withMetacelloLoadSessionDo: aBlock  aBlock valuecreateBaselineOfMethod: selector inCategory: category  methodSpec := MetacelloBaselineOfMethodSpec new     project: project;     selector: selector;     category: category;     yourselfsetPreLoadDoIt: aSymbol  preLoadDoIt := aSymbolfile: aString  self root file: aString constructor: selfdefaultAction  ^self projectSpecbaselineVersion113ProjectToolBox: spec  < version: '1.1.3-baseline'>  spec for: #outer do: [ spec           package: 'Example-Core';           package: 'Example-Test' ]repository: anObject constructor: aVersionConstructor  aVersionConstructor repositoryForRepositories: anObjectlookupProjectSpecFor: aProjectSpec  | registration |  registration := MetacelloProjectRegistration registrationForProjectSpec: aProjectSpec ifAbsent: [:new |  new ] ifPresent: [:existing :new |  (existing hasLoadConflicts: new) ifTrue: [ ((existing canUpgradeTo: new) ifTrue: [ MetacelloAllowProjectUpgrade new ] ifFalse: [ (existing canDowngradeTo: new) ifTrue: [ MetacelloAllowProjectDowngrade new ] ifFalse: [ MetacelloAllowConflictingProjectUpgrade new ] ])                 existingProjectRegistration: existing;                 newProjectRegistration: new;                 signal ] ifFalse: [ new ] ].  ^registration projectSpecsetUpConfigurationOfProjectToolBox  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectToolBox-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'postloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #postloadDoIt) asString) .   (MCMethodDefinition className: className asString selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #preloadDoIt) asString) .   (MCMethodDefinition className: className asString selector: 'symbolicVersionExplicitlyDoesNotExistProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #symbolicVersionExplicitlyDoesNotExistProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version100ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version100ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version101ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version101ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version102ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version102ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version103ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version103ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version104ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version104ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version105ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version105ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version106ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version106ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version107ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version107ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version108ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version108ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version109ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version109ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version110ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version110ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version111ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version111ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version112ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version112ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion113ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion113ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version113ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version113ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version114ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version114ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version115ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version115ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version116ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version116ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version117ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version117ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version118ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version118ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version119ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version119ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version120ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version120ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version121ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version121ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version122ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version122ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version123ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version123ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion124ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion124ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version124ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version124ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version125ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version125ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version126ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version126ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version127ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version127ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version128ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version128ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version129ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version129ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version130ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version130ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version131ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version131ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version132ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version132ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version133ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version133ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version134ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version134ProjectToolBox:) asString) .   (MCMethodDefinition className: className asString selector: 'version135ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version135ProjectToolBox:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())project  ^self spec projectdefaultPlatformAttributes  ^MetacelloPlatform current defaultPlatformAttributesbleedingEdge  < defaultSymbolicVersion: #bleedingEdge>  ^self defaultBleedingEdgeVersiondefaultSymbolicVersionResolverBlock  ^self defaultSymbolicVersionResolverBlock: self configurationhasNoPackage: aBoolean  hasNoPackage := aBooleanmetacelloRegistrationHash  ^String stringHash: self file initialHash: super metacelloRegistrationHashcacheNames  ^cacheNamesload  overrideRepositories := Array with: self cacheRepository.  self loadDirective loadWithPolicy: selfisExternal  ^falseisResumable  ^truelatestVersionMatching: versionPatternString includedBlessings: included  ^self latestVersionMatching: versionPatternString includedBlessings: included excludedBlessings: self excludeFromLatestVersionperformCurrentVersionTestAgainst: vrsn operator: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader  | currentVersion existing new |  vrsn ifNil: [ ^false ].  self useDetermineVersionForLoad ifTrue: [ | prjct cv |        self hasOverride ifTrue: [ self error: 'unexpected logic combination: useDeterminVersionForLoad & hasOverride' ].        prjct := self projectSpec projectClassProject.        prjct loader: anMCLoader.        (cv := prjct currentVersion) == nil ifTrue: [ ^false ].        (targetVersionStatus includes: cv versionStatus) ifTrue: [ ^cv perform: anOperator with: vrsn ].        ^false ].  true ifTrue: [ ^false ].  (self hasOverride not or: [ targetVersionStatus ~= #(#allLoadedToSpec) ]) ifTrue: [ ^false ].  (self overrideProjectSpec allPackagesLoaded: anMCLoader) ifFalse: [ ^false ].  (self overrideProjectSpec isPartiallyLoaded: self overrideProjectSpec copy loader) ifFalse: [ ^false ].  (currentVersion := self overrideProjectSpec versionOrNil) ifNil: [ ^false ].  currentVersion = vrsn ifTrue: [ ^true ].  existing := self overrideProjectSpec asProjectRegistration.  new := self projectSpec asProjectRegistration.  ^currentVersion > vrsn ifTrue: [ (MetacelloAllowProjectDowngrade new           existingProjectRegistration: existing;           newProjectRegistration: new;           signal) == existing ] ifFalse: [ (MetacelloAllowProjectUpgrade new           existingProjectRegistration: existing;           newProjectRegistration: new;           signal) == existing ]saveProject  | pkgSpec |  (pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].  ^pkgSpec savePackagestackCacheFor: cacheName cacheClass: cacheClass at: key doing: aBlock  self useStackCacheDuring: [:dict |  | cache |        cache := dict at: cacheName ifAbsent: [  ].        cache ~~ nil ifTrue: [ | value hasEntry |              hasEntry := true.              value := cache at: key ifAbsent: [ hasEntry := false ].              hasEntry ifTrue: [ ^value ] ] ifFalse: [ cache := cacheClass new.              dict at: cacheName put: cache ].        ^aBlock value: cache ] defaultDictionary: nilunlock  ^self execute: #unlock args: #()configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent  aMember methodUpdateSelector == #remove: ifTrue: [ aStream nextPutAll: 'removeProject: ' , self name printString ] ifFalse: [ self projectReference == nil ifTrue: [ ^self ].        aStream nextPutAll: self projectLabel , ': ' , self projectName printString , ' '.        (aMember methodUpdateSelector == #copy: and: [ self projectReference hasNonVersionStringField ]) ifTrue: [ aStream nextPutAll: 'copyFrom: ' , aMember sourceName printString , ' ' ].        self projectReference configShortCutMethodOn: aStream member: aMember indent: indent + 1 ].  lastCascade ifTrue: [ aStream nextPut: $. ] ifFalse: [ aStream           nextPut: $;;           cr ]downloadJSON: url eTagsCache: eTagsCache eTagsKey: eTagsKey username: username pass: pass  ^self downloadJSON: url username: username pass: passprintOn: aStream  aStream     nextPutAll: self label;     nextPut: $:;     space;     nextPutAll: self explanation.  self reasonCode ~~ #none ifTrue: [ aStream           space;           nextPut: ${;           space;           print: self reasonCode;           space;           nextPut: $} ].  (self configurationClass ~~ nil or: [ self callSite ~~ nil ]) ifTrue: [ aStream           space;           nextPut: $[;           space.        self configurationClass ~~ nil ifTrue: [ aStream                 print: self configurationClass name;                 space ].        self callSite ~~ nil ifTrue: [ aStream                 print: self callSite name;                 space ].        aStream nextPut: $] ]mapRemove: aMemberSpec into: map  map removeKey: aMemberSpec name ifAbsent: [  ]postLoad: packageOrVersionSpec  version111ProjectToolBox: spec  < version: '1.1.1-baseline'>  spec for: #common do: [ spec package: 'Example-Core'.        spec for: #nested do: [ spec package: 'Example-Base' ] ].  spec for: #extra do: [ spec package: 'Example-Test' ]projectLabel  ^self project labelversion: anObject constructor: aVersionConstructor  self error: 'version: not allowed in a baseline project spec'resolveProjectSpec  ^self projectReferenceimport: aString provides: aCollection  self root import: aString provides: aCollection constructor: selftestVersion16  self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0')doLoadRequiredFromArray: anArray  | displayString oldPolicy oldBypassProgress |  displayString := self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloNotification signal: 'Loading ' , displayString , '...'.  oldPolicy := loaderPolicy.  oldBypassProgress := MetacelloPlatform current bypassProgressBars.  self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].  [ | fetchLoader |  fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).  MetacelloPlatform current do: [ fetchLoader doLoad ] displaying: 'Loading ' , displayString.  MetacelloNotification signal: '...finished ' , self versionNumber printString.  ^fetchLoader ] ensure: [ MetacelloPlatform current bypassProgressBars: oldBypassProgress.        loaderPolicy := oldPolicy ]setUpIssue156ConfigurationOfProjectGoo  | reference className definitionArray |  reference := GoferVersionReference name: 'ConfigurationOfProjectGoo-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString selector: 'version10Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue156:) asString) .   (MCMethodDefinition className: className asString selector: 'version11Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version11Issue156:) asString) .   (MCMethodDefinition className: className asString selector: 'version20Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue156:) asString) .   (MCMethodDefinition className: className asString selector: 'version30Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue156:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())currentVersionAgainst: resolvedPackageAndProjectNames  ^nilprojectSpec  ^baselineProjectSpec ifNil: [ self assert: configurationProjectSpec notNil.        configurationProjectSpec ]confirm: aString  ^(Smalltalk hasClassNamed: #UIManager) ifTrue: [ (Smalltalk classNamed: #UIManager) default perform: #confirm: with: aString ] ifFalse: [ Warning signal: aString.        true ]suspendSystemUpdateEventsDuring: aBlock  ^aBlock valueresolveSpec: pkgSpec from: repositorySpecs  | gofer |  gofer := MetacelloGofer new.  gofer disablePackageCache.  (self repositoriesFrom: repositorySpecs ignoreOverrides: true) do: [:repo |  gofer repository: repo ].  ^self resolveSpec: pkgSpec with: gofermethodUpdateSelector  ^#with:preLoadDoIt  ^preLoadDoItrepositoryMap  repositoryMap == nil ifTrue: [ repositoryMap := Dictionary new ].  ^repositoryMaprepositoryDescriptions  ^(self configurationProjectSpecIfAbsent: [ self baselineProjectSpec ]) repositoryDescriptionstestAddGroupB  | packages group |  packages := self packagesSpec.  packages add: {(self groupSpec           name: 'Platform';           includes: 'Core';           yourself) .         (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself)}.  group := packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self deny: (group includes includes: 'Core').  self assert: (group includes includes: 'Tests')includesForPackageOrdering  ^self includesinfo  ^selfonUpgradeUseLoaded  self onUpgrade: [:ex :loaded :incoming |  ex useLoaded ]allPackagesForSpecs: pkgSpecs visited: visited  | coll |  coll := Dictionary new.  pkgSpecs do: [:pkgSpec |  (pkgSpec resolveToAllPackagesIn: self spec visited: visited) do: [:pkg |  coll at: pkg name put: pkg ] ].  ^coll values asOrderedCollectionloadingSpecLoader  ^(MetacelloLoadingMCSpecLoader on: self spec)     shouldDisablePackageCache: self shouldDisablePackageCache;     loaderPolicy: self loaderPolicy copy;     yourselfloadPreloadDirective: aPreloadDirective  | block |  (block := aPreloadDirective spec preLoadDoItBlock) ~~ nil ifTrue: [ aPreloadDirective evaluateSupplyingAnswers: [ block valueWithPossibleArgs: (Array with: aPreloadDirective loader with: aPreloadDirective spec) ].        MetacelloNotification signal: 'Evaluated -> ' , aPreloadDirective spec label , ' >> ' , aPreloadDirective spec preLoadDoIt value asString ]symbolicMethodSelectorAndPragma: aSelector symbolicVersionSymbol: symbolicVersionSymbol on: strm  strm     nextPutAll: aSelector asString , ' spec';     cr;     tab;     nextPutAll: '<symbolicVersion: #' , symbolicVersionSymbol asString printString;     nextPutAll: '>';     crpackageSpec  ^packageSpecbaselineGithubReferenceVI: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>baselineGithubReferenceVI:'.        spec           baseline: 'External Core' with: [ spec                 className: 'BaselineOfExternal';                 loads: 'Core';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           baseline: 'External Tests' with: [ spec                 className: 'BaselineOfExternal';                 loads: 'Tests';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]blessing: aBlockOrString constructor: aVersionConstructor  aVersionConstructor blessingForVersion: aBlockOrStringdefaultRepositoryDescription  ^self class defaultRepositoryDescriptionmethodSource  | strm |  strm := WriteStream on: String new.  self methodSelectorAndPragma: self selector imports: self imports versionString: self versionString on: strm.  self methodSection: self pre: [:methodSection :indent |  strm           cr;           tab: indent;           nextPutAll: 'spec for: ' , methodSection attributePrintString , ' do: [';           cr.        methodSection versionSpec configMethodOn: strm last: methodSection methodSections isEmpty indent: indent + 1 ] last: false post: [:methodSection :indent :last |  strm nextPutAll: ' ].'.        (last or: [ indent = 1 or: [ methodSection methodSections isEmpty and: [ indent = 1 ] ] ]) ifTrue: [ strm cr ] ] indent: 0.  ^strm contentsprojectReferenceSpec  ^self project projectReferenceSpecasString  ^self printStringproject  ^projectrepository: aString  self repositoriesSpec add: aStringprojectArg  ^projectArgcriticalWarningReasonCodes  ^super criticalWarningReasonCodes , #(#noLoadableVersions #noTests #testDeprecation #loadDeprecation #noVersionSpecified #missingRecommendedProjectSpecField)lesson02  ^Lesson title: 'Lesson 2' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version02:."For version 0.2, we''ve simply updated the package version to ''Example-Core-anon.9'', which can be confirmed by printing the following expression:"  (MetacelloTutorialConfig project version: ''0.2'') spec.ProfStef next.'setUp  super setUp.  self     setUpVersionReferences;     setUpMonticelloRepositorypushLoadDirective: aLoaderDirective during: aBlock  | oldRoot |  self loadDirective add: aLoaderDirective.  oldRoot := loadDirective.  loadDirective := aLoaderDirective.  aBlock ensure: [ loadDirective := oldRoot ]aPackageIsLoaded  ^aPackageIsLoadedpreLoadDoIt  ^nilversionString  | strm |  strm := WriteStream on: String new.  self printOn: strm.  ^strm contentscreateBitbucketRepository: aRepositorySpec  | cl |  cl := Smalltalk at: #MCBitbucketRepository.  ^cl location: aRepositorySpec descriptionbaseline40MethodSourceProjectFoe  ^(self class sourceCodeAt: #baseline40ProjectFoe:) asStringdefaultTimeout  ^60gtInspectorProjectsIn: composite  < gtInspectorPresentationOrder: 40>  composite list     title: 'Projects';     display: [ self projects ]project: projectName  self addStatement: #projectArg: args: {projectName}packagesNeedSavingVisited: visitedProjects using: repos into: aCollection  | prjct clsName vrsn |  prjct := self resolveToLoadableSpec.  (visitedProjects includes: (clsName := prjct className)) ifTrue: [ ^self ].  visitedProjects add: clsName.  (vrsn := self versionOrNil) == nil ifTrue: [ ^self ].  vrsn spec packagesNeedSavingVisited: visitedProjects into: aCollectionconflictOf12: spec  < version: '1.2.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>conflictOf12:'.        spec author: 'dkh'.        spec timestamp: '6/1/2012 14:46' ].  spec for: #custom do: [ spec configuration: 'ExternalX' with: [ spec                 operator: #=;                 version: '0.9.2';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]defaultTimeout  ^60000modifySymbolicVersionMethodFor: versionSymbol symbolicVersionSpecsDo: aBlock  | constructor coll pragma |  constructor := self constructor.  coll := constructor extractSymbolicVersionPragmas at: versionSymbol ifAbsent: [ ^nil ].  coll size > 1 ifTrue: [ self error: 'More than one pragma defining ' , versionSymbol printString ].  pragma := coll at: 1.  methodSpec := MetacelloSymbolicVersionMethodSpec new     project: project;     selector: (MetacelloPlatform current selectorForPragma: pragma);     category: (project configuration class whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma: pragma));     versionString: versionSymbol;     yourself.  (constructor extractSymbolicVersionSpecsFor: versionSymbol) do: [:symbolicVersionSpec |  (aBlock value: symbolicVersionSpec) ifTrue: [ self methodSpec addMethodSection: symbolicVersionSpec attributes versionString: symbolicVersionSpec versionString ] ]aPackageNotLoaded  ^aPackageNotLoadedprojectVersion  ^projectVersionintroductionText  ^'Covers project reference specifications:	1. Open a code browser on the MetacelloTutorialConfig class:"		MetacelloTutorialConfig browse.	"2. In the browser view the ''--all--'' category.	3. Have fun!"'difference: otherVersionSpec  | report myProjectSpecs otherProjectSpecs |  report := MetacelloVersionDiffReport new.  myProjectSpecs := Dictionary new.  self projectDo: [:projectSpec |  myProjectSpecs at: projectSpec name put: projectSpec ] packageDo: [:ignored |   ] groupDo: [:ignored |   ].  otherProjectSpecs := Dictionary new.  otherVersionSpec projectDo: [:projectSpec |  otherProjectSpecs at: projectSpec name put: projectSpec ] packageDo: [:ignored |   ] groupDo: [:ignored |   ].  myProjectSpecs valuesDo: [:myProjectSpec |  | otherProjectSpec |        otherProjectSpec := otherProjectSpecs at: myProjectSpec name ifAbsent: [  ].        otherProjectSpec == nil ifTrue: [ report removals at: myProjectSpec name put: {myProjectSpec versionString .                     ''} ] ifFalse: [ myProjectSpec versionString = otherProjectSpec versionString ifFalse: [ report modifications at: myProjectSpec name put: {myProjectSpec versionString .                           otherProjectSpec versionString} ] ] ].  otherProjectSpecs valuesDo: [:otherProjectSpec |  (myProjectSpecs at: otherProjectSpec name ifAbsent: [  ]) == nil ifTrue: [ report additions at: otherProjectSpec name put: {'' .                     otherProjectSpec versionString} ] ].  ^reportloadListForVersion: vrsn  ^(self loads == nil or: [ self loads isEmpty ]) ifTrue: [ vrsn spec defaultPackageNames ] ifFalse: [ self loads ]testVersion17  self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-0').  self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-beta.0').  self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-beta')onWarningLog  self onWarning: [:ex |  MetacelloNotification signal: ex description.        ex resume ]doLoad  self loaderPolicy copy loadversionString: aStringOrSymbol  aStringOrSymbol isSymbol ifTrue: [ self error: 'Version string ' , aStringOrSymbol printString , ' for version method must be a String' ].  super versionString: aStringOrSymbolresolveToPackagesIn: aVersionSpec visited: visited  ^#()isEmpty  ^self configurationProjectSpecs isEmpty and: [ self baselineProjectSpecs isEmpty ]baseline07: spec  < version: '0.7-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/Project'.        spec           package: 'Project-Core' with: [ spec requires: 'Example-Core' ];           package: 'Project-Tests' with: [ spec requires: #('Project-Core' 'Example-Tests') ];           package: 'Example-Core' with: [ spec repository: 'http://www.example.com/Example' ];           package: 'Example-Tests' with: [ spec                 requires: 'Example-Core';                 repository: 'http://www.example.com/Example' ];           package: 'Example-AddOn' with: [ spec                 requires: 'Example-Core';                 repository: 'http://www.example.com/Example' ] ]ensuredMap  ensuredMap == nil ifTrue: [ ensuredMap := Dictionary new ].  ^ensuredMapisExplicit  ^falseversion11Issue156: spec  < version: '1.1.0'>  spec for: #common do: [ spec           baseline: 'Goo' with: [ spec repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           yourself ]baseline31Fan: spec  < version: '3.1-baseline'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec postLoadDoIt: #postLoad31baseline.        spec           package: 'GoferBar';           package: 'GoferBeau' with: [ spec                 requires: 'GoferBar';                 includes: #('GoferFoo') ];           package: 'GoferFar' with: [ spec requires: #('GoferFoo') ];           yourself.        spec           project: 'GoferFoo' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '2.0';                 loads: 'GoferFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]getConfigurationProjectUnconditionalLoad: unconditionalLoad  ^(self getConfigurationUnconditionalLoad: unconditionalLoad) projecthasNoLoadConflicts: aMetacelloRepositoriesSpec  | repositorySpecs anotherRepositorySpecs |  repositorySpecs := self map values sort: [:a :b |  a description <= b description ].  anotherRepositorySpecs := aMetacelloRepositoriesSpec map values sort: [:a :b |  a description <= b description ].  repositorySpecs size ~= anotherRepositorySpecs size ifTrue: [ ^false ].  1 to: repositorySpecs size do: [:index |  | repoSpec anotherRepoSpec |        repoSpec := repositorySpecs at: index.        anotherRepoSpec := anotherRepositorySpecs at: index.        (repoSpec hasNoLoadConflicts: anotherRepoSpec) ifFalse: [ ^false ] ].  ^truebaseline50Fan: spec  < version: '5.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '5.0';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]onLock: aBlock  self options at: #onLock put: aBlockfile  ^self externalReference nameloadLinearLoadDirective: aLoaderDirective gofer: aGofer  self finalizeLoad: aGofer.  super loadLinearLoadDirective: aLoaderDirective gofer: aGoferversionString  | strm |  strm := WriteStream on: String new.  self printOn: strm.  ^strm contentsisPartiallyCurrentAgainst: resolvedPackageAndProjectNames  | mcLoader status |  status := MetacelloMCPartiallyLoadedStatus new.  mcLoader := self loader.  self specsNamed: resolvedPackageAndProjectNames projectDo: [:prj |  | vrsn currentVersion |        status hasNoProject: false.        vrsn := prj versionOrNil.        vrsn ~~ nil ifTrue: [ (currentVersion := prj relativeCurrentVersion) ~~ nil ifTrue: [ status vrsnStatus add: currentVersion versionStatus ] ].        currentVersion ~~ nil ifTrue: [ status aProjectIsLoaded: true.              (currentVersion perform: #= with: vrsn) ifTrue: [ status aLoadedProjectIsExact: true ] ifFalse: [ (currentVersion perform: prj projectReference operator with: vrsn) ifTrue: [ status aLoadedProjectIsCurrent: true ] ifFalse: [ status aLoadedProjectIsNotCurrent: true ] ] ] ifFalse: [ status aProjectNotLoaded: true ] ] packageDo: [:pkg |  status hasNoPackage: false.        pkg currentPackageLoaded: [:versionInfos :file |  | wcName wcRef fileRef exact current |              status aPackageIsLoaded: true.              versionInfos isEmpty ifTrue: [ status aLoadedPackageIsNotCurrent: true ] ifFalse: [ exact := current := false.                    versionInfos do: [:vi |  wcName := vi name.                          fileRef := GoferResolvedReference name: file.                          wcRef := GoferResolvedReference name: wcName.                          (wcRef compare: fileRef using: #=) ifTrue: [ exact := true ] ].                    exact ifTrue: [ status aLoadedPackageIsExact: true ] ifFalse: [ versionInfos do: [:vi |  wcName := vi name.                                fileRef := GoferResolvedReference name: file.                                wcRef := GoferResolvedReference name: wcName.                                (wcRef compare: fileRef using: #>=) ifTrue: [ current := true ] ].                          current ifTrue: [ status aLoadedPackageIsCurrent: true ] ifFalse: [ status aLoadedPackageIsNotCurrent: true ] ] ] ] notLoaded: [ status aPackageNotLoaded: true ] using: mcLoader ] groupDo: [:ignoredGroup |  status abort: true.        ^status ].  ^statuson: aConfig project: aProject  self calculate: aConfig project: aProjectmethodSectionAttributes  | attributes |  attributes := Set new.  self methodSectionsDo: [:methodSection |  attributes addAll: methodSection attributes ].  ^attributesrepositoriesForSpec: aBlock  self with: self root repositories during: aBlockbaseline10B: spec  < version: '1.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'C' with: [ spec                 className: 'MetacelloTestConfigurationOfIssue77C';                 loads: #('GoferFoo');                 versionString: '1.2';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           yourself ]version07: spec  < version: '0.7' imports: #('0.7-baseline')>  spec for: #common do: [ spec           package: 'Example-Core' with: 'Example-Core-anon.12';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1' ]packagesForSpecNamed: aString  ^self packagesForSpecNamed: aString ifAbsent: [ ^#() ]methodSectionsDo: aBlock  self methodSection: self do: aBlockload: required  self load: required onProjectDownGrade: [:ex :existing :new |  ex allowEvenIfLocked ] onProjectUpgrade: [:ex :existing :new |  ex allowEvenIfLocked ]import: aString  importName := aStringignoreImage: aBool  self loaderPolicy ignoreImage: aBooltestVersion18  self deny: (self versionClass fromString: '1.0') < (self versionClass fromString: '1').  self deny: (self versionClass fromString: '1.0') < (self versionClass fromString: '1-0')packageSet  ^MetacelloTestsPackageSet named: nameaddMethodSection: methodSection  methodSection parent: self.  self methodSections add: methodSectionprojectName  ^self existingProjectRegistration projectNameprojectAttributes: aList  projectAttributes := aListextractPragmas: pragmaKeyword for: aClass into: versionDict  | versionString pragmas |  (Pragma allNamed: pragmaKeyword in: aClass) do: [:pragma |  versionString := pragma argumentAt: 1.        pragmas := versionDict at: versionString ifAbsent: [ | list |              list := OrderedCollection new.              versionDict at: versionString put: list.              list ].        pragmas add: pragma ]projectArg: anObject  projectArg := anObjectversion128ProjectToolBox: spec  < version: '1.2.8-baseline' imports: #('1.2.7-baseline')>  spec for: #common do: [ spec project: 'Example Project' with: [ spec                 preLoadDoIt: nil;                 postLoadDoIt: nil ] ]applyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock  copyBlock value: selfconfiguration  ^configurationloadPackageDirectives: pkgLoads gofer: aGofer  MetacelloPlatform current do: [ | goferLoad loadBlock answers |        goferLoad := MetacelloGoferLoad on: aGofer.        answers := OrderedCollection new.        pkgLoads do: [:packageLoadDirective |  | resolvedReference |              aGofer disablePackageCache.              (resolvedReference := self resolvePackageSpec: packageLoadDirective spec gofer: aGofer) ~~ nil ifTrue: [ goferLoad addResolved: resolvedReference.                    answers addAll: packageLoadDirective spec answers.                    packageLoadDirective resolvedReference: resolvedReference ] ].        MetacelloNotification signal: 'Starting atomic load'.        loadBlock := [ goferLoad execute.        pkgLoads do: [:packageLoadDirective |  packageLoadDirective resolvedReference == nil ifTrue: [ MetacelloNotification signal: 'Already Loaded -> ' , packageLoadDirective file level: 2 ] ifFalse: [ MetacelloNotification signal: 'Loaded -> ' , packageLoadDirective file , ' --- ' , packageLoadDirective repository repositoryDescription , ' --- ' , packageLoadDirective resolvedReference repository description level: 2.                    packageLoadDirective resolvedReference workingCopy repositoryGroup addRepository: packageLoadDirective repository ] ].        MetacelloPlatform current clearCurrentVersionCache ].        answers notEmpty ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ] ifFalse: [ loadBlock value ].        MetacelloNotification signal: 'Finished atomic load' ] displaying: 'Atomic Load...'copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock  | copy |  aMetacelloProjectRegistration configurationProjectSpecIfPresent: [:spec |  copy := spec copy.        aBlock value: copy.        aMetacelloProjectRegistration configurationProjectSpec: copy ] ifAbsent: [ aMetacelloProjectRegistration baselineProjectSpecIfPresent: [:spec |  copy := spec copy.              aBlock value: copy.              aMetacelloProjectRegistration baselineProjectSpec: copy ] ifAbsent: [ aBlock value: nil ] ]unregister  | spec |  self setDefaultsAndValidate: self projectSpec copy.  spec := self projectSpec.  MetacelloProjectRegistration registrationForProjectSpec: spec ifAbsent: [:ignored |   ] ifPresent: [:existing :new |  existing unregisterProject ].  self root: spectitle  ^'atomic load'baseline35Foo: spec  < version: '3.5'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.31';           package: 'GoferBeau' with: 'GoferBeau-dkh.54';           yourself.        spec           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferFaux');           yourself ]groups  | groups |  groups := OrderedCollection new.  self spec projectDo: [:ignored |   ] packageDo: [:ignored |   ] groupDo: [:grp |  groups add: grp ].  ^groupsfetch: required  actionArg := #fetch: -> {required}normalVersion  normalVersion ifNil: [ normalVersion := #() ].  ^normalVersionattributes  attributes ifNil: [ attributes := OrderedCollection new ].  ^attributesprepostLoadsDo: aBlock  self loadDirectives do: [:directive |  directive prepostLoadDo: aBlock ]baselineOrConfigurationName  ^self argumentAt: 3isLoadedMatchConstraintsAgainst: resolvedPackageAndProjectNames  (self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isLoadedMatchConstraints: [:ignored |  ^true ].  ^falsevalidateBaselineProject  | project |  project := self validateProjectCreationFrom: self configurationClass onError: [:ex |  self recordValidationError: 'Error creating project: ' , ex description , ' to reproduce evalutate the following: ''' , self configurationClass name asString , ' project''' callSite: #validateBaselineProject reasonCode: #projectCreationError.        ^self validationReport ].  ^self validateBaselineProject: projectprojectClass  self className == nil ifTrue: [ ^nil ].  ^Smalltalk at: self className asSymbol ifAbsent: [  ]options: aDictionary  options := aDictionaryproject  | constructor |  ^project ifNil: [ constructor := MetacelloVersionConstructor on: self.        project := constructor project.        project loader: MetacelloNullRecordingMCSpecLoader new.        project ]ensureLoadedForDevelopmentUsing: mcLoader  | ensured |  ensured := mcLoader ensuredMap at: self name ifAbsent: [ nil ].  self projectClass ~~ nil ifTrue: [ | vrsn |        vrsn := self versionOrNil.        vrsn ~~ nil ifTrue: [ (self ensureConfigurationLoaded: vrsn ensured: ensured) ifTrue: [ mcLoader ensureForDevelopment ifTrue: [ | pc |                          (pc := self projectClass) ~~ nil ifTrue: [ MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo #versionConstructor #loadableSpecNames) , {pc} ].                          self ensureLoadUsing: mcLoader ] ifFalse: [ self projectPackage fetchUsing: mcLoader ].                    mcLoader ensuredMap at: self name put: #latest ].              ^self ] ].  ensured == nil ifTrue: [ mcLoader ensureForDevelopment ifTrue: [ | pc |              (pc := self projectClass) ~~ nil ifTrue: [ MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo #versionConstructor #loadableSpecNames) , {pc} ].              self ensureLoadUsing: mcLoader ] ifFalse: [ self fetchUsing: mcLoader ].        mcLoader ensuredMap at: self name put: #present ]stableVersionDMethodSourceSymbolic  ^(self class sourceCodeAt: #stableVersionD:) asStringloadUsing: aLoaderDirective gofer: aGofer  self loadDirectives isEmpty ifTrue: [ ^self ].  aLoaderDirective loadLinearLoadDirective: self gofer: aGoferpossibleVersions  self shouldNotImplementasProjectRegistration  ^MetacelloProjectRegistration fromMCConfigurationProjectSpec: selfcompareVersions  ^Lesson title: '6. Compare versions' lesson: '"Occasionally, it is useful to view the mcz and project version changes between the #development symbolic version and the #stable symbolic version:"	(MetacelloToolBox compareVersionsIn: ConfigurationOfExample) inspect.	ProfStef next.'allProjectsDo: aBlock  self allProjectsDo: aBlock withTraversedProjects: OrderedCollection newprojectPackage: aProjectPackage  self shouldBeMutable.  projectPackage := aProjectPackageproject: aString constructor: aVersionConstructor  aVersionConstructor projectForVersion: aStringbaselineVersion20Issue154: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec           project: 'MetacelloExample' with: [ spec                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]extractRepositoryFrom: zipFile to: directory  ZipArchive new     readFrom: zipFile;     extractAllTo: directory asFileReference.  zipFile asFileReference deleteblessing  blessing == nil ifTrue: [ ^self project valueHolderSpec           value: self project defaultBlessing;           yourself ].  ^blessingonConflict: aBlock  self addStatement: #onConflict: args: {aBlock}addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock  | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |  versionSpec := self createVersionSpec: self methodSpec versionString.  dependencyMap := self buildMapFrom: dependecies for: packageList.  includesMap := self buildMapFrom: includes for: packageList.  filesMap := self buildMapFrom: files for: packageList.  repositoriesMap := self buildMapFrom: repositories for: packageList , projectList.  preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.  postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.  supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.  projectList do: [:projectName |  | spec |        spec := self createProjectReferenceSpec: projectName.        repositoriesMap at: projectName ifPresent: [:repositoriesList |  repositoriesList do: [:repoString |  spec repository: repoString ] ].        versionSpec packages merge: spec ].  packageList do: [:packageName |  | spec |        spec := self createPackageSpec: packageName.        dependencyMap at: packageName ifPresent: [:dependencyList |  spec requires: dependencyList ].        includesMap at: packageName ifPresent: [:includesList |  spec includes: includesList ].        filesMap at: packageName ifPresent: [:file |  spec file: file ].        repositoriesMap at: packageName ifPresent: [:repositoriesList |  repositoriesList do: [:repoString |  spec repository: repoString ] ].        preLoadDoItsMap at: packageName ifPresent: [:preLoad |  spec preLoadDoIt: preLoad ].        postLoadDoItsMap at: packageName ifPresent: [:postLoad |  spec postLoadDoIt: postLoad ].        supplyingAnswersMap at: packageName ifPresent: [:answer |  spec answers: answer ].        versionSpec packages merge: spec ].  groups do: [:assoc |  | spec |        spec := self createGroupSpec: assoc key.        spec includes: assoc value.        versionSpec packages merge: spec ].  aBlock value: versionSpec.  self methodSpec addMethodSection: sectionAttributeOrPath asMetacelloAttributePath versionSpec: versionSpeclatestVersionMatching: versionPatternString includedBlessings: included  ^nilbaseline: aString constructor: aVersionConstructor  aVersionConstructor baselineForVersion: aStringversionDo: aBlock  testValueHolderMergeSpec  | valueHolderA valueHolderB valueHolder |  valueHolderA := self valueHolderSpec     value: 'an Object';     yourself.  valueHolderB := self valueHolderSpec     value: 1.1;     yourself.  valueHolder := valueHolderA mergeSpec: valueHolderB.  self assert: valueHolder value equals: 1.1project  ^self projectWith: #()group: aString overrides: aStringOrCollection  self root group: aString overrides: aStringOrCollection constructor: selfdetect: aBlock  ^self detect: aBlock ifNone: [ self error: 'Object is not in the collection.' ]hasNoLoadConflicts: aMetacelloProjectSpec  ^self className = aMetacelloProjectSpec className and: [ (self compareVersionsEqual: aMetacelloProjectSpec) and: [ self operator == aMetacelloProjectSpec operator ] ]description  ^'Version ' , self versionString printString , ' is not defined in ' , self project label , '. Possible versions include: ' , self possibleVersions printStringresolveProjectVersionPattern: aString  | patternString tagDictionary matchingTags tagAssocs sortedMatchingTags theTag |  self projectPath ifNil: [ self error: 'projectPath must be set to resolve project version pattern.' ].  patternString := (self class projectVersionFromString: aString) asString.  tagDictionary := self downloadJSONTags.  tagAssocs := tagDictionary keys collect: [:tagName |  | tagVersion |        tagVersion := self class projectVersionFromString: tagName.        tagVersion -> tagName ].  matchingTags := tagAssocs select: [:assoc |  assoc key match: patternString ].  matchingTags isEmpty ifTrue: [ projectVersion := aString.        ^self error: 'No tags matching the pattern ' , aString printString , ' found for repository description ' , self description printString ].  sortedMatchingTags := matchingTags asArray sort: [:a :b |  a key <= b key ].  theTag := sortedMatchingTags last.  projectVersionPattern := aString.  projectVersion := theTag valuedescription  ^self basicSpec description valueattributes: aCollectionOrSymbol  attributes := aCollectionOrSymbol asMetacelloAttributeListconfigMethodCascadeOn: aStream lastCascade: lastCascade  aStream nextPutAll: 'repository: ' , self description printString.  (self username isEmpty not or: [ self password isEmpty not ]) ifTrue: [ aStream nextPutAll: ' username: ' , self username printString , ' password: ' , self password printString ].  lastCascade ifFalse: [ aStream           nextPut: $;;           cr ]merge: aSpec  self subclassResponsibilitysetUpVersionReferences  versionReferences := OrderedCollection new.  versionReferences     add: (GoferVersionReference name: 'GoferBar.gemstone-dkh.68');     add: (GoferVersionReference name: 'GoferBar.gemstone-dkh.69');     add: (GoferVersionReference name: 'GoferBar.gemstone-dkh.70');     add: (GoferVersionReference name: 'GoferBar-dkh.68');     add: (GoferVersionReference name: 'GoferBar-dkh.69');     add: (GoferVersionReference name: 'GoferBar-dkh.70');     yourselfversionSpec  ^self specgoferBranch: branchName project: commitMessage  | pkgSpec |  pkgSpec := self projectPackage.  pkgSpec file: pkgSpec name , '.' , branchName.  ^pkgSpec goferBranchPackage: branchName message: commitMessageprojectClass  ^Smalltalk at: #MetacelloCypressBaselineProjecttestVersion12  self deny: (self versionClass fromString: '1.0') <= (self versionClass fromString: '0.7')packageSpecsInLoadOrderFor: aVersionSpec  | orderedPackageSpecs groupSpecs moved lastMovedSpecs count terminationLimit map specsWithIncludes firstTime groupLoops |  map := self map.  orderedPackageSpecs := OrderedCollection new.  groupSpecs := Set new.  self list do: [:member |  | spec |        spec := map at: member name ifAbsent: [  ].        (spec == nil or: [ orderedPackageSpecs includes: spec ]) ifFalse: [ spec projectDo: [:prjSpec |  orderedPackageSpecs add: prjSpec ] packageDo: [:pkgSpec |  orderedPackageSpecs add: pkgSpec ] groupDo: [:groupSpec |  groupSpecs add: groupSpec ] ] ].  orderedPackageSpecs isEmpty ifTrue: [ ^orderedPackageSpecs , groupSpecs asOrderedCollection ].  moved := true.  count := 0.  terminationLimit := orderedPackageSpecs size * 2.  groupLoops := IdentitySet new.  [ moved ] whileTrue: [ count := count + 1.        count > terminationLimit ifTrue: [ self error: 'Apparent loop in before/after dependency definitions' ].        moved := false.        orderedPackageSpecs copy do: [:packageSpec |  moved := moved or: [ self sortPackageSpecs: orderedPackageSpecs packageSpec: packageSpec groupLoops: groupLoops for: aVersionSpec ] ] ].  lastMovedSpecs := Set new.  moved := true.  count := 0.  specsWithIncludes := orderedPackageSpecs select: [:pkgSpec |  pkgSpec includesForPackageOrdering isEmpty not ].  firstTime := true.  [ moved ] whileTrue: [ | result |        count := count + 1.        count > 14 ifTrue: [ self error: 'Apparent loop in before/after dependency definitions' ].        moved := false.        result := Set new.        specsWithIncludes do: [:packageSpec |  result addAll: (self applyIncludesTo: orderedPackageSpecs for: packageSpec firstTime: firstTime for: aVersionSpec) ].        result size = lastMovedSpecs size ifTrue: [ result do: [:name |  (lastMovedSpecs includes: name) ifFalse: [ moved := true ] ] ] ifFalse: [ moved := true ].        lastMovedSpecs := result.        firstTime := false ].  ^orderedPackageSpecs , groupSpecs asOrderedCollectiontestHasGroups  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--groups=core,tests').  self assert: cli hasGroups.  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self deny: cli hasGroupscalculateRepositoryDirectory  | directory |  directory := self class projectDirectoryFrom: self projectPath version: self projectVersion.  self repoPath isEmpty ifFalse: [ directory := MetacelloPlatform current directoryFromPath: self repoPath relativeTo: directory ].  ^directorycreateRepository  | repo |  repo := self project createRepository: self.  ^MCRepositoryGroup default repositories detect: [:each |  each = repo ] ifNone: [ MCRepositoryGroup default addRepository: repo.        repo ]for: attributeListOrSymbol do: aBlock  attributeListOrSymbol setForDo: aBlock withInMetacelloConfig: selftestVersionSpec  | version |  version := self versionSpec     blessing: #baseline;     versionString: '1.0';     description: 'A description';     author: 'dkh';     timestamp: '1/24/2012 09:59';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  self assert: version blessing value equals: #baseline.  self assert: version versionString value equals: '1.0'.  self assert: version description value equals: 'A description'.  self assert: version author value equals: 'dkh'.  self assert: version timestamp value equals: '1/24/2012 09:59'.  self assert: version preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: version postLoadDoIt value identicalTo: #postLoadDoIt.  self should: [ version preLoadDoIt: '' ] raise: Error.  self should: [ version postLoadDoIt: '' ] raise: ErrorcreateGroupSpec: baseName  ^self project groupSpec     name: baseName;     yourselfversion108ProjectToolBox: spec  < version: '1.0.8-baseline'>  spec for: #common do: [ spec           package: 'Example-Core';           package: 'Example-Tests' with: [ spec requires: #('Example-Core') ] ]includesForPackageOrdering  ^#()configuration096Issue185: spec  < version: '0.9.6'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration0956Issue185:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA3 , '/repository' ];           import: 'External' ]disableUndefinedSymbolTracking  ^truecheckSubCommand: aString  (self availableSubCommands includes: aString) ifFalse: [ self exitFailure: ('{1} subcommand does not exists' format: {aString}) ]className: className  self addStatement: #classNameArg: args: {className}removals  removals ifNil: [ removals := Dictionary new ].  ^removalsimports  imports == nil ifTrue: [ imports := #() ].  ^importsdo: aBlock  self map values do: aBlockconfigMethodOn: aStream indent: indent  | hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers hasFile |  hasFile := file ~~ nil.  hasRepositories := self repositorySpecs size > 0.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [ self answers isEmpty ] ]) not.  aStream     tab: indent;     nextPutAll: 'spec '.  hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers ifTrue: [ aStream           cr;           tab: indent + 1;           nextPutAll: 'name: ' , self name printString;           nextPut: $;.        self configMethodBodyOn: aStream hasName: true indent: indent + 1 ] ifFalse: [ aStream nextPutAll: 'name: ' , self name printString ]configuration093Issue185: spec  < version: '0.9.3'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration093Issue185:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA , '/repository' ];           import: 'External' ]setUpConfigurationOfProjectIssue119  | versionInfo |  versionInfo := self setUpConfigurationOfProjectIssue119dkh1.  versionInfo := self setUpConfigurationOfProjectIssue119dkh2: {versionInfo}.  versionInfo := self setUpConfigurationOfProjectIssue119dkh3: {versionInfo}.  versionInfo := self setUpConfigurationOfProjectIssue119dkh4: {versionInfo}.  versionInfo := self setUpConfigurationOfProjectIssue119dkh5: {versionInfo}.  versionInfo := self setUpConfigurationOfProjectIssue119dkh6: {versionInfo}.  versionInfo := self setUpConfigurationOfProjectIssue119dkh7: {versionInfo}resolveToLoadableSpec  ^self copycurrentlyLoadedExtensionClassesInVersion  ^self spec currentlyLoadedExtensionClassesInVersionconfiguration097Issue185: spec  < version: '0.9.7'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration0957Issue185:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA4 , '/repository' ];           import: 'External' ]version104ProjectToolBox: spec  < version: '1.0.4-baseline' imports: #('1.0.2-baseline')>  spec for: #common do: [ spec preLoadDoIt: nil ]repositories: anObject  repositories := anObjectregistrationFor: aMetacelloProjectRegistration ifPresent: presentBlock ifAbsent: absentBlock  | baseName |  baseName := aMetacelloProjectRegistration baseName.  aMetacelloProjectRegistration configurationProjectSpec ifNotNil: [:spec |  self configurationRegistry at: spec className ifPresent: [:existing |  ^presentBlock value: existing ] ].  aMetacelloProjectRegistration baselineProjectSpec ifNotNil: [:spec |  self baselineRegistry at: spec className ifPresent: [:existing |  ^presentBlock value: existing ] ].  self configurationRegistry at: 'ConfigurationOf' , baseName ifPresent: [:existing |  ^presentBlock value: existing ].  self baselineRegistry at: 'BaselineOf' , baseName ifPresent: [:existing |  ^presentBlock value: existing ].  ^absentBlock valuemethodSpec  ^methodSpecgetPostLoadDoIt  ^postLoadDoItintegrateCodeContributions  ^Lesson title: '5. Integrate code contributions' lesson: '"If other developers have commited new versions of the packages in your project you can integrate the changes into your configuration by first loading the latest packages in your project:"	(ConfigurationOfExample project version: #baseline) load."Then updating the mcz file specifications in #development version:"	MetacelloToolBox 		updateToLatestPackageVersionsIn: ConfigurationOfExample		description: ''- integrated code from Barney and Fred''."Then checkpoint the configuration:"	MetacelloToolBox 		saveConfigurationPackageFor: ''Example'' 		description: ''- integrated code from Barney and Fred''.ProfStef next.'repositorySpec  ^self repositorySpecClass for: selfbaselineVersion21Issue171: spec  < version: '2.1-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec className: 'MetacelloTestConfigurationOfFoo' ];           yourself.        spec package: 'GeauxFoo' ]mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec  aMetacelloRepositoriesSpec addMember: selfversionDirectivesDepthFirstDo: aBlock  testAlphaNumericVersion1  | x y |  self assert: (x := self versionClass fromString: '2.9.0') < (y := self versionClass fromString: '2.10.0')errorReasonCodes  ^#(#duplicateNames #shadowedNames #invalidDoItSelector #invalidVersionString #missingVersionImport #projectCreationError #noVersionsDefined #cannotResolveVersion #incompleteProjectSpec #incorrectVersionString #versionCompositionError #versionCreationError)version14: spec  < version: '1.4' imports: #('1.4-baseline')>  spec for: #common do: [ spec blessing: #beta.        spec description: 'Add groups and Project-Extra'.        spec           project: 'Example Default' with: '1.3';           project: 'Example Tests' with: '1.3'.        spec           package: 'Project-Core' with: 'Project-Core-anon.2';           package: 'Project-Tests' with: 'Project-Tests-anon.2';           package: 'Project-Extra' with: 'Project-Extra-anon.1' ]compareVersionsEqual: aMetacelloProjectSpec  | vrsn otherVrsn |  vrsn := self versionOrNil.  otherVrsn := aMetacelloProjectSpec versionOrNil.  vrsn ifNil: [ ^vrsn = otherVrsn ].  otherVrsn ifNil: [ ^false ].  ^vrsn versionNumber = otherVrsn versionNumberbaseline60MethodSourceFix  ^(self class sourceCodeAt: #baseline60Fix:) asStringresolveToLoadableSpec  ^nilbaseline10D: spec  < version: '1.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'C' with: [ spec                 className: 'MetacelloTestConfigurationOfIssue77C';                 loads: #('GoferFoo');                 versionString: '1.3';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           package: 'GoferBar' with: [ spec file: 'GoferBar-lr.1' ];           group: 'default' with: #('GoferBar');           yourself ]isExplicit  ^truerepositoriesForPackage: aBlock  self repositoriesForSpec: aBlocknormalizeTagsData: jsonObject  ^self subclassResponsibilitytestCollapseZeros  self assert: (MetacelloVersionNumber fromString: '1.0-beta.24.0.1') collapseZeros printString equals: '1-beta.24.0.1'.  self assert: (MetacelloVersionNumber fromString: '1.0-beta.24.0.0.1') collapseZeros printString equals: '1-beta.24.0.0.1'.  self assert: (MetacelloVersionNumber fromString: '1.0.0-beta.24.0.0.1') collapseZeros printString equals: '1-beta.24.0.0.1'baselineForVersion: aString  self setBaseline: aStringmodifySection: sectionAttributeOrPath sectionIndex: sectionIndex repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlock  | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap groups packageList newGroupNames |  versionSpec := (self methodSpec findMethodSection: sectionAttributeOrPath asMetacelloAttributePath sectionIndex: sectionIndex) versionSpec.  repositoryDescription ~~ nil ifTrue: [ versionSpec repository: repositoryDescription ].  newProjectList do: [:projectName |  (versionSpec packages specListDetect: [:spec |  spec name = projectName ] ifNone: [  ]) == nil ifTrue: [ versionSpec packages merge: (self createProjectReferenceSpec: projectName) ] ifFalse: [ self error: 'Project named: ' , projectName printString , ' already exists.' ] ].  packageList := OrderedCollection new.  groups := OrderedCollection new.  newGroupNames := OrderedCollection new.  versionSpec projectDo: [:ignored |   ] packageDo: [:pkg |  packageList add: pkg name ] groupDo: [:group |  groups add: group name -> group includes.        newGroupNames add: group name ].  newPackageList do: [:packageName |  (packageList includes: packageName) ifTrue: [ self error: 'Package named: ' , packageName printString , ' already exists.' ] ifFalse: [ packageList add: packageName ] ].  newGroups do: [:assoc |  (newGroupNames includes: assoc key) ifTrue: [ self error: 'Group named: ' , assoc key printString , ' already exists.' ] ifFalse: [ groups add: assoc ] ].  dependencyMap := self buildMapFrom: dependecies for: packageList.  includesMap := self buildMapFrom: includes for: packageList.  filesMap := self buildMapFrom: files for: packageList.  repositoriesMap := self buildMapFrom: repositories for: packageList.  preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.  postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.  supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.  packageList do: [:packageName |  | spec |        (newPackageList includes: packageName) ifTrue: [ spec := self createPackageSpec: packageName.              versionSpec packages merge: spec ] ifFalse: [ spec := versionSpec packages specListDetect: [:spc |  spc name = packageName ] ].        dependencyMap at: packageName ifPresent: [:dependencyList |  spec setRequires: spec requires , dependencyList ].        includesMap at: packageName ifPresent: [:includesList |  spec setIncludes: spec includes , includesList ].        filesMap at: packageName ifPresent: [:file |  spec file: file ].        repositoriesMap at: packageName ifPresent: [:repositoriesList |  repositoriesList do: [:repoString |  spec repository: repoString ] ].        preLoadDoItsMap at: packageName ifPresent: [:preLoad |  spec preLoadDoIt: preLoad ].        postLoadDoItsMap at: packageName ifPresent: [:postLoad |  spec postLoadDoIt: postLoad ].        supplyingAnswersMap at: packageName ifPresent: [:answer |  spec answers: answer ] ].  groups do: [:assoc |  | spec |        (newGroupNames includes: assoc key) ifFalse: [ spec := self createGroupSpec: assoc key.              versionSpec packages merge: spec.              spec setIncludes: spec includes , assoc value ] ].  aBlock value: versionSpecloaderPolicy  loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].  ^loaderPolicytestAddPackageD  | packages |  packages := self packagesSpec.  packages add: 'Platform'.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ]packageRepository  ^(self class package mcWorkingCopy repositoryGroup repositories reject: [:each |  each = MCCacheRepository uniqueInstance ]) ifNotEmpty: [:repositories |  repositories anyOne ] ifEmpty: [ nil ]configMethodOn: aStream indent: indent  | packageSpecs |  packageSpecs := self map values.  packageSpecs size = 0 ifTrue: [ ^aStream nextPutAll: 'spec add: []' ].  packageSpecs size = 1 ifTrue: [ aStream           tab: indent;           nextPutAll: 'spec add: [';           cr.        packageSpecs first configMethodOn: aStream indent: indent + 1.        aStream           nextPut: $];           cr ] ifFalse: [ aStream           tab: indent;           nextPutAll: 'spec'.        1 to: packageSpecs size do: [:index |  | packageSpec |              packageSpec := packageSpecs at: index.              aStream                 tab: indent + 1;                 nextPutAll: 'add: [';                 cr.              packageSpec configMethodOn: aStream indent: indent + 2.              aStream nextPut: $].              index < packageSpecs size ifTrue: [ aStream nextPut: $; ].              aStream cr ] ]createDirectoryRepository: aRepositorySpec  ^MCDirectoryRepository new     directory: (self fileHandleOn: aRepositorySpec description);     yourselfvalidateVersionSpecForSymbolicVersion: versionSpec symbolicVersion: symbolicVersionString  self subclassResponsibilityload  | mcLoader |  packages := Dictionary new.  self resolveToLoadableSpecs.  mcLoader := self loader.  packages values do: [:pkg |  pkg ensureLoadedForDevelopmentUsing: mcLoader.        (MetacelloIgnorePackageLoaded signal: pkg) ifFalse: [ mcLoader ignoreImage ifFalse: [ (pkg compareCurrentVersion: self operator targetVersionStatus: #(#allLoadedToSpec) using: mcLoader) ifTrue: [ packages removeKey: pkg name ] ] ] ].  packages notEmpty ifTrue: [ mcLoader preLoad: self versionSpec.        mcLoader load.        mcLoader postLoad: self versionSpec ].  ^mcLoaderresolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  | packages |  packages := Dictionary new.  self resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool into: packages visited: visited.  ^packages values asOrderedCollectionpostLoad31baselineMethodSource  ^(self class sourceCodeAt: #postLoad31baseline) asStringcreateRepository: aRepositorySpec  ^MCRepository newRepositoryFromSpec: aRepositorySpec on: selfversion122ProjectToolBox: spec  < version: '1.2.2-baseline'>  spec for: #common do: [ spec project: 'Example Project' with: [ spec                 className: 'MetacelloExampleProjectConfig';                 repository: 'http://www.example.com/ob' ] ]testMergeA  | repositories repository |  repositories := self repositoriesSpec.  repositories     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     merge: (self repositorySpec           description: 'http://example.com/repository';           username: 'DaleHenrichs';           password: 'secret';           yourself).  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  self assert: repository username equals: 'DaleHenrichs'.  self assert: repository password equals: 'secret'latestVersion: blessing  ^nilmergeImportLoads: aLoadList  aLoadList ifNotNil: [:otherLoads |  self loads ifNil: [ loads := otherLoads ] ifNotNil: [ loads := loads , otherLoads ] ]evalDoits: aBool  evalDoits := aBoolreleaseVersion10  ^Lesson title: 'Release version 1.0' lesson: '"	1. Create configuration	2. Prepare to modify the version method for version 1.0:		- the project and package versions are not updated	3. Change the blessing to #release for the #common attribute	4. Note that the return value for the #attributeBlocksDo: block is true. If the return value is false, the versionSpec would not be included in the updated mehtod.	5. Compile and validate the #version10: method .	6. Remove version 1.0 from the definition of the #development symbolic version - the version is no longer in development		- the return value for the  #methodSectionsDo: block (like the #versionSpecsDo: block) determins whether the methodSection is carried forward or not	7. Compile and validate the #development: method	8. Prepare to define the symbolic version method #stable:	9. Define version 1.0 as the #stable symbolic version for #common	10. Compile and validate the #stable: method"	"1"	(MetacelloToolBox configurationNamed: ''Example'')"2."		modifyVersionMethodForVersion: ''1.0''			versionSpecsDo: [ :attribute :versionSpec | 					attribute == #common"3."						ifTrue: [ versionSpec blessing: #release ]."4."					true ];"5."		commitMethod;"6."		modifySymbolicVersionMethodFor: #development			symbolicVersionSpecsDo: [ :methodSection | methodSection versionString ~= ''1.0'' ];"7."		commitMethod;"8."		createSymbolicVersionMethod: ''stable:'' inCategory: ''symbolic versions'' forVersion: #stable;"9."		addSymbolicSection: #common version: ''1.0'';"10."	commitMethod."After evaluating the above expression, take a look at the updated method #version10, where you will see that the blessing has been updated to #release.Look at the #development: method (which should be empty) and the #stable: method"ProfStef next.'versionString: aString  ^self projectReference versionString: aStringversionReferences  ^versionReferencesaddSectionsFrom: inputVersionStringOrSymbol forBaseline: forBaseline updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock  | constructor updatedSpecs projectAttributes fullVersionSpec version coll pragma imports visitedSpecs fromVersionString |  constructor := self constructor.  updatedSpecs := Set new.  visitedSpecs := Set new.  projectAttributes := project attributes.  version := project version: inputVersionStringOrSymbol.  fromVersionString := version versionString.  fullVersionSpec := version spec.  fullVersionSpec := version spec.  coll := constructor extractAllVersionPragmas at: fromVersionString ifAbsent: [ ^nil ].  coll size > 1 ifTrue: [ self error: 'More than one pragma defining ' , fromVersionString printString ].  pragma := coll at: 1.  imports := pragma numArgs = 2 ifTrue: [ pragma argumentAt: 2 ] ifFalse: [ #() ].  methodSpec imports: imports.  constructor extractMethodSectionsFor: fromVersionString.  constructor methodSections do: [:methodSection |  | versionSpec attributeList |        versionSpec := methodSection versionSpec.        attributeList := methodSection attributes.        forBaseline ifFalse: [ (projectAttributes includes: attributeList) ifTrue: [ self updateVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs ] ].        (aBlock value: methodSection attributeOrPath value: versionSpec) ifTrue: [ self methodSpec addMethodSection: methodSection attributePath versionSpec: versionSpec ] ]executeLoadFromArray: anArray  | loader |  loader := MetacelloMCVersionSpecLoader on: self spec.  loader required: anArray.  loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy ].  ^loader loadcanUpgradeTo: aMetacelloProjectSpec  ^(super canUpgradeTo: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]versionOfX090: spec  < version: '0.9.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>versionOfX090:'.        spec author: 'dkh'.        spec timestamp: '5/4/2012 14:16' ].  spec for: #custom do: [ spec baseline: 'ExternalX' with: [ spec repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]goferCommitPackageUsing: repositorySpecs commitMessage: commitMessage  | gofer repoSpecs wc |  repoSpecs := self spec repositorySpecs notEmpty ifTrue: [ self spec repositorySpecs ] ifFalse: [ repositorySpecs ].  gofer := MetacelloGofer new.  gofer disablePackageCache.  wc := self spec workingCopy.  repositorySpecs do: [:repoSpec |  | repo |        repo := repoSpec createRepository.        (wc possiblyNewerVersionsIn: repo) notEmpty ifTrue: [ self notify: 'There are possibly newer versions of the package ' , self spec name printString , ' in the repository ' , repo description printString , '. Cancel and manually merge if you want to pick up the changes from the later version.' ].        gofer repository: repo ].  gofer package: self spec name.  gofer commit: commitMessage.  ^trueprojectPath: aProjectPath projectVersion: aProjectVersion repoPath: aRepoPath  self projectPath: aProjectPath.  self projectVersion: aProjectVersion.  self repoPath: aRepoPathloadedRepositories  | repos |  repos := OrderedCollection new.  self repositoryMap values collect: [:coll |  repos addAll: coll ].  ^reposversion  self projectClass == nil ifTrue: [ ^nil ].  ^self versionString == nil ifTrue: [ | vrsn |        self flag: 'deprecate after version 1.0'.        (vrsn := self projectClassProject latestVersion) == nil ifTrue: [ self projectClassProject version: #bleedingEdge ] ifFalse: [ vrsn ] ] ifFalse: [ self projectClassProject version: self versionString ]hasConflictWithBaselineSpec: projectSpec  projectSpec name = self name ifFalse: [ ^true ].  projectSpec project configuration className = self project configuration className ifFalse: [ ^true ].  ^((projectSpec repositories isEmpty or: [ self repositories isEmpty ]) or: [ projectSpec repositories hasNoLoadConflicts: self repositories ]) nottitle  ^'explicit load'printOn: aStream  aStream     nextPutAll: self class name asString;     nextPut: $(.  self versionSpec printOn: aStream.  aStream nextPut: $)validateVersionTests: version  | testCases cleanTests |  testCases := IdentitySet new.  cleanTests := true.  version currentlyLoadedClassesInVersion do: [:class |  | isTestCase |        isTestCase := (class withAllSuperclasses collect: #name) includes: #TestCase.        (isTestCase and: [ class isAbstract not ]) ifTrue: [ testCases add: class ] ].  testCases do: [:testCase |  | testResults |        testResults := testCase suite run.        testResults defects notEmpty ifTrue: [ self recordValidationError: 'Test failures in tests ' , testCase name asString , ' for ' , version versionString printString , ' in ' , self configurationClass name asString , ' ' , testResults printString versionString: version versionString callSite: #validateVersionTests: reasonCode: #testFailures.              cleanTests := false ] ].  testCases isEmpty ifTrue: [ self recordValidationCriticalWarning: 'No test cases for ' , version versionString printString , ' in ' , self configurationClass name asString versionString: version versionString callSite: #validateVersionTests: reasonCode: #noTests.        cleanTests := false ].  ^cleanTestsrecord: required  actionArg := #record: -> {required}version20Issue119: spec  < version: '2.0' imports: #('2.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '2.0'.        spec package: 'GoferBar' with: 'GoferBar-jf.1' ]verifyVersionImportPragmas: pragmaDict definedIn: versionMap  pragmaDict copy keysAndValuesDo: [:versionString :pragmaColl |  [ pragmaColl do: [:pragma |  (pragma argumentAt: 2) do: [:importedVersion |  versionMap at: importedVersion ifAbsent: [ pragmaDict at: importedVersion ifAbsent: [ ^self error: 'The imported version:' , importedVersion printString , ' for version: ' , versionString , ' referenced from the method: ' , (MetacelloPlatform current selectorForPragma: pragma) printString , ' in configuration ' , configuration class printString , ' has not been defined.' ] ] ] ] ] on: Error do: [:ex |  (MetacelloErrorInProjectConstructionNotification versionString: versionString exception: ex) ifTrue: [ ^ex pass ] ifFalse: [ pragmaDict removeKey: versionString.                    self errorMap at: versionString put: ex ] ] ]repositoriesForProject: aBlock  self repositoriesForSpec: aBlockimport: aStringOrCollection  self root import: aStringOrCollection constructor: selfsymbolicVersionSymbols  ^self symbolicVersionMap keys asArray sort: [:a :b |  a <= b ]incrementMinorVersion  self size < 2 ifTrue: [ self at: 2 put: 0 ].  self incrementVersionAt: 2projectClass  ^MetacelloMCProjectsetUpNewerDependency  | reference |  reference := GoferVersionReference name: 'GoferUmbrella-lr.5'.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) with: (MCClassDefinition name: (reference packageName copyWithout: $-) asSymbol superclassName: #Object category: reference packageName asSymbol instVarNames: #() comment: ''))) dependencies: (Array with: (MCVersionDependency package: (MetacelloTestsMCPackage new name: 'GoferBarDependency') info: (monticelloRepository versionInfoFromVersionNamed: 'GoferBarDependency-lr.35')) with: (MCVersionDependency package: (MetacelloTestsMCPackage new name: 'GoferFooDependency') info: (monticelloRepository versionInfoFromVersionNamed: 'GoferFooDependency-lr.35'))))projectSpecLookupBlock  ^[:projectName |  {(MetacelloProjectRegistration projectSpecForClassNamed: (MetacelloScriptEngine baselineNameFrom: projectName) ifAbsent: [  ])} ]extractPragmas: pragmaKeyword into: versionDict  ^self extractPragmas: pragmaKeyword for: self configurationClass into: versionDictextractSymbolicVersionPragmas  | aDict |  aDict := Dictionary new.  self extractPragmas: #symbolicVersion: into: aDict.  ^aDictincrementMajorVersion  self incrementNormalVersionAt: 1collectAllSymbolicVersionsFromVersionPragmasInto: symbolicVersionMap using: executionBlock  | defined versionPragmaDict versionString |  versionPragmaDict := self extractSymbolicVersionPragmas.  versionPragmaDict keysAndValuesDo: [:versionSymbol :pragmaColl |  defined := false.        pragmaColl do: [:pragma |  defined := true.              versionString := executionBlock value: versionSymbol value: pragma ].        defined ifTrue: [ versionString == nil ifFalse: [ symbolicVersionMap at: versionSymbol put: versionString ] ].        self reset ]bleedingEdge: spec  < symbolicVersion: #bleedingEdge>  spec for: #'platformVersion1.x' version: '1.0-baseline'testPackageSpec  | package repository |  package := self packageSpec     name: 'Package';     requires: 'AnotherPackage';     includes: 'IncludedPackage';     answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));     file: 'Package-dkh.1';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  self assert: package name equals: 'Package'.  self assert: package requires equals: #('AnotherPackage').  self assert: package includes equals: #('IncludedPackage').  self assert: package answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer')).  self assert: package file equals: 'Package-dkh.1'.  self assert: package preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: package postLoadDoIt value identicalTo: #postLoadDoIt.  repository := package repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := package repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'hasNoProject  ^hasNoProjectworkingCopy  ^self goferPackage workingCopymapMerge: aMemberSpec into: map  | spec |  spec := map at: aMemberSpec name ifAbsent: [  ].  spec == nil ifTrue: [ map at: aMemberSpec name put: aMemberSpec spec copy ] ifFalse: [ map at: aMemberSpec name put: (spec mergeSpec: aMemberSpec spec) ]repositoryOverrides: aRepositoryDescriptionList  self options at: #repositoryOverrides put: aRepositoryDescriptionListhostname: aString  hostname := aStringasString  ^self printStringresolvePackageSpecReferences: packageSpec gofer: gofer  | versionReference references localGofer |  localGofer := gofer.  self hasRepositoryOverrides not ifTrue: [ packageSpec repositorySpecs notEmpty ifTrue: [ localGofer := MetacelloGofer new.              (self repositoriesFrom: packageSpec repositorySpecs) do: [:repo |  localGofer repository: repo ] ] ].  (packageSpec getFile == nil or: [ self shouldDisablePackageCache ]) ifTrue: [ localGofer disablePackageCache ].  versionReference := packageSpec goferLoaderReference.  references := versionReference resolveAllWith: localGofer.  localGofer enablePackageCache.  ^referencesbaselineVersion10Issue119: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo ' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec package: 'GoferBar ' ]updatePackageRepositoriesFor: aVersionSpec  self workingCopy == nil ifTrue: [ ^self ].  self updatePackageRepositories: self repositorySpecs , aVersionSpec repositorySpecsdefaultPlatformAttributes  | versionString |  Smalltalk at: #SystemVersion ifPresent: [:cl |  versionString := cl current version.        (versionString beginsWith: 'Pharo') ifTrue: [ ^#(#squeakCommon #pharo) ].        (versionString beginsWith: 'Squeak') ifTrue: [ ^#(#squeakCommon #squeak) ].        (self string: versionString includesSubstring: 'Pharo') ifTrue: [ ^#(#squeakCommon #pharo) ].        (self string: versionString includesSubstring: 'Squeak') ifTrue: [ ^#(#squeakCommon #squeak) ].        self error: 'Unrecognized version of Squeak/Pharo: ' , versionString ].  ^#(#gemstone)getOrCreateIcebergRepository  | remoteUrl |  remoteUrl := self perform: Iceberg remoteTypeSelector.  ^IceRepository registry detect: [:repo |  repo isCloneOfUrl: remoteUrl ] ifNone: [ | remote |        remote := IceGitRemote url: remoteUrl.        self createIcebergRepositoryWithFallbackFor: remote url: remoteUrl ]prepostLoadDo: aBlock  value: anObject  value := anObjectloadUsing: aLoaderDirective gofer: aGofer  aLoaderDirective loadPreloadDirective: selfconfigMethodOn: aStream last: last indent: indent  | spec hasRepositories hasPackageSpecs hasImport |  hasRepositories := (spec := self repositoriesSpec) ~~ nil and: [ spec list isEmpty not ].  hasImport := self import ~~ nil.  hasPackageSpecs := false.  self packagesSpec list do: [:member |  member spec projectDo: [:proj |  member spec name ~~ nil ifTrue: [ hasPackageSpecs := true ] ] packageDo: [:package |  member spec name ~~ nil ifTrue: [ hasPackageSpecs := true ] ] groupDo: [:group |  member spec name ~~ nil ifTrue: [ hasPackageSpecs := true ] ] ].  self configMethodBasicOn: aStream last: (hasRepositories | hasPackageSpecs | hasImport) not indent: indent.  hasImport ifTrue: [ self configMethodValueOn: aStream for: self import selector: 'import:' last: (hasRepositories | hasPackageSpecs) not indent: indent ].  hasRepositories ifTrue: [ spec map values size = 1 ifTrue: [ aStream                 tab: indent;                 nextPutAll: 'spec repository: ';                 nextPutAll: spec map values first description printString , '.'.              hasPackageSpecs ifTrue: [ aStream cr ] ] ifFalse: [ self configMethodOn: aStream for: spec selector: 'repositories:' last: hasPackageSpecs not indent: indent ] ].  self configPackagesSpecMethodOn: aStream indent: indent.  last ifFalse: [ aStream cr ]label  ^self configuration class nameload  ^self doLoadRequiredFromArray: self spec defaultPackageNamesversion03: spec  < version: '0.3'>  spec for: #common do: [ spec           package: 'Example-Core' with: [ spec                 file: 'Example-Core-anon.10';                 repository: 'http://www.example.com/Example' ];           package: 'Example-Tests' with: [ spec                 file: 'Example-Tests-anon.3';                 repository: 'http://www.example.com/Example' ] ]< aMetacelloVersionNumber  | condensed aCondensed |  aMetacelloVersionNumber species = self species ifFalse: [ ^false ].  condensed := self collapseZeros.  aCondensed := aMetacelloVersionNumber collapseZeros.  (condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ]) ifTrue: [ ^condensed compareLessThan: aCondensed ].  ^self compareLessThan: aMetacelloVersionNumberlesson04  getBaselineUnconditionalLoad: unconditionalLoad  | spec |  spec := self projectSpec.  Smalltalk at: spec className asSymbol ifPresent: [:cl |  unconditionalLoad ifFalse: [ ^cl ] ].  spec := self lookupProjectSpecFor: spec.  [ spec projectPackage load ] on: MetacelloIgnorePackageLoaded do: [:ex |  ex resume: true ].  ^Smalltalk at: spec className asSymbolancestors  ^self goferPackage ancestorsprojectSpec  ^projectSpecrepositories  ^self projectSpec repositoriestearDownPackageNames  ^{self projectName}evaluateStatus: validStatusList  ^self abort ifTrue: [ false ] ifFalse: [ (self hasNoProject or: [ self vrsnStatus isEmpty ]) ifTrue: [ true ] ifFalse: [ | valid |              valid := true.              vrsnStatus do: [:status |  (validStatusList includes: status) ifFalse: [ valid := false ] ].              valid ] ]initializeName: aString packageFilename: packagefilename  name := aString.  packageFilename := packagefilenameallPackagesLoaded: aLoader  | vrsn pkgs |  (vrsn := self versionOrNil) == nil ifTrue: [ ^false ].  pkgs := OrderedCollection new.  (self loadListForVersion: vrsn) do: [:nm |  vrsn packages do: [:pkg |  (pkg isPackageLoaded: aLoader) ifFalse: [ ^false ] ] ].  ^trueloaderPolicy: anObject  loaderPolicy := anObjectexplanation  ^explanationsavePackage  | latestFile pkgSpec |  ^(file notNil and: [ self name = self file ]) ifTrue: [ latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.        pkgSpec := self copy.        pkgSpec file: latestFile.        pkgSpec savePackage ] ifFalse: [ self loader savePackageUsing: self repositorySpecs ]versionDoesNotExistException  ^versionDoesNotExistExceptionoverrideProjectSpec  ^overrideProjectSpecaLoadedPackageIsNotCurrent  ^aLoadedPackageIsNotCurrentsetUpIssue156ConfigurationOfProjectSoo  | reference className definitionArray |  reference := GoferVersionReference name: 'ConfigurationOfProjectSoo-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString selector: 'version10Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue156:) asString) .   (MCMethodDefinition className: className asString selector: 'version11Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version11Issue156:) asString) .   (MCMethodDefinition className: className asString selector: 'version20Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue156:) asString) .   (MCMethodDefinition className: className asString selector: 'version30Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue156:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())projectClassMethodSource  ^(self class class sourceCodeAt: #project) asStringrepository: repositoryDescription  self addStatement: #repositoryArg: args: {repositoryDescription}downloadJSON: url username: username pass: pass  self subclassResponsibilityrepository: anObject constructor: aVersionConstructor  aVersionConstructor repositoryForPackage: anObjectpushLinearLoadDirectivesDuring: aBlock for: aLoader  self pushLoadDirective: (MetacelloLinearLoadDirective loader: aLoader) during: aBlockapplyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock  addBlock value: selfdisableUndefinedSybolUpdates  ^nilpreloads  preloads == nil ifTrue: [ preloads := OrderedCollection new ].  ^preloadssetUpBaselineGithubReferenceXX  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefXX-dkh.1'.  className := #BaselineOfGithubRefXX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineGithubReferenceXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceXX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfobaselineGithubReferenceIV: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>baselineGithubReferenceIV:'.        spec baseline: 'External' with: [ spec repository: 'http://ss3.gemtalksystems.com/ss/external' ] ]testSemanticVersioningSpecItem11  self validateSemanticVersionStrings: #('1.0.0+build.1' '1.3.7+build.11.e0f985a')validateProjects: specArrays  specArrays do: [:array |  self validate: (array at: 1) expConfigVersion: (array at: 2) expConfigRepo: (array at: 3) expBaselineClassName: (array at: 4) expBaselineVersion: (array at: 5) expBaselineRepo: (array at: 6) ]setUpConfigurationOfProjectIssue115  | versionInfo |  versionInfo := self setUpConfigurationOfProjectIssue115dkh1.  versionInfo := self setUpConfigurationOfProjectIssue115dkh2: {versionInfo}handleResolutionFor: aScriptEngine  ^aScriptEngine handleLookupProjectSpecForLoad: selfcanDowngradeTo: aMetacelloProjectSpec  ^(super canDowngradeTo: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]repositoryOverrides: repositoriesCollection  self loaderPolicy overrideRepositories: repositoriesCollectionconditionResult: resultString  ^((((((resultString copyReplaceAll: '#preloadForAddOn' with: '#''preloadForAddOn''') copyReplaceAll: '#postloadForAddOn' with: '#''postloadForAddOn''') copyReplaceAll: '#baseline' with: '#''baseline''') copyReplaceAll: '#preloadForVersion' with: '#''preloadForVersion''') copyReplaceAll: '#postloadForVersion' with: '#''postloadForVersion''') copyReplaceAll: '#preloadForProject' with: '#''preloadForProject''') copyReplaceAll: '#postloadForProject' with: '#''postloadForProject'''preLoadDoIt  ^preLoadDoIthasRepository  ^falseisValid  projectName ifNil: [ ^false ].  configurationProjectSpec ifNil: [ ^baselineProjectSpec notNil ].  ^baselineProjectSpec isNilnormalizeTagsData: jsonObject  | tagDict |  jsonObject at: 'error' ifPresent: [:errorObject |  self error: 'Error accessing tags for bitbucket project: ' , self projectPath printString , ' -> ' , (errorObject at: 'message') printString , ((errorObject at: 'detail') ifNil: [ '' ] ifNotNil: [:detail |  ' :: ' , detail printString ]) ].  tagDict := Dictionary new.  jsonObject keysAndValuesDo: [:tag :tagObject |  | sha |        sha := tagObject at: 'node'.        tagDict at: tag put: sha ].  ^tagDictbleedingEdge  ^self version: #bleedingEdgeversionString: anObject constructor: aVersionConstructor  aVersionConstructor versionStringForVersion: anObjectissue: anObject  issue := anObjectversionSpecClass  ^MetacelloMCVersionSpecloadUsing: aLoader gofer: ignored  | required |  required := self resolveToLoadableSpec.  required loader: aLoader.  ^required loadvalue  ^valueasProjectSpecForVersion: vrsn  | proj spec |  proj := vrsn ifNil: [ ^self ] ifNotNil: [ vrsn versionSpec project ].  spec := proj configurationOfProjectSpecClass for: proj.  self copyForScriptingInto: spec.  spec loader: self loader.  self assert: (self className beginsWith: 'BaselineOf') not.  ^speccacheRepository: aRepositoryDescription  self addStatement: #cacheRepository: args: {aRepositoryDescription}testVersion09  | v1 v2 |  v1 := self versionClass fromString: '1.0'.  v2 := self versionClass fromString: '0.7'.  self assert: v1 >= v2.  self assert: v2 <= v1authorName  ^Author fullNamelockConfiguration14: spec  < version: '1.4.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>lockConfiguration14: '.        spec configuration: 'ExternalX' with: [ spec                 version: #unstable;                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]loads  ^loadsextractRepositoryFrom: zipFile to: directory  self subclassResponsibilitybaselineVersion12Issue154: spec  < version: '1.2-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec           project: 'MetacelloExample' with: [ spec                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 projectPackage: [ spec                       name: 'MetacelloExampleTestConfigurationIssue154';                       file: 'MetacelloExampleTestConfigurationIssue154.gemstone';                       repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ];           yourself ]file  ^nillesson01  primeStackCacheWith: aDictionary doing: noArgBlock  self useStackCacheDuring: [:dict |  ^noArgBlock value ] defaultDictionary: aDictionaryproject: aString copyFrom: oldSpecName with: aBlock constructor: aVersionConstructor  aVersionConstructor projectForVersion: aString copyFrom: oldSpecName with: aBlockversionString: anObject  versionString := anObjectsymbolicVersion: aSymbol  symbolicVersion := aSymbolresolveToLoadableSpecs: required forLoad: forLoad map: packageMap  | reqd allReqd map newReqd spec |  reqd := required copy.  allReqd := Set new.  map := self packages map.  [ reqd isEmpty ] whileFalse: [ newReqd := Set new.        reqd do: [:req |  (self resolveToLoadableSpec: req forLoad: forLoad forMap: map packages: packageMap) do: [:loadableSpec |  newReqd addAll: loadableSpec requires.                    newReqd addAll: loadableSpec includes ] ].        allReqd addAll: reqd.        newReqd removeAllFoundIn: allReqd.        reqd := newReqd ].  packageMap keys do: [:pkgName |  (spec := (packageMap at: pkgName) resolveToLoadableSpec) == nil ifTrue: [ packageMap removeKey: pkgName ] ifFalse: [ packageMap at: pkgName put: (packageMap at: pkgName) resolveToLoadableSpec ] ]loadAtomicLoadDirective: aLoaderDirective gofer: aGofer  aLoaderDirective loadDirectives do: [:directive |  directive loadUsing: self gofer: aGofer ]newProjectRegistration  ^newProjectRegistrationignoreImage: aBool  self options at: #ignoreImage put: aBoolexternalBaselineX: spec  < baseline>  spec description: 'MetacelloScriptingResource>>externalBaselineX:'.  spec     package: 'External-CoreX';     package: 'External-TestsX' with: [ spec requires: 'External-CoreX' ];     yourself.  spec     group: 'Core' with: #('External-CoreX');     group: 'default' with: #('Core');     group: 'Tests' with: #('External-TestsX');     yourselfsetUpConfigurationOfProjectIssue154dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfMetacelloProjectIssue154-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion10Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue154:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion11Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion11Issue154:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion12Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion12Issue154:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion13Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion13Issue154:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion20Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue154:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion30Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion30Issue154:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoprojectSpec: anObject  projectSpec := anObjectgoferLoaderReference  ^file == nil ifTrue: [ GoferPackageReference name: self name ] ifFalse: [ MetacelloGoferPackage name: self name packageFilename: self file ]finalizeLoad: aGofer  remove: aRepositorySpec  aRepositorySpec removeFromMetacelloRepositories: selfcreateIcebergRepositoryWithFallbackFor: remote url: remoteUrl  | urlToUse |  urlToUse := remoteUrl.  [ ^self createIcebergRepositoryFor: urlToUse ] on: IceAuthenticationError do: [:e |  self crTrace: ('I got an error while cloning: {1}. I will try to clone the HTTPS variant.' format: {e messageText}).        urlToUse := remote httpsUrl.        e retry ]record: required  ^self execute: #record: args: {required}from  ^fromcopyForRegistration: aMetacelloProjectRegistration onWrite: aBlock  self error: 'Should be converting to configuration spec for the registration, so we should not get here'hasNoLoadConflicts: aMetacelloProjectSpec  ^(super hasNoLoadConflicts: aMetacelloProjectSpec) and: [ (self repositories isEmpty or: [ aMetacelloProjectSpec repositories isEmpty ]) or: [ self repositories hasNoLoadConflicts: aMetacelloProjectSpec repositories ] ]releaseVersion  ^Lesson title: '7. Release development version' lesson: '"When you ready to release the #development version of your project, the following things need to be done:	1. Change #blessing of version to #release	2. Set the #development symbolic version to #notFound (no longer in development)	3. Set the #stable symbolic version to the current #development version	4. Save the configuration	5. Copy the configuration to http://www.squeaksource.com/MetacelloRepository (optional).Steps 1-4 are performed by the following expression:"	MetacelloToolBox 		releaseDevelopmentVersionIn: ConfigurationOfExample		description: ''- release version 1.0''.	"If you want to copy the saved configuration to another repository, use the following expression:"	MetacelloToolBox 		copyConfiguration: ConfigurationOfExample 		to: ''http://www.example.com/MetacelloRepository''.ProfStef next.'ignoreImage  ^self options at: #ignoreImage ifAbsent: [ false ]getBaselineProjectUnconditionalLoad: unconditionalLoad  | project |  project := (self getBaselineUnconditionalLoad: unconditionalLoad) project.  project version spec repositories: self repositories copy.  ^projectdefaultAction  Warning signal: 'LOCK ENFORCED: Attempt to ' , self operationString printString , ' new project: ' , self newProjectRegistration printString printString , ' when existing project: ' , self existingProjectRegistration printString printString , ' is locked. New project not loaded. Use #onLock: to intercept.'.  ^self disallowupdatePackageRepositories: repositorySpecs  | resolvedPackageRef |  MetacelloNotification signal: '  Looking up version -> ' , self file.  resolvedPackageRef := self loader resolveSpec: self from: repositorySpecs.  MetacelloNotification signal: 'Update repositoryGroup -> ' , resolvedPackageRef name , ' ' , resolvedPackageRef repository description.  resolvedPackageRef version workingCopy repositoryGroup addRepository: resolvedPackageRef repositoryfileForPackage: aString  self root file: aStringsetUpConfigurationOfProjectIssue125  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue125-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'version30Issue125:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue125:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion20Issue125:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue125:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion30Issue125:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion30Issue125:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoversion50MethodSourceFoo  ^(self class sourceCodeAt: #version50Foo:) asStringhandleResolutionFor: aScriptEngine  ^aScriptEngine handleEnsureProjectLoadedForDevelopment: selfrecordingSpecLoader  ^(MetacelloNullRecordingMCSpecLoader on: self spec)     shouldDisablePackageCache: self shouldDisablePackageCache;     loaderPolicy: self loaderPolicy copy;     yourselfprojectClass  ^MetacelloMCProjectcreate10Baseline  ^Lesson title: 'Create 1.0 Baseline' lesson: '"	1. Create configuration		- class named ConfigurationOfExample created if it does not already exist.	2. Prepare to define baseline version method		- selector, category and version number defined	3. Define baseline project structure		- repository		- external project ''Shout''		- packages ''ProfStef-Core'' and ''ProfStef-Tests'', plus dependencies	4. Compile the #baseline10: method		- version method compiled and validated "	"1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		createVersionMethod: ''baseline10:'' inCategory: ''baselines'' forVersion: ''1.0-baseline'';"3."		addSection: #common			repository: ''http://www.squeaksource.com/ProfStef''			requiredProjects: #(''Shout'')			packages: #(''ProfStef-Core'' ''ProfStef-Tests'')			dependencies:				{(''ProfStef-Core'' -> #(''Shout'')).				(''ProfStef-Tests'' -> #(''ProfStef-Core''))}			groups:				{(''default'' -> #(''Core'')).				(''Core'' -> #(''ProfStef-Core'')).				(''Tests'' -> #(''ProfStef-Tests'')).				(''Core Tests'' -> #(''Core'' ''Tests''))}			versionSpecsDo: [ :versionSpec | versionSpec blessing: #baseline ];"4."		commitMethod."After evaluating the above expression, browse the configuration:"	ConfigurationOfExample browse.	"and look at the generated method #baseline10:. Note that the symbolic version #bleedingEdge is used for the Shout project."ProfStef next.'httpsUrl  ^'https://github.com/' , projectPath , '.git'configurationGithubReferenceV: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configurationGithubReferenceV:'.        spec           project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 version: '0.9.0';                 loads: 'Core';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ];           project: 'External Tests' copyFrom: 'External' with: [ spec loads: 'Tests' ] ]addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: groups versionSpecsDo: aBlock  | versionSpec dependencyMap includesMap filesMap repositoriesMap preLoadDoItsMap postLoadDoItsMap supplyingAnswersMap |  versionSpec := self createVersionSpec: self methodSpec versionString.  repositoryDescription ~~ nil ifTrue: [ versionSpec repository: repositoryDescription ].  dependencyMap := self buildMapFrom: dependecies for: packageList.  includesMap := self buildMapFrom: includes for: packageList.  filesMap := self buildMapFrom: files for: packageList.  repositoriesMap := self buildMapFrom: repositories for: packageList , projectList.  preLoadDoItsMap := self buildMapFrom: preLoadDoIts for: packageList.  postLoadDoItsMap := self buildMapFrom: postLoadDoIts for: packageList.  supplyingAnswersMap := self buildMapFrom: supplyingAnswers for: packageList.  projectList do: [:projectName |  | spec |        spec := self createProjectReferenceSpec: projectName.        repositoriesMap at: projectName ifPresent: [:repositoriesList |  repositoriesList do: [:repoString |  spec repository: repoString ] ].        versionSpec packages merge: spec ].  packageList do: [:packageName |  | spec |        spec := self createPackageSpec: packageName.        dependencyMap at: packageName ifPresent: [:dependencyList |  spec requires: dependencyList ].        includesMap at: packageName ifPresent: [:includesList |  spec includes: includesList ].        filesMap at: packageName ifPresent: [:file |  spec file: file ].        repositoriesMap at: packageName ifPresent: [:repositoriesList |  repositoriesList do: [:repoString |  spec repository: repoString ] ].        preLoadDoItsMap at: packageName ifPresent: [:preLoad |  spec preLoadDoIt: preLoad ].        postLoadDoItsMap at: packageName ifPresent: [:postLoad |  spec postLoadDoIt: postLoad ].        supplyingAnswersMap at: packageName ifPresent: [:answer |  spec answers: answer ].        versionSpec packages merge: spec ].  groups do: [:assoc |  | spec |        spec := self createGroupSpec: assoc key.        spec includes: assoc value.        versionSpec packages merge: spec ].  aBlock value: versionSpec.  self methodSpec addMethodSection: sectionAttributeOrPath asMetacelloAttributePath versionSpec: versionSpecaddTo: aLoaderDirective  spec preLoadDoIt value ~~ nil ifTrue: [ aLoaderDirective add: self ]bypassProgressBars  bypassProgressBars == nil ifTrue: [ bypassProgressBars := false ].  ^bypassProgressBarsauthor  ^self spec author valuetestVersion10  | x y |  self assert: (x := (({(self versionClass fromString: '1.0.0') .         (self versionClass fromString: '0.7.0') .         (self versionClass fromString: '0.8.0') .         (self versionClass fromString: '0.9.0') .         (self versionClass fromString: '1.0.1')} sort: [:a :b |  a <= b ]) collect: [:each |  each versionString ]) asArray) equals: (y := #('0.7.0' '0.8.0' '0.9.0' '1.0.0' '1.0.1'))version117ProjectToolBox: spec  < version: '1.1.7-baseline' imports: #('1.0-baseline')>  spec for: #common do: [ spec package: 'Example-Core' overrides: [ spec preLoadDoIt: #alternatePreloadForCore ] ]configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent  aMember methodUpdateSelector == #remove: ifTrue: [ aStream nextPutAll: 'removeGroup: ' , self name printString ] ifFalse: [ aStream           nextPutAll: 'group: ' , self name printString;           space;           nextPutAll: aMember methodUpdateSelector asString , ' #('.        self includes do: [:str |  aStream nextPutAll: str printString , ' ' ].        aStream nextPut: $) ].  lastCascade ifTrue: [ aStream nextPut: $. ] ifFalse: [ aStream           nextPut: $;;           cr ]hasRepositoryOverrides  ^self loaderPolicy hasRepositoryOverridesprint: components prefix: prefixChar on: aStream  | beforeFirst |  beforeFirst := true.  components do: [:component |  beforeFirst ifTrue: [ beforeFirst := false.              prefixChar ifNotNil: [ aStream nextPut: prefixChar ] ] ifFalse: [ aStream nextPut: $. ].        aStream nextPutAll: component asString ]runCase  | original |  original := MetacelloPlatform current bypassGoferLoadUpdateCategories.  [ MetacelloPlatform current bypassGoferLoadUpdateCategories: true.  ^MetacelloPlatform current suspendSystemUpdateEventsDuring: [ super runCase ] ] ensure: [ MetacelloPlatform current bypassGoferLoadUpdateCategories: original ]configurationGithubReferenceIV: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configurationGithubReferenceIV:'.        spec project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]configurationRegistry  configurationRegistry ifNil: [ configurationRegistry := Dictionary new ].  ^configurationRegistryaLoadedProjectIsCurrent: aBoolean  aLoadedProjectIsCurrent := aBooleanproject  ^selfsetUpRepositories  | defaultDirectory |  super setUpRepositories.  defaultDirectory := MetacelloPlatform current defaultDirectory.  configurationDirectory := MetacelloPlatform current directoryFromPath: self configurationPath relativeTo: defaultDirectory.  externalDirectory := MetacelloPlatform current directoryFromPath: self externalPath relativeTo: defaultDirectory.  sampleDirectory := MetacelloPlatform current directoryFromPath: self samplePath relativeTo: defaultDirectory.  configurationDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: configurationDirectory ].  MetacelloPlatform current ensureDirectoryExists: configurationDirectory.  externalDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: externalDirectory ].  MetacelloPlatform current ensureDirectoryExists: externalDirectory.  sampleDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: sampleDirectory ].  MetacelloPlatform current ensureDirectoryExists: sampleDirectory.  configurationRepository := MetacelloScriptingResource current configurationRepository.  externalRepository := MetacelloScriptingResource current externalRepository.  testingEnvironment at: 'Metacello_Configuration_Test_Repository' asSymbol put: externalRepository.  monticelloRepository := MetacelloMonticelloResource current monticelloRepository.  testingEnvironment at: 'Metacello_Gofer_Test_Repository' asSymbol put: monticelloRepository.  mczConfigurationRepository := MetacelloConfigurationResource current monticelloRepository.  testingEnvironment at: 'Metacello_MczConfiguration_Test_Repository' asSymbol put: mczConfigurationRepositorypostLoad: packageOrVersionSpec  (MetacelloDirective postLoadSpec: packageOrVersionSpec loader: self) addTo: self loadDirectiveensureForDevelopment  ^falsepostCopy  super postCopy.  list := list copy.  self clearMemberMapvalidateVersionSpec: versionSpec  self subclassResponsibilitysignal: aMetacelloVersion  self version: aMetacelloVersion.  ^self signaltestGroupSpec  | group |  group := self groupSpec     name: 'Platform';     includes: 'Core';     yourself.  self assert: group name equals: 'Platform'.  self assert: (group includes includes: 'Core').  group := self groupSpec     name: 'Platform';     includes: #('Core');     yourself.  self assert: group name equals: 'Platform'.  self assert: (group includes includes: 'Core').  self should: [ group requires: #() ] raise: Error.  self should: [ group answers: #() ] raise: Error.  group projectDo: [:ignored |  self assert: false ] packageDo: [:ignored |  self assert: false ] groupDo: [:grp |  self assert: group identicalTo: grp ]version114ProjectToolBox: spec  < version: '1.1.4-baseline'>  spec for: #common do: [ spec project: 'Example Project' with: [ spec                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 repository: 'http://www.example.com/ob' ] ]version43Symbolic: spec  < version: '4.3'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #development.        spec           package: 'GoferBeau' with: 'GoferBeau-dkh.54';           package: 'GoferFaux' with: 'GoferFaux-tg.33';           yourself ]packagesSpec  ^self packagesrepositoriesSpec  ^self repositoriesbaseline: aString with: aBlockOrString constructor: aVersionConstructor  aVersionConstructor baselineForVersion: aString with: aBlockOrStringtestRemoveGroupB  | packages removed |  packages := self packagesSpec.  packages add: {(self groupSpec           name: 'Platform';           includes: 'Core';           yourself) .         (self groupSpec           name: 'Base';           includes: 'Base';           yourself) .         (self groupSpec           name: 'Tests';           includes: 'Tests';           yourself)}.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  packages packageNamed: 'Base' ifAbsent: [ self assert: false ].  packages packageNamed: 'Tests' ifAbsent: [ self assert: false ].  packages remove: {'Base' .         'Tests'}.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  removed := false.  packages packageNamed: 'Base' ifAbsent: [ removed := true ].  self assert: removed.  removed := false.  packages packageNamed: 'Tests' ifAbsent: [ removed := true ].  self assert: removedglobalNamed: globalName  ^Smalltalk at: globalNamesetUpConfigurationOfExternaldkh2  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternal-dkh.2'.  className := #ConfigurationOfExternal.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfExternal090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfExternal090:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfExternal091:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfExternal091:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfofindMethodSection: attributeOrPath sectionIndex: sectionIndex  | attributePath index sections found |  attributePath := attributeOrPath asMetacelloAttributePath.  index := 1.  sections := self methodSections.  found := true.  [ found ] whileTrue: [ found := false.        sections do: [:ms |  ms attributes = (attributePath at: index) ifTrue: [ index == attributePath size ifTrue: [ ^ms ].                    sections := ms methodSections.                    index := index + 1.                    found := true ] ] ].  self error: 'Method section for attribute: ' , attributePath printString , ' not found.'repositoryVersionString  | spec repo |  self repositorySpecs do: [:repoSpec |  spec := repoSpec ].  [ repo := spec createRepository ] on: Error do: [:ex |  ^'' ].  ^repo repositoryVersionStringhash  ^self versionNumber hashtype  type == nil ifTrue: [ type := self extractTypeFromDescription ].  ^typeproject  ^project ifNil: [ self class ensureMetacello.        project := MetacelloMCProject new projectAttributes: self customProjectAttributes.        (Smalltalk at: #MetacelloVersionConstructor) on: self project: project.        project loadType: #linear.        project ]lesson06  resolveLocalRespository  | directory directoryPath |  directory := self calculateRepositoryDirectory.  directoryPath := MCFileTreeFileUtils current directoryPathString: directory.  directory exists ifFalse: [ self error: 'Local directory ' , directoryPath , ' does not exist.' ].  localRepository := MetacelloPlatform current createRepository: (MetacelloRepositorySpec new           description: 'filetree://' , directoryPath;           yourself)lookupConfigurationSpec  configurationProjectSpec ifNotNil: [:spec |  ^spec ].  ^baselineProjectSpecupdatePackageRepositoriesFor: versionString  | versionSpec |  (versionSpec := (self version: versionString) versionSpec) packageSpecsInLoadOrder do: [:pkgSpec |  pkgSpec updatePackageRepositoriesFor: versionSpec ].  ^truegoferCommitBranchPackage: branchName using: repositorySpecs commitMessage: commitMessage  | gofer repoSpecs wc |  repoSpecs := self spec repositorySpecs notEmpty ifTrue: [ self spec repositorySpecs ] ifFalse: [ repositorySpecs ].  gofer := MetacelloGofer new.  gofer disablePackageCache.  wc := self spec workingCopy.  repositorySpecs do: [:repoSpec |  | repo |        repo := repoSpec createRepository.        (wc possiblyNewerVersionsIn: repo) notEmpty ifTrue: [ self notify: 'There are possibly newer versions of the package ' , self spec name printString , ' in the repository ' , repo description printString , '. Cancel and manually merge if you want to pick up the changes from the later version.' ].        gofer repository: repo ].  gofer package: self spec name.  [ gofer interactiveCommit ] on: MCVersionNameAndMessageRequest do: [:ex |  | ref |        ref := GoferVersionReference name: ex suggestedName.        ex resume: {(ref packageName , '.' , branchName , '-' , ref author , '.' , ref versionNumber printString) .               commitMessage} ].  ^trueversion  self projectClass == nil ifTrue: [ ^nil ].  ^self projectClassProject versionhandleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock  self subclassResponsibilityresolveToPackagesIn: aVersionSpec visited: visited  ^self subclassResponsibilityhash  ^self description hashversionKey  ^self version versionKeyblessing: aBlockOrString  self root blessing: aBlockOrString constructor: selfrepositorySpecs  | repositoryMap |  repositoryMap := self versionSpec repositories ~~ nil ifTrue: [ self versionSpec repositories map ] ifFalse: [ Dictionary new ].  ^repositoryMap valueslabel  ^'Warning'loader  loader == nil ifTrue: [ | prjctLoader |        (prjctLoader := self project loader) == nil ifTrue: [ self loader: (self project loaderClass on: self) ] ifFalse: [ self loader: prjctLoader ] ].  ^loaderhasNoLoadConflicts: anMCGitBasedRepository  (anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^false ].  ^self projectPath = anMCGitBasedRepository projectPath and: [ self repoPath = anMCGitBasedRepository repoPath and: [ self projectVersion = anMCGitBasedRepository projectVersion ] ]setPostLoadDoIt: aSymbol  postLoadDoIt := aSymbolversion51MethodSourceUmbrella  ^(self class sourceCodeAt: #version51Umbrella:) asString= aMetacelloVersionNumber  aMetacelloVersionNumber species = self species ifFalse: [ ^false ].  ^self compareEqualTo: aMetacelloVersionNumberversionFrom: aVersionReferenceString  ^self localRepository versionFrom: aVersionReferenceStringtearDownPackages  | aGofer |  aGofer := Gofer new.  self tearDownPackageList do: [:packageName |  (self hasPackage: packageName) ifTrue: [ aGofer package: packageName ] ].  aGofer references notEmpty ifTrue: [ aGofer metacelloUnload ]projectVersion20Issue283: spec  < version: '2.0'>  spec for: #common do: [ spec blessing: #release.        spec configuration: 'ProjectIssue283' with: [ spec                 version: #bleedingEdge;                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]setAuthorInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setAuthor: selfpackageSpec: anObject  packageSpec := anObjecthasNoLoadConflicts: aMetacelloRepositorySpec  self description = aMetacelloRepositorySpec description ifTrue: [ ^true ].  self type = aMetacelloRepositorySpec type ifFalse: [ ^false ].  (#('github' 'gitorious' 'bitbucket') includes: self type) ifTrue: [ ^self createRepository hasNoLoadConflicts: aMetacelloRepositorySpec createRepository ].  ^falsehash  ^((String stringHash: projectName initialHash: 0) bitXor: configurationProjectSpec metacelloRegistrationHash) bitXor: baselineProjectSpec metacelloRegistrationHashhasNoProject: aBoolean  hasNoProject := aBooleanname  ^self versionSpec nameversionString: aStringOrSymbol  aStringOrSymbol isSymbol ifFalse: [ self error: 'Version symbol ' , aStringOrSymbol printString , ' for symbolic version method must be a Symbol' ].  super versionString: aStringOrSymbolversion42SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version42Symbolic:) asStringmethodSectionsInEvaluationOrder: attributes do: aBlock  | selected processed |  selected := IdentitySet new.  self methodSection: self inEvaluationOrder: attributes do: [:methodSection |  selected add: methodSection ].  processed := IdentitySet new.  attributes do: [:attribute |  | list |        list := OrderedCollection new.        selected do: [:methodSection |  (processed includes: methodSection) ifFalse: [ (methodSection attributes includes: attribute) ifTrue: [ list add: methodSection.                          processed add: methodSection ] ] ].        list do: aBlock ]metacelloProjectClassFor: aScriptEngine  ^MetacelloMCBaselineProjectgetFile  ^fileprepostLoadDo: aBlock  aBlock value: selfconfigurationProjectSpecIfAbsent: absentBlock  ^configurationProjectSpec ifNil: absentBlockrequires: anObject  self root requires: anObject constructor: selfcollectAllVersionsFromVersionPragmasInto: versionMap using: executionBlock  | defined versionPragmaDict |  versionPragmaDict := self extractVersionPragmas.  versionPragmaDict keysAndValuesDo: [:versionString :pragmaColl |  | versionSpec |        versionSpec := self project versionSpec.        versionSpec versionString: versionString.        defined := false.        [ pragmaColl do: [:pragma |  executionBlock value: versionSpec value: pragma.              defined := true ] ] on: Error do: [:ex |  (MetacelloErrorInProjectConstructionNotification versionString: versionSpec versionString exception: ex) ifTrue: [ ^ex pass ] ifFalse: [ self errorMap at: versionSpec versionString put: ex.                    defined := false ] ].        defined ifTrue: [ self validateVersionString: versionString againstSpec: versionSpec.              versionMap at: versionSpec versionString put: versionSpec createVersion ].        self reset ]version100ProjectToolBox: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #testBlessing.        spec           package: 'Example-Core' with: [ spec                 includes: #('Example-AddOn');                 file: 'Example-Core-anon.1';                 repository: 'http://www.example.com/or';                 preLoadDoIt: #preloadForCore;                 postLoadDoIt: #postloadForCore:package: ];           package: 'Example-AddOn' with: [ spec requires: #('Example-Core') ];           package: 'Example-Tests' with: [ spec requires: #('Example-AddOn') ] ]pushAtomicLoadDirectivesDuring: aBlock for: aLoader  self pushLoadDirective: (MetacelloAtomicLoadDirective loader: aLoader) during: aBlockdefaultLoaderClass  ^MetacelloSpecLoadercurrentVersionInfoFor: packageSpec  ^self loadData currentVersionInfoFor: packageSpec ifAbsent: [ nil ]setUpSampleCore  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'Sample-CoreX-dkh.1'.  className := #SampleCoreX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #Object category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'sampleAuthorName' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #sampleAuthorName) asString) .   (MCClassDefinition name: #Object superclassName: #ProtoObject category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: 'Object' classIsMeta: true selector: 'isSample' category: '*sample-core' timeStamp: '' source: (self class sourceCodeAt: #isSample) asString)}.  sampleRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfotestPrimeStackCache  | cached collection cacheNil direct mixed mixedStack block defaultDictionary |  defaultDictionary := Dictionary new.  block := [ cached := Dictionary new.  collection := Dictionary new.  cacheNil := Dictionary new.  direct := Dictionary new.  mixed := Dictionary new.  mixedStack := Dictionary new.  MetacelloPlatform current useStackCacheDuring: [:dict |  self cachedReturnOfValue ] defaultDictionary: cached.  MetacelloPlatform current useStackCacheDuring: [:dict |  self collectionCacheKey ] defaultDictionary: collection.  MetacelloPlatform current useStackCacheDuring: [:dict |  self cacheNil ] defaultDictionary: cacheNil.  MetacelloPlatform current useStackCacheDuring: [:dict |  self directReturnOfValue ] defaultDictionary: direct.  MetacelloPlatform current useStackCacheDuring: [:dict |  self mixedStack ] defaultDictionary: mixed.  MetacelloPlatform current useStackCacheDuring: [:dict |  self mixedStackCall ] defaultDictionary: mixedStack ].  block value.  self assert: ((cached at: #cached) at: #key) identicalTo: 6.  self assert: ((collection at: #collection) at: #x) identicalTo: 6.  self assert: ((cacheNil at: #cacheNil) at: #key) identicalTo: nil.  self assert: ((direct at: #direct) at: #x) identicalTo: 6.  self assert: ((mixed at: #cached) at: #key) identicalTo: 6.  self assert: ((mixed at: #mixed) at: #x) identicalTo: 4.  self assert: ((mixed at: #mixedStack) at: #x) identicalTo: 4.  self assert: ((mixed at: #direct) at: #x) identicalTo: 6.  self assert: ((mixedStack at: #cached) at: #key) identicalTo: 6.  self assert: ((mixedStack at: #mixedStack) at: #x) identicalTo: 4.  MetacelloPlatform current primeStackCacheWith: defaultDictionary doing: block.  self assert: ((defaultDictionary at: #cached) at: #key) identicalTo: 6.  self assert: ((defaultDictionary at: #collection) at: #x) identicalTo: 6.  self assert: ((defaultDictionary at: #cacheNil) at: #key) identicalTo: nil.  self assert: ((defaultDictionary at: #direct) at: #x) identicalTo: 6.  self assert: ((defaultDictionary at: #cached) at: #key) identicalTo: 6.  self assert: ((defaultDictionary at: #mixed) at: #x) identicalTo: 4.  self assert: ((defaultDictionary at: #mixedStack) at: #x) identicalTo: 4.  self assert: ((defaultDictionary at: #direct) at: #x) identicalTo: 6.  self assert: ((defaultDictionary at: #cached) at: #key) identicalTo: 6.  self assert: ((defaultDictionary at: #mixedStack) at: #x) identicalTo: 4fetchUsing: mcLoader  | fetchingSpecLoader |  fetchingSpecLoader := mcLoader fetchingSpecLoader.  fetchingSpecLoader linearLoadPackageSpecs: (Array with: self) repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs)baseline61ProjectIssue86: spec  < version: '6.1'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'A' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.1';                 loads: #('1');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'B' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.1';                 loads: #('2');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]exception  ^exceptiongetPreLoadDoIt  ^preLoadDoItpackagesNeedSavingVisited: visitedProjects using: repos into: aCollection  updatePackageMethodIn: aConfig sourceVersion: sourceVersionString  self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for replacement method'.  self prepareForMethodUpdate: aConfig sourceVersion: sourceVersionString forceUpdate: false generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap |  | strm pragma |        updatedPackageSpecsMap isEmpty ifTrue: [ ^false ].        strm := WriteStream on: String new.        strm           nextPutAll: selector asString , ' spec';           cr;           tab;           nextPutAll: '<version: ' , sourceVersionString printString.        pragma := pragmaMap at: selector.        pragma numArgs = 2 ifTrue: [ strm nextPutAll: ' imports: #('.              (pragma argumentAt: 2) do: [:versionString |  strm                       nextPutAll: versionString printString;                       space ] ].        strm           nextPutAll: ')>';           cr.        (ar at: 2) do: [:attribute |  | vs d |              vs := (ar at: 1) at: attribute.              (d := updatedPackageSpecsMap at: attribute ifAbsent: [  ]) ~~ nil ifTrue: [ vs packagesSpec list do: [:member |  member spec file ~~ nil ifTrue: [ | x |                                ((x := d at: member spec name ifAbsent: [  ]) ~~ nil and: [ x ~~ #uptodate ]) ifTrue: [ member spec file: x file ] ] ] ].              strm                 cr;                 tab;                 nextPutAll: 'spec for: ' , attribute printString , ' do: [';                 cr.              attribute == #common ifTrue: [ vs                       author: MetacelloPlatform current authorName;                       timestamp: MetacelloPlatform current timestamp ].              vs configMethodOn: strm indent: 2.              strm nextPutAll: '].' ].        (aConfig class compile: strm contents classified: (aConfig class whichCategoryIncludesSelector: pragma selector)) == nil ifTrue: [ self error: 'Error compiling the method' ] ].  ^trueimportFrom: inputVersionStringOrSymbol projectAttributes: projectAttributes inactiveAttributes: inactiveAttributesList updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock  | constructor updatedSpecs fullVersionSpec version visitedSpecs fromVersionString attributeSet |  constructor := self constructor.  updatedSpecs := Set new.  visitedSpecs := Set new.  version := project version: inputVersionStringOrSymbol.  fromVersionString := version versionString.  fullVersionSpec := version spec.  self methodSpec imports: {fromVersionString}.  constructor extractMethodSectionsFor: fromVersionString.  self editVersionSpecsForImport: constructor projectAttributes: projectAttributes active: true fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs.  attributeSet := projectAttributes.  inactiveAttributesList do: [:inactiveAttributes |  self editVersionSpecsForImport: constructor projectAttributes: inactiveAttributes active: false fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs.        attributeSet := attributeSet , projectAttributes ].  attributeSet := attributeSet asSet.  constructor methodSectionsDo: [:methodSection |  | versionSpec attributePath |        versionSpec := methodSection versionSpec.        attributePath := methodSection attributePath.        (methodSection includesAttributeFrom: attributeSet) ifFalse: [ versionSpec updateForSpawnMethod: versionSpec.              versionSpec specListProjectDo: [:spec |  spec updateForSpawnMethod: spec ] packageDo: [:spec |  spec updateForSpawnMethod: spec ] groupDo: [:spec |  spec updateForSpawnMethod: spec ].              self clearVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages ].        (aBlock value: attributePath asAttributeOrPath value: versionSpec) ifTrue: [ self methodSpec addMethodSection: attributePath versionSpec: versionSpec ] ]monticelloRepository  ^monticelloRepositorycurrentBranchName  ^self configurationProjectSpec ifNotNil: [ configurationProjectSpec versionOrNil ifNil: [ '' ] ifNotNil: [:vrsn |  vrsn blessing asString ] ] ifNil: [ baselineProjectSpec repositoryBranchName ]currentVersion  | cacheKey cv |  cacheKey := self configuration class.  ^MetacelloPlatform current stackCacheFor: #currentVersion at: cacheKey doing: [:cache |  cv := self currentVersionAgainst: nil.        ^cache at: cacheKey put: cv ]onDowngradeUseIncoming: projectNames  self onDowngrade: [:ex :loaded :incoming |  (projectNames includes: loaded baseName) ifTrue: [ ex useIncoming ] ifFalse: [ ex useLoaded ] ]versionNumberClass  ^MetacelloSemanticVersionNumbertestStandardMatch  self assert: ((self versionClass fromString: '1.1.1') match: '*.*.*').  self deny: ((self versionClass fromString: '1.1.1') match: '*.*').  self assert: ((self versionClass fromString: '1.1.0') match: '1.1.*').  self assert: ((self versionClass fromString: '1.1.0') match: '1.#.*').  self deny: ((self versionClass fromString: '1.10.0') match: '1.#.*').  self assert: ((self versionClass fromString: '1-alpha5.0') match: '1-alpha#.0').  self assert: ((self versionClass fromString: '1.alpha5.0') match: '1-alpha#.0').  self assert: ((self versionClass fromString: '1.alpha5.0') match: '1.alpha#.0').  self deny: ((self versionClass fromString: '1-alpha10.0') match: '1-alpha#.0')asRepositorySpecFor: aMetacelloMCProject  ^aMetacelloMCProject repositorySpec     description: self description;     type: self class basicDescription;     yourselfversionClass  ^MetacelloSemanticVersionNumberconfigMethodBodyOn: aStream hasName: hasName cascading: cascading indent: indent  | hasCascading hasRequires hasIncludes hasAnswers |  hasCascading := cascading.  hasRequires := self requires isEmpty not.  hasIncludes := self includes isEmpty not.  hasAnswers := self answers isEmpty not.  hasRequires ifTrue: [ hasName | hasIncludes | hasAnswers | hasCascading ifTrue: [ aStream                 cr;                 tab: indent ].        aStream nextPutAll: 'requires: #('.        self requires do: [:str |  aStream nextPutAll: str printString , ' ' ].        hasIncludes | hasAnswers | hasCascading ifTrue: [ aStream nextPutAll: ');' ] ifFalse: [ aStream nextPut: $) ] ].  hasIncludes ifTrue: [ hasName | hasRequires | hasAnswers | hasCascading ifTrue: [ aStream                 cr;                 tab: indent ].        aStream nextPutAll: 'includes: #('.        self includes do: [:str |  aStream nextPutAll: str printString , ' ' ].        hasAnswers | hasCascading ifTrue: [ aStream nextPutAll: ');' ] ifFalse: [ aStream nextPut: $) ] ].  hasAnswers ifTrue: [ hasName | hasRequires | hasIncludes | hasCascading ifTrue: [ aStream                 cr;                 tab: indent ].        aStream nextPutAll: 'supplyingAnswers: #( '.        self answers do: [:ar |  aStream nextPutAll: '#( '.              ar do: [:val |  (val isString or: [ val isNumber or: [ val isSymbol or: [ val isCharacter ] ] ]) ifTrue: [ aStream nextPutAll: val printString , ' ' ].                    val == true ifTrue: [ aStream nextPutAll: 'true ' ].                    val == false ifTrue: [ aStream nextPutAll: 'false ' ] ].              aStream nextPutAll: ') ' ].        hasCascading ifTrue: [ aStream nextPutAll: ');' ] ifFalse: [ aStream nextPut: $) ] ]version11Issue115: spec  < version: '1.1' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: ''.        spec package: 'GeauxFoo' with: 'GeauxFoo-lr.1' ]modifySymbolicVersionMethodFor: versionSymbol  ^self modifySymbolicVersionMethodFor: versionSymbol symbolicVersionSpecsDo: [:symbolicVersionSpec |  true ]onConflictUseLoaded  self onConflict: [:ex :loaded :incoming |  ex useLoaded ]versionSpec: anObject  versionSpec := anObjecthasLoadConflicts: aMetacelloProjectSpec  ^(self hasNoLoadConflicts: aMetacelloProjectSpec) notcallSite  ^callSiteactionLabel  ^'Fetching 'ensureSpecLoader  ^selfdirectivesDo: aBlock  aBlock value: self.  self preloads do: [:directive |  directive directivesDo: aBlock ].  self loadDirectives do: [:directive |  directive directivesDo: aBlock ].  self postloads do: [:directive |  directive directivesDo: aBlock ]bypassProgressBars: anObject  bypassProgressBars := anObjectapplyToList: aListSpec  aListSpec remove: selfbaseline20Foo: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #baseline.        spec           package: 'GoferBar';           package: 'GoferFoo';           package: 'GoferBeau';           package: 'GoferFaux';           yourself ]noQuit  ^self hasOption: 'no-quit'supplyingAnswers: anObject constructor: aVersionConstructor  aVersionConstructor supplyingAnswersForPackage: anObjectbaseline40ProjectIssue95: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Loop' with: [ spec                 className: 'MetacelloTestConfigurationOfProjectLoop';                 versionString: '4.0';                 loads: 'GoferFaux';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Infinite' with: [ spec                 className: 'MetacelloTestConfigurationOfProjectInfinite';                 versionString: '4.0';                 loads: 'GeauxBar';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]setUpBaselineOfExternalXX  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfExternalXX-dkh.1'.  className := #BaselineOfExternalXX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'externalBaselineXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalBaselineXX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfocacheRepository  ^(MetacelloMCProject new repositorySpec description: (self options at: #cacheRepository ifAbsent: [ ^nil ])) createRepositorycopyForRegistration: aMetacelloProjectRegistration onWrite: aBlock  self subclassResponsibilitysetUpConfigurationOfProjectFie  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectFie-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline15ProjectFie:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline15ProjectFie:) asString) .   (MCMethodDefinition className: className asString selector: 'baseline25ProjectFie:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline25ProjectFie:) asString) .   (MCMethodDefinition className: className asString selector: 'baseline35ProjectFie:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline35ProjectFie:) asString) .   (MCMethodDefinition className: className asString selector: 'baseline40ProjectFie:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline40ProjectFie:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())canUpgradeTo: aMetacelloProjectSpec  (self className = aMetacelloProjectSpec className and: [ self operator == aMetacelloProjectSpec operator ]) ifFalse: [ ^false ].  self versionOrNil == nil ifTrue: [ ^true ].  ^self compareVersions: aMetacelloProjectSpec usingOperator: self operatorlist  list == nil ifTrue: [ list := OrderedCollection new ].  ^listrepositoriesSpecClass  ^MetacelloRepositoriesSpecrepositoryBranchName  | spec repo |  self repositorySpecs do: [:repoSpec |  spec := repoSpec ].  repo := spec createRepository.  ^repo repositoryBranchNamerepositoryError  ^repositoryErrorsetUpConfigurationExternalRefdkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternalRef-dkh.2'.  className := #ConfigurationOfExternalRef.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationExternalRef090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef090:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationExternalRef091:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef091:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationExternalRef092:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef092:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfospecListDetect: aBlock ifNone: exceptionBlock  self specListDo: [:each |  (aBlock value: each) ifTrue: [ ^each ] ].  ^exceptionBlock valueissue  ^issueupdateVersionMethodForVersion: inputVersionStringOrSymbol updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock  ^self updateVersionMethodForVersion: inputVersionStringOrSymbol projectAttributes: project attributes updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlockversion10Issue156: spec  < version: '1.0.0'>  spec for: #common do: [ spec           configuration: 'Goo' with: [ spec                 versionString: '3.0.0';                 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           yourself ]baseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/Example'.        spec           package: 'Example-Core';           package: 'Example-Tests' with: [ spec requires: 'Example-Core' ];           package: 'Example-AddOn' with: [ spec requires: 'Example-Core' ];           package: 'Example-AddOnTests' with: [ spec requires: #('Example-AddOn' 'Example-Tests') ].        spec           group: 'default' with: #('Example-Core' 'Example-AddOn');           group: 'Tests' with: #('Example-Tests' 'Example-AddOnTests') ]callSite: anObject  callSite := anObjectname: aString  ((aString at: 1) isSeparator or: [ (aString at: aString size) isSeparator ]) ifTrue: [ self error: 'Names are not allowed to have leading or trailing blanks: ' , aString printString ].  name := aStringcalculate: aConfig project: aProject  | pragma versionMap versionSpec |  self configuration: aConfig.  pragma := self extractBaselinePragmaFor: aConfig class.  self setProject: (aProject ifNil: [ [ aConfig class project ] on: MessageNotUnderstood do: [:ex |  ex return: nil ] ]).  versionSpec := self project versionSpec.  self root: versionSpec.  self evaluatePragma: pragma.  versionMap := Dictionary new.  self project attributes do: [:attribute |  | blockList |        (blockList := self attributeMap at: attribute ifAbsent: [  ]) ~~ nil ifTrue: [ blockList do: [:block |  self with: versionSpec during: block ] ] ].  versionSpec versionString: self project singletonVersionName.  versionMap at: versionSpec versionString put: versionSpec createVersion.  self project map: versionMap.  self project configuration: aConfigcopyOnWrite: aBlock  | copy |  self class registry registrationFor: self ifPresent: [:existing |   ] ifAbsent: [ aBlock value: self.        ^self ].  self unregisterProject.  copy := self copy.  aBlock value: copy.  copy registerProject.  ^copymethodSection: methodSection pre: preBlock last: last post: postBlock indent: indent  | list |  methodSection ~~ self ifTrue: [ preBlock value: methodSection value: indent ].  list := methodSection methodSections.  1 to: list size do: [:index |  | ms |        ms := list at: index.        self methodSection: ms pre: preBlock last: index ~= list size post: postBlock indent: indent + 1 ].  methodSection ~~ self ifTrue: [ postBlock value: methodSection value: indent value: last ]preloadDoIt  Smalltalk at: #Metacello_Configuration_Test_DoIt_Result put: truegtInspectorChildren  ^{}forceUpdatePackageSpec: updatedSpecs using: anMCLoader  self updatePackageSpec: updatedSpecs force: true using: anMCLoaderdefaultAction  ^falserepository: aStringOrMetacelloRepositorySpec  self repositories repository: aStringOrMetacelloRepositorySpec.  self projectPackage: nilprojectSpec: aMetacelloMCProjectSpec  projectSpec := aMetacelloMCProjectSpecsetDescriptionInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setDescription: selfpackageSpecsInLoadOrder  ^{self}project: anObject  project := anObjectlockConfiguration15: spec  < version: '1.5.0'>  spec for: #common do: [ spec blessing: #release.        spec description: self className , '>>lockConfiguration15: '.        spec baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA , '/repository' ] ]lesson11Blessing  versionKey  ^String streamContents: [:aStream |  | label |        self versionNumber printOn: aStream.        self basicSpec ~~ nil ifTrue: [ (label := self projectLabel) isEmpty ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ] ]setUpConfigurationOfProjectConfigIssue283dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfProjectConfigIssue283-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'projectVersion10Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #projectVersion10Issue283:) asString) .   (MCMethodDefinition className: className asString selector: 'projectVersion20Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #projectVersion20Issue283:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoversion  ^self projectReference versionlesson11  ^Lesson title: 'Lesson 11' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."In version 0.11 we''ve defined a couple of attributes that are expected to be used all of the timein a version specification:  #blessing:  #description:  #author:  #timestamp:The following lessons cover each of these attributes in more detail. "ProfStef next.'packagesNeedSaving: aVersionString  | packages |  packages := Set new.  (self version: aVersionString) spec packagesNeedSavingVisited: (Set with: self configuration class name asString) into: packages.  ^packagespackageNames  packages == nil ifTrue: [ ^super packageNames ].  ^self packages map keys asSetversionOfExternal091: spec  < version: '0.9.1'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>versionOfExternal091:'.        spec author: 'dkh'.        spec timestamp: '5/4/2012 14:16'.        spec baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]commitId  | repoRoot |  repoRoot := self repoPath isEmpty ifTrue: [ self directory ] ifFalse: [ self directory parent ].  ^repoRoot basename copyAfterLast: $-project  | project |  project := MetacelloMCProject new.  project projectAttributes: MetacelloConfigurationResource projectAttributes.  MetacelloVersionConstructor on: self project: project.  project loader: (project loaderClass new           shouldDisablePackageCache: true;           yourself).  project loadType: #linear.  ^projectpackageSpec: aMetacelloPackageSpec  packageSpec := aMetacelloPackageSpecversion: aVersionString  aVersionString isSymbol ifTrue: [ | symbolicVersionString |        symbolicVersionString := self symbolicVersionMap at: aVersionString ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: aVersionString) signal ].        symbolicVersionString == #notDefined ifTrue: [ (MetacelloSymbolicVersionNotDefinedError project: self project versionString: aVersionString) signal ].        ^self lookupVersion: symbolicVersionString ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: symbolicVersionString) signal ] ].  ^self lookupVersion: aVersionString ifAbsent: [ (MetacelloVersionDoesNotExistError project: self project versionString: aVersionString) signal ]versionReferences  ^versionReferencesgroup: aString with: aStringOrCollection constructor: aVersionConstructor  aVersionConstructor groupForVersion: aString with: aStringOrCollectiondoSilently  ^truetestPackageMergeSpec  | packageA packageB package repository |  packageA := self packageSpec     name: 'Package';     name: 'Package';     requires: 'AnotherPackage';     includes: 'IncludedPackage';     answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));     file: 'Package-dkh.1';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  packageB := self packageSpec     name: 'Package';     requires: 'AndAnotherPackage';     includes: 'AndIncludedPackage';     answers: #(#('xpostload' 'xpostload answer'));     file: 'Package-dkh.2';     repository: 'http://example.com/repository' username: 'DaleHenrichs' password: 'secret';     repository: '/opt/gemstone/repo';     yourself.  package := packageA mergeSpec: packageB.  self assert: package name equals: 'Package'.  self assert: package requires equals: #('AnotherPackage' 'AndAnotherPackage').  self assert: package includes equals: #('IncludedPackage' 'AndIncludedPackage').  self assert: package answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer') #('xpostload' 'xpostload answer')).  self assert: package file equals: 'Package-dkh.2'.  self assert: package preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: package postLoadDoIt value identicalTo: #postLoadDoIt.  repository := package repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := package repositories map at: '/opt/gemstone/repo' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := package repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'DaleHenrichs'.  self assert: repository password equals: 'secret'repositoryArg: anObject  repositoryArg := anObjecttestAlphaNumericVersion3  self assert: (self versionClass fromString: '2.9.9-alpha.2') < (self versionClass fromString: '2.9.10')baselineVersion20Issue119: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec package: 'GoferBar ' ]aboutToCopy  self projectReference classNamespec: aMetacelloPackagesSpec  spec := aMetacelloPackagesSpecstatements  statements ifNil: [ statements := OrderedCollection new ].  ^statementsversion41Issue119: spec  < version: '4.1' imports: #('4.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo ' with: '2.0'.        spec package: 'GoferBar' with: 'GoferBar-jf.1' ]resolveDependencies: aResolvedReference nearest: nearestReference into: aCollection  | block retryCount coll notDone |  self flag: 'Not used, but retained to avoid upgrade issues'.  block := [:dependency |  | reference |  reference := MetacelloCachingGoferResolvedReference name: dependency versionInfo name repository: aResolvedReference repository.  coll add: reference.  MetacelloNotification signal: 'Fetched dependency -> ' , reference name , ' --- ' , reference repository repositoryDescription.  self resolveDependencies: reference nearest: reference into: coll ].  retryCount := 0.  notDone := true.  coll := OrderedCollection new.  [ notDone and: [ retryCount < 3 ] ] whileTrue: [ retryCount > 0 ifTrue: [ MetacelloNotification signal: '...RETRY' ].        [ aCollection do: [:each |  each version ].        nearestReference version dependencies do: block.        notDone := false ] on: Error do: [:ex |  retryCount := retryCount + 1.              retryCount >= 3 ifTrue: [ ex pass ].              coll := OrderedCollection new ] ].  aCollection addAll: coll.  ^aCollectionoperator  ^self loader operatorsetUpConfigurationOfExternalXX  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternalXX-dkh.1'.  className := #ConfigurationOfExternalXX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfXX:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfotestDictionaryRepository  | project pkg repoSpec repo |  project := self project.  pkg := (project version: '1.5-baseline') packageNamed: 'Example-Core'.  repoSpec := pkg repositorySpecs first.  self assert: repoSpec type equals: 'dictionary'.  repo := repoSpec createRepository.  self assert: repo class identicalTo: MCDictionaryRepository.  self assert: repo dictionary identicalTo: (testingEnvironment at: #Metacello_Platform_Test_GlobalDictionary) dictionaryregister  ^self execute: #register args: #()packages  packageList == nil ifTrue: [ packageList := self project packagesSpec ].  ^packageListupdatedPackageSpecs  | updatedSpecs mcLoader |  updatedSpecs := Dictionary new.  mcLoader := self loader.  self packages map valuesDo: [:pkg |  pkg updatePackageSpec: updatedSpecs using: mcLoader ].  ^updatedSpecssetUp  super setUp.  self     setUpVersionReferences;     setUpMonticelloRepositorysetUpConfigurationOfAtomicFoo  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfAtomicFoo-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline20Foo:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'baseline25Foo:' category: 'cat' timeStamp: '' source: self baseline25MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'version20Foo:' category: 'cat' timeStamp: '' source: self version20MethodSourceFoo)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())ensureDirectoryExists: aDirectoryHandle  ^aDirectoryHandle     assureExistence;     yourselfcollectDefaultSymbolicVersionsFromVersionPragmasFrom: versionPragmaDict into: symbolicVersionMap using: executionBlock  | defined versionString |  versionPragmaDict keysAndValuesDo: [:versionSymbol :pragmaColl |  defined := false.        symbolicVersionMap at: versionSymbol ifAbsent: [ pragmaColl do: [:pragma |  defined := true.                    versionString := executionBlock value: versionSymbol value: pragma ].              defined ifTrue: [ versionString == nil ifFalse: [ symbolicVersionMap at: versionSymbol put: versionString ] ].              self reset ] ]createFiletreeRepository: aRepositorySpec  | cl description headerSize |  cl := Smalltalk at: #MCFileTreeRepository.  description := aRepositorySpec description.  headerSize := 'filetree://' size.  ^cl new     directory: (self fileHandleOn: (aRepositorySpec description copyFrom: headerSize + 1 to: description size));     yourselfrepositorySpecs  ^self repositories map valuesaddSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies groups: groups versionSpecsDo: aBlock  self addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: #() files: #() repositories: #() preLoadDoIts: #() postLoadDoIts: #() supplyingAnswers: #() groups: groups versionSpecsDo: aBlocktimestamp  ^DateAndTime now printStringbaseline10MethodSourceD  ^(self class sourceCodeAt: #baseline10D:) asStringsetUpConfigurationOfMetacelloExampledkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfMetacelloExample-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion10MetacelloExample:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10MetacelloExample:) asString) .   (MCMethodDefinition className: className asString selector: 'version10MetacelloExample:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10MetacelloExample:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoclassName: aString constructor: aVersionConstructor  aVersionConstructor classNameForProject: aStringprojectPath  ^projectPathblessing: anObject  anObject setBlessingInMetacelloVersion: selfcreateGithubRepository: aRepositorySpec  | cl |  cl := Smalltalk at: #MCGitHubRepository.  ^cl location: aRepositorySpec descriptionscpUrl  ^'git@bitbucket.org:' , projectPath , '.git'description  ^'The symbolic version ' , self versionString printString , ' is EXPLICITLY not defined in ' , self project label , ' for the current platform (i.e., symbolic version defined as #notDefined).'project: aMetacelloProject  project := aMetacelloProjectvalidateMergeForSpec: aSpec  attributeOrder  attributeOrder == nil ifTrue: [ attributeOrder := OrderedCollection new ].  ^attributeOrderprepostLoadDirectivesDo: aBlock  packageSpec  ^packageSpecoperationString  self subclassResponsibilitytestTempFileFor  | tempFilePath |  tempFilePath := MetacelloPlatform current tempFileFor: 'xxx' suffix: '.test'preLoadDoIt: aSymbol constructor: aVersionConstructor  aVersionConstructor preLoadDoItForVersion: aSymbolbaseline15: spec  < version: '1.5-baseline'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'dictionary://Metacello_Platform_Test_GlobalDictionary' ] ]command: arguments  ^MetacelloCommandLineHandler commandLine: (self argumentsWith: arguments)baselineArg: anObject  baselineArg := anObjectaLoadedPackageIsExact  ^aLoadedPackageIsExactexplicitLoadWithPolicy: aLoadPolicy  | gofer |  gofer := MetacelloGofer new.  gofer disablePackageCache.  gofer repository: aLoadPolicy cacheRepository.  self explicitLoadUsing: self gofer: goferremoveFromMetacelloRepositories: aMetacelloRepositoriesSpec  aMetacelloRepositoriesSpec addMember: selfhandleProjectSpecLoaded: exception  MetacelloProjectRegistration registrationForProjectSpec: exception projectSpec ifAbsent: [:new |  new           loadedInImage: true;           registerProject ] ifPresent: [:existing :new |  existing copyOnWrite: [:existingCopy |  existingCopy                 loadedInImage: true;                 merge: new ] ].  exception resumeloader  ^loadervalidateProject: project version: versionString  | version spec |  (self visited includes: project configuration class) ifTrue: [ ^self validationReport ].  self visited add: project configuration class.  [ version := project version: versionString ] on: Error do: [:ex |  self recordValidationError: 'Could not resolve version ' , versionString printString , ' due to error: ' , ex description versionString: versionString callSite: #validateProject:version: reasonCode: #cannotResolveVersion.        ^self validationReport ].  spec := version spec.  [ spec blessing value == #baseline ifTrue: [ self validateBaselineVersionSpec: spec ] ifFalse: [ self validateVersionSpec: spec ] ] on: Error do: [:ex |  self recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description versionString: version versionString callSite: #validateProject:version: reasonCode: #versionCompositionError ].  ^self validationReportmap: aDictionary  versionMap := aDictionarycanUpgradeTo: aProjectSpec  (self repositories canUpgradeTo: aProjectSpec repositories) ifTrue: [ ^true ].  ^falselesson07  ^Lesson title: 'Lesson 7' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline07:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version07:."NOTE: you should run through the lessons in Part 1 first.In this configuration we are defining a project that utilizes the packages from the Example project (MetacelloTutorialConfig):  ''Example-Core'', ''Example-AddOn'', ''Example-Tests'' and 2 packages specific to the project: ''Project-Core'' and ''Project-Tests'':"  (MetacelloProjectRefTutorialConfig project version: ''0.7'') load.ProfStef next.'validateVersionString: versionString againstSpec: versionSpec  versionString = versionSpec versionString ifFalse: [ MetacelloValidationNotification signal: (MetacelloValidationError configurationClass: self configurationClass reasonCode: #incorrectVersionString callSite: #'validateVersionString:againstSpec' explanation: 'The version declared in the pragma ' , versionString printString , ' does not match the version in the spec ' , versionSpec versionString printString) ]hasClassName  ^className ~~ nil and: [ className ~= self constructClassName ]importArray  ^importArraydo: aBlock  1 to: self size do: [:index |  aBlock value: (self at: index) ]testStableVersionMethod  | project |  project := self projectWith: #(#'platformVersion1.x').  self assert: (project version: #stable) equals: project stableVersionmodifyVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: aBlock  ^self updateVersionMethodForVersion: inputVersionStringOrSymbol updateProjects: false updatePackages: false versionSpecsDo: aBlockproject  ^self projectWith: #()cacheRepository  cacheRepository == nil ifTrue: [ cacheRepository := MCDictionaryRepository new ].  ^cacheRepositorypreLoadDoItForSpec: aSymbol  self validateDoItSelector: aSymbol.  self root preLoadDoIt: aSymbolbaseline12: spec  < version: '1.2-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/Project'.        spec           project: 'Example Default' with: [ spec                 className: 'MetacelloTutorialConfig';                 versionString: '1.2';                 loads: #('default');                 file: 'Metacello-Tutorial';                 repository: 'http://seaside.gemstone.com/ss/metacello' ];           project: 'Example Tests' copyFrom: 'Example Default' with: [ spec loads: #('Tests') ].        spec           package: 'Project-Core' with: [ spec requires: 'Example Default' ];           package: 'Project-Tests' with: [ spec requires: #('Project-Core' 'Example Tests') ] ]printOn: aStream  | printBlock |  printBlock := [:pkgName :ar |  aStream     tab: 2;     nextPutAll: pkgName asString;     cr.  aStream     tab: 3;     nextPutAll: (ar at: 1) asString printString;     nextPutAll: ' to ';     nextPutAll: (ar at: 2) asString printString;     cr ].  aStream     nextPutAll: self configuration asString;     space;     nextPutAll: from asString printString;     nextPutAll: ' to ';     nextPutAll: to asString printString;     cr.  aStream     tab;     nextPutAll: 'Additions:';     cr.  self additions keysAndValuesDo: printBlock.  aStream     tab;     nextPutAll: 'Modifications:';     cr.  self modifications keysAndValuesDo: printBlock.  aStream     tab;     nextPutAll: 'Removals:';     cr.  self removals keysAndValuesDo: printBlock= aRegistration  aRegistration class == self class ifFalse: [ ^false ].  ^(configurationProjectSpec registrationsCompareEqual: aRegistration configurationProjectSpec) and: [ baselineProjectSpec registrationsCompareEqual: aRegistration baselineProjectSpec ]extractBaselinePragmaFor: aClass  | pragmas |  pragmas := Pragma allNamed: #baseline in: aClass.  pragmas isEmpty ifTrue: [ ^self error: 'No #baseline pragma found' ].  ^pragmas firstmethodUpdateSelector  ^#overrides:defaultPackageCache  ^MCCacheRepository defaultprojectLabel  ^self projectReference projectLabelfileForProject: aString  self root file: aStringdeleteSpec: aSpec  self packages deleteSpec: aSpeccreateIcebergRepositoryFor: remoteUrl  | builder repository |  builder := IceRepositoryCreator new     url: remoteUrl;     subdirectory: repoPath;     commitishName: self projectVersion;     ensureProjectFile;     yourself.  [ repository := builder createRepository ] on: IceDuplicatedRepository do: [:e |  e resignalAs: (IceMetacelloDuplicatedNotification new                 builder: builder;                 yourself) ].  repository register.  ^repositoryrepositoriesSpec  ^self repositoriesSpecClass for: selfhasRepository  ^self projectReference hasRepositoryprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  self loadDirective printOn: aStream.  aStream nextPut: $)versionOfX091: spec  < version: '0.9.1'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>versionOfX091:'.        spec author: 'dkh'.        spec timestamp: '5/4/2012 14:16' ].  spec for: #custom do: [ spec baseline: 'ExternalX' with: [ spec repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]project  ^project ifNil: [ | constructor |        constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.        project := constructor project ]packageNamed: aString ifAbsent: aBlock  ^self packageNamed: aString forMap: self packages map ifAbsent: aBlockversionComponents  ^self normalVersion , self preReleaseVersion , self buildVersionlesson06  ^Lesson title: 'Lesson 6' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version06:."In version 0.6 we''ve added dependency information in the form of the #requires: directive.Both ''Example-Tests'' and  ''Example-AddOn'' require ''Example-Core'' to be loaded before they areloaded. Print the following expressions to see that the requires directives are being followed:"  (MetacelloTutorialConfig project version: ''0.5'') load: { ''Example-Tests''. }.  (MetacelloTutorialConfig project version: ''0.6'') load: { ''Example-Tests''. }.  (MetacelloTutorialConfig project version: ''0.6'') load: ''Example-AddOn''.  (MetacelloTutorialConfig project version: ''0.6'') load: { ''Example-AddOn''. ''Example-Tests''. }."With version 0.6 we are mixing structural information (required packages and repository) with thedynamic file version info. It is expected that over time the file version info will change fromversion to version while the structural information will remain relatively static."ProfStef next.'testMergeGroupB  | packages group |  packages := self packagesSpec.  packages add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  packages merge: {(self groupSpec           name: 'Platform';           includes: 'Tests';           yourself)}.  group := packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (group includes includes: 'Core').  self assert: (group includes includes: 'Tests')groupSpec  ^self groupSpecClass for: selfbaseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://smalltalkhub.com/mc/JohnDoe/MyProject/main'.        self           fuelMetalevel: spec;           fileSystemLegacy: spec.        spec           package: 'MyProject-Core';           package: 'MyProject-Tests' with: [ spec requires: #('MyProject-Core' 'FuelMetalevel' 'FileSystemLegacy') ].        spec           group: 'default' with: #('core' 'test');           group: 'test' with: #('MyProject-Tests');           group: 'core' with: #('MyProject-Core') ]printLoadDirectivesOn: aStream indent: indent  self loadDirectives do: [:each |  aStream cr.        each printOn: aStream indent: indent + 1 ]configurationArg  ^configurationArgsetUpConfigurationOfUmbrellaA  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfUmbrellaA-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'version50Umbrella:' category: 'cat' timeStamp: '' source: self version50MethodSourceUmbrella)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())postCopy  super postCopy.  baselineRegistry := self baselineRegistry copy.  configurationRegistry := self configurationRegistry copyprojectClass  ^MetacelloMCProjectlatestVersionMatching: versionPatternString  ^self latestVersionMatching: versionPatternString includedBlessings: #() excludedBlessings: self excludeFromLatestVersiontestVersion18  | x y |  self deny: (x := self versionClass fromString: '1.0.0') < (y := self versionClass fromString: '1.0.0-0').  self assert: (x := self versionClass fromString: '1.0.0') > (y := self versionClass fromString: '1.0.0-0').  self assert: (x := self versionClass fromString: '1.0.0') < (y := self versionClass fromString: '1.0.0+0').  self deny: (x := self versionClass fromString: '1.0.0') > (y := self versionClass fromString: '1.0.0+0')loader: aLoader  self versionSpec loader: aLoaderisPackageLoaded  ^falsepackage: packageName with: aBlockOrString  self root package: packageName with: aBlockOrString constructor: selfversionDo: aBlock  aBlock value: selfdirectReturnOfValue  ^MetacelloPlatform current stackCacheFor: #direct at: #key doing: [:cache |  | value |        value := cache at: #x ifAbsent: [ 0 ].        value > 5 ifTrue: [ ^value ].        value := value + 1.        cache at: #x put: value.        self directReturnOfValue ]mixedStack  ^MetacelloPlatform current stackCacheFor: #mixed at: #key doing: [:cache |  | value |        value := cache at: #x ifAbsent: [ 0 ].        value > 3 ifTrue: [ ^value ].        value := value + 1.        cache at: #x put: value.        self assert: self directReturnOfValue identicalTo: 6.        self assert: self mixedStackCall identicalTo: 4.        self mixedStack ]swa: projectName  self swasource: projectNameincludesAttributeFrom: attributeCollection  ^(attributeCollection asSet intersection: self attributes asSet) notEmptyprintOn: aStream  self printOn: aStream indent: 0testBleedingEdgeMethod  | project |  project := self projectWith: #(#'platformVersion1.x').  self assert: (project version: #bleedingEdge) equals: project bleedingEdgeversion40Symbolic: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #release.        spec           package: 'GoferBeau' with: 'GoferBeau-dkh.15';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           yourself ]forceUpdatePackageSpec: updatedSpecs using: anMCLoader  ^self updatePackageSpec: updatedSpecs using: anMCLoaderhasConflictWithProjectSpec: projectSpec  ^projectSpec hasConflictWithConfigurationSpec: selfpreLoadDoItBlock  ^self doItBlock: self preLoadDoIt valuesetUpConfigurationOfProjectFee  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectFee-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline40ProjectFee:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectFee)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())setPackage: aString withBlock: aBlock  | spec |  spec := self project packageSpec     name: aString;     yourself.  self root packages merge: spec.  self with: spec during: aBlockmethodUpdateSelector  ^#copy:version20MethodSourceFoo  ^(self class sourceCodeAt: #version20Foo:) asStringversionNumber  ^versionNumberversionString  self shouldNotImplementcompareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader  ^falsegroupSpec  ^self project groupSpecdescription: aBlockOrString constructor: aVersionConstructor  aVersionConstructor descriptionForVersion: aBlockOrStringloader: aLoader  loader := aLoaderupdateForSpawnMethod: sourceSpec  answers := name := requires := includes := nilbaselineVersion30Issue154: spec  < version: '3.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec           project: 'MetacelloExample' with: [ spec                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]development: spec  < symbolicVersion: #development>  spec for: #common version: 'dev'cachedReturnOfValue  ^MetacelloPlatform current stackCacheFor: #cached at: #key doing: [:cache |  | value |        value := cache at: #x ifAbsent: [ 0 ].        value > 5 ifTrue: [ cache at: #key put: value ] ifFalse: [ value := value + 1.              cache at: #x put: value ].        self cachedReturnOfValue ]valueForValueHolder: anObject  self root value: anObjectimmutable  mutable := falsecurrentVersionAgainst: resolvedPackageAndProjectNames  | cacheKey |  cacheKey := resolvedPackageAndProjectNames ifNil: [ Array with: self configuration class with: nil ] ifNotNil: [ Array with: self configuration class with: (resolvedPackageAndProjectNames sort: [:a :b |  a <= b ]) ].  ^MetacelloPlatform current stackCacheFor: #currentVersionAgainst: at: cacheKey doing: [:cache |  | cv versions latestSomethingLoaded |        cv := nil.        versions := self sortedAndFilteredVersions.        versions do: [:version |  | status matchBlock |              status := resolvedPackageAndProjectNames ifNil: [ version spec isPartiallyCurrent ] ifNotNil: [ version spec isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].              matchBlock := [:matchStatus |  cv := version copy.              cv versionStatus: matchStatus.              ^cache at: cacheKey put: cv ].              status isAllLoadedToSpec: matchBlock.              status isLoadedToSpec: matchBlock.              status isLoadedMatchConstraints: matchBlock.              status isSomethingLoaded: [:matchStatus |  latestSomethingLoaded ifNil: [ cv := version copy.                          cv versionStatus: matchStatus.                          latestSomethingLoaded := cv ] ] ].        latestSomethingLoaded ifNotNil: [ ^cache at: cacheKey put: latestSomethingLoaded ].        ^cache at: cacheKey put: nil ]setUpConfiguration181  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfIssue181-dkh.1'.  className := #ConfigurationOfIssue181.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration091Issue181:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration091Issue181:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration092Issue181:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration092Issue181:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration093Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration093Issue185:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration094Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration094Issue185:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration095Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration095Issue185:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration096Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration096Issue185:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration097Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration097Issue185:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration098Issue215:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration098Issue215:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfocreateFtpRepository: aRepositorySpec  | description headerSize index host directory |  description := aRepositorySpec description.  headerSize := 'ftp://' size.  index := description indexOf: $/ startingAt: headerSize + 1.  host := description copyFrom: headerSize + 1 to: index - 1.  directory := description copyFrom: index + 1 to: description size.  ^MCFtpRepository host: host directory: directory user: aRepositorySpec username password: aRepositorySpec passwordprojectClass  ^MetacelloProjectdefaultBleedingEdgeVersion  | bleedingEdgeVersion |  bleedingEdgeVersion := (self project map values select: [:version |  version blessing == #baseline ]) detectMax: [:version |  version ].  bleedingEdgeVersion ifNil: [ ^#notDefined ].  ^bleedingEdgeVersion versionStringtestRemoveB  | repositories removed |  repositories := self repositoriesSpec.  repositories add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  repositories remove: {(self repositorySpec           description: 'http://example.com/repository';           yourself)}.  removed := false.  repositories map at: 'http://example.com/repository' ifAbsent: [ removed := true ].  self assert: removedbaseline20Foo: spec  < version: '2.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar.branch-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           package: 'GoferBeau' with: 'GoferBeau-dkh.25';           yourself ]incrementMinorVersion  self incrementNormalVersionAt: 2baselineVersion20Issue171: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec package: 'GeauxFoo' ]mergeMap  | map |  map := super mergeMap.  map at: #versionString put: versionString.  map at: #blessing put: blessing.  map at: #description put: description.  map at: #author put: author.  map at: #timestamp put: timestamp.  map at: #preLoadDoIt put: preLoadDoIt.  map at: #postLoadDoIt put: postLoadDoIt.  map at: #packageList put: self packages.  ^mapprepostLoadDirectivesDo: aBlock  self loadDirectives do: [:directive |  directive prepostLoadDirectivesDo: aBlock ]baseline40MethodSourceFeaux  ^(self class sourceCodeAt: #baseline40Feaux:) asStringversionInfo  versionInfo ifNil: [ versionInfo := MetacelloProjectRegistrationVersionInfo new.        self configurationProjectSpecIfPresent: [ versionInfo versionString: self version ] ifAbsent: [  ] ].  ^versionInfotestMCVersionMergeSpec  | versionA versionB version repository package group projectReferenceSpec |  versionA := self versionSpec     blessing: #baseline;     versionString: '1.0';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  versionA packages     merge: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           yourself);     merge: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself);     merge: (self projectReferenceSpec           name: 'Project';           projectReference: (self projectSpec                 name: 'Project';                 projectPackage: self project packageSpec;                 className: 'ConfigurationOfProjectA';                 repository: 'http://example.com/repository' username: 'dkh' password: 'password';                 repository: '/opt/gemstone/repository';                 yourself));     yourself.  versionB := self versionSpec     blessing: #release;     versionString: '1.1';     repository: 'http://example.com/repository' username: 'DaleHenrichs' password: 'secret';     repository: '/opt/gemstone/repo';     yourself.  versionB packages     merge: (self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           yourself);     merge: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself);     merge: (self projectReferenceSpec           name: 'Project';           projectReference: (self projectSpec                 name: 'Project';                 projectPackage: self project packageSpec;                 className: 'ConfigurationOfProjectA';                 repository: 'http://example.com/repository' username: 'DaleHenrichs' password: 'secret';                 repository: '/opt/gemstone/repo';                 yourself));     yourself.  version := versionA mergeSpec: versionB.  self assert: version blessing value equals: #release.  self assert: version versionString value equals: '1.1'.  repository := version repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := version repositories map at: '/opt/gemstone/repo' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := version repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'DaleHenrichs'.  self assert: repository password equals: 'secret'.  package := version packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: package name equals: 'Package'.  projectReferenceSpec := version packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: projectReferenceSpec projectName equals: 'Project'.  repository := projectReferenceSpec repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := projectReferenceSpec repositories map at: '/opt/gemstone/repo' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := projectReferenceSpec repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'DaleHenrichs'.  self assert: repository password equals: 'secret'.  group := version packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (group includes includes: 'Core').  self assert: (group includes includes: 'Tests')testApproxVersion03  self assert: '1.1' asMetacelloVersionNumber ~> '1.1' asMetacelloVersionNumberresolvedReference: anObject  resolvedReference := anObjectdeleteFileNamed: filePath  filePath asFileReference ensureDeletebaselineArg  ^baselineArgonLockBreak  self onLock: [:ex :loaded :incoming |  ex break ]croquet: projectName  self repository: 'http://hedgehog.software.umn.edu:8888/' , projectNameprojectForScriptEngine: aMetacelloScriptEngine  ^self projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: falselesson04  ^Lesson title: 'Lesson 4' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version04:."The specification for version 0.4 is basically the same as version 0.3. Instead of listing a repository with each package we specify a project repository that applies to all packages.Compare the printStrings for the specs for each version:"  (MetacelloTutorialConfig project version: ''0.3'') spec.  (MetacelloTutorialConfig project version: ''0.4'') spec.ProfStef next.'loadType  ^self project loadTypedifference: otherVersionSpec  | report myProjectSpecs myPackageSpecs otherProjectSpecs otherPackageSpecs |  report := MetacelloVersionDiffReport new.  myProjectSpecs := Dictionary new.  myPackageSpecs := Dictionary new.  self projectDo: [:projectSpec |  myProjectSpecs at: projectSpec name put: projectSpec ] packageDo: [:packageSpec |  myPackageSpecs at: packageSpec name put: packageSpec ] groupDo: [:ignored |   ].  otherProjectSpecs := Dictionary new.  otherPackageSpecs := Dictionary new.  otherVersionSpec projectDo: [:projectSpec |  otherProjectSpecs at: projectSpec name put: projectSpec ] packageDo: [:packageSpec |  otherPackageSpecs at: packageSpec name put: packageSpec ] groupDo: [:ignored |   ].  myProjectSpecs valuesDo: [:myProjectSpec |  | otherProjectSpec |        otherProjectSpec := otherProjectSpecs at: myProjectSpec name ifAbsent: [  ].        otherProjectSpec == nil ifTrue: [ report removals at: myProjectSpec name put: {myProjectSpec versionString .                     ''} ] ifFalse: [ myProjectSpec versionString = otherProjectSpec versionString ifFalse: [ report modifications at: myProjectSpec name put: {myProjectSpec versionString .                           otherProjectSpec versionString} ] ] ].  otherProjectSpecs valuesDo: [:otherProjectSpec |  (myProjectSpecs at: otherProjectSpec name ifAbsent: [  ]) == nil ifTrue: [ report additions at: otherProjectSpec name put: {'' .                     otherProjectSpec versionString} ] ].  myPackageSpecs valuesDo: [:myPackageSpec |  | otherPackageSpec |        otherPackageSpec := otherPackageSpecs at: myPackageSpec name ifAbsent: [  ].        otherPackageSpec == nil ifTrue: [ report removals at: myPackageSpec name put: {myPackageSpec file .                     ''} ] ifFalse: [ myPackageSpec file = otherPackageSpec file ifFalse: [ report modifications at: myPackageSpec name put: {myPackageSpec file .                           otherPackageSpec file} ] ] ].  otherPackageSpecs valuesDo: [:otherPackageSpec |  (myPackageSpecs at: otherPackageSpec name ifAbsent: [  ]) == nil ifTrue: [ report additions at: otherPackageSpec name put: {'' .                     otherPackageSpec file} ] ].  ^reporttestApproxVersion02  self deny: '1.1' asMetacelloVersionNumber ~> '1' asMetacelloVersionNumberasMetacelloVersionNumber  ^selfprojectWith: projectAttributes  | project |  project := MetacelloMCProject new.  project projectAttributes: projectAttributes.  MetacelloVersionConstructor on: self project: project.  project loader: (project loaderClass new           shouldDisablePackageCache: true;           yourself).  project loadType: self loadType.  ^projecttestSemanticVersioningSpecItem10  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-0.3.7' '1.0.0-x.7.z.92')baseline31MethodSourceFan  ^(self class sourceCodeAt: #baseline31Fan:) asStringconfiguration: aString with: aBlockOrString constructor: aVersionConstructor  aVersionConstructor configurationForVersion: aString with: aBlockOrStringclassNameArg  ^classNameArgresolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  ^self resolveToPackagesIn: aVersionSpec visited: visitedsetUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:assoc |  | reference superclassName |        reference := assoc key.        superclassName := assoc value.        monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) with: (MCClassDefinition name: (reference packageName copyWithout: $-) asSymbol superclassName: superclassName category: reference packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]version107ProjectToolBox: spec  < version: '1.0.7-baseline'>  spec for: #common do: [ spec           package: 'Example-Core' with: [ spec                 supplyingAnswers: #(#('preload' 'preload answer') #('postload' 'postload answer'));                 preLoadDoIt: #preloadForSupplyingAnswers;                 postLoadDoIt: #postloadForSupplyingAnswers ];           package: 'Example-Tests' with: [ spec supplyingAnswers: #(#('string' 'preload answer') #('symbol' #'abc def') #('integer' 1) #('boolean' true) #('another boolean' false) #('character' $a)) ] ]requiresForPackage: anObject  self root requires: anObjecthasNoLoadConflicts: aMetacelloProjectSpec  ^(super hasNoLoadConflicts: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]version09Issue32: spec  < version: '0.9.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>baselineOfIssue32:'.        spec author: 'dkh'.        spec timestamp: '6/18/2012 14:34' ].  spec for: #custom do: [ spec baseline: 'Issue32' with: [ spec repository: 'dictionary://Metacello_External_Test_Repository' ] ]setUpConfigurationOfProjectIssue171dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue171-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion20Issue171:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue171:) asString) .   (MCMethodDefinition className: className asString selector: 'version20Issue171:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue171:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfosetUpRepositoryContents  baseline200: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec           preLoadDoIt: #preloadForCore;           postLoadDoIt: #postloadForCore:package:.        spec           project: 'Example Project' with: [ spec                 className: 'ConfigurationOfExampleProject';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 loads: #('core');                 yourself ];           yourself.        spec group: 'Core' with: #('Example Project') ]repository: aString username: username password: password constructor: aVersionConstructor  aVersionConstructor repositoryForProject: aString username: username password: passwordversion127ProjectToolBox: spec  < version: '1.2.7-baseline'>  spec for: #common do: [ spec project: 'Example Project' with: [ spec                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadDoIt;                 postLoadDoIt: #postloadDoIt;                 repository: 'http://www.example.com/ob' ] ]version120ProjectToolBox: spec  < version: '1.2.0-baseline' imports: #('1.1.4-baseline')>  spec for: #common do: [ spec project: 'Copied Example' copyFrom: 'Example Project' with: [ spec preLoadDoIt: #alternatePreloadForCore ] ]addMethodSection: attributePath versionSpec: versionSpec  | attributeList methodSection index sections found |  attributeList := attributePath last.  methodSection := MetacelloVersionMethodSection new     attributes: attributeList;     versionSpec: versionSpec;     yourself.  attributePath size > 1 ifTrue: [ index := 1.        sections := self methodSections.        found := true.        [ found ] whileTrue: [ found := false.              sections do: [:ms |  ms attributes = (attributePath at: index) ifTrue: [ index == (attributePath size - 1) ifTrue: [ ms methodSections add: methodSection.                                ^self ].                          sections := ms methodSections.                          index := index + 1.                          found := true ] ] ].        self error: 'Method section for attribute: ' , (attributePath at: index) printString , ' not found.' ] ifFalse: [ self methodSections add: methodSection ]setUpConfigurationOfProjectFoe  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectFoe-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline40ProjectFoe:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectFoe)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependecies groups: groups versionSpecsDo: aBlock  self addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies includes: #() files: #() repositories: repositories preLoadDoIts: #() postLoadDoIts: #() supplyingAnswers: #() groups: groups versionSpecsDo: aBlockproject  ^self projectWith: #()flushForScriptGet  self class flushProjectEntry: self projectPath version: self projectVersion.  self localRepository flushForScriptGetanswers: aListOfPairs  self shouldNotImplementlesson01  ^Lesson title: 'Lesson 1' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version01:."Version 0.1 represents the simplest version specification possible. In the method #version01, version 0.1 is defined with a single package ''Example-Core-anon.8'' that is loaded from the repository ''http://www.example.com/Example''.Looking at this method you will notice a couple of things. Immediately after the method selector you see the pragma definition:  <version: ''0.1''>The pragma indicates that the version created in this method should be associated with version ''0.1'' of the Tutorial project.Looking a little closer you see that the argument to the method, <spec>, is the only variable inthe method and it is used as the receiver to four different messages:  - #for:do:  - #package:with:  - #file:   - #repository:With the evaluation of each block expression, a new object is pushed on a stack and the messageswithin the block are sent to the object on the top of the stack.So the method should be read as:  Create version ''0.1''. The #common code for version ''0.1'' (#for:do:) consists of a package named   ''Example-Core'' (#package:with:) whose file attribute is ''Example-Core-anon.8'' (#file:) and whose   repository attribute is ''http://www.example.com/Example'' (#repository:).We can see the spec created for version 0.1 by printing the following expression:"  (MetacelloTutorialConfig project version: ''0.1'') spec."Note that in creating version ''0.1'' the #common attribute is extracted out.In addition to #common, there are pre-defined attributes for each of the platforms upon whichMetacello runs (#pharo, #squeak, #gemstone and #squeakCommon). #squeakCommon is used for both #pharo and #squeak."ProfStef next.'updateVersionMethodForVersion: inputVersionStringOrSymbol projectAttributes: projectAttributes updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock  | constructor updatedSpecs fullVersionSpec version coll pragma imports blessing addedSections visitedSpecs sourceVersionString keptSections |  updatedSpecs := Set new.  version := project version: inputVersionStringOrSymbol.  sourceVersionString := version versionString.  blessing := version blessing.  blessing == #release ifTrue: [ MetacelloCannotUpdateReleasedVersionError signal: 'Should not update a version that has been released (resume to continue update).' ].  fullVersionSpec := version spec.  constructor := self constructor.  coll := constructor extractAllVersionPragmas at: sourceVersionString ifAbsent: [ ^updatedSpecs ].  coll size > 1 ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionString printString ].  pragma := coll at: 1.  imports := pragma numArgs = 2 ifTrue: [ pragma argumentAt: 2 ] ifFalse: [ #() ].  methodSpec := MetacelloVersionMethodSpec new     project: project;     selector: (MetacelloPlatform current selectorForPragma: pragma);     category: (project configuration class whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma: pragma));     versionString: sourceVersionString;     imports: imports;     yourself.  constructor extractMethodSectionsFor: sourceVersionString.  addedSections := Dictionary new.  visitedSpecs := Set new.  keptSections := IdentitySet new.  constructor methodSectionsInEvaluationOrder: projectAttributes reverse do: [:methodSection |  | versionSpec |        versionSpec := methodSection versionSpec.        (blessing ~~ #baseline and: [ methodSection includesAttributeFrom: projectAttributes ]) ifTrue: [ self updateVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs ].        (aBlock value: methodSection attributeOrPath value: versionSpec) ifTrue: [ keptSections add: methodSection topParent ] ].  constructor methodSections do: [:methodSection |  (methodSection includesAttributeFrom: projectAttributes) ifTrue: [ (keptSections includes: methodSection) ifTrue: [ self methodSpec methodSections add: methodSection ] ] ifFalse: [ self methodSpec methodSections add: methodSection ] ].  ^updatedSpecsnonOverridable  ^super nonOverridable , #(repositories)availableSubCommands  ^#('install')file: aString constructor: aVersionConstructor  aVersionConstructor fileForPackage: aStringextractTypeFromDescription: description  (description beginsWith: 'ftp://') ifTrue: [ ^'ftp' ].  ^super extractTypeFromDescription: descriptionpostCopy  super postCopy.  repositories := repositories copy.  projectPackage := nilsetUpConfigurationOfExternalXXX  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternalXXX-dkh.1'.  className := #ConfigurationOfExternalXXX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfXXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfXXX:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfocanUpgradeTo: anMCGitBasedRepository  (anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^false ].  ^self projectPath = anMCGitBasedRepository projectPath and: [ self repoPath = anMCGitBasedRepository repoPath ]setUpBaselineGithubReferenceV  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefV-dkh.1'.  className := #BaselineOfGithubRefV.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationGithubReferenceXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceXX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfospec: packageOrVersionSpec loader: aLoader  spec := packageOrVersionSpec.  loader := aLoaderconfigMethodBodyOn: aStream indent: indent fromShortCut: fromShortCut  | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |  hasClassName := self hasClassName.  hasVersionString := self configHasVersionString.  hasOperator := operator ~~ nil.  hasProjectPackage := self hasRepository or: [ hasClassName & (self getFile ~~ nil) ].  hasLoads := self loads ~~ nil.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasClassName ifTrue: [ hasVersionString | hasOperator | hasProjectPackage | hasLoads ifTrue: [ aStream                 cr;                 tab: indent + 1 ] ifFalse: [ aStream space ].        aStream nextPutAll: 'className: ' , self className printString.        hasVersionString | hasPreLoadDoIt | hasPostLoadDoIt | hasOperator | hasLoads | hasProjectPackage ifTrue: [ aStream nextPut: $; ] ].  hasVersionString ifTrue: [ | vs |        hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream                 cr;                 tab: indent + 1 ] ifFalse: [ aStream space ].        vs := self versionString.        aStream nextPutAll: 'versionString: '.        vs isSymbol ifTrue: [ aStream nextPut: $# ].        aStream nextPutAll: vs asString printString.        hasPreLoadDoIt | hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads ifTrue: [ aStream nextPut: $; ] ].  hasPreLoadDoIt ifTrue: [ hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt ifTrue: [ aStream                 cr;                 tab: indent + 1 ] ifFalse: [ aStream space ].        aStream nextPutAll: 'preLoadDoIt: '.        self preLoadDoIt value isSymbol ifTrue: [ aStream                 nextPut: $#;                 nextPutAll: self preLoadDoIt value asString printString ] ifFalse: [ aStream nextPutAll: self preLoadDoIt value asString ].        hasPostLoadDoIt | hasOperator | hasProjectPackage | hasLoads ifTrue: [ aStream nextPut: $; ] ].  hasPostLoadDoIt ifTrue: [ hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPostLoadDoIt ifTrue: [ aStream                 cr;                 tab: indent + 1 ] ifFalse: [ aStream space ].        aStream nextPutAll: 'postLoadDoIt: '.        self postLoadDoIt value isSymbol ifTrue: [ aStream                 nextPut: $#;                 nextPutAll: self postLoadDoIt value asString printString ] ifFalse: [ aStream nextPutAll: self postLoadDoIt value asString ].        hasOperator | hasProjectPackage | hasLoads ifTrue: [ aStream nextPut: $; ] ].  hasOperator ifTrue: [ hasClassName | hasVersionString | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream                 cr;                 tab: indent + 1 ] ifFalse: [ aStream space ].        aStream nextPutAll: 'operator: #' , self operator asString printString.        hasProjectPackage | hasLoads ifTrue: [ aStream nextPut: $; ] ].  hasLoads ifTrue: [ hasClassName | hasVersionString | hasOperator | hasProjectPackage | hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream                 cr;                 tab: indent + 1 ] ifFalse: [ aStream space ].        aStream nextPutAll: 'loads: #('.        self loads do: [:str |  aStream nextPutAll: str printString , ' ' ].        aStream nextPut: $).        hasProjectPackage ifTrue: [ aStream nextPut: $; ] ].  hasProjectPackage ifTrue: [ | hasName hasRepo |        hasRepo := self hasRepository.        hasName := self file ~= self className.        hasName ifTrue: [ hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream                       cr;                       tab: indent + 1 ] ifFalse: [ aStream space ].              aStream nextPutAll: 'file: ' , self file printString.              hasRepo ifTrue: [ aStream nextPut: $; ] ].        hasRepo ifTrue: [ | repos |              repos := self repositories map values.              repos size = 1 ifTrue: [ fromShortCut ifTrue: [ hasClassName | hasVersionString | hasOperator | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt | hasName ifTrue: [ aStream                                   cr;                                   tab: indent + 1 ] ifFalse: [ aStream space ] ] ifFalse: [ aStream                             cr;                             tab: indent + 1 ].                    repos first configMethodCascadeOn: aStream lastCascade: true ] ifFalse: [ aStream cr.                    self repositories configMethodCascadeOn: aStream indent: indent ] ] ]setUpRepositoryContents: packageList sourceRepo: sourceRepo targetRepo: targetRepo  packageList do: [:package |  | versionInfo |        versionInfo := sourceRepo versionInfoFromVersionNamed: package.        targetRepo storeVersion: (sourceRepo versionWithInfo: versionInfo ifAbsent: [ self assert: false ]) ]ignoreImage  ^ignoreImagepreLoadDoIt: aSymbol constructor: aVersionConstructor  aVersionConstructor preLoadDoItForProject: aSymbolcanDowngradeTo: aProjectSpec  ^falsenonOverridable  ^#(includes requires answers)printOn: aStream  | beforeFirst |  beforeFirst := true.  self do: [:each |  beforeFirst ifTrue: [ beforeFirst := false ] ifFalse: [ each isString ifTrue: [ aStream nextPut: $- ] ifFalse: [ aStream nextPut: $. ] ].        aStream nextPutAll: each asString ]baseline50MethodSourceFan  ^(self class sourceCodeAt: #baseline50Fan:) asStringpragmaKeywords  ^#(#version:attribute: #blessing:attribute: #description:attribute: #required:attribute: #groups:attribute: #doits:attribute:)slideIn: orderedSpecs spec: targetSpec baseIndex: baseIndex seen: seen firstTime: firstTime for: aVersionSpec  | targetIndex requiredSpecNames targetRequires targetRequiresIndexes minIndex baseSpec required |  (seen includes: targetSpec) ifTrue: [ ^false ].  targetIndex := orderedSpecs indexOf: targetSpec.  baseIndex >= targetIndex ifTrue: [ ^false ].  required := false.  baseSpec := orderedSpecs at: baseIndex.  baseIndex + 1 to: targetIndex - 1 do: [:index |  | spec |        spec := orderedSpecs at: index.        ((spec requiredSpecNamesForPackageOrdering: aVersionSpec) includes: baseSpec name) ifTrue: [ required := true ] ].  firstTime ifFalse: [ required ifFalse: [ ^false ] ].  requiredSpecNames := targetSpec requiredSpecNamesForPackageOrdering: aVersionSpec.  targetRequires := orderedSpecs select: [:spec |  requiredSpecNames includes: spec name ].  targetRequiresIndexes := targetRequires collect: [:spec |  orderedSpecs indexOf: spec ].  targetRequiresIndexes add: baseIndex.  minIndex := targetRequiresIndexes detectMax: [:each |  each ].  minIndex + 1 < targetIndex ifTrue: [ orderedSpecs remove: targetSpec.        orderedSpecs add: targetSpec afterIndex: minIndex.        seen add: targetSpec ] ifFalse: [ ^self slideIn: orderedSpecs spec: (orderedSpecs at: minIndex) baseIndex: 1 seen: seen firstTime: firstTime for: aVersionSpec ].  ^truepostCopy  normalVersion := normalVersion copy.  preReleaseVersion := preReleaseVersion copy.  buildVersion := buildVersion copysetUpExternalCoreX  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'External-CoreX-dkh.1'.  className := #ExternalCoreX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #Object category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'externalAuthorName' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalAuthorName) asString) .   (MCMethodDefinition className: 'Object' classIsMeta: true selector: 'isExternal' category: '*external-corex' timeStamp: '' source: (self class sourceCodeAt: #isExternal) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfosymbolicVersionResolverBlock  ^[:symbolicVrsn :pragma |  | result |  result := nil.  (pragma argumentAt: 1) = symbolicVrsn ifTrue: [ self symbolicVersion: symbolicVrsn.        self evaluatePragma: pragma.        self project attributes do: [:attribute |  | versionString |              versionString := self attributeMap at: attribute ifAbsent: [  ].              versionString ~~ nil ifTrue: [ result := versionString ] ] ].  result ]preLoadDoIt: aSymbol  self root preLoadDoIt: aSymbol constructor: selfhandleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock  ^onDownGradeBlock cull: self cull: self existingProjectRegistration cull: self newProjectRegistrationgetRepositories  ^repositoriesbaselineVersion10Issue115: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec package: 'GeauxFoo' ]projectSpecCreationBlock  ^[:projectName |  {(MetacelloMCBaselineProject new baselineOfProjectSpec name: projectName)} ]version103ProjectToolBox: spec  < version: '1.0.3-baseline' imports: #('1.0.2-baseline')>  spec for: #common do: [ spec preLoadDoIt: #alternatePreloadForCore ]stableVersion  ^nilpackageSpec: anObject  packageSpec := anObjectisCriticalWarning  ^truedefaultAction  ^trueversionWithInfo: aVersionInfo ifAbsent: errorBlock  ^self localRepository versionWithInfo: aVersionInfo ifAbsent: errorBlockcanUpgradeTo: aMetacelloRepositorySpec  self description = aMetacelloRepositorySpec description ifTrue: [ ^true ].  (#('github' 'gitorious' 'bitbucket') includes: self type) ifTrue: [ ^self createRepository canUpgradeTo: aMetacelloRepositorySpec createRepository ].  ^falselockConfiguration11: spec  < version: '1.1.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>lockConfiguration11: '.        spec configuration: 'ExternalX' with: [ spec                 version: '0.9.1';                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]baselineGithubReferenceXX: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>baselineGithubReferenceXX:'.        spec baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]downloadZipArchive: url to: outputFileName  self subclassResponsibilitypackagesSpec  ^self project packagesSpecoperator: anObject  self shouldBeMutable.  operator := anObjectapplyToList: aListSpec  aListSpec copy: selfmethodSource  | strm |  strm := WriteStream on: String new.  self methodSelectorAndPragma: self selector imports: self imports on: strm.  self methodSection: self pre: [:methodSection :indent |  strm           cr;           tab: indent;           nextPutAll: 'spec for: ' , methodSection attributePrintString , ' do: [';           cr.        methodSection versionSpec configMethodOn: strm last: methodSection methodSections isEmpty indent: indent + 1 ] last: false post: [:methodSection :indent :last |  strm nextPutAll: ' ].'.        (last or: [ indent = 1 or: [ methodSection methodSections isEmpty and: [ indent = 1 ] ] ]) ifTrue: [ strm cr ] ] indent: 0.  ^strm contentsplatformAttributes  ^self projectPlatformAttributespostloadDoIt  Smalltalk at: #Metacello_Configuration_Test_POST_DoIt_Result put: truespotterForIncludesFor: aStep  < spotterOrder: 1>  aStep listProcessor     title: 'Includes';     allCandidates: [ self includes ];     itemName: [:item |  item name ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: trueensureConfigurationLoaded: vrsn ensured: ensured  (vrsn blessing == #development or: [ self versionString isSymbol ]) ifTrue: [ ensured ~~ #latest ifTrue: [ ^MetacelloScriptEnsureProjectLoadedForDevelopment signal ] ].  ^falserelativeCurrentVersion  ^self projectReference relativeCurrentVersionsetUpConfigurationOfProjectIssue119dkh7: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.7'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion40Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version50Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version50Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoaddSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList repositories: repositories dependencies: dependecies groups: groups versionSpecsDo: aBlock  self addSection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: projectList packages: packageList dependencies: dependecies includes: #() files: #() repositories: repositories preLoadDoIts: #() postLoadDoIts: #() supplyingAnswers: #() groups: groups versionSpecsDo: aBlockbaseline62Foo: spec  < version: '6.2'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        spec           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo');           yourself ]version12: spec  < version: '1.2' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec description: 'Add in doits for Example-Core'.        spec author: 'dkh'.        spec timestamp: '10/12/2009 09:26'.        spec           package: 'Example-Core' with: [ spec                 file: 'Example-Core-anon.16';                 preLoadDoIt: #preloadForCore;                 postLoadDoIt: #postloadForCore:package: ];           package: 'Example-Tests' with: 'Example-Tests-anon.5';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ]silently  silently == nil ifTrue: [ silently := false ].  ^silentlyversion126ProjectToolBox: spec  < version: '1.2.6-baseline' imports: #('1.2.5-baseline')>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 preLoadDoIt: nil;                 postLoadDoIt: nil ] ]projectSpecsFromRepositoryArg  | spec repo projectSpecs |  repositoryArg ifNil: [ ^#() ].  spec := (projectSpecGenerator projectSpecCreationBlock value: 'xxx') first.  repo := spec project createRepository: (spec project repositorySpec description: repositoryArg).  projectSpecs := OrderedCollection new.  ((Gofer new disablePackageCache     repository: repo;     allResolved) collect: [:resolvedReference |  resolvedReference packageName ]) asSet do: [:packageName |  (projectSpecGenerator projectSpecCreationBlock value: (MetacelloScriptEngine baseNameOf: packageName)) do: [:projectSpec |  projectSpec className = packageName ifTrue: [ projectSpecs add: (self applyArgsToProjectSpec: projectSpec copy) ] ] ].  ^projectSpecsversionString  versionString == nil ifTrue: [ ^'' ].  ^versionStringbaseline20Fan: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #baseline.        spec           package: 'GoferFan';           yourself ]reasonCode  reasonCode == nil ifTrue: [ reasonCode := #none ].  ^reasonCodeincludes  includes == nil ifTrue: [ includes := #() ].  ^includeslesson07  repositoryFor: pkgSpec from: repositorySpecs  ^([ self resolveSpec: pkgSpec from: repositorySpecs ] on: Error do: [:ignored |  ^nil ]) repositorystableVersion  ^self version: #stablesetBlessingInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setBlessing: selfconfigSpawnMethodOn: aStream indent: indent  self configMethodValueOn: aStream for: self getBlessing selector: 'blessing:' last: false indent: indent.  self configMethodValueOn: aStream for: self getAuthor selector: 'author:' last: false indent: indent.  self configMethodValueOn: aStream for: self getTimestamp selector: 'timestamp:' last: false indent: indentimportedVersions  importedVersions == nil ifTrue: [ importedVersions := #() ].  ^importedVersionshasLoadConflicts: aProjectRegistration  aProjectRegistration validate.  self isValid ifFalse: [ ^false ].  ^self projectSpec hasConflictWithProjectSpec: aProjectRegistration projectSpecerrorReasonCodes  ^super errorReasonCodes , #(#loadError #testFailures)loadedPackageNames: aLoader  | vrsn pkgs |  (vrsn := self versionOrNil) == nil ifTrue: [ ^#() ].  pkgs := OrderedCollection new.  (self loadListForVersion: vrsn) do: [:nm |  (vrsn packagesForSpecNamed: nm) do: [:pkg |  (pkg isPackageLoaded: aLoader) ifTrue: [ pkgs add: pkg name ] ] ].  ^pkgsloadVersion: aVersionOrNil  self subclassResponsibilitybaseline40MethodSourceProjectLoop  ^(self class sourceCodeAt: #baseline40ProjectLoop:) asStringfile  ^self classNameactivate  self activateHelpWithoutArguments ifTrue: [ ^self ].  self subCommand = 'install' ifTrue: [ self           checkInputForInstallSubcommand;           install;           postInstall ]downloadJSON: url username: username pass: pass  | client json |  client := ZnClient new     url: url;     yourself.  username ifNotNil: [ client username: username password: pass ].  client get.  json := client contents.  ^STON fromString: jsontestHttpRepository  | project pkg repoSpec repo |  project := self project.  pkg := (project version: '1.4-baseline') packageNamed: 'Example-Core'.  repoSpec := pkg repositorySpecs first.  self assert: repoSpec type equals: 'http'.  repo := repoSpec createRepository.  self assert: repo class identicalTo: MCHttpRepository.  self assert: repo description equals: 'http://example.com/examples'nonOverridable  ^super nonOverridable , #(projectReference)addTo: aLoaderDirective  spec postLoadDoIt value ~~ nil ifTrue: [ aLoaderDirective add: self ]setUpConfigurationOfProjectIssue283dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfProjectIssue283-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'stableVersion283A:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #stableVersion283A:) asString) .   (MCMethodDefinition className: className asString selector: 'bleedingEdge206A:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #bleedingEdge206A:) asString) .   (MCMethodDefinition className: className asString selector: 'version20Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue283:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoprojectSpec  ^projectSpecprojectSpecListBlock  ^[ MetacelloProjectRegistration baselineProjectSpecs ]versionString  ^versionString ifNil: [ self version ifNotNil: [:v |  v versionString ] ]packagesNeedSavingUsing: repositorySpecs into: aCollection  | wc repoSpecs repo |  (wc := self spec workingCopy) == nil ifTrue: [ ^self ].  (wc ancestry ancestors notEmpty and: [ wc modified not ]) ifTrue: [ ^self ].  repoSpecs := self spec repositorySpecs notEmpty ifTrue: [ self spec repositorySpecs ] ifFalse: [ repositorySpecs ].  repo := (self spec getFile == nil or: [ wc ancestry ancestors isEmpty ]) ifTrue: [ (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ] ifFalse: [ ([ self resolveSpec: self spec from: repoSpecs ] on: Error do: [:ignored |  ^self ]) repository ].  aCollection add: self spec -> repoprojectSpecLookupBlock  ^[:projectName |  {(MetacelloProjectRegistration projectSpecForClassNamed: (MetacelloScriptEngine configurationNameFrom: projectName) ifAbsent: [  ])} ]projectClass  ^MetacelloMCProjecttestIssue392  #('v0.0.1' '00.0.1' '16r00.0.1' '101r.0.1' 'rr101r.0.1') do: [:versionString |  MetacelloOldSemanticVersionNumber fromString: versionString.        self should: [ self versionClass fromString: versionString ] raise: Error ]retryingResolvePackageSpecReferences: packageSpec gofer: gofer  | retryCount references repositoryError |  retryCount := 0.  references := #().  [ references isEmpty and: [ retryCount < 3 ] ] whileTrue: [ retryCount > 0 ifTrue: [ MetacelloNotification signal: '...RETRY->' , packageSpec file ].        references := [ self resolvePackageSpecReferences: packageSpec gofer: gofer ] on: Error , GoferRepositoryError do: [:ex |  self class retryPackageResolution ifFalse: [ ex pass ].              retryCount >= 2 ifTrue: [ (ex isKindOf: GoferRepositoryError) ifTrue: [ MetacelloNotification signal: 'gofer repository error: ' , ex description printString , '...ignoring'.                          repositoryError := ex.                          ex resume: #() ] ifFalse: [ ex pass ] ].              ex return: #() ].        retryCount := retryCount + 1 ].  references isEmpty ifTrue: [ MetacelloNotification signal: '...FAILED->' , packageSpec file.        (MetacelloPackageSpecResolutionError new           packageSpec: packageSpec;           repositories: gofer repositories;           repositoryError: repositoryError;           yourself) signal ].  ^referencesremoveGroup: aString constructor: aVersionConstructor  aVersionConstructor removeGroupForVersion: aStringsourceName  ^sourceNameswasource: projectName  self repository: 'http://www.hpi.uni-potsdam.de/hirschfeld/squeaksource/' , projectNameversionsDo: aBlock  self loadDirectives do: [:directive |  directive versionDo: aBlock ]packages  | packages |  packages := OrderedCollection new.  self spec projectDo: [:ignored |   ] packageDo: [:pkg |  packages add: pkg ] groupDo: [:ignored |   ].  ^packagesignoreImage: anObject  ignoreImage := anObjectcreateProjectReferenceSpec: projectBaseName  | projectSpec |  projectSpec := (Metacello image     project: projectBaseName;     list) detect: [:each |  true ] ifNone: [ ^self classicCreateProjectReferenceSpec: projectBaseName ].  ^project projectReferenceSpec     name: projectBaseName;     projectReference: projectSpec;     yourselfvalidateSemanticVersionStrings: versionStrings  | versions version |  versions := versionStrings collect: [:each |  each asMetacelloSemanticVersionNumber ].  version := versions at: 1.  2 to: versions size do: [:index |  | nextVersion |        nextVersion := versions at: index.        self assert: version < nextVersion.        version := nextVersion ]configMethodOn: aStream indent: indent  self configMethodOn: aStream last: true indent: indentremoveFromMetacelloPackages: aMetacelloPackagesSpec  aMetacelloPackagesSpec addMember: (aMetacelloPackagesSpec removeMember           name: self name;           spec: self;           yourself)baselineVersion10Issue154: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec           project: 'MetacelloExample' with: [ spec                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 projectPackage: [ spec                       name: 'ConfigurationOfMetacelloExample';                       repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ];           yourself ]sourceName  ^self nameresolveToPackagesIn: aVersionSpec andProjects: andProjectsBool into: packages visited: visited  visited visit: self doing: [:aSpec |  | map |        map := aVersionSpec packages map.        aSpec includes do: [:pkgName |  (aVersionSpec packageNamed: pkgName forMap: map ifAbsent: [  ]) projectDo: [:prj |  andProjectsBool ifTrue: [ packages at: prj name put: prj ] ] packageDo: [:pkg |  packages at: pkg name put: pkg ] groupDo: [:grp |  grp resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool into: packages visited: visited ] ] ]setUpBaselineOfExternalXXX  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfExternalXXX-dkh.1'.  className := #BaselineOfExternalXXX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'externalBaselineXXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalBaselineXXX:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoproject  ^self basicSpec projectusername: aString  username := aStringexternalReference  ^externalReferencepackages  ^packageslist  self setDefaultsAndValidateProjectSpec.  self root: self projectSpeccompareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader  self currentPackageLoaded: [:bool |  ^bool ] comparing: anOperator notLoaded: [:ignored |  ^false ] using: anMCLoaderevaluatePragma: pragma  currentContext := pragma.  [ self configuration perform: (MetacelloPlatform current selectorForPragma: pragma) with: self ] ensure: [ currentContext := nil ]commitBaselineOfMethod  | skipValidation |  skipValidation := false.  self methodSpec ifNil: [ ^self ].  self methodSpec compileMethod.  project := project configuration class project.  [ project version: self methodSpec versionString ] on: MetacelloSymbolicVersionDoesNotExistError do: [:ex |  skipValidation := true ].  skipValidation ifFalse: [ self validateVersion: self methodSpec versionString ].  methodSpec := niltestGroupMergeSpec  | groupA groupB group |  groupA := self groupSpec     name: 'Platform';     includes: 'Core';     yourself.  groupB := self groupSpec     name: 'Platform';     includes: 'Tests';     yourself.  group := groupA mergeSpec: groupB.  self assert: (group includes includes: 'Core').  self assert: (group includes includes: 'Tests')description  | desc |  desc := self class description , self projectPath , ':' , self projectVersionEscaped.  self repoPath isEmpty ifTrue: [ ^desc ].  ^desc , '/' , self repoPathinvalidConfiguration30: spec  < version: '3.0.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>invalidConfiguration30: ... missing repository:'.        spec project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 version: '0.9.0' ] ]testVersion  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--version=stable').  self assert: cli version equals: 'stable'operationString  ^'downgrade to'roots  roots ifNil: [ roots := OrderedCollection new ].  ^rootsprojectLabel  ^'configuration'~> aMetacelloVersionNumber  aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].  ^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]versionString: anObject  versionString := anObjecthasClassName  ^className ~~ nil and: [ className ~= self constructClassName ]configurationGithubReferenceXXX: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configurationGithubReferenceXXX:'.        spec configuration: 'External' with: [ spec                 version: '0.9.0';                 repository: 'http://ss3.gemtalksystems.com/ss/external' ] ]asProjectSpecForVersion: vrsn  ^selfimports: anObject  imports := anObjectprojectLabel  ^self basicSpec projectLabeladd: aStringOrSpec  aStringOrSpec addToMetacelloRepositories: selfaLoadedProjectIsExact  ^aLoadedProjectIsExactss3: projectName  self squeaksource3: projectNamerepositoryFor: pkgSpec with: gofer  ^([ self resolveSpec: pkgSpec with: gofer ] on: Error do: [:ignored |  ^nil ]) repositoryvalidateBaselineVersionSpec: versionSpec  self subclassResponsibilityisPartiallyCurrent  ^self isPartiallyCurrentAgainst: (self expandToLoadableSpecNames: #('ALL'))label  ^self versionSpec labelauthor: aBlockOrString constructor: aVersionConstructor  aVersionConstructor authorForVersion: aBlockOrStringrepositories: anObject  repositories := anObjectrepository  | specs |  self deprecated: 'Use repositories or repositorySpecs'.  (specs := self repositorySpecs) isEmpty ifTrue: [ ^nil ].  ^specs firstsetProject: aString withString: versionString  | spec projectSpec |  projectSpec := self project projectSpec     name: aString;     versionString: versionString;     yourself.  spec := self project projectReferenceSpec     name: aString;     projectReference: projectSpec;     yourself.  self root packages merge: specon: aConfig project: aProject  | cacheKey cachedProject |  cacheKey := aConfig class.  cachedProject := MetacelloPlatform current stackCacheFor: #versionConstructor at: cacheKey doing: [:cache |  self calculate: aConfig project: aProject.        cache at: cacheKey put: self project.        ^self ].  aProject map: cachedProject map.  aProject errorMap: cachedProject errorMap.  aProject symbolicVersionMap: cachedProject symbolicVersionMap.  aProject configuration: aConfig.  self setProject: aProjectvalidationReport  validationReport == nil ifTrue: [ validationReport := OrderedCollection new ].  ^validationReportsetPreLoadDoItInMetacelloSpec: aMetacelloSpec  aMetacelloSpec setPreLoadDoIt: selfname  ^self versionStringsetUpConfigurationOfFan  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfFan-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline20Fan:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFan) .   (MCMethodDefinition className: className asString selector: 'baseline30Fan:' category: 'cat' timeStamp: '' source: self baseline30MethodSourceFan) .   (MCMethodDefinition className: className asString selector: 'baseline35Fan:' category: 'cat' timeStamp: '' source: self baseline35MethodSourceFan) .   (MCMethodDefinition className: className asString selector: 'baseline40Fan:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceFan) .   (MCMethodDefinition className: className asString selector: 'baseline50Fan:' category: 'cat' timeStamp: '' source: self baseline50MethodSourceFan)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())goferPackage  goferPackage == nil ifTrue: [ goferPackage := MetacelloGoferPackage name: self name packageFilename: self file ].  ^goferPackagetestVersion11  | v1 v2 |  v1 := self versionClass fromString: '1.0.1b'.  v2 := self versionClass fromString: '1.0.1a'.  self assert: v1 >= v2.  self assert: v2 <= v1printOn: aStream indent: indent  indent timesRepeat: [ aStream tab ].  aStream     nextPutAll: self title;     nextPutAll: ' : ';     nextPutAll: self labelpragmaKeywords  ^super pragmaKeywords , #(#projectPackage:attribute: #packages:attribute: #repositories:attribute:)configMethodBodyOn: aStream indent: indent  ^self configMethodBodyOn: aStream indent: indent fromShortCut: falsebaseline40Feaux: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GeauxFoo' with: 'GeauxFoo-lr.1';           package: 'GeauxBar' with: 'GeauxBar.branch-lr.2';           yourself ]= aMetacelloVersion  aMetacelloVersion species = self species ifFalse: [ ^false ].  ^self versionNumber = aMetacelloVersion versionNumbergroupForVersion: aString with: aStringOrCollection  | spec |  spec := self project groupSpec     name: aString;     includes: aStringOrCollection;     yourself.  self root packages merge: spectestVersion25  self assert: (MetacelloVersionNumber fromString: '1.0-beta.24.0.1') < (MetacelloVersionNumber fromString: '1.0-beta.28')setUpConfigurationOfProjectIssue115dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue115-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion10Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue115:) asString) .   (MCMethodDefinition className: className asString selector: 'version10Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue115:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoanswers: aListOfPairs  self shouldNotImplementsetUpConfigurationOfExternalXdkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternalX-dkh.1'.  className := #ConfigurationOfExternalX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'stableVersionOfX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #stableVersionOfX:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfX090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfX090:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfosetUpConfigurationOfProjectIssue119dkh6: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.6'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion10Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion20Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion30Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion30Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineVersion40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion40Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version10Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version20Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version30Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version40Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version41Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version41Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version42Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version42Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version43Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version43Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version44Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version44Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfogtInspectorActionLoad  < gtInspectorAction>  ^GLMGenericAction new     action: [ self load ];     iconName: #smallLoadProject;     title: 'Load'mergeSpec: anotherSpec  | newSpec map anotherProjectReference |  newSpec := super mergeSpec: anotherSpec.  map := anotherSpec mergeMap.  (anotherProjectReference := map at: #projectReference) ~~ nil ifTrue: [ newSpec projectReference: (newSpec projectReference == nil ifTrue: [ anotherProjectReference ] ifFalse: [ newSpec projectReference mergeSpec: anotherProjectReference ]) ].  ^newSpecloadUsing: aLoaderDirective gofer: aGofer  self subclassResponsibilityhandleResolutionFor: aScriptEngine  ^aScriptEngine handleConflict: selfabort: aBoolean  abort := aBooleandetect: aBlock ifNone: exceptionBlock  self do: [:each |  (aBlock value: each) ifTrue: [ ^each ] ].  ^exceptionBlock valueprojectSpecGenerator  baselineArg ifNotNil: [ configurationArg ifNotNil: [ self error: ' baseline: and configuration: are both be specified' ].        projectArg ifNotNil: [ self error: ' baseline: and project are both be specified' ].        ^MetacelloBaselineSpecGenerator new           target: baselineArg;           yourself ].  configurationArg ifNotNil: [ baselineArg ifNotNil: [ self error: ' baseline: and configuration: are both be specified' ].        projectArg ifNotNil: [ self error: ' configuration and project are both be specified' ].        ^MetacelloConfigurationSpecGenerator new           target: configurationArg;           yourself ].  projectArg ifNotNil: [ configurationArg ifNotNil: [ self error: ' project and configuration: are both be specified' ].        baselineArg ifNotNil: [ self error: ' baseline: and project are both be specified' ].        ^MetacelloProjectSpecGenerator new           target: projectArg;           yourself ].  self error: 'project, baseline, or configuration not specified'hasNonVersionStringField  | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |  hasClassName := self hasClassName.  hasVersionString := self versionString ~~ nil.  hasOperator := operator ~~ nil.  hasProjectPackage := (self file ~~ nil and: [ hasClassName and: [ self className ~= self name ] ]) or: [ self hasRepository ].  hasLoads := self loads ~~ nil.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  ^hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoItmetacelloRegistrationHash  | hash |  hash := String stringHash: name initialHash: 0.  hash := String stringHash: self className initialHash: hash.  hash := String stringHash: self versionString initialHash: hash.  hash := String stringHash: self operator asString initialHash: hash.  hash := String stringHash: self preLoadDoIt asString initialHash: hash.  hash := String stringHash: self postLoadDoIt asString initialHash: hash.  ^hash bitXor: loads hashfetchingSpecLoader  ^(MetacelloFetchingMCSpecLoader on: self spec)     shouldDisablePackageCache: self shouldDisablePackageCache;     loaderPolicy: self loaderPolicy copy;     yourselfversion116ProjectToolBox: spec  < version: '1.1.6-baseline' imports: #('1.1.4-baseline')>  spec for: #common do: [ spec project: 'Example Project' with: [ spec preLoadDoIt: #alternatePreloadForCore ] ]testMergeC  | repositories repository |  repositories := self repositoriesSpec.  repositories     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     merge: {(self repositorySpec           description: 'http://example.com/repository';           password: 'secret';           yourself) .         (self repositorySpec           description: 'http://example.com/repository';           username: 'DaleHenrichs';           yourself)}.  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  self assert: repository username equals: 'DaleHenrichs'.  self assert: repository password equals: 'secret'versionDevelopment: spec  < version: 'dev' imports: #('1.0-baseline')>  spec for: #common do: [ spec           description: 'Development Version';           blessing: #development;           author: 'John Doe';           timestamp: '2013-05-09'.        spec           package: 'MyProject-Core' with: 'MyProject-Core-JohnDoe.152';           package: 'MyProject-Tests' with: 'MyProject-Tests-JohnDoe.173';           project: 'FuelMetalevel' with: #development ]repositories: anObject  repositories := anObjectversion10Issue84: spec  < version: '1.0.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>version10Issue84:'.        spec author: 'dkh'.        spec timestamp: '7/24/2012 19:23'.        spec configuration: 'NestedIssue84' with: [ spec                 version: '1.0.0';                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]repository: aString username: username password: password constructor: aVersionConstructor  aVersionConstructor repositoryForRepositories: aString username: username password: passwordunlock  actionArg := #unlock -> #()linearLoadPackageSpec: packageSpec gofer: gofer  MetacelloPlatform current do: [ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |        cachedReference := nil.        packageSpec searchCacheRepositoryForPackage: [ cachedReference := self resolvePackageSpec: packageSpec cachedGofer: self loaderPolicy cacheGofer.              (cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ]) ifTrue: [ cachedReference name = packageSpec file ifTrue: [ ^self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].        references := self retryingResolvePackageSpecReferences: packageSpec gofer: gofer.        nearestReference := references last asMetacelloCachingResolvedReference.        (cachedReference ~~ nil and: [ cachedReference name = nearestReference name ]) ifTrue: [ ^self scheduleFetchFor: packageSpec nearestReference: nearestReference ].        (self ignoreImage not and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ]) ifTrue: [ loadedVersionInfos do: [:info |  info name = nearestReference name ifTrue: [ | spc |                          spc := packageSpec copy.                          spc file: info name.                          (MetacelloIgnorePackageLoaded signal: spc) ifFalse: [ ^self ] ] ] ].        externalReference := (references select: [:ref |  ref name = nearestReference name ]) first asMetacelloCachingResolvedReference.        self repositoryMap at: externalReference name put: externalReference repository.        (self resolveDependencies: externalReference nearest: nearestReference into: (OrderedCollection with: nearestReference)) do: [:reference |  | pSpec l |              mcVersion := reference version.              (l := (GoferVersionReference name: reference name) resolveAllWith: self loaderPolicy cacheGofer) isEmpty ifTrue: [ self cacheRepository storeVersion: mcVersion.                    reference == nearestReference ifTrue: [ pSpec := packageSpec ] ifFalse: [ pSpec := packageSpec project packageSpec.                          pSpec name: mcVersion package name ].                    self loadData addVersion: mcVersion versionInfo: mcVersion info resolvedReference: reference packageSpec: pSpec ] ].        self scheduleFetchFor: packageSpec externalReference: externalReference ] displaying: 'Fetching ' , packageSpec fileonWarning: aBlock  self addStatement: #onWarning: args: {aBlock}canUpgradeTo: aMetacelloRepositoriesSpec  | repositorySpecs anotherRepositorySpecs |  repositorySpecs := self map values sort: [:a :b |  a description <= b description ].  anotherRepositorySpecs := aMetacelloRepositoriesSpec map values sort: [:a :b |  a description <= b description ].  repositorySpecs size ~= anotherRepositorySpecs size ifTrue: [ ^false ].  1 to: repositorySpecs size do: [:index |  | repoSpec anotherRepoSpec |        repoSpec := repositorySpecs at: index.        anotherRepoSpec := anotherRepositorySpecs at: index.        (repoSpec canUpgradeTo: anotherRepoSpec) ifTrue: [ ^true ] ].  ^falsebaselineOrConfigurationNameSuffix  self isBaselineName ifTrue: [ ^self baselineOrConfigurationName copyFrom: 'BaselineOf' size + 1 to: self baselineOrConfigurationName size ].  self isConfigurationName ifTrue: [ ^self baselineOrConfigurationName copyFrom: 'ConfigurationOf' size + 1 to: self baselineOrConfigurationName size ]doFetchRequiredFromArray: anArray  | oldPolicy oldBypassProgress displayString |  displayString := self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloNotification signal: 'Fetching ' , displayString , '...'.  oldPolicy := loaderPolicy.  oldBypassProgress := MetacelloPlatform current bypassProgressBars.  self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].  [ | ans |  ans := self fetchRequiredFromArray: anArray.  MetacelloNotification signal: '...finished ' , self versionNumber printString.  ^ans ] ensure: [ MetacelloPlatform current bypassProgressBars: oldBypassProgress.        loaderPolicy := oldPolicy ]baselineNameFrom: baseName  ^self class baselineNameFrom: baseNameloadsForProject: anObject  self root loads: anObjectsetFor: attributeList version: aString  self methodSections add: (MetacelloSymbolicVersionSpec new           attributes: attributeList asMetacelloAttributeList;           versionString: aString;           yourself)label  ^'Error'to: anObject  to := anObjectdevelopment  ^self version: #developmentfetchingSpecLoader  ^selfvisitingWithPackages: packages  mergeMap  | map |  map := super mergeMap.  map at: #description put: description.  map at: #type put: self type.  map at: #username put: username.  map at: #password put: password.  ^maploadAtomicLoadDirective: aLoaderDirective gofer: aGofer  aLoaderDirective loadDirectives do: [:directive |  directive loadUsing: aLoaderDirective gofer: aGofer ].  aLoaderDirective finalizeLoad: aGoferlock  actionArg := #lock -> #()remove: aSpec  aSpec removeFromMetacelloPackages: selfpostLoadDoIt: aSymbol constructor: aVersionConstructor  aVersionConstructor postLoadDoItForPackage: aSymbolconfigMethodOn: aStream indent: indent  self subclassResponsibilitycacheNames: anArray  cacheNames := anArraytestVersion16  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1.0').  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1.0.0').  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1.0.0.0')tearDownRepositories  configMethodOn: aStream indent: indent  aStream     tab: indent;     nextPutAll: 'spec '.  self configMethodCascadeOn: aStream lastCascade: trueprojectClass  ^MetacelloMCProjectensuredMap: anObject  ensuredMap := anObjectbaselineVersion13Issue154: spec  < version: '1.3-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec           project: 'MetacelloExample' with: [ spec                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 projectPackage: [ spec                       file: 'MetacelloExampleTestConfigurationIssue154.gemstone';                       repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ];           yourself ]packageInfo  ^MetacelloTestsPackageSet named: namecopyFrom: start to: stop  | newSize new j |  newSize := stop - start + 1.  new := self species new: newSize.  j := 0.  start to: stop do: [:i |  new at: j + 1 put: (self at: i).        j := j + 1 ].  ^newcriticalWarningReasonCodes  ^#(#packageNameMismatch #projectClassNameFileMismatch #duplicateVersionDefinitions)version119ProjectToolBox: spec  < version: '1.1.9-baseline' imports: #('1.1.4-baseline')>  spec for: #common do: [ spec project: 'Example Project' overrides: [ spec                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #alternatePreloadForCore;                 repository: 'http://www.example.com/ob' ] ]mergeSpec: anotherSpec  | newSpec map anotherRepositories |  newSpec := super mergeSpec: anotherSpec.  map := anotherSpec mergeMap.  (anotherRepositories := map at: #repositories) isEmpty not ifTrue: [ newSpec repositories: (self repositories isEmpty ifTrue: [ anotherRepositories ] ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].  ^newSpecissues: anObject  issues := anObjectstatements: anObject  statements := anObjectforceUpdatedPackageSpecs  | updatedSpecs mcLoader |  updatedSpecs := Dictionary new.  mcLoader := self loader.  self packages map valuesDo: [:pkg |  pkg forceUpdatePackageSpec: updatedSpecs using: mcLoader ].  ^updatedSpecslesson11Author  compareEqualTo: aMetacelloVersionNumber  | mySize |  aMetacelloVersionNumber species = self species ifFalse: [ ^false ].  mySize := self size.  mySize = aMetacelloVersionNumber size ifFalse: [ ^false ].  1 to: mySize do: [:i |  (self at: i) = (aMetacelloVersionNumber at: i) ifFalse: [ ^false ] ].  ^truebaselineVersion11Issue154: spec  < version: '1.1-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec           project: 'MetacelloExample' with: [ spec                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 projectPackage: [ spec                       name: 'MetacelloExampleTestConfigurationIssue154';                       repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ];           yourself ]version10Issue119: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '2.0'.        spec package: 'GoferBar' with: 'GoferBar-jf.1' ]versionString: anObject  self shouldBeMutable.  versionString := anObjectversion  cachedVersion == nil ifTrue: [ cachedVersion := super version ].  ^cachedVersionlocalRepository  self ensureLocalRepository.  self validateLocalRepository.  ^localRepositorybaselineVersion30Issue119: spec  < version: '3.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo ' with: [ spec                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec package: 'GoferBar' ]versionString: anObject  versionString := anObjectversion113ProjectToolBox: spec  < version: '1.1.3' imports: #('1.1.3-baseline')>  spec for: #outer do: [ spec           package: 'Example-Core' with: 'Example-Core-dkh.1';           package: 'Example-Test' with: 'Example-Test-dkh.1'.        spec for: #nested do: [ spec package: 'Example-Core' with: 'Example-Core-dkh.2' ] ].  spec for: #extra do: [ spec package: 'Example-Core' with: 'Example-Core-dkh.3' ]shouldSave  ^self noSave notcopySpec: pkgSpec from: repositorySpecs to: repository  | gofer |  gofer := MetacelloGofer new.  (self repositoriesFrom: repositorySpecs) do: [:repo |  gofer repository: repo ].  ^self copySpec: pkgSpec with: gofer to: repositorysetProject: aProject  project := aProjectgetPreLoadDoIt  ^preLoadDoItcurrentVersionInfo  ^self goferPackage currentVersionInfoversion43Issue119: spec  < version: '4.3' imports: #('4.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo ' with: '2.0'.        spec package: 'GoferBar ' with: 'GoferBar-jf.1' ]baselineProjectSpec: anObject  self shouldBeMutable.  configurationProjectSpec := nil.  self assert: anObject isBaselineOfProjectSpec.  baselineProjectSpec := anObjectextractVersionPragmas  | aDict |  aDict := Dictionary new.  self extractPragmas: #version: into: aDict.  ^aDictnewProjectRegistration: anObject  newProjectRegistration := anObjecttestForDoListAttribute1Atrribute2Active  | project version expected actual |  project := self projectWith: #(#attribute1 #attribute2).  version := project version: '3.0-baseline'.  expected := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec 	project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec 	group: ''Core'' with: #(''Example Project'' );	group: ''Core'' with: #(''Extra Project'' );	group: ''Core'' with: #(''Extra Project'' ).'.  actual := version spec printString.  self assert: expected equals: actuallesson13  createDictionaryRepository: aRepositorySpec  | description headerSize globalName |  description := aRepositorySpec description.  headerSize := 'dictionary://' size.  globalName := (description copyFrom: headerSize + 1 to: description size) asSymbol.  ^Smalltalk at: globalName ifAbsent: [ Smalltalk at: globalName put: (MCDictionaryRepository new                 description: description;                 yourself) ]silently  self addStatement: #silently: args: {true}scheduleFetchFor: packageSpec nearestReference: reference  ^selfsetTimestampWithBlock: aBlock  | spec |  (spec := self root getTimestamp) == nil ifTrue: [ spec := self project valueHolderSpec.        self root setTimestamp: spec ].  self with: spec during: aBlocktestVersion02  | v1 v2 |  v1 := self versionClass fromString: '1.1.1'.  v2 := self versionClass fromString: '1.0.0'.  self assert: v1 equals: v1.  self assert: v2 equals: v2.  self assert: v1 > v2testLessThanComparison  self assert: '1.0.0-rc.1+build.1' asMetacelloSemanticVersionNumber < '1.0.0' asMetacelloSemanticVersionNumber.  self assert: '1.0.0-rc.1+build.1' asMetacelloSemanticVersionNumber < '1.0.0+build.0' asMetacelloSemanticVersionNumber.  self assert: '1.0.0-alpha.1' asMetacelloSemanticVersionNumber < '1.0.0-0.3.7' asMetacelloSemanticVersionNumber.  self assert: '1.0.0-alpha' asMetacelloSemanticVersionNumber < '1.0.0-alpha.1' asMetacelloSemanticVersionNumber.  self assert: '1.0.0+-' asMetacelloSemanticVersionNumber < '1.0.0+a' asMetacelloSemanticVersionNumber.  self assert: '1.0.0-0.3.7' asMetacelloSemanticVersionNumber < '1.0.0-x.7.z.92' asMetacelloSemanticVersionNumbertestShouldSave  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self     deny: cli noSave;     assert: cli shouldSave.  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--no-save').  self     assert: cli noSave;     deny: cli shouldSavespec  (spec == nil and: [ self loader ~~ nil ]) ifTrue: [ ^[ self loader spec versionSpec ] on: MessageNotUnderstood do: [:ex |  ex return: self loader spec ] ].  ^specimport: aString provides: anArray constructor: aVersionConstructor  aVersionConstructor importForVersion: aString provides: anArraygtInspectorProjectsIn: composite  < gtInspectorPresentationOrder: 40>  self version gtInspectorProjectsIn: compositeremoveProject: aString constructor: aVersionConstructor  aVersionConstructor removeProjectForVersion: aStringinitialize  super initialize.  hasNoPackage := hasNoProject := true.  aProjectIsLoaded := aPackageIsLoaded := false.  aLoadedProjectIsExact := aLoadedPackageIsExact := false.  aLoadedProjectIsCurrent := aLoadedPackageIsCurrent := false.  aLoadedProjectIsNotCurrent := aLoadedPackageIsNotCurrent := false.  aProjectNotLoaded := aPackageNotLoaded := false.  vrsnStatus := Set new.  abort := falsedecrementMinorVersion  self decrementNormalVersionAt: 2versionString: anObject  self root versionString: anObject constructor: selfmethodSource  | strm |  strm := WriteStream on: String new.  self symbolicMethodSelectorAndPragma: self selector symbolicVersionSymbol: self versionString on: strm.  (self methodSections asArray sort: [:a :b |  a attributes first <= b attributes first ]) do: [:methodSection |  | vs |        strm           cr;           tab;           nextPutAll: 'spec for: ' , methodSection attributePrintString , ' version: '.        vs := methodSection versionString.        vs isSymbol ifTrue: [ strm nextPut: $# ].        strm           nextPutAll: vs asString printString , '.';           cr ].  ^strm contentsexecuteBlock: selectBlock do: projectSpecBlock  ((projectSpecGenerator projectSpecListBlock value select: selectBlock) select: self projectSpecSelectBlock) do: [:projectSpec |  projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]evaluateSupplyingAnswers: loadBlock  | answers |  (answers := self spec answers) notEmpty ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ] ifFalse: [ loadBlock value ]preReleaseVersion: anObject  preReleaseVersion := anObjectconfigurationProjectSpecIfPresent: presentBlock ifAbsent: absentBlock  ^configurationProjectSpec ifNotNil: [ presentBlock cull: configurationProjectSpec ] ifNil: absentBlockrequires: aCollection  self shouldNotImplementprojectClass  ^testingEnvironment at: self projectName asSymbolsignal  self messageText: self description.  ^super signalloadPackageDirective: aPackageLoadDirective gofer: aGofer  self packageloads add: aPackageLoadDirectivetutorial  ^#(intro create10Baseline open10ForDevelopment updateVersion10 releaseVersion10 open11ForDevelopment create11Baseline releaseVersion11PharoOnly)resolveToLoadableSpecs: nameList  | map |  map := Dictionary new.  self resolveToLoadableSpecs: nameList forLoad: false map: map.  ^map valuesrepositorySpecClass  ^MetacelloRepositorySpecnormalVersion: anObject  normalVersion := anObjectprojectVersionPattern  projectVersionPattern ifNil: [ ^self projectVersion ].  ^projectVersionPatternfetch  ^self execute: #fetch: args: #(#())baseline61Foo: spec  < version: '6.1'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        spec           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferBeau');           yourself ]title  ^'postload'shouldDisablePackageCache  disablePackageCache == nil ifTrue: [ disablePackageCache := false ].  ^disablePackageCachebaseline35Fan: spec  < version: '3.5'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.5';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]version21Issue171: spec  < version: '2.1' imports: #('2.1-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '2.0'.        spec package: 'GeauxFoo' with: 'GeauxFoo-lr.1' ]getPostLoadDoIt  ^postLoadDoIttestRemovePackageC  | packages removed |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages remove: {'Package'}.  removed := false.  packages packageNamed: 'Package' ifAbsent: [ removed := true ].  self assert: removedfor: attributeListOrSymbol version: aString  attributeListOrSymbol setForVersion: aString withInMetacelloConfig: selftestPrinting  | x vrsn |  self sampleVersionStrings do: [:versionString |  self assert: versionString equals: (x := (vrsn := versionString asMetacelloSemanticVersionNumber) printString) ]signal: anArray  self cacheNames: anArray.  ^self signalresolveToLoadableSpecs: nameList  ^self spec resolveToLoadableSpecs: nameListmutable  mutable := trueverify: packageName loadedFrom: repositoryDescription  | externalCoreWorkingCopy |  externalCoreWorkingCopy := MCWorkingCopy allManagers detect: [:wc |  wc packageName = packageName ].  self assert: (externalCoreWorkingCopy repositoryGroup repositories includes: (MetacelloMCProject new repositorySpec description: repositoryDescription) createRepository)scheduleFetchFor: packageSpec cachedReference: reference  ^self scheduleFetchFor: packageSpec reference: reference message: 'Fetched -> (cached) ' , reference name , ' --- ' , reference repository repositoryDescription , ' --- ' , reference repository descriptionversionString: anObject  versionString := anObjectsetDescriptionWithBlock: aBlock  | spec |  (spec := self root getDescription) == nil ifTrue: [ spec := self project valueHolderSpec.        self root setDescription: spec ].  self with: spec during: aBlocksetConfiguration: aString withBlock: aBlock  | spec projectSpec |  projectSpec := self project configurationOfProjectSpec     name: aString;     yourself.  spec := self project projectReferenceSpec     name: aString;     projectReference: projectSpec;     yourself.  self root packages merge: spec.  self with: projectSpec during: aBlockimmutable  mutable := falsepassword: aString  password := aStringloadExplicitLoadDirective: aLoaderDirective gofer: aGofer  asMetacelloAttributePath  ^selfaLoadedProjectIsExact: aBoolean  aLoadedProjectIsExact := aBooleansavePackageUsing: repositorySpecs  | wc repo repoSpecs newVersion |  (wc := self spec workingCopy) == nil ifTrue: [ ^false ].  (wc ancestry ancestors notEmpty and: [ wc modified not ]) ifTrue: [ ^false ].  repoSpecs := self spec repositorySpecs notEmpty ifTrue: [ self spec repositorySpecs ] ifFalse: [ repositorySpecs ].  (self spec getFile == nil or: [ wc ancestry ancestors isEmpty ]) ifTrue: [ repo := (self repositoriesFrom: repoSpecs ignoreOverrides: true) first ] ifFalse: [ [ | newer |        repo := (self resolveSpec: self spec from: repoSpecs) repository.        newer := wc possiblyNewerVersionsIn: repo.        newer isEmpty not ifTrue: [ (MetacelloPlatform current confirm: 'CAUTION! These versions in the repository may be newer:' , String cr , newer printString , String cr , 'Do you really want to save this version?') ifFalse: [ ^false ] ] ] on: Error do: [:ignored |  ^false ] ].  (newVersion := MetacelloPlatform current newVersionForWorkingCopy: wc) == nil ifTrue: [ ^false ].  repo storeVersion: newVersion.  ^truesupplyingAnswers: aCollection  self root supplyingAnswers: aCollection constructor: selfversion10Issue115: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo'.        spec package: 'GeauxFoo' with: 'GeauxFoo-lr.1' ]setUpConfigurationOfProjectIssue283dkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfProjectIssue283-dkh.2'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'stableVersion283B:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #stableVersion283B:) asString) .   (MCMethodDefinition className: className asString selector: 'bleedingEdge206B:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #bleedingEdge206B:) asString) .   (MCMethodDefinition className: className asString selector: 'version20Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue283:) asString) .   (MCMethodDefinition className: className asString selector: 'version21Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version21Issue283:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoerrorMap  ^errorMaploaderClass: aMetacelloSpecLoader  loaderClass := aMetacelloSpecLoadervalidateVersionLoad: version loads: loadList  | list |  list := loadList asOrderedCollection.  list isEmpty ifTrue: [ list add: 'default' ].  (version groups includes: 'Tests') ifTrue: [ list add: 'Tests' ].  version load: listprojectClass  ^MetacelloMCProjecthandleResolutionFor: aScriptEngine  ^aScriptEngine handleProjectSpecLoaded: selfpreloadDoIt  Smalltalk at: #Metacello_Configuration_Test_DoIt_Result put: trueapplyToList: aListSpec  self subclassResponsibilityrelativeCurrentVersion  | vrsn expanded loadList |  (vrsn := self versionOrNil) == nil ifTrue: [ ^nil ].  expanded := [ vrsn expandToLoadableSpecNames: (loadList := self loadListForVersion: vrsn) ] on: Error do: [:ex |  vrsn blessing == #development ifTrue: [ self ensureLoadUsing: self loader.              vrsn := self versionOrNil.              ex return: (vrsn expandToLoadableSpecNames: loadList) ].        ex pass ].  ^self projectClassProject currentVersionAgainst: expandedadd: aSpec  self subclassResponsibilityrepositoryOverrides: aRepositoryDescriptionCollection  self addStatement: #repositoryOverrides: args: {aRepositoryDescriptionCollection}isResumable  ^truehandleEnsureProjectLoadedForDevelopment: exception  ^exception resume: self useCurrentVersionbaseline12MethodSourceC  ^(self class sourceCodeAt: #baseline12C:) asStringpackageloads: anObject  packageloads := anObjectapproximateBase  | base |  base := self copyFrom: 1 to: self size - 1.  base at: base size put: (base at: base size) + 1.  ^baseisAllLoadedToSpecAgainst: resolvedPackageAndProjectNames  (self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isAllLoadedToSpec: [:ignored |  ^true ].  ^falsecategory  ^categorycopy: specNamed to: aSpec  self subclassResponsibilityrunCase  | original |  self doSilently ifFalse: [ ^super runCase ].  original := MetacelloPlatform current bypassGoferLoadUpdateCategories.  [ MetacelloPlatform current bypassGoferLoadUpdateCategories: true.  ^MetacelloPlatform current suspendSystemUpdateEventsDuring: [ super runCase ] ] ensure: [ MetacelloPlatform current bypassGoferLoadUpdateCategories: original ]addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies groups: groups versionSpecsDo: aBlock  self addBaselineOfSection: sectionAttributeOrPath requiredProjects: projectList packages: packageList dependencies: dependecies includes: #() files: #() repositories: #() preLoadDoIts: #() postLoadDoIts: #() supplyingAnswers: #() groups: groups versionSpecsDo: aBlocksetPreLoadDoIt: aSymbol  preLoadDoIt := aSymbolcommitConfiguration: commitComment  symbolicVersionSymbols  ^nilpackageDirectivesDo: aBlock  version04: spec  < version: '0.4'>  spec for: #common do: [ spec repository: 'http://www.example.com/Example'.        spec           package: 'Example-Core' with: 'Example-Core-anon.10';           package: 'Example-Tests' with: 'Example-Tests-anon.3' ]select: aBlock  | newCollection |  newCollection := OrderedCollection new.  self do: [:each |  (aBlock value: each) ifTrue: [ newCollection add: each ] ].  ^newCollectionexecutorSpec  executorSpec ifNil: [ executorSpec := #MetacelloScriptApiExecutor -> 'batch' ].  ^executorSpecgetPostLoadDoIt  ^postLoadDoItasConfigurationProject  ^selfclassNameForProject: aString  self root className: aStringmergeMap  | map |  map := super mergeMap.  map at: #projectReference put: projectReference.  ^mapconfigurationRepository  ^MetacelloConfigurationResource current monticelloRepositoryspec  ^specrepositories: aBlock constructor: aVersionConstructor  aVersionConstructor repositoriesForVersion: aBlockpackage: aString constructor: aVersionConstructor  aVersionConstructor packageForVersion: aStringbaseline20MethodSourceFan  ^(self class sourceCodeAt: #baseline20Fan:) asStringcreateRepository: aRepositorySpec  ^MetacelloPlatform current createRepository: aRepositorySpechasConflictWithConfigurationSpec: projectSpec  ^self hasLoadConflicts: projectSpeclesson11Descripton  ^Lesson title: 'Lesson 11 (Description)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."A description can be defined for a version:"	(MetacelloTutorialConfig project version: ''1.1'') description.	ProfStef next.'updateVersion10  ^Lesson title: 'Update specs for version 1.0' lesson: '"	1. Create configuration	2. Prepare to update the version method for version 1.0:		- with #updateProjects set to true, the current version of the project Shout will set		- with #updatePackages set to true, the current mcz files for the packages ProfStef-Core ProfStef-Tests will be set	3. Define desired versionSpec attributes		- current author and timestamp	4. Append the #logEntry to the version descripttion	5. Compile the #version10: method		- compile and validate"		| logEntry |	logEntry := ''- fixed a bug''."1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		updateVersionMethodForVersion: ''1.0''			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ "3."						versionSpec							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp."4."						versionSpec description value isEmpty							ifTrue: [ versionSpec description: logEntry ]							ifFalse: [ 								| strm |								strm := WriteStream on: String new.								strm									nextPutAll: versionSpec description value;									cr;									nextPutAll: logEntry.								versionSpec description: strm contents ] ].				true ];"5."		commitMethod."After evaluating the above expression, take a look at the updated method #version10. Unless you changed the packages that were loaded in your image, you should just see the #timestamp and #description fields updated."ProfStef next.'readStreamOn: aFileHandle do: aBlock  ^aFileHandle readStreamDo: aBlocksortPackageSpecs: orderedSpecs packageSpec: packageSpec groupLoops: groupLoops for: aVersionSpec  | packageIndex moved movePackage targetPackage targetIndex targetSpecNames groupLoopDetected |  packageIndex := orderedSpecs indexOf: packageSpec.  moved := movePackage := false.  targetSpecNames := packageSpec requiredSpecNamesForPackageOrdering: aVersionSpec.  groupLoopDetected := groupLoops includes: packageSpec.  groupLoopDetected ifFalse: [ targetSpecNames do: [:targetPackageOrProjectName |  targetPackage := orderedSpecs detect: [:each |  each name = targetPackageOrProjectName ] ifNone: [ MetacelloNameNotDefinedError signal: 'project group, or package named: ' , targetPackageOrProjectName printString , ' not found when used in requires: or includes: field of package: ' , packageSpec name printString , ' for version: ' , aVersionSpec versionString , ' of ' , aVersionSpec projectLabel , '.'.                    nil ].              targetIndex := orderedSpecs indexOf: targetPackage.              (groupLoopDetected not and: [ packageIndex = targetIndex ]) ifTrue: [ self notify: 'A group loop has been detected. The package: ' , packageSpec name printString , ' requires a group that includes itself. If you resume, the group loop will be ignored and details will be written to the system log.'.                    groupLoopDetected := true.                    groupLoops add: packageSpec.                    MetacelloNotification signal: 'Package: ' , packageSpec name printString.                    MetacelloNotification signal: 'Raw Requires:' level: 2.                    packageSpec requires do: [:each |  MetacelloNotification signal: each asString level: 3 ].                    MetacelloNotification signal: 'Package: ' , packageSpec name printString , ' has a group loop:'.                    MetacelloNotification signal: 'Expanded Requires:' level: 2.                    targetSpecNames do: [:each |  MetacelloNotification signal: each asString level: 3 ] ].              movePackage := movePackage or: [ packageIndex <= targetIndex ].              false ifTrue: [ packageIndex < targetIndex ifTrue: [ MetacelloNotification signal: 'Moving ' , targetPackageOrProjectName , ' from ' , targetIndex printString , ' to ' , packageIndex printString ] ] ] ].  groupLoopDetected ifTrue: [ targetSpecNames := packageSpec requires.        targetSpecNames do: [:targetPackageName |  targetPackage := orderedSpecs detect: [:each |  each name = targetPackageName ] ifNone: [  ].              targetIndex := orderedSpecs indexOf: targetPackage.              movePackage := movePackage or: [ packageIndex <= targetIndex ] ] ].  movePackage ifTrue: [ moved := true.        orderedSpecs remove: packageSpec ifAbsent: [ ^self error: 'unexpected error removing package' ].        targetIndex := 0.        targetSpecNames do: [:targetPackageOrProjectName |  (targetPackage := orderedSpecs detect: [:each |  each name = targetPackageOrProjectName ] ifNone: [  ]) ~~ nil ifTrue: [ targetIndex := targetIndex max: (orderedSpecs indexOf: targetPackage) ] ].        targetIndex == 0 ifTrue: [ orderedSpecs add: packageSpec beforeIndex: packageIndex ] ifFalse: [ orderedSpecs add: packageSpec afterIndex: targetIndex ] ].  ^moveddirectory  ^self localRepository directoryimportForVersion: aString provides: anArray  self root import: aString provides: anArraycopyMember  ^MetacelloCopyMemberSpec for: self projectsetUpRepositoryContents  super setUpRepositoryContents.  self setUpRepositoryContents: self configurationRepositoryContents sourceRepo: MetacelloScriptingResource current configurationRepository targetRepo: (MCFileTreeRepository new directory: configurationDirectory).  self setUpRepositoryContents: self externalRepositoryContents sourceRepo: MetacelloScriptingResource current externalRepository targetRepo: (MCFileTreeRepository new directory: externalDirectory).  self setUpRepositoryContents: self sampleRepositoryContents sourceRepo: MetacelloScriptingResource current sampleRepository targetRepo: (MCFileTreeRepository new directory: sampleDirectory)projectWith: projectAttributes  | project |  project := MetacelloProject new.  project projectAttributes: projectAttributes.  MetacelloVersionConstructor on: self project: project.  ^projectpackageNamed: aString ifAbsent: aBlock  ^self map at: aString ifAbsent: aBlocklatestVersion: blessing  ^(self map values select: [:version |  blessing = version blessing ]) detectMax: [:version |  version ]isMutable  mutable ifNil: [ ^true ].  ^mutableproject: aString overrides: aBlock constructor: aVersionConstructor  aVersionConstructor projectForVersion: aString overrides: aBlockaLoadedPackageIsCurrent  ^aLoadedPackageIsCurrentregister  actionArg := #register -> #()version10: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #release ]projectName  ^projectNameauthorName: aString  self subclassResponsibilitysetAuthor: anObject  author := anObjectsetUp  | repo |  super setUp.  MetacelloPlatform current clearPackageCache.  repo := self monticelloRepository.  gofer := Gofer new.  gofer disablePackageCache.  gofer repository: repo.  testingEnvironment at: #Metacello_Gofer_Test_Repository put: repo.  repo := self configurationRepository.  gofer repository: repo.  testingEnvironment at: #Metacello_Configuration_Test_Repository put: repo.  initialWorkingCopyList := MCWorkingCopy allManagers collect: [:each |  each packageName ]do: elementBlock separatedBy: separatorBlock  | beforeFirst |  beforeFirst := true.  self do: [:each |  beforeFirst ifTrue: [ beforeFirst := false ] ifFalse: [ separatorBlock value ].        elementBlock value: each ]baseline16: spec  < version: '1.6-baseline'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'filetree://' , MCFileTreeFileUtils current default fullName , '/temp/repo' ] ]projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  groupBlock value: selftestReferenceConfigPrintString  | version string expected x y |  version := MetacelloReferenceConfig project version: '1.0-baseline'.  string := self conditionResult: version spec printString.  expected := self expectedPrintString.  1 to: string size do: [:i |  (i > expected size or: [ (string at: i) ~= (expected at: i) ]) ifTrue: [ x := string copyFrom: (i - 25 max: 1) to: (i + 25 min: string size).              y := expected copyFrom: ((i - 25 max: 1) min: expected size) to: (i + 25 min: expected size).              Array with: x with: y ] ].  self assert: string equals: expectedcompareEqualTo: aMetacelloVersionNumber  aMetacelloVersionNumber species = self species ifFalse: [ ^false ].  (self compareEqualTo: self normalVersion other: aMetacelloVersionNumber normalVersion) ifFalse: [ ^false ].  (self compareEqualTo: self preReleaseVersion other: aMetacelloVersionNumber preReleaseVersion) ifFalse: [ ^false ].  ^self compareEqualTo: self buildVersion other: aMetacelloVersionNumber buildVersiontestCopyToPackage  | packages package |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages copy: 'Package' to: (self packageSpec           name: 'PackageCopy';           yourself).  package := packages packageNamed: 'PackageCopy' ifAbsent: [ self assert: false ].  self assert: package name equals: 'PackageCopy'.  self assert: package requires equals: #('AnotherPackage').  self assert: package includes equals: #('IncludedPackage').  self assert: package answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer')).  self assert: package file equals: 'Package-dkh.1'.  self assert: package preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: package postLoadDoIt value identicalTo: #postLoadDoIttestProjectReferenceMergeSpec  | projectReferenceA projectReferenceB projectReference project |  projectReferenceA := self projectReferenceSpec     name: 'Project';     projectReference: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           yourself);     yourself.  projectReferenceB := self projectReferenceSpec     name: 'Project';     projectReference: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectB';           versionString: '1.0';           yourself);     yourself.  projectReference := projectReferenceA mergeSpec: projectReferenceB.  self assert: projectReference name equals: 'Project'.  self assert: projectReference projectName equals: 'Project'.  project := projectReference projectReference.  self assert: project className equals: 'ConfigurationOfProjectB'.  self assert: project versionString equals: '1.0'testIncrementDecrementVersionNumber  | version |  super testIncrementDecrementVersionNumber.  version := '1' asMetacelloVersionNumber.  self assert: version incrementMinorVersionNumber asString equals: '2'.  self assert: version decrementMinorVersionNumber asString equals: '1'.  version := '1.0' asMetacelloVersionNumber.  self assert: version incrementMinorVersionNumber asString equals: '1.1'.  self assert: version decrementMinorVersionNumber asString equals: '1.0'.  version := '1.0.0' asMetacelloVersionNumber.  self assert: version incrementMinorVersionNumber asString equals: '1.0.1'.  self assert: version decrementMinorVersionNumber asString equals: '1.0.0'.  version := '1.0.0.0' asMetacelloVersionNumber.  self assert: version incrementMinorVersionNumber asString equals: '1.0.0.1'.  self assert: version decrementMinorVersionNumber asString equals: '1.0.0.0'currentVersionString  ^self configurationProjectSpec ifNotNil: [:aSpec |  aSpec versionString ] ifNil: [ baselineProjectSpec repositoryVersionString ]executeString: aString do: projectSpecBlock  singleRoot ifNil: [ self singleRoot: true ].  ((projectSpecGenerator projectSpecLookupBlock value: aString) select: self projectSpecSelectBlock) do: [:projectSpec |  projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]configuration: aConfig  configuration := aConfigversionString: anObject constructor: aVersionConstructor  aVersionConstructor versionStringForProject: anObjectpackageNamed: aString  ^self packageNamed: aString ifAbsent: [ ^nil ]project: anObject  project := anObjectgroup: aString overrides: aStringOrCollection constructor: aVersionConstructor  aVersionConstructor groupForVersion: aString overrides: aStringOrCollectionextractExcludedValidations  | exclusionDict |  exclusionDict := Dictionary new.  (Pragma allNamed: #excludedValidationIssues: in: self configurationClass) do: [:pragma |  | exclusions |        exclusions := pragma argumentAt: 1.        1 to: exclusions size by: 2 do: [:index |  exclusionDict at: (exclusions at: index) put: (exclusions at: index + 1) ] ].  ^exclusionDictpackageInfoFor: aMCWorkingCopy  ^aMCWorkingCopy packageInforoot  ^rootcurrentPackageLoaded: loadedBlock notLoaded: notLoadedBlock using: anMCLoader  | vis |  vis := anMCLoader ancestorsFor: self.  vis notNil ifTrue: [ self getFile == nil ifTrue: [ ^loadedBlock value: #() value: self file ].        ^loadedBlock value: vis value: self file ].  ^notLoadedBlock valuetestAddA  | repositories repository |  repositories := self repositoriesSpec.  repositories     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'DaleHenrichs';           password: 'secret';           yourself).  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  self assert: repository username equals: 'DaleHenrichs'.  self assert: repository password equals: 'secret'mergeScriptRepository: anotherSpec  self repositories: anotherSpec repositoriescheckpointSave  ^Lesson title: '4. Checkpoint save' lesson: '"After having done development for awhile, you may want to checkpoint your work to share with others, test in another development environment or just to backup your work.You can save the modified mcz files, update the development version spec with the new mcz file names and then save the configuration:"	MetacelloToolBox 		saveModifiedPackagesAndConfigurationIn: ConfigurationOfExample		description: ''- fixed Issue 1090''."Or you can arrange to just save the modified mcz files and update the development version spec with the new mcz file names:"	MetacelloToolBox 		saveModifiedPackagesIn: ConfigurationOfExample		description: ''- fixed Issue 1090''.ProfStef next.'repositoryForVersion: anObject  self repositoryForSpec: anObjectbaselineOfVersionSpecClass  ^self subclassResponsibilityprojectSpec  ^self project projectSpeccheckAllowed  self existingProjectRegistration locked ifTrue: [ self resume: (MetacelloAllowLockedProjectChange new                 operationString: self operationString;                 existingProjectRegistration: self existingProjectRegistration;                 newProjectRegistration: self newProjectRegistration;                 signal) ]scpUrl  ^self sshPort ifNil: [ 'git@<1s>:<2s>.git' expandMacrosWith: self hostname with: projectPath ] ifNotNil: [:port |  'ssh://git@<1s>:<2s>/<3s>.git' expandMacrosWith: self hostname with: port with: projectPath ]validate: expectedConfigurationClassName expConfigVersion: expectedConfigurationVersion expConfigRepo: expectedConfigurationRepository expBaselineClassName: expectedBaselineClassName expBaselineVersion: expectedBaselineVersion expBaselineRepo: expectedBaselineRepository  MetacelloProjectRegistration registry configurationRegistry at: expectedConfigurationClassName ifPresent: [:existing |  | spec x |        spec := existing configurationProjectSpec.        self assert: (x := spec version versionString) equals: expectedConfigurationVersion.        self assert: (spec repositoryDescriptions includes: expectedConfigurationRepository) ] ifAbsent: [ self assert: expectedConfigurationVersion identicalTo: nil ].  MetacelloProjectRegistration registry baselineRegistry at: expectedBaselineClassName ifPresent: [:existing |  | spec |        spec := existing baselineProjectSpec.        self assert: spec versionString equals: expectedBaselineVersion.        self assert: (spec repositoryDescriptions includes: expectedBaselineRepository) ] ifAbsent: [ self assert: expectedBaselineVersion identicalTo: nil ]setUpVersionReferences  versionReferences := OrderedCollection new.  versionReferences     add: (GoferVersionReference name: 'GoferFan-dkh.1') -> #GoferFar;     add: (GoferVersionReference name: 'GoferBar-dkh.1') -> #Object;     add: (GoferVersionReference name: 'GoferFoo-dkh.4') -> #GoferBeau;     add: (GoferVersionReference name: 'GoferFoo-dkh.5') -> #GoferBeau;     add: (GoferVersionReference name: 'GoferBeau-dkh.15') -> #GoferBar;     add: (GoferVersionReference name: 'GoferFaux-tg.30') -> #Object;     add: (GoferVersionReference name: 'GoferFar-dkh.4') -> #GoferFoo;     add: (GoferVersionReference name: 'GoferBarDependency-dkh.4') -> #Object;     add: (GoferVersionReference name: 'GoferFooDependency-lr.4') -> #Object;     add: (GoferVersionReference name: 'GoferBarDependency-lr.30') -> #Object;     add: (GoferVersionReference name: 'GoferFooDependency-lr.30') -> #Object;     add: (GoferVersionReference name: 'GoferBarDependency-lr.35') -> #Object;     add: (GoferVersionReference name: 'GoferFooDependency-lr.35') -> #Object;     yourselfrepositories: aBlock constructor: aVersionConstructor  aVersionConstructor repositoriesForProject: aBlockcommitMethod  | skipValidation |  skipValidation := false.  self methodSpec ifNil: [ ^self ].  self methodSpec compileMethod.  project := project configuration class project.  [ project version: self methodSpec versionString ] on: MetacelloSymbolicVersionDoesNotExistError do: [:ex |  skipValidation := true ].  skipValidation ifFalse: [ self validateVersion: self methodSpec versionString ].  methodSpec := nilsetUpRepositoryContents  super setUpRepositoryContents.  testingEnvironment at: #Metacello_Config_Test_Repository put: configurationRepositoryremoveFromMetacelloRepositories: aMetacelloRepositoriesSpec  aMetacelloRepositoriesSpec addMember: (aMetacelloRepositoriesSpec removeMember           name: self name;           spec: self;           yourself)postCopy  super postCopy.  goferPackage := nil.  repositories := repositories copyincludesForPackage: anObject  self root includes: anObjectdefaultSymbolicVersionResolverBlock: receiver  ^[:symbolicVrsn :pragma |  | result |  result := nil.  (pragma argumentAt: 1) = symbolicVrsn ifTrue: [ self symbolicVersion: symbolicVrsn.        result := [ receiver perform: (MetacelloPlatform current selectorForPragma: pragma) ] on: MetacelloVersionDoesNotExistError do: [:ex |  ex return: nil ] ].  result ]testIsConfigurationName  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self deny: cli isConfigurationName.  cli := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self assert: cli isConfigurationNameloader: aLoader  loader := aLoaderloads: aStringOrCollection  self root loads: aStringOrCollection constructor: selfapplyToList: aListSpec  aListSpec add: selfversionSpecClass  ^MetacelloVersionSpecpreLoadDoIt: anObject  anObject setPreLoadDoItInMetacelloSpec: selfpostLoadDoIt  ^postLoadDoItmergeRepositoriesSpec: anotherRepositories  self repositories: anotherRepositoriesshouldQuit  ^self noQuit nottestVersion01  self assert: (self versionClass fromString: '1.1.1') versionString equals: '1.1.1'includeSpecNamesForPackageOrdering: aVersionSpec  ^self specs: self includesForPackageOrdering forPackageOrdering: aVersionSpecpreLoadDoItForVersion: aSymbol  self preLoadDoItForSpec: aSymbolsetUpRepositories  configurationRepository := MCDictionaryRepository new.  externalRepository := MCDictionaryRepository new.  sampleRepository := MCDictionaryRepository newlocked  ^self     project: [:projectSpec |  projectSpec isLocked ];     listpostloadDoIt  Smalltalk at: #Metacello_Configuration_Test_POST_DoIt_Result put: trueprojectSpecLookupBlock  ^[:projectName |  {(MetacelloProjectRegistration projectSpecForClassNamed: (MetacelloScriptEngine baselineNameFrom: projectName) ifAbsent: [  ]) .   (MetacelloProjectRegistration projectSpecForClassNamed: (MetacelloScriptEngine configurationNameFrom: projectName) ifAbsent: [  ])} ]versionString  ^versionStringintro  ^Lesson title: 'Intro' lesson: '"The lessons in this section cover some of the same material that was covered in the development process tutorial, but we take a closer look at the implementation using the instance-side protocol instead of the class-side protocol"	ProfStef next.'isEmpty  ^self list isEmptyincludesVersionNamed: aString  ^self localRepository includesVersionNamed: aStringload: aVersionString  ^(self version: aVersionString) loadupdateCategories  MetacelloPlatform current bypassGoferLoadUpdateCategories ifFalse: [ super updateCategories ]executeString: aString do: projectSpecBlock  singleRoot ifNil: [ self singleRoot: true ].  (projectSpecGenerator projectSpecCreationBlock value: aString) do: [:projectSpec |  projectSpec ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]postCopy  super postCopy.  requires := requires copy.  includes := includes copy.  answers := answers copyexecute  self workingCopies do: [:copy |  self unload: copy ].  self model load.  self gofer metacelloCleanup.  self workingCopies do: [:copy |  self unregister: copy ]monticelloRepository  ^monticelloRepositoryonConflictUseIncoming: incomingProjects useLoaded: loadedProjects  self onConflict: [:ex :loaded :incoming |  (incomingProjects includes: incoming baseName) ifTrue: [ ex useIncoming ] ifFalse: [ (loadedProjects includes: incoming baseName) ifTrue: [ ex useLoaded ] ].        ex pass ]lesson11Timestamp  ^Lesson title: 'Lesson 11 (Timestamp)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."The timestamp of a version can be defined:"	(MetacelloTutorialConfig project version: ''1.1'') timestamp."When using the OB-Metacello tools the timestamp field is automatically updated to reflect the currentDateAndTime that the update was made.The timestamp is a String"ProfStef next.'baseline40ProjectFum: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Feaux' with: [ spec                 className: 'MetacelloTestConfigurationOfFeaux';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFeaux';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'ProjectFie' with: [ spec                 className: 'MetacelloTestConfigurationOfProjectFie';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfProjectFie';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'ProjectFee' with: [ spec                 className: 'MetacelloTestConfigurationOfProjectFee';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfProjectFee';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]hasRepositoryOverrides  ^self overrideRepositories ~~ nilconfigMethodOn: aStream indent: indent  aStream     tab: indent;     nextPutAll: 'spec ';     cr;     tab: indent + 1;     nextPutAll: 'name: ' , self name printString , ';'.  self configMethodBodyOn: aStream indent: indent.  aStream nextPut: $.lesson14  setUp  | repo |  super setUp.  MetacelloPlatform current clearPackageCache.  MetacelloConfigurationResource projectAttributes: nil.  repo := self monticelloRepository.  self tempRepositories add: repo.  gofer repository: repo.  testingEnvironment at: #Metacello_Gofer_Test_Repository put: repo.  repo := self alternateRepository.  self tempRepositories add: repo.  testingEnvironment at: #Metacello_Configuration_Test_Alternate_Repository put: repo.  repo := self configurationRepository.  self tempRepositories add: repo.  testingEnvironment at: #Metacello_Configuration_Test_Repository put: repo.  initialWorkingCopyList := MCWorkingCopy allManagers collect: [:each |  each packageName ].  undefinedSymbols := MetacelloPlatform current disableUndefinedSybolUpdatestestForDoListNotActive  | project version expected actual |  project := self projectWith: #().  version := project version: '3.0-baseline'.  expected := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec group: ''Core'' with: #(''Example Project'' ).'.  actual := version spec printString.  self assert: expected equals: actualpackageDo: aBlock  aBlock value: selfhttpsUrl  ^'https://bitbucket.org/' , projectPath , '.git'cacheRepository: repository  self loaderPolicy cacheRepository: repositorylesson10  ^Lesson title: 'Lesson 10' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline10:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version10:."In lesson07 it was obvious that we copied the configuration information from MetacelloTutorialConfig and adapted it to our project.There is a better way.In #baseline10: we''ve created a project reference for the Example project.The #className: specifies the name of the class that contains the project metadata. If the class is not present in the image, then we know that we need to load the configuration for the project.The #file: and #repository: specifications give us the information needed to load the project metadata from a repository.Finally, the #versionString: and #loads: tell us which version of the project to load and which packages to load from the project.We''ve named the project reference ''Example ALL'' and in the specification for the ''Project-Core'' package, we''ve specified that ''Example ALL'' is required:"  (MetacelloProjectRefTutorialConfig project version: ''1.0'') load."Note that the entire Example project is loaded before ''Project-Core''"ProfStef next.'setRequires: aCollection  requires := aCollectionbuildVersion  buildVersion ifNil: [ buildVersion := #() ].  ^buildVersionprojects  | projects |  projects := OrderedCollection new.  self spec projectDo: [:prj |  projects add: prj projectReference ] packageDo: [:ignored |   ] groupDo: [:ignored |   ].  ^projectsauthor: aBlockOrString  self root author: aBlockOrString constructor: selfremovePackageForVersion: aString  | spec |  spec := self project packageSpec     name: aString;     yourself.  self root packages remove: specunload  self subclassResponsibilityparentDirectoryOf: aFileHandler  ^aFileHandler containingDirectoryrequiresSpecsForPackageOrdering: aVersionSpec  ^{self}isPossibleBaseline  ^self spec isPossibleBaselinebaseline60MethodSourceProjectIssue86  ^(self class sourceCodeAt: #baseline60ProjectIssue86:) asStringresolveToAllPackagesIn: aVersionSpec visited: visited  | vrsn |  visited pushProject: [ visited visit: self doing: [:spec |  spec ensureProjectLoaded.              vrsn := spec version.              ^vrsn allPackagesForSpecNamed: (self loadListForVersion: vrsn) ifAbsent: [ self error: 'invalid loads: spec' ] ] ].  ^#()baselineGooIssue156Baseline: spec  < baseline>  spec for: #common do: [ spec           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar.branch-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           yourself ]operationString: aString  operationString := aStringexpandToLoadableSpecNames: nameList  | cacheKey names |  cacheKey := Array with: self label with: nameList.  ^MetacelloPlatform current stackCacheFor: #loadableSpecNames at: cacheKey doing: [:cache |  names := (self resolveToLoadableSpecs: nameList) collect: [:spec |  spec name ].        cache at: cacheKey put: names ]monticelloRepository  ^monticelloRepositoryhonor  ^self disallowtype: aString  type := aStringgtInspectorProjectsIn: composite  < gtInspectorPresentationOrder: 40>  composite list     title: 'Projects';     display: [ | projects |        projects := OrderedCollection new.        self projectDo: [:prj |  projects add: prj ] packageDo: [:pkg |   ] groupDo: [:ignored |   ].        projects ]blessing  ^self basicSpec blessing valueconfiguration091Issue181: spec  < version: '0.9.1'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration091Issue181:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           import: 'External' ]project  ^project ifNil: [ | constructor loader |        constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.        project := constructor project.        loader := MetacelloNullRecordingMCSpecLoader new.        loader evalDoits: true.        project loader: loader.        project ]constructClassName  ^'BaselineOf' , self namecompareEqualTo: myComponents other: otherComponents  | mySize |  mySize := myComponents size.  mySize = otherComponents size ifFalse: [ ^false ].  1 to: mySize do: [:i |  (myComponents at: i) = (otherComponents at: i) ifFalse: [ ^false ] ].  ^trueextractCommonDefaultSymbolicVersionPragmas  | aDict |  aDict := Dictionary new.  self extractPragmas: #defaultSymbolicVersion: for: ConfigurationOf into: aDict.  ^aDictunregisterProject  ^MetacelloProjectRegistration registrationForProjectSpec: self ifAbsent: [  ] ifPresent: [:existing :new |  existing unregisterProject ]version10: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec           description: 'Version 1.0 the current stable release';           blessing: #release;           author: 'John Doe';           timestamp: '2013-05-01'.        spec           package: 'MyProject-Core' with: 'MyProject-Core-JohnDoe.52';           package: 'MyProject-Tests' with: 'MyProject-Tests-JohnDoe.73';           project: 'FuelMetalevel' with: #stable ]unlock  | spec |  MetacelloProjectRegistration copyRegistryRestoreOnErrorWhile: [ self setDefaultsAndValidate: self projectSpec copy.        spec := self projectSpec.        MetacelloProjectRegistration registrationForProjectSpec: spec ifAbsent: [:ignored |   ] ifPresent: [:existing :new |  existing copyOnWrite: [:existingCopy |  existingCopy locked: false ] ].        self root: spec ]isLoadedMatchConstraints: matchBlock  | matchStatus |  matchStatus := #loadedMatchConstraints.  (self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints)) ifTrue: [ aPackageIsLoaded & aProjectIsLoaded ifTrue: [ (aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not and: [ aLoadedProjectIsExact | aLoadedProjectIsCurrent & aLoadedProjectIsNotCurrent not ]) ifTrue: [ matchBlock value: matchStatus ] ] ifFalse: [ aPackageIsLoaded ifTrue: [ aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not ifTrue: [ matchBlock value: matchStatus ] ] ifFalse: [ hasNoPackage & (aLoadedProjectIsExact | aLoadedProjectIsCurrent) & aLoadedProjectIsNotCurrent not ifTrue: [ matchBlock value: matchStatus ] ] ] ]description: aString  description := aStringaddToMetacelloPackages: aMetacelloPackagesSpec  aMetacelloPackagesSpec addMember: (aMetacelloPackagesSpec addMember           name: self name;           spec: self;           yourself)projectSpecClass  ^MetacelloProjectSpecselectorForPragma: aPragma  ^aPragma methodSelectormethodSections  methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].  ^methodSectionspreLoad: packageOrVersionSpec  self evalDoits ifFalse: [ ^self ].  packageOrVersionSpec preLoadDoItBlock ~~ nil ifTrue: [ self beforeLoads add: packageOrVersionSpec printString , ' load' ].  super preLoad: packageOrVersionSpeclatestVersion  | excluded |  self flag: 'deprecate after version 1.0'.  excluded := self excludeFromLatestVersion.  ^(self map values select: [:version |  (excluded includes: version blessing) not ]) detectMax: [:version |  version ]baseline13MethodSourceC  ^(self class sourceCodeAt: #baseline13C:) asStringdefaultAction  ^self existingProjectRegistrationlesson05  unload  ^self spec unloadrepository: aStringOrMetacelloRepositorySpec  self repositories repository: aStringOrMetacelloRepositorySpectestReferenceConfig  | spec map string expected |  spec := (MetacelloReferenceConfig project version: '1.0-baseline') spec.  map := spec packages map.  string := self conditionResult: (map at: 'Example-AddOn') printString.  expected := 'spec 	name: ''Example-AddOn'';	requires: #(''Example-Core'' ''UI Support'' );	includes: #(''Example-UI'' );	supplyingAnswers: #( #( ''list of packages'' ''Kernel* Collection*'' ) );	file: ''Example-AddOn-anon.5'';	repository: ''http://www.example.com/or'' username: ''foo'' password: ''bar'';	preLoadDoIt: #''preloadForAddOn'';	postLoadDoIt: #''postloadForAddOn''.'.  self assert: string equals: expected.  string := (map at: 'Example-Core') printString.  self assert: string equals: 'spec name: ''Example-Core'''.  string := (map at: 'Example-TestsUI') printString.  self assert: string equals: 'spec 	name: ''Example-TestsUI'';	requires: #(''Example-UI'' ).'.  string := (map at: 'UI Support') printString.  self assert: string equals: 'spec 	name: ''UI Support'';	projectReference: [		spec			className: ''ConfigurationOfUINew'';			versionString: ''1.0.1'';			operator: #''>='';			loads: #(''UI-Core'' ''UI-Tests'' );			repository: ''http://www.example.com/r'' username: ''foo'' password: ''bar'' ].'postCopy  super postCopy.  repositories := repositories copy.  packages := packages copycurrentPackageLoaded: loadedBlock comparing: comarisonOperator notLoaded: notLoadedBlock using: anMCLoader  | wcName vis |  vis := anMCLoader ancestorsFor: self.  vis notNil ifTrue: [ | fileRef wcRef |        self getFile == nil ifTrue: [ ^loadedBlock value: false ].        vis do: [:vi |  wcName := vi name.              fileRef := GoferVersionReference name: self file.              fileRef versionNumber = 0 ifTrue: [ ^loadedBlock value: false ].              wcRef := GoferVersionReference name: wcName.              (wcRef compare: fileRef using: comarisonOperator) ifTrue: [ ^loadedBlock value: true ] ].        ^loadedBlock value: false ].  ^notLoadedBlock value: truesingletonVersionName  ^self class singletonVersionNameimports: importList  self methodSpec imports: importListrepository: aStringOrSpec  aStringOrSpec addToMetacelloRepositories: selfsetUp  super setUp.  self     setUpMonticelloRepository;     setUpConfigurationOfAtomicFoo;     setUpConfigurationOfLinearFoo;     setUpConfigurationOfAtomicFan;     setUpConfigurationOfUmbrellaA;     setUpConfigurationOfUmbrellaB;     setUpConfigurationOfProjectIssue86;     yourselfdirectoryFromPath: adirectoryPath relativeTo: anotherDirectoryPath  ^anotherDirectoryPath resolveString: adirectoryPathmergeIntoMetacelloPackages: aMetacelloPackagesSpec  aMetacelloPackagesSpec addMember: selfbuildVersion: anObject  buildVersion := anObjectvalidateProject  | project |  project := self validateProjectCreationFrom: self configurationClass onError: [:ex |  self recordValidationError: 'Error creating project: ' , ex description , ' to reproduce evalutate the following: ''' , self configurationClass name asString , ' project''' callSite: #validateProject reasonCode: #projectCreationError.        ^self validationReport ].  ^self validateProject: projectconfigMethodOn: aStream for: spec selector: selector last: last indent: indent  spec == nil ifTrue: [ ^self ].  aStream     tab: indent;     nextPutAll: 'spec ' , selector , ' [';     cr.  spec configMethodOn: aStream indent: indent + 1.  aStream nextPutAll: ' ].'.  last ifFalse: [ aStream cr ]sampleAuthorName  ^(Smalltalk at: #ExternalCore) new externalAuthorNameconfigMethodOn: aStream last: last indent: indent  | hasPackageSpecs |  hasPackageSpecs := false.  self packagesSpec list do: [:member |  member spec projectDo: [:proj |  member spec name ~~ nil ifTrue: [ hasPackageSpecs := true ] ] packageDo: [:package |  member spec name ~~ nil ifTrue: [ hasPackageSpecs := true ] ] groupDo: [:group |  member spec name ~~ nil ifTrue: [ hasPackageSpecs := true ] ] ].  self configMethodBasicOn: aStream last: hasPackageSpecs not indent: indent.  self configPackagesSpecMethodOn: aStream indent: indent.  last ifFalse: [ aStream cr ]version01: spec  < version: '0.1'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 file: 'Example-Core-anon.8';                 repository: 'http://www.example.com/Example' ] ]defaultPackageNamesToLoad: defaultList  ^self packageAndProjectNamesToLoad: defaultList loader: self loaderdefaultAction  ^MetacelloProjectSpecForLoad new     projectSpec: self projectSpec;     yourselfexecutorSpec: anAssoc  executorSpec := anAssocpostInstall  Smalltalk snapshot: self shouldSave andQuit: self shouldQuitconfigurationNamed: baseName  | configurationName |  configurationName := self configurationNameFrom: baseName.  (Smalltalk includesKey: configurationName asSymbol) ifFalse: [ self ensureMetacello.        MetacelloPlatform current copyClass: (MetacelloPlatform current globalNamed: #MetacelloConfigTemplate) as: configurationName asSymbol inCategory: configurationName asString.        MetacelloPlatform current registerPackageNamed: configurationName ].  project := (MetacelloPlatform current globalNamed: configurationName asSymbol) projecttimestamp  ^Date today mmddyyyy , ' ' , ((String streamContents: [:s |  Time now print24: true on: s ]) copyFrom: 1 to: 5)versionString  ^versionStringmerge: aProjectRegistration  self shouldBeMutable.  aProjectRegistration validate.  aProjectRegistration configurationProjectSpec ifNotNil: [:aSpec |  configurationProjectSpec := aSpec copy.        configurationProjectSpec versionOrNil ifNotNil: [:version |  configurationProjectSpec versionString: version versionString ].        baselineProjectSpec := nil.        self versionInfo versionString: configurationProjectSpec versionString ] ifNil: [ baselineProjectSpec := aProjectRegistration baselineProjectSpec.        configurationProjectSpec := nil.        self versionInfo versionString: baselineProjectSpec repositoryVersionString ]testShouldQuit  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self     deny: cli noQuit;     assert: cli shouldQuit.  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--no-quit').  self     assert: cli noQuit;     deny: cli shouldQuitallowEvenIfLocked  self resume: self newProjectRegistrationgetDescription  ^descriptionincludes: aCollection  aCollection setIncludesInMetacelloPackage: selftearDownRepositories  super tearDownRepositories.  configurationDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: configurationDirectory ].  externalDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: externalDirectory ].  sampleDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: sampleDirectory ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Gofer_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_MczConfiguration_Test_Repository ifAbsent: [  ].  MCRepositoryGroup default     removeIdenticalRepository: externalRepository;     removeIdenticalRepository: monticelloRepository;     removeIdenticalRepository: mczConfigurationRepository;     removeIdenticalRepository: configurationRepositorysetUpConfigurationExternalRef  | versionInfo |  versionInfo := self setUpConfigurationExternalRefdkh1.  versionInfo := self setUpConfigurationExternalRefdkh2: {versionInfo}baseline40ProjectInfinite: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Loop' with: [ spec                 className: 'MetacelloTestConfigurationOfProjectLoop';                 versionString: '4.0';                 loads: 'GeauxBeau';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec           package: 'GeauxBar' with: [ spec                 file: 'GeauxBar.branch-lr.2';                 requires: 'Loop';                 yourself ];           package: 'GoferBar' with: 'GoferBar-lr.1';           yourself ]compareLessThan: aMetacelloVersionNumber  | myComponents otherComponents defaultResult |  aMetacelloVersionNumber species = self species ifFalse: [ ^false ].  myComponents := self normalVersion.  otherComponents := aMetacelloVersionNumber normalVersion.  defaultResult := true.  (self compareEqualTo: myComponents other: otherComponents) ifTrue: [ defaultResult := false ] ifFalse: [ (self compareLessThan: myComponents other: otherComponents version: #normal) ifFalse: [ ^false ] ].  myComponents := self preReleaseVersion.  otherComponents := aMetacelloVersionNumber preReleaseVersion.  (self compareEqualTo: myComponents other: otherComponents) ifTrue: [ myComponents size > 0 ifTrue: [ defaultResult := false ] ] ifFalse: [ ^self compareLessThan: myComponents other: otherComponents version: #preRelease ].  myComponents := self buildVersion.  otherComponents := aMetacelloVersionNumber buildVersion.  ^(self compareEqualTo: myComponents other: otherComponents) ifTrue: [ defaultResult ] ifFalse: [ self compareLessThan: myComponents other: otherComponents version: #build ]baseline60Foo: spec  < version: '6.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        spec           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('1' 'GoferFaux');           yourself ]methodSource  self subclassResponsibilitytestMergePackageD  | packages |  packages := self packagesSpec.  packages     add: 'Platform';     merge: 'Tests'.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  packages packageNamed: 'Tests' ifAbsent: [ self assert: false ]addAttribute: anAttribute  self attributeOrder add: anAttributedo: aBlock displaying: aString  aBlock valuelesson11Author  ^Lesson title: 'Lesson 11 (Author)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."The author of a version can be defined:"	(MetacelloTutorialConfig project version: ''1.1'') author."When using the OB-Metacello tools the author field is automatically updated to reflect the currentauthor as defined in the image."ProfStef next.'decrementNormalVersionAt: index  | int col |  col := self normalVersion.  int := col at: index.  int > 0 ifTrue: [ col at: index put: int - 1 ]gemsource: projectName  self repository: 'http://seaside.gemtalksystems.com/ss/' , projectNameasConfigurationProject  ^MetacelloMCProject newbaseline10ProjectFum: spec  < version: '1.0'>  spec for: #common do: [ spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '5.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Fie' with: [ spec                 className: 'MetacelloTestConfigurationOfProjectFie';                 versionString: '2.5';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]package: aString overrides: aBlock  self root package: aString overrides: aBlock constructor: selfrepositoryForRepositories: aString username: username password: password  self repositoryForVersion: aString username: username password: passwordoperator: anObject  self root operator: anObject constructor: selfprojectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  self subclassResponsibilityconflictOf11: spec  < version: '1.1.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>conflictOf11:'.        spec author: 'dkh'.        spec timestamp: '6/1/2012 14:46' ].  spec for: #custom do: [ spec configuration: 'ExternalX' with: [ spec                 version: '0.9.0';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]testVersion09  | v1 v2 |  v1 := self versionClass fromString: '1.0.0'.  v2 := self versionClass fromString: '0.7.0'.  self assert: v1 >= v2.  self assert: v2 <= v1testVersion06  | v1 v2 |  v1 := self versionClass fromString: '3.'.  v2 := self versionClass fromString: '2'.  self assert: v1 > v2loadPackageList  | vrsn pkgs |  (vrsn := self versionOrNil) == nil ifTrue: [ ^#() ].  pkgs := OrderedCollection new.  (self loadListForVersion: vrsn) do: [:nm |  pkgs addAll: ((vrsn packagesForSpecNamed: nm) collect: [:each |  each name ]) ].  ^pkgsrepository: aString username: username password: password constructor: aVersionConstructor  aVersionConstructor repositoryForPackage: aString username: username password: passwordversionNumberClass  ^MetacelloVersionNumbersetDescription: anObject  description := anObjectsetUpInvalidConfigurations  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfInvalidConfigurations-dkh.1'.  className := #ConfigurationOfInvalidConfigurations.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'invalidConfiguration10:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #invalidConfiguration10:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'invalidConfiguration20:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #invalidConfiguration20:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'invalidConfiguration30:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #invalidConfiguration30:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfolesson08  with: aMetacelloSpec during: aBlock  | previousRoot |  previousRoot := self root.  self root: aMetacelloSpec.  aBlock ensure: [ self root: previousRoot ]setUpConfiguration63  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfIssue63-dkh.1'.  className := #ConfigurationOfIssue63.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration091Issue63:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration091Issue63:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configuration092Issue63:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration092Issue63:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoapproximateBase  | base |  base := self copyFrom: 1 to: self size - 1.  base at: base size put: (base at: base size) + 1.  ^baseconfigMethodOn: aStream for: aValue selector: selector cascading: cascading cascade: cascade indent: indent  | valuePrintString |  aValue == nil ifTrue: [ ^self ].  cascading ifTrue: [ aStream           cr;           tab: indent ].  valuePrintString := aValue value isSymbol ifTrue: [ '#' , aValue value asString printString ] ifFalse: [ aValue value printString ].  aStream nextPutAll: selector , valuePrintString.  cascade ifTrue: [ aStream nextPut: $; ]squeaksource3: projectName  self repository: 'http://ss3.gemtalksystems.com/ss/' , projectNamebaseline14: spec  < version: '1.4-baseline'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'http://example.com/examples' ] ]required  required == nil ifTrue: [ ^#() ].  ^requiredprojectClass  ^MetacelloMCProjecttestBasicStableVersion  | project version expected actual |  project := self projectWith: #(#'platformVersion1.x').  version := project version: #stable.  expected := 'spec blessing: #''release''.spec project: ''Example Project'' with: [		spec			className: ''MetacelloExampleProjectConfig'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'' ].'.  actual := version spec printString.  self assert: expected equals: actuallesson03  ^Lesson title: 'Lesson 3' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version03:."For version 0.3, we''ve updated the package version to ''Example-Core-anon.10'' and added an additional package ''Example-Tests-anon.3'', which can be confirmed by printing the following expression:"  (MetacelloTutorialConfig project version: ''0.3'') spec."As is often the case, the two packages share the same repository, so specifying a repository witheach package is redundant."ProfStef next.'collapseZeros  | collection newSize new j lastElementIsStringOrZero canCollapse |  (self size = 0 or: [ self at: 1 ]) == 0 ifTrue: [ ^self ].  collection := OrderedCollection new.  lastElementIsStringOrZero := true.  canCollapse := true.  self size to: 1 by: -1 do: [:i |  | element |        element := self at: i.        (canCollapse and: [ element == 0 ]) ifTrue: [ lastElementIsStringOrZero ifFalse: [ canCollapse := false.                    collection addFirst: element ] ] ifFalse: [ collection addFirst: element.              canCollapse := lastElementIsStringOrZero := element isString ] ].  collection size = self size ifTrue: [ ^self ].  newSize := collection size.  new := self species new: newSize.  j := 0.  collection do: [:element |  new at: j + 1 put: element.        j := j + 1 ].  ^newconfiguration098Issue215: spec  < version: '0.9.8'>  spec for: #common do: [ spec description: self className , '>>configuration092Issue63:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           package: 'GoferBar' with: [ spec                 file: 'GoferBar-lr.1';                 requires: 'External-Core';                 repository: 'dictionary://Metacello_Gofer_Test_Repository' ];           package: 'GoferFoo' with: [ spec                 file: 'GoferFoo-lr.2';                 requires: 'External-Tests';                 repository: 'dictionary://Metacello_Gofer_Test_Repository' ];           import: 'External' provides: #('External-Core' 'External-Tests') ]overrideRepositories: anObject  overrideRepositories := anObjectpostloads  postloads == nil ifTrue: [ postloads := OrderedCollection new ].  ^postloadspostCopy  super postCopy.  mutable := nil.  loader ~~ nil ifTrue: [ self loader: loader ]decrementMinorVersionNumber  | int |  self size to: 1 by: -1 do: [:index |  (int := self at: index) isString ifFalse: [ int > 0 ifTrue: [ self at: index put: int - 1 ].              ^self ] ]issues  ^issuesmergeMap  | map |  map := super mergeMap.  map at: #requires put: requires.  map at: #includes put: includes.  map at: #answers put: answers.  ^mapbaseline20: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec project: 'UTF8' with: [ spec                 className: 'MetacelloVersionQueryMiscConfig';                 versionString: #stable;                 loads: #('Misc-UTF8') ].        spec project: 'UTF9' with: [ spec                 className: 'MetacelloVersionQueryOtherConfig';                 versionString: '1.0-baseline';                 loads: #('Misc-UTF8') ].        spec           group: 'Core' with: #('UTF8' 'UTF9');           group: 'Tests' with: #('UTF8');           group: 'Recursive' with: #('Core' 'Recursive') ]setUpConfigurationOfProjectFum  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectFum-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline10ProjectFum:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline10ProjectFum:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())classicCreateProjectReferenceSpec: projectBaseName  | configurationName projectReferenceProject versionString |  configurationName := self configurationNameFrom: projectBaseName.  projectReferenceProject := (MetacelloPlatform current globalNamed: configurationName asSymbol ifAbsent: [ self error: 'The project with configuration ' , configurationName printString , ' for the project ' , projectBaseName printString , ' is not currently loaded into the image.' ]) project.  versionString := (projectReferenceProject hasVersion: #stable) ifTrue: [ #stable ] ifFalse: [ #bleedingEdge ].  ^project projectReferenceSpec     name: projectBaseName;     projectReference: (project projectSpec           name: projectBaseName;           className: configurationName;           versionString: versionString;           yourself);     yourselftutorial  ^#(#lesson07 #lesson10 #lesson11 #lesson12 #lesson13 #lesson14)searchCacheRepositoryForPackage: searchBlock  searchBlock valueensureForDevelopment  ^truecloseZipArchive: anArchive  anArchive closegtInspectorPackagesIn: composite  < gtInspectorPresentationOrder: 40>  self version gtInspectorPackagesIn: compositetestRepositoryMergeSpec  | repositoryA repositoryB repository |  repositoryA := self repositorySpec     description: '/opt/gemstone/repository';     username: 'dkh';     password: 'password';     type: 'directory';     yourself.  repositoryB := self repositorySpec     description: 'http://example.com/repository';     password: 'secret';     yourself.  repository := repositoryA mergeSpec: repositoryB.  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'secret'.  self assert: repository type equals: 'http'projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  projectBlock value: selfget  actionArg := #get -> #()sourceName: aString  sourceName := aStringtestApproxVersion01  self assert: '1.1.1' asMetacelloVersionNumber ~> '1.1' asMetacelloVersionNumberfile  file ifNil: [ ^self className ].  ^fileasBaselineProject  ^MetacelloMCBaselineProject newresolveToPackagesIn: aVersionSpec visited: visited  ^{self}testBaseline10Groups  | project version expected list |  project := self project.  version := project version: '1.0-baseline'.  expected := #('Core' 'Tests' 'Recursive').  list := version groups.  self assert: list size equals: expected size.  list do: [:pkg |  self assert: (expected includes: pkg name) ]packageInfoFor: aMCWorkingCopy  ^aMCWorkingCopy packageSetcompareEqual: aMetacelloProjectSpec  ^(super compareEqual: aMetacelloProjectSpec) and: [ self file = aMetacelloProjectSpec file ]version30Issue119: spec  < version: '3.0' imports: #('3.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '2.0'.        spec package: 'GoferBar' with: 'GoferBar-jf.1' ]versionForVersion: anObject  self versionStringForVersion: anObjectlatestVersionMatching: versionPatternString includedBlessings: included excludedBlessings: excludedBlessings  ^nilexecute: aWorkingCopy  | version |  version := MetacelloPlatform current newVersionForWorkingCopy: aWorkingCopy.  self gofer repositories do: [:repository |  repository storeVersion: version ]project: aString with: aBlockOrString constructor: aVersionConstructor  aVersionConstructor projectForVersion: aString with: aBlockOrStringisAllLoadedToSpec  self isPartiallyCurrent isAllLoadedToSpec: [:ignored |  ^true ].  ^falsedecrementPatchVersion  self size < 2 ifTrue: [ self at: 2 put: 0 ].  self size < 3 ifTrue: [ self at: 3 put: 0 ].  self decrementVersionAt: 3getRepositories  ^nilensureProjectLoaded  (self projectClass == nil or: [ self versionOrNil == nil or: [ (loader notNil or: [ self isMutable ]) and: [ self loader ignoreImage ] ] ]) ifTrue: [ | pc |        (pc := self projectClass) ~~ nil ifTrue: [ MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo #versionConstructor #loadableSpecNames) , {pc} ].        self projectPackage ifNil: [ ^true ].        self ensureLoadUsing: self loader ].  ^self projectClass ~~ nilsetUpConfigurationIssue32  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfIssue32-dkh.1'.  className := #ConfigurationOfIssue32.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version10Issue47:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue47:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version09Issue32:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version09Issue32:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoversionString  ^versionStringdevelopment  ^nilrepository: anObject constructor: aVersionConstructor  aVersionConstructor repositoryForVersion: anObjecthasVersion  ^self hasOption: 'version'projectClass  ^MetacelloMCProjectsetAnswers: aCollection  answers := aCollectionsilently  ^self options at: #silently ifAbsent: [ false ]updateVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs  versionSpec specListProjectDo: [:spec |  (updateProjects and: [ (visitedSpecs includes: spec name) not ]) ifTrue: [ | fullProjectSpec |              fullProjectSpec := (fullVersionSpec packageNamed: spec name) projectReference.              (fullProjectSpec versionString ~~ nil and: [ fullProjectSpec versionString ~~ #stable and: [ fullProjectSpec projectClass ~~ nil ] ]) ifTrue: [ | cv |                    cv := fullProjectSpec projectClassProject currentVersion.                    cv ~~ nil ifTrue: [ cv versionString ~= fullProjectSpec versionString ifTrue: [ spec projectReference versionString: cv versionString.                                updatedSpecs add: spec name ] ] ifFalse: [ spec projectReference versionString: ''.                          updatedSpecs add: spec name ] ] ] ] packageDo: [:spec |  (updatePackages and: [ (visitedSpecs includes: spec name) not ]) ifTrue: [ spec getFile ~~ nil ifTrue: [ | viName |                    spec file = '' ifTrue: [ spec file: spec name ].                    (viName := spec workingCopyNameFor: spec loader) ~~ nil ifTrue: [ viName ~= spec file ifTrue: [ spec file: viName.                                updatedSpecs add: spec name ].                          visitedSpecs add: spec name ] ] ] ] groupDo: [:ignored |   ]setPackage: aString withString: aFile  | spec |  spec := self project packageSpec     name: aString;     file: aFile;     yourself.  self root packages merge: specdefaultLoaderClass  ^MetacelloLoadingMCSpecLoaderincrementMinorVersionNumber  | int |  self size to: 1 by: -1 do: [:index |  (int := self at: index) isString ifFalse: [ self at: index put: int + 1.              ^self ] ]configHasVersionString  ^self versionString ~~ nilbleedingEdgeVersion: spec  < symbolicVersion: #bleedingEdge>  spec for: #common version: '4.0'downloadZipArchive: url to: outputFileName  | archive zipfile errorFileName |  errorFileName := self downloadBasicFile: url to: outputFileName username: nil pass: nil.  archive := ZipArchive new.  zipfile := self fileHandleOn: outputFileName.  zipfile containingDirectory readOnlyFileNamed: zipfile localName do: [:fileStream |  [ archive readFrom: fileStream ] on: Error do: [:ex |  self error: 'Error during download (' , ex description , ') please check the file ' , errorFileName printString , ' for error message.' ] ].  self deleteFileNamed: errorFileName.  ^archiveisConfigurationOfProjectSpec  ^falseversion30Issue125: spec  < version: '3.0' imports: #('3.0-baseline')>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloConfigurationResource>>version30Issue125:'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-jf.1';           yourself ].  spec for: #attribute1 do: [ spec           package: 'GoferFaux' with: 'GoferFaux-tg.32';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself ].  spec for: #attribute2 do: [ spec           package: 'GoferFaux' with: 'GoferFaux-tg.33';           package: 'GoferBeau' with: 'GoferBeau-dkh.56';           yourself ]methodSection: methodSection inEvaluationOrder: attributes do: aBlock  | selected |  selected := IdentitySet new.  attributes do: [:attribute |  methodSection methodSections do: [:ms |  (ms attributes includes: attribute) ifTrue: [ selected add: ms ] ] ].  selected do: aBlock.  attributes size == 1 ifTrue: [ ^self ].  selected do: [:ms |  self methodSection: ms inEvaluationOrder: (attributes copyFrom: 2 to: attributes size) do: aBlock ]baseline60ProjectIssue86: spec  < version: '6.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'A' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.0';                 loads: #('1');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'B' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.0';                 loads: #('2');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]bleedingEdge206B: spec  < symbolicVersion: #bleedingEdge>  spec for: #common version: '2.1'processPID  ^''setBaseline: aString withBlock: aBlock  | projectSpec |  projectSpec := self setBaseline: aString.  self with: projectSpec during: aBlockgetOperator  ^operatorsetBlessingWithString: aString  self root blessing: aStringsetUpConfigurationOfProjectIssue171dkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue171-dkh.2'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion21Issue171:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion21Issue171:) asString) .   (MCMethodDefinition className: className asString selector: 'version21Issue171:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version21Issue171:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInforequired: anObject  required := anObjectlabel  ^''possiblyNewerVersionsOfAnyOf: someVersions  ^self localRepository possiblyNewerVersionsOfAnyOf: someVersionsunloadPackage: packageName  | aGofer |  aGofer := Gofer new.  (self hasPackage: packageName) ifTrue: [ aGofer package: packageName ].  aGofer references notEmpty ifTrue: [ aGofer unload ]version: anObject constructor: aVersionConstructor  aVersionConstructor versionForProject: anObjectselector  ^selectorsingleRoot  singleRoot ifNil: [ singleRoot := false ].  ^singleRootdeleteFileNamed: filePath  filePath asFileReference deletesignal: aMetacelloValidationIssue  self issue: aMetacelloValidationIssue.  ^self signalisCritical  ^self isError or: [ self isCriticalWarning ]lesson12DoIts  setUpConfigurationOfExternalIV  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternalIV-dkh.1'.  className := #ConfigurationOfExternalIV.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfIV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfIV:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfosetLoads: aCollection  self shouldBeMutable.  loads := aCollectionrepositoriesSpec  ^self project repositoriesSpeccustomProjectAttributes  ^#()printOn: aStream  self configMethodOn: aStream indent: 0packageSpecClass  ^MetacelloPackageSpecfileHandleOn: aPath  ^self fileDirectoryClass on: aPathmergeSpec: aSpec  | newSpec nonOverridable |  self validateMergeForSpec: aSpec.  newSpec := self copy.  nonOverridable := self nonOverridable.  aSpec mergeMap keysAndValuesDo: [:key :value |  (nonOverridable includes: key) ifFalse: [ value ~~ nil ifTrue: [ newSpec instVarNamed: key asString put: value ] ] ].  ^newSpecoptions  options ifNil: [ options := Dictionary new ].  ^optionsmergeScriptLoads: aSpec  self shouldBeMutable.  aSpec loads ifNotNil: [:otherLoads |  self loads ifNil: [ loads := otherLoads ] ifNotNil: [ loads := (loads , otherLoads) asSet asArray ] ].  self loader: aSpec loaderregistrations  ^self baselineRegistry values , self configurationRegistry valuesextractTypeFromDescription  ^MetacelloPlatform current extractTypeFromDescription: self descriptionerrorMap: anObject  errorMap ifNil: [ errorMap := Dictionary new ].  errorMap := anObjectblock: anObject  block := anObjectsuspendSystemUpdateEventsDuring: aBlock  (Smalltalk at: #SystemChangeNotifier) uniqueInstance doSilently: aBlockvalidateDoIts: aSpec versionString: versionString errorMessage: errorMessage  | ar |  ar := {#preLoadDoIt .   'preLoadDoIt selector for ' .   #postLoadDoIt .   'postLoadDoIt selector for '}.  1 to: ar size by: 2 do: [:i |  | selector |        selector := (aSpec perform: (ar at: i)) value.        selector ~~ nil ifTrue: [ selector isSymbol ifFalse: [ self recordValidationError: (ar at: i + 1) , errorMessage , ' is not a symbol' versionString: versionString callSite: #validateDoIts:versionString:errorMessage: reasonCode: #invalidDoItSelector ] ] ]mergeImportLoads: aLoadList  self projectReference mergeImportLoads: aLoadListworkingCopyNameFor: anMCLoader  | vi |  (vi := anMCLoader currentVersionInfoFor: self) == nil ifTrue: [ ^nil ].  ^vi nameconfigurationRepository  ^configurationRepositorylabel  ^super label , ' >> ' , self spec preLoadDoIt value asStringfetchPackage: aLoaderPolicy  self fetchUsing: (self loader           loaderPolicy: aLoaderPolicy;           yourself)setUpConfigurationNextedIssue84dkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfNestedIssue84-dkh.2'.  className := #ConfigurationOfNestedIssue84.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version10NestedIssue84:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10NestedIssue84:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionNumberClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionNumberClass) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfopreLoadDoItForProject: aSymbol  self preLoadDoItForSpec: aSymbolupdateRepositories  projectClass  ^MetacelloMCProjectversion  self subclassResponsibilityprintString  ^String streamContents: [:s |  self printOn: s ]repositoryForPackage: aString username: username password: password  self repositoryForSpec: aString username: username password: passwordapplyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock  mergeBlock value: selfignoreImage  self addStatement: #ignoreImage: args: {true}versionString  ^versionStringbaseline30Foo: spec  < version: '3.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: [ spec                 preLoadDoIt: #preloadDoIt;                 file: 'GoferFoo-lr.1' ];           package: 'GoferBar' with: 'GoferBar.branch-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           yourself ]repositories  repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].  ^repositoriesdirectivesDo: aBlock  aBlock value: selfprojectReferenceSpecClass  ^MetacelloProjectReferenceSpecmodifications  modifications ifNil: [ modifications := Dictionary new ].  ^modificationstestSemanticVersioning  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2+build.0').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0+build.0').  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0-1').  self validateSemanticVersionStrings: #('1.0.0-1' '1.0.0+alpha').  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0+1').  self validateSemanticVersionStrings: #('1.0.0+alpha' '1.0.0+1').  self validateSemanticVersionStrings: #('1.0.0--' '1.0.0-a').  self validateSemanticVersionStrings: #('1.0.0+-' '1.0.0+a').  self validateSemanticVersionStrings: #('1.0.0-rc.1' '1.0.0' '1.0.0+build.1').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2+build.3').  self validateSemanticVersionStrings: #('1.0.0-rc.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2+build.2').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0' '1.0.0+build.0').  self validateSemanticVersionStrings: #('1.0.0+10000' '1.0.0+a').  self validateSemanticVersionStrings: #('1.0.0-10000' '1.0.0-a')aboutToCopy  calculate: aConfig project: aProject  | versionMap symbolicVersionMap executionBlock pragmaDict |  self setProject: aProject.  self configuration: aConfig.  versionMap := Dictionary new.  symbolicVersionMap := Dictionary new.  executionBlock := self specResolverBlock.  self collectAllVersionsFromVersionPragmasInto: versionMap using: executionBlock.  pragmaDict := self extractVersionImportPragmas.  self verifyVersionImportPragmas: pragmaDict definedIn: versionMap.  self collectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict.  self collectAllSymbolicVersionsFromVersionPragmasInto: symbolicVersionMap using: self symbolicVersionResolverBlock.  self project map: versionMap.  self project errorMap: self errorMap.  self project symbolicVersionMap: symbolicVersionMap.  self project configuration: aConfig.  self collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractDefaultSymbolicVersionPragmas into: symbolicVersionMap using: self defaultSymbolicVersionResolverBlock.  self collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractCommonDefaultSymbolicVersionPragmas into: symbolicVersionMap using: self commonDefaultSymbolicVersionResolverBlock.  symbolicVersionMap copy keysAndValuesDo: [:symbolic :original |  | versionString visited |        versionString := original.        visited := Set new.        [ visited add: versionString.        versionString isSymbol and: [ versionString ~~ #notDefined ] ] whileTrue: [ versionString := symbolicVersionMap at: versionString ifAbsent: [ self error: 'Cannot resolve symbolic version ' , original printString ].              (visited includes: versionString) ifTrue: [ self error: 'Loop detected resolving symbolic version ' , original printString ] ].        symbolicVersionMap at: symbolic put: versionString ]resolveToLoadableSpecs  self versionSpec resolveToLoadableSpecs: required forLoad: true map: packagesrepositoryForRepositories: anObject  self repositoryForSpec: anObjectspec: aMetacelloSpec  spec := aMetacelloSpecpostLoadDoItForPackage: aSymbol  self postLoadDoItForSpec: aSymbolprepostLoadsDo: aBlock  self preloads do: [:directive |  directive prepostLoadDo: aBlock ].  self loadDirectives do: [:directive |  directive prepostLoadDo: aBlock ].  self postloads do: [:directive |  directive prepostLoadDo: aBlock ]handleResolutionFor: aScriptEngine  ^aScriptEngine handleLookupProjectSpec: selfdefaultRepositoryDescription  ^'http://smalltalkhub.com/mc/Pharo/MetaRepoForPharo30/main'setUpConfigurationOfProjectIssue171  | versionInfo |  versionInfo := self setUpConfigurationOfProjectIssue171dkh1.  versionInfo := self setUpConfigurationOfProjectIssue171dkh2: {versionInfo}repositorySpecs  repositories ifNil: [ ^#() ].  ^self repositories map valuesclassName: aString  super className: aString.  self projectPackage: nilproject  ^projectfileHandleOn: aPath  ^aPath asFileReferenceexludededValidations  exludededValidations == nil ifTrue: [ exludededValidations := self extractExcludedValidations ].  ^exludededValidationsversionString: aStringOrSymbol  versionString := aStringOrSymbollabel  ^super label , ' >> ' , self spec postLoadDoIt value asStringversion11: spec  < version: '1.1' imports: #('1.1-baseline')>  spec for: #common do: [ spec blessing: #beta.        spec           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1' ]authorForVersion: aBlockOrString  aBlockOrString setAuthorInMetacelloConfig: selfcanUpgradeTo: aProjectRegistration  (self hasLoadConflicts: aProjectRegistration) ifFalse: [ ^true ].  configurationProjectSpec ifNotNil: [ aProjectRegistration configurationProjectSpec ifNotNil: [ configurationProjectSpec copy ensureProjectLoaded.              ^configurationProjectSpec canUpgradeTo: aProjectRegistration configurationProjectSpec ] ].  baselineProjectSpec ifNotNil: [ aProjectRegistration baselineProjectSpec ifNotNil: [ baselineProjectSpec copy ensureProjectLoaded.              ^baselineProjectSpec canUpgradeTo: aProjectRegistration baselineProjectSpec ] ].  ^falseextractVersionImportPragmas  | aDict |  aDict := Dictionary new.  self extractPragmas: #version:imports: into: aDict.  ^aDictconfigurationClass: aClass  configurationClass := aClasshasVersion: versionString  ^versionString = 'baseline'setUp  super setUp.  self     setUpVersionReferences;     setUpMonticelloRepository;     setUpDependency;     setUpNewerDependencyblessingForVersion: aBlockOrString  aBlockOrString setBlessingInMetacelloConfig: selfsetUpConfigurationOfProjectIssue136dkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue136-dkh.2'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion10Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue136:) asString) .   (MCMethodDefinition className: className asString selector: 'version10Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue136:) asString) .   (MCMethodDefinition className: className asString selector: 'version11Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version11Issue136:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoonUpgrade: aBlock  self options at: #onUpgrade put: aBlockreleaseVersion11PharoOnly  ^Lesson title: 'Release version 1.1 (#pharo only)' lesson: '"	1. Create configuration	2. Prepare to modify the version method for version 1.1:	3. Change the blessing to #release for the #pharo attribute	4. Compile and validate the #version11: method .	5. Remove version 1.0 from the definition of the #development symbolic version	6. Compile and validate the #development: method	7. Prepare to define the symbolic version method #stable:	8. Define version 1.1 as the #stable symbolic version for #common	9. Compile and validate the #stable: method"	"1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		modifyVersionMethodForVersion: ''1.1''			versionSpecsDo: [ :attribute :versionSpec | 					attribute == #pharo"3."						ifTrue: [ versionSpec blessing: #release ].					true ];"4."		commitMethod;"5."		modifySymbolicVersionMethodFor: #development			symbolicVersionSpecsDo: [ :symbolicVersionSpec | symbolicVersionSpec attribute ~~ #pharo ];"6."		commitMethod;"7."		modifySymbolicVersionMethodFor: #stable symbolicVersionSpecsDo: [ :symbolicVersionSpec | true ];"8."		addSymbolicSection: #pharo version: ''1.1'';"9."		commitMethod."After evaluating the above expression, take a look at the generated methods:	#version11:	#development:	#stable: "	ProfStef next.'evalDoits  evalDoits == nil ifTrue: [ evalDoits := false ].  ^evalDoitsbypassGoferLoadUpdateCategories  bypassGoferLoadUpdateCategories == nil ifTrue: [ bypassGoferLoadUpdateCategories := false ].  ^bypassGoferLoadUpdateCategoriespushExplicitLoadDirectivesDuring: aBlock for: aLoader  | directive |  directive := MetacelloExplicitLoadDirective loader: aLoader.  self pushLoadDirective: directive during: aBlock.  ^directiveversionSpec  ^versionSpecsetUpConfigurationOfProjectInfinite  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectInfinite-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline40ProjectInfinite:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectInfinite)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())attributePath  | path |  path := MetacelloMethodSectionPath with: self attributes.  ^self parent == nil ifTrue: [ path ] ifFalse: [ self parent attributePath , path ]removeProjectForVersion: aString  | spec |  spec := self project projectReferenceSpec     name: aString;     yourself.  self root packages remove: specshouldBeMutable  self isMutable ifTrue: [ ^self ].  self error: 'Not allowed to modify an immutable object'primeRegistryFromImage: configurationClasses baselineClasses: baselineClasses prioritizeConfiguration: prioritizeConfiguration  baselineClasses do: [:cl |  (self baselineRegistry includesKey: cl name asString) ifFalse: [ (self primeRegistryCurrentVersionFor: cl) ifNotNil: [:version |  | projectSpec |                    projectSpec := (version project projectSpec                       name: (MetacelloScriptEngine baseNameOf: cl name asString);                       repositories: version project projectPackage repositories copy;                       yourself) asBaselineProjectSpec.                    self primeRegisterLoadedProjectSpec: projectSpec ] ] ].  configurationClasses do: [:cl |  (self configurationRegistry includesKey: cl name asString) ifFalse: [ (self primeRegistryCurrentVersionFor: cl) ifNotNil: [:version |  | projectSpec repos projectPackage project |                    project := version project.                    projectPackage := project projectPackage.                    repos := nil.                    projectPackage ~~ nil ifTrue: [ repos := projectPackage repositories copy ].                    projectSpec := (version project projectSpec                       name: (MetacelloScriptEngine baseNameOf: cl name asString);                       className: cl name asString;                       versionString: version versionString;                       repositories: repos;                       yourself) asConfigurationProjectSpec.                    (prioritizeConfiguration or: [ (self primeRegistryProjectSpecRegistered: projectSpec) not ]) ifTrue: [ self primeRegisterLoadedProjectSpec: projectSpec ] ] ] ]authorName: aString  Author fullName: aStringasBaselineProjectSpec  ^self copyForScriptingInto: (MetacelloMCBaselineOfProjectSpec for: self project asBaselineProject)lesson03  mutable  mutable := truepackageNameMap  packageNameMap == nil ifTrue: [ packageNameMap := Dictionary new ].  ^packageNameMapversionNumberClass  ^MetacelloVersionNumberdefaultVersion1  ^self versionClass fromString: '1.0.0'isSomethingLoaded: somethingLoadedBlock  (self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints #somethingLoaded)) ifTrue: [ aPackageIsLoaded ifTrue: [ somethingLoadedBlock value: #somethingLoaded ] ]version: aVersionString ifAbsent: aBlock  ^[ self version: aVersionString ] on: MetacelloVersionDoesNotExistError do: [:ex |  aBlock value ]visited: anIdentitySet  visited := anIdentitySethandleDowngrade: exception  ^(self options at: #onDowngrade ifAbsent: [ ^exception pass ]) cull: exception cull: exception existingProjectRegistration cull: exception newProjectRegistrationcreateConfiguration: baseName  | configurationName |  configurationName := (baseName beginsWith: 'ConfigurationOf') ifTrue: [ baseName ] ifFalse: [ 'ConfigurationOf' , baseName ].  (Smalltalk includesKey: configurationName asSymbol) ifFalse: [ self ensureMetacello.        MetacelloPlatform current copyClass: (MetacelloPlatform current globalNamed: #MetacelloConfigTemplate) as: configurationName asSymbol inCategory: configurationName asString.        MetacelloPlatform current registerPackageNamed: configurationName ].  ^(MetacelloPlatform current globalNamed: configurationName asSymbol) projectallPackagesForSpecNamed: aStringOrArray  ^self allPackagesForSpecNamed: aStringOrArray ifAbsent: [ ^#() ]applyArgsToProjectSpec: aProjectSpec  classNameArg ifNotNil: [ aProjectSpec className: classNameArg ].  versionArg ifNotNil: [ aProjectSpec versionString: versionArg ].  repositoryArg ifNotNil: [ aProjectSpec repository: repositoryArg ].  ^aProjectSpectestSelfHostedLocation  | repository |  repository := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo:master/src'.  self     assert: repository hostname equals: 'git.pharo.org';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assert: repository repoPath equals: 'src';     assert: repository sshPort isNil.  repository := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo:master'.  self     assert: repository hostname equals: 'git.pharo.org';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assertEmpty: repository repoPath;     assert: repository sshPort isNil.  repository := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo'.  self     assert: repository hostname equals: 'git.pharo.org';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assertEmpty: repository repoPath;     assert: repository sshPort isNilsetUp  super setUp.  MetacelloPlatform current clearPackageCache.  registry := MetacelloProjectRegistration registry.  self setUpRepositories.  self setUpRepositoryContents.  MetacelloProjectRegistration resetRegistry.  initialWorkingCopyList := MCWorkingCopy allManagers collect: [:each |  each packageName ].  self disableUndefinedSymbolTracking ifTrue: [ undefinedSymbols := MetacelloPlatform current disableUndefinedSybolUpdates ]pushProject: aBlock  | oldGroups oldPackages oldProjects |  oldGroups := groups.  oldPackages := packages.  oldProjects := projects.  groups := Set new.  packages := Set new.  ^aBlock ensure: [ groups := oldGroups.        packages := oldPackages.        projects := oldProjects ]testAddPackageA  | packages package |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages add: (self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           includes: 'AndIncludedPackage';           answers: #(#('postload' 'postload answer'));           file: 'Package-dkh.2';           yourself).  package := packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: package name equals: 'Package'.  self assert: package requires equals: #('AndAnotherPackage').  self assert: package includes equals: #('AndIncludedPackage').  self assert: package answers equals: #(#('postload' 'postload answer')).  self assert: package file equals: 'Package-dkh.2'.  self assert: package preLoadDoIt value identicalTo: nil.  self assert: package postLoadDoIt value identicalTo: nilconfigHasVersionString  ^falsename: aString  ((aString at: 1) isSeparator or: [ (aString at: aString size) isSeparator ]) ifTrue: [ self error: 'Names are not allowed to have leading or trailing blanks: ' , aString printString ].  self shouldBeMutable.  name := aStringtestVersion05  | v1 v2 |  v1 := self versionClass fromString: '3.0.0'.  v2 := self versionClass fromString: '2.0.0'.  self assert: v1 > v2extensionMethods  ^#()versionStringForVersion: anObject  self versionStringForProject: anObjectconfigMethodOn: aStream indent: indent  aStream nextPutAll: self class name asString , ' member: ('.  self spec configMethodOn: aStream indent: indent.  aStream nextPutAll: ')'explicitLoadUsing: aLoaderDirective gofer: aGofer  aLoaderDirective loadLinearLoadDirective: self gofer: aGoferblueplane: projectName  self repository: 'http://squeaksource.blueplane.jp/' , projectNameconfigMethodCascadeOn: aStream last: lastCascade indent: indent  self spec configMethodCascadeOn: aStream member: self last: lastCascade indent: indentbaseline15ProjectFie: spec  < version: '1.5'>  spec for: #common do: [ spec configuration: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.5';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]baselineIssue399: spec  < baseline>  spec for: #common do: [ spec description: self className , '>>baselineIssue399:'.        spec package: 'Issue399-Core' ]setUpConfigurationOfLinearFoo  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfLinearFoo-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self linearProjectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline20Foo:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'version20Foo:' category: 'cat' timeStamp: '' source: self version20MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'version50Foo:' category: 'cat' timeStamp: '' source: self version50MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'version51Foo:' category: 'cat' timeStamp: '' source: self version51MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'baseline60Foo:' category: 'cat' timeStamp: '' source: self baseline60MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'baseline61Foo:' category: 'cat' timeStamp: '' source: self baseline61MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'baseline62Foo:' category: 'cat' timeStamp: '' source: self baseline62MethodSourceFoo)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())applyToList: aListSpec  aListSpec merge: selfisSomethingLoaded  ^self spec isSomethingLoadedversion50Issue119: spec  < version: '5.0' imports: #('4.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '1.0'.        spec package: 'GoferBar' with: 'GoferBar-jf.1' ]directoryFromPath: adirectoryPath relativeTo: anotherDirectoryPath  ^anotherDirectoryPath directoryNamed: adirectoryPathsetUpConfigurationOfProjectIssue119dkh3: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.3'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion30Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion30Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version30Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoaddToMetacelloRepositories: aMetacelloRepositoriesSpec  aMetacelloRepositoriesSpec addMember: (aMetacelloRepositoriesSpec addMember           name: self name;           spec: self;           yourself)timestamp: aBlockOrStringOrDateAndTime constructor: aVersionConstructor  aVersionConstructor timestampForVersion: aBlockOrStringOrDateAndTimeon: aConfig  | cacheKey |  cacheKey := aConfig class.  project := MetacelloPlatform current stackCacheFor: #versionConstructor at: cacheKey doing: [:cache |  self calculate: aConfig project: nil.        cache at: cacheKey put: self project ].  self setProject: projectbaselineOfProjectSpecClass  ^self subclassResponsibilitysetUpConfigurationOfSymbolic  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfSymbolic-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'stableVersionD:' category: 'cat' timeStamp: '' source: self stableVersionDMethodSourceSymbolic) .   (MCMethodDefinition className: className asString selector: 'version40Symbolic:' category: 'cat' timeStamp: '' source: self version40SymbolicMethodSourceSymbolic) .   (MCMethodDefinition className: className asString selector: 'version41Symbolic:' category: 'cat' timeStamp: '' source: self version41SymbolicMethodSourceSymbolic) .   (MCMethodDefinition className: className asString selector: 'version42Symbolic:' category: 'cat' timeStamp: '' source: self version42SymbolicMethodSourceSymbolic) .   (MCMethodDefinition className: className asString selector: 'version43Symbolic:' category: 'cat' timeStamp: '' source: self version43SymbolicMethodSourceSymbolic)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())packageFilename  ^packageFilenamepackages: anObject  packageList := anObjectfuelMetalevel: spec  spec project: 'FuelMetalevel' with: [ spec           repository: 'http://ss3.gemstone.com/ss/Fuel';           className: 'ConfigurationOfFuel';           loads: #FuelMetalevel ]testSemanticVersioningSpecItem12  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0-rc.1+build.1' '1.0.0' '1.0.0+0.3.7' '1.3.7+build' '1.3.7+build.2.b8f12d7' '1.3.7+build.11.e0f985a')version50Umbrella: spec  < version: '5.0'>  spec for: #common do: [ spec           project: 'Umbrella' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '5.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]versionOrNil  ^[ self version ] on: MetacelloVersionDoesNotExistError do: [:ex |  ^nil ]downloadJSONTags  | tagsUrl jsonObject |  tagsUrl := self projectTagsUrlFor: self projectPath.  jsonObject := MetacelloPlatform current downloadJSON: tagsUrl eTagsCache: self class eTagsCache eTagsKey: self projectPath username: self class siteUsername pass: self class sitePassword.  ^self normalizeTagsData: jsonObjectcreateVersionSpec: versionString  | versionSpec |  versionSpec := project versionSpec.  versionSpec versionString: versionString.  ^versionSpecprojectSpecs  ^self configurationProjectSpecs , self baselineProjectSpecssetUpBaselineGithubReferenceIV  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefIV-dkh.1'.  className := #BaselineOfGithubRefIV.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationGithubReferenceX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoloadDirective  loadDirective == nil ifTrue: [ loadDirective := MetacelloLinearLoadDirective new ].  ^loadDirectiveregisterProjectRegistration: aMetacelloProjectRegistration  aMetacelloProjectRegistration configurationProjectSpec copy ifNotNil: [:spec |  self configurationRegistry at: spec className ifPresent: [:existing |  (existing configurationProjectSpec registrationsCompareEqual: spec) ifFalse: [ MetacelloNotification signal: 'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString , ' REPLACED BY ' , aMetacelloProjectRegistration printString ] ].        spec versionOrNil ifNotNil: [:version |  spec versionString: version versionString ].        aMetacelloProjectRegistration configurationProjectSpec: spec.        (aMetacelloProjectRegistration respondsTo: #versionInfo) ifTrue: [ aMetacelloProjectRegistration versionInfo setVersionString: spec versionString ].        spec immutable.        self configurationRegistry at: spec className put: aMetacelloProjectRegistration ].  aMetacelloProjectRegistration baselineProjectSpec ifNotNil: [:spec |  self baselineRegistry at: spec className ifPresent: [:existing |  (existing baselineProjectSpec registrationsCompareEqual: spec) ifFalse: [ MetacelloNotification signal: 'REGISTRATION OF INCOMPATABLE PROJECTS: ' , existing printString , ' REPLACED BY ' , aMetacelloProjectRegistration printString ] ].        (aMetacelloProjectRegistration respondsTo: #versionInfo) ifTrue: [ aMetacelloProjectRegistration versionInfo setVersionString: spec repositoryVersionString ].        spec immutable.        self baselineRegistry at: spec className put: aMetacelloProjectRegistration ].  aMetacelloProjectRegistration immutabledescription  ^'The version ' , self versionString printString , ' is not defined in ' , self project label , ' for the current platform, because an exception occurred while creating the version:. ' , self exception description , '. Evaluate the following to see the error: ''[' , self project configuration class name asString , ' project ] 	on: MetacelloErrorInProjectConstructionNotification 	do: [:ex | ex resume: true ].''' , 'Possible versions include: ' , self possibleVersions printStringdetermineCurrentVersionForLoad  | prjct version currentVersion cvs |  self projectClass == nil ifTrue: [ ^nil ].  (version := self versionOrNil) == nil ifTrue: [ ^nil ].  version blessing == #baseline ifTrue: [ ^version ].  self loader ignoreImage ifTrue: [ ^version ].  prjct := self projectClass new project.  prjct loader: self loader.  (currentVersion := prjct currentVersion) == nil ifTrue: [ ^nil ].  (cvs := currentVersion versionStatus) == #somethingLoaded ifTrue: [ ^nil ].  (#(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints) includes: (cvs := currentVersion versionStatus)) ifTrue: [ (currentVersion perform: self operator with: version) ifTrue: [ ^currentVersion ].        ^nil ].  version = currentVersion ifTrue: [ ^currentVersion ].  (MetacelloProjectSpecLoadConflict projectSpec: self) signal: 'Project load conflict for' , prjct label printString , ' between current version ' , currentVersion printString , '(' , cvs asString , ') and specified version ' , version printString , '. Press resume to continue with load anyway'.  ^nilfiletreeDirectory: directoryName  self repository: 'filetree://' , directoryNamespec: aMetacellVersionSpec  spec := aMetacellVersionSpecoperator  operator == nil ifTrue: [ ^#= ].  ^operatortestBaselineOrConfigurationName  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: cli baselineOrConfigurationName equals: 'BaselineOfMineSweeper'.  cli := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self assert: cli baselineOrConfigurationName equals: 'ConfigurationOfFoo'setFor: attributeList do: aBlock  | methodSection |  methodSection := MetacelloVersionMethodSection new     attributes: attributeList asMetacelloAttributeList;     block: aBlock;     yourself.  currentSection ~~ nil ifTrue: [ currentSection addMethodSection: methodSection ] ifFalse: [ self methodSections add: methodSection ]register  | spec |  self setDefaultsAndValidate: self projectSpec copy.  spec := self projectSpec.  MetacelloProjectRegistration registrationForProjectSpec: spec ifAbsent: [:new |  new registerProject ] ifPresent: [:existing :new |  existing copyOnWrite: [:existingCopy |  existingCopy merge: new ] ].  self root: speccopyForScriptingInto: aProjectSpec  ^aProjectSpec     setName: name;     className: className;     versionString: versionString;     operator: operator;     setLoads: loads;     preLoadDoIt: preLoadDoIt;     postLoadDoIt: postLoadDoIt;     repositories: repositories copy;     file: filecompareEqual: aMetacelloProjectSpec  ^(super compareEqual: aMetacelloProjectSpec) and: [ self repositories compareEqual: aMetacelloProjectSpec repositories ]packageFileSpecFor: aMetacelloPackagesSpec  ^aMetacelloPackagesSpec project projectReferenceSpec     name: self name;     projectReference: self copy;     yourselfversion124ProjectToolBox: spec  < version: '1.2.4' imports: #('1.2.4-baseline')>  spec for: #common do: [ spec repository: 'http://www.example.com/ac' ]projectPath: anObject  projectPath := anObjectdoingLoads: aBlock  aBlock valuetimestampForVersion: aBlockOrStringOrDateAndTime  aBlockOrStringOrDateAndTime setTimestampInMetacelloConfig: selfcurrentVersionInfoFor: packageSpec  ^self loadData currentVersionInfoFor: packageSpec ifAbsent: [ super currentVersionInfoFor: packageSpec ]collection: aCollection do: aBlock displaying: aString  self bypassProgressBars ifTrue: [ ^super collection: aCollection do: aBlock displaying: aString ].  aCollection do: aBlock displayingProgress: aStringsetUpBaselineGithubReferenceIX  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefIX-dkh.1'.  className := #BaselineOfGithubRefIX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationGithubReferenceIV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceIV:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoversionReferences  ^versionReferencesproject  ^projectreadStreamOn: aFileHandle do: aBlock  | stream |  stream := aFileHandle readStream.  ^[ aBlock value: stream ] ensure: [ stream close ]< aMetacelloVersionNumber  aMetacelloVersionNumber species = self species ifFalse: [ ^false ].  ^self compareLessThan: aMetacelloVersionNumbercompiler  ^self class compilerdefaultPlatformAttributes  | attributes versionString |  ((Smalltalk respondsTo: #image) and: [ Smalltalk image respondsTo: #metacelloPlatformAttributes ]) ifTrue: [ ^Smalltalk image metacelloPlatformAttributes ].  attributes := OrderedCollection with: #squeakCommon with: #pharo.  Smalltalk at: #SystemVersion ifPresent: [:cl |  versionString := cl current version.        (((versionString beginsWith: 'Pharo-1') or: [ versionString beginsWith: 'PharoCore1' ]) or: [ versionString beginsWith: 'Pharo1' ]) ifTrue: [ attributes add: #'pharo1.x'.              ((versionString beginsWith: 'Pharo-1.0') or: [ versionString beginsWith: 'PharoCore1.0' ]) ifTrue: [ attributes add: #'pharo1.0.x' ] ifFalse: [ ((versionString beginsWith: 'Pharo-1.1') or: [ versionString beginsWith: 'Pharo1.1' ]) ifTrue: [ attributes add: #'pharo1.1.x' ] ifFalse: [ ((versionString beginsWith: 'Pharo-1.2') or: [ versionString beginsWith: 'Pharo1.2' ]) ifTrue: [ attributes add: #'pharo1.2.x' ] ifFalse: [ (versionString beginsWith: 'Pharo1.3') ifTrue: [ attributes add: #'pharo1.3.x' ] ] ] ] ] ].  ^attributestestCopyTo  | repositories |  repositories := self repositoriesSpec.  repositories add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  self should: [ repositories copy: 'http://example.com/repository' to: (self repositorySpec                 description: 'http://example.com/alternate/repository';                 yourself) ] raise: ErrorscheduleFetchFor: packageSpec externalReference: reference  ^self scheduleFetchFor: packageSpec reference: reference message: 'Fetched -> ' , reference name , ' --- ' , reference repository repositoryDescription , ' --- ' , reference repository descriptionlinearLoadPackageSpecs: packageSpecs repositories: repositories  | gofer |  gofer := MetacelloGofer new.  repositories do: [:repo |  gofer repository: repo ].  packageSpecs do: [:pkg |  pkg loadUsing: self gofer: gofer ]setUpIssue156ConfigurationOfGoo  | reference className definitionArray |  reference := GoferVersionReference name: 'ConfigurationOfGoo-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString selector: 'baselineGoo300Issue156Configuration:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGoo300Issue156Configuration:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineGoo400Issue156Configuration:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGoo400Issue156Configuration:) asString) .   (MCMethodDefinition className: className asString selector: 'baselineGoo500Issue156Configuration:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGoo500Issue156Configuration:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())postLoadDoIt: aSymbol constructor: aVersionConstructor  aVersionConstructor postLoadDoItForProject: aSymbolcreateTonelRepository: aRepositorySpec  | cl description headerSize |  cl := Smalltalk at: #TonelRepository.  description := aRepositorySpec description.  headerSize := (aRepositorySpec type , '://') size.  ^cl new     directory: (self fileHandleOn: (aRepositorySpec description copyFrom: headerSize + 1 to: description size));     yourselfmergeMap  ^Dictionary newpackageNamed: aString  ^self packageNamed: aString ifAbsent: [ nil ]recordValidationError: aString versionString: versionString callSite: callSite reasonCode: aSymbol  < haltOrBreakpointForTesting>  (self errorReasonCodes includes: aSymbol) ifFalse: [ self error: 'Unknown error reason code' ].  ((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol) ifTrue: [ ^self ].  (self debug includes: #error) ifTrue: [ self halt: 'Debug triggered for error: ' , aString ].  self validationReport add: (MetacelloValidationError configurationClass: (self recurse ifTrue: [ self configurationClass ] ifFalse: [ nil ]) reasonCode: aSymbol callSite: callSite explanation: aString)baseline25Foo: spec  < version: '2.5-baseline'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #baseline.        spec           package: 'GoferFoo' with: [ spec requires: 'GoferFan' ];           yourself.        spec           project: 'GoferFan' with: [ spec                 className: 'MetacelloTestConfigurationOfAtomicFan';                 versionString: '2.0-baseline';                 loads: 'GoferFan';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]version118ProjectToolBox: spec  < version: '1.1.8-baseline' imports: #('1.0-baseline')>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec preLoadDoIt: #alternatePreloadForCore ] ]modifications: anObject  modifications := anObjectdetermineCurrentVersionForLoad  self subclassResponsibilityaLoadedProjectIsNotCurrent: aBoolean  aLoadedProjectIsNotCurrent := aBooleanversionStringForProject: anObject  self root versionString: anObjectextractNameFromFile  file == nil ifTrue: [ ^nil ].  ^(self loader nameComponentsFrom: self file) firstload  self explicitLoadUsing: self loadertestVersion14  self assert: (self versionClass fromString: '2.9.0-alpha02') < (self versionClass fromString: '2.9.0-alpha03')baseline11: spec  < version: '1.1-baseline' imports: #('1.0-baseline')>  spec for: #common do: [ spec project: 'UTF7' with: [ spec                 className: 'MetacelloVersionQueryMiscConfig';                 versionString: '1.0-baseline';                 loads: #('Misc-UTF7') ].        spec           group: 'Core' with: #('UTF7');           group: 'Tests' with: #('UTF7');           yourself ]includes: aCollection  self shouldNotImplementlesson12DoIts  ^Lesson title: 'Lesson 12 (DoIts)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version12:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #preloadForCore.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #postloadForCore:package:."Occassionally, you find that you need to perform an expression either before a package is loaded, orafter a package is loaded. To do that in Metacello, you can define a preLoadDoIt selector and a postLoadDoIt selector:"	(MetacelloTutorialConfig project version: ''1.2'') spec."If you open a Transcript and execute the following expression, you will see that the pre load andpost load methods were executed:"	(MetacelloTutorialConfig project version: ''1.2'') load."The pre/post load methods may take 0, 1 or 2 args. The loader is the first optional argument and the loaded packageSpec is the second optional argument."ProfStef next.'label  ^self versionString , ' [' , self projectLabel , ']'testBasicBleedingEdgeVersion  | project version expected actual |  project := self projectWith: #(#'platformVersion1.x').  version := project version: #bleedingEdge.  expected := 'spec blessing: #''baseline''.spec project: ''Example Project'' with: [		spec			className: ''MetacelloExampleProjectConfig'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'' ].'.  actual := version spec printString.  self assert: expected equals: actualcompareLessThan: myComponents other: otherComponents version: version  | mySize aSize commonSize count more |  mySize := myComponents size.  aSize := otherComponents size.  commonSize := mySize min: aSize.  count := 0.  more := true.  [ more and: [ count < commonSize ] ] whileTrue: [ (myComponents at: count + 1) = (otherComponents at: count + 1) ifTrue: [ count := count + 1 ] ifFalse: [ more := false ] ].  count < commonSize ifTrue: [ ^(myComponents at: count + 1) metacelloSemanticVersionComponentLessThan: (otherComponents at: count + 1) ].  mySize < aSize ifTrue: [ mySize = 0 ifTrue: [ #preRelease == version ifTrue: [ ^false ].              ^true ].        (myComponents at: commonSize) = (otherComponents at: commonSize) ifFalse: [ ^true ].        ^true ] ifFalse: [ mySize = aSize ifTrue: [ ^false ].        aSize = 0 ifTrue: [ #build == version ifTrue: [ ^false ].              ^true ].        (myComponents at: commonSize) = (otherComponents at: commonSize) ifFalse: [ ^false ].        ^true ]versionForProject: anObject  self versionStringForProject: anObjectremoveProject: aString  self root removeProject: aString constructor: selfdefaultAction  self checkAllowed.  ^super defaultActionversionOfIV: spec  < version: '0.9.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>baselineOfIV:'.        spec author: 'dkh'.        spec timestamp: '5/4/2012 14:16' ].  spec for: #custom do: [ spec baseline: 'ExternalX' with: [ spec repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]updateForSpawnMethod: sourceSpec  | nm |  nm := name.  self projectReference updateForSpawnMethod: sourceSpec.  super updateForSpawnMethod: sourceSpec.  name := nmtestForDoListAtrribute2Active  | project version expected actual |  project := self projectWith: #(#attribute2).  version := project version: '3.0-baseline'.  expected := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec 	project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec 	group: ''Core'' with: #(''Example Project'' );	group: ''Core'' with: #(''Extra Project'' ).'.  actual := version spec printString.  self assert: expected equals: actualsetUp  super setUp.  self     setUpMonticelloRepository;     setUpConfigurationOfFoo;     setUpConfigurationOfFeaux;     setUpConfigurationOfProjectFie;     setUpConfigurationOfProjectFee;     setUpConfigurationOfFum;     setUpConfigurationOfProjectFoe;     setUpConfigurationOfFan;     setUpConfigurationOfFix;     setUpIssue77;     setUpIssue95;     setUpConfigurationOfSymbolic;     setUpConfigurationOfProjectToolBox;     setUpConfigurationOfProjectIssue115;     setUpConfigurationOfProjectIssue136;     setUpConfigurationOfProjectIssue119;     setUpConfigurationOfProjectIssue171;     setUpConfigurationOfProjectIssue154;     setUpConfigurationOfProjectIssue156;     setUpIssue156ConfigurationOfProjectGoo;     setUpIssue156ConfigurationOfProjectSoo;     setUpConfigurationOfProjectFum;     setUpConfigurationOfProjectIssue125;     setUpConfigurationOfProjectIssue283;     yourselfcompareEqual: aMetacelloProjectSpec  | repositorySpecs anotherRepositorySpecs |  repositorySpecs := (self map values sort: [:a :b |  a description <= b description ]) collect: [:each |  each description ].  anotherRepositorySpecs := (aMetacelloProjectSpec map values sort: [:a :b |  a description <= b description ]) collect: [:each |  each description ].  ^repositorySpecs = anotherRepositorySpecsancestors  ^niladditions  additions ifNil: [ additions := Dictionary new ].  ^additionspostLoad31baseline  Smalltalk at: #GoferFar ifAbsent: [ self error: 'GoferFar should be loaded' ]import  ^importNameload: required  ^self execute: #load: args: {required}label  ^'Critical Warning'setUpConfigurationOfProjectIssue115dkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue115-dkh.2'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion10Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue115:) asString) .   (MCMethodDefinition className: className asString selector: 'version10Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue115:) asString) .   (MCMethodDefinition className: className asString selector: 'version11Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version11Issue115:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoversion10MetacelloExample: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #release.        spec package: 'GoferFoo' with: 'GoferFoo-lr.2' ]primeRegistryFromImage  self primeRegistryFromImage: falsepreLoadDoIt: anObject  anObject setPreLoadDoItInMetacelloSpec: selfstableVersionOfX: spec  < symbolicVersion: #stable>  spec for: #common version: '0.9.0'do: aBlock  1 to: self size do: [:index |  aBlock value: (self at: index) ]setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:reference |  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) with: (MCClassDefinition name: (reference packageName copyWithout: $-) asSymbol superclassName: #Object category: reference packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]testGroups  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--groups=core,tests').  self assertCollection: cli groups hasSameElements: #('core' 'tests')clearCurrentVersionCache  MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo)setBaseline: aString  | spec projectSpec |  projectSpec := self project baselineOfProjectSpec     name: aString;     className: 'BaselineOf' , aString;     yourself.  spec := self project projectReferenceSpec     name: aString;     projectReference: projectSpec;     yourself.  self root packages merge: spec.  ^projectSpecpostLoadDo: aBlock  aBlock value: selflesson14  configuration092Issue63: spec  < version: '0.9.2'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration092Issue63:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           package: 'GoferBar' with: [ spec                 file: 'GoferBar-lr.1';                 repository: 'dictionary://Metacello_Gofer_Test_Repository' ];           package: 'GoferFoo' with: [ spec                 file: 'GoferFoo-lr.2';                 requires: 'External';                 repository: 'dictionary://Metacello_Gofer_Test_Repository' ];           import: 'External' ]baselineVersion20Issue125: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec description: 'MetacelloConfigurationResource>>baselineVersion20Issue125:'.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo';           package: 'GoferBar' with: [ spec requires: 'GoferFoo' ];           yourself ]aLoadedPackageIsCurrent: aBoolean  aLoadedPackageIsCurrent := aBooleantestVersion05  | v1 v2 |  v1 := self versionClass fromString: '3'.  v2 := self versionClass fromString: '2'.  self assert: v1 > v2version133ProjectToolBox: spec  < version: '1.3.3-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository' ].  spec for: #level1_1 do: [ spec package: 'GoferBar' with: 'GoferBar-jf.1'.        spec for: #level2_1 do: [ spec package: 'GoferFoo' with: 'GoferFoo-lr.1'.              spec for: #level3_1 do: [ spec package: 'GoferFaux' with: 'GoferFaux-tg.30' ] ].        spec for: #level2_2 do: [ spec package: 'GeauxBar' with: 'GeauxBar.branch-lr.2'.              spec for: #level3_2 do: [ spec package: 'GeauxBeau' with: 'GeauxBeau-dkh.55' ] ] ].  spec for: #pharo do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository' ]latestVersionMatching: versionPatternString  ^nilallProjectsDo: aBlock withTraversedProjects: aCollection  self projects do: [:each |  (each version notNil and: [ (aCollection includes: each version) not ]) ifTrue: [ aCollection add: each version.              aBlock value: each version.              each version allProjectsDo: aBlock withTraversedProjects: aCollection ] ]setUpConfigurationOfProjectLoop  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectLoop-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline40ProjectLoop:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectLoop)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())package: aString overrides: aBlock constructor: aVersionConstructor  aVersionConstructor packageForVersion: aString overrides: aBlockoperatorForProject: anObject  self root operator: anObjectprojectVersionEscaped  | pv |  pv := self projectVersion.  (projectVersion includes: $/) ifTrue: [ ^pv copyReplaceAll: '/' with: '\/' ].  ^pvget  | spec projectPackage |  MetacelloProjectRegistration copyRegistryRestoreOnErrorWhile: [ self setDefaultsAndValidateProjectSpec.        spec := self projectSpec.        projectPackage := spec projectPackage.        projectPackage repositorySpecs do: [:repoSpec |  repoSpec createRepository flushForScriptGet ].        self cacheRepository ifNotNil: [:cacheRepository |  projectPackage loader loaderPolicy cacheRepository: cacheRepository ].        projectPackage load.        self root: (Smalltalk at: spec className asSymbol) project.        MetacelloProjectRegistration registrationForProjectSpec: spec ifAbsent: [:new |  new registerProject ] ifPresent: [:existing :new |  existing copyOnWrite: [:existingCopy |  spec copyForRegistration: existingCopy onWrite: [:specCopy |  specCopy ifNil: [ existingCopy merge: new ] ifNotNil: [ specCopy mergeScriptRepository: spec ] ] ] ] ]version05: spec  < version: '0.5'>  spec for: #common do: [ spec repository: 'http://www.example.com/Example'.        spec           package: 'Example-Core' with: 'Example-Core-anon.11';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1' ]getFile  ^filerequires: aCollection  aCollection setRequiresInMetacelloPackage: selfensureConfigurationLoaded: vrsn ensured: ensured  ^trueloads: aCollection  aCollection setLoadsInMetacelloProject: selfisBaselineOfProjectSpec  ^truehasConflictWithProjectSpec: projectSpec  ^projectSpec hasConflictWithBaselineSpec: selfcomputeVersionStatus  self spec computeVersionStatus: [:status |  ^status ].  ^#noStatusaddTo: aLoaderDirective  aLoaderDirective add: selfverify: packageName version: fileName  | externalCoreWorkingCopy x |  externalCoreWorkingCopy := MCWorkingCopy allManagers detect: [:wc |  wc packageName = packageName ].  self assert: (x := externalCoreWorkingCopy ancestors first name) equals: fileNamerepositoryDescriptions  ^self repositorySpecs collect: [:repoSpec |  repoSpec description ]defaultAction  ^nilexecute: statements  MetacelloPlatform current withMetacelloLoadSessionDo: [ super execute: statements ]setProject: aString withBlock: aBlock  | spec projectSpec |  projectSpec := self project projectSpec     name: aString;     yourself.  spec := self project projectReferenceSpec     name: aString;     projectReference: projectSpec;     yourself.  self root packages merge: spec.  self with: projectSpec during: aBlockresolveToLoadableSpec  ^self resolveProjectSpec resolveToLoadableSpecsetUpConfigurationOfConflict  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfConflict-dkh.1'.  className := #ConfigurationOfConflict.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'conflictOf20:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf20:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'conflictOf21:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf21:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'conflictOf10:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf10:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'conflictOf11:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf11:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'conflictOf12:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf12:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfolesson13  methodUpdateSelector  ^self subclassResponsibilitybaseline40MethodSourceProjectFee  ^(self class sourceCodeAt: #baseline40ProjectFee:) asStringhostname  ^hostnametempFileFor: aName suffix: aSuffixString  ^(FileLocator temp asFileReference / (FileReference newTempFilePrefix: aName suffix: aSuffixString) basename) fullNameroot: aMetacelloSpec  root := aMetacelloSpectimestamp: aBlockOrStringOrDateAndTime  self root timestamp: aBlockOrStringOrDateAndTime constructor: selfexecuteCollection: aCollection do: projectSpecBlock  self projectSpecsFromRepositoryArg do: [:projectSpec |  (aCollection includes: (MetacelloScriptEngine baseNameOf: projectSpec className)) ifTrue: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]projectSpecListBlock  ^[ MetacelloProjectRegistration projectSpecs ]bleedingEdge  ^nilrepository: aString username: username password: password  self repositories repository: aString username: username password: passwordcompareCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader  ^(MetacelloLookupProjectSpecForLoad new     projectSpec: self;     yourself) signal performCurrentVersionTestAgainst: self versionOrNil operator: anOperator targetVersionStatus: targetVersionStatus using: anMCLoadertestAddE  | repositories repository |  repositories := self repositoriesSpec.  repositories     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository'.  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  repository := repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: '/opt/gemstone/repository'.  self assert: repository type equals: 'directory'resolveToAllPackagesIn: aVersionSpec into: packages visited: visited  (self resolveProjectSpec resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:pkg |  packages at: pkg put: pkg ]stableVersion: spec  < symbolicVersion: #stable>  spec for: #'platformVersion1.x' version: '1.0'setAuthorWithString: aString  self root author: aStringcopySpec: pkgSpec with: gofer to: aRepository  | repository resolvedReference |  [ resolvedReference := pkgSpec goferLoaderReference resolveWith: gofer ] on: Error do: [:ignored |  ^nil ].  repository := MCRepositoryGroup default repositories detect: [:each |  each = aRepository ] ifNone: [ aRepository ].  repository storeVersion: resolvedReference version.  ^resolvedReference repositorytestDirectoryRepository  | project pkg repoSpec repo |  project := self project.  pkg := (project version: '1.0-baseline') packageNamed: 'Example-Core'.  repoSpec := pkg repositorySpecs first.  self assert: repoSpec type equals: 'directory'.  repo := repoSpec createRepository.  self assert: repo class identicalTo: MCDirectoryRepository.  self assert: repo description equals: self directoryForPlatformlesson07  resolveSpecsForPackageOrdering: aVersionSpec  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  self includes do: [:specName |  (aVersionSpec packageNamed: specName ifAbsent: [  ]) ifNotNil: [:pkgSpec |  packageOrProjectSpecs addAll: (pkgSpec resolveToPackagesIn: aVersionSpec andProjects: true visited: MetacelloVisitedPackages new) ] ].  ^packageOrProjectSpecsimpara: projectName  self repository: 'http://source.impara.de/' , projectNameloadUsing: aLoaderDirective gofer: aGofer  self loadDirectives isEmpty ifTrue: [ ^self ].  aLoaderDirective loadAtomicLoadDirective: self gofer: aGofercollection: aCollection do: aBlock displaying: aString  aCollection do: aBlockloadedPackages  | packages |  packages := OrderedCollection new.  self loadDirective packageDirectivesDo: [:directive |  packages add: directive file ].  ^packagesbaseline50MethodSourceFoo  ^(self class sourceCodeAt: #baseline50Foo:) asStringsetImport: anArray  importArray := importArray ifNil: [ anArray ] ifNotNil: [ importArray , anArray ]defaultAction  self existingProjectRegistration locked ifTrue: [ ^self useIncoming ].  ^MetacelloConflictingProjectError signal: 'Load Conflict between existing ' , self existingProjectRegistration printString , ' and ' , self newProjectRegistration printStringtestFtpRepository  | project pkg repoSpec repo |  project := self project.  pkg := (project version: '1.3-baseline') packageNamed: 'Example-Core'.  repoSpec := pkg repositorySpecs first.  self assert: repoSpec type equals: 'ftp'.  repo := repoSpec createRepository.  self assert: repo class identicalTo: MCFtpRepository.  self assert: repo host equals: 'ftp.example.com'.  self assert: repo directory equals: 'examples'difference: aMetacelloVersion  ^self spec difference: aMetacelloVersion specconfigMethodCascadeOn: aStream indent: indent  | repositorySpecs |  repositorySpecs := self map values sort: [:a :b |  a description <= b description ].  repositorySpecs size = 1 ifTrue: [ repositorySpecs first configMethodCascadeOn: aStream lastCascade: true ] ifFalse: [ 1 to: repositorySpecs size do: [:index |  | repositorySpec |              aStream tab: indent + 1.              (repositorySpecs at: index) configMethodCascadeOn: aStream lastCascade: index >= repositorySpecs size ] ]setFor: attributeList version: aString  attributeList asMetacelloAttributeList do: [:attribute |  self attributeMap at: attribute put: aString.        self addAttribute: attribute ]loadVersion: aVersionOrNil  | vrsn mcLoader list |  self ensureProjectLoaded.  vrsn := aVersionOrNil.  vrsn == nil ifTrue: [ [ vrsn := self version ] on: MetacelloVersionDoesNotExistError do: [:ex |  ^(MetacelloProjectSpecLoadError projectSpec: self)                 versionDoesNotExistException: ex;                 signal: 'No version found for ' , self versionString printString , ' of ' , self className asString , ' because: ' , ex description ] ].  mcLoader := self loader copy.  mcLoader operator: self operator.  vrsn loader: mcLoader.  list := (mcLoader ignoreImage ifTrue: [ self loadListForVersion: vrsn ] ifFalse: [ vrsn packageAndProjectNamesToLoad: (self loadListForVersion: vrsn) loader: mcLoader ]) asSet.  MetacelloPlatform current useStackCacheDuring: [:dict |  | projectCache cachedList |        projectCache := dict at: self projectClass ifAbsent: [ dict at: self projectClass put: Dictionary new ].        (cachedList := projectCache at: vrsn ifAbsent: [  ]) == nil ifTrue: [ projectCache at: vrsn put: list ] ifFalse: [ (cachedList size = list size and: [ cachedList allSatisfy: [:each |  list includes: each ] ]) ifTrue: [ ^self ] ifFalse: [ projectCache at: vrsn put: list ] ].        vrsn versionString ~= self versionString ifTrue: [ MetacelloNotification signal: ' [' , vrsn versionString , ']' ].        mcLoader preLoad: self.        vrsn fetchRequiredFromArray: list.        (MetacelloProjectSpecLoadedNotification new projectSpec: (self copy versionString: vrsn versionString)) signal.        mcLoader postLoad: self ] defaultDictionary: Dictionary newpreLoad: packageOrVersionSpec  (MetacelloDirective preLoadSpec: packageOrVersionSpec loader: self) addTo: self loadDirectivebaseline25ProjectFie: spec  < version: '2.5'>  spec for: #common do: [ spec configuration: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.5';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]projectClassMethodSource  ^(self class class sourceCodeAt: #project) asStringresetCacheGofer  cacheGofer := nilbaseline62ProjectIssue86: spec  < version: '6.2'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'A' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.2';                 loads: #('1');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'B' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.2';                 loads: #('2');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]requiredSpecsForPackageOrdering: aVersionSpec  ^self specs: self requires forPackageOrdering: aVersionSpecloadPostloadDirective: aPostloadDirective  self postloads add: aPostloadDirectivepostLoadDo: aBlock  aProjectNotLoaded  ^aProjectNotLoadedversion02: spec  < version: '0.2'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 file: 'Example-Core-anon.9';                 repository: 'http://www.example.com/Example' ] ]doLoad  self subclassResponsibilityvalidateVersionString: issues withDefaultVersionString: defaultVersionString  self versionString ifNil: [ defaultVersionString ifNotNil: [ self versionString: defaultVersionString ] ifNil: [ issues add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #incompleteProjectSpec callSite: #validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription: explanation: 'version field required') ] ]allProjects  | all |  all := OrderedCollection new.  self allProjectsDo: [:each |  all add: each ].  ^allpostLoadDoItForVersion: aSymbol  self postLoadDoItForSpec: aSymboldownloadBasicFile: url to: outputFileName username: username pass: pass  | out err proc errorFileName args |  errorFileName := self downloadErrorFileNameFor: outputFileName.  out := FileStream forceNewFileNamed: outputFileName.  err := FileStream forceNewFileNamed: errorFileName.  args := username ifNotNil: [ args := {'-u' .         (username , ':' , pass) .         '-L' .         url} ] ifNil: [ args := {'-L' .         url} ].  proc := (self class environment at: #OSProcess) thisOSProcess forkJob: '/usr/bin/curl' arguments: args environment: nil descriptors: (Array with: nil with: out with: err).  proc ifNil: [ (self class environment at: #OSProcess) noAccessorAvailable ].  [ proc isRunning ] whileTrue: [ (Delay forMilliseconds: 100) wait ].  out close.  err close.  ^errorFileNamelabel  ^self filedeleteFileNamed: filePath  (self fileDirectoryClass on: filePath) containingDirectory deleteFileNamed: (self fileDirectoryClass localNameFor: filePath)configMethodOn: aStream  self configMethodOn: aStream indent: 0loadPreloadDirective: aPreloadDirective  self preloads add: aPreloadDirectivetestCacheNil  | x |  self assert: (x := self cacheNil) identicalTo: nilinitialize  self     repositoryMap;     cacheRepository;     ensuredMap.  ignoreImage := falseupdateProject  ^self updateProject: MetacelloLoaderPolicy newcollectAllVersionsFromVersionImportPragmasInto: versionMap using: executionBlock satisfiedPragmas: pragmaDict  | defined done completed count |  done := false.  completed := IdentitySet new.  count := 0.  [ count := count + 1.  count > 10000 ifTrue: [ self error: 'Apparent loop in import expansion' ].  done ] whileFalse: [ done := true.        pragmaDict keysAndValuesDo: [:versionString :pragmaColl |  | versionSpec |              versionSpec := nil.              defined := false.              [ pragmaColl do: [:pragma |  (completed includes: pragma) ifFalse: [ | imports |                          done := false.                          imports := pragma argumentAt: 2.                          imports detect: [:importedVersion |  (versionMap includesKey: importedVersion) not ] ifNone: [ imports do: [:importedVersion |  | version |                                      (version := versionMap at: importedVersion ifAbsent: [  ]) ~~ nil ifTrue: [ defined := true.                                            completed add: pragma.                                            versionSpec == nil ifTrue: [ versionSpec := version spec copy ] ifFalse: [ versionSpec := versionSpec mergeSpec: version spec copy ].                                            versionSpec versionString: versionString.                                            executionBlock value: versionSpec value: pragma ] ] ] ] ] ] on: Error do: [:ex |  (MetacelloErrorInProjectConstructionNotification versionString: versionSpec versionString exception: ex) ifTrue: [ ^ex pass ] ifFalse: [ self errorMap at: versionSpec versionString put: ex.                          defined := false ] ].              defined ifTrue: [ | version importedVersions |                    importedVersions := OrderedCollection new.                    version := versionSpec createVersion.                    pragmaColl do: [:pragma |  importedVersions addAll: (pragma argumentAt: 2) ].                    version importedVersions: importedVersions.                    self validateVersionString: versionString againstSpec: versionSpec.                    versionMap at: versionSpec versionString put: version ].              self reset ] ]defaultAction  ^truebaseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: [ spec value: #baseline ].        spec description: [ spec value: 'Descriptive comment' ].        spec author: [ spec value: 'dkh' ].        spec timestamp: [ spec value: '10/7/2009 14:40' ].        spec timestamp: [ spec value: (DateAndTime fromString: '10/7/2009 14:40') ].        spec blessing: #baseline.        spec description: 'Descriptive comment'.        spec author: 'dkh'.        spec timestamp: (DateAndTime fromString: '10/7/2009 14:40').        spec timestamp: '10/7/2009 14:40'.        spec           preLoadDoIt: #preloadForVersion;           postLoadDoIt: #postloadForVersion.        spec repository: 'http://www.example.com/rr'.        spec repository: 'http://www.example.com/private' username: 'foo' password: 'bar'.        spec repositories: [ spec                 repository: '/opt/mc/repository';                 repository: 'c:\pharo\myapp\repo\';                 repository: 'ftp://ftp.example.com/repo';                 repository: 'dictionary://GlobalName';                 repository: 'http://www.example.com/rr';                 repository: 'http://www.example.com/ar';                 repository: 'http://www.example.com/private' username: 'foo' password: 'bar' ].        spec           project: 'UI Support' with: [ spec                 className: 'ConfigurationOfUI';                 versionString: '1.0';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 operator: #~>;                 loads: #('UI-Core');                 file: 'ConfigurationOfUI';                 repository: 'http://www.example.com/r' ];           project: 'UI Support' overrides: [ spec                 className: 'ConfigurationOfUINew';                 versionString: '1.0';                 operator: #>=;                 loads: #('UI-Core' 'UI-Tests');                 repository: 'http://www.example.com/r' username: 'foo' password: 'bar' ];           project: 'UI Tests' copyFrom: 'UI Support' with: [ spec                 className: 'ConfigurationOfUI';                 versionString: '1.0';                 operator: #~>;                 loads: #('UI-Core' 'UI-Tests');                 repository: 'http://www.example.com/r' ];           project: 'UI Support' with: '1.0.1';           removeProject: 'UI Tests';           project: 'UI Multi' with: [ spec                 className: 'ConfigurationOfMulti';                 repository: 'http://www.example.com/r';                 repository: 'http://www.example.com/s' ].        spec           package: 'Example-AddOn' with: [ spec                 requires: #('Example-Core');                 includes: #('Example-UI');                 file: 'Example-AddOn-anon.3';                 repositories: [ spec                       repository: 'http://www.example.com/yar';                       repository: 'http://www.example.com/yas' ];                 preLoadDoIt: #preloadForAddOn;                 postLoadDoIt: #postloadForAddOn ];           package: 'Example-AddOn' overrides: [ spec                 requires: #('Example-Core' 'UI Support');                 includes: #('Example-UI');                 file: 'Example-AddOn-anon.7';                 supplyingAnswers: #(#('list of packages' 'Kernel* Collection*'));                 repository: 'http://www.example.com/or' username: 'foo' password: 'bar';                 preLoadDoIt: #preloadForAddOn;                 postLoadDoIt: #postloadForAddOn ];           package: 'Example-AddOn' with: 'Example-AddOn-anon.5';           package: 'Example-Core';           package: 'Example-Tests' with: [ spec requires: #('Example-Core') ];           package: 'Example-TestsUI' with: [ spec requires: #('Example-UI') ];           package: 'Example-UI' with: [ spec requires: #('Example-AddOn') ];           removePackage: 'Example-Tests'.        spec           group: 'default' with: #('Example-Core' 'Example-AddOn');           group: 'default' overrides: #('Example-Core' 'Example-Tests');           removeGroup: 'default' ]actionLabel  ^'Loading 'testVersion04  | v1 v2 |  v1 := self versionClass fromString: '1.0.1'.  v2 := self versionClass fromString: '1.0.0'.  self assert: v1 > v2repository  ^self externalReference repositorydoSilently  ^truebaseline40MethodSourceFan  ^(self class sourceCodeAt: #baseline40Fan:) asStringprojectSpecSelectBlock  ^[:projectSpec |  true ]version  ^versiondefaultAction  ^falseloadLinearLoadDirective: aLoaderDirective gofer: aGofer  aLoaderDirective loadDirectives do: [:directive |  directive loadUsing: aLoaderDirective gofer: aGofer ].  aLoaderDirective finalizeLoad: aGoferbaseline40MethodSourceProjectFum  ^(self class sourceCodeAt: #baseline40ProjectFum:) asStringregistration  ^MetacelloProjectRegistration registrationForProjectSpec: self ifAbsent: [:ignored |   ] ifPresent: [:existing :new |  existing ]baselineProjectSpecIfPresent: presentBlock ifAbsent: absentBlock  ^baselineProjectSpec ifNotNil: [ presentBlock cull: baselineProjectSpec ] ifNil: absentBlockprojectSpecListBlock  ^[ MetacelloProjectRegistration configurationProjectSpecs ]package: packageName with: aBlockOrString constructor: aVersionConstructor  aVersionConstructor packageForVersion: packageName with: aBlockOrStringloadDirective  ^self loaderPolicy loadDirectiveclearPackageCache  | cache dir |  cache := self defaultPackageCache.  cache flushCache.  dir := cache directory.  dir ~~ nil ifTrue: [ [ self recursiveDelete: dir ] on: Error do: [:ignore |   ] ]addStatement: selector args: args  self statements add: selector -> argsasProjectRegistration  (self className beginsWith: 'BaselineOf') ifTrue: [ ^MetacelloProjectRegistration fromMCBaselineProjectSpec: self asBaselineProjectSpec ].  ^MetacelloProjectRegistration fromMCConfigurationProjectSpec: self asConfigurationProjectSpecsetUpLockConfigurations  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfLockConfigurations-dkh.1'.  className := #ConfigurationOfLockConfigurations.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'lockConfiguration10:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration10:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'lockConfiguration11:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration11:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'lockConfiguration12:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration12:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'lockConfiguration13:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration13:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'lockConfiguration14:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration14:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'lockConfiguration15:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration15:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfomergeMap  | map |  map := super mergeMap.  map at: #name put: name.  map at: #className put: className.  map at: #versionString put: versionString.  map at: #operator put: operator.  map at: #loads put: loads.  map at: #preLoadDoIt put: preLoadDoIt.  map at: #postLoadDoIt put: postLoadDoIt.  ^mapincrementPatchVersion  self size < 2 ifTrue: [ self at: 2 put: 0 ].  self size < 3 ifTrue: [ self at: 3 put: 0 ].  self incrementVersionAt: 3loadPackageDirective: aPackageLoadDirective gofer: aGofer  projectClass  ^MetacelloMCProjectaddVersion: version versionInfo: versionInfo resolvedReference: resolvedReference packageSpec: packageSpec  | vis |  (vis := self packageNameMap at: packageSpec name ifAbsent: [  ]) ~~ nil ifTrue: [ vis do: [:vi |  self dataMap removeKey: vi name.              self versionInfoMap removeKey: vi name ] ].  self dataMap at: version info name put: {version .         resolvedReference .         packageSpec}.  self versionInfoMap at: versionInfo name put: {versionInfo}.  self packageNameMap at: packageSpec name put: {versionInfo}packageDirectivesDo: aBlock  aBlock value: selftestVersion19  self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0')repositoryDescriptions  ^self repositorySpecs collect: [:repoSpec |  repoSpec description ]extractDefaultSymbolicVersionPragmas  | aDict |  aDict := Dictionary new.  self extractPragmas: #defaultSymbolicVersion: into: aDict.  ^aDicttestRemovePackageD  | packages removed |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages remove: 'Package'.  removed := false.  packages packageNamed: 'Package' ifAbsent: [ removed := true ].  self assert: removedreset  super reset.  methodSections := nilresolvedReference  ^resolvedReferencetestVersion12  self deny: (self versionClass fromString: '1.0.0') <= (self versionClass fromString: '0.7.0')reset  projectVersion  (projectVersion == nil or: [ projectVersion isEmpty ]) ifTrue: [ projectVersion := 'master' ].  ^projectVersionrecord  ^self doRecordRequiredFromArray: self spec defaultPackageNamesconfigMethodValueOn: aStream for: spec selector: selector last: last indent: indent  | valuePrintString |  spec == nil ifTrue: [ ^self ].  valuePrintString := spec value isSymbol ifTrue: [ '#' , spec value asString printString ] ifFalse: [ spec value printString ].  aStream     tab: indent;     nextPutAll: 'spec ' , selector , ' ' , valuePrintString , '.'.  last ifFalse: [ aStream cr ]packageForVersion: packageName with: aBlockOrString  aBlockOrString setPackage: packageName withInMetacelloConfig: selfspotterForVersionsFor: aStep  < spotterOrder: 1>  self flag: #maybeRewriteForDirectStreaming.  aStep listProcessor     title: 'Versions';     allCandidates: [ (#(stableVersion currentVersion bleedingEdge development) collect: [:each |  [ self perform: each ] on: Error do: [ nil ] ]) reject: [:each |  each isNil ] ];     itemName: [:version |  version versionString ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: trueprojectReference: anObject  projectReference := anObjectprojectLabel  ^'project'ancestors  | wc |  (wc := self workingCopy) ~~ nil ifTrue: [ wc ancestry ancestors isEmpty not ifTrue: [ ^wc ancestry ancestors ] ].  ^nilisSomethingLoadedAgainst: resolvedPackageAndProjectNames  (self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isSomethingLoaded: [:ignored |  ^true ].  ^falsesetUpConfigurationOfExternalXdkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternalX-dkh.2'.  className := #ConfigurationOfExternalX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'stableVersionOfX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #stableVersionOfX:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'unstableVersionOfX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #unstableVersionOfX:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfX090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfX090:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfX091:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfX091:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfosetUpIssue77D  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfIssue77D-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline10D:' category: 'cat' timeStamp: '' source: self baseline10MethodSourceD)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())projectPlatformAttributes  | list aBlock |  list := OrderedCollection new.  (aBlock := self projectAttributes) ~~ nil ifTrue: [ list addAll: aBlock value ].  ^self defaultPlatformAttributes , listversionDoesNotExistError: versionStringOrSymbol  ((Smalltalk at: #MetacelloSymbolicVersionDoesNotExistError) project: self project versionString: versionStringOrSymbol) signalblock  ^blockconfigurationClass  ^configurationClasstearDown  | aGofer finalWorkingCopyList diff |  aGofer := Gofer new.  self tearDownPackages: aGofer.  aGofer references notEmpty ifTrue: [ aGofer metacelloUnload ].  testingEnvironment removeKey: #Metacello_Gofer_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Alternate_Repository ifAbsent: [  ].  self tempRepositories do: [:repo |  MCRepositoryGroup default removeIdenticalRepository: repo ].  MetacelloPlatform current reenableUndefinedSybolUpdates: undefinedSymbols.  finalWorkingCopyList := MCWorkingCopy allManagers collect: [:each |  each packageName ].  diff := finalWorkingCopyList difference: initialWorkingCopyList.  diff do: [:leak |  self crTrace: 'leaked package from ' , self printString , ' -> ' , leak printString ].  self assertEmpty: diff.  super tearDownlesson08  ^Lesson title: 'Lesson 8' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version08:."In version 0.8 we''ve simply updated the package versions, which can be seen by comparing the results of loading version 0.7 and 0.8:"  (MetacelloTutorialConfig project version: ''0.7'') load.  (MetacelloTutorialConfig project version: ''0.8'') load.ProfStef next.'setUpBaselineOfExternalX  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfExternalX-dkh.1'.  className := #BaselineOfExternalX.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'externalBaselineX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalBaselineX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfolabel  self spec == nil ifTrue: [ ^'' ].  ^self spec labelbaseline40Fan: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]projectSpec: aProjectSpec  projectSpec := aProjectSpecbaseline62MethodSourceFoo  ^(self class sourceCodeAt: #baseline62Foo:) asStringresolveToLoadableSpec: aString forLoad: forLoad forMap: map packages: packageMap  | package |  package := self packageNamed: aString forLoad: forLoad forMap: map ifAbsent: [ ^self error: 'Name not found: ' , aString ].  packageMap at: package name put: package.  ^{package}setUpConfigurationOfProjectIssue95  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue95-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline40ProjectIssue95:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectIssue95)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())repositoryOverrides  ^(self options at: #repositoryOverrides ifAbsent: [ ^nil ]) collect: [:description |  (MetacelloMCProject new repositorySpec description: description) createRepository ]flushCache  | directory |  [ localRepository flushCache ] on: Error do: [:ex |  SystemNotification signal: 'Error for: ' , self description printString , ' during flushCache: ' , ex description printString ].  self class flushDownloadCache.  directory := self calculateRepositoryDirectory.  directory exists ifTrue: [ localRepository directory: directory ] ifFalse: [ localRepository resetDirectory ]compareLessThan: aMetacelloVersionNumber  | mySize aSize commonSize count more |  mySize := self size.  aSize := aMetacelloVersionNumber size.  commonSize := mySize min: aSize.  count := 0.  more := true.  [ more and: [ count < commonSize ] ] whileTrue: [ (self at: count + 1) = (aMetacelloVersionNumber at: count + 1) ifTrue: [ count := count + 1 ] ifFalse: [ more := false ] ].  count < commonSize ifTrue: [ ^(self at: count + 1) metacelloVersionComponentLessThan: (aMetacelloVersionNumber at: count + 1) ].  mySize < aSize ifTrue: [ mySize = 0 ifTrue: [ ^true ].        (self at: commonSize) = (aMetacelloVersionNumber at: commonSize) ifFalse: [ ^true ].        ^(aMetacelloVersionNumber at: commonSize + 1) isString not ] ifFalse: [ mySize = aSize ifTrue: [ ^false ].        aSize <= 0 ifTrue: [ ^false ].        (self at: commonSize) = (aMetacelloVersionNumber at: commonSize) ifFalse: [ ^false ].        ^(self at: commonSize + 1) isString ]configuration: aString with: aBlockOrString  self root configuration: aString with: aBlockOrString constructor: selffile  file == nil ifTrue: [ ^self name ].  ^filedecrementMinorVersion  self size < 2 ifTrue: [ self at: 2 put: 0 ].  self decrementVersionAt: 2parent: anObject  parent := anObjectabortMethod  project := project configuration class project.  methodSpec := nilproject: aString copyFrom: oldSpecName with: aBlock  self root project: aString copyFrom: oldSpecName with: aBlock constructor: selfstable: spec  < symbolicVersion: #stable>  spec for: #common version: '1.0'validateVersionSpec: versionSpec  versionSpec blessing value == #broken ifTrue: [ ^self ].  versionSpec projectDo: [:projectSpec |  | referencedProjectSpec |        projectSpec versionString == nil ifTrue: [ self recordValidationCriticalWarning: 'No version specified for the project reference ' , projectSpec name printString , ' in version ' , versionSpec versionString printString versionString: versionSpec versionString callSite: #validateVersionSpec: reasonCode: #noVersionSpecified ].        referencedProjectSpec := projectSpec referencedSpec.        versionSpec blessing value == #baseline ifTrue: [ referencedProjectSpec hasRepository ifTrue: [ (referencedProjectSpec file beginsWith: referencedProjectSpec className) ifFalse: [ self recordValidationCriticalWarning: 'The class name of project ' , referencedProjectSpec className printString , ' does not match the file name ' , referencedProjectSpec file printString , ' in version ' , versionSpec versionString printString versionString: versionSpec versionString callSite: #validateVersionSpec: reasonCode: #projectClassNameFileMismatch ] ] ifFalse: [ self recordValidationError: 'The specification for the project reference ' , projectSpec name printString , ' in version ' , versionSpec versionString printString , ' is missing the required repository field' versionString: versionSpec versionString callSite: #validateVersionSpec: reasonCode: #incompleteProjectSpec ] ].        referencedProjectSpec ensureProjectLoaded ifTrue: [ [ projectSpec version ] on: MetacelloVersionDoesNotExistError do: [:ex |  | explanation |                    explanation := projectSpec versionString == nil ifTrue: [ 'the default version' ] ifFalse: [ 'version ' , projectSpec versionString printString ].                    self recordValidationError: 'Cannot resolve ' , explanation , ' for the project reference ' , projectSpec name printString , ' in version ' , versionSpec versionString printString versionString: versionSpec versionString callSite: #validateVersionSpec: reasonCode: #cannotResolveVersion ] ] ] packageDo: [:packageSpec |  (packageSpec file beginsWith: packageSpec name) ifFalse: [ self recordValidationCriticalWarning: 'The name of package ' , packageSpec name printString , ' does not match the file name ' , packageSpec file printString , ' in version ' , versionSpec versionString printString versionString: versionSpec versionString callSite: #validateVersionSpec: reasonCode: #packageNameMismatch ].        packageSpec file = packageSpec name ifTrue: [ self recordValidationCriticalWarning: 'No version specified for the package ' , packageSpec name printString , ' in version ' , versionSpec versionString printString versionString: versionSpec versionString callSite: #validateVersionSpec: reasonCode: #noVersionSpecified ] ] groupDo: [:ignored |   ].  self validateBaselineVersionSpec: versionSpectestVersion15  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1.0-beta.1')testMergeGroupA  | packages group |  packages := self packagesSpec.  packages add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  packages merge: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself).  group := packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (group includes includes: 'Core').  self assert: (group includes includes: 'Tests')setUpRepositories  testAddF  | repositories repository |  repositories := self repositoriesSpec.  repositories     repository: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     repository: (self repositorySpec           description: 'http://example.com/repository';           username: 'DaleHenrichs';           password: 'secret';           yourself).  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  self assert: repository username equals: 'DaleHenrichs'.  self assert: repository password equals: 'secret'from: anObject  from := anObjectmergeSpec: anotherSpec  | newSpec map anotherRepositories |  newSpec := super mergeSpec: anotherSpec.  map := anotherSpec mergeMap.  (anotherRepositories := map at: #repositories) notEmpty ifTrue: [ newSpec repositories: (self repositories isEmpty ifTrue: [ anotherRepositories ] ifFalse: [ self repositories mergeSpec: anotherRepositories ]) ].  ^newSpecauthor  author == nil ifTrue: [ ^self project valueHolderSpec           value: '';           yourself ].  ^authortestBaseline10ResolveToLoadableSpecs01  | project version expected list |  project := self project.  version := project version: '1.0-baseline'.  expected := #('UTF8').  list := version resolveToLoadableSpecs: #('UTF8').  self assert: list size equals: expected size.  list do: [:pkg |  self assert: (expected includes: pkg name) ].  expected := #('UTF8').  list := version resolveToLoadableSpecs: #('Recursive').  self assert: list size equals: expected size.  list do: [:pkg |  self assert: (expected includes: pkg name) ]fetchRecord: fetchRecordBlock required: required  MetacelloProjectRegistration copyRegistryWhile: [ self handleNotificationsForAction: [ | version loadedSpec |              self setDefaultsAndValidateProjectSpec.              [ loadedSpec := self lookupProjectSpecFor: self projectSpec ] on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade do: [:notification |  notification handleOnDownGrade: [:ex :existing :new |  ex allowEvenIfLocked ] onUpgrade: [:ex :existing :new |  ex allowEvenIfLocked ] ].              version := loadedSpec versionForScriptEngine: self.              self root: (fetchRecordBlock value: version) loadDirective ] ]additions: anObject  additions := anObjectrepositories  ^self repositorySpecscreateHttpRepository: aRepositorySpec  ^MCHttpRepository location: aRepositorySpec description user: aRepositorySpec username password: aRepositorySpec passwordsetDescriptionWithString: aString  self root description: aStringcopy: specNamed to: spec  self addMember: (self copyMember           name: spec name;           sourceName: specNamed;           spec: spec;           yourself)monticelloRepository  ^monticelloRepositoryprimeRegistryCurrentVersionFor: cl  ^[ cl project currentVersion ] on: Error do: [:ex |  Warning signal: 'Error finding current version of ' , cl name asString , '. Probably an invalid specification.'.        nil ]packagesDo: aBlock  self loadDirectives do: [:directive |  directive packageDo: aBlock ]setUp  super setUp.  testingEnvironment at: #Metacello_Platform_Test_GlobalDictionary put: (MCDictionaryRepository new           description: 'dictionary://Metacello_Platform_Test_GlobalDictionary';           yourself)extractAllVersionPragmas  | aDict |  aDict := Dictionary new.  self extractPragmas: #version: into: aDict.  self extractPragmas: #version:imports: into: aDict.  ^aDictmethodSections  methodSections ifNil: [ methodSections := OrderedCollection new ].  ^methodSectionsversion101ProjectToolBox: spec  < version: '1.0.1-baseline'>  spec for: #common do: [ spec blessing: #testBlessing ]projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  projectBlock value: selfpackageRepositoryURL  ^self packageRepository ifNotNil: [:aRepository |  aRepository description ] ifNil: [ '' ]postLoadDoIt: aSymbol constructor: aVersionConstructor  aVersionConstructor postLoadDoItForVersion: aSymbolvalidateCleanLoadAndTestsForVersion: version loads: loadList  | cleanLoad cleanTests |  cleanTests := cleanLoad := false.  [ self validateVersionLoad: version loads: loadList.  cleanLoad := true ] on: Error , Warning do: [:ex |  (ex isKindOf: Error) ifTrue: [ self recordValidationError: 'Error while loading version ' , version versionString printString , ' in ' , self configurationClass name asString , ' ' , ex description versionString: version versionString callSite: #validateCleanLoadAndTestsForVersion:loads: reasonCode: #loadError ].        (ex isKindOf: Warning) ifTrue: [ (ex isKindOf: Deprecation) ifTrue: [ self recordValidationCriticalWarning: 'Deprecation while loading version ' , version versionString printString , ' in ' , self configurationClass name asString , ' ' , ex description versionString: version versionString callSite: #validateCleanLoadAndTestsForVersion:loads: reasonCode: #loadDeprecation ] ifFalse: [ self recordValidationWarning: 'Warning while loading version ' , version versionString printString , ' in ' , self configurationClass name asString , ' ' , ex description versionString: version versionString callSite: #validateCleanLoadAndTestsForVersion:loads: reasonCode: #loadWarning.                    Smalltalk at: #UndeclaredVariableWarning ifPresent: [:undeclaredWrning |  (ex isKindOf: undeclaredWrning) ifTrue: [ ex resume: true ] ].                    ex resume ] ] ].  cleanLoad ifTrue: [ cleanTests := [ self validateVersionTests: version ] on: Deprecation do: [:ex |  | message |              message := 'Deprecation warning while running tests for version ' , version versionString printString , ' in ' , self configurationClass name asString , ' ' , ex description.              self recordValidationCriticalWarning: message versionString: version versionString callSite: #validateCleanLoadAndTestsForVersion:loads: reasonCode: #testDeprecation.              ex return: false ].        cleanTests ifTrue: [ MetacelloCleanLoadAndTestsNotification signal: version ] ifFalse: [ MetacelloCleanLoadNotification signal: version ] ]versionOfXXX: spec  < version: '0.9.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>versionOfXXX:'.        spec author: 'dkh'.        spec timestamp: '5/4/2012 14:16'.        spec baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]spotterForGroupsFor: aStep  < spotterOrder: 2>  aStep listProcessor     title: 'Groups';     allCandidates: [ self groups ];     itemName: [:item |  item name ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: truerepositories  ^repositoriesgroupForVersion: aString overrides: aStringOrCollection  | spec |  spec := self project groupSpec     name: aString;     includes: aStringOrCollection;     yourself.  self root packages add: specversion41Symbolic: spec  < version: '4.1'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #release.        spec           package: 'GoferBeau' with: 'GoferBeau-dkh.25';           package: 'GoferFaux' with: 'GoferFaux-tg.31';           yourself ]ensureSpecLoader  ^selfconfiguration092Issue181: spec  < version: '0.9.2'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration092Issue181:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue181SHA , '/repository' ];           import: 'External' ]project  | constructor project |  constructor := MetacelloVersionConstructor on: self.  project := constructor project.  project loader: (project loaderClass new           shouldDisablePackageCache: true;           yourself).  project loadType: #atomic.  ^projectpostCopy  super postCopy.  mutable := nillesson12  actionLabel  ^'Recording 'projectPackage  self subclassResponsibilityloadDirectives: anObject  loadDirectives := anObjectstableVersionD: spec  < symbolicVersion: #stable>  spec for: #common version: '4.2'.  spec for: #'platformVersion1.x' version: '4.0'.  spec for: #'platformVersion1.0.x' version: '4.1'.  spec for: #'platformVersion1.1.x' version: '4.2'.  spec for: #'platformVersion1.2.x' version: '4.3'onLockBreak: projectNames  self onLock: [:ex :loaded :incoming |  (projectNames includes: loaded baseName) ifTrue: [ ex break ] ifFalse: [ ex honor ] ]execute: statements  statements do: [:assoc |  assoc value ifNil: [ self perform: assoc key ] ifNotNil: [ self perform: assoc key withArguments: assoc value ] ].  projectSpecGenerator := self projectSpecGenerator.  projectSpecGenerator target execute: [:projectSpec |  | engine |        engine := MetacelloScriptEngine new           options: self options copy;           projectSpec: projectSpec;           yourself.        engine perform: actionArg key withArguments: actionArg value.        engine root ifNotNil: [:root |  self roots add: root ] ] against: self.  ^(self singleRoot and: [ self roots size == 1 ]) ifTrue: [ self roots first ] ifFalse: [ self roots ]validate  self isValid ifFalse: [ self error: 'Invalid project registration' ]preReleaseVersion  preReleaseVersion ifNil: [ preReleaseVersion := #() ].  ^preReleaseVersionsetUpConfigurationOfUmbrellaB  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfUmbrellaB-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'version51Umbrella:' category: 'cat' timeStamp: '' source: self version51MethodSourceUmbrella)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())prepareForMethodUpdate: aConfig sourceVersion: sourceVersionString forceUpdate: forceUpdate generating: generateBlock  | pragmaDict versionSpecs pragmaMap updatedPackageSpecs updatedPackageSpecsMap reversed pragmaColl seenUpdatedPackageSpecs |  self deprecated: 'see MetacelloToolBox for replacement methods'.  self configuration: aConfig.  versionSpecs := Dictionary new.  pragmaMap := Dictionary new.  pragmaDict := self extractAllVersionPragmas.  pragmaColl := pragmaDict at: sourceVersionString ifAbsent: [ ^self ].  pragmaColl do: [:pragma |  | specs versionSpec |        specs := Dictionary new.        self evaluatePragma: pragma.        self attributeMap keysAndValuesDo: [:attribute :blockList |  versionSpec := self project versionSpec.              versionSpec versionString: sourceVersionString.              specs at: attribute put: versionSpec.              blockList do: [:block |  self with: versionSpec during: block ] ].        versionSpecs at: pragma selector put: {specs .               self attributeOrder .               nil}.        pragmaMap at: pragma selector put: pragma.        self reset ].  versionSpecs keysAndValuesDo: [:selector :ar |  updatedPackageSpecsMap := Dictionary new.        seenUpdatedPackageSpecs := Dictionary new.        ar at: 3 put: updatedPackageSpecsMap.        reversed := aConfig project attributes reverse.        reversed do: [:attribute |  | vs |              (vs := (ar at: 1) at: attribute ifAbsent: [  ]) ~~ nil ifTrue: [ updatedPackageSpecs := forceUpdate ifTrue: [ vs forceUpdatedPackageSpecs ] ifFalse: [ vs updatedPackageSpecs ].                    updatedPackageSpecs associations do: [:assoc |  | filename |                          (filename := seenUpdatedPackageSpecs at: assoc key ifAbsent: [  ]) == nil ifTrue: [ assoc value == #uptodate ifTrue: [ seenUpdatedPackageSpecs at: assoc key put: #uptodate ] ifFalse: [ seenUpdatedPackageSpecs at: assoc key put: assoc value file ] ] ifFalse: [ (filename == #uptodate or: [ assoc value == #uptodate or: [ filename = assoc value file ] ]) ifTrue: [ updatedPackageSpecs removeKey: assoc key ] ] ].                    updatedPackageSpecsMap at: attribute put: updatedPackageSpecs ] ].        updatedPackageSpecsMap valuesDo: [:d |  d associations do: [:assoc |  assoc value == #uptodate ifTrue: [ d removeKey: assoc key ] ] ].        1 to: reversed size do: [:index |  | attribute d |              attribute := reversed at: index.              ((d := updatedPackageSpecsMap at: attribute ifAbsent: [  ]) ~~ nil and: [ d keys size > 0 ]) ifTrue: [ index + 1 to: reversed size do: [:shadowIndex |  d keysDo: [:key |  | dict |                                (dict := updatedPackageSpecsMap at: (reversed at: shadowIndex) ifAbsent: [  ]) ~~ nil ifTrue: [ dict removeKey: key ifAbsent: [  ] ] ] ] ] ].        updatedPackageSpecsMap keys do: [:key |  | d |              d := updatedPackageSpecsMap at: key.              d isEmpty ifTrue: [ updatedPackageSpecsMap removeKey: key ] ].        generateBlock value: selector value: pragmaMap value: ar value: updatedPackageSpecsMap ]lock  ^self execute: #lock args: #()primeRegisterLoadedProjectSpec: projectSpec  MetacelloProjectRegistration registrationForProjectSpec: projectSpec ifAbsent: [:new |  new           loadedInImage: true;           registerProject ] ifPresent: [:existing :new |  existing copyOnWrite: [:existingCopy |  existingCopy loadedInImage: true.              existing locked ifFalse: [ existingCopy merge: new ] ] ]monticelloRepository  ^MetacelloMonticelloResource current monticelloRepositoryprojectPackage: aBlock constructor: aVersionConstructor  aVersionConstructor projectPackageForProject: aBlockgetClassName  ^classNameremoveMember  ^MetacelloRemoveMemberSpec for: self projectname: aString constructor: aVersionConstructor  aVersionConstructor nameForProject: aStringtestSubCommand  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: cli subCommand equals: 'install'.  cli := self command: #('foo' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self should: [ cli subCommand ] raise: Exitcompiler  ^Smalltalk compilerClasstestVersion03  | v1 v2 |  v1 := self versionClass fromString: '1.0.0.1'.  v2 := self versionClass fromString: '1.0.0'.  self assert: v1 > v2packagesSpec  ^self packagesSpecClass for: selfversion: anObject  version := anObjectrepositoryVersionString  | versionComponents versionElement pathElements gitBasedPath repositoryDirPath projectDirPath projectDir projectVersionDir |  repositoryDirPath := self directory fullName.  projectDir := self class cacheDirectoryFor: self projectPath.  projectVersionDir := MCFileTreeFileUtils current directoryFromPath: self projectVersion relativeTo: projectDir.  projectDirPath := projectVersionDir fullName.  (repositoryDirPath beginsWith: projectDirPath) ifFalse: [ ^self projectVersion ].  gitBasedPath := repositoryDirPath copyFrom: projectDirPath size + 2 to: repositoryDirPath size.  pathElements := gitBasedPath findTokens: '/'.  versionElement := pathElements at: 1.  versionComponents := versionElement findTokens: '-'.  ^versionComponents lastbaseline: aString  self root baseline: aString constructor: selfrecursiveDelete: aDirectory  ^aDirectory deleteAllensureLocalRepository  localRepository ifNotNil: [ ^self ].  self resolveLocalRespositoryversionString  ^self versionSpec versionStringcustomProjectAttributes  ^#()tearDownPackageList  ^#()baseline40ProjectFoe: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 loads: '1';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]loadPackageDirective: aPackageLoadDirective gofer: aGofer  | packageSpec |  packageSpec := aPackageLoadDirective spec.  MetacelloPlatform current do: [ | loadBlock goferLoad answers resolvedReference |        aGofer disablePackageCache.        resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.        resolvedReference ifNil: [ ^self ].        loadBlock := [ goferLoad := MetacelloGoferLoad on: aGofer.        goferLoad addResolved: resolvedReference.        goferLoad execute.        MetacelloPlatform current clearCurrentVersionCache ].        (answers := packageSpec answers) notEmpty ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ] ifFalse: [ loadBlock value ].        resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.        MetacelloNotification signal: 'Loaded -> ' , resolvedReference name , ' --- ' , aPackageLoadDirective repository repositoryDescription , ' --- ' , resolvedReference repository description ] displaying: 'Loading ' , packageSpec fileoperator  operator == nil ifTrue: [ ^#>= ].  ^operator~> aMetacelloVersionNumber  aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].  ^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]versionSpec  ^self versionSpecClass for: selfconstructClassName  ^'ConfigurationOf' , self nameexplicitLoadPackageSpecs: packageSpecs repositories: repositories  | directive |  directive := self loaderPolicy pushExplicitLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] for: self.  directive explicitLoadWithPolicy: self loaderPolicyexternalRepository  ^externalRepositorymergeMap  | map |  map := super mergeMap.  map at: #repositories put: repositories.  ^mapmethodUpdateSelector  ^#remove:baseline35MethodSourceFan  ^(self class sourceCodeAt: #baseline35Fan:) asStringoverriddenMethods  ^#()version  ^(self configurationProjectSpecIfAbsent: [ ^MetacelloMCBaselineProject singletonVersionName ]) versionStringtestMergePackageB  | packages package |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages merge: {(self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           includes: 'AndIncludedPackage';           answers: #(#('xpostload' 'xpostload answer'));           file: 'Package-dkh.2';           yourself)}.  package := packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: package name equals: 'Package'.  self assert: package requires equals: #('AnotherPackage' 'AndAnotherPackage').  self assert: package includes equals: #('IncludedPackage' 'AndIncludedPackage').  self assert: package answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer') #('xpostload' 'xpostload answer')).  self assert: package file equals: 'Package-dkh.2'.  self assert: package preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: package postLoadDoIt value identicalTo: #postLoadDoItlatestVersionMatching: versionPatternString excludedBlessings: excluded  ^nilsetTimestampWithString: aString  self root timestamp: aStringincrementNormalVersionAt: index  | int col |  col := self normalVersion.  int := col at: index.  col at: index put: int + 1isLoadedMatchConstraints  self isPartiallyCurrent isLoadedMatchConstraints: [:ignored |  ^true ].  ^falsetestProjectReferenceSpec  | projectReference project |  projectReference := self projectReferenceSpec     name: 'Project';     projectReference: (project := self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           yourself);     yourself.  self assert: projectReference name equals: 'Project'.  self assert: projectReference projectName equals: 'Project'.  self assert: projectReference projectReference identicalTo: project.  self should: [ projectReference includes: #() ] raise: Error.  self should: [ projectReference requires: #() ] raise: Error.  self should: [ projectReference answers: #() ] raise: Error.  projectReference projectDo: [:prjct |  self assert: projectReference identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ]configurationProjectSpec  ^configurationProjectSpecmergeMember  ^MetacelloMergeMemberSpec for: self projectproject  ^project ifNil: [ self class ensureMetacello.        project := self projectClass new projectAttributes: self customProjectAttributes.        project versionNumberClass: self versionNumberClass.        project class versionConstructorClass on: self project: project.        project loadType: #linear.        project ]projectSpecSelectBlock  ^[:projectSpec |  projectSpec ifNil: [ false ] ifNotNil: [ MetacelloProjectRegistration registrationForProjectSpec: projectSpec ifAbsent: [ false ] ifPresent: [:existingRegistration :newRegistration |  existingRegistration loadedInImage ] ] ]resolvePackageSpec: packageSpec cachedGofer: gofer  | versionReference references |  versionReference := packageSpec goferLoaderReference.  (references := versionReference resolveAllWith: gofer) isEmpty ifTrue: [ ^nil ].  ^references last asMetacelloCachingResolvedReferencesetUpMonticelloRepository  monticelloRepository := MCDictionaryRepository newhasOverride  ^self overrideProjectSpec ~~ nilresolveToAllPackagesIn: aVersionSpec visited: visited  | packages |  packages := Dictionary new.  self resolveToAllPackagesIn: aVersionSpec into: packages visited: visited.  ^packages values asOrderedCollectionworkingCopy  workingCopy == nil ifTrue: [ workingCopy := self findWorkingCopy ].  ^workingCopymodifyBaselineOf  | baselineClass constructor pragma baseline |  baselineClass := project configuration class.  baseline := baselineClass new.  constructor := MetacelloToolBoxBaselineConstructor new     configuration: project configuration class new;     yourself.  pragma := constructor extractBaselinePragmaFor: baselineClass.  constructor extractMethodSectionsForClass: baselineClass.  methodSpec := MetacelloBaselineOfMethodSpec new     project: project;     selector: (MetacelloPlatform current selectorForPragma: pragma);     category: (baselineClass whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma: pragma));     yourself.  constructor methodSections do: [:methodSection |  self methodSpec methodSections add: methodSection ]lookupBaselineSpec  baselineProjectSpec ifNotNil: [:spec |  ^spec ].  ^configurationProjectSpecversion10Issue59: spec  < version: '1.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>version10Issue59:'.        spec author: 'dkh'.        spec timestamp: '6/18/2012 14:34'.        spec baseline: 'Issue32' ].  spec for: #custom do: [ spec baseline: 'Issue32' with: [ spec repository: 'dictionary://Metacello_External_Test_Repository' ] ]updateForSpawnMethod: sourceSpec  | nm fl |  nm := name.  fl := file.  fl == nil ifTrue: [ {answers .         requires .         includes .         repositories .         preLoadDoIt .         postLoadDoIt} detect: [:each |  each ~~ nil ] ifNone: [ fl := name ] ].  super updateForSpawnMethod: sourceSpec.  file := repositories := goferPackage := preLoadDoIt := postLoadDoIt := nil.  name := nm.  file := fl.  ^file == nilversion112ProjectToolBox: spec  < version: '1.1.2-baseline'>  spec for: #common do: [ spec package: 'Example-Core'.        spec for: #nested do: [ spec                 package: 'Example-Base';                 package: 'Example-Test-Nested' ] ].  spec for: #extra do: [ spec package: 'Example-Test' ]isError  ^falseversion40SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version40Symbolic:) asStringversionClass  ^MetacelloVersiontestSemanticVersioningSubsetCompliance  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0')printOn: aStream indent: indent  super printOn: aStream indent: indent.  self printLoadDirectivesOn: aStream indent: indentexecuteBlock: selectBlock do: projectSpecBlock  (self projectSpecsFromRepositoryArg select: selectBlock) do: [:projectSpec |  projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ]isEmpty  ^self dataMap isEmptygetFile  ^nilisResumable  ^truepostLoadDoIt: aSymbol  self root postLoadDoIt: aSymbol constructor: selfrepository: anObject constructor: aVersionConstructor  aVersionConstructor repositoryForProject: anObjectrepositoryForPackage: anObject  self repositoryForSpec: anObjectload  ^self subclassResponsibilitygitCommitShaFor: aDirectory  ^nilprojectSpecCreationBlock  ^[:projectName |  {(MetacelloMCProject new configurationOfProjectSpec name: projectName)} ]defaultBlessing  ^#releasesetUpConfigurationOfProjectIssue119dkh5: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.5'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion40Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version40Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version41Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version41Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version42Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version42Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version43Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version43Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version44Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version44Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfobaselineIssue32: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>baselineIssue32:'.        spec           package: 'External-CoreX';           package: 'External-TestsX' with: [ spec requires: 'External-CoreX' ];           preLoadDoIt: #preloadDoIt;           postLoadDoIt: #postloadDoIt;           yourself.        spec           group: 'Core' with: #('External-CoreX');           group: 'default' with: #('Core');           group: 'Tests' with: #('External-TestsX');           yourself ]setDefaultsAndValidate: aProjectSpec  | issues |  issues := aProjectSpec validateForScriptLoad: self withDefaultVersionString: self defaultVersionString withDefaultRepositoryDecription: self defaultRepositoryDescription.  issues isEmpty ifTrue: [ ^self ].  (MetacelloValidationFailure issues: issues message: 'Project spec validation failure') signalcleanupProtocols: aWorkingCopy  doItBlock: selector  selector == nil ifTrue: [ ^nil ].  selector numArgs = 0 ifTrue: [ ^[ self project configuration perform: selector ] ].  selector numArgs = 1 ifTrue: [ ^[:aLoader |  self project configuration perform: selector with: aLoader ] ].  selector numArgs = 2 ifTrue: [ ^[:aLoader :pkgSpec |  self project configuration perform: selector with: aLoader with: pkgSpec ] ].  ^nilconfigPackagesSpecMethodOn: aStream indent: indent  | projectSpecs packageSpecs groupSpecs |  projectSpecs := OrderedCollection new.  packageSpecs := OrderedCollection new.  groupSpecs := OrderedCollection new.  self packagesSpec list do: [:member |  member spec projectDo: [:proj |  member spec name ~~ nil ifTrue: [ projectSpecs add: member ] ] packageDo: [:package |  member spec name ~~ nil ifTrue: [ packageSpecs add: member ] ] groupDo: [:group |  member spec name ~~ nil ifTrue: [ groupSpecs add: member ] ] ].  projectSpecs isEmpty not ifTrue: [ aStream           tab: indent;           nextPutAll: 'spec '.        projectSpecs size > 1 ifTrue: [ aStream                 cr;                 tab: indent + 1 ].        1 to: projectSpecs size do: [:index |  (projectSpecs at: index) configMethodCascadeOn: aStream last: index == projectSpecs size indent: indent + 1.              index ~= projectSpecs size ifTrue: [ aStream tab: indent + 1 ] ] ].  packageSpecs isEmpty not ifTrue: [ projectSpecs isEmpty not ifTrue: [ aStream cr ].        aStream           tab: indent;           nextPutAll: 'spec '.        packageSpecs size > 1 ifTrue: [ aStream                 cr;                 tab: indent + 1 ].        1 to: packageSpecs size do: [:index |  (packageSpecs at: index) configMethodCascadeOn: aStream last: index == packageSpecs size indent: indent + 1.              index ~= packageSpecs size ifTrue: [ aStream tab: indent + 1 ] ] ].  groupSpecs isEmpty not ifTrue: [ projectSpecs isEmpty not | packageSpecs isEmpty not ifTrue: [ aStream cr ].        aStream           tab: indent;           nextPutAll: 'spec '.        groupSpecs size > 1 ifTrue: [ aStream                 cr;                 tab: indent + 1 ].        1 to: groupSpecs size do: [:index |  (groupSpecs at: index) configMethodCascadeOn: aStream last: index == groupSpecs size indent: indent + 1.              index ~= groupSpecs size ifTrue: [ aStream tab: indent + 1 ] ] ]baseline60MethodSourceFoo  ^(self class sourceCodeAt: #baseline60Foo:) asStringpackageSpecsInLoadOrder  ^self versionSpec packageSpecsInLoadOrderForMap: packagesproject: aString  self root project: aString constructor: selfensureSpecLoader  ^(MetacelloEnsureFetchingMCSpecLoader on: self spec)     shouldDisablePackageCache: self shouldDisablePackageCache;     loaderPolicy: self loaderPolicy;     yourselflock  | spec |  MetacelloProjectRegistration copyRegistryRestoreOnErrorWhile: [ self setDefaultsAndValidate: self projectSpec copy.        spec := self projectSpec.        MetacelloProjectRegistration registrationForProjectSpec: spec ifAbsent: [:new |  new                 locked: true;                 registerProject ] ifPresent: [:existing :new |  existing copyOnWrite: [:existingCopy |  existingCopy locked: true.                    spec copyForRegistration: existingCopy onWrite: [:specCopy |  specCopy ifNil: [ existingCopy merge: new ] ifNotNil: [ specCopy mergeScriptRepository: spec.                                spec := specCopy ] ] ] ].        self root: spec ]shouldBeMutable  self isMutable ifTrue: [ ^self ].  self error: 'Not allowed to modify an immutable object'validateProjectLoad  | issues project versions currentVersion collectedIssues |  (issues := self validateProject select: [:issue |  issue isError ]) notEmpty ifTrue: [ ^issues ].  project := self configurationClass project.  collectedIssues := issues.  versions := project versions select: [:version |  validationReport := nil.        version blessing ~~ #broken and: [ version blessing ~~ #baseline and: [ (issues := (self validateProject: project version: version versionString) select: [:issue |  issue isCritical ]) isEmpty ] ] ].  validationReport := collectedIssues.  versions isEmpty ifTrue: [ self recordValidationCriticalWarning: 'No non #baseline versions  available  in ' , self configurationClass name asString callSite: #validateProjectLoad reasonCode: #noLoadableVersions.        ^self validationReport ].  (currentVersion := project currentVersion) ~~ nil ifTrue: [ | index |        index := versions indexOf: currentVersion.        versions := versions copyFrom: index to: versions size ].  versions do: [:version |  self validateCleanLoadAndTestsForVersion: version loads: #('ALL') ].  ^self validationReportbaseline62MethodSourceProjectIssue86  ^(self class sourceCodeAt: #baseline62ProjectIssue86:) asStringuseDetermineVersionForLoad: anObject  useDetermineVersionForLoad := anObjecttestClearCache  MetacelloPlatform current stackCacheFor: #cached at: #key doing: [:cache |  | value |        cache at: #x put: 1.        self assert: (cache at: #x ifAbsent: [  ]) identicalTo: 1.        MetacelloClearStackCacheNotification signal.        self assert: (cache at: #x ifAbsent: [  ]) identicalTo: nil ]baseline30MethodSourceFoo  ^(self class sourceCodeAt: #baseline30Foo:) asStringsetUpBaselineGithubReferenceXII  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefXII-dkh.1'.  className := #BaselineOfGithubRefXII.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineGithubReferenceVI:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceVI:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfogetName  ^nameverifyPackageNotLoaded: packageName  self assert: (MCWorkingCopy allManagers detect: [:wc |  wc packageName = packageName ] ifNone: [  ]) identicalTo: nilroot: anObject  root := anObjectincludes: anObject  self root includes: anObject constructor: selfproject: aString with: aBlockOrString  self root project: aString with: aBlockOrString constructor: selfsetFor: attributeList do: aBlock  attributeList asMetacelloAttributeList do: [:attribute |  | blockList |        blockList := self attributeMap at: attribute ifAbsent: [ self attributeMap at: attribute put: (blockList := OrderedCollection new) ].        blockList add: aBlock.        self addAttribute: attribute ]versionStatus  versionStatus == nil ifTrue: [ versionStatus := self computeVersionStatus ].  ^versionStatusconfigMethodOn: aStream indent: indent  aStream     tab: indent;     nextPutAll: 'spec ';     cr;     tab: indent + 1;     nextPutAll: 'name: ' , self name printString;     nextPut: $;;     cr;     tab: indent + 1;     nextPutAll: 'projectReference: ';     nextPut: $[;     cr.  aStream     tab: indent + 2;     nextPutAll: 'spec'.  self projectReference ifNotNil: [ self projectReference configMethodBodyOn: aStream indent: indent + 2 ].  aStream nextPutAll: ' ].'fetch  self fetchUsing: self loadersetUpConfigurationOfProjectIssue154  | versionInfo |  versionInfo := self setUpConfigurationOfMetacelloExampledkh1.  versionInfo := self setUpConfigurationOfProjectIssue154dkh1version51Foo: spec  < version: '5.1'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #release.        spec           package: 'GoferUmbrella' with: 'GoferUmbrella-lr.5';           yourself ]nameComponentsFrom: aVersionName  ^self class nameComponentsFrom: aVersionNameconstructor  | constructor |  constructor := MetacelloToolBoxConstructor new.  constructor configuration: project configuration class new.  ^constructorcompareRelativeCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoader  ^self compareCurrentVersion: anOperator targetVersionStatus: statusIgnored using: anMCLoaderconfigurationClass  ^self subclassResponsibilitysetUpBaselineGithubReferenceVII  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefVII-dkh.1'.  className := #BaselineOfGithubRefVII.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineGithubReferenceIV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceIV:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoversion50MethodSourceUmbrella  ^(self class sourceCodeAt: #version50Umbrella:) asStringtestAddPackageC  | packages |  packages := self packagesSpec.  packages add: {'Platform' .         'Base' .         'Tests'}.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  packages packageNamed: 'Base' ifAbsent: [ self assert: false ].  packages packageNamed: 'Tests' ifAbsent: [ self assert: false ]versionInfoMap  versionInfoMap == nil ifTrue: [ versionInfoMap := Dictionary new ].  ^versionInfoMapsetPreLoadDoIt: aSymbol  self shouldBeMutable.  preLoadDoIt := aSymbolloadDirectives  loadDirectives == nil ifTrue: [ loadDirectives := OrderedCollection new ].  ^loadDirectivescurrentlyLoadedExtensionClassesInVersion  | classes |  classes := Dictionary new.  self projectDo: [:ignored |   ] packageDo: [:packageSpec |  ([ packageSpec workingCopy ] on: Error do: [:ex |  ex return: nil ]) ifNotNil: [:workingCopy |  | packageInfo |              packageInfo := MetacelloPlatform current packageInfoFor: workingCopy.              packageInfo extendedClasses do: [:cl |  classes at: cl put: (packageInfo extensionCategoriesForClass: cl) ] ] ] groupDo: [:ignored |   ].  ^classesconfigShortCutMethodBodyOn: aStream member: aMember indent: indent  | hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |  hasFile := file ~~ nil.  hasRepositories := self repositorySpecs size > 0.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [ self answers isEmpty ] ]) not.  hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers ifTrue: [ aStream           nextPutAll: 'package: ' , self name printString , ' ';           nextPutAll: aMember methodUpdateSelector asString , ' [';           cr.        aStream           tab: indent + 1;           nextPutAll: 'spec '.        self configMethodBodyOn: aStream hasName: false indent: indent + 2.        aStream nextPutAll: ' ]'.        ^self ].  aStream nextPutAll: 'package: ' , self name printString.  hasFile ifTrue: [ aStream nextPutAll: ' with: ' , file printString ]registerPackageNamed: packageName  ^RPackageSet named: packageNamemerge: aRepositorySpec  aRepositorySpec mergeIntoMetacelloRepositories: selfbaseline40ProjectFee: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec           package: 'GeauxFaux' with: 'GeauxFaux-tg.32';           package: 'GeauxBeau' with: 'GeauxBeau-dkh.55';           yourself ]testStandardMatch  self assert: ((self versionClass fromString: '1.0.0+alpha5.0') match: '1.0.0+alpha#.0').  self assert: ((self versionClass fromString: '1.1.1') match: '*.*.*').  self deny: ((self versionClass fromString: '1.1.1') match: '*.*').  self assert: ((self versionClass fromString: '1.1.0') match: '1.1.*').  self assert: ((self versionClass fromString: '1.1.0') match: '1.#.*').  self deny: ((self versionClass fromString: '1.10.0+build.0') match: '1.#.*').  self assert: ((self versionClass fromString: '1.0.0-alpha5.0') match: '1.0.0-alpha#.0').  self assert: ((self versionClass fromString: '1.0.0-alpha5+build5.0') match: '1.0.0-alpha5+build#.0').  self deny: ((self versionClass fromString: '1.0.0-alpha10.0') match: '1.0.0-alpha#.0')hasRepository  ^self repositorySpecs notEmptypostLoadDoIt: anObject  anObject setPostLoadDoItInMetacelloSpec: selfmergeRepositoriesSpec: anotherRepositories  self repositories: (self getRepositories == nil ifTrue: [ anotherRepositories ] ifFalse: [ self repositories mergeSpec: anotherRepositories ])getTimestamp  ^timestamprecordValidationError: aString callSite: callSite reasonCode: aSymbol  ^self recordValidationError: aString versionString: nil callSite: callSite reasonCode: aSymboladdMember: aMember  self list add: aMember.  self clearMemberMapconfigurationOfProjectSpecClass  ^MetacelloMCConfigurationOfProjectSpecprintOn: aStream  | label vs |  (#(structural broken) includes: self blessing) not ifTrue: [ (vs := self versionStatus) == #somethingLoaded ifTrue: [ aStream nextPutAll: '<>' ].        vs == #loadedMatchConstraints ifTrue: [ aStream nextPutAll: '>=' ].        vs == #loadedToSpec ifTrue: [ aStream nextPut: $~ ] ].  self versionNumber printOn: aStream.  self basicSpec ~~ nil ifTrue: [ (label := self projectLabel) isEmpty ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ]versionOfExternal090: spec  < version: '0.9.0'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>versionOfExternal090:'.        spec repository: 'dictionary://Metacello_Configuration_Test_Repository'.        spec           package: 'External-Core' with: 'External-Core-dkh.1';           yourself ]version20Issue171: spec  < version: '2.0' imports: #('2.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '2.0'.        spec package: 'GeauxFoo' with: 'GeauxFoo-lr.1' ]monticelloRepository  ^MetacelloMonticelloResource current monticelloRepositoryversionForScriptEngine: aMetacelloScriptEngine  | prj |  prj := self projectClass ifNil: [ self project ] ifNotNil: [ self projectClassProject ].  ^((prj projectForScriptEngine: aMetacelloScriptEngine) version: self versionString)     silently: aMetacelloScriptEngine silently;     ignoreImage: aMetacelloScriptEngine ignoreImage;     cacheRepository: aMetacelloScriptEngine cacheRepository;     repositoryOverrides: aMetacelloScriptEngine repositoryOverridesexcludeFromLatestVersion  ^#(structural development broken baseline)version44Issue119: spec  < version: '4.4' imports: #('4.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: 2.0.        spec package: 'GoferBar ' with: 'GoferBar-jf.1' ]testLocation  | repository |  repository := MCGitlabRepository location: 'gitlab://pharo-project/pharo:master/src'.  self     assert: repository hostname equals: 'gitlab.com';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assert: repository repoPath equals: 'src';     assert: repository sshPort isNil.  repository := MCGitlabRepository location: 'gitlab://pharo-project/pharo:master'.  self     assert: repository hostname equals: 'gitlab.com';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assertEmpty: repository repoPath;     assert: repository sshPort isNil.  repository := MCGitlabRepository location: 'gitlab://pharo-project/pharo'.  self     assert: repository hostname equals: 'gitlab.com';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assertEmpty: repository repoPath;     assert: repository sshPort isNilsetTimestampInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setTimestamp: selfdescription: aBlockOrString  self root description: aBlockOrString constructor: selfgtInspectorChildren  ^self loadDirectivesversion121ProjectToolBox: spec  < version: '1.2.1-baseline'>  spec for: #common do: [ spec blessing: #testBlessing.        spec repository: 'http://www.example.com/vor'.        spec           package: 'Example-Core' with: [ spec                 includes: #('Example-AddOn');                 file: 'Example-Core-anon.1';                 repository: 'http://www.example.com/or';                 preLoadDoIt: #preloadForCore;                 postLoadDoIt: #postloadForCore:package: ];           package: 'Example-AddOn' with: [ spec requires: #('Example-Core') ];           package: 'Example-Tests' with: [ spec requires: #('Example-AddOn') ] ]attributes  ^(OrderedCollection with: #common)     addAll: self platformAttributes;     yourselfgitBranchNameFor: aDirectory  ^nilrepoPath  repoPath ifNil: [ repoPath := '' ].  ^repoPathbaselineProjectSpecs  | projectSpecs |  projectSpecs := OrderedCollection new.  self baselineRegistry keysAndValuesDo: [:className :registration |  projectSpecs add: (self projectSpecForClassNamed: className ifAbsent: [ self error: 'not expected' ]) ].  ^projectSpecs asArrayusername  username == nil ifTrue: [ username := '' ].  ^usernameproject  ^self projectWith: #()isLoadedToSpec: matchBlock  | matchStatus |  matchStatus := #loadedToSpec.  (self evaluateStatus: #(#allLoadedToSpec #loadedToSpec)) ifTrue: [ aPackageIsLoaded & aProjectIsLoaded ifTrue: [ (aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not and: [ aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not ]) ifTrue: [ matchBlock value: matchStatus ] ] ifFalse: [ aPackageIsLoaded ifTrue: [ aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not ifTrue: [ matchBlock value: matchStatus ] ] ifFalse: [ hasNoPackage & aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not ifTrue: [ matchBlock value: matchStatus ] ] ] ]add: aDirective  self loadDirectives add: aDirectiveloadWithPolicy: aLoadPolicy  | gofer |  gofer := MetacelloGofer new.  gofer disablePackageCache.  gofer repository: aLoadPolicy cacheRepository.  self loadUsing: self gofer: goferdebug  debug == nil ifTrue: [ debug := #() ].  ^debugconfigSpawnMethodOn: aStream indent: indent  super configSpawnMethodOn: aStream indent: indent.  self configPackagesSpecMethodOn: aStream indent: indenttestAlphaNumericVersion2  self assert: (self versionClass fromString: '2.9.0-alpha.2') < (self versionClass fromString: '2.9.0-alpha.3')baseline40ProjectFie: spec  < version: '4.0'>  spec for: #common do: [ spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Feaux' with: [ spec                 className: 'MetacelloTestConfigurationOfFeaux';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFeaux';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]registrationsCompareEqual: aMetacelloProjectSpec  ^self className = aMetacelloProjectSpec className and: [ self versionString = aMetacelloProjectSpec versionString and: [ self operator == aMetacelloProjectSpec operator ] ]packagesForSpecNamed: aString ifAbsent: aBlock  | pkgSpec |  pkgSpec := self spec packageNamed: aString ifAbsent: aBlock.  ^pkgSpec resolveToPackagesIn: self spec visited: MetacelloVisitedPackages newversion12: spec  < version: '1.2' imports: #('1.2-baseline')>  spec for: #common do: [ spec blessing: #beta.        spec           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1' ]commonDefaultSymbolicVersionResolverBlock  ^self defaultSymbolicVersionResolverBlock: (ConfigurationOf new project: self project)versionNumber: aVersionNumber  versionNumber := aVersionNumberisLoadedToSpec  self isPartiallyCurrent isLoadedToSpec: [:ignored |  ^true ].  ^falsesetUpConfigurationOfProjectIssue136  | versionInfo |  versionInfo := self setUpConfigurationOfProjectIssue136dkh1.  versionInfo := self setUpConfigurationOfProjectIssue136dkh2: {versionInfo}description  ^'Could not resolve: ' , packageSpec name , ' [' , packageSpec file , ']' , ' in' , self repositoryString , (repositoryError == nil ifTrue: [ '' ] ifFalse: [ ' ERROR: ' , repositoryError description printString ])conflictOf10: spec  < version: '1.0.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>conflictOf10:'.        spec author: 'dkh'.        spec timestamp: '6/1/2012 14:46' ].  spec for: #custom do: [ spec configuration: 'ExternalX' with: [ spec                 version: '0.9.1';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]testInvalidSpecialMatch  self should: [ (self versionClass fromString: '1.1.1') match: '?.?.?' ] raise: Errorwiresong: projectName  self repository: 'http://source.wiresong.ca/' , projectNameloadUsing: aLoaderDirective gofer: aGofer  aLoaderDirective loadPackageDirective: self gofer: aGoferlesson07  ^Lesson title: 'Lesson 7' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #baseline07:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version07:."For version 0.7, we are ceating a baseline version specification which is expected to be usedacross several versions and the version specification which is restricted to the file versions.In method #baseline07: the structure of version ''0.7-baseline'' is specified. The repository is listed, the packages are listed and the required packages are defined. We''ll cover the #blessing:in a later lesson.In method #version07: the file versions are specified. You will note that the pragma as an #imports: component that specifies the list of versions that this version (version ''0.7'') is based upon. In fact, if you print the spec for ''0.7-baseline'' and then print the spec for ''0.7'' you can see that ''0.7'' is a composition of both versions:"   (MetacelloTutorialConfig project version: ''0.7-baseline'') spec.   (MetacelloTutorialConfig project version: ''0.7'') spec."Of course if you print the ''0.6'' spec and the ''0.7'' spec you can see that they specify exactly thesame information in a slightly different way:"  (MetacelloTutorialConfig project version: ''0.6'') spec.  (MetacelloTutorialConfig project version: ''0.7'') spec."and if you load each of the versions, you will see that they load the same packages, in the same order:"  (MetacelloTutorialConfig project version: ''0.6'') load.  (MetacelloTutorialConfig project version: ''0.7'') load."Finally, even though version ''0.7-baseline'' does not have explicit package versions, you may loadthe version. When the ''real'' loader encounters a package name (without version information) it willattempt to load the latest version of the package from the repository. With theMetacelloNullRecordingMCSpecLoader the packages names are ''loaded'':"  (MetacelloTutorialConfig project version: ''0.7-baseline'') load."Of course when a number of developers are working on a project it may be useful to load a#baseline version so that you get the latest work from all of the project members. "ProfStef next.'defaultPackageNamesToLoad  ^self defaultPackageNamesToLoad: self spec defaultPackageNames~> aMetacelloVersion  aMetacelloVersion species = self species ifFalse: [ ^false ].  ^self versionNumber ~> aMetacelloVersion versionNumberload  | repos |  repos := self repositoriesFrom: self spec repositorySpecs.  ^self loadType == #atomic ifTrue: [ self atomicLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos ] ifFalse: [ self linearLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: repos ]testSpecialMatch  self assert: ((self versionClass fromString: '1.1.0') match: '?').  self assert: ((self versionClass fromString: '1.0.0-alpha') match: '?').  self assert: ((self versionClass fromString: '1.0.0-rc.1+build.1') match: '?').  self assert: ((self versionClass fromString: '1.1.0') match: '*.*.?').  self assert: ((self versionClass fromString: '1.3.7+build.2.b8f12d7') match: '?').  self assert: ((self versionClass fromString: '1.3.7+build.11.e0f985a') match: '?').  self deny: ((self versionClass fromString: '1.1.0') match: '*.*.*-?').  self deny: ((self versionClass fromString: '1.1.0') match: '*.*.*+?').  self assert: ((self versionClass fromString: '1.1.1') match: '*.?')postLoadDoIt: anObject  anObject setPostLoadDoItInMetacelloSpec: selfprintOn: aStream  | label versionString descriptions |  self configurationProjectSpecIfPresent: [:spec |  label := spec className.        versionString := spec versionString ] ifAbsent: [ label := self baselineProjectSpec className.        versionString := '[baseline]' ].  aStream nextPutAll: label.  versionString ifNil: [ aStream nextPutAll: ' --no version specified--' ] ifNotNil: [ aStream           space;           nextPutAll: versionString ].  (descriptions := self repositoryDescriptions) isEmpty ifTrue: [ ^self ].  aStream nextPutAll: ' from '.  descriptions size = 1 ifTrue: [ aStream nextPutAll: descriptions first ] ifFalse: [ aStream nextPut: ${.        descriptions do: [:description |  aStream nextPutAll: description ].        aStream nextPut: $} ]stackCacheFor: cacheName at: key doing: aBlock  ^self stackCacheFor: cacheName cacheClass: Dictionary at: key doing: aBlockbaseline30MethodSourceFan  ^(self class sourceCodeAt: #baseline30Fan:) asStringlesson02  mergeSpec: anotherSpec  | newSpec map anotherRequires anotherIncludes anotherAnswers |  newSpec := super mergeSpec: anotherSpec.  map := anotherSpec mergeMap.  anotherSpec name ~~ nil ifTrue: [ newSpec name: anotherSpec name ].  (anotherRequires := map at: #requires) ~~ nil ifTrue: [ newSpec setRequires: self requires , anotherRequires ].  (anotherIncludes := map at: #includes) ~~ nil ifTrue: [ newSpec setIncludes: self includes , anotherIncludes ].  (anotherAnswers := map at: #answers) ~~ nil ifTrue: [ newSpec setAnswers: self answers , anotherAnswers ].  ^newSpeccreateNewDevelopmentVersion  ^Lesson title: '8. Create new development version' lesson: '"After releasing a version it isn''t a bad idea to open a new development version for the next phase of development:"		MetacelloToolBox		createNewDevelopmentVersionIn: ConfigurationOfExample		description: ''- aim at implementing new features''."The above expression uses the #release version as a template for the new version with the #release minor version number incremented." ProfStef next.'testIsBaselineName  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: cli isBaselineName.  cli := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self deny: cli isBaselineNamehasConflictWithBaselineSpec: projectSpec  ^self hasLoadConflicts: projectSpecupdatePackageSpec: updatedSpecs using: anMCLoader  onLock: aBlock  self addStatement: #onLock: args: {aBlock}setTimestamp: anObject  timestamp := anObjectget  ^self execute: #get args: #()specResolverBlock  ^[:versionSpec :pragma |  (pragma argumentAt: 1) = versionSpec versionString ifTrue: [ self evaluatePragma: pragma.        self project attributes do: [:attribute |  | blockList |              (blockList := self attributeMap at: attribute ifAbsent: [  ]) ~~ nil ifTrue: [ blockList do: [:block |  self with: versionSpec during: block ] ] ] ] ]mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec  aMetacelloRepositoriesSpec addMember: (aMetacelloRepositoriesSpec mergeMember           name: self name;           spec: self;           yourself)operator: aSymbol  operator := aSymbollesson11  ^Lesson title: 'Lesson 11' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline11:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version11:."As is often the case, it is useful to separate the test package from the core packages for a project. In #baseline11: we''ve created two project references. The reference named ''Example Default'' loads the ''default'' group and the reference named ''Example Tests'' loads the ''Tests'' group.We then made ''Project-Core'' require ''Example Default'' and ''Project-Tests'' requires ''Project-Core'' and ''Example Tests''.Now it is possible to load just the core packages:"  (MetacelloProjectRefTutorialConfig project version: ''1.1'') load: ''Project-Core''."or the whole enchilada including tests:"  (MetacelloProjectRefTutorialConfig project version: ''1.1'') load: ''Project-Tests''.ProfStef next.'setUpConfigurationOfProjectIssue156  self     setUpIssue156BaselineOfGoo;     setUpIssue156ConfigurationOfGooaProjectIsLoaded: aBoolean  aProjectIsLoaded := aBooleanrepositories: aBlock constructor: aVersionConstructor  aVersionConstructor repositoriesForPackage: aBlockwarningReasonCodes  ^#(#onlyBaselineVersion)version50Foo: spec  < version: '5.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #release.        spec           package: 'GoferUmbrella' with: 'GoferUmbrella-dkh.4';           yourself ]primeStackCacheFor: cacheName doing: noArgBlock defaultDictionary: aDictionary  self deprecated: 'use #primeStackCacheWith:doing:'.  self useStackCacheDuring: [:dict |  | cache |        cache := dict at: cacheName ifAbsent: [  ].        cache == nil ifTrue: [ cache := Dictionary new.              dict at: cacheName put: cache ].        ^noArgBlock value ] defaultDictionary: aDictionaryhttpsUrl  ^'https://<1s>/<2s>.git' expandMacrosWith: self hostname with: projectPathpackagesSpecClass  ^MetacelloPackagesSpecprojectReference  ^projectReferencesshPort  ^sshPortloadRequiredFromArray: anArray  | displayString |  displayString := 'Loading ' , self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloPlatform current do: [ ^self executeLoadFromArray: anArray ] displaying: displayStringcopySpecTo: aRepositorySpec  self loader copySpec: self from: self repositorySpecs to: aRepositorySpec createRepositorysingleRoot: aBool  singleRoot := aBoolsupplyingAnswersForPackage: anObject  self root answers: anObjectconfigurationOfProjectSpecClass  ^self subclassResponsibilityapplyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock  removeBlock value: selfprojectTagsUrlFor: aProjectPath  ^'https://<1s>/api/v4/projects/<2s>/repository/tags' expandMacrosWith: self hostname with: aProjectPathunregisterProject  self class registry unregisterProjectRegistration: selfhasConflictWithConfigurationSpec: projectSpec  ^falsepostLoadDoItForSpec: aSymbol  self validateDoItSelector: aSymbol.  self root postLoadDoIt: aSymbolversionArg: anObject  versionArg := anObjectversion10Issue47: spec  < version: '1.0.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>version10Issue47:'.        spec author: 'dkh'.        spec timestamp: '6/18/2012 14:34'.        spec baseline: 'Issue32' ].  spec for: #custom do: [ spec baseline: 'Issue32' with: [ spec repository: 'dictionary://Metacello_External_Test_Repository' ] ]asProjectSpec  ^selfinitialize  self loaderPolicyincrementVersionAt: index  | int |  int := self at: index.  (int := self at: index) isString ifFalse: [ self at: index put: int + 1 ]version129ProjectToolBox: spec  < version: '1.2.9-baseline'>  spec for: #common do: [ spec           project: 'Example Project' with: [ spec                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadDoIt;                 postLoadDoIt: #postloadDoIt;                 repository: 'http://www.example.com/ob' ];           project: 'Copy Project' copyFrom: 'Example Project' with: [ spec                 preLoadDoIt: nil;                 postLoadDoIt: nil ] ]validateForScriptLoad: aScriptEngine withDefaultVersionString: defaultVersionString withDefaultRepositoryDecription: defaultRepositoryDecription  | issues callSite |  issues := OrderedCollection new.  callSite := #validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription:.  self name ifNil: [ issues add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #incompleteProjectSpec callSite: callSite explanation: 'name field required') ].  self className ifNil: [ issues add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #incompleteProjectSpec callSite: callSite explanation: 'className field required') ].  self repositories isEmpty ifTrue: [ defaultRepositoryDecription ifNotNil: [ self repository: defaultRepositoryDecription ] ifNil: [ issues add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #incompleteProjectSpec callSite: callSite explanation: 'repository field required') ] ].  self validateVersionString: issues withDefaultVersionString: defaultVersionString.  ^issuesfetchProject: aLoaderPolicy  | mcLoader |  (mcLoader := self loader) == nil ifTrue: [ mcLoader := self project loaderClass on: nil ].  mcLoader loaderPolicy: aLoaderPolicy.  mcLoader doingLoads: [ MCWorkingCopy managersForClass: self configuration class do: [:mgr |  | pkg |              pkg := self packageSpec.              mgr repositoryGroup repositories do: [:repo |  pkg repositories repository: (repo asRepositorySpecFor: self) ].              pkg name: mgr packageName.              pkg fetchUsing: mcLoader.              ^true ] ].  ^truescheduleFetchFor: packageSpec reference: reference message: message  self loaderPolicy resetCacheGofer.  self preLoad: packageSpec.  (MetacelloDirective loadPackage: packageSpec externalReference: reference loader: self) addTo: self loadDirective.  self postLoad: packageSpec.  MetacelloNotification signal: messagetestProjectSpec  | project |  project := self projectSpec.  project     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     versionString: #stable;     operator: #<;     operator: nil;     loads: 'MyPackage';     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: #stable.  self assert: project operator identicalTo: #>=.  self assert: project loads equals: #('MyPackage' 'MyTests').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  self should: [ project includes: #() ] raise: Error.  self should: [ project requires: #() ] raise: Error.  self should: [ project answers: #() ] raise: Error.  project projectDo: [:prjct |  self assert: project identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ].  self should: [ project preLoadDoIt: '' ] raise: Error.  self should: [ project postLoadDoIt: '' ] raise: ErrorsetUp  super setUp.  self     setUpVersionReferences;     setUpMonticelloRepositorypackagesNeedSavingVisited: visitedProjects into: aCollection  self packages map valuesDo: [:pkg |  pkg packagesNeedSavingVisited: visitedProjects using: self repositories map values into: aCollection ]match: aVersionPattern  | patternVersion mySize patternSize components |  patternVersion := (self class fromString: aVersionPattern forPattern: true) versionComponents.  components := self versionComponents.  mySize := components size.  patternSize := patternVersion size.  mySize = patternSize ifFalse: [ mySize < patternSize ifTrue: [ ^false ].        (patternVersion at: patternSize) ~= '?' ifTrue: [ ^false ].        mySize := patternSize ].  1 to: mySize do: [:i |  | pattern |        pattern := (patternVersion at: i) asString.        pattern = '?' ifTrue: [ i = mySize ifFalse: [ ^self error: 'Invalid version match pattern: ' , aVersionPattern printString ] ] ifFalse: [ (pattern match: (components at: i) asString) ifFalse: [ ^false ] ] ].  ^trueversionString: anObject  versionString := anObject.  projectVersion := nilremovePackage: aString constructor: aVersionConstructor  aVersionConstructor removePackageForVersion: aStringconfigMethodOn: aStream indent: indent  aStream     tab: indent;     nextPutAll: 'spec ';     cr;     tab: indent + 1;     nextPutAll: 'name: ' , self name printString , ';'.  self configMethodBodyOn: aStream hasName: true cascading: false indent: indent + 1.  aStream nextPut: $.repositorySpecs  ^#()recordValidationCriticalWarning: aString callSite: callSite reasonCode: aSymbol  ^self recordValidationCriticalWarning: aString versionString: nil callSite: callSite reasonCode: aSymboltestMCProjectMergeSpec  | projectA projectB project repository |  projectA := self projectSpec     name: 'Project';     projectPackage: self project packageSpec;     className: 'ConfigurationOfProject';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  projectB := self projectSpec     name: 'Project';     projectPackage: self project packageSpec;     className: 'ConfigurationOfProjectB';     repository: 'http://example.com/repository' username: 'DaleHenrichs' password: 'secret';     repository: '/opt/gemstone/repo';     yourself.  project := projectA mergeSpec: projectB.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProjectB'.  self assert: project projectPackage name equals: project className.  self assert: project projectPackage file equals: project className.  repository := project repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := project repositories map at: '/opt/gemstone/repo' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := project repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'DaleHenrichs'.  self assert: repository password equals: 'secret'mergeMap  | map |  map := super mergeMap.  map at: #file put: file.  map at: #repositories put: self repositories.  map at: #preLoadDoIt put: preLoadDoIt.  map at: #postLoadDoIt put: postLoadDoIt.  ^mapmetacelloRegistrationHash  ^super metacelloRegistrationHash bitXor: self repositories metacelloRegistrationHashmerge: aSpec  aSpec mergeIntoMetacelloPackages: selfsetUp  super setUp.  self     setUpRepositories;     setUpExternalCore;     setUpExternalCoreX;     setUpSampleCore;     setUpBaselineOfExternalX;     setUpBaselineOfExternalXX;     setUpBaselineOfExternalXXX;     setUpConfigurationOfExternaldkh1;     setUpConfigurationOfExternaldkh2;     setUpConfigurationExternalRef;     setUpConfigurationOfExternalX;     setUpConfigurationOfExternalXX;     setUpConfigurationOfExternalXXX;     setUpConfigurationOfExternalIV;     setUpBaselineGithubReferenceXX;     setUpBaselineGithubReferenceIV;     setUpBaselineGithubReferenceV;     setUpBaselineGithubReferenceVI;     setUpBaselineGithubReferenceVII;     setUpBaselineGithubReferenceVIII;     setUpBaselineGithubReferenceIX;     setUpBaselineGithubReferenceXI;     setUpBaselineGithubReferenceXII;     setUpBaselineGithubReferenceXIII;     setUpMarianosImage;     setUpConfigurationOfConflict;     setUpInvalidConfigurations;     setUpConfigurationIssue32;     setUpBaselineIssue32;     setUpConfigurationIssue59;     setUpConfiguration63;     setUpLockConfigurations;     setUpConfigurationIssue84;     setUpConfigurationNextedIssue84;     setUpConfiguration181;     setUpBaselineIssue215;     setUpConfigurationIssue339;     setUpIssue399answers  ^#()packageNamed: aString ifAbsent: aBlock  | pkg |  (pkg := self spec packageNamed: aString ifAbsent: [  ]) == nil ifTrue: [ ^aBlock value ].  ^pkg referencedSpecrepositories  repositories ifNil: [ repositories := self project repositoriesSpec ].  ^repositoriespreLoad: packageOrVersionSpec  self subclassResponsibilitycacheRepository  ^self loaderPolicy cacheRepositorynonOverridable  ^super nonOverridable , #(#projectPackage #repositories)setUpConfigurationOfProjectIssue119dkh4: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.4'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion40Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version40Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoisLoadedToSpecAgainst: resolvedPackageAndProjectNames  (self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames) isLoadedToSpec: [:ignored |  ^true ].  ^falseoverrideRepositories  ^overrideRepositoriestestVersion10  | x y |  self assert: (x := (({(self versionClass fromString: '1.0') .         (self versionClass fromString: '0.7') .         (self versionClass fromString: '0.8') .         (self versionClass fromString: '0.9') .         (self versionClass fromString: '1.0.1')} sort: [:a :b |  a <= b ]) collect: [:each |  each versionString ]) asArray) equals: (y := #('0.7' '0.8' '0.9' '1.0' '1.0.1'))checkAllowed  projectSpecClass  ^MetacelloMCNamelessProjectSpeclesson12  ^Lesson title: 'Lesson 12' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline11:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline12:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version12:."In #baseline11: there is redundant information for each of the project references. In #baseline12: we use the #project:copyFrom:with: method to eliminate the need to specify the bulk of the project information twice. Evaluate and compare the results of the following expressions:"   (MetacelloProjectRefTutorialConfig project version: ''1.1'') load: ''Project-Core''.  (MetacelloProjectRefTutorialConfig project version: ''1.2'') load: ''Project-Core''.  (MetacelloProjectRefTutorialConfig project version: ''1.1'') load: ''Project-Tests''.  (MetacelloProjectRefTutorialConfig project version: ''1.2'') load: ''Project-Tests''.ProfStef next.'deleteSpec: aSpec  self list detect: [:aMember |  aMember spec = aSpec ] ifFound: [:member |  self list remove: member ]isPossibleBaseline  | vrsn |  (vrsn := self versionOrNil) == nil ifTrue: [ ^false ].  (vrsn allPackagesForSpecNamed: (self loadListForVersion: vrsn)) do: [:pkg |  pkg workingCopy == nil ifTrue: [ ^false ] ].  ^truesampleVersionStrings  ^#('1.0.0+-' '1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-0.3.7' '1.0.0-x.7.z.92') , #('1.0.0+build.1' '1.3.7+build.11.e0f985a') , #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0-rc.1+build.1' '1.0.0' '1.0.0+0.3.7' '1.3.7+build' '1.3.7+build.2.b8f12d7' '1.3.7+build.11.e0f985a') , #('1.0.0-alp-h-a' '1.0.0-r-c.1' '1.0.0+alp-h-a' '1.0.0+r-c.1')baselineGithubReferenceV: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>baselineGithubReferenceV:'.        spec baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  packageBlock value: selftestRepositorySpec  | repository |  repository := self repositorySpec     description: '/opt/gemstone/repository';     username: 'dkh';     password: 'password';     type: 'directory';     yourself.  self assert: repository name equals: repository description.  self assert: repository description equals: '/opt/gemstone/repository'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'.  self assert: repository type equals: 'directory'.  repository := self repositorySpec     description: '/opt/gemstone/repository';     yourself.  self assert: repository description equals: '/opt/gemstone/repository'.  self assert: repository type equals: 'directory'.  repository := self repositorySpec     description: 'http://example.com/repository';     yourself.  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'setUpBaselineGithubReferenceXIII  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefXIII-dkh.1'.  className := #BaselineOfGithubRefXIII.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineGithubReferenceVII:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceVII:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfodefaultDirectory  ^FileLocator imageDirectory asFileReferencedecrementVersionAt: index  | int |  int := self at: index.  (int := self at: index) isString ifFalse: [ int > 0 ifTrue: [ self at: index put: int - 1 ] ]handleLookupProjectSpec: exception  ^exception resume: ((self lookupProjectSpecFor: exception projectSpec) ifNil: [ ^exception resume: exception projectSpec ])repositoryForProject: aString username: username password: password  self repositoryForSpec: aString username: username password: passwordsubCommand  | firstArg |  firstArg := self argumentAt: 1.  self checkSubCommand: firstArg.  ^firstArgimport: aString constructor: aVersionConstructor  aVersionConstructor importForVersion: aStringmethodSectionsFrom: inputVersionStringOrSymbol do: methodSectionBlock  | constructor version fromVersionString |  constructor := self constructor.  version := project version: inputVersionStringOrSymbol.  fromVersionString := version versionString.  constructor extractMethodSectionsFor: fromVersionString.  constructor methodSectionsDo: methodSectionBlockbaseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/Project'.        spec project: 'Example ALL' with: [ spec                 className: 'MetacelloTutorialConfig';                 versionString: '1.0';                 loads: #('ALL');                 file: 'MetacelloTutorialConfig';                 repository: 'http://seaside.gemstone.com/ss/metacello' ].        spec           package: 'Project-Core' with: [ spec requires: 'Example ALL' ];           package: 'Project-Tests' with: [ spec requires: 'Project-Core' ] ]baseline12C: spec  < version: '1.2'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GeauxBeau' with: 'GeauxBeau-dkh.55';           yourself ]projectWith: projectAttributes  | project |  project := self projectClass new.  project projectAttributes: projectAttributes.  MetacelloVersionConstructor on: self project: project.  project loader: MetacelloNullRecordingMCSpecLoader new.  ^projectbaselineVersion10Issue136: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec package: 'GoferBeau' ]testProjectMergeSpec  | projectA projectB project |  projectA := self projectSpec     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     loads: #('MyPackage');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  projectB := self projectSpec     name: 'Project';     className: 'ConfigurationOfProjectB';     versionString: #stable;     operator: #<;     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  project := projectA mergeSpec: projectB.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProjectB'.  self assert: project versionString equals: #stable.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage' 'MyTests').  self assert: project preLoadDoIt value identicalTo: #preLoadDoItB.  self assert: project postLoadDoIt value identicalTo: #postLoadDoItBgetBlessing  ^blessingrepository: aStringOrMetacelloRepositorySpec  ^self projectReference repository: aStringOrMetacelloRepositorySpecspecs: specNames forPackageOrdering: aVersionSpec  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  specNames do: [:specName |  | spec |        spec := aVersionSpec packageNamed: specName ifAbsent: [ MetacelloNameNotDefinedError signal: 'project group, or package named: ' , specName printString , ' not found when used in requires: or includes: field of package: ' , self name printString , ' for version: ' , aVersionSpec versionString , ' of ' , aVersionSpec projectLabel , '.'.              nil ].        spec ifNotNil: [ packageOrProjectSpecs addAll: (spec resolveSpecsForPackageOrdering: aVersionSpec) ] ].  ^packageOrProjectSpecstestCopyToProject  | packages project referenceSpec |  packages := self packagesSpec.  packages add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself).  project := self projectSpec     name: 'ProjectCopy';     yourself.  referenceSpec := self project projectReferenceSpec     name: 'ProjectCopy';     projectReference: project;     yourself.  packages copy: 'Project' to: referenceSpec.  project := (packages packageNamed: 'ProjectCopy' ifAbsent: [ self assert: false ]) referencedSpec.  self assert: project name equals: 'ProjectCopy'.  self assert: project className equals: 'ConfigurationOfProjectA'.  self assert: project versionString equals: #stable.  self assert: project operator identicalTo: #>=.  self assert: project loads equals: #('MyPackage' 'MyTests').  self assert: project preLoadDoIt value identicalTo: #preLoadDoItB.  self assert: project postLoadDoIt value identicalTo: #postLoadDoItBisLocked  ^self registration lockedprojectPackageForProject: aBlock  self with: self root during: aBlocktestAddPackageB  | packages package |  packages := self packagesSpec.  packages add: {(self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself) .         (self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           includes: 'AndIncludedPackage';           answers: #(#('postload' 'postload answer'));           file: 'Package-dkh.2';           yourself)}.  package := packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: package name equals: 'Package'.  self assert: package requires equals: #('AndAnotherPackage').  self assert: package includes equals: #('AndIncludedPackage').  self assert: package answers equals: #(#('postload' 'postload answer')).  self assert: package file equals: 'Package-dkh.2'.  self assert: package preLoadDoIt value identicalTo: nil.  self assert: package postLoadDoIt value identicalTo: niltestAsRepositorySpecFor  | project testBlock |  project := self project.  testBlock := [:pkg :expectedType1 :expectedType2 |  | repoSpec1 repo repoSpec2 |  repoSpec1 := pkg repositorySpecs first.  self assert: repoSpec1 type equals: expectedType1.  repo := repoSpec1 createRepository.  repoSpec2 := repo asRepositorySpecFor: project.  self assert: repoSpec2 type equals: expectedType2.  expectedType1 = expectedType2 ifTrue: [ self assert: repoSpec1 description equals: repoSpec2 description ] ifFalse: [ self assert: (repoSpec1 description copyFrom: 'server://' size + 1 to: repoSpec1 description size) equals: repoSpec2 description ] ].  testBlock value: ((project version: '1.0-baseline') packageNamed: 'Example-Core') value: 'directory' value: 'directory'.  testBlock value: ((project version: '1.3-baseline') packageNamed: 'Example-Core') value: 'ftp' value: 'ftp'.  testBlock value: ((project version: '1.4-baseline') packageNamed: 'Example-Core') value: 'http' value: 'http'.  testBlock value: ((project version: '1.5-baseline') packageNamed: 'Example-Core') value: 'dictionary' value: 'dictionary'testFileTreeRepository  | project pkg repoSpec repo fileUtils workingDir tempDir repoDir |  fileUtils := MCFileTreeFileUtils current.  workingDir := fileUtils default.  tempDir := fileUtils directoryFromPath: 'temp' relativeTo: workingDir.  [ fileUtils ensureDirectoryExists: tempDir.  repoDir := fileUtils directoryFromPath: 'repo' relativeTo: tempDir.  fileUtils ensureDirectoryExists: repoDir.  project := self project.  pkg := (project version: '1.6-baseline') packageNamed: 'Example-Core'.  repoSpec := pkg repositorySpecs first.  self assert: repoSpec type equals: 'filetree'.  repo := repoSpec createRepository.  self assert: repo class identicalTo: (testingEnvironment at: #MCFileTreeRepository ifAbsent: [  ]).  MetacelloNotification signal: 'testFileTreeRepository: ' , (fileUtils directoryFromPath: 'temp/repo' relativeTo: fileUtils default) fullName.  self assert: repo description equals: 'filetree://' , (fileUtils directoryFromPath: 'temp/repo' relativeTo: fileUtils default) fullName ] ensure: [ (fileUtils directoryExists: tempDir) ifTrue: [ fileUtils deleteAll: tempDir ] ]recordValidationWarning: aString callSite: callSite reasonCode: aSymbol  ^self recordValidationWarning: aString versionString: nil callSite: callSite reasonCode: aSymbolglobalNamed: globalName ifAbsent: absentBlock  ^Smalltalk at: globalName ifAbsent: absentBlockcopyFrom: start to: stop  | newSize new j |  newSize := stop - start + 1.  new := self species new: newSize.  j := 0.  start to: stop do: [:i |  new at: j + 1 put: (self at: i).        j := j + 1 ].  ^newattributeMap  attributeMap == nil ifTrue: [ attributeMap := Dictionary new ].  ^attributeMapgtInspectorLoadDirectivesIn: composite  < gtInspectorPresentationOrder: 1>  composite tree     title: 'Load directives';     display: [ {self} ];     format: [:each |  each label ifEmpty: [ each title ] ];     rootsExpanded;     children: #gtInspectorChildren;     filterOn: [:text :each |  '*' , text , '*' match: each label ]smalltalkhubUser: userName project: projectName  self repository: 'http://smalltalkhub.com/mc/' , userName , '/' , projectName , '/main'testVersion15  self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0-beta.1')project  project == nil ifTrue: [ project := self projectClass new ].  ^projectfetch: required  ^self execute: #fetch: args: {required}packageSpec  ^self packageSpecClass for: selfgroupSpecClass  ^MetacelloGroupSpecmonticelloRepository  ^monticelloRepositoryabort  ^abortexpandToLoadableSpecNames: nameList  ^self spec expandToLoadableSpecNames: nameListtestRemoveProjectB  | packages project projectReferenceSpec removed |  packages := self packagesSpec.  packages add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  packages remove: {(self projectReferenceSpec           name: 'Project';           yourself)}.  removed := false.  packages packageNamed: 'Project' ifAbsent: [ removed := true ].  self assert: removedprintOn: aStream  | label |  self configuration class printOn: aStream.  aStream nextPut: $(.  self versions do: [:vrsn |  aStream nextPutAll: vrsn versionString.        vrsn spec ~~ nil ifTrue: [ (label := vrsn spec projectLabel) isEmpty ifFalse: [ aStream nextPutAll: ' [' , label , ']' ] ].        aStream           nextPut: $,;           space ].  aStream nextPut: $)attributeOrPath  ^self parent == nil ifTrue: [ self attributes size == 1 ifTrue: [ self attributes first ] ifFalse: [ self attributes ] ] ifFalse: [ self attributePath ]selectorForPragma: aPragma  ^aPragma selectorpreLoadDoItForPackage: aSymbol  self preLoadDoItForSpec: aSymbolsqueaksource: projectName  self repository: 'http://www.squeaksource.com/' , projectNametestHasVersion  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--version=stable').  self assert: cli hasVersion.  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self deny: cli hasVersionmethodSelectorAndPragma: aSelector imports: importList on: strm  strm     nextPutAll: aSelector asString , ' spec';     cr;     tab;     nextPutAll: '<baseline>'load  ^self execute: #load: args: #(#())doLoad  configurationExternalRef092: spec  < version: '0.9.2'>  spec for: #common do: [ spec blessing: #version.        spec description: 'MetacelloScriptingResource>>configurationExternalRef092:'.        spec project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 version: '0.9.2';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]setUpIssue95  self     setUpConfigurationOfProjectInfinite;     setUpConfigurationOfProjectLoop;     setUpConfigurationOfProjectIssue95;     yourselfversions  ^self map values asArray sort: [:a :b |  a <= b ]baseline11: spec  < version: '1.1-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/Project'.        spec           project: 'Example Default' with: [ spec                 className: 'MetacelloTutorialConfig';                 versionString: '1.1';                 loads: #('default');                 file: 'Metacello-Tutorial';                 repository: 'http://seaside.gemstone.com/ss/metacello' ];           project: 'Example Tests' with: [ spec                 className: 'MetacelloTutorialConfig';                 versionString: '1.1';                 loads: #('Tests');                 file: 'Metacello-Tutorial';                 repository: 'http://seaside.gemstone.com/ss/metacello' ].        spec           package: 'Project-Core' with: [ spec requires: 'Example Default' ];           package: 'Project-Tests' with: [ spec requires: #('Project-Core' 'Example Tests') ] ]configuration: anObject  configuration := anObjectcopy: aMemberSpec  self addMember: aMemberSpecpackageForVersion: aString overrides: aBlock  | spec |  spec := self project packageSpec     name: aString;     yourself.  self root packages add: spec.  self with: spec during: aBlockloadType  loadType == nil ifTrue: [ ^#atomic ].  ^loadTypeprojectPackage  projectPackage ifNil: [ self className ifNil: [ ^nil ].        projectPackage := self project packageSpec.        projectPackage name: self className.        self getFile ifNotNil: [ projectPackage file: self file ].        projectPackage repositories: self getRepositories ].  ^projectPackageapplyIncludesTo: orderedSpecs for: pkgSpec firstTime: firstTime for: aVersionSpec  | movedSpecs baseIndex |  movedSpecs := Set new.  baseIndex := orderedSpecs indexOf: pkgSpec.  (pkgSpec includeSpecNamesForPackageOrdering: aVersionSpec) do: [:includedSpec |  | includedSpecName spec |        includedSpecName := includedSpec name.        spec := orderedSpecs detect: [:aSpec |  aSpec name = includedSpecName ] ifNone: [  ].        (self slideIn: orderedSpecs spec: spec baseIndex: baseIndex seen: IdentitySet new firstTime: firstTime for: aVersionSpec) ifTrue: [ movedSpecs add: spec name ] ].  ^movedSpecsversionString  ^versionStringcacheGofer  cacheGofer == nil ifTrue: [ cacheGofer := Gofer new.        cacheGofer disablePackageCache.        cacheGofer repository: self cacheRepository ].  ^cacheGoferclassNameArg: anObject  classNameArg := anObjectcacheRepository: aRepositoryDescription  self options at: #cacheRepository put: aRepositoryDescriptionbaseline20MethodSourceFan  ^(self class sourceCodeAt: #baseline20Fan:) asStringsetUpBaselineGithubReferenceVIII  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefVIII-dkh.1'.  className := #BaselineOfGithubRefVIII.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineGithubReferenceV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceV:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInforesolvePackageNames  packages := Dictionary new.  self resolveToLoadableSpecs.  ^packages values collect: [:pkg |  pkg name ]title  self subclassResponsibilitysetUpBaselineGithubReferenceVI  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefVI-dkh.1'.  className := #BaselineOfGithubRefVI.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationGithubReferenceXXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceXXX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfodownloadJSON: url username: username pass: pass  | jsonFileName jsonFile errorFileName |  jsonFileName := self tempFileFor: 'tags-' , self processPID suffix: 'json'.  errorFileName := self downloadBasicFile: url to: jsonFileName username: username pass: pass.  [ jsonFile := self fileHandleOn: jsonFileName.  jsonFile containingDirectory readOnlyFileNamed: jsonFile localName do: [:fileStream |  | result |        result := (Smalltalk at: #MCFileTreeJsonParser) parseStream: fileStream self deleteFileNamed: errorFileName.        ^result ] ] on: Error do: [:ex |  self error: 'Error during download (' , ex description , ') please check the file ' , errorFileName printString , ' for error message.' ]setUpConfigurationOfProjectIssue119dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion10Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version10Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfocurrentVersionInfoFor: packageSpec  | cacheKey vi |  cacheKey := packageSpec file.  ^MetacelloPlatform current stackCacheFor: #currentVersionInfo at: cacheKey doing: [:cache |  vi := packageSpec currentVersionInfo.        cache at: cacheKey put: vi ]projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool  ^aMetacelloScriptEngine getConfigurationProjectUnconditionalLoad: aBooldefaultVersionString  ^self class defaultVersionStringfileDirectoryClass  ^Smalltalk at: #FileDirectoryversion11Issue136: spec  < version: '1.1' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec package: 'GoferBeau' with: 'GoferBeau-dkh.25' ]project  ^project ifNil: [ | constructor loader |        constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.        project := constructor project.        loader := MetacelloNullRecordingMCSpecLoader new.        loader evalDoits: true.        project loader: loader.        project ]version20Issue283: spec  < version: '2.0'>  spec for: #common do: [ spec blessing: #release.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec package: 'GoferFoo' with: 'GoferFoo-lr.2' ]configShortCutMethodOn: aStream member: aMember indent: indent  | hasVersionString hasOperator hasProjectPackage hasLoads hasClassName hasPreLoadDoIt hasPostLoadDoIt |  hasClassName := self hasClassName.  hasVersionString := self configHasVersionString.  hasOperator := operator ~~ nil.  hasProjectPackage := self hasRepository or: [ hasClassName & (self getFile ~~ nil or: [ className ~= self name ]) ].  hasLoads := self loads ~~ nil.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasClassName | hasOperator | hasProjectPackage | hasLoads | hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ (aMember methodUpdateSelector == #copy: or: [ aMember methodUpdateSelector == #with: ]) ifTrue: [ aStream                 nextPutAll: 'with: [';                 cr ] ifFalse: [ aStream                 nextPutAll: 'overrides: [';                 cr ].        aStream           tab: indent;           nextPutAll: 'spec'.        self configMethodBodyOn: aStream indent: indent fromShortCut: true.        aStream nextPutAll: ' ]'.        ^self ].  hasVersionString ifTrue: [ | vs |        vs := self versionString.        aStream nextPutAll: 'with: '.        vs isSymbol ifTrue: [ aStream nextPut: $# ].        aStream nextPutAll: vs asString printString ]isBaselineName  ^self baselineOrConfigurationName matchesRegex: 'BaselineOf.+'lastVersion  | coll |  coll := (self map values asArray sort: [:a :b |  a <= b ]) asOrderedCollection.  coll isEmpty ifTrue: [ ^nil ].  ^coll lastversionNumberClass  versionNumberClass ifNil: [ versionNumberClass := MetacelloVersionNumber ].  ^versionNumberClassattribute: anObject  self deprecated: 'Use attributes: instead'.  self attributes size > 1 ifTrue: [ self error: 'invalid use of attribute:' ].  attributes := OrderedCollection with: anObjectbaselineGoo300Issue156Configuration: spec  < version: '3.0.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferGoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar.branch-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           yourself ]setUpConfigurationOfExternaldkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternal-dkh.1'.  className := #ConfigurationOfExternal.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfExternal090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfExternal090:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoversion105ProjectToolBox: spec  < version: '1.0.5-baseline'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec repository: 'http://www.example.com/ob' ] ]baselineGoo500Issue156Configuration: spec  < version: '5.0.0'>  spec for: #common do: [ spec           baseline: 'Goo' with: [ spec repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           import: 'Goo' ]valueHolderSpecClass  ^MetacelloValueHolderSpecpostLoadDoIt  ^postLoadDoItstoreVersion: aVersion  ^self localRepository storeVersion: aVersionto  ^toloadPostloadDirective: aPostloadDirective  | block |  (block := aPostloadDirective spec postLoadDoItBlock) ~~ nil ifTrue: [ aPostloadDirective evaluateSupplyingAnswers: [ block valueWithPossibleArgs: (Array with: aPostloadDirective loader with: aPostloadDirective spec) ].        MetacelloNotification signal: 'Evaluated -> ' , aPostloadDirective spec label , ' >> ' , aPostloadDirective spec postLoadDoIt value asString ]versionString  ^versionStringisPartiallyCurrent: notLoadedMatters useEquality: useEquality  self subclassResponsibilityconfigMethodBasicOn: aStream last: last indent: indent  | values lastIndex lastBlock |  last ifTrue: [ values := {self getBlessing .         self getDescription .         self getPreLoadDoIt .         self getPostLoadDoIt .         self getAuthor .         self getTimestamp}.        1 to: values size do: [:index |  (values at: index) ~~ nil ifTrue: [ lastIndex := index ] ].        lastBlock := [:arg |  arg = lastIndex ] ] ifFalse: [ lastBlock := [:arg |  false ] ].  self configMethodValueOn: aStream for: self getBlessing selector: 'blessing:' last: (lastBlock value: 1) indent: indent.  self configMethodValueOn: aStream for: self getDescription selector: 'description:' last: (lastBlock value: 2) indent: indent.  self configMethodValueOn: aStream for: self getPreLoadDoIt selector: 'preLoadDoIt:' last: (lastBlock value: 3) indent: indent.  self configMethodValueOn: aStream for: self getPostLoadDoIt selector: 'postLoadDoIt:' last: (lastBlock value: 4) indent: indent.  self configMethodValueOn: aStream for: self getAuthor selector: 'author:' last: (lastBlock value: 5) indent: indent.  self configMethodValueOn: aStream for: self getTimestamp selector: 'timestamp:' last: (lastBlock value: 6) indent: indentloader  ^self spec loaderupdateForSpawnMethod: sourceSpec  repositories := className := operator := loads := projectPackage := nil.  sourceSpec ~~ nil ifTrue: [ versionString := sourceSpec versionString ]ensureDirectoryExists: aDirectoryHandle  ^aDirectoryHandle     ensureCreateDirectory;     yourselfgtInspectorPackagesIn: composite  < gtInspectorPresentationOrder: 40>  composite list     title: 'Packages';     display: [ (self spec packages packageSpecsInLoadOrderFor: self spec) select: [:each |  each isKindOf: MetacelloPackageSpec ] ]registrationForClassNamed: aClassName ifAbsent: absentBlock  ^self registrationForExactClassNamed: aClassName ifAbsent: [ | baseName |        baseName := MetacelloScriptEngine baseNameOf: aClassName.        self configurationRegistry at: 'ConfigurationOf' , baseName ifPresent: [:registration |  ^registration ].        self baselineRegistry at: 'BaselineOf' , baseName ifPresent: [:registration |  ^registration ].        absentBlock value ]resolveToLoadableSpec  ^selfspecListSelect: aBlock  | newCollection |  newCollection := OrderedCollection new.  self specListDo: [:each |  (aBlock value: each) ifTrue: [ newCollection add: each ] ].  ^newCollectionhandleNotificationsForAction: actionBlock  [ [ [ actionBlock on: MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad , MetacelloProjectSpecLoadedNotification , MetacelloScriptEnsureProjectLoadedForDevelopment , MetacelloLookupBaselineSpecForEnsureLoad do: [:ex |  ex handleResolutionFor: self ] ] on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade , MetacelloAllowConflictingProjectUpgrade do: [:ex |  ex handleResolutionFor: self ] ] on: MetacelloAllowLockedProjectChange do: [:ex |  ex handleResolutionFor: self ] ] on: Warning do: [:ex |  self handleWarning: ex ]ensureLoadUsing: aLoader  [ super ensureLoadUsing: aLoader ] on: MetacelloIgnorePackageLoaded do: [:ex |  ex resume: ex packageSpec name = self name ]isValid  ^trueoperationString  ^'load with conflicts'projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool  ^aMetacelloScriptEngine getBaselineProjectUnconditionalLoad: trueversion07: spec  < version: '0.7' imports: #('0.7-baseline')>  spec for: #common do: [ spec blessing: #release.        spec           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1';           package: 'Example-Core' with: 'Example-Core-anon.12';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1' ]sampleRepositoryContents  ^#('Sample-CoreX-dkh.1')customProjectAttributes  ^#(#custom)resolveSpecsForPackageOrdering: aVersionSpec  ^{self}mergeSpec: anotherSpec  ^super mergeSpec: anotherSpec asBaselineProjectSpecoperationString  ^'upgrade to'downloadJSONTags  | tagsUrl jsonObject |  tagsUrl := self projectTagsUrlFor: self projectPath.  jsonObject := MetacelloPlatform current downloadJSON: tagsUrl username: self class siteUsername pass: self class sitePassword.  ^self normalizeTagsData: jsonObjectversion42Symbolic: spec  < version: '4.2'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #release.        spec           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           package: 'GoferFaux' with: 'GoferFaux-tg.32';           yourself ]validateProjectCreationFrom: aConfigurationClass onError: aBlock  [ ^aConfigurationClass project ] on: Error , MetacelloValidationNotification , MetacelloErrorInProjectConstructionNotification do: [:ex |  (ex isKindOf: MetacelloValidationNotification) ifTrue: [ self validationReport add: ex issue.              ex resume ].        (ex isKindOf: MetacelloErrorInProjectConstructionNotification) ifTrue: [ self recordValidationError: 'Error creating version: ' , ex versionString , ' error: ' , ex exception description , ' to reproduce evalutate the following: ''[' , self configurationClass name asString , ' project ] on: MetacelloErrorInProjectConstructionNotification do: [:ex | ex resume: true ]''' callSite: #validateProjectCreationFrom:onError: reasonCode: #versionCreationError.              ex resume: false ].        ^aBlock value: ex ]string: aString includesSubstring: aSubstring  ^aString includesSubstring: aSubstringdescription  description == nil ifTrue: [ ^self project valueHolderSpec           value: '';           yourself ].  ^descriptionsetBaselineRepositoryDescription: aListOrRepositoryDescriptions  hasMethodForSymbolicVersion: versionSymbol  ^(self constructor extractSymbolicVersionPragmas at: versionSymbol ifAbsent: [ ^false ]) size > 0setUpConfigurationIssue59  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfIssue59-dkh.1'.  className := #ConfigurationOfIssue59.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version10Issue59:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue59:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionNumberClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionNumberClass) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfotestVersion19  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1')testRemovePackageA  | packages removed |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages remove: (self packageSpec           name: 'Package';           yourself).  removed := false.  packages packageNamed: 'Package' ifAbsent: [ removed := true ].  self assert: removedprojectTagsUrlFor: projectPath2  ^'https://bitbucket.org/api/1.0/repositories/' , projectPath2 , '/tags'fetch: required  self fetchRecord: [:version |  required isEmpty ifTrue: [ version fetch ] ifFalse: [ version fetch: required ] ] required: requiredpreloadForCore  MetacelloNotification signal: '#preloadForCore executed'version123ProjectToolBox: spec  < version: '1.2.3-baseline'>  spec for: #common do: [ spec project: 'Example Project' with: [ spec                 className: 'MetacelloExampleProjectConfig';                 repository: 'http://www.example.com/ob';                 repository: 'http://www.example.com/or' ] ]setUpBaselineIssue399  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfIssue399-dkh.1'.  className := #BaselineOfIssue399.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineIssue399:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue399:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfovalidateVersionSpecForSymbolicVersion: versionSpec symbolicVersion: symbolicVersionString  | blessing |  versionSpec blessing value == #broken ifTrue: [ ^self ].  blessing := versionSpec blessing value.  (symbolicVersionString == #development and: [ blessing ~~ #development ]) ifTrue: [ self recordValidationWarning: 'Symbolic version ' , symbolicVersionString printString , ' refers to a version' , versionSpec versionString printString , ' whose blessing ' , blessing printString , ' is not #development' versionString: versionSpec versionString callSite: #validateVersionSpecForSymbolicVersion:symbolicVersion: reasonCode: #notDevelopmentVersion ]invalidConfiguration20: spec  < version: '2.0.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>invalidConfiguration20: ... missing version:'.        spec project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]saltypickle: projectName  self repository: 'http://squeak.saltypickle.com/' , projectNameaddSymbolicSection: attribute version: versionString  self methodSpec methodSections do: [:methodSection |  methodSection attributes = {attribute} ifTrue: [ methodSection versionString: versionString.              ^self ] ].  self methodSpec addMethodSection: attribute versionString: versionStringversion130ProjectToolBox: spec  < version: '1.3.0-baseline'>  spec for: #common do: [ spec           project: 'Example Project' with: [ spec                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadDoIt;                 postLoadDoIt: #postloadDoIt;                 repository: 'http://www.example.com/ob' ];           project: 'Copy Project' copyFrom: 'Example Project' with: [ spec repository: 'http://www.example.com/or' ] ]configMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent  aMember methodUpdateSelector == #remove: ifTrue: [ aStream nextPutAll: 'removePackage: ' , self name printString ] ifFalse: [ self configShortCutMethodBodyOn: aStream member: aMember indent: indent ].  lastCascade ifTrue: [ aStream nextPut: $. ] ifFalse: [ aStream           nextPut: $;;           cr ]isCriticalWarning  ^falseaddMember  ^MetacelloAddMemberSpec for: self projectprojectLabel  ^'baseline'isLoadedMatchConstraints  ^self spec isLoadedMatchConstraintsprojectPackage  ^nilconfigurationClass  ^configurationClassrepositoryUrl  ^self argumentAt: 2loadUsing: aLoaderDirective gofer: aGofer  aLoaderDirective loadExplicitLoadDirective: self gofer: aGoferversionClass  ^self subclassResponsibilityload  self subclassResponsibilitytestSpecialMatch  self assert: ((self versionClass fromString: '1.1') match: '?').  self assert: ((self versionClass fromString: 'alpha') match: '?').  self assert: ((self versionClass fromString: '1.1.1.1.1') match: '?').  self assert: ((self versionClass fromString: '1.alpha5') match: '?').  self assert: ((self versionClass fromString: '1.1') match: '*.?').  self assert: ((self versionClass fromString: '1.1') match: '?').  self assert: ((self versionClass fromString: '10.1.1.1.1') match: '?').  self deny: ((self versionClass fromString: '1.1') match: '*.*.?').  self assert: ((self versionClass fromString: '1.1.1') match: '*.?')computeVersionStatus: matchBlock  self computeVersionStatus: (self expandToLoadableSpecNames: #('ALL')) matchBlock: matchBlockrepositoryMap: anObject  repositoryMap := anObjectvalue: anObject constructor: aVersionConstructor  aVersionConstructor valueForValueHolder: anObjecttestAddGroupA  | packages group |  packages := self packagesSpec.  packages add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  packages add: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself).  group := packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self deny: (group includes includes: 'Core').  self assert: (group includes includes: 'Tests')possibleVersions  ^self project symbolicVersionSymbolsreasonCode: anObject  reasonCode := anObjectprojectReferenceSpec  ^self projectReferenceSpecClass for: selfcopyOnWrite: aBlock  | copy |  copy := self copy.  aBlock value: copy.  ^copyprojectTagsUrlFor: aProjectPath  self subclassResponsibilityconfigurationExternalRef090: spec  < version: '0.9.0'>  spec for: #common do: [ spec blessing: #version.        spec description: 'MetacelloScriptingResource>>configurationExternalRef090:'.        spec project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 version: '0.9.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]packageNamed: aString forMap: map ifAbsent: absentBlock  ^self packageNamed: aString forLoad: true forMap: map ifAbsent: absentBlockclearVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages  versionSpec specListProjectDo: [:spec |  updateProjects ifTrue: [ | fullProjectReferenceSpec fullProjectSpec |              (fullProjectReferenceSpec := fullVersionSpec packageNamed: spec name) ~~ nil ifTrue: [ fullProjectSpec := fullProjectReferenceSpec projectReference.                    fullProjectSpec versionString == nil ifTrue: [ spec projectReference versionString: '' ] ] ] ] packageDo: [:spec |  updatePackages ifTrue: [ spec getFile ~~ nil ifTrue: [ spec file: '' ] ] ] groupDo: [:ignored |   ]resolveToPackagesIn: aVersionSpec into: packages visited: visited  self resolveToPackagesIn: aVersionSpec andProjects: false into: packages visited: visitedloaderPolicy: anObject  loaderPolicy := anObjectdefaultAction  ^trueaddToMetacelloPackages: aMetacelloPackagesSpec  | spec |  spec := aMetacelloPackagesSpec project projectReferenceSpec     name: self name;     projectReference: self copy;     yourself.  aMetacelloPackagesSpec addMember: (aMetacelloPackagesSpec addMember           name: spec name;           spec: spec;           yourself)version10: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #beta.        spec           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1' ]clearMemberMap  memberMap := nilversion20Issue156: spec  < version: '2.0.0'>  spec for: #common do: [ spec           configuration: 'Goo' with: [ spec                 versionString: '4.0.0';                 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           yourself ]version51MethodSourceFoo  ^(self class sourceCodeAt: #version51Foo:) asStringtestVersion21  self deny: (MetacelloVersionNumber fromString: '') > (MetacelloVersionNumber fromString: '0').  self assert: (MetacelloVersionNumber fromString: '') < (MetacelloVersionNumber fromString: '0').  self assert: (MetacelloVersionNumber fromString: '') equals: (MetacelloVersionNumber fromString: '')versionDirectivesDepthFirstDo: aBlock  self loadDirectives do: [:directive |  directive versionDirectivesDepthFirstDo: aBlock ].  aBlock value: selftestDefaultDictionary  | defaultDictionary |  defaultDictionary := Dictionary new.  MetacelloPlatform current useStackCacheDuring: [:dict |  self           cachedReturnOfValue;           collectionCacheKey;           cacheNil;           directReturnOfValue;           mixedStack;           mixedStackCall ] defaultDictionary: defaultDictionary.  self assert: (defaultDictionary includesKey: #cached).  self assert: (defaultDictionary includesKey: #cacheNil).  self assert: (defaultDictionary includesKey: #collection).  self assert: (defaultDictionary includesKey: #direct).  self assert: (defaultDictionary includesKey: #mixed).  self assert: (defaultDictionary includesKey: #mixedStack)loadedInImage: anObject  self shouldBeMutable.  loadedInImage := anObjecttestVersion07  | v1 v2 |  v1 := self versionClass fromString: '3.0.0'.  v2 := self versionClass fromString: '2'.  self assert: v1 > v2normalizeTagsData: jsonObject  | tagDict |  jsonObject isDictionary ifTrue: [ jsonObject at: 'message' ifPresent: [:errorString |  self error: 'Error accessing tags for github project: ' , self projectPath printString , ' -> ' , errorString printString ] ].  tagDict := Dictionary new.  jsonObject do: [:tagObject |  | tag commit |        tag := tagObject at: 'name'.        commit := tagObject at: 'commit'.        tagDict at: tag put: (commit at: 'sha') ].  ^tagDictinitialize  groups := Set new.  packages := Set new.  projects := Set newversion100Issue339: spec  < version: '1.0.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>version100Issue339:'.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec package: 'Issue339' with: 'Issue339-JanKurs.1' ]latestVersionMatching: versionPatternString includedBlessings: included excludedBlessings: excludedBlessings  | excluded |  excluded := excludedBlessings asSet copy.  excluded removeAllFoundIn: included.  ^(self map values select: [:version |  (included isEmpty or: [ included includes: version blessing ]) and: [ (excluded includes: version blessing) not and: [ version versionNumber match: versionPatternString ] ] ]) detectMax: [:version |  version ]valueHolderSpec  ^self valueHolderSpecClass for: selffindWorkingCopy  | wcs |  wcs := MCWorkingCopy allManagers select: [:each |  self matchesWorkingCopy: each ].  wcs isEmpty ifTrue: [ ^nil ].  ^wcs detectMax: [:ea |  ea package name size ]configurationNameFrom: baseName  ^self class configurationNameFrom: baseNameisWarning  ^truerepoPath: anObject  repoPath := anObjecttestCheckInputForInstallSubcommand  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--version=master').  self should: [ cli checkInputForInstallSubcommand ] raise: Exit.  cli := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'Foo').  self should: [ cli checkInputForInstallSubcommand ] raise: ExitisError  ^truesetPostLoadDoIt: aSymbol  postLoadDoIt := aSymbolintroductionText  ^'Dive down into the MetacelloToolBox API to take a closer look at the implementation of the development support methods.'primeRegistryFromImage: configurationClasses baselineClasses: baselineClasses  self primeRegistryFromImage: configurationClasses baselineClasses: baselineClasses prioritizeConfiguration: falsevalidateMergeForSpec: aSpec  aSpec class = self class ifFalse: [ self error: 'The project spec ' , self name printString , ' in project ' , self project label , ' has incompatible specs. ' , aSpec class name asString , ' and ' , self class name asString , ' are not compatible.' ]copyForRegistration: aMetacelloProjectRegistration onWrite: aBlock  | copy |  aMetacelloProjectRegistration baselineProjectSpecIfPresent: [:spec |  copy := spec copy.        aBlock value: copy.        aMetacelloProjectRegistration baselineProjectSpec: copy ] ifAbsent: [ aMetacelloProjectRegistration configurationProjectSpecIfPresent: [:spec |  copy := spec copy.              aBlock value: copy.              aMetacelloProjectRegistration configurationProjectSpec: copy ] ifAbsent: [ aBlock value: nil ] ]map  versionMap ifNil: [ ^Dictionary new ].  ^versionMapdefaultPackageNames  self packages packageNamed: 'default' ifAbsent: [ ^self packageNames ].  ^#('default')preLoadDoIt  ^preLoadDoItsetUpIssue399CoreExternaldkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'Issue399-Core-dkh.1'.  className := #Issue399External.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #Object category: reference packageName instVarNames: #() comment: '')}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfointroductionText  ^'This tutorial covers some of the methods that can be found in the MetacelloToolBox.CREATE PROJECT	1. Create configuration and baseline version	2. Create development version	3. Validate and save configuration in project repository	DEVELOPMENT	4. Checkpoint save	5. Integrate code contributions	6. Compare versionsRELEASE	7. Release development version	8. Create new development versionFor convenience, a number of the methods covered in these sections can be found in the ''development support'' category on the class-side of MetacelloBaseConfiguration." 	Smalltalk tools browser openOnClass: MetacelloBaseConfiguration class selector: #DevelopmentProcess."After deciding which of the development support methods you will use in your project, copy the methods of interest to the the class-side of your own configuration or implement your own ''development support'' methods using the MetacelloToolBox API:"	HelpBrowser openOn: MetacelloAPIDocumentation"'operator: anObject constructor: aVersionConstructor  aVersionConstructor operatorForProject: anObjecttitle  ^'preload'linearLoadPackageSpec: packageSpec gofer: gofer  MetacelloPlatform current do: [ | loadBlock goferLoad answers resolvedReference repo |        resolvedReference := self resolvePackageSpec: packageSpec gofer: gofer.        resolvedReference ifNil: [ ^self ].        loadBlock := [ self preLoad: packageSpec.        goferLoad := MetacelloGoferLoad on: MetacelloGofer new.        goferLoad addResolved: resolvedReference.        goferLoad execute.        MetacelloPlatform current clearCurrentVersionCache.        self postLoad: packageSpec ].        (answers := packageSpec answers) notEmpty ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ] ifFalse: [ loadBlock value ].        repo := resolvedReference repository.        self hasRepositoryOverrides ifTrue: [ repo := self loaderPolicy repositoryMap at: resolvedReference name ifAbsent: [ resolvedReference repository ].              resolvedReference workingCopy repositoryGroup addRepository: repo ] ifFalse: [ resolvedReference workingCopy repositoryGroup addRepository: resolvedReference repository ].        MetacelloNotification signal: 'Loaded -> ' , resolvedReference name , ' --- ' , repo repositoryDescription , ' --- ' , resolvedReference repository description ] displaying: 'Loading ' , packageSpec filerenggli: projectName  self repository: 'http://source.lukas-renggli.ch/' , projectNametestVersion24  self assert: (MetacelloVersionNumber fromString: '3.0.3.-rc.1') ~= (MetacelloVersionNumber fromString: '3.0.0.3-rc.1').  self assert: (MetacelloVersionNumber fromString: '1.0.0.1.0.0') equals: (MetacelloVersionNumber fromString: '1.0.0.1').  self assert: (MetacelloVersionNumber fromString: '1.0.0.1') ~= (MetacelloVersionNumber fromString: '1..1')remove: aSpec  self subclassResponsibilitysetUpConfigurationOfExternalX  | versionInfo |  versionInfo := self setUpConfigurationOfExternalXdkh1.  versionInfo := self setUpConfigurationOfExternalXdkh2: {versionInfo}repositories  ^self referencedSpec repositoriescommitIdFor: aMCWorkingCopy ifFound: aBlockClosure  (aMCWorkingCopy repositoryGroup includes: self) ifTrue: [ aBlockClosure value: self commitId ]loadUsing: aLoader gofer: gofer  ^self subclassResponsibilitylockConfiguration10: spec  < version: '1.0.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>lockConfiguration10: '.        spec configuration: 'ExternalX' with: [ spec                 version: '0.9.0';                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]testAlphaNumericVersion4  self assert: (self versionClass fromString: '2.9.9-alpha.2') < (self versionClass fromString: '2.9.9')baselineProjectSpecIfAbsent: absentBlock  ^baselineProjectSpec ifNil: absentBlockpreLoadDoIt: anObject  anObject setPreLoadDoItInMetacelloSpec: selfstableVersionC: spec  < symbolicVersion: #stable>  spec for: #common do: [ spec version: '4.2' ].  spec for: #'platformVersion1.x' do: [ spec version: '4.0' ].  spec for: #'platformVersion1.0.x' do: [ spec version: '4.1' ].  spec for: #'platformVersion1.1.x' do: [ spec version: '4.2' ].  spec for: #'platformVersion1.2.x' do: [ spec version: '4.3' ]workingCopyName  | wc |  (wc := self workingCopy) == nil ifTrue: [ ^nil ].  wc ancestry ancestors isEmpty not ifTrue: [ ^wc ancestry ancestors first name ].  ^nilcollect: aBlock  | newCollection |  newCollection := OrderedCollection new.  self do: [:each |  newCollection add: (aBlock value: each) ].  ^newCollectionpostLoadDoIt  ^nilmatchesWorkingCopy: aWorkingCopy  | pFilename |  (pFilename := self packageFilename) == nil ifTrue: [ ^self error: 'cannot match working copy' ].  (self class packageFileName: pFilename matchesPackageName: aWorkingCopy package name) ifTrue: [ aWorkingCopy ancestry ancestors isEmpty ifTrue: [ ^true ].        ^self class packageFileName: aWorkingCopy ancestry ancestors first name matchesPackageName: self packageName ].  ^falsecurrentlyLoadedClassesInVersion  self versionOrNil ifNotNil: [:vrsn |  ^vrsn currentlyLoadedClassesInVersion ].  ^#()cacheNil  ^MetacelloPlatform current stackCacheFor: #cacheNil at: #key doing: [:cache |  | value |        cache at: #key put: nil.        self cacheNil ]testCollectionCacheKey  | x |  self assert: (Array with: self class with: (Array with: 'faux' with: 'foobar')) equals: (Array with: self class with: (Array with: 'faux' with: 'foobar')).  self deny: (Array with: self class with: (Array with: 'faux' with: 'foobar')) equals: (Array with: self class with: (Array with: 'faux' with: 'foobar' with: 'foobaz')).  self assert: (x := self collectionCacheKey) identicalTo: 6topParent  self parent == nil ifTrue: [ ^self ].  ^self parent topParentdefaultDirectory  ^self fileDirectoryClass defaulttitle  ^'load'possibleVersions  ^self project symbolicVersionSymbols , (self project versions collect: [:each |  each versionString ])projectMethodSource  ^(self class sourceCodeAt: #project) asStringvalidationReport: anObject  validationReport := anObjectnoSave  ^self hasOption: 'no-save'goferBranchPackage: branchName message: commitMessage  | latestFile pkgSpec |  (file notNil and: [ (self name , '.' , branchName) = self file ]) ifTrue: [ latestFile := self loader latestPackage: self file fromRepository: self repositorySpecs.        pkgSpec := self copy.        latestFile ~~ nil ifTrue: [ pkgSpec file: latestFile.              pkgSpec goferCommitPackage: commitMessage.              ^self ] ].  self loader goferCommitBranchPackage: branchName using: self repositorySpecs commitMessage: commitMessagesetUpVersionReferences  versionReferences := OrderedCollection new.  versionReferences     add: (GoferVersionReference name: 'GoferBar-dkh.24');     add: (GoferVersionReference name: 'GoferBar-dkh.25');     add: (GoferVersionReference name: 'GoferFoo-dkh.75');     add: (GoferVersionReference name: 'GoferFoo-dkh.104')linearLoadPackageSpecs: packageSpecs repositories: repositories  self loaderPolicy pushLinearLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] for: selfgetConfigurationUnconditionalLoad: unconditionalLoad  | spec |  spec := self projectSpec.  Smalltalk at: spec className asSymbol ifPresent: [:cl |  unconditionalLoad ifFalse: [ ^cl ] ].  (spec := self lookupProjectSpecFor: spec) projectPackage load.  ^Smalltalk at: spec className asSymbolgetFile  ^nilpackages  packages == nil ifTrue: [ ^super packages ].  ^packagesbaseline300: spec  < version: '3.0-baseline' imports: #('2.0-baseline')>  spec for: #(#attribute1 #attribute2) do: [ spec           project: 'Extra Project' with: [ spec                 className: 'ConfigurationOfExtraProject';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 loads: #('core');                 yourself ];           yourself.        spec group: 'Core' with: #('Extra Project') ]latestPackage: aString fromRepository: repositorySpecs  | gofer |  gofer := MetacelloGofer new.  gofer disablePackageCache.  (self repositoriesFrom: repositorySpecs) do: [:repo |  gofer repository: repo ].  ^([ (GoferPackageReference name: aString) resolveWith: gofer ] on: Error do: [:ignored |  ^nil ]) nameonUpgradeUseLoaded: projectNames  self onUpgrade: [:ex :loaded :incoming |  (projectNames includes: loaded baseName) ifTrue: [ ex useLoaded ] ifFalse: [ ex useIncoming ] ]extractMethodSectionsForClass: aBaselineClass  | pragma |  pragma := self extractBaselinePragmaFor: aBaselineClass.  self evaluatePragma: pragma.  self methodSections do: [:methodSection |  self evaluateBaselineMethodSection: methodSection ]sshPort: anObject  sshPort := anObjectremoveFromMetacelloPackages: aMetacelloPackagesSpec  aMetacelloPackagesSpec addMember: selflabel  ^self printStringfileDirectoryClass  ^FileSystemconfiguration: anObject  configuration := anObjectbaseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec project: 'UTF8' with: [ spec                 className: 'MetacelloVersionQueryMiscConfig';                 versionString: '1.0-baseline';                 loads: #('Misc-UTF8') ].        spec           group: 'Core' with: #('UTF8');           group: 'Tests' with: #('UTF8');           group: 'Recursive' with: #('Core' 'Recursive') ]postLoadDoItBlock  ^self doItBlock: self postLoadDoIt valuecurrentlyLoadedClassesInVersion  ^self spec currentlyLoadedClassesInVersionconfiguration: projectName  self addStatement: #configurationArg: args: {projectName}record: required  self fetchRecord: [:version |  required isEmpty ifTrue: [ version record ] ifFalse: [ version record: required ] ] required: requiredmergeMap  | map |  map := super mergeMap.  map at: #repositories put: self repositories.  ^mapmodifySection: sectionAttributeOrPath repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlock  self modifySection: sectionAttributeOrPath sectionIndex: 1 repository: repositoryDescription requiredProjects: newProjectList packages: newPackageList dependencies: dependecies includes: includes files: files repositories: repositories preLoadDoIts: preLoadDoIts postLoadDoIts: postLoadDoIts supplyingAnswers: supplyingAnswers groups: newGroups versionSpecsDo: aBlockprojectForVersion: aString overrides: aBlock  | spec projectSpec |  projectSpec := self project projectSpec     name: aString;     yourself.  spec := self project projectReferenceSpec     name: aString;     projectReference: projectSpec;     yourself.  self root packages add: spec.  self with: projectSpec during: aBlocktimestamp: anObject  anObject setTimestampInMetacelloVersion: selfbaseline20MethodSourceFoo  ^(self class sourceCodeAt: #baseline20Foo:) asStringauthorName  Smalltalk at: #Author ifPresent: [:cl |  ^cl perform: #initials ].  ^'no developer initials'loadData  ^self loaderPolicy loadDatauseLoaded  self disallowversion11: spec  < version: '1.1' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec description: 'Example of a complete version specification'.        spec author: 'dkh'.        spec timestamp: '10/12/2009 09:26'.        spec           package: 'Example-Core' with: 'Example-Core-anon.15';           package: 'Example-Tests' with: 'Example-Tests-anon.4';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ]incrementPatchVersion  self incrementNormalVersionAt: 3project  ^projectrepositories: anObject  self shouldBeMutable.  repositories := anObject.  self projectPackage: nilrepositorySpecs  ^self repositories map valuestestDirectReturn  | x |  self assert: (x := self directReturnOfValue) identicalTo: 6version21Issue283: spec  < version: '2.1'>  spec for: #common do: [ spec blessing: #release.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec package: 'GoferFoo' with: 'GoferFoo-lr.4' ]loadingSpecLoader  ^selftearDownPackages: aGoferInstance  (self hasPackage: 'GoferFoo') ifTrue: [ aGoferInstance package: 'GoferFoo' ].  (self hasPackage: 'GoferBar') ifTrue: [ aGoferInstance package: 'GoferBar' ].  (self hasPackage: 'GoferFaux') ifTrue: [ aGoferInstance package: 'GoferFaux' ].  (self hasPackage: 'GoferBeau') ifTrue: [ aGoferInstance package: 'GoferBeau' ].  (self hasPackage: 'MetacelloTestConfigurationOfFoo') ifTrue: [ aGoferInstance package: 'MetacelloTestConfigurationOfFoo' ]version131ProjectToolBox: spec  < version: '1.3.1-baseline'>  spec for: #common do: [ spec blessing: #baseline ].  spec for: #level1_1 do: [ spec           package: 'Example-Core' with: [ spec repository: 'http://www.example.com/1' ];           package: 'Example-Core' with: [ spec repository: 'http://www.example.com/2' ];           package: 'Example-Core' with: [ spec repository: 'http://www.example.com/3' ].        spec for: #level2_1 do: [ spec package: 'Example-Core' with: [ spec repository: 'http://www.example.com/4' ].              spec for: #level3_1 do: [ spec package: 'Example-Core' with: [ spec repository: 'http://www.example.com/5' ] ] ].        spec for: #level2_2 do: [ spec package: 'Example-Core' with: [ spec repository: 'http://www.example.com/6' ].              spec for: #level3_2 do: [ spec package: 'Example-Core' with: [ spec repository: 'http://www.example.com/7' ] ] ] ]baseline61MethodSourceFix  ^(self class sourceCodeAt: #baseline61Fix:) asStringprojectVersion  | pv |  pv := self versionInfo projectVersion.  pv ifNil: [ pv := self projectSpec versionOrNil.        self versionInfo projectVersion: pv ].  ^pvname  name == nil ifTrue: [ name := self extractNameFromFile ].  ^nameexecuteCollection: aCollection do: projectSpecBlock  aCollection do: [:projectName |  ((projectSpecGenerator projectSpecLookupBlock value: projectName) select: self projectSpecSelectBlock) do: [:projectSpec |  projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ]extractBaselinePragmaFor: aClass  | pragmas |  pragmas := Pragma allNamed: #baseline in: aClass.  pragmas isEmpty ifTrue: [ ^self error: 'No #baseline pragma found' ].  ^pragmas firsttestDifference  | project expected fromVersionString toVersionString report actual |  project := self project.  fromVersionString := '1.1-baseline'.  toVersionString := '2.0-baseline'.  report := (project version: fromVersionString) difference: (project version: toVersionString).  report     from: fromVersionString;     to: toVersionString;     configuration: 'Test Configuration'.  expected := 'Test Configuration ''1.1-baseline'' to ''2.0-baseline''	Additions:		UTF9			'''' to ''1.0-baseline''	Modifications:		UTF8			''1.0-baseline'' to ''stable''	Removals:		UTF7			''1.0-baseline'' to '''''.  actual := report printString.  self assert: expected equals: actualload: required  ^required loadRequiredForMetacelloMCVersion: selfremovals: anObject  removals := anObjectmatchesMetacelloGoferPackage: aMetacelloGoferPackage  self error: 'Should not be matching a MetacelloGoferPackage with another MetacelloGoferPackage'addToMetacelloPackages: aMetacelloPackagesSpec  aMetacelloPackagesSpec addMember: selftestVersion08  | v1 v2 |  v1 := self versionClass fromString: '1.0a6'.  v2 := self versionClass fromString: '1.0a5'.  self assert: v1 > v2projectVersion: anObject  projectVersion := anObjectvalidateBaselineProject: project  | version spec |  (self visited includes: project configuration class) ifTrue: [ ^self validationReport ].  self visited add: project configuration class.  version := project version.  spec := version spec.  [ self validateBaselineVersionSpec: spec ] on: Error do: [:ex |  self recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description versionString: version versionString callSite: #validateBaselineProject: reasonCode: #versionCompositionError ].  ^self validationReportbaselineNamed: baseName  | baselineName |  baselineName := self baselineNameFrom: baseName.  (Smalltalk includesKey: baselineName asSymbol) ifFalse: [ self ensureMetacello.        BaselineOf subclass: baselineName asSymbol instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: baselineName.        MetacelloPlatform current registerPackageNamed: baselineName.        (MetacelloPlatform current globalNamed: baselineName asSymbol) compile: 'baseline: spec <baseline>' classified: 'baseline' ].  project := (MetacelloPlatform current globalNamed: baselineName asSymbol) projectrepositories  repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].  ^repositoriesexplicitLoadUsing: mcLoader  | wc fetchingSpecLoader |  ((wc := self workingCopy) ~~ nil and: [ wc needsSaving ]) ifTrue: [ (MetacelloSkipDirtyPackageLoad signal: self) ifTrue: [ MetacelloNotification signal: 'Skipping load of modified package: ' , self file.              ^self ] ifFalse: [ MetacelloNotification signal: 'Load over modified package: ' , self file ] ].  fetchingSpecLoader := mcLoader fetchingSpecLoader.  fetchingSpecLoader explicitLoadPackageSpecs: (Array with: self) repositories: (fetchingSpecLoader repositoriesFrom: self repositorySpecs)mergeSpec: anotherSpec  | newSpec |  newSpec := super mergeSpec: anotherSpec.  newSpec list: self list copy.  anotherSpec list do: [:groupMember |  groupMember applyToList: newSpec ].  ^newSpecpassword  password == nil ifTrue: [ password := '' ].  ^passwordversion30Issue156: spec  < version: '3.0.0'>  spec for: #common do: [ spec           configuration: 'Goo' with: [ spec                 versionString: '5.0.0';                 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           yourself ]workingCopy  | pName |  cachedVersion == nil ifTrue: [ ^super workingCopy ].  pName := cachedVersion package name.  ^MCWorkingCopy allManagers detect: [:each |  pName = each packageName ] ifNone: [ self error: 'Working copy for ' , self name , ' not found' ]explanation: aString  explanation := aStringpreLoadDo: aBlock  name: aString  name := aStringgetPreLoadDoIt  ^preLoadDoItdownloadErrorFileNameFor: zipFileName  | pid |  pid := self processPID.  ^'/tmp/curl-' , pid , '-' , (zipFileName select: [:c |  c isAlphaNumeric ]) , '.err'basicReferencesIn: aRepository  ((aRepository isKindOf: MCDictionaryRepository) or: [ aRepository isKindOf: MCDirectoryRepository ]) ifTrue: [ ^super basicReferencesIn: aRepository ].  ^MetacelloPlatform current stackCacheFor: #goferRepository cacheClass: IdentityDictionary at: aRepository doing: [:cache |  ^cache at: aRepository put: (super basicReferencesIn: aRepository) ]baseline40MethodSourceProjectInfinite  ^(self class sourceCodeAt: #baseline40ProjectInfinite:) asStringuseDetermineVersionForLoad  useDetermineVersionForLoad ifNil: [ useDetermineVersionForLoad := true ].  ^useDetermineVersionForLoadexternalBaselineXX: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>externalBaselineXX:'.        spec           package: 'External-CoreX';           package: 'External-TestsX' with: [ spec requires: 'External-CoreX' ];           yourself.        spec           group: 'Core' with: #('External-CoreX');           group: 'default' with: #('Core');           group: 'Tests' with: #('External-TestsX');           yourself ]goferReferences  ^self localRepository goferReferences collect: [:each |  GoferResolvedReference name: each name repository: self ]packageSpecsInLoadOrder  ^self packages packageSpecsInLoadOrderFor: selfmap  | map |  memberMap ~~ nil ifTrue: [ ^memberMap ].  map := Dictionary new.  self list do: [:member |  member applyAdd: [:memberSpec |  self mapAdd: memberSpec into: map ] copy: [:memberSpec |  self mapCopy: memberSpec into: map ] merge: [:memberSpec |  self mapMerge: memberSpec into: map ] remove: [:memberSpec |  self mapRemove: memberSpec into: map ] ].  memberMap := map.  ^memberMapsetUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:reference |  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) with: (MCClassDefinition name: reference packageName asSymbol superclassName: #Object category: reference packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]lookupVersion: aVersionString ifAbsent: aBlock  ^self map at: aVersionString ifAbsent: [ (MetacelloVersionDefinitionError project: self project versionString: aVersionString)           exception: (self errorMap at: aVersionString ifAbsent: [ ^aBlock value ]);           signal ]label  ^self namelesson14  ^Lesson title: 'Lesson 14' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline14:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version14:."In this lesson we''ll cover the querying API for Metacello. The querying API is useful for analyzing the contents and structure of a version.To start with we''ll look at version ''1.4'' of the MetacelloProjectRefTutorialConfig. You can list the packages in the version:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') packages."The list project references:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') projects."And the groups:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') groups."You can access individual packages/project refs/groups using  the #packageNamed: method. Here you can access the package named: ''Project-Core'':"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Project-Core''."The project reference named ''Example Default'':" (MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Example Default''."The group named ''Core'':" (MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Core''."Each of the attributes of the package can be accessed (#requires, #includes, #file, #repository, #preLoadDoIt, and #postLoadDoit). For example:"  ((MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Project-Core'') requires."Each of the attributes of the project can be accessed (#className, #versionString, #operator, #loads, #file, and #repository). For example:"  ((MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Example Default'') repository."Each of the attributes of the group can be accessed (#includes). For example:"  ((MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''default'') includes."When looking at the ''Core'' group, there is only one package listed:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Core''."In the case of the ''Core'' group, it is defined in terms of the ''default'', which isn''t very useful. When looking at the contents of groups you''d like to see the complete list of packages, without having to explicitly expanding each group you encounter. #packagesForSpecNamed: does just that:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') packagesForSpecNamed: ''Core''."If you were to load the ''Core'' package:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') load: ''Core''."You end up seeing the packages from the Example project. If you want to get the list of packages that _would_ be loaded, you can use #allPackagesForSpecNamed:. For example:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') allPackagesForSpecNamed: ''Core''."If you use #allPackagesForSpecNamed: with a project refernce name, you''ll see the packages that _would_ be loaded:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') load: ''Example Default''.  (MetacelloProjectRefTutorialConfig project version: ''1.4'') allPackagesForSpecNamed: ''Example Default''."You can also send #version to a project reference. This is useful if you want to explicitly walk the tree of projects:"  ((MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Example Default'') version.ProfStef next.'packages  | packages |  packages := OrderedCollection new.  self loadDirective packageDirectivesDo: [:directive |  packages add: directive spec ].  ^packagescompileMethod  (project configuration class compile: self methodSource classified: self category) == nil ifTrue: [ self error: 'Error compiling the method' ]configurationGithubReferenceXX: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configurationGithubReferenceXX:'.        spec configuration: 'External' with: [ spec                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]repositoryForVersion: aString username: username password: password  self repositoryForSpec: aString username: username password: passwordconfigurationPath  ^'metacello-tests/configuration'configurationArg: anObject  configurationArg := anObjectload  self subclassResponsibilityensureLoadedForDevelopmentUsing: mcLoader  ^truecreateVersion  ^self versionClass fromSpec: selfextractSymbolicVersionSpecsFor: sourceVersionSymbol  | coll pragma |  coll := self extractSymbolicVersionPragmas at: sourceVersionSymbol ifAbsent: [ ^#() ].  coll size > 1 ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionSymbol printString ].  pragma := coll at: 1.  self evaluatePragma: pragma.  ^self methodSectionsbaseline61MethodSourceFoo  ^(self class sourceCodeAt: #baseline61Foo:) asStringtimestamp  timestamp == nil ifTrue: [ ^self project valueHolderSpec           value: '';           yourself ].  ^timestampextractRepositoryFrom: zipFile to: directory  | out err proc errorMessage errorFileName |  errorFileName := self downloadErrorFileNameFor: zipFile.  out := FileStream forceNewFileNamed: '/tmp/zip.out'.  err := FileStream forceNewFileNamed: errorFileName.  errorMessage := ''.  [ proc := (self class environment at: #OSProcess) thisOSProcess forkJob: '/usr/bin/unzip' arguments: {'-u' .         zipFile .         '-d' .         directory} environment: nil descriptors: (Array with: nil with: out with: err).  proc ifNil: [ self noAccessorAvailable ].  [ proc isRunning ] whileTrue: [ (Delay forMilliseconds: 100) wait ] ] ensure: [ out close.        err close ].  FileStream fileNamed: errorFileName do: [:fileStream |  (errorMessage := fileStream contentsOfEntireFile) notEmpty ifTrue: [ self error: 'unzip failure: ' , errorMessage printString ] ifFalse: [ (self fileHandleOn: '/tmp')                 deleteFileNamed: zipFile;                 deleteFileNamed: errorFileName ] ]searchCacheRepositoryForPackage: searchBlock  setUpConfigurationOfProjectIssue86  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue86-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self linearProjectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline60ProjectIssue86:' category: 'cat' timeStamp: '' source: self baseline60MethodSourceProjectIssue86) .   (MCMethodDefinition className: className asString selector: 'baseline61ProjectIssue86:' category: 'cat' timeStamp: '' source: self baseline61MethodSourceProjectIssue86) .   (MCMethodDefinition className: className asString selector: 'baseline62ProjectIssue86:' category: 'cat' timeStamp: '' source: self baseline62MethodSourceProjectIssue86)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())tutorial  ^#(#lesson01 #lesson02 #lesson03 #lesson04 #lesson05 #lesson06 #lesson07 #lesson08 #lesson10 #lesson11 #lesson11Author #lesson11Blessing #lesson11Descripton #lesson11Timestamp #lesson12DoIts #lesson13)label  ^self namemapAdd: aMemberSpec into: map  map at: aMemberSpec name put: aMemberSpec specvalidateProjectVersion: versionString  | project |  project := self validateProjectCreationFrom: self configurationClass onError: [:ex |  self recordValidationError: 'Error creating project: ' , ex description , ' to reproduce evalutate the following: ''' , self configurationClass name asString , ' project''' callSite: #validateProject reasonCode: #projectCreationError.        ^self validationReport ].  ^self validateProject: project version: versionStringbaseline: projectName  self addStatement: #baselineArg: args: {projectName}tutorial  ^#(createConfigurationAndBaseline createDevelopmentVersion validateAndSaveConfiguration checkpointSave integrateCodeContributions compareVersions releaseVersion createNewDevelopmentVersion)useExisting  self disallow< aMetacelloVersion  aMetacelloVersion species = self species ifFalse: [ ^false ].  ^self versionNumber < aMetacelloVersion versionNumberremoveGroup: aString  self root removeGroup: aString constructor: selfpackage: aString  self root package: aString constructor: selfversionClass  ^MetacelloMCVersionasAttributeOrPath  self size = 1 ifTrue: [ | attribute |        attribute := self at: 1.        ^attribute size = 1 ifTrue: [ attribute at: 1 ] ifFalse: [ attribute ] ].  ^selfrepositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: ignoreOverrides  | repositories repos |  (ignoreOverrides not and: [ self hasRepositoryOverrides ]) ifTrue: [ ^self loaderPolicy overrideRepositories ].  repositories := MCRepositoryGroup default repositories.  repos := OrderedCollection new.  aMetacelloMVRepositorySpecs do: [:aSpec |  | description repo |        description := aSpec description.        (repo := repositories detect: [:rep |  rep description = description ] ifNone: [ aSpec createRepository ]) ~~ nil ifTrue: [ repos add: repo ] ].  ^repossetUpConfigurationOfFoo  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfFoo-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'bleedingEdgeVersion:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #bleedingEdgeVersion:) asString) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline20Foo:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'baseline30Foo:' category: 'cat' timeStamp: '' source: self baseline30MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'baseline35Foo:' category: 'cat' timeStamp: '' source: self baseline35MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'baseline40Foo:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'baseline50Foo:' category: 'cat' timeStamp: '' source: self baseline50MethodSourceFoo) .   (MCMethodDefinition className: className asString selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: self preloadDoItMethodSource)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())preLoadDoIt: aSymbol constructor: aVersionConstructor  aVersionConstructor preLoadDoItForPackage: aSymboldisallow  self resume: self existingProjectRegistrationloadPackageDirective: aPackageLoadDirective gofer: aGofer  aPackageLoadDirective loader loadingSpecLoader loadPackageDirective: aPackageLoadDirective gofer: aGoferupdateProject: aLoaderPolicy  | mcLoader |  (mcLoader := self loader) == nil ifTrue: [ mcLoader := self project loaderClass on: nil ].  mcLoader loaderPolicy: aLoaderPolicy.  mcLoader doingLoads: [ MCWorkingCopy managersForClass: self configuration class do: [:mgr |  | pkg ar |              pkg := self packageSpec.              mgr repositoryGroup repositories do: [:repo |  pkg repositories repository: (repo asRepositorySpecFor: self) ].              ar := mgr metacelloPackageNameWithBranch.              pkg name: (ar at: 1).              (ar at: 2) notEmpty ifTrue: [ pkg file: (ar at: 2) ].              pkg load.              ^true ] ].  ^truefinalizeLoad: aGofer  | pkgLoads |  self preloads do: [:directive |  super loadPreloadDirective: directive ].  preloads := nil.  (pkgLoads := self packageloads) notEmpty ifTrue: [ self loader loadingSpecLoader loadPackageDirectives: pkgLoads gofer: aGofer.        self packageloads: nil ].  self postloads do: [:directive |  super loadPostloadDirective: directive ].  postloads := nilonDowngrade: aBlock  self options at: #onDowngrade put: aBlockresolvePackageSpecReferences: packageSpec gofer: gofer  | versionReference references localGofer |  localGofer := gofer.  self hasRepositoryOverrides not ifTrue: [ packageSpec repositorySpecs notEmpty ifTrue: [ localGofer := MetacelloGofer new.              (self repositoriesFrom: packageSpec repositorySpecs) do: [:repo |  localGofer repository: repo ] ] ].  (packageSpec getFile == nil or: [ self shouldDisablePackageCache ]) ifTrue: [ localGofer disablePackageCache ].  versionReference := packageSpec goferLoaderReference.  references := versionReference resolveAllWith: localGofer.  localGofer enablePackageCache.  ^referencesunregister  actionArg := #unregister -> #()testRemoveC  | repositories removed |  repositories := self repositoriesSpec.  repositories add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  repositories remove: {'http://example.com/repository'}.  removed := false.  repositories map at: 'http://example.com/repository' ifAbsent: [ removed := true ].  self assert: removedloadPackageDirectives: pkgLoads gofer: aGofer  interactiveCommit  ^self execute: MetacelloGoferCommitaddToMetacelloRepositories: aMetacelloRepositoriesSpec  aMetacelloRepositoriesSpec addMember: selfproject  ^project ifNil: [ (self class baseConfigurationClassIfAbsent: [  ]) ensureMetacello.        project := MetacelloMCProject new projectAttributes: self customProjectAttributes.        (Smalltalk at: #MetacelloVersionConstructor) on: self project: project.        project loadType: #linear.        project ]specListDetect: aBlock  ^self specListDetect: aBlock ifNone: [ self error: 'Object is not in the collection.' ]loadUsing: aLoaderDirective gofer: aGofer  aLoaderDirective loadPostloadDirective: selfopen11ForDevelopment  ^Lesson title: 'Open version 1.1 for development' lesson: '"	1. Create configuration	2. Prepare to define version method #version11:	3. Use version 1.0 as basis for version 1.1. basically a copy. Differs from import.	4. Update project and package versions		- with #updateProjects set to true, the current version of the project Shout will set		- with #updatePackages set to true, the current mcz files for the packages ProfStef-Core ProfStef-Tests will be set	5. Define desired versionSpec attributes		- current author and timestamp		- set blessing to #development		- set the description	6. Compile and validate the #version11: method	7. Prepare to modify symbolic version method #development:		- keep all of the existing symbolic version specs in the method	8. Define/change the symbolic version for #development to 1.1	9. Compile and validate the #development: method"		| description |	description := ''''."1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		createVersionMethod: ''version11:'' inCategory: ''versions'' forVersion: ''1.1'';"3."		addSectionsFrom: ''1.0''			forBaseline: false"4."			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ "5."						versionSpec							author: MetacelloPlatform current authorName;							description: description;							blessing: #development;							timestamp: MetacelloPlatform current timestamp ].				true ];"6."		commitMethod;"7."		modifySymbolicVersionMethodFor: #development symbolicVersionSpecsDo: [ :symbolicVersionSpec | true ];"8."		addSymbolicSection: #common version: ''1.1'';"9."		commitMethod."After evaluating the above expression, take a look at the generated methods:	- #version11:	- #development:"ProfStef next.'removePackage: aString  self root removePackage: aString constructor: selfversion13: spec  < version: '1.3' imports: #('1.2-baseline')>  spec for: #common do: [ spec blessing: #beta.        spec description: 'Import functionality from the example project, different packages'.        spec           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1';           project: 'Example Default' with: '1.3';           project: 'Example Tests' with: '1.3' ]addMethodSection: attribute versionString: aString  self methodSections add: (MetacelloSymbolicVersionSpec new           attributes: attribute asMetacelloAttributeList;           versionString: aString;           yourself)specListProjectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  self packages specListDo: [:pkgSpec |  pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]symbolicVersionMethod: versionSymbol  (self hasMethodForSymbolicVersion: versionSymbol) ifTrue: [ self modifySymbolicVersionMethodFor: versionSymbol ] ifFalse: [ self createSymbolicVersionMethod: versionSymbol asString , ':' inCategory: 'symbolic versions' forVersion: versionSymbol ]matches: aLoadableReference  | pFilename |  ((pFilename := self packageFilename) == nil or: [ self name = self packageFilename ]) ifTrue: [ ^super matches: aLoadableReference ].  aLoadableReference name = pFilename ifTrue: [ ^true ].  (aLoadableReference name beginsWith: pFilename) ifFalse: [ ^false ].  ^aLoadableReference matchesMetacelloGoferPackage: selfbaseline20Fan: spec  < version: '2.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '2.0';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Far' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '2.0';                 loads: #('GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]signal  self messageText: self description.  ^super signalscheduleFetchFor: packageSpec nearestReference: reference  ^self scheduleFetchFor: packageSpec reference: reference message: 'Fetched -> (nearest) ' , reference name , ' --- ' , reference repository repositoryDescription , ' --- ' , reference repository descriptionregisterProject  self class registry registerProjectRegistration: selfparentDirectoryOf: aFileHandler  ^aFileHandler parentasConfigurationProjectSpec  ^selfcreate11Baseline  ^Lesson title: 'Create 1.1 Baseline' lesson: '"	1. Create configuration	2. Prepare to define baseline version method	3. Copy specs from 1.0-baseline. This is a copy not an import, so all specs are preserved		- with #updateProjects set to false, the version of the project Shout is preserved		- with #updatePackages set to false, the specification of the mcz files for the packages ProfStef-Core ProfStef-Tests are preserved (typically not specified)	4. Add and additional section for the attribute #pharo		- the package ProfStefBrowser and it''s dependencies are added		- the package is added to the UI group	5. Compile and validate #baseline11: method	6. Prepare to modify the method defining version 1.1.		- false as return value in block means that all existing version specs in 1.1 are dropped on floor. Basically just the method name and pragma are preserved	7. Import the versionSpecs from 1.1-baseline into version 1.1	8. Compile and validate the #version11: method	9. Prepare to modify the method defining symbolic version #development. Preserve existing symbolic version specs	10.  add symbolic version spec for #pharo	11. Compile and validate the #development: method"		| description |	description := ''''."1."	(MetacelloToolBox configurationNamed: ''Example'')"2"		createVersionMethod: ''baseline11:'' inCategory: ''baselines'' forVersion: ''1.1-baseline'';"3."		addSectionsFrom: ''1.0-baseline''			forBaseline: true			updateProjects: false			updatePackages: false			versionSpecsDo: [ :attribute :versionSpec | true ];"4"		addSection: #pharo			repository: nil			requiredProjects: #()			packages: #(''ProfStefBrowser'')			dependencies: {(''ProfStefBrowser'' -> #(''ProfStef-Core''))}			groups: {(''UI'' -> #(''ProfStefBrowser''))}			versionSpecsDo: [ :versionSpec |  ];"5."		commitMethod;"6."		modifyVersionMethodForVersion: ''1.1'' versionSpecsDo: [ :attribute :versionSpec | false ];"7."		importFrom: ''1.1-baseline''			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, blessing and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							blessing: #development;							description: description;							timestamp: MetacelloPlatform current timestamp ].				true ];"8."		commitMethod;"9"		modifySymbolicVersionMethodFor: #development symbolicVersionSpecsDo: [ :symbolicVersionSpec | true ];"10."	addSymbolicSection: #pharo version: ''1.1'';"11."	commitMethod."Look at the generated methods: 	#baseline11:	#version11:	#development:"	ProfStef next.'loadingSpecLoader  ^selfproject: aString overrides: aBlock  self root project: aString overrides: aBlock constructor: selfrecord  ^self execute: #record: args: #(#())isSomethingLoaded  self isPartiallyCurrent isSomethingLoaded: [:ignored |  ^true ].  ^falsedoRecordRequiredFromArray: anArray  | originalLoader oldPolicy displayString oldBypassProgress |  displayString := self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloNotification signal: 'Recording ' , displayString , '...'.  originalLoader := self versionSpec loader.  oldPolicy := loaderPolicy.  oldBypassProgress := MetacelloPlatform current bypassProgressBars.  self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].  [ MetacelloPlatform current do: [ | ans |        self versionSpec loader: originalLoader recordingSpecLoader.        ans := (self executeLoadFromArray: anArray) copy.        MetacelloNotification signal: '...finished ' , self versionNumber printString.        ^ans ] displaying: 'Recording ' , displayString ] ensure: [ MetacelloPlatform current bypassProgressBars: oldBypassProgress.        self versionSpec loader: originalLoader.        loaderPolicy := oldPolicy ]compareEqual: aMetacelloProjectSpec  ^self className = aMetacelloProjectSpec className and: [ (self compareVersionsEqual: aMetacelloProjectSpec) and: [ self operator == aMetacelloProjectSpec operator and: [ self loads = aMetacelloProjectSpec loads and: [ self preLoadDoIt value == aMetacelloProjectSpec preLoadDoIt value and: [ self postLoadDoIt value == aMetacelloProjectSpec postLoadDoIt value ] ] ] ] ]conflictOf21: spec  < version: '2.1.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>conflictOf21:'.        spec author: 'dkh'.        spec timestamp: '6/1/2012 14:46' ].  spec for: #custom do: [ spec configuration: 'ExternalX' with: [ spec                 operator: #=;                 version: '0.9.1';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]projectWith: projectAttributes  | project |  project := MetacelloProject new.  project projectAttributes: projectAttributes.  MetacelloVersionConstructor on: self project: project.  ^projecthash  | mySize interval hashValue |  (mySize := self size) == 0 ifTrue: [ ^15243 ].  interval := (mySize - 1) // 4 max: 1.  hashValue := 4459.  1 to: mySize by: interval do: [:i |  | anElement |        anElement := self at: i.        (anElement isKindOf: SequenceableCollection) ifTrue: [ hashValue := (hashValue bitShift: -1) bitXor: anElement size ] ifFalse: [ hashValue := (hashValue bitShift: -1) bitXor: anElement hash ] ].  ^hashValue absregisterPackageNamed: packageName  ^(Smalltalk at: #PackageInfo) registerPackageName: packageNameonDowngrade: aBlock  self addStatement: #onDowngrade: args: {aBlock}checkInputForInstallSubcommand  (self isBaselineName and: [ self hasVersion ]) ifTrue: [ Exit signalFailure: 'A baseline can not be used with --version option.' ].  (self isBaselineName or: [ self isConfigurationName ]) ifFalse: [ Exit signalFailure: 'Not a Baseline nor a Configuration.' ]shouldDisablePackageCache: anObject  disablePackageCache := anObjectrepository  self deprecated: 'Use repositories or repositorySpecs'.  self repositorySpecs isEmpty ifTrue: [ ^nil ].  ^self repositorySpecs firstspotterForPackagesFor: aStep  < spotterOrder: 3>  aStep listProcessor     title: 'Packages';     allCandidates: [ self packages ];     itemName: [:item |  item file ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: truemethodSelectorAndPragma: aSelector imports: importList versionString: aString on: strm  strm     nextPutAll: aSelector asString , ' spec';     cr;     tab;     nextPutAll: '<version: ' , aString printString.  importList notEmpty ifTrue: [ strm nextPutAll: ' imports: #('.        importList do: [:importVersionString |  strm                 nextPutAll: importVersionString printString;                 space ].        strm nextPut: $) ].  strm     nextPutAll: '>';     crreferencedSpec  ^self projectReferencemodifyVersionMethodForVersion: inputVersionStringOrSymbol  ^self modifyVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: [:attribute :versionSpec |  true ]name: anObject  self root name: anObject constructor: selftestCopyToGroup  | packages group |  packages := self packagesSpec.  packages add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  packages merge: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself).  group := packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (group includes includes: 'Core').  self assert: (group includes includes: 'Tests').  group := self groupSpec     name: 'PlatformCopy';     includes: 'Copy';     yourself.  packages copy: 'Platform' to: group.  group := packages packageNamed: 'PlatformCopy' ifAbsent: [ self assert: false ].  self assert: (group includes includes: 'Core').  self assert: (group includes includes: 'Copy').  self assert: (group includes includes: 'Tests')metacelloRegistrationHash  ^((self map values sort: [:a :b |  a description <= b description ]) collect: [:each |  each description ]) hashensureMetacello  compareVersions: aMetacelloProjectSpec usingOperator: anOperator  ^aMetacelloProjectSpec versionOrNil == nil ifTrue: [ aMetacelloProjectSpec versionString asMetacelloVersionNumber perform: anOperator with: self version versionNumber ] ifFalse: [ ^aMetacelloProjectSpec version perform: anOperator with: self version ]ancestorsFor: packageSpec  ^self loadData ancestorsFor: packageSpec ifAbsent: [ super ancestorsFor: packageSpec ]for: aProject  self shouldBeMutable.  project := aProjectrequires  requires == nil ifTrue: [ requires := #() ].  ^requiresfetch  ^self doFetchRequiredFromArray: self spec defaultPackageNamescomputeVersionStatus  ^#noStatusrepositoryArg  ^repositoryArgresolveSpec: pkgSpec with: gofer  ^pkgSpec goferLoaderReference resolveWith: goferprojectClass  ^MetacelloMCBaselineProjectsetUpMarianosImage  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MarianosImage-dkh.1'.  className := #MarianosImage.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionOfMariano:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfMariano:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfogroup: aString with: aStringOrCollection  self root group: aString with: aStringOrCollection constructor: selfrecurse  recurse == nil ifTrue: [ recurse := false ].  ^recursenonOverridable  ^#()load: required  ^self subclassResponsibilitylockConfiguration13: spec  < version: '1.3.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>lockConfiguration13: '.        spec configuration: 'ExternalX' with: [ spec                 version: #stable;                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]lesson05  ^Lesson title: 'Lesson 5' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version05:."For version 0.5 we''ve added an additional package to the mix: ''Example-AddOn'':"  (MetacelloTutorialConfig project version: ''0.5'') spec."Of course, the point of specifiying packages in Metacello is to be able to load versions. Here area couple examples of loading versions of the Tutorial. If you print the result of each expression, you will see the list of packages in load order (note that for the tutorial, we are using the MetacelloNullRecordingMCSpecLoader. This class records which packages are loaded and the order that they are loaded in among other things instead of actually loading the packages."  (MetacelloTutorialConfig project version: ''0.1'') load.  (MetacelloTutorialConfig project version: ''0.4'') load.  (MetacelloTutorialConfig project version: ''0.5'') load."You will note that in each case, all of the packages associated with the version are loaded, which is the default. If you want to load a subset of the packages in a project, you may list the packages that youare interested in as an argument to the #load: method:"  (MetacelloTutorialConfig project version: ''0.5'') load: { ''Example-Tests''. ''Example-Core'' }."Note that the ordering of the packages is based on the order in which the packages are specified.If you evaluate the following expression:"  (MetacelloTutorialConfig project version: ''0.5'') load: { ''Example-Tests''. }."Only the package is ''Example-Tests''. By default the packages are ordered, but there are no implicitdependencies."ProfStef next.'baseline25MethodSourceFoo  ^(self class sourceCodeAt: #baseline25Foo:) asStringmergeMap  | map |  map := super mergeMap.  map at: #value put: value.  ^mapsetBaselineRepositoryDescription: aListOrRepositoryDescriptions  aListOrRepositoryDescriptions do: [:desc |  self version spec repository: desc ]sampleRepository  ^sampleRepositoryaProjectNotLoaded: aBoolean  aProjectNotLoaded := aBooleanbaseline20MethodSourceFoo  ^(self class sourceCodeAt: #baseline20Foo:) asStringstableVersion283A: spec  < symbolicVersion: #stable>  spec for: #common version: '2.0'setUpConfigurationOfFum  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfFum-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline40ProjectFum:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectFum)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())version109ProjectToolBox: spec  < version: '1.0.9-baseline'>  spec for: #common do: [ spec           package: 'Example-Core';           package: 'Example-Tests' with: [ spec includes: #('Example-Core') ] ]isPartiallyLoaded: aLoader  | vrsn |  (vrsn := self versionOrNil) == nil ifTrue: [ ^false ].  (self loadListForVersion: vrsn) do: [:nm |  (vrsn packagesForSpecNamed: nm) do: [:pkg |  (pkg isPackageLoaded: aLoader) ifTrue: [ ^true ] ] ].  ^falseconfigMethodCascadeOn: aStream member: aMember last: lastCascade indent: indent  self subclassResponsibilitysetDefaultsAndValidateProjectSpec  self setDefaultsAndValidate: self projectSpecconfigurationClass: anObject  configurationClass := anObjectisPackageLoaded: aLoader  ^(self workingCopyNameFor: aLoader) ~~ nilcurrentVersionInfoFor: packageSpec ifAbsent: aBlock  ^self versionInfoMap at: packageSpec file ifPresent: [:v |  v first ] ifAbsent: [ self packageNameMap at: packageSpec name ifPresent: [:v |  v first ] ifAbsent: aBlock ]on: aConfig  self calculate: aConfig project: nilisAllLoadedToSpec: matchBlock  (self evaluateStatus: #(#allLoadedToSpec)) ifTrue: [ ((hasNoPackage or: [ aPackageIsLoaded & aPackageNotLoaded not & aLoadedPackageIsExact & aLoadedPackageIsNotCurrent not & aLoadedPackageIsCurrent not ]) and: [ hasNoProject or: [ aProjectIsLoaded & aProjectNotLoaded not & aLoadedProjectIsExact & aLoadedProjectIsNotCurrent not & aLoadedProjectIsCurrent not ] ]) ifTrue: [ matchBlock value: #allLoadedToSpec ] ]postCopy  super postCopy.  projectReference := projectReference copydecrementPatchVersion  self decrementNormalVersionAt: 3nameForProject: aString  self root name: aStringrequires: anObject constructor: aVersionConstructor  aVersionConstructor requiresForPackage: anObjectisWarning  ^falseevaluateBaselineMethodSection: methodSection  | versionSpec |  versionSpec := self project versionSpec.  methodSection versionSpec: versionSpec.  currentSection := methodSection.  self with: versionSpec during: methodSection block.  methodSection methodSections do: [:ms |  self evaluateBaselineMethodSection: ms ]handleUpgrade: exception  ^(self options at: #onUpgrade ifAbsent: [ ^exception pass ]) cull: exception cull: exception existingProjectRegistration cull: exception newProjectRegistrationrecordValidationWarning: aString versionString: versionString callSite: callSite reasonCode: aSymbol  < haltOrBreakpointForTesting>  (self warningReasonCodes includes: aSymbol) ifFalse: [ self error: 'Unknown warning reason code' ].  ((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol) ifTrue: [ ^self ].  (self debug includes: #warning) ifTrue: [ self halt: 'Debug triggered for critical warning: ' , aString ].  self validationReport add: (MetacelloValidationWarning configurationClass: (self recurse ifTrue: [ self configurationClass ] ifFalse: [ nil ]) reasonCode: aSymbol callSite: callSite explanation: aString)attributePrintString  | stream |  stream := WriteStream on: String new.  self attributes size = 1 ifTrue: [ stream nextPutAll: '#' , attributes first asString printString ] ifFalse: [ stream nextPutAll: '#('.        self attributes do: [:attribute |  stream                 nextPutAll: '#' , attribute asString printString;                 space ].        stream nextPut: $) ].  ^stream contentsversionDirectivesDo: aBlock  aBlock value: self.  self loadDirectives do: [:directive |  directive versionDirectivesDo: aBlock ]symbolicVersionExplicitlyDoesNotExistProjectToolBox: spec  < symbolicVersion: #'explicitly does not exist'>  spec for: #common version: #notDefinedhandleConflict: exception  ^(self options at: #onConflict ifAbsent: [ ^exception pass ]) cull: exception cull: exception existingProjectRegistration cull: exception newProjectRegistrationadd: aSpec  aSpec addToMetacelloPackages: selfrequires: aCollection  self shouldNotImplementunloadClasses: aWorkingCopy  do: aBlock  self dataMap valuesDo: [:ar |  aBlock value: (ar at: 1) value: (ar at: 2) value: (ar at: 3) ]load: required  actionArg := #load: -> {required}versionClass  ^MetacelloVersionNumberprepostLoadDirectivesDo: aBlock  self preloads do: [:directive |  directive prepostLoadDirectivesDo: aBlock ].  self loadDirectives do: [:directive |  directive prepostLoadDirectivesDo: aBlock ].  self postloads do: [:directive |  directive prepostLoadDirectivesDo: aBlock ]testValueHolderSpec  | valueHolder |  valueHolder := self valueHolderSpec     value: 'an Object';     yourself.  self assert: valueHolder value equals: 'an Object'projectSpec  ^self projectSpecClass for: selfconfiguration095Issue185: spec  < version: '0.9.5'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration095Issue185:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA2 , '/repository' ];           import: 'External' ]