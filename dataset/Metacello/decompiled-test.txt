bypassGoferLoadUpdateCategories: arg1  bypassGoferLoadUpdateCategories := arg1-=JUAMPI=-tearDown  | tmp1 tmp2 tmp3 |  tmp1 := Gofer new.  self tearDownPackageNames do: [:arg1 |  (self hasPackage: arg1) ifTrue: [ tmp1 package: arg1 ] ].  tmp1 references notEmpty ifTrue: [ tmp1 metacelloUnload ].  MCRepositoryGroup default     removeIdenticalRepository: (testingEnvironment at: #Metacello_Gofer_Test_Repository ifAbsent: [  ]);     removeIdenticalRepository: (testingEnvironment at: #Metacello_Configuration_Test_Repository ifAbsent: [  ]);     yourself.  testingEnvironment removeKey: #Metacello_Gofer_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Repository ifAbsent: [  ].  tmp2 := MCWorkingCopy allManagers collect: [:arg2 |  arg2 packageName ].  tmp3 := tmp2 difference: initialWorkingCopyList.  tmp3 do: [:arg3 |  MetacelloNotification signal: 'leaked package from ' , self printString , ' -> ' , arg3 printString ].  self assert: tmp3 isEmpty.  super tearDown-=JUAMPI=-configuration094Issue185: arg1  < version: '0.9.4'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration094Issue185:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA1 , '/repository' ];           import: 'External' ]-=JUAMPI=-argumentsWith: arg1  ^CommandLineArguments withArguments: arg1-=JUAMPI=-useIncoming  self allow-=JUAMPI=-species  ^MCPackage-=JUAMPI=-title  ^'linear load'-=JUAMPI=-asBaselineProject  ^self-=JUAMPI=-importedVersions: arg1  importedVersions := arg1-=JUAMPI=-version42Issue119: arg1  < version: '4.2' imports: #('4.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: '2.0'.        arg1 package: 'GoferBar ' with: 'GoferBar-jf.1' ]-=JUAMPI=-allow  self checkAllowed.  self resume: self newProjectRegistration-=JUAMPI=-setUpConfigurationIssue339  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfIssue339-dkh.1'.  tmp2 := #ConfigurationOfIssue339.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'version100Issue339:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version100Issue339:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4-=JUAMPI=-ignoreImage  ^self loaderPolicy ignoreImage-=JUAMPI=-baseline10: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1           package: 'Example-Core';           package: 'Example-AddOn' with: [ arg1 requires: #('Example-Core') ];           package: 'Example-Tests' with: [ arg1 requires: #('Example-AddOn') ];           package: 'Example-TestsUI' with: [ arg1 requires: #('Example-UI' 'Example-Tests') ];           package: 'Example-UI' with: [ arg1 requires: #('Example-AddOn') ] ]-=JUAMPI=-name  ^name-=JUAMPI=-import: arg1 provides: arg2  importArray := importArray ifNil: [ {(arg1 -> arg2)} ] ifNotNil: [ importArray , {(arg1 -> arg2)} ]-=JUAMPI=-testAddProjectA  | tmp1 tmp2 tmp3 |  tmp1 := self packagesSpec.  tmp1 add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself).  tmp1 add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp3 := tmp1 packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: tmp3 projectName equals: 'Project'.  self assert: tmp3 versionString equals: '1.0'.  self should: [ tmp3 includes: #() ] raise: Error.  self should: [ tmp3 requires: #() ] raise: Error.  self should: [ tmp3 answers: #() ] raise: Error.  tmp3 projectDo: [:arg1 |  self assert: tmp3 identicalTo: arg1 ] packageDo: [:arg2 |  self assert: false ] groupDo: [:arg2 |  self assert: false ].  tmp2 := tmp3 referencedSpec.  self assert: tmp2 name equals: 'Project'.  self assert: tmp2 className equals: 'ConfigurationOfProject'.  self assert: tmp2 versionString equals: '1.0'.  self assert: tmp2 operator identicalTo: #<.  self assert: tmp2 loads equals: #('MyPackage').  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoIt.  tmp2 projectDo: [:arg1 |  self assert: tmp2 identicalTo: arg1 ] packageDo: [:arg2 |  self assert: false ] groupDo: [:arg2 |  self assert: false ]-=JUAMPI=-configMethodBodyOn: arg1 hasName: arg2 indent: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := file ~~ nil.  tmp2 := self repositorySpecs size > 0.  tmp3 := self getPreLoadDoIt ~~ nil.  tmp4 := self getPostLoadDoIt ~~ nil.  tmp5 := (self requires isEmpty and: [ self includes isEmpty and: [ self answers isEmpty ] ]) not.  tmp5 ifTrue: [ self configMethodBodyOn: arg1 hasName: arg2 cascading: tmp1 | tmp2 | tmp3 | tmp4 indent: arg3 ].  self configMethodOn: arg1 for: file selector: 'file: ' cascading: arg2 | tmp2 | tmp3 | tmp4 | tmp5 cascade: tmp2 | tmp3 | tmp4 indent: arg3.  tmp2 ifTrue: [ self repositorySpecs size > 1 ifTrue: [ arg2 | tmp1 | tmp3 | tmp4 | tmp5 ifTrue: [ arg1                       cr;                       tab: arg3 ].              arg1                 nextPutAll: 'repositories: [';                 cr;                 tab: arg3 + 1;                 nextPutAll: 'spec';                 cr.              self repositories configMethodCascadeOn: arg1 indent: arg3 + 1.              arg1 nextPutAll: ' ]' ] ifFalse: [ arg2 | tmp1 | tmp3 | tmp4 | tmp5 ifTrue: [ arg1                       cr;                       tab: arg3 ].              self repositories configMethodCascadeOn: arg1 indent: arg3 ].        tmp3 | tmp4 ifTrue: [ arg1 nextPut: $; ] ].  self configMethodOn: arg1 for: self getPreLoadDoIt selector: 'preLoadDoIt: ' cascading: arg2 | tmp1 | tmp2 | tmp4 | tmp5 cascade: tmp4 indent: arg3.  self configMethodOn: arg1 for: self getPostLoadDoIt selector: 'postLoadDoIt: ' cascading: arg2 | tmp1 | tmp2 | tmp3 | tmp5 cascade: false indent: arg3.  arg1 nextPut: $.-=JUAMPI=-remove  -=JUAMPI=-lesson13  ^Lesson title: 'Lesson 12 (DoIts)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #baseline13:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version13:."For version 1.3 we are adding a platform specific package ''Example-Platform''. ''Example-Platform''requires ''Example-Core''. On GemStone, Pharo and Squeak, a branch of the ''Example-Platform'' package will be loaded: ''Example-Platform.gemstone'', ''Example-Platform.pharo'', ''Example-Platform.squeak'' respectively will be loaded. Consequently we''ve updated the baselines with #baseline13: to reflect the structural changes and#version13: reflects the package versions.The platform-specific versions and branches are defined in the #for:do: block for the correspondingplatforms: #gemstone, #pharo, #squeak (in both methods)The result of the following expression will depend on the platform upon which you are running:"	(MetacelloTutorialConfig project version: ''1.3'') load."Note that when you execute the following expresson to load ''Example-Core'' that the correct''Example-Platform'' is loaded as well:"	(MetacelloTutorialConfig project version: ''1.3'') load: ''Example-Core''."If you look at the specification for ''Example-Core'' (in #baseline13:) you will note that ''Example-Core'' #includes: ''Example-Platform''. The #includes: directive means that the package ''Example-Platform'' should be loaded whenever the ''Example-Core'' package is loaded.Also note when you evaluate the following expression that the ''Example-Platform'' package is loadedbefore ''Example-Tests'' as if ''Example-Tests'' #requires: ''Example-Platform'':"	(MetacelloTutorialConfig project version: ''1.3'') load: ''Example-Tests''."When you use the #includes: directive, you are not only specifying that the listed packages shouldbe loaded when the parent package is loaded, but that the #included: packages should be loaded_before_ any packages that require the parent package."ProfStef next.'-=JUAMPI=-version  ^self optionAt: 'version'-=JUAMPI=-lesson10  -=JUAMPI=-baseline50Foo: arg1  < version: '5.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.2';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        arg1           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferFaux');           yourself ]-=JUAMPI=-root  ^root-=JUAMPI=-projectForScriptEngine: arg1 unconditionalLoad: arg2  ^self subclassResponsibility-=JUAMPI=-asBaselineProjectSpec  ^self-=JUAMPI=-requiredSpecsForPackageOrdering: arg1  ^#()-=JUAMPI=-primeRegistryProjectSpecRegistered: arg1  MetacelloProjectRegistration registrationForProjectSpec: arg1 ifAbsent: [:arg2 |  ^false ] ifPresent: [:arg3 :arg2 |  ^true ]-=JUAMPI=-handleOnDownGrade: arg1 onUpgrade: arg2  ^arg2 cull: self cull: self existingProjectRegistration cull: self newProjectRegistration-=JUAMPI=-beforeLoads  beforeLoads == nil ifTrue: [ beforeLoads := OrderedCollection new ].  ^beforeLoads-=JUAMPI=-silently: arg1  self loaderPolicy silently: arg1-=JUAMPI=-baselineVersion124ProjectToolBox: arg1  < version: '1.2.4-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://www.example.com/aa' ].  arg1 for: #common do: [ arg1 repository: 'http://www.example.com/ab' ]-=JUAMPI=-resolveRecordingPackageSpecReference: arg1 gofer: arg2  | tmp1 |  tmp1 := arg1 file == nil ifTrue: [ GoferPackageReference name: arg1 name ] ifFalse: [ GoferResolvedReference name: arg1 file repository: nil ].  arg1 repositorySpecs isEmpty ifTrue: [ self repositoryMap at: tmp1 packageName put: (arg2 repositories reject: [:arg3 |  arg3 = MetacelloPlatform current defaultPackageCache ]) ] ifFalse: [ self repositoryMap at: tmp1 packageName put: (arg1 repositorySpecs collect: [:arg4 |  arg4 createRepository ]) ].  ^tmp1-=JUAMPI=-postLoad: arg1  self evalDoits ifFalse: [ ^self ].  arg1 postLoadDoItBlock ~~ nil ifTrue: [ self afterLoads add: arg1 printString , ' load' ].  super postLoad: arg1-=JUAMPI=-isMutable  mutable ifNil: [ ^true ].  ^mutable-=JUAMPI=-requiredSpecNamesForPackageOrdering: arg1  ^(self requiredSpecsForPackageOrdering: arg1) collect: [:arg2 |  arg2 name ]-=JUAMPI=-resolvePackageSpec: arg1 gofer: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self retryingResolvePackageSpecReferences: arg1 gofer: arg2.  tmp2 := tmp1 last asMetacelloCachingResolvedReference.  tmp3 := tmp2 version.  (tmp4 := self ancestorsFor: arg1) ~~ nil ifTrue: [ tmp4 do: [:arg3 |  arg3 name = tmp3 info name ifTrue: [ | tmp5 |                    tmp5 := arg1 copy.                    tmp5 file: arg3 name.                    (MetacelloIgnorePackageLoaded signal: tmp5) ifFalse: [ ^nil ] ] ] ].  ^tmp2-=JUAMPI=-mergeIntoMetacelloPackages: arg1  arg1 addMember: (arg1 mergeMember           name: self name;           spec: self;           yourself)-=JUAMPI=-attribute  self deprecated: 'Use attributes instead'.  self attributes size > 1 ifTrue: [ self error: 'invalid use of attribute' ].  self attributes isEmpty ifTrue: [ ^nil ].  ^self attributes first-=JUAMPI=-exception: arg1  exception := arg1-=JUAMPI=-configurationRepository  ^MetacelloConfigurationResource current monticelloRepository-=JUAMPI=-aPackageIsLoaded: arg1  aPackageIsLoaded := arg1-=JUAMPI=-linearLoadPackageSpec: arg1 gofer: arg2  MetacelloPlatform current do: [ | tmp1 tmp2 tmp3 tmp4 |        tmp1 := self resolveRecordingPackageSpecReference: arg1 gofer: arg2.        tmp2 := [ self preLoad: arg1.        (MetacelloDirective loadPackage: arg1 externalReference: tmp1 loader: self) addTo: self loadDirective.        self postLoad: arg1 ].        (tmp3 := arg1 answers) notEmpty ifTrue: [ tmp2 valueSupplyingMetacelloAnswers: tmp3 ] ifFalse: [ tmp2 value ].        tmp4 := arg1 copy.        tmp4 name: tmp4 file.        self loadData addVersion: tmp4 versionInfo: tmp4 resolvedReference: tmp1 packageSpec: arg1 ] displaying: 'Recording ' , arg1 file-=JUAMPI=-spec  ^spec-=JUAMPI=-configurationExternalRef091: arg1  < version: '0.9.1'>  arg1 for: #common do: [ arg1 blessing: #version.        arg1 description: 'MetacelloScriptingResource>>configurationExternalRef090:'.        arg1 project: 'External' with: [ arg1                 className: 'ConfigurationOfExternal';                 version: '0.9.1';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]-=JUAMPI=-downloadZipArchive: arg1 to: arg2  arg2 asFileReference ensureDelete.  [:arg3 |  arg3 title: 'Download: ' , arg1 asString , ' to ' , arg2.  [ ZnClient new     url: arg1;     signalProgress: true;     downloadTo: arg2 ] on: HTTPProgress do: [:arg4 |  arg4 isEmpty ifFalse: [ arg3 current: arg4 percentage ].        arg4 resume ] ] asJob run.  ^ZipArchive new readFrom: arg2 asFileReference-=JUAMPI=-projectSpec  ^projectSpec-=JUAMPI=-testRemoveD  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1 add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  tmp1 remove: 'http://example.com/repository'.  tmp2 := false.  tmp1 map at: 'http://example.com/repository' ifAbsent: [ tmp2 := true ].  self assert: tmp2-=JUAMPI=-projectMethodSource  ^(self class sourceCodeAt: #project) asString-=JUAMPI=-version43SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version43Symbolic:) asString-=JUAMPI=-hash  ^self versionComponents hash-=JUAMPI=-packageSpecsInLoadOrderForMap: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self packageSpecsInLoadOrder.  tmp4 := (tmp3 := (arg1 values collect: [:arg2 |  arg2 name ]) asSet) copy.  (self import isNil and: [ self importArray isNil ]) ifTrue: [ ^tmp1 select: [:arg2 |  tmp3 includes: arg2 name ] ].  tmp1 do: [:arg2 |  tmp4 remove: arg2 name ifAbsent: [  ] ].  tmp2 := OrderedCollection new.  tmp6 := Dictionary new.  tmp7 := Dictionary new.  importArray ifNotNil: [ tmp1 do: [:arg2 |  importArray do: [:arg3 |  arg3 key = arg2 name ifTrue: [ tmp6 at: arg2 name put: arg2.                          (arg3 value select: [:arg4 |  tmp4 includes: arg4 ]) do: [:arg4 |  (tmp7 at: arg2 name ifAbsent: [ tmp7 at: arg2 name put: Set new ]) add: arg4 ] ] ] ] ].  self import ifNotNil: [ tmp1 do: [:arg2 |  arg2 name = self import ifTrue: [ tmp6 at: arg2 name put: arg2.                    tmp7 at: arg2 name put: tmp4 ] ] ].  tmp1 do: [:arg2 |  (tmp3 includes: arg2 name) ifTrue: [ tmp2 add: arg2 ].        tmp6 at: arg2 name ifPresent: [:arg5 |  (tmp7 at: arg2 name ifAbsent: [ #() ]) do: [:arg6 |  tmp2 add: (tmp5 := arg5 copy                             name: arg6;                             mergeImportLoads: {arg6};                             yourself).                    tmp5 projectReference name: arg6 ] ] ].  ^tmp2-=JUAMPI=-testBaselineOrConfigurationNameSuffix  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: tmp1 baselineOrConfigurationNameSuffix equals: 'MineSweeper'.  tmp1 := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self assert: tmp1 baselineOrConfigurationNameSuffix equals: 'Foo'-=JUAMPI=-version10Issue136: arg1  < version: '1.0' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 package: 'GoferBeau' with: 'GoferBeau-dkh.15' ]-=JUAMPI=-invalidConfiguration10: arg1  < version: '1.0.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>invalidConfiguration10: ... missing className:'.        arg1 project: 'External' with: [ arg1                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]-=JUAMPI=-setUpIssue77B  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfIssue77B-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline10B:' category: 'cat' timeStamp: '' source: self baseline10MethodSourceB)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())-=JUAMPI=-packageSpec  ^packageSpec-=JUAMPI=-locked  locked ifNil: [ locked := false ].  ^locked-=JUAMPI=-name  ^self description-=JUAMPI=-hasGroups  ^self hasOption: 'groups'-=JUAMPI=-existingProjectRegistration  ^existingProjectRegistration-=JUAMPI=-doingLoads: arg1  -=JUAMPI=-testForDoListAtrribute1Active  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self projectWith: #(#attribute1).  tmp2 := tmp1 version: '3.0-baseline'.  tmp3 := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec 	project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec 	group: ''Core'' with: #(''Example Project'' );	group: ''Core'' with: #(''Extra Project'' ).'.  tmp4 := tmp2 spec printString.  self assert: tmp3 equals: tmp4-=JUAMPI=-possibleVersions  ^self versionDoesNotExistException possibleVersions-=JUAMPI=-defaultRepositoryDescription  ^'http://www.squeaksource.com/MetacelloRepository'-=JUAMPI=-gtInspectorVersionsIn: arg1  < gtInspectorPresentationOrder: 40>  arg1 list     title: 'Versions';     display: #versions-=JUAMPI=-goferCommitProject: arg1  | tmp1 |  (tmp1 := self projectPackage) == nil ifTrue: [ ^false ].  ^tmp1 goferCommitPackage: arg1-=JUAMPI=-testRemoveA  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1 add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  tmp1 remove: (self repositorySpec           description: 'http://example.com/repository';           yourself).  tmp2 := false.  tmp1 map at: 'http://example.com/repository' ifAbsent: [ tmp2 := true ].  self assert: tmp2-=JUAMPI=-isResumable  ^false-=JUAMPI=-versionString: arg1  versionString := arg1-=JUAMPI=-closestAncestorVersionFor: arg1 ifNone: arg2  ^self localRepository closestAncestorVersionFor: arg1 ifNone: arg2-=JUAMPI=-recordingSpecLoader  ^self-=JUAMPI=-packageForVersion: arg1  | tmp1 |  tmp1 := self project packageSpec     name: arg1;     yourself.  self root packages add: tmp1-=JUAMPI=-version08: arg1  < version: '0.8' imports: #('0.7-baseline')>  arg1 for: #common do: [ arg1           package: 'Example-Core' with: 'Example-Core-anon.15';           package: 'Example-Tests' with: 'Example-Tests-anon.6';           package: 'Example-AddOn' with: 'Example-AddOn-anon.2' ]-=JUAMPI=-dataMap  dataMap == nil ifTrue: [ dataMap := Dictionary new ].  ^dataMap-=JUAMPI=-loaderPolicy  loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].  ^loaderPolicy-=JUAMPI=-= arg1  | tmp1 tmp2 |  arg1 species = self species ifFalse: [ ^false ].  tmp1 := self collapseZeros.  tmp2 := arg1 collapseZeros.  (tmp1 ~~ self or: [ tmp2 ~~ arg1 ]) ifTrue: [ ^tmp1 compareEqualTo: tmp2 ].  ^self compareEqualTo: arg1-=JUAMPI=-versionNumber  ^self project versionNumberClass fromString: self versionString-=JUAMPI=-referencedSpec  ^self-=JUAMPI=-projectVersion: arg1  | tmp1 |  arg1 ifNil: [ projectVersion := arg1.        ^self ].  (tmp1 := arg1 findDelimiters: {$# .         $* .         $?} startingAt: 1) <= arg1 size ifTrue: [ self resolveProjectVersionPattern: arg1 ] ifFalse: [ projectVersion := arg1 ]-=JUAMPI=-runCase  | tmp1 |  self doSilently ifFalse: [ ^super runCase ].  tmp1 := MetacelloPlatform current bypassGoferLoadUpdateCategories.  [ MetacelloPlatform current bypassGoferLoadUpdateCategories: true.  ^MetacelloPlatform current suspendSystemUpdateEventsDuring: [ super runCase ] ] ensure: [ MetacelloPlatform current bypassGoferLoadUpdateCategories: tmp1 ]-=JUAMPI=-configurationForVersion: arg1 with: arg2  arg2 setConfiguration: arg1 withInMetacelloConfig: self-=JUAMPI=-baselineVersion30Issue125: arg1  < version: '3.0-baseline' imports: #('2.0-baseline')>  arg1 for: #(#attribute1 #attribute2) do: [ arg1 description: 'MetacelloConfigurationResource>>baselineVersion30Issue125:'.        arg1           package: 'GoferFaux' with: [ arg1 requires: 'GoferFoo' ];           package: 'GoferBeau' with: [ arg1 requires: 'GoferFaux' ];           yourself ]-=JUAMPI=-versionSpec  ^versionSpec-=JUAMPI=-asConfigurationProjectSpec  ^self copyForScriptingInto: (MetacelloMCConfigurationOfProjectSpec for: self project asConfigurationProject)-=JUAMPI=-customProjectAttributes  ^#()-=JUAMPI=-testMCProjectSpec  | tmp1 tmp2 |  tmp1 := self projectSpec.  tmp1     name: 'Project';     projectPackage: self project packageSpec;     className: 'ConfigurationOfProject';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  self assert: tmp1 name equals: 'Project'.  self assert: tmp1 className equals: 'ConfigurationOfProject'.  self assert: tmp1 projectPackage name equals: tmp1 className.  self assert: tmp1 projectPackage file equals: tmp1 className.  tmp2 := tmp1 repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 type equals: 'directory'.  tmp2 := tmp1 repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 type equals: 'http'.  self assert: tmp2 username equals: 'dkh'.  self assert: tmp2 password equals: 'password'-=JUAMPI=-packageAndProjectNamesToLoad: arg1 loader: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := ((self packages select: [:arg3 |  arg3 isPackageLoaded: arg2 ]) collect: [:arg3 |  arg3 name ]) asSet , arg1.  tmp2 := Dictionary new.  self projects do: [:arg4 |  arg4 className ~~ nil ifTrue: [ | tmp5 tmp6 |              tmp5 := tmp2 at: arg4 className ifAbsent: [ tmp5 := OrderedCollection new.                    tmp2 at: arg4 className put: tmp5.                    tmp5 ].              (tmp6 := arg4 loadedPackageNames: arg2) isEmpty ifFalse: [ tmp5 add: arg4 -> (tmp6 -> arg4 loadPackageList) ] ] ].  tmp3 := Set new.  tmp2 keysAndValuesDo: [:arg5 :arg6 |  arg6 size <= 1 ifTrue: [ arg6 do: [:arg7 |  tmp3 add: arg7 key name ] ] ifFalse: [ arg6 do: [:arg7 |  | tmp6 tmp7 |                    tmp6 := arg7 value key.                    tmp7 := arg7 value value.                    (tmp7 difference: tmp6) isEmpty ifTrue: [ tmp3 add: arg7 key name ] ] ] ].  tmp4 := tmp1 , tmp3.  tmp4 isEmpty ifTrue: [ ^self spec defaultPackageNames ].  ^tmp4-=JUAMPI=-buildMapFrom: arg1 for: arg2  | tmp1 |  tmp1 := Dictionary new.  arg1 do: [:arg3 |  | tmp2 tmp3 |        tmp2 := arg3 key.        (arg2 includes: tmp2) ifFalse: [ self error: 'package ' , tmp2 printString , ' not found in packages.' ].        tmp1 at: tmp2 put: arg3 value ].  ^tmp1-=JUAMPI=-projectPath  ^projectPath-=JUAMPI=-conflictOf20: arg1  < version: '2.0.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>conflictOf20:'.        arg1 author: 'dkh'.        arg1 timestamp: '6/1/2012 14:46' ].  arg1 for: #custom do: [ arg1 configuration: 'ExternalX' with: [ arg1                 version: '0.9.0';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]-=JUAMPI=-setUpBaselineIssue215  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfIssue215-dkh.1'.  tmp2 := #BaselineOfIssue215.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'postloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #postloadDoIt) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #preloadDoIt) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineIssue215:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue215:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4-=JUAMPI=-workingCopy  ^self projectPackage workingCopy-=JUAMPI=-warningReasonCodes  ^super warningReasonCodes , #(#loadWarning #notDevelopmentVersion #stableDevelopmentVersion)-=JUAMPI=-hasVersion: arg1  self version: arg1 ifAbsent: [ ^false ].  ^true-=JUAMPI=-versionString  ^self versionNumber versionString-=JUAMPI=-defaultTimeout  ^60000-=JUAMPI=-baselineOfProjectSpecClass  ^MetacelloCypressBaselineProjectSpec-=JUAMPI=-loads: arg1 constructor: arg2  arg2 loadsForProject: arg1-=JUAMPI=-useCurrentVersion  ^self options at: #useCurrentVersion ifAbsent: [ false ]-=JUAMPI=-version10: arg1  < version: '1.0' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1           package: 'Example-Core' with: 'Example-Core-anon.14';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ]-=JUAMPI=-onWarning: arg1  self options at: #onWarning put: arg1-=JUAMPI=-packageloads  packageloads == nil ifTrue: [ packageloads := OrderedCollection new ].  ^packageloads-=JUAMPI=-reset  attributeMap := attributeOrder := nil-=JUAMPI=-target: arg1  target := arg1-=JUAMPI=-aLoadedPackageIsNotCurrent: arg1  aLoadedPackageIsNotCurrent := arg1-=JUAMPI=-decrementMajorVersion  self decrementVersionAt: 1-=JUAMPI=-packagesNeedSavingVisited: arg1 using: arg2 into: arg3  ^self loader packagesNeedSavingUsing: arg2 into: arg3-=JUAMPI=-repository: arg1 username: arg2 password: arg3  self root repository: arg1 username: arg2 password: arg3 constructor: self-=JUAMPI=-createFiletreeRepository: arg1  MCRepository findFiletreeAlternateFormat: arg1 ifFound: [:arg2 |  ^arg2 createRepositoryFromSpec: arg1 on: self ].  ^super createFiletreeRepository: arg1-=JUAMPI=-handleResolutionFor: arg1  self subclassResponsibility-=JUAMPI=-extractTypeFromDescription: arg1  arg1 == nil ifTrue: [ ^nil ].  ((arg1 beginsWith: '/') or: [ arg1 second = $: ]) ifTrue: [ ^'directory' ].  (arg1 beginsWith: 'dictionary://') ifTrue: [ ^'dictionary' ].  (arg1 beginsWith: 'filetree://') ifTrue: [ ^'filetree' ].  (arg1 beginsWith: 'tonel://') ifTrue: [ ^'tonel' ].  (arg1 beginsWith: 'github://') ifTrue: [ ^'github' ].  (arg1 beginsWith: 'gitorious://') ifTrue: [ ^'gitorious' ].  (arg1 beginsWith: 'bitbucket://') ifTrue: [ ^'bitbucket' ].  ^'http'-=JUAMPI=-hasPackage: arg1  | tmp1 |  tmp1 := MCWorkingCopy allManagers detect: [:arg2 |  arg2 packageName = arg1 ] ifNone: [ nil ].  ^tmp1 notNil-=JUAMPI=-notEmpty  ^self list notEmpty-=JUAMPI=-projectName  ^self projectSpec name-=JUAMPI=-isPackageLoaded: arg1  MCWorkingCopy allManagers detect: [:arg2 |  arg2 packageName = self file ] ifNone: [ ^false ].  ^true-=JUAMPI=-lesson10  -=JUAMPI=-methodSections: arg1  methodSections := arg1-=JUAMPI=-versionString  ^MetacelloMCBaselineProject singletonVersionName-=JUAMPI=-baseline13C: arg1  < version: '1.3'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GeauxBeau' with: 'GeauxBeau-dkh.56';           yourself ]-=JUAMPI=-projectName  ^self projectReference name-=JUAMPI=-aProjectIsLoaded  ^aProjectIsLoaded-=JUAMPI=-configuration  ^configuration-=JUAMPI=-versionString: arg1 constructor: arg2  self error: 'versionString: not allowed in a baseline project spec'-=JUAMPI=-repository: arg1 username: arg2 password: arg3  self repositories repository: arg1 username: arg2 password: arg3.  self projectPackage: nil-=JUAMPI=-packageDirectivesDo: arg1  self loadDirectives do: [:arg2 |  arg2 packageDirectivesDo: arg1 ]-=JUAMPI=-baselineProjectSpec  ^baselineProjectSpec-=JUAMPI=-configurationProjectSpecs  | tmp1 |  tmp1 := OrderedCollection new.  self configurationRegistry keysAndValuesDo: [:arg1 :arg2 |  tmp1 add: (self projectSpecForClassNamed: arg1 ifAbsent: [ self error: 'not expected' ]) ].  ^tmp1 asArray-=JUAMPI=-projectAttributes  projectAttributes ~~ nil ifTrue: [ ^projectAttributes ].  ^#()-=JUAMPI=-projectWith: arg1  | tmp1 |  tmp1 := MetacelloMCProject new.  tmp1 projectAttributes: arg1.  MetacelloVersionConstructor on: self projectClass new project: tmp1.  tmp1 loader: MetacelloNullRecordingMCSpecLoader new.  tmp1 loader evalDoits: false.  ^tmp1-=JUAMPI=-projectDo: arg1 packageDo: arg2 groupDo: arg3  self packageSpecsInLoadOrder do: [:arg4 |  arg4 projectDo: arg1 packageDo: arg2 groupDo: arg3 ]-=JUAMPI=-baseline61Fix: arg1  < version: '6.1'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           package: 'GoferFaux' with: 'GoferFaux-tg.31';           yourself ]-=JUAMPI=-validateProjectVersionLoad: arg1 loads: arg2  | tmp1 tmp2 tmp3 |  (tmp1 := (self validateProjectVersion: arg1) select: [:arg3 |  arg3 isError ]) notEmpty ifTrue: [ ^tmp1 ].  tmp2 := self configurationClass project.  tmp3 := tmp2 version: arg1 ifAbsent: [ self recordValidationError: 'Version ' , arg1 printString , ' does not exist.' callSite: #validateProjectVersionLoad:loads: reasonCode: #cannotResolveVersion.        ^self validationReport ].  tmp3 blessing = #broken ifTrue: [ self error: 'The specified version is #broken' ].  self validateCleanLoadAndTestsForVersion: tmp3 loads: arg2.  ^self validationReport-=JUAMPI=-postCopy  super postCopy.  blessing := blessing copy.  description := description copy.  author := author copy.  timestamp := timestamp copy.  packageList := packageList copy-=JUAMPI=-category: arg1  category := arg1-=JUAMPI=-preLoadDo: arg1  arg1 value: self-=JUAMPI=-alternateRepository  ^MetacelloAlternateResource current monticelloRepository-=JUAMPI=-updateVersionMethodForVersion: arg1 versionSpecsDo: arg2  ^self updateVersionMethodForVersion: arg1 updateProjects: true updatePackages: true versionSpecsDo: arg2-=JUAMPI=-timestamp  ^self basicSpec timestamp value-=JUAMPI=-currentVersion  ^self version isSomethingLoaded ifTrue: [ self version ] ifFalse: [ nil ]-=JUAMPI=-version102ProjectToolBox: arg1  < version: '1.0.2-baseline'>  arg1 for: #common do: [ arg1 preLoadDoIt: #preloadForCore.        arg1 postLoadDoIt: #postloadForCore:package:.        arg1           package: 'Example-Core' with: [ arg1 includes: #('Example-AddOn') ];           package: 'Example-AddOn' with: [ arg1 requires: #('Example-Core') ];           package: 'Example-Tests' with: [ arg1 requires: #('Example-AddOn') ] ]-=JUAMPI=-description: arg1  arg1 setDescriptionInMetacelloVersion: self-=JUAMPI=-isPossibleBaseline  self subclassResponsibility-=JUAMPI=-spotterForRequiresFor: arg1  < spotterOrder: 2>  arg1 listProcessor     title: 'Requires';     allCandidates: [ self requires ];     itemName: [:arg2 |  arg2 name ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: true-=JUAMPI=-versionString  ^versionString-=JUAMPI=-testVersion13  self deny: (self versionClass fromString: '0.8') <= (self versionClass fromString: '0.7').  self deny: (self versionClass fromString: '0.8.1.8') <= (self versionClass fromString: '0.7.0.5')-=JUAMPI=-isConfigurationName  ^self baselineOrConfigurationName matchesRegex: 'ConfigurationOf.+'-=JUAMPI=-evaluateMethodSection: arg1 version: arg2  | tmp1 |  tmp1 := self project versionSpec.  tmp1 versionString: arg2.  arg1 versionSpec: tmp1.  currentSection := arg1.  self with: tmp1 during: arg1 block.  arg1 methodSections do: [:arg3 |  self evaluateMethodSection: arg3 version: arg2 ]-=JUAMPI=-fetchRequiredFromArray: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self versionSpec loader.  tmp3 := tmp1 fetchingSpecLoader.  tmp2 := tmp3 actionLabel , self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloPlatform current do: [ [ self versionSpec loader: tmp3.        MetacelloPlatform current useStackCacheDuring: [:arg2 |  ^self executeLoadFromArray: arg1 ] defaultDictionary: Dictionary new ] ensure: [ self versionSpec loader: tmp1 ] ] displaying: tmp2-=JUAMPI=-baseline10: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: self directoryForPlatform ] ]-=JUAMPI=-packageNamed: arg1 forLoad: arg2 forMap: arg3 ifAbsent: arg4  | tmp1 |  ^arg3 at: arg1 ifAbsent: [ (self importArray notNil or: [ self import notNil ]) ifTrue: [ importArray ifNotNil: [ importArray do: [:arg5 |  ((arg5 value includes: arg1) and: [ arg3 includesKey: arg5 key ]) ifTrue: [ tmp1 := (arg3 at: arg5 key)                                   mergeImportLoads: {arg1};                                   yourself ] ].                    tmp1 ifNotNil: [ ^tmp1 ] ].              (tmp1 isNil and: [ self import notNil ]) ifTrue: [ ^(arg3 at: self import ifAbsent: arg4)                       mergeImportLoads: {arg1};                       yourself ] ].        (arg1 = 'default' or: [ arg1 = 'ALL' ]) ifTrue: [ self project groupSpec                 name: arg1;                 includes: self packageNames;                 yourself ] ifFalse: [ arg4 value ] ]-=JUAMPI=-loadType  ^#linear-=JUAMPI=-testProjectTagsUrlFor  | tmp1 |  tmp1 := MCGitlabRepository location: 'gitlab://pharo-project/pharo:master/src'.  self assert: (tmp1 projectTagsUrlFor: 'pharo-project/pharo') equals: 'https://gitlab.com/api/v4/projects/pharo-project/pharo/repository/tags'.  tmp1 := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo:master/src'.  self assert: (tmp1 projectTagsUrlFor: 'pharo-project/pharo') equals: 'https://git.pharo.org/api/v4/projects/pharo-project/pharo/repository/tags'-=JUAMPI=-testMixedStack  | tmp1 |  self assert: (tmp1 := self mixedStack) identicalTo: 4-=JUAMPI=-latestVersion  ^self version-=JUAMPI=-computeVersionStatus: arg1 matchBlock: arg2  | tmp1 |  tmp1 := arg1 ifNil: [ self isPartiallyCurrent ] ifNotNil: [ self isPartiallyCurrentAgainst: arg1 ].  tmp1 isAllLoadedToSpec: arg2.  tmp1 isLoadedToSpec: arg2.  tmp1 isLoadedMatchConstraints: arg2.  tmp1 isSomethingLoaded: arg2-=JUAMPI=-projectSpecCreationBlock  ^[:arg1 |  {(MetacelloMCProject new projectSpec name: arg1)} ]-=JUAMPI=-symbolicVersionMap: arg1  symbolicVersionMap := arg1-=JUAMPI=-projectForVersion: arg1  self project: arg1 with: ''-=JUAMPI=-handleResolutionFor: arg1  ^arg1 handleDowngrade: self-=JUAMPI=-className: arg1  self root className: arg1 constructor: self-=JUAMPI=-tempRepositories  tempRepositories ifNil: [ tempRepositories := OrderedCollection new ].  ^tempRepositories-=JUAMPI=-constructClassName  ^nil-=JUAMPI=-tearDown  | tmp1 tmp2 |  self tearDownPackages.  self tearDownRepositories.  MetacelloProjectRegistration registry: registry.  self disableUndefinedSymbolTracking ifTrue: [ MetacelloPlatform current reenableUndefinedSybolUpdates: undefinedSymbols ].  tmp1 := MCWorkingCopy allManagers collect: [:arg1 |  arg1 packageName ].  tmp2 := tmp1 difference: initialWorkingCopyList.  tmp2 do: [:arg2 |  MetacelloNotification signal: 'leaked package from ' , self printString , ' -> ' , arg2 printString ].  self assert: tmp2 isEmpty.  super tearDown-=JUAMPI=-registrationForExactClassNamed: arg1 ifAbsent: arg2  self configurationRegistry at: arg1 ifPresent: [:arg3 |  ^arg3 ].  self baselineRegistry at: arg1 ifPresent: [:arg3 |  ^arg3 ].  ^arg2 value-=JUAMPI=-mixedStackCall  ^MetacelloPlatform current stackCacheFor: #mixedStack at: #key doing: [:arg1 |  | tmp1 |        tmp1 := arg1 at: #x ifAbsent: [ 0 ].        tmp1 > 3 ifTrue: [ ^tmp1 ].        tmp1 := tmp1 + 1.        arg1 at: #x put: tmp1.        self assert: self cachedReturnOfValue identicalTo: 6.        self mixedStackCall ]-=JUAMPI=-baseline: arg1 with: arg2  self root baseline: arg1 with: arg2 constructor: self-=JUAMPI=-testRemovePackageB  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp1 remove: {(self packageSpec           name: 'Package';           yourself)}.  tmp2 := false.  tmp1 packageNamed: 'Package' ifAbsent: [ tmp2 := true ].  self assert: tmp2-=JUAMPI=-externalBaselineXXX: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>externalBaselineXXX:'.        arg1           package: 'External-CoreX';           package: 'External-TestsX' with: [ arg1 requires: 'External-CoreX' ];           yourself.        arg1           group: 'Core' with: #('External-CoreX');           group: 'default' with: #('Core');           group: 'Tests' with: #('External-TestsX');           yourself ].  arg1 for: #custom do: [ arg1 package: 'External-UIX'.        arg1 group: 'UI' with: #('External-UIX') ]-=JUAMPI=-versionString  ^self versionDoesNotExistException versionString-=JUAMPI=-loaderPolicy  ^loaderPolicy-=JUAMPI=-match: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 asMetacelloVersionNumber.  tmp2 := self size.  tmp3 := tmp1 size.  tmp2 = tmp3 ifFalse: [ tmp2 < tmp3 ifTrue: [ ^false ].        (tmp1 at: tmp3) ~= '?' ifTrue: [ ^false ].        tmp2 := tmp3 ].  1 to: tmp2 do: [:arg2 |  | tmp4 |        tmp4 := (tmp1 at: arg2) asString.        tmp4 = '?' ifTrue: [ arg2 = tmp2 ifFalse: [ ^self error: 'Invalid version match pattern: ' , arg1 printString ] ] ifFalse: [ (tmp4 match: (self at: arg2) asString) ifFalse: [ ^false ] ] ].  ^true-=JUAMPI=-projectVersion10Issue283: arg1  < version: '1.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 configuration: 'ProjectIssue283' with: [ arg1                 version: #stable;                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]-=JUAMPI=-projectWith: arg1  | tmp1 |  tmp1 := MetacelloProject new.  tmp1 projectAttributes: arg1.  MetacelloVersionConstructor on: self project: tmp1.  ^tmp1-=JUAMPI=-unregisterProjectRegistration: arg1  arg1 configurationProjectSpec ifNotNil: [:arg2 |  self configurationRegistry removeKey: arg2 className ifAbsent: [ self error: 'unexpectedly missing project registration' ] ].  arg1 baselineProjectSpec ifNotNil: [:arg2 |  self baselineRegistry removeKey: arg2 className ifAbsent: [ self error: 'unexpectedly missing project registration' ] ]-=JUAMPI=-fetchProject  ^self fetchProject: MetacelloLoaderPolicy new-=JUAMPI=-preloadDoItMethodSource  ^(self class sourceCodeAt: #preloadDoIt) asString-=JUAMPI=-testAddB  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     add: '/opt/gemstone/repository'.  tmp2 := tmp1 map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: 'http://example.com/repository'.  self assert: tmp2 type equals: 'http'.  self assert: tmp2 username equals: 'dkh'.  self assert: tmp2 password equals: 'password'.  tmp2 := tmp1 map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: '/opt/gemstone/repository'.  self assert: tmp2 type equals: 'directory'-=JUAMPI=-setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:arg1 |  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: arg1 packageName) info: (MCVersionInfo name: arg1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: arg1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: arg1 packageName asSymbol)) with: (MCClassDefinition name: (arg1 packageName copyWithout: $-) asSymbol superclassName: #Object category: arg1 packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]-=JUAMPI=-testBaseline10Projects  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self project.  tmp2 := tmp1 version: '1.0-baseline'.  tmp3 := #('UTF8').  tmp4 := tmp2 projects.  self assert: tmp4 size equals: tmp3 size.  tmp4 do: [:arg1 |  self assert: (tmp3 includes: arg1 name) ]-=JUAMPI=-versionOfXX: arg1  < version: '0.9.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>versionOfXX:'.        arg1 author: 'dkh'.        arg1 timestamp: '5/4/2012 14:16' ].  arg1 for: #custom do: [ arg1 baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]-=JUAMPI=-version134ProjectToolBox: arg1  < version: '1.3.4-baseline'>  arg1 for: #common do: [  ]-=JUAMPI=-repository: arg1  self root repository: arg1 constructor: self-=JUAMPI=-repository: arg1 username: arg2 password: arg3  | tmp1 |  tmp1 := self project repositorySpec     description: arg1;     username: arg2;     password: arg3;     yourself.  self addMember: (self addMember           name: tmp1 name;           spec: tmp1;           yourself)-=JUAMPI=-testEqualityComparison  self deny: '1.0.0+-' asMetacelloSemanticVersionNumber equals: '1.0.0--' asMetacelloSemanticVersionNumber.  self sampleVersionStrings do: [:arg1 |  self assert: arg1 asMetacelloSemanticVersionNumber equals: arg1 asMetacelloSemanticVersionNumber ]-=JUAMPI=-postLoad: arg1  | tmp1 |  (tmp1 := arg1 postLoadDoItBlock) ~~ nil ifTrue: [ tmp1 valueWithPossibleArgs: {self .               arg1} ]-=JUAMPI=-testMCVersionSpec  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self versionSpec     blessing: #baseline;     versionString: '1.0';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  tmp1 packages     add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself);     add: (self packageSpec           name: 'AnotherPackage';           yourself);     add: (self packageSpec           name: 'IncludedPackage';           yourself);     add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself);     add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself);     yourself.  self assert: tmp1 blessing value equals: #baseline.  self assert: tmp1 versionString value equals: '1.0'.  tmp5 := tmp1 repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp5 type equals: 'directory'.  tmp5 := tmp1 repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp5 type equals: 'http'.  self assert: tmp5 username equals: 'dkh'.  self assert: tmp5 password equals: 'password'.  tmp4 := tmp1 packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: tmp4 name equals: 'Package'.  tmp3 := tmp1 packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (tmp3 includes includes: 'Core').  tmp2 := tmp1 packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: tmp2 projectName equals: 'Project'.  self assert: tmp2 versionString equals: #stable.  tmp1 projectDo: [:arg1 |  arg1 == tmp2 ] packageDo: [:arg2 |  arg2 == tmp4 ] groupDo: [:arg3 |  arg3 == tmp3 ]-=JUAMPI=-allPackagesForSpecNamed: arg1 ifAbsent: arg2  ^arg1 resolvePackageSpecsNamedForMetacelloMCVersion: self visited: MetacelloVisitedPackages new ifAbsent: arg2-=JUAMPI=-testRepositoryUrl  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: tmp1 repositoryUrl equals: 'github://juliendelplanque/MineSweeper/repository'-=JUAMPI=-errorMap  errorMap ifNil: [ errorMap := Dictionary new ].  ^errorMap-=JUAMPI=-useStackCacheDuring: arg1 defaultDictionary: arg2  | tmp1 |  tmp1 := MetacelloStackCacheNotification signal.  tmp1 == nil ifTrue: [ tmp1 := arg2 == nil ifTrue: [ Dictionary new ] ifFalse: [ arg2 ] ].  [ ^arg1 value: tmp1 ] on: MetacelloStackCacheNotification , MetacelloClearStackCacheNotification do: [:arg3 |  (arg3 isKindOf: MetacelloStackCacheNotification) ifTrue: [ arg3 resume: tmp1 ].        (arg3 isKindOf: MetacelloClearStackCacheNotification) ifTrue: [ | tmp2 |              tmp2 := arg3 cacheNames.              tmp2 ifNil: [ tmp2 := tmp1 keys ].              tmp2 do: [:arg4 |  (tmp1 includesKey: arg4) ifTrue: [ | tmp3 |                          tmp3 := tmp1 at: arg4.                          tmp3 keys do: [:arg5 |  tmp3 removeKey: arg5 ].                          tmp1 removeKey: arg4 ] ].              arg3 resume ] ]-=JUAMPI=-lastVersion  ^self version-=JUAMPI=-hasRepository  ^false-=JUAMPI=-setName: arg1  self shouldBeMutable.  name := arg1-=JUAMPI=-removeGroupForVersion: arg1  | tmp1 |  tmp1 := self project groupSpec     name: arg1;     yourself.  self root packages remove: tmp1-=JUAMPI=-sortedAndFilteredVersions  ^(self map values asArray sort: [:arg1 :arg2 |  arg1 >= arg2 ]) select: [:arg3 |  (#(structural broken baseline) includes: arg3 blessing) not ]-=JUAMPI=-testMergeProjectB  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self packagesSpec.  tmp2 := self projectSpec     name: 'Project';     className: 'ConfigurationOfProjectA';     versionString: #stable;     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  tmp4 := self project projectReferenceSpec     name: tmp2 name;     projectReference: tmp2;     yourself.  tmp1 add: tmp4.  tmp2 := self projectSpec     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     operator: #<;     loads: #('MyPackage');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  tmp4 := self project projectReferenceSpec     name: tmp2 name;     projectReference: tmp2;     yourself.  tmp1 merge: {tmp4}.  tmp3 := tmp1 packageNamed: 'Project' ifAbsent: [ self assert: false ].  tmp2 := tmp3 referencedSpec.  self assert: tmp2 name equals: 'Project'.  self assert: tmp2 className equals: 'ConfigurationOfProject'.  self assert: tmp2 versionString equals: '1.0'.  self assert: tmp2 operator identicalTo: #<.  self assert: tmp2 loads equals: #('MyPackage').  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoIt.  tmp2 projectDo: [:arg1 |  self assert: tmp2 identicalTo: arg1 ] packageDo: [:arg2 |  self assert: false ] groupDo: [:arg2 |  self assert: false ]-=JUAMPI=-testVersion23  self assert: (MetacelloVersionNumber fromString: '3.0.0.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0') > (MetacelloVersionNumber fromString: '3.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3') > (MetacelloVersionNumber fromString: '3-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3') > (MetacelloVersionNumber fromString: '3.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0') > (MetacelloVersionNumber fromString: '3.0.0-rc.1')-=JUAMPI=-setIncludes: arg1  includes := arg1-=JUAMPI=-methodSections  methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].  ^methodSections-=JUAMPI=-bitbucketUser: arg1 project: arg2 commitish: arg3 path: arg4  | tmp1 |  tmp1 := arg3.  tmp1 isEmpty ifTrue: [ tmp1 := 'master' ].  self repository: 'bitbucket://' , arg1 , '/' , arg2 , ':' , tmp1 , '/' , arg4-=JUAMPI=-specsNamed: arg1 projectDo: arg2 packageDo: arg3 groupDo: arg4  | tmp1 |  tmp1 := self packages map.  arg1 do: [:arg5 |  | tmp2 |        (tmp2 := tmp1 at: arg5 ifAbsent: [  ]) ~~ nil ifTrue: [ tmp2 projectDo: arg2 packageDo: arg3 groupDo: arg4 ] ]-=JUAMPI=-newVersionForWorkingCopy: arg1  ^arg1 newVersion-=JUAMPI=-lesson11  -=JUAMPI=-spec  ^spec-=JUAMPI=-isPossibleBaseline  self projectDo: [:arg1 |  arg1 isPossibleBaseline ifFalse: [ ^false ] ] packageDo: [:arg2 |  arg2 isPackageLoaded ifFalse: [ ^false ] ] groupDo: [:arg3 |   ].  ^true-=JUAMPI=-baseline40MethodSourceProjectIssue95  ^(self class sourceCodeAt: #baseline40ProjectIssue95:) asString-=JUAMPI=-setUpConfigurationNextedIssue84dkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfNestedIssue84-dkh.1'.  tmp2 := #ConfigurationOfNestedIssue84.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'version10NestedIssue84:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10NestedIssue84:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionNumberClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionNumberClass) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4-=JUAMPI=-resolveToPackagesIn: arg1 andProjects: arg2 visited: arg3  ^arg2 ifTrue: [ {self} ] ifFalse: [ self resolveToPackagesIn: arg1 visited: arg3 ]-=JUAMPI=-repositoryForProject: arg1  self repositoryForSpec: arg1-=JUAMPI=-isSample  ^false-=JUAMPI=-externalRepositoryContents  ^#('External-CoreX-dkh.1' 'BaselineOfExternalX-dkh.1' 'BaselineOfGithubRefXX-dkh.1' 'BaselineOfGithubRefIV-dkh.1' 'BaselineOfGithubRefV-dkh.1' 'BaselineOfGithubRefVI-dkh.1' 'BaselineOfGithubRefVII-dkh.1' 'BaselineOfGithubRefVIII-dkh.1' 'BaselineOfGithubRefIX-dkh.1' 'BaselineOfGithubRefXI-dkh.1' 'BaselineOfGithubRefXII-dkh.1' 'BaselineOfGithubRefXIII-dkh.1')-=JUAMPI=-goferCommitPackage: arg1  | tmp1 tmp2 |  ^(file notNil and: [ self name = self file ]) ifTrue: [ tmp1 := self loader latestPackage: self name fromRepository: self repositorySpecs.        tmp2 := self copy.        tmp2 file: tmp1.        tmp2 goferCommitPackage: arg1 ] ifFalse: [ self loader goferCommitPackageUsing: self repositorySpecs commitMessage: arg1 ]-=JUAMPI=-asProjectRegistration  ^MetacelloProjectRegistration fromMCBaselineProjectSpec: self-=JUAMPI=-project  ^self projectWith: #()-=JUAMPI=-lesson10  ^Lesson title: 'Lesson 10' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #baseline10:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version10:."In #baseline10: we''ve added two things: the ''Example-AddOnTests'' package and a specification for groups. The ''Example-AddOnTests'' package has been added to make the idea of needing to group packages alittle more appealing. The package requires ''Example-AddOn'' and ''Example-Tests''.With two Test packages it would be convenient to be able to load all of the tests with a simpleexpression like the following:"  (MetacelloTutorialConfig project version: ''1.0'') load: { ''Tests''. }."instead of having to explicitly list all of the test projects like this:"  (MetacelloTutorialConfig project version: ''1.0'') 	load: { ''Example-Tests''. ''Example-AddOnTests''. }."This becomes especially useful if over time the project evolves to have more component and test packages.The ''default'' group is special in that when a ''default'' group is defined, the #load method loadsthe members of the ''default'' group instead of loading all of the packages:"  (MetacelloTutorialConfig project version: ''1.0'') load."If you want to load all of the packages in a project, then the pseudo group ''ALL'' may be used asfollows:"  (MetacelloTutorialConfig project version: ''1.0'') load: ''ALL''.ProfStef next.'-=JUAMPI=-version41SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version41Symbolic:) asString-=JUAMPI=-isConfigurationOfProjectSpec  ^true-=JUAMPI=-onConflict: arg1  self options at: #onConflict put: arg1-=JUAMPI=-baselineVersion40Issue119: arg1  < version: '4.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        arg1 package: 'GoferBar' ]-=JUAMPI=-printOn: arg1  self print: self normalVersion prefix: nil on: arg1.  self print: self preReleaseVersion prefix: $- on: arg1.  self print: self buildVersion prefix: $+ on: arg1-=JUAMPI=-setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new-=JUAMPI=-setUpConfigurationOfAtomicFan  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfAtomicFan-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline20Fan:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFan) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline31Fan:' category: 'cat' timeStamp: '' source: self baseline31MethodSourceFan) .   (MCMethodDefinition className: tmp2 asString selector: 'postLoad31baseline' category: 'cat' timeStamp: '' source: self postLoad31baselineMethodSource)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())-=JUAMPI=-file: arg1  file := arg1-=JUAMPI=-versionSpec  ^self project versionSpec-=JUAMPI=-loadUsing: arg1  self loader doingLoads: [ self explicitLoadUsing: arg1 ]-=JUAMPI=-validateBaselineOf  self validatePragmas.  ^self validateBaselineProject-=JUAMPI=-project  ^self versionSpec project-=JUAMPI=-asMetacelloSemanticVersionNumber  ^self-=JUAMPI=-testInvalidSpecialMatch  self should: [ (self versionClass fromString: '1.1') match: '?.?' ] raise: Error-=JUAMPI=-validateConfiguration  | tmp1 |  tmp1 := (MetacelloMCVersionValidator validateConfiguration: project configuration class recurse: false) select: [:arg1 |  arg1 isCritical ].  tmp1 notEmpty ifTrue: [ MetacelloValidationFailure issues: tmp1 message: 'There are critical issues in the configuration' ]-=JUAMPI=-primeRegistryFromImage: arg1  self primeRegistryFromImage: MetacelloProjectRegistration configurationClasses baselineClasses: MetacelloProjectRegistration baselineClasses prioritizeConfiguration: arg1-=JUAMPI=-modifiedPackageSpecs: arg1 packageSpecsDo: arg2  | tmp1 |  tmp1 := (self project version: arg1) spec.  tmp1 projectDo: [:arg3 |   ] packageDo: [:arg4 |  | tmp2 |        tmp2 := arg4 workingCopy.        tmp2 ~~ nil ifTrue: [ tmp2 modified ifTrue: [ arg2 value: tmp1 value: arg4 value: tmp2 ] ] ] groupDo: [:arg3 |   ]-=JUAMPI=-baselineOfProjectSpec  ^self baselineOfProjectSpecClass for: self-=JUAMPI=-setUpIssue399  | tmp1 |  tmp1 := self setUpIssue399CoreSampledkh1.  tmp1 := self setUpIssue399CoreSampledkh2: {tmp1}.  self     setUpIssue399CoreExternaldkh1;     setUpBaselineIssue399;     setUpBaselineIssue399Cypress;     yourself-=JUAMPI=-latestVersionMatching: arg1 excludedBlessings: arg2  ^self latestVersionMatching: arg1 includedBlessings: #() excludedBlessings: arg2-=JUAMPI=-useCurrentVersion: arg1  self options at: #useCurrentVersion put: arg1-=JUAMPI=-label  ^self spec label-=JUAMPI=-hasRepository  ^self repositorySpecs notEmpty-=JUAMPI=-loader  loader == nil ifTrue: [ loader := self versionSpec loader copy.        loader spec: self.        loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy ] ].  ^loader-=JUAMPI=-createDevelopmentVersion  ^Lesson title: '2. Create development version' lesson: '"After the configuration and initial baseline version have been created, define the initial development version:"		MetacelloToolBox		createDevelopment: ''1.0''		for: ''Example''		importFromBaseline: ''1.0-baseline''		description: ''initial version''."After evaluating the above expression, take a look at the #version10: method in ConfigurationOfExample:"	Smalltalk tools browser openOnClass: ConfigurationOfExample selector: #version10:."The current version of the Shout project has been filled in as well as the current version of the ProfStef packages.When a new development version is created the #development symbolic version is defined as well:"	Smalltalk tools browser openOnClass: ConfigurationOfExample selector: #development:."The #development version is defined as 1.0 for all platforms.Note that the #development symbolic version is used in a number of the Development Support scripts, so you want to make sure that it is kept up-to-date."ProfStef next.'-=JUAMPI=-projectPackage: arg1  self root projectPackage: arg1 constructor: self-=JUAMPI=-setUpIssue399CoreSampledkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'Issue399-Core-dkh.1'.  tmp2 := #Issue399Sample.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp1 packageName instVarNames: #() comment: '')}.  sampleRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4-=JUAMPI=-setUpConfigurationOfFeaux  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfFeaux-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40Feaux:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceFeaux)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())-=JUAMPI=-setUpConfigurationOfFix  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfFix-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline60Fix:' category: 'cat' timeStamp: '' source: self baseline60MethodSourceFix) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline61Fix:' category: 'cat' timeStamp: '' source: self baseline61MethodSourceFix)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())-=JUAMPI=-configurationRepositoryContents  ^#('ConfigurationOfExternalX-dkh.1' 'ConfigurationOfExternalXX-dkh.1' 'ConfigurationOfExternalXXX-dkh.1' 'ConfigurationOfExternalIV-dkh.1' 'MarianosImage-dkh.1')-=JUAMPI=-version20Foo: arg1  < version: '2.0' imports: #('2.0-baseline')>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #release.        arg1           package: 'GoferBar' with: 'GoferBar-dkh.1';           package: 'GoferFoo' with: 'GoferFoo-dkh.4';           package: 'GoferBeau' with: 'GoferBeau-dkh.15';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           yourself ]-=JUAMPI=-install  | tmp1 |  tmp1 := Metacello new.  self isBaselineName ifTrue: [ tmp1 baseline: self baselineOrConfigurationNameSuffix ].  self isConfigurationName ifTrue: [ tmp1 configuration: self baselineOrConfigurationNameSuffix ].  tmp1 repository: self repositoryUrl.  self hasVersion ifTrue: [ tmp1 version: self version ].  self hasGroups ifTrue: [ tmp1 load: self groups ] ifFalse: [ tmp1 load ]-=JUAMPI=-scriptExecutor  ^(self class scriptExecutorClass: self executorSpec) new-=JUAMPI=-projectPath: arg1  projectPath := arg1-=JUAMPI=-validateVersion: arg1  | tmp1 |  tmp1 := (MetacelloMCVersionValidator validateProject: project version: arg1) select: [:arg2 |  arg2 isError ].  tmp1 notEmpty ifTrue: [ MetacelloValidationFailure issues: tmp1 message: 'There are error issues with version ' , arg1 printString ]-=JUAMPI=-baselineVersion10MetacelloExample: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 package: 'GoferFoo' ]-=JUAMPI=-versionOrNil  ^self projectReference versionOrNil-=JUAMPI=-repository: arg1 username: arg2 password: arg3  self repositoriesSpec repository: arg1 username: arg2 password: arg3-=JUAMPI=-baseline14: arg1  < version: '1.4-baseline' imports: #('1.2-baseline')>  arg1 for: #common do: [ arg1 description: 'Add groups and Project-Extra, extending 1.2-baseline'.        arg1           package: 'Project-Core' with: [ arg1 includes: 'Project-Extra' ];           package: 'Project-Extra' with: [ arg1 requires: 'Project-Core' ].        arg1           group: 'default' with: #('Project-Core' 'Project-Extra');           group: 'Core' with: #('default');           group: 'Tests' with: #('Project-Tests') ]-=JUAMPI=-projectForVersion: arg1 copyFrom: arg2 with: arg3  | tmp1 tmp2 |  tmp2 := self project projectSpec     name: arg1;     yourself.  tmp1 := self project projectReferenceSpec     name: arg1;     projectReference: tmp2;     yourself.  self root packages copy: arg2 to: tmp1.  self with: tmp2 during: arg3-=JUAMPI=-setBlessing: arg1  blessing := arg1-=JUAMPI=-handleLock: arg1  ^(self options at: #onLock ifAbsent: [ ^arg1 pass ]) cull: arg1 cull: arg1 existingProjectRegistration cull: arg1 newProjectRegistration-=JUAMPI=-setVersionString: arg1  versionString ifNil: [ self versionString: arg1 ]-=JUAMPI=-testVersion22  self assert: (MetacelloVersionNumber fromString: '3.0.0') collapseZeros size equals: 1.  self assert: (MetacelloVersionNumber fromString: '3.0.0') equals: (MetacelloVersionNumber fromString: '3.0').  self assert: (MetacelloVersionNumber fromString: '3.0') equals: (MetacelloVersionNumber fromString: '3.0.0')-=JUAMPI=-version115ProjectToolBox: arg1  < version: '1.1.5-baseline' imports: #('1.1.4-baseline')>  arg1 for: #common do: [ arg1 project: 'Example Project' with: [ arg1 preLoadDoIt: #alternatePreloadForCore ] ]-=JUAMPI=-configMethodOn: arg1 indent: arg2  arg1     tab: arg2;     nextPutAll: 'spec';     cr.  self configMethodCascadeOn: arg1 indent: arg2-=JUAMPI=-operationString  ^operationString-=JUAMPI=-baseline13: arg1  < version: '1.3-baseline'>  arg1 for: #squeakCommon do: [ arg1 package: 'Example-Core' with: [ arg1                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'ftp://ftp.example.com/examples' ] ]-=JUAMPI=-testRemoveProjectA  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self packagesSpec.  tmp1 add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp3 := tmp1 packageNamed: 'Project' ifAbsent: [ self assert: false ].  tmp2 := tmp3 referencedSpec.  self assert: tmp2 name equals: 'Project'.  self assert: tmp2 className equals: 'ConfigurationOfProject'.  self assert: tmp2 versionString equals: '1.0'.  self assert: tmp2 operator identicalTo: #<.  self assert: tmp2 loads equals: #('MyPackage').  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoIt.  tmp1 remove: (self projectReferenceSpec           name: 'Project';           yourself).  tmp4 := false.  tmp1 packageNamed: 'Project' ifAbsent: [ tmp4 := true ].  self assert: tmp4-=JUAMPI=-baseline40ProjectLoop: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Infinite' with: [ arg1                 className: 'MetacelloTestConfigurationOfProjectInfinite';                 versionString: '4.0';                 loads: 'GoferBar';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           package: 'GoferFaux' with: [ arg1                 file: 'GoferFaux-tg.30';                 requires: 'Infinite';                 yourself ];           package: 'GeauxBeau' with: [ arg1                 file: 'GeauxBeau-dkh.55';                 yourself ];           yourself ]-=JUAMPI=-validateVersionString: arg1 withDefaultVersionString: arg2  self versionString ifNotNil: [:arg3 |  | tmp1 |        tmp1 := self project asBaselineProject.        arg3 ~= tmp1 singletonVersionName ifTrue: [ arg1 add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #invalidVersionString callSite: #validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription: explanation: 'version field is incorrect, should be: ' , tmp1 singletonVersionName printString) ] ]-=JUAMPI=-loader: arg1  self shouldBeMutable.  loader := arg1 copy.  loader spec: self-=JUAMPI=-directoryForPlatform  | tmp1 |  tmp1 := '/opt/mcexamples'.  (Smalltalk classNamed: #OSPlatform) ifNotNil: [:arg1 |  arg1 current isWindows ifTrue: [ tmp1 := 'c:\opt\mcexamples' ] ].  ^tmp1-=JUAMPI=-updatePackageSpec: arg1  | tmp1 tmp2 tmp3 |  className == nil ifTrue: [ ^self ].  tmp1 := self projectClassProject.  (tmp2 := tmp1 currentVersion) = self versionOrNil ifTrue: [ ^self ].  tmp2 == nil ifTrue: [ ^self ].  tmp3 := self copy.  tmp3 versionString: tmp2 versionString.  arg1 at: tmp3 name put: tmp3-=JUAMPI=-aLoadedProjectIsNotCurrent  ^aLoadedProjectIsNotCurrent-=JUAMPI=-versionInfo: arg1  versionInfo := arg1-=JUAMPI=-validateDoItSelector: arg1  arg1 == nil ifTrue: [ ^self ].  arg1 isSymbol ifFalse: [ self error: 'Invalid message selector for doit: ' , arg1 printString ]-=JUAMPI=-packageSpecClass  ^MetacelloCypressPackageSpec-=JUAMPI=-aLoadedPackageIsExact: arg1  aLoadedPackageIsExact := arg1-=JUAMPI=-recursiveDelete: arg1  ^arg1 recursiveDelete-=JUAMPI=-samplePath  ^'metacello-tests/sample'-=JUAMPI=-ancestorsFor: arg1 ifAbsent: arg2  ^self versionInfoMap at: arg1 file ifAbsent: [ self packageNameMap at: arg1 name ifAbsent: arg2 ]-=JUAMPI=-decrementMinorVersionNumber  self decrementNormalVersionAt: 3-=JUAMPI=-version  ^self version: self singletonVersionName-=JUAMPI=-postloadForCore: arg1 package: arg2  MetacelloNotification signal: '#postloadForCore executed, Loader: ' , arg1 printString , ' spec: ' , arg2 printString-=JUAMPI=-determineCurrentVersionForLoad  ^self version-=JUAMPI=-handleLookupProjectSpecForLoad: arg1  | tmp1 tmp2 |  tmp1 := arg1 projectSpec.  tmp2 := self useCurrentVersion ifTrue: [ nil ] ifFalse: [ | tmp3 |        tmp3 := self lookupProjectSpecFor: arg1 projectSpec.        (tmp3 compareEqual: tmp1) ifFalse: [ tmp2 := tmp3 ] ].  ^arg1 resume: (MetacelloProjectSpecForLoad new           projectSpec: tmp1;           useDetermineVersionForLoad: self useCurrentVersion;           overrideProjectSpec: tmp2;           yourself)-=JUAMPI=-target  ^target-=JUAMPI=-answers  answers == nil ifTrue: [ answers := #() ].  ^answers-=JUAMPI=-setPostLoadDoIt: arg1  self shouldBeMutable.  postLoadDoIt := arg1-=JUAMPI=-baseline61MethodSourceProjectIssue86  ^(self class sourceCodeAt: #baseline61ProjectIssue86:) asString-=JUAMPI=-loadUsing: arg1 gofer: arg2  -=JUAMPI=-closeZipArchive: arg1  -=JUAMPI=-testRemoveGroupC  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: {(self groupSpec           name: 'Platform';           includes: 'Core';           yourself) .         (self groupSpec           name: 'Base';           includes: 'Base';           yourself) .         (self groupSpec           name: 'Tests';           includes: 'Tests';           yourself)}.  tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  tmp1 packageNamed: 'Base' ifAbsent: [ self assert: false ].  tmp1 packageNamed: 'Tests' ifAbsent: [ self assert: false ].  tmp1 remove: 'Tests'.  tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  tmp1 packageNamed: 'Base' ifAbsent: [ self assert: false ].  tmp2 := false.  tmp1 packageNamed: 'Tests' ifAbsent: [ tmp2 := true ].  self assert: tmp2-=JUAMPI=-versionReferences  ^versionReferences-=JUAMPI=-performLoad  | tmp1 tmp2 |  tmp2 := self projectSpec.  tmp1 := 'Project: ' , tmp2 name.  tmp2 versionString ~~ nil ifTrue: [ tmp1 := tmp1 , ' ' , tmp2 versionString ].  MetacelloNotification signal: tmp1.  self hasOverride ifTrue: [ | tmp3 |        tmp3 := self overrideProjectSpec copy.        tmp3 mergeScriptLoads: tmp2.        tmp3 loadVersion: nil ] ifFalse: [ | tmp4 |        tmp4 := self useDetermineVersionForLoad ifTrue: [ tmp2 determineCurrentVersionForLoad ] ifFalse: [ tmp2 versionOrNil ].        (tmp2 asProjectSpecForVersion: tmp4) loadVersion: tmp4 ]-=JUAMPI=-repositorySpecs  ^self repositories map values-=JUAMPI=-