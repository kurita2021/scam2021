bypassGoferLoadUpdateCategories: anObject  bypassGoferLoadUpdateCategories := anObject-=JUAMPI=-tearDown  | aGofer finalWorkingCopyList diff |  aGofer := Gofer new.  self tearDownPackageNames do: [:pName |  (self hasPackage: pName) ifTrue: [ aGofer package: pName ] ].  aGofer references notEmpty ifTrue: [ aGofer metacelloUnload ].  MCRepositoryGroup default     removeIdenticalRepository: (testingEnvironment at: #Metacello_Gofer_Test_Repository ifAbsent: [  ]);     removeIdenticalRepository: (testingEnvironment at: #Metacello_Configuration_Test_Repository ifAbsent: [  ]);     yourself.  testingEnvironment removeKey: #Metacello_Gofer_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Repository ifAbsent: [  ].  finalWorkingCopyList := MCWorkingCopy allManagers collect: [:each |  each packageName ].  diff := finalWorkingCopyList difference: initialWorkingCopyList.  diff do: [:leak |  MetacelloNotification signal: 'leaked package from ' , self printString , ' -> ' , leak printString ].  self assert: diff isEmpty.  super tearDown-=JUAMPI=-configuration094Issue185: spec  < version: '0.9.4'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration094Issue185:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA1 , '/repository' ];           import: 'External' ]-=JUAMPI=-argumentsWith: aCollection  ^CommandLineArguments withArguments: aCollection-=JUAMPI=-useIncoming  self allow-=JUAMPI=-species  ^MCPackage-=JUAMPI=-title  ^'linear load'-=JUAMPI=-asBaselineProject  ^self-=JUAMPI=-importedVersions: aCollection  importedVersions := aCollection-=JUAMPI=-version42Issue119: spec  < version: '4.2' imports: #('4.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '2.0'.        spec package: 'GoferBar ' with: 'GoferBar-jf.1' ]-=JUAMPI=-allow  self checkAllowed.  self resume: self newProjectRegistration-=JUAMPI=-setUpConfigurationIssue339  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfIssue339-dkh.1'.  className := #ConfigurationOfIssue339.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version100Issue339:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version100Issue339:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfo-=JUAMPI=-ignoreImage  ^self loaderPolicy ignoreImage-=JUAMPI=-baseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec           package: 'Example-Core';           package: 'Example-AddOn' with: [ spec requires: #('Example-Core') ];           package: 'Example-Tests' with: [ spec requires: #('Example-AddOn') ];           package: 'Example-TestsUI' with: [ spec requires: #('Example-UI' 'Example-Tests') ];           package: 'Example-UI' with: [ spec requires: #('Example-AddOn') ] ]-=JUAMPI=-name  ^name-=JUAMPI=-import: aString provides: anArray  importArray := importArray ifNil: [ {(aString -> anArray)} ] ifNotNil: [ importArray , {(aString -> anArray)} ]-=JUAMPI=-testAddProjectA  | packages project projectReferenceSpec |  packages := self packagesSpec.  packages add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself).  packages add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: projectReferenceSpec projectName equals: 'Project'.  self assert: projectReferenceSpec versionString equals: '1.0'.  self should: [ projectReferenceSpec includes: #() ] raise: Error.  self should: [ projectReferenceSpec requires: #() ] raise: Error.  self should: [ projectReferenceSpec answers: #() ] raise: Error.  projectReferenceSpec projectDo: [:prjct |  self assert: projectReferenceSpec identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  project projectDo: [:prjct |  self assert: project identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ]-=JUAMPI=-configMethodBodyOn: aStream hasName: hasName indent: indent  | hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |  hasFile := file ~~ nil.  hasRepositories := self repositorySpecs size > 0.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [ self answers isEmpty ] ]) not.  hasRequiresOrIncludesOrAnswers ifTrue: [ self configMethodBodyOn: aStream hasName: hasName cascading: hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt indent: indent ].  self configMethodOn: aStream for: file selector: 'file: ' cascading: hasName | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers cascade: hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt indent: indent.  hasRepositories ifTrue: [ self repositorySpecs size > 1 ifTrue: [ hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers ifTrue: [ aStream                       cr;                       tab: indent ].              aStream                 nextPutAll: 'repositories: [';                 cr;                 tab: indent + 1;                 nextPutAll: 'spec';                 cr.              self repositories configMethodCascadeOn: aStream indent: indent + 1.              aStream nextPutAll: ' ]' ] ifFalse: [ hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers ifTrue: [ aStream                       cr;                       tab: indent ].              self repositories configMethodCascadeOn: aStream indent: indent ].        hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream nextPut: $; ] ].  self configMethodOn: aStream for: self getPreLoadDoIt selector: 'preLoadDoIt: ' cascading: hasName | hasFile | hasRepositories | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers cascade: hasPostLoadDoIt indent: indent.  self configMethodOn: aStream for: self getPostLoadDoIt selector: 'postLoadDoIt: ' cascading: hasName | hasFile | hasRepositories | hasPreLoadDoIt | hasRequiresOrIncludesOrAnswers cascade: false indent: indent.  aStream nextPut: $.-=JUAMPI=-remove  -=JUAMPI=-lesson13  ^Lesson title: 'Lesson 12 (DoIts)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #baseline13:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version13:."For version 1.3 we are adding a platform specific package ''Example-Platform''. ''Example-Platform''requires ''Example-Core''. On GemStone, Pharo and Squeak, a branch of the ''Example-Platform'' package will be loaded: ''Example-Platform.gemstone'', ''Example-Platform.pharo'', ''Example-Platform.squeak'' respectively will be loaded. Consequently we''ve updated the baselines with #baseline13: to reflect the structural changes and#version13: reflects the package versions.The platform-specific versions and branches are defined in the #for:do: block for the correspondingplatforms: #gemstone, #pharo, #squeak (in both methods)The result of the following expression will depend on the platform upon which you are running:"	(MetacelloTutorialConfig project version: ''1.3'') load."Note that when you execute the following expresson to load ''Example-Core'' that the correct''Example-Platform'' is loaded as well:"	(MetacelloTutorialConfig project version: ''1.3'') load: ''Example-Core''."If you look at the specification for ''Example-Core'' (in #baseline13:) you will note that ''Example-Core'' #includes: ''Example-Platform''. The #includes: directive means that the package ''Example-Platform'' should be loaded whenever the ''Example-Core'' package is loaded.Also note when you evaluate the following expression that the ''Example-Platform'' package is loadedbefore ''Example-Tests'' as if ''Example-Tests'' #requires: ''Example-Platform'':"	(MetacelloTutorialConfig project version: ''1.3'') load: ''Example-Tests''."When you use the #includes: directive, you are not only specifying that the listed packages shouldbe loaded when the parent package is loaded, but that the #included: packages should be loaded_before_ any packages that require the parent package."ProfStef next.'-=JUAMPI=-version  ^self optionAt: 'version'-=JUAMPI=-lesson10  -=JUAMPI=-baseline50Foo: spec  < version: '5.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.2';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        spec           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferFaux');           yourself ]-=JUAMPI=-root  ^root-=JUAMPI=-projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool  ^self subclassResponsibility-=JUAMPI=-asBaselineProjectSpec  ^self-=JUAMPI=-requiredSpecsForPackageOrdering: aVersionSpec  ^#()-=JUAMPI=-primeRegistryProjectSpecRegistered: projectSpec  MetacelloProjectRegistration registrationForProjectSpec: projectSpec ifAbsent: [:new |  ^false ] ifPresent: [:existing :new |  ^true ]-=JUAMPI=-handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock  ^onUpgradeBlock cull: self cull: self existingProjectRegistration cull: self newProjectRegistration-=JUAMPI=-beforeLoads  beforeLoads == nil ifTrue: [ beforeLoads := OrderedCollection new ].  ^beforeLoads-=JUAMPI=-silently: aBool  self loaderPolicy silently: aBool-=JUAMPI=-baselineVersion124ProjectToolBox: spec  < version: '1.2.4-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/aa' ].  spec for: #common do: [ spec repository: 'http://www.example.com/ab' ]-=JUAMPI=-resolveRecordingPackageSpecReference: packageSpec gofer: gofer  | externalPackageReference |  externalPackageReference := packageSpec file == nil ifTrue: [ GoferPackageReference name: packageSpec name ] ifFalse: [ GoferResolvedReference name: packageSpec file repository: nil ].  packageSpec repositorySpecs isEmpty ifTrue: [ self repositoryMap at: externalPackageReference packageName put: (gofer repositories reject: [:repo |  repo = MetacelloPlatform current defaultPackageCache ]) ] ifFalse: [ self repositoryMap at: externalPackageReference packageName put: (packageSpec repositorySpecs collect: [:repoSpec |  repoSpec createRepository ]) ].  ^externalPackageReference-=JUAMPI=-postLoad: packageOrVersionSpec  self evalDoits ifFalse: [ ^self ].  packageOrVersionSpec postLoadDoItBlock ~~ nil ifTrue: [ self afterLoads add: packageOrVersionSpec printString , ' load' ].  super postLoad: packageOrVersionSpec-=JUAMPI=-isMutable  mutable ifNil: [ ^true ].  ^mutable-=JUAMPI=-requiredSpecNamesForPackageOrdering: aVersionSpec  ^(self requiredSpecsForPackageOrdering: aVersionSpec) collect: [:spec |  spec name ]-=JUAMPI=-resolvePackageSpec: packageSpec gofer: gofer  | references resolvedReference mcVersion loadedVersionInfos |  references := self retryingResolvePackageSpecReferences: packageSpec gofer: gofer.  resolvedReference := references last asMetacelloCachingResolvedReference.  mcVersion := resolvedReference version.  (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ifTrue: [ loadedVersionInfos do: [:info |  info name = mcVersion info name ifTrue: [ | spc |                    spc := packageSpec copy.                    spc file: info name.                    (MetacelloIgnorePackageLoaded signal: spc) ifFalse: [ ^nil ] ] ] ].  ^resolvedReference-=JUAMPI=-mergeIntoMetacelloPackages: aMetacelloPackagesSpec  aMetacelloPackagesSpec addMember: (aMetacelloPackagesSpec mergeMember           name: self name;           spec: self;           yourself)-=JUAMPI=-attribute  self deprecated: 'Use attributes instead'.  self attributes size > 1 ifTrue: [ self error: 'invalid use of attribute' ].  self attributes isEmpty ifTrue: [ ^nil ].  ^self attributes first-=JUAMPI=-exception: anObject  exception := anObject-=JUAMPI=-configurationRepository  ^MetacelloConfigurationResource current monticelloRepository-=JUAMPI=-aPackageIsLoaded: aBoolean  aPackageIsLoaded := aBoolean-=JUAMPI=-linearLoadPackageSpec: packageSpec gofer: gofer  MetacelloPlatform current do: [ | externalReference loadBlock answers fake |        externalReference := self resolveRecordingPackageSpecReference: packageSpec gofer: gofer.        loadBlock := [ self preLoad: packageSpec.        (MetacelloDirective loadPackage: packageSpec externalReference: externalReference loader: self) addTo: self loadDirective.        self postLoad: packageSpec ].        (answers := packageSpec answers) notEmpty ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ] ifFalse: [ loadBlock value ].        fake := packageSpec copy.        fake name: fake file.        self loadData addVersion: fake versionInfo: fake resolvedReference: externalReference packageSpec: packageSpec ] displaying: 'Recording ' , packageSpec file-=JUAMPI=-spec  ^spec-=JUAMPI=-configurationExternalRef091: spec  < version: '0.9.1'>  spec for: #common do: [ spec blessing: #version.        spec description: 'MetacelloScriptingResource>>configurationExternalRef090:'.        spec project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 version: '0.9.1';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]-=JUAMPI=-downloadZipArchive: url to: outputFileName  outputFileName asFileReference ensureDelete.  [:bar |  bar title: 'Download: ' , url asString , ' to ' , outputFileName.  [ ZnClient new     url: url;     signalProgress: true;     downloadTo: outputFileName ] on: HTTPProgress do: [:progress |  progress isEmpty ifFalse: [ bar current: progress percentage ].        progress resume ] ] asJob run.  ^ZipArchive new readFrom: outputFileName asFileReference-=JUAMPI=-projectSpec  ^projectSpec-=JUAMPI=-testRemoveD  | repositories removed |  repositories := self repositoriesSpec.  repositories add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  repositories remove: 'http://example.com/repository'.  removed := false.  repositories map at: 'http://example.com/repository' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-projectMethodSource  ^(self class sourceCodeAt: #project) asString-=JUAMPI=-version43SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version43Symbolic:) asString-=JUAMPI=-hash  ^self versionComponents hash-=JUAMPI=-packageSpecsInLoadOrderForMap: packageMap  | loadOrder pkgs packageNames importNames importSpec importProjectSpecs importProjectNameMap |  loadOrder := self packageSpecsInLoadOrder.  importNames := (packageNames := (packageMap values collect: [:pkg |  pkg name ]) asSet) copy.  (self import isNil and: [ self importArray isNil ]) ifTrue: [ ^loadOrder select: [:pkg |  packageNames includes: pkg name ] ].  loadOrder do: [:pkg |  importNames remove: pkg name ifAbsent: [  ] ].  pkgs := OrderedCollection new.  importProjectSpecs := Dictionary new.  importProjectNameMap := Dictionary new.  importArray ifNotNil: [ loadOrder do: [:pkg |  importArray do: [:assoc |  assoc key = pkg name ifTrue: [ importProjectSpecs at: pkg name put: pkg.                          (assoc value select: [:each |  importNames includes: each ]) do: [:each |  (importProjectNameMap at: pkg name ifAbsent: [ importProjectNameMap at: pkg name put: Set new ]) add: each ] ] ] ] ].  self import ifNotNil: [ loadOrder do: [:pkg |  pkg name = self import ifTrue: [ importProjectSpecs at: pkg name put: pkg.                    importProjectNameMap at: pkg name put: importNames ] ] ].  loadOrder do: [:pkg |  (packageNames includes: pkg name) ifTrue: [ pkgs add: pkg ].        importProjectSpecs at: pkg name ifPresent: [:importProjectSpec |  (importProjectNameMap at: pkg name ifAbsent: [ #() ]) do: [:importedName |  pkgs add: (importSpec := importProjectSpec copy                             name: importedName;                             mergeImportLoads: {importedName};                             yourself).                    importSpec projectReference name: importedName ] ] ].  ^pkgs-=JUAMPI=-testBaselineOrConfigurationNameSuffix  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: cli baselineOrConfigurationNameSuffix equals: 'MineSweeper'.  cli := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self assert: cli baselineOrConfigurationNameSuffix equals: 'Foo'-=JUAMPI=-version10Issue136: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec package: 'GoferBeau' with: 'GoferBeau-dkh.15' ]-=JUAMPI=-invalidConfiguration10: spec  < version: '1.0.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>invalidConfiguration10: ... missing className:'.        spec project: 'External' with: [ spec                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]-=JUAMPI=-setUpIssue77B  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfIssue77B-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline10B:' category: 'cat' timeStamp: '' source: self baseline10MethodSourceB)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())-=JUAMPI=-packageSpec  ^packageSpec-=JUAMPI=-locked  locked ifNil: [ locked := false ].  ^locked-=JUAMPI=-name  ^self description-=JUAMPI=-hasGroups  ^self hasOption: 'groups'-=JUAMPI=-existingProjectRegistration  ^existingProjectRegistration-=JUAMPI=-doingLoads: aBlock  -=JUAMPI=-testForDoListAtrribute1Active  | project version expected actual |  project := self projectWith: #(#attribute1).  version := project version: '3.0-baseline'.  expected := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec 	project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec 	group: ''Core'' with: #(''Example Project'' );	group: ''Core'' with: #(''Extra Project'' ).'.  actual := version spec printString.  self assert: expected equals: actual-=JUAMPI=-possibleVersions  ^self versionDoesNotExistException possibleVersions-=JUAMPI=-defaultRepositoryDescription  ^'http://www.squeaksource.com/MetacelloRepository'-=JUAMPI=-gtInspectorVersionsIn: composite  < gtInspectorPresentationOrder: 40>  composite list     title: 'Versions';     display: #versions-=JUAMPI=-goferCommitProject: commitMessage  | pkgSpec |  (pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].  ^pkgSpec goferCommitPackage: commitMessage-=JUAMPI=-testRemoveA  | repositories removed |  repositories := self repositoriesSpec.  repositories add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  repositories remove: (self repositorySpec           description: 'http://example.com/repository';           yourself).  removed := false.  repositories map at: 'http://example.com/repository' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-isResumable  ^false-=JUAMPI=-versionString: anObject  versionString := anObject-=JUAMPI=-closestAncestorVersionFor: anAncestry ifNone: errorBlock  ^self localRepository closestAncestorVersionFor: anAncestry ifNone: errorBlock-=JUAMPI=-recordingSpecLoader  ^self-=JUAMPI=-packageForVersion: aString  | spec |  spec := self project packageSpec     name: aString;     yourself.  self root packages add: spec-=JUAMPI=-version08: spec  < version: '0.8' imports: #('0.7-baseline')>  spec for: #common do: [ spec           package: 'Example-Core' with: 'Example-Core-anon.15';           package: 'Example-Tests' with: 'Example-Tests-anon.6';           package: 'Example-AddOn' with: 'Example-AddOn-anon.2' ]-=JUAMPI=-dataMap  dataMap == nil ifTrue: [ dataMap := Dictionary new ].  ^dataMap-=JUAMPI=-loaderPolicy  loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].  ^loaderPolicy-=JUAMPI=-= aMetacelloVersionNumber  | condensed aCondensed |  aMetacelloVersionNumber species = self species ifFalse: [ ^false ].  condensed := self collapseZeros.  aCondensed := aMetacelloVersionNumber collapseZeros.  (condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ]) ifTrue: [ ^condensed compareEqualTo: aCondensed ].  ^self compareEqualTo: aMetacelloVersionNumber-=JUAMPI=-versionNumber  ^self project versionNumberClass fromString: self versionString-=JUAMPI=-referencedSpec  ^self-=JUAMPI=-projectVersion: aString  | x |  aString ifNil: [ projectVersion := aString.        ^self ].  (x := aString findDelimiters: {$# .         $* .         $?} startingAt: 1) <= aString size ifTrue: [ self resolveProjectVersionPattern: aString ] ifFalse: [ projectVersion := aString ]-=JUAMPI=-runCase  | original |  self doSilently ifFalse: [ ^super runCase ].  original := MetacelloPlatform current bypassGoferLoadUpdateCategories.  [ MetacelloPlatform current bypassGoferLoadUpdateCategories: true.  ^MetacelloPlatform current suspendSystemUpdateEventsDuring: [ super runCase ] ] ensure: [ MetacelloPlatform current bypassGoferLoadUpdateCategories: original ]-=JUAMPI=-configurationForVersion: aString with: aBlock  aBlock setConfiguration: aString withInMetacelloConfig: self-=JUAMPI=-baselineVersion30Issue125: spec  < version: '3.0-baseline' imports: #('2.0-baseline')>  spec for: #(#attribute1 #attribute2) do: [ spec description: 'MetacelloConfigurationResource>>baselineVersion30Issue125:'.        spec           package: 'GoferFaux' with: [ spec requires: 'GoferFoo' ];           package: 'GoferBeau' with: [ spec requires: 'GoferFaux' ];           yourself ]-=JUAMPI=-versionSpec  ^versionSpec-=JUAMPI=-asConfigurationProjectSpec  ^self copyForScriptingInto: (MetacelloMCConfigurationOfProjectSpec for: self project asConfigurationProject)-=JUAMPI=-customProjectAttributes  ^#()-=JUAMPI=-testMCProjectSpec  | project repository |  project := self projectSpec.  project     name: 'Project';     projectPackage: self project packageSpec;     className: 'ConfigurationOfProject';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project projectPackage name equals: project className.  self assert: project projectPackage file equals: project className.  repository := project repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := project repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'-=JUAMPI=-packageAndProjectNamesToLoad: defaultList loader: aLoader  | loadedPackageNames projectMap loadedProjectNames list |  loadedPackageNames := ((self packages select: [:pkg |  pkg isPackageLoaded: aLoader ]) collect: [:pkg |  pkg name ]) asSet , defaultList.  projectMap := Dictionary new.  self projects do: [:prj |  prj className ~~ nil ifTrue: [ | coll loaded |              coll := projectMap at: prj className ifAbsent: [ coll := OrderedCollection new.                    projectMap at: prj className put: coll.                    coll ].              (loaded := prj loadedPackageNames: aLoader) isEmpty ifFalse: [ coll add: prj -> (loaded -> prj loadPackageList) ] ] ].  loadedProjectNames := Set new.  projectMap keysAndValuesDo: [:prjClass :coll |  coll size <= 1 ifTrue: [ coll do: [:assoc |  loadedProjectNames add: assoc key name ] ] ifFalse: [ coll do: [:assoc |  | loaded packageList |                    loaded := assoc value key.                    packageList := assoc value value.                    (packageList difference: loaded) isEmpty ifTrue: [ loadedProjectNames add: assoc key name ] ] ] ].  list := loadedPackageNames , loadedProjectNames.  list isEmpty ifTrue: [ ^self spec defaultPackageNames ].  ^list-=JUAMPI=-buildMapFrom: mapList for: packageList  | map |  map := Dictionary new.  mapList do: [:assoc |  | pkgName pkgSpec |        pkgName := assoc key.        (packageList includes: pkgName) ifFalse: [ self error: 'package ' , pkgName printString , ' not found in packages.' ].        map at: pkgName put: assoc value ].  ^map-=JUAMPI=-projectPath  ^projectPath-=JUAMPI=-conflictOf20: spec  < version: '2.0.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>conflictOf20:'.        spec author: 'dkh'.        spec timestamp: '6/1/2012 14:46' ].  spec for: #custom do: [ spec configuration: 'ExternalX' with: [ spec                 version: '0.9.0';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]-=JUAMPI=-setUpBaselineIssue215  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfIssue215-dkh.1'.  className := #BaselineOfIssue215.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'postloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #postloadDoIt) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #preloadDoIt) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineIssue215:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue215:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfo-=JUAMPI=-workingCopy  ^self projectPackage workingCopy-=JUAMPI=-warningReasonCodes  ^super warningReasonCodes , #(#loadWarning #notDevelopmentVersion #stableDevelopmentVersion)-=JUAMPI=-hasVersion: versionString  self version: versionString ifAbsent: [ ^false ].  ^true-=JUAMPI=-versionString  ^self versionNumber versionString-=JUAMPI=-defaultTimeout  ^60000-=JUAMPI=-baselineOfProjectSpecClass  ^MetacelloCypressBaselineProjectSpec-=JUAMPI=-loads: anObject constructor: aVersionConstructor  aVersionConstructor loadsForProject: anObject-=JUAMPI=-useCurrentVersion  ^self options at: #useCurrentVersion ifAbsent: [ false ]-=JUAMPI=-version10: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec           package: 'Example-Core' with: 'Example-Core-anon.14';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ]-=JUAMPI=-onWarning: aBlock  self options at: #onWarning put: aBlock-=JUAMPI=-packageloads  packageloads == nil ifTrue: [ packageloads := OrderedCollection new ].  ^packageloads-=JUAMPI=-reset  attributeMap := attributeOrder := nil-=JUAMPI=-target: anObject  target := anObject-=JUAMPI=-aLoadedPackageIsNotCurrent: aBoolean  aLoadedPackageIsNotCurrent := aBoolean-=JUAMPI=-decrementMajorVersion  self decrementVersionAt: 1-=JUAMPI=-packagesNeedSavingVisited: visitedProjects using: repos into: aCollection  ^self loader packagesNeedSavingUsing: repos into: aCollection-=JUAMPI=-repository: description username: username password: password  self root repository: description username: username password: password constructor: self-=JUAMPI=-createFiletreeRepository: aRepositorySpec  MCRepository findFiletreeAlternateFormat: aRepositorySpec ifFound: [:repository |  ^repository createRepositoryFromSpec: aRepositorySpec on: self ].  ^super createFiletreeRepository: aRepositorySpec-=JUAMPI=-handleResolutionFor: aScriptEngine  self subclassResponsibility-=JUAMPI=-extractTypeFromDescription: description  description == nil ifTrue: [ ^nil ].  ((description beginsWith: '/') or: [ description second = $: ]) ifTrue: [ ^'directory' ].  (description beginsWith: 'dictionary://') ifTrue: [ ^'dictionary' ].  (description beginsWith: 'filetree://') ifTrue: [ ^'filetree' ].  (description beginsWith: 'tonel://') ifTrue: [ ^'tonel' ].  (description beginsWith: 'github://') ifTrue: [ ^'github' ].  (description beginsWith: 'gitorious://') ifTrue: [ ^'gitorious' ].  (description beginsWith: 'bitbucket://') ifTrue: [ ^'bitbucket' ].  ^'http'-=JUAMPI=-hasPackage: aString  | package |  package := MCWorkingCopy allManagers detect: [:each |  each packageName = aString ] ifNone: [ nil ].  ^package notNil-=JUAMPI=-notEmpty  ^self list notEmpty-=JUAMPI=-projectName  ^self projectSpec name-=JUAMPI=-isPackageLoaded: aLoader  MCWorkingCopy allManagers detect: [:wc |  wc packageName = self file ] ifNone: [ ^false ].  ^true-=JUAMPI=-lesson10  -=JUAMPI=-methodSections: anObject  methodSections := anObject-=JUAMPI=-versionString  ^MetacelloMCBaselineProject singletonVersionName-=JUAMPI=-baseline13C: spec  < version: '1.3'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GeauxBeau' with: 'GeauxBeau-dkh.56';           yourself ]-=JUAMPI=-projectName  ^self projectReference name-=JUAMPI=-aProjectIsLoaded  ^aProjectIsLoaded-=JUAMPI=-configuration  ^configuration-=JUAMPI=-versionString: anObject constructor: aVersionConstructor  self error: 'versionString: not allowed in a baseline project spec'-=JUAMPI=-repository: aString username: username password: password  self repositories repository: aString username: username password: password.  self projectPackage: nil-=JUAMPI=-packageDirectivesDo: aBlock  self loadDirectives do: [:directive |  directive packageDirectivesDo: aBlock ]-=JUAMPI=-baselineProjectSpec  ^baselineProjectSpec-=JUAMPI=-configurationProjectSpecs  | projectSpecs |  projectSpecs := OrderedCollection new.  self configurationRegistry keysAndValuesDo: [:className :registration |  projectSpecs add: (self projectSpecForClassNamed: className ifAbsent: [ self error: 'not expected' ]) ].  ^projectSpecs asArray-=JUAMPI=-projectAttributes  projectAttributes ~~ nil ifTrue: [ ^projectAttributes ].  ^#()-=JUAMPI=-projectWith: projectAttributes  | project |  project := MetacelloMCProject new.  project projectAttributes: projectAttributes.  MetacelloVersionConstructor on: self projectClass new project: project.  project loader: MetacelloNullRecordingMCSpecLoader new.  project loader evalDoits: false.  ^project-=JUAMPI=-projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  self packageSpecsInLoadOrder do: [:pkgSpec |  pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]-=JUAMPI=-baseline61Fix: spec  < version: '6.1'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           package: 'GoferFaux' with: 'GoferFaux-tg.31';           yourself ]-=JUAMPI=-validateProjectVersionLoad: versionString loads: loadList  | issues project version |  (issues := (self validateProjectVersion: versionString) select: [:issue |  issue isError ]) notEmpty ifTrue: [ ^issues ].  project := self configurationClass project.  version := project version: versionString ifAbsent: [ self recordValidationError: 'Version ' , versionString printString , ' does not exist.' callSite: #validateProjectVersionLoad:loads: reasonCode: #cannotResolveVersion.        ^self validationReport ].  version blessing = #broken ifTrue: [ self error: 'The specified version is #broken' ].  self validateCleanLoadAndTestsForVersion: version loads: loadList.  ^self validationReport-=JUAMPI=-postCopy  super postCopy.  blessing := blessing copy.  description := description copy.  author := author copy.  timestamp := timestamp copy.  packageList := packageList copy-=JUAMPI=-category: anObject  category := anObject-=JUAMPI=-preLoadDo: aBlock  aBlock value: self-=JUAMPI=-alternateRepository  ^MetacelloAlternateResource current monticelloRepository-=JUAMPI=-updateVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: aBlock  ^self updateVersionMethodForVersion: inputVersionStringOrSymbol updateProjects: true updatePackages: true versionSpecsDo: aBlock-=JUAMPI=-timestamp  ^self basicSpec timestamp value-=JUAMPI=-currentVersion  ^self version isSomethingLoaded ifTrue: [ self version ] ifFalse: [ nil ]-=JUAMPI=-version102ProjectToolBox: spec  < version: '1.0.2-baseline'>  spec for: #common do: [ spec preLoadDoIt: #preloadForCore.        spec postLoadDoIt: #postloadForCore:package:.        spec           package: 'Example-Core' with: [ spec includes: #('Example-AddOn') ];           package: 'Example-AddOn' with: [ spec requires: #('Example-Core') ];           package: 'Example-Tests' with: [ spec requires: #('Example-AddOn') ] ]-=JUAMPI=-description: anObject  anObject setDescriptionInMetacelloVersion: self-=JUAMPI=-isPossibleBaseline  self subclassResponsibility-=JUAMPI=-spotterForRequiresFor: aStep  < spotterOrder: 2>  aStep listProcessor     title: 'Requires';     allCandidates: [ self requires ];     itemName: [:item |  item name ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: true-=JUAMPI=-versionString  ^versionString-=JUAMPI=-testVersion13  self deny: (self versionClass fromString: '0.8') <= (self versionClass fromString: '0.7').  self deny: (self versionClass fromString: '0.8.1.8') <= (self versionClass fromString: '0.7.0.5')-=JUAMPI=-isConfigurationName  ^self baselineOrConfigurationName matchesRegex: 'ConfigurationOf.+'-=JUAMPI=-evaluateMethodSection: methodSection version: sourceVersionString  | versionSpec |  versionSpec := self project versionSpec.  versionSpec versionString: sourceVersionString.  methodSection versionSpec: versionSpec.  currentSection := methodSection.  self with: versionSpec during: methodSection block.  methodSection methodSections do: [:ms |  self evaluateMethodSection: ms version: sourceVersionString ]-=JUAMPI=-fetchRequiredFromArray: anArray  | originalLoader displayString newLoader |  originalLoader := self versionSpec loader.  newLoader := originalLoader fetchingSpecLoader.  displayString := newLoader actionLabel , self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloPlatform current do: [ [ self versionSpec loader: newLoader.        MetacelloPlatform current useStackCacheDuring: [:dict |  ^self executeLoadFromArray: anArray ] defaultDictionary: Dictionary new ] ensure: [ self versionSpec loader: originalLoader ] ] displaying: displayString-=JUAMPI=-baseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: self directoryForPlatform ] ]-=JUAMPI=-packageNamed: aString forLoad: ignored forMap: map ifAbsent: absentBlock  | importSpec |  ^map at: aString ifAbsent: [ (self importArray notNil or: [ self import notNil ]) ifTrue: [ importArray ifNotNil: [ importArray do: [:assoc |  ((assoc value includes: aString) and: [ map includesKey: assoc key ]) ifTrue: [ importSpec := (map at: assoc key)                                   mergeImportLoads: {aString};                                   yourself ] ].                    importSpec ifNotNil: [ ^importSpec ] ].              (importSpec isNil and: [ self import notNil ]) ifTrue: [ ^(map at: self import ifAbsent: absentBlock)                       mergeImportLoads: {aString};                       yourself ] ].        (aString = 'default' or: [ aString = 'ALL' ]) ifTrue: [ self project groupSpec                 name: aString;                 includes: self packageNames;                 yourself ] ifFalse: [ absentBlock value ] ]-=JUAMPI=-loadType  ^#linear-=JUAMPI=-testProjectTagsUrlFor  | repository |  repository := MCGitlabRepository location: 'gitlab://pharo-project/pharo:master/src'.  self assert: (repository projectTagsUrlFor: 'pharo-project/pharo') equals: 'https://gitlab.com/api/v4/projects/pharo-project/pharo/repository/tags'.  repository := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo:master/src'.  self assert: (repository projectTagsUrlFor: 'pharo-project/pharo') equals: 'https://git.pharo.org/api/v4/projects/pharo-project/pharo/repository/tags'-=JUAMPI=-testMixedStack  | x |  self assert: (x := self mixedStack) identicalTo: 4-=JUAMPI=-latestVersion  ^self version-=JUAMPI=-computeVersionStatus: resolvedPackageAndProjectNames matchBlock: matchBlock  | status |  status := resolvedPackageAndProjectNames ifNil: [ self isPartiallyCurrent ] ifNotNil: [ self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].  status isAllLoadedToSpec: matchBlock.  status isLoadedToSpec: matchBlock.  status isLoadedMatchConstraints: matchBlock.  status isSomethingLoaded: matchBlock-=JUAMPI=-projectSpecCreationBlock  ^[:projectName |  {(MetacelloMCProject new projectSpec name: projectName)} ]-=JUAMPI=-symbolicVersionMap: aDictionary  symbolicVersionMap := aDictionary-=JUAMPI=-projectForVersion: aString  self project: aString with: ''-=JUAMPI=-handleResolutionFor: aScriptEngine  ^aScriptEngine handleDowngrade: self-=JUAMPI=-className: aString  self root className: aString constructor: self-=JUAMPI=-tempRepositories  tempRepositories ifNil: [ tempRepositories := OrderedCollection new ].  ^tempRepositories-=JUAMPI=-constructClassName  ^nil-=JUAMPI=-tearDown  | finalWorkingCopyList diff |  self tearDownPackages.  self tearDownRepositories.  MetacelloProjectRegistration registry: registry.  self disableUndefinedSymbolTracking ifTrue: [ MetacelloPlatform current reenableUndefinedSybolUpdates: undefinedSymbols ].  finalWorkingCopyList := MCWorkingCopy allManagers collect: [:each |  each packageName ].  diff := finalWorkingCopyList difference: initialWorkingCopyList.  diff do: [:leak |  MetacelloNotification signal: 'leaked package from ' , self printString , ' -> ' , leak printString ].  self assert: diff isEmpty.  super tearDown-=JUAMPI=-registrationForExactClassNamed: aClassName ifAbsent: absentBlock  self configurationRegistry at: aClassName ifPresent: [:registration |  ^registration ].  self baselineRegistry at: aClassName ifPresent: [:registration |  ^registration ].  ^absentBlock value-=JUAMPI=-mixedStackCall  ^MetacelloPlatform current stackCacheFor: #mixedStack at: #key doing: [:cache |  | value |        value := cache at: #x ifAbsent: [ 0 ].        value > 3 ifTrue: [ ^value ].        value := value + 1.        cache at: #x put: value.        self assert: self cachedReturnOfValue identicalTo: 6.        self mixedStackCall ]-=JUAMPI=-baseline: aString with: aBlockOrString  self root baseline: aString with: aBlockOrString constructor: self-=JUAMPI=-testRemovePackageB  | packages removed |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages remove: {(self packageSpec           name: 'Package';           yourself)}.  removed := false.  packages packageNamed: 'Package' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-externalBaselineXXX: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>externalBaselineXXX:'.        spec           package: 'External-CoreX';           package: 'External-TestsX' with: [ spec requires: 'External-CoreX' ];           yourself.        spec           group: 'Core' with: #('External-CoreX');           group: 'default' with: #('Core');           group: 'Tests' with: #('External-TestsX');           yourself ].  spec for: #custom do: [ spec package: 'External-UIX'.        spec group: 'UI' with: #('External-UIX') ]-=JUAMPI=-versionString  ^self versionDoesNotExistException versionString-=JUAMPI=-loaderPolicy  ^loaderPolicy-=JUAMPI=-match: aVersionPattern  | patternVersion mySize patternSize |  patternVersion := aVersionPattern asMetacelloVersionNumber.  mySize := self size.  patternSize := patternVersion size.  mySize = patternSize ifFalse: [ mySize < patternSize ifTrue: [ ^false ].        (patternVersion at: patternSize) ~= '?' ifTrue: [ ^false ].        mySize := patternSize ].  1 to: mySize do: [:i |  | pattern |        pattern := (patternVersion at: i) asString.        pattern = '?' ifTrue: [ i = mySize ifFalse: [ ^self error: 'Invalid version match pattern: ' , aVersionPattern printString ] ] ifFalse: [ (pattern match: (self at: i) asString) ifFalse: [ ^false ] ] ].  ^true-=JUAMPI=-projectVersion10Issue283: spec  < version: '1.0'>  spec for: #common do: [ spec blessing: #release.        spec configuration: 'ProjectIssue283' with: [ spec                 version: #stable;                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]-=JUAMPI=-projectWith: projectAttributes  | project |  project := MetacelloProject new.  project projectAttributes: projectAttributes.  MetacelloVersionConstructor on: self project: project.  ^project-=JUAMPI=-unregisterProjectRegistration: aMetacelloProjectRegistration  aMetacelloProjectRegistration configurationProjectSpec ifNotNil: [:spec |  self configurationRegistry removeKey: spec className ifAbsent: [ self error: 'unexpectedly missing project registration' ] ].  aMetacelloProjectRegistration baselineProjectSpec ifNotNil: [:spec |  self baselineRegistry removeKey: spec className ifAbsent: [ self error: 'unexpectedly missing project registration' ] ]-=JUAMPI=-fetchProject  ^self fetchProject: MetacelloLoaderPolicy new-=JUAMPI=-preloadDoItMethodSource  ^(self class sourceCodeAt: #preloadDoIt) asString-=JUAMPI=-testAddB  | repositories repository |  repositories := self repositoriesSpec.  repositories     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     add: '/opt/gemstone/repository'.  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'.  repository := repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: '/opt/gemstone/repository'.  self assert: repository type equals: 'directory'-=JUAMPI=-setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:reference |  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) with: (MCClassDefinition name: (reference packageName copyWithout: $-) asSymbol superclassName: #Object category: reference packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]-=JUAMPI=-testBaseline10Projects  | project version expected list |  project := self project.  version := project version: '1.0-baseline'.  expected := #('UTF8').  list := version projects.  self assert: list size equals: expected size.  list do: [:pkg |  self assert: (expected includes: pkg name) ]-=JUAMPI=-versionOfXX: spec  < version: '0.9.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>versionOfXX:'.        spec author: 'dkh'.        spec timestamp: '5/4/2012 14:16' ].  spec for: #custom do: [ spec baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]-=JUAMPI=-version134ProjectToolBox: spec  < version: '1.3.4-baseline'>  spec for: #common do: [  ]-=JUAMPI=-repository: anObject  self root repository: anObject constructor: self-=JUAMPI=-repository: description username: username password: password  | spec |  spec := self project repositorySpec     description: description;     username: username;     password: password;     yourself.  self addMember: (self addMember           name: spec name;           spec: spec;           yourself)-=JUAMPI=-testEqualityComparison  self deny: '1.0.0+-' asMetacelloSemanticVersionNumber equals: '1.0.0--' asMetacelloSemanticVersionNumber.  self sampleVersionStrings do: [:versionString |  self assert: versionString asMetacelloSemanticVersionNumber equals: versionString asMetacelloSemanticVersionNumber ]-=JUAMPI=-postLoad: packageOrVersionSpec  | block |  (block := packageOrVersionSpec postLoadDoItBlock) ~~ nil ifTrue: [ block valueWithPossibleArgs: {self .               packageOrVersionSpec} ]-=JUAMPI=-testMCVersionSpec  | version projectReferenceSpec group package repository |  version := self versionSpec     blessing: #baseline;     versionString: '1.0';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  version packages     add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself);     add: (self packageSpec           name: 'AnotherPackage';           yourself);     add: (self packageSpec           name: 'IncludedPackage';           yourself);     add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself);     add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself);     yourself.  self assert: version blessing value equals: #baseline.  self assert: version versionString value equals: '1.0'.  repository := version repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := version repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'.  package := version packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: package name equals: 'Package'.  group := version packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (group includes includes: 'Core').  projectReferenceSpec := version packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: projectReferenceSpec projectName equals: 'Project'.  self assert: projectReferenceSpec versionString equals: #stable.  version projectDo: [:prjct |  prjct == projectReferenceSpec ] packageDo: [:pkg |  pkg == package ] groupDo: [:grp |  grp == group ]-=JUAMPI=-allPackagesForSpecNamed: aStringOrArray ifAbsent: aBlock  ^aStringOrArray resolvePackageSpecsNamedForMetacelloMCVersion: self visited: MetacelloVisitedPackages new ifAbsent: aBlock-=JUAMPI=-testRepositoryUrl  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: cli repositoryUrl equals: 'github://juliendelplanque/MineSweeper/repository'-=JUAMPI=-errorMap  errorMap ifNil: [ errorMap := Dictionary new ].  ^errorMap-=JUAMPI=-useStackCacheDuring: aBlock defaultDictionary: defaultDictionary  | dict |  dict := MetacelloStackCacheNotification signal.  dict == nil ifTrue: [ dict := defaultDictionary == nil ifTrue: [ Dictionary new ] ifFalse: [ defaultDictionary ] ].  [ ^aBlock value: dict ] on: MetacelloStackCacheNotification , MetacelloClearStackCacheNotification do: [:ex |  (ex isKindOf: MetacelloStackCacheNotification) ifTrue: [ ex resume: dict ].        (ex isKindOf: MetacelloClearStackCacheNotification) ifTrue: [ | keys |              keys := ex cacheNames.              keys ifNil: [ keys := dict keys ].              keys do: [:k |  (dict includesKey: k) ifTrue: [ | c |                          c := dict at: k.                          c keys do: [:ck |  c removeKey: ck ].                          dict removeKey: k ] ].              ex resume ] ]-=JUAMPI=-lastVersion  ^self version-=JUAMPI=-hasRepository  ^false-=JUAMPI=-setName: aStringOrNil  self shouldBeMutable.  name := aStringOrNil-=JUAMPI=-removeGroupForVersion: aString  | spec |  spec := self project groupSpec     name: aString;     yourself.  self root packages remove: spec-=JUAMPI=-sortedAndFilteredVersions  ^(self map values asArray sort: [:a :b |  a >= b ]) select: [:vrsn |  (#(structural broken baseline) includes: vrsn blessing) not ]-=JUAMPI=-testMergeProjectB  | packages project projectReferenceSpec referenceSpec |  packages := self packagesSpec.  project := self projectSpec     name: 'Project';     className: 'ConfigurationOfProjectA';     versionString: #stable;     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  referenceSpec := self project projectReferenceSpec     name: project name;     projectReference: project;     yourself.  packages add: referenceSpec.  project := self projectSpec     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     operator: #<;     loads: #('MyPackage');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  referenceSpec := self project projectReferenceSpec     name: project name;     projectReference: project;     yourself.  packages merge: {referenceSpec}.  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  project projectDo: [:prjct |  self assert: project identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ]-=JUAMPI=-testVersion23  self assert: (MetacelloVersionNumber fromString: '3.0.0.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0') > (MetacelloVersionNumber fromString: '3.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3') > (MetacelloVersionNumber fromString: '3-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3') > (MetacelloVersionNumber fromString: '3.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0') > (MetacelloVersionNumber fromString: '3.0.0-rc.1')-=JUAMPI=-setIncludes: aCollection  includes := aCollection-=JUAMPI=-methodSections  methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].  ^methodSections-=JUAMPI=-bitbucketUser: userName project: projectName commitish: commitish path: path  | branchOrCommitOrTag |  branchOrCommitOrTag := commitish.  branchOrCommitOrTag isEmpty ifTrue: [ branchOrCommitOrTag := 'master' ].  self repository: 'bitbucket://' , userName , '/' , projectName , ':' , branchOrCommitOrTag , '/' , path-=JUAMPI=-specsNamed: packageAndProjectNames projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  | map |  map := self packages map.  packageAndProjectNames do: [:name |  | pkgSpec |        (pkgSpec := map at: name ifAbsent: [  ]) ~~ nil ifTrue: [ pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ] ]-=JUAMPI=-newVersionForWorkingCopy: aWorkingCopy  ^aWorkingCopy newVersion-=JUAMPI=-lesson11  -=JUAMPI=-spec  ^spec-=JUAMPI=-isPossibleBaseline  self projectDo: [:prj |  prj isPossibleBaseline ifFalse: [ ^false ] ] packageDo: [:pkg |  pkg isPackageLoaded ifFalse: [ ^false ] ] groupDo: [:ignored |   ].  ^true-=JUAMPI=-baseline40MethodSourceProjectIssue95  ^(self class sourceCodeAt: #baseline40ProjectIssue95:) asString-=JUAMPI=-setUpConfigurationNextedIssue84dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfNestedIssue84-dkh.1'.  className := #ConfigurationOfNestedIssue84.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version10NestedIssue84:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10NestedIssue84:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionNumberClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionNumberClass) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfo-=JUAMPI=-resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  ^andProjectsBool ifTrue: [ {self} ] ifFalse: [ self resolveToPackagesIn: aVersionSpec visited: visited ]-=JUAMPI=-repositoryForProject: anObject  self repositoryForSpec: anObject-=JUAMPI=-isSample  ^false-=JUAMPI=-externalRepositoryContents  ^#('External-CoreX-dkh.1' 'BaselineOfExternalX-dkh.1' 'BaselineOfGithubRefXX-dkh.1' 'BaselineOfGithubRefIV-dkh.1' 'BaselineOfGithubRefV-dkh.1' 'BaselineOfGithubRefVI-dkh.1' 'BaselineOfGithubRefVII-dkh.1' 'BaselineOfGithubRefVIII-dkh.1' 'BaselineOfGithubRefIX-dkh.1' 'BaselineOfGithubRefXI-dkh.1' 'BaselineOfGithubRefXII-dkh.1' 'BaselineOfGithubRefXIII-dkh.1')-=JUAMPI=-goferCommitPackage: commitMessage  | latestFile pkgSpec |  ^(file notNil and: [ self name = self file ]) ifTrue: [ latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.        pkgSpec := self copy.        pkgSpec file: latestFile.        pkgSpec goferCommitPackage: commitMessage ] ifFalse: [ self loader goferCommitPackageUsing: self repositorySpecs commitMessage: commitMessage ]-=JUAMPI=-asProjectRegistration  ^MetacelloProjectRegistration fromMCBaselineProjectSpec: self-=JUAMPI=-project  ^self projectWith: #()-=JUAMPI=-lesson10  ^Lesson title: 'Lesson 10' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #baseline10:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version10:."In #baseline10: we''ve added two things: the ''Example-AddOnTests'' package and a specification for groups. The ''Example-AddOnTests'' package has been added to make the idea of needing to group packages alittle more appealing. The package requires ''Example-AddOn'' and ''Example-Tests''.With two Test packages it would be convenient to be able to load all of the tests with a simpleexpression like the following:"  (MetacelloTutorialConfig project version: ''1.0'') load: { ''Tests''. }."instead of having to explicitly list all of the test projects like this:"  (MetacelloTutorialConfig project version: ''1.0'') 	load: { ''Example-Tests''. ''Example-AddOnTests''. }."This becomes especially useful if over time the project evolves to have more component and test packages.The ''default'' group is special in that when a ''default'' group is defined, the #load method loadsthe members of the ''default'' group instead of loading all of the packages:"  (MetacelloTutorialConfig project version: ''1.0'') load."If you want to load all of the packages in a project, then the pseudo group ''ALL'' may be used asfollows:"  (MetacelloTutorialConfig project version: ''1.0'') load: ''ALL''.ProfStef next.'-=JUAMPI=-version41SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version41Symbolic:) asString-=JUAMPI=-isConfigurationOfProjectSpec  ^true-=JUAMPI=-onConflict: aBlock  self options at: #onConflict put: aBlock-=JUAMPI=-baselineVersion40Issue119: spec  < version: '4.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec package: 'GoferBar' ]-=JUAMPI=-printOn: aStream  self print: self normalVersion prefix: nil on: aStream.  self print: self preReleaseVersion prefix: $- on: aStream.  self print: self buildVersion prefix: $+ on: aStream-=JUAMPI=-setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new-=JUAMPI=-setUpConfigurationOfAtomicFan  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfAtomicFan-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline20Fan:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFan) .   (MCMethodDefinition className: className asString selector: 'baseline31Fan:' category: 'cat' timeStamp: '' source: self baseline31MethodSourceFan) .   (MCMethodDefinition className: className asString selector: 'postLoad31baseline' category: 'cat' timeStamp: '' source: self postLoad31baselineMethodSource)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())-=JUAMPI=-file: aString  file := aString-=JUAMPI=-versionSpec  ^self project versionSpec-=JUAMPI=-loadUsing: mcLoader  self loader doingLoads: [ self explicitLoadUsing: mcLoader ]-=JUAMPI=-validateBaselineOf  self validatePragmas.  ^self validateBaselineProject-=JUAMPI=-project  ^self versionSpec project-=JUAMPI=-asMetacelloSemanticVersionNumber  ^self-=JUAMPI=-testInvalidSpecialMatch  self should: [ (self versionClass fromString: '1.1') match: '?.?' ] raise: Error-=JUAMPI=-validateConfiguration  | issues |  issues := (MetacelloMCVersionValidator validateConfiguration: project configuration class recurse: false) select: [:issue |  issue isCritical ].  issues notEmpty ifTrue: [ MetacelloValidationFailure issues: issues message: 'There are critical issues in the configuration' ]-=JUAMPI=-primeRegistryFromImage: prioritizeConfiguration  self primeRegistryFromImage: MetacelloProjectRegistration configurationClasses baselineClasses: MetacelloProjectRegistration baselineClasses prioritizeConfiguration: prioritizeConfiguration-=JUAMPI=-modifiedPackageSpecs: versionStringOrSymbol packageSpecsDo: aBlock  | versionSpec |  versionSpec := (self project version: versionStringOrSymbol) spec.  versionSpec projectDo: [:ignored |   ] packageDo: [:packageSpec |  | wc |        wc := packageSpec workingCopy.        wc ~~ nil ifTrue: [ wc modified ifTrue: [ aBlock value: versionSpec value: packageSpec value: wc ] ] ] groupDo: [:ignored |   ]-=JUAMPI=-baselineOfProjectSpec  ^self baselineOfProjectSpecClass for: self-=JUAMPI=-setUpIssue399  | versionInfo |  versionInfo := self setUpIssue399CoreSampledkh1.  versionInfo := self setUpIssue399CoreSampledkh2: {versionInfo}.  self     setUpIssue399CoreExternaldkh1;     setUpBaselineIssue399;     setUpBaselineIssue399Cypress;     yourself-=JUAMPI=-latestVersionMatching: versionPatternString excludedBlessings: excluded  ^self latestVersionMatching: versionPatternString includedBlessings: #() excludedBlessings: excluded-=JUAMPI=-useCurrentVersion: aBool  self options at: #useCurrentVersion put: aBool-=JUAMPI=-label  ^self spec label-=JUAMPI=-hasRepository  ^self repositorySpecs notEmpty-=JUAMPI=-loader  loader == nil ifTrue: [ loader := self versionSpec loader copy.        loader spec: self.        loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy ] ].  ^loader-=JUAMPI=-createDevelopmentVersion  ^Lesson title: '2. Create development version' lesson: '"After the configuration and initial baseline version have been created, define the initial development version:"		MetacelloToolBox		createDevelopment: ''1.0''		for: ''Example''		importFromBaseline: ''1.0-baseline''		description: ''initial version''."After evaluating the above expression, take a look at the #version10: method in ConfigurationOfExample:"	Smalltalk tools browser openOnClass: ConfigurationOfExample selector: #version10:."The current version of the Shout project has been filled in as well as the current version of the ProfStef packages.When a new development version is created the #development symbolic version is defined as well:"	Smalltalk tools browser openOnClass: ConfigurationOfExample selector: #development:."The #development version is defined as 1.0 for all platforms.Note that the #development symbolic version is used in a number of the Development Support scripts, so you want to make sure that it is kept up-to-date."ProfStef next.'-=JUAMPI=-projectPackage: aBlock  self root projectPackage: aBlock constructor: self-=JUAMPI=-setUpIssue399CoreSampledkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'Issue399-Core-dkh.1'.  className := #Issue399Sample.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #Object category: reference packageName instVarNames: #() comment: '')}.  sampleRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfo-=JUAMPI=-setUpConfigurationOfFeaux  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfFeaux-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline40Feaux:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceFeaux)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())-=JUAMPI=-setUpConfigurationOfFix  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfFix-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline60Fix:' category: 'cat' timeStamp: '' source: self baseline60MethodSourceFix) .   (MCMethodDefinition className: className asString selector: 'baseline61Fix:' category: 'cat' timeStamp: '' source: self baseline61MethodSourceFix)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())-=JUAMPI=-configurationRepositoryContents  ^#('ConfigurationOfExternalX-dkh.1' 'ConfigurationOfExternalXX-dkh.1' 'ConfigurationOfExternalXXX-dkh.1' 'ConfigurationOfExternalIV-dkh.1' 'MarianosImage-dkh.1')-=JUAMPI=-version20Foo: spec  < version: '2.0' imports: #('2.0-baseline')>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #release.        spec           package: 'GoferBar' with: 'GoferBar-dkh.1';           package: 'GoferFoo' with: 'GoferFoo-dkh.4';           package: 'GoferBeau' with: 'GoferBeau-dkh.15';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           yourself ]-=JUAMPI=-install  | metacello |  metacello := Metacello new.  self isBaselineName ifTrue: [ metacello baseline: self baselineOrConfigurationNameSuffix ].  self isConfigurationName ifTrue: [ metacello configuration: self baselineOrConfigurationNameSuffix ].  metacello repository: self repositoryUrl.  self hasVersion ifTrue: [ metacello version: self version ].  self hasGroups ifTrue: [ metacello load: self groups ] ifFalse: [ metacello load ]-=JUAMPI=-scriptExecutor  ^(self class scriptExecutorClass: self executorSpec) new-=JUAMPI=-projectPath: anObject  projectPath := anObject-=JUAMPI=-validateVersion: versionStringOrSymbol  | issues |  issues := (MetacelloMCVersionValidator validateProject: project version: versionStringOrSymbol) select: [:issue |  issue isError ].  issues notEmpty ifTrue: [ MetacelloValidationFailure issues: issues message: 'There are error issues with version ' , versionStringOrSymbol printString ]-=JUAMPI=-baselineVersion10MetacelloExample: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec package: 'GoferFoo' ]-=JUAMPI=-versionOrNil  ^self projectReference versionOrNil-=JUAMPI=-repository: aString username: username password: password  self repositoriesSpec repository: aString username: username password: password-=JUAMPI=-baseline14: spec  < version: '1.4-baseline' imports: #('1.2-baseline')>  spec for: #common do: [ spec description: 'Add groups and Project-Extra, extending 1.2-baseline'.        spec           package: 'Project-Core' with: [ spec includes: 'Project-Extra' ];           package: 'Project-Extra' with: [ spec requires: 'Project-Core' ].        spec           group: 'default' with: #('Project-Core' 'Project-Extra');           group: 'Core' with: #('default');           group: 'Tests' with: #('Project-Tests') ]-=JUAMPI=-projectForVersion: aString copyFrom: oldSpecName with: aBlock  | spec projectSpec |  projectSpec := self project projectSpec     name: aString;     yourself.  spec := self project projectReferenceSpec     name: aString;     projectReference: projectSpec;     yourself.  self root packages copy: oldSpecName to: spec.  self with: projectSpec during: aBlock-=JUAMPI=-setBlessing: anObject  blessing := anObject-=JUAMPI=-handleLock: exception  ^(self options at: #onLock ifAbsent: [ ^exception pass ]) cull: exception cull: exception existingProjectRegistration cull: exception newProjectRegistration-=JUAMPI=-setVersionString: anObject  versionString ifNil: [ self versionString: anObject ]-=JUAMPI=-testVersion22  self assert: (MetacelloVersionNumber fromString: '3.0.0') collapseZeros size equals: 1.  self assert: (MetacelloVersionNumber fromString: '3.0.0') equals: (MetacelloVersionNumber fromString: '3.0').  self assert: (MetacelloVersionNumber fromString: '3.0') equals: (MetacelloVersionNumber fromString: '3.0.0')-=JUAMPI=-version115ProjectToolBox: spec  < version: '1.1.5-baseline' imports: #('1.1.4-baseline')>  spec for: #common do: [ spec project: 'Example Project' with: [ spec preLoadDoIt: #alternatePreloadForCore ] ]-=JUAMPI=-configMethodOn: aStream indent: indent  aStream     tab: indent;     nextPutAll: 'spec';     cr.  self configMethodCascadeOn: aStream indent: indent-=JUAMPI=-operationString  ^operationString-=JUAMPI=-baseline13: spec  < version: '1.3-baseline'>  spec for: #squeakCommon do: [ spec package: 'Example-Core' with: [ spec                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'ftp://ftp.example.com/examples' ] ]-=JUAMPI=-testRemoveProjectA  | packages project projectReferenceSpec removed |  packages := self packagesSpec.  packages add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  packages remove: (self projectReferenceSpec           name: 'Project';           yourself).  removed := false.  packages packageNamed: 'Project' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-baseline40ProjectLoop: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Infinite' with: [ spec                 className: 'MetacelloTestConfigurationOfProjectInfinite';                 versionString: '4.0';                 loads: 'GoferBar';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           package: 'GoferFaux' with: [ spec                 file: 'GoferFaux-tg.30';                 requires: 'Infinite';                 yourself ];           package: 'GeauxBeau' with: [ spec                 file: 'GeauxBeau-dkh.55';                 yourself ];           yourself ]-=JUAMPI=-validateVersionString: issues withDefaultVersionString: ignored  self versionString ifNotNil: [:vs |  | prj |        prj := self project asBaselineProject.        vs ~= prj singletonVersionName ifTrue: [ issues add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #invalidVersionString callSite: #validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription: explanation: 'version field is incorrect, should be: ' , prj singletonVersionName printString) ] ]-=JUAMPI=-loader: aLoader  self shouldBeMutable.  loader := aLoader copy.  loader spec: self-=JUAMPI=-directoryForPlatform  | dir |  dir := '/opt/mcexamples'.  (Smalltalk classNamed: #OSPlatform) ifNotNil: [:c |  c current isWindows ifTrue: [ dir := 'c:\opt\mcexamples' ] ].  ^dir-=JUAMPI=-updatePackageSpec: updatedSpecs  | prj currentVersion spec |  className == nil ifTrue: [ ^self ].  prj := self projectClassProject.  (currentVersion := prj currentVersion) = self versionOrNil ifTrue: [ ^self ].  currentVersion == nil ifTrue: [ ^self ].  spec := self copy.  spec versionString: currentVersion versionString.  updatedSpecs at: spec name put: spec-=JUAMPI=-aLoadedProjectIsNotCurrent  ^aLoadedProjectIsNotCurrent-=JUAMPI=-versionInfo: aMetacelloProjectRegistrationVersionInfo  versionInfo := aMetacelloProjectRegistrationVersionInfo-=JUAMPI=-validateDoItSelector: anObject  anObject == nil ifTrue: [ ^self ].  anObject isSymbol ifFalse: [ self error: 'Invalid message selector for doit: ' , anObject printString ]-=JUAMPI=-packageSpecClass  ^MetacelloCypressPackageSpec-=JUAMPI=-aLoadedPackageIsExact: aBoolean  aLoadedPackageIsExact := aBoolean-=JUAMPI=-recursiveDelete: aDirectory  ^aDirectory recursiveDelete-=JUAMPI=-samplePath  ^'metacello-tests/sample'-=JUAMPI=-ancestorsFor: packageSpec ifAbsent: aBlock  ^self versionInfoMap at: packageSpec file ifAbsent: [ self packageNameMap at: packageSpec name ifAbsent: aBlock ]-=JUAMPI=-decrementMinorVersionNumber  self decrementNormalVersionAt: 3-=JUAMPI=-version  ^self version: self singletonVersionName-=JUAMPI=-postloadForCore: loader package: packageSpec  MetacelloNotification signal: '#postloadForCore executed, Loader: ' , loader printString , ' spec: ' , packageSpec printString-=JUAMPI=-determineCurrentVersionForLoad  ^self version-=JUAMPI=-handleLookupProjectSpecForLoad: exception  | requested override |  requested := exception projectSpec.  override := self useCurrentVersion ifTrue: [ nil ] ifFalse: [ | registered |        registered := self lookupProjectSpecFor: exception projectSpec.        (registered compareEqual: requested) ifFalse: [ override := registered ] ].  ^exception resume: (MetacelloProjectSpecForLoad new           projectSpec: requested;           useDetermineVersionForLoad: self useCurrentVersion;           overrideProjectSpec: override;           yourself)-=JUAMPI=-target  ^target-=JUAMPI=-answers  answers == nil ifTrue: [ answers := #() ].  ^answers-=JUAMPI=-setPostLoadDoIt: aSymbol  self shouldBeMutable.  postLoadDoIt := aSymbol-=JUAMPI=-baseline61MethodSourceProjectIssue86  ^(self class sourceCodeAt: #baseline61ProjectIssue86:) asString-=JUAMPI=-loadUsing: aLoader gofer: gofer  -=JUAMPI=-closeZipArchive: anArchive  -=JUAMPI=-testRemoveGroupC  | packages removed |  packages := self packagesSpec.  packages add: {(self groupSpec           name: 'Platform';           includes: 'Core';           yourself) .         (self groupSpec           name: 'Base';           includes: 'Base';           yourself) .         (self groupSpec           name: 'Tests';           includes: 'Tests';           yourself)}.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  packages packageNamed: 'Base' ifAbsent: [ self assert: false ].  packages packageNamed: 'Tests' ifAbsent: [ self assert: false ].  packages remove: 'Tests'.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  packages packageNamed: 'Base' ifAbsent: [ self assert: false ].  removed := false.  packages packageNamed: 'Tests' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-versionReferences  ^versionReferences-=JUAMPI=-performLoad  | displayString spec |  spec := self projectSpec.  displayString := 'Project: ' , spec name.  spec versionString ~~ nil ifTrue: [ displayString := displayString , ' ' , spec versionString ].  MetacelloNotification signal: displayString.  self hasOverride ifTrue: [ | override |        override := self overrideProjectSpec copy.        override mergeScriptLoads: spec.        override loadVersion: nil ] ifFalse: [ | vrsn |        vrsn := self useDetermineVersionForLoad ifTrue: [ spec determineCurrentVersionForLoad ] ifFalse: [ spec versionOrNil ].        (spec asProjectSpecForVersion: vrsn) loadVersion: vrsn ]-=JUAMPI=-repositorySpecs  ^self repositories map values-=JUAMPI=-