atomicLoadPackageSpecs: packageSpecs repositories: repositories  self loaderPolicy pushAtomicLoadDirectivesDuring: [ super linearLoadPackageSpecs: packageSpecs repositories: repositories ] for: selfname  ^namedo: aBlock displaying: aString  self bypassProgressBars ifTrue: [ ^super do: aBlock displaying: aString ].  aString displayProgressFrom: 0 to: 2 during: [:bar |  bar value: 1.        aBlock value.        bar value: 2 ]baselineForVersion: aString with: aBlock  aBlock setBaseline: aString withInMetacelloConfig: selflist  actionArg := #list -> #().  self singleRoot: falseexpectedPrintString  ^'spec blessing: #''baseline''.spec description: ''Descriptive comment''.spec preLoadDoIt: #''preloadForVersion''.spec postLoadDoIt: #''postloadForVersion''.spec author: ''dkh''.spec timestamp: ''10/7/2009 14:40''.spec repositories: [	spec		repository: ''/opt/mc/repository'';		repository: ''c:\pharo\myapp\repo\'';		repository: ''dictionary://GlobalName'';		repository: ''ftp://ftp.example.com/repo'';		repository: ''http://www.example.com/ar'';		repository: ''http://www.example.com/private'' username: ''foo'' password: ''bar'';		repository: ''http://www.example.com/rr'' ].spec 	project: ''UI Support'' with: [		spec			className: ''ConfigurationOfUI'';			versionString: ''1.0'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			operator: #''~>'';			loads: #(''UI-Core'' );			repository: ''http://www.example.com/r'' ];	project: ''UI Support'' overrides: [		spec			className: ''ConfigurationOfUINew'';			versionString: ''1.0'';			operator: #''>='';			loads: #(''UI-Core'' ''UI-Tests'' );			repository: ''http://www.example.com/r'' username: ''foo'' password: ''bar'' ];	project: ''UI Tests'' copyFrom: ''UI Support'' with: [		spec			className: ''ConfigurationOfUI'';			versionString: ''1.0'';			operator: #''~>'';			loads: #(''UI-Core'' ''UI-Tests'' );			repository: ''http://www.example.com/r'' ];	project: ''UI Support'' with: ''1.0.1'';	removeProject: ''UI Tests'';	project: ''UI Multi'' with: [		spec			className: ''ConfigurationOfMulti'';			repository: ''http://www.example.com/r'';			repository: ''http://www.example.com/s'' ].spec 	package: ''Example-AddOn'' with: [		spec 			requires: #(''Example-Core'' );			includes: #(''Example-UI'' );			file: ''Example-AddOn-anon.3'';			repositories: [				spec					repository: ''http://www.example.com/yar'';					repository: ''http://www.example.com/yas'' ];			preLoadDoIt: #''preloadForAddOn'';			postLoadDoIt: #''postloadForAddOn''. ];	package: ''Example-AddOn'' overrides: [		spec 			requires: #(''Example-Core'' ''UI Support'' );			includes: #(''Example-UI'' );			supplyingAnswers: #( #( ''list of packages'' ''Kernel* Collection*'' ) );			file: ''Example-AddOn-anon.7'';			repository: ''http://www.example.com/or'' username: ''foo'' password: ''bar'';			preLoadDoIt: #''preloadForAddOn'';			postLoadDoIt: #''postloadForAddOn''. ];	package: ''Example-AddOn'' with: ''Example-AddOn-anon.5'';	package: ''Example-Core'';	package: ''Example-Tests'' with: [		spec requires: #(''Example-Core'' ). ];	package: ''Example-TestsUI'' with: [		spec requires: #(''Example-UI'' ). ];	package: ''Example-UI'' with: [		spec requires: #(''Example-AddOn'' ). ];	removePackage: ''Example-Tests''.spec 	group: ''default'' with: #(''Example-Core'' ''Example-AddOn'' );	group: ''default'' overrides: #(''Example-Core'' ''Example-Tests'' );	removeGroup: ''default''.'file: aString  self shouldBeMutable.  file := aString.  self projectPackage: nilversion13: spec  < version: '1.3' imports: #('1.3-baseline')>  spec for: #common do: [ spec blessing: #development.        spec description: 'Add in doits for Example-Core'.        spec author: 'dkh'.        spec timestamp: '10/13/2009 14:27'.        spec           package: 'Example-Core' with: 'Example-Core-anon.17';           package: 'Example-Tests' with: 'Example-Tests-anon.6';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ].  spec for: #gemstone do: [ spec package: 'Example-Platform' with: 'Example-Platform.gemstone-dkh.4' ].  spec for: #pharo do: [ spec package: 'Example-Platform' with: 'Example-Platform.pharo-dkh.7' ].  spec for: #squeak do: [ spec package: 'Example-Platform' with: 'Example-Platform.squeak-dkh.3' ]configuration091Issue63: spec  < version: '0.9.1'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration091Issue63:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           import: 'External' ]monticelloRepository  ^monticelloRepositoryonUpgrade: aBlock  self addStatement: #onUpgrade: args: {aBlock}updatePackageSpec: updatedSpecs using: anMCLoader  self updatePackageSpec: updatedSpecs force: false using: anMCLoadertestMergePackageA  | packages package |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages merge: (self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           includes: 'AndIncludedPackage';           answers: #(#('xpostload' 'xpostload answer'));           file: 'Package-dkh.2';           yourself).  package := packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: package name equals: 'Package'.  self assert: package requires equals: #('AnotherPackage' 'AndAnotherPackage').  self assert: package includes equals: #('IncludedPackage' 'AndIncludedPackage').  self assert: package answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer') #('xpostload' 'xpostload answer')).  self assert: package file equals: 'Package-dkh.2'.  self assert: package preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: package postLoadDoIt value identicalTo: #postLoadDoItsetUpConfigurationOfProjectIssue119dkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.2'.  className := reference packageName asSymbol.  definitionArray := {(MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion20Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue119:) asString) .   (MCMethodDefinition className: className asString selector: 'version20Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfoloaderPolicy: anObject  loaderPolicy := anObjectpostLoadDoIt  ^postLoadDoItload: required onProjectDownGrade: onDownGradeBlock onProjectUpgrade: onUpgradeBlock  MetacelloProjectRegistration copyRegistryRestoreOnErrorWhile: [ self handleNotificationsForAction: [ | version loadedSpec |              self setDefaultsAndValidateProjectSpec.              [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ] on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade do: [:ex |  ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].              version := loadedSpec versionForScriptEngine: self.              self root: (required isEmpty ifTrue: [ version load ] ifFalse: [ version load: required ]) loadDirective.              loadedSpec loads: required.              MetacelloProjectRegistration registrationForProjectSpec: loadedSpec ifAbsent: [:new |  new                       loadedInImage: true;                       registerProject ] ifPresent: [:existing :new |  existing copyOnWrite: [:existingCopy |  existingCopy                             loadedInImage: true;                             merge: new ] ] ] ]version132ProjectToolBox: spec  < version: '1.3.2-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository' ].  spec for: #level1_1 do: [ spec package: 'GoferBeau' with: 'GoferBeau-dkh.15'.        spec for: #level2_1 do: [ spec package: 'GoferBeau' with: 'GoferBeau-dkh.25'.              spec for: #level3_1 do: [ spec package: 'GoferBeau' with: 'GoferBeau-dkh.53' ] ].        spec for: #level2_2 do: [ spec package: 'GoferBeau' with: 'GoferBeau-dkh.54'.              spec for: #level3_2 do: [ spec package: 'GoferBeau' with: 'GoferBeau-dkh.55' ] ] ]setUpConfigurationOfProjectIssue283  | versionInfo |  versionInfo := self setUpConfigurationOfProjectIssue283dkh1.  versionInfo := self setUpConfigurationOfProjectIssue283dkh2: {versionInfo}.  self setUpConfigurationOfProjectConfigIssue283dkh1do: elementBlock separatedBy: separatorBlock  | beforeFirst |  beforeFirst := true.  self do: [:each |  beforeFirst ifTrue: [ beforeFirst := false ] ifFalse: [ separatorBlock value ].        elementBlock value: each ]mapCopy: aMemberSpec into: map  | spec |  spec := map at: aMemberSpec sourceName ifAbsent: [  ].  spec == nil ifTrue: [ ^self error: 'Source spec named ' , aMemberSpec sourceName printString , ' not found' ] ifFalse: [ spec aboutToCopy.        map at: aMemberSpec name put: (spec copy mergeSpec: aMemberSpec spec copy) ]description  ^'The symbolic version ' , self versionString printString , ' is not defined in ' , self project label , ' for the current platform. Possible symbolic version values include: ' , self possibleVersions printStringdirectivesDo: aBlock  aBlock value: self.  self loadDirectives do: [:directive |  directive directivesDo: aBlock ]handleResolutionFor: aScriptEngine  ^aScriptEngine handleUpgrade: selfvalidatePragmas  | versionPragmas versionImportPragmas symbolicVersionPragmas versionStrings |  versionPragmas := self extractVersionPragmas.  versionImportPragmas := self extractVersionImportPragmas.  symbolicVersionPragmas := self extractSymbolicVersionPragmas.  versionStrings := Set new.  versionPragmas keys , versionImportPragmas keys , symbolicVersionPragmas keys do: [:versionString |  (versionStrings includes: versionString) ifTrue: [ self recordValidationCriticalWarning: 'version ' , versionString printString , ' is defined multiple times.' versionString: versionString callSite: #validatePragmas reasonCode: #duplicateVersionDefinitions ] ifFalse: [ versionStrings add: versionString ] ].  versionPragmas keysAndValuesDo: [:versionString :pragmaList |  versionString isString ifFalse: [ self recordValidationError: 'version ' , versionString printString , ' is not a String.' versionString: versionString callSite: #validatePragmas reasonCode: #invalidVersionString ].        pragmaList size > 1 ifTrue: [ self recordValidationCriticalWarning: 'version ' , versionString printString , ' is defined multiple times.' versionString: versionString callSite: #validatePragmas reasonCode: #duplicateVersionDefinitions ] ].  symbolicVersionPragmas keysAndValuesDo: [:versionString :pragmaList |  versionString isSymbol ifFalse: [ self recordValidationError: 'symbolic version ' , versionString printString , ' is not a Symbol.' versionString: versionString callSite: #validatePragmas reasonCode: #invalidVersionString ].        pragmaList size > 1 ifTrue: [ self recordValidationCriticalWarning: 'version ' , versionString printString , ' is defined multiple times.' versionString: versionString callSite: #validatePragmas reasonCode: #duplicateVersionDefinitions ] ].  versionImportPragmas keysAndValuesDo: [:versionString :pragmaList |  versionString isString ifFalse: [ self recordValidationError: 'version ' , versionString printString , ' is not a String.' versionString: versionString callSite: #validatePragmas reasonCode: #invalidVersionString ].        pragmaList size > 1 ifTrue: [ self recordValidationCriticalWarning: 'version ' , versionString printString , ' is defined multiple times.' versionString: versionString callSite: #validatePragmas reasonCode: #duplicateVersionDefinitions ].        pragmaList do: [:versionImportPragma |  (versionImportPragma arguments at: 2) do: [:importedVersionString |  (versionStrings includes: importedVersionString) ifFalse: [ self recordValidationError: 'version ' , importedVersionString printString , ' referenced in import list of version ' , versionString printString , ' has not been defined.' versionString: versionString callSite: #validatePragmas reasonCode: #missingVersionImport ] ] ] ]repositoryString  | repositoryString |  repositoryString := ''.  self repositories do: [:repo |  repositoryString := repositoryString , ' ' , repo description ].  ^repositoryStringstableVersion283B: spec  < symbolicVersion: #stable>  spec for: #common version: '2.1'testIncrementDecrementVersion  | version |  version := self defaultVersion1.  self assert: version incrementMajorVersion asString equals: '2.0.0'.  self assert: version decrementMajorVersion asString equals: '1.0.0'.  self assert: version incrementMinorVersion asString equals: '1.1.0'.  self assert: version decrementMinorVersion asString equals: '1.0.0'.  self assert: version incrementPatchVersion asString equals: '1.0.1'.  self assert: version decrementPatchVersion asString equals: '1.0.0'postLoadDoItForProject: aSymbol  self postLoadDoItForSpec: aSymbolhasPackage: aString  ^MCWorkingCopy allManagers anySatisfy: [:each |  each packageName = aString ]exception  ^exceptionsetUpDependency  | reference |  reference := GoferVersionReference name: 'GoferUmbrella-dkh.4'.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) with: (MCClassDefinition name: (reference packageName copyWithout: $-) asSymbol superclassName: #Object category: reference packageName asSymbol instVarNames: #() comment: ''))) dependencies: (Array with: (MCVersionDependency package: (MetacelloTestsMCPackage new name: 'GoferBarDependency') info: (monticelloRepository versionInfoFromVersionNamed: 'GoferBarDependency-lr.30')) with: (MCVersionDependency package: (MetacelloTestsMCPackage new name: 'GoferFooDependency') info: (monticelloRepository versionInfoFromVersionNamed: 'GoferFooDependency-lr.30'))))loader  ^loaderbaselineGithubReferenceVII: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>baselineGithubReferenceVII:'.        spec           baseline: 'External Core' with: [ spec                 className: 'BaselineOfExternal';                 loads: 'Core';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           project: 'External Tests' copyFrom: 'External Core' with: [ spec loads: 'Tests' ] ]project  | constructor project |  constructor := MetacelloVersionConstructor on: self.  project := constructor project.  project loader: (project loaderClass new           shouldDisablePackageCache: true;           yourself).  project loadType: self loadType.  ^projectprojectSpecSelectBlock  ^[:projectSpec |  projectSpec notNil ]repositoryBranchName  ^self projectVersionloadedInImage  loadedInImage ifNil: [ loadedInImage := false ].  ^loadedInImageversions  ^[ {self version} ] on: MetacelloVersionDoesNotExistError do: [:ex |  ^#() ]importForVersion: aString  self root import: aStringincludeSpecNamesForPackageOrdering: aVersionSpec  ^#()testVersionSpecCreateVersion  | spec version |  spec := self versionSpec     blessing: #baseline;     versionString: '1.0';     description: 'A description';     author: 'dkh';     timestamp: '1/24/2012 09:59';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  version := spec createVersion.  self assert: version class identicalTo: spec versionClass.  self assert: version spec identicalTo: spec.  self assert: version versionNumber asString equals: '1.0'.  self assert: version blessing equals: #baseline.  self assert: version versionString equals: '1.0'.  self assert: version description equals: 'A description'.  self assert: version author equals: 'dkh'.  self assert: version timestamp equals: '1/24/2012 09:59'isPackageLoaded  ^self isPackageLoaded: self loaderunstableVersionOfX: spec  < symbolicVersion: #unstable>  spec for: #common version: '0.9.1'mergeSpec: anotherSpec  ^super mergeSpec: anotherSpec asConfigurationProjectSpecversion110ProjectToolBox: spec  < version: '1.1.0-baseline'>  spec for: #common do: [ spec           package: 'Example-Core';           package: 'Example-Base';           package: 'Example-Test1' with: [ spec                 requires: #('Example-Base');                 includes: #('Example-Core') ];           package: 'Example-Test2' with: [ spec                 includes: #('Example-Core');                 supplyingAnswers: #(#('captionMatch' 'answer')) ];           package: 'Example-Test3' with: [ spec                 requires: #('Example-Base');                 supplyingAnswers: #(#('captionMatch' 'answer')) ];           package: 'Example-Test4' with: [ spec                 requires: #('Example-Base');                 includes: #('Example-Core');                 supplyingAnswers: #(#('captionMatch' 'answer')) ] ]testSelfHostedLocationWithNonDefaultSSHPort  | repository |  repository := MCGitlabRepository location: 'gitlab://git.pharo.org:1234:pharo-project/pharo:master/src'.  self     assert: repository hostname equals: 'git.pharo.org';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assert: repository repoPath equals: 'src';     assert: repository sshPort equals: '1234'.  repository := MCGitlabRepository location: 'gitlab://git.pharo.org:1234:pharo-project/pharo:master'.  self     assert: repository hostname equals: 'git.pharo.org';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assertEmpty: repository repoPath;     assert: repository sshPort equals: '1234'.  repository := MCGitlabRepository location: 'gitlab://git.pharo.org:1234:pharo-project/pharo'.  self     assert: repository hostname equals: 'git.pharo.org';     assert: repository projectPath equals: 'pharo-project/pharo';     assert: repository projectVersion equals: 'master';     assertEmpty: repository repoPath;     assert: repository sshPort equals: '1234'configMethodOn: aStream indent: indent  aStream     tab: indent;     nextPutAll: 'spec value: ' , self value printStringrepositoryForSpec: anObject  self root repository: anObjectbaseline35MethodSourceFoo  ^(self class sourceCodeAt: #baseline35Foo:) asStringsetBlessingWithBlock: aBlock  | spec |  (spec := self root getBlessing) == nil ifTrue: [ spec := self project valueHolderSpec.        self root setBlessing: spec ].  self with: spec during: aBlocklocked: anObject  self shouldBeMutable.  locked := anObjectbaselineGoo400Issue156Configuration: spec  < version: '4.0.0'>  spec for: #common do: [ spec           baseline: 'Goo' with: [ spec repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           import: 'Goo' ]includes: anObject constructor: aVersionConstructor  aVersionConstructor includesForPackage: anObjectpackageSpecClass  MetacelloCypressBaselineProject useCypressPackagesForAllBaselines ifTrue: [ ^MetacelloCypressPackageSpec ].  ^super packageSpecClasssetUpIssue399CoreSampledkh2: ancestors  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'Issue399-Core-dkh.2'.  className := #Issue399Sample.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #Object category: reference packageName instVarNames: #() comment: '')}.  sampleRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: ancestors) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfotestMergeB  | repositories repository |  repositories := self repositoriesSpec.  repositories     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     merge: 'http://example.com/repository'.  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'project: aProject  project ifNil: [ self class ensureMetacello ].  project := aProjectversion06: spec  < version: '0.6'>  spec for: #common do: [ spec repository: 'http://www.example.com/Example'.        spec           package: 'Example-Core' with: 'Example-Core-anon.12';           package: 'Example-Tests' with: [ spec                 file: 'Example-Tests-anon.3';                 requires: 'Example-Core' ];           package: 'Example-AddOn' with: [ spec                 file: 'Example-AddOn-anon.1';                 requires: 'Example-Core' ] ]baselineIssue215: spec  < baseline>  spec for: #common do: [ spec description: self className , '>>baselineGithubReferenceV:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           import: 'External' provides: #('External-Core' 'External-Tests') ]externalAuthorName  ^'dkh'ensuredMap  ^self loaderPolicy ensuredMaplesson11Descripton  projectVersionPattern: aString  projectVersionPattern := aStringafterLoads  afterLoads == nil ifTrue: [ afterLoads := OrderedCollection new ].  ^afterLoadssetUpExternalCore  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'External-Core-dkh.1'.  className := #ExternalCore.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #Object category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'externalAuthorName' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalAuthorName) asString) .   (MCMethodDefinition className: 'Object' classIsMeta: true selector: 'isExternal' category: '*external-core' timeStamp: '' source: (self class sourceCodeAt: #isExternal) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfospawnPackageMethodIn: aConfig category: methodCategory named: newSelector sourceVersion: sourceVersionString targetVersion: targetVersionString blessing: blessing  self deprecated: 'see MetacelloToolBox class>>createBaseline:for:from:description: for replacement method'.  self prepareForMethodUpdate: aConfig sourceVersion: sourceVersionString forceUpdate: blessing ~~ #baseline generating: [:selector :pragmaMap :ar :updatedPackageSpecsMap |  | strm |        strm := WriteStream on: String new.        strm           nextPutAll: newSelector asString , ' spec';           cr;           tab;           nextPutAll: '<version: ' , targetVersionString printString , ' imports: #(' , sourceVersionString printString , ')>';           cr.        (ar at: 2) do: [:attribute |  | vs d |              vs := (ar at: 1) at: attribute.              (d := updatedPackageSpecsMap at: attribute ifAbsent: [  ]) ~~ nil ifTrue: [ vs packagesSpec list do: [:member |  | x |                          x := d at: member spec name ifAbsent: [  ].                          member spec updateForSpawnMethod: x ] ] ifFalse: [ vs packagesSpec list do: [:member |  member spec updateForSpawnMethod: member spec copy ] ].              strm                 cr;                 tab;                 nextPutAll: 'spec for: ' , attribute printString , ' do: [';                 cr.              attribute == #common ifTrue: [ vs                       author: MetacelloPlatform current authorName;                       timestamp: MetacelloPlatform current timestamp.                    blessing ~~ nil ifTrue: [ vs blessing: blessing ] ].              vs configSpawnMethodOn: strm indent: 2.              strm nextPutAll: '].' ].        (aConfig class compile: strm contents classified: methodCategory) == nil ifTrue: [ self error: 'Error compiling the method' ] ].  ^truetestRemoveGroupA  | packages group removed |  packages := self packagesSpec.  packages add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  packages merge: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself).  group := packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (group includes includes: 'Core').  self assert: (group includes includes: 'Tests').  packages remove: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  removed := false.  packages packageNamed: 'Platform' ifAbsent: [ removed := true ].  self assert: removededitVersionSpecsForImport: constructor projectAttributes: projectAttributes active: activeSection fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs  | fileSpecified encounteredPackageSpecs |  fileSpecified := Bag new.  encounteredPackageSpecs := Bag new.  constructor methodSectionsInEvaluationOrder: projectAttributes reverse do: [:methodSection |  methodSection versionSpec specListProjectDo: [:spec |   ] packageDo: [:spec |  encounteredPackageSpecs add: spec name.              (spec copy updateForSpawnMethod: spec) ifFalse: [ fileSpecified add: spec name ] ] groupDo: [:spec |   ] ].  constructor methodSectionsInEvaluationOrder: projectAttributes reverse do: [:methodSection |  | versionSpec attributePath packageSpecsToDelete |        versionSpec := methodSection versionSpec.        attributePath := methodSection attributePath.        versionSpec updateForSpawnMethod: versionSpec.        packageSpecsToDelete := OrderedCollection new.        versionSpec specListProjectDo: [:spec |  spec updateForSpawnMethod: spec ] packageDo: [:spec |  encounteredPackageSpecs remove: spec name.              (spec updateForSpawnMethod: spec) ifTrue: [ ((fileSpecified includes: spec name) or: [ encounteredPackageSpecs includes: spec name ]) ifTrue: [ packageSpecsToDelete add: spec ] ifFalse: [ spec file: spec name.                          fileSpecified add: spec name ] ] ifFalse: [ (fileSpecified occurrencesOf: spec name) > 1 ifTrue: [ packageSpecsToDelete add: spec.                          fileSpecified remove: spec name ] ] ] groupDo: [:spec |  spec updateForSpawnMethod: spec ].        packageSpecsToDelete do: [:spec |  versionSpec deleteSpec: spec ].        activeSection ifTrue: [ self updateVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages visited: visitedSpecs updated: updatedSpecs ] ifFalse: [ self clearVersionSpec: versionSpec fullVersionSpec: fullVersionSpec updateProjects: updateProjects updatePackages: updatePackages ] ]externalPath  ^'metacello-tests/external'projectName: anObject  self shouldBeMutable.  projectName := anObjectexecute: selector args: args  | script |  script := self statements copy.  script add: selector -> args.  ^self scriptExecutor execute: scriptdebug: aCollection  debug := aCollectionconfigurationGithubReferenceX: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configurationGithubReferenceX:'.        spec project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]projectName  ^self subclassResponsibilitytearDownPackageList  ^#('ConfigurationOfExternalX' 'ConfigurationOfExternalXX' 'ConfigurationOfExternal' 'ConfigurationOfExternalXXX' 'ConfigurationOfExternalIV' 'ConfigurationOfExternalIV' 'BaselineOfExternalX' 'BaselineOfGithubRefXX' 'BaselineOfGithubRefIV' 'BaselineOfGithubRefV' 'BaselineOfGithubRefVI' 'BaselineOfGithubRefVII' 'BaselineOfExternal' 'BaselineOfExternalX' 'External-CoreX' 'Sample-CoreX' 'ConfigurationOfMetacelloExample' 'GoferFoo' 'Sample-Core' 'Sample-Platform' 'Sample-Tests' 'External-Core' 'ExternalCore' 'External-Tests' 'BaselineOfGithubRefVIII' 'BaselineOfGithubRefIX' 'MarianosImage' 'BaselineOfGithubRefXI' 'BaselineOfGithubRefXII' 'BaselineOfGithubRefXIII')file: aString constructor: aVersionConstructor  aVersionConstructor fileForProject: aStringbaseline40MethodSourceFoo  ^(self class sourceCodeAt: #baseline40Foo:) asStringtransact: aBlock  aBlock valueprojectTagsUrlFor: projectPath2  ^'https://api.github.com/repos/' , projectPath2 , '/tags'introductionText  ^'Convers basic Metacello configuration specifications:	1. Open a code browser on the MetacelloTutorialConfig class:"		MetacelloTutorialConfig browse.	"2. In the browser view the ''--all--'' category.	3. Have fun!"'versionNumberFrom: aString  ^self versionNumber class fromString: aStringupdateForSpawnMethod: sourceSpec  repositories := preLoadDoIt := postLoadDoIt := nilhasPackage: aString  ^MCWorkingCopy allManagers anySatisfy: [:each |  each packageName = aString ]tempFileFor: aName suffix: aSuffixString  ^'/tmp/' , aName , aSuffixStringreenableUndefinedSybolUpdates: undefinedSymbols  lesson11  fetch: required  ^required fetchRequiredForMetacelloMCVersion: selfupdatePackageSpec: updatedSpecs force: force using: anMCLoader  | viName |  (force not and: [ self getFile == nil ]) ifTrue: [ ^self ].  (viName := self workingCopyNameFor: anMCLoader) == nil ifTrue: [ ^self ].  viName ~= self file ifTrue: [ | spec |        spec := self copy.        spec file: viName.        updatedSpecs at: spec name put: spec ] ifFalse: [ updatedSpecs at: self name put: #uptodate ]onDowngradeUseIncoming  self onDowngrade: [:ex :loaded :incoming |  ex useIncoming ]currentlyLoadedClassesInVersion  | classes |  classes := Set new.  self projectDo: [:ignored |   ] packageDo: [:packageSpec |  | wc |        wc := [ packageSpec workingCopy ] on: Error do: [:ex |  ex return: nil ].        wc ~~ nil ifTrue: [ classes addAll: (MetacelloPlatform current packageInfoFor: wc) classes ] ] groupDo: [:ignored |   ].  ^classesprojectClass  ^MetacelloMCProjectrepositoryMap  ^self loaderPolicy repositoryMappreLoad: packageOrVersionSpec  | block |  (block := packageOrVersionSpec preLoadDoItBlock) ~~ nil ifTrue: [ block valueWithPossibleArgs: {self .               packageOrVersionSpec} ]list  ^self execute: #list args: #()version10NestedIssue84: spec  < version: '1.0.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>version10NestedIssue84:'.        spec author: 'dkh'.        spec timestamp: '7/24/2012 19:23'.        spec repository: 'dictionary://Metacello_Configuration_Test_Repository'.        spec package: 'External-CoreX' ]extractMethodSectionsFor: aBaselineClass  self shouldNotImplementgtInspectorCodeIn: composite  < gtInspectorPresentationOrder: 40>  composite pharoScript     title: 'Code';     display: [ String streamContents: [:s |  self configMethodOn: s indent: 0 ] ]setPostLoadDoItInMetacelloSpec: aMetacelloSpec  aMetacelloSpec setPostLoadDoIt: selflinearLoadPackageSpec: packageSpec gofer: gofer  self subclassResponsibilitypackageNames  packageList == nil ifTrue: [ ^#() ].  ^self packages map keys asSetprojectSpec: anObject  projectSpec := anObjectdefaultAction  self checkAllowed.  ^self newProjectRegistrationbleedingEdge206A: spec  < symbolicVersion: #bleedingEdge>  spec for: #common version: '2.0'list: aCollection  list := aCollection.  self clearMemberMapprojectSpec  ^projectSpecsetUpConfigurationNextedIssue84  | versionInfo |  versionInfo := self setUpConfigurationNextedIssue84dkh1.  self setUpConfigurationNextedIssue84dkh2: {versionInfo}repositoriesFrom: aMetacelloMVRepositorySpecs  ^self repositoriesFrom: aMetacelloMVRepositorySpecs ignoreOverrides: falsetestAddProjectB  | packages project projectReferenceSpec |  packages := self packagesSpec.  packages add: {(self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself) .         (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself)}.  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: projectReferenceSpec projectName equals: 'Project'.  self assert: projectReferenceSpec versionString equals: '1.0'.  self should: [ projectReferenceSpec includes: #() ] raise: Error.  self should: [ projectReferenceSpec requires: #() ] raise: Error.  self should: [ projectReferenceSpec answers: #() ] raise: Error.  projectReferenceSpec projectDo: [:prjct |  self assert: projectReferenceSpec identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  project projectDo: [:prjct |  self assert: project identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ]useNew  self allowgoferVersionFrom: aVersionReference  self flag: #review.  ^self localRepository goferVersionFrom: aVersionReferencesetUpConfigurationOfProjectIssue136dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue136-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baselineVersion10Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue136:) asString) .   (MCMethodDefinition className: className asString selector: 'version10Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue136:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInforepositories: aBlock  self root repositories: aBlock constructor: selfanswers: aListOfPairs  self setAnswers: aListOfPairscanDowngradeTo: aMetacelloProjectSpec  (self className = aMetacelloProjectSpec className and: [ self operator == aMetacelloProjectSpec operator ]) ifFalse: [ ^false ].  self versionOrNil == nil ifTrue: [ ^true ].  ^(self compareVersions: aMetacelloProjectSpec usingOperator: self operator) notconfiguration  ^configurationversion51Umbrella: spec  < version: '5.1'>  spec for: #common do: [ spec           project: 'Umbrella' with: [ spec                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '5.1';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]vrsnStatus  ^vrsnStatusimportFrom: inputVersionStringOrSymbol updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlock  ^self importFrom: inputVersionStringOrSymbol projectAttributes: project attributes inactiveAttributes: #() updateProjects: updateProjects updatePackages: updatePackages versionSpecsDo: aBlockversionDoesNotExistException: anObject  versionDoesNotExistException := anObjectclassName  className ifNil: [ self name ifNotNil: [ self className: self constructClassName ] ].  ^classNameupdatePackageSpec: updatedSpecs using: anMCLoader  self projectReference updatePackageSpec: updatedSpecsvalidateAndSaveConfiguration  ^Lesson title: '3. Validate and save configuration in project repository' lesson: '"Before saving a configuration into the project repository, the configuration should be validated and any Critical Issues should be addressed:"			(MetacelloToolBox validateConfiguration: ConfigurationOfExample) explore."Use Gofer to save the configuration to your project repository:"	Gofer new		url: ''http://www.example.com/ExampleRepository'';		package: ''ConfigurationOfExample'';		commit: ''Initial configuration''."Once you''ve done your initial commit, you can use the following expression to save the configuration to your project repository:"	MetacelloToolBox saveConfigurationPackageFor: ''Example'' description: ''commit message''.	"Note that MetacelloToolBox class>>saveConfigurationPackageFor:description: validates the configuration before saving."ProfStef next.'createVersion: versionString  | version |  [ version := project version: versionString ] on: MetacelloVersionDoesNotExistError do: [:ex |  | versionSpec |        versionSpec := self createVersionSpec: versionString.        version := versionSpec createVersion.        project map == nil ifTrue: [ project map: Dictionary new ].        project map at: versionString put: version ].  ^versionapplyAdd: addBlock copy: copyBlock merge: mergeBlock remove: removeBlock  self subclassResponsibilityopen10ForDevelopment  ^Lesson title: 'Open version 1.0 for development' lesson: '"	1. Create configuration		- always start a toolbox expression this way	2. Prepare to define version method #version10:		- similar expression used to create baseline method	3. Import specification from version 1.0-baseline		- specs that are not needed in a version are dropped		- import is added to pragma		- with #updateProjects set to true, the current version of the project Shout will set		- with #updatePackages set to true, the current mcz files for the packages ProfStef-Core ProfStef-Tests will be set	4. Define desired versionSpec attributes		- current author and timestamp		- set blessing to #development		- set the description		- return value of true in block, means the versionSpec is added to current method being defined	5. Compile the #version10: method		- compile and validate	6. Prepare to define symbolic version method #development:	7. Define symbolic version 		- symbolic version #development maps to version 1.0 for the #common attributes		- multiple addSymbolicSection: expressions may be used 	8. Compile the #development: method		- compile and validate"		| description |	description := ''- fixed a bug''."1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		createVersionMethod: ''version10:'' inCategory: ''versions'' forVersion: ''1.0'';"3."		importFrom: ''1.0-baseline''			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ "4."						versionSpec							author: MetacelloPlatform current authorName;							blessing: #development;							description: description;							timestamp: MetacelloPlatform current timestamp ].				true ];"5."		commitMethod;"6."		createSymbolicVersionMethod: ''development:'' inCategory: ''symbolic versions'' forVersion: #development;"7."		addSymbolicSection: #common version: ''1.0'';"8."		commitMethod."After evaluating the above expression, take a look at the generated methods:	- #version10:	- #development:"ProfStef next.'existingProjectRegistration: anObject  existingProjectRegistration := anObjecthasClassName  ^className ~~ nilbaseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec project: 'Example Project' with: [ spec                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 yourself ] ]baseline20: spec  < version: '2.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec project: 'Example Project' with: [ spec                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 yourself ] ]className: aString  self shouldBeMutable.  className := aStringspecListDo: aBlock  self list do: [:member |  aBlock value: member spec ]projectClassProject  ^self projectClass new project     setBaselineRepositoryDescription: self repositoryDescriptions;     yourselfsetUpVersionReferences  versionReferences := OrderedCollection new.  versionReferences     add: (GoferVersionReference name: 'GoferBar.branch-lr.1');     add: (GoferVersionReference name: 'GoferBar.branch-lr.2');     add: (GoferVersionReference name: 'GoferBar-jf.1');     add: (GoferVersionReference name: 'GoferBar-lr.1');     add: (GoferVersionReference name: 'GoferFoo-lr.1');     add: (GoferVersionReference name: 'GoferFoo-lr.2');     add: (GoferVersionReference name: 'GoferFoo-lr.4');     add: (GoferVersionReference name: 'GoferBeau-dkh.15');     add: (GoferVersionReference name: 'GoferBeau-dkh.25');     add: (GoferVersionReference name: 'GoferBeau-dkh.53');     add: (GoferVersionReference name: 'GoferBeau-dkh.54');     add: (GoferVersionReference name: 'GoferBeau-dkh.55');     add: (GoferVersionReference name: 'GoferBeau-dkh.56');     add: (GoferVersionReference name: 'GoferFaux-tg.30');     add: (GoferVersionReference name: 'GoferFaux-tg.31');     add: (GoferVersionReference name: 'GoferFaux-tg.32');     add: (GoferVersionReference name: 'GoferFaux-tg.33');     add: (GoferVersionReference name: 'GoferFaux-tg.34');     add: (GoferVersionReference name: 'GoferFaux-tg.35');     add: (GoferVersionReference name: 'GeauxBar.branch-lr.2');     add: (GoferVersionReference name: 'GeauxFoo-lr.1');     add: (GoferVersionReference name: 'GeauxFaux-tg.32');     add: (GoferVersionReference name: 'GeauxBeau-dkh.55');     add: (GoferVersionReference name: 'GeauxBeau-dkh.56');     add: (GoferVersionReference name: 'Issue339-JanKurs.1');     add: (GoferVersionReference name: 'Issue339-JanKurs.11');     add: (GoferVersionReference name: 'ConfigurationOfNautilusWithoutPackages-dkh.55');     add: (GoferVersionReference name: 'ConfigurationOfNautilusWithoutPackages-dkh.56');     add: (GoferVersionReference name: 'ConfigurationOfNautilusWithoutPackages-dkh.57');     add: (GoferVersionReference name: 'ConfigurationOfNautilus-dkh.56');     add: (GoferVersionReference name: 'ConfigurationOfGlamourSeaside-dkh.55');     add: (GoferVersionReference name: 'ConfigurationOfGlamourSeaside-dkh.56');     add: (GoferVersionReference name: 'ConfigurationOfGlamourSeaside-dkh.57');     add: (GoferVersionReference name: 'ConfigurationOfGlamour-dkh.56');     yourselfbaseline40Foo: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.32';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        spec           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferFaux');           yourself ]githubUser: userName project: projectName commitish: commitish path: path  | branchOrCommitOrTag |  branchOrCommitOrTag := commitish.  branchOrCommitOrTag isEmpty ifTrue: [ branchOrCommitOrTag := 'master' ].  self repository: 'github://' , userName , '/' , projectName , ':' , branchOrCommitOrTag , '/' , pathexception: anObject  exception := anObjectname  ^namepackageDo: aBlock  loadData  loadData == nil ifTrue: [ loadData := MetacelloLoadData new ].  ^loadDataparent  ^parentauthor: anObject  anObject setAuthorInMetacelloVersion: selftestVersionMergeSpec  | versionA versionB version |  versionA := self versionSpec     blessing: #baseline;     versionString: '1.0';     description: 'A description';     author: 'dkh';     timestamp: '1/24/2012 09:59';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  versionB := self versionSpec     blessing: #release;     versionString: '1.1';     description: 'A FULL description';     author: 'DaleHenrichs';     timestamp: '1/24/2012 10:22';     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  version := versionA mergeSpec: versionB.  self assert: version blessing value equals: #release.  self assert: version versionString value equals: '1.1'.  self assert: version description value equals: 'A FULL description'.  self assert: version author value equals: 'DaleHenrichs'.  self assert: version timestamp value equals: '1/24/2012 10:22'.  self assert: version preLoadDoIt value identicalTo: #preLoadDoItB.  self assert: version postLoadDoIt value identicalTo: #postLoadDoItBcreateVersionMethod: selector inCategory: category forVersion: versionString  methodSpec := MetacelloVersionMethodSpec new     project: project;     selector: selector;     category: category;     versionString: versionString;     yourselfcompareRelativeCurrentVersion: anOperator targetVersionStatus: targetVersionStatus using: anMCLoader  | cv vrsn |  (vrsn := self versionOrNil) == nil ifTrue: [ ^false ].  (cv := self relativeCurrentVersion) == nil ifTrue: [ ^false ].  (targetVersionStatus includes: cv versionStatus) ifTrue: [ ^cv perform: anOperator with: vrsn ].  ^falseprepostLoadDirectivesDo: aBlock  aBlock value: selfbaseline35ProjectFie: spec  < version: '3.5'>  spec for: #common do: [ spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.5';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Feaux' with: [ spec                 className: 'MetacelloTestConfigurationOfFeaux';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFeaux';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]validateProject: project  | hasNoBaseline hasNoVersion |  (self visited includes: project configuration class) ifTrue: [ ^self validationReport ].  self visited add: project configuration class.  hasNoBaseline := hasNoVersion := true.  project versions do: [:version |  | spec |        spec := version spec.        [ spec blessing value == #baseline ifTrue: [ hasNoBaseline := false.              self validateBaselineVersionSpec: spec ] ifFalse: [ hasNoVersion := false.              self validateVersionSpec: spec ] ] on: Error do: [:ex |  self recordValidationError: 'Error composing version ' , version versionString printString , ': ' , ex description versionString: version versionString callSite: #validateProject: reasonCode: #versionCompositionError ] ].  project symbolicVersionMap keys do: [:symbolicVersion |  | version |        version := [ project version: symbolicVersion ] on: Error , MetacelloSymbolicVersionNotDefinedError do: [:ex |  (ex isKindOf: MetacelloSymbolicVersionNotDefinedError) ifFalse: [ self recordValidationError: 'symbolic version ' , symbolicVersion printString , ' does not resolve to a literal version.' callSite: #validatePragmas reasonCode: #cannotResolveVersion ].              ex return: nil ].        version ~~ nil ifTrue: [ self validateVersionSpecForSymbolicVersion: version spec symbolicVersion: symbolicVersion ] ].  hasNoVersion ifTrue: [ hasNoBaseline ifTrue: [ self recordValidationError: 'No usable baseline or versions defined.' callSite: #validatePragmas reasonCode: #noVersionsDefined ] ifFalse: [ self recordValidationWarning: 'Only baseline defined (no version defined).' callSite: #validatePragmas reasonCode: #onlyBaselineVersion ] ].  ^self validationReportspec: aPackageSpec externalReference: anExternalReference loader: aLoader  super spec: aPackageSpec loader: aLoader.  externalReference := anExternalReferenceversion: versionString  self addStatement: #versionArg: args: {versionString}repositoryForSpec: aString username: username password: password  self root repository: aString username: username password: passwordsymbolicVersionMap  ^symbolicVersionMapnonOverridable  ^super nonOverridable , #(#packageList)scheduleFetchFor: packageSpec cachedReference: reference  ^selfversionOfMariano: spec  < version: '0.9.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>versionOfMariano:'.        spec author: 'dkh'.        spec timestamp: '5/31/2012 16:04' ].  spec for: #custom do: [ spec baseline: 'ExternalX' with: [ spec repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]versionDirectivesDo: aBlock  handleWarning: exception  ^(self options at: #onWarning ifAbsent: [ ^exception pass ]) cull: exceptiontestAddC  | repositories repository |  repositories := self repositoriesSpec.  repositories add: #('http://example.com/repository' '/opt/gemstone/repository').  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  repository := repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: '/opt/gemstone/repository'.  self assert: repository type equals: 'directory'testCachedReturn  | x |  self assert: (x := self cachedReturnOfValue) identicalTo: 6cacheRepository: anMCRepository  cacheRepository := anMCRepository.  ensuredMap := cacheGofer := nilsetAuthorWithBlock: aBlock  | spec |  (spec := self root getAuthor) == nil ifTrue: [ spec := self project valueHolderSpec.        self root setAuthor: spec ].  self with: spec during: aBlockmergeSpec: anotherSpec  | newSpec map anotherRepositories |  newSpec := super mergeSpec: anotherSpec.  map := anotherSpec mergeMap.  (anotherRepositories := map at: #repositories) ~~ nil ifTrue: [ newSpec mergeRepositoriesSpec: anotherRepositories ].  ^newSpectestVersion20  self assert: (MetacelloVersionNumber fromString: '') printString equals: ''projectForVersion: aString with: aBlockOrString  aBlockOrString setProject: aString withInMetacelloConfig: selfversionStatus: aSymbol  versionStatus := aSymbolloadUsing: aLoader gofer: gofer  ^aLoader linearLoadPackageSpec: self gofer: goferallFileNames  self flag: #review.  ^self localRepository allFileNamesresolveToAllPackagesIn: aVersionSpec into: packages visited: visited  visited visit: self doing: [:spec |  self visitingWithPackages: packages.        spec includes , spec requires do: [:pkgName |  (aVersionSpec packageNamed: pkgName) projectDo: [:prj |  (prj resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:pkg |  packages at: pkg name put: pkg ] ] packageDo: [:pkg |  packages at: pkg name put: pkg.                    (pkg resolveToAllPackagesIn: aVersionSpec visited: visited) do: [:rpkg |  packages at: rpkg name put: rpkg ] ] groupDo: [:grp |  grp resolveToAllPackagesIn: aVersionSpec into: packages visited: visited ] ] ]valueHolderSpec  ^self project valueHolderSpecbaselineRegistry  baselineRegistry ifNil: [ baselineRegistry := Dictionary new ].  ^baselineRegistryhasConflictWithProjectSpec: projectSpec  (self className beginsWith: 'BaselineOf') ifTrue: [ ^projectSpec hasConflictWithBaselineSpec: self asBaselineProjectSpec ].  ^projectSpec hasConflictWithConfigurationSpec: self asConfigurationProjectSpecextractMethodSectionsFor: sourceVersionString  | coll pragma |  coll := self extractAllVersionPragmas at: sourceVersionString ifAbsent: [ ^#() ].  coll size > 1 ifTrue: [ self error: 'More than one pragma defining ' , sourceVersionString printString ].  pragma := coll at: 1.  self evaluatePragma: pragma.  self methodSections do: [:methodSection |  self evaluateMethodSection: methodSection version: sourceVersionString ]setUpConfigurationExternalRefdkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfExternalRef-dkh.1'.  className := #ConfigurationOfExternalRef.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationExternalRef090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef090:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationExternalRef091:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef091:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfolesson11Blessing  ^Lesson title: 'Lesson 11 (Blessing)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."A version can be tagged with a blessing like #alpha, #beta, #release, #development or any other tag that you find useful. The blessing for version 1.1 is #development"	(MetacelloTutorialConfig project version: ''1.1'') blessing."The default blessing is #release, so even though we didn''t specify a blessing for version 0.5, the blessing is set:"	(MetacelloTutorialConfig project version: ''0.5'') blessing.	"For version 1.1, it is important to explicitly set the blessing, because it imports version''1.0-baseline'' whose blessing is #baseline:"	(MetacelloTutorialConfig project version: ''1.0-baseline'') blessing."Blessings can be used as a filter. For example, you will notice that the result of the following expression is version 0.6, because #stableVersion answers the latest version whose blessing is _not_ #development, #broken, or #blessing: "	MetacelloTutorialConfig project stableVersion.	MetacelloTutorialConfig project stableVersion load."The blessing of version 1.1 is #development. To find the latest #development version you would execute this expression:"	MetacelloTutorialConfig project latestVersion: #development.	(MetacelloTutorialConfig project latestVersion: #development) load."You can get the very last version independent of blessing by executing this expression:"	MetacelloTutorialConfig project bleedingEdge.	MetacelloTutorialConfig project bleedingEdge load.	"In general, the #development blessing should be used for any version that is unstable. Once a version has stabilized, a different blessing should be applied.The following expression will load the latest version of all of the packages for the latest #baseline version:"	(MetacelloTutorialConfig project latestVersion: #baseline) load."Since the latest #baseline version should reflect the most up-to-date project structure, executingthe previous expression should load the absolute bleeding edge of the project. "ProfStef next.'symbolicVersion  ^symbolicVersionensureLoadUsing: aLoader  | pp |  pp := (MetacelloLookupProjectSpec new     projectSpec: self;     yourself) signal projectPackage.  pp ifNil: [ self error: 'Unable to resolve project package for ' , self name printString , '. It is likely that that the configuration referencing this project will not validate properly (see MetacelloToolBox class>>validateConfiguration:).' ].  pp ensureLoadUsing: aLoadernewVersionForWorkingCopy: aWorkingCopy  ^aWorkingCopy newVersionIn: aWorkingCopy repositoryGroupload  (MetacelloLookupProjectSpecForLoad new     projectSpec: self;     yourself) signal performLoadhandleResolutionFor: aScriptEngine  ^aScriptEngine handleLookupBaselineSpecForEnsureLoad: selfsetUpIssue156BaselineOfGoo  | reference className definitionArray |  reference := GoferVersionReference name: 'BaselineOfGoo-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString selector: 'baselineGooIssue156Baseline:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGooIssue156Baseline:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())name: aString  super name: aString.  self projectPackage: nilvalue: anObject  self root value: anObject constructor: selfcurrentVersionInfo  | wc |  (wc := self workingCopy) ~~ nil ifTrue: [ wc ancestry ancestors isEmpty not ifTrue: [ ^wc ancestry ancestors first ] ].  ^nilrequiresSpecsForPackageOrdering: aVersionSpec  | packageOrProjectSpecs |  packageOrProjectSpecs := Set new.  self includes do: [:specName |  (aVersionSpec packageNamed: specName ifAbsent: [  ]) ifNotNil: [:pkgSpec |  packageOrProjectSpecs addAll: (pkgSpec resolveToPackagesIn: aVersionSpec andProjects: true visited: MetacelloVisitedPackages new) ] ].  ^packageOrProjectSpecspackageSpec  ^self project packageSpecconfigurationProjectSpec: anObject  self shouldBeMutable.  baselineProjectSpec := nil.  self assert: anObject isConfigurationOfProjectSpec.  configurationProjectSpec := anObjectdescriptionForVersion: aBlockOrString  aBlockOrString setDescriptionInMetacelloConfig: selfbreak  ^self allowconfigurationClass  ^self configuration classbaselineOfProjectSpecClass  ^MetacelloMCBaselineOfProjectSpecversion106ProjectToolBox: spec  < version: '1.0.6-baseline'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec repositories: [ spec                       repository: 'http://www.example.com/ob';                       repository: 'http://www.example.com/or' ] ] ]tearDown  testingEnvironment removeKey: #Metacello_Platform_Test_GlobalDictionary ifAbsent: [  ].  super tearDownmergeImportLoads: aLoadList  self error: 'import: can only be used with baseline project specs'lockConfiguration12: spec  < version: '1.2.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>lockConfiguration12: '.        spec configuration: 'ExternalX' with: [ spec repository: 'dictionary://Metacello_Config_Test_Repository' ] ]description  ^descriptionvalidate  self validatePragmas.  ^self validateProjectsetUpBaselineIssue399Cypress  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfIssue399Cypress-dkh.1'.  className := #BaselineOfIssue399Cypress.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineIssue399:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue399:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'projectClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #projectClass) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInforepositorySpec  ^self project repositorySpecprojectPackage  MCWorkingCopy managersForClass: self configuration class do: [:mgr |  | pkgSpec repo |        pkgSpec := self packageSpec           name: mgr packageName;           yourself.        mgr ancestors notEmpty ifTrue: [ pkgSpec file: mgr ancestors first name ].        repo := mgr repositoryGroup repositories detect: [:each |  each ~~ MetacelloPlatform current defaultPackageCache ] ifNone: [ MetacelloNotification signal: 'Using cache repository for ' , self label , ' project package'.              MetacelloPlatform current defaultPackageCache ].        pkgSpec repository: (repo asRepositorySpecFor: self).        ^pkgSpec ].  ^nilisLoadedToSpec  ^self spec isLoadedToSpecrecordValidationCriticalWarning: aString versionString: versionString callSite: callSite reasonCode: aSymbol  < haltOrBreakpointForTesting>  (self criticalWarningReasonCodes includes: aSymbol) ifFalse: [ self error: 'Unknown critical warning reason code' ].  ((self exludededValidations at: versionString ifAbsent: [ #() ]) includes: aSymbol) ifTrue: [ ^self ].  (self debug includes: #criticalWarning) ifTrue: [ self halt: 'Debug triggered for critical warning: ' , aString ].  self validationReport add: (MetacelloValidationCriticalWarning configurationClass: (self recurse ifTrue: [ self configurationClass ] ifFalse: [ nil ]) reasonCode: aSymbol callSite: callSite explanation: aString)visited  visited == nil ifTrue: [ visited := IdentitySet new ].  ^visitedhandleResolutionFor: aScriptEngine  ^aScriptEngine handleLock: selfancestorsFor: packageSpec  | cacheKey vi |  cacheKey := packageSpec file.  ^MetacelloPlatform current stackCacheFor: #ancestors at: cacheKey doing: [:cache |  vi := packageSpec ancestors.        cache at: cacheKey put: vi ]baseline30Fan: spec  < version: '3.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.0';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]aPackageNotLoaded: aBoolean  aPackageNotLoaded := aBooleanvisitingWithPackages: packages  packages at: self name put: selfsilently: aBool  self options at: #silently put: aBoolsetUpIssue77  self     setUpIssue77B;     setUpIssue77C;     setUpIssue77DsetUpBaselineIssue32  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfIssue32-dkh.1'.  className := #BaselineOfIssue32.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'postloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #postloadDoIt) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #preloadDoIt) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineIssue32:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue32:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfocompareWorkingCopyNamed: wcName using: comarisonOperator  | fileRef wcRef |  fileRef := GoferResolvedReference name: self file.  wcRef := GoferResolvedReference name: wcName.  ^wcRef compare: fileRef using: comarisonOperatortestIncrementDecrementVersionNumber  | version |  version := self defaultVersion1.  self assert: version incrementMinorVersionNumber asString equals: '1.0.1'.  self assert: version decrementMinorVersionNumber asString equals: '1.0.0'selector: anObject  selector := anObjectfileSystemLegacy: spec  spec package: 'FileSystemLegacy' with: [ spec           repository: 'http://smalltalkhub.com/mc/PharoExtras/FileSystemLegacy/main';           file: 'FileSystem-Legacy-JohanBrichau.2' ]silently: anObject  silently := anObjectversion: anObject  self root version: anObject constructor: selfmethodSection: methodSection do: aBlock  methodSection methodSections do: aBlock.  methodSection methodSections do: [:ms |  self methodSection: ms do: aBlock ]lesson13  ^Lesson title: 'Lesson 13' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version13:."In #version13: we are importing the ''1.2-baseline'', but changing the Example project version to 1.3, so project versions can be updated in the verson method jus like package versions.Evaluate and compare the results of these expressions:"  (MetacelloProjectRefTutorialConfig project version: ''1.2'') load: ''Project-Core''.  (MetacelloProjectRefTutorialConfig project version: ''1.3'') load: ''Project-Core''.  (MetacelloProjectRefTutorialConfig project version: ''1.2'') load: ''Project-Tests''.  (MetacelloProjectRefTutorialConfig project version: ''1.3'') load: ''Project-Tests''."It is worth noting that in version 1.3 of the Example project, the platform-specific''Example-Platform'' was introduced and nothing special had to be done in the project reference to get the package included."ProfStef next.'validateBaselineVersionSpec: versionSpec  | projectNames packageNames groupNames versionMessage |  self validateDoIts: versionSpec versionString: versionSpec versionString errorMessage: ' version ' , versionSpec versionString printString.  projectNames := Set new.  packageNames := Set new.  groupNames := Set new.  versionMessage := ' in version ' , versionSpec versionString printString.  versionSpec projectDo: [:projectSpec |  projectSpec resolveProjectSpec className == nil ifTrue: [ self recordValidationError: 'Missing required field (className:) for project reference ' , projectSpec name printString , ' in version ' , versionSpec versionString printString versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #incompleteProjectSpec ].        projectSpec resolveProjectSpec versionString == nil ifTrue: [ self recordValidationCriticalWarning: 'Missing recommended field (versionString:) for project reference ' , projectSpec name printString , ' in version ' , versionSpec versionString printString versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #missingRecommendedProjectSpecField ].        projectSpec hasRepository ifTrue: [ (self recurse and: [ projectSpec versionString ~~ nil ]) ifTrue: [ | project |                    projectSpec resolveProjectSpec ensureProjectLoaded.                    project := self validateProjectCreationFrom: projectSpec resolveProjectSpec projectClass onError: [:ex |  self recordValidationError: 'Error creating project reference: ' , ex description versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #projectCreationError.                          nil ].                    project ~~ nil ifTrue: [ self validationReport addAll: (self class validateProject: project version: projectSpec versionString debug: self debug recurse: self recurse visited: self visited) ] ] ] ifFalse: [ self recordValidationError: 'Missing required field (repository:) for project reference ' , projectSpec name printString , ' in version ' , versionSpec versionString printString versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #incompleteProjectSpec ].        self validateDoIts: projectSpec versionString: versionSpec versionString errorMessage: projectSpec name printString , versionMessage.        (projectNames includes: projectSpec name) ifTrue: [ self recordValidationError: 'Duplicate projects named' , projectSpec name printString , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #duplicateNames ] ifFalse: [ projectNames add: projectSpec name ] ] packageDo: [:packageSpec |  self validateDoIts: packageSpec versionString: versionSpec versionString errorMessage: packageSpec name printString , versionMessage.        (packageNames includes: packageSpec name) ifTrue: [ self recordValidationError: 'Duplicate packages named' , packageSpec name printString , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #duplicateNames ] ifFalse: [ projectNames add: packageSpec name ] ] groupDo: [:groupSpec |  (groupNames includes: groupSpec name) ifTrue: [ self recordValidationError: 'Duplicate groups named' , groupSpec name printString , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #duplicateNames ] ifFalse: [ projectNames add: groupSpec name ] ].  (packageNames intersection: projectNames) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between packages and projects' , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (groupNames intersection: projectNames) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between groups and projects' , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (projectNames intersection: packageNames) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between projects and packages' , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (groupNames intersection: packageNames) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between groups and packages' , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (projectNames intersection: groupNames) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between projects and groups' , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (packageNames intersection: groupNames) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between packages and groups' , versionMessage versionString: versionSpec versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ]getAuthor  ^authorhandleLookupBaselineSpecForEnsureLoad: exception  | requested registered |  requested := exception projectSpec.  registered := self lookupProjectSpecFor: exception projectSpec.  ^exception resume: (registered compareEqual: requested) notrepositoryError: anObject  repositoryError := anObjecttestMergeProjectA  | packages project projectReferenceSpec referenceSpec |  packages := self packagesSpec.  project := self projectSpec     name: 'Project';     className: 'ConfigurationOfProjectA';     versionString: #stable;     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  referenceSpec := self project projectReferenceSpec     name: project name;     projectReference: project;     yourself.  packages add: referenceSpec.  project := self projectSpec     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     operator: #<;     loads: #('MyPackage');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  referenceSpec := self project projectReferenceSpec     name: project name;     projectReference: project;     yourself.  packages merge: referenceSpec.  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  project projectDo: [:prjct |  self assert: project identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ]collectionCacheKey  | key |  key := Array with: self class with: (Array with: #x with: #y).  ^MetacelloPlatform current stackCacheFor: #collection at: key doing: [:cache |  | value |        value := cache at: #x ifAbsent: [ 0 ].        value > 5 ifTrue: [ cache at: key put: value ] ifFalse: [ value := value + 1.              cache at: #x put: value ].        self collectionCacheKey ]tearDownRepositories  super tearDownRepositories.  MCRepositoryGroup default removeIdenticalRepository: (testingEnvironment at: #Metacello_XXX_Test_Repository ifAbsent: [  ]).  testingEnvironment removeKey: #Metacello_Config_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_XXX_Test_Repository ifAbsent: [  ]incrementMajorVersion  self incrementVersionAt: 1versionArg  ^versionArgrecord: required  ^required recordRequiredForMetacelloMCVersion: selflesson11Timestamp  loadType: aSymbol  loadType := aSymbolspec  ^specprime  nonOverridable  ^super nonOverridable , #(#repositories)baseName  ^MetacelloScriptEngine baseNameOf: self classNameunregister  ^self execute: #unregister args: #()baseline60Fix: spec  < version: '6.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.35';           yourself ]version125ProjectToolBox: spec  < version: '1.2.5-baseline' imports: #('1.0-baseline')>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 preLoadDoIt: #preloadDoIt;                 postLoadDoIt: #postloadDoIt ] ]project  | constructor project |  constructor := MetacelloVersionConstructor on: self.  project := constructor project.  project loader: MetacelloNullRecordingMCSpecLoader new.  ^projectfileFromPath: aFileName relativeTo: aDirectoryPath  ^aDirectoryPath / aFileNamerepository  self deprecated: 'Use repositories or repositorySpecs'.  ^nilrecurse: anObject  recurse := anObjectloaderClass  loaderClass == nil ifTrue: [ loaderClass := self defaultLoaderClass ].  ^loaderClasssqueakfoundation: projectName  self repository: 'http://source.squeakfoundation.org/' , projectNameversion  ^nilbaseline13: spec  < version: '1.3-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/Example'.        spec           package: 'Example-Core' with: [ spec includes: #('Example-Platform') ];           package: 'Example-Tests' with: [ spec requires: 'Example-Core' ];           package: 'Example-AddOn' with: [ spec requires: 'Example-Core' ];           package: 'Example-Platform' with: [ spec requires: 'Example-Core' ];           package: 'Example-AddOnTests' with: [ spec requires: #('Example-AddOn' 'Example-Tests') ].        spec           group: 'default' with: #('Example-Core' 'Example-AddOn');           group: 'Tests' with: #('Example-Tests' 'Example-AddOnTests') ].  spec for: #gemstone do: [ spec package: 'Example-Platform' with: 'Example-Platform.gemstone' ].  spec for: #pharo do: [ spec package: 'Example-Platform' with: 'Example-Platform.pharo' ].  spec for: #squeak do: [ spec package: 'Example-Platform' with: 'Example-Platform.squeak' ]setUpConfigurationIssue84  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfIssue84-dkh.1'.  className := #ConfigurationOfIssue84.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version10Issue84:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue84:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInforesolveToPackagesIn: aVersionSpec visited: visited  | packages |  packages := Dictionary new.  self resolveToPackagesIn: aVersionSpec andProjects: false into: packages visited: visited.  ^packages values asOrderedCollectionensureLoadUsing: mcLoader  self explicitLoadUsing: mcLoader ensureSpecLoaderlinearProjectMethodSource  ^(self class sourceCodeAt: #project) asString copyReplaceAll: 'atomic' with: 'linear'repository: aString username: username password: password constructor: aVersionConstructor  aVersionConstructor repositoryForVersion: aString username: username password: passwordtestVersion17  self assert: (self versionClass fromString: '1.0') equals: (self versionClass fromString: '1.0.0').  self assert: (self versionClass fromString: '1') equals: (self versionClass fromString: '1.0').  self assert: (self versionClass fromString: '1') > (self versionClass fromString: '1-0').  self assert: (self versionClass fromString: '1') > (self versionClass fromString: '1.0-beta.0').  self assert: (self versionClass fromString: '1') > (self versionClass fromString: '1-beta.0').  self assert: (self versionClass fromString: '1') > (self versionClass fromString: '1-beta')postLoadDoIt: anObject  anObject setPostLoadDoItInMetacelloSpec: selfvisit: aSpec doing: aBlock  aSpec projectDo: [:spec |  (projects includes: spec name) ifTrue: [ ^self ].        projects add: spec name ] packageDo: [:spec |  (packages includes: spec name) ifTrue: [ ^self ].        packages add: spec name ] groupDo: [:spec |  (groups includes: spec name) ifTrue: [ ^self ].        groups add: spec name ].  aBlock value: aSpeccopyClass: oldClass as: newName inCategory: newCategoryName  self subclassResponsibilitysetUpIssue77C  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfIssue77C-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline12C:' category: 'cat' timeStamp: '' source: self baseline12MethodSourceC) .   (MCMethodDefinition className: className asString selector: 'baseline13C:' category: 'cat' timeStamp: '' source: self baseline13MethodSourceC)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())scpUrl  ^'git@github.com:' , projectPath , '.git'string: aString includesSubstring: aSubstring  ^aString includesSubString: aSubstringpackageName  ^self externalReference packageNamefetchUsing: aLoader  (MetacelloLookupProjectSpec new     projectSpec: self;     yourself) signal projectPackage fetchUsing: aLoaderprojectClass  ^MetacelloMCBaselineProjectcopyClass: oldClass as: newName inCategory: newCategoryName  | copysName class newDefinition |  copysName := newName asSymbol.  copysName = oldClass name ifTrue: [ ^oldClass ].  (Smalltalk globals includesKey: copysName) ifTrue: [ ^self error: copysName , ' already exists' ].  newDefinition := oldClass definition copyReplaceAll: '#' , oldClass name asString with: '#' , copysName asString printString.  newDefinition := newDefinition copyReplaceAll: 'category: ' , (SystemOrganization categoryOfElement: oldClass name) asString printString with: 'category: ' , newCategoryName printString.  class := self compiler     logged: true;     evaluate: newDefinition.  class class instanceVariableNames: oldClass class instanceVariablesString.  class copyAllCategoriesFrom: oldClass.  class class copyAllCategoriesFrom: oldClass class.  class category: newCategoryName.  ^classconfigurationOfProjectSpec  ^self configurationOfProjectSpecClass for: selfcreatePackageSpec: baseName  ^project packageSpec     name: baseName;     yourselfbaseName  ^self projectSpec baseNameoverrideProjectSpec: anObject  overrideProjectSpec := anObjectprojectSpecForClassNamed: aClassName ifAbsent: absentBlock  ^(self configurationRegistry at: aClassName ifAbsent: [ ^(self baselineRegistry at: aClassName ifAbsent: [ ^absentBlock value ]) baselineProjectSpec ]) configurationProjectSpecversionNumberClass: aClass  versionNumberClass := aClassdecrementMajorVersion  self decrementNormalVersionAt: 1updatePackageRepositoriesFor: aVersionSpec  ^trueonConflictUseIncoming  self onConflict: [:ex :loaded :incoming |  ex useIncoming ]mergeSpec: anotherSpec  | newSpec map anotherPackages |  newSpec := super mergeSpec: anotherSpec.  map := anotherSpec mergeMap.  (anotherPackages := map at: #packageList) isEmpty not ifTrue: [ newSpec packages: (self packages isEmpty ifTrue: [ anotherPackages ] ifFalse: [ self packages mergeSpec: anotherPackages ]) ].  ^newSpecversion40Issue119: spec  < version: '4.0' imports: #('4.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '2.0'.        spec package: 'GoferBar' with: 'GoferBar-jf.1' ]basicSpec  ^self specbaseline10MethodSourceB  ^(self class sourceCodeAt: #baseline10B:) asStringcurrentlyLoadedClassesInProject  ^self projectSpec currentlyLoadedClassesInVersion asSetgetRepositories  ^repositoriesincrementMinorVersionNumber  self incrementNormalVersionAt: 3isBaselineOfProjectSpec  ^falsevalidateLocalRepository  | dir |  dir := self calculateRepositoryDirectory.  (dir = localRepository directory and: [ MCFileTreeFileUtils current directoryExists: dir ]) ifTrue: [ ^self ].  self flushCache.  self resolveLocalRespositoryversionString  ^self projectReference versionStringcreateSymbolicVersionMethod: selector inCategory: category forVersion: versionSymbol  | constructor |  methodSpec := MetacelloSymbolicVersionMethodSpec new     project: project;     selector: selector;     category: category;     versionString: versionSymbol;     yourself.  constructor := self constructor.  self methodSpec methodSections: (constructor extractSymbolicVersionSpecsFor: versionSymbol) asOrderedCollectionversion135ProjectToolBox: spec  < version: '1.3.5' imports: #('1.2.4-baseline')>  spec for: #common do: [ spec repositories: [ spec                 repository: 'http://www.example.com/ab';                 repository: 'http://www.example.com/ac' ] ]createConfigurationAndBaseline  ^Lesson title: '1. Create configuration' lesson: '"The MetacelloToolBox class provides programmatic support for creating and maintaining your configuration. Use the following expression to create your configuration class and initial baseline version. Edit the expression to specifiy the required projects, packages, dependencies and groups for your project:"		MetacelloToolBox		createBaseline: ''1.0-baseline''		for: ''Example''		repository: ''http://www.squeaksource.com/ProfStef''		requiredProjects: #(''Shout'')		packages: #(''ProfStef-Core'' ''ProfStef-Tests'')		dependencies:			{(''ProfStef-Core'' -> #(''Shout'')).			(''ProfStef-Tests'' -> #(''ProfStef-Core''))}		groups:			{(''default'' -> #(''Core'')).			(''Core'' -> #(''ProfStef-Core'')).			(''Tests'' -> #(''ProfStef-Tests'')).			(''Core Tests'' -> #(''Core'' ''Tests''))}.			"After evaluating the above expression, browse the configuration:"	Smalltalk tools browser openOnClass: ConfigurationOfExample selector: #baseline10:.	"Edit the #baseline10 method in the browser to fine tune the baseline specification."ProfStef next.'baseline07: spec  < version: '0.7-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/Example'.        spec           package: 'Example-Core';           package: 'Example-Tests' with: [ spec requires: 'Example-Core' ];           package: 'Example-AddOn' with: [ spec requires: 'Example-Core' ] ]repositoriesForVersion: aBlock  self repositoriesForSpec: aBlockversionSpec: anObject  versionSpec := anObjectsetUpBaselineGithubReferenceXI  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfGithubRefXI-dkh.1'.  className := #BaselineOfGithubRefXI.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'configurationGithubReferenceV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceV:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfohasNoPackage  ^hasNoPackageoptions  options ifNil: [ options := Dictionary new ].  ^optionscanDowngradeTo: aProjectRegistration  (self hasLoadConflicts: aProjectRegistration) ifFalse: [ ^true ].  configurationProjectSpec ifNotNil: [ aProjectRegistration configurationProjectSpec ifNotNil: [ configurationProjectSpec ensureProjectLoaded.              ^configurationProjectSpec canDowngradeTo: aProjectRegistration configurationProjectSpec ] ].  ^falsegroups  ^(self optionAt: 'groups') splitOn: $,isAllLoadedToSpec  ^self spec isAllLoadedToSpec