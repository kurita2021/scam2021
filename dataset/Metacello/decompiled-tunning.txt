atomicLoadPackageSpecs: arg1 repositories: arg2  self loaderPolicy pushAtomicLoadDirectivesDuring: [ super linearLoadPackageSpecs: arg1 repositories: arg2 ] for: selfname  ^namedo: arg1 displaying: arg2  self bypassProgressBars ifTrue: [ ^super do: arg1 displaying: arg2 ].  arg2 displayProgressFrom: 0 to: 2 during: [:arg3 |  arg3 value: 1.        arg1 value.        arg3 value: 2 ]baselineForVersion: arg1 with: arg2  arg2 setBaseline: arg1 withInMetacelloConfig: selflist  actionArg := #list -> #().  self singleRoot: falseexpectedPrintString  ^'spec blessing: #''baseline''.spec description: ''Descriptive comment''.spec preLoadDoIt: #''preloadForVersion''.spec postLoadDoIt: #''postloadForVersion''.spec author: ''dkh''.spec timestamp: ''10/7/2009 14:40''.spec repositories: [	spec		repository: ''/opt/mc/repository'';		repository: ''c:\pharo\myapp\repo\'';		repository: ''dictionary://GlobalName'';		repository: ''ftp://ftp.example.com/repo'';		repository: ''http://www.example.com/ar'';		repository: ''http://www.example.com/private'' username: ''foo'' password: ''bar'';		repository: ''http://www.example.com/rr'' ].spec 	project: ''UI Support'' with: [		spec			className: ''ConfigurationOfUI'';			versionString: ''1.0'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			operator: #''~>'';			loads: #(''UI-Core'' );			repository: ''http://www.example.com/r'' ];	project: ''UI Support'' overrides: [		spec			className: ''ConfigurationOfUINew'';			versionString: ''1.0'';			operator: #''>='';			loads: #(''UI-Core'' ''UI-Tests'' );			repository: ''http://www.example.com/r'' username: ''foo'' password: ''bar'' ];	project: ''UI Tests'' copyFrom: ''UI Support'' with: [		spec			className: ''ConfigurationOfUI'';			versionString: ''1.0'';			operator: #''~>'';			loads: #(''UI-Core'' ''UI-Tests'' );			repository: ''http://www.example.com/r'' ];	project: ''UI Support'' with: ''1.0.1'';	removeProject: ''UI Tests'';	project: ''UI Multi'' with: [		spec			className: ''ConfigurationOfMulti'';			repository: ''http://www.example.com/r'';			repository: ''http://www.example.com/s'' ].spec 	package: ''Example-AddOn'' with: [		spec 			requires: #(''Example-Core'' );			includes: #(''Example-UI'' );			file: ''Example-AddOn-anon.3'';			repositories: [				spec					repository: ''http://www.example.com/yar'';					repository: ''http://www.example.com/yas'' ];			preLoadDoIt: #''preloadForAddOn'';			postLoadDoIt: #''postloadForAddOn''. ];	package: ''Example-AddOn'' overrides: [		spec 			requires: #(''Example-Core'' ''UI Support'' );			includes: #(''Example-UI'' );			supplyingAnswers: #( #( ''list of packages'' ''Kernel* Collection*'' ) );			file: ''Example-AddOn-anon.7'';			repository: ''http://www.example.com/or'' username: ''foo'' password: ''bar'';			preLoadDoIt: #''preloadForAddOn'';			postLoadDoIt: #''postloadForAddOn''. ];	package: ''Example-AddOn'' with: ''Example-AddOn-anon.5'';	package: ''Example-Core'';	package: ''Example-Tests'' with: [		spec requires: #(''Example-Core'' ). ];	package: ''Example-TestsUI'' with: [		spec requires: #(''Example-UI'' ). ];	package: ''Example-UI'' with: [		spec requires: #(''Example-AddOn'' ). ];	removePackage: ''Example-Tests''.spec 	group: ''default'' with: #(''Example-Core'' ''Example-AddOn'' );	group: ''default'' overrides: #(''Example-Core'' ''Example-Tests'' );	removeGroup: ''default''.'file: arg1  self shouldBeMutable.  file := arg1.  self projectPackage: nilversion13: arg1  < version: '1.3' imports: #('1.3-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'Add in doits for Example-Core'.        arg1 author: 'dkh'.        arg1 timestamp: '10/13/2009 14:27'.        arg1           package: 'Example-Core' with: 'Example-Core-anon.17';           package: 'Example-Tests' with: 'Example-Tests-anon.6';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ].  arg1 for: #gemstone do: [ arg1 package: 'Example-Platform' with: 'Example-Platform.gemstone-dkh.4' ].  arg1 for: #pharo do: [ arg1 package: 'Example-Platform' with: 'Example-Platform.pharo-dkh.7' ].  arg1 for: #squeak do: [ arg1 package: 'Example-Platform' with: 'Example-Platform.squeak-dkh.3' ]configuration091Issue63: arg1  < version: '0.9.1'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration091Issue63:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           import: 'External' ]monticelloRepository  ^monticelloRepositoryonUpgrade: arg1  self addStatement: #onUpgrade: args: {arg1}updatePackageSpec: arg1 using: arg2  self updatePackageSpec: arg1 force: false using: arg2testMergePackageA  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp1 merge: (self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           includes: 'AndIncludedPackage';           answers: #(#('xpostload' 'xpostload answer'));           file: 'Package-dkh.2';           yourself).  tmp2 := tmp1 packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: tmp2 name equals: 'Package'.  self assert: tmp2 requires equals: #('AnotherPackage' 'AndAnotherPackage').  self assert: tmp2 includes equals: #('IncludedPackage' 'AndIncludedPackage').  self assert: tmp2 answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer') #('xpostload' 'xpostload answer')).  self assert: tmp2 file equals: 'Package-dkh.2'.  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoItsetUpConfigurationOfProjectIssue119dkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.2'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion20Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4loaderPolicy: arg1  loaderPolicy := arg1postLoadDoIt  ^postLoadDoItload: arg1 onProjectDownGrade: arg2 onProjectUpgrade: arg3  MetacelloProjectRegistration copyRegistryRestoreOnErrorWhile: [ self handleNotificationsForAction: [ | tmp1 tmp2 |              self setDefaultsAndValidateProjectSpec.              [ tmp2 := (self lookupProjectSpecFor: self projectSpec) copy ] on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade do: [:arg4 |  arg4 handleOnDownGrade: arg2 onUpgrade: arg3 ].              tmp1 := tmp2 versionForScriptEngine: self.              self root: (arg1 isEmpty ifTrue: [ tmp1 load ] ifFalse: [ tmp1 load: arg1 ]) loadDirective.              tmp2 loads: arg1.              MetacelloProjectRegistration registrationForProjectSpec: tmp2 ifAbsent: [:arg5 |  arg5                       loadedInImage: true;                       registerProject ] ifPresent: [:arg6 :arg5 |  arg6 copyOnWrite: [:arg7 |  arg7                             loadedInImage: true;                             merge: arg5 ] ] ] ]version132ProjectToolBox: arg1  < version: '1.3.2-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository' ].  arg1 for: #level1_1 do: [ arg1 package: 'GoferBeau' with: 'GoferBeau-dkh.15'.        arg1 for: #level2_1 do: [ arg1 package: 'GoferBeau' with: 'GoferBeau-dkh.25'.              arg1 for: #level3_1 do: [ arg1 package: 'GoferBeau' with: 'GoferBeau-dkh.53' ] ].        arg1 for: #level2_2 do: [ arg1 package: 'GoferBeau' with: 'GoferBeau-dkh.54'.              arg1 for: #level3_2 do: [ arg1 package: 'GoferBeau' with: 'GoferBeau-dkh.55' ] ] ]setUpConfigurationOfProjectIssue283  | tmp1 |  tmp1 := self setUpConfigurationOfProjectIssue283dkh1.  tmp1 := self setUpConfigurationOfProjectIssue283dkh2: {tmp1}.  self setUpConfigurationOfProjectConfigIssue283dkh1do: arg1 separatedBy: arg2  | tmp1 |  tmp1 := true.  self do: [:arg3 |  tmp1 ifTrue: [ tmp1 := false ] ifFalse: [ arg2 value ].        arg1 value: arg3 ]mapCopy: arg1 into: arg2  | tmp1 |  tmp1 := arg2 at: arg1 sourceName ifAbsent: [  ].  tmp1 == nil ifTrue: [ ^self error: 'Source spec named ' , arg1 sourceName printString , ' not found' ] ifFalse: [ tmp1 aboutToCopy.        arg2 at: arg1 name put: (tmp1 copy mergeSpec: arg1 spec copy) ]description  ^'The symbolic version ' , self versionString printString , ' is not defined in ' , self project label , ' for the current platform. Possible symbolic version values include: ' , self possibleVersions printStringdirectivesDo: arg1  arg1 value: self.  self loadDirectives do: [:arg2 |  arg2 directivesDo: arg1 ]handleResolutionFor: arg1  ^arg1 handleUpgrade: selfvalidatePragmas  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self extractVersionPragmas.  tmp2 := self extractVersionImportPragmas.  tmp3 := self extractSymbolicVersionPragmas.  tmp4 := Set new.  tmp1 keys , tmp2 keys , tmp3 keys do: [:arg1 |  (tmp4 includes: arg1) ifTrue: [ self recordValidationCriticalWarning: 'version ' , arg1 printString , ' is defined multiple times.' versionString: arg1 callSite: #validatePragmas reasonCode: #duplicateVersionDefinitions ] ifFalse: [ tmp4 add: arg1 ] ].  tmp1 keysAndValuesDo: [:arg1 :arg2 |  arg1 isString ifFalse: [ self recordValidationError: 'version ' , arg1 printString , ' is not a String.' versionString: arg1 callSite: #validatePragmas reasonCode: #invalidVersionString ].        arg2 size > 1 ifTrue: [ self recordValidationCriticalWarning: 'version ' , arg1 printString , ' is defined multiple times.' versionString: arg1 callSite: #validatePragmas reasonCode: #duplicateVersionDefinitions ] ].  tmp3 keysAndValuesDo: [:arg1 :arg2 |  arg1 isSymbol ifFalse: [ self recordValidationError: 'symbolic version ' , arg1 printString , ' is not a Symbol.' versionString: arg1 callSite: #validatePragmas reasonCode: #invalidVersionString ].        arg2 size > 1 ifTrue: [ self recordValidationCriticalWarning: 'version ' , arg1 printString , ' is defined multiple times.' versionString: arg1 callSite: #validatePragmas reasonCode: #duplicateVersionDefinitions ] ].  tmp2 keysAndValuesDo: [:arg1 :arg2 |  arg1 isString ifFalse: [ self recordValidationError: 'version ' , arg1 printString , ' is not a String.' versionString: arg1 callSite: #validatePragmas reasonCode: #invalidVersionString ].        arg2 size > 1 ifTrue: [ self recordValidationCriticalWarning: 'version ' , arg1 printString , ' is defined multiple times.' versionString: arg1 callSite: #validatePragmas reasonCode: #duplicateVersionDefinitions ].        arg2 do: [:arg3 |  (arg3 arguments at: 2) do: [:arg4 |  (tmp4 includes: arg4) ifFalse: [ self recordValidationError: 'version ' , arg4 printString , ' referenced in import list of version ' , arg1 printString , ' has not been defined.' versionString: arg1 callSite: #validatePragmas reasonCode: #missingVersionImport ] ] ] ]repositoryString  | tmp1 |  tmp1 := ''.  self repositories do: [:arg1 |  tmp1 := tmp1 , ' ' , arg1 description ].  ^tmp1stableVersion283B: arg1  < symbolicVersion: #stable>  arg1 for: #common version: '2.1'testIncrementDecrementVersion  | tmp1 |  tmp1 := self defaultVersion1.  self assert: tmp1 incrementMajorVersion asString equals: '2.0.0'.  self assert: tmp1 decrementMajorVersion asString equals: '1.0.0'.  self assert: tmp1 incrementMinorVersion asString equals: '1.1.0'.  self assert: tmp1 decrementMinorVersion asString equals: '1.0.0'.  self assert: tmp1 incrementPatchVersion asString equals: '1.0.1'.  self assert: tmp1 decrementPatchVersion asString equals: '1.0.0'postLoadDoItForProject: arg1  self postLoadDoItForSpec: arg1hasPackage: arg1  ^MCWorkingCopy allManagers anySatisfy: [:arg2 |  arg2 packageName = arg1 ]exception  ^exceptionsetUpDependency  | tmp1 |  tmp1 := GoferVersionReference name: 'GoferUmbrella-dkh.4'.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) with: (MCClassDefinition name: (tmp1 packageName copyWithout: $-) asSymbol superclassName: #Object category: tmp1 packageName asSymbol instVarNames: #() comment: ''))) dependencies: (Array with: (MCVersionDependency package: (MetacelloTestsMCPackage new name: 'GoferBarDependency') info: (monticelloRepository versionInfoFromVersionNamed: 'GoferBarDependency-lr.30')) with: (MCVersionDependency package: (MetacelloTestsMCPackage new name: 'GoferFooDependency') info: (monticelloRepository versionInfoFromVersionNamed: 'GoferFooDependency-lr.30'))))loader  ^loaderbaselineGithubReferenceVII: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>baselineGithubReferenceVII:'.        arg1           baseline: 'External Core' with: [ arg1                 className: 'BaselineOfExternal';                 loads: 'Core';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           project: 'External Tests' copyFrom: 'External Core' with: [ arg1 loads: 'Tests' ] ]project  | tmp1 tmp2 |  tmp1 := MetacelloVersionConstructor on: self.  tmp2 := tmp1 project.  tmp2 loader: (tmp2 loaderClass new           shouldDisablePackageCache: true;           yourself).  tmp2 loadType: self loadType.  ^tmp2projectSpecSelectBlock  ^[:arg1 |  arg1 notNil ]repositoryBranchName  ^self projectVersionloadedInImage  loadedInImage ifNil: [ loadedInImage := false ].  ^loadedInImageversions  ^[ {self version} ] on: MetacelloVersionDoesNotExistError do: [:arg1 |  ^#() ]importForVersion: arg1  self root import: arg1includeSpecNamesForPackageOrdering: arg1  ^#()testVersionSpecCreateVersion  | tmp1 tmp2 |  tmp1 := self versionSpec     blessing: #baseline;     versionString: '1.0';     description: 'A description';     author: 'dkh';     timestamp: '1/24/2012 09:59';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  tmp2 := tmp1 createVersion.  self assert: tmp2 class identicalTo: tmp1 versionClass.  self assert: tmp2 spec identicalTo: tmp1.  self assert: tmp2 versionNumber asString equals: '1.0'.  self assert: tmp2 blessing equals: #baseline.  self assert: tmp2 versionString equals: '1.0'.  self assert: tmp2 description equals: 'A description'.  self assert: tmp2 author equals: 'dkh'.  self assert: tmp2 timestamp equals: '1/24/2012 09:59'isPackageLoaded  ^self isPackageLoaded: self loaderunstableVersionOfX: arg1  < symbolicVersion: #unstable>  arg1 for: #common version: '0.9.1'mergeSpec: arg1  ^super mergeSpec: arg1 asConfigurationProjectSpecversion110ProjectToolBox: arg1  < version: '1.1.0-baseline'>  arg1 for: #common do: [ arg1           package: 'Example-Core';           package: 'Example-Base';           package: 'Example-Test1' with: [ arg1                 requires: #('Example-Base');                 includes: #('Example-Core') ];           package: 'Example-Test2' with: [ arg1                 includes: #('Example-Core');                 supplyingAnswers: #(#('captionMatch' 'answer')) ];           package: 'Example-Test3' with: [ arg1                 requires: #('Example-Base');                 supplyingAnswers: #(#('captionMatch' 'answer')) ];           package: 'Example-Test4' with: [ arg1                 requires: #('Example-Base');                 includes: #('Example-Core');                 supplyingAnswers: #(#('captionMatch' 'answer')) ] ]testSelfHostedLocationWithNonDefaultSSHPort  | tmp1 |  tmp1 := MCGitlabRepository location: 'gitlab://git.pharo.org:1234:pharo-project/pharo:master/src'.  self     assert: tmp1 hostname equals: 'git.pharo.org';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assert: tmp1 repoPath equals: 'src';     assert: tmp1 sshPort equals: '1234'.  tmp1 := MCGitlabRepository location: 'gitlab://git.pharo.org:1234:pharo-project/pharo:master'.  self     assert: tmp1 hostname equals: 'git.pharo.org';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assertEmpty: tmp1 repoPath;     assert: tmp1 sshPort equals: '1234'.  tmp1 := MCGitlabRepository location: 'gitlab://git.pharo.org:1234:pharo-project/pharo'.  self     assert: tmp1 hostname equals: 'git.pharo.org';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assertEmpty: tmp1 repoPath;     assert: tmp1 sshPort equals: '1234'configMethodOn: arg1 indent: arg2  arg1     tab: arg2;     nextPutAll: 'spec value: ' , self value printStringrepositoryForSpec: arg1  self root repository: arg1baseline35MethodSourceFoo  ^(self class sourceCodeAt: #baseline35Foo:) asStringsetBlessingWithBlock: arg1  | tmp1 |  (tmp1 := self root getBlessing) == nil ifTrue: [ tmp1 := self project valueHolderSpec.        self root setBlessing: tmp1 ].  self with: tmp1 during: arg1locked: arg1  self shouldBeMutable.  locked := arg1baselineGoo400Issue156Configuration: arg1  < version: '4.0.0'>  arg1 for: #common do: [ arg1           baseline: 'Goo' with: [ arg1 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           import: 'Goo' ]includes: arg1 constructor: arg2  arg2 includesForPackage: arg1packageSpecClass  MetacelloCypressBaselineProject useCypressPackagesForAllBaselines ifTrue: [ ^MetacelloCypressPackageSpec ].  ^super packageSpecClasssetUpIssue399CoreSampledkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'Issue399-Core-dkh.2'.  tmp2 := #Issue399Sample.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp1 packageName instVarNames: #() comment: '')}.  sampleRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4testMergeB  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     merge: 'http://example.com/repository'.  tmp2 := tmp1 map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: 'http://example.com/repository'.  self assert: tmp2 type equals: 'http'.  self assert: tmp2 username equals: 'dkh'.  self assert: tmp2 password equals: 'password'project: arg1  project ifNil: [ self class ensureMetacello ].  project := arg1version06: arg1  < version: '0.6'>  arg1 for: #common do: [ arg1 repository: 'http://www.example.com/Example'.        arg1           package: 'Example-Core' with: 'Example-Core-anon.12';           package: 'Example-Tests' with: [ arg1                 file: 'Example-Tests-anon.3';                 requires: 'Example-Core' ];           package: 'Example-AddOn' with: [ arg1                 file: 'Example-AddOn-anon.1';                 requires: 'Example-Core' ] ]baselineIssue215: arg1  < baseline>  arg1 for: #common do: [ arg1 description: self className , '>>baselineGithubReferenceV:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           import: 'External' provides: #('External-Core' 'External-Tests') ]externalAuthorName  ^'dkh'ensuredMap  ^self loaderPolicy ensuredMaplesson11Descripton  projectVersionPattern: arg1  projectVersionPattern := arg1afterLoads  afterLoads == nil ifTrue: [ afterLoads := OrderedCollection new ].  ^afterLoadssetUpExternalCore  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'External-Core-dkh.1'.  tmp2 := #ExternalCore.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'externalAuthorName' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalAuthorName) asString) .   (MCMethodDefinition className: 'Object' classIsMeta: true selector: 'isExternal' category: '*external-core' timeStamp: '' source: (self class sourceCodeAt: #isExternal) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4spawnPackageMethodIn: arg1 category: arg2 named: arg3 sourceVersion: arg4 targetVersion: arg5 blessing: arg6  self deprecated: 'see MetacelloToolBox class>>createBaseline:for:from:description: for replacement method'.  self prepareForMethodUpdate: arg1 sourceVersion: arg4 forceUpdate: arg6 ~~ #baseline generating: [:arg7 :arg8 :arg9 :arg10 |  | tmp1 |        tmp1 := WriteStream on: String new.        tmp1           nextPutAll: arg3 asString , ' spec';           cr;           tab;           nextPutAll: '<version: ' , arg5 printString , ' imports: #(' , arg4 printString , ')>';           cr.        (arg9 at: 2) do: [:arg11 |  | tmp2 tmp3 |              tmp2 := (arg9 at: 1) at: arg11.              (tmp3 := arg10 at: arg11 ifAbsent: [  ]) ~~ nil ifTrue: [ tmp2 packagesSpec list do: [:arg12 |  | tmp4 |                          tmp4 := tmp3 at: arg12 spec name ifAbsent: [  ].                          arg12 spec updateForSpawnMethod: tmp4 ] ] ifFalse: [ tmp2 packagesSpec list do: [:arg12 |  arg12 spec updateForSpawnMethod: arg12 spec copy ] ].              tmp1                 cr;                 tab;                 nextPutAll: 'spec for: ' , arg11 printString , ' do: [';                 cr.              arg11 == #common ifTrue: [ tmp2                       author: MetacelloPlatform current authorName;                       timestamp: MetacelloPlatform current timestamp.                    arg6 ~~ nil ifTrue: [ tmp2 blessing: arg6 ] ].              tmp2 configSpawnMethodOn: tmp1 indent: 2.              tmp1 nextPutAll: '].' ].        (arg1 class compile: tmp1 contents classified: arg2) == nil ifTrue: [ self error: 'Error compiling the method' ] ].  ^truetestRemoveGroupA  | tmp1 tmp2 tmp3 |  tmp1 := self packagesSpec.  tmp1 add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  tmp1 merge: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself).  tmp2 := tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (tmp2 includes includes: 'Core').  self assert: (tmp2 includes includes: 'Tests').  tmp1 remove: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  tmp3 := false.  tmp1 packageNamed: 'Platform' ifAbsent: [ tmp3 := true ].  self assert: tmp3editVersionSpecsForImport: arg1 projectAttributes: arg2 active: arg3 fullVersionSpec: arg4 updateProjects: arg5 updatePackages: arg6 visited: arg7 updated: arg8  | tmp1 tmp2 |  tmp1 := Bag new.  tmp2 := Bag new.  arg1 methodSectionsInEvaluationOrder: arg2 reverse do: [:arg9 |  arg9 versionSpec specListProjectDo: [:arg10 |   ] packageDo: [:arg10 |  tmp2 add: arg10 name.              (arg10 copy updateForSpawnMethod: arg10) ifFalse: [ tmp1 add: arg10 name ] ] groupDo: [:arg10 |   ] ].  arg1 methodSectionsInEvaluationOrder: arg2 reverse do: [:arg9 |  | tmp3 tmp4 tmp5 |        tmp3 := arg9 versionSpec.        tmp4 := arg9 attributePath.        tmp3 updateForSpawnMethod: tmp3.        tmp5 := OrderedCollection new.        tmp3 specListProjectDo: [:arg10 |  arg10 updateForSpawnMethod: arg10 ] packageDo: [:arg10 |  tmp2 remove: arg10 name.              (arg10 updateForSpawnMethod: arg10) ifTrue: [ ((tmp1 includes: arg10 name) or: [ tmp2 includes: arg10 name ]) ifTrue: [ tmp5 add: arg10 ] ifFalse: [ arg10 file: arg10 name.                          tmp1 add: arg10 name ] ] ifFalse: [ (tmp1 occurrencesOf: arg10 name) > 1 ifTrue: [ tmp5 add: arg10.                          tmp1 remove: arg10 name ] ] ] groupDo: [:arg10 |  arg10 updateForSpawnMethod: arg10 ].        tmp5 do: [:arg10 |  tmp3 deleteSpec: arg10 ].        arg3 ifTrue: [ self updateVersionSpec: tmp3 fullVersionSpec: arg4 updateProjects: arg5 updatePackages: arg6 visited: arg7 updated: arg8 ] ifFalse: [ self clearVersionSpec: tmp3 fullVersionSpec: arg4 updateProjects: arg5 updatePackages: arg6 ] ]externalPath  ^'metacello-tests/external'projectName: arg1  self shouldBeMutable.  projectName := arg1execute: arg1 args: arg2  | tmp1 |  tmp1 := self statements copy.  tmp1 add: arg1 -> arg2.  ^self scriptExecutor execute: tmp1debug: arg1  debug := arg1configurationGithubReferenceX: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configurationGithubReferenceX:'.        arg1 project: 'External' with: [ arg1                 className: 'ConfigurationOfExternal';                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]projectName  ^self subclassResponsibilitytearDownPackageList  ^#('ConfigurationOfExternalX' 'ConfigurationOfExternalXX' 'ConfigurationOfExternal' 'ConfigurationOfExternalXXX' 'ConfigurationOfExternalIV' 'ConfigurationOfExternalIV' 'BaselineOfExternalX' 'BaselineOfGithubRefXX' 'BaselineOfGithubRefIV' 'BaselineOfGithubRefV' 'BaselineOfGithubRefVI' 'BaselineOfGithubRefVII' 'BaselineOfExternal' 'BaselineOfExternalX' 'External-CoreX' 'Sample-CoreX' 'ConfigurationOfMetacelloExample' 'GoferFoo' 'Sample-Core' 'Sample-Platform' 'Sample-Tests' 'External-Core' 'ExternalCore' 'External-Tests' 'BaselineOfGithubRefVIII' 'BaselineOfGithubRefIX' 'MarianosImage' 'BaselineOfGithubRefXI' 'BaselineOfGithubRefXII' 'BaselineOfGithubRefXIII')file: arg1 constructor: arg2  arg2 fileForProject: arg1baseline40MethodSourceFoo  ^(self class sourceCodeAt: #baseline40Foo:) asStringtransact: arg1  arg1 valueprojectTagsUrlFor: arg1  ^'https://api.github.com/repos/' , arg1 , '/tags'introductionText  ^'Convers basic Metacello configuration specifications:	1. Open a code browser on the MetacelloTutorialConfig class:"		MetacelloTutorialConfig browse.	"2. In the browser view the ''--all--'' category.	3. Have fun!"'versionNumberFrom: arg1  ^self versionNumber class fromString: arg1updateForSpawnMethod: arg1  repositories := preLoadDoIt := postLoadDoIt := nilhasPackage: arg1  ^MCWorkingCopy allManagers anySatisfy: [:arg2 |  arg2 packageName = arg1 ]tempFileFor: arg1 suffix: arg2  ^'/tmp/' , arg1 , arg2reenableUndefinedSybolUpdates: arg1  lesson11  fetch: arg1  ^arg1 fetchRequiredForMetacelloMCVersion: selfupdatePackageSpec: arg1 force: arg2 using: arg3  | tmp1 |  (arg2 not and: [ self getFile == nil ]) ifTrue: [ ^self ].  (tmp1 := self workingCopyNameFor: arg3) == nil ifTrue: [ ^self ].  tmp1 ~= self file ifTrue: [ | tmp2 |        tmp2 := self copy.        tmp2 file: tmp1.        arg1 at: tmp2 name put: tmp2 ] ifFalse: [ arg1 at: self name put: #uptodate ]onDowngradeUseIncoming  self onDowngrade: [:arg1 :arg2 :arg3 |  arg1 useIncoming ]currentlyLoadedClassesInVersion  | tmp1 |  tmp1 := Set new.  self projectDo: [:arg1 |   ] packageDo: [:arg2 |  | tmp2 |        tmp2 := [ arg2 workingCopy ] on: Error do: [:arg3 |  arg3 return: nil ].        tmp2 ~~ nil ifTrue: [ tmp1 addAll: (MetacelloPlatform current packageInfoFor: tmp2) classes ] ] groupDo: [:arg1 |   ].  ^tmp1projectClass  ^MetacelloMCProjectrepositoryMap  ^self loaderPolicy repositoryMappreLoad: arg1  | tmp1 |  (tmp1 := arg1 preLoadDoItBlock) ~~ nil ifTrue: [ tmp1 valueWithPossibleArgs: {self .               arg1} ]list  ^self execute: #list args: #()version10NestedIssue84: arg1  < version: '1.0.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>version10NestedIssue84:'.        arg1 author: 'dkh'.        arg1 timestamp: '7/24/2012 19:23'.        arg1 repository: 'dictionary://Metacello_Configuration_Test_Repository'.        arg1 package: 'External-CoreX' ]extractMethodSectionsFor: arg1  self shouldNotImplementgtInspectorCodeIn: arg1  < gtInspectorPresentationOrder: 40>  arg1 pharoScript     title: 'Code';     display: [ String streamContents: [:arg2 |  self configMethodOn: arg2 indent: 0 ] ]setPostLoadDoItInMetacelloSpec: arg1  arg1 setPostLoadDoIt: selflinearLoadPackageSpec: arg1 gofer: arg2  self subclassResponsibilitypackageNames  packageList == nil ifTrue: [ ^#() ].  ^self packages map keys asSetprojectSpec: arg1  projectSpec := arg1defaultAction  self checkAllowed.  ^self newProjectRegistrationbleedingEdge206A: arg1  < symbolicVersion: #bleedingEdge>  arg1 for: #common version: '2.0'list: arg1  list := arg1.  self clearMemberMapprojectSpec  ^projectSpecsetUpConfigurationNextedIssue84  | tmp1 |  tmp1 := self setUpConfigurationNextedIssue84dkh1.  self setUpConfigurationNextedIssue84dkh2: {tmp1}repositoriesFrom: arg1  ^self repositoriesFrom: arg1 ignoreOverrides: falsetestAddProjectB  | tmp1 tmp2 tmp3 |  tmp1 := self packagesSpec.  tmp1 add: {(self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself) .         (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself)}.  tmp3 := tmp1 packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: tmp3 projectName equals: 'Project'.  self assert: tmp3 versionString equals: '1.0'.  self should: [ tmp3 includes: #() ] raise: Error.  self should: [ tmp3 requires: #() ] raise: Error.  self should: [ tmp3 answers: #() ] raise: Error.  tmp3 projectDo: [:arg1 |  self assert: tmp3 identicalTo: arg1 ] packageDo: [:arg2 |  self assert: false ] groupDo: [:arg2 |  self assert: false ].  tmp2 := tmp3 referencedSpec.  self assert: tmp2 name equals: 'Project'.  self assert: tmp2 className equals: 'ConfigurationOfProject'.  self assert: tmp2 versionString equals: '1.0'.  self assert: tmp2 operator identicalTo: #<.  self assert: tmp2 loads equals: #('MyPackage').  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoIt.  tmp2 projectDo: [:arg1 |  self assert: tmp2 identicalTo: arg1 ] packageDo: [:arg2 |  self assert: false ] groupDo: [:arg2 |  self assert: false ]useNew  self allowgoferVersionFrom: arg1  self flag: #review.  ^self localRepository goferVersionFrom: arg1setUpConfigurationOfProjectIssue136dkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue136-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion10Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue136:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version10Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue136:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4repositories: arg1  self root repositories: arg1 constructor: selfanswers: arg1  self setAnswers: arg1canDowngradeTo: arg1  (self className = arg1 className and: [ self operator == arg1 operator ]) ifFalse: [ ^false ].  self versionOrNil == nil ifTrue: [ ^true ].  ^(self compareVersions: arg1 usingOperator: self operator) notconfiguration  ^configurationversion51Umbrella: arg1  < version: '5.1'>  arg1 for: #common do: [ arg1           project: 'Umbrella' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '5.1';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]vrsnStatus  ^vrsnStatusimportFrom: arg1 updateProjects: arg2 updatePackages: arg3 versionSpecsDo: arg4  ^self importFrom: arg1 projectAttributes: project attributes inactiveAttributes: #() updateProjects: arg2 updatePackages: arg3 versionSpecsDo: arg4versionDoesNotExistException: arg1  versionDoesNotExistException := arg1className  className ifNil: [ self name ifNotNil: [ self className: self constructClassName ] ].  ^classNameupdatePackageSpec: arg1 using: arg2  self projectReference updatePackageSpec: arg1validateAndSaveConfiguration  ^Lesson title: '3. Validate and save configuration in project repository' lesson: '"Before saving a configuration into the project repository, the configuration should be validated and any Critical Issues should be addressed:"			(MetacelloToolBox validateConfiguration: ConfigurationOfExample) explore."Use Gofer to save the configuration to your project repository:"	Gofer new		url: ''http://www.example.com/ExampleRepository'';		package: ''ConfigurationOfExample'';		commit: ''Initial configuration''."Once you''ve done your initial commit, you can use the following expression to save the configuration to your project repository:"	MetacelloToolBox saveConfigurationPackageFor: ''Example'' description: ''commit message''.	"Note that MetacelloToolBox class>>saveConfigurationPackageFor:description: validates the configuration before saving."ProfStef next.'createVersion: arg1  | tmp1 |  [ tmp1 := project version: arg1 ] on: MetacelloVersionDoesNotExistError do: [:arg2 |  | tmp2 |        tmp2 := self createVersionSpec: arg1.        tmp1 := tmp2 createVersion.        project map == nil ifTrue: [ project map: Dictionary new ].        project map at: arg1 put: tmp1 ].  ^tmp1applyAdd: arg1 copy: arg2 merge: arg3 remove: arg4  self subclassResponsibilityopen10ForDevelopment  ^Lesson title: 'Open version 1.0 for development' lesson: '"	1. Create configuration		- always start a toolbox expression this way	2. Prepare to define version method #version10:		- similar expression used to create baseline method	3. Import specification from version 1.0-baseline		- specs that are not needed in a version are dropped		- import is added to pragma		- with #updateProjects set to true, the current version of the project Shout will set		- with #updatePackages set to true, the current mcz files for the packages ProfStef-Core ProfStef-Tests will be set	4. Define desired versionSpec attributes		- current author and timestamp		- set blessing to #development		- set the description		- return value of true in block, means the versionSpec is added to current method being defined	5. Compile the #version10: method		- compile and validate	6. Prepare to define symbolic version method #development:	7. Define symbolic version 		- symbolic version #development maps to version 1.0 for the #common attributes		- multiple addSymbolicSection: expressions may be used 	8. Compile the #development: method		- compile and validate"		| description |	description := ''- fixed a bug''."1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		createVersionMethod: ''version10:'' inCategory: ''versions'' forVersion: ''1.0'';"3."		importFrom: ''1.0-baseline''			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ "4."						versionSpec							author: MetacelloPlatform current authorName;							blessing: #development;							description: description;							timestamp: MetacelloPlatform current timestamp ].				true ];"5."		commitMethod;"6."		createSymbolicVersionMethod: ''development:'' inCategory: ''symbolic versions'' forVersion: #development;"7."		addSymbolicSection: #common version: ''1.0'';"8."		commitMethod."After evaluating the above expression, take a look at the generated methods:	- #version10:	- #development:"ProfStef next.'existingProjectRegistration: arg1  existingProjectRegistration := arg1hasClassName  ^className ~~ nilbaseline10: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 project: 'Example Project' with: [ arg1                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 yourself ] ]baseline20: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 project: 'Example Project' with: [ arg1                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 yourself ] ]className: arg1  self shouldBeMutable.  className := arg1specListDo: arg1  self list do: [:arg2 |  arg1 value: arg2 spec ]projectClassProject  ^self projectClass new project     setBaselineRepositoryDescription: self repositoryDescriptions;     yourselfsetUpVersionReferences  versionReferences := OrderedCollection new.  versionReferences     add: (GoferVersionReference name: 'GoferBar.branch-lr.1');     add: (GoferVersionReference name: 'GoferBar.branch-lr.2');     add: (GoferVersionReference name: 'GoferBar-jf.1');     add: (GoferVersionReference name: 'GoferBar-lr.1');     add: (GoferVersionReference name: 'GoferFoo-lr.1');     add: (GoferVersionReference name: 'GoferFoo-lr.2');     add: (GoferVersionReference name: 'GoferFoo-lr.4');     add: (GoferVersionReference name: 'GoferBeau-dkh.15');     add: (GoferVersionReference name: 'GoferBeau-dkh.25');     add: (GoferVersionReference name: 'GoferBeau-dkh.53');     add: (GoferVersionReference name: 'GoferBeau-dkh.54');     add: (GoferVersionReference name: 'GoferBeau-dkh.55');     add: (GoferVersionReference name: 'GoferBeau-dkh.56');     add: (GoferVersionReference name: 'GoferFaux-tg.30');     add: (GoferVersionReference name: 'GoferFaux-tg.31');     add: (GoferVersionReference name: 'GoferFaux-tg.32');     add: (GoferVersionReference name: 'GoferFaux-tg.33');     add: (GoferVersionReference name: 'GoferFaux-tg.34');     add: (GoferVersionReference name: 'GoferFaux-tg.35');     add: (GoferVersionReference name: 'GeauxBar.branch-lr.2');     add: (GoferVersionReference name: 'GeauxFoo-lr.1');     add: (GoferVersionReference name: 'GeauxFaux-tg.32');     add: (GoferVersionReference name: 'GeauxBeau-dkh.55');     add: (GoferVersionReference name: 'GeauxBeau-dkh.56');     add: (GoferVersionReference name: 'Issue339-JanKurs.1');     add: (GoferVersionReference name: 'Issue339-JanKurs.11');     add: (GoferVersionReference name: 'ConfigurationOfNautilusWithoutPackages-dkh.55');     add: (GoferVersionReference name: 'ConfigurationOfNautilusWithoutPackages-dkh.56');     add: (GoferVersionReference name: 'ConfigurationOfNautilusWithoutPackages-dkh.57');     add: (GoferVersionReference name: 'ConfigurationOfNautilus-dkh.56');     add: (GoferVersionReference name: 'ConfigurationOfGlamourSeaside-dkh.55');     add: (GoferVersionReference name: 'ConfigurationOfGlamourSeaside-dkh.56');     add: (GoferVersionReference name: 'ConfigurationOfGlamourSeaside-dkh.57');     add: (GoferVersionReference name: 'ConfigurationOfGlamour-dkh.56');     yourselfbaseline40Foo: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.32';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        arg1           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferFaux');           yourself ]githubUser: arg1 project: arg2 commitish: arg3 path: arg4  | tmp1 |  tmp1 := arg3.  tmp1 isEmpty ifTrue: [ tmp1 := 'master' ].  self repository: 'github://' , arg1 , '/' , arg2 , ':' , tmp1 , '/' , arg4exception: arg1  exception := arg1name  ^namepackageDo: arg1  loadData  loadData == nil ifTrue: [ loadData := MetacelloLoadData new ].  ^loadDataparent  ^parentauthor: arg1  arg1 setAuthorInMetacelloVersion: selftestVersionMergeSpec  | tmp1 tmp2 tmp3 |  tmp1 := self versionSpec     blessing: #baseline;     versionString: '1.0';     description: 'A description';     author: 'dkh';     timestamp: '1/24/2012 09:59';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  tmp2 := self versionSpec     blessing: #release;     versionString: '1.1';     description: 'A FULL description';     author: 'DaleHenrichs';     timestamp: '1/24/2012 10:22';     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: tmp3 blessing value equals: #release.  self assert: tmp3 versionString value equals: '1.1'.  self assert: tmp3 description value equals: 'A FULL description'.  self assert: tmp3 author value equals: 'DaleHenrichs'.  self assert: tmp3 timestamp value equals: '1/24/2012 10:22'.  self assert: tmp3 preLoadDoIt value identicalTo: #preLoadDoItB.  self assert: tmp3 postLoadDoIt value identicalTo: #postLoadDoItBcreateVersionMethod: arg1 inCategory: arg2 forVersion: arg3  methodSpec := MetacelloVersionMethodSpec new     project: project;     selector: arg1;     category: arg2;     versionString: arg3;     yourselfcompareRelativeCurrentVersion: arg1 targetVersionStatus: arg2 using: arg3  | tmp1 tmp2 |  (tmp2 := self versionOrNil) == nil ifTrue: [ ^false ].  (tmp1 := self relativeCurrentVersion) == nil ifTrue: [ ^false ].  (arg2 includes: tmp1 versionStatus) ifTrue: [ ^tmp1 perform: arg1 with: tmp2 ].  ^falseprepostLoadDirectivesDo: arg1  arg1 value: selfbaseline35ProjectFie: arg1  < version: '3.5'>  arg1 for: #common do: [ arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.5';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Feaux' with: [ arg1                 className: 'MetacelloTestConfigurationOfFeaux';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFeaux';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]validateProject: arg1  | tmp1 tmp2 |  (self visited includes: arg1 configuration class) ifTrue: [ ^self validationReport ].  self visited add: arg1 configuration class.  tmp1 := tmp2 := true.  arg1 versions do: [:arg2 |  | tmp3 |        tmp3 := arg2 spec.        [ tmp3 blessing value == #baseline ifTrue: [ tmp1 := false.              self validateBaselineVersionSpec: tmp3 ] ifFalse: [ tmp2 := false.              self validateVersionSpec: tmp3 ] ] on: Error do: [:arg3 |  self recordValidationError: 'Error composing version ' , arg2 versionString printString , ': ' , arg3 description versionString: arg2 versionString callSite: #validateProject: reasonCode: #versionCompositionError ] ].  arg1 symbolicVersionMap keys do: [:arg4 |  | tmp4 |        arg2 := [ arg1 version: arg4 ] on: Error , MetacelloSymbolicVersionNotDefinedError do: [:arg3 |  (arg3 isKindOf: MetacelloSymbolicVersionNotDefinedError) ifFalse: [ self recordValidationError: 'symbolic version ' , arg4 printString , ' does not resolve to a literal version.' callSite: #validatePragmas reasonCode: #cannotResolveVersion ].              arg3 return: nil ].        arg2 ~~ nil ifTrue: [ self validateVersionSpecForSymbolicVersion: arg2 spec symbolicVersion: arg4 ] ].  tmp2 ifTrue: [ tmp1 ifTrue: [ self recordValidationError: 'No usable baseline or versions defined.' callSite: #validatePragmas reasonCode: #noVersionsDefined ] ifFalse: [ self recordValidationWarning: 'Only baseline defined (no version defined).' callSite: #validatePragmas reasonCode: #onlyBaselineVersion ] ].  ^self validationReportspec: arg1 externalReference: arg2 loader: arg3  super spec: arg1 loader: arg3.  externalReference := arg2version: arg1  self addStatement: #versionArg: args: {arg1}repositoryForSpec: arg1 username: arg2 password: arg3  self root repository: arg1 username: arg2 password: arg3symbolicVersionMap  ^symbolicVersionMapnonOverridable  ^super nonOverridable , #(#packageList)scheduleFetchFor: arg1 cachedReference: arg2  ^selfversionOfMariano: arg1  < version: '0.9.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>versionOfMariano:'.        arg1 author: 'dkh'.        arg1 timestamp: '5/31/2012 16:04' ].  arg1 for: #custom do: [ arg1 baseline: 'ExternalX' with: [ arg1 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]versionDirectivesDo: arg1  handleWarning: arg1  ^(self options at: #onWarning ifAbsent: [ ^arg1 pass ]) cull: arg1testAddC  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1 add: #('http://example.com/repository' '/opt/gemstone/repository').  tmp2 := tmp1 map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: 'http://example.com/repository'.  self assert: tmp2 type equals: 'http'.  tmp2 := tmp1 map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: '/opt/gemstone/repository'.  self assert: tmp2 type equals: 'directory'testCachedReturn  | tmp1 |  self assert: (tmp1 := self cachedReturnOfValue) identicalTo: 6cacheRepository: arg1  cacheRepository := arg1.  ensuredMap := cacheGofer := nilsetAuthorWithBlock: arg1  | tmp1 |  (tmp1 := self root getAuthor) == nil ifTrue: [ tmp1 := self project valueHolderSpec.        self root setAuthor: tmp1 ].  self with: tmp1 during: arg1mergeSpec: arg1  | tmp1 tmp2 tmp3 |  tmp1 := super mergeSpec: arg1.  tmp2 := arg1 mergeMap.  (tmp3 := tmp2 at: #repositories) ~~ nil ifTrue: [ tmp1 mergeRepositoriesSpec: tmp3 ].  ^tmp1testVersion20  self assert: (MetacelloVersionNumber fromString: '') printString equals: ''projectForVersion: arg1 with: arg2  arg2 setProject: arg1 withInMetacelloConfig: selfversionStatus: arg1  versionStatus := arg1loadUsing: arg1 gofer: arg2  ^arg1 linearLoadPackageSpec: self gofer: arg2allFileNames  self flag: #review.  ^self localRepository allFileNamesresolveToAllPackagesIn: arg1 into: arg2 visited: arg3  arg3 visit: self doing: [:arg4 |  self visitingWithPackages: arg2.        arg4 includes , arg4 requires do: [:arg5 |  (arg1 packageNamed: arg5) projectDo: [:arg6 |  (arg6 resolveToAllPackagesIn: arg1 visited: arg3) do: [:arg7 |  arg2 at: arg7 name put: arg7 ] ] packageDo: [:arg7 |  arg2 at: arg7 name put: arg7.                    (arg7 resolveToAllPackagesIn: arg1 visited: arg3) do: [:arg8 |  arg2 at: arg8 name put: arg8 ] ] groupDo: [:arg9 |  arg9 resolveToAllPackagesIn: arg1 into: arg2 visited: arg3 ] ] ]valueHolderSpec  ^self project valueHolderSpecbaselineRegistry  baselineRegistry ifNil: [ baselineRegistry := Dictionary new ].  ^baselineRegistryhasConflictWithProjectSpec: arg1  (self className beginsWith: 'BaselineOf') ifTrue: [ ^arg1 hasConflictWithBaselineSpec: self asBaselineProjectSpec ].  ^arg1 hasConflictWithConfigurationSpec: self asConfigurationProjectSpecextractMethodSectionsFor: arg1  | tmp1 tmp2 |  tmp1 := self extractAllVersionPragmas at: arg1 ifAbsent: [ ^#() ].  tmp1 size > 1 ifTrue: [ self error: 'More than one pragma defining ' , arg1 printString ].  tmp2 := tmp1 at: 1.  self evaluatePragma: tmp2.  self methodSections do: [:arg2 |  self evaluateMethodSection: arg2 version: arg1 ]setUpConfigurationExternalRefdkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternalRef-dkh.1'.  tmp2 := #ConfigurationOfExternalRef.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationExternalRef090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef090:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationExternalRef091:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef091:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4lesson11Blessing  ^Lesson title: 'Lesson 11 (Blessing)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."A version can be tagged with a blessing like #alpha, #beta, #release, #development or any other tag that you find useful. The blessing for version 1.1 is #development"	(MetacelloTutorialConfig project version: ''1.1'') blessing."The default blessing is #release, so even though we didn''t specify a blessing for version 0.5, the blessing is set:"	(MetacelloTutorialConfig project version: ''0.5'') blessing.	"For version 1.1, it is important to explicitly set the blessing, because it imports version''1.0-baseline'' whose blessing is #baseline:"	(MetacelloTutorialConfig project version: ''1.0-baseline'') blessing."Blessings can be used as a filter. For example, you will notice that the result of the following expression is version 0.6, because #stableVersion answers the latest version whose blessing is _not_ #development, #broken, or #blessing: "	MetacelloTutorialConfig project stableVersion.	MetacelloTutorialConfig project stableVersion load."The blessing of version 1.1 is #development. To find the latest #development version you would execute this expression:"	MetacelloTutorialConfig project latestVersion: #development.	(MetacelloTutorialConfig project latestVersion: #development) load."You can get the very last version independent of blessing by executing this expression:"	MetacelloTutorialConfig project bleedingEdge.	MetacelloTutorialConfig project bleedingEdge load.	"In general, the #development blessing should be used for any version that is unstable. Once a version has stabilized, a different blessing should be applied.The following expression will load the latest version of all of the packages for the latest #baseline version:"	(MetacelloTutorialConfig project latestVersion: #baseline) load."Since the latest #baseline version should reflect the most up-to-date project structure, executingthe previous expression should load the absolute bleeding edge of the project. "ProfStef next.'symbolicVersion  ^symbolicVersionensureLoadUsing: arg1  | tmp1 |  tmp1 := (MetacelloLookupProjectSpec new     projectSpec: self;     yourself) signal projectPackage.  tmp1 ifNil: [ self error: 'Unable to resolve project package for ' , self name printString , '. It is likely that that the configuration referencing this project will not validate properly (see MetacelloToolBox class>>validateConfiguration:).' ].  tmp1 ensureLoadUsing: arg1newVersionForWorkingCopy: arg1  ^arg1 newVersionIn: arg1 repositoryGroupload  (MetacelloLookupProjectSpecForLoad new     projectSpec: self;     yourself) signal performLoadhandleResolutionFor: arg1  ^arg1 handleLookupBaselineSpecForEnsureLoad: selfsetUpIssue156BaselineOfGoo  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'BaselineOfGoo-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString selector: 'baselineGooIssue156Baseline:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGooIssue156Baseline:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())name: arg1  super name: arg1.  self projectPackage: nilvalue: arg1  self root value: arg1 constructor: selfcurrentVersionInfo  | tmp1 |  (tmp1 := self workingCopy) ~~ nil ifTrue: [ tmp1 ancestry ancestors isEmpty not ifTrue: [ ^tmp1 ancestry ancestors first ] ].  ^nilrequiresSpecsForPackageOrdering: arg1  | tmp1 |  tmp1 := Set new.  self includes do: [:arg2 |  (arg1 packageNamed: arg2 ifAbsent: [  ]) ifNotNil: [:arg3 |  tmp1 addAll: (arg3 resolveToPackagesIn: arg1 andProjects: true visited: MetacelloVisitedPackages new) ] ].  ^tmp1packageSpec  ^self project packageSpecconfigurationProjectSpec: arg1  self shouldBeMutable.  baselineProjectSpec := nil.  self assert: arg1 isConfigurationOfProjectSpec.  configurationProjectSpec := arg1descriptionForVersion: arg1  arg1 setDescriptionInMetacelloConfig: selfbreak  ^self allowconfigurationClass  ^self configuration classbaselineOfProjectSpecClass  ^MetacelloMCBaselineOfProjectSpecversion106ProjectToolBox: arg1  < version: '1.0.6-baseline'>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1 repositories: [ arg1                       repository: 'http://www.example.com/ob';                       repository: 'http://www.example.com/or' ] ] ]tearDown  testingEnvironment removeKey: #Metacello_Platform_Test_GlobalDictionary ifAbsent: [  ].  super tearDownmergeImportLoads: arg1  self error: 'import: can only be used with baseline project specs'lockConfiguration12: arg1  < version: '1.2.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>lockConfiguration12: '.        arg1 configuration: 'ExternalX' with: [ arg1 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]description  ^descriptionvalidate  self validatePragmas.  ^self validateProjectsetUpBaselineIssue399Cypress  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfIssue399Cypress-dkh.1'.  tmp2 := #BaselineOfIssue399Cypress.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineIssue399:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue399:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'projectClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #projectClass) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4repositorySpec  ^self project repositorySpecprojectPackage  MCWorkingCopy managersForClass: self configuration class do: [:arg1 |  | tmp1 tmp2 |        tmp1 := self packageSpec           name: arg1 packageName;           yourself.        arg1 ancestors notEmpty ifTrue: [ tmp1 file: arg1 ancestors first name ].        tmp2 := arg1 repositoryGroup repositories detect: [:arg2 |  arg2 ~~ MetacelloPlatform current defaultPackageCache ] ifNone: [ MetacelloNotification signal: 'Using cache repository for ' , self label , ' project package'.              MetacelloPlatform current defaultPackageCache ].        tmp1 repository: (tmp2 asRepositorySpecFor: self).        ^tmp1 ].  ^nilisLoadedToSpec  ^self spec isLoadedToSpecrecordValidationCriticalWarning: arg1 versionString: arg2 callSite: arg3 reasonCode: arg4  < haltOrBreakpointForTesting>  (self criticalWarningReasonCodes includes: arg4) ifFalse: [ self error: 'Unknown critical warning reason code' ].  ((self exludededValidations at: arg2 ifAbsent: [ #() ]) includes: arg4) ifTrue: [ ^self ].  (self debug includes: #criticalWarning) ifTrue: [ self halt: 'Debug triggered for critical warning: ' , arg1 ].  self validationReport add: (MetacelloValidationCriticalWarning configurationClass: (self recurse ifTrue: [ self configurationClass ] ifFalse: [ nil ]) reasonCode: arg4 callSite: arg3 explanation: arg1)visited  visited == nil ifTrue: [ visited := IdentitySet new ].  ^visitedhandleResolutionFor: arg1  ^arg1 handleLock: selfancestorsFor: arg1  | tmp1 tmp2 |  tmp1 := arg1 file.  ^MetacelloPlatform current stackCacheFor: #ancestors at: tmp1 doing: [:arg2 |  tmp2 := arg1 ancestors.        arg2 at: tmp1 put: tmp2 ]baseline30Fan: arg1  < version: '3.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.0';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]aPackageNotLoaded: arg1  aPackageNotLoaded := arg1visitingWithPackages: arg1  arg1 at: self name put: selfsilently: arg1  self options at: #silently put: arg1setUpIssue77  self     setUpIssue77B;     setUpIssue77C;     setUpIssue77DsetUpBaselineIssue32  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfIssue32-dkh.1'.  tmp2 := #BaselineOfIssue32.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'postloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #postloadDoIt) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #preloadDoIt) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineIssue32:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue32:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4compareWorkingCopyNamed: arg1 using: arg2  | tmp1 tmp2 |  tmp1 := GoferResolvedReference name: self file.  tmp2 := GoferResolvedReference name: arg1.  ^tmp2 compare: tmp1 using: arg2testIncrementDecrementVersionNumber  | tmp1 |  tmp1 := self defaultVersion1.  self assert: tmp1 incrementMinorVersionNumber asString equals: '1.0.1'.  self assert: tmp1 decrementMinorVersionNumber asString equals: '1.0.0'selector: arg1  selector := arg1fileSystemLegacy: arg1  arg1 package: 'FileSystemLegacy' with: [ arg1           repository: 'http://smalltalkhub.com/mc/PharoExtras/FileSystemLegacy/main';           file: 'FileSystem-Legacy-JohanBrichau.2' ]silently: arg1  silently := arg1version: arg1  self root version: arg1 constructor: selfmethodSection: arg1 do: arg2  arg1 methodSections do: arg2.  arg1 methodSections do: [:arg3 |  self methodSection: arg3 do: arg2 ]lesson13  ^Lesson title: 'Lesson 13' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version13:."In #version13: we are importing the ''1.2-baseline'', but changing the Example project version to 1.3, so project versions can be updated in the verson method jus like package versions.Evaluate and compare the results of these expressions:"  (MetacelloProjectRefTutorialConfig project version: ''1.2'') load: ''Project-Core''.  (MetacelloProjectRefTutorialConfig project version: ''1.3'') load: ''Project-Core''.  (MetacelloProjectRefTutorialConfig project version: ''1.2'') load: ''Project-Tests''.  (MetacelloProjectRefTutorialConfig project version: ''1.3'') load: ''Project-Tests''."It is worth noting that in version 1.3 of the Example project, the platform-specific''Example-Platform'' was introduced and nothing special had to be done in the project reference to get the package included."ProfStef next.'validateBaselineVersionSpec: arg1  | tmp1 tmp2 tmp3 tmp4 |  self validateDoIts: arg1 versionString: arg1 versionString errorMessage: ' version ' , arg1 versionString printString.  tmp1 := Set new.  tmp2 := Set new.  tmp3 := Set new.  tmp4 := ' in version ' , arg1 versionString printString.  arg1 projectDo: [:arg2 |  arg2 resolveProjectSpec className == nil ifTrue: [ self recordValidationError: 'Missing required field (className:) for project reference ' , arg2 name printString , ' in version ' , arg1 versionString printString versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #incompleteProjectSpec ].        arg2 resolveProjectSpec versionString == nil ifTrue: [ self recordValidationCriticalWarning: 'Missing recommended field (versionString:) for project reference ' , arg2 name printString , ' in version ' , arg1 versionString printString versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #missingRecommendedProjectSpecField ].        arg2 hasRepository ifTrue: [ (self recurse and: [ arg2 versionString ~~ nil ]) ifTrue: [ | tmp5 |                    arg2 resolveProjectSpec ensureProjectLoaded.                    tmp5 := self validateProjectCreationFrom: arg2 resolveProjectSpec projectClass onError: [:arg3 |  self recordValidationError: 'Error creating project reference: ' , arg3 description versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #projectCreationError.                          nil ].                    tmp5 ~~ nil ifTrue: [ self validationReport addAll: (self class validateProject: tmp5 version: arg2 versionString debug: self debug recurse: self recurse visited: self visited) ] ] ] ifFalse: [ self recordValidationError: 'Missing required field (repository:) for project reference ' , arg2 name printString , ' in version ' , arg1 versionString printString versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #incompleteProjectSpec ].        self validateDoIts: arg2 versionString: arg1 versionString errorMessage: arg2 name printString , tmp4.        (tmp1 includes: arg2 name) ifTrue: [ self recordValidationError: 'Duplicate projects named' , arg2 name printString , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #duplicateNames ] ifFalse: [ tmp1 add: arg2 name ] ] packageDo: [:arg4 |  self validateDoIts: arg4 versionString: arg1 versionString errorMessage: arg4 name printString , tmp4.        (tmp2 includes: arg4 name) ifTrue: [ self recordValidationError: 'Duplicate packages named' , arg4 name printString , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #duplicateNames ] ifFalse: [ tmp1 add: arg4 name ] ] groupDo: [:arg5 |  (tmp3 includes: arg5 name) ifTrue: [ self recordValidationError: 'Duplicate groups named' , arg5 name printString , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #duplicateNames ] ifFalse: [ tmp1 add: arg5 name ] ].  (tmp2 intersection: tmp1) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between packages and projects' , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (tmp3 intersection: tmp1) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between groups and projects' , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (tmp1 intersection: tmp2) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between projects and packages' , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (tmp3 intersection: tmp2) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between groups and packages' , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (tmp1 intersection: tmp3) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between projects and groups' , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ].  (tmp2 intersection: tmp3) notEmpty ifTrue: [ self recordValidationError: 'Names duplicated between packages and groups' , tmp4 versionString: arg1 versionString callSite: #validateBaselineVersionSpec: reasonCode: #shadowedNames ]getAuthor  ^authorhandleLookupBaselineSpecForEnsureLoad: arg1  | tmp1 tmp2 |  tmp1 := arg1 projectSpec.  tmp2 := self lookupProjectSpecFor: arg1 projectSpec.  ^arg1 resume: (tmp2 compareEqual: tmp1) notrepositoryError: arg1  repositoryError := arg1testMergeProjectA  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self packagesSpec.  tmp2 := self projectSpec     name: 'Project';     className: 'ConfigurationOfProjectA';     versionString: #stable;     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  tmp4 := self project projectReferenceSpec     name: tmp2 name;     projectReference: tmp2;     yourself.  tmp1 add: tmp4.  tmp2 := self projectSpec     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     operator: #<;     loads: #('MyPackage');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  tmp4 := self project projectReferenceSpec     name: tmp2 name;     projectReference: tmp2;     yourself.  tmp1 merge: tmp4.  tmp3 := tmp1 packageNamed: 'Project' ifAbsent: [ self assert: false ].  tmp2 := tmp3 referencedSpec.  self assert: tmp2 name equals: 'Project'.  self assert: tmp2 className equals: 'ConfigurationOfProject'.  self assert: tmp2 versionString equals: '1.0'.  self assert: tmp2 operator identicalTo: #<.  self assert: tmp2 loads equals: #('MyPackage').  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoIt.  tmp2 projectDo: [:arg1 |  self assert: tmp2 identicalTo: arg1 ] packageDo: [:arg2 |  self assert: false ] groupDo: [:arg2 |  self assert: false ]collectionCacheKey  | tmp1 |  tmp1 := Array with: self class with: (Array with: #x with: #y).  ^MetacelloPlatform current stackCacheFor: #collection at: tmp1 doing: [:arg1 |  | tmp2 |        tmp2 := arg1 at: #x ifAbsent: [ 0 ].        tmp2 > 5 ifTrue: [ arg1 at: tmp1 put: tmp2 ] ifFalse: [ tmp2 := tmp2 + 1.              arg1 at: #x put: tmp2 ].        self collectionCacheKey ]tearDownRepositories  super tearDownRepositories.  MCRepositoryGroup default removeIdenticalRepository: (testingEnvironment at: #Metacello_XXX_Test_Repository ifAbsent: [  ]).  testingEnvironment removeKey: #Metacello_Config_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_XXX_Test_Repository ifAbsent: [  ]incrementMajorVersion  self incrementVersionAt: 1versionArg  ^versionArgrecord: arg1  ^arg1 recordRequiredForMetacelloMCVersion: selflesson11Timestamp  loadType: arg1  loadType := arg1spec  ^specprime  nonOverridable  ^super nonOverridable , #(#repositories)baseName  ^MetacelloScriptEngine baseNameOf: self classNameunregister  ^self execute: #unregister args: #()baseline60Fix: arg1  < version: '6.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.35';           yourself ]version125ProjectToolBox: arg1  < version: '1.2.5-baseline' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1                 preLoadDoIt: #preloadDoIt;                 postLoadDoIt: #postloadDoIt ] ]project  | tmp1 tmp2 |  tmp1 := MetacelloVersionConstructor on: self.  tmp2 := tmp1 project.  tmp2 loader: MetacelloNullRecordingMCSpecLoader new.  ^tmp2fileFromPath: arg1 relativeTo: arg2  ^arg2 / arg1repository  self deprecated: 'Use repositories or repositorySpecs'.  ^nilrecurse: arg1  recurse := arg1loaderClass  loaderClass == nil ifTrue: [ loaderClass := self defaultLoaderClass ].  ^loaderClasssqueakfoundation: arg1  self repository: 'http://source.squeakfoundation.org/' , arg1version  ^nilbaseline13: arg1  < version: '1.3-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://www.example.com/Example'.        arg1           package: 'Example-Core' with: [ arg1 includes: #('Example-Platform') ];           package: 'Example-Tests' with: [ arg1 requires: 'Example-Core' ];           package: 'Example-AddOn' with: [ arg1 requires: 'Example-Core' ];           package: 'Example-Platform' with: [ arg1 requires: 'Example-Core' ];           package: 'Example-AddOnTests' with: [ arg1 requires: #('Example-AddOn' 'Example-Tests') ].        arg1           group: 'default' with: #('Example-Core' 'Example-AddOn');           group: 'Tests' with: #('Example-Tests' 'Example-AddOnTests') ].  arg1 for: #gemstone do: [ arg1 package: 'Example-Platform' with: 'Example-Platform.gemstone' ].  arg1 for: #pharo do: [ arg1 package: 'Example-Platform' with: 'Example-Platform.pharo' ].  arg1 for: #squeak do: [ arg1 package: 'Example-Platform' with: 'Example-Platform.squeak' ]setUpConfigurationIssue84  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfIssue84-dkh.1'.  tmp2 := #ConfigurationOfIssue84.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'version10Issue84:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue84:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4resolveToPackagesIn: arg1 visited: arg2  | tmp1 |  tmp1 := Dictionary new.  self resolveToPackagesIn: arg1 andProjects: false into: tmp1 visited: arg2.  ^tmp1 values asOrderedCollectionensureLoadUsing: arg1  self explicitLoadUsing: arg1 ensureSpecLoaderlinearProjectMethodSource  ^(self class sourceCodeAt: #project) asString copyReplaceAll: 'atomic' with: 'linear'repository: arg1 username: arg2 password: arg3 constructor: arg4  arg4 repositoryForVersion: arg1 username: arg2 password: arg3testVersion17  self assert: (self versionClass fromString: '1.0') equals: (self versionClass fromString: '1.0.0').  self assert: (self versionClass fromString: '1') equals: (self versionClass fromString: '1.0').  self assert: (self versionClass fromString: '1') > (self versionClass fromString: '1-0').  self assert: (self versionClass fromString: '1') > (self versionClass fromString: '1.0-beta.0').  self assert: (self versionClass fromString: '1') > (self versionClass fromString: '1-beta.0').  self assert: (self versionClass fromString: '1') > (self versionClass fromString: '1-beta')postLoadDoIt: arg1  arg1 setPostLoadDoItInMetacelloSpec: selfvisit: arg1 doing: arg2  arg1 projectDo: [:arg3 |  (projects includes: arg3 name) ifTrue: [ ^self ].        projects add: arg3 name ] packageDo: [:arg3 |  (packages includes: arg3 name) ifTrue: [ ^self ].        packages add: arg3 name ] groupDo: [:arg3 |  (groups includes: arg3 name) ifTrue: [ ^self ].        groups add: arg3 name ].  arg2 value: arg1copyClass: arg1 as: arg2 inCategory: arg3  self subclassResponsibilitysetUpIssue77C  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfIssue77C-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline12C:' category: 'cat' timeStamp: '' source: self baseline12MethodSourceC) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline13C:' category: 'cat' timeStamp: '' source: self baseline13MethodSourceC)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())scpUrl  ^'git@github.com:' , projectPath , '.git'string: arg1 includesSubstring: arg2  ^arg1 includesSubString: arg2packageName  ^self externalReference packageNamefetchUsing: arg1  (MetacelloLookupProjectSpec new     projectSpec: self;     yourself) signal projectPackage fetchUsing: arg1projectClass  ^MetacelloMCBaselineProjectcopyClass: arg1 as: arg2 inCategory: arg3  | tmp1 tmp2 tmp3 |  tmp1 := arg2 asSymbol.  tmp1 = arg1 name ifTrue: [ ^arg1 ].  (Smalltalk globals includesKey: tmp1) ifTrue: [ ^self error: tmp1 , ' already exists' ].  tmp3 := arg1 definition copyReplaceAll: '#' , arg1 name asString with: '#' , tmp1 asString printString.  tmp3 := tmp3 copyReplaceAll: 'category: ' , (SystemOrganization categoryOfElement: arg1 name) asString printString with: 'category: ' , arg3 printString.  tmp2 := self compiler     logged: true;     evaluate: tmp3.  tmp2 class instanceVariableNames: arg1 class instanceVariablesString.  tmp2 copyAllCategoriesFrom: arg1.  tmp2 class copyAllCategoriesFrom: arg1 class.  tmp2 category: arg3.  ^tmp2configurationOfProjectSpec  ^self configurationOfProjectSpecClass for: selfcreatePackageSpec: arg1  ^project packageSpec     name: arg1;     yourselfbaseName  ^self projectSpec baseNameoverrideProjectSpec: arg1  overrideProjectSpec := arg1projectSpecForClassNamed: arg1 ifAbsent: arg2  ^(self configurationRegistry at: arg1 ifAbsent: [ ^(self baselineRegistry at: arg1 ifAbsent: [ ^arg2 value ]) baselineProjectSpec ]) configurationProjectSpecversionNumberClass: arg1  versionNumberClass := arg1decrementMajorVersion  self decrementNormalVersionAt: 1updatePackageRepositoriesFor: arg1  ^trueonConflictUseIncoming  self onConflict: [:arg1 :arg2 :arg3 |  arg1 useIncoming ]mergeSpec: arg1  | tmp1 tmp2 tmp3 |  tmp1 := super mergeSpec: arg1.  tmp2 := arg1 mergeMap.  (tmp3 := tmp2 at: #packageList) isEmpty not ifTrue: [ tmp1 packages: (self packages isEmpty ifTrue: [ tmp3 ] ifFalse: [ self packages mergeSpec: tmp3 ]) ].  ^tmp1version40Issue119: arg1  < version: '4.0' imports: #('4.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: '2.0'.        arg1 package: 'GoferBar' with: 'GoferBar-jf.1' ]basicSpec  ^self specbaseline10MethodSourceB  ^(self class sourceCodeAt: #baseline10B:) asStringcurrentlyLoadedClassesInProject  ^self projectSpec currentlyLoadedClassesInVersion asSetgetRepositories  ^repositoriesincrementMinorVersionNumber  self incrementNormalVersionAt: 3isBaselineOfProjectSpec  ^falsevalidateLocalRepository  | tmp1 |  tmp1 := self calculateRepositoryDirectory.  (tmp1 = localRepository directory and: [ MCFileTreeFileUtils current directoryExists: tmp1 ]) ifTrue: [ ^self ].  self flushCache.  self resolveLocalRespositoryversionString  ^self projectReference versionStringcreateSymbolicVersionMethod: arg1 inCategory: arg2 forVersion: arg3  | tmp1 |  methodSpec := MetacelloSymbolicVersionMethodSpec new     project: project;     selector: arg1;     category: arg2;     versionString: arg3;     yourself.  tmp1 := self constructor.  self methodSpec methodSections: (tmp1 extractSymbolicVersionSpecsFor: arg3) asOrderedCollectionversion135ProjectToolBox: arg1  < version: '1.3.5' imports: #('1.2.4-baseline')>  arg1 for: #common do: [ arg1 repositories: [ arg1                 repository: 'http://www.example.com/ab';                 repository: 'http://www.example.com/ac' ] ]createConfigurationAndBaseline  ^Lesson title: '1. Create configuration' lesson: '"The MetacelloToolBox class provides programmatic support for creating and maintaining your configuration. Use the following expression to create your configuration class and initial baseline version. Edit the expression to specifiy the required projects, packages, dependencies and groups for your project:"		MetacelloToolBox		createBaseline: ''1.0-baseline''		for: ''Example''		repository: ''http://www.squeaksource.com/ProfStef''		requiredProjects: #(''Shout'')		packages: #(''ProfStef-Core'' ''ProfStef-Tests'')		dependencies:			{(''ProfStef-Core'' -> #(''Shout'')).			(''ProfStef-Tests'' -> #(''ProfStef-Core''))}		groups:			{(''default'' -> #(''Core'')).			(''Core'' -> #(''ProfStef-Core'')).			(''Tests'' -> #(''ProfStef-Tests'')).			(''Core Tests'' -> #(''Core'' ''Tests''))}.			"After evaluating the above expression, browse the configuration:"	Smalltalk tools browser openOnClass: ConfigurationOfExample selector: #baseline10:.	"Edit the #baseline10 method in the browser to fine tune the baseline specification."ProfStef next.'baseline07: arg1  < version: '0.7-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://www.example.com/Example'.        arg1           package: 'Example-Core';           package: 'Example-Tests' with: [ arg1 requires: 'Example-Core' ];           package: 'Example-AddOn' with: [ arg1 requires: 'Example-Core' ] ]repositoriesForVersion: arg1  self repositoriesForSpec: arg1versionSpec: arg1  versionSpec := arg1setUpBaselineGithubReferenceXI  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefXI-dkh.1'.  tmp2 := #BaselineOfGithubRefXI.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationGithubReferenceV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceV:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4hasNoPackage  ^hasNoPackageoptions  options ifNil: [ options := Dictionary new ].  ^optionscanDowngradeTo: arg1  (self hasLoadConflicts: arg1) ifFalse: [ ^true ].  configurationProjectSpec ifNotNil: [ arg1 configurationProjectSpec ifNotNil: [ configurationProjectSpec ensureProjectLoaded.              ^configurationProjectSpec canDowngradeTo: arg1 configurationProjectSpec ] ].  ^falsegroups  ^(self optionAt: 'groups') splitOn: $,isAllLoadedToSpec  ^self spec isAllLoadedToSpec