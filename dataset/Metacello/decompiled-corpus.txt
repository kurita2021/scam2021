withMetacelloLoadSessionDo: arg1  arg1 valuecreateBaselineOfMethod: arg1 inCategory: arg2  methodSpec := MetacelloBaselineOfMethodSpec new     project: project;     selector: arg1;     category: arg2;     yourselfsetPreLoadDoIt: arg1  preLoadDoIt := arg1file: arg1  self root file: arg1 constructor: selfdefaultAction  ^self projectSpecbaselineVersion113ProjectToolBox: arg1  < version: '1.1.3-baseline'>  arg1 for: #outer do: [ arg1           package: 'Example-Core';           package: 'Example-Test' ]repository: arg1 constructor: arg2  arg2 repositoryForRepositories: arg1lookupProjectSpecFor: arg1  | tmp1 |  tmp1 := MetacelloProjectRegistration registrationForProjectSpec: arg1 ifAbsent: [:arg2 |  arg2 ] ifPresent: [:arg3 :arg2 |  (arg3 hasLoadConflicts: arg2) ifTrue: [ ((arg3 canUpgradeTo: arg2) ifTrue: [ MetacelloAllowProjectUpgrade new ] ifFalse: [ (arg3 canDowngradeTo: arg2) ifTrue: [ MetacelloAllowProjectDowngrade new ] ifFalse: [ MetacelloAllowConflictingProjectUpgrade new ] ])                 existingProjectRegistration: arg3;                 newProjectRegistration: arg2;                 signal ] ifFalse: [ arg2 ] ].  ^tmp1 projectSpecsetUpConfigurationOfProjectToolBox  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectToolBox-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'postloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #postloadDoIt) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #preloadDoIt) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'symbolicVersionExplicitlyDoesNotExistProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #symbolicVersionExplicitlyDoesNotExistProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version100ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version100ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version101ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version101ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version102ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version102ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version103ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version103ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version104ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version104ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version105ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version105ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version106ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version106ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version107ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version107ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version108ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version108ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version109ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version109ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version110ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version110ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version111ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version111ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version112ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version112ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion113ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion113ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version113ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version113ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version114ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version114ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version115ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version115ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version116ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version116ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version117ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version117ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version118ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version118ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version119ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version119ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version120ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version120ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version121ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version121ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version122ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version122ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version123ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version123ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion124ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion124ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version124ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version124ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version125ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version125ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version126ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version126ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version127ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version127ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version128ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version128ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version129ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version129ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version130ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version130ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version131ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version131ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version132ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version132ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version133ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version133ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version134ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version134ProjectToolBox:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version135ProjectToolBox:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version135ProjectToolBox:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())project  ^self spec projectdefaultPlatformAttributes  ^MetacelloPlatform current defaultPlatformAttributesbleedingEdge  < defaultSymbolicVersion: #bleedingEdge>  ^self defaultBleedingEdgeVersiondefaultSymbolicVersionResolverBlock  ^self defaultSymbolicVersionResolverBlock: self configurationhasNoPackage: arg1  hasNoPackage := arg1metacelloRegistrationHash  ^String stringHash: self file initialHash: super metacelloRegistrationHashcacheNames  ^cacheNamesload  overrideRepositories := Array with: self cacheRepository.  self loadDirective loadWithPolicy: selfisExternal  ^falseisResumable  ^truelatestVersionMatching: arg1 includedBlessings: arg2  ^self latestVersionMatching: arg1 includedBlessings: arg2 excludedBlessings: self excludeFromLatestVersionperformCurrentVersionTestAgainst: arg1 operator: arg2 targetVersionStatus: arg3 using: arg4  | tmp1 tmp2 tmp3 |  arg1 ifNil: [ ^false ].  self useDetermineVersionForLoad ifTrue: [ | tmp4 tmp5 |        self hasOverride ifTrue: [ self error: 'unexpected logic combination: useDeterminVersionForLoad & hasOverride' ].        tmp4 := self projectSpec projectClassProject.        tmp4 loader: arg4.        (tmp5 := tmp4 currentVersion) == nil ifTrue: [ ^false ].        (arg3 includes: tmp5 versionStatus) ifTrue: [ ^tmp5 perform: arg2 with: arg1 ].        ^false ].  true ifTrue: [ ^false ].  (self hasOverride not or: [ arg3 ~= #(#allLoadedToSpec) ]) ifTrue: [ ^false ].  (self overrideProjectSpec allPackagesLoaded: arg4) ifFalse: [ ^false ].  (self overrideProjectSpec isPartiallyLoaded: self overrideProjectSpec copy loader) ifFalse: [ ^false ].  (tmp1 := self overrideProjectSpec versionOrNil) ifNil: [ ^false ].  tmp1 = arg1 ifTrue: [ ^true ].  tmp2 := self overrideProjectSpec asProjectRegistration.  tmp3 := self projectSpec asProjectRegistration.  ^tmp1 > arg1 ifTrue: [ (MetacelloAllowProjectDowngrade new           existingProjectRegistration: tmp2;           newProjectRegistration: tmp3;           signal) == tmp2 ] ifFalse: [ (MetacelloAllowProjectUpgrade new           existingProjectRegistration: tmp2;           newProjectRegistration: tmp3;           signal) == tmp2 ]saveProject  | tmp1 |  (tmp1 := self projectPackage) == nil ifTrue: [ ^false ].  ^tmp1 savePackagestackCacheFor: arg1 cacheClass: arg2 at: arg3 doing: arg4  self useStackCacheDuring: [:arg5 |  | tmp1 |        tmp1 := arg5 at: arg1 ifAbsent: [  ].        tmp1 ~~ nil ifTrue: [ | tmp2 tmp3 |              tmp3 := true.              tmp2 := tmp1 at: arg3 ifAbsent: [ tmp3 := false ].              tmp3 ifTrue: [ ^tmp2 ] ] ifFalse: [ tmp1 := arg2 new.              arg5 at: arg1 put: tmp1 ].        ^arg4 value: tmp1 ] defaultDictionary: nilunlock  ^self execute: #unlock args: #()configMethodCascadeOn: arg1 member: arg2 last: arg3 indent: arg4  arg2 methodUpdateSelector == #remove: ifTrue: [ arg1 nextPutAll: 'removeProject: ' , self name printString ] ifFalse: [ self projectReference == nil ifTrue: [ ^self ].        arg1 nextPutAll: self projectLabel , ': ' , self projectName printString , ' '.        (arg2 methodUpdateSelector == #copy: and: [ self projectReference hasNonVersionStringField ]) ifTrue: [ arg1 nextPutAll: 'copyFrom: ' , arg2 sourceName printString , ' ' ].        self projectReference configShortCutMethodOn: arg1 member: arg2 indent: arg4 + 1 ].  arg3 ifTrue: [ arg1 nextPut: $. ] ifFalse: [ arg1           nextPut: $;;           cr ]downloadJSON: arg1 eTagsCache: arg2 eTagsKey: arg3 username: arg4 pass: arg5  ^self downloadJSON: arg1 username: arg4 pass: arg5printOn: arg1  arg1     nextPutAll: self label;     nextPut: $:;     space;     nextPutAll: self explanation.  self reasonCode ~~ #none ifTrue: [ arg1           space;           nextPut: ${;           space;           print: self reasonCode;           space;           nextPut: $} ].  (self configurationClass ~~ nil or: [ self callSite ~~ nil ]) ifTrue: [ arg1           space;           nextPut: $[;           space.        self configurationClass ~~ nil ifTrue: [ arg1                 print: self configurationClass name;                 space ].        self callSite ~~ nil ifTrue: [ arg1                 print: self callSite name;                 space ].        arg1 nextPut: $] ]mapRemove: arg1 into: arg2  arg2 removeKey: arg1 name ifAbsent: [  ]postLoad: arg1  version111ProjectToolBox: arg1  < version: '1.1.1-baseline'>  arg1 for: #common do: [ arg1 package: 'Example-Core'.        arg1 for: #nested do: [ arg1 package: 'Example-Base' ] ].  arg1 for: #extra do: [ arg1 package: 'Example-Test' ]projectLabel  ^self project labelversion: arg1 constructor: arg2  self error: 'version: not allowed in a baseline project spec'resolveProjectSpec  ^self projectReferenceimport: arg1 provides: arg2  self root import: arg1 provides: arg2 constructor: selftestVersion16  self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0')doLoadRequiredFromArray: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloNotification signal: 'Loading ' , tmp1 , '...'.  tmp2 := loaderPolicy.  tmp3 := MetacelloPlatform current bypassProgressBars.  self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].  [ | tmp4 |  tmp4 := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: arg1).  MetacelloPlatform current do: [ tmp4 doLoad ] displaying: 'Loading ' , tmp1.  MetacelloNotification signal: '...finished ' , self versionNumber printString.  ^tmp4 ] ensure: [ MetacelloPlatform current bypassProgressBars: tmp3.        loaderPolicy := tmp2 ]setUpIssue156ConfigurationOfProjectGoo  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'ConfigurationOfProjectGoo-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString selector: 'version10Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue156:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version11Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version11Issue156:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue156:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version30Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue156:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())currentVersionAgainst: arg1  ^nilprojectSpec  ^baselineProjectSpec ifNil: [ self assert: configurationProjectSpec notNil.        configurationProjectSpec ]confirm: arg1  ^(Smalltalk hasClassNamed: #UIManager) ifTrue: [ (Smalltalk classNamed: #UIManager) default perform: #confirm: with: arg1 ] ifFalse: [ Warning signal: arg1.        true ]suspendSystemUpdateEventsDuring: arg1  ^arg1 valueresolveSpec: arg1 from: arg2  | tmp1 |  tmp1 := MetacelloGofer new.  tmp1 disablePackageCache.  (self repositoriesFrom: arg2 ignoreOverrides: true) do: [:arg3 |  tmp1 repository: arg3 ].  ^self resolveSpec: arg1 with: tmp1methodUpdateSelector  ^#with:preLoadDoIt  ^preLoadDoItrepositoryMap  repositoryMap == nil ifTrue: [ repositoryMap := Dictionary new ].  ^repositoryMaprepositoryDescriptions  ^(self configurationProjectSpecIfAbsent: [ self baselineProjectSpec ]) repositoryDescriptionstestAddGroupB  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: {(self groupSpec           name: 'Platform';           includes: 'Core';           yourself) .         (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself)}.  tmp2 := tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self deny: (tmp2 includes includes: 'Core').  self assert: (tmp2 includes includes: 'Tests')includesForPackageOrdering  ^self includesinfo  ^selfonUpgradeUseLoaded  self onUpgrade: [:arg1 :arg2 :arg3 |  arg1 useLoaded ]allPackagesForSpecs: arg1 visited: arg2  | tmp1 |  tmp1 := Dictionary new.  arg1 do: [:arg3 |  (arg3 resolveToAllPackagesIn: self spec visited: arg2) do: [:arg4 |  tmp1 at: arg4 name put: arg4 ] ].  ^tmp1 values asOrderedCollectionloadingSpecLoader  ^(MetacelloLoadingMCSpecLoader on: self spec)     shouldDisablePackageCache: self shouldDisablePackageCache;     loaderPolicy: self loaderPolicy copy;     yourselfloadPreloadDirective: arg1  | tmp1 |  (tmp1 := arg1 spec preLoadDoItBlock) ~~ nil ifTrue: [ arg1 evaluateSupplyingAnswers: [ tmp1 valueWithPossibleArgs: (Array with: arg1 loader with: arg1 spec) ].        MetacelloNotification signal: 'Evaluated -> ' , arg1 spec label , ' >> ' , arg1 spec preLoadDoIt value asString ]symbolicMethodSelectorAndPragma: arg1 symbolicVersionSymbol: arg2 on: arg3  arg3     nextPutAll: arg1 asString , ' spec';     cr;     tab;     nextPutAll: '<symbolicVersion: #' , arg2 asString printString;     nextPutAll: '>';     crpackageSpec  ^packageSpecbaselineGithubReferenceVI: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>baselineGithubReferenceVI:'.        arg1           baseline: 'External Core' with: [ arg1                 className: 'BaselineOfExternal';                 loads: 'Core';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           baseline: 'External Tests' with: [ arg1                 className: 'BaselineOfExternal';                 loads: 'Tests';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]blessing: arg1 constructor: arg2  arg2 blessingForVersion: arg1defaultRepositoryDescription  ^self class defaultRepositoryDescriptionmethodSource  | tmp1 |  tmp1 := WriteStream on: String new.  self methodSelectorAndPragma: self selector imports: self imports versionString: self versionString on: tmp1.  self methodSection: self pre: [:arg1 :arg2 |  tmp1           cr;           tab: arg2;           nextPutAll: 'spec for: ' , arg1 attributePrintString , ' do: [';           cr.        arg1 versionSpec configMethodOn: tmp1 last: arg1 methodSections isEmpty indent: arg2 + 1 ] last: false post: [:arg1 :arg2 :arg3 |  tmp1 nextPutAll: ' ].'.        (arg3 or: [ arg2 = 1 or: [ arg1 methodSections isEmpty and: [ arg2 = 1 ] ] ]) ifTrue: [ tmp1 cr ] ] indent: 0.  ^tmp1 contentsprojectReferenceSpec  ^self project projectReferenceSpecasString  ^self printStringproject  ^projectrepository: arg1  self repositoriesSpec add: arg1projectArg  ^projectArgcriticalWarningReasonCodes  ^super criticalWarningReasonCodes , #(#noLoadableVersions #noTests #testDeprecation #loadDeprecation #noVersionSpecified #missingRecommendedProjectSpecField)lesson02  ^Lesson title: 'Lesson 2' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version02:."For version 0.2, we''ve simply updated the package version to ''Example-Core-anon.9'', which can be confirmed by printing the following expression:"  (MetacelloTutorialConfig project version: ''0.2'') spec.ProfStef next.'setUp  super setUp.  self     setUpVersionReferences;     setUpMonticelloRepositorypushLoadDirective: arg1 during: arg2  | tmp1 |  self loadDirective add: arg1.  tmp1 := loadDirective.  loadDirective := arg1.  arg2 ensure: [ loadDirective := tmp1 ]aPackageIsLoaded  ^aPackageIsLoadedpreLoadDoIt  ^nilversionString  | tmp1 |  tmp1 := WriteStream on: String new.  self printOn: tmp1.  ^tmp1 contentscreateBitbucketRepository: arg1  | tmp1 |  tmp1 := Smalltalk at: #MCBitbucketRepository.  ^tmp1 location: arg1 descriptionbaseline40MethodSourceProjectFoe  ^(self class sourceCodeAt: #baseline40ProjectFoe:) asStringdefaultTimeout  ^60gtInspectorProjectsIn: arg1  < gtInspectorPresentationOrder: 40>  arg1 list     title: 'Projects';     display: [ self projects ]project: arg1  self addStatement: #projectArg: args: {arg1}packagesNeedSavingVisited: arg1 using: arg2 into: arg3  | tmp1 tmp2 tmp3 |  tmp1 := self resolveToLoadableSpec.  (arg1 includes: (tmp2 := tmp1 className)) ifTrue: [ ^self ].  arg1 add: tmp2.  (tmp3 := self versionOrNil) == nil ifTrue: [ ^self ].  tmp3 spec packagesNeedSavingVisited: arg1 into: arg3conflictOf12: arg1  < version: '1.2.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>conflictOf12:'.        arg1 author: 'dkh'.        arg1 timestamp: '6/1/2012 14:46' ].  arg1 for: #custom do: [ arg1 configuration: 'ExternalX' with: [ arg1                 operator: #=;                 version: '0.9.2';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]defaultTimeout  ^60000modifySymbolicVersionMethodFor: arg1 symbolicVersionSpecsDo: arg2  | tmp1 tmp2 tmp3 |  tmp1 := self constructor.  tmp2 := tmp1 extractSymbolicVersionPragmas at: arg1 ifAbsent: [ ^nil ].  tmp2 size > 1 ifTrue: [ self error: 'More than one pragma defining ' , arg1 printString ].  tmp3 := tmp2 at: 1.  methodSpec := MetacelloSymbolicVersionMethodSpec new     project: project;     selector: (MetacelloPlatform current selectorForPragma: tmp3);     category: (project configuration class whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma: tmp3));     versionString: arg1;     yourself.  (tmp1 extractSymbolicVersionSpecsFor: arg1) do: [:arg3 |  (arg2 value: arg3) ifTrue: [ self methodSpec addMethodSection: arg3 attributes versionString: arg3 versionString ] ]aPackageNotLoaded  ^aPackageNotLoadedprojectVersion  ^projectVersionintroductionText  ^'Covers project reference specifications:	1. Open a code browser on the MetacelloTutorialConfig class:"		MetacelloTutorialConfig browse.	"2. In the browser view the ''--all--'' category.	3. Have fun!"'difference: arg1  | tmp1 tmp2 tmp3 |  tmp1 := MetacelloVersionDiffReport new.  tmp2 := Dictionary new.  self projectDo: [:arg2 |  tmp2 at: arg2 name put: arg2 ] packageDo: [:arg3 |   ] groupDo: [:arg3 |   ].  tmp3 := Dictionary new.  arg1 projectDo: [:arg2 |  tmp3 at: arg2 name put: arg2 ] packageDo: [:arg3 |   ] groupDo: [:arg3 |   ].  tmp2 valuesDo: [:arg4 |  | tmp4 |        tmp4 := tmp3 at: arg4 name ifAbsent: [  ].        tmp4 == nil ifTrue: [ tmp1 removals at: arg4 name put: {arg4 versionString .                     ''} ] ifFalse: [ arg4 versionString = tmp4 versionString ifFalse: [ tmp1 modifications at: arg4 name put: {arg4 versionString .                           tmp4 versionString} ] ] ].  tmp3 valuesDo: [:arg5 |  (tmp2 at: arg5 name ifAbsent: [  ]) == nil ifTrue: [ tmp1 additions at: arg5 name put: {'' .                     arg5 versionString} ] ].  ^tmp1loadListForVersion: arg1  ^(self loads == nil or: [ self loads isEmpty ]) ifTrue: [ arg1 spec defaultPackageNames ] ifFalse: [ self loads ]testVersion17  self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-0').  self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-beta.0').  self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-beta')onWarningLog  self onWarning: [:arg1 |  MetacelloNotification signal: arg1 description.        arg1 resume ]doLoad  self loaderPolicy copy loadversionString: arg1  arg1 isSymbol ifTrue: [ self error: 'Version string ' , arg1 printString , ' for version method must be a String' ].  super versionString: arg1resolveToPackagesIn: arg1 visited: arg2  ^#()isEmpty  ^self configurationProjectSpecs isEmpty and: [ self baselineProjectSpecs isEmpty ]baseline07: arg1  < version: '0.7-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://www.example.com/Project'.        arg1           package: 'Project-Core' with: [ arg1 requires: 'Example-Core' ];           package: 'Project-Tests' with: [ arg1 requires: #('Project-Core' 'Example-Tests') ];           package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/Example' ];           package: 'Example-Tests' with: [ arg1                 requires: 'Example-Core';                 repository: 'http://www.example.com/Example' ];           package: 'Example-AddOn' with: [ arg1                 requires: 'Example-Core';                 repository: 'http://www.example.com/Example' ] ]ensuredMap  ensuredMap == nil ifTrue: [ ensuredMap := Dictionary new ].  ^ensuredMapisExplicit  ^falseversion11Issue156: arg1  < version: '1.1.0'>  arg1 for: #common do: [ arg1           baseline: 'Goo' with: [ arg1 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           yourself ]baseline31Fan: arg1  < version: '3.1-baseline'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 postLoadDoIt: #postLoad31baseline.        arg1           package: 'GoferBar';           package: 'GoferBeau' with: [ arg1                 requires: 'GoferBar';                 includes: #('GoferFoo') ];           package: 'GoferFar' with: [ arg1 requires: #('GoferFoo') ];           yourself.        arg1           project: 'GoferFoo' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '2.0';                 loads: 'GoferFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]getConfigurationProjectUnconditionalLoad: arg1  ^(self getConfigurationUnconditionalLoad: arg1) projecthasNoLoadConflicts: arg1  | tmp1 tmp2 |  tmp1 := self map values sort: [:arg2 :arg3 |  arg2 description <= arg3 description ].  tmp2 := arg1 map values sort: [:arg2 :arg3 |  arg2 description <= arg3 description ].  tmp1 size ~= tmp2 size ifTrue: [ ^false ].  1 to: tmp1 size do: [:arg4 |  | tmp3 tmp4 |        tmp3 := tmp1 at: arg4.        tmp4 := tmp2 at: arg4.        (tmp3 hasNoLoadConflicts: tmp4) ifFalse: [ ^false ] ].  ^truebaseline50Fan: arg1  < version: '5.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '5.0';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]onLock: arg1  self options at: #onLock put: arg1file  ^self externalReference nameloadLinearLoadDirective: arg1 gofer: arg2  self finalizeLoad: arg2.  super loadLinearLoadDirective: arg1 gofer: arg2versionString  | tmp1 |  tmp1 := WriteStream on: String new.  self printOn: tmp1.  ^tmp1 contentsisPartiallyCurrentAgainst: arg1  | tmp1 tmp2 |  tmp2 := MetacelloMCPartiallyLoadedStatus new.  tmp1 := self loader.  self specsNamed: arg1 projectDo: [:arg2 |  | tmp3 tmp4 |        tmp2 hasNoProject: false.        tmp3 := arg2 versionOrNil.        tmp3 ~~ nil ifTrue: [ (tmp4 := arg2 relativeCurrentVersion) ~~ nil ifTrue: [ tmp2 vrsnStatus add: tmp4 versionStatus ] ].        tmp4 ~~ nil ifTrue: [ tmp2 aProjectIsLoaded: true.              (tmp4 perform: #= with: tmp3) ifTrue: [ tmp2 aLoadedProjectIsExact: true ] ifFalse: [ (tmp4 perform: arg2 projectReference operator with: tmp3) ifTrue: [ tmp2 aLoadedProjectIsCurrent: true ] ifFalse: [ tmp2 aLoadedProjectIsNotCurrent: true ] ] ] ifFalse: [ tmp2 aProjectNotLoaded: true ] ] packageDo: [:arg3 |  tmp2 hasNoPackage: false.        arg3 currentPackageLoaded: [:arg4 :arg5 |  | tmp5 tmp6 tmp7 tmp8 tmp9 |              tmp2 aPackageIsLoaded: true.              arg4 isEmpty ifTrue: [ tmp2 aLoadedPackageIsNotCurrent: true ] ifFalse: [ tmp8 := tmp9 := false.                    arg4 do: [:arg6 |  tmp5 := arg6 name.                          tmp7 := GoferResolvedReference name: arg5.                          tmp6 := GoferResolvedReference name: tmp5.                          (tmp6 compare: tmp7 using: #=) ifTrue: [ tmp8 := true ] ].                    tmp8 ifTrue: [ tmp2 aLoadedPackageIsExact: true ] ifFalse: [ arg4 do: [:arg6 |  tmp5 := arg6 name.                                tmp7 := GoferResolvedReference name: arg5.                                tmp6 := GoferResolvedReference name: tmp5.                                (tmp6 compare: tmp7 using: #>=) ifTrue: [ tmp9 := true ] ].                          tmp9 ifTrue: [ tmp2 aLoadedPackageIsCurrent: true ] ifFalse: [ tmp2 aLoadedPackageIsNotCurrent: true ] ] ] ] notLoaded: [ tmp2 aPackageNotLoaded: true ] using: tmp1 ] groupDo: [:arg7 |  tmp2 abort: true.        ^tmp2 ].  ^tmp2on: arg1 project: arg2  self calculate: arg1 project: arg2methodSectionAttributes  | tmp1 |  tmp1 := Set new.  self methodSectionsDo: [:arg1 |  tmp1 addAll: arg1 attributes ].  ^tmp1repositoriesForSpec: arg1  self with: self root repositories during: arg1baseline10B: arg1  < version: '1.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'C' with: [ arg1                 className: 'MetacelloTestConfigurationOfIssue77C';                 loads: #('GoferFoo');                 versionString: '1.2';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           yourself ]version07: arg1  < version: '0.7' imports: #('0.7-baseline')>  arg1 for: #common do: [ arg1           package: 'Example-Core' with: 'Example-Core-anon.12';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1' ]packagesForSpecNamed: arg1  ^self packagesForSpecNamed: arg1 ifAbsent: [ ^#() ]methodSectionsDo: arg1  self methodSection: self do: arg1load: arg1  self load: arg1 onProjectDownGrade: [:arg2 :arg3 :arg4 |  arg2 allowEvenIfLocked ] onProjectUpgrade: [:arg2 :arg3 :arg4 |  arg2 allowEvenIfLocked ]import: arg1  importName := arg1ignoreImage: arg1  self loaderPolicy ignoreImage: arg1testVersion18  self deny: (self versionClass fromString: '1.0') < (self versionClass fromString: '1').  self deny: (self versionClass fromString: '1.0') < (self versionClass fromString: '1-0')packageSet  ^MetacelloTestsPackageSet named: nameaddMethodSection: arg1  arg1 parent: self.  self methodSections add: arg1projectName  ^self existingProjectRegistration projectNameprojectAttributes: arg1  projectAttributes := arg1extractPragmas: arg1 for: arg2 into: arg3  | tmp1 tmp2 |  (Pragma allNamed: arg1 in: arg2) do: [:arg4 |  tmp1 := arg4 argumentAt: 1.        tmp2 := arg3 at: tmp1 ifAbsent: [ | tmp3 |              tmp3 := OrderedCollection new.              arg3 at: tmp1 put: tmp3.              tmp3 ].        tmp2 add: arg4 ]projectArg: arg1  projectArg := arg1version128ProjectToolBox: arg1  < version: '1.2.8-baseline' imports: #('1.2.7-baseline')>  arg1 for: #common do: [ arg1 project: 'Example Project' with: [ arg1                 preLoadDoIt: nil;                 postLoadDoIt: nil ] ]applyAdd: arg1 copy: arg2 merge: arg3 remove: arg4  arg2 value: selfconfiguration  ^configurationloadPackageDirectives: arg1 gofer: arg2  MetacelloPlatform current do: [ | tmp1 tmp2 tmp3 |        tmp1 := MetacelloGoferLoad on: arg2.        tmp3 := OrderedCollection new.        arg1 do: [:arg3 |  | tmp4 |              arg2 disablePackageCache.              (tmp4 := self resolvePackageSpec: arg3 spec gofer: arg2) ~~ nil ifTrue: [ tmp1 addResolved: tmp4.                    tmp3 addAll: arg3 spec answers.                    arg3 resolvedReference: tmp4 ] ].        MetacelloNotification signal: 'Starting atomic load'.        tmp2 := [ tmp1 execute.        arg1 do: [:arg3 |  arg3 resolvedReference == nil ifTrue: [ MetacelloNotification signal: 'Already Loaded -> ' , arg3 file level: 2 ] ifFalse: [ MetacelloNotification signal: 'Loaded -> ' , arg3 file , ' --- ' , arg3 repository repositoryDescription , ' --- ' , arg3 resolvedReference repository description level: 2.                    arg3 resolvedReference workingCopy repositoryGroup addRepository: arg3 repository ] ].        MetacelloPlatform current clearCurrentVersionCache ].        tmp3 notEmpty ifTrue: [ tmp2 valueSupplyingMetacelloAnswers: tmp3 ] ifFalse: [ tmp2 value ].        MetacelloNotification signal: 'Finished atomic load' ] displaying: 'Atomic Load...'copyForRegistration: arg1 onWrite: arg2  | tmp1 |  arg1 configurationProjectSpecIfPresent: [:arg3 |  tmp1 := arg3 copy.        arg2 value: tmp1.        arg1 configurationProjectSpec: tmp1 ] ifAbsent: [ arg1 baselineProjectSpecIfPresent: [:arg3 |  tmp1 := arg3 copy.              arg2 value: tmp1.              arg1 baselineProjectSpec: tmp1 ] ifAbsent: [ arg2 value: nil ] ]unregister  | tmp1 |  self setDefaultsAndValidate: self projectSpec copy.  tmp1 := self projectSpec.  MetacelloProjectRegistration registrationForProjectSpec: tmp1 ifAbsent: [:arg1 |   ] ifPresent: [:arg2 :arg3 |  arg2 unregisterProject ].  self root: tmp1title  ^'atomic load'baseline35Foo: arg1  < version: '3.5'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.31';           package: 'GoferBeau' with: 'GoferBeau-dkh.54';           yourself.        arg1           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferFaux');           yourself ]groups  | tmp1 |  tmp1 := OrderedCollection new.  self spec projectDo: [:arg1 |   ] packageDo: [:arg1 |   ] groupDo: [:arg2 |  tmp1 add: arg2 ].  ^tmp1fetch: arg1  actionArg := #fetch: -> {arg1}normalVersion  normalVersion ifNil: [ normalVersion := #() ].  ^normalVersionattributes  attributes ifNil: [ attributes := OrderedCollection new ].  ^attributesprepostLoadsDo: arg1  self loadDirectives do: [:arg2 |  arg2 prepostLoadDo: arg1 ]baselineOrConfigurationName  ^self argumentAt: 3isLoadedMatchConstraintsAgainst: arg1  (self isPartiallyCurrentAgainst: arg1) isLoadedMatchConstraints: [:arg2 |  ^true ].  ^falsevalidateBaselineProject  | tmp1 |  tmp1 := self validateProjectCreationFrom: self configurationClass onError: [:arg1 |  self recordValidationError: 'Error creating project: ' , arg1 description , ' to reproduce evalutate the following: ''' , self configurationClass name asString , ' project''' callSite: #validateBaselineProject reasonCode: #projectCreationError.        ^self validationReport ].  ^self validateBaselineProject: tmp1projectClass  self className == nil ifTrue: [ ^nil ].  ^Smalltalk at: self className asSymbol ifAbsent: [  ]options: arg1  options := arg1project  | tmp1 |  ^project ifNil: [ tmp1 := MetacelloVersionConstructor on: self.        project := tmp1 project.        project loader: MetacelloNullRecordingMCSpecLoader new.        project ]ensureLoadedForDevelopmentUsing: arg1  | tmp1 |  tmp1 := arg1 ensuredMap at: self name ifAbsent: [ nil ].  self projectClass ~~ nil ifTrue: [ | tmp2 |        tmp2 := self versionOrNil.        tmp2 ~~ nil ifTrue: [ (self ensureConfigurationLoaded: tmp2 ensured: tmp1) ifTrue: [ arg1 ensureForDevelopment ifTrue: [ | tmp3 |                          (tmp3 := self projectClass) ~~ nil ifTrue: [ MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo #versionConstructor #loadableSpecNames) , {tmp3} ].                          self ensureLoadUsing: arg1 ] ifFalse: [ self projectPackage fetchUsing: arg1 ].                    arg1 ensuredMap at: self name put: #latest ].              ^self ] ].  tmp1 == nil ifTrue: [ arg1 ensureForDevelopment ifTrue: [ | tmp3 |              (tmp3 := self projectClass) ~~ nil ifTrue: [ MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo #versionConstructor #loadableSpecNames) , {tmp3} ].              self ensureLoadUsing: arg1 ] ifFalse: [ self fetchUsing: arg1 ].        arg1 ensuredMap at: self name put: #present ]stableVersionDMethodSourceSymbolic  ^(self class sourceCodeAt: #stableVersionD:) asStringloadUsing: arg1 gofer: arg2  self loadDirectives isEmpty ifTrue: [ ^self ].  arg1 loadLinearLoadDirective: self gofer: arg2possibleVersions  self shouldNotImplementasProjectRegistration  ^MetacelloProjectRegistration fromMCConfigurationProjectSpec: selfcompareVersions  ^Lesson title: '6. Compare versions' lesson: '"Occasionally, it is useful to view the mcz and project version changes between the #development symbolic version and the #stable symbolic version:"	(MetacelloToolBox compareVersionsIn: ConfigurationOfExample) inspect.	ProfStef next.'allProjectsDo: arg1  self allProjectsDo: arg1 withTraversedProjects: OrderedCollection newprojectPackage: arg1  self shouldBeMutable.  projectPackage := arg1project: arg1 constructor: arg2  arg2 projectForVersion: arg1baselineVersion20Issue154: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1           project: 'MetacelloExample' with: [ arg1                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]extractRepositoryFrom: arg1 to: arg2  ZipArchive new     readFrom: arg1;     extractAllTo: arg2 asFileReference.  arg1 asFileReference deleteblessing  blessing == nil ifTrue: [ ^self project valueHolderSpec           value: self project defaultBlessing;           yourself ].  ^blessingonConflict: arg1  self addStatement: #onConflict: args: {arg1}addBaselineOfSection: arg1 requiredProjects: arg2 packages: arg3 dependencies: arg4 includes: arg5 files: arg6 repositories: arg7 preLoadDoIts: arg8 postLoadDoIts: arg9 supplyingAnswers: arg10 groups: arg11 versionSpecsDo: arg12  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp1 := self createVersionSpec: self methodSpec versionString.  tmp2 := self buildMapFrom: arg4 for: arg3.  tmp3 := self buildMapFrom: arg5 for: arg3.  tmp4 := self buildMapFrom: arg6 for: arg3.  tmp5 := self buildMapFrom: arg7 for: arg3 , arg2.  tmp6 := self buildMapFrom: arg8 for: arg3.  tmp7 := self buildMapFrom: arg9 for: arg3.  tmp8 := self buildMapFrom: arg10 for: arg3.  arg2 do: [:arg13 |  | tmp9 |        tmp9 := self createProjectReferenceSpec: arg13.        tmp5 at: arg13 ifPresent: [:arg14 |  arg14 do: [:arg15 |  tmp9 repository: arg15 ] ].        tmp1 packages merge: tmp9 ].  arg3 do: [:arg16 |  | tmp9 |        tmp9 := self createPackageSpec: arg16.        tmp2 at: arg16 ifPresent: [:arg17 |  tmp9 requires: arg17 ].        tmp3 at: arg16 ifPresent: [:arg18 |  tmp9 includes: arg18 ].        tmp4 at: arg16 ifPresent: [:arg19 |  tmp9 file: arg19 ].        tmp5 at: arg16 ifPresent: [:arg14 |  arg14 do: [:arg15 |  tmp9 repository: arg15 ] ].        tmp6 at: arg16 ifPresent: [:arg20 |  tmp9 preLoadDoIt: arg20 ].        tmp7 at: arg16 ifPresent: [:arg21 |  tmp9 postLoadDoIt: arg21 ].        tmp8 at: arg16 ifPresent: [:arg22 |  tmp9 answers: arg22 ].        tmp1 packages merge: tmp9 ].  arg11 do: [:arg23 |  | tmp9 |        tmp9 := self createGroupSpec: arg23 key.        tmp9 includes: arg23 value.        tmp1 packages merge: tmp9 ].  arg12 value: tmp1.  self methodSpec addMethodSection: arg1 asMetacelloAttributePath versionSpec: tmp1latestVersionMatching: arg1 includedBlessings: arg2  ^nilbaseline: arg1 constructor: arg2  arg2 baselineForVersion: arg1versionDo: arg1  testValueHolderMergeSpec  | tmp1 tmp2 tmp3 |  tmp1 := self valueHolderSpec     value: 'an Object';     yourself.  tmp2 := self valueHolderSpec     value: 1.1;     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: tmp3 value equals: 1.1project  ^self projectWith: #()group: arg1 overrides: arg2  self root group: arg1 overrides: arg2 constructor: selfdetect: arg1  ^self detect: arg1 ifNone: [ self error: 'Object is not in the collection.' ]hasNoLoadConflicts: arg1  ^self className = arg1 className and: [ (self compareVersionsEqual: arg1) and: [ self operator == arg1 operator ] ]description  ^'Version ' , self versionString printString , ' is not defined in ' , self project label , '. Possible versions include: ' , self possibleVersions printStringresolveProjectVersionPattern: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  self projectPath ifNil: [ self error: 'projectPath must be set to resolve project version pattern.' ].  tmp1 := (self class projectVersionFromString: arg1) asString.  tmp2 := self downloadJSONTags.  tmp4 := tmp2 keys collect: [:arg2 |  | tmp7 |        tmp7 := self class projectVersionFromString: arg2.        tmp7 -> arg2 ].  tmp3 := tmp4 select: [:arg3 |  arg3 key match: tmp1 ].  tmp3 isEmpty ifTrue: [ projectVersion := arg1.        ^self error: 'No tags matching the pattern ' , arg1 printString , ' found for repository description ' , self description printString ].  tmp5 := tmp3 asArray sort: [:arg4 :arg5 |  arg4 key <= arg5 key ].  tmp6 := tmp5 last.  projectVersionPattern := arg1.  projectVersion := tmp6 valuedescription  ^self basicSpec description valueattributes: arg1  attributes := arg1 asMetacelloAttributeListconfigMethodCascadeOn: arg1 lastCascade: arg2  arg1 nextPutAll: 'repository: ' , self description printString.  (self username isEmpty not or: [ self password isEmpty not ]) ifTrue: [ arg1 nextPutAll: ' username: ' , self username printString , ' password: ' , self password printString ].  arg2 ifFalse: [ arg1           nextPut: $;;           cr ]merge: arg1  self subclassResponsibilitysetUpVersionReferences  versionReferences := OrderedCollection new.  versionReferences     add: (GoferVersionReference name: 'GoferBar.gemstone-dkh.68');     add: (GoferVersionReference name: 'GoferBar.gemstone-dkh.69');     add: (GoferVersionReference name: 'GoferBar.gemstone-dkh.70');     add: (GoferVersionReference name: 'GoferBar-dkh.68');     add: (GoferVersionReference name: 'GoferBar-dkh.69');     add: (GoferVersionReference name: 'GoferBar-dkh.70');     yourselfversionSpec  ^self specgoferBranch: arg1 project: arg2  | tmp1 |  tmp1 := self projectPackage.  tmp1 file: tmp1 name , '.' , arg1.  ^tmp1 goferBranchPackage: arg1 message: arg2projectClass  ^Smalltalk at: #MetacelloCypressBaselineProjecttestVersion12  self deny: (self versionClass fromString: '1.0') <= (self versionClass fromString: '0.7')packageSpecsInLoadOrderFor: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp7 := self map.  tmp1 := OrderedCollection new.  tmp2 := Set new.  self list do: [:arg2 |  | tmp11 |        tmp11 := tmp7 at: arg2 name ifAbsent: [  ].        (tmp11 == nil or: [ tmp1 includes: tmp11 ]) ifFalse: [ tmp11 projectDo: [:arg3 |  tmp1 add: arg3 ] packageDo: [:arg4 |  tmp1 add: arg4 ] groupDo: [:arg5 |  tmp2 add: arg5 ] ] ].  tmp1 isEmpty ifTrue: [ ^tmp1 , tmp2 asOrderedCollection ].  tmp3 := true.  tmp5 := 0.  tmp6 := tmp1 size * 2.  tmp10 := IdentitySet new.  [ tmp3 ] whileTrue: [ tmp5 := tmp5 + 1.        tmp5 > tmp6 ifTrue: [ self error: 'Apparent loop in before/after dependency definitions' ].        tmp3 := false.        tmp1 copy do: [:arg6 |  tmp3 := tmp3 or: [ self sortPackageSpecs: tmp1 packageSpec: arg6 groupLoops: tmp10 for: arg1 ] ] ].  tmp4 := Set new.  tmp3 := true.  tmp5 := 0.  tmp8 := tmp1 select: [:arg4 |  arg4 includesForPackageOrdering isEmpty not ].  tmp9 := true.  [ tmp3 ] whileTrue: [ | tmp12 |        tmp5 := tmp5 + 1.        tmp5 > 14 ifTrue: [ self error: 'Apparent loop in before/after dependency definitions' ].        tmp3 := false.        tmp12 := Set new.        tmp8 do: [:arg6 |  tmp12 addAll: (self applyIncludesTo: tmp1 for: arg6 firstTime: tmp9 for: arg1) ].        tmp12 size = tmp4 size ifTrue: [ tmp12 do: [:arg7 |  (tmp4 includes: arg7) ifFalse: [ tmp3 := true ] ] ] ifFalse: [ tmp3 := true ].        tmp4 := tmp12.        tmp9 := false ].  ^tmp1 , tmp2 asOrderedCollectiontestHasGroups  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--groups=core,tests').  self assert: tmp1 hasGroups.  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self deny: tmp1 hasGroupscalculateRepositoryDirectory  | tmp1 |  tmp1 := self class projectDirectoryFrom: self projectPath version: self projectVersion.  self repoPath isEmpty ifFalse: [ tmp1 := MetacelloPlatform current directoryFromPath: self repoPath relativeTo: tmp1 ].  ^tmp1createRepository  | tmp1 |  tmp1 := self project createRepository: self.  ^MCRepositoryGroup default repositories detect: [:arg1 |  arg1 = tmp1 ] ifNone: [ MCRepositoryGroup default addRepository: tmp1.        tmp1 ]for: arg1 do: arg2  arg1 setForDo: arg2 withInMetacelloConfig: selftestVersionSpec  | tmp1 |  tmp1 := self versionSpec     blessing: #baseline;     versionString: '1.0';     description: 'A description';     author: 'dkh';     timestamp: '1/24/2012 09:59';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  self assert: tmp1 blessing value equals: #baseline.  self assert: tmp1 versionString value equals: '1.0'.  self assert: tmp1 description value equals: 'A description'.  self assert: tmp1 author value equals: 'dkh'.  self assert: tmp1 timestamp value equals: '1/24/2012 09:59'.  self assert: tmp1 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp1 postLoadDoIt value identicalTo: #postLoadDoIt.  self should: [ tmp1 preLoadDoIt: '' ] raise: Error.  self should: [ tmp1 postLoadDoIt: '' ] raise: ErrorcreateGroupSpec: arg1  ^self project groupSpec     name: arg1;     yourselfversion108ProjectToolBox: arg1  < version: '1.0.8-baseline'>  arg1 for: #common do: [ arg1           package: 'Example-Core';           package: 'Example-Tests' with: [ arg1 requires: #('Example-Core') ] ]includesForPackageOrdering  ^#()configuration096Issue185: arg1  < version: '0.9.6'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration0956Issue185:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA3 , '/repository' ];           import: 'External' ]disableUndefinedSymbolTracking  ^truecheckSubCommand: arg1  (self availableSubCommands includes: arg1) ifFalse: [ self exitFailure: ('{1} subcommand does not exists' format: {arg1}) ]className: arg1  self addStatement: #classNameArg: args: {arg1}removals  removals ifNil: [ removals := Dictionary new ].  ^removalsimports  imports == nil ifTrue: [ imports := #() ].  ^importsdo: arg1  self map values do: arg1configMethodOn: arg1 indent: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := file ~~ nil.  tmp1 := self repositorySpecs size > 0.  tmp2 := self getPreLoadDoIt ~~ nil.  tmp3 := self getPostLoadDoIt ~~ nil.  tmp4 := (self requires isEmpty and: [ self includes isEmpty and: [ self answers isEmpty ] ]) not.  arg1     tab: arg2;     nextPutAll: 'spec '.  tmp5 | tmp1 | tmp2 | tmp3 | tmp4 ifTrue: [ arg1           cr;           tab: arg2 + 1;           nextPutAll: 'name: ' , self name printString;           nextPut: $;.        self configMethodBodyOn: arg1 hasName: true indent: arg2 + 1 ] ifFalse: [ arg1 nextPutAll: 'name: ' , self name printString ]configuration093Issue185: arg1  < version: '0.9.3'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration093Issue185:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA , '/repository' ];           import: 'External' ]setUpConfigurationOfProjectIssue119  | tmp1 |  tmp1 := self setUpConfigurationOfProjectIssue119dkh1.  tmp1 := self setUpConfigurationOfProjectIssue119dkh2: {tmp1}.  tmp1 := self setUpConfigurationOfProjectIssue119dkh3: {tmp1}.  tmp1 := self setUpConfigurationOfProjectIssue119dkh4: {tmp1}.  tmp1 := self setUpConfigurationOfProjectIssue119dkh5: {tmp1}.  tmp1 := self setUpConfigurationOfProjectIssue119dkh6: {tmp1}.  tmp1 := self setUpConfigurationOfProjectIssue119dkh7: {tmp1}resolveToLoadableSpec  ^self copycurrentlyLoadedExtensionClassesInVersion  ^self spec currentlyLoadedExtensionClassesInVersionconfiguration097Issue185: arg1  < version: '0.9.7'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration0957Issue185:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA4 , '/repository' ];           import: 'External' ]version104ProjectToolBox: arg1  < version: '1.0.4-baseline' imports: #('1.0.2-baseline')>  arg1 for: #common do: [ arg1 preLoadDoIt: nil ]repositories: arg1  repositories := arg1registrationFor: arg1 ifPresent: arg2 ifAbsent: arg3  | tmp1 |  tmp1 := arg1 baseName.  arg1 configurationProjectSpec ifNotNil: [:arg4 |  self configurationRegistry at: arg4 className ifPresent: [:arg5 |  ^arg2 value: arg5 ] ].  arg1 baselineProjectSpec ifNotNil: [:arg4 |  self baselineRegistry at: arg4 className ifPresent: [:arg5 |  ^arg2 value: arg5 ] ].  self configurationRegistry at: 'ConfigurationOf' , tmp1 ifPresent: [:arg5 |  ^arg2 value: arg5 ].  self baselineRegistry at: 'BaselineOf' , tmp1 ifPresent: [:arg5 |  ^arg2 value: arg5 ].  ^arg3 valuemethodSpec  ^methodSpecgetPostLoadDoIt  ^postLoadDoItintegrateCodeContributions  ^Lesson title: '5. Integrate code contributions' lesson: '"If other developers have commited new versions of the packages in your project you can integrate the changes into your configuration by first loading the latest packages in your project:"	(ConfigurationOfExample project version: #baseline) load."Then updating the mcz file specifications in #development version:"	MetacelloToolBox 		updateToLatestPackageVersionsIn: ConfigurationOfExample		description: ''- integrated code from Barney and Fred''."Then checkpoint the configuration:"	MetacelloToolBox 		saveConfigurationPackageFor: ''Example'' 		description: ''- integrated code from Barney and Fred''.ProfStef next.'repositorySpec  ^self repositorySpecClass for: selfbaselineVersion21Issue171: arg1  < version: '2.1-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1 className: 'MetacelloTestConfigurationOfFoo' ];           yourself.        arg1 package: 'GeauxFoo' ]mergeIntoMetacelloRepositories: arg1  arg1 addMember: selfversionDirectivesDepthFirstDo: arg1  testAlphaNumericVersion1  | tmp1 tmp2 |  self assert: (tmp1 := self versionClass fromString: '2.9.0') < (tmp2 := self versionClass fromString: '2.10.0')errorReasonCodes  ^#(#duplicateNames #shadowedNames #invalidDoItSelector #invalidVersionString #missingVersionImport #projectCreationError #noVersionsDefined #cannotResolveVersion #incompleteProjectSpec #incorrectVersionString #versionCompositionError #versionCreationError)version14: arg1  < version: '1.4' imports: #('1.4-baseline')>  arg1 for: #common do: [ arg1 blessing: #beta.        arg1 description: 'Add groups and Project-Extra'.        arg1           project: 'Example Default' with: '1.3';           project: 'Example Tests' with: '1.3'.        arg1           package: 'Project-Core' with: 'Project-Core-anon.2';           package: 'Project-Tests' with: 'Project-Tests-anon.2';           package: 'Project-Extra' with: 'Project-Extra-anon.1' ]compareVersionsEqual: arg1  | tmp1 tmp2 |  tmp1 := self versionOrNil.  tmp2 := arg1 versionOrNil.  tmp1 ifNil: [ ^tmp1 = tmp2 ].  tmp2 ifNil: [ ^false ].  ^tmp1 versionNumber = tmp2 versionNumberbaseline60MethodSourceFix  ^(self class sourceCodeAt: #baseline60Fix:) asStringresolveToLoadableSpec  ^nilbaseline10D: arg1  < version: '1.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'C' with: [ arg1                 className: 'MetacelloTestConfigurationOfIssue77C';                 loads: #('GoferFoo');                 versionString: '1.3';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           package: 'GoferBar' with: [ arg1 file: 'GoferBar-lr.1' ];           group: 'default' with: #('GoferBar');           yourself ]isExplicit  ^truerepositoriesForPackage: arg1  self repositoriesForSpec: arg1normalizeTagsData: arg1  ^self subclassResponsibilitytestCollapseZeros  self assert: (MetacelloVersionNumber fromString: '1.0-beta.24.0.1') collapseZeros printString equals: '1-beta.24.0.1'.  self assert: (MetacelloVersionNumber fromString: '1.0-beta.24.0.0.1') collapseZeros printString equals: '1-beta.24.0.0.1'.  self assert: (MetacelloVersionNumber fromString: '1.0.0-beta.24.0.0.1') collapseZeros printString equals: '1-beta.24.0.0.1'baselineForVersion: arg1  self setBaseline: arg1modifySection: arg1 sectionIndex: arg2 repository: arg3 requiredProjects: arg4 packages: arg5 dependencies: arg6 includes: arg7 files: arg8 repositories: arg9 preLoadDoIts: arg10 postLoadDoIts: arg11 supplyingAnswers: arg12 groups: arg13 versionSpecsDo: arg14  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 |  tmp1 := (self methodSpec findMethodSection: arg1 asMetacelloAttributePath sectionIndex: arg2) versionSpec.  arg3 ~~ nil ifTrue: [ tmp1 repository: arg3 ].  arg4 do: [:arg15 |  (tmp1 packages specListDetect: [:arg16 |  arg16 name = arg15 ] ifNone: [  ]) == nil ifTrue: [ tmp1 packages merge: (self createProjectReferenceSpec: arg15) ] ifFalse: [ self error: 'Project named: ' , arg15 printString , ' already exists.' ] ].  tmp10 := OrderedCollection new.  tmp9 := OrderedCollection new.  tmp11 := OrderedCollection new.  tmp1 projectDo: [:arg17 |   ] packageDo: [:arg18 |  tmp10 add: arg18 name ] groupDo: [:arg19 |  tmp9 add: arg19 name -> arg19 includes.        tmp11 add: arg19 name ].  arg5 do: [:arg20 |  (tmp10 includes: arg20) ifTrue: [ self error: 'Package named: ' , arg20 printString , ' already exists.' ] ifFalse: [ tmp10 add: arg20 ] ].  arg13 do: [:arg21 |  (tmp11 includes: arg21 key) ifTrue: [ self error: 'Group named: ' , arg21 key printString , ' already exists.' ] ifFalse: [ tmp9 add: arg21 ] ].  tmp2 := self buildMapFrom: arg6 for: tmp10.  tmp3 := self buildMapFrom: arg7 for: tmp10.  tmp4 := self buildMapFrom: arg8 for: tmp10.  tmp5 := self buildMapFrom: arg9 for: tmp10.  tmp6 := self buildMapFrom: arg10 for: tmp10.  tmp7 := self buildMapFrom: arg11 for: tmp10.  tmp8 := self buildMapFrom: arg12 for: tmp10.  tmp10 do: [:arg20 |  | tmp12 |        (arg5 includes: arg20) ifTrue: [ arg16 := self createPackageSpec: arg20.              tmp1 packages merge: arg16 ] ifFalse: [ arg16 := tmp1 packages specListDetect: [:arg22 |  arg22 name = arg20 ] ].        tmp2 at: arg20 ifPresent: [:arg23 |  arg16 setRequires: arg16 requires , arg23 ].        tmp3 at: arg20 ifPresent: [:arg24 |  arg16 setIncludes: arg16 includes , arg24 ].        tmp4 at: arg20 ifPresent: [:arg25 |  arg16 file: arg25 ].        tmp5 at: arg20 ifPresent: [:arg26 |  arg26 do: [:arg27 |  arg16 repository: arg27 ] ].        tmp6 at: arg20 ifPresent: [:arg28 |  arg16 preLoadDoIt: arg28 ].        tmp7 at: arg20 ifPresent: [:arg29 |  arg16 postLoadDoIt: arg29 ].        tmp8 at: arg20 ifPresent: [:arg30 |  arg16 answers: arg30 ] ].  tmp9 do: [:arg21 |  | tmp12 |        (tmp11 includes: arg21 key) ifFalse: [ arg16 := self createGroupSpec: arg21 key.              tmp1 packages merge: arg16.              arg16 setIncludes: arg16 includes , arg21 value ] ].  arg14 value: tmp1loaderPolicy  loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].  ^loaderPolicytestAddPackageD  | tmp1 |  tmp1 := self packagesSpec.  tmp1 add: 'Platform'.  tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ]packageRepository  ^(self class package mcWorkingCopy repositoryGroup repositories reject: [:arg1 |  arg1 = MCCacheRepository uniqueInstance ]) ifNotEmpty: [:arg2 |  arg2 anyOne ] ifEmpty: [ nil ]configMethodOn: arg1 indent: arg2  | tmp1 |  tmp1 := self map values.  tmp1 size = 0 ifTrue: [ ^arg1 nextPutAll: 'spec add: []' ].  tmp1 size = 1 ifTrue: [ arg1           tab: arg2;           nextPutAll: 'spec add: [';           cr.        tmp1 first configMethodOn: arg1 indent: arg2 + 1.        arg1           nextPut: $];           cr ] ifFalse: [ arg1           tab: arg2;           nextPutAll: 'spec'.        1 to: tmp1 size do: [:arg3 |  | tmp2 |              tmp2 := tmp1 at: arg3.              arg1                 tab: arg2 + 1;                 nextPutAll: 'add: [';                 cr.              tmp2 configMethodOn: arg1 indent: arg2 + 2.              arg1 nextPut: $].              arg3 < tmp1 size ifTrue: [ arg1 nextPut: $; ].              arg1 cr ] ]createDirectoryRepository: arg1  ^MCDirectoryRepository new     directory: (self fileHandleOn: arg1 description);     yourselfvalidateVersionSpecForSymbolicVersion: arg1 symbolicVersion: arg2  self subclassResponsibilityload  | tmp1 |  packages := Dictionary new.  self resolveToLoadableSpecs.  tmp1 := self loader.  packages values do: [:arg1 |  arg1 ensureLoadedForDevelopmentUsing: tmp1.        (MetacelloIgnorePackageLoaded signal: arg1) ifFalse: [ tmp1 ignoreImage ifFalse: [ (arg1 compareCurrentVersion: self operator targetVersionStatus: #(#allLoadedToSpec) using: tmp1) ifTrue: [ packages removeKey: arg1 name ] ] ] ].  packages notEmpty ifTrue: [ tmp1 preLoad: self versionSpec.        tmp1 load.        tmp1 postLoad: self versionSpec ].  ^tmp1resolveToPackagesIn: arg1 andProjects: arg2 visited: arg3  | tmp1 |  tmp1 := Dictionary new.  self resolveToPackagesIn: arg1 andProjects: arg2 into: tmp1 visited: arg3.  ^tmp1 values asOrderedCollectionpostLoad31baselineMethodSource  ^(self class sourceCodeAt: #postLoad31baseline) asStringcreateRepository: arg1  ^MCRepository newRepositoryFromSpec: arg1 on: selfversion122ProjectToolBox: arg1  < version: '1.2.2-baseline'>  arg1 for: #common do: [ arg1 project: 'Example Project' with: [ arg1                 className: 'MetacelloExampleProjectConfig';                 repository: 'http://www.example.com/ob' ] ]testMergeA  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     merge: (self repositorySpec           description: 'http://example.com/repository';           username: 'DaleHenrichs';           password: 'secret';           yourself).  tmp2 := tmp1 map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: 'http://example.com/repository'.  self assert: tmp2 type equals: 'http'.  self assert: tmp2 username equals: 'DaleHenrichs'.  self assert: tmp2 password equals: 'secret'latestVersion: arg1  ^nilmergeImportLoads: arg1  arg1 ifNotNil: [:arg2 |  self loads ifNil: [ loads := arg2 ] ifNotNil: [ loads := loads , arg2 ] ]evalDoits: arg1  evalDoits := arg1releaseVersion10  ^Lesson title: 'Release version 1.0' lesson: '"	1. Create configuration	2. Prepare to modify the version method for version 1.0:		- the project and package versions are not updated	3. Change the blessing to #release for the #common attribute	4. Note that the return value for the #attributeBlocksDo: block is true. If the return value is false, the versionSpec would not be included in the updated mehtod.	5. Compile and validate the #version10: method .	6. Remove version 1.0 from the definition of the #development symbolic version - the version is no longer in development		- the return value for the  #methodSectionsDo: block (like the #versionSpecsDo: block) determins whether the methodSection is carried forward or not	7. Compile and validate the #development: method	8. Prepare to define the symbolic version method #stable:	9. Define version 1.0 as the #stable symbolic version for #common	10. Compile and validate the #stable: method"	"1"	(MetacelloToolBox configurationNamed: ''Example'')"2."		modifyVersionMethodForVersion: ''1.0''			versionSpecsDo: [ :attribute :versionSpec | 					attribute == #common"3."						ifTrue: [ versionSpec blessing: #release ]."4."					true ];"5."		commitMethod;"6."		modifySymbolicVersionMethodFor: #development			symbolicVersionSpecsDo: [ :methodSection | methodSection versionString ~= ''1.0'' ];"7."		commitMethod;"8."		createSymbolicVersionMethod: ''stable:'' inCategory: ''symbolic versions'' forVersion: #stable;"9."		addSymbolicSection: #common version: ''1.0'';"10."	commitMethod."After evaluating the above expression, take a look at the updated method #version10, where you will see that the blessing has been updated to #release.Look at the #development: method (which should be empty) and the #stable: method"ProfStef next.'versionString: arg1  ^self projectReference versionString: arg1versionReferences  ^versionReferencesaddSectionsFrom: arg1 forBaseline: arg2 updateProjects: arg3 updatePackages: arg4 versionSpecsDo: arg5  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp1 := self constructor.  tmp2 := Set new.  tmp9 := Set new.  tmp3 := project attributes.  tmp5 := project version: arg1.  tmp10 := tmp5 versionString.  tmp4 := tmp5 spec.  tmp4 := tmp5 spec.  tmp6 := tmp1 extractAllVersionPragmas at: tmp10 ifAbsent: [ ^nil ].  tmp6 size > 1 ifTrue: [ self error: 'More than one pragma defining ' , tmp10 printString ].  tmp7 := tmp6 at: 1.  tmp8 := tmp7 numArgs = 2 ifTrue: [ tmp7 argumentAt: 2 ] ifFalse: [ #() ].  methodSpec imports: tmp8.  tmp1 extractMethodSectionsFor: tmp10.  tmp1 methodSections do: [:arg6 |  | tmp11 tmp12 |        tmp11 := arg6 versionSpec.        tmp12 := arg6 attributes.        arg2 ifFalse: [ (tmp3 includes: tmp12) ifTrue: [ self updateVersionSpec: tmp11 fullVersionSpec: tmp4 updateProjects: arg3 updatePackages: arg4 visited: tmp9 updated: tmp2 ] ].        (arg5 value: arg6 attributeOrPath value: tmp11) ifTrue: [ self methodSpec addMethodSection: arg6 attributePath versionSpec: tmp11 ] ]executeLoadFromArray: arg1  | tmp1 |  tmp1 := MetacelloMCVersionSpecLoader on: self spec.  tmp1 required: arg1.  loaderPolicy notNil ifTrue: [ tmp1 loaderPolicy: loaderPolicy ].  ^tmp1 loadcanUpgradeTo: arg1  ^(super canUpgradeTo: arg1) and: [ self file = arg1 file ]versionOfX090: arg1  < version: '0.9.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>versionOfX090:'.        arg1 author: 'dkh'.        arg1 timestamp: '5/4/2012 14:16' ].  arg1 for: #custom do: [ arg1 baseline: 'ExternalX' with: [ arg1 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]goferCommitPackageUsing: arg1 commitMessage: arg2  | tmp1 tmp2 tmp3 |  tmp2 := self spec repositorySpecs notEmpty ifTrue: [ self spec repositorySpecs ] ifFalse: [ arg1 ].  tmp1 := MetacelloGofer new.  tmp1 disablePackageCache.  tmp3 := self spec workingCopy.  arg1 do: [:arg3 |  | tmp4 |        tmp4 := arg3 createRepository.        (tmp3 possiblyNewerVersionsIn: tmp4) notEmpty ifTrue: [ self notify: 'There are possibly newer versions of the package ' , self spec name printString , ' in the repository ' , tmp4 description printString , '. Cancel and manually merge if you want to pick up the changes from the later version.' ].        tmp1 repository: tmp4 ].  tmp1 package: self spec name.  tmp1 commit: arg2.  ^trueprojectPath: arg1 projectVersion: arg2 repoPath: arg3  self projectPath: arg1.  self projectVersion: arg2.  self repoPath: arg3loadedRepositories  | tmp1 |  tmp1 := OrderedCollection new.  self repositoryMap values collect: [:arg1 |  tmp1 addAll: arg1 ].  ^tmp1version  self projectClass == nil ifTrue: [ ^nil ].  ^self versionString == nil ifTrue: [ | tmp1 |        self flag: 'deprecate after version 1.0'.        (tmp1 := self projectClassProject latestVersion) == nil ifTrue: [ self projectClassProject version: #bleedingEdge ] ifFalse: [ tmp1 ] ] ifFalse: [ self projectClassProject version: self versionString ]hasConflictWithBaselineSpec: arg1  arg1 name = self name ifFalse: [ ^true ].  arg1 project configuration className = self project configuration className ifFalse: [ ^true ].  ^((arg1 repositories isEmpty or: [ self repositories isEmpty ]) or: [ arg1 repositories hasNoLoadConflicts: self repositories ]) nottitle  ^'explicit load'printOn: arg1  arg1     nextPutAll: self class name asString;     nextPut: $(.  self versionSpec printOn: arg1.  arg1 nextPut: $)validateVersionTests: arg1  | tmp1 tmp2 |  tmp1 := IdentitySet new.  tmp2 := true.  arg1 currentlyLoadedClassesInVersion do: [:arg2 |  | tmp3 |        tmp3 := (arg2 withAllSuperclasses collect: #name) includes: #TestCase.        (tmp3 and: [ arg2 isAbstract not ]) ifTrue: [ tmp1 add: arg2 ] ].  tmp1 do: [:arg3 |  | tmp4 |        tmp4 := arg3 suite run.        tmp4 defects notEmpty ifTrue: [ self recordValidationError: 'Test failures in tests ' , arg3 name asString , ' for ' , arg1 versionString printString , ' in ' , self configurationClass name asString , ' ' , tmp4 printString versionString: arg1 versionString callSite: #validateVersionTests: reasonCode: #testFailures.              tmp2 := false ] ].  tmp1 isEmpty ifTrue: [ self recordValidationCriticalWarning: 'No test cases for ' , arg1 versionString printString , ' in ' , self configurationClass name asString versionString: arg1 versionString callSite: #validateVersionTests: reasonCode: #noTests.        tmp2 := false ].  ^tmp2record: arg1  actionArg := #record: -> {arg1}version20Issue119: arg1  < version: '2.0' imports: #('2.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: '2.0'.        arg1 package: 'GoferBar' with: 'GoferBar-jf.1' ]verifyVersionImportPragmas: arg1 definedIn: arg2  arg1 copy keysAndValuesDo: [:arg3 :arg4 |  [ arg4 do: [:arg5 |  (arg5 argumentAt: 2) do: [:arg6 |  arg2 at: arg6 ifAbsent: [ arg1 at: arg6 ifAbsent: [ ^self error: 'The imported version:' , arg6 printString , ' for version: ' , arg3 , ' referenced from the method: ' , (MetacelloPlatform current selectorForPragma: arg5) printString , ' in configuration ' , configuration class printString , ' has not been defined.' ] ] ] ] ] on: Error do: [:arg7 |  (MetacelloErrorInProjectConstructionNotification versionString: arg3 exception: arg7) ifTrue: [ ^arg7 pass ] ifFalse: [ arg1 removeKey: arg3.                    self errorMap at: arg3 put: arg7 ] ] ]repositoriesForProject: arg1  self repositoriesForSpec: arg1import: arg1  self root import: arg1 constructor: selfsymbolicVersionSymbols  ^self symbolicVersionMap keys asArray sort: [:arg1 :arg2 |  arg1 <= arg2 ]incrementMinorVersion  self size < 2 ifTrue: [ self at: 2 put: 0 ].  self incrementVersionAt: 2projectClass  ^MetacelloMCProjectsetUpNewerDependency  | tmp1 |  tmp1 := GoferVersionReference name: 'GoferUmbrella-lr.5'.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) with: (MCClassDefinition name: (tmp1 packageName copyWithout: $-) asSymbol superclassName: #Object category: tmp1 packageName asSymbol instVarNames: #() comment: ''))) dependencies: (Array with: (MCVersionDependency package: (MetacelloTestsMCPackage new name: 'GoferBarDependency') info: (monticelloRepository versionInfoFromVersionNamed: 'GoferBarDependency-lr.35')) with: (MCVersionDependency package: (MetacelloTestsMCPackage new name: 'GoferFooDependency') info: (monticelloRepository versionInfoFromVersionNamed: 'GoferFooDependency-lr.35'))))projectSpecLookupBlock  ^[:arg1 |  {(MetacelloProjectRegistration projectSpecForClassNamed: (MetacelloScriptEngine baselineNameFrom: arg1) ifAbsent: [  ])} ]extractPragmas: arg1 into: arg2  ^self extractPragmas: arg1 for: self configurationClass into: arg2extractSymbolicVersionPragmas  | tmp1 |  tmp1 := Dictionary new.  self extractPragmas: #symbolicVersion: into: tmp1.  ^tmp1incrementMajorVersion  self incrementNormalVersionAt: 1collectAllSymbolicVersionsFromVersionPragmasInto: arg1 using: arg2  | tmp1 tmp2 tmp3 |  tmp2 := self extractSymbolicVersionPragmas.  tmp2 keysAndValuesDo: [:arg3 :arg4 |  tmp1 := false.        arg4 do: [:arg5 |  tmp1 := true.              tmp3 := arg2 value: arg3 value: arg5 ].        tmp1 ifTrue: [ tmp3 == nil ifFalse: [ arg1 at: arg3 put: tmp3 ] ].        self reset ]bleedingEdge: arg1  < symbolicVersion: #bleedingEdge>  arg1 for: #'platformVersion1.x' version: '1.0-baseline'testPackageSpec  | tmp1 tmp2 |  tmp1 := self packageSpec     name: 'Package';     requires: 'AnotherPackage';     includes: 'IncludedPackage';     answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));     file: 'Package-dkh.1';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  self assert: tmp1 name equals: 'Package'.  self assert: tmp1 requires equals: #('AnotherPackage').  self assert: tmp1 includes equals: #('IncludedPackage').  self assert: tmp1 answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer')).  self assert: tmp1 file equals: 'Package-dkh.1'.  self assert: tmp1 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp1 postLoadDoIt value identicalTo: #postLoadDoIt.  tmp2 := tmp1 repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 type equals: 'directory'.  tmp2 := tmp1 repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 type equals: 'http'.  self assert: tmp2 username equals: 'dkh'.  self assert: tmp2 password equals: 'password'hasNoProject  ^hasNoProjectworkingCopy  ^self goferPackage workingCopymapMerge: arg1 into: arg2  | tmp1 |  tmp1 := arg2 at: arg1 name ifAbsent: [  ].  tmp1 == nil ifTrue: [ arg2 at: arg1 name put: arg1 spec copy ] ifFalse: [ arg2 at: arg1 name put: (tmp1 mergeSpec: arg1 spec) ]repositoryOverrides: arg1  self options at: #repositoryOverrides put: arg1hostname: arg1  hostname := arg1asString  ^self printStringresolvePackageSpecReferences: arg1 gofer: arg2  | tmp1 tmp2 tmp3 |  tmp3 := arg2.  self hasRepositoryOverrides not ifTrue: [ arg1 repositorySpecs notEmpty ifTrue: [ tmp3 := MetacelloGofer new.              (self repositoriesFrom: arg1 repositorySpecs) do: [:arg3 |  tmp3 repository: arg3 ] ] ].  (arg1 getFile == nil or: [ self shouldDisablePackageCache ]) ifTrue: [ tmp3 disablePackageCache ].  tmp1 := arg1 goferLoaderReference.  tmp2 := tmp1 resolveAllWith: tmp3.  tmp3 enablePackageCache.  ^tmp2baselineVersion10Issue119: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo ' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        arg1 package: 'GoferBar ' ]updatePackageRepositoriesFor: arg1  self workingCopy == nil ifTrue: [ ^self ].  self updatePackageRepositories: self repositorySpecs , arg1 repositorySpecsdefaultPlatformAttributes  | tmp1 |  Smalltalk at: #SystemVersion ifPresent: [:arg1 |  tmp1 := arg1 current version.        (tmp1 beginsWith: 'Pharo') ifTrue: [ ^#(#squeakCommon #pharo) ].        (tmp1 beginsWith: 'Squeak') ifTrue: [ ^#(#squeakCommon #squeak) ].        (self string: tmp1 includesSubstring: 'Pharo') ifTrue: [ ^#(#squeakCommon #pharo) ].        (self string: tmp1 includesSubstring: 'Squeak') ifTrue: [ ^#(#squeakCommon #squeak) ].        self error: 'Unrecognized version of Squeak/Pharo: ' , tmp1 ].  ^#(#gemstone)getOrCreateIcebergRepository  | tmp1 |  tmp1 := self perform: Iceberg remoteTypeSelector.  ^IceRepository registry detect: [:arg1 |  arg1 isCloneOfUrl: tmp1 ] ifNone: [ | tmp2 |        tmp2 := IceGitRemote url: tmp1.        self createIcebergRepositoryWithFallbackFor: tmp2 url: tmp1 ]prepostLoadDo: arg1  value: arg1  value := arg1loadUsing: arg1 gofer: arg2  arg1 loadPreloadDirective: selfconfigMethodOn: arg1 last: arg2 indent: arg3  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := (tmp1 := self repositoriesSpec) ~~ nil and: [ tmp1 list isEmpty not ].  tmp4 := self import ~~ nil.  tmp3 := false.  self packagesSpec list do: [:arg4 |  arg4 spec projectDo: [:arg5 |  arg4 spec name ~~ nil ifTrue: [ tmp3 := true ] ] packageDo: [:arg6 |  arg4 spec name ~~ nil ifTrue: [ tmp3 := true ] ] groupDo: [:arg7 |  arg4 spec name ~~ nil ifTrue: [ tmp3 := true ] ] ].  self configMethodBasicOn: arg1 last: (tmp2 | tmp3 | tmp4) not indent: arg3.  tmp4 ifTrue: [ self configMethodValueOn: arg1 for: self import selector: 'import:' last: (tmp2 | tmp3) not indent: arg3 ].  tmp2 ifTrue: [ tmp1 map values size = 1 ifTrue: [ arg1                 tab: arg3;                 nextPutAll: 'spec repository: ';                 nextPutAll: tmp1 map values first description printString , '.'.              tmp3 ifTrue: [ arg1 cr ] ] ifFalse: [ self configMethodOn: arg1 for: tmp1 selector: 'repositories:' last: tmp3 not indent: arg3 ] ].  self configPackagesSpecMethodOn: arg1 indent: arg3.  arg2 ifFalse: [ arg1 cr ]label  ^self configuration class nameload  ^self doLoadRequiredFromArray: self spec defaultPackageNamesversion03: arg1  < version: '0.3'>  arg1 for: #common do: [ arg1           package: 'Example-Core' with: [ arg1                 file: 'Example-Core-anon.10';                 repository: 'http://www.example.com/Example' ];           package: 'Example-Tests' with: [ arg1                 file: 'Example-Tests-anon.3';                 repository: 'http://www.example.com/Example' ] ]< arg1  | tmp1 tmp2 |  arg1 species = self species ifFalse: [ ^false ].  tmp1 := self collapseZeros.  tmp2 := arg1 collapseZeros.  (tmp1 ~~ self or: [ tmp2 ~~ arg1 ]) ifTrue: [ ^tmp1 compareLessThan: tmp2 ].  ^self compareLessThan: arg1lesson04  getBaselineUnconditionalLoad: arg1  | tmp1 |  tmp1 := self projectSpec.  Smalltalk at: tmp1 className asSymbol ifPresent: [:arg2 |  arg1 ifFalse: [ ^arg2 ] ].  tmp1 := self lookupProjectSpecFor: tmp1.  [ tmp1 projectPackage load ] on: MetacelloIgnorePackageLoaded do: [:arg3 |  arg3 resume: true ].  ^Smalltalk at: tmp1 className asSymbolancestors  ^self goferPackage ancestorsprojectSpec  ^projectSpecrepositories  ^self projectSpec repositoriestearDownPackageNames  ^{self projectName}evaluateStatus: arg1  ^self abort ifTrue: [ false ] ifFalse: [ (self hasNoProject or: [ self vrsnStatus isEmpty ]) ifTrue: [ true ] ifFalse: [ | tmp1 |              tmp1 := true.              vrsnStatus do: [:arg2 |  (arg1 includes: arg2) ifFalse: [ tmp1 := false ] ].              tmp1 ] ]initializeName: arg1 packageFilename: arg2  name := arg1.  packageFilename := arg2allPackagesLoaded: arg1  | tmp1 tmp2 |  (tmp1 := self versionOrNil) == nil ifTrue: [ ^false ].  tmp2 := OrderedCollection new.  (self loadListForVersion: tmp1) do: [:arg2 |  tmp1 packages do: [:arg3 |  (arg3 isPackageLoaded: arg1) ifFalse: [ ^false ] ] ].  ^trueloaderPolicy: arg1  loaderPolicy := arg1explanation  ^explanationsavePackage  | tmp1 tmp2 |  ^(file notNil and: [ self name = self file ]) ifTrue: [ tmp1 := self loader latestPackage: self name fromRepository: self repositorySpecs.        tmp2 := self copy.        tmp2 file: tmp1.        tmp2 savePackage ] ifFalse: [ self loader savePackageUsing: self repositorySpecs ]versionDoesNotExistException  ^versionDoesNotExistExceptionoverrideProjectSpec  ^overrideProjectSpecaLoadedPackageIsNotCurrent  ^aLoadedPackageIsNotCurrentsetUpIssue156ConfigurationOfProjectSoo  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'ConfigurationOfProjectSoo-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString selector: 'version10Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue156:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version11Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version11Issue156:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue156:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version30Issue156:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue156:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())projectClassMethodSource  ^(self class class sourceCodeAt: #project) asStringrepository: arg1  self addStatement: #repositoryArg: args: {arg1}downloadJSON: arg1 username: arg2 pass: arg3  self subclassResponsibilityrepository: arg1 constructor: arg2  arg2 repositoryForPackage: arg1pushLinearLoadDirectivesDuring: arg1 for: arg2  self pushLoadDirective: (MetacelloLinearLoadDirective loader: arg2) during: arg1applyAdd: arg1 copy: arg2 merge: arg3 remove: arg4  arg1 value: selfdisableUndefinedSybolUpdates  ^nilpreloads  preloads == nil ifTrue: [ preloads := OrderedCollection new ].  ^preloadssetUpBaselineGithubReferenceXX  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefXX-dkh.1'.  tmp2 := #BaselineOfGithubRefXX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineGithubReferenceXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceXX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4baselineGithubReferenceIV: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>baselineGithubReferenceIV:'.        arg1 baseline: 'External' with: [ arg1 repository: 'http://ss3.gemtalksystems.com/ss/external' ] ]testSemanticVersioningSpecItem11  self validateSemanticVersionStrings: #('1.0.0+build.1' '1.3.7+build.11.e0f985a')validateProjects: arg1  arg1 do: [:arg2 |  self validate: (arg2 at: 1) expConfigVersion: (arg2 at: 2) expConfigRepo: (arg2 at: 3) expBaselineClassName: (arg2 at: 4) expBaselineVersion: (arg2 at: 5) expBaselineRepo: (arg2 at: 6) ]setUpConfigurationOfProjectIssue115  | tmp1 |  tmp1 := self setUpConfigurationOfProjectIssue115dkh1.  tmp1 := self setUpConfigurationOfProjectIssue115dkh2: {tmp1}handleResolutionFor: arg1  ^arg1 handleLookupProjectSpecForLoad: selfcanDowngradeTo: arg1  ^(super canDowngradeTo: arg1) and: [ self file = arg1 file ]repositoryOverrides: arg1  self loaderPolicy overrideRepositories: arg1conditionResult: arg1  ^((((((arg1 copyReplaceAll: '#preloadForAddOn' with: '#''preloadForAddOn''') copyReplaceAll: '#postloadForAddOn' with: '#''postloadForAddOn''') copyReplaceAll: '#baseline' with: '#''baseline''') copyReplaceAll: '#preloadForVersion' with: '#''preloadForVersion''') copyReplaceAll: '#postloadForVersion' with: '#''postloadForVersion''') copyReplaceAll: '#preloadForProject' with: '#''preloadForProject''') copyReplaceAll: '#postloadForProject' with: '#''postloadForProject'''preLoadDoIt  ^preLoadDoIthasRepository  ^falseisValid  projectName ifNil: [ ^false ].  configurationProjectSpec ifNil: [ ^baselineProjectSpec notNil ].  ^baselineProjectSpec isNilnormalizeTagsData: arg1  | tmp1 |  arg1 at: 'error' ifPresent: [:arg2 |  self error: 'Error accessing tags for bitbucket project: ' , self projectPath printString , ' -> ' , (arg2 at: 'message') printString , ((arg2 at: 'detail') ifNil: [ '' ] ifNotNil: [:arg3 |  ' :: ' , arg3 printString ]) ].  tmp1 := Dictionary new.  arg1 keysAndValuesDo: [:arg4 :arg5 |  | tmp2 |        tmp2 := arg5 at: 'node'.        tmp1 at: arg4 put: tmp2 ].  ^tmp1bleedingEdge  ^self version: #bleedingEdgeversionString: arg1 constructor: arg2  arg2 versionStringForVersion: arg1issue: arg1  issue := arg1versionSpecClass  ^MetacelloMCVersionSpecloadUsing: arg1 gofer: arg2  | tmp1 |  tmp1 := self resolveToLoadableSpec.  tmp1 loader: arg1.  ^tmp1 loadvalue  ^valueasProjectSpecForVersion: arg1  | tmp1 tmp2 |  tmp1 := arg1 ifNil: [ ^self ] ifNotNil: [ arg1 versionSpec project ].  tmp2 := tmp1 configurationOfProjectSpecClass for: tmp1.  self copyForScriptingInto: tmp2.  tmp2 loader: self loader.  self assert: (self className beginsWith: 'BaselineOf') not.  ^tmp2cacheRepository: arg1  self addStatement: #cacheRepository: args: {arg1}testVersion09  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '1.0'.  tmp2 := self versionClass fromString: '0.7'.  self assert: tmp1 >= tmp2.  self assert: tmp2 <= tmp1authorName  ^Author fullNamelockConfiguration14: arg1  < version: '1.4.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>lockConfiguration14: '.        arg1 configuration: 'ExternalX' with: [ arg1                 version: #unstable;                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]loads  ^loadsextractRepositoryFrom: arg1 to: arg2  self subclassResponsibilitybaselineVersion12Issue154: arg1  < version: '1.2-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1           project: 'MetacelloExample' with: [ arg1                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 projectPackage: [ arg1                       name: 'MetacelloExampleTestConfigurationIssue154';                       file: 'MetacelloExampleTestConfigurationIssue154.gemstone';                       repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ];           yourself ]file  ^nillesson01  primeStackCacheWith: arg1 doing: arg2  self useStackCacheDuring: [:arg3 |  ^arg2 value ] defaultDictionary: arg1project: arg1 copyFrom: arg2 with: arg3 constructor: arg4  arg4 projectForVersion: arg1 copyFrom: arg2 with: arg3versionString: arg1  versionString := arg1symbolicVersion: arg1  symbolicVersion := arg1resolveToLoadableSpecs: arg1 forLoad: arg2 map: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 copy.  tmp2 := Set new.  tmp3 := self packages map.  [ tmp1 isEmpty ] whileFalse: [ tmp4 := Set new.        tmp1 do: [:arg4 |  (self resolveToLoadableSpec: arg4 forLoad: arg2 forMap: tmp3 packages: arg3) do: [:arg5 |  tmp4 addAll: arg5 requires.                    tmp4 addAll: arg5 includes ] ].        tmp2 addAll: tmp1.        tmp4 removeAllFoundIn: tmp2.        tmp1 := tmp4 ].  arg3 keys do: [:arg6 |  (tmp5 := (arg3 at: arg6) resolveToLoadableSpec) == nil ifTrue: [ arg3 removeKey: arg6 ] ifFalse: [ arg3 at: arg6 put: (arg3 at: arg6) resolveToLoadableSpec ] ]loadAtomicLoadDirective: arg1 gofer: arg2  arg1 loadDirectives do: [:arg3 |  arg3 loadUsing: self gofer: arg2 ]newProjectRegistration  ^newProjectRegistrationignoreImage: arg1  self options at: #ignoreImage put: arg1externalBaselineX: arg1  < baseline>  arg1 description: 'MetacelloScriptingResource>>externalBaselineX:'.  arg1     package: 'External-CoreX';     package: 'External-TestsX' with: [ arg1 requires: 'External-CoreX' ];     yourself.  arg1     group: 'Core' with: #('External-CoreX');     group: 'default' with: #('Core');     group: 'Tests' with: #('External-TestsX');     yourselfsetUpConfigurationOfProjectIssue154dkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfMetacelloProjectIssue154-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion10Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue154:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion11Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion11Issue154:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion12Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion12Issue154:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion13Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion13Issue154:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion20Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue154:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion30Issue154:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion30Issue154:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4projectSpec: arg1  projectSpec := arg1goferLoaderReference  ^file == nil ifTrue: [ GoferPackageReference name: self name ] ifFalse: [ MetacelloGoferPackage name: self name packageFilename: self file ]finalizeLoad: arg1  remove: arg1  arg1 removeFromMetacelloRepositories: selfcreateIcebergRepositoryWithFallbackFor: arg1 url: arg2  | tmp1 |  tmp1 := arg2.  [ ^self createIcebergRepositoryFor: tmp1 ] on: IceAuthenticationError do: [:arg3 |  self crTrace: ('I got an error while cloning: {1}. I will try to clone the HTTPS variant.' format: {arg3 messageText}).        tmp1 := arg1 httpsUrl.        arg3 retry ]record: arg1  ^self execute: #record: args: {arg1}from  ^fromcopyForRegistration: arg1 onWrite: arg2  self error: 'Should be converting to configuration spec for the registration, so we should not get here'hasNoLoadConflicts: arg1  ^(super hasNoLoadConflicts: arg1) and: [ (self repositories isEmpty or: [ arg1 repositories isEmpty ]) or: [ self repositories hasNoLoadConflicts: arg1 repositories ] ]releaseVersion  ^Lesson title: '7. Release development version' lesson: '"When you ready to release the #development version of your project, the following things need to be done:	1. Change #blessing of version to #release	2. Set the #development symbolic version to #notFound (no longer in development)	3. Set the #stable symbolic version to the current #development version	4. Save the configuration	5. Copy the configuration to http://www.squeaksource.com/MetacelloRepository (optional).Steps 1-4 are performed by the following expression:"	MetacelloToolBox 		releaseDevelopmentVersionIn: ConfigurationOfExample		description: ''- release version 1.0''.	"If you want to copy the saved configuration to another repository, use the following expression:"	MetacelloToolBox 		copyConfiguration: ConfigurationOfExample 		to: ''http://www.example.com/MetacelloRepository''.ProfStef next.'ignoreImage  ^self options at: #ignoreImage ifAbsent: [ false ]getBaselineProjectUnconditionalLoad: arg1  | tmp1 |  tmp1 := (self getBaselineUnconditionalLoad: arg1) project.  tmp1 version spec repositories: self repositories copy.  ^tmp1defaultAction  Warning signal: 'LOCK ENFORCED: Attempt to ' , self operationString printString , ' new project: ' , self newProjectRegistration printString printString , ' when existing project: ' , self existingProjectRegistration printString printString , ' is locked. New project not loaded. Use #onLock: to intercept.'.  ^self disallowupdatePackageRepositories: arg1  | tmp1 |  MetacelloNotification signal: '  Looking up version -> ' , self file.  tmp1 := self loader resolveSpec: self from: arg1.  MetacelloNotification signal: 'Update repositoryGroup -> ' , tmp1 name , ' ' , tmp1 repository description.  tmp1 version workingCopy repositoryGroup addRepository: tmp1 repositoryfileForPackage: arg1  self root file: arg1setUpConfigurationOfProjectIssue125  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue125-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'version30Issue125:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue125:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion20Issue125:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue125:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion30Issue125:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion30Issue125:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4version50MethodSourceFoo  ^(self class sourceCodeAt: #version50Foo:) asStringhandleResolutionFor: arg1  ^arg1 handleEnsureProjectLoadedForDevelopment: selfrecordingSpecLoader  ^(MetacelloNullRecordingMCSpecLoader on: self spec)     shouldDisablePackageCache: self shouldDisablePackageCache;     loaderPolicy: self loaderPolicy copy;     yourselfprojectClass  ^MetacelloMCProjectcreate10Baseline  ^Lesson title: 'Create 1.0 Baseline' lesson: '"	1. Create configuration		- class named ConfigurationOfExample created if it does not already exist.	2. Prepare to define baseline version method		- selector, category and version number defined	3. Define baseline project structure		- repository		- external project ''Shout''		- packages ''ProfStef-Core'' and ''ProfStef-Tests'', plus dependencies	4. Compile the #baseline10: method		- version method compiled and validated "	"1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		createVersionMethod: ''baseline10:'' inCategory: ''baselines'' forVersion: ''1.0-baseline'';"3."		addSection: #common			repository: ''http://www.squeaksource.com/ProfStef''			requiredProjects: #(''Shout'')			packages: #(''ProfStef-Core'' ''ProfStef-Tests'')			dependencies:				{(''ProfStef-Core'' -> #(''Shout'')).				(''ProfStef-Tests'' -> #(''ProfStef-Core''))}			groups:				{(''default'' -> #(''Core'')).				(''Core'' -> #(''ProfStef-Core'')).				(''Tests'' -> #(''ProfStef-Tests'')).				(''Core Tests'' -> #(''Core'' ''Tests''))}			versionSpecsDo: [ :versionSpec | versionSpec blessing: #baseline ];"4."		commitMethod."After evaluating the above expression, browse the configuration:"	ConfigurationOfExample browse.	"and look at the generated method #baseline10:. Note that the symbolic version #bleedingEdge is used for the Shout project."ProfStef next.'httpsUrl  ^'https://github.com/' , projectPath , '.git'configurationGithubReferenceV: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configurationGithubReferenceV:'.        arg1           project: 'External' with: [ arg1                 className: 'ConfigurationOfExternal';                 version: '0.9.0';                 loads: 'Core';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ];           project: 'External Tests' copyFrom: 'External' with: [ arg1 loads: 'Tests' ] ]addSection: arg1 repository: arg2 requiredProjects: arg3 packages: arg4 dependencies: arg5 includes: arg6 files: arg7 repositories: arg8 preLoadDoIts: arg9 postLoadDoIts: arg10 supplyingAnswers: arg11 groups: arg12 versionSpecsDo: arg13  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp1 := self createVersionSpec: self methodSpec versionString.  arg2 ~~ nil ifTrue: [ tmp1 repository: arg2 ].  tmp2 := self buildMapFrom: arg5 for: arg4.  tmp3 := self buildMapFrom: arg6 for: arg4.  tmp4 := self buildMapFrom: arg7 for: arg4.  tmp5 := self buildMapFrom: arg8 for: arg4 , arg3.  tmp6 := self buildMapFrom: arg9 for: arg4.  tmp7 := self buildMapFrom: arg10 for: arg4.  tmp8 := self buildMapFrom: arg11 for: arg4.  arg3 do: [:arg14 |  | tmp9 |        tmp9 := self createProjectReferenceSpec: arg14.        tmp5 at: arg14 ifPresent: [:arg15 |  arg15 do: [:arg16 |  tmp9 repository: arg16 ] ].        tmp1 packages merge: tmp9 ].  arg4 do: [:arg17 |  | tmp9 |        tmp9 := self createPackageSpec: arg17.        tmp2 at: arg17 ifPresent: [:arg18 |  tmp9 requires: arg18 ].        tmp3 at: arg17 ifPresent: [:arg19 |  tmp9 includes: arg19 ].        tmp4 at: arg17 ifPresent: [:arg20 |  tmp9 file: arg20 ].        tmp5 at: arg17 ifPresent: [:arg15 |  arg15 do: [:arg16 |  tmp9 repository: arg16 ] ].        tmp6 at: arg17 ifPresent: [:arg21 |  tmp9 preLoadDoIt: arg21 ].        tmp7 at: arg17 ifPresent: [:arg22 |  tmp9 postLoadDoIt: arg22 ].        tmp8 at: arg17 ifPresent: [:arg23 |  tmp9 answers: arg23 ].        tmp1 packages merge: tmp9 ].  arg12 do: [:arg24 |  | tmp9 |        tmp9 := self createGroupSpec: arg24 key.        tmp9 includes: arg24 value.        tmp1 packages merge: tmp9 ].  arg13 value: tmp1.  self methodSpec addMethodSection: arg1 asMetacelloAttributePath versionSpec: tmp1addTo: arg1  spec preLoadDoIt value ~~ nil ifTrue: [ arg1 add: self ]bypassProgressBars  bypassProgressBars == nil ifTrue: [ bypassProgressBars := false ].  ^bypassProgressBarsauthor  ^self spec author valuetestVersion10  | tmp1 tmp2 |  self assert: (tmp1 := (({(self versionClass fromString: '1.0.0') .         (self versionClass fromString: '0.7.0') .         (self versionClass fromString: '0.8.0') .         (self versionClass fromString: '0.9.0') .         (self versionClass fromString: '1.0.1')} sort: [:arg1 :arg2 |  arg1 <= arg2 ]) collect: [:arg3 |  arg3 versionString ]) asArray) equals: (tmp2 := #('0.7.0' '0.8.0' '0.9.0' '1.0.0' '1.0.1'))version117ProjectToolBox: arg1  < version: '1.1.7-baseline' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 package: 'Example-Core' overrides: [ arg1 preLoadDoIt: #alternatePreloadForCore ] ]configMethodCascadeOn: arg1 member: arg2 last: arg3 indent: arg4  arg2 methodUpdateSelector == #remove: ifTrue: [ arg1 nextPutAll: 'removeGroup: ' , self name printString ] ifFalse: [ arg1           nextPutAll: 'group: ' , self name printString;           space;           nextPutAll: arg2 methodUpdateSelector asString , ' #('.        self includes do: [:arg5 |  arg1 nextPutAll: arg5 printString , ' ' ].        arg1 nextPut: $) ].  arg3 ifTrue: [ arg1 nextPut: $. ] ifFalse: [ arg1           nextPut: $;;           cr ]hasRepositoryOverrides  ^self loaderPolicy hasRepositoryOverridesprint: arg1 prefix: arg2 on: arg3  | tmp1 |  tmp1 := true.  arg1 do: [:arg4 |  tmp1 ifTrue: [ tmp1 := false.              arg2 ifNotNil: [ arg3 nextPut: arg2 ] ] ifFalse: [ arg3 nextPut: $. ].        arg3 nextPutAll: arg4 asString ]runCase  | tmp1 |  tmp1 := MetacelloPlatform current bypassGoferLoadUpdateCategories.  [ MetacelloPlatform current bypassGoferLoadUpdateCategories: true.  ^MetacelloPlatform current suspendSystemUpdateEventsDuring: [ super runCase ] ] ensure: [ MetacelloPlatform current bypassGoferLoadUpdateCategories: tmp1 ]configurationGithubReferenceIV: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configurationGithubReferenceIV:'.        arg1 project: 'External' with: [ arg1                 className: 'ConfigurationOfExternal';                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]configurationRegistry  configurationRegistry ifNil: [ configurationRegistry := Dictionary new ].  ^configurationRegistryaLoadedProjectIsCurrent: arg1  aLoadedProjectIsCurrent := arg1project  ^selfsetUpRepositories  | tmp1 |  super setUpRepositories.  tmp1 := MetacelloPlatform current defaultDirectory.  configurationDirectory := MetacelloPlatform current directoryFromPath: self configurationPath relativeTo: tmp1.  externalDirectory := MetacelloPlatform current directoryFromPath: self externalPath relativeTo: tmp1.  sampleDirectory := MetacelloPlatform current directoryFromPath: self samplePath relativeTo: tmp1.  configurationDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: configurationDirectory ].  MetacelloPlatform current ensureDirectoryExists: configurationDirectory.  externalDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: externalDirectory ].  MetacelloPlatform current ensureDirectoryExists: externalDirectory.  sampleDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: sampleDirectory ].  MetacelloPlatform current ensureDirectoryExists: sampleDirectory.  configurationRepository := MetacelloScriptingResource current configurationRepository.  externalRepository := MetacelloScriptingResource current externalRepository.  testingEnvironment at: 'Metacello_Configuration_Test_Repository' asSymbol put: externalRepository.  monticelloRepository := MetacelloMonticelloResource current monticelloRepository.  testingEnvironment at: 'Metacello_Gofer_Test_Repository' asSymbol put: monticelloRepository.  mczConfigurationRepository := MetacelloConfigurationResource current monticelloRepository.  testingEnvironment at: 'Metacello_MczConfiguration_Test_Repository' asSymbol put: mczConfigurationRepositorypostLoad: arg1  (MetacelloDirective postLoadSpec: arg1 loader: self) addTo: self loadDirectiveensureForDevelopment  ^falsepostCopy  super postCopy.  list := list copy.  self clearMemberMapvalidateVersionSpec: arg1  self subclassResponsibilitysignal: arg1  self version: arg1.  ^self signaltestGroupSpec  | tmp1 |  tmp1 := self groupSpec     name: 'Platform';     includes: 'Core';     yourself.  self assert: tmp1 name equals: 'Platform'.  self assert: (tmp1 includes includes: 'Core').  tmp1 := self groupSpec     name: 'Platform';     includes: #('Core');     yourself.  self assert: tmp1 name equals: 'Platform'.  self assert: (tmp1 includes includes: 'Core').  self should: [ tmp1 requires: #() ] raise: Error.  self should: [ tmp1 answers: #() ] raise: Error.  tmp1 projectDo: [:arg1 |  self assert: false ] packageDo: [:arg1 |  self assert: false ] groupDo: [:arg2 |  self assert: tmp1 identicalTo: arg2 ]version114ProjectToolBox: arg1  < version: '1.1.4-baseline'>  arg1 for: #common do: [ arg1 project: 'Example Project' with: [ arg1                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 repository: 'http://www.example.com/ob' ] ]version43Symbolic: arg1  < version: '4.3'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #development.        arg1           package: 'GoferBeau' with: 'GoferBeau-dkh.54';           package: 'GoferFaux' with: 'GoferFaux-tg.33';           yourself ]packagesSpec  ^self packagesrepositoriesSpec  ^self repositoriesbaseline: arg1 with: arg2 constructor: arg3  arg3 baselineForVersion: arg1 with: arg2testRemoveGroupB  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: {(self groupSpec           name: 'Platform';           includes: 'Core';           yourself) .         (self groupSpec           name: 'Base';           includes: 'Base';           yourself) .         (self groupSpec           name: 'Tests';           includes: 'Tests';           yourself)}.  tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  tmp1 packageNamed: 'Base' ifAbsent: [ self assert: false ].  tmp1 packageNamed: 'Tests' ifAbsent: [ self assert: false ].  tmp1 remove: {'Base' .         'Tests'}.  tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  tmp2 := false.  tmp1 packageNamed: 'Base' ifAbsent: [ tmp2 := true ].  self assert: tmp2.  tmp2 := false.  tmp1 packageNamed: 'Tests' ifAbsent: [ tmp2 := true ].  self assert: tmp2globalNamed: arg1  ^Smalltalk at: arg1setUpConfigurationOfExternaldkh2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternal-dkh.2'.  tmp2 := #ConfigurationOfExternal.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfExternal090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfExternal090:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfExternal091:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfExternal091:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4findMethodSection: arg1 sectionIndex: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 asMetacelloAttributePath.  tmp2 := 1.  tmp3 := self methodSections.  tmp4 := true.  [ tmp4 ] whileTrue: [ tmp4 := false.        tmp3 do: [:arg3 |  arg3 attributes = (tmp1 at: tmp2) ifTrue: [ tmp2 == tmp1 size ifTrue: [ ^arg3 ].                    tmp3 := arg3 methodSections.                    tmp2 := tmp2 + 1.                    tmp4 := true ] ] ].  self error: 'Method section for attribute: ' , tmp1 printString , ' not found.'repositoryVersionString  | tmp1 tmp2 |  self repositorySpecs do: [:arg1 |  tmp1 := arg1 ].  [ tmp2 := tmp1 createRepository ] on: Error do: [:arg2 |  ^'' ].  ^tmp2 repositoryVersionStringhash  ^self versionNumber hashtype  type == nil ifTrue: [ type := self extractTypeFromDescription ].  ^typeproject  ^project ifNil: [ self class ensureMetacello.        project := MetacelloMCProject new projectAttributes: self customProjectAttributes.        (Smalltalk at: #MetacelloVersionConstructor) on: self project: project.        project loadType: #linear.        project ]lesson06  resolveLocalRespository  | tmp1 tmp2 |  tmp1 := self calculateRepositoryDirectory.  tmp2 := MCFileTreeFileUtils current directoryPathString: tmp1.  tmp1 exists ifFalse: [ self error: 'Local directory ' , tmp2 , ' does not exist.' ].  localRepository := MetacelloPlatform current createRepository: (MetacelloRepositorySpec new           description: 'filetree://' , tmp2;           yourself)lookupConfigurationSpec  configurationProjectSpec ifNotNil: [:arg1 |  ^arg1 ].  ^baselineProjectSpecupdatePackageRepositoriesFor: arg1  | tmp1 |  (tmp1 := (self version: arg1) versionSpec) packageSpecsInLoadOrder do: [:arg2 |  arg2 updatePackageRepositoriesFor: tmp1 ].  ^truegoferCommitBranchPackage: arg1 using: arg2 commitMessage: arg3  | tmp1 tmp2 tmp3 |  tmp2 := self spec repositorySpecs notEmpty ifTrue: [ self spec repositorySpecs ] ifFalse: [ arg2 ].  tmp1 := MetacelloGofer new.  tmp1 disablePackageCache.  tmp3 := self spec workingCopy.  arg2 do: [:arg4 |  | tmp4 |        tmp4 := arg4 createRepository.        (tmp3 possiblyNewerVersionsIn: tmp4) notEmpty ifTrue: [ self notify: 'There are possibly newer versions of the package ' , self spec name printString , ' in the repository ' , tmp4 description printString , '. Cancel and manually merge if you want to pick up the changes from the later version.' ].        tmp1 repository: tmp4 ].  tmp1 package: self spec name.  [ tmp1 interactiveCommit ] on: MCVersionNameAndMessageRequest do: [:arg5 |  | tmp5 |        tmp5 := GoferVersionReference name: arg5 suggestedName.        arg5 resume: {(tmp5 packageName , '.' , arg1 , '-' , tmp5 author , '.' , tmp5 versionNumber printString) .               arg3} ].  ^trueversion  self projectClass == nil ifTrue: [ ^nil ].  ^self projectClassProject versionhandleOnDownGrade: arg1 onUpgrade: arg2  self subclassResponsibilityresolveToPackagesIn: arg1 visited: arg2  ^self subclassResponsibilityhash  ^self description hashversionKey  ^self version versionKeyblessing: arg1  self root blessing: arg1 constructor: selfrepositorySpecs  | tmp1 |  tmp1 := self versionSpec repositories ~~ nil ifTrue: [ self versionSpec repositories map ] ifFalse: [ Dictionary new ].  ^tmp1 valueslabel  ^'Warning'loader  loader == nil ifTrue: [ | tmp1 |        (tmp1 := self project loader) == nil ifTrue: [ self loader: (self project loaderClass on: self) ] ifFalse: [ self loader: tmp1 ] ].  ^loaderhasNoLoadConflicts: arg1  (arg1 isKindOf: self class) ifFalse: [ ^false ].  ^self projectPath = arg1 projectPath and: [ self repoPath = arg1 repoPath and: [ self projectVersion = arg1 projectVersion ] ]setPostLoadDoIt: arg1  postLoadDoIt := arg1version51MethodSourceUmbrella  ^(self class sourceCodeAt: #version51Umbrella:) asString= arg1  arg1 species = self species ifFalse: [ ^false ].  ^self compareEqualTo: arg1versionFrom: arg1  ^self localRepository versionFrom: arg1tearDownPackages  | tmp1 |  tmp1 := Gofer new.  self tearDownPackageList do: [:arg1 |  (self hasPackage: arg1) ifTrue: [ tmp1 package: arg1 ] ].  tmp1 references notEmpty ifTrue: [ tmp1 metacelloUnload ]projectVersion20Issue283: arg1  < version: '2.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 configuration: 'ProjectIssue283' with: [ arg1                 version: #bleedingEdge;                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]setAuthorInMetacelloVersion: arg1  arg1 setAuthor: selfpackageSpec: arg1  packageSpec := arg1hasNoLoadConflicts: arg1  self description = arg1 description ifTrue: [ ^true ].  self type = arg1 type ifFalse: [ ^false ].  (#('github' 'gitorious' 'bitbucket') includes: self type) ifTrue: [ ^self createRepository hasNoLoadConflicts: arg1 createRepository ].  ^falsehash  ^((String stringHash: projectName initialHash: 0) bitXor: configurationProjectSpec metacelloRegistrationHash) bitXor: baselineProjectSpec metacelloRegistrationHashhasNoProject: arg1  hasNoProject := arg1name  ^self versionSpec nameversionString: arg1  arg1 isSymbol ifFalse: [ self error: 'Version symbol ' , arg1 printString , ' for symbolic version method must be a Symbol' ].  super versionString: arg1version42SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version42Symbolic:) asStringmethodSectionsInEvaluationOrder: arg1 do: arg2  | tmp1 tmp2 |  tmp1 := IdentitySet new.  self methodSection: self inEvaluationOrder: arg1 do: [:arg3 |  tmp1 add: arg3 ].  tmp2 := IdentitySet new.  arg1 do: [:arg4 |  | tmp3 |        tmp3 := OrderedCollection new.        tmp1 do: [:arg3 |  (tmp2 includes: arg3) ifFalse: [ (arg3 attributes includes: arg4) ifTrue: [ tmp3 add: arg3.                          tmp2 add: arg3 ] ] ].        tmp3 do: arg2 ]metacelloProjectClassFor: arg1  ^MetacelloMCBaselineProjectgetFile  ^fileprepostLoadDo: arg1  arg1 value: selfconfigurationProjectSpecIfAbsent: arg1  ^configurationProjectSpec ifNil: arg1requires: arg1  self root requires: arg1 constructor: selfcollectAllVersionsFromVersionPragmasInto: arg1 using: arg2  | tmp1 tmp2 |  tmp2 := self extractVersionPragmas.  tmp2 keysAndValuesDo: [:arg3 :arg4 |  | tmp3 |        tmp3 := self project versionSpec.        tmp3 versionString: arg3.        tmp1 := false.        [ arg4 do: [:arg5 |  arg2 value: tmp3 value: arg5.              tmp1 := true ] ] on: Error do: [:arg6 |  (MetacelloErrorInProjectConstructionNotification versionString: tmp3 versionString exception: arg6) ifTrue: [ ^arg6 pass ] ifFalse: [ self errorMap at: tmp3 versionString put: arg6.                    tmp1 := false ] ].        tmp1 ifTrue: [ self validateVersionString: arg3 againstSpec: tmp3.              arg1 at: tmp3 versionString put: tmp3 createVersion ].        self reset ]version100ProjectToolBox: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #testBlessing.        arg1           package: 'Example-Core' with: [ arg1                 includes: #('Example-AddOn');                 file: 'Example-Core-anon.1';                 repository: 'http://www.example.com/or';                 preLoadDoIt: #preloadForCore;                 postLoadDoIt: #postloadForCore:package: ];           package: 'Example-AddOn' with: [ arg1 requires: #('Example-Core') ];           package: 'Example-Tests' with: [ arg1 requires: #('Example-AddOn') ] ]pushAtomicLoadDirectivesDuring: arg1 for: arg2  self pushLoadDirective: (MetacelloAtomicLoadDirective loader: arg2) during: arg1defaultLoaderClass  ^MetacelloSpecLoadercurrentVersionInfoFor: arg1  ^self loadData currentVersionInfoFor: arg1 ifAbsent: [ nil ]setUpSampleCore  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'Sample-CoreX-dkh.1'.  tmp2 := #SampleCoreX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'sampleAuthorName' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #sampleAuthorName) asString) .   (MCClassDefinition name: #Object superclassName: #ProtoObject category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: 'Object' classIsMeta: true selector: 'isSample' category: '*sample-core' timeStamp: '' source: (self class sourceCodeAt: #isSample) asString)}.  sampleRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4testPrimeStackCache  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp8 := Dictionary new.  tmp7 := [ tmp1 := Dictionary new.  tmp2 := Dictionary new.  tmp3 := Dictionary new.  tmp4 := Dictionary new.  tmp5 := Dictionary new.  tmp6 := Dictionary new.  MetacelloPlatform current useStackCacheDuring: [:arg1 |  self cachedReturnOfValue ] defaultDictionary: tmp1.  MetacelloPlatform current useStackCacheDuring: [:arg1 |  self collectionCacheKey ] defaultDictionary: tmp2.  MetacelloPlatform current useStackCacheDuring: [:arg1 |  self cacheNil ] defaultDictionary: tmp3.  MetacelloPlatform current useStackCacheDuring: [:arg1 |  self directReturnOfValue ] defaultDictionary: tmp4.  MetacelloPlatform current useStackCacheDuring: [:arg1 |  self mixedStack ] defaultDictionary: tmp5.  MetacelloPlatform current useStackCacheDuring: [:arg1 |  self mixedStackCall ] defaultDictionary: tmp6 ].  tmp7 value.  self assert: ((tmp1 at: #cached) at: #key) identicalTo: 6.  self assert: ((tmp2 at: #collection) at: #x) identicalTo: 6.  self assert: ((tmp3 at: #cacheNil) at: #key) identicalTo: nil.  self assert: ((tmp4 at: #direct) at: #x) identicalTo: 6.  self assert: ((tmp5 at: #cached) at: #key) identicalTo: 6.  self assert: ((tmp5 at: #mixed) at: #x) identicalTo: 4.  self assert: ((tmp5 at: #mixedStack) at: #x) identicalTo: 4.  self assert: ((tmp5 at: #direct) at: #x) identicalTo: 6.  self assert: ((tmp6 at: #cached) at: #key) identicalTo: 6.  self assert: ((tmp6 at: #mixedStack) at: #x) identicalTo: 4.  MetacelloPlatform current primeStackCacheWith: tmp8 doing: tmp7.  self assert: ((tmp8 at: #cached) at: #key) identicalTo: 6.  self assert: ((tmp8 at: #collection) at: #x) identicalTo: 6.  self assert: ((tmp8 at: #cacheNil) at: #key) identicalTo: nil.  self assert: ((tmp8 at: #direct) at: #x) identicalTo: 6.  self assert: ((tmp8 at: #cached) at: #key) identicalTo: 6.  self assert: ((tmp8 at: #mixed) at: #x) identicalTo: 4.  self assert: ((tmp8 at: #mixedStack) at: #x) identicalTo: 4.  self assert: ((tmp8 at: #direct) at: #x) identicalTo: 6.  self assert: ((tmp8 at: #cached) at: #key) identicalTo: 6.  self assert: ((tmp8 at: #mixedStack) at: #x) identicalTo: 4fetchUsing: arg1  | tmp1 |  tmp1 := arg1 fetchingSpecLoader.  tmp1 linearLoadPackageSpecs: (Array with: self) repositories: (tmp1 repositoriesFrom: self repositorySpecs)baseline61ProjectIssue86: arg1  < version: '6.1'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'A' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.1';                 loads: #('1');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'B' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.1';                 loads: #('2');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]exception  ^exceptiongetPreLoadDoIt  ^preLoadDoItpackagesNeedSavingVisited: arg1 using: arg2 into: arg3  updatePackageMethodIn: arg1 sourceVersion: arg2  self deprecated: 'see MetacelloToolBox class>>updateDevelopment:for:updateProjects:description: for replacement method'.  self prepareForMethodUpdate: arg1 sourceVersion: arg2 forceUpdate: false generating: [:arg3 :arg4 :arg5 :arg6 |  | tmp1 tmp2 |        arg6 isEmpty ifTrue: [ ^false ].        tmp1 := WriteStream on: String new.        tmp1           nextPutAll: arg3 asString , ' spec';           cr;           tab;           nextPutAll: '<version: ' , arg2 printString.        tmp2 := arg4 at: arg3.        tmp2 numArgs = 2 ifTrue: [ tmp1 nextPutAll: ' imports: #('.              (tmp2 argumentAt: 2) do: [:arg7 |  tmp1                       nextPutAll: arg7 printString;                       space ] ].        tmp1           nextPutAll: ')>';           cr.        (arg5 at: 2) do: [:arg8 |  | tmp3 tmp4 |              tmp3 := (arg5 at: 1) at: arg8.              (tmp4 := arg6 at: arg8 ifAbsent: [  ]) ~~ nil ifTrue: [ tmp3 packagesSpec list do: [:arg9 |  arg9 spec file ~~ nil ifTrue: [ | tmp5 |                                ((tmp5 := tmp4 at: arg9 spec name ifAbsent: [  ]) ~~ nil and: [ tmp5 ~~ #uptodate ]) ifTrue: [ arg9 spec file: tmp5 file ] ] ] ].              tmp1                 cr;                 tab;                 nextPutAll: 'spec for: ' , arg8 printString , ' do: [';                 cr.              arg8 == #common ifTrue: [ tmp3                       author: MetacelloPlatform current authorName;                       timestamp: MetacelloPlatform current timestamp ].              tmp3 configMethodOn: tmp1 indent: 2.              tmp1 nextPutAll: '].' ].        (arg1 class compile: tmp1 contents classified: (arg1 class whichCategoryIncludesSelector: tmp2 selector)) == nil ifTrue: [ self error: 'Error compiling the method' ] ].  ^trueimportFrom: arg1 projectAttributes: arg2 inactiveAttributes: arg3 updateProjects: arg4 updatePackages: arg5 versionSpecsDo: arg6  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self constructor.  tmp2 := Set new.  tmp5 := Set new.  tmp4 := project version: arg1.  tmp6 := tmp4 versionString.  tmp3 := tmp4 spec.  self methodSpec imports: {tmp6}.  tmp1 extractMethodSectionsFor: tmp6.  self editVersionSpecsForImport: tmp1 projectAttributes: arg2 active: true fullVersionSpec: tmp3 updateProjects: arg4 updatePackages: arg5 visited: tmp5 updated: tmp2.  tmp7 := arg2.  arg3 do: [:arg7 |  self editVersionSpecsForImport: tmp1 projectAttributes: arg7 active: false fullVersionSpec: tmp3 updateProjects: arg4 updatePackages: arg5 visited: tmp5 updated: tmp2.        tmp7 := tmp7 , arg2 ].  tmp7 := tmp7 asSet.  tmp1 methodSectionsDo: [:arg8 |  | tmp8 tmp9 |        tmp8 := arg8 versionSpec.        tmp9 := arg8 attributePath.        (arg8 includesAttributeFrom: tmp7) ifFalse: [ tmp8 updateForSpawnMethod: tmp8.              tmp8 specListProjectDo: [:arg9 |  arg9 updateForSpawnMethod: arg9 ] packageDo: [:arg9 |  arg9 updateForSpawnMethod: arg9 ] groupDo: [:arg9 |  arg9 updateForSpawnMethod: arg9 ].              self clearVersionSpec: tmp8 fullVersionSpec: tmp3 updateProjects: arg4 updatePackages: arg5 ].        (arg6 value: tmp9 asAttributeOrPath value: tmp8) ifTrue: [ self methodSpec addMethodSection: tmp9 versionSpec: tmp8 ] ]monticelloRepository  ^monticelloRepositorycurrentBranchName  ^self configurationProjectSpec ifNotNil: [ configurationProjectSpec versionOrNil ifNil: [ '' ] ifNotNil: [:arg1 |  arg1 blessing asString ] ] ifNil: [ baselineProjectSpec repositoryBranchName ]currentVersion  | tmp1 tmp2 |  tmp1 := self configuration class.  ^MetacelloPlatform current stackCacheFor: #currentVersion at: tmp1 doing: [:arg1 |  tmp2 := self currentVersionAgainst: nil.        ^arg1 at: tmp1 put: tmp2 ]onDowngradeUseIncoming: arg1  self onDowngrade: [:arg2 :arg3 :arg4 |  (arg1 includes: arg3 baseName) ifTrue: [ arg2 useIncoming ] ifFalse: [ arg2 useLoaded ] ]versionNumberClass  ^MetacelloSemanticVersionNumbertestStandardMatch  self assert: ((self versionClass fromString: '1.1.1') match: '*.*.*').  self deny: ((self versionClass fromString: '1.1.1') match: '*.*').  self assert: ((self versionClass fromString: '1.1.0') match: '1.1.*').  self assert: ((self versionClass fromString: '1.1.0') match: '1.#.*').  self deny: ((self versionClass fromString: '1.10.0') match: '1.#.*').  self assert: ((self versionClass fromString: '1-alpha5.0') match: '1-alpha#.0').  self assert: ((self versionClass fromString: '1.alpha5.0') match: '1-alpha#.0').  self assert: ((self versionClass fromString: '1.alpha5.0') match: '1.alpha#.0').  self deny: ((self versionClass fromString: '1-alpha10.0') match: '1-alpha#.0')asRepositorySpecFor: arg1  ^arg1 repositorySpec     description: self description;     type: self class basicDescription;     yourselfversionClass  ^MetacelloSemanticVersionNumberconfigMethodBodyOn: arg1 hasName: arg2 cascading: arg3 indent: arg4  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg3.  tmp2 := self requires isEmpty not.  tmp3 := self includes isEmpty not.  tmp4 := self answers isEmpty not.  tmp2 ifTrue: [ arg2 | tmp3 | tmp4 | tmp1 ifTrue: [ arg1                 cr;                 tab: arg4 ].        arg1 nextPutAll: 'requires: #('.        self requires do: [:arg5 |  arg1 nextPutAll: arg5 printString , ' ' ].        tmp3 | tmp4 | tmp1 ifTrue: [ arg1 nextPutAll: ');' ] ifFalse: [ arg1 nextPut: $) ] ].  tmp3 ifTrue: [ arg2 | tmp2 | tmp4 | tmp1 ifTrue: [ arg1                 cr;                 tab: arg4 ].        arg1 nextPutAll: 'includes: #('.        self includes do: [:arg5 |  arg1 nextPutAll: arg5 printString , ' ' ].        tmp4 | tmp1 ifTrue: [ arg1 nextPutAll: ');' ] ifFalse: [ arg1 nextPut: $) ] ].  tmp4 ifTrue: [ arg2 | tmp2 | tmp3 | tmp1 ifTrue: [ arg1                 cr;                 tab: arg4 ].        arg1 nextPutAll: 'supplyingAnswers: #( '.        self answers do: [:arg6 |  arg1 nextPutAll: '#( '.              arg6 do: [:arg7 |  (arg7 isString or: [ arg7 isNumber or: [ arg7 isSymbol or: [ arg7 isCharacter ] ] ]) ifTrue: [ arg1 nextPutAll: arg7 printString , ' ' ].                    arg7 == true ifTrue: [ arg1 nextPutAll: 'true ' ].                    arg7 == false ifTrue: [ arg1 nextPutAll: 'false ' ] ].              arg1 nextPutAll: ') ' ].        tmp1 ifTrue: [ arg1 nextPutAll: ');' ] ifFalse: [ arg1 nextPut: $) ] ]version11Issue115: arg1  < version: '1.1' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: ''.        arg1 package: 'GeauxFoo' with: 'GeauxFoo-lr.1' ]modifySymbolicVersionMethodFor: arg1  ^self modifySymbolicVersionMethodFor: arg1 symbolicVersionSpecsDo: [:arg2 |  true ]onConflictUseLoaded  self onConflict: [:arg1 :arg2 :arg3 |  arg1 useLoaded ]versionSpec: arg1  versionSpec := arg1hasLoadConflicts: arg1  ^(self hasNoLoadConflicts: arg1) notcallSite  ^callSiteactionLabel  ^'Fetching 'ensureSpecLoader  ^selfdirectivesDo: arg1  arg1 value: self.  self preloads do: [:arg2 |  arg2 directivesDo: arg1 ].  self loadDirectives do: [:arg2 |  arg2 directivesDo: arg1 ].  self postloads do: [:arg2 |  arg2 directivesDo: arg1 ]bypassProgressBars: arg1  bypassProgressBars := arg1applyToList: arg1  arg1 remove: selfbaseline20Foo: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #baseline.        arg1           package: 'GoferBar';           package: 'GoferFoo';           package: 'GoferBeau';           package: 'GoferFaux';           yourself ]noQuit  ^self hasOption: 'no-quit'supplyingAnswers: arg1 constructor: arg2  arg2 supplyingAnswersForPackage: arg1baseline40ProjectIssue95: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Loop' with: [ arg1                 className: 'MetacelloTestConfigurationOfProjectLoop';                 versionString: '4.0';                 loads: 'GoferFaux';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Infinite' with: [ arg1                 className: 'MetacelloTestConfigurationOfProjectInfinite';                 versionString: '4.0';                 loads: 'GeauxBar';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]setUpBaselineOfExternalXX  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfExternalXX-dkh.1'.  tmp2 := #BaselineOfExternalXX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'externalBaselineXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalBaselineXX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4cacheRepository  ^(MetacelloMCProject new repositorySpec description: (self options at: #cacheRepository ifAbsent: [ ^nil ])) createRepositorycopyForRegistration: arg1 onWrite: arg2  self subclassResponsibilitysetUpConfigurationOfProjectFie  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectFie-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline15ProjectFie:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline15ProjectFie:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline25ProjectFie:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline25ProjectFie:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline35ProjectFie:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline35ProjectFie:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40ProjectFie:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline40ProjectFie:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())canUpgradeTo: arg1  (self className = arg1 className and: [ self operator == arg1 operator ]) ifFalse: [ ^false ].  self versionOrNil == nil ifTrue: [ ^true ].  ^self compareVersions: arg1 usingOperator: self operatorlist  list == nil ifTrue: [ list := OrderedCollection new ].  ^listrepositoriesSpecClass  ^MetacelloRepositoriesSpecrepositoryBranchName  | tmp1 tmp2 |  self repositorySpecs do: [:arg1 |  tmp1 := arg1 ].  tmp2 := tmp1 createRepository.  ^tmp2 repositoryBranchNamerepositoryError  ^repositoryErrorsetUpConfigurationExternalRefdkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternalRef-dkh.2'.  tmp2 := #ConfigurationOfExternalRef.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationExternalRef090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef090:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationExternalRef091:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef091:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationExternalRef092:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationExternalRef092:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4specListDetect: arg1 ifNone: arg2  self specListDo: [:arg3 |  (arg1 value: arg3) ifTrue: [ ^arg3 ] ].  ^arg2 valueissue  ^issueupdateVersionMethodForVersion: arg1 updateProjects: arg2 updatePackages: arg3 versionSpecsDo: arg4  ^self updateVersionMethodForVersion: arg1 projectAttributes: project attributes updateProjects: arg2 updatePackages: arg3 versionSpecsDo: arg4version10Issue156: arg1  < version: '1.0.0'>  arg1 for: #common do: [ arg1           configuration: 'Goo' with: [ arg1                 versionString: '3.0.0';                 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           yourself ]baseline10: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://www.example.com/Example'.        arg1           package: 'Example-Core';           package: 'Example-Tests' with: [ arg1 requires: 'Example-Core' ];           package: 'Example-AddOn' with: [ arg1 requires: 'Example-Core' ];           package: 'Example-AddOnTests' with: [ arg1 requires: #('Example-AddOn' 'Example-Tests') ].        arg1           group: 'default' with: #('Example-Core' 'Example-AddOn');           group: 'Tests' with: #('Example-Tests' 'Example-AddOnTests') ]callSite: arg1  callSite := arg1name: arg1  ((arg1 at: 1) isSeparator or: [ (arg1 at: arg1 size) isSeparator ]) ifTrue: [ self error: 'Names are not allowed to have leading or trailing blanks: ' , arg1 printString ].  name := arg1calculate: arg1 project: arg2  | tmp1 tmp2 tmp3 |  self configuration: arg1.  tmp1 := self extractBaselinePragmaFor: arg1 class.  self setProject: (arg2 ifNil: [ [ arg1 class project ] on: MessageNotUnderstood do: [:arg3 |  arg3 return: nil ] ]).  tmp3 := self project versionSpec.  self root: tmp3.  self evaluatePragma: tmp1.  tmp2 := Dictionary new.  self project attributes do: [:arg4 |  | tmp4 |        (tmp4 := self attributeMap at: arg4 ifAbsent: [  ]) ~~ nil ifTrue: [ tmp4 do: [:arg5 |  self with: tmp3 during: arg5 ] ] ].  tmp3 versionString: self project singletonVersionName.  tmp2 at: tmp3 versionString put: tmp3 createVersion.  self project map: tmp2.  self project configuration: arg1copyOnWrite: arg1  | tmp1 |  self class registry registrationFor: self ifPresent: [:arg2 |   ] ifAbsent: [ arg1 value: self.        ^self ].  self unregisterProject.  tmp1 := self copy.  arg1 value: tmp1.  tmp1 registerProject.  ^tmp1methodSection: arg1 pre: arg2 last: arg3 post: arg4 indent: arg5  | tmp1 |  arg1 ~~ self ifTrue: [ arg2 value: arg1 value: arg5 ].  tmp1 := arg1 methodSections.  1 to: tmp1 size do: [:arg6 |  | tmp2 |        tmp2 := tmp1 at: arg6.        self methodSection: tmp2 pre: arg2 last: arg6 ~= tmp1 size post: arg4 indent: arg5 + 1 ].  arg1 ~~ self ifTrue: [ arg4 value: arg1 value: arg5 value: arg3 ]preloadDoIt  Smalltalk at: #Metacello_Configuration_Test_DoIt_Result put: truegtInspectorChildren  ^{}forceUpdatePackageSpec: arg1 using: arg2  self updatePackageSpec: arg1 force: true using: arg2defaultAction  ^falserepository: arg1  self repositories repository: arg1.  self projectPackage: nilprojectSpec: arg1  projectSpec := arg1setDescriptionInMetacelloVersion: arg1  arg1 setDescription: selfpackageSpecsInLoadOrder  ^{self}project: arg1  project := arg1lockConfiguration15: arg1  < version: '1.5.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: self className , '>>lockConfiguration15: '.        arg1 baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA , '/repository' ] ]lesson11Blessing  versionKey  ^String streamContents: [:arg1 |  | tmp1 |        self versionNumber printOn: arg1.        self basicSpec ~~ nil ifTrue: [ (tmp1 := self projectLabel) isEmpty ifFalse: [ arg1 nextPutAll: ' [' , tmp1 , ']' ] ] ]setUpConfigurationOfProjectConfigIssue283dkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfProjectConfigIssue283-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'projectVersion10Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #projectVersion10Issue283:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'projectVersion20Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #projectVersion20Issue283:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4version  ^self projectReference versionlesson11  ^Lesson title: 'Lesson 11' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."In version 0.11 we''ve defined a couple of attributes that are expected to be used all of the timein a version specification:  #blessing:  #description:  #author:  #timestamp:The following lessons cover each of these attributes in more detail. "ProfStef next.'packagesNeedSaving: arg1  | tmp1 |  tmp1 := Set new.  (self version: arg1) spec packagesNeedSavingVisited: (Set with: self configuration class name asString) into: tmp1.  ^tmp1packageNames  packages == nil ifTrue: [ ^super packageNames ].  ^self packages map keys asSetversionOfExternal091: arg1  < version: '0.9.1'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>versionOfExternal091:'.        arg1 author: 'dkh'.        arg1 timestamp: '5/4/2012 14:16'.        arg1 baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]commitId  | tmp1 |  tmp1 := self repoPath isEmpty ifTrue: [ self directory ] ifFalse: [ self directory parent ].  ^tmp1 basename copyAfterLast: $-project  | tmp1 |  tmp1 := MetacelloMCProject new.  tmp1 projectAttributes: MetacelloConfigurationResource projectAttributes.  MetacelloVersionConstructor on: self project: tmp1.  tmp1 loader: (tmp1 loaderClass new           shouldDisablePackageCache: true;           yourself).  tmp1 loadType: #linear.  ^tmp1packageSpec: arg1  packageSpec := arg1version: arg1  arg1 isSymbol ifTrue: [ | tmp1 |        tmp1 := self symbolicVersionMap at: arg1 ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: arg1) signal ].        tmp1 == #notDefined ifTrue: [ (MetacelloSymbolicVersionNotDefinedError project: self project versionString: arg1) signal ].        ^self lookupVersion: tmp1 ifAbsent: [ (MetacelloSymbolicVersionDoesNotExistError project: self project versionString: tmp1) signal ] ].  ^self lookupVersion: arg1 ifAbsent: [ (MetacelloVersionDoesNotExistError project: self project versionString: arg1) signal ]versionReferences  ^versionReferencesgroup: arg1 with: arg2 constructor: arg3  arg3 groupForVersion: arg1 with: arg2doSilently  ^truetestPackageMergeSpec  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self packageSpec     name: 'Package';     name: 'Package';     requires: 'AnotherPackage';     includes: 'IncludedPackage';     answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));     file: 'Package-dkh.1';     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  tmp2 := self packageSpec     name: 'Package';     requires: 'AndAnotherPackage';     includes: 'AndIncludedPackage';     answers: #(#('xpostload' 'xpostload answer'));     file: 'Package-dkh.2';     repository: 'http://example.com/repository' username: 'DaleHenrichs' password: 'secret';     repository: '/opt/gemstone/repo';     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: tmp3 name equals: 'Package'.  self assert: tmp3 requires equals: #('AnotherPackage' 'AndAnotherPackage').  self assert: tmp3 includes equals: #('IncludedPackage' 'AndIncludedPackage').  self assert: tmp3 answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer') #('xpostload' 'xpostload answer')).  self assert: tmp3 file equals: 'Package-dkh.2'.  self assert: tmp3 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp3 postLoadDoIt value identicalTo: #postLoadDoIt.  tmp4 := tmp3 repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'directory'.  tmp4 := tmp3 repositories map at: '/opt/gemstone/repo' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'directory'.  tmp4 := tmp3 repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'http'.  self assert: tmp4 username equals: 'DaleHenrichs'.  self assert: tmp4 password equals: 'secret'repositoryArg: arg1  repositoryArg := arg1testAlphaNumericVersion3  self assert: (self versionClass fromString: '2.9.9-alpha.2') < (self versionClass fromString: '2.9.10')baselineVersion20Issue119: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        arg1 package: 'GoferBar ' ]aboutToCopy  self projectReference classNamespec: arg1  spec := arg1statements  statements ifNil: [ statements := OrderedCollection new ].  ^statementsversion41Issue119: arg1  < version: '4.1' imports: #('4.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo ' with: '2.0'.        arg1 package: 'GoferBar' with: 'GoferBar-jf.1' ]resolveDependencies: arg1 nearest: arg2 into: arg3  | tmp1 tmp2 tmp3 tmp4 |  self flag: 'Not used, but retained to avoid upgrade issues'.  tmp1 := [:arg4 |  | tmp5 |  tmp5 := MetacelloCachingGoferResolvedReference name: arg4 versionInfo name repository: arg1 repository.  tmp3 add: tmp5.  MetacelloNotification signal: 'Fetched dependency -> ' , tmp5 name , ' --- ' , tmp5 repository repositoryDescription.  self resolveDependencies: tmp5 nearest: tmp5 into: tmp3 ].  tmp2 := 0.  tmp4 := true.  tmp3 := OrderedCollection new.  [ tmp4 and: [ tmp2 < 3 ] ] whileTrue: [ tmp2 > 0 ifTrue: [ MetacelloNotification signal: '...RETRY' ].        [ arg3 do: [:arg5 |  arg5 version ].        arg2 version dependencies do: tmp1.        tmp4 := false ] on: Error do: [:arg6 |  tmp2 := tmp2 + 1.              tmp2 >= 3 ifTrue: [ arg6 pass ].              tmp3 := OrderedCollection new ] ].  arg3 addAll: tmp3.  ^arg3operator  ^self loader operatorsetUpConfigurationOfExternalXX  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternalXX-dkh.1'.  tmp2 := #ConfigurationOfExternalXX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfXX:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4testDictionaryRepository  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self project.  tmp2 := (tmp1 version: '1.5-baseline') packageNamed: 'Example-Core'.  tmp3 := tmp2 repositorySpecs first.  self assert: tmp3 type equals: 'dictionary'.  tmp4 := tmp3 createRepository.  self assert: tmp4 class identicalTo: MCDictionaryRepository.  self assert: tmp4 dictionary identicalTo: (testingEnvironment at: #Metacello_Platform_Test_GlobalDictionary) dictionaryregister  ^self execute: #register args: #()packages  packageList == nil ifTrue: [ packageList := self project packagesSpec ].  ^packageListupdatedPackageSpecs  | tmp1 tmp2 |  tmp1 := Dictionary new.  tmp2 := self loader.  self packages map valuesDo: [:arg1 |  arg1 updatePackageSpec: tmp1 using: tmp2 ].  ^tmp1setUp  super setUp.  self     setUpVersionReferences;     setUpMonticelloRepositorysetUpConfigurationOfAtomicFoo  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfAtomicFoo-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline20Foo:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline25Foo:' category: 'cat' timeStamp: '' source: self baseline25MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Foo:' category: 'cat' timeStamp: '' source: self version20MethodSourceFoo)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())ensureDirectoryExists: arg1  ^arg1     assureExistence;     yourselfcollectDefaultSymbolicVersionsFromVersionPragmasFrom: arg1 into: arg2 using: arg3  | tmp1 tmp2 |  arg1 keysAndValuesDo: [:arg4 :arg5 |  tmp1 := false.        arg2 at: arg4 ifAbsent: [ arg5 do: [:arg6 |  tmp1 := true.                    tmp2 := arg3 value: arg4 value: arg6 ].              tmp1 ifTrue: [ tmp2 == nil ifFalse: [ arg2 at: arg4 put: tmp2 ] ].              self reset ] ]createFiletreeRepository: arg1  | tmp1 tmp2 tmp3 |  tmp1 := Smalltalk at: #MCFileTreeRepository.  tmp2 := arg1 description.  tmp3 := 'filetree://' size.  ^tmp1 new     directory: (self fileHandleOn: (arg1 description copyFrom: tmp3 + 1 to: tmp2 size));     yourselfrepositorySpecs  ^self repositories map valuesaddSection: arg1 repository: arg2 requiredProjects: arg3 packages: arg4 dependencies: arg5 groups: arg6 versionSpecsDo: arg7  self addSection: arg1 repository: arg2 requiredProjects: arg3 packages: arg4 dependencies: arg5 includes: #() files: #() repositories: #() preLoadDoIts: #() postLoadDoIts: #() supplyingAnswers: #() groups: arg6 versionSpecsDo: arg7timestamp  ^DateAndTime now printStringbaseline10MethodSourceD  ^(self class sourceCodeAt: #baseline10D:) asStringsetUpConfigurationOfMetacelloExampledkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfMetacelloExample-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion10MetacelloExample:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10MetacelloExample:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version10MetacelloExample:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10MetacelloExample:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4className: arg1 constructor: arg2  arg2 classNameForProject: arg1projectPath  ^projectPathblessing: arg1  arg1 setBlessingInMetacelloVersion: selfcreateGithubRepository: arg1  | tmp1 |  tmp1 := Smalltalk at: #MCGitHubRepository.  ^tmp1 location: arg1 descriptionscpUrl  ^'git@bitbucket.org:' , projectPath , '.git'description  ^'The symbolic version ' , self versionString printString , ' is EXPLICITLY not defined in ' , self project label , ' for the current platform (i.e., symbolic version defined as #notDefined).'project: arg1  project := arg1validateMergeForSpec: arg1  attributeOrder  attributeOrder == nil ifTrue: [ attributeOrder := OrderedCollection new ].  ^attributeOrderprepostLoadDirectivesDo: arg1  packageSpec  ^packageSpecoperationString  self subclassResponsibilitytestTempFileFor  | tmp1 |  tmp1 := MetacelloPlatform current tempFileFor: 'xxx' suffix: '.test'preLoadDoIt: arg1 constructor: arg2  arg2 preLoadDoItForVersion: arg1baseline15: arg1  < version: '1.5-baseline'>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'dictionary://Metacello_Platform_Test_GlobalDictionary' ] ]command: arg1  ^MetacelloCommandLineHandler commandLine: (self argumentsWith: arg1)baselineArg: arg1  baselineArg := arg1aLoadedPackageIsExact  ^aLoadedPackageIsExactexplicitLoadWithPolicy: arg1  | tmp1 |  tmp1 := MetacelloGofer new.  tmp1 disablePackageCache.  tmp1 repository: arg1 cacheRepository.  self explicitLoadUsing: self gofer: tmp1removeFromMetacelloRepositories: arg1  arg1 addMember: selfhandleProjectSpecLoaded: arg1  MetacelloProjectRegistration registrationForProjectSpec: arg1 projectSpec ifAbsent: [:arg2 |  arg2           loadedInImage: true;           registerProject ] ifPresent: [:arg3 :arg2 |  arg3 copyOnWrite: [:arg4 |  arg4                 loadedInImage: true;                 merge: arg2 ] ].  arg1 resumeloader  ^loadervalidateProject: arg1 version: arg2  | tmp1 tmp2 |  (self visited includes: arg1 configuration class) ifTrue: [ ^self validationReport ].  self visited add: arg1 configuration class.  [ tmp1 := arg1 version: arg2 ] on: Error do: [:arg3 |  self recordValidationError: 'Could not resolve version ' , arg2 printString , ' due to error: ' , arg3 description versionString: arg2 callSite: #validateProject:version: reasonCode: #cannotResolveVersion.        ^self validationReport ].  tmp2 := tmp1 spec.  [ tmp2 blessing value == #baseline ifTrue: [ self validateBaselineVersionSpec: tmp2 ] ifFalse: [ self validateVersionSpec: tmp2 ] ] on: Error do: [:arg3 |  self recordValidationError: 'Error composing version ' , tmp1 versionString printString , ': ' , arg3 description versionString: tmp1 versionString callSite: #validateProject:version: reasonCode: #versionCompositionError ].  ^self validationReportmap: arg1  versionMap := arg1canUpgradeTo: arg1  (self repositories canUpgradeTo: arg1 repositories) ifTrue: [ ^true ].  ^falselesson07  ^Lesson title: 'Lesson 7' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline07:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version07:."NOTE: you should run through the lessons in Part 1 first.In this configuration we are defining a project that utilizes the packages from the Example project (MetacelloTutorialConfig):  ''Example-Core'', ''Example-AddOn'', ''Example-Tests'' and 2 packages specific to the project: ''Project-Core'' and ''Project-Tests'':"  (MetacelloProjectRefTutorialConfig project version: ''0.7'') load.ProfStef next.'validateVersionString: arg1 againstSpec: arg2  arg1 = arg2 versionString ifFalse: [ MetacelloValidationNotification signal: (MetacelloValidationError configurationClass: self configurationClass reasonCode: #incorrectVersionString callSite: #'validateVersionString:againstSpec' explanation: 'The version declared in the pragma ' , arg1 printString , ' does not match the version in the spec ' , arg2 versionString printString) ]hasClassName  ^className ~~ nil and: [ className ~= self constructClassName ]importArray  ^importArraydo: arg1  1 to: self size do: [:arg2 |  arg1 value: (self at: arg2) ]testStableVersionMethod  | tmp1 |  tmp1 := self projectWith: #(#'platformVersion1.x').  self assert: (tmp1 version: #stable) equals: tmp1 stableVersionmodifyVersionMethodForVersion: arg1 versionSpecsDo: arg2  ^self updateVersionMethodForVersion: arg1 updateProjects: false updatePackages: false versionSpecsDo: arg2project  ^self projectWith: #()cacheRepository  cacheRepository == nil ifTrue: [ cacheRepository := MCDictionaryRepository new ].  ^cacheRepositorypreLoadDoItForSpec: arg1  self validateDoItSelector: arg1.  self root preLoadDoIt: arg1baseline12: arg1  < version: '1.2-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://www.example.com/Project'.        arg1           project: 'Example Default' with: [ arg1                 className: 'MetacelloTutorialConfig';                 versionString: '1.2';                 loads: #('default');                 file: 'Metacello-Tutorial';                 repository: 'http://seaside.gemstone.com/ss/metacello' ];           project: 'Example Tests' copyFrom: 'Example Default' with: [ arg1 loads: #('Tests') ].        arg1           package: 'Project-Core' with: [ arg1 requires: 'Example Default' ];           package: 'Project-Tests' with: [ arg1 requires: #('Project-Core' 'Example Tests') ] ]printOn: arg1  | tmp1 |  tmp1 := [:arg2 :arg3 |  arg1     tab: 2;     nextPutAll: arg2 asString;     cr.  arg1     tab: 3;     nextPutAll: (arg3 at: 1) asString printString;     nextPutAll: ' to ';     nextPutAll: (arg3 at: 2) asString printString;     cr ].  arg1     nextPutAll: self configuration asString;     space;     nextPutAll: from asString printString;     nextPutAll: ' to ';     nextPutAll: to asString printString;     cr.  arg1     tab;     nextPutAll: 'Additions:';     cr.  self additions keysAndValuesDo: tmp1.  arg1     tab;     nextPutAll: 'Modifications:';     cr.  self modifications keysAndValuesDo: tmp1.  arg1     tab;     nextPutAll: 'Removals:';     cr.  self removals keysAndValuesDo: tmp1= arg1  arg1 class == self class ifFalse: [ ^false ].  ^(configurationProjectSpec registrationsCompareEqual: arg1 configurationProjectSpec) and: [ baselineProjectSpec registrationsCompareEqual: arg1 baselineProjectSpec ]extractBaselinePragmaFor: arg1  | tmp1 |  tmp1 := Pragma allNamed: #baseline in: arg1.  tmp1 isEmpty ifTrue: [ ^self error: 'No #baseline pragma found' ].  ^tmp1 firstmethodUpdateSelector  ^#overrides:defaultPackageCache  ^MCCacheRepository defaultprojectLabel  ^self projectReference projectLabelfileForProject: arg1  self root file: arg1deleteSpec: arg1  self packages deleteSpec: arg1createIcebergRepositoryFor: arg1  | tmp1 tmp2 |  tmp1 := IceRepositoryCreator new     url: arg1;     subdirectory: repoPath;     commitishName: self projectVersion;     ensureProjectFile;     yourself.  [ tmp2 := tmp1 createRepository ] on: IceDuplicatedRepository do: [:arg2 |  arg2 resignalAs: (IceMetacelloDuplicatedNotification new                 builder: tmp1;                 yourself) ].  tmp2 register.  ^tmp2repositoriesSpec  ^self repositoriesSpecClass for: selfhasRepository  ^self projectReference hasRepositoryprintOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  self loadDirective printOn: arg1.  arg1 nextPut: $)versionOfX091: arg1  < version: '0.9.1'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>versionOfX091:'.        arg1 author: 'dkh'.        arg1 timestamp: '5/4/2012 14:16' ].  arg1 for: #custom do: [ arg1 baseline: 'ExternalX' with: [ arg1 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]project  ^project ifNil: [ | tmp1 |        tmp1 := (Smalltalk at: #MetacelloVersionConstructor) on: self.        project := tmp1 project ]packageNamed: arg1 ifAbsent: arg2  ^self packageNamed: arg1 forMap: self packages map ifAbsent: arg2versionComponents  ^self normalVersion , self preReleaseVersion , self buildVersionlesson06  ^Lesson title: 'Lesson 6' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version06:."In version 0.6 we''ve added dependency information in the form of the #requires: directive.Both ''Example-Tests'' and  ''Example-AddOn'' require ''Example-Core'' to be loaded before they areloaded. Print the following expressions to see that the requires directives are being followed:"  (MetacelloTutorialConfig project version: ''0.5'') load: { ''Example-Tests''. }.  (MetacelloTutorialConfig project version: ''0.6'') load: { ''Example-Tests''. }.  (MetacelloTutorialConfig project version: ''0.6'') load: ''Example-AddOn''.  (MetacelloTutorialConfig project version: ''0.6'') load: { ''Example-AddOn''. ''Example-Tests''. }."With version 0.6 we are mixing structural information (required packages and repository) with thedynamic file version info. It is expected that over time the file version info will change fromversion to version while the structural information will remain relatively static."ProfStef next.'testMergeGroupB  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  tmp1 merge: {(self groupSpec           name: 'Platform';           includes: 'Tests';           yourself)}.  tmp2 := tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (tmp2 includes includes: 'Core').  self assert: (tmp2 includes includes: 'Tests')groupSpec  ^self groupSpecClass for: selfbaseline10: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://smalltalkhub.com/mc/JohnDoe/MyProject/main'.        self           fuelMetalevel: arg1;           fileSystemLegacy: arg1.        arg1           package: 'MyProject-Core';           package: 'MyProject-Tests' with: [ arg1 requires: #('MyProject-Core' 'FuelMetalevel' 'FileSystemLegacy') ].        arg1           group: 'default' with: #('core' 'test');           group: 'test' with: #('MyProject-Tests');           group: 'core' with: #('MyProject-Core') ]printLoadDirectivesOn: arg1 indent: arg2  self loadDirectives do: [:arg3 |  arg1 cr.        arg3 printOn: arg1 indent: arg2 + 1 ]configurationArg  ^configurationArgsetUpConfigurationOfUmbrellaA  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfUmbrellaA-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'version50Umbrella:' category: 'cat' timeStamp: '' source: self version50MethodSourceUmbrella)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())postCopy  super postCopy.  baselineRegistry := self baselineRegistry copy.  configurationRegistry := self configurationRegistry copyprojectClass  ^MetacelloMCProjectlatestVersionMatching: arg1  ^self latestVersionMatching: arg1 includedBlessings: #() excludedBlessings: self excludeFromLatestVersiontestVersion18  | tmp1 tmp2 |  self deny: (tmp1 := self versionClass fromString: '1.0.0') < (tmp2 := self versionClass fromString: '1.0.0-0').  self assert: (tmp1 := self versionClass fromString: '1.0.0') > (tmp2 := self versionClass fromString: '1.0.0-0').  self assert: (tmp1 := self versionClass fromString: '1.0.0') < (tmp2 := self versionClass fromString: '1.0.0+0').  self deny: (tmp1 := self versionClass fromString: '1.0.0') > (tmp2 := self versionClass fromString: '1.0.0+0')loader: arg1  self versionSpec loader: arg1isPackageLoaded  ^falsepackage: arg1 with: arg2  self root package: arg1 with: arg2 constructor: selfversionDo: arg1  arg1 value: selfdirectReturnOfValue  ^MetacelloPlatform current stackCacheFor: #direct at: #key doing: [:arg1 |  | tmp1 |        tmp1 := arg1 at: #x ifAbsent: [ 0 ].        tmp1 > 5 ifTrue: [ ^tmp1 ].        tmp1 := tmp1 + 1.        arg1 at: #x put: tmp1.        self directReturnOfValue ]mixedStack  ^MetacelloPlatform current stackCacheFor: #mixed at: #key doing: [:arg1 |  | tmp1 |        tmp1 := arg1 at: #x ifAbsent: [ 0 ].        tmp1 > 3 ifTrue: [ ^tmp1 ].        tmp1 := tmp1 + 1.        arg1 at: #x put: tmp1.        self assert: self directReturnOfValue identicalTo: 6.        self assert: self mixedStackCall identicalTo: 4.        self mixedStack ]swa: arg1  self swasource: arg1includesAttributeFrom: arg1  ^(arg1 asSet intersection: self attributes asSet) notEmptyprintOn: arg1  self printOn: arg1 indent: 0testBleedingEdgeMethod  | tmp1 |  tmp1 := self projectWith: #(#'platformVersion1.x').  self assert: (tmp1 version: #bleedingEdge) equals: tmp1 bleedingEdgeversion40Symbolic: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #release.        arg1           package: 'GoferBeau' with: 'GoferBeau-dkh.15';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           yourself ]forceUpdatePackageSpec: arg1 using: arg2  ^self updatePackageSpec: arg1 using: arg2hasConflictWithProjectSpec: arg1  ^arg1 hasConflictWithConfigurationSpec: selfpreLoadDoItBlock  ^self doItBlock: self preLoadDoIt valuesetUpConfigurationOfProjectFee  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectFee-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40ProjectFee:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectFee)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())setPackage: arg1 withBlock: arg2  | tmp1 |  tmp1 := self project packageSpec     name: arg1;     yourself.  self root packages merge: tmp1.  self with: tmp1 during: arg2methodUpdateSelector  ^#copy:version20MethodSourceFoo  ^(self class sourceCodeAt: #version20Foo:) asStringversionNumber  ^versionNumberversionString  self shouldNotImplementcompareCurrentVersion: arg1 targetVersionStatus: arg2 using: arg3  ^falsegroupSpec  ^self project groupSpecdescription: arg1 constructor: arg2  arg2 descriptionForVersion: arg1loader: arg1  loader := arg1updateForSpawnMethod: arg1  answers := name := requires := includes := nilbaselineVersion30Issue154: arg1  < version: '3.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1           project: 'MetacelloExample' with: [ arg1                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]development: arg1  < symbolicVersion: #development>  arg1 for: #common version: 'dev'cachedReturnOfValue  ^MetacelloPlatform current stackCacheFor: #cached at: #key doing: [:arg1 |  | tmp1 |        tmp1 := arg1 at: #x ifAbsent: [ 0 ].        tmp1 > 5 ifTrue: [ arg1 at: #key put: tmp1 ] ifFalse: [ tmp1 := tmp1 + 1.              arg1 at: #x put: tmp1 ].        self cachedReturnOfValue ]valueForValueHolder: arg1  self root value: arg1immutable  mutable := falsecurrentVersionAgainst: arg1  | tmp1 |  tmp1 := arg1 ifNil: [ Array with: self configuration class with: nil ] ifNotNil: [ Array with: self configuration class with: (arg1 sort: [:arg2 :arg3 |  arg2 <= arg3 ]) ].  ^MetacelloPlatform current stackCacheFor: #currentVersionAgainst: at: tmp1 doing: [:arg4 |  | tmp2 tmp3 tmp4 |        tmp2 := nil.        tmp3 := self sortedAndFilteredVersions.        tmp3 do: [:arg5 |  | tmp5 tmp6 |              tmp5 := arg1 ifNil: [ arg5 spec isPartiallyCurrent ] ifNotNil: [ arg5 spec isPartiallyCurrentAgainst: arg1 ].              tmp6 := [:arg6 |  tmp2 := arg5 copy.              tmp2 versionStatus: arg6.              ^arg4 at: tmp1 put: tmp2 ].              tmp5 isAllLoadedToSpec: tmp6.              tmp5 isLoadedToSpec: tmp6.              tmp5 isLoadedMatchConstraints: tmp6.              tmp5 isSomethingLoaded: [:arg6 |  tmp4 ifNil: [ tmp2 := arg5 copy.                          tmp2 versionStatus: arg6.                          tmp4 := tmp2 ] ] ].        tmp4 ifNotNil: [ ^arg4 at: tmp1 put: tmp4 ].        ^arg4 at: tmp1 put: nil ]setUpConfiguration181  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfIssue181-dkh.1'.  tmp2 := #ConfigurationOfIssue181.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration091Issue181:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration091Issue181:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration092Issue181:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration092Issue181:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration093Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration093Issue185:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration094Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration094Issue185:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration095Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration095Issue185:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration096Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration096Issue185:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration097Issue185:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration097Issue185:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration098Issue215:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration098Issue215:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4createFtpRepository: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 description.  tmp2 := 'ftp://' size.  tmp3 := tmp1 indexOf: $/ startingAt: tmp2 + 1.  tmp4 := tmp1 copyFrom: tmp2 + 1 to: tmp3 - 1.  tmp5 := tmp1 copyFrom: tmp3 + 1 to: tmp1 size.  ^MCFtpRepository host: tmp4 directory: tmp5 user: arg1 username password: arg1 passwordprojectClass  ^MetacelloProjectdefaultBleedingEdgeVersion  | tmp1 |  tmp1 := (self project map values select: [:arg1 |  arg1 blessing == #baseline ]) detectMax: [:arg1 |  arg1 ].  tmp1 ifNil: [ ^#notDefined ].  ^tmp1 versionStringtestRemoveB  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1 add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  tmp1 remove: {(self repositorySpec           description: 'http://example.com/repository';           yourself)}.  tmp2 := false.  tmp1 map at: 'http://example.com/repository' ifAbsent: [ tmp2 := true ].  self assert: tmp2baseline20Foo: arg1  < version: '2.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar.branch-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           package: 'GoferBeau' with: 'GoferBeau-dkh.25';           yourself ]incrementMinorVersion  self incrementNormalVersionAt: 2baselineVersion20Issue171: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        arg1 package: 'GeauxFoo' ]mergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #versionString put: versionString.  tmp1 at: #blessing put: blessing.  tmp1 at: #description put: description.  tmp1 at: #author put: author.  tmp1 at: #timestamp put: timestamp.  tmp1 at: #preLoadDoIt put: preLoadDoIt.  tmp1 at: #postLoadDoIt put: postLoadDoIt.  tmp1 at: #packageList put: self packages.  ^tmp1prepostLoadDirectivesDo: arg1  self loadDirectives do: [:arg2 |  arg2 prepostLoadDirectivesDo: arg1 ]baseline40MethodSourceFeaux  ^(self class sourceCodeAt: #baseline40Feaux:) asStringversionInfo  versionInfo ifNil: [ versionInfo := MetacelloProjectRegistrationVersionInfo new.        self configurationProjectSpecIfPresent: [ versionInfo versionString: self version ] ifAbsent: [  ] ].  ^versionInfotestMCVersionMergeSpec  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self versionSpec     blessing: #baseline;     versionString: '1.0';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  tmp1 packages     merge: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           yourself);     merge: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself);     merge: (self projectReferenceSpec           name: 'Project';           projectReference: (self projectSpec                 name: 'Project';                 projectPackage: self project packageSpec;                 className: 'ConfigurationOfProjectA';                 repository: 'http://example.com/repository' username: 'dkh' password: 'password';                 repository: '/opt/gemstone/repository';                 yourself));     yourself.  tmp2 := self versionSpec     blessing: #release;     versionString: '1.1';     repository: 'http://example.com/repository' username: 'DaleHenrichs' password: 'secret';     repository: '/opt/gemstone/repo';     yourself.  tmp2 packages     merge: (self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           yourself);     merge: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself);     merge: (self projectReferenceSpec           name: 'Project';           projectReference: (self projectSpec                 name: 'Project';                 projectPackage: self project packageSpec;                 className: 'ConfigurationOfProjectA';                 repository: 'http://example.com/repository' username: 'DaleHenrichs' password: 'secret';                 repository: '/opt/gemstone/repo';                 yourself));     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: tmp3 blessing value equals: #release.  self assert: tmp3 versionString value equals: '1.1'.  tmp4 := tmp3 repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'directory'.  tmp4 := tmp3 repositories map at: '/opt/gemstone/repo' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'directory'.  tmp4 := tmp3 repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'http'.  self assert: tmp4 username equals: 'DaleHenrichs'.  self assert: tmp4 password equals: 'secret'.  tmp5 := tmp3 packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: tmp5 name equals: 'Package'.  tmp7 := tmp3 packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: tmp7 projectName equals: 'Project'.  tmp4 := tmp7 repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'directory'.  tmp4 := tmp7 repositories map at: '/opt/gemstone/repo' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'directory'.  tmp4 := tmp7 repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'http'.  self assert: tmp4 username equals: 'DaleHenrichs'.  self assert: tmp4 password equals: 'secret'.  tmp6 := tmp3 packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (tmp6 includes includes: 'Core').  self assert: (tmp6 includes includes: 'Tests')testApproxVersion03  self assert: '1.1' asMetacelloVersionNumber ~> '1.1' asMetacelloVersionNumberresolvedReference: arg1  resolvedReference := arg1deleteFileNamed: arg1  arg1 asFileReference ensureDeletebaselineArg  ^baselineArgonLockBreak  self onLock: [:arg1 :arg2 :arg3 |  arg1 break ]croquet: arg1  self repository: 'http://hedgehog.software.umn.edu:8888/' , arg1projectForScriptEngine: arg1  ^self projectForScriptEngine: arg1 unconditionalLoad: falselesson04  ^Lesson title: 'Lesson 4' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version04:."The specification for version 0.4 is basically the same as version 0.3. Instead of listing a repository with each package we specify a project repository that applies to all packages.Compare the printStrings for the specs for each version:"  (MetacelloTutorialConfig project version: ''0.3'') spec.  (MetacelloTutorialConfig project version: ''0.4'') spec.ProfStef next.'loadType  ^self project loadTypedifference: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := MetacelloVersionDiffReport new.  tmp2 := Dictionary new.  tmp3 := Dictionary new.  self projectDo: [:arg2 |  tmp2 at: arg2 name put: arg2 ] packageDo: [:arg3 |  tmp3 at: arg3 name put: arg3 ] groupDo: [:arg4 |   ].  tmp4 := Dictionary new.  tmp5 := Dictionary new.  arg1 projectDo: [:arg2 |  tmp4 at: arg2 name put: arg2 ] packageDo: [:arg3 |  tmp5 at: arg3 name put: arg3 ] groupDo: [:arg4 |   ].  tmp2 valuesDo: [:arg5 |  | tmp6 |        tmp6 := tmp4 at: arg5 name ifAbsent: [  ].        tmp6 == nil ifTrue: [ tmp1 removals at: arg5 name put: {arg5 versionString .                     ''} ] ifFalse: [ arg5 versionString = tmp6 versionString ifFalse: [ tmp1 modifications at: arg5 name put: {arg5 versionString .                           tmp6 versionString} ] ] ].  tmp4 valuesDo: [:arg6 |  (tmp2 at: arg6 name ifAbsent: [  ]) == nil ifTrue: [ tmp1 additions at: arg6 name put: {'' .                     arg6 versionString} ] ].  tmp3 valuesDo: [:arg7 |  | tmp7 |        tmp7 := tmp5 at: arg7 name ifAbsent: [  ].        tmp7 == nil ifTrue: [ tmp1 removals at: arg7 name put: {arg7 file .                     ''} ] ifFalse: [ arg7 file = tmp7 file ifFalse: [ tmp1 modifications at: arg7 name put: {arg7 file .                           tmp7 file} ] ] ].  tmp5 valuesDo: [:arg8 |  (tmp3 at: arg8 name ifAbsent: [  ]) == nil ifTrue: [ tmp1 additions at: arg8 name put: {'' .                     arg8 file} ] ].  ^tmp1testApproxVersion02  self deny: '1.1' asMetacelloVersionNumber ~> '1' asMetacelloVersionNumberasMetacelloVersionNumber  ^selfprojectWith: arg1  | tmp1 |  tmp1 := MetacelloMCProject new.  tmp1 projectAttributes: arg1.  MetacelloVersionConstructor on: self project: tmp1.  tmp1 loader: (tmp1 loaderClass new           shouldDisablePackageCache: true;           yourself).  tmp1 loadType: self loadType.  ^tmp1testSemanticVersioningSpecItem10  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-0.3.7' '1.0.0-x.7.z.92')baseline31MethodSourceFan  ^(self class sourceCodeAt: #baseline31Fan:) asStringconfiguration: arg1 with: arg2 constructor: arg3  arg3 configurationForVersion: arg1 with: arg2classNameArg  ^classNameArgresolveToPackagesIn: arg1 andProjects: arg2 visited: arg3  ^self resolveToPackagesIn: arg1 visited: arg3setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:arg1 |  | tmp1 tmp2 |        tmp1 := arg1 key.        tmp2 := arg1 value.        monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) with: (MCClassDefinition name: (tmp1 packageName copyWithout: $-) asSymbol superclassName: tmp2 category: tmp1 packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]version107ProjectToolBox: arg1  < version: '1.0.7-baseline'>  arg1 for: #common do: [ arg1           package: 'Example-Core' with: [ arg1                 supplyingAnswers: #(#('preload' 'preload answer') #('postload' 'postload answer'));                 preLoadDoIt: #preloadForSupplyingAnswers;                 postLoadDoIt: #postloadForSupplyingAnswers ];           package: 'Example-Tests' with: [ arg1 supplyingAnswers: #(#('string' 'preload answer') #('symbol' #'abc def') #('integer' 1) #('boolean' true) #('another boolean' false) #('character' $a)) ] ]requiresForPackage: arg1  self root requires: arg1hasNoLoadConflicts: arg1  ^(super hasNoLoadConflicts: arg1) and: [ self file = arg1 file ]version09Issue32: arg1  < version: '0.9.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>baselineOfIssue32:'.        arg1 author: 'dkh'.        arg1 timestamp: '6/18/2012 14:34' ].  arg1 for: #custom do: [ arg1 baseline: 'Issue32' with: [ arg1 repository: 'dictionary://Metacello_External_Test_Repository' ] ]setUpConfigurationOfProjectIssue171dkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue171-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion20Issue171:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue171:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Issue171:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue171:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4setUpRepositoryContents  baseline200: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1           preLoadDoIt: #preloadForCore;           postLoadDoIt: #postloadForCore:package:.        arg1           project: 'Example Project' with: [ arg1                 className: 'ConfigurationOfExampleProject';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 loads: #('core');                 yourself ];           yourself.        arg1 group: 'Core' with: #('Example Project') ]repository: arg1 username: arg2 password: arg3 constructor: arg4  arg4 repositoryForProject: arg1 username: arg2 password: arg3version127ProjectToolBox: arg1  < version: '1.2.7-baseline'>  arg1 for: #common do: [ arg1 project: 'Example Project' with: [ arg1                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadDoIt;                 postLoadDoIt: #postloadDoIt;                 repository: 'http://www.example.com/ob' ] ]version120ProjectToolBox: arg1  < version: '1.2.0-baseline' imports: #('1.1.4-baseline')>  arg1 for: #common do: [ arg1 project: 'Copied Example' copyFrom: 'Example Project' with: [ arg1 preLoadDoIt: #alternatePreloadForCore ] ]addMethodSection: arg1 versionSpec: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 last.  tmp2 := MetacelloVersionMethodSection new     attributes: tmp1;     versionSpec: arg2;     yourself.  arg1 size > 1 ifTrue: [ tmp3 := 1.        tmp4 := self methodSections.        tmp5 := true.        [ tmp5 ] whileTrue: [ tmp5 := false.              tmp4 do: [:arg3 |  arg3 attributes = (arg1 at: tmp3) ifTrue: [ tmp3 == (arg1 size - 1) ifTrue: [ arg3 methodSections add: tmp2.                                ^self ].                          tmp4 := arg3 methodSections.                          tmp3 := tmp3 + 1.                          tmp5 := true ] ] ].        self error: 'Method section for attribute: ' , (arg1 at: tmp3) printString , ' not found.' ] ifFalse: [ self methodSections add: tmp2 ]setUpConfigurationOfProjectFoe  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectFoe-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40ProjectFoe:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectFoe)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())addBaselineOfSection: arg1 requiredProjects: arg2 packages: arg3 repositories: arg4 dependencies: arg5 groups: arg6 versionSpecsDo: arg7  self addBaselineOfSection: arg1 requiredProjects: arg2 packages: arg3 dependencies: arg5 includes: #() files: #() repositories: arg4 preLoadDoIts: #() postLoadDoIts: #() supplyingAnswers: #() groups: arg6 versionSpecsDo: arg7project  ^self projectWith: #()flushForScriptGet  self class flushProjectEntry: self projectPath version: self projectVersion.  self localRepository flushForScriptGetanswers: arg1  self shouldNotImplementlesson01  ^Lesson title: 'Lesson 1' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version01:."Version 0.1 represents the simplest version specification possible. In the method #version01, version 0.1 is defined with a single package ''Example-Core-anon.8'' that is loaded from the repository ''http://www.example.com/Example''.Looking at this method you will notice a couple of things. Immediately after the method selector you see the pragma definition:  <version: ''0.1''>The pragma indicates that the version created in this method should be associated with version ''0.1'' of the Tutorial project.Looking a little closer you see that the argument to the method, <spec>, is the only variable inthe method and it is used as the receiver to four different messages:  - #for:do:  - #package:with:  - #file:   - #repository:With the evaluation of each block expression, a new object is pushed on a stack and the messageswithin the block are sent to the object on the top of the stack.So the method should be read as:  Create version ''0.1''. The #common code for version ''0.1'' (#for:do:) consists of a package named   ''Example-Core'' (#package:with:) whose file attribute is ''Example-Core-anon.8'' (#file:) and whose   repository attribute is ''http://www.example.com/Example'' (#repository:).We can see the spec created for version 0.1 by printing the following expression:"  (MetacelloTutorialConfig project version: ''0.1'') spec."Note that in creating version ''0.1'' the #common attribute is extracted out.In addition to #common, there are pre-defined attributes for each of the platforms upon whichMetacello runs (#pharo, #squeak, #gemstone and #squeakCommon). #squeakCommon is used for both #pharo and #squeak."ProfStef next.'updateVersionMethodForVersion: arg1 projectAttributes: arg2 updateProjects: arg3 updatePackages: arg4 versionSpecsDo: arg5  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 |  tmp2 := Set new.  tmp4 := project version: arg1.  tmp11 := tmp4 versionString.  tmp8 := tmp4 blessing.  tmp8 == #release ifTrue: [ MetacelloCannotUpdateReleasedVersionError signal: 'Should not update a version that has been released (resume to continue update).' ].  tmp3 := tmp4 spec.  tmp1 := self constructor.  tmp5 := tmp1 extractAllVersionPragmas at: tmp11 ifAbsent: [ ^tmp2 ].  tmp5 size > 1 ifTrue: [ self error: 'More than one pragma defining ' , tmp11 printString ].  tmp6 := tmp5 at: 1.  tmp7 := tmp6 numArgs = 2 ifTrue: [ tmp6 argumentAt: 2 ] ifFalse: [ #() ].  methodSpec := MetacelloVersionMethodSpec new     project: project;     selector: (MetacelloPlatform current selectorForPragma: tmp6);     category: (project configuration class whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma: tmp6));     versionString: tmp11;     imports: tmp7;     yourself.  tmp1 extractMethodSectionsFor: tmp11.  tmp9 := Dictionary new.  tmp10 := Set new.  tmp12 := IdentitySet new.  tmp1 methodSectionsInEvaluationOrder: arg2 reverse do: [:arg6 |  | tmp13 |        tmp13 := arg6 versionSpec.        (tmp8 ~~ #baseline and: [ arg6 includesAttributeFrom: arg2 ]) ifTrue: [ self updateVersionSpec: tmp13 fullVersionSpec: tmp3 updateProjects: arg3 updatePackages: arg4 visited: tmp10 updated: tmp2 ].        (arg5 value: arg6 attributeOrPath value: tmp13) ifTrue: [ tmp12 add: arg6 topParent ] ].  tmp1 methodSections do: [:arg6 |  (arg6 includesAttributeFrom: arg2) ifTrue: [ (tmp12 includes: arg6) ifTrue: [ self methodSpec methodSections add: arg6 ] ] ifFalse: [ self methodSpec methodSections add: arg6 ] ].  ^tmp2nonOverridable  ^super nonOverridable , #(repositories)availableSubCommands  ^#('install')file: arg1 constructor: arg2  arg2 fileForPackage: arg1extractTypeFromDescription: arg1  (arg1 beginsWith: 'ftp://') ifTrue: [ ^'ftp' ].  ^super extractTypeFromDescription: arg1postCopy  super postCopy.  repositories := repositories copy.  projectPackage := nilsetUpConfigurationOfExternalXXX  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternalXXX-dkh.1'.  tmp2 := #ConfigurationOfExternalXXX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfXXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfXXX:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4canUpgradeTo: arg1  (arg1 isKindOf: self class) ifFalse: [ ^false ].  ^self projectPath = arg1 projectPath and: [ self repoPath = arg1 repoPath ]setUpBaselineGithubReferenceV  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefV-dkh.1'.  tmp2 := #BaselineOfGithubRefV.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationGithubReferenceXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceXX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4spec: arg1 loader: arg2  spec := arg1.  loader := arg2configMethodBodyOn: arg1 indent: arg2 fromShortCut: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp5 := self hasClassName.  tmp1 := self configHasVersionString.  tmp2 := operator ~~ nil.  tmp3 := self hasRepository or: [ tmp5 & (self getFile ~~ nil) ].  tmp4 := self loads ~~ nil.  tmp6 := self getPreLoadDoIt ~~ nil.  tmp7 := self getPostLoadDoIt ~~ nil.  tmp5 ifTrue: [ tmp1 | tmp2 | tmp3 | tmp4 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ] ifFalse: [ arg1 space ].        arg1 nextPutAll: 'className: ' , self className printString.        tmp1 | tmp6 | tmp7 | tmp2 | tmp4 | tmp3 ifTrue: [ arg1 nextPut: $; ] ].  tmp1 ifTrue: [ | tmp8 |        tmp5 | tmp2 | tmp3 | tmp4 | tmp6 | tmp7 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ] ifFalse: [ arg1 space ].        tmp8 := self versionString.        arg1 nextPutAll: 'versionString: '.        tmp8 isSymbol ifTrue: [ arg1 nextPut: $# ].        arg1 nextPutAll: tmp8 asString printString.        tmp6 | tmp7 | tmp2 | tmp3 | tmp4 ifTrue: [ arg1 nextPut: $; ] ].  tmp6 ifTrue: [ tmp5 | tmp2 | tmp3 | tmp4 | tmp6 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ] ifFalse: [ arg1 space ].        arg1 nextPutAll: 'preLoadDoIt: '.        self preLoadDoIt value isSymbol ifTrue: [ arg1                 nextPut: $#;                 nextPutAll: self preLoadDoIt value asString printString ] ifFalse: [ arg1 nextPutAll: self preLoadDoIt value asString ].        tmp7 | tmp2 | tmp3 | tmp4 ifTrue: [ arg1 nextPut: $; ] ].  tmp7 ifTrue: [ tmp5 | tmp2 | tmp3 | tmp4 | tmp7 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ] ifFalse: [ arg1 space ].        arg1 nextPutAll: 'postLoadDoIt: '.        self postLoadDoIt value isSymbol ifTrue: [ arg1                 nextPut: $#;                 nextPutAll: self postLoadDoIt value asString printString ] ifFalse: [ arg1 nextPutAll: self postLoadDoIt value asString ].        tmp2 | tmp3 | tmp4 ifTrue: [ arg1 nextPut: $; ] ].  tmp2 ifTrue: [ tmp5 | tmp1 | tmp3 | tmp4 | tmp6 | tmp7 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ] ifFalse: [ arg1 space ].        arg1 nextPutAll: 'operator: #' , self operator asString printString.        tmp3 | tmp4 ifTrue: [ arg1 nextPut: $; ] ].  tmp4 ifTrue: [ tmp5 | tmp1 | tmp2 | tmp3 | tmp6 | tmp7 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ] ifFalse: [ arg1 space ].        arg1 nextPutAll: 'loads: #('.        self loads do: [:arg4 |  arg1 nextPutAll: arg4 printString , ' ' ].        arg1 nextPut: $).        tmp3 ifTrue: [ arg1 nextPut: $; ] ].  tmp3 ifTrue: [ | tmp9 tmp10 |        tmp10 := self hasRepository.        tmp9 := self file ~= self className.        tmp9 ifTrue: [ tmp5 | tmp1 | tmp2 | tmp4 | tmp6 | tmp7 ifTrue: [ arg1                       cr;                       tab: arg2 + 1 ] ifFalse: [ arg1 space ].              arg1 nextPutAll: 'file: ' , self file printString.              tmp10 ifTrue: [ arg1 nextPut: $; ] ].        tmp10 ifTrue: [ | tmp11 |              tmp11 := self repositories map values.              tmp11 size = 1 ifTrue: [ arg3 ifTrue: [ tmp5 | tmp1 | tmp2 | tmp4 | tmp6 | tmp7 | tmp9 ifTrue: [ arg1                                   cr;                                   tab: arg2 + 1 ] ifFalse: [ arg1 space ] ] ifFalse: [ arg1                             cr;                             tab: arg2 + 1 ].                    tmp11 first configMethodCascadeOn: arg1 lastCascade: true ] ifFalse: [ arg1 cr.                    self repositories configMethodCascadeOn: arg1 indent: arg2 ] ] ]setUpRepositoryContents: arg1 sourceRepo: arg2 targetRepo: arg3  arg1 do: [:arg4 |  | tmp1 |        tmp1 := arg2 versionInfoFromVersionNamed: arg4.        arg3 storeVersion: (arg2 versionWithInfo: tmp1 ifAbsent: [ self assert: false ]) ]ignoreImage  ^ignoreImagepreLoadDoIt: arg1 constructor: arg2  arg2 preLoadDoItForProject: arg1canDowngradeTo: arg1  ^falsenonOverridable  ^#(includes requires answers)printOn: arg1  | tmp1 |  tmp1 := true.  self do: [:arg2 |  tmp1 ifTrue: [ tmp1 := false ] ifFalse: [ arg2 isString ifTrue: [ arg1 nextPut: $- ] ifFalse: [ arg1 nextPut: $. ] ].        arg1 nextPutAll: arg2 asString ]baseline50MethodSourceFan  ^(self class sourceCodeAt: #baseline50Fan:) asStringpragmaKeywords  ^#(#version:attribute: #blessing:attribute: #description:attribute: #required:attribute: #groups:attribute: #doits:attribute:)slideIn: arg1 spec: arg2 baseIndex: arg3 seen: arg4 firstTime: arg5 for: arg6  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  (arg4 includes: arg2) ifTrue: [ ^false ].  tmp1 := arg1 indexOf: arg2.  arg3 >= tmp1 ifTrue: [ ^false ].  tmp7 := false.  tmp6 := arg1 at: arg3.  arg3 + 1 to: tmp1 - 1 do: [:arg7 |  | tmp8 |        tmp8 := arg1 at: arg7.        ((tmp8 requiredSpecNamesForPackageOrdering: arg6) includes: tmp6 name) ifTrue: [ tmp7 := true ] ].  arg5 ifFalse: [ tmp7 ifFalse: [ ^false ] ].  tmp2 := arg2 requiredSpecNamesForPackageOrdering: arg6.  tmp3 := arg1 select: [:arg8 |  tmp2 includes: arg8 name ].  tmp4 := tmp3 collect: [:arg8 |  arg1 indexOf: arg8 ].  tmp4 add: arg3.  tmp5 := tmp4 detectMax: [:arg9 |  arg9 ].  tmp5 + 1 < tmp1 ifTrue: [ arg1 remove: arg2.        arg1 add: arg2 afterIndex: tmp5.        arg4 add: arg2 ] ifFalse: [ ^self slideIn: arg1 spec: (arg1 at: tmp5) baseIndex: 1 seen: arg4 firstTime: arg5 for: arg6 ].  ^truepostCopy  normalVersion := normalVersion copy.  preReleaseVersion := preReleaseVersion copy.  buildVersion := buildVersion copysetUpExternalCoreX  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'External-CoreX-dkh.1'.  tmp2 := #ExternalCoreX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'externalAuthorName' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalAuthorName) asString) .   (MCMethodDefinition className: 'Object' classIsMeta: true selector: 'isExternal' category: '*external-corex' timeStamp: '' source: (self class sourceCodeAt: #isExternal) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4symbolicVersionResolverBlock  ^[:arg1 :arg2 |  | tmp1 |  tmp1 := nil.  (arg2 argumentAt: 1) = arg1 ifTrue: [ self symbolicVersion: arg1.        self evaluatePragma: arg2.        self project attributes do: [:arg3 |  | tmp2 |              tmp2 := self attributeMap at: arg3 ifAbsent: [  ].              tmp2 ~~ nil ifTrue: [ tmp1 := tmp2 ] ] ].  tmp1 ]preLoadDoIt: arg1  self root preLoadDoIt: arg1 constructor: selfhandleOnDownGrade: arg1 onUpgrade: arg2  ^arg1 cull: self cull: self existingProjectRegistration cull: self newProjectRegistrationgetRepositories  ^repositoriesbaselineVersion10Issue115: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        arg1 package: 'GeauxFoo' ]projectSpecCreationBlock  ^[:arg1 |  {(MetacelloMCBaselineProject new baselineOfProjectSpec name: arg1)} ]version103ProjectToolBox: arg1  < version: '1.0.3-baseline' imports: #('1.0.2-baseline')>  arg1 for: #common do: [ arg1 preLoadDoIt: #alternatePreloadForCore ]stableVersion  ^nilpackageSpec: arg1  packageSpec := arg1isCriticalWarning  ^truedefaultAction  ^trueversionWithInfo: arg1 ifAbsent: arg2  ^self localRepository versionWithInfo: arg1 ifAbsent: arg2canUpgradeTo: arg1  self description = arg1 description ifTrue: [ ^true ].  (#('github' 'gitorious' 'bitbucket') includes: self type) ifTrue: [ ^self createRepository canUpgradeTo: arg1 createRepository ].  ^falselockConfiguration11: arg1  < version: '1.1.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>lockConfiguration11: '.        arg1 configuration: 'ExternalX' with: [ arg1                 version: '0.9.1';                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]baselineGithubReferenceXX: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>baselineGithubReferenceXX:'.        arg1 baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]downloadZipArchive: arg1 to: arg2  self subclassResponsibilitypackagesSpec  ^self project packagesSpecoperator: arg1  self shouldBeMutable.  operator := arg1applyToList: arg1  arg1 copy: selfmethodSource  | tmp1 |  tmp1 := WriteStream on: String new.  self methodSelectorAndPragma: self selector imports: self imports on: tmp1.  self methodSection: self pre: [:arg1 :arg2 |  tmp1           cr;           tab: arg2;           nextPutAll: 'spec for: ' , arg1 attributePrintString , ' do: [';           cr.        arg1 versionSpec configMethodOn: tmp1 last: arg1 methodSections isEmpty indent: arg2 + 1 ] last: false post: [:arg1 :arg2 :arg3 |  tmp1 nextPutAll: ' ].'.        (arg3 or: [ arg2 = 1 or: [ arg1 methodSections isEmpty and: [ arg2 = 1 ] ] ]) ifTrue: [ tmp1 cr ] ] indent: 0.  ^tmp1 contentsplatformAttributes  ^self projectPlatformAttributespostloadDoIt  Smalltalk at: #Metacello_Configuration_Test_POST_DoIt_Result put: truespotterForIncludesFor: arg1  < spotterOrder: 1>  arg1 listProcessor     title: 'Includes';     allCandidates: [ self includes ];     itemName: [:arg2 |  arg2 name ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: trueensureConfigurationLoaded: arg1 ensured: arg2  (arg1 blessing == #development or: [ self versionString isSymbol ]) ifTrue: [ arg2 ~~ #latest ifTrue: [ ^MetacelloScriptEnsureProjectLoadedForDevelopment signal ] ].  ^falserelativeCurrentVersion  ^self projectReference relativeCurrentVersionsetUpConfigurationOfProjectIssue119dkh7: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.7'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion40Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version50Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version50Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4addSection: arg1 repository: arg2 requiredProjects: arg3 packages: arg4 repositories: arg5 dependencies: arg6 groups: arg7 versionSpecsDo: arg8  self addSection: arg1 repository: arg2 requiredProjects: arg3 packages: arg4 dependencies: arg6 includes: #() files: #() repositories: arg5 preLoadDoIts: #() postLoadDoIts: #() supplyingAnswers: #() groups: arg7 versionSpecsDo: arg8baseline62Foo: arg1  < version: '6.2'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        arg1           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo');           yourself ]version12: arg1  < version: '1.2' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'Add in doits for Example-Core'.        arg1 author: 'dkh'.        arg1 timestamp: '10/12/2009 09:26'.        arg1           package: 'Example-Core' with: [ arg1                 file: 'Example-Core-anon.16';                 preLoadDoIt: #preloadForCore;                 postLoadDoIt: #postloadForCore:package: ];           package: 'Example-Tests' with: 'Example-Tests-anon.5';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ]silently  silently == nil ifTrue: [ silently := false ].  ^silentlyversion126ProjectToolBox: arg1  < version: '1.2.6-baseline' imports: #('1.2.5-baseline')>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1                 preLoadDoIt: nil;                 postLoadDoIt: nil ] ]projectSpecsFromRepositoryArg  | tmp1 tmp2 tmp3 |  repositoryArg ifNil: [ ^#() ].  tmp1 := (projectSpecGenerator projectSpecCreationBlock value: 'xxx') first.  tmp2 := tmp1 project createRepository: (tmp1 project repositorySpec description: repositoryArg).  tmp3 := OrderedCollection new.  ((Gofer new disablePackageCache     repository: tmp2;     allResolved) collect: [:arg1 |  arg1 packageName ]) asSet do: [:arg2 |  (projectSpecGenerator projectSpecCreationBlock value: (MetacelloScriptEngine baseNameOf: arg2)) do: [:arg3 |  arg3 className = arg2 ifTrue: [ tmp3 add: (self applyArgsToProjectSpec: arg3 copy) ] ] ].  ^tmp3versionString  versionString == nil ifTrue: [ ^'' ].  ^versionStringbaseline20Fan: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #baseline.        arg1           package: 'GoferFan';           yourself ]reasonCode  reasonCode == nil ifTrue: [ reasonCode := #none ].  ^reasonCodeincludes  includes == nil ifTrue: [ includes := #() ].  ^includeslesson07  repositoryFor: arg1 from: arg2  ^([ self resolveSpec: arg1 from: arg2 ] on: Error do: [:arg3 |  ^nil ]) repositorystableVersion  ^self version: #stablesetBlessingInMetacelloVersion: arg1  arg1 setBlessing: selfconfigSpawnMethodOn: arg1 indent: arg2  self configMethodValueOn: arg1 for: self getBlessing selector: 'blessing:' last: false indent: arg2.  self configMethodValueOn: arg1 for: self getAuthor selector: 'author:' last: false indent: arg2.  self configMethodValueOn: arg1 for: self getTimestamp selector: 'timestamp:' last: false indent: arg2importedVersions  importedVersions == nil ifTrue: [ importedVersions := #() ].  ^importedVersionshasLoadConflicts: arg1  arg1 validate.  self isValid ifFalse: [ ^false ].  ^self projectSpec hasConflictWithProjectSpec: arg1 projectSpecerrorReasonCodes  ^super errorReasonCodes , #(#loadError #testFailures)loadedPackageNames: arg1  | tmp1 tmp2 |  (tmp1 := self versionOrNil) == nil ifTrue: [ ^#() ].  tmp2 := OrderedCollection new.  (self loadListForVersion: tmp1) do: [:arg2 |  (tmp1 packagesForSpecNamed: arg2) do: [:arg3 |  (arg3 isPackageLoaded: arg1) ifTrue: [ tmp2 add: arg3 name ] ] ].  ^tmp2loadVersion: arg1  self subclassResponsibilitybaseline40MethodSourceProjectLoop  ^(self class sourceCodeAt: #baseline40ProjectLoop:) asStringfile  ^self classNameactivate  self activateHelpWithoutArguments ifTrue: [ ^self ].  self subCommand = 'install' ifTrue: [ self           checkInputForInstallSubcommand;           install;           postInstall ]downloadJSON: arg1 username: arg2 pass: arg3  | tmp1 tmp2 |  tmp1 := ZnClient new     url: arg1;     yourself.  arg2 ifNotNil: [ tmp1 username: arg2 password: arg3 ].  tmp1 get.  tmp2 := tmp1 contents.  ^STON fromString: tmp2testHttpRepository  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self project.  tmp2 := (tmp1 version: '1.4-baseline') packageNamed: 'Example-Core'.  tmp3 := tmp2 repositorySpecs first.  self assert: tmp3 type equals: 'http'.  tmp4 := tmp3 createRepository.  self assert: tmp4 class identicalTo: MCHttpRepository.  self assert: tmp4 description equals: 'http://example.com/examples'nonOverridable  ^super nonOverridable , #(projectReference)addTo: arg1  spec postLoadDoIt value ~~ nil ifTrue: [ arg1 add: self ]setUpConfigurationOfProjectIssue283dkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfProjectIssue283-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'stableVersion283A:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #stableVersion283A:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'bleedingEdge206A:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #bleedingEdge206A:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue283:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4projectSpec  ^projectSpecprojectSpecListBlock  ^[ MetacelloProjectRegistration baselineProjectSpecs ]versionString  ^versionString ifNil: [ self version ifNotNil: [:arg1 |  arg1 versionString ] ]packagesNeedSavingUsing: arg1 into: arg2  | tmp1 tmp2 tmp3 |  (tmp1 := self spec workingCopy) == nil ifTrue: [ ^self ].  (tmp1 ancestry ancestors notEmpty and: [ tmp1 modified not ]) ifTrue: [ ^self ].  tmp2 := self spec repositorySpecs notEmpty ifTrue: [ self spec repositorySpecs ] ifFalse: [ arg1 ].  tmp3 := (self spec getFile == nil or: [ tmp1 ancestry ancestors isEmpty ]) ifTrue: [ (self repositoriesFrom: tmp2 ignoreOverrides: true) first ] ifFalse: [ ([ self resolveSpec: self spec from: tmp2 ] on: Error do: [:arg3 |  ^self ]) repository ].  arg2 add: self spec -> tmp3projectSpecLookupBlock  ^[:arg1 |  {(MetacelloProjectRegistration projectSpecForClassNamed: (MetacelloScriptEngine configurationNameFrom: arg1) ifAbsent: [  ])} ]projectClass  ^MetacelloMCProjecttestIssue392  #('v0.0.1' '00.0.1' '16r00.0.1' '101r.0.1' 'rr101r.0.1') do: [:arg1 |  MetacelloOldSemanticVersionNumber fromString: arg1.        self should: [ self versionClass fromString: arg1 ] raise: Error ]retryingResolvePackageSpecReferences: arg1 gofer: arg2  | tmp1 tmp2 tmp3 |  tmp1 := 0.  tmp2 := #().  [ tmp2 isEmpty and: [ tmp1 < 3 ] ] whileTrue: [ tmp1 > 0 ifTrue: [ MetacelloNotification signal: '...RETRY->' , arg1 file ].        tmp2 := [ self resolvePackageSpecReferences: arg1 gofer: arg2 ] on: Error , GoferRepositoryError do: [:arg3 |  self class retryPackageResolution ifFalse: [ arg3 pass ].              tmp1 >= 2 ifTrue: [ (arg3 isKindOf: GoferRepositoryError) ifTrue: [ MetacelloNotification signal: 'gofer repository error: ' , arg3 description printString , '...ignoring'.                          tmp3 := arg3.                          arg3 resume: #() ] ifFalse: [ arg3 pass ] ].              arg3 return: #() ].        tmp1 := tmp1 + 1 ].  tmp2 isEmpty ifTrue: [ MetacelloNotification signal: '...FAILED->' , arg1 file.        (MetacelloPackageSpecResolutionError new           packageSpec: arg1;           repositories: arg2 repositories;           repositoryError: tmp3;           yourself) signal ].  ^tmp2removeGroup: arg1 constructor: arg2  arg2 removeGroupForVersion: arg1sourceName  ^sourceNameswasource: arg1  self repository: 'http://www.hpi.uni-potsdam.de/hirschfeld/squeaksource/' , arg1versionsDo: arg1  self loadDirectives do: [:arg2 |  arg2 versionDo: arg1 ]packages  | tmp1 |  tmp1 := OrderedCollection new.  self spec projectDo: [:arg1 |   ] packageDo: [:arg2 |  tmp1 add: arg2 ] groupDo: [:arg1 |   ].  ^tmp1ignoreImage: arg1  ignoreImage := arg1createProjectReferenceSpec: arg1  | tmp1 |  tmp1 := (Metacello image     project: arg1;     list) detect: [:arg2 |  true ] ifNone: [ ^self classicCreateProjectReferenceSpec: arg1 ].  ^project projectReferenceSpec     name: arg1;     projectReference: tmp1;     yourselfvalidateSemanticVersionStrings: arg1  | tmp1 tmp2 |  tmp1 := arg1 collect: [:arg2 |  arg2 asMetacelloSemanticVersionNumber ].  tmp2 := tmp1 at: 1.  2 to: tmp1 size do: [:arg3 |  | tmp3 |        tmp3 := tmp1 at: arg3.        self assert: tmp2 < tmp3.        tmp2 := tmp3 ]configMethodOn: arg1 indent: arg2  self configMethodOn: arg1 last: true indent: arg2removeFromMetacelloPackages: arg1  arg1 addMember: (arg1 removeMember           name: self name;           spec: self;           yourself)baselineVersion10Issue154: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1           project: 'MetacelloExample' with: [ arg1                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 projectPackage: [ arg1                       name: 'ConfigurationOfMetacelloExample';                       repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ];           yourself ]sourceName  ^self nameresolveToPackagesIn: arg1 andProjects: arg2 into: arg3 visited: arg4  arg4 visit: self doing: [:arg5 |  | tmp1 |        tmp1 := arg1 packages map.        arg5 includes do: [:arg6 |  (arg1 packageNamed: arg6 forMap: tmp1 ifAbsent: [  ]) projectDo: [:arg7 |  arg2 ifTrue: [ arg3 at: arg7 name put: arg7 ] ] packageDo: [:arg8 |  arg3 at: arg8 name put: arg8 ] groupDo: [:arg9 |  arg9 resolveToPackagesIn: arg1 andProjects: arg2 into: arg3 visited: arg4 ] ] ]setUpBaselineOfExternalXXX  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfExternalXXX-dkh.1'.  tmp2 := #BaselineOfExternalXXX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'externalBaselineXXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalBaselineXXX:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4project  ^self basicSpec projectusername: arg1  username := arg1externalReference  ^externalReferencepackages  ^packageslist  self setDefaultsAndValidateProjectSpec.  self root: self projectSpeccompareCurrentVersion: arg1 targetVersionStatus: arg2 using: arg3  self currentPackageLoaded: [:arg4 |  ^arg4 ] comparing: arg1 notLoaded: [:arg5 |  ^false ] using: arg3evaluatePragma: arg1  currentContext := arg1.  [ self configuration perform: (MetacelloPlatform current selectorForPragma: arg1) with: self ] ensure: [ currentContext := nil ]commitBaselineOfMethod  | tmp1 |  tmp1 := false.  self methodSpec ifNil: [ ^self ].  self methodSpec compileMethod.  project := project configuration class project.  [ project version: self methodSpec versionString ] on: MetacelloSymbolicVersionDoesNotExistError do: [:arg1 |  tmp1 := true ].  tmp1 ifFalse: [ self validateVersion: self methodSpec versionString ].  methodSpec := niltestGroupMergeSpec  | tmp1 tmp2 tmp3 |  tmp1 := self groupSpec     name: 'Platform';     includes: 'Core';     yourself.  tmp2 := self groupSpec     name: 'Platform';     includes: 'Tests';     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: (tmp3 includes includes: 'Core').  self assert: (tmp3 includes includes: 'Tests')description  | tmp1 |  tmp1 := self class description , self projectPath , ':' , self projectVersionEscaped.  self repoPath isEmpty ifTrue: [ ^tmp1 ].  ^tmp1 , '/' , self repoPathinvalidConfiguration30: arg1  < version: '3.0.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>invalidConfiguration30: ... missing repository:'.        arg1 project: 'External' with: [ arg1                 className: 'ConfigurationOfExternal';                 version: '0.9.0' ] ]testVersion  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--version=stable').  self assert: tmp1 version equals: 'stable'operationString  ^'downgrade to'roots  roots ifNil: [ roots := OrderedCollection new ].  ^rootsprojectLabel  ^'configuration'~> arg1  arg1 size == 1 ifTrue: [ ^false ].  ^self >= arg1 and: [ self < arg1 approximateBase ]versionString: arg1  versionString := arg1hasClassName  ^className ~~ nil and: [ className ~= self constructClassName ]configurationGithubReferenceXXX: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configurationGithubReferenceXXX:'.        arg1 configuration: 'External' with: [ arg1                 version: '0.9.0';                 repository: 'http://ss3.gemtalksystems.com/ss/external' ] ]asProjectSpecForVersion: arg1  ^selfimports: arg1  imports := arg1projectLabel  ^self basicSpec projectLabeladd: arg1  arg1 addToMetacelloRepositories: selfaLoadedProjectIsExact  ^aLoadedProjectIsExactss3: arg1  self squeaksource3: arg1repositoryFor: arg1 with: arg2  ^([ self resolveSpec: arg1 with: arg2 ] on: Error do: [:arg3 |  ^nil ]) repositoryvalidateBaselineVersionSpec: arg1  self subclassResponsibilityisPartiallyCurrent  ^self isPartiallyCurrentAgainst: (self expandToLoadableSpecNames: #('ALL'))label  ^self versionSpec labelauthor: arg1 constructor: arg2  arg2 authorForVersion: arg1repositories: arg1  repositories := arg1repository  | tmp1 |  self deprecated: 'Use repositories or repositorySpecs'.  (tmp1 := self repositorySpecs) isEmpty ifTrue: [ ^nil ].  ^tmp1 firstsetProject: arg1 withString: arg2  | tmp1 tmp2 |  tmp2 := self project projectSpec     name: arg1;     versionString: arg2;     yourself.  tmp1 := self project projectReferenceSpec     name: arg1;     projectReference: tmp2;     yourself.  self root packages merge: tmp1on: arg1 project: arg2  | tmp1 tmp2 |  tmp1 := arg1 class.  tmp2 := MetacelloPlatform current stackCacheFor: #versionConstructor at: tmp1 doing: [:arg3 |  self calculate: arg1 project: arg2.        arg3 at: tmp1 put: self project.        ^self ].  arg2 map: tmp2 map.  arg2 errorMap: tmp2 errorMap.  arg2 symbolicVersionMap: tmp2 symbolicVersionMap.  arg2 configuration: arg1.  self setProject: arg2validationReport  validationReport == nil ifTrue: [ validationReport := OrderedCollection new ].  ^validationReportsetPreLoadDoItInMetacelloSpec: arg1  arg1 setPreLoadDoIt: selfname  ^self versionStringsetUpConfigurationOfFan  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfFan-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline20Fan:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFan) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline30Fan:' category: 'cat' timeStamp: '' source: self baseline30MethodSourceFan) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline35Fan:' category: 'cat' timeStamp: '' source: self baseline35MethodSourceFan) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40Fan:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceFan) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline50Fan:' category: 'cat' timeStamp: '' source: self baseline50MethodSourceFan)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())goferPackage  goferPackage == nil ifTrue: [ goferPackage := MetacelloGoferPackage name: self name packageFilename: self file ].  ^goferPackagetestVersion11  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '1.0.1b'.  tmp2 := self versionClass fromString: '1.0.1a'.  self assert: tmp1 >= tmp2.  self assert: tmp2 <= tmp1printOn: arg1 indent: arg2  arg2 timesRepeat: [ arg1 tab ].  arg1     nextPutAll: self title;     nextPutAll: ' : ';     nextPutAll: self labelpragmaKeywords  ^super pragmaKeywords , #(#projectPackage:attribute: #packages:attribute: #repositories:attribute:)configMethodBodyOn: arg1 indent: arg2  ^self configMethodBodyOn: arg1 indent: arg2 fromShortCut: falsebaseline40Feaux: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GeauxFoo' with: 'GeauxFoo-lr.1';           package: 'GeauxBar' with: 'GeauxBar.branch-lr.2';           yourself ]= arg1  arg1 species = self species ifFalse: [ ^false ].  ^self versionNumber = arg1 versionNumbergroupForVersion: arg1 with: arg2  | tmp1 |  tmp1 := self project groupSpec     name: arg1;     includes: arg2;     yourself.  self root packages merge: tmp1testVersion25  self assert: (MetacelloVersionNumber fromString: '1.0-beta.24.0.1') < (MetacelloVersionNumber fromString: '1.0-beta.28')setUpConfigurationOfProjectIssue115dkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue115-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion10Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue115:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version10Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue115:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4answers: arg1  self shouldNotImplementsetUpConfigurationOfExternalXdkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternalX-dkh.1'.  tmp2 := #ConfigurationOfExternalX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'stableVersionOfX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #stableVersionOfX:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfX090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfX090:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4setUpConfigurationOfProjectIssue119dkh6: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.6'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion10Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion20Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion20Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion30Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion30Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion40Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version10Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version30Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version40Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version41Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version41Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version42Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version42Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version43Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version43Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version44Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version44Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4gtInspectorActionLoad  < gtInspectorAction>  ^GLMGenericAction new     action: [ self load ];     iconName: #smallLoadProject;     title: 'Load'mergeSpec: arg1  | tmp1 tmp2 tmp3 |  tmp1 := super mergeSpec: arg1.  tmp2 := arg1 mergeMap.  (tmp3 := tmp2 at: #projectReference) ~~ nil ifTrue: [ tmp1 projectReference: (tmp1 projectReference == nil ifTrue: [ tmp3 ] ifFalse: [ tmp1 projectReference mergeSpec: tmp3 ]) ].  ^tmp1loadUsing: arg1 gofer: arg2  self subclassResponsibilityhandleResolutionFor: arg1  ^arg1 handleConflict: selfabort: arg1  abort := arg1detect: arg1 ifNone: arg2  self do: [:arg3 |  (arg1 value: arg3) ifTrue: [ ^arg3 ] ].  ^arg2 valueprojectSpecGenerator  baselineArg ifNotNil: [ configurationArg ifNotNil: [ self error: ' baseline: and configuration: are both be specified' ].        projectArg ifNotNil: [ self error: ' baseline: and project are both be specified' ].        ^MetacelloBaselineSpecGenerator new           target: baselineArg;           yourself ].  configurationArg ifNotNil: [ baselineArg ifNotNil: [ self error: ' baseline: and configuration: are both be specified' ].        projectArg ifNotNil: [ self error: ' configuration and project are both be specified' ].        ^MetacelloConfigurationSpecGenerator new           target: configurationArg;           yourself ].  projectArg ifNotNil: [ configurationArg ifNotNil: [ self error: ' project and configuration: are both be specified' ].        baselineArg ifNotNil: [ self error: ' baseline: and project are both be specified' ].        ^MetacelloProjectSpecGenerator new           target: projectArg;           yourself ].  self error: 'project, baseline, or configuration not specified'hasNonVersionStringField  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp5 := self hasClassName.  tmp1 := self versionString ~~ nil.  tmp2 := operator ~~ nil.  tmp3 := (self file ~~ nil and: [ tmp5 and: [ self className ~= self name ] ]) or: [ self hasRepository ].  tmp4 := self loads ~~ nil.  tmp6 := self getPreLoadDoIt ~~ nil.  tmp7 := self getPostLoadDoIt ~~ nil.  ^tmp5 | tmp2 | tmp3 | tmp4 | tmp6 | tmp7metacelloRegistrationHash  | tmp1 |  tmp1 := String stringHash: name initialHash: 0.  tmp1 := String stringHash: self className initialHash: tmp1.  tmp1 := String stringHash: self versionString initialHash: tmp1.  tmp1 := String stringHash: self operator asString initialHash: tmp1.  tmp1 := String stringHash: self preLoadDoIt asString initialHash: tmp1.  tmp1 := String stringHash: self postLoadDoIt asString initialHash: tmp1.  ^tmp1 bitXor: loads hashfetchingSpecLoader  ^(MetacelloFetchingMCSpecLoader on: self spec)     shouldDisablePackageCache: self shouldDisablePackageCache;     loaderPolicy: self loaderPolicy copy;     yourselfversion116ProjectToolBox: arg1  < version: '1.1.6-baseline' imports: #('1.1.4-baseline')>  arg1 for: #common do: [ arg1 project: 'Example Project' with: [ arg1 preLoadDoIt: #alternatePreloadForCore ] ]testMergeC  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     merge: {(self repositorySpec           description: 'http://example.com/repository';           password: 'secret';           yourself) .         (self repositorySpec           description: 'http://example.com/repository';           username: 'DaleHenrichs';           yourself)}.  tmp2 := tmp1 map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: 'http://example.com/repository'.  self assert: tmp2 type equals: 'http'.  self assert: tmp2 username equals: 'DaleHenrichs'.  self assert: tmp2 password equals: 'secret'versionDevelopment: arg1  < version: 'dev' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1           description: 'Development Version';           blessing: #development;           author: 'John Doe';           timestamp: '2013-05-09'.        arg1           package: 'MyProject-Core' with: 'MyProject-Core-JohnDoe.152';           package: 'MyProject-Tests' with: 'MyProject-Tests-JohnDoe.173';           project: 'FuelMetalevel' with: #development ]repositories: arg1  repositories := arg1version10Issue84: arg1  < version: '1.0.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>version10Issue84:'.        arg1 author: 'dkh'.        arg1 timestamp: '7/24/2012 19:23'.        arg1 configuration: 'NestedIssue84' with: [ arg1                 version: '1.0.0';                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]repository: arg1 username: arg2 password: arg3 constructor: arg4  arg4 repositoryForRepositories: arg1 username: arg2 password: arg3unlock  actionArg := #unlock -> #()linearLoadPackageSpec: arg1 gofer: arg2  MetacelloPlatform current do: [ | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |        tmp3 := nil.        arg1 searchCacheRepositoryForPackage: [ tmp3 := self resolvePackageSpec: arg1 cachedGofer: self loaderPolicy cacheGofer.              (tmp3 ~~ nil and: [ arg1 getFile ~~ nil ]) ifTrue: [ tmp3 name = arg1 file ifTrue: [ ^self scheduleFetchFor: arg1 cachedReference: tmp3 ] ] ].        tmp1 := self retryingResolvePackageSpecReferences: arg1 gofer: arg2.        tmp2 := tmp1 last asMetacelloCachingResolvedReference.        (tmp3 ~~ nil and: [ tmp3 name = tmp2 name ]) ifTrue: [ ^self scheduleFetchFor: arg1 nearestReference: tmp2 ].        (self ignoreImage not and: [ (tmp6 := self ancestorsFor: arg1) ~~ nil ]) ifTrue: [ tmp6 do: [:arg3 |  arg3 name = tmp2 name ifTrue: [ | tmp7 |                          tmp7 := arg1 copy.                          tmp7 file: arg3 name.                          (MetacelloIgnorePackageLoaded signal: tmp7) ifFalse: [ ^self ] ] ] ].        tmp4 := (tmp1 select: [:arg4 |  arg4 name = tmp2 name ]) first asMetacelloCachingResolvedReference.        self repositoryMap at: tmp4 name put: tmp4 repository.        (self resolveDependencies: tmp4 nearest: tmp2 into: (OrderedCollection with: tmp2)) do: [:arg5 |  | tmp8 tmp9 |              tmp5 := arg5 version.              (tmp9 := (GoferVersionReference name: arg5 name) resolveAllWith: self loaderPolicy cacheGofer) isEmpty ifTrue: [ self cacheRepository storeVersion: tmp5.                    arg5 == tmp2 ifTrue: [ tmp8 := arg1 ] ifFalse: [ tmp8 := arg1 project packageSpec.                          tmp8 name: tmp5 package name ].                    self loadData addVersion: tmp5 versionInfo: tmp5 info resolvedReference: arg5 packageSpec: tmp8 ] ].        self scheduleFetchFor: arg1 externalReference: tmp4 ] displaying: 'Fetching ' , arg1 fileonWarning: arg1  self addStatement: #onWarning: args: {arg1}canUpgradeTo: arg1  | tmp1 tmp2 |  tmp1 := self map values sort: [:arg2 :arg3 |  arg2 description <= arg3 description ].  tmp2 := arg1 map values sort: [:arg2 :arg3 |  arg2 description <= arg3 description ].  tmp1 size ~= tmp2 size ifTrue: [ ^false ].  1 to: tmp1 size do: [:arg4 |  | tmp3 tmp4 |        tmp3 := tmp1 at: arg4.        tmp4 := tmp2 at: arg4.        (tmp3 canUpgradeTo: tmp4) ifTrue: [ ^true ] ].  ^falsebaselineOrConfigurationNameSuffix  self isBaselineName ifTrue: [ ^self baselineOrConfigurationName copyFrom: 'BaselineOf' size + 1 to: self baselineOrConfigurationName size ].  self isConfigurationName ifTrue: [ ^self baselineOrConfigurationName copyFrom: 'ConfigurationOf' size + 1 to: self baselineOrConfigurationName size ]doFetchRequiredFromArray: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloNotification signal: 'Fetching ' , tmp3 , '...'.  tmp1 := loaderPolicy.  tmp2 := MetacelloPlatform current bypassProgressBars.  self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].  [ | tmp4 |  tmp4 := self fetchRequiredFromArray: arg1.  MetacelloNotification signal: '...finished ' , self versionNumber printString.  ^tmp4 ] ensure: [ MetacelloPlatform current bypassProgressBars: tmp2.        loaderPolicy := tmp1 ]baselineNameFrom: arg1  ^self class baselineNameFrom: arg1loadsForProject: arg1  self root loads: arg1setFor: arg1 version: arg2  self methodSections add: (MetacelloSymbolicVersionSpec new           attributes: arg1 asMetacelloAttributeList;           versionString: arg2;           yourself)label  ^'Error'to: arg1  to := arg1development  ^self version: #developmentfetchingSpecLoader  ^selfvisitingWithPackages: arg1  mergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #description put: description.  tmp1 at: #type put: self type.  tmp1 at: #username put: username.  tmp1 at: #password put: password.  ^tmp1loadAtomicLoadDirective: arg1 gofer: arg2  arg1 loadDirectives do: [:arg3 |  arg3 loadUsing: arg1 gofer: arg2 ].  arg1 finalizeLoad: arg2lock  actionArg := #lock -> #()remove: arg1  arg1 removeFromMetacelloPackages: selfpostLoadDoIt: arg1 constructor: arg2  arg2 postLoadDoItForPackage: arg1configMethodOn: arg1 indent: arg2  self subclassResponsibilitycacheNames: arg1  cacheNames := arg1testVersion16  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1.0').  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1.0.0').  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1.0.0.0')tearDownRepositories  configMethodOn: arg1 indent: arg2  arg1     tab: arg2;     nextPutAll: 'spec '.  self configMethodCascadeOn: arg1 lastCascade: trueprojectClass  ^MetacelloMCProjectensuredMap: arg1  ensuredMap := arg1baselineVersion13Issue154: arg1  < version: '1.3-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1           project: 'MetacelloExample' with: [ arg1                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 projectPackage: [ arg1                       file: 'MetacelloExampleTestConfigurationIssue154.gemstone';                       repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ];           yourself ]packageInfo  ^MetacelloTestsPackageSet named: namecopyFrom: arg1 to: arg2  | tmp1 tmp2 tmp3 |  tmp1 := arg2 - arg1 + 1.  tmp2 := self species new: tmp1.  tmp3 := 0.  arg1 to: arg2 do: [:arg3 |  tmp2 at: tmp3 + 1 put: (self at: arg3).        tmp3 := tmp3 + 1 ].  ^tmp2criticalWarningReasonCodes  ^#(#packageNameMismatch #projectClassNameFileMismatch #duplicateVersionDefinitions)version119ProjectToolBox: arg1  < version: '1.1.9-baseline' imports: #('1.1.4-baseline')>  arg1 for: #common do: [ arg1 project: 'Example Project' overrides: [ arg1                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #alternatePreloadForCore;                 repository: 'http://www.example.com/ob' ] ]mergeSpec: arg1  | tmp1 tmp2 tmp3 |  tmp1 := super mergeSpec: arg1.  tmp2 := arg1 mergeMap.  (tmp3 := tmp2 at: #repositories) isEmpty not ifTrue: [ tmp1 repositories: (self repositories isEmpty ifTrue: [ tmp3 ] ifFalse: [ self repositories mergeSpec: tmp3 ]) ].  ^tmp1issues: arg1  issues := arg1statements: arg1  statements := arg1forceUpdatedPackageSpecs  | tmp1 tmp2 |  tmp1 := Dictionary new.  tmp2 := self loader.  self packages map valuesDo: [:arg1 |  arg1 forceUpdatePackageSpec: tmp1 using: tmp2 ].  ^tmp1lesson11Author  compareEqualTo: arg1  | tmp1 |  arg1 species = self species ifFalse: [ ^false ].  tmp1 := self size.  tmp1 = arg1 size ifFalse: [ ^false ].  1 to: tmp1 do: [:arg2 |  (self at: arg2) = (arg1 at: arg2) ifFalse: [ ^false ] ].  ^truebaselineVersion11Issue154: arg1  < version: '1.1-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1           project: 'MetacelloExample' with: [ arg1                 className: 'ConfigurationOfMetacelloExample';                 versionString: '1.0';                 projectPackage: [ arg1                       name: 'MetacelloExampleTestConfigurationIssue154';                       repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ];           yourself ]version10Issue119: arg1  < version: '1.0' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: '2.0'.        arg1 package: 'GoferBar' with: 'GoferBar-jf.1' ]versionString: arg1  self shouldBeMutable.  versionString := arg1version  cachedVersion == nil ifTrue: [ cachedVersion := super version ].  ^cachedVersionlocalRepository  self ensureLocalRepository.  self validateLocalRepository.  ^localRepositorybaselineVersion30Issue119: arg1  < version: '3.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo ' with: [ arg1                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        arg1 package: 'GoferBar' ]versionString: arg1  versionString := arg1version113ProjectToolBox: arg1  < version: '1.1.3' imports: #('1.1.3-baseline')>  arg1 for: #outer do: [ arg1           package: 'Example-Core' with: 'Example-Core-dkh.1';           package: 'Example-Test' with: 'Example-Test-dkh.1'.        arg1 for: #nested do: [ arg1 package: 'Example-Core' with: 'Example-Core-dkh.2' ] ].  arg1 for: #extra do: [ arg1 package: 'Example-Core' with: 'Example-Core-dkh.3' ]shouldSave  ^self noSave notcopySpec: arg1 from: arg2 to: arg3  | tmp1 |  tmp1 := MetacelloGofer new.  (self repositoriesFrom: arg2) do: [:arg4 |  tmp1 repository: arg4 ].  ^self copySpec: arg1 with: tmp1 to: arg3setProject: arg1  project := arg1getPreLoadDoIt  ^preLoadDoItcurrentVersionInfo  ^self goferPackage currentVersionInfoversion43Issue119: arg1  < version: '4.3' imports: #('4.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo ' with: '2.0'.        arg1 package: 'GoferBar ' with: 'GoferBar-jf.1' ]baselineProjectSpec: arg1  self shouldBeMutable.  configurationProjectSpec := nil.  self assert: arg1 isBaselineOfProjectSpec.  baselineProjectSpec := arg1extractVersionPragmas  | tmp1 |  tmp1 := Dictionary new.  self extractPragmas: #version: into: tmp1.  ^tmp1newProjectRegistration: arg1  newProjectRegistration := arg1testForDoListAttribute1Atrribute2Active  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self projectWith: #(#attribute1 #attribute2).  tmp2 := tmp1 version: '3.0-baseline'.  tmp3 := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec 	project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec 	group: ''Core'' with: #(''Example Project'' );	group: ''Core'' with: #(''Extra Project'' );	group: ''Core'' with: #(''Extra Project'' ).'.  tmp4 := tmp2 spec printString.  self assert: tmp3 equals: tmp4lesson13  createDictionaryRepository: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 description.  tmp2 := 'dictionary://' size.  tmp3 := (tmp1 copyFrom: tmp2 + 1 to: tmp1 size) asSymbol.  ^Smalltalk at: tmp3 ifAbsent: [ Smalltalk at: tmp3 put: (MCDictionaryRepository new                 description: tmp1;                 yourself) ]silently  self addStatement: #silently: args: {true}scheduleFetchFor: arg1 nearestReference: arg2  ^selfsetTimestampWithBlock: arg1  | tmp1 |  (tmp1 := self root getTimestamp) == nil ifTrue: [ tmp1 := self project valueHolderSpec.        self root setTimestamp: tmp1 ].  self with: tmp1 during: arg1testVersion02  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '1.1.1'.  tmp2 := self versionClass fromString: '1.0.0'.  self assert: tmp1 equals: tmp1.  self assert: tmp2 equals: tmp2.  self assert: tmp1 > tmp2testLessThanComparison  self assert: '1.0.0-rc.1+build.1' asMetacelloSemanticVersionNumber < '1.0.0' asMetacelloSemanticVersionNumber.  self assert: '1.0.0-rc.1+build.1' asMetacelloSemanticVersionNumber < '1.0.0+build.0' asMetacelloSemanticVersionNumber.  self assert: '1.0.0-alpha.1' asMetacelloSemanticVersionNumber < '1.0.0-0.3.7' asMetacelloSemanticVersionNumber.  self assert: '1.0.0-alpha' asMetacelloSemanticVersionNumber < '1.0.0-alpha.1' asMetacelloSemanticVersionNumber.  self assert: '1.0.0+-' asMetacelloSemanticVersionNumber < '1.0.0+a' asMetacelloSemanticVersionNumber.  self assert: '1.0.0-0.3.7' asMetacelloSemanticVersionNumber < '1.0.0-x.7.z.92' asMetacelloSemanticVersionNumbertestShouldSave  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self     deny: tmp1 noSave;     assert: tmp1 shouldSave.  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--no-save').  self     assert: tmp1 noSave;     deny: tmp1 shouldSavespec  (spec == nil and: [ self loader ~~ nil ]) ifTrue: [ ^[ self loader spec versionSpec ] on: MessageNotUnderstood do: [:arg1 |  arg1 return: self loader spec ] ].  ^specimport: arg1 provides: arg2 constructor: arg3  arg3 importForVersion: arg1 provides: arg2gtInspectorProjectsIn: arg1  < gtInspectorPresentationOrder: 40>  self version gtInspectorProjectsIn: arg1removeProject: arg1 constructor: arg2  arg2 removeProjectForVersion: arg1initialize  super initialize.  hasNoPackage := hasNoProject := true.  aProjectIsLoaded := aPackageIsLoaded := false.  aLoadedProjectIsExact := aLoadedPackageIsExact := false.  aLoadedProjectIsCurrent := aLoadedPackageIsCurrent := false.  aLoadedProjectIsNotCurrent := aLoadedPackageIsNotCurrent := false.  aProjectNotLoaded := aPackageNotLoaded := false.  vrsnStatus := Set new.  abort := falsedecrementMinorVersion  self decrementNormalVersionAt: 2versionString: arg1  self root versionString: arg1 constructor: selfmethodSource  | tmp1 |  tmp1 := WriteStream on: String new.  self symbolicMethodSelectorAndPragma: self selector symbolicVersionSymbol: self versionString on: tmp1.  (self methodSections asArray sort: [:arg1 :arg2 |  arg1 attributes first <= arg2 attributes first ]) do: [:arg3 |  | tmp2 |        tmp1           cr;           tab;           nextPutAll: 'spec for: ' , arg3 attributePrintString , ' version: '.        tmp2 := arg3 versionString.        tmp2 isSymbol ifTrue: [ tmp1 nextPut: $# ].        tmp1           nextPutAll: tmp2 asString printString , '.';           cr ].  ^tmp1 contentsexecuteBlock: arg1 do: arg2  ((projectSpecGenerator projectSpecListBlock value select: arg1) select: self projectSpecSelectBlock) do: [:arg3 |  arg2 value: (self applyArgsToProjectSpec: arg3 copy) ]evaluateSupplyingAnswers: arg1  | tmp1 |  (tmp1 := self spec answers) notEmpty ifTrue: [ arg1 valueSupplyingMetacelloAnswers: tmp1 ] ifFalse: [ arg1 value ]preReleaseVersion: arg1  preReleaseVersion := arg1configurationProjectSpecIfPresent: arg1 ifAbsent: arg2  ^configurationProjectSpec ifNotNil: [ arg1 cull: configurationProjectSpec ] ifNil: arg2requires: arg1  self shouldNotImplementprojectClass  ^testingEnvironment at: self projectName asSymbolsignal  self messageText: self description.  ^super signalloadPackageDirective: arg1 gofer: arg2  self packageloads add: arg1tutorial  ^#(intro create10Baseline open10ForDevelopment updateVersion10 releaseVersion10 open11ForDevelopment create11Baseline releaseVersion11PharoOnly)resolveToLoadableSpecs: arg1  | tmp1 |  tmp1 := Dictionary new.  self resolveToLoadableSpecs: arg1 forLoad: false map: tmp1.  ^tmp1 valuesrepositorySpecClass  ^MetacelloRepositorySpecnormalVersion: arg1  normalVersion := arg1projectVersionPattern  projectVersionPattern ifNil: [ ^self projectVersion ].  ^projectVersionPatternfetch  ^self execute: #fetch: args: #(#())baseline61Foo: arg1  < version: '6.1'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        arg1           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferBeau');           yourself ]title  ^'postload'shouldDisablePackageCache  disablePackageCache == nil ifTrue: [ disablePackageCache := false ].  ^disablePackageCachebaseline35Fan: arg1  < version: '3.5'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.5';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]version21Issue171: arg1  < version: '2.1' imports: #('2.1-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: '2.0'.        arg1 package: 'GeauxFoo' with: 'GeauxFoo-lr.1' ]getPostLoadDoIt  ^postLoadDoIttestRemovePackageC  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp1 remove: {'Package'}.  tmp2 := false.  tmp1 packageNamed: 'Package' ifAbsent: [ tmp2 := true ].  self assert: tmp2for: arg1 version: arg2  arg1 setForVersion: arg2 withInMetacelloConfig: selftestPrinting  | tmp1 tmp2 |  self sampleVersionStrings do: [:arg1 |  self assert: arg1 equals: (tmp1 := (tmp2 := arg1 asMetacelloSemanticVersionNumber) printString) ]signal: arg1  self cacheNames: arg1.  ^self signalresolveToLoadableSpecs: arg1  ^self spec resolveToLoadableSpecs: arg1mutable  mutable := trueverify: arg1 loadedFrom: arg2  | tmp1 |  tmp1 := MCWorkingCopy allManagers detect: [:arg3 |  arg3 packageName = arg1 ].  self assert: (tmp1 repositoryGroup repositories includes: (MetacelloMCProject new repositorySpec description: arg2) createRepository)scheduleFetchFor: arg1 cachedReference: arg2  ^self scheduleFetchFor: arg1 reference: arg2 message: 'Fetched -> (cached) ' , arg2 name , ' --- ' , arg2 repository repositoryDescription , ' --- ' , arg2 repository descriptionversionString: arg1  versionString := arg1setDescriptionWithBlock: arg1  | tmp1 |  (tmp1 := self root getDescription) == nil ifTrue: [ tmp1 := self project valueHolderSpec.        self root setDescription: tmp1 ].  self with: tmp1 during: arg1setConfiguration: arg1 withBlock: arg2  | tmp1 tmp2 |  tmp2 := self project configurationOfProjectSpec     name: arg1;     yourself.  tmp1 := self project projectReferenceSpec     name: arg1;     projectReference: tmp2;     yourself.  self root packages merge: tmp1.  self with: tmp2 during: arg2immutable  mutable := falsepassword: arg1  password := arg1loadExplicitLoadDirective: arg1 gofer: arg2  asMetacelloAttributePath  ^selfaLoadedProjectIsExact: arg1  aLoadedProjectIsExact := arg1savePackageUsing: arg1  | tmp1 tmp2 tmp3 tmp4 |  (tmp1 := self spec workingCopy) == nil ifTrue: [ ^false ].  (tmp1 ancestry ancestors notEmpty and: [ tmp1 modified not ]) ifTrue: [ ^false ].  tmp3 := self spec repositorySpecs notEmpty ifTrue: [ self spec repositorySpecs ] ifFalse: [ arg1 ].  (self spec getFile == nil or: [ tmp1 ancestry ancestors isEmpty ]) ifTrue: [ tmp2 := (self repositoriesFrom: tmp3 ignoreOverrides: true) first ] ifFalse: [ [ | tmp5 |        tmp2 := (self resolveSpec: self spec from: tmp3) repository.        tmp5 := tmp1 possiblyNewerVersionsIn: tmp2.        tmp5 isEmpty not ifTrue: [ (MetacelloPlatform current confirm: 'CAUTION! These versions in the repository may be newer:' , String cr , tmp5 printString , String cr , 'Do you really want to save this version?') ifFalse: [ ^false ] ] ] on: Error do: [:arg2 |  ^false ] ].  (tmp4 := MetacelloPlatform current newVersionForWorkingCopy: tmp1) == nil ifTrue: [ ^false ].  tmp2 storeVersion: tmp4.  ^truesupplyingAnswers: arg1  self root supplyingAnswers: arg1 constructor: selfversion10Issue115: arg1  < version: '1.0' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo'.        arg1 package: 'GeauxFoo' with: 'GeauxFoo-lr.1' ]setUpConfigurationOfProjectIssue283dkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfProjectIssue283-dkh.2'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'stableVersion283B:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #stableVersion283B:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'bleedingEdge206B:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #bleedingEdge206B:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version20Issue283:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version21Issue283:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version21Issue283:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4errorMap  ^errorMaploaderClass: arg1  loaderClass := arg1validateVersionLoad: arg1 loads: arg2  | tmp1 |  tmp1 := arg2 asOrderedCollection.  tmp1 isEmpty ifTrue: [ tmp1 add: 'default' ].  (arg1 groups includes: 'Tests') ifTrue: [ tmp1 add: 'Tests' ].  arg1 load: tmp1projectClass  ^MetacelloMCProjecthandleResolutionFor: arg1  ^arg1 handleProjectSpecLoaded: selfpreloadDoIt  Smalltalk at: #Metacello_Configuration_Test_DoIt_Result put: trueapplyToList: arg1  self subclassResponsibilityrelativeCurrentVersion  | tmp1 tmp2 tmp3 |  (tmp1 := self versionOrNil) == nil ifTrue: [ ^nil ].  tmp2 := [ tmp1 expandToLoadableSpecNames: (tmp3 := self loadListForVersion: tmp1) ] on: Error do: [:arg1 |  tmp1 blessing == #development ifTrue: [ self ensureLoadUsing: self loader.              tmp1 := self versionOrNil.              arg1 return: (tmp1 expandToLoadableSpecNames: tmp3) ].        arg1 pass ].  ^self projectClassProject currentVersionAgainst: tmp2add: arg1  self subclassResponsibilityrepositoryOverrides: arg1  self addStatement: #repositoryOverrides: args: {arg1}isResumable  ^truehandleEnsureProjectLoadedForDevelopment: arg1  ^arg1 resume: self useCurrentVersionbaseline12MethodSourceC  ^(self class sourceCodeAt: #baseline12C:) asStringpackageloads: arg1  packageloads := arg1approximateBase  | tmp1 |  tmp1 := self copyFrom: 1 to: self size - 1.  tmp1 at: tmp1 size put: (tmp1 at: tmp1 size) + 1.  ^tmp1isAllLoadedToSpecAgainst: arg1  (self isPartiallyCurrentAgainst: arg1) isAllLoadedToSpec: [:arg2 |  ^true ].  ^falsecategory  ^categorycopy: arg1 to: arg2  self subclassResponsibilityrunCase  | tmp1 |  self doSilently ifFalse: [ ^super runCase ].  tmp1 := MetacelloPlatform current bypassGoferLoadUpdateCategories.  [ MetacelloPlatform current bypassGoferLoadUpdateCategories: true.  ^MetacelloPlatform current suspendSystemUpdateEventsDuring: [ super runCase ] ] ensure: [ MetacelloPlatform current bypassGoferLoadUpdateCategories: tmp1 ]addBaselineOfSection: arg1 requiredProjects: arg2 packages: arg3 dependencies: arg4 groups: arg5 versionSpecsDo: arg6  self addBaselineOfSection: arg1 requiredProjects: arg2 packages: arg3 dependencies: arg4 includes: #() files: #() repositories: #() preLoadDoIts: #() postLoadDoIts: #() supplyingAnswers: #() groups: arg5 versionSpecsDo: arg6setPreLoadDoIt: arg1  preLoadDoIt := arg1commitConfiguration: arg1  symbolicVersionSymbols  ^nilpackageDirectivesDo: arg1  version04: arg1  < version: '0.4'>  arg1 for: #common do: [ arg1 repository: 'http://www.example.com/Example'.        arg1           package: 'Example-Core' with: 'Example-Core-anon.10';           package: 'Example-Tests' with: 'Example-Tests-anon.3' ]select: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self do: [:arg2 |  (arg1 value: arg2) ifTrue: [ tmp1 add: arg2 ] ].  ^tmp1executorSpec  executorSpec ifNil: [ executorSpec := #MetacelloScriptApiExecutor -> 'batch' ].  ^executorSpecgetPostLoadDoIt  ^postLoadDoItasConfigurationProject  ^selfclassNameForProject: arg1  self root className: arg1mergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #projectReference put: projectReference.  ^tmp1configurationRepository  ^MetacelloConfigurationResource current monticelloRepositoryspec  ^specrepositories: arg1 constructor: arg2  arg2 repositoriesForVersion: arg1package: arg1 constructor: arg2  arg2 packageForVersion: arg1baseline20MethodSourceFan  ^(self class sourceCodeAt: #baseline20Fan:) asStringcreateRepository: arg1  ^MetacelloPlatform current createRepository: arg1hasConflictWithConfigurationSpec: arg1  ^self hasLoadConflicts: arg1lesson11Descripton  ^Lesson title: 'Lesson 11 (Description)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."A description can be defined for a version:"	(MetacelloTutorialConfig project version: ''1.1'') description.	ProfStef next.'updateVersion10  ^Lesson title: 'Update specs for version 1.0' lesson: '"	1. Create configuration	2. Prepare to update the version method for version 1.0:		- with #updateProjects set to true, the current version of the project Shout will set		- with #updatePackages set to true, the current mcz files for the packages ProfStef-Core ProfStef-Tests will be set	3. Define desired versionSpec attributes		- current author and timestamp	4. Append the #logEntry to the version descripttion	5. Compile the #version10: method		- compile and validate"		| logEntry |	logEntry := ''- fixed a bug''."1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		updateVersionMethodForVersion: ''1.0''			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ "3."						versionSpec							author: MetacelloPlatform current authorName;							timestamp: MetacelloPlatform current timestamp."4."						versionSpec description value isEmpty							ifTrue: [ versionSpec description: logEntry ]							ifFalse: [ 								| strm |								strm := WriteStream on: String new.								strm									nextPutAll: versionSpec description value;									cr;									nextPutAll: logEntry.								versionSpec description: strm contents ] ].				true ];"5."		commitMethod."After evaluating the above expression, take a look at the updated method #version10. Unless you changed the packages that were loaded in your image, you should just see the #timestamp and #description fields updated."ProfStef next.'readStreamOn: arg1 do: arg2  ^arg1 readStreamDo: arg2sortPackageSpecs: arg1 packageSpec: arg2 groupLoops: arg3 for: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := arg1 indexOf: arg2.  tmp2 := tmp3 := false.  tmp6 := arg2 requiredSpecNamesForPackageOrdering: arg4.  tmp7 := arg3 includes: arg2.  tmp7 ifFalse: [ tmp6 do: [:arg5 |  tmp4 := arg1 detect: [:arg6 |  arg6 name = arg5 ] ifNone: [ MetacelloNameNotDefinedError signal: 'project group, or package named: ' , arg5 printString , ' not found when used in requires: or includes: field of package: ' , arg2 name printString , ' for version: ' , arg4 versionString , ' of ' , arg4 projectLabel , '.'.                    nil ].              tmp5 := arg1 indexOf: tmp4.              (tmp7 not and: [ tmp1 = tmp5 ]) ifTrue: [ self notify: 'A group loop has been detected. The package: ' , arg2 name printString , ' requires a group that includes itself. If you resume, the group loop will be ignored and details will be written to the system log.'.                    tmp7 := true.                    arg3 add: arg2.                    MetacelloNotification signal: 'Package: ' , arg2 name printString.                    MetacelloNotification signal: 'Raw Requires:' level: 2.                    arg2 requires do: [:arg6 |  MetacelloNotification signal: arg6 asString level: 3 ].                    MetacelloNotification signal: 'Package: ' , arg2 name printString , ' has a group loop:'.                    MetacelloNotification signal: 'Expanded Requires:' level: 2.                    tmp6 do: [:arg6 |  MetacelloNotification signal: arg6 asString level: 3 ] ].              tmp3 := tmp3 or: [ tmp1 <= tmp5 ].              false ifTrue: [ tmp1 < tmp5 ifTrue: [ MetacelloNotification signal: 'Moving ' , arg5 , ' from ' , tmp5 printString , ' to ' , tmp1 printString ] ] ] ].  tmp7 ifTrue: [ tmp6 := arg2 requires.        tmp6 do: [:arg7 |  tmp4 := arg1 detect: [:arg6 |  arg6 name = arg7 ] ifNone: [  ].              tmp5 := arg1 indexOf: tmp4.              tmp3 := tmp3 or: [ tmp1 <= tmp5 ] ] ].  tmp3 ifTrue: [ tmp2 := true.        arg1 remove: arg2 ifAbsent: [ ^self error: 'unexpected error removing package' ].        tmp5 := 0.        tmp6 do: [:arg5 |  (tmp4 := arg1 detect: [:arg6 |  arg6 name = arg5 ] ifNone: [  ]) ~~ nil ifTrue: [ tmp5 := tmp5 max: (arg1 indexOf: tmp4) ] ].        tmp5 == 0 ifTrue: [ arg1 add: arg2 beforeIndex: tmp1 ] ifFalse: [ arg1 add: arg2 afterIndex: tmp5 ] ].  ^tmp2directory  ^self localRepository directoryimportForVersion: arg1 provides: arg2  self root import: arg1 provides: arg2copyMember  ^MetacelloCopyMemberSpec for: self projectsetUpRepositoryContents  super setUpRepositoryContents.  self setUpRepositoryContents: self configurationRepositoryContents sourceRepo: MetacelloScriptingResource current configurationRepository targetRepo: (MCFileTreeRepository new directory: configurationDirectory).  self setUpRepositoryContents: self externalRepositoryContents sourceRepo: MetacelloScriptingResource current externalRepository targetRepo: (MCFileTreeRepository new directory: externalDirectory).  self setUpRepositoryContents: self sampleRepositoryContents sourceRepo: MetacelloScriptingResource current sampleRepository targetRepo: (MCFileTreeRepository new directory: sampleDirectory)projectWith: arg1  | tmp1 |  tmp1 := MetacelloProject new.  tmp1 projectAttributes: arg1.  MetacelloVersionConstructor on: self project: tmp1.  ^tmp1packageNamed: arg1 ifAbsent: arg2  ^self map at: arg1 ifAbsent: arg2latestVersion: arg1  ^(self map values select: [:arg2 |  arg1 = arg2 blessing ]) detectMax: [:arg2 |  arg2 ]isMutable  mutable ifNil: [ ^true ].  ^mutableproject: arg1 overrides: arg2 constructor: arg3  arg3 projectForVersion: arg1 overrides: arg2aLoadedPackageIsCurrent  ^aLoadedPackageIsCurrentregister  actionArg := #register -> #()version10: arg1  < version: '1.0' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #release ]projectName  ^projectNameauthorName: arg1  self subclassResponsibilitysetAuthor: arg1  author := arg1setUp  | tmp1 |  super setUp.  MetacelloPlatform current clearPackageCache.  tmp1 := self monticelloRepository.  gofer := Gofer new.  gofer disablePackageCache.  gofer repository: tmp1.  testingEnvironment at: #Metacello_Gofer_Test_Repository put: tmp1.  tmp1 := self configurationRepository.  gofer repository: tmp1.  testingEnvironment at: #Metacello_Configuration_Test_Repository put: tmp1.  initialWorkingCopyList := MCWorkingCopy allManagers collect: [:arg1 |  arg1 packageName ]do: arg1 separatedBy: arg2  | tmp1 |  tmp1 := true.  self do: [:arg3 |  tmp1 ifTrue: [ tmp1 := false ] ifFalse: [ arg2 value ].        arg1 value: arg3 ]baseline16: arg1  < version: '1.6-baseline'>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'filetree://' , MCFileTreeFileUtils current default fullName , '/temp/repo' ] ]projectDo: arg1 packageDo: arg2 groupDo: arg3  arg3 value: selftestReferenceConfigPrintString  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := MetacelloReferenceConfig project version: '1.0-baseline'.  tmp2 := self conditionResult: tmp1 spec printString.  tmp3 := self expectedPrintString.  1 to: tmp2 size do: [:arg1 |  (arg1 > tmp3 size or: [ (tmp2 at: arg1) ~= (tmp3 at: arg1) ]) ifTrue: [ tmp4 := tmp2 copyFrom: (arg1 - 25 max: 1) to: (arg1 + 25 min: tmp2 size).              tmp5 := tmp3 copyFrom: ((arg1 - 25 max: 1) min: tmp3 size) to: (arg1 + 25 min: tmp3 size).              Array with: tmp4 with: tmp5 ] ].  self assert: tmp2 equals: tmp3compareEqualTo: arg1  arg1 species = self species ifFalse: [ ^false ].  (self compareEqualTo: self normalVersion other: arg1 normalVersion) ifFalse: [ ^false ].  (self compareEqualTo: self preReleaseVersion other: arg1 preReleaseVersion) ifFalse: [ ^false ].  ^self compareEqualTo: self buildVersion other: arg1 buildVersiontestCopyToPackage  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp1 copy: 'Package' to: (self packageSpec           name: 'PackageCopy';           yourself).  tmp2 := tmp1 packageNamed: 'PackageCopy' ifAbsent: [ self assert: false ].  self assert: tmp2 name equals: 'PackageCopy'.  self assert: tmp2 requires equals: #('AnotherPackage').  self assert: tmp2 includes equals: #('IncludedPackage').  self assert: tmp2 answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer')).  self assert: tmp2 file equals: 'Package-dkh.1'.  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoIttestProjectReferenceMergeSpec  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self projectReferenceSpec     name: 'Project';     projectReference: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           yourself);     yourself.  tmp2 := self projectReferenceSpec     name: 'Project';     projectReference: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectB';           versionString: '1.0';           yourself);     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: tmp3 name equals: 'Project'.  self assert: tmp3 projectName equals: 'Project'.  tmp4 := tmp3 projectReference.  self assert: tmp4 className equals: 'ConfigurationOfProjectB'.  self assert: tmp4 versionString equals: '1.0'testIncrementDecrementVersionNumber  | tmp1 |  super testIncrementDecrementVersionNumber.  tmp1 := '1' asMetacelloVersionNumber.  self assert: tmp1 incrementMinorVersionNumber asString equals: '2'.  self assert: tmp1 decrementMinorVersionNumber asString equals: '1'.  tmp1 := '1.0' asMetacelloVersionNumber.  self assert: tmp1 incrementMinorVersionNumber asString equals: '1.1'.  self assert: tmp1 decrementMinorVersionNumber asString equals: '1.0'.  tmp1 := '1.0.0' asMetacelloVersionNumber.  self assert: tmp1 incrementMinorVersionNumber asString equals: '1.0.1'.  self assert: tmp1 decrementMinorVersionNumber asString equals: '1.0.0'.  tmp1 := '1.0.0.0' asMetacelloVersionNumber.  self assert: tmp1 incrementMinorVersionNumber asString equals: '1.0.0.1'.  self assert: tmp1 decrementMinorVersionNumber asString equals: '1.0.0.0'currentVersionString  ^self configurationProjectSpec ifNotNil: [:arg1 |  arg1 versionString ] ifNil: [ baselineProjectSpec repositoryVersionString ]executeString: arg1 do: arg2  singleRoot ifNil: [ self singleRoot: true ].  ((projectSpecGenerator projectSpecLookupBlock value: arg1) select: self projectSpecSelectBlock) do: [:arg3 |  arg2 value: (self applyArgsToProjectSpec: arg3 copy) ]configuration: arg1  configuration := arg1versionString: arg1 constructor: arg2  arg2 versionStringForProject: arg1packageNamed: arg1  ^self packageNamed: arg1 ifAbsent: [ ^nil ]project: arg1  project := arg1group: arg1 overrides: arg2 constructor: arg3  arg3 groupForVersion: arg1 overrides: arg2extractExcludedValidations  | tmp1 |  tmp1 := Dictionary new.  (Pragma allNamed: #excludedValidationIssues: in: self configurationClass) do: [:arg1 |  | tmp2 |        tmp2 := arg1 argumentAt: 1.        1 to: tmp2 size by: 2 do: [:arg2 |  tmp1 at: (tmp2 at: arg2) put: (tmp2 at: arg2 + 1) ] ].  ^tmp1packageInfoFor: arg1  ^arg1 packageInforoot  ^rootcurrentPackageLoaded: arg1 notLoaded: arg2 using: arg3  | tmp1 |  tmp1 := arg3 ancestorsFor: self.  tmp1 notNil ifTrue: [ self getFile == nil ifTrue: [ ^arg1 value: #() value: self file ].        ^arg1 value: tmp1 value: self file ].  ^arg2 valuetestAddA  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'DaleHenrichs';           password: 'secret';           yourself).  tmp2 := tmp1 map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: 'http://example.com/repository'.  self assert: tmp2 type equals: 'http'.  self assert: tmp2 username equals: 'DaleHenrichs'.  self assert: tmp2 password equals: 'secret'mergeScriptRepository: arg1  self repositories: arg1 repositoriescheckpointSave  ^Lesson title: '4. Checkpoint save' lesson: '"After having done development for awhile, you may want to checkpoint your work to share with others, test in another development environment or just to backup your work.You can save the modified mcz files, update the development version spec with the new mcz file names and then save the configuration:"	MetacelloToolBox 		saveModifiedPackagesAndConfigurationIn: ConfigurationOfExample		description: ''- fixed Issue 1090''."Or you can arrange to just save the modified mcz files and update the development version spec with the new mcz file names:"	MetacelloToolBox 		saveModifiedPackagesIn: ConfigurationOfExample		description: ''- fixed Issue 1090''.ProfStef next.'repositoryForVersion: arg1  self repositoryForSpec: arg1baselineOfVersionSpecClass  ^self subclassResponsibilityprojectSpec  ^self project projectSpeccheckAllowed  self existingProjectRegistration locked ifTrue: [ self resume: (MetacelloAllowLockedProjectChange new                 operationString: self operationString;                 existingProjectRegistration: self existingProjectRegistration;                 newProjectRegistration: self newProjectRegistration;                 signal) ]scpUrl  ^self sshPort ifNil: [ 'git@<1s>:<2s>.git' expandMacrosWith: self hostname with: projectPath ] ifNotNil: [:arg1 |  'ssh://git@<1s>:<2s>/<3s>.git' expandMacrosWith: self hostname with: arg1 with: projectPath ]validate: arg1 expConfigVersion: arg2 expConfigRepo: arg3 expBaselineClassName: arg4 expBaselineVersion: arg5 expBaselineRepo: arg6  MetacelloProjectRegistration registry configurationRegistry at: arg1 ifPresent: [:arg7 |  | tmp1 tmp2 |        tmp1 := arg7 configurationProjectSpec.        self assert: (tmp2 := tmp1 version versionString) equals: arg2.        self assert: (tmp1 repositoryDescriptions includes: arg3) ] ifAbsent: [ self assert: arg2 identicalTo: nil ].  MetacelloProjectRegistration registry baselineRegistry at: arg4 ifPresent: [:arg7 |  | tmp1 |        tmp1 := arg7 baselineProjectSpec.        self assert: tmp1 versionString equals: arg5.        self assert: (tmp1 repositoryDescriptions includes: arg6) ] ifAbsent: [ self assert: arg5 identicalTo: nil ]setUpVersionReferences  versionReferences := OrderedCollection new.  versionReferences     add: (GoferVersionReference name: 'GoferFan-dkh.1') -> #GoferFar;     add: (GoferVersionReference name: 'GoferBar-dkh.1') -> #Object;     add: (GoferVersionReference name: 'GoferFoo-dkh.4') -> #GoferBeau;     add: (GoferVersionReference name: 'GoferFoo-dkh.5') -> #GoferBeau;     add: (GoferVersionReference name: 'GoferBeau-dkh.15') -> #GoferBar;     add: (GoferVersionReference name: 'GoferFaux-tg.30') -> #Object;     add: (GoferVersionReference name: 'GoferFar-dkh.4') -> #GoferFoo;     add: (GoferVersionReference name: 'GoferBarDependency-dkh.4') -> #Object;     add: (GoferVersionReference name: 'GoferFooDependency-lr.4') -> #Object;     add: (GoferVersionReference name: 'GoferBarDependency-lr.30') -> #Object;     add: (GoferVersionReference name: 'GoferFooDependency-lr.30') -> #Object;     add: (GoferVersionReference name: 'GoferBarDependency-lr.35') -> #Object;     add: (GoferVersionReference name: 'GoferFooDependency-lr.35') -> #Object;     yourselfrepositories: arg1 constructor: arg2  arg2 repositoriesForProject: arg1commitMethod  | tmp1 |  tmp1 := false.  self methodSpec ifNil: [ ^self ].  self methodSpec compileMethod.  project := project configuration class project.  [ project version: self methodSpec versionString ] on: MetacelloSymbolicVersionDoesNotExistError do: [:arg1 |  tmp1 := true ].  tmp1 ifFalse: [ self validateVersion: self methodSpec versionString ].  methodSpec := nilsetUpRepositoryContents  super setUpRepositoryContents.  testingEnvironment at: #Metacello_Config_Test_Repository put: configurationRepositoryremoveFromMetacelloRepositories: arg1  arg1 addMember: (arg1 removeMember           name: self name;           spec: self;           yourself)postCopy  super postCopy.  goferPackage := nil.  repositories := repositories copyincludesForPackage: arg1  self root includes: arg1defaultSymbolicVersionResolverBlock: arg1  ^[:arg2 :arg3 |  | tmp1 |  tmp1 := nil.  (arg3 argumentAt: 1) = arg2 ifTrue: [ self symbolicVersion: arg2.        tmp1 := [ arg1 perform: (MetacelloPlatform current selectorForPragma: arg3) ] on: MetacelloVersionDoesNotExistError do: [:arg4 |  arg4 return: nil ] ].  tmp1 ]testIsConfigurationName  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self deny: tmp1 isConfigurationName.  tmp1 := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self assert: tmp1 isConfigurationNameloader: arg1  loader := arg1loads: arg1  self root loads: arg1 constructor: selfapplyToList: arg1  arg1 add: selfversionSpecClass  ^MetacelloVersionSpecpreLoadDoIt: arg1  arg1 setPreLoadDoItInMetacelloSpec: selfpostLoadDoIt  ^postLoadDoItmergeRepositoriesSpec: arg1  self repositories: arg1shouldQuit  ^self noQuit nottestVersion01  self assert: (self versionClass fromString: '1.1.1') versionString equals: '1.1.1'includeSpecNamesForPackageOrdering: arg1  ^self specs: self includesForPackageOrdering forPackageOrdering: arg1preLoadDoItForVersion: arg1  self preLoadDoItForSpec: arg1setUpRepositories  configurationRepository := MCDictionaryRepository new.  externalRepository := MCDictionaryRepository new.  sampleRepository := MCDictionaryRepository newlocked  ^self     project: [:arg1 |  arg1 isLocked ];     listpostloadDoIt  Smalltalk at: #Metacello_Configuration_Test_POST_DoIt_Result put: trueprojectSpecLookupBlock  ^[:arg1 |  {(MetacelloProjectRegistration projectSpecForClassNamed: (MetacelloScriptEngine baselineNameFrom: arg1) ifAbsent: [  ]) .   (MetacelloProjectRegistration projectSpecForClassNamed: (MetacelloScriptEngine configurationNameFrom: arg1) ifAbsent: [  ])} ]versionString  ^versionStringintro  ^Lesson title: 'Intro' lesson: '"The lessons in this section cover some of the same material that was covered in the development process tutorial, but we take a closer look at the implementation using the instance-side protocol instead of the class-side protocol"	ProfStef next.'isEmpty  ^self list isEmptyincludesVersionNamed: arg1  ^self localRepository includesVersionNamed: arg1load: arg1  ^(self version: arg1) loadupdateCategories  MetacelloPlatform current bypassGoferLoadUpdateCategories ifFalse: [ super updateCategories ]executeString: arg1 do: arg2  singleRoot ifNil: [ self singleRoot: true ].  (projectSpecGenerator projectSpecCreationBlock value: arg1) do: [:arg3 |  arg3 ifNotNil: [ arg2 value: (self applyArgsToProjectSpec: arg3 copy) ] ]postCopy  super postCopy.  requires := requires copy.  includes := includes copy.  answers := answers copyexecute  self workingCopies do: [:arg1 |  self unload: arg1 ].  self model load.  self gofer metacelloCleanup.  self workingCopies do: [:arg1 |  self unregister: arg1 ]monticelloRepository  ^monticelloRepositoryonConflictUseIncoming: arg1 useLoaded: arg2  self onConflict: [:arg3 :arg4 :arg5 |  (arg1 includes: arg5 baseName) ifTrue: [ arg3 useIncoming ] ifFalse: [ (arg2 includes: arg5 baseName) ifTrue: [ arg3 useLoaded ] ].        arg3 pass ]lesson11Timestamp  ^Lesson title: 'Lesson 11 (Timestamp)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."The timestamp of a version can be defined:"	(MetacelloTutorialConfig project version: ''1.1'') timestamp."When using the OB-Metacello tools the timestamp field is automatically updated to reflect the currentDateAndTime that the update was made.The timestamp is a String"ProfStef next.'baseline40ProjectFum: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Feaux' with: [ arg1                 className: 'MetacelloTestConfigurationOfFeaux';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFeaux';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'ProjectFie' with: [ arg1                 className: 'MetacelloTestConfigurationOfProjectFie';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfProjectFie';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'ProjectFee' with: [ arg1                 className: 'MetacelloTestConfigurationOfProjectFee';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfProjectFee';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]hasRepositoryOverrides  ^self overrideRepositories ~~ nilconfigMethodOn: arg1 indent: arg2  arg1     tab: arg2;     nextPutAll: 'spec ';     cr;     tab: arg2 + 1;     nextPutAll: 'name: ' , self name printString , ';'.  self configMethodBodyOn: arg1 indent: arg2.  arg1 nextPut: $.lesson14  setUp  | tmp1 |  super setUp.  MetacelloPlatform current clearPackageCache.  MetacelloConfigurationResource projectAttributes: nil.  tmp1 := self monticelloRepository.  self tempRepositories add: tmp1.  gofer repository: tmp1.  testingEnvironment at: #Metacello_Gofer_Test_Repository put: tmp1.  tmp1 := self alternateRepository.  self tempRepositories add: tmp1.  testingEnvironment at: #Metacello_Configuration_Test_Alternate_Repository put: tmp1.  tmp1 := self configurationRepository.  self tempRepositories add: tmp1.  testingEnvironment at: #Metacello_Configuration_Test_Repository put: tmp1.  initialWorkingCopyList := MCWorkingCopy allManagers collect: [:arg1 |  arg1 packageName ].  undefinedSymbols := MetacelloPlatform current disableUndefinedSybolUpdatestestForDoListNotActive  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self projectWith: #().  tmp2 := tmp1 version: '3.0-baseline'.  tmp3 := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec group: ''Core'' with: #(''Example Project'' ).'.  tmp4 := tmp2 spec printString.  self assert: tmp3 equals: tmp4packageDo: arg1  arg1 value: selfhttpsUrl  ^'https://bitbucket.org/' , projectPath , '.git'cacheRepository: arg1  self loaderPolicy cacheRepository: arg1lesson10  ^Lesson title: 'Lesson 10' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline10:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version10:."In lesson07 it was obvious that we copied the configuration information from MetacelloTutorialConfig and adapted it to our project.There is a better way.In #baseline10: we''ve created a project reference for the Example project.The #className: specifies the name of the class that contains the project metadata. If the class is not present in the image, then we know that we need to load the configuration for the project.The #file: and #repository: specifications give us the information needed to load the project metadata from a repository.Finally, the #versionString: and #loads: tell us which version of the project to load and which packages to load from the project.We''ve named the project reference ''Example ALL'' and in the specification for the ''Project-Core'' package, we''ve specified that ''Example ALL'' is required:"  (MetacelloProjectRefTutorialConfig project version: ''1.0'') load."Note that the entire Example project is loaded before ''Project-Core''"ProfStef next.'setRequires: arg1  requires := arg1buildVersion  buildVersion ifNil: [ buildVersion := #() ].  ^buildVersionprojects  | tmp1 |  tmp1 := OrderedCollection new.  self spec projectDo: [:arg1 |  tmp1 add: arg1 projectReference ] packageDo: [:arg2 |   ] groupDo: [:arg2 |   ].  ^tmp1author: arg1  self root author: arg1 constructor: selfremovePackageForVersion: arg1  | tmp1 |  tmp1 := self project packageSpec     name: arg1;     yourself.  self root packages remove: tmp1unload  self subclassResponsibilityparentDirectoryOf: arg1  ^arg1 containingDirectoryrequiresSpecsForPackageOrdering: arg1  ^{self}isPossibleBaseline  ^self spec isPossibleBaselinebaseline60MethodSourceProjectIssue86  ^(self class sourceCodeAt: #baseline60ProjectIssue86:) asStringresolveToAllPackagesIn: arg1 visited: arg2  | tmp1 |  arg2 pushProject: [ arg2 visit: self doing: [:arg3 |  arg3 ensureProjectLoaded.              tmp1 := arg3 version.              ^tmp1 allPackagesForSpecNamed: (self loadListForVersion: tmp1) ifAbsent: [ self error: 'invalid loads: spec' ] ] ].  ^#()baselineGooIssue156Baseline: arg1  < baseline>  arg1 for: #common do: [ arg1           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar.branch-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           yourself ]operationString: arg1  operationString := arg1expandToLoadableSpecNames: arg1  | tmp1 tmp2 |  tmp1 := Array with: self label with: arg1.  ^MetacelloPlatform current stackCacheFor: #loadableSpecNames at: tmp1 doing: [:arg2 |  tmp2 := (self resolveToLoadableSpecs: arg1) collect: [:arg3 |  arg3 name ].        arg2 at: tmp1 put: tmp2 ]monticelloRepository  ^monticelloRepositoryhonor  ^self disallowtype: arg1  type := arg1gtInspectorProjectsIn: arg1  < gtInspectorPresentationOrder: 40>  arg1 list     title: 'Projects';     display: [ | tmp1 |        tmp1 := OrderedCollection new.        self projectDo: [:arg2 |  tmp1 add: arg2 ] packageDo: [:arg3 |   ] groupDo: [:arg4 |   ].        tmp1 ]blessing  ^self basicSpec blessing valueconfiguration091Issue181: arg1  < version: '0.9.1'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration091Issue181:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           import: 'External' ]project  ^project ifNil: [ | tmp1 tmp2 |        tmp1 := (Smalltalk at: #MetacelloVersionConstructor) on: self.        project := tmp1 project.        tmp2 := MetacelloNullRecordingMCSpecLoader new.        tmp2 evalDoits: true.        project loader: tmp2.        project ]constructClassName  ^'BaselineOf' , self namecompareEqualTo: arg1 other: arg2  | tmp1 |  tmp1 := arg1 size.  tmp1 = arg2 size ifFalse: [ ^false ].  1 to: tmp1 do: [:arg3 |  (arg1 at: arg3) = (arg2 at: arg3) ifFalse: [ ^false ] ].  ^trueextractCommonDefaultSymbolicVersionPragmas  | tmp1 |  tmp1 := Dictionary new.  self extractPragmas: #defaultSymbolicVersion: for: ConfigurationOf into: tmp1.  ^tmp1unregisterProject  ^MetacelloProjectRegistration registrationForProjectSpec: self ifAbsent: [  ] ifPresent: [:arg1 :arg2 |  arg1 unregisterProject ]version10: arg1  < version: '1.0' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1           description: 'Version 1.0 the current stable release';           blessing: #release;           author: 'John Doe';           timestamp: '2013-05-01'.        arg1           package: 'MyProject-Core' with: 'MyProject-Core-JohnDoe.52';           package: 'MyProject-Tests' with: 'MyProject-Tests-JohnDoe.73';           project: 'FuelMetalevel' with: #stable ]unlock  | tmp1 |  MetacelloProjectRegistration copyRegistryRestoreOnErrorWhile: [ self setDefaultsAndValidate: self projectSpec copy.        tmp1 := self projectSpec.        MetacelloProjectRegistration registrationForProjectSpec: tmp1 ifAbsent: [:arg1 |   ] ifPresent: [:arg2 :arg3 |  arg2 copyOnWrite: [:arg4 |  arg4 locked: false ] ].        self root: tmp1 ]isLoadedMatchConstraints: arg1  | tmp1 |  tmp1 := #loadedMatchConstraints.  (self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints)) ifTrue: [ aPackageIsLoaded & aProjectIsLoaded ifTrue: [ (aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not and: [ aLoadedProjectIsExact | aLoadedProjectIsCurrent & aLoadedProjectIsNotCurrent not ]) ifTrue: [ arg1 value: tmp1 ] ] ifFalse: [ aPackageIsLoaded ifTrue: [ aLoadedPackageIsExact | aLoadedPackageIsCurrent & aLoadedPackageIsNotCurrent not ifTrue: [ arg1 value: tmp1 ] ] ifFalse: [ hasNoPackage & (aLoadedProjectIsExact | aLoadedProjectIsCurrent) & aLoadedProjectIsNotCurrent not ifTrue: [ arg1 value: tmp1 ] ] ] ]description: arg1  description := arg1addToMetacelloPackages: arg1  arg1 addMember: (arg1 addMember           name: self name;           spec: self;           yourself)projectSpecClass  ^MetacelloProjectSpecselectorForPragma: arg1  ^arg1 methodSelectormethodSections  methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].  ^methodSectionspreLoad: arg1  self evalDoits ifFalse: [ ^self ].  arg1 preLoadDoItBlock ~~ nil ifTrue: [ self beforeLoads add: arg1 printString , ' load' ].  super preLoad: arg1latestVersion  | tmp1 |  self flag: 'deprecate after version 1.0'.  tmp1 := self excludeFromLatestVersion.  ^(self map values select: [:arg1 |  (tmp1 includes: arg1 blessing) not ]) detectMax: [:arg1 |  arg1 ]baseline13MethodSourceC  ^(self class sourceCodeAt: #baseline13C:) asStringdefaultAction  ^self existingProjectRegistrationlesson05  unload  ^self spec unloadrepository: arg1  self repositories repository: arg1testReferenceConfig  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := (MetacelloReferenceConfig project version: '1.0-baseline') spec.  tmp2 := tmp1 packages map.  tmp3 := self conditionResult: (tmp2 at: 'Example-AddOn') printString.  tmp4 := 'spec 	name: ''Example-AddOn'';	requires: #(''Example-Core'' ''UI Support'' );	includes: #(''Example-UI'' );	supplyingAnswers: #( #( ''list of packages'' ''Kernel* Collection*'' ) );	file: ''Example-AddOn-anon.5'';	repository: ''http://www.example.com/or'' username: ''foo'' password: ''bar'';	preLoadDoIt: #''preloadForAddOn'';	postLoadDoIt: #''postloadForAddOn''.'.  self assert: tmp3 equals: tmp4.  tmp3 := (tmp2 at: 'Example-Core') printString.  self assert: tmp3 equals: 'spec name: ''Example-Core'''.  tmp3 := (tmp2 at: 'Example-TestsUI') printString.  self assert: tmp3 equals: 'spec 	name: ''Example-TestsUI'';	requires: #(''Example-UI'' ).'.  tmp3 := (tmp2 at: 'UI Support') printString.  self assert: tmp3 equals: 'spec 	name: ''UI Support'';	projectReference: [		spec			className: ''ConfigurationOfUINew'';			versionString: ''1.0.1'';			operator: #''>='';			loads: #(''UI-Core'' ''UI-Tests'' );			repository: ''http://www.example.com/r'' username: ''foo'' password: ''bar'' ].'postCopy  super postCopy.  repositories := repositories copy.  packages := packages copycurrentPackageLoaded: arg1 comparing: arg2 notLoaded: arg3 using: arg4  | tmp1 tmp2 |  tmp2 := arg4 ancestorsFor: self.  tmp2 notNil ifTrue: [ | tmp3 tmp4 |        self getFile == nil ifTrue: [ ^arg1 value: false ].        tmp2 do: [:arg5 |  tmp1 := arg5 name.              tmp3 := GoferVersionReference name: self file.              tmp3 versionNumber = 0 ifTrue: [ ^arg1 value: false ].              tmp4 := GoferVersionReference name: tmp1.              (tmp4 compare: tmp3 using: arg2) ifTrue: [ ^arg1 value: true ] ].        ^arg1 value: false ].  ^arg3 value: truesingletonVersionName  ^self class singletonVersionNameimports: arg1  self methodSpec imports: arg1repository: arg1  arg1 addToMetacelloRepositories: selfsetUp  super setUp.  self     setUpMonticelloRepository;     setUpConfigurationOfAtomicFoo;     setUpConfigurationOfLinearFoo;     setUpConfigurationOfAtomicFan;     setUpConfigurationOfUmbrellaA;     setUpConfigurationOfUmbrellaB;     setUpConfigurationOfProjectIssue86;     yourselfdirectoryFromPath: arg1 relativeTo: arg2  ^arg2 resolveString: arg1mergeIntoMetacelloPackages: arg1  arg1 addMember: selfbuildVersion: arg1  buildVersion := arg1validateProject  | tmp1 |  tmp1 := self validateProjectCreationFrom: self configurationClass onError: [:arg1 |  self recordValidationError: 'Error creating project: ' , arg1 description , ' to reproduce evalutate the following: ''' , self configurationClass name asString , ' project''' callSite: #validateProject reasonCode: #projectCreationError.        ^self validationReport ].  ^self validateProject: tmp1configMethodOn: arg1 for: arg2 selector: arg3 last: arg4 indent: arg5  arg2 == nil ifTrue: [ ^self ].  arg1     tab: arg5;     nextPutAll: 'spec ' , arg3 , ' [';     cr.  arg2 configMethodOn: arg1 indent: arg5 + 1.  arg1 nextPutAll: ' ].'.  arg4 ifFalse: [ arg1 cr ]sampleAuthorName  ^(Smalltalk at: #ExternalCore) new externalAuthorNameconfigMethodOn: arg1 last: arg2 indent: arg3  | tmp1 |  tmp1 := false.  self packagesSpec list do: [:arg4 |  arg4 spec projectDo: [:arg5 |  arg4 spec name ~~ nil ifTrue: [ tmp1 := true ] ] packageDo: [:arg6 |  arg4 spec name ~~ nil ifTrue: [ tmp1 := true ] ] groupDo: [:arg7 |  arg4 spec name ~~ nil ifTrue: [ tmp1 := true ] ] ].  self configMethodBasicOn: arg1 last: tmp1 not indent: arg3.  self configPackagesSpecMethodOn: arg1 indent: arg3.  arg2 ifFalse: [ arg1 cr ]version01: arg1  < version: '0.1'>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1                 file: 'Example-Core-anon.8';                 repository: 'http://www.example.com/Example' ] ]defaultPackageNamesToLoad: arg1  ^self packageAndProjectNamesToLoad: arg1 loader: self loaderdefaultAction  ^MetacelloProjectSpecForLoad new     projectSpec: self projectSpec;     yourselfexecutorSpec: arg1  executorSpec := arg1postInstall  Smalltalk snapshot: self shouldSave andQuit: self shouldQuitconfigurationNamed: arg1  | tmp1 |  tmp1 := self configurationNameFrom: arg1.  (Smalltalk includesKey: tmp1 asSymbol) ifFalse: [ self ensureMetacello.        MetacelloPlatform current copyClass: (MetacelloPlatform current globalNamed: #MetacelloConfigTemplate) as: tmp1 asSymbol inCategory: tmp1 asString.        MetacelloPlatform current registerPackageNamed: tmp1 ].  project := (MetacelloPlatform current globalNamed: tmp1 asSymbol) projecttimestamp  ^Date today mmddyyyy , ' ' , ((String streamContents: [:arg1 |  Time now print24: true on: arg1 ]) copyFrom: 1 to: 5)versionString  ^versionStringmerge: arg1  self shouldBeMutable.  arg1 validate.  arg1 configurationProjectSpec ifNotNil: [:arg2 |  configurationProjectSpec := arg2 copy.        configurationProjectSpec versionOrNil ifNotNil: [:arg3 |  configurationProjectSpec versionString: arg3 versionString ].        baselineProjectSpec := nil.        self versionInfo versionString: configurationProjectSpec versionString ] ifNil: [ baselineProjectSpec := arg1 baselineProjectSpec.        configurationProjectSpec := nil.        self versionInfo versionString: baselineProjectSpec repositoryVersionString ]testShouldQuit  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self     deny: tmp1 noQuit;     assert: tmp1 shouldQuit.  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--no-quit').  self     assert: tmp1 noQuit;     deny: tmp1 shouldQuitallowEvenIfLocked  self resume: self newProjectRegistrationgetDescription  ^descriptionincludes: arg1  arg1 setIncludesInMetacelloPackage: selftearDownRepositories  super tearDownRepositories.  configurationDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: configurationDirectory ].  externalDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: externalDirectory ].  sampleDirectory exists ifTrue: [ MetacelloPlatform current recursiveDelete: sampleDirectory ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Gofer_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_MczConfiguration_Test_Repository ifAbsent: [  ].  MCRepositoryGroup default     removeIdenticalRepository: externalRepository;     removeIdenticalRepository: monticelloRepository;     removeIdenticalRepository: mczConfigurationRepository;     removeIdenticalRepository: configurationRepositorysetUpConfigurationExternalRef  | tmp1 |  tmp1 := self setUpConfigurationExternalRefdkh1.  tmp1 := self setUpConfigurationExternalRefdkh2: {tmp1}baseline40ProjectInfinite: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Loop' with: [ arg1                 className: 'MetacelloTestConfigurationOfProjectLoop';                 versionString: '4.0';                 loads: 'GeauxBeau';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        arg1           package: 'GeauxBar' with: [ arg1                 file: 'GeauxBar.branch-lr.2';                 requires: 'Loop';                 yourself ];           package: 'GoferBar' with: 'GoferBar-lr.1';           yourself ]compareLessThan: arg1  | tmp1 tmp2 tmp3 |  arg1 species = self species ifFalse: [ ^false ].  tmp1 := self normalVersion.  tmp2 := arg1 normalVersion.  tmp3 := true.  (self compareEqualTo: tmp1 other: tmp2) ifTrue: [ tmp3 := false ] ifFalse: [ (self compareLessThan: tmp1 other: tmp2 version: #normal) ifFalse: [ ^false ] ].  tmp1 := self preReleaseVersion.  tmp2 := arg1 preReleaseVersion.  (self compareEqualTo: tmp1 other: tmp2) ifTrue: [ tmp1 size > 0 ifTrue: [ tmp3 := false ] ] ifFalse: [ ^self compareLessThan: tmp1 other: tmp2 version: #preRelease ].  tmp1 := self buildVersion.  tmp2 := arg1 buildVersion.  ^(self compareEqualTo: tmp1 other: tmp2) ifTrue: [ tmp3 ] ifFalse: [ self compareLessThan: tmp1 other: tmp2 version: #build ]baseline60Foo: arg1  < version: '6.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        arg1           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('1' 'GoferFaux');           yourself ]methodSource  self subclassResponsibilitytestMergePackageD  | tmp1 |  tmp1 := self packagesSpec.  tmp1     add: 'Platform';     merge: 'Tests'.  tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  tmp1 packageNamed: 'Tests' ifAbsent: [ self assert: false ]addAttribute: arg1  self attributeOrder add: arg1do: arg1 displaying: arg2  arg1 valuelesson11Author  ^Lesson title: 'Lesson 11 (Author)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version11:."The author of a version can be defined:"	(MetacelloTutorialConfig project version: ''1.1'') author."When using the OB-Metacello tools the author field is automatically updated to reflect the currentauthor as defined in the image."ProfStef next.'decrementNormalVersionAt: arg1  | tmp1 tmp2 |  tmp2 := self normalVersion.  tmp1 := tmp2 at: arg1.  tmp1 > 0 ifTrue: [ tmp2 at: arg1 put: tmp1 - 1 ]gemsource: arg1  self repository: 'http://seaside.gemtalksystems.com/ss/' , arg1asConfigurationProject  ^MetacelloMCProject newbaseline10ProjectFum: arg1  < version: '1.0'>  arg1 for: #common do: [ arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '5.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Fie' with: [ arg1                 className: 'MetacelloTestConfigurationOfProjectFie';                 versionString: '2.5';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]package: arg1 overrides: arg2  self root package: arg1 overrides: arg2 constructor: selfrepositoryForRepositories: arg1 username: arg2 password: arg3  self repositoryForVersion: arg1 username: arg2 password: arg3operator: arg1  self root operator: arg1 constructor: selfprojectDo: arg1 packageDo: arg2 groupDo: arg3  self subclassResponsibilityconflictOf11: arg1  < version: '1.1.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>conflictOf11:'.        arg1 author: 'dkh'.        arg1 timestamp: '6/1/2012 14:46' ].  arg1 for: #custom do: [ arg1 configuration: 'ExternalX' with: [ arg1                 version: '0.9.0';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]testVersion09  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '1.0.0'.  tmp2 := self versionClass fromString: '0.7.0'.  self assert: tmp1 >= tmp2.  self assert: tmp2 <= tmp1testVersion06  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '3.'.  tmp2 := self versionClass fromString: '2'.  self assert: tmp1 > tmp2loadPackageList  | tmp1 tmp2 |  (tmp1 := self versionOrNil) == nil ifTrue: [ ^#() ].  tmp2 := OrderedCollection new.  (self loadListForVersion: tmp1) do: [:arg1 |  tmp2 addAll: ((tmp1 packagesForSpecNamed: arg1) collect: [:arg2 |  arg2 name ]) ].  ^tmp2repository: arg1 username: arg2 password: arg3 constructor: arg4  arg4 repositoryForPackage: arg1 username: arg2 password: arg3versionNumberClass  ^MetacelloVersionNumbersetDescription: arg1  description := arg1setUpInvalidConfigurations  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfInvalidConfigurations-dkh.1'.  tmp2 := #ConfigurationOfInvalidConfigurations.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'invalidConfiguration10:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #invalidConfiguration10:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'invalidConfiguration20:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #invalidConfiguration20:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'invalidConfiguration30:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #invalidConfiguration30:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4lesson08  with: arg1 during: arg2  | tmp1 |  tmp1 := self root.  self root: arg1.  arg2 ensure: [ self root: tmp1 ]setUpConfiguration63  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfIssue63-dkh.1'.  tmp2 := #ConfigurationOfIssue63.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration091Issue63:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration091Issue63:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configuration092Issue63:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configuration092Issue63:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4approximateBase  | tmp1 |  tmp1 := self copyFrom: 1 to: self size - 1.  tmp1 at: tmp1 size put: (tmp1 at: tmp1 size) + 1.  ^tmp1configMethodOn: arg1 for: arg2 selector: arg3 cascading: arg4 cascade: arg5 indent: arg6  | tmp1 |  arg2 == nil ifTrue: [ ^self ].  arg4 ifTrue: [ arg1           cr;           tab: arg6 ].  tmp1 := arg2 value isSymbol ifTrue: [ '#' , arg2 value asString printString ] ifFalse: [ arg2 value printString ].  arg1 nextPutAll: arg3 , tmp1.  arg5 ifTrue: [ arg1 nextPut: $; ]squeaksource3: arg1  self repository: 'http://ss3.gemtalksystems.com/ss/' , arg1baseline14: arg1  < version: '1.4-baseline'>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'http://example.com/examples' ] ]required  required == nil ifTrue: [ ^#() ].  ^requiredprojectClass  ^MetacelloMCProjecttestBasicStableVersion  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self projectWith: #(#'platformVersion1.x').  tmp2 := tmp1 version: #stable.  tmp3 := 'spec blessing: #''release''.spec project: ''Example Project'' with: [		spec			className: ''MetacelloExampleProjectConfig'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'' ].'.  tmp4 := tmp2 spec printString.  self assert: tmp3 equals: tmp4lesson03  ^Lesson title: 'Lesson 3' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version03:."For version 0.3, we''ve updated the package version to ''Example-Core-anon.10'' and added an additional package ''Example-Tests-anon.3'', which can be confirmed by printing the following expression:"  (MetacelloTutorialConfig project version: ''0.3'') spec."As is often the case, the two packages share the same repository, so specifying a repository witheach package is redundant."ProfStef next.'collapseZeros  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  (self size = 0 or: [ self at: 1 ]) == 0 ifTrue: [ ^self ].  tmp1 := OrderedCollection new.  tmp5 := true.  tmp6 := true.  self size to: 1 by: -1 do: [:arg1 |  | tmp7 |        tmp7 := self at: arg1.        (tmp6 and: [ tmp7 == 0 ]) ifTrue: [ tmp5 ifFalse: [ tmp6 := false.                    tmp1 addFirst: tmp7 ] ] ifFalse: [ tmp1 addFirst: tmp7.              tmp6 := tmp5 := tmp7 isString ] ].  tmp1 size = self size ifTrue: [ ^self ].  tmp2 := tmp1 size.  tmp3 := self species new: tmp2.  tmp4 := 0.  tmp1 do: [:arg2 |  tmp3 at: tmp4 + 1 put: arg2.        tmp4 := tmp4 + 1 ].  ^tmp3configuration098Issue215: arg1  < version: '0.9.8'>  arg1 for: #common do: [ arg1 description: self className , '>>configuration092Issue63:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           package: 'GoferBar' with: [ arg1                 file: 'GoferBar-lr.1';                 requires: 'External-Core';                 repository: 'dictionary://Metacello_Gofer_Test_Repository' ];           package: 'GoferFoo' with: [ arg1                 file: 'GoferFoo-lr.2';                 requires: 'External-Tests';                 repository: 'dictionary://Metacello_Gofer_Test_Repository' ];           import: 'External' provides: #('External-Core' 'External-Tests') ]overrideRepositories: arg1  overrideRepositories := arg1postloads  postloads == nil ifTrue: [ postloads := OrderedCollection new ].  ^postloadspostCopy  super postCopy.  mutable := nil.  loader ~~ nil ifTrue: [ self loader: loader ]decrementMinorVersionNumber  | tmp1 |  self size to: 1 by: -1 do: [:arg1 |  (tmp1 := self at: arg1) isString ifFalse: [ tmp1 > 0 ifTrue: [ self at: arg1 put: tmp1 - 1 ].              ^self ] ]issues  ^issuesmergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #requires put: requires.  tmp1 at: #includes put: includes.  tmp1 at: #answers put: answers.  ^tmp1baseline20: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 project: 'UTF8' with: [ arg1                 className: 'MetacelloVersionQueryMiscConfig';                 versionString: #stable;                 loads: #('Misc-UTF8') ].        arg1 project: 'UTF9' with: [ arg1                 className: 'MetacelloVersionQueryOtherConfig';                 versionString: '1.0-baseline';                 loads: #('Misc-UTF8') ].        arg1           group: 'Core' with: #('UTF8' 'UTF9');           group: 'Tests' with: #('UTF8');           group: 'Recursive' with: #('Core' 'Recursive') ]setUpConfigurationOfProjectFum  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectFum-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline10ProjectFum:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baseline10ProjectFum:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())classicCreateProjectReferenceSpec: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self configurationNameFrom: arg1.  tmp2 := (MetacelloPlatform current globalNamed: tmp1 asSymbol ifAbsent: [ self error: 'The project with configuration ' , tmp1 printString , ' for the project ' , arg1 printString , ' is not currently loaded into the image.' ]) project.  tmp3 := (tmp2 hasVersion: #stable) ifTrue: [ #stable ] ifFalse: [ #bleedingEdge ].  ^project projectReferenceSpec     name: arg1;     projectReference: (project projectSpec           name: arg1;           className: tmp1;           versionString: tmp3;           yourself);     yourselftutorial  ^#(#lesson07 #lesson10 #lesson11 #lesson12 #lesson13 #lesson14)searchCacheRepositoryForPackage: arg1  arg1 valueensureForDevelopment  ^truecloseZipArchive: arg1  arg1 closegtInspectorPackagesIn: arg1  < gtInspectorPresentationOrder: 40>  self version gtInspectorPackagesIn: arg1testRepositoryMergeSpec  | tmp1 tmp2 tmp3 |  tmp1 := self repositorySpec     description: '/opt/gemstone/repository';     username: 'dkh';     password: 'password';     type: 'directory';     yourself.  tmp2 := self repositorySpec     description: 'http://example.com/repository';     password: 'secret';     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: tmp3 description equals: 'http://example.com/repository'.  self assert: tmp3 username equals: 'dkh'.  self assert: tmp3 password equals: 'secret'.  self assert: tmp3 type equals: 'http'projectDo: arg1 packageDo: arg2 groupDo: arg3  arg1 value: selfget  actionArg := #get -> #()sourceName: arg1  sourceName := arg1testApproxVersion01  self assert: '1.1.1' asMetacelloVersionNumber ~> '1.1' asMetacelloVersionNumberfile  file ifNil: [ ^self className ].  ^fileasBaselineProject  ^MetacelloMCBaselineProject newresolveToPackagesIn: arg1 visited: arg2  ^{self}testBaseline10Groups  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self project.  tmp2 := tmp1 version: '1.0-baseline'.  tmp3 := #('Core' 'Tests' 'Recursive').  tmp4 := tmp2 groups.  self assert: tmp4 size equals: tmp3 size.  tmp4 do: [:arg1 |  self assert: (tmp3 includes: arg1 name) ]packageInfoFor: arg1  ^arg1 packageSetcompareEqual: arg1  ^(super compareEqual: arg1) and: [ self file = arg1 file ]version30Issue119: arg1  < version: '3.0' imports: #('3.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: '2.0'.        arg1 package: 'GoferBar' with: 'GoferBar-jf.1' ]versionForVersion: arg1  self versionStringForVersion: arg1latestVersionMatching: arg1 includedBlessings: arg2 excludedBlessings: arg3  ^nilexecute: arg1  | tmp1 |  tmp1 := MetacelloPlatform current newVersionForWorkingCopy: arg1.  self gofer repositories do: [:arg2 |  arg2 storeVersion: tmp1 ]project: arg1 with: arg2 constructor: arg3  arg3 projectForVersion: arg1 with: arg2isAllLoadedToSpec  self isPartiallyCurrent isAllLoadedToSpec: [:arg1 |  ^true ].  ^falsedecrementPatchVersion  self size < 2 ifTrue: [ self at: 2 put: 0 ].  self size < 3 ifTrue: [ self at: 3 put: 0 ].  self decrementVersionAt: 3getRepositories  ^nilensureProjectLoaded  (self projectClass == nil or: [ self versionOrNil == nil or: [ (loader notNil or: [ self isMutable ]) and: [ self loader ignoreImage ] ] ]) ifTrue: [ | tmp1 |        (tmp1 := self projectClass) ~~ nil ifTrue: [ MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo #versionConstructor #loadableSpecNames) , {tmp1} ].        self projectPackage ifNil: [ ^true ].        self ensureLoadUsing: self loader ].  ^self projectClass ~~ nilsetUpConfigurationIssue32  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfIssue32-dkh.1'.  tmp2 := #ConfigurationOfIssue32.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'version10Issue47:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue47:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'version09Issue32:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version09Issue32:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4versionString  ^versionStringdevelopment  ^nilrepository: arg1 constructor: arg2  arg2 repositoryForVersion: arg1hasVersion  ^self hasOption: 'version'projectClass  ^MetacelloMCProjectsetAnswers: arg1  answers := arg1silently  ^self options at: #silently ifAbsent: [ false ]updateVersionSpec: arg1 fullVersionSpec: arg2 updateProjects: arg3 updatePackages: arg4 visited: arg5 updated: arg6  arg1 specListProjectDo: [:arg7 |  (arg3 and: [ (arg5 includes: arg7 name) not ]) ifTrue: [ | tmp1 |              tmp1 := (arg2 packageNamed: arg7 name) projectReference.              (tmp1 versionString ~~ nil and: [ tmp1 versionString ~~ #stable and: [ tmp1 projectClass ~~ nil ] ]) ifTrue: [ | tmp2 |                    tmp2 := tmp1 projectClassProject currentVersion.                    tmp2 ~~ nil ifTrue: [ tmp2 versionString ~= tmp1 versionString ifTrue: [ arg7 projectReference versionString: tmp2 versionString.                                arg6 add: arg7 name ] ] ifFalse: [ arg7 projectReference versionString: ''.                          arg6 add: arg7 name ] ] ] ] packageDo: [:arg7 |  (arg4 and: [ (arg5 includes: arg7 name) not ]) ifTrue: [ arg7 getFile ~~ nil ifTrue: [ | tmp3 |                    arg7 file = '' ifTrue: [ arg7 file: arg7 name ].                    (tmp3 := arg7 workingCopyNameFor: arg7 loader) ~~ nil ifTrue: [ tmp3 ~= arg7 file ifTrue: [ arg7 file: tmp3.                                arg6 add: arg7 name ].                          arg5 add: arg7 name ] ] ] ] groupDo: [:arg8 |   ]setPackage: arg1 withString: arg2  | tmp1 |  tmp1 := self project packageSpec     name: arg1;     file: arg2;     yourself.  self root packages merge: tmp1defaultLoaderClass  ^MetacelloLoadingMCSpecLoaderincrementMinorVersionNumber  | tmp1 |  self size to: 1 by: -1 do: [:arg1 |  (tmp1 := self at: arg1) isString ifFalse: [ self at: arg1 put: tmp1 + 1.              ^self ] ]configHasVersionString  ^self versionString ~~ nilbleedingEdgeVersion: arg1  < symbolicVersion: #bleedingEdge>  arg1 for: #common version: '4.0'downloadZipArchive: arg1 to: arg2  | tmp1 tmp2 tmp3 |  tmp3 := self downloadBasicFile: arg1 to: arg2 username: nil pass: nil.  tmp1 := ZipArchive new.  tmp2 := self fileHandleOn: arg2.  tmp2 containingDirectory readOnlyFileNamed: tmp2 localName do: [:arg3 |  [ tmp1 readFrom: arg3 ] on: Error do: [:arg4 |  self error: 'Error during download (' , arg4 description , ') please check the file ' , tmp3 printString , ' for error message.' ] ].  self deleteFileNamed: tmp3.  ^tmp1isConfigurationOfProjectSpec  ^falseversion30Issue125: arg1  < version: '3.0' imports: #('3.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloConfigurationResource>>version30Issue125:'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-jf.1';           yourself ].  arg1 for: #attribute1 do: [ arg1           package: 'GoferFaux' with: 'GoferFaux-tg.32';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself ].  arg1 for: #attribute2 do: [ arg1           package: 'GoferFaux' with: 'GoferFaux-tg.33';           package: 'GoferBeau' with: 'GoferBeau-dkh.56';           yourself ]methodSection: arg1 inEvaluationOrder: arg2 do: arg3  | tmp1 |  tmp1 := IdentitySet new.  arg2 do: [:arg4 |  arg1 methodSections do: [:arg5 |  (arg5 attributes includes: arg4) ifTrue: [ tmp1 add: arg5 ] ] ].  tmp1 do: arg3.  arg2 size == 1 ifTrue: [ ^self ].  tmp1 do: [:arg5 |  self methodSection: arg5 inEvaluationOrder: (arg2 copyFrom: 2 to: arg2 size) do: arg3 ]baseline60ProjectIssue86: arg1  < version: '6.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'A' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.0';                 loads: #('1');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'B' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.0';                 loads: #('2');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]bleedingEdge206B: arg1  < symbolicVersion: #bleedingEdge>  arg1 for: #common version: '2.1'processPID  ^''setBaseline: arg1 withBlock: arg2  | tmp1 |  tmp1 := self setBaseline: arg1.  self with: tmp1 during: arg2getOperator  ^operatorsetBlessingWithString: arg1  self root blessing: arg1setUpConfigurationOfProjectIssue171dkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue171-dkh.2'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion21Issue171:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion21Issue171:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version21Issue171:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version21Issue171:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4required: arg1  required := arg1label  ^''possiblyNewerVersionsOfAnyOf: arg1  ^self localRepository possiblyNewerVersionsOfAnyOf: arg1unloadPackage: arg1  | tmp1 |  tmp1 := Gofer new.  (self hasPackage: arg1) ifTrue: [ tmp1 package: arg1 ].  tmp1 references notEmpty ifTrue: [ tmp1 unload ]version: arg1 constructor: arg2  arg2 versionForProject: arg1selector  ^selectorsingleRoot  singleRoot ifNil: [ singleRoot := false ].  ^singleRootdeleteFileNamed: arg1  arg1 asFileReference deletesignal: arg1  self issue: arg1.  ^self signalisCritical  ^self isError or: [ self isCriticalWarning ]lesson12DoIts  setUpConfigurationOfExternalIV  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternalIV-dkh.1'.  tmp2 := #ConfigurationOfExternalIV.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfIV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfIV:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4setLoads: arg1  self shouldBeMutable.  loads := arg1repositoriesSpec  ^self project repositoriesSpeccustomProjectAttributes  ^#()printOn: arg1  self configMethodOn: arg1 indent: 0packageSpecClass  ^MetacelloPackageSpecfileHandleOn: arg1  ^self fileDirectoryClass on: arg1mergeSpec: arg1  | tmp1 tmp2 |  self validateMergeForSpec: arg1.  tmp1 := self copy.  tmp2 := self nonOverridable.  arg1 mergeMap keysAndValuesDo: [:arg2 :arg3 |  (tmp2 includes: arg2) ifFalse: [ arg3 ~~ nil ifTrue: [ tmp1 instVarNamed: arg2 asString put: arg3 ] ] ].  ^tmp1options  options ifNil: [ options := Dictionary new ].  ^optionsmergeScriptLoads: arg1  self shouldBeMutable.  arg1 loads ifNotNil: [:arg2 |  self loads ifNil: [ loads := arg2 ] ifNotNil: [ loads := (loads , arg2) asSet asArray ] ].  self loader: arg1 loaderregistrations  ^self baselineRegistry values , self configurationRegistry valuesextractTypeFromDescription  ^MetacelloPlatform current extractTypeFromDescription: self descriptionerrorMap: arg1  errorMap ifNil: [ errorMap := Dictionary new ].  errorMap := arg1block: arg1  block := arg1suspendSystemUpdateEventsDuring: arg1  (Smalltalk at: #SystemChangeNotifier) uniqueInstance doSilently: arg1validateDoIts: arg1 versionString: arg2 errorMessage: arg3  | tmp1 |  tmp1 := {#preLoadDoIt .   'preLoadDoIt selector for ' .   #postLoadDoIt .   'postLoadDoIt selector for '}.  1 to: tmp1 size by: 2 do: [:arg4 |  | tmp2 |        tmp2 := (arg1 perform: (tmp1 at: arg4)) value.        tmp2 ~~ nil ifTrue: [ tmp2 isSymbol ifFalse: [ self recordValidationError: (tmp1 at: arg4 + 1) , arg3 , ' is not a symbol' versionString: arg2 callSite: #validateDoIts:versionString:errorMessage: reasonCode: #invalidDoItSelector ] ] ]mergeImportLoads: arg1  self projectReference mergeImportLoads: arg1workingCopyNameFor: arg1  | tmp1 |  (tmp1 := arg1 currentVersionInfoFor: self) == nil ifTrue: [ ^nil ].  ^tmp1 nameconfigurationRepository  ^configurationRepositorylabel  ^super label , ' >> ' , self spec preLoadDoIt value asStringfetchPackage: arg1  self fetchUsing: (self loader           loaderPolicy: arg1;           yourself)setUpConfigurationNextedIssue84dkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfNestedIssue84-dkh.2'.  tmp2 := #ConfigurationOfNestedIssue84.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'version10NestedIssue84:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10NestedIssue84:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionNumberClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionNumberClass) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4preLoadDoItForProject: arg1  self preLoadDoItForSpec: arg1updateRepositories  projectClass  ^MetacelloMCProjectversion  self subclassResponsibilityprintString  ^String streamContents: [:arg1 |  self printOn: arg1 ]repositoryForPackage: arg1 username: arg2 password: arg3  self repositoryForSpec: arg1 username: arg2 password: arg3applyAdd: arg1 copy: arg2 merge: arg3 remove: arg4  arg3 value: selfignoreImage  self addStatement: #ignoreImage: args: {true}versionString  ^versionStringbaseline30Foo: arg1  < version: '3.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: [ arg1                 preLoadDoIt: #preloadDoIt;                 file: 'GoferFoo-lr.1' ];           package: 'GoferBar' with: 'GoferBar.branch-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           yourself ]repositories  repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].  ^repositoriesdirectivesDo: arg1  arg1 value: selfprojectReferenceSpecClass  ^MetacelloProjectReferenceSpecmodifications  modifications ifNil: [ modifications := Dictionary new ].  ^modificationstestSemanticVersioning  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2+build.0').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0+build.0').  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0-1').  self validateSemanticVersionStrings: #('1.0.0-1' '1.0.0+alpha').  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0+1').  self validateSemanticVersionStrings: #('1.0.0+alpha' '1.0.0+1').  self validateSemanticVersionStrings: #('1.0.0--' '1.0.0-a').  self validateSemanticVersionStrings: #('1.0.0+-' '1.0.0+a').  self validateSemanticVersionStrings: #('1.0.0-rc.1' '1.0.0' '1.0.0+build.1').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2+build.3').  self validateSemanticVersionStrings: #('1.0.0-rc.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0-rc.1+build.2' '1.0.0-rc.2+build.2').  self validateSemanticVersionStrings: #('1.0.0-rc.1+build.1' '1.0.0' '1.0.0+build.0').  self validateSemanticVersionStrings: #('1.0.0+10000' '1.0.0+a').  self validateSemanticVersionStrings: #('1.0.0-10000' '1.0.0-a')aboutToCopy  calculate: arg1 project: arg2  | tmp1 tmp2 tmp3 tmp4 |  self setProject: arg2.  self configuration: arg1.  tmp1 := Dictionary new.  tmp2 := Dictionary new.  tmp3 := self specResolverBlock.  self collectAllVersionsFromVersionPragmasInto: tmp1 using: tmp3.  tmp4 := self extractVersionImportPragmas.  self verifyVersionImportPragmas: tmp4 definedIn: tmp1.  self collectAllVersionsFromVersionImportPragmasInto: tmp1 using: tmp3 satisfiedPragmas: tmp4.  self collectAllSymbolicVersionsFromVersionPragmasInto: tmp2 using: self symbolicVersionResolverBlock.  self project map: tmp1.  self project errorMap: self errorMap.  self project symbolicVersionMap: tmp2.  self project configuration: arg1.  self collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractDefaultSymbolicVersionPragmas into: tmp2 using: self defaultSymbolicVersionResolverBlock.  self collectDefaultSymbolicVersionsFromVersionPragmasFrom: self extractCommonDefaultSymbolicVersionPragmas into: tmp2 using: self commonDefaultSymbolicVersionResolverBlock.  tmp2 copy keysAndValuesDo: [:arg3 :arg4 |  | tmp5 tmp6 |        tmp5 := arg4.        tmp6 := Set new.        [ tmp6 add: tmp5.        tmp5 isSymbol and: [ tmp5 ~~ #notDefined ] ] whileTrue: [ tmp5 := tmp2 at: tmp5 ifAbsent: [ self error: 'Cannot resolve symbolic version ' , arg4 printString ].              (tmp6 includes: tmp5) ifTrue: [ self error: 'Loop detected resolving symbolic version ' , arg4 printString ] ].        tmp2 at: arg3 put: tmp5 ]resolveToLoadableSpecs  self versionSpec resolveToLoadableSpecs: required forLoad: true map: packagesrepositoryForRepositories: arg1  self repositoryForSpec: arg1spec: arg1  spec := arg1postLoadDoItForPackage: arg1  self postLoadDoItForSpec: arg1prepostLoadsDo: arg1  self preloads do: [:arg2 |  arg2 prepostLoadDo: arg1 ].  self loadDirectives do: [:arg2 |  arg2 prepostLoadDo: arg1 ].  self postloads do: [:arg2 |  arg2 prepostLoadDo: arg1 ]handleResolutionFor: arg1  ^arg1 handleLookupProjectSpec: selfdefaultRepositoryDescription  ^'http://smalltalkhub.com/mc/Pharo/MetaRepoForPharo30/main'setUpConfigurationOfProjectIssue171  | tmp1 |  tmp1 := self setUpConfigurationOfProjectIssue171dkh1.  tmp1 := self setUpConfigurationOfProjectIssue171dkh2: {tmp1}repositorySpecs  repositories ifNil: [ ^#() ].  ^self repositories map valuesclassName: arg1  super className: arg1.  self projectPackage: nilproject  ^projectfileHandleOn: arg1  ^arg1 asFileReferenceexludededValidations  exludededValidations == nil ifTrue: [ exludededValidations := self extractExcludedValidations ].  ^exludededValidationsversionString: arg1  versionString := arg1label  ^super label , ' >> ' , self spec postLoadDoIt value asStringversion11: arg1  < version: '1.1' imports: #('1.1-baseline')>  arg1 for: #common do: [ arg1 blessing: #beta.        arg1           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1' ]authorForVersion: arg1  arg1 setAuthorInMetacelloConfig: selfcanUpgradeTo: arg1  (self hasLoadConflicts: arg1) ifFalse: [ ^true ].  configurationProjectSpec ifNotNil: [ arg1 configurationProjectSpec ifNotNil: [ configurationProjectSpec copy ensureProjectLoaded.              ^configurationProjectSpec canUpgradeTo: arg1 configurationProjectSpec ] ].  baselineProjectSpec ifNotNil: [ arg1 baselineProjectSpec ifNotNil: [ baselineProjectSpec copy ensureProjectLoaded.              ^baselineProjectSpec canUpgradeTo: arg1 baselineProjectSpec ] ].  ^falseextractVersionImportPragmas  | tmp1 |  tmp1 := Dictionary new.  self extractPragmas: #version:imports: into: tmp1.  ^tmp1configurationClass: arg1  configurationClass := arg1hasVersion: arg1  ^arg1 = 'baseline'setUp  super setUp.  self     setUpVersionReferences;     setUpMonticelloRepository;     setUpDependency;     setUpNewerDependencyblessingForVersion: arg1  arg1 setBlessingInMetacelloConfig: selfsetUpConfigurationOfProjectIssue136dkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue136-dkh.2'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion10Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue136:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version10Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue136:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version11Issue136:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version11Issue136:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4onUpgrade: arg1  self options at: #onUpgrade put: arg1releaseVersion11PharoOnly  ^Lesson title: 'Release version 1.1 (#pharo only)' lesson: '"	1. Create configuration	2. Prepare to modify the version method for version 1.1:	3. Change the blessing to #release for the #pharo attribute	4. Compile and validate the #version11: method .	5. Remove version 1.0 from the definition of the #development symbolic version	6. Compile and validate the #development: method	7. Prepare to define the symbolic version method #stable:	8. Define version 1.1 as the #stable symbolic version for #common	9. Compile and validate the #stable: method"	"1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		modifyVersionMethodForVersion: ''1.1''			versionSpecsDo: [ :attribute :versionSpec | 					attribute == #pharo"3."						ifTrue: [ versionSpec blessing: #release ].					true ];"4."		commitMethod;"5."		modifySymbolicVersionMethodFor: #development			symbolicVersionSpecsDo: [ :symbolicVersionSpec | symbolicVersionSpec attribute ~~ #pharo ];"6."		commitMethod;"7."		modifySymbolicVersionMethodFor: #stable symbolicVersionSpecsDo: [ :symbolicVersionSpec | true ];"8."		addSymbolicSection: #pharo version: ''1.1'';"9."		commitMethod."After evaluating the above expression, take a look at the generated methods:	#version11:	#development:	#stable: "	ProfStef next.'evalDoits  evalDoits == nil ifTrue: [ evalDoits := false ].  ^evalDoitsbypassGoferLoadUpdateCategories  bypassGoferLoadUpdateCategories == nil ifTrue: [ bypassGoferLoadUpdateCategories := false ].  ^bypassGoferLoadUpdateCategoriespushExplicitLoadDirectivesDuring: arg1 for: arg2  | tmp1 |  tmp1 := MetacelloExplicitLoadDirective loader: arg2.  self pushLoadDirective: tmp1 during: arg1.  ^tmp1versionSpec  ^versionSpecsetUpConfigurationOfProjectInfinite  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectInfinite-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40ProjectInfinite:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectInfinite)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())attributePath  | tmp1 |  tmp1 := MetacelloMethodSectionPath with: self attributes.  ^self parent == nil ifTrue: [ tmp1 ] ifFalse: [ self parent attributePath , tmp1 ]removeProjectForVersion: arg1  | tmp1 |  tmp1 := self project projectReferenceSpec     name: arg1;     yourself.  self root packages remove: tmp1shouldBeMutable  self isMutable ifTrue: [ ^self ].  self error: 'Not allowed to modify an immutable object'primeRegistryFromImage: arg1 baselineClasses: arg2 prioritizeConfiguration: arg3  arg2 do: [:arg4 |  (self baselineRegistry includesKey: arg4 name asString) ifFalse: [ (self primeRegistryCurrentVersionFor: arg4) ifNotNil: [:arg5 |  | tmp1 |                    tmp1 := (arg5 project projectSpec                       name: (MetacelloScriptEngine baseNameOf: arg4 name asString);                       repositories: arg5 project projectPackage repositories copy;                       yourself) asBaselineProjectSpec.                    self primeRegisterLoadedProjectSpec: tmp1 ] ] ].  arg1 do: [:arg4 |  (self configurationRegistry includesKey: arg4 name asString) ifFalse: [ (self primeRegistryCurrentVersionFor: arg4) ifNotNil: [:arg5 |  | tmp1 tmp2 tmp3 tmp4 |                    tmp4 := arg5 project.                    tmp3 := tmp4 projectPackage.                    tmp2 := nil.                    tmp3 ~~ nil ifTrue: [ tmp2 := tmp3 repositories copy ].                    tmp1 := (arg5 project projectSpec                       name: (MetacelloScriptEngine baseNameOf: arg4 name asString);                       className: arg4 name asString;                       versionString: arg5 versionString;                       repositories: tmp2;                       yourself) asConfigurationProjectSpec.                    (arg3 or: [ (self primeRegistryProjectSpecRegistered: tmp1) not ]) ifTrue: [ self primeRegisterLoadedProjectSpec: tmp1 ] ] ] ]authorName: arg1  Author fullName: arg1asBaselineProjectSpec  ^self copyForScriptingInto: (MetacelloMCBaselineOfProjectSpec for: self project asBaselineProject)lesson03  mutable  mutable := truepackageNameMap  packageNameMap == nil ifTrue: [ packageNameMap := Dictionary new ].  ^packageNameMapversionNumberClass  ^MetacelloVersionNumberdefaultVersion1  ^self versionClass fromString: '1.0.0'isSomethingLoaded: arg1  (self evaluateStatus: #(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints #somethingLoaded)) ifTrue: [ aPackageIsLoaded ifTrue: [ arg1 value: #somethingLoaded ] ]version: arg1 ifAbsent: arg2  ^[ self version: arg1 ] on: MetacelloVersionDoesNotExistError do: [:arg3 |  arg2 value ]visited: arg1  visited := arg1handleDowngrade: arg1  ^(self options at: #onDowngrade ifAbsent: [ ^arg1 pass ]) cull: arg1 cull: arg1 existingProjectRegistration cull: arg1 newProjectRegistrationcreateConfiguration: arg1  | tmp1 |  tmp1 := (arg1 beginsWith: 'ConfigurationOf') ifTrue: [ arg1 ] ifFalse: [ 'ConfigurationOf' , arg1 ].  (Smalltalk includesKey: tmp1 asSymbol) ifFalse: [ self ensureMetacello.        MetacelloPlatform current copyClass: (MetacelloPlatform current globalNamed: #MetacelloConfigTemplate) as: tmp1 asSymbol inCategory: tmp1 asString.        MetacelloPlatform current registerPackageNamed: tmp1 ].  ^(MetacelloPlatform current globalNamed: tmp1 asSymbol) projectallPackagesForSpecNamed: arg1  ^self allPackagesForSpecNamed: arg1 ifAbsent: [ ^#() ]applyArgsToProjectSpec: arg1  classNameArg ifNotNil: [ arg1 className: classNameArg ].  versionArg ifNotNil: [ arg1 versionString: versionArg ].  repositoryArg ifNotNil: [ arg1 repository: repositoryArg ].  ^arg1testSelfHostedLocation  | tmp1 |  tmp1 := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo:master/src'.  self     assert: tmp1 hostname equals: 'git.pharo.org';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assert: tmp1 repoPath equals: 'src';     assert: tmp1 sshPort isNil.  tmp1 := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo:master'.  self     assert: tmp1 hostname equals: 'git.pharo.org';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assertEmpty: tmp1 repoPath;     assert: tmp1 sshPort isNil.  tmp1 := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo'.  self     assert: tmp1 hostname equals: 'git.pharo.org';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assertEmpty: tmp1 repoPath;     assert: tmp1 sshPort isNilsetUp  super setUp.  MetacelloPlatform current clearPackageCache.  registry := MetacelloProjectRegistration registry.  self setUpRepositories.  self setUpRepositoryContents.  MetacelloProjectRegistration resetRegistry.  initialWorkingCopyList := MCWorkingCopy allManagers collect: [:arg1 |  arg1 packageName ].  self disableUndefinedSymbolTracking ifTrue: [ undefinedSymbols := MetacelloPlatform current disableUndefinedSybolUpdates ]pushProject: arg1  | tmp1 tmp2 tmp3 |  tmp1 := groups.  tmp2 := packages.  tmp3 := projects.  groups := Set new.  packages := Set new.  ^arg1 ensure: [ groups := tmp1.        packages := tmp2.        projects := tmp3 ]testAddPackageA  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           includes: 'AndIncludedPackage';           answers: #(#('postload' 'postload answer'));           file: 'Package-dkh.2';           yourself).  tmp2 := tmp1 packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: tmp2 name equals: 'Package'.  self assert: tmp2 requires equals: #('AndAnotherPackage').  self assert: tmp2 includes equals: #('AndIncludedPackage').  self assert: tmp2 answers equals: #(#('postload' 'postload answer')).  self assert: tmp2 file equals: 'Package-dkh.2'.  self assert: tmp2 preLoadDoIt value identicalTo: nil.  self assert: tmp2 postLoadDoIt value identicalTo: nilconfigHasVersionString  ^falsename: arg1  ((arg1 at: 1) isSeparator or: [ (arg1 at: arg1 size) isSeparator ]) ifTrue: [ self error: 'Names are not allowed to have leading or trailing blanks: ' , arg1 printString ].  self shouldBeMutable.  name := arg1testVersion05  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '3.0.0'.  tmp2 := self versionClass fromString: '2.0.0'.  self assert: tmp1 > tmp2extensionMethods  ^#()versionStringForVersion: arg1  self versionStringForProject: arg1configMethodOn: arg1 indent: arg2  arg1 nextPutAll: self class name asString , ' member: ('.  self spec configMethodOn: arg1 indent: arg2.  arg1 nextPutAll: ')'explicitLoadUsing: arg1 gofer: arg2  arg1 loadLinearLoadDirective: self gofer: arg2blueplane: arg1  self repository: 'http://squeaksource.blueplane.jp/' , arg1configMethodCascadeOn: arg1 last: arg2 indent: arg3  self spec configMethodCascadeOn: arg1 member: self last: arg2 indent: arg3baseline15ProjectFie: arg1  < version: '1.5'>  arg1 for: #common do: [ arg1 configuration: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.5';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]baselineIssue399: arg1  < baseline>  arg1 for: #common do: [ arg1 description: self className , '>>baselineIssue399:'.        arg1 package: 'Issue399-Core' ]setUpConfigurationOfLinearFoo  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfLinearFoo-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self linearProjectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline20Foo:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'version20Foo:' category: 'cat' timeStamp: '' source: self version20MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'version50Foo:' category: 'cat' timeStamp: '' source: self version50MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'version51Foo:' category: 'cat' timeStamp: '' source: self version51MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline60Foo:' category: 'cat' timeStamp: '' source: self baseline60MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline61Foo:' category: 'cat' timeStamp: '' source: self baseline61MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline62Foo:' category: 'cat' timeStamp: '' source: self baseline62MethodSourceFoo)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())applyToList: arg1  arg1 merge: selfisSomethingLoaded  ^self spec isSomethingLoadedversion50Issue119: arg1  < version: '5.0' imports: #('4.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: '1.0'.        arg1 package: 'GoferBar' with: 'GoferBar-jf.1' ]directoryFromPath: arg1 relativeTo: arg2  ^arg2 directoryNamed: arg1setUpConfigurationOfProjectIssue119dkh3: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.3'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion30Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion30Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version30Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version30Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4addToMetacelloRepositories: arg1  arg1 addMember: (arg1 addMember           name: self name;           spec: self;           yourself)timestamp: arg1 constructor: arg2  arg2 timestampForVersion: arg1on: arg1  | tmp1 |  tmp1 := arg1 class.  project := MetacelloPlatform current stackCacheFor: #versionConstructor at: tmp1 doing: [:arg2 |  self calculate: arg1 project: nil.        arg2 at: tmp1 put: self project ].  self setProject: projectbaselineOfProjectSpecClass  ^self subclassResponsibilitysetUpConfigurationOfSymbolic  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfSymbolic-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'stableVersionD:' category: 'cat' timeStamp: '' source: self stableVersionDMethodSourceSymbolic) .   (MCMethodDefinition className: tmp2 asString selector: 'version40Symbolic:' category: 'cat' timeStamp: '' source: self version40SymbolicMethodSourceSymbolic) .   (MCMethodDefinition className: tmp2 asString selector: 'version41Symbolic:' category: 'cat' timeStamp: '' source: self version41SymbolicMethodSourceSymbolic) .   (MCMethodDefinition className: tmp2 asString selector: 'version42Symbolic:' category: 'cat' timeStamp: '' source: self version42SymbolicMethodSourceSymbolic) .   (MCMethodDefinition className: tmp2 asString selector: 'version43Symbolic:' category: 'cat' timeStamp: '' source: self version43SymbolicMethodSourceSymbolic)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())packageFilename  ^packageFilenamepackages: arg1  packageList := arg1fuelMetalevel: arg1  arg1 project: 'FuelMetalevel' with: [ arg1           repository: 'http://ss3.gemstone.com/ss/Fuel';           className: 'ConfigurationOfFuel';           loads: #FuelMetalevel ]testSemanticVersioningSpecItem12  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0-rc.1+build.1' '1.0.0' '1.0.0+0.3.7' '1.3.7+build' '1.3.7+build.2.b8f12d7' '1.3.7+build.11.e0f985a')version50Umbrella: arg1  < version: '5.0'>  arg1 for: #common do: [ arg1           project: 'Umbrella' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '5.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]versionOrNil  ^[ self version ] on: MetacelloVersionDoesNotExistError do: [:arg1 |  ^nil ]downloadJSONTags  | tmp1 tmp2 |  tmp1 := self projectTagsUrlFor: self projectPath.  tmp2 := MetacelloPlatform current downloadJSON: tmp1 eTagsCache: self class eTagsCache eTagsKey: self projectPath username: self class siteUsername pass: self class sitePassword.  ^self normalizeTagsData: tmp2createVersionSpec: arg1  | tmp1 |  tmp1 := project versionSpec.  tmp1 versionString: arg1.  ^tmp1projectSpecs  ^self configurationProjectSpecs , self baselineProjectSpecssetUpBaselineGithubReferenceIV  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefIV-dkh.1'.  tmp2 := #BaselineOfGithubRefIV.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationGithubReferenceX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4loadDirective  loadDirective == nil ifTrue: [ loadDirective := MetacelloLinearLoadDirective new ].  ^loadDirectiveregisterProjectRegistration: arg1  arg1 configurationProjectSpec copy ifNotNil: [:arg2 |  self configurationRegistry at: arg2 className ifPresent: [:arg3 |  (arg3 configurationProjectSpec registrationsCompareEqual: arg2) ifFalse: [ MetacelloNotification signal: 'REGISTRATION OF INCOMPATABLE PROJECTS: ' , arg3 printString , ' REPLACED BY ' , arg1 printString ] ].        arg2 versionOrNil ifNotNil: [:arg4 |  arg2 versionString: arg4 versionString ].        arg1 configurationProjectSpec: arg2.        (arg1 respondsTo: #versionInfo) ifTrue: [ arg1 versionInfo setVersionString: arg2 versionString ].        arg2 immutable.        self configurationRegistry at: arg2 className put: arg1 ].  arg1 baselineProjectSpec ifNotNil: [:arg2 |  self baselineRegistry at: arg2 className ifPresent: [:arg3 |  (arg3 baselineProjectSpec registrationsCompareEqual: arg2) ifFalse: [ MetacelloNotification signal: 'REGISTRATION OF INCOMPATABLE PROJECTS: ' , arg3 printString , ' REPLACED BY ' , arg1 printString ] ].        (arg1 respondsTo: #versionInfo) ifTrue: [ arg1 versionInfo setVersionString: arg2 repositoryVersionString ].        arg2 immutable.        self baselineRegistry at: arg2 className put: arg1 ].  arg1 immutabledescription  ^'The version ' , self versionString printString , ' is not defined in ' , self project label , ' for the current platform, because an exception occurred while creating the version:. ' , self exception description , '. Evaluate the following to see the error: ''[' , self project configuration class name asString , ' project ] 	on: MetacelloErrorInProjectConstructionNotification 	do: [:ex | ex resume: true ].''' , 'Possible versions include: ' , self possibleVersions printStringdetermineCurrentVersionForLoad  | tmp1 tmp2 tmp3 tmp4 |  self projectClass == nil ifTrue: [ ^nil ].  (tmp2 := self versionOrNil) == nil ifTrue: [ ^nil ].  tmp2 blessing == #baseline ifTrue: [ ^tmp2 ].  self loader ignoreImage ifTrue: [ ^tmp2 ].  tmp1 := self projectClass new project.  tmp1 loader: self loader.  (tmp3 := tmp1 currentVersion) == nil ifTrue: [ ^nil ].  (tmp4 := tmp3 versionStatus) == #somethingLoaded ifTrue: [ ^nil ].  (#(#allLoadedToSpec #loadedToSpec #loadedMatchConstraints) includes: (tmp4 := tmp3 versionStatus)) ifTrue: [ (tmp3 perform: self operator with: tmp2) ifTrue: [ ^tmp3 ].        ^nil ].  tmp2 = tmp3 ifTrue: [ ^tmp3 ].  (MetacelloProjectSpecLoadConflict projectSpec: self) signal: 'Project load conflict for' , tmp1 label printString , ' between current version ' , tmp3 printString , '(' , tmp4 asString , ') and specified version ' , tmp2 printString , '. Press resume to continue with load anyway'.  ^nilfiletreeDirectory: arg1  self repository: 'filetree://' , arg1spec: arg1  spec := arg1operator  operator == nil ifTrue: [ ^#= ].  ^operatortestBaselineOrConfigurationName  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: tmp1 baselineOrConfigurationName equals: 'BaselineOfMineSweeper'.  tmp1 := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self assert: tmp1 baselineOrConfigurationName equals: 'ConfigurationOfFoo'setFor: arg1 do: arg2  | tmp1 |  tmp1 := MetacelloVersionMethodSection new     attributes: arg1 asMetacelloAttributeList;     block: arg2;     yourself.  currentSection ~~ nil ifTrue: [ currentSection addMethodSection: tmp1 ] ifFalse: [ self methodSections add: tmp1 ]register  | tmp1 |  self setDefaultsAndValidate: self projectSpec copy.  tmp1 := self projectSpec.  MetacelloProjectRegistration registrationForProjectSpec: tmp1 ifAbsent: [:arg1 |  arg1 registerProject ] ifPresent: [:arg2 :arg1 |  arg2 copyOnWrite: [:arg3 |  arg3 merge: arg1 ] ].  self root: tmp1copyForScriptingInto: arg1  ^arg1     setName: name;     className: className;     versionString: versionString;     operator: operator;     setLoads: loads;     preLoadDoIt: preLoadDoIt;     postLoadDoIt: postLoadDoIt;     repositories: repositories copy;     file: filecompareEqual: arg1  ^(super compareEqual: arg1) and: [ self repositories compareEqual: arg1 repositories ]packageFileSpecFor: arg1  ^arg1 project projectReferenceSpec     name: self name;     projectReference: self copy;     yourselfversion124ProjectToolBox: arg1  < version: '1.2.4' imports: #('1.2.4-baseline')>  arg1 for: #common do: [ arg1 repository: 'http://www.example.com/ac' ]projectPath: arg1  projectPath := arg1doingLoads: arg1  arg1 valuetimestampForVersion: arg1  arg1 setTimestampInMetacelloConfig: selfcurrentVersionInfoFor: arg1  ^self loadData currentVersionInfoFor: arg1 ifAbsent: [ super currentVersionInfoFor: arg1 ]collection: arg1 do: arg2 displaying: arg3  self bypassProgressBars ifTrue: [ ^super collection: arg1 do: arg2 displaying: arg3 ].  arg1 do: arg2 displayingProgress: arg3setUpBaselineGithubReferenceIX  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefIX-dkh.1'.  tmp2 := #BaselineOfGithubRefIX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationGithubReferenceIV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceIV:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4versionReferences  ^versionReferencesproject  ^projectreadStreamOn: arg1 do: arg2  | tmp1 |  tmp1 := arg1 readStream.  ^[ arg2 value: tmp1 ] ensure: [ tmp1 close ]< arg1  arg1 species = self species ifFalse: [ ^false ].  ^self compareLessThan: arg1compiler  ^self class compilerdefaultPlatformAttributes  | tmp1 tmp2 |  ((Smalltalk respondsTo: #image) and: [ Smalltalk image respondsTo: #metacelloPlatformAttributes ]) ifTrue: [ ^Smalltalk image metacelloPlatformAttributes ].  tmp1 := OrderedCollection with: #squeakCommon with: #pharo.  Smalltalk at: #SystemVersion ifPresent: [:arg1 |  tmp2 := arg1 current version.        (((tmp2 beginsWith: 'Pharo-1') or: [ tmp2 beginsWith: 'PharoCore1' ]) or: [ tmp2 beginsWith: 'Pharo1' ]) ifTrue: [ tmp1 add: #'pharo1.x'.              ((tmp2 beginsWith: 'Pharo-1.0') or: [ tmp2 beginsWith: 'PharoCore1.0' ]) ifTrue: [ tmp1 add: #'pharo1.0.x' ] ifFalse: [ ((tmp2 beginsWith: 'Pharo-1.1') or: [ tmp2 beginsWith: 'Pharo1.1' ]) ifTrue: [ tmp1 add: #'pharo1.1.x' ] ifFalse: [ ((tmp2 beginsWith: 'Pharo-1.2') or: [ tmp2 beginsWith: 'Pharo1.2' ]) ifTrue: [ tmp1 add: #'pharo1.2.x' ] ifFalse: [ (tmp2 beginsWith: 'Pharo1.3') ifTrue: [ tmp1 add: #'pharo1.3.x' ] ] ] ] ] ].  ^tmp1testCopyTo  | tmp1 |  tmp1 := self repositoriesSpec.  tmp1 add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  self should: [ tmp1 copy: 'http://example.com/repository' to: (self repositorySpec                 description: 'http://example.com/alternate/repository';                 yourself) ] raise: ErrorscheduleFetchFor: arg1 externalReference: arg2  ^self scheduleFetchFor: arg1 reference: arg2 message: 'Fetched -> ' , arg2 name , ' --- ' , arg2 repository repositoryDescription , ' --- ' , arg2 repository descriptionlinearLoadPackageSpecs: arg1 repositories: arg2  | tmp1 |  tmp1 := MetacelloGofer new.  arg2 do: [:arg3 |  tmp1 repository: arg3 ].  arg1 do: [:arg4 |  arg4 loadUsing: self gofer: tmp1 ]setUpIssue156ConfigurationOfGoo  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'ConfigurationOfGoo-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString selector: 'baselineGoo300Issue156Configuration:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGoo300Issue156Configuration:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineGoo400Issue156Configuration:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGoo400Issue156Configuration:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineGoo500Issue156Configuration:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGoo500Issue156Configuration:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())postLoadDoIt: arg1 constructor: arg2  arg2 postLoadDoItForProject: arg1createTonelRepository: arg1  | tmp1 tmp2 tmp3 |  tmp1 := Smalltalk at: #TonelRepository.  tmp2 := arg1 description.  tmp3 := (arg1 type , '://') size.  ^tmp1 new     directory: (self fileHandleOn: (arg1 description copyFrom: tmp3 + 1 to: tmp2 size));     yourselfmergeMap  ^Dictionary newpackageNamed: arg1  ^self packageNamed: arg1 ifAbsent: [ nil ]recordValidationError: arg1 versionString: arg2 callSite: arg3 reasonCode: arg4  < haltOrBreakpointForTesting>  (self errorReasonCodes includes: arg4) ifFalse: [ self error: 'Unknown error reason code' ].  ((self exludededValidations at: arg2 ifAbsent: [ #() ]) includes: arg4) ifTrue: [ ^self ].  (self debug includes: #error) ifTrue: [ self halt: 'Debug triggered for error: ' , arg1 ].  self validationReport add: (MetacelloValidationError configurationClass: (self recurse ifTrue: [ self configurationClass ] ifFalse: [ nil ]) reasonCode: arg4 callSite: arg3 explanation: arg1)baseline25Foo: arg1  < version: '2.5-baseline'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #baseline.        arg1           package: 'GoferFoo' with: [ arg1 requires: 'GoferFan' ];           yourself.        arg1           project: 'GoferFan' with: [ arg1                 className: 'MetacelloTestConfigurationOfAtomicFan';                 versionString: '2.0-baseline';                 loads: 'GoferFan';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]version118ProjectToolBox: arg1  < version: '1.1.8-baseline' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1 preLoadDoIt: #alternatePreloadForCore ] ]modifications: arg1  modifications := arg1determineCurrentVersionForLoad  self subclassResponsibilityaLoadedProjectIsNotCurrent: arg1  aLoadedProjectIsNotCurrent := arg1versionStringForProject: arg1  self root versionString: arg1extractNameFromFile  file == nil ifTrue: [ ^nil ].  ^(self loader nameComponentsFrom: self file) firstload  self explicitLoadUsing: self loadertestVersion14  self assert: (self versionClass fromString: '2.9.0-alpha02') < (self versionClass fromString: '2.9.0-alpha03')baseline11: arg1  < version: '1.1-baseline' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 project: 'UTF7' with: [ arg1                 className: 'MetacelloVersionQueryMiscConfig';                 versionString: '1.0-baseline';                 loads: #('Misc-UTF7') ].        arg1           group: 'Core' with: #('UTF7');           group: 'Tests' with: #('UTF7');           yourself ]includes: arg1  self shouldNotImplementlesson12DoIts  ^Lesson title: 'Lesson 12 (DoIts)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version12:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #preloadForCore.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #postloadForCore:package:."Occassionally, you find that you need to perform an expression either before a package is loaded, orafter a package is loaded. To do that in Metacello, you can define a preLoadDoIt selector and a postLoadDoIt selector:"	(MetacelloTutorialConfig project version: ''1.2'') spec."If you open a Transcript and execute the following expression, you will see that the pre load andpost load methods were executed:"	(MetacelloTutorialConfig project version: ''1.2'') load."The pre/post load methods may take 0, 1 or 2 args. The loader is the first optional argument and the loaded packageSpec is the second optional argument."ProfStef next.'label  ^self versionString , ' [' , self projectLabel , ']'testBasicBleedingEdgeVersion  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self projectWith: #(#'platformVersion1.x').  tmp2 := tmp1 version: #bleedingEdge.  tmp3 := 'spec blessing: #''baseline''.spec project: ''Example Project'' with: [		spec			className: ''MetacelloExampleProjectConfig'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'' ].'.  tmp4 := tmp2 spec printString.  self assert: tmp3 equals: tmp4compareLessThan: arg1 other: arg2 version: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 size.  tmp2 := arg2 size.  tmp3 := tmp1 min: tmp2.  tmp4 := 0.  tmp5 := true.  [ tmp5 and: [ tmp4 < tmp3 ] ] whileTrue: [ (arg1 at: tmp4 + 1) = (arg2 at: tmp4 + 1) ifTrue: [ tmp4 := tmp4 + 1 ] ifFalse: [ tmp5 := false ] ].  tmp4 < tmp3 ifTrue: [ ^(arg1 at: tmp4 + 1) metacelloSemanticVersionComponentLessThan: (arg2 at: tmp4 + 1) ].  tmp1 < tmp2 ifTrue: [ tmp1 = 0 ifTrue: [ #preRelease == arg3 ifTrue: [ ^false ].              ^true ].        (arg1 at: tmp3) = (arg2 at: tmp3) ifFalse: [ ^true ].        ^true ] ifFalse: [ tmp1 = tmp2 ifTrue: [ ^false ].        tmp2 = 0 ifTrue: [ #build == arg3 ifTrue: [ ^false ].              ^true ].        (arg1 at: tmp3) = (arg2 at: tmp3) ifFalse: [ ^false ].        ^true ]versionForProject: arg1  self versionStringForProject: arg1removeProject: arg1  self root removeProject: arg1 constructor: selfdefaultAction  self checkAllowed.  ^super defaultActionversionOfIV: arg1  < version: '0.9.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>baselineOfIV:'.        arg1 author: 'dkh'.        arg1 timestamp: '5/4/2012 14:16' ].  arg1 for: #custom do: [ arg1 baseline: 'ExternalX' with: [ arg1 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]updateForSpawnMethod: arg1  | tmp1 |  tmp1 := name.  self projectReference updateForSpawnMethod: arg1.  super updateForSpawnMethod: arg1.  name := tmp1testForDoListAtrribute2Active  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self projectWith: #(#attribute2).  tmp2 := tmp1 version: '3.0-baseline'.  tmp3 := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec 	project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec 	group: ''Core'' with: #(''Example Project'' );	group: ''Core'' with: #(''Extra Project'' ).'.  tmp4 := tmp2 spec printString.  self assert: tmp3 equals: tmp4setUp  super setUp.  self     setUpMonticelloRepository;     setUpConfigurationOfFoo;     setUpConfigurationOfFeaux;     setUpConfigurationOfProjectFie;     setUpConfigurationOfProjectFee;     setUpConfigurationOfFum;     setUpConfigurationOfProjectFoe;     setUpConfigurationOfFan;     setUpConfigurationOfFix;     setUpIssue77;     setUpIssue95;     setUpConfigurationOfSymbolic;     setUpConfigurationOfProjectToolBox;     setUpConfigurationOfProjectIssue115;     setUpConfigurationOfProjectIssue136;     setUpConfigurationOfProjectIssue119;     setUpConfigurationOfProjectIssue171;     setUpConfigurationOfProjectIssue154;     setUpConfigurationOfProjectIssue156;     setUpIssue156ConfigurationOfProjectGoo;     setUpIssue156ConfigurationOfProjectSoo;     setUpConfigurationOfProjectFum;     setUpConfigurationOfProjectIssue125;     setUpConfigurationOfProjectIssue283;     yourselfcompareEqual: arg1  | tmp1 tmp2 |  tmp1 := (self map values sort: [:arg2 :arg3 |  arg2 description <= arg3 description ]) collect: [:arg4 |  arg4 description ].  tmp2 := (arg1 map values sort: [:arg2 :arg3 |  arg2 description <= arg3 description ]) collect: [:arg4 |  arg4 description ].  ^tmp1 = tmp2ancestors  ^niladditions  additions ifNil: [ additions := Dictionary new ].  ^additionspostLoad31baseline  Smalltalk at: #GoferFar ifAbsent: [ self error: 'GoferFar should be loaded' ]import  ^importNameload: arg1  ^self execute: #load: args: {arg1}label  ^'Critical Warning'setUpConfigurationOfProjectIssue115dkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue115-dkh.2'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion10Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue115:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version10Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue115:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version11Issue115:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version11Issue115:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4version10MetacelloExample: arg1  < version: '1.0' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 package: 'GoferFoo' with: 'GoferFoo-lr.2' ]primeRegistryFromImage  self primeRegistryFromImage: falsepreLoadDoIt: arg1  arg1 setPreLoadDoItInMetacelloSpec: selfstableVersionOfX: arg1  < symbolicVersion: #stable>  arg1 for: #common version: '0.9.0'do: arg1  1 to: self size do: [:arg2 |  arg1 value: (self at: arg2) ]setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:arg1 |  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: arg1 packageName) info: (MCVersionInfo name: arg1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: arg1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: arg1 packageName asSymbol)) with: (MCClassDefinition name: (arg1 packageName copyWithout: $-) asSymbol superclassName: #Object category: arg1 packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]testGroups  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--groups=core,tests').  self assertCollection: tmp1 groups hasSameElements: #('core' 'tests')clearCurrentVersionCache  MetacelloClearStackCacheNotification signal: #(#currentVersion #currentVersionAgainst: #currentVersionInfo)setBaseline: arg1  | tmp1 tmp2 |  tmp2 := self project baselineOfProjectSpec     name: arg1;     className: 'BaselineOf' , arg1;     yourself.  tmp1 := self project projectReferenceSpec     name: arg1;     projectReference: tmp2;     yourself.  self root packages merge: tmp1.  ^tmp2postLoadDo: arg1  arg1 value: selflesson14  configuration092Issue63: arg1  < version: '0.9.2'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration092Issue63:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ];           package: 'GoferBar' with: [ arg1                 file: 'GoferBar-lr.1';                 repository: 'dictionary://Metacello_Gofer_Test_Repository' ];           package: 'GoferFoo' with: [ arg1                 file: 'GoferFoo-lr.2';                 requires: 'External';                 repository: 'dictionary://Metacello_Gofer_Test_Repository' ];           import: 'External' ]baselineVersion20Issue125: arg1  < version: '2.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 description: 'MetacelloConfigurationResource>>baselineVersion20Issue125:'.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo';           package: 'GoferBar' with: [ arg1 requires: 'GoferFoo' ];           yourself ]aLoadedPackageIsCurrent: arg1  aLoadedPackageIsCurrent := arg1testVersion05  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '3'.  tmp2 := self versionClass fromString: '2'.  self assert: tmp1 > tmp2version133ProjectToolBox: arg1  < version: '1.3.3-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository' ].  arg1 for: #level1_1 do: [ arg1 package: 'GoferBar' with: 'GoferBar-jf.1'.        arg1 for: #level2_1 do: [ arg1 package: 'GoferFoo' with: 'GoferFoo-lr.1'.              arg1 for: #level3_1 do: [ arg1 package: 'GoferFaux' with: 'GoferFaux-tg.30' ] ].        arg1 for: #level2_2 do: [ arg1 package: 'GeauxBar' with: 'GeauxBar.branch-lr.2'.              arg1 for: #level3_2 do: [ arg1 package: 'GeauxBeau' with: 'GeauxBeau-dkh.55' ] ] ].  arg1 for: #pharo do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository' ]latestVersionMatching: arg1  ^nilallProjectsDo: arg1 withTraversedProjects: arg2  self projects do: [:arg3 |  (arg3 version notNil and: [ (arg2 includes: arg3 version) not ]) ifTrue: [ arg2 add: arg3 version.              arg1 value: arg3 version.              arg3 version allProjectsDo: arg1 withTraversedProjects: arg2 ] ]setUpConfigurationOfProjectLoop  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectLoop-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40ProjectLoop:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectLoop)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())package: arg1 overrides: arg2 constructor: arg3  arg3 packageForVersion: arg1 overrides: arg2operatorForProject: arg1  self root operator: arg1projectVersionEscaped  | tmp1 |  tmp1 := self projectVersion.  (projectVersion includes: $/) ifTrue: [ ^tmp1 copyReplaceAll: '/' with: '\/' ].  ^tmp1get  | tmp1 tmp2 |  MetacelloProjectRegistration copyRegistryRestoreOnErrorWhile: [ self setDefaultsAndValidateProjectSpec.        tmp1 := self projectSpec.        tmp2 := tmp1 projectPackage.        tmp2 repositorySpecs do: [:arg1 |  arg1 createRepository flushForScriptGet ].        self cacheRepository ifNotNil: [:arg2 |  tmp2 loader loaderPolicy cacheRepository: arg2 ].        tmp2 load.        self root: (Smalltalk at: tmp1 className asSymbol) project.        MetacelloProjectRegistration registrationForProjectSpec: tmp1 ifAbsent: [:arg3 |  arg3 registerProject ] ifPresent: [:arg4 :arg3 |  arg4 copyOnWrite: [:arg5 |  tmp1 copyForRegistration: arg5 onWrite: [:arg6 |  arg6 ifNil: [ arg5 merge: arg3 ] ifNotNil: [ arg6 mergeScriptRepository: tmp1 ] ] ] ] ]version05: arg1  < version: '0.5'>  arg1 for: #common do: [ arg1 repository: 'http://www.example.com/Example'.        arg1           package: 'Example-Core' with: 'Example-Core-anon.11';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1' ]getFile  ^filerequires: arg1  arg1 setRequiresInMetacelloPackage: selfensureConfigurationLoaded: arg1 ensured: arg2  ^trueloads: arg1  arg1 setLoadsInMetacelloProject: selfisBaselineOfProjectSpec  ^truehasConflictWithProjectSpec: arg1  ^arg1 hasConflictWithBaselineSpec: selfcomputeVersionStatus  self spec computeVersionStatus: [:arg1 |  ^arg1 ].  ^#noStatusaddTo: arg1  arg1 add: selfverify: arg1 version: arg2  | tmp1 tmp2 |  tmp1 := MCWorkingCopy allManagers detect: [:arg3 |  arg3 packageName = arg1 ].  self assert: (tmp2 := tmp1 ancestors first name) equals: arg2repositoryDescriptions  ^self repositorySpecs collect: [:arg1 |  arg1 description ]defaultAction  ^nilexecute: arg1  MetacelloPlatform current withMetacelloLoadSessionDo: [ super execute: arg1 ]setProject: arg1 withBlock: arg2  | tmp1 tmp2 |  tmp2 := self project projectSpec     name: arg1;     yourself.  tmp1 := self project projectReferenceSpec     name: arg1;     projectReference: tmp2;     yourself.  self root packages merge: tmp1.  self with: tmp2 during: arg2resolveToLoadableSpec  ^self resolveProjectSpec resolveToLoadableSpecsetUpConfigurationOfConflict  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfConflict-dkh.1'.  tmp2 := #ConfigurationOfConflict.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'conflictOf20:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf20:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'conflictOf21:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf21:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'conflictOf10:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf10:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'conflictOf11:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf11:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'conflictOf12:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #conflictOf12:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4lesson13  methodUpdateSelector  ^self subclassResponsibilitybaseline40MethodSourceProjectFee  ^(self class sourceCodeAt: #baseline40ProjectFee:) asStringhostname  ^hostnametempFileFor: arg1 suffix: arg2  ^(FileLocator temp asFileReference / (FileReference newTempFilePrefix: arg1 suffix: arg2) basename) fullNameroot: arg1  root := arg1timestamp: arg1  self root timestamp: arg1 constructor: selfexecuteCollection: arg1 do: arg2  self projectSpecsFromRepositoryArg do: [:arg3 |  (arg1 includes: (MetacelloScriptEngine baseNameOf: arg3 className)) ifTrue: [ arg2 value: (self applyArgsToProjectSpec: arg3 copy) ] ]projectSpecListBlock  ^[ MetacelloProjectRegistration projectSpecs ]bleedingEdge  ^nilrepository: arg1 username: arg2 password: arg3  self repositories repository: arg1 username: arg2 password: arg3compareCurrentVersion: arg1 targetVersionStatus: arg2 using: arg3  ^(MetacelloLookupProjectSpecForLoad new     projectSpec: self;     yourself) signal performCurrentVersionTestAgainst: self versionOrNil operator: arg1 targetVersionStatus: arg2 using: arg3testAddE  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository'.  tmp2 := tmp1 map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: 'http://example.com/repository'.  self assert: tmp2 type equals: 'http'.  tmp2 := tmp1 map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: '/opt/gemstone/repository'.  self assert: tmp2 type equals: 'directory'resolveToAllPackagesIn: arg1 into: arg2 visited: arg3  (self resolveProjectSpec resolveToAllPackagesIn: arg1 visited: arg3) do: [:arg4 |  arg2 at: arg4 put: arg4 ]stableVersion: arg1  < symbolicVersion: #stable>  arg1 for: #'platformVersion1.x' version: '1.0'setAuthorWithString: arg1  self root author: arg1copySpec: arg1 with: arg2 to: arg3  | tmp1 tmp2 |  [ tmp2 := arg1 goferLoaderReference resolveWith: arg2 ] on: Error do: [:arg4 |  ^nil ].  tmp1 := MCRepositoryGroup default repositories detect: [:arg5 |  arg5 = arg3 ] ifNone: [ arg3 ].  tmp1 storeVersion: tmp2 version.  ^tmp2 repositorytestDirectoryRepository  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self project.  tmp2 := (tmp1 version: '1.0-baseline') packageNamed: 'Example-Core'.  tmp3 := tmp2 repositorySpecs first.  self assert: tmp3 type equals: 'directory'.  tmp4 := tmp3 createRepository.  self assert: tmp4 class identicalTo: MCDirectoryRepository.  self assert: tmp4 description equals: self directoryForPlatformlesson07  resolveSpecsForPackageOrdering: arg1  | tmp1 |  tmp1 := Set new.  self includes do: [:arg2 |  (arg1 packageNamed: arg2 ifAbsent: [  ]) ifNotNil: [:arg3 |  tmp1 addAll: (arg3 resolveToPackagesIn: arg1 andProjects: true visited: MetacelloVisitedPackages new) ] ].  ^tmp1impara: arg1  self repository: 'http://source.impara.de/' , arg1loadUsing: arg1 gofer: arg2  self loadDirectives isEmpty ifTrue: [ ^self ].  arg1 loadAtomicLoadDirective: self gofer: arg2collection: arg1 do: arg2 displaying: arg3  arg1 do: arg2loadedPackages  | tmp1 |  tmp1 := OrderedCollection new.  self loadDirective packageDirectivesDo: [:arg1 |  tmp1 add: arg1 file ].  ^tmp1baseline50MethodSourceFoo  ^(self class sourceCodeAt: #baseline50Foo:) asStringsetImport: arg1  importArray := importArray ifNil: [ arg1 ] ifNotNil: [ importArray , arg1 ]defaultAction  self existingProjectRegistration locked ifTrue: [ ^self useIncoming ].  ^MetacelloConflictingProjectError signal: 'Load Conflict between existing ' , self existingProjectRegistration printString , ' and ' , self newProjectRegistration printStringtestFtpRepository  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self project.  tmp2 := (tmp1 version: '1.3-baseline') packageNamed: 'Example-Core'.  tmp3 := tmp2 repositorySpecs first.  self assert: tmp3 type equals: 'ftp'.  tmp4 := tmp3 createRepository.  self assert: tmp4 class identicalTo: MCFtpRepository.  self assert: tmp4 host equals: 'ftp.example.com'.  self assert: tmp4 directory equals: 'examples'difference: arg1  ^self spec difference: arg1 specconfigMethodCascadeOn: arg1 indent: arg2  | tmp1 |  tmp1 := self map values sort: [:arg3 :arg4 |  arg3 description <= arg4 description ].  tmp1 size = 1 ifTrue: [ tmp1 first configMethodCascadeOn: arg1 lastCascade: true ] ifFalse: [ 1 to: tmp1 size do: [:arg5 |  | tmp2 |              arg1 tab: arg2 + 1.              (tmp1 at: arg5) configMethodCascadeOn: arg1 lastCascade: arg5 >= tmp1 size ] ]setFor: arg1 version: arg2  arg1 asMetacelloAttributeList do: [:arg3 |  self attributeMap at: arg3 put: arg2.        self addAttribute: arg3 ]loadVersion: arg1  | tmp1 tmp2 tmp3 |  self ensureProjectLoaded.  tmp1 := arg1.  tmp1 == nil ifTrue: [ [ tmp1 := self version ] on: MetacelloVersionDoesNotExistError do: [:arg2 |  ^(MetacelloProjectSpecLoadError projectSpec: self)                 versionDoesNotExistException: arg2;                 signal: 'No version found for ' , self versionString printString , ' of ' , self className asString , ' because: ' , arg2 description ] ].  tmp2 := self loader copy.  tmp2 operator: self operator.  tmp1 loader: tmp2.  tmp3 := (tmp2 ignoreImage ifTrue: [ self loadListForVersion: tmp1 ] ifFalse: [ tmp1 packageAndProjectNamesToLoad: (self loadListForVersion: tmp1) loader: tmp2 ]) asSet.  MetacelloPlatform current useStackCacheDuring: [:arg3 |  | tmp4 tmp5 |        tmp4 := arg3 at: self projectClass ifAbsent: [ arg3 at: self projectClass put: Dictionary new ].        (tmp5 := tmp4 at: tmp1 ifAbsent: [  ]) == nil ifTrue: [ tmp4 at: tmp1 put: tmp3 ] ifFalse: [ (tmp5 size = tmp3 size and: [ tmp5 allSatisfy: [:arg4 |  tmp3 includes: arg4 ] ]) ifTrue: [ ^self ] ifFalse: [ tmp4 at: tmp1 put: tmp3 ] ].        tmp1 versionString ~= self versionString ifTrue: [ MetacelloNotification signal: ' [' , tmp1 versionString , ']' ].        tmp2 preLoad: self.        tmp1 fetchRequiredFromArray: tmp3.        (MetacelloProjectSpecLoadedNotification new projectSpec: (self copy versionString: tmp1 versionString)) signal.        tmp2 postLoad: self ] defaultDictionary: Dictionary newpreLoad: arg1  (MetacelloDirective preLoadSpec: arg1 loader: self) addTo: self loadDirectivebaseline25ProjectFie: arg1  < version: '2.5'>  arg1 for: #common do: [ arg1 configuration: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '3.5';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]projectClassMethodSource  ^(self class class sourceCodeAt: #project) asStringresetCacheGofer  cacheGofer := nilbaseline62ProjectIssue86: arg1  < version: '6.2'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'A' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.2';                 loads: #('1');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'B' with: [ arg1                 className: 'MetacelloTestConfigurationOfLinearFoo';                 versionString: '6.2';                 loads: #('2');                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]requiredSpecsForPackageOrdering: arg1  ^self specs: self requires forPackageOrdering: arg1loadPostloadDirective: arg1  self postloads add: arg1postLoadDo: arg1  aProjectNotLoaded  ^aProjectNotLoadedversion02: arg1  < version: '0.2'>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1                 file: 'Example-Core-anon.9';                 repository: 'http://www.example.com/Example' ] ]doLoad  self subclassResponsibilityvalidateVersionString: arg1 withDefaultVersionString: arg2  self versionString ifNil: [ arg2 ifNotNil: [ self versionString: arg2 ] ifNil: [ arg1 add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #incompleteProjectSpec callSite: #validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription: explanation: 'version field required') ] ]allProjects  | tmp1 |  tmp1 := OrderedCollection new.  self allProjectsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1postLoadDoItForVersion: arg1  self postLoadDoItForSpec: arg1downloadBasicFile: arg1 to: arg2 username: arg3 pass: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := self downloadErrorFileNameFor: arg2.  tmp1 := FileStream forceNewFileNamed: arg2.  tmp2 := FileStream forceNewFileNamed: tmp4.  tmp5 := arg3 ifNotNil: [ tmp5 := {'-u' .         (arg3 , ':' , arg4) .         '-L' .         arg1} ] ifNil: [ tmp5 := {'-L' .         arg1} ].  tmp3 := (self class environment at: #OSProcess) thisOSProcess forkJob: '/usr/bin/curl' arguments: tmp5 environment: nil descriptors: (Array with: nil with: tmp1 with: tmp2).  tmp3 ifNil: [ (self class environment at: #OSProcess) noAccessorAvailable ].  [ tmp3 isRunning ] whileTrue: [ (Delay forMilliseconds: 100) wait ].  tmp1 close.  tmp2 close.  ^tmp4label  ^self filedeleteFileNamed: arg1  (self fileDirectoryClass on: arg1) containingDirectory deleteFileNamed: (self fileDirectoryClass localNameFor: arg1)configMethodOn: arg1  self configMethodOn: arg1 indent: 0loadPreloadDirective: arg1  self preloads add: arg1testCacheNil  | tmp1 |  self assert: (tmp1 := self cacheNil) identicalTo: nilinitialize  self     repositoryMap;     cacheRepository;     ensuredMap.  ignoreImage := falseupdateProject  ^self updateProject: MetacelloLoaderPolicy newcollectAllVersionsFromVersionImportPragmasInto: arg1 using: arg2 satisfiedPragmas: arg3  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := false.  tmp3 := IdentitySet new.  tmp4 := 0.  [ tmp4 := tmp4 + 1.  tmp4 > 10000 ifTrue: [ self error: 'Apparent loop in import expansion' ].  tmp2 ] whileFalse: [ tmp2 := true.        arg3 keysAndValuesDo: [:arg4 :arg5 |  | tmp5 |              tmp5 := nil.              tmp1 := false.              [ arg5 do: [:arg6 |  (tmp3 includes: arg6) ifFalse: [ | tmp6 |                          tmp2 := false.                          tmp6 := arg6 argumentAt: 2.                          tmp6 detect: [:arg7 |  (arg1 includesKey: arg7) not ] ifNone: [ tmp6 do: [:arg7 |  | tmp7 |                                      (tmp7 := arg1 at: arg7 ifAbsent: [  ]) ~~ nil ifTrue: [ tmp1 := true.                                            tmp3 add: arg6.                                            tmp5 == nil ifTrue: [ tmp5 := tmp7 spec copy ] ifFalse: [ tmp5 := tmp5 mergeSpec: tmp7 spec copy ].                                            tmp5 versionString: arg4.                                            arg2 value: tmp5 value: arg6 ] ] ] ] ] ] on: Error do: [:arg8 |  (MetacelloErrorInProjectConstructionNotification versionString: tmp5 versionString exception: arg8) ifTrue: [ ^arg8 pass ] ifFalse: [ self errorMap at: tmp5 versionString put: arg8.                          tmp1 := false ] ].              tmp1 ifTrue: [ | tmp7 tmp8 |                    tmp8 := OrderedCollection new.                    tmp7 := tmp5 createVersion.                    arg5 do: [:arg6 |  tmp8 addAll: (arg6 argumentAt: 2) ].                    tmp7 importedVersions: tmp8.                    self validateVersionString: arg4 againstSpec: tmp5.                    arg1 at: tmp5 versionString put: tmp7 ].              self reset ] ]defaultAction  ^truebaseline10: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: [ arg1 value: #baseline ].        arg1 description: [ arg1 value: 'Descriptive comment' ].        arg1 author: [ arg1 value: 'dkh' ].        arg1 timestamp: [ arg1 value: '10/7/2009 14:40' ].        arg1 timestamp: [ arg1 value: (DateAndTime fromString: '10/7/2009 14:40') ].        arg1 blessing: #baseline.        arg1 description: 'Descriptive comment'.        arg1 author: 'dkh'.        arg1 timestamp: (DateAndTime fromString: '10/7/2009 14:40').        arg1 timestamp: '10/7/2009 14:40'.        arg1           preLoadDoIt: #preloadForVersion;           postLoadDoIt: #postloadForVersion.        arg1 repository: 'http://www.example.com/rr'.        arg1 repository: 'http://www.example.com/private' username: 'foo' password: 'bar'.        arg1 repositories: [ arg1                 repository: '/opt/mc/repository';                 repository: 'c:\pharo\myapp\repo\';                 repository: 'ftp://ftp.example.com/repo';                 repository: 'dictionary://GlobalName';                 repository: 'http://www.example.com/rr';                 repository: 'http://www.example.com/ar';                 repository: 'http://www.example.com/private' username: 'foo' password: 'bar' ].        arg1           project: 'UI Support' with: [ arg1                 className: 'ConfigurationOfUI';                 versionString: '1.0';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 operator: #~>;                 loads: #('UI-Core');                 file: 'ConfigurationOfUI';                 repository: 'http://www.example.com/r' ];           project: 'UI Support' overrides: [ arg1                 className: 'ConfigurationOfUINew';                 versionString: '1.0';                 operator: #>=;                 loads: #('UI-Core' 'UI-Tests');                 repository: 'http://www.example.com/r' username: 'foo' password: 'bar' ];           project: 'UI Tests' copyFrom: 'UI Support' with: [ arg1                 className: 'ConfigurationOfUI';                 versionString: '1.0';                 operator: #~>;                 loads: #('UI-Core' 'UI-Tests');                 repository: 'http://www.example.com/r' ];           project: 'UI Support' with: '1.0.1';           removeProject: 'UI Tests';           project: 'UI Multi' with: [ arg1                 className: 'ConfigurationOfMulti';                 repository: 'http://www.example.com/r';                 repository: 'http://www.example.com/s' ].        arg1           package: 'Example-AddOn' with: [ arg1                 requires: #('Example-Core');                 includes: #('Example-UI');                 file: 'Example-AddOn-anon.3';                 repositories: [ arg1                       repository: 'http://www.example.com/yar';                       repository: 'http://www.example.com/yas' ];                 preLoadDoIt: #preloadForAddOn;                 postLoadDoIt: #postloadForAddOn ];           package: 'Example-AddOn' overrides: [ arg1                 requires: #('Example-Core' 'UI Support');                 includes: #('Example-UI');                 file: 'Example-AddOn-anon.7';                 supplyingAnswers: #(#('list of packages' 'Kernel* Collection*'));                 repository: 'http://www.example.com/or' username: 'foo' password: 'bar';                 preLoadDoIt: #preloadForAddOn;                 postLoadDoIt: #postloadForAddOn ];           package: 'Example-AddOn' with: 'Example-AddOn-anon.5';           package: 'Example-Core';           package: 'Example-Tests' with: [ arg1 requires: #('Example-Core') ];           package: 'Example-TestsUI' with: [ arg1 requires: #('Example-UI') ];           package: 'Example-UI' with: [ arg1 requires: #('Example-AddOn') ];           removePackage: 'Example-Tests'.        arg1           group: 'default' with: #('Example-Core' 'Example-AddOn');           group: 'default' overrides: #('Example-Core' 'Example-Tests');           removeGroup: 'default' ]actionLabel  ^'Loading 'testVersion04  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '1.0.1'.  tmp2 := self versionClass fromString: '1.0.0'.  self assert: tmp1 > tmp2repository  ^self externalReference repositorydoSilently  ^truebaseline40MethodSourceFan  ^(self class sourceCodeAt: #baseline40Fan:) asStringprojectSpecSelectBlock  ^[:arg1 |  true ]version  ^versiondefaultAction  ^falseloadLinearLoadDirective: arg1 gofer: arg2  arg1 loadDirectives do: [:arg3 |  arg3 loadUsing: arg1 gofer: arg2 ].  arg1 finalizeLoad: arg2baseline40MethodSourceProjectFum  ^(self class sourceCodeAt: #baseline40ProjectFum:) asStringregistration  ^MetacelloProjectRegistration registrationForProjectSpec: self ifAbsent: [:arg1 |   ] ifPresent: [:arg2 :arg3 |  arg2 ]baselineProjectSpecIfPresent: arg1 ifAbsent: arg2  ^baselineProjectSpec ifNotNil: [ arg1 cull: baselineProjectSpec ] ifNil: arg2projectSpecListBlock  ^[ MetacelloProjectRegistration configurationProjectSpecs ]package: arg1 with: arg2 constructor: arg3  arg3 packageForVersion: arg1 with: arg2loadDirective  ^self loaderPolicy loadDirectiveclearPackageCache  | tmp1 tmp2 |  tmp1 := self defaultPackageCache.  tmp1 flushCache.  tmp2 := tmp1 directory.  tmp2 ~~ nil ifTrue: [ [ self recursiveDelete: tmp2 ] on: Error do: [:arg1 |   ] ]addStatement: arg1 args: arg2  self statements add: arg1 -> arg2asProjectRegistration  (self className beginsWith: 'BaselineOf') ifTrue: [ ^MetacelloProjectRegistration fromMCBaselineProjectSpec: self asBaselineProjectSpec ].  ^MetacelloProjectRegistration fromMCConfigurationProjectSpec: self asConfigurationProjectSpecsetUpLockConfigurations  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfLockConfigurations-dkh.1'.  tmp2 := #ConfigurationOfLockConfigurations.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'lockConfiguration10:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration10:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'lockConfiguration11:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration11:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'lockConfiguration12:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration12:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'lockConfiguration13:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration13:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'lockConfiguration14:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration14:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'lockConfiguration15:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #lockConfiguration15:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4mergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #name put: name.  tmp1 at: #className put: className.  tmp1 at: #versionString put: versionString.  tmp1 at: #operator put: operator.  tmp1 at: #loads put: loads.  tmp1 at: #preLoadDoIt put: preLoadDoIt.  tmp1 at: #postLoadDoIt put: postLoadDoIt.  ^tmp1incrementPatchVersion  self size < 2 ifTrue: [ self at: 2 put: 0 ].  self size < 3 ifTrue: [ self at: 3 put: 0 ].  self incrementVersionAt: 3loadPackageDirective: arg1 gofer: arg2  projectClass  ^MetacelloMCProjectaddVersion: arg1 versionInfo: arg2 resolvedReference: arg3 packageSpec: arg4  | tmp1 |  (tmp1 := self packageNameMap at: arg4 name ifAbsent: [  ]) ~~ nil ifTrue: [ tmp1 do: [:arg5 |  self dataMap removeKey: arg5 name.              self versionInfoMap removeKey: arg5 name ] ].  self dataMap at: arg1 info name put: {arg1 .         arg3 .         arg4}.  self versionInfoMap at: arg2 name put: {arg2}.  self packageNameMap at: arg4 name put: {arg2}packageDirectivesDo: arg1  arg1 value: selftestVersion19  self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0')repositoryDescriptions  ^self repositorySpecs collect: [:arg1 |  arg1 description ]extractDefaultSymbolicVersionPragmas  | tmp1 |  tmp1 := Dictionary new.  self extractPragmas: #defaultSymbolicVersion: into: tmp1.  ^tmp1testRemovePackageD  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp1 remove: 'Package'.  tmp2 := false.  tmp1 packageNamed: 'Package' ifAbsent: [ tmp2 := true ].  self assert: tmp2reset  super reset.  methodSections := nilresolvedReference  ^resolvedReferencetestVersion12  self deny: (self versionClass fromString: '1.0.0') <= (self versionClass fromString: '0.7.0')reset  projectVersion  (projectVersion == nil or: [ projectVersion isEmpty ]) ifTrue: [ projectVersion := 'master' ].  ^projectVersionrecord  ^self doRecordRequiredFromArray: self spec defaultPackageNamesconfigMethodValueOn: arg1 for: arg2 selector: arg3 last: arg4 indent: arg5  | tmp1 |  arg2 == nil ifTrue: [ ^self ].  tmp1 := arg2 value isSymbol ifTrue: [ '#' , arg2 value asString printString ] ifFalse: [ arg2 value printString ].  arg1     tab: arg5;     nextPutAll: 'spec ' , arg3 , ' ' , tmp1 , '.'.  arg4 ifFalse: [ arg1 cr ]packageForVersion: arg1 with: arg2  arg2 setPackage: arg1 withInMetacelloConfig: selfspotterForVersionsFor: arg1  < spotterOrder: 1>  self flag: #maybeRewriteForDirectStreaming.  arg1 listProcessor     title: 'Versions';     allCandidates: [ (#(stableVersion currentVersion bleedingEdge development) collect: [:arg2 |  [ self perform: arg2 ] on: Error do: [ nil ] ]) reject: [:arg2 |  arg2 isNil ] ];     itemName: [:arg3 |  arg3 versionString ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: trueprojectReference: arg1  projectReference := arg1projectLabel  ^'project'ancestors  | tmp1 |  (tmp1 := self workingCopy) ~~ nil ifTrue: [ tmp1 ancestry ancestors isEmpty not ifTrue: [ ^tmp1 ancestry ancestors ] ].  ^nilisSomethingLoadedAgainst: arg1  (self isPartiallyCurrentAgainst: arg1) isSomethingLoaded: [:arg2 |  ^true ].  ^falsesetUpConfigurationOfExternalXdkh2: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternalX-dkh.2'.  tmp2 := #ConfigurationOfExternalX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'stableVersionOfX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #stableVersionOfX:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'unstableVersionOfX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #unstableVersionOfX:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfX090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfX090:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfX091:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfX091:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4setUpIssue77D  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfIssue77D-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline10D:' category: 'cat' timeStamp: '' source: self baseline10MethodSourceD)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())projectPlatformAttributes  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  (tmp2 := self projectAttributes) ~~ nil ifTrue: [ tmp1 addAll: tmp2 value ].  ^self defaultPlatformAttributes , tmp1versionDoesNotExistError: arg1  ((Smalltalk at: #MetacelloSymbolicVersionDoesNotExistError) project: self project versionString: arg1) signalblock  ^blockconfigurationClass  ^configurationClasstearDown  | tmp1 tmp2 tmp3 |  tmp1 := Gofer new.  self tearDownPackages: tmp1.  tmp1 references notEmpty ifTrue: [ tmp1 metacelloUnload ].  testingEnvironment removeKey: #Metacello_Gofer_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Alternate_Repository ifAbsent: [  ].  self tempRepositories do: [:arg1 |  MCRepositoryGroup default removeIdenticalRepository: arg1 ].  MetacelloPlatform current reenableUndefinedSybolUpdates: undefinedSymbols.  tmp2 := MCWorkingCopy allManagers collect: [:arg2 |  arg2 packageName ].  tmp3 := tmp2 difference: initialWorkingCopyList.  tmp3 do: [:arg3 |  self crTrace: 'leaked package from ' , self printString , ' -> ' , arg3 printString ].  self assertEmpty: tmp3.  super tearDownlesson08  ^Lesson title: 'Lesson 8' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version08:."In version 0.8 we''ve simply updated the package versions, which can be seen by comparing the results of loading version 0.7 and 0.8:"  (MetacelloTutorialConfig project version: ''0.7'') load.  (MetacelloTutorialConfig project version: ''0.8'') load.ProfStef next.'setUpBaselineOfExternalX  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfExternalX-dkh.1'.  tmp2 := #BaselineOfExternalX.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'externalBaselineX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #externalBaselineX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4label  self spec == nil ifTrue: [ ^'' ].  ^self spec labelbaseline40Fan: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]projectSpec: arg1  projectSpec := arg1baseline62MethodSourceFoo  ^(self class sourceCodeAt: #baseline62Foo:) asStringresolveToLoadableSpec: arg1 forLoad: arg2 forMap: arg3 packages: arg4  | tmp1 |  tmp1 := self packageNamed: arg1 forLoad: arg2 forMap: arg3 ifAbsent: [ ^self error: 'Name not found: ' , arg1 ].  arg4 at: tmp1 name put: tmp1.  ^{tmp1}setUpConfigurationOfProjectIssue95  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue95-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40ProjectIssue95:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectIssue95)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())repositoryOverrides  ^(self options at: #repositoryOverrides ifAbsent: [ ^nil ]) collect: [:arg1 |  (MetacelloMCProject new repositorySpec description: arg1) createRepository ]flushCache  | tmp1 |  [ localRepository flushCache ] on: Error do: [:arg1 |  SystemNotification signal: 'Error for: ' , self description printString , ' during flushCache: ' , arg1 description printString ].  self class flushDownloadCache.  tmp1 := self calculateRepositoryDirectory.  tmp1 exists ifTrue: [ localRepository directory: tmp1 ] ifFalse: [ localRepository resetDirectory ]compareLessThan: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self size.  tmp2 := arg1 size.  tmp3 := tmp1 min: tmp2.  tmp4 := 0.  tmp5 := true.  [ tmp5 and: [ tmp4 < tmp3 ] ] whileTrue: [ (self at: tmp4 + 1) = (arg1 at: tmp4 + 1) ifTrue: [ tmp4 := tmp4 + 1 ] ifFalse: [ tmp5 := false ] ].  tmp4 < tmp3 ifTrue: [ ^(self at: tmp4 + 1) metacelloVersionComponentLessThan: (arg1 at: tmp4 + 1) ].  tmp1 < tmp2 ifTrue: [ tmp1 = 0 ifTrue: [ ^true ].        (self at: tmp3) = (arg1 at: tmp3) ifFalse: [ ^true ].        ^(arg1 at: tmp3 + 1) isString not ] ifFalse: [ tmp1 = tmp2 ifTrue: [ ^false ].        tmp2 <= 0 ifTrue: [ ^false ].        (self at: tmp3) = (arg1 at: tmp3) ifFalse: [ ^false ].        ^(self at: tmp3 + 1) isString ]configuration: arg1 with: arg2  self root configuration: arg1 with: arg2 constructor: selffile  file == nil ifTrue: [ ^self name ].  ^filedecrementMinorVersion  self size < 2 ifTrue: [ self at: 2 put: 0 ].  self decrementVersionAt: 2parent: arg1  parent := arg1abortMethod  project := project configuration class project.  methodSpec := nilproject: arg1 copyFrom: arg2 with: arg3  self root project: arg1 copyFrom: arg2 with: arg3 constructor: selfstable: arg1  < symbolicVersion: #stable>  arg1 for: #common version: '1.0'validateVersionSpec: arg1  arg1 blessing value == #broken ifTrue: [ ^self ].  arg1 projectDo: [:arg2 |  | tmp1 |        arg2 versionString == nil ifTrue: [ self recordValidationCriticalWarning: 'No version specified for the project reference ' , arg2 name printString , ' in version ' , arg1 versionString printString versionString: arg1 versionString callSite: #validateVersionSpec: reasonCode: #noVersionSpecified ].        tmp1 := arg2 referencedSpec.        arg1 blessing value == #baseline ifTrue: [ tmp1 hasRepository ifTrue: [ (tmp1 file beginsWith: tmp1 className) ifFalse: [ self recordValidationCriticalWarning: 'The class name of project ' , tmp1 className printString , ' does not match the file name ' , tmp1 file printString , ' in version ' , arg1 versionString printString versionString: arg1 versionString callSite: #validateVersionSpec: reasonCode: #projectClassNameFileMismatch ] ] ifFalse: [ self recordValidationError: 'The specification for the project reference ' , arg2 name printString , ' in version ' , arg1 versionString printString , ' is missing the required repository field' versionString: arg1 versionString callSite: #validateVersionSpec: reasonCode: #incompleteProjectSpec ] ].        tmp1 ensureProjectLoaded ifTrue: [ [ arg2 version ] on: MetacelloVersionDoesNotExistError do: [:arg3 |  | tmp2 |                    tmp2 := arg2 versionString == nil ifTrue: [ 'the default version' ] ifFalse: [ 'version ' , arg2 versionString printString ].                    self recordValidationError: 'Cannot resolve ' , tmp2 , ' for the project reference ' , arg2 name printString , ' in version ' , arg1 versionString printString versionString: arg1 versionString callSite: #validateVersionSpec: reasonCode: #cannotResolveVersion ] ] ] packageDo: [:arg4 |  (arg4 file beginsWith: arg4 name) ifFalse: [ self recordValidationCriticalWarning: 'The name of package ' , arg4 name printString , ' does not match the file name ' , arg4 file printString , ' in version ' , arg1 versionString printString versionString: arg1 versionString callSite: #validateVersionSpec: reasonCode: #packageNameMismatch ].        arg4 file = arg4 name ifTrue: [ self recordValidationCriticalWarning: 'No version specified for the package ' , arg4 name printString , ' in version ' , arg1 versionString printString versionString: arg1 versionString callSite: #validateVersionSpec: reasonCode: #noVersionSpecified ] ] groupDo: [:arg5 |   ].  self validateBaselineVersionSpec: arg1testVersion15  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1.0-beta.1')testMergeGroupA  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  tmp1 merge: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself).  tmp2 := tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (tmp2 includes includes: 'Core').  self assert: (tmp2 includes includes: 'Tests')setUpRepositories  testAddF  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1     repository: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     repository: (self repositorySpec           description: 'http://example.com/repository';           username: 'DaleHenrichs';           password: 'secret';           yourself).  tmp2 := tmp1 map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp2 description equals: 'http://example.com/repository'.  self assert: tmp2 type equals: 'http'.  self assert: tmp2 username equals: 'DaleHenrichs'.  self assert: tmp2 password equals: 'secret'from: arg1  from := arg1mergeSpec: arg1  | tmp1 tmp2 tmp3 |  tmp1 := super mergeSpec: arg1.  tmp2 := arg1 mergeMap.  (tmp3 := tmp2 at: #repositories) notEmpty ifTrue: [ tmp1 repositories: (self repositories isEmpty ifTrue: [ tmp3 ] ifFalse: [ self repositories mergeSpec: tmp3 ]) ].  ^tmp1author  author == nil ifTrue: [ ^self project valueHolderSpec           value: '';           yourself ].  ^authortestBaseline10ResolveToLoadableSpecs01  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self project.  tmp2 := tmp1 version: '1.0-baseline'.  tmp3 := #('UTF8').  tmp4 := tmp2 resolveToLoadableSpecs: #('UTF8').  self assert: tmp4 size equals: tmp3 size.  tmp4 do: [:arg1 |  self assert: (tmp3 includes: arg1 name) ].  tmp3 := #('UTF8').  tmp4 := tmp2 resolveToLoadableSpecs: #('Recursive').  self assert: tmp4 size equals: tmp3 size.  tmp4 do: [:arg1 |  self assert: (tmp3 includes: arg1 name) ]fetchRecord: arg1 required: arg2  MetacelloProjectRegistration copyRegistryWhile: [ self handleNotificationsForAction: [ | tmp1 tmp2 |              self setDefaultsAndValidateProjectSpec.              [ tmp2 := self lookupProjectSpecFor: self projectSpec ] on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade do: [:arg3 |  arg3 handleOnDownGrade: [:arg4 :arg5 :arg6 |  arg4 allowEvenIfLocked ] onUpgrade: [:arg4 :arg5 :arg6 |  arg4 allowEvenIfLocked ] ].              tmp1 := tmp2 versionForScriptEngine: self.              self root: (arg1 value: tmp1) loadDirective ] ]additions: arg1  additions := arg1repositories  ^self repositorySpecscreateHttpRepository: arg1  ^MCHttpRepository location: arg1 description user: arg1 username password: arg1 passwordsetDescriptionWithString: arg1  self root description: arg1copy: arg1 to: arg2  self addMember: (self copyMember           name: arg2 name;           sourceName: arg1;           spec: arg2;           yourself)monticelloRepository  ^monticelloRepositoryprimeRegistryCurrentVersionFor: arg1  ^[ arg1 project currentVersion ] on: Error do: [:arg2 |  Warning signal: 'Error finding current version of ' , arg1 name asString , '. Probably an invalid specification.'.        nil ]packagesDo: arg1  self loadDirectives do: [:arg2 |  arg2 packageDo: arg1 ]setUp  super setUp.  testingEnvironment at: #Metacello_Platform_Test_GlobalDictionary put: (MCDictionaryRepository new           description: 'dictionary://Metacello_Platform_Test_GlobalDictionary';           yourself)extractAllVersionPragmas  | tmp1 |  tmp1 := Dictionary new.  self extractPragmas: #version: into: tmp1.  self extractPragmas: #version:imports: into: tmp1.  ^tmp1methodSections  methodSections ifNil: [ methodSections := OrderedCollection new ].  ^methodSectionsversion101ProjectToolBox: arg1  < version: '1.0.1-baseline'>  arg1 for: #common do: [ arg1 blessing: #testBlessing ]projectDo: arg1 packageDo: arg2 groupDo: arg3  arg1 value: selfpackageRepositoryURL  ^self packageRepository ifNotNil: [:arg1 |  arg1 description ] ifNil: [ '' ]postLoadDoIt: arg1 constructor: arg2  arg2 postLoadDoItForVersion: arg1validateCleanLoadAndTestsForVersion: arg1 loads: arg2  | tmp1 tmp2 |  tmp2 := tmp1 := false.  [ self validateVersionLoad: arg1 loads: arg2.  tmp1 := true ] on: Error , Warning do: [:arg3 |  (arg3 isKindOf: Error) ifTrue: [ self recordValidationError: 'Error while loading version ' , arg1 versionString printString , ' in ' , self configurationClass name asString , ' ' , arg3 description versionString: arg1 versionString callSite: #validateCleanLoadAndTestsForVersion:loads: reasonCode: #loadError ].        (arg3 isKindOf: Warning) ifTrue: [ (arg3 isKindOf: Deprecation) ifTrue: [ self recordValidationCriticalWarning: 'Deprecation while loading version ' , arg1 versionString printString , ' in ' , self configurationClass name asString , ' ' , arg3 description versionString: arg1 versionString callSite: #validateCleanLoadAndTestsForVersion:loads: reasonCode: #loadDeprecation ] ifFalse: [ self recordValidationWarning: 'Warning while loading version ' , arg1 versionString printString , ' in ' , self configurationClass name asString , ' ' , arg3 description versionString: arg1 versionString callSite: #validateCleanLoadAndTestsForVersion:loads: reasonCode: #loadWarning.                    Smalltalk at: #UndeclaredVariableWarning ifPresent: [:arg4 |  (arg3 isKindOf: arg4) ifTrue: [ arg3 resume: true ] ].                    arg3 resume ] ] ].  tmp1 ifTrue: [ tmp2 := [ self validateVersionTests: arg1 ] on: Deprecation do: [:arg3 |  | tmp3 |              tmp3 := 'Deprecation warning while running tests for version ' , arg1 versionString printString , ' in ' , self configurationClass name asString , ' ' , arg3 description.              self recordValidationCriticalWarning: tmp3 versionString: arg1 versionString callSite: #validateCleanLoadAndTestsForVersion:loads: reasonCode: #testDeprecation.              arg3 return: false ].        tmp2 ifTrue: [ MetacelloCleanLoadAndTestsNotification signal: arg1 ] ifFalse: [ MetacelloCleanLoadNotification signal: arg1 ] ]versionOfXXX: arg1  < version: '0.9.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>versionOfXXX:'.        arg1 author: 'dkh'.        arg1 timestamp: '5/4/2012 14:16'.        arg1 baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]spotterForGroupsFor: arg1  < spotterOrder: 2>  arg1 listProcessor     title: 'Groups';     allCandidates: [ self groups ];     itemName: [:arg2 |  arg2 name ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: truerepositories  ^repositoriesgroupForVersion: arg1 overrides: arg2  | tmp1 |  tmp1 := self project groupSpec     name: arg1;     includes: arg2;     yourself.  self root packages add: tmp1version41Symbolic: arg1  < version: '4.1'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #release.        arg1           package: 'GoferBeau' with: 'GoferBeau-dkh.25';           package: 'GoferFaux' with: 'GoferFaux-tg.31';           yourself ]ensureSpecLoader  ^selfconfiguration092Issue181: arg1  < version: '0.9.2'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration092Issue181:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue181SHA , '/repository' ];           import: 'External' ]project  | tmp1 tmp2 |  tmp1 := MetacelloVersionConstructor on: self.  tmp2 := tmp1 project.  tmp2 loader: (tmp2 loaderClass new           shouldDisablePackageCache: true;           yourself).  tmp2 loadType: #atomic.  ^tmp2postCopy  super postCopy.  mutable := nillesson12  actionLabel  ^'Recording 'projectPackage  self subclassResponsibilityloadDirectives: arg1  loadDirectives := arg1stableVersionD: arg1  < symbolicVersion: #stable>  arg1 for: #common version: '4.2'.  arg1 for: #'platformVersion1.x' version: '4.0'.  arg1 for: #'platformVersion1.0.x' version: '4.1'.  arg1 for: #'platformVersion1.1.x' version: '4.2'.  arg1 for: #'platformVersion1.2.x' version: '4.3'onLockBreak: arg1  self onLock: [:arg2 :arg3 :arg4 |  (arg1 includes: arg3 baseName) ifTrue: [ arg2 break ] ifFalse: [ arg2 honor ] ]execute: arg1  arg1 do: [:arg2 |  arg2 value ifNil: [ self perform: arg2 key ] ifNotNil: [ self perform: arg2 key withArguments: arg2 value ] ].  projectSpecGenerator := self projectSpecGenerator.  projectSpecGenerator target execute: [:arg3 |  | tmp1 |        tmp1 := MetacelloScriptEngine new           options: self options copy;           projectSpec: arg3;           yourself.        tmp1 perform: actionArg key withArguments: actionArg value.        tmp1 root ifNotNil: [:arg4 |  self roots add: arg4 ] ] against: self.  ^(self singleRoot and: [ self roots size == 1 ]) ifTrue: [ self roots first ] ifFalse: [ self roots ]validate  self isValid ifFalse: [ self error: 'Invalid project registration' ]preReleaseVersion  preReleaseVersion ifNil: [ preReleaseVersion := #() ].  ^preReleaseVersionsetUpConfigurationOfUmbrellaB  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfUmbrellaB-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'version51Umbrella:' category: 'cat' timeStamp: '' source: self version51MethodSourceUmbrella)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())prepareForMethodUpdate: arg1 sourceVersion: arg2 forceUpdate: arg3 generating: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  self deprecated: 'see MetacelloToolBox for replacement methods'.  self configuration: arg1.  tmp2 := Dictionary new.  tmp3 := Dictionary new.  tmp1 := self extractAllVersionPragmas.  tmp7 := tmp1 at: arg2 ifAbsent: [ ^self ].  tmp7 do: [:arg5 |  | tmp9 tmp10 |        tmp9 := Dictionary new.        self evaluatePragma: arg5.        self attributeMap keysAndValuesDo: [:arg6 :arg7 |  tmp10 := self project versionSpec.              tmp10 versionString: arg2.              tmp9 at: arg6 put: tmp10.              arg7 do: [:arg8 |  self with: tmp10 during: arg8 ] ].        tmp2 at: arg5 selector put: {tmp9 .               self attributeOrder .               nil}.        tmp3 at: arg5 selector put: arg5.        self reset ].  tmp2 keysAndValuesDo: [:arg9 :arg10 |  tmp5 := Dictionary new.        tmp8 := Dictionary new.        arg10 at: 3 put: tmp5.        tmp6 := arg1 project attributes reverse.        tmp6 do: [:arg6 |  | tmp11 |              (tmp11 := (arg10 at: 1) at: arg6 ifAbsent: [  ]) ~~ nil ifTrue: [ tmp4 := arg3 ifTrue: [ tmp11 forceUpdatedPackageSpecs ] ifFalse: [ tmp11 updatedPackageSpecs ].                    tmp4 associations do: [:arg11 |  | tmp12 |                          (tmp12 := tmp8 at: arg11 key ifAbsent: [  ]) == nil ifTrue: [ arg11 value == #uptodate ifTrue: [ tmp8 at: arg11 key put: #uptodate ] ifFalse: [ tmp8 at: arg11 key put: arg11 value file ] ] ifFalse: [ (tmp12 == #uptodate or: [ arg11 value == #uptodate or: [ tmp12 = arg11 value file ] ]) ifTrue: [ tmp4 removeKey: arg11 key ] ] ].                    tmp5 at: arg6 put: tmp4 ] ].        tmp5 valuesDo: [:arg12 |  arg12 associations do: [:arg11 |  arg11 value == #uptodate ifTrue: [ arg12 removeKey: arg11 key ] ] ].        1 to: tmp6 size do: [:arg13 |  | tmp13 tmp14 |              arg6 := tmp6 at: arg13.              ((arg12 := tmp5 at: arg6 ifAbsent: [  ]) ~~ nil and: [ arg12 keys size > 0 ]) ifTrue: [ arg13 + 1 to: tmp6 size do: [:arg14 |  arg12 keysDo: [:arg15 |  | tmp15 |                                (tmp15 := tmp5 at: (tmp6 at: arg14) ifAbsent: [  ]) ~~ nil ifTrue: [ tmp15 removeKey: arg15 ifAbsent: [  ] ] ] ] ] ].        tmp5 keys do: [:arg15 |  | tmp14 |              arg12 := tmp5 at: arg15.              arg12 isEmpty ifTrue: [ tmp5 removeKey: arg15 ] ].        arg4 value: arg9 value: tmp3 value: arg10 value: tmp5 ]lock  ^self execute: #lock args: #()primeRegisterLoadedProjectSpec: arg1  MetacelloProjectRegistration registrationForProjectSpec: arg1 ifAbsent: [:arg2 |  arg2           loadedInImage: true;           registerProject ] ifPresent: [:arg3 :arg2 |  arg3 copyOnWrite: [:arg4 |  arg4 loadedInImage: true.              arg3 locked ifFalse: [ arg4 merge: arg2 ] ] ]monticelloRepository  ^MetacelloMonticelloResource current monticelloRepositoryprojectPackage: arg1 constructor: arg2  arg2 projectPackageForProject: arg1getClassName  ^classNameremoveMember  ^MetacelloRemoveMemberSpec for: self projectname: arg1 constructor: arg2  arg2 nameForProject: arg1testSubCommand  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: tmp1 subCommand equals: 'install'.  tmp1 := self command: #('foo' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self should: [ tmp1 subCommand ] raise: Exitcompiler  ^Smalltalk compilerClasstestVersion03  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '1.0.0.1'.  tmp2 := self versionClass fromString: '1.0.0'.  self assert: tmp1 > tmp2packagesSpec  ^self packagesSpecClass for: selfversion: arg1  version := arg1repositoryVersionString  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp5 := self directory fullName.  tmp7 := self class cacheDirectoryFor: self projectPath.  tmp8 := MCFileTreeFileUtils current directoryFromPath: self projectVersion relativeTo: tmp7.  tmp6 := tmp8 fullName.  (tmp5 beginsWith: tmp6) ifFalse: [ ^self projectVersion ].  tmp4 := tmp5 copyFrom: tmp6 size + 2 to: tmp5 size.  tmp3 := tmp4 findTokens: '/'.  tmp2 := tmp3 at: 1.  tmp1 := tmp2 findTokens: '-'.  ^tmp1 lastbaseline: arg1  self root baseline: arg1 constructor: selfrecursiveDelete: arg1  ^arg1 deleteAllensureLocalRepository  localRepository ifNotNil: [ ^self ].  self resolveLocalRespositoryversionString  ^self versionSpec versionStringcustomProjectAttributes  ^#()tearDownPackageList  ^#()baseline40ProjectFoe: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 loads: '1';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]loadPackageDirective: arg1 gofer: arg2  | tmp1 |  tmp1 := arg1 spec.  MetacelloPlatform current do: [ | tmp2 tmp3 tmp4 tmp5 |        arg2 disablePackageCache.        tmp5 := self resolvePackageSpec: tmp1 gofer: arg2.        tmp5 ifNil: [ ^self ].        tmp2 := [ tmp3 := MetacelloGoferLoad on: arg2.        tmp3 addResolved: tmp5.        tmp3 execute.        MetacelloPlatform current clearCurrentVersionCache ].        (tmp4 := tmp1 answers) notEmpty ifTrue: [ tmp2 valueSupplyingMetacelloAnswers: tmp4 ] ifFalse: [ tmp2 value ].        tmp5 workingCopy repositoryGroup addRepository: arg1 repository.        MetacelloNotification signal: 'Loaded -> ' , tmp5 name , ' --- ' , arg1 repository repositoryDescription , ' --- ' , tmp5 repository description ] displaying: 'Loading ' , tmp1 fileoperator  operator == nil ifTrue: [ ^#>= ].  ^operator~> arg1  arg1 size == 1 ifTrue: [ ^false ].  ^self >= arg1 and: [ self < arg1 approximateBase ]versionSpec  ^self versionSpecClass for: selfconstructClassName  ^'ConfigurationOf' , self nameexplicitLoadPackageSpecs: arg1 repositories: arg2  | tmp1 |  tmp1 := self loaderPolicy pushExplicitLoadDirectivesDuring: [ super linearLoadPackageSpecs: arg1 repositories: arg2 ] for: self.  tmp1 explicitLoadWithPolicy: self loaderPolicyexternalRepository  ^externalRepositorymergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #repositories put: repositories.  ^tmp1methodUpdateSelector  ^#remove:baseline35MethodSourceFan  ^(self class sourceCodeAt: #baseline35Fan:) asStringoverriddenMethods  ^#()version  ^(self configurationProjectSpecIfAbsent: [ ^MetacelloMCBaselineProject singletonVersionName ]) versionStringtestMergePackageB  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp1 merge: {(self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           includes: 'AndIncludedPackage';           answers: #(#('xpostload' 'xpostload answer'));           file: 'Package-dkh.2';           yourself)}.  tmp2 := tmp1 packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: tmp2 name equals: 'Package'.  self assert: tmp2 requires equals: #('AnotherPackage' 'AndAnotherPackage').  self assert: tmp2 includes equals: #('IncludedPackage' 'AndIncludedPackage').  self assert: tmp2 answers equals: #(#('preload' 'preload answer') #('postload' 'postload answer') #('xpostload' 'xpostload answer')).  self assert: tmp2 file equals: 'Package-dkh.2'.  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoItlatestVersionMatching: arg1 excludedBlessings: arg2  ^nilsetTimestampWithString: arg1  self root timestamp: arg1incrementNormalVersionAt: arg1  | tmp1 tmp2 |  tmp2 := self normalVersion.  tmp1 := tmp2 at: arg1.  tmp2 at: arg1 put: tmp1 + 1isLoadedMatchConstraints  self isPartiallyCurrent isLoadedMatchConstraints: [:arg1 |  ^true ].  ^falsetestProjectReferenceSpec  | tmp1 tmp2 |  tmp1 := self projectReferenceSpec     name: 'Project';     projectReference: (tmp2 := self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           yourself);     yourself.  self assert: tmp1 name equals: 'Project'.  self assert: tmp1 projectName equals: 'Project'.  self assert: tmp1 projectReference identicalTo: tmp2.  self should: [ tmp1 includes: #() ] raise: Error.  self should: [ tmp1 requires: #() ] raise: Error.  self should: [ tmp1 answers: #() ] raise: Error.  tmp1 projectDo: [:arg1 |  self assert: tmp1 identicalTo: arg1 ] packageDo: [:arg2 |  self assert: false ] groupDo: [:arg2 |  self assert: false ]configurationProjectSpec  ^configurationProjectSpecmergeMember  ^MetacelloMergeMemberSpec for: self projectproject  ^project ifNil: [ self class ensureMetacello.        project := self projectClass new projectAttributes: self customProjectAttributes.        project versionNumberClass: self versionNumberClass.        project class versionConstructorClass on: self project: project.        project loadType: #linear.        project ]projectSpecSelectBlock  ^[:arg1 |  arg1 ifNil: [ false ] ifNotNil: [ MetacelloProjectRegistration registrationForProjectSpec: arg1 ifAbsent: [ false ] ifPresent: [:arg2 :arg3 |  arg2 loadedInImage ] ] ]resolvePackageSpec: arg1 cachedGofer: arg2  | tmp1 tmp2 |  tmp1 := arg1 goferLoaderReference.  (tmp2 := tmp1 resolveAllWith: arg2) isEmpty ifTrue: [ ^nil ].  ^tmp2 last asMetacelloCachingResolvedReferencesetUpMonticelloRepository  monticelloRepository := MCDictionaryRepository newhasOverride  ^self overrideProjectSpec ~~ nilresolveToAllPackagesIn: arg1 visited: arg2  | tmp1 |  tmp1 := Dictionary new.  self resolveToAllPackagesIn: arg1 into: tmp1 visited: arg2.  ^tmp1 values asOrderedCollectionworkingCopy  workingCopy == nil ifTrue: [ workingCopy := self findWorkingCopy ].  ^workingCopymodifyBaselineOf  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := project configuration class.  tmp4 := tmp1 new.  tmp2 := MetacelloToolBoxBaselineConstructor new     configuration: project configuration class new;     yourself.  tmp3 := tmp2 extractBaselinePragmaFor: tmp1.  tmp2 extractMethodSectionsForClass: tmp1.  methodSpec := MetacelloBaselineOfMethodSpec new     project: project;     selector: (MetacelloPlatform current selectorForPragma: tmp3);     category: (tmp1 whichCategoryIncludesSelector: (MetacelloPlatform current selectorForPragma: tmp3));     yourself.  tmp2 methodSections do: [:arg1 |  self methodSpec methodSections add: arg1 ]lookupBaselineSpec  baselineProjectSpec ifNotNil: [:arg1 |  ^arg1 ].  ^configurationProjectSpecversion10Issue59: arg1  < version: '1.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>version10Issue59:'.        arg1 author: 'dkh'.        arg1 timestamp: '6/18/2012 14:34'.        arg1 baseline: 'Issue32' ].  arg1 for: #custom do: [ arg1 baseline: 'Issue32' with: [ arg1 repository: 'dictionary://Metacello_External_Test_Repository' ] ]updateForSpawnMethod: arg1  | tmp1 tmp2 |  tmp1 := name.  tmp2 := file.  tmp2 == nil ifTrue: [ {answers .         requires .         includes .         repositories .         preLoadDoIt .         postLoadDoIt} detect: [:arg2 |  arg2 ~~ nil ] ifNone: [ tmp2 := name ] ].  super updateForSpawnMethod: arg1.  file := repositories := goferPackage := preLoadDoIt := postLoadDoIt := nil.  name := tmp1.  file := tmp2.  ^file == nilversion112ProjectToolBox: arg1  < version: '1.1.2-baseline'>  arg1 for: #common do: [ arg1 package: 'Example-Core'.        arg1 for: #nested do: [ arg1                 package: 'Example-Base';                 package: 'Example-Test-Nested' ] ].  arg1 for: #extra do: [ arg1 package: 'Example-Test' ]isError  ^falseversion40SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version40Symbolic:) asStringversionClass  ^MetacelloVersiontestSemanticVersioningSubsetCompliance  self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0')printOn: arg1 indent: arg2  super printOn: arg1 indent: arg2.  self printLoadDirectivesOn: arg1 indent: arg2executeBlock: arg1 do: arg2  (self projectSpecsFromRepositoryArg select: arg1) do: [:arg3 |  arg2 value: (self applyArgsToProjectSpec: arg3 copy) ]isEmpty  ^self dataMap isEmptygetFile  ^nilisResumable  ^truepostLoadDoIt: arg1  self root postLoadDoIt: arg1 constructor: selfrepository: arg1 constructor: arg2  arg2 repositoryForProject: arg1repositoryForPackage: arg1  self repositoryForSpec: arg1load  ^self subclassResponsibilitygitCommitShaFor: arg1  ^nilprojectSpecCreationBlock  ^[:arg1 |  {(MetacelloMCProject new configurationOfProjectSpec name: arg1)} ]defaultBlessing  ^#releasesetUpConfigurationOfProjectIssue119dkh5: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.5'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion40Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version40Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version41Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version41Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version42Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version42Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version43Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version43Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version44Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version44Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4baselineIssue32: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>baselineIssue32:'.        arg1           package: 'External-CoreX';           package: 'External-TestsX' with: [ arg1 requires: 'External-CoreX' ];           preLoadDoIt: #preloadDoIt;           postLoadDoIt: #postloadDoIt;           yourself.        arg1           group: 'Core' with: #('External-CoreX');           group: 'default' with: #('Core');           group: 'Tests' with: #('External-TestsX');           yourself ]setDefaultsAndValidate: arg1  | tmp1 |  tmp1 := arg1 validateForScriptLoad: self withDefaultVersionString: self defaultVersionString withDefaultRepositoryDecription: self defaultRepositoryDescription.  tmp1 isEmpty ifTrue: [ ^self ].  (MetacelloValidationFailure issues: tmp1 message: 'Project spec validation failure') signalcleanupProtocols: arg1  doItBlock: arg1  arg1 == nil ifTrue: [ ^nil ].  arg1 numArgs = 0 ifTrue: [ ^[ self project configuration perform: arg1 ] ].  arg1 numArgs = 1 ifTrue: [ ^[:arg2 |  self project configuration perform: arg1 with: arg2 ] ].  arg1 numArgs = 2 ifTrue: [ ^[:arg2 :arg3 |  self project configuration perform: arg1 with: arg2 with: arg3 ] ].  ^nilconfigPackagesSpecMethodOn: arg1 indent: arg2  | tmp1 tmp2 tmp3 |  tmp1 := OrderedCollection new.  tmp2 := OrderedCollection new.  tmp3 := OrderedCollection new.  self packagesSpec list do: [:arg3 |  arg3 spec projectDo: [:arg4 |  arg3 spec name ~~ nil ifTrue: [ tmp1 add: arg3 ] ] packageDo: [:arg5 |  arg3 spec name ~~ nil ifTrue: [ tmp2 add: arg3 ] ] groupDo: [:arg6 |  arg3 spec name ~~ nil ifTrue: [ tmp3 add: arg3 ] ] ].  tmp1 isEmpty not ifTrue: [ arg1           tab: arg2;           nextPutAll: 'spec '.        tmp1 size > 1 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ].        1 to: tmp1 size do: [:arg7 |  (tmp1 at: arg7) configMethodCascadeOn: arg1 last: arg7 == tmp1 size indent: arg2 + 1.              arg7 ~= tmp1 size ifTrue: [ arg1 tab: arg2 + 1 ] ] ].  tmp2 isEmpty not ifTrue: [ tmp1 isEmpty not ifTrue: [ arg1 cr ].        arg1           tab: arg2;           nextPutAll: 'spec '.        tmp2 size > 1 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ].        1 to: tmp2 size do: [:arg7 |  (tmp2 at: arg7) configMethodCascadeOn: arg1 last: arg7 == tmp2 size indent: arg2 + 1.              arg7 ~= tmp2 size ifTrue: [ arg1 tab: arg2 + 1 ] ] ].  tmp3 isEmpty not ifTrue: [ tmp1 isEmpty not | tmp2 isEmpty not ifTrue: [ arg1 cr ].        arg1           tab: arg2;           nextPutAll: 'spec '.        tmp3 size > 1 ifTrue: [ arg1                 cr;                 tab: arg2 + 1 ].        1 to: tmp3 size do: [:arg7 |  (tmp3 at: arg7) configMethodCascadeOn: arg1 last: arg7 == tmp3 size indent: arg2 + 1.              arg7 ~= tmp3 size ifTrue: [ arg1 tab: arg2 + 1 ] ] ]baseline60MethodSourceFoo  ^(self class sourceCodeAt: #baseline60Foo:) asStringpackageSpecsInLoadOrder  ^self versionSpec packageSpecsInLoadOrderForMap: packagesproject: arg1  self root project: arg1 constructor: selfensureSpecLoader  ^(MetacelloEnsureFetchingMCSpecLoader on: self spec)     shouldDisablePackageCache: self shouldDisablePackageCache;     loaderPolicy: self loaderPolicy;     yourselflock  | tmp1 |  MetacelloProjectRegistration copyRegistryRestoreOnErrorWhile: [ self setDefaultsAndValidate: self projectSpec copy.        tmp1 := self projectSpec.        MetacelloProjectRegistration registrationForProjectSpec: tmp1 ifAbsent: [:arg1 |  arg1                 locked: true;                 registerProject ] ifPresent: [:arg2 :arg1 |  arg2 copyOnWrite: [:arg3 |  arg3 locked: true.                    tmp1 copyForRegistration: arg3 onWrite: [:arg4 |  arg4 ifNil: [ arg3 merge: arg1 ] ifNotNil: [ arg4 mergeScriptRepository: tmp1.                                tmp1 := arg4 ] ] ] ].        self root: tmp1 ]shouldBeMutable  self isMutable ifTrue: [ ^self ].  self error: 'Not allowed to modify an immutable object'validateProjectLoad  | tmp1 tmp2 tmp3 tmp4 tmp5 |  (tmp1 := self validateProject select: [:arg1 |  arg1 isError ]) notEmpty ifTrue: [ ^tmp1 ].  tmp2 := self configurationClass project.  tmp5 := tmp1.  tmp3 := tmp2 versions select: [:arg2 |  validationReport := nil.        arg2 blessing ~~ #broken and: [ arg2 blessing ~~ #baseline and: [ (tmp1 := (self validateProject: tmp2 version: arg2 versionString) select: [:arg1 |  arg1 isCritical ]) isEmpty ] ] ].  validationReport := tmp5.  tmp3 isEmpty ifTrue: [ self recordValidationCriticalWarning: 'No non #baseline versions  available  in ' , self configurationClass name asString callSite: #validateProjectLoad reasonCode: #noLoadableVersions.        ^self validationReport ].  (tmp4 := tmp2 currentVersion) ~~ nil ifTrue: [ | tmp6 |        tmp6 := tmp3 indexOf: tmp4.        tmp3 := tmp3 copyFrom: tmp6 to: tmp3 size ].  tmp3 do: [:arg2 |  self validateCleanLoadAndTestsForVersion: arg2 loads: #('ALL') ].  ^self validationReportbaseline62MethodSourceProjectIssue86  ^(self class sourceCodeAt: #baseline62ProjectIssue86:) asStringuseDetermineVersionForLoad: arg1  useDetermineVersionForLoad := arg1testClearCache  MetacelloPlatform current stackCacheFor: #cached at: #key doing: [:arg1 |  | tmp1 |        arg1 at: #x put: 1.        self assert: (arg1 at: #x ifAbsent: [  ]) identicalTo: 1.        MetacelloClearStackCacheNotification signal.        self assert: (arg1 at: #x ifAbsent: [  ]) identicalTo: nil ]baseline30MethodSourceFoo  ^(self class sourceCodeAt: #baseline30Foo:) asStringsetUpBaselineGithubReferenceXII  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefXII-dkh.1'.  tmp2 := #BaselineOfGithubRefXII.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineGithubReferenceVI:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceVI:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4getName  ^nameverifyPackageNotLoaded: arg1  self assert: (MCWorkingCopy allManagers detect: [:arg2 |  arg2 packageName = arg1 ] ifNone: [  ]) identicalTo: nilroot: arg1  root := arg1includes: arg1  self root includes: arg1 constructor: selfproject: arg1 with: arg2  self root project: arg1 with: arg2 constructor: selfsetFor: arg1 do: arg2  arg1 asMetacelloAttributeList do: [:arg3 |  | tmp1 |        tmp1 := self attributeMap at: arg3 ifAbsent: [ self attributeMap at: arg3 put: (tmp1 := OrderedCollection new) ].        tmp1 add: arg2.        self addAttribute: arg3 ]versionStatus  versionStatus == nil ifTrue: [ versionStatus := self computeVersionStatus ].  ^versionStatusconfigMethodOn: arg1 indent: arg2  arg1     tab: arg2;     nextPutAll: 'spec ';     cr;     tab: arg2 + 1;     nextPutAll: 'name: ' , self name printString;     nextPut: $;;     cr;     tab: arg2 + 1;     nextPutAll: 'projectReference: ';     nextPut: $[;     cr.  arg1     tab: arg2 + 2;     nextPutAll: 'spec'.  self projectReference ifNotNil: [ self projectReference configMethodBodyOn: arg1 indent: arg2 + 2 ].  arg1 nextPutAll: ' ].'fetch  self fetchUsing: self loadersetUpConfigurationOfProjectIssue154  | tmp1 |  tmp1 := self setUpConfigurationOfMetacelloExampledkh1.  tmp1 := self setUpConfigurationOfProjectIssue154dkh1version51Foo: arg1  < version: '5.1'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #release.        arg1           package: 'GoferUmbrella' with: 'GoferUmbrella-lr.5';           yourself ]nameComponentsFrom: arg1  ^self class nameComponentsFrom: arg1constructor  | tmp1 |  tmp1 := MetacelloToolBoxConstructor new.  tmp1 configuration: project configuration class new.  ^tmp1compareRelativeCurrentVersion: arg1 targetVersionStatus: arg2 using: arg3  ^self compareCurrentVersion: arg1 targetVersionStatus: arg2 using: arg3configurationClass  ^self subclassResponsibilitysetUpBaselineGithubReferenceVII  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefVII-dkh.1'.  tmp2 := #BaselineOfGithubRefVII.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineGithubReferenceIV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceIV:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4version50MethodSourceUmbrella  ^(self class sourceCodeAt: #version50Umbrella:) asStringtestAddPackageC  | tmp1 |  tmp1 := self packagesSpec.  tmp1 add: {'Platform' .         'Base' .         'Tests'}.  tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  tmp1 packageNamed: 'Base' ifAbsent: [ self assert: false ].  tmp1 packageNamed: 'Tests' ifAbsent: [ self assert: false ]versionInfoMap  versionInfoMap == nil ifTrue: [ versionInfoMap := Dictionary new ].  ^versionInfoMapsetPreLoadDoIt: arg1  self shouldBeMutable.  preLoadDoIt := arg1loadDirectives  loadDirectives == nil ifTrue: [ loadDirectives := OrderedCollection new ].  ^loadDirectivescurrentlyLoadedExtensionClassesInVersion  | tmp1 |  tmp1 := Dictionary new.  self projectDo: [:arg1 |   ] packageDo: [:arg2 |  ([ arg2 workingCopy ] on: Error do: [:arg3 |  arg3 return: nil ]) ifNotNil: [:arg4 |  | tmp2 |              tmp2 := MetacelloPlatform current packageInfoFor: arg4.              tmp2 extendedClasses do: [:arg5 |  tmp1 at: arg5 put: (tmp2 extensionCategoriesForClass: arg5) ] ] ] groupDo: [:arg1 |   ].  ^tmp1configShortCutMethodBodyOn: arg1 member: arg2 indent: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := file ~~ nil.  tmp2 := self repositorySpecs size > 0.  tmp3 := self getPreLoadDoIt ~~ nil.  tmp4 := self getPostLoadDoIt ~~ nil.  tmp5 := (self requires isEmpty and: [ self includes isEmpty and: [ self answers isEmpty ] ]) not.  tmp2 | tmp3 | tmp4 | tmp5 ifTrue: [ arg1           nextPutAll: 'package: ' , self name printString , ' ';           nextPutAll: arg2 methodUpdateSelector asString , ' [';           cr.        arg1           tab: arg3 + 1;           nextPutAll: 'spec '.        self configMethodBodyOn: arg1 hasName: false indent: arg3 + 2.        arg1 nextPutAll: ' ]'.        ^self ].  arg1 nextPutAll: 'package: ' , self name printString.  tmp1 ifTrue: [ arg1 nextPutAll: ' with: ' , file printString ]registerPackageNamed: arg1  ^RPackageSet named: arg1merge: arg1  arg1 mergeIntoMetacelloRepositories: selfbaseline40ProjectFee: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        arg1           package: 'GeauxFaux' with: 'GeauxFaux-tg.32';           package: 'GeauxBeau' with: 'GeauxBeau-dkh.55';           yourself ]testStandardMatch  self assert: ((self versionClass fromString: '1.0.0+alpha5.0') match: '1.0.0+alpha#.0').  self assert: ((self versionClass fromString: '1.1.1') match: '*.*.*').  self deny: ((self versionClass fromString: '1.1.1') match: '*.*').  self assert: ((self versionClass fromString: '1.1.0') match: '1.1.*').  self assert: ((self versionClass fromString: '1.1.0') match: '1.#.*').  self deny: ((self versionClass fromString: '1.10.0+build.0') match: '1.#.*').  self assert: ((self versionClass fromString: '1.0.0-alpha5.0') match: '1.0.0-alpha#.0').  self assert: ((self versionClass fromString: '1.0.0-alpha5+build5.0') match: '1.0.0-alpha5+build#.0').  self deny: ((self versionClass fromString: '1.0.0-alpha10.0') match: '1.0.0-alpha#.0')hasRepository  ^self repositorySpecs notEmptypostLoadDoIt: arg1  arg1 setPostLoadDoItInMetacelloSpec: selfmergeRepositoriesSpec: arg1  self repositories: (self getRepositories == nil ifTrue: [ arg1 ] ifFalse: [ self repositories mergeSpec: arg1 ])getTimestamp  ^timestamprecordValidationError: arg1 callSite: arg2 reasonCode: arg3  ^self recordValidationError: arg1 versionString: nil callSite: arg2 reasonCode: arg3addMember: arg1  self list add: arg1.  self clearMemberMapconfigurationOfProjectSpecClass  ^MetacelloMCConfigurationOfProjectSpecprintOn: arg1  | tmp1 tmp2 |  (#(structural broken) includes: self blessing) not ifTrue: [ (tmp2 := self versionStatus) == #somethingLoaded ifTrue: [ arg1 nextPutAll: '<>' ].        tmp2 == #loadedMatchConstraints ifTrue: [ arg1 nextPutAll: '>=' ].        tmp2 == #loadedToSpec ifTrue: [ arg1 nextPut: $~ ] ].  self versionNumber printOn: arg1.  self basicSpec ~~ nil ifTrue: [ (tmp1 := self projectLabel) isEmpty ifFalse: [ arg1 nextPutAll: ' [' , tmp1 , ']' ] ]versionOfExternal090: arg1  < version: '0.9.0'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>versionOfExternal090:'.        arg1 repository: 'dictionary://Metacello_Configuration_Test_Repository'.        arg1           package: 'External-Core' with: 'External-Core-dkh.1';           yourself ]version20Issue171: arg1  < version: '2.0' imports: #('2.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: '2.0'.        arg1 package: 'GeauxFoo' with: 'GeauxFoo-lr.1' ]monticelloRepository  ^MetacelloMonticelloResource current monticelloRepositoryversionForScriptEngine: arg1  | tmp1 |  tmp1 := self projectClass ifNil: [ self project ] ifNotNil: [ self projectClassProject ].  ^((tmp1 projectForScriptEngine: arg1) version: self versionString)     silently: arg1 silently;     ignoreImage: arg1 ignoreImage;     cacheRepository: arg1 cacheRepository;     repositoryOverrides: arg1 repositoryOverridesexcludeFromLatestVersion  ^#(structural development broken baseline)version44Issue119: arg1  < version: '4.4' imports: #('4.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 project: 'Foo' with: 2.0.        arg1 package: 'GoferBar ' with: 'GoferBar-jf.1' ]testLocation  | tmp1 |  tmp1 := MCGitlabRepository location: 'gitlab://pharo-project/pharo:master/src'.  self     assert: tmp1 hostname equals: 'gitlab.com';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assert: tmp1 repoPath equals: 'src';     assert: tmp1 sshPort isNil.  tmp1 := MCGitlabRepository location: 'gitlab://pharo-project/pharo:master'.  self     assert: tmp1 hostname equals: 'gitlab.com';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assertEmpty: tmp1 repoPath;     assert: tmp1 sshPort isNil.  tmp1 := MCGitlabRepository location: 'gitlab://pharo-project/pharo'.  self     assert: tmp1 hostname equals: 'gitlab.com';     assert: tmp1 projectPath equals: 'pharo-project/pharo';     assert: tmp1 projectVersion equals: 'master';     assertEmpty: tmp1 repoPath;     assert: tmp1 sshPort isNilsetTimestampInMetacelloVersion: arg1  arg1 setTimestamp: selfdescription: arg1  self root description: arg1 constructor: selfgtInspectorChildren  ^self loadDirectivesversion121ProjectToolBox: arg1  < version: '1.2.1-baseline'>  arg1 for: #common do: [ arg1 blessing: #testBlessing.        arg1 repository: 'http://www.example.com/vor'.        arg1           package: 'Example-Core' with: [ arg1                 includes: #('Example-AddOn');                 file: 'Example-Core-anon.1';                 repository: 'http://www.example.com/or';                 preLoadDoIt: #preloadForCore;                 postLoadDoIt: #postloadForCore:package: ];           package: 'Example-AddOn' with: [ arg1 requires: #('Example-Core') ];           package: 'Example-Tests' with: [ arg1 requires: #('Example-AddOn') ] ]attributes  ^(OrderedCollection with: #common)     addAll: self platformAttributes;     yourselfgitBranchNameFor: arg1  ^nilrepoPath  repoPath ifNil: [ repoPath := '' ].  ^repoPathbaselineProjectSpecs  | tmp1 |  tmp1 := OrderedCollection new.  self baselineRegistry keysAndValuesDo: [:arg1 :arg2 |  tmp1 add: (self projectSpecForClassNamed: arg1 ifAbsent: [ self error: 'not expected' ]) ].  ^tmp1 asArrayusername  username == nil ifTrue: [ username := '' ].  ^usernameproject  ^self projectWith: #()isLoadedToSpec: arg1  | tmp1 |  tmp1 := #loadedToSpec.  (self evaluateStatus: #(#allLoadedToSpec #loadedToSpec)) ifTrue: [ aPackageIsLoaded & aProjectIsLoaded ifTrue: [ (aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not and: [ aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not ]) ifTrue: [ arg1 value: tmp1 ] ] ifFalse: [ aPackageIsLoaded ifTrue: [ aLoadedPackageIsExact & aLoadedPackageIsCurrent not & aLoadedPackageIsNotCurrent not ifTrue: [ arg1 value: tmp1 ] ] ifFalse: [ hasNoPackage & aLoadedProjectIsExact & aLoadedProjectIsCurrent not & aLoadedProjectIsNotCurrent not ifTrue: [ arg1 value: tmp1 ] ] ] ]add: arg1  self loadDirectives add: arg1loadWithPolicy: arg1  | tmp1 |  tmp1 := MetacelloGofer new.  tmp1 disablePackageCache.  tmp1 repository: arg1 cacheRepository.  self loadUsing: self gofer: tmp1debug  debug == nil ifTrue: [ debug := #() ].  ^debugconfigSpawnMethodOn: arg1 indent: arg2  super configSpawnMethodOn: arg1 indent: arg2.  self configPackagesSpecMethodOn: arg1 indent: arg2testAlphaNumericVersion2  self assert: (self versionClass fromString: '2.9.0-alpha.2') < (self versionClass fromString: '2.9.0-alpha.3')baseline40ProjectFie: arg1  < version: '4.0'>  arg1 for: #common do: [ arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Feaux' with: [ arg1                 className: 'MetacelloTestConfigurationOfFeaux';                 versionString: '4.0';                 file: 'MetacelloTestConfigurationOfFeaux';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]registrationsCompareEqual: arg1  ^self className = arg1 className and: [ self versionString = arg1 versionString and: [ self operator == arg1 operator ] ]packagesForSpecNamed: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := self spec packageNamed: arg1 ifAbsent: arg2.  ^tmp1 resolveToPackagesIn: self spec visited: MetacelloVisitedPackages newversion12: arg1  < version: '1.2' imports: #('1.2-baseline')>  arg1 for: #common do: [ arg1 blessing: #beta.        arg1           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1' ]commonDefaultSymbolicVersionResolverBlock  ^self defaultSymbolicVersionResolverBlock: (ConfigurationOf new project: self project)versionNumber: arg1  versionNumber := arg1isLoadedToSpec  self isPartiallyCurrent isLoadedToSpec: [:arg1 |  ^true ].  ^falsesetUpConfigurationOfProjectIssue136  | tmp1 |  tmp1 := self setUpConfigurationOfProjectIssue136dkh1.  tmp1 := self setUpConfigurationOfProjectIssue136dkh2: {tmp1}description  ^'Could not resolve: ' , packageSpec name , ' [' , packageSpec file , ']' , ' in' , self repositoryString , (repositoryError == nil ifTrue: [ '' ] ifFalse: [ ' ERROR: ' , repositoryError description printString ])conflictOf10: arg1  < version: '1.0.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>conflictOf10:'.        arg1 author: 'dkh'.        arg1 timestamp: '6/1/2012 14:46' ].  arg1 for: #custom do: [ arg1 configuration: 'ExternalX' with: [ arg1                 version: '0.9.1';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]testInvalidSpecialMatch  self should: [ (self versionClass fromString: '1.1.1') match: '?.?.?' ] raise: Errorwiresong: arg1  self repository: 'http://source.wiresong.ca/' , arg1loadUsing: arg1 gofer: arg2  arg1 loadPackageDirective: self gofer: arg2lesson07  ^Lesson title: 'Lesson 7' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #baseline07:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version07:."For version 0.7, we are ceating a baseline version specification which is expected to be usedacross several versions and the version specification which is restricted to the file versions.In method #baseline07: the structure of version ''0.7-baseline'' is specified. The repository is listed, the packages are listed and the required packages are defined. We''ll cover the #blessing:in a later lesson.In method #version07: the file versions are specified. You will note that the pragma as an #imports: component that specifies the list of versions that this version (version ''0.7'') is based upon. In fact, if you print the spec for ''0.7-baseline'' and then print the spec for ''0.7'' you can see that ''0.7'' is a composition of both versions:"   (MetacelloTutorialConfig project version: ''0.7-baseline'') spec.   (MetacelloTutorialConfig project version: ''0.7'') spec."Of course if you print the ''0.6'' spec and the ''0.7'' spec you can see that they specify exactly thesame information in a slightly different way:"  (MetacelloTutorialConfig project version: ''0.6'') spec.  (MetacelloTutorialConfig project version: ''0.7'') spec."and if you load each of the versions, you will see that they load the same packages, in the same order:"  (MetacelloTutorialConfig project version: ''0.6'') load.  (MetacelloTutorialConfig project version: ''0.7'') load."Finally, even though version ''0.7-baseline'' does not have explicit package versions, you may loadthe version. When the ''real'' loader encounters a package name (without version information) it willattempt to load the latest version of the package from the repository. With theMetacelloNullRecordingMCSpecLoader the packages names are ''loaded'':"  (MetacelloTutorialConfig project version: ''0.7-baseline'') load."Of course when a number of developers are working on a project it may be useful to load a#baseline version so that you get the latest work from all of the project members. "ProfStef next.'defaultPackageNamesToLoad  ^self defaultPackageNamesToLoad: self spec defaultPackageNames~> arg1  arg1 species = self species ifFalse: [ ^false ].  ^self versionNumber ~> arg1 versionNumberload  | tmp1 |  tmp1 := self repositoriesFrom: self spec repositorySpecs.  ^self loadType == #atomic ifTrue: [ self atomicLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: tmp1 ] ifFalse: [ self linearLoadPackageSpecs: self spec packageSpecsInLoadOrder repositories: tmp1 ]testSpecialMatch  self assert: ((self versionClass fromString: '1.1.0') match: '?').  self assert: ((self versionClass fromString: '1.0.0-alpha') match: '?').  self assert: ((self versionClass fromString: '1.0.0-rc.1+build.1') match: '?').  self assert: ((self versionClass fromString: '1.1.0') match: '*.*.?').  self assert: ((self versionClass fromString: '1.3.7+build.2.b8f12d7') match: '?').  self assert: ((self versionClass fromString: '1.3.7+build.11.e0f985a') match: '?').  self deny: ((self versionClass fromString: '1.1.0') match: '*.*.*-?').  self deny: ((self versionClass fromString: '1.1.0') match: '*.*.*+?').  self assert: ((self versionClass fromString: '1.1.1') match: '*.?')postLoadDoIt: arg1  arg1 setPostLoadDoItInMetacelloSpec: selfprintOn: arg1  | tmp1 tmp2 tmp3 |  self configurationProjectSpecIfPresent: [:arg2 |  tmp1 := arg2 className.        tmp2 := arg2 versionString ] ifAbsent: [ tmp1 := self baselineProjectSpec className.        tmp2 := '[baseline]' ].  arg1 nextPutAll: tmp1.  tmp2 ifNil: [ arg1 nextPutAll: ' --no version specified--' ] ifNotNil: [ arg1           space;           nextPutAll: tmp2 ].  (tmp3 := self repositoryDescriptions) isEmpty ifTrue: [ ^self ].  arg1 nextPutAll: ' from '.  tmp3 size = 1 ifTrue: [ arg1 nextPutAll: tmp3 first ] ifFalse: [ arg1 nextPut: ${.        tmp3 do: [:arg3 |  arg1 nextPutAll: arg3 ].        arg1 nextPut: $} ]stackCacheFor: arg1 at: arg2 doing: arg3  ^self stackCacheFor: arg1 cacheClass: Dictionary at: arg2 doing: arg3baseline30MethodSourceFan  ^(self class sourceCodeAt: #baseline30Fan:) asStringlesson02  mergeSpec: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := super mergeSpec: arg1.  tmp2 := arg1 mergeMap.  arg1 name ~~ nil ifTrue: [ tmp1 name: arg1 name ].  (tmp3 := tmp2 at: #requires) ~~ nil ifTrue: [ tmp1 setRequires: self requires , tmp3 ].  (tmp4 := tmp2 at: #includes) ~~ nil ifTrue: [ tmp1 setIncludes: self includes , tmp4 ].  (tmp5 := tmp2 at: #answers) ~~ nil ifTrue: [ tmp1 setAnswers: self answers , tmp5 ].  ^tmp1createNewDevelopmentVersion  ^Lesson title: '8. Create new development version' lesson: '"After releasing a version it isn''t a bad idea to open a new development version for the next phase of development:"		MetacelloToolBox		createNewDevelopmentVersionIn: ConfigurationOfExample		description: ''- aim at implementing new features''."The above expression uses the #release version as a template for the new version with the #release minor version number incremented." ProfStef next.'testIsBaselineName  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: tmp1 isBaselineName.  tmp1 := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self deny: tmp1 isBaselineNamehasConflictWithBaselineSpec: arg1  ^self hasLoadConflicts: arg1updatePackageSpec: arg1 using: arg2  onLock: arg1  self addStatement: #onLock: args: {arg1}setTimestamp: arg1  timestamp := arg1get  ^self execute: #get args: #()specResolverBlock  ^[:arg1 :arg2 |  (arg2 argumentAt: 1) = arg1 versionString ifTrue: [ self evaluatePragma: arg2.        self project attributes do: [:arg3 |  | tmp1 |              (tmp1 := self attributeMap at: arg3 ifAbsent: [  ]) ~~ nil ifTrue: [ tmp1 do: [:arg4 |  self with: arg1 during: arg4 ] ] ] ] ]mergeIntoMetacelloRepositories: arg1  arg1 addMember: (arg1 mergeMember           name: self name;           spec: self;           yourself)operator: arg1  operator := arg1lesson11  ^Lesson title: 'Lesson 11' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline11:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version11:."As is often the case, it is useful to separate the test package from the core packages for a project. In #baseline11: we''ve created two project references. The reference named ''Example Default'' loads the ''default'' group and the reference named ''Example Tests'' loads the ''Tests'' group.We then made ''Project-Core'' require ''Example Default'' and ''Project-Tests'' requires ''Project-Core'' and ''Example Tests''.Now it is possible to load just the core packages:"  (MetacelloProjectRefTutorialConfig project version: ''1.1'') load: ''Project-Core''."or the whole enchilada including tests:"  (MetacelloProjectRefTutorialConfig project version: ''1.1'') load: ''Project-Tests''.ProfStef next.'setUpConfigurationOfProjectIssue156  self     setUpIssue156BaselineOfGoo;     setUpIssue156ConfigurationOfGooaProjectIsLoaded: arg1  aProjectIsLoaded := arg1repositories: arg1 constructor: arg2  arg2 repositoriesForPackage: arg1warningReasonCodes  ^#(#onlyBaselineVersion)version50Foo: arg1  < version: '5.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #release.        arg1           package: 'GoferUmbrella' with: 'GoferUmbrella-dkh.4';           yourself ]primeStackCacheFor: arg1 doing: arg2 defaultDictionary: arg3  self deprecated: 'use #primeStackCacheWith:doing:'.  self useStackCacheDuring: [:arg4 |  | tmp1 |        tmp1 := arg4 at: arg1 ifAbsent: [  ].        tmp1 == nil ifTrue: [ tmp1 := Dictionary new.              arg4 at: arg1 put: tmp1 ].        ^arg2 value ] defaultDictionary: arg3httpsUrl  ^'https://<1s>/<2s>.git' expandMacrosWith: self hostname with: projectPathpackagesSpecClass  ^MetacelloPackagesSpecprojectReference  ^projectReferencesshPort  ^sshPortloadRequiredFromArray: arg1  | tmp1 |  tmp1 := 'Loading ' , self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloPlatform current do: [ ^self executeLoadFromArray: arg1 ] displaying: tmp1copySpecTo: arg1  self loader copySpec: self from: self repositorySpecs to: arg1 createRepositorysingleRoot: arg1  singleRoot := arg1supplyingAnswersForPackage: arg1  self root answers: arg1configurationOfProjectSpecClass  ^self subclassResponsibilityapplyAdd: arg1 copy: arg2 merge: arg3 remove: arg4  arg4 value: selfprojectTagsUrlFor: arg1  ^'https://<1s>/api/v4/projects/<2s>/repository/tags' expandMacrosWith: self hostname with: arg1unregisterProject  self class registry unregisterProjectRegistration: selfhasConflictWithConfigurationSpec: arg1  ^falsepostLoadDoItForSpec: arg1  self validateDoItSelector: arg1.  self root postLoadDoIt: arg1versionArg: arg1  versionArg := arg1version10Issue47: arg1  < version: '1.0.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>version10Issue47:'.        arg1 author: 'dkh'.        arg1 timestamp: '6/18/2012 14:34'.        arg1 baseline: 'Issue32' ].  arg1 for: #custom do: [ arg1 baseline: 'Issue32' with: [ arg1 repository: 'dictionary://Metacello_External_Test_Repository' ] ]asProjectSpec  ^selfinitialize  self loaderPolicyincrementVersionAt: arg1  | tmp1 |  tmp1 := self at: arg1.  (tmp1 := self at: arg1) isString ifFalse: [ self at: arg1 put: tmp1 + 1 ]version129ProjectToolBox: arg1  < version: '1.2.9-baseline'>  arg1 for: #common do: [ arg1           project: 'Example Project' with: [ arg1                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadDoIt;                 postLoadDoIt: #postloadDoIt;                 repository: 'http://www.example.com/ob' ];           project: 'Copy Project' copyFrom: 'Example Project' with: [ arg1                 preLoadDoIt: nil;                 postLoadDoIt: nil ] ]validateForScriptLoad: arg1 withDefaultVersionString: arg2 withDefaultRepositoryDecription: arg3  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := #validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription:.  self name ifNil: [ tmp1 add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #incompleteProjectSpec callSite: tmp2 explanation: 'name field required') ].  self className ifNil: [ tmp1 add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #incompleteProjectSpec callSite: tmp2 explanation: 'className field required') ].  self repositories isEmpty ifTrue: [ arg3 ifNotNil: [ self repository: arg3 ] ifNil: [ tmp1 add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #incompleteProjectSpec callSite: tmp2 explanation: 'repository field required') ] ].  self validateVersionString: tmp1 withDefaultVersionString: arg2.  ^tmp1fetchProject: arg1  | tmp1 |  (tmp1 := self loader) == nil ifTrue: [ tmp1 := self project loaderClass on: nil ].  tmp1 loaderPolicy: arg1.  tmp1 doingLoads: [ MCWorkingCopy managersForClass: self configuration class do: [:arg2 |  | tmp2 |              tmp2 := self packageSpec.              arg2 repositoryGroup repositories do: [:arg3 |  tmp2 repositories repository: (arg3 asRepositorySpecFor: self) ].              tmp2 name: arg2 packageName.              tmp2 fetchUsing: tmp1.              ^true ] ].  ^truescheduleFetchFor: arg1 reference: arg2 message: arg3  self loaderPolicy resetCacheGofer.  self preLoad: arg1.  (MetacelloDirective loadPackage: arg1 externalReference: arg2 loader: self) addTo: self loadDirective.  self postLoad: arg1.  MetacelloNotification signal: arg3testProjectSpec  | tmp1 |  tmp1 := self projectSpec.  tmp1     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     versionString: #stable;     operator: #<;     operator: nil;     loads: 'MyPackage';     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  self assert: tmp1 name equals: 'Project'.  self assert: tmp1 className equals: 'ConfigurationOfProject'.  self assert: tmp1 versionString equals: #stable.  self assert: tmp1 operator identicalTo: #>=.  self assert: tmp1 loads equals: #('MyPackage' 'MyTests').  self assert: tmp1 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp1 postLoadDoIt value identicalTo: #postLoadDoIt.  self should: [ tmp1 includes: #() ] raise: Error.  self should: [ tmp1 requires: #() ] raise: Error.  self should: [ tmp1 answers: #() ] raise: Error.  tmp1 projectDo: [:arg1 |  self assert: tmp1 identicalTo: arg1 ] packageDo: [:arg2 |  self assert: false ] groupDo: [:arg2 |  self assert: false ].  self should: [ tmp1 preLoadDoIt: '' ] raise: Error.  self should: [ tmp1 postLoadDoIt: '' ] raise: ErrorsetUp  super setUp.  self     setUpVersionReferences;     setUpMonticelloRepositorypackagesNeedSavingVisited: arg1 into: arg2  self packages map valuesDo: [:arg3 |  arg3 packagesNeedSavingVisited: arg1 using: self repositories map values into: arg2 ]match: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := (self class fromString: arg1 forPattern: true) versionComponents.  tmp4 := self versionComponents.  tmp2 := tmp4 size.  tmp3 := tmp1 size.  tmp2 = tmp3 ifFalse: [ tmp2 < tmp3 ifTrue: [ ^false ].        (tmp1 at: tmp3) ~= '?' ifTrue: [ ^false ].        tmp2 := tmp3 ].  1 to: tmp2 do: [:arg2 |  | tmp5 |        tmp5 := (tmp1 at: arg2) asString.        tmp5 = '?' ifTrue: [ arg2 = tmp2 ifFalse: [ ^self error: 'Invalid version match pattern: ' , arg1 printString ] ] ifFalse: [ (tmp5 match: (tmp4 at: arg2) asString) ifFalse: [ ^false ] ] ].  ^trueversionString: arg1  versionString := arg1.  projectVersion := nilremovePackage: arg1 constructor: arg2  arg2 removePackageForVersion: arg1configMethodOn: arg1 indent: arg2  arg1     tab: arg2;     nextPutAll: 'spec ';     cr;     tab: arg2 + 1;     nextPutAll: 'name: ' , self name printString , ';'.  self configMethodBodyOn: arg1 hasName: true cascading: false indent: arg2 + 1.  arg1 nextPut: $.repositorySpecs  ^#()recordValidationCriticalWarning: arg1 callSite: arg2 reasonCode: arg3  ^self recordValidationCriticalWarning: arg1 versionString: nil callSite: arg2 reasonCode: arg3testMCProjectMergeSpec  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self projectSpec     name: 'Project';     projectPackage: self project packageSpec;     className: 'ConfigurationOfProject';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  tmp2 := self projectSpec     name: 'Project';     projectPackage: self project packageSpec;     className: 'ConfigurationOfProjectB';     repository: 'http://example.com/repository' username: 'DaleHenrichs' password: 'secret';     repository: '/opt/gemstone/repo';     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: tmp3 name equals: 'Project'.  self assert: tmp3 className equals: 'ConfigurationOfProjectB'.  self assert: tmp3 projectPackage name equals: tmp3 className.  self assert: tmp3 projectPackage file equals: tmp3 className.  tmp4 := tmp3 repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'directory'.  tmp4 := tmp3 repositories map at: '/opt/gemstone/repo' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'directory'.  tmp4 := tmp3 repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: tmp4 type equals: 'http'.  self assert: tmp4 username equals: 'DaleHenrichs'.  self assert: tmp4 password equals: 'secret'mergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #file put: file.  tmp1 at: #repositories put: self repositories.  tmp1 at: #preLoadDoIt put: preLoadDoIt.  tmp1 at: #postLoadDoIt put: postLoadDoIt.  ^tmp1metacelloRegistrationHash  ^super metacelloRegistrationHash bitXor: self repositories metacelloRegistrationHashmerge: arg1  arg1 mergeIntoMetacelloPackages: selfsetUp  super setUp.  self     setUpRepositories;     setUpExternalCore;     setUpExternalCoreX;     setUpSampleCore;     setUpBaselineOfExternalX;     setUpBaselineOfExternalXX;     setUpBaselineOfExternalXXX;     setUpConfigurationOfExternaldkh1;     setUpConfigurationOfExternaldkh2;     setUpConfigurationExternalRef;     setUpConfigurationOfExternalX;     setUpConfigurationOfExternalXX;     setUpConfigurationOfExternalXXX;     setUpConfigurationOfExternalIV;     setUpBaselineGithubReferenceXX;     setUpBaselineGithubReferenceIV;     setUpBaselineGithubReferenceV;     setUpBaselineGithubReferenceVI;     setUpBaselineGithubReferenceVII;     setUpBaselineGithubReferenceVIII;     setUpBaselineGithubReferenceIX;     setUpBaselineGithubReferenceXI;     setUpBaselineGithubReferenceXII;     setUpBaselineGithubReferenceXIII;     setUpMarianosImage;     setUpConfigurationOfConflict;     setUpInvalidConfigurations;     setUpConfigurationIssue32;     setUpBaselineIssue32;     setUpConfigurationIssue59;     setUpConfiguration63;     setUpLockConfigurations;     setUpConfigurationIssue84;     setUpConfigurationNextedIssue84;     setUpConfiguration181;     setUpBaselineIssue215;     setUpConfigurationIssue339;     setUpIssue399answers  ^#()packageNamed: arg1 ifAbsent: arg2  | tmp1 |  (tmp1 := self spec packageNamed: arg1 ifAbsent: [  ]) == nil ifTrue: [ ^arg2 value ].  ^tmp1 referencedSpecrepositories  repositories ifNil: [ repositories := self project repositoriesSpec ].  ^repositoriespreLoad: arg1  self subclassResponsibilitycacheRepository  ^self loaderPolicy cacheRepositorynonOverridable  ^super nonOverridable , #(#projectPackage #repositories)setUpConfigurationOfProjectIssue119dkh4: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.4'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion40Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version40Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version40Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: arg1) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4isLoadedToSpecAgainst: arg1  (self isPartiallyCurrentAgainst: arg1) isLoadedToSpec: [:arg2 |  ^true ].  ^falseoverrideRepositories  ^overrideRepositoriestestVersion10  | tmp1 tmp2 |  self assert: (tmp1 := (({(self versionClass fromString: '1.0') .         (self versionClass fromString: '0.7') .         (self versionClass fromString: '0.8') .         (self versionClass fromString: '0.9') .         (self versionClass fromString: '1.0.1')} sort: [:arg1 :arg2 |  arg1 <= arg2 ]) collect: [:arg3 |  arg3 versionString ]) asArray) equals: (tmp2 := #('0.7' '0.8' '0.9' '1.0' '1.0.1'))checkAllowed  projectSpecClass  ^MetacelloMCNamelessProjectSpeclesson12  ^Lesson title: 'Lesson 12' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline11:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline12:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version12:."In #baseline11: there is redundant information for each of the project references. In #baseline12: we use the #project:copyFrom:with: method to eliminate the need to specify the bulk of the project information twice. Evaluate and compare the results of the following expressions:"   (MetacelloProjectRefTutorialConfig project version: ''1.1'') load: ''Project-Core''.  (MetacelloProjectRefTutorialConfig project version: ''1.2'') load: ''Project-Core''.  (MetacelloProjectRefTutorialConfig project version: ''1.1'') load: ''Project-Tests''.  (MetacelloProjectRefTutorialConfig project version: ''1.2'') load: ''Project-Tests''.ProfStef next.'deleteSpec: arg1  self list detect: [:arg2 |  arg2 spec = arg1 ] ifFound: [:arg3 |  self list remove: arg3 ]isPossibleBaseline  | tmp1 |  (tmp1 := self versionOrNil) == nil ifTrue: [ ^false ].  (tmp1 allPackagesForSpecNamed: (self loadListForVersion: tmp1)) do: [:arg1 |  arg1 workingCopy == nil ifTrue: [ ^false ] ].  ^truesampleVersionStrings  ^#('1.0.0+-' '1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-0.3.7' '1.0.0-x.7.z.92') , #('1.0.0+build.1' '1.3.7+build.11.e0f985a') , #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0-rc.1+build.1' '1.0.0' '1.0.0+0.3.7' '1.3.7+build' '1.3.7+build.2.b8f12d7' '1.3.7+build.11.e0f985a') , #('1.0.0-alp-h-a' '1.0.0-r-c.1' '1.0.0+alp-h-a' '1.0.0+r-c.1')baselineGithubReferenceV: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>baselineGithubReferenceV:'.        arg1 baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]projectDo: arg1 packageDo: arg2 groupDo: arg3  arg2 value: selftestRepositorySpec  | tmp1 |  tmp1 := self repositorySpec     description: '/opt/gemstone/repository';     username: 'dkh';     password: 'password';     type: 'directory';     yourself.  self assert: tmp1 name equals: tmp1 description.  self assert: tmp1 description equals: '/opt/gemstone/repository'.  self assert: tmp1 username equals: 'dkh'.  self assert: tmp1 password equals: 'password'.  self assert: tmp1 type equals: 'directory'.  tmp1 := self repositorySpec     description: '/opt/gemstone/repository';     yourself.  self assert: tmp1 description equals: '/opt/gemstone/repository'.  self assert: tmp1 type equals: 'directory'.  tmp1 := self repositorySpec     description: 'http://example.com/repository';     yourself.  self assert: tmp1 description equals: 'http://example.com/repository'.  self assert: tmp1 type equals: 'http'setUpBaselineGithubReferenceXIII  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefXIII-dkh.1'.  tmp2 := #BaselineOfGithubRefXIII.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineGithubReferenceVII:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceVII:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4defaultDirectory  ^FileLocator imageDirectory asFileReferencedecrementVersionAt: arg1  | tmp1 |  tmp1 := self at: arg1.  (tmp1 := self at: arg1) isString ifFalse: [ tmp1 > 0 ifTrue: [ self at: arg1 put: tmp1 - 1 ] ]handleLookupProjectSpec: arg1  ^arg1 resume: ((self lookupProjectSpecFor: arg1 projectSpec) ifNil: [ ^arg1 resume: arg1 projectSpec ])repositoryForProject: arg1 username: arg2 password: arg3  self repositoryForSpec: arg1 username: arg2 password: arg3subCommand  | tmp1 |  tmp1 := self argumentAt: 1.  self checkSubCommand: tmp1.  ^tmp1import: arg1 constructor: arg2  arg2 importForVersion: arg1methodSectionsFrom: arg1 do: arg2  | tmp1 tmp2 tmp3 |  tmp1 := self constructor.  tmp2 := project version: arg1.  tmp3 := tmp2 versionString.  tmp1 extractMethodSectionsFor: tmp3.  tmp1 methodSectionsDo: arg2baseline10: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://www.example.com/Project'.        arg1 project: 'Example ALL' with: [ arg1                 className: 'MetacelloTutorialConfig';                 versionString: '1.0';                 loads: #('ALL');                 file: 'MetacelloTutorialConfig';                 repository: 'http://seaside.gemstone.com/ss/metacello' ].        arg1           package: 'Project-Core' with: [ arg1 requires: 'Example ALL' ];           package: 'Project-Tests' with: [ arg1 requires: 'Project-Core' ] ]baseline12C: arg1  < version: '1.2'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferFoo' with: 'GoferFoo-lr.1';           package: 'GeauxBeau' with: 'GeauxBeau-dkh.55';           yourself ]projectWith: arg1  | tmp1 |  tmp1 := self projectClass new.  tmp1 projectAttributes: arg1.  MetacelloVersionConstructor on: self project: tmp1.  tmp1 loader: MetacelloNullRecordingMCSpecLoader new.  ^tmp1baselineVersion10Issue136: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 package: 'GoferBeau' ]testProjectMergeSpec  | tmp1 tmp2 tmp3 |  tmp1 := self projectSpec     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     loads: #('MyPackage');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  tmp2 := self projectSpec     name: 'Project';     className: 'ConfigurationOfProjectB';     versionString: #stable;     operator: #<;     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  tmp3 := tmp1 mergeSpec: tmp2.  self assert: tmp3 name equals: 'Project'.  self assert: tmp3 className equals: 'ConfigurationOfProjectB'.  self assert: tmp3 versionString equals: #stable.  self assert: tmp3 operator identicalTo: #<.  self assert: tmp3 loads equals: #('MyPackage' 'MyTests').  self assert: tmp3 preLoadDoIt value identicalTo: #preLoadDoItB.  self assert: tmp3 postLoadDoIt value identicalTo: #postLoadDoItBgetBlessing  ^blessingrepository: arg1  ^self projectReference repository: arg1specs: arg1 forPackageOrdering: arg2  | tmp1 |  tmp1 := Set new.  arg1 do: [:arg3 |  | tmp2 |        tmp2 := arg2 packageNamed: arg3 ifAbsent: [ MetacelloNameNotDefinedError signal: 'project group, or package named: ' , arg3 printString , ' not found when used in requires: or includes: field of package: ' , self name printString , ' for version: ' , arg2 versionString , ' of ' , arg2 projectLabel , '.'.              nil ].        tmp2 ifNotNil: [ tmp1 addAll: (tmp2 resolveSpecsForPackageOrdering: arg2) ] ].  ^tmp1testCopyToProject  | tmp1 tmp2 tmp3 |  tmp1 := self packagesSpec.  tmp1 add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself).  tmp2 := self projectSpec     name: 'ProjectCopy';     yourself.  tmp3 := self project projectReferenceSpec     name: 'ProjectCopy';     projectReference: tmp2;     yourself.  tmp1 copy: 'Project' to: tmp3.  tmp2 := (tmp1 packageNamed: 'ProjectCopy' ifAbsent: [ self assert: false ]) referencedSpec.  self assert: tmp2 name equals: 'ProjectCopy'.  self assert: tmp2 className equals: 'ConfigurationOfProjectA'.  self assert: tmp2 versionString equals: #stable.  self assert: tmp2 operator identicalTo: #>=.  self assert: tmp2 loads equals: #('MyPackage' 'MyTests').  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoItB.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoItBisLocked  ^self registration lockedprojectPackageForProject: arg1  self with: self root during: arg1testAddPackageB  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: {(self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself) .         (self packageSpec           name: 'Package';           requires: 'AndAnotherPackage';           includes: 'AndIncludedPackage';           answers: #(#('postload' 'postload answer'));           file: 'Package-dkh.2';           yourself)}.  tmp2 := tmp1 packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: tmp2 name equals: 'Package'.  self assert: tmp2 requires equals: #('AndAnotherPackage').  self assert: tmp2 includes equals: #('AndIncludedPackage').  self assert: tmp2 answers equals: #(#('postload' 'postload answer')).  self assert: tmp2 file equals: 'Package-dkh.2'.  self assert: tmp2 preLoadDoIt value identicalTo: nil.  self assert: tmp2 postLoadDoIt value identicalTo: niltestAsRepositorySpecFor  | tmp1 tmp2 |  tmp1 := self project.  tmp2 := [:arg1 :arg2 :arg3 |  | tmp3 tmp4 tmp5 |  tmp3 := arg1 repositorySpecs first.  self assert: tmp3 type equals: arg2.  tmp4 := tmp3 createRepository.  tmp5 := tmp4 asRepositorySpecFor: tmp1.  self assert: tmp5 type equals: arg3.  arg2 = arg3 ifTrue: [ self assert: tmp3 description equals: tmp5 description ] ifFalse: [ self assert: (tmp3 description copyFrom: 'server://' size + 1 to: tmp3 description size) equals: tmp5 description ] ].  tmp2 value: ((tmp1 version: '1.0-baseline') packageNamed: 'Example-Core') value: 'directory' value: 'directory'.  tmp2 value: ((tmp1 version: '1.3-baseline') packageNamed: 'Example-Core') value: 'ftp' value: 'ftp'.  tmp2 value: ((tmp1 version: '1.4-baseline') packageNamed: 'Example-Core') value: 'http' value: 'http'.  tmp2 value: ((tmp1 version: '1.5-baseline') packageNamed: 'Example-Core') value: 'dictionary' value: 'dictionary'testFileTreeRepository  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp5 := MCFileTreeFileUtils current.  tmp6 := tmp5 default.  tmp7 := tmp5 directoryFromPath: 'temp' relativeTo: tmp6.  [ tmp5 ensureDirectoryExists: tmp7.  tmp8 := tmp5 directoryFromPath: 'repo' relativeTo: tmp7.  tmp5 ensureDirectoryExists: tmp8.  tmp1 := self project.  tmp2 := (tmp1 version: '1.6-baseline') packageNamed: 'Example-Core'.  tmp3 := tmp2 repositorySpecs first.  self assert: tmp3 type equals: 'filetree'.  tmp4 := tmp3 createRepository.  self assert: tmp4 class identicalTo: (testingEnvironment at: #MCFileTreeRepository ifAbsent: [  ]).  MetacelloNotification signal: 'testFileTreeRepository: ' , (tmp5 directoryFromPath: 'temp/repo' relativeTo: tmp5 default) fullName.  self assert: tmp4 description equals: 'filetree://' , (tmp5 directoryFromPath: 'temp/repo' relativeTo: tmp5 default) fullName ] ensure: [ (tmp5 directoryExists: tmp7) ifTrue: [ tmp5 deleteAll: tmp7 ] ]recordValidationWarning: arg1 callSite: arg2 reasonCode: arg3  ^self recordValidationWarning: arg1 versionString: nil callSite: arg2 reasonCode: arg3globalNamed: arg1 ifAbsent: arg2  ^Smalltalk at: arg1 ifAbsent: arg2copyFrom: arg1 to: arg2  | tmp1 tmp2 tmp3 |  tmp1 := arg2 - arg1 + 1.  tmp2 := self species new: tmp1.  tmp3 := 0.  arg1 to: arg2 do: [:arg3 |  tmp2 at: tmp3 + 1 put: (self at: arg3).        tmp3 := tmp3 + 1 ].  ^tmp2attributeMap  attributeMap == nil ifTrue: [ attributeMap := Dictionary new ].  ^attributeMapgtInspectorLoadDirectivesIn: arg1  < gtInspectorPresentationOrder: 1>  arg1 tree     title: 'Load directives';     display: [ {self} ];     format: [:arg2 |  arg2 label ifEmpty: [ arg2 title ] ];     rootsExpanded;     children: #gtInspectorChildren;     filterOn: [:arg3 :arg2 |  '*' , arg3 , '*' match: arg2 label ]smalltalkhubUser: arg1 project: arg2  self repository: 'http://smalltalkhub.com/mc/' , arg1 , '/' , arg2 , '/main'testVersion15  self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0-beta.1')project  project == nil ifTrue: [ project := self projectClass new ].  ^projectfetch: arg1  ^self execute: #fetch: args: {arg1}packageSpec  ^self packageSpecClass for: selfgroupSpecClass  ^MetacelloGroupSpecmonticelloRepository  ^monticelloRepositoryabort  ^abortexpandToLoadableSpecNames: arg1  ^self spec expandToLoadableSpecNames: arg1testRemoveProjectB  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self packagesSpec.  tmp1 add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp3 := tmp1 packageNamed: 'Project' ifAbsent: [ self assert: false ].  tmp2 := tmp3 referencedSpec.  self assert: tmp2 name equals: 'Project'.  self assert: tmp2 className equals: 'ConfigurationOfProject'.  self assert: tmp2 versionString equals: '1.0'.  self assert: tmp2 operator identicalTo: #<.  self assert: tmp2 loads equals: #('MyPackage').  self assert: tmp2 preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: tmp2 postLoadDoIt value identicalTo: #postLoadDoIt.  tmp1 remove: {(self projectReferenceSpec           name: 'Project';           yourself)}.  tmp4 := false.  tmp1 packageNamed: 'Project' ifAbsent: [ tmp4 := true ].  self assert: tmp4printOn: arg1  | tmp1 |  self configuration class printOn: arg1.  arg1 nextPut: $(.  self versions do: [:arg2 |  arg1 nextPutAll: arg2 versionString.        arg2 spec ~~ nil ifTrue: [ (tmp1 := arg2 spec projectLabel) isEmpty ifFalse: [ arg1 nextPutAll: ' [' , tmp1 , ']' ] ].        arg1           nextPut: $,;           space ].  arg1 nextPut: $)attributeOrPath  ^self parent == nil ifTrue: [ self attributes size == 1 ifTrue: [ self attributes first ] ifFalse: [ self attributes ] ] ifFalse: [ self attributePath ]selectorForPragma: arg1  ^arg1 selectorpreLoadDoItForPackage: arg1  self preLoadDoItForSpec: arg1squeaksource: arg1  self repository: 'http://www.squeaksource.com/' , arg1testHasVersion  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--version=stable').  self assert: tmp1 hasVersion.  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self deny: tmp1 hasVersionmethodSelectorAndPragma: arg1 imports: arg2 on: arg3  arg3     nextPutAll: arg1 asString , ' spec';     cr;     tab;     nextPutAll: '<baseline>'load  ^self execute: #load: args: #(#())doLoad  configurationExternalRef092: arg1  < version: '0.9.2'>  arg1 for: #common do: [ arg1 blessing: #version.        arg1 description: 'MetacelloScriptingResource>>configurationExternalRef092:'.        arg1 project: 'External' with: [ arg1                 className: 'ConfigurationOfExternal';                 version: '0.9.2';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]setUpIssue95  self     setUpConfigurationOfProjectInfinite;     setUpConfigurationOfProjectLoop;     setUpConfigurationOfProjectIssue95;     yourselfversions  ^self map values asArray sort: [:arg1 :arg2 |  arg1 <= arg2 ]baseline11: arg1  < version: '1.1-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline.        arg1 repository: 'http://www.example.com/Project'.        arg1           project: 'Example Default' with: [ arg1                 className: 'MetacelloTutorialConfig';                 versionString: '1.1';                 loads: #('default');                 file: 'Metacello-Tutorial';                 repository: 'http://seaside.gemstone.com/ss/metacello' ];           project: 'Example Tests' with: [ arg1                 className: 'MetacelloTutorialConfig';                 versionString: '1.1';                 loads: #('Tests');                 file: 'Metacello-Tutorial';                 repository: 'http://seaside.gemstone.com/ss/metacello' ].        arg1           package: 'Project-Core' with: [ arg1 requires: 'Example Default' ];           package: 'Project-Tests' with: [ arg1 requires: #('Project-Core' 'Example Tests') ] ]configuration: arg1  configuration := arg1copy: arg1  self addMember: arg1packageForVersion: arg1 overrides: arg2  | tmp1 |  tmp1 := self project packageSpec     name: arg1;     yourself.  self root packages add: tmp1.  self with: tmp1 during: arg2loadType  loadType == nil ifTrue: [ ^#atomic ].  ^loadTypeprojectPackage  projectPackage ifNil: [ self className ifNil: [ ^nil ].        projectPackage := self project packageSpec.        projectPackage name: self className.        self getFile ifNotNil: [ projectPackage file: self file ].        projectPackage repositories: self getRepositories ].  ^projectPackageapplyIncludesTo: arg1 for: arg2 firstTime: arg3 for: arg4  | tmp1 tmp2 |  tmp1 := Set new.  tmp2 := arg1 indexOf: arg2.  (arg2 includeSpecNamesForPackageOrdering: arg4) do: [:arg5 |  | tmp3 tmp4 |        tmp3 := arg5 name.        tmp4 := arg1 detect: [:arg6 |  arg6 name = tmp3 ] ifNone: [  ].        (self slideIn: arg1 spec: tmp4 baseIndex: tmp2 seen: IdentitySet new firstTime: arg3 for: arg4) ifTrue: [ tmp1 add: tmp4 name ] ].  ^tmp1versionString  ^versionStringcacheGofer  cacheGofer == nil ifTrue: [ cacheGofer := Gofer new.        cacheGofer disablePackageCache.        cacheGofer repository: self cacheRepository ].  ^cacheGoferclassNameArg: arg1  classNameArg := arg1cacheRepository: arg1  self options at: #cacheRepository put: arg1baseline20MethodSourceFan  ^(self class sourceCodeAt: #baseline20Fan:) asStringsetUpBaselineGithubReferenceVIII  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefVIII-dkh.1'.  tmp2 := #BaselineOfGithubRefVIII.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineGithubReferenceV:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineGithubReferenceV:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4resolvePackageNames  packages := Dictionary new.  self resolveToLoadableSpecs.  ^packages values collect: [:arg1 |  arg1 name ]title  self subclassResponsibilitysetUpBaselineGithubReferenceVI  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfGithubRefVI-dkh.1'.  tmp2 := #BaselineOfGithubRefVI.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'configurationGithubReferenceXXX:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #configurationGithubReferenceXXX:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4downloadJSON: arg1 username: arg2 pass: arg3  | tmp1 tmp2 tmp3 |  tmp1 := self tempFileFor: 'tags-' , self processPID suffix: 'json'.  tmp3 := self downloadBasicFile: arg1 to: tmp1 username: arg2 pass: arg3.  [ tmp2 := self fileHandleOn: tmp1.  tmp2 containingDirectory readOnlyFileNamed: tmp2 localName do: [:arg4 |  | tmp4 |        tmp4 := (Smalltalk at: #MCFileTreeJsonParser) parseStream: arg4 self deleteFileNamed: tmp3.        ^tmp4 ] ] on: Error do: [:arg5 |  self error: 'Error during download (' , arg5 description , ') please check the file ' , tmp3 printString , ' for error message.' ]setUpConfigurationOfProjectIssue119dkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue119-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baselineVersion10Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineVersion10Issue119:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'version10Issue119:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue119:) asString)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4currentVersionInfoFor: arg1  | tmp1 tmp2 |  tmp1 := arg1 file.  ^MetacelloPlatform current stackCacheFor: #currentVersionInfo at: tmp1 doing: [:arg2 |  tmp2 := arg1 currentVersionInfo.        arg2 at: tmp1 put: tmp2 ]projectForScriptEngine: arg1 unconditionalLoad: arg2  ^arg1 getConfigurationProjectUnconditionalLoad: arg2defaultVersionString  ^self class defaultVersionStringfileDirectoryClass  ^Smalltalk at: #FileDirectoryversion11Issue136: arg1  < version: '1.1' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 package: 'GoferBeau' with: 'GoferBeau-dkh.25' ]project  ^project ifNil: [ | tmp1 tmp2 |        tmp1 := (Smalltalk at: #MetacelloVersionConstructor) on: self.        project := tmp1 project.        tmp2 := MetacelloNullRecordingMCSpecLoader new.        tmp2 evalDoits: true.        project loader: tmp2.        project ]version20Issue283: arg1  < version: '2.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 package: 'GoferFoo' with: 'GoferFoo-lr.2' ]configShortCutMethodOn: arg1 member: arg2 indent: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp5 := self hasClassName.  tmp1 := self configHasVersionString.  tmp2 := operator ~~ nil.  tmp3 := self hasRepository or: [ tmp5 & (self getFile ~~ nil or: [ className ~= self name ]) ].  tmp4 := self loads ~~ nil.  tmp6 := self getPreLoadDoIt ~~ nil.  tmp7 := self getPostLoadDoIt ~~ nil.  tmp5 | tmp2 | tmp3 | tmp4 | tmp6 | tmp7 ifTrue: [ (arg2 methodUpdateSelector == #copy: or: [ arg2 methodUpdateSelector == #with: ]) ifTrue: [ arg1                 nextPutAll: 'with: [';                 cr ] ifFalse: [ arg1                 nextPutAll: 'overrides: [';                 cr ].        arg1           tab: arg3;           nextPutAll: 'spec'.        self configMethodBodyOn: arg1 indent: arg3 fromShortCut: true.        arg1 nextPutAll: ' ]'.        ^self ].  tmp1 ifTrue: [ | tmp8 |        tmp8 := self versionString.        arg1 nextPutAll: 'with: '.        tmp8 isSymbol ifTrue: [ arg1 nextPut: $# ].        arg1 nextPutAll: tmp8 asString printString ]isBaselineName  ^self baselineOrConfigurationName matchesRegex: 'BaselineOf.+'lastVersion  | tmp1 |  tmp1 := (self map values asArray sort: [:arg1 :arg2 |  arg1 <= arg2 ]) asOrderedCollection.  tmp1 isEmpty ifTrue: [ ^nil ].  ^tmp1 lastversionNumberClass  versionNumberClass ifNil: [ versionNumberClass := MetacelloVersionNumber ].  ^versionNumberClassattribute: arg1  self deprecated: 'Use attributes: instead'.  self attributes size > 1 ifTrue: [ self error: 'invalid use of attribute:' ].  attributes := OrderedCollection with: arg1baselineGoo300Issue156Configuration: arg1  < version: '3.0.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           package: 'GoferGoo' with: 'GoferFoo-lr.1';           package: 'GoferBar' with: 'GoferBar.branch-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           yourself ]setUpConfigurationOfExternaldkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfExternal-dkh.1'.  tmp2 := #ConfigurationOfExternal.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfExternal090:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfExternal090:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4version105ProjectToolBox: arg1  < version: '1.0.5-baseline'>  arg1 for: #common do: [ arg1 package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/ob' ] ]baselineGoo500Issue156Configuration: arg1  < version: '5.0.0'>  arg1 for: #common do: [ arg1           baseline: 'Goo' with: [ arg1 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           import: 'Goo' ]valueHolderSpecClass  ^MetacelloValueHolderSpecpostLoadDoIt  ^postLoadDoItstoreVersion: arg1  ^self localRepository storeVersion: arg1to  ^toloadPostloadDirective: arg1  | tmp1 |  (tmp1 := arg1 spec postLoadDoItBlock) ~~ nil ifTrue: [ arg1 evaluateSupplyingAnswers: [ tmp1 valueWithPossibleArgs: (Array with: arg1 loader with: arg1 spec) ].        MetacelloNotification signal: 'Evaluated -> ' , arg1 spec label , ' >> ' , arg1 spec postLoadDoIt value asString ]versionString  ^versionStringisPartiallyCurrent: arg1 useEquality: arg2  self subclassResponsibilityconfigMethodBasicOn: arg1 last: arg2 indent: arg3  | tmp1 tmp2 tmp3 |  arg2 ifTrue: [ tmp1 := {self getBlessing .         self getDescription .         self getPreLoadDoIt .         self getPostLoadDoIt .         self getAuthor .         self getTimestamp}.        1 to: tmp1 size do: [:arg4 |  (tmp1 at: arg4) ~~ nil ifTrue: [ tmp2 := arg4 ] ].        tmp3 := [:arg5 |  arg5 = tmp2 ] ] ifFalse: [ tmp3 := [:arg5 |  false ] ].  self configMethodValueOn: arg1 for: self getBlessing selector: 'blessing:' last: (tmp3 value: 1) indent: arg3.  self configMethodValueOn: arg1 for: self getDescription selector: 'description:' last: (tmp3 value: 2) indent: arg3.  self configMethodValueOn: arg1 for: self getPreLoadDoIt selector: 'preLoadDoIt:' last: (tmp3 value: 3) indent: arg3.  self configMethodValueOn: arg1 for: self getPostLoadDoIt selector: 'postLoadDoIt:' last: (tmp3 value: 4) indent: arg3.  self configMethodValueOn: arg1 for: self getAuthor selector: 'author:' last: (tmp3 value: 5) indent: arg3.  self configMethodValueOn: arg1 for: self getTimestamp selector: 'timestamp:' last: (tmp3 value: 6) indent: arg3loader  ^self spec loaderupdateForSpawnMethod: arg1  repositories := className := operator := loads := projectPackage := nil.  arg1 ~~ nil ifTrue: [ versionString := arg1 versionString ]ensureDirectoryExists: arg1  ^arg1     ensureCreateDirectory;     yourselfgtInspectorPackagesIn: arg1  < gtInspectorPresentationOrder: 40>  arg1 list     title: 'Packages';     display: [ (self spec packages packageSpecsInLoadOrderFor: self spec) select: [:arg2 |  arg2 isKindOf: MetacelloPackageSpec ] ]registrationForClassNamed: arg1 ifAbsent: arg2  ^self registrationForExactClassNamed: arg1 ifAbsent: [ | tmp1 |        tmp1 := MetacelloScriptEngine baseNameOf: arg1.        self configurationRegistry at: 'ConfigurationOf' , tmp1 ifPresent: [:arg3 |  ^arg3 ].        self baselineRegistry at: 'BaselineOf' , tmp1 ifPresent: [:arg3 |  ^arg3 ].        arg2 value ]resolveToLoadableSpec  ^selfspecListSelect: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self specListDo: [:arg2 |  (arg1 value: arg2) ifTrue: [ tmp1 add: arg2 ] ].  ^tmp1handleNotificationsForAction: arg1  [ [ [ arg1 on: MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad , MetacelloProjectSpecLoadedNotification , MetacelloScriptEnsureProjectLoadedForDevelopment , MetacelloLookupBaselineSpecForEnsureLoad do: [:arg2 |  arg2 handleResolutionFor: self ] ] on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade , MetacelloAllowConflictingProjectUpgrade do: [:arg2 |  arg2 handleResolutionFor: self ] ] on: MetacelloAllowLockedProjectChange do: [:arg2 |  arg2 handleResolutionFor: self ] ] on: Warning do: [:arg2 |  self handleWarning: arg2 ]ensureLoadUsing: arg1  [ super ensureLoadUsing: arg1 ] on: MetacelloIgnorePackageLoaded do: [:arg2 |  arg2 resume: arg2 packageSpec name = self name ]isValid  ^trueoperationString  ^'load with conflicts'projectForScriptEngine: arg1 unconditionalLoad: arg2  ^arg1 getBaselineProjectUnconditionalLoad: trueversion07: arg1  < version: '0.7' imports: #('0.7-baseline')>  arg1 for: #common do: [ arg1 blessing: #release.        arg1           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1';           package: 'Example-Core' with: 'Example-Core-anon.12';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1' ]sampleRepositoryContents  ^#('Sample-CoreX-dkh.1')customProjectAttributes  ^#(#custom)resolveSpecsForPackageOrdering: arg1  ^{self}mergeSpec: arg1  ^super mergeSpec: arg1 asBaselineProjectSpecoperationString  ^'upgrade to'downloadJSONTags  | tmp1 tmp2 |  tmp1 := self projectTagsUrlFor: self projectPath.  tmp2 := MetacelloPlatform current downloadJSON: tmp1 username: self class siteUsername pass: self class sitePassword.  ^self normalizeTagsData: tmp2version42Symbolic: arg1  < version: '4.2'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 blessing: #release.        arg1           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           package: 'GoferFaux' with: 'GoferFaux-tg.32';           yourself ]validateProjectCreationFrom: arg1 onError: arg2  [ ^arg1 project ] on: Error , MetacelloValidationNotification , MetacelloErrorInProjectConstructionNotification do: [:arg3 |  (arg3 isKindOf: MetacelloValidationNotification) ifTrue: [ self validationReport add: arg3 issue.              arg3 resume ].        (arg3 isKindOf: MetacelloErrorInProjectConstructionNotification) ifTrue: [ self recordValidationError: 'Error creating version: ' , arg3 versionString , ' error: ' , arg3 exception description , ' to reproduce evalutate the following: ''[' , self configurationClass name asString , ' project ] on: MetacelloErrorInProjectConstructionNotification do: [:ex | ex resume: true ]''' callSite: #validateProjectCreationFrom:onError: reasonCode: #versionCreationError.              arg3 resume: false ].        ^arg2 value: arg3 ]string: arg1 includesSubstring: arg2  ^arg1 includesSubstring: arg2description  description == nil ifTrue: [ ^self project valueHolderSpec           value: '';           yourself ].  ^descriptionsetBaselineRepositoryDescription: arg1  hasMethodForSymbolicVersion: arg1  ^(self constructor extractSymbolicVersionPragmas at: arg1 ifAbsent: [ ^false ]) size > 0setUpConfigurationIssue59  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'ConfigurationOfIssue59-dkh.1'.  tmp2 := #ConfigurationOfIssue59.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'version10Issue59:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10Issue59:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionNumberClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionNumberClass) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4testVersion19  self assert: (self versionClass fromString: '1.0-beta.0') < (self versionClass fromString: '1')testRemovePackageA  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  tmp1 remove: (self packageSpec           name: 'Package';           yourself).  tmp2 := false.  tmp1 packageNamed: 'Package' ifAbsent: [ tmp2 := true ].  self assert: tmp2projectTagsUrlFor: arg1  ^'https://bitbucket.org/api/1.0/repositories/' , arg1 , '/tags'fetch: arg1  self fetchRecord: [:arg2 |  arg1 isEmpty ifTrue: [ arg2 fetch ] ifFalse: [ arg2 fetch: arg1 ] ] required: arg1preloadForCore  MetacelloNotification signal: '#preloadForCore executed'version123ProjectToolBox: arg1  < version: '1.2.3-baseline'>  arg1 for: #common do: [ arg1 project: 'Example Project' with: [ arg1                 className: 'MetacelloExampleProjectConfig';                 repository: 'http://www.example.com/ob';                 repository: 'http://www.example.com/or' ] ]setUpBaselineIssue399  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'BaselineOfIssue399-dkh.1'.  tmp2 := #BaselineOfIssue399.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #BaselineOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'baselineIssue399:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue399:) asString)}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4validateVersionSpecForSymbolicVersion: arg1 symbolicVersion: arg2  | tmp1 |  arg1 blessing value == #broken ifTrue: [ ^self ].  tmp1 := arg1 blessing value.  (arg2 == #development and: [ tmp1 ~~ #development ]) ifTrue: [ self recordValidationWarning: 'Symbolic version ' , arg2 printString , ' refers to a version' , arg1 versionString printString , ' whose blessing ' , tmp1 printString , ' is not #development' versionString: arg1 versionString callSite: #validateVersionSpecForSymbolicVersion:symbolicVersion: reasonCode: #notDevelopmentVersion ]invalidConfiguration20: arg1  < version: '2.0.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>invalidConfiguration20: ... missing version:'.        arg1 project: 'External' with: [ arg1                 className: 'ConfigurationOfExternal';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]saltypickle: arg1  self repository: 'http://squeak.saltypickle.com/' , arg1addSymbolicSection: arg1 version: arg2  self methodSpec methodSections do: [:arg3 |  arg3 attributes = {arg1} ifTrue: [ arg3 versionString: arg2.              ^self ] ].  self methodSpec addMethodSection: arg1 versionString: arg2version130ProjectToolBox: arg1  < version: '1.3.0-baseline'>  arg1 for: #common do: [ arg1           project: 'Example Project' with: [ arg1                 className: 'MetacelloExampleProjectConfig';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadDoIt;                 postLoadDoIt: #postloadDoIt;                 repository: 'http://www.example.com/ob' ];           project: 'Copy Project' copyFrom: 'Example Project' with: [ arg1 repository: 'http://www.example.com/or' ] ]configMethodCascadeOn: arg1 member: arg2 last: arg3 indent: arg4  arg2 methodUpdateSelector == #remove: ifTrue: [ arg1 nextPutAll: 'removePackage: ' , self name printString ] ifFalse: [ self configShortCutMethodBodyOn: arg1 member: arg2 indent: arg4 ].  arg3 ifTrue: [ arg1 nextPut: $. ] ifFalse: [ arg1           nextPut: $;;           cr ]isCriticalWarning  ^falseaddMember  ^MetacelloAddMemberSpec for: self projectprojectLabel  ^'baseline'isLoadedMatchConstraints  ^self spec isLoadedMatchConstraintsprojectPackage  ^nilconfigurationClass  ^configurationClassrepositoryUrl  ^self argumentAt: 2loadUsing: arg1 gofer: arg2  arg1 loadExplicitLoadDirective: self gofer: arg2versionClass  ^self subclassResponsibilityload  self subclassResponsibilitytestSpecialMatch  self assert: ((self versionClass fromString: '1.1') match: '?').  self assert: ((self versionClass fromString: 'alpha') match: '?').  self assert: ((self versionClass fromString: '1.1.1.1.1') match: '?').  self assert: ((self versionClass fromString: '1.alpha5') match: '?').  self assert: ((self versionClass fromString: '1.1') match: '*.?').  self assert: ((self versionClass fromString: '1.1') match: '?').  self assert: ((self versionClass fromString: '10.1.1.1.1') match: '?').  self deny: ((self versionClass fromString: '1.1') match: '*.*.?').  self assert: ((self versionClass fromString: '1.1.1') match: '*.?')computeVersionStatus: arg1  self computeVersionStatus: (self expandToLoadableSpecNames: #('ALL')) matchBlock: arg1repositoryMap: arg1  repositoryMap := arg1value: arg1 constructor: arg2  arg2 valueForValueHolder: arg1testAddGroupA  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  tmp1 add: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself).  tmp2 := tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self deny: (tmp2 includes includes: 'Core').  self assert: (tmp2 includes includes: 'Tests')possibleVersions  ^self project symbolicVersionSymbolsreasonCode: arg1  reasonCode := arg1projectReferenceSpec  ^self projectReferenceSpecClass for: selfcopyOnWrite: arg1  | tmp1 |  tmp1 := self copy.  arg1 value: tmp1.  ^tmp1projectTagsUrlFor: arg1  self subclassResponsibilityconfigurationExternalRef090: arg1  < version: '0.9.0'>  arg1 for: #common do: [ arg1 blessing: #version.        arg1 description: 'MetacelloScriptingResource>>configurationExternalRef090:'.        arg1 project: 'External' with: [ arg1                 className: 'ConfigurationOfExternal';                 version: '0.9.0';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]packageNamed: arg1 forMap: arg2 ifAbsent: arg3  ^self packageNamed: arg1 forLoad: true forMap: arg2 ifAbsent: arg3clearVersionSpec: arg1 fullVersionSpec: arg2 updateProjects: arg3 updatePackages: arg4  arg1 specListProjectDo: [:arg5 |  arg3 ifTrue: [ | tmp1 tmp2 |              (tmp1 := arg2 packageNamed: arg5 name) ~~ nil ifTrue: [ tmp2 := tmp1 projectReference.                    tmp2 versionString == nil ifTrue: [ arg5 projectReference versionString: '' ] ] ] ] packageDo: [:arg5 |  arg4 ifTrue: [ arg5 getFile ~~ nil ifTrue: [ arg5 file: '' ] ] ] groupDo: [:arg6 |   ]resolveToPackagesIn: arg1 into: arg2 visited: arg3  self resolveToPackagesIn: arg1 andProjects: false into: arg2 visited: arg3loaderPolicy: arg1  loaderPolicy := arg1defaultAction  ^trueaddToMetacelloPackages: arg1  | tmp1 |  tmp1 := arg1 project projectReferenceSpec     name: self name;     projectReference: self copy;     yourself.  arg1 addMember: (arg1 addMember           name: tmp1 name;           spec: tmp1;           yourself)version10: arg1  < version: '1.0' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #beta.        arg1           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1' ]clearMemberMap  memberMap := nilversion20Issue156: arg1  < version: '2.0.0'>  arg1 for: #common do: [ arg1           configuration: 'Goo' with: [ arg1                 versionString: '4.0.0';                 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           yourself ]version51MethodSourceFoo  ^(self class sourceCodeAt: #version51Foo:) asStringtestVersion21  self deny: (MetacelloVersionNumber fromString: '') > (MetacelloVersionNumber fromString: '0').  self assert: (MetacelloVersionNumber fromString: '') < (MetacelloVersionNumber fromString: '0').  self assert: (MetacelloVersionNumber fromString: '') equals: (MetacelloVersionNumber fromString: '')versionDirectivesDepthFirstDo: arg1  self loadDirectives do: [:arg2 |  arg2 versionDirectivesDepthFirstDo: arg1 ].  arg1 value: selftestDefaultDictionary  | tmp1 |  tmp1 := Dictionary new.  MetacelloPlatform current useStackCacheDuring: [:arg1 |  self           cachedReturnOfValue;           collectionCacheKey;           cacheNil;           directReturnOfValue;           mixedStack;           mixedStackCall ] defaultDictionary: tmp1.  self assert: (tmp1 includesKey: #cached).  self assert: (tmp1 includesKey: #cacheNil).  self assert: (tmp1 includesKey: #collection).  self assert: (tmp1 includesKey: #direct).  self assert: (tmp1 includesKey: #mixed).  self assert: (tmp1 includesKey: #mixedStack)loadedInImage: arg1  self shouldBeMutable.  loadedInImage := arg1testVersion07  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '3.0.0'.  tmp2 := self versionClass fromString: '2'.  self assert: tmp1 > tmp2normalizeTagsData: arg1  | tmp1 |  arg1 isDictionary ifTrue: [ arg1 at: 'message' ifPresent: [:arg2 |  self error: 'Error accessing tags for github project: ' , self projectPath printString , ' -> ' , arg2 printString ] ].  tmp1 := Dictionary new.  arg1 do: [:arg3 |  | tmp2 tmp3 |        tmp2 := arg3 at: 'name'.        tmp3 := arg3 at: 'commit'.        tmp1 at: tmp2 put: (tmp3 at: 'sha') ].  ^tmp1initialize  groups := Set new.  packages := Set new.  projects := Set newversion100Issue339: arg1  < version: '1.0.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>version100Issue339:'.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 package: 'Issue339' with: 'Issue339-JanKurs.1' ]latestVersionMatching: arg1 includedBlessings: arg2 excludedBlessings: arg3  | tmp1 |  tmp1 := arg3 asSet copy.  tmp1 removeAllFoundIn: arg2.  ^(self map values select: [:arg4 |  (arg2 isEmpty or: [ arg2 includes: arg4 blessing ]) and: [ (tmp1 includes: arg4 blessing) not and: [ arg4 versionNumber match: arg1 ] ] ]) detectMax: [:arg4 |  arg4 ]valueHolderSpec  ^self valueHolderSpecClass for: selffindWorkingCopy  | tmp1 |  tmp1 := MCWorkingCopy allManagers select: [:arg1 |  self matchesWorkingCopy: arg1 ].  tmp1 isEmpty ifTrue: [ ^nil ].  ^tmp1 detectMax: [:arg2 |  arg2 package name size ]configurationNameFrom: arg1  ^self class configurationNameFrom: arg1isWarning  ^truerepoPath: arg1  repoPath := arg1testCheckInputForInstallSubcommand  | tmp1 |  tmp1 := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper' '--version=master').  self should: [ tmp1 checkInputForInstallSubcommand ] raise: Exit.  tmp1 := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'Foo').  self should: [ tmp1 checkInputForInstallSubcommand ] raise: ExitisError  ^truesetPostLoadDoIt: arg1  postLoadDoIt := arg1introductionText  ^'Dive down into the MetacelloToolBox API to take a closer look at the implementation of the development support methods.'primeRegistryFromImage: arg1 baselineClasses: arg2  self primeRegistryFromImage: arg1 baselineClasses: arg2 prioritizeConfiguration: falsevalidateMergeForSpec: arg1  arg1 class = self class ifFalse: [ self error: 'The project spec ' , self name printString , ' in project ' , self project label , ' has incompatible specs. ' , arg1 class name asString , ' and ' , self class name asString , ' are not compatible.' ]copyForRegistration: arg1 onWrite: arg2  | tmp1 |  arg1 baselineProjectSpecIfPresent: [:arg3 |  tmp1 := arg3 copy.        arg2 value: tmp1.        arg1 baselineProjectSpec: tmp1 ] ifAbsent: [ arg1 configurationProjectSpecIfPresent: [:arg3 |  tmp1 := arg3 copy.              arg2 value: tmp1.              arg1 configurationProjectSpec: tmp1 ] ifAbsent: [ arg2 value: nil ] ]map  versionMap ifNil: [ ^Dictionary new ].  ^versionMapdefaultPackageNames  self packages packageNamed: 'default' ifAbsent: [ ^self packageNames ].  ^#('default')preLoadDoIt  ^preLoadDoItsetUpIssue399CoreExternaldkh1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'Issue399-Core-dkh.1'.  tmp2 := #Issue399External.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp1 packageName instVarNames: #() comment: '')}.  externalRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4introductionText  ^'This tutorial covers some of the methods that can be found in the MetacelloToolBox.CREATE PROJECT	1. Create configuration and baseline version	2. Create development version	3. Validate and save configuration in project repository	DEVELOPMENT	4. Checkpoint save	5. Integrate code contributions	6. Compare versionsRELEASE	7. Release development version	8. Create new development versionFor convenience, a number of the methods covered in these sections can be found in the ''development support'' category on the class-side of MetacelloBaseConfiguration." 	Smalltalk tools browser openOnClass: MetacelloBaseConfiguration class selector: #DevelopmentProcess."After deciding which of the development support methods you will use in your project, copy the methods of interest to the the class-side of your own configuration or implement your own ''development support'' methods using the MetacelloToolBox API:"	HelpBrowser openOn: MetacelloAPIDocumentation"'operator: arg1 constructor: arg2  arg2 operatorForProject: arg1title  ^'preload'linearLoadPackageSpec: arg1 gofer: arg2  MetacelloPlatform current do: [ | tmp1 tmp2 tmp3 tmp4 tmp5 |        tmp4 := self resolvePackageSpec: arg1 gofer: arg2.        tmp4 ifNil: [ ^self ].        tmp1 := [ self preLoad: arg1.        tmp2 := MetacelloGoferLoad on: MetacelloGofer new.        tmp2 addResolved: tmp4.        tmp2 execute.        MetacelloPlatform current clearCurrentVersionCache.        self postLoad: arg1 ].        (tmp3 := arg1 answers) notEmpty ifTrue: [ tmp1 valueSupplyingMetacelloAnswers: tmp3 ] ifFalse: [ tmp1 value ].        tmp5 := tmp4 repository.        self hasRepositoryOverrides ifTrue: [ tmp5 := self loaderPolicy repositoryMap at: tmp4 name ifAbsent: [ tmp4 repository ].              tmp4 workingCopy repositoryGroup addRepository: tmp5 ] ifFalse: [ tmp4 workingCopy repositoryGroup addRepository: tmp4 repository ].        MetacelloNotification signal: 'Loaded -> ' , tmp4 name , ' --- ' , tmp5 repositoryDescription , ' --- ' , tmp4 repository description ] displaying: 'Loading ' , arg1 filerenggli: arg1  self repository: 'http://source.lukas-renggli.ch/' , arg1testVersion24  self assert: (MetacelloVersionNumber fromString: '3.0.3.-rc.1') ~= (MetacelloVersionNumber fromString: '3.0.0.3-rc.1').  self assert: (MetacelloVersionNumber fromString: '1.0.0.1.0.0') equals: (MetacelloVersionNumber fromString: '1.0.0.1').  self assert: (MetacelloVersionNumber fromString: '1.0.0.1') ~= (MetacelloVersionNumber fromString: '1..1')remove: arg1  self subclassResponsibilitysetUpConfigurationOfExternalX  | tmp1 |  tmp1 := self setUpConfigurationOfExternalXdkh1.  tmp1 := self setUpConfigurationOfExternalXdkh2: {tmp1}repositories  ^self referencedSpec repositoriescommitIdFor: arg1 ifFound: arg2  (arg1 repositoryGroup includes: self) ifTrue: [ arg2 value: self commitId ]loadUsing: arg1 gofer: arg2  ^self subclassResponsibilitylockConfiguration10: arg1  < version: '1.0.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>lockConfiguration10: '.        arg1 configuration: 'ExternalX' with: [ arg1                 version: '0.9.0';                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]testAlphaNumericVersion4  self assert: (self versionClass fromString: '2.9.9-alpha.2') < (self versionClass fromString: '2.9.9')baselineProjectSpecIfAbsent: arg1  ^baselineProjectSpec ifNil: arg1preLoadDoIt: arg1  arg1 setPreLoadDoItInMetacelloSpec: selfstableVersionC: arg1  < symbolicVersion: #stable>  arg1 for: #common do: [ arg1 version: '4.2' ].  arg1 for: #'platformVersion1.x' do: [ arg1 version: '4.0' ].  arg1 for: #'platformVersion1.0.x' do: [ arg1 version: '4.1' ].  arg1 for: #'platformVersion1.1.x' do: [ arg1 version: '4.2' ].  arg1 for: #'platformVersion1.2.x' do: [ arg1 version: '4.3' ]workingCopyName  | tmp1 |  (tmp1 := self workingCopy) == nil ifTrue: [ ^nil ].  tmp1 ancestry ancestors isEmpty not ifTrue: [ ^tmp1 ancestry ancestors first name ].  ^nilcollect: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self do: [:arg2 |  tmp1 add: (arg1 value: arg2) ].  ^tmp1postLoadDoIt  ^nilmatchesWorkingCopy: arg1  | tmp1 |  (tmp1 := self packageFilename) == nil ifTrue: [ ^self error: 'cannot match working copy' ].  (self class packageFileName: tmp1 matchesPackageName: arg1 package name) ifTrue: [ arg1 ancestry ancestors isEmpty ifTrue: [ ^true ].        ^self class packageFileName: arg1 ancestry ancestors first name matchesPackageName: self packageName ].  ^falsecurrentlyLoadedClassesInVersion  self versionOrNil ifNotNil: [:arg1 |  ^arg1 currentlyLoadedClassesInVersion ].  ^#()cacheNil  ^MetacelloPlatform current stackCacheFor: #cacheNil at: #key doing: [:arg1 |  | tmp1 |        arg1 at: #key put: nil.        self cacheNil ]testCollectionCacheKey  | tmp1 |  self assert: (Array with: self class with: (Array with: 'faux' with: 'foobar')) equals: (Array with: self class with: (Array with: 'faux' with: 'foobar')).  self deny: (Array with: self class with: (Array with: 'faux' with: 'foobar')) equals: (Array with: self class with: (Array with: 'faux' with: 'foobar' with: 'foobaz')).  self assert: (tmp1 := self collectionCacheKey) identicalTo: 6topParent  self parent == nil ifTrue: [ ^self ].  ^self parent topParentdefaultDirectory  ^self fileDirectoryClass defaulttitle  ^'load'possibleVersions  ^self project symbolicVersionSymbols , (self project versions collect: [:arg1 |  arg1 versionString ])projectMethodSource  ^(self class sourceCodeAt: #project) asStringvalidationReport: arg1  validationReport := arg1noSave  ^self hasOption: 'no-save'goferBranchPackage: arg1 message: arg2  | tmp1 tmp2 |  (file notNil and: [ (self name , '.' , arg1) = self file ]) ifTrue: [ tmp1 := self loader latestPackage: self file fromRepository: self repositorySpecs.        tmp2 := self copy.        tmp1 ~~ nil ifTrue: [ tmp2 file: tmp1.              tmp2 goferCommitPackage: arg2.              ^self ] ].  self loader goferCommitBranchPackage: arg1 using: self repositorySpecs commitMessage: arg2setUpVersionReferences  versionReferences := OrderedCollection new.  versionReferences     add: (GoferVersionReference name: 'GoferBar-dkh.24');     add: (GoferVersionReference name: 'GoferBar-dkh.25');     add: (GoferVersionReference name: 'GoferFoo-dkh.75');     add: (GoferVersionReference name: 'GoferFoo-dkh.104')linearLoadPackageSpecs: arg1 repositories: arg2  self loaderPolicy pushLinearLoadDirectivesDuring: [ super linearLoadPackageSpecs: arg1 repositories: arg2 ] for: selfgetConfigurationUnconditionalLoad: arg1  | tmp1 |  tmp1 := self projectSpec.  Smalltalk at: tmp1 className asSymbol ifPresent: [:arg2 |  arg1 ifFalse: [ ^arg2 ] ].  (tmp1 := self lookupProjectSpecFor: tmp1) projectPackage load.  ^Smalltalk at: tmp1 className asSymbolgetFile  ^nilpackages  packages == nil ifTrue: [ ^super packages ].  ^packagesbaseline300: arg1  < version: '3.0-baseline' imports: #('2.0-baseline')>  arg1 for: #(#attribute1 #attribute2) do: [ arg1           project: 'Extra Project' with: [ arg1                 className: 'ConfigurationOfExtraProject';                 versionString: '1.0-baseline';                 preLoadDoIt: #preloadForProject;                 postLoadDoIt: #postloadForProject;                 loads: #('core');                 yourself ];           yourself.        arg1 group: 'Core' with: #('Extra Project') ]latestPackage: arg1 fromRepository: arg2  | tmp1 |  tmp1 := MetacelloGofer new.  tmp1 disablePackageCache.  (self repositoriesFrom: arg2) do: [:arg3 |  tmp1 repository: arg3 ].  ^([ (GoferPackageReference name: arg1) resolveWith: tmp1 ] on: Error do: [:arg4 |  ^nil ]) nameonUpgradeUseLoaded: arg1  self onUpgrade: [:arg2 :arg3 :arg4 |  (arg1 includes: arg3 baseName) ifTrue: [ arg2 useLoaded ] ifFalse: [ arg2 useIncoming ] ]extractMethodSectionsForClass: arg1  | tmp1 |  tmp1 := self extractBaselinePragmaFor: arg1.  self evaluatePragma: tmp1.  self methodSections do: [:arg2 |  self evaluateBaselineMethodSection: arg2 ]sshPort: arg1  sshPort := arg1removeFromMetacelloPackages: arg1  arg1 addMember: selflabel  ^self printStringfileDirectoryClass  ^FileSystemconfiguration: arg1  configuration := arg1baseline10: arg1  < version: '1.0-baseline'>  arg1 for: #common do: [ arg1 project: 'UTF8' with: [ arg1                 className: 'MetacelloVersionQueryMiscConfig';                 versionString: '1.0-baseline';                 loads: #('Misc-UTF8') ].        arg1           group: 'Core' with: #('UTF8');           group: 'Tests' with: #('UTF8');           group: 'Recursive' with: #('Core' 'Recursive') ]postLoadDoItBlock  ^self doItBlock: self postLoadDoIt valuecurrentlyLoadedClassesInVersion  ^self spec currentlyLoadedClassesInVersionconfiguration: arg1  self addStatement: #configurationArg: args: {arg1}record: arg1  self fetchRecord: [:arg2 |  arg1 isEmpty ifTrue: [ arg2 record ] ifFalse: [ arg2 record: arg1 ] ] required: arg1mergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #repositories put: self repositories.  ^tmp1modifySection: arg1 repository: arg2 requiredProjects: arg3 packages: arg4 dependencies: arg5 includes: arg6 files: arg7 repositories: arg8 preLoadDoIts: arg9 postLoadDoIts: arg10 supplyingAnswers: arg11 groups: arg12 versionSpecsDo: arg13  self modifySection: arg1 sectionIndex: 1 repository: arg2 requiredProjects: arg3 packages: arg4 dependencies: arg5 includes: arg6 files: arg7 repositories: arg8 preLoadDoIts: arg9 postLoadDoIts: arg10 supplyingAnswers: arg11 groups: arg12 versionSpecsDo: arg13projectForVersion: arg1 overrides: arg2  | tmp1 tmp2 |  tmp2 := self project projectSpec     name: arg1;     yourself.  tmp1 := self project projectReferenceSpec     name: arg1;     projectReference: tmp2;     yourself.  self root packages add: tmp1.  self with: tmp2 during: arg2timestamp: arg1  arg1 setTimestampInMetacelloVersion: selfbaseline20MethodSourceFoo  ^(self class sourceCodeAt: #baseline20Foo:) asStringauthorName  Smalltalk at: #Author ifPresent: [:arg1 |  ^arg1 perform: #initials ].  ^'no developer initials'loadData  ^self loaderPolicy loadDatauseLoaded  self disallowversion11: arg1  < version: '1.1' imports: #('1.0-baseline')>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'Example of a complete version specification'.        arg1 author: 'dkh'.        arg1 timestamp: '10/12/2009 09:26'.        arg1           package: 'Example-Core' with: 'Example-Core-anon.15';           package: 'Example-Tests' with: 'Example-Tests-anon.4';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ]incrementPatchVersion  self incrementNormalVersionAt: 3project  ^projectrepositories: arg1  self shouldBeMutable.  repositories := arg1.  self projectPackage: nilrepositorySpecs  ^self repositories map valuestestDirectReturn  | tmp1 |  self assert: (tmp1 := self directReturnOfValue) identicalTo: 6version21Issue283: arg1  < version: '2.1'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1 package: 'GoferFoo' with: 'GoferFoo-lr.4' ]loadingSpecLoader  ^selftearDownPackages: arg1  (self hasPackage: 'GoferFoo') ifTrue: [ arg1 package: 'GoferFoo' ].  (self hasPackage: 'GoferBar') ifTrue: [ arg1 package: 'GoferBar' ].  (self hasPackage: 'GoferFaux') ifTrue: [ arg1 package: 'GoferFaux' ].  (self hasPackage: 'GoferBeau') ifTrue: [ arg1 package: 'GoferBeau' ].  (self hasPackage: 'MetacelloTestConfigurationOfFoo') ifTrue: [ arg1 package: 'MetacelloTestConfigurationOfFoo' ]version131ProjectToolBox: arg1  < version: '1.3.1-baseline'>  arg1 for: #common do: [ arg1 blessing: #baseline ].  arg1 for: #level1_1 do: [ arg1           package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/1' ];           package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/2' ];           package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/3' ].        arg1 for: #level2_1 do: [ arg1 package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/4' ].              arg1 for: #level3_1 do: [ arg1 package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/5' ] ] ].        arg1 for: #level2_2 do: [ arg1 package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/6' ].              arg1 for: #level3_2 do: [ arg1 package: 'Example-Core' with: [ arg1 repository: 'http://www.example.com/7' ] ] ] ]baseline61MethodSourceFix  ^(self class sourceCodeAt: #baseline61Fix:) asStringprojectVersion  | tmp1 |  tmp1 := self versionInfo projectVersion.  tmp1 ifNil: [ tmp1 := self projectSpec versionOrNil.        self versionInfo projectVersion: tmp1 ].  ^tmp1name  name == nil ifTrue: [ name := self extractNameFromFile ].  ^nameexecuteCollection: arg1 do: arg2  arg1 do: [:arg3 |  ((projectSpecGenerator projectSpecLookupBlock value: arg3) select: self projectSpecSelectBlock) do: [:arg4 |  arg2 value: (self applyArgsToProjectSpec: arg4 copy) ] ]extractBaselinePragmaFor: arg1  | tmp1 |  tmp1 := Pragma allNamed: #baseline in: arg1.  tmp1 isEmpty ifTrue: [ ^self error: 'No #baseline pragma found' ].  ^tmp1 firsttestDifference  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := self project.  tmp3 := '1.1-baseline'.  tmp4 := '2.0-baseline'.  tmp5 := (tmp1 version: tmp3) difference: (tmp1 version: tmp4).  tmp5     from: tmp3;     to: tmp4;     configuration: 'Test Configuration'.  tmp2 := 'Test Configuration ''1.1-baseline'' to ''2.0-baseline''	Additions:		UTF9			'''' to ''1.0-baseline''	Modifications:		UTF8			''1.0-baseline'' to ''stable''	Removals:		UTF7			''1.0-baseline'' to '''''.  tmp6 := tmp5 printString.  self assert: tmp2 equals: tmp6load: arg1  ^arg1 loadRequiredForMetacelloMCVersion: selfremovals: arg1  removals := arg1matchesMetacelloGoferPackage: arg1  self error: 'Should not be matching a MetacelloGoferPackage with another MetacelloGoferPackage'addToMetacelloPackages: arg1  arg1 addMember: selftestVersion08  | tmp1 tmp2 |  tmp1 := self versionClass fromString: '1.0a6'.  tmp2 := self versionClass fromString: '1.0a5'.  self assert: tmp1 > tmp2projectVersion: arg1  projectVersion := arg1validateBaselineProject: arg1  | tmp1 tmp2 |  (self visited includes: arg1 configuration class) ifTrue: [ ^self validationReport ].  self visited add: arg1 configuration class.  tmp1 := arg1 version.  tmp2 := tmp1 spec.  [ self validateBaselineVersionSpec: tmp2 ] on: Error do: [:arg2 |  self recordValidationError: 'Error composing version ' , tmp1 versionString printString , ': ' , arg2 description versionString: tmp1 versionString callSite: #validateBaselineProject: reasonCode: #versionCompositionError ].  ^self validationReportbaselineNamed: arg1  | tmp1 |  tmp1 := self baselineNameFrom: arg1.  (Smalltalk includesKey: tmp1 asSymbol) ifFalse: [ self ensureMetacello.        BaselineOf subclass: tmp1 asSymbol instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: tmp1.        MetacelloPlatform current registerPackageNamed: tmp1.        (MetacelloPlatform current globalNamed: tmp1 asSymbol) compile: 'baseline: spec <baseline>' classified: 'baseline' ].  project := (MetacelloPlatform current globalNamed: tmp1 asSymbol) projectrepositories  repositories == nil ifTrue: [ repositories := self project repositoriesSpec ].  ^repositoriesexplicitLoadUsing: arg1  | tmp1 tmp2 |  ((tmp1 := self workingCopy) ~~ nil and: [ tmp1 needsSaving ]) ifTrue: [ (MetacelloSkipDirtyPackageLoad signal: self) ifTrue: [ MetacelloNotification signal: 'Skipping load of modified package: ' , self file.              ^self ] ifFalse: [ MetacelloNotification signal: 'Load over modified package: ' , self file ] ].  tmp2 := arg1 fetchingSpecLoader.  tmp2 explicitLoadPackageSpecs: (Array with: self) repositories: (tmp2 repositoriesFrom: self repositorySpecs)mergeSpec: arg1  | tmp1 |  tmp1 := super mergeSpec: arg1.  tmp1 list: self list copy.  arg1 list do: [:arg2 |  arg2 applyToList: tmp1 ].  ^tmp1password  password == nil ifTrue: [ password := '' ].  ^passwordversion30Issue156: arg1  < version: '3.0.0'>  arg1 for: #common do: [ arg1           configuration: 'Goo' with: [ arg1                 versionString: '5.0.0';                 repository: 'dictionary://Metacello_MczConfiguration_Test_Repository' ];           yourself ]workingCopy  | tmp1 |  cachedVersion == nil ifTrue: [ ^super workingCopy ].  tmp1 := cachedVersion package name.  ^MCWorkingCopy allManagers detect: [:arg1 |  tmp1 = arg1 packageName ] ifNone: [ self error: 'Working copy for ' , self name , ' not found' ]explanation: arg1  explanation := arg1preLoadDo: arg1  name: arg1  name := arg1getPreLoadDoIt  ^preLoadDoItdownloadErrorFileNameFor: arg1  | tmp1 |  tmp1 := self processPID.  ^'/tmp/curl-' , tmp1 , '-' , (arg1 select: [:arg2 |  arg2 isAlphaNumeric ]) , '.err'basicReferencesIn: arg1  ((arg1 isKindOf: MCDictionaryRepository) or: [ arg1 isKindOf: MCDirectoryRepository ]) ifTrue: [ ^super basicReferencesIn: arg1 ].  ^MetacelloPlatform current stackCacheFor: #goferRepository cacheClass: IdentityDictionary at: arg1 doing: [:arg2 |  ^arg2 at: arg1 put: (super basicReferencesIn: arg1) ]baseline40MethodSourceProjectInfinite  ^(self class sourceCodeAt: #baseline40ProjectInfinite:) asStringuseDetermineVersionForLoad  useDetermineVersionForLoad ifNil: [ useDetermineVersionForLoad := true ].  ^useDetermineVersionForLoadexternalBaselineXX: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>externalBaselineXX:'.        arg1           package: 'External-CoreX';           package: 'External-TestsX' with: [ arg1 requires: 'External-CoreX' ];           yourself.        arg1           group: 'Core' with: #('External-CoreX');           group: 'default' with: #('Core');           group: 'Tests' with: #('External-TestsX');           yourself ]goferReferences  ^self localRepository goferReferences collect: [:arg1 |  GoferResolvedReference name: arg1 name repository: self ]packageSpecsInLoadOrder  ^self packages packageSpecsInLoadOrderFor: selfmap  | tmp1 |  memberMap ~~ nil ifTrue: [ ^memberMap ].  tmp1 := Dictionary new.  self list do: [:arg1 |  arg1 applyAdd: [:arg2 |  self mapAdd: arg2 into: tmp1 ] copy: [:arg2 |  self mapCopy: arg2 into: tmp1 ] merge: [:arg2 |  self mapMerge: arg2 into: tmp1 ] remove: [:arg2 |  self mapRemove: arg2 into: tmp1 ] ].  memberMap := tmp1.  ^memberMapsetUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:arg1 |  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: arg1 packageName) info: (MCVersionInfo name: arg1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: arg1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: arg1 packageName asSymbol)) with: (MCClassDefinition name: arg1 packageName asSymbol superclassName: #Object category: arg1 packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]lookupVersion: arg1 ifAbsent: arg2  ^self map at: arg1 ifAbsent: [ (MetacelloVersionDefinitionError project: self project versionString: arg1)           exception: (self errorMap at: arg1 ifAbsent: [ ^arg2 value ]);           signal ]label  ^self namelesson14  ^Lesson title: 'Lesson 14' lesson: 'Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #baseline14:.Smalltalk tools browser openOnClass: MetacelloProjectRefTutorialConfig selector: #version14:."In this lesson we''ll cover the querying API for Metacello. The querying API is useful for analyzing the contents and structure of a version.To start with we''ll look at version ''1.4'' of the MetacelloProjectRefTutorialConfig. You can list the packages in the version:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') packages."The list project references:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') projects."And the groups:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') groups."You can access individual packages/project refs/groups using  the #packageNamed: method. Here you can access the package named: ''Project-Core'':"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Project-Core''."The project reference named ''Example Default'':" (MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Example Default''."The group named ''Core'':" (MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Core''."Each of the attributes of the package can be accessed (#requires, #includes, #file, #repository, #preLoadDoIt, and #postLoadDoit). For example:"  ((MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Project-Core'') requires."Each of the attributes of the project can be accessed (#className, #versionString, #operator, #loads, #file, and #repository). For example:"  ((MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Example Default'') repository."Each of the attributes of the group can be accessed (#includes). For example:"  ((MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''default'') includes."When looking at the ''Core'' group, there is only one package listed:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Core''."In the case of the ''Core'' group, it is defined in terms of the ''default'', which isn''t very useful. When looking at the contents of groups you''d like to see the complete list of packages, without having to explicitly expanding each group you encounter. #packagesForSpecNamed: does just that:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') packagesForSpecNamed: ''Core''."If you were to load the ''Core'' package:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') load: ''Core''."You end up seeing the packages from the Example project. If you want to get the list of packages that _would_ be loaded, you can use #allPackagesForSpecNamed:. For example:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') allPackagesForSpecNamed: ''Core''."If you use #allPackagesForSpecNamed: with a project refernce name, you''ll see the packages that _would_ be loaded:"  (MetacelloProjectRefTutorialConfig project version: ''1.4'') load: ''Example Default''.  (MetacelloProjectRefTutorialConfig project version: ''1.4'') allPackagesForSpecNamed: ''Example Default''."You can also send #version to a project reference. This is useful if you want to explicitly walk the tree of projects:"  ((MetacelloProjectRefTutorialConfig project version: ''1.4'') packageNamed: ''Example Default'') version.ProfStef next.'packages  | tmp1 |  tmp1 := OrderedCollection new.  self loadDirective packageDirectivesDo: [:arg1 |  tmp1 add: arg1 spec ].  ^tmp1compileMethod  (project configuration class compile: self methodSource classified: self category) == nil ifTrue: [ self error: 'Error compiling the method' ]configurationGithubReferenceXX: arg1  < baseline>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configurationGithubReferenceXX:'.        arg1 configuration: 'External' with: [ arg1                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]repositoryForVersion: arg1 username: arg2 password: arg3  self repositoryForSpec: arg1 username: arg2 password: arg3configurationPath  ^'metacello-tests/configuration'configurationArg: arg1  configurationArg := arg1load  self subclassResponsibilityensureLoadedForDevelopmentUsing: arg1  ^truecreateVersion  ^self versionClass fromSpec: selfextractSymbolicVersionSpecsFor: arg1  | tmp1 tmp2 |  tmp1 := self extractSymbolicVersionPragmas at: arg1 ifAbsent: [ ^#() ].  tmp1 size > 1 ifTrue: [ self error: 'More than one pragma defining ' , arg1 printString ].  tmp2 := tmp1 at: 1.  self evaluatePragma: tmp2.  ^self methodSectionsbaseline61MethodSourceFoo  ^(self class sourceCodeAt: #baseline61Foo:) asStringtimestamp  timestamp == nil ifTrue: [ ^self project valueHolderSpec           value: '';           yourself ].  ^timestampextractRepositoryFrom: arg1 to: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := self downloadErrorFileNameFor: arg1.  tmp1 := FileStream forceNewFileNamed: '/tmp/zip.out'.  tmp2 := FileStream forceNewFileNamed: tmp5.  tmp4 := ''.  [ tmp3 := (self class environment at: #OSProcess) thisOSProcess forkJob: '/usr/bin/unzip' arguments: {'-u' .         arg1 .         '-d' .         arg2} environment: nil descriptors: (Array with: nil with: tmp1 with: tmp2).  tmp3 ifNil: [ self noAccessorAvailable ].  [ tmp3 isRunning ] whileTrue: [ (Delay forMilliseconds: 100) wait ] ] ensure: [ tmp1 close.        tmp2 close ].  FileStream fileNamed: tmp5 do: [:arg3 |  (tmp4 := arg3 contentsOfEntireFile) notEmpty ifTrue: [ self error: 'unzip failure: ' , tmp4 printString ] ifFalse: [ (self fileHandleOn: '/tmp')                 deleteFileNamed: arg1;                 deleteFileNamed: tmp5 ] ]searchCacheRepositoryForPackage: arg1  setUpConfigurationOfProjectIssue86  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfProjectIssue86-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self linearProjectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline60ProjectIssue86:' category: 'cat' timeStamp: '' source: self baseline60MethodSourceProjectIssue86) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline61ProjectIssue86:' category: 'cat' timeStamp: '' source: self baseline61MethodSourceProjectIssue86) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline62ProjectIssue86:' category: 'cat' timeStamp: '' source: self baseline62MethodSourceProjectIssue86)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())tutorial  ^#(#lesson01 #lesson02 #lesson03 #lesson04 #lesson05 #lesson06 #lesson07 #lesson08 #lesson10 #lesson11 #lesson11Author #lesson11Blessing #lesson11Descripton #lesson11Timestamp #lesson12DoIts #lesson13)label  ^self namemapAdd: arg1 into: arg2  arg2 at: arg1 name put: arg1 specvalidateProjectVersion: arg1  | tmp1 |  tmp1 := self validateProjectCreationFrom: self configurationClass onError: [:arg2 |  self recordValidationError: 'Error creating project: ' , arg2 description , ' to reproduce evalutate the following: ''' , self configurationClass name asString , ' project''' callSite: #validateProject reasonCode: #projectCreationError.        ^self validationReport ].  ^self validateProject: tmp1 version: arg1baseline: arg1  self addStatement: #baselineArg: args: {arg1}tutorial  ^#(createConfigurationAndBaseline createDevelopmentVersion validateAndSaveConfiguration checkpointSave integrateCodeContributions compareVersions releaseVersion createNewDevelopmentVersion)useExisting  self disallow< arg1  arg1 species = self species ifFalse: [ ^false ].  ^self versionNumber < arg1 versionNumberremoveGroup: arg1  self root removeGroup: arg1 constructor: selfpackage: arg1  self root package: arg1 constructor: selfversionClass  ^MetacelloMCVersionasAttributeOrPath  self size = 1 ifTrue: [ | tmp1 |        tmp1 := self at: 1.        ^tmp1 size = 1 ifTrue: [ tmp1 at: 1 ] ifFalse: [ tmp1 ] ].  ^selfrepositoriesFrom: arg1 ignoreOverrides: arg2  | tmp1 tmp2 |  (arg2 not and: [ self hasRepositoryOverrides ]) ifTrue: [ ^self loaderPolicy overrideRepositories ].  tmp1 := MCRepositoryGroup default repositories.  tmp2 := OrderedCollection new.  arg1 do: [:arg3 |  | tmp3 tmp4 |        tmp3 := arg3 description.        (tmp4 := tmp1 detect: [:arg4 |  arg4 description = tmp3 ] ifNone: [ arg3 createRepository ]) ~~ nil ifTrue: [ tmp2 add: tmp4 ] ].  ^tmp2setUpConfigurationOfFoo  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfFoo-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'bleedingEdgeVersion:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #bleedingEdgeVersion:) asString) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline20Foo:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline30Foo:' category: 'cat' timeStamp: '' source: self baseline30MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline35Foo:' category: 'cat' timeStamp: '' source: self baseline35MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40Foo:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline50Foo:' category: 'cat' timeStamp: '' source: self baseline50MethodSourceFoo) .   (MCMethodDefinition className: tmp2 asString selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: self preloadDoItMethodSource)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())preLoadDoIt: arg1 constructor: arg2  arg2 preLoadDoItForPackage: arg1disallow  self resume: self existingProjectRegistrationloadPackageDirective: arg1 gofer: arg2  arg1 loader loadingSpecLoader loadPackageDirective: arg1 gofer: arg2updateProject: arg1  | tmp1 |  (tmp1 := self loader) == nil ifTrue: [ tmp1 := self project loaderClass on: nil ].  tmp1 loaderPolicy: arg1.  tmp1 doingLoads: [ MCWorkingCopy managersForClass: self configuration class do: [:arg2 |  | tmp2 tmp3 |              tmp2 := self packageSpec.              arg2 repositoryGroup repositories do: [:arg3 |  tmp2 repositories repository: (arg3 asRepositorySpecFor: self) ].              tmp3 := arg2 metacelloPackageNameWithBranch.              tmp2 name: (tmp3 at: 1).              (tmp3 at: 2) notEmpty ifTrue: [ tmp2 file: (tmp3 at: 2) ].              tmp2 load.              ^true ] ].  ^truefinalizeLoad: arg1  | tmp1 |  self preloads do: [:arg2 |  super loadPreloadDirective: arg2 ].  preloads := nil.  (tmp1 := self packageloads) notEmpty ifTrue: [ self loader loadingSpecLoader loadPackageDirectives: tmp1 gofer: arg1.        self packageloads: nil ].  self postloads do: [:arg2 |  super loadPostloadDirective: arg2 ].  postloads := nilonDowngrade: arg1  self options at: #onDowngrade put: arg1resolvePackageSpecReferences: arg1 gofer: arg2  | tmp1 tmp2 tmp3 |  tmp3 := arg2.  self hasRepositoryOverrides not ifTrue: [ arg1 repositorySpecs notEmpty ifTrue: [ tmp3 := MetacelloGofer new.              (self repositoriesFrom: arg1 repositorySpecs) do: [:arg3 |  tmp3 repository: arg3 ] ] ].  (arg1 getFile == nil or: [ self shouldDisablePackageCache ]) ifTrue: [ tmp3 disablePackageCache ].  tmp1 := arg1 goferLoaderReference.  tmp2 := tmp1 resolveAllWith: tmp3.  tmp3 enablePackageCache.  ^tmp2unregister  actionArg := #unregister -> #()testRemoveC  | tmp1 tmp2 |  tmp1 := self repositoriesSpec.  tmp1 add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  tmp1 remove: {'http://example.com/repository'}.  tmp2 := false.  tmp1 map at: 'http://example.com/repository' ifAbsent: [ tmp2 := true ].  self assert: tmp2loadPackageDirectives: arg1 gofer: arg2  interactiveCommit  ^self execute: MetacelloGoferCommitaddToMetacelloRepositories: arg1  arg1 addMember: selfproject  ^project ifNil: [ (self class baseConfigurationClassIfAbsent: [  ]) ensureMetacello.        project := MetacelloMCProject new projectAttributes: self customProjectAttributes.        (Smalltalk at: #MetacelloVersionConstructor) on: self project: project.        project loadType: #linear.        project ]specListDetect: arg1  ^self specListDetect: arg1 ifNone: [ self error: 'Object is not in the collection.' ]loadUsing: arg1 gofer: arg2  arg1 loadPostloadDirective: selfopen11ForDevelopment  ^Lesson title: 'Open version 1.1 for development' lesson: '"	1. Create configuration	2. Prepare to define version method #version11:	3. Use version 1.0 as basis for version 1.1. basically a copy. Differs from import.	4. Update project and package versions		- with #updateProjects set to true, the current version of the project Shout will set		- with #updatePackages set to true, the current mcz files for the packages ProfStef-Core ProfStef-Tests will be set	5. Define desired versionSpec attributes		- current author and timestamp		- set blessing to #development		- set the description	6. Compile and validate the #version11: method	7. Prepare to modify symbolic version method #development:		- keep all of the existing symbolic version specs in the method	8. Define/change the symbolic version for #development to 1.1	9. Compile and validate the #development: method"		| description |	description := ''''."1."	(MetacelloToolBox configurationNamed: ''Example'')"2."		createVersionMethod: ''version11:'' inCategory: ''versions'' forVersion: ''1.1'';"3."		addSectionsFrom: ''1.0''			forBaseline: false"4."			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ "5."						versionSpec							author: MetacelloPlatform current authorName;							description: description;							blessing: #development;							timestamp: MetacelloPlatform current timestamp ].				true ];"6."		commitMethod;"7."		modifySymbolicVersionMethodFor: #development symbolicVersionSpecsDo: [ :symbolicVersionSpec | true ];"8."		addSymbolicSection: #common version: ''1.1'';"9."		commitMethod."After evaluating the above expression, take a look at the generated methods:	- #version11:	- #development:"ProfStef next.'removePackage: arg1  self root removePackage: arg1 constructor: selfversion13: arg1  < version: '1.3' imports: #('1.2-baseline')>  arg1 for: #common do: [ arg1 blessing: #beta.        arg1 description: 'Import functionality from the example project, different packages'.        arg1           package: 'Project-Core' with: 'Project-Core-anon.1';           package: 'Project-Tests' with: 'Project-Tests-anon.1';           project: 'Example Default' with: '1.3';           project: 'Example Tests' with: '1.3' ]addMethodSection: arg1 versionString: arg2  self methodSections add: (MetacelloSymbolicVersionSpec new           attributes: arg1 asMetacelloAttributeList;           versionString: arg2;           yourself)specListProjectDo: arg1 packageDo: arg2 groupDo: arg3  self packages specListDo: [:arg4 |  arg4 projectDo: arg1 packageDo: arg2 groupDo: arg3 ]symbolicVersionMethod: arg1  (self hasMethodForSymbolicVersion: arg1) ifTrue: [ self modifySymbolicVersionMethodFor: arg1 ] ifFalse: [ self createSymbolicVersionMethod: arg1 asString , ':' inCategory: 'symbolic versions' forVersion: arg1 ]matches: arg1  | tmp1 |  ((tmp1 := self packageFilename) == nil or: [ self name = self packageFilename ]) ifTrue: [ ^super matches: arg1 ].  arg1 name = tmp1 ifTrue: [ ^true ].  (arg1 name beginsWith: tmp1) ifFalse: [ ^false ].  ^arg1 matchesMetacelloGoferPackage: selfbaseline20Fan: arg1  < version: '2.0'>  arg1 for: #common do: [ arg1 repository: 'dictionary://Metacello_Gofer_Test_Repository'.        arg1           project: 'Foo' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '2.0';                 loads: #('GoferFaux' 'GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           project: 'Far' with: [ arg1                 className: 'MetacelloTestConfigurationOfFoo';                 versionString: '2.0';                 loads: #('GoferBeau');                 file: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself ]signal  self messageText: self description.  ^super signalscheduleFetchFor: arg1 nearestReference: arg2  ^self scheduleFetchFor: arg1 reference: arg2 message: 'Fetched -> (nearest) ' , arg2 name , ' --- ' , arg2 repository repositoryDescription , ' --- ' , arg2 repository descriptionregisterProject  self class registry registerProjectRegistration: selfparentDirectoryOf: arg1  ^arg1 parentasConfigurationProjectSpec  ^selfcreate11Baseline  ^Lesson title: 'Create 1.1 Baseline' lesson: '"	1. Create configuration	2. Prepare to define baseline version method	3. Copy specs from 1.0-baseline. This is a copy not an import, so all specs are preserved		- with #updateProjects set to false, the version of the project Shout is preserved		- with #updatePackages set to false, the specification of the mcz files for the packages ProfStef-Core ProfStef-Tests are preserved (typically not specified)	4. Add and additional section for the attribute #pharo		- the package ProfStefBrowser and it''s dependencies are added		- the package is added to the UI group	5. Compile and validate #baseline11: method	6. Prepare to modify the method defining version 1.1.		- false as return value in block means that all existing version specs in 1.1 are dropped on floor. Basically just the method name and pragma are preserved	7. Import the versionSpecs from 1.1-baseline into version 1.1	8. Compile and validate the #version11: method	9. Prepare to modify the method defining symbolic version #development. Preserve existing symbolic version specs	10.  add symbolic version spec for #pharo	11. Compile and validate the #development: method"		| description |	description := ''''."1."	(MetacelloToolBox configurationNamed: ''Example'')"2"		createVersionMethod: ''baseline11:'' inCategory: ''baselines'' forVersion: ''1.1-baseline'';"3."		addSectionsFrom: ''1.0-baseline''			forBaseline: true			updateProjects: false			updatePackages: false			versionSpecsDo: [ :attribute :versionSpec | true ];"4"		addSection: #pharo			repository: nil			requiredProjects: #()			packages: #(''ProfStefBrowser'')			dependencies: {(''ProfStefBrowser'' -> #(''ProfStef-Core''))}			groups: {(''UI'' -> #(''ProfStefBrowser''))}			versionSpecsDo: [ :versionSpec |  ];"5."		commitMethod;"6."		modifyVersionMethodForVersion: ''1.1'' versionSpecsDo: [ :attribute :versionSpec | false ];"7."		importFrom: ''1.1-baseline''			updateProjects: true			updatePackages: true			versionSpecsDo: [ :attribute :versionSpec | 				attribute == #common					ifTrue: [ 						"update the author, blessing and timeStamp"						versionSpec							author: MetacelloPlatform current authorName;							blessing: #development;							description: description;							timestamp: MetacelloPlatform current timestamp ].				true ];"8."		commitMethod;"9"		modifySymbolicVersionMethodFor: #development symbolicVersionSpecsDo: [ :symbolicVersionSpec | true ];"10."	addSymbolicSection: #pharo version: ''1.1'';"11."	commitMethod."Look at the generated methods: 	#baseline11:	#version11:	#development:"	ProfStef next.'loadingSpecLoader  ^selfproject: arg1 overrides: arg2  self root project: arg1 overrides: arg2 constructor: selfrecord  ^self execute: #record: args: #(#())isSomethingLoaded  self isPartiallyCurrent isSomethingLoaded: [:arg1 |  ^true ].  ^falsedoRecordRequiredFromArray: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloNotification signal: 'Recording ' , tmp3 , '...'.  tmp1 := self versionSpec loader.  tmp2 := loaderPolicy.  tmp4 := MetacelloPlatform current bypassProgressBars.  self loaderPolicy silently ifTrue: [ MetacelloPlatform current bypassProgressBars: true ].  [ MetacelloPlatform current do: [ | tmp5 |        self versionSpec loader: tmp1 recordingSpecLoader.        tmp5 := (self executeLoadFromArray: arg1) copy.        MetacelloNotification signal: '...finished ' , self versionNumber printString.        ^tmp5 ] displaying: 'Recording ' , tmp3 ] ensure: [ MetacelloPlatform current bypassProgressBars: tmp4.        self versionSpec loader: tmp1.        loaderPolicy := tmp2 ]compareEqual: arg1  ^self className = arg1 className and: [ (self compareVersionsEqual: arg1) and: [ self operator == arg1 operator and: [ self loads = arg1 loads and: [ self preLoadDoIt value == arg1 preLoadDoIt value and: [ self postLoadDoIt value == arg1 postLoadDoIt value ] ] ] ] ]conflictOf21: arg1  < version: '2.1.0'>  arg1 for: #common do: [ arg1 blessing: #development.        arg1 description: 'MetacelloScriptingResource>>conflictOf21:'.        arg1 author: 'dkh'.        arg1 timestamp: '6/1/2012 14:46' ].  arg1 for: #custom do: [ arg1 configuration: 'ExternalX' with: [ arg1                 operator: #=;                 version: '0.9.1';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]projectWith: arg1  | tmp1 |  tmp1 := MetacelloProject new.  tmp1 projectAttributes: arg1.  MetacelloVersionConstructor on: self project: tmp1.  ^tmp1hash  | tmp1 tmp2 tmp3 |  (tmp1 := self size) == 0 ifTrue: [ ^15243 ].  tmp2 := (tmp1 - 1) // 4 max: 1.  tmp3 := 4459.  1 to: tmp1 by: tmp2 do: [:arg1 |  | tmp4 |        tmp4 := self at: arg1.        (tmp4 isKindOf: SequenceableCollection) ifTrue: [ tmp3 := (tmp3 bitShift: -1) bitXor: tmp4 size ] ifFalse: [ tmp3 := (tmp3 bitShift: -1) bitXor: tmp4 hash ] ].  ^tmp3 absregisterPackageNamed: arg1  ^(Smalltalk at: #PackageInfo) registerPackageName: arg1onDowngrade: arg1  self addStatement: #onDowngrade: args: {arg1}checkInputForInstallSubcommand  (self isBaselineName and: [ self hasVersion ]) ifTrue: [ Exit signalFailure: 'A baseline can not be used with --version option.' ].  (self isBaselineName or: [ self isConfigurationName ]) ifFalse: [ Exit signalFailure: 'Not a Baseline nor a Configuration.' ]shouldDisablePackageCache: arg1  disablePackageCache := arg1repository  self deprecated: 'Use repositories or repositorySpecs'.  self repositorySpecs isEmpty ifTrue: [ ^nil ].  ^self repositorySpecs firstspotterForPackagesFor: arg1  < spotterOrder: 3>  arg1 listProcessor     title: 'Packages';     allCandidates: [ self packages ];     itemName: [:arg2 |  arg2 file ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: truemethodSelectorAndPragma: arg1 imports: arg2 versionString: arg3 on: arg4  arg4     nextPutAll: arg1 asString , ' spec';     cr;     tab;     nextPutAll: '<version: ' , arg3 printString.  arg2 notEmpty ifTrue: [ arg4 nextPutAll: ' imports: #('.        arg2 do: [:arg5 |  arg4                 nextPutAll: arg5 printString;                 space ].        arg4 nextPut: $) ].  arg4     nextPutAll: '>';     crreferencedSpec  ^self projectReferencemodifyVersionMethodForVersion: arg1  ^self modifyVersionMethodForVersion: arg1 versionSpecsDo: [:arg2 :arg3 |  true ]name: arg1  self root name: arg1 constructor: selftestCopyToGroup  | tmp1 tmp2 |  tmp1 := self packagesSpec.  tmp1 add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself).  tmp1 merge: (self groupSpec           name: 'Platform';           includes: 'Tests';           yourself).  tmp2 := tmp1 packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (tmp2 includes includes: 'Core').  self assert: (tmp2 includes includes: 'Tests').  tmp2 := self groupSpec     name: 'PlatformCopy';     includes: 'Copy';     yourself.  tmp1 copy: 'Platform' to: tmp2.  tmp2 := tmp1 packageNamed: 'PlatformCopy' ifAbsent: [ self assert: false ].  self assert: (tmp2 includes includes: 'Core').  self assert: (tmp2 includes includes: 'Copy').  self assert: (tmp2 includes includes: 'Tests')metacelloRegistrationHash  ^((self map values sort: [:arg1 :arg2 |  arg1 description <= arg2 description ]) collect: [:arg3 |  arg3 description ]) hashensureMetacello  compareVersions: arg1 usingOperator: arg2  ^arg1 versionOrNil == nil ifTrue: [ arg1 versionString asMetacelloVersionNumber perform: arg2 with: self version versionNumber ] ifFalse: [ ^arg1 version perform: arg2 with: self version ]ancestorsFor: arg1  ^self loadData ancestorsFor: arg1 ifAbsent: [ super ancestorsFor: arg1 ]for: arg1  self shouldBeMutable.  project := arg1requires  requires == nil ifTrue: [ requires := #() ].  ^requiresfetch  ^self doFetchRequiredFromArray: self spec defaultPackageNamescomputeVersionStatus  ^#noStatusrepositoryArg  ^repositoryArgresolveSpec: arg1 with: arg2  ^arg1 goferLoaderReference resolveWith: arg2projectClass  ^MetacelloMCBaselineProjectsetUpMarianosImage  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GoferVersionReference name: 'MarianosImage-dkh.1'.  tmp2 := #MarianosImage.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp1 packageName asSymbol)) .   (MCClassDefinition name: tmp2 superclassName: #ConfigurationOf category: tmp1 packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'versionOfMariano:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionOfMariano:) asString) .   (MCMethodDefinition className: tmp2 asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (tmp4 := MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #()).  ^tmp4group: arg1 with: arg2  self root group: arg1 with: arg2 constructor: selfrecurse  recurse == nil ifTrue: [ recurse := false ].  ^recursenonOverridable  ^#()load: arg1  ^self subclassResponsibilitylockConfiguration13: arg1  < version: '1.3.0'>  arg1 for: #common do: [ arg1 blessing: #release.        arg1 description: 'MetacelloScriptingResource>>lockConfiguration13: '.        arg1 configuration: 'ExternalX' with: [ arg1                 version: #stable;                 repository: 'dictionary://Metacello_Config_Test_Repository' ] ]lesson05  ^Lesson title: 'Lesson 5' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version05:."For version 0.5 we''ve added an additional package to the mix: ''Example-AddOn'':"  (MetacelloTutorialConfig project version: ''0.5'') spec."Of course, the point of specifiying packages in Metacello is to be able to load versions. Here area couple examples of loading versions of the Tutorial. If you print the result of each expression, you will see the list of packages in load order (note that for the tutorial, we are using the MetacelloNullRecordingMCSpecLoader. This class records which packages are loaded and the order that they are loaded in among other things instead of actually loading the packages."  (MetacelloTutorialConfig project version: ''0.1'') load.  (MetacelloTutorialConfig project version: ''0.4'') load.  (MetacelloTutorialConfig project version: ''0.5'') load."You will note that in each case, all of the packages associated with the version are loaded, which is the default. If you want to load a subset of the packages in a project, you may list the packages that youare interested in as an argument to the #load: method:"  (MetacelloTutorialConfig project version: ''0.5'') load: { ''Example-Tests''. ''Example-Core'' }."Note that the ordering of the packages is based on the order in which the packages are specified.If you evaluate the following expression:"  (MetacelloTutorialConfig project version: ''0.5'') load: { ''Example-Tests''. }."Only the package is ''Example-Tests''. By default the packages are ordered, but there are no implicitdependencies."ProfStef next.'baseline25MethodSourceFoo  ^(self class sourceCodeAt: #baseline25Foo:) asStringmergeMap  | tmp1 |  tmp1 := super mergeMap.  tmp1 at: #value put: value.  ^tmp1setBaselineRepositoryDescription: arg1  arg1 do: [:arg2 |  self version spec repository: arg2 ]sampleRepository  ^sampleRepositoryaProjectNotLoaded: arg1  aProjectNotLoaded := arg1baseline20MethodSourceFoo  ^(self class sourceCodeAt: #baseline20Foo:) asStringstableVersion283A: arg1  < symbolicVersion: #stable>  arg1 for: #common version: '2.0'setUpConfigurationOfFum  | tmp1 tmp2 tmp3 |  tmp1 := GoferVersionReference name: 'MetacelloTestConfigurationOfFum-dkh.1'.  tmp2 := tmp1 packageName asSymbol.  tmp3 := {(MCOrganizationDefinition categories: (Array with: tmp2)) .   (MCClassDefinition name: tmp2 superclassName: #Object category: tmp2 instVarNames: #() comment: '') .   (MCMethodDefinition className: tmp2 asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: tmp2 asString selector: 'baseline40ProjectFum:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceProjectFum)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: tmp1 packageName) info: (MCVersionInfo name: tmp1 name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: tmp1 author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: tmp3) dependencies: #())version109ProjectToolBox: arg1  < version: '1.0.9-baseline'>  arg1 for: #common do: [ arg1           package: 'Example-Core';           package: 'Example-Tests' with: [ arg1 includes: #('Example-Core') ] ]isPartiallyLoaded: arg1  | tmp1 |  (tmp1 := self versionOrNil) == nil ifTrue: [ ^false ].  (self loadListForVersion: tmp1) do: [:arg2 |  (tmp1 packagesForSpecNamed: arg2) do: [:arg3 |  (arg3 isPackageLoaded: arg1) ifTrue: [ ^true ] ] ].  ^falseconfigMethodCascadeOn: arg1 member: arg2 last: arg3 indent: arg4  self subclassResponsibilitysetDefaultsAndValidateProjectSpec  self setDefaultsAndValidate: self projectSpecconfigurationClass: arg1  configurationClass := arg1isPackageLoaded: arg1  ^(self workingCopyNameFor: arg1) ~~ nilcurrentVersionInfoFor: arg1 ifAbsent: arg2  ^self versionInfoMap at: arg1 file ifPresent: [:arg3 |  arg3 first ] ifAbsent: [ self packageNameMap at: arg1 name ifPresent: [:arg3 |  arg3 first ] ifAbsent: arg2 ]on: arg1  self calculate: arg1 project: nilisAllLoadedToSpec: arg1  (self evaluateStatus: #(#allLoadedToSpec)) ifTrue: [ ((hasNoPackage or: [ aPackageIsLoaded & aPackageNotLoaded not & aLoadedPackageIsExact & aLoadedPackageIsNotCurrent not & aLoadedPackageIsCurrent not ]) and: [ hasNoProject or: [ aProjectIsLoaded & aProjectNotLoaded not & aLoadedProjectIsExact & aLoadedProjectIsNotCurrent not & aLoadedProjectIsCurrent not ] ]) ifTrue: [ arg1 value: #allLoadedToSpec ] ]postCopy  super postCopy.  projectReference := projectReference copydecrementPatchVersion  self decrementNormalVersionAt: 3nameForProject: arg1  self root name: arg1requires: arg1 constructor: arg2  arg2 requiresForPackage: arg1isWarning  ^falseevaluateBaselineMethodSection: arg1  | tmp1 |  tmp1 := self project versionSpec.  arg1 versionSpec: tmp1.  currentSection := arg1.  self with: tmp1 during: arg1 block.  arg1 methodSections do: [:arg2 |  self evaluateBaselineMethodSection: arg2 ]handleUpgrade: arg1  ^(self options at: #onUpgrade ifAbsent: [ ^arg1 pass ]) cull: arg1 cull: arg1 existingProjectRegistration cull: arg1 newProjectRegistrationrecordValidationWarning: arg1 versionString: arg2 callSite: arg3 reasonCode: arg4  < haltOrBreakpointForTesting>  (self warningReasonCodes includes: arg4) ifFalse: [ self error: 'Unknown warning reason code' ].  ((self exludededValidations at: arg2 ifAbsent: [ #() ]) includes: arg4) ifTrue: [ ^self ].  (self debug includes: #warning) ifTrue: [ self halt: 'Debug triggered for critical warning: ' , arg1 ].  self validationReport add: (MetacelloValidationWarning configurationClass: (self recurse ifTrue: [ self configurationClass ] ifFalse: [ nil ]) reasonCode: arg4 callSite: arg3 explanation: arg1)attributePrintString  | tmp1 |  tmp1 := WriteStream on: String new.  self attributes size = 1 ifTrue: [ tmp1 nextPutAll: '#' , attributes first asString printString ] ifFalse: [ tmp1 nextPutAll: '#('.        self attributes do: [:arg1 |  tmp1                 nextPutAll: '#' , arg1 asString printString;                 space ].        tmp1 nextPut: $) ].  ^tmp1 contentsversionDirectivesDo: arg1  arg1 value: self.  self loadDirectives do: [:arg2 |  arg2 versionDirectivesDo: arg1 ]symbolicVersionExplicitlyDoesNotExistProjectToolBox: arg1  < symbolicVersion: #'explicitly does not exist'>  arg1 for: #common version: #notDefinedhandleConflict: arg1  ^(self options at: #onConflict ifAbsent: [ ^arg1 pass ]) cull: arg1 cull: arg1 existingProjectRegistration cull: arg1 newProjectRegistrationadd: arg1  arg1 addToMetacelloPackages: selfrequires: arg1  self shouldNotImplementunloadClasses: arg1  do: arg1  self dataMap valuesDo: [:arg2 |  arg1 value: (arg2 at: 1) value: (arg2 at: 2) value: (arg2 at: 3) ]load: arg1  actionArg := #load: -> {arg1}versionClass  ^MetacelloVersionNumberprepostLoadDirectivesDo: arg1  self preloads do: [:arg2 |  arg2 prepostLoadDirectivesDo: arg1 ].  self loadDirectives do: [:arg2 |  arg2 prepostLoadDirectivesDo: arg1 ].  self postloads do: [:arg2 |  arg2 prepostLoadDirectivesDo: arg1 ]testValueHolderSpec  | tmp1 |  tmp1 := self valueHolderSpec     value: 'an Object';     yourself.  self assert: tmp1 value equals: 'an Object'projectSpec  ^self projectSpecClass for: selfconfiguration095Issue185: arg1  < version: '0.9.5'>  arg1 for: #common do: [ arg1 description: 'MetacelloScriptingResource>>configuration095Issue185:'.        arg1           baseline: 'External' with: [ arg1 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA2 , '/repository' ];           import: 'External' ]