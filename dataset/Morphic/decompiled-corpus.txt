repelsMorph: arg1 event: arg2  (arg1 wantsToBeDroppedInto: self) ifFalse: [ ^false ].  self dropEnabled ifFalse: [ ^true ].  (self wantsDroppedMorph: arg1 event: arg2) ifFalse: [ ^true ].  ^super repelsMorph: arg1 event: arg2name  ^self item namefillStyle: arg1  backgroundColor := arg1 asColor.  super fillStyle: arg1hShowScrollBar  self hIsScrollbarShowing ifTrue: [ ^self ].  self hResizeScrollBar.  self privateAddMorph: hScrollBar atIndex: 1.  self resetExtentallMorphsDo: arg1  super allMorphsDo: arg1.  worldState handsReverseDo: [:arg2 |  arg2 allMorphsDo: arg1 ]doActivate  self subclassResponsibilityparentNode: arg1  parentNode := arg1actualScreenSize  self subclassResponsibilitynewEditableDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 ghostText: arg6 getEnabled: arg7 help: arg8  ^self theme newEditableDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: String default: '' ghostText: arg6 getEnabled: arg7 useIndex: false help: arg8useFindReplaceSelection  ^TextEditor useFindReplaceSelectionnewLabel: arg1  ^self newLabelFor: nil label: arg1 getEnabled: niladdCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  arg1 addLine.  arg1 addUpdating: #autoGradientString selector: #toggleAutoGradient.  self isFloating ifFalse: [ arg1 addUpdating: #fillsOwnerString selector: #toggleFillsOwner.        arg1 addUpdating: #avoidVisibleBordersAtEdgeString selector: #toggleAvoidVisibleBordersAtEdge ]highlightRowIndexes: arg1  self deprecated: 'Use #highlightIndexes: instead' transformWith: '`@receiver highlightRowIndexes: `@statements1' -> '`@receiver highlightIndexes: `@statements1'.  self highlightIndexes: arg1restoreSavedPatchOn: arg1  | tmp1 |  hasChanged := false.  savedPatch ifNotNil: [ arg1 drawImage: savedPatch at: savedPatch offset.        submorphs notEmpty ifTrue: [ ^self ].        (temporaryCursor notNil and: [ hardwareCursor isNil ]) ifTrue: [ ^self ].        super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset) from: self.        tmp1 := hardwareCursor ifNil: [ Cursor normal ].        tmp1 isCurrent ifFalse: [ tmp1 show ].        savedPatch := nil ]defaultAttachmentPointSpecs  ^{{#firstVertex} .   {#midpoint} .   {#lastVertex}}valueParameter  ^valueParameterdefaultWidth  ^22target: arg1  defaultTarget := arg1verticalScrollBarValue: arg1  self hasDataSource ifFalse: [ ^self ].  showIndex := self verticalScrollBarValueToRowIndex: arg1.  self container changedvResizing: arg1  self assureLayoutProperties vResizing: arg1.  self layoutChangedcellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTIndentedCellMorph new.  tmp2 indentBy: tmp1 depth * 16.  tmp2 addMorphBack: (self buttonFor: tmp1).  tmp2 addMorphBack: (self toString: tmp1 data) asMorph.  ^tmp2rowMorphFor: arg1  | tmp1 |  tmp1 := self rowMorphGetSelector ifNil: [ arg1 rowMorphForColumn: self ] ifNotNil: [ self rowMorphGetterBlock value: arg1 value: self container ].  tmp1 := tmp1 asMorph.  tmp1 ifNotNil: [ tmp1 borderWidth: 0 ] ifNil: [ tmp1 := self defaultRowMorph ].  ^tmp1 rowMorphForNode: arg1 inColumn: selflayoutInset  ^self layoutProperties ifNil: [ 0 ] ifNotNil: [:arg1 |  arg1 layoutInset ]over: arg1  over := arg1.  self changedcontents  ^self target perform: nameSelectoraddSubmorphsFromNodeList: arg1 previouslyExpanded: arg2  | tmp1 |  tmp1 := OrderedCollection new.  self addMorphsTo: tmp1 from: arg1 withExpandedItems: arg2 atLevel: 0.  self insertNewMorphs: tmp1.  self listManager updateSelectionFromModel.  self roots do: [:arg3 |  arg3 updateChildrenRecursively ].  self updateColumnMorphsisWorldOrHandMorph  ^self isWorldMorph or: [ self isHandMorph ]closeBoxClicked  owner ifNotNil: [:arg1 |  arg1 delete ]numSelectionsInView  ^scroller numberOfItemsPotentiallyInViewisHandMorph  ^falsebottomVisibleRowForCanvas: arg1 startingAt: arg2  ^self rowAtLocation: arg1 clipRect bottomRight startingAt: arg2testIsAfterColumn  self deny: (strategy is: 3 afterColumn: 4).  self deny: (strategy is: 3 afterColumn: 3).  self deny: (strategy is: 3 afterColumn: 2)newToolbarHandle  ^self theme newToolbarHandleIn: selfoldSize  ^oldSizeresetListSelectionSilently  self resetListSelector ifNotNil: [:arg1 |  self model perform: arg1 ]mouseEnterDragging: arg1  | tmp1 tmp2 |  self enabled ifFalse: [ ^self ].  tmp1 := self rowAtLocation: arg1 position.  (self dragEnabled or: [ arg1 hand hasSubmorphs ]) ifFalse: [ tmp1 = 0 ifTrue: [ ^self ].        self listMorph mouseDownRow: tmp1 ].  (arg1 hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: arg1 ].  potentialDropRow = tmp1 ifTrue: [ ^self ].  tmp2 := potentialDropRow.  potentialDropRow := tmp1.  arg1 hand newMouseFocus: self.  (self wantsDroppedMorph: arg1 hand firstSubmorph event: arg1) ifTrue: [ self changed ] ifFalse: [ (tmp2 ifNil: [ 0 ]) > 0 ifTrue: [ self resetPotentialDropRow ] ifFalse: [ potentialDropRow := 0 ] ]drawSubmorphsOnAthensCanvas: arg1  | tmp1 |  submorphs isEmpty ifTrue: [ ^self ].  tmp1 := [:arg2 |  | tmp2 |  (self topVisibleRowForCanvas: arg1) to: (self bottomVisibleRowForCanvas: arg1) do: [:arg3 |  tmp2 := self item: arg3.        arg2 fullDrawMorph: tmp2 ] ].  self clipSubmorphs ifTrue: [ arg1 clipBy: (arg1 clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: tmp1 ] ifFalse: [ tmp1 value: arg1 ]linkSubmorphsToSplitters  self splitters do: [:arg1 |  arg1 splitsTopAndBottom ifTrue: [ self submorphsDo: [:arg2 |  (arg2 ~= arg1 and: [ arg2 layoutFrame bottomFraction = arg1 layoutFrame topFraction ]) ifTrue: [ arg1 addLeftOrTop: arg2 ].                    (arg2 ~= arg1 and: [ arg2 layoutFrame topFraction = arg1 layoutFrame bottomFraction ]) ifTrue: [ arg1 addRightOrBottom: arg2 ] ] ] ifFalse: [ self submorphsDo: [:arg2 |  (arg2 ~= arg1 and: [ arg2 layoutFrame rightFraction = arg1 layoutFrame leftFraction ]) ifTrue: [ arg1 addLeftOrTop: arg2 ].                    (arg2 ~= arg1 and: [ arg2 layoutFrame leftFraction = arg1 layoutFrame rightFraction ]) ifTrue: [ arg1 addRightOrBottom: arg2 ] ] ] ]vScrollbarShowWhenNeeded  self vScrollbar showWhenNeeded.  self updateScrollbarscomputeBounds  [ self doLayoutIn: self layoutBounds ] on: Error do: [:arg1 |  fullBounds := bounds.        arg1 pass ]hash  ^firstIndex hash bitXor: lastIndex hashunexpandedFrame: arg1  ^self setProperty: #unexpandedFrame toValue: arg1wantsDroppedObject: arg1  ^model wantsDroppedNode: arg1 on: selfitemClass  ^self parentNode parentNode itemnotExpandedFormForMorph: arg1  ^(self selectedMorph = arg1 and: [ self theme selectionColor luminance < 0.6 ]) ifTrue: [ self theme whiteTreeUnexpandedForm ] ifFalse: [ self theme treeUnexpandedForm ]addHand: arg1  arg1 owner ifNotNil: [ arg1 owner removeHand: arg1 ].  worldState addHand: arg1.  arg1 privateOwner: selfsearchText: arg1  arg1 isEmptyOrNil ifTrue: [ ^#() ].  self elements withIndexDo: [:arg2 :arg3 |  (arg2 name beginsWith: arg1) ifTrue: [ ^{arg3} ] ].  ^#()addMorphsAfter: arg1 fromCollection: arg2  | tmp1 tmp2 tmp3 |  tmp1 := nil.  tmp2 := OrderedCollection new.  arg2 do: [:arg3 |  tmp1 := self indentingItemClass new initWithContents: arg3 prior: tmp1 forList: self indentLevel: arg1 indentLevel + 1.        tmp2 add: tmp1.        tmp1 isExpanded ifTrue: [ tmp1 isExpanded: true.              tmp1 addChildrenForList: self addingTo: tmp2 withExpandedItems: #() ] ].  1 to: tmp2 size do: [:arg4 |  | tmp4 |        (tmp4 := tmp2 at: arg4) index: arg4 + arg1 index ].  scroller addAllMorphs: tmp2 after: arg1.  tmp3 := self allNodeMorphs.  tmp2 last index to: tmp3 size do: [:arg5 |  (tmp3 at: arg5) index: arg5 ].  self updateColumnMorphsWidth.  tmp2 do: [:arg6 |  arg6 doLayoutIn: arg6 layoutBounds ].  ^tmp2initialize  subscriptions := Dictionary newinitializeProcessMouseOver  leftMorphs := mouseOverMorphs asIdentitySet.  overMorphs := WriteStream on: (Array new: leftMorphs size).  enteredMorphs := WriteStream on: #()bounds  | tmp1 tmp2 |  self fillsOwner ifFalse: [ ^textMorph textBounds ].  tmp2 := textMorph.  tmp1 := tmp2 owner innerBounds.  tmp1 := tmp1 insetBy: (textMorph valueOfProperty: #margins ifAbsent: [ 1 @ 1 ]).  tmp2 owner submorphsBehind: tmp2 do: [:arg1 |  tmp1 := tmp1 merge: arg1 fullBounds ].  ^tmp1normalFillStyle  ^self theme windowEdgeNormalFillStyleFor: selfaddFillStyleMenuItems: arg1 hand: arg2  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  self fillStyle addFillStyleMenuItems: tmp1 hand: arg2 from: self.  tmp1 addLine.  tmp1 add: 'solid fill' selector: #useSolidFill.  tmp1 add: 'gradient fill' selector: #useGradientFill.  tmp1 add: 'bitmap fill' selector: #useBitmapFill.  tmp1 add: 'default fill' selector: #useDefaultFill.  arg1 add: 'fill style' subMenu: tmp1vIsScrollbarShowing  ^submorphs includes: scrollBarscrollDeltaHeight  ^self font heighttestRightBottomQuadrant  | tmp1 tmp2 |  tmp1 := LayoutFrame new     leftFraction: 1 / 2 offset: 1;     topFraction: 1 / 2 offset: 1;     rightFraction: 1 offset: -2;     bottomFraction: 1 offset: -2;     yourself.  tmp2 := tmp1 layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (101 @ 41 corner: 148 @ 68) equals: tmp2target  ^modeldialogWindow  ^self ownerThatIsA: DialogWindowisShowColumnHeaders  ^showColumnHeadersspotterPreviewMenuIn: arg1  < spotterPreview: 10>  arg1 list     title: [ self contents ];     display: #yourself;     format: [:arg2 |  GTSpotterItemBrick new           text: arg2 contents;           icon: arg2 icon;           disable;           yourself ];     styled: [:arg3 |  arg3 ];     entity: (self hasSubMenu ifFalse: [ {self} ] ifTrue: [ self subMenu allItems ]).  self flag: 'move "entity: self" somewhere else, maybe'itemShortcut  ^ToggleMenuItemShortcut owner: self keyText: self keyTextroots  ^scroller submorphs select: [:arg1 |  arg1 indentLevel isZero ]beCheckbox  self     isRadioButton: false;     onImage: self theme checkboxMarkerForm;     cornerStyle: (self theme checkboxCornerStyleFor: self);     fillStyle: self fillStyleToUse;     borderStyle: self borderStyleToUseattachKeymapCategory: arg1  self kmDispatcher attachCategory: arg1ascendingSortFunction  ^[:arg1 |  self property value: arg1 ] ascendingcursorPoint  ^self currentHand lastEvent cursorPointmouseEnter: arg1  super mouseEnter: arg1.  (owner notNil and: [ owner isKindOf: EmbeddedMenuMorph ]) ifTrue: [ owner selectedItem ~~ self ifTrue: [ owner selectItem: self event: arg1 ] ]setGrabbedColor  self fillStyle: self pressedFillStyleselectedMorph  ^(TickSelectionCheckboxMorph basicNew     index: (self model rootItems indexOf: self item);     initialize;     model: self item;     getStateSelector: #selected;     setStateSelector: #selected:;     updateSelection;     getEnabledSelector: nil;     font: StandardFonts defaultFont;     label: '';     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     setBalloonText: nil)     color: Color transparent;     yourselfisDraggingEvent  source ifNil: [ ^false ].  source hasSubmorphs ifTrue: [ ^true ].  self anyButtonPressed ifTrue: [ ^true ].  ^falsedashedBorder  ^borderDashSpecscrollBarMenuButtonPressed: arg1  ^self yellowButtonActivity: arg1 shiftPressedtakesKeyboardFocus  ^truemouseDown: arg1 on: arg2  | tmp1 |  tmp1 := self clicked: arg1 inTheCheckboxOf: arg2.  (self autoMultiSelection and: [ arg1 shiftPressed not ]) ifTrue: [ firstClickedMorph := arg2.        arg2 selected ifTrue: [ self removeFromSelection: arg2.              (tmp1 not and: [ self selectOnlyLastHighlighted and: [ arg2 hasContentToShow ] ]) ifTrue: [ arg2 = self lastClickedMorph ifFalse: [ self addToSelection: arg2 ] ] ] ifFalse: [ (tmp1 not and: [ self selectOnlyLastHighlighted and: [ arg2 hasContentToShow ] ]) ifTrue: [ arg2 = self lastClickedMorph ifTrue: [ self addToSelection: arg2.                          tmp1 ifFalse: [ self lastClickedMorph: arg2 ] ] ] ifFalse: [ self addToSelection: arg2.                    tmp1 ifFalse: [ self lastClickedMorph: arg2 ] ] ] ].  (tmp1 not and: [ arg1 shiftPressed not or: [ firstClickedMorph isNil ] ]) ifTrue: [ firstClickedMorph := arg2 ].  arg2 mouseDown: arg1requestView: arg1  ^self announcer announce: arg1mouseMove: arg1  arg1 isDraggingEvent ifFalse: [ ^self ].  arg1 hand hasSubmorphs ifFalse: [ ^self ].  (self wantsDroppedMorph: arg1 hand submorphs first event: arg1) ifFalse: [ ^self ].  (self container rowIndexContainingPoint: arg1 position) ifNotNil: [:arg2 |  self basicHighlightIndexes: {arg2}.        self refresh ].  (self container bounds containsPoint: arg1 position) ifFalse: [ ^self ].  arg1 position y <= (self container top + self autoScrollHeightLimit) ifTrue: [ ^self verticalScrollBar scrollUp: 1 ].  arg1 position y >= (self container bottom - self autoScrollHeightLimit) ifTrue: [ ^self verticalScrollBar scrollDown: 1 ]framePolygon: arg1 on: arg2  self framePolyline: arg1 on: arg2.  self drawLineFrom: arg1 last to: arg1 first on: arg2firstOwnerSuchThat: arg1  self allOwnersDo: [:arg2 |  (arg1 value: arg2) ifTrue: [ ^arg2 ] ].  ^nilreleaseCachedState  (model ~~ self and: [ model respondsTo: #releaseCachedState ]) ifTrue: [ model releaseCachedState ].  super releaseCachedStateinitializeScroller  scroller := self newTransformMorph color: Color transparent.  scroller offset: self hMargin negated @ 0.  self addMorph: scrollermouseDown: arg1  | tmp1 |  tmp1 := arg1 cursorPoint.  lastMouse := {tmp1 .   (tmp1 - self position) .   (tmp1 - self targetPoint)}autoMultiSelection  ^autoMultiSelection ifNil: [ autoMultiSelection := false ]layoutChanged  fullBounds := nil.  self layoutPolicy ifNotNil: [:arg1 |  arg1 flushLayoutCache ]isInterruptable  ^self class isInterruptableisMenuItemMorph  ^trueadoptColor: arg1  self paneColorChangednewAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7 entryCompletion: arg8  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7 entryCompletion: arg8fitScrollTarget  | tmp1 |  tmp1 := 0.  self scroller width > self scrollTarget width ifTrue: [ self scrollTarget width: self scroller width ] ifFalse: [ tmp1 := self scrollBarThickness ].  self scroller height - tmp1 > self scrollTarget height ifTrue: [ self scrollTarget height: self scroller height + tmp1 ]updateLayoutInDockingBar  owner isVertical ifTrue: [ self hResizing: #spaceFill.        self vResizing: #shrinkWrap ] ifFalse: [ self hResizing: #shrinkWrap.        self vResizing: #spaceFill ].  self extent: self minWidth @ self minHeightmouseUp: arg1  super mouseUp: arg1.  self stopSteppingSelector: #autoScrollView:.  editView selectionInterval: editor selectionIntervalnewScrollPaneFor: arg1  ^self theme newScrollPaneIn: self for: arg1hasIconBlock  ^iconBlock notNilshowOrHideHandles  self showingHandles ifTrue: [ self removeHandles ] ifFalse: [ self addHandles ]setPageSize: arg1  pageSize := arg1isFlexMorph  ^falsecomposer  ^composer ifNil: [ composer := TextComposer new ]normalBorderStyle  ^self theme buttonNormalBorderStyleFor: selflineBorderColor: arg1  self borderColor: arg1alignCentersVertically  | tmp1 tmp2 |  selectedItems size > 1 ifFalse: [ ^self ].  tmp1 := (selectedItems collect: [:arg1 |  arg1 top ]) min.  tmp2 := selectedItems detect: [:arg2 |  arg2 top = tmp1 ].  selectedItems do: [:arg1 |  arg1 center: tmp2 center x @ arg1 center y ].  self changedrotationDegrees: arg1  initialize  min := 0.  max := 1.  label := ''.  super initialize.  self enabled: trueremoveCloseBox  closeBox ifNotNil: [ closeBox delete.        closeBox := nil ]layoutProperties  ^layoutPropertiesslideOneLineDown  | tmp1 |  prevIndex < prevLines size ifFalse: [ ^nowSliding := possibleSlide := false ].  prevIndex := prevIndex + 1.  tmp1 := (prevLines at: prevIndex) slideIndexBy: deltaCharIndex andMoveTopTo: currentY.  lines addLast: tmp1.  currentY := tmp1 bottom.  currCharIndex := tmp1 last + 1.  wantsColumnBreaks ifTrue: [ tmp1 first to: tmp1 last do: [:arg1 |  (theText at: arg1) = TextComposer characterForColumnBreak ifTrue: [ nowSliding := possibleSlide := false.                    ^nil ] ] ]resizeScroller  scroller bounds: self innerBoundskeyboardListeners  ^nilshouldCopy: arg1  copy := arg1stepListSize  ^stepList sizebeSingle  self listManager multipleSelection: falseselectedRow  ^selectedRowresetHScrollRangeIfNecessary  hScrollRangeCache ifNil: [ ^self deriveHScrollRange ].  (list isNil or: [ list isEmpty ]) ifTrue: [ ^hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0 ].  (hScrollRangeCache third == list size and: [ hScrollRangeCache fourth == list first and: [ hScrollRangeCache fifth == list last ] ]) ifFalse: [ self deriveHScrollRange ]drawDropShadowOn: arg1  self assert: [ vertices notEmpty ] description: 'a polygon must have at least one point'.  closed ifTrue: [ arg1 drawPolygon: self getVertices fillStyle: self shadowColor ]sharesFindReplace  ^falseadjustLayoutBounds  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self hResizing.  tmp2 := self vResizing.  (tmp1 == #shrinkWrap or: [ tmp2 == #shrinkWrap ]) ifFalse: [ ^self ].  tmp3 := self layoutBounds.  tmp4 := tmp3 extent.  tmp5 := self submorphBounds corner - tmp3 origin.  tmp1 == #shrinkWrap ifTrue: [ tmp4 := tmp5 x @ tmp4 y ].  tmp2 == #shrinkWrap ifTrue: [ tmp4 := tmp4 x @ tmp5 y ].  tmp4 x < self minWidth ifTrue: [ tmp4 := (tmp4 x max: self minWidth - self bounds width + self layoutBounds width) @ tmp4 y ].  tmp4 y < self minHeight ifTrue: [ tmp4 := tmp4 x @ (tmp4 y max: self minHeight - self bounds height + self layoutBounds height) ].  self layoutBounds: (tmp3 origin extent: tmp4)dropNode: arg1 on: arg2  dropItemSelector ifNil: [ ^nil ].  model perform: dropItemSelector with: arg1 item with: arg2 itemannounceKeyboardFocusChange: arg1  | tmp1 |  tmp1 := arg1 ifTrue: [ MorphGotFocus morph: self ] ifFalse: [ MorphLostFocus morph: self ].  self doAnnounce: tmp1.  Morph announcer announce: tmp1menu: arg1  menu := arg1addEmphaseTo: arg1  self model isActive ifFalse: [ ^self ].  arg1 emphasis: 1enterClickableRegion: arg1  arg1 hand hasSubmorphs ifTrue: [ ^self ].  arg1 hand temporaryCursor ifNotNil: [ ^self ]getCurrentSelectionItem  ^model perform: (getSelectionSelector ifNil: [ ^nil ])addGrowHandle: arg1  target shouldFlex ifFalse: [ (self addHandle: arg1 on: #mouseDown send: #startGrow:with: to: self) on: #mouseMove send: #doGrow:with: to: self ]pager  ^pagerinitialExtent  ^(self valueOfProperty: #initialExtent) ifNil: [ 700 @ 500 ] ifNotNil: [:arg1 |  arg1 ]innerTarget  ^innerTargetballoonOwner  ^balloonOwnerinitialize  worldState := WorldState new.  super initialize.  SystemAnnouncer uniqueInstance weak when: FullscreenAnnouncement send: #fullscreenChanged: to: self.  Smalltalk tools whenToolRegistered: [:arg1 :arg2 |  WorldState defaultWorldMenu ].  Smalltalk tools whenToolUnregistered: [:arg1 :arg2 |  WorldState defaultWorldMenu ]addAlarm: arg1 at: arg2  ^self addAlarm: arg1 withArguments: #() at: arg2makeClosable  mustNotClose := false.  closeBox ifNil: [ closeBox := self createCloseBox.        self replaceBoxes ]submorphBefore  | tmp1 |  owner ifNil: [ ^nil ].  ^(tmp1 := owner submorphIndexOf: self) = 1 ifTrue: [ nil ] ifFalse: [ owner submorphs at: tmp1 - 1 ]action: arg1  action := arg1standardArrows  self removeProperty: #arrowSpec.  self computeBoundshandlesMouseOver: arg1  self eventHandler ifNotNil: [ ^self eventHandler handlesMouseOver: arg1 ].  ^falsenotOnLastPage  ^self onLastPage notokayToAddDismissHandle  ^self resistsRemoval notsetInverseColors  handleColor := Color lightGray.  dotColor := Color whitemodel  ^modelvScrollBarValue: arg1  super vScrollBarValue: arg1.  self pager ifNotNil: [:arg2 |  arg2 vScrollBarValue: arg1 ]drawMouseDownHighlightOn: arg1  self highlightedForMouseDown ifTrue: [ arg1 frameRectangle: self fullBounds color: self color darker darker ]testNoIconWithoutSorting  column disableSort.  self assert: column sortingIcon isNiladdChildrenForList: arg1 addingTo: arg2 withExpandedItems: arg3  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg4 |  arg4 delete ].        firstChild := nil ].  complexContents hasContents ifFalse: [ ^self ].  firstChild := arg1 addMorphsTo: arg2 from: complexContents contents withExpandedItems: arg3 atLevel: indentLevel + 1composeAllRectangles: arg1  | tmp1 tmp2 tmp3 |  actualHeight := defaultLineHeight.  tmp1 := currCharIndex.  tmp2 := lines size.  tmp3 := self composeEachRectangleIn: arg1.  currentY := currentY + actualHeight.  currentY > theContainer bottom ifTrue: [ currCharIndex := tmp1.        lines size - tmp2 timesRepeat: [ lines removeLast ].        ^self ].  maxRightX := maxRightX max: scanner rightX.  1 to: arg1 size - 1 do: [:arg2 |  (lines at: lines size - arg1 size + arg2) lineHeight: lines last lineHeight baseline: lines last baseline ].  isFirstLine := false.  tmp3 == #columnBreak ifTrue: [ ^nil ].  currCharIndex > theText size ifTrue: [ ^nil ]newColor: arg1  newColor := arg1getList  getListSelector ifNil: [ ^#() ].  list := model perform: getListSelector.  list ifNil: [ ^#() ].  ^listnewImage: arg1 size: arg2  ^self theme newImageIn: self form: arg1 size: arg2initialize  super initialize.  self     setLabel: self defaultLabel;     setWindowColor: self defaultColortextEntry: arg1  ^self textEntry: arg1 title: 'Entry' translatedvPageDelta  | tmp1 tmp2 tmp3 |  tmp2 := self scrollTarget height.  tmp3 := self scrollBounds height.  tmp1 := tmp2 - tmp3 max: 0.  tmp1 = 0 ifFalse: [ tmp1 := tmp3 / tmp1 ].  ^tmp1newStateForEnabled: arg1  ^TabEnabled tab: self tabsmoothing  ^smoothingdrawRowsOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  self canRefreshValues ifFalse: [ ^self ].  tmp1 := self left + self class rowLeftMargin.  tmp2 := self top.  tmp3 := self width - self class rowLeftMargin.  tmp4 := self table rowHeight rounded.  tmp7 := self table selectedIndexes , self table highlightedIndexes.  tmp8 := self table selectedIndex.  self updateAllRows.  tmp5 := self exposedRows.  tmp6 := OrderedCollection new: tmp5 size + 1.  headerRow ifNotNil: [ headerRow bounds: (self left @ tmp2 extent: self width @ tmp4).        tmp2 := tmp2 + tmp4 + self table intercellSpacing y.        tmp6 add: headerRow ].  tmp5 keysAndValuesDo: [:arg2 :arg3 |  | tmp9 |        tmp9 := (self rowHeight: arg2 default: tmp4) min: self bottom - tmp2.        arg3 bounds: (tmp1 @ tmp2 extent: tmp3 @ tmp9).        tmp2 := tmp2 + tmp9 + self table intercellSpacing y.        tmp6 add: arg3.        (self table selectionModeStrategy selectablesToHighlightFromRow: arg3 at: arg2 withHighlightedIndexes: tmp7 andPrimaryIndex: tmp8) keysAndValuesDo: [:arg4 :arg5 |  arg4 selectionColor: (self table colorForSelection: arg5) ] ].  submorphs do: [:arg6 |  arg6           privateOwner: nil;           outOfWorld: self world ].  submorphs := tmp6 asArray.  submorphs do: [:arg6 |  arg6 intoWorld: self world ].  self table isResizable ifTrue: [ self addResizeSplitters ].  needsRefreshExposedRows := falserotationDegrees: arg1  halo: arg1  | tmp1 |  tmp1 := self halo.  (tmp1 isNil or: [ tmp1 == arg1 ]) ifFalse: [ tmp1 delete ].  arg1 ifNil: [ self removeProperty: #halo ] ifNotNil: [ self setProperty: #halo toValue: arg1 ]previousWindow  | tmp1 |  tmp1 := self systemWindows.  tmp1 ifEmpty: [ ^nil ].  ^tmp1 before: self currentWindow ifAbsent: [ tmp1 last ]handleEvent: arg1  | tmp1 |  owner ifNil: [ ^self ].  tmp1 := arg1.  EventStats ifNotNil: [ self class logEventStats: tmp1 ].  tmp1 isMouse ifTrue: [ lastMouseEvent := tmp1 ].  captureBlock ifNotNil: [ ^captureBlock value: arg1 ].  tmp1 isMouseOver ifTrue: [ ^self sendMouseEvent: tmp1 ].  self showDebugEvent: tmp1.  self sendListenEvent: tmp1 to: self eventListeners.  tmp1 isWindowEvent ifTrue: [ self sendEvent: tmp1 focus: nil.        ^self mouseOverHandler processMouseOver: lastMouseEvent ].  tmp1 isKeyboard ifTrue: [ self sendListenEvent: tmp1 to: self keyboardListeners.        self sendKeyboardEvent: tmp1.        ^self mouseOverHandler processMouseOver: lastMouseEvent ].  tmp1 isDropEvent ifTrue: [ self sendEvent: tmp1 focus: nil.        ^self mouseOverHandler processMouseOver: lastMouseEvent ].  tmp1 isMouse ifTrue: [ self sendListenEvent: tmp1 to: self mouseListeners.        lastMouseEvent := tmp1 ].  mouseClickState ifNotNil: [ (mouseClickState handleEvent: tmp1 from: self) ifFalse: [ ^self mouseOverHandler processMouseOver: lastMouseEvent ] ].  tmp1 isMove ifTrue: [ | tmp2 |        tmp2 := tmp1 position.        tmp1 isDraggingEvent ifTrue: [ | tmp3 |              tmp3 := 0.              (self submorphs at: 1 ifAbsent: [ nil ]) ifNotNil: [:arg2 |  tmp3 := self top - arg2 top ].              tmp2 y < (self class upperHandLimit + tmp3) ifTrue: [ tmp2 := tmp2 x @ (self class upperHandLimit + tmp3) ] ].        self position: tmp2.        self sendMouseEvent: tmp1 ] ifFalse: [ tmp1 position = self position ifFalse: [ self moveToEvent: tmp1 ].        self hasSubmorphs ifTrue: [ self dropMorphs: tmp1 ] ifFalse: [ self sendMouseEvent: tmp1 ] ].  self showMouseFocusEvent: tmp1.  self mouseOverHandler processMouseOver: lastMouseEventescapePressed  date  ^datechangeDocumentAnchor  | tmp1 |  tmp1 := self textAnchorType == #document ifTrue: [ #paragraph ] ifFalse: [ #document ].  owner isTextMorph ifTrue: [ owner anchorMorph: self at: self position type: tmp1 ]addCustomMenuItems: arg1 hand: arg2  actionOffset  ^4 * self displayScaleFactornewToolbarHandle  ^self theme newToolbarHandleIn: selfremoveTaskbar  self taskbars do: [:arg1 |  arg1 removeFromWorld ]closeWindowAction  self cancelmouseWheel: arg1  addMorphFront: arg1 fromWorldPosition: arg2  arg1 textAnchorType == #document ifFalse: [ ^self anchorMorph: arg1 at: arg2 type: arg1 textAnchorType ].  self addMorphFront: arg1newString: arg1 style: arg2  ^self theme newStringIn: self label: arg1 font: self theme labelFont style: arg2onFirstPage  ^self currentPageFirstIndex = 1addTitle: arg1 icon: arg2  arg2 ifNil: [ ^self addTitle: arg1 ].  self buildTitle: [:arg3 |  arg3           title: arg1;           icon: arg2 ]defaultBorderColor  ^#raisedocclusionsOnOff  self setContainer: (container ifNil: [ (TextContainer new for: self minWidth: textStyle lineGrid * 2)                 fillsOwner: false;                 avoidsOcclusions: true ] ifNotNil: [ (container avoidsOcclusions and: [ container fillsOwner not ]) ifTrue: [ nil ] ifFalse: [ container avoidsOcclusions: container avoidsOcclusions not ] ])dragEnabled: arg1  ^self enableDrag: arg1getValueSelector: arg1  getValueSelector := arg1maxCellSize  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ SmallInteger maxVal ] ifNotNil: [ tmp1 maxCellSize ]wantsDropFiles: arg1  ^falseinitialize  super initialize.  submorphs := EmptyArray.  bounds := self defaultBounds.  color := self defaultColordeny: arg1  ^self deny: arg1 title: 'Access Denied' translatedsetDirection: arg1 with: arg2  arg1 hand obtainHalo: self.  target setDirectionFrom: arg2 center.  self endInteractionselectAll  self requestView: MorphTreeChangeRequest selectAllresizeCursor  ^Cursor resizeForEdge: #bottomLefton: arg1 getState: arg2 action: arg3 label: arg4 icon: arg5 menu: arg6  super on: arg1 getState: arg2 action: arg3 label: arg4 icon: arg5 menu: arg6.  self pressed: super getModelStatescrollTabsLeft  self visibleTabRange: (self visibleTabRange first < 2 ifTrue: [ 0 to: self tabs size ] ifFalse: [ 0 to: self visibleTabRange first - 1 ]).  self updateTabsnewExpander: arg1 for: arg2  ^self theme newExpanderIn: self label: arg1 forAll: {arg2}doesBevels  ^falseactionOn: arg1  ^actionIcon ifNil: [ actionIcon := self createActionIconOn: arg1 ]updatePanesFromSubmorphs  paneMorphs := paneMorphs select: [:arg1 |  submorphs includes: arg1 ]add: arg1 target: arg2 selector: arg3 argumentList: arg4  ^self addToggle: arg1 target: arg2 selector: arg3 getStateSelector: nil enablementSelector: nil argumentList: arg4fillStyleToUse  ^self fillStyleensureSelectedTabIsVisible  (self selectedIndex > 0 and: [ (self visibleTabRange includes: self selectedIndex) not ]) ifTrue: [ self visibleTabRange: (self selectedIndex to: 0).        self updateTabs ]hideScrollBars  self     vHideScrollBar;     hHideScrollBardrawArrowsOn: arg1  | tmp1 |  self hasArrows ifFalse: [ ^#() ].  tmp1 := Array with: vertices first with: vertices last.  borderColor isColor ifFalse: [ ^tmp1 ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ tmp1 at: 2 put: (self drawArrowOn: arg1 at: vertices last from: self nextToLastPoint) ].  (arrows == #back or: [ arrows == #both ]) ifTrue: [ tmp1 at: 1 put: (self drawArrowOn: arg1 at: vertices first from: self nextToFirstPoint) ].  ^tmp1rowMorphsWidths  | tmp1 |  tmp1 := self headerBounds collect: [:arg1 |  arg1 width ].  tmp1 ifNotEmpty: [ tmp1 at: 1 put: (tmp1 at: 1) - 3 ].  ^tmp1setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigidbottom  ^bottomsetDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedmouseStillDown: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseStillDown from: arg2newTextEditorFor: arg1 getText: arg2 setText: arg3  ^self newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: nilnavigationKey: arg1  ^self taskList handleEvent: arg1selected: arg1  self item selected: arg1mouseOverPagingAreaThumbBorderStyle  ^self theme scrollbarMouseOverBarThumbBorderStyleFor: selfdoButtonAction  self invokeWithEvent: nilbottomBoundary  | tmp1 |  tmp1 := rightOrBottom reject: [:arg1 |  arg1 layoutFrame bottomFraction ~= 1 and: [ arg1 layoutFrame topFraction = arg1 layoutFrame bottomFraction ] ].  tmp1 ifEmpty: [ ^(self splitterBelow ifNil: [ self containingWindow panelRect bottom ] ifNotNil: [ self splitterBelow first top ]) - 25 ].  ^(tmp1 collect: [:arg1 |  arg1 bottom - arg1 minExtent y - (arg1 layoutFrame topOffset ifNil: [ 0 ]) + (self layoutFrame bottomOffset ifNil: [ 0 ]) ]) min - self class splitterWidthoverlapsShadowForm: arg1 bounds: arg2  | tmp1 tmp2 |  tmp2 := (arg2 intersect: self fullBounds ifNone: [ ^false ]) extent.  tmp2 > (0 @ 0) ifFalse: [ ^false ].  tmp1 := self shadowForm.  tmp2 ~= self fullBounds extent ifTrue: [ tmp1 := tmp1 contentsOfArea: (0 @ 0 extent: tmp2) ].  tmp1 := tmp1 copyBits: (self fullBounds translateBy: arg1 offset negated) from: arg1 at: 0 @ 0 clippingBox: (0 @ 0 extent: tmp2) rule: Form and fillColor: nil.  ^tmp1 bits anySatisfy: [:arg3 |  arg3 ~= 0 ]goBehind  owner addMorphBack: selfrootsItems  ^rootItem childrenmakeNoArrows  arrows := #none.  self computeBoundsexistsSubscriptionsFor: arg1  ^(subscriptions includesKey: arg1) and: [ (subscriptions at: arg1) notEmpty ]contents  ^contents ifNil: [ contents := super contents ]createLabelMorph: arg1  ^arg1 asStringMorph     font: self labelFont emphasis: 0;     color: textColor;     yourselfasPotentialDropTarget  self model asPotentialDropTargetborderWidth: arg1  | tmp1 |  tmp1 := selectedItems select: [:arg2 |  arg2 isKindOf: BorderedMorph ].  undoProperties ifNil: [ undoProperties := tmp1 collect: [:arg2 |  arg2 borderWidth ] ].  tmp1 do: [:arg2 |  arg2 borderWidth: arg1 ]transparentSpacerOfSize: arg1  ^(Morph new extent: arg1) color: Color transparentremoveTabIndex: arg1  self tabs removeAt: arg1.  self selectedIndex: 0.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ]endShapeWidth: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self valueOfProperty: #originalWidth ifAbsentPut: [ self borderWidth isZero ifFalse: [ self borderWidth ] ifTrue: [ 2 ] ].  self borderWidth: arg1.  tmp2 := self valueOfProperty: #originalVertices ifAbsentPut: [ self vertices collect: [:arg2 |  arg2 - self referencePosition rotateBy: self heading degreesToRadians about: 0 @ 0 ] ].  tmp3 := MorphicTransform offset: 0 @ 0 angle: self heading degreesToRadians scale: tmp1 / arg1.  self setVertices: (tmp2 collect: [:arg2 |  ((tmp3 transform: arg2) + self referencePosition) asIntegerPoint ]).  self computeBoundswithHLines  ^withHLines ifNil: [ withHLines := false ]defaultBorderWidth  ^1fillStyles  | tmp1 |  tmp1 := OrderedCollection new.  self stateMap do: [:arg1 |  arg1 do: [:arg2 |  arg2 do: [:arg3 |  arg3 do: [:arg4 |  tmp1 add: arg4 ] ] ] ].  ^tmp1nonCachingFullDrawOn: arg1  submorphs isEmpty ifTrue: [ ^self drawOn: arg1 ].  arg1 asShadowDrawingCanvas translateBy: self shadowOffset during: [:arg2 |  | tmp1 |        tmp1 := self shadowForm.        arg2 paintImage: tmp1 at: tmp1 offset ].  self drawSubmorphsOn: arg1.  self drawOn: arg1testSelectAll  table beSingleSelection.  table selectFirst.  table selectAll.  self assert: table selectedIndexes equals: #(#(1 1)).  table beMultipleSelection.  table selectFirst.  table selectAll.  self assert: table selectedIndexes equals: #(#(1 1) #(1 2) #(1 3) #(2 1) #(2 2) #(2 3) #(3 1) #(3 2) #(3 3) #(4 1) #(4 2) #(4 3) #(5 1) #(5 2) #(5 3) #(6 1) #(6 2) #(6 3) #(7 1) #(7 2) #(7 3) #(8 1) #(8 2) #(8 3) #(9 1) #(9 2) #(9 3) #(10 1) #(10 2) #(10 3))allWordingsNotInSubMenus: arg1  self isStayUpItem ifTrue: [ ^#() ].  subMenu ifNotNil: [ ^(arg1 includes: self contents asString) ifTrue: [ #() ] ifFalse: [ subMenu allWordingsNotInSubMenus: arg1 ] ].  ^Array with: self contents asStringhandlesMouseOver: arg1  ^falseaddCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  arg1 addUpdating: #handlesShowingPhrase target: self selector: #showOrHideHandles.  vertices size > 2 ifTrue: [ self addPolyLIneCurveMenuItems: arg1 hand: arg2 ].  arg1 add: 'specify dashed line' selector: #specifyDashedLine.  self isOpen ifTrue: [ self addPolyArrowMenuItems: arg1 hand: arg2 ] ifFalse: [ self addPolyShapingMenuItems: arg1 hand: arg2 ]rejectDropMorphEvent: arg1  self formerOwner notNil ifTrue: [ ^self slideBackToFormerSituation: arg1 ].  self formerPosition ifNotNil: [ ^self vanishAfterSlidingTo: self formerPosition event: arg1 ]newMenuItem  ^DockingBarMenuItemMorph newrecordFiltering: arg1  self setProperty: #matchString toValue: arg1positions  ^#(#topLeft #topRight #center #bottomLeft #bottomRight)flashRects: arg1 color: arg2  | tmp1 |  tmp1 := (BitBlt toForm: Display)     sourceForm: nil;     sourceOrigin: 0 @ 0;     clipRect: self viewBox;     combinationRule: Form reverse.  arg1 do: [:arg3 |  | tmp2 |        tmp2 := arg3 translateBy: self viewBox origin.        tmp1           destRect: tmp2;           copyBits.        Display           forceToScreen: tmp2;           forceDisplayUpdate.        (Delay forMilliseconds: 15) wait.        tmp1           destRect: tmp2;           copyBits.        Display           forceToScreen: tmp2;           forceDisplayUpdate ]selectedItemOrItemsOrNil  ^self lastSelectedNode ifNil: [ nil ] ifNotNil: [ self lastSelectedNode item ]defaultYellowButtonMenuEnabled  ^self class defaultYellowButtonMenuEnabledchangeInlineAnchor  | tmp1 |  tmp1 := self textAnchorType == #inline ifTrue: [ #paragraph ] ifFalse: [ #inline ].  owner isTextMorph ifTrue: [ owner anchorMorph: self at: self position type: tmp1 ]closedCubicSlopesOf: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp6 := arg1 size.  tmp6 < 3 ifTrue: [ self error: 'Less than 3 points makes a poor curve' ].  tmp1 := Array new: tmp6.  tmp2 := Array new: tmp6.  tmp4 := Array new: tmp6.  tmp7 := Array new: tmp6.  tmp3 := arg1.  tmp5 := 1.0 / 4.0.  tmp1 at: 2 put: tmp5.  tmp2 at: 2 put: tmp5.  tmp4 at: 1 put: tmp5 * 3.0 * ((tmp3 at: 2) - (tmp3 at: tmp6)).  tmp10 := 4.0.  tmp8 := 3 * ((tmp3 at: 1) - (tmp3 at: tmp6 - 1)).  tmp9 := 1.  2 to: tmp6 - 1 do: [:arg2 |  tmp5 := 1.0 / (4.0 - (tmp1 at: arg2)).        tmp1 at: arg2 + 1 put: tmp5.        tmp2 at: arg2 + 1 put: tmp5 negated * (tmp2 at: arg2).        tmp4 at: arg2 put: tmp5 * (3.0 * ((tmp3 at: arg2 + 1) - (tmp3 at: arg2 - 1)) - (tmp4 at: arg2 - 1)).        tmp10 := tmp10 - (tmp9 * (tmp2 at: arg2)).        tmp8 := tmp8 - (tmp9 * (tmp4 at: arg2 - 1)).        tmp9 := (tmp1 at: arg2) negated * tmp9 ].  tmp10 := tmp10 - ((tmp9 + 1) * ((tmp1 at: tmp6) + (tmp2 at: tmp6))).  tmp4 at: tmp6 put: tmp8 - ((tmp9 + 1) * (tmp4 at: tmp6 - 1)).  tmp7 at: tmp6 put: (tmp4 at: tmp6) / tmp10.  tmp7 at: tmp6 - 1 put: (tmp4 at: tmp6 - 1) - (((tmp1 at: tmp6) + (tmp2 at: tmp6)) * (tmp7 at: tmp6)).  (1 to: tmp6 - 2) reverseDo: [:arg2 |  tmp7 at: arg2 put: (tmp4 at: arg2) - ((tmp1 at: arg2 + 1) * (tmp7 at: arg2 + 1)) - ((tmp2 at: arg2 + 1) * (tmp7 at: tmp6)) ].  ^tmp7announceScrollChangedFrom: arg1 to: arg2  arg1 = arg2 ifTrue: [ ^self ].  self doAnnounce: ((FTScrollingChanged from: arg1 to: arg2)           fastTable: self;           yourself)treeLineDashes  ^treeLineDashes ifNil: [ treeLineDashes := self theme treeLineDashes ]mouseMove: arg1  self mouseDown: arg1target: arg1  target := arg1defaultPreviewExtent  ^(320 @ 320) scaledByDisplayScaleFactorforwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]privateAddMorph: arg1 atIndex: arg2  | tmp1 tmp2 tmp3 tmp4 |  (arg2 between: 1 and: submorphs size + 1) ifFalse: [ ^self error: 'index out of range' ].  tmp2 := self world.  tmp4 := arg1 owner.  (tmp4 == self and: [ (tmp1 := submorphs indexOf: arg1) > 0 ]) ifTrue: [ tmp1 < arg2 ifTrue: [ submorphs replaceFrom: tmp1 to: arg2 - 2 with: submorphs startingAt: tmp1 + 1.              submorphs at: arg2 - 1 put: arg1 ] ifFalse: [ tmp1 - 1 to: arg2 by: -1 do: [:arg3 |  submorphs at: arg3 + 1 put: (submorphs at: arg3) ].              submorphs at: arg2 put: arg1 ] ] ifFalse: [ tmp4 ifNotNil: [ tmp3 := arg1 world.              tmp3 ifNotNil: [ self privateInvalidateMorph: arg1 ].              tmp3 == tmp2 ifFalse: [ arg1 outOfWorld: tmp3 ].              tmp4 privateRemove: arg1.              tmp4 removedMorph: arg1 ].        arg1 privateOwner: self.        submorphs := submorphs copyReplaceFrom: arg2 to: arg2 - 1 with: (Array with: arg1).        tmp3 == tmp2 ifFalse: [ arg1 intoWorld: tmp2 ] ].  tmp2 ifNotNil: [ self privateInvalidateMorph: arg1 ].  self layoutChanged.  tmp4 == self ifFalse: [ self addedMorph: arg1.        arg1 noteNewOwner: self ]icon: arg1  icon := arg1changeListRequest: arg1  self updateListinterval: arg1  | tmp1 |  tmp1 := slider extent.  interval := arg1 min: 1.0.  self expandSlider.  self computeSlider.  slider extent = tmp1 ifFalse: [ slider fillStyle: self normalThumbFillStyle ]keyStroke: arg1  | tmp1 tmp2 |  (self navigationKey: arg1) ifTrue: [ ^self ].  tmp1 := arg1 keyCharacter.  tmp1 = Character space ifTrue: [ selectedItem ifNotNil: [ selectedItem hasSubMenu ifTrue: [ arg1 hand newMouseFocus: selectedItem subMenu.                    ^selectedItem subMenu takeKeyboardFocus ] ifFalse: [ ^selectedItem invokeWithEvent: arg1 ] ].        (tmp2 := self items) size = 1 ifTrue: [ ^tmp2 first invokeWithEvent: arg1 ].        ^self ].  (tmp1 = Character arrowLeft or: [ tmp1 = Character arrowRight ]) ifTrue: [ (selectedItem notNil and: [ selectedItem hasSubMenu ]) ifTrue: [ arg1 hand newMouseFocus: selectedItem subMenu.              selectedItem subMenu moveSelectionDown: 1 event: arg1.              ^arg1 hand newKeyboardFocus: selectedItem subMenu ] ].  tmp1 = Character arrowUp ifTrue: [ ^self moveSelectionDown: -1 event: arg1 ].  tmp1 = Character arrowDown ifTrue: [ ^self moveSelectionDown: 1 event: arg1 ].  tmp1 = Character pageUp ifTrue: [ ^self moveSelectionDown: -5 event: arg1 ].  tmp1 = Character pageDown ifTrue: [ ^self moveSelectionDown: 5 event: arg1 ]oldSelectedIndexes  ^oldSelectedIndexesclippingBounds  ^tab modifyClippingBounds: super clippingBoundsactiveEnabledNotOverDownFillStyle: arg1  self stateMap atPath: #(active enabled notOver down) put: arg1.  self changedinitialize  super initialize.  self     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     wrapCentering: #topLeft;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 2;     rubberBandCells: trueworld  ^selfselectedDisabledFillStyle  ^self theme buttonSelectedDisabledFillStyleFor: selfreturnToOldResizingStrategy: arg1  self submorphs with: arg1 third do: [:arg2 :arg3 |  arg2 returnToOldResizingStrategy: arg3 ].  self hResizing: arg1 first.  self vResizing: arg1 secondlabel  ^self labelMorph contentsheight  ^bounds heightoverlapsHorizontal: arg1  ^arg1 left <= self right and: [ arg1 right >= self left ]asString  ^self item packageNamenumSelectionsInView  ^scroller numberOfItemsPotentiallyInViewWith: scroller submorphs last getListSizepageOfNodeIndex: arg1  ^(arg1 > 0 and: [ arg1 <= self nodeList size ]) ifTrue: [ (arg1 - 1) // pageSize + 1 ] ifFalse: [ nil ]initialize  super initialize.  self     initializeLayout;     initializeAppearance;     tasks: #();     orderedTasks: OrderedCollection newopenModal: arg1  | tmp1 tmp2 tmp3 tmp4 |  arg1 extent: arg1 initialExtent.  tmp2 := self currentWorld submorphs select: [:arg2 |  arg2 isKindOf: DialogWindow ] thenCollect: [:arg2 |  arg2 bounds expandBy: 8 ].  tmp1 := RealEstateAgent maximumUsableArea insetBy: 8.  tmp3 := true.  tmp1 allAreasOutsideList: tmp2 do: [:arg3 |  tmp3 ifTrue: [ arg1 extent <= (arg3 insetBy: 8) extent ifTrue: [ tmp4 := arg3.                    tmp3 := false ] ] ].  tmp3 ifTrue: [ tmp4 := tmp1 ].  arg1 setWindowColor: self theme windowColor.  arg1 position: tmp4 topLeft + 8.  arg1 openAsIs.  ^arg1discoveredWorldMenu  ^worldState discoveredWorldMenuresizable  ^resizable ifNil: [ resizable := true ]listDirection  ^#topToBottomcontainsPoint: arg1  | tmp1 |  ^(super containsPoint: arg1) and: [ tmp1 := SystemWindow borderWidth.        ((self bounds translateBy: (tmp1 @ tmp1) negated) containsPoint: arg1) not ]lastSelection  ^selectedItem ifNotNil: [ selectedItem selector ]arrowBoundsAt: arg1 from: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp2 := arg1 - arg2.  tmp3 := tmp2 degrees.  tmp1 := borderWidth max: 1.  tmp5 := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  tmp6 := tmp5 x abs.  tmp7 := tmp5 y abs.  tmp4 := arg1 + (Point r: tmp1 * tmp6 degrees: tmp3 + 180.0).  tmp5 x >= 0 ifTrue: [ ^{arg1 .         (tmp4 + (Point r: tmp1 * tmp7 degrees: tmp3 + 125.0)) .         (tmp4 + (Point r: tmp1 * tmp7 degrees: tmp3 - 125.0))} ] ifFalse: [ ^{arg1 .         (tmp4 + (Point r: tmp1 * tmp7 degrees: tmp3 + 125.0)) .         tmp4 .         (tmp4 + (Point r: tmp1 * tmp7 degrees: tmp3 - 125.0))} ]topHeaderBackground  ^topHeaderBackground ifNil: [ topHeaderBackground := Color transparent ]newStateForSelected: arg1  ^self subclassResponsibilitytoggleDragNDrop  self enableDragNDrop: self dragNDropEnabled notaddStandardHaloMenuItemsTo: arg1 hand: arg2  self addWorldHaloMenuItemsTo: arg1 hand: arg2actionAttributesUnder: arg1 event: arg2 do: arg3  | tmp1 |  tmp1 := self characterBlockAtPoint: arg1.  (text attributesAt: tmp1 stringIndex forStyle: textStyle) select: [:arg4 |  arg4 mayActOnEvent: arg2 ] thenDo: [:arg4 |  | tmp2 tmp3 |        tmp2 := text rangeOf: arg4 startingAt: tmp1 stringIndex.        tmp3 := self selectionRectsFrom: (self characterBlockForIndex: tmp2 first) to: (self characterBlockForIndex: tmp2 last + 1).        tmp3 detect: [:arg5 |  arg5 containsPoint: arg1 ] ifFound: [ arg3 cull: arg4 cull: tmp3 ] ]defaultBorderColor  ^self defaultColor twiceDarker alpha: 0.75splitsTopAndBottom  ^falsehasDisableTableLayoutString  ^self disableTableLayout -> 'disable layout in tables' translatedshouldCopy  ^copymouseMove: arg1  | tmp1 |  tmp1 := self itemFromPoint: arg1 position.  arg1 hand hasSubmorphs ifFalse: [ (tmp1 isNil or: [ tmp1 highlightedForMouseDown not ]) ifTrue: [ scroller submorphsDo: [:arg2 |  arg2 highlightedForMouseDown ifTrue: [ arg2 highlightForMouseDown: false ] ].              tmp1 ifNotNil: [ tmp1 highlightForMouseDown ] ] ].  (self dropEnabled and: [ arg1 hand hasSubmorphs ]) ifFalse: [ ^super mouseMove: arg1 ].  potentialDropMorph ifNotNil: [ (potentialDropMorph containsPoint: (potentialDropMorph point: arg1 position from: self)) ifTrue: [ ^self ] ].  self mouseLeaveDragging: arg1.  (self containsPoint: arg1 position) ifTrue: [ self mouseEnterDragging: arg1 ]mouseDown: arg1  | tmp1 |  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: arg1 cursorPoint) ifTrue: [ oldColor := self color.        self setGrabbedColor ].  tmp1 := arg1 cursorPoint.  lastMouse := {tmp1 .   (tmp1 - self position)}noteRemovalOfAll: arg1  scroller removeAllMorphsIn: arg1.  (arg1 includes: selectedMorph) ifTrue: [ self setSelectedMorph: nil ]roundedCorners  owner isFloating ifTrue: [ ^#(1 4) ].  owner isAdheringToTop ifTrue: [ ^#(1 4) ].  owner isAdheringToBottom ifTrue: [ ^#(2 3) ].  owner isAdheringToLeft ifTrue: [ ^#(1 2) ].  owner isAdheringToRight ifTrue: [ ^#(3 4) ].  ^#(1 2 3 4)icon: arg1  icon image: arg1.  label ifNotNil: [ icon setBalloonText: label maxLineLength: 100 ].  action ifNotNil: [ icon on: #click send: #value to: action ]topLeftColor  ^self colorselectIndex: arg1 event: arg2  self toggleIndex: arg1selectedRowsIndexesFrom: arg1  | tmp1 tmp2 |  tmp1 := arg1.  self recentlyChanged ifTrue: [ ^(self dataSource table selectedIndexes select: [:arg2 |  arg2 between: tmp1 and: tmp1 + self numberOfVisibleChildren ]) ifEmpty: [ {} ] ifNotEmpty: [ {tmp1} ] ].  tmp2 := (self dataSource table selectedIndexes includes: tmp1) ifTrue: [ {tmp1} ] ifFalse: [ {} ].  self isExpanded ifFalse: [ ^tmp2 ].  tmp1 := tmp1 + 1.  ^(self children flatCollect: [:arg3 |  | tmp3 |        tmp3 := arg3 selectedRowsIndexesFrom: tmp1.        tmp1 := tmp1 + 1 + arg3 numberOfVisibleChildren.        tmp3 ]) , tmp2replaceFrom: arg1 to: arg2 with: arg3  text replaceFrom: arg1 to: arg2 with: arg3.  self recomposeFrom: arg1 to: arg1 + arg3 size - 1 delta: arg3 size - (arg2 - arg1 + 1)drawSubmorphsOnAthensCanvas: arg1  super drawSubmorphsOnAthensCanvas: arg1.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOnAthensCanvas: arg1 ]doAutoAccept: arg1  self autoAccept == true ifTrue: [ self editView hasUnacceptedEdits ifTrue: [ self editor accept ] ]listCenteringString: arg1  ^self layoutMenuPropertyString: arg1 from: self listCenteringincrement  bar incrementgrabMorph: arg1  arg1 hand grabMorph: selfthemeChanged  self allMorphsDo: [:arg1 |  (arg1 isKindOf: StringMorph) ifTrue: [ arg1 color: self theme textColor ] ].  super themeChangedmouseLeave: arg1  hasFocus := falsestepTime  ^50childNodeClassFromItem: arg1  ^PackageMethodCategoryNodeExamplechooseColor  | tmp1 |  tmp1 := self theme chooseColorIn: ((self ownerThatIsA: SystemWindow) ifNil: [ self ]) title: 'Choose Color' translated color: self labelMorph color.  tmp1 ifNil: [ ^self ].  self labelMorph color: tmp1.  self solidLabelMorph color: tmp1 beOpaque.  self setColorSelector ifNotNil: [ self model perform: self setColorSelector with: tmp1 ]anyModifierKeyPressed  ^recentModifiers anyMask: 16r0EonColor: arg1 offColor: arg2  onColor := arg1.  offColor := arg2.  self update: #onOffColor.  self update: getStateSelectordelete  self isCloseable ifFalse: [ ^self ].  self deleteDiscardingChangesbuildTopHeader  | tmp1 |  tmp1 := OrderedCollection new.  self columns do: [:arg1 |  arg1 container: self.        tmp1 add: (arg1 header                 hResizing: #rigid;                 layoutChanged;                 yourself) ].  topHeader := Morph new fillStyle: self topHeaderBackground.  self addMorph: topHeader.  topHeader clipSubmorphs: true.  topHeader borderColor: Color veryLightGray.  topHeader color: Color transparent.  topHeader borderWidth: 0.  topHeader addAllMorphs: tmp1.  topHeader bounds: (scroller left @ self top corner: scroller right @ (self top + self topHeaderHeight))plugOne  | tmp1 |  rootClass := Object.  tmp1 := PluggableListMorph on: self list: #rootItems selected: #selected changeSelected: #selected:.  (tmp1 embeddedInMorphicWindowLabeled: 'test') openInWorldstring: arg1  string := arg1createWindowGroup  | tmp1 tmp2 tmp3 |  tmp2 := self position.  tmp3 := self extent.  tmp1 := GroupWindowMorph new.  tmp1 addWindow: self.  (tmp1 openInWindowLabeled: 'Group: ' translated , self label)     extent: tmp3;     position: tmp2;     model: tmp1intoWorld: arg1  arg1 ifNil: [ ^self ].  self wantsSteps ifTrue: [ arg1 startStepping: self ].  self submorphsDo: [:arg2 |  arg2 intoWorld: arg1 ]layoutBounds: arg1  super layoutBounds: arg1.  self computeSliderclipboardText  ^self osWindow clipboardTextmaxDepth  ^maxDepthcontainingWindow  ^self ownerThatIsA: SystemWindowcloseable: arg1  closeable := arg1.  arg1 ifTrue: [ self setUnlockedIcon ] ifFalse: [ self setLockedIcon ]minExtentOf: arg1 in: arg2  ^0 @ 0rootMorphsAt: arg1  ^self submorphs select: [:arg2 |  (arg2 fullContainsPoint: arg1) and: [ arg2 isLocked not ] ]update: arg1  arg1 == getSelectionSelector ifTrue: [ self selection: self getCurrentSelectionItem.        ^self ].  arg1 == getListSelector ifTrue: [ self list: self getList.        ^self ].  ((arg1 isKindOf: Array) and: [ arg1 size > 1 and: [ arg1 first == getListSelector and: [ arg1 second == #openPath ] ] ]) ifTrue: [ ^(scroller submorphs at: 1 ifAbsent: [ ^self ]) openPath: (arg1 allButFirst: 2) ].  ((arg1 isKindOf: Array) and: [ arg1 size > 1 and: [ arg1 first == getListSelector and: [ arg1 second == #openItemPath ] ] ]) ifTrue: [ ^(scroller submorphs at: 1 ifAbsent: [ ^self ]) openItemPath: (arg1 allButFirst: 2) ].  ((arg1 isKindOf: Array) and: [ arg1 notEmpty and: [ arg1 first == #openPath ] ]) ifTrue: [ ^(scroller submorphs at: 1 ifAbsent: [ ^self ]) openPath: arg1 allButFirst ].  ((arg1 isKindOf: Array) and: [ arg1 size = 2 and: [ arg1 first = getListSelector and: [ arg1 second == #expandRoots ] ] ]) ifTrue: [ ^self expandRoots ].  ((arg1 isKindOf: Array) and: [ arg1 notEmpty and: [ arg1 first = getListSelector and: [ arg1 second == #expandAll ] ] ]) ifTrue: [ ^self expandAll ]subMenu  ^subMenudrawColumnOn: arg1  self isPotentialDropTarget ifTrue: [ arg1 frameAndFillRectangle: self dataBounds fillColor: ((Color gray alpha: 0.1) alphaMixed: 0.9 with: (self color ifNotNil: [:arg2 |  arg2 asColor ] ifNil: [ Color transparent ])) borderWidth: 2 borderColor: Color gray ] ifFalse: [ self color ifNotNil: [:arg2 |  arg2 isColor ifTrue: [ arg1 frameAndFillRectangle: self dataBounds fillColor: self color borderWidth: 0 borderColor: Color transparent ] ifFalse: [ arg2 origin: self dataBounds topLeft.                    arg2 direction: 0 @ self dataBounds height.                    arg1 fillRectangle: self dataBounds basicFillStyle: arg2 ] ] ]width: arg1  width := arg1removeListener: arg1 from: arg2  | tmp1 |  arg2 ifNil: [ ^nil ].  tmp1 := arg2.  tmp1 := tmp1 copyWithout: arg1.  tmp1 := tmp1 copyWithout: nil.  tmp1 isEmpty ifTrue: [ tmp1 := nil ].  ^tmp1wrapScrolling: arg1  wrapScrolling := arg1.  self     changed: #leftButtonEnabled;     changed: #rightButtonEnabledaddTab: arg1 selected: arg2  self tabs add: (self newLabelMorph: arg1 selected: arg2).  self updateTabswantsDroppedObject: arg1  ^falsescreenRectangle  ^self fullBoundsisLinkedTo: arg1  self firstInChain withSuccessorsDo: [:arg2 |  arg2 == arg1 ifTrue: [ ^true ] ].  ^falsedrawSubmorphsOn: arg1  | tmp1 |  super drawSubmorphsOn: arg1.  (self hasKeyboardFocus and: [ (tmp1 := self selectedTab) notNil and: [ tmp1 owner notNil ] ]) ifTrue: [ self clipSubmorphs ifTrue: [ arg1 clipBy: (arg1 clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: [:arg2 |  tmp1 drawKeyboardFocusOn: arg2 ] ] ifFalse: [ tmp1 drawKeyboardFocusOn: arg1 ] ]addMorphsTo: arg1 from: arg2 allowSorting: arg3 withExpandedItems: arg4 atLevel: arg5  | tmp1 tmp2 tmp3 |  tmp1 := nil.  tmp2 := (arg3 and: [ sortingSelector notNil ]) ifTrue: [ (arg2 asSortedCollection: [:arg6 :arg7 |  (arg6 perform: sortingSelector) <= (arg7 perform: sortingSelector) ]) asOrderedCollection ] ifFalse: [ arg2 ].  tmp3 := nil.  tmp2 do: [:arg8 |  tmp1 := self indentingItemClass basicNew initWithContents: arg8 prior: tmp1 forList: self indentLevel: arg5.        tmp3 ifNil: [ tmp3 := tmp1 ].        arg1 add: tmp1.        ((arg8 hasEquivalentIn: arg4) or: [ tmp1 isExpanded ]) ifTrue: [ tmp1 isExpanded: true.              tmp1 addChildrenForList: self addingTo: arg1 withExpandedItems: arg4 ] ].  ^tmp3testSortDataSourceWithChainedSortFunction  | tmp1 |  tmp1 := self complexDataSourceForTesting.  strategy sortFunction: [:arg1 |  arg1 \\ 10 ] ascending , #yourself ascending.  self assert: tmp1 elements equals: self complexElementsForTestDataSource.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(10 20 70 80 3 28 29).  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(29 28 3 80 70 20 10).  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: self complexElementsForTestDataSourceshowCurrentPage  self buildPanel.  treeMorph scroller removeAllMorphs.  (self nodeList isNil or: [ self nodeList isEmpty ]) ifTrue: [ ^treeMorph emptySelection ].  treeMorph addSubmorphsFromNodeList.  treeMorph updateColumnMorphs.  treeMorph scrollSelectionIntoViewfillsOwnerString  ^self fillsOwner -> 'fills owner' translatedisSelected  ^self selectedaddAllMorphs: arg1 after: arg2  ^self privateAddAllMorphs: arg1 atIndex: (arg2 index ifNil: [ submorphs size ])animateRestoreFromMinimized  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self worldTaskbar ifNil: [ ^self ].  tmp2 := ((tmp1 taskButtonOf: self) ifNil: [ ^self ]) bounds.  tmp3 := self isFlexed ifTrue: [ (owner transform globalPointToLocal: fullFrame topLeft) extent: fullFrame extent ] ifFalse: [ fullFrame ].  tmp5 := self theme numberOfStepsForAnimations.  tmp4 := (1 / tmp5 to: 1 by: 1 / tmp5) collect: [:arg1 |  tmp2 interpolateTo: tmp3 at: ((20 raisedTo: arg1) - 1) / 19 ].  self fastAnimateRectangles: tmp4close: arg1  self bars isEmpty ifTrue: [ ^self ].  lock critical: [ arg1 delete.        self bars size = 0 ifTrue: [ self width: 0.              self delete ] ].  self refreshfullDrawOn: arg1  super fullDrawOn: (arg1 asAlphaBlendingCanvas: alpha)testResizingClosing  | tmp1 |  window := SystemWindow labelled: 'foo'.  tmp1 := OrderedCollection new.  window openInWorld.  window announcer when: WindowAnnouncement do: [:arg1 |  tmp1 add: arg1 ].  self assertEmpty: tmp1.  window minimizeOrRestore.  self assert: tmp1 size equals: 4.  self assert: tmp1 first isResized.  self assert: tmp1 second isMoved.  self assert: tmp1 third isDeActivated.  self assert: tmp1 fourth isCollapsed.  window delete.  self assert: tmp1 size equals: 5.  self assert: tmp1 fifth isClosed.  window := nilnewGroupboxForAll: arg1  ^self theme newGroupboxIn: self forAll: arg1expandFullBoundsForDropShadow: arg1  ^(arg1 expandBy: self shadowMargins) quickMerge: arg1isSticky  extension ifNil: [ ^false ].  ^extension stickypoint: arg1 in: arg2  owner ifNil: [ ^arg1 ].  ^(owner transformFrom: arg2) localPointToGlobal: arg1onAnnouncement: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3release  traceMorph := nil.  oldColor := nil.  container := nil.  self releaseActionMap.  super releasedataSource: arg1  dataSource := arg1.  children do: [:arg2 |  arg2 dataSource: arg1 ]position  ^positionhandlesKeyStroke: arg1  ^self handlesKeyboard: arg1highlightPotentialDropRow: arg1 on: arg2  | tmp1 |  tmp1 := self drawBoundsForRow: arg1.  tmp1 := tmp1 intersect: self bounds ifNone: [ ^self ].  arg2 frameRectangle: tmp1 color: Color bluehasDataSource  ^self dataSource notNilveryDeepInner: arg1  super veryDeepInner: arg1.  isEnabled := isEnabled veryDeepCopyWith: arg1.  subMenu := subMenu veryDeepCopyWith: arg1.  isSelected := isSelected veryDeepCopyWith: arg1.  icon := icon veryDeepCopyWith: arg1.  arguments := argumentscursorPoint  ^positionrememberOverList  mouseOverMorphs := overMorphs contentsrepressedImage: arg1  repressedImage := arg1.  self invalidRect: self boundshighlightingColor  ^self theme selectionColorisFirstItem  ^owner notNil and: [ owner submorphs first == self ]hScrollbar: arg1  hScrollbar := arg1windowEventHandler  ^WindowEventHandlercurrentCursor  ^currentCursorisTopWindow  ^self == TopWindowshortcutCharacter: arg1  shortcutCharacter := arg1forwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1generateWindowEvent: arg1  | tmp1 |  tmp1 := WindowEvent new.  tmp1 setTimeStamp: arg1 second.  tmp1 timeStamp = 0 ifTrue: [ tmp1 setTimeStamp: Time millisecondClockValue ].  tmp1 action: arg1 third.  tmp1 rectangle: (Rectangle origin: arg1 fourth @ arg1 fifth corner: arg1 sixth @ arg1 seventh).  ^tmp1drawOnCanvasWrapperFor: arg1  self drawOn: arg1 asCanvasWrapperwantsKeyboardFocusNavigation  ^super wantsKeyboardFocusNavigation and: [ self valueOfProperty: #wantsKeyboardFocusNavigation ifAbsent: [ true ] ]spawnFilterUpdateThread  [ | tmp1 |  tmp1 := nil.  [ isEditingSemaphore wait.  tmp1 ~= pattern ifTrue: [ tmp1 := pattern.        0.2 seconds wait.        tmp1 = pattern ifTrue: [ self filter ] ] ] repeat ] forkAt: Processor userBackgroundPriorityhandleSize  ^self class splitterWidth @ 30disableSort  self sortingStrategy: (FTNullColumnSortingStrategy column: self)selectedMouseOverFillStyle  ^self theme taskbarItemSelectedMouseOverFillStyleFor: selfempty  self selectedNodePathList: OrderedCollection newexternalName  ^self assureExtension externalName ifNil: [ self printString ]displayScaleFactor  ^self currentWorld displayScaleFactorremoveColumn: arg1  self removeColumnAtIndex: (self columns indexOf: arg1)rightFraction: arg1  rightFraction := arg1blue  ^(self selectedColor blue * 255) asIntegernewBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 help: arg7  ^self newBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: nil help: arg7animateClose  defaultBounds  ^0 @ 0 corner: 16 @ 100selector  ^selectorresetPotentialDropMorph  potentialDropMorph ifNotNil: [ potentialDropMorph resetHighlightForDrop.        potentialDropMorph := nil ]hands  ^worldState handsscrollSelectionIntoView  | tmp1 |  tmp1 := self getCurrentSelectionIndex.  self scrollSelectionToRow: tmp1mouseLeaveDragging: arg1  (self dropEnabled and: [ arg1 hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: arg1 ].  self resetPotentialDropMorph.  arg1 hand releaseMouseFocus: selfadd: arg1 selector: arg2  self add: arg1 target: defaultTarget selector: arg2 argumentList: EmptyArraychooseDropList: arg1 list: arg2  ^self chooseDropList: arg1 title: 'Choose' translated list: arg2string: arg1 fontName: arg2 size: arg3 wrap: arg4  arg4 ifTrue: [ self contentsWrapped: arg1 ] ifFalse: [ self contents: arg1 ].  self fontName: arg2 size: arg3newString: arg1  ^self theme newStringIn: self label: arg1 font: self theme labelFont style: #plainpopUpFor: arg1 event: arg2  | tmp1 tmp2 |  self flag: #workAround.  tmp2 := arg2 ifNil: [ tmp1 := arg1 world ifNotNil: [:arg3 |  arg3 activeHand ].        tmp1 ifNil: [ tmp1 := arg1 world primaryHand ].        tmp1 lastEvent transformedBy: (arg1 transformedFrom: nil) ] ifNotNil: [ tmp1 := arg2 hand.        arg2 ].  self target: arg1.  tmp1 halo: self.  tmp1 world addMorphFront: self.  positionOffset := tmp2 position - (arg1 point: arg1 position in: owner).  self startSteppingboundsForKeyText: arg1 font: arg2  | tmp1 tmp2 tmp3 |  tmp1 := self owner hasSubMenu ifTrue: [ self owner right - self owner subMenuMarker width ] ifFalse: [ self owner right ].  tmp1 := tmp1 - (tmp2 := arg2 widthOfString: arg1).  tmp3 := tmp1 @ ((self owner bounds top + self owner bounds bottom - arg2 height) // 2) extent: tmp2 @ self owner height.  ^tmp3redButtonChanged  ^whichButton anyMask: self class redButtonaddFirstInHistory: arg1  self removeFromHistory: arg1.  selectionHistory addFirst: arg1smoothOrSegmentedPhrase  | tmp1 |  tmp1 := (closed ifTrue: [ 'outline' ] ifFalse: [ 'line' ]) translated.  ^self isCurve ifTrue: [ 'make segmented {1}' translated format: {tmp1} ] ifFalse: [ 'make smooth {1}' translated format: {tmp1} ]rightFraction: arg1 offset: arg2  rightFraction := arg1.  rightOffset := arg2withHandPositionDo: arg1  arg1 value: self positiononImage: arg1  self image: arg1columnInset: arg1  columnInset := arg1taskThumbnailOfSize: arg1  | tmp1 tmp2 |  tmp1 := self isMinimized ifTrue: [ self restoreBeforeGeneratingThumbnail.        true ] ifFalse: [ false ].  tmp2 := self basicTaskThumbnailOfSize: arg1.  tmp1 ifTrue: [ self minimizeAfterGeneratingThumbnail ].  ^tmp2nullIndex  ^#(0 0)handlesKeyboard: arg1  ^trueadd: arg1 target: arg2 selector: arg3 argument: arg4  ^self add: arg1 target: arg2 selector: arg3 argumentList: (Array with: arg4)updateGradients  | tmp1 tmp2 |  tmp2 := self innerBounds.  tmp1 := self submorphs last.  tmp1 bounds: tmp2.  tmp1 fillStyle     origin: tmp2 topLeft;     direction: 0 @ tmp2 height.  self fillStyle     origin: tmp2 topLeft;     direction: tmp2 width @ 0.  self updateSelectedLocationmouseEnter: arg1 fromMorph: arg2  ^self notify: arg1 from: arg2drawOnAthensCanvas: arg1  super drawOnAthensCanvas: arg1.  arg1 morphicDrawString: self label in: self labelBounds font: self font color: self fontColoraddARowCentered: arg1  ^(self addARow: arg1)     hResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #leftCenterbrickDoubleLink: arg1  self setProperty: #brickDoubleLink toValue: arg1initialize  super initialize.  scrollDelta := 0.02.  pageDelta := 0.2contentsMenu: arg1  (self submorphs asSortedCollection: [:arg2 :arg3 |  arg2 class name caseInsensitiveLessOrEqual: arg3 class name ]) do: [:arg4 |  arg1 add: arg4 class name target: arg4 selector: #comeToFront ].  ^arg1handleColor  ^handleColor ifNil: [ self setDefaultColors.        handleColor ]action  ^actiondropItemSelector: arg1  dropItemSelector := arg1.  arg1 ifNotNil: [ self dropEnabled: true ]showScrollBarsOnlyWhenNeeded: arg1  self showHScrollBarOnlyWhenNeeded: arg1.  self showVScrollBarOnlyWhenNeeded: arg1handleFatalDrawingError: arg1  Display deferUpdates: false.  self primitiveError: arg1privateAddAllMorphs: arg1 atIndex: arg2  | tmp1 tmp2 |  tmp1 := self world.  tmp2 := submorphs copyWithoutAll: arg1.  (arg2 between: 0 and: tmp2 size) ifFalse: [ ^self error: 'index out of range' ].  arg2 = 0 ifTrue: [ submorphs := arg1 asArray , tmp2 ] ifFalse: [ arg2 = tmp2 size ifTrue: [ submorphs := tmp2 , arg1 ] ifFalse: [ submorphs := tmp2 copyReplaceFrom: arg2 + 1 to: arg2 with: arg1 ] ].  arg1 do: [:arg3 |  | tmp3 tmp4 |        tmp3 := arg3 owner.        tmp3 ifNotNil: [ tmp4 := arg3 world.              tmp4 == tmp1 ifFalse: [ tmp4 ifNotNil: [ self privateInvalidateMorph: arg3 ].                    arg3 outOfWorld: tmp4 ].              tmp3 ~~ self ifTrue: [ arg3 owner privateRemove: arg3.                    arg3 owner removedMorph: arg3 ] ].        arg3 privateOwner: self.        tmp1 ifNotNil: [ self privateInvalidateMorph: arg3 ].        tmp1 == tmp4 ifFalse: [ arg3 intoWorld: tmp1 ].        tmp3 == self ifFalse: [ self addedMorph: arg3.              arg3 noteNewOwner: self ] ].  self layoutChangedsetOptimalResizing  self hResizing: #rigid.  self vResizing: #rigidcopy  ^super copy text: text copy textStyle: textStyle copy wrap: wrapFlag color: color predecessor: nil successor: nilconfigureForEmbedding  labelArea owner notNil ifTrue: [ self           hasDropShadow: false;           beWithoutGrips;           removeLabelArea;           makeBorderless.        self submorphsDo: [:arg1 |  arg1 unlock ] ]layout: arg1  | tmp1 |  (tmp1 := layout) = arg1 ifTrue: [ ^self ].  layout := arg1.  ((tmp1 = #scaled or: [ tmp1 = #scaledAspect ]) or: [ arg1 = #scaled or: [ arg1 = #scaledAspect ] ]) ifTrue: [ self cachedForm: nil ].  self changedptName  ^#bottomRightescapePressed  self cancelactivate  (self morph respondsTo: #restoreAndActivate) ifTrue: [ self morph restoreAndActivate ]newSliderFor: arg1 getValue: arg2 setValue: arg3 help: arg4  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: 0 max: 1 quantum: nil getEnabled: nil help: arg4isTaskbar  ^falsestart  self startSteppingreleaseCachedState  super releaseCachedState.  self cleanseStepListlayoutProportionallyIn: arg1  | tmp1 tmp2 |  tmp2 := self layoutFrame ifNil: [ ^self ].  tmp1 := tmp2 layout: self bounds in: arg1.  tmp1 = self bounds ifTrue: [ ^self ].  ^self layoutInBounds: tmp1wasHandled: arg1  wasHandled := arg1restore  self isMinimized ifTrue: [ self collapseBoxHit ] ifFalse: [ self isMaximized ifTrue: [ self expandBoxHit ] ]printOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     print: self;     nextPut: $)beRadioButton  self buttonMorph beRadioButtondefaultBorderWidth  ^0morphsInFrontOverlapping: arg1  | tmp1 |  tmp1 := Array new writeStream.  self morphsInFrontOf: nil overlapping: arg1 do: [:arg2 |  tmp1 nextPut: arg2 ].  ^tmp1 contentsnewCloseButtonFor: arg1  ^self theme newCloseButtonIn: self for: arg1wantsDroppedMorph: arg1 event: arg2  self visible ifFalse: [ ^false ].  self dropEnabled ifFalse: [ ^false ].  ^truelineSegmentsDo: arg1  | tmp1 tmp2 tmp3 tmp4 |  vertices size < 1 ifTrue: [ ^self ].  self isCurvy ifFalse: [ tmp4 := nil.        vertices do: [:arg2 |  tmp4 ifNotNil: [ arg1 value: tmp4 value: arg2 ].              tmp4 := arg2 ].        (closed or: [ vertices size = 1 ]) ifTrue: [ arg1 value: tmp4 value: vertices first ].        ^self ].  tmp1 := self coefficients.  tmp4 := (tmp2 := tmp1 first first) @ (tmp3 := tmp1 fifth first).  (closed ifTrue: [ 1 to: tmp1 first size ] ifFalse: [ 1 to: tmp1 first size - 1 ]) do: [:arg3 |  | tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 |        tmp9 := tmp1 second at: arg3.        tmp12 := tmp1 sixth at: arg3.        tmp11 := tmp1 third at: arg3.        tmp13 := tmp1 seventh at: arg3.        tmp7 := tmp1 fourth at: arg3.        tmp8 := tmp1 eighth at: arg3.        tmp6 := tmp1 ninth at: arg3.        1 to: tmp6 - 1 do: [:arg4 |  tmp5 := arg4 asFloat / tmp6 asFloat.              tmp10 := (((tmp7 * tmp5 + tmp11) * tmp5 + tmp9) * tmp5 + tmp2) @ (((tmp8 * tmp5 + tmp13) * tmp5 + tmp12) * tmp5 + tmp3).              arg1 value: tmp4 value: tmp10.              tmp4 := tmp10 ].        tmp10 := (tmp2 := tmp1 first atWrap: arg3 + 1) @ (tmp3 := tmp1 fifth atWrap: arg3 + 1).        arg1 value: tmp4 value: tmp10.        tmp4 := tmp10 ]font  ^self labelMorph fontaddColumnResizers  columnResizers := self columnResizerFrames withIndexCollect: [:arg1 :arg2 |  (MorphTreeResizerMorph container: self index: arg2) bounds: (arg1 translateBy: scroller offset x negated @ 0) ].  self addAllMorphs: columnResizers.  self columnResizersToFrontchildrenItems  ^self parentNode item selectorsInProtocol: self itemcolumnDropUnabled: arg1  columnDropUnabled := arg1keystrokeActionSelector  ^keystrokeActionSelectorunderlined  self changeEmphasis: #underlinedsetNextDirectionFromEvent: arg1  nextPageDirection := bounds isWide ifTrue: [ arg1 cursorPoint x >= slider center x ] ifFalse: [ arg1 cursorPoint y >= slider center y ]layout: arg1 in: arg2  handlesMouseOver: arg1  (self existsSubscriptionsFor: #mouseEnter) ifTrue: [ ^true ].  (self existsSubscriptionsFor: #mouseLeave) ifTrue: [ ^true ].  (self existsSubscriptionsFor: #mouseOver) ifTrue: [ ^true ].  ^falseresult: arg1  lock critical: [ hasResult := true.        result := arg1 ]veryDeepInner: arg1  super veryDeepInner: arg1.  actWhen := actWhen veryDeepCopyWith: arg1.  oldColor := oldColor veryDeepCopyWith: arg1.  label := label veryDeepCopyWith: arg1setStateSelector: arg1  setStateSelector := arg1initialize  super initialize.  self showWhenNeededchangeAlignment: arg1  self editor applyAttribute: (TextAlignment perform: arg1).  self updateFromParagraphbackgroundColorFor: arg1  | tmp1 |  arg1 ifNil: [ ^nil ].  self enabled ifFalse: [ tmp1 := Color white darker darker ].  self backgroundColoringBlockOrSelector ifNotNil: [:arg2 |  | tmp2 |        tmp2 := getListElementSelector ifNil: [ list at: arg1 ifAbsent: [ ^nil ] ] ifNotNil: [ model perform: getListElementSelector with: arg1 ].        tmp1 := arg2 isBlock ifTrue: [ arg2 cull: tmp2 cull: arg1 ] ifFalse: [ arg2 isSymbol ifTrue: [ arg2 numArgs == 0 ifTrue: [ tmp2 perform: arg2 ] ifFalse: [ self model perform: arg2 withEnoughArguments: {tmp2 .                                 arg1} ] ] ifFalse: [ nil ] ] ].  ^tmp1 isColor ifTrue: [ tmp1 ] ifFalse: [ nil ]addAllMorphs: arg1  super addAllMorphs: arg1.  arg1 do: [:arg2 |  self startSteppingSubmorphsOf: arg2 ]setActWhen  | tmp1 |  tmp1 := #(#buttonDown #buttonUp #whilePressed #startDrag).  actWhen := UIManager default chooseFrom: (tmp1 collect: [:arg1 |  arg1 translated ]) values: tmp1 title: 'Choose one of the following conditions' translatedworld: arg1  world := arg1beTransparent  self color: Color transparenttabs  ^tabsisSingle  ^self isMultiple notprivateFullBounds  | tmp1 |  submorphs isEmpty ifTrue: [ ^self outerBounds ].  tmp1 := self outerBounds copy.  tmp1 := tmp1 quickMerge: (self clipSubmorphs ifTrue: [ self submorphBounds intersect: self clippingBounds ifNone: [ self clippingBounds ] ] ifFalse: [ self submorphBounds ]).  ^tmp1 origin asIntegerPoint corner: tmp1 corner asIntegerPointextent: arg1  | tmp1 tmp2 |  tmp2 := self referencePosition.  tmp1 := arg1 max: 20 @ 20.  self setVertices: (vertices collect: [:arg2 |  (arg2 - tmp2) * (tmp1 asFloatPoint / (bounds extent max: 1 @ 1)) + tmp2 ])taskbarButtonFor: arg1  ^nilmouseLeave: arg1  self canResizeColumn ifFalse: [ ^self ].  super mouseLeave: arg1isKeyboard  ^truenewRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6  ^self theme newRadioButtonIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6selectionColor: arg1  selectionColor := arg1.  paragraph ifNotNil: [:arg2 |  arg2 selectionColor: arg1 ]calculateExactVisibleRows  | tmp1 |  tmp1 := self height / (self table rowHeight + self table intercellSpacing y).  ^headerRow ifNotNil: [ tmp1 - 1 ] ifNil: [ tmp1 ]stepTime  ^100selectionColor: arg1  | tmp1 |  arg1 ifNil: [ self removeProperty: #selectionColor ] ifNotNil: [ self setProperty: #selectionColor toValue: arg1 ].  tmp1 := self ownerThatIsA: SystemWindow.  self selectionColorToUse: ((self theme fadedBackgroundWindows not or: [ tmp1 isNil or: [ tmp1 isActive ] ]) ifTrue: [ arg1 ] ifFalse: [ self theme unfocusedSelectionColor ])alwaysShowHScrollbar  ^self class alwaysShowHScrollbarupdatePinForm  pinBox ifNotNil: [ pinBox           labelGraphic: self pinForm;           extent: self boxExtent ]updateColor  | tmp1 |  self autoGradient ifFalse: [ ^self ].  tmp1 := GradientFillStyle ramp: self gradientRamp.  tmp1 origin: self topLeft.  self isVertical ifTrue: [ tmp1 direction: self width @ 0 ] ifFalse: [ tmp1 direction: 0 @ self height ].  self fillStyle: tmp1newLabelGroup: arg1  ^self theme newLabelGroupIn: self for: arg1isExpanded: arg1  selectAll  self editor selectFrom: 1 to: text sizeforwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1helpText  ^self balloonTextupdateData  selectionContainsPoint: arg1  ^self selectionRects anySatisfy: [:arg2 |  arg2 containsPoint: arg1 ]page: arg1  self selectedPageIndex: (self pages indexOf: arg1)handlesDropShadowInHand  ^falsedatasource: arg1  dataSource := arg1environment: arg1  deselectAndFocusOutermenuOn: arg1  self selectItem: nil event: arg1.  arg1 hand newMouseFocus: popUpOwner owner.  ^arg1 hand newKeyboardFocus: popUpOwner ownerexecuteSortingOn: arg1  arg1 sortWith: self context ascendingSortFunction reversedaddHalo: arg1  | tmp1 |  self halosEnabled ifFalse: [ ^self ].  tmp1 := (Smalltalk globals at: self haloClass ifAbsent: [ HaloMorph ]) new.  tmp1 bounds: (tmp1 worldBoundsForMorph: self).  tmp1 popUpFor: self event: arg1.  ^tmp1initialize  super initialize.  value := 0.0.  descending := false.  self initializeSlidergetOldColor  ^oldColor ifNil: [ Color transparent ]step  ^stepheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]internalSpaces: arg1  internalSpaces := arg1autoDeselect: arg1  autoDeselect := arg1newCloseControlFor: arg1 action: arg2 help: arg3  ^self theme newCloseControlIn: self for: arg1 action: arg2 help: arg3addColumn: arg1  columns := columns copyWith: arg1dropMorph: arg1 event: arg2  | tmp1 tmp2 |  (arg2 isMouseUp and: [ arg1 shouldDropOnMouseUp not ]) ifTrue: [ ^self ].  self privateRemove: arg1.  arg1 privateOwner: self.  tmp2 := arg1.  (tmp2 hasProperty: #addedFlexAtGrab) ifTrue: [ tmp2 := arg1 removeFlexShell ].  tmp1 := DropEvent new setPosition: self position contents: tmp2 hand: self.  self sendEvent: tmp1 focus: nil.  tmp1 wasHandled ifFalse: [ arg1 rejectDropMorphEvent: tmp1 ].  arg1 owner == self ifTrue: [ arg1 delete ].  self mouseOverHandler processMouseOver: arg2extent  ^bounds extentmessage: arg1  ^self message: arg1 title: 'Information' translatedlastPaneColor: arg1  lastPaneColor := arg1newDialogPanel  ^self theme newDialogPanelIn: selfminWidth  ^self hResizing = #shrinkWrap ifTrue: [ self scrollTarget minExtent x + self scrollbarThickness + 5 ] ifFalse: [ super minWidth ]themeChanged  self fillStyle: self normalFillStyle.  super themeChangednodeExpandRequest: arg1  arg1 nodes ifEmpty: [ self expandAll ] ifNotEmpty: [:arg2 |  arg1 recur ifTrue: [ self expandAllFromNode: arg2 last ] ifFalse: [ self expandNodePath: arg2 ] ]isMultipleSelection  ^self multipleSelectiontabAddedToSelection: arg1  arg1 selected ifTrue: [ ^self ].  numberOfSelectedTabs := numberOfSelectedTabs + 1.  self addInHistory: arg1.  arg1 silentlySelected: true.  self adjustLayout.  self triggerEvent: #tabAddedToSelection with: arg1keyboardFocusChange: arg1  super keyboardFocusChange: arg1.  arg1 ifTrue: [ self defaultFocusMorph ifNotNil: [:arg2 |  arg2 takeKeyboardFocus ] ]exportAsPNGSilently  | tmp1 tmp2 |  tmp2 := (DateAndTime now asString copyReplaceAll: ':' with: '-') copyReplaceAll: '.' with: '-'.  tmp1 := self externalName , tmp2 , '.png'.  PNGReadWriter putForm: self imageForm onFileNamed: tmp1newButtonFor: arg1 action: arg2 label: arg3 help: arg4  ^self newButtonFor: arg1 getState: nil action: arg2 arguments: nil getEnabled: nil label: arg3 help: arg4layoutBounds  | tmp1 |  tmp1 := super layoutBounds.  ^tmp1 withTop: tmp1 top + self labelHeighthasDocumentAnchorString  ^(self textAnchorType == #document) -> 'Document' translatedaddCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  arg1 addLine.  arg1 add: 'list font...' target: self selector: #setListFont.  arg1 add: 'copy list to clipboard' target: self selector: #copyListToClipboard.  arg1 add: 'copy selection to clipboard' target: self selector: #copySelectionToClipboardwantsDroppedMorph: arg1 event: arg2  arg1 isTransferable ifFalse: [ ^false ].  ^self dataSource wantsDropElements: arg1 passenger type: arg1 dragTransferType index: ((self container rowIndexContainingPoint: arg2 position) ifNil: [ 0 ])calculateMinVisibleRows  ^self calculateExactVisibleRows floormatches: arg1  ^arg1 includesSubstring: pattern caseSensitive: falseupdateList  | tmp1 |  self listMorph listChanged.  self setScrollDeltas.  scrollBar setValue: 0.0.  tmp1 := self getCurrentSelectionIndex.  self resetPotentialDropRow.  tmp1 ifNotNil: [ tmp1 := tmp1 min: self getListSize.        tmp1 > 0 ifTrue: [ self selectionIndex: tmp1 ] ].  self searchedElement: niladdUpdating: arg1 selector: arg2  self addUpdating: arg1 target: defaultTarget selector: arg2 argumentList: EmptyArraystartStepping  self startStepping: #stepAt: at: Time millisecondClockValue arguments: nil stepTime: nilnewOKButton  ^self newOKButtonFor: selfaMorph: arg1  aMorph := arg1drawBackgroundForSelectedRow: arg1 on: arg2  self drawBackgroundForRow: arg1 on: arg2 color: listSource selectionColorToUsestate: arg1  state := arg1realSearch  | tmp1 |  tmp1 := self table dataSource searchText: pattern.  tmp1 ifNotEmpty: [ self table selectIndex: tmp1 first ].  self table highlightIndexes: tmp1.  ^tmp1 notEmptycanResizeColumn  ^(container columns at: index) resizablecellPositioningString: arg1  ^self layoutMenuPropertyString: arg1 from: self cellPositioningcolor: arg1  color := arg1initialize  super initialize.  self extent: 8 @ 8addExtraSpace: arg1  extraSpace ifNil: [ extraSpace := arg1 ] ifNotNil: [ extraSpace := extraSpace + arg1 ]commandKeyHandler  ^self valueOfProperty: #commandKeyHandler ifAbsent: [ nil ]wantsExpandBox  ^falseextent: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self isCollapsed ifTrue: [ arg1 max: self labelWidgetAllowance @ 0 ] ifFalse: [ arg1 max: self minimumExtent ].  tmp1 = self extent ifTrue: [ ^self ].  tmp3 := self extent.  isCollapsed ifTrue: [ super extent: tmp1 x @ self labelHeight ] ifFalse: [ super extent: tmp1 ].  isCollapsed ifTrue: [ collapsedFrame := self bounds ] ifFalse: [ fullFrame := self bounds ].  (self isCollapsed or: [ label isNil ]) ifFalse: [ label minWidth: nil.        label fitContents.        label width > (bounds width - labelWidgetAllowance) ifTrue: [ label setBalloonText: label contents ] ifFalse: [ label setBalloonText: nil ].        tmp2 := label width min: bounds width - labelWidgetAllowance.        label           setWidth: tmp2;           minWidth: tmp2.        label align: label bounds topCenter with: bounds topCenter + (0 @ borderWidth).        collapsedFrame ifNotNil: [ collapsedFrame := collapsedFrame withWidth: label width + labelWidgetAllowance ] ].  self theme windowExtentChangedFor: self.  self announce: (WindowResizing new           oldSize: tmp3;           newSize: tmp1;           window: self;           yourself)expandedNodesFrom: arg1  ^(arg1 select: [:arg2 |  arg2 isExpanded ]) collect: [:arg2 |  arg2 complexContents ]root: arg1  self roots: {arg1}path  ^parent ifNil: [ OrderedCollection with: self ] ifNotNil: [ parent path           add: self;           yourself ]actionBlock  ^actionBlockbackgroundColor: arg1  backgroundColor := arg1composeLinesFrom: arg1 to: arg2 delta: arg3 into: arg4 priorLines: arg5 atY: arg6  | tmp1 |  tmp1 := self composer composeLinesFrom: arg1 to: arg2 delta: arg3 into: arg4 priorLines: arg5 atY: arg6 textStyle: textStyle text: text container: container wantsColumnBreaks: wantsColumnBreaks == true.  lines := tmp1 first asArray.  ^maxRightX := tmp1 secondtextEntry: arg1 title: arg2  ^self textEntry: arg1 title: arg2 entryText: ''moveOrResizeFromKeystroke: arg1  | tmp1 |  arg1 keyValue = 28 ifTrue: [ tmp1 := -1 @ 0 ].  arg1 keyValue = 29 ifTrue: [ tmp1 := 1 @ 0 ].  arg1 keyValue = 30 ifTrue: [ tmp1 := 0 @ -1 ].  arg1 keyValue = 31 ifTrue: [ tmp1 := 0 @ 1 ].  tmp1 notNil ifTrue: [ arg1 controlKeyPressed ifTrue: [ tmp1 := tmp1 * 10 ].        arg1 shiftPressed ifTrue: [ self extent: self extent + tmp1 ] ifFalse: [ self position: self position + tmp1 ] ]lineSegments  | tmp1 |  tmp1 := OrderedCollection new.  self lineSegmentsDo: [:arg1 :arg2 |  tmp1 addLast: (Array with: arg1 with: arg2) ].  ^tmp1athensSurface  ^owner ifNil: [ nil ] ifNotNil: [ owner athensSurface ]isMouse  ^truemenuColumn: arg1 row: arg2  ^nilsetRotationCenterFrom: arg1  self rotationCenter: (arg1 - self bounds origin) / self bounds extent asFloatPointfieldHeigh  ^StandardFonts defaultFont pixelSize + 10isScrolledFromTop  ^scroller offset y > 0testMouseLeaveFromMorph  morph eventHandler on: #mouseLeave send: #value to: true.  self assert: (morph mouseLeave: nil) identicalTo: trueextent: arg1  super extent: arg1.  graphicalMorph ifNotNil: [ graphicalMorph position: self center - (graphicalMorph extent // 2) ]newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: arg5  ^self theme newTextEditorIn: self for: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: arg5minWidth  ^super minWidth max: self theme buttonMinWidthcopyHandlerState: arg1  handler := arg1 handler.  wasHandled := arg1 wasHandledkeystrokeActionSelector: arg1  keystrokeActionSelector := arg1anchorMorph: arg1 at: arg2 type: arg3  | tmp1 tmp2 tmp3 tmp4 |  arg1 owner == self ifTrue: [ self removeMorph: arg1 ].  arg1 textAnchorType: nil.  arg1 relativeTextAnchorPosition: nil.  self addMorphFront: arg1.  arg1 textAnchorType: arg3.  arg1 relativeTextAnchorPosition: nil.  arg3 == #document ifTrue: [ ^self ].  tmp1 := self transformFromWorld globalPointToLocal: arg2.  tmp2 := (self paragraph characterBlockAtPoint: tmp1) stringIndex.  tmp3 := Text string: (String value: 1) attribute: (TextAnchor new anchoredMorph: arg1).  arg3 == #inline ifTrue: [ self paragraph replaceFrom: tmp2 to: tmp2 - 1 with: tmp3 displaying: false ] ifFalse: [ tmp2 := tmp2 min: paragraph text size.        tmp2 := paragraph text string lastIndexOf: Character cr startingAt: tmp2 ifAbsent: [ 0 ].        tmp4 := paragraph characterBlockForIndex: tmp2 + 1.        arg1 relativeTextAnchorPosition: (tmp1 x - bounds left) @ (tmp1 y - tmp4 top).        self paragraph replaceFrom: tmp2 + 1 to: tmp2 with: tmp3 displaying: false ].  self fitnormalFillStyle  ^self theme tabLabelNormalFillStyleFor: selfminWidth  | tmp1 |  tmp1 := container ifNil: [ 0 ] ifNotNil: [ self indentGap ].  ^tmp1 max: super minWidthaddLayoutMenuItems: arg1 hand: arg2  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 addUpdating: #hasNoLayoutString selector: #changeNoLayout.  tmp1 addUpdating: #hasProportionalLayoutString selector: #changeProportionalLayout.  tmp1 addUpdating: #hasTableLayoutString selector: #changeTableLayout.  tmp1 addLine.  tmp1 add: 'change layout inset...' selector: #changeLayoutInset:.  tmp1 addLine.  self addCellLayoutMenuItems: tmp1 hand: arg2.  self addTableLayoutMenuItems: tmp1 hand: arg2.  arg1 ifNotNil: [ arg1 add: 'layout' subMenu: tmp1 ].  ^tmp1maximumExtent: arg1  ^self setProperty: #maximumExtent toValue: arg1computeColors  width = 0 ifTrue: [ ^colors := #() ].  style == #complexFramed ifTrue: [ ^self computeFramedColors ].  style == #complexAltFramed ifTrue: [ ^self computeAltFramedColors ].  style == #complexRaised ifTrue: [ ^self computeRaisedColors ].  style == #complexAltRaised ifTrue: [ ^self computeAltRaisedColors ].  style == #complexInset ifTrue: [ ^self computeInsetColors ].  style == #complexAltInset ifTrue: [ ^self computeAltInsetColors ].  self error: 'Unknown border style: ' , style printStringmouseMove: arg1  actWhen == #buttonDown ifTrue: [ ^self ].  self updateVisualState: arg1mouseOverButtonBorderStyle  ^self theme scrollbarMouseOverButtonBorderStyleFor: selfrefreshWorld  | tmp1 |  (tmp1 := self world) ifNotNil: [ tmp1 displayWorldSafely ]newHSVAColorSelectorMorph  ^HSVAColorSelectorMorph new     extent: 40 @ 28 + 152;     when: #selectedColor send: #colorSelected: to: selftakesKeyboardFocus  ^self enabledmorphsAt: arg1 unlocked: arg2 do: arg3  (self fullBounds containsPoint: arg1) ifFalse: [ ^self ].  (arg2 and: [ self isLocked or: [ self visible not ] ]) ifTrue: [ ^self ].  self submorphsDo: [:arg4 |  | tmp1 |        tmp1 := arg4 transformedFrom: self.        arg4 morphsAt: (tmp1 globalPointToLocal: arg1) unlocked: arg2 do: arg3 ].  (self containsPoint: arg1) ifTrue: [ arg3 value: self ]addHandlesTo: arg1 box: arg2  arg1 haloBox: arg2.  HaloMorph currentHaloSpecifications do: [:arg3 |  | tmp1 tmp2 |        tmp2 := arg3 addHandleSelector.        (tmp1 := self wantsHaloHandleWithSelector: tmp2 inHalo: arg1) ifTrue: [ (#(addDupHandle:) includes: tmp2) ifTrue: [ tmp1 := self preferredDuplicationHandleSelector = tmp2 ] ].        tmp1 ifTrue: [ arg1 perform: tmp2 with: arg3 ] ].  arg1 innerTarget addOptionalHandlesTo: arg1 box: arg2actualClass  ^FTAscendingSortingStatenewRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 label: arg4 help: arg5  ^self newRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: nil label: arg4 help: arg5canBeClosed  ^toolbar canBeClosedhSetScrollDelta  | tmp1 tmp2 |  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  tmp2 := self scrollDeltaWidth.  tmp1 := self hLeftoverScrollRange.  tmp1 = 0 ifTrue: [ hScrollBar           scrollDelta: 0.02 pageDelta: 0.2;           interval: 1.0;           setValue: 0.        ^self ].  hScrollBar scrollDelta: (tmp2 / tmp1) asFloat pageDelta: ((self innerBounds width - tmp2) / tmp1) asFloat.  hScrollBar interval: (self innerBounds width / self hTotalScrollRange) asFloat.  hScrollBar setValue: (scroller offset x / tmp1 min: 1.0) asFloatensureLayoutAndAddMorph: arg1  arg1 layoutFrame ifNil: [ arg1 layoutFrame: LayoutFrame identity ].  self addMorph: arg1hasYellowButtonMenu  ^self wantsYellowButtonMenulistDirectionString: arg1  ^self layoutMenuPropertyString: arg1 from: self listDirectionballoonText  ^balloonTextfractions: arg1 offsets: arg2  | tmp1 tmp2 |  self deprecated: 'Do not use this method. It forces to create spurious objects (rectangle or points) for nothing.'.  tmp1 := arg1 ifNil: [ 0 @ 0 extent: 0 @ 0 ].  tmp2 := arg2 ifNil: [ 0 @ 0 extent: 0 @ 0 ].  ^self     topFraction: tmp1 top offset: tmp2 top;     leftFraction: tmp1 left offset: tmp2 left;     bottomFraction: tmp1 bottom offset: tmp2 bottom;     rightFraction: tmp1 right offset: tmp2 rightbuttonExtent  | tmp1 |  tmp1 := self theme scrollbarThickness.  ^bounds isWide ifTrue: [ upButton ifNil: [ tmp1 @ tmp1 ] ifNotNil: [ upButton extent ] ] ifFalse: [ downButton ifNil: [ tmp1 @ tmp1 ] ifNotNil: [ downButton extent ] ]asMouseOver  ^MouseEvent basicNew     setType: #mouseOver position: position buttons: buttons hand: source;     setTimeStamp: self timeStampsentTo: arg1  ^arg1 handleUnknownEvent: selfaddWorldHandlesTo: arg1 box: arg2  arg1 haloBox: arg2.  HaloMorph haloSpecificationsForWorld do: [:arg3 |  arg1 perform: arg3 addHandleSelector with: arg3 ].  arg1 innerTarget addOptionalHandlesTo: arg1 box: arg2setUp  super setUp.  column := self actualClass newageMorph  ^(self theme newTextEntryIn: self currentWorld for: self get: #age set: #age: class: Integer getEnabled: nil help: nil) color: Color transparentresizeCursor  self subclassResponsibilityinitWithContents: arg1 font: arg2 emphasis: arg3  offset := 1.  alpha := 0.5.  super initWithContents: arg1 font: arg2 emphasis: arg3valueOfProperty: arg1 ifAbsentPut: arg2  ^self assureExtension valueOfProperty: arg1 ifAbsentPut: arg2resetListSelector: arg1  resetListSelector := arg1positionIn: arg1 horizontalPlacement: arg2 verticalPlacement: arg3  | tmp1 tmp2 |  arg2 == #left ifTrue: [ tmp1 := arg1 left ].  arg2 == #leftCenter ifTrue: [ tmp1 := arg1 left + (arg1 width // 4) ].  arg2 == #center ifTrue: [ tmp1 := (arg1 left + arg1 right) // 2 ].  arg2 == #rightCenter ifTrue: [ tmp1 := arg1 left + (3 * arg1 width // 4) ].  arg2 == #right ifTrue: [ tmp1 := arg1 right ].  arg3 == #top ifTrue: [ tmp2 := arg1 top ].  arg3 == #topCenter ifTrue: [ tmp2 := arg1 top + (arg1 height // 4) ].  arg3 == #center ifTrue: [ tmp2 := (arg1 top + arg1 bottom) // 2 ].  arg3 == #bottomCenter ifTrue: [ tmp2 := arg1 top + (3 * arg1 height // 4) ].  arg3 == #bottom ifTrue: [ tmp2 := arg1 bottom ].  ^tmp1 asInteger @ tmp2 asIntegernormalizedY: arg1  ^(arg1 max: self topBoundary) min: self bottomBoundarydrawSubmenuMarkerOn: arg1  | tmp1 tmp2 |  self hasSubMenu ifFalse: [ ^self ].  tmp1 := self subMenuMarker.  tmp2 := (self right - tmp1 width) @ ((self top + self bottom - tmp1 height) // 2).  arg1 paintImage: tmp1 at: tmp2doesBevels  ^falsedragTransferType  ^transferTypestyle  ^#dashedexternalName  ^'Selected {1} objects' translated format: {self selectedItems size}followHand: arg1 forEachPointDo: arg2 lastPointDo: arg3  hand := arg1.  pointBlock := arg2.  lastPointBlock := arg3.  self position: hand lastEvent cursorPoint - (self extent // 2)userString  ^(String new: indentLevel withAll: Character tab) , super userStringexpand: arg1 suchThat: arg2  (arg2 value: arg1 complexContents) ifTrue: [ arg1 isExpanded ifFalse: [ arg1 expand ].        arg1 childrenDo: [:arg3 |  self expandSilently: arg3 suchThat: arg2 ] ].  self innerWidgetChangediconFor: arg1  | tmp1 |  tmp1 := self elementAt: arg1.  ((tmp1 includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ tmp1 isAbstract not ]) ifTrue: [ tmp1 hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        tmp1 hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        tmp1 hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  tmp1 organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ((tmp1 includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ tmp1 isAbstract not ]) ifTrue: [ tmp1 hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        tmp1 hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        tmp1 hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  tmp1 organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ^tmp1 systemIconinitialize  super initialize.  self elements: Smalltalk allClassesAndTraits shuffledaddSimpleHandlesTo: arg1 box: arg2  | tmp1 |  target isWorldMorph ifTrue: [ ^self addSimpleHandlesForWorldHalos ].  self removeAllMorphs.  self bounds: (self worldBoundsForMorph: target renderedMorph).  self addHandleAt: (arg2 topLeft + arg2 leftCenter) // 2 + self simpleFudgeOffset color: Color paleBuff icon: #haloMoreHandlesIcon on: #mouseDown send: #addFullHandles to: self.  tmp1 := self addGraphicalHandle: #rotateIcon at: arg2 bottomLeft on: #mouseDown send: #startRot:with: to: self.  tmp1 on: #mouseMove send: #doRot:with: to: self.  target shouldFlex ifTrue: [ (self addGraphicalHandle: #scaleIcon at: arg2 bottomRight on: #mouseDown send: #startScale:with: to: self) on: #mouseMove send: #doScale:with: to: self ] ifFalse: [ (self addGraphicalHandle: #scaleIcon at: arg2 bottomRight on: #mouseDown send: #startGrow:with: to: self) on: #mouseMove send: #doGrow:with: to: self ].  growingOrRotating := false.  self layoutChanged.  self changedtabClicked: arg1 with: arg2  self selectedIndex: (self tabs indexOf: arg2)delete  window ifNotNil: [ window delete ]chooseFont  ^self chooseFont: nilhelpText: arg1  self setBalloonText: arg1step  owner ifNil: [ ^self stopStepping ].  self updateContents.  self changedupdateColor  self theme preferGradientFill ifFalse: [ ^self ].  self fillStyle: (self theme menuFillStyleFor: self).  titleMorph ifNotNil: [:arg1 |  arg1 fillStyle: (self theme menuTitleFillStyleFor: arg1) ]actualScreenSize  ^240 @ 120labelArea  ^labelAreamenubar  ^self submorphs detect: #isMenubardoubleClick: arg1 on: arg2  self doubleClickSelector ifNil: [ ^false ].  client model perform: self doubleClickSelector withEnoughArguments: {arg1 .         arg2}.  ^trueaddDebuggingItemsTo: arg1 hand: arg2  arg1 add: 'debug...' subMenu: (self buildDebugMenu: arg2).  arg1 lastItem icon: (self iconNamed: #smallDebugIcon)basicSelectIndexes: arg1  selectedIndexes := arg1 asArraynewSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8shortcutProvider  ^PharoShortcuts currentnewButtonFor: arg1 action: arg2 getEnabled: arg3 label: arg4 help: arg5  ^self newButtonFor: arg1 getState: nil action: arg2 arguments: nil getEnabled: arg3 label: arg4 help: arg5coefficients  curveState ifNotNil: [ ^curveState at: 1 ].  ^self vertices size < 1 ifTrue: [ self ] ifFalse: [ self coefficientsForMoreThanThreePoints ]worldMenu  ^self menuBuilder menuEntitled: self discoveredMenuTitleinitializeActionButtonNamed: arg1  actionButton := PluggableButtonMorph newButtonFor: self action: #execute label: arg1 help: nilpaddingWidth  ^paddingWidthresult: arg1  lock critical: [ hasResult := true.        result := arg1 ]updatePageIndex: arg1  self pageMorph ifNotNil: [:arg2 |  self contentMorph removeMorph: arg2 ].  arg1 > 0 ifTrue: [ self contentMorph addMorph: (self pages at: arg1) ].  self pageMorph ifNotNil: [:arg3 |  arg3 layoutChanged ].  self adoptPaneColor: self paneColorfullscreenMargin  ^self class fullscreenMarginisCollapsed  ^falsevSetScrollDelta  | tmp1 |  tmp1 := self vPageDelta.  self vScrollbar     scrollDelta: tmp1 / 10 pageDelta: tmp1;     interval: self vScrollbarInterval;     setValue: self vScrollbarValuerootClass: arg1  rootClass := arg1handleMonthNameTouched  | tmp1 tmp2 |  tmp1 := UIManager default chooseDropList: 'Choose a month:' list: #('January' 'February' 'March' 'April' 'May' 'June' 'July' 'August' 'September' 'October' 'November' 'December').  tmp1 ifNil: [ ^self ].  tmp2 := (Month year: date year month: tmp1) daysInMonth.  self date: (Date year: date year month: tmp1 day: (date dayOfMonth min: tmp2)).  self changedallowsCellSelection  ^falseshouldFlex  ^self isFlexMorphpositionDirectionShaft: arg1  | tmp1 tmp2 |  tmp1 := target heading degreesToRadians.  tmp2 := tmp1 sin @ tmp1 cos negated.  arg1 setVertices: {(tmp2 * 6 + directionArrowAnchor) .         (tmp2 * self directionArrowLength + directionArrowAnchor)}promptForCancel  ^self confirm: 'Changes have not been saved.Is it OK to cancel changes?' translatedenabled: arg1  arg1 ~= enabled ifTrue: [ enabled := arg1.        self requestView: MorphTreeChangeRequest enabled ]testIndexFromPosition  self subclassResponsibilityhandler  ^handlerlockedString  ^self isLocked -> 'be locked' translatedselectedIndex: arg1  selectedIndex := arg1initialize  super initialize.  self     isRadioButton: false;     enabled: true;     onImage: self theme checkboxMarkerForm;     fillStyle: self fillStyleToUse;     borderStyle: self borderStyleToUsesliderColor  sliderColor ifNil: [ ^(color alphaMixed: 0.7 with: Color white) slightlyLighter ].  ^sliderColorprocessEvents  ^self processEventsFromQueue: self eventQueuegetMenuSelector: arg1  getMenuSelector := arg1deselectTimeOut: arg1  owner selectedItem == self ifTrue: [ arg1 hand releaseMouseFocus: owner.        owner selectItem: nil event: arg1 ]arguments  ^arguments ifNil: [ Array new ]showShortcut  ShortcutReminder showShortcut: selfbeSplitsTopAndBottom  splitsTopAndBottom := truetreeItemFor: arg1  ^FTBasicTreeListItem new     datasource: dataSource;     depth: depth + 1;     item: arg1enable  self enabled: truerelativeTextAnchorPosition: arg1  ^self setProperty: #relativeTextAnchorPosition toValue: arg1add: arg1 font: arg2 icon: arg3 help: arg4 subMenu: arg5  | tmp1 |  tmp1 := DockingBarToggleMenuItemMorph new.  tmp1     font: arg2;     contents: arg1;     subMenu: arg5;     icon: arg3.  arg4 ifNotNil: [ tmp1 setBalloonText: arg4 ].  self addMorphBack: tmp1rejectsEvent: arg1  (arg1 isMouse and: [ arg1 isMouseDown ]) ifTrue: [ ^(self submorphs anySatisfy: [:arg2 |  arg2 containsPoint: arg1 cursorPoint ]) not ].  ^super rejectsEvent: arg1hScrollbarShowing  ^self hScrollbar owner notNilinitialize  super initialize.  self     changeTableLayout;     color: Color transparent;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     cellInset: 16;     imageMorph: self newImageMorph;     textMorph: self newTextMorph;     addMorphBack: self imageMorph;     addMorphBack: self textMorphhIsScrollable  ^self hLeftoverScrollRange > 0newFuzzyLabelFor: arg1 label: arg2 offset: arg3 alpha: arg4 getEnabled: arg5  ^self theme newFuzzyLabelIn: self for: arg1 label: arg2 offset: arg3 alpha: arg4 getEnabled: arg5borderStyle: arg1  arg1 = self borderStyle ifTrue: [ ^self ].  (self canDrawBorder: arg1) ifFalse: [ ^self borderStyle: (BorderStyle width: arg1 width color: (arg1 trackColorFrom: self) color) ].  self assureExtension.  self extension borderStyle: arg1.  self changedneedsToBeDrawn  | tmp1 |  (savedPatch notNil or: [ (submorphs anySatisfy: [:arg1 |  arg1 visible ]) or: [ temporaryCursor notNil and: [ hardwareCursor isNil ] ] ]) ifTrue: [ Cursor blank isCurrent ifFalse: [ Cursor blank show ].        ^true ].  tmp1 := hardwareCursor ifNil: [ Cursor normal ].  tmp1 isCurrent ifFalse: [ tmp1 show ].  ^falsegetListRow: arg1  getListElementSelector ifNotNil: [ ^model perform: getListElementSelector with: arg1 ].  ^self getList at: arg1openModal: arg1  arg1 setWindowColor: self theme windowColor.  ^super openModal: arg1checkTimeoutFrom: arg1  localStamp ifNil: [ localStamp := Time millisecondClockValue.        ^self ].  Time millisecondClockValue - localStamp > dblClickTime ifFalse: [ ^self ].  clickState == #firstClickDown ifTrue: [ clickState := #firstClickTimedOut.        dragSelector ifNotNil: [ ^self ] ].  arg1 resetClickState.  self doubleClickTimeout.  clickState == #firstClickTimedOut ifTrue: [ self click ]isOn  ^color = onColorstrikethroughColor  ^self stringColorunhighlightSelection  self searchedElement: nilnewMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil useIndex: true help: arg5startBlinking  self canChangeText ifTrue: [ super startBlinking ] ifFalse: [ self paragraph showCaret: true ]mouseDown: arg1  oldColor := self fillStylegtInspectorMorphExtensionIn: arg1  < gtInspectorPresentationOrder: 15>  ^arg1 table     title: 'Extension';     showOnly: 50;     display: [ self extension gtInspectorVariableValuePairs asSortedCollection ];     when: [ extension notNil ];     column: 'Variable' evaluated: [:arg2 |  GTObjectPrinter asNonTruncatedTextFrom: arg2 key ];     column: 'Value' evaluated: [:arg2 |  GTObjectPrinter asTruncatedTextFrom: arg2 value ];     send: #value;     morphicSelectionAct: [:arg3 |  arg3 selection value browse ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse';     morphicSelectionAct: [:arg3 |  arg3 selection value inspect ] icon: GLMUIThemeExtraIcons glamorousInspect on: $i entitled: 'Inspect';     selectionAct: [:arg3 |  ((arg3 selection pointersToExcept: {arg3 selection}) reject: [:arg4 |  arg4 pointsOnlyWeaklyTo: arg3 selection ]) inspect ] on: $t entitled: 'Open pointers to'selectedMouseOverBorderStyle  ^self theme buttonSelectedMouseOverBorderStyleFor: selfdrawBoundsForRow: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := [ self getListItem: arg1 ] on: SubscriptOutOfBounds do: [:arg2 |  self getListItem: (arg1 min: self getListSize) ].  tmp4 := tmp3 heightToDisplayInList: self.  tmp1 := self topLeft x @ (self topLeft y + ((arg1 - 1) * tmp4)).  tmp2 := tmp1 extent: self width @ tmp4.  ^tmp2bottom  ^bounds bottomdrawSubmorphsOn: arg1  super drawSubmorphsOn: arg1.  self drawLinesOn: arg1hash  ^position hash + buttons hashnewYesButtonFor: arg1  ^self theme newYesButtonIn: self for: arg1isDefault  ^self extension isDefaultdeleteIfPopUp: arg1  owner ifNotNil: [ owner deleteIfPopUp: arg1 ]paneColor: arg1  self setProperty: #paneColor toValue: arg1.  self adoptPaneColorchangeTableLayout  | tmp1 |  ((tmp1 := self layoutPolicy) notNil and: [ tmp1 isTableLayout ]) ifTrue: [ ^self ].  self layoutPolicy: TableLayout new.  self layoutChangednewColorComponentFieldMorph: arg1  ^(self newTextEntryFor: self get: arg1 set: (arg1 , ':') asSymbol class: Integer getEnabled: nil help: nil) minWidth: 40verticalScrollBar  ^verticalScrollBarkeyStroke: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := self theme builder newBalloonHelp: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.  tmp5 popUpForHand: self activeHand.  (self rootMenu hasProperty: #hasUsedKeyboard) ifFalse: [ self rootMenu setProperty: #hasUsedKeyboard toValue: true.        self changed ].  (arg1 commandKeyPressed and: [ self commandKeyHandler notNil ]) ifTrue: [ self commandKeyHandler commandKeyTypedIntoMenu: arg1.        ^self deleteIfPopUp: arg1 ].  tmp2 := arg1 keyCharacter.  tmp3 := tmp2 asciiValue.  tmp2 = Character cr ifTrue: [ selectedItem ifNotNil: [ selectedItem hasSubMenu ifTrue: [ arg1 hand newMouseFocus: selectedItem subMenu.                    ^arg1 hand newKeyboardFocus: selectedItem subMenu ] ifFalse: [ ^selectedItem invokeWithEvent: arg1 ] ].        (tmp4 := self items) size = 1 ifTrue: [ ^tmp4 first invokeWithEvent: arg1 ].        ^self ].  tmp3 = 27 ifTrue: [ self valueOfProperty: #matchString ifPresentDo: [:arg2 |  arg2 isEmpty ifFalse: [ self setProperty: #matchString toValue: String new.                    self selectItem: nil event: arg1.                    ^self displayFiltered: arg1 ] ].        popUpOwner ifNil: [ ^self delete ].        ^self deselectAndFocusOutermenuOn: arg1 ].  tmp3 = 28 ifTrue: [ ^self leftArrowStroked: arg1 ].  tmp3 = 29 ifTrue: [ (self rightArrowStroked: arg1) ifTrue: [ ^self ] ].  tmp3 = 30 ifTrue: [ ^self moveSelectionDown: -1 event: arg1 ].  tmp3 = 31 ifTrue: [ ^self moveSelectionDown: 1 event: arg1 ].  tmp3 = 11 ifTrue: [ ^self moveSelectionDown: -5 event: arg1 ].  tmp3 = 12 ifTrue: [ ^self moveSelectionDown: 5 event: arg1 ].  tmp1 := self valueOfProperty: #matchString ifAbsentPut: [ String new ].  (tmp2 = Character backspace and: [ tmp1 notEmpty ]) ifTrue: [ tmp1 := tmp1 allButLast.        self recordFiltering: tmp1.        self displayFiltered: arg1 ].  tmp2 isAlphaNumeric ifFalse: [ ^self ].  tmp1 := tmp1 , tmp2 asString.  self recordFiltering: tmp1.  self displayFiltered: arg1table: arg1  table := arg1changed  hasChanged := truehandlesMouseDown: arg1  ^(self isEditable: arg1) ifTrue: [ true ] ifFalse: [ super handlesMouseDown: arg1 ]hasEquivalentIn: arg1  ^arg1 anySatisfy: [:arg2 |  arg2 withoutListWrapper = item withoutListWrapper ]hasDropShadow: arg1  arg1 ifTrue: [ self setProperty: #hasDropShadow toValue: true ] ifFalse: [ self removeProperty: #hasDropShadow ]doAnnounce: arg1  (self valueOfProperty: #announcer ifAbsent: [ ^self ]) announce: arg1defaultColor  ^self theme selectionColorownerChanged  super ownerChanged.  self updateLayoutInDockingBarheaderLabel: arg1  headerLabel := arg1drawOnAthensCanvas: arg1  | tmp1 |  tmp1 := self boundsForKeyText: self keyText font: self owner fontToUse.  self owner drawText: keyText onAthensCanvas: arg1 in: tmp1 color: self owner theme disabledTextColorallItems  ^(submorphs detect: [:arg1 |  arg1 class = TransformMorph ]) submorphsaddPage: arg1 label: arg2 selected: arg3  arg1     hResizing: #spaceFill;     vResizing: #spaceFill.  self pages add: arg1.  self tabSelectorMorph addTab: arg2 selected: arg3shadowForm  shadowForm ifNil: [ self computeShadow ].  ^shadowFormdoScrollDown  (self waitForDelay1: 200 delay2: 40) ifFalse: [ ^self ].  self setValue: (value + scrollDelta + 0.000001 min: 1.0)addGripsIfWanted  self wantsGrips ifTrue: [ self addGrips ]lineColor  | tmp1 |  lineColor ifNotNil: [ ^lineColor ].  tmp1 := self color isTransparent ifTrue: [ self firstOwnerSuchThat: [:arg1 |  arg1 isWorldOrHandMorph not and: [ arg1 color isTransparent not ] ] ] ifFalse: [ self ].  tmp1 ifNil: [ ^Color black ].  ^tmp1 color luminance > 0.5 ifTrue: [ Color black ] ifFalse: [ Color white ]autoDeselect  ^self resetListSelector ifNotNil: [ true ] ifNil: [ self allowsDeselection ]chooseForSaveFileReference: arg1 extensions: arg2 path: arg3  ^self chooseForSaveFileReference: arg1 extensions: arg2 path: arg3 preview: nilnewBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newBracketSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8arguments  ^argumentsadjustBottomY  | tmp1 tmp2 tmp3 |  tmp1 := lines collect: [:arg1 |  arg1 lineHeight ].  tmp3 := tmp1 sum.  tmp2 := container top + tmp3.  container := container withBottom: tmp2wantsDroppedMorph: arg1 event: arg2  ^trueheaderBounds  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := OrderedCollection new.  tmp3 := scroller left.  (tmp1 := self columnResizers asOrderedCollection collect: [:arg1 |  arg1 position ]) ifNotEmpty: [ | tmp5 |        tmp3 := tmp1 removeFirst x.        tmp4 := scroller left - scroller offset x.        tmp5 := tmp3.        tmp2 add: (tmp4 @ topHeader top corner: tmp5 @ topHeader bottom).        [ tmp1 notEmpty ] whileTrue: [ tmp4 := tmp3 + self resizerWidth.              tmp3 := tmp1 removeFirst x.              tmp5 := tmp3.              tmp2 add: (tmp4 @ topHeader top corner: tmp5 @ topHeader bottom) ] ].  self columnResizers size < self columns size ifTrue: [ tmp4 := tmp3 + self resizerWidth.        tmp2 add: ((tmp4 min: scroller right) @ topHeader top corner: scroller right @ topHeader bottom) ].  ^tmp2topLeftCorner  ^self intersectionWithLineSegmentFromCenterTo: bounds topLeftdragTarget: arg1  | tmp1 |  tmp1 := target point: arg1 position - positionOffset from: owner.  target setConstrainedPosition: tmp1 hangOut: true.  arg1 hand newMouseFocus: selftrackColorFrom: arg1  baseColor ifNil: [ self color: arg1 raisedColor ]listChanged  listItems := Array new: self getListSize withAll: nil.  self removeAllMorphs.  selectedRow := nil.  selectedRows := PluggableSet integerSet.  maxWidth := nil.  self adjustHeight.  self adjustWidth.  self changedkeystrokeSelector: arg1  keystrokeSelector := arg1alpha  ^alphaupdateContentsWithPreviouslyExpanded: arg1  super updateContentsWithPreviouslyExpanded: arg1.  self updatePagerdropItemSelector  ^dropItemSelectorsearchText: arg1  | tmp1 |  arg1 isEmptyOrNil ifTrue: [ ^#() ].  tmp1 := OrderedCollection new.  self elements withIndexDo: [:arg2 :arg3 |  ((self toString: arg2) beginsWith: arg1) ifTrue: [ tmp1 add: arg3 ] ].  ^tmp1 asArrayprintOn: arg1  | tmp1 |  arg1 nextPutAll: '3PButton'.  arguments notEmpty ifTrue: [ tmp1 := arguments at: (2 min: arguments size) ].  arg1 nextPutAll: '('.  (tmp1 notNil and: [ tmp1 ~~ self ]) ifTrue: [ arg1           print: tmp1;           space ] ifFalse: [ arg1           print: actionSelector;           space ].  arg1     print: self identityHash;     nextPutAll: ')'shadowOffset: arg1  (arg1 isNil or: [ arg1 isZero ]) ifTrue: [ self removeProperty: #shadowOffset ] ifFalse: [ self setProperty: #shadowOffset toValue: arg1 ]icon  ^self iconNamed: #smallExpertIconballoonTextForNode: arg1  getHelpSelector ifNil: [ ^nil ].  ^model perform: getHelpSelector with: arg1 itemprintOn: arg1  arg1 nextPut: $[.  arg1     nextPutAll: self cursorPoint printString;     space.  arg1     nextPutAll: type;     space.  arg1     print: self direction;     space.  arg1 nextPutAll: self modifierString.  arg1 nextPutAll: self buttonString.  arg1     nextPutAll: timeStamp printString;     space.  arg1 nextPutAll: self windowIndex printString.  arg1 nextPut: $]activeFillStyle  ^self theme windowActiveFillStyleFor: selfchildren: arg1  children := arg1splitsTopAndBottom  ^falsechooseExistingFileReference: arg1 extensions: arg2 path: arg3 preview: arg4  ^self theme chooseExistingFileReferenceIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4menuIcon  ^self class menuIconclipSubmorphs  ^trueminExtent  | tmp1 |  self page ifNil: [ ^super minExtent max: self tabSelectorMorph minExtent ].  tmp1 := 0 @ self tabSelectorMorph minExtent y + (self contentMorph borderWidth * 2).  tmp1 := tmp1 + (self contentMorph layoutInset * 2).  ^super minExtent max: ((self pages inject: 0 @ 0 into: [:arg1 :arg2 |  arg1 max: arg2 minExtent ]) + tmp1 max: self tabSelectorMorph minExtent)getIconSelector  ^getIconSelectorrowInset  ^rowInset ifNil: [ rowInset := 0 ]rowIndexContainingPoint: arg1  self exposedRows keysAndValuesDo: [:arg2 :arg3 |  (arg3 bounds containsPoint: arg1) ifTrue: [ ^arg2 ] ].  ^nilbasicSelectRowIndexes: arg1  self deprecated: 'Use #basicSelectIndexes: instead' transformWith: '`@receiver basicSelectRowIndexes: `@statements' -> '`@receiver basicSelectIndexes: `@statements'.  self basicSelectIndexes: arg1newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: arg6 help: arg7minCellSize  ^minCellSizeacceptDroppingMorph: arg1 event: arg2  self addWindow: arg1isClosed  ^false= arg1  ^self species = arg1 species and: [ self leftFraction == arg1 leftFraction and: [ self leftOffset == arg1 leftOffset and: [ self topFraction == arg1 topFraction and: [ self topOffset == arg1 topOffset and: [ self rightFraction == arg1 rightFraction and: [ self rightOffset == arg1 rightOffset and: [ self bottomFraction == arg1 bottomFraction and: [ self bottomOffset == arg1 bottomOffset ] ] ] ] ] ] ] ]wantsHalo  ^falsenewColorPresenterFor: arg1 getColor: arg2 help: arg3  ^self theme newColorPresenterIn: self for: arg1 getColor: arg2 help: arg3closestPointTo: arg1  | tmp1 |  tmp1 := self bounds pointNearestTo: arg1.  self wantsRoundedCorners ifFalse: [ ^tmp1 ].  self bounds corners with: (self bounds insetBy: 6) corners do: [:arg2 :arg3 |  (tmp1 - arg2) abs < (6 @ 6) ifTrue: [ ^(arg3 + (Point r: 5.0 degrees: (tmp1 - arg3) degrees)) asIntegerPoint ] ].  ^tmp1inToggleArea: arg1  ^self toggleRectangle containsPoint: arg1activateFilterWith: arg1  (function isKindOf: FTFilterFunction) ifFalse: [ ^self ].  function filterNowWith: arg1raisedColor  (color isColor and: [ color isTransparent and: [ owner notNil ] ]) ifTrue: [ ^owner raisedColor ].  ^color asColor raisedColordraggedTo: arg1  self position: arg1 + startGapbold  self changeEmphasis: #boldautoDeselection: arg1  autoDeselection := arg1font: arg1  self normalLabel allMorphsDo: [:arg2 |  (arg2 respondsTo: #font:) ifTrue: [ arg2 font: arg1 ] ].  self selectedLabel allMorphsDo: [:arg2 |  (arg2 respondsTo: #font:) ifTrue: [ arg2 font: arg1 ] ]isResizeableMorph: arg1 forSplitter: arg2  | tmp1 |  tmp1 := arg2 splitsTopAndBottom ifTrue: [ arg1 layoutFrame isVerticallyResizeable ] ifFalse: [ arg1 layoutFrame isHorizontallyResizeable ].  ^tmp1newMenuFor: arg1  ^self theme newMenuIn: self for: arg1selectItemsRequest: arg1  self selectedItems: arg1 itemsToSelectmouseUpOnSingle: arg1  | tmp1 tmp2 |  tmp1 := self rowAtLocation: arg1 position.  arg1 hand hasSubmorphs ifFalse: [ tmp2 := self mouseDownRow.        self mouseDownRow: nil.        tmp2 ifNil: [ ^self ] ].  (self enabled and: [ model okToChange ]) ifFalse: [ ^self ].  tmp1 == self selectionIndex ifTrue: [ self autoDeselect ifTrue: [ tmp1 = 0 ifFalse: [ self changeModelSelection: 0 ] ] ifFalse: [ self changeModelSelection: tmp1 ] ] ifFalse: [ self changeModelSelection: tmp1 ].  Cursor normal showsearchedElement  ^searchedElementpageSize: arg1  pageSize := arg1doFastFrameDrag: arg1  (FastDraggingFrameMorph forDragging: self clickedAt: arg1) openInWorldhandlesMouseDown: arg1  ^truecalculateArcLengths  | tmp1 tmp2 |  tmp2 := self cornerRadius.  tmp1 := Array new: tmp2.  1 to: tmp2 do: [:arg1 |  | tmp3 |        tmp3 := arg1 - 0.5.        tmp1 at: arg1 put: (tmp2 - (2 * tmp3 * tmp2 - (tmp3 * tmp3)) sqrt) asInteger ].  self arcLengths: tmp1initialize  super initialize.  self highlighted: falseinstallEditorToReplace: arg1  | tmp1 |  arg1 ifNotNil: [ tmp1 := arg1 stateArray ].  editor := self editorClass forMorph: self.  arg1 ifNotNil: [ editor stateArrayPut: tmp1 ].  self selectionChanged.  ^editorchangeMargins: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := arg1 ifNil: [ self primaryHand ] ifNotNil: [ arg1 hand ].  tmp2 := tmp3 position.  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  tmp1 removeAllMorphs.        tmp1 addMorph: (LineMorph from: tmp2 to: arg2 color: Color black width: 1).        tmp4 := (arg2 - tmp2 max: 0 @ 0) // 5.        self margins: tmp4 asMargin ] lastPointDo: [:arg2 |  tmp1 deleteBalloon.        self halo ifNotNil: [:arg3 |  arg3 addHandles ] ].  tmp3 attachMorph: tmp1.  tmp1 showBalloon: 'Move cursor down and to the rightto increase margin inset.Click when done.' hand: arg1 hand.  tmp1 startSteppingcleanStepList  ^stepList sortBlock: self stepListSortBlockdefaultColor  ^defaultColor ifNil: [ self theme textColor ]owner  ^ownerinitialize  pressed := false.  super initializenewMouseFocus: arg1  self mouseFocus: arg1contentString  ^self valueOfProperty: #contentStringinitializeScrollBars  (scrollBar := ScrollBar new     model: self;     setValueSelector: #vScrollBarValue:)     borderWidth: 1;     borderColor: Color black.  (hScrollBar := ScrollBar new     model: self;     setValueSelector: #hScrollBarValue:)     borderWidth: 1;     borderColor: Color black.  self initializeScroller.  self addMorph: scrollBar.  self addMorph: hScrollBar.  self alwaysShowVScrollbar ifTrue: [ self alwaysShowVScrollBar: true ].  self alwaysHideHScrollbar ifTrue: [ self hideHScrollBarIndefinitely: true ] ifFalse: [ self alwaysShowHScrollbar ifTrue: [ self alwaysShowHScrollBar: true ] ]adoptPaneColor: arg1  super adoptPaneColor: arg1.  self hasSubMenu ifTrue: [ self subMenu adoptPaneColor: arg1 ]borderColorForItems: arg1  (selectedItems select: [:arg2 |  arg2 isKindOf: BorderedMorph ]) with: arg1 do: [:arg2 :arg3 |  arg2 borderColor: arg3 ]buildToggleButtonNoLabel  ^PluggableToggleButtonMorph on: self getState: nil action: #toggleAction: label: nil icon: #icon menu: nildefaultColor  ^Color r: 0.8 g: 1.0 b: 0.8wrapScrolling  ^wrapScrollingiconRightOffset  ^10 * self displayScaleFactordefaultColor  ^Color transparentaddIfNeededTitle: arg1 andIcon: arg2  (arg1 notNil or: [ arg2 notNil ]) ifTrue: [ self addTitle: arg1 icon: arg2 ]toggleExpandedState  isExpanded := isExpanded not.  self refreshExpandedStatefullBounds  fullBounds ifNotNil: [ ^fullBounds ].  ^submorphs ifEmpty: [ bounds ] ifNotEmpty: [ self doLayoutIn: self layoutBounds.        fullBounds ]nextWindow  | tmp1 |  tmp1 := self systemWindows.  tmp1 ifEmpty: [ ^nil ].  ^tmp1 after: self currentWindow ifAbsent: [ tmp1 first ]scrollSelectionIntoView  self listManager selectedMorph ifNotNil: [:arg1 |  self scrollToShow: arg1 contentBounds ]reduceVertices  | tmp1 |  [ (tmp1 := self nextDuplicateVertexIndex) > 0 ] whileTrue: [ self setVertices: (vertices copyWithoutIndex: tmp1) ].  ^vertices sizeaddNestedYellowButtonItemsTo: arg1 event: arg2  | tmp1 tmp2 |  self addYellowButtonMenuItemsTo: arg1 event: arg2.  tmp1 := self submorphThat: [:arg3 |  arg3 containsPoint: arg2 position ] ifNone: [ ^self ].  (tmp1 addMyYellowButtonMenuItemsToSubmorphMenus and: [ tmp1 hasYellowButtonMenu ]) ifFalse: [ ^self ].  arg1 addLine.  tmp2 := UIManager default newMenuIn: tmp1 for: tmp1.  tmp1 addNestedYellowButtonItemsTo: tmp2 event: arg2.  arg1 add: tmp1 externalName icon: (tmp1 iconOrThumbnailOfSize: 16) subMenu: tmp2color: arg1  selectAll  self isMultipleSelection ifFalse: [ ^self ].  self selectionModeStrategy selectAllwrapDirection: arg1  wrapDirection := arg1label  ^labeldrawSubmorphsOn: arg1  super drawSubmorphsOn: arg1.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: arg1 ]balloonHelpDelayTime  ^self theme settings balloonHelpDelayTimetopHeaderBackground: arg1  topHeaderBackground := arg1items  ^itemsroundedCorners  ^#(1 4)selectionStart: arg1 selectionStop: arg2  selectionStart := arg1.  selectionStop := arg2getRootsSelector  ^getRootsSelectortestSortFunction  | tmp1 |  tmp1 := self dataSourceForTesting.  strategy sortFunction: #yourself ascending.  self assert: tmp1 elements equals: self elementsForTestDataSource.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy reset.  strategy sortFunction: #asString ascending.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 10 2 3 4 5 6 7 8 9)on: arg1 getState: arg2 action: arg3 label: arg4 icon: arg5 menu: arg6  self model: arg1.  getStateSelector := arg2.  actionSelector := arg3.  getLabelSelector := arg4.  getIconSelector := arg5.  getMenuSelector := arg6.  self     update: (arg4 ifNil: [ arg5 ]);     update: arg2minWidth  ^self perform: #minWidth withArguments: #() inSuperclass: MorphselectedItems  ^self selectedNodes collect: [:arg1 |  arg1 item ]initialize  super initialize.  self orientation: #horizontalsetContentMorph: arg1  self removeAllMorphs.  self addMorph: arg1 fullFrame: LayoutFrame identitystraightLineSegmentsDo: arg1  | tmp1 |  tmp1 := nil.  vertices do: [:arg2 |  tmp1 ifNotNil: [ arg1 value: tmp1 value: arg2 ].        tmp1 := arg2 ].  (closed or: [ vertices size = 1 ]) ifTrue: [ arg1 value: tmp1 value: vertices first ]icon: arg1  composeAllStartingAt: arg1  firstCharacterIndex := arg1.  offsetToEnd := text size - firstCharacterIndex.  self composeAlltab: arg1  tab := arg1selectItems: arg1  self selectedItems: arg1model: arg1  model ifNotNil: [ model removeDependent: self ].  arg1 ifNotNil: [ arg1 addDependent: self ].  model := arg1drawable: arg1  drawable := arg1defaultBounds  ^0 @ 0 extent: 10 @ 10browseAction  | tmp1 |  tmp1 := self model class whichClassIncludesSelector: self actionSelector.  Smalltalk tools browser openOnClass: tmp1 selector: self actionSelectordrawOnAthensCanvas: arg1  super drawOnAthensCanvas: arg1.  self drawKeyTextOnAthenCanvas: arg1sortingIcon  ^self subclassResponsibilityborderWidth  ^self borderStyle widthexpandItemPath: arg1  (self allNodeMorphs at: 1 ifAbsent: [ ^self ]) openItemPath: arg1handleMouseWheel: arg1  ^self dispatchDefault: arg1 with: morphsearchingString  ^self contents asStringfilterListWith: arg1  | tmp1 |  tmp1 := self valueOfProperty: #matchString ifAbsentPut: [ String new ].  tmp1 := arg1 = Character backspace ifTrue: [ tmp1 isEmpty ifTrue: [ tmp1 ] ifFalse: [ tmp1 allButLast ] ] ifFalse: [ tmp1 copyWith: arg1 ].  self setProperty: #matchString toValue: tmp1addMorphs  self addMorph: toolbar fullFrame: (LayoutFrame identity           bottomFraction: 0;           bottomOffset: TabMorph defaultHeight + (2 * self displayScaleFactor);           yourself).  self addMorph: container fullFrame: (LayoutFrame identity           topOffset: TabMorph defaultHeight + 2;           yourself).  container addMorph: contentsWrapper fullFrame: (LayoutFrame identity           topOffset: 2;           rightOffset: -1;           bottomOffset: -1;           leftOffset: 2;           yourself)invalidRect: arg1 from: arg2  | tmp1 |  arg1 hasPositiveExtent ifFalse: [ ^self ].  tmp1 := arg1.  arg2 == self ifFalse: [ self clipSubmorphs ifTrue: [ tmp1 := arg1 intersect: self clippingBounds ifNone: [ ^self ] ] ].  owner ifNotNil: [ owner invalidRect: tmp1 from: self ]heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]step  collapseItem  dataSource updateAvailableRows: 1 - self availableRows.  children := #().  expanded := falsenewTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5 entryCompletion: arg6  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5 entryCompletion: arg6sliderExtent  ^bounds isWide ifTrue: [ self sliderThickness @ self innerBounds height ] ifFalse: [ self innerBounds width @ self sliderThickness ]step  target ifNotNil: [ self position: target position + offsetFromTarget ]extent: arg1  self extent = arg1 ifTrue: [ ^self ].  super extent: arg1.  self     updateTabs;     ensureSelectedTabIsVisibleexploreItem  self inspecttestIsBeforeColumn  self deny: (strategy is: 3 beforeColumn: 9).  self deny: (strategy is: 3 beforeColumn: 4).  self deny: (strategy is: 3 beforeColumn: 7)handleNextMonthTouched  self date: date onNextMonth.  self changedremoveHaloFromClick: arg1 on: arg2  | tmp1 |  tmp1 := self halo ifNil: [ ^self ].  (tmp1 target hasOwner: self) ifTrue: [ ^self ].  (tmp1 staysUpWhenMouseIsDownIn: arg2) ifFalse: [ self removeHalo ]addFontSizeHandle: arg1  innerTarget isTextMorph ifTrue: [ self addHandle: arg1 on: #mouseDown send: #chooseFont to: innerTarget ]addMorphInFrontOfLayer: arg1  | tmp1 |  tmp1 := arg1 morphicLayerNumber.  submorphs do: [:arg2 |  | tmp2 |        arg2 == arg1 ifTrue: [ ^self ].        tmp2 := arg2 morphicLayerNumber.        tmp1 <= tmp2 ifTrue: [ ^self addMorph: arg1 inFrontOf: arg2 ] ].  self addMorphBack: arg1setActualFont: arg1  actualFont := arg1.  arg1 textStyle ifNotNil: [:arg2 |  fontNumber := arg2 fontIndexOf: arg1 ]notExpandedForm  ^self theme treeUnexpandedFormcellPositioning: arg1  self assureTableProperties cellPositioning: arg1.  self layoutChangeduseDefaultFill  self fillStyle: self defaultColorchangeBorderWidth: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 ifNil: [ self primaryHand ] ifNotNil: [ arg1 hand ].  tmp2 := tmp1 position.  tmp3 := HandleMorph new forEachPointDo: [:arg2 |  tmp3 removeAllMorphs.        tmp3 addMorph: (LineMorph from: tmp2 to: arg2 color: Color black width: 1).        tmp4 := (arg2 - tmp2) r asInteger // 5.        self borderWidth: tmp4 ] lastPointDo: [:arg2 |  tmp3 deleteBalloon.        self halo ifNotNil: [:arg3 |  arg3 addHandles ] ].  tmp1 attachMorph: tmp3.  tmp3 showBalloon: 'Move cursor farther fromthis point to increase border width.Click when done.' translated hand: arg1 hand.  tmp3 startSteppingisMultiple  ^falseisRoot  ^trueuncollapseToHand  | tmp1 |  tmp1 := uncollapsedMorph.  uncollapsedMorph := nil.  tmp1 setProperty: #collapsedPosition toValue: self position.  mustNotClose := false.  self delete.  ActiveHand attachMorph: tmp1mouseUp: arg1  | tmp1 |  tmp1 := super mouseUp: arg1.  self pressed: index.  ^tmp1lastSelectedNodePath  ^self subclassResponsibilityupdate: arg1  self textSelector ifNotNil: [ arg1 = self textSelector ifTrue: [ | tmp1 |              tmp1 := (arg1 isSymbol and: [ model notNil ]) ifTrue: [ (self model perform: arg1) asMorph ] ifFalse: [ arg1 value asMorph ].              self subMorph: tmp1 ] ].  self changedselectLastVisibleRow  ^self selectRowIndex: (container exposedRows ifNotEmpty: [:arg1 |  arg1 keys last ] ifEmpty: [ 0 ])initRow  self buildRowMorph.  self layoutChangedupdateSelectionWithCollectBlock: arg1  | tmp1 |  self table selectedIndexes ifEmpty: [ ^self ].  tmp1 := self indexOfChangedItem.  self table selectIndexes: (self table selectedIndexes collect: [:arg2 |  arg1 value: arg2 value: tmp1 ]) asSet asArray andMakeVisibleIf: falseisVerticallyResizeable  ^self bottomFraction ~= self topFractionsvMorph  ^svMorphdecrement  self value: self value - self quantumextent: arg1  super extent: arg1.  self adoptPaneColorflushLayoutCache  cachedMinExtent := niladoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self selectionColor: self selectionColor.  self borderStyle baseColor: arg1 twiceDarkerelementAt: arg1  ^self elements at: arg1getModelState  model ifNil: [ ^false ].  ^getStateSelector ifNil: [ false ] ifNotNil: [ getStateSelector numArgs = 0 ifTrue: [ model perform: getStateSelector ] ifFalse: [ argumentsProvider ifNotNil: [ arguments := argumentsProvider perform: argumentsSelector ].              model perform: getStateSelector withEnoughArguments: arguments ] ]currentlyExpanded  ^self expandedNodesFrom: self allNodeMorphsindexForInserting: arg1 inList: arg2 horizontal: arg3 target: arg4  | tmp1 tmp2 tmp3 tmp4 |  properties := arg4 layoutProperties.  tmp4 := properties wrapDirection == #none.  arg3 ifTrue: [ properties listDirection == #rightToLeft ifTrue: [ tmp1 := [:arg5 |  arg1 x > arg5 left ] ] ifFalse: [ tmp1 := [:arg5 |  arg1 x < arg5 right ] ].        properties wrapDirection == #bottomToTop ifTrue: [ tmp2 := [:arg5 |  arg1 y > arg5 top ].              tmp3 := [:arg5 |  arg1 y > arg5 bottom ] ] ifFalse: [ tmp2 := [:arg5 |  arg1 y < arg5 bottom ].              tmp3 := [:arg5 |  arg1 y < arg5 top ] ] ] ifFalse: [ properties listDirection == #bottomToTop ifTrue: [ tmp1 := [:arg5 |  arg1 y > arg5 top ] ] ifFalse: [ tmp1 := [:arg5 |  arg1 y < arg5 bottom ] ].        properties wrapDirection == #rightToLeft ifTrue: [ tmp2 := [:arg5 |  arg1 x > arg5 left ].              tmp3 := [:arg5 |  arg1 x > arg5 right ] ] ifFalse: [ tmp2 := [:arg5 |  arg1 x < arg5 right ].              tmp3 := [:arg5 |  arg1 x < arg5 left ] ] ].  arg2 keysAndValuesDo: [:arg6 :arg7 |  | tmp5 |        self flag: #pharoFixMe.        tmp5 := arg7 fullBounds.        tmp4 ifTrue: [ (tmp1 value: tmp5) ifTrue: [ ^arg6 ] ] ifFalse: [ (tmp3 value: tmp5) ifTrue: [ ^arg6 ].              ((tmp1 value: tmp5) and: [ tmp2 value: tmp5 ]) ifTrue: [ ^arg6 ] ] ].  ^arg2 size + 1onSelectionChangeSend: arg1 to: arg2  self on: MorphTreeSelectionChanged send: arg1 to: arg2newContents: arg1  | tmp1 tmp2 |  tmp1 := arg1 isString ifTrue: [ | tmp3 |        (text notNil and: [ (tmp3 := text size) > 0 and: [ (text runLengthFor: 1) = tmp3 ] ]) ifTrue: [ | tmp4 |              tmp4 := text attributesAt: 1 forStyle: textStyle.              Text string: arg1 copy attributes: tmp4 ] ifFalse: [ Text fromString: arg1 copy ] ] ifFalse: [ arg1 copy asText ].  (text = tmp1 and: [ text runs = tmp1 runs ]) ifTrue: [ ^self ].  text ifNotNil: [ (tmp2 := text embeddedMorphs) ifNotNil: [ self removeAllMorphsIn: tmp2.              tmp2 do: [:arg2 |  arg2 delete ] ] ].  text := tmp1.  tmp1 embeddedMorphs do: [:arg2 |  self addMorph: arg2.        arg2 position: -1000 @ 0 ].  self releaseParagraph.  self paragraph.  self world ifNotNil: [ self world startSteppingSubmorphsOf: self ]setType: arg1 startPoint: arg2 endPoint: arg3 trail: arg4 buttons: arg5 hand: arg6 stamp: arg7  type := arg1.  startPoint := arg2.  position := arg3.  trail := arg4.  buttons := arg5.  source := arg6.  wasHandled := false.  timeStamp := arg7isExplicit  self subclassResponsibilitywantsEasySelection  ^self isEasySelectingnumberOfRows  ^self elements ifNotNil: [ self elements size ] ifNil: [ 0 ]privateBounds: arg1  fullBounds := nil.  bounds := arg1keyStrokeArrowDown: arg1  (self selectionModeStrategy is: self selectedIndex aboveRow: self numberOfRows) ifFalse: [ ^self ].  self resetFunction.  self selectIndex: (self selectionModeStrategy selectableIndexBellow: self selectedIndex) event: arg1mouseEnterThumb: arg1  slider     fillStyle: self mouseOverThumbFillStyle;     borderStyle: self mouseOverThumbBorderStyle;     changed.  upButton     fillStyle: self mouseOverThumbButtonFillStyle;     borderStyle: self mouseOverThumbButtonBorderStyle;     changed.  downButton     fillStyle: self mouseOverThumbButtonFillStyle;     borderStyle: self mouseOverThumbButtonBorderStyle;     changedchangeClipSubmorphs  self clipSubmorphs: self clipSubmorphs notsetDirectionFrom: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self renderedMorph.  tmp3 == self ifTrue: [ ^self ].  tmp1 := (tmp3 transformFromWorld globalPointToLocal: arg1) - tmp3 referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedmouseDown: arg1  container enabled ifFalse: [ ^self ].  complexContents mouseDown: arg1rootItems: arg1  initialRootItems := arg1.  super rootItems: initialRootItems copy.  self updateListstepListSortBlock  ^[:arg1 :arg2 |  arg1 scheduledTime <= arg2 scheduledTime ]addSourceToRootItem  rootItem dataSource: selflinkSplittersToSplitters  self splitters do: [:arg1 |  arg1 splitsTopAndBottom ifTrue: [ self splitters do: [:arg2 |  arg2 splitsTopAndBottom ~= arg1 splitsTopAndBottom ifTrue: [ arg2 layoutFrame bottomFraction = arg1 layoutFrame topFraction ifTrue: [ arg1 addLeftOrTop: arg2 ].                          arg2 layoutFrame topFraction = arg1 layoutFrame bottomFraction ifTrue: [ arg1 addRightOrBottom: arg2 ] ] ] ] ifFalse: [ self splitters do: [:arg2 |  arg2 splitsTopAndBottom ~= arg1 splitsTopAndBottom ifTrue: [ arg2 layoutFrame rightFraction = arg1 layoutFrame leftFraction ifTrue: [ arg1 addLeftOrTop: arg2 ].                          arg2 layoutFrame leftFraction = arg1 layoutFrame rightFraction ifTrue: [ arg1 addRightOrBottom: arg2 ] ] ] ] ]popUpOwner  ^nilsortingIcon  ^self state sortingIconwasHandled: arg1  drawOn: arg1  super drawOn: arg1.  self drawRowsOn: arg1initialize  super initialize.  outOfWorldCount := intoWorldCount := 0selectionChanged  self paragraph selectionRects do: [:arg1 |  | tmp1 |        tmp1 := arg1 intersect: self fullBounds ifNone: [ nil ].        tmp1 ifNotNil: [ self invalidRect: (self expandFullBoundsForDropShadow: tmp1) ] ]expandedForm  ^self theme treeExpandedFormhandleMouseEnter: arg1  ^self dispatchDefault: arg1 with: morphnewButtonLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newButtonLabelIn: self for: arg1 label: arg2 getEnabled: arg3matches: arg1  ^(regex matchesIn: arg1) notEmptyadd: arg1 selector: arg2 argument: arg3  ^self add: arg1 target: defaultTarget selector: arg2 argumentList: (Array with: arg3)originalObject  ^originalObjectmouseLeaveDragging: arg1  self noMorePotentialDropTargethandleDropFiles: arg1  ^self dispatchDefault: arg1 with: morphacceptContents  isExpanded  ^trueballoonText  ^complexContents balloonText ifNil: [ super balloonText ]drawDaysOn: arg1  days do: [:arg2 |  arg2 drawOn: arg1 offset: self bounds topLeft ]notify: arg1 from: arg2  | tmp1 |  recipient ifNil: [ ^self ].  tmp1 := selector numArgs.  tmp1 = 0 ifTrue: [ ^recipient perform: selector ].  tmp1 = 1 ifTrue: [ ^recipient perform: selector with: arg1 ].  tmp1 = 2 ifTrue: [ ^recipient perform: selector with: arg1 with: arg2 ].  tmp1 = 3 ifTrue: [ ^recipient perform: selector with: valueParameter with: arg1 with: arg2 ].  self error: 'Event handling selectors must be Symbols and take 0-3 arguments'newGroupbox: arg1 forAll: arg2  ^self theme newGroupboxIn: self label: arg1 forAll: arg2newToolDockingBar  ^self theme newToolDockingBarIn: selfrotationDegrees: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self referencePosition.  tmp4 := originalAngle ifNil: [ self heading ].  tmp5 := originalCenter ifNil: [ self center ].  tmp3 := (MorphicTransform offset: tmp1 negated) withAngle: (arg1 - tmp4) degreesToRadians.  tmp2 := (tmp3 transform: tmp5) - tmp3 offset.  self position: (self position + tmp2 - self center) asIntegerPoint.  referencePosition := tmp1.  originalAngle := tmp4.  originalCenter := tmp5.  self forwardDirection: arg1.  self changedborderWidth: arg1  super borderWidth: arg1.  self updateGradientsnodeStringGetter: arg1  rowMorphGetSelector := arg1 isSymbol ifTrue: [ [:arg2 |  (arg2 complexContents perform: arg1) asMorph ] ] ifFalse: [ [:arg2 |  (arg1 value: arg2 complexContents) asMorph ] ]getImageSelector  ^getImageSelectorgetLabelSelector  ^getLabelSelectordrawKeyboardFocusOnAthensCanvas: arg1  self focusIndicatorMorph drawOnAthensCanvas: arg1defaultBorderColor  ^self defaultColor muchDarkerhResizing  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #rigid ] ifNotNil: [ tmp1 hResizing ]visibleClearArea  ^self viewBox intersect: self clearArea ifNone: [ 0 @ 0 corner: 0 @ 0 ]showMenuForPosition: arg1  | tmp1 |  tmp1 := self container rowAndColumnIndexContainingPoint: arg1.  self showMenuForIndex: tmp1initializeTrackedMorphs  leftMorphs := OrderedCollection new.  overMorphs := WriteStream on: #().  enteredMorphs := WriteStream on: #()setNameTo: arg1  | tmp1 tmp2 |  tmp1 := arg1 ifNotNil: [ (tmp2 := arg1 asString) notEmpty ifTrue: [ tmp2 ] ifFalse: [ '*' ] ].  self setNamePropertyTo: tmp1targetPoint  ^self target bounds pointAtSideOrCorner: self edgeNametestRowIndexFrom  self subclassResponsibilityisCursorOverHandle  ^self class showSplitterHandles not or: [ self handleRect containsPoint: ActiveHand cursorPoint ]red: arg1  | tmp1 |  tmp1 := self selectedColor.  self selectedColor: ((Color r: arg1 g: tmp1 green * 255 b: tmp1 blue * 255 range: 255) alpha: tmp1 alpha)keepOpen  ^self class keepOpennewAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 font: arg5 help: arg6 entryCompletion: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 font: arg5 help: arg6 entryCompletion: arg7setGridSpec  | tmp1 tmp2 |  tmp1 := UIManager default request: 'New grid origin (usually 0@0):' translated initialAnswer: self gridOrigin printString.  tmp1 isEmpty ifTrue: [ ^self ].  tmp2 := [ self class compiler evaluate: tmp1 ] ifError: [ ^self ].  (tmp2 isPoint and: [ tmp2 >= (0 @ 0) ]) ifTrue: [ self gridOrigin: tmp2 ] ifFalse: [ self inform: 'Must be a Point with coordinates (for example 10@10)' translated ].  tmp1 := UIManager default request: 'New grid spacing:' translated initialAnswer: self gridModulus printString.  tmp1 isEmptyOrNil ifTrue: [ ^self ].  tmp2 := [ self class compiler evaluate: tmp1 ] ifError: [ ^self ].  (tmp2 isPoint and: [ tmp2 > (0 @ 0) ]) ifTrue: [ self gridModulus: tmp2 ] ifFalse: [ self inform: 'Must be a Point with coordinates (for example 10@10)' translated ]drawArrowOnAthensCanvas: arg1 at: arg2 from: arg3  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self arrowBoundsAt: arg2 from: arg3.  tmp3 := tmp1 size = 4 ifTrue: [ tmp1 third ] ifFalse: [ (tmp1 copyFrom: 2 to: 3) average ].  tmp2 := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  tmp4 := arg1 createPath: [:arg4 |  arg4 absolute.        arg4 moveTo: tmp1 first.        tmp1 allButFirst do: [:arg5 |  arg4 lineTo: arg5 ].        arg4 close ].  tmp2 x sign = tmp2 y sign ifTrue: [ arg1 setPaint: self borderColor ] ifFalse: [ (arg1 setStrokePaint: self borderColor) width: (borderWidth + 1) // 2 ].  arg1 drawShape: tmp4.  ^tmp3hasCloseBox  ^closeBox notNilcolorFor: arg1  arg1 odd ifTrue: [ ^Smalltalk ui theme lightBackgroundColor ].  ^Smalltalk ui theme backgroundColormarried  ^marriednextSibling  ^nextSiblingnewSVSelector: arg1 help: arg2  ^self theme newSVSelectorIn: self color: arg1 help: arg2imageForm: arg1 forRectangle: arg2  | tmp1 |  tmp1 := Display defaultCanvasClass extent: arg2 extent depth: arg1.  tmp1 translateBy: arg2 topLeft negated during: [:arg3 |  arg3 fullDrawMorph: self ].  ^tmp1 form offset: arg2 topLeftnewHSVColorMorph  ^HSVColorSelectorMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     when: #colorSelected send: #colorSelected: to: selfnumberOfMethodsColumn: arg1 row: arg2  ^FTCellMorph new     addMorph: (self elementAt: arg2) numberOfMethods asStringMorph;     yourselffeedbackColor: arg1  feedbackColor := arg1.  self changeddefaultLabel  ^'|'pagerColor  ^treeMorph pagerColorcleanProcesses  processes do: [:arg1 |  arg1 terminate ].  processes removeAllfirstName: arg1  self item firstName: arg1.  self changed: #firstNameaddARow: arg1  | tmp1 |  tmp1 := self class inARow: arg1.  self addMorphBack: tmp1.  ^tmp1drawOn: arg1  drawable ifFalse: [ container buildRowMorphsFrom: self ] ifTrue: [ super drawOn: arg1 ]isMouseLeave  ^self type == #mouseLeavedropItemSelector  ^dropItemSelectormouseLeaveUpButton: arg1  arg1 redButtonPressed ifFalse: [ upButton           fillStyle: self normalButtonFillStyle;           borderStyle: self normalButtonBorderStyle;           changed ]leftCenter  ^bounds leftCentersubmorphBounds  ^(self localVisibleSubmorphBounds ifNotNil: [:arg1 |  transform localBoundsToGlobal: arg1 ] ifNil: [ self bounds ]) truncatedactivateOwnerMenu: arg1  | tmp1 |  (owner isNil or: [ owner isMenuMorph not ]) ifTrue: [ ^false ].  (owner fullContainsPoint: arg1 position) ifTrue: [ owner activate: arg1.        ^true ].  tmp1 := owner popUpOwner.  [ tmp1 ] whileNotNil: [ (tmp1 owner fullContainsPoint: arg1 position) ifTrue: [ tmp1 owner activate: arg1.              ^true ] ifFalse: [ tmp1 := tmp1 owner popUpOwner ] ].  ^falsestep  | tmp1 |  tmp1 := hand lastEvent.  tmp1 anyButtonPressed ifTrue: [ waitingForClickInside := false.        self position: tmp1 cursorPoint - (self extent // 2).        pointBlock value: self center ] ifFalse: [ waitingForClickInside ifTrue: [ (self containsPoint: tmp1 cursorPoint) ifFalse: [ ^self delete ] ] ifFalse: [ lastPointBlock value: self center.              ^self delete ] ]defaultBorderWidth  ^1labelMorph: arg1  labelMorph := arg1highlight  self allMorphsDo: [:arg1 |  (arg1 isKindOf: StringMorph) ifTrue: [ arg1 setProperty: #originalColor toValue: arg1 color.              arg1 color: self theme selectionTextColor ] ].  complexContents highlightingColor ifNotNil: [:arg2 |  self setProperty: #originalColor toValue: color.        self color: arg2 ]wantsYellowButtonMenu  ^falsedoesOwnRotation  ^falseactivateFromKeyboard: arg1  arg1 hand newMouseFocus: self.  self activate: arg1.  self takeKeyboardFocus.  self moveSelectionDown: 1 event: arg1removeObsoleteEventHandlers  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  scroller submorphs do: [:arg1 |  arg1           eventHandler: nil;           highlightForMouseDown: false;           resetExtension ]wantsKeyboardFocusFor: arg1  arg1 wouldAcceptKeyboardFocus ifTrue: [ ^true ].  ^super wantsKeyboardFocusFor: arg1openInWindowLabeled: arg1 inWorld: arg2  | tmp1 tmp2 |  tmp1 := (SystemWindow labelled: arg1) model: nil.  tmp1     bounds: (RealEstateAgent initialFrameFor: tmp1 initialExtent: self fullBounds extent world: arg2);     addMorph: self frame: (0 @ 0 extent: 1 @ 1);     updatePaneColors.  tmp2 := self fullBounds extent + (tmp1 borderWidth @ tmp1 labelHeight) + tmp1 borderWidth + ((tmp1 class borderWidth * 2) @ (tmp1 class borderWidth + 1)).  tmp1 extent: tmp2.  arg2 addMorph: tmp1.  tmp1 activate.  arg2 startSteppingSubmorphsOf: tmp1.  tmp1 announceOpened.  ^tmp1font: arg1  titleContainer ifNil: [ ^self ].  titleContainer submorphsDo: [:arg2 |  arg2 font: arg1 ]veryDeepInner: arg1  super veryDeepInner: arg1.  selectedItem := selectedItem veryDeepCopyWith: arg1.  stayUp := stayUp veryDeepCopyWith: arg1.  popUpOwner := popUpOwner.  activeSubMenu := activeSubMenuenablementSelector: arg1  enablementSelector := arg1mouseOverButtonFillStyle  ^self theme scrollbarMouseOverButtonFillStyleFor: selfnewAlphaImage: arg1 help: arg2  ^self theme newAlphaImageIn: self image: arg1 help: arg2updateButtonsAndPreview  self     updateTaskButtons;     updatePreview.  self world ifNotNil: [ self center: self world center ]initialize  super initialize.  self     changeTableLayout;     cellPositioning: #topLeft;     cellInset: 2;     vResizing: #shrinkWrap;     hResizing: #rigidmouseUp: arg1  (self bounds containsPoint: arg1 cursorPoint) ifFalse: [ arg1 hand showTemporaryCursor: nil ].  self adoptPaneColor: self paneColordefaultBorderColor  ^self theme darkBaseColordrawOn: arg1  super drawOn: arg1.  self columns do: [:arg2 |  arg2 drawColumnOn: arg1 ]cellColumn: arg1 row: arg2  | tmp1 tmp2 tmp3 |  tmp1 := self elementAt: arg2.  tmp3 := self getIconSelector ifNotNil: [:arg3 |  self model perform: arg3 with: tmp1 ].  tmp2 := arg1 transform: (self elementWrapped: tmp1).  ^self createCellText: tmp2 icon: tmp3selected: arg1  selected := arg1.  self changed: #selecteddetachSubMenu: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self items select: [:arg2 |  arg2 hasSubMenu ].  tmp1 isEmpty ifTrue: [ ^self ].  tmp4 := UIManager default chooseFrom: (tmp1 collect: [:arg3 |  arg3 contents asString ]) title: 'Which menu?' translated.  tmp4 = 0 ifTrue: [ ^self ].  tmp2 := tmp1 at: tmp4.  tmp3 := tmp2 subMenu.  tmp3 ifNotNil: [ tmp2 subMenu: nil.        tmp2 delete.        tmp3 stayUp: true.        tmp3 popUpOwner: nil.        tmp3 addTitle: tmp2 contents.        arg1 hand attachMorph: tmp3 ]veryDeepFixupWith: arg1  | tmp1 |  super veryDeepFixupWith: arg1.  1 to: self class instSize do: [:arg2 |  tmp1 := self instVarAt: arg2.        self instVarAt: arg2 put: (arg1 references at: tmp1 ifAbsent: [ tmp1 ]) ]allMorphsInto: arg1  submorphs do: [:arg2 |  arg2 allMorphsInto: arg1 ].  self allNonSubmorphMorphs do: [:arg2 |  (arg1 includes: arg2) ifFalse: [ arg2 allMorphsInto: arg1 ] ].  arg1 add: self.  ^arg1isHorizontallyResizeable  ^self rightFraction ~= self leftFractionred  ^(self selectedColor red * 255) asIntegerresetFunction  function resetshowMouseFocusEvent: arg1  ShowEvents == true ifTrue: [ | tmp1 |        tmp1 := ((owner hands indexOf: self) - 1) * 60.        self mouseFocus printString displayAt: 0 @ tmp1 + (0 @ 15) ]label: arg1  label := arg1newPluggableDialogWindow: arg1 for: arg2  ^self theme newPluggableDialogWindowIn: self title: arg1 for: arg2childrenItems  ^(self item subclasses asArray sort: [:arg1 :arg2 |  arg1 name < arg2 name ]) asOrderedCollectionnewEmbeddedMenu  ^self theme newEmbeddedMenuIn: self for: selftoggleResistsRemoval  self resistsRemoval ifTrue: [ self removeProperty: #resistsRemoval ] ifFalse: [ self setProperty: #resistsRemoval toValue: true ]icon: arg1  directionArrowLength  ^25drawOn: arg1  super drawOn: arg1.  (self enabled not and: [ self disabledStyle = #inset ]) ifTrue: [ arg1 drawString: self contents in: (self stringBounds translateBy: 1) font: self fontToUse color: self theme lightBackgroundColor ]blue: arg1  | tmp1 |  tmp1 := self selectedColor.  self selectedColor: ((Color r: tmp1 red * 255 g: tmp1 green * 255 b: arg1 range: 255) alpha: tmp1 alpha)hResizing: arg1  self assureLayoutProperties hResizing: arg1.  self layoutChangedmove: arg1 for: arg2 controller: arg3  | tmp1 tmp2 |  tmp2 := arg1 cursorPoint.  tmp1 := false.  self actionAttributesUnder: tmp2 event: arg1 do: [:arg4 |  | tmp3 |        tmp3 := arg2 ifNil: [ arg3 morph ].        (arg4 actOnMove: arg1 for: tmp3 in: self editor: arg3) == true ifTrue: [ ^true ] ].  (tmp1 and: [ Cursor currentCursor == Cursor webLink ]) ifTrue: [ Cursor normal show ].  ^tmp1step  | tmp1 |  target ifNil: [ ^self ].  tmp1 := target isWorldMorph ifTrue: [ target bounds ] ifFalse: [ self localHaloBoundsFor: target renderedMorph ].  tmp1 = self bounds ifTrue: [ ^self ].  tmp1 extent = self bounds extent ifTrue: [ ^self position: tmp1 origin ].  growingOrRotating ifFalse: [ submorphs size > 1 ifTrue: [ self addHandles ] ].  self bounds: tmp1newDataSourceMatching: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self elements select: [:arg2 |  tmp2 := self elementWrapped: arg2.        table columns anySatisfy: [:arg3 |  tmp3 := arg3 transform: tmp2.              arg1 matches: tmp3 ] ].  tmp4 := self copy.  tmp5 := self model copy.  tmp5 prepareForFilteredDataSourceWith: tmp1.  tmp4 model: tmp5.  ^tmp4buttonImageColor  ^self theme scrollbarImageColorFor: selfeventHandler  ^eventHandlerthemeChanged  self initializeAppearance.  self removeAllMorphs.  super themeChanged.  self updateTaskButtonsreadFromFile  | tmp1 |  tmp1 := UIManager default request: 'Please enter the image file name' translated initialAnswer: 'fileName'.  tmp1 isEmptyOrNil ifTrue: [ ^self ].  self form: (Form fromFileNamed: tmp1)textBounds  ^boundscanDisplayChildrenOf: arg1  ^self maxDepth ifNil: [ true ] ifNotNil: [ self maxDepth > arg1 depth ]newStack  ^self theme newStackIn: self for: #()nodeList  ^treeMorph nodeListactiveDisabledNotOverDownFillStyle: arg1  self stateMap atPath: #(active disabled notOver down) put: arg1.  self changedtextStyle  ^self actualFont textStyle ifNil: [ TextStyle default ]actualClass  ^self subclassResponsibilityfirstCharacterIndex  ^self paragraph firstCharacterIndexhandle: arg1 in: arg2 dropEvent: arg3  | tmp1 tmp2 tmp3 |  tmp1 := arg1 fullName.  tmp2 := self servicesForFileNamed: tmp1.  tmp2 isEmpty ifTrue: [ arg1 inspect.        ^self ].  tmp3 := self chooseServiceFrom: tmp2.  tmp3 ifNotNil: [ tmp3 performServiceFor: arg1 ]isSystemWindow  ^trueaddAddHandMenuItemsForHalo: arg1 hand: arg2  checkMorphsLeftOrTopFrom: arg1  | tmp1 tmp2 |  tmp2 := submorphs size.  tmp1 := submorphs identityIndexOf: arg1.  tmp1 := tmp1 + 1.  [ tmp1 <= tmp2 ] whileTrue: [ | tmp3 tmp4 |        tmp3 := submorphs at: tmp1.        arg1 addLeftOrTop: tmp3.        tmp4 := self isResizeableMorph: tmp3 forSplitter: arg1.        tmp4 ifTrue: [ tmp1 := tmp2 + 1 ].        tmp1 := tmp1 + 1 ]barDeleted: arg1  self closeactiveHand: arg1  ActiveHand := arg1.  activeHand := arg1storeOn: arg1  super storeOn: arg1.  arg1 space.  self startPoint x storeOn: arg1.  arg1 space.  self startPoint y storeOn: arg1.  arg1 spacerefreshExpandedState  | tmp1 tmp2 tmp3 |  tmp2 := OrderedCollection new.  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg1 |  arg1 recursiveAddTo: tmp2 ] ].  container noteRemovalOfAll: tmp2.  (isExpanded and: [ complexContents hasContents ]) ifFalse: [ ^self changed ].  (tmp3 := complexContents contents) isEmpty ifTrue: [ ^self changed ].  tmp1 := container addSubmorphsAfter: self fromCollection: tmp3 allowSorting: true.  firstChild := tmp1 firsttreeLineDashes: arg1  treeLineDashes := arg1deactivate  doFastReframe: arg1  | tmp1 |  tmp1 := self boundsInWorld newRectButtonPressedDo: [:arg2 :arg3 |  arg2 withSideOrCorner: arg1 setToPoint: arg3 minExtent: self minimumExtent ].  Display deferUpdatesIn: Display boundingBox while: [ self bounds: tmp1 ].  ^tmp1layoutBounds: arg1  super layoutBounds: arg1.  self updateFillStyle.  slider horizontal: self bounds isWide.  sliderShadow horizontal: self bounds isWidetextStyle: arg1  textStyle := arg1updateSelectedLocation  self locationMorph position: self selectedLocation - (self locationMorph extent // 2 + (self locationMorph extent \\ 2))scrollDown: arg1  self setValue: (value + (scrollDelta * arg1) + 0.000001 min: 1.0)extent: arg1  self basicExtent: arg1.  (self layout = #scaled or: [ self layout = #scaledAspect ]) ifTrue: [ self cachedForm: nil ]announce: arg1  self doAnnounce: arg1setTarget: arg1  | tmp1 |  tmp1 := self world rootMorphsAt: arg1 hand targetPoint.  target := tmp1 size > 1 ifTrue: [ tmp1 second ]alpha: arg1  alpha := arg1.  self     cachedForm: nil;     changed;     changed: #alphadrawOnAthensCanvas: arg1  | tmp1 |  tmp1 := self bounds topLeft + self layoutInset.  font := self fontToUse.  arg1 pathTransform restoreAfter: [ arg1 pathTransform translateBy: tmp1.        arg1 pathTransform translateX: 0 Y: font getPreciseAscent.        arg1           setPaint: color;           setFont: self fontToUse;           drawString: contents ]isAdheringToBottom  ^self edgeToAdhereTo == #bottomrenameTo: arg1  self topRendererOrSelf setNameTo: arg1.  ^arg1searchedElement  ^searchedElementstep  self subMorph step.  self changedhandlesMouseDown: arg1  ^truesliderMorph: arg1  sliderMorph := arg1icon  ^iconscreenLocation  ^self fullBounds originunlock  self lock: falseexpandAll  self roots reverseDo: [:arg1 |  self expandAllSilently: arg1 ].  self innerWidgetChangedaddDropShadowMenuItems: arg1 hand: arg2  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 addUpdating: #hasDropShadowString selector: #toggleDropShadow.  tmp1 addLine.  tmp1 add: 'shadow color...' target: self selector: #changeShadowColor.  tmp1 add: 'shadow offset...' target: self selector: #setShadowOffset:.  arg1 add: 'drop shadow' subMenu: tmp1frameRectangle8: arg1 on: arg2  | tmp1 |  tmp1 := arg1 insetBy: self width // 2.  self width odd ifTrue: [ tmp1 := tmp1 insetBy: (0 @ 0 corner: 1 @ 1) ].  arg2     line: tmp1 topLeft + (8 @ 0) to: tmp1 topRight - (8 @ 0) width: self width color: self color;     line: tmp1 topRight + (-7 @ 1) to: tmp1 topRight + (-6 @ 1) width: self width color: self color;     line: tmp1 topRight + (-5 @ 2) to: tmp1 topRight + (-2 @ 5) width: self width color: self color;     line: tmp1 topRight + (-1 @ 6) to: tmp1 topRight + (-1 @ 7) width: self width color: self color;     line: tmp1 topRight + (0 @ 8) to: tmp1 bottomRight - (0 @ 8) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 7) to: tmp1 bottomRight - (1 @ 6) width: self width color: self color;     line: tmp1 bottomRight - (2 @ 5) to: tmp1 bottomRight - (5 @ 2) width: self width color: self color;     line: tmp1 bottomRight - (6 @ 1) to: tmp1 bottomRight - (7 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (8 @ 0) to: tmp1 bottomLeft + (8 @ 0) width: self width color: self color;     line: tmp1 bottomLeft - (-7 @ 1) to: tmp1 bottomLeft - (-6 @ 1) width: self width color: self color;     line: tmp1 bottomLeft - (-5 @ 2) to: tmp1 bottomLeft - (-2 @ 5) width: self width color: self color;     line: tmp1 bottomLeft - (-1 @ 6) to: tmp1 bottomLeft - (-1 @ 7) width: self width color: self color;     line: tmp1 bottomLeft - (0 @ 8) to: tmp1 topLeft + (0 @ 8) width: self width color: self color;     line: tmp1 topLeft + (1 @ 7) to: tmp1 topLeft + (1 @ 6) width: self width color: self color;     line: tmp1 topLeft + (2 @ 5) to: tmp1 topLeft + (5 @ 2) width: self width color: self color;     line: tmp1 topLeft + (6 @ 1) to: tmp1 topLeft + (7 @ 1) width: self width color: self colorisVisible  ^self tabSelector ifNil: [ false ] ifNotNil: [:arg1 |  arg1 visibleTabs includes: self ]beRight  self option: #righttrackPaneColor  ^trackPaneColorturnOff  self borderColor: #raised.  self color: offColorinitialize  super initialize.  needsRefreshExposedRows := false.  startColumnIndex := 0wantsDropElements: arg1 type: arg2 index: arg3  ^falsestepTime  (self hasProperty: #doesButtonAction) ifTrue: [ ^1 ].  ^super stepTimesegmentedSlopesOf: arg1  ^arg1 collectWithIndex: [:arg2 :arg3 |  (arg1 atWrap: arg3 + 1) - arg2 ]ownerChanged  self updateBounds.  ^super ownerChangedsecondName: arg1  secondName := arg1defaultBorderColor  ^Color r: 0.0 g: 0.419 b: 0.935vResizeScrollBar  | tmp1 tmp2 |  tmp1 := self scrollBarThickness.  tmp2 := bounds topRight - ((tmp1 + borderWidth - 0) @ (0 - borderWidth)).  scrollBar bounds: (tmp2 extent: tmp1 @ self vScrollBarHeight)asMouseLeave  ^self shallowCopy setType: #mouseLeaveisDraggingEvent  ^falseenabled: arg1  self submorphsDo: [:arg2 |  arg2 enabled: arg1 ]isComplex  ^falsenewTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5 entryCompletion: arg6  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5 entryCompletion: arg6isPressed  ^pressedstartDrag: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #startDrag from: arg2mouseOverBorderStyle  ^self theme taskbarItemMouseOverBorderStyleFor: selfhandlesKeyboard: arg1  ^arg1 anyModifierKeyPressed not or: [ arg1 commandKeyPressed and: [ self commandKeyHandler notNil ] ]testLeakingSelectionsOnUpdate  | tmp1 tmp2 tmp3 |  tmp1 := ClassTreeExample new.  [ tmp2 := tmp1 openOn: Collection.  tmp3 := tmp1 dependents last.  tmp3 expandAll.  tmp3 selectAll.  tmp1 updateList.  tmp3 listManager selectedMorphList do: [:arg1 |  self assert: (tmp3 allNodeMorphs includes: arg1) ] ] ensure: [ tmp2 close ]stepAt: arg1  self steprotationDegrees  ^0.0cellInset: arg1  cellInset := arg1themeChanged  self selectionColor: self theme selectionColor.  self color: self defaultColor.  super themeChangeddrawOnAthensCanvas: arg1  self drawOnCanvasWrapperFor: arg1keyStroke: arg1  arg1 keyString = '<Cmd-a>' ifTrue: [ self selectAll ].  arg1 keyString = '<Cmd-A>' ifTrue: [ self deselectAll ]newCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6startAt: arg1  startValue := arg1hExtraScrollRange  ^5handlesKeyDown: arg1  ^self handlesKeyboard: arg1subMorph  subMorph ifNil: [ self update: self textSelector ].  ^subMorphdrawOnAthensCanvas: arg1 bounds: arg2 color: arg3  self displayCaretAndSelectionOnAthensCanvas: arg1.  self displayExtraSelectionOnAthensCanvas: arg1.  arg1 setPaint: arg3.  self displayTextOnAthensCanvas: arg1 in: arg2drawOn: arg1  self perform: #drawOn: withArguments: {arg1} inSuperclass: Morph.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: arg1 ]initialize  super initialize.  self initForKeystrokesexploreItem  self inspectsubMenuMarker  owner isFloating ifTrue: [ ^self bottomArrow ].  owner isAdheringToTop ifTrue: [ ^self bottomArrow ].  owner isAdheringToBottom ifTrue: [ ^self upArrow ].  owner isAdheringToLeft ifTrue: [ ^self rightArrow ].  owner isAdheringToRight ifTrue: [ ^self leftArrow ].  ^self rightArrowmoveSelectionRight: arg1 event: arg2  | tmp1 |  tmp1 := (submorphs indexOf: selectedItem ifAbsent: [ 1 - arg1 ]) + arg1.  submorphs do: [:arg3 |  | tmp2 |        tmp2 := submorphs atWrap: tmp1.        (tmp2 isMenuItemMorph and: [ tmp2 isEnabled ]) ifTrue: [ ^self selectItem: tmp2 event: arg2 ].        tmp1 := tmp1 + arg1 sign ].  ^self selectItem: nil event: arg2style  ^#insetflags  ^flags ifNil: [ 0 ]cleanupFilter  (function isKindOf: FTFilterFunction) ifTrue: [ function terminateFilterProcess ]testProperty  | tmp1 |  tmp1 := self dataSourceForTesting.  strategy property: #yourself.  self assert: tmp1 elements equals: self elementsForTestDataSource.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy reset.  strategy property: #asString.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 10 2 3 4 5 6 7 8 9)iconBlock: arg1  iconBlock := arg1minResizerOffset  ^20selectablesToHighlightFromRow: arg1 at: arg2 withHighlightedIndexes: arg3 andPrimaryIndex: arg4  | tmp1 |  tmp1 := Dictionary new.  (arg3 includes: arg2) ifTrue: [ tmp1 at: arg1 put: arg4 = arg2 ].  ^tmp1mouseDown: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersgetAllButFirstCharacter  | tmp1 |  ^(tmp1 := text string) size > 1 ifTrue: [ tmp1 copyFrom: 2 to: tmp1 size ] ifFalse: [ '·' ]nonWindows  ^self submorphs select: [:arg1 |  arg1 isSystemWindow not and: [ arg1 wantsToBeTopmost not ] ]wasActivatedFromDockingBar  ^activatorDockingBar notNilgetIconSelector: arg1  self dataSource getIconSelector: arg1handleEvent: arg1  arg1 isWindowNavigation ifFalse: [ ^false ].  world theme openTaskListIn: world from: arg1.  ^trueborderInset  self borderColor: #insetmouseDown: arg1  (arg1 shiftPressed and: [ self isEditable ]) ifTrue: [ ^super mouseDown: arg1 ].  isSelected ifTrue: [ owner selectItem: nil event: arg1 ] ifFalse: [ owner activate: arg1.        owner selectItem: self event: arg1 ]newWindowFor: arg1 title: arg2  ^self theme newWindowIn: self for: arg1 title: arg2useSelectionBar  ^falsebuildRowMorphsFrom: arg1 increment: arg2  Cursor wait showWhile: [ | tmp1 tmp2 tmp3 |        tmp1 := self allNodeMorphs.        tmp2 := arg1 index.        tmp3 := tmp2 + arg2 min: tmp1 size.        self buildRowMorphsFromIndex: tmp2 to: tmp3 ]frameRectangle4: arg1 on: arg2  | tmp1 |  tmp1 := arg1 insetBy: self width // 2.  self width odd ifTrue: [ tmp1 := tmp1 insetBy: (0 @ 0 corner: 1 @ 1) ].  arg2     line: tmp1 topLeft + (4 @ 0) to: tmp1 topRight - (4 @ 0) width: self width color: self color;     line: tmp1 topRight + (-3 @ 1) to: tmp1 topRight + (-1 @ 2) width: self width color: self color;     line: tmp1 topRight + (-1 @ 2) to: tmp1 topRight + (-1 @ 3) width: self width color: self color;     line: tmp1 topRight + (0 @ 4) to: tmp1 bottomRight - (0 @ 4) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 3) to: tmp1 bottomRight - (1 @ 2) width: self width color: self color;     line: tmp1 bottomRight - (2 @ 1) to: tmp1 bottomRight - (3 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (4 @ 0) to: tmp1 bottomLeft + (4 @ 0) width: self width color: self color;     line: tmp1 bottomLeft - (-3 @ 1) to: tmp1 bottomLeft - (-2 @ 1) width: self width color: self color;     line: tmp1 bottomLeft - (-1 @ 2) to: tmp1 bottomLeft - (-1 @ 3) width: self width color: self color;     line: tmp1 bottomLeft - (0 @ 4) to: tmp1 topLeft + (0 @ 4) width: self width color: self color;     line: tmp1 topLeft + (1 @ 3) to: tmp1 topLeft + (1 @ 2) width: self width color: self color;     line: tmp1 topLeft + (2 @ 1) to: tmp1 topLeft + (3 @ 1) width: self width color: self colormoveToEvent: arg1  self handleEvent: (MouseMoveEvent basicNew setType: #mouseMove startPoint: self position endPoint: arg1 position trail: (Array with: self position with: arg1 position) buttons: arg1 buttons hand: self stamp: arg1 timeStamp)createShortcutMorphFor: arg1  ^FadingMorph new     addMorphBack: (self createLabelMorph: arg1 contents);     addMorphBack: (self createKeyTextMorph: arg1 keyText);     color: backgroundColor;     yourselfmouseUp: arg1  super mouseUp: arg1.  self selectedItem ifNil: [ ^self ].  self selectedItem selector ifNil: [ ^self ].  (self selectedItem containsPoint: arg1 cursorPoint) ifFalse: [ ^self ].  self selectedItem invokeWithEvent: arg1.  self selectItem: nil event: arg1updateContentsWithPreviouslyExpanded: arg1  nodeList := nil.  self noteRemovalOfAll: self allNodeMorphs.  (self nodeList isNil or: [ self nodeList isEmpty ]) ifTrue: [ nodeList := nil.        ^self emptySelection ].  self addSubmorphsFromNodeList: self currentNodelist previouslyExpanded: arg1.  self listManager updateLastClickedMorphhandlesMouseOverDragging: arg1  ^truetaskList  ^taskListselector: arg1  selector := arg1primaryHand  | tmp1 |  tmp1 := self outermostWorldMorph ifNil: [ ^nil ].  ^tmp1 activeHand ifNil: [ tmp1 firstHand ]close  SystemProgressMorph uniqueInstance close: self.  self removeDependent: SystemProgressMorph uniqueInstanceinitWithContents: arg1 font: arg2 emphasis: arg3  super initialize.  font := arg2.  emphasis := arg3.  hasFocus := false.  self contents: arg1doesBevels  ^truemouseEnterDragging: arg1  super mouseEnterDragging: arg1.  self over: truecreateMenuButton  | tmp1 tmp2 |  tmp1 := self theme windowMenuForm.  tmp2 := MultistateButtonMorph new extent: tmp1 extent.  tmp2 activeEnabledNotOverUpFillStyle: (ImageFillStyle form: tmp1).  tmp1 := self theme windowMenuPassiveForm.  tmp2 extent: tmp1 extent.  tmp2 activeDisabledNotOverUpFillStyle: (ImageFillStyle form: tmp1).  tmp2 passiveEnabledNotOverUpFillStyle: (ImageFillStyle form: tmp1).  tmp2 passiveDisabledNotOverUpFillStyle: (ImageFillStyle form: tmp1).  tmp1 := self theme windowMenuForm.  tmp2 extent: tmp1 extent.  tmp2     activeEnabledOverUpFillStyle: (ImageFillStyle form: tmp1);     passiveEnabledOverUpFillStyle: (ImageFillStyle form: tmp1).  tmp1 := self theme windowMenuPassiveForm.  tmp2     extent: tmp1 extent;     activeEnabledOverDownFillStyle: (ImageFillStyle form: tmp1);     passiveEnabledOverDownFillStyle: (ImageFillStyle form: tmp1);     addUpAction: [ self popUpMenu ];     setBalloonText: 'tab menu' translated;     extent: 16 @ 16.  ^tmp2drawOn: arg1  | tmp1 |  self isOpaque ifTrue: [ arg1 drawImage: image at: self innerBounds origin ] ifFalse: [ arg1 translucentImage: image at: self innerBounds origin ].  (tmp1 := self borderStyle) ifNotNil: [ tmp1 frameRectangle: bounds on: arg1 ]updateFromEvent: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := arg1 cursorPoint - lastMouse second.  tmp2 := lastMouse first - lastMouse second.  tmp3 := splitsTopAndBottom ifTrue: [ 0 @ ((self normalizedY: tmp1 y) - tmp2 y) ] ifFalse: [ ((self normalizedX: tmp1 x) - tmp2 x) @ 0 ].  lastMouse at: 1 put: (splitsTopAndBottom ifTrue: [ tmp1 x @ (self normalizedY: tmp1 y) + lastMouse second ] ifFalse: [ (self normalizedX: tmp1 x) @ tmp1 y + lastMouse second ]).  leftOrTop do: [:arg2 |  | tmp8 tmp9 |        tmp8 := arg2 layoutFrame rightOffset ifNil: [ 0 ].        tmp9 := arg2 layoutFrame bottomOffset ifNil: [ 0 ].        arg2 layoutFrame rightOffset: tmp8 + tmp3 x.        arg2 layoutFrame bottomOffset: tmp9 + tmp3 y.        (arg2 layoutFrame leftFraction = arg2 layoutFrame rightFraction and: [ arg2 layoutFrame leftFraction ~= 0 ]) ifTrue: [ arg2 layoutFrame leftOffset: (arg2 layoutFrame leftOffset ifNil: [ 0 ]) + tmp3 x ].        (arg2 layoutFrame topFraction = arg2 layoutFrame bottomFraction and: [ arg2 layoutFrame topFraction ~= 0 ]) ifTrue: [ arg2 layoutFrame topOffset: (arg2 layoutFrame topOffset ifNil: [ 0 ]) + tmp3 y ] ].  rightOrBottom do: [:arg2 |  | tmp10 tmp11 |        tmp10 := arg2 layoutFrame leftOffset ifNil: [ 0 ].        tmp11 := arg2 layoutFrame topOffset ifNil: [ 0 ].        arg2 layoutFrame leftOffset: tmp10 + tmp3 x.        arg2 layoutFrame topOffset: tmp11 + tmp3 y.        (arg2 layoutFrame leftFraction = arg2 layoutFrame rightFraction and: [ arg2 layoutFrame rightFraction ~= 1 ]) ifTrue: [ arg2 layoutFrame rightOffset: (arg2 layoutFrame rightOffset ifNil: [ 0 ]) + tmp3 x ].        (arg2 layoutFrame topFraction = arg2 layoutFrame bottomFraction and: [ arg2 layoutFrame bottomFraction ~= 1 ]) ifTrue: [ arg2 layoutFrame bottomOffset: (arg2 layoutFrame bottomOffset ifNil: [ 0 ]) + tmp3 y ] ].  tmp4 := self layoutFrame topOffset ifNil: [ 0 ].  tmp5 := self layoutFrame bottomOffset ifNil: [ 0 ].  tmp6 := self layoutFrame leftOffset ifNil: [ 0 ].  tmp7 := self layoutFrame rightOffset ifNil: [ 0 ].  self layoutFrame topOffset: tmp4 + tmp3 y.  self layoutFrame bottomOffset: tmp5 + tmp3 y.  self layoutFrame leftOffset: tmp6 + tmp3 x.  self layoutFrame rightOffset: tmp7 + tmp3 x.  self owner layoutChangeddefaultImage  ^DefaultFormisRoot  ^falsemouseLeaveDragging: arg1  self mouseLeave: arg1drawOn: arg1  submorphs isEmpty ifTrue: [ super drawOn: arg1 ]initialize  super initialize.  acceptOnCR := false.  autoAccept := false.  acceptOnFocusChange := falselastClicked: arg1  menuImage  ^self class boxOfSize: (self buttonExtent x min: self buttonExtent y) color: self thumbColorcurrentCursor: arg1  ActiveHand world currentCursor: arg1.  ActiveHand world isCursorOwner ifTrue: [ arg1 activateInCursorOwner: ActiveHand world ]griddingString  ^(self griddingOn ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'use gridding' translatedghostString  ^ghostStringfillStyleForItems: arg1  selectedItems with: arg1 do: [:arg2 :arg3 |  arg2 fillStyle: arg3 ]bounds  ^boundsreleaseParagraphReally  self releaseEditor.  paragraph ifNotNil: [ paragraph := nil ].  container ifNotNil: [ container releaseCachedState ]testTransformReturnASubArea  | tmp1 tmp2 tmp3 |  tmp1 := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  tmp3 := 0 @ 0 extent: 100 @ 200.  tmp2 := tmp1 transform: tmp3.  self assert: tmp2 width equals: 80.  self assert: tmp2 height equals: 180sortingStrategy: arg1  sortingStrategy := arg1paneColorToUse  ^Display depth <= 2 ifTrue: [ Color white ] ifFalse: [ self paneColor ]initialize  super initialize.  self     scroller: self newScroller;     hScrollbar: self newHScrollbar;     vScrollbar: self newVScrollbar;     scrollTarget: self defaultScrollTarget.  self     addMorph: self scroller;     resizeScrollerdoActivate  closeUnchangedWindows  (self confirm: 'Do you really want to close all windowsexcept those with unaccepted edits?' translated) ifFalse: [ ^self ].  self closeAllUnchangedWindowsbeCheckbox  self buttonMorph beCheckboxsliderThickness  ^((self bounds isWide ifTrue: [ self height ] ifFalse: [ self width ]) // 2 max: 8) // 2 * 2 + 1newTitle: arg1 for: arg2  ^self theme newTitleIn: self label: arg1 for: arg2displayInLine: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := first stringIndex.  tmp2 := last stringIndex.  (tmp2 < arg1 first or: [ tmp1 > (arg1 last + 1) ]) ifTrue: [ ^self ].  (tmp2 = arg1 first and: [ last textLine ~= arg1 ]) ifTrue: [ ^self ].  (tmp1 = (arg1 last + 1) and: [ last textLine ~= arg1 ]) ifTrue: [ ^self ].  tmp3 := (tmp1 < arg1 first ifTrue: [ arg1 ] ifFalse: [ first ]) left.  tmp4 := (tmp2 > (arg1 last + 1) or: [ tmp2 = (arg1 last + 1) and: [ last textLine ~= arg1 ] ]) ifTrue: [ arg1 right ] ifFalse: [ last left ].  arg2 fillRectangle: (tmp3 @ arg1 top corner: tmp4 @ arg1 bottom) color: colormouseLeaveDragging: arg1  owner ifNil: [ ^self ].  arg1 hand mouseFocus == owner ifFalse: [ ^self ].  subMenu ifNil: [ owner selectItem: nil event: arg1 ] ifNotNil: [ self addAlarm: #deselectTimeOut: with: arg1 after: 500 ]showOverEditableTextCursor  | tmp1 |  owner ifNil: [ ^self ].  tmp1 := owner isWorldMorph ifTrue: [ self ] ifFalse: [ owner ].  (tmp1 boundsInWorld containsPoint: self currentHand position) ifTrue: [ self currentHand showTemporaryCursor: (self theme overTextCursorFor: self) ]drawBackgroundForPotentialDrop: arg1 on: arg2  | tmp1 |  tmp1 := self drawBoundsForRow: arg1.  tmp1 := tmp1 intersect: self bounds ifNone: [ ^self ].  arg2 fillRectangle: tmp1 color: self color muchLighter darkernewToolSpacer  ^self theme newToolSpacerIn: selfwantsRecolorHandle  ^image notNil and: [ image depth = 1 ]getListItem: arg1  getListElementSelector ifNotNil: [ ^self itemMorphFor: (model perform: getListElementSelector with: arg1) index: arg1 ].  (list notNil and: [ list size >= arg1 ]) ifTrue: [ ^list at: arg1 ].  ^self wrapItem: (self getList at: arg1) index: arg1mouseDown: arg1  self deletenewAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5allNodeMorphs  ^client allNodeMorphsonAnnouncement: arg1 do: arg2  self announcer when: arg1 do: arg2testReset  | tmp1 |  tmp1 := self dataSourceForTesting.  strategy property: #yourself.  self assert: tmp1 elements equals: self elementsForTestDataSource.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy reset.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10)decrement  ^progressBar decrementshouldDropOnMouseUp  | tmp1 |  tmp1 := self formerPosition ifNil: [ ^false ].  ^(tmp1 distanceTo: self position) > 10topLayoutFrame  ^(0 @ 0 corner: 1 @ 0) asLayoutFrame     topLeftOffset: 22 @ -29;     bottomRightOffset: -22 @ (SystemWindow borderWidth - 29)drawOnAthensCanvas: arg1  self drawOnCanvasWrapperFor: arg1getSelectedPathSelector: arg1  getSelectedPathSelector := arg1isAdheringToRight  ^falsefullDrawOn: arg1  super fullDrawOn: arg1.  self theme drawTabGroupFinishingFor: self on: arg1isProportionalLayout  ^trueprintOn: arg1  super printOn: arg1.  arg1 nextPutAll: '('.  arg1     print: self identityHash;     nextPutAll: ')'contents  ^contentssaturation: arg1  | tmp1 |  tmp1 := self selectedColor.  self selectedColor: ((Color h: tmp1 hue s: arg1 / 255 v: tmp1 brightness) alpha: tmp1 alpha)stepTime  ^100selected  ^falseenabled  ^enabledtextSelector: arg1  textSelector := arg1font: arg1  self tabSelectorMorph font: arg1specifyDashedLine  | tmp1 tmp2 |  tmp1 := UIManager default request: 'Enter a dash specification as{ major dash length. minor dash length. minor dash color }The major dash will have the normal border color.A blank response will remove the dash specification.[Note: You may give 5 items as, eg, {10. 5. Color white. 0. 3}where the 4th ityem is zero, and the 5th is the number of pixelsby which the dashes will move in each step of animation]' translated initialAnswer: '{ 10. 5. Color red }'.  tmp1 isEmptyOrNil ifTrue: [ ^self           stopStepping;           dashedBorder: nil ].  tmp2 := [ self class compiler evaluate: tmp1 ] ifError: [ ^self           stopStepping;           dashedBorder: nil ].  (tmp2 first isNumber and: [ tmp2 second isNumber and: [ tmp2 third isColor ] ]) ifFalse: [ ^self           stopStepping;           dashedBorder: nil ].  tmp2 size = 3 ifTrue: [ ^self           stopStepping;           dashedBorder: tmp2 ].  (tmp2 size = 5 and: [ tmp2 fourth isNumber and: [ tmp2 fifth isNumber ] ]) ifTrue: [ ^self           dashedBorder: tmp2;           startStepping ]initialize  super initialize.  progressBar := ProgressBarMorph new.  progressBar hResizing: #spaceFill.  self extent: 200 @ 20.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     cellPositioning: #leftCenter;     cellInset: 3;     listCentering: #center;     hResizing: #spaceFill;     vResizing: #shrinkWrap.  self addMorphBack: progressBar.  self addInterruptionButtondrawOn: arg1  self useSelectionBar ifTrue: [ self paragraph displaySelectionBarOn: arg1 ].  self useExtraSelection ifTrue: [ self paragraph displayExtraSelectionOn: arg1 ].  super drawOn: arg1normalizedY: arg1  ^arg1hasKeymapCategoryNamed: arg1  ^self kmDispatcher targets anySatisfy: [:arg2 |  arg2 category name = arg1 ]discoveredMenuPragmaKeyword  ^self class discoveredMenuPragmaKeywordreset  self state: (FTUnsortedSortingState context: self)dropItemSelector: arg1  dropItemSelector := arg1setNamePropertyTo: arg1  self assureExtension externalName: arg1isWorldMorph  ^trueminimumExtent  | tmp1 |  textStyle ifNil: [ ^9 @ 16 ].  borderWidth ifNil: [ ^9 @ 16 ].  tmp1 := 9 @ (textStyle lineGrid + 2) + (borderWidth * 2).  ^((0 @ 0 extent: tmp1) expandBy: margins) extenthighlightIndex: arg1  self highlightIndexes: {arg1}mouseWheel: arg1  arg1 isUp ifTrue: [ ^scrollBar scrollUp: 3 ].  arg1 isDown ifTrue: [ ^scrollBar scrollDown: 3 ].  arg1 isLeft ifTrue: [ ^hScrollBar scrollLeft: 3 ].  arg1 isRight ifTrue: [ ^hScrollBar scrollRight: 3 ]arguments: arg1  arguments := arg1 asArray copymaybeDoDup: arg1 with: arg2  arg1 hand obtainHalo: self.  ^self doDup: arg1 with: arg2from: arg1 to: arg2 do: arg3  | tmp1 tmp2 |  tmp1 := ((self getSelectionIndexOf: arg1) min: self allNodeMorphs size) max: 1.  tmp2 := ((self getSelectionIndexOf: arg2) min: self allNodeMorphs size) max: 1.  (tmp1 min: tmp2) to: (tmp1 max: tmp2) do: [:arg4 |  arg3 value: (self allNodeMorphs at: arg4) ]allowsRowSelection  ^truesetValue: arg1  | tmp1 |  value := arg1.  self scaledValue: (tmp1 := self scaledValue).  self model ifNotNil: [ self setValueSelector ifNotNil: [:arg2 |  self model perform: arg2 with: tmp1 ] ]handlesMouseOver: arg1  ^truehandleDropMorph: arg1  | tmp1 |  tmp1 := arg1 contents.  (self wantsDroppedMorph: tmp1 event: arg1) ifFalse: [ ^self ].  arg1 wasHandled: true.  self acceptDroppingMorph: tmp1 event: arg1.  tmp1 justDroppedInto: self event: arg1hScrollbarShowAlways  self hScrollbar showAlways.  self updateScrollbarscellInset  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ 0 ] ifNotNil: [ tmp1 cellInset ]hasChildrenSelector  ^hasChildrenSelectorresetHandlerFields  handler := nil.  wasHandled := falseaddHelpHandle: arg1  target balloonText ifNotNil: [ (self addHandle: arg1 on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget) on: #mouseUp send: #deleteBalloon to: innerTarget ]mouseListeners: arg1  mouseListeners := arg1rightOffset  ^rightOffsetdefaultColor  ^Color transparentaboutToBeGrabbedBy: arg1  self formerOwner: owner.  self formerPosition: self position.  ^selfgridVisibleString  ^(self gridVisible ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'show grid when gridding' translateddrawKeyTextOn: arg1  self keyText ifNil: [ ^self ].  self itemShortcut drawOn: arg1aboutToBeGrabbedBy: arg1  slippage := 0 @ 0.  ^super aboutToBeGrabbedBy: arg1pointFromWorld: arg1  ^self point: arg1 from: self worldmouseMove: arg1  | tmp1 |  super mouseMove: arg1.  arg1 redButtonPressed ifFalse: [ ^self ].  tmp1 := arg1 transformedBy: (self transformedFrom: editView) inverseTransformation.  (tmp1 position y between: editView top and: editView bottom) ifFalse: [ self startStepping: #autoScrollView: at: Time millisecondClockValue arguments: (Array with: tmp1) stepTime: 100 ] ifTrue: [ self stopSteppingSelector: #autoScrollView: ]navigateWindowForward  self nextWindow ifNotNil: [:arg1 |  self currentWindow ifNotNil: [:arg2 |  arg2 sendToBack ].        arg1 isCollapsed ifTrue: [ arg1 collapseOrExpand ].        arg1 activate ]initialize  super initialize.  selectedIndex := 0.  self     tabs: OrderedCollection new;     wrapScrolling: false;     visibleTabRange: (1 to: 0);     controls: self newControls;     roundedCorners: #(1 4);     borderWidth: 0;     changeTableLayout;     listDirection: #leftToRight;     cellInset: (self theme tabSelectorCellInsetFor: self)rootItems  ^rootItems ifNil: [ rootItems := (1 to: 1000) collect: [:arg1 |  PersonDataExample firstName: 'Person' , arg1 asString secondName: 'Person' , arg1 asString , ' second name' age: arg1 married: false ] ]updateShowIcon  (self selected not and: [ self width < 100 ]) ifTrue: [ self hideCloseIcon ] ifFalse: [ self showCloseIcon ]mouseUp: arg1  (self containsPoint: arg1 cursorPoint) ifTrue: [ self setSwitchState: oldColor = offColor.        self doButtonAction ] ifFalse: [ self setSwitchState: oldColor = onColor ]acceptDroppingObject: arg1  ^item acceptDroppingObject: arg1updateFromEvent: arg1  | tmp1 |  tmp1 := (arg1 cursorPoint - lastMouse first) x.  (tmp1 > 0 and: [ tmp1 > (rightColumn width - self width - 5) ]) ifTrue: [ tmp1 := rightColumn width - self width - 5 ].  (tmp1 < 0 and: [ tmp1 negated > (leftColumn width - self width - 5) ]) ifTrue: [ tmp1 := (leftColumn width - self width - 5) negated ].  leftColumn column width: (leftColumn column width ifNil: [ leftColumn width ]) + tmp1.  rightColumn column width: (rightColumn column width ifNil: [ rightColumn width ]) - tmp1.  container changedprepareForRotating  ^selfmorphicLayerNumber  ^8arrowForms  arrowForms ifNotNil: [ ^arrowForms ].  arrowForms := Array new.  self hasArrows ifFalse: [ ^arrowForms ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ arrowForms := arrowForms copyWith: (self computeArrowFormAt: vertices last from: self nextToLastPoint) ].  (arrows == #back or: [ arrows == #both ]) ifTrue: [ arrowForms := arrowForms copyWith: (self computeArrowFormAt: vertices first from: self nextToFirstPoint) ].  ^arrowFormsballoonColor  ^balloonColormouseOverBorderStyle  ^self theme controlButtonMouseOverBorderStyleFor: selffirstHand  ^worldState hands firstupdateButtonDown: arg1  self wantsKeyboardFocusOnMouseDown ifTrue: [ self takeKeyboardFocus ].  self updateButton: arg1wantsKeyboardFocusNavigation  ^falsecomputeAltInsetColors  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self color asColor.  tmp2 := Color white.  tmp3 := Color black.  tmp4 := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  tmp4 := tmp4 asInteger.  tmp5 := Array new: tmp4 * 2.  tmp7 := 0.5 / tmp4.  0 to: tmp4 - 1 do: [:arg1 |  tmp6 := false ifTrue: [ 0.5 + (tmp7 * arg1) ] ifFalse: [ 0.5 + (tmp7 * (tmp4 - arg1)) ].        tmp5 at: arg1 + 1 put: (tmp1 mixed: tmp6 with: tmp3).        tmp5 at: tmp5 size - arg1 put: (tmp1 mixed: tmp6 with: tmp2) ].  ^tmp5draggedMorph: arg1  draggedMorph := arg1handlesMouseOverDragging: arg1  ^truenewPluggableDialogWindow: arg1 for: arg2  ^self theme newPluggableDialogWindowIn: self title: arg1 for: arg2headerButton  self header: (MorphTreeColumnButton new           layoutPolicy: RowLayout new;           listDirection: #leftToRight;           wrapCentering: #center;           cellInset: 5 @ 0;           layoutInset: 5 @ 0;           yourself)resetHandlerFields  wasHandled := falserootNodes  | tmp1 |  tmp1 := super rootNodes.  self defaultChunkSize ifNotNil: [ tmp1 size > self defaultChunkSize ifTrue: [ self chunkSize: self defaultChunkSize ] ] ifNil: [ self defaultPageSize ifNotNil: [ tmp1 size > self defaultPageSize ifTrue: [ self pageSize: self defaultPageSize ] ] ].  ^tmp1extent: arg1  bounds extent = arg1 ifTrue: [ ^self ].  super extent: arg1.  self setScrollDeltaskeyUp: arg1  initialize  super initialize.  self layoutInset: (self theme controlButtonLabelInsetFor: self)labelMorph  ^labelMorphinitialize  super initialize.  self form: self defaultImagestringColor  ^self colorshowsAlways  ^self showState == #alwaysnormalBorderStyle  ^self theme controlButtonNormalBorderStyleFor: selfstate  ^statereferencePosition  ^self valueOfProperty: #referencePosition ifAbsent: [ super referencePosition ]getMenu: arg1  ^arg1 not ifTrue: [ editor yellowButtonMenu ] ifFalse: [ editor shiftedYellowButtonMenu ]imageToUse  ^self imageFromName: stategetListSelector: arg1  self dataSource getListSelector: arg1drawWithoutSelectedOn: arg1  arg1 line: self bottomLeft + (0 @ -1) to: self bottomRight + (0 @ -1) width: 1 color: self borderColorfillStyleToUse  ^self isActive ifTrue: [ self activeFillStyle ] ifFalse: [ self inactiveFillStyle ]basicBox  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := 4 * self handleSize.  tmp3 := (self width + self handleSize + 8 max: tmp2) @ (self height + self handleSize + 8 max: tmp2).  tmp1 := Rectangle center: self center extent: tmp3.  tmp4 := self world ifNil: [ target outermostWorldMorph ].  ^tmp4 ifNil: [ tmp1 ] ifNotNil: [ tmp1 intersect: (tmp4 viewBox insetBy: 8 @ 8) ifNone: [ self error: 'should not happen' ] ]inspectInMorphic: arg1  Smalltalk tools inspector inspect: selfselectNext  | tmp1 tmp2 |  tmp1 := tabs indexOf: self selectedTab.  tmp2 := tabs at: tmp1 + 1 ifAbsent: [ ^self ].  tmp2 selected: truedefaultColor  ^Color orangestartDrag: arg1  self eventHandler ifNotNil: [ self eventHandler startDrag: arg1 fromMorph: self ]newButtonLabel: arg1  ^self newButtonLabelFor: nil label: arg1 getEnabled: nilplayRestoreDownSound  self theme windowRestoreDownSound playoffImage: arg1  offImage := arg1.  self invalidRect: self boundsnewSliderFor: arg1 getValue: arg2 setValue: arg3 getEnabled: arg4 help: arg5  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: 0 max: 1 quantum: nil getEnabled: arg4 help: arg5closeAllTabs  toolbar closeAllTabsblinkStart  ^self valueOfProperty: #blinkStart ifAbsent: [ Time millisecondClockValue ]addMorph: arg1  self addMorphFront: arg1isStayUpItem  ^selector == #toggleStayUp:displayBlock  ^displayBlockhUnadjustedScrollRange  | tmp1 tmp2 tmp3 |  maxWidth ifNotNil: [ ^maxWidth ].  listItems isEmpty ifTrue: [ ^0 ].  tmp1 := 30 min: listItems size.  maxWidth := 0.  tmp3 := 1.  [ tmp3 < tmp1 ] whileTrue: [ tmp2 := self getListItem: tmp3.        maxWidth := maxWidth max: (tmp2 widthToDisplayInList: self).        tmp3 := tmp3 + 1 ].  tmp1 < listItems size ifTrue: [ maxWidth := maxWidth * 2 ].  ^maxWidthdrawIconOn: arg1  | tmp1 |  self hasIcon ifFalse: [ ^self ].  tmp1 := self iconForm.  arg1 translucentImage: tmp1 at: bounds left @ (self top + ((self height - tmp1 height) // 2))menuColumn: arg1 row: arg2  menuBlock ifNil: [ ^nil ].  arg2 = 0 ifTrue: [ ^nil ].  ^menuBlock value: (self elementAt: arg2)keyboardFocusOnMouseDown  ^self class keyboardFocusOnMouseDownchangeShadowColor  (UIManager default chooseColor: self shadowColor) ifNotNil: [:arg1 |  self shadowColor: arg1 ]containsPoint: arg1  | tmp1 tmp2 tmp3 tmp4 |  (bounds containsPoint: arg1) ifFalse: [ ^false ].  (bounds width = 1 or: [ bounds height = 1 ]) ifTrue: [ ^true ].  tmp1 := bounds height asFloat / 2.  tmp2 := bounds width asFloat / 2.  tmp3 := arg1 - bounds topLeft - (tmp2 @ tmp1).  tmp4 := bounds width asFloat / bounds height asFloat.  ^(tmp3 x asFloat / tmp4) squared + tmp3 y squared <= tmp1 squaredacceptDroppingMorph: arg1 event: arg2  self dataSource dropElements: arg1 passenger index: ((self container rowIndexContainingPoint: arg2 position) ifNil: [ 0 ]).  self basicHighlightIndexes: #().  self refreshrealElementAt: arg1  ^self elementAt: arg1fullscreenChanged: arg1  self currentWorld worldState worldRenderer fullscreenMode: arg1 fullscreenhandleWindowEvent: arg1  arg1 wasHandled ifTrue: [ ^self ].  (self wantsWindowEvent: arg1) ifFalse: [ ^self ].  arg1 wasHandled: true.  self windowEvent: arg1selected: arg1  oldPosition  ^oldPositiondescending  ^descending == truelayoutChanged  (self owner isNil or: [ self owner isWorldMorph not ]) ifTrue: [ ^super layoutChanged ].  fullBounds := nil.  self layoutPolicy ifNotNil: [:arg1 |  arg1 flushLayoutCache ]handlesMouseOver: arg1  ^trueitem: arg1  | tmp1 tmp2 |  (arg1 between: 1 and: listItems size) ifFalse: [ ^self getListItem: arg1 ].  (listItems at: arg1) ifNil: [ tmp1 := self getListItem: arg1.        maxWidth ifNotNil: [ tmp2 := tmp1 widthToDisplayInList: self.              tmp2 > maxWidth ifTrue: [ maxWidth := tmp2.                    self adjustWidth ] ].        listItems at: arg1 put: tmp1 ].  ^listItems at: arg1spaceFillWeight  ^self valueOfProperty: #spaceFillWeight ifAbsent: [ 1 ]leftOffset: arg1  leftOffset := arg1cellInset: arg1  self assureTableProperties cellInset: arg1.  self layoutChangedwrapDirectionString: arg1  ^self layoutMenuPropertyString: arg1 from: self wrapDirectionwithSearch: arg1  withSearch := arg1.  self buildPanelrootItems  ^OrderedCollection with: self rootClassnewCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 getLabel: arg5 help: arg6  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 getLabel: arg5 help: arg6initialize  super initialize.  lock := Semaphore forMutualExclusion.  lastRefresh := 0.  self     setDefaultParameters;     setProperty: #morphicLayerNumber toValue: self morphicLayerNumber;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #topCenter;     cellInset: 5;     listCentering: #center;     hResizing: #rigid;     vResizing: #shrinkWrap;     layoutInset: 10 @ 6;     minWidth: 150newRow  ^self theme newRowIn: self for: #()sentTo: arg1  type == #mouseWheel ifTrue: [ ^arg1 handleMouseWheel: self ].  ^super sentTo: arg1initialize  super initialize.  self     borderWidth: 0;     changeTableLayout;     cellInset: 4;     listDirection: #leftToRight;     cellPositioning: #topLeft;     svMorph: self newSVColorMorph;     hMorph: self newHColorMorph;     addMorphBack: self svMorph;     addMorphBack: self hMorph;     extent: 192 @ 152;     hue: 0.5itemWithWording: arg1  (self contents asString sameAs: arg1) ifTrue: [ ^self ].  subMenu ifNotNil: [ ^subMenu itemWithWording: arg1 ].  ^nilnewCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6raisedColor  ^self paneColor raisedColormaybeAddCollapseItemTo: arg1  | tmp1 |  (tmp1 := self topRendererOrSelf owner) ifNotNil: [ tmp1 isWorldMorph ifTrue: [ arg1 add: 'collapse' target: self selector: #collapse ] ]font: arg1  self listMorph font: arg1fullscreen  self bounds: self fullscreenBoundsdefaultBackgroundColor  ^Color graydoOneCycleNow  worldState doOneCycleNowFor: selfreverseTableCells  ^falseposition: arg1  | tmp1 |  isCollapsed ifTrue: [ tmp1 := collapsedFrame origin ] ifFalse: [ tmp1 := fullFrame origin ].  super position: arg1.  isCollapsed ifTrue: [ collapsedFrame := self bounds ] ifFalse: [ fullFrame := self bounds ].  tmp1 ~= arg1 ifTrue: [ self announce: (WindowMoved new                 oldPosition: tmp1;                 newPosition: arg1;                 window: self) ]unrotatedWidth: arg1  self borderWidth: arg1indexFromPosition: arg1  ^self subclassResponsibilitydrawText: arg1 on: arg2 in: arg3 color: arg4  (self enabled not and: [ self theme disabledItemStyle = #inset ]) ifTrue: [ arg2           drawString: arg1 in: arg3 font: self fontToUse color: arg4 muchLighter lighter;           drawString: arg1 in: (arg3 translateBy: -1) font: self fontToUse color: arg4 ] ifFalse: [ arg2 drawString: arg1 in: arg3 font: self fontToUse color: arg4 ]resizeAllSubviews  self resizeVerticalScrollBar.  horizontalScrollBar ifNotNil: [ self resizeHorizontalScrollBar ].  self recalculateVerticalScrollBar.  self resizeContainer.  self container setNeedsRefreshExposedRows.  self container updateExposedRows.  self verticalScrollBar value: (self rowIndexToVerticalScrollBarValue: showIndex).  function isExplicit ifTrue: [ function resizeWidget ]buildRowMorphsFromIndex: arg1 to: arg2  | tmp1 tmp2 |  tmp2 := self allNodeMorphs.  tmp1 := self rowMorphsWidths.  arg1 to: arg2 do: [:arg3 |  (tmp2 at: arg3)           buildRowMorph;           updateColumnMorphsWidthWith: tmp1 ].  self setScrollDeltas.  self adjustSubmorphPositionsFrom: arg1 to: arg2.  self setScrollDeltas.  arg1 to: arg2 do: [:arg4 |  (tmp2 at: arg4) drawable: true ]handleKeyDown: arg1  ^self dispatchDefault: arg1 with: morphseparatorBlockOrSelector  ^separatorBlockOrSelectorremovedMorph: arg1  resetTimer  timeOfMouseDown := Time millisecondClockValue.  timeOfLastScroll := timeOfMouseDown - 1000 max: 0.  nextPageDirection := nil.  currentScrollDelay := nilpassiveEnabledOverUpFillStyle: arg1  self stateMap atPath: #(passive enabled over up) put: arg1.  self changedmanageCursor  (paragraph isNil or: [ paragraph focused not ]) ifTrue: [ ^self           resetBlinkCursor;           stopBlinking ].  TextEditor blinkingCursor ifTrue: [ self startBlinking ] ifFalse: [ self ensureCursor ]newLabelGroup: arg1 font: arg2 labelColor: arg3  ^self theme newLabelGroupIn: self for: arg1 font: arg2 labelColor: arg3performAction: arg1  enabled ifFalse: [ ^self ].  askBeforeChanging ifTrue: [ model okToChange ifFalse: [ ^self ] ].  self pressed: self isPressed not.  self actionBlock ifNotNil: [ ^self actionBlock cull: self isPressed cull: arg1 ].  actionSelector ifNil: [ ^self ].  arguments := argumentsProvider ifNotNil: [ argumentsProvider perform: argumentsSelector ] ifNil: [ #() ].  model perform: actionSelector withArguments: (arguments copyWithFirst: self isPressed)tabEmptyContents: arg1  contentsWrapper removeAllMorphsbeRowNotHomogeneous  | tmp1 |  tmp1 := container.  container := FTTableContainerRowNotHomogeneousMorph new.  self replaceSubmorph: tmp1 by: container.  self resizeAllSubviewswantsGrips  ^self isResizeableprepareForRotating  ^self addFlexShellsearchText: arg1  | tmp1 tmp2 |  arg1 isEmptyOrNil ifTrue: [ ^#() ].  tmp1 := 0.  tmp2 := OrderedCollection new.  self items do: [:arg2 |  arg2 do: [:arg3 |  tmp1 := tmp1 + 1.              ((self toString: arg3) beginsWith: arg1) ifTrue: [ tmp2 add: tmp1 ] ] ].  ^tmp2 asArraywithoutListWrapper  ^item withoutListWrapperacceptContents  self updateFromParagraph.  editView accepttopVisibleRowForCanvas: arg1  ^self rowAtLocation: arg1 clipRect topLeftsmoothing: arg1  smoothing := arg1.  self changedrecentlyChanged  self subclassResponsibilityadoptPaneColor: arg1  super adoptPaneColor: arg1.  self borderStyle baseColor: arg1 twiceDarkerhandleSize  ^20max  ^maxstopSteppingSelector: arg1  | tmp1 |  tmp1 := self world.  tmp1 ifNotNil: [ tmp1 stopStepping: self selector: arg1 ]handlesMouseDown: arg1  ^trueborders  ^bordersmenu: arg1  self dataSource menu: arg1helpText: arg1  self setBalloonText: arg1newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7  ^self theme newMorphDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7basicActivate  | tmp1 |  tmp1 := self topRendererOrSelf.  tmp1 owner ifNil: [ ^self ].  self isTopWindow ifTrue: [ ^self ].  self beTopWindow.  tmp1 owner firstSubmorph == tmp1 ifFalse: [ tmp1 owner addMorphFront: tmp1 ].  self submorphsDo: [:arg1 |  arg1 unlock ].  labelArea ifNotNil: [ labelArea submorphsDo: [:arg1 |  arg1 unlock ].        self setStripeColorsFrom: self paneColorToUse ].  self isCollapsed ifFalse: [ model modelWakeUpIn: self.        self positionSubmorphs.        labelArea ifNil: [ self adjustBorderUponActivationWhenLabeless ] ].  self     privateFullBounds: nil;     changedbeUnresizeable  isResizeable := false.  self isResizeable ifFalse: [ self removeGrips ]okayToResizeEasily  ^truesimulateKeyStrokes: arg1  arg1 do: [:arg2 |  self simulateKeyStroke: arg2 ]popUpInWorld: arg1  ^self popUpAt: arg1 primaryHand position forHand: arg1 primaryHand in: arg1setActionsFrom: arg1  self actions: arg1 valuerootNodeClassFromItem: arg1  ^ClassTreeNodeExamplenewBalloonHelp: arg1 for: arg2 corner: arg3  ^self theme newBalloonHelpIn: self contents: arg1 for: arg2 corner: arg3borderColor: arg1  | tmp1 tmp2 |  tmp1 := self borderStyle.  tmp1 baseColor = arg1 ifTrue: [ ^self ].  arg1 isColor ifTrue: [ tmp1 style = #none ifTrue: [ self borderStyle: (SimpleBorder width: 0 color: arg1) ] ifFalse: [ tmp1 baseColor: arg1.              self changed ].        ^self ].  self borderStyle: (({nil .         #none} includes: arg1) ifTrue: [ BorderStyle default ] ifFalse: [ self doesBevels ifFalse: [ ^self ].              tmp2 := (BorderStyle perform: arg1)                 color: tmp1 color;                 width: tmp1 width;                 yourself.              (self canDrawBorder: tmp2) ifTrue: [ tmp2 ] ifFalse: [ tmp1 ] ])defaultImage  ^DefaultImage ifNil: [ DefaultImage := DefaultForm asFormOfDepth: 32 ]client: arg1  client := arg1reposition  | tmp1 tmp2 tmp3 |  tmp3 := 20.  tmp1 := Display boundingBox width - self fullBounds width - (2 * tmp3).  tmp1 := tmp1 * self class horizontalPosition + tmp3.  tmp2 := Display boundingBox height - self fullBounds height - (2 * tmp3).  tmp2 := tmp2 * self class verticalPosition + tmp3.  self align: self fullBounds topLeft with: Display boundingBox topLeft + (tmp1 @ tmp2).  self refreshlarge  ^55rowHeight: arg1 default: arg2  ^arg2rectangle: arg1  left := arg1 left.  right := arg1 right.  top := arg1 top.  bottom := arg1 bottomisEnabled  | tmp1 |  self enablementSelector ifNil: [ ^super isEnabled ].  tmp1 := self enablementSelector isSymbol ifTrue: [ self target perform: self enablementSelector ] ifFalse: [ self enablementSelector value ].  self isEnabled: tmp1.  ^tmp1glmAnimateValue: arg1 duration: arg2  arg2 <= 0 ifTrue: [ self setValue: arg1 ] ifFalse: [ | tmp1 tmp2 tmp3 |        tmp1 := Time millisecondClockValue.        tmp2 := value.        [ | tmp4 |        [ (tmp4 := Time millisecondClockValue - tmp1) < arg2 ] whileTrue: [ self setValue: (arg1 - tmp2) * (tmp4 / arg2) + tmp2.              Processor yield ].        self setValue: arg1 ] fork ]handleColorAt: arg1  ^Color yellowexportAsPNG  self exportAs: 'png' using: PNGReadWritergrabMorph: arg1  | tmp1 |  arg1 = self currentWorld ifTrue: [ ^self ].  self releaseMouseFocus.  tmp1 := arg1 aboutToBeGrabbedBy: self.  tmp1 ifNil: [ ^self ].  tmp1 := tmp1 topRendererOrSelf.  ^self grabMorph: tmp1 from: tmp1 ownerdrawSubmenuMarkerOn: arg1  drawOn: arg1  listItems isEmpty ifTrue: [ ^self ].  arg1 fillRectangle: arg1 clipRect color: (self theme listNormalFillStyleFor: self).  (self topVisibleRowForCanvas: arg1) to: (self bottomVisibleRowForCanvas: arg1) do: [:arg2 |  (listSource itemSelectedAmongMultiple: arg2) ifTrue: [ self drawBackgroundForSelectedRow: arg2 on: arg1 ] ifFalse: [ listSource searchedElement = arg2 ifTrue: [ self drawBackgroundForSearchedRow: arg2 on: arg1 ] ifFalse: [ (listSource backgroundColorFor: arg2) ifNotNil: [:arg3 |  self drawBackgroundForRow: arg2 on: arg1 color: arg3 ] ] ].        selectedRow = arg2 ifTrue: [ self drawSelectionOn: arg1 ].        (listSource separatorAfterARow: arg2) ifTrue: [ self drawSeparatorAfter: arg2 on: arg1 ].        self display: (self item: arg2) atRow: arg2 on: arg1 ].  listSource potentialDropRow > 0 ifTrue: [ self highlightPotentialDropRow: listSource potentialDropRow on: arg1 ]calculateStartIndexWhenShowing: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self table showIndex.  tmp1 + arg1 - 1 > self table numberOfRows ifTrue: [ tmp1 := self table numberOfRows - arg1 + 2 ].  tmp2 := tmp1 max: 1.  tmp3 := self table showIndex.  self table basicMoveShowIndexTo: tmp2.  self table announceScrollChangedFrom: tmp3 to: self table showIndex.  ^tmp2initialize  super initialize.  self borderStyle: (self theme taskbarItemNormalBorderStyleFor: self)disableDragNDrop  self enableDragNDrop: falsetextEntry: arg1  ^self textEntry: arg1 title: 'Entry' translatedshowSelectionFeedback: arg1  showSelectionFeedback := arg1currentPageToString  ^self currentPage asStringvScrollbarShowAlways  self vScrollbar showAlways.  self updateScrollbarsnewTextMorph  ^StringMorph contents: ''closeAllUnchangedWindows  (self windowsSatisfying: [:arg1 |  arg1 model canDiscardEdits ]) do: [:arg1 |  arg1 delete ]numSelectionsInView  ^client numSelectionsInViewnewTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6defaultColor  ^self theme menubarFillStyleFor: selfstateMap: arg1  stateMap := arg1margins: arg1  margins := arg1 asMargin.  self composeToBoundshandleMouseLeave: arg1  ^self dispatchDefault: arg1 with: morphbottomVisibleRowForCanvas: arg1  ^self rowAtLocation: arg1 clipRect bottomLeftaddWorldHaloMenuItemsTo: arg1 hand: arg2  self addFillStyleMenuItems: arg1 hand: arg2.  self addLayoutMenuItems: arg1 hand: arg2.  arg1 addLine.  self addWorldToggleItemsToHaloMenu: arg1.  arg1 addLine.  self addExportMenuItems: arg1 hand: arg2.  self addMiscExtrasTo: arg1.  self addDebuggingItemsTo: arg1 hand: arg2.  arg1 addLine.  arg1 defaultTarget: arg2hasClipSubmorphsString  ^self clipSubmorphs -> 'provide clipping' translatedscrollValue: arg1  self     hScrollValue: arg1 x;     vScrollValue: arg1 yhideVScrollBarIndefinitely: arg1  self setProperty: #noVScrollBarPlease toValue: arg1.  self vHideOrShowScrollBarfillStyle: arg1  undoProperties ifNil: [ undoProperties := selectedItems collect: [:arg2 |  arg2 fillStyle ] ].  selectedItems do: [:arg2 |  arg2 fillStyle: arg1 ]question: arg1  ^self question: arg1 title: 'Question' translatedvalue: arg1  value := arg1 min: 1.0 max: 0.0.  self computeSliderkeyStroke: arg1  (self localHandleKeystroke: arg1) ifTrue: [ ^self ].  (self maxLength isNil or: [ self text size < self maxLength or: [ self editor selectionInterval size > 0 or: [ self isEditEvent: arg1 ] ] ]) ifTrue: [ self doAutoAccept: arg1 ].  super keyStroke: arg1preferredCornerStyle  ^self theme dialogWindowPreferredCornerStyleFor: selfmouseDown: arg1  | tmp1 tmp2 |  tmp2 := self rowAtLocation: arg1 position.  arg1 yellowButtonPressed ifTrue: [ self isMultipleSelection ifTrue: [ arg1 commandKeyPressed ifFalse: [ (self yellowButtonActivity: arg1 shiftPressed) ifTrue: [ ^super mouseDown: arg1 ] ] ] ifFalse: [ (self yellowButtonActivity: arg1 shiftPressed) ifTrue: [ ^super mouseDown: arg1 ] ] ].  self enabled ifFalse: [ ^super mouseDown: arg1 ].  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ].  tmp2 := self rowAtLocation: arg1 position.  tmp2 = 0 ifTrue: [ ^super mouseDown: arg1 ].  self mouseDownRow: tmp2.  self isMultipleSelection ifTrue: [ self mouseDownOnMultiple: arg1 forRow: tmp2 ].  tmp1 := Array with: #click: with: (doubleClickSelector ifNotNil: [ #doubleClick: ]) with: nil with: (self dragEnabled ifTrue: [ #startDrag: ] ifFalse: [ nil ]).  arg1 hand waitForClicksOrDrag: self event: arg1 selectors: tmp1 threshold: 10.  super mouseDown: arg1backgroundColor  ^Smalltalk ui theme darkBaseColorchangeOpacity  self isOpaque: self isOpaque notmouseDownHighlightColor  | tmp1 tmp2 |  tmp1 := self lineColor.  tmp1 isTransparent ifFalse: [ ^tmp1 ].  tmp2 := self color isTransparent ifTrue: [ self firstOwnerSuchThat: [:arg1 |  arg1 isWorldOrHandMorph not and: [ arg1 color isTransparent not ] ] ] ifFalse: [ self ].  tmp2 ifNil: [ ^Color black ].  ^tmp2 color luminance > 0.5 ifTrue: [ Color black ] ifFalse: [ Color white ]selected  ^selected ifNil: [ selected := 1 ]originMenuColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := (self elementAt: arg2) method.  tmp2 := UIManager default newMenuIn: self table for: self.  tmp2 add: 'Browse ' , tmp1 methodClass name target: tmp1 methodClass selector: #browse.  ^tmp2handlesMouseDown: arg1  ^truewidthForRounding  ^self widthmouseUp: arg1  scroller hasSubmorphs ifTrue: [ scroller submorphs last mouseUp: (arg1 transformedBy: (scroller transformFrom: self)) ]modalSelection  ^self valueOfProperty: #modalSelection ifAbsent: [ nil ]selectedColor: arg1  self aMorph value: arg1 alpha.  self hsvMorph selectedColor: arg1 beOpaquecurrentPage: arg1  arg1 = self currentPage ifTrue: [ ^self ].  arg1 = 1 ifTrue: [ self setPageInterval: (1 to: (pageSize min: self nodeList size)) ] ifFalse: [ | tmp1 |        tmp1 := arg1 * pageSize.        tmp1 <= self nodeList size ifTrue: [ self setPageInterval: ((tmp1 - pageSize + 1 max: 1) to: tmp1) ] ifFalse: [ self setPageInterval: ((self lastPage - 1) * pageSize + 1 to: self nodeList size) ] ]allMorphs  | tmp1 |  tmp1 := (Array new: submorphs size) writeStream.  self allMorphsDo: [:arg1 |  tmp1 nextPut: arg1 ].  ^tmp1 contentstextMorph: arg1  textMorph := arg1handlesMouseDown: arg1  ^trueselectedColor  ^self theme selectionColoryellowButtonActivity: arg1  ^falseflash  (self hasProperty: #activeModalFlash) ifTrue: [ ^self ].  self setProperty: #activeModalFlash toValue: true.  [ | tmp1 tmp2 tmp3 |  tmp1 := self fillStyle.  tmp2 := self color alphaMixed: 0.5 with: Color white.  tmp3 := 0.  2 timesRepeat: [ tmp3 milliSeconds asDuration wait.        tmp3 := 200.        self color: tmp2.        tmp3 milliSeconds asDuration wait.        self color = tmp2 ifFalse: [ tmp1 := self fillStyle ].        self fillStyle: tmp1 ].  self removeProperty: #activeModalFlash ] forkmustTakeIntoAccountCheckSpace  ^container listManager isCheckListstep  (self hasProperty: #doesButtonAction) ifTrue: [ self doButtonAction.        self setProperty: #didButtonAction toValue: true ]isSelectedMatchingTheState: arg1  ^arg1minimizeAfterGeneratingThumbnail  self isMinimized ifTrue: [ ^self ].  isCollapsed := true.  paneMorphs do: [:arg1 |  arg1           delete;           releaseCachedState ].  self setBoundsWithFlex: (-10 @ -10 extent: 2 @ 2).  self hide.  self layoutChangedresistsRemoval: arg1  arg1 ifTrue: [ self setProperty: #resistsRemoval toValue: true ] ifFalse: [ self removeProperty: #resistsRemoval ]themeChanged  self fillStyle: (self theme morphTreeColumnFillStyleFor: self).  self borderStyle: (self theme morphTreeColumnBorderStyleFor: self).  super themeChangedtrimSize  ^trimSize ifNil: [ trimSize := 0 ]rotationDegrees  ^self angle radiansToDegrees negateddisplayAt: arg1 during: arg2  self currentWorld addMorph: self centeredNear: arg1.  self world displayWorld.  arg2 value.  self deletenewImageMorph  ^AlphaImageMorph new     borderStyle: (BorderStyle inset width: 1);     color: Color white;     alpha: 1.0for: arg1 minWidth: arg2  textMorph := arg1.  minWidth := arg2.  fillsOwner := true.  avoidsOcclusions := falseupdateIcon  target ifNotNil: [ self icon: (target perform: iconSelector) ]selectFrom: arg1 to: arg2  self editor selectFrom: arg1 to: arg2chooseDirectory: arg1 path: arg2  ^self theme chooseDirectoryIn: self title: arg1 path: arg2rowIndexFrom: arg1  ^self subclassResponsibilityanimateMaximize  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self fullscreenBounds.  tmp2 := self bounds.  tmp4 := self theme numberOfStepsForAnimations.  tmp3 := (1 / tmp4 to: 1 by: 1 / tmp4) collect: [:arg1 |  tmp2 interpolateTo: tmp1 at: ((20 raisedTo: arg1) - 1) / 19 ].  self fastAnimateRectangles: tmp3iconSelector: arg1  iconSelector := arg1.  self updateIcontextColor  ^textColorsetAsColumn  self     listDirection: #topToBottom;     hResizing: #spaceFill;     extent: 1 @ 1;     vResizing: #spaceFillfillsOwner: arg1  fillsOwner := arg1.  self updateLayoutPropertiesexpandAllTo: arg1  self roots do: [:arg2 |  self expand: arg2 to: arg1 ].  self innerWidgetChangednextMorphInWindow  ^self hasSubmorphs ifTrue: [ self submorphs first ]processEvent: arg1 using: arg2  (self rejectsEvent: arg1) ifTrue: [ ^#rejected ].  ^arg2 dispatchEvent: arg1 with: selfcomputeNextToEndPoints  | tmp1 tmp2 |  tmp1 := nil.  self lineSegmentsDo: [:arg1 :arg2 |  tmp1 ifNil: [ tmp1 := arg2 asIntegerPoint ].        tmp2 := arg1 asIntegerPoint ].  curveState at: 2 put: tmp1.  curveState at: 3 put: tmp2referencePositionInWorld: arg1  | tmp1 |  tmp1 := owner ifNil: [ arg1 ] ifNotNil: [ (owner transformFrom: self world) globalPointToLocal: arg1 ].  self referencePosition: tmp1frameRectangle: arg1 on: arg2  (arg1 width < self width or: [ arg1 height < self width ]) ifTrue: [ ^self ].  arg2 frameRectangle: arg1 width: self width colors: self dashColors dashes: self dashLengthshandlesMouseOver: arg1  ^self enabledselectionStrategy  ^selectionStrategykeyStroke: arg1 from: arg2  autoMultiSelection: arg1  autoMultiSelection := arg1selectedRowIndex  self deprecated: 'Use #selectedIndex instead' transformWith: '`@receiver selectedRowIndex' -> '`@receiver selectedIndex'.  ^self selectedIndexfont  ^self tabSelectorMorph fontbuildVerticesFrom: arg1  ^arg1mainDockingBars  ^self dockingBars select: [:arg1 |  arg1 hasProperty: #mainDockingBarTimeStamp ]delete  accepted ifFalse: [ self dropNotifyRecipient ifNotNil: [ self dropNotifyRecipient dropRejectedMorph: self ] ].  self changed: #deleted.  self breakDependents.  super deleteicon  ^icontoggleEnabled  self enabled: self enabled notgetListSize  ^listSource ifNil: [ 0 ] ifNotNil: [:arg1 |  arg1 getListSize ]expandToDepth: arg1  depth = arg1 ifTrue: [ ^self ].  self expandItem.  children do: [:arg2 |  arg2 expandToDepth: arg1 ]cornerRadius: arg1  cornerRadius := arg1startRot: arg1 with: arg2  self obtainHaloForEvent: arg1 andRemoveAllHandlesBut: arg2.  target prepareForRotating.  growingOrRotating := true.  angleOffset := arg1 cursorPoint - (target pointInWorld: target referencePosition).  angleOffset := Point r: angleOffset r degrees: angleOffset degrees - target rotationDegreespopUpAt: arg1 forHand: arg2 in: arg3  ^self popUpAt: arg1 forHand: arg2 in: arg3 allowKeyboard: self menuKeyboardControlsimplySetVisible: arg1  self visible: arg1selected: arg1  selected = arg1 ifTrue: [ ^self ].  container ifNil: [ ^self ].  arg1 ifTrue: [ container selectedMorphList add: self ] ifFalse: [ selected ifNotNil: [ container selectedMorphList remove: self ] ].  selected := arg1.  self complexContents selected: arg1addSplitterOn: arg1 delta: arg2  | tmp1 tmp2 |  arg1 overlappingPairsWithIndexDo: [:arg3 :arg4 :arg5 |  tmp1 := arg3 retrieveMorph: [:arg6 |  arg6 ifNil: [ TabWithNoContents signalTab: arg3 ].              tmp2 := arg4 retrieveMorph: [:arg7 |  | tmp3 |                    arg7 ifNil: [ TabWithNoContents signalTab: arg4 ].                    tmp3 := ProportionalSplitterMorph new                       addLeftOrTop: arg6;                       addRightOrBottom: arg7;                       yourself.                    contentsWrapper addMorph: tmp3 fullFrame: (LayoutFrame identity                             leftFraction: arg5 * arg2;                             rightFraction: arg5 * arg2;                             leftOffset: -2;                             rightOffset: 2) ] ] ].  tmp1 ifNotNil: [ processes add: tmp1 ].  tmp2 ifNotNil: [ processes add: tmp2 ]handleAsMouseOver: arg1  arg1 hand handleEvent: arg1 asMouseOveronColor  ^onColortestIntoWorldCollapseOutOfWorld  | tmp1 tmp2 tmp3 |  tmp1 := TestInWorldMorph new.  tmp2 := TestInWorldMorph new.  self assert: tmp1 intoWorldCount equals: 0.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 0.  self assert: tmp2 outOfWorldCount equals: 0.  morph addMorphFront: tmp1.  tmp1 addMorphFront: tmp2.  self assert: tmp1 intoWorldCount equals: 0.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 0.  self assert: tmp2 outOfWorldCount equals: 0.  morph openInWorld.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 0.  tmp3 := CollapsedMorph new beReplacementFor: morph.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 1.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 1.  tmp3 collapseOrExpand.  self assert: tmp1 intoWorldCount equals: 2.  self assert: tmp1 outOfWorldCount equals: 1.  self assert: tmp2 intoWorldCount equals: 2.  self assert: tmp2 outOfWorldCount equals: 1.  morph delete.  self assert: tmp1 intoWorldCount equals: 2.  self assert: tmp1 outOfWorldCount equals: 2.  self assert: tmp2 intoWorldCount equals: 2.  self assert: tmp2 outOfWorldCount equals: 2updateFillStyle  | tmp1 tmp2 |  tmp2 := self fillStyle.  tmp2 isOrientedFill ifTrue: [ tmp1 := self innerBounds.        tmp2 origin: tmp1 topLeft.        tmp2 direction: (tmp1 isWide ifTrue: [ tmp1 width @ 0 ] ifFalse: [ 0 @ tmp1 height ]) ]isCheckList: arg1  isCheckList := arg1drawClippedBorderOn: arg1 usingEnds: arg2  arg1 clipBy: self bounds during: [:arg3 |  self drawBorderOn: arg3 usingEnds: arg2 ]handlesMouseOver: arg1  ^trueisLineMorph  ^falsecreateCloseBox  ^self theme createCloseBoxFor: selfenableSearch  function := FTSearchFunction table: selfinitialize  super initialize.  nextPageAllowed := trueupdateLastClickedMorph  lastClickedMorph ifNil: [ lastClickedMorph := self selectedMorphList ifEmpty: [  ] ifNotEmpty: [ self selectedMorphList last ] ] ifNotNil: [ self allNodeMorphs do: [:arg1 |  arg1 complexContents withoutListWrapper = lastClickedMorph complexContents withoutListWrapper ifTrue: [ lastClickedMorph := arg1 ] ] ]drawOnAthensCanvas: arg1  | tmp1 tmp2 |  tmp1 := arg1 cacheAt: image ifAbsentPut: [ image asAthensPaintOn: arg1 ].  arg1 setPaint: tmp1.  arg1 paintTransform restoreAfter: [ arg1 paintTransform translateBy: self innerBounds origin.        arg1 drawShape: self innerBounds ].  (tmp2 := self borderStyle) ifNotNil: [ arg1 setStrokePaint: tmp2.        arg1 drawShape: bounds ]rightOrBottomVertices: arg1  ^self orientation == #vertical ifTrue: [ {(arg1 topRight - (0 @ 1)) .         ((arg1 right - (arg1 height // 2 + (arg1 height \\ 2))) @ (arg1 center y - ((arg1 height + 1) \\ 2))) .         ((arg1 right - (arg1 height // 2 + (arg1 height \\ 2))) @ arg1 center y) .         arg1 bottomRight} ] ifFalse: [ {(arg1 center x @ (arg1 bottom - 1 - (arg1 width // 2 + (arg1 width \\ 2)))) .         (arg1 center x @ (arg1 bottom - 1 - (arg1 width // 2 + (arg1 width \\ 2)))) .         arg1 bottomRight .         (arg1 bottomLeft - (1 @ 0))} ]goBehind  max: arg1  max := arg1.  self setValue: self valuepagingArea  ^selfbasicKeyPressed: arg1  ^arg1 == Character space ifTrue: [ self interactWithSelectedItem ] ifFalse: [ super basicKeyPressed: arg1 ]keyStrokeSearch: arg1  ^function keyStroke: arg1defaultColor  ^self theme backgroundColorhideColumnHeaders  showColumnHeaders ifFalse: [ ^self ].  showColumnHeaders := false.  self refreshalphaSelected: arg1  self triggerSelectedColorhSpaceFill: arg1  flags := arg1 ifTrue: [ self flags bitOr: 1 ] ifFalse: [ self flags bitClear: 1 ]vIsScrolled  ^scroller offset y > 0refreshExtraSelection  | tmp1 |  tmp1 := self useSelectionBar.  self useFindReplaceSelection ifTrue: [ tmp1 := true.        self findText isEmpty ifTrue: [ self paragraph findReplaceSelectionRegex: nil ] ifFalse: [ self paragraph findReplaceSelectionRegex: self findRegex ] ].  self useSecondarySelection ifTrue: [ tmp1 := true.        (self paragraph secondarySelection isNil and: [ self selection isEmptyOrNil not ]) ifTrue: [ self paragraph secondarySelection: (self text asString allRangesOfSubstring: self selection asString) ] ].  tmp1 ifTrue: [ self paragraph extraSelectionChanged.        self invalidRect: self bounds ]complexElementsForTestDataSource  ^#(3 80 29 10 20 28 70)isAnimated  borderDashSpec ifNil: [ ^false ].  ^borderDashSpec size = 5 and: [ borderDashSpec fifth > 0 ]removeLink: arg1  self eventHandler ifNotNil: [ self eventHandler on: arg1 send: nil to: nil ]editorClass  ^TextEditoractive: arg1  active := arg1.  self changedstartDrag: arg1  self editView startDrag: arg1selectableIndexContainingPoint: arg1  ^self subclassResponsibilityselectionChangedUpdateStatus: arg1  self setSelectionListSelector ifNil: [ ^self ].  arg1 oldSelectedIndexes do: [:arg2 |  self model perform: self setSelectionListSelector with: arg2 with: false ].  arg1 newSelectedIndexes do: [:arg2 |  self model perform: self setSelectionListSelector with: arg2 with: true ]basicExtent: arg1  ^super extent: arg1newNoButton  ^self newNoButtonFor: selftaskThumbnailOfSize: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self bounds scaledAndCenteredIn: (0 @ 0 extent: arg1).  tmp1 := Form extent: tmp3 extent depth: Display depth.  tmp2 := MatrixTransform2x3 withScale: tmp1 extent / self extent.  tmp1 getCanvas transformBy: tmp2 clippingTo: tmp1 boundingBox during: [:arg2 |  arg2 translateBy: self topLeft negated during: [:arg3 |  self fullDrawOn: arg3 ] ] smoothing: 2.  ^ImageMorph new form: tmp1release  lineColorBlock := nil.  columnResizers := nil.  preferedPaneColor := nil.  expandedToggleImage := nil.  notExpandedToggleImage := nil.  columns ifNotNil: [ columns do: [:arg1 |  arg1 release ].        columns := nil ].  listManager ifNotNil: [ listManager release.        listManager := nil ].  self releaseActionMap.  super releasemodel  ^modelexpand: arg1 to: arg2  | tmp1 |  arg1 toggleExpandedState.  tmp1 := OrderedCollection new: 10.  arg1 recursiveAddTo: tmp1.  tmp1 do: [:arg3 |  ((arg3 canExpand and: [ arg3 isExpanded not ]) and: [ arg2 > 0 ]) ifTrue: [ self expand: arg3 to: arg2 - 1 ] ]calendar  ^calendarselectionColor: arg1  | tmp1 |  arg1 ifNil: [ self removeProperty: #selectionColor ] ifNotNil: [ self setProperty: #selectionColor toValue: arg1 ].  tmp1 := self ownerThatIsA: SystemWindow.  self selectionColorToUse: ((self theme fadedBackgroundWindows not or: [ tmp1 isNil or: [ tmp1 isActive ] ]) ifTrue: [ arg1 ] ifFalse: [ self theme unfocusedSelectionColor ])keyStroke: arg1  arg1 keyCharacter = Character escape ifTrue: [ ^self delete ].  arg1 anyModifierKeyPressed ifFalse: [ ^self done ].  arg1 keyString = '<Opt-Shift-tab>' ifTrue: [ ^self selectPreviousTask ].  arg1 keyString = '<Opt-tab>' ifTrue: [ ^self selectNextTask ]pressedFillStyle  ^self theme taskbarItemPressedFillStyleFor: selfformat: arg1  ^arg1disabledStyle: arg1  disabledStyle := arg1.  self changedborderStyle: arg1  self borderStyle = arg1 ifTrue: [ ^self ].  super borderStyle: arg1.  self setScrollDeltasbackgroundColor  ^state backgroundColorpotentialDropMorph  ^potentialDropMorphisEnabledMatchingTheState: arg1  ^arg1 notcornerStyle: arg1  (extension isNil or: [ self cornerStyle == arg1 ]) ifTrue: [ ^self ].  extension cornerStyle: nil.  self changedforwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1label: arg1  label morph: arg1 asMorphdisplayTextOnAthensCanvas: arg1 in: arg2  | tmp1 tmp2 tmp3 |  arg1 clipBy: arg2 during: [ arg1 pathTransform restoreAfter: [ tmp2 := arg2 topLeft - positionWhenComposed.              tmp1 := AthensDisplayScanner for: self on: arg1.              tmp3 := 0.              self forLinesIn: arg1 clipRect do: [:arg3 |  arg3 first <= arg3 last ifTrue: [ tmp3 := tmp1 displayLine: arg3 offset: tmp2 leftInRun: tmp3 ] ] ] ]hasUnacceptedEdits: arg1  editView hasUnacceptedEdits: arg1headerColumn: arg1  ^nildrawOnAthensCanvas: arg1  self theme flatMenu ifFalse: [ arg1 setPaint: self baseColor twiceDarker.        arg1 drawShape: (bounds topLeft corner: bounds rightCenter).        arg1 setPaint: self baseColor twiceLighter.        arg1 drawShape: (bounds leftCenter corner: bounds bottomRight) ] ifTrue: [ arg1 setPaint: self baseColor.        arg1 drawShape: (bounds topLeft corner: bounds bottomRight) ]shouldDraw  ^truehandleMouseMove: arg1  arg1 wasHandled ifTrue: [ ^self ].  (self handlesMouseMove: arg1) ifFalse: [ ^self ].  arg1 wasHandled: true.  self mouseMove: arg1.  (self handlesMouseStillDown: arg1) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue arguments: {arg1 copy resetHandlerFields} stepTime: self mouseStillDownStepRate ].  ^self eventHandler ifNotNil: [:arg2 |  arg2 mouseMove: arg1 fromMorph: self ]secondarySelectionColor  ^self theme secondarySelectionColordepthIndent: arg1  arg1 timesRepeat: [ self addIndendtation: 16 ]isAdheringToLeft  ^falsecanBeDragged  ^truenewSeparator  ^self theme newSeparatorIn: selfactivatedModalChild  self modalChild ifNotNil: [:arg1 |  arg1 owner ifNotNil: [ arg1 activate.              arg1 modalChild ifNil: [ arg1 indicateModalChild ].              ^true ] ].  ^falselayoutPolicy: arg1  self layoutPolicy == arg1 ifTrue: [ ^self ].  self assureExtension layoutPolicy: arg1.  self layoutChangedproperty  ^propertywantsYellowButtonMenu  ^truetoggleStayUp  ^stayUp := stayUp notverticalScrollbarFrontier  ^0.98hideOrShowScrollBars  | tmp1 tmp2 |  tmp2 := self vIsScrollbarShowing.  tmp1 := self hIsScrollbarShowing.  self     vHideOrShowScrollBar;     hHideOrShowScrollBar;     resizeScrollBars.  (tmp2 and: [ self vIsScrollbarShowing not ]) ifTrue: [ scroller offset y = 0 ifFalse: [ scroller offset: scroller offset x @ 0 ] ].  (tmp1 and: [ self hIsScrollbarShowing not ]) ifTrue: [ scroller offset x <= 0 ifFalse: [ scroller offset: self hMargin negated @ scroller offset y ] ]submorphs  ^submorphsselectionFrame  ^selectedMorph ifNotNil: [ selectedMorph bounds: selectedMorph selectionFrame in: self ]minWidth  | tmp1 |  tmp1 := super minWidth.  self keyText ifNotNil: [ tmp1 := tmp1 + (self fontToUse widthOfString: self keyTextExpanded) + 12 ].  ^tmp1labelMorph  ^labelMorphnewLabelMorph  ^Morph newscrollPane: arg1  scrollPane := arg1addAllMorphs: arg1 after: arg2  ^self privateAddAllMorphs: arg1 atIndex: (submorphs indexOf: arg2 ifAbsent: [ submorphs size ])testExecuteSortingOn  | tmp1 |  tmp1 := self dataSourceForTesting.  state executeSortingOn: tmp1.  self assert: tmp1 elements equals: self elementsForTestDataSource.  state executeSortingOn: tmp1.  self assert: tmp1 elements equals: self elementsForTestDataSourceacceptDroppingMorph: arg1 event: arg2  | tmp1 |  tmp1 := self morphToDropFrom: arg1.  super acceptDroppingMorph: tmp1 event: arg2.  tmp1 submorphsDo: [:arg3 |  (arg3 isKindOf: HaloMorph) ifTrue: [ arg3 delete ] ].  self bringTopmostsToFrontbuildWindowMenu  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 add: 'Change name...' selector: #relabel.  tmp1 addLine.  tmp1 add: 'Send to back' selector: #sendToBack.  tmp1 add: 'Make next-to-topmost' selector: #makeSecondTopmost.  tmp1 addLine.  self mustNotClose ifFalse: [ tmp1 add: 'Make unclosable' selector: #makeUnclosable ] ifTrue: [ tmp1 add: 'Make closable' translated selector: #makeClosable ].  tmp1 add: (self isSticky ifTrue: [ 'Make draggable' ] ifFalse: [ 'Make undraggable' ]) selector: #toggleStickiness.  ^tmp1newMenuItem  ^MenubarItemMorph newisStepping: arg1  ^worldState isStepping: arg1leftFlush  self changeAlignment: #leftFlushsubMenuSelector: arg1  subMenuSelector := arg1.  self updateSubMenuborderRaised  self borderColor: #raisedhandleMouseMove: arg1  arg1 wasHandled ifTrue: [ ^self ].  (arg1 anyButtonPressed and: [ arg1 hand mouseFocus == self ]) ifFalse: [ ^self ].  arg1 wasHandled: true.  self mouseMove: arg1.  (self handlesMouseStillDown: arg1) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue arguments: {arg1 copy resetHandlerFields} stepTime: 1 ]keyStroke: arg1  self basicKeyStroke: arg1setPosition: arg1 contents: arg2 hand: arg3  position := arg1.  contents := arg2.  source := arg3.  wasHandled := falseshadowMargins  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := tmp2 := tmp3 := tmp4 := 0.  (tmp5 := self shadowOffset x) < 0 ifTrue: [ tmp1 := tmp5 ] ifFalse: [ tmp2 := tmp5 ].  (tmp6 := self shadowOffset x) < 0 ifTrue: [ tmp3 := tmp6 ] ifFalse: [ tmp4 := tmp6 ].  ^Margin left: tmp1 right: tmp2 top: tmp3 bottom: tmp4veryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  predecessor := arg1 references at: predecessor ifAbsent: [ nil ].  successor := arg1 references at: successor ifAbsent: [ nil ]spaceFillWeight: arg1  arg1 = 1 ifTrue: [ self removeProperty: #spaceFillWeight ] ifFalse: [ self setProperty: #spaceFillWeight toValue: arg1 ].  self layoutChangedhandlesBasicKeys  ^handlesBasicKeys ifNil: [ true ]newToolSpacer  ^self theme newToolSpacerIn: selfhUnadjustedScrollRange  | tmp1 tmp2 tmp3 |  maxWidth ifNotNil: [ ^maxWidth ].  listItems isEmpty ifTrue: [ ^0 ].  tmp1 := 30 min: listItems size.  maxWidth := 0.  tmp3 := 1.  [ tmp3 < tmp1 ] whileTrue: [ tmp2 := self getListItem: tmp3.        maxWidth := maxWidth max: (self widthToDisplayItem: tmp2).        tmp3 := tmp3 + 1 ].  tmp1 < listItems size ifTrue: [ maxWidth := maxWidth * 2 ].  ^maxWidth + 150alarmSortBlock  ^[:arg1 :arg2 |  arg1 scheduledTime < arg2 scheduledTime ]drawOn: arg1  | tmp1 |  tmp1 := self innerBounds.  arg1 fillRectangle: tmp1 fillStyle: self fillStyle.  value > 0 ifTrue: [ cachedWidth := self completedWidth.        tmp1 := tmp1 origin extent: cachedWidth @ tmp1 height.        arg1 fillRectangle: tmp1 fillStyle: self barFillStyle ].  self borderStyle frameRectangle: self bounds on: arg1selection: arg1  selection := arg1pressedButtonFillStyle  ^self theme scrollbarPressedButtonFillStyleFor: selfscale  ^scaleowner  ^ownerpopUpAt: arg1 forHand: arg2 in: arg3 allowKeyboard: arg4  | tmp1 |  arg3 submorphs select: [:arg5 |  (arg5 isKindOf: MenuMorph) and: [ arg5 stayUp not ] ] thenCollect: [:arg6 |  arg6 delete ].  self items isEmpty ifTrue: [ ^self ].  self layoutItems.  self positionAt: arg1 relativeTo: (selectedItem ifNil: [ self items first ]) inWorld: arg3.  arg3 addMorphFront: self.  arg2 newMouseFocus: self.  arg4 ifTrue: [ arg2 newKeyboardFocus: self ].  tmp1 := arg2 lastEvent.  (tmp1 isKeyboard or: [ tmp1 isMouse and: [ tmp1 anyButtonPressed not ] ]) ifTrue: [ self moveSelectionDown: 1 event: tmp1 ].  self updateColor.  self changedok  self     cancelled: false;     applyChanges;     deletediscoveredMenuOn: arg1  ^arg1 menuEntitled: self discoveredMenuTitleshadowForm  | tmp1 |  tmp1 := (Display defaultCanvasClass extent: self fullBounds extent depth: 1) asShadowDrawingCanvas: Color black.  tmp1 translateBy: bounds topLeft negated during: [:arg1 |  arg1 fullDrawMorph: self ].  ^tmp1 form offset: bounds topLeftfilter  pattern ifNil: [ ^self ].  table dataSource: (pattern ifEmpty: [ initialDataSource ] ifNotEmpty: [ initialDataSource newDataSourceMatching: (filterClass pattern: pattern) ]).  table refresh.  table deselectAll.  self isExplicit ifTrue: [ self resizeWidget ]updatePagingAreaBounds  pagingArea bounds: self totalSliderAreacolumnColorForOdd: arg1  columnColors at: 1 put: nil.  columnColors at: 2 put: arg1fillsOwner  ^fillsOwnerinitialize  super initialize.  self margin: 0menuColumn: arg1 row: arg2  | tmp1 tmp2 |  arg2 = 0 ifTrue: [ ^nil ].  tmp2 := (self elementAt: arg2) method.  tmp1 := UIManager default newMenuIn: self table for: self.  tmp1 add: 'Browse ' , tmp2 methodClass name , '>>#' , tmp2 selector target: tmp2 selector: #browse.  tmp1 add: 'Inspect #' , tmp2 methodClass name , '>>#' , tmp2 selector target: tmp2 selector: #inspect.  ^tmp1label  ^self isSelected ifTrue: [ self selectedLabel userString ifNil: [ self firstSubmorph ] ] ifFalse: [ self normalLabel userString ifNil: [ self firstSubmorph ] ]initialize  super initialize.  self     initializeAppearance;     initializeLayout;     beResetable;     resetAlpha.  fadingFactor := self defaultFadingFactorsetScrollDeltas  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        hScrollBar interval: 1.0.        ^self ].  self hideOrShowScrollBars.  self vIsScrollbarShowing ifTrue: [ self vSetScrollDelta ].  self hIsScrollbarShowing ifTrue: [ self hSetScrollDelta ]sortingIcon  ^self context morphicIconNamed: #arrowUpAndDownhasNoScaleOrRotation  ^transform isPureTranslationhash  ^self species hash bitXor: (self width hash bitXor: self color hash)title: arg1  titleContainer ifNotNil: [ titleContainer delete ].  titleContainer := AlignmentMorph newColumn.  titleContainer     color: Color transparent;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     wrapCentering: #center;     layoutInset: 0;     layoutChanged.  arg1 translated linesDo: [:arg2 |  titleContainer addMorphBack: (StringMorph contents: arg2 font: StandardFonts menuFont) ].  pinBox ifNotNil: [ ^self addMorph: titleContainer inFrontOf: pinBox ].  self addMorphBack: titleContainertabAddedToSelection: arg1  self setMultipleContentsgetSelectionIndex  ^scroller submorphs indexOf: selectedMorphdefaultColor  ^Color lightGrayautoMultiSelection: arg1  self listManager autoMultiSelection: arg1fillStyle  ^extension ifNil: [ ^color ] ifNotNil: [ extension fillStyle ifNil: [ color ] ]selectionFillStyle  ^self theme menuItemInDockingBarSelectedFillStyleFor: selfindex: arg1  index := arg1topFraction  ^topFractioninitialDataSource  ^(function isKindOf: FTFilterFunction) ifTrue: [ function initialDataSource ] ifFalse: [ nil ]newEditableDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: arg6 default: arg7 ghostText: arg8 getEnabled: arg9 useIndex: arg10 help: arg11  ^self theme newEditableDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: arg6 default: arg7 ghostText: arg8 getEnabled: arg9 useIndex: arg10 help: arg11disable  question: arg1 title: arg2  ^self theme questionIn: self text: arg1 title: arg2viewBox  ^self pasteUpMorph viewBoxfont: arg1  mouseEnterUpButton: arg1  upButton     fillStyle: self mouseOverButtonFillStyle;     borderStyle: self mouseOverButtonBorderStyle;     changedprivateSubmorphs  ^submorphstestBoundsBug1035  | tmp1 tmp2 |  tmp1 := (PolygonMorph vertices: {(0 @ 0) .         (100 @ 0) .         (0 @ 100)} color: Color red borderWidth: 0 borderColor: Color transparent) color: Color red.  tmp1 bounds.  tmp2 := Morph new     color: Color blue;     layoutPolicy: ProportionalLayout new;     addMorph: tmp1 fullFrame: (0.1 @ 0.1 corner: 0.9 @ 0.9) asLayoutFrame.  tmp1 bounds.  tmp2 fullBounds.  tmp1 bounds.  tmp2 extent: 100 @ 100.  tmp1 bounds.  tmp2 fullBounds.  tmp1 bounds.  self assert: tmp2 fullBounds equals: (0 @ 0 extent: 100 @ 100).  self assert: tmp1 bounds equals: (10 @ 10 corner: 90 @ 90)newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 help: arg5  ^self newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: nil help: arg5backgroundImage: arg1 layout: arg2  self backgroundMorph: ((self theme builder newAlphaImage: arg1 help: nil)           autoSize: false;           layout: arg2;           lock)defaultWidth  ^ProportionalSplitterMorph splitterWidthhasUnacceptedEdits  ^(self submorphs select: [:arg1 |  arg1 respondsTo: #hasUnacceptedEdits ]) anySatisfy: [:arg1 |  arg1 hasUnacceptedEdits ]increment  bar incrementwantsRecolorHandle  ^trueprepareForRotating  ^selfcurrent  ^bar valueautoGradient: arg1  autoGradient := arg1.  self updateColornewStateForEnabled: arg1  self deny: arg1.  ^TabDisabled tab: self tabcollapseNodePath: arg1  self allNodeMorphs first collapseNodePath: arg1defaultColor  ^Color transparentinitialize  enabled := true.  autoSize := true.  scale := 1.0.  layout := #topLeft.  alpha := 1.0.  super initializeresetPosition  showIndex := 0.  self verticalScrollBar value: 0.  horizontalScrollBar ifNotNil: [ self horizontalScrollBar value: 0 ].  self container setNeedsRefreshExposedRows.  self container updateExposedRowsnewSpacer  ^Morph new     borderWidth: 0;     color: Color transparent;     extent: 0 @ 0;     minWidth: 0;     hResizing: #spaceFillrotationCenter: arg1  arg1 ifNil: [ self removeProperty: #rotationCenter ] ifNotNil: [ self setProperty: #rotationCenter toValue: arg1 ]transferStateToRenderer: arg1  arg1 simplySetVisible: self visiblehandlesMouseWheel: arg1  ^self vIsScrollable or: [ self hIsScrollable ]vLeftoverScrollRange  scroller hasSubmorphs ifFalse: [ ^0 ].  ^(self vTotalScrollRange - self vScrollBarHeight roundTo: self scrollDeltaHeight) max: 0label: arg1  | tmp1 |  tmp1 := arg1 isMorph ifTrue: [ arg1 ] ifFalse: [ (self theme buttonLabelForText: arg1)           vResizing: #shrinkWrap;           hResizing: #shrinkWrap ].  self     normalLabel: tmp1;     selectedLabel: tmp1;     selected: self isSelectedcollapseNonWindows  self nonWindows reject: [:arg1 |  arg1 isSticky ] thenDo: [:arg1 |  arg1 collapse ]selectNodePath: arg1  arg1 ifNil: [ self emptySelection ] ifNotNil: [ self firstChild ifNotNil: [:arg2 |  arg2 selectNodePath: arg1 ] ]deselectAll  self requestView: MorphTreeChangeRequest deselectAllfindSubmorphFor: arg1  ^scroller findSubmorphBinary: [:arg2 |  (arg1 between: arg2 top and: arg2 bottom) ifTrue: [ 0 ] ifFalse: [ | tmp1 |              tmp1 := (arg2 top + arg2 bottom) // 2.              arg1 < tmp1 ifTrue: [ -1 ] ifFalse: [ 1 ] ] ]cornerStyle: arg1  (extension isNil or: [ self cornerStyle == arg1 ]) ifTrue: [ ^self ].  extension cornerStyle: nil.  self changeddrawLineFrom: arg1 to: arg2 on: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 |  width isPoint ifTrue: [ tmp7 := width x.        tmp8 := width y ] ifFalse: [ tmp7 := tmp8 := width ].  tmp9 := tmp7 // 2.  tmp10 := tmp7 - tmp9.  tmp11 := tmp8 // 2.  tmp12 := tmp8 - tmp11.  tmp1 := arg2 - arg1.  tmp2 := tmp1 r.  tmp3 := tmp2 > 1.0e-10 ifTrue: [ tmp1 / tmp2 ] ifFalse: [ 1 @ 0 ].  tmp4 := tmp3 dotProduct: 1 @ 0.  tmp5 := tmp3 crossProduct: 1 @ 0.  tmp6 := MatrixTransform2x3 new     a11: tmp4;     a12: tmp5;     a21: tmp5 negated;     a22: tmp4.  tmp6 offset: arg1.  tmp13 := self fillStyleForDirection: tmp3.  arg3 asBalloonCanvas transformBy: tmp6 during: [:arg4 |  arg4 drawPolygon: {((0 - tmp9) @ (0 - tmp11)) .               ((tmp2 + tmp10) @ (0 - tmp11)) .               ((tmp2 + tmp10) @ tmp12) .               ((0 - tmp9) @ tmp12)} fillStyle: tmp13 ]convertAlarms  alarms ifNotNil: [ alarms sortBlock: self alarmSortBlock ]makeBorderless  | tmp1 |  tmp1 := self class borderWidth.  self submorphsDo: [:arg1 |  | tmp2 |        tmp2 := arg1 layoutFrame.        tmp2 ifNotNil: [ tmp2 rightFraction = 1 ifTrue: [ tmp2 rightOffset: tmp2 rightOffset + tmp1 ].              tmp2 leftFraction = 0 ifTrue: [ tmp2 leftOffset: tmp2 leftOffset - tmp1 ].              tmp2 bottomFraction = 1 ifTrue: [ tmp2 bottomOffset: tmp2 bottomOffset + tmp1 ] ] ].  self borderWidth: 0mouseLeavePagingArea: arg1  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStyle;     changed.  slider     fillStyle: self normalThumbFillStyle;     borderStyle: self normalThumbBorderStyle;     changed.  upButton     fillStyle: self normalButtonFillStyle;     borderStyle: self normalButtonBorderStyle;     changed.  downButton     fillStyle: self normalButtonFillStyle;     borderStyle: self normalButtonBorderStyle;     changedprepareForRotating  ^self addFlexShellprepareForRotating  ^self addFlexShellreferencePosition  | tmp1 |  ^(tmp1 := self renderedMorph) == self ifTrue: [ super referencePosition ] ifFalse: [ transform localPointToGlobal: tmp1 referencePosition ]maximumExtent  ^self valueOfProperty: #maximumExtentchildNodeFromItem: arg1  ^((self childNodeClassFromItem: arg1) with: arg1 model: model)     parentNode: self;     yourselfmin  ^minkeyStroke: arg1  ^falseextension  ^extensionlabel  ^labeltrackCenterOfRotation: arg1 with: arg2  (arg2 hasProperty: #dragByCenterOfRotation) ifTrue: [ ^self doDrag: arg1 with: arg2 ].  arg1 hand obtainHalo: self.  arg2 center: arg1 cursorPointcreateKeyTextMorph: arg1  ^(self fixKeyText: arg1) asStringMorph     font: self keyTextFont emphasis: 2;     color: textColor;     yourselfnewString: arg1  ^self theme newStringIn: self label: arg1 font: self theme labelFont style: #plaincolor  ^colornewTabGroup: arg1  ^self theme newTabGroupIn: self for: arg1sortingSelector: arg1  sortingSelector := arg1morphicIconNamed: arg1  ^(self iconNamed: arg1) asMorphstoredListTab  ^TabMorph label: 'Stored List Model' icon: (self iconNamed: #smallHelpIcon) retrievingBlock: [ listModel buildWithSpec ]sortingIcon  ^nilorigin  ^self method originjustDroppedInto: arg1 event: arg2  patternModel  ^patternModeladdGrips  self     addCornerGrips;     addEdgeGripsbasicKeyPressed: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := tmp4 := self getCurrentSelectionIndex.  tmp2 := Time millisecondClockValue.  tmp3 := tmp2 - lastKeystrokeTime > 500.  lastKeystrokeTime := tmp2.  self searchedElement: nil.  lastKeystrokes := tmp3 ifTrue: [ arg1 asLowercase asString ] ifFalse: [ lastKeystrokes , arg1 asLowercase asString ].  tmp1 := self listForSearching findFirst: [:arg2 |  arg2 beginsWith: lastKeystrokes fromList: self ].  tmp1 isZero ifTrue: [ ^0 ].  model okToChange ifFalse: [ ^0 ].  tmp4 = tmp1 ifTrue: [ ^0 ].  self searchedElement: tmp1.  ^tmp1storeOn: arg1  arg1     nextPutAll: '(';     nextPutAll: self class name;     nextPutAll: ' width: ';     print: self width;     nextPutAll: ' color: ';     print: self color;     nextPutAll: ')'initialize  super initialize.  self     cancelled: true;     addInitialPanelrootItems  ^RPackageOrganizer default packagescontents  ^contentsgetValueSelector: arg1  getValueSelector := arg1addPolyShapingMenuItems: arg1 hand: arg2  arg1 addLine.  arg1 addWithLabel: 'make inscribed diamondOval' enablement: [ self isClosed ] action: #diamondOval.  arg1 addWithLabel: 'make enclosing rectangleOval' enablement: [ self isClosed ] action: #rectangleOvalupdateExtent  | tmp1 tmp2 |  self fullBounds.  self fillsOwner ifFalse: [ ^self ].  self owner ifNotNil: [:arg1 |  tmp1 := self avoidVisibleBordersAtEdge ifTrue: [ self borderWidth * 2 ] ifFalse: [ 0 ].        self isHorizontal ifTrue: [ self width: arg1 width + tmp1 ].        self isVertical ifTrue: [ tmp2 := self usedHeightByPredominantDockingBarsOfChastes: #(#top #bottom).              self height: arg1 height + tmp1 - tmp2 ] ]textColor: arg1  self setProperty: #textColor toValue: arg1.  self listMorph color: arg1initialDataSource: arg1  (function isKindOf: FTFilterFunction) ifTrue: [ function initialDataSource: arg1 ]paneColorOrNil  ^super paneColorOrNil ifNotNil: [:arg1 |  self theme subgroupColorFrom: arg1 ]handleKeyUp: arg1  arg1 wasHandled ifTrue: [ ^self ].  (self handlesKeyUp: arg1) ifFalse: [ ^self ].  arg1 wasHandled: true.  ^self keyUp: arg1rowMorphGetSelector  ^rowMorphGetSelectorlayoutBounds  | tmp1 tmp2 tmp3 |  tmp1 := super layoutBounds.  container ifNil: [ ^tmp1 ].  tmp2 := tmp1 left + self spacerWidth.  tmp3 := tmp1 right max: tmp2 + self spacerWidth.  ^Rectangle left: tmp2 right: tmp3 top: tmp1 top bottom: tmp1 bottombuildContents  nodeList := nil.  scroller removeAllMorphs.  (self nodeList isNil or: [ self nodeList isEmpty ]) ifTrue: [ nodeList := nil.        ^self emptySelection ].  self addSubmorphsFromNodeListptName  ^#bottomLeftadd: arg1 icon: arg2 subMenu: arg3  self addToggle: arg1 target: nil selector: nil.  self lastItem     icon: arg2;     subMenu: arg3.  ^selfaddAllToSelection: arg1  | tmp1 |  self searchedElement: nil.  arg1 do: [:arg2 |  arg2           highlight;           selected: true ].  self selectionChanged.  self selectionUpdateFromViewWhile: [ tmp1 := self newSelectionHolderWithNodePath: (arg1 last path collect: [:arg2 |  arg2 complexContents ]).        self listModel selection: tmp1 ]colorsAtCorners  ^self borders first colorsAtCornersgridModulus: arg1  self gridSpecPut: (self gridOrigin extent: arg1).  self changednewString: arg1 font: arg2 style: arg3  ^self theme newStringIn: self label: arg1 font: arg2 style: arg3navigateFocusForward  self nextMorphWantingFocus ifNotNil: [:arg1 |  arg1 takeKeyboardFocus ]newPluggableDialogWindow: arg1  ^self newPluggableDialogWindow: arg1 for: nilrefresh  lastRefresh := Time millisecondClockValue.  UIManager default uiProcess == Processor activeProcess ifTrue: [ self currentWorld doOneCycleNow ]columnColors  ^columnColorsstartBlinking  self startStepping: #onBlinkCursor at: Time millisecondClockValue arguments: nil stepTime: 500.  self resetBlinkCursortranslatedBy: arg1  ^self shallowCopy translateBy: arg1disable  self enabled: falseenabled  ^enabledredoTypeIn: arg1 interval: arg2  self handleEdit: [ self editor redoTypeIn: arg1 interval: arg2 ]listManager  ^listManager ifNil: [ listManager := MorphTreeListManager new client: self ]isMenuLineMorph  ^truenumberOfRows  ^self items ifNotNil: [ | tmp1 |        tmp1 := 0.        self items do: [:arg1 |  tmp1 := tmp1 + arg1 size ].        tmp1 ] ifNil: [ 0 ]scrollTarget  ^self scroller submorphs firstlayoutBounds  ^self isFullscreen ifTrue: [ self perform: #layoutBounds withArguments: #() inSuperclass: Morph ] ifFalse: [ super layoutBounds ]openInExternalWindowModalCallback: arg1  | tmp1 |  tmp1 := OSWindowWorldMorph new extent: self extent.  tmp1     layoutPolicy: ProportionalLayout new;     clipSubmorphs: true;     closeCallback: [ arg1 cull: self ].  self layoutFrame: LayoutFrame identity.  self     hResizing: #spaceFill;     vResizing: #spaceFill.  self openInWorld: tmp1.  self onAnnouncement: MorphDeleted do: [:arg2 |  tmp1 ifNotNil: [ tmp1 delete ].        tmp1 := nil ].  ^tmp1 openaddGraphicalHandleFrom: arg1 at: arg2  | tmp1 tmp2 |  tmp2 := Smalltalk ui icons iconNamed: arg1 ifNone: [ self iconNamed: #solidMenuIcon ].  tmp1 := ImageMorph new     form: tmp2;     bounds: (Rectangle center: arg2 extent: tmp2 extent).  tmp1 wantsYellowButtonMenu: false.  self addMorph: tmp1.  tmp1 on: #mouseUp send: #endInteraction to: self.  ^tmp1addPaneVSplitterBetween: arg1 and: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 |  arg1 ifEmpty: [ ^self ].  tmp1 := arg1 first layoutFrame rightFraction.  tmp2 := arg1 select: [:arg3 |  arg3 layoutFrame leftFraction = arg3 layoutFrame rightFraction ].  tmp6 := ((arg1 reject: [:arg3 |  arg3 layoutFrame leftFraction = arg3 layoutFrame rightFraction ]) asSortedCollection: [:arg4 :arg5 |  arg4 layoutFrame bottomFraction = arg5 layoutFrame bottomFraction ifTrue: [ arg4 layoutFrame topFraction <= arg5 layoutFrame topFraction ] ifFalse: [ arg4 layoutFrame bottomFraction <= arg5 layoutFrame bottomFraction ] ]) readStream.  tmp6 contents ifEmpty: [ ^tmp2 ].  tmp8 := OrderedCollection new.  tmp3 := tmp6 contents first layoutFrame topFraction.  [ tmp6 atEnd or: [ tmp7 := tmp6 next.        tmp7 layoutFrame topFraction ~= tmp3 and: [ tmp7 layoutFrame bottomFraction ~= tmp3 ] ] ] whileFalse: [ tmp8 add: tmp7.        tmp3 := tmp7 layoutFrame bottomFraction ].  tmp4 := tmp8 first layoutFrame.  tmp5 := tmp8 last layoutFrame.  tmp9 := (arg2 reject: [:arg3 |  arg3 layoutFrame leftFraction = arg3 layoutFrame rightFraction ]) select: [:arg3 |  arg3 layoutFrame topFraction between: tmp4 topFraction and: tmp5 bottomFraction ].  tmp11 := (tmp8 collect: [:arg3 |  arg3 layoutFrame rightOffset ]) max.  tmp10 := ProportionalSplitterMorph new.  tmp10 layoutFrame: ((tmp1 @ tmp4 topFraction corner: tmp1 @ tmp5 bottomFraction) asLayoutFrame           leftOffset: tmp11;           topOffset: tmp4 topOffset;           rightOffset: 4 + tmp11;           bottomOffset: tmp5 bottomOffset).  tmp8 := tmp8 , tmp2.  tmp8 do: [:arg3 |  tmp10 addLeftOrTop: arg3 ].  tmp9 do: [:arg3 |  tmp10 addRightOrBottom: arg3 ].  self addMorphBack: tmp10.  ^tmp8turnOn  self borderColor: #inset.  self color: onColorvalueOfProperty: arg1 ifAbsent: arg2  otherProperties ifNil: [ ^arg2 value ].  ^otherProperties at: arg1 ifAbsent: [ ^arg2 value ]toggleStickiness  extension ifNil: [ ^self beSticky ].  extension sticky: extension sticky notchildNodeClassFromItem: arg1  ^self classinitialize  super initialize.  self     layoutPolicy: TableLayout new;     cellPositioning: #leftCenter;     listDirection: #leftToRight;     cellSpacing: #none;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     color: Color transparentgrabTransform  ^owner ifNil: [ IdentityTransform new ] ifNotNil: [ owner grabTransform ]mouseDown: arg1  (self isEditable: arg1) ifTrue: [ self launchEditor: arg1 ] ifFalse: [ super mouseDown: arg1 ]balloonColor: arg1  ^self setProperty: #balloonColor toValue: arg1totalBarWidth  ^self width - (2 * self borderWidth)rowHeight: arg1  ^self table rowHeightkeyStroke: arg1  | tmp1 tmp2 |  tmp2 := arg1 keyValue asCharacter.  arg1 anyModifierKeyPressed ifFalse: [ self basicKeyPressed: tmp2.        ^false ].  (self scrollByKeyboard: arg1) ifTrue: [ ^true ].  keystrokeActionSelector ifNil: [ ^false ].  (tmp1 := keystrokeActionSelector numArgs) = 1 ifTrue: [ ^model perform: keystrokeActionSelector with: tmp2 ].  tmp1 = 2 ifTrue: [ ^model perform: keystrokeActionSelector with: tmp2 with: self ].  ^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'adjustRightX  | tmp1 |  tmp1 := container right - maxRightX.  lines do: [:arg1 |  arg1 paddingWidth: arg1 paddingWidth - tmp1 ].  container := container withRight: maxRightXadjustLayout  | tmp1 tmp2 |  tmp1 := self computeLength.  self removeAllMorphs.  tmp1 isZero ifTrue: [ ^self ].  tmp2 := self overlap.  selectionHistory do: [:arg1 |  | tmp3 |        tmp3 := (tabs indexOf: arg1) - 1.        self addMorph: arg1 fullFrame: (LayoutFrame identity                 rightFraction: 0;                 leftOffset: tmp3 * (tmp1 - tmp2);                 rightOffset: tmp3 * (tmp1 - tmp2) + tmp1;                 bottomOffset: -1;                 yourself).        arg1 updateShowIcon ].  self addActionsFor: self selectedTabbeExplicit  super beExplicit.  table addMorph: actionButton.  table selectedIndex = 0 ifTrue: [ table selectIndex: 1 ]selectableIndexBellow: arg1  ^arg1 + 1mouseDown: arg1  | tmp1 |  (self class showSplitterHandles not and: [ self bounds containsPoint: arg1 cursorPoint ]) ifTrue: [ oldColor := self color.        self setGrabbedColor ].  tmp1 := arg1 cursorPoint.  lastMouse := {tmp1 .   (tmp1 - self position)}drawWeekDayNamesOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := self bounds topLeft translateBy: 0 @ 25.  tmp4 := self bounds topRight translateBy: 0 @ 25.  tmp2 := self bounds height - 25.  tmp1 := tmp2 // 8.  tmp5 := self bounds width // 7.  arg1 line: (tmp3 translateBy: 0 @ tmp1) to: (tmp4 translateBy: 0 @ tmp1) width: 1 color: Color black.  #('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat') withIndexDo: [:arg2 :arg3 |  | tmp6 tmp7 tmp8 |        tmp6 := tmp5 * (arg3 - 1).        tmp7 := tmp3 translateBy: (tmp6 + (tmp5 // 2) + 1) @ 0.        tmp8 := self weekdayFont widthOfString: arg2.        arg1 drawString: arg2 at: (tmp7 translateBy: (tmp8 // -2) @ 3) font: self weekdayFont color: Color darkGray ]maxBarWidth  ^self bars inject: 0 into: [:arg1 :arg2 |  arg2 minExtent x max: arg1 ]selectionChanged: arg1  self selectionChangedUpdateStatus: arg1.  self selectionChangedUpdateIndex: arg1.  self selectionChangedResetIfEmpty: arg1asTableLayoutProperties  ^TableLayoutProperties new     hResizing: self hResizing;     vResizing: self vResizing;     disableTableLayout: self disableTableLayout;     yourselficonOrThumbnail  ^self icon ifNil: [ | tmp1 tmp2 |        tmp1 := 320 @ 240.        tmp2 := self fullBounds.        tmp2 area <= (tmp1 x * tmp1 y) ifTrue: [ self imageForm ] ifFalse: [ self imageFormForRectangle: (tmp2 topLeft extent: tmp1) ] ]isTableLayout  ^falsekeyStroke: arg1  (self navigationKey: arg1) ifTrue: [ ^self ].  (arg1 keyCharacter = Character space or: [ arg1 keyCharacter = Character cr ]) ifTrue: [ self performAction ]bottomRightOffset: arg1  bottomOffset := arg1 y.  rightOffset := arg1 xhLeftoverScrollRange  | tmp1 |  scroller hasSubmorphs ifFalse: [ ^0 ].  tmp1 := bounds width.  self vIsScrollbarShowing ifTrue: [ tmp1 := tmp1 - self scrollBarThickness ].  ^(self hTotalScrollRange - tmp1 roundTo: self scrollDeltaHeight) max: 0setItemFromBlock: arg1  self setItem: arg1 valuebeSingleSelection  multipleSelection := falsebaseColor: arg1  morphsAt: arg1  ^self morphsAt: arg1 unlocked: falseframeRectangle: arg1 on: arg2  self drawLineFrom: arg1 bottomLeft + (self trimSize @ 0) to: arg1 bottomRight - (self trimSize @ 0) on: arg2addAllFromPragma: arg1 target: arg2  self addAllFrom: (PragmaMenuBuilder pragmaKeyword: arg1 model: arg2) menuhandleMouseLeave: arg1  arg1 hand removePendingBalloonFor: self.  arg1 isDraggingEvent ifTrue: [ (self handlesMouseOverDragging: arg1) ifTrue: [ arg1 wasHandled: true.              self mouseLeaveDragging: arg1 ].        ^self eventHandler ifNotNil: [:arg2 |  arg2 mouseLeave: arg1 fromMorph: self ] ].  ^(self handlesMouseOver: arg1) ifTrue: [ arg1 wasHandled: true.        self mouseLeave: arg1 ] ifFalse: [ self eventHandler ifNotNil: [:arg2 |  arg2 mouseLeave: arg1 fromMorph: self ] ]rejectsEvent: arg1  (super rejectsEvent: arg1) ifTrue: [ ^true ].  arg1 isDropEvent ifTrue: [ ^true ].  ^falsecouldHaveRoundedCorners  ^falseprivateUpdateColumnMorphs  self resetRootInfo.  self updateTopHeader.  self innerWidgetChangedmouseUp: arg1  | tmp1 |  tmp1 := allButtons copy.  tmp1 ifNotNil: [ tmp1 do: [:arg2 |  arg2 showSelectionFeedback ifTrue: [ arg2                       showSelectionFeedback: false;                       changed;                       layoutChanged ] ] ].  tmp1 ifNil: [ ^self ].  allButtons := nil.  tmp1 do: [:arg2 |  (arg2 containsPoint: arg1 cursorPoint) ifTrue: [ arg2 enabled ifTrue: [ arg2 performAction: arg1 ] ] ].  self showSelectionFeedback ifTrue: [ self changed ]treeMorphClass  ^LazyMorphTreeMorphchangeScrollerTableLayout  self scroller changeTableLayoutselectSubmorphsOf: arg1  | tmp1 tmp2 |  tmp1 := arg1 submorphs select: [:arg2 |  (bounds containsRect: arg2 fullBounds) and: [ arg2 ~~ self and: [ (arg2 isKindOf: HaloMorph) not ] ] ].  otherSelection ifNil: [ ^selectedItems := tmp1 ].  tmp2 := tmp1 intersection: itemsAlreadySelected.  otherSelection setSelectedItems: (itemsAlreadySelected copyWithoutAll: tmp2).  selectedItems := tmp1 copyWithoutAll: tmp2selectedNodePathList  ^selectedNodePathList ifNil: [ selectedNodePathList := OrderedCollection new ]drawOnAthensCanvas: arg1  | tmp1 |  arg1 setPaint: self fillStyle.  arg1 drawShape: self bounds.  arg1 setPaint: self borderStyle.  arg1 drawShape: self bounds.  tmp1 := self imageToUse.  tmp1 ifNotNil: [ arg1 setPaint: tmp1.        arg1 drawShape: (self innerBounds center - (tmp1 extent // 2) extent: tmp1 extent) ].  ((self state == #pressed or: [ self state == #repressed ]) and: [ image isNil ]) ifTrue: [ arg1 setPaint: (self paneColor alpha: 0.3).        arg1 drawShape: self innerBounds ].  (self enabled not and: [ self theme fadeCheckboxWhenDisabled ]) ifTrue: [ arg1 setPaint: (self paneColor alpha: 0.4).        arg1 drawShape: self innerBounds ]sendListenEvent: arg1 to: arg2  arg2 ifNil: [ ^self ].  arg2 do: [:arg3 |  arg3 ifNotNil: [ arg3 handleListenEvent: arg1 copy ] ]complexContents  ^complexContentstoggleSelection  self selected ifTrue: [ self removeFromSelection ] ifFalse: [ self addToSelection ]mouseLeaveDownButton: arg1  arg1 redButtonPressed ifFalse: [ downButton           fillStyle: self normalButtonFillStyle;           borderStyle: self normalButtonBorderStyle;           changed ]shrinkWrap: arg1  shrinkWrap := arg1snapToEdgeIfAppropriate  | tmp1 tmp2 tmp3 |  (tmp1 := self valueOfProperty: #edgeToAdhereTo) ifNotNil: [ tmp2 := bounds.        self adhereToEdge: tmp1.        bounds ~= tmp2 ifTrue: [ (tmp3 := self world) ifNotNil: [ tmp3 viewBox ifNotNil: [ tmp3 displayWorld ] ] ] ]mouseEnter: arg1  super mouseEnter: arg1.  self wantsKeyboardFocus ifFalse: [ ^self ].  self keyboardFocusOnMouseDown ifFalse: [ self takeKeyboardFocus ]showBalloon: arg1 hand: arg2  | tmp1 tmp2 |  (tmp1 := self world) ifNil: [ ^self ].  tmp2 := arg2 ifNil: [ tmp1 activeHand ].  (self theme builder newBalloonHelp: arg1 for: self balloonHelpAligner) popUpFor: self hand: tmp2addTab: arg1  self tabs add: (self newLabelMorph: arg1).  self updateTabslabel  ^labelStringinitialize  super initialize.  self     fillStyle: self defaultFillStyle;     borderStyle: (BorderStyle inset           baseColor: self paneColor;           width: 1);     sliderColor: Color black;     clipSubmorphs: trueupdateColor  self theme preferGradientFill ifFalse: [ ^self ].  self fillStyle: (self theme progressFillStyleFor: self)useBitmapFill  | tmp1 |  self fillStyle isBitmapFill ifTrue: [ ^self ].  tmp1 := BitmapFillStyle fromForm: self defaultBitmapFillForm.  tmp1 origin: self bounds origin.  self fillStyle: tmp1setType: arg1 position: arg2 direction: arg3 buttons: arg4 hand: arg5 stamp: arg6  type := arg1.  position := arg2.  buttons := arg4.  source := arg5.  wasHandled := false.  direction := arg3.  timeStamp := arg6defaultColor  ^Color transparentcurrentPageFirstIndex  ^currentPageFirstIndex ifNil: [ currentPageFirstIndex := 1 ]lastNonZeroIndex  ^lastNonZeroIndex ifNil: [ lastNonZeroIndex := 0 ]popUpNoKeyboard  ^self popUpAt: ActiveHand position forHand: ActiveHand in: self currentWorld allowKeyboard: falseinitializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigationforEachPointDo: arg1 lastPointDo: arg2  pointBlock := arg1.  lastPointBlock := arg2notExpandedToggleImage  ^notExpandedToggleImage ifNil: [ notExpandedToggleImage := ImageMorph new form: self notExpandedForm ]contents  ^contents ifNil: [ contents := super contents ]width  ^widthcanExpand  ^complexContents hasContentstestIfTheTestedMethodIstheSameThatTheOneUsedInProd  self assert: self theMethodInProdThatShouldBeTested bytecode equals: (self class >> #updateOrderedTasksFrom:) bytecoderotationDegrees  ^0.0fillStyleForDirection: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 degrees truncated // 10 + 1.  lineStyles ifNotNil: [ tmp2 := lineStyles at: tmp1.        tmp2 ifNotNil: [ ^tmp2 ] ].  tmp3 := Point r: 1.0 degrees: (tmp1 - 1) * 10 + 5.  tmp2 := GradientFillStyle colors: (self colorsForDirection: tmp3).  tmp2     direction: 0 @ width asPoint y;     radial: false.  tmp2 origin: ((width asPoint x // 2) @ (width asPoint y // 2)) negated.  tmp2 pixelRamp: (tmp2 computePixelRampOfSize: 16).  tmp2 isTranslucent.  lineStyles ifNil: [ lineStyles := Array new: 37 ].  lineStyles at: tmp1 put: tmp2.  ^tmp2areasRemainingToFill: arg1  ^Array with: arg1mouseDown: arg1  | tmp1 tmp2 |  self enabled ifFalse: [ ^self ].  mouseOverAllowed := true.  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ].  (arg1 yellowButtonPressed and: [ (self commandOrCrontrolKeyPressed: arg1) not ]) ifTrue: [ ^self yellowButtonEvent: arg1 ].  (tmp1 := self scrollerSubMorphFromPoint: arg1 position) ifNotNil: [ tmp1 hasToggle ifTrue: [ (tmp1 inToggleArea: (tmp1 point: arg1 position from: self)) ifTrue: [ ^self toggleExpandedState: tmp1 event: arg1 ] ] ].  tmp1 ifNil: [ ^super mouseDown: arg1 ].  tmp1 highlightForMouseDown.  tmp2 := Array with: #click: with: #doubleClick: with: nil with: (self dragEnabled ifTrue: [ #startDrag: ]).  arg1 hand waitForClicksOrDrag: self event: arg1 selectors: tmp2 threshold: 10.  self listManager mouseDown: arg1 on: tmp1enabled  ^state enabledbrowseItem  Smalltalk tools browser openOnClass: self itemClass selector: self selectorlineIndexForPoint: arg1  | tmp1 tmp2 |  tmp2 := arg1 y truncated.  tmp1 := (self fastFindFirstLineSuchThat: [:arg2 |  arg2 bottom > tmp2 ]) min: lines size.  [ tmp1 < lines size and: [ (lines at: tmp1 + 1) top = (lines at: tmp1) top and: [ arg1 x >= (lines at: tmp1 + 1) left ] ] ] whileTrue: [ tmp1 := tmp1 + 1 ].  ^tmp1fontName: arg1 size: arg2  ^self font: (StrikeFont familyName: arg1 size: arg2) emphasis: 0updateSliderBounds  self     updateUpButtonBounds;     updateDownButtonBounds;     updatePagingAreaBounds.  super updateSliderBoundsglamourOptimalExtent  | tmp1 tmp2 |  tmp1 := self setOptimalResizingStrategyAndReturnOldOne.  tmp2 := self minExtent.  self returnToOldResizingStrategy: tmp1.  ^tmp2drawOnAthensCanvas: arg1  self subclassResponsibilitywantsToShow: arg1  ^limit < 0 or: [ (countDict at: arg1 ifAbsent: [ 0 ]) < limit ]printOn: arg1  arg1 nextPut: $[.  arg1     nextPutAll: type;     nextPutAll: ' '''.  self printKeyStringOn: arg1.  arg1 nextPut: $'.  arg1 nextPut: $]takesKeyboardFocus  ^self enabledlabel  ^label contentsinitialize  super initialize.  showIndex := 0.  showColumnHeaders := true.  columns := #().  needToggleAtMouseUp := false.  self beRowSelection.  self beNotResizable.  self beSingleSelection.  self enableSearch.  self initializeScrollBars.  self initializeContainer.  self initializeKeyBindings.  self resizeAllSubviewsicon  ^self iconNamed: #windowIconfullContainsPoint: arg1  ^bounds containsPoint: arg1selection: arg1  self selectionIndex: (self getList indexOf: arg1)arguments  ^argumentsonlyCloseAndPinable  self     withCloseBox;     title: '';     withPinBoxmakeAScreenshot  | tmp1 |  tmp1 := 'PharoScreenshot'.  (UIManager default chooseFrom: {'The entire world' translated .         'A selected area' translated} values: #(#world #area) message: 'What do you want to shoot? (File will be saved in image directory)' translated title: 'Make a screenshot') ifNotNil: [:arg1 |  | tmp2 tmp3 |        tmp2 := arg1 = #world ifTrue: [ self currentWorld imageForm ] ifFalse: [ Form fromUser ].        tmp3 := (FileSystem workingDirectory / tmp1 , 'png') nextVersion.        PNGReadWriter putForm: tmp2 onFileNamed: (FileSystem workingDirectory / tmp1 , 'png') nextVersion.        UIManager default inform: (String streamContents: [:arg2 |  arg2                       nextPutAll: 'Screenshot saved under ';                       nextPutAll: tmp3 fullName;                       cr;                       nextPutAll: 'Click to open location' ]) actionOnClick: [ tmp3 openInOSFileBrowser ] ]showCloseIcon  closeIcon showaddDirectionHandles  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  self showingDirectionHandles ifFalse: [ ^self ].  directionArrowAnchor := (target point: target referencePosition in: self world) rounded.  tmp5 := target imageFormForRectangle: (Rectangle center: directionArrowAnchor extent: 3 @ 3).  tmp6 := tmp5 colorAt: 1 @ 1.  (tmp4 := LineMorph newSticky makeForwardArrow)     borderWidth: 2;     borderColor: (Color green orColorUnlike: tmp6).  self positionDirectionShaft: tmp4.  self addMorphFront: tmp4.  tmp4     setCenteredBalloonText: 'Set forward direction' translated;     on: #mouseDown send: #doDirection:with: to: self;     on: #mouseMove send: #trackDirectionArrow:with: to: self;     on: #mouseUp send: #setDirection:with: to: self.  tmp2 := 15.  tmp3 := 3.  tmp7 := Color red orColorUnlike: tmp6.  (tmp1 := EllipseMorph newBounds: (0 @ 0 extent: tmp2 @ tmp2) color: Color transparent)     borderWidth: tmp3;     borderColor: (Color blue orColorUnlike: tmp6);     addMorph: (LineMorph from: (tmp2 // 2) @ tmp3 to: (tmp2 // 2) @ (tmp2 - tmp3 - 1) color: tmp7 width: 1) lock;     addMorph: (LineMorph from: tmp3 @ (tmp2 // 2) to: (tmp2 - tmp3 - 1) @ (tmp2 // 2) color: tmp7 width: 1) lock;     align: tmp1 bounds center with: directionArrowAnchor.  tmp1 wantsYellowButtonMenu: false.  self addMorph: tmp1.  tmp1     setCenteredBalloonText: 'Rotation center (hold down the shift key and drag from here to change it)' translated;     on: #mouseDown send: #prepareToTrackCenterOfRotation:with: to: self;     on: #mouseMove send: #trackCenterOfRotation:with: to: self;     on: #mouseUp send: #setCenterOfRotation:with: to: selfselectableIndexBellow: arg1  ^{(arg1 first + 1) .   arg1 second}allOwners  ^Array streamContents: [:arg1 |  self allOwnersDo: [:arg2 |  arg1 nextPut: arg2 ] ]handlesMouseStillDown: arg1  ^actWhen == #whilePressedcolumnResizerFrames  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := self columns collect: [:arg1 |  tmp1 := self minResizerOffset max: tmp1 + arg1 currentWidth.        (scroller left + tmp1) @ self top corner: (scroller left + tmp1 + self resizerWidth) @ scroller bottom ].  self lastColumnUnbounded ifTrue: [ tmp2 ifNotEmpty: [ tmp2 removeLast ] ].  ^tmp2 collect: [:arg2 |  arg2 translateBy: scroller offset x negated @ 0 ]unlockContents  self submorphsDo: [:arg1 |  arg1 unlock ]resizerChanged  self columns size > 1 ifTrue: [ self           updateColumnResizersXOffset;           resizeScroller;           updateColumnMorphs ] ifFalse: [ self updateTopHeader ]isOpaque: arg1  arg1 == false ifTrue: [ self removeProperty: #isOpaque ] ifFalse: [ self setProperty: #isOpaque toValue: arg1 ].  self changedinitializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigationsize  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := self.  [ tmp2 isNil ] whileFalse: [ tmp1 := tmp1 + 1.        tmp2 := tmp2 nextCell ].  ^tmp1useSolidFill  self fillStyle isSolidFill ifTrue: [ ^self ].  self fillStyle: self fillStyle asColorisEnabled  ^isEnabledelementAt: arg1  ^rootItem childAt: arg1allOwnersDo: arg1  owner ifNotNil: [ ^owner withAllOwnersDo: arg1 ]mouseOverPagingAreaButtonBorderStyle  ^self theme scrollbarMouseOverBarButtonBorderStyleFor: selfnewSliderFor: arg1 getValue: arg2 setValue: arg3 getEnabled: arg4 help: arg5  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: 0 max: 1 quantum: nil getEnabled: arg4 help: arg5newCancelButton  ^self newCancelButtonFor: selfincrement  ^progressBar incrementbeCheckList  self isCheckList: trueaddSubmorphsFromNodeList  self addSubmorphsFromNodeList: self currentNodelist previouslyExpanded: #()bringWindowsFullOnscreen  | tmp1 |  bounds allAreasOutsideList: (self taskbars collect: [:arg1 |  arg1 bounds ]) do: [:arg2 |  tmp1 ifNil: [ tmp1 := arg2 ] ifNotNil: [ tmp1 area > arg2 area ifTrue: [ tmp1 ] ifFalse: [ arg2 ] ] ].  (self windowsSatisfying: [:arg3 |  true ]) do: [:arg4 |  arg4 right: (arg4 right min: tmp1 right).        arg4 bottom: (arg4 bottom min: tmp1 bottom).        arg4 left: (arg4 left max: tmp1 left).        arg4 top: (arg4 top max: tmp1 top) ]honeIn: arg1 step: arg2 measure: arg3 withIn: arg4  | tmp1 |  arg2 < 1 ifTrue: [ ^arg1 ].  tmp1 := arg1 - arg2.  ^arg3 > (arg4 + (self measureFor: tmp1)) ifTrue: [ self honeIn: arg1 step: arg2 // 2 measure: arg3 withIn: arg4 ] ifFalse: [ self honeIn: tmp1 step: arg2 // 2 measure: arg3 withIn: arg4 ]pinBoxClicked  owner toggleStayUp.  self updatePinFormsetUp  super setUp.  strategy := self actualClass column: FTColumn newupdate: arg1 with: arg2  super update: arg1.  arg1 == #selectedIndex ifTrue: [ | tmp1 |        tmp1 := self tabGroup pages at: arg2 ifAbsent: [ nil ].        tmp1 ifNotNil: [ tmp1 rememberKeyboardFocus: ActiveHand keyboardFocus.              self tabGroup page ifNotNil: [ self tabGroup page activate ] ] ]vHideScrollBar  self vIsScrollbarShowing ifFalse: [ ^self ].  self removeMorph: scrollBar.  self resetExtenthasSpecialCTRLKeyValue  ^self controlKeyPressed and: [ keyValue <= 26 & (keyValue ~= 4) & (keyValue ~= 1) ]searchText: arg1  arg1 isEmptyOrNil ifTrue: [ ^#() ].  self elements withIndexDo: [:arg2 :arg3 |  (arg2 name beginsWith: arg1) ifTrue: [ ^{arg3} ] ].  ^#()add: arg1 icon: arg2 help: arg3 subMenu: arg4 action: arg5 keyText: arg6  | tmp1 |  tmp1 := self newMenuItem     contents: arg1;     subMenu: arg4;     icon: arg2;     keyText: arg6;     yourself.  arg5 ifNotNil: [:arg7 |  tmp1           target: arg7 receiver;           selector: arg7 selector;           arguments: arg7 arguments ].  arg3 ifNotNil: [ tmp1 setBalloonText: arg3 ].  self addMorphBack: tmp1invalidRect: arg1  ^self invalidRect: arg1 from: selfenable  self enabled: truedoScrollUp  (self waitForDelay1: 200 delay2: 40) ifFalse: [ ^self ].  self setValue: (value - scrollDelta - 0.000001 max: 0.0)newColorChooserFor: arg1 getColor: arg2 setColor: arg3 getEnabled: arg4 help: arg5  ^self theme newColorChooserIn: self for: arg1 getColor: arg2 setColor: arg3 getEnabled: arg4 help: arg5initForEvents  mouseOverHandler := nil.  lastMouseEvent := MouseEvent basicNew setType: #mouseMove position: 0 @ 0 buttons: 0 hand: self.  lastEventBuffer := {1 .   0 .   0 .   0 .   0 .   0 .   nil .   nil}.  recentModifiers := 0.  self resetClickStatenewColorChooserFor: arg1 getColor: arg2 setColor: arg3 help: arg4  ^self theme newColorChooserIn: self for: arg1 getColor: arg2 setColor: arg3 getEnabled: nil help: arg4assureLayoutProperties  | tmp1 |  tmp1 := self layoutProperties.  tmp1 == self ifTrue: [ tmp1 := nil ].  tmp1 ifNil: [ tmp1 := LayoutProperties new initializeFrom: self.        self layoutProperties: tmp1 ].  ^tmp1setWindowColor: arg1  | tmp1 |  arg1 ifNil: [ ^self ].  tmp1 := arg1.  self setProperty: #paneColor toValue: tmp1.  self setStripeColorsFrom: tmp1.  self theme fadedBackgroundWindows ifFalse: [ self adoptPaneColor: tmp1 ].  self changednewGroupbox: arg1  ^self theme newGroupboxIn: self label: arg1is: arg1 aboveRow: arg2  ^arg1 < arg2withCloseBox  closeBox ifNotNil: [ closeBox delete ].  closeBox := self iconButtonCalling: #closeBoxClicked withForm: self theme menuCloseForm helpText: 'Close this menu'.  self addMorph: closeBox asElementNumber: 1menu: arg1  menuBlock := arg1nextMorphAcrossInWindow  ^(self owner notNil and: [ self owner isWorldMorph ]) ifTrue: [ self ] ifFalse: [ super nextMorphAcrossInWindow ]expandAll  self subclassResponsibilityframeRectangle6: arg1 on: arg2  | tmp1 |  tmp1 := arg1 insetBy: self width // 2.  self width odd ifTrue: [ tmp1 := tmp1 insetBy: (0 @ 0 corner: 1 @ 1) ].  arg2     line: tmp1 topLeft + (6 @ 0) to: tmp1 topRight - (6 @ 0) width: self width color: self color;     line: tmp1 topRight + (-5 @ 1) to: tmp1 topRight + (-3 @ 2) width: self width color: self color;     line: tmp1 topRight + (-2 @ 3) to: tmp1 topRight + (-2 @ 3) width: self width color: self color;     line: tmp1 topRight + (-1 @ 4) to: tmp1 topRight + (-1 @ 5) width: self width color: self color;     line: tmp1 topRight + (0 @ 6) to: tmp1 bottomRight - (0 @ 6) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 5) to: tmp1 bottomRight - (2 @ 3) width: self width color: self color;     line: tmp1 bottomRight - (3 @ 2) to: tmp1 bottomRight - (4 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (5 @ 1) to: tmp1 bottomRight - (6 @ 0) width: self width color: self color;     line: tmp1 bottomRight - (7 @ 0) to: tmp1 bottomLeft + (6 @ 0) width: self width color: self color;     line: tmp1 bottomLeft - (-5 @ 1) to: tmp1 bottomLeft - (-4 @ 1) width: self width color: self color;     line: tmp1 bottomLeft - (-3 @ 2) to: tmp1 bottomLeft - (-3 @ 2) width: self width color: self color;     line: tmp1 bottomLeft - (-2 @ 3) to: tmp1 bottomLeft - (-1 @ 5) width: self width color: self color;     line: tmp1 bottomLeft - (0 @ 6) to: tmp1 topLeft + (0 @ 6) width: self width color: self color;     line: tmp1 topLeft + (1 @ 5) to: tmp1 topLeft + (1 @ 4) width: self width color: self color;     line: tmp1 topLeft + (2 @ 3) to: tmp1 topLeft + (2 @ 3) width: self width color: self color;     line: tmp1 topLeft + (3 @ 2) to: tmp1 topLeft + (5 @ 1) width: self width color: self colordeeplyDetect: arg1  self rootNodes do: [:arg2 |  (arg2 deeplyDetect: arg1) ifNotNil: [:arg3 |  ^arg3 ] ].  ^nildelete  parent := nil.  complexContents := nil.  firstChild := nil.  container := nil.  nextSibling := nil.  controls := nil.  super deleteextraSelectionRects  ^Array streamContents: [:arg1 |  extraSelectionBlocks ifNotNil: [:arg2 |  arg2 do: [:arg3 |  arg1 nextPutAll: (self selectionRectsFrom: arg3 first to: arg3 last) ] ] ]spawnNewProcess  UIProcess := [ [ WorldMorph doOneCycle.  Processor yield.  false ] whileFalse: [  ] ] newProcess priority: Processor userSchedulingPriority.  UIProcess name: 'Morphic UI Process'.  UIProcess resumenewMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7  ^self theme newMorphDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7drawToggleOn: arg1 in: arg2  | tmp1 tmp2 |  tmp1 := self toggleImageForm.  tmp2 := ((arg2 height - tmp1 extent y) / 2.0) truncated.  ^arg1 translucentImage: tmp1 at: (arg2 topLeft translateBy: 0 @ tmp2)selectionColor  ^selectionColorkeyboardNavigationHandler  | tmp1 |  tmp1 := self valueOfProperty: #keyboardNavigationHandler ifAbsent: [ ^nil ].  (tmp1 hasProperty: #moribund) ifTrue: [ self removeProperty: #keyboardNavigationHandler.        ^nil ].  ^tmp1rightArrowStroked: arg1  (selectedItem notNil and: [ selectedItem hasSubMenu ]) ifTrue: [ arg1 hand newMouseFocus: selectedItem subMenu.        selectedItem subMenu moveSelectionDown: 1 event: arg1.        arg1 hand newKeyboardFocus: selectedItem subMenu.        ^true ].  ^falsenewHSVASelector: arg1 help: arg2  ^self theme newHSVASelectorIn: self color: arg1 help: arg2cellSize: arg1  cellSize := arg1newDataSourceMatching: arg1  ^selfgetIndexSelector: arg1  getIndexSelector := arg1cornerStyle: arg1  super cornerStyle: arg1.  self layoutInset: (self theme buttonLabelInsetFor: self)insertNewMorphs: arg1  scroller addAllMorphs: arg1magicAlpha: arg1  self setProperty: #magicAlpha toValue: arg1.  self changedcomposeAllLines  [ currCharIndex <= theText size and: [ currentY + defaultLineHeight <= theContainer bottom ] ] whileTrue: [ (nowSliding ifTrue: [ self slideOneLineDown ] ifFalse: [ self composeOneLine ]) ifNil: [ ^nil ] ]sliderShadowColor  ^Color black alpha: 0.6newCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 getLabel: arg5 help: arg6  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 getLabel: arg5 help: arg6initializeMorph  field := RubScrolledTextModel new newTextField     hResizing: #spaceFill;     autoAccept: true;     withGhostText: self ghostText;     yourself.  field model announcer when: RubTextUpdatedInModel send: #textUpdated: to: selfimages  ^images ifNil: [ images := Dictionary newFromPairs: {#off .               [ self offImage ] .               #pressed .               [ self pressedImage ] .               #on .               [ self onImage ] .               #repressed .               [ self repressedImage ifNil: [ self onImage ] ]} ]showTemporaryCursor: arg1 hotSpotOffset: arg2  self changed.  temporaryCursorOffset ifNotNil: [ bounds := bounds translateBy: temporaryCursorOffset negated ].  arg1 ifNil: [ temporaryCursor := temporaryCursorOffset := hardwareCursor := nil ] ifNotNil: [ temporaryCursor := arg1 asCursorForm.        temporaryCursorOffset := temporaryCursor offset - arg2.        (arg1 isKindOf: Cursor) ifTrue: [ hardwareCursor := arg1 ] ].  bounds := self cursorBounds.  self     layoutChanged;     changedchanged  | tmp1 tmp2 |  tmp1 := 25.  tmp2 := Time millisecondClockValue - lastRefresh >= tmp1.  super changed.  (self isInWorld and: [ tmp2 ]) ifTrue: [ self refresh ]isCheckList: arg1  self listManager isCheckList: arg1isModalInvokationDone: arg1  self setProperty: #isModalInvokationDone toValue: arg1resetWorldMenu  menuBuilder ifNotNil: [ menuBuilder reset.        menuBuilder := nil ]sortingIcon  ^self sortingStrategy sortingIconshiftedYellowButtonActivity  ^self yellowButtonActivity: trueselectPrefix: arg1  | tmp1 |  self items do: [:arg2 |  | tmp2 |        tmp2 := arg1 isEmpty or: [ arg2 contents asString asLowercase beginsWith: arg1 ].        arg2 isEnabled: tmp2.        (tmp2 and: [ tmp1 isNil ]) ifTrue: [ tmp1 := arg2 ] ].  ^tmp1imageExtent  ^self form extentchangeSelectionRequest: arg1  self updateSelectionFromModelfullscreenBounds  ^(RealEstateAgent maximumUsableAreaInWorld: self world) insetBy: self fullscreenMargintriggerSelectedColor  self triggerEvent: #selectedColor with: self selectedColorvalueOfProperty: arg1  ^extension ifNotNil: [ extension valueOfProperty: arg1 ]useFindReplaceSelection  ^falsemaximize  self isMinimized ifTrue: [ self collapseOrExpand ].  self isMaximized ifFalse: [ self expandBoxHit ]createHandleAt: arg1 color: arg2 iconName: arg3  | tmp1 tmp2 |  tmp1 := Rectangle center: arg1 extent: self handleSize asPoint.  self gradientHalo ifTrue: [ tmp2 := Morph newBounds: tmp1 color: arg2.        tmp2 borderWidth: 1.        tmp2 useRoundedCorners.        self setColor: arg2 toHandle: tmp2 ] ifFalse: [ tmp2 := EllipseMorph newBounds: tmp1 color: arg2 ].  tmp2 borderColor: arg2 muchDarker.  tmp2 wantsYellowButtonMenu: false.  arg3 ifNotNil: [ (self iconNamed: arg3) ifNotNil: [:arg4 |  | tmp3 |              tmp3 := ImageMorph new.              tmp3 form: arg4.              tmp3 color: arg2 contrastingBlackAndWhiteColor.              tmp3 lock.              tmp2 addMorphCentered: tmp3 ] ].  ^tmp2morphsAt: arg1 unlocked: arg2  | tmp1 |  tmp1 := Array new writeStream.  self morphsAt: arg1 unlocked: arg2 do: [:arg3 |  tmp1 nextPut: arg3 ].  ^tmp1 contentsintersectionsWith: arg1  | tmp1 |  tmp1 := IdentitySet new: 4.  (self bounds intersects: arg1) ifFalse: [ ^tmp1 ].  self lineSegmentsDo: [:arg2 :arg3 |  | tmp2 |        tmp2 := LineSegment from: arg2 to: arg3.        arg1 lineSegmentsDo: [:arg4 :arg5 |  | tmp3 tmp4 |              tmp3 := LineSegment from: arg4 to: arg5.              tmp4 := tmp2 intersectionWith: tmp3.              tmp4 ifNotNil: [ tmp1 add: tmp4 ] ] ].  ^tmp1chooseForSaveFileReference: arg1 extensions: arg2 path: arg3  ^self chooseForSaveFileReference: arg1 extensions: arg2 path: arg3 preview: niltestSelectableIndexBellow  self assert: (strategy selectableIndexBellow: 2) equals: 3columnMorphAt: arg1  ^controls at: arg1anyModifierKeyPressed  ^self buttons anyMask: 2r01110000ownerChanged  | tmp1 |  super ownerChanged.  container ifNotNil: [ editor ifNil: [ self releaseParagraph.              (container isKindOf: TextContainer) ifTrue: [ self installEditorToReplace: nil.                    self releaseParagraph ] ] ifNotNil: [ tmp1 := editor.              self releaseParagraph.              self installEditorToReplace: tmp1 ] ]defaultBounds  ^0 @ 0 corner: 200 @ 160adjustHeight  testSelectedRowIndex  table selectIndex: #(3 5).  self assert: strategy selectedRowIndex equals: 3.  table selectIndex: #(4 5).  self assert: strategy selectedRowIndex equals: 4printOn: arg1  super printOn: arg1.  arg1     nextPut: $[;     print: clickState;     nextPut: $]justDroppedInto: arg1 event: arg2  selectedItems isEmpty ifTrue: [ ^self extendByHand: arg2 hand ].  dupLoc ifNotNil: [ dupDelta := self position - dupLoc ].  selectedItems reverseDo: [:arg3 |  self defer: [ arg3 referencePosition: (arg1 localPointToGlobal: arg3 referencePosition).              arg1 handleDropMorph: (DropEvent new setPosition: arg2 cursorPoint contents: arg3 hand: arg2 hand) ] ].  arg2 wasHandled: trueinitialize  super initialize.  self option: #leftexpandRoots  self roots do: [:arg1 |  (arg1 canExpand and: [ arg1 isExpanded not ]) ifTrue: [ arg1 toggleExpandedState ] ].  self adjustSubmorphPositionsisCurvy  ^smoothCurve and: [ vertices size > 2 ]wantsSteps  ^falseisAdheringToTop  ^falsenewDataSourceMatching: arg1  | tmp1 |  tmp1 := items class withAll: (items collect: [:arg2 |  arg2 select: [:arg3 |  arg1 matches: (self toString: arg3) ] ]).  ^self class new items: tmp1pressedBorderStyle  ^self theme scrollbarPressedBorderStyleFor: selfmodel  ^self dataSource modelbackgroundColoringBlockOrSelector: arg1  backgroundColoringBlockOrSelector := arg1mouseUpInSlider: arg1  slider borderStyle style == #inset ifTrue: [ slider borderColor: #raised ].  sliderShadow hideinitialize  super initialize.  self     value: 1.0;     color: Color blackisDockingBar  ^truetransformedBy: arg1  self changed.  self transform: (self transform composedWithGlobal: arg1).  self computeBounds.  self changedupdateAllRows  self table isShowColumnHeaders ifTrue: [ self updateHeaderRow ] ifFalse: [ headerRow := nil ].  self updateExposedRowsopenInWorld: arg1  self bounds: (RealEstateAgent initialFrameFor: self world: arg1).  ^self openAsIsIn: arg1tabRemovedFromSelection: arg1  numberOfSelectedTabs == 1 ifTrue: [ ^self ].  numberOfSelectedTabs := numberOfSelectedTabs - 1.  selectionHistory remove: arg1.  selectionHistory add: arg1 afterIndex: selectionHistory size - numberOfSelectedTabs.  arg1 silentlySelected: false.  self adjustLayout.  self triggerEvent: #tabRemovedFromSelection with: arg1keyboardNavigationHandler: arg1  arg1 ifNil: [ self removeProperty: #keyboardNavigationHandler ] ifNotNil: [ self setProperty: #keyboardNavigationHandler toValue: arg1 ]setPredecessor: arg1  predecessor := arg1beTopWindow  | tmp1 |  tmp1 := TopWindow.  TopWindow := self.  tmp1 ifNotNil: [ tmp1 privateBePassive ].  self announceActivatedinspectElement  | tmp1 tmp2 |  tmp1 := UIManager default chooseFrom: self sortedPropertyNames values: self sortedPropertyNames title: 'Inspect which property?' translated.  tmp1 ifNil: [ ^self ].  tmp2 := otherProperties at: tmp1 ifAbsent: [ 'nOT a vALuE' ].  tmp2 = 'nOT a vALuE' ifTrue: [ (self perform: tmp1) inspect ] ifFalse: [ tmp2 inspect ]newVerticalSeparator  ^self theme newVerticalSeparatorIn: selfoptimalExtent  ^self submorphBounds extent + (self borderWidth * 2)rubberBandCells: arg1  rubberBandCells := arg1colorForInsets  ^owner ifNil: [ color ] ifNotNil: [ owner color ]removeAllMorphs  | tmp1 tmp2 |  tmp2 := self world.  (fullBounds notNil or: [ tmp2 notNil ]) ifTrue: [ self invalidRect: self fullBounds ].  submorphs do: [:arg1 |  tmp2 ifNotNil: [ arg1 outOfWorld: tmp2 ].        arg1 privateOwner: nil ].  tmp1 := submorphs.  submorphs := EmptyArray.  tmp1 do: [:arg1 |  self removedMorph: arg1 ].  self layoutChangedinitializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #WindowShortcutsbecomeActiveDuring: arg1  | tmp1 tmp2 tmp3 |  tmp1 := ActiveWorld.  tmp2 := ActiveHand.  tmp3 := ActiveEvent.  ActiveWorld := self.  ActiveHand := self hands first.  ActiveEvent := nil.  arg1 on: Error do: [:arg2 |  ActiveWorld := tmp1.        ActiveEvent := tmp3.        ActiveHand := tmp2.        arg2 pass ]beComplete  self closeunselectRow: arg1  selectedRows remove: arg1 ifAbsent: [ ^self ].  self invalidRect: (self selectionFrameForRow: arg1)minCellSize: arg1  self assureTableProperties minCellSize: arg1.  self layoutChangedmouseStillDown: arg1  actWhen == #whilePressed ifFalse: [ ^self ].  (self containsPoint: arg1 cursorPoint) ifTrue: [ self doButtonAction ]drag: arg1  dragSelector ifNotNil: [ clickClient perform: dragSelector with: arg1 ]listSpacing  ^#nonewrapCentering  ^wrapCenteringmodifyClippingBounds: arg1  | tmp1 |  tmp1 := -10.  closeIcon visible ifTrue: [ tmp1 := tmp1 - 14 ].  ^arg1 withRight: (arg1 right + tmp1) * self displayScaleFactorisExpanded  ^falserotationDegrees  ^self forwardDirectionprivateFullBounds: arg1  fullBounds := arg1newButtonRow  | tmp1 tmp2 tmp3 |  tmp2 := self newButtons.  tmp3 := 0 @ 0.  tmp2 do: [:arg1 |  tmp3 := tmp3 max: arg1 minExtent ].  tmp2 do: [:arg1 |  arg1 extent: tmp3 ].  tmp1 := Morph new     color: Color transparent;     changeTableLayout;     cellInset: 8;     listDirection: #leftToRight;     listCentering: #bottomRight;     hResizing: #spaceFill;     vResizing: #shrinkWrap.  tmp2 do: [:arg1 |  tmp1 addMorphBack: arg1 ].  ^tmp1isEasySelecting  ^worldState isEasySelectingshowDirectionHandles: arg1  self showDirectionHandles: arg1 addHandles: truemouseFocus  ^mouseFocusbounds  ^boundshandleAllowanceForIconicHalos  ^12vUnadjustedScrollRange  | tmp1 |  tmp1 := scroller localSubmorphBounds ifNil: [ ^0 ].  ^tmp1 bottomupdate: arg1  | tmp1 tmp2 |  arg1 == #width ifTrue: [ self updateWidth ].  tmp1 := 60.  tmp2 := Time millisecondClockValue - self lastRefresh >= tmp1.  (self isInWorld and: [ tmp2 ]) ifFalse: [ ^self ].  self refreshisOpen  ^closed notfillingOnOff  self fillsOwner: self fillsOwner notnewHSVSelector: arg1 help: arg2  ^self theme newHSVSelectorIn: self color: arg1 help: arg2source: arg1  source := arg1hideLocation  self locationMorph     visible: false;     changedpaneColorOrNil  ^self paneColorpredecessor  ^predecessorunexpandedFrame  ^self valueOfProperty: #unexpandedFramepressed: arg1  pressed := arg1.  self update: (getLabelSelector ifNil: [ getIconSelector ])compositionRectangle  | tmp1 |  tmp1 := self innerBounds.  tmp1 := tmp1 insetBy: margins.  tmp1 width < 9 ifTrue: [ tmp1 := tmp1 withWidth: 9 ].  tmp1 height < 16 ifTrue: [ tmp1 := tmp1 withHeight: 16 ].  ^tmp1widthForRounding  ^0roundedCorners  owner isFloating ifTrue: [ ^#(1 4) ].  owner isAdheringToTop ifTrue: [ ^#(1 4) ].  owner isAdheringToBottom ifTrue: [ ^#(2 3) ].  owner isAdheringToLeft ifTrue: [ ^#(1 2) ].  owner isAdheringToRight ifTrue: [ ^#(3 4) ].  ^#(1 2 3 4)mouseDown: arg1  arg1 yellowButtonPressed ifTrue: [ (self yellowButtonActivity: arg1 shiftPressed) ifTrue: [ ^self ] ].  self handleInteraction: [ editor mouseDown: arg1 ].  self hasKeyboardFocus ifFalse: [ self takeKeyboardFocus ].  super mouseDown: arg1defaultPageSize  ^niltextUpdated: arg1  self filterWith: field getTextFromModelthemeChanged  self color: self theme textColor.  super themeChangedwithSnapshotBorder  self borderStyle: ((ComplexBorder style: #complexFramed)           color: (Color r: 0.613 g: 1.0 b: 0.516);           width: 1;           yourself)expandItemPath: arg1  | tmp1 |  tmp1 := arg1 asOrderedCollection.  [ tmp1 notEmpty ] whileTrue: [ | tmp2 |        tmp2 := (1 to: self nodeList size) select: [:arg2 |  (self nodeList at: arg2) item = tmp1 first ].        tmp2 isEmpty ifTrue: [ ^self ].        self pager nextPage: tmp2 first.        (self allNodeMorphs at: 1 ifAbsent: [ ^self ]) openItemPath: {tmp1 first}.        tmp1 := tmp1 copyWithoutFirst ].  ^selfnewAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6 entryCompletion: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6 entryCompletion: arg7pagerHeight  ^self pager ifNil: [ 0 ] ifNotNil: [ pager computedHeight ]outOfWorld: arg1  arg1 ifNil: [ ^self ].  self submorphsDo: [:arg2 |  arg2 outOfWorld: arg1 ]activeSubmenu: arg1  activeSubMenu ifNotNil: [ activeSubMenu delete ].  activeSubMenu := arg1setTarget: arg1  (target := arg1) ifNotNil: [ offsetFromTarget := self position - target position ]children  ^childrennewPluggableDialogWindow  ^self newPluggableDialogWindow: 'Dialog'resetHandlerFields  initialize  super initialize.  self extent: self defaultWidth @ self defaultHeight.  self layoutFrame: self gripLayoutFrameborderWidth: arg1  borderColor ifNil: [ borderColor := Color black ].  borderWidth := arg1 max: 0.  self changedlabel  ^labelrowMorphForNode: arg1 inColumn: arg2  | tmp1 |  tmp1 := (arg2 container iconBlock value: arg1) notNil.  (arg2 isFirstColumn and: [ tmp1 ]) ifTrue: [ ^super rowMorphForNode: arg1 inColumn: arg2 ].  self layoutInset: arg2 container columnInset @ arg2 container rowInset.  self fitContents.  ^selfelementAt: arg1  | tmp1 |  tmp1 := arg1.  self items do: [:arg2 |  tmp1 <= arg2 size ifTrue: [ ^arg2 at: tmp1 ] ifFalse: [ tmp1 := tmp1 - arg2 size ] ].  self errorSubscriptBounds: arg1beAllFont: arg1  textStyle := TextStyle fontArray: (Array with: arg1).  self     releaseCachedState;     changedaddNodePath: arg1  self selectedNodePath: arg1hideScrollBarsIndefinitely  self hideScrollBarsIndefinitely: truecancelled  ^cancelleddoubleClickTimeout: arg1 fromMorph: arg2  ^self notify: arg1 from: arg2initialize  super initialize.  columnColors := Array with: Color transparent with: Color transparent.  rowColors := Array with: self theme backgroundColor with: self theme backgroundColor.  self borderWidth: 0selectedDisabledBorderStyle  ^self theme controlButtonSelectedDisabledBorderStyleFor: selfpanelRect  ^self innerBounds insetBy: (0 @ self labelHeight corner: 0 @ 0)handleMouseUp: arg1  arg1 wasHandled ifTrue: [ ^self ].  arg1 hand releaseMouseFocus: self.  arg1 wasHandled: true.  arg1 blueButtonChanged ifTrue: [ self blueButtonUp: arg1 ] ifFalse: [ self mouseUp: arg1 ]canBeMaximized  ^self isResizeable and: [ self isNotMaximized ]sortedPropertyNames  | tmp1 |  tmp1 := (Array new: 10) writeStream.  locked == true ifTrue: [ tmp1 nextPut: #locked ].  visible == false ifTrue: [ tmp1 nextPut: #visible ].  sticky == true ifTrue: [ tmp1 nextPut: #sticky ].  balloonText ifNotNil: [ tmp1 nextPut: #balloonText ].  externalName ifNotNil: [ tmp1 nextPut: #externalName ].  eventHandler ifNotNil: [ tmp1 nextPut: #eventHandler ].  otherProperties ifNotNil: [ otherProperties associationsDo: [:arg1 |  tmp1 nextPut: arg1 key ] ].  ^tmp1 contents sort: [:arg2 :arg3 |  arg2 <= arg3 ]currentNodelist  ^self nodeList copyFrom: 1 to: (self lastIndex min: self nodeList size)model: arg1  model ifNotNil: [ model removeDependent: self ].  arg1 ifNotNil: [ arg1 addDependent: self ].  model := arg1defaultBorderWidth  ^2delete  predecessor ifNotNil: [ predecessor setSuccessor: successor ].  successor ifNotNil: [ successor setPredecessor: predecessor.        successor recomposeChain ].  super deleteisStepping  | tmp1 |  ^(tmp1 := self world) ifNil: [ false ] ifNotNil: [ tmp1 isStepping: self ]setColumnWidthsFor: arg1  | tmp1 tmp2 tmp3 |  columnWidths ifNil: [ columnWidths := (self item: 1) collect: [:arg2 |  0 ] ].  tmp2 := (self topVisibleRowForCanvas: arg1) max: 1.  tmp3 := (self bottomVisibleRowForCanvas: arg1) max: 1.  tmp2 > tmp3 ifTrue: [ ^self ].  tmp2 to: tmp3 do: [:arg3 |  tmp1 := self item: arg3.        columnWidths := columnWidths with: tmp1 collect: [:arg4 :arg5 |  | tmp4 |              tmp4 := font widthOfStringOrText: arg5.              tmp4 > arg4 ifTrue: [ self changed.                    tmp4 ] ifFalse: [ arg4 ] ] ]localHandleKeystroke: arg1  (self editView keystrokeFromTextMorph: arg1) ifTrue: [ ^true ].  (self autoAccept and: [ arg1 keyCharacter = Character cr and: [ self crAction notNil ] ]) ifTrue: [ (self crAction isKindOf: MessageSend) ifTrue: [ self crAction value ] ifFalse: [ self crAction value: self text ].        ^true ].  arg1 keyCharacter = Character tab ifTrue: [ arg1 shiftPressed ifTrue: [ (self editView respondsTo: #navigateFocusBackward) ifTrue: [ self editView navigateFocusBackward ] ] ifFalse: [ (self editView respondsTo: #navigateFocusForward) ifTrue: [ self editView navigateFocusForward ] ].        ^true ].  ^falsecolor: arg1  colorsAtCorners  | tmp1 tmp2 tmp3 |  tmp1 := self color.  tmp2 := tmp1 lighter.  tmp3 := tmp1 darker.  ^Array with: tmp2 with: tmp3 with: tmp3 with: tmp2vExtraScrollRange  ^super vExtraScrollRange + self topHeaderHeightminHeight: arg1  arg1 ifNil: [ self removeProperty: #minHeight ] ifNotNil: [ self setProperty: #minHeight toValue: arg1 ].  self layoutChangednameSelector: arg1  nameSelector := arg1.  self updateContentsfocusColor  ^self borderStyle color contrastingBlackAndWhiteColornormalThumbFillStyle  ^self theme scrollbarNormalThumbFillStyleFor: selfpageMorph  ^self contentMorph hasSubmorphs ifTrue: [ self contentMorph submorphs first ]containsPoint: arg1 event: arg2  (self fullBounds containsPoint: arg1) ifFalse: [ ^false ].  (self containsPoint: arg1) ifTrue: [ ^true ].  self submorphsDo: [:arg3 |  (arg3 isLocked and: [ arg3 fullContainsPoint: ((arg3 transformedFrom: self) globalPointToLocal: arg1) ]) ifTrue: [ ^true ] ].  ^falsemouseOverPagingAreaButtonFillStyle  ^self theme scrollbarMouseOverBarButtonFillStyleFor: selfleftArrow  ^LeftArrownewVerticalSeparator  ^self theme newVerticalSeparatorIn: selfborderStyle  ^borderStylechangeFont  | tmp1 tmp2 |  tmp2 := FontChooser windowTitle: 'Choose a Font' for: self setSelector: #font: getSelector: self fontToUse.  self openModal: tmp2.  tmp1 := tmp2 result.  tmp1 ifNotNil: [ self font: tmp1 ]handleDropFiles: arg1  arg1 wasHandled ifTrue: [ ^self ].  (self wantsDropFiles: arg1) ifFalse: [ ^self ].  arg1 wasHandled: true.  self dropFiles: arg1dragEnabled  ^self editView dragEnabledisRestored  ^(self isMinimized or: [ self isMaximized ]) nottreeMorphClass  ^PaginatedMorphTreeMorphdrawLineToggleToTextOn: arg1 hasToggle: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  self isSoleItem ifTrue: [ ^self ].  self hasToggle ifTrue: [ ^self ].  tmp1 := self toggleRectangle.  tmp2 := tmp1 center.  tmp3 := tmp2 y - 1.  tmp6 := container treeLineWidth // 2.  tmp4 := tmp2 x - tmp6.  tmp5 := self theme.  arg1 frameRectangle: (tmp4 @ tmp3 corner: (tmp1 right + 3 + tmp6) @ (tmp3 + container treeLineWidth)) width: container treeLineWidth colors: (tmp5 treeLineColorsFrom: (self parent ifNil: [ self lineColor ] ifNotNil: [ self parent lineColor ])) dashes: self treeLineDasheswantsRoundedCorners  ^self isFullscreen ifTrue: [ false ] ifFalse: [ ^super wantsRoundedCorners ]noteNewOwner: arg1  super noteNewOwner: arg1.  self updateLayoutInDockingBarnextToFirstPoint  self isCurvy ifTrue: [ curveState ifNil: [ self coefficients ].        ^curveState second ] ifFalse: [ ^vertices second ]frameRectangle: arg1 on: arg2  | tmp1 tmp2 tmp3 |  self colors ifNil: [ ^super frameRectangle: arg1 on: arg2 ].  tmp1 := self width.  tmp1 isPoint ifTrue: [ tmp2 := tmp1 y.        tmp1 := tmp1 x ] ifFalse: [ tmp2 := tmp1 ].  1 to: tmp2 do: [:arg3 |  tmp3 := arg1 topLeft + (arg3 - 1) extent: (arg1 width - ((arg3 - 1) * 2)) @ 1.        arg2 fillRectangle: tmp3 color: (colors at: arg3).        tmp3 := arg1 bottomLeft + (arg3 @ (0 - arg3)) extent: (arg1 width - ((arg3 - 1) * 2) - 1) @ 1.        arg2 fillRectangle: tmp3 color: (colors at: colors size - arg3 + 1) ].  1 to: tmp1 do: [:arg3 |  tmp3 := arg1 topLeft + (arg3 - 1) extent: 1 @ (arg1 height - ((arg3 - 1) * 2)).        arg2 fillRectangle: tmp3 color: (colors at: arg3).        tmp3 := arg1 topRight + ((0 - arg3) @ arg3) extent: 1 @ (arg1 height - ((arg3 - 1) * 2) - 1).        arg2 fillRectangle: tmp3 color: (colors at: colors size - arg3 + 1) ]workspace: arg1  setDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundednewHSplitterAt: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := submorphs size.  tmp4 := tmp5 - arg1 + 2.  tmp1 := self submorphs at: tmp4.  tmp2 := tmp1 layoutFrame.  tmp3 := self newHSplitter.  tmp3 layoutFrame: ((tmp2 leftFraction @ tmp2 bottomFraction corner: tmp2 rightFraction @ tmp2 bottomFraction) asLayoutFrame bottomOffset: 4).  self privateAddMorph: tmp3 atIndex: tmp5 - arg1 + 2privateFullMoveBy: arg1  self privateMoveBy: arg1.  transform := transform asMorphicTransform withOffset: transform offset - arg1runLocalStepMethods  worldState runLocalStepMethodsIn: selfkeyText: arg1  keyText := arg1resetCount  countDict := Dictionary newsubmorphIndexOf: arg1  ^submorphs indexOf: arg1 ifAbsent: [ nil ]setDefaultParameters  self theme setSystemProgressMorphDefaultParameters: selfasAthensPaintOn: arg1  ^self topLeftColor = self bottomRightColor ifTrue: [ super asAthensPaintOn: arg1 ] ifFalse: [ self asTwoColorStrokePaintOn: arg1 ]addCustomMenuItems: arg1 hand: arg2  | tmp1 |  super addCustomMenuItems: arg1 hand: arg2.  arg1 addUpdating: #autoFitString target: self selector: #autoFitOnOff.  arg1 addUpdating: #wrapString target: self selector: #wrapOnOff.  arg1 add: 'text margins...' selector: #changeMargins:.  arg1 add: 'add predecessor' selector: #addPredecessor:.  arg1 add: 'add successor' selector: #addSuccessor:.  arg1 add: 'code pane menu...' selector: #yellowButtonActivity.  arg1 add: 'code pane shift menu...' selector: #shiftedYellowButtonActivity.  tmp1 := self owner.  tmp1 ifNotNil: [ tmp1 isLineMorph ifTrue: [ container ifNotNil: [ arg1 add: 'set baseline' selector: #setCurveBaseline: ] ] ifFalse: [ self fillsOwner ifFalse: [ arg1 add: 'fill owner''s shape' selector: #fillingOnOff ] ifTrue: [ arg1 add: 'rectangular bounds' selector: #fillingOnOff ].              self avoidsOcclusions ifFalse: [ arg1 add: 'avoid occlusions' selector: #occlusionsOnOff ] ifTrue: [ arg1 add: 'ignore occlusions' selector: #occlusionsOnOff ] ] ]event  ^eventclipText  | tmp1 |  tmp1 := self userString.  tmp1 ifNil: [ | tmp2 |        tmp2 := self allStringsAfter: nil.        tmp2 notEmpty ifTrue: [ tmp1 := String streamContents: [:arg1 |  tmp2 do: [:arg2 |  arg1                             nextPutAll: arg2;                             cr ] ] ] ].  tmp1 ifNil: [ self flash ] ifNotNil: [ Clipboard clipboardText: tmp1 ]borderWidth: arg1  | tmp1 |  super borderWidth: arg1.  tmp1 := 2 * arg1 + image extent min asPoint.  bounds extent = tmp1 ifFalse: [ super extent: tmp1 ]hasRubberBandCellsString  ^self rubberBandCells -> 'rubber band cells' translatedquestion: arg1  ^self question: arg1 title: 'Question' translatedcolorSelected: arg1  self aMorph color: arg1.  self triggerSelectedColorstate  ^statenodeMorphsWithAllNodeItems: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self allNodeMorphs do: [:arg2 |  arg1 do: [:arg3 |  arg2 expandPath: arg3 ] ].  self allNodeMorphs do: [:arg2 |  arg1 do: [:arg3 |  (arg2 matchPath: arg3) ifNotNil: [:arg4 |  tmp1 addAll: arg4 ] ] ].  ^tmp1 flattenedgetListElementSelector  ^getListElementSelectortasks  ^tasksmouseDownOnMultiple: arg1 forRow: arg2  | tmp1 tmp2 tmp3 tmp4 |  canMove ifFalse: [ ^self ].  canMove := false.  model okToChange ifFalse: [ canMove := true.        ^self ].  canMove := true.  dragOnOrOff := (self listSelectionAt: arg2) not.  tmp4 := dragOnOrOff.  (arg1 shiftPressed not and: [ arg1 yellowButtonPressed not and: [ self autoDeselect ] ]) ifTrue: [ self resetListSelection ].  tmp2 := self getCurrentSelectionIndex.  tmp2 ~= 0 ifTrue: [ tmp3 := self listSelectionAt: tmp2 ].  tmp1 := tmp4 ifTrue: [ arg2 ] ifFalse: [ 0 ].  setIndexSelector ifNotNil: [ model perform: setIndexSelector with: tmp1 ].  tmp2 ~= 0 ifTrue: [ self listSelectionAt: tmp2 put: tmp3 ].  arg1 shiftPressed ifTrue: [ ((tmp2 max: 1) min: arg2) to: (tmp2 max: arg2) do: [:arg3 |  self listSelectionAt: arg3 put: tmp4 ].        self changed ] ifFalse: [ self listSelectionAt: arg2 put: tmp4 ]getEnabledSelector  ^getEnabledSelectortabAmongFields  ^self theme settings tabAmongFields or: [ self hasProperty: #tabAmongFields ]rowMorphForColumn: arg1  ^self item ifNotNil: [:arg2 |  self asString asMorph ]beResizeable  isResizeable := true.  self isResizeable ifTrue: [ self addGripsIfWanted ]minHeight  ^8 max: super minHeightcanvas: arg1  self worldRenderer canvas: arg1.  damageRecorder ifNil: [ damageRecorder := DamageRecorder new ] ifNotNil: [ damageRecorder doFullRepaint ]isRadioButton: arg1  isRadioButton := arg1isResizable  ^resizablemodel: arg1  model := arg1activeSubmenu: arg1  super activeSubmenu: arg1.  arg1 ifNotNil: [ activeSubMenu activatedFromDockingBar: nil ]source  ^sourcetakesKeyboardFocus  ^falsethemeChanged  self fillStyle: self normalFillStyle.  super themeChangedprepareForRotating  ^self addFlexShellmouseLeave: arg1  oldBorderStyle ifNil: [ ^self borderNormal ].  self borderStyle: oldBorderStyle.  oldBorderStyle := nilkeyboardFocusChange: arg1  self announceKeyboardFocusChange: arg1.  paragraph ifNotNil: [ paragraph focused: arg1 ].  arg1 ifTrue: [ self hasFocus ifFalse: [ self editor ].        self editor focused: true.        self showOverEditableTextCursor.        self useFindReplaceSelection ifTrue: [ self selectionChanged ] ] ifFalse: [ editor ifNotNil: [ editor focused: false ].        self hideOverEditableTextCursor ].  self manageCursor.  self editView ifNil: [ self focusChanged ] ifNotNil: [ self editView focusChanged ].  self acceptOnFocusChange == true ifTrue: [ self editView hasUnacceptedEdits ifTrue: [ self editor accept ] ]newTreeFor: arg1 list: arg2 selected: arg3 changeSelected: arg4  ^self theme newTreeIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4rootClass  ^rootClass ifNil: [ rootClass := Object ]removeFromSelection: arg1  arg1 selected ifFalse: [ ^false ].  arg1 selected: false.  arg1 unhighlight.  self selectionUpdateFromViewWhile: [ | tmp1 |        tmp1 := self newSelectionHolderWithNodePath: nil.        self listModel selection: tmp1 ].  ^trueoption  ^optionshowCloseIcon  closeable ifTrue: [ closeIcon show ]amendSteppingStatus  self wantsSteps ifTrue: [ self arrangeToStartStepping ] ifFalse: [ self stopStepping ]shadowOffset  extension ifNil: [ ^0 @ 0 ].  ^self valueOfProperty: #shadowOffset ifAbsent: [ 0 @ 0 ]minimumExtent  ^self defaultPreviewExtent + 64hScrollBarMenuButtonPressed: arg1  ^self scrollBarMenuButtonPressed: arg1hasDirectionHandlesString  ^self wantsDirectionHandles -> 'direction handles' translatedminWidth  ^100asReadOnlyMorph  ^StringMorph contents: self textlastKeystrokes  ^lastKeystrokesactionMap  ^self updateableActionMaptoggleLocked  self lock: self isLocked notrestoreDisplayAfter: arg1  arg1 value.  self currentWorld activeHand waitButton.  self currentWorld fullRepaintNeededpressedFillStyle  ^self theme splitterPressedFillStyleFor: selfrightCenter  ^bounds rightCenterunstyledTextFrom: arg1  ^arg1initialize  | tmp1 |  super initialize.  tmp1 := self valueOfProperty: #nominalExtent ifAbsent: [ 25 @ 25 ].  self extent: tmp1newPanel  ^self theme newPanelIn: selfchooseFont  ^self chooseFont: nilscrollDeltaWidth  ^self scrollDeltaHeight // 2textAnchorType: arg1  arg1 == #document ifTrue: [ ^self removeProperty: #textAnchorType ] ifFalse: [ ^self setProperty: #textAnchorType toValue: arg1 ]adjustedCenter: arg1  self center: arg1handleListenEvent: arg1  (arg1 isMouse and: [ arg1 isMove not ]) ifFalse: [ ^self ].  arg1 hand removeMouseListener: self.  (self world ifNil: [ target world ]) ifNil: [ ^self ].  self addHandlestextAlignment  ^self editor textAlignmentdisplayWorld: arg1 submorphs: arg2  worldRenderer displayWorldState: self ofWorld: arg1 submorphs: arg2addRotateHandle: arg1  (self addHandle: arg1 on: #mouseDown send: #startRot:with: to: self) on: #mouseMove send: #doRot:with: to: selftopCenter  ^bounds topCenterhash  ^self type hashupdateableActionMap  | tmp1 |  self assureExtension.  tmp1 := extension actionMap.  tmp1 ifNil: [ tmp1 := self createActionMap.        extension actionMap: tmp1 ].  ^tmp1backgroundColor  ^self subclassResponsibilitynextState  ^self subclassResponsibilityspacer: arg1  ^Morph new     color: Color transparent;     extent: arg1 @ (self hasSubmorphs ifTrue: [ self computedHeight ] ifFalse: [ self preferedFont height + 8 ]);     yourselflocked: arg1  locked := arg1activate  self activatedModalChild ifTrue: [ ^self ].  self addPaneSplittersIfNeeded.  super activate.  self isEmbedded ifFalse: [ self basicActivate ].  self navigateFocus.  self positionModalOwnerupdate: arg1  arg1 == #refresh ifTrue: [ ^self refresh ].  ^super update: arg1drawOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  self shouldDraw ifFalse: [ ^self ].  tmp3 := SystemWindow borderWidth.  tmp2 := arg1 asAlphaBlendingCanvas: 0.7.  tmp1 := self bounds.  tmp4 := tmp1 left: tmp1 right - tmp3.  tmp4 := tmp4 top: tmp4 bottom - tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp1 right: tmp1 right - tmp3.  tmp4 := tmp4 top: tmp4 bottom - tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp4 left: tmp4 left + 7.  tmp4 := tmp4 right: tmp4 right - 7.  tmp2 fillRectangle: tmp4 color: self dotColor.  tmp4 := tmp1 left: tmp1 right - tmp3.  tmp4 := tmp4 bottom: tmp4 bottom - tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp4 top: tmp4 top + 7.  tmp4 := tmp4 bottom: tmp4 bottom - 7.  tmp2 fillRectangle: tmp4 color: self dotColorwantsDropSelector  ^wantsDropSelectorgradient  self subclassResponsibilityvisibleTabRange: arg1  visibleTabRange := arg1.  self     changed: #leftButtonEnabled;     changed: #rightButtonEnabledtabResetSelection: arg1  selectionHistory ifNotEmpty: [ (selectionHistory last: numberOfSelectedTabs) do: [:arg2 |  arg2 == arg1 ifFalse: [ arg2 silentlySelected: false ] ] ].  numberOfSelectedTabs := 1.  self addInHistory: arg1.  self adjustLayout.  self triggerEvent: #tabResetSelection with: arg1detachKeymapCategory: arg1 targetting: arg2  self kmDispatcher detachKeymapCategory: arg1 targetting: arg2avoidVisibleBordersAtEdge: arg1  avoidVisibleBordersAtEdge := arg1.  self updateLayoutPropertiesupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]contents: arg1  self privateSetContents: arg1.  self fitContentsicon: arg1  icon ifNotNil: [ self removeMorph: icon ].  arg1 ifNotNil: [ icon := arg1.        self addMorphFront: arg1 ]mouseUp: arg1  self enabled ifFalse: [ ^self perform: #mouseUp: withArguments: {arg1} inSuperclass: Morph ].  actWhen == #buttonUp ifFalse: [ ^self perform: #mouseUp: withArguments: {arg1} inSuperclass: Morph ].  (self containsPoint: arg1 cursorPoint) ifTrue: [ state == #repressed ifTrue: [ self state: #off ] ifFalse: [ self state: #on ].        self doButtonAction: arg1 ].  ^self perform: #mouseUp: withArguments: {arg1} inSuperclass: MorphmeasureFor: arg1  | tmp1 tmp2 |  tmp1 := self first.  tmp2 := 0.  1 to: arg1 do: [:arg2 |  | tmp3 |        tmp3 := self polynomialEval: arg2 / arg1 asFloat.        tmp2 := tmp2 + (tmp3 distanceTo: tmp1).        tmp1 := tmp3 ].  ^tmp2setSlider: arg1 withShadow: arg2  slider ifNotNil: [ self removeMorph: slider ].  sliderShadow ifNotNil: [ self pagingArea removeMorph: sliderShadow ].  slider := arg1.  sliderShadow := arg2.  slider on: #mouseMove send: #scrollAbsolute: to: self.  slider on: #mouseDown send: #mouseDownInSlider: to: self.  slider on: #mouseUp send: #mouseUpInSlider: to: self.  self pagingArea addMorph: sliderShadow.  sliderShadow hide.  self addMorph: slider.  self computeSliderenabledString  ^self enabled -> 'enabled' translatedmodel  ^modelinterimContents: arg1  self contents: arg1selectedRow: arg1  selectedRow ifNotNil: [ self selectionFrameChanged ].  selectedRow := arg1.  selectedRow ifNotNil: [ self selectionFrameChanged ]deepCopy  | tmp1 |  tmp1 := self copy.  tmp1 textStyle: textStyle copy lines: lines copy text: text deepCopy.  ^tmp1rightButtonEnabled  ^self wrapScrolling or: [ self visibleTabRange last < self tabs size ]setType: arg1 buttons: arg2 position: arg3 keyValue: arg4 charCode: arg5 hand: arg6 stamp: arg7  type := arg1.  buttons := arg2.  position := arg3.  keyValue := arg4.  charCode := arg5.  source := arg6.  wasHandled := false.  timeStamp := arg7discoveredMenuTitle  ^self class discoveredMenuTitlenudgeForLabel: arg1  | tmp1 tmp2 tmp3 |  (self bounds intersects: arg1) ifFalse: [ ^0 @ 0 ].  tmp2 := 0.  tmp3 := 0 @ 0.  tmp1 := 1.  arg1 lineSegmentsDo: [:arg2 :arg3 |  | tmp4 |        tmp4 := LineSegment from: arg2 to: arg3.        self straightLineSegmentsDo: [:arg4 :arg5 |  | tmp5 tmp6 |              tmp5 := LineSegment from: arg4 to: arg5.              tmp6 := tmp5 intersectionWith: tmp4.              tmp6 ifNotNil: [ tmp2 := tmp2 bitOr: tmp1 ] ].        tmp1 := tmp1 * 2 ].  tmp3 := tmp2 caseOf: {([ 0 ] -> [ 0 @ 0 ]) .         ([ 9 ] -> [ 1 @ 1 ]) .         ([ 3 ] -> [ -1 @ 1 ]) .         ([ 12 ] -> [ 1 @ -1 ]) .         ([ 6 ] -> [ -1 @ -1 ]) .         ([ 10 ] -> [ 0 @ -1 ]) .         ([ 5 ] -> [ 1 @ 0 ]) .         ([ 8 ] -> [ -1 @ 0 ]) .         ([ 1 ] -> [ 0 @ -1 ]) .         ([ 2 ] -> [ 1 @ 0 ]) .         ([ 4 ] -> [ 0 @ 1 ]) .         ([ 11 ] -> [ 0 @ 1 ]) .         ([ 13 ] -> [ 1 @ 0 ]) .         ([ 14 ] -> [ 0 @ -1 ]) .         ([ 7 ] -> [ -1 @ 0 ]) .         ([ 15 ] -> [ 1 @ -1 ])}.  ^tmp3enabled  ^self sliderMorph ifNil: [ super enabled ] ifNotNil: [:arg1 |  arg1 enabled ]initialize  super initialize.  tabs := OrderedCollection new.  selectionHistory := OrderedCollection new.  menuButton := self createMenuButton.  numberOfSelectedTabs := 1.  self changeProportionalLayout.  self addMenuButtonbuildToggleButton  ^PluggableToggleButtonMorph on: self getState: nil action: #toggleAction: label: #label menu: niladdToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 enablementSelector: arg5  self addToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 enablementSelector: arg5 argumentList: EmptyArrayhelpText  ^model helpTextbackgroundMorph: arg1  self backgroundMorph ifNotNil: [ self backgroundMorph delete ].  backgroundMorph := arg1.  arg1 ifNotNil: [ arg1 bounds: self bounds.        self addMorphBack: arg1 ]buildButtonWithIconBottom  ^(PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: nil) beIconBottomupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]containsPoint: arg1  (bounds containsPoint: arg1) ifFalse: [ ^false ].  self hasSubmorphs ifTrue: [ | tmp1 |        tmp1 := transform globalPointToLocal: arg1.        self submorphsDo: [:arg2 |  (arg2 containsPoint: tmp1) ifTrue: [ ^true ] ].        ^false ] ifFalse: [ ^true ]rowAndColumnIndexContainingPoint: arg1  self exposedRows keysAndValuesDo: [:arg2 :arg3 |  (arg3 bounds containsPoint: arg1) ifTrue: [ arg3 submorphs withIndexDo: [:arg4 :arg5 |  (arg4 bounds containsPoint: arg1) ifTrue: [ ^{arg2 .                           arg5} ] ] ] ].  ^{nil .   nil}startStepping: arg1 at: arg2 selector: arg3 arguments: arg4 stepTime: arg5  worldState startStepping: arg1 at: arg2 selector: arg3 arguments: arg4 stepTime: arg5table  ^tableindex  ^indexrememberKeyboardFocus: arg1  (arg1 isNil or: [ (arg1 hasOwner: self) not ]) ifFalse: [ self setProperty: #rememberedFocus toValue: arg1 ]filterClass  ^filterClassfont: arg1  font == arg1 ifTrue: [ ^self ].  font := arg1.  self updateFontopenInWorld: arg1 extent: arg2  self     position: (RealEstateAgent initialFrameFor: self initialExtent: arg2 world: arg1) topLeft;     extent: arg2.  ^self openAsIsIn: arg1minExtentOf: arg1 in: arg2  | tmp1 |  tmp1 := 0 @ 0.  arg1 submorphsDo: [:arg3 |  | tmp2 tmp3 |        tmp2 := arg3 minExtent.        tmp3 := arg3 layoutFrame.        tmp3 ifNotNil: [ tmp2 := tmp3 minExtentFrom: tmp2 ].        tmp1 := tmp1 max: tmp2 ].  ^tmp1isKeystroke  ^self type == #keystrokeselectPath: arg1 in: arg2  arg1 isEmpty ifTrue: [ ^self setSelectedMorph: nil ].  arg2 withSiblingsDo: [:arg3 |  arg3 complexContents item = arg1 first ifTrue: [ arg3 isExpanded ifFalse: [ arg3 toggleExpandedState.                    self adjustSubmorphPositions ].              arg3 changed.              arg1 size = 1 ifTrue: [ ^self setSelectedMorph: arg3 ].              arg3 firstChild ifNil: [ ^self setSelectedMorph: nil ].              ^self selectPath: arg1 allButFirst in: arg3 firstChild ] ].  ^self setSelectedMorph: nilprivateSetContents: arg1  | tmp1 |  contents := arg1 isText ifTrue: [ tmp1 := StringMorphAttributeScanner new initializeFromStringMorph: self.        (arg1 attributesAt: 1 forStyle: self font textStyle) do: [:arg2 |  arg2 emphasizeScanner: tmp1 ].        emphasis := tmp1 emphasis.        font := tmp1 font emphasis: emphasis.        color := tmp1 textColor.        arg1 string ] ifFalse: [ contents = arg1 ifTrue: [ ^self ].        arg1 ]isBrick  ^falsenewString: arg1 style: arg2  ^self theme newStringIn: self label: arg1 font: self theme labelFont style: arg2doScrollByPage  (self waitForDelay1: 300 delay2: 100) ifFalse: [ ^self ].  nextPageDirection ifTrue: [ self setValue: (value + pageDelta min: 1.0) ] ifFalse: [ self setValue: (value - pageDelta max: 0.0) ]autoAction  ^firstClickedMorph ifNotNil: [ firstClickedMorph selected ifTrue: [ #addToSelection: ] ifFalse: [ #removeFromSelection: ] ]isRowIndexSelected: arg1  self deprecated: 'Use #isIndexSelected: instead' transformWith: '`@receiver isRowIndexSelected: `@statements1' -> '`@receiver isIndexSelected: `@statements1'.  ^self isIndexSelected: arg1extent: arg1  | tmp1 |  self bounds extent = arg1 ifTrue: [ ^self ].  tmp1 := (arg1 - self extent) // 2.  self fillStyles do: [:arg2 |  arg2 isOrientedFill ifTrue: [ arg2 origin: arg2 origin + tmp1 ] ].  super extent: arg1defaultWorldColor  ^self class defaultWorldColortable  ^self ownerdefaultTreeMorph  ^super defaultTreeMorph     multiSelection: true;     autoMultiSelection: true;     yourselfnormalFillStyle  ^self theme scrollbarNormalFillStyleFor: selfresetAlpha  alpha := 1.0selector: arg1  selector := arg1basicTaskThumbnailOfSize: arg1  ^super taskThumbnailOfSize: arg1minExtentOf: arg1 in: arg2  | tmp1 tmp2 |  cachedMinExtent ifNotNil: [ ^cachedMinExtent ].  arg1 submorphs ifEmpty: [ ^arg1 minWidth @ arg1 minHeight ].  tmp2 := 0 @ 0.  cachedMinExtents := arg1 submorphs collect: [:arg3 |  | tmp3 |        tmp3 := arg3 minExtent.        tmp2 := (tmp2 x + tmp3 x) @ (tmp2 y max: tmp3 y).        tmp3 ].  tmp1 := arg1 assureTableProperties.  ^cachedMinExtent := tmp2 + (((arg1 submorphs size - 1) * (tmp1 cellInset isPoint ifTrue: [ tmp1 cellInset x ] ifFalse: [ tmp1 cellInset ])) @ 0)wantsToBeTopmost  ^trueselectionFrame  | tmp1 |  tmp1 := self bounds: self bounds in: container.  tmp1 := self bounds: ((tmp1 left: container innerBounds left) right: container innerBounds right) from: container.  ^tmp1modifierString  | tmp1 |  tmp1 := ''.  self commandKeyPressed ifTrue: [ tmp1 := tmp1 , 'CMD ' ].  self shiftPressed ifTrue: [ tmp1 := tmp1 , 'SHIFT ' ].  self controlKeyPressed ifTrue: [ tmp1 := tmp1 , 'CTRL ' ].  ^tmp1last  ^lastIndexboundsWithinCorners  ^self bounds insetBy: 2actionSelector  ^actionSelectorgetListSizeSelector: arg1  self dataSource getListSizeSelector: arg1releaseCachedState  super releaseCachedState.  lastSketchForm := lastFormShown := nilinitializeWithHorizontalScrollBar  horizontalScrollBar := true.  self initializenewToolbar: arg1  ^self theme newToolbarIn: self for: arg1updateFont  self tabs do: [:arg1 |  arg1 font: self font ].  self updateTabstestAsLayoutFrame  | tmp1 |  tmp1 := #(0.66 0.5 1 0.77 1 2 3 25) asLayoutFrame.  self assert: tmp1 leftFraction equals: 0.66.  self assert: tmp1 topFraction equals: 0.5.  self assert: tmp1 leftOffset equals: 1.  self assert: tmp1 topOffset equals: 2.  self assert: tmp1 rightFraction equals: 1.  self assert: tmp1 bottomFraction equals: 0.77.  self assert: tmp1 rightOffset equals: 3.  self assert: tmp1 bottomOffset equals: 25measureContents  | tmp1 |  tmp1 := self fontToUse.  ^(((tmp1 widthOfString: contents) max: self minimumWidth) @ tmp1 height + (self layoutInset * 2)) ceilingstopStepping: arg1 selector: arg2  lastStepMessage ifNotNil: [ (lastStepMessage receiver == arg1 and: [ lastStepMessage selector == arg2 ]) ifTrue: [ lastStepMessage := nil ] ].  stepList removeAll: (stepList select: [:arg3 |  arg3 receiver == arg1 and: [ arg3 selector == arg2 ] ])newImage: arg1  ^self theme newImageIn: self form: arg1rowIndexFrom: arg1  ^arg1 firstis: arg1 afterColumn: arg2  ^falseaddGraphicalHandle: arg1 at: arg2 on: arg3 send: arg4 to: arg5  | tmp1 |  tmp1 := self addGraphicalHandleFrom: arg1 at: arg2.  tmp1 on: arg3 send: arg4 to: arg5.  tmp1 setBalloonText: (target balloonHelpTextForHandle: tmp1) translated.  ^tmp1characterBlockAtPoint: arg1  | tmp1 |  tmp1 := lines at: (self lineIndexForPoint: arg1).  ^(CharacterBlockScanner new text: text textStyle: textStyle) characterBlockAtPoint: arg1 index: nil in: tmp1pageSize: arg1  self pager ifNil: [ arg1 ifNotNil: [ self addNavigationPane: (MorphTreePager on: self pageSize: arg1) ] ] ifNotNil: [ arg1 ifNil: [ self removePager ] ifNotNil: [ self pager changePageSize: arg1 ] ]label  ^labelopenAsIsIn: arg1  super openAsIsIn: arg1.  self allMorphs do: [:arg2 |  arg2 layoutChanged ]morph  ^morphanimateClose  | tmp1 tmp2 tmp3 tmp4 |  self isMinimized ifTrue: [ ^self ].  tmp2 := self bounds.  tmp1 := tmp2 scaledAndCenteredIn: (0 @ 0 extent: 20 @ 20).  tmp1 := tmp1 align: tmp1 center with: tmp2 center.  tmp4 := self theme numberOfStepsForAnimations.  tmp3 := ((tmp4 - 1) / tmp4 to: 0 by: -1 / tmp4) collect: [:arg1 |  tmp1 interpolateTo: tmp2 at: ((20 raisedTo: arg1) - 1) / 19 ].  self currentWorld displayWorldSafely.  self fastAnimateRectangles: tmp3textStyle  ^textStylecontainsPoint: arg1  ^self bounds containsPoint: arg1collapsedButton  ^self defaultButton     actionSelector: #expandItem;     labelGraphic: Smalltalk ui theme treeUnexpandedForm;     helpText: 'Expand Item';     yourselfupdateScrollbars  self     vUpdateScrollbar;     hUpdateScrollbar;     setScrollDeltashasExtension  ^extension notNilrowMorphAt: arg1  ^self submorphs seconds submorphs at: arg1selectableIndexBefore: arg1  ^{arg1 first .   (arg1 second - 1)}stringBoundsToUse  ^self bounds left: self left + 4privateInvalidateMorph: arg1  arg1 fullBounds.  arg1 changedhalosEnabled  ^self class halosEnabledselectedNodes  ^self lastSelectedNode ifNotNil: [:arg1 |  OrderedCollection with: arg1 ] ifNil: [ OrderedCollection new ]downImage  ^self class arrowOfDirection: (bounds isWide ifTrue: [ #right ] ifFalse: [ #bottom ]) size: (self buttonExtent x min: self buttonExtent y) color: self buttonImageColorlineIndexForCharacter: arg1  ^(self fastFindFirstLineSuchThat: [:arg2 |  arg2 first > arg1 ]) - 1 max: 1basicGetListElementSelector: arg1  self getListElementSelector: arg1newFuzzyLabel: arg1  ^self theme newFuzzyLabelIn: self for: nil label: arg1 offset: 1 alpha: 0.5 getEnabled: niladdDupHandle: arg1  self addHandle: arg1 on: #mouseDown send: #doDup:with: to: selfuserString  ^String streamContents: [:arg1 |  1 to: self getListSize do: [:arg2 |  arg1                 nextPutAll: (self getListItem: arg2);                 cr ] ]registerBarActions  toolbar     when: #tabSelected send: #tabSelected: to: self;     when: #barDeleted send: #barDeleted: to: self;     when: #tabsChanged send: #tabsChanged to: self;     when: #tabRefreshed send: #tabRefreshed: to: self;     when: #tabAddedToSelection send: #tabAddedToSelection: to: self;     when: #tabRemovedFromSelection send: #tabRemovedFromSelection: to: self;     when: #tabResetSelection send: #tabResetSelection: to: self;     when: #tabEmptyContents send: #tabEmptyContents: to: selfhelpText: arg1  self setBalloonText: arg1newBalloonHelp: arg1 for: arg2  ^self theme newBalloonHelpIn: self contents: arg1 for: arg2 corner: #bottomLeftbeMultiple  self listManager multipleSelection: truehaloEnclosesFullBounds  ^self class haloEnclosesFullBoundselementsForTestDataSource  ^#(2 4 7 1 5 8 6 9 10 3)updateUpButtonImage  upButton removeAllMorphs.  upButton addMorphCentered: (ImageMorph new form: self upImage)bottomLeftCorner  ^self intersectionWithLineSegmentFromCenterTo: bounds bottomLeftfont  self textStyle fonts ifEmpty: [ ^TextStyle defaultFont ].  ^self textStyle defaultFonthorizontal  ^self orientation == #horizontalon: arg1 selected: arg2 changeSelected: arg3  self     model: arg1;     getStateSelector: arg2;     setStateSelector: arg3;     updateSelectionopenInWorld  self openInWorld: self currentWorldextraSelectionChanged  refreshExtraSelection := trueshowWhenNeeded  self showState: #whenNeededenabled: arg1  enabled := arg1.  self submorphsDo: [:arg2 |  arg2 allMorphsDo: [:arg3 |  (arg3 respondsTo: #enabled:) ifTrue: [ arg3 enabled: arg1 ] ] ].  self changed: #enabled.  self changedicon: arg1  icon ifNotNil: [ self removeMorph: icon ].  icon := arg1 asAlphaImageMorph.  arg1 ifNotNil: [ self addMorphFront: icon.        self adjustLayoutBounds ]model: arg1  model ifNotNil: [ model removeDependent: self ].  arg1 ifNotNil: [ arg1 addDependent: self ].  model := arg1newTabGroup: arg1  ^self theme newTabGroupIn: self for: arg1lock  self lock: truescrollPageInit: arg1  self resetTimer.  self setNextDirectionFromEvent: arg1.  self scrollBarAction: #doScrollByPage.  self doScrollByPage.  pagingArea     fillStyle: self pressedFillStyle;     borderStyle: self pressedBorderStyle.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nilacceptDroppingMorph: arg1 event: arg2  self addMorphFront: arg1 fromWorldPosition: arg1 positionaddTitle: arg1  self buildTitle: [:arg2 |  arg2 title: arg1 ]labelGap  ^2showColumnHeaders  showColumnHeaders ifTrue: [ ^self ].  showColumnHeaders := true.  self refreshsmall  ^15fullRepaintNeeded  worldState doFullRepaint.  self windowsSatisfying: [:arg1 |  arg1 makeMeVisible.        false ]depth: arg1  depth := arg1centeredAlert: arg1 title: arg2 configure: arg3  ^self theme centeredAlertIn: self text: arg1 title: arg2 configure: arg3drawErrorOn: arg1  arg1 frameAndFillRectangle: bounds fillColor: Color red borderWidth: 1 borderColor: Color yellow.  arg1 line: bounds topLeft to: bounds bottomRight width: 1 color: Color yellow.  arg1 line: bounds topRight to: bounds bottomLeft width: 1 color: Color yellow.  self valueOfProperty: #drawError ifPresentDo: [:arg2 |  | tmp1 tmp2 |        tmp1 := String streamContents: [:arg3 |  arg2 signalerContext shortDebugStackOn: arg3 ].        tmp2 := bounds insetBy: 5.        tmp1 linesDo: [:arg4 |  arg1 drawString: arg4 in: tmp2.              tmp2 := tmp2 top: tmp2 top + (TextStyle defaultFont pixelSize * 1.2) ] ]setIndexSelector  ^setIndexSelectorselectRow: arg1  selectedRows add: arg1.  self invalidRect: (self drawBoundsForRow: arg1)testNilExtensionOnDraw  | tmp1 |  tmp1 := Morph new.  self assert: tmp1 hasExtension not.  tmp1 imageForm.  self assert: tmp1 hasExtension notanimationForMoveSuccess: arg1  | tmp1 tmp2 tmp3 |  arg1 ifTrue: [ ^self ] ifFalse: [ tmp1 := self fullBounds origin.        tmp2 := self formerPosition ifNil: [ self source bounds origin ] ].  tmp1 = tmp2 ifTrue: [ ^self ].  tmp3 := self imageForm offset: 0 @ 0.  tmp3 slideWithFirstFrom: tmp1 to: tmp2 nSteps: 12 delay: 20normalButtonFillStyle  ^self theme scrollbarNormalButtonFillStyleFor: selfthemeChanged  super themeChanged.  self subMenu ifNotNil: [:arg1 |  arg1 themeChanged ]nextDuplicateVertexIndex  vertices doWithIndex: [:arg1 :arg2 |  ((arg2 between: 2 and: vertices size - 1) and: [ | tmp1 tmp2 tmp3 |              tmp2 := vertices at: arg2 - 1.              tmp3 := vertices at: arg2 + 1.              tmp1 := ((tmp2 x - tmp3 x) abs max: (tmp2 y - tmp3 y) abs) // 32 max: 1.              arg1 onLineFrom: tmp2 to: tmp3 within: tmp1 ]) ifTrue: [ ^arg2 ] ].  ^0getChildrenSelector: arg1  getChildrenSelector := arg1table  ^tablelineColorBlock: arg1  lineColorBlock := arg1cursorWrapped: arg1  self setProperty: #textCursorLocation toValue: (arg1 rounded - 1) \\ text string size + 1center: arg1 with: arg2  self topOffset: (arg2 height - arg1 height) // 2.  self leftOffset: (arg2 width - arg1 width) // 2defaultBalloonFont  ^BalloonMorph balloonFontenabled: arg1  self sliderMorph ifNotNil: [:arg2 |  arg2 enabled: arg1 ].  self     changed: #enabled;     changed: #minEnabled;     changed: #maxEnabledmouseUp: arg1  arg1 hand showTemporaryCursor: nil.  self updateSelectedLocation.  self locationMorph visible: trueblueButtonChanged  ^whichButton anyMask: self class blueButtoncollapseAll: arg1  | tmp1 |  arg1 toggleExpandedState.  tmp1 := OrderedCollection new: 10.  arg1 recursiveAddTo: tmp1.  tmp1 do: [:arg2 |  arg2 isExpanded ifTrue: [ self collapseAll: arg2 ] ]closeAllWindowsDiscardingChanges  self currentWorld systemWindows do: [:arg1 |  [ arg1 delete ] valueSupplyingAnswer: false ]initialize  super initialize.  hands := Array new.  damageRecorder := DamageRecorder new.  stepList := Heap sortBlock: self stepListSortBlock.  lastStepTime := 0.  lastAlarmTime := 0rootNodeClassFromItem: arg1  ^MorphTreeNodeModellimit  ^limitmouseOverBorderStyle  ^self theme buttonMouseOverBorderStyleFor: selfmakeForwardArrow  arrows := #forward.  self computeBoundspressedFillStyle  ^self theme splitterPressedFillStyleFor: selfwindowIndex  ^windowIndexremoveTopHeader  topHeader ifNotNil: [ self removeMorph: topHeader.        topHeader := nil ]checkMorphsLeftOrTopFrom: arg1 size: arg2  | tmp1 |  tmp1 := submorphs identityIndexOf: arg1.  tmp1 := tmp1 + 1.  [ tmp1 <= arg2 ] whileTrue: [ | tmp2 tmp3 |        tmp2 := submorphs at: tmp1.        arg1 addLeftOrTop: tmp2.        tmp3 := self isResizeableMorph: tmp2 forSplitter: arg1.        tmp3 ifTrue: [ tmp1 := arg2 + 1 ].        tmp1 := tmp1 + 1 ]labelMorph  ^labelMorphaddCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  arg1 addLine.  arg1 add: 'Edit label...' selector: #relabelinspectItem  self inspectkeyStroke: arg1 from: arg2  | tmp1 |  tmp1 := arg1 keyCharacter.  tmp1 = $b ifTrue: [ self browseItem.        ^true ].  tmp1 = $i ifTrue: [ self inspectItem.        ^true ].  tmp1 = $I ifTrue: [ self exploreItem.        ^true ].  ^falseaddIndendtation: arg1  indentation := indentation + arg1 + self cellInsetaddChildrenForList: arg1 addingTo: arg2 withExpandedItems: arg3  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg4 |  arg4 delete ] ].  firstChild := nil.  complexContents hasContents ifFalse: [ ^self ].  firstChild := arg1 addMorphsTo: arg2 from: complexContents contents allowSorting: true withExpandedItems: arg3 atLevel: indentLevel + 1newOverflowRowForAll: arg1  ^self theme newOverflowRowIn: self forAll: arg1morph  ^morphdrawToggleOn: arg1 in: arg2  | tmp1 tmp2 |  complexContents hasContents ifFalse: [ ^self ].  tmp1 := isExpanded ifTrue: [ container expandedFormForMorph: self ] ifFalse: [ container notExpandedFormForMorph: self ].  tmp2 := ((arg2 height - tmp1 extent y) / 2.0) truncated.  ^arg1 translucentImage: tmp1 at: (arg2 topLeft translateBy: 0 @ tmp2)addToggleItemsToHaloMenu: arg1  #(#(#resistsRemovalString #toggleResistsRemoval 'whether I should be reistant to easy deletion via the pink X handle' true) #(#stickinessString #toggleStickiness 'whether I should be resistant to a drag done by mousing down on me' true) #(#lockedString #lockUnlockMorph 'when "locked", I am inert to all user interactions' true) #(#hasClipSubmorphsString #changeClipSubmorphs 'whether the parts of objects within me that are outside my bounds should be masked.' false) #(#hasDirectionHandlesString #changeDirectionHandles 'whether direction handles are shown with the halo' false) #(#hasDragAndDropEnabledString #changeDragAndDrop 'whether I am open to having objects dropped into me' false)) do: [:arg2 |  arg1 addUpdating: arg2 first selector: arg2 second.        arg1 balloonTextForLastItem: arg2 third translated ].  self couldHaveRoundedCorners ifFalse: [ ^self ].  arg1 addUpdating: #roundedCornersString selector: #toggleCornerRounding.  arg1 balloonTextForLastItem: 'whether my corners should be rounded' translatednewMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7  ^self theme newMorphDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7addToggle: arg1 target: arg2 selector: arg3  self addToggle: arg1 target: arg2 selector: arg3 getStateSelector: nil argumentList: EmptyArraymorphicLayerNumber  ^11visibleBounds  ^self header bounds withBottom: self container scroller bottomlayoutChanged  self computeBounds.  super layoutChangedbeCheckList  self isCheckList: trueselectedItems  ^selection ifNil: [ OrderedCollection new ] ifNotNil: [ selection selectedItems ]change: arg1  action ifNil: [ ^self ].  arg1 perform: action withEnoughArguments: self argumentsremoveAllHandlesBut: arg1  submorphs copy do: [:arg2 |  arg2 == arg1 ifFalse: [ arg2 delete ] ]alwaysHideHScrollbar  ^self class alwaysHideHScrollbarminHeight  ^self fontToUse height max: super minHeightmodel  ^modeltarget: arg1  target := arg1extent: arg1  | tmp1 |  tmp1 := super extent: arg1.  date notNil ifTrue: [ self computeDays ].  ^tmp1handlesMouseDown: arg1  ^self isEmbedded notrootClass: arg1  rootClass := arg1label: arg1 font: arg2  label ifNotNil: [ label delete ].  label := StringMorph contents: arg1 font: (arg2 ifNil: [ StandardFonts buttonFont ]).  self extent: (label width + 6) @ (label height + 6).  label position: self center - (label extent // 2).  self addMorph: label.  label lockisMouseWheel  ^falsesetSelectionListSelector: arg1  setSelectionListSelector := arg1topFraction: arg1  topFraction := arg1borderStyleToUse  ^self perform: (self availableBorderStyles at: (self interactionStates indexOf: self interactionState))transferFor: arg1 from: arg2  ^(self model transferFor: arg1 from: self table) buildWithSpectestSelectAll  self subclassResponsibilityactiveHand  ^worldState activeHandhResizeScrollBar  | tmp1 tmp2 |  (self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ]) ifTrue: [ ^self ].  bounds ifNil: [ self fullBounds ].  tmp2 := self scrollBarThickness.  tmp1 := bounds bottomLeft + (borderWidth @ (tmp2 + borderWidth) negated).  hScrollBar bounds: (tmp1 extent: self hScrollBarWidth @ tmp2)green: arg1  | tmp1 |  tmp1 := self selectedColor.  self selectedColor: ((Color r: tmp1 red * 255 g: arg1 b: tmp1 blue * 255 range: 255) alpha: tmp1 alpha)listSpacing  ^listSpacingdisabledFillStyle  ^self theme buttonDisabledFillStyleFor: selfinitializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigationverticalScrollBarWidth  self isVerticalScrollBarVisible ifFalse: [ ^0 ].  ^self scrollBarThicknesssetSelectedMorph: arg1  self listManager setSelectedMorph: arg1isSortEnabled  ^self sortingStrategy isSortingEnablednewHScrollbar  ^GeneralScrollBar new     model: self;     setValueSelector: #hScrollbarValue:closeBoxHit  self allowedToClose ifFalse: [ ^self ].  self playCloseSound.  self closescheduledTime  ^scheduledTimetitle: arg1  super title: arg1.  label fitContents.  self minimumExtent: ((label width + 20 min: Display width // 2) max: self minimumExtent x) @ self minimumExtent ygetEnabledSelector: arg1  getEnabledSelector := arg1.  self updateEnabledindicateModalChildForMorph: arg1  (self buttonForMorph: arg1) ifNotNil: [:arg2 |  arg2 indicateModalChild ]blueButtonDown: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 hand halo.  tmp3 := false.  tmp1 ifNotNil: [ tmp1 innerTarget == self ifTrue: [ tmp3 := true ].        (tmp1 innerTarget hasOwner: self) ifTrue: [ tmp3 := true ].        (self hasOwner: tmp1 target) ifTrue: [ tmp3 := true ] ].  tmp2 := (self transformedFrom: nil) inverseTransformation.  tmp1 := self addHalo: (arg1 transformedBy: tmp2).  tmp1 ifNil: [ ^self ].  tmp3 ifTrue: [ ^self ].  arg1 hand waitForClicksOrDrag: tmp1 event: (arg1 transformedBy: tmp2) selectors: {nil .         nil .         nil .         #dragTarget:} threshold: 5.  arg1 hand newMouseFocus: tmp1chooseAlignment  self editor changeAlignment.  self updateFromParagraphcheckSession  handlesMouseOver: arg1  ^self mouseOverAllowednotOnFirstPage  ^self onFirstPage notstop: arg1  lastIndex := arg1setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigidoffColor: arg1  offColor := arg1defaultDesktopCommandKeyTriplets  self flag: #problem.  ^{{$r .   self currentWorld .   #restoreMorphicDisplay .   'Redraw the screen'} .   {$b .   Smalltalk tools browser .   #open .   'Open a new System Browser'} .   {$k .   Smalltalk tools workspace .   #open .   'Open a new, blank Workspace'} .   {$t .   Smalltalk tools transcript .   #open .   'Make a System Transcript visible'} .   {$W .   Smalltalk tools finder .   #open .   'Open a new Finder'} .   {$Z .   Smalltalk tools changeList .   #browseRecentLog .   'Browse recently-logged changes'} .   {$\ .   SystemWindow .   #sendTopWindowToBack .   'Send the top window to the back'}}getSelectionListSelector: arg1  getSelectionListSelector := arg1isEasySelecting  ^falsefield  ^fieldisPartialMatch  | tmp1 |  tmp1 := false.  self contents do: [:arg1 |  (arg1 selected or: [ arg1 isPartialMatch ]) ifTrue: [ tmp1 := true ] ].  ^tmp1changeLayoutInset: arg1  | tmp1 |  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  self layoutInset: (arg2 - arg1 cursorPoint) asIntegerPoint // 5 ].  arg1 hand attachMorph: tmp1.  tmp1 startSteppingvUnadjustedScrollRange  scroller submorphs size > 0 ifFalse: [ ^0 ].  ^scroller submorphs last fullBounds bottomremoveAllMorphsIn: arg1  | tmp1 tmp2 |  tmp1 := IdentitySet new: arg1 size * 4 // 3.  arg1 do: [:arg2 |  arg2 owner == self ifTrue: [ tmp1 add: arg2 ] ].  tmp2 := self world.  (fullBounds notNil or: [ tmp2 notNil ]) ifTrue: [ self invalidRect: self fullBounds ].  tmp1 do: [:arg3 |  tmp2 ifNotNil: [ arg3 outOfWorld: tmp2 ].        arg3 privateOwner: nil ].  submorphs := submorphs reject: [:arg2 |  tmp1 includes: arg2 ].  tmp1 do: [:arg3 |  self removedMorph: arg3 ].  self layoutChangedmouseOverFillStyle  ^self theme scrollbarMouseOverFillStyleFor: selfnewButtonMorph  | tmp1 |  tmp1 := TickSelectionCheckboxButtonMorph new     target: self;     actionSelector: #toggleSelected;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap.  tmp1 index: index.  ^tmp1enabled: arg1  enabled = arg1 ifTrue: [ ^self ].  enabled := arg1.  self updateLabelEnablement.  self changeddismissMorph: arg1  self dismissMorphtestSelectFirst  table selectFirst.  self assert: table selectedIndexes equals: #(1)pressedFillStyle  ^self theme controlButtonPressedFillStyleFor: selfselectedRowIndex: arg1  self deprecated: 'Use #selectedIndex: instead' transformWith: '`@receiver selectedRowIndex: `@statements1' -> '`@receiver selectedIndex: `@statements1'.  self selectedIndex: arg1extent: arg1  super extent: arg1.  self listMorph width: (self innerBounds width max: listMorph hUnadjustedScrollRange)selectIndex: arg1 event: arg2  self subclassResponsibilityisHandMorph  ^truecolumnDropUnabled  ^columnDropUnabled ifNil: [ columnDropUnabled := false ]mouseDown: arg1  | tmp1 |  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: arg1 cursorPoint) ifTrue: [ oldColor := self color.        self setGrabbedColor ].  tmp1 := arg1 cursorPoint.  lastMouse := {tmp1 .   (tmp1 - self position)}kmDispatcher  ^self valueOfProperty: #kmDispatcher ifAbsentPut: [ | tmp1 |        tmp1 := KMDispatcher target: self.        self initializeShortcuts: tmp1.        tmp1 ]previousMorphWantingFocus  | tmp1 |  tmp1 := self previousMorphInWindow ifNil: [ ^nil ].  [ tmp1 = self or: [ tmp1 wantsKeyboardFocusNavigation ] ] whileFalse: [ tmp1 := tmp1 previousMorphInWindow ifNil: [ ^nil ] ].  ^tmp1 wantsKeyboardFocusNavigation ifTrue: [ tmp1 ]top  | tmp1 |  tmp1 := minWidth + (2 * OuterMargin).  ^(self vertProfile findFirst: [:arg1 |  arg1 >= tmp1 ]) - 1 + shadowForm offset ychooseFileName: arg1 extensions: arg2 path: arg3 preview: arg4  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4drawBackgroundForSearchedRow: arg1 on: arg2  self drawBackgroundForRow: arg1 on: arg2 color: listSource secondarySelectionColorcleanseStepListForWorld: arg1  | tmp1 tmp2 |  tmp1 := nil.  stepList do: [:arg2 |  tmp2 := arg2 receiver.        tmp2 world == arg1 ifFalse: [ tmp1 ifNil: [ tmp1 := OrderedCollection new ].              tmp1 addLast: arg2 ] ].  tmp1 ifNotNil: [ tmp1 do: [:arg2 |  self stopStepping: arg2 receiver ] ].  self alarms copy do: [:arg2 |  tmp2 := arg2 receiver.        (tmp2 isMorph and: [ tmp2 world == arg1 ]) ifFalse: [ self removeAlarm: arg2 selector for: arg2 receiver ] ]chunkSizeFromString: arg1  | tmp1 tmp2 |  tmp1 := arg1 asString trimBoth.  tmp1 ifEmpty: [ treeMorph flash.        ^false ].  tmp2 := Integer readFromString: tmp1.  tmp2 > 0 ifTrue: [ self changePageSize: tmp2.        self nextPage.        pageSizeEditor ifNotNil: [ pageSizeEditor takeKeyboardFocus ] ] ifFalse: [ treeMorph flash.        ^false ].  ^truehsvMorph: arg1  hsvMorph := arg1elementsForTestDataSource  ^#(2 4 7 1 5 8 6 9 10 3)listDirection: arg1  self assureTableProperties listDirection: arg1.  self layoutChangedpaneColorOrNil  ^self valueOfProperty: #paneColor ifAbsent: [ (self owner ifNil: [ ^nil ]) paneColorOrNil ]refreshContent  morph := nil.  self triggerEvent: #tabEmptyContents with: self.  self softRetrieveMorphdeselectTimeOut: arg1  owner selectedItem == self ifTrue: [ arg1 hand newMouseFocus: owner.        owner selectItem: nil event: arg1 ]colorAt: arg1  ^self isInWorld ifTrue: [ (Display colorAt: arg1) beOpaque ] ifFalse: [ Color black ]veryDeepInner: arg1  super veryDeepInner: arg1.  label := label veryDeepCopyWith: arg1.  icon := icon veryDeepCopyWith: arg1.  shortcutCharacter := shortcutCharacter veryDeepCopyWith: arg1.  askBeforeChanging := askBeforeChanging veryDeepCopyWith: arg1.  triggerOnMouseDown := triggerOnMouseDown veryDeepCopyWith: arg1.  offColor := offColor veryDeepCopyWith: arg1.  onColor := onColor veryDeepCopyWith: arg1.  feedbackColor := feedbackColor veryDeepCopyWith: arg1.  showSelectionFeedback := showSelectionFeedback veryDeepCopyWith: arg1.  allButtons := nil.  arguments := arguments veryDeepCopyWith: arg1.  argumentsProvider := argumentsProvider veryDeepCopyWith: arg1.  argumentsSelector := argumentsSelectorthemeChanged  self     layoutInset: (self theme buttonLabelInsetFor: self);     cornerStyle: (self theme buttonCornerStyleIn: self window);     borderStyle: (self theme buttonNormalBorderStyleFor: self).  (self labelMorph isNil or: [ self label isMorph ]) ifFalse: [ self label: self label font: self labelMorph font.        self labelMorph color: self theme textColor ].  super themeChangedwidthToDisplayInTree: arg1  ^self minExtent xoutOfWorld: arg1  arg1 ifNil: [ ^self ].  super outOfWorld: arg1.  outOfWorldCount := outOfWorldCount + 1addCornerGrips  | tmp1 tmp2 tmp3 |  tmp3 := self labelHeight.  tmp1 := TopLeftGripMorph new     target: self;     position: self position.  tmp1 layoutFrame topOffset: tmp3 negated.  tmp2 := TopRightGripMorph new     target: self;     position: self position.  tmp2 layoutFrame topOffset: tmp3 negated.  self     addMorph: tmp1;     addMorph: tmp2;     addMorph: (BottomLeftGripMorph new           target: self;           position: self position);     addMorph: (BottomRightGripMorph new           target: self;           position: self position)keyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self focusChangedaddCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  arg1 addLine.  arg1 add: 'add title...' selector: #addTitle.  arg1 add: 'set target...' selector: #setTarget:.  defaultTarget ifNotNil: [ arg1 add: 'add item...' selector: #addItem ].  arg1 add: 'add line' selector: #addLine.  (self items anySatisfy: [:arg3 |  arg3 hasSubMenu ]) ifTrue: [ arg1 add: 'detach submenu' selector: #detachSubMenu: ]anchoredMorph: arg1  anchoredMorph := arg1getListSize  | tmp1 |  getListSizeSelector ifNotNil: [ ^model perform: getListSizeSelector ].  tmp1 := self getList.  tmp1 isEmpty ifTrue: [ ^0 ].  ^tmp1 sizetransformFrom: arg1  (self == arg1 or: [ owner isNil ]) ifTrue: [ ^transform ].  ^(owner transformFrom: arg1) composedWithLocal: transformnewButtonLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newButtonLabelIn: self for: arg1 label: arg2 getEnabled: arg3forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]data  ^datafirstName  ^self item firstNametabGroup  ^tabGroupsetDefaultLabel  self label: self defaultLabeldoubleClick  self selectedNode ifNotNil: [:arg1 |  arg1 doubleClick ]browseItem  vScrollBarValue: arg1  resumeAfterDrawError  self changed.  self removeProperty: #errorOnDraw.  self removeProperty: #drawError.  self changedpotentialTargetsAt: arg1  | tmp1 |  tmp1 := self topRendererOrSelf owner ifNil: [ ^#() ].  ^tmp1 morphsAt: arg1forbidColumnDrop  columnDropUnabled := falsesortingIcon  ^self context morphicIconNamed: #arrowDownupdateLayout  labelMorph contents isEmpty ifFalse: [ self addMorphBack: labelMorph ].  self addMorphBack: barselectionChangedUpdateIndex: arg1  self setIndexSelector ifNil: [ ^self ].  self model perform: self setIndexSelector with: (arg1 newSelectedIndexes ifNotEmpty: [:arg2 |  arg2 first ] ifEmpty: [ 0 ])sortFunction  ^sortFunctionaddPaneSplitters  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 |  self removePaneSplitters.  self removeCornerGrips.  tmp2 := submorphs reject: [:arg1 |  arg1 layoutFrame rightFraction = 1 ].  [ tmp2 notEmpty ] whileTrue: [ tmp3 := tmp2 first.        tmp4 := tmp3 layoutFrame rightFraction.        tmp5 := submorphs select: [:arg1 |  arg1 layoutFrame rightFraction = tmp4 ].        tmp6 := (tmp5 detectMin: [:arg1 |  arg1 layoutFrame topFraction ]) layoutFrame topFraction.        tmp7 := (tmp5 detectMax: [:arg1 |  arg1 layoutFrame bottomFraction ]) layoutFrame bottomFraction.        tmp1 := ProportionalSplitterMorph new.        tmp1 layoutFrame: ((tmp4 @ tmp6 corner: tmp4 @ tmp7) asLayoutFrame                 leftOffset: tmp3 layoutFrame rightOffset;                 topOffset: tmp3 layoutFrame topOffset;                 rightOffset: 4 + tmp3 layoutFrame rightOffset;                 bottomOffset: tmp3 layoutFrame bottomOffset).        self addMorphBack: (tmp1 position: self position).        tmp2 := tmp2 copyWithoutAll: tmp5 ].  tmp2 := submorphs copy reject: [:arg1 |  arg1 layoutFrame bottomFraction = 1 ].  [ tmp2 notEmpty ] whileTrue: [ tmp3 := tmp2 first.        tmp8 := tmp3 layoutFrame bottomFraction.        tmp9 := submorphs select: [:arg1 |  arg1 layoutFrame bottomFraction = tmp8 ].        tmp10 := (tmp9 detectMin: [:arg1 |  arg1 layoutFrame leftFraction ]) layoutFrame leftFraction.        tmp11 := (tmp9 detectMax: [:arg1 |  arg1 layoutFrame rightFraction ]) layoutFrame rightFraction.        tmp1 := ProportionalSplitterMorph new           beSplitsTopAndBottom;           yourself.        tmp1 layoutFrame: ((tmp10 @ tmp8 corner: tmp11 @ tmp8) asLayoutFrame                 leftOffset: tmp3 layoutFrame leftOffset;                 topOffset: tmp3 layoutFrame bottomOffset;                 rightOffset: tmp3 layoutFrame rightOffset;                 bottomOffset: 4 + tmp3 layoutFrame bottomOffset).        self addMorphBack: (tmp1 position: self position).        tmp2 := tmp2 copyWithoutAll: tmp9 ].  self linkSubmorphsToSplitters.  self splitters do: [:arg1 |  arg1 comeToFront ]obtainHalo: arg1  self halo == arg1 ifTrue: [ ^self ].  self world hands detect: [:arg2 |  arg2 halo == arg1 ] ifFound: [:arg3 |  arg3 releaseHalo: arg1 ].  self halo: arg1sortWith: arg1  self sortElements: arg1.  self table refreshbuttonLabel: arg1 actionSelector: arg2 arguments: arg3 getEnabled: arg4 help: arg5  | tmp1 |  tmp1 := (arg1 isString ifTrue: [ self basicButton ] ifFalse: [ self basicIcon ])     actionSelector: arg2;     arguments: arg3;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     setBalloonText: arg5;     yourself.  arg1 isString ifTrue: [ tmp1 label: arg1 font: self preferedFont ] ifFalse: [ | tmp2 |        tmp2 := (arg4 isNil or: [ self perform: arg4 ]) ifTrue: [ arg1 ] ifFalse: [ tmp1 lock.              self asDisabledForm: arg1 ].        tmp1 labelGraphic: tmp2 ].  ^tmp1initialize  self basicSelectedColor: Color blue.  super initialize.  self selectedColor: self selectedColorchanged  | tmp1 tmp2 |  tmp1 := 60.  tmp2 := Time millisecondClockValue - self lastRefresh >= tmp1.  (self isInWorld and: [ tmp2 ]) ifTrue: [ super changed ]testTestTime  | tmp1 |  cases := {(tmp1 := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ self assert: true ]scrollBounds  | tmp1 |  tmp1 := self innerBounds.  self vScrollbarNeeded ifTrue: [ tmp1 := tmp1 right: tmp1 right - self scrollBarThickness ].  self hScrollbarNeeded ifTrue: [ tmp1 := tmp1 bottom: tmp1 bottom - self scrollBarThickness ].  ^tmp1athensDrawBackgroundForRow: arg1 on: arg2 color: arg3  arg2 setPaint: arg3.  arg2 drawShape: (self selectionFrameForRow: arg1)layoutChanged  | tmp1 |  fullBounds := nil.  tmp1 := self layoutPolicy.  tmp1 ifNotNil: [ tmp1 flushLayoutCache ].  owner ifNotNil: [ owner layoutChanged ]removeTab: arg1  | tmp1 |  (arg1 selected and: [ selectionHistory size > 1 ]) ifTrue: [ tmp1 := selectionHistory at: selectionHistory size - 1.        tmp1 selected: true ].  self removeFromHistory: arg1.  tabs remove: arg1.  self adjustLayoutweekdayFont  ^LogicalFont familyName: 'Bitmap DejaVu Sans' pointSize: 9balloonTextForLastItem: arg1  submorphs last setBalloonText: arg1hasChanged  ^hasChanged ifNil: [ true ]hasIcon  ^container hasIconBlock or: [ self complexContents icon notNil ]initializeLayout  self     changeTableLayout;     layoutInset: 6;     listDirection: #topToBottom;     cellPositioning: #topRight;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     cellInset: 0preferredColor  ^niltopBoundary  | tmp1 |  tmp1 := leftOrTop reject: [:arg1 |  arg1 layoutFrame topFraction ~= 0 and: [ arg1 layoutFrame topFraction = arg1 layoutFrame bottomFraction ] ].  tmp1 ifEmpty: [ ^(self splitterAbove ifNil: [ self containingWindow panelRect top ] ifNotNil: [:arg2 |  arg2 first top ]) + 25 ].  ^(tmp1 collect: [:arg1 |  arg1 top + arg1 minExtent y + (self layoutFrame topOffset ifNil: [ 0 ]) - (arg1 layoutFrame bottomOffset ifNil: [ 0 ]) ]) maxaddUpdating: arg1 target: arg2 selector: arg3  self addUpdating: arg1 target: arg2 selector: arg3 argumentList: EmptyArraycontentMorph  ^self submorphs firstflash  ^editView flashinitializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigation.  arg1 attachCategory: #PluggableButtonMorphreplaceSubmorph: arg1 by: arg2  | tmp1 tmp2 tmp3 |  arg1 stopStepping.  tmp2 := arg1 referencePositionInWorld.  tmp1 := submorphs indexOf: arg1.  arg1 privateDelete.  self privateAddMorph: arg2 atIndex: tmp1.  arg2 referencePositionInWorld: tmp2.  (tmp3 := arg2 world) ifNotNil: [ tmp3 startSteppingSubmorphsOf: arg2 ]setGrabbedColor  self fillStyle: self pressedFillStyleemphasis  ^emphasisfont  ^fonthResizing: arg1  hResizing := arg1bindKeyCombination: arg1 toAction: arg2  self kmDispatcher bindKeyCombination: arg1 asKeyCombination toAction: arg2activateCursor: arg1 withMask: arg2  arg1 beCursorWithMask: arg2color: arg1  super color: arg1.  (image depth = 1 and: [ arg1 isColor ]) ifTrue: [ image isColorForm ifFalse: [ image := ColorForm mappingWhiteToTransparentFrom: image ].        image colors: {Color transparent .               arg1}.        self changed ]initializeOtherProperties  otherProperties := SmallIdentityDictionary newtarget: arg1  target := arg1.  self color: (target paneColor alpha: 0.35).  self bounds: arg1 bounds.  self currentHand newMouseFocus: selftreeMorph: arg1  treeMorph := arg1tabSelected: arg1  self setTabContentFrom: arg1.  self triggerEvent: #tabSelected with: arg1shiftedTextPaneMenuRequest  ^self yellowButtonActivity: truedrawLinesOn: arg1  self flag: #pharoTodoannounceOpened  self doAnnounce: (MorphOpened morph: self).  self submorphs do: #announceOpenedallowsCellSelection  ^truesearchText: arg1  arg1 isEmptyOrNil ifTrue: [ ^#() ].  self elements withIndexDo: [:arg2 :arg3 |  (arg2 name beginsWith: arg1) ifTrue: [ ^{arg3} ] ].  ^#()adhereTo: arg1  (#(#left #top #right #bottom #none) includes: arg1) ifFalse: [ ^self error: 'invalid option' ].  self setToAdhereToEdge: arg1.  self updateLayoutProperties.  self updateColorscrollbarThickness  ^self theme scrollbarThicknessisMorphicModel  ^truenewSize: arg1  newSize := arg1lastVisibleRowIndex  ^self exposedRows ifNotEmpty: [:arg1 |  arg1 keys last ] ifEmpty: [ 0 ]referencePosition  | tmp1 |  tmp1 := self bounds.  ^tmp1 origin + (self rotationCenter * tmp1 extent)balloonHelpTextForHandle: arg1  (arg1 eventHandler mouseSelectorsInclude: #addOrRemoveItems:) ifTrue: [ ^'Add items to, or remove them from, this selection.' ].  ^super balloonHelpTextForHandle: arg1beCursorOwner  self class cursorOwnerWorld: selfaltKeyPressed  ^self optionKeyPressedstep  (self keepOpen not and: [ self activeHand anyModifierKeyPressed not ]) ifTrue: [ self done ]fullFrame  ^fullFramemouseDownInTitle: arg1  arg1 hand grabMorph: selfdefaultTreeMorph  | tmp1 |  tmp1 := MorphTreeColumn new rowMorphGetSelector: [:arg1 |  StringMorph contents: arg1 item asString ].  self headerLabel ifNotNil: [ tmp1 headerButtonLabel: self headerLabel font: nil ].  ^(self treeMorphClass on: self)     columns: (Array with: tmp1);     hResizing: #spaceFill;     vResizing: #spaceFill;     resizerWidth: 0;     columnInset: 0;     rowInset: 2;     keystrokeActionSelector: #keyStroke:;     multiSelection: self multiSelection;     autoMultiSelection: self autoMultiSelection;     itemStringGetter: [:arg2 |  self wrapItem: arg2 ];     isCheckList: self isCheckListtestSortDataSource  | tmp1 |  tmp1 := self dataSourceForTesting.  strategy sortFunction: #yourself ascending.  self assert: tmp1 elements equals: self elementsForTestDataSource.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(10 9 8 7 6 5 4 3 2 1).  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: self elementsForTestDataSourcemidVertices  | tmp1 tmp2 tmp3 |  vertices size < 2 ifTrue: [ ^vertices ].  tmp1 := OrderedCollection new.  tmp2 := 2.  tmp3 := OrderedCollection new.  tmp3 add: vertices first asIntegerPoint.  self lineSegmentsDo: [:arg1 :arg2 |  tmp3 addLast: arg2 asIntegerPoint.        arg2 = (vertices atWrap: tmp2) ifTrue: [ tmp1 addLast: ((tmp3 atWrap: (tmp3 size + 1) // 2) + (tmp3 at: tmp3 size // 2 + 1)) // 2.              tmp3 := OrderedCollection new.              tmp3 add: arg2 asIntegerPoint.              tmp2 := tmp2 + 1 ] ].  ^tmp1 asArrayinnerBounds  | tmp1 |  tmp1 := super innerBounds.  (submorphs includes: scrollBar) ifTrue: [ tmp1 := tmp1 topLeft corner: (tmp1 right - scrollBar width) @ tmp1 bottom ].  self hIsScrollbarShowing ifFalse: [ ^tmp1 ] ifTrue: [ ^tmp1 topLeft extent: tmp1 extent - (0 @ self scrollBarThickness) ]chooseDirectory: arg1  ^self chooseDirectory: arg1 path: nilenablementSelector  ^enablementSelectorpassiveDisabledNotOverUpFillStyle: arg1  self stateMap atPath: #(passive disabled notOver up) put: arg1.  self changedinnerWidgetChanged  self setScrollDeltas.  self updateColumnMorphsWidth.  self adjustSubmorphPositionscommentText  ^(self theme newTextIn: self currentWorld text: self item comment)     unlock;     wrapFlag: true;     yourselfselectionChanged  client selectionChangedfillStyleToUse  | tmp1 |  tmp1 := self active ifTrue: [ self stateMap at: #active ifAbsent: [ self stateMap at: #passive ifAbsent: [ Dictionary new ] ] ] ifFalse: [ self stateMap at: #passive ifAbsent: [ self stateMap at: #active ifAbsent: [ Dictionary new ] ] ].  tmp1 := self enabled ifTrue: [ tmp1 at: #enabled ifAbsent: [ tmp1 at: #disabled ifAbsent: [ Dictionary new ] ] ] ifFalse: [ tmp1 at: #disabled ifAbsent: [ tmp1 at: #enabled ifAbsent: [ Dictionary new ] ] ].  tmp1 := self over ifTrue: [ tmp1 at: #over ifAbsent: [ tmp1 at: #notOver ifAbsent: [ Dictionary new ] ] ] ifFalse: [ tmp1 at: #notOver ifAbsent: [ tmp1 at: #over ifAbsent: [ Dictionary new ] ] ].  ^tmp1 at: (self down ifTrue: [ #down ] ifFalse: [ #up ]) ifAbsent: [ tmp1 at: (self down ifTrue: [ #up ] ifFalse: [ #down ]) ifAbsent: [ Color transparent ] ]drawOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  self shouldDraw ifFalse: [ ^self ].  super drawOn: arg1.  self class showSplitterHandles ifTrue: [ tmp2 := self splitsTopAndBottom ifTrue: [ self handleSize transposed ] ifFalse: [ self handleSize ].        tmp4 := self splitsTopAndBottom ifTrue: [ 6 @ self class splitterWidth ] ifFalse: [ self class splitterWidth @ 6 ].        tmp3 := arg1 asAlphaBlendingCanvas: 0.7.        tmp1 := Rectangle center: self bounds center extent: tmp2.        tmp3 fillRectangle: tmp1 color: self handleColor.        tmp1 := Rectangle center: self bounds center extent: tmp4.        tmp3 fillRectangle: tmp1 color: self dotColor ]mouseOverHandler  ^mouseOverHandler ifNil: [ mouseOverHandler := MouseOverHandler new ]pattern: arg1  pattern := arg1orderedTasks  ^orderedTasksnewCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 getLabel: arg5 help: arg6  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 getLabel: arg5 help: arg6hScrollBarValue: arg1  | tmp1 |  tmp1 := scroller offset x.  super hScrollBarValue: arg1.  scroller offset x ~= tmp1 ifTrue: [ self updateColumnResizersXOffset.        self updateTopHeader ]roots: arg1  roots := arg1 collect: [:arg2 |  PluggableTreeItemNode with: arg2 model: self ].  self list: rootscellSpacing  ^cellSpacingstruckOut  self changeEmphasis: #struckOutsetDefaultColors  handleColor := Color lightGray lighter lighter.  dotColor := Color gray lighterperformAction: arg1  enabled ifFalse: [ ^self ].  askBeforeChanging ifTrue: [ model okToChange ifFalse: [ ^self ] ].  self actionBlock ifNotNil: [ ^self actionBlock cull: arg1 ].  actionSelector ifNotNil: [ actionSelector numArgs = 0 ifTrue: [ model perform: actionSelector ] ifFalse: [ argumentsProvider ifNotNil: [ arguments := argumentsProvider perform: argumentsSelector ].              model perform: actionSelector withArguments: arguments ] ]bottomRight  ^right @ bottomselectLastPrefix: arg1  | tmp1 |  self items reverseDo: [:arg2 |  | tmp2 |        tmp2 := arg1 isEmpty or: [ arg2 contents asString asLowercase beginsWith: arg1 ].        arg2 isEnabled: tmp2.        (tmp2 and: [ tmp1 isNil ]) ifTrue: [ tmp1 := arg2 ] ].  ^tmp1down  ^downcheckRectangle  | tmp1 |  tmp1 := self toggleRectangle translateBy: 3 @ 0.  ^self mustTakeIntoAccountToggleSpace ifTrue: [ tmp1 topRight + (self checkGap @ 0) corner: tmp1 bottomRight + ((self checkGap + self checkWidth) @ 0) ] ifFalse: [ tmp1 ]defaultIcon  ^self iconNamed: #blankIcondrawOnAthensCanvas: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self borderStyle.  tmp2 := self asAthensPathOn: arg1.  self isClosed ifTrue: [ arg1 setPaint: self fillStyle.        arg1 drawShape: tmp2 ].  tmp3 := arg1 setStrokePaint: tmp1 color.  tmp3 width: tmp1 width.  self dashedBorder notNil ifTrue: [ self setDashOnStroke: tmp3 ].  arg1 drawShape: tmp2.  self hasTwoColorDash ifTrue: [ self setSecondColorDashOnStroke: tmp3.        arg1 drawShape: tmp2 ].  self drawArrowsOnAthensCanvas: arg1newVerticalSeparator  ^self theme newVerticalSeparatorIn: selfisCursorOwner  ^self class cursorOwnerWorld == selfsetUp  super setUp.  morph := CircleMorph newborderWidth: arg1  super borderWidth: arg1.  self setScrollDeltasreplaceAll: arg1 with: arg2 startingAt: arg3  self handleEdit: [ self editor replaceAll: arg1 with: arg2 startingAt: arg3 ]taskbarLabel  self model ifNotNil: [ self model taskbarLabel ifNotNil: [:arg1 |  ^arg1 ] ].  ^self labelStringmorphicLayerNumber  ^(owner isNil or: [ owner isWorldMorph ]) ifTrue: [ self valueOfProperty: #morphicLayerNumber ifAbsent: [ 100 ] ] ifFalse: [ owner morphicLayerNumber ]otherProperties  ^extension ifNotNil: [ extension otherProperties ]expand  | tmp1 tmp2 |  isExpanded := true.  (tmp1 := complexContents contents) isEmpty ifTrue: [ ^self changed ].  tmp2 := container addMorphsAfter: self fromCollection: tmp1.  firstChild := tmp2 first.  self updateChildrenselectablesToHighlightFromRow: arg1 at: arg2 withHighlightedIndexes: arg3 andPrimaryIndex: arg4  | tmp1 |  tmp1 := Dictionary new.  self flag: #pharoFixMe.  arg1 submorphs withIndexDo: [:arg5 :arg6 |  | tmp2 |        (arg3 includes: (tmp2 := {arg2 .               arg6})) ifTrue: [ tmp1 at: arg5 put: arg4 = tmp2 ] ].  ^tmp1keyStrokeAction: arg1  | tmp1 |  tmp1 := self model perform: self keystrokeSelector withEnoughArguments: {arg1 .         self}.  ^tmp1 = truesortDataSource: arg1  getListSizeSelector  ^getListSizeSelectorhandlerForYellowButtonDown: arg1  (self hasYellowButtonMenu or: [ self handlesMouseDown: arg1 ]) ifFalse: [ ^nil ].  arg1 handler ifNil: [ ^self ].  ^self mouseDownPriority >= arg1 handler mouseDownPriority ifFalse: [ nil ] ifTrue: [ self ]cornerStyle: arg1  arg1 == self cornerStyle ifFalse: [ self assureExtension.        extension cornerStyle: arg1.        self changed ]highlightedIndexes  ^highlightedIndexesaddTabContents: arg1 at: arg2 delta: arg3  | tmp1 |  tmp1 := arg1 retrieveMorph: [:arg4 |  | tmp2 |        arg4 ifNil: [ TabWithNoContents signalTab: arg1 ].        tmp2 := arg2 = 1 ifTrue: [ 0 ] ifFalse: [ 2 ].        contentsWrapper addMorph: arg4 fullFrame: (LayoutFrame identity                 leftFraction: (arg2 - 1) * arg3;                 leftOffset: tmp2;                 rightOffset: -2;                 rightFraction: arg2 * arg3) ].  tmp1 ifNotNil: [ processes add: tmp1 ]mouseDown: arg1  self flag: #pharoTodofirstVisibleRowIndex  ^self exposedRows ifNotEmpty: [:arg1 |  arg1 keys first ] ifEmpty: [ 0 ]dispatchKeystroke: arg1  | tmp1 tmp2 |  tmp1 := arg1 keyCharacter.  (tmp2 := tmp1 asciiValue) = 27 ifTrue: [ ^self invokeWorldMenuFromEscapeKey ].  (self navigationKey: arg1) ifTrue: [ ^self ].  (arg1 commandKeyPressed and: [ TextEditor cmdKeysInText ]) ifTrue: [ ^self dispatchCommandKeyInWorld: tmp1 event: arg1 ].  self lastKeystroke: arg1 keyString.  self triggerEvent: #keyStroke.  super dispatchKeystroke: arg1cleanseOtherworldlySteppers  | tmp1 tmp2 |  tmp1 := self currentWorld stepListSize.  self currentWorld steppingMorphsNotInWorld do: [:arg1 |  arg1 delete ].  self currentWorld cleanseStepList.  (tmp2 := tmp1 - self currentWorld stepListSize) > 0 ifTrue: [ self crTrace: tmp2 asString , ' morphs removed from steplist' ]spotterForKeysFor: arg1  < spotterOrder: 15>  (self hasProperty: #kmDispatcher) ifFalse: [ ^self ].  self kmDispatcher spotterForKeysFor: arg1expandAllTo: arg1  self rootItem expandAllTo: arg1expandAll: arg1 except: arg2  | tmp1 |  (arg2 value: arg1 complexContents) ifFalse: [ ^self ].  arg1 toggleExpandedState.  tmp1 := OrderedCollection new: 10.  arg1 recursiveAddTo: tmp1.  tmp1 do: [:arg3 |  (arg3 canExpand and: [ arg3 isExpanded not ]) ifTrue: [ self expandAll: arg3 except: arg2 ] ]selectionInterval  ^editor ifNotNil: [ editor selectionInterval ]taskClicked: arg1  self selectTask: arg1.  self donetakesKeyboardFocus  ^truepresentHelp  self inform: 'Sorry, no help has beenprovided here yet.'labelGraphic: arg1  graphicalMorph ifNotNil: [ graphicalMorph delete ].  graphicalMorph := ImageMorph new form: arg1.  self extent: graphicalMorph extent + (self borderWidth + self extraBorder).  graphicalMorph position: self center - (graphicalMorph extent // 2).  self addMorph: graphicalMorph.  graphicalMorph lockdirection  ^directionaddMorphCentered: arg1  arg1 position: bounds center - (arg1 extent // 2).  self addMorphFront: arg1mouseUp: arg1  super mouseUp: arg1.  oldColor ifNotNil: [ self color: oldColor.        oldColor := nil.        (self containsPoint: arg1 cursorPoint) ifTrue: [ actWhen == #buttonUp ifTrue: [ self doButtonAction ] ] ifFalse: [ self mouseLeave: arg1 ] ]selectedNodePath  ^selectedNodePathtextStyle: arg1 lines: arg2 text: arg3  textStyle := arg1.  lines := arg2.  text := arg3mouseUp: arg1 on: arg2  | tmp1 tmp2 tmp3 |  tmp3 := self clicked: arg1 inTheCheckboxOf: arg2.  self listModel okToChange ifFalse: [ ^self ].  self listModel okToDiscardEdits ifFalse: [ ^self ].  tmp2 := self commandOrCrontrolKeyPressed: arg1.  tmp1 := (arg1 shiftPressed and: [ self isMultiple ]) ifTrue: [ self shiftSelectMorph: arg2 ] ifFalse: [ self autoMultiSelection ifTrue: [ self selectedMorphList ifEmpty: [  ] ifNotEmpty: [:arg3 |  arg3 last path collect: [:arg4 |  arg4 complexContents ] ] ] ifFalse: [ self selectMorph: arg2 multiple: ((tmp2 and: [ self isMultiple ]) or: [ self autoMultiSelection ]) clickedTheCheckBox: tmp3 ] ].  self selectionUpdateFromViewWhile: [ | tmp4 |        tmp4 := self newSelectionHolderWithNodePath: tmp1.        self listModel selection: tmp4 ].  tmp3 ifFalse: [ self lastClickedMorph: arg2 ].  self selectionChangeddefaultBalloonColor  ^Display depth <= 2 ifTrue: [ Color white ] ifFalse: [ BalloonMorph balloonColor ]searchIn: arg1  | tmp1 |  tmp1 := false.  (self isMatching: arg1) ifTrue: [ result add: index.        tmp1 := true ].  index := index + 1.  (arg1 hasChildren and: [ dataSource canDisplayChildrenOf: arg1 ]) ifTrue: [ | tmp2 |        tmp2 := index.        (arg1 children select: [:arg2 |  self searchIn: arg2 ]) ifNotEmpty: [ tmp1 := true.              arg1 expand ] ifEmpty: [ arg1 collapse.              index := tmp2 ] ].  ^tmp1hide  owner ifNil: [ ^self ].  self visible ifFalse: [ ^self ].  self visible: false.  self changedrecursiveAddTo: arg1  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg2 |  arg2 recursiveAddTo: arg1 ] ].  arg1 add: selfwantsSteps  ^self scrollBarAction notNilgetHelpSelector  ^getHelpSelectortextEntry: arg1 title: arg2  ^self textEntry: arg1 title: arg2 entryText: ''wantsDroppedMorph: arg1 event: arg2  ^model container columnDropUnabled and: [ arg1 isTransferable and: [ (arg1 passenger isKindOf: MorphTreeColumn) and: [ arg1 passenger ~= self model ] ] ]selectLastTab  toolbar selectLastTabfillStyleToUse  ^self enabled ifTrue: [ self theme sliderNormalFillStyleFor: self ] ifFalse: [ self theme sliderDisabledFillStyleFor: self ]unsortElements  unsortedElements ifNil: [ ^self ].  self elements: unsortedElements.  unsortedElements := nilhelpText  ^self balloonTextclick: arg1  (self isYellowButtonReallyPressed: arg1) ifTrue: [ self showMenuForPosition: arg1 cursorPoint ]waitReadyMorphFor: arg1  morph ifNotNil: [ ^self ].  retrievingSemaphore wait: arg1moveDown: arg1  ^self moveSelectionDown: 1 event: arg1keyStrokeArrowLeft: arg1  (self selectionModeStrategy is: self selectedIndex afterColumn: 1) ifFalse: [ ^self ].  self resetFunction.  self selectIndex: (self selectionModeStrategy selectableIndexBefore: self selectedIndex) event: arg1open  window := manager openInWindow.  window extent: 400 @ 300.  self addTabsdrawGridOn: arg1  (self griddingOn and: [ self gridVisible ]) ifTrue: [ arg1 fillRectangle: self bounds fillStyle: (self gridFormOrigin: self gridOrigin grid: self gridModulus background: nil line: Color lightGray) ]handlesKeyStroke: arg1  ^self existsSubscriptionsFor: #keyStrokeaddCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  arg1 addLine.  arg1 add: 'add or remove items' target: self selector: #addOrRemoveItems: argument: arg2.  arg1 addList: {#- .         {'Place into a row' .         #organizeIntoRow} .         {'Place into a column' .         #organizeIntoColumn} .         #- .         {'Align left edges' .         #alignLeftEdges} .         {'Align top edges' .         #alignTopEdges} .         {'Align right edges' .         #alignRightEdges} .         {'Align bottom edges' .         #alignBottomEdges} .         #- .         {'Align centers vertically' .         #alignCentersVertically} .         {'Align centers horizontally' .         #alignCentersHorizontally}}.  self selectedItems size > 2 ifTrue: [ arg1 addList: {#- .               {'Distribute vertically' .               #distributeVertically} .               {'Distribute horizontally' .               #distributeHorizontally}} ]active: arg1  active := arg1.  self changedinstall  owner := nil.  ActiveWorld := self.  World := self.  ActiveHand := self hands first.  ActiveEvent := nil.  submorphs do: [:arg1 |  arg1 owner ifNil: [ arg1 privateOwner: self ] ].  self viewBox: Display boundingBox.  Sensor flushAllButDandDEvents.  worldState handsDo: [:arg2 |  arg2 initForEvents ].  self borderWidth: 0.  SystemWindow noteTopWindowIn: self.  self displayWorldSafelylistMorph  listMorph ifNil: [ listMorph := self listMorphClass new.        listMorph listSource: self.        listMorph width: self scroller width.        listMorph color: self textColor ].  listMorph owner ~~ self scroller ifTrue: [ self scroller removeAllMorphs.        self scroller addMorph: listMorph ].  ^listMorphisYellowButtonReallyPressed: arg1  arg1 yellowButtonPressed ifFalse: [ ^false ].  ^Smalltalk os isMacOS ifTrue: [ arg1 commandKeyPressed not ] ifFalse: [ arg1 controlKeyPressed not ]textAnchorType  ^self valueOfProperty: #textAnchorType ifAbsent: [ #document ]handlesMouseOver: arg1  ^truesetStrategy  self subclassResponsibilityisAdheringToLeft  ^self edgeToAdhereTo == #leftoverrideExtent: arg1  self isAutoFit ifTrue: [ self           setProperty: #autoFitContents toValue: false;           extent: arg1;           setProperty: #autoFitContents toValue: true ]classButton  ^(self theme newButtonIn: self currentWorld for: self getState: nil action: #browseItem arguments: {} getEnabled: #enabled getLabel: nil help: 'Open a browser on ' translated , self item name)     label: (self theme windowLabelForText: self item name , '...');     yourselfpageSize  ^pageSizeblueButtonUp: arg1  isInWorld  ^self world notNilimage: arg1  image := arg1.  super extent: (2 * self borderWidth) asPoint + image extent.  self changedactivateOwnerMenu: arg1  ^self owner ifNil: [ false ] ifNotNil: [:arg2 |  arg2 activate: arg1.        true ]stepAt: arg1  (isCollapsed not or: [ self wantsStepsWhenCollapsed ]) ifTrue: [ model ifNotNil: [ model stepAt: arg1 in: self ].        super stepAt: arg1 ]mouseOverColor  ^self theme lightBackgroundColorrightArrow  ^SubMenuMarkertestRowIndexFrom  self assert: (strategy rowIndexFrom: #(3 5)) equals: 3addLine  (self hasItems and: [ self lastSubmorph isMenuLineMorph not ]) ifTrue: [ self addMorphBack: MenuLineMorph new ]verticalScrollBarValueToRowIndex: arg1  | tmp1 |  tmp1 := self dataSource numberOfRows - self container calculateMinVisibleRows + 1.  ^(tmp1 * arg1) asIntegerdefaultBorderWidth  ^0selected  ^falseisRenderer  ^falsenewRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6  ^self theme newRadioButtonIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6removePage: arg1  | tmp1 |  tmp1 := self pages indexOf: arg1.  self pages remove: arg1.  self tabSelectorMorph removeTabIndex: tmp1showingDirectionHandles  ^directionArrowAnchor notNilbaseColor  ^baseColor ifNil: [ Color transparent ]empty  self selectedNodePath: nilsetDefaultContentsIfNil  | tmp1 |  text ifNil: [ tmp1 := self valueOfProperty: #defaultContents.        tmp1 ifNil: [ tmp1 := '' asText ].        text := tmp1 ]contents  ^item submorphs collect: [:arg1 |  self class with: arg1 ]subMenu: arg1  subMenu := arg1.  self changednewColorPickerButtonMorph  ^self newButtonFor: self getState: nil action: #pickColor arguments: nil getEnabled: nil labelForm: ((self iconNamed: #eyedropperIcon) scaledIntoFormOfSize: 16) help: 'Pick a color from the screen' translatedglamourMinExtent  ^self minExtentnewEmbeddedMenu  ^self theme newEmbeddedMenuIn: self for: selftext  | tmp1 |  tmp1 := (self keyText substrings: '+') collect: #trimBoth.  ((tmp1 includes: 'Shift') and: [ (tmp1 first = 'Shift') not ]) ifTrue: [ tmp1 := (tmp1 copyWithout: 'Shift') copyWithFirst: 'Shift' ].  ^tmp1 inject: Text new into: [:arg1 :arg2 |  arg1 , (self class symbolTableAt: arg2 ifAbsent: [ arg2 capitalized ]) ]transformedBy: arg1  arg1 isIdentity ifTrue: [ ^self ].  arg1 isPureTranslation ifTrue: [ ^self position: (arg1 localPointToGlobal: self position) ].  ^self addFlexShell transformedBy: arg1containsPoint: arg1 event: arg2  (arg2 isMouse and: [ arg2 isMouseDown and: [ arg2 blueButtonPressed ] ]) ifFalse: [ ^super containsPoint: arg1 event: arg2 ].  ^bounds containsPoint: arg2 positionisActive  ^self isFullscreen or: [ super isActive ]testColumnHasIconWithSorting  column sortableOnProperty: #name.  self assert: column sortingIcon isNotNiladdNullLineWithIndex: arg1 andRectangle: arg2  lines addLast: ((TextLine start: arg1 stop: arg1 - 1 internalSpaces: 0 paddingWidth: 0)           rectangle: arg2;           lineHeight: defaultLineHeight baseline: theTextStyle baseline)setBalloonText: arg1 maxLineLength: arg2  (extension isNil and: [ arg1 isNil ]) ifTrue: [ ^self ].  self assureExtension balloonText: (arg1 ifNotNil: [ arg1 asString withNoLineLongerThan: arg2 ])setSelectionIndexFromKeyboard: arg1 multiSelection: arg2 event: arg3  | tmp1 |  arg1 ifNil: [ ^self ].  arg1 > self allNodeMorphs size ifTrue: [ ^self ].  tmp1 := arg1 = 0 ifTrue: [ nil ] ifFalse: [ self allNodeMorphs at: arg1 ].  lastClickedMorph ifNotNil: [ lastClickedMorph highlightForMouseDown: false ].  self isCheckList ifTrue: [ (arg2 and: [ arg3 shiftPressed ]) ifTrue: [ self autoMultiSelect: tmp1 ] ] ifFalse: [ (arg2 and: [ arg3 shiftPressed ]) ifTrue: [ self autoMultiSelect: tmp1 ] ifFalse: [ self setSelectedMorph: tmp1 ] ].  self lastClickedMorph: (firstClickedMorph := tmp1).  arg3 shiftPressed ifTrue: [ lastClickedMorph highlightForMouseDown: true ].  self selectionChanged.  self scrollToShow: tmp1 contentBoundsmouseOverThumbBorderStyle  ^self theme scrollbarMouseOverThumbBorderStyleFor: selfintercellSpacing  ^intercellSpacing ifNil: [ self class defaultIntercellSpacing ]mouseMove: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseMove from: arg2addHaloActionsTo: arg1  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1     buildTitle: [:arg2 |  arg2 bigTitle: self externalName ];     add: 'delete' selector: #dismissViaHalo.  tmp1 balloonTextForLastItem: 'Delete this object -- warning -- can be destructive!' translated.  self maybeAddCollapseItemTo: tmp1.  tmp1 add: 'grab' selector: #openInHand.  tmp1 balloonTextForLastItem: 'Pick this object up -- warning, since this removes it from its container, it can have adverse effects.' translated.  tmp1 addLine.  tmp1 add: 'resize' selector: #resizeFromMenu.  tmp1 balloonTextForLastItem: 'Change the size of this object' translated.  tmp1 add: 'duplicate' selector: #maybeDuplicateMorph.  tmp1 balloonTextForLastItem: 'Hand me a copy of this object'.  tmp1 addLine.  tmp1 add: 'set color' target: self renderedMorph selector: #changeColor.  tmp1 balloonTextForLastItem: 'Change the color of this object'.  tmp1 addLine.  tmp1 add: 'inspect' target: self selector: #inspect.  tmp1 balloonTextForLastItem: 'Open an Inspector on this object'.  arg1 add: 'halo actions...' subMenu: tmp1mouseMove: arg1  target ifNil: [ ^self ].  target fastFramingOn ifTrue: [ target doFastWindowReframe: self ptName ] ifFalse: [ lastMouse at: 1 put: arg1 cursorPoint.        self targetPoint: lastMouse first - lastMouse last.        self position: lastMouse first - lastMouse second ]getEnabledSelector  ^getEnabledSelectorareasRemainingToFill: arg1  (backgroundColor isNil or: [ backgroundColor isTranslucent ]) ifTrue: [ ^Array with: arg1 ].  self wantsRoundedCorners ifTrue: [ (borderWidth > 0 and: [ borderColor isColor and: [ borderColor isTranslucent ] ]) ifTrue: [ ^arg1 areasOutside: (self innerBounds intersect: self boundsWithinCorners ifNone: [ self error: 'cannot happen' ]) ] ifFalse: [ ^arg1 areasOutside: self boundsWithinCorners ] ] ifFalse: [ (borderWidth > 0 and: [ borderColor isColor and: [ borderColor isTranslucent ] ]) ifTrue: [ ^arg1 areasOutside: self innerBounds ] ifFalse: [ ^arg1 areasOutside: self bounds ] ]reframePanesAdjoining: arg1 along: arg2 to: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  arg1 ifNil: [ ^self ].  tmp2 := arg3.  tmp5 := #(left right) includes: arg2.  tmp4 := tmp5 ifTrue: [ 40 ] ifFalse: [ 20 ].  tmp3 := (((paneMorphs select: [:arg4 |  arg4 bounds bordersOn: arg1 bounds along: arg2 ]) collect: [:arg4 |  arg4 bounds adjustTo: tmp2 along: arg2 ]) copyWith: arg3) inject: 999 into: [:arg5 :arg6 |  arg5 min: (tmp5 ifTrue: [ arg6 width ] ifFalse: [ arg6 height ]) ].  tmp3 > tmp4 ifFalse: [ tmp1 := tmp3 - tmp4.        tmp2 := tmp2 withSide: arg2 setTo: ((tmp2 perform: arg2) > (arg1 bounds perform: arg2) ifTrue: [ (tmp2 perform: arg2) + tmp1 ] ifFalse: [ (tmp2 perform: arg2) - tmp1 ]) ].  paneMorphs do: [:arg4 |  (arg4 bounds bordersOn: arg1 bounds along: arg2) ifTrue: [ arg4 bounds: (arg4 bounds adjustTo: tmp2 along: arg2) ] ].  arg1 bounds: tmp2.  self setPaneRectsFromBounds.  self extent: self extenthasLeftOrTop: arg1  ^leftOrTop includes: arg1delete  super delete.  self releaseopenAsIs  ^self openAsIsIn: self currentWorldpopUpEvent: arg1 in: arg2  | tmp1 tmp2 |  tmp1 := arg1 ifNotNil: [ arg1 hand ] ifNil: [ ActiveHand ].  tmp2 := tmp1 position truncated.  ^self popUpAt: tmp2 forHand: tmp1 in: arg2imageFormDepth: arg1  ^self imageForm: arg1 forRectangle: self fullBoundstestIsAboveRow  self assert: (strategy is: #(3 7) aboveRow: 4).  self deny: (strategy is: #(3 7) aboveRow: 2).  self deny: (strategy is: #(3 7) aboveRow: 3)selectedLabel: arg1  selectedLabel := arg1vResizing  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #rigid ] ifNotNil: [ tmp1 vResizing ]resize  | tmp1 |  tmp1 := self maxBarWidth + 50 max: self width.  self width: tmp1splitterBelow  | tmp1 |  tmp1 := (self siblingSplitters select: [:arg1 |  arg1 top < self top and: [ self overlapsHorizontal: arg1 ] ]) asSortedCollection: [:arg2 :arg3 |  arg2 top > arg3 top ].  ^tmp1 ifEmpty: [ nil ] ifNotEmpty: [:arg4 |  arg4 first ]acceptDroppingMorph: arg1 event: arg2  complexContents acceptDroppingObject: arg1 complexContents.  arg1 delete.  self highlightForDrop: falsenewAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7 entryCompletion: arg8  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7 entryCompletion: arg8currentCursor: arg1  ^worldState currentCursor: arg1adjustSubmorphPositionsFrom: arg1 to: arg2  | tmp1 tmp2 |  tmp1 := self allNodeMorphs.  tmp2 := (tmp1 at: arg1) position.  arg1 to: tmp1 size do: [:arg3 |  | tmp3 tmp4 |        tmp3 := tmp1 at: arg3.        tmp4 := tmp3 height.        tmp3 bounds: (tmp2 extent: tmp3 width @ tmp4).        tmp2 := tmp2 + (0 @ tmp4) ]keyDown: arg1  inactiveLabelFillStyle  ^self theme windowInactiveLabelFillStyleFor: selfresetListSelector  ^resetListSelectorcontainer  container ifNil: [ successor ifNotNil: [ ^self compositionRectangle ].        wrapFlag ifTrue: [ ^self compositionRectangle withHeight: 9999999 ].        ^self compositionRectangle topLeft extent: 9999999 @ 9999999 ].  ^containertestSelectableIndexAfter  self assert: (strategy selectableIndexAfter: #(2 3)) equals: #(2 4)hasIcon  ^icon notNilfirstClickedMorph: arg1  firstClickedMorph := arg1filterWith: arg1  initialDataSource ifNil: [ self initializeFilter ].  pattern := arg1 asString trimBoth.  isEditingSemaphore signalembeddable  ^self valueOfProperty: #embeddable ifAbsent: [ false ]controlButtonWidth  ^self theme scrollbarThickness + (3 * self displayScaleFactor)autoGradientString  ^self autoGradient -> 'auto gradient' translatedhandsDo: arg1  ^worldState handsDo: arg1vScrollbarInterval  ^self scrollBounds height asFloat / self scrollTarget height min: 1.0initForKeystrokes  lastKeystrokeTime := 0.  lastKeystrokes := ''.  lastSelection := 0otherProperties  ^otherPropertieswidth: arg1  width = arg1 ifTrue: [ ^self ].  width := arg1 truncated max: (width isPoint ifTrue: [ 0 @ 0 ] ifFalse: [ 0 ]).  self releaseCachedStatenewCloseButtonFor: arg1  ^self theme newCloseButtonIn: self for: arg1borderColor  ^self theme lightBackgroundColorhasContentsSelector  ^hasContentsSelectorbeWithGrips  self removeProperty: #noGrips.  (self isCollapsed not or: [ self isTaskbarPresent ]) ifTrue: [ self addGripsIfWanted ]pasteUpMorph  ^self ownerThatIsA: PasteUpMorphdefaultRowMorph  ^Morph new     color: Color red;     borderWidth: 0;     extent: 0 @ 0;     yourselfworldTaskbar  ^self world ifNotNil: [:arg1 |  arg1 submorphThat: [:arg2 |  arg2 isTaskbar ] ifNone: [ nil ] ]doubleClickSelector: arg1  self listManager doubleClickSelector: arg1showWindowPreview  ^self class showWindowPreviewopenInSceneView  ^AthensSceneView new     scene: (AthensMorphScene new morph: self);     openInWindowchooseFont: arg1  ^self theme chooseFontIn: self title: 'Font Selector' translated font: arg1checkIfUpdateNeeded  damageRecorder updateIsNeeded ifTrue: [ ^true ].  hands do: [:arg1 |  (arg1 hasChanged and: [ arg1 needsToBeDrawn ]) ifTrue: [ ^true ] ].  ^falsetarget  ^targetallIntervals  | tmp1 |  tmp1 := OrderedCollection new.  1 to: self lastPage do: [:arg1 |  | tmp2 |        tmp1 add: (tmp2 := (arg1 - 1) * self pageSize + 1) -> (tmp2 + pageSize - 1) ].  tmp1 last value: self nodeList size.  ^tmp1drawBoundsForRow: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := self getListItem: arg1.  tmp5 := (tmp3 collect: [:arg2 |  arg2 heightToDisplayInList: self ]) max.  tmp4 := self width.  tmp1 := self topLeft x @ (self topLeft y + ((arg1 - 1) * tmp5)).  tmp2 := tmp1 extent: tmp4 @ tmp5.  ^tmp2updateData  self children do: #updateDataselectPrevious  | tmp1 tmp2 |  tmp1 := tabs indexOf: self selectedTab.  tmp2 := tabs at: tmp1 - 1 ifAbsent: [ ^self ].  tmp2 selected: truenewScrollPaneFor: arg1  ^self theme newScrollPaneIn: self for: arg1children  ^childrencreateClosedPolygonPathFrom: arg1 on: arg2  ^arg2 createPath: [:arg3 |  arg1 ifEmpty: [ arg3 ].        arg3 absolute.        arg3 moveTo: arg1 first.        arg1 allButFirstDo: [:arg4 |  arg3 lineTo: arg4 ].        arg3 close.        arg3 ]gapSize: arg1  gapSize := arg1addAlarm: arg1 with: arg2 with: arg3 at: arg4  ^self addAlarm: arg1 withArguments: (Array with: arg2 with: arg3) at: arg4lastColumnUnbounded  ^unboundLastColumn ifNil: [ unboundLastColumn := true ]addEmphasis: arg1  self emphasis: (emphasis bitOr: arg1 value)mouseDownInSlider: arg1  self enabled ifFalse: [ ^self ].  ^super mouseDownInSlider: arg1hasActions  ^actions notEmptygetStringSelector: arg1  self validateSelector: arg1.  getStringSelector := arg1release  container := nil.  header := nil.  self releaseActionMap.  super releaserotationDegrees  ^0.0label: arg1  font ifNil: [ self label: arg1 font: self theme buttonFont ] ifNotNil: [ self label: arg1 font: font ]lazyIncrement  ^lazyIncrement ifNil: [ lazyIncrement := 20 ]distributeHorizontally  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self selectedItems size > 2 ifFalse: [ ^self ].  tmp1 := self selectedItems anyOne left.  tmp2 := self selectedItems anyOne right.  tmp3 := 0.  self selectedItems do: [:arg1 |  tmp1 := tmp1 min: arg1 left.        tmp2 := tmp2 max: arg1 right.        tmp3 := tmp3 + arg1 width ].  tmp4 := tmp1.  tmp5 := ((tmp2 - tmp1 - tmp3) / (self selectedItems size - 1)) rounded.  (self selectedItems asSortedCollection: [:arg2 :arg3 |  arg2 left <= arg3 left ]) do: [:arg1 |  arg1 left: tmp4.        tmp4 := tmp4 + arg1 width + tmp5 ].  self changedisIndexSelected: arg1  ^self selectedIndexes includes: arg1addServices: arg1 for: arg2 extraLines: arg3  arg1 withIndexDo: [:arg4 :arg5 |  self           addService: arg4 for: arg2;           balloonTextForLastItem: arg4 description.        (arg4 usingLineAfter or: [ arg3 includes: arg5 ]) ifTrue: [ self addLine ] ]selectionFrameFor: arg1  ^arg1 bounds: arg1 selectionFrame in: selfwasHandled: arg1  wasHandled := arg1stop  self stopSteppinglayoutInset  ^layoutInsetpreferredDuplicationHandleSelector  ^#addDupHandle:keyText  ^keyTextselectedIndexes  ^selectedIndexesdrawPolyPatchFrom: arg1 to: arg2 on: arg3 usingEnds: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp5 := (arg2 - arg1) normalized.  tmp1 := tmp5 dotProduct: 1 @ 0.  tmp2 := tmp5 crossProduct: 1 @ 0.  tmp4 := self fillStyleForDirection: tmp5.  false ifTrue: [ tmp4 := tmp4 shallowCopy.        tmp9 := tmp4 origin x.        tmp10 := tmp4 origin y.        tmp6 := (tmp9 * tmp1 + (tmp10 * tmp2) + arg1 x) @ (tmp10 * tmp1 - (tmp9 * tmp2) + arg1 y).        tmp9 := tmp4 direction x.        tmp10 := tmp4 direction y.        tmp7 := (tmp9 * tmp1 + (tmp10 * tmp2)) @ (tmp10 * tmp1 - (tmp9 * tmp2)).        tmp4           origin: tmp6;           direction: tmp7 rounded;           normal: nil.        arg3 asBalloonCanvas drawPolygon: arg4 fillStyle: tmp4 ] ifFalse: [ tmp3 := MatrixTransform2x3 new           a11: tmp1;           a12: tmp2;           a21: tmp2 negated;           a22: tmp1.        tmp3 offset: arg1.        tmp8 := arg4 collect: [:arg5 |  tmp3 invertPoint: arg5 ].        arg3 asBalloonCanvas transformBy: tmp3 during: [:arg6 |  arg6 drawPolygon: tmp8 fillStyle: tmp4 ] ]waitButton  self captureEventsUntil: [:arg1 |  self anyButtonPressed ]deleteVertexAt: arg1  self setVertices: (vertices copyReplaceFrom: arg1 to: arg1 with: #())isSelectionUpdateFromView  ^isSelectionUpdateFromView ifNil: [ isSelectionUpdateFromView := false ]drawLinesToNextSiblingOn: arg1 lineColor: arg2 hasToggle: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self toggleBounds.  tmp2 := self nextSibling toggleBounds.  tmp4 := tmp1 center.  tmp3 := tmp4 x.  tmp5 := tmp4 y + 1.  tmp6 := tmp2 center y - 1.  tmp7 := self theme.  arg1 frameRectangle: (tmp3 @ tmp5 corner: (tmp3 + 1) @ tmp6) width: tmp7 treeLineWidth colors: (tmp7 treeLineColorsFrom: arg2) dashes: tmp7 treeLineDashessecondarySelectionColor  ^secondarySelectionColor ifNil: [ self class defaultSecondarySelectionColor ]invokeMetaMenu: arg1  stayUp ifFalse: [ ^self ].  ^super invokeMetaMenu: arg1strongSelectionChanged: arg1  self doubleClickSelector ifNil: [ ^self ].  self model perform: self doubleClickSelector withEnoughArguments: {arg1}fullBoundsInWorld  ^self bounds: self fullBounds in: self worldinactiveFillStyle  ^self theme windowInactiveFillStyleFor: selfname  ^self item itemName asStringshowingHandles  ^handles notNilfullList  self lastIndex < self nodeList size ifTrue: [ self nextPage: self nodeList size ]highlightColor  ^(self valueOfProperty: #highlightColor) ifNotNil: [:arg1 |  arg1 ifNil: [ self error: 'nil highlightColor' ] ] ifNil: [ owner ifNil: [ self color ] ifNotNil: [ owner highlightColor ] ]borderColor: arg1  | tmp1 |  tmp1 := selectedItems.  undoProperties ifNil: [ undoProperties := tmp1 collect: [:arg2 |  arg2 borderColor ] ].  tmp1 do: [:arg2 |  arg2 borderColor: arg1 ]client: arg1 click: arg2 dblClick: arg3 dblClickTime: arg4 dblClickTimeout: arg5 drag: arg6 threshold: arg7 event: arg8  clickClient := arg1.  clickSelector := arg2.  dblClickSelector := arg3.  dblClickTime := arg4.  dblClickTimeoutSelector := arg5.  dragSelector := arg6.  dragThreshold := arg7.  firstClickDown := arg8.  firstClickTime := arg8 timeStamp.  clickState := #firstClickDown.  localStamp := Time millisecondClockValueborderRectsFor: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := self width.  tmp1 := arg1 topLeft corner: arg1 right @ (arg1 top + tmp5).  tmp2 := arg1 left @ (arg1 bottom - tmp5) corner: arg1 bottomRight.  tmp3 := arg1 left @ (arg1 top + tmp5) corner: (arg1 left + tmp5) @ (arg1 bottom - tmp5).  tmp4 := (arg1 right - tmp5) @ (arg1 top + tmp5) corner: arg1 right @ (arg1 bottom - tmp5).  ^{tmp1 .   tmp2 .   tmp3 .   tmp4}setSelectedMorph: arg1  | tmp1 |  tmp1 := arg1 ifNotNil: [ arg1 path collect: [:arg2 |  arg2 complexContents ] ].  self lastClickedMorph: arg1.  self emptySelection.  arg1 ifNotNil: [ self addToSelection: lastClickedMorph ].  self selectionUpdateFromViewWhile: [ self listModel selection: (self newSelectionHolderWithNodePath: tmp1) ]initialize  super initialize.  self color: Color transparentmustNotClose  ^mustNotClose == truenextState  ^FTAscendingSortingState context: self contexttestCollapsing  | tmp1 |  window := SystemWindow labelled: 'foo'.  tmp1 := 0.  window openInWorld.  window announcer when: WindowCollapsed do: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 0.  window collapse.  self assert: tmp1 equals: 1setLockedIcon  closeIcon image: self class lockedIcontransform: arg1  ^arg1filterString  (function isKindOf: FTFilterFunction) ifFalse: [ ^'' ].  ^function pattern ifNil: [ '' ]setValueSelector: arg1  setValueSelector := arg1toogleSelectionValue  self item toogleSelectionValueathensHighlightPotentialDropRow: arg1 on: arg2  | tmp1 |  tmp1 := self drawBoundsForRow: arg1.  tmp1 := tmp1 intersect: self bounds ifNone: [ ^self ].  arg2 setStrokePaint: Color blue.  arg2 drawShape: tmp1adhereToTop  self adhereTo: #topnewTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5isWindowActive: arg1  ^self owner ifNil: [ true ] ifNotNil: [:arg2 |  arg2 isWindowActive: arg1 ]passiveEnabledNotOverDownFillStyle: arg1  self stateMap atPath: #(passive enabled notOver down) put: arg1.  self changeddoubleClickTimeout: arg1  self removeProperty: #inactiveDoubleClickcustomizeArrows: arg1  | tmp1 tmp2 tmp3 |  tmp3 := arg1 ifNil: [ self primaryHand ] ifNotNil: [ arg1 hand ].  tmp2 := tmp3 position.  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  tmp1 removeAllMorphs.        tmp1 addMorph: (LineMorph from: tmp2 to: arg2 color: Color black width: 1).        self arrowSpec: (arg2 - tmp2) / 5.0 ] lastPointDo: [:arg2 |  tmp1 deleteBalloon.        self halo ifNotNil: [:arg3 |  arg3 addHandles ] ].  tmp3 attachMorph: tmp1.  tmp1 showBalloon: 'Move cursor left and rightto change arrow length and style.Move it up and down to change width.Click when done.' hand: arg1 hand.  tmp1 startSteppingitem  ^item= arg1  arg1 isMorphicEvent ifFalse: [ ^false ].  ^self type = arg1 typecheckIfReadyToSlide  (possibleSlide and: [ currCharIndex > stopCharIndex ]) ifFalse: [ ^self ].  [ prevIndex < prevLines size and: [ (prevLines at: prevIndex) first < (currCharIndex - deltaCharIndex) ] ] whileTrue: [ prevIndex := prevIndex + 1 ].  (prevLines at: prevIndex) first = (currCharIndex - deltaCharIndex) ifTrue: [ prevIndex := prevIndex - 1.        possibleSlide := false.        nowSliding := true ] ifFalse: [ prevIndex = prevLines size ifTrue: [ possibleSlide := false ] ]hasExpandBox  ^expandBox notNilremoveBoxes  closeBox ifNotNil: [ closeBox delete.        closeBox := nil ].  menuBox ifNotNil: [ menuBox delete.        menuBox := nil ].  expandBox ifNotNil: [ expandBox delete.        expandBox := nil ].  collapseBox ifNotNil: [ collapseBox delete.        collapseBox := nil ]forceWidthTo: arg1  currentWidth := arg1argumentsBlock: arg1  self arguments: arg1 valueinitialize  super initialize.  topSeparator := false.  self     clipSubmorphs: true;     layoutPolicy: TableLayout new;     hResizing: #spaceFill;     vResizing: #spaceFill;     listDirection: #leftToRight;     listCentering: #topLeft;     wrapCentering: #centergrabFromScreen  self form: Form fromUserforceRefreshOnNextChange  lastRefresh := 0update: arg1  arg1 == stateSelector ifTrue: [ ^self updateState ].  arg1 == onImageSelector ifTrue: [ ^self updateOnImage ].  arg1 == offImageSelector ifTrue: [ ^self updateOffImage ].  arg1 == pressedImageSelector ifTrue: [ ^self updatePressedImage ].  ^super update: arg1rootNodeClassFromItem: arg1  ^PackageNodeExampletaskbarThumbnail  ^self taskThumbnailOfSize: self taskbarThumbnailExtentclipSubmorphs: arg1  clipSubmorphs := arg1newMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil help: arg5keystrokeActionSelector  ^keystrokeActionSelectorclick: arg1  ^self eventHandler ifNotNil: [ self eventHandler click: arg1 fromMorph: self ]highlightForDrop  self highlightForDrop: truesetNeedsRefreshExposedRows  needsRefreshExposedRows := truenewTransformMorph  ^TransformMorph newnormalLabel  ^normalLabeldisplayExtentChanged  self updateBoundscontentsMenuTitle  ^'World contents' translatedowner: arg1  owner := arg1contrastingBackgroundColor  backgroundColor := self color contrastingBlackAndWhiteColorheaderColor  ^headerColor ifNil: [ self class defaultHeaderColor ]updateCount: arg1  | tmp1 |  tmp1 := countDict at: arg1 ifAbsent: [ 0 ].  countDict at: arg1 put: tmp1 + 1layoutItems  | tmp1 |  tmp1 := 0.  self items do: [:arg1 |  arg1 icon ifNotNil: [ tmp1 := tmp1 max: arg1 icon width ].        arg1 hasSubMenu ifTrue: [ arg1 subMenu layoutItems ] ].  tmp1 isZero ifFalse: [ self addBlankIconsIfNecessary: (Smalltalk ui icons blankIconOfWidth: tmp1) ]event: arg1  event := arg1releaseCachedState  shadowForm := nil.  vertProfile := nil.  rectangleCache := Dictionary newnewPluggableDialogWindow: arg1  ^self newPluggableDialogWindow: arg1 for: nilannouncer  ^announcer ifNil: [ announcer := Announcer new ]menuStringBounds  | tmp1 |  tmp1 := super menuStringBounds.  ^tmp1 left: (tmp1 left + tmp1 right - self measureContents x) // 2beExplicit  self initializeMorph.  table     addMorph: field;     resizeAllSubviewswantsToBeCachedByHand  self isTranslucentButNotTransparent ifTrue: [ ^false ].  self submorphsDo: [:arg1 |  arg1 wantsToBeCachedByHand ifFalse: [ ^false ] ].  ^trueworldState  ^worldStatestate: arg1  state := arg1colorsAtCorners  ^Array new: 4 withAll: self colorbuildLabel: arg1 withIcon: arg2  ^(TabLabelItem tab: self)     morph: arg1 asMorph;     icon: (AlphaImageMorph new image: arg2);     yourselfcreateMenuBox  ^self theme createMenuBoxFor: selfisMouseEnter  ^self type == #mouseEntertargetPoint  ^self target bounds pointAtSideOrCorner: self ptNameexternalName  ^externalNameisSelectedMatchingTheState: arg1  ^arg1 notadoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self     fillStyle: self fillStyleToUse;     borderStyle: self borderStyleToUse;     sliderColor: (self enabled ifTrue: [ arg1 twiceDarker ] ifFalse: [ self paneColor twiceDarker paler ])drawMouseDownHighlightOn: arg1  | tmp1 |  self highlightedForMouseDown ifTrue: [ container ifNil: [ ^super drawMouseDownHighlightOn: arg1 ].        tmp1 := self selectionFrame.        arg1 frameRectangle: tmp1 width: 1 colors: {container mouseDownHighlightColor .               Color transparent} dashes: #(1 1) ]initialize  super initialize.  hResizing := vResizing := #rigid.  disableLayout := falseadd: arg1 target: arg2 selector: arg3  ^self add: arg1 target: arg2 selector: arg3 argumentList: EmptyArraybrickThemerChanged  self submorphs do: #brickThemerChangedhideCloseIcon  closeIcon hidemouseEnterDragging: arg1  (self isTopWindow not and: [ arg1 hand hasSubmorphs ]) ifTrue: [ self submorphsDo: [:arg2 |  arg2 unlock ].        arg1 hand addMouseListener: self ]preview  ^previewlayoutFrame  ^layoutFrameoptionKeyPressed  ^buttons anyMask: 2r00100000optionalOperations  ^pattern isEmptyOrNil ifTrue: [ #() ] ifFalse: [ nil ]handlesMouseMove: arg1  self eventHandler ifNotNil: [:arg2 |  (arg2 handlesMouseMove: arg1) ifTrue: [ ^true ] ].  ^arg1 hand submorphs isEmpty and: [ arg1 anyButtonPressed and: [ arg1 hand mouseFocus == self ] ]testUpdateTaskBarShouldContainsTaskbarTasksForEachWindow  | tmp1 tmp2 |  taskbar := self.  world := self.  tmp1 := world addWindow.  tmp2 := world addWindow.  taskbar updateTasks.  self assert: taskbar tasks first morph equals: tmp1.  self assert: taskbar tasks second morph equals: tmp2setDefaultLabel  self labelGraphic: self class defaultGraphicstransform: arg1 toCubicPointPolynomialAt: arg2  | tmp1 |  tmp1 := (1 to: 4) collect: [:arg3 |  ((arg1 at: arg3) at: arg2) @ ((arg1 at: 4 + arg3) at: arg2) ].  ^Cubic withAll: tmp1isDraggableNode: arg1  ^truewantsSteps  ^isCollapsed not and: [ model wantsStepsIn: self ]proceed: arg1 title: arg2  ^self theme proceedIn: self text: arg1 title: arg2addWithLabel: arg1 enablement: arg2 action: arg3  self flag: #pharoToDeprecate.  self addToggle: arg1 target: defaultTarget selector: arg3 getStateSelector: nil enablementSelector: arg2 argumentList: EmptyArraywantsToBeTopmost  ^truecomputedHeight  ^self nodeList size > self lastIndex ifTrue: [ super computedHeight ] ifFalse: [ 0 ]initializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #ScrollPaneisMinimized  ^self state == #minimizedhHideScrollbar  self hScrollbarShowing ifFalse: [ ^self ].  self removeMorph: self hScrollbar.  self vResizeScrollbar.  self resizeScrollerrecentlyChanged  ^recentlyChanged ifFalse: [ false ] ifTrue: [ recentlyChanged := false.        true ]updateContents  self bounds: self computedBounds.  self color: treeMorph pagerColorhash  ^position hash + startPoint hash + buttons hashsetProperties: arg1  1 to: arg1 size by: 2 do: [:arg2 |  self setProperty: (arg1 at: arg2) toValue: (arg1 at: arg2 + 1) ]passivate  super passivate.  self setStripeColorsFrom: self paneColorToUse.  self isEmbedded ifTrue: [ ^self ].  self lockInactivePortions.  labelArea ifNil: [ self adjustBorderUponDeactivationWhenLabeless ]selectedIndex  ^selectedIndexid  ^idalign: arg1 with: arg2  ^self position: self position + (arg2 - arg1)addAlarm: arg1 after: arg2  ^self addAlarm: arg1 withArguments: #() after: arg2progress: arg1  ^progressBar value: arg1 * 100tabDeleted: arg1  self removeTab: arg1addList: arg1  arg1 do: [:arg2 |  arg2 == #- ifTrue: [ self addLine ] ifFalse: [ self add: arg2 first capitalized translated selector: arg2 second.              (arg2 size > 2 and: [ arg2 third notNil ]) ifTrue: [ self balloonTextForLastItem: arg2 third translated ].              (arg2 size > 3 and: [ arg2 fourth notNil ]) ifTrue: [ self lastItem icon: (self iconNamed: arg2 fourth) ] ] ]releaseCachedState  super releaseCachedState.  self removeModalWindowtab: arg1  tab := arg1enabled: arg1  enabled == arg1 ifFalse: [ enabled := arg1.        self           changed: #enabled;           changed ]changed  ^fullBounds ifNil: [ self invalidRect: self privateFullBounds ] ifNotNil: [ self invalidRect: fullBounds ]createCommandContextBy: arg1 forDropAt: arg2  ^arg1 createCommandContextForSelection: #()setTargetBounds: arg1  self target bounds: arg1.  self fitTargetOwner ifTrue: [ self fitTargetBoundsInOwner: arg1 ]expandRoots  self rootsItems do: #expand.  self tableRefreshthemeChanged  super themeChanged.  morph color: morph defaultColor.  morph changedtestSelectFirst  self subclassResponsibilitykeyTextExpanded  ^ToggleMenuItemShortcut normalize: self keyTextinARow: arg1  self setAsRow     color: Color transparent;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     layoutInset: 1;     wrapCentering: #center;     cellPositioning: #leftCenter.  arg1 do: [:arg2 |  self addMorphBack: arg2 ]tabSelector  ^tabSelectoradoptPaneColor: arg1  arg1 ifNil: [ ^super adoptPaneColor: arg1 ].  self fillStyle: (self theme resizerGripNormalFillStyleFor: self)mouseLeave: arg1 fromMorph: arg2  ^self notify: arg1 from: arg2stringMorph  ^stringMorph ifNil: [ stringMorph := self mockStringMorph ]blueButtonDown: arg1  target ifNil: [ ^self delete ].  arg1 hand obtainHalo: self.  positionOffset := arg1 position - (target point: target position in: owner).  arg1 hand waitForClicksOrDrag: self event: arg1 selectors: {#transferHalo: .         nil .         nil .         #dragTarget:} threshold: 5submorphCount  ^submorphs sizewantsYellowButtonMenu  ^self getMenuSelector notNilsetItem: arg1  item := arg1handlesMouseDown: arg1  ^trueactiveDisabledOverUpFillStyle: arg1  self stateMap atPath: #(active disabled over up) put: arg1.  self changedmouseSelectorsInclude: arg1  | tmp1 tmp2 |  tmp1 := #(mouseDown mouseMove mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging doubleClick).  tmp2 := subscriptions values flatCollect: [:arg2 |  arg2 ].  ^tmp2 anySatisfy: [:arg2 |  (tmp1 includes: arg2 event) and: [ arg2 selector = arg1 ] ]isMenuItemMorph  ^falseupdateColumnMorphsWidth  | tmp1 |  self columns size > 1 ifFalse: [ ^self ].  tmp1 := self rowMorphsWidths.  self allNodeMorphs do: [:arg1 |  arg1 updateColumnMorphsWidthWith: tmp1 ]borderWidth: arg1  super borderWidth: arg1.  paragraph ifNotNil: [ self composeToBounds ]newNoButtonFor: arg1  ^self theme newNoButtonIn: self for: arg1announceDeleted  complexContents ifNotNil: [ complexContents removeDependent: self ].  super announceDeletedchildNodeClassFromItem: arg1  ^PackageClassNodeExampledrawDropShadowOn: arg1  | tmp1 tmp2 |  tmp1 := self bounds translateBy: self shadowOffset.  tmp2 := self layoutInset.  tmp1 := tmp1 topLeft + tmp2 corner: tmp1 bottomRight + tmp2.  arg1 drawString: contents in: tmp1 font: self fontToUse color: self shadowColordrawSubmorphsOn: arg1  | tmp1 |  submorphs isEmpty ifTrue: [ ^self ].  tmp1 := [:arg2 |  submorphs reverseDo: [:arg3 |  arg2 fullDrawMorph: arg3 ] ].  self clipSubmorphs ifTrue: [ arg1 clipBy: (arg1 clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: tmp1 ] ifFalse: [ tmp1 value: arg1 ]defaultColor  ^self balloonColorcolumns  ^columnsaddEmphasis: arg1  emphasis := emphasis bitOr: arg1tabSelector: arg1  tabSelector := arg1resizeWidget  newPanel  ^self theme newPanelIn: selfisFullscreen  ^self owner isKindOf: FullscreenMorphupdateChildren  self childrenDo: [:arg1 |  arg1 parent: self ]adjustWakeupTimesIfNecessary  | tmp1 |  tmp1 := Time millisecondClockValue.  (tmp1 < lastStepTime or: [ tmp1 - lastStepTime > 5000 ]) ifTrue: [ self adjustWakeupTimes: tmp1 ]selectedColor  ^self hsvMorph selectedColor alpha: self aMorph valuetoString: arg1  ^arg1 asStringchooseDropList: arg1 title: arg2 list: arg3  ^self theme chooseDropListIn: self text: arg1 title: arg2 list: arg3positionSubmorphs  super positionSubmorphs.  self submorphsDo: [:arg1 |  arg1 positionSubmorphs ]scaleToMatch: arg1  | tmp1 tmp2 tmp3 |  tmp2 := transform withScale: 1.0.  tmp3 := ((tmp2 localBoundsToGlobal: self renderedMorph fullBounds) corner - (tmp2 localPointToGlobal: self renderedMorph referencePosition)) r.  tmp3 < 1.0 ifTrue: [ tmp3 := 1.0 ].  tmp1 := (arg1 - self referencePosition) r / tmp3.  tmp1 := tmp1 < 1.0 ifTrue: [ tmp1 detentBy: 0.05 atMultiplesOf: 0.25 snap: false ] ifFalse: [ tmp1 detentBy: 0.1 atMultiplesOf: 0.5 snap: false ].  self adjustAfter: [ self scale: ((tmp1 min: 8.0) max: 0.1) ]is: arg1 beforeColumn: arg2  ^arg1 second < arg2updateOnImage  self onImage: (target perform: onImageSelector)addListener: arg1 to: arg2  | tmp1 |  tmp1 := arg2.  (tmp1 notNil and: [ tmp1 includes: arg1 ]) ifFalse: [ tmp1 ifNil: [ tmp1 := WeakArray with: arg1 ] ifNotNil: [ tmp1 := tmp1 copyWith: arg1 ] ].  tmp1 := tmp1 copyWithout: nil.  ^tmp1icon  ^container iconBlock value: self complexContentsmenuBuilder  ^menuBuilder ifNil: [ menuBuilder := (PragmaMenuBuilder pragmaKeyword: self discoveredMenuPragmaKeyword model: self)           menuSpec;           yourself ]treeLineDashes  ^container treeLineDasheslastIndex: arg1  lastIndex := arg1topRightCorner  ^self intersectionWithLineSegmentFromCenterTo: bounds topRighttestChooseDirectory  | tmp1 tmp2 |  tmp1 := FileSystem / 'tmp'.  tmp2 := [ MorphicUIManager new chooseDirectory ] valueSupplyingAnswer: {'Choose Directory' .         tmp1}.  self assert: tmp2 equals: tmp1lockInactivePortions  self isEmbedded ifTrue: [ ^self ].  self submorphsDo: [:arg1 |  arg1 == labelArea ifFalse: [ arg1 lock ] ]newLabelFor: arg1 getLabel: arg2 getEnabled: arg3  ^self theme newLabelIn: self for: arg1 getLabel: arg2 getEnabled: arg3finishedScrolling  | tmp1 tmp2 |  tmp1 := upButton borderStyle baseColor.  tmp2 := downButton borderStyle baseColor.  self stopStepping.  self scrollBarAction: nil.  upButton borderRaised.  upButton borderStyle baseColor: tmp1.  downButton borderRaised.  downButton borderStyle baseColor: tmp2.  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStylehandleMouseMove: arg1  arg1 wasHandled ifTrue: [ ^self ].  arg1 anyButtonPressed ifFalse: [ ^self ].  arg1 wasHandled: true.  self mouseMove: arg1mouseMove: arg1  target ifNil: [ ^self ].  self theme settings fastDragging ifTrue: [ target doFastReframe: self edgeName ] ifFalse: [ lastMouse at: 1 put: arg1 cursorPoint.        self targetPoint: lastMouse first - lastMouse last.        self positionPoint: lastMouse first - lastMouse second ]borderStyle  | tmp1 |  borderColor ifNil: [ ^BorderStyle default ].  borderWidth isZero ifTrue: [ ^BorderStyle default ].  self assureExtension.  tmp1 := extension borderStyle ifNil: [ BorderStyle default ].  (borderWidth = tmp1 width and: [ borderColor == tmp1 style or: [ #simple == tmp1 style and: [ borderColor = tmp1 color ] ] ]) ifFalse: [ tmp1 := borderColor isColor ifTrue: [ BorderStyle width: borderWidth color: borderColor ] ifFalse: [ (BorderStyle perform: borderColor) width: borderWidth ].        extension borderStyle: tmp1 ].  ^tmp1 trackColorFrom: selfmouseEnter: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseEnter from: arg2sleep  worldState canvas ifNil: [ ^self ].  Cursor normal show.  worldState canvas: nil.  self fullReleaseCachedStateyellowButtonActivity: arg1  | tmp1 |  self isWorldMorph ifFalse: [ | tmp2 |        tmp2 := self outermostOwnerWithYellowButtonMenu.        tmp2 ifNil: [ ^false ].        tmp2 == self ifFalse: [ ^tmp2 yellowButtonActivity: arg1 ] ].  tmp1 := self buildYellowButtonMenu: ActiveHand.  tmp1 addTitle: self externalName icon: (self iconOrThumbnailOfSize: 28).  tmp1 popUpInWorld: self currentWorld.  ^truenewAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 font: arg5 help: arg6  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 font: arg5 help: arg6newGroupbox  ^self theme newGroupboxIn: selfnewFuzzyLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newFuzzyLabelIn: self for: arg1 label: arg2 offset: 1 alpha: 0.5 getEnabled: arg3isMorph  ^truehandleMouseDown: arg1  ^self dispatchMouseDown: arg1 with: morphnameSelector  ^nameSelectoraddSpace: arg1  | tmp1 |  tmp1 := Morph new.  tmp1 extent: arg1 asPoint.  tmp1 color: Color transparent.  tmp1 borderWidth: 0.  self addMorphBack: tmp1showWidget  super showWidget.  table addMorph: actionButton.  table selectedIndex = 0 ifTrue: [ table selectIndex: 1 ]originalCenter  ^originalCentersnapToEdgeIfAppropriate  (self owner isNil or: [ self owner isHandMorph ]) ifTrue: [ ^self ].  self updateBoundsfastTable  ^fastTablesendSettingMessageTo: arg1  arg1 perform: (self settingSelector ifNil: [ ^self ]) with: self withoutListWrappersetPosition: arg1  position := arg1openInWindowLabeled: arg1  ^self openInWindowLabeled: arg1 inWorld: self currentWorldballoonHelp: arg1  self balloonHelp ifNotNil: [:arg2 |  arg2 delete ].  arg1 ifNil: [ self removeProperty: #balloonHelpMorph ] ifNotNil: [ self setProperty: #balloonHelpMorph toValue: arg1 ]showWidget  self subclassResponsibilitymouseOver: arg1  self eventHandler ifNotNil: [ self eventHandler mouseOver: arg1 fromMorph: self ]widthOfFullLabelText  ^StandardFonts windowTitleFont widthOfString: labelStringmorphicLayerNumber  ^self valueOfProperty: #morphicLayerNumber ifAbsent: [ 12 ]layoutPolicy: arg1  layoutPolicy := arg1emptySelection  self listManager emptySelectionchangeCellInset: arg1  | tmp1 |  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  self cellInset: (arg2 - arg1 cursorPoint) asIntegerPoint // 5 ].  arg1 hand attachMorph: tmp1.  tmp1 startSteppingselectMoreAtBottom  | tmp1 |  autoTargetMorph ifNil: [ ^self ].  tmp1 := autoTargetMorph index.  tmp1 < self allNodeMorphs size ifTrue: [ self autoMultiSelect: (self allNodeMorphs at: tmp1 + 1).        self selectionChanged ]gripLayoutFrame  self edgeName == #top ifTrue: [ ^self topLayoutFrame ].  self edgeName == #bottom ifTrue: [ ^self bottomLayoutFrame ].  self edgeName == #left ifTrue: [ ^self leftLayoutFrame ].  ^self rightLayoutFrameselectedItem  ^selectedItemchooseDirectory: arg1 path: arg2  ^self theme chooseDirectoryIn: self title: arg1 path: arg2anchoredMorph  ^anchoredMorphscrollDownInit  | tmp1 |  tmp1 := downButton borderStyle baseColor.  downButton borderInset.  downButton borderStyle baseColor: tmp1.  self resetTimer.  self scrollBarAction: #doScrollDown.  self doScrollDown.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nil.  downButton fillStyle: self pressedButtonFillStyle.  downButton borderStyle: self pressedButtonBorderStyledefaultColor  ^self class defaultBackgroundColoralert: arg1  ^self alert: arg1 title: 'Alert' translatedwrapSelector  ^wrapSelectorattachMorph: arg1  | tmp1 |  self releaseMouseFocus.  tmp1 := arg1 bounds extent // 2.  arg1 position: self position - tmp1.  arg1 formerPosition: arg1 position.  targetOffset := arg1 position - self position.  self addMorphBack: arg1lineBorderColor  ^self borderColordefaultColor  ^Color transparentisPotentialDropTarget  ^isPotentialDropTarget ifNil: [ isPotentialDropTarget := false ]update: arg1  arg1 = #select ifTrue: [ ^self selected: true ].  arg1 = #deselect ifTrue: [ ^self selected: false ].  arg1 = #takeHighlight ifTrue: [ ^self takeHighlight ].  super update: arg1taskbarButtonFor: arg1  ^arg1 theme newTaskbarButtonIn: arg1 for: selfhandlesKeyboard: arg1  ^truesetType: arg1 position: arg2 which: arg3 buttons: arg4 hand: arg5 stamp: arg6  type := arg1.  position := arg2.  buttons := arg4.  source := arg5.  wasHandled := false.  whichButton := arg3.  timeStamp := arg6selectionFrameChanged  | tmp1 |  selectedRow ifNil: [ ^self ].  selectedRow = 0 ifTrue: [ ^self ].  selectedRow > self getListSize ifTrue: [ ^self ].  tmp1 := self selectionFrameForRow: selectedRow.  self invalidRect: tmp1newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: true help: arg6rubberBandCells  ^falseaddEdgeGrips  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := self labelHeight.  tmp1 := WindowEdgeGripMorph new     target: self;     position: self position;     edgeName: #top.  tmp1 layoutFrame     topOffset: tmp4 negated;     bottomOffset: tmp4 negated + self class borderWidth.  tmp2 := WindowEdgeGripMorph new     target: self;     position: self position;     edgeName: #left.  tmp2 layoutFrame topOffset: tmp4 negated + 22.  tmp3 := WindowEdgeGripMorph new     target: self;     position: self position;     edgeName: #right.  tmp3 layoutFrame topOffset: tmp4 negated + 22.  self     addMorph: tmp1;     addMorph: tmp2;     addMorph: tmp3;     addMorph: (WindowEdgeGripMorph new           target: self;           position: self position;           edgeName: #bottom)fitContents  | tmp1 tmp2 |  tmp2 := self center.  submorphs isEmpty ifTrue: [ ^self ].  tmp1 := submorphs first.  self extent: tmp1 extent + (borderWidth + 6).  self center: tmp2.  tmp1 position: tmp2 - (tmp1 extent // 2)iconColumn: arg1 row: arg2  ^FTCellMorph new     addMorphBack: (self iconFor: arg2) asMorph;     yourselfgraphicalMorph: arg1  self addMorph: arg1.  arg1 lockalarms  ^alarms ifNil: [ alarms := Heap sortBlock: self alarmSortBlock ]buildBorderVertices  ^state buildBorderVerticesremoveNode: arg1  self subclassResponsibilitydrawOn: arg1  arg1 fillRectangle: self bounds fillStyle: self fillStyle borderStyle: self borderStyleshowMenuForIndex: arg1  | tmp1 tmp2 tmp3 |  tmp2 := arg1 first.  tmp3 := arg1 second.  (tmp2 notNil and: [ (self isIndexSelected: tmp2) not ]) ifTrue: [ self selectIndex: (self selectionModeStrategy indexFromPosition: arg1) ].  tmp1 := self dataSource menuColumn: (tmp3 ifNotNil: [ self columns at: tmp3 ]) row: (tmp2 ifNil: [ 0 ]).  (tmp1 isNil or: [ tmp1 isInWorld ]) ifTrue: [ ^self ].  tmp1 popUpInWorld: self currentWorldvScrollValue: arg1  scrollBar setValue: arg1keystrokeAction: arg1  | tmp1 |  keystrokeSelector ifNil: [ ^nil ].  tmp1 := model perform: keystrokeSelector withEnoughArguments: {arg1 .         self}.  ^tmp1 = trueselectedNodePath: arg1  selectedNodePath := arg1keyStrokeArrowUp: arg1  (self selectionModeStrategy is: self selectedIndex bellowRow: 1) ifFalse: [ ^self ].  self resetFunction.  self selectIndex: (self selectionModeStrategy selectableIndexAbove: self selectedIndex) event: arg1mouseDown: arg1  (stayUp or: [ self fullContainsPoint: arg1 position ]) ifFalse: [ ^self deleteIfPopUp: arg1 ].  self comeToFrontname  ^self method selectormakeBordered  | tmp1 |  self borderWidth = 0 ifFalse: [ ^self ].  tmp1 := self class borderWidth.  self submorphsDo: [:arg1 |  | tmp2 |        tmp2 := arg1 layoutFrame.        tmp2 ifNotNil: [ tmp2 rightFraction = 1 ifTrue: [ tmp2 rightOffset: tmp2 rightOffset - tmp1 ].              tmp2 leftFraction = 0 ifTrue: [ tmp2 leftOffset: tmp2 leftOffset + tmp1 ].              tmp2 bottomFraction = 1 ifTrue: [ tmp2 bottomOffset: tmp2 bottomOffset - tmp1 ] ] ].  self theme configureWindowBorderFor: selfselected  ^trueaddMyYellowButtonMenuItemsToSubmorphMenus  ^truedefaultHeight  ^ProportionalSplitterMorph splitterWidthcomeToFrontAndAddHalo  self comeToFront.  self addHalorealSearch  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := 1.  dataSource rootsItems do: [:arg1 |  (self isMatching: arg1) ifTrue: [ tmp1 add: tmp2 ].        tmp2 := tmp2 + (arg1 numberOfVisibleChildren + 1) ].  ^tmp1 asArrayptName  ^#topRightvalueFromContents  ^contentsfont: arg1  font := arg1 ifNil: [ TextStyle default defaultFont ].  self adjustHeight.  self changedselectionModeStrategy  ^self table selectionModeStrategyon: arg1 list: arg2 selected: arg3 changeSelected: arg4 menu: arg5 keystroke: arg6  self model: arg1.  self getListSelector: arg2.  self getIndexSelector: arg3.  self setIndexSelector: arg4.  self getMenuSelector: arg5.  self keystrokeActionSelector: arg6athensDisplay: arg1 atRow: arg2 on: arg3  arg2 = self mouseDownRow ifTrue: [ (arg3 setStrokePaint: (self colorForRow: arg2))           width: 1;           dashes: {1} offset: 0.        arg3 drawShape: (self selectionFrameForRow: arg2) ]setAsSpacer: arg1  self     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0;     borderWidth: 0;     extent: 1 @ 1;     color: arg1roots  ^self rootsFrom: self allNodeMorphsicon  ^iconsetTarget: arg1  target := arg1 topRendererOrSelf.  innerTarget := target renderedMorph.  innerTarget wantsDirectionHandles ifTrue: [ self showDirectionHandles: true addHandles: false ].  target hasHalo: truenewPluggableDialogWindow  ^self newPluggableDialogWindow: 'Dialog'stringBoundsToUse  ^self boundsnewTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: arg5  ^self theme newTextEditorIn: self for: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: arg5updateColumnResizersXOffset  self columnResizerFrames with: self columnResizers do: [:arg1 :arg2 |  arg2 bounds: (arg1 withBottom: scroller bottom) ]makeClosed  closed := true.  handles ifNotNil: [ self           removeHandles;           addHandles ].  self computeBoundsgetList  ^model rootNodeschangePageSize: arg1  arg1 ifNotNil: [ self updateForNewPageSize: arg1 ] ifNil: [ treeMorph removePager ]selectionFillStyle  ^self theme menuItemSelectedFillStyleFor: selfjustDroppedInto: arg1 event: arg2  | tmp1 |  super justDroppedInto: arg1 event: arg2.  tmp1 := arg2 hand halo.  (tmp1 notNil and: [ tmp1 target hasOwner: self ]) ifTrue: [ self addHalo: arg2 ].  stayUp ifFalse: [ arg2 hand newMouseFocus: self ]select  editor ifNotNil: [ editor select ]rootMenu  popUpOwner ifNil: [ ^self ].  popUpOwner owner ifNil: [ ^self ].  ^popUpOwner owner rootMenuasAthensCurvedOpenPathOn: arg1  | tmp1 |  tmp1 := self computeCurvedSegmentCtrlPoints.  ^arg1 createPath: [:arg2 |  self vertices notEmpty ifTrue: [ | tmp2 |              tmp2 := tmp1 first.              arg2 absolute.              arg2 moveTo: tmp2 second.              arg2 curveVia: (tmp1 at: 2) first to: (tmp1 at: 2) second.              tmp2 := tmp1 at: 2.              3 to: tmp1 size - 1 do: [:arg3 |  | tmp3 |                    tmp3 := tmp1 at: arg3.                    arg2 curveVia: tmp2 third and: tmp3 first to: tmp3 second.                    tmp2 := tmp3 ].              arg2 curveVia: tmp2 third to: tmp1 last second ].        arg2 ]isCursorOverHandle  ^truedrawIcon: arg1 on: arg2 in: arg3  | tmp1 |  self isEnabled ifTrue: [ tmp1 := arg1 ] ifFalse: [ tmp1 := Form extent: arg1 extent depth: 32.        tmp1 fillColor: (Color white alpha: 0.003922).        (tmp1 getCanvas asAlphaBlendingCanvas: 0.5) drawImage: arg1 at: 0 @ 0 ].  arg2 translucentImage: tmp1 at: arg3 topLeft + (0 @ ((arg3 height - tmp1 height) // 2))nameColumn: arg1 row: arg2  ^FTCellMorph new     addMorphBack: (self elementAt: arg2) name asStringMorph;     yourselfasAthensPathOn: arg1  ^self isCurvy ifTrue: [ self isOpen ifTrue: [ self asAthensCurvedOpenPathOn: arg1 ] ifFalse: [ self asAthensCurvedPathOn: arg1 ] ] ifFalse: [ self asAthensLinePathOn: arg1 ]counter  ^counteropen  self openInWorldpopUpOwner  ^popUpOwneractivate  super activate.  self nonVisibleTabs do: [:arg1 |  arg1 activate ]openPath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container setSelectedMorph: nil ].  tmp1 := self findPathIn: arg1.  tmp1 ifNil: [ ^container setSelectedMorph: nil ].  tmp1 isExpanded ifTrue: [ tmp1 refreshExpandedState ] ifFalse: [ tmp1 toggleExpandedState ].  container adjustSubmorphPositions.  tmp1 changed.  arg1 size = 1 ifTrue: [ ^container setSelectedMorph: tmp1 ].  ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild openPath: arg1 allButFirst ]mouseLeave: arg1  super mouseLeave: arg1.  self hideOverEditableTextCursoranimateMinimize  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self worldTaskbar ifNil: [ ^self ].  tmp2 := ((tmp1 taskButtonOf: self) ifNil: [ ^self ]) bounds.  tmp3 := self isFlexed ifTrue: [ (owner transform globalPointToLocal: fullFrame topLeft) extent: fullFrame extent ] ifFalse: [ fullFrame ].  tmp5 := self theme numberOfStepsForAnimations.  tmp4 := ((tmp5 - 1) / tmp5 to: 0 by: -1 / tmp5) collect: [:arg1 |  tmp2 interpolateTo: tmp3 at: ((20 raisedTo: arg1) - 1) / 19 ].  self fastAnimateRectangles: tmp4offset  ^offsetnextToLastPoint  self isCurvy ifTrue: [ curveState ifNil: [ self coefficients ].        ^curveState third ] ifFalse: [ ^vertices at: vertices size - 1 ]worldMenu  ^worldState worldMenusubmorphAfter  | tmp1 |  owner ifNil: [ ^nil ].  ^(tmp1 := owner submorphIndexOf: self) = owner submorphs size ifTrue: [ nil ] ifFalse: [ owner submorphs at: tmp1 + 1 ]isBorderStyle  ^trueaddKern: arg1  kern := kern + arg1handlesMouseOverDragging: arg1  ^truecontentWidth  | tmp1 |  tmp1 := 0.  self container allNodeMorphs do: [:arg1 |  tmp1 := tmp1 max: (arg1 columnMorphAt: self index) width ].  ^tmp1removeIcon  icon ifNotNil: [ self removeMorph: icon ]theme  ^Smalltalk ui themeisOpaque  ^self valueOfProperty: #isOpaque ifAbsent: [ false ]selectIndex: arg1  self selectIndexes: {arg1}sharesFindReplace  ^falselabelFromString: arg1  self labelGraphic: (StringMorph contents: arg1) imageFormdone  self delete.  self activeTask ifNotNil: [:arg1 |  arg1 activate ]interactSelector  ^#interacticon: arg1  arg1 ifNil: [ label icon: nil ] ifNotNil: [ label icon: (AlphaImageMorph new image: arg1) ]iconSelector  ^iconSelectorstraighten  self setVertices: {vertices first .         vertices last}modalOwner  ^self valueOfProperty: #modalOwnerwantsDroppedMorph: arg1 event: arg2  arg1 dragTransferType == #dragTransfer ifFalse: [ ^false ].  ^wantsDropSelector ifNil: [ model wantsDroppedMorph: arg1 event: arg2 inMorph: self ] ifNotNil: [ model perform: wantsDropSelector with: arg1 passenger ]forceDisplayUpdate  defaultColor  ^Color yellowshrinkWrap  ^shrinkWrap ifNil: [ shrinkWrap := false ]isSelected  ^isSelectedcolumnsChanged  self removeColumnResizers.  self removeTopHeader.  self buildTopHeader.  self addColumnResizershasSubMenu  ^subMenu notNilwidth  ^bounds widthcolumn  ^columntestSetForward  | tmp1 |  cases := {(tmp1 := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ tmp1 forwardDirection: 180.0.        self assert: tmp1 forwardDirection equals: 0.0 ]newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: true help: arg6reframedTo: arg1  self bounds: (self bounds withSideOrCorner: location setToPoint: arg1)setIndexSelector: arg1  setIndexSelector := arg1hasContentsSelector: arg1  self validateSelector: arg1.  hasContentsSelector := arg1newSliderFor: arg1 getValue: arg2 setValue: arg3 getEnabled: arg4 help: arg5  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: 0 max: 1 quantum: nil getEnabled: arg4 help: arg5recentlyChanged  ^falseon: arg1 list: arg2 primarySelection: arg3 changePrimarySelection: arg4 listSelection: arg5 changeListSelection: arg6 menu: arg7 keystroke: arg8  getSelectionListSelector := arg5.  setSelectionListSelector := arg6.  self on: arg1 list: arg2 selected: arg3 changeSelected: arg4 menu: arg7 keystroke: arg8.  self beMultipleSelection.  ^selfstep  self shouldCopy = dragHand shiftPressed ifTrue: [ ^self ].  self shouldCopy: dragHand shiftPressed.  self updateCopyIconrootsFrom: arg1  ^arg1 select: [:arg2 |  arg2 indentLevel isZero ]scroller: arg1  scroller ifNotNil: [ scroller delete ].  scroller := arg1.  self addMorph: scroller.  self resizeScrollercellSpacing  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #none ] ifNotNil: [ tmp1 cellSpacing ]step  | tmp1 |  tmp1 := self scrollBarAction.  tmp1 ifNotNil: [ self perform: tmp1 ]wantsKeyboardFocus  ^self takesKeyboardFocus and: [ self visible and: [ self enabled ] ]getListSelector  ^self dataSource getListSelectornewOverflowRowForAll: arg1  ^self theme newOverflowRowIn: self forAll: arg1pageSearchText: arg1  | tmp1 tmp2 tmp3 |  pageSearchText := arg1.  self changed: #pageSearchText.  tmp1 := OrderedCollection new.  self nodeList doWithIndex: [:arg2 :arg3 |  (arg2 includesSubstringAnywhere: pageSearchText) ifTrue: [ tmp1 add: arg3 -> arg2 ] ].  tmp1 ifEmpty: [ ^self flash ].  tmp1 size > 1 ifTrue: [ tmp2 := UIManager default chooseFrom: (tmp1 collect: [:arg4 |  arg4 value ]) values: (tmp1 collect: [:arg4 |  arg4 key ]) lines: nil title: ''.        tmp2 ifNil: [ ^self ] ] ifFalse: [ tmp2 := tmp1 first key ].  self currentPage: (self pageOfNodeIndex: tmp2).  tmp3 := self nodeList at: tmp2.  treeMorph scroller submorphsDo: [:arg5 |  arg5 complexContents == tmp3 ifTrue: [ treeMorph listManager setSelectedMorph: arg5.              ^treeMorph scrollSelectionIntoView ] ]getListSelector  ^getListSelectortreeLineWidth: arg1  treeLineWidth := arg1heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]isMultiple  ^self subclassResponsibilitynoteNewOwner: arg1  super noteNewOwner: arg1.  self defer: [ self adoptPaneColor: self paneColor ]vResizing  ^vResizingtaskbarIcon  self model ifNotNil: [ self model taskbarIcon ifNotNil: [:arg1 |  ^arg1 ] ].  ^super taskbarIconnewMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newMorphListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6haloMorphs  ^self hands collect: [:arg1 |  arg1 halo ] thenSelect: [:arg2 |  arg2 notNil ]collapseNodePath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container setSelectedMorph: nil ].  tmp1 := nil.  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ arg2 complexContents = arg1 first ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNotNil: [ (tmp1 isExpanded and: [ arg1 size = 1 ]) ifTrue: [ tmp1 toggleExpandedState.              container adjustSubmorphPositions ].        tmp1 changed.        arg1 size = 1 ifTrue: [ ^container listManager setSelectedMorph: tmp1 ].        ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild collapseNodePath: arg1 allButFirst ] ].  ^container setSelectedMorph: nilsetSelectionListSelector  ^setSelectionListSelectoraddHandlesForWorldHalos  | tmp1 tmp2 |  tmp2 := self world ifNil: [ target world ].  self removeAllMorphs.  self bounds: target bounds.  tmp1 := tmp2 bounds insetBy: 9.  target addWorldHandlesTo: self box: tmp1.  self addNameBeneath: (tmp1 insetBy: (0 @ 0 corner: 0 @ 10)) string: innerTarget externalName.  growingOrRotating := false.  self layoutChanged.  self changedoffImageSelector  ^offImageSelectorarrowEvent: arg1 key: arg2  | tmp1 tmp2 tmp3 tmp4 |  self allNodeMorphs ifEmpty: [ ^false ].  self listModel okToChange ifFalse: [ ^false ].  self listModel okToDiscardEdits ifFalse: [ ^false ].  tmp1 := nil.  tmp2 := lastClickedMorph.  tmp2 ifNotNil: [ (self listModel arrowEvent: arg1 key: arg2 target: tmp2) ifTrue: [ ^true ] ].  tmp3 := tmp2 ifNil: [ 0 ] ifNotNil: [ tmp2 index ].  tmp4 := (arg1 shiftPressed and: [ self isMultiple ]) or: [ self autoMultiSelection ].  arg2 = Character arrowDown ifTrue: [ tmp1 := tmp3 + 1 ].  arg2 = Character arrowUp ifTrue: [ tmp1 := tmp3 - 1 max: 1 ].  arg2 = Character home ifTrue: [ tmp1 := 1 ].  arg2 = Character end ifTrue: [ tmp1 := self allNodeMorphs size ].  arg2 = Character pageUp ifTrue: [ tmp1 := tmp3 - self numSelectionsInView max: 1 ].  arg2 = Character pageDown ifTrue: [ tmp1 := tmp3 + self numSelectionsInView ].  arg2 = Character arrowRight ifTrue: [ tmp2 ifNil: [ ^false ].        (tmp2 canExpand and: [ tmp2 isExpanded not ]) ifTrue: [ self toggleExpandedState: tmp2.              ^true ] ifFalse: [ tmp1 := tmp3 + 1 ] ].  arg2 = Character arrowLeft ifTrue: [ tmp2 ifNil: [ ^false ].        (tmp2 canExpand and: [ tmp2 isExpanded ]) ifTrue: [ self toggleExpandedState: tmp2.              ^true ] ifFalse: [ | tmp5 |              tmp5 := tmp2 parent.              tmp5 ifNil: [ tmp1 := tmp3 - 1 max: 1 ] ifNotNil: [ self toggleExpandedState: tmp5.                    tmp1 := tmp5 index ] ] ].  tmp1 notNil ifTrue: [ self setSelectionIndexFromKeyboard: tmp1 multiSelection: tmp4 event: arg1.        self selectionChanged.        ^true ].  ^falseadjustSubmorphPositionsOf: arg1 startIdx: arg2 startPos: arg3  | tmp1 tmp2 |  tmp1 := arg3.  tmp2 := arg2.  arg1 do: [:arg4 |  | tmp3 |        tmp3 := arg4 height.        arg4 index: tmp2.        arg4 bounds: (tmp1 extent: arg4 width @ tmp3).        maxNodeWidth := maxNodeWidth max: arg4 fullBounds width.        tmp2 := tmp2 + 1.        tmp1 := tmp1 + (0 @ tmp3) ].  self setScrollDeltas.  ^tmp1tasks  ^tasksremoveMatchString  self setProperty: #matchString toValue: String new.  self displayFiltered: nillayoutFrame: arg1  self layoutFrame == arg1 ifTrue: [ ^self ].  self assureExtension layoutFrame: arg1 asLayoutFrame.  self layoutChangedpreferredButtonCornerStyle  ^nildrawDropShadowOn: arg1  | tmp1 |  tmp1 := self areasRemainingToFill: (self bounds expandBy: self shadowMargins).  (tmp1 anySatisfy: [:arg2 |  arg1 isVisible: arg2 ]) ifFalse: [ ^self ].  self isActive ifTrue: [ self theme drawWindowActiveDropShadowFor: self on: arg1 ] ifFalse: [ self theme drawWindowInactiveDropShadowFor: self on: arg1 ]testForTiltedStickyness  | tmp1 |  tmp1 := Morph new openCenteredInWorld.  cases := Array with: tmp1.  self assert: tmp1 topRendererOrSelf isSticky not.  tmp1 beSticky.  self assert: tmp1 topRendererOrSelf isSticky.  tmp1 addFlexShell.  cases := Array with: tmp1 topRendererOrSelf.  tmp1 topRendererOrSelf rotationDegrees: 45.0.  self assert: tmp1 topRendererOrSelf isSticky.  tmp1 beUnsticky.  self assert: tmp1 topRendererOrSelf isSticky not.  tmp1 topRendererOrSelf delete.  ^trueisMatching: arg1  ^(dataSource toString: arg1) beginsWith: patternupdate: arg1  | tmp1 |  arg1 ifNil: [ ^self ].  (arg1 == getLabelSelector or: [ arg1 == getIconSelector ]) ifTrue: [ getIconSelector ifNotNil: [ self icon: (model perform: getIconSelector) ].        self label: (getLabelSelector ifNotNil: [ model perform: getLabelSelector ]) ].  arg1 == getFontSelector ifTrue: [ self font: (model perform: getFontSelector) ].  tmp1 := self getModelState.  (tmp1 ~= self lastState or: [ getStateSelector isNil and: [ arg1 == #onOffColor ] ]) ifTrue: [ self color: self colorToUse.        self lastState: tmp1 ].  arg1 == getEnabledSelector ifTrue: [ ^self enabled: (model perform: getEnabledSelector) ].  getColorSelector ifNotNil: [ | tmp2 |        color = (tmp2 := model perform: getColorSelector) ifFalse: [ self privateColor: tmp2.              self onColor: color offColor: color.              self changed ] ].  arg1 isArray ifFalse: [ ^self ].  arg1 size == 2 ifFalse: [ ^self ].  arg1 first = #askBeforeChanging: ifTrue: [ self askBeforeChanging: arg1 second ]model: arg1  | tmp1 |  tmp1 := self dataSource model.  tmp1 ifNotNil: [ tmp1 removeDependent: self ].  arg1 ifNotNil: [ arg1 addDependent: self ].  self dataSource model: arg1vScrollValue: arg1  self verticalScrollBar setValue: arg1containsPoint: arg1  (super containsPoint: arg1) ifFalse: [ ^false ].  container ifNil: [ ^true ].  self startingIndex > text size ifTrue: [ ^super containsPoint: arg1 ].  ^self paragraph containsPoint: arg1fillsOwner: arg1  self fillsOwner == arg1 ifTrue: [ ^self ].  self setContainer: (arg1 ifTrue: [ wrapFlag := true.              container ifNil: [ TextContainer new for: self minWidth: textStyle lineGrid * 2 ] ifNotNil: [ container fillsOwner: true ] ] ifFalse: [ self avoidsOcclusions ifFalse: [ nil ] ifTrue: [ container fillsOwner: false ] ])commandOrCrontrolKeyPressed: arg1  ^Smalltalk os isMacOS ifTrue: [ arg1 controlKeyPressed ] ifFalse: [ arg1 commandKeyPressed ]method  ^methodnewFuzzyLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newFuzzyLabelIn: self for: arg1 label: arg2 offset: 1 alpha: 0.5 getEnabled: arg3heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]scaledIntoFormOfSize: arg1  ^self imageForm scaledIntoFormOfSize: arg1stringColorToUse  ^self isEnabled ifTrue: [ self isSelected ifTrue: [ self theme menuItemSelectedTextColorFor: self ] ifFalse: [ self theme menuItemNormalTextColorFor: self ] ] ifFalse: [ self theme menuItemDisabledTextColorFor: self ]isKeystroke  ^falsevisible: arg1  (extension isNil and: [ arg1 ]) ifTrue: [ ^self ].  self visible == arg1 ifTrue: [ ^self ].  self assureExtension visible: arg1.  self changed.  owner ifNotNil: [ owner layoutChanged ]initializeDesktopCommandKeySelectors  | tmp1 |  tmp1 := IdentityDictionary new.  self defaultDesktopCommandKeyTriplets do: [:arg1 |  | tmp2 |        tmp2 := MessageSend receiver: arg1 second selector: arg1 third.        tmp1 at: arg1 first put: tmp2 ].  self setProperty: #commandKeySelectors toValue: tmp1.  ^tmp1newGroupbox: arg1  ^self theme newGroupboxIn: self label: arg1frameRectangle: arg1 on: arg2  arg2 frameAndFillRectangle: arg1 fillColor: Color transparent borderWidth: self width topLeftColor: self topLeftColor bottomRightColor: self bottomRightColornewWindowFor: arg1 title: arg2  ^self theme newWindowIn: self for: arg1 title: arg2horizontalScrollBarHeight  ^horizontalScrollBar ifNil: [ 0 ] ifNotNil: [ self isHorizontalScrollBarVisible ifFalse: [ ^0 ].        self scrollBarThickness ]exportAs: arg1 using: arg2  | tmp1 |  tmp1 := UIManager default chooseForSaveFileReference: 'Save Morph as ' , arg1 asUppercase extensions: {arg1} path: self externalName , '.' , arg1.  tmp1 ifNotNil: [ arg2 putForm: self imageForm onFileNamed: tmp1 ]verticalPlacement  ^verticalPlacementextent: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp1 := self width.  tmp2 := self height.  tmp3 := self hIsScrollbarShowing.  tmp4 := self vIsScrollbarShowing.  tmp5 := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  tmp6 := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  tmp7 := self scrollBarThickness + 16.  tmp8 := self scrollBarThickness + 20.  tmp5 ifTrue: [ tmp6 ifTrue: [ tmp7 := 1.              tmp8 := 1 ] ifFalse: [ tmp7 := self scrollBarThickness ] ] ifFalse: [ tmp6 ifTrue: [ tmp7 := self scrollBarThickness + 5 ] ].  super extent: (arg1 max: tmp8 @ tmp7).  self     resizeScrollBars;     resizeScroller;     hideOrShowScrollBars.  (self height ~~ tmp2 or: [ tmp3 ~~ self hIsScrollbarShowing ]) ifTrue: [ self vIsScrollbarShowing ifTrue: [ self vSetScrollDelta ] ].  (self width ~~ tmp1 or: [ tmp4 ~~ self vIsScrollbarShowing ]) ifTrue: [ self hIsScrollbarShowing ifTrue: [ self hSetScrollDelta ] ]setOffset: arg1 angle: arg2 scale: arg3  transform := MorphicTransform offset: arg1 angle: arg2 scale: arg3.  self changedupdatePager  self pager ifNotNil: [ self pager buildPanel ]newCloseButton  ^self newCloseButtonFor: selfokToClose  model ifNil: [ ^true ].  ^model okToClosedrawLinesToNextSiblingOn: arg1 hasToggle: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  tmp1 := self toggleRectangle.  tmp2 := self nextSibling toggleRectangle.  tmp4 := tmp1 center.  tmp3 := tmp4 x.  tmp9 := container notExpandedForm extent y // 2 + 1.  tmp5 := tmp4 y + (self hasToggle ifTrue: [ tmp9 ] ifFalse: [ 0 ]).  tmp6 := tmp2 center y - (self nextSibling hasToggle ifTrue: [ tmp9 ] ifFalse: [ 0 ]).  tmp7 := self theme.  tmp8 := container treeLineWidth // 2.  arg1 frameRectangle: ((tmp3 - tmp8) @ tmp5 corner: (tmp3 + tmp8 + (container treeLineWidth \\ 2)) @ tmp6) width: container treeLineWidth colors: (tmp7 treeLineColorsFrom: self lineColor) dashes: self treeLineDashesopenOn: arg1  | tmp1 |  self rootClass: arg1.  tmp1 := StandardWindow new model: self.  tmp1 title: arg1 name , ' hierarchy'.  tmp1 addMorph: self treeMorph fullFrame: LayoutFrame identity.  tmp1 themeChanged.  tmp1 openInWorld.  ^tmp1spotterActDefault  ^self isTopWindow ifTrue: [ self comeToFront ] ifFalse: [ self activate ]browseItem  Smalltalk tools browser openOnClass: self itemrotationDegrees  ^0.0searchText: arg1  | tmp1 tmp2 tmp3 |  arg1 isEmptyOrNil ifTrue: [ ^#() ].  tmp3 := OrderedCollection new.  tmp1 := arg1 trimBoth asLowercase.  1 to: self numberOfRows do: [:arg2 |  tmp2 := (self elementWrapped: (self elementAt: arg2)) contents trimBoth asLowercase.        (tmp2 beginsWith: tmp1) ifTrue: [ tmp3 add: arg2 ] ].  ^tmp3 asArraynewSize  ^newSizesplitterAbove  | tmp1 |  tmp1 := (self siblingSplitters select: [:arg1 |  arg1 top > self top and: [ self overlapsHorizontal: arg1 ] ]) asSortedCollection: [:arg2 :arg3 |  arg2 top < arg3 top ].  ^tmp1 ifEmpty: [ nil ] ifNotEmpty: [:arg4 |  arg4 first ]headerRow  ^headerRowmouseMove: arg1  self basicIsSticky ifFalse: [ self fastFramingOn ifTrue: [ self doFastFrameDrag: arg1 startPoint ] ifFalse: [ self grabSelfOrTopRenderer: arg1 ] ]hue  ^(self selectedColor hue / 359 * 255) asIntegertaskListButtonFor: arg1  ^self theme newTaskListButtonIn: arg1 for: selfrestoreDefaultPaneColor  self setStripeColorsFrom: self paneColorbeIconTop  iconPosition := #top.  self update: getIconSelectorhighlighted  ^highlightedtakesKeyboardFocus  ^truewantsToBeTopmost  ^truedeleteIfPopUp  stayUp ifFalse: [ self topRendererOrSelf delete ].  (popUpOwner notNil and: [ popUpOwner isMenuItemMorph ]) ifTrue: [ popUpOwner isSelected: false.        popUpOwner owner isMenuMorph ifTrue: [ popUpOwner owner deleteIfPopUp ] ]useRoundedCorners  self cornerStyle: #roundedcolumn: arg1  column := arg1patternFromString: arg1  ^[ arg1 asRegexIgnoringCase ] on: RegexSyntaxError do: [:arg2 |   ]model: arg1  model := arg1spotterItemsFor: arg1  < spotterOrder: 10>  self flag: #pharoFixMe.  ^arg1 listProcessor     title: 'Items';     candidatesLimit: Float infinity;     allCandidates: [ self items ];     itemName: #contents;     itemIcon: [:arg2 |  arg2 icon ];     actLogic: [:arg2 :arg3 |  arg2 hasSubMenu ifTrue: [ arg3 diveIn ] ifFalse: [ arg2 spotterActDefault.              arg3 exit ] ];     filter: GTFilterSubstringreferencePositionInWorld  ^self pointInWorld: self referencePositiondisableTableLayout  ^disableLayoutinitializeLayout  self     changeTableLayout;     layoutInset: 16;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     extent: self minimumExtentwidth  ^widthborderStyleForSymbol: arg1  | tmp1 tmp2 |  tmp1 := BorderStyle borderStyleForSymbol: arg1 asSymbol.  tmp1 ifNil: [ self error: 'bad style' ].  tmp2 := self borderStyle.  tmp1     width: tmp2 width;     baseColor: tmp2 baseColor.  ^(self canDrawBorder: tmp1) ifTrue: [ tmp1 ] ifFalse: [ nil ]wantsToBeTopmost  ^truedrawTodayOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := 'Today: ' , (Date today printFormat: #(2 1 3 $  3 1 1)).  tmp4 := self weekdayFont widthOfString: tmp1.  tmp2 := self weekdayFont height.  tmp3 := self bounds bottomCenter translateBy: (tmp4 // -2) @ (tmp2 negated - 5).  tmp5 := tmp3 extent: tmp4 @ tmp2.  touchPoints at: tmp5 put: #handleTodayTouched.  arg1 drawString: tmp1 at: tmp3 font: self weekdayFont color: Color graynewDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil useIndex: true help: arg5initializeTasks  self tasks: ((self currentWorld submorphs collect: [:arg1 |  arg1 taskbarTask ]) select: [:arg1 |  arg1 notNil ]) asOrderedCollectionthemeChanged  super themeChanged.  morph ifNotNil: #themeChangedpattern: arg1  super pattern: arg1.  regex := self patternFromString: arg1delete  hand ifNotNil: [ hand showTemporaryCursor: nil ].  super deletetrackColorFrom: arg1  baseColor ifNil: [ self color: arg1 raisedColor ]hasTwoColorDash  ^self dashedBorder notNil and: [ self dashedBorder size > 2 ]modalUnlockFrom: arg1  self unlockpattern: arg1  pattern := arg1closeable  ^closeableopenAsIsIn: arg1  arg1 addMorphCentered: self.  self allMorphs do: [:arg2 |  arg2 layoutChanged ].  arg1 startSteppingSubmorphsOf: self.  self announceOpened.  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ]initializeFor: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self labelSizeIn: arg1.  tmp2 := self labelOfSize: tmp3.  self addEmphaseTo: tmp2.  tmp1 := self theme newRowIn: arg1 for: {(self model taskbarIcon ifNil: [ ^nil ]) asMorph .         tmp2}.  tmp1 cellInset: 2.  self     label: tmp1 font: self theme buttonFont;     extent: self minExtent;     hResizing: #rigid;     vResizing: #rigid;     useSquareCorners;     getMenuSelector: #taskbarButtonMenu:.  self initializeAnnouncements.  tmp2 color: (self model isCollapsed ifTrue: [ self theme taskbarItemLabelColorForCollapsed: self ] ifFalse: [ self theme taskbarItemLabelColorForExpanded: self ])includesSubstringAnywhere: arg1  ^(Array with: self asString) includesSubstringAnywhere: arg1setDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedprogress  ^bar progresstestFillInTheBlank  | tmp1 |  tmp1 := [ MorphicUIManager new request: 'Your favorite color?' ] valueSupplyingAnswer: #('Your favorite color?' 'blue').  self assert: tmp1 equals: 'blue'splitters  ^self submorphsSatisfying: [:arg1 |  arg1 isKindOf: ProportionalSplitterMorph ]updateSelectionFromModel  ^self listManager updateSelectionFromModelheightToDisplayInList: arg1  ^self contents heightToDisplayInList: arg1setSelectedMorph: arg1  model perform: (setSelectionSelector ifNil: [ ^self ]) with: arg1 complexContentsscrollDeltaHeight  ^10isRadioButton  ^isRadioButtoncanBeDragged  ^model isDraggableNode: selfdefaultTreeMorph  ^super defaultTreeMorph     chunkSize: 100;     yourselfmouseEnter: arg1  super mouseEnter: arg1.  self wantsKeyboardFocus ifFalse: [ ^self ].  self keyboardFocusOnMouseDown ifFalse: [ self takeKeyboardFocus ]abort: arg1  ^self abort: arg1 title: 'Error' translatedtransformedBy: arg1  arg1 isIdentity ifTrue: [ ^self ].  ^self center: (arg1 localPointToGlobal: self center)takeKeyboardFocus  self activeHand newKeyboardFocus: selfdrawNullTextOn: arg1  arg1 fillRectangle: bounds color: (self backgroundColor ifNil: [ Color transparent ])resizeContainerFrom: arg1 to: arg2  ^arg1 corner: arg2selectionColorToUse: arg1  arg1 = self selectionColorToUse ifTrue: [ ^self ].  arg1 ifNil: [ self removeProperty: #selectionColorToUse ] ifNotNil: [ self setProperty: #selectionColorToUse toValue: arg1 ]topHeader  ^topHeaderlastRefresh  ^lastRefresh ifNil: [ lastRefresh := 0 ]scale: arg1  scale = arg1 ifTrue: [ ^self ].  scale := arg1.  self     cachedForm: nil;     changed;     changed: #scalekeyboardFocusChange: arg1  self announceKeyboardFocusChange: arg1spotterItemsFor: arg1  < spotterOrder: 10>  self hasSubMenu ifTrue: [ self subMenu spotterItemsFor: arg1 ]getMenuSelector: arg1  self dataSource getMenuSelector: arg1privateSubmorphs: arg1  submorphs := arg1visibleSystemWindows  ^self submorphsSatisfying: [:arg1 |  arg1 isSystemWindow and: [ arg1 visible ] ]addService: arg1 for: arg2  arg1 addServiceFor: arg2 toMenu: selfhSetScrollDelta  | tmp1 |  tmp1 := self hPageDelta.  self hScrollbar     scrollDelta: tmp1 / 10 pageDelta: tmp1;     interval: self hScrollbarInterval;     setValue: self hScrollbarValueactivate  super activate.  self world ifNil: [ ^self ].  self rememberedKeyboardFocus ifNil: [ self defaultFocusMorph ifNotNil: [:arg1 |  arg1 takeKeyboardFocus ] ]hExtraScrollRange  ^5addHandles  | tmp1 |  self removeHandles.  handles := OrderedCollection new.  tmp1 := Array with: 0 @ -4 with: 4 @ 3 with: -3 @ 3.  vertices withIndexDo: [:arg1 :arg2 |  | tmp2 tmp3 |        tmp2 := EllipseMorph newBounds: (Rectangle center: arg1 extent: 8 @ 8) color: (self handleColorAt: arg2).        tmp2 on: #mouseMove send: #dragVertex:event:fromHandle: to: self withValue: arg2.        tmp2 on: #mouseUp send: #dropVertex:event:fromHandle: to: self withValue: arg2.        tmp2 on: #click send: #clickVertex:event:fromHandle: to: self withValue: arg2.        self addMorph: tmp2.        handles addLast: tmp2.        (closed or: [ 1 = vertices size or: [ arg2 < vertices size ] ]) ifTrue: [ tmp3 := PolygonMorph vertices: (tmp1 collect: [:arg3 |  arg3 + ((arg1 + (vertices atWrap: arg2 + 1)) // 2) ]) color: Color green borderWidth: 1 borderColor: Color black.              tmp3 on: #mouseDown send: #newVertex:event:fromHandle: to: self withValue: arg2.              self addMorph: tmp3.              handles addLast: tmp3 ] ].  self isCurvy ifTrue: [ self           updateHandles;           layoutChanged ].  self changedworldMorphs  ^self world submorphs , ((self tasks select: [:arg1 |  arg1 morph owner = self world activeHand ]) collect: [:arg1 |  arg1 morph ])chooseDropList: arg1 title: arg2 list: arg3  ^self theme chooseDropListIn: self text: arg1 title: arg2 list: arg3orderedTasks  ^taskslayoutProperties: arg1  layoutProperties := arg1buttonMorph  ^buttonMorphnewToolbar  ^self theme newToolbarIn: selfmouseDown: arg1  self column sortDataSource: self table dataSourcedefaultBackgroundColor  ^self theme windowColorFor: selfisLineMorph  ^closed notisDropEvent  ^falseactionSelector: arg1  (nil = arg1 or: [ 'nil' = arg1 or: [ arg1 isEmpty ] ]) ifTrue: [ ^actionSelector := nil ].  actionSelector := arg1 asSymboldetachAllKeymapCategories  self kmDispatcher detachAllKeymapCategoriesselectionRectsFrom: arg1 to: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  arg1 <= arg2 ifTrue: [ tmp4 := arg1.        tmp5 := arg2 ] ifFalse: [ tmp5 := arg1.        tmp4 := arg2 ].  tmp4 = tmp5 ifTrue: [ tmp6 := self caretWidth.        ^Array with: (tmp4 topLeft - (tmp6 @ 0) corner: tmp4 bottomLeft + ((tmp6 + 1) @ 0)) ].  tmp1 := self lineIndexForCharacter: tmp4 stringIndex.  tmp2 := self lineIndexForCharacter: tmp5 stringIndex.  tmp1 = tmp2 ifTrue: [ ^Array with: (tmp4 topLeft corner: tmp5 bottomRight) ].  tmp3 := OrderedCollection new.  tmp3 addLast: (tmp4 topLeft corner: (lines at: tmp1) bottomRight).  tmp1 + 1 to: tmp2 - 1 do: [:arg3 |  | tmp7 |        tmp7 := lines at: arg3.        (tmp7 left = tmp3 last left and: [ tmp7 right = tmp3 last right ]) ifTrue: [ | tmp8 |              tmp8 := tmp3 removeLast.              tmp3 add: (tmp8 bottom: tmp7 bottom) ] ifFalse: [ tmp3 add: tmp7 rectangle ] ].  tmp3 addLast: ((lines at: tmp2) topLeft rectangle: tmp5 bottomLeft).  ^tmp3childrenDo: arg1  self roots do: arg1prepareForScaling  ^self addFlexShellbuildButtonWithIcon  ^PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: nilchanged  self assureExtension.  extension fillStyle: self fillStyleToUse.  color := self fillStyle asColor.  super changedsetFramesForLabelArea  self theme configureWindowLabelAreaFrameFor: selfleftArrowStroked: arg1  | tmp1 |  super leftArrowStroked: arg1.  tmp1 := arg1 hand keyboardFocus.  tmp1 isMenubar ifTrue: [ tmp1 keyStroke: arg1 ]addCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  arg1 addUpdating: #opacityString selector: #changeOpacityheader  ^header ifNil: [ header := (Morph new extent: 0 @ 0) color: Color transparent ]rowHeight: arg1  ^50drawSubmorphsOn: arg1  submorphs ifEmpty: [ ^self ].  arg1 transformBy: transform clippingTo: (arg1 clipRect intersect: owner clippingBounds ifNone: [ ^self ]) during: [:arg2 |  | tmp1 tmp2 |        tmp1 := self topVisibleRowForCanvas: arg2.        tmp2 := self bottomVisibleRowForCanvas: arg2 startingAt: tmp1.        tmp2 to: tmp1 by: -1 do: [:arg3 |  | tmp3 |              tmp3 := submorphs basicAt: arg3.              self drawRawColorOn: arg2 forSubmorph: tmp3.              arg2 fullDrawMorph: tmp3 ] ] smoothing: smoothing.  owner withTreeLines ifTrue: [ owner drawLinesOn: arg1 ].  owner enabled ifFalse: [ arg1 fillRectangle: owner innerBounds fillStyle: (owner paneColor alpha: 0.2) ]columns  ^columnssendEvent: arg1 focus: arg2 clear: arg3  | tmp1 |  arg2 ifNotNil: [ ^self sendFocusEvent: arg1 to: arg2 clear: arg3 ].  ActiveEvent := arg1.  tmp1 := owner processEvent: arg1.  ActiveEvent := nil.  ^tmp1frameOval: arg1 on: arg2  arg2 frameOval: arg1 width: self width color: self colorgetSelectionListSelector  ^getSelectionListSelectorexpandedFormForMorph: arg1  ^(arg1 selected and: [ self selectionColor luminance < 0.7 ]) ifTrue: [ self theme whiteTreeExpandedForm ] ifFalse: [ self theme treeExpandedForm ]proceed: arg1  ^self proceed: arg1 title: 'Proceed' translatedposition  ^self subclassResponsibilitykeystrokeSelector  ^keystrokeSelectorcellColumn: arg1 row: arg2  ^FTCellMorph new     cellInset: 5;     addMorphBack: (self iconFor: arg2) asMorph;     addMorphBack: (self elementAt: arg2) name asMorph;     yourselfpointSize  ^size value: selfgridVisible  ^self hasProperty: #gridVisibleeditBalloonHelpContent: arg1  | tmp1 |  tmp1 := UIManager default multiLineRequest: 'Edit the balloon help text for ' translated , self externalName initialAnswer: (arg1 ifNil: [ self noHelpString ] ifNotNil: [ arg1 ]) answerHeight: 200.  tmp1 ifNil: [ ^self ].  (tmp1 isEmpty or: [ tmp1 asString = self noHelpString ]) ifTrue: [ self setBalloonText: nil ] ifFalse: [ self setBalloonText: tmp1 ]sortElements: arg1  unsortedElements ifNil: [ unsortedElements := self rootsItems ].  self rootItem children: (self rootItem children sorted: arg1)drawOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self toggleRectangle.  tmp2 := bounds withLeft: tmp1 right + 4.  self drawToggleOn: arg1 in: tmp1.  tmp4 := complexContents preferredColor ifNil: [ self theme textColor ].  icon ifNotNil: [ arg1 translucentImage: icon at: tmp2 left @ (self top + ((self height - icon height) // 2)).        tmp2 := tmp2 left: tmp2 left + icon width + 2 ].  (container columns isNil or: [ (contents asString indexOf: Character tab) = 0 ]) ifTrue: [ tmp2 := tmp2 top: (tmp2 top + tmp2 bottom - self fontToUse height) // 2.        contents treeRenderOn: arg1 bounds: tmp2 color: tmp4 font: self fontToUse from: self ] ifFalse: [ tmp5 := tmp2 left.        tmp3 := contents asString readStream.        container columns do: [:arg2 |  | tmp6 tmp7 |              tmp7 := tmp5 @ tmp2 top extent: arg2 @ tmp2 height.              tmp6 := tmp3 upTo: Character tab.              tmp6 isEmpty ifFalse: [ arg1 drawString: tmp6 in: tmp7 font: self fontToUse color: tmp4 ].              tmp5 := tmp7 right + 5 ] ]tabHitWithEvent: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 hand keyboardFocus.  tmp2 := self allMorphs select: [:arg2 |  arg2 wouldAcceptKeyboardFocusUponTab and: [ arg2 isLocked not ] ].  tmp2 isEmpty ifTrue: [ ^self ].  tmp3 := tmp2 indexOf: tmp1 ifAbsent: [ nil ].  tmp4 := tmp2 atWrap: (tmp3 ifNotNil: [ arg1 shiftPressed ifTrue: [ tmp3 - 1 ] ifFalse: [ tmp3 + 1 ] ] ifNil: [ 1 ]).  arg1 hand newKeyboardFocus: tmp4.  tmp4 editor selectAll.  tmp4 invalidRect: tmp4 boundsvExtraScrollRange  ^self scrollDeltaHeightminExtentHorizontal: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  tmp7 := properties minCellSize asPoint.  tmp2 := tmp7 x.  tmp3 := tmp7 y.  tmp7 := properties maxCellSize asPoint.  tmp4 := tmp7 x.  tmp5 := tmp7 y.  tmp1 := properties cellInset asPoint.  tmp6 := 0.  tmp8 := tmp9 := 0.  arg1 submorphsDo: [:arg2 |  | tmp10 tmp11 |        arg2 disableTableLayout ifFalse: [ tmp6 := tmp6 + 1.              tmp7 := arg2 minExtent.              tmp11 := tmp7 x.              tmp10 := tmp7 y.              tmp11 < tmp2 ifTrue: [ tmp11 := tmp2 ] ifFalse: [ tmp11 > tmp4 ifTrue: [ tmp11 := tmp4 ] ].              tmp10 < tmp3 ifTrue: [ tmp10 := tmp3 ] ifFalse: [ tmp10 > tmp5 ifTrue: [ tmp10 := tmp5 ] ].              tmp8 := tmp8 + tmp11.              tmp10 > tmp9 ifTrue: [ tmp9 := tmp10 ] ] ].  tmp6 > 1 ifTrue: [ tmp8 := tmp8 + ((tmp6 - 1) * tmp1 x) ].  ^minExtentCache := tmp8 @ tmp9wantsKeyboardFocusOnMouseDown  ^self wantsKeyboardFocus and: [ self valueOfProperty: #wantsKeyboardFocusOnMouseDown ifAbsent: [ false ] ]showActions  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := SortedCollection new.  tmp4 := [:arg1 :arg2 |  tmp1 add: (RGMethodDefinition realClass: arg1 selector: arg2) ].  self eventHandler ifNotNil: [ tmp1 := self eventHandler methodRefList.        (self eventHandler handlesMouseDown: nil) ifFalse: [ tmp4 value: HandMorph value: #grabMorph: ] ].  #(#keyStroke: #mouseDown: #mouseEnter: #mouseLeave: #mouseMove: #mouseUp: #doButtonAction) do: [:arg3 |  tmp2 := self class whichClassIncludesSelector: arg3.        tmp2 ifNotNil: [ tmp2 == Morph ifFalse: [ tmp4 value: tmp2 value: arg3 ] ] ].  (self respondsTo: #actionSelector) ifTrue: [ tmp3 := self actionSelector.        tmp2 := self target class whichClassIncludesSelector: tmp3.        tmp2 ifNotNil: [ tmp2 == Morph ifFalse: [ tmp4 value: tmp2 value: tmp3 ] ] ].  Smalltalk tools messageList browse: tmp1 title: 'Actions of ' , self printStringaddIcon  self addMorph: closeIcon fullFrame: (LayoutFrame identity           bottomFraction: 0;           leftFraction: 1;           topOffset: 6 * self displayScaleFactor;           leftOffset: self iconRightOffset negated - (12 * self displayScaleFactor);           rightOffset: self iconRightOffset negated;           bottomOffset: 18 * self displayScaleFactor;           yourself)clipSubmorphs  ^trueshowTemporaryCursor: arg1  self showTemporaryCursor: arg1 hotSpotOffset: 0 @ 0initializeLabelMorph  labelMorph := LabelMorph new     extent: 0 @ 0;     yourselfdefaultTreeMorph  ^super defaultTreeMorph     pageSize: 100;     yourselfenabled: arg1  dragItemSelector: arg1  dragItemSelector := arg1.  arg1 ifNotNil: [ self dragEnabled: true ]initialize  super initialize.  self     fitTargetOwner: false;     edgeName: #right;     extent: self defaultWidth @ self defaultHeight;     hResizing: #spaceFill;     vResizing: #spaceFillwrapDirection  ^#nonetextHighlightColor  ^self valueOfProperty: #textHighlightColor ifAbsent: [ Color red ]toggleClosable  mustNotClose ifTrue: [ self makeClosable ] ifFalse: [ self makeUnclosable ]elements: arg1  elements := arg1isLastColumn  ^container columns last = selfmouseLeaveDragging: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersalert: arg1 title: arg2 configure: arg3  ^self theme alertIn: self text: arg1 title: arg2 configure: arg3indexForInserting: arg1 at: arg2 in: arg3  ^1doubleClick: arg1  (self selectionModeStrategy selectableIndexContainingPoint: arg1 cursorPoint) ifNotNil: [:arg2 |  self doAnnounce: (FTStrongSelectionChanged index: arg2 event: arg1) ]changed  self extent > (200 @ 200) ifTrue: [ (target notNil and: [ target ~~ self world ]) ifTrue: [ (self fullBounds areasOutside: target bounds) do: [:arg1 |  self invalidRect: arg1 ] ].        self submorphsDo: [:arg2 |  arg2 changed ] ] ifFalse: [ super changed ]isMultipleSelection  ^self selectionStrategy isMultipleendShapeColor: arg1  self borderColor: arg1.  self isClosed ifTrue: [ self color: arg1 ]canResizeColumn  ^container owner isResizablesetPageInterval: arg1  currentPageFirstIndex := arg1 first.  self showCurrentPage.  self changed: #currentPagecontents  ^Array newcheckClickableZone  | tmp1 tmp2 |  tmp1 := self computeCheckTopLeft.  tmp2 := self retrieveCheckIcon.  ^tmp1 corner: tmp2 extent + tmp1storeOn: arg1  arg1 nextPutAll: type.  arg1 space.  self timeStamp storeOn: arg1.  arg1 space.  position x asInteger storeOn: arg1.  arg1 space.  position y asInteger storeOn: arg1.  arg1 space.  buttons storeOn: arg1.  arg1 space.  keyValue storeOn: arg1.  arg1 space.  charCode storeOn: arg1.  arg1 space.  scanCode storeOn: arg1selectableIndexContainingPoint: arg1  ^self tableContainer rowIndexContainingPoint: arg1model: arg1  model := arg1actualClass  ^FTColumnspInitializeColumsFrom: arg1  self columns: arg1 columnsdrawOn: arg1  | tmp1 |  self shouldBeHighlighted ifTrue: [ arg1 fillRectangle: self bounds fillStyle: self selectionFillStyle.        tmp1 := self selectionTextColor ] ifFalse: [ tmp1 := color ].  self drawIconOn: arg1.  arg1 drawString: self contents in: self menuStringBounds font: self fontToUse color: tmp1.  self drawSubmenuMarkerOn: arg1initializeSelectedIndexes  selectedIndexes := #().  highlightedIndexes := #()getRootsSelector: arg1  getRootsSelector := arg1.  self update: getRootsSelectortestSelectedRowIndex  table selectIndex: 3.  self assert: strategy selectedRowIndex equals: 3.  table selectIndex: 4.  self assert: strategy selectedRowIndex equals: 4pasteBuffer  ^PasteBuffercanScrollDown  ^value < 1hideScrollBarsIndefinitely: arg1  self hideVScrollBarIndefinitely: arg1.  self hideHScrollBarIndefinitely: arg1isOn  ^state == #onhasLeftMorphsChanged  ^(leftMorphs isEmpty and: [ enteredMorphs position = 0 ]) notaddToggleItemsToHaloMenu: arg1  super addToggleItemsToHaloMenu: arg1.  arg1 addUpdating: #enabledString target: self selector: #toggleEnabledinitialize  indentation := 0.  super initialize.  self cellInset: 2minWidth  ^self valueOfProperty: #minWidth ifAbsent: [ self measureContents x ]enabled: arg1  self submorphs do: [:arg2 |  arg2 enabled: arg1 ]adjustSubmorphPositions  | tmp1 |  tmp1 := 0 @ 0.  scroller submorphsDo: [:arg1 |  | tmp2 |        tmp2 := arg1 height.        arg1 privateBounds: (tmp1 extent: arg1 width @ tmp2).        tmp1 := tmp1 + (0 @ tmp2) ].  self     changed;     layoutChanged;     setScrollDeltashandlesMouseDown: arg1  ^trueremoveWindow: arg1  arg1 isCloseable ifFalse: [ ^self ].  arg1 announcer unsubscribe: self.  self tabGroup removePage: arg1.  arg1 configureForUnembedding.  arg1 deleteDiscardingChanges.  self tabGroup pages ifEmpty: [ self owner delete ]wantsDroppedMorph: arg1 event: arg2  ^arg1 dragTransferType == #dragTransfer ifTrue: [ dropItemSelector ifNil: [ ^false ].        wantsDropSelector ifNil: [ ^true ].        model perform: wantsDropSelector with: arg1 passenger ] ifFalse: [ self model wantsDroppedMorph: arg1 event: arg2 inMorph: self ]target  ^targethIsScrollbarShowing  ^submorphs includes: hScrollBarwantsToBeDroppedInto: arg1  ^arg1 isWorldMorph or: [ self embeddable ]thumbColor  ^self sliderColorshowFirstRowSelection  self deprecated: 'Use #showFirstSelection instead' transformWith: '`@receiver showFirstRowSelection' -> '`@receiver showFirstSelection'.  ^self showFirstSelectioninitializeDownButton  downButton := self theme newScrollBarDownButtonFor: self.  downButton color: self thumbColor.  downButton on: #mouseDown send: #scrollDownInit to: self.  downButton on: #mouseUp send: #finishedScrolling to: self.  self updateDownButtonImage.  downButton     borderWidth: 1;     borderColor: Color lightGray.  downButton cornerStyle: (self theme scrollbarButtonCornerStyleIn: self window).  downButton on: #mouseUp send: #finishedScrolling: to: self.  downButton on: #mouseEnter send: #mouseEnterDownButton: to: self.  downButton on: #mouseLeave send: #mouseLeaveDownButton: to: self.  self addMorph: downButtonupdateList  super rootItems: (self initialRootItems select: [:arg1 |  (self pattern matchesIn: arg1 name) notEmpty ]).  super updateListcreateCollapseBox  ^self theme createCollapseBoxFor: selfrowMorphForNode: arg1 inColumn: arg2  | tmp1 |  tmp1 := Morph new     color: Color transparent;     layoutPolicy: RowLayout new;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: arg2 container columnInset @ arg2 container rowInset;     listDirection: #leftToRight;     cellPositioning: #leftCenter;     cellInset: 4 @ 0;     yourself.  tmp1 addMorph: self.  arg2 isFirstColumn ifTrue: [ | tmp2 |        tmp2 := arg2 container iconBlock value: arg1.        tmp2 ifNotNil: [ tmp1 addMorph: tmp2 asMorph ].        tmp1 layoutInset: 0 @ arg2 container rowInset ].  ^tmp1children  self subclassResponsibilityisMultiple  ^multipleSelection ifNil: [ multipleSelection := false ]selectedItemOrItemsOrNil  | tmp1 |  tmp1 := self selectedNodeList collect: [:arg1 |  arg1 item ].  ^tmp1 isEmpty ifTrue: [ nil ] ifFalse: [ tmp1 ]newAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7 entryCompletion: arg8  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7 entryCompletion: arg8isExplicit  ^false= arg1  ^super = arg1 and: [ self borders = arg1 borders ]step  | tmp1 |  tmp1 := self actualViewee.  tmp1 ifNil: [ self stopStepping.        ^self ].  self changeddisabledStyle  ^disabledStylebuildPanel  | tmp1 tmp2 tmp3 tmp4 |  self removeAllMorphs.  pageSize ifNil: [ ^self ].  self atBottom: (treeMorph scrollValue y <= self verticalScrollbarFrontier and: [ treeMorph vIsScrollable ]) not.  tmp1 := OrderedCollection new.  (self nodeList size > self lastIndex and: [ self atBottom ]) ifTrue: [ pageSizeEditor := self textEntryLabel: 'Page size' get: #pageSizeToString set: #chunkSizeFromString: help: 'Change the page size or the number of pages if the input begins with "/"' translated class: String.        pageSizeEditor hResizing: #rigid.        pageSizeEditor width: (self preferedFont widthOfString: '1000000').        tmp1 add: pageSizeEditor.        tmp2 := self buttonLabel: self class smallToRightIcon actionSelector: #nextPage arguments: {} getEnabled: #notOnLastPage help: 'Next page'.        tmp1 add: tmp2.        tmp3 := self buttonLabel: self class smallToRightEndIcon actionSelector: #fullList arguments: {} getEnabled: #notOnLastPage help: 'Last page'.        tmp1 add: tmp3.        tmp1 add: (self spacer: 10) ].  self withSearch ifTrue: [ tmp4 := self textEntryLabel: '' get: #pageSearchText set: #pageSearchText: help: 'Enter a text correspondig to your search' translated class: String.        tmp4 ghostText: 'Searched text'.        tmp1 add: tmp4.        tmp1 add: (self spacer: 10) ].  tmp1 add: (self spacer: 1).  tmp1 add: (LabelMorph contents: self lastIndex asString , ' / ' , self nodeList size asString font: self preferedFont).  self addAllMorphs: tmp1.  self updateContentsselectHandsToDrawForDamage: arg1  ^hands select: [:arg2 |  arg2 needsToBeDrawn and: [ arg2 hasChanged or: [ self is: arg2 overlappingDamagedAreaIn: arg1 ] ] ]top: arg1  self position: bounds left @ arg1testInform  | tmp1 |  [ MorphicUIManager new inform: 'blah' ] on: Exception do: [:arg1 |  tmp1 := arg1 messageText ].  self assert: tmp1 equals: 'blah'addedMorph: arg1  extent: arg1  arg1 = bounds extent ifTrue: [ ^self ].  bounds isWide ifTrue: [ super extent: (arg1 x max: self sliderThickness * 2) @ arg1 y ] ifFalse: [ super extent: arg1 x @ (arg1 y max: self sliderThickness * 2) ].  self     removeAllMorphs;     initializeSlidernewTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5 entryCompletion: arg6  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5 entryCompletion: arg6predominantDockingBarsOfChastes: arg1  | tmp1 tmp2 tmp3 |  (self owner isNil or: [ self owner isHandMorph ]) ifTrue: [ ^#() ].  tmp1 := self owner dockingBars.  tmp2 := tmp1 select: [:arg2 |  arg1 includes: arg2 edgeToAdhereTo ].  (arg1 includes: self edgeToAdhereTo) ifFalse: [ ^tmp2 ].  tmp2 := tmp2 reject: [:arg2 |  arg2 edgeToAdhereTo = self edgeToAdhereTo ].  tmp3 := tmp1 select: [:arg2 |  arg2 edgeToAdhereTo = self edgeToAdhereTo ].  tmp3 := tmp3 copyAfter: self.  ^tmp2 , tmp3sticky  ^stickyselectedDisabledFillStyle  ^self theme controlButtonSelectedDisabledFillStyleFor: selfapply: arg1  | tmp1 |  tmp1 := target bounds.  target bounds: (tmp1 origin + (0 @ arg1 y) corner: tmp1 corner + (arg1 x @ 0))dismissViaHalo  self setProperty: #lastPosition toValue: self positionInWorld.  self dismissMorphhHideScrollBar  self hIsScrollbarShowing ifFalse: [ ^scroller offset: self hMargin negated @ scroller offset y ].  self removeMorph: hScrollBar.  scroller offset: self hMargin negated @ scroller offset y.  self resetExtentdisable  self subclassResponsibilitylineBorderWidth: arg1  self borderWidth: arg1storeValue  ^self owner owner storeValueallowDeselection  self allowsDeselection: truegenerateDropFilesEvent: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp4 := arg1 second.  tmp4 = 0 ifTrue: [ tmp4 := Time millisecondClockValue ].  tmp6 := arg1 third.  tmp1 := arg1 fourth @ arg1 fifth.  tmp2 := 0.  tmp3 := arg1 sixth.  tmp2 := tmp2 bitOr: (tmp3 bitShift: 3).  tmp5 := arg1 seventh.  tmp6 = 4 ifTrue: [ owner borderWidth: 0.        ^DropFilesEvent new setPosition: tmp1 contents: tmp5 hand: self ].  tmp6 = 1 ifTrue: [ owner           borderWidth: 4;           borderColor: owner color asColor negated ].  tmp6 = 2 ifTrue: [  ].  tmp6 = 3 ifTrue: [ owner borderWidth: 0 ].  ^nilactiveHand  | tmp1 |  tmp1 := self world ifNil: [ ^ActiveHand ].  ^tmp1 activeHand ifNil: [ ^ActiveHand ]expandAllTo: arg1  self subclassResponsibilitywantsRoundedCorners  ^(self theme windowPreferredCornerStyleFor: self) == #roundedviewBox: arg1  (self viewBox isNil or: [ self viewBox extent ~= arg1 extent ]) ifTrue: [ worldState canvas: nil ].  super viewBox: arg1.  worldState handsDo: [:arg2 |  arg2 releaseKeyboardFocus ].  self fullRepaintNeededhandlesMouseStillDown: arg1  ^(self innerBounds containsPoint: arg1 position) notnewContentMorph  | tmp1 |  tmp1 := PanelMorph new     roundedCorners: #(2 3 4);     changeTableLayout;     layoutInset: 4;     cellInset: 8;     vResizing: #spaceFill;     hResizing: #spaceFill.  tmp1 borderStyle: (self theme tabPanelBorderStyleFor: self).  ^tmp1updateTabs  | tmp1 tmp2 |  tmp1 := self tabsAndControls.  self removeAllMorphs.  tmp1 ifEmpty: [ ^self ].  tmp2 := self selectedTab.  self tabs do: [:arg1 |  arg1 selected: arg1 == tmp2 ].  self     addAllMorphs: self tabsAndControls;     adoptPaneColorkeyboardFocusChange: arg1  super keyboardFocusChange: arg1.  paragraph ifNotNil: [ paragraph focused: arg1 ].  arg1 ifTrue: [ self hasFocus ifFalse: [ self editor ].        self showOverEditableTextCursor ] ifFalse: [ self world ifNotNil: [:arg2 |  arg2 handsDo: [:arg3 |  arg3 keyboardFocus == self ifTrue: [ ^self ] ].              self releaseEditor ].        self hideOverEditableTextCursor ].  self manageCursor.  self focusChangedfitInWorld  self bounds: (self bounds translatedAndSquishedToBeWithin: self world bounds)simulateMiddleClick  self simulateClickWith: MouseEvent blueButtonenabled: arg1  enabled = arg1 ifTrue: [ ^self ].  enabled := arg1.  self changed: #enabled.  self     adoptPaneColor: self paneColor;     changedcreateCommandContextBy: arg1 forDropAt: arg2  | tmp1 tmp2 |  tmp1 := self container rowIndexContainingPoint: arg2 position.  tmp1 ifNil: [ ^super createCommandContextBy: arg1 forDropAt: arg2 ].  tmp2 := dataSource elementAt: tmp1.  ^arg1 createCommandContextForSelection: {tmp2}highlightedIndex  ^self highlightedIndexes ifNotEmpty: #first ifEmpty: [ 0 ]aboutToBeGrabbedBy: arg1  self beFloating.  self updateBounds.  self updateColor.  (self bounds containsPoint: arg1 position) ifFalse: [ self center: arg1 position ]setTimeStamp: arg1  timeStamp := arg1drawingClass  ^ImageMorphchangeDisableTableLayout  self disableTableLayout: self disableTableLayout not.  self layoutChangedtestMoving  | tmp1 tmp2 tmp3 |  window := SystemWindow labelled: 'foo'.  tmp1 := 0.  tmp3 := nil.  window openInWorld.  tmp2 := window bounds.  window announcer when: WindowMoved do: [:arg1 |  tmp1 := tmp1 + 1.        tmp3 := arg1 ].  self assert: tmp1 equals: 0.  self assert: tmp3 isNil.  window position: 50 @ 50.  self assert: tmp1 equals: 1.  self assert: tmp3 oldPosition equals: tmp2 origin.  self assert: tmp3 newPosition equals: 50 @ 50.  window position: 50 @ 50.  self assert: tmp1 equals: 1.  window extent: 50 @ 60.  self assert: tmp1 equals: 1windowsSatisfying: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self submorphs do: [:arg2 |  arg2 embeddedWindowOrNil ifNotNil: [ (arg1 value: arg2) ifTrue: [ tmp1 addLast: arg2 ] ] ].  ^tmp1dataBounds  ^self visibleBounds withTop: self container topHeader bottomrunStepMethodsIn: arg1  | tmp1 tmp2 |  tmp1 := self class deferredUIMessages.  [ (tmp2 := tmp1 nextOrNil) isNil ] whileFalse: [ tmp2 value ].  self runLocalStepMethodsIn: arg1.  Transcript stepGlobaldefaultFadingFactor  ^0.04initialize  super initialize.  counter := 0wantsToBeTopmost  ^trueneedsRefreshExposedRows  ^needsRefreshExposedRowstoggleExpandedState: arg1  arg1 toggleExpandedState.  client innerWidgetChangedwantsKeyboardFocusOnShiftClick  ^owner topRendererOrSelf wantsKeyboardFocusFor: selfsilentlySelected: arg1  (state isSelectedMatchingTheState: arg1) ifTrue: [ ^self ].  state := state newStateForSelected: arg1.  arg1 ifTrue: [ self showCloseIcon ]deleteBalloonTarget: arg1  self balloonHelp: nildefaultBorderColor  ^self theme menuBorderColorwantsSteps  ^self subMorph wantsStepsdrawDropShadowOn: arg1  arg1 translateBy: self shadowOffset during: [:arg2 |  arg2 roundShadowCornersOf: self during: [ (arg2 isVisible: self bounds) ifTrue: [ arg2 fillRectangle: self bounds fillStyle: self shadowColor ] ] ]fillStyle  ^fillStyle ifNil: [ self color ]updateSliderBounds  slider bounds: self totalSliderArea.  sliderShadow bounds: self totalSliderArea.  self computeSliderpreferredKeyboardPosition  | tmp1 |  tmp1 := super preferredKeyboardPosition.  ^tmp1 + (self bounds: self bounds in: self currentWorld) topLeftsetDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedcollapseAll  self requestView: MorphTreeChangeRequest collapseAllenabled  ^enabledchildrenBlock  ^childrenBlockhandleWindowEvent: arg1  ^self dispatchWindowEvent: arg1 with: morphlabel  ^self labelMorph contentshands  ^handsmouseDown: arg1  | tmp1 tmp2 |  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ].  tmp1 := self itemFromPoint: arg1 position.  (tmp1 notNil and: [ tmp1 inToggleArea: (tmp1 point: arg1 position from: self) ]) ifTrue: [ ^self toggleExpandedState: tmp1 event: arg1 ].  arg1 yellowButtonPressed ifTrue: [ (self yellowButtonActivity: arg1 shiftPressed) ifTrue: [ ^self ] ].  tmp1 ifNil: [ ^super mouseDown: arg1 ].  tmp1 highlightForMouseDown.  tmp2 := Array with: #click: with: nil with: nil with: (self dragEnabled ifTrue: [ #startDrag: ] ifFalse: [ nil ]).  arg1 hand waitForClicksOrDrag: self event: arg1 selectors: tmp2 threshold: 10mouseDownRow  ^self valueOfProperty: #mouseDownRowensureAtLeastOneColumn  self columns ifNotEmpty: [ ^self ].  self addColumn: self class defaultColumnnormalLabel: arg1  normalLabel := arg1themedFillStyle  ^self theme morphTreeColumnFillStyleFor: selfisRowIndexExceding: arg1  | tmp1 tmp2 tmp3 |  tmp1 := headerRow ifNotNil: [ 1 ] ifNil: [ 0 ].  tmp2 := arg1 - self table showIndex + 1 + tmp1.  tmp3 := self table rowHeight + self table intercellSpacing y.  ^tmp2 * tmp3 > self heightnodeListSelector  ^#rootNodesaddHandles  self addCircleHandlesisSortingEnabled  ^falseendInteraction  | tmp1 |  (target isInWorld not or: [ owner isNil ]) ifTrue: [ ^self ].  [ target isFlexMorph and: [ target hasNoScaleOrRotation ] ] whileTrue: [ tmp1 := target firstSubmorph.        target removeFlexShell.        target := tmp1 ].  self isInWorld ifTrue: [ self comeToFront.        self addHandles ]layoutBounds  | tmp1 tmp2 |  tmp1 := self layoutInset.  tmp2 := self innerBounds.  tmp1 isZero ifTrue: [ ^tmp2 ].  ^tmp2 insetBy: tmp1handlesKeyboard: arg1  (super handlesKeyboard: arg1) ifTrue: [ ^true ].  ^arg1 keyCharacter = Character escape or: [ self defaultButton notNil and: [ arg1 keyCharacter = Character cr ] ]acceptDroppingMorph: arg1 event: arg2  self dataSource dropItemSelector ifNotNil: [ ^super acceptDroppingMorph: arg1 event: arg2 ].  self model acceptDroppingMorph: arg1 event: arg2 inMorph: self.  self refreshasAthensLinePathOn: arg1  | tmp1 |  tmp1 := self adjustSegmentPointsForArrows.  ^arg1 createPath: [:arg2 |  tmp1 notEmpty ifTrue: [ arg2 absolute.              arg2 moveTo: tmp1 first.              tmp1 allButFirstDo: [:arg3 |  arg2 lineTo: arg3 ] ].        self isClosed ifTrue: [ arg2 close ].        arg2 ]windowEvent: arg1  selectRowIndex: arg1 event: arg2  self deprecated: 'Use #selectIndex:event: instead' transformWith: '`@receiver selectRowIndex: `@statements1 event: `@statements2' -> '`@receiver selectIndex: `@statements1 event: `@statements2'.  self selectIndex: arg1 event: arg2getStateSelector: arg1  getStateSelector := arg1.  self updateSelectionselectNextTask  self selectTask: (self tasks after: self activeTask ifAbsent: [ self tasks isEmpty ifFalse: [ self tasks first ] ])firstChild  ^firstChildrotationDegrees: arg1  scaledImage  | tmp1 |  tmp1 := self form.  tmp1 boundingBox area = 0 ifTrue: [ ^tmp1 ].  (self layout == #scaled and: [ self extent ~= tmp1 extent ]) ifTrue: [ ^tmp1 magnify: tmp1 boundingBox by: self extent / tmp1 extent smoothing: 2 ].  (self layout == #scaledAspect and: [ self extent ~= tmp1 extent ]) ifTrue: [ ^self width / tmp1 width > (self height / tmp1 height) ifTrue: [ tmp1 magnify: tmp1 boundingBox by: self height / tmp1 height smoothing: 2 ] ifFalse: [ tmp1 magnify: tmp1 boundingBox by: self width / tmp1 width smoothing: 2 ] ].  self scale ~= 1 ifTrue: [ ^tmp1 magnify: tmp1 boundingBox by: self scale smoothing: 2 ].  ^tmp1isStepping: arg1  lastStepMessage ifNotNil: [ lastStepMessage receiver == arg1 ifTrue: [ ^true ] ].  stepList do: [:arg2 |  arg2 receiver == arg1 ifTrue: [ ^true ] ].  ^falsenewYesButtonFor: arg1  ^self theme newYesButtonIn: self for: arg1selectRowIndex: arg1 event: arg2  self deprecated: 'Use #selectIndex:event: instead.' transformWith: '`@receiver selectRowIndex: `@statements1 event: `@statements2' -> '`@receiver selectIndex: `@statements1 event: `@statements2'.  self selectIndex: arg1 event: arg2doneExtending  otherSelection ifNotNil: [ selectedItems := otherSelection selectedItems , selectedItems.        otherSelection delete.        self setOtherSelection: nil ].  self changed.  self layoutChanged.  super privateBounds: ((Rectangle merging: (selectedItems collect: [:arg1 |  arg1 fullBounds ])) expandBy: 8).  self changed.  self addHaloexpandedToggleImage  ^expandedToggleImage ifNil: [ expandedToggleImage := ImageMorph new form: self expandedForm ]arguments  ^argumentstarget  ^targetlistChanged  listItems := (1 to: self getListSize) collect: [:arg1 |  self getListItem: arg1 ].  self removeAllMorphs.  self extent: 0 @ 0.  listItems do: [:arg1 |  self addMorphBack: arg1 ].  selectedRow := nil.  selectedRows := PluggableSet integerSet.  maxWidth := nil.  self     adjustHeight;     adjustWidth.  listItems do: [:arg1 |  arg1 layoutChanged ].  self changedinvokeAt: arg1 in: arg2  ^self invokeAt: arg1 in: arg2 allowKeyboard: self menuKeyboardControlbackgroundMorph  ^backgroundMorphheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]newAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 font: arg5 help: arg6 entryCompletion: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 font: arg5 help: arg6 entryCompletion: arg7dragNDropEnabled  self separateDragAndDrop.  ^self dragEnabled and: [ self dropEnabled ]colorToUse  ^self paneColorsystemWindows  ^self submorphsSatisfying: [:arg1 |  arg1 isSystemWindow ]treeMorphClass  ^MorphTreeMorphlabel: arg1  label := arg1.  icon setBalloonText: label maxLineLength: 100realWindowExtent: arg1  realWindowExtent := arg1isActivated  ^truelocalPointToGlobal: arg1  ^self point: arg1 in: nilprintOn: arg1  arg1 nextPut: $[.  arg1     nextPutAll: self cursorPoint printString;     space.  arg1     nextPutAll: type;     space.  arg1 nextPutAll: self modifierString.  arg1 nextPutAll: self buttonString.  arg1     nextPutAll: timeStamp printString;     space.  arg1 nextPutAll: self windowIndex printString.  arg1 nextPut: $]step  stringMorph contents: work printStringisMultiSelection  ^numberOfSelectedTabs > 1colorForRow: arg1  ^(self isRowSelected: arg1) ifTrue: [ self theme selectionTextColor ] ifFalse: [ self color ]initializeJob: arg1  super initialize.  lock := Semaphore forMutualExclusion.  job := arg1.  hasResult := false.  lastRefresh := 0.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #leftCenter;     listCentering: #center;     hResizing: #spaceFill;     vResizing: #shrinkWrap.  labelMorph := StringMorph contents: job title font: StandardFonts defaultFont.  bar := JobProgressBarMorph new.  bar     on: #mouseUp send: #debug to: self;     hResizing: #spaceFill.  self updateLayoutareasRemainingToFill: arg1  ^Array with: arg1cellSize  ^cellSizerelabelPage: arg1 with: arg2  self tabSelectorMorph relabelTab: (self tabOfPage: arg1) with: arg2addSimpleHandlesForWorldHalos  self addHandlesForWorldHalosbuildToggleButtonWithIcon  ^PluggableToggleButtonMorph on: self getState: nil action: #toggleAction: label: #label icon: #icon menu: nilnewYesButton  ^self newYesButtonFor: selfbuildButtonNoLabel  ^PluggableButtonMorph on: self getState: nil action: #action label: nil icon: #icon menu: nilleftMargin: arg1  left := arg1setPaneRectsFromBounds  | tmp1 |  tmp1 := self layoutBounds.  paneMorphs do: [:arg1 |  | tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |        tmp2 := arg1 layoutFrame.        tmp5 := arg1 bounds.        tmp2 ifNotNil: [ tmp7 := tmp5 left - tmp1 left - (tmp2 leftOffset ifNil: [ 0 ]).              tmp3 := tmp5 right - tmp1 left - (tmp2 rightOffset ifNil: [ 0 ]).              tmp4 := tmp5 top - tmp1 top - (tmp2 topOffset ifNil: [ 0 ]).              tmp6 := tmp5 bottom - tmp1 top - (tmp2 bottomOffset ifNil: [ 0 ]).              tmp2 leftFraction: tmp7 / tmp1 width asFloat.              tmp2 rightFraction: tmp3 / tmp1 width asFloat.              tmp2 topFraction: tmp4 / tmp1 height asFloat.              tmp2 bottomFraction: tmp6 / tmp1 height asFloat ] ]setDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedhighlight  self color: self highlightColoraddCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  smoothing = 1 ifTrue: [ arg1 add: 'turn on smoothing' selector: #smoothingOn ] ifFalse: [ arg1 add: 'turn off smoothing' selector: #smoothingOff ]addMenuButton  | tmp1 tmp2 |  tmp2 := self actionOffset.  tmp1 := (self height - 16) * self displayScaleFactor // 2.  self addMorph: menuButton fullFrame: (LayoutFrame identity           bottomFraction: 0;           leftFraction: 1;           rightOffset: tmp2 negated;           leftOffset: tmp2 negated - self menuButtonWidth;           topOffset: tmp1;           bottomOffset: tmp1 + self menuButtonHeight)newColumn: arg1  ^self theme newColumnIn: self for: arg1getFirstCharacter  | tmp1 |  ^(tmp1 := text string) isEmpty ifTrue: [ '·' ] ifFalse: [ tmp1 first asString ]newLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newLabelIn: self for: arg1 label: arg2 getEnabled: arg3updateButton: arg1  self enabled ifFalse: [ ^self ].  arg1 isMouseDown ifTrue: [ self buttonMorph state == #on ifTrue: [ ^self buttonMorph state: #repressed ].        self buttonMorph state == #off ifTrue: [ ^self buttonMorph state: #pressed ] ].  arg1 isMouseUp ifTrue: [ self buttonMorph state == #repressed ifTrue: [ ^self buttonMorph                 state: #off;                 doButtonAction ].        self buttonMorph state == #pressed ifTrue: [ ^self buttonMorph                 state: #on;                 doButtonAction ] ].  arg1 isMove ifTrue: [ (self containsPoint: arg1 cursorPoint) ifTrue: [ self buttonMorph state == #on ifTrue: [ ^self buttonMorph state: #repressed ].              self buttonMorph state == #off ifTrue: [ ^self buttonMorph state: #pressed ] ] ifFalse: [ self buttonMorph state == #repressed ifTrue: [ ^self buttonMorph state: #on ].              self buttonMorph state == #pressed ifTrue: [ ^self buttonMorph state: #off ] ] ]buildMetaMenu: arg1  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  self addStandardHaloMenuItemsTo: tmp1 hand: arg1 hand.  ^tmp1testScrolling  | tmp1 tmp2 tmp3 |  window := SystemWindow labelled: 'foo'.  window extent: 300 @ 200.  tmp1 := Morph new.  tmp1 extent: 10000000000 @ 1000000000.  tmp2 := ScrollPane new.  tmp2 scroller addMorph: tmp1.  window addMorph: tmp2 fullFrame: LayoutFrame identity.  tmp3 := 0 @ 0.  window openInWorld.  window announcer when: WindowScrolling do: [:arg1 |  tmp3 := tmp3 + arg1 step ].  tmp2 hScrollBarValue: 10.  tmp2 vScrollBarValue: 5.  window delete.  self assert: tmp3 equals: 10 @ 5.  window := nilselectableIndexAfter: arg1  self shouldNotImplementoffset  ^transform offset + self innerBounds topLeftmaxCellSize  ^SmallInteger maxValinitialize  super initialize.  self     disabledStyle: #plain;     enabled: trueactualScreenSize  ^self worldState worldRenderer actualScreenSizepageSize: arg1  self setPageSize: arg1.  self announce: (MorphTreeChangeRequest pageSize: arg1)indentGap  ^indentGap ifNil: [ indentGap := 20 ]expand: arg1 to: arg2  | tmp1 |  arg1 toggleExpandedState.  tmp1 := OrderedCollection new: 10.  arg1 recursiveAddTo: tmp1.  tmp1 do: [:arg3 |  ((arg3 canExpand and: [ arg3 isExpanded not ]) and: [ arg2 > 0 ]) ifTrue: [ self expand: arg3 to: arg2 - 1 ] ]privateOwner: arg1  super privateOwner: arg1.  container ifNotNil: [ arg1 ifNotNil: [ arg1 isWorldOrHandMorph ifTrue: [ self setContainer: nil ] ] ]secondarySelection  ^secondarySelectiontransform: arg1  transform := arg1is: arg1 aboveRow: arg2  ^self subclassResponsibilityinvalidRectsFullBounds: arg1  ^totalRepaint ifTrue: [ Array with: arg1 ] ifFalse: [ invalidRects copy ]bindingOf: arg1  ^self editor bindingOf: arg1newStaticItemFrom: arg1  ^FTStaticBasicItem new     data: arg1 data;     depth: arg1 depth;     children: #();     yourselfadoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  originalColor := arg1.  self borderStyle baseColor: arg1.  self updateColoronLastPage  ^self currentPageLastIndex = self nodeList sizesaturation  ^(self selectedColor saturation * 255) asIntegerassuredCanvas  (self canvas isNil or: [ self canvas extent ~= self viewBox extent or: [ self canvas form depth ~= Display depth ] ]) ifTrue: [ self canvas: (Display defaultCanvasClass extent: self viewBox extent) ].  ^self canvasresizeCursor  ^Cursor resizeForEdge: self edgeNamenewCloseButton  ^self newCloseButtonFor: selfhandleKeystroke: arg1  ^self dispatchDefault: arg1 with: morphstep  owner ifNotNil: [ ^self runLocalStepMethods ].  ^super stepregisterRequestHandlers  self model announcer when: MorphTreeChangeRequest send: #changeRequest: to: selftestWindowLabelling  | tmp1 tmp2 |  tmp1 := #().  self currentWorld announcer when: WindowLabelled do: [:arg1 |  tmp2 := arg1 window.        tmp1 := tmp1 copyWith: arg1 label ].  window := SystemWindow labelled: 'foo'.  window openInWorld.  self assert: tmp2 equals: window.  self assert: tmp1 equals: #('foo').  window setLabel: 'bar'.  self assert: tmp2 equals: window.  self assert: tmp1 equals: #('foo' 'bar')id: arg1  id := arg1pageMorphs: arg1  pageMorphs := arg1frameRectangle3: arg1 on: arg2  | tmp1 |  tmp1 := arg1 insetBy: self width // 2.  self width odd ifTrue: [ tmp1 := tmp1 insetBy: (0 @ 0 corner: 1 @ 1) ].  arg2     line: tmp1 topLeft + (3 @ 0) to: tmp1 topRight - (3 @ 0) width: self width color: self color;     line: tmp1 topRight + (-2 @ 1) to: tmp1 topRight + (-1 @ 1) width: self width color: self color;     line: tmp1 topRight + (-1 @ 1) to: tmp1 topRight + (-1 @ 2) width: self width color: self color;     line: tmp1 topRight + (0 @ 3) to: tmp1 bottomRight - (0 @ 3) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 2) to: tmp1 bottomRight - (1 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 1) to: tmp1 bottomRight - (2 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (3 @ 0) to: tmp1 bottomLeft + (3 @ 0) width: self width color: self color;     line: tmp1 bottomLeft - (-2 @ 1) to: tmp1 bottomLeft - (-1 @ 1) width: self width color: self color;     line: tmp1 bottomLeft - (-1 @ 1) to: tmp1 bottomLeft - (-1 @ 2) width: self width color: self color;     line: tmp1 bottomLeft - (0 @ 3) to: tmp1 topLeft + (0 @ 3) width: self width color: self color;     line: tmp1 topLeft + (1 @ 2) to: tmp1 topLeft + (1 @ 1) width: self width color: self color;     line: tmp1 topLeft + (1 @ 1) to: tmp1 topLeft + (2 @ 1) width: self width color: self colorremoveAlarm: arg1  | tmp1 |  tmp1 := self alarmScheduler.  tmp1 ifNotNil: [ tmp1 removeAlarm: arg1 for: self ]argumentsProvider: arg1 argumentsSelector: arg2  argumentsProvider := arg1.  argumentsSelector := arg2addBorderStyleMenuItems: arg1 hand: arg2  invalidRect: arg1 from: arg2  worldState recordDamagedRect: (arg1 intersect: self bounds ifNone: [ ^self ])acceptContents  self updateFromParagraphaddLabel  self addMorph: label fullFrame: (LayoutFrame identity           topFraction: 1;           leftOffset: self labelRightOffset;           topOffset: label height negated - self labelBottomOffset + 2;           yourself)forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]computeBounds  self hasSubmorphs ifTrue: [ bounds := (transform localBoundsToGlobal: (Rectangle merging: (self submorphs collect: [:arg1 |  arg1 fullBounds ]))) truncated expandBy: 1 ].  fullBounds := boundstopRendererOrSelf  | tmp1 tmp2 |  owner ifNil: [ ^self ].  self isWorldMorph ifTrue: [ ^self ].  tmp1 := self.  tmp2 := tmp1 owner.  [ tmp2 notNil and: [ tmp2 isRenderer ] ] whileTrue: [ tmp1 := tmp2.        tmp2 := tmp1 owner ].  ^tmp1addAction: arg1  actions add: arg1timeStamp  ^timeStamp ifNil: [ timeStamp := Time millisecondClockValue ]chooseColor: arg1 title: arg2  ^self theme chooseColorIn: self title: arg2 color: arg1updateBounds  self     width: self owner width;     snapToEdgeIfAppropriatecolor  ^nilcomputeRaisedColors  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self color asColor.  tmp2 := Color white.  tmp3 := Color black.  tmp4 := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  tmp4 := tmp4 asInteger.  tmp5 := Array new: tmp4 * 2.  tmp7 := 0.5 / tmp4.  0 to: tmp4 - 1 do: [:arg1 |  tmp6 := true ifTrue: [ 0.5 + (tmp7 * arg1) ] ifFalse: [ 0.5 + (tmp7 * (tmp4 - arg1)) ].        tmp5 at: arg1 + 1 put: (tmp1 mixed: tmp6 with: tmp2).        tmp5 at: tmp5 size - arg1 put: (tmp1 mixed: tmp6 with: tmp3) ].  ^tmp5target: arg1  target := arg1.  arg1 ifNotNil: [ self fillStyle: (arg1 theme resizerGripNormalFillStyleFor: self) ]setType: arg1 position: arg2 buttons: arg3 hand: arg4  type := arg1.  position := arg2.  buttons := arg3.  source := arg4.  wasHandled := falselocked  ^lockedmouseOverForKeyboardFocus  ^self class mouseOverForKeyboardFocusselectedMorph  ^self scroller submorphs at: self selectionIndexescapePressed  ^self editView yellowButtonActivity: falsetable  ^self owner ifNotNil: #tablelistDirection  ^listDirectiontextEntry: arg1 title: arg2 entryText: arg3  ^self theme textEntryIn: self text: arg1 title: arg2 entryText: arg3clickVertex: arg1 event: arg2 fromHandle: arg3  vLeftoverScrollRange  ^self scrollTarget height - self scrollBounds height max: 0lineColorBlock  ^lineColorBlockhighlightIndexes: arg1  arg1 = self highlightedIndexes ifTrue: [ ^self ].  self basicHighlightIndexes: arg1.  (self hasHighlighted and: [ (self isIndexVisible: self highlightedIndex) not ]) ifTrue: [ self moveShowIndexTo: self highlightedIndexes first.        ^self ].  (self hasSelection and: [ (self isIndexVisible: self selectedIndex) not ]) ifTrue: [ self moveShowIndexTo: self selectedIndex.        ^self ].  self refreshlayoutInset: arg1  self assureTableProperties layoutInset: arg1.  self layoutChangednodeMorphOfNode: arg1  ^self allNodeMorphs detect: [:arg2 |  arg2 complexContents = arg1 ] ifNone: [  ]topLeftColor  ^width = 1 ifTrue: [ self color twiceDarker ] ifFalse: [ self color darker ]forwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1cornerStyle: arg1  super cornerStyle: arg1.  self tabs do: [:arg2 |  arg2 cornerStyle: arg1 ]setDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedscrollDelta: arg1 pageDelta: arg2  scrollDelta := arg1.  pageDelta := arg2updatablePanes  ^updatablePanes ifNil: [ updatablePanes := #() ]actAsExecutor  self breakDependentslocalSubmorphBounds  localBounds ifNil: [ self hasSubmorphs ifFalse: [ ^nil ].        localBounds := self firstSubmorph fullBounds topLeft corner: owner maxNodeWidth @ (self lastSubmorph fullBounds bottom + owner extraScrollRange) ].  ^localBoundshandlesMouseDown: arg1  ^self innerBounds containsPoint: arg1 cursorPointalarmScheduler  ^self worldasBrick  ^GLMMorphBrick on: selfsizes  ^#(#small #medium #large)getStateSelector: arg1  getStateSelector := arg1headerButtonLabel: arg1 font: arg2 target: arg3 actionSelector: arg4 arguments: arg5  self headerButton.  self header label: arg1 font: arg2.  self header actionSelector: arg4.  self header target: arg3.  self header arguments: arg5stopStepping  | tmp1 |  tmp1 := self world.  tmp1 ifNotNil: [ tmp1 stopStepping: self ]centeredAlert: arg1 title: arg2 configure: arg3  ^self theme centeredAlertIn: self text: arg1 title: arg2 configure: arg3arrowKey: arg1  | tmp1 |  tmp1 := arg1 asciiValue.  tmp1 = 31 ifTrue: [ self setSelectionIndex: self getSelectionIndex + 1.        ^true ].  tmp1 = 30 ifTrue: [ self setSelectionIndex: (self getSelectionIndex - 1 max: 1).        ^true ].  tmp1 = 1 ifTrue: [ self setSelectionIndex: 1.        ^true ].  tmp1 = 4 ifTrue: [ self setSelectionIndex: scroller submorphs size.        ^true ].  tmp1 = 11 ifTrue: [ self setSelectionIndex: (self getSelectionIndex - self numSelectionsInView max: 1).        ^true ].  tmp1 = 12 ifTrue: [ self setSelectionIndex: self getSelectionIndex + self numSelectionsInView.        ^true ].  tmp1 = 29 ifTrue: [ selectedMorph ifNotNil: [ selectedMorph canExpand ifTrue: [ selectedMorph isExpanded not ifTrue: [ self toggleExpandedState: selectedMorph ] ifFalse: [ self setSelectionIndex: self getSelectionIndex + 1 ] ] ].        ^true ].  tmp1 = 28 ifTrue: [ selectedMorph ifNotNil: [ selectedMorph isExpanded ifTrue: [ self toggleExpandedState: selectedMorph ] ifFalse: [ | tmp2 |                    selectedMorph indentLevel > 0 ifTrue: [ tmp2 := self getSelectionIndex max: 1.                          [ tmp2 > 1 and: [ (scroller submorphs at: tmp2) indentLevel >= selectedMorph indentLevel ] ] whileTrue: [ tmp2 := tmp2 - 1 max: 1 ].                          self setSelectionIndex: tmp2 ] ] ].        ^true ].  ^falseautoMultiSelect: arg1  autoTargetMorph := arg1.  self autoAction ifNotNil: [:arg2 |  self from: firstClickedMorph to: arg1 do: [:arg3 |  self perform: arg2 with: arg3 ].        self selectionUpdateFromViewWhile: [ | tmp1 |              tmp1 := self newSelectionHolderWithNodePath: nil.              self listModel selection: tmp1 ].        self selectionChanged.        self scrollToShow: arg1 contentBounds ]newButtonLabel: arg1  ^self newButtonLabelFor: nil label: arg1 getEnabled: nilblackGradientMorph  ^Morph new     hResizing: #spaceFill;     vResizing: #spaceFill;     fillStyle: self blackGradientstring  ^text stringnewGroupbox: arg1 for: arg2  ^self theme newGroupboxIn: self label: arg1 for: arg2doActivate  InputEventFetcher default startUp.  InputEventSensor installMouseDecodeTable.  InputEventSensor default startUp.  Display setExtent: self actualScreenSize depth: 32.  Display beDisplay.  canvas := nil.  display := nil.  self assuredCanvas.  DisplayScreen refreshHostWindowTitle.  Display forceDisplayUpdate.  world displayWorldgtInspectorSubmorphsIn: arg1  < gtInspectorPresentationOrder: 80>  arg1 tree     title: 'Submorphs';     rootsExpanded;     display: [:arg2 |  {arg2} ];     icon: [:arg2 |  | tmp1 |        tmp1 := arg2 imageForm.        (tmp1 extent x > 0 and: [ tmp1 extent y > 0 ]) ifTrue: [ (tmp1 scaledToSize: 16 @ 16) asMorph ] ifFalse: [ Form extent: 16 @ 16 ] ];     children: [:arg2 |  arg2 submorphs ];     when: [:arg2 |  arg2 submorphs notNil and: [ arg2 hasSubmorphs ] ]questionWithoutCancel: arg1  ^self questionWithoutCancel: arg1 title: 'Question' translatedsearchedElement: arg1  searchedElement := arg1borderStyleToUse  ^self enabled ifTrue: [ self theme sliderNormalBorderStyleFor: self ] ifFalse: [ self theme sliderDisabledBorderStyleFor: self ]beFloating  self adhereTo: #nonelayoutPolicy  ^layoutPolicymax: arg1  (self sliderMorph ifNil: [ ^self ]) max: arg1last  ^lastreinitializeTable  table dataSource: initialDataSource.  ^trueuseSquareCorners  self cornerStyle: #squarepotentialDropMorph: arg1  potentialDropMorph := arg1.  arg1 highlightForDropsortDataSource: arg1  self state sort: arg1inspectItem  self inspectselectAll  self listManager selectAllisAdheringToBottom  ^truemouseEnterDragging: arg1  self hideLocation.  arg1 hand showTemporaryCursor: (Cursor crossHair copy offset: -9 @ -9)updatePreview  self preview removeAllMorphs.  self preview addMorphCentered: (self activeTask ifNil: [ 'No tasks...' asMorph ] ifNotNil: [:arg1 |  arg1 morph taskThumbnailOfSize: self preview extent ])keystrokeActionSelector: arg1  self listManager keystrokeActionSelector: arg1hScrollbarShowNever  self hScrollbar showNever.  self updateScrollbarsnewStaticItemFrom: arg1  ^FTStaticBasicItem new     data: arg1 data;     depth: arg1 depth;     children: #();     yourselfpassivate  super passivate.  self active: falsehasClipLayoutCellsString  ^self clipLayoutCells -> 'clip to cell size' translatedbuttonMouseDown: arg1  self wantsKeyboardFocusOnMouseDown ifTrue: [ self takeKeyboardFocus ]isMenuLineMorph  ^falsecolorText: arg1  table dataSource numberOfRows ~= 0 ifTrue: [ arg1 makeAllColor: self table theme textColor ] ifFalse: [ arg1 addAttribute: (TextColor new color: Color red) ].  ^arg1popUpOwner: arg1  popUpOwner := arg1chooseForSaveFileReference: arg1 extensions: arg2 path: arg3 preview: arg4  ^self theme chooseForSaveFileReferenceIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4initialize  locked := false.  visible := true.  sticky := falsesendEvent: arg1 focus: arg2  ^self sendEvent: arg1 focus: arg2 clear: [ nil ]openInWorld: arg1  (arg1 visibleClearArea origin ~= (0 @ 0) and: [ self position = (0 @ 0) ]) ifTrue: [ self position: arg1 visibleClearArea origin ].  arg1 addMorph: self.  arg1 startSteppingSubmorphsOf: self.  self announceOpeneddoOneCycleFor: arg1  self interCyclePause: MinCycleLapse.  self doOneCycleNowFor: arg1localHaloBoundsFor: arg1  | tmp1 |  tmp1 := (self worldBoundsForMorph: arg1) truncated.  arg1 world = self world ifFalse: [ ^tmp1 ].  ^(self transformFromOutermostWorld globalBoundsToLocal: tmp1) truncatednewText: arg1  ^self theme newTextIn: self text: arg1transformFrom: arg1  (self == arg1 or: [ owner isNil ]) ifTrue: [ ^IdentityTransform new ].  ^owner transformFrom: arg1replaceSubmorph: arg1 by: arg2  | tmp1 tmp2 |  tmp1 := transform.  tmp2 := bounds.  super replaceSubmorph: arg1 by: arg2.  transform := tmp1.  bounds := tmp2.  self layoutChangedalignment  ^alignmentmodalLockTo: arg1  arg1 setProperty: #modalOwner toValue: self.  self setProperty: #modalChild toValue: arg1.  closeBox ifNotNil: [ self setProperty: #preModalCloseEnabled toValue: closeBox enabled.        closeBox enabled: false ]pages  ^self pageMorphsaddWindow  ^world addWindowToWorldnormalFillStyle  ^self theme splitterNormalFillStyleFor: selfalpha  ^(self selectedColor alpha * 255) asIntegerbuildDebugMenu: arg1  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  (self hasProperty: #errorOnDraw) ifTrue: [ tmp1 add: 'start drawing again' selector: #resumeAfterDrawError ].  (self hasProperty: #drawError) ifTrue: [ tmp1 add: 'debug drawing error' selector: #debugDrawError.        tmp1 addLine ].  (self hasProperty: #errorOnStep) ifTrue: [ tmp1 add: 'start stepping again' selector: #resumeAfterStepError.        tmp1 addLine ].  tmp1 add: 'inspect morph' selector: #inspectInMorphic:.  tmp1 lastItem icon: (self iconNamed: #smallInspectItIcon).  tmp1 add: 'inspect owner chain' selector: #inspectOwnerChain.  tmp1 lastItem icon: (self iconNamed: #smallInspectItIcon).  tmp1 addLine.  tmp1 add: 'browse morph class' target: self selector: #browseHierarchy.  ^tmp1select: arg1  self isSelected: true.  owner activeSubmenu: subMenu.  subMenu ifNotNil: [ subMenu delete.        subMenu popUpAdjacentTo: self adjacentTo forHand: arg1 hand from: self.        subMenu selectItem: nil event: arg1 ]addName  self addNameBeneath: self basicBox string: target externalNameexpandedForm  ^self theme treeExpandedFormbackgroundColor  ^Smalltalk ui theme disabledColornewFuzzyLabelFor: arg1 label: arg2 offset: arg3 alpha: arg4 getEnabled: arg5  ^self theme newFuzzyLabelIn: self for: arg1 label: arg2 offset: arg3 alpha: arg4 getEnabled: arg5basicColor: arg1  super color: arg1 beOpaque.  self fillStyle: self gradientisMovedOrResized  ^self isMoved or: [ self isResized ]label  ^labelsearchText: arg1  ^#()childrenItems  ^self item organization categoriespassiveDisabledNotOverDownFillStyle: arg1  self stateMap atPath: #(passive disabled notOver down) put: arg1.  self changedmouseUp: arg1  | tmp1 tmp2 |  tmp1 := self itemFromPoint: arg1 position.  tmp2 := tmp1 notNil ifTrue: [ tmp1 highlightedForMouseDown ] ifFalse: [ false ].  scroller submorphsDo: [:arg2 |  arg2 highlightedForMouseDown ifTrue: [ arg2 highlightForMouseDown: false ] ].  tmp1 ifNil: [ ^self ].  tmp2 ifFalse: [ ^self ].  model okToChange ifFalse: [ ^self ].  (autoDeselect == true and: [ tmp1 == selectedMorph ]) ifTrue: [ self setSelectedMorph: nil ] ifFalse: [ self setSelectedMorph: tmp1 ].  Cursor normal showhasRightOrBottom: arg1  ^rightOrBottom includes: arg1selectablesToHighlightFromRow: arg1 at: arg2 withHighlightedIndexes: arg3 andPrimaryIndex: arg4  ^self subclassResponsibilitygetContentsSelector: arg1  self validateSelector: arg1.  getContentsSelector := arg1resistsRemovalString  ^self resistsRemoval -> 'resist being deleted' translatedmouseUp: arg1  self handleInteraction: [ editor mouseUp: arg1 ].  (self boundsInWorld containsPoint: self currentHand position) ifFalse: [ self hideOverEditableTextCursor ]notifyMorphsOfEvent: arg1 ofType: arg2 from: arg3  | tmp1 |  tmp1 := false.  ((subscriptions includesKey: arg2) not or: [ (subscriptions at: arg2) isEmpty ]) ifTrue: [ ^false ].  (subscriptions at: arg2) do: [:arg4 |  tmp1 := tmp1 | ((arg4 notify: arg1 from: arg3) == true) ].  ^tmp1newSelectionHolderWithNodePath: arg1  ^self isMultiple ifTrue: [ MorphTreeMorphMultipleSelection new selectedNodePathList: (self selectedMorphList collect: [:arg2 |  arg2 path collect: [:arg3 |  arg3 complexContents ] ]) ] ifFalse: [ MorphTreeMorphSingleSelection new selectedNodePath: arg1 ]privateBePassive  self isInWorld ifFalse: [ ^self ].  self     rememberKeyboardFocus: ActiveHand keyboardFocus;     passivate;     announceDeActivatedunhighlightSelection  selectedMorph ifNotNil: [ selectedMorph unhighlight ]on: arg1 getValue: arg2 setValue: arg3  self     model: arg1;     getValueSelector: arg2;     setValueSelector: arg3;     updateValueinitialize  super initialize.  self cornerRadius: 0okayToBrownDragEasily  ^truenewDataSourceMatching: arg1  | tmp1 |  tmp1 := Array withAll: (elements select: [:arg2 |  arg1 matches: (self toString: arg2) ]).  ^self class new elements: tmp1thumbColor  ^self class imageColorFor: selfspotterActDefault  self doButtonActionmouseUp: arg1  | tmp1 |  touchPoints keysAndValuesDo: [:arg2 :arg3 |  (arg2 containsPoint: arg1 cursorPoint) ifTrue: [ self perform: arg3 ] ].  tmp1 := arg1 cursorPoint translateBy: bounds origin negated.  days do: [:arg4 |  arg4 highlighted: false.        (arg4 bounds containsPoint: tmp1) ifTrue: [ self date: arg4 date.              self announceDate ] ].  self changedmouseOverThumbFillStyle  ^self theme scrollbarMouseOverThumbFillStyleFor: selfnumberOfItemsInView  ^(submorphs select: [:arg1 |  self innerBounds intersects: (transform localBoundsToGlobal: arg1 bounds) ]) sizelayoutPolicy  ^extension ifNotNil: [ extension layoutPolicy ]mouseUp: arg1  ^self eventHandler ifNotNil: [ self eventHandler mouseUp: arg1 fromMorph: self ]useRoundedCorners  super useRoundedCorners.  self == self currentWorld ifTrue: [ Display bits primFill: 0 ]display: arg1 atRow: arg2 on: arg3  | tmp1 tmp2 tmp3 |  tmp3 := self drawBoundsForRow: arg2.  tmp1 := self colorForRow: arg2.  tmp2 := self backgroundColorForRow: arg2.  arg1 listRenderOn: arg3 atRow: arg2 bounds: tmp3 color: tmp1 backgroundColor: tmp2 from: self.  arg2 = self mouseDownRow ifTrue: [ arg3 frameRectangle: (self selectionFrameForRow: arg2) width: 1 colors: {tmp1 .               Color transparent} dashes: #(1 1) ]newEndSpacer  ^Morph new     borderWidth: 0;     color: Color transparent;     extent: 6 @ 0expandAll  self requestView: MorphTreeChangeRequest expandAllbuttons  ^buttonsisDropEvent  ^truecollapse  CollapsedMorph new beReplacementFor: selfvalue: arg1  | tmp1 |  value := arg1.  tmp1 := self completedWidth.  tmp1 ~= cachedWidth ifTrue: [ cachedWidth := tmp1.        self changed ]showLeftOrTop  self show.  leftOrTop do: [:arg1 |  arg1 show ]nodeList: arg1  nodeList := arg1patternFromString: arg1  ^[ arg1 asRegexIgnoringCase ] on: RegexSyntaxError do: [:arg2 |   ]close  ^self deletehandlesMouseDown: arg1  ^truenewSliderFor: arg1 getValue: arg2 setValue: arg3 help: arg4  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: 0 max: 1 quantum: nil getEnabled: nil help: arg4mouseDown: arg1  self eventHandler ifNotNil: [ self eventHandler mouseDown: arg1 fromMorph: self ]minWidth  | tmp1 |  tmp1 := self hasIcon ifTrue: [ self icon width + 2 ] ifFalse: [ 0 ].  ^13 * indentLevel + 15 + (contents widthToDisplayInTree: self) + tmp1 max: super minWidthleftOrTopVertices: arg1  ^self orientation == #vertical ifTrue: [ {(arg1 topLeft - (0 @ 1)) .         ((arg1 left + (arg1 height // 2 + (arg1 height \\ 2))) @ (arg1 center y - ((arg1 height + 1) \\ 2))) .         ((arg1 left + (arg1 height // 2 + (arg1 height \\ 2))) @ arg1 center y) .         arg1 bottomLeft} ] ifFalse: [ {arg1 topLeft .         ((arg1 center x - ((arg1 width + 1) \\ 2)) @ (arg1 top + (arg1 width // 2 + (arg1 width \\ 2)))) .         (arg1 center x @ (arg1 top + (arg1 width // 2 + (arg1 width \\ 2)))) .         arg1 topRight} ]newMouseFocus: arg1 event: arg2  arg1 ifNotNil: [ targetOffset := arg2 cursorPoint - arg1 position ].  ^self newMouseFocus: arg1morphicLayerNumber  ^11enableDrag: arg1  self setProperty: #dragEnabled toValue: arg1removeStayUpItems  self menuItems select: [:arg1 |  arg1 isStayUpItem ] thenDo: [:arg2 |  arg2 delete ]setSelectedItems: arg1  selectedItems := arg1.  self changedisMenubar  ^falsereset  canBeMaximized  ^self isResizeable ifTrue: [ super canBeMaximized ] ifFalse: [ false ]changeNoLayout  self layoutPolicy ifNil: [ ^self ].  self layoutPolicy: nil.  self layoutChangedscrollDeltaWidth  ^self scrollDeltaHeight // 2containsPoint: arg1  | tmp1 |  ^(super containsPoint: arg1) and: [ tmp1 := SystemWindow borderWidth.        ((self bounds translateBy: tmp1 @ tmp1) containsPoint: arg1) not ]dragTab: arg1 event: arg2 in: arg3  self removeWindow: arg1.  arg1 position: arg2 targetPoint.  arg2 hand grabMorph: arg1mouseOverBorderStyle: arg1  mouseOverBorderStyle := arg1submorphThat: arg1 ifNone: arg2  ^submorphs detect: [:arg3 |  (arg1 value: arg3) == true ] ifNone: arg2justified  textStyle justifiedinstallForUIProcessReinstall  | tmp1 |  owner := nil.  tmp1 := World submorphs.  Sensor     flushNonKbdEvents;     flushKeyboard;     flushEvents;     shutDown.  self class shutDown.  self addHand: HandMorph new.  self borderWidth: 0.  self viewBox: Display boundingBox.  self borderWidth: 0.  self color: self class defaultWorldColor.  self addAllMorphs: tmp1.  SystemWindow noteTopWindowIn: self.  World := self.  ActiveWorld := self.  ActiveHand := self hands first.  ActiveEvent := nil.  worldState handsDo: [:arg1 |  arg1 releaseCachedState ].  Sensor startUp.  self class startUp.  self displayWorldSafelyreleaseHalo: arg1  self removeProperty: #halotopVisibleRowForCanvas: arg1 startingAt: arg2  ^self rowAtLocation: arg1 clipRect topLeft startingAt: arg2allowColumnDrop  columnDropUnabled := truechangeModelSelection: arg1  setIndexSelector ifNotNil: [ model perform: setIndexSelector with: arg1 ].  self isMultipleSelection ifTrue: [ self listSelectionAt: self lastNonZeroIndex put: false.        self listSelectionAt: arg1 put: true ]isStepping: arg1 selector: arg2  lastStepMessage ifNotNil: [ (lastStepMessage receiver == arg1 and: [ lastStepMessage selector == arg2 ]) ifTrue: [ ^true ] ].  stepList do: [:arg3 |  (arg3 receiver == arg1 and: [ arg3 selector == arg2 ]) ifTrue: [ ^true ] ].  ^falsefirstIndex: arg1 lastIndex: arg2  firstIndex := arg1.  lastIndex := arg2wantsBalloon  ^self balloonText notNil and: [ self balloonHelpEnabled ]removeEdgeGrips  | tmp1 |  tmp1 := self submorphsSatisfying: [:arg1 |  arg1 isKindOf: WindowEdgeGripMorph ].  tmp1 do: [:arg1 |  arg1 delete ]addTitleForHaloMenu: arg1  arg1 buildTitle: [:arg2 |  arg2           bigTitle: self externalName;           icon: (self iconOrThumbnailOfSize: 18);           cellInset: 3 ]startDrag: arg1 with: arg2  self obtainHaloForEvent: arg1 andRemoveAllHandlesBut: arg2.  positionOffset := arg2 center - (target point: target position in: owner)expandAll  self roots do: [:arg1 |  self expandAll: arg1 ].  self adjustSubmorphPositionstextColor  ^textColorselectedColor: arg1  selectedColor := arg1.  self locationMorph visible ifTrue: [ self updateSelectedLocation ].  self triggerEvent: #colorSelected with: arg1alignTopEdges  | tmp1 |  tmp1 := (selectedItems collect: [:arg1 |  arg1 top ]) min.  selectedItems do: [:arg1 |  arg1 top: tmp1 ].  self changeddefaultColor  ^Color whiteremovedMorph: arg1  | tmp1 |  tmp1 := text find: (TextAnchor new anchoredMorph: arg1).  tmp1 ifNotNil: [ self paragraph replaceFrom: tmp1 first to: tmp1 last with: Text new displaying: false.        self fit ].  arg1 textAnchorType: nil.  arg1 relativeTextAnchorPosition: nil.  super removedMorph: arg1modalChild  ^self valueOfProperty: #modalChildvertexAt: arg1  ^vertices at: (arg1 min: vertices size)selectAll  self editor selectAllsetOptimalResizing  self hResizing: #shrinkWrap.  self vResizing: #shrinkWrapinitialize  super initialize.  self dataSource: FTEasyListDataSource newreplaceAll: arg1 with: arg2  self handleEdit: [ self editor replaceAll: arg1 with: arg2 ]isExpanded  ^self subclassResponsibilitycellColumn: arg1 row: arg2  ^FTCellMorph new     cellInset: 5;     in: [:arg3 |  (self iconFor: arg2) ifNotNil: [:arg4 |  arg3 addMorphBack: arg4 asMorph ] ];     addMorphBack: (self displayFor: arg2) asMorph;     yourselfsendRightArrowPressedToMenubarOwner: arg1  popUpOwner owner isMenubar ifTrue: [ popUpOwner owner keyStroke: arg1 ] ifFalse: [ popUpOwner owner sendRightArrowPressedToMenubarOwner: arg1 ]wrapDirection: arg1  self assureTableProperties wrapDirection: arg1.  self layoutChangedhasInlineAnchorString  ^(self textAnchorType == #inline) -> 'Inline' translatedheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]chooseColor: arg1 title: arg2  ^self theme chooseColorIn: self title: arg2 color: arg1daysForLine: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := date month daysInMonth.  tmp2 := Date firstWeekdayOfMonth: date monthIndex year: date year.  tmp3 := date month previous daysInMonth.  arg1 = 1 ifTrue: [ tmp2 = 1 ifTrue: [ ^(tmp3 - 6 to: tmp3) asArray ].        tmp4 := (tmp2 - 1 to: 1 by: -1) collect: [:arg2 |  tmp3 - arg2 + 1 ].        ^tmp4 , ((1 to: 7) asArray copyFrom: 1 to: 7 - tmp4 size) ].  tmp5 := (self daysForLine: arg1 - 1) last.  (arg1 = 2 and: [ tmp5 = tmp3 ]) ifTrue: [ ^(1 to: 7) asArray ].  tmp5 = tmp1 ifTrue: [ ^(1 to: 7) asArray ].  ^(tmp5 + 1 to: tmp5 + 7) collect: [:arg2 |  arg2 <= tmp1 ifTrue: [ arg2 ] ifFalse: [ arg2 - tmp1 ] ]rubberBandCells  ^rubberBandCellsrectangle  ^rectanglenewWindowFor: arg1 title: arg2  ^self theme newWindowIn: self for: arg1 title: arg2vResizeToFit: arg1  arg1 ifTrue: [ self vResizing: #shrinkWrap ] ifFalse: [ self vResizing: #rigid ]justDroppedInto: arg1 event: arg2  self removeHalo.  lastPointBlock ifNotNil: [ lastPointBlock value: self center ].  arg2 hand releaseKeyboardFocus: self.  self changed.  self deletequestion: arg1 title: arg2  ^self theme questionIn: self text: arg1 title: arg2rootItems  ^rootClass allSubclasses asArray sort: [:arg1 :arg2 |  arg1 name < arg2 name ]drawLinesOn: arg1 lineColor: arg2  | tmp1 |  tmp1 := self hasToggle.  self drawLineToggleToTextOn: arg1 lineColor: arg2 hasToggle: tmp1.  self nextSibling ifNotNil: [ self drawLinesToNextSiblingOn: arg1 lineColor: arg2 hasToggle: tmp1 ].  (self firstChild notNil and: [ self isExpanded ]) ifTrue: [ self drawLinesToFirstChildOn: arg1 lineColor: arg2 ]isHorizontal  ^self isAdheringToTop or: [ self isAdheringToBottom ]tabs  ^OrderedCollection new     add: self storedListTab;     add: self freshListTab;     add: self blueMorphTab;     add: self redMorphTab;     yourselfreplacePane: arg1 with: arg2  | tmp1 tmp2 |  tmp2 := model dependents includes: arg1.  arg1 owner replaceSubmorph: arg1 by: arg2.  arg2     position: arg1 position;     extent: arg1 extent.  tmp1 := arg1 layoutFrame.  paneMorphs := paneMorphs collect: [:arg3 |  arg3 == arg1 ifTrue: [ arg2 ] ifFalse: [ arg3 ] ].  tmp1 ifNotNil: [ arg2 layoutFrame: tmp1 ].  arg2 color: Color transparent.  tmp2 ifTrue: [ model removeDependent: arg1.        model addDependent: arg2 ].  self changedbasicMinExtent  | tmp1 tmp2 tmp3 |  tmp3 := 0 @ 0.  self controls do: [:arg1 |  tmp2 := arg1 minExtent.        tmp3 := (tmp3 x + tmp2 x) @ (tmp3 y max: tmp2 y) ].  self tabs ifEmpty: [ ^tmp3 ].  tmp1 := 0 @ 0.  self tabs do: [:arg2 |  tmp1 := tmp1 max: arg2 minExtent ].  ^(tmp1 x + tmp3 x) @ (tmp1 y max: tmp3 y)renderedMorph  ^selfchooseColor: arg1 title: arg2  ^self theme chooseColorIn: self modalMorph title: (arg2 ifNil: [ 'Choose Color' translated ]) color: arg1on: arg1 do: arg2  ^self bindKeyCombination: arg1 toAction: arg2hsvaMorph  ^hsvaMorphscrollAbsolute: arg1  arg1 redButtonPressed ifFalse: [ ^self ].  ^super scrollAbsolute: arg1testEmptyTaskBarList  taskbar := self.  world := self.  taskbar updateTasks.  self assert: taskbar tasks size equals: 0numberOfRows  ^availableRowslastState: arg1  lastState := arg1frameRectangle: arg1 on: arg2  (self borderRectsFor: arg1) do: [:arg3 |  arg2 fillRectangle: arg3 fillStyle: self fillStyle ]addUpdating: arg1 target: arg2 selector: arg3 argumentList: arg4  | tmp1 tmp2 |  tmp1 := (MessageSend receiver: arg2 selector: arg1) valueWithEnoughArguments: arg4.  self flag: #pharoFixMe.  (tmp1 isKindOf: Association) ifTrue: [ tmp1 := tmp1 value ] ifFalse: [ tmp2 := tmp1 readStream.        (tmp2 skipTo: $>) ifTrue: [ tmp1 := tmp2 upToEnd ] ].  self addToggle: tmp1 target: arg2 selector: arg3 getStateSelector: arg1 enablementSelector: nil argumentList: arg4fontColor  ^self theme textColorselectionFillStyle  ^self theme menubarItemSelectionFillStyleFor: selfnewString: arg1 style: arg2  ^self theme newStringIn: self label: arg1 font: self theme labelFont style: arg2asReadOnlyMorph  ^selfdrawClippedOnAthensCanvas: arg1 during: arg2  ^self clipSubmorphs ifTrue: [ arg1 clipBy: (self clippingBounds intersect: arg1 clipRect ifNone: [ ^self ]) during: arg2 ] ifFalse: [ arg2 value ]left  ^leftwidthToDisplayInList: arg1  ^self contents widthToDisplayInList: arg1adjustWidth  self width: (listSource innerBounds width max: self hUnadjustedScrollRange)addAColumn: arg1  | tmp1 |  tmp1 := self class inAColumn: arg1.  self addMorphBack: tmp1.  ^tmp1delete  super delete.  self releaseacceptOnCR  ^acceptOnCR == trueactWhen: arg1  actWhen := arg1.  actWhen == #startDrag ifFalse: [ self on: #startDrag send: nil to: nil ] ifTrue: [ self on: #startDrag send: #doButtonAction to: self ]autoDeselect: arg1  self allowsDeselection: arg1newColumn: arg1  ^self theme newColumnIn: self for: arg1hasFillStyle  ^falsechooseFont  self editor changeTextFont.  self updateFromParagraphacceptDroppingMorph: arg1 event: arg2  | tmp1 |  tmp1 := self morphToDropFrom: arg1.  self addMorphFront: tmp1.  (tmp1 fullBounds intersects: self viewBox) ifFalse: [ self inform: 'Dropped morph not in bounds'.        tmp1 position: self bounds center ].  tmp1 submorphsDo: [:arg3 |  (arg3 isKindOf: HaloMorph) ifTrue: [ arg3 delete ] ].  self bringTopmostsToFrontdefaultBounds  ^0 @ 0 corner: 100 @ self class defaultHeight * self displayScaleFactorcontentMorph  ^contentMorphupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]newSelectedIndexes  ^newSelectedIndexesextent: arg1  textEntry: arg1  ^self textEntry: arg1 title: 'Entry' translateddefaultHeight  ^22testSort  | tmp1 |  tmp1 := self dataSourceForTesting.  self assert: state context state equals: state.  state sort: tmp1.  self deny: state context state equals: stateisEnabledMatchingTheState: arg1  ^arg1enabled  ^trueprocessEvent: arg1  ^self processEvent: arg1 using: self defaultEventDispatcherinitialize  super initialize.  contents := ''.  hasFocus := false.  isEnabled := true.  isSelected := false.  font := StandardFonts menuFont.  self     hResizing: #spaceFill;     vResizing: #shrinkWraptab: arg1  tab := arg1topHeaderHeight  | tmp1 |  self topHeader ifNil: [ ^0 ] ifNotNil: [:arg1 |  tmp1 := arg1 borderWidth * 2.        self columns do: [:arg2 |  tmp1 := tmp1 max: arg2 height ].        ^tmp1 ]vResizeScrollbar  | tmp1 |  tmp1 := self innerBounds.  tmp1 := tmp1 left: tmp1 right - self scrollBarThickness.  self hScrollbarShowing ifTrue: [ tmp1 := tmp1 bottom: tmp1 bottom - self scrollBarThickness ].  self vScrollbar bounds: tmp1boundsForBalloon  container ifNil: [ ^super boundsForBalloon ].  ^self boundsInWorld intersect: container boundsInWorld ifNone: [ self boundsInWorld ]limit: arg1  limit := arg1morph: arg1  morph ifNotNil: [ self removeMorph: morph ].  morph := arg1.  morph ifNotNil: [ self addMorphBack: morph.        self adjustLayoutBounds ]editorClass  ^TextEditorbasicUpdateSelectionIndex  | tmp1 |  self getIndexSelector ifNil: [ ^self ].  tmp1 := self model perform: self getIndexSelector.  tmp1 = self selectedIndex ifTrue: [ ^self ].  tmp1 = 0 ifTrue: [ self basicSelectIndexes: #() ] ifFalse: [ self basicSelectIndexes: {tmp1} ]getListSelector: arg1  getListSelector := arg1testWhenRemovingWindowInWorldListTaskListShouldUpdateConsequently  | tmp1 tmp2 |  taskbar := self.  world := self.  tmp1 := world addWindow.  tmp2 := world addWindow.  taskbar updateTasks.  world removeWindow: tmp1.  taskbar updateTasks.  self assert: taskbar tasks size equals: 1.  self assert: taskbar tasks first morph equals: tmp2printOn: arg1  super printOn: arg1.  arg1 nextPutAll: ' [world]'mouseDown: arg1  (self bounds containsPoint: arg1 cursorPoint) ifTrue: [ self window ifNotNil: [:arg2 |  arg2 activate ] ].  ^super mouseDown: arg1rootItems: arg1  rootItems := arg1inactiveTitleFillStyle  ^self theme windowInactiveTitleFillStyleFor: selfgridOrigin  ^self gridSpec originisEditable  ^self editorProvider notNilfont  ^font ifNil: [ TextStyle defaultFont ]highlightForMouseDown: arg1  arg1 ifTrue: [ self setProperty: #highlightedForMouseDown toValue: arg1 ] ifFalse: [ self removeProperty: #highlightedForMouseDown ].  self changedisEmbedded  ^self owner isNotNil and: [ self owner ~= self world and: [ self owner ~= self activeHand ] ]allItems  | tmp1 |  tmp1 := OrderedCollection new.  self items do: [:arg1 |  tmp1 add: arg1.        arg1 hasSubMenu ifTrue: [ tmp1 addAll: arg1 subMenu allItems ] ].  ^tmp1wantsKeyboardFocusNavigation  ^self wantsKeyboardFocusdisplayWorldState: arg1 ofWorld: arg2 submorphs: arg3  | tmp1 tmp2 tmp3 |  tmp1 := (Form extent: self actualScreenSize depth: 32) getCanvas.  arg3 do: [:arg4 |  arg4 fullBounds ].  arg1 checkIfUpdateNeeded ifFalse: [ ^self ].  tmp2 := arg1 drawWorld: arg2 submorphs: arg3 invalidAreasOn: tmp1.  tmp3 := arg1 selectHandsToDrawForDamage: tmp2.  tmp3 reverseDo: [:arg5 |  tmp1 fullDrawMorph: arg5 ].  tmp1veryDeepCopyWith: arg1  ^selfdo: arg1  self changed.  ^[ arg1 value: self ] ensure: [ self close ]selectSearchedElement  self searchedElement ifNotNil: [:arg1 |  self setSelectedMorph: arg1.        self searchedElement: nil ]updateLabel  self model ifNotNil: [:arg1 |  self getLabelSelector ifNotNil: [:arg2 |  self label: (arg1 perform: arg2) ] ]newSelectedRowIndexes: arg1  self deprecated: 'Use #newSelectedIndexes: instead' transformWith: '`@receiver newSelectedRowIndexes: `@statements1' -> '`@receiver newSelectedIndexes: `@statements1'.  self newSelectedIndexes: arg1newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 getLabel: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 getLabel: arg6 help: arg7message: arg1 title: arg2  ^self theme messageIn: self text: arg1 title: arg2image: arg1 size: arg2  arg1 ifNil: [ self imageMorph image: (self defaultImageFormOfSize: arg2).        self textMorph contents: '' ] ifNotNil: [ self imageMorph image: arg1 size: arg2.        self textMorph contents: ('{1} x {2} pixels' translated format: {arg1 width asString .                     arg1 height asString}) ]firstNodeMorph  ^self allNodeMorphs ifEmpty: [ nil ] ifNotEmpty: [ scroller submorphs at: 1 ]offColor: arg1  self onColor: onColor offColor: arg1testTwoEventHandlersAreAttached  | tmp1 tmp2 tmp3 |  tmp1 := KeyboardEvent new setType: #keystroke buttons: 2 position: nil keyValue: 65 charCode: 65 hand: nil stamp: nil.  tmp2 := false.  tmp3 := false.  morph eventHandler on: #keyStroke send: #value to: [ tmp2 := true ].  morph eventHandler on: #keyStroke send: #value to: [ tmp3 := true ].  morph handleKeystroke: tmp1.  self assert: tmp2.  self assert: tmp3vScrollBarValue: arg1  | tmp1 |  scroller hasSubmorphs ifFalse: [ ^self ].  scroller offset: scroller offset x @ (self vLeftoverScrollRange * arg1) rounded.  owner ifNil: [ ^self ].  tmp1 := self window.  tmp1 ifNotNil: [ tmp1 announce: (WindowScrolling new                 step: 0 @ arg1;                 window: tmp1) ].  self announcer announce: (PaneScrolling new           step: 0 @ arg1;           scrollPane: self;           yourself)mouseLeave: arg1  self color: self selectionColoradjustLineIndicesBy: arg1  paragraph ifNotNil: [ paragraph adjustLineIndicesBy: arg1 ]getCharacters  ^self text string copyasDisabledForm: arg1  | tmp1 |  tmp1 := arg1 copy.  (arg1 colorsUsed reject: [:arg2 |  arg2 = Color transparent ]) do: [:arg2 |  tmp1 replaceColor: arg2 withColor: (arg2 alphaMixed: 0.4 with: Color white) ].  ^tmp1nullIndex  ^0newAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5getVertices  smoothCurve ifFalse: [ ^vertices ].  ^Array streamContents: [:arg1 |  self lineSegmentsDo: [:arg2 :arg3 |  arg1 nextPut: arg2 ] ]isMouseUp  ^self type == #mouseUpremoveHalo  self primaryHand removeHaloAround: selfupdateForNewPageSize: arg1  pageSize ~= arg1 ifTrue: [ | tmp1 |        tmp1 := self currentPageLastIndex.        pageSize := arg1 max: 1.        currentPageFirstIndex := tmp1 + 1 - pageSize max: 1.        self nodeList ifNotNil: [ self showCurrentPage ] ]doRot: arg1 with: arg2  | tmp1 |  arg1 hand obtainHalo: self.  tmp1 := (arg1 cursorPoint - (target pointInWorld: target referencePosition)) degrees.  tmp1 := tmp1 - angleOffset degrees.  tmp1 := tmp1 detentBy: 10.0 atMultiplesOf: 90.0 snap: false.  tmp1 = 0.0 ifTrue: [ self setColor: Color lightBlue toHandle: arg2 ] ifFalse: [ self setColor: Color blue toHandle: arg2 ].  arg2 submorphsDo: [:arg3 |  arg3 color: arg2 color contrastingBlackAndWhiteColor ].  self removeAllHandlesBut: arg2.  self showingDirectionHandles ifFalse: [ self showDirectionHandles: true addHandles: false ].  self addDirectionHandles.  target rotationDegrees: tmp1.  arg2 position: arg1 cursorPoint - (arg2 extent // 2)fastFindFirstLineSuchThat: arg1  | tmp1 tmp2 tmp3 |  tmp2 := 1.  tmp3 := lines size.  [ tmp1 := (tmp3 + tmp2) // 2.  tmp2 > tmp3 ] whileFalse: [ (arg1 value: (lines at: tmp1)) ifTrue: [ tmp3 := tmp1 - 1 ] ifFalse: [ tmp2 := tmp1 + 1 ] ].  ^tmp2wrapFlag  ^wrapFlagaddAlarm: arg1 withArguments: arg2 for: arg3 at: arg4  worldState addAlarm: arg1 withArguments: arg2 for: arg3 at: arg4morphToView  objectToView ifNil: [ ^nil ].  ^objectToView isMorph ifTrue: [ objectToView ] ifFalse: [ Morph new color: Color blue ]fullContainsPoint: arg1  (self fullBounds containsPoint: arg1) ifFalse: [ ^false ].  (self containsPoint: arg1) ifTrue: [ ^true ].  ^submorphs anySatisfy: [:arg2 |  arg2 fullContainsPoint: arg1 ]drawSubmorphsOn: arg1  | tmp1 |  submorphs isEmpty ifTrue: [ ^self ].  tmp1 := [:arg2 |  submorphs reverseDo: [:arg3 |  arg3 ~~ backgroundMorph ifTrue: [ arg2 fullDrawMorph: arg3 ] ] ].  self clipSubmorphs ifTrue: [ arg1 clipBy: (arg1 clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: tmp1 ] ifFalse: [ tmp1 value: arg1 ]toggleIndex: arg1  ((self table selectedIndexes includes: arg1) and: [ self table selectedIndexes size = 1 and: [ self table allowsDeselection ] ]) ifTrue: [ self table deselectAll ] ifFalse: [ self table selectIndex: arg1 ]mouseEnter: arg1  oldBorderStyle := self borderStyle.  self borderStyle: self mouseOverBorderStylewantsYellowButtonMenu  ^falseshowBoundsInHalo  ^self class showBoundsInHalochooseExistingFileReference: arg1 extensions: arg2 path: arg3 preview: arg4  ^self theme chooseExistingFileReferenceIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4mouseDown: arg1  (self fullContainsPoint: arg1 position) ifFalse: [ arg1 hand releaseMouseFocus: self ].  ^super mouseDown: arg1mouseOverFillStyle  ^self theme controlButtonMouseOverFillStyleFor: selfextent: arg1  | tmp1 |  tmp1 := arg1 rounded.  (bounds extent closeTo: tmp1) ifTrue: [ ^self ].  self changed.  bounds := bounds topLeft extent: tmp1.  self layoutChanged.  self changednewMenu  ^self theme newMenuIn: self for: selficon  ^iconmouseDown: arg1 fromMorph: arg2  ((self handlesClickOrDrag: arg1) and: [ arg1 redButtonPressed ]) ifTrue: [ arg1 hand waitForClicksOrDrag: arg2 event: arg1 ].  ^self notifyMorphsOfEvent: arg1 ofType: #mouseDown from: arg2newButtonFor: arg1 action: arg2 label: arg3 help: arg4  ^self newButtonFor: arg1 getState: nil action: arg2 arguments: nil getEnabled: nil label: arg3 help: arg4rowColors  ^rowColorsincludesTableProperties  ^falsepageDelta  ^pageDeltadoubleClick: arg1  ^self eventHandler ifNotNil: [ self eventHandler doubleClick: arg1 fromMorph: self ]degreesOfFlex  ^0.0on: arg1 list: arg2 selected: arg3 changeSelected: arg4 menu: arg5 keystroke: arg6 wrapSelector: arg7  self model: arg1.  getListSelector := arg2.  getIndexSelector := arg3.  setIndexSelector := arg4.  getMenuSelector := arg5.  keystrokeActionSelector := arg6.  wrapSelector := arg7.  self autoDeselect: true.  self borderWidth: 1.  self updateList.  self selectionIndex: self getCurrentSelectionIndex.  self initForKeystrokesstyle: arg1  style == arg1 ifTrue: [ ^self ].  style := arg1.  self releaseCachedStatenewString: arg1 font: arg2 style: arg3  ^self theme newStringIn: self label: arg1 font: arg2 style: arg3dispatchMouseDown: arg1 with: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp1 := arg1 cursorPoint.  (arg2 fullBounds containsPoint: tmp1) ifFalse: [ ^#rejected ].  tmp8 := arg1 handler.  tmp6 := arg2 handlerForMouseDown: arg1.  tmp6 ifNotNil: [ arg1 handler: tmp6 ].  tmp3 := 1.  tmp5 := arg2 submorphs.  [ tmp3 <= tmp5 size ] whileTrue: [ tmp4 := tmp5 at: tmp3.        tmp2 := arg1 transformedBy: (tmp4 transformedFrom: arg2).        (tmp4 processEvent: tmp2 using: self) == #rejected ifFalse: [ tmp7 := false.              tmp2 wasHandled ifTrue: [ arg1 copyHandlerState: tmp2 ].              tmp3 := tmp5 size ].        tmp3 := tmp3 + 1 ].  (tmp7 == false or: [ arg2 containsPoint: arg1 cursorPoint event: arg1 ]) ifTrue: [ tmp6 ifNotNil: [ tmp6 handleEvent: arg1 ].        arg1 handler: tmp8.        ^self ].  arg1 handler: tmp8.  ^#rejectedchangeEmphasis  | tmp1 |  tmp1 := UIManager default chooseFrom: (self emphasisChoices collect: [:arg1 |  arg1 translated ]) values: self emphasisChoices.  tmp1 ifNotNil: [ self emphasis: (TextEmphasis perform: tmp1) emphasisCode ]deselectAll  self selectIndexes: #()lastIndex  ^lastIndex ifNil: [ lastIndex := self pageSize ]denyDeselection  self allowsDeselection: falsetaskbarButtonClicked  self isMinimized ifTrue: [ self restore ] ifFalse: [ self isActive ifTrue: [ self minimize ] ifFalse: [ self activate ] ]scrollAbsolute: arg1  self enabled ifFalse: [ ^self ].  super scrollAbsolute: arg1.  self updateLabelarrowsContainPoint: arg1  | tmp1 tmp2 |  tmp1 := {false .   false}.  (super containsPoint: arg1) ifFalse: [ ^tmp1 ].  (closed or: [ arrows == #none or: [ vertices size < 2 ] ]) ifTrue: [ ^tmp1 ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ tmp2 := self arrowForms first.        tmp1 at: 2 put: (tmp2 pixelValueAt: arg1 - tmp2 offset) > 0 ].  (arrows == #back or: [ arrows == #both ]) ifTrue: [ tmp2 := self arrowForms last.        tmp1 at: 1 put: (tmp2 pixelValueAt: arg1 - tmp2 offset) > 0 ].  ^tmp1resizeButton  | tmp1 tmp2 |  self flag: #pharoTodo.  tmp2 := (table bounds right - table verticalScrollBarWidth) @ (table bottom - table horizontalScrollBarHeight).  tmp1 := (tmp2 x - actionButton width) @ (table bounds bottom - self fieldHeigh - table horizontalScrollBarHeight).  actionButton bounds: (tmp1 corner: tmp2)handlesMouseDown: arg1  ^(self existsSubscriptionsFor: #mouseDown) or: [ (self existsSubscriptionsFor: #mouseStillDown) or: [ (self existsSubscriptionsFor: #mouseUp) or: [ (self handlesClickOrDrag: arg1) or: [ self handlesGestureStart: arg1 ] ] ] ]dispatchCommandKeyInWorld: arg1 event: arg2  | tmp1 |  tmp1 := self commandKeySelectors at: arg1 ifAbsent: [ ^false ].  tmp1 selector numArgs = 0 ifTrue: [ tmp1 value ] ifFalse: [ tmp1 valueWithArguments: (Array with: arg2) ].  ^truedrawOn: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self paneColor.  tmp3 := self enabled ifTrue: [ self color ] ifFalse: [ tmp1 twiceDarker ].  tmp2 := self enabled ifTrue: [ tmp3 twiceDarker darker contrastingBlackAndWhiteColor alpha: self alpha ] ifFalse: [ Color transparent ].  arg1 depth < 8 ifTrue: [ tmp2 := Color transparent alpha: 0.001 ].  tmp2 isTransparent ifFalse: [ arg1           drawString: self contents in: (self bounds translateBy: 0 @ -1) font: self fontToUse color: tmp2;           drawString: self contents in: (self bounds translateBy: (self offset * 2) @ -1) font: self fontToUse color: tmp2;           drawString: self contents in: (self bounds translateBy: (self offset * 2) @ (self offset * 2 - 1)) font: self fontToUse color: tmp2;           drawString: self contents in: (self bounds translateBy: 0 @ (self offset * 2 - 1)) font: self fontToUse color: tmp2 ].  arg1 drawString: self contents in: (self bounds translateBy: self offset @ (self offset - 1)) font: self fontToUse color: tmp3haloBox: arg1  haloBox := arg1selectionColorToUse  ^self valueOfProperty: #selectionColorToUse ifAbsent: [ self theme selectionColor ]newTextEditorFor: arg1 getText: arg2 setText: arg3  ^self newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: nilcurrentPageInput: arg1  | tmp1 tmp2 |  tmp1 := arg1 asString trimBoth.  tmp1 ifEmpty: [ treeMorph flash.        ^false ].  tmp2 := Integer readFromString: tmp1.  ^self currentPage: tmp2lastKeystroke  ^self valueOfProperty: #lastKeystroke ifAbsent: [ '' ]updateOrderedTasksFrom: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self orderedTasks do: [:arg2 |  arg1 detect: [:arg3 |  arg3 morph = arg2 morph ] ifFound: [:arg4 |  arg1 remove: arg4 ] ifNone: [ tmp1 add: arg2 ] ].  (tmp1 isEmpty and: [ arg1 isEmpty ]) ifTrue: [ ^self ].  self orderedTasks: (self orderedTasks           removeAll: tmp1;           addAll: arg1;           yourself)target  ^targetremoveNode: arg1  self selectedNodePathList remove: arg1 path ifAbsent: [  ]displaySelectionBlock: arg1 inLine: arg2 onAthensCanvas: arg3  (selectionStart notNil and: [ selectionStop notNil and: [ selectionStart ~= selectionStop ] ]) ifTrue: [ | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |        tmp1 := arg1 first stringIndex.        tmp2 := arg1 last stringIndex.        tmp3 := selectionStart stringIndex.        tmp4 := selectionStop stringIndex.        tmp5 := tmp1 to: tmp2.        tmp6 := tmp3 to: tmp4.        ((tmp5 rangeIncludes: tmp3 + 1) or: [ (tmp5 rangeIncludes: tmp4 - 1) or: [ (tmp6 rangeIncludes: tmp1 + 1) or: [ tmp6 rangeIncludes: tmp2 - 1 ] ] ]) ifTrue: [ ^self ] ].  arg1 displayInLine: arg2 onAthensCanvas: arg3balloonColor: arg1  balloonColor := arg1.  self color: arg1edgeToAdhereTo  ^self valueOfProperty: #edgeToAdhereTo ifAbsent: [ #none ]vScrollBarHeight  ^super vScrollBarHeight - self pagerHeightnewCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 label: arg4 help: arg5  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: nil label: arg4 help: arg5toggleBounds  ^self toggleRectangledefer: arg1  worldState defer: arg1checkboxFillStyleToUse  ^self selected ifTrue: [ self enabled ifTrue: [ self theme checkboxButtonSelectedFillStyleFor: self ] ifFalse: [ self theme checkboxButtonSelectedDisabledFillStyleFor: self ] ] ifFalse: [ self enabled ifTrue: [ self theme checkboxButtonNormalFillStyleFor: self ] ifFalse: [ self theme checkboxButtonDisabledFillStyleFor: self ] ]morphsAt: arg1 behind: arg2 unlocked: arg3  | tmp1 tmp2 tmp3 |  tmp2 := (arg2 isNil or: [ owner isNil ]) ifTrue: [ (self fullBounds containsPoint: arg1) ifFalse: [ ^#() ].        (arg3 and: [ self isLocked or: [ self visible not ] ]) ifTrue: [ ^#() ].        nil ] ifFalse: [ tmp3 := self transformedFrom: owner.        tmp2 := owner morphsAt: (tmp3 localPointToGlobal: arg1) behind: self unlocked: arg3.        WriteStream with: tmp2 ].  tmp1 := arg2 isNil.  self submorphsDo: [:arg4 |  | tmp4 |        tmp1 ifTrue: [ tmp3 := arg4 transformedFrom: self.              tmp4 := arg4 morphsAt: (tmp3 globalPointToLocal: arg1) behind: nil unlocked: arg3.              tmp4 notEmpty ifTrue: [ tmp2 ifNil: [ tmp2 := Array new writeStream ].                    tmp2 nextPutAll: tmp4 ] ].        arg4 == arg2 ifTrue: [ tmp1 := true ] ].  (tmp1 and: [ self containsPoint: arg1 ]) ifTrue: [ tmp2 ifNil: [ ^Array with: self ].        tmp2 nextPut: self ].  ^tmp2 ifNil: [ #() ] ifNotNil: [ tmp2 contents ]listSelectionAt: arg1 put: arg2  self searchedElement: nil.  setSelectionListSelector ifNil: [ ^false ].  ^model perform: setSelectionListSelector with: arg1 with: arg2changeOfChangesInSlopes: arg1 of: arg2  | tmp1 tmp2 |  tmp1 := arg2 size.  tmp1 = arg1 size ifFalse: [ ^self error: 'vertices and slopes differ in number' ].  tmp2 := Array new: tmp1.  1 to: tmp1 do: [:arg3 |  tmp2 at: arg3 put: ((arg2 at: arg3) - (arg2 atWrap: arg3 + 1)) * 2 + (arg1 at: arg3) + (arg1 atWrap: arg3 + 1) ].  ^tmp2icon: arg1  icon ifNotNil: [ self removeMorph: icon ].  icon := arg1.  icon ifNotNil: [ self addMorphFront: icon ]drawNullTextOn: arg1  arg1 paragraph: self paragraph bounds: bounds color: coloranyButtonPressed  ^lastMouseEvent anyButtonPressedalignLeftEdges  | tmp1 |  tmp1 := (selectedItems collect: [:arg1 |  arg1 left ]) min.  selectedItems do: [:arg1 |  arg1 left: tmp1 ].  self changedoldSelectedRowIndexes  self deprecated: 'Use #oldSelectedIndexes instead' transformWith: '`@receiver oldSelectedRowIndexes' -> '`@receiver oldSelectedIndexes'.  ^self oldSelectedIndexesnewLabel: arg1  ^self newLabelFor: nil label: arg1 getEnabled: nilwrapDirection  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #none ] ifNotNil: [ tmp1 wrapDirection ]sticky: arg1  extension sticky: arg1active  ^activealert: arg1 title: arg2 configure: arg3  ^self theme alertIn: self text: arg1 title: arg2 configure: arg3mouseUp: arg1  self isMultipleSelection ifTrue: [ self mouseUpOnMultiple: arg1 ] ifFalse: [ self mouseUpOnSingle: arg1 ]selectionColor  ^self valueOfProperty: #selectionColor ifAbsent: [ self theme selectionColor ]executeSortingOn: arg1  self subclassResponsibilitycreateCellText: arg1 icon: arg2  | tmp1 tmp2 tmp3 |  tmp1 := arg1.  tmp2 := arg2.  tmp3 := FTCellMorph new     cellInset: 5;     yourself.  tmp2 ifNotNil: [ tmp2 := tmp2 asMorph.        tmp2 class = ImageMorph ifTrue: [ tmp2 form: (tmp2 form scaledToSize: 16 @ 16) ] ifFalse: [ tmp2 bounds: (0 @ 0 corner: 16 @ 16) ].        tmp3 addMorphBack: tmp2 ].  tmp3 addMorphBack: tmp1 asMorph.  ^tmp3mockStringMorph  ^StringMorph new     contents: 'Test';     on: #mouseEnter send: #mouseEnter:from: to: self;     yourselfnewStack: arg1  ^self theme newStackIn: self for: arg1selectionColorToUse  ^selectionColorToUse ifNil: [ self theme selectionColor ]chooseFont: arg1  ^self theme chooseFontIn: self title: 'Font Selector' translated font: arg1mouseEnter: arg1  super mouseEnter: arg1.  self wantsKeyboardFocus ifFalse: [ ^self ].  self keyboardFocusOnMouseDown ifFalse: [ self takeKeyboardFocus ]notExpandedForm  ^self theme treeUnexpandedFormfindPathIn: arg1  | tmp1 |  tmp1 := self findExactPathMatchIn: arg1.  tmp1 ifNil: [ tmp1 := self findSimilarPathMatchIn: arg1 ].  ^tmp1defaultColor  ^Color r: 0.781 g: 0.781 b: 0.781isCollapsed  ^truewantsRoundedCorners  ^self cornerStyle == #roundedcreateResizableHeaderWith: arg1 between: arg2 and: arg3  ^Morph new     color: Color transparent;     clipSubmorphs: true;     layoutPolicy: FTRowLayout new;     bounds: arg1 bounds;     addMorphBack: (FTColumnResizerMorph container: self left: arg2 right: arg3);     addMorphBack: arg1;     yourselfradioFillStyleToUse  ^self selected ifTrue: [ self enabled ifTrue: [ self theme radioButtonSelectedFillStyleFor: self ] ifFalse: [ self theme radioButtonSelectedDisabledFillStyleFor: self ] ] ifFalse: [ self enabled ifTrue: [ self theme radioButtonNormalFillStyleFor: self ] ifFalse: [ self theme radioButtonDisabledFillStyleFor: self ] ]realElementAt: arg1  ^(super realElementAt: arg1) dataresizeBackgroundMorph  self backgroundMorph ifNotNil: [ self backgroundMorph extent: self extent ]scrollBarThickness  ^self theme scrollbarThicknessbottomLeft  ^bounds bottomLeftsentTo: arg1  ^arg1 handleDropFiles: selfduplicateMorph: arg1  | tmp1 |  tmp1 := self duplicate.  arg1 hand grabMorph: tmp1 from: owner.  ^tmp1icon  ^label icontestIndexesToSelectInMultipleSelectionFromTo  self assert: (strategy indexesToSelectInMultipleSelectionFrom: #(8 1) to: #(21 3)) asArray equals: #(#(8 1) #(9 1) #(10 1) #(11 1) #(12 1) #(13 1) #(14 1) #(15 1) #(16 1) #(17 1) #(18 1) #(19 1) #(20 1) #(21 1) #(8 2) #(9 2) #(10 2) #(11 2) #(12 2) #(13 2) #(14 2) #(15 2) #(16 2) #(17 2) #(18 2) #(19 2) #(20 2) #(21 2) #(8 3) #(9 3) #(10 3) #(11 3) #(12 3) #(13 3) #(14 3) #(15 3) #(16 3) #(17 3) #(18 3) #(19 3) #(20 3) #(21 3))wantsYellowButtonMenu  ^falseopen  ^self openDialogWindowIn: self currentWorld title: 'Packages'initialize  super initialize.  self enableDragNDrop: true.  self fillStyle: (self theme morphTreeColumnFillStyleFor: self).  self borderStyle: (self theme morphTreeColumnBorderStyleFor: self)style  ^#nonecolor: arg1  self     basicColor: arg1;     selectedColor: (Color h: arg1 hue s: self selectedColor saturation v: self selectedColor brightness)location: arg1  location := arg1dataSourceForTesting  ^FTTableMorph new     dataSource: (FTSimpleDataSource elements: self elementsForTestDataSource);     dataSourcegetListElementSelector: arg1  self dataSource getListElementSelector: arg1defaultBitmapFillForm  ^ImageMorph defaultFormhandleKeyDown: arg1  arg1 wasHandled ifTrue: [ ^self ].  (self handlesKeyDown: arg1) ifFalse: [ ^self ].  arg1 wasHandled: true.  ^self keyDown: arg1doFullRepaint  ^totalRepaint := trueisExpanded: arg1  isExpanded := arg1.  self complexContents isExpanded: arg1initialize  super initialize.  smoothing := 1.  transform := MorphicTransform identityselectPrevious  toolbar selectPreviousstateMap  ^stateMapdefaultColor  ^Color r: 0.8 g: 1.0 b: 0.6isTaskbarPresent  ^self worldTaskbar notNilmenuBarItems  ^menuBarItemstestIsBellowRow  self assert: (strategy is: #(3 7) bellowRow: 2).  self deny: (strategy is: #(3 7) bellowRow: 4).  self deny: (strategy is: #(3 7) bellowRow: 3)colorsForDirection: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self colors.  arg1 x * arg1 y <= 0 ifTrue: [ tmp1 := (arg1 x > 0 or: [ arg1 y < 0 ]) ifTrue: [ tmp3 copyFrom: 1 to: width ] ifFalse: [ (tmp3 copyFrom: width + 1 to: tmp3 size) reversed ] ] ifFalse: [ tmp1 := Array new: width.        tmp2 := arg1 x asFloat / (arg1 x + arg1 y).        (arg1 x > 0 or: [ arg1 y >= 0 ]) ifTrue: [ 1 to: width do: [:arg2 |  tmp1 at: arg2 put: ((tmp3 at: arg2) mixed: tmp2 with: (tmp3 at: tmp3 size - arg2 + 1)) ] ] ifFalse: [ 1 to: width do: [:arg2 |  tmp1 at: arg2 put: ((tmp3 at: tmp3 size - arg2 + 1) mixed: tmp2 with: (tmp3 at: arg2)) ] ] ].  ^tmp1isScrolled  ^truenavigationKey: arg1  (self world navigationKey: arg1) ifTrue: [ ^true ].  (self tabKey: arg1) ifTrue: [ ^true ].  (arg1 keyCharacter = Character escape and: [ arg1 anyModifierKeyPressed ]) ifTrue: [ ^self yellowButtonActivity: false ].  ^falsenewGroupbox  ^self theme newGroupboxIn: selfembeddedWindowOrNil  | tmp1 |  self submorphs size = 1 ifTrue: [ tmp1 := self firstSubmorph.        tmp1 isSystemWindow ifTrue: [ ^tmp1 ] ].  ^nildisplayExtentChanged  layoutInset: arg1  layoutInset := arg1reset  defaultScrollTarget  ^Morph new extent: 200 @ 150visibleRowMorphAtIndex: arg1  ^self exposedRows at: arg1mouseStillDown: arg1  arg1 hand position y > self innerBounds bottom ifTrue: [ self listManager selectMoreAtBottom ] ifFalse: [ arg1 hand position y < self innerBounds top ifTrue: [ self listManager selectMoreAtTop ] ifFalse: [ super mouseStillDown: arg1 ] ]filter  | tmp1 |  tmp1 := OrderedCollection new.  dataSource rootsItems do: [:arg1 |  (self matchingFilter: arg1) ifNotNil: [:arg2 |  tmp1 add: arg2 ] ] displayingProgress: [:arg3 |  'Looking inside ' , arg3 printString ].  dataSource table selectIndex: 1.  ^dataSource class root: (FTRootItem new           children: tmp1 asArray;           yourself) children: dataSource childrenBlockselected  ^self item selectedviewBox  ^self worldRenderer viewBoxresetListSelection  self resetListSelectionSilently.  self changedupdateList  | tmp1 |  tmp1 := scrollBar value.  self updateContentsWithPreviouslyExpanded: self currentlyExpanded.  self vScrollValue: tmp1mouseUp: arg1  (self bounds containsPoint: arg1 cursorPoint) ifFalse: [ arg1 hand showTemporaryCursor: nil ].  self class fastSplitterResize ifTrue: [ self updateFromEvent: arg1 ].  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUpaddGrabHandle: arg1  self addHandle: arg1 on: #mouseDown send: #doGrab:with: to: selfaddSubscription: arg1 toEvent: arg2  (subscriptions includesKey: arg2) ifFalse: [ subscriptions at: arg2 put: Set new ].  (subscriptions at: arg2) add: arg1addMorph: arg1 after: arg2  ^self privateAddMorph: arg1 atIndex: (submorphs indexOf: arg2) + 1newHSplitter  ^ProportionalSplitterMorph new     beSplitsTopAndBottom;     setProperty: #model toValue: selfisLeft  ^self option == #lefttopLeft: arg1  self position: arg1doubleClick: arg1  | tmp1 |  doubleClickSelector ifNil: [ ^super doubleClick: arg1 ].  tmp1 := self rowAtLocation: arg1 position.  tmp1 = 0 ifTrue: [ ^super doubleClick: arg1 ].  ^self model perform: doubleClickSelectornewVScrollbar  ^GeneralScrollBar new     model: self;     setValueSelector: #vScrollbarValue:dashLengths  ^dashLengthscollapseAll  self updateContentsWithPreviouslyExpanded: Array newhandleListenEvent: arg1  ^arg1 sentTo: selfresumeUIProcess: arg1  UIProcess := arg1.  UIProcess resumedrawLinesOn: arg1  | tmp1 |  tmp1 := self hasToggle.  self drawLineToggleToTextOn: arg1 hasToggle: tmp1.  self nextSibling ifNotNil: [ self drawLinesToNextSiblingOn: arg1 hasToggle: tmp1 ].  (self firstChild notNil and: [ self isExpanded ]) ifTrue: [ self drawLinesToFirstChildOn: arg1 ]addMorphs  | tmp1 |  self preview: self newPreviewMorph.  self taskList: self newTasksMorph.  tmp1 := self theme newColumnIn: self for: {self preview .         self taskList}.  tmp1     vResizing: #shrinkWrap;     cellInset: 8;     cellPositioning: #center.  self addMorph: tmp1.  self layoutChangedisExpanded  ^isExpandedbasicHighlightRowIndexes: arg1  self deprecated: 'Use #basicHighlightIndexes: instead' transformWith: '`@receiver basicHighlightRowIndexes: `@statements' -> '`@receiver basicHighlightIndexes: `@statements'.  ^self basicHighlightIndexes: arg1newColorPresenterFor: arg1 getColor: arg2 help: arg3  ^self theme newColorPresenterIn: self for: arg1 getColor: arg2 help: arg3getIconSelector  ^getIconSelectoractivatedFromDockingBar: arg1  activatorDockingBar := arg1locationMorph: arg1  locationMorph := arg1window  ^self ownerThatIsA: SystemWindowexpandNodePath: arg1  (self allNodeMorphs at: 1 ifAbsent: [ ^self ]) openNodePath: arg1isNotRestored  ^self isMinimized or: [ self isMaximized ]sortDataSource: arg1  self subclassResponsibilitydisable  self enabled: falsebrowseItem  Smalltalk tools browser openOnClass: self iteminitialize  super initialize.  self     rubberBandCells: false;     listDirection: #topToBottom;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #center.  enabled := true.  self initializeLabelMorph.  askBeforeChanging := false.  triggerOnMouseDown := false.  showSelectionFeedback := false.  arguments := #().  self     layoutInset: (self theme buttonLabelInsetFor: self);     extent: 20 @ 15;     lastState: false;     cornerStyle: (self theme buttonCornerStyleIn: nil);     borderStyle: (self theme buttonNormalBorderStyleFor: self).  self clipSubmorphs: truetabRefreshed: arg1  self selectedTab = arg1 ifFalse: [ ^self ].  self triggerEvent: #tabRefreshed with: arg1mouseEnterIcon  closeable ifFalse: [ ^self ].  fadeOut ifNotNil: [ fadeOut terminate ].  closeIcon image: self class closeOverIconnumberOfItemsPotentiallyInViewWith: arg1  | tmp1 |  tmp1 := self localSubmorphBounds height.  tmp1 isZero ifTrue: [ ^0 ].  ^self innerBounds height // (tmp1 / arg1)right  ^righttearDown  window ifNotNil: [ window delete ].  super tearDownhandlesMouseOverDragging: arg1  ^truetaskbarCloseAllLikeThis  (SystemWindow allSubInstances select: [:arg1 |  arg1 model isKindOf: self model class ]) do: [:arg1 |  arg1 delete ]delete  self setProperty: #deleting toValue: true.  super deleteremoveHalo  self halo ifNotNil: [:arg1 |  self removeHaloAround: arg1 target ]repelsMorph: arg1 event: arg2  ^truebeResetable  resetable := trueactualClass  ^FTNullColumnSortingStrategyinnerExtent: arg1  self extent: (arg1 x + (self cornerRadius * 2)) @ arg1 yshowLocation  self locationMorph     visible: true;     changedattachKeymapCategory: arg1 onProperty: arg2  self kmDispatcher attachCategory: arg1 onProperty: arg2actualScreenSize  < primitive: 106>  self primitiveFailedmenuTitleSelector: arg1  getMenuTitleSelector := arg1noticeMouseOver: arg1 event: arg2  leftMorphs remove: arg1 ifAbsent: [ enteredMorphs nextPut: arg1 ].  overMorphs nextPut: arg1drawIconOn: arg1  | tmp1 tmp2 tmp3 |  self hasIcon ifFalse: [ ^self ].  tmp1 := self iconForm.  tmp2 := self menuStringBounds left - tmp1 width - 5.  tmp3 := self top + ((self height - tmp1 height) // 2).  arg1 translucentImage: tmp1 at: tmp2 @ tmp3mouseDownInSlider: arg1  slider borderStyle style == #raised ifTrue: [ slider borderColor: #inset ].  sliderShadow color: self sliderShadowColor.  sliderShadow cornerStyle: slider cornerStyle.  sliderShadow bounds: slider bounds.  sliderShadow showshowWidget  hasNoOffsets  ^leftOffset = 0 and: [ rightOffset = 0 and: [ topOffset = 0 and: [ bottomOffset = 0 ] ] ]activeHand  ^activeHandmouseOverThumbButtonBorderStyle  ^self theme scrollbarMouseOverThumbButtonBorderStyleFor: selfdrawSubmorphsOnAthensCanvas: arg1  | tmp1 |  tmp1 := self clippingBounds intersect: arg1 clipRect.  arg1 transformBy: self transform withClip: tmp1 in: self innerBounds during: [:arg2 |  | tmp2 tmp3 |        tmp2 := self topVisibleRowForCanvas: arg2.        tmp3 := self bottomVisibleRowForCanvas: arg2 startingAt: tmp2.        tmp3 to: tmp2 by: -1 do: [:arg3 |  | tmp4 |              tmp4 := submorphs basicAt: arg3.              self drawRawColorOn: arg1 asCanvasWrapper forSubmorph: tmp4.              arg2 fullDrawMorph: tmp4 ] ].  owner withTreeLines ifTrue: [ owner drawLinesOn: arg1 asCanvasWrapper ].  owner enabled ifFalse: [ arg1 asCanvasWrapper fillRectangle: owner innerBounds fillStyle: (owner paneColor alpha: 0.2) ]initializeSlider  self setSlider: ((BracketMorph newBounds: self totalSliderArea)           horizontal: self bounds isWide;           color: self thumbColor;           borderStyle: (BorderStyle raised                 baseColor: Color white;                 width: 1)) withShadow: ((BracketMorph newBounds: self totalSliderArea)           horizontal: self bounds isWide;           color: self pagingArea color;           borderStyle: (BorderStyle inset                 baseColor: (Color white alpha: 0.6);                 width: 1))adhereToLeft  self adhereTo: #leftstringBounds  | tmp1 tmp2 |  tmp1 := self bounds.  tmp2 := self layoutInset.  ^tmp1 topLeft + tmp2 corner: tmp1 bottomRight + tmp2isTranslucentButNotTransparent  ^color isColor and: [ color isTranslucentButNotTransparent ]initializeLabelArea  label := self theme windowLabelFor: self.  collapseBox := self createCollapseBox.  closeBox := self createCloseBox.  self wantsExpandBox ifTrue: [ expandBox := self createExpandBox.        self setExpandBoxBalloonText ].  menuBox := self createMenuBox.  stripes := Array with: (Morph newBounds: bounds) with: (Morph newBounds: bounds).  self addLabelArea.  labelArea goBehind.  self replaceBoxes.  labelArea fillStyle: self activeTitleFillStyleisKeyUp  ^self type == #keyUpdeleteIfPopUp: arg1  arg1 ifNotNil: [ arg1 hand releaseMouseFocus: self ]deselectItem  | tmp1 |  self isSelected: false.  subMenu ifNotNil: [ subMenu deleteIfPopUp ].  owner isMenuMorph ifTrue: [ tmp1 := owner popUpOwner.        tmp1 isMenuItemMorph ifTrue: [ tmp1 deselectItem ] ]handlesKeyboard: arg1  ^trueradioBorderStyleToUse  ^self selected ifTrue: [ self enabled ifTrue: [ self theme radioButtonSelectedBorderStyleFor: self ] ifFalse: [ self theme radioButtonSelectedDisabledBorderStyleFor: self ] ] ifFalse: [ self enabled ifTrue: [ self theme radioButtonNormalBorderStyleFor: self ] ifFalse: [ self theme radioButtonDisabledBorderStyleFor: self ] ]handleMouseOver: arg1  arg1 hand mouseFocus == self ifTrue: [ (self containsPoint: arg1 position event: arg1) ifFalse: [ ^self ] ].  arg1 hand noticeMouseOver: self event: arg1rootItems  ^self rootClass allSubclasses asArray sort: [:arg1 :arg2 |  arg1 name < arg2 name ]asString  ^item asStringsetActionSelector  | tmp1 |  tmp1 := UIManager default request: 'Please type the selector to be sent tothe target when this button is pressed' translated initialAnswer: actionSelector.  tmp1 isEmptyOrNil ifFalse: [ self actionSelector: tmp1 ]keyboardFocus: arg1  self newKeyboardFocus: arg1openAsIs  ^self openAsIsIn: self currentWorldmouseMove: arg1  self isForDragging ifTrue: [ self draggedTo: arg1 position ] ifFalse: [ self reframedTo: arg1 position ]acceptValue: arg1  | tmp1 |  self contents: (tmp1 := arg1 asString).  ^tmp1isHorizontal  ^self edgeName == #top or: [ self edgeName == #bottom ]move  copy := falsecompiledMethod  ^self itemClass compiledMethodAt: self selector ifAbsent: [ self itemClass class compiledMethodAt: self selector ifAbsent: [  ] ]mouseLeave: arg1  owner ifNotNil: [ owner stayUp ifFalse: [ self mouseLeaveDragging: arg1 ] ]elementCount  ^self text string sizeage: arg1  age := arg1slopes: arg1  self isCurvy ifFalse: [ ^self segmentedSlopesOf: arg1 ].  ^closed ifTrue: [ self closedCubicSlopesOf: arg1 ] ifFalse: [ self naturalCubicSlopesOf: arg1 ]applyModelExtent  self extent: model initialExtentthemeChanged  self color: self defaultColor.  super themeChangedlayoutChanged  localBounds := nil.  ^super layoutChangedselectFirstVisibleRow  ^self selectIndex: (container exposedRows ifNotEmpty: [:arg1 |  arg1 keys first ] ifEmpty: [ 0 ])value: arg1  | tmp1 |  numArgs ifNil: [ numArgs := selector numArgs ].  tmp1 := arguments ifNil: [ 0 ] ifNotNil: [ arguments size ].  tmp1 = numArgs ifTrue: [ ^self value ].  ^arguments ifNil: [ receiver perform: selector with: arg1 ] ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: arg1) ]newMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil help: arg5morph: arg1  morph := arg1labelMorph: arg1  labelMorph ifNotNil: [ labelMorph delete ].  labelMorph := arg1.  labelMorph color: (self theme checkboxButtonLabelNormalFillStyleFor: self label: labelMorph).  self addMorphBack: arg1.  self enabled: self enabledmodel: arg1  model := arg1addHand: arg1  hands := (hands copyWithout: arg1) copyWith: arg1addEventListener: arg1  self eventListeners: (self addListener: arg1 to: self eventListeners)adoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self borderStyle baseColor: arg1 twiceDarkerrotationDegrees  ^0.0isDown  ^direction = Character arrowDowndoubleClick: arg1 fromMorph: arg2  ^self notify: arg1 from: arg2labelRightOffset  ^12 * self displayScaleFactormouseOverPagingAreaThumbFillStyle  ^self theme scrollbarMouseOverBarThumbFillStyleFor: selfnewScroller  ^TransformWithLayoutMorph new color: Color transparentsimulateRightClick  self simulateClickWith: MouseEvent yellowButtontreeMorph  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := Color lightBlue lighter.  tmp3 := (GradientFillStyle ramp: {(0.0 -> tmp2 whiter) .         (0.2 -> tmp2) .         (0.8 -> tmp2 darker) .         (1.0 -> tmp2 blacker)}) radial: false.  tmp2 := Color veryLightGray muchLighter.  tmp4 := (GradientFillStyle ramp: {(0.0 -> tmp2 lighter lighter) .         (0.2 -> tmp2 lighter) .         (0.8 -> tmp2) .         (1.0 -> tmp2 blacker)}) radial: false.  tmp1 := self treeMorphClass new     model: self;     beMultiple;     columns: {(MorphTreeColumn new           startWidth: 100;           rowMorphGetSelector: #classButton;           headerButtonLabel: 'Class' font: nil icon: (self iconNamed: #smallOpenIcon) target: nil actionSelector: nil arguments: #()) .         (MorphTreeColumn new           rowMorphGetSelector: #commentText;           headerButtonLabel: 'Comments' font: nil icon: (self iconNamed: #smallPrintIcon) target: nil actionSelector: nil arguments: #())};     makeLastColumnUnbounded;     withHLines: true;     allowColumnDrop;     useSquareCorners;     hResizing: #spaceFill;     vResizing: #spaceFill;     rowInset: 5;     columnInset: 5;     resizerWidth: 2;     preferedPaneColor: Color white;     getMenuSelector: #menu:shifted:;     columnColorForEven: tmp4 odd: tmp3.  ^tmp1 buildContentsprogress: arg1  bar progress = arg1 ifFalse: [ bar progress: arg1.        self changed: #progressValue ]lastSelectedNodePath  ^self selectedNodePathList ifNotEmpty: [:arg1 |  arg1 last ]createActionButtonFor: arg1  ^TabActionButtonMorph forAction: arg1autoMultiSelection  ^autoMultiSelection ifNil: [ autoMultiSelection := false ]asAthensPaintOn: arg1  ^AthensCompositeStrokePaint new fromBorderStyles: borders on: arg1endPoint  ^positiongetList  ^(model perform: (getListSelector ifNil: [ ^#() ])) ifNil: [ #() ]defaultBorderColor  ^Color grayisDockingBar  ^falseselectAll  self table selectIndexes: ((1 to: self table numberOfRows) flatCollect: [:arg1 |  (1 to: self table numberOfColumns) collect: [:arg2 |  {arg1 .                     arg2} ] ]) asArraymodel: arg1  model := arg1newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 icon: arg5 getEnabled: arg6 help: arg7  ^self theme newListIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4 icon: arg5 getEnabled: arg6 help: arg7data: arg1  self children: (arg1 collect: [:arg2 |  FTBasicItem data: arg2 from: dataSource ]) asArrayprivateMoveBy: arg1  super privateMoveBy: arg1.  vertices := vertices collect: [:arg2 |  arg2 + arg1 ].  self arrowForms do: [:arg3 |  arg3 offset: arg3 offset + arg1 ].  curveState := nil.  (self valueOfProperty: #referencePosition) ifNotNil: [:arg4 |  self setProperty: #referencePosition toValue: arg4 + arg1 ]newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 labelForm: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: (AlphaImageMorph new image: arg6) help: arg7selection: arg1  | tmp1 |  arg1 ifNil: [ ^self selectionIndex: 0 ].  tmp1 := scroller submorphs findFirst: [:arg2 |  arg2 complexContents == arg1 ].  tmp1 > 0 ifTrue: [ ^self selectionIndex: tmp1 ].  tmp1 := scroller submorphs findFirst: [:arg2 |  arg2 withoutListWrapper = arg1 withoutListWrapper ].  self selectionIndex: tmp1newTransformMorph  ^MorphTreeTransformMorph newdoubleClick: arg1  | tmp1 |  tmp1 := self scrollerSubMorphFromPoint: arg1 position.  (self listManager doubleClick: arg1 on: tmp1) ifFalse: [ super doubleClick: arg1 ]adhereToEdge  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  #(top right bottom left - center - topLeft topRight bottomRight bottomLeft - none) do: [:arg1 |  arg1 == #- ifTrue: [ tmp1 addLine ] ifFalse: [ tmp1 add: arg1 asString selector: #setToAdhereToEdge: argument: arg1 ] ].  tmp1 popUpEvent: self currentEvent in: self worldhandlesShowingPhrase  ^(self showingHandles ifTrue: [ 'hide handles' ] ifFalse: [ 'show handles' ]) translatedhandlesMouseDown: arg1  ^(super handlesMouseDown: arg1) or: [ arg1 shiftPressed ]textColor  ^colorvalue: arg1  (self sliderMorph ifNil: [ ^self ]) scaledValue: arg1.  self model ifNotNil: [ self setValueSelector ifNotNil: [ self model perform: self setValueSelector with: self sliderMorph scaledValue ] ].  self     changed: #minEnabled;     changed: #maxEnabledresizeScroller  self scroller bounds: self scrollBoundsaddMainPanel  self addMorph: self newMainPanel frame: (0 @ 0 corner: 1 @ 1)handlesMouseOverDragging: arg1  ^(self existsSubscriptionsFor: #mouseEnterDragging) or: [ self existsSubscriptionsFor: #mouseLeaveDragging ]font  ^fontdeselectAll  self isMultipleSelection ifFalse: [ ^self ].  self resetListSelectionsendKeyboardEvent: arg1  ^self sendEvent: arg1 focus: self keyboardFocus clear: [ self keyboardFocus: nil ]interactWithSelection  | tmp1 |  self hasSelection ifFalse: [ ^self ].  tmp1 := (self container exposedRows at: self selectedIndex) submorphs first.  tmp1 submorphsDo: [:arg1 |  arg1 update: #interact ]initialize  super initialize.  borderWidth := 0.  textStyle := TextStyle default copy.  wrapFlag := true.  margins := Margin left: 0 right: 0 top: 0 bottom: 0.  self attachKeymapCategory: #TextMorphthemeChanged  self     color: self defaultColor;     borderColor: self defaultBorderColor;     borderWidth: self defaultBorderWidth.  super themeChangedstartWidth: arg1  currentWidth := arg1initialize  super initialize.  self     dashColors: {Color black .         Color white};     dashLengths: #(1 1)newLabelGroup: arg1 font: arg2 labelColor: arg3  ^self theme newLabelGroupIn: self for: arg1 font: arg2 labelColor: arg3addCircleHandles  | tmp1 |  target isWorldMorph ifTrue: [ ^self addHandlesForWorldHalos ].  self removeAllMorphs.  self bounds: (self worldBoundsForMorph: target renderedMorph).  tmp1 := self basicBox.  target addHandlesTo: self box: tmp1.  self addName.  growingOrRotating := false.  self layoutChanged.  self changedgetStringSelector  ^getStringSelectorenabled: arg1  arg1 ifTrue: [ text makeAllColor: self defaultColor ] ifFalse: [ text makeAllColor: self theme disabledTextColor ].  self changedsetAlignment: arg1  alignment := arg1textSelector  ^textSelectorquestion: arg1  ^self question: arg1 title: 'Question' translatedtabSelectTo: arg1  | tmp1 tmp2 |  tmp1 := tabs indexOf: arg1.  tmp2 := tabs indexOf: self selectedTab ifAbsent: [ ^self ].  tmp1 compareWith: tmp2 ifLesser: [ tmp2 to: tmp1 by: -1 do: [:arg2 |  (tabs at: arg2) addToSelection ] ] ifEqual: [  ] ifGreater: [ tmp2 to: tmp1 do: [:arg2 |  (tabs at: arg2) addToSelection ] ].  self addInHistory: arg1.  self adjustLayoutrecursiveDelete  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg1 |  arg1 recursiveDelete ] ].  self deletekeyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self focusChangedallNodeMorphs  ^scroller submorphsmouseDownInSlider: arg1  interval = 1.0 ifTrue: [ self setValue: 0.        self model hideOrShowScrollBar ].  arg1 redButtonPressed ifFalse: [ ^self ].  slider fillStyle: self pressedThumbFillStyle.  slider borderStyle: self pressedThumbBorderStyle.  self theme useScrollbarThumbShadow ifTrue: [ sliderShadow           color: self sliderShadowColor;           cornerStyle: slider cornerStyle;           bounds: slider bounds;           show ]addTabs  self tabs do: [:arg1 |  manager addTab: arg1 ]scrollDeltaHeight  ^scroller firstSubmorph heightblueButtonUp: arg1  super blueButtonUp: arg1.  self closeselectableIndexAbove: arg1  ^self subclassResponsibilityvIsScrollbarNeeded  (self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ]) ifTrue: [ ^false ].  (self valueOfProperty: #vScrollBarAlways ifAbsent: [ false ]) ifTrue: [ ^true ].  ^self vIsScrollablethemeChanged  self color: (self theme menuColorFor: nil).  super themeChangedupdateFromSelection: arg1  arg1 selectedNodePathList do: [:arg2 |  self selectNodePath: arg2 ].  self scrollSelectionIntoViewworldRenderer  ^worldRenderer ifNil: [ worldRenderer := NullWorldRenderer forWorld: self currentWorld ]text  ^texttargetOffset  ^targetOffsetisSingleSelection  ^self multipleSelection notnewOKButtonFor: arg1 getEnabled: arg2  ^self theme newOKButtonIn: self for: arg1 getEnabled: arg2wantsHaloFromClick  ^owner isSystemWindow nothandlesMouseDown: arg1  ^truedataSource: arg1  dataSource := arg1style  ^#tabbeddashedBorder: arg1  borderDashSpec := arg1.  self changedwantsRoundedCorners  ^(self theme dialogWindowPreferredCornerStyleFor: self) == #roundedreferencePosition: arg1  | tmp1 tmp2 |  tmp1 := self position + (arg1 - self referencePosition).  tmp2 := tmp1 asIntegerPoint.  tmp1 = tmp2 ifTrue: [ self position: tmp2 ] ifFalse: [ self position: tmp1 ]notAtMin  ^self value > self minfillStyle: arg1  ^self isOpen ifTrue: [ self borderColor: arg1 asColor ] ifFalse: [ super fillStyle: arg1 ]emphasis: arg1  emphasis := arg1 value.  ^self font: font emphasis: emphasison: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3doDeferredUpdatingFor: arg1  (Display deferUpdates: true) ifNil: [ ^false ].  (self canvas notNil and: [ self canvas form == Display ]) ifFalse: [ arg1 viewBox: self viewBox.        self canvas: (Display getCanvas copyClipRect: Display boundingBox) ].  ^trueopen  (self treeMorph     buildContents;     embeddedInMorphicWindowLabeled: 'Simple grid example') openInWorldmouseStillDownStepRate  ^200releaseParagraph  self releaseParagraphReallylabelSizeIn: arg1  ^(150 // (arg1 tasks size + 1) max: 10) min: 30canRefreshValues  ^self needsRefreshExposedRows and: [ self table isNotNil and: [ self table hasDataSource ] ]forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]searchedElement: arg1  searchedElement := arg1wantsDropElements: arg1 type: arg2 index: arg3  self dropItemSelector ifNil: [ ^false ].  self wantsDropSelector ifNil: [ ^true ].  ^self model perform: self wantsDropSelector with: arg1bottomFraction: arg1 offset: arg2  bottomFraction := arg1.  bottomOffset := arg2worldMenu  ^owner worldMenufilter  | tmp1 |  tmp1 := OrderedCollection new.  dataSource rootsItems do: [:arg1 |  (self matchingFilter: arg1) ifNotNil: [:arg2 |  tmp1 add: arg2 ] ] displayingProgress: [:arg3 |  'Looking inside ' , arg3 printString ].  dataSource table selectIndex: 1.  ^dataSource class root: (FTRootItem new           children: tmp1 asArray;           yourself) children: dataSource childrenBlockremoveProperty: arg1  extension ifNil: [ ^self ].  extension removeProperty: arg1normalizedX: arg1  ^(arg1 max: self leftBoundary) min: self rightBoundarymaybeAddCollapseItemTo: arg1  isTableLayout  ^trueremoveDropShadow  self hasDropShadow ifFalse: [ ^self ].  self changed.  self hasDropShadow: false.  self shadowOffset: 0 @ 0.  self layoutChanged.  self changedisScrolled  ^falseaddCollapseBox  labelArea ifNil: [ ^self ].  collapseBox := self createCollapseBox.  collapseBox layoutFrame: (self theme windowCollapseBoxLayoutFor: self).  labelArea addMorphBack: collapseBoxupdateContents  treeMorph vIsScrollable ifFalse: [ self atBottom: true ].  super updateContentsparagraph  paragraph ifNotNil: [ ^paragraph ].  self setProperty: #CreatingParagraph toValue: true.  self setDefaultContentsIfNil.  paragraph := Paragraph new textOwner: self owner.  paragraph wantsColumnBreaks: successor notNil.  paragraph compose: text style: textStyle copy from: self startingIndex in: self container.  paragraph focused: self currentHand keyboardFocus == self.  self fit.  self removeProperty: #CreatingParagraph.  self selectionColor: self selectionColor.  ^paragraphselectIndex: arg1 event: arg2  arg1 ifNotNil: [ self selectionStrategy selectIndex: arg1 event: arg2 ] ifNil: [ self deselectAll ]selectAppendingIndex: arg1  | tmp1 tmp2 |  tmp1 := self table selectedIndexes.  tmp2 := (tmp1 includes: arg1) ifTrue: [ tmp1 copyWithout: arg1 ] ifFalse: [ tmp1 copyWithFirst: arg1 ].  self table selectIndexes: tmp2initialize  super initialize.  self     clipSubmorphs: true;     beStickycursor  | tmp1 |  tmp1 := self valueOfProperty: #textCursorLocation ifAbsentPut: [ 1 ].  tmp1 := tmp1 min: text string size.  ^tmp1 roundedlabelHeight  label ifNil: [ ^self isEmbedded ifTrue: [ 0 ] ifFalse: [ self class borderWidth ] ].  ^label height + (self class borderWidth * 2) max: (collapseBox ifNotNil: [ collapseBox height ] ifNil: [ 10 ])mouseMove: arg1  (self containsPoint: arg1 cursorPoint) ifTrue: [ self state: #pressed.        super mouseMove: arg1 ] ifFalse: [ self state: #off ]morphToGrab: arg1  self submorphsDo: [:arg2 |  ((arg2 rejectsEvent: arg1) not and: [ arg2 fullContainsPoint: arg1 cursorPoint ]) ifTrue: [ ^arg2 ] ].  ^nilnewExpander: arg1 for: arg2  ^self theme newExpanderIn: self label: arg1 forAll: {arg2}disable  self enabled: falsesetFont: arg1  fontNumber := arg1justifiedPadFor: arg1  | tmp1 |  internalSpaces = 0 ifTrue: [ ^0 ].  tmp1 := paddingWidth // internalSpaces.  arg1 <= (paddingWidth \\ internalSpaces) ifTrue: [ ^tmp1 + 1 ] ifFalse: [ ^tmp1 ]initialize  super initialize.  self beStraightSegmentsballoonText: arg1  self assureExtension balloonText: arg1newTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5newIncrementButton  ^(self theme builder newButtonFor: self action: #increment getEnabled: #maxEnabled label: (self newButtonLabel: #right ofSize: 24) help: nil)     vResizing: #spaceFill;     width: 64;     roundedCorners: #(3 4);     setProperty: #wantsKeyboardFocusNavigation toValue: false;     on: #mouseStillDown send: #increment to: selfright: arg1  self position: (arg1 - bounds width) @ bounds topmatchingFilter: arg1  arg1 isExpanded ifTrue: [ ((arg1 children collect: [:arg2 |  self matchingFilter: arg2 ]) reject: #isNil) ifNotEmpty: [:arg3 |  ^(self newStaticItemFrom: arg1)                 children: arg3 asArray;                 expandWithoutChange;                 yourself ] ].  ^(pattern matchesIn: (self dataSource toString: arg1)) ifNotEmpty: [ arg1 isExpanded ifTrue: [ self newStaticItemFrom: arg1 ] ifFalse: [ arg1 ] ] ifEmpty: [ nil ]setProperty: arg1 toValue: arg2  arg2 ifNil: [ ^self removeProperty: arg1 ].  self assureExtension setProperty: arg1 toValue: arg2testIntoWorldTransferToNewGuy  | tmp1 tmp2 |  tmp1 := TestInWorldMorph new.  tmp2 := TestInWorldMorph new.  self assert: tmp1 intoWorldCount equals: 0.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 0.  self assert: tmp2 outOfWorldCount equals: 0.  morph addMorphFront: tmp1.  tmp1 addMorphFront: tmp2.  self assert: tmp1 intoWorldCount equals: 0.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 0.  self assert: tmp2 outOfWorldCount equals: 0.  morph openInWorld.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 0.  morph addMorphFront: tmp2.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 0.  morph addMorphFront: tmp1.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 0.  tmp2 addMorphFront: tmp1.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 0.  morph delete.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 1.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 1handleMouseOver: arg1  super handleMouseOver: arg1.  (self handlesMouseOver: arg1) ifTrue: [ arg1 wasHandled: true.        self mouseOver: arg1 ]mouseDown: arg1  self perform: #mouseDown: withArguments: {arg1} inSuperclass: Morph.  self enabled ifFalse: [ ^self ].  self isOn ifTrue: [ self state: #repressed ] ifFalse: [ self state: #pressed ].  actWhen == #buttonDown ifTrue: [ self doButtonAction ].  self mouseStillDown: arg1sendToModel: arg1  arg1 numArgs = 0 ifTrue: [ ^model perform: arg1 ].  arg1 numArgs = 1 ifTrue: [ ^model perform: arg1 with: item ].  arg1 numArgs = 2 ifTrue: [ ^model perform: arg1 with: item with: self ]displaySelectionBlock: arg1 inLine: arg2 on: arg3  (selectionStart notNil and: [ selectionStop notNil and: [ selectionStart ~= selectionStop ] ]) ifTrue: [ | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |        tmp1 := arg1 first stringIndex.        tmp2 := arg1 last stringIndex.        tmp3 := selectionStart stringIndex.        tmp4 := selectionStop stringIndex.        tmp5 := tmp1 to: tmp2.        tmp6 := tmp3 to: tmp4.        ((tmp5 rangeIncludes: tmp3 + 1) or: [ (tmp5 rangeIncludes: tmp4 - 1) or: [ (tmp6 rangeIncludes: tmp1 + 1) or: [ tmp6 rangeIncludes: tmp2 - 1 ] ] ]) ifTrue: [ ^self ] ].  arg1 displayInLine: arg2 on: arg3expandItemPath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  tmp1 := nil.  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ (arg2 complexContents withoutListWrapper = arg1 first or: [ arg1 first isNil ]) ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNotNil: [ tmp1 isExpanded ifFalse: [ tmp1 toggleExpandedState ].        tmp1 changed.        arg1 size = 1 ifTrue: [ ^container listManager setSelectedMorph: tmp1 ].        ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild expandItemPath: arg1 allButFirst ] ].  ^container setSelectedMorph: nilrecipient: arg1  recipient := arg1veryDeepInner: arg1  super veryDeepInner: arg1.  offImage := offImage veryDeepCopyWith: arg1.  pressedImage := pressedImage veryDeepCopyWith: arg1.  state := state veryDeepCopyWith: arg1.  actWhen := actWhencaretRect  ^caretRectaddHandleAt: arg1 color: arg2 on: arg3 send: arg4 to: arg5  ^self addHandleAt: arg1 color: arg2 icon: nil on: arg3 send: arg4 to: arg5keyStroke: arg1  self subclassResponsibilitydrawLinesToFirstChildOn: arg1 lineColor: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  self firstChild hasToggle ifTrue: [ ^self ].  tmp4 := self firstChild toggleBounds.  tmp5 := tmp4 center.  tmp1 := tmp5 x.  tmp2 := bounds bottom.  tmp3 := self firstChild hasToggle ifTrue: [ tmp5 y - (tmp4 height // 2) + 1 ] ifFalse: [ tmp5 y - 2 ].  tmp6 := self theme.  arg1 frameRectangle: (tmp1 @ tmp2 corner: (tmp1 + 1) @ tmp3) width: tmp6 treeLineWidth colors: (tmp6 treeLineColorsFrom: arg2) dashes: tmp6 treeLineDasheschooseFont: arg1  ^self theme chooseFontIn: self title: 'Font Selector' translated font: arg1position  ^positionselectableIndexAfter: arg1  ^{arg1 first .   (arg1 second + 1)}newToolbar  ^self theme newToolbarIn: selfownerChanged  super ownerChanged.  self updateLayoutInDockingBardrawSubmorphsOn: arg1  | tmp1 tmp2 |  submorphs isEmpty ifTrue: [ ^self ].  tmp2 := self computeSubmorphsToDraw.  tmp1 := [:arg2 |  tmp2 do: [:arg3 |  arg2 fullDrawMorph: arg3 ] ].  self clipSubmorphs ifTrue: [ arg1 clipBy: (arg1 clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: tmp1 ] ifFalse: [ tmp1 value: arg1 ]newAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7label: arg1  self label: arg1 font: StandardFonts buttonFontsortChildrenBy: arg1  sortingBlock := arg1listCentering  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #topLeft ] ifNotNil: [ tmp1 listCentering ]ptName  ^#topLeftborderStyleToUse  ^self isSelected ifTrue: [ self theme tabLabelSelectedBorderStyleFor: self ] ifFalse: [ self theme tabLabelNormalBorderStyleFor: self ]displayFor: arg1  | tmp1 |  tmp1 := self elementAt: arg1.  ^displayBlock ifNotNil: [ displayBlock value: tmp1 ] ifNil: [ ^tmp1 ]scroller  ^scrollerbrickDoubleLink  ^self valueOfProperty: #brickDoubleLink ifAbsentPut: [ nil ]startDrag: arg1 with: arg2  self currentHand attachMorph: arg2activate: arg1  arg1 hand newMouseFocus: self.  self takeKeyboardFocuspaneColor: arg1  self setProperty: #paneColor toValue: arg1.  self adoptPaneColor: arg1update: arg1  arg1 = self interactSelector ifTrue: [ ^self doButtonAction ].  super update: arg1item: arg1  | tmp1 tmp2 |  (arg1 between: 1 and: listItems size) ifFalse: [ ^self getListItem: arg1 ].  (listItems at: arg1) ifNil: [ tmp1 := self getListItem: arg1.        maxWidth ifNotNil: [ tmp2 := self widthToDisplayItem: tmp1.              tmp2 > maxWidth ifTrue: [ maxWidth := tmp2.                    self adjustWidth ] ].        listItems at: arg1 put: tmp1 ].  ^listItems at: arg1ghostString: arg1  ghostString := arg1quantum  ^(self sliderMorph ifNil: [ ^0 ]) quantumframeRectangle2: arg1 on: arg2  | tmp1 |  tmp1 := arg1 insetBy: self width // 2.  self width odd ifTrue: [ tmp1 := tmp1 insetBy: (0 @ 0 corner: 1 @ 1) ].  arg2     line: tmp1 topLeft + (2 @ 0) to: tmp1 topRight - (2 @ 0) width: self width color: self color;     line: tmp1 topRight + (-1 @ 1) to: tmp1 topRight + (-1 @ 1) width: self width color: self color;     line: tmp1 topRight + (0 @ 2) to: tmp1 bottomRight - (0 @ 2) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 1) to: tmp1 bottomRight - (1 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (2 @ 0) to: tmp1 bottomLeft + (2 @ 0) width: self width color: self color;     line: tmp1 bottomLeft - (-1 @ 1) to: tmp1 bottomLeft - (-1 @ 1) width: self width color: self color;     line: tmp1 bottomLeft - (0 @ 2) to: tmp1 topLeft + (0 @ 2) width: self width color: self color;     line: tmp1 topLeft + (1 @ 1) to: tmp1 topLeft + (1 @ 1) width: self width color: self coloractiveEnabledNotOverUpFillStyle: arg1  self stateMap atPath: #(active enabled notOver up) put: arg1.  self changedaskBeforeChanging  ^askBeforeChangingmodel  ^modelscrollByKeyboard: arg1  | tmp1 |  tmp1 := arg1 commandKeyPressed ifTrue: [ self hScrollbar ] ifFalse: [ self vScrollbar ].  (arg1 keyValue = 30 or: [ arg1 keyValue = 11 ]) ifTrue: [ tmp1 scrollUp: 3.        ^true ].  (arg1 keyValue = 31 or: [ arg1 keyValue = 12 ]) ifTrue: [ tmp1 scrollDown: 3.        ^true ].  ^falseisClosed  ^trueprivateMoveBy: arg1  referencePosition := referencePosition + arg1.  originalCenter := (originalCenter ifNil: [ self center ]) + arg1.  super privateMoveBy: arg1usableArea  ^Display usableAreamouseMove: arg1  | tmp1 |  self perform: #mouseMove: withArguments: {arg1} inSuperclass: TextMorph.  arg1 redButtonPressed ifFalse: [ ^self ].  tmp1 := arg1 transformedBy: (self transformedFrom: editView) inverseTransformation.  (editView bounds containsPoint: tmp1 position) ifFalse: [ self startStepping: #autoScrollView: at: Time millisecondClockValue arguments: (Array with: tmp1) stepTime: 100 ] ifTrue: [ self stopSteppingSelector: #autoScrollView: ]activeFillStyle  ^self theme dialogWindowActiveFillStyleFor: selfautoDeselect  ^autoDeselect ifNil: [ self resetListSelector notNil ] ifNotNil: [ autoDeselect ]cellColumn: arg1 row: arg2  | tmp1 |  tmp1 := self elementAt: arg2.  ^tmp1 cellMorphFor: selfnewContentMorph  ^Morph new     color: Color transparent;     hResizing: #spaceFill;     vResizing: #spaceFilltargetWith: arg1  | tmp1 |  tmp1 := UIManager default chooseFrom: (self potentialTargets collect: [:arg2 |  arg2 class name asString ]) values: self potentialTargets title: self externalName , ' targets...' translated.  tmp1 ifNil: [ ^self ].  self target: tmp1unsortElements  self subclassResponsibilityactivate  self submorphsDo: [:arg1 |  arg1 activate ]newExpander: arg1 forAll: arg2  ^self theme newExpanderIn: self label: arg1 forAll: arg2handlesKeyboard: arg1  self eventHandler ifNotNil: [ ^self eventHandler handlesKeyboard: arg1 ].  ^falsemakeBothArrows  arrows := #both.  self computeBoundsnewContentMorph  | tmp1 |  tmp1 := (self theme newButtonIn: self for: self getState: nil action: #chooseColor arguments: #() getEnabled: #enabled label: (self newHatchMorph layoutInset: 2) help: nil) hResizing: #spaceFill.  tmp1 contentHolder hResizing: #spaceFill.  ^tmp1defersHaloOnClickTo: arg1  ^falsenewLabel: arg1  ^self newLabelFor: nil label: arg1 getEnabled: nilnewAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6selectedTab  ^selectionHistory ifEmpty: [ nil ] ifNotEmpty: [ selectionHistory last ]noMorePotentialDropTarget  self model noMorePotentialDropTargetposition  ^positionnewContentMorph  ^Morph new     color: Color transparent;     changeTableLayout;     borderStyle: (BorderStyle inset width: 1);     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: self newHatchMorph;     yourselfmouseMove: arg1  self perform: #mouseMove: withArguments: {arg1} inSuperclass: Morph.  self enabled ifFalse: [ ^self ].  (self containsPoint: arg1 cursorPoint) ifTrue: [ state == #on ifTrue: [ self state: #repressed ].        state == #off ifTrue: [ self state: #pressed ] ] ifFalse: [ state == #repressed ifTrue: [ self state: #on ].        state == #pressed ifTrue: [ self state: #off ] ]initialize  super initialize.  label := 'Test label'.  state := #on.  icon := self iconNamed: #smallOkIconisMultiple  ^truepointInWorld: arg1  ^self point: arg1 in: self worldbackgroundColor  ^Smalltalk ui theme selectionColorselectTabAt: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := tabs at: arg1 ifAbsent: [ ^arg2 value ].  tmp1 selected: trueautoFitOnOff  self setProperty: #autoFitContents toValue: self isAutoFit not.  self isAutoFit ifTrue: [ self fit ]handleDropMorph: arg1  | tmp1 tmp2 |  tmp1 := arg1 contents.  ((self wantsDroppedMorph: tmp1 event: arg1) and: [ tmp1 wantsToBeDroppedInto: self ]) ifFalse: [ ^self ].  arg1 wasHandled: true.  tmp2 := (self transformedFrom: arg1 hand world) globalPointToLocal: tmp1 referencePosition.  tmp1 referencePosition: tmp2.  self acceptDroppingMorph: tmp1 event: arg1.  tmp1 justDroppedInto: self event: arg1mouseLeaveDragging: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersservicesForFileNamed: arg1  | tmp1 |  tmp1 := FileServices itemsForFile: arg1.  ^tmp1 reject: [:arg2 |  self unwantedSelectors includes: arg2 selector ]expandAndRefresh  self expand.  self refreshTableadjustWakeupTimes: arg1  | tmp1 |  tmp1 := arg1 - lastStepTime.  stepList do: [:arg2 |  arg2 scheduledTime: arg2 scheduledTime + tmp1 ].  lastStepTime := arg1merge: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := vertices select: [:arg2 |  arg1 vertices includes: arg2 ].  tmp1 size < 2 ifTrue: [ ^nil ].  tmp2 := vertices asOrderedCollection.  [ tmp1 includes: tmp2 first ] whileFalse: [ tmp3 := tmp2 removeFirst.        tmp2 addLast: tmp3 ].  tmp4 := arg1 vertices asOrderedCollection.  [ tmp2 first = tmp4 first ] whileFalse: [ tmp3 := tmp4 removeFirst.        tmp4 addLast: tmp3 ].  [ tmp1 size > 2 ] whileTrue: [ tmp1 := tmp1 asOrderedCollection.        (self mergeDropThird: tmp2 in: tmp4 from: tmp1) ifNil: [ ^nil ] ].  tmp2 second = tmp4 last ifTrue: [ tmp2           removeFirst;           removeFirst.        ^self setVertices: (tmp4 , tmp2) asArray ].  tmp4 second = tmp2 last ifTrue: [ tmp4           removeFirst;           removeFirst.        ^self setVertices: (tmp2 , tmp4) asArray ].  tmp2 second = tmp4 second ifTrue: [ tmp4 removeFirst.        tmp2 remove: tmp2 second.        tmp5 := tmp2 removeFirst.        ^self setVertices: (tmp4 , (Array with: tmp5) , tmp2 reversed) asArray ].  tmp2 last = tmp4 last ifTrue: [ tmp2 removeLast.        tmp4 removeFirst.        ^self setVertices: (tmp2 , tmp4 reversed) asArray ].  ^nildismissViaHalo  self class resetmeasureContents  | tmp1 tmp2 |  tmp1 := self fontToUse.  tmp2 := self hasIcon ifTrue: [ self icon width + 2 ] ifFalse: [ 0 ].  ^((13 * indentLevel + 15 + tmp2 + (contents widthToDisplayInTree: self) max: self minimumWidth) @ ((contents heightToDisplayInTree: self) max: tmp1 height) + (self layoutInset * 2)) ceilingprepareForRotating  ^self addFlexShellreleaseActionMap  self removeProperty: #actionMapmouseEnterDragging: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseEnterDragging from: arg2minResizerX  ^scroller left + self minResizerOffsetshowScrollBars  self     vShowScrollBar;     hShowScrollBartestInset  | tmp1 tmp2 |  tmp1 := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  tmp2 := tmp1 layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 140 @ 60) equals: tmp2rootNodeFromItem: arg1  ^(self rootNodeClassFromItem: arg1) with: arg1 model: selfborderNormal  self borderStyle: (BorderStyle width: 2 color: Color transparent)borderDashOffset  borderDashSpec size < 4 ifTrue: [ ^0.0 ].  ^borderDashSpec fourth asFloatstartSteppingSubmorphsOf: arg1  arg1 allMorphsDo: [:arg2 |  arg2 wantsSteps ifTrue: [ arg2 arrangeToStartSteppingIn: arg2 world ] ]rowAtLocation: arg1  | tmp1 |  tmp1 := (self scroller transformFrom: self) transform: arg1.  ^self listMorph rowAtLocation: tmp1is: arg1 afterColumn: arg2  ^self subclassResponsibilitydrawLineFrom: arg1 to: arg2 on: arg3  ^arg3 line: arg1 to: arg2 width: self width color: self colordropNotifyRecipient: arg1  dropNotifyRecipient := arg1contentsMenu: arg1  | tmp1 tmp2 |  tmp1 := self windowsSatisfying: [:arg2 |  arg2 isCollapsed not ].  tmp2 := self windowsSatisfying: [:arg2 |  arg2 isCollapsed ].  (tmp1 asSortedCollection: [:arg3 :arg4 |  arg3 label caseInsensitiveLessOrEqual: arg4 label ]) do: [:arg2 |  arg1 add: (self truncatedMenuLabelFor: arg2 label) target: arg2 selector: #activateAndForceLabelToShow.        arg1 lastItem icon: arg2 taskbarIcon.        arg2 model canDiscardEdits ifFalse: [ arg1 lastItem color: Color red ] ].  arg1 addLine.  (tmp2 asSortedCollection: [:arg3 :arg4 |  arg3 label caseInsensitiveLessOrEqual: arg4 label ]) do: [:arg2 |  arg1 add: (self truncatedMenuLabelFor: arg2 label) target: arg2 selector: #collapseOrExpand.        arg1 lastItem icon: arg2 taskbarIcon.        arg2 model canDiscardEdits ifFalse: [ arg1 lastItem color: Color red ] ].  arg1 addLine.  ((self submorphs reject: [:arg5 |  (tmp1 includes: arg5) or: [ tmp2 includes: arg5 ] ]) asSortedCollection: [:arg3 :arg4 |  arg3 class name caseInsensitiveLessOrEqual: arg4 class name ]) do: [:arg2 |  arg1 add: (self truncatedMenuLabelFor: arg2 class name) target: arg2 selector: #comeToFront.        arg1 lastItem icon: arg2 taskbarIcon ].  ^arg1hMorph  ^hMorphnullIndex  ^self subclassResponsibilitybringTopmostsToFront  submorphs select: [:arg1 |  arg1 wantsToBeTopmost ] thenDo: [:arg1 |  self addMorphInLayer: arg1 ]adoptPaneColor  self adoptPaneColor: self paneColortextSize: arg1  (self sizes includes: arg1) ifFalse: [ self error ].  size := arg1stepTime  ^100hasSubmorphs  ^submorphs notEmptywrapCenteringString: arg1  ^self layoutMenuPropertyString: arg1 from: self wrapCenteringvScrollBarHeight  | tmp1 |  tmp1 := bounds height - (2 * borderWidth).  self hIsScrollbarNeeded ifTrue: [ tmp1 := tmp1 - self scrollBarThickness ].  ^tmp1adoptPaneColor: arg1  super adoptPaneColor: arg1.  self fillStyle: self normalFillStyletextColor: arg1  color = arg1 ifTrue: [ ^self ].  color := arg1.  text addAttribute: (TextColor color: arg1).  self changedscrollBarAction  ^self valueOfProperty: #scrollBarActionstring: arg1 fontName: arg2 size: arg3  self string: arg1 fontName: arg2 size: arg3 wrap: truecomputeCurvedSegmentCtrlPoints  | tmp1 tmp2 |  tmp2 := self adjustSegmentPointsForArrows.  tmp1 := (1 to: tmp2 size) collect: [:arg1 |  | tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |        tmp3 := tmp2 atWrap: arg1 - 1.        tmp4 := tmp2 atWrap: arg1.        tmp5 := tmp2 atWrap: arg1 + 1.        tmp10 := (tmp5 - tmp3) / 2.        tmp6 := tmp4 distanceTo: tmp3.        tmp7 := tmp5 dist: tmp4.        tmp6 = 0 ifTrue: [ tmp8 := tmp3 ] ifFalse: [ tmp8 := tmp4 - (tmp10 / (1 + (tmp7 / tmp6))) ].        tmp7 = 0 ifTrue: [ tmp9 := tmp5 ] ifFalse: [ tmp9 := tmp4 + (tmp10 / (1 + (tmp6 / tmp7))) ].        {tmp8 asFloatPoint .         tmp4 .         tmp9 asFloatPoint} ].  ^tmp1newOKButtonFor: arg1  ^self newOKButtonFor: arg1 getEnabled: nilgetSelector  ^viewSelectorisMouseDown  ^self type == #mouseDownmouseDown: arg1  self editView ifNotNil: [ self editView mouseDownFromTextMorph: arg1 ].  super mouseDown: arg1.  self flag: #hack.  (self editView respondsTo: #highlights) ifTrue: [ self editView highlights detect: [:arg2 |  arg2 containsPoint: arg1 position in: (self bounds: self editView innerBounds from: self) ] ifFound: [:arg3 |  arg3 clicked: arg1 ] ]selectedNode  ^self selectedNodePath ifNotNil: [:arg1 |  arg1 ifEmpty: [ nil ] ifNotEmpty: [ arg1 last ] ]newSeparator  ^self theme newSeparatorIn: selfnewAlphaSelector: arg1 getAlpha: arg2 setAlpha: arg3 help: arg4  ^self theme newAlphaSelectorIn: self for: arg1 getAlpha: arg2 setAlpha: arg3 help: arg4allNonSubmorphMorphs  ^OrderedCollection newaddSeparator  self addMorphBack: MenubarSeparatorMorph newballoonColor  ^self valueOfProperty: #balloonColor ifAbsent: [ self defaultBalloonColor ]newScrollingIndex  ^newScrollingIndexresizeWidget  self resizeField.  self resizeButtonthemeChanged  super themeChanged.  self     color: self defaultColor;     borderWidth: self defaultBorderWidthparagraph  | tmp1 |  paragraph ifNotNil: [ ^paragraph ].  self setProperty: #CreatingParagraph toValue: true.  self setDefaultContentsIfNil.  tmp1 := Paragraph new textOwner: self owner.  tmp1 wantsColumnBreaks: successor notNil.  tmp1 compose: text style: textStyle copy from: self startingIndex in: self container.  wrapFlag ifFalse: [ tmp1 adjustRightX ].  tmp1 focused: self currentHand keyboardFocus == self.  paragraph := tmp1.  self fit.  self removeProperty: #CreatingParagraph.  ^paragraphwantsSteps  ^self hasProperty: #doesButtonActionannounceDeActivated  self announce: (WindowDeActivated new           window: self;           yourself)open  self menuBarItems do: [:arg1 |  self add: arg1 label icon: arg1 icon help: arg1 help subMenu: (arg1 subMenu ifNotNil: #asMenubarMenuMorph) action: arg1 action keyText: arg1 keyText.        arg1 separator ifTrue: [ self addSeparator ] ].  self     adhereToTop;     openInWorldresizeCursor  ^Cursor resizeForEdge: #topRighttestIsAboveRow  self assert: (strategy is: 3 aboveRow: 4).  self deny: (strategy is: 3 aboveRow: 2).  self deny: (strategy is: 3 aboveRow: 3)isActive  ^self isWindowActive: selfdefaultBounds  ^0 @ 0 extent: 40 @ 40drawCheckOn: arg1  | tmp1 tmp2 |  tmp1 := self computeCheckTopLeft.  tmp2 := self retrieveCheckIcon.  arg1 drawImage: tmp2 at: tmp1icon  ^self iconNamed: #homeIconmouseDown: arg1  self flag: #todo.  (arg1 yellowButtonPressed and: [ arg1 commandKeyPressed not ]) ifTrue: [ (self yellowButtonActivity: arg1 shiftPressed) ifTrue: [ ^super mouseDown: arg1 ] ].  scroller hasSubmorphs ifTrue: [ scroller submorphs last mouseDown: (arg1 transformedBy: (scroller transformFrom: self)) ].  self eventHandler ifNotNil: [ self eventHandler mouseDown: arg1 fromMorph: self ]setBoundsWithFlex: arg1  self isFlexed ifTrue: [ super bounds: ((owner transform globalPointToLocal: arg1 topLeft) extent: arg1 extent) ] ifFalse: [ super bounds: arg1 ]setValueSelector  ^setValueSelectoraddPaneHSplitters  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := paneMorphs reject: [:arg1 |  arg1 layoutFrame bottomFraction = 1 or: [ arg1 layoutFrame bottomFraction = 0 ] ].  [ tmp1 notEmpty ] whileTrue: [ tmp2 := tmp1 first layoutFrame bottomFraction.        tmp3 := tmp1 select: [:arg1 |  arg1 layoutFrame bottomFraction = tmp2 ].        tmp4 := paneMorphs select: [:arg1 |  arg1 layoutFrame topFraction = tmp2 ].        tmp1 := tmp1 copyWithoutAll: (self addPaneHSplitterBetween: tmp3 and: tmp4) ]secondarySelection: arg1  secondarySelection := arg1minHeight  ^super minHeight max: self theme buttonMinHeightleft: arg1  self position: arg1 @ bounds topgetValueSelector  ^getValueSelectorgetLabelSelector  ^getLabelSelectoritemSelectedAmongMultiple: arg1  ^self isMultipleSelection ifTrue: [ (self listSelectionAt: arg1) == true ] ifFalse: [ false ]expand  isExpanded := true.  recentlyChanged := true.  self dataSource updateSelectionWithCollectBlock: [:arg1 :arg2 |  arg1 <= arg2 ifTrue: [ arg1 ] ifFalse: [ arg1 + self numberOfVisibleChildren ] ]avoidsOcclusions  ^avoidsOcclusions ifNil: [ false ]refresh  self ensureAtLeastOneColumn.  self recalculateVerticalScrollBar.  self verticalScrollBar changed.  horizontalScrollBar ifNotNil: [ self horizontalScrollBar changed ].  self container changedbeIconBottom  iconPosition := #bottom.  self update: getIconSelectornewToolSpacer  ^self theme newToolSpacerIn: selfmargin  ^marginsimulateClick  self simulateClickWith: MouseEvent redButtoncurrentCursor: arg1  currentCursor := arg1clicked: arg1 inTheCheckboxOf: arg2  | tmp1 |  arg2 ifNil: [ ^false ].  tmp1 := arg2 point: arg1 position from: client.  ^self isCheckList and: [ (arg2 checkClickableZone translateBy: 2 @ 0) containsPoint: tmp1 ]waitForDelay1: arg1 delay2: arg2  | tmp1 tmp2 |  timeOfLastScroll ifNil: [ self resetTimer ].  tmp1 := Time millisecondClockValue.  (tmp2 := currentScrollDelay) ifNil: [ tmp2 := arg1 ].  currentScrollDelay := tmp2 * 9 // 10 max: arg2.  timeOfLastScroll := tmp1.  ^truemessage: arg1 title: arg2  ^self theme messageIn: self text: arg1 title: arg2drawSubmorphsOnAthensCanvas: arg1  self drawClippedOnAthensCanvas: arg1 during: [ submorphs reverseDo: [:arg2 |  arg1 fullDrawMorph: arg2 ] ]columnInset  ^columnInset ifNil: [ columnInset := 0 ]rightBoundary  | tmp1 |  tmp1 := rightOrBottom reject: [:arg1 |  arg1 layoutFrame rightFraction ~= 1 and: [ arg1 layoutFrame leftFraction = arg1 layoutFrame rightFraction ] ].  tmp1 ifEmpty: [ ^(self splitterRight ifNil: [ self containingWindow panelRect right ] ifNotNil: [:arg2 |  arg2 left ]) + 25 ].  ^(tmp1 collect: [:arg1 |  arg1 right - arg1 minExtent x - (arg1 layoutFrame leftOffset ifNil: [ 0 ]) + (self layoutFrame rightOffset ifNil: [ 0 ]) ]) min - self class splitterWidthabort: arg1 title: arg2  ^self theme abortIn: self text: arg1 title: arg2keyStroke: arg1  arg1 keyValue = 28 ifTrue: [ self moveSelectionRight: -1 event: arg1 ].  arg1 keyValue = 29 ifTrue: [ self moveSelectionRight: 1 event: arg1 ].  arg1 keyValue = 31 ifTrue: [ selectedItem ifNotNil: [ selectedItem subMenu ifNotNil: [:arg2 |  arg2 activateFromKeyboard: arg1 ] ] ].  ^super keyStroke: arg1topLeft  ^bounds topLeftplayMinimizeSound  self theme windowMinimizeSound playexpandedFormForMorph: arg1  ^(self selectedMorph = arg1 and: [ self theme selectionColor luminance < 0.6 ]) ifTrue: [ self theme whiteTreeExpandedForm ] ifFalse: [ self theme treeExpandedForm ]mouseMove: arg1  self canResizeColumn ifFalse: [ ^self ].  arg1 hand temporaryCursor ifNil: [ ^self ].  self class fastSplitterResize ifTrue: [ traceMorph ifNil: [ traceMorph := Morph newBounds: self bounds.              traceMorph borderColor: Color lightGray.              traceMorph borderWidth: 1.              self owner addMorph: traceMorph ].        traceMorph position: (arg1 cursorPoint x - lastMouse second x) @ traceMorph position y ] ifFalse: [ self updateFromEvent: arg1 ]hasContents  hasContentsSelector ifNil: [ ^super hasContents ].  ^self sendToModel: hasContentsSelectorupdateExposedRows  | tmp1 tmp2 tmp3 tmp4 |  self canRefreshValues ifFalse: [ ^self ].  tmp1 := self calculateMaxVisibleRows.  tmp4 := self calculateStartIndexWhenShowing: tmp1.  tmp2 := self table columns.  tmp3 := self calculateColumnWidths.  exposedRows := SmallDictionary new.  tmp4 to: (tmp4 + tmp1 - 1 min: self table numberOfRows) do: [:arg1 |  | tmp5 |        tmp5 := FTTableRowMorph table: self table.        (self exposedColumnsRange: tmp3) do: [:arg2 |  | tmp6 |              tmp6 := self table dataSource cellColumn: (tmp2 at: arg2) row: arg1.              tmp6 width: (tmp3 at: arg2).              tmp5 addMorphBack: tmp6 ].        tmp5 privateOwner: self.        exposedRows at: arg1 put: tmp5 ]addTextAnchorMenuItems: arg1 hand: arg2  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 addUpdating: #hasInlineAnchorString selector: #changeInlineAnchor.  tmp1 addUpdating: #hasParagraphAnchorString selector: #changeParagraphAnchor.  tmp1 addUpdating: #hasDocumentAnchorString selector: #changeDocumentAnchor.  arg1 ifNotNil: [ arg1 add: 'text anchor' subMenu: tmp1 ].  ^tmp1maybeCollapse: arg1 with: arg2  arg1 hand obtainHalo: self.  self delete.  (arg2 containsPoint: arg1 cursorPoint) ifFalse: [ target addHalo: arg1 ] ifTrue: [ target collapse ]cursorPoint  ^self positionmultiSelection  ^multiSelection ifNil: [ multiSelection := false ]newColorChooserFor: arg1 getColor: arg2 setColor: arg3 getEnabled: arg4 help: arg5  ^self theme newColorChooserIn: self for: arg1 getColor: arg2 setColor: arg3 getEnabled: arg4 help: arg5innerBounds  | tmp1 |  tmp1 := super innerBounds.  tmp1 := tmp1 withBottom: tmp1 bottom - self pagerHeight.  ^tmp1mouseStillDownStepRate  ^1removeLabelArea  self removeGrips.  labelArea delete.  label := nil.  (self isCollapsed not or: [ self isTaskbarPresent ]) ifTrue: [ self addGripsIfWanted ]setUp  super setUp.  state := self actualClass context: (FTPropertyColumnSortingStrategy new           property: #yourself;           yourself).  state context state: statebeSmoothCurve  smoothCurve == true ifFalse: [ smoothCurve := true.        self computeBounds ]clipLayoutCells  ^self valueOfProperty: #clipLayoutCells ifAbsent: [ false ]position  ^temporaryCursor ifNil: [ bounds topLeft ] ifNotNil: [ temporaryCursorOffset ifNil: [ bounds topLeft ] ifNotNil: [:arg1 |  bounds topLeft - arg1 ] ]first  ^firstautoDeselection  ^autoDeselection ifNil: [ autoDeselection := false ]newRow  ^self theme newRowIn: self for: #()newEditableDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 ghostText: arg6 getEnabled: arg7 help: arg8  ^self theme newEditableDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: String default: '' ghostText: arg6 getEnabled: arg7 useIndex: false help: arg8childrenBlock  ^childrenBlockreleaseCachedState  | tmp1 |  super releaseCachedState.  cacheCanvas := nil.  tmp1 := owner.  self removeAllMorphs.  self initialize.  self privateOwner: tmp1.  self releaseAllFocusownerChanged  super ownerChanged.  self adjustLayoutintersects: arg1  | tmp1 |  (super intersects: arg1) ifFalse: [ ^false ].  tmp1 := self bounds: arg1 in: self world.  self lineSegmentsDo: [:arg2 :arg3 |  (tmp1 intersectsLineFrom: arg2 to: arg3) ifTrue: [ ^true ] ].  ^falseinitialize  super initialize.  self     borderWidth: 0;     changeTableLayout;     labelMorph: self newLabelMorph;     solidLabelMorph: self newLabelMorph;     contentMorph: self newContentMorph;     addMorphBack: self contentMorphaddAlarm: arg1 with: arg2 after: arg3  ^self addAlarm: arg1 withArguments: (Array with: arg2) after: arg3handlesMouseDown: arg1  ^truebuildContents  super buildContents.  self updatePagersearchText: arg1  ^(self class searchStrategies at: self searchStrategy ifAbsent: [ self class searchStrategies at: #default ]) searchWith: arg1 dataSource: selfdefaultColor  ^self theme settings derivedMenuColorextent: arg1  super extent: arg1.  self selectSubmorphsOf: self pasteUpMorphnewPosition  ^newPositionnewExpander: arg1 forAll: arg2  ^self theme newExpanderIn: self label: arg1 forAll: arg2mouseEnterDragging: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlerstestMouseEnterDraggingFromMorph  | tmp1 |  tmp1 := MouseEvent basicNew setType: #mouseOver position: nil buttons: 2 hand: Morph new.  morph eventHandler on: #mouseEnterDragging send: #value to: true.  self assert: (morph handleMouseEnter: tmp1) identicalTo: truerectangle  ^self topLeft corner: self bottomRighthandlesKeyDown: arg1  ^self existsSubscriptionsFor: #keyDowndrawSubmorphsOnAthensCanvas: arg1  super drawSubmorphsOnAthensCanvas: arg1.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOnAthensCanvas: arg1 ]colorSelected: arg1  self basicSelectedColor: arg1window  ^windowtopOffset  ^topOffsetvScrollbarShowNever  self vScrollbar showNever.  self updateScrollbarsscrollToShow: arg1  | tmp1 |  tmp1 := self scroller offset.  (arg1 top - tmp1 y >= 0 and: [ arg1 bottom - tmp1 y <= self innerBounds height ]) ifFalse: [ tmp1 := tmp1 x @ (arg1 top min: self scrollTarget height - self innerBounds height) ].  (arg1 left - tmp1 x >= 0 and: [ arg1 right - tmp1 x <= self innerBounds width ]) ifFalse: [ tmp1 := (arg1 left min: self scrollTarget width - self innerBounds width) @ tmp1 y ].  tmp1 = self scroller offset ifFalse: [ self scroller offset: tmp1.        self setScrollDeltas ]beExplicit  startGrow: arg1 with: arg2  | tmp1 |  self obtainHaloForEvent: arg1 andRemoveAllHandlesBut: arg2.  tmp1 := target point: target bottomRight in: owner.  positionOffset := (self world viewBox containsPoint: tmp1) ifTrue: [ arg1 cursorPoint - tmp1 ] ifFalse: [ 0 @ 0 ].  originalExtent := target extentveryDeepInner: arg1  super veryDeepInner: arg1.  viewSelector := viewSelector veryDeepCopyWith: arg1.  lastSketchForm := lastSketchForm veryDeepCopyWith: arg1.  lastFormShown := lastFormShown veryDeepCopyWith: arg1.  drawTime := drawTime veryDeepCopyWith: arg1fullDrawOn: arg1  self visible ifFalse: [ ^self ].  (arg1 isVisible: self fullBounds) ifFalse: [ ^self ].  (self hasProperty: #errorOnDraw) ifTrue: [ ^self drawErrorOn: arg1 ].  [ self hasDropShadow ifTrue: [ self drawDropShadowOn: arg1 ].  arg1 roundCornersOf: self during: [ (arg1 isVisible: self bounds) ifTrue: [ arg1 drawMorph: self ].        self drawSubmorphsOn: arg1.        self drawDropHighlightOn: arg1.        self drawMouseDownHighlightOn: arg1 ] ] on: Error do: [:arg2 |  self setProperty: #errorOnDraw toValue: true.        self setProperty: #drawError toValue: arg2 freeze.        ^self drawErrorOn: arg1 ]newAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7newStateForEnabled: arg1  ^self subclassResponsibilitynewDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil useIndex: true help: arg5obtainHaloForEvent: arg1 andRemoveAllHandlesBut: arg2  arg1 hand obtainHalo: self.  self removeAllHandlesBut: arg2pressed: arg1  self complexContents pressed: arg1forwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1computeSubmorphsToDraw  owner width < tab showIconTreshold ifTrue: [ (storedIcon isNil and: [ icon notNil ]) ifTrue: [ storedIcon := icon.              self removeMorph: icon ].        ^{morph} ].  storedIcon ifNotNil: [ self addMorphFront: storedIcon.        storedIcon := nil ].  ^self submorphsleftFraction: arg1 offset: arg2  leftFraction := arg1.  leftOffset := arg2drawOnAthensCanvas: arg1  | tmp1 |  self setDefaultContentsIfNil.  super drawOnAthensCanvas: arg1.  self startingIndex > text size ifTrue: [ ^self ].  tmp1 := self bounds topLeft corner: self innerBounds bottomRight.  self paragraph drawOnAthensCanvas: arg1 bounds: tmp1 color: colorhandlerForMetaMenu: arg1  self isWorldMorph ifTrue: [ ^self ].  arg1 handler ifNotNil: [ arg1 handler isWorldMorph ifTrue: [ ^self ] ].  ^nilstartStepping: arg1  ^self startStepping: arg1 at: Time millisecondClockValue selector: #stepAt: arguments: nil stepTime: nilisBordered  ^falsemouseUp: arg1  self noMorePotentialDropTarget.  super mouseUp: arg1sortElements: arg1  unsortedElements ifNil: [ unsortedElements := self elements ].  self elements: (self elements sorted: arg1)runStepMethods  worldState runStepMethodsIn: selfintoWorld: arg1  arg1 ifNil: [ ^self ].  super intoWorld: arg1.  intoWorldCount := intoWorldCount + 1releaseAllFocus  mouseFocus := nil.  self newKeyboardFocus: nilitem  ^itemfocusIndicatorCornerRadius  ^self theme buttonFocusIndicatorCornerRadiusFor: selfisDefault  ^self valueOfProperty: #isDefault ifAbsent: [ false ]keyStroke: arg1 from: arg2  | tmp1 |  tmp1 := arg1 keyCharacter.  tmp1 = $b ifTrue: [ self browseItem.        ^true ].  tmp1 = $i ifTrue: [ self inspectItem.        ^true ].  tmp1 = $I ifTrue: [ self exploreItem.        ^true ].  ^falseremoveHaloAround: arg1  | tmp1 |  tmp1 := self halo.  tmp1 ifNil: [ ^self ].  tmp1 target == arg1 ifFalse: [ ^self ].  self removeProperty: #halo.  tmp1 deleteacceptDroppingMorph: arg1 event: arg2  self model acceptDroppingMorph: arg1 event: arg2 inMorph: self.  self resetPotentialDropMorph.  arg2 hand releaseMouseFocus: self.  Cursor normal showbeLeft  self option: #leftopenNodePath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  tmp1 := nil.  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ (arg2 complexContents = arg1 first or: [ arg1 first isNil ]) ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNotNil: [ tmp1 isExpanded ifFalse: [ tmp1 toggleExpandedState.              container adjustSubmorphPositions ].        tmp1 changed.        arg1 size = 1 ifTrue: [ ^container setSelectedMorph: tmp1 ].        ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild openNodePath: arg1 allButFirst ] ].  ^container setSelectedMorph: nilflushLayoutCache  cachedMinExtent := nilhasIconOrMarker  ^self hasIcon or: [ self hasMarker ]withPinBox  pinBox ifNotNil: [ pinBox delete ].  pinBox := self iconButtonCalling: #pinBoxClicked withForm: self pinForm scaledByDisplayScaleFactor helpText: 'Keep this menu up'.  self addMorph: pinBox asElementNumber: 4textAlignmentSymbol  ^self editor textAlignmentSymbolpassiveEnabledNotOverUpFillStyle: arg1  self stateMap atPath: #(passive enabled notOver up) put: arg1.  self changedisMoved  ^falseremovePager  self pager ifNotNil: [ self removeMorph: self pager.        pager := nil.        self updateList.        self resizerChanged ]openOn: arg1  rootClass := arg1.  (self dialogWindowIn: self currentWorld title: 'All Object subclasses') openInWorldarguments: arg1  arguments := arg1 asArray copydotColor  ^dotColor ifNil: [ self setDefaultColors.        dotColor ]selectionFrame  ^self bounds: self bounds in: containerhandleTodayTouched  self date: Date today.  self changedscrollToIndex: arg1  (self container isRowIndexFullyVisible: arg1) ifTrue: [ ^self ].  arg1 <= self showIndex ifTrue: [ self moveShowIndexTo: arg1 ] ifFalse: [ self moveShowIndexTo: (self selectionModeStrategy indexForRow: arg1 - self container calculateMinVisibleRows + 1) ]drawForForm: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := arg1 boundingBox.  tmp1 := self scaleFor: tmp3 in: self innerBounds.  tmp4 := Display defaultCanvasClass extent: tmp3 extent depth: arg2 depth.  tmp4 translateBy: tmp3 topLeft negated during: [:arg3 |  arg3 drawImage: arg1 at: 0 @ 0 ].  tmp2 := tmp4 form magnify: tmp4 form boundingBox by: tmp1 smoothing: 1.  lastFormShown := tmp2.  arg2 paintImage: tmp2 at: self center - tmp2 boundingBox centerlastChild  | tmp1 |  tmp1 := self firstChild ifNil: [ ^nil ].  [ tmp1 nextSibling isNil ] whileFalse: [ tmp1 := tmp1 nextSibling ].  ^tmp1update: arg1  super update: arg1.  arg1 = self getValueSelector ifTrue: [ ^self updateValue ].  arg1 = self getEnabledSelector ifTrue: [ ^self updateEnabled ]addFontStyleHandle: arg1  innerTarget isTextMorph ifTrue: [ self addHandle: arg1 on: #mouseDown send: #chooseStyle to: innerTarget ]wantsDropSelector  ^wantsDropSelectorvSpaceFill: arg1  flags := arg1 ifTrue: [ self flags bitOr: 2 ] ifFalse: [ self flags bitClear: 2 ]grabSelfOrTopRenderer: arg1  | tmp1 |  tmp1 := self topRendererOrSelf.  arg1 hand grabMorph: tmp1.  (tmp1 isKindOf: SystemWindow) ifTrue: [ tmp1 position: arg1 hand position + (tmp1 position - arg1 startPoint) ]unrotatedWidth  vertices size = 2 ifTrue: [ ^self borderWidth ].  ^((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) widthicon  ^self iconNamed: #smallExpertIconposition: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1.  temporaryCursor ifNotNil: [ tmp1 := tmp1 + temporaryCursorOffset ].  tmp2 := tmp1 - bounds topLeft.  (tmp2 x = 0 and: [ tmp2 y = 0 ]) ifTrue: [ ^self ].  tmp3 := self fullBounds.  (tmp2 dotProduct: tmp2) > 100 ifTrue: [ self invalidRect: tmp3.        self invalidRect: (tmp3 translateBy: tmp2) ] ifFalse: [ self invalidRect: (tmp3 merge: (tmp3 translateBy: tmp2)) ].  self privateFullMoveBy: tmp2releaseCachedState  super releaseCachedState.  self releaseParagraphpotentialDropRow  ^potentialDropRow ifNil: [ 0 ]newOKButtonFor: arg1  ^self newOKButtonFor: arg1 getEnabled: nilstart: arg1  startValue := arg1updateData  children := nilgetMenuSelector  ^getMenuSelectornumberOfRows  ^self rootItem numberOfVisibleChildrenpressed: arg1  self owner owner pressed: arg1resizeContainer  | tmp1 tmp2 |  tmp1 := (self bounds left - self borderWidth) @ self bounds top - self borderWidth.  tmp2 := (self bounds right - self verticalScrollBarWidth - self borderWidth) @ (self bounds bottom - self horizontalScrollBarHeight - self borderWidth).  self container bounds: (function isExplicit ifTrue: [ function resizeContainerFrom: tmp1 to: tmp2 ] ifFalse: [ tmp1 corner: tmp2 ])wantsHaloFromClick  ^owner notNil and: [ owner hasSubmorphs ]actionSelector: arg1  actionSelector := arg1mouseDown: arg1  (arg1 shiftPressed and: [ self isEditable ]) ifTrue: [ ^super mouseDown: arg1 ].  isSelected ifTrue: [ arg1 hand newMouseFocus: nil.        owner selectItem: nil event: arg1 ] ifFalse: [ arg1 hand newMouseFocus: owner.        owner selectItem: self event: arg1 ]grabWindow  | tmp1 tmp2 |  tmp1 := self world visibleSystemWindows.  tmp2 := UIManager default chooseFrom: (tmp1 collect: [:arg1 |  arg1 labelString ]) values: tmp1 lines: #() message: 'Choose a window to add to the organiser' translated title: 'Grab window' translated.  tmp2 ifNotNil: [ self addWindow: tmp2 ]target  ^targetupdate: arg1  arg1 = self nodeListSelector ifTrue: [ ^self updateList ].  super update: arg1layoutFrame  ^extension ifNotNil: [ extension layoutFrame ]initialize  super initialize.  self setDefaultParameters.  self listDirection: #topToBottom.  self hResizing: #shrinkWrap.  self vResizing: #shrinkWrap.  stayUp := false.  self setProperty: #morphicLayerNumber toValue: self morphicLayerNumber.  self theme currentSettings preferRoundCorner ifTrue: [ self useRoundedCorners ]withSuccessorsDo: arg1  | tmp1 |  tmp1 := self.  [ tmp1 isNil ] whileFalse: [ arg1 value: tmp1.        tmp1 := tmp1 successor ]drawOn: arg1  super drawOn: arg1.  searchedElement ifNotNil: [ arg1 clipBy: self innerBounds during: [:arg2 |  arg2 fillRectangle: self searchedFrame color: (self secondarySelectionColor ifNil: [ self theme secondarySelectionColor ]) ] ].  selectedMorph ifNotNil: [ arg1 clipBy: self innerBounds during: [:arg2 |  arg2 fillRectangle: self selectionFrame color: (self selectionColorToUse ifNil: [ self theme selectionColor ]) ] ].  self drawLinesOn: arg1expandBoxHit  self isCollapsed ifTrue: [ self playRestoreUpSound.        self           hide;           collapseOrExpand.        self unexpandedFrame ifNil: [ self unexpandedFrame: fullFrame ].        self           fullscreen;           setExpandBoxBalloonText.        ^self show ].  self unexpandedFrame ifNil: [ self playMaximizeSound.        self theme shouldUseAnimations ifTrue: [ self animateMaximize ].        self           unexpandedFrame: fullFrame;           fullscreen ] ifNotNil: [ self playRestoreDownSound.        self theme shouldUseAnimations ifTrue: [ self animateRestore ].        self           bounds: self unexpandedFrame;           unexpandedFrame: nil ].  self setExpandBoxBalloonTextcorrectFrom: arg1 to: arg2 with: arg3  editor ifNotNil: [ editor correctFrom: arg1 to: arg2 with: arg3 ]isMaximized  ^self unexpandedFrame notNilquestionWithoutCancel: arg1 title: arg2  ^self theme questionWithoutCancelIn: self text: arg1 title: arg2columnOrderOfWidthDistribution  | tmp1 tmp2 |  self startColumnIndex isZero ifTrue: [ ^1 to: self table numberOfColumns ].  tmp1 := startColumnIndex to: self table numberOfColumns.  tmp2 := startColumnIndex > 1 ifTrue: [ startColumnIndex - 1 to: 1 by: -1 ] ifFalse: [ #() ].  ^tmp1 , tmp2hasToggle  ^complexContents hasContentsgapAfterToggle  ^gapAfterToggle ifNil: [ gapAfterToggle := 5 ]scrollTabsRight  self visibleTabRange: (self visibleTabRange last \\ self tabs size + 1 to: 0).  self updateTabsgetImageSelector: arg1  getImageSelector := arg1minimize  self isMinimized ifFalse: [ self collapseBoxHit ]model  ^modelpreview: arg1  preview := arg1date  ^dateitems: arg1  items := arg1addHalo: arg1 from: arg2  ^self addHalo: arg1optimalExtent  ^self listMorph extent + (self borderWidth * 2) + self scrollBarThicknesstabsAndControls  | tmp1 tmp2 |  self tabs ifEmpty: [ self visibleTabRange: (1 to: 0).        ^#() ].  tmp1 := self calculateVisibleTabs.  tmp1 ifEmpty: [ self visibleTabRange: (1 to: 0).        ^#() ].  tmp2 := self tabs indexOf: tmp1 first.  self visibleTabRange: (tmp2 to: tmp2 + tmp1 size - 1).  tmp1 size = self tabs size ifFalse: [ tmp1           add: self newSpacer;           addAll: self controls.        self cornerStyle = #rounded ifTrue: [ tmp1 add: self newEndSpacer ] ].  ^tmp1lastRefresh  ^lastRefresh ifNil: [ lastRefresh := 0 ]focusIndicatorMorph  ^self theme focusIndicatorMorphFor: selfkern  ^kerncomposeLinesFrom: arg1 to: arg2 delta: arg3 into: arg4 priorLines: arg5 atY: arg6 textStyle: arg7 text: arg8 container: arg9 wantsColumnBreaks: arg10  wantsColumnBreaks := arg10.  lines := arg4.  theTextStyle := arg7.  theText := arg8.  theContainer := arg9.  deltaCharIndex := arg3.  currCharIndex := startCharIndex := arg1.  stopCharIndex := arg2.  prevLines := arg5.  currentY := arg6.  defaultLineHeight := theTextStyle lineGrid.  maxRightX := theContainer left.  possibleSlide := stopCharIndex < theText size and: [ theContainer isMemberOf: Rectangle ].  nowSliding := false.  prevIndex := 1.  scanner := CompositionScanner new text: theText textStyle: theTextStyle.  scanner wantsColumnBreaks: wantsColumnBreaks.  isFirstLine := true.  self composeAllLines.  isFirstLine ifTrue: [ self addNullLineWithIndex: startCharIndex andRectangle: (theContainer left @ theContainer top extent: 0 @ defaultLineHeight) ] ifFalse: [ self fixupLastLineIfCR ].  ^{lines asArray .   maxRightX}fillStyleToUse  ^self perform: (self availableFillStyles at: (self interactionStates indexOf: self interactionState))autoMultiSelection  ^self listManager autoMultiSelectionhasDragAndDropEnabledString  ^self dragNDropEnabled -> 'accept drops' translatedselectedIndex  ^selectedIndexaddExportMenuItems: arg1 hand: arg2  arg1 ifNotNil: [ | tmp1 |        tmp1 := UIManager default newMenuIn: self for: self.        tmp1 add: 'BMP file' selector: #exportAsBMP.        tmp1 add: 'GIF file' selector: #exportAsGIF.        tmp1 add: 'JPEG file' selector: #exportAsJPEG.        tmp1 add: 'PNG file' selector: #exportAsPNG.        arg1 add: 'export...' icon: (self iconNamed: #smallExportIcon) subMenu: tmp1.        arg1 lastItem icon: (self iconNamed: #smallExportIcon) ]playOpenSound  self theme windowOpenSound playtopRight  ^bounds topRightselectAll  self table selectIndexes: (1 to: self table numberOfRows) asArrayaction  ^self actionSelectorgetIconSelector  ^getIconSelectorframeRectangle0: arg1 on: arg2  arg2 frameAndFillRectangle: arg1 fillColor: Color transparent borderWidth: self width borderColor: self colorbounds  container ifNil: [ ^bounds ].  ^container bounds ifNil: [ bounds ]style: arg1  style := arg1.  self changedtoggleImageForm  ^isExpanded ifTrue: [ container expandedFormForMorph: self ] ifFalse: [ container notExpandedFormForMorph: self ]layout: arg1 in: arg2  arg1 submorphsDo: [:arg3 |  arg3 layoutProportionallyIn: arg2 ]addNodePath: arg1  self selectedNodePathList add: arg1selectedPressedBorderStyle  ^self theme buttonSelectedPressedBorderStyleFor: selfclose  self deleteeventHandler: arg1  self assureExtension eventHandler: arg1drawSubmorphsOn: arg1  super drawSubmorphsOn: arg1.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: arg1 ]testSortDataSource  self subclassResponsibilitysimulateClickWith: arg1  | tmp1 |  tmp1 := 0.  {(#mouseDown -> arg1) .   (#mouseUp -> tmp1)} do: [:arg2 |  self activeHand handleEvent: (MouseButtonEvent new setType: arg2 key position: (self pointInWorld: self center) which: (tmp1 bitXor: arg1) buttons: arg2 value hand: self activeHand stamp: Time millisecondClockValue) ]contentMorph  ^contentMorphselectionModeStrategy  ^selectionModeStrategyasPotentialDropTarget  isPotentialDropTarget := true.  self container invalidRect: self visibleBoundscrAction: arg1  ^self setProperty: #crAction toValue: arg1existingPaneColor  | tmp1 |  tmp1 := self valueOfProperty: #paneColor.  tmp1 ifNil: [ self setProperty: #paneColor toValue: (tmp1 := self paneColor) ].  ^tmp1embeddable  ^embeddable ifNil: [ embeddable := false ]onImage  | tmp1 tmp2 |  tmp1 := CheckboxButtonMorph new     privateOwner: self owner;     adoptPaneColor: self paneColor;     selected: true.  tmp2 := Form extent: tmp1 extent depth: 32.  tmp2 fillColor: (Color white alpha: 0.003922).  tmp2 getCanvas fullDrawMorph: tmp1.  ^tmp2duplicate  | tmp1 tmp2 |  (tmp2 := self topRendererOrSelf) ~~ self ifTrue: [ ^tmp2 duplicate ].  tmp1 := self veryDeepCopy.  tmp1 arrangeToStartStepping.  tmp1 privateOwner: nil.  ^tmp1privateColor: arg1  color := arg1isSelected: arg1  isSelected := arg1.  self changedaddPaneHSplitterBetween: arg1 and: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 |  arg1 ifEmpty: [ ^self ].  tmp1 := arg1 first layoutFrame bottomFraction.  tmp2 := arg1 select: [:arg3 |  arg3 layoutFrame topFraction = arg3 layoutFrame bottomFraction ].  tmp6 := ((arg1 reject: [:arg3 |  arg3 layoutFrame topFraction = arg3 layoutFrame bottomFraction ]) asSortedCollection: [:arg4 :arg5 |  arg4 layoutFrame rightFraction = arg5 layoutFrame rightFraction ifTrue: [ arg4 layoutFrame leftFraction <= arg5 layoutFrame leftFraction ] ifFalse: [ arg4 layoutFrame rightFraction <= arg5 layoutFrame rightFraction ] ]) readStream.  tmp6 contents ifEmpty: [ ^tmp2 ].  tmp8 := OrderedCollection new.  tmp3 := tmp6 contents first layoutFrame leftFraction.  [ tmp6 atEnd or: [ tmp7 := tmp6 next.        tmp7 layoutFrame leftFraction ~= tmp3 and: [ tmp7 layoutFrame rightFraction ~= tmp3 ] ] ] whileFalse: [ tmp8 add: tmp7.        tmp3 := tmp7 layoutFrame rightFraction ].  tmp4 := tmp8 first layoutFrame.  tmp5 := tmp8 last layoutFrame.  tmp9 := (arg2 reject: [:arg3 |  arg3 layoutFrame topFraction = arg3 layoutFrame bottomFraction ]) select: [:arg3 |  (arg3 layoutFrame leftFraction between: tmp4 leftFraction and: tmp5 rightFraction) or: [ arg3 layoutFrame rightFraction between: tmp4 leftFraction and: tmp5 rightFraction ] ].  tmp11 := (tmp8 collect: [:arg3 |  arg3 layoutFrame bottomOffset ]) max.  tmp10 := ProportionalSplitterMorph new beSplitsTopAndBottom.  tmp10 layoutFrame: ((tmp4 leftFraction @ tmp1 corner: tmp5 rightFraction @ tmp1) asLayoutFrame           leftOffset: tmp4 leftOffset;           topOffset: tmp11;           rightOffset: tmp5 rightOffset;           bottomOffset: 4 + tmp11).  tmp8 := tmp8 , tmp2.  tmp8 do: [:arg3 |  tmp10 addLeftOrTop: arg3 ].  tmp9 do: [:arg3 |  tmp10 addRightOrBottom: arg3 ].  self addMorphBack: tmp10.  ^tmp8forceDamageToScreen: arg1  asFlexOf: arg1  | tmp1 |  tmp1 := arg1 position.  self addMorph: arg1.  arg1 position: (arg1 extent // 2) negated.  self position: tmp1.  transform := transform withOffset: arg1 position - tmp1image: arg1  image := arg1 depth = 1 ifTrue: [ ColorForm mappingWhiteToTransparentFrom: arg1 ] ifFalse: [ arg1 ].  self extent: 2 * self borderWidth + image extent min asPoint.  self changedimageForm: arg1 backgroundColor: arg2 forRectangle: arg3  | tmp1 |  tmp1 := Display defaultCanvasClass extent: arg3 extent depth: arg1.  tmp1 translateBy: arg3 topLeft negated during: [:arg4 |  arg4 fillRectangle: arg3 color: arg2.        arg4 fullDrawMorph: self ].  ^tmp1 form offset: arg3 topLeftpasteBuffer: arg1  PasteBuffer := arg1drawOnAthensCanvas: arg1  arg1 setPaint: (InfiniteForm with: self hatchForm).  arg1 drawShape: self innerBounds.  super drawOnAthensCanvas: arg1labelGraphic: arg1  minimumWidth  ^3selectedMouseOverBorderStyle  ^self theme taskbarItemSelectedMouseOverBorderStyleFor: selfselectedColor: arg1  self hue: arg1 hue / 360.  self svMorph selectedColor: arg1newExpander: arg1  ^self theme newExpanderIn: self label: arg1 forAll: #()athensDrawBackgroundForSelectedRow: arg1 on: arg2  arg2 setPaint: listSource selectionColorToUse.  arg2 drawShape: (self selectionFrameForRow: arg1)chooseForSaveFileReference: arg1 extensions: arg2 path: arg3 preview: arg4  ^self theme chooseForSaveFileReferenceIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4displayExtraSelectionOn: arg1  | tmp1 tmp2 |  tmp1 := arg1 clipRect.  refreshExtraSelection = true ifTrue: [ self buildSelectionBlocksFrom: tmp1 topLeft to: tmp1 bottomRight.        refreshExtraSelection := false ].  extraSelectionBlocks ifNotNil: [ (self lineIndexForPoint: tmp1 topLeft) to: (self lineIndexForPoint: tmp1 bottomRight) do: [:arg2 |  tmp2 := lines at: arg2.              extraSelectionBlocks do: [:arg3 |  self displaySelectionBlock: arg3 inLine: tmp2 on: arg1 ] ] ]isLabelled  ^falsebuttonClickedForTaskList: arg1  arg1 taskClicked: selfadjustedCenter  ^(self vertices last: 4) average roundedinitialize  super initialize.  self disableSortsecondSelection: arg1  | tmp1 |  tmp1 := self allNodeMorphs detect: [:arg2 |  arg2 complexContents item == arg1 ].  self searchedElement: tmp1.  client changedhandleInteraction: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self editor.  tmp2 := paragraph.  tmp3 := tmp2 text copy.  self selectionChanged.  arg1 value.  tmp2 == paragraph ifTrue: [ editor := tmp1 ].  self selectionChanged.  (tmp3 = paragraph text and: [ tmp3 runs = paragraph text runs ]) ifFalse: [ self updateFromParagraph ]isMainWorld  ^World == selfapply: arg1  | tmp1 |  tmp1 := target bounds.  target bounds: (tmp1 origin + arg1 corner: tmp1 corner)contentsMenuTitle  ^'Contents' translatedtopInactiveGap  ^5addActionsFor: arg1  | tmp1 |  arg1 ifNil: [ ^self ].  tmp1 := self actionOffset.  arg1 hasMenu ifTrue: [ tmp1 := 2 * tmp1 + self menuButtonWidth.        self addMenuButton ].  arg1 actions reverseDo: [:arg2 |  | tmp2 |        tmp2 := (self height - arg2 icon height) // 2.        self addMorph: (self createActionButtonFor: arg2) fullFrame: (LayoutFrame identity                 bottomFraction: 0;                 leftFraction: 1;                 topOffset: tmp2;                 bottomOffset: tmp2 + arg2 icon height;                 rightOffset: tmp1 negated;                 leftOffset: tmp1 negated - arg2 icon width).        tmp1 := tmp1 + arg2 icon width + self actionOffset ]selectedNodes  ^OrderedCollection withAll: self selectedNodeListlineColor: arg1  lineColorBlock := [:arg2 |  arg1 ]newMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil help: arg5vScrollbarNeeded  self vScrollbar showsAlways ifTrue: [ ^true ].  self vScrollbar showsNever ifTrue: [ ^false ].  ^self scrollTarget height + (self scrollTarget width > self innerBounds width ifTrue: [ self scrollBarThickness ] ifFalse: [ 0 ]) > self innerBounds heightaddInitialPanel  self addMainPanelmultiSelection: arg1  self listManager multipleSelection: arg1defaultCharacterBlock  ^(CharacterBlock new stringIndex: firstCharacterIndex text: text topLeft: lines first topLeft extent: 0 @ 0) textLine: lines firstsentTo: arg1  ^arg1 handleDropMorph: selfdefaultBorderWidth  ^1frameRectangle7: arg1 on: arg2  | tmp1 |  tmp1 := arg1 insetBy: self width // 2.  self width odd ifTrue: [ tmp1 := tmp1 insetBy: (0 @ 0 corner: 1 @ 1) ].  arg2     line: tmp1 topLeft + (7 @ 0) to: tmp1 topRight - (7 @ 0) width: self width color: self color;     line: tmp1 topRight + (-6 @ 1) to: tmp1 topRight + (-5 @ 1) width: self width color: self color;     line: tmp1 topRight + (-4 @ 2) to: tmp1 topRight + (-2 @ 4) width: self width color: self color;     line: tmp1 topRight + (-1 @ 5) to: tmp1 topRight + (-1 @ 6) width: self width color: self color;     line: tmp1 topRight + (0 @ 7) to: tmp1 bottomRight - (0 @ 7) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 6) to: tmp1 bottomRight - (1 @ 5) width: self width color: self color;     line: tmp1 bottomRight - (2 @ 4) to: tmp1 bottomRight - (4 @ 2) width: self width color: self color;     line: tmp1 bottomRight - (5 @ 1) to: tmp1 bottomRight - (6 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (7 @ 0) to: tmp1 bottomLeft + (7 @ 0) width: self width color: self color;     line: tmp1 bottomLeft - (-6 @ 1) to: tmp1 bottomLeft - (-5 @ 1) width: self width color: self color;     line: tmp1 bottomLeft - (-4 @ 2) to: tmp1 bottomLeft - (-2 @ 4) width: self width color: self color;     line: tmp1 bottomLeft - (-1 @ 5) to: tmp1 bottomLeft - (-1 @ 6) width: self width color: self color;     line: tmp1 bottomLeft - (0 @ 7) to: tmp1 topLeft + (0 @ 7) width: self width color: self color;     line: tmp1 topLeft + (1 @ 6) to: tmp1 topLeft + (1 @ 5) width: self width color: self color;     line: tmp1 topLeft + (2 @ 4) to: tmp1 topLeft + (4 @ 2) width: self width color: self color;     line: tmp1 topLeft + (5 @ 1) to: tmp1 topLeft + (6 @ 1) width: self width color: self colornormalFillStyle  ^self theme taskbarItemNormalFillStyleFor: selfmouseLeave: arg1  super mouseLeave: arg1.  self over: falsetestSortDataSource  | tmp1 |  tmp1 := self dataSourceForTesting.  strategy property: #yourself.  self assert: tmp1 elements equals: self elementsForTestDataSource.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(10 9 8 7 6 5 4 3 2 1).  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: self elementsForTestDataSourcekeyStrokeModifierAction: arg1  | tmp1 tmp2 |  tmp2 := arg1 keyCharacter.  tmp1 := self keystrokeActionSelector numArgs.  tmp1 = 1 ifTrue: [ ^self model perform: self keystrokeActionSelector with: tmp2 ].  tmp1 = 2 ifTrue: [ ^self model perform: self keystrokeActionSelector with: tmp2 with: self ].  ^self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'cellColumn: arg1 row: arg2  ^FTCellMorph new     addMorphBack: (self elementAt: arg2) asMorph;     yourselfhandleMouseMove: arg1  arg1 wasHandled ifTrue: [ ^self ].  (arg1 isDraggingEvent or: [ arg1 anyButtonPressed and: [ arg1 hand mouseFocus == self ] ]) ifFalse: [ ^self ].  arg1 wasHandled: true.  self mouseMove: arg1.  (self handlesMouseStillDown: arg1) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue + self mouseStillDownThreshold arguments: {arg1 copy resetHandlerFields} stepTime: self mouseStillDownStepRate ]setModal: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self activeHand keyboardFocus.  tmp2 := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  tmp2 ifNil: [ tmp2 := self ].  tmp2 modalLockTo: arg1.  tmp1 := RealEstateAgent maximumUsableArea.  arg1 extent: arg1 initialExtent.  arg1 position = (0 @ 0) ifTrue: [ arg1 position: self activeHand position - (arg1 extent // 2) ].  arg1 bounds: (arg1 bounds translatedToBeWithin: tmp1).  [ | tmp4 |  tmp4 := arg1.  [ tmp4 world notNil ] whileTrue: [ tmp4 outermostWorldMorph doOneCycle ] ] ensure: [ tmp2 modalUnlockFrom: arg1.        self activeHand newKeyboardFocus: tmp3 ].  ^arg1taskbarThumbnailExtent  ^self extent min: self defaultTaskbarThumbnailExtentgetMenu: arg1  | tmp1 tmp2 tmp3 |  self getMenuSelector == nil ifTrue: [ ^nil ].  tmp1 := UIManager default newMenuIn: self for: self model.  tmp3 := getMenuTitleSelector ifNotNil: [ self model perform: getMenuTitleSelector ].  self getMenuSelector numArgs = 1 ifTrue: [ tmp2 := self model perform: self getMenuSelector with: tmp1.        tmp3 ifNotNil: [ tmp2 addTitle: tmp3 ].        ^tmp2 ].  self getMenuSelector numArgs = 2 ifTrue: [ tmp2 := self model perform: self getMenuSelector with: tmp1 with: arg1.        tmp3 ifNotNil: [ tmp2 addTitle: tmp3 ].        ^tmp2 ].  ^self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'openInWindow  ^self openInWindowLabeled: self defaultLabelcolor: arg1  color := arg1contents: arg1 withMarkers: arg2 inverse: arg3  | tmp1 tmp2 |  self contentString: nil.  arg2 ifFalse: [ ^super contents: arg1 ].  self removeAllMorphs.  self hasIcon ifTrue: [ self icon: nil ].  self flag: #pharoFixMe.  (arg1 isKindOf: Association) ifTrue: [ super contents: arg1 value.        tmp2 := arg1 key ifTrue: [ self onImage ] ifFalse: [ self offImage ] ] ifFalse: [ (arg1 notEmpty and: [ arg1 first = $< ]) ifFalse: [ ^super contents: arg1 ].        tmp1 := arg1 indexOf: $>.        tmp1 = 0 ifTrue: [ ^super contents: arg1 ].        tmp2 := (arg1 copyFrom: 1 to: tmp1) asLowercase.        (#('<on>' '<off>' '<yes>' '<no>') includes: tmp2) ifFalse: [ ^super contents: arg1 ].        self contentString: arg1.        tmp2 := (tmp2 = '<on>' or: [ tmp2 = '<yes>' ]) ~= arg3 ifTrue: [ self onImage ] ifFalse: [ self offImage ].        super contents: (arg1 copyFrom: tmp1 + 1 to: arg1 size) ].  tmp2 := ImageMorph new form: tmp2.  tmp2 position: self left @ (self top + 2).  self addMorphFront: tmp2borderStyleToUse  ^self enabled ifTrue: [ self theme listNormalBorderStyleFor: self ] ifFalse: [ self theme listDisabledBorderStyleFor: self ]scrollDelta  ^scrollDeltadrawOnAthensCanvas: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := (self keyText substrings: '+') collect: #trimBoth.  ((tmp1 includes: 'Shift') and: [ (tmp1 first = 'Shift') not ]) ifTrue: [ tmp1 := (tmp1 copyWithout: 'Shift') copyWithFirst: 'Shift' ].  tmp5 := self class symbolFont.  tmp2 := tmp1 inject: Text new into: [:arg2 :arg3 |  arg2 , (self class symbolTableAt: arg3 ifAbsent: [ arg3 capitalized ]) ].  tmp4 := self boundsForKeyText: tmp2 string font: tmp5.  tmp3 := Paragraph new     compose: tmp2 style: (TextStyle fontArray: {tmp5}) from: 1 in: (0 @ 0 corner: tmp4 corner);     yourself.  arg1 asCanvasWrapper paragraph: tmp3 bounds: tmp4 color: self colorupdate: arg1  super update: arg1.  arg1 == self getEnabledSelector ifTrue: [ self updateEnabled.        ^self ]mouseLeave: arg1  self setProperty: #mouseEntered toValue: false.  self changed.  self color: (self color adjustBrightness: 0.09375).  super mouseLeave: arg1menuBox  ^menuBoxremoveFromSelection  self triggerEvent: #tabRemovedFromSelection with: selfisMove  ^trueextent: arg1  super extent: arg1.  self listMorph width: (self width max: listMorph hUnadjustedScrollRange) + 20isRowIndexVisible: arg1  self deprecated: 'Use #isIndexVisible: instead' transformWith: '`@receiver isRowIndexVisible: `@statements1' -> '`@receiver isIndexVisible: `@statements1'.  ^self isIndexVisible: arg1listOfSteppingMorphs  ^worldState listOfSteppingMorphsoverlap  ^8 * self displayScaleFactornumberOfItemsPotentiallyInView  ^self numberOfItemsPotentiallyInViewWith: self submorphCountinactiveFillStyle  ^self theme dialogWindowInactiveFillStyleFor: selfleftOffset  ^leftOffsetdrawOnAthensCanvas: arg1 bounds: arg2  navigationKey: arg1  arg1 isUserInterrupt ifTrue: [ ^true ].  (arg1 keyCharacter = Character escape and: [ arg1 anyModifierKeyPressed ]) ifTrue: [ ^self yellowButtonActivity: false ].  self window ifNotNil: [:arg2 |  (arg2 handlesKeyStroke: arg1) ifTrue: [ (arg2 keyStroke: arg1) ifTrue: [ ^true ] ] ].  ^falsevalidateSelector: arg1  (arg1 numArgs between: 0 and: 2) ifFalse: [ ^self error: 'Invalid pluggable selector' ]firstInChain  | tmp1 |  tmp1 := self.  [ tmp1 predecessor isNil ] whileFalse: [ tmp1 := tmp1 predecessor ].  ^tmp1pressed: arg1  self owner pressed: arg1multiSelection: arg1  multiSelection := arg1headerButtonLabel: arg1 font: arg2 icon: arg3 target: arg4 actionSelector: arg5 arguments: arg6  self headerButton.  self header label: arg1 font: arg2.  self header icon: (ImageMorph new form: arg3).  self header actionSelector: arg5.  self header target: arg4.  self header arguments: arg6newColor  ^newColortestIsAboveRow  self subclassResponsibilityadoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self color: (self preferedPaneColor ifNil: [ self theme backgroundColor ])adjustBorderUponActivationWhenLabeless  | tmp1 |  (tmp1 := self valueOfProperty: #borderWidthWhenActive) ifNotNil: [ self acquireBorderWidth: tmp1 ]borderWidthForRounding  ^self borderWidthtransformedBy: arg1  ^self shallowCopy transformBy: arg1handlesKeyboard: arg1  ^truelastSubmorphRecursive  ^self hasSubmorphs ifTrue: [ self lastSubmorph lastSubmorphRecursive ] ifFalse: [ self ]isWindowActive: arg1  ^self currentWindow == arg1selectLastMatch: arg1  | tmp1 |  self items reverseDo: [:arg2 |  | tmp2 |        tmp2 := arg1 isEmpty or: [ arg2 contents asString asLowercase includesSubstring: arg1 ].        arg2 isEnabled: tmp2.        (tmp2 and: [ tmp1 isNil ]) ifTrue: [ tmp1 := arg2 ] ].  ^tmp1getListSize  getListSizeSelector ifNotNil: [ ^model perform: getListSizeSelector ].  ^self getList sizemorphicLayerNumber  ^1basicDrawOn: arg1  | tmp1 tmp2 |  tmp1 := self stringColorToUse.  tmp2 := self stringBoundsToUse.  (self isSelected and: [ self isEnabled ]) ifTrue: [ arg1 fillRectangle: self bounds fillStyle: self selectionFillStyle borderStyle: self selectionBorderStyle ].  self hasIcon ifTrue: [ | tmp3 |        tmp3 := self icon.        self drawIcon: tmp3 on: arg1 in: tmp2.        tmp2 := tmp2 left: tmp2 left + tmp3 width + (2 * self displayScaleFactor) ].  self hasMarker ifTrue: [ tmp2 := tmp2 left: tmp2 left + self submorphBounds width + (8 * self displayScaleFactor) ].  tmp2 := tmp2 top: (tmp2 top + tmp2 bottom - self fontToUse height) // 2.  tmp2 := tmp2 bottom: tmp2 top + self fontToUse height.  self drawText: contents on: arg1 in: tmp2.  self hasSubMenu ifTrue: [ | tmp4 |        tmp4 := self subMenuMarker deepCopy mapColor: Color black to: tmp1.        self drawSubMenuMarker: tmp4 on: arg1 in: tmp2 ]repelsMorph: arg1 event: arg2  ^falsehandleInteraction: arg1  self editor model: editView model.  ^super handleInteraction: arg1addTableLayoutMenuItems: arg1 hand: arg2  | tmp1 tmp2 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 addUpdating: #hasReverseCellsString selector: #changeReverseCells.  tmp1 addUpdating: #hasClipLayoutCellsString selector: #changeClipLayoutCells.  tmp1 addUpdating: #hasRubberBandCellsString selector: #changeRubberBandCells.  tmp1 addLine.  tmp1 add: 'change cell inset...' selector: #changeCellInset:.  tmp1 add: 'change min cell size...' selector: #changeMinCellSize:.  tmp1 add: 'change max cell size...' selector: #changeMaxCellSize:.  tmp1 addLine.  tmp2 := UIManager default newMenuIn: self for: self.  #(#leftToRight #rightToLeft #topToBottom #bottomToTop) do: [:arg3 |  tmp2 addUpdating: #listDirectionString: target: self selector: #changeListDirection: argumentList: (Array with: arg3) ].  tmp1 add: 'list direction' subMenu: tmp2.  tmp2 := UIManager default newMenuIn: self for: self.  #(#none #leftToRight #rightToLeft #topToBottom #bottomToTop) do: [:arg3 |  tmp2 addUpdating: #wrapDirectionString: target: self selector: #wrapDirection: argumentList: (Array with: arg3) ].  tmp1 add: 'wrap direction' subMenu: tmp2.  tmp2 := UIManager default newMenuIn: self for: self.  #(#center #topLeft #topRight #bottomLeft #bottomRight #topCenter #leftCenter #rightCenter #bottomCenter) do: [:arg3 |  tmp2 addUpdating: #cellPositioningString: target: self selector: #cellPositioning: argumentList: (Array with: arg3) ].  tmp1 add: 'cell positioning' subMenu: tmp2.  tmp2 := UIManager default newMenuIn: self for: self.  #(#topLeft #bottomRight #center #justified) do: [:arg3 |  tmp2 addUpdating: #listCenteringString: target: self selector: #listCentering: argumentList: (Array with: arg3) ].  tmp1 add: 'list centering' subMenu: tmp2.  tmp2 := UIManager default newMenuIn: self for: self.  #(#topLeft #bottomRight #center #justified) do: [:arg3 |  tmp2 addUpdating: #wrapCenteringString: target: self selector: #wrapCentering: argumentList: (Array with: arg3) ].  tmp1 add: 'wrap centering' subMenu: tmp2.  tmp2 := UIManager default newMenuIn: self for: self.  #(#none #equal) do: [:arg3 |  tmp2 addUpdating: #listSpacingString: target: self selector: #listSpacing: argumentList: (Array with: arg3) ].  tmp1 add: 'list spacing' subMenu: tmp2.  tmp2 := UIManager default newMenuIn: self for: self.  #(#none #localRect #localSquare #globalRect #globalSquare) do: [:arg3 |  tmp2 addUpdating: #cellSpacingString: target: self selector: #cellSpacing: argumentList: (Array with: arg3) ].  tmp1 add: 'cell spacing' subMenu: tmp2.  arg1 ifNotNil: [ arg1 add: 'table layout' subMenu: tmp1 ].  ^tmp1separatorSize  ^separatorSize ifNil: [ separatorSize := 1 ]lineColor: arg1  self borderColor: arg1handlesMouseOverDragging: arg1  ^truenewColorChooserFor: arg1 getColor: arg2 setColor: arg3 help: arg4  ^self theme newColorChooserIn: self for: arg1 getColor: arg2 setColor: arg3 getEnabled: nil help: arg4center  ^bounds centerdecrement  self value: self value - 1viewBox  ^Display boundingBoxbottomRight: arg1  self position: (arg1 x - bounds width) @ (arg1 y - self height)initializeFrom: arg1  self hResizing: arg1 hResizing.  self vResizing: arg1 vResizing.  self disableTableLayout: arg1 disableTableLayoutvisibleRowMorphAtIndex: arg1  ^container visibleRowMorphAtIndex: arg1newMainPanel  ^self newDialogPanel     addMorphBack: self newContentMorph;     addMorphBack: self newButtonRow;     yourselfdisplay: arg1 atRow: arg2 on: arg3  | tmp1 tmp2 |  tmp2 := self backgroundColorForRow: arg2.  tmp1 := self drawBoundsForRow: arg2.  tmp1 := tmp1 intersect: self bounds ifNone: [ ^self ].  arg1 with: (1 to: arg1 size) do: [:arg4 :arg5 |  arg5 > 1 ifTrue: [ tmp1 := tmp1 left: tmp1 left + listSource gapSize + (columnWidths at: arg5 - 1) ].        arg4 listRenderOn: arg3 atRow: arg2 bounds: tmp1 color: color backgroundColor: tmp2 from: self ]drawOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  self shouldDraw ifFalse: [ ^self ].  tmp3 := SystemWindow borderWidth.  tmp2 := arg1 asAlphaBlendingCanvas: 0.7.  tmp1 := self bounds.  tmp4 := tmp1 right: tmp1 left + tmp3.  tmp4 := tmp4 bottom: tmp4 top + tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp1 left: tmp1 left + tmp3.  tmp4 := tmp4 bottom: tmp4 top + tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp4 left: tmp4 left + 7.  tmp4 := tmp4 right: tmp4 right - 7.  tmp2 fillRectangle: tmp4 color: self dotColor.  tmp4 := tmp1 right: tmp1 left + tmp3.  tmp4 := tmp4 top: tmp4 top + tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp4 top: tmp4 top + 7.  tmp4 := tmp4 bottom: tmp4 bottom - 7.  tmp2 fillRectangle: tmp4 color: self dotColorselectedFillStyle  ^self theme taskbarItemSelectedFillStyleFor: selfbuildPanel  self subclassResponsibilitymouseMove: arg1  self isMultipleSelection ifTrue: [ self mouseMoveOnMultiple: arg1 ] ifFalse: [ self mouseMoveOnSingle: arg1 ]displayOn: arg1 using: arg2 at: arg3  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 clipRect.  tmp2 := (arg3 - positionWhenComposed) truncated.  tmp3 := 0.  (self lineIndexForPoint: tmp1 topLeft) to: (self lineIndexForPoint: tmp1 bottomRight) do: [:arg4 |  tmp4 := lines at: arg4.        self displaySelectionInLine: tmp4 on: arg1.        tmp4 first <= tmp4 last ifTrue: [ tmp3 := arg2 displayLine: tmp4 offset: tmp2 leftInRun: tmp3 ] ]isCheckList  ^isCheckList ifNil: [ isCheckList := false ]drawLineToggleToTextOn: arg1 lineColor: arg2 hasToggle: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self isSoleItem ifTrue: [ ^self ].  self hasToggle ifTrue: [ ^self ].  tmp1 := self toggleBounds.  tmp2 := tmp1 center.  tmp3 := tmp2 y - 1.  tmp4 := tmp2 x.  tmp5 := self theme.  arg1 frameRectangle: (tmp4 @ tmp3 corner: (tmp1 right + 3) @ (tmp3 + 1)) width: tmp5 treeLineWidth colors: (tmp5 treeLineColorsFrom: arg2) dashes: tmp5 treeLineDashessetDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedposition: arg1  (self positions includes: arg1) ifFalse: [ self error ].  position := arg1restoreBeforeGeneratingThumbnail  self isMinimized ifFalse: [ ^self ].  isCollapsed := false.  self show.  self setBoundsWithFlex: fullFrame.  paneMorphs reverseDo: [:arg1 |  self addMorph: arg1 ].  self layoutChangedkeyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self focusChangedsetValueSelector  ^setValueSelectorselectedNodePath  ^self selection ifNotNil: [:arg1 |  arg1 lastSelectedNodePath ]chooseColor  ^self chooseColor: Color blackprintOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     print: receiver;     space;     print: selector;     space;     print: scheduledTime;     nextPut: $)testMorphInline  | tmp1 tmp2 |  tmp1 := 'Hello ' asText , Morph new asText , ' world' asText.  tmp2 := tmp1 attributesAt: 7.  self assert: (tmp2 first isKindOf: TextAnchor)dropEnabled  ^(self valueOfProperty: #dropEnabled) ~~ falseparagraph  ^super paragraph     selectionColor: self selectionColor;     yourselfmouseEnter: arg1  owner ifNotNil: [ owner stayUp ifFalse: [ self mouseEnterDragging: arg1 ] ].  (owner selectedItem notNil and: [ owner selectedItem ~~ self ]) ifTrue: [ owner selectItem: self event: arg1 ]rotationDegrees: arg1  minHeight  ^owner isVertical ifTrue: [ self theme menuBorderWidth ] ifFalse: [ 10 ]updateColumnMorphsWidthWith: arg1  | tmp1 |  (container columns isEmpty or: [ self hasSubmorphs not ]) ifTrue: [ ^self ].  tmp1 := self spacerWidth.  1 to: arg1 size - 1 do: [:arg2 |  | tmp2 |        tmp2 := arg1 at: arg2.        (controls at: arg2) width: tmp2 - (arg2 = 1 ifTrue: [ tmp1 ] ifFalse: [ 0 ]) ]mouseMove: arg1  self isFullscreen ifTrue: [ ^self ].  ^super mouseMove: arg1enabledFromModel  | tmp1 |  self model ifNil: [ ^self ].  tmp1 := self model enabled.  tmp1 ~= self enabled ifTrue: [ self enabled: tmp1 ]wantsSteps  super wantsSteps ifTrue: [ ^true ].  ^self isAnimatednewDialogPanel  ^self theme newDialogPanelIn: selfselectableIndexAbove: arg1  ^{(arg1 first - 1) .   arg1 second}forceDamageToScreen: arg1  ^Display forceDamageToScreen: arg1fillStyle: arg1  arg1 isColor ifTrue: [ self color: arg1 ] ifFalse: [ super fillStyle: arg1 ]release  traceMorph := nil.  oldColor := nil.  container := nil.  self releaseActionMap.  super releasecellMorphFor: arg1  | tmp1 |  tmp1 := FTIndentedCellMorph new.  tmp1 depthIndent: depth.  self hasChildren ifTrue: [ tmp1 addMorphBack: self generateButton ] ifFalse: [ tmp1 addIndendtation: 15 ].  dataSource displayBlock value: item value: tmp1.  ^tmp1vertices: arg1 color: arg2 borderWidth: arg3 borderColor: arg4  super initialize.  vertices := arg1.  color := arg2.  borderWidth := arg3.  borderColor := arg4.  closed := vertices size > 2.  arrows := #none.  self computeBoundscopyToPasteBuffer: arg1  ^arg1 hand copyToPasteBuffer: selfextraBorder  ^6setOptimalResizingStrategyAndReturnOldOne  | tmp1 tmp2 tmp3 |  tmp1 := self hResizing.  tmp2 := self vResizing.  self setOptimalResizing.  tmp3 := self submorphs collect: [:arg1 |  arg1 setOptimalResizingStrategyAndReturnOldOne ].  ^{tmp1 .   tmp2 .   tmp3}tabSelectorMorph: arg1  tabSelectorMorph := arg1adhereToRight  self adhereTo: #rightsliderColor: arg1  super sliderColor: arg1.  slider ifNotNil: [ slider borderStyle baseColor: arg1 ]getListItem: arg1  | tmp1 |  getListElementSelector ifNotNil: [ ^self wrapItem: (model perform: getListElementSelector with: arg1) index: arg1 ].  list ifNotNil: [ ^list at: arg1 ].  tmp1 := self getList at: arg1.  ^self wrapItem: tmp1 index: arg1result: arg1 from: arg2  toggleExpandedState: arg1  arg1 toggleExpandedState.  self adjustSubmorphPositionsactive  active ifNil: [ active := false ].  ^activemaybeDismiss: arg1 with: arg2  | tmp1 |  arg1 hand obtainHalo: self.  (arg2 containsPoint: arg1 cursorPoint) ifTrue: [ target resistsRemoval ifTrue: [ tmp1 := self confirm: 'Really throw this away?' translated.              tmp1 ifFalse: [ ^self ] ].        arg1 hand removeHalo.        self delete.        target dismissViaHalo ] ifFalse: [ self delete.        target addHalo: arg1 ]multiComposeLinesFrom: arg1 to: arg2 delta: arg3 into: arg4 priorLines: arg5 atY: arg6 textStyle: arg7 text: arg8 container: arg9 wantsColumnBreaks: arg10  wantsColumnBreaks := arg10.  lines := arg4.  theTextStyle := arg7.  theText := arg8.  theContainer := arg9.  deltaCharIndex := arg3.  currCharIndex := startCharIndex := arg1.  stopCharIndex := arg2.  prevLines := arg5.  currentY := arg6.  defaultLineHeight := theTextStyle lineGrid.  maxRightX := theContainer left.  possibleSlide := stopCharIndex < theText size and: [ theContainer isMemberOf: Rectangle ].  nowSliding := false.  prevIndex := 1.  scanner := CompositionScanner new text: theText textStyle: theTextStyle.  scanner wantsColumnBreaks: wantsColumnBreaks.  isFirstLine := true.  self composeAllLines.  isFirstLine ifTrue: [ self addNullLineWithIndex: startCharIndex andRectangle: (theContainer topLeft extent: 0 @ defaultLineHeight) ] ifFalse: [ self fixupLastLineIfCR ].  ^{lines asArray .   maxRightX}testIsSortEnabled  column disableSort.  self deny: column isSortEnabled.  column sortableOnProperty: #name.  self assert: column isSortEnabledspotterForSubmorphsFor: arg1  < spotterOrder: 10>  self submorphs ifNil: [ ^self ].  arg1 listProcessor     title: 'Submorphs';     allCandidates: [ self submorphs ];     candidatesLimit: 5;     filter: GTFilterSubstringaboutToBeGrabbedBy: arg1  | tmp1 tmp2 |  (owner notNil and: [ owner hasSubmorphs ]) ifTrue: [ owner stayUp: true.        ^owner aboutToBeGrabbedBy: arg1 ].  tmp2 := self bounds.  tmp1 := UIManager default newMenuIn: self for: nil.  tmp1 addMorphFront: self.  tmp1 bounds: tmp2.  tmp1 stayUp: true.  self isSelected: false.  ^tmp1married  ^self item marriedshedSelvedge  self extent: self extent - (6 @ 6)copyToPasteBuffer: arg1  arg1 ifNil: [ ^PasteBuffer := nil ].  Cursor wait showWhile: [ PasteBuffer := arg1 topRendererOrSelf veryDeepCopy.        PasteBuffer privateOwner: nil ]isComposite  ^falsestate  ^statequestion: arg1 title: arg2  ^self theme questionIn: self text: arg1 title: arg2changed: arg1 with: arg2  self doAnnounce: (MorphChangedWithArguments new           morph: self;           selector: arg1;           arguments: arg2)click: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #click from: arg2testExecuteSortingOn  self subclassResponsibilitynewListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 help: arg5  ^self newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: nil help: arg5newControls  ^{self newLeftButton .   self newRightButton}onChoiceSend: arg1 to: arg2  self announcer when: ChoseDate send: arg1 to: arg2chooseForSaveFileReference: arg1 extensions: arg2 path: arg3  ^self chooseForSaveFileReference: arg1 extensions: arg2 path: arg3 preview: nilnewString: arg1 font: arg2 style: arg3  ^self theme newStringIn: self label: arg1 font: arg2 style: arg3browseItem  Smalltalk tools browser openOnClass: self iteminteractionState: arg1  self submorphsDo: [:arg2 |  (arg2 respondsTo: #interactionState:) ifTrue: [ arg2 interactionState: arg1 ] ]getStateSelector  ^getStateSelectorlocalVisibleSubmorphBounds  | tmp1 |  tmp1 := nil.  self submorphsDo: [:arg1 |  arg1 visible ifTrue: [ tmp1 ifNil: [ tmp1 := arg1 fullBounds copy ] ifNotNil: [ tmp1 := tmp1 quickMerge: arg1 fullBounds ] ] ].  ^tmp1indexOfChangedItem  1 to: self numberOfRows do: [:arg1 |  (self elementAt: arg1) recentlyChanged ifTrue: [ ^arg1 ] ].  ^self errorSubscriptBounds: self numberOfRows + 1wantsDropSelector: arg1  wantsDropSelector := arg1printOn: arg1  super printOn: arg1.  arg1     nextPutAll: ' (';     print: addHandleSelector;     space;     print: iconSymbol;     nextPut: $)newCancelButton  ^self newCancelButtonFor: selfasShortcut  ^self asKeyCombinationcellColumn: arg1 row: arg2  self subclassResponsibilitydeleteCloseBox  closeBox ifNotNil: [ closeBox delete.        closeBox := nil ]angle: arg1  self changed.  transform := transform withAngle: arg1.  self layoutChanged.  self changedmouseEnter: arg1 from: arg2  counter := counter + 1themeChanged  self color: self defaultColor.  super themeChangedhandlesMouseWheel: arg1  ^trueaddEmbeddingMenuItemsTo: arg1 hand: arg2  | tmp1 tmp2 |  tmp2 := self potentialEmbeddingTargets.  tmp2 size > 1 ifFalse: [ ^self ].  tmp1 := UIManager default newMenuIn: self for: self.  tmp2 reverseDo: [:arg3 |  tmp1 add: arg3 class name asString target: arg3 selector: #addMorphFrontFromWorldPosition: argument: self topRendererOrSelf.        tmp1 lastItem icon: (arg3 iconOrThumbnailOfSize: 16).        self owner == arg3 ifTrue: [ tmp1 lastItem emphasis: 1 ] ].  arg1 add: 'embed into' subMenu: tmp1.  ^tmp1on: arg1 list: arg2 selected: arg3 changeSelected: arg4 menu: arg5 keystroke: arg6 wrapSelector: arg7  self model: arg1.  self getListSelector: arg2.  self getIndexSelector: arg3.  self setIndexSelector: arg4.  self getMenuSelector: arg5.  self keystrokeActionSelector: arg6.  self basicWrapSelector: arg7extent: arg1  | tmp1 |  tmp1 := self extent.  super extent: arg1.  self isHorizontal ifTrue: [ self extent y ~= tmp1 y ifTrue: [ self adoptPaneColor: self paneColor ] ] ifFalse: [ self extent x ~= tmp1 x ifTrue: [ self adoptPaneColor: self paneColor ] ]moveBy: arg1  left := left + arg1 x.  right := right + arg1 x.  top := top + arg1 y.  bottom := bottom + arg1 yrubberBandCells  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ false ] ifNotNil: [ tmp1 rubberBandCells ]defaultWidth  ^100handlesMouseDown: arg1  self eventHandler ifNotNil: [ ^self eventHandler handlesMouseDown: arg1 ].  ^falsemouseMove: arg1  scroller hasSubmorphs ifTrue: [ scroller submorphs last mouseMove: (arg1 transformedBy: (scroller transformFrom: self)) ]focusBounds  ^self boundsminExtent  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := self hResizing.  tmp5 := self vResizing.  (tmp4 == #rigid and: [ tmp5 == #rigid ]) ifTrue: [ ^self fullBounds extent max: self minWidth @ self minHeight ].  self hasSubmorphs ifFalse: [ tmp4 == #shrinkWrap ifTrue: [ tmp4 := #rigid ].        tmp5 == #shrinkWrap ifTrue: [ tmp5 := #rigid ] ].  tmp1 := self layoutPolicy.  tmp1 ifNil: [ tmp2 := 0 @ 0 ] ifNotNil: [ tmp2 := tmp1 minExtentOf: self in: self layoutBounds ].  tmp4 == #rigid ifTrue: [ tmp2 := self fullBounds extent x @ tmp2 y ] ifFalse: [ tmp3 := self bounds width - self layoutBounds width.        tmp2 := (tmp2 x + tmp3) @ tmp2 y ].  tmp2 := tmp5 == #rigid ifTrue: [ tmp2 x @ self fullBounds extent y ] ifFalse: [ tmp3 := self bounds height - self layoutBounds height.        tmp2 x @ (tmp2 y + tmp3) ].  tmp2 := tmp2 max: self minWidth @ self minHeight.  ^tmp2icon: arg1  self subclassResponsibilitycancelEdits  self doneWithEditson: arg1 color: arg2 changeColor: arg3  self     on: arg1 color: arg2;     setColorSelector: arg3addYellowButtonMenuItemsTo: arg1 event: arg2  arg1 defaultTarget: self.  self defaultYellowButtonMenuEnabled ifFalse: [ ^self ].  self addModelYellowButtonItemsTo: arg1 event: arg2.  self cmdGesturesEnabled ifTrue: [ arg1 addLine.        arg1 add: 'inspect' selector: #inspect ].  arg1 addLine.  self isWorldMorph ifFalse: [ arg1 add: 'delete' selector: #delete ].  self world selectedObject == self ifTrue: [ arg1 add: 'halo off' selector: #removeHalo ] ifFalse: [ arg1 add: 'halo on' selector: #addHalo ].  (self isWorldMorph or: [ self wantsToBeTopmost ]) ifFalse: [ arg1 addLine.        arg1 add: 'send to back' selector: #goBehind.        arg1 add: 'bring to front' selector: #comeToFront.        self addEmbeddingMenuItemsTo: arg1 hand: arg2 hand ].  self isWorldMorph ifFalse: [ self isFullOnScreen ifFalse: [ arg1 add: 'move onscreen' selector: #goHome ] ].  self addLayoutMenuItems: arg1 hand: arg2 hand.  (owner notNil and: [ owner isTextMorph ]) ifTrue: [ self addTextAnchorMenuItems: arg1 hand: arg2 hand ].  self isWorldMorph ifFalse: [ arg1 addLine.        self addToggleItemsToHaloMenu: arg1 ].  arg1 addLine.  self isWorldMorph ifFalse: [ arg1 add: 'copy to paste buffer' selector: #copyToPasteBuffer: ].  (self allStringsAfter: nil) isEmpty ifFalse: [ arg1 add: 'copy text' selector: #clipText ].  self addExportMenuItems: arg1 hand: arg2 hand.  arg1 addLine.  arg1 add: 'adhere to edge...' selector: #adhereToEdge.  self addCustomMenuItems: arg1 hand: arg2 handpreferredKeyboardBounds  ^self bounds: self bounds in: self currentWorlddrawOn: arg1 offset: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp2 := date dayOfMonth printString.  tmp5 := owner weekdayFont widthOfString: tmp2.  tmp4 := bounds topCenter translateBy: (tmp5 // -2) @ 3.  tmp1 := ((tmp4 extent: tmp5 @ owner weekdayFont height) insetBy: -8 @ -1) translateBy: arg2.  tmp6 := date = Date today.  tmp3 := date month = owner date month ifTrue: [ Color black ] ifFalse: [ Color veryLightGray ].  (date = owner date or: [ self highlighted ]) ifTrue: [ | tmp7 tmp8 |        tmp7 := tmp6 ifTrue: [ Color red ] ifFalse: [ Color veryLightGray ].        tmp8 := self highlighted ifTrue: [ Color veryVeryLightGray ] ifFalse: [ Color veryLightGray ].        arg1 fillOval: tmp1 color: tmp8 borderWidth: 1 borderColor: tmp7 ].  tmp6 & (date ~= owner date) & self highlighted not ifTrue: [ arg1 fillOval: tmp1 color: Color white borderWidth: 1 borderColor: Color red ].  arg1 drawString: tmp2 at: tmp4 + arg2 font: owner weekdayFont color: tmp3enableDrop: arg1  self setProperty: #dropEnabled toValue: arg1mouseEnter: arg1  super mouseEnter: arg1.  self showOverEditableTextCursorchooseDropList: arg1 list: arg2  ^self chooseDropList: arg1 title: 'Choose' translated list: arg2drawOn: arg1  self theme flatMenu ifFalse: [ arg1 fillRectangle: (bounds topLeft corner: bounds rightCenter) color: self baseColor twiceDarker.        arg1 fillRectangle: (bounds leftCenter corner: bounds bottomRight) color: self baseColor twiceLighter ] ifTrue: [ arg1 fillRectangle: (bounds topLeft corner: bounds bottomRight) color: self baseColor ]minHeight  ^self class defaultRowHeight ceilingupdateFromParagraph  | tmp1 tmp2 tmp3 tmp4 tmp5 |  paragraph ifNil: [ ^self ].  wrapFlag ifNil: [ wrapFlag := true ].  editor ifNotNil: [ tmp4 := editor.        tmp2 := editor selectionInterval.        editor storeSelectionInParagraph ].  text := paragraph text.  paragraph textStyle = textStyle ifTrue: [ self fit ] ifFalse: [ tmp1 := paragraph textStyle.        (self firstInChain text: text textStyle: tmp1) recomposeChain.        editor ifNotNil: [ self installEditorToReplace: editor ] ].  super layoutChanged.  tmp2 ifNil: [ ^self ].  predecessor ifNotNil: [ tmp2 first <= (self paragraph lines first last + 1) ifTrue: [ tmp3 := predecessor lastCharacterIndex.              predecessor paragraph recomposeFrom: tmp3 to: text size delta: 0.              tmp3 = predecessor lastCharacterIndex ifFalse: [ predecessor changed.                    self predecessorChanged ] ] ].  ((tmp5 := predecessor notNil and: [ tmp2 first <= self paragraph firstCharacterIndex ]) or: [ successor notNil and: [ tmp2 first > (self paragraph lastCharacterIndex + 1) ] ]) ifTrue: [ tmp5 ifTrue: [ predecessor recomposeChain ] ifFalse: [ self recomposeChain ].        self firstInChain withSuccessorsDo: [:arg1 |  (tmp2 first between: arg1 firstCharacterIndex and: arg1 lastCharacterIndex + 1) ifTrue: [ arg1 installEditorToReplace: tmp4.                    ^self passKeyboardFocusTo: arg1 ] ].        self error: 'Inconsistency in text editor' ].  editor ifNil: [ self installEditorToReplace: tmp4 ]getValueSelector  ^getValueSelectorusedHeightByPredominantDockingBarsOfChastes: arg1  ^(self predominantDockingBarsOfChastes: arg1) ifEmpty: [ 0 ] ifNotEmpty: [:arg2 |  (arg2 collect: [:arg3 |  arg3 height ]) sum ]disableTableLayout  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ false ] ifNotNil: [ tmp1 disableTableLayout ]children  | tmp1 |  tmp1 := OrderedCollection new.  self childrenDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1backgroundColor  ^backgroundColorexpandedChildren  self isExpanded ifFalse: [ ^{} ].  ^self children flatCollect: #withExpandedChildrenshouldDraw  ^truesetUp  super setUp.  morph := Morph new.  morph eventHandler: MorphicEventHandler newnewAlphaSelector: arg1 getAlpha: arg2 setAlpha: arg3 help: arg4  ^self theme newAlphaSelectorIn: self for: arg1 getAlpha: arg2 setAlpha: arg3 help: arg4vIsScrollable  ^self vLeftoverScrollRange > 0 and: [ self vTotalScrollRange > (self scrollDeltaHeight * 3 / 2) ]reset  self subclassResponsibilitycolor  ^color ifNil: [ self container columnColors at: self index \\ 2 + 1 ]handleUnknownEvent: arg1  ^self dispatchDefault: arg1 with: morphhandlesMouseDown: arg1  ^truestate  ^stateindexForRow: arg1  ^self subclassResponsibilityscaledValue: arg1  | tmp1 |  tmp1 := arg1.  self quantum ifNotNil: [:arg2 |  tmp1 := tmp1 roundTo: arg2 ].  self value: (self max <= self min ifTrue: [ 0 ] ifFalse: [ (tmp1 - self min) / (self max - self min) ])lineColor  ^lineColor ifNil: [ lineColor := container lineColorForNode: self complexContents ]yellowButtonEvent: arg1  (self scrollerSubMorphFromPoint: arg1 position) ifNotNil: [:arg2 |  arg2 selected ifFalse: [ self listManager setSelectedMorph: arg2 ].        ^self yellowButtonActivity: arg1 shiftPressed ].  ^self yellowButtonActivity: arg1 shiftPressedresizeCursor  ^Cursor resizeForEdge: #leftresetListSelector  ^resetListSelectortreeMorph  | tmp1 |  tmp1 := (MorphTreeMorph on: self)     beMultiple;     columns: {(MorphTreeColumn new           startWidth: 300;           rowMorphGetSelector: #classButton;           headerButtonLabel: 'Class' font: nil) .         (MorphTreeColumn new           startWidth: 500;           rowMorphGetSelector: #commentText;           headerButtonLabel: 'Comment' font: nil)};     rowInset: 4;     treeLineWidth: 1;     columnInset: 4;     getMenuSelector: #menu:shifted:;     rowColorForEven: Color lightGray muchLighter.  ^tmp1 buildContentsdrawBackgroundSketchOn: arg1  backgroundMorph ifNil: [ ^self ].  self clipSubmorphs ifTrue: [ arg1 clipBy: self clippingBounds during: [:arg2 |  arg2 fullDrawMorph: backgroundMorph ] ] ifFalse: [ arg1 fullDrawMorph: backgroundMorph ]printKeyStringOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self keyCharacter.  tmp2 := false.  tmp3 := [ tmp2 ifFalse: [ arg1 nextPut: $<.        tmp2 := true ] ].  self controlKeyPressed ifTrue: [ tmp3 value.        arg1 nextPutAll: 'Ctrl-' ].  self commandKeyPressed ifTrue: [ tmp3 value.        arg1 nextPutAll: 'Cmd-' ].  (buttons anyMask: 32) ifTrue: [ tmp3 value.        arg1 nextPutAll: 'Opt-' ].  (self shiftPressed and: [ keyValue between: 1 and: 31 ]) ifTrue: [ tmp3 value.        arg1 nextPutAll: 'Shift-' ].  self hasSpecialCTRLKeyValue ifTrue: [ arg1 nextPut: (keyValue + $a asciiValue - 1) asCharacter ] ifFalse: [ tmp4 := tmp1 caseOf: {([ Character space ] -> [ ' ' ]) .               ([ Character tab ] -> [ 'tab' ]) .               ([ Character cr ] -> [ 'cr' ]) .               ([ Character lf ] -> [ 'lf' ]) .               ([ Character enter ] -> [ 'enter' ]) .               ([ Character backspace ] -> [ 'backspace' ]) .               ([ Character delete ] -> [ 'delete' ]) .               ([ Character escape ] -> [ 'escape' ]) .               ([ Character arrowDown ] -> [ 'down' ]) .               ([ Character arrowUp ] -> [ 'up' ]) .               ([ Character arrowLeft ] -> [ 'left' ]) .               ([ Character arrowRight ] -> [ 'right' ]) .               ([ Character end ] -> [ 'end' ]) .               ([ Character home ] -> [ 'home' ]) .               ([ Character pageDown ] -> [ 'pageDown' ]) .               ([ Character pageUp ] -> [ 'pageUp' ]) .               ([ Character euro ] -> [ 'euro' ]) .               ([ Character insert ] -> [ 'insert' ])} otherwise: [ String with: tmp1 ].        tmp4 size > 1 ifTrue: [ tmp3 value ].        arg1 nextPutAll: tmp4 ].  tmp2 ifTrue: [ arg1 nextPut: $> ]addFontEmphHandle: arg1  innerTarget isTextMorph ifTrue: [ self addHandle: arg1 on: #mouseDown send: #chooseEmphasisOrAlignment to: innerTarget ]clipSubmorphs  ^truetestRowIndexFrom  self assert: (strategy rowIndexFrom: 3) equals: 3sliderShadowColor  ^self sliderColor alphaMixed: 0.2 with: self pagingArea colorremoveNode: arg1  self selectedNodePath = arg1 path ifTrue: [ self selectedNodePath: nil ]defaultBorderWidth  ^self theme borderWidthsecondNameMorph  ^(self theme newTextEntryIn: self currentWorld for: self get: #secondName set: #secondName: class: String getEnabled: nil help: nil) color: Color transparentchooseFont  ^self chooseFont: nilwrapItem: arg1 index: arg2  ^self wrapSelector ifNil: [ arg1 asStringOrText ] ifNotNil: [:arg3 |  arg3 numArgs == 0 ifTrue: [ arg1 perform: arg3 ] ifFalse: [ self model perform: arg3 withEnoughArguments: {arg1 .                     arg2} ] ]scroller: arg1  scroller := arg1wrapSelector  ^wrapSelectoroldPosition: arg1  oldPosition := arg1on: arg1 send: arg2 to: arg3 withValue: arg4  self eventHandler ifNil: [ self eventHandler: MorphicEventHandler new ].  self eventHandler on: arg1 send: arg2 to: arg3 withValue: arg4shiftPressed  ^buttons anyMask: 8selectionColorToUse: arg1  arg1 = self selectionColorToUse ifTrue: [ ^self ].  arg1 ifNil: [ self removeProperty: #selectionColorToUse ] ifNotNil: [ self setProperty: #selectionColorToUse toValue: arg1 ].  self selectionFrameChangedtoggleExpandedState: arg1 event: arg2  | tmp1 |  arg2 yellowButtonPressed ifTrue: [ tmp1 := arg1 isExpanded.        self allNodeMorphs copy do: [:arg3 |  (arg3 canExpand and: [ arg3 isExpanded = tmp1 ]) ifTrue: [ arg3 toggleExpandedState ] ] ] ifFalse: [ arg1 toggleExpandedState ].  self adjustSubmorphPositionsorganizeIntoRow  ((AlignmentMorph inARow: (selectedItems asSortedCollection: [:arg1 :arg2 |  arg1 left < arg2 left ]))     setNameTo: 'Row';     color: Color orange muchLighter;     enableDragNDrop: true;     yourself) openInHandprepareForScaling  ^selfcolumnResizers  ^columnResizers ifNil: [ columnResizers := OrderedCollection new ]model  ^modelfindNextString: arg1 startingAt: arg2  | tmp1 |  self handleEdit: [ tmp1 := self editor findNextString: arg1 startingAt: arg2 ].  ^tmp1asString  ^model printNode: selfcolor  ^Color transparentcomputeSlider  | tmp1 |  tmp1 := self roomToMove.  self descending ifFalse: [ slider position: (bounds isWide ifTrue: [ tmp1 topLeft + ((tmp1 width * value) asInteger @ 0) ] ifFalse: [ tmp1 topLeft + (0 @ (tmp1 height * value) asInteger) ]) ] ifTrue: [ slider position: (bounds isWide ifTrue: [ tmp1 bottomRight - ((tmp1 width * value) asInteger @ 0) ] ifFalse: [ tmp1 bottomRight - (0 @ (tmp1 height * value) asInteger) ]) ].  slider extent: self sliderExtentshowDebugEvent: arg1  ShowEvents == true ifTrue: [ | tmp1 |        Display fill: (0 @ 0 extent: 500 @ 120) rule: Form over fillColor: Color white.        tmp1 := ((owner hands indexOf: self) - 1) * 60.        arg1 printString displayAt: 0 @ tmp1 + (arg1 isKeyboard ifTrue: [ 0 @ 30 ] ifFalse: [ 0 @ 0 ]).        self keyboardFocus printString displayAt: 0 @ tmp1 + (0 @ 45) ]asText  | tmp1 tmp2 |  tmp1 := TextAnchor new anchoredMorph: self.  tmp2 := (Character value: 1) asString.  ^Text string: tmp2 attribute: tmp1icon: arg1  iconBlock := arg1newFuzzyLabel: arg1  ^self theme newFuzzyLabelIn: self for: nil label: arg1 offset: 1 alpha: 0.5 getEnabled: nilchildNodeClassFromItem: arg1  ^PackageMethodNodeExampleframeRectangle: arg1 on: arg2  arg2 frameAndFillRectangle: arg1 fillColor: Color transparent borderWidth: (self width - self margin max: 0) topLeftColor: self topLeftColor bottomRightColor: self bottomRightColorsolidLabelMorph  ^solidLabelMorphroomToMove  ^self bounds isWide ifTrue: [ self totalSliderArea insetBy: (((self sliderThickness // 2) @ 0) negated corner: (self sliderThickness // 2 + 1) @ 0) ] ifFalse: [ self totalSliderArea insetBy: (0 @ (self sliderThickness // 2) negated corner: 0 @ (self sliderThickness // 2 - (self sliderThickness \\ 2) + 1)) ]enabled  ^self isEnabledballoonHelp  ^self valueOfProperty: #balloonHelpMorphextent: arg1  self changed.  bounds := bounds topLeft extent: arg1.  self layoutChanged.  self changedpressedImage: arg1  pressedImage := arg1.  self invalidRect: self boundsaddPaneVSplitterBetween: arg1 and: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 layoutFrame rightFraction.  tmp2 := (arg2 detectMin: [:arg3 |  arg3 layoutFrame topFraction ]) layoutFrame topFraction.  tmp3 := (arg2 detectMax: [:arg3 |  arg3 layoutFrame bottomFraction ]) layoutFrame bottomFraction.  tmp4 := ProportionalSplitterMorph new.  tmp4 layoutFrame: ((tmp1 @ tmp2 corner: tmp1 @ tmp3) asLayoutFrame           leftOffset: arg1 layoutFrame rightOffset;           rightOffset: 4 + arg1 layoutFrame rightOffset;           topOffset: arg1 layoutFrame topOffset;           bottomOffset: arg1 layoutFrame bottomOffset).  self addMorphBack: (tmp4 position: self position)handlesMouseStillDown: arg1  ^self existsSubscriptionsFor: #mouseStillDownreplaceSelectionWith: arg1  self handleEdit: [ self editor replaceSelectionWith: arg1 ]isWindowNavigation  ^TaskListMorph isNavigationEvent: selfexecute  actionBlock cull: table dataSource cull: field getTextFromModel asString cull: (table selectedIndex = 0 ifFalse: [ table dataSource realElementAt: table selectedIndex ] ifTrue: [ nil ])shadowColor: arg1  self shadowColor = arg1 ifFalse: [ self changed ].  self setProperty: #shadowColor toValue: arg1position: arg1  | tmp1 tmp2 |  tmp1 := arg1 asNonFractionalPoint - bounds topLeft.  (tmp1 x = 0 and: [ tmp1 y = 0 ]) ifTrue: [ ^self ].  tmp2 := self fullBounds.  (tmp1 dotProduct: tmp1) > 100 ifTrue: [ self invalidRect: tmp2.        self invalidRect: (tmp2 translateBy: tmp1) ] ifFalse: [ self invalidRect: (tmp2 merge: (tmp2 translateBy: tmp1)) ].  self privateFullMoveBy: tmp1.  owner ifNotNil: [ owner layoutChanged ]adjustAlarmTimes: arg1  | tmp1 |  tmp1 := arg1 - lastAlarmTime.  self alarms do: [:arg2 |  arg2 scheduledTime: arg2 scheduledTime + tmp1 ]changeRequest: arg1  ^arg1 change: selfnewPluggableDialogWindow: arg1  ^self newPluggableDialogWindow: arg1 for: niladdCloseBox  | tmp1 |  labelArea ifNil: [ ^self ].  closeBox := self createCloseBox.  tmp1 := LayoutFrame identity leftOffset: 2.  closeBox layoutFrame: tmp1.  labelArea addMorphBack: closeBoxnodeStringGetter: arg1  self columns first nodeStringGetter: arg1updateState  (target perform: stateSelector) ifTrue: [ self state: #on ] ifFalse: [ self state: #off ]editorProvider: arg1  self setProperty: #editorProvider toValue: arg1height  ^header ifNil: [ 0 ] ifNotNil: [ header height ]formerPosition: arg1  arg1 ifNil: [ self removeProperty: #formerPosition ] ifNotNil: [ self setProperty: #formerPosition toValue: arg1 ]getLabelSelector: arg1  getLabelSelector := arg1dispatchKeystroke: arg1  arg1 keyCharacter == Character tab ifTrue: [ self tabAmongFields ifTrue: [ ^self tabHitWithEvent: arg1 ] ]mayBeExtended  ^falsekeystrokeActionSelector: arg1  keystrokeActionSelector := arg1keyValue  ^keyValueinitialize  super initialize.  toolbar := TabBarMorph new.  processes := OrderedCollection new.  self registerBarActions.  self registerShortcuts.  container := Morph new     color: self containerColor;     changeProportionalLayout;     yourself.  contentsWrapper := Morph new     color: self containerColor;     changeProportionalLayout;     yourself.  self changeProportionalLayout.  self addMorphsmouseUpOnMultiple: arg1  dragOnOrOff := nil.  arg1 hand hasSubmorphs ifFalse: [ self mouseDownRow: nil ]acceptDroppingMorph: arg1 event: arg2  dropItemSelector ifNotNil: [ | tmp1 |        dropItemSelector ifNil: [ ^self ].        tmp1 := arg1 passenger.        model perform: dropItemSelector with: tmp1 with: potentialDropRow ] ifNil: [ self model acceptDroppingMorph: arg1 event: arg2 inMorph: self ].  self resetPotentialDropRow.  arg2 hand releaseMouseFocus: self.  Cursor normal showdescending: arg1  descending := arg1.  self value: valuehatchForm  ^ColorPresenterMorph hatchFormrectangle: arg1  rectangle := arg1scrollDeltaWidth  ^self scrollDeltaHeight // 2deleteDockingBars  self dockingBars do: [:arg1 |  arg1 delete ]delete  super delete.  self triggerEvent: #barDeleted with: selfcancelled: arg1  cancelled := arg1cornerStyle  ^cornerStyle ifNil: [ #square ]column: arg1  column := arg1arrangeToStartSteppingIn: arg1  arg1 ifNil: [ ^self ].  arg1 startStepping: self.  self changeddoubleClick  dblClickSelector ifNotNil: [ clickClient perform: dblClickSelector with: firstClickDown ]wrapCentering: arg1  self assureTableProperties wrapCentering: arg1.  self layoutChangedaddOrRemoveItems: arg1  | tmp1 |  tmp1 := arg1 isMorphicEvent ifFalse: [ arg1 ] ifTrue: [ arg1 hand ].  tmp1 addMorphBack: ((self class newBounds: (tmp1 lastEvent cursorPoint extent: 16 @ 16)) setOtherSelection: self)normalFillStyle  ^self theme morphTreeSplitterNormalFillStyleFor: selfgetMenuSelector: arg1  getMenuSelector := arg1newLabelMorph  ^(LabelMorph contents: self label)     on: #mouseDown send: #toggleSelected to: self;     yourselfhandleRect  ^Rectangle center: self bounds center extent: (self splitsTopAndBottom ifTrue: [ self handleSize transposed ] ifFalse: [ self handleSize ])keyStroke: arg1  super keyStroke: arg1.  (self navigationKey: arg1) ifTrue: [ ^true ].  ^falsedeliverTo: arg1  ^arg1 update: selectorupdateDownButtonImage  downButton removeAllMorphs.  downButton addMorphCentered: (ImageMorph new form: self downImage)collapse  recentlyChanged := true.  self dataSource updateSelectionWithCollectBlock: [:arg1 :arg2 |  | tmp1 |        tmp1 := self numberOfVisibleChildren.        (arg1 between: arg2 and: arg2 + tmp1) ifTrue: [ arg2 ] ifFalse: [ arg1 < arg2 ifTrue: [ arg1 ] ifFalse: [ arg1 - tmp1 ] ] ].  isExpanded := falsenewColorPresenterFor: arg1 getColor: arg2 help: arg3  ^self theme newColorPresenterIn: self for: arg1 getColor: arg2 help: arg3wouldAcceptKeyboardFocusUponTab  ^falsecentered  self changeAlignment: #centeredinitialize  super initialize.  self addDependent: SystemProgressMorph uniqueInstanceputOnTop: arg1  windows remove: arg1.  windows addLast: arg1newExpander: arg1 forAll: arg2  ^self theme newExpanderIn: self label: arg1 forAll: arg2isNotMinimized  ^self isCollapsed notmenuKeyboardControl  ^self theme settings menuKeyboardControlwithTreeLines: arg1  self treeLineWidth: 1privateMoveBy: arg1  | tmp1 tmp2 |  bounds := bounds translateBy: arg1.  fullBounds ifNotNil: [ fullBounds := fullBounds translateBy: arg1 ].  tmp1 := self fillStyle.  tmp1 isOrientedFill ifTrue: [ tmp1 origin: tmp1 origin + arg1 ].  tmp2 := self borderStyle.  (tmp2 hasFillStyle and: [ tmp2 fillStyle isOrientedFill ]) ifTrue: [ tmp2 fillStyle origin: tmp2 fillStyle origin + arg1 ]add: arg1 icon: arg2 help: arg3 subMenu: arg4  self add: arg1 icon: arg2 help: arg3 subMenu: arg4 action: nil keyText: nildisabledFillStyle  ^self theme taskbarItemDisabledFillStyleFor: selfadjacentTo  | tmp1 |  tmp1 := 4 + owner borderWidth.  owner isFloating ifTrue: [ ^{(self bounds bottomLeft + (5 @ tmp1))} ].  owner isAdheringToTop ifTrue: [ ^{(self bounds bottomLeft + (5 @ tmp1))} ].  owner isAdheringToLeft ifTrue: [ ^{(self bounds topRight + (5 @ tmp1))} ].  owner isAdheringToBottom ifTrue: [ ^{(self bounds topLeft + (5 @ tmp1))} ].  owner isAdheringToRight ifTrue: [ ^{(self bounds topLeft + (5 @ tmp1 negate))} ].  ^{(self bounds bottomLeft + (3 @ tmp1))}cellColumn: arg1 row: arg2  ^FTCellMorph new     color: (self colorFor: arg2);     cellInset: 5;     addMorphBack: (self iconFor: arg2) asMorph;     addMorphBack: (self elementAt: arg2) name asStringMorph;     yourselfinternalSpaces  ^internalSpacesfitAllVisibleWindows  | tmp1 |  tmp1 := RealEstateAgent maximumUsableAreaInWorld: self currentWorld.  (self windowsSatisfying: [:arg1 |  arg1 isCollapsed not ]) reverseDo: [:arg1 |  arg1 extent: arg1 initialExtent.        arg1 bounds: ((arg1 position extent: arg1 initialExtent) translatedAndSquishedToBeWithin: tmp1) ].  self displayWorldclippingBounds  ^self innerBoundsexpandItemPath: arg1  self requestView: (MorphTreeChangeRequest expandItemPath: arg1)setTabs: arg1  self tabs: arg1 valuesetToAdhereToEdge: arg1  arg1 ifNil: [ ^self ].  arg1 == #none ifTrue: [ ^self removeProperty: #edgeToAdhereTo ].  self setProperty: #edgeToAdhereTo toValue: arg1selected: arg1  (self state == #pressed or: [ self state == #repressed ]) ifTrue: [ self state: (arg1 ifTrue: [ #repressed ] ifFalse: [ #pressed ]) ] ifFalse: [ self state: (arg1 ifTrue: [ #on ] ifFalse: [ #off ]) ]shiftPressed  ^lastMouseEvent shiftPressedrotationDegrees  ^0.0dragEnabled  ^(self valueOfProperty: #dragEnabled) == truevertProfile  vertProfile ifNil: [ self computeShadow ].  ^vertProfilebuildRowMorphsFrom: arg1  self buildRowMorphsFrom: arg1 increment: self lazyIncrementfullReleaseCachedState  self allMorphsDo: [:arg1 |  arg1 releaseCachedState ]drawSubmorphsOn: arg1  | tmp1 |  (tmp1 := self magicAlpha) = 1.0 ifTrue: [ ^super drawSubmorphsOn: arg1 ].  ^super drawSubmorphsOn: (arg1 asAlphaBlendingCanvas: tmp1)topVisibleRowForCanvas: arg1  ^self rowAtLocation: arg1 clipRect topLefthUnadjustedScrollRange  ^self listMorph hUnadjustedScrollRangecollapseOrExpand  | tmp1 |  self isTaskbarPresent ifTrue: [ ^self minimizeOrRestore ].  isCollapsed ifTrue: [ isCollapsed := false.        self activate.        collapsedFrame := self getBoundsWithFlex.        collapseBox ifNotNil: [ collapseBox setBalloonText: 'Collapse this window' ].        self setBoundsWithFlex: fullFrame.        paneMorphs reverseDo: [:arg1 |  self addMorph: arg1 unlock.              self world startSteppingSubmorphsOf: arg1 ].        self           addPaneSplitters;           addGripsIfWanted ] ifFalse: [ isCollapsed := true.        fullFrame := self getBoundsWithFlex.        paneMorphs do: [:arg1 |  arg1                 delete;                 releaseCachedState ].        self removePaneSplitters.        self removeGrips.        tmp1 := self getCollapsedFrame.        collapsedFrame ifNil: [ collapsedFrame := tmp1 ].        self setBoundsWithFlex: tmp1.        collapseBox ifNotNil: [ collapseBox setBalloonText: 'expand this window' ].        expandBox ifNotNil: [ expandBox setBalloonText: 'expand to full screen' ] ].  self layoutChanged.  self announce: (WindowCollapsed new           window: self;           yourself)menu: arg1 shifted: arg2  ^arg1enable  self enabled: truebeSingleSelection  selectionStrategy := FTSimpleSelection table: selfaddDebugHandle: arg1  self class haloWithDebugHandle ifTrue: [ self addHandle: arg1 on: #mouseDown send: #doDebug:with: to: self ]composeOneLine  | tmp1 |  tmp1 := theContainer rectanglesAt: currentY height: defaultLineHeight.  tmp1 notEmpty ifTrue: [ (self composeAllRectangles: tmp1) ifNil: [ ^nil ] ] ifFalse: [ currentY := currentY + defaultLineHeight ].  self checkIfReadyToSlidenewCloseButtonFor: arg1  ^self theme newCloseButtonIn: self for: arg1eventHandler: arg1  eventHandler := arg1model  ^modelrotationCenter: arg1  | tmp1 |  arg1 ifNil: [ self removeProperty: #referencePosition ] ifNotNil: [ tmp1 := self bounds.        self setProperty: #referencePosition toValue: tmp1 origin + (arg1 * tmp1 extent) ]deferUpdates: arg1  ^Display deferUpdates: arg1veryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  defaultTarget := arg1 references at: defaultTarget ifAbsent: [ defaultTarget ].  popUpOwner := arg1 references at: popUpOwner ifAbsent: [ popUpOwner ].  activeSubMenu := arg1 references at: activeSubMenu ifAbsent: [ activeSubMenu ]updateFeedbackForEvt: arg1  | tmp1 |  tmp1 := self containsPoint: arg1 cursorPoint.  tmp1 = showSelectionFeedback ifFalse: [ self showSelectionFeedback: tmp1.        self           changed;           layoutChanged ]disabledBorderStyle  ^self theme taskbarItemDisabledBorderStyleFor: selfhorizontal: arg1  ^self orientation: (arg1 ifTrue: [ #horizontal ] ifFalse: [ #vertical ])selectedDisabledFillStyle  ^self theme taskbarItemSelectedDisabledFillStyleFor: selfsetScrollDeltas  self     hSetScrollDelta;     vSetScrollDeltatransformedBy: arg1  addMenuItem: arg1  self addMorphBack: arg1.  ^arg1closeItemPath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  tmp1 := nil.  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ arg2 complexContents withoutListWrapper = arg1 first ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNotNil: [ (tmp1 isExpanded and: [ arg1 size = 1 ]) ifTrue: [ tmp1 toggleExpandedState.              container adjustSubmorphPositions ].        tmp1 changed.        arg1 size = 1 ifTrue: [ ^container listManager setSelectedMorph: tmp1 ].        ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild closeItemPath: arg1 allButFirst ] ].  ^container setSelectedMorph: nilnewToolbar: arg1  ^self theme newToolbarIn: self for: arg1vScrollbar: arg1  vScrollbar := arg1minCellSize: arg1  minCellSize := arg1invalidRect: arg1  beExplicite  self deprecated: 'Use #beExplicit instead' transformWith: '`@receiver beExplicite' -> '`@receiver beExplicit'.  ^self beExplicitdrawOn: arg1  (owner notNil and: [ owner containsPoint: self position ]) ifTrue: [ super drawOn: arg1 ]subMenuMarker  ^self rightArrowdashColors: arg1 dashLengths: arg2  arg1 size = arg2 size ifFalse: [ self error: 'Colors and Lengths must have the same size' ].  self     dashColors: arg1;     dashLengths: arg2themeChanged  isEditEvent: arg1  | tmp1 |  tmp1 := arg1 keyValue asCharacter.  ^tmp1 == Character cr or: [ tmp1 == Character escape or: [ tmp1 == Character backspace or: [ tmp1 == Character delete or: [ tmp1 == Character arrowLeft or: [ tmp1 == Character arrowRight or: [ tmp1 == Character home or: [ tmp1 == Character end or: [ arg1 commandKeyPressed and: [ tmp1 = $a ] ] ] ] ] ] ] ] ]stateSelector  ^stateSelectoruseSecondarySelection  ^TextEditor useSecondarySelectionscale: arg1  mouseMove: arg1  allButtons ifNil: [ ^self ].  allButtons do: [:arg2 |  arg2 updateFeedbackForEvt: arg1 ]newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: true help: arg6outerGap  ^self cornerRadius * 2highlightRowIndex: arg1  self deprecated: 'Use #highlightIndex: instead' transformWith: '`@receiver highlightRowIndex: `@statements1' -> '`@receiver highlightIndex: `@statements1'.  self highlightIndex: arg1printOn: arg1  arg1 nextPut: $[.  arg1     nextPutAll: self type;     space.  arg1     nextPut: $(;     print: self rectangle;     nextPut: $).  arg1 nextPut: $]areasRemainingToFill: arg1  ^Array with: arg1handlesKeyboard: arg1  ^truestylingEnabled  ^falsenewAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6 entryCompletion: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6 entryCompletion: arg7buttonForMorph: arg1  | tmp1 |  tmp1 := (self orderedTasks collect: [:arg2 |  arg2 morph ]) indexOf: arg1.  ^tmp1 = 0 ifTrue: [ nil ] ifFalse: [ self submorphs at: tmp1 ifAbsent: [  ] ]rotationDegrees  ^0.0handlesKeyboard: arg1  ^trueownerChanged  self owner ifNil: [ ^self ].  [ self updateBounds.  self updateTasks ] on: Exception do: [:arg1 |  self delete.        arg1 pass ].  super ownerChangedsmoothingOn  smoothing := 2.  self changeduiProcess  ^UIProcessdropElements: arg1 index: arg2  self dropItemSelector ifNil: [ ^self ].  self model perform: self dropItemSelector with: arg1 with: arg2minimumExtent: arg1  self setProperty: #minimumExtent toValue: arg1pageSearchText  ^pageSearchText ifNil: [ pageSearchText := '' ]composeEachRectangleIn: arg1  | tmp1 tmp2 |  1 to: arg1 size do: [:arg2 |  currCharIndex <= theText size ifFalse: [ ^false ].        tmp1 := scanner composeFrom: currCharIndex inRectangle: (arg1 at: arg2) firstLine: isFirstLine leftSide: arg2 = 1 rightSide: arg2 = arg1 size.        lines addLast: tmp1.        actualHeight := actualHeight max: tmp1 lineHeight.        currCharIndex := tmp1 last + 1.        tmp1 last = 0 ifTrue: [ ^false ].        tmp2 := theText at: tmp1 last.        (CharacterSet crlf includes: tmp2) ifTrue: [ ^#cr ].        wantsColumnBreaks ifTrue: [ tmp2 = self class characterForColumnBreak ifTrue: [ ^#columnBreak ] ] ].  ^falsehasParagraphAnchorString  ^(self textAnchorType == #paragraph) -> 'Paragraph' translatedmodalLockTo: arg1  | tmp1 |  tmp1 := IdentityDictionary new.  self submorphsDo: [:arg2 |  tmp1 at: arg2 put: arg2 isLocked.        arg2 lock ].  arg1 unlock.  tmp1 at: arg1 put: arg1 isLocked.  self setProperty: #submorphLockStates toValue: tmp1closestPointTo: arg1  | tmp1 tmp2 |  tmp1 := tmp2 := nil.  self lineSegmentsDo: [:arg2 :arg3 |  | tmp3 tmp4 |        tmp4 := arg1 nearestPointOnLineFrom: arg2 to: arg3.        tmp3 := tmp4 distanceTo: arg1.        (tmp1 isNil or: [ tmp3 < tmp2 ]) ifTrue: [ tmp1 := tmp4.              tmp2 := tmp3 ] ].  ^tmp1scaledValue  | tmp1 |  tmp1 := self value * (self max - self min) + self min.  self quantum ifNotNil: [:arg1 |  tmp1 := tmp1 roundTo: arg1 ].  ^(tmp1 max: self min) min: self maxstartingIndex  predecessor ifNil: [ ^1 ].  ^predecessor lastCharacterIndex + 1maxRightX  ^maxRightXprepareToBeSaved  self releaseCachedState.  self formerOwner: nil.  self formerPosition: nil.  fullBounds := nilrootItems  ^rootItems ifNil: [ rootItems := {} ]mouseLeaveDragging: arg1  arg1 hand showTemporaryCursor: nil.  self showLocationlabel: arg1  self labelMorph: (arg1 isMorph ifTrue: [ arg1 ] ifFalse: [ self labelMorph contents: arg1.              self newLabel ])setRight: arg1  right := arg1font: arg1  | tmp1 |  tmp1 := arg1 textStyle copy ifNil: [ TextStyle fontArray: {arg1} ].  textStyle := tmp1.  text addAttribute: (TextFontChange fontNumber: (tmp1 fontIndexOf: arg1)).  paragraph ifNotNil: [ paragraph textStyle: tmp1 ]testSelectLast  table selectLast.  self assert: table selectedIndexes equals: #(#(10 3))wrapBlockOrSelector: arg1  wrapBlockOrSelector := arg1startAt: arg1  value := start := arg1scrollRight: arg1  self scrollDown: arg1mouseDown: arg1  | tmp1 tmp2 |  self state: #pressed.  actWhen == #buttonDown ifTrue: [ self doButtonAction ] ifFalse: [ tmp1 := Time millisecondClockValue.        super mouseDown: arg1.        tmp2 := Time millisecondClockValue - tmp1 max: 0.        tmp2 < 200 ifTrue: [ (Delay forMilliseconds: 200 - tmp2) wait ] ].  self mouseStillDown: arg1selectionIndex: arg1  | tmp1 tmp2 tmp3 |  arg1 ifNil: [ ^self ].  tmp3 := arg1 min: scroller submorphs size max: 0.  (tmp1 := tmp3 = 0 ifTrue: [ nil ] ifFalse: [ scroller submorphs at: tmp3 ]) ifNotNil: [ (tmp1 bounds top - scroller offset y >= 0 and: [ tmp1 bounds bottom - scroller offset y <= self innerBounds height ]) ifFalse: [ tmp2 := self vTotalScrollRange.              scrollBar value: (tmp2 > 0 ifTrue: [ (tmp3 - 1) * tmp1 height / self vTotalScrollRange truncateTo: scrollBar scrollDelta ] ifFalse: [ 0 ]).              scroller offset: -3 @ (tmp2 * scrollBar value) ] ].  self selectedMorph: tmp1lineIndexOfCharacterIndex: arg1  ^self lineIndexForCharacter: arg1mouseEnter: arg1  owner ifNotNil: [ owner stayUp ifFalse: [ self mouseEnterDragging: arg1 ] ]vResizingString: arg1  ^self layoutMenuPropertyString: arg1 from: self vResizingonLastPage  ^self lastIndex = self nodeList sizetaskList: arg1  taskList := arg1thumbnailOfSize: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self header fullBounds scaledAndCenteredIn: (0 @ 0 extent: arg1).  tmp1 := Form extent: tmp3 extent depth: Display depth.  tmp2 := MatrixTransform2x3 withScale: 1.0.  tmp1 getCanvas transformBy: tmp2 clippingTo: tmp1 boundingBox during: [:arg2 |  arg2 translateBy: self visibleBounds topLeft negated during: [:arg3 |  self container fullDrawOn: arg3 ] ] smoothing: 6.  ^ImageMorph new form: tmp1newPanel  ^self theme newPanelIn: selfreverseTableCells: arg1  self assureTableProperties reverseTableCells: arg1.  self layoutChangedmoveCollapsedWindowsToTaskbar  (self systemWindows select: [:arg1 |  arg1 isCollapsed ]) do: [:arg1 |  arg1           restore;           minimize ]extraSpace  ^extraSpace ifNil: [ 0 @ 0 ]basicButton  | tmp1 |  ^(tmp1 := SimpleButtonMorph new)     clipSubmorphs: true;     color: self pagerColor;     on: #mouseEnter send: #value to: [ tmp1 borderColor: self pagerColor muchDarker ];     on: #mouseLeave send: #value to: [ tmp1 borderColor: self pagerColor ];     target: self;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     listCentering: #leftCenter;     wrapCentering: #center;     layoutInset: 2 @ 0;     cellInset: 2 @ 0;     borderWidth: 1;     borderColor: self pagerColor;     yourselfsetEditView: arg1  editView := arg1scroller  ^scrollergetListElementSelector: arg1  getListElementSelector := arg1maxLength: arg1  maxLength := arg1draggedMorph  draggedMorph ifNil: [ self initDraggedMorph ].  ^draggedMorphresizeToFitString  ^(self resizeToFit ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'resize to fit' translatedbeSticky  self assureExtension sticky: trueisFlexed  ^owner notNil and: [ owner isFlexMorph ]drawSubmorphsOnAthensCanvas: arg1  | tmp1 |  tmp1 := self clippingBounds intersect: arg1 clipRect.  arg1 transformBy: self transform withClip: tmp1 in: self innerBounds during: [:arg2 |  submorphs do: [:arg3 |  arg3 fullDrawOnAthensCanvas: arg2 ] ]defaultColor  ^Color bluehash  ^anchoredMorph identityHashdrawLinesOn: arg1  self hasToggleAtRoot ifFalse: [ ^self ].  arg1 transformBy: scroller transform clippingTo: scroller innerBounds during: [:arg2 |  scroller submorphsDo: [:arg3 |  | tmp1 |              ((arg3 isExpanded and: [ (arg3 nextSibling notNil and: [ arg2 isVisible: (arg3 fullBounds topLeft corner: arg3 nextSibling fullBounds bottomRight) ]) or: [ arg3 nextSibling isNil and: [ (tmp1 := arg3 lastChild) notNil and: [ arg2 isVisible: (arg3 fullBounds topLeft corner: tmp1 fullBounds bottomRight) ] ] ] ]) or: [ (arg2 isVisible: arg3 fullBounds) or: [ arg3 nextSibling notNil and: [ arg2 isVisible: arg3 nextSibling fullBounds ] ] ]) ifTrue: [ arg3 drawLinesOn: arg2 ] ] ] smoothing: scroller smoothingmarried: arg1  married := arg1newEditableDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 ghostText: arg6 getEnabled: arg7 help: arg8  ^self theme newEditableDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: String default: '' ghostText: arg6 getEnabled: arg7 useIndex: false help: arg8defaultColor  ^self theme menuTitleColorFor: nilchangeColorTarget: arg1 selector: arg2 originalColor: arg3 hand: arg4  (UIManager default chooseColor: arg3) ifNotNil: [:arg5 |  arg1 perform: arg2 with: arg5 ]enabled  ^trueexpandAll  children do: #expandAlladdWindow: arg1  arg1 isTopWindow ifTrue: [ SystemWindow passivateTopWindow ].  self tabGroup     addPage: arg1 configureForEmbedding label: (self tabLabelFor: arg1);     selectedPageIndex: self tabGroup pages size.  self isActive ifFalse: [ self tabGroup selectedTab passivate ].  self tabGroup selectedTab on: #startDrag send: #dragTab:event:in: to: self withValue: arg1.  arg1 announcer when: WindowLabelled send: #onWindowLabelChanged: to: selfstoreValue: arg1  ^self owner owner storeValue: arg1hasProportionalLayoutString  | tmp1 |  ^((tmp1 := self layoutPolicy) notNil and: [ tmp1 isProportionalLayout ]) -> 'proportional layout' translatedwantsRoundedCorners  ^self theme currentSettings preferRoundCornerstep  borderDashSpec ifNil: [ ^super step ].  borderDashSpec size < 5 ifTrue: [ ^super step ].  borderDashSpec at: 4 put: borderDashSpec fourth + borderDashSpec fifth.  self changed.  ^super steplistModel  ^client modelreverseTableCells  ^reverseTableCellsactualFont  ^actualFont ifNil: [ TextStyle defaultFont ]forwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1expandSlider  | tmp1 |  tmp1 := self totalSliderArea.  slider extent: (bounds isWide ifTrue: [ ((tmp1 width * interval) asInteger max: self sliderThickness) @ slider height ] ifFalse: [ slider width @ ((tmp1 height * interval) asInteger max: self sliderThickness) ])enabled  ^enabledhandsReverseDo: arg1  ^worldState handsReverseDo: arg1defaultExtent  ^150 @ 120rowAtLocation: arg1  | tmp1 |  tmp1 := arg1 y.  tmp1 < self top ifTrue: [ ^1 ].  ^(tmp1 - self top) // font height + 1 min: listItems size max: 0dropMorphs  self dropMorphs: lastMouseEventveryDeepInner: arg1  super veryDeepInner: arg1.  textStyle := textStyle veryDeepCopyWith: arg1.  text := text veryDeepCopyWith: arg1.  wrapFlag := wrapFlag veryDeepCopyWith: arg1.  paragraph := paragraph veryDeepCopyWith: arg1.  editor := editor veryDeepCopyWith: arg1.  container := container veryDeepCopyWith: arg1.  predecessor := predecessor.  successor := successor.  backgroundColor := backgroundColor veryDeepCopyWith: arg1.  margins := margins veryDeepCopyWith: arg1newMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newMorphListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6dispatchDefault: arg1 with: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  (arg2 fullBounds containsPoint: arg1 position) ifFalse: [ ^#rejected ].  tmp2 := 1.  tmp4 := arg2 submorphs.  tmp5 := false.  [ tmp2 <= tmp4 size ] whileTrue: [ tmp3 := tmp4 at: tmp2.        tmp1 := arg1 transformedBy: (tmp3 transformedFrom: arg2).        (tmp3 processEvent: tmp1 using: self) == #rejected ifFalse: [ tmp5 := true.              tmp1 wasHandled ifTrue: [ arg1 copyHandlerState: tmp1 ].              tmp2 := tmp4 size ].        tmp2 := tmp2 + 1 ].  tmp5 ifFalse: [ tmp5 := arg2 containsPoint: arg1 position event: arg1 ].  tmp5 ifTrue: [ ^arg2 handleEvent: arg1 ].  ^#rejectedselectItem: arg1 event: arg2  self owner ifNotNil: [ | tmp1 |        tmp1 := self owner submorphs select: [:arg3 |  (arg3 isKindOf: self class) and: [ arg3 ~~ self ] ].        tmp1 do: [:arg4 |  arg4 perform: #selectItem:event: withArguments: {nil .                     arg2} inSuperclass: self class superclass ] ].  ^super selectItem: arg1 event: arg2checkboxBorderStyleToUse  ^self selected ifTrue: [ self enabled ifTrue: [ self theme checkboxButtonSelectedBorderStyleFor: self ] ifFalse: [ self theme checkboxButtonSelectedDisabledBorderStyleFor: self ] ] ifFalse: [ self enabled ifTrue: [ self theme checkboxButtonNormalBorderStyleFor: self ] ifFalse: [ self theme checkboxButtonDisabledBorderStyleFor: self ] ]drawOn: arg1  | tmp1 tmp2 |  (isSelected and: [ isEnabled ]) ifTrue: [ arg1 fillRectangle: self bounds fillStyle: self selectionFillStyle.        tmp1 := color negated ] ifFalse: [ tmp1 := color ].  tmp2 := bounds.  tmp2 := tmp2 left: tmp2 left + 4.  self hasIcon ifTrue: [ | tmp3 |        tmp3 := self iconForm.        arg1 translucentImage: tmp3 at: tmp2 left @ (self top + ((self height - tmp3 height) // 2)).        tmp2 := tmp2 left: tmp2 left + tmp3 width + 2 ].  self hasMarker ifTrue: [ tmp2 := tmp2 left: tmp2 left + self submorphBounds width + 8 ].  tmp2 := tmp2 top: (tmp2 top + tmp2 bottom - self fontToUse height) // 2.  arg1 drawString: self contents in: tmp2 font: self fontToUse color: tmp1.  self hasSubMenu ifTrue: [ | tmp4 tmp5 |        tmp4 := self subMenuMarker.        tmp5 := (self right - tmp4 width) @ ((self top + self bottom - tmp4 height) // 2).        tmp5 := tmp5 - (4 @ -1).        arg1 paintImage: tmp4 at: tmp5 ]scrollDeltaWidth  ^10restoreFocus: arg1 in: arg2  arg2 primaryHand keyboardFocus ifNotNil: [ ^self ].  arg1 ifNotNil: [ arg2 primaryHand newKeyboardFocus: arg1 ]testWindowCreationAndDeletion  | tmp1 tmp2 |  tmp1 := 0.  self currentWorld announcer when: WindowOpened do: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 window ].  self currentWorld announcer when: WindowClosed do: [:arg1 |  tmp1 := tmp1 + 10.        tmp2 := arg1 window ].  window := SystemWindow labelled: 'foo'.  window openInWorld.  self assert: tmp1 equals: 1.  self assert: window identicalTo: tmp2.  window delete.  self assert: tmp1 equals: 11.  self assert: window identicalTo: tmp2alpha  ^alphalayout: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  arg1 submorphs ifEmpty: [ ^self ].  tmp1 := arg1 assureTableProperties.  tmp8 := (self minExtentOf: arg1 in: arg2) x.  tmp2 := arg2 width - tmp8 max: 0.  tmp6 := 0.  tmp2 > 0 ifTrue: [ tmp6 := arg1 submorphs size.        tmp3 := tmp6 = 0 ifTrue: [ 0 ] ifFalse: [ tmp2 // tmp6 ].        tmp2 := tmp2 - ((tmp6 - 1) * tmp3) ] ifFalse: [ tmp3 := 0 ].  tmp7 := tmp6 > 0 ifTrue: [ arg2 left ] ifFalse: [ tmp1 listCentering == #center ifTrue: [ arg2 center x - (tmp8 // 2) ] ifFalse: [ tmp1 listCentering == #bottomRight ifTrue: [ arg2 right - tmp8 ] ifFalse: [ arg2 left ] ] ].  tmp4 := arg2 height.  tmp5 := tmp1 cellInset isPoint ifTrue: [ tmp1 cellInset x ] ifFalse: [ tmp1 cellInset ].  arg1 submorphs withIndexDo: [:arg3 :arg4 |  | tmp9 tmp10 tmp11 |        tmp8 := (arg3 width = 0 and: [ tmp6 > 0 ]) ifTrue: [ (arg2 width + arg2 left - tmp7) / (tmp6 - arg4 + 1) ] ifFalse: [ arg3 width ].        tmp11 := tmp7 @ arg2 top extent: tmp8 @ tmp4.        tmp10 := tmp11 origin extent: tmp11 width @ tmp11 height.        tmp9 := tmp1 cellPositioning.        tmp10 := tmp10 align: (tmp10 perform: tmp9) with: (tmp11 perform: tmp9).        arg3 bounds: tmp10.        tmp7 := tmp7 + tmp8 + tmp5 ]autoSize: arg1  autoSize := arg1update: arg1  ^selfright  ^bounds rightcurrentWorld  ActiveWorld ifNotNil: [ ^ActiveWorld ].  ^WorldsetDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedmenuColumn: arg1 row: arg2  arg2 = 0 ifTrue: [ ^nil ].  ^(UIManager default newMenuIn: self table for: self)     add: 'Expand All ' target: self selector: #expandAll;     add: 'Collapse All' target: self selector: #collapseAll;     yourselfaddInHistory: arg1  self removeFromHistory: arg1.  selectionHistory addLast: arg1label: arg1  label := arg1.  self changedrowHeight: arg1  rowHeight := arg1availableBorderStyles  ^#(normalBorderStyle mouseOverBorderStyle pressedBorderStyle disabledBorderStyle selectedBorderStyle selectedPressedBorderStyle selectedMouseOverBorderStyle selectedDisabledBorderStyle)tabSelector: arg1  tabSelector := arg1addToggle: arg1 selector: arg2  self addToggle: arg1 target: defaultTarget selector: arg2 getStateSelector: nil argumentList: EmptyArrayselectLastTab  tabs ifEmpty: [ ^self ].  tabs last selected: truemaxDepth: arg1  maxDepth := arg1isDockingBar  ^trueupdate: arg1  super update: arg1.  arg1 == #selectedIndex ifTrue: [ self tabGroup page activate ]secondarySelectionColor  ^self theme secondarySelectionColorclosestSegmentTo: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := 0.  tmp4 := 0.  tmp1 := tmp2 := nil.  self lineSegmentsDo: [:arg2 :arg3 |  | tmp5 tmp6 |        arg2 = (self vertices at: tmp3 + 1) ifTrue: [ tmp3 := tmp3 + 1 ].        tmp5 := arg1 nearestPointOnLineFrom: arg2 to: arg3.        tmp6 := tmp5 distanceTo: arg1.        (tmp1 isNil or: [ tmp6 < tmp2 ]) ifTrue: [ tmp1 := tmp5.              tmp2 := tmp6.              tmp4 := tmp3 ] ].  ^tmp4mouseEnter: arg1  ^self eventHandler ifNotNil: [ self eventHandler mouseEnter: arg1 fromMorph: self ]deny: arg1 title: arg2  ^self theme denyIn: self text: arg1 title: arg2getEnabledSelector: arg1  getEnabledSelector := arg1.  self updateEnabledcontext: arg1  context := arg1displayFiltered: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self valueOfProperty: #matchString.  tmp2 := self menuItems select: [:arg2 |  | tmp4 |        tmp4 := tmp1 isEmpty or: [ arg2 contents includesSubstring: tmp1 caseSensitive: false ].        arg2 isEnabled: tmp4.        tmp4 ].  tmp3 := self valueOfProperty: #feedbackMorph.  tmp3 ifNil: [ tmp3 := TextMorph new           autoFit: true;           color: Color darkGray.        self           addLine;           addMorphBack: tmp3 lock.        self setProperty: #feedbackMorph toValue: tmp3.        self fullBounds ].  tmp3 contents: '<' , tmp1 , '>'.  tmp1 isEmpty ifTrue: [ tmp3 delete.        self lastSubmorph delete.        self removeProperty: #feedbackMorph ].  (arg1 notNil and: [ tmp2 size >= 1 ]) ifTrue: [ self selectItem: tmp2 first event: arg1 ]wrapCentering: arg1  wrapCentering := arg1isAutoFit  ^self valueOfProperty: #autoFitContents ifAbsent: [ true ]invalidRect: arg1 from: arg2  hasChanged := true.  arg2 == self ifTrue: [ ^self ].  damageRecorder recordInvalidRect: arg1drawOn: arg1  (owner notNil and: [ owner containsPoint: self position ]) ifTrue: [ super drawOn: arg1 ]newKeyboardFocus: arg1  | tmp1 |  keyboardFocus == arg1 ifTrue: [ ^self ].  tmp1 := keyboardFocus.  keyboardFocus := arg1.  tmp1 ifNotNil: [ tmp1 keyboardFocusChange: false ].  arg1 ifNotNil: [ arg1 keyboardFocusChange: true ]addTargetingMenuItems: arg1 hand: arg2  arg1 addLine.  arg1 add: 'set target' selector: #targetWith:.  target ifNotNil: [ arg1 add: 'clear target' translated selector: #clearTarget ]potentialEmbeddingTargets  | tmp1 tmp2 |  (tmp1 := (tmp2 := self topRendererOrSelf) owner) ifNil: [ ^#() ].  ^(tmp1 morphsAt: tmp2 referencePosition behind: tmp2 unlocked: true) reject: [:arg1 |  arg1 isFlexMorph ]updateIsNeeded  ^totalRepaint or: [ invalidRects notEmpty ]collapseAndRefresh  self collapse.  self refreshTablethemeChanged  super themeChanged.  toolbar themeChanged.  container     color: self theme lightBaseColor;     changed.  contentsWrapper     color: self theme lightBaseColor;     changeddoButtonAction: arg1  target ifNil: [ ^self ].  actionSelector ifNil: [ ^self ].  Cursor normal showWhile: [ | tmp1 |        tmp1 := actionSelector numArgs > arguments size ifTrue: [ arguments copyWith: arg1 ] ifFalse: [ arguments ].        target perform: actionSelector withArguments: tmp1 ]transform: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := (arg1 left + (arg1 width * leftFraction) + leftOffset) rounded asInteger.  tmp2 := (arg1 right - (arg1 width * (1 - rightFraction)) + rightOffset) rounded asInteger.  tmp3 := (arg1 top + (arg1 height * topFraction) + topOffset) rounded asInteger.  tmp4 := (arg1 bottom - (arg1 height * (1 - bottomFraction)) + bottomOffset) rounded asInteger.  tmp2 < tmp1 ifTrue: [ tmp2 := tmp1 ].  tmp4 < tmp3 ifTrue: [ tmp4 := tmp3 ].  ^Rectangle left: tmp1 right: tmp2 top: tmp3 bottom: tmp4dropMorphs: arg1  self submorphsReverseDo: [:arg2 |  self dropMorph: arg2 event: arg1 ]setVertices: arg1  vertices := arg1.  handles ifNotNil: [ self           removeHandles;           addHandles ].  self computeBoundsacceptDroppingMorph: arg1 event: arg2  complexContents acceptDroppingObject: arg1 complexContents.  arg1 delete.  self highlightForDrop: falsehatchForm  ^self class hatchFormrowHeight: arg1 default: arg2  ^self table dataSource rowHeight: arg1theme: arg1  self theme = arg1 ifFalse: [ self setProperty: #theme toValue: arg1.        self themeChanged ]selectionChanged  self sharesFindReplace ifTrue: [ self editor findReplaceService changed: #findReplaceSelection ].  self useExtraSelection ifTrue: [ self refreshExtraSelection ].  super selectionChangednewHSVASelector: arg1 help: arg2  ^self theme newHSVASelectorIn: self color: arg1 help: arg2setCenterOfRotation: arg1 with: arg2  | tmp1 |  arg1 hand obtainHalo: self.  arg1 hand showTemporaryCursor: nil.  (arg2 hasProperty: #dragByCenterOfRotation) ifFalse: [ tmp1 := innerTarget transformFromWorld globalPointToLocal: arg2 center.        innerTarget setRotationCenterFrom: tmp1 ].  arg2 removeProperty: #dragByCenterOfRotation.  self endInteractionselect: arg1  self isEnabled ifFalse: [ ^self ].  ^super select: arg1forwardDirection  | tmp1 |  ^(tmp1 := self renderedMorph) == self ifTrue: [ 0.0 ] ifFalse: [ ^tmp1 forwardDirection ]selectionChanged  self changedactivateAndForceLabelToShow  self activate.  bounds top < 0 ifTrue: [ self position: self position x @ 0 ]basicGetListElementSelector: arg1  getListElementSelector := arg1treeMorph: arg1 pageSize: arg2  self treeMorph: arg1.  self pageSize: arg2privateDelete  owner ifNotNil: [ owner removeMorph: self ]removePaneSplitters  self splitters do: [:arg1 |  arg1 delete ]keyStroke: arg1 from: arg2  self selectedNode ifNotNil: [:arg3 |  arg3 keyStroke: arg1 from: arg2 ]layoutLeftToRight: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 tmp16 tmp17 tmp18 tmp19 tmp20 tmp21 tmp22 |  tmp18 := properties minCellSize asPoint.  tmp9 := tmp18 x.  tmp10 := tmp18 y.  tmp18 := properties maxCellSize asPoint.  tmp11 := tmp18 x.  tmp12 := tmp18 y.  tmp1 := properties cellInset asPoint x.  tmp2 := arg2 extent.  tmp13 := 0.  tmp21 := false.  tmp20 := 0.  tmp14 := tmp19 := 0.  tmp22 := tmp16 := nil.  tmp3 := [:arg3 |  | tmp23 tmp24 tmp25 |  tmp25 := arg3 layoutProperties ifNil: [ arg3 ].  tmp25 disableTableLayout ifFalse: [ tmp13 := tmp13 + 1.        tmp17 := LayoutCell new target: arg3.        tmp25 hResizing == #spaceFill ifTrue: [ tmp17 hSpaceFill: true.              tmp15 := arg3 spaceFillWeight.              tmp17 extraSpace: tmp15.              tmp20 := tmp20 + tmp15 ] ifFalse: [ tmp17 hSpaceFill: false ].        tmp25 vResizing == #spaceFill ifTrue: [ tmp21 := true ].        tmp18 := arg3 minExtent.        tmp24 := tmp18 x.        tmp23 := tmp18 y.        tmp24 < tmp9 ifTrue: [ tmp24 := tmp9 ] ifFalse: [ tmp24 > tmp11 ifTrue: [ tmp24 := tmp11 ] ].        tmp23 < tmp10 ifTrue: [ tmp23 := tmp10 ] ifFalse: [ tmp23 > tmp12 ifTrue: [ tmp23 := tmp12 ] ].        tmp17 cellSize: tmp24.        tmp16 ifNil: [ tmp22 := tmp17 ] ifNotNil: [ tmp16 nextCell: tmp17 ].        tmp16 := tmp17.        tmp14 := tmp14 + tmp24.        tmp23 > tmp19 ifTrue: [ tmp19 := tmp23 ] ] ].  properties reverseTableCells ifTrue: [ arg1 submorphsReverseDo: tmp3 ] ifFalse: [ arg1 submorphsDo: tmp3 ].  tmp13 > 1 ifTrue: [ tmp14 := tmp14 + ((tmp13 - 1) * tmp1) ].  (properties hResizing == #shrinkWrap and: [ properties rubberBandCells or: [ tmp20 isZero ] ]) ifTrue: [ tmp2 := tmp14 @ (tmp2 y max: tmp19) ].  (properties vResizing == #shrinkWrap and: [ properties rubberBandCells or: [ tmp21 not ] ]) ifTrue: [ tmp2 := (tmp2 x max: tmp14) @ tmp19 ].  tmp4 := arg2 left.  tmp5 := arg2 top.  tmp15 := tmp2 y - tmp19.  tmp15 < 0 ifTrue: [ tmp15 := 0 ].  tmp15 > 0 ifTrue: [ tmp21 ifTrue: [ tmp19 := tmp2 y ] ifFalse: [ tmp6 := properties wrapCentering.              tmp6 == #bottomRight ifTrue: [ tmp5 := tmp5 + tmp15 ].              tmp6 == #center ifTrue: [ tmp5 := tmp5 + (tmp15 // 2) ] ] ].  tmp15 := tmp2 x - tmp14.  tmp15 < 0 ifTrue: [ tmp15 := 0 ].  tmp7 := 0.  tmp15 > 0 ifTrue: [ tmp20 isZero ifTrue: [ tmp6 := properties listCentering.              tmp6 == #bottomRight ifTrue: [ tmp4 := tmp4 + tmp15 ].              tmp6 == #center ifTrue: [ tmp4 := tmp4 + (tmp15 // 2) ] ] ifFalse: [ tmp7 := tmp15 asFloat / tmp20 asFloat ] ].  tmp13 := 0.  tmp15 := tmp16 := 0.  tmp17 := tmp22.  [ tmp17 == nil ] whileFalse: [ tmp13 := tmp13 + 1.        tmp14 := tmp17 cellSize.        (tmp7 > 0 and: [ tmp17 hSpaceFill ]) ifTrue: [ tmp15 := (tmp16 := tmp15) + (tmp7 * tmp17 extraSpace).              tmp8 := tmp15 truncated - tmp16 truncated.              tmp14 := tmp14 + tmp8 ].        tmp17 target layoutInBounds: (tmp4 @ tmp5 extent: tmp14 @ tmp19).        tmp4 := tmp4 + tmp14 + tmp1.        tmp17 := tmp17 nextCell ]newMultistateButton  ^self theme newMultistateButtonIn: selfslider  ^sliderwrapItem: arg1  ^self wrapBlockOrSelector isBlock ifTrue: [ wrapBlockOrSelector cull: arg1 ] ifFalse: [ wrapBlockOrSelector isSymbol ifTrue: [ | tmp1 |              tmp1 := wrapBlockOrSelector numArgs.              tmp1 isZero ifTrue: [ arg1 perform: wrapBlockOrSelector ] ifFalse: [ tmp1 = 1 ifTrue: [ arg1 perform: wrapBlockOrSelector with: arg1 ] ifFalse: [ self error: 'Wrong number of arguments' ] ] ] ifFalse: [ arg1 ] ]rotationDegrees: arg1  | tmp1 tmp2 |  (tmp2 := self valueOfProperty: #referencePosition) ifNil: [ self setProperty: #referencePosition toValue: (tmp2 := self bounds center) ].  tmp1 := (MorphicTransform offset: tmp2 negated) withAngle: (arg1 - self forwardDirection) degreesToRadians.  self setVertices: (vertices collect: [:arg2 |  (tmp1 transform: arg2) - tmp1 offset ]).  self forwardDirection: arg1currentCursor  ^worldState currentCursoractionMap: arg1  actionMap := arg1borderWidth: arg1  | tmp1 |  tmp1 := 2 * arg1 + image extent.  bounds extent = tmp1 ifFalse: [ super extent: tmp1 ].  super borderWidth: arg1heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]newGroupbox: arg1  ^self theme newGroupboxIn: self label: arg1children: arg1  childrenBlock := arg1defaultColor  ^self theme windowColor lightericonFor: arg1  iconBlock ifNil: [ ^nil ].  ^iconBlock value: (self elementAt: arg1)generateButton  ^expanded ifTrue: [ self expandedButton ] ifFalse: [ self collapsedButton ]target: arg1  target := arg1matchesExtension: arg1  (self extension isNil or: [ arg1 isNil ]) ifTrue: [ ^false ].  FileSystem disk isCaseSensitive ifTrue: [ ^extension = arg1 ] ifFalse: [ ^extension sameAs: arg1 ]updateAvailableRows: arg1  availableRows := availableRows + arg1.  arg1 isZero ifFalse: [ self tableRefresh ]drawOn: arg1  self drawTabOn: arg1.  self drawSubMorphOn: arg1commandKeyTypedIntoMenu: arg1  ^self modifierKeyPressed: arg1listSpacing  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #none ] ifNotNil: [ tmp1 listSpacing ]colorForInsets  ^owner colorForInsetsreleaseCachedState  context  ^contextselectionFrameForRow: arg1  | tmp1 |  tmp1 := self drawBoundsForRow: arg1.  tmp1 := tmp1 intersect: self bounds.  tmp1 := self bounds: tmp1 in: listSource.  tmp1 := self bounds: ((tmp1 left: listSource innerBounds left) right: listSource innerBounds right) from: listSource.  ^tmp1mouseOver: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseOver from: arg2setMultipleSelection: arg1  multipleSelection := arg1initialize  enabled := true.  super initializescrollSelectionToRow: arg1  arg1 = 0 ifTrue: [ ^self ].  self scrollToShow: (self listMorph drawBoundsForRow: arg1)startDrag: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersmouseDown: arg1  super mouseDown: arg1.  self enabled ifFalse: [ ^self ].  self down: truewithTopSeparator  topSeparator := trueexpandAll  (self windowsSatisfying: [:arg1 |  arg1 isCollapsed ]) reverseDo: [:arg1 |  arg1 collapseOrExpand.        self displayWorld ]borderStyle: arg1  borderStyle := arg1drawOn: arg1  container withHLines ifTrue: [ arg1 frameRectangle: self selectionFrame width: 1 colors: {Color veryLightGray .               Color transparent} dashes: #(1 2) ].  self hasToggle ifTrue: [ self drawToggleOn: arg1 in: self toggleRectangle ].  container listManager isCheckList ifTrue: [ self drawCheckOn: arg1 ]expandPath: arg1  arg1 ifNil: [ ^false ].  ^arg1 treeNodeHead = self complexContents withoutListWrapper ifFalse: [ false ] ifTrue: [ arg1 treeNodeTail ifNil: [ ^true ].        (self isExpanded not and: [ self canExpand ]) ifTrue: [ self toggleExpandedState.              container innerWidgetChanged ].        self children anySatisfy: [:arg2 |  arg2 expandPath: arg1 treeNodeTail ] ]opacityString  ^self isOpaque -> 'opaque' translatedmouseDown: arg1  ^arg1 shiftPressed ifTrue: [ ((owner isKindOf: PolygonMorph) and: [ owner includesHandle: self ]) ifTrue: [ ^super mouseDown: arg1 ].        self toggleHandles.        handles ifNil: [ ^self ].        vertices withIndexDo: [:arg2 :arg3 |  ((handles at: arg3 * 2 - 1 ifAbsent: [ ^self ]) containsPoint: arg1 cursorPoint) ifTrue: [ arg1 hand newMouseFocus: (handles at: arg3 * 2 - 1) ] ] ] ifFalse: [ super mouseDown: arg1 ]defer: arg1  self owner ifNotNil: [ self owner defer: arg1 ] ifNil: [ UIManager default defer: arg1 ]getSelector: arg1  self objectToView: objectToView viewSelector: arg1property: arg1  property := arg1releaseKeyboardFocus  self newKeyboardFocus: nilcomputeInsetColors  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self color asColor.  tmp2 := Color white.  tmp3 := Color black.  tmp4 := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  tmp4 := tmp4 asInteger.  tmp5 := Array new: tmp4 * 2.  tmp7 := 0.5 / tmp4.  0 to: tmp4 - 1 do: [:arg1 |  tmp6 := true ifTrue: [ 0.5 + (tmp7 * arg1) ] ifFalse: [ 0.5 + (tmp7 * (tmp4 - arg1)) ].        tmp5 at: arg1 + 1 put: (tmp1 mixed: tmp6 with: tmp3).        tmp5 at: tmp5 size - arg1 put: (tmp1 mixed: tmp6 with: tmp2) ].  ^tmp5sortElements: arg1  self subclassResponsibilityaddMorph: arg1 fullFrame: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp6 := arg2 asLayoutFrame.  tmp5 := self class borderWidth.  tmp1 := tmp6 leftOffset.  tmp2 := tmp6 rightOffset.  tmp3 := tmp6 bottomOffset.  tmp4 := tmp6 topOffset.  tmp6 rightFraction = 1 ifTrue: [ tmp6 rightOffset: tmp2 - tmp5 - self theme windowRightOffset ].  tmp6 leftFraction = 0 ifTrue: [ tmp6 leftOffset: tmp1 + tmp5 + self theme windowLeftOffset ] ifFalse: [ tmp6 leftFraction = 1 ifFalse: [ tmp6 leftOffset: tmp1 + ProportionalSplitterMorph splitterWidth ] ].  tmp6 bottomFraction = 1 ifTrue: [ tmp6 bottomOffset: tmp3 - tmp5 - self theme windowBottomOffset ].  tmp6 topFraction = 0 ifTrue: [ tmp6 topOffset: tmp4 + self theme windowTopOffset ] ifFalse: [ tmp6 topFraction = 1 ifFalse: [ tmp6 topOffset: tmp4 + ProportionalSplitterMorph splitterWidth ] ].  super addMorph: arg1 fullFrame: tmp6.  paneMorphs := paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: arg1).  arg1 borderStyle: (self theme windowPaneBorderStyleFor: arg1 in: self).  self addMorphBack: arg1.  self owner ifNotNil: [ self addPaneSplitters ]updateForNewPageSize: arg1  pageSize := arg1 max: 1.  self changed: #pageSizetargetPoint  ^self position - targetOffsetthemeChanged  self color: self defaultColor.  super themeChangedavoidsOcclusions: arg1  avoidsOcclusions := arg1.  self releaseCachedStateosWindow  ^niltab  ^tabnavigateVisibleWindowForward  self nextVisibleWindow ifNil: [ SystemWindow passivateTopWindow ] ifNotNil: [:arg1 |  arg1 activate ]naturalCubicSlopesOf: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := arg1 size.  tmp5 < 3 ifTrue: [ self error: 'Less than 3 points makes a poor curve' ].  tmp1 := arg1.  tmp2 := Array new: tmp5.  tmp3 := Array new: tmp5.  tmp4 := Array new: tmp5.  tmp2 at: 1 put: 1.0 / 2.0.  2 to: tmp5 - 1 do: [:arg2 |  tmp2 at: arg2 put: 1.0 / (4.0 - (tmp2 at: arg2 - 1)) ].  tmp2 at: tmp5 put: 1.0 / (2.0 - (tmp2 at: tmp5 - 1)).  tmp3 at: 1 put: 3.0 * ((tmp1 at: 2) - (tmp1 at: 1)) * (tmp2 at: 1).  2 to: tmp5 - 1 do: [:arg2 |  tmp3 at: arg2 put: (3.0 * ((tmp1 at: arg2 + 1) - (tmp1 at: arg2 - 1)) - (tmp3 at: arg2 - 1)) * (tmp2 at: arg2) ].  tmp3 at: tmp5 put: (3.0 * ((tmp1 at: tmp5) - (tmp1 at: tmp5 - 1)) - (tmp3 at: tmp5 - 1)) * (tmp2 at: tmp5).  tmp4 at: tmp5 put: (tmp3 at: tmp5).  (1 to: tmp5 - 1) reverseDo: [:arg2 |  tmp4 at: arg2 put: (tmp3 at: arg2) - ((tmp2 at: arg2) * (tmp4 at: arg2 + 1)) ].  ^tmp4contents  getContentsSelector ifNil: [ ^#() ].  ^self sendToModel: getContentsSelectordrawText: arg1 onAthensCanvas: arg2 in: arg3 color: arg4  | tmp1 |  tmp1 := arg2 asCanvasWrapper.  (self enabled not and: [ self theme disabledItemStyle = #inset ]) ifTrue: [ tmp1           drawString: arg1 in: arg3 font: self fontToUse color: arg4 muchLighter lighter;           drawString: arg1 in: (arg3 translateBy: -1) font: self fontToUse color: arg4 ] ifFalse: [ tmp1 drawString: arg1 in: arg3 font: self fontToUse color: arg4 ]morph  ^morphnewBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 help: arg7  ^self newBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: nil help: arg7listCentering: arg1  listCentering := arg1hasFocus  ^editor notNilbeResizable  resizable := truenewAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6 entryCompletion: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6 entryCompletion: arg7isIndexVisible: arg1  ^self container isRowIndexVisible: arg1forLinesIn: arg1 do: arg2  (self lineIndexForPoint: arg1 topLeft) to: (self lineIndexForPoint: arg1 bottomRight) do: [:arg3 |  arg2 value: (lines at: arg3) ]alwaysShowVScrollBar: arg1  self setProperty: #vScrollBarAlways toValue: arg1.  self vHideOrShowScrollBarsetValue: arg1  ^self perform: #setValue: withArguments: {arg1} inSuperclass: SlideraddPage: arg1 label: arg2  arg1     hResizing: #spaceFill;     vResizing: #spaceFill.  self pages add: arg1.  self tabSelectorMorph addTab: arg2updateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]layoutInset  ^0update: arg1  (arg1 == getListSelector or: [ arg1 == getListElementSelector ]) ifTrue: [ self updateList.        ^self ].  arg1 == getIndexSelector ifTrue: [ self selectionIndex: self getCurrentSelectionIndex.        ^self ].  arg1 == #allSelections ifTrue: [ self selectionIndex: self getCurrentSelectionIndex.        ^self changed ].  arg1 isArray ifFalse: [ ^self ].  arg1 size == 2 ifFalse: [ ^self ].  arg1 first = #setMultipleSelection: ifTrue: [ self setMultipleSelection: arg1 second ]rightFlush  textStyle rightFlushhandlerForBlueButtonDown: arg1  ^selfsetInvokingView: arg1  self items do: [:arg2 |  arg2 hasSubMenu ifTrue: [ arg2 subMenu setInvokingView: arg1 ] ifFalse: [ arg2 arguments isEmptyOrNil ifTrue: [ arg2 arguments: (Array with: arg2 selector with: arg1).                    arg2 selector: #perform:orSendTo: ] ] ]tabSelected: arg1  self isMultiSelection ifTrue: [ self tabResetSelection: arg1 ] ifFalse: [ self selectedTab ifNotNil: [ self selectedTab selected: false ].        self addInHistory: arg1.        self adjustLayout.        self triggerEvent: #tabSelected with: arg1 ]initialize  super initialize.  self     changeTableLayout;     listDirection: #leftToRight;     cellPositioning: #center;     cellInset: 2;     borderWidth: 0;     color: Color transparent;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     extent: 20 @ 16noteNewOwner: arg1  super noteNewOwner: arg1.  self submorphs do: [:arg2 |  arg2 adjustLayoutBounds ]alignRightEdges  | tmp1 |  tmp1 := (selectedItems collect: [:arg1 |  arg1 right ]) max.  selectedItems do: [:arg1 |  arg1 right: tmp1 ].  self changedhExtraScrollRange  ^12openDialogOn: arg1  rootClass := arg1.  ^self openDialogWindowIn: self currentWorld title: 'All Object subclasses'drawSubmenuMarkerOn: arg1  delete  activeSubMenu ifNotNil: [ activeSubMenu delete ].  ^super deleterefreshTable  dataSource tableRefresh.  dataSource table resetFunctiongetEnabledSelector  ^getEnabledSelector ifNil: [ nil ]drawOn: arg1  arg1 fillRectangle: self bounds fillStyle: self fillStyle borderStyle: self borderStyle.  (self cachedForm width = 0 or: [ self cachedForm height = 0 ]) ifTrue: [ ^self ].  self layout == #tiled ifTrue: [ arg1 fillRectangle: self innerBounds fillStyle: (AlphaInfiniteForm with: self cachedForm) ] ifFalse: [ arg1 clipBy: self innerBounds during: [:arg2 |  arg2 translucentImage: self cachedForm at: self layoutPosition ] ]setUp  super setUp.  morph := Morph newnewYesButton  ^self newYesButtonFor: selfhandleMouseMove: arg1  arg1 wasHandled ifTrue: [ ^self ].  (arg1 anyButtonPressed and: [ arg1 hand mouseFocus == self ]) ifFalse: [ ^self ].  arg1 wasHandled: true.  self mouseMove: arg1.  (self handlesMouseStillDown: arg1) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue arguments: {arg1 copy resetHandlerFields} stepTime: 1 ]removeGrips  self     removeCornerGrips;     removeEdgeGripsrootItem  ^rootItemlocalSubmorphBounds  localBounds ifNil: [ self submorphsDo: [:arg1 |  localBounds ifNil: [ localBounds := arg1 fullBounds ] ifNotNil: [ localBounds := localBounds quickMerge: arg1 fullBounds ] ] ].  ^localBoundsnewBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 help: arg7  ^self newBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: nil help: arg7serverMode  ^self class serverModehandlesMouseWheel: arg1  ^falseopenAsIs  self openAsIsIn: self currentWorldscrollPoint: arg1  | tmp1 tmp2 |  tmp1 := self roomToMove.  bounds isWide ifTrue: [ tmp1 width = 0 ifTrue: [ ^self ] ] ifFalse: [ tmp1 height = 0 ifTrue: [ ^self ] ].  tmp2 := arg1 position - (self sliderThickness // 2) adhereTo: tmp1.  self descending ifFalse: [ self setValue: (bounds isWide ifTrue: [ (tmp2 x - tmp1 left) asFloat / tmp1 width ] ifFalse: [ (tmp2 y - tmp1 top) asFloat / tmp1 height ]) ] ifTrue: [ self setValue: (bounds isWide ifTrue: [ (tmp1 right - tmp2 x) asFloat / tmp1 width ] ifFalse: [ (tmp1 bottom - tmp2 y) asFloat / tmp1 height ]) ]startGap: arg1  startGap := arg1keyStrokeArrowRight: arg1  (self selectionModeStrategy is: self selectedIndex beforeColumn: self numberOfColumns) ifFalse: [ ^self ].  self resetFunction.  self selectIndex: (self selectionModeStrategy selectableIndexAfter: self selectedIndex) event: arg1handleMouseMove: arg1  arg1 wasHandled ifTrue: [ ^self ].  arg1 hand hasSubmorphs ifTrue: [ ^self ].  arg1 wasHandled: true.  self mouseMove: arg1.  (arg1 anyButtonPressed and: [ arg1 hand mouseFocus == self ]) ifFalse: [ ^self ].  (self handlesMouseStillDown: arg1) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue arguments: {arg1 copy resetHandlerFields} stepTime: 1 ]heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]printOn: arg1  super printOn: arg1.  arg1     space;     print: firstIndex;     nextPutAll: ' to: ';     print: lastIndexextraScrollRange  ^self scrollDeltaHeightboxExtent  ^18 @ 18 * self displayScaleFactorisComposite  ^truestoreValue  ^storeValuetestIsBeforeColumn  self assert: (strategy is: #(3 7) beforeColumn: 9).  self deny: (strategy is: #(3 7) beforeColumn: 4).  self deny: (strategy is: #(3 7) beforeColumn: 7)newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newListIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: arg5 help: arg6handleListenEvent: arg1  arg1 isMouse ifFalse: [ ^self ].  arg1 hand hasSubmorphs ifTrue: [ ^self ].  self isTopWindow ifFalse: [ self lockInactivePortions ].  arg1 hand removeMouseListener: selfselectedTab  ^self tabSelectorMorph selectedTabreverseTableCells  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ false ] ifNotNil: [ tmp1 reverseTableCells ]cornerStyle: arg1  cornerStyle := arg1bottomRightColor  ^width = 1 ifTrue: [ self color twiceDarker ] ifFalse: [ self color darker ]visibleTabs  ^self tabs select: [:arg1 |  arg1 owner notNil ]initialize  super initialize.  indentLevel := 0.  isExpanded := falsenewLabelGroup: arg1  ^self theme newLabelGroupIn: self for: arg1cellColumn: arg1 row: arg2  | tmp1 |  tmp1 := FTCellMorph new     addMorphBack: (self elementAt: arg2) asMorph;     yourself.  (self needSeparatorBefore: arg2) ifTrue: [ tmp1 withTopSeparator ].  ^tmp1labelOfSize: arg1  ^self theme buttonLabelForText: (self model taskbarLabel truncateWithElipsisTo: arg1)changeDirectionHandles  ^self wantsDirectionHandles: self wantsDirectionHandles notrootClass  ^rootClass ifNil: [ rootClass := Object ]currentIcon  ^TabMorph perform: (#refreshIcon , progress asString) asSymbolis: arg1 beforeColumn: arg2  ^falseaddLabelItemsTo: arg1 hand: arg2  privateAddAllMorphs: arg1 atIndex: arg2  submorphs := Array new: submorphs size + arg1 size streamContents: [:arg3 |  1 to: arg2 do: [:arg4 |  arg3 nextPut: (submorphs atWrap: arg4) ].        arg3 nextPutAll: arg1.        arg2 + 1 to: submorphs size do: [:arg4 |  arg3 nextPut: (submorphs atWrap: arg4) ] ].  arg1 do: [:arg5 |  arg5 fullBounds.        arg5 privateOwner: self ].  self layoutChangedgrabTransform  ^owner ifNil: [ self transform ] ifNotNil: [ owner grabTransform composedWithLocal: self transform ]is: arg1 beforeColumn: arg2  ^self subclassResponsibilityinsertNewMorphs: arg1  arg1 do: [:arg2 |  arg2           font: self font;           extent: arg2 minWidth @ arg2 minHeight ].  ^super insertNewMorphs: arg1measureContents  ^super measureContents + 2asKeyCombination  ^KMKeyCombination fromKeyboardEvent: selfbeReplacementFor: arg1  | tmp1 tmp2 |  (tmp1 := arg1 world) ifNil: [ ^self ].  uncollapsedMorph := arg1.  self setLabel: arg1 externalName.  arg1 delete.  tmp1 addMorphFront: self.  self collapseOrExpand.  (tmp2 := arg1 valueOfProperty: #collapsedPosition ifAbsent: [ nil ]) ifNotNil: [ self position: tmp2 ]beCenter  self option: #centershowBalloon: arg1  | tmp1 |  self showBalloon: arg1 hand: ((tmp1 := self world) ifNotNil: [ tmp1 activeHand ])hash  ^super hash bitXor: self borders hashembedInWindow  | tmp1 tmp2 |  tmp2 := self world.  tmp1 := (SystemWindow labelled: self defaultLabel) model: nil.  tmp1 bounds: (self position - (0 @ tmp1 labelHeight + tmp1 borderWidth) corner: self bottomRight + tmp1 borderWidth).  tmp1 addMorph: self frame: (0 @ 0 extent: 1 @ 1).  tmp1 updatePaneColors.  tmp2 addMorph: tmp1.  tmp1 activatebottomLeft: arg1  self position: arg1 x @ (arg1 y - self height)action: arg1 named: arg2  actionBlock := arg1.  self initializeActionButtonNamed: arg2listSource: arg1  listSource := arg1.  self listChangedsetCharacters: arg1  self getCharacters = arg1 ifFalse: [ self newContents: arg1 ]gtInspectorIcon  ^self class systemIconlineWidth  ^self borderWidthtextMorph  ^textMorphseasideMimeDocument  ^self imageForm seasideMimeDocumentbeginsWith: arg1 fromList: arg2  | tmp1 |  tmp1 := self userString ifNil: [ (self submorphs collect: [:arg3 |  arg3 userString ]) detect: [:arg4 |  arg4 notNil ] ifNone: [ '' ] ].  ^tmp1 asString beginsWith: arg1 fromList: arg2selectableIndexBellow: arg1  ^self subclassResponsibilityicon  ^model iconOfNode: selfshouldBeHighlighted  ^isSelected and: [ isEnabled ]previousMorphInWindow  ^self submorphBefore notNil ifTrue: [ self submorphBefore lastSubmorphRecursive ] ifFalse: [ self owner ]removeVertex: arg1  | tmp1 |  vertices size < 2 ifTrue: [ ^self ].  tmp1 := vertices copyWithout: arg1.  tmp1 size caseOf: {([ 1 ] -> [ tmp1 := {tmp1 first .               tmp1 first} ]) .         ([ 0 ] -> [ tmp1 := {arg1 .               arg1} ])} otherwise: [  ].  self setVertices: tmp1previousMorphInWindow  ^self hasSubmorphs ifTrue: [ self lastSubmorphRecursive ]hasNoLayoutString  ^self layoutPolicy isNil -> 'no layout' translatedcopyWeakly  ^#(formerOwner)computeShadow  | tmp1 tmp2 tmp3 |  tmp2 := self bounds.  tmp3 := textMorph.  tmp1 := (Display defaultCanvasClass extent: tmp2 extent depth: 1) asShadowDrawingCanvas: Color black.  tmp1 translateBy: tmp2 topLeft negated during: [:arg1 |  | tmp4 |        self fillsOwner ifTrue: [ arg1 fullDrawMorph: (tmp3 owner copyWithoutSubmorph: tmp3) ] ifFalse: [ arg1 fillRectangle: textMorph bounds color: Color black ].        self avoidsOcclusions ifTrue: [ tmp4 := arg1 form deepCopy.              arg1 form fillWhite.              tmp3 owner submorphsInFrontOf: tmp3 do: [:arg2 |  (textMorph isLinkedTo: arg2) ifTrue: [  ] ifFalse: [ arg1 fullDrawMorph: arg2 ] ].              tmp4 displayOn: arg1 form at: 0 @ 0 rule: Form reverse ] ].  shadowForm := tmp1 form offset: tmp2 topLeft.  vertProfile := shadowForm yTallyPixelValue: 1 orNot: false.  rectangleCache := Dictionary new.  ^shadowFormsortDataSource: arg1  (arg1 table columns copyWithout: self) do: #resetSorting.  self sortingStrategy sortDataSource: arg1relabel  | tmp1 |  tmp1 := UIManager default request: 'New title for this window' translated initialAnswer: labelString.  tmp1 isEmptyOrNil ifTrue: [ ^self ].  self setLabel: tmp1followHand: arg1 forEachPointDo: arg2 lastPointDo: arg3 withCursor: arg4  hand := arg1.  hand showTemporaryCursor: arg4.  borderWidth := 0.  color := Color transparent.  pointBlock := arg2.  lastPointBlock := arg3.  self position: hand lastEvent cursorPoint - (self extent // 2)boundsForBalloon  container ifNil: [ ^super boundsForBalloon ].  ^self boundsInWorld intersect: container boundsInWorld ifNone: [ self boundsInWorld ]enableFilterWithAction: arg1  self enableFilterWithAction: arg1 named: 'Validate.'source: arg1  source := arg1drawOn: arg1  temporaryCursor ifNil: [ arg1 paintImage: NormalCursor at: bounds topLeft ] ifNotNil: [ arg1 paintImage: temporaryCursor at: bounds topLeft ]tearDown  morph := nil.  super tearDownnewRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 label: arg4 help: arg5  ^self newRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: nil label: arg4 help: arg5removeMouseListener: arg1  self mouseListeners: (self removeListener: arg1 from: self mouseListeners)isExpanded  ^isExpandedavoidVisibleBordersAtEdge  ^avoidVisibleBordersAtEdgearrows  ^arrowscomputeCellArrangement: arg1 in: arg2 horizontal: arg3 target: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 tmp16 tmp17 tmp18 |  tmp15 := arg1 key.  tmp1 := arg1 value.  properties wrapDirection == #none ifTrue: [ tmp2 := SmallInteger maxVal ] ifFalse: [ tmp2 := arg3 ifTrue: [ arg2 width ] ifFalse: [ arg2 height ].        tmp2 < tmp15 x ifTrue: [ tmp2 := tmp15 x ] ].  tmp3 := properties cellSpacing.  (tmp3 == #globalRect or: [ tmp3 = #globalSquare ]) ifTrue: [ ^self computeGlobalCellArrangement: tmp1 in: arg2 horizontal: arg3 wrap: tmp2 spacing: tmp3 ].  tmp4 := Array new writeStream.  tmp18 := properties cellInset asPoint.  arg3 ifFalse: [ tmp18 := tmp18 transposed ].  tmp11 := tmp12 := nil.  tmp5 := 0 @ 0.  tmp7 := 0.  tmp8 := 1.  tmp6 := 0.  tmp16 := tmp17 := false.  [ tmp8 <= tmp1 size ] whileTrue: [ tmp13 := tmp7.        tmp10 := tmp1 at: tmp8.        tmp14 := tmp5 max: tmp10 cellSize.        (tmp3 == #localRect or: [ tmp3 == #localSquare ]) ifTrue: [ tmp3 == #localSquare ifTrue: [ tmp9 := tmp14 x max: tmp14 y ] ifFalse: [ tmp9 := tmp14 x ].              tmp7 := (tmp6 + 1) * tmp9 ] ifFalse: [ tmp7 := tmp7 + tmp10 cellSize x ].        (tmp7 + (tmp6 * tmp18 x) > tmp2 and: [ tmp11 notNil ]) ifTrue: [ (tmp3 == #localSquare or: [ tmp3 == #localRect ]) ifTrue: [ tmp3 == #localSquare ifTrue: [ tmp5 := (tmp5 x max: tmp5 y) asPoint ].                    tmp11 do: [:arg5 |  arg5 cellSize: tmp5 ] ].              tmp13 := tmp13 + ((tmp6 - 1) * tmp18 x).              tmp11 nextCell ifNotNil: [ tmp11 nextCell do: [:arg5 |  arg5 addExtraSpace: tmp18 x @ 0 ] ].              tmp12 := LayoutCell new.              tmp12 cellSize: tmp13 @ tmp5 y.              tmp12 hSpaceFill: tmp16.              tmp12 vSpaceFill: tmp17.              tmp12 nextCell: tmp11.              tmp4 position = 0 ifFalse: [ tmp12 addExtraSpace: 0 @ tmp18 y ].              tmp4 nextPut: tmp12.              tmp11 := nil.              tmp5 := 0 @ 0.              tmp7 := 0.              tmp6 := 0.              tmp16 := tmp17 := false ] ifFalse: [ tmp11 ifNil: [ tmp11 := tmp12 := tmp10 ] ifNotNil: [ tmp12 nextCell: tmp10.                    tmp12 := tmp10 ].              tmp8 := tmp8 + 1.              tmp6 := tmp6 + 1.              tmp5 := tmp14.              tmp16 := tmp16 or: [ tmp10 hSpaceFill ].              tmp17 := tmp17 or: [ tmp10 vSpaceFill ] ] ].  tmp11 ifNotNil: [ tmp12 := LayoutCell new.        tmp7 := tmp7 + ((tmp6 - 1) * tmp18 x).        tmp11 nextCell ifNotNil: [ tmp11 nextCell do: [:arg5 |  arg5 addExtraSpace: tmp18 x @ 0 ] ].        tmp12 cellSize: tmp7 @ tmp5 y.        tmp12 hSpaceFill: tmp16.        tmp12 vSpaceFill: tmp17.        tmp12 nextCell: tmp11.        tmp4 position = 0 ifFalse: [ tmp12 addExtraSpace: 0 @ tmp18 y ].        tmp4 nextPut: tmp12 ].  tmp4 := tmp4 contents.  properties listSpacing == #equal ifTrue: [ tmp9 := tmp4 inject: 0 into: [:arg6 :arg5 |  arg6 max: arg5 cellSize y ].        tmp4 do: [:arg5 |  arg5 cellSize: arg5 cellSize x @ tmp9 ] ].  ^tmp4pressedImage  ^pressedImagemouseMove: arg1  | tmp1 |  tmp1 := target point: arg1 position - positionOffset from: owner.  target setConstrainedPosition: tmp1 hangOut: truedataSource  ^dataSourceactualClass  ^FTDescendingSortingStateshowsWhenNeeded  ^self showState == #whenNeededokToChange  ^self tabGroup pages allSatisfy: [:arg1 |  arg1 model okToChange ]parent  ^parenthasFocus  ^falsehandlesKeyboard: arg1  ^trueenabled  ^super enabled and: [ self isLocked not ]minHeight  ^self fontToUse height rounded max: super minHeightadd: arg1 icon: arg2 subMenu: arg3  ^self add: arg1 icon: arg2 help: nil subMenu: arg3newButtonFor: arg1 action: arg2 label: arg3 help: arg4  ^self newButtonFor: arg1 getState: nil action: arg2 arguments: nil getEnabled: nil label: arg3 help: arg4setSelectedSelector  ^setSelectionSelectornewRow: arg1  ^self theme newRowIn: self for: arg1newToolbarHandle  ^self theme newToolbarHandleIn: selfmouseEnter: arg1  self canResizeColumn ifFalse: [ ^self ].  (owner notNil and: [ owner bounds containsPoint: arg1 position ]) ifTrue: [ super mouseEnter: arg1 ]hResizingString: arg1  ^self layoutMenuPropertyString: arg1 from: self hResizingisSortingEnabled  ^trueupdate: arg1  arg1 == self getColorSelector ifTrue: [ self updateColor.        ^self ]isResizeable  ^isResizeable ifNil: [ isResizeable := self defaultIsResizeable ]mouseMove: arg1  | tmp1 |  self enabled ifFalse: [ ^self ].  tmp1 := self scrollerSubMorphFromPoint: arg1 position.  arg1 hand hasSubmorphs ifFalse: [ (self innerBounds containsPoint: arg1 position) ifTrue: [ self listManager mouseMove: arg1 on: tmp1 ] ].  (self dropEnabled and: [ arg1 hand hasSubmorphs ]) ifFalse: [ ^super mouseMove: arg1 ].  potentialDropMorph ifNotNil: [ (potentialDropMorph containsPoint: (potentialDropMorph point: arg1 position from: self)) ifTrue: [ ^self ] ].  self mouseLeaveDragging: arg1.  (self containsPoint: arg1 position) ifTrue: [ self mouseEnterDragging: arg1 ]recalculateVerticalScrollBarVisibilityIfHidden: arg1  self container calculateExactVisibleRows >= self dataSource numberOfRows ifTrue: [ self isVerticalScrollBarVisible ifTrue: [ self removeMorph: self verticalScrollBar ].        self resizeContainer.        arg1 value ] ifFalse: [ self isVerticalScrollBarVisible ifFalse: [ self resizeVerticalScrollBar.              self addMorph: self verticalScrollBar ] ]initializeFromStringMorph: arg1  fontNumber := 1.  self setActualFont: (arg1 font ifNil: [ TextStyle defaultFont ]).  emphasis := actualFont emphasis.  textColor := arg1 coloropenFullscreen  ^FullscreenMorph new     setContentMorph: self;     openInWorlddefaultIsResizeable  ^truetasks: arg1  tasks := arg1drawMouseDownHighlightOn: arg1  self highlightedForMouseDown ifTrue: [ container ifNil: [ ^super drawMouseDownHighlightOn: arg1 ].        self storeValue ifNil: [ self storeValue: self complexContents selected not ].        self complexContents selected: self storeValue.        arg1 frameRectangle: self selectionFrame width: 1 colors: {container mouseDownHighlightColor .               Color transparent} dashes: #(1 1) ]unrotatedLength  vertices size = 2 ifTrue: [ ^(vertices second - vertices first) r ].  ^((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) heightisModalInvokationDone  ^self valueOfProperty: #isModalInvokationDone ifAbsent: [ false ]griddingOnOff  griddingOn := self griddingOn not.  self changedselected  ^selected ifNil: [ selected := false ]newString: arg1  ^self theme newStringIn: self label: arg1 font: self theme labelFont style: #plainmenuButtonWidth  ^16 * self displayScaleFactorinitialize  leftOffset := rightOffset := topOffset := bottomOffset := 0.  leftFraction := topFraction := 0.  rightFraction := bottomFraction := 1level  ^parentNode ifNil: [ 1 ] ifNotNil: [ parentNode level + 1 ]worldRenderer: arg1  worldRenderer := arg1.  worldRenderer activateborderRaised  self borderStyle: (BorderStyle raised width: 2)extraSpaceForActions  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := 1.  self hasMenu ifTrue: [ tmp2 := tmp2 + 1.        tmp1 := tmp1 + self menuIcon width ].  self actions do: [:arg1 |  tmp1 := tmp1 + arg1 icon width.        tmp2 := tmp2 + 1 ].  ^tmp1 + (tmp2 * self actionOffset)keyCharacter  ^Unicode value: charCodefindSubmorphFor: arg1  ^scroller submorphThat: [:arg2 |  arg1 between: arg2 top and: arg2 bottom ] ifNone: [  ]fullBounds  | tmp1 |  tmp1 := super fullBounds.  submorphs isEmpty ifTrue: [ ^tmp1 ] ifFalse: [ ^tmp1 topLeft corner: tmp1 bottomRight + self shadowOffset ]drawOnAthensCanvas: arg1  | tmp1 |  tmp1 := self owner ifNil: [ self paneColor ] ifNotNil: [ self owner color isTransparent ifTrue: [ self owner paneColor ] ifFalse: [ self owner color ] ].  arg1 clipBy: self bounds during: [ arg1 pathTransform restoreAfter: [ arg1 pathTransform translateX: self left Y: self top + self fontToUse ascent.              arg1                 setFont: self fontToUse;                 setPaint: (self enabled ifTrue: [ self color ] ifFalse: [ tmp1 muchDarker ]);                 drawString: self contents ] ]handleKeystroke: arg1  arg1 wasHandled ifTrue: [ ^self ].  self allowsKeymapping ifTrue: [ self dispatchKeystrokeForEvent: arg1 ].  arg1 wasHandled ifTrue: [ ^self ].  (self handlesKeyStroke: arg1) ifFalse: [ ^self ].  self keyStroke: arg1.  arg1 wasHandled: trueisActive  ^falseaddSubmorphsAfter: arg1 fromCollection: arg2 allowSorting: arg3  | tmp1 tmp2 tmp3 |  tmp1 := nil.  tmp3 := (arg3 and: [ sortingSelector notNil ]) ifTrue: [ (arg2 asSortedCollection: [:arg4 :arg5 |  (arg4 perform: sortingSelector) <= (arg5 perform: sortingSelector) ]) asOrderedCollection ] ifFalse: [ arg2 ].  tmp2 := OrderedCollection new.  tmp3 do: [:arg6 |  tmp1 := self indentingItemClass basicNew initWithContents: arg6 prior: tmp1 forList: self indentLevel: arg1 indentLevel + 1.        tmp2 add: tmp1 ].  scroller addAllMorphs: tmp2 after: arg1.  ^tmp2noteRemovalOfAll: arg1  self listManager noteRemovalOfAll: arg1.  arg1 do: [:arg2 |  arg2 delete ].  scroller removeAllMorphsIn: arg1.  self adjustSubmorphPositionswidth  ^textMorph owner widthsentTo: arg1  type == #keystroke ifTrue: [ ^arg1 handleKeystroke: self ].  type == #keyDown ifTrue: [ ^arg1 handleKeyDown: self ].  type == #keyUp ifTrue: [ ^arg1 handleKeyUp: self ].  ^super sentTo: arg1initialize  super initialize.  growingOrRotating := false.  self borderStyle: (SimpleBorder width: 2 color: self theme menuSelectionColor)drawOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self text.  tmp4 := self class symbolFont.  tmp3 := self boundsForKeyText: tmp1 string font: tmp4.  tmp2 := Paragraph new     compose: tmp1 style: (TextStyle fontArray: {tmp4}) from: 1 in: (0 @ 0 corner: tmp3 corner);     yourself.  arg1 paragraph: tmp2 bounds: tmp3 color: self colorhideOverEditableTextCursor  self currentHand showTemporaryCursor: nilupdateSelectionIndex  self basicUpdateSelectionIndex.  self refreshisTranslucentButNotTransparent  backgroundColor ifNil: [ ^true ].  (backgroundColor isColor and: [ backgroundColor isTranslucentButNotTransparent ]) ifTrue: [ ^true ].  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) ifTrue: [ ^true ].  ^falsesortableOnProperty: arg1  self sortingStrategy: (FTPropertyColumnSortingStrategy column: self property: arg1)drawOnAthensCanvas: arg1  submorphs isEmpty ifTrue: [ super drawOnAthensCanvas: arg1 ]mouseLeaveDragging: arg1  (self dragEnabled or: [ arg1 hand hasSubmorphs ]) ifFalse: [ self listMorph mouseDownRow: nil ].  (self dropEnabled and: [ arg1 hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: arg1 ].  self resetPotentialDropRow.  arg1 hand releaseMouseFocus: selfnoMorePotentialDropTarget  isPotentialDropTarget := false.  self container invalidRect: self visibleBoundsactiveTitleFillStyle  ^self theme windowActiveTitleFillStyleFor: selfrootItemsTest  ^rootClass allSubclasses asArray sort: [:arg1 :arg2 |  arg1 name < arg2 name ]asString  string ifNotNil: [ ^string ].  getStringSelector ifNil: [ ^super asString ].  ^self sendToModel: getStringSelectorstayUp: arg1  stayUp := arg1.  titleMorph ifNotNil: [ titleMorph updatePinForm ]enabled  ^enabledchunkSize: arg1  self pager ifNil: [ arg1 ifNotNil: [ self addNavigationPane: (MorphTreeChunkPager on: self pageSize: arg1) ] ] ifNotNil: [ arg1 ifNil: [ self removePager ] ifNotNil: [ self pager changePageSize: arg1 ] ]acceptOnCR  ^falseselectedMorph: arg1  self unhighlightSelection.  selectedMorph := arg1.  self highlightSelectionballoonText  ^model balloonTextForNode: selflayout: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  arg1 submorphs ifEmpty: [ ^self ].  tmp1 := arg1 assureTableProperties.  tmp7 := arg1 minWidth @ arg1 minHeight - arg1 extent + arg1 layoutBounds extent max: 0 @ 0.  tmp6 := arg2 origin extent: (arg2 extent max: tmp7).  tmp10 := 0.  tmp10 := (self minExtentOf: arg1 in: tmp6) x.  tmp2 := tmp6 width - tmp10 max: 0.  tmp8 := 0.  tmp2 > 0 ifTrue: [ tmp8 := arg1 submorphs inject: 0 into: [:arg3 :arg4 |  arg3 + (arg4 hResizing == #spaceFill ifTrue: [ 1 ] ifFalse: [ 0 ]) ].        tmp3 := tmp8 = 0 ifTrue: [ 0 ] ifFalse: [ tmp2 // tmp8 ].        tmp2 := tmp2 - ((tmp8 - 1) * tmp3) ] ifFalse: [ tmp3 := 0 ].  tmp9 := tmp8 > 0 ifTrue: [ tmp6 left ] ifFalse: [ tmp1 listCentering == #center ifTrue: [ tmp6 center x - (tmp10 // 2) ] ifFalse: [ tmp1 listCentering == #bottomRight ifTrue: [ tmp6 right - tmp10 ] ifFalse: [ tmp6 left ] ] ].  tmp4 := tmp6 height.  tmp5 := tmp1 cellInset isPoint ifTrue: [ tmp1 cellInset x ] ifFalse: [ tmp1 cellInset ].  arg1 submorphs with: cachedMinExtents do: [:arg4 :arg5 |  | tmp11 tmp12 tmp13 tmp14 |        tmp10 := arg4 hResizing == #spaceFill ifTrue: [ tmp8 := tmp8 - 1.              arg5 x + (tmp8 > 0 ifTrue: [ tmp2 ] ifFalse: [ tmp3 ]) ] ifFalse: [ arg5 x ].        tmp14 := tmp9 @ tmp6 top extent: tmp10 @ tmp4.        ((tmp12 := arg4 vResizing) == #shrinkWrap or: [ arg4 bounds ~= tmp14 ]) ifTrue: [ ((tmp12 == #shrinkWrap) not and: [ arg4 extent = tmp14 extent ]) ifTrue: [ arg4 position: tmp14 origin ] ifFalse: [ tmp13 := arg4 bounds.                    arg4 hResizing == #spaceFill ifTrue: [ tmp13 := tmp14 origin extent: tmp14 width @ tmp13 height ].                    tmp12 == #spaceFill ifTrue: [ tmp13 := tmp13 origin extent: tmp13 width @ tmp14 height ].                    tmp12 == #shrinkWrap ifTrue: [ tmp13 := tmp13 origin extent: tmp13 width @ arg5 y ].                    tmp11 := tmp1 cellPositioning.                    tmp13 := tmp13 align: (tmp13 perform: tmp11) with: (tmp14 perform: tmp11).                    arg4 bounds: tmp13 ] ].        tmp9 := tmp9 + tmp10 + tmp5 ]addActions: arg1  actions addAll: arg1sendFocusEvent: arg1 to: arg2 clear: arg3  | tmp1 tmp2 |  tmp2 := arg2 world ifNil: [ ^arg3 value ].  tmp2 becomeActiveDuring: [ ActiveHand := self.        ActiveEvent := arg1.        tmp1 := arg2 handleFocusEvent: (arg1 transformedBy: (arg2 transformedFrom: self)) ].  ^tmp1keyStroke: arg1 from: arg2  | tmp1 |  tmp1 := arg1 keyCharacter.  tmp1 = $b ifTrue: [ self browseItem.        ^true ].  tmp1 = $i ifTrue: [ self inspectItem.        ^true ].  tmp1 = $I ifTrue: [ self exploreItem.        ^true ].  ^falsecaptureEventsWhile: arg1  ^self captureEventsUntil: [:arg2 |  (arg1 value: arg2) not ]sortingStrategy  ^sortingStrategyabort: arg1 title: arg2  ^self theme abortIn: self text: arg1 title: arg2printOn: arg1  super printOn: arg1.  arg1     nextPut: $[;     nextPutAll: (self dataSource toString: data);     nextPut: $]slide: arg1  firstIndex := firstIndex + arg1.  lastIndex := lastIndex + arg1initialize  super initialize.  labelClickable := true.  self     borderWidth: 2;     borderColor: Color transparent;     enabled: true;     changeTableLayout;     listDirection: #leftToRight;     wrapCentering: #center;     cellInset: 4;     labelMorph: self newLabelMorph;     buttonMorph: self newButtonMorph;     on: #click send: #updateButton: to: self;     on: #mouseMove send: #updateButton: to: self;     on: #mouseUp send: #updateButton: to: selfselectionColor  ^self valueOfProperty: #selectionColor ifAbsent: [  ]hasHalo  ^self hasProperty: #hasHaloborderColor  ^borderColorboxExtent  label ifNil: [ ^14 @ 14 * self displayScaleFactor ].  ^14 @ 14 * self displayScaleFactor max: label height @ label heightbeExplicit  self subclassResponsibilityupdateLabel  self model ifNotNil: [ self getLabelSelector ifNotNil: [ self label: (self model perform: self getLabelSelector) ] ]visibleTabRange  ^visibleTabRangecollapseBoxHit  self isCollapsed ifTrue: [ self playRestoreUpSound ] ifFalse: [ self playMinimizeSound ].  self collapseOrExpandupdateTasks  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self worldMorphs asOrderedCollection.  tmp4 := (tmp1 collect: [:arg1 |  arg1 taskbarTask ]) reject: [:arg1 |  arg1 isNil ].  self tasks: tmp4.  tmp2 := self orderedTasks difference: self tasks.  tmp3 := self tasks difference: self orderedTasks.  (tmp3 isEmpty and: [ tmp2 isEmpty ]) ifTrue: [ ^self ].  tmp3 copy do: [:arg2 |  self orderedTasks detect: [:arg3 |  arg3 morph = arg2 morph ] ifFound: [:arg3 |  self orderedTasks replaceAll: arg3 with: arg2.              tmp2 remove: arg3.              tmp3 remove: arg2 ] ].  self orderedTasks     removeAll: tmp2;     addAll: tmp3 reversed.  self updateTaskButtons.  self defer: [ self layoutChanged ]selectedMorph  ^self selectedMorphList ifNotEmpty: [:arg1 |  arg1 last ] ifEmpty: [  ]horizontalPlacement  ^horizontalPlacementupdateTaskButtons  self taskList removeAllMorphs.  self tasks do: [:arg1 |  | tmp1 |        tmp1 := arg1 taskListButtonFor: self.        tmp1 ifNotNil: [ self taskList addMorphBack: tmp1 ] ]newText: arg1  ^self theme newTextIn: self text: arg1stationarySetup  self actWhen: #startDrag.  self cornerStyle: #rounded.  self borderNormal.  self on: #mouseEnter send: #borderThick to: self.  self on: #mouseDown send: nil to: nil.  self on: #mouseLeave send: #borderNormal to: self.  self on: #mouseLeaveDragging send: #borderNormal to: self.  self on: #mouseUp send: #borderThick to: selfopenOn: arg1  | tmp1 |  self rootClass: arg1.  tmp1 := StandardWindow new model: self.  tmp1 title: arg1 name , ' hierarchy'.  tmp1 addMorph: self treeMorph fullFrame: LayoutFrame identity.  tmp1 themeChanged.  tmp1 openInWorld.  ^tmp1lineHeight  ^bottom - topcontents: arg1  ^self contentsAsIs: arg1hasKeyboardFocus  ^((self world ifNil: [ ^false ]) activeHand ifNil: [ ^false ]) keyboardFocus = selfselectedItems  ^selectedItemsnormalFillStyle  ^self theme buttonNormalFillStyleFor: selfshowState: arg1  showState := arg1drawOnFormCanvas: arg1  vertices size < 1 ifTrue: [ self error: 'a polygon must have at least one point' ].  closed & color isTransparent not ifTrue: [ arg1 stencil: self filledForm at: bounds topLeft - 1 color: color ].  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) ifTrue: [ arg1 stencil: self borderForm at: bounds topLeft color: borderColor ] ifFalse: [ self drawBorderOn: arg1 ].  self arrowForms do: [:arg2 |  arg1 stencil: arg2 at: arg2 offset color: (borderColor isColor ifTrue: [ borderColor ] ifFalse: [ color ]) ]selectMorph: arg1 multiple: arg2  | tmp1 tmp2 |  self lastClickedMorph: arg1.  arg1 ifNil: [ self emptySelection.        ^nil ].  arg1 selected ifTrue: [ arg2 ifTrue: [ self removeFromSelection: arg1 ] ifFalse: [ tmp2 := self selectedMorphList size > 1.              tmp1 := arg1 path collect: [:arg3 |  arg3 complexContents ].              (self autoDeselection or: [ tmp2 ]) ifTrue: [ self emptySelection.                    tmp2 ifTrue: [ self addToSelection: arg1 ] ifFalse: [ tmp1 := nil ] ] ] ] ifFalse: [ arg2 ifFalse: [ self emptySelection ].        self addToSelection: arg1.        tmp1 := arg1 path collect: [:arg3 |  arg3 complexContents ] ].  self selectionChanged.  ^tmp1keyboardFocus  ^keyboardFocusballoonFont  ^self valueOfProperty: #balloonFont ifAbsent: [ self defaultBalloonFont ]displayArea  ^self worldState worldRenderer usableAreachangeParagraphAnchor  | tmp1 |  tmp1 := self textAnchorType == #paragraph ifTrue: [ #document ] ifFalse: [ #paragraph ].  owner isTextMorph ifTrue: [ owner anchorMorph: self at: self position type: tmp1 ]nodeCollapseRequest: arg1  arg1 nodes ifEmpty: [ self collapseAll ] ifNotEmpty: [:arg2 |  self collapseNodePath: arg2 ]expandAll  self expand.  self children do: #expandAllnewTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: arg5  ^self theme newTextEditorIn: self for: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: arg5setSelection: arg1  selection := arg1prepareToTrackCenterOfRotation: arg1 with: arg2  arg1 hand obtainHalo: self.  arg1 shiftPressed ifTrue: [ self removeAllHandlesBut: arg2 ] ifFalse: [ arg2 setProperty: #dragByCenterOfRotation toValue: true.        self startDrag: arg1 with: arg2 ].  arg1 hand showTemporaryCursor: Cursor blankwasHandled  ^wasHandledelementAt: arg1  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := nil.  tmp2 := [:arg2 |  arg2 do: [:arg3 |  (tmp1 := tmp1 + 1) = arg1 ifTrue: [ ^arg3 ] ifFalse: [ tmp2 value: arg3 children ] ] ].  tmp2 value: rootItems.  SubscriptOutOfBounds signal: arg1value  ^valueshowHScrollBarOnlyWhenNeeded: arg1  self setProperty: #noHScrollBarPlease toValue: arg1.  self setProperty: #hScrollBarAlways toValue: arg1.  self hHideOrShowScrollBarisEnabled: arg1  isEnabled = arg1 ifTrue: [ ^self ].  isEnabled := arg1.  self color: (arg1 ifTrue: [ Color black ] ifFalse: [ Color gray ])highlighted: arg1  highlighted := arg1selectAllRowIndexes  self deprecated: 'Use #selectAll instead' transformWith: '`@receiver selectAllRowIndexes' -> '`@receiver selectAll'.  ^self selectAllacceptDroppingObject: arg1  ^model dropNode: arg1 on: selfcomputedHeightFromContents  | tmp1 |  tmp1 := 0.  self submorphsDo: [:arg1 |  tmp1 := tmp1 max: arg1 height ].  ^tmp1drawLineFrom: arg1 to: arg2 on: arg3  | tmp1 |  tmp1 := (arg2 truncated quadrantOf: arg1 truncated) > 2 ifTrue: [ self topLeftColor ] ifFalse: [ self bottomRightColor ].  arg3 line: arg1 to: arg2 width: self width color: tmp1leftFlush  textStyle leftFlushdefaultColor  ^Color transparentorderedSelectedTabs  ^tabs select: [:arg1 |  arg1 selected ]selectedTabs  ^(selectionHistory last: numberOfSelectedTabs) reversedtype  ^#(windowMetricChange windowClose windowIconise windowActivated windowPaint) at: action ifAbsent: [ #windowEventUnknown ]numberOfRows  self hasDataSource ifFalse: [ ^0 ].  ^self dataSource numberOfRowsupdateHeaderRow  | tmp1 tmp2 tmp3 |  self canRefreshValues ifFalse: [ ^self ].  headerRow := nil.  tmp1 := self table columns.  tmp2 := OrderedCollection new.  tmp3 := self calculateColumnWidths.  (self exposedColumnsRange: tmp3) do: [:arg1 |  | tmp4 tmp5 tmp6 |        tmp4 := tmp1 at: arg1.        tmp6 := tmp3 at: arg1.        tmp5 := self table dataSource headerColumn: tmp4.        tmp5 ifNil: [ ^self ].        tmp5           color: self table headerColor;           width: tmp6.        tmp2 addLast: tmp5.        FTDisplayColumn column: tmp4 width: tmp6 ].  headerRow := (FTTableHeaderRowMorph table: self table)     privateOwner: self;     addAllMorphs: tmp2;     yourselfsliderExtent  ^slider extenttabs: arg1  tabs := arg1testExtent  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := Morph new.  tmp2 := Morph new.  tmp3 := 100.000001.  tmp4 := 100.000001000001.  tmp5 := 100.000001000002.  tmp1 extent: tmp3 @ tmp3.  tmp6 := tmp1 bounds.  tmp2 extent: tmp4 @ tmp5.  tmp7 := tmp2 bounds.  self assert: tmp7 equals: tmp6addMorph: arg1 centeredNear: arg2  | tmp1 tmp2 |  tmp1 := Rectangle center: arg2 extent: arg1 fullBounds extent.  tmp2 := tmp1 amountToTranslateWithin: bounds.  arg1 position: tmp1 origin + tmp2.  self addMorph: arg1step  alpha <= fadingFactor ifTrue: [ ^self delete ].  alpha := alpha - fadingFactor.  self changedtoggle  self active: self active notdefaultTreeMorph  ^super defaultTreeMorph     multiSelection: true;     autoMultiSelection: true;     yourselfitalic  self changeEmphasis: #italichandsDo: arg1  ^hands do: arg1addToggleItemsToHaloMenu: arg1  super addToggleItemsToHaloMenu: arg1.  arg1 addUpdating: #enabledString target: self selector: #toggleEnabledopenFindDialog  self sharesFindReplace ifTrue: [ (self findReplaceDialog on: self) open ] ifFalse: [ self flash ]getContentsSelector  ^getContentsSelectorextent: arg1  super extent: arg1.  label ifNotNil: [ label position: self center - (label extent // 2) ]labelClickable: arg1  labelClickable := arg1oldScrollingIndex: arg1  oldScrollingIndex := arg1balloonText  ^nilselectedMorphList  ^self listManager selectedMorphListdragSelectionColor  ^Color magentagetIconSelector: arg1  getIconSelector := arg1minimumExtent  | tmp1 |  (textStyle isNil or: [ borderWidth isNil or: [ self paragraph lines isEmpty ] ]) ifTrue: [ ^9 @ 16 ].  tmp1 := 9 @ self paragraph lines first lineHeight ceiling + (borderWidth * 2).  ^((0 @ 0 extent: tmp1) expandBy: margins) extentminExtentVertical: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  tmp7 := properties minCellSize asPoint.  tmp2 := tmp7 x.  tmp3 := tmp7 y.  tmp7 := properties maxCellSize asPoint.  tmp4 := tmp7 x.  tmp5 := tmp7 y.  tmp1 := properties cellInset asPoint.  tmp6 := 0.  tmp8 := tmp9 := 0.  arg1 submorphsDo: [:arg2 |  | tmp10 tmp11 |        arg2 disableTableLayout ifFalse: [ tmp6 := tmp6 + 1.              tmp7 := arg2 minExtent.              tmp10 := tmp7 x.              tmp11 := tmp7 y.              tmp10 < tmp2 ifTrue: [ tmp10 := tmp2 ] ifFalse: [ tmp10 > tmp4 ifTrue: [ tmp10 := tmp4 ] ].              tmp11 < tmp3 ifTrue: [ tmp11 := tmp3 ] ifFalse: [ tmp11 > tmp5 ifTrue: [ tmp11 := tmp5 ] ].              tmp9 := tmp9 + tmp11.              tmp10 > tmp8 ifTrue: [ tmp8 := tmp10 ] ] ].  tmp6 > 1 ifTrue: [ tmp9 := tmp9 + ((tmp6 - 1) * tmp1 y) ].  ^minExtentCache := tmp8 @ tmp9vScrollBarValue: arg1  | tmp1 |  tmp1 := atBottom.  self atBottom: arg1 >= self verticalScrollbarFrontier.  tmp1 ~= atBottom ifTrue: [ self buildPanel ]selection: arg1  self setSelection: arg1.  self requestView: MorphTreeChangeRequest updateSelectionFromModelstate: arg1  arg1 == state ifTrue: [ ^self ].  state := arg1.  self invalidRect: boundslabelBottomOffset  ^5 * self displayScaleFactorisLabelled  ^truekeystrokeActionSelector: arg1  keystrokeActionSelector := arg1clipSubmorphs  ^clipSubmorphsstyle  ^#simpleowner  ^ownerdisable  self enabled: falsewidth: arg1  width := arg1longMessage: arg1 title: arg2  ^self theme longMessageIn: self text: arg1 title: arg2enabled  ^truedoFullRepaint  damageRecorder doFullRepainttextSize  ^sizeresetSorting  self sortingStrategy resetborderThick  self borderStyle: (BorderStyle width: 2 color: self raisedColor twiceDarker)positionInWorld  ^self pointInWorld: self positionlabel: arg1  self label isEmpty ifTrue: [ self forceRefreshOnNextChange ].  self labelMorph contents: arg1.  self changedkeyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self focusChangedsimulateKeyStroke: arg1  | tmp1 |  tmp1 := KeyboardEvent new setType: #keystroke buttons: 0 position: 0 @ 0 keyValue: arg1 charCode charCode: arg1 charCode hand: ActiveHand stamp: 0.  self keyStroke: tmp1mouseEnterDragging: arg1  self eventHandler ifNotNil: [ ^self eventHandler mouseEnterDragging: arg1 fromMorph: self ]subMorph: arg1  subMorph := arg1date: arg1  date := arg1offImage  | tmp1 tmp2 |  tmp1 := CheckboxButtonMorph new     privateOwner: self owner;     adoptPaneColor: self paneColor;     selected: false.  tmp2 := Form extent: tmp1 extent depth: 32.  tmp2 fillColor: (Color white alpha: 0.003922).  tmp2 getCanvas fullDrawMorph: tmp1.  ^tmp2leftMargin  ^self leftcomputeArrowFormAt: arg1 from: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp2 := self arrowBoundsAt: arg1 from: arg2.  tmp3 := ((tmp2 first rectangle: tmp2 last) encompass: tmp2 second) expandBy: 1.  tmp4 := Form extent: tmp3 extent asIntegerPoint.  tmp5 := (BitBlt toForm: tmp4)     sourceForm: nil;     fillColor: Color black;     combinationRule: Form over;     width: 1;     height: 1.  tmp6 := tmp3 topLeft.  tmp1 := tmp2 last - tmp6.  tmp2 do: [:arg3 |  tmp5 drawFrom: tmp1 to: arg3 - tmp6.        tmp1 := arg3 - tmp6 ].  tmp4 convexShapeFill: Color black.  ^tmp4 offset: tmp3 topLeftgtInspectorMappingsIn: arg1  < gtInspectorPresentationOrder: 95>  (self hasProperty: #kmDispatcher) ifFalse: [ ^self ].  self kmDispatcher gtInspectorMappingsIn: arg1initializePagingArea  pagingArea := Morph newBounds: self totalSliderArea color: (Color r: 0.6 g: 0.6 b: 0.8).  pagingArea on: #mouseDown send: #scrollPageInit: to: self.  pagingArea on: #mouseUp send: #finishedScrolling to: self.  self addMorph: pagingArea.  pagingArea cornerStyle: (self theme scrollbarPagingAreaCornerStyleIn: self window).  pagingArea on: #mouseUp send: #finishedScrolling: to: self.  self on: #mouseEnter send: #mouseEnterPagingArea: to: self.  self on: #mouseLeave send: #mouseLeavePagingArea: to: selfisCheckList  ^isCheckList ifNil: [ isCheckList := false ]doButtonAction  resizeContainerFrom: arg1 to: arg2  ^arg1 corner: arg2 x @ (arg2 y - self fieldHeigh)selectedItems: arg1  self listModel okToDiscardEdits ifFalse: [ ^self ].  self emptySelection.  (self nodeMorphsWithAllNodeItems: arg1) ifNotEmpty: [:arg2 |  self addAllToSelection: arg2 ].  lastClickedMorph ifNil: [ lastClickedMorph := self selectedMorphList ifEmpty: [  ] ifNotEmpty: [ self selectedMorphList last ] ]removeFromHistory: arg1  selectionHistory remove: arg1 ifAbsent: [  ]prepareForRotating  ^self addFlexShellmouseUp: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlerschooseDirectory: arg1 path: arg2  ^self theme chooseDirectoryIn: self title: arg1 path: arg2tableContainer  ^self table containerhandleMouseMove: arg1  ^self dispatchDefault: arg1 with: morphmouseMove: arg1  self canResizeColumn ifFalse: [ ^self ].  arg1 hand temporaryCursor ifNil: [ ^self ].  traceMorph ifNil: [ traceMorph := Morph newBounds: (self bounds withHeight: container height).        traceMorph color: self theme fastTableColumnResizingColor.        traceMorph borderWidth: 0.        container addMorph: traceMorph ].  traceMorph position: (arg1 cursorPoint x - lastMouse second x) @ traceMorph position ychanged  container ifNil: [ super changed ] ifNotNil: [ container invalidRect: self selectionFrame ]hasToggleAtRoot  ^hasToggleAtRoot ifNil: [ hasToggleAtRoot := self roots anySatisfy: [:arg1 |  arg1 hasToggle ] ]veryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  target := arg1 references at: target ifAbsent: [ target ].  arguments := arguments collect: [:arg2 |  arg1 references at: arg2 ifAbsent: [ arg2 ] ]noticeMouseOver: arg1 event: arg2  mouseOverHandler ifNil: [ ^self ].  mouseOverHandler noticeMouseOver: arg1 event: arg2inARightColumn: arg1  self setAsColumn     vResizing: #shrinkWrap;     layoutInset: 1;     wrapCentering: #bottomRight;     cellPositioning: #topCenter.  arg1 do: [:arg2 |  self addMorphBack: arg2 ]sortingIcon  ^self context morphicIconNamed: #arrowUpcontainsPoint: arg1  | tmp1 |  ^(super containsPoint: arg1) and: [ tmp1 := SystemWindow borderWidth.        ((self bounds translateBy: tmp1 negated @ tmp1) containsPoint: arg1) not ]contentString: arg1  arg1 ifNil: [ self removeProperty: #contentString ] ifNotNil: [ self setProperty: #contentString toValue: arg1 ]nextTokenFrom: arg1 direction: arg2  ^self editor nextTokenFrom: arg1 direction: arg2scrollByKeyboard: arg1  (arg1 controlKeyPressed or: [ arg1 commandKeyPressed ]) ifFalse: [ ^false ].  arg1 keyValue = 30 ifTrue: [ scrollBar scrollUp: 3.        ^true ].  arg1 keyValue = 31 ifTrue: [ scrollBar scrollDown: 3.        ^true ].  ^falseaddToSelection  self triggerEvent: #tabAddedToSelection with: selflayoutSymbols  ^#(#center #tiled #scaled #scaledAspect #topLeft #topCenter #topRight #rightCenter #bottomRight #bottomCenter #bottomLeft #leftCenter)empty  self subclassResponsibilitybeIconLeft  iconPosition := #left.  self update: getIconSelectoruserString  ^contentsindentingItemClass  ^IndentingListItemMorphdragHand: arg1  dragHand := arg1invokeAt: arg1 in: arg2 allowKeyboard: arg3  | tmp1 tmp2 |  tmp2 := arg2 primaryHand keyboardFocus.  self popUpAt: arg1 forHand: arg2 primaryHand in: arg2 allowKeyboard: arg3.  tmp1 := arg2 outermostWorldMorph.  [ self isInWorld ] whileTrue: [ tmp1 doOneSubCycle ].  self delete.  self restoreFocus: tmp2 in: arg2.  ^selectedItem ifNotNil: [ selectedItem target ]slideBackToFormerSituation: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp2 := self formerOwner.  tmp3 := self formerPosition.  tmp4 := arg1 hand world.  tmp7 := tmp2 transformFromWorld.  tmp1 := tmp7 isPureTranslation ifTrue: [ self imageForm offset: 0 @ 0 ] ifFalse: [ ((TransformationMorph new asFlexOf: self) transform: tmp7) imageForm offset: 0 @ 0 ].  tmp5 := arg1 hand fullBounds origin.  tmp6 := tmp7 localPointToGlobal: tmp3.  owner removeMorph: self.  tmp4 displayWorld.  tmp1 slideFrom: tmp5 to: tmp6 nSteps: 12 delay: 15.  tmp2 addMorph: self.  self position: tmp3.  self justDroppedInto: tmp2 event: arg1flushLayoutCache  selectionColor: arg1  selectionColor := arg1.  self color: selectionColormorph  ^morphshowState  ^showStatefocusIndicatorCornerRadius  ^self theme focusIndicatorCornerRadiusFor: selfedgeToAdhereTo  ^#bottomexternalName  ^labelStringstep  pointBlock value: self centeradjacentTo  ^{(self bounds topRight + (10 @ 0)) .   self bounds topLeft}locationMorph  ^locationMorphfont  ^self fontToUsenormalBorderStyle  ^self theme scrollbarNormalBorderStyleFor: selfonImageSelector  ^onImageSelectorexploreItem  self inspectsetTarget: arg1  | tmp1 |  tmp1 := defaultTarget.  tmp1 ~~ defaultTarget ifTrue: [ self updateItemsWithTarget: defaultTarget orWithHand: arg1 hand ]dashColors: arg1  dashColors := arg1mouseMove: arg1  target ifNil: [ ^self ].  self theme settings fastDragging ifTrue: [ target doFastWindowReframe: self edgeName ] ifFalse: [ super mouseMove: arg1 ]trackPaneColor: arg1  trackPaneColor := arg1releaseEditor  editor ifNotNil: [ self selectionChanged.        self paragraph selectionStart: nil selectionStop: nil.        editor := nil ]veryDeepInner: arg1  bounds := bounds shallowCopy.  submorphs := submorphs veryDeepCopyWith: arg1.  color := color veryDeepCopyWith: arg1.  extension := extension veryDeepCopyWith: arg1simpleFudgeOffset  ^0 @ 0headerColumn: arg1  ^self basicHeaderCellFor: arg1setSuccessor: arg1  successor := arg1.  paragraph ifNotNil: [ paragraph wantsColumnBreaks: successor notNil ]disable  field ifNotNil: [ field delete.        field := nil ]rowAtLocation: arg1 startingAt: arg2  | tmp1 |  tmp1 := arg1 y.  submorphs ifEmpty: [ ^nil ].  arg2 to: submorphs size do: [:arg3 |  | tmp2 |        tmp2 := submorphs basicAt: arg3.        tmp2 topLeft y >= tmp1 ifTrue: [ ^arg3 - 1 max: 1 ] ].  ^submorphs sizetopWindow  ^self class topWindowprivateRemove: arg1  submorphs := submorphs copyWithout: arg1.  self layoutChangedautoFit: arg1  self isAutoFit = arg1 ifTrue: [ ^self ].  self autoFitOnOffcollapseAll  (self windowsSatisfying: [:arg1 |  arg1 isCollapsed not ]) reverseDo: [:arg1 |  arg1 collapseOrExpand.        self displayWorld ].  self collapseNonWindowsstep  ^stephighlight  complexContents highlightingColor ifNotNil: [ self color: complexContents highlightingColor ].  self changedrightArrowStroked: arg1  (super rightArrowStroked: arg1) ifTrue: [ ^true ].  popUpOwner ifNotNil: [ self deselectAndFocusOutermenuOn: arg1.        self sendRightArrowPressedToMenubarOwner: arg1.        ^true ].  ^falseinitialize  super initialize.  self     hResizing: #spaceFill;     vResizing: #rigid;     changeTableLayout;     listDirection: #leftToRight;     cellInset: 2 @ 0;     layoutInset: 3 @ 0;     listCentering: #center;     clipSubmorphs: true;     borderWidth: 0;     borderColor: Color lightGrayfillStyleToUse  ^self enabled ifTrue: [ self theme listNormalFillStyleFor: self ] ifFalse: [ self theme listDisabledFillStyleFor: self ]indexesToSelectInMultipleSelectionFrom: arg1 to: arg2  | tmp1 |  tmp1 := arg1 <= arg2 ifTrue: [ 1 ] ifFalse: [ -1 ].  ^arg1 to: arg2 by: tmp1showWorldTaskbar: arg1  arg1 ifTrue: [ self createTaskbarIfNecessary ] ifFalse: [ self removeTaskbar ]textHighlightColor: arg1  self setProperty: #textHighlightColor toValue: arg1addNode: arg1  self addNodePath: arg1 pathaddMorphBack: arg1  ^self privateAddMorph: arg1 atIndex: submorphs size + 1newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7  ^self theme newDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7handleFocusEvent: arg1  self processEvent: arg1.  arg1 isKeyboard ifTrue: [ ^self handleEvent: arg1 ].  (arg1 isMouseOver or: [ arg1 isMouse not ]) ifTrue: [ ^self ].  arg1 isMove ifFalse: [ ^self handleEvent: arg1 ].  selectedItem ifNotNil: [ (selectedItem activateSubmenu: arg1) ifTrue: [ ^self ] ].  (self fullContainsPoint: arg1 position) ifFalse: [ popUpOwner ifNotNil: [ (popUpOwner activateOwnerMenu: arg1) ifTrue: [ ^self ] ] ]highlightForMouseDown  self highlightForMouseDown: trueresetListSelector: arg1  resetListSelector := arg1wantsDropElements: arg1 type: arg2 index: arg3  ^arg1 allSatisfy: #isClassrightButtonLabel  ^AlphaImageMorph new image: (ScrollBar arrowOfDirection: #right size: self controlButtonWidth - (3 * self displayScaleFactor) color: self paneColor darker)update: arg1  (arg1 == self getListSelector or: [ arg1 == self getListElementSelector ]) ifTrue: [ ^self updateList ].  arg1 == self getIndexSelector ifTrue: [ ^self updateSelectionIndex ]newYesButtonFor: arg1  ^self theme newYesButtonIn: self for: arg1newSVSelector: arg1 help: arg2  ^self theme newSVSelectorIn: self color: arg1 help: arg2listMorphClass  ^LazyListMorphcolumn  ^columnballoonFont: arg1  ^self setProperty: #balloonFont toValue: arg1toggleVisibleAndRaise  self isActive ifTrue: [ self world navigateVisibleWindowForward ].  super toggleVisibleAndRaise.  self visible ifTrue: [ self activate ]firstSubmorph  ^submorphs firstdefaultBorderColor  ^Color blackjob: arg1  job := arg1testMouseEnterFromMorph  morph eventHandler on: #mouseEnter send: #value to: true.  self assert: (morph mouseEnter: nil) identicalTo: truechildrenItems  ^self item classestriggerOnMouseDown: arg1  triggerOnMouseDown := arg1font: arg1 emphasis: arg2  font := arg1.  emphasis := arg2.  self fitContentsrootNodes  ^(self rootItems ifNil: [ ^nil ]) collect: [:arg1 |  self rootNodeFromItem: arg1 ]addRecolorHandle: arg1  self addHandle: arg1 on: #mouseUp send: #doRecolor:with: to: selfisTextMorph  ^falsetabEmptyContents: arg1  self selectedTab = arg1 ifFalse: [ ^self ].  (selectionHistory last: numberOfSelectedTabs) do: [:arg2 |  arg2 == arg1 ifFalse: [ arg2 silentlySelected: false ] ].  numberOfSelectedTabs := 1.  self adjustLayout.  self triggerEvent: #tabEmptyContents with: arg1keyStroke: arg1  (self navigationKey: arg1) ifTrue: [ ^self ].  super keyStroke: arg1toggleHandles  handles ifNil: [ self addHandles ] ifNotNil: [ self removeHandles ]changeEmphasis: arg1  self editor applyAttribute: (TextEmphasis perform: arg1).  self updateFromParagraphmustTakeIntoAccountToggleSpace  ^indentLevel > 0 or: [ container hasToggleAtRoot ]parentNode  ^parentNodeselectedItem  selectedItem ifNil: [ ^nil ].  ^selectedItem isSelected ifTrue: [ selectedItem ] ifFalse: [ nil ]resize: arg1  self form: (image scaledToSize: arg1)roundedCornersString  ^(self wantsRoundedCorners ifTrue: [ '<yes>' translated ] ifFalse: [ '<no>' translated ]) , 'round corners' translatedownerChanged  self snapToEdgeIfAppropriateeventHandler  ^extension ifNotNil: [ extension eventHandler ]handleDropMorph: arg1  ^self dispatchDropEvent: arg1 with: morphfitContents  | tmp1 tmp2 |  tmp1 := self measureContents.  tmp2 := bounds extent ~= tmp1.  self extent: tmp1.  tmp2 ifFalse: [ self changed ]goHome  | tmp1 tmp2 |  owner ifNil: [ ^self ].  self visible ifFalse: [ ^self ].  tmp1 := owner visibleClearArea.  tmp2 := self fullBounds.  tmp2 left < tmp1 left ifTrue: [ self left: tmp1 left - tmp2 left + self left ].  tmp2 right > tmp1 right ifTrue: [ self right: tmp1 right - tmp2 right + self right ].  tmp2 top < tmp1 top ifTrue: [ self top: tmp1 top - tmp2 top + self top ].  tmp2 bottom > tmp1 bottom ifTrue: [ self bottom: tmp1 bottom - tmp2 bottom + self bottom ]scale: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self scaleFactor / arg1.  self borderWidth: ((self borderWidth / tmp3) rounded max: 0).  tmp2 := self referencePosition.  tmp1 := (MorphicTransform offset: tmp2 negated) withScale: tmp3.  self setVertices: (vertices collect: [:arg2 |  (tmp1 transform: arg2) - tmp1 offset ]).  super scale: arg1removeHandles  handles ifNotNil: [ handles do: [:arg1 |  arg1 delete ].        handles := nil ]alwaysShowHScrollBar: arg1  self setProperty: #hScrollBarAlways toValue: arg1.  self hHideOrShowScrollBarhandlePreviousMonthTouched  self date: date onPreviousMonth.  self changedpotentialDropMorph  ^potentialDropMorphnewMorphListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newMorphListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6updateTaskButtons  | tmp1 tmp2 |  tmp1 := self submorphs copy.  self removeAllMorphs.  self defer: [ tmp1 do: [:arg1 |  arg1 model: nil ] ].  tmp2 := self orderedTasks size.  (self orderedTasks copyFrom: (tmp2 - self class maximumButtons + 1 max: 1) to: tmp2) do: [:arg2 |  | tmp3 |        tmp3 := arg2 taskbarButtonFor: self.        tmp3 ifNotNil: [ self addMorphBack: tmp3 ] ]step: arg1  step := arg1menu: arg1 shifted: arg2  arg1 add: 'Browse (b)' target: self selector: #browseItem.  arg1 add: 'Inspect (i)' target: self selector: #inspectItem.  arg1 add: 'Explore (I)' target: self selector: #exploreItemnewTextEditorFor: arg1 getText: arg2 setText: arg3  ^self newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: nilframeRectangle: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self width.  tmp1 isPoint ifTrue: [ tmp2 := tmp1 y.        tmp1 := tmp1 x ] ifFalse: [ tmp2 := tmp1 ].  tmp3 := arg1 topLeft extent: tmp1 @ arg1 height.  arg2 fillRectangle: tmp3 color: self color.  tmp3 := arg1 topRight - (tmp1 @ 0) extent: tmp1 @ arg1 height.  arg2 fillRectangle: tmp3 color: self color.  tmp3 := arg1 bottomLeft + (tmp1 @ tmp2 negated) extent: (arg1 width - tmp1 - tmp1) @ tmp2.  arg2 fillRectangle: tmp3 color: self color.  tmp4 := self selectedTab.  (tmp4 isNil or: [ tmp4 owner isNil ]) ifTrue: [ tmp3 := arg1 topLeft + (tmp1 @ 0) corner: arg1 topRight - (tmp1 @ tmp2 negated).        arg2 fillRectangle: tmp3 color: self color.        ^self ].  tmp3 := arg1 topLeft + (tmp1 @ 0) corner: (tmp4 bounds left + tmp1) @ (arg1 top + tmp2).  arg2 fillRectangle: tmp3 color: self color.  tmp3 := (tmp4 bounds left + tmp1) @ arg1 top corner: (tmp4 bounds right - tmp1) @ (arg1 top + tmp2).  arg2 fillRectangle: tmp3 color: tmp4 paneColor.  tmp3 := (tmp4 bounds right - tmp1) @ arg1 top corner: arg1 topRight - (tmp1 @ tmp2 negated).  arg2 fillRectangle: tmp3 color: self coloritemFromPoint: arg1  | tmp1 |  scroller hasSubmorphs ifFalse: [ ^nil ].  (scroller fullBounds containsPoint: arg1) ifFalse: [ ^nil ].  tmp1 := (scroller firstSubmorph point: arg1 from: self) y.  scroller firstSubmorph top > tmp1 ifTrue: [ ^nil ].  scroller lastSubmorph bottom < tmp1 ifTrue: [ ^nil ].  ^self findSubmorphFor: tmp1dropNotifyRecipient  ^dropNotifyRecipientcollapseOrExpand  | tmp1 |  isCollapsed ifTrue: [ uncollapsedMorph setProperty: #collapsedPosition toValue: self position.        labelString ifNotNil: [ uncollapsedMorph setNameTo: labelString ].        mustNotClose := false.        self delete.        (tmp1 := self currentWorld) addMorphFront: uncollapsedMorph.        tmp1 startSteppingSubmorphsOf: uncollapsedMorph ] ifFalse: [ super collapseOrExpand ]scrollBar  ^scrollBarshowFilterFieldFromKeystrokeEvent: arg1  | tmp1 tmp2 |  tmp1 := arg1 keyCharacter asString asText.  self initializeFilter.  self filterWith: tmp1.  tmp2 := RubFloatingEditorBuilder new     customizeEditorWith: [:arg2 |  arg2 bounds: (self table bottomLeft + (0 @ 2) corner: self table bottomRight + (0 @ (arg2 font height + 6))) ];     withEditedContentsDo: [:arg3 :arg2 |  self filterWith: arg3.        arg2 setTextWith: (self colorText: arg3) ].  tmp2 autoAccept: true.  tmp2 whenEditorEscapedDo: [ self reinitializeTable ].  tmp2 openEditorWithContents: (self colorText: tmp1)acceptOnFocusChange: arg1  acceptOnFocusChange := arg1magicAlpha  ^self valueOfProperty: #magicAlpha ifAbsent: [ 1.0 ]hScrollbarValue: arg1  | tmp1 |  tmp1 := self scrollTarget width - self scrollBounds width max: 0.  self scroller offset: (tmp1 * arg1) rounded @ self scroller offset ytarget: arg1  target := arg1stepTime  ^100enable  self enabled: true= arg1  super = arg1 ifFalse: [ ^false ].  position = arg1 position ifFalse: [ ^false ].  startPoint = arg1 startPoint ifFalse: [ ^false ].  buttons = arg1 buttons ifFalse: [ ^false ].  ^truecopyHandlerState: arg1  wasHandled := arg1 wasHandledtestUpdatingSelectionsOnUpdate  | tmp1 tmp2 tmp3 |  tmp1 := ClassTreeExample new.  [ tmp2 := tmp1 openOn: Collection.  tmp3 := tmp1 dependents last.  tmp3 expandAll.  tmp1 selectItems: {Bag .         CharacterSet}.  tmp1 selection selectedNodes do: [:arg1 |  self assert: (tmp3 selectedMorphList anySatisfy: [:arg2 |  arg2 complexContents = arg1 ]) ].  tmp1 rootClass: Bag.  tmp1 updateList.  tmp1 selection selectedNodes do: [:arg1 |  self assert: (tmp3 selectedMorphList anySatisfy: [:arg2 |  arg2 complexContents = arg1 ]) ] ] ensure: [ tmp2 close ]mouseEnterDragging: arg1  | tmp1 |  (arg1 hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: arg1 ].  (self wantsDroppedMorph: arg1 hand firstSubmorph event: arg1) ifTrue: [ tmp1 := self itemFromPoint: arg1 position.        tmp1 ifNotNil: [ self potentialDropMorph: tmp1 ].        arg1 hand newMouseFocus: self ]mouseUp: arg1  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: arg1 cursorPoint) ifFalse: [ arg1 hand showTemporaryCursor: nil ].  self updateFromEvent: arg1.  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUpnextState  ^FTUnsortedSortingState context: self contextselectableIndexBefore: arg1  ^self subclassResponsibilitymouseUp: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseUp from: arg2left  ^bounds lefthasMenuBox  ^menuBox notNilmouseUpInSlider: arg1  super mouseUpInSlider: arg1.  self updateLabelpreferedPaneColor  ^preferedPaneColorseparatorBlockOrSelector: arg1  separatorBlockOrSelector := arg1show: arg1  | tmp1 |  self flag: #pharoFixMe.  tmp1 := self addItemShowing: arg1.  self openInWorld.  self updateWidth.  ^tmp1handleMouseDown: arg1  arg1 wasHandled ifTrue: [ ^self ].  arg1 hand removePendingBalloonFor: self.  arg1 wasHandled: true.  (arg1 controlKeyPressed and: [ self cmdGesturesEnabled and: [ arg1 shiftPressed ] ]) ifTrue: [ self invokeMetaMenu: arg1.        ^self eventHandler ifNotNil: [:arg2 |  arg2 mouseDown: arg1 fromMorph: self ] ].  arg1 hand newMouseFocus: self event: arg1.  arg1 blueButtonChanged ifTrue: [ ^self blueButtonDown: arg1 ].  self mouseDown: arg1.  arg1 hand removeHaloFromClick: arg1 on: self.  (self handlesMouseStillDown: arg1) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue + self mouseStillDownThreshold arguments: {arg1 copy resetHandlerFields} stepTime: self mouseStillDownStepRate ]canScrollUp  ^value > 0searchStrategy: arg1  searchStrategy := arg1enabledString  ^self enabled -> 'enabled' translatedmouseStillDownThreshold  ^200heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]selectedNodePathList  ^self selectedNodePath ifNil: [ #() ] ifNotNil: [ Array with: self selectedNodePath ]becomeModal  self currentWorld ifNotNil: [ self currentWorld modalWindow: self ]sendToBack  | tmp1 |  tmp1 := self world submorphs select: [:arg1 |  arg1 isSystemWindow and: arg1 ~~ self ].  tmp1 ifNotEmpty: [ tmp1 first activate.        self world addMorph: self behind: tmp1 last ]stepTime  | tmp1 |  tmp1 := self renderedMorph.  tmp1 = self ifTrue: [ ^super stepTime ].  ^tmp1 stepTimechangeListDirection: arg1  | tmp1 tmp2 |  self listDirection: arg1.  self wrapDirection == #none ifTrue: [ ^self ].  tmp1 := self listDirection.  tmp2 := self wrapDirection.  (tmp1 == #leftToRight or: [ tmp1 == #rightToLeft ]) ifTrue: [ tmp2 == #leftToRight ifTrue: [ ^self wrapDirection: #topToBottom ].        tmp2 == #rightToLeft ifTrue: [ ^self wrapDirection: #bottomToTop ] ] ifFalse: [ tmp2 == #topToBottom ifTrue: [ ^self wrapDirection: #leftToRight ].        tmp2 == #bottomToTop ifTrue: [ ^self wrapDirection: #rightToLeft ] ]newButtonFor: arg1 action: arg2 getEnabled: arg3 label: arg4 help: arg5  ^self newButtonFor: arg1 getState: nil action: arg2 arguments: nil getEnabled: arg3 label: arg4 help: arg5privateExtension: arg1  extension := arg1icon: arg1  icon := arg1viewBox  ^0 @ 0 corner: self actualScreenSizemouseDown: arg1  super mouseDown: arg1.  arg1 yellowButtonPressed ifTrue: [ ^self ].  oldColor := self fillStyle.  actWhen == #buttonDown ifTrue: [ self doButtonAction ] ifFalse: [ self updateVisualState: arg1 ].  self mouseStillDown: arg1discoveredWorldMenu  ^owner discoveredWorldMenufillStyle: arg1  arg1 isColor ifTrue: [ self color: arg1 ] ifFalse: [ super fillStyle: arg1 ]fit  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self isAutoFit ifTrue: [ tmp1 := (self paragraph extent max: 9 @ textStyle lineGrid) + (0 @ 2).        tmp1 := tmp1 + (2 * borderWidth).        tmp1 := ((0 @ 0 extent: tmp1) expandBy: margins) extent.        tmp1 ~= bounds extent ifTrue: [ (container isNil and: [ successor isNil ]) ifTrue: [ tmp2 := paragraph.                    super extent: tmp1.                    paragraph := tmp2 ] ].        (container notNil and: [ successor isNil ]) ifTrue: [ tmp3 := container bounds truncated.              tmp4 := self paragraph lines last.              tmp5 := tmp4 bottom - tmp4 top.              (tmp4 last < text size and: [ tmp4 bottom + tmp5 >= self bottom ]) ifTrue: [ container releaseCachedState.                    tmp3 := tmp3 origin corner: tmp3 corner + (0 @ tmp5) ].              self privateBounds: tmp3 ] ].  self paragraph positionWhenComposed: self position.  successor ifNotNil: [ successor predecessorChanged ].  self changedselectItem: arg1 event: arg2  selectedItem ifNotNil: [ selectedItem deselect: arg2 ].  selectedItem := arg1.  selectedItem ifNotNil: [ selectedItem select: arg2 ]doButtonAction  (target notNil and: [ actionSelector notNil ]) ifTrue: [ Cursor normal showWhile: [ target perform: actionSelector withArguments: arguments ] ].  actWhen == #startDrag ifTrue: [ oldColor ifNotNil: [ self color: oldColor ] ]testSelectableIndexAbove  self assert: (strategy selectableIndexAbove: 2) equals: 1arguments: arg1  arguments := arg1testSelectableIndexBefore  self assert: (strategy selectableIndexBefore: #(2 3)) equals: #(2 2)actWhen  ^actWhenfirstVertex  ^vertices firstdamageRecorder  ^damageRecorderframeRectangle: arg1 on: arg2  self cornerRadius = 0 ifTrue: [ ^self frameRectangle0: arg1 on: arg2 ].  self cornerRadius = 1 ifTrue: [ ^self frameRectangle1: arg1 on: arg2 ].  self cornerRadius = 2 ifTrue: [ ^self frameRectangle2: arg1 on: arg2 ].  self cornerRadius = 3 ifTrue: [ ^self frameRectangle3: arg1 on: arg2 ].  self cornerRadius = 4 ifTrue: [ ^self frameRectangle4: arg1 on: arg2 ].  self cornerRadius = 5 ifTrue: [ ^self frameRectangle5: arg1 on: arg2 ].  self cornerRadius = 6 ifTrue: [ ^self frameRectangle6: arg1 on: arg2 ].  self cornerRadius = 7 ifTrue: [ ^self frameRectangle7: arg1 on: arg2 ].  self cornerRadius = 8 ifTrue: [ ^self frameRectangle8: arg1 on: arg2 ].  ^super frameRectangle: arg1 on: arg2hScrollBarValue: arg1  | tmp1 tmp2 |  self hIsScrollbarShowing ifFalse: [ ^scroller offset: (0 - self hMargin) @ scroller offset y ].  (tmp1 := self hLeftoverScrollRange * arg1) <= 0 ifTrue: [ tmp1 := 0 - self hMargin ].  scroller offset: tmp1 @ scroller offset y.  owner ifNil: [ ^self ].  tmp2 := self window.  tmp2 ifNotNil: [ tmp2 announce: (WindowScrolling new                 step: arg1 @ 0;                 window: tmp2) ].  self announcer announce: (PaneScrolling new           step: arg1 @ 0;           scrollPane: self;           yourself)isMinimized  ^self isCollapsedcancel  self closelayoutBounds: arg1  | tmp1 tmp2 |  tmp1 := self bounds.  tmp2 := self layoutBounds.  bounds := arg1 origin + (tmp1 origin - tmp2 origin) corner: arg1 corner + (tmp1 corner - tmp2 corner)isMouseMove  ^self type == #mouseMovecurveBounds  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  self isCurvy ifFalse: [ ^(Rectangle encompassing: vertices) expandBy: borderWidth * 0.5 ].  curveState := nil.  tmp1 := nil.  self lineSegmentsDo: [:arg1 :arg2 |  tmp1 ifNil: [ tmp1 := arg2 floor.              tmp3 := tmp5 := arg1 x.              tmp4 := tmp6 := arg1 y ].        tmp3 := tmp3 min: arg2 x.        tmp5 := tmp5 max: arg2 x.        tmp4 := tmp4 min: arg2 y.        tmp6 := tmp6 max: arg2 y.        tmp2 := arg1 floor ].  curveState at: 2 put: tmp1.  curveState at: 3 put: tmp2.  ^(tmp3 @ tmp4 corner: tmp5 @ tmp6) expandBy: borderWidth * 0.5haloClass  ^#HaloMorphbuildRowMorph  | tmp1 tmp2 |  controls := OrderedCollection new.  tmp2 := container columns collect: [:arg1 |  | tmp3 |        tmp3 := arg1 rowMorphFor: complexContents.        controls add: tmp3.        arg1 -> tmp3 ].  tmp1 := OrderedCollection new.  tmp2 do: [:arg2 |  | tmp4 tmp5 |        arg1 := arg2 key.        tmp5 := arg2 value.        tmp5 clipSubmorphs: true.        tmp5 vResizing: #shrinkWrap.        tmp1 add: tmp5.        (tmp5 = controls last and: [ container lastColumnUnbounded ]) ifFalse: [ tmp5 hResizing: #rigid ].        (arg1 resizable not and: [ arg1 shrinkWrap ]) ifTrue: [ arg1 currentWidth < tmp5 width ifTrue: [ arg1 forceWidthTo: tmp5 width ] ] ].  self addAllMorphs: tmp1.  self layoutChangedopenInWorld: arg1  ^self openAsIsIn: arg1defaultContainer  ^FTTableContainerMorph newselectedItems: arg1  self listManager selectedItems: arg1scanCode: arg1  scanCode := arg1computeGlobalCellArrangement: arg1 in: arg2 horizontal: arg3 wrap: arg4 spacing: arg5  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp1 := Array new writeStream.  tmp5 := tmp6 := nil.  tmp2 := arg1 inject: 0 @ 0 into: [:arg6 :arg7 |  arg6 max: arg7 cellSize ].  arg5 == #globalSquare ifTrue: [ tmp2 := (tmp2 x max: tmp2 y) asPoint ].  tmp3 := arg4 // tmp2 x max: 1.  tmp7 := tmp8 := false.  1 to: arg1 size do: [:arg8 |  tmp4 := arg1 at: arg8.        tmp7 := tmp7 or: [ tmp4 hSpaceFill ].        tmp8 := tmp8 or: [ tmp4 vSpaceFill ].        tmp4 cellSize: tmp2.        tmp5 ifNil: [ tmp5 := tmp6 := tmp4 ] ifNotNil: [ tmp6 nextCell: tmp4.              tmp6 := tmp4 ].        arg8 \\ tmp3 = 0 ifTrue: [ tmp6 := LayoutCell new.              tmp6 cellSize: (tmp2 x * tmp3) @ tmp2 y.              tmp6 hSpaceFill: tmp7.              tmp6 vSpaceFill: tmp8.              tmp7 := tmp8 := false.              tmp6 nextCell: tmp5.              tmp1 nextPut: tmp6.              tmp5 := nil ] ].  tmp5 ifNotNil: [ tmp6 := LayoutCell new.        tmp6 cellSize: (tmp2 x * tmp3) @ tmp2 y.        self flag: #pharoFixMe.        tmp6 nextCell: tmp5.        tmp1 nextPut: tmp6 ].  ^tmp1 contentsdataSource: arg1  dataSource := arg1fillStyle: arg1  fillStyle := arg1.  arg1 ifNotNil: [ self baseColor: arg1 asColor ]cursorPoint  | tmp1 |  tmp1 := self position.  (self currentWorld isNil or: [ self currentWorld == owner ]) ifTrue: [ ^tmp1 ].  ^self currentWorld point: tmp1 from: ownermouseDown: arg1  needToggleAtMouseUp ifTrue: [ ^self ].  (self selectionModeStrategy selectableIndexContainingPoint: arg1 cursorPoint) ifNotNil: [:arg2 |  (self selectedIndexes includes: arg2) ifFalse: [ self selectIndex: arg2 event: arg1 ] ifTrue: [ needToggleAtMouseUp := true ] ] ifNil: [ ^self ].  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ].  arg1 hand waitForClicksOrDrag: self event: arg1age  ^self item agelastSelectedNodePath  ^self selectedNodePathforwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1currentWidth: arg1  self resizable ifTrue: [ currentWidth := arg1 ]initializeSlider  slider := BorderedMorph newBounds: self totalSliderArea color: self theme baseColor.  sliderShadow := BorderedMorph newBounds: self totalSliderArea color: self pagingArea color.  slider on: #mouseMove send: #scrollAbsolute: to: self.  slider on: #mouseDown send: #mouseDownInSlider: to: self.  slider on: #mouseUp send: #mouseUpInSlider: to: self.  slider     borderWidth: 1;     borderColor: self theme baseColor.  sliderShadow     borderWidth: 1;     borderColor: #inset.  self pagingArea addMorph: sliderShadow.  sliderShadow hide.  self addMorph: slider.  self computeSliderhash  ^((((((((self species hash + leftFraction hash) hashMultiply + leftOffset hash) hashMultiply + topFraction hash) hashMultiply + topOffset hash) hashMultiply + rightFraction hash) hashMultiply + rightOffset hash) hashMultiply + bottomFraction hash) hashMultiply + bottomOffset hash) hashMultiplyisCurve  ^smoothCurvechangeBorderColor: arg1  self theme chooseColorIn: self title: 'Choose Color' translated color: self borderStyle color for: [:arg2 |  self borderColor: arg2 ]setLabelWidgetAllowance  ^labelWidgetAllowance := self boxExtent x * 7hue: arg1  self hMorph value: arg1.  self svMorph color: (Color h: arg1 * 359.9 s: 1.0 v: 1.0)newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: arg6 help: arg7stepTime  ^0menuColumn: arg1 row: arg2  arg2 = 0 ifTrue: [ ^nil ].  arg1 id = 'Name' ifTrue: [ ^self nameMenuColumn: arg1 row: arg2 ].  arg1 id = 'Origin' ifTrue: [ ^self originMenuColumn: arg1 row: arg2 ].  ^nillistMorphClass  ^LazyMorphListMorphtestSpaceFill  | tmp1 tmp2 |  tmp1 := LayoutFrame identity.  tmp2 := tmp1 layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (50 @ 10 corner: 150 @ 70) equals: tmp2defaultIsResizeable  ^falserowMorphGetSelector: arg1  rowMorphGetSelector := arg1alert: arg1  ^self alert: arg1 title: 'Alert' translatedaddDismissHandle: arg1  | tmp1 |  target okayToAddDismissHandle ifTrue: [ tmp1 := self addHandle: arg1 on: #mouseDown send: #mouseDownInDimissHandle:with: to: self.        tmp1 on: #mouseUp send: #maybeDismiss:with: to: self.        tmp1 on: #mouseDown send: #setDismissColor:with: to: self.        tmp1 on: #mouseMove send: #setDismissColor:with: to: self ]extent: arg1  super extent: arg1.  container extent: arg1.  self resizeAllSubviewsspEnsureLayoutAndAddMorph: arg1  arg1 layoutFrame ifNil: [ arg1 layoutFrame: LayoutFrame identity ].  self addMorph: arg1leftButtonLabel  ^AlphaImageMorph new image: (ScrollBar arrowOfDirection: #left size: self controlButtonWidth - (3 * self displayScaleFactor) color: self paneColor darker)brickTransparentImageForm  | tmp1 tmp2 tmp3 |  self isBrick ifTrue: [ tmp3 := self border.        self border: GLMBrickBorder new ].  tmp1 := self color.  self color: Color transparent.  tmp2 := self imageForm.  self color: tmp1.  self isBrick ifTrue: [ self border: tmp3 ].  ^tmp2vShowScrollbar  self vResizeScrollbar.  self vScrollbarShowing ifTrue: [ ^self ].  self privateAddMorph: self vScrollbar atIndex: 1.  self hResizeScrollbar.  self resizeScrollerselectTask: arg1  self tasks do: [:arg2 |  arg2 state: #restored ].  arg1 ifNotNil: [ arg1 state: #active ].  self updateButtonsAndPreviewcontrols: arg1  controls := arg1justDroppedInto: arg1 event: arg2  isCollapsed ifTrue: [ self position: ((self position max: 0 @ 0) grid: 8 @ 8).        collapsedFrame := self bounds ] ifFalse: [ fullFrame := self bounds.        self isTopWindow ifFalse: [ self activate ] ].  arg2 hand releaseMouseFocus.  ^super justDroppedInto: arg1 event: arg2diamondOval  | tmp1 |  tmp1 := self bounds.  self setVertices: {tmp1 leftCenter .         tmp1 bottomCenter .         tmp1 rightCenter .         tmp1 topCenter}basicWrapSelector: arg1  self dataSource wrapSelector: arg1extension  ^extensionscrollBy: arg1  | tmp1 tmp2 tmp3 |  tmp1 := scroller offset y - arg1 y max: 0.  tmp3 := scroller offset x - arg1 x max: self hMargin negated.  scroller offset: tmp3 @ tmp1.  (tmp2 := self vLeftoverScrollRange) = 0 ifTrue: [ scrollBar value: 0.0 ] ifFalse: [ scrollBar value: tmp1 asFloat / tmp2 ].  (tmp2 := self hLeftoverScrollRange) = 0 ifTrue: [ hScrollBar value: 0.0 ] ifFalse: [ hScrollBar value: tmp3 asFloat / tmp2 ]veryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  target := arg1 references at: target ifAbsent: [ target ].  arguments := arguments collect: [:arg2 |  arg1 references at: arg2 ifAbsent: [ arg2 ] ]secondarySelectionColor  ^self theme secondarySelectionColorgripLayoutFrame  ^(1 @ 0 corner: 1 @ 0) asLayoutFrame topLeftOffset: self defaultWidth negated @ -27dashColors  ^dashColorsnotOnLastPage  ^self onLastPage notgetLabelSelector: arg1  getLabelSelector := arg1.  self updateLabelnewButtonMorph  ^(CheckboxButtonMorph new     target: self;     actionSelector: #toggleSelected;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap) on: #mouseDown send: #buttonMouseDown: to: selfstepTime  ^stepTimenearestOwnerThat: arg1  ^self firstOwnerSuchThat: arg1addCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  self addLabelItemsTo: arg1 hand: arg2.  arg1 add: 'change action selector' selector: #setActionSelector.  arg1 add: 'change arguments' selector: #setArguments.  arg1 add: 'change when to act' selector: #setActWhen.  self addTargetingMenuItems: arg1 hand: arg2autoGradient  ^autoGradientinitialize  super initialize.  self initializeSelections.  self hideColumnHeaders.  self dataSource: FTPluggableIconListMorphAdaptorDataSource newwantsDirectionHandles: arg1  self setProperty: #wantsDirectionHandles toValue: arg1layoutPosition  self layout == #topCenter ifTrue: [ ^self innerBounds topCenter - ((self cachedForm width // 2) @ 0) ].  self layout == #topRight ifTrue: [ ^self innerBounds topRight - (self cachedForm width @ 0) ].  self layout == #rightCenter ifTrue: [ ^self innerBounds rightCenter - (self cachedForm width @ (self cachedForm height // 2)) ].  self layout == #bottomRight ifTrue: [ ^self innerBounds bottomRight - self cachedForm extent ].  self layout == #bottomCenter ifTrue: [ ^self innerBounds bottomCenter - ((self cachedForm width // 2) @ self cachedForm height) ].  self layout == #bottomLeft ifTrue: [ ^self innerBounds bottomLeft - (0 @ self cachedForm height) ].  self layout == #leftCenter ifTrue: [ ^self innerBounds leftCenter - (0 @ (self cachedForm height // 2)) ].  (self layout == #center or: [ self layout == #scaledAspect ]) ifTrue: [ ^self innerBounds center - (self cachedForm extent // 2) ].  ^self innerBounds topLeftorientation: arg1  orientation := arg1.  self changedcopy  ^self veryDeepCopycontrolsExtent  ^self controls first minExtent + (self controls last minExtent x @ 0)moveBy: arg1  lines do: [:arg2 |  arg2 moveBy: arg1 ].  positionWhenComposed ifNotNil: [ positionWhenComposed := positionWhenComposed + arg1 ].  container := container translateBy: arg1handlesMouseOverDragging: arg1  ^trueindentingItemClass  ^TickSelectionListNodeMorphgetIconSelector: arg1  getIconSelector := arg1resizerWidth: arg1  resizerWidth := arg1tabOfPage: arg1  ^self tabSelectorMorph tabs at: (self pages indexOf: arg1)scrollValue  ^hScrollBar value @ scrollBar valuefillStyle  ^fillStyledrawOnAthensCanvas: arg1  self useSelectionBar ifTrue: [ self paragraph displaySelectionBarOnAthensCanvas: arg1 ].  self useExtraSelection ifTrue: [ self paragraph displayExtraSelectionOnAthensCanvas: arg1 ].  super drawOnAthensCanvas: arg1asAthensPaintOn: arg1  ^AthensCompositeStrokePaint new fromDashedBorderStyle: self on: arg1indexesToSelectInMultipleSelectionFrom: arg1 to: arg2  ^self subclassResponsibilityselectionColorToUse  self enabled ifFalse: [ ^self paneColor ].  ^self valueOfProperty: #selectionColorToUse ifAbsent: [ self theme selectionColor ]itemStringGetter: arg1  rowMorphGetSelector := arg1 isSymbol ifTrue: [ [:arg2 |  (arg2 complexContents item perform: arg1) asMorph ] ] ifFalse: [ [:arg2 |  (arg1 value: arg2 complexContents item) asMorph ] ]target: arg1  target ifNotNil: [ target removeDependent: self ].  arg1 ifNotNil: [ arg1 addDependent: self ].  target := arg1newAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6tasks  ^tasksbottomCenter  ^bounds bottomCentertoggleFillsOwner  self fillsOwner: self fillsOwner notthemeChanged  rowColors at: 1 put: (rowColors asSet size = 1 ifTrue: [ self theme backgroundColor ] ifFalse: [ rowColors at: 1 put: self theme backgroundColor contrastingColorAdjustment ]).  rowColors at: 2 put: self theme backgroundColor.  super themeChangedresistsRemoval  ^self hasProperty: #resistsRemovalonBlinkCursor  | tmp1 |  tmp1 := self paragraph ifNil: [ ^nil ].  Time millisecondClockValue < self blinkStart ifTrue: [ ^tmp1 showCaret: tmp1 focused ].  tmp1 showCaret: tmp1 showCaret not.  tmp1 caretRect ifNotNil: [:arg1 |  self invalidRect: arg1 ]updateCopyIcon  | tmp1 |  tmp1 := self submorphWithProperty: #tmCopyIcon.  self shouldCopy ifFalse: [ ^tmp1 ifNotNil: [ tmp1 delete ] ].  tmp1 ifNotNil: [ ^self ].  tmp1 := ImageMorph new form: CopyPlusIcon.  tmp1 setProperty: #tmCopyIcon toValue: true.  ^self addMorphFront: tmp1addHandleSelector  ^addHandleSelectormouseStillDown: arg1  actWhen == #whilePressed ifFalse: [ ^self ].  (self containsPoint: arg1 cursorPoint) ifTrue: [ self doButtonAction ]unhighlight  complexContents highlightingColor ifNotNil: [ (self valueOfProperty: #originalColor ifAbsent: [ Color black ]) ifNotNil: [:arg1 |  self color: arg1 ] ].  self allMorphsDo: [:arg2 |  (arg2 isKindOf: StringMorph) ifTrue: [ arg2 color: (arg2 valueOfProperty: #originalColor ifAbsent: [ self theme textColor ]) ] ]label: arg1 font: arg2  | tmp1 |  self removeAllMorphs.  tmp1 := AlignmentMorph new     borderWidth: 0;     layoutInset: 0;     cellInset: 2;     color: Color transparent;     hResizing: #shrinkWrap;     vResizing: #spaceFill;     wrapCentering: #center;     listCentering: #center;     cellPositioning: #center;     yourself.  (self iconPosition == #top or: [ self iconPosition == #bottom ]) ifTrue: [ tmp1 setAsColumn ] ifFalse: [ tmp1 setAsRow ].  label := arg1.  self label ifNotNil: [ labelMorph := self label isMorph ifTrue: [ self label ] ifFalse: [ self newLabel: arg2 ].        tmp1 addMorph: labelMorph ].  self icon ifNotNil: [ iconMorph := self icon asMorph.        (self iconPosition == #right or: [ self iconPosition == #bottom ]) ifTrue: [ tmp1 addMorphBack: iconMorph ] ifFalse: [ tmp1 addMorphFront: iconMorph ] ].  self addMorph: tmp1.  self updateLabelEnablementinformMouseLeaveToLeftMorphsUsing: arg1  | tmp1 |  tmp1 := arg1 asMouseLeave.  leftMorphs do: [:arg2 |  self inform: tmp1 to: arg2 originatedFrom: arg1 ifNotFocusedDo: [ overMorphs nextPut: arg2 ] ]imageForm  ^self imageFormForRectangle: self fullBoundsdoButtonAction  self hasItems ifTrue: [ self menuItems first doButtonAction ]shouldInvalidateOnMouseTransition  ^self class showSplitterHandlesforwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1selectableIndexBefore: arg1  self shouldNotImplementdefaultTreeMorph  ^super defaultTreeMorph     doubleClickSelector: #doubleClick;     nodeStringGetter: #asString;     getMenuSelector: #menu:shifted:flashFillStyle  ^Color blackcalculateMaxVisibleRows  ^self calculateExactVisibleRows ceilingstartDrag: arg1  | tmp1 tmp2 tmp3 |  dragItemSelector ifNotNil: [ ^self startDragExtended: arg1 ].  arg1 hand hasSubmorphs ifTrue: [ ^self ].  self dragEnabled ifFalse: [ ^self ].  ActiveHand anyButtonPressed ifFalse: [ ^self ].  tmp2 := self getListItem: (self mouseDownRow ifNil: [ self lastNonZeroIndex ]).  tmp2 ifNil: [ ^self ].  tmp3 := self model dragPassengersFor: tmp2 inMorph: self.  tmp3 ifNil: [ ^self ].  tmp1 := self model transferFor: tmp3 from: self.  tmp1 align: tmp1 draggedMorph bottomLeft with: arg1 position.  self mouseDownRow: nil.  tmp1 dragTransferType: (self model dragTransferTypeForMorph: self).  [ arg1 hand grabMorph: tmp1 ] ensure: [ Cursor normal show.        arg1 hand releaseMouseFocus: self ]fullBounds  fullBounds ifNotNil: [ ^fullBounds ].  fullBounds := bounds.  ^fullBoundsoldSelectedRowIndexes: arg1  self deprecated: 'Use #oldSelectedIndexes: instead' transformWith: '`@receiver oldSelectedRowIndexes: `@statements1' -> '`@receiver oldSelectedIndexes: `@statements1'.  self oldSelectedIndexes: arg1showAlways  self showState: #alwaysresizeCursor  ^Cursor resizeForEdge: #topLeftremoveHand: arg1  (worldState hands includes: arg1) ifFalse: [ ^self ].  arg1 dropMorphs.  self invalidRect: arg1 fullBounds.  worldState removeHand: arg1themeChanged  self submorphsDo: [:arg1 |  arg1 themeChanged ].  self changeddropVertex: arg1 event: arg2 fromHandle: arg3  | tmp1 |  tmp1 := vertices at: arg1.  (vertices size >= 2 and: [ ((vertices atWrap: arg1 - 1) distanceTo: tmp1) < 3 or: [ ((vertices atWrap: arg1 + 1) distanceTo: tmp1) < 3 ] ]) ifTrue: [ self deleteVertexAt: arg1 ].  arg2 shiftPressed ifTrue: [ self removeHandles ] ifFalse: [ self addHandles ]exportAsGIF  self exportAs: 'gif' using: GIFReadWritervTotalScrollRange  ^self vUnadjustedScrollRange + self vExtraScrollRangeinitializeAppearance  self     color: (Color black alpha: 0.15);     fillStyle: (self theme taskListFillStyleFor: self);     borderStyle: (self theme taskbarThumbnailNormalBorderStyleFor: self);     cornerStyle: (self theme taskbarThumbnailCornerStyleFor: self)focusBounds  ^self selectedTab ifNil: [ super focusBounds ] ifNotNil: [:arg1 |  arg1 focusBounds ]setLabel: arg1  | tmp1 tmp2 |  labelString := arg1.  tmp2 := WindowLabelled new     window: self;     label: arg1;     yourself.  self announce: tmp2.  self currentWorld announcer announce: tmp2.  label ifNil: [ ^self ].  label contents: arg1.  self labelWidgetAllowance.  self isCollapsed ifTrue: [ self extent: (label width + labelWidgetAllowance) @ (self labelHeight + 2) ] ifFalse: [ label width > (bounds width - labelWidgetAllowance) ifTrue: [ label setBalloonText: label contents ] ifFalse: [ label setBalloonText: nil ].        label           fitContents;           setWidth: (label width min: bounds width - labelWidgetAllowance).        label align: label bounds topCenter with: bounds topCenter + (0 @ borderWidth).        collapsedFrame ifNotNil: [ collapsedFrame := collapsedFrame withWidth: label width + labelWidgetAllowance ] ].  tmp1 := LayoutFrame new.  tmp1     leftFraction: 0.5;     topFraction: 0.5;     leftOffset: label width negated // 2;     topOffset: label height negated // 2.  label layoutFrame: tmp1isResized  ^falseusedWidthByPredominantDockingBarsOfChastes: arg1  ^(self predominantDockingBarsOfChastes: arg1) ifEmpty: [ 0 ] ifNotEmpty: [:arg2 |  (arg2 collect: [:arg3 |  arg3 width ]) sum ]searchedElement: arg1  searchedElement := arg1.  arg1 ifNil: [ self vScrollValue: self scrollValue y ] ifNotNil: [ self vScrollValue: (arg1 - 1) / self getListSize ]openAsIsIn: arg1  arg1 addMorph: self.  (self submorphs notEmpty and: [ self submorphs first isSystemWindow ]) ifTrue: [ self submorphs first openedFullscreen ].  arg1 startSteppingSubmorphsOf: self.  self announceOpenedthemeChanged  self cornerStyle: (self theme tabGroupCornerStyleIn: self window).  self pageMorphs do: [:arg1 |  arg1 themeChanged ].  super themeChangedbasicKeyPressed: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := tmp4 := lastSelection.  tmp2 := Time millisecondClockValue.  tmp3 := tmp2 - lastKeystrokeTime > 500.  lastKeystrokeTime := tmp2.  self searchedElement: nil.  tmp3 ifTrue: [ lastKeystrokes := arg1 asLowercase asString ] ifFalse: [ lastKeystrokes := lastKeystrokes , arg1 asLowercase asString ].  model okToChange ifFalse: [ ^self ].  tmp5 := self allItems.  tmp5 detect: [:arg2 |  arg2 searchingString trimBoth asLowercase beginsWith: lastKeystrokes ] ifFound: [:arg3 |  tmp1 := tmp5 indexOf: arg3 ifAbsent: [ 0 ].        self searchedElement: arg3.        lastSelection := tmp1.        ^self vScrollValue: (tmp1 - 1) / tmp5 size ]printOn: arg1  super printOn: arg1.  label ifNotNil: [ arg1 nextPutAll: ' named: ' , self labelString ]selectedColor  ^self svMorph selectedColorwantsYellowButtonMenu: arg1  self setProperty: #wantsYellowButtonMenu toValue: arg1withoutListWrapper  ^complexContents withoutListWrappernewTaskFor: arg1  ^TaskbarTask morph: arg1 state: #aNilState icon: nil label: 'a Label'minWidth  ^super minWidth max: self theme buttonMinWidthdoOneSubCycleFor: arg1  | tmp1 |  tmp1 := self activeHand.  self doOneCycleFor: arg1.  self activeHand: tmp1layoutTopToBottom: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 tmp16 tmp17 tmp18 tmp19 tmp20 tmp21 tmp22 |  tmp18 := properties minCellSize asPoint.  tmp9 := tmp18 x.  tmp10 := tmp18 y.  tmp18 := properties maxCellSize asPoint.  tmp11 := tmp18 x.  tmp12 := tmp18 y.  tmp1 := properties cellInset asPoint y.  tmp2 := arg2 extent.  tmp13 := 0.  tmp21 := false.  tmp20 := 0.  tmp19 := tmp14 := 0.  tmp22 := tmp16 := nil.  tmp3 := [:arg3 |  | tmp23 tmp24 tmp25 |  tmp24 := arg3 layoutProperties ifNil: [ arg3 ].  tmp24 disableTableLayout ifFalse: [ tmp13 := tmp13 + 1.        tmp17 := LayoutCell new target: arg3.        tmp24 vResizing == #spaceFill ifTrue: [ tmp17 vSpaceFill: true.              tmp15 := arg3 spaceFillWeight.              tmp17 extraSpace: tmp15.              tmp20 := tmp20 + tmp15 ] ifFalse: [ tmp17 vSpaceFill: false ].        tmp24 hResizing == #spaceFill ifTrue: [ tmp21 := true ].        tmp18 := arg3 minExtent.        tmp23 := tmp18 x.        tmp25 := tmp18 y.        tmp23 < tmp9 ifTrue: [ tmp23 := tmp9 ] ifFalse: [ tmp23 > tmp11 ifTrue: [ tmp23 := tmp11 ] ].        tmp25 < tmp10 ifTrue: [ tmp25 := tmp10 ] ifFalse: [ tmp25 > tmp12 ifTrue: [ tmp25 := tmp12 ] ].        tmp17 cellSize: tmp25.        tmp22 ifNil: [ tmp22 := tmp17 ] ifNotNil: [ tmp16 nextCell: tmp17 ].        tmp16 := tmp17.        tmp14 := tmp14 + tmp25.        tmp23 > tmp19 ifTrue: [ tmp19 := tmp23 ] ] ].  properties reverseTableCells ifTrue: [ arg1 submorphsReverseDo: tmp3 ] ifFalse: [ arg1 submorphsDo: tmp3 ].  tmp13 > 1 ifTrue: [ tmp14 := tmp14 + ((tmp13 - 1) * tmp1) ].  (properties vResizing == #shrinkWrap and: [ properties rubberBandCells or: [ tmp20 isZero ] ]) ifTrue: [ tmp2 := (tmp2 x max: tmp19) @ tmp14 ].  (properties hResizing == #shrinkWrap and: [ properties rubberBandCells or: [ tmp21 not ] ]) ifTrue: [ tmp2 := tmp19 @ (tmp2 y max: tmp14) ].  tmp4 := arg2 left.  tmp5 := arg2 top.  tmp15 := tmp2 x - tmp19.  tmp15 < 0 ifTrue: [ tmp15 := 0 ].  tmp15 > 0 ifTrue: [ tmp21 ifTrue: [ tmp19 := tmp2 x ] ifFalse: [ tmp6 := properties wrapCentering.              tmp6 == #bottomRight ifTrue: [ tmp4 := tmp4 + tmp15 ].              tmp6 == #center ifTrue: [ tmp4 := tmp4 + (tmp15 // 2) ] ] ].  tmp15 := tmp2 y - tmp14.  tmp15 < 0 ifTrue: [ tmp15 := 0 ].  tmp7 := 0.  tmp15 > 0 ifTrue: [ tmp20 isZero ifTrue: [ tmp6 := properties listCentering.              tmp6 == #bottomRight ifTrue: [ tmp5 := tmp5 + tmp15 ].              tmp6 == #center ifTrue: [ tmp5 := tmp5 + (tmp15 // 2) ] ] ifFalse: [ tmp7 := tmp15 asFloat / tmp20 asFloat ] ].  tmp13 := 0.  tmp15 := tmp16 := 0.  tmp17 := tmp22.  [ tmp17 == nil ] whileFalse: [ tmp13 := tmp13 + 1.        tmp14 := tmp17 cellSize.        (tmp7 > 0 and: [ tmp17 vSpaceFill ]) ifTrue: [ tmp15 := (tmp16 := tmp15) + (tmp7 * tmp17 extraSpace).              tmp8 := tmp15 truncated - tmp16 truncated.              tmp14 := tmp14 + tmp8 ].        tmp17 target layoutInBounds: (tmp4 @ tmp5 extent: tmp19 @ tmp14).        tmp5 := tmp5 + tmp14 + tmp1.        tmp17 := tmp17 nextCell ]shouldntTakeLong: arg1  ^self should: arg1 notTakeMoreThanMilliseconds: self longselectableIndexAbove: arg1  ^arg1 - 1newLabelMorph: arg1 selected: arg2  ^TabLabelMorph new     roundedCorners: #(1 4);     cornerStyle: self cornerStyle;     changeTableLayout;     listDirection: #leftToRight;     listCentering: #center;     layoutInset: (self theme tabLabelInsetFor: self);     hResizing: #shrinkWrap;     vResizing: #spaceFill;     label: arg1 selected: arg2;     font: self font;     on: #mouseDown send: #tabClicked:with: to: self;     tabSelector: selfcollapseAll  self children do: #collapseAll.  self collapselazyIncrement: arg1  lazyIncrement := arg1chooseExistingFileReference: arg1 extensions: arg2 path: arg3  ^self chooseExistingFileReference: arg1 extensions: arg2 path: arg3 preview: nildefaultLabel  ^'Flash'borderColor  ^self borderStyle colordrawIconOnAthensCanvas: arg1  self hasIcon ifFalse: [ ^self ].  arg1 setPaint: self iconForm.  arg1 drawShape: (0 @ 0 extent: self iconForm extent).  arg1 pathTransform translateX: self iconForm width + 2 Y: 0state: arg1  arg1 == state ifTrue: [ ^self ].  state := arg1.  self     adoptPaneColor: self paneColor;     changedselection  ^selectionadoptPaneColor: arg1  handlesMouseDown: arg1  ^trueresetClickState  mouseClickState := nilmouseLeave: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseLeave from: arg2taskbarTask  (self valueOfProperty: #noTaskbarTask ifAbsent: [ false ]) ifTrue: [ ^nil ].  ^TaskbarTask morph: self state: self taskbarState icon: self taskbarIcon label: self taskbarLabelfillStyle  self assureExtension.  ^extension fillStyle ifNil: [ backgroundColor ifNil: [ Color transparent ] ]defaultBorderColor  ^#insetupdateSelection  self buttonMorph ifNotNil: [:arg1 |  arg1 selected: self isSelected ].  self changed: #isSelectedscrollTarget: arg1  self scroller     removeAllMorphs;     addMorph: arg1.  self updateScrollbarsfallbackMenuExplanations  | tmp1 tmp2 |  tmp2 := Dictionary newFrom: {(#menu -> self)}.  tmp1 := Smalltalk tools workspace openContents: '"Something is wrong with this menu. To investigate just debug following expression:"menu debug'.  tmp1     label: 'Fallback menu explanations';     setBindings: tmp2tearDown  cases do: [:arg1 |  arg1 delete ].  super tearDowntoggleRectangle  ^(bounds left + self indentGap) @ bounds top extent: container toggleImageWidth @ bounds heighteditor  editor ifNotNil: [ ^editor ].  ^self installEditorToReplace: nilcornerRadius  ^cornerRadiusbuildWindowMenu  ^self menuBuilder menuhasMenu  ^menu notNil or: [ retrievingBlock notNil ]mouseDown: arg1  releaseMouseFocus: arg1  self mouseFocus == arg1 ifTrue: [ self releaseMouseFocus ]bottomOffset: arg1  bottomOffset := arg1rotationCenter: arg1  | tmp1 tmp2 |  arg1 ifNotNil: [ tmp2 := self bounds.        tmp1 := tmp2 origin + (arg1 * tmp2 extent).        self setRotationCenterFrom: tmp1 ]veryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  objectToView := arg1 references at: objectToView ifAbsent: [ objectToView ]isTranslucentButNotTransparent  (color isColor and: [ color isTranslucentButNotTransparent ]) ifTrue: [ ^true ].  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) ifTrue: [ ^true ].  ^falseupdateSelectionFromModel  self listModel selection ifNotNil: [:arg1 |  self isSelectionUpdateFromView ifTrue: [ self listModel selectionChanged.              self selectionChanged ] ifFalse: [ arg1 updateView: client forModel: self listModel ] ]deselect: arg1  self isSelected: false.  subMenu ifNotNil: [ owner ifNotNil: [ owner activeSubmenu: nil ].        self removeAlarm: #deselectTimeOut: ]increment  self value: self value + 1showRightOrBottom  self show.  rightOrBottom do: [:arg1 |  arg1 show ]outerBounds  | tmp1 |  tmp1 := self bounds.  self hasDropShadow ifTrue: [ tmp1 := self expandFullBoundsForDropShadow: tmp1 ].  ^tmp1tabRefreshed: arg1  self setMultipleContentsthemeChanged  self     setProperty: #textColor toValue: self theme textColor;     updateList.  self selectionColor ifNotNil: [ self selectionColor: self theme selectionColor ].  super themeChangedautoAccept  ^autoAcceptchangeColor  | tmp1 |  tmp1 := ColorSelectorDialogWindow new     title: 'Choose color';     selectedColor: self color.  self openModal: tmp1.  tmp1 cancelled ifFalse: [ self fillStyle: tmp1 selectedColor ]getColorSelector  ^getColorSelectorreset  self subclassResponsibilitykeyText  ^keyTextacceptOnFocusChange  ^acceptOnFocusChangeaddMorph: arg1 asElementNumber: arg2  (submorphs includes: arg1) ifTrue: [ arg1 privateDelete ].  arg2 <= submorphs size ifTrue: [ self addMorph: arg1 inFrontOf: (submorphs at: arg2) ] ifFalse: [ self addMorphBack: arg1 ]canvas: arg1  canvas := arg1measureContents  ^super measureContents ceiling + (self offset * 2) asPointcrAction  ^self valueOfProperty: #crActionbasicBoxForSimpleHalos  | tmp1 |  tmp1 := self world ifNil: [ target outermostWorldMorph ].  ^((self worldBoundsForMorph: target topRendererOrSelf) expandBy: self handleAllowanceForIconicHalos) intersect: (tmp1 bounds insetBy: 8 @ 8) ifNone: [ self error: 'should not happen' ]activate: arg1  arg1 hand newMouseFocus: selfdeny: arg1 title: arg2  ^self theme denyIn: self text: arg1 title: arg2searchFor: arg1  pattern := arg1 asString trim.  ^self realSearchaddDragHandle: arg1  (self addHandle: arg1 on: #mouseDown send: #startDrag:with: to: self) on: #mouseMove send: #doDrag:with: to: selfjustifiedPadFor: arg1 font: arg2  | tmp1 |  internalSpaces = 0 ifTrue: [ ^0 ].  ^(arg2 notNil and: [ arg2 isSubPixelPositioned ]) ifTrue: [ paddingWidth * 1.0 / internalSpaces ] ifFalse: [ tmp1 := paddingWidth // internalSpaces.        arg1 <= (paddingWidth \\ internalSpaces) ifTrue: [ tmp1 + 1 ] ifFalse: [ tmp1 ] ]lineColor  ^self borderColordisplaySelectionBarOn: arg1  | tmp1 tmp2 |  selectionStart ifNil: [ ^self ].  selectionStop ifNil: [ ^self ].  tmp1 := arg1 clipRect.  selectionStart textLine = selectionStop textLine ifFalse: [ ^self ].  tmp2 := selectionStart textLine.  arg1 fillRectangle: (tmp1 left @ tmp2 top corner: tmp1 right @ tmp2 bottom) color: self selectionBarColornewHueSelector: arg1 getHue: arg2 setHue: arg3 help: arg4  ^self theme newHueSelectorIn: self for: arg1 getHue: arg2 setHue: arg3 help: arg4expandAll: arg1 except: arg2  | tmp1 |  (arg2 value: arg1 complexContents) ifFalse: [ ^self ].  arg1 toggleExpandedState.  tmp1 := OrderedCollection new: 10.  arg1 recursiveAddTo: tmp1.  tmp1 do: [:arg3 |  (arg3 canExpand and: [ arg3 isExpanded not ]) ifTrue: [ self expandAll: arg3 except: arg2 ] ]defaultBorderWidth  ^1fastFramingOn  ^self theme settings fastDragging and: [ self isFlexed not ]pageSize  ^pageSizenewSliderMorph  | tmp1 |  tmp1 := self theme builder newBracketSliderFor: self getValue: #value setValue: #value: min: 0 max: 100 quantum: 1 getEnabled: #enabled help: nil.  tmp1 fillStyle: self defaultSliderFillStyle.  ^tmp1testUpdatingSelectionsOnUpdateWithRemoval  | tmp1 tmp2 tmp3 |  tmp1 := ClassTreeExample new.  [ tmp2 := tmp1 openOn: Collection.  tmp3 := tmp1 dependents last.  tmp3 expandAll.  tmp1 selectItems: {Bag .         CharacterSet}.  tmp1 selection selectedNodes do: [:arg1 |  self assert: (tmp3 selectedMorphList anySatisfy: [:arg2 |  arg2 complexContents = arg1 ]) ].  tmp1 rootClass: Bag.  tmp1 updateList.  self assert: tmp3 selectedMorphList size equals: 1.  self assert: tmp3 selectedMorphList first complexContents withoutListWrapper identicalTo: Bag.  tmp1 selection selectedNodes do: [:arg1 |  self assert: (tmp3 selectedMorphList anySatisfy: [:arg2 |  arg2 complexContents = arg1 ]) ] ] ensure: [ tmp2 close ]removeOnlyLastSelected: arg1  self listManager removeOnlyLastSelected: arg1text: arg1 textStyle: arg2  text := arg1.  defaultColor := (arg1 attributesAt: 1) detect: [:arg3 |  arg3 isKindOf: TextColor ] ifNone: [ self color ].  textStyle := arg2.  paragraph ifNotNil: [ paragraph textStyle: arg2 ]sticky: arg1  sticky := arg1bounds: arg1  super bounds: arg1.  self adjustLayoutprepareForRotating  indicateModalChild  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self fillStyle.  tmp2 := self color alphaMixed: 0.5 with: Color black.  tmp3 := self world.  tmp4 := 0.  self assureExtension.  2 timesRepeat: [ (Delay forDuration: tmp4 milliSeconds) wait.        tmp4 := 200.        extension fillStyle: tmp2.        self privateColor: tmp2.        self invalidRect: self bounds.        tmp3 ifNotNil: [ tmp3 displayWorldSafely ].        (Delay forDuration: tmp4 milliSeconds) wait.        self fillStyle: tmp1.        tmp3 ifNotNil: [ tmp3 displayWorldSafely ].        self invalidRect: self bounds ]splitterLeft  | tmp1 |  tmp1 := (self siblingSplitters select: [:arg1 |  arg1 left < self left and: [ self overlapsVertical: arg1 ] ]) asSortedCollection: [:arg2 :arg3 |  arg2 left > arg3 left ].  ^tmp1 ifEmpty: [ nil ] ifNotEmpty: [:arg4 |  arg4 first ]fullBounds  fullBounds ifNotNil: [ ^fullBounds ].  self computeFullBounds.  ^fullBoundssetRotationCenterFrom: arg1  referencePosition := arg1.  originalCenter := self center.  originalAngle := self headingcolor: arg1  color = arg1 ifTrue: [ ^self ].  color := arg1.  self releaseCachedStateicon  ^(target perform: iconSelector) ifNil: [ super icon ]handleKeystrokeWithKeymappings: arg1  self allowsKeymapping ifTrue: [ self dispatchKeystrokeForEvent: arg1 ]paneColorTracksModel  ^trueactualClass  ^FTPropertyColumnSortingStrategybaseline  ^baselinepagerColor  ^self color darker alpha: 0.6rightFraction  ^rightFractionlabelsAndPages: arg1  self contentMorph removeAllMorphs.  self tabSelectorMorph removeAllMorphs.  arg1 do: [:arg2 |  self addPage: arg2 value label: arg2 key ]newImage: arg1  ^self theme newImageIn: self form: arg1model: arg1  model ifNotNil: [ model removeDependent: self ].  arg1 ifNotNil: [ arg1 addDependent: self ].  model := arg1taskbarCloseAllToRight  | tmp1 |  tmp1 := false.  self worldTaskbar ifNotNil: [:arg1 |  arg1 orderedTasks copy do: [:arg2 |  tmp1 ifTrue: [ arg2 morph delete ] ifFalse: [ tmp1 := arg2 morph == self ] ] ]isHorizontalScrollBarVisible  ^horizontalScrollBar ifNil: [ false ] ifNotNil: [ self horizontalScrollBar owner isNotNil ]arrowSpec: arg1  self setProperty: #arrowSpec toValue: arg1.  self computeBoundsvUpdateScrollbar  self vScrollbarNeeded ifTrue: [ self           vShowScrollbar;           vResizeScrollbar ] ifFalse: [ self vHideScrollbar ]noteNewOwner: arg1  super noteNewOwner: arg1.  (self isFullscreen and: [ labelArea owner notNil ]) ifTrue: [ self           beWithoutGrips;           removeLabelArea;           makeBorderless.        (self submorphs size = 1 and: [ self submorphs first isKindOf: PanelMorph ]) ifTrue: [ self submorphs first roundedCorners: #() ] ]delete  super delete.  morph ifNotNil: [ morph delete ].  retrievingProcess ifNotNil: [ retrievingProcess terminate ].  self triggerEvent: #tabDeleted with: selfextent: arg1  bounds extent = arg1 ifTrue: [ ^self ].  self changed.  bounds := (bounds topLeft extent: arg1) rounded.  super layoutChanged.  self changedhandlesMouseDown: arg1  ^truecellPositioning  ^cellPositioninghandleFatalDrawingError: arg1  self worldRenderer deferUpdates: false.  self primitiveError: arg1resetRootInfo  hasToggleAtRoot := nillabelClicked  labelClickable ifTrue: [ self toggleSelected ].  self doAnnounce: (LabelClicked source: self stateChanged: labelClickable)testForward  | tmp1 |  cases := {(tmp1 := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ self assert: tmp1 forwardDirection equals: 0.0 ]initializeLayout  self     changeTableLayout;     layoutInset: 2;     cellInset: 2;     listDirection: #leftToRight;     wrapDirection: #topToBottom;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     extent: self minimumExtentinitialize  super initialize.  self smoothingOnrefresh  lastRefresh := Time millisecondClockValue.  UIManager default uiProcess == Processor activeProcess ifTrue: [ self currentWorld doOneCycleNow ]initializeFilter  initialDataSource := table dataSource.  isEditingSemaphore := Semaphore new.  self spawnFilterUpdateThreadaddMorphFront: arg1  ^self addMorphInFrontOfLayer: arg1newVertex: arg1 event: arg2 fromHandle: arg3  | tmp1 |  tmp1 := arg2 cursorPoint.  self insertVertexAt: arg1 put: tmp1.  arg2 hand newMouseFocus: (handles at: (arg1 + 1) * 2 - 1)adoptPaneColor: arg1  arg1 ifNil: [ ^self ].  self sliderColor: arg1theme  (self valueOfProperty: #theme) ifNotNil: [:arg1 |  ^arg1 ].  ^self class themerotationDegrees  ^0.0cancelEdits  self releaseParagraphmarried: arg1  self item married: arg1.  self changed: #marriedthemeChanged  self     layoutInset: (self theme buttonLabelInsetFor: self);     cornerStyle: (self theme buttonCornerStyleIn: self window);     fillStyle: self themedFillStyle.  label ifNotNil: [ label color: self fillStyle asColor contrastingBlackAndWhiteColor ].  super themeChangedquestionWithoutCancel: arg1  ^self questionWithoutCancel: arg1 title: 'Question' translatedveryDeepInner: arg1  super veryDeepInner: arg1.  positionOffset := positionOffset veryDeepCopyWith: arg1.  angleOffset := angleOffset veryDeepCopyWith: arg1.  growingOrRotating := growingOrRotating veryDeepCopyWith: arg1.  directionArrowAnchor := directionArrowAnchor.  haloBox := haloBox.  originalExtent := originalExtent.  nameMorph := nameMorphselectedPressedBorderStyle  ^self theme taskbarItemSelectedPressedBorderStyleFor: selfclick  clickSelector ifNotNil: [ clickClient perform: clickSelector with: firstClickDown ]handlesDropShadowInHand  ^self theme handlesWindowDropShadowInHandFor: selfupdateCacheCanvas: arg1  | tmp1 tmp2 tmp3 |  tmp1 := Rectangle merging: (submorphs collect: [:arg2 |  arg2 fullBounds ]).  tmp2 := damageRecorder invalidRectsFullBounds: tmp1.  damageRecorder reset.  (tmp2 isEmpty and: [ cacheCanvas notNil and: [ cacheCanvas extent = tmp1 extent ] ]) ifTrue: [ ^self ].  self submorphsDo: [:arg2 |  arg2 wantsToBeCachedByHand ifFalse: [ cacheCanvas := nil.              cachedCanvasHasHoles := true.              ^self ] ].  (cacheCanvas isNil or: [ cacheCanvas extent ~= tmp1 extent ]) ifTrue: [ cacheCanvas := (arg1 allocateForm: tmp1 extent) getCanvas.        cacheCanvas translateBy: tmp1 origin negated during: [:arg3 |  self drawSubmorphsOn: arg3 ].        self submorphsDo: [:arg2 |  (arg2 areasRemainingToFill: tmp1) isEmpty ifTrue: [ ^cachedCanvasHasHoles := false ] ].        tmp3 := cacheCanvas form tallyPixelValues first.        cachedCanvasHasHoles := (tmp3 = 48 and: [ submorphs size = 1 and: [ submorphs first wantsRoundedCorners ] ]) ifTrue: [ false ] ifFalse: [ tmp3 > 0 ].        ^self ].  cacheCanvas translateBy: tmp1 origin negated during: [:arg4 |  tmp2 do: [:arg5 |  arg4 clipBy: arg5 during: [:arg6 |  arg6 fillColor: Color transparent.                    self drawSubmorphsOn: arg6 ] ] ]lastKeystrokes: arg1  lastKeystrokes := arg1newVSplitter  ^ProportionalSplitterMorph new setProperty: #model toValue: selflayoutInBounds: arg1  | tmp1 tmp2 |  arg1 = self bounds ifTrue: [ ^self ].  arg1 extent = self bounds extent ifTrue: [ ^self position: arg1 origin ].  tmp1 := bounds.  self hResizing == #shrinkWrap ifTrue: [ tmp1 := tmp1 origin extent: self minExtent x @ tmp1 height ].  self vResizing == #shrinkWrap ifTrue: [ tmp1 := tmp1 origin extent: tmp1 width @ self minExtent y ].  self hResizing == #spaceFill ifTrue: [ tmp1 := tmp1 origin extent: arg1 width @ tmp1 height ].  self vResizing == #spaceFill ifTrue: [ tmp1 := tmp1 origin extent: tmp1 width @ arg1 height ].  tmp2 := (owner ifNil: [ self ]) cellPositioning.  tmp1 := tmp1 align: (tmp1 perform: tmp2) with: (arg1 perform: tmp2).  self bounds: tmp1dispatchWindowEvent: arg1 with: arg2  arg2 isWorldMorph ifFalse: [ ^#rejected ].  arg1 wasHandled ifTrue: [ ^self ].  ^arg2 handleEvent: arg1font: arg1  font := arg1.  ^self font: font emphasis: emphasisrecenter  self repositiontoggleRectangle  | tmp1 |  tmp1 := bounds height.  ^(bounds left + (13 * indentLevel)) @ bounds top extent: 9 @ tmp1addCollapseHandle: arg1  | tmp1 |  (target owner notNil and: [ target owner isWorldOrHandMorph ]) ifFalse: [ ^self ].  tmp1 := self addHandle: arg1 on: #mouseDown send: #mouseDownInCollapseHandle:with: to: self.  tmp1 on: #mouseUp send: #maybeCollapse:with: to: self.  tmp1 on: #mouseMove send: #setDismissColor:with: to: selfrowAtLocation: arg1  | tmp1 |  tmp1 := arg1 y.  submorphs ifEmpty: [ ^nil ].  submorphs doWithIndex: [:arg2 :arg3 |  arg2 topLeft y >= tmp1 ifTrue: [ ^arg3 - 1 max: 1 ] ].  ^submorphs sizewidth  ^0setCenteredBalloonText: arg1  self setBalloonText: arg1getLastCharacter  | tmp1 |  ^(tmp1 := text string) size > 0 ifTrue: [ tmp1 last asString ] ifFalse: [ '·' ]colorForInsets  ^self paneColor colorForInsetsdotOfSize: arg1 forDirection: arg2  | tmp1 |  tmp1 := Form extent: arg1 @ arg1 depth: Display depth.  tmp1 getCanvas fillOval: tmp1 boundingBox color: self color.  ^tmp1textOwner: arg1  highlightForDrop: arg1  self setProperty: #highlightedForDrop toValue: arg1.  self changedkeystrokeActionSelector  ^keystrokeActionSelectorupdateEnabled  self model ifNotNil: [:arg1 |  self getEnabledSelector ifNotNil: [:arg2 |  self enabled: (arg1 perform: arg2) ] ]setOtherSelection: arg1  otherSelection := arg1.  arg1 ifNil: [ super borderColor: Color blue ] ifNotNil: [ itemsAlreadySelected := otherSelection selectedItems.        super borderColor: Color green ]handlesKeyboard: arg1  ^truestyle: arg1  add: arg1 subMenu: arg2  self add: arg1 icon: nil subMenu: arg2toggleImageWidth  ^self expandedToggleImage width max: self notExpandedToggleImage widthactiveTask  ^self tasks detect: [:arg1 |  arg1 isActive ] ifNone: [  ]alwaysShowVScrollbar  ^self class alwaysShowVScrollbarbuilder: arg1  builder := arg1isMorphicEvent  ^truerealSearch  self subclassResponsibilityprivateInvalidateMorph: arg1  removeAlarm: arg1 for: arg2  self alarms detect: [:arg3 |  arg3 receiver == arg2 and: [ arg3 selector == arg1 ] ] ifFound: [:arg4 |  self alarms remove: arg4 ]initializeKeyBindings  super initializeKeyBindings.  self bindKeyCombination: Character space asKeyCombination toAction: [ self interactWithSelection ]newSVSelector: arg1 help: arg2  ^self theme newSVSelectorIn: self color: arg1 help: arg2keyboardFocusChange: arg1  arg1 ifTrue: [ self editView selectAll ] ifFalse: [ self editView selectFrom: 1 to: 0 ].  super keyboardFocusChange: arg1label  ^(self labelMorph ifNil: [ ^'' ]) contentsnewButtons  ^{(self newOKButton isDefault: true) .   self newCancelButton}newOverflowRowForAll: arg1  ^self theme newOverflowRowIn: self forAll: arg1brickImageForm: arg1  | tmp1 tmp2 |  tmp2 := self fullBounds origin extent: self measureContents.  tmp1 := Display defaultCanvasClass extent: tmp2 extent depth: Display depth.  tmp1 form fillColor: arg1.  tmp1 translateBy: tmp2 topLeft negated during: [:arg2 |  arg2 fullDrawMorph: self ].  ^tmp1 form offset: tmp2 topLeftinteractionStates  ^#(normal mouseOver pressed disabled selected selectedPressed selectedMouseOver selectedDisabled)actionSelector  ^actionSelectortoggleImageHeight  ^self expandedToggleImage height max: self notExpandedToggleImage heightstart: arg1  startValue := arg1selectionColor  ^self focused ifTrue: [ self theme selectionColor ] ifFalse: [ self theme unfocusedSelectionColor ]fullBounds  self contents ifNil: [ self contents: 'String Morph' ].  ^super fullBoundsmouseLeaveDragging: arg1  self eventHandler ifNotNil: [ self eventHandler mouseLeaveDragging: arg1 fromMorph: self ]stayUp  ^stayUpfitTargetOwner  ^fitTargetOwnerchangeReverseCells  self reverseTableCells: self reverseTableCells notnewIncrementalSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newIncrementalSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8chooseExistingFileReference: arg1 extensions: arg2 path: arg3  ^self chooseExistingFileReference: arg1 extensions: arg2 path: arg3 preview: nilmouseDown: arg1  lastMouse := arg1 cursorPointinitialize  super initialize.  lastKeystrokeTime := 0.  lastKeystrokes := ''.  lastSelection := 0.  removeOnlyLastSelected := falseresetPotentialDropRow  potentialDropRow ifNotNil: [ potentialDropRow ~= 0 ifTrue: [ potentialDropRow := 0.              self changed ] ]addAlarm: arg1 withArguments: arg2 at: arg3  | tmp1 |  tmp1 := self alarmScheduler.  tmp1 ifNotNil: [ tmp1 addAlarm: arg1 withArguments: arg2 for: self at: arg3 ]addMenuHandle: arg1  self addHandle: arg1 on: #mouseDown send: #doMenu:with: to: selfpassKeyboardFocusTo: arg1  self flag: #pharoFixMe.  self world ifNotNil: [:arg2 |  arg2 handsDo: [:arg3 |  arg3 keyboardFocus == self ifTrue: [ arg3 newKeyboardFocus: arg1 ] ] ]displayExtentChanged  self updateBoundsmarriedMorph  ^(self theme newCheckboxIn: self currentWorld for: self getSelected: #married setSelected: #married: getEnabled: nil label: '' help: nil) color: Color transparentwantsKeyboardFocusFor: arg1  ^falseaddTransparentSpacerOfSize: arg1  self addMorphBack: (self transparentSpacerOfSize: arg1)translateBy: arg1  self releaseCachedStatefilterField  ^(function isKindOf: FTFilterFunction) ifTrue: [ function field ] ifFalse: [ nil ]justDroppedInto: arg1 event: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  super justDroppedInto: arg1 event: arg2.  self owner ifNil: [ ^self ].  tmp1 := arg1 bounds.  tmp5 := tmp1 bottom: tmp1 top + (tmp1 height // 5).  tmp6 := tmp1 top: tmp1 bottom - (tmp1 height // 5).  tmp2 := tmp1 right: tmp1 left + (tmp1 width // 5).  tmp2 := tmp2 top: tmp5 bottom.  tmp2 := tmp2 bottom: tmp6 top.  tmp4 := tmp1 left: tmp1 right - (tmp1 width // 5).  tmp4 := tmp4 top: tmp5 bottom.  tmp4 := tmp4 bottom: tmp6 top.  tmp3 := arg2 position.  (tmp5 containsPoint: tmp3) ifTrue: [ ^self adhereToTop ].  (tmp6 containsPoint: tmp3) ifTrue: [ ^self adhereToBottom ].  (tmp2 containsPoint: tmp3) ifTrue: [ ^self adhereToLeft ].  (tmp4 containsPoint: tmp3) ifTrue: [ ^self adhereToRight ].  self beFloatinglines  ^lines ifNil: [ ^Array new ]mouseOverThumbButtonFillStyle  ^self theme scrollbarMouseOverThumbButtonFillStyleFor: selfextraSpace  ^tabs max: [:arg1 |  arg1 extraSpaceForActions ]= arg1  ^self species = arg1 species and: [ self morph == arg1 morph and: [ self state == arg1 state and: [ self icon = arg1 icon and: [ self label = arg1 label ] ] ] ]splitsTopAndBottom  ^splitsTopAndBottomisDefault  locked == true ifTrue: [ ^false ].  visible == false ifTrue: [ ^false ].  sticky == true ifTrue: [ ^false ].  balloonText ifNotNil: [ ^false ].  externalName ifNotNil: [ ^false ].  eventHandler ifNotNil: [ ^false ].  otherProperties ifNotNil: [ otherProperties isEmpty ifFalse: [ ^false ] ].  ^trueclick: arg1 fromMorph: arg2  ^self notify: arg1 from: arg2normalThumbBorderStyle  ^self theme scrollbarNormalThumbBorderStyleFor: selfrotationDegrees  ^self forwardDirectionaction  ^actionisSteppingSelector: arg1  | tmp1 |  ^(tmp1 := self world) ifNil: [ false ] ifNotNil: [ tmp1 isStepping: self selector: arg1 ]testClickFromMorph  morph eventHandler on: #click send: #value to: true.  self assert: (morph click: nil) identicalTo: truedropElements: arg1 index: arg2  ^falseremoveFromWorld  | tmp1 tmp2 |  tmp1 := self tasks select: [:arg1 |  arg1 isMinimized ].  tmp2 := self theme shouldUseAnimations.  tmp2 ifTrue: [ self theme useAnimation: false ].  [ tmp1 do: [:arg1 |  arg1 morph           restore;           resetCollapsedFrame ].  self delete.  tmp1 do: [:arg1 |  arg1 morph minimize ] ] ensure: [ tmp2 ifTrue: [ self theme useAnimation: true ] ]elementAt: arg1  self subclassResponsibilityfirstVisibleRowIndex  ^self container firstVisibleRowIndexmouseUp: arg1  (self bounds containsPoint: arg1 cursorPoint) ifFalse: [ arg1 hand showTemporaryCursor: nil.        self           setDefaultColors;           changed ]collapse  self isCollapsed ifFalse: [ self collapseOrExpand ]embeddedInMorphicWindowLabeled: arg1  | tmp1 |  tmp1 := (SystemWindow labelled: arg1) model: nil.  tmp1 setStripeColorsFrom: (self theme windowColorFor: self).  tmp1 addMorph: self frame: (0 @ 0 extent: 1 @ 1).  ^tmp1formerOwner  ^self valueOfProperty: #formerOwnerreset  morphicLayerNumber  ^5invalidRect: arg1 from: arg2  arg2 == self ifTrue: [ super invalidRect: arg1 from: self ] ifFalse: [ super invalidRect: (((transform localBoundsToGlobal: arg1) intersect: bounds ifNone: [ ^self ]) expandBy: 1) from: self ]pathIn: arg1  self parentNode ifNotNil: [ (arg1 includes: self parentNode) ifFalse: [ self parentNode pathIn: arg1 ] ].  arg1 add: self.  ^arg1newDecrementButton  ^(self theme builder newButtonFor: self action: #decrement getEnabled: #minEnabled label: (self newButtonLabel: #left ofSize: 24) help: nil)     vResizing: #spaceFill;     width: 64;     roundedCorners: #(1 2);     setProperty: #wantsKeyboardFocusNavigation toValue: false;     on: #mouseStillDown send: #decrement to: selftestSelectableIndexAbove  self assert: (strategy selectableIndexAbove: #(2 3)) equals: #(1 3)selectLast  self selectionModeStrategy selectLastheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]updateColor  | tmp1 |  self getColorSelector ifNotNil: [ tmp1 := (self model perform: self getColorSelector) ifNil: [ Color transparent ].        self setColor: tmp1 ]isExplicite  self deprecated: 'Use #isExplicit instead' transformWith: '`@receiver isExplicite' -> '`@receiver isExplicit'.  ^self isExplicitmouseMove: arg1 on: arg2  (arg2 isNil or: [ arg2 highlightedForMouseDown not ]) ifTrue: [ self allNodeMorphs do: [:arg3 |  arg3 highlightedForMouseDown ifTrue: [ arg3 highlightForMouseDown: false ] ].        arg2 ifNotNil: [ arg2 highlightForMouseDown.              (self autoMultiSelection and: [ arg1 shiftPressed not ]) ifTrue: [ self autoMultiSelect: arg2.                    self selectionChanged ] ] ]drawMouseDownHighlightOn: arg1  self highlightedForMouseDown ifTrue: [ container ifNil: [ ^super drawMouseDownHighlightOn: arg1 ].        arg1 frameRectangle: self bounds width: 1 colors: {container mouseDownHighlightColor .               Color transparent} dashes: #(1 1) ]setHand: arg1  source := arg1openDialogWindowIn: arg1 title: arg2 selectedtems: arg3  | tmp1 |  tmp1 := self dialogWindowIn: arg1 title: arg2 selectedtems: arg3.  arg1 openModal: tmp1.  ^tmp1 cancelled ifFalse: [ self selectedItems ]stateChanged  ^stateChangedjustGrabbedFrom: arg1  (self isRenderer and: [ self hasSubmorphs ]) ifTrue: [ self firstSubmorph justGrabbedFrom: arg1 ]selectNextTab  self selectedIndex: self selectedIndex \\ self tabs size + 1initialize  alreadyActivated := falsestyleSymbols  ^#(plain inset insetNoHighlight raised raisedNoHighlight)reset  beMultipleSelection  selectionStrategy := FTMultipleSelection table: selfhasHalo: arg1  super hasHalo: arg1.  arg1 ifFalse: [ (self hasProperty: #deleting) ifFalse: [ self delete ] ]initialize  super initialize.  self changeProportionalLayout.  state := TabEnabled tab: self.  closeable := true.  label := self buildLabel: 'tab' withIcon: self defaultIcon.  closeIcon := AlphaImageMorph withForm: self class closeIcon scaledByDisplayScaleFactor.  actions := OrderedCollection new.  retrievingSemaphore := Semaphore new.  self addLabel.  self addIcon.  self addActionsToIconaddCornerGrips  self addMorphBack: (TopLeftGripMorph new           target: self;           position: self position).  self addMorphBack: (TopRightGripMorph new           target: self;           position: self position).  self addMorphBack: (BottomLeftGripMorph new           target: self;           position: self position).  self addMorphBack: (BottomRightGripMorph new           target: self;           position: self position)displayExtentChanged  self updateBoundsaddAlarm: arg1 with: arg2 at: arg3  ^self addAlarm: arg1 withArguments: (Array with: arg2) at: arg3taskbarButtonFor: arg1  ^self morph taskbarButtonFor: arg1bottomRight  ^bounds bottomRightbottomOffset  ^bottomOffsethandleMouseEnter: arg1  arg1 isDraggingEvent ifTrue: [ (self handlesMouseOverDragging: arg1) ifTrue: [ arg1 wasHandled: true.              self mouseEnterDragging: arg1 ].        ^self eventHandler ifNotNil: [:arg2 |  arg2 mouseEnterDragging: arg1 fromMorph: self ] ].  self wantsBalloon ifTrue: [ arg1 hand triggerBalloonFor: self after: self balloonHelpDelayTime ].  ^(self handlesMouseOver: arg1) ifTrue: [ arg1 wasHandled: true.        self mouseEnter: arg1 ] ifFalse: [ self eventHandler ifNotNil: [:arg2 |  arg2 mouseEnter: arg1 fromMorph: self ] ]softRetrieveMorph  | tmp1 |  morph ifNotNil: [ ^self ].  retrievingProcess ifNotNil: [ retrievingProcess isTerminated ifFalse: [ ^self ] ].  tmp1 := self icon ifNotNil: [:arg1 |  arg1 form ].  label icon: TabBuildingIconMorph new.  retrievingProcess := [ [ morph := retrievingBlock value ] ensure: [ UIManager default defer: [ self icon: tmp1.              self triggerEvent: #tabRefreshed with: self ].        [ retrievingSemaphore isEmpty ] whileFalse: [ retrievingSemaphore signal ] ] ] forkAt: Processor activePriority - 2addColumn: arg1 afterIndex: arg2  arg1 container: self.  self columns add: arg1 afterIndex: arg2.  self columnsChanged.  self updateColumnMorphs.  self updateListexpandSilently: arg1 suchThat: arg2  (arg2 value: arg1 complexContents) ifTrue: [ arg1 isExpanded ifFalse: [ arg1 expand ].        arg1 childrenDo: [:arg3 |  self expandSilently: arg3 suchThat: arg2 ] ]index  ^self container columns indexOf: selfhandsReverseDo: arg1  ^hands reverseDo: arg1getColorSelector: arg1  getColorSelector := arg1.  self update: getColorSelectorposition: arg1  ^super position: arg1 asIntegerPointnewCancelButtonFor: arg1  ^self theme newCancelButtonIn: self for: arg1clipSubmorphs  extension ifNil: [ ^false ].  ^extension clipSubmorphs ifNil: [ false ]borderStyle  ^(target notNil and: [ self showBoundsInHalo and: [ target isWorldMorph not ] ]) ifTrue: [ super borderStyle ] ifFalse: [ SimpleBorder width: 0 color: Color transparent ]setBorderStyle: arg1  | tmp1 |  tmp1 := self borderStyleForSymbol: arg1.  tmp1 ifNil: [ ^self ].  (self canDrawBorder: tmp1) ifTrue: [ self borderStyle: tmp1 ]newAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 labelForm: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: (AlphaImageMorph new image: arg6) help: arg7gripLayoutFrame  ^(0 @ 0 corner: 0 @ 0) asLayoutFrame     topOffset: -27;     rightOffset: self defaultWidthnewButtonLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newButtonLabelIn: self for: arg1 label: arg2 getEnabled: arg3path  ^self pathIn: OrderedCollection newminimumExtent  | tmp1 |  (tmp1 := self valueOfProperty: #minimumExtent) ifNotNil: [ ^tmp1 ].  ^100 @ 80mouseListeners  ^mouseListenershandlesMouseOverDragging: arg1  ^trueinitializeUpButton  upButton := self theme newScrollBarUpButtonFor: self.  upButton color: self thumbColor.  upButton on: #mouseDown send: #scrollUpInit to: self.  upButton on: #mouseUp send: #finishedScrolling to: self.  self updateUpButtonImage.  upButton     borderWidth: 1;     borderColor: Color lightGray.  upButton cornerStyle: (self theme scrollbarButtonCornerStyleIn: self window).  upButton on: #mouseUp send: #finishedScrolling: to: self.  upButton on: #mouseEnter send: #mouseEnterUpButton: to: self.  upButton on: #mouseLeave send: #mouseLeaveUpButton: to: self.  self addMorph: upButtonlastClickedMorph  ^lastClickedMorphselectionTextColor  ^color negatedborderInitialize  borderColor := self defaultBorderColor.  borderWidth := self defaultBorderWidthlabelGraphic  ^graphicalMorph formtheme  (self valueOfProperty: #theme) ifNotNil: [:arg1 |  ^arg1 ].  ^(self owner ifNil: [ self class ]) themestartColumnIndex: arg1  startColumnIndex := arg1labelBounds  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := self innerBounds.  tmp3 := self font widthOfStringOrText: self label.  tmp1 := (self height - self font height) / 2.  tmp4 := tmp5 left + self labelGap + tmp3.  tmp2 := (slider left < tmp4 or: [ sliderShadow visible and: [ sliderShadow left < tmp4 ] ]) ifTrue: [ tmp5 width - self labelGap - tmp3 ] ifFalse: [ self labelGap ].  ^tmp5 translateBy: tmp2 @ tmp1reset  invalidRects := OrderedCollection new: 15.  totalRepaint := falseselectionUpdateFromViewWhile: arg1  | tmp1 |  tmp1 := self isSelectionUpdateFromView.  isSelectionUpdateFromView := true.  arg1 ensure: [ isSelectionUpdateFromView := tmp1 ]openCenteredInWorld  self     fullBounds;     openInWorld;     center: self world clearArea centerscrollUp: arg1  self setValue: (value - (scrollDelta * arg1) - 0.000001 max: 0.0)veryDeepInner: arg1  | tmp1 tmp2 |  super veryDeepInner: arg1.  locked := locked veryDeepCopyWith: arg1.  visible := visible veryDeepCopyWith: arg1.  sticky := sticky veryDeepCopyWith: arg1.  balloonText := balloonText veryDeepCopyWith: arg1.  externalName := externalName veryDeepCopyWith: arg1.  eventHandler := eventHandler veryDeepCopyWith: arg1.  fillStyle := fillStyle veryDeepCopyWith: arg1.  layoutPolicy := layoutPolicy veryDeepCopyWith: arg1.  layoutFrame := layoutFrame veryDeepCopyWith: arg1.  layoutProperties := layoutProperties veryDeepCopyWith: arg1.  borderStyle := borderStyle veryDeepCopyWith: arg1.  cornerStyle := cornerStyle veryDeepCopyWith: arg1.  actionMap := actionMap veryDeepCopyWith: arg1.  clipSubmorphs := clipSubmorphs veryDeepCopyWith: arg1.  otherProperties ifNil: [ ^self ].  otherProperties := otherProperties copy.  self propertyNamesNotCopied do: [:arg2 |  otherProperties removeKey: arg2 ifAbsent: [  ] ].  tmp1 := self copyWeakly.  tmp2 := tmp1 collect: [:arg2 |  otherProperties removeKey: arg2 ifAbsent: [  ] ].  otherProperties := otherProperties veryDeepCopyWith: arg1.  tmp1 with: tmp2 do: [:arg3 :arg4 |  arg4 ifNotNil: [ otherProperties at: arg3 put: arg4 ] ]expandRoots  self roots do: [:arg1 |  (arg1 canExpand and: [ arg1 isExpanded not ]) ifTrue: [ arg1 toggleExpandedState ] ].  self innerWidgetChangedworldBoundsForMorph: arg1  | tmp1 |  tmp1 := self haloEnclosesFullBounds ifFalse: [ arg1 boundsIn: nil ] ifTrue: [ arg1 fullBoundsInWorld ].  self showBoundsInHalo ifTrue: [ ^tmp1 expandBy: 2 ].  ^tmp1trail  ^trail ifNil: [ #() ]computeFullBounds  [ self doLayoutIn: self layoutBounds ] on: Error do: [:arg1 |  fullBounds := bounds.        arg1 pass ]selectionTextColor  ^self theme menubarItemSelectionTextColorFor: selfselected  ^self state == #repressed or: [ self state == #on ]swapColumn: arg1 withColumn: arg2  self swapColumnAt: arg1 index withColumnAt: arg2 indexisSelectedMatchingTheState: arg1  ^arg1 notupdateBounds  self bounds: self owner clearAreatakeHighlight  container listManager lastClickedMorph: self.  container selectionChangeddataSource: arg1  dataSource := arg1.  dataSource table: self.  dataSource readyToBeDisplayed.  self resetPosition.  self refreshassureTableProperties  | tmp1 |  tmp1 := self layoutProperties.  tmp1 == self ifTrue: [ tmp1 := nil ].  tmp1 ifNil: [ tmp1 := TableLayoutProperties new initializeFrom: self.        self layoutProperties: tmp1 ].  tmp1 includesTableProperties ifFalse: [ self layoutProperties: (tmp1 := tmp1 asTableLayoutProperties) ].  ^tmp1title: arg1  self setLabel: arg1initializeNewSearch  result := OrderedCollection new.  index := 1composeToBounds  self     releaseParagraph;     paragraph.  container ifNotNil: [ self privateBounds: container bounds truncated ].  self paragraph positionWhenComposed: self position.  successor ifNotNil: [ successor predecessorChanged ]newDataSourceMatching: arg1  ^(self class searchStrategies at: self searchStrategy ifAbsent: [ self class searchStrategies at: #default ]) filterWith: arg1 pattern dataSource: selfdrawOn: arg1  touchPoints := Dictionary new.  arg1 clipBy: self bounds during: [:arg2 |  arg2 fillRectangle: self bounds color: Color white.        self           drawMonthHeaderOn: arg2;           drawWeekDayNamesOn: arg2;           drawDaysOn: arg2;           drawTodayOn: arg1.        arg2 frameRectangle: self bounds width: 1 color: Color black ]forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]mouseDown: arg1  arg1 redButtonPressed ifFalse: [ ^super mouseDown: arg1 ].  arg1 hand showTemporaryCursor: (Cursor crossHair copy offset: -9 @ -9).  self hideLocation.  self selectColorAt: arg1 position.  ^super mouseDown: arg1drawLinesOn: arg1  | tmp1 |  tmp1 := self lineColor.  arg1 transformBy: scroller transform clippingTo: scroller innerBounds during: [:arg2 |  scroller submorphs do: [:arg3 |  | tmp2 |              ((arg3 isExpanded and: [ (arg3 nextSibling notNil and: [ arg2 isVisible: (arg3 fullBounds topLeft corner: arg3 nextSibling fullBounds bottomRight) ]) or: [ arg3 nextSibling isNil and: [ (tmp2 := arg3 lastChild) notNil and: [ arg2 isVisible: (arg3 fullBounds topLeft corner: tmp2 fullBounds bottomRight) ] ] ] ]) or: [ (arg2 isVisible: arg3 fullBounds) or: [ arg3 nextSibling notNil and: [ arg2 isVisible: arg3 nextSibling fullBounds ] ] ]) ifTrue: [ arg3 drawLinesOn: arg2 lineColor: tmp1 ] ] ] smoothing: scroller smoothinghandleMouseUp: arg1  arg1 wasHandled ifTrue: [ ^self ].  arg1 hand mouseFocus == self ifFalse: [ ^self ].  arg1 hand releaseMouseFocus: self.  arg1 wasHandled: true.  ^arg1 blueButtonChanged ifTrue: [ self blueButtonUp: arg1.        self eventHandler ifNotNil: [:arg2 |  arg2 mouseUp: arg1 fromMorph: self ] ] ifFalse: [ | tmp1 |        tmp1 := self mouseUp: arg1.        self stopSteppingSelector: #handleMouseStillDown:.        tmp1 ]computeExtraSpacing: arg1 in: arg2 horizontal: arg3 target: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 |  tmp1 := arg2 extent.  arg3 ifFalse: [ tmp1 := tmp1 transposed ].  tmp8 := tmp9 := false.  tmp10 := 0 @ 0.  arg1 do: [:arg5 |  tmp10 := (tmp10 x max: arg5 cellSize x) @ (tmp10 y + arg5 cellSize y).        tmp10 := tmp10 max: arg5 cellSize.        tmp8 := tmp8 or: [ arg5 hSpaceFill ].        tmp9 := tmp9 or: [ arg5 vSpaceFill ] ].  tmp12 := properties rubberBandCells not.  arg4 hResizing == #shrinkWrap ifTrue: [ arg3 ifTrue: [ tmp12 & tmp8 ifFalse: [ tmp1 := tmp10 x @ (tmp10 y max: tmp1 y) ] ] ifFalse: [ tmp12 & tmp9 ifFalse: [ tmp1 := (tmp10 x max: tmp1 x) @ tmp10 y ] ] ].  arg4 vResizing == #shrinkWrap ifTrue: [ arg3 ifFalse: [ tmp12 & tmp8 ifFalse: [ tmp1 := tmp10 x @ (tmp10 y max: tmp1 y) ] ] ifTrue: [ tmp12 & tmp9 ifFalse: [ tmp1 := (tmp10 x max: tmp1 x) @ tmp10 y ] ] ].  tmp2 := tmp1 y - (arg1 inject: 0 into: [:arg6 :arg5 |  arg6 + arg5 cellSize y ]).  tmp2 > 0 ifTrue: [ tmp9 ifTrue: [ tmp4 := arg1 inject: 0 into: [:arg6 :arg5 |  arg5 vSpaceFill ifTrue: [ arg6 + 1 ] ifFalse: [ arg6 ] ].              tmp4 isZero ifFalse: [ tmp5 := tmp2 asFloat / tmp4 asFloat ].              tmp2 := tmp7 := 0.              arg1 do: [:arg5 |  arg5 vSpaceFill ifTrue: [ tmp2 := (tmp7 := tmp2) + tmp5.                          tmp11 := 0 @ (tmp2 truncated - tmp7 truncated).                          arg5 do: [:arg7 |  arg7 cellSize: arg7 cellSize + tmp11 ] ] ] ] ifFalse: [ tmp3 := properties wrapCentering.              tmp3 == #bottomRight ifTrue: [ arg1 first addExtraSpace: 0 @ tmp2 ].              tmp3 == #center ifTrue: [ arg1 first addExtraSpace: 0 @ (tmp2 // 2) ].              tmp3 == #justified ifTrue: [ tmp4 := arg1 size - 1 max: 1.                    tmp5 := tmp2 asFloat / tmp4 asFloat.                    tmp2 := tmp7 := 0.                    arg1 do: [:arg5 |  arg5 addExtraSpace: 0 @ (tmp2 truncated - tmp7 truncated).                          tmp2 := (tmp7 := tmp2) + tmp5 ] ] ] ].  tmp3 := properties listCentering.  1 to: arg1 size do: [:arg8 |  tmp6 := arg1 at: arg8.        tmp2 := tmp1 x - tmp6 cellSize x.        tmp2 > 0 ifTrue: [ tmp6 := tmp6 nextCell.              tmp6 hSpaceFill ifTrue: [ tmp4 := tmp6 inject: 0 into: [:arg6 :arg5 |  arg5 hSpaceFill ifTrue: [ arg6 + arg5 target spaceFillWeight ] ifFalse: [ arg6 ] ].                    tmp4 isZero ifFalse: [ tmp5 := tmp2 asFloat / tmp4 asFloat ].                    tmp2 := tmp7 := 0.                    tmp6 do: [:arg5 |  arg5 hSpaceFill ifTrue: [ tmp2 := (tmp7 := tmp2) + (tmp5 * arg5 target spaceFillWeight).                                tmp11 := tmp2 truncated - tmp7 truncated.                                arg5 cellSize: arg5 cellSize + (tmp11 @ 0) ] ] ] ifFalse: [ tmp3 == #bottomRight ifTrue: [ tmp6 addExtraSpace: tmp2 @ 0 ].                    tmp3 == #center ifTrue: [ tmp6 addExtraSpace: (tmp2 // 2) @ 0 ].                    tmp3 == #justified ifTrue: [ tmp4 := tmp6 size - 1 max: 1.                          tmp5 := tmp2 asFloat / tmp4 asFloat.                          tmp2 := tmp7 := 0.                          tmp6 do: [:arg5 |  arg5 addExtraSpace: (tmp2 truncated - tmp7 truncated) @ 0.                                tmp2 := (tmp7 := tmp2) + tmp5 ] ] ] ] ]on: arg1 send: arg2 to: arg3  self addSubscription: (MorphEventSubscription on: arg1 send: arg2 to: arg3) toEvent: arg1framePolyline: arg1 on: arg2  | tmp1 tmp2 |  tmp1 := arg1 first.  2 to: arg1 size do: [:arg3 |  tmp2 := arg1 at: arg3.        self drawLineFrom: tmp1 to: tmp2 on: arg2.        tmp1 := tmp2 ]trackColorFrom: arg1  activate  super activate.  self active: truenewButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 getLabel: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 getLabel: arg6 help: arg7toggleExpandedState: arg1 event: arg2  | tmp1 |  arg2 yellowButtonPressed ifTrue: [ tmp1 := arg1 isExpanded.        scroller submorphs copy do: [:arg3 |  (arg3 canExpand and: [ arg3 isExpanded = tmp1 ]) ifTrue: [ arg3 toggleExpandedState ] ] ] ifFalse: [ arg1 toggleExpandedState ].  self adjustSubmorphPositionsnewLabelFor: arg1 getLabel: arg2 getEnabled: arg3  ^self theme newLabelIn: self for: arg1 getLabel: arg2 getEnabled: arg3stateChanged: arg1  stateChanged := arg1resumeAfterStepError  self startStepping.  self removeProperty: #errorOnStepcheckForNewScreenSize  mergeDropThird: arg1 in: arg2 from: arg3  | tmp1 tmp2 |  (arg3 includes: (arg1 at: arg1 size - 2)) ifTrue: [ (arg3 includes: arg1 last) ifTrue: [ tmp1 := arg1 last ] ] ifFalse: [ (arg3 includes: arg1 last) ifTrue: [ (arg3 includes: arg1 second) ifTrue: [ tmp1 := arg1 first ] ] ].  (arg3 includes: arg1 third) ifTrue: [ (arg3 includes: arg1 second) ifTrue: [ tmp1 := arg1 second ] ].  tmp1 ifNil: [ ^nil ].  arg1 remove: tmp1.  arg2 remove: tmp1.  arg3 remove: tmp1.  [ arg3 includes: arg1 first ] whileFalse: [ tmp2 := arg1 removeFirst.        arg1 addLast: tmp2 ].  [ arg1 first = arg2 first ] whileFalse: [ tmp2 := arg2 removeFirst.        arg2 addLast: tmp2 ]playRestoreUpSound  self theme windowRestoreUpSound playnextPage: arg1  self currentPage: (self pageOfNodeIndex: arg1)doDrag: arg1 with: arg2  | tmp1 |  arg1 hand obtainHalo: self.  tmp1 := target point: arg1 position - positionOffset from: owner.  target setConstrainedPosition: tmp1 hangOut: truepressedFillStyle  ^self theme morphTreeSplitterPressedFillStyleFor: selftoggleState  self isOn ifTrue: [ self turnOff ] ifFalse: [ self turnOn ]changeDragAndDrop  ^self enableDragNDrop: self dragNDropEnabled notisComplex  ^truenewNoButton  ^self newNoButtonFor: selfaddPaneSplittersIfNeeded  (isCollapsed not and: [ self paneMorphs isNotEmpty and: [ self splitters isEmpty ] ]) ifTrue: [ self addPaneSplitters ]modifierKeyPressed: arg1  | tmp1 tmp2 |  tmp2 := arg1 keyCharacter.  keystrokeActionSelector ifNil: [ ^nil ].  tmp1 := keystrokeActionSelector numArgs.  tmp1 = 1 ifTrue: [ ^model perform: keystrokeActionSelector with: tmp2 ].  tmp1 = 2 ifTrue: [ ^model perform: keystrokeActionSelector with: tmp2 with: self ].  ^self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'doScale: arg1 with: arg2  | tmp1 tmp2 |  arg1 hand obtainHalo: self.  tmp1 := arg1 cursorPoint - (arg2 extent // 2).  target scaleToMatch: tmp1.  tmp2 := target scale = 1.0 ifTrue: [ Color yellow ] ifFalse: [ Color orange ].  self setColor: tmp2 toHandle: arg2.  arg2 submorphsDo: [:arg3 |  arg3 color: tmp2 contrastingBlackAndWhiteColor ].  arg2 position: tmp1is: arg1 overlappingDamagedAreaIn: arg2  | tmp1 |  tmp1 := arg1 fullBounds.  ^arg2 anySatisfy: [:arg3 |  arg3 intersects: tmp1 ]intercellSpacing: arg1  intercellSpacing := arg1 asPointrestoreMorphicDisplay  worldState worldRenderer restoreMorphicDisplaynewTextEntryFor: arg1 getText: arg2 setText: arg3 help: arg4  ^self newTextEntryFor: arg1 get: arg2 set: arg3 class: String getEnabled: nil help: arg4displayScaleFactor  ^self class displayScaleFactorwidthToDisplayItem: arg1  | tmp1 |  tmp1 := arg1 collect: [:arg2 |  arg2 widthToDisplayInList: self ].  ^tmp1 sum + ((listSource gapSize + 4) * (tmp1 size - 1))normalBorderStyle  ^self theme taskbarItemNormalBorderStyleFor: selfshiftedYellowButtonActivity  self editor pluggableYellowButtonActivity: true.  self changedstepTime: arg1  stepTime := arg1scaleFactor  ^transform scaleasSpAdapter  self deprecated: 'Instead of #asSpAdapter you should use a SpMorphPresenter'.  ^(SpBindings value adapterClass: #GenericAdapter) morph: selfactionsChanged: arg1  self selectedTab = arg1 ifFalse: [ ^self ].  self adjustLayouthasIcon  ^icon notNildepth: arg1  depth := arg1adjustSegmentPointsForArrows  | tmp1 |  (self isClosed or: [ self hasArrows not ]) ifTrue: [ ^self vertices ].  tmp1 := self vertices copy.  (arrows == #back or: [ arrows == #both ]) ifTrue: [ | tmp2 |        tmp2 := self arrowBoundsAt: tmp1 first from: tmp1 second.        tmp2 size = 4 ifTrue: [ tmp1 at: 1 put: tmp2 third ] ifFalse: [ tmp1 at: 1 put: (tmp2 copyFrom: 2 to: 3) average ] ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ | tmp2 |        tmp2 := self arrowBoundsAt: tmp1 last from: tmp1 nextToLast.        tmp2 size = 4 ifTrue: [ tmp1 at: tmp1 size put: tmp2 third ] ifFalse: [ tmp1 at: tmp1 size put: (tmp2 copyFrom: 2 to: 3) average ] ].  ^tmp1originalColor  ^originalColorsource  ^sourcescheduledTime: arg1  scheduledTime := arg1ensureVisibleFirstSelection  | tmp1 |  (self hasSelection not or: [ self container isRowIndexFullyVisible: (tmp1 := self selectionModeStrategy selectedRowIndex) ]) ifTrue: [ ^self ].  tmp1 < self showIndex ifTrue: [ self moveShowIndexTo: self selectedIndex ] ifFalse: [ self moveShowIndexTo: (self selectionModeStrategy indexForRow: tmp1 - self container calculateMinVisibleRows + 1) ]defaultTaskbarThumbnailExtent  ^320 @ 320color  ^color ifNil: [ Color transparent ]handlesMouseOver: arg1  ^truelistItemHeight  ^12initialize  super initialize.  width := 1.  color := Color transparenthandleEvent: arg1  ^arg1 sentTo: selfquestionWithoutCancel: arg1 title: arg2  ^self theme questionWithoutCancelIn: self text: arg1 title: arg2clipSubmorphs  ^truehasHalo: arg1  arg1 ifTrue: [ self setProperty: #hasHalo toValue: true ] ifFalse: [ self removeProperty: #hasHalo ]nextMorphWantingFocus  | tmp1 |  tmp1 := self nextMorphInWindow ifNil: [ ^nil ].  [ tmp1 = self or: [ tmp1 wantsKeyboardFocusNavigation ] ] whileFalse: [ tmp1 := tmp1 nextMorphInWindow ].  ^tmp1 wantsKeyboardFocusNavigation ifTrue: [ tmp1 ]isStepping: arg1 selector: arg2  ^worldState isStepping: arg1 selector: arg2expandAll  self expand: SmallInteger maxValdefaultColor  ^Color transparentdrawDashedBorderOn: arg1  self drawDashedBorderOn: arg1 usingEnds: (Array with: vertices first with: vertices last)proceed: arg1  ^self proceed: arg1 title: 'Proceed' translatedemptyTabColor: arg1  contentsWrapper color: arg1privateRemoveMorph: arg1  backgroundMorph == arg1 ifTrue: [ backgroundMorph := nil ].  ^super privateRemoveMorph: arg1indentLevel  ^indentLevelsetUpdatablePanesFrom: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := OrderedCollection new.  self allMorphsDo: [:arg2 |  (arg2 isKindOf: PluggableListMorph) ifTrue: [ tmp2 add: arg2 ] ].  arg1 do: [:arg3 |  tmp2 detect: [:arg2 |  arg2 getListSelector == arg3 ] ifFound: [:arg4 |  tmp1 add: arg4 ] ].  updatablePanes := tmp1 asArraynewGroupboxFor: arg1  ^self theme newGroupboxIn: self for: arg1type  ^self subclassResponsibilityhandleMouseUp: arg1  ^self dispatchDefault: arg1 with: morphinitialize  super initialize.  self     hResizing: #spaceFill;     vResizing: #spaceFillrejectsEvent: arg1  ^(arg1 isMouse and: [ arg1 isMouseDown ]) or: [ super rejectsEvent: arg1 ]current: arg1  bar value: arg1.  self changedpopUpForHand: arg1  | tmp1 |  self lock.  self fullBounds.  self setProperty: #morphicLayerNumber toValue: self morphicLayerNumber.  arg1 world addMorphFront: self.  ((tmp1 := arg1 world bounds) containsRect: self bounds) ifFalse: [ self bounds: (self bounds translatedToBeWithin: tmp1) ].  arg1 balloonHelp: selfstep  progress := progress + 1.  progress > 10 ifTrue: [ progress := 1 ].  progressIconMorph form: self currentIconcolor: arg1  super color: arg1.  originalColor := arg1 asColor.  self updateColorveryDeepCopyWith: arg1  self prepareToBeSaved.  ^super veryDeepCopyWith: arg1selectedItem  ^self selectedNode ifNotNil: [:arg1 |  arg1 item ]pasteUpMorphHandlingTabAmongFields  | tmp1 |  tmp1 := self owner.  [ tmp1 notNil ] whileTrue: [ tmp1 tabAmongFields ifTrue: [ ^tmp1 ].        tmp1 := tmp1 owner ].  ^nilmouseLeaveDragging: arg1  (self dropEnabled and: [ arg1 hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: arg1 ].  self resetPotentialDropMorph.  arg1 hand releaseMouseFocus: selfautoScrollHeightLimit  ^20testSelectedRowIndex  self subclassResponsibilityshadowColor  ^self valueOfProperty: #shadowColor ifAbsent: [ Color black ]comeToFront  | tmp1 |  tmp1 := self topRendererOrSelf.  (tmp1 owner isNil or: [ tmp1 owner hasSubmorphs not ]) ifTrue: [ ^self ].  tmp1 owner firstSubmorph == tmp1 ifFalse: [ tmp1 owner addMorphFront: tmp1 ]basicHeaderCellFor: arg1  | tmp1 |  arg1 id ifNil: [ ^nil ].  tmp1 := FTHeaderColumnCellMorph new     listCentering: #center;     column: arg1;     cellInset: 5;     addMorph: arg1 id asStringMorph;     yourself.  arg1 sortingIcon ifNotNil: [:arg2 |  tmp1 addMorph: arg2 ].  ^tmp1countAvailableRows  availableRows := rootItems inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 availableRows ]initialize  super initialize.  touchPoints := Dictionary newdo: arg1  self changed.  ^[ arg1 value: self ] ensure: [ self close ]isEditable: arg1  ^self isEditable and: [ arg1 shiftPressed ]title  ^self labelnewTasksMorph  ^Morph new     changeTableLayout;     listDirection: #leftToRight;     wrapDirection: #topToBottom;     cellInset: 1;     color: Color transparent;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     yourselfmouseMove: arg1  arg1 redButtonPressed ifFalse: [ ^self ].  self handleInteraction: [ editor mouseMove: arg1 ]selectRowIndex: arg1  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver selectRowIndex: `@statements1' -> '`@receiver selectIndex: `@statements1'.  self selectIndex: arg1getTextSelector  ^getTextSelectorinitWithContents: arg1 prior: arg2 forList: arg3 indentLevel: arg4  container := arg3.  complexContents := arg1.  indentLevel := arg4.  self initWithContents: arg1 asString font: StandardFonts listFont emphasis: nil.  isExpanded := false.  nextSibling := firstChild := nil.  arg2 ifNotNil: [ arg2 nextSibling: self ].  icon := arg1 icon.  self extent: self minWidth @ self minHeightnewExpander: arg1 for: arg2  ^self theme newExpanderIn: self label: arg1 forAll: {arg2}pinboxClicked  self stayUp: truearrowEvent: arg1 key: arg2 target: arg3  ^falseenabled  ^enableddefaultTarget  ^defaultTargettestSelectableIndexBefore  self subclassResponsibilitytype  ^#dropEventinitialize  super initialize.  state := #off.  actionSelector := #flash.  arguments := EmptyArray.  actWhen := #buttonUpdelete  self mustNotClose ifTrue: [ ^self ].  self model ifNotNil: [ self model okToChange ifFalse: [ ^self ].        self model okToClose ifFalse: [ ^self ] ].  self isFullscreen ifTrue: [ self owner delete ] ifFalse: [ super delete ]testKeyStrokeFromMorph  | tmp1 |  tmp1 := KeyboardEvent new setType: #keystroke buttons: 2 position: nil keyValue: nil charCode: 65 hand: nil stamp: nil.  morph eventHandler on: #keyStroke send: #value to: true.  self assert: (morph handleKeystroke: tmp1) identicalTo: trueselected: arg1  self removeAllMorphs.  self isSelected ifTrue: [ self addMorph: self selectedLabel ] ifFalse: [ self addMorph: self normalLabel ]direction: arg1  direction := arg1drawOn: arg1  self     isEnabled;     basicDrawOn: arg1;     drawKeyTextOn: arg1setDashOnStroke: arg1  | tmp1 tmp2 |  tmp1 := self dashedBorder.  tmp2 := tmp1 size > 3 ifTrue: [ tmp1 fourth ] ifFalse: [ 0 ].  arg1 dashes: {tmp1 first .         tmp1 second} offset: tmp2newStack  ^self theme newStackIn: self for: #()announcer  ^self valueOfProperty: #announcer ifAbsentPut: [ Announcer new ]initialize  super initialize.  referencePosition := self centerapplyChanges  self acceptTextMorphsdecrement  bar decrementreplaceBoxes  labelArea removeAllMorphs.  self setLabelWidgetAllowance.  self theme configureWindowLabelAreaFor: self.  self setFramesForLabelArea.  self isActive ifFalse: [ labelArea passivate ]borderColor  ^self theme lightBackgroundColornoteRemovalOfAll: arg1  arg1 do: [:arg2 |  self selectedMorphList remove: arg2 ifAbsent: [  ].        lastClickedMorph == arg2 ifTrue: [ lastClickedMorph := nil ] ]form: arg1  image := arg1.  super extent: (2 * self borderWidth) asPoint + image extent.  self changedtoggleVisibleAndRaise  self visible ifTrue: [ self hide ] ifFalse: [ self           comeToFront;           show ]splitsTopAndBottom  ^self isHorizontalkeyStroke: arg1  | tmp1 |  (self scrollByKeyboard: arg1) ifTrue: [ ^self ].  (self navigationKey: arg1) ifTrue: [ ^self ].  tmp1 := arg1 keyCharacter.  keystrokeSelector ifNotNil: [ (self keystrokeAction: arg1) ifTrue: [ ^self ] ].  tmp1 asciiValue < 32 ifTrue: [ ^self specialKeyPressed: arg1 ].  (arg1 anyModifierKeyPressed or: [ self handlesBasicKeys not ]) ifTrue: [ ^self modifierKeyPressed: arg1 ].  ^self basicKeyPressed: tmp1pinForm  ^CircleMorph new     extent: 8 @ 8;     borderWidth: 2;     color: self pinColor;     imageFormhandlesKeyboard: arg1  ^truepotentialDropItem  self potentialDropRow = 0 ifTrue: [ ^self ].  ^self getListItem: self potentialDropRowaddAlarm: arg1 with: arg2 with: arg3 after: arg4  ^self addAlarm: arg1 withArguments: (Array with: arg2 with: arg3) after: arg4organizeIntoColumn  ((AlignmentMorph inAColumn: (selectedItems asSortedCollection: [:arg1 :arg2 |  arg1 top < arg2 top ]))     setNameTo: 'Column';     color: Color orange muchLighter;     enableDragNDrop: true;     yourself) openInHandprintOn: arg1  arg1 nextPut: $[.  arg1     nextPutAll: self position printString;     space.  arg1     nextPutAll: self type;     space.  arg1 nextPutAll: self windowIndex printString.  arg1 nextPut: $]drawOnAthensCanvas: arg1  listItems isEmpty ifTrue: [ ^self ].  1 to: listItems size do: [:arg2 |  (listSource itemSelectedAmongMultiple: arg2) ifTrue: [ self athensDrawBackgroundForSelectedRow: arg2 on: arg1 ] ifFalse: [ listSource searchedElement = arg2 ifTrue: [ self athensDrawBackgroundForSearchedRow: arg2 on: arg1 ] ifFalse: [ (listSource backgroundColorFor: arg2) ifNotNil: [:arg3 |  self athensDrawBackgroundForRow: arg2 on: arg1 color: arg3 ] ] ].        selectedRow = arg2 ifTrue: [ self athensDrawSelectionOn: arg1 ].        (listSource separatorAfterARow: arg2) ifTrue: [ self athensDrawSeparatorAfter: arg2 on: arg1 ].        self athensDisplay: (self item: arg2) atRow: arg2 on: arg1 ].  listSource potentialDropRow > 0 ifTrue: [ self athensHighlightPotentialDropRow: listSource potentialDropRow on: arg1 ]passiveEnabledOverDownFillStyle: arg1  self stateMap atPath: #(passive enabled over down) put: arg1.  self changedisMove  ^falseenable  self enabled: truecommandKeySelectors  | tmp1 |  tmp1 := self valueOfProperty: #commandKeySelectors ifAbsentPut: [ self initializeDesktopCommandKeySelectors ].  ^tmp1updateLayoutInDockingBar  owner isVertical ifTrue: [ self hResizing: #spaceFill.        self vResizing: #shrinkWrap ] ifFalse: [ self hResizing: #shrinkWrap.        self vResizing: #spaceFill ].  self extent: self minWidth @ self minHeightadoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self selectionColor: self selectionColor.  self fillStyle: self fillStyleToUse.  self borderWidth > 0 ifTrue: [ self borderStyle: self borderStyleToUse ]toggleEnabled  self enabled: self enabled notrenderedMorph  submorphs isEmpty ifTrue: [ ^self ].  ^self firstSubmorph renderedMorphtakesKeyboardFocus  ^truegetMenu: arg1  | tmp1 |  tmp1 := super getMenu: arg1.  tmp1 ifNotNil: [ tmp1 commandKeyHandler: self ].  ^tmp1asText  ^textdrawOnAthensCanvas: arg1  self drawOnCanvasWrapperFor: arg1width  ^widthbuildWithSpec  ^selfexpandWithoutChange  isExpanded := trueinteractionState  | tmp1 tmp2 |  tmp1 := self getModelState.  tmp2 := (self valueOfProperty: #mouseEntered) == true.  ^(self enabled ifNil: [ true ]) ifTrue: [ showSelectionFeedback ifTrue: [ tmp1 ifTrue: [ #selectedPressed ] ifFalse: [ #pressed ] ] ifFalse: [ tmp2 ifTrue: [ tmp1 ifTrue: [ #selectedMouseOver ] ifFalse: [ #mouseOver ] ] ifFalse: [ tmp1 ifTrue: [ #selected ] ifFalse: [ #normal ] ] ] ] ifFalse: [ tmp1 ifTrue: [ #selectedDisabled ] ifFalse: [ #disabled ] ]handler: arg1  handler := arg1resetWorldMenu  worldState resetWorldMenudefaultColor  ^Color transparentaddMorph: arg1 inFrontOf: arg2  ^self privateAddMorph: arg1 atIndex: ((submorphs indexOf: arg2) max: 1)areasRemainingToFill: arg1  ^self isOpaque ifTrue: [ arg1 areasOutside: self bounds ] ifFalse: [ Array with: arg1 ]column  ^columnactiveHand: arg1  worldState activeHand: arg1debugDrawLineRectsOn: arg1  self paragraph lines do: [:arg2 |  arg1 frameRectangle: arg2 rectangle color: Color brown ]positionPoint: arg1  (#(top bottom) includes: self edgeName) ifTrue: [ ^self position: self left @ arg1 y ].  (#(left right) includes: self edgeName) ifTrue: [ ^self position: arg1 x @ self top ].  ^self position: arg1wantsGradientByDefault  ^falsemorph: arg1  morph := arg1boundsInWorld  ^self bounds: self bounds in: self worldrightLayoutFrame  ^(1 @ 0 corner: 1 @ 1) asLayoutFrame     topLeftOffset: SystemWindow borderWidth negated @ -7;     bottomOffset: SystemWindow borderWidth - 26removeProperty: arg1  otherProperties ifNil: [ ^self ].  otherProperties removeKey: arg1 ifAbsent: [  ].  otherProperties isEmpty ifTrue: [ self removeOtherProperties ]setItem: arg1 model: arg2  item := arg1.  model := arg2handlesKeyboard: arg1  ^trueresizeCursor  ^Cursor resizeForEdge: #bottomRighteditBalloonHelpText  self editBalloonHelpContent: self balloonTextlayoutBounds: arg1  super layoutBounds: arg1.  self     resizeScroller;     setScrollDeltasisInSystemWindow  ^owner isMorph and: [ owner isSystemWindow or: [ owner isInSystemWindow ] ]retrieveMorph: arg1  morph ifNotNil: [ arg1 value: morph.        ^nil ].  retrievingSemaphore isSignaled ifFalse: [ self softRetrieveMorph ].  ^[ retrievingSemaphore wait.  morph ifNotNil: [ UIManager default defer: [ arg1 value: morph ] ] ] forkrecomposeChain  self withSuccessorsDo: [:arg1 |  arg1           text: text textStyle: textStyle;           releaseParagraph;           fit ]findSimilarPathMatchIn: arg1  self withSiblingsDo: [:arg2 |  (arg2 complexContents asString sameAs: arg1 first) ifTrue: [ ^arg2 ] ].  ^nilensureSafePattern: arg1  ^[ arg1 asRegexIgnoringCase ] on: RegexSyntaxError do: [:arg2 |   ]world: arg1  world := arg1dashLengths: arg1  dashLengths := arg1shouldInvalidateOnMouseTransition  ^falsehighlightForMouseDown: arg1  arg1 ifTrue: [ self setProperty: #highlightedForMouseDown toValue: arg1 ] ifFalse: [ self removeProperty: #highlightedForMouseDown.        self resetExtension ].  self changedcolumnColorForEven: arg1  columnColors at: 2 put: nil.  columnColors at: 1 put: arg1topLeftOffset: arg1  topOffset := arg1 y.  leftOffset := arg1 xbrickApi  ^self valueOfProperty: #brickApi ifAbsentPut: [ GLMBrickMorphWrapper on: self ]removeEventListener: arg1  self eventListeners: (self removeListener: arg1 from: self eventListeners)navigateFocus  self rememberedKeyboardFocus ifNil: [ self navigateFocusForward ] ifNotNil: [:arg1 |  arg1 world ifNotNil: [ arg1 wantsKeyboardFocus ifTrue: [ arg1 takeKeyboardFocus ] ifFalse: [ self navigateFocusForward ] ] ]transformBy: arg1  position := arg1 globalPointToLocal: position.  startPoint := arg1 globalPointToLocal: startPointgetListSelector  ^getListSelectorhandleAsMouseLeave: arg1  self keepLeftMorphsOrder.  self informMouseLeaveToLeftMorphsUsing: arg1doButtonAction  (target notNil and: [ actionSelector notNil ]) ifTrue: [ Cursor normal showWhile: [ target perform: actionSelector withArguments: arguments ].        target isMorph ifTrue: [ target changed ] ]setSelectedSelector: arg1  setSelectionSelector := arg1bounds: arg1  selectedItems := OrderedCollection new.  self     position: arg1 topLeft;     extent: arg1 extenthasFocus  ^hasFocusisExpanded  ^isExpandedwindow  ^windowfitTargetOwner: arg1  fitTargetOwner := arg1targetPoint: arg1  | tmp1 tmp2 |  tmp2 := self target bounds withSideOrCorner: self ptName setToPoint: arg1.  tmp1 := self target minimumExtent.  tmp2 width <= tmp1 x ifTrue: [ (self ptName = #topLeft or: [ self ptName = #bottomLeft ]) ifTrue: [ tmp2 := tmp2 withSideOrCorner: #left setToPoint: self target bounds bottomRight - tmp1 ] ifFalse: [ tmp2 := tmp2 withSideOrCorner: #right setToPoint: self target bounds topLeft + tmp1 ] ].  tmp2 height <= tmp1 y ifTrue: [ (self ptName = #topLeft or: [ self ptName = #topRight ]) ifTrue: [ tmp2 := tmp2 withSideOrCorner: #top setToPoint: self target bounds bottomRight - tmp1 ] ifFalse: [ tmp2 := tmp2 withSideOrCorner: #bottom setToPoint: self target bounds topLeft + tmp1 ] ].  self target bounds: tmp2completedWidth  | tmp1 tmp2 tmp3 |  tmp1 := end - start.  tmp3 := value - start.  tmp2 := tmp3 / tmp1.  ^(tmp2 * self totalBarWidth) truncatedselectionOneOf: arg1  arg1 do: [:arg2 |  | tmp1 |        tmp1 := scroller submorphs findFirst: [:arg3 |  arg3 withoutListWrapper = arg2 withoutListWrapper ].        tmp1 > 0 ifTrue: [ ^self selectionIndex: tmp1 ] ].  self selectionIndex: 0initialize  super initialize.  filterClass := FTRegexFilterdefaultBorderWidth  ^self theme menubarBorderWidthFor: selffindA: arg1  ^self submorphs detect: [:arg2 |  arg2 isKindOf: arg1 ] ifNone: [ nil ]buildHandleMenu: arg1  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 addLine.  self addStandardHaloMenuItemsTo: tmp1 hand: arg1.  tmp1 defaultTarget: arg1.  self addAddHandMenuItemsForHalo: tmp1 hand: arg1.  tmp1 defaultTarget: self.  self addCustomHaloMenuItems: tmp1 hand: arg1.  tmp1 defaultTarget: arg1.  ^tmp1griddingOn  ^griddingOn ifNil: [ false ]toggleResizeToFit  self vResizeToFit: self resizeToFit notsetUp  super setUp.  windows := OrderedCollection new.  tasks := OrderedCollection new.  self theMethodInProdThatShouldBeTestedtestExecuteSortingOn  | tmp1 |  tmp1 := self dataSourceForTesting.  state executeSortingOn: tmp1.  self assert: tmp1 elements equals: #(10 9 8 7 6 5 4 3 2 1).  state executeSortingOn: tmp1.  self assert: tmp1 elements equals: #(10 9 8 7 6 5 4 3 2 1)minimumExtent  ^40 @ 25keyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self focusChangedalwaysShowScrollBars: arg1  self     alwaysShowHScrollBar: arg1;     alwaysShowVScrollBar: arg1newTextEntryFor: arg1 getText: arg2 setText: arg3 help: arg4  ^self newTextEntryFor: arg1 get: arg2 set: arg3 class: String getEnabled: nil help: arg4firstChild  ^self firstNodeMorphaddAllMorphs: arg1  ^self privateAddAllMorphs: arg1 atIndex: submorphs sizekeyStroke: arg1  (self scrollByKeyboard: arg1) ifTrue: [ ^self ].  scroller submorphs last keyStroke: arg1noteNewOwner: arg1  super noteNewOwner: arg1.  self updateLayoutInDockingBarselectIndexesUpTo: arg1  | tmp1 tmp2 |  tmp1 := self table selectedIndexes.  tmp2 := tmp1 ifNotEmpty: [ tmp1 first ] ifEmpty: [ arg1 ].  self selectIndexes: arg1 previous: (tmp1 union: (self table selectionModeStrategy indexesToSelectInMultipleSelectionFrom: tmp2 to: arg1))initialize  super initialize.  self     clipSubmorphs: true;     layoutPolicy: FTRowLayout newlaunchEditor: arg1  self editorProvider ifNil: [ ^self ].  self editorProvider openEditorForStringMorph: selffixStateForClickAndModifierIssue  self isMouseUp ifFalse: [ ^self ].  self yellowButtonChanged ifFalse: [ ^self ].  self anyModifierKeyPressed ifFalse: [ ^self ].  whichButton := MouseEvent redButtondoLayoutIn: arg1  | tmp1 tmp2 |  tmp2 := self outerBounds.  submorphs isEmpty ifTrue: [ ^fullBounds := tmp2 ].  submorphs do: [:arg2 |  arg2 ownerChanged ].  self layoutPolicy ifNotNil: [:arg3 |  arg3 layout: self in: (0 @ 0 extent: arg1 extent // self scale) ].  self adjustLayoutBounds.  fullBounds := self privateFullBounds.  tmp1 := self outerBounds.  tmp1 = tmp2 ifFalse: [ self invalidRect: (tmp2 quickMerge: tmp1) ]visible  extension ifNil: [ ^true ].  ^extension visiblenewListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 help: arg5  ^self newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: nil help: arg5targetPoint: arg1  | tmp1 tmp2 |  tmp2 := self target bounds withSideOrCorner: self edgeName setToPoint: arg1.  tmp1 := (self target layoutPolicy notNil and: [ self target layoutPolicy isTableLayout ]) ifTrue: [ self target layoutPolicy minExtentOf: self target in: self target layoutBounds ] ifFalse: [ self target minimumExtent ].  tmp2 width <= tmp1 x ifTrue: [ tmp2 := self edgeName = #left ifTrue: [ tmp2 withSideOrCorner: #left setToPoint: self target bounds bottomRight - tmp1 ] ifFalse: [ tmp2 withSideOrCorner: #right setToPoint: self target bounds topLeft + tmp1 ] ].  tmp2 height <= tmp1 y ifTrue: [ tmp2 := self edgeName = #top ifTrue: [ tmp2 withSideOrCorner: #top setToPoint: self target bounds bottomRight - tmp1 ] ifFalse: [ tmp2 withSideOrCorner: #bottom setToPoint: self target bounds topLeft + tmp1 ] ].  self setTargetBounds: tmp2createActionIconOn: arg1  ^Smalltalk ui icons iconNamed: #scriptManagerIconrowInset: arg1  rowInset := arg1balloonText  ^complexContents balloonText ifNil: [ super balloonText ]releaseMouseFocus  self newMouseFocus: nilhScrollbar  ^hScrollbarlistCentering: arg1  self assureTableProperties listCentering: arg1.  self layoutChangeddefaultLabel  ^'Color Selector' translatedwithExpandedChildren  ^{self} , self expandedChildrenselectedMorph  ^self listManager selectedMorphworldBounds  ^self world boundskeystrokeActionSelector: arg1  keystrokeActionSelector := arg1on: arg1 send: arg2 to: arg3  self eventHandler ifNil: [ self eventHandler: MorphicEventHandler new ].  self eventHandler on: arg1 send: arg2 to: arg3updateOffImage  self offImage: (target perform: offImageSelector)arguments: arg1  arguments := arg1myDependents  ^(self valueOfProperty: #myDependents) ifNil: [ #() ]distributeVertically  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self selectedItems size > 2 ifFalse: [ ^self ].  tmp1 := self selectedItems anyOne top.  tmp2 := self selectedItems anyOne bottom.  tmp3 := 0.  self selectedItems do: [:arg1 |  tmp1 := tmp1 min: arg1 top.        tmp2 := tmp2 max: arg1 bottom.        tmp3 := tmp3 + arg1 height ].  tmp4 := tmp1.  tmp5 := ((tmp2 - tmp1 - tmp3) / (self selectedItems size - 1)) rounded.  (self selectedItems asSortedCollection: [:arg2 :arg3 |  arg2 top <= arg3 top ]) do: [:arg1 |  arg1 top: tmp4.        tmp4 := tmp4 + arg1 height + tmp5 ].  self changedtext  ^textnewCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 label: arg4 help: arg5  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: nil label: arg4 help: arg5deselectAll  self listManager deselectAllmouseUp: arg1  arg1 hand mouseFocus == owner ifFalse: [ ^self ].  self contentString ifNotNil: [ self contents: self contentString withMarkers: true inverse: true.        self refreshWorld.        (Delay forMilliseconds: 200) wait ].  owner rootMenu selectItem: nil event: arg1.  self invokeWithEvent: arg1mouseEnterDragging: arg1  (arg1 hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: arg1 ].  (self wantsDroppedMorph: arg1 hand firstSubmorph event: arg1) ifTrue: [ self asPotentialDropTarget ]closeWindowAction  self closelabel: arg1  self label isEmpty ifTrue: [ arg1 isEmptyOrNil ifTrue: [ ^self ].        self removeAllMorphs.        self labelMorph contents: arg1.        self updateLayout.        self changed: #width ].  self labelMorph contents = arg1 ifFalse: [ self labelMorph contents: arg1.        arg1 isEmptyOrNil ifTrue: [ self removeMorph: self labelMorph ].        self changed: #width ].  self changed: #widthmouseDown: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlershighlightedRowIndexes  self deprecated: 'Use #highlightedIndexes instead' transformWith: '`@receiver highlightedRowIndexes' -> '`@receiver highlightedIndexes'.  ^self highlightedIndexesmidpoint  | tmp1 |  tmp1 := self totalLength.  tmp1 < 2 ifTrue: [ ^self center ].  tmp1 := tmp1 / 2.  self lineSegmentsDo: [:arg1 :arg2 |  | tmp2 |        tmp2 := arg1 distanceTo: arg2.        tmp1 < tmp2 ifTrue: [ ^(arg1 + ((arg2 - arg1) * (tmp1 / tmp2))) asIntegerPoint ].        tmp1 := tmp1 - tmp2 ].  self error: 'can''t happen'isRight  ^self option == #rightrootItemsOrig  ^rootClass allSubclasses asArray sort: [:arg1 :arg2 |  arg1 name < arg2 name ]borderColor  ^self theme borderColormouseDown: arg1  | tmp1 |  tmp1 := arg1 cursorPoint translateBy: bounds origin negated.  days do: [:arg2 |  arg2 highlighted: (arg2 bounds containsPoint: tmp1) ].  self changedhMorph: arg1  hMorph := arg1addHandle: arg1 on: arg2 send: arg3 to: arg4  | tmp1 tmp2 |  tmp2 := self positionIn: haloBox horizontalPlacement: arg1 horizontalPlacement verticalPlacement: arg1 verticalPlacement.  tmp1 := self addHandleAt: tmp2 color: (Color colorFrom: arg1 color) icon: arg1 iconSymbol on: arg2 send: arg3 to: arg4.  ^tmp1commandKeyHandler: arg1  self setProperty: #commandKeyHandler toValue: arg1selectionRects  selectionStart ifNil: [ ^Array new ].  ^self selectionRectsFrom: selectionStart to: selectionStopsetStrategy  table beRowSelectiontrackColorFrom: arg1  baseColor ifNil: [ self color: arg1 insetColor ]selectionBorderStyle  ^self theme menuItemSelectedBorderStyleFor: selfdefaultMultipleSelectionValue  ^falseiconFor: arg1  ^(self elementAt: arg1) actionOn: selfmin  ^(self sliderMorph ifNil: [ ^0 ]) minarcLengths  arcLengths ifNil: [ self calculateArcLengths ].  ^arcLengthscontentsWrapped: arg1  wrapFlag := true.  self newContents: arg1chooseExistingFileReference: arg1 extensions: arg2 path: arg3  ^self chooseExistingFileReference: arg1 extensions: arg2 path: arg3 preview: nilsetBalloonText: arg1  self setBalloonText: arg1 maxLineLength: self theme settings maxBalloonHelpLineLengthaddSubmorphsAfter: arg1 fromCollection: arg2 allowSorting: arg3  | tmp1 |  tmp1 := super addSubmorphsAfter: arg1 fromCollection: arg2 allowSorting: arg3.  self flag: #issue12027.  ^tmp1isVerticalScrollBarVisible  ^self verticalScrollBar owner isNotNildoubleClickSelector: arg1  doubleClickSelector := arg1innerBounds  ^self bounds insetBy: self borderWidthupdateVisualState: arg1  oldColor ifNotNil: [ self color: ((self containsPoint: arg1 cursorPoint) ifTrue: [ oldColor mixed: 0.5 with: Color white ] ifFalse: [ oldColor ]) ]computeCheckTopLeft  | tmp1 tmp2 |  tmp1 := self checkRectangle center.  tmp2 := (self checkWidth / 2.0) truncated.  ^(tmp1 x - tmp2) @ (tmp1 y - tmp2 - 1)toggleCornerRounding  self cornerStyle == #rounded ifTrue: [ self cornerStyle: #square ] ifFalse: [ self cornerStyle: #rounded ].  self changedareasRemainingToFill: arg1  self fillStyle isTranslucent ifTrue: [ ^Array with: arg1 ].  self wantsRoundedCorners ifTrue: [ (self borderWidth > 0 and: [ self borderColor isColor and: [ self borderColor isTranslucent ] ]) ifTrue: [ ^arg1 areasOutside: (self innerBounds intersect: self boundsWithinCorners) ] ifFalse: [ ^arg1 areasOutside: self boundsWithinCorners ] ] ifFalse: [ (self borderWidth > 0 and: [ self borderColor isColor and: [ self borderColor isTranslucent ] ]) ifTrue: [ ^arg1 areasOutside: self innerBounds ] ifFalse: [ ^arg1 areasOutside: self bounds ] ]selectColorAt: arg1  | tmp1 tmp2 |  tmp1 := self innerBounds.  tmp2 := (tmp1 containsPoint: arg1) ifTrue: [ arg1 ] ifFalse: [ tmp1 pointNearestTo: arg1 ].  tmp2 := (tmp2 - tmp1 topLeft) / tmp1 extent.  self selectedColor: (Color h: self color hue s: tmp2 x v: 1.0 - tmp2 y)basicIcon  | tmp1 |  ^(tmp1 := IconicButton new)     clipSubmorphs: true;     color: self pagerColor;     on: #mouseEnter send: #value to: [ tmp1 borderColor: self pagerColor muchDarker ];     on: #mouseLeave send: #value to: [ tmp1 borderColor: self pagerColor ];     target: self;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     listCentering: #leftCenter;     wrapCentering: #center;     layoutInset: 2 @ 0;     cellInset: 2 @ 0;     borderWidth: 1;     borderColor: self pagerColor;     yourselfinitializeExtension  extension := MorphExtension newmouseDown: arg1  self enabled ifFalse: [ ^self ].  allButtons := nil.  arg1 yellowButtonPressed ifTrue: [ ^self invokeMenu: arg1 ].  self wantsKeyboardFocusOnMouseDown ifTrue: [ self takeKeyboardFocus ].  triggerOnMouseDown ifTrue: [ self performAction: arg1 ] ifFalse: [ allButtons := owner submorphs select: [:arg2 |  arg2 class = self class ].        self updateFeedbackForEvt: arg1 ]expandFullBoundsForRolloverBorder: arg1  | tmp1 |  tmp1 := self valueOfProperty: #rolloverWidth ifAbsent: [ 10 @ 10 ].  ^arg1 expandBy: tmp1wouldAcceptKeyboardFocusUponTab  ^falseminExtent  ^100 @ 50 * self displayScaleFactornewAlphaImage: arg1 help: arg2  ^self theme newAlphaImageIn: self image: arg1 help: arg2initialize  balloonColor := self class balloonColor.  super initialize.  self beSmoothCurve.  offsetFromTarget := 0 @ 0handleEvent: arg1 from: arg2  | tmp1 tmp2 tmp3 |  tmp2 := arg1 timeStamp - firstClickTime > dblClickTime.  tmp1 := arg1 transformedBy: (clickClient transformedFrom: arg2 owner).  tmp3 := (tmp1 position - firstClickDown position) r > dragThreshold.  clickState == #firstClickDown ifTrue: [ (tmp2 and: [ tmp1 isMouseUp not ]) ifTrue: [ clickState := #firstClickTimedOut.              dragSelector ifNil: [ arg2 resetClickState.                    self                       doubleClickTimeout;                       click ].              ^true ].        tmp1 isMouseUp ifTrue: [ (tmp2 or: [ dblClickSelector isNil ]) ifTrue: [ self click.                    arg2 resetClickState.                    ^true ].              firstClickUp := arg1 copy.              clickState := #firstClickUp.              self click.              arg2 handleEvent: firstClickUp.              ^false ].        tmp3 ifTrue: [ self doubleClickTimeout.              arg2 resetClickState.              dragSelector ifNil: [ self click ] ifNotNil: [ self drag: firstClickDown ].              ^true ].        ^false ].  clickState == #firstClickTimedOut ifTrue: [ tmp1 isMouseUp ifTrue: [ arg2 resetClickState.              self                 doubleClickTimeout;                 click.              ^true ].        tmp3 ifTrue: [ arg2 resetClickState.              self                 doubleClickTimeout;                 drag: firstClickDown.              ^true ].        ^false ].  clickState == #firstClickUp ifTrue: [ tmp2 ifTrue: [ arg2 resetClickState.              self doubleClickTimeout.              ^true ].        tmp1 isMouseDown ifTrue: [ clickState := #secondClickDown.              ^false ] ].  clickState == #secondClickDown ifTrue: [ tmp2 ifTrue: [ arg2 resetClickState.              self doubleClickTimeout.              ^true ].        tmp3 ifTrue: [ self doubleClickTimeout.              arg2 resetClickState.              dragSelector ifNil: [ self click ] ifNotNil: [ self drag: firstClickDown ].              ^true ].        tmp1 isMouseUp ifTrue: [ arg2 resetClickState.              self doubleClick.              ^false ] ].  ^truecontainer: arg1  container := arg1color  ^colordispatchEvent: arg1 with: arg2  morph := arg2.  [ ^arg1 sentTo: self ] ensure: [ morph := nil ]wantsDroppedMorph: arg1 event: arg2  ^self model wantsDroppedMorph: arg1 event: arg2 inMorph: selfallRecipients  ^subscriptions collect: #recipientschanged  self table ifNil: [ ^self ].  self setNeedsRefreshExposedRows.  super changedcalcEnoughSegments  ^self enough: 4 withMeasure: (self measureFor: 2) withIn: self leewaykeyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self changedadoptPaneColor: arg1  rotationDegrees: arg1  initialize  super initialize.  cellSpacing := listSpacing := wrapDirection := #none.  cellPositioning := #center.  listCentering := wrapCentering := #topLeft.  listDirection := #topToBottom.  reverseTableCells := rubberBandCells := false.  layoutInset := cellInset := minCellSize := 0.  maxCellSize := 1073741823bottomRightCorner  ^self intersectionWithLineSegmentFromCenterTo: bounds bottomRightalert: arg1 title: arg2  ^self alert: arg1 title: arg2 configure: [:arg3 |   ]executeSortingOn: arg1  arg1 sortWith: self context ascendingSortFunctionkeystrokeSelector: arg1  keystrokeSelector := arg1buildButtonWithIconRight  ^(PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: nil) beIconRightcontents: arg1 withMarkers: arg2  ^self contents: arg1 withMarkers: arg2 inverse: falsecontentMorph: arg1  contentMorph := arg1display: arg1  self dataSource display: arg1defaultSliderFillStyle  ^(GradientFillStyle colors: {Color white .         Color black})     origin: self topLeft;     direction: (self bounds isWide ifTrue: [ self width @ 0 ] ifFalse: [ 0 @ self height ])children: arg1  children := arg1defaultBounds  ^0 @ 0 corner: 50 @ 40doubleClick: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlerswrapBlockOrSelector  ^wrapBlockOrSelector ifNil: [ wrapBlockOrSelector := #printString ]commandKeyPressed  ^buttons anyMask: 2r01000000shouldGetStepsFrom: arg1  (self isWorldMorph and: [ owner notNil ]) ifTrue: [ ^self outermostWorldMorph == arg1 ].  ^super shouldGetStepsFrom: arg1key  ^Smalltalk os keyForValue: keyValuesetLabelWidgetAllowance  ^labelWidgetAllowance := 0preferedPaneColor: arg1  self color: (preferedPaneColor := arg1)openOrClosePhrase  | tmp1 |  tmp1 := (self isCurve ifTrue: [ 'curve' ] ifFalse: [ 'polygon' ]) translated.  ^closed ifTrue: [ 'make open {1}' translated format: {tmp1} ] ifFalse: [ 'make closed {1}' translated format: {tmp1} ]roots  ^rootstype  ^#dropFilesEventchooseColor  ^self chooseColor: Color blackupdateProgressValue  color: arg1  (arg1 isColor or: [ arg1 isKindOf: InfiniteForm ]) ifFalse: [ ^self fillStyle: arg1 ].  color = arg1 ifFalse: [ self assureExtension.        extension fillStyle: nil.        color := arg1.        self changed ]getOldColor  ^oldColor ifNil: [ Color transparent ]getMenu: arg1  | tmp1 |  getMenuSelector ifNil: [ ^nil ].  tmp1 := self theme newMenuIn: self for: model.  getMenuSelector numArgs = 1 ifTrue: [ ^model perform: getMenuSelector with: tmp1 ].  getMenuSelector numArgs = 2 ifTrue: [ ^model perform: getMenuSelector with: tmp1 with: arg1 ].  ^self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'recursiveAddTo: arg1  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg2 |  arg2 recursiveAddTo: arg1 ] ].  arg1 add: selfextent: arg1  super extent: arg1.  self resizerChangedshiftSelectMorph: arg1  | tmp1 |  tmp1 := arg1 ifNil: [ self allNodeMorphs last ].  self emptySelection.  self searchedElement: nil.  self from: firstClickedMorph to: tmp1 do: [:arg2 |  self addToSelection: arg2 ].  self lastClickedMorph: tmp1.  ^tmp1 path collect: [:arg3 |  arg3 complexContents ]initialize  super initialize.  self hResizing: #spaceFill.  self vResizing: #spaceFill.  splitsTopAndBottom := false.  leftOrTop := OrderedCollection new.  rightOrBottom := OrderedCollection newarguments: arg1  arguments := arg1removeOnlyLastSelected: arg1  removeOnlyLastSelected := arg1sort: arg1  | tmp1 |  tmp1 := self nextState.  self context state: tmp1.  tmp1 executeSortingOn: arg1addMorphFront: arg1  ^self privateAddMorph: arg1 atIndex: 1balloonHelpEnabled  ^self theme settings balloonHelpEnableddefaultColor  ^self containingWindow ifNil: [ Color lightGreen ] ifNotNil: [:arg1 |  arg1 defaultBackgroundColor ]newStack  ^self theme newStackIn: self for: #()autoScrollView: arg1  | tmp1 |  tmp1 := arg1 transformedBy: (self transformedFrom: editView).  super mouseMove: tmp1.  editView scrollSelectionIntoView: tmp1collapseAll  self roots do: [:arg1 |  self collapseAll: arg1 ].  self adjustSubmorphPositionsgridFormOrigin: arg1 grid: arg2 background: arg3 line: arg4  | tmp1 tmp2 tmp3 |  tmp3 := arg1 \\ arg2.  tmp1 := arg2 asPoint x @ arg2 asPoint y.  tmp2 := Form extent: tmp1 depth: Display depth.  arg3 ifNotNil: [ tmp2 fillWithColor: arg3 ].  tmp3 x to: tmp2 width by: arg2 x do: [:arg5 |  tmp2 fill: (arg5 @ 0 extent: 1 @ tmp2 height) fillColor: arg4 ].  tmp3 y to: tmp2 height by: arg2 y do: [:arg6 |  tmp2 fill: (0 @ arg6 extent: tmp2 width @ 1) fillColor: arg4 ].  ^InfiniteForm with: tmp2toggleStayUp: arg1  self items do: [:arg2 |  arg2 isStayUpItem ifTrue: [ self stayUp: stayUp not.              stayUp ifTrue: [ arg2 contents: 'dismiss this menu' ] ifFalse: [ arg2 contents: 'keep this menu up' ] ] ].  arg1 hand releaseMouseFocus: self.  stayUp ifFalse: [ self topRendererOrSelf delete ]defaultColor  ^Color gray alpha: 0.15drawLinesToFirstChildOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  self firstChild hasToggle ifTrue: [ ^self ].  tmp4 := self firstChild toggleRectangle.  tmp5 := tmp4 center.  tmp1 := tmp5 x.  tmp2 := bounds bottom.  tmp7 := container treeLineWidth // 2.  self firstChild hasToggle ifTrue: [ tmp3 := tmp5 y - (tmp4 height // 2) + tmp7 ] ifFalse: [ tmp3 := tmp5 y - 2 ].  tmp6 := self theme.  arg1 frameRectangle: ((tmp1 - tmp7) @ tmp2 corner: (tmp1 + tmp7 + (container treeLineWidth \\ 2)) @ tmp3) width: container treeLineWidth colors: (tmp6 treeLineColorsFrom: self lineColor) dashes: self treeLineDashesfontSized: arg1  ^LogicalFont familyName: self defaultFontFamiliyName pointSize: arg1isKeyboard  ^falseboundsForBalloon  ^self boundsInWorldicon  | tmp1 |  tmp1 := super icon.  tmp1 ifNil: [ ^tmp1 ].  ^self isPressed ifTrue: [ (tmp1 asFormOfDepth: 32) dimmed ] ifFalse: [ tmp1 ]extent: arg1  super extent: arg1.  self updateGradientsdefaultBorderColor  ^Color r: 0.861 g: 1.0 b: 0.722itemMorphGetter: arg1  rowMorphGetSelector := arg1 isSymbol ifTrue: [ [:arg2 |  arg2 complexContents item perform: arg1 ] ] ifFalse: [ [:arg2 |  arg1 value: arg2 complexContents item ] ]removeMenuBox  menuBox ifNotNil: [ menuBox delete.        menuBox := nil ]icon  | tmp1 |  self getStateSelector ifNil: [ ^super icon ].  tmp1 := (MessageSend receiver: self target selector: self getStateSelector) valueWithEnoughArguments: self arguments.  self flag: #pharoFixMe.  (tmp1 isKindOf: Association) ifTrue: [ ^tmp1 key ifTrue: [ self onImage ] ifFalse: [ self offImage ] ] ifFalse: [ (tmp1 = true or: [ tmp1 isString and: [ (tmp1 beginsWith: '<yes>') or: [ tmp1 beginsWith: '<on>' ] ] ]) ifTrue: [ ^self onImage ].        (tmp1 = false or: [ tmp1 isString and: [ (tmp1 beginsWith: '<no>') or: [ tmp1 beginsWith: '<off>' ] ] ]) ifTrue: [ ^self offImage ] ].  ^super iconendAt: arg1  end := arg1lastPage  | tmp1 |  tmp1 := (self nodeList size / pageSize) asInteger.  self nodeList size \\ pageSize > 0 ifTrue: [ tmp1 := tmp1 + 1 ].  ^tmp1brightness  ^(self selectedColor brightness * 255) asIntegerfindReplaceSelectionRegex: arg1  findReplaceSelectionRegex := arg1model: arg1  super model: arg1.  self title: self titleupdateHandles  | tmp1 |  self isCurvy ifTrue: [ handles first center: vertices first.        handles last center: vertices last.        self midVertices withIndexDo: [:arg1 :arg2 |  (closed or: [ arg2 < vertices size ]) ifTrue: [ tmp1 := handles atWrap: arg2 * 2.                    tmp1 position: arg1 - (tmp1 extent // 2) ] ] ] ifFalse: [ vertices withIndexDo: [:arg3 :arg2 |  | tmp2 |              tmp2 := handles at: arg2 * 2 - 1.              tmp2 position: arg3 - (tmp2 extent // 2).              (closed or: [ arg2 < vertices size ]) ifTrue: [ tmp1 := handles at: arg2 * 2.                    tmp1 position: (arg3 + (vertices atWrap: arg2 + 1) - tmp1 extent) // 2 + (1 @ -1) ] ] ]rowAtLocation: arg1  | tmp1 |  tmp1 := arg1 y.  tmp1 < self top ifTrue: [ ^1 ].  listItems with: (1 to: listItems size) do: [:arg2 :arg3 |  tmp1 < arg2 bottom ifTrue: [ ^arg3 ] ].  ^listItems sizemorph: arg1  morph := arg1.  self triggerEvent: #tabRefreshed with: selfwantsWindowEvent: arg1  ^self windowEventHandler notNilclassOrMetaClass: arg1  keyStroke: arg1  (self scrollByKeyboard: arg1) ifTrue: [ ^self ].  self scrollTarget keyStroke: arg1basicKeyStroke: arg1  | tmp1 |  arg1 keyValue = 13 ifTrue: [ tmp1 := self crAction.        tmp1 ifNotNil: [ arg1 hand newKeyboardFocus: nil.              ^tmp1 value ] ].  self handleInteraction: [ editor keystroke: arg1 ].  self updateFromParagraph.  super keyStroke: arg1newStateForSelected: arg1  ^selfnextSibling: arg1  nextSibling := arg1defaultMorphIn: arg1  | tmp1 tmp2 |  tmp1 := self defaultTreeMorph buildContents.  tmp2 := patternModel newTextField     hResizing: #spaceFill;     autoAccept: autoAccept;     withGhostText: ghostString;     textFont: StandardFonts defaultFont;     yourself.  tmp2 ghostTextRuler font: StandardFonts defaultFont.  tmp2 announcer when: RubReturnEntered send: #whenReturnInFilter: to: self.  ^self theme newColumnIn: arg1 for: {tmp2 .         tmp1}keyStroke: arg1  (self navigationKey: arg1) ifTrue: [ ^true ].  (self scrollByKeyboard: arg1) ifTrue: [ ^true ].  ^self listManager keyStroke: arg1doubleClick  self browseItemmenu: arg1 shifted: arg2  arg1 add: 'Expand all' target: self selector: #expandAll.  arg1 add: 'Browse (b)' target: self selector: #browseItem.  arg1 add: 'Inspect (i)' target: self selector: #inspectItem.  arg1 add: 'Explore (I)' target: self selector: #exploreIteminitialize  super initialize.  self     initializeTasks;     initializeLayout;     initializeAppearance;     addMorphs;     updateButtonsAndPreview;     adoptPaneColor: self colorlayoutProportionallyIn: arg1  self layoutFrame ifNil: [ ^self ].  self isAutoFit ifTrue: [ self fullBounds ].  ^super layoutProportionallyIn: arg1isTaskbar  ^trueinsertionPointColor  self focused ifFalse: [ ^Color transparent ].  ^Display depth <= 2 ifTrue: [ Color black ] ifFalse: [ self class insertionPointColor ]outermostWorldMorph  ^self world ifNil: [ self currentWorld ]takesKeyboardFocus  ^truefirstClickedMorph  ^firstClickedMorphnotify: arg1 at: arg2 in: arg3  ^self editor notify: arg1 at: arg2 in: arg3keyStroke: arg1  (self navigationKey: arg1) ifTrue: [ ^self ].  arg1 keyCharacter = Character arrowLeft ifTrue: [ self selectPreviousTab ].  arg1 keyCharacter = Character arrowRight ifTrue: [ self selectNextTab ]isSelectedMatchingTheState: arg1  ^self subclassResponsibilityminWidth  ^10 * self displayScaleFactorstoreOn: arg1  arg1 nextPutAll: type.  arg1 space.  self timeStamp storeOn: arg1.  arg1 space.  position x storeOn: arg1.  arg1 space.  position y storeOn: arg1.  arg1 space.  buttons storeOn: arg1newLabel: arg1  ^self newLabel font: arg1moveUp: arg1  ^self moveSelectionDown: -1 event: arg1hUpdateScrollbar  self hScrollbarNeeded ifTrue: [ self           hShowScrollbar;           hResizeScrollbar ] ifFalse: [ self hHideScrollbar ]clipLayoutCells: arg1  arg1 == false ifTrue: [ self removeProperty: #clipLayoutCells ] ifFalse: [ self setProperty: #clipLayoutCells toValue: arg1 ].  self changedcellSpacing: arg1  self assureTableProperties cellSpacing: arg1.  self layoutChangedtable  ^tableclient: arg1  client := arg1testIsBellowRow  self subclassResponsibilitynewTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4  ^self newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: nilhash  ^buttons hash + keyValue hashaddAlarm: arg1 withArguments: arg2 after: arg3  ^self addAlarm: arg1 withArguments: arg2 at: Time millisecondClockValue + arg3adjustSubmorphPositions  maxNodeWidth := 0.  ^self adjustSubmorphPositionsOf: self allNodeMorphs startIdx: 1 startPos: 0 @ 0resizable: arg1  resizable := arg1age: arg1  self item age: arg1.  self changed: #agemouseTrailFrom: arg1  | tmp1 tmp2 |  tmp2 := (Array new: 1) writeStream.  tmp2 nextPut: arg1 third @ arg1 fourth.  [ (tmp1 := Sensor peekEvent) isNil ] whileFalse: [ tmp1 first = arg1 first ifFalse: [ ^tmp2 contents ].        tmp1 fifth = arg1 fifth ifFalse: [ ^tmp2 contents ].        tmp1 sixth = arg1 sixth ifFalse: [ ^tmp2 contents ].        tmp1 := Sensor nextEvent.        tmp1 ifNotNil: [ tmp2 nextPut: tmp1 third @ tmp1 fourth ] ].  ^tmp2 contentsinterrupted  self releaseAllFocustab  ^tabdrawBorderOn: arg1 usingEnds: arg2  | tmp1 tmp2 |  borderDashSpec ifNotNil: [ ^self drawDashedBorderOn: arg1 usingEnds: arg2 ].  tmp2 := self borderStyle.  tmp1 := arg1 clipRect expandBy: (self borderWidth + 1) // 2.  self lineSegmentsDo: [:arg3 :arg4 |  | tmp3 tmp4 |        tmp3 := arg3 asIntegerPoint.        tmp4 := arg4 asIntegerPoint.        self hasArrows ifTrue: [ ((arrows == #back or: [ arrows == #both ]) and: [ arg3 = vertices first ]) ifTrue: [ tmp3 := arg2 first asIntegerPoint ].              ((arrows == #forward or: [ arrows == #both ]) and: [ arg4 = vertices last ]) ifTrue: [ tmp4 := arg2 last asIntegerPoint ] ].        (closed or: [ ((tmp3 min: tmp4) max: tmp1 origin) <= ((tmp3 max: tmp4) min: tmp1 corner) ]) ifTrue: [ tmp2 drawLineFrom: tmp3 to: tmp4 on: arg1 ] ]nextVisibleWindow  ^self visibleSystemWindows ifEmpty: [ nil ] ifNotEmpty: [:arg1 |  arg1 after: self currentWindow ifAbsent: [ arg1 first ] ]depth  ^depth ifNil: [ depth := 0 ]layoutBounds: arg1  super layoutBounds: arg1.  self updateGradientskeyStroke: arg1  (arg1 anyModifierKeyPressed or: [ arg1 keyCharacter isAlphaNumeric not ]) ifTrue: [ ^false ].  currentSelIndex := self table selectedIndex.  currentHighlightedIndexes := self table highlightedIndexes.  self showSearchFieldFromKeystrokeEvent: arg1.  ^truemenu  | tmp1 |  tmp1 := MenuMorph new defaultTarget: self.  menu ifNotNil: [ menu cull: tmp1 ].  self addRefreshMenuItemOn: tmp1.  ^tmp1wrapSelector: arg1  self basicWrapSelector: arg1.  self updateListaddNodePath: arg1  ^self subclassResponsibilityprintOn: arg1  super printOn: arg1.  arg1 nextPutAll: ' ( '.  arg1     print: self leftFraction @ self topFraction;     nextPutAll: ' + ';     print: self leftOffset @ self topOffset;     nextPutAll: 'px corner: ';     print: self rightFraction @ self bottomFraction;     nextPutAll: ' + ';     print: self rightOffset @ self bottomOffset;     nextPutAll: 'px ) 'stepTime  ^model ifNotNil: [ model stepTimeIn: self ] ifNil: [ 200 ]recomposeFrom: arg1 to: arg2 delta: arg3  | tmp1 tmp2 |  tmp1 := (self lineIndexForCharacter: arg1) - 1 max: 1.  [ tmp1 > 1 and: [ (lines at: tmp1 - 1) top = (lines at: tmp1) top ] ] whileTrue: [ tmp1 := tmp1 - 1 ].  tmp2 := OrderedCollection new: lines size + 1.  1 to: tmp1 - 1 do: [:arg4 |  tmp2 addLast: (lines at: arg4) ].  text string isOctetString ifTrue: [ ^self composeLinesFrom: (lines at: tmp1) first to: arg2 delta: arg3 into: tmp2 priorLines: lines atY: (lines at: tmp1) top ].  self multiComposeLinesFrom: (lines at: tmp1) first to: arg2 delta: arg3 into: tmp2 priorLines: lines atY: (lines at: tmp1) topinitialize  super initialize.  self     extent: 180 @ 168;     changeTableLayout;     cellInset: 4;     aMorph: self newAColorMorph;     hsvMorph: self newHSVColorMorph;     addMorphBack: self hsvMorph;     addMorphBack: self aMorph.  self aMorph color: self hsvMorph selectedColormorphPreceding: arg1  | tmp1 |  tmp1 := submorphs indexOf: arg1 ifAbsent: [ ^nil ].  ^tmp1 > 1 ifTrue: [ submorphs at: tmp1 - 1 ] ifFalse: [ nil ]updateItemsWithTarget: arg1 orWithHand: arg2  self items do: [:arg3 |  arg3 target ifNotNil: [ arg3 target isHandMorph ifTrue: [ arg3 target: arg2 ] ifFalse: [ arg3 target: arg1 ] ] ]initialize  super initialize.  self     listDirection: #leftToRight;     vResizing: #shrinkWrap;     wrapCentering: #topLeft;     cellPositioning: #center;     cellSpacing: #none;     layoutInset: 2;     clipSubmorphs: truemodel: arg1  super model: arg1.  self paneColorTracksModel ifTrue: [ self           setProperty: #paneColor toValue: self defaultBackgroundColor;           fillStyle: self fillStyleToUse;           setStripeColorsFrom: self paneColorToUse.        self theme fadedBackgroundWindows ifFalse: [ self adoptPaneColor: self paneColor ] ].  self minimumExtent: ((arg1 respondsTo: #minimumExtent) ifTrue: [ arg1 minimumExtent ]).  menuBox ifNotNil: [ menuBox           labelGraphic: (self theme windowMenuIconFor: self);           height: self boxExtent y ]rootNodeClassFromItem: arg1  ^ClassListNodeExampleupImage  ^self class arrowOfDirection: (bounds isWide ifTrue: [ #left ] ifFalse: [ #top ]) size: (self buttonExtent x min: self buttonExtent y) color: self buttonImageColoracquireWidth: arg1  ^self widthOrUndefined min: arg1addMorphFrontFromWorldPosition: arg1  ^self addMorphFront: arg1 fromWorldPosition: arg1 positionInWorldaddRightOrBottom: arg1  rightOrBottom add: arg1newCancelButtonFor: arg1  ^self theme newCancelButtonIn: self for: arg1cellColumn: arg1 row: arg2  ^FTCellMorph new     cellInset: 5;     addMorphBack: (self iconFor: arg2) asMorph;     addMorphBack: (Morph new           changeTableLayout;           hResizing: #shrinkWrap;           listDirection: #topToBottom;           color: Color transparent;           addMorphBack: ((self elementAt: arg2) protocol asMorph emphasis: 2r10);           addMorphBack: (self elementAt: arg2) name asMorph;           yourself);     yourselfgtInspectorMorphIn: arg1  < gtInspectorPresentationOrder: 90>  | tmp1 |  tmp1 := arg1 morph.  tmp1     title: 'Morph';     display: [ [ self imageForm asMorph on: #mouseDown send: #value: to: [:arg2 |  tmp1 selection: (self morphsAt: arg2 position) ] ] on: Error do: [ IconicListItem text: 'Error drawing Morph' icon: (self iconNamed: #smallWarningIcon) ] ];     act: [:arg3 |  self exportAsPNG ] entitled: 'Export as PNG';     act: [:arg3 |  self delete ] entitled: 'Delete'drawTabOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := self cornerRadius.  tmp5 := self bounds.  self active ifTrue: [ tmp1 := tmp5 top.        tmp2 := self color ] ifFalse: [ tmp1 := tmp5 top + self topInactiveGap.        tmp2 := self color whiter whiter ].  arg1 fillRectangle: ((tmp5 left + tmp3) @ (tmp1 + tmp3) corner: (tmp5 right - tmp3) @ self bottom) color: tmp2.  arg1 fillRectangle: ((tmp5 left + (tmp3 * 2)) @ tmp1 corner: (tmp5 right - (tmp3 * 2)) @ (tmp1 + tmp3)) color: tmp2.  arg1 fillOval: ((tmp5 left + self cornerRadius) @ tmp1 corner: (tmp5 left + (self cornerRadius * 3)) @ (tmp1 + (self cornerRadius * 2))) color: tmp2.  arg1 fillOval: ((tmp5 right - (self cornerRadius * 3)) @ tmp1 corner: (tmp5 right - self cornerRadius) @ (tmp1 + (self cornerRadius * 2))) color: tmp2.  tmp4 := self arcLengths.  1 to: tmp4 size do: [:arg2 |  | tmp6 |        tmp6 := tmp4 at: arg2.        arg1 line: (tmp5 left + tmp3 - arg2) @ (tmp5 bottom - 1) to: (tmp5 left + tmp3 - arg2) @ (tmp5 bottom - tmp6 - 1) color: tmp2.        arg1 line: (tmp5 right - tmp3 + arg2 - 1) @ (tmp5 bottom - 1) to: (tmp5 right - tmp3 + arg2 - 1) @ (tmp5 bottom - tmp6 - 1) color: tmp2 ]isMouseWheel  ^trueminWidth  | tmp1 tmp2 tmp3 |  tmp1 := self hasSubMenu ifTrue: [ 10 ] ifFalse: [ 0 ].  tmp2 := self hasIcon ifTrue: [ self icon width + 2 ] ifFalse: [ 0 ].  tmp3 := self hasMarker ifTrue: [ self submorphBounds width + 8 ] ifFalse: [ 0 ].  ^(self fontToUse widthOfString: contents) + tmp1 + tmp2 + tmp3 + 10activateCursor: arg1  arg1 beCursortestIsBellowRow  self assert: (strategy is: 3 bellowRow: 2).  self deny: (strategy is: 3 bellowRow: 4).  self deny: (strategy is: 3 bellowRow: 3)openFindDialog  self flashenableDragNDrop  self enableDragNDrop: truevScrollbarShowing  ^self vScrollbar owner notNilactiveLabelFillStyle  ^self theme windowActiveLabelFillStyleFor: selfalpha: arg1  | tmp1 |  tmp1 := self selectedColor.  self selectedColor: (tmp1 alpha: arg1 / 255)rectanglesAt: arg1 height: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  tmp6 := Array with: arg1 with: arg2.  tmp2 := rectangleCache at: tmp6 ifAbsent: [ nil ].  tmp2 ifNotNil: [ ^tmp2 ].  tmp7 := minWidth + (2 * OuterMargin).  self shadowForm.  tmp8 := 0 @ (arg1 - shadowForm offset y) extent: shadowForm width @ arg2.  tmp9 := shadowForm copy: tmp8.  tmp9 tallyPixelValues second = tmp8 area ifTrue: [ tmp2 := Array with: (shadowForm offset x @ arg1 extent: tmp8 extent) ] ifFalse: [ tmp1 := tmp9 xTallyPixelValue: 1 orNot: false.        tmp2 := OrderedCollection new.        tmp3 := 0.        tmp4 := 0.        1 to: tmp1 size do: [:arg3 |  tmp5 := tmp1 at: arg3.              tmp5 >= arg2 ifTrue: [ tmp3 := tmp3 + 1 ] ifFalse: [ tmp3 >= tmp7 ifTrue: [ tmp2 addLast: ((tmp4 + shadowForm offset x) @ arg1 extent: tmp3 @ arg2) ].                    tmp3 := 0.                    tmp4 := arg3 ] ].        tmp3 >= tmp7 ifTrue: [ tmp2 addLast: ((tmp4 + shadowForm offset x) @ arg1 extent: tmp3 @ arg2) ] ].  tmp2 := tmp2 collect: [:arg4 |  arg4 insetBy: OuterMargin @ 0 ].  rectangleCache at: tmp6 put: tmp2.  ^tmp2imageFormForRectangle: arg1  ^self imageForm: Display depth forRectangle: arg1initializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigationoffset: arg1  transform := transform withOffset: arg1 - self innerBounds topLeft.  self changedstartAt: arg1  startValue := arg1update: arg1  arg1 ifNil: [ ^self ].  arg1 == getRootsSelector ifTrue: [ self roots: (model perform: getRootsSelector) ].  arg1 == getSelectedPathSelector ifTrue: [ ^self selectPath: (model perform: getSelectedPathSelector) in: (scroller submorphs at: 1 ifAbsent: [ ^self ]) ].  ^super update: arg1drawOn: arg1  arg1     fillRectangle: self bounds fillStyle: self backgroundColor;     drawString: self contents in: self stringBounds font: self fontToUse color: self stringColor underline: (emphasis bitAnd: 2r100) ~~ 0 underlineColor: self underlineColor strikethrough: (emphasis bitAnd: 2r10000) ~~ 0 strikethroughColor: self strikethroughColorrootNodeClassFromItem: arg1  ^SimpleGridNodeExampleframeRectangle: arg1 on: arg2  | tmp1 |  tmp1 := arg1.  self borders do: [:arg3 |  arg3 frameRectangle: tmp1 on: arg2.        tmp1 := tmp1 insetBy: arg3 width ]mouseEnter: arg1  self isCursorOverHandle ifTrue: [ self setInverseColors.        self shouldInvalidateOnMouseTransition ifTrue: [ self changed ].        arg1 hand showTemporaryCursor: self resizeCursor ]repressedImage  ^repressedImagerotationDegrees: arg1  setLabel  | tmp1 |  tmp1 := UIManager default request: 'Please enter a new label for this button' translated initialAnswer: self label.  tmp1 isEmptyOrNil ifFalse: [ self labelString: tmp1 ]doubleClickSelector  ^doubleClickSelectornewMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil useIndex: true help: arg5drawOnAthensCanvas: arg1  self perform: #drawOnAthensCanvas: withArguments: {arg1} inSuperclass: Morph.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOnAthensCanvas: arg1 ]indexForRow: arg1  ^arg1dragItemSelector: arg1  dragItemSelector := arg1.  arg1 ifNotNil: [ self dragEnabled: true ]asMouseEnter  ^self shallowCopy setType: #mouseEnterstartDrag: arg1  | tmp1 |  self dragEnabled ifFalse: [ ^self ].  arg1 hand hasSubmorphs ifTrue: [ ^self ].  oldColor ifNotNil: [ self fillStyle: oldColor.        oldColor := nil ].  tmp1 := self model transferFor: self model from: self.  tmp1 align: tmp1 draggedMorph center with: arg1 position.  arg1 hand grabMorph: tmp1.  arg1 hand releaseMouseFocus: selficonFor: arg1  | tmp1 |  tmp1 := self elementAt: arg1.  ((tmp1 includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ tmp1 isAbstract not ]) ifTrue: [ tmp1 hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        tmp1 hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        tmp1 hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  tmp1 organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ((tmp1 includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ tmp1 isAbstract not ]) ifTrue: [ tmp1 hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        tmp1 hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        tmp1 hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  tmp1 organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ^tmp1 systemIconsmoothingOff  smoothing := 1.  self changedaddToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4  self addToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 argumentList: EmptyArraybrickImageForm: arg1  | tmp1 tmp2 tmp3 |  self isBrick ifFalse: [ ^self imageForm ].  tmp3 := self border.  self border: GLMBrickBorder new.  tmp1 := self color.  self color: arg1.  tmp2 := self imageForm.  self color: tmp1.  self border: tmp3.  ^tmp2newColorChooserFor: arg1 getColor: arg2 setColor: arg3 getEnabled: arg4 help: arg5  ^self theme newColorChooserIn: self for: arg1 getColor: arg2 setColor: arg3 getEnabled: arg4 help: arg5isDeActivated  ^falselongMessage: arg1 title: arg2  ^self theme longMessageIn: self text: arg1 title: arg2vExtraScrollRange  ^8hasChildrenSelector: arg1  hasChildrenSelector := arg1wantsToBeCachedByHand  self isTranslucentButNotTransparent ifTrue: [ ^false ].  self clipSubmorphs ifTrue: [ ^true ].  self bounds = self fullBounds ifTrue: [ ^true ].  self submorphsDo: [:arg1 |  (self bounds containsRect: arg1 fullBounds) ifFalse: [ arg1 wantsToBeCachedByHand ifFalse: [ ^false ] ] ].  ^truesubmorphsBehind: arg1 do: arg2  | tmp1 |  tmp1 := false.  submorphs do: [:arg3 |  arg3 == arg1 ifTrue: [ tmp1 := true ] ifFalse: [ tmp1 ifTrue: [ arg2 value: arg3 ] ] ]mouseDownRow: arg1  self listMorph mouseDownRow: arg1mouseUp: arg1  | tmp1 |  tmp1 := arg1 cursorPoint.  submorphs do: [:arg2 |  (arg2 containsPoint: tmp1) ifTrue: [ arg2 mouseUp: arg1 ] ]mouseOverBorderStyle  ^self theme scrollbarMouseOverBorderStyleFor: selftransformFromWorld  ^self transformFrom: nillabelFont  ^self fontSized: self pointSizedefaultLimit  ^5newNoButton  ^self newNoButtonFor: selfgetTextSelector: arg1  getTextSelector := arg1.  self updateTextalignCentersHorizontally  | tmp1 tmp2 |  selectedItems size > 1 ifFalse: [ ^self ].  tmp1 := (selectedItems collect: [:arg1 |  arg1 left ]) min.  tmp2 := selectedItems detect: [:arg2 |  arg2 left = tmp1 ].  selectedItems do: [:arg1 |  arg1 center: arg1 center x @ tmp2 center y ].  self changedlistSelectionAt: arg1  arg1 isZero ifFalse: [ lastNonZeroIndex := arg1 ].  getSelectionListSelector ifNil: [ ^false ].  ^model perform: getSelectionListSelector with: arg1setDismissColor: arg1 with: arg2  | tmp1 |  arg1 hand obtainHalo: self.  tmp1 := (arg2 containsPoint: arg1 cursorPoint) ifFalse: [ Color red muchLighter ] ifTrue: [ Color lightGray ].  self setColor: tmp1 toHandle: arg2selectedRowIndexes  self deprecated: 'Use #selectedIndexes instead' transformWith: '`@receiver selectedRowIndexes' -> '`@receiver selectedIndexes'.  ^self selectedIndexeshandleFocusEvent: arg1  (arg1 isMouse and: [ arg1 isMouseUp ]) ifTrue: [ ^self mouseUp: arg1 ].  self processEvent: arg1.  arg1 isKeyboard ifTrue: [ ^self handleEvent: arg1 ].  (arg1 isMouseOver or: [ arg1 isMouse not ]) ifTrue: [ ^self ].  arg1 isMove ifFalse: [ ^self handleEvent: arg1 ].  selectedItem ifNotNil: [ (selectedItem activateSubmenu: arg1) ifTrue: [ ^self ] ]bottom  ^(self vertProfile findLast: [:arg1 |  arg1 >= minWidth ]) + shadowForm offset ysliderMorph  ^sliderMorphaction: arg1  action := arg1updateBalloonText  target ifNotNil: [ self balloonText: (target perform: balloonTextSelector) ]update: arg1  arg1 == self getEnabledSelector ifTrue: [ self updateEnabled.        ^self ].  arg1 == self getTextSelector ifTrue: [ self updateText.        ^self ]colorForInsets  self owner isSystemWindow ifTrue: [ ^self owner colorForInsets ].  ^super colorForInsetsremoveColumnAtIndex: arg1  self columns removeAt: arg1.  self columnsChanged.  self updateListseparatorColor  ^separatorColor ifNil: [ separatorColor := Color gray ]long  ^50margin: arg1  margin := arg1handlesMouseOver: arg1  ^falsetaskbarButtonLeft: arg1 event: arg2 in: arg3  self valueOfProperty: #taskbarThumbnail ifPresentDo: [:arg4 |  arg4 delete.        self removeProperty: #taskbarThumbnail ]searchedElement: arg1  self highlightIndex: arg1selectedPressedFillStyle  ^self theme controlButtonSelectedPressedFillStyleFor: selfmouseEnter: arg1  hasFocus := truedisable  self enabled: falsegetMenuSelector  ^getMenuSelectordoMenu: arg1 with: arg2  | tmp1 |  self obtainHaloForEvent: arg1 andRemoveAllHandlesBut: nil.  target world displayWorld.  tmp1 := innerTarget buildHandleMenu: arg1 hand.  innerTarget addTitleForHaloMenu: tmp1.  tmp1 popUpEvent: arg1 in: target worlddefaultMorphIn: arg1  ^self defaultTreeMorphtestInitialize  TextMorph initializemouseDownRow: arg1  arg1 = self mouseDownRow ifTrue: [ ^self ].  self mouseDownRowFrameChanged.  self setProperty: #mouseDownRow toValue: arg1.  self mouseDownRowFrameChangedmodalSelection: arg1  self setProperty: #modalSelection toValue: arg1.  self isModalInvokationDone: trueisWindowEvent  ^falseisRowIndexVisible: arg1  self exposedRows ifNil: [ ^false ].  ^self exposedRows includesKey: arg1selectedMouseOverBorderStyle  ^self theme controlButtonSelectedMouseOverBorderStyleFor: selfexpandAllSilently: arg1  arg1 isExpanded ifFalse: [ arg1 expand ].  arg1 childrenDo: [:arg2 |  self expandAllSilently: arg2 ]contents: arg1 wrappedTo: arg2  self newContents: ''.  wrapFlag := true.  super extent: arg2 truncated @ self height.  self newContents: arg1selectRowIndexes: arg1 andMakeVisibleIf: arg2  self deprecated: 'Use #selectIndexes:andMakeVisibleIf: instead' transformWith: '`@receiver selectRowIndexes: `@statements1 andMakeVisibleIf: `@statements2' -> '`@receiver selectIndexes: `@statements1 andMakeVisibleIf: `@statements2'.  self selectIndexes: arg1 andMakeVisibleIf: arg2drawArrowsOnAthensCanvas: arg1  | tmp1 |  self hasArrows ifFalse: [ ^#() ].  tmp1 := Array with: vertices first with: vertices last.  borderColor isColor ifFalse: [ ^tmp1 ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ tmp1 at: 2 put: (self drawArrowOnAthensCanvas: arg1 at: vertices last from: self nextToLastPoint) ].  (arrows == #back or: [ arrows == #both ]) ifTrue: [ tmp1 at: 1 put: (self drawArrowOnAthensCanvas: arg1 at: vertices first from: self nextToFirstPoint) ].  ^tmp1deliverTo: arg1  ^arg1 update: selector with: argumentsaction: arg1  actionSelector := arg1newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 icon: arg5 getEnabled: arg6 help: arg7  ^self theme newListIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4 icon: arg5 getEnabled: arg6 help: arg7drawSubMenuMarker: arg1 on: arg2 in: arg3  | tmp1 |  tmp1 := arg3 topRight + ((arg1 width * self displayScaleFactor) negated @ ((arg3 height - (arg1 height * self displayScaleFactor)) // 2)) extent: arg1 extent * self displayScaleFactor.  self drawIcon: arg1 scaledByDisplayScaleFactor on: arg2 in: tmp1removeColumnResizers  self removeAllMorphsIn: self columnResizers.  self columnResizers do: [:arg1 |  arg1 release ].  self columnResizers removeAllselectNodePath: arg1  self selection: (MorphTreeMorphSingleSelection new selectedNodePath: arg1)normalFillStyle  ^self theme morphTreeSplitterNormalFillStyleFor: selffocusBounds  ^self theme listFocusBoundsFor: selfkeyStroke: arg1  self isExplicit ifTrue: [ ^false ].  (arg1 keyCharacter = Character escape and: [ initialDataSource isNotNil ]) ifTrue: [ ^self reinitializeTable ].  (arg1 anyModifierKeyPressed or: [ arg1 keyCharacter isAlphaNumeric not ]) ifTrue: [ ^false ].  self showFilterFieldFromKeystrokeEvent: arg1.  ^truestepTime  ^10startScale: arg1 with: arg2  self obtainHaloForEvent: arg1 andRemoveAllHandlesBut: arg2.  target prepareForScaling.  growingOrRotating := true.  positionOffset := 0 @ 0.  originalExtent := target extentlistForSearching  ^getListSelector ifNotNil: [ self getList ] ifNil: [ getListElementSelector ifNil: [ #() ] ifNotNil: [ (1 to: self getListSize) collect: [:arg1 |  self getListItem: arg1 ] ] ]nameMenuColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := (self elementAt: arg2) method.  tmp2 := UIManager default newMenuIn: self table for: self.  tmp2 add: 'Browse ' , tmp1 methodClass name , '>>#' , tmp1 selector target: tmp1 selector: #browse.  tmp2 add: 'Inspect #' , tmp1 methodClass name , '>>#' , tmp1 selector target: tmp1 selector: #inspect.  ^tmp2newPluggableDialogWindow  ^self newPluggableDialogWindow: 'Dialog'actualClass  ^FTSortFunctionColumnSortingStrategyasMouseMove  ^MouseMoveEvent basicNew setType: #mouseMove startPoint: position endPoint: position trail: {position .         position} buttons: buttons hand: source stamp: self timeStampnormalColor  ^self theme buttonColorFor: selficonForm  ^isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ]selectedDisabledBorderStyle  ^self theme taskbarItemSelectedDisabledBorderStyleFor: selfkeyStroke: arg1 from: arg2  self selectedNode ifNotNil: [:arg3 |  arg3 keyStroke: arg1 from: arg2 ]invokeWorldMenu: arg1  | tmp1 |  self class shouldShowWorldMenu ifFalse: [ ^self ].  self bringTopmostsToFront.  (tmp1 := self worldMenu) popUpEvent: arg1 in: self.  ^tmp1column: arg1  column := arg1focusBounds  ^(self bounds width < 6 or: [ self bounds height < 6 ]) ifTrue: [ super focusBounds ] ifFalse: [ super focusBounds insetBy: (2 @ 2 corner: 2 @ 0) ]arrowLength: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := vertices second - vertices first.  tmp1 := tmp5 theta.  tmp2 := arg1 * tmp1 cos.  tmp3 := arg1 * tmp1 sin.  tmp4 := vertices first + (tmp2 @ tmp3).  self verticesAt: 2 put: tmp4bottomFraction: arg1  bottomFraction := arg1toggleVisible  self visible ifTrue: [ self hide ] ifFalse: [ self show ]bePressed  self pressed: trueminWidth  ^owner isVertical ifTrue: [ 10 ] ifFalse: [ self theme menuBorderWidth ]setSelectedMorph: arg1  self changeModelSelection: (scroller submorphs indexOf: arg1)newAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5maxLength  ^maxLengthis: arg1 bellowRow: arg2  ^self subclassResponsibilityflipHAroundX: arg1  | tmp1 |  tmp1 := arg1 ifNil: [ bounds center x ] ifNotNil: [ arg1 ].  self setVertices: (vertices collect: [:arg2 |  ((arg2 x - tmp1) * -1 + tmp1) @ arg2 y ]) reversedrestoreMorphicDisplay  world     extent: self actualScreenSize;     viewBox: self viewBox;     handsDo: [:arg1 |  arg1           visible: true;           showTemporaryCursor: nil ];     resizeBackgroundMorph;     submorphsDo: [:arg2 |  arg2 displayExtentChanged ];     fullRepaintNeeded.  world defer: [ Cursor normal show ].  world layoutChangedborderInset  self borderStyle: (BorderStyle inset width: 2)getEnabledSelector  ^getEnabledSelectorintersectFrom: arg1 with: arg2 to: arg3 with: arg4  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg2 x * arg4 y - (arg2 y * arg4 x).  tmp1 = 0.0 ifTrue: [ ^nil ].  tmp2 := arg3 - arg1.  tmp3 := tmp2 x * arg4 y - (tmp2 y * arg4 x).  tmp4 := tmp2 x * arg2 y - (tmp2 y * arg2 x).  tmp3 := tmp3 / tmp1.  tmp4 := tmp4 / tmp1.  tmp3 < 0 ifTrue: [ ^nil ].  tmp4 > 1.0 ifTrue: [ ^nil ].  ^(arg1 x + (tmp3 * arg2 x)) @ (arg1 y + (tmp3 * arg2 y))barFillStyle: arg1  ^self setProperty: #barFillStyle toValue: arg1previousPage  self currentPageFirstIndex > 1 ifTrue: [ currentPageFirstIndex := currentPageFirstIndex - pageSize max: 1.        self showCurrentPage ]displayWorldState: arg1 ofWorld: arg2 submorphs: arg3  | tmp1 tmp2 tmp3 |  arg3 do: [:arg4 |  arg4 fullBounds ].  arg1 checkIfUpdateNeeded ifFalse: [ ^self ].  tmp1 := self doDeferredUpdatingFor: arg2.  tmp1 ifFalse: [ self assuredCanvas ].  self canvas ifNotNil: [ self canvas roundCornersOf: arg2 during: [ | tmp4 tmp5 |              tmp4 := arg1 drawWorld: arg2 submorphs: arg3 invalidAreasOn: self canvas.              tmp2 := arg1 selectHandsToDrawForDamage: tmp4.              tmp5 := tmp2 collect: [:arg5 |  arg5 savePatchFrom: self canvas ].              tmp3 := tmp4 , tmp5.              tmp2 reverseDo: [:arg5 |  self canvas fullDrawMorph: arg5 ] ] ].  arg1 class debugShowDamage ifTrue: [ arg2 flashRects: tmp3 color: Color black ].  self canvas ifNotNil: [:arg6 |  arg6 finish ].  tmp1 ifTrue: [ self forceDamageToScreen: tmp3 ] ifFalse: [ self canvas showAt: arg2 viewBox origin invalidRects: tmp3 ].  tmp2 do: [:arg5 |  arg5 restoreSavedPatchOn: self canvas ].  self     deferUpdates: false;     forceDisplayUpdatemaxEnabled  ^self enabled and: [ self notAtMax ]getBoundsWithFlex  self isFlexed ifTrue: [ ^(owner transform localPointToGlobal: bounds topLeft) extent: bounds extent ] ifFalse: [ ^self bounds ]state: arg1  state := arg1lastState  ^lastStateresetExtension  (extension notNil and: [ extension isDefault ]) ifTrue: [ extension := nil ]vScrollbarValue: arg1  | tmp1 |  tmp1 := self scrollTarget height - self scrollBounds height max: 0.  self scroller offset: self scroller offset x @ (tmp1 * arg1) roundedmodelWakeUpIn: arg1  self viewBox = arg1 panelRect ifFalse: [ self viewBox: arg1 panelRect ]fastTable: arg1  fastTable := arg1hIsScrollbarNeeded  (self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ]) ifTrue: [ ^false ].  (self valueOfProperty: #hScrollBarAlways ifAbsent: [ false ]) ifTrue: [ ^true ].  ^self hIsScrollableinitWithContents: arg1 font: arg2 emphasis: arg3  super initWithContents: arg1 font: arg2 emphasis: arg3.  self     style: #inset;     trackPaneColor: trueelements  ^self model getListnotAtMax  ^self value < self maxhasMarker  ^self hasSubmorphsdefaultColor  ^self theme textColorpressedThumbFillStyle  ^self theme scrollbarPressedThumbFillStyleFor: selfdisable  self enabled: falseicon: arg1  worldRenderer icon: arg1show  self visible ifTrue: [ ^self ].  self visible: true.  self changednormal  self changeEmphasis: #normalselectionColor: arg1  exportAsBMP  self exportAs: 'bmp' using: BMPReadWriternewFuzzyLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newFuzzyLabelIn: self for: arg1 label: arg2 offset: 1 alpha: 0.5 getEnabled: arg3selectedIndex: arg1  | tmp1 |  selectedIndex == arg1 ifTrue: [ ^self ].  tmp1 := selectedIndex.  selectedIndex := arg1 min: self tabs size.  self visibleTabRange first > arg1 ifTrue: [ self visibleTabRange: ((arg1 max: 1) to: 0) ] ifFalse: [ self visibleTabRange last < arg1 ifTrue: [ self visibleTabRange: (0 to: arg1) ] ].  self updateTabs.  self changed: #selectedIndex with: tmp1getSelectionListSelector: arg1  getSelectionListSelector := arg1displayWorldSafely  worldState displayWorldSafely: selfmethodRefList  | tmp1 |  tmp1 := OrderedCollection new.  subscriptions do: [:arg1 |  arg1 do: [:arg2 |  arg2 ifNotNil: [ tmp1 add: (RGMethodDefinition realClass: (arg2 recipient class whichClassIncludesSelector: arg2 selector) selector: arg2 selector) ] ] ].  ^tmp1scanCode  ^scanCodeaddOptionalHandlesTo: arg1 box: arg2  arg1 addHandleAt: arg2 leftCenter color: Color blue icon: nil on: #mouseUp send: #addOrRemoveItems: to: selfbackgroundColor: arg1  backgroundColor := arg1selectedColor  ^selectedColorcellSpacingString: arg1  ^self layoutMenuPropertyString: arg1 from: self cellSpacingprivateMoveBy: arg1  super privateMoveBy: arg1.  (self fillStyles copyWithout: self fillStyle) do: [:arg2 |  arg2 isOrientedFill ifTrue: [ arg2 origin: arg2 origin + arg1 ] ]isRowIndexFullyVisible: arg1  ^(self isRowIndexVisible: arg1) and: [ (self isRowIndexExceding: arg1) not ]ensureCursor  paragraph ifNotNil: [:arg1 |  arg1 showCaret: true ]handleMouseUp: arg1  container enabled ifFalse: [ ^false ].  (container commandOrCrontrolKeyPressed: arg1) ifTrue: [ ^container listManager mouseUp: arg1 on: self ].  ^super handleMouseUp: arg1addToSelection: arg1  arg1 selected ifTrue: [ ^false ].  self searchedElement: nil.  arg1 highlight.  arg1 selected: true.  ^truelastCharacterIndex  ^self paragraph lastCharacterIndexdata: arg1  self subclassResponsibilityopenInWorldExtent: arg1  self openInWorld: self currentWorld extent: arg1submorphsReverseDo: arg1  submorphs reverseDo: arg1wantsDropFiles: arg1  ^self class allowDropFilesmouseDown: arg1  self isEmbedded ifTrue: [ ^self ].  self isTopWindow ifTrue: [ self comeToFront ] ifFalse: [ self activate ].  arg1 hand waitForClicksOrDrag: self event: arg1.  arg1 wasHandled: false.  self submorphsDo: [:arg2 |  (arg2 containsPoint: arg1 cursorPoint) ifTrue: [ arg2 processEvent: arg1 ] ].  arg1 wasHandled: trueinspectItem  self inspectelements  ^elementsgetEnabledSelector: arg1  getEnabledSelector := arg1.  self updateEnabledvalueOfProperty: arg1 ifAbsentPut: arg2  ^self assureOtherProperties at: arg1 ifAbsentPut: arg2newSelectedIndexes: arg1  newSelectedIndexes := arg1athensDrawSelectionOn: arg1  selectedRow ifNil: [ ^self ].  selectedRow = 0 ifTrue: [ ^self ].  self athensDrawBackgroundForSelectedRow: selectedRow on: arg1theme  ^Smalltalk ui themepotentialDropMorph: arg1  potentialDropMorph := arg1.  arg1 highlightForDropderivs: arg1 first: arg2 second: arg3 third: arg4  | tmp1 tmp2 tmp3 |  tmp1 := arg1 size.  tmp1 < 2 ifTrue: [ ^self ].  tmp1 > 2 ifTrue: [ tmp2 := Array new: tmp1.        tmp2 at: 1 put: 4.0.        tmp3 := Array new: tmp1.        tmp3 at: 1 put: 6.0 * (arg1 first - (arg1 second * 2.0) + arg1 third).        2 to: tmp1 - 2 do: [:arg5 |  tmp2 at: arg5 put: 4.0 - (1.0 / (tmp2 at: arg5 - 1)).              tmp3 at: arg5 put: 6.0 * ((arg1 at: arg5) - ((arg1 at: arg5 + 1) * 2.0) + (arg1 at: arg5 + 2)) - ((tmp3 at: arg5 - 1) / (tmp2 at: arg5 - 1)) ].        arg3 at: tmp1 - 1 put: (tmp3 at: tmp1 - 2) / (tmp2 at: tmp1 - 2).        tmp1 - 2 to: 2 by: 0 - 1 do: [:arg5 |  arg3 at: arg5 put: ((tmp3 at: arg5 - 1) - (arg3 at: arg5 + 1)) / (tmp2 at: arg5 - 1) ] ].  arg3 at: 1 put: (arg3 at: tmp1 put: 0.0).  1 to: tmp1 - 1 do: [:arg5 |  arg2 at: arg5 put: (arg1 at: arg5 + 1) - (arg1 at: arg5) - (((arg3 at: arg5) * 2.0 + (arg3 at: arg5 + 1)) / 6.0).        arg4 at: arg5 put: (arg3 at: arg5 + 1) - (arg3 at: arg5) ]isLeft  ^direction = Character arrowLeftaddPolyArrowMenuItems: arg1 hand: arg2  arg1 addLine.  arg1 addWithLabel: '---' enablement: [ self isOpen and: [ arrows ~~ #none ] ] action: #makeNoArrows.  arg1 addWithLabel: '-->' enablement: [ self isOpen and: [ arrows ~~ #forward ] ] action: #makeForwardArrow.  arg1 addWithLabel: '<--' enablement: [ self isOpen and: [ arrows ~~ #back ] ] action: #makeBackArrow.  arg1 addWithLabel: '<->' enablement: [ self isOpen and: [ arrows ~~ #both ] ] action: #makeBothArrows.  arg1 add: 'customize arrows' selector: #customizeArrows:.  (self hasProperty: #arrowSpec) ifTrue: [ arg1 add: 'standard arrows' selector: #standardArrows ]stopBlinking  self stopSteppingSelector: #onBlinkCursortestIsMorph  self assert: morph isMorphchildren  ^childrenredMorphTab  ^(LockableTabMorph label: 'Red Morph' icon: (self iconNamed: #smallBackIcon) morph: (Morph new           color: Color red;           yourself))     closeable: false;     yourselfisLocked  extension ifNil: [ ^false ].  ^extension lockeddegreesOfFlex  ^self rotationDegreeschooseColor: arg1  ^self theme chooseColorIn: self title: 'Colour Selector' translated color: arg1doubleClick: arg1  self isResizeable ifFalse: [ ^self ].  (labelArea containsPoint: arg1 position) ifTrue: [ self expandBoxHit ]transformedBy: arg1  self setVertices: (self vertices collect: [:arg2 |  arg1 localPointToGlobal: arg2 ])scrollerSubMorphFromPoint: arg1  | tmp1 |  scroller hasSubmorphs ifFalse: [ ^nil ].  tmp1 := (scroller firstSubmorph point: arg1 from: self) y.  scroller firstSubmorph top > tmp1 ifTrue: [ ^nil ].  scroller lastSubmorph bottom < tmp1 ifTrue: [ ^nil ].  ^scroller findSubmorphBinary: [:arg2 |  (tmp1 between: arg2 top and: arg2 bottom) ifTrue: [ 0 ] ifFalse: [ (arg2 top + arg2 bottom) // 2 > tmp1 ifTrue: [ -1 ] ifFalse: [ 1 ] ] ]setDefaultParameters  self     color: self theme settings derivedMenuColor;     borderWidth: self theme menuBorderWidth;     borderColor: self theme menuBorderColor.  self theme settings flatMenu ifFalse: [ self borderStyle: BorderStyle thinGray.        self           hasDropShadow: true;           shadowColor: self theme menuShadowColor;           shadowOffset: 1 @ 1 ].  self layoutInset: 3.  self cellInset: 0 @ 1updateDownButtonBounds  downButton bounds: (self theme scrollBarDownButtonBoundsFor: self)isOpened  ^falsedisplay: arg1 atRow: arg2 on: arg3  | tmp1 tmp2 |  arg2 = self mouseDownRow ifFalse: [ ^self ].  tmp2 := self selectionFrameForRow: arg2.  tmp1 := self colorForRow: arg2.  arg3 frameRectangle: tmp2 width: 1 colors: {tmp1 .         Color transparent} dashes: #(1 1)bottomRightColor  ^width = 1 ifTrue: [ self color twiceLighter ] ifFalse: [ self color lighter ]container: arg1 index: arg2  container := arg1.  index := arg2updateData  self subclassResponsibilityhandlesMouseDown: arg1  ^trueinvokeMenu: arg1  | tmp1 |  tmp1 := self getMenu: arg1 shiftPressed.  tmp1 ifNotNil: [ tmp1 popUpEvent: arg1 in: self world ]selectNext  toolbar selectNextownerThatIsA: arg1  ^self firstOwnerSuchThat: [:arg2 |  arg2 isKindOf: arg1 ]showSearchFieldFromKeystrokeEvent: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 keyCharacter asString asText.  tmp3 := self searchFor: tmp1.  tmp2 := RubFloatingEditorBuilder new     customizeEditorWith: [:arg2 |  arg2 bounds: (self table bottomLeft + (0 @ 2) corner: self table bottomRight + (0 @ (arg2 font height + 6))) ];     withEditedContentsDo: [:arg3 :arg2 |  arg3 ifEmpty: [ tmp3 ifTrue: [ self table selectIndex: currentSelIndex ].              self table highlightIndexes: currentHighlightedIndexes ] ifNotEmpty: [ tmp3 := self searchFor: arg3.              tmp3 ifTrue: [ arg2 setTextWith: (arg3                             makeAllColor: self table theme textColor;                             yourself) ] ifFalse: [ arg2 setTextWith: (arg3                             addAttribute: (TextColor new color: Color red);                             yourself) ] ] ];     whenEditorEscapedDo: [ tmp3 ifTrue: [ self table selectIndex: currentSelIndex ].        self table highlightIndexes: currentHighlightedIndexes ].  tmp2 autoAccept: true.  tmp3 ifFalse: [ tmp1 addAttribute: (TextColor new color: Color red) ] ifTrue: [ tmp1 makeAllColor: self table theme textColor ].  tmp2 openEditorWithContents: tmp1mouseDownPriority  ^0isCursorOwner  ^falsemenu: arg1 shifted: arg2  self selectedNode ifNotNil: [:arg3 |  arg3 menu: arg1 shifted: arg2 ].  ^arg1pressedBorderStyle  ^self theme buttonPressedBorderStyleFor: selflistChanged  columnWidths := nil.  super listChangedvalue  ^valuetriggerBalloonFor: arg1 after: arg2  self addAlarm: #spawnBalloonFor: with: arg1 after: arg2focused  ^focused ifNil: [ focused := false ]setUp  super setUp.  table := FTTableMorph new     addColumn: (FTColumn id: 'column1');     addColumn: (FTColumn id: 'column2');     addColumn: (FTColumn id: 'column3');     dataSource: (FTSimpleDataSource elements: (1 to: 10));     yourself.  self setStrategy.  strategy := table selectionModeStrategyactiveDisabledOverDownFillStyle: arg1  self stateMap atPath: #(active disabled over down) put: arg1.  self changedbeWithoutGrips  self setProperty: #noGrips toValue: true.  self removeGripsrejectsEvent: arg1  (arg1 isMouse and: [ arg1 isMouseWheel ]) ifTrue: [ ^self visible not ].  ^self isLocked or: [ self visible not ]protocol  ^self method protocolabort: arg1 title: arg2  ^self theme abortIn: self text: arg1 title: arg2controls  ^controlsmorphsInFrontOverlapping: arg1 do: arg2  ^self morphsInFrontOf: nil overlapping: arg1 do: arg2selectionColor: arg1  | tmp1 |  selectionColor := arg1.  tmp1 := self ownerThatIsA: SystemWindow.  self selectionColorToUse: ((self theme fadedBackgroundWindows not or: [ tmp1 isNil or: [ tmp1 isActive ] ]) ifTrue: [ arg1 ] ifFalse: [ self theme unfocusedSelectionColor ])buildBorderVertices  | tmp1 |  tmp1 := OrderedCollection new.  tmp1     add: tab bottomLeft;     add: tab topLeft;     add: tab topRight;     add: tab bottomRight.  ^tmp1hideHScrollBarIndefinitely: arg1  self setProperty: #noHScrollBarPlease toValue: arg1.  self hHideOrShowScrollBarcontainsPoint: arg1  (super containsPoint: arg1) ifFalse: [ ^false ].  (closed and: [ color isTransparent not ]) ifTrue: [ ^(self filledForm pixelValueAt: arg1 - bounds topLeft + 1) > 0 ].  self lineSegmentsDo: [:arg2 :arg3 |  (arg1 onLineFrom: arg2 to: arg3 within: (3 max: (borderWidth + 1) // 2) asFloat) ifTrue: [ ^true ] ].  self arrowForms do: [:arg4 |  (arg4 pixelValueAt: arg1 - arg4 offset) > 0 ifTrue: [ ^true ] ].  ^falsenewFuzzyLabelFor: arg1 label: arg2 offset: arg3 alpha: arg4 getEnabled: arg5  ^self theme newFuzzyLabelIn: self for: arg1 label: arg2 offset: arg3 alpha: arg4 getEnabled: arg5label: arg1  label := arg1show: arg1 from: arg2 to: arg3 during: arg4  | tmp1 tmp2 |  self openInWorld.  tmp1 := self addItemShowing: arg1 from: arg2 to: arg3.  self     refresh;     reposition.  [ tmp2 := tmp1 do: arg4 ] ensure: [ self close: tmp1 ].  ^tmp2morphsInFrontOf: arg1 overlapping: arg2 do: arg3  self submorphsDo: [:arg4 |  arg4 == arg1 ifTrue: [ owner ifNil: [ ^self ].              ^owner morphsInFrontOf: self overlapping: arg2 do: arg3 ].        (arg4 fullBoundsInWorld intersects: arg2) ifTrue: [ arg3 value: arg4 ] ].  owner ifNil: [ ^self ].  ^owner morphsInFrontOf: self overlapping: arg2 do: arg3exportAsJPEG  self exportAs: 'jpeg' using: PluginBasedJPEGReadWritercancelEdits  self releaseParagraph.  editView cancelgradientHalo  ^truesetUp  super setUp.  prototypes add: (TextLine start: 1 stop: 50 internalSpaces: 2 paddingWidth: 1)outerBounds  ^self boundsmakeOpen  closed := false.  handles ifNotNil: [ self           removeHandles;           addHandles ].  self computeBoundslineBorderWidth  ^self borderWidthnewButtonFor: arg1 action: arg2 getEnabled: arg3 label: arg4 help: arg5  ^self newButtonFor: arg1 getState: nil action: arg2 arguments: nil getEnabled: arg3 label: arg4 help: arg5selectedMorphList  ^selectedMorphList ifNil: [ selectedMorphList := LinkedList new ]sentTo: arg1  ^arg1 handleWindowEvent: selfpassivate  self submorphsDo: [:arg1 |  arg1 passivate ]autoDeselection: arg1  self listManager autoDeselection: arg1printOn: arg1  super printOn: arg1.  arg1 print: contentscenterWidget: arg1  arg1     fullBounds;     center: self centernewGroupbox: arg1 for: arg2  ^self theme newGroupboxIn: self label: arg1 for: arg2notExpandedFormForMorph: arg1  ^(arg1 selected and: [ self selectionColor luminance < 0.7 ]) ifTrue: [ self theme whiteTreeUnexpandedForm ] ifFalse: [ self theme treeUnexpandedForm ]selectFirst  self table selectIndex: 1edgeName: arg1  edgeName := arg1.  self     setLayoutSizingFor: arg1;     layoutFrame: self gripLayoutFrame;     layoutChangedpressedFillStyle  ^self theme buttonPressedFillStyleFor: selfhasNodeContents: arg1  hasChildrenSelector ifNil: [ ^arg1 contents isNotEmpty ].  ^model perform: hasChildrenSelector with: arg1 itemlayout: arg1 in: arg2  ^self transform: arg2isMenubar  ^truegradientRamp: arg1  gradientRamp := arg1.  self updateColorupArrow  ^UpArrowdoOneSubCycle  worldState doOneSubCycleFor: selfaddMiscExtrasTo: arg1  | tmp1 |  self isWorldMorph ifTrue: [ ^self ].  tmp1 := UIManager default newMenuIn: self for: self.  self renderedMorph isSystemWindow ifFalse: [ tmp1 add: 'put in a window' selector: #embedInWindow ].  tmp1 add: 'adhere to edge...' selector: #adhereToEdge.  arg1 add: 'extras...' subMenu: tmp1indexForInserting: arg1 at: arg2 in: arg3  | tmp1 tmp2 tmp3 |  arg3 hasSubmorphs ifFalse: [ ^1 ].  arg1 disableTableLayout ifTrue: [ ^1 ].  tmp1 := (arg3 listDirection == #topToBottom or: [ arg3 listDirection == #bottomToTop ]) not.  tmp2 := arg3 submorphs.  arg3 reverseTableCells ifTrue: [ tmp2 := tmp2 reversed ].  tmp3 := self indexForInserting: arg2 inList: tmp2 horizontal: tmp1 target: arg3.  arg3 reverseTableCells ifTrue: [ tmp3 := tmp2 size - tmp3 + 2 ].  ^tmp3 ifNil: [ 1 ]dataSource  ^dataSourceactualClass  ^FTUnsortedSortingStatedebug  job isRunning ifTrue: [ job debug ]handlesKeyboard: arg1  ^(self handlesKeyDown: arg1) or: [ (self handlesKeyUp: arg1) or: [ self handlesKeyStroke: arg1 ] ]fullDrawOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  self visible ifFalse: [ ^self ].  (arg1 isVisible: self fullBounds) ifFalse: [ ^self ].  tmp1 := false.  tmp1 ifTrue: [ self nonCachingFullDrawOn: arg1.        ^self ].  submorphs isEmpty ifTrue: [ cacheCanvas := nil.        ^self drawOn: arg1 ].  tmp2 := Rectangle merging: (submorphs collect: [:arg2 |  arg2 fullBounds ]).  self updateCacheCanvas: arg1.  (cacheCanvas isNil or: [ cachedCanvasHasHoles and: [ cacheCanvas depth = 1 ] ]) ifTrue: [ self nonCachingFullDrawOn: arg1.        ^self ].  tmp3 := cachedCanvasHasHoles == false and: [ submorphs size = 1 and: [ submorphs first wantsRoundedCorners ] ].  tmp3 ifTrue: [ tmp4 := submorphs first.        arg1 asShadowDrawingCanvas translateBy: self shadowOffset during: [:arg3 |  arg3 roundCornersOf: tmp4 during: [ (tmp2 areasOutside: (tmp4 boundsWithinCorners translateBy: self shadowOffset negated)) do: [:arg4 |  arg3 fillRectangle: arg4 color: Color black ] ] ].        arg1 roundCornersOf: tmp4 during: [ arg1 drawImage: cacheCanvas form at: tmp2 origin sourceRect: cacheCanvas form boundingBox ].        ^self drawOn: arg1 ].  (submorphs anySatisfy: [:arg2 |  arg2 handlesDropShadowInHand not ]) ifTrue: [ arg1 asShadowDrawingCanvas translateBy: self shadowOffset during: [:arg3 |  cachedCanvasHasHoles ifTrue: [ arg3 paintImage: cacheCanvas form at: tmp2 origin ] ifFalse: [ (tmp2 areasOutside: (tmp2 translateBy: self shadowOffset negated)) do: [:arg4 |  arg3 fillRectangle: arg4 color: Color black ] ] ] ].  cachedCanvasHasHoles ifTrue: [ arg1 paintImage: cacheCanvas form at: tmp2 origin ] ifFalse: [ arg1 drawImage: cacheCanvas form at: tmp2 origin sourceRect: cacheCanvas form boundingBox ].  self drawOn: arg1ascendingSortFunction  ^self subclassResponsibilitynewImageFor: arg1 get: arg2 help: arg3  ^self theme newImageIn: self for: arg1 get: arg2 help: arg3taskOf: arg1  ^self orderedTasks detect: [:arg2 |  arg2 morph = arg1 ] ifNone: [  ]vHideScrollbar  self vScrollbarShowing ifFalse: [ ^self ].  self removeMorph: self vScrollbar.  self hResizeScrollbar.  self resizeScrollernewGroupboxForAll: arg1  ^self theme newGroupboxIn: self forAll: arg1openPath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  tmp1 := nil.  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ (arg2 complexContents asString = arg1 first or: [ arg1 first isNil ]) ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNil: [ self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ (arg2 complexContents asString sameAs: arg1 first) ifTrue: [ tmp1 := arg2 ] ] ] ].  tmp1 ifNotNil: [ tmp1 isExpanded ifFalse: [ tmp1 toggleExpandedState.              container adjustSubmorphPositions ].        tmp1 changed.        arg1 size = 1 ifTrue: [ ^container setSelectedMorph: tmp1 ].        ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild openPath: arg1 allButFirst ] ].  ^container setSelectedMorph: nilstartColumnIndex  startColumnIndex ifNil: [ startColumnIndex := 0 ].  ^startColumnIndexselectAllNodePaths: arg1  self selection: (MorphTreeMorphMultipleSelection new selectedNodePathList: arg1)newMultistateButton  ^self theme newMultistateButtonIn: selfhelpText  ^nilminHeight  ^self theme menuBorderWidthhorizontalScrollBar  ^horizontalScrollBarprintOn: arg1  super printOn: arg1.  arg1     space;     nextPut: $(;     print: self identityHash;     nextPut: $).  locked == true ifTrue: [ arg1 nextPutAll: ' [locked] ' ].  visible == false ifTrue: [ arg1 nextPutAll: '[not visible] ' ].  sticky == true ifTrue: [ arg1 nextPutAll: ' [sticky] ' ].  balloonText ifNotNil: [ arg1 nextPutAll: ' [balloonText] ' ].  externalName ifNotNil: [ arg1           nextPutAll: ' [externalName = ' , externalName;           nextPutAll: ' ] ' ].  eventHandler ifNotNil: [ arg1           nextPutAll: ' [eventHandler = ' , eventHandler printString;           nextPutAll: '] ' ].  (otherProperties isNil or: [ otherProperties isEmpty ]) ifTrue: [ ^self ].  arg1 nextPutAll: ' [other: '.  self otherProperties keysDo: [:arg2 |  arg1           nextPutAll: ' (' , arg2 , ' -> ' , (self otherProperties at: arg2) printString;           nextPutAll: ')' ].  arg1 nextPut: $]colorToUse  | tmp1 |  tmp1 := self getModelState ifTrue: [ onColor ifNil: [ self paneColor ] ifNotNil: [ onColor isTransparent ifTrue: [ self paneColor ] ifFalse: [ onColor ] ] ] ifFalse: [ offColor ifNil: [ self paneColor ] ifNotNil: [ offColor isTransparent ifTrue: [ self paneColor ] ifFalse: [ offColor ] ] ].  ^tmp1wouldAcceptKeyboardFocus  ^self isLocked notisSelected  ^self tabSelector ifNil: [ false ] ifNotNil: [:arg1 |  arg1 selectedTab == self ]testMaintainingSelectionsOnUpdate  | tmp1 tmp2 tmp3 |  tmp1 := ClassTreeExample new.  [ tmp2 := tmp1 openOn: Collection.  tmp3 := tmp1 dependents last.  tmp3 expandAll.  tmp1 selectItems: {Bag .         CharacterSet}.  tmp3 selectedMorphList do: [:arg1 |  self assert: ({Bag .               CharacterSet} includes: arg1 complexContents withoutListWrapper) ].  tmp1 updateList.  tmp3 selectedMorphList do: [:arg1 |  self assert: ({Bag .               CharacterSet} includes: arg1 complexContents withoutListWrapper) ] ] ensure: [ tmp2 close ]dragHand  ^dragHandcursorBounds  temporaryCursor ifNil: [ ^self position extent: NormalCursor extent ] ifNotNil: [ ^self position + temporaryCursorOffset extent: temporaryCursor extent ]setAsRow  self     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     borderWidth: 0vScrollbarValue  | tmp1 tmp2 tmp3 |  tmp1 := self scrollTarget height.  tmp2 := self scrollBounds height.  tmp3 := tmp1 - tmp2 max: 0.  tmp3 = 0 ifFalse: [ tmp3 := self scroller offset y asFloat / tmp3 min: 1.0 ].  ^tmp3resizeScrollBars  self extent = self defaultExtent ifFalse: [ super resizeScrollBars ]intoWorld: arg1  self     setToAdhereToEdge: #bottomLeft;     updateBounds.  super intoWorld: arg1resetCollapsedFrame  collapsedFrame := niltestSelectAll  table beSingleSelection.  table selectFirst.  table selectAll.  self assert: table selectedIndexes equals: #(1).  table beMultipleSelection.  table selectFirst.  table selectAll.  self assert: table selectedIndexes equals: #(1 2 3 4 5 6 7 8 9 10)keepLeftMorphsOrder  leftMorphs size > 1 ifTrue: [ leftMorphs := mouseOverMorphs intersection: leftMorphs ]rootItems  ^self itemsForTest asArray sort: [:arg1 :arg2 |  arg1 name < arg2 name ]beMultipleSelection  multipleSelection := trueavoidsOcclusions  ^container notNil and: [ container avoidsOcclusions ]drawable  ^drawable ifNil: [ false ]narrow  self changeEmphasis: #narrowtestWindowCreation  | tmp1 tmp2 tmp3 |  tmp1 := 0.  self currentWorld announcer when: WindowResizing do: [:arg1 |  tmp1 := tmp1 + 1 ].  window := SystemWindow labelled: 'foo'.  window setProperty: #minimumExtent toValue: 1 @ 1.  window openInWorld.  tmp2 := window bounds.  window announcer when: WindowResizing do: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 0.  window extent: 50 @ 60.  tmp3 := window bounds.  self assert: tmp1 equals: 1keyStroke: arg1  self flag: #pharoTodo.  ((super keyStroke: arg1) or: [ self navigationKey: arg1 ]) ifTrue: [ ^true ].  ^self keyStrokeSearch: arg1chooseEmphasisOrAlignment  self editor changeEmphasisOrAlignment.  self updateFromParagraphnewSelectedRowIndexes  self deprecated: 'Use #newSelectedIndexes instead' transformWith: '`@receiver newSelectedRowIndexes' -> '`@receiver newSelectedIndexes'.  ^self newSelectedIndexeskeyStroke: arg1  | tmp1 tmp2 |  tmp1 := arg1 keyValue asCharacter.  (self arrowEvent: arg1 key: tmp1) ifTrue: [ ^true ].  tmp1 = Character cr ifTrue: [ self selectSearchedElement.        ^true ].  arg1 anyModifierKeyPressed ifFalse: [ self basicKeyPressed: tmp1.        ^true ].  self keystrokeActionSelector ifNil: [ ^false ].  tmp2 := self keystrokeActionSelector numArgs.  (tmp2 = 0 or: [ tmp2 > 2 ]) ifTrue: [ ^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol' ] ifFalse: [ ^tmp2 = 1 ifTrue: [ self listModel perform: self keystrokeActionSelector with: arg1 ] ifFalse: [ self listModel perform: self keystrokeActionSelector with: arg1 with: self ] ]backgroundColor  ^backgroundColorselectedMorph  ^selectedMorphisTranslucentButNotTransparent  ^truestartDrag: arg1  | tmp1 tmp2 tmp3 |  self dragEnabled ifTrue: [ tmp2 := self allNodeMorphs detect: [:arg2 |  arg2 highlightedForMouseDown ] ifNone: [  ] ].  (tmp2 isNil or: [ arg1 hand hasSubmorphs ]) ifTrue: [ ^self ].  tmp2 highlightForMouseDown: false.  (self listManager selectedMorphList includes: tmp2) ifFalse: [ self listManager setSelectedMorph: tmp2 ].  tmp3 := self model dragPassengerFor: tmp2 inMorph: self.  tmp3 ifNotNil: [ tmp1 := self model transferFor: tmp3 from: self.        tmp1 align: tmp1 draggedMorph center with: arg1 position.        tmp1 dragTransferType: (self model dragTransferTypeForMorph: self).        arg1 hand grabMorph: tmp1 ].  arg1 hand releaseMouseFocus: selfhandlesMouseOver: arg1  self table ifNotNil: [:arg2 |  ^arg2 selectionModeStrategy allowsRowSelection ].  ^falsesetStripeColorsFrom: arg1  stripes ifNil: [ ^self ].  self fillStyle: self fillStyleToUse.  self isActive ifTrue: [ label ifNotNil: [ label color: self activeLabelFillStyle ].        labelArea fillStyle: self activeTitleFillStyle ] ifFalse: [ label ifNotNil: [ label color: self inactiveLabelFillStyle ].        labelArea fillStyle: self inactiveTitleFillStyle ].  self adoptPaneColor: self paneColororderedTasks: arg1  orderedTasks := arg1generateMouseEvent: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  self class environment at: #KMBuffer ifPresent: [:arg2 |  arg2 uniqueInstance clearBuffer ].  arg1 first = lastEventBuffer first ifTrue: [ tmp8 := false.        3 to: arg1 size do: [:arg3 |  (lastEventBuffer at: arg3) = (arg1 at: arg3) ifFalse: [ tmp8 := true ] ].        tmp8 ifFalse: [ ^nil ] ].  tmp6 := arg1 second.  tmp6 = 0 ifTrue: [ tmp6 := Time millisecondClockValue ].  tmp1 := arg1 third @ arg1 fourth.  tmp2 := arg1 fifth.  tmp3 := arg1 sixth.  tmp4 := tmp2 = 0 ifTrue: [ lastEventBuffer fifth = 0 ifTrue: [ #mouseMove ] ifFalse: [ #mouseUp ] ] ifFalse: [ lastEventBuffer fifth = 0 ifTrue: [ #mouseDown ] ifFalse: [ #mouseMove ] ].  tmp2 := tmp2 bitOr: (tmp3 bitShift: 3).  tmp7 := lastEventBuffer fifth bitOr: (lastEventBuffer sixth bitShift: 3).  lastEventBuffer := arg1.  tmp4 == #mouseMove ifTrue: [ tmp5 := self mouseTrailFrom: arg1.        ^MouseMoveEvent basicNew setType: tmp4 startPoint: self position endPoint: tmp5 last trail: tmp5 buttons: tmp2 hand: self stamp: tmp6 ].  ^MouseButtonEvent basicNew setType: tmp4 position: tmp1 which: (tmp7 bitXor: tmp2) buttons: tmp2 hand: self stamp: tmp6newDialogPanel  ^self theme newDialogPanelIn: selfcellInset  ^cellInsetdisabledFillStyle  ^self theme controlButtonDisabledFillStyleFor: selfminHeight  ^self minimumExtent y max: super minHeightextent: arg1  self extent = arg1 ifTrue: [ ^self ].  super extent: arg1.  self updateOrientation: arg1pressedBorderStyle  ^self theme taskbarItemPressedBorderStyleFor: selfstepTime  ^100secondName  ^self item secondNamehighlightColor: arg1  self setProperty: #highlightColor toValue: arg1isKeyDown  ^self type == #keyDowncmdGesturesEnabled  ^self class cmdGesturesEnabledseparatorColor: arg1  separatorColor := arg1color  ^color ifNil: [ self theme ghostTextColor ]atBottom: arg1  atBottom ~= arg1 ifTrue: [ atBottom := arg1 ]handleEdit: arg1  self selectionChanged.  arg1 value.  self selectionChanged.  self updateFromParagraphstartDragExtended: arg1  dragItemSelector ifNil: [ ^self ].  arg1 hand hasSubmorphs ifTrue: [ ^self ].  [ | tmp1 tmp2 tmp3 tmp4 |  (self dragEnabled and: [ model okToChange ]) ifFalse: [ ^self ].  tmp1 := self rowAtLocation: arg1 position.  tmp1 = 0 ifTrue: [ ^self ].  tmp2 := model perform: dragItemSelector with: tmp1.  tmp2 ifNil: [ ^self ].  self mouseDownRow: nil.  tmp3 := self model transferFor: tmp2 from: self.  tmp4 := tmp3 draggedMorph bounds.  tmp3 position: arg1 position - (tmp4 center - tmp4 origin).  tmp3 dragTransferType: #dragTransfer.  arg1 hand grabMorph: tmp3 ] ensure: [ Cursor normal show.        arg1 hand newMouseFocus: self ]emphasisChoices  ^#(normal bold italic narrow underlined struckOut)defaultColor  ^Color lightGreenwantsDroppedMorph: arg1 event: arg2  self visible ifFalse: [ ^false ].  self dropEnabled ifFalse: [ ^false ].  (self tabGroup tabSelectorMorph bounds containsPoint: arg2 position) ifFalse: [ ^false ].  ^arg1 isSystemWindowaddOptionalHandlesTo: arg1 box: arg2  testSortDataSource  | tmp1 |  tmp1 := self dataSourceForTesting.  self assert: tmp1 elements equals: self elementsForTestDataSource.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: self elementsForTestDataSourcequestionWithoutCancel: arg1  ^self questionWithoutCancel: arg1 title: 'Question' translatedtestHaloIsDisable  | tmp1 |  tmp1 := Morph halosEnabled.  Morph halosEnabled: false.  self assert: (Morph new addHalo: nil) ~= (Smalltalk globals at: #HaloMorph).  Morph halosEnabled: tmp1progress  ^progressBar value / 100isWrapped  ^wrapFlagiconSymbol  ^iconSymbolselectedPressedFillStyle  ^self theme buttonSelectedPressedFillStyleFor: selfaboutTitle  | tmp1 |  tmp1 := self model ifNil: [ 'SystemWindow' ] ifNotNil: [ (self model respondsTo: #aboutTitle) ifTrue: [ self model aboutTitle ] ifFalse: [ self model class name ] ].  ^'About {1}' translated format: {tmp1}waitForClicksOrDrag: arg1 event: arg2  ^self waitForClicksOrDrag: arg1 event: arg2 selectors: #(#click: #doubleClick: #doubleClickTimeout: #startDrag:) threshold: 10elementAt: arg1  ^self getListElementSelector ifNotNil: [ self model perform: self getListElementSelector with: arg1 ] ifNil: [ (self model perform: self getListSelector) at: arg1 ]mouseDown: arg1  | tmp1 |  (self bounds containsPoint: arg1 cursorPoint) ifTrue: [ self fillStyle: self pressedFillStyle ].  tmp1 := arg1 cursorPoint.  lastMouse := {tmp1 .   (tmp1 - self position) .   (tmp1 - self targetPoint)}.  self eventHandler ifNotNil: [ self eventHandler mouseDown: arg1 fromMorph: self ]handleMouseMove: arg1  (arg1 wasHandled or: [ resetable not ]) ifTrue: [ ^self ].  self resetAlpha.  arg1 wasHandled: truesliderColor: arg1  super sliderColor: (self enabled ifTrue: [ Color black ] ifFalse: [ self sliderShadowColor ]).  slider ifNotNil: [ slider borderStyle baseColor: Color white ]newImage: arg1 size: arg2  ^self theme newImageIn: self form: arg1 size: arg2drawIconAndLabelOnAthensCanvas: arg1  arg1 pathTransform restoreAfter: [ self drawIconOnAthensCanvas: arg1.        self drawLabelOnAthensCanvas: arg1 ]handlesDoubleClick  ^self editView handlesDoubleClickinitialize  super initialize.  self locationMorph: self newLocationMorph.  self     clipSubmorphs: true;     color: Color blue;     borderStyle: (BorderStyle inset width: 1);     addMorphBack: self locationMorph;     addMorphBack: self blackGradientMorphheaderColumn: arg1  ^self basicHeaderCellFor: arg1ownerChain  | tmp1 tmp2 |  tmp1 := OrderedCollection with: self.  tmp2 := self.  [ (tmp2 := tmp2 owner) notNil ] whileTrue: [ tmp1 add: tmp2 ].  ^tmp1 asArrayroundedCorners: arg1  arg1 = #(1 2 3 4) ifTrue: [ self removeProperty: #roundedCorners ] ifFalse: [ self setProperty: #roundedCorners toValue: arg1 ].  self changeddefaultColor  ^Color transparentdoDup: arg1 with: arg2  (target isKindOf: SelectionMorph) ifTrue: [ ^target doDup: arg1 fromHalo: self handle: arg2 ].  self obtainHaloForEvent: arg1 andRemoveAllHandlesBut: arg2.  self setTarget: (target duplicateMorph: arg1).  arg1 hand grabMorph: target.  self step.  arg1 hand addMouseListener: selfextent  ^container width @ (lines last bottom - lines first top)handlesKeyboard: arg1  ^trueghostText  ^'Filter...'expandedButton  ^self defaultButton     actionSelector: #collapseItem;     labelGraphic: Smalltalk ui theme treeExpandedForm;     helpText: 'Collapse Item';     yourselfroot  (owner isNil or: [ owner isWorldOrHandMorph ]) ifTrue: [ ^self ].  ^owner rootsetArrowheads  | tmp1 tmp2 |  tmp1 := self renderedMorph valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  tmp2 := Morph obtainArrowheadFor: 'Head size for arrowheads: ' translated defaultValue: tmp1 asString.  tmp2 ifNotNil: [ self renderedMorph setProperty: #arrowSpec toValue: tmp2 ] ifNil: [ self inform: 'Invalid input' ]hasFillStyle  ^truestyle  ^#raisedmakeBackArrow  arrows := #back.  self computeBoundsmethodsInCategory: arg1  ^self item selectorsInProtocol: arg1asAthensPaintOn: arg1  | tmp1 |  tmp1 := self color asStrokePaintOn: arg1.  tmp1 width: self width.  tmp1 joinMiter.  ^tmp1disableTableLayout: arg1  disableLayout := arg1updateOrientation: arg1  | tmp1 |  tmp1 := self buttons.  arg1 x >= arg1 y ifTrue: [ self listDirection: #leftToRight.        tmp1 first           roundedCorners: #(1 2);           hResizing: #rigid;           vResizing: #spaceFill;           width: arg1 y;           label: (self newButtonLabel: #left ofSize: arg1 y // 2).        tmp1 last           roundedCorners: #(3 4);           hResizing: #rigid;           vResizing: #spaceFill;           width: arg1 y;           label: (self newButtonLabel: #right ofSize: arg1 y // 2) ] ifFalse: [ self listDirection: #topToBottom.        tmp1 first           roundedCorners: #(1 4);           hResizing: #spaceFill;           vResizing: #rigid;           height: arg1 x;           label: (self newButtonLabel: #top ofSize: arg1 x // 2).        tmp1 last           roundedCorners: #(2 3);           hResizing: #spaceFill;           vResizing: #rigid;           height: arg1 x;           label: (self newButtonLabel: #bottom ofSize: arg1 x // 2) ]computeDays  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp4 := 0 @ 25.  tmp3 := self bounds height - 25.  tmp1 := tmp3 // 8.  tmp3 := tmp3 - tmp1.  tmp2 := self bounds width // 7.  tmp5 := date month previous.  tmp8 := date month.  tmp6 := date month next.  days := OrderedCollection new.  1 to: 6 do: [:arg1 |  | tmp9 |        tmp9 := tmp4 y + (arg1 * tmp1).        (self daysForLine: arg1) withIndexDo: [:arg2 :arg3 |  | tmp10 tmp11 |              tmp11 := tmp8 asDate addDays: arg2 - 1.              (arg1 = 1 and: [ arg2 > 7 ]) ifTrue: [ tmp11 := tmp5 asDate addDays: arg2 - 1 ].              (arg1 > 4 and: [ arg2 < 15 ]) ifTrue: [ tmp11 := tmp6 asDate addDays: arg2 - 1 ].              tmp10 := tmp2 * (arg3 - 1).              days add: (tmp7 := CalendarDayMorph on: tmp11 for: self).              tmp7 bounds: (tmp10 @ tmp9 extent: tmp2 @ tmp1) ] ]adoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self fillStyle: self fillStyleToUse.  self borderStyle: self borderStyleToUse.  self cornerStyle: (self isRadioButton ifTrue: [ self theme radioButtonCornerStyleFor: self ] ifFalse: [ self theme checkboxCornerStyleFor: self ])transformFromOutermostWorld  ^self transformFrom: self outermostWorldMorphinvokeWithEvent: arg1  | tmp1 |  self isEnabled ifFalse: [ ^self ].  owner ifNotNil: [ self isStayUpItem ifFalse: [ self flag: #workAround.              (tmp1 := self world) ifNotNil: [ owner deleteIfPopUp: arg1.                    tmp1 displayWorldSafely ] ] ].  selector ifNil: [ ^self ].  Cursor normal showWhile: [ | tmp2 |        (tmp2 := selector numArgs) = 0 ifTrue: [ target perform: selector ] ifFalse: [ tmp2 = arguments size ifTrue: [ target perform: selector withArguments: arguments ] ifFalse: [ target perform: selector withArguments: (arguments copyWith: arg1) ] ].        self showShortcut.        self changed ]addLabelItemsTo: arg1 hand: arg2  arg1 add: 'change label' selector: #setLabelremovePageIndex: arg1  self pages removeAt: arg1.  self tabSelectorMorph removeTabIndex: arg1model  ^modelgripLayoutFrame  ^(1 @ 1 corner: 1 @ 1) asLayoutFrame topLeftOffset: (0 - self defaultWidth) @ (0 - self defaultHeight)valueOfProperty: arg1 ifPresentDo: arg2  extension ifNil: [ ^self ].  ^arg2 value: (extension valueOfProperty: arg1 ifAbsent: [ ^self ])topLeft  ^left @ topaddHalo  ^self addHalo: nilrubberBandCells: arg1  self assureTableProperties rubberBandCells: arg1.  self layoutChangedmouseDownOnHelpHandle: arg1  | tmp1 |  arg1 shiftPressed ifTrue: [ ^self editBalloonHelpText ].  tmp1 := self balloonText.  tmp1 ifNil: [ tmp1 := self noHelpString ].  self showBalloon: tmp1 hand: arg1 handtarget  ^targetannounceActivated  self announce: (WindowActivated new           window: self;           yourself)handlesMouseWheel: arg1  ^self isVerticalScrollBarVisible and: [ self hasDataSource ]coefficientsForMoreThanThreePoints  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self vertices.  tmp2 := {(tmp3 := tmp1 collect: [:arg1 |  arg1 x asFloat ]) .   (tmp4 := self slopes: tmp3) .   (self changeInSlopes: tmp4 of: tmp3) .   (self changeOfChangesInSlopes: tmp4 of: tmp3) .   (tmp5 := tmp1 collect: [:arg1 |  arg1 y asFloat ]) .   (tmp6 := self slopes: tmp5) .   (self changeInSlopes: tmp6 of: tmp5) .   (self changeOfChangesInSlopes: tmp6 of: tmp5) .   (Array new: tmp1 size withAll: 12)}.  tmp7 := (1 to: tmp1 size) collect: [:arg2 |  (self transform: tmp2 toCubicPointPolynomialAt: arg2) bestSegments ].  tmp2 at: 9 put: tmp7.  curveState := {tmp2 .   nil .   nil}.  self computeNextToEndPoints.  ^tmp2newText: arg1  ^self theme newTextIn: self text: arg1defaultBorderWidth  ^1tableRefresh  table ifNotNil: [ table refresh ]offImage  | tmp1 |  tmp1 := Form extent: (self fontToUse ascent - 2) asPoint depth: 16.  tmp1 getCanvas frameAndFillRectangle: tmp1 boundingBox fillColor: (Color gray: 0.9) borderWidth: 1 borderColor: Color black.  ^tmp1testExecuteSortingOn  | tmp1 |  tmp1 := self dataSourceForTesting.  state executeSortingOn: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10).  state executeSortingOn: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10)backgroundColorForRow: arg1  ^(self isRowSelected: arg1) ifTrue: [ listSource selectionColorToUse ] ifFalse: [ self theme backgroundColor ]hideOrShowScrollBar  (self valueOfProperty: #noScrollBarPlease ifAbsent: [ false ]) ifTrue: [ ^self ].  (self vIsScrollbarNeeded not and: [ self isScrolledFromTop not ]) ifTrue: [ self vHideScrollBar ].  (self vIsScrollbarNeeded or: [ self isScrolledFromTop ]) ifTrue: [ self vShowScrollBar ]backgroundColor  ^backgroundColorbuildButtonWithIconTop  ^(PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: nil) beIconTopisVertical  ^self isAdheringToLeft or: [ self isAdheringToRight ]bigTitle: arg1  self     withCloseBox;     title: arg1;     font: StandardFonts windowTitleFont;     withPinBoxhorizontalPlacement: arg1 verticalPlacement: arg2 color: arg3 iconSymbol: arg4 addHandleSelector: arg5  horizontalPlacement := arg1.  verticalPlacement := arg2.  color := arg3.  iconSymbol := arg4 asSymbol.  addHandleSelector := arg5allowedToClose  ^self mustNotClose not and: [ self modalChild isNil ]closeAllTabs  tabs copy do: [:arg1 |  arg1 close ]value: arg1  ^progressBar value: arg1newTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 help: arg5  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 help: arg5expandAllTo: arg1  children do: [:arg2 |  arg2 expandAllTo: arg1 ]isActive  ^self state == #activenumberOfRows  ^self subclassResponsibilityforwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1announceDeleted  self doAnnounce: (MorphDeleted morph: self).  self submorphs do: #announceDeletedhandlesMouseDown: arg1  ^truefindReplaceSelectionColor  ^self theme currentSettings findReplaceSelectionColornewCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6initializeSlider  super initializeSlider.  slider borderStyle: (BorderStyle raised           baseColor: slider color;           width: 1)layoutBounds  | tmp1 |  tmp1 := self innerBounds.  ^indentation = 0 ifTrue: [ tmp1 ] ifFalse: [ indentation @ 0 + tmp1 origin corner: tmp1 corner ]selectAll  self allNodeMorphs isEmpty ifTrue: [ ^self ].  self isMultiple ifFalse: [ ^self ].  self addAllToSelection: self allNodeMorphslabelWidgetAllowance  ^labelWidgetAllowance ifNil: [ self setLabelWidgetAllowance ]pattern  ^patterncomputedHeight  ^computedHeight ifNil: [ computedHeight := self computedHeightFromContents + self layoutInset asPoint y + self cellInset asPoint y ]top  ^toprejectDropEvent: arg1  (self repelsMorph: arg1 contents event: arg1) ifFalse: [ ^self ].  (self fullContainsPoint: arg1 position) ifFalse: [ ^self ].  arg1 wasHandled: true.  arg1 contents rejectDropMorphEvent: arg1setFirstCharacter: arg1  | tmp1 tmp2 |  tmp1 := arg1 asCharacter.  (tmp2 := self getCharacters) isEmpty ifTrue: [ self newContents: (String with: tmp1) ] ifFalse: [ tmp2 first = tmp1 ifFalse: [ self newContents: (String streamContents: [:arg2 |  arg2 nextPut: tmp1.                          arg2 nextPutAll: (tmp2 copyFrom: 2 to: tmp2 size) ]) ] ]addTab: arg1  toolbar addTab: arg1chooseDropList: arg1 list: arg2  ^self chooseDropList: arg1 title: 'Choose' translated list: arg2drawOnAthensCanvas: arg1  self drawOnCanvasWrapperFor: arg1contents: arg1  ^self contents: arg1 withMarkers: truedisplayCaretAndSelectionOnAthensCanvas: arg1  selectionStart ifNil: [ ^self ].  selectionStart = selectionStop ifTrue: [ self drawCaretOnAthensCanvas: arg1 ] ifFalse: [ | tmp1 |        caretRect := nil.        tmp1 := ParagraphSelectionBlock first: selectionStart last: selectionStop color: self selectionColor.        self forLinesIn: arg1 clipRect do: [:arg2 |  tmp1 displayInLine: arg2 onAthensCanvas: arg1 ] ]getStateSelector  ^getStateSelectorselectRowIndexes: arg1  self deprecated: 'Use #selectIndexes: instead' transformWith: '`@receiver selectRowIndexes: `@statements1' -> '`@receiver selectIndexes: `@statements1'.  self selectIndexes: arg1do: arg1  arg1 value: self.  nextCell ifNotNil: [ nextCell do: arg1 ]chooseColor: arg1  ^self theme chooseColorIn: self title: 'Colour Selector' translated color: arg1wantsKeyboardFocusFor: arg1  arg1 wouldAcceptKeyboardFocus ifTrue: [ ^true ].  ^super wantsKeyboardFocusFor: arg1vResizing: arg1  vResizing := arg1header: arg1  self ensureAtLeastOneColumn.  self columns first id: arg1initializeAppearance  self     color: Color gray;     borderStyle: (BorderStyle inset width: 3)duplicate  selectedItems := selectedItems collect: #duplicate.  selectedItems reverseDo: [:arg1 |  (owner ifNil: [ self currentWorld ]) addMorph: arg1 ].  dupLoc := self position.  ActiveHand grabMorph: selfpositionAt: arg1 relativeTo: arg2 inWorld: arg3  | tmp1 tmp2 tmp3 tmp4 |  self fullBounds.  tmp1 := 0.  tmp2 := 0.  [ (tmp3 := self submorphs at: (tmp1 := tmp1 + 1)) == arg2 ] whileFalse: [ tmp2 := tmp2 + tmp3 height ].  self position: arg1 - (2 @ (tmp2 + 8)).  self right > arg3 worldBounds right ifTrue: [ self right: arg1 x + 1 ].  tmp4 := self bounds amountToTranslateWithin: (arg3 worldBounds withHeight: (arg3 worldBounds height - 18 max: ActiveHand position y + 1)).  tmp4 = (0 @ 0) ifFalse: [ self position: self position + tmp4 ]resizerWidth  ^resizerWidth ifNil: [ resizerWidth := 3 ]withSiblingsDo: arg1  | tmp1 |  tmp1 := self.  [ tmp1 isNil ] whileFalse: [ arg1 value: tmp1.        tmp1 := tmp1 nextSibling ]enableFilterWithAction: arg1 named: arg2  function := FTFilterFunctionWithAction table: self action: arg1 named: arg2.  self explicitFunctionmakeLastColumnBounded  self lastColumnBounded ifFalse: [ unboundLastColumn := false.        self columnsChanged ]handlesKeyboard: arg1  ^truecolumns: arg1  columns := arg1drawOn: arg1  | tmp1 |  arg1 fillRectangle: self bounds fillStyle: self fillStyle borderStyle: self borderStyle.  tmp1 := self imageToUse.  tmp1 ifNotNil: [ arg1 translucentImage: tmp1 at: self innerBounds center - (tmp1 extent // 2) ].  ((self state == #pressed or: [ self state == #repressed ]) and: [ image isNil ]) ifTrue: [ arg1 fillRectangle: self innerBounds fillStyle: (self paneColor alpha: 0.3) ].  (self enabled not and: [ self theme fadeCheckboxWhenDisabled ]) ifTrue: [ arg1 fillRectangle: self innerBounds fillStyle: (self paneColor alpha: 0.4) ]scrollDownByPageDelta  self scrollDown: self pageDeltaadhereToEdge: arg1  | tmp1 |  (owner isNil or: [ owner isHandMorph ]) ifTrue: [ ^self ].  (owner class canUnderstand: arg1) ifFalse: [ ^self ].  (self class canUnderstand: (tmp1 := (arg1 , ':') asSymbol)) ifFalse: [ ^self ].  self perform: tmp1 withArguments: (Array with: (owner perform: arg1))layoutMenuPropertyString: arg1 from: arg2  | tmp1 |  tmp1 := String streamContents: [:arg3 |  | tmp2 |        tmp2 := 1.        arg1 keysAndValuesDo: [:arg4 :arg5 |  arg5 isUppercase ifTrue: [ arg3 nextPutAll: (arg1 copyFrom: tmp2 to: arg4 - 1) asLowercase.                    arg3 nextPutAll: ' '.                    tmp2 := arg4 ] ].        tmp2 < arg1 size ifTrue: [ arg3 nextPutAll: (arg1 copyFrom: tmp2 to: arg1 size) asLowercase ] ].  ^(arg1 == arg2) -> tmp1 translatednewIncrementalSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newIncrementalSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8labelString: arg1  label ifNil: [ self label: arg1 ] ifNotNil: [ label contents: arg1.        self fitContents ]max: arg1  endValue := arg1minExtentOf: arg1 in: arg2  | tmp1 tmp2 |  cachedMinExtent ifNotNil: [ ^cachedMinExtent ].  arg1 submorphs ifEmpty: [ ^0 @ 0 ].  tmp2 := 0 @ 0.  cachedMinExtents := arg1 submorphs collect: [:arg3 |  tmp1 := arg3 minExtent.        tmp2 := tmp2 max: tmp1.        tmp1 ].  ^cachedMinExtent := tmp2hScrollBarWidth  | tmp1 |  tmp1 := bounds width - (2 * borderWidth).  self vIsScrollbarNeeded ifTrue: [ tmp1 := tmp1 - self scrollBarThickness ].  ^tmp1makeSecondTopmost  | tmp1 |  tmp1 := self world.  tmp1 submorphs detect: [:arg1 |  arg1 isSystemWindow and: [ arg1 ~~ self ] ] ifFound: [:arg2 |  arg2 activate.        tmp1 addMorph: self behind: arg2 ]currentWindow  ^self class environment at: #SystemWindow ifPresent: [:arg1 |  arg1 topWindow ]cellSpacing  ^#nonedate: arg1  | tmp1 |  tmp1 := date isNil or: [ date month ~= arg1 month ].  date := arg1.  tmp1 ifTrue: [ self computeDays ]listCentering  ^listCenteringenabled: arg1  arg1 ifTrue: [ self color: self defaultColor ] ifFalse: [ self color: self theme disabledTextColor ]deleteSelectedTabs  toolbar selectedTab ifNotNil: [ toolbar deleteSelectedTabs ] ifNil: [ self owner takeKeyboardFocus ]newRow: arg1  ^self theme newRowIn: self for: arg1initWithContents: arg1 font: arg2 emphasis: arg3  super initWithContents: arg1 font: arg2 emphasis: arg3.  self     disabledStyle: #plain;     enabled: truehighlightSelection  rotationDegrees  ^0.0textEntry: arg1 title: arg2  ^self textEntry: arg1 title: arg2 entryText: ''updateChildrenRecursively  self childrenDo: [:arg1 |  arg1 parent: self.        arg1 updateChildrenRecursively ]submorphsDo: arg1  submorphs do: arg1menuBuilder  ^menuBuilder ifNil: [ menuBuilder := PragmaMenuBuilder pragmaKeyword: self discoveredMenuPragmaKeyword model: self ]selectedDisabledBorderStyle  ^self theme buttonSelectedDisabledBorderStyleFor: selfdisplayBounds  ^self layoutPosition extent: self cachedForm extentupdateUpButtonBounds  upButton bounds: (self theme scrollBarUpButtonBoundsFor: self)showCaret  ^showCaret ifNil: [ true ]makeLastColumnUnbounded  unboundLastColumn := trueiconButtonCalling: arg1 withForm: arg2 helpText: arg3  ^IconicButton new     target: self;     actionSelector: arg1;     labelGraphic: arg2;     color: Color transparent;     extent: self boxExtent;     borderWidth: 0;     helpText: arg3 translated;     yourselfextendByHand: arg1  | tmp1 tmp2 |  tmp1 := self position.  tmp2 := NewHandleMorph new followHand: arg1 forEachPointDo: [:arg2 |  | tmp3 |        tmp3 := (self transformFrom: self world) globalPointToLocal: arg2.        self bounds: (tmp1 rectangle: tmp3) ] lastPointDo: [:arg2 |  selectedItems isEmpty ifTrue: [ self delete ] ifFalse: [ selectedItems size = 1 ifTrue: [ self delete.                    selectedItems anyOne addHalo ] ifFalse: [ self doneExtending ] ] ].  arg1 attachMorph: tmp2.  tmp2 startSteppinglastSubmorph  ^submorphs lastwantsToBeDroppedInto: arg1  ^truesharesFindReplace  ^trueabort: arg1  ^self abort: arg1 title: 'Error' translatedhandleFocusEvent: arg1  self processEvent: arg1.  (arg1 isMouse and: [ arg1 isMouseDown and: [ (self fullContainsPoint: arg1 position) not ] ]) ifFalse: [ ^super handleFocusEvent: arg1 ].  self eventHandler ifNotNil: [ self eventHandler mouseDown: arg1 fromMorph: self ]counter: arg1  counter := arg1isSoleItem  ^self isFirstItem and: [ owner submorphs size = 1 ]mouseEnterDragging: arg1  | tmp1 |  (arg1 hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: arg1 ].  (self wantsDroppedMorph: arg1 hand firstSubmorph event: arg1) ifTrue: [ tmp1 := self scrollerSubMorphFromPoint: arg1 position.        tmp1 ifNotNil: [ self potentialDropMorph: tmp1 ].        arg1 hand newMouseFocus: self ]dropItemSelector  ^dropItemSelectorstartSteppingSelector: arg1  self startStepping: arg1 at: Time millisecondClockValue arguments: nil stepTime: nilhasOwner: arg1  arg1 ifNil: [ ^true ].  self allOwnersDo: [:arg2 |  arg2 = arg1 ifTrue: [ ^true ] ].  ^falsecheckForNewScreenSize  Display extent = DisplayScreen actualScreenSize ifTrue: [ ^Display ].  Display setExtent: self actualScreenSize depth: 32.  Display beDisplay.  world worldState realWindowExtent: self actualScreenSize.  world restoreMorphicDisplaytaskList  ^self submorphs detect: [:arg1 |  arg1 isKindOf: TaskListMorph ] ifNone: [ NullTaskList in: self ]externalName: arg1  externalName := arg1selectLast  self subclassResponsibilityinitialize  super initialize.  waitingForClickInside := truecontentsAsIs: arg1  wrapFlag := false.  container ifNotNil: [ container fillsOwner ifTrue: [ wrapFlag := true ] ].  self newContents: arg1unhighlight  complexContents highlightingColor ifNotNil: [ self color: self theme textColor ].  self changedrestoreMainDockingBarDisplay  self dockingBars do: [:arg1 |  arg1 updateBounds ]triggerAlarmsBefore: arg1  | tmp1 |  lastAlarmTime ifNil: [ lastAlarmTime := arg1 ].  (arg1 < lastAlarmTime or: [ arg1 - lastAlarmTime > 10000 ]) ifTrue: [ self adjustAlarmTimes: arg1 ].  tmp1 := self alarms.  [ tmp1 isEmpty not and: [ tmp1 first scheduledTime < arg1 ] ] whileTrue: [ tmp1 removeFirst value: arg1 ].  lastAlarmTime := arg1matchingFilter: arg1  ((arg1 children collect: [:arg2 |  self matchingFilter: arg2 ]) reject: #isNil) ifNotEmpty: [:arg3 |  ^(self newStaticItemFrom: arg1)           children: arg3 asArray;           dataSource: arg1 dataSource;           expandWithoutChange;           yourself ].  ^(pattern matchesIn: (self dataSource toString: arg1)) ifEmpty: [ nil ] ifNotEmpty: [ self newStaticItemFrom: arg1 ]startDrag: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlerslayout: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 |  arg1 hasSubmorphs ifFalse: [ ^self ].  properties := arg1 assureTableProperties.  tmp4 := arg2 origin asIntegerPoint corner: arg2 corner asIntegerPoint.  (properties wrapDirection == #none and: [ properties cellSpacing == #none ]) ifTrue: [ properties listCentering == #justified ifFalse: [ properties listDirection == #leftToRight ifTrue: [ ^self layoutLeftToRight: arg1 in: tmp4 ].              properties listDirection == #topToBottom ifTrue: [ ^self layoutTopToBottom: arg1 in: tmp4 ] ] ].  tmp3 := (properties listDirection == #topToBottom or: [ properties listDirection == #bottomToTop ]) not.  tmp1 := self computeCellSizes: arg1 in: (0 @ 0 corner: tmp4 extent) horizontal: tmp3.  tmp2 := self computeCellArrangement: tmp1 in: tmp4 horizontal: tmp3 target: arg1.  self computeExtraSpacing: tmp2 in: tmp4 horizontal: tmp3 target: arg1.  self placeCells: tmp2 in: tmp4 horizontal: tmp3 target: arg1newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newListIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: arg5 help: arg6shadowOffset  ^6 @ 8scrollBarThickness  ^self theme scrollbarThicknessdataSourceForTesting  ^FTTableMorph new     dataSource: (FTSimpleDataSource elements: self elementsForTestDataSource);     dataSourcetoggleExpandedState  | tmp1 |  self isExpanded: self isExpanded not.  tmp1 := OrderedCollection new.  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg1 |  arg1 recursiveAddTo: tmp1 ] ].  container noteRemovalOfAll: tmp1.  (isExpanded and: [ complexContents hasContents ]) ifFalse: [ ^self changed ].  self expandtopFraction: arg1 offset: arg2  topFraction := arg1.  topOffset := arg2beRadioButton  self     isRadioButton: true;     onImage: self theme radioButtonMarkerForm;     cornerStyle: (self theme radioButtonCornerStyleFor: self);     fillStyle: self fillStyleToUse;     borderStyle: self borderStyleToUseupdate: arg1  arg1 = getEnabledSelector ifTrue: [ ^self updateEnabled ].  arg1 = getValueSelector ifTrue: [ ^self updateValue ].  arg1 = getLabelSelector ifTrue: [ ^self updateLabel ].  arg1 isArray ifFalse: [ ^self ].  arg1 size == 2 ifFalse: [ ^self ].  arg1 first = #max: ifTrue: [ self max: arg1 second ].  arg1 first = #min: ifTrue: [ self min: arg1 second ].  arg1 first = #quantum: ifTrue: [ self quantum: arg1 second ].  arg1 first = #scaledValue: ifTrue: [ self scaledValue: arg1 second ].  arg1 first = #value: ifTrue: [ self value: arg1 second ]rotationDegrees: arg1  initializeOwner: arg1 keyText: arg2  self initialize.  owner := arg1.  keyText := self class normalize: arg2handlesKeyboard: arg1  (super handlesKeyboard: arg1) ifTrue: [ ^true ].  ^arg1 anyModifierKeyPressed and: [ arg1 keyCharacter = Character arrowLeft or: [ arg1 keyCharacter = Character arrowRight or: [ arg1 keyCharacter = Character delete or: [ arg1 keyCharacter = $w or: [ arg1 keyCharacter = Character tab ] ] ] ] ]addUpAction: arg1  upAction := arg1fallbackMenuOn: arg1  arg1 addTitle: 'Fallback menu'.  arg1 commandKeyHandler: self.  arg1 addLine.  arg1     defaultTarget: Smalltalk tools;     addList: Smalltalk tools menuItems.  arg1 addLine.  arg1 add: 'Save' target: self class selector: #saveSession.  arg1 add: 'Save as...' target: self class selector: #saveAs.  arg1 add: 'Save and quit' target: self class selector: #saveAndQuit.  arg1 add: 'Quit' target: self class selector: #quitSessiontarget: arg1  target := arg1sensitiveToggleRectangle  ^(bounds left + self indentGap) @ bounds top extent: (container toggleImageWidth + container gapAfterToggle) @ bounds heightinform: arg1 to: arg2 originatedFrom: arg3 ifNotFocusedDo: arg4  ^(self is: arg3 withFocusOver: arg2) ifTrue: [ self transform: arg1 from: arg3 andSendTo: arg2 ] ifFalse: arg4visible: arg1  self needsToBeDrawn ifFalse: [ ^self ].  super visible: arg1drawOn: arg1  | tmp1 |  tmp1 := self horizontal ifTrue: [ self bounds insetBy: (2 @ 1 corner: 2 @ 1) ] ifFalse: [ self bounds insetBy: (1 @ 2 corner: 1 @ 2) ].  arg1     drawPolygon: (self leftOrTopVertices: self bounds) fillStyle: self borderColor;     drawPolygon: (self leftOrTopVertices: tmp1) fillStyle: self fillStyle;     drawPolygon: (self rightOrBottomVertices: self bounds) fillStyle: self borderColor;     drawPolygon: (self rightOrBottomVertices: tmp1) fillStyle: self fillStyleresizeWidget  self subclassResponsibilityhasSeveralPages  ^self lastPage > 1embeddedWindowOrNil  ^selftestIndexFromPosition  self assert: (strategy indexFromPosition: #(3 7)) equals: 3activate  alreadyActivated ifTrue: [ ^self ].  self doActivate.  alreadyActivated := truenewEditableDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: arg6 default: arg7 ghostText: arg8 getEnabled: arg9 useIndex: arg10 help: arg11  ^self theme newEditableDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: arg6 default: arg7 ghostText: arg8 getEnabled: arg9 useIndex: arg10 help: arg11current: arg1  bar value: arg1.  self changedinitializeTable: arg1  self initialize.  self cellInset: arg1 intercellSpacing.  self flag: #pharoTodooffImageSelector: arg1  offImageSelector := arg1computeAltRaisedColors  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self color asColor.  tmp2 := Color white.  tmp3 := Color black.  tmp4 := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  tmp4 := tmp4 asInteger.  tmp5 := Array new: tmp4 * 2.  tmp7 := 0.5 / tmp4.  0 to: tmp4 - 1 do: [:arg1 |  tmp6 := false ifTrue: [ 0.5 + (tmp7 * arg1) ] ifFalse: [ 0.5 + (tmp7 * (tmp4 - arg1)) ].        tmp5 at: arg1 + 1 put: (tmp1 mixed: tmp6 with: tmp2).        tmp5 at: tmp5 size - arg1 put: (tmp1 mixed: tmp6 with: tmp3) ].  ^tmp5prepareForRotating  ^self addFlexShellstopStepping: arg1 selector: arg2  worldState stopStepping: arg1 selector: arg2sortingIcon  ^self subclassResponsibilityclearTarget  target := nilavailableFillStyles  ^#(normalFillStyle mouseOverFillStyle pressedFillStyle disabledFillStyle selectedFillStyle selectedPressedFillStyle selectedMouseOverFillStyle selectedDisabledFillStyle)newButtonLabel: arg1  ^self newButtonLabelFor: nil label: arg1 getEnabled: nilinitializeAnnouncements  self     on: #mouseEnter send: #taskbarButtonEntered:event:in: to: self model withValue: self;     on: #mouseLeave send: #taskbarButtonLeft:event:in: to: self model withValue: selflineColor: arg1  ^lineColor := arg1dragItemSelector  ^dragItemSelectorrotationDegrees: arg1  freshListTab  < haltOrBreakpointForTesting>  ^(TabMorph label: 'Fresh List' icon: nil retrievingBlock: [ 1 second asDelay wait.        SpListPresenter new           items: (1 to: 50) asOrderedCollection;           buildWithSpec ] actions: {(TabAction action: [ self halt ] icon: (self iconNamed: #smallConfigurationIcon) label: 'Halt!')})     menu: [:arg1 |  arg1 add: 'Fubu' target: self selector: #halt ];     yourselfrealSearch  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := 0.  dataSource rootsItems do: [:arg1 |  1 to: arg1 numberOfVisibleChildren + 1 do: [:arg2 |  | tmp3 |              tmp3 := arg1 selfOrChildAt: arg2.              (self isMatching: tmp3) ifTrue: [ tmp1 add: arg2 + tmp2 ] ].        tmp2 := tmp2 + (arg1 numberOfVisibleChildren + 1) ].  ^tmp1 asArrayforwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1contents  ^self childrenItems collect: [:arg1 |  self childNodeFromItem: arg1 ]mouseDown: arg1  dropEnabled: arg1  ^self enableDrop: arg1drawOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  super drawOn: arg1.  tmp4 := self bounds.  selectedItems do: [:arg2 |  tmp4 := tmp4 merge: arg2 fullBounds ].  tmp4 := tmp4 expandBy: 1.  tmp1 := Display defaultCanvasClass extent: tmp4 extent depth: 8.  tmp1 translateBy: tmp4 topLeft negated during: [:arg3 |  selectedItems do: [:arg2 |  arg3 fullDrawMorph: arg2 ] ].  tmp2 := (Form extent: tmp4 extent) copyBits: (0 @ 0 extent: tmp4 extent) from: tmp1 form at: 0 @ 0 colorMap: (Color maskingMap: 8).  tmp3 := Form extent: tmp4 extent.  (0 @ 0) fourNeighbors do: [:arg4 |  tmp2 displayOn: tmp3 at: arg4 rule: Form under ].  tmp2 displayOn: tmp3 at: 0 @ 0 rule: Form erase.  arg1 stencil: tmp3 at: tmp4 topLeft sourceRect: tmp3 boundingBox color: self borderColormouseWheel: arg1  arg1 isUp ifTrue: [ self verticalScrollBar scrollRestrictedUp: 3.        ^self ].  arg1 isDown ifTrue: [ self verticalScrollBar scrollRestrictedDown: 3.        ^self ].  super mouseWheel: arg1withTreeLines  ^self treeLineWidth > 0fullDrawOnAthensCanvas: arg1  self visible ifFalse: [ ^self ].  (arg1 isVisible: self fullBounds) ifFalse: [ ^self ].  (self hasProperty: #errorOnDraw) ifTrue: [ ^self ].  (arg1 isVisible: self bounds) ifTrue: [ arg1 draw: self ].  submorphs isEmpty ifTrue: [ ^self ].  self drawSubmorphsOnAthensCanvas: arg1selectedMouseOverFillStyle  ^self theme buttonSelectedMouseOverFillStyleFor: selftestDoubleClickTimeoutFromMorph  morph eventHandler on: #doubleClickTimeout send: #value to: true.  self assert: (morph doubleClickTimeout: nil) identicalTo: trueremoveCornerGrips  | tmp1 |  tmp1 := self submorphsSatisfying: [:arg1 |  arg1 isKindOf: CornerGripMorph ].  tmp1 do: [:arg1 |  arg1 delete ]chooseColor: arg1  ^self theme chooseColorIn: self title: 'Colour Selector' translated color: arg1imageRectangleFromDisplayRectangle: arg1  | tmp1 |  tmp1 := self displayBounds.  tmp1 area = 0 ifTrue: [ ^tmp1 ].  self layout == #scaledAspect ifTrue: [ ^((arg1 translateBy: self layoutPosition negated) scaleBy: self form width / tmp1 width) rounded ].  self layout == #scaled ifTrue: [ ^((arg1 translateBy: self layoutPosition negated) scaleBy: (self form width / tmp1 width) @ (self form height / tmp1 height)) rounded ].  ^self scale = 1 ifTrue: [ arg1 translateBy: self layoutPosition negated ] ifFalse: [ ((arg1 translateBy: self layoutPosition negated) scaleBy: 1 / self scale) rounded ]basicKeyPressed: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  (arg1 == Character space and: [ lastClickedMorph notNil ]) ifTrue: [ self selectMorph: lastClickedMorph multiple: (self isMultiple or: [ self autoMultiSelection ]).        self selectionUpdateFromViewWhile: [ | tmp6 |              tmp6 := self newSelectionHolderWithNodePath: lastClickedMorph complexContents path.              self listModel selection: tmp6 ] ].  tmp1 := tmp2 := lastSelection.  tmp3 := Time millisecondClockValue.  tmp4 := tmp3 - lastKeystrokeTime > 500.  lastKeystrokeTime := tmp3.  self searchedElement: nil.  tmp4 ifTrue: [ tmp2 := tmp2 + 1.        lastKeystrokes := arg1 asLowercase asString ] ifFalse: [ lastKeystrokes := lastKeystrokes , arg1 asLowercase asString ].  tmp2 isZero ifFalse: [ tmp5 := self allNodeMorphs detect: [:arg2 |  arg2 index >= tmp2 and: [ arg2 complexContents asString trimBoth asLowercase beginsWith: lastKeystrokes ] ] ifNone: [ tmp2 := 0 ] ].  tmp2 isZero ifTrue: [ tmp5 := self allNodeMorphs detect: [:arg2 |  arg2 complexContents asString trimBoth asLowercase beginsWith: lastKeystrokes ] ifNone: [ ^self ] ].  tmp1 := tmp5 index.  self listModel okToChange ifFalse: [ ^self ].  self searchedElement: tmp5.  lastSelection := tmp1.  self scrollToShow: tmp5 contentBounds.  self selectionChangedmodalUnlockFrom: arg1  | tmp1 |  tmp1 := self valueOfProperty: #submorphLockStates ifAbsent: [ ^self ].  self removeProperty: #submorphLockStates.  tmp1 keysAndValuesDo: [:arg2 :arg3 |  arg3 ifFalse: [ arg2 unlock ] ]resetDamageRecorder  damageRecorder resetvalue  ^self getValueSelector ifNil: [ (self sliderMorph ifNil: [ ^0 ]) scaledValue ] ifNotNil: [ self model ifNil: [ (self sliderMorph ifNil: [ ^0 ]) scaledValue ] ifNotNil: [ self model perform: self getValueSelector ] ]hUnadjustedScrollRange  maxWidth ifNotNil: [ ^maxWidth ].  listItems isEmpty ifTrue: [ ^0 ].  maxWidth := 0.  listItems do: [:arg1 |  arg1 ifNotNil: [ maxWidth := maxWidth max: (arg1 widthToDisplayInList: self) ] ].  ^maxWidthpaddingWidth: arg1  paddingWidth := arg1stepTime  drawTime ifNil: [ ^250 ].  ^20 * drawTime max: 250handleKeystroke: arg1  arg1 wasHandled ifTrue: [ ^self ].  self shortcutsHandler ifNotNil: [:arg2 |  arg2 handleKeystroke: arg1 inMorph: self.        arg1 wasHandled ifTrue: [ ^self ] ].  (self handlesKeyStroke: arg1) ifFalse: [ ^self ].  arg1 wasHandled: true.  self keyStroke: arg1.  ^self eventHandler ifNotNil: [:arg2 |  arg2 keyStroke: arg1 fromMorph: self ]shortcutCharacter  ^shortcutCharacterinvokeWorldMenuFromEscapeKey  self invokeWorldMenu: ActiveEventdisplayWorldSafely: arg1  [ arg1 displayWorld ] ifError: [:arg2 :arg3 |  | tmp1 tmp2 |        tmp1 := thisContext.        [ tmp1 := tmp1 sender.        [ tmp1 notNil and: [ tmp1 receiver isMorph not ] ] whileTrue: [ tmp1 := tmp1 sender ].        tmp1 ifNil: [ ^self handleFatalDrawingError: arg2 ].        tmp2 := tmp1 receiver.        tmp2 hasProperty: #errorOnDraw ] whileTrue.        tmp2 setProperty: #errorOnDraw toValue: true.        arg3 error: arg2 ]isAdheringToTop  ^self edgeToAdhereTo == #toplistDirection  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #topToBottom ] ifNotNil: [ tmp1 listDirection ]setWindowColor  (UIManager default chooseColor: self paneColor) ifNotNil: [:arg1 |  self setWindowColor: arg1 ]enabled: arg1  self isEnabled: arg1gridVisibleOnOff  self setProperty: #gridVisible toValue: self gridVisible not.  self changedupdateView: arg1 forModel: arg2  arg1 updateFromSelection: self.  arg2 selectionChangedcellColumn: arg1 row: arg2  arg1 id = '#' ifTrue: [ ^FTCellMorph new addMorph: arg2 asMorph ].  arg1 id = 'Name' ifTrue: [ ^self nameColumn: arg1 row: arg2 ].  arg1 id = 'Protocol' ifTrue: [ ^self protocolColumn: arg1 row: arg2 ].  arg1 id = 'Origin' ifTrue: [ ^self originColumn: arg1 row: arg2 ].  self error: 'Invalid column'fillStyleToUse  ^self isRadioButton ifTrue: [ self radioFillStyleToUse ] ifFalse: [ self checkboxFillStyleToUse ]newLabelMorph: arg1  ^TabLabelMorph new     roundedCorners: #(1 4);     cornerStyle: self cornerStyle;     changeTableLayout;     listDirection: #leftToRight;     listCentering: #center;     layoutInset: (self theme tabLabelInsetFor: self);     hResizing: #shrinkWrap;     vResizing: #spaceFill;     label: arg1;     font: self font;     on: #mouseDown send: #tabClicked:with: to: self;     tabSelector: selfnewGroupbox  ^self theme newGroupboxIn: selfopenModal: arg1  arg1     theme: self theme;     setWindowColor: self paneColor.  ^super openModal: arg1balloonText  ^self target perform: balloonTextSelectormaxCellSize: arg1  maxCellSize := arg1keyDown: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #keyDown from: arg2mouseDownRow  ^self listMorph mouseDownRowselectionBorderStyle  ^self theme menuItemInDockingBarSelectedBorderStyleFor: selfdate  ^datecomputedHeightFromContents  | tmp1 |  tmp1 := 0.  self submorphsDo: [:arg1 |  tmp1 := tmp1 max: arg1 height ].  ^tmp1 max: self preferedFont height + 8font  ^fontpinColor  ^owner stayUp ifTrue: [ Color gray lighter ] ifFalse: [ Color black ]viewBox  ^worldState viewBoxroundedCorners  ^self valueOfProperty: #roundedCorners ifAbsent: [ #(1 2 3 4) ]deleteIfPopUp: arg1  stayUp ifFalse: [ self topRendererOrSelf delete ].  popUpOwner notNil ifTrue: [ popUpOwner isSelected: false.        popUpOwner deleteIfPopUp: arg1 ].  arg1 ifNotNil: [ arg1 hand releaseMouseFocus: self ]enabled  ^enabledisMouse  ^falsechooseSmoothing  smoothing := (self scale < 1.0 or: [ self angle ~= (self angle roundTo: Float pi / 2.0) ]) ifTrue: [ 2 ] ifFalse: [ 1 ]color  ^complexContents color ifNil: [ self index ifNotNil: [ container rowColors at: self index \\ 2 + 1 ] ]nextPage  | tmp1 |  nextPageAllowed ifTrue: [ [ nextPageAllowed := false.        pageSizeEditor ifNotNil: [ pageSizeEditor acceptTextInModel ].        self changed: #pageSize.        treeMorph scroller hasSubmorphs ifTrue: [ tmp1 := treeMorph scroller lastSubmorph ].        self nextPage: (self lastIndex + pageSize min: self nodeList size).        tmp1 ifNotNil: [ | tmp2 tmp3 |              tmp3 := (treeMorph bounds: treeMorph innerBounds in: self world) bottom - treeMorph vExtraScrollRange.              tmp2 := tmp1 boundsInWorld bottom.              treeMorph scrollBy: 0 @ (tmp3 - tmp2) ].        self buildPanel ] ensure: [ nextPageAllowed := true ] ]addMorphsTo: arg1 from: arg2 withExpandedItems: arg3 atLevel: arg4  | tmp1 tmp2 |  tmp1 := nil.  tmp2 := nil.  arg2 doWithIndex: [:arg5 :arg6 |  tmp1 := self indentingItemClass new initWithContents: arg5 prior: tmp1 forList: self indentLevel: arg4.        tmp2 ifNil: [ tmp2 := tmp1 ].        arg1 add: tmp1.        ((arg5 hasEquivalentIn: arg3) or: [ tmp1 isExpanded ]) ifTrue: [ tmp1 isExpanded: true.              tmp1 addChildrenForList: self addingTo: arg1 withExpandedItems: arg3 ] ].  ^tmp2handlesKeyUp: arg1  ^self handlesKeyboard: arg1message: arg1  ^self message: arg1 title: 'Information' translatedtext  ^keyTextquestionWithoutCancel: arg1 title: arg2  ^self theme questionWithoutCancelIn: self text: arg1 title: arg2bounds: arg1  | tmp1 tmp2 |  tmp1 := self extent.  tmp2 := arg1 extent.  (tmp1 dotProduct: tmp1) <= (tmp2 dotProduct: tmp2) ifTrue: [ self           position: arg1 topLeft;           extent: tmp2 ] ifFalse: [ self           extent: tmp2;           position: arg1 topLeft ]whenReturnInFilter: arg1  patternModel acceptEditsInViewreturnPressed  (self defaultButton ifNil: [ ^self ]) performActionselectionModeStrategy: arg1  selectionModeStrategy = arg1 ifTrue: [ ^self ].  selectionModeStrategy := arg1.  self initializeSelectedIndexesdefaultFillStyle  ^(GradientFillStyle colors: {(self color alpha: 0) .         self color})     origin: self topLeft;     direction: (self bounds isWide ifTrue: [ self width @ 0 ] ifFalse: [ 0 @ self height ])isProportionalLayout  ^falsedoubleClickTimeout: arg1  ^self eventHandler ifNotNil: [ self eventHandler doubleClickTimeout: arg1 fromMorph: self ]drawOn: arg1  state == #off ifTrue: [ offImage ifNotNil: [ arg1 translucentImage: offImage at: bounds origin ] ].  state == #pressed ifTrue: [ pressedImage ifNotNil: [ arg1 translucentImage: pressedImage at: bounds origin ] ].  state == #on ifTrue: [ image ifNotNil: [ arg1 translucentImage: image at: bounds origin ] ]nodeList  ^nodeList ifNil: [ nodeList := self getList ]drawRawColorOn: arg1 forSubmorph: arg2  | tmp1 tmp2 |  tmp2 := (arg2 fullBounds withWidth: owner scroller innerBounds width) translateBy: owner scroller offset x @ 0.  arg2 = owner listManager searchedElement ifTrue: [ arg1 fillRectangle: tmp2 color: owner secondarySelectionColor.        ^self ].  owner listManager isCheckList ifTrue: [ arg2 = owner listManager lastClickedMorph ifTrue: [ arg1 fillRectangle: tmp2 color: owner selectionColorToUse.              ^self ] ] ifFalse: [ arg2 selected ifTrue: [ arg1 fillRectangle: tmp2 color: owner selectionColorToUse.              ^self ] ].  (tmp1 := arg2 color) notNil ifTrue: [ tmp1 isColor ifTrue: [ arg1 frameAndFillRectangle: tmp2 fillColor: tmp1 borderWidth: 0 borderColor: Color transparent ] ifFalse: [ tmp1 origin: arg2 bounds topLeft.              tmp1 direction: arg2 bounds width @ 0.              arg1 fillRectangle: tmp2 basicFillStyle: tmp1 ] ]yellowButtonActivity: arg1  self wantsYellowButtonMenu ifFalse: [ ^false ].  (self getMenu: arg1) ifNotNil: [:arg2 |  arg2 setInvokingView: self editor.        arg2 invokeModal.        self changed.        ^true ].  ^truesliderThickness  ^self theme scrollbarMinimumThumbThicknessselectedColor  ^selectedColor ifNil: [ self color ]autoFitString  ^(self isAutoFit ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'text auto fit' translatedhorizontalScrollBarValue: arg1  horizontalScrollBar ifNotNil: [ self container adjustToHorizontalScrollBarValue: arg1 ]dataSource  ^dataSourceenableMouseCommands: arg1 withContextFrom: arg2  arg1 enableInMorph: self withCommandsFrom: arg2activeEnabledOverDownFillStyle: arg1  self stateMap atPath: #(active enabled over down) put: arg1.  self changedtarget  ^targetforwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]fillsOwner  ^container notNil and: [ container fillsOwner ]newTitle: arg1 for: arg2  ^self theme newTitleIn: self label: arg1 for: arg2addTitle  | tmp1 |  tmp1 := UIManager default request: 'Title for this menu?'.  tmp1 isEmptyOrNil ifTrue: [ ^self ].  self addTitle: tmp1drawMonthHeaderOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp2 := date asMonth printString.  tmp1 := self monthNameFont widthOfString: tmp2.  tmp3 := self bounds topLeft extent: self bounds width @ 23.  tmp5 := self bounds topCenter translateBy: (tmp1 // -2) @ 5.  tmp4 := tmp5 extent: tmp1 @ self monthNameFont height.  tmp7 := self monthNameFont widthOfString: self date monthName , ' '.  tmp6 := tmp4 topLeft extent: tmp7 @ tmp4 height.  tmp8 := tmp6 topRight corner: tmp4 bottomRight.  tmp9 := (self bounds topLeft translateBy: 10 @ 5) extent: 10 @ self monthNameFont height.  tmp10 := (self bounds topRight translateBy: -20 @ 5) extent: 10 @ self monthNameFont height.  touchPoints     at: tmp6 put: #handleMonthNameTouched;     at: tmp8 put: #handleYearTouched;     at: (tmp9 expandBy: 10 @ 5) put: #handlePreviousMonthTouched;     at: (tmp10 expandBy: 10 @ 5) put: #handleNextMonthTouched.  arg1     frameAndFillRectangle: tmp3 fillColor: Color veryLightGray borderWidth: 1 borderColor: Color black;     line: tmp3 bottomLeft to: tmp3 bottomRight width: 2 color: Color black;     drawString: '<' at: tmp9 origin font: self monthNameFont color: Color black;     drawString: '>' at: tmp10 origin font: self monthNameFont color: Color black;     drawString: tmp2 at: (self bounds topCenter translateBy: (tmp1 // -2) @ 5) font: self monthNameFont color: Color blackreferencePosition  ^referencePositioncopyTitle  Clipboard clipboardText: self label.  self inform: 'Window title copied.'listItemHeight  ^12textUpdated: arg1  newOKButtonFor: arg1 getEnabled: arg2  ^self theme newOKButtonIn: self for: arg1 getEnabled: arg2indentGap: arg1  indentGap := arg1buttonMorph: arg1  buttonMorph ifNotNil: [ self removeDependent: buttonMorph.        buttonMorph delete ].  buttonMorph := arg1.  self     addDependent: arg1;     addMorphFront: arg1choose: arg1  | tmp1 |  tmp1 := self itemWithWording: arg1.  tmp1 ifNil: [ self error: 'Menu does not have "' , arg1 , '" item' ].  tmp1 simulateClicksubmorphBounds  self hasSubmorphs ifFalse: [ ^nil ].  ^self firstSubmorph topLeft corner: owner scroller bounds bottomLeft + (0 @ owner extraScrollRange)fillStyle  ^self isOpen ifTrue: [ self borderColor ] ifFalse: [ super fillStyle ]minEnabled  ^self enabled and: [ self notAtMin ]defaultFillStyle  ^(GradientFillStyle colors: ((0.0 to: 359.9 by: 0.1) collect: [:arg1 |  Color h: arg1 s: 1.0 v: 1.0 ]))     origin: self topLeft;     direction: (self bounds isWide ifTrue: [ self width @ 0 ] ifFalse: [ 0 @ self height ])color: arg1  arg1 ifNil: [ ^self ].  (arg1 = self color and: [ self getModelState = self lastState ]) ifTrue: [ ^self ].  super color: arg1enabled  ^enabled ifNil: [ enabled := true ]sortableUsing: arg1  self sortingStrategy: (FTSortFunctionColumnSortingStrategy column: self sortFunction: arg1)resizeScrollBars  self     vResizeScrollBar;     hResizeScrollBargetListElementSelector: arg1  self basicGetListElementSelector: arg1.  list := nil.  self updateListmenu: arg1 shifted: arg2  arg1 add: 'Browse (b)' target: self selector: #browseItem.  arg1 add: 'Inspect (i)' target: self selector: #inspectItem.  arg1 add: 'Explore (I)' target: self selector: #exploreItemthemeChanged  (self theme desktopImageFor: self) ifNotNil: [:arg1 |  self color: Color white.        self backgroundImage: arg1 layout: self theme desktopImageLayout ].  super themeChangedasDraggableMorph  ^selfaddMorphInLayer: arg1  submorphs do: [:arg2 |  arg2 == arg1 ifTrue: [ ^self ].        arg1 morphicLayerNumber < arg2 morphicLayerNumber ifTrue: [ ^self addMorph: arg1 inFrontOf: arg2 ] ].  self addMorphBack: arg1printOn: arg1  super printOn: arg1.  submorphs isEmpty ifTrue: [ arg1 nextPutAll: ' with no transformee!' ] ifFalse: [ arg1 nextPutAll: ' on ' , submorphs first printString ]selectionFrameForRow: arg1  | tmp1 |  tmp1 := self drawBoundsForRow: arg1.  tmp1 := tmp1 expandBy: self cellInset // 2.  self cellInset odd ifTrue: [ tmp1 := tmp1 bottom: tmp1 bottom + 1 ].  tmp1 := tmp1 intersect: self bounds ifNone: [ self error: 'should not happen' ].  tmp1 := self bounds: tmp1 in: listSource.  tmp1 := self bounds: ((tmp1 left: listSource innerBounds left) right: listSource innerBounds right) from: listSource.  ^tmp1initializeContainer: arg1 left: arg2 right: arg3  self initialize.  self width: self class resizerWidth.  container := arg1.  leftColumn := arg2.  rightColumn := arg3initializeScrollBars  verticalScrollBar := ScrollBar new     model: self;     setValueSelector: #verticalScrollBarValue:;     yourself.  self addMorph: verticalScrollBar.  horizontalScrollBar ifNotNil: [ horizontalScrollBar := ScrollBar new           model: self;           setValueSelector: #horizontalScrollBarValue:;           yourself.        self addMorph: horizontalScrollBar ]borders: arg1  borders := arg1drawOnAthensCanvas: arg1  | tmp1 |  tmp1 := self horizontal ifTrue: [ self bounds insetBy: (2 @ 1 corner: 2 @ 1) ] ifFalse: [ self bounds insetBy: (1 @ 2 corner: 1 @ 2) ].  arg1 setPaint: self borderColor.  arg1 drawShape: (self createClosedPolygonPathFrom: (self leftOrTopVertices: self bounds) on: arg1).  arg1 setPaint: self fillStyle.  arg1 drawShape: (self createClosedPolygonPathFrom: (self leftOrTopVertices: tmp1) on: arg1).  arg1 setPaint: self borderColor.  arg1 drawShape: (self createClosedPolygonPathFrom: (self rightOrBottomVertices: self bounds) on: arg1).  arg1 setPaint: self fillStyle.  arg1 drawShape: (self createClosedPolygonPathFrom: (self rightOrBottomVertices: tmp1) on: arg1)keyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self focusChangedtestSelectFirst  table selectFirst.  self assert: table selectedIndexes equals: #(#(1 1))testSelectableIndexAfter  self should: [ strategy selectableIndexAfter: 2 ] raise: ErroroutOfWorldCount  ^outOfWorldCountallowsKeymapping: arg1  ^self setProperty: #allowsKeymapping toValue: arg1rotationCenter  | tmp1 |  tmp1 := self referencePosition.  ^(tmp1 - self bounds origin) / self bounds extent asFloatPointbuttonFor: arg1  ^((self canDisplayChildrenOf: arg1) and: [ arg1 children isNotEmpty ]) ifTrue: [ arg1 generateButton ] ifFalse: [ self class emptyMorph ]isWorldMorph  ^falsepaneMorphs  ^paneMorphslistOfSteppingMorphs  ^stepList collect: [:arg1 |  arg1 receiver ]doOneCycleNowFor: arg1  self worldRenderer checkForNewScreenSize.  LastCycleTime := Time millisecondClockValue.  self handsDo: [:arg2 |  self activeHand: arg2.        arg2 processEvents.        self activeHand: nil ].  self activeHand: self hands first.  arg1 runStepMethods.  self displayWorldSafely: arg1initialize  super initialize.  self resetcomplexDataSourceForTesting  ^FTTableMorph new     dataSource: (FTSimpleDataSource elements: self complexElementsForTestDataSource);     dataSourcecursorPoint  ^positioncolors  ^colors ifNil: [ colors := self computeColors ]athensDrawBackgroundForSearchedRow: arg1 on: arg2  arg2 setPaint: listSource secondarySelectionColor.  arg2 drawShape: (self selectionFrameForRow: arg1)doubleClickOnSelectedText: arg1  self deselectlastSelection  ^lastSelectionhelpText  ^self balloonTextenabled: arg1  (state isEnabledMatchingTheState: arg1) ifTrue: [ ^self ].  state := state newStateForEnabled: arg1.  label enabled: arg1.  self changedon: arg1 list: arg2 selected: arg3 changeSelected: arg4 menu: arg5 keystroke: arg6  self model: arg1.  getListSelector := arg2.  getSelectionSelector := arg3.  setSelectionSelector := arg4.  getMenuSelector := arg5.  keystrokeActionSelector := arg6.  autoDeselect := true.  self borderWidth: 1.  self list: self getListbasicKeyPressed: arg1  ^selfdrawOnAthensCanvas: arg1  | tmp1 |  tmp1 := self bounds topLeft + self layoutInset.  arg1 pathTransform restoreAfter: [ arg1 pathTransform translateBy: tmp1.        self drawBackgroundOnAthensCanvas: arg1.        self drawIconAndLabelOnAthensCanvas: arg1.        self drawSubMenuMarkerOnAthensCanvas: arg1 ]unsortElements  self rootItem children: unsortedElements.  unsortedElements := nilshouldDropOnMouseUp  ^trueattachKeymapCategory: arg1 targetting: arg2  self kmDispatcher attachCategory: arg1 targetting: arg2createBox  | tmp1 |  tmp1 := IconicButton new.  tmp1     color: Color transparent;     target: self;     useSquareCorners;     borderWidth: 0.  ^tmp1canvas  ^nilchangeInSlopes: arg1 of: arg2  | tmp1 tmp2 |  tmp1 := arg2 size.  tmp1 = arg1 size ifFalse: [ ^self error: 'vertices and slopes differ in number' ].  tmp2 := Array new: tmp1.  1 to: tmp1 do: [:arg3 |  tmp2 at: arg3 put: ((arg2 atWrap: arg3 + 1) - (arg2 at: arg3)) * 3 - ((arg1 at: arg3) * 2) - (arg1 atWrap: arg3 + 1) ].  ^tmp2centered  textStyle centeredautoSize  ^autoSizethemeChanged  scrollBar theme: self theme.  hScrollBar theme: self theme.  super themeChangedextent: arg1  super extent: arg1.  worldState viewBox ifNotNil: [ worldState canvas: nil ]handlesMouseDown: arg1  ^truewantsKeyboardFocusFor: arg1  ^trueduplicateMorph: arg1  | tmp1 tmp2 |  tmp1 := self duplicate isSelected: false.  tmp2 := UIManager default newMenuIn: self for: nil.  tmp2 addMorphFront: tmp1.  tmp2 bounds: self bounds.  tmp2 stayUp: true.  arg1 hand grabMorph: tmp2 from: owner.  ^tmp2calculateColumnWidths  | tmp1 tmp2 tmp3 |  tmp3 := self table bounds width.  tmp2 := Array new: self table numberOfColumns withAll: 0.  self columnOrderOfWidthDistribution do: [:arg1 |  | tmp4 tmp5 |        tmp4 := self table columns at: arg1.        tmp5 := tmp4 acquireWidth: tmp3.        tmp2 at: arg1 put: tmp5.        tmp3 := tmp3 - tmp5 ].  tmp1 := tmp2 count: #isZero.  tmp1 isZero ifTrue: [ tmp2 size > 1 ifTrue: [ tmp2 at: tmp2 size put: tmp2 last + tmp3 ].        ^tmp2 ].  self columnOrderOfWidthDistribution do: [:arg1 |  (tmp2 at: arg1) = 0 ifTrue: [ tmp2 at: arg1 put: tmp3 / tmp1 ] ].  ^tmp2drawOnAthensCanvas: arg1  | tmp1 |  tmp1 := offImage.  state == #pressed ifTrue: [ tmp1 := pressedImage ].  state == #on ifTrue: [ tmp1 := image ].  tmp1 ifNil: [ ^self ].  arg1 setPaint: tmp1.  arg1 paintTransform restoreAfter: [ arg1 paintTransform translateBy: self innerBounds origin.        arg1 drawShape: self innerBounds ]forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]removeHand: arg1  (hands includes: arg1) ifFalse: [ ^self ].  hands := hands copyWithout: arg1.  activeHand == arg1 ifTrue: [ activeHand := nil ].  ActiveHand == arg1 ifTrue: [ ActiveHand := nil ]updateFromParagraph  super updateFromParagraph.  editView setScrollDeltaskeyStroke: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #keyStroke from: arg2selectAll  self subclassResponsibilitymouseEnter: arg1  self setProperty: #mouseEntered toValue: true.  self changed.  self color: (self color adjustBrightness: -0.09375).  super mouseEnter: arg1generateButton  ^isExpanded ifTrue: [ self expandedButton ] ifFalse: [ self collpasedButton ]selectedObject  ^self primaryHand selectedObjectstylingEnabled: arg1  updateList  | tmp1 |  tmp1 := self selectedItems.  self requestView: MorphTreeChangeRequest updateList.  self selectItems: tmp1leeway  ^0.1initialize  super initialize.  patternModel := RubScrolledTextModel new.  patternModel announcer when: RubTextUpdatedInModel send: #whenPatternChanged: to: self.  autoAccept := true.  ghostString := ''updatePosition  self owner ifNotNil: [:arg1 |  | tmp1 tmp2 tmp3 |        tmp1 := self edgeToAdhereTo.        tmp1 == #none ifTrue: [ self perform: (tmp1 , ':') asSymbol with: (arg1 perform: tmp1) ].        tmp2 := (self avoidVisibleBordersAtEdge ifTrue: [ self borderWidth ] ifFalse: [ 0 ]) asPoint.        self isAdheringToTop ifTrue: [ tmp3 := self usedHeightByPredominantDockingBarsOfChastes: #(#top).              self topLeft: arg1 topLeft - tmp2 + (0 @ tmp3) ].        self isAdheringToBottom ifTrue: [ tmp3 := self usedHeightByPredominantDockingBarsOfChastes: #(#bottom).              self bottomLeft: arg1 bottomLeft + (-1 @ 1 * tmp2) - (0 @ tmp3) ].        self isAdheringToLeft ifTrue: [ | tmp4 |              tmp3 := self usedHeightByPredominantDockingBarsOfChastes: #(#top).              tmp4 := self usedWidthByPredominantDockingBarsOfChastes: #(#left).              self topLeft: arg1 topLeft - tmp2 + (tmp4 @ tmp3) ].        self isAdheringToRight ifTrue: [ | tmp4 |              tmp3 := self usedHeightByPredominantDockingBarsOfChastes: #(#top).              tmp4 := self usedWidthByPredominantDockingBarsOfChastes: #(#right).              self topRight: arg1 topRight + (1 @ -1 * tmp2) + (tmp4 negated @ tmp3) ] ]click  (self handlesMouseDown: nil) ifTrue: [ self mouseDown: nil.        self mouseUp: nil ]aboutToBeGrabbedBy: arg1  super aboutToBeGrabbedBy: arg1.  self draggedMorph.  self formerPosition: self position.  arg1 newKeyboardFocus: selfdoDup: arg1 fromHalo: arg2 handle: arg3  selectedItems := selectedItems collect: #duplicate.  selectedItems do: [:arg4 |  self owner addMorph: arg4 ].  dupDelta ifNil: [ dupLoc := self position.        arg1 hand grabMorph: self.        arg2 removeAllHandlesBut: arg3 ] ifNotNil: [ dupLoc := nil.        self position: self position + dupDelta ]actWhen: arg1  actWhen := arg1newToolDockingBar  ^self theme newToolDockingBarIn: selfinitialize  super initialize.  self changeProportionalLayout.  self tabGroup: self newTabGroup.  self tabGroup tabSelectorMorph addDependent: self.  self     dropEnabled: true;     addMorph: self tabGroup fullFrame: LayoutFrame identity.  self tabGroup color: Color transparentborderStyle: arg1  | tmp1 |  self borderStyle = arg1 ifTrue: [ ^self ].  tmp1 := 2 * arg1 width + image extent.  bounds extent = tmp1 ifFalse: [ super extent: tmp1 ].  super borderStyle: arg1wantsHaloFor: arg1  ^falsepopUpFor: arg1 hand: arg2  balloonOwner := arg1.  self popUpForHand: arg2vSpaceFill  ^self flags anyMask: 2result: arg1  ^self result: arg1 from: nilmouseDown: arg1  super mouseDown: arg1.  self currentWindow ifNotNil: [:arg2 |  SystemWindow passivateTopWindow ]useFunction: arg1 do: arg2  function := arg1 table: self.  arg2 cull: function cull: selfpressedThumbBorderStyle  ^self theme scrollbarPressedThumbBorderStyleFor: selfaddLeftOrTop: arg1  leftOrTop add: arg1drawKeyboardFocusOn: arg1  self focusIndicatorMorph drawOn: arg1collapseRequest: arg1  arg1 nodes ifEmpty: [ ^self collapseAll ] ifNotEmpty: [:arg2 |  self collapseNodePath: arg2 ]newNoButtonFor: arg1  ^self theme newNoButtonIn: self for: arg1terminateFilterProcess  isEditingSemaphore ifNotNil: [ isEditingSemaphore terminateProcess ]initialize  super initialize.  self borderWidth: 3.  self extent: self extent + 2.  onColor := Color r: 1.0 g: 0.6 b: 0.6.  offColor := Color lightGray.  color := offColorroundedCorners: arg1  super roundedCorners: arg1.  self layoutInset: (self theme buttonLabelInsetFor: self)selectedRowIndex  self deprecated: 'Use #selectedIndex instead' transformWith: '`@receiver selectedRowIndex' -> '`@receiver selectedIndex'.  ^self selectedIndexdata: arg1  data := arg1isExpanded: arg1  isExpanded := arg1executeSortingOn: arg1  arg1 unsortdecrement  bar decrementfont  ^StandardFonts defaultFontgridSpec  ^self valueOfProperty: #gridSpec ifAbsent: [ 0 @ 0 extent: 8 @ 8 ]isDefault  ^truenewAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 font: arg5 help: arg6 entryCompletion: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 font: arg5 help: arg6 entryCompletion: arg7keyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self focusChangedcheckGap  ^2drawOn: arg1  self getListSize = 0 ifTrue: [ ^self ].  self setColumnWidthsFor: arg1.  self adjustWidth.  super drawOn: arg1window  ^selffocused: arg1  focused := arg1printNode: arg1  getLabelSelector ifNil: [ ^arg1 item printString ].  ^model perform: getLabelSelector with: arg1 itemfixupLastLineIfCR  (theText size > 0 and: [ CharacterSet crlf includes: theText last ]) ifFalse: [ ^self ].  self addNullLineForIndex: theText size + 1resetBlinkCursor  | tmp1 |  self blinkStart: Time millisecondClockValue + 500.  tmp1 := self paragraph ifNil: [ ^self ].  tmp1 showCaret = tmp1 focused ifFalse: [ tmp1 caretRect ifNotNil: [:arg1 |  self invalidRect: arg1 ].        tmp1 showCaret: tmp1 focused ]setExpandBoxBalloonText  expandBox ifNil: [ ^self ].  self unexpandedFrame ifNil: [ expandBox setBalloonText: 'Expand to full screen' translated ] ifNotNil: [ expandBox setBalloonText: 'Contract to original size' translated ]listForSearching  ^super listForSearching collect: #firstwantsHaloFromClick  ^falsemouseLeaveDragging: arg1  (self isTopWindow not and: [ arg1 hand hasSubmorphs ]) ifTrue: [ self lockInactivePortions.        arg1 hand removeMouseListener: self ]textColor: arg1  textColor := arg1isRootItem  ^self depth = 0setValue: arg1  arg1 >= 1.0 ifTrue: [ ^super setValue: 1.0 ].  ^super setValue: (arg1 roundTo: scrollDelta)initializeMethod: arg1  self initialize.  method := arg1extent: arg1  self extent = arg1 ifTrue: [ ^self ].  super extent: arg1.  self updatePagerdispatchKeystrokeForEvent: arg1  self kmDispatcher dispatchKeystroke: arg1invokeMetaMenu: arg1  | tmp1 |  self world ifNil: [ ^self ].  tmp1 := self buildMetaMenu: arg1.  self addTitleForHaloMenu: tmp1.  tmp1 popUpEvent: arg1 in: self worldstartDrag: arg1  | tmp1 tmp2 tmp3 |  self dragEnabled ifTrue: [ tmp2 := scroller submorphs detect: [:arg2 |  arg2 highlightedForMouseDown ] ifNone: [  ] ].  (tmp2 isNil or: [ arg1 hand hasSubmorphs ]) ifTrue: [ ^self ].  tmp2 highlightForMouseDown: false.  tmp2 ~= self selectedMorph ifTrue: [ self setSelectedMorph: tmp2 ].  tmp3 := self model dragPassengerFor: tmp2 inMorph: self.  tmp3 ifNotNil: [ tmp1 := self model transferFor: tmp3 from: self.        tmp1 align: tmp1 draggedMorph center with: arg1 position.        tmp1 dragTransferType: (self model dragTransferTypeForMorph: self).        arg1 hand grabMorph: tmp1 ].  arg1 hand releaseMouseFocus: selfsiblingSplitters  ^self owner submorphsSatisfying: [:arg1 |  (arg1 isKindOf: self class) and: [ self splitsTopAndBottom = arg1 splitsTopAndBottom and: [ arg1 ~= self ] ] ]multipleSelection  ^multipleSelection ifNil: [ multipleSelection := false ]testBoundingBoxOfSubmorphs  | tmp1 |  tmp1 := morph copy     topLeft: morph topLeft + 5;     yourself.  morph addMorph: tmp1.  self assert: morph boundingBoxOfSubmorphs equals: tmp1 boundsnewStack: arg1  ^self theme newStackIn: self for: arg1privateMoveBy: arg1  super privateMoveBy: arg1.  editor ifNil: [ paragraph ifNotNil: [ paragraph moveBy: arg1 ] ] ifNotNil: [ paragraph moveBy: arg1.        self installEditorToReplace: editor ]resetHighlightForDrop  self highlightForDrop: falsenewMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil useIndex: true help: arg5defaultFontFamiliyName  ^'Source Sans Pro'drawOnAthensCanvas: arg1  super drawOnAthensCanvas: arg1.  backgroundMorph ifNotNil: [ arg1 clipBy: self clippingBounds during: [ arg1 fullDrawMorph: backgroundMorph ] ]cornerStyle: arg1  super cornerStyle: arg1.  self tabSelectorMorph cornerStyle: arg1.  self contentMorph cornerStyle: arg1testOpenInWorld  morph openInWorldadhereToBottom  self adhereTo: #bottomselector  ^selectorsetOptimalResizing  self hResizing: #rigid.  self vResizing: #rigidtestDisableSort  column disableSort.  self deny: column isSortEnabledwhenPatternChanged: arg1  self updateListheader: arg1  header := arg1     clipSubmorphs: true;     yourself.  header model: selfinitialize  super initialize.  self initForEvents.  bounds := 0 @ 0 extent: Cursor normal extent.  damageRecorder := DamageRecorder new.  cachedCanvasHasHoles := false.  self initForEventsnewOKButtonFor: arg1  ^self newOKButtonFor: arg1 getEnabled: nilobjectToView: arg1 viewSelector: arg2  self objectToView: arg1.  viewSelector := arg2selectedFillStyle  ^self theme controlButtonSelectedFillStyleFor: selfgetIndexSelector  ^getIndexSelectorcopySelectionToClipboard  self selection ifNotNil: [ Clipboard clipboardText: self selection asString ] ifNil: [ self flash ]acceptDroppingMorph: arg1 event: arg2  self model container swapColumn: self model withColumn: arg1 passenger.  arg2 hand releaseMouseFocus: self.  self noMorePotentialDropTarget.  self model container changed.  Cursor normal showdeleteBalloon  | tmp1 |  tmp1 := self world ifNil: [ ^self ].  tmp1 deleteBalloonTarget: selfnumberOfInstanceVariablesColumn: arg1 row: arg2  ^FTCellMorph new     addMorph: (self elementAt: arg2) instSize asStringMorph;     yourselfkeyStroke: arg1 from: arg2  self selectedNode ifNotNil: [:arg3 |  arg3 keyStroke: arg1 from: arg2 ]detachKeymapCategory: arg1  self kmDispatcher detachKeymapCategory: arg1selectFirst  self subclassResponsibilitycontainer  ^containerupdateLayoutInDockingBar  owner isVertical ifFalse: [ self hResizing: #shrinkWrap.        self vResizing: #spaceFill ] ifTrue: [ self hResizing: #spaceFill.        self vResizing: #shrinkWrap ].  self extent: self minWidth @ self minHeightdrawOnAthensCanvas: arg1  | tmp1 |  tmp1 := self borderStyle.  arg1 setPaint: self fillStyle.  arg1 drawShape: self bounds.  arg1 drawShape: (self bounds insetBy: tmp1 width).  arg1 setStrokePaint: tmp1.  arg1 drawShape: (self bounds insetBy: tmp1 width / 2 asFloat)handleKeyUp: arg1  ^self dispatchDefault: arg1 with: morphpositionShortcut: arg1  | tmp1 |  tmp1 := self currentWorld clearArea insetBy: 3.  arg1     cellPositioning: position;     fullBounds.  arg1 perform: (position , ':') asSymbol with: (position value: tmp1)useSelectionBar  ^TextEditor useSelectionBarbuildTitle: arg1  titleMorph ifNil: [ self createTitleMorph ].  arg1 value: titleMorphgetListSizeSelector: arg1  getListSizeSelector := arg1calculateVisibleTabs  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self tabs collect: [:arg1 |  arg1 minExtent x ].  tmp3 := self layoutBounds width.  self cornerStyle = #rounded ifTrue: [ tmp3 := tmp3 - 6 ].  tmp1 sum <= tmp3 ifTrue: [ ^self tabs ].  tmp3 := tmp3 - self controlsExtent x.  tmp2 := OrderedCollection new.  tmp4 := 0.  self visibleTabRange last = 0 ifTrue: [ tmp5 := (self tabs copyFrom: self visibleTabRange first to: self tabs size) readStream.        tmp6 := (tmp1 copyFrom: self visibleTabRange first to: tmp1 size) readStream.        [ tmp4 <= tmp3 and: [ tmp5 atEnd not ] ] whileTrue: [ tmp2 add: tmp5 next.              tmp4 := tmp4 + tmp6 next ].        tmp4 > tmp3 ifTrue: [ tmp2 removeLast ].        ^tmp2 ] ifFalse: [ tmp5 := (self tabs copyFrom: 1 to: self visibleTabRange last) reversed readStream.        tmp6 := (tmp1 copyFrom: 1 to: self visibleTabRange last) reversed readStream.        [ tmp4 <= tmp3 and: [ tmp5 atEnd not ] ] whileTrue: [ tmp2 addFirst: tmp5 next.              tmp4 := tmp4 + (tmp7 := tmp6 next) ].        tmp4 > tmp3 ifTrue: [ tmp2 removeFirst.              tmp4 := tmp4 - tmp7 ].        tmp5 := (self tabs copyFrom: self visibleTabRange last + 1 to: self tabs size) readStream.        tmp6 := (tmp1 copyFrom: self visibleTabRange last + 1 to: tmp1 size) readStream.        [ tmp4 <= tmp3 and: [ tmp5 atEnd not ] ] whileTrue: [ tmp2 add: tmp5 next.              tmp4 := tmp4 + tmp6 next ].        tmp4 > tmp3 ifTrue: [ tmp2 removeLast ].        ^tmp2 ]addSpacer  self addMorphBack: (AlignmentMorph newSpacer: Color transparent)isEasySelecting  ^self class easySelectingWorldbackgroundColor: arg1  backgroundColor := arg1.  self changednoHelpString  ^'Help not yet supplied' translatedrestoreDisplay  self currentWorld restoreMorphicDisplayhandleMouseWheel: arg1  arg1 wasHandled ifTrue: [ ^self ].  (self handlesMouseWheel: arg1) ifTrue: [ arg1 wasHandled: true.        self mouseWheel: arg1 ]newMultistateButton  ^self theme newMultistateButtonIn: selfselectedTab  ^self selectedIndex = 0 ifFalse: [ self tabs at: self selectedIndex ifAbsent: [ nil ] ]newCloseButton  ^self newCloseButtonFor: selfgetEnabledSelector: arg1  getEnabledSelector := arg1.  self update: arg1isResizeable: arg1  arg1 = isResizeable ifTrue: [ ^self ].  arg1 ifTrue: [ self beResizeable ] ifFalse: [ self beUnresizeable ]selectIndex: arg1 event: arg2  arg2 shiftPressed ifTrue: [ ^self selectIndexesUpTo: arg1 ].  OSPlatform current isMacOS ifTrue: [ arg2 commandKeyPressed ifTrue: [ ^self selectAppendingIndex: arg1 ] ] ifFalse: [ arg2 controlKeyPressed ifTrue: [ ^self selectAppendingIndex: arg1 ] ].  self toggleIndex: arg1originalObject: arg1  originalObject := arg1defaultBackgroundColor  ^self theme windowColorFor: selfcontentMorph: arg1  contentMorph := arg1isSticky  submorphs isEmpty ifFalse: [ ^submorphs first isSticky ].  ^falseselectedNodeList  ^self selectedNodePathList ifNil: [ #() ] ifNotNil: [:arg1 |  arg1 collect: [:arg2 |  arg2 last ] ]brightness: arg1  | tmp1 |  tmp1 := self selectedColor.  self selectedColor: ((Color h: tmp1 hue s: tmp1 saturation v: arg1 / 255) alpha: tmp1 alpha)isExpanded  ^falseaddMenuControl  labelArea ifNil: [ ^self ].  menuBox ifNotNil: [ menuBox delete ].  labelArea addMorphBack: (menuBox := self createMenuBox)enabled  ^falseaddItem  | tmp1 tmp2 |  tmp1 := UIManager default request: 'Label for new item?'.  tmp1 isEmpty ifTrue: [ ^self ].  tmp2 := UIManager default request: 'Selector?'.  tmp2 isEmpty ifFalse: [ tmp2 := tmp2 asSymbol ].  self add: tmp1 selector: tmp2stepListSize  ^worldState stepListSizeacceptTextMorphs  self allMorphs do: [:arg1 |  ((arg1 respondsTo: #accept) and: [ (arg1 respondsTo: #hasUnacceptedEdits) and: [ arg1 hasUnacceptedEdits ] ]) ifTrue: [ arg1 accept ] ]bars  ^self submorphschanged  | tmp1 tmp2 tmp3 |  self assureExtension.  extension borderStyle: (tmp3 := self borderStyleToUse).  borderColor := tmp3 style.  borderWidth := tmp3 width.  extension fillStyle: self fillStyleToUse.  self layoutInset: (self theme buttonLabelInsetFor: self).  self privateColor: self fillStyle asColor.  (self labelMorph respondsTo: #interactionState:) ifTrue: [ self labelMorph interactionState: self interactionState ] ifFalse: [ (self labelMorph isNil or: [ label isMorph ]) ifFalse: [ tmp2 := self normalColor.              tmp1 := self enabled ifTrue: [ tmp2 contrastingBlackAndWhiteColor ] ifFalse: [ tmp2 contrastingBlackAndWhiteColor muchDarker ].              self labelMorph color: tmp1 ] ].  super changedputSelector  ^nilsortFunction: arg1  sortFunction := arg1lastKeystrokeTime: arg1  lastKeystrokeTime := arg1mouseWheel: arg1  (self scrollTarget handlesMouseWheel: arg1) ifTrue: [ ^self scrollTarget mouseWheel: arg1 ].  arg1 isUp ifTrue: [ ^vScrollbar scrollUp: 3 ].  arg1 isDown ifTrue: [ ^vScrollbar scrollDown: 3 ].  arg1 isLeft ifTrue: [ ^hScrollbar scrollLeft: 3 ].  arg1 isRight ifTrue: [ ^hScrollbar scrollRight: 3 ]forEachPointDo: arg1  pointBlock := arg1bounds: arg1  bounds := arg1updateColumnMorphs  self privateUpdateColumnMorphsrecordInvalidRect: arg1  | tmp1 tmp2 |  totalRepaint ifTrue: [ ^self ].  tmp2 := 0 @ 0 corner: 0 @ 0.  invalidRects do: [:arg2 |  | tmp3 |        ((tmp3 := (arg2 intersect: arg1 ifNone: [ tmp2 ]) area) > 40 and: [ tmp3 > (arg1 area // 4) or: [ tmp3 > (arg2 area // 4) ] ]) ifTrue: [ arg2 setPoint: (arg2 origin min: arg1 origin) truncated point: (arg2 corner max: arg1 corner) truncated.              ^self ] ].  invalidRects size >= 50 ifTrue: [ tmp1 := Rectangle merging: invalidRects.        self reset.        invalidRects addLast: tmp1 ].  arg1 hasPositiveExtent ifTrue: [ invalidRects addLast: (arg1 topLeft truncated corner: arg1 bottomRight truncated) ]contents  ^model contentsOfNode: selfheight: arg1  self extent: self width @ arg1 asIntegertopLeft  ^textMorph owner topLeftnewGroupbox: arg1 forAll: arg2  ^self theme newGroupboxIn: self label: arg1 forAll: arg2chunkSize: arg1  self setPageSize: arg1.  self announce: (MorphTreeChangeRequest chunkSize: arg1)proceed: arg1 title: arg2  ^self theme proceedIn: self text: arg1 title: arg2mouseEnterDragging: arg1  self enabled ifFalse: [ ^self ].  (arg1 hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: arg1 ]newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 help: arg5  ^self newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: nil useIndex: true help: arg5newTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6theMethodInProdThatShouldBeTested  ^TaskbarMorph >> #updateOrderedTasksFrom:selectedBorderStyle  ^self theme taskbarItemSelectedBorderStyleFor: selfresizeVerticalScrollBar  | tmp1 tmp2 tmp3 |  tmp1 := self scrollBarThickness.  tmp2 := self bounds height - (self borderWidth * 2) - self horizontalScrollBarHeight.  tmp3 := self bounds topRight - ((tmp1 + self borderWidth) @ (0 - self borderWidth)).  self verticalScrollBar bounds: (tmp3 extent: tmp1 @ tmp2)newEmbeddedMenu  ^self theme newEmbeddedMenuIn: self for: selfcolumns: arg1  columns := arg1 asArraystep: arg1  step := arg1leftBoundary  | tmp1 |  tmp1 := leftOrTop reject: [:arg1 |  arg1 layoutFrame leftFraction ~= 0 and: [ arg1 layoutFrame leftFraction = arg1 layoutFrame rightFraction ] ].  tmp1 ifEmpty: [ ^(self splitterLeft ifNil: [ self containingWindow panelRect left ] ifNotNil: [:arg2 |  arg2 left ]) + 25 ].  ^(tmp1 collect: [:arg1 |  arg1 left + arg1 minExtent x + (self layoutFrame leftOffset ifNil: [ 0 ]) - (arg1 layoutFrame rightOffset ifNil: [ 0 ]) ]) maxsendMouseEvent: arg1  ^self sendEvent: arg1 focus: self mouseFocus clear: [ self mouseFocus: nil ]storeOn: arg1  super storeOn: arg1.  arg1 space.  whichButton storeOn: arg1drawOn: arg1  super drawOn: arg1.  arg1 drawString: self label in: self labelBounds font: self font color: self fontColorhandlesMouseMove: arg1  ^self existsSubscriptionsFor: #mouseMovemouseDown: arg1  super mouseDown: arg1.  (actWhen == #buttonDown and: [ arg1 hand mouseFocus ~= self ]) ifTrue: [ self mouseLeave: arg1 ]handlerForMouseDown: arg1  ^(self hasProperty: #submorphLockStates) ifFalse: [ super handlerForMouseDown: arg1 ]couldHaveRoundedCorners  ^truecollapseAll  rootItem collapseAll.  self tableRefreshtransformedFrom: arg1  owner ifNil: [ ^IdentityTransform basicNew ].  ^owner transformFrom: arg1menuBarItems: arg1  menuBarItems := arg1initialize  super initialize.  self borderInitializehighlightedRowIndex  self deprecated: 'Use #highlightedIndex instead' transformWith: '`@receiver highlightedRowIndex' -> '`@receiver highlightedIndex'.  ^self highlightedIndexleftFraction  ^leftFractiondisableTableLayout: arg1  self assureLayoutProperties disableTableLayout: arg1.  self layoutChangedrefresh  lastRefresh := Time millisecondClockValue.  self width: labelMorph width + 25newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: arg6 help: arg7initializeAppearance  self     color: (self theme textColor alpha: 0.3);     fillStyle: (self theme taskbarFillStyleFor: self)current  ^bar valuelongMessage: arg1 title: arg2  ^self theme longMessageIn: self text: arg1 title: arg2menuButtonHeight  ^16 * self displayScaleFactorisTransferable  ^trueinitialize  super initialize.  self borderWidth: 1.  self color: (Color r: 0.4 g: 0.8 b: 0.6).  self borderColor: self color darker.  self borderStyle: BorderStyle thinGray.  actionSelector := #flash.  arguments := EmptyArray.  actWhen := #buttonUp.  self setDefaultLabeltestIndexesToSelectInMultipleSelectionFromTo  self assert: (strategy indexesToSelectInMultipleSelectionFrom: 3 to: 11) asArray equals: #(3 4 5 6 7 8 9 10 11).  self assert: (strategy indexesToSelectInMultipleSelectionFrom: 11 to: 3) asArray equals: #(11 10 9 8 7 6 5 4 3).  self assert: (strategy indexesToSelectInMultipleSelectionFrom: 3 to: 3) asArray equals: #(3)drawSeparatorAfter: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := listSource separatorSize.  tmp4 := listSource separatorColor.  tmp1 := self selectionFrameForRow: arg1.  tmp2 := tmp1 left @ (tmp1 bottom - tmp3) corner: tmp1 right @ tmp1 bottom.  arg2 fillRectangle: tmp2 color: tmp4childAt: arg1  | tmp1 |  tmp1 := arg1.  self children do: [:arg2 |  | tmp2 |        tmp2 := arg2 numberOfVisibleChildren + 1.        tmp1 <= tmp2 ifTrue: [ ^arg2 selfOrChildAt: tmp1 ] ifFalse: [ tmp1 := tmp1 - tmp2 ] ].  self errorSubscriptBounds: arg1drawOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  self shouldDraw ifFalse: [ ^self ].  tmp3 := SystemWindow borderWidth.  tmp2 := arg1 asAlphaBlendingCanvas: 0.7.  tmp1 := self bounds.  tmp4 := tmp1 left: tmp1 right - tmp3.  tmp4 := tmp4 bottom: tmp4 top + tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp1 right: tmp1 right - tmp3.  tmp4 := tmp4 bottom: tmp4 top + tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp4 left: tmp4 left + 7.  tmp4 := tmp4 right: tmp4 right - 7.  tmp2 fillRectangle: tmp4 color: self dotColor.  tmp4 := tmp1 left: tmp1 right - tmp3.  tmp4 := tmp4 top: tmp4 top + tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp4 top: tmp4 top + 7.  tmp4 := tmp4 bottom: tmp4 bottom - 7.  tmp2 fillRectangle: tmp4 color: self dotColormatchPath: arg1  arg1 ifNil: [ ^nil ].  ^arg1 treeNodeHead = self complexContents withoutListWrapper ifFalse: [ nil ] ifTrue: [ | tmp1 |        arg1 treeNodeTail ifNil: [ ^{self} ].        tmp1 := self children collect: [:arg2 |  arg2 matchPath: arg1 treeNodeTail ].        ^tmp1 select: [:arg3 |  arg3 notNil ] ]showNever  self showState: #neverlineHeight: arg1 baseline: arg2  bottom := top + arg1.  baseline := arg2hideLeftOrTop  self hide.  leftOrTop do: [:arg1 |  arg1 hide ]minHeight  ^self valueOfProperty: #minHeight ifAbsent: [ 2 ]selectItem: arg1 event: arg2  selectedItem ifNotNil: [ selectedItem deselect: arg2 ].  selectedItem := arg1.  selectedItem ifNotNil: [ selectedItem select: arg2 ]secondarySelectionColor: arg1  secondarySelectionColor := arg1wantsDroppedNode: arg1 on: arg2  dropItemSelector ifNil: [ ^false ].  wantsDropSelector ifNil: [ ^true ].  ^(model perform: wantsDropSelector with: arg1 with: arg2) == truedrawOn: arg1  | tmp1 |  self style == #plain ifTrue: [ ^super drawOn: arg1 ].  tmp1 := self bounds.  (self style == #inset or: [ self style == #insetNoHighlight ]) ifTrue: [ self style == #insetNoHighlight ifFalse: [ arg1 drawString: self contents in: (tmp1 translateBy: 1) font: self fontToUse color: self color veryMuchLighter ].        arg1           drawString: self contents in: (tmp1 translateBy: -1) font: self fontToUse color: self color muchDarker;           drawString: self contents in: tmp1 font: self fontToUse color: self color ] ifFalse: [ self style == #raisedNoHighlight ifFalse: [ arg1 drawString: self contents in: (tmp1 translateBy: -1) font: self fontToUse color: self color veryMuchLighter ].        arg1           drawString: self contents in: (tmp1 translateBy: 1) font: self fontToUse color: self color muchDarker;           drawString: self contents in: tmp1 font: self fontToUse color: self color ]handlesMouseOverDragging: arg1  ^trueokToDiscardEdits  ^self canDiscardEdits or: [ self promptForCancel ]invokeModalAt: arg1 in: arg2 allowKeyboard: arg3  | tmp1 tmp2 |  tmp2 := arg2 primaryHand keyboardFocus.  self popUpAt: arg1 forHand: arg2 primaryHand in: arg2 allowKeyboard: arg3.  self isModalInvokationDone: false.  tmp1 := arg2 outermostWorldMorph.  [ self isInWorld and: [ self isModalInvokationDone not ] ] whileTrue: [ tmp1 doOneSubCycle ].  self delete.  self restoreFocus: tmp2 in: arg2.  ^self modalSelectionadjustWidth  self width: (listSource width max: self hUnadjustedScrollRange) + 20initialize  countDict := Dictionary new.  limit := self defaultLimit.  size := #small.  position := #bottomLeft.  backgroundColor := self defaultBackgroundColor.  textColor := self defaultTextColordragThroughOnDesktop: arg1  | tmp1 |  tmp1 := SelectionMorph newBounds: (arg1 cursorPoint extent: 8 @ 8).  self addMorph: tmp1.  ^tmp1 extendByHand: arg1 handcanChangeText  ^self editView enabledcontainer  ^containeraddBlankIconsIfNecessary: arg1  self items reject: [:arg2 |  arg2 hasIconOrMarker ] thenDo: [:arg2 |  arg2 icon: arg1 ]hScrollbarNeeded  self hScrollbar showsAlways ifTrue: [ ^true ].  self hScrollbar showsNever ifTrue: [ ^false ].  ^self scrollTarget width + (self scrollTarget height > self innerBounds height ifTrue: [ self scrollBarThickness ] ifFalse: [ 0 ]) > self innerBounds widthpaneMorphSatisfying: arg1  ^paneMorphs detect: arg1 ifNone: [ nil ]newCloseControlFor: arg1 action: arg2 help: arg3  ^self theme newCloseControlIn: self for: arg1 action: arg2 help: arg3alert: arg1 title: arg2 configure: arg3  ^self theme alertIn: self text: arg1 title: arg2 configure: arg3keyStroke: arg1  (self navigationKey: arg1) ifTrue: [ ^self ].  arg1 keyCharacter = Character space ifTrue: [ self toggleSelected ]delete  activeSubMenu ifNotNil: [ activeSubMenu delete ].  ^super deleteaddMouseListener: arg1  self mouseListeners: (self addListener: arg1 to: self mouseListeners)normalizedX: arg1  ^arg1highlightedForMouseDown  ^(self valueOfProperty: #highlightedForMouseDown) == truenumberOfChildren  ^self children ifEmpty: [ 0 ] ifNotEmpty: [:arg1 |  arg1 size + (arg1 collect: [:arg2 |  arg2 numberOfChildren ]) sum ]exposedRows  ^exposedRowsmorphToDropFrom: arg1  ^arg1pressedFillStyle  ^self theme scrollbarPressedFillStyleFor: selfextraSpace: arg1  extraSpace := arg1canBeClosed  ^tabs allSatisfy: [:arg1 |  arg1 closeable ]scrollToShow: arg1  client scrollToShow: arg1brickThemer  ^(self nearestOwnerThat: [:arg1 |  (arg1 isKindOf: GLMFoundationBrick) | (arg1 isKindOf: GLMBrick) ]) ifNotNil: [:arg2 |  arg2 themer ] ifNil: [ self theme brickThemer ]childrenFor: arg1  | tmp1 |  tmp1 := childrenBlock value: arg1.  ^sortingBlock ifNil: [ tmp1 ] ifNotNil: [ tmp1 sort: sortingBlock ]hScrollValue: arg1  hScrollBar setValue: arg1insetColor  owner ifNil: [ ^self color ].  ^self colorForInsetsscrollBarAction: arg1  self setProperty: #scrollBarAction toValue: arg1modalWindow: arg1  (self valueOfProperty: #modalWindow) ifNotNil: [:arg2 |  arg2 delete ].  self setProperty: #modalWindow toValue: arg1.  arg1 ifNotNil: [ self when: #aboutToLeaveWorld send: #removeModalWindow to: self ]paneColorChanged  self changedtextStyle  ^textStylebeComplete  self closedeactivate  self subclassResponsibilityupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]handlerForMouseDown: arg1  arg1 blueButtonPressed ifTrue: [ ^self handlerForBlueButtonDown: arg1 ].  arg1 yellowButtonPressed ifTrue: [ ^self handlerForYellowButtonDown: arg1 ].  arg1 controlKeyPressed ifTrue: [ ^self handlerForMetaMenu: arg1 ].  (self handlesMouseDown: arg1) ifFalse: [ ^nil ].  arg1 handler ifNil: [ ^self ].  ^self mouseDownPriority >= arg1 handler mouseDownPriority ifTrue: [ self ] ifFalse: [ nil ]simulateClickWith: arg1 position: arg2  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := HandMorph new     mouseFocus: self;     yourself.  tmp2 privateOwner: self.  {(#mouseDown -> arg1) .   (#mouseUp -> tmp1)} do: [:arg3 |  tmp2 handleEvent: (MouseButtonEvent new setType: arg3 key position: arg2 which: (tmp1 bitXor: arg1) buttons: arg3 value hand: tmp2 stamp: Time millisecondClockValue) ]newScrollingIndex: arg1  newScrollingIndex := arg1inAColumn: arg1  self setAsColumn     color: Color transparent;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     layoutInset: 1;     wrapCentering: #center;     cellPositioning: #topCenter.  arg1 do: [:arg2 |  self addMorphBack: arg2 ].  ^selfoverlapsVertical: arg1  ^arg1 top <= self bottom and: [ arg1 bottom >= self top ]pattern  ^patternglobalPointToLocal: arg1  ^self point: arg1 from: nilnavigateFocusForward  self nextMorphWantingFocus ifNil: [ self takeKeyboardFocus ] ifNotNil: [ super navigateFocusForward ]arrangeToStartStepping  self arrangeToStartSteppingIn: self worldscrollBarThickness  ^self theme scrollbarThicknessnewStack: arg1  ^self theme newStackIn: self for: arg1isAlignmentMorph  ^falseunderlineColor  ^self stringColorchanged  container ifNil: [ ^super changed ].  self invalidRect: self selectionFrame.  super changedcanvas  ^worldState canvascolorSelected: arg1  self triggerEvent: #colorSelected with: arg1hasDropShadow  ^self valueOfProperty: #hasDropShadow ifAbsent: [ false ]drawOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  self shouldDraw ifFalse: [ ^self ].  tmp3 := SystemWindow borderWidth.  tmp2 := arg1 asAlphaBlendingCanvas: 0.7.  tmp1 := self bounds.  tmp4 := tmp1 right: tmp1 left + tmp3.  tmp4 := tmp4 top: tmp4 bottom - tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp1 left: tmp1 left + tmp3.  tmp4 := tmp4 top: tmp4 bottom - tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp4 left: tmp4 left + 7.  tmp4 := tmp4 right: tmp4 right - 7.  tmp2 fillRectangle: tmp4 color: self dotColor.  tmp4 := tmp1 right: tmp1 left + tmp3.  tmp4 := tmp4 bottom: tmp4 bottom - tmp3.  tmp2 fillRectangle: tmp4 color: self handleColor.  tmp4 := tmp4 top: tmp4 top + 7.  tmp4 := tmp4 bottom: tmp4 bottom - 7.  tmp2 fillRectangle: tmp4 color: self dotColordefaultLabel  ^'Window' translatedmouseMoveOnSingle: arg1  | tmp1 |  self enabled ifFalse: [ ^self ].  tmp1 := self rowAtLocation: arg1 position.  arg1 hand hasSubmorphs ifFalse: [ ((self containsPoint: arg1 position) and: [ tmp1 ~= 0 ]) ifTrue: [ self mouseDownRow: tmp1 ] ifFalse: [ self mouseDownRow: nil ] ].  (self dropEnabled and: [ arg1 hand hasSubmorphs ]) ifFalse: [ ^self eventHandler ifNotNil: [ self eventHandler mouseMove: arg1 fromMorph: self ] ].  (self containsPoint: arg1 position) ifTrue: [ self mouseEnterDragging: arg1 ] ifFalse: [ self mouseLeaveDragging: arg1 ]defaultBorderColor  ^Color yellowdrawOn: arg1  | tmp1 |  self setDefaultContentsIfNil.  super drawOn: arg1.  false ifTrue: [ self debugDrawLineRectsOn: arg1 ].  self startingIndex > text size ifTrue: [ self drawNullTextOn: arg1 ].  tmp1 := self bounds topLeft corner: self innerBounds bottomRight.  arg1 paragraph: self paragraph bounds: tmp1 color: colorchangeClipLayoutCells  self invalidRect: self fullBounds.  self clipLayoutCells: self clipLayoutCells not.  self invalidRect: self fullBoundsrememberedKeyboardFocus  ^self valueOfProperty: #rememberedFocususeSortedTabsBy: arg1  tabs := SortedCollection sortBlock: arg1composeAll  ^self multiComposeLinesFrom: firstCharacterIndex to: text size delta: 0 into: OrderedCollection new priorLines: Array new atY: container topretrievingBlock: arg1  retrievingBlock := arg1.  retrievingBlock ifNotNil: [ self softRetrieveMorph ]extent: arg1  | tmp1 tmp2 |  bounds extent = arg1 ifTrue: [ ^self ].  tmp2 := editor.  self isAutoFit ifTrue: [ wrapFlag ifFalse: [ ^self ].        tmp1 := arg1 truncated max: self minimumExtent.        tmp1 x = self extent x ifTrue: [ ^self ].        self releaseParagraphReally.        super extent: tmp1.        tmp2 ifNil: [ self fit ] ifNotNil: [ self installEditorToReplace: tmp2 ] ] ifFalse: [ super extent: (arg1 truncated max: self minimumExtent).        wrapFlag ifFalse: [ ^self ].        self composeToBounds ]blueMorphTab  | tmp1 |  tmp1 := TabMorph label: 'Blue Morph' icon: (self iconNamed: #smallBackIcon) morph: Morph new.  tmp1 actions: {(TabAction action: [ tmp1 morph color: Color random ] icon: (self iconNamed: #smallConfigurationIcon) label: 'Randomize color')}.  tmp1     closeable: false;     menu: [:arg1 |  arg1 add: 'Fubu' target: self selector: #halt ].  ^tmp1allowsDeselection  ^allowsDeselection ifNil: [ self class defaultAllowsDeselection ]addMorph: arg1 behind: arg2  ^self privateAddMorph: arg1 atIndex: (submorphs indexOf: arg2) + 1lostFocusWithoutAccepting  self acceptContentsinitialize  super initialize.  emphasis := 0.  hasFocus := false.  backgroundColor := Color transparenton: arg1 list: arg2 primarySelection: arg3 changePrimarySelection: arg4 listSelection: arg5 changeListSelection: arg6 menu: arg7 keystroke: arg8  self getSelectionListSelector: arg5.  self setSelectionListSelector: arg6.  self on: arg1 list: arg2 selected: arg3 changeSelected: arg4 menu: arg7 keystroke: arg8.  self beMultipleSelectionwrapSelector: arg1  wrapSelector := arg1cornerStyle: arg1  super cornerStyle: arg1.  self imageMorph cornerStyle: arg1offset: arg1  offset := arg1.  self fitContentsexpand  self isCollapsed ifTrue: [ self collapseOrExpand ]defaultFocusMorph  ^self defaultButton ifNil: [ (self respondsTo: #nextMorphWantingFocus) ifTrue: [ self nextMorphWantingFocus ] ] ifNotNil: [:arg1 |  arg1 enabled ifTrue: [ arg1 ] ]getEnabledSelector  ^getEnabledSelectoractionBlock: arg1  actionBlock := arg1hasSubMenu: arg1  subMenu ifNil: [ ^false ].  subMenu == arg1 ifTrue: [ ^true ].  ^subMenu hasSubMenu: arg1visible  ^visiblevalueOfProperty: arg1  ^self valueOfProperty: arg1 ifAbsent: [  ]avoidVisibleBordersAtEdgeString  ^self avoidVisibleBordersAtEdge -> 'avoid visible borders at edge' translatedveryDeepFixupWith: arg1  owner := arg1 references at: owner ifAbsent: [ nil ]newAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 font: arg5 help: arg6  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 font: arg5 help: arg6newTabGroup: arg1  ^self theme newTabGroupIn: self for: arg1selectTabAt: arg1  toolbar selectTabAt: arg1 ifAbsent: [  ]headerButtonLabel: arg1 font: arg2  self headerButton.  self header label: arg1 font: arg2newGroupboxFor: arg1  ^self theme newGroupboxIn: self for: arg1width  ^right - leftselectOnlyLastHighlighted  ^removeOnlyLastSelectedclosestPointTo: arg1  ^self intersectionWithLineSegmentFromCenterTo: arg1asArray  ^{leftFraction .   topFraction .   rightFraction .   bottomFraction .   leftOffset .   topOffset .   rightOffset .   bottomOffset}green  ^(self selectedColor green * 255) asIntegerisActivated  ^falseprocessEventsFromQueue: arg1  | tmp1 tmp2 tmp3 tmp4 |  ActiveEvent ifNotNil: [ self mouseOverHandler processMouseOver: lastMouseEvent ].  tmp4 := false.  [ arg1 isNotNil and: [ (tmp2 := arg1 nextEvent) isNotNil ] ] whileTrue: [ tmp1 := nil.        tmp3 := tmp2 first.        tmp3 = EventTypeMouse ifTrue: [ self world beCursorOwner.              recentModifiers := tmp2 sixth.              tmp1 := self generateMouseEvent: tmp2 ].        tmp3 = EventTypeKeyboard ifTrue: [ recentModifiers := tmp2 fifth.              tmp1 := self generateKeyboardEvent: tmp2 ].        tmp3 = EventTypeDragDropFiles ifTrue: [ tmp1 := self generateDropFilesEvent: tmp2 ].        tmp3 = EventTypeWindow ifTrue: [ tmp1 := self generateWindowEvent: tmp2 ].        (tmp3 ~= EventTypeDragDropFiles and: [ tmp1 isNil ]) ifTrue: [ ^self ].        tmp1 ifNotNil: [ self handleEvent: tmp1.              tmp4 := true.              (tmp1 isMouse and: [ tmp1 isMouseWheel not ]) ifTrue: [ ^self ] ] ].  mouseClickState notNil ifTrue: [ mouseClickState handleEvent: lastMouseEvent asMouseMove from: self ].  tmp4 ifFalse: [ self mouseOverHandler processMouseOver: lastMouseEvent ]defaultButton  ^self findDeepSubmorphThat: [:arg1 |  (arg1 isKindOf: PluggableButtonMorph) and: [ arg1 isDefault ] ] ifAbsent: [  ]numberOfRows  ^self model ifNotNil: [ self getListSizeSelector ifNotNil: [ self model perform: self getListSizeSelector ] ifNil: [ (self model perform: self getListSelector) size ] ] ifNil: [ 0 ]mouseUp: arg1  target ifNotNil: [ Display deferUpdatesIn: Display boundingBox while: [ target bounds: self bounds ] ].  self deleteinitialDataSource  ^initialDataSourceupdateText  self model ifNotNil: [ self getTextSelector ifNotNil: [ self contents: (self model perform: self getTextSelector) ] ]addAlarm: arg1 withArguments: arg2 for: arg3 at: arg4  self alarms add: (MorphicAlarm scheduledAt: arg4 receiver: arg3 selector: arg1 arguments: arg2)updateLabelEnablement  self labelMorph enabled: self enabledtotalLength  | tmp1 |  tmp1 := 0.  self lineSegmentsDo: [:arg1 :arg2 |  tmp1 := tmp1 + (arg1 distanceTo: arg2) ].  ^tmp1initialize  super initialize.  fillsOwner := true.  avoidVisibleBordersAtEdge := true.  autoGradient := self wantsGradientByDefault.  self color: self defaultColor.  self beFloating.  self layoutInset: 0nextMorphInWindow  ^self hasSubmorphs ifTrue: [ self submorphs first ] ifFalse: [ self nextMorphAcrossInWindow ]canvas  ^canvasbottom: arg1  self position: bounds left @ (arg1 - self height)drawCaretOnAthensCanvas: arg1  (self showCaret not or: [ selectionStart isNil ]) ifTrue: [ ^self ].  caretRect := selectionStart topLeft asIntegerPoint extent: 1 @ selectionStart height.  arg1 setPaint: self insertionPointColor.  arg1 drawShape: self caretRectroots: arg1  rootItems := arg1 collect: [:arg2 |  FTBasicTreeListItem new           item: arg2;           datasource: self ].  self countAvailableRowsinitializeSelections  self onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: selfkeystrokeActionSelector: arg1  keystrokeActionSelector := arg1label: arg1  label := arg1isFlexMorph  ^truedrawSubMenuMarker: arg1 on: arg2 in: arg3  | tmp1 |  tmp1 := arg3 topRight + (arg1 width negated @ ((arg3 height - arg1 height) // 2)) extent: arg1 extent.  tmp1 translateBy: -4 @ 1.  self drawIcon: arg1 on: arg2 in: tmp1enabled  ^enabled ifNil: [ enabled := super enabled ]okayToRotateEasily  ^self respondsTo: #prepareForRotatingdefaultTextColor  ^Color blackisRowSelected: arg1  ^(selectedRow notNil and: [ arg1 = selectedRow ]) or: [ listSource itemSelectedAmongMultiple: arg1 ]recursiveDelete  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg1 |  arg1 recursiveDelete ] ].  self deleteoption: arg1  option := arg1.  self     changed: #isLeft;     changed: #isCenter;     changed: #isRightupdatePaneColors  self setStripeColorsFrom: self paneColorToUsenewHSVASelector: arg1 help: arg2  ^self theme newHSVASelectorIn: self color: arg1 help: arg2pattern  ^self ensureSafePattern: patternModel getText asString trimBothprintOn: arg1  arg1 nextPutAll: 'NodeMorph('.  complexContents printOn: arg1.  arg1 nextPut: $)mouseMove: arg1  (self containsPoint: arg1 cursorPoint) ifTrue: [ self setSwitchState: oldColor = offColor ] ifFalse: [ self setSwitchState: oldColor = onColor ]beUnResetable  resetable := falserotationCenter  | tmp1 |  tmp1 := self valueOfProperty: #referencePosition ifAbsent: [ ^0.5 @ 0.5 ].  ^(tmp1 - self bounds origin) / self bounds extent asFloatPointnewBalloonHelp: arg1 for: arg2 corner: arg3  ^self theme newBalloonHelpIn: self contents: arg1 for: arg2 corner: arg3getSelectedPathSelector  ^getSelectedPathSelectortoggleAction: arg1  self inform: (arg1 ifTrue: [ 'Button pressed' ] ifFalse: [ 'Button unpressed' ])normalFillStyle  ^self theme controlButtonNormalFillStyleFor: selflayout: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  arg1 submorphs ifEmpty: [ ^self ].  tmp1 := arg1 assureTableProperties.  tmp7 := self minExtentOf: arg1 in: arg2.  tmp6 := arg2 origin extent: (arg2 extent max: tmp7).  tmp2 := tmp6.  arg1 submorphs with: cachedMinExtents do: [:arg3 :arg4 |  ((tmp5 := arg3 vResizing) == #shrinkWrap or: [ arg3 bounds ~= tmp2 ]) ifTrue: [ ((tmp5 == #shrinkWrap) not and: [ arg3 extent = tmp2 extent ]) ifTrue: [ arg3 position: tmp2 origin ] ifFalse: [ tmp3 := arg3 bounds.                    arg3 hResizing == #spaceFill ifTrue: [ tmp3 := tmp2 origin extent: tmp2 width @ tmp3 height ].                    tmp5 == #spaceFill ifTrue: [ tmp3 := tmp3 origin extent: tmp3 width @ tmp2 height ].                    tmp5 == #shrinkWrap ifTrue: [ tmp3 := tmp3 origin extent: tmp3 width @ arg4 y ].                    tmp4 := tmp1 cellPositioning.                    tmp3 := tmp3 align: (tmp3 perform: tmp4) with: (tmp2 perform: tmp4).                    arg3 bounds: tmp3 ] ] ]childrenDo: arg1  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg2 |  arg1 value: arg2 ] ]mouseLeave: arg1  self canResizeColumn ifFalse: [ ^self ].  super mouseLeave: arg1indexesToSelectInMultipleSelectionFrom: arg1 to: arg2  | tmp1 tmp2 |  tmp1 := arg1 first <= arg2 first ifTrue: [ 1 ] ifFalse: [ -1 ].  tmp2 := arg1 second <= arg2 second ifTrue: [ 1 ] ifFalse: [ -1 ].  ^(arg1 second to: arg2 second by: tmp2) flatCollect: [:arg3 |  (arg1 first to: arg2 first by: tmp1) collect: [:arg4 |  {arg4 .               arg3} ] ]registerActionsFor: arg1  arg1     when: #tabSelected send: #tabSelected: to: self;     when: #tabDeleted send: #tabDeleted: to: self;     when: #rightKeyPressed send: #rightKeyPressed: to: self;     when: #leftKeyPressed send: #leftKeyPressed: to: self;     when: #tabRefreshed send: #tabRefreshed: to: self;     when: #actionsChanged send: #actionsChanged: to: self;     when: #tabResetSelection send: #tabResetSelection: to: self;     when: #tabAddedToSelection send: #tabAddedToSelection: to: self;     when: #tabRemovedFromSelection send: #tabRemovedFromSelection: to: self;     when: #tabSelectTo send: #tabSelectTo: to: self;     when: #tabEmptyContents send: #tabEmptyContents: to: selfchildrenBlock: arg1  childrenBlock := arg1actualClass  self subclassResponsibilityredButtonPressed  ^buttons anyMask: self class redButtonsilentlySetSelectedMorph: arg1  | tmp1 |  tmp1 := arg1 ifNotNil: [ arg1 path collect: [:arg2 |  arg2 complexContents ] ].  self isMultiple ifFalse: [ self emptySelection ].  arg1 ifNotNil: [ self addToSelection: arg1 ].  self selectionUpdateFromViewWhile: [ self listModel selection: (self newSelectionHolderWithNodePath: tmp1) ]wantsGradientByDefault  ^self theme preferGradientFillshouldGetStepsFrom: arg1  ^self world == arg1adjustHeight  self height: (listItems size max: 1) * font heightnewLabelFor: arg1 getLabel: arg2 getEnabled: arg3  ^self theme newLabelIn: self for: arg1 getLabel: arg2 getEnabled: arg3goBehind  | tmp1 |  container ifNil: [ ^super goBehind ].  self releaseParagraph.  tmp1 := container.  super goBehind.  container := tmp1.  self changedcolumnColorForEven: arg1 odd: arg2  columnColors at: 2 put: arg2.  columnColors at: 1 put: arg1taskbars  ^self submorphs select: [:arg1 |  arg1 isTaskbar ]editorProvider  ^self valueOfProperty: #editorProvider ifAbsent: [  ]newTabGroup  ^(self newTabGroup: #()) cornerStyle: #squareenough: arg1 withMeasure: arg2 withIn: arg3  | tmp1 |  tmp1 := self measureFor: arg1.  tmp1 > (arg2 + arg3) ifFalse: [ ^arg1 // 2 ].  ^self enough: 2 * arg1 withMeasure: tmp1 withIn: arg3wasHandled  ^wasHandledhScrollbarShowWhenNeeded  self hScrollbar showWhenNeeded.  self updateScrollbarscreateTitleMorph  titleMorph ifNotNil: [ titleMorph delete ].  titleMorph := MenuTitleMorph new.  titleMorph on: #mouseDown send: #mouseDownInTitle: to: self.  self addMorphFront: titleMorphlistSpacing: arg1  listSpacing := arg1forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]drawOn: arg1  arg1 fillRectangle: self innerBounds fillStyle: (InfiniteForm with: self hatchForm).  super drawOn: arg1font  ^(self textStyle fontAt: self fontNumber) copyveryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  target := arg1 references at: target ifAbsent: [ target ].  arguments notNil ifTrue: [ arguments := arguments collect: [:arg2 |  arg1 references at: arg2 ifAbsent: [ arg2 ] ] ]newLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newLabelIn: self for: arg1 label: arg2 getEnabled: arg3submorphWithProperty: arg1  ^submorphs detect: [:arg2 |  arg2 hasProperty: arg1 ] ifNone: [ nil ]selectedPressedFillStyle  ^self theme taskbarItemSelectedPressedFillStyleFor: selfclassButton  ^(self theme newButtonIn: self currentWorld for: self getState: nil action: #browseItem arguments: {} getEnabled: #enabled getLabel: nil help: 'Open a browser on ' translated , self item name)     label: (self theme windowLabelForText: self item name , '...');     yourselfaction: arg1  action := arg1.  icon on: #click send: #value to: actionfillsOwner: arg1  fillsOwner := arg1.  self releaseCachedStatetabGroup: arg1  tabGroup := arg1cachedForm: arg1  cachedForm := arg1customSettingsOn: arg1  (arg1 pickOne: #position)     order: 1;     target: self;     label: 'Position in World';     description: 'Select one of the positons available to specify where the shortcut notification morph will be shown';     default: #bottomLeft;     domainValues: self positions.  (arg1 pickOne: #textSize)     order: 2;     target: self;     label: 'Size of the reminder';     description: 'Set the size (small medium or large) of the reminder morph shown';     domainValues: self sizes.  (arg1 setting: #textColor)     order: 3;     target: self;     label: 'Text color';     default: self defaultTextColor.  (arg1 setting: #backgroundColor)     target: self;     label: 'Background color';     default: self defaultBackgroundColor.  (arg1 range: #limit)     order: 6;     target: self;     label: 'Notification limit';     description: 'Set the limit of how many notifications per menu entry one should be reminded about. Setting the value to -1 means that it will allways remind you';     default: self defaultLimit;     range: (-1 to: 100).  (arg1 group: #'Reset count')     order: 7;     target: self;     label: 'Reset the reminder count';     dialog: [ self createResetCountButtonMorph ]selectedPageIndex: arg1  self tabSelectorMorph selectedIndex: arg1dialogWindowIn: arg1 title: arg2  ^self dialogWindowIn: arg1 title: arg2 selectedtems: Array newopenedFullscreen  self allMorphs do: [:arg1 |  arg1 layoutChanged ].  self activatedoRecolor: arg1 with: arg2  arg1 hand obtainHalo: self.  (arg2 containsPoint: arg1 cursorPoint) ifFalse: [ self delete.        target addHalo: arg1 ] ifTrue: [ innerTarget changeColor ].  self showingDirectionHandles ifTrue: [ self addHandles ]textMorph  ^textMorphdropElements: arg1 index: arg2  self elements: (arg2 = 0 ifTrue: [ self elements , arg1 ] ifFalse: [ (self elements first: arg2) , arg1 , (self elements allButFirst: arg2) ])max: arg1  endValue := arg1window: arg1  window := arg1separateDragAndDrop  | tmp1 |  (self hasProperty: #dragNDropEnabled) ifFalse: [ ^self ].  tmp1 := (self valueOfProperty: #dragNDropEnabled) == true.  self dragEnabled: tmp1.  self dropEnabled: tmp1.  self removeProperty: #dragNDropEnabledtaskbarTask  ^nilitem: arg1  item := arg1defaultBorderWidth  ^self theme dockingBarBorderWidthedgeName  ^edgeNamehoneIn: arg1  [ arg1 isPowerOfTwo ] assert.  arg1 < 2 ifTrue: [ ^arg1 ].  ^self honeIn: arg1 step: arg1 // 2 measure: (self measureFor: arg1) withIn: self leewayprintOn: arg1  self storeOn: arg1enable  self enabled: truedelete  morphDeleted := true.  super deleteinitializeLabelArea  super initializeLabelArea.  self removeBoxes.  self replaceBoxesexpand: arg1  rootItems do: [:arg2 |  arg2 expandToDepth: arg1 ]rightOffset: arg1  rightOffset := arg1handlesGestureStart: arg1  ^self existsSubscriptionsFor: #gestureStartroundedCorners  self wasActivatedFromDockingBar ifTrue: [ activatorDockingBar isFloating ifTrue: [ ^#(2 3) ].        activatorDockingBar isAdheringToTop ifTrue: [ ^#(2 3) ].        activatorDockingBar isAdheringToBottom ifTrue: [ ^#(1 4) ].        activatorDockingBar isAdheringToLeft ifTrue: [ ^#(3 4) ].        activatorDockingBar isAdheringToRight ifTrue: [ ^#(1 2) ] ].  ^super roundedCornerstextEntry: arg1 title: arg2 entryText: arg3  ^self theme textEntryIn: self text: arg1 title: arg2 entryText: arg3pressedButtonBorderStyle  ^self theme scrollbarPressedButtonBorderStyleFor: selfbuttonString  | tmp1 |  tmp1 := ''.  self redButtonPressed ifTrue: [ tmp1 := tmp1 , 'red ' ].  self yellowButtonPressed ifTrue: [ tmp1 := tmp1 , 'yellow ' ].  self blueButtonPressed ifTrue: [ tmp1 := tmp1 , 'blue ' ].  ^tmp1setFramesForLabelArea  self theme configureDialogWindowLabelAreaFrameFor: selfhHideOrShowScrollBar  self hIsScrollbarNeeded ifTrue: [ self hShowScrollBar ] ifFalse: [ self hHideScrollBar ]addPolyLIneCurveMenuItems: arg1 hand: arg2  arg1     addLine;     addUpdating: #openOrClosePhrase target: self selector: #toggleOpenOrClosed.  arg1 addUpdating: #smoothOrSegmentedPhrase target: self selector: #toggleSmoothingbounds: arg1 from: arg2  owner ifNil: [ ^arg1 ].  ^(owner transformFrom: arg2) globalBoundsToLocal: arg1getCurrentSelectionIndex  self getIndexSelector ifNil: [ ^0 ].  ^self model perform: self getIndexSelectortestDoubleClickFromMorph  morph eventHandler on: #doubleClick send: #value to: true.  self assert: (morph doubleClick: nil) identicalTo: truedrawSubmorphsOn: arg1  arg1 transformBy: transform clippingTo: self innerBounds during: [:arg2 |  (self angle ~= 0.0 or: [ self scale ~= 1.0 ]) ifTrue: [ FreeTypeSettings current forceNonSubPixelDuring: [ submorphs reverseDo: [:arg3 |  arg2 fullDrawMorph: arg3 ] ] ] ifFalse: [ submorphs reverseDo: [:arg3 |  arg2 fullDrawMorph: arg3 ] ] ] smoothing: smoothingnewHSVSelector: arg1 help: arg2  ^self theme newHSVSelectorIn: self color: arg1 help: arg2newExpander: arg1  ^self theme newExpanderIn: self label: arg1 forAll: #()takesKeyboardFocus  ^truetestSelectableIndexBefore  self should: [ strategy selectableIndexBefore: 2 ] raise: ErrorbuttonSetup  self actWhen: #buttonUp.  self cornerStyle: #rounded.  self borderNormal.  self on: #mouseEnter send: #borderRaised to: self.  self on: #mouseLeave send: #borderNormal to: self.  self on: #mouseLeaveDragging send: #borderNormal to: self.  self on: #mouseDown send: #borderInset to: self.  self on: #mouseUp send: #borderRaised to: selfadoptPaneColor: arg1  self submorphsDo: [:arg2 |  arg2 adoptPaneColor: arg1 ]update: arg1  arg1 = #relabel ifTrue: [ ^model ifNotNil: [ self setLabel: model labelString ] ].  arg1 = #close ifTrue: [ self delete ]