repelsMorph: aMorph event: ev  (aMorph wantsToBeDroppedInto: self) ifFalse: [ ^false ].  self dropEnabled ifFalse: [ ^true ].  (self wantsDroppedMorph: aMorph event: ev) ifFalse: [ ^true ].  ^super repelsMorph: aMorph event: evname  ^self item namefillStyle: aFillStyle  backgroundColor := aFillStyle asColor.  super fillStyle: aFillStylehShowScrollBar  self hIsScrollbarShowing ifTrue: [ ^self ].  self hResizeScrollBar.  self privateAddMorph: hScrollBar atIndex: 1.  self resetExtentallMorphsDo: aBlock  super allMorphsDo: aBlock.  worldState handsReverseDo: [:h |  h allMorphsDo: aBlock ]doActivate  self subclassResponsibilityparentNode: aNode  parentNode := aNodeactualScreenSize  self subclassResponsibilitynewEditableDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel ghostText: ghostText getEnabled: enabledSel help: helpText  ^self theme newEditableDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: String default: '' ghostText: ghostText getEnabled: enabledSel useIndex: false help: helpTextuseFindReplaceSelection  ^TextEditor useFindReplaceSelectionnewLabel: aString  ^self newLabelFor: nil label: aString getEnabled: niladdCustomMenuItems: aMenu hand: aHandMorph  super addCustomMenuItems: aMenu hand: aHandMorph.  aMenu addLine.  aMenu addUpdating: #autoGradientString selector: #toggleAutoGradient.  self isFloating ifFalse: [ aMenu addUpdating: #fillsOwnerString selector: #toggleFillsOwner.        aMenu addUpdating: #avoidVisibleBordersAtEdgeString selector: #toggleAvoidVisibleBordersAtEdge ]highlightRowIndexes: anArray  self deprecated: 'Use #highlightIndexes: instead' transformWith: '`@receiver highlightRowIndexes: `@statements1' -> '`@receiver highlightIndexes: `@statements1'.  self highlightIndexes: anArrayrestoreSavedPatchOn: aCanvas  | cursor |  hasChanged := false.  savedPatch ifNotNil: [ aCanvas drawImage: savedPatch at: savedPatch offset.        submorphs notEmpty ifTrue: [ ^self ].        (temporaryCursor notNil and: [ hardwareCursor isNil ]) ifTrue: [ ^self ].        super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset) from: self.        cursor := hardwareCursor ifNil: [ Cursor normal ].        cursor isCurrent ifFalse: [ cursor show ].        savedPatch := nil ]defaultAttachmentPointSpecs  ^{{#firstVertex} .   {#midpoint} .   {#lastVertex}}valueParameter  ^valueParameterdefaultWidth  ^22target: aMorph  defaultTarget := aMorphverticalScrollBarValue: aNumber  self hasDataSource ifFalse: [ ^self ].  showIndex := self verticalScrollBarValueToRowIndex: aNumber.  self container changedvResizing: aSymbol  self assureLayoutProperties vResizing: aSymbol.  self layoutChangedcellColumn: column row: rowIndex  | item cell |  item := self elementAt: rowIndex.  cell := FTIndentedCellMorph new.  cell indentBy: item depth * 16.  cell addMorphBack: (self buttonFor: item).  cell addMorphBack: (self toString: item data) asMorph.  ^cellrowMorphFor: aNode  | rowMorph |  rowMorph := self rowMorphGetSelector ifNil: [ aNode rowMorphForColumn: self ] ifNotNil: [ self rowMorphGetterBlock value: aNode value: self container ].  rowMorph := rowMorph asMorph.  rowMorph ifNotNil: [ rowMorph borderWidth: 0 ] ifNil: [ rowMorph := self defaultRowMorph ].  ^rowMorph rowMorphForNode: aNode inColumn: selflayoutInset  ^self layoutProperties ifNil: [ 0 ] ifNotNil: [:props |  props layoutInset ]over: anObject  over := anObject.  self changedcontents  ^self target perform: nameSelectoraddSubmorphsFromNodeList: aNodeList previouslyExpanded: expandedNodeList  | morphList |  morphList := OrderedCollection new.  self addMorphsTo: morphList from: aNodeList withExpandedItems: expandedNodeList atLevel: 0.  self insertNewMorphs: morphList.  self listManager updateSelectionFromModel.  self roots do: [:r |  r updateChildrenRecursively ].  self updateColumnMorphsisWorldOrHandMorph  ^self isWorldMorph or: [ self isHandMorph ]closeBoxClicked  owner ifNotNil: [:o |  o delete ]numSelectionsInView  ^scroller numberOfItemsPotentiallyInViewisHandMorph  ^falsebottomVisibleRowForCanvas: aCanvas startingAt: aPos  ^self rowAtLocation: aCanvas clipRect bottomRight startingAt: aPostestIsAfterColumn  self deny: (strategy is: 3 afterColumn: 4).  self deny: (strategy is: 3 afterColumn: 3).  self deny: (strategy is: 3 afterColumn: 2)newToolbarHandle  ^self theme newToolbarHandleIn: selfoldSize  ^oldSizeresetListSelectionSilently  self resetListSelector ifNotNil: [:sel |  self model perform: sel ]mouseEnterDragging: evt  | row oldPDR |  self enabled ifFalse: [ ^self ].  row := self rowAtLocation: evt position.  (self dragEnabled or: [ evt hand hasSubmorphs ]) ifFalse: [ row = 0 ifTrue: [ ^self ].        self listMorph mouseDownRow: row ].  (evt hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: evt ].  potentialDropRow = row ifTrue: [ ^self ].  oldPDR := potentialDropRow.  potentialDropRow := row.  evt hand newMouseFocus: self.  (self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifTrue: [ self changed ] ifFalse: [ (oldPDR ifNil: [ 0 ]) > 0 ifTrue: [ self resetPotentialDropRow ] ifFalse: [ potentialDropRow := 0 ] ]drawSubmorphsOnAthensCanvas: anAthensCanvas  | drawBlock |  submorphs isEmpty ifTrue: [ ^self ].  drawBlock := [:canvas |  | i |  (self topVisibleRowForCanvas: anAthensCanvas) to: (self bottomVisibleRowForCanvas: anAthensCanvas) do: [:row |  i := self item: row.        canvas fullDrawMorph: i ] ].  self clipSubmorphs ifTrue: [ anAthensCanvas clipBy: (anAthensCanvas clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: drawBlock ] ifFalse: [ drawBlock value: anAthensCanvas ]linkSubmorphsToSplitters  self splitters do: [:each |  each splitsTopAndBottom ifTrue: [ self submorphsDo: [:eachMorph |  (eachMorph ~= each and: [ eachMorph layoutFrame bottomFraction = each layoutFrame topFraction ]) ifTrue: [ each addLeftOrTop: eachMorph ].                    (eachMorph ~= each and: [ eachMorph layoutFrame topFraction = each layoutFrame bottomFraction ]) ifTrue: [ each addRightOrBottom: eachMorph ] ] ] ifFalse: [ self submorphsDo: [:eachMorph |  (eachMorph ~= each and: [ eachMorph layoutFrame rightFraction = each layoutFrame leftFraction ]) ifTrue: [ each addLeftOrTop: eachMorph ].                    (eachMorph ~= each and: [ eachMorph layoutFrame leftFraction = each layoutFrame rightFraction ]) ifTrue: [ each addRightOrBottom: eachMorph ] ] ] ]vScrollbarShowWhenNeeded  self vScrollbar showWhenNeeded.  self updateScrollbarscomputeBounds  [ self doLayoutIn: self layoutBounds ] on: Error do: [:ex |  fullBounds := bounds.        ex pass ]hash  ^firstIndex hash bitXor: lastIndex hashunexpandedFrame: aRectangle  ^self setProperty: #unexpandedFrame toValue: aRectanglewantsDroppedObject: anotherItem  ^model wantsDroppedNode: anotherItem on: selfitemClass  ^self parentNode parentNode itemnotExpandedFormForMorph: aMorph  ^(self selectedMorph = aMorph and: [ self theme selectionColor luminance < 0.6 ]) ifTrue: [ self theme whiteTreeUnexpandedForm ] ifFalse: [ self theme treeUnexpandedForm ]addHand: aHandMorph  aHandMorph owner ifNotNil: [ aHandMorph owner removeHand: aHandMorph ].  worldState addHand: aHandMorph.  aHandMorph privateOwner: selfsearchText: aString  aString isEmptyOrNil ifTrue: [ ^#() ].  self elements withIndexDo: [:each :index |  (each name beginsWith: aString) ifTrue: [ ^{index} ] ].  ^#()addMorphsAfter: parentMorph fromCollection: aCollection  | priorMorph morphList subs |  priorMorph := nil.  morphList := OrderedCollection new.  aCollection do: [:item |  priorMorph := self indentingItemClass new initWithContents: item prior: priorMorph forList: self indentLevel: parentMorph indentLevel + 1.        morphList add: priorMorph.        priorMorph isExpanded ifTrue: [ priorMorph isExpanded: true.              priorMorph addChildrenForList: self addingTo: morphList withExpandedItems: #() ] ].  1 to: morphList size do: [:i |  | m |        (m := morphList at: i) index: i + parentMorph index ].  scroller addAllMorphs: morphList after: parentMorph.  subs := self allNodeMorphs.  morphList last index to: subs size do: [:pos |  (subs at: pos) index: pos ].  self updateColumnMorphsWidth.  morphList do: [:e |  e doLayoutIn: e layoutBounds ].  ^morphListinitialize  subscriptions := Dictionary newinitializeProcessMouseOver  leftMorphs := mouseOverMorphs asIdentitySet.  overMorphs := WriteStream on: (Array new: leftMorphs size).  enteredMorphs := WriteStream on: #()bounds  | bounds theText |  self fillsOwner ifFalse: [ ^textMorph textBounds ].  theText := textMorph.  bounds := theText owner innerBounds.  bounds := bounds insetBy: (textMorph valueOfProperty: #margins ifAbsent: [ 1 @ 1 ]).  theText owner submorphsBehind: theText do: [:m |  bounds := bounds merge: m fullBounds ].  ^boundsnormalFillStyle  ^self theme windowEdgeNormalFillStyleFor: selfaddFillStyleMenuItems: aMenu hand: aHand  | menu |  menu := UIManager default newMenuIn: self for: self.  self fillStyle addFillStyleMenuItems: menu hand: aHand from: self.  menu addLine.  menu add: 'solid fill' selector: #useSolidFill.  menu add: 'gradient fill' selector: #useGradientFill.  menu add: 'bitmap fill' selector: #useBitmapFill.  menu add: 'default fill' selector: #useDefaultFill.  aMenu add: 'fill style' subMenu: menuvIsScrollbarShowing  ^submorphs includes: scrollBarscrollDeltaHeight  ^self font heighttestRightBottomQuadrant  | lf rectangle |  lf := LayoutFrame new     leftFraction: 1 / 2 offset: 1;     topFraction: 1 / 2 offset: 1;     rightFraction: 1 offset: -2;     bottomFraction: 1 offset: -2;     yourself.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (101 @ 41 corner: 148 @ 68) equals: rectangletarget  ^modeldialogWindow  ^self ownerThatIsA: DialogWindowisShowColumnHeaders  ^showColumnHeadersspotterPreviewMenuIn: aComposite  < spotterPreview: 10>  aComposite list     title: [ self contents ];     display: #yourself;     format: [:item |  GTSpotterItemBrick new           text: item contents;           icon: item icon;           disable;           yourself ];     styled: [:brick |  brick ];     entity: (self hasSubMenu ifFalse: [ {self} ] ifTrue: [ self subMenu allItems ]).  self flag: 'move "entity: self" somewhere else, maybe'itemShortcut  ^ToggleMenuItemShortcut owner: self keyText: self keyTextroots  ^scroller submorphs select: [:each |  each indentLevel isZero ]beCheckbox  self     isRadioButton: false;     onImage: self theme checkboxMarkerForm;     cornerStyle: (self theme checkboxCornerStyleFor: self);     fillStyle: self fillStyleToUse;     borderStyle: self borderStyleToUseattachKeymapCategory: aCategory  self kmDispatcher attachCategory: aCategoryascendingSortFunction  ^[:entity |  self property value: entity ] ascendingcursorPoint  ^self currentHand lastEvent cursorPointmouseEnter: evt  super mouseEnter: evt.  (owner notNil and: [ owner isKindOf: EmbeddedMenuMorph ]) ifTrue: [ owner selectedItem ~~ self ifTrue: [ owner selectItem: self event: evt ] ]setGrabbedColor  self fillStyle: self pressedFillStyleselectedMorph  ^(TickSelectionCheckboxMorph basicNew     index: (self model rootItems indexOf: self item);     initialize;     model: self item;     getStateSelector: #selected;     setStateSelector: #selected:;     updateSelection;     getEnabledSelector: nil;     font: StandardFonts defaultFont;     label: '';     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     setBalloonText: nil)     color: Color transparent;     yourselfisDraggingEvent  source ifNil: [ ^false ].  source hasSubmorphs ifTrue: [ ^true ].  self anyButtonPressed ifTrue: [ ^true ].  ^falsedashedBorder  ^borderDashSpecscrollBarMenuButtonPressed: event  ^self yellowButtonActivity: event shiftPressedtakesKeyboardFocus  ^truemouseDown: event on: aTargetMorph  | clickedTheCheckbox |  clickedTheCheckbox := self clicked: event inTheCheckboxOf: aTargetMorph.  (self autoMultiSelection and: [ event shiftPressed not ]) ifTrue: [ firstClickedMorph := aTargetMorph.        aTargetMorph selected ifTrue: [ self removeFromSelection: aTargetMorph.              (clickedTheCheckbox not and: [ self selectOnlyLastHighlighted and: [ aTargetMorph hasContentToShow ] ]) ifTrue: [ aTargetMorph = self lastClickedMorph ifFalse: [ self addToSelection: aTargetMorph ] ] ] ifFalse: [ (clickedTheCheckbox not and: [ self selectOnlyLastHighlighted and: [ aTargetMorph hasContentToShow ] ]) ifTrue: [ aTargetMorph = self lastClickedMorph ifTrue: [ self addToSelection: aTargetMorph.                          clickedTheCheckbox ifFalse: [ self lastClickedMorph: aTargetMorph ] ] ] ifFalse: [ self addToSelection: aTargetMorph.                    clickedTheCheckbox ifFalse: [ self lastClickedMorph: aTargetMorph ] ] ] ].  (clickedTheCheckbox not and: [ event shiftPressed not or: [ firstClickedMorph isNil ] ]) ifTrue: [ firstClickedMorph := aTargetMorph ].  aTargetMorph mouseDown: eventrequestView: anAnnouncement  ^self announcer announce: anAnnouncementmouseMove: event  event isDraggingEvent ifFalse: [ ^self ].  event hand hasSubmorphs ifFalse: [ ^self ].  (self wantsDroppedMorph: event hand submorphs first event: event) ifFalse: [ ^self ].  (self container rowIndexContainingPoint: event position) ifNotNil: [:rowIndex |  self basicHighlightIndexes: {rowIndex}.        self refresh ].  (self container bounds containsPoint: event position) ifFalse: [ ^self ].  event position y <= (self container top + self autoScrollHeightLimit) ifTrue: [ ^self verticalScrollBar scrollUp: 1 ].  event position y >= (self container bottom - self autoScrollHeightLimit) ifTrue: [ ^self verticalScrollBar scrollDown: 1 ]framePolygon: vertices on: aCanvas  self framePolyline: vertices on: aCanvas.  self drawLineFrom: vertices last to: vertices first on: aCanvasfirstOwnerSuchThat: conditionBlock  self allOwnersDo: [:m |  (conditionBlock value: m) ifTrue: [ ^m ] ].  ^nilreleaseCachedState  (model ~~ self and: [ model respondsTo: #releaseCachedState ]) ifTrue: [ model releaseCachedState ].  super releaseCachedStateinitializeScroller  scroller := self newTransformMorph color: Color transparent.  scroller offset: self hMargin negated @ 0.  self addMorph: scrollermouseDown: anEvent  | cp |  cp := anEvent cursorPoint.  lastMouse := {cp .   (cp - self position) .   (cp - self targetPoint)}autoMultiSelection  ^autoMultiSelection ifNil: [ autoMultiSelection := false ]layoutChanged  fullBounds := nil.  self layoutPolicy ifNotNil: [:l |  l flushLayoutCache ]isInterruptable  ^self class isInterruptableisMenuItemMorph  ^trueadoptColor: aColor  self paneColorChangednewAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletionfitScrollTarget  | extra |  extra := 0.  self scroller width > self scrollTarget width ifTrue: [ self scrollTarget width: self scroller width ] ifFalse: [ extra := self scrollBarThickness ].  self scroller height - extra > self scrollTarget height ifTrue: [ self scrollTarget height: self scroller height + extra ]updateLayoutInDockingBar  owner isVertical ifTrue: [ self hResizing: #spaceFill.        self vResizing: #shrinkWrap ] ifFalse: [ self hResizing: #shrinkWrap.        self vResizing: #spaceFill ].  self extent: self minWidth @ self minHeightmouseUp: event  super mouseUp: event.  self stopSteppingSelector: #autoScrollView:.  editView selectionInterval: editor selectionIntervalnewScrollPaneFor: aMorph  ^self theme newScrollPaneIn: self for: aMorphhasIconBlock  ^iconBlock notNilshowOrHideHandles  self showingHandles ifTrue: [ self removeHandles ] ifFalse: [ self addHandles ]setPageSize: anIntegerOrNil  pageSize := anIntegerOrNilisFlexMorph  ^falsecomposer  ^composer ifNil: [ composer := TextComposer new ]normalBorderStyle  ^self theme buttonNormalBorderStyleFor: selflineBorderColor: aColor  self borderColor: aColoralignCentersVertically  | minTop topMost |  selectedItems size > 1 ifFalse: [ ^self ].  minTop := (selectedItems collect: [:itm |  itm top ]) min.  topMost := selectedItems detect: [:m |  m top = minTop ].  selectedItems do: [:itm |  itm center: topMost center x @ itm center y ].  self changedrotationDegrees: degrees  initialize  min := 0.  max := 1.  label := ''.  super initialize.  self enabled: trueremoveCloseBox  closeBox ifNotNil: [ closeBox delete.        closeBox := nil ]layoutProperties  ^layoutPropertiesslideOneLineDown  | priorLine |  prevIndex < prevLines size ifFalse: [ ^nowSliding := possibleSlide := false ].  prevIndex := prevIndex + 1.  priorLine := (prevLines at: prevIndex) slideIndexBy: deltaCharIndex andMoveTopTo: currentY.  lines addLast: priorLine.  currentY := priorLine bottom.  currCharIndex := priorLine last + 1.  wantsColumnBreaks ifTrue: [ priorLine first to: priorLine last do: [:i |  (theText at: i) = TextComposer characterForColumnBreak ifTrue: [ nowSliding := possibleSlide := false.                    ^nil ] ] ]resizeScroller  scroller bounds: self innerBoundskeyboardListeners  ^nilshouldCopy: aBoolean  copy := aBooleanstepListSize  ^stepList sizebeSingle  self listManager multipleSelection: falseselectedRow  ^selectedRowresetHScrollRangeIfNecessary  hScrollRangeCache ifNil: [ ^self deriveHScrollRange ].  (list isNil or: [ list isEmpty ]) ifTrue: [ ^hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0 ].  (hScrollRangeCache third == list size and: [ hScrollRangeCache fourth == list first and: [ hScrollRangeCache fifth == list last ] ]) ifFalse: [ self deriveHScrollRange ]drawDropShadowOn: aCanvas  self assert: [ vertices notEmpty ] description: 'a polygon must have at least one point'.  closed ifTrue: [ aCanvas drawPolygon: self getVertices fillStyle: self shadowColor ]sharesFindReplace  ^falseadjustLayoutBounds  | hFit vFit box myExtent extent |  hFit := self hResizing.  vFit := self vResizing.  (hFit == #shrinkWrap or: [ vFit == #shrinkWrap ]) ifFalse: [ ^self ].  box := self layoutBounds.  myExtent := box extent.  extent := self submorphBounds corner - box origin.  hFit == #shrinkWrap ifTrue: [ myExtent := extent x @ myExtent y ].  vFit == #shrinkWrap ifTrue: [ myExtent := myExtent x @ extent y ].  myExtent x < self minWidth ifTrue: [ myExtent := (myExtent x max: self minWidth - self bounds width + self layoutBounds width) @ myExtent y ].  myExtent y < self minHeight ifTrue: [ myExtent := myExtent x @ (myExtent y max: self minHeight - self bounds height + self layoutBounds height) ].  self layoutBounds: (box origin extent: myExtent)dropNode: srcNode on: dstNode  dropItemSelector ifNil: [ ^nil ].  model perform: dropItemSelector with: srcNode item with: dstNode itemannounceKeyboardFocusChange: gotFocus  | announcement |  announcement := gotFocus ifTrue: [ MorphGotFocus morph: self ] ifFalse: [ MorphLostFocus morph: self ].  self doAnnounce: announcement.  Morph announcer announce: announcementmenu: aMenu  menu := aMenuaddEmphaseTo: lab  self model isActive ifFalse: [ ^self ].  lab emphasis: 1enterClickableRegion: evt  evt hand hasSubmorphs ifTrue: [ ^self ].  evt hand temporaryCursor ifNotNil: [ ^self ]getCurrentSelectionItem  ^model perform: (getSelectionSelector ifNil: [ ^nil ])addGrowHandle: haloSpec  target shouldFlex ifFalse: [ (self addHandle: haloSpec on: #mouseDown send: #startGrow:with: to: self) on: #mouseMove send: #doGrow:with: to: self ]pager  ^pagerinitialExtent  ^(self valueOfProperty: #initialExtent) ifNil: [ 700 @ 500 ] ifNotNil: [:ext |  ext ]innerTarget  ^innerTargetballoonOwner  ^balloonOwnerinitialize  worldState := WorldState new.  super initialize.  SystemAnnouncer uniqueInstance weak when: FullscreenAnnouncement send: #fullscreenChanged: to: self.  Smalltalk tools whenToolRegistered: [:tool :toolName |  WorldState defaultWorldMenu ].  Smalltalk tools whenToolUnregistered: [:tool :toolName |  WorldState defaultWorldMenu ]addAlarm: aSelector at: scheduledTime  ^self addAlarm: aSelector withArguments: #() at: scheduledTimemakeClosable  mustNotClose := false.  closeBox ifNil: [ closeBox := self createCloseBox.        self replaceBoxes ]submorphBefore  | ii |  owner ifNil: [ ^nil ].  ^(ii := owner submorphIndexOf: self) = 1 ifTrue: [ nil ] ifFalse: [ owner submorphs at: ii - 1 ]action: aValue  action := aValuestandardArrows  self removeProperty: #arrowSpec.  self computeBoundshandlesMouseOver: evt  self eventHandler ifNotNil: [ ^self eventHandler handlesMouseOver: evt ].  ^falsenotOnLastPage  ^self onLastPage notokayToAddDismissHandle  ^self resistsRemoval notsetInverseColors  handleColor := Color lightGray.  dotColor := Color whitemodel  ^modelvScrollBarValue: scrollValue  super vScrollBarValue: scrollValue.  self pager ifNotNil: [:p |  p vScrollBarValue: scrollValue ]drawMouseDownHighlightOn: aCanvas  self highlightedForMouseDown ifTrue: [ aCanvas frameRectangle: self fullBounds color: self color darker darker ]testNoIconWithoutSorting  column disableSort.  self assert: column sortingIcon isNiladdChildrenForList: hostList addingTo: morphList withExpandedItems: expandedItems  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aNode delete ].        firstChild := nil ].  complexContents hasContents ifFalse: [ ^self ].  firstChild := hostList addMorphsTo: morphList from: complexContents contents withExpandedItems: expandedItems atLevel: indentLevel + 1composeAllRectangles: rectangles  | charIndexBeforeLine numberOfLinesBefore reasonForStopping |  actualHeight := defaultLineHeight.  charIndexBeforeLine := currCharIndex.  numberOfLinesBefore := lines size.  reasonForStopping := self composeEachRectangleIn: rectangles.  currentY := currentY + actualHeight.  currentY > theContainer bottom ifTrue: [ currCharIndex := charIndexBeforeLine.        lines size - numberOfLinesBefore timesRepeat: [ lines removeLast ].        ^self ].  maxRightX := maxRightX max: scanner rightX.  1 to: rectangles size - 1 do: [:i |  (lines at: lines size - rectangles size + i) lineHeight: lines last lineHeight baseline: lines last baseline ].  isFirstLine := false.  reasonForStopping == #columnBreak ifTrue: [ ^nil ].  currCharIndex > theText size ifTrue: [ ^nil ]newColor: anObject  newColor := anObjectgetList  getListSelector ifNil: [ ^#() ].  list := model perform: getListSelector.  list ifNil: [ ^#() ].  ^listnewImage: aForm size: aPoint  ^self theme newImageIn: self form: aForm size: aPointinitialize  super initialize.  self     setLabel: self defaultLabel;     setWindowColor: self defaultColortextEntry: aStringOrText  ^self textEntry: aStringOrText title: 'Entry' translatedvPageDelta  | pd tw sw |  tw := self scrollTarget height.  sw := self scrollBounds height.  pd := tw - sw max: 0.  pd = 0 ifFalse: [ pd := sw / pd ].  ^pdnewStateForEnabled: aBoolean  ^TabEnabled tab: self tabsmoothing  ^smoothingdrawRowsOn: canvas  | x y cellWidth cellHeight rowsToDisplay rowSubviews highligtedIndexes primarySelectionIndex |  self canRefreshValues ifFalse: [ ^self ].  x := self left + self class rowLeftMargin.  y := self top.  cellWidth := self width - self class rowLeftMargin.  cellHeight := self table rowHeight rounded.  highligtedIndexes := self table selectedIndexes , self table highlightedIndexes.  primarySelectionIndex := self table selectedIndex.  self updateAllRows.  rowsToDisplay := self exposedRows.  rowSubviews := OrderedCollection new: rowsToDisplay size + 1.  headerRow ifNotNil: [ headerRow bounds: (self left @ y extent: self width @ cellHeight).        y := y + cellHeight + self table intercellSpacing y.        rowSubviews add: headerRow ].  rowsToDisplay keysAndValuesDo: [:rowIndex :row |  | visibleHeight |        visibleHeight := (self rowHeight: rowIndex default: cellHeight) min: self bottom - y.        row bounds: (x @ y extent: cellWidth @ visibleHeight).        y := y + visibleHeight + self table intercellSpacing y.        rowSubviews add: row.        (self table selectionModeStrategy selectablesToHighlightFromRow: row at: rowIndex withHighlightedIndexes: highligtedIndexes andPrimaryIndex: primarySelectionIndex) keysAndValuesDo: [:morph :isPrimary |  morph selectionColor: (self table colorForSelection: isPrimary) ] ].  submorphs do: [:each |  each           privateOwner: nil;           outOfWorld: self world ].  submorphs := rowSubviews asArray.  submorphs do: [:each |  each intoWorld: self world ].  self table isResizable ifTrue: [ self addResizeSplitters ].  needsRefreshExposedRows := falserotationDegrees: degrees  halo: newHalo  | oldHalo |  oldHalo := self halo.  (oldHalo isNil or: [ oldHalo == newHalo ]) ifFalse: [ oldHalo delete ].  newHalo ifNil: [ self removeProperty: #halo ] ifNotNil: [ self setProperty: #halo toValue: newHalo ]previousWindow  | sys |  sys := self systemWindows.  sys ifEmpty: [ ^nil ].  ^sys before: self currentWindow ifAbsent: [ sys last ]handleEvent: anEvent  | evt |  owner ifNil: [ ^self ].  evt := anEvent.  EventStats ifNotNil: [ self class logEventStats: evt ].  evt isMouse ifTrue: [ lastMouseEvent := evt ].  captureBlock ifNotNil: [ ^captureBlock value: anEvent ].  evt isMouseOver ifTrue: [ ^self sendMouseEvent: evt ].  self showDebugEvent: evt.  self sendListenEvent: evt to: self eventListeners.  evt isWindowEvent ifTrue: [ self sendEvent: evt focus: nil.        ^self mouseOverHandler processMouseOver: lastMouseEvent ].  evt isKeyboard ifTrue: [ self sendListenEvent: evt to: self keyboardListeners.        self sendKeyboardEvent: evt.        ^self mouseOverHandler processMouseOver: lastMouseEvent ].  evt isDropEvent ifTrue: [ self sendEvent: evt focus: nil.        ^self mouseOverHandler processMouseOver: lastMouseEvent ].  evt isMouse ifTrue: [ self sendListenEvent: evt to: self mouseListeners.        lastMouseEvent := evt ].  mouseClickState ifNotNil: [ (mouseClickState handleEvent: evt from: self) ifFalse: [ ^self mouseOverHandler processMouseOver: lastMouseEvent ] ].  evt isMove ifTrue: [ | pos |        pos := evt position.        evt isDraggingEvent ifTrue: [ | treshold |              treshold := 0.              (self submorphs at: 1 ifAbsent: [ nil ]) ifNotNil: [:first |  treshold := self top - first top ].              pos y < (self class upperHandLimit + treshold) ifTrue: [ pos := pos x @ (self class upperHandLimit + treshold) ] ].        self position: pos.        self sendMouseEvent: evt ] ifFalse: [ evt position = self position ifFalse: [ self moveToEvent: evt ].        self hasSubmorphs ifTrue: [ self dropMorphs: evt ] ifFalse: [ self sendMouseEvent: evt ] ].  self showMouseFocusEvent: evt.  self mouseOverHandler processMouseOver: lastMouseEventescapePressed  date  ^datechangeDocumentAnchor  | newType |  newType := self textAnchorType == #document ifTrue: [ #paragraph ] ifFalse: [ #document ].  owner isTextMorph ifTrue: [ owner anchorMorph: self at: self position type: newType ]addCustomMenuItems: aCustomMenu hand: aHandMorph  actionOffset  ^4 * self displayScaleFactornewToolbarHandle  ^self theme newToolbarHandleIn: selfremoveTaskbar  self taskbars do: [:each |  each removeFromWorld ]closeWindowAction  self cancelmouseWheel: evt  addMorphFront: aMorph fromWorldPosition: wp  aMorph textAnchorType == #document ifFalse: [ ^self anchorMorph: aMorph at: wp type: aMorph textAnchorType ].  self addMorphFront: aMorphnewString: aStringOrText style: aStyle  ^self theme newStringIn: self label: aStringOrText font: self theme labelFont style: aStyleonFirstPage  ^self currentPageFirstIndex = 1addTitle: aString icon: aForm  aForm ifNil: [ ^self addTitle: aString ].  self buildTitle: [:tm |  tm           title: aString;           icon: aForm ]defaultBorderColor  ^#raisedocclusionsOnOff  self setContainer: (container ifNil: [ (TextContainer new for: self minWidth: textStyle lineGrid * 2)                 fillsOwner: false;                 avoidsOcclusions: true ] ifNotNil: [ (container avoidsOcclusions and: [ container fillsOwner not ]) ifTrue: [ nil ] ifFalse: [ container avoidsOcclusions: container avoidsOcclusions not ] ])dragEnabled: aBool  ^self enableDrag: aBoolgetValueSelector: anObject  getValueSelector := anObjectmaxCellSize  | props |  props := self layoutProperties.  ^props ifNil: [ SmallInteger maxVal ] ifNotNil: [ props maxCellSize ]wantsDropFiles: anEvent  ^falseinitialize  super initialize.  submorphs := EmptyArray.  bounds := self defaultBounds.  color := self defaultColordeny: aStringOrText  ^self deny: aStringOrText title: 'Access Denied' translatedsetDirection: anEvent with: directionHandle  anEvent hand obtainHalo: self.  target setDirectionFrom: directionHandle center.  self endInteractionselectAll  self requestView: MorphTreeChangeRequest selectAllresizeCursor  ^Cursor resizeForEdge: #bottomLefton: anObject getState: getStateSel action: actionSel label: labelSel icon: iconSel menu: menuSel  super on: anObject getState: getStateSel action: actionSel label: labelSel icon: iconSel menu: menuSel.  self pressed: super getModelStatescrollTabsLeft  self visibleTabRange: (self visibleTabRange first < 2 ifTrue: [ 0 to: self tabs size ] ifFalse: [ 0 to: self visibleTabRange first - 1 ]).  self updateTabsnewExpander: aString for: aControl  ^self theme newExpanderIn: self label: aString forAll: {aControl}doesBevels  ^falseactionOn: aBrowser  ^actionIcon ifNil: [ actionIcon := self createActionIconOn: aBrowser ]updatePanesFromSubmorphs  paneMorphs := paneMorphs select: [:pane |  submorphs includes: pane ]add: aLabelString target: target selector: aSymbol argumentList: argList  ^self addToggle: aLabelString target: target selector: aSymbol getStateSelector: nil enablementSelector: nil argumentList: argListfillStyleToUse  ^self fillStyleensureSelectedTabIsVisible  (self selectedIndex > 0 and: [ (self visibleTabRange includes: self selectedIndex) not ]) ifTrue: [ self visibleTabRange: (self selectedIndex to: 0).        self updateTabs ]hideScrollBars  self     vHideScrollBar;     hHideScrollBardrawArrowsOn: aCanvas  | array |  self hasArrows ifFalse: [ ^#() ].  array := Array with: vertices first with: vertices last.  borderColor isColor ifFalse: [ ^array ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ array at: 2 put: (self drawArrowOn: aCanvas at: vertices last from: self nextToLastPoint) ].  (arrows == #back or: [ arrows == #both ]) ifTrue: [ array at: 1 put: (self drawArrowOn: aCanvas at: vertices first from: self nextToFirstPoint) ].  ^arrayrowMorphsWidths  | result |  result := self headerBounds collect: [:b |  b width ].  result ifNotEmpty: [ result at: 1 put: (result at: 1) - 3 ].  ^resultsetOptimalResizing  self hResizing: #rigid.  self vResizing: #rigidbottom  ^bottomsetDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedmouseStillDown: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseStillDown from: sourceMorphnewTextEditorFor: aModel getText: getSel setText: setSel  ^self newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: nilnavigationKey: aKeyboardEvent  ^self taskList handleEvent: aKeyboardEventselected: aBoolean  self item selected: aBooleanmouseOverPagingAreaThumbBorderStyle  ^self theme scrollbarMouseOverBarThumbBorderStyleFor: selfdoButtonAction  self invokeWithEvent: nilbottomBoundary  | morphs |  morphs := rightOrBottom reject: [:m |  m layoutFrame bottomFraction ~= 1 and: [ m layoutFrame topFraction = m layoutFrame bottomFraction ] ].  morphs ifEmpty: [ ^(self splitterBelow ifNil: [ self containingWindow panelRect bottom ] ifNotNil: [ self splitterBelow first top ]) - 25 ].  ^(morphs collect: [:m |  m bottom - m minExtent y - (m layoutFrame topOffset ifNil: [ 0 ]) + (self layoutFrame bottomOffset ifNil: [ 0 ]) ]) min - self class splitterWidthoverlapsShadowForm: itsShadow bounds: itsBounds  | andForm overlapExtent |  overlapExtent := (itsBounds intersect: self fullBounds ifNone: [ ^false ]) extent.  overlapExtent > (0 @ 0) ifFalse: [ ^false ].  andForm := self shadowForm.  overlapExtent ~= self fullBounds extent ifTrue: [ andForm := andForm contentsOfArea: (0 @ 0 extent: overlapExtent) ].  andForm := andForm copyBits: (self fullBounds translateBy: itsShadow offset negated) from: itsShadow at: 0 @ 0 clippingBox: (0 @ 0 extent: overlapExtent) rule: Form and fillColor: nil.  ^andForm bits anySatisfy: [:w |  w ~= 0 ]goBehind  owner addMorphBack: selfrootsItems  ^rootItem childrenmakeNoArrows  arrows := #none.  self computeBoundsexistsSubscriptionsFor: anEvent  ^(subscriptions includesKey: anEvent) and: [ (subscriptions at: anEvent) notEmpty ]contents  ^contents ifNil: [ contents := super contents ]createLabelMorph: aString  ^aString asStringMorph     font: self labelFont emphasis: 0;     color: textColor;     yourselfasPotentialDropTarget  self model asPotentialDropTargetborderWidth: aWidth  | bordered |  bordered := selectedItems select: [:m |  m isKindOf: BorderedMorph ].  undoProperties ifNil: [ undoProperties := bordered collect: [:m |  m borderWidth ] ].  bordered do: [:m |  m borderWidth: aWidth ]transparentSpacerOfSize: aPoint  ^(Morph new extent: aPoint) color: Color transparentremoveTabIndex: anInteger  self tabs removeAt: anInteger.  self selectedIndex: 0.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ]endShapeWidth: aWidth  | originalWidth originalVertices transform |  originalWidth := self valueOfProperty: #originalWidth ifAbsentPut: [ self borderWidth isZero ifFalse: [ self borderWidth ] ifTrue: [ 2 ] ].  self borderWidth: aWidth.  originalVertices := self valueOfProperty: #originalVertices ifAbsentPut: [ self vertices collect: [:ea |  ea - self referencePosition rotateBy: self heading degreesToRadians about: 0 @ 0 ] ].  transform := MorphicTransform offset: 0 @ 0 angle: self heading degreesToRadians scale: originalWidth / aWidth.  self setVertices: (originalVertices collect: [:ea |  ((transform transform: ea) + self referencePosition) asIntegerPoint ]).  self computeBoundswithHLines  ^withHLines ifNil: [ withHLines := false ]defaultBorderWidth  ^1fillStyles  | styles |  styles := OrderedCollection new.  self stateMap do: [:actives |  actives do: [:enableds |  enableds do: [:overs |  overs do: [:fs |  styles add: fs ] ] ] ].  ^stylesnonCachingFullDrawOn: aCanvas  submorphs isEmpty ifTrue: [ ^self drawOn: aCanvas ].  aCanvas asShadowDrawingCanvas translateBy: self shadowOffset during: [:shadowCanvas |  | shadowForm |        shadowForm := self shadowForm.        shadowCanvas paintImage: shadowForm at: shadowForm offset ].  self drawSubmorphsOn: aCanvas.  self drawOn: aCanvastestSelectAll  table beSingleSelection.  table selectFirst.  table selectAll.  self assert: table selectedIndexes equals: #(#(1 1)).  table beMultipleSelection.  table selectFirst.  table selectAll.  self assert: table selectedIndexes equals: #(#(1 1) #(1 2) #(1 3) #(2 1) #(2 2) #(2 3) #(3 1) #(3 2) #(3 3) #(4 1) #(4 2) #(4 3) #(5 1) #(5 2) #(5 3) #(6 1) #(6 2) #(6 3) #(7 1) #(7 2) #(7 3) #(8 1) #(8 2) #(8 3) #(9 1) #(9 2) #(9 3) #(10 1) #(10 2) #(10 3))allWordingsNotInSubMenus: verbotenSubmenuContentsList  self isStayUpItem ifTrue: [ ^#() ].  subMenu ifNotNil: [ ^(verbotenSubmenuContentsList includes: self contents asString) ifTrue: [ #() ] ifFalse: [ subMenu allWordingsNotInSubMenus: verbotenSubmenuContentsList ] ].  ^Array with: self contents asStringhandlesMouseOver: event  ^falseaddCustomMenuItems: aMenu hand: aHandMorph  super addCustomMenuItems: aMenu hand: aHandMorph.  aMenu addUpdating: #handlesShowingPhrase target: self selector: #showOrHideHandles.  vertices size > 2 ifTrue: [ self addPolyLIneCurveMenuItems: aMenu hand: aHandMorph ].  aMenu add: 'specify dashed line' selector: #specifyDashedLine.  self isOpen ifTrue: [ self addPolyArrowMenuItems: aMenu hand: aHandMorph ] ifFalse: [ self addPolyShapingMenuItems: aMenu hand: aHandMorph ]rejectDropMorphEvent: evt  self formerOwner notNil ifTrue: [ ^self slideBackToFormerSituation: evt ].  self formerPosition ifNotNil: [ ^self vanishAfterSlidingTo: self formerPosition event: evt ]newMenuItem  ^DockingBarMenuItemMorph newrecordFiltering: matchString  self setProperty: #matchString toValue: matchStringpositions  ^#(#topLeft #topRight #center #bottomLeft #bottomRight)flashRects: rectangleList color: aColor  | blt |  blt := (BitBlt toForm: Display)     sourceForm: nil;     sourceOrigin: 0 @ 0;     clipRect: self viewBox;     combinationRule: Form reverse.  rectangleList do: [:r |  | screenRect |        screenRect := r translateBy: self viewBox origin.        blt           destRect: screenRect;           copyBits.        Display           forceToScreen: screenRect;           forceDisplayUpdate.        (Delay forMilliseconds: 15) wait.        blt           destRect: screenRect;           copyBits.        Display           forceToScreen: screenRect;           forceDisplayUpdate ]selectedItemOrItemsOrNil  ^self lastSelectedNode ifNil: [ nil ] ifNotNil: [ self lastSelectedNode item ]defaultYellowButtonMenuEnabled  ^self class defaultYellowButtonMenuEnabledchangeInlineAnchor  | newType |  newType := self textAnchorType == #inline ifTrue: [ #paragraph ] ifFalse: [ #inline ].  owner isTextMorph ifTrue: [ owner anchorMorph: self at: self position type: newType ]closedCubicSlopesOf: knots  | v w x y z n1 D F G H |  n1 := knots size.  n1 < 3 ifTrue: [ self error: 'Less than 3 points makes a poor curve' ].  v := Array new: n1.  w := Array new: n1.  y := Array new: n1.  D := Array new: n1.  x := knots.  z := 1.0 / 4.0.  v at: 2 put: z.  w at: 2 put: z.  y at: 1 put: z * 3.0 * ((x at: 2) - (x at: n1)).  H := 4.0.  F := 3 * ((x at: 1) - (x at: n1 - 1)).  G := 1.  2 to: n1 - 1 do: [:k |  z := 1.0 / (4.0 - (v at: k)).        v at: k + 1 put: z.        w at: k + 1 put: z negated * (w at: k).        y at: k put: z * (3.0 * ((x at: k + 1) - (x at: k - 1)) - (y at: k - 1)).        H := H - (G * (w at: k)).        F := F - (G * (y at: k - 1)).        G := (v at: k) negated * G ].  H := H - ((G + 1) * ((v at: n1) + (w at: n1))).  y at: n1 put: F - ((G + 1) * (y at: n1 - 1)).  D at: n1 put: (y at: n1) / H.  D at: n1 - 1 put: (y at: n1 - 1) - (((v at: n1) + (w at: n1)) * (D at: n1)).  (1 to: n1 - 2) reverseDo: [:k |  D at: k put: (y at: k) - ((v at: k + 1) * (D at: k + 1)) - ((w at: k + 1) * (D at: n1)) ].  ^DannounceScrollChangedFrom: oldIndex to: newIndex  oldIndex = newIndex ifTrue: [ ^self ].  self doAnnounce: ((FTScrollingChanged from: oldIndex to: newIndex)           fastTable: self;           yourself)treeLineDashes  ^treeLineDashes ifNil: [ treeLineDashes := self theme treeLineDashes ]mouseMove: event  self mouseDown: eventtarget: aMorph  target := aMorphdefaultPreviewExtent  ^(320 @ 320) scaledByDisplayScaleFactorforwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]privateAddMorph: aMorph atIndex: index  | oldIndex myWorld itsWorld oldOwner |  (index between: 1 and: submorphs size + 1) ifFalse: [ ^self error: 'index out of range' ].  myWorld := self world.  oldOwner := aMorph owner.  (oldOwner == self and: [ (oldIndex := submorphs indexOf: aMorph) > 0 ]) ifTrue: [ oldIndex < index ifTrue: [ submorphs replaceFrom: oldIndex to: index - 2 with: submorphs startingAt: oldIndex + 1.              submorphs at: index - 1 put: aMorph ] ifFalse: [ oldIndex - 1 to: index by: -1 do: [:i |  submorphs at: i + 1 put: (submorphs at: i) ].              submorphs at: index put: aMorph ] ] ifFalse: [ oldOwner ifNotNil: [ itsWorld := aMorph world.              itsWorld ifNotNil: [ self privateInvalidateMorph: aMorph ].              itsWorld == myWorld ifFalse: [ aMorph outOfWorld: itsWorld ].              oldOwner privateRemove: aMorph.              oldOwner removedMorph: aMorph ].        aMorph privateOwner: self.        submorphs := submorphs copyReplaceFrom: index to: index - 1 with: (Array with: aMorph).        itsWorld == myWorld ifFalse: [ aMorph intoWorld: myWorld ] ].  myWorld ifNotNil: [ self privateInvalidateMorph: aMorph ].  self layoutChanged.  oldOwner == self ifFalse: [ self addedMorph: aMorph.        aMorph noteNewOwner: self ]icon: aForm  icon := aFormchangeListRequest: anAnnounce  self updateListinterval: d  | oldExtent |  oldExtent := slider extent.  interval := d min: 1.0.  self expandSlider.  self computeSlider.  slider extent = oldExtent ifFalse: [ slider fillStyle: self normalThumbFillStyle ]keyStroke: evt  | char selectable |  (self navigationKey: evt) ifTrue: [ ^self ].  char := evt keyCharacter.  char = Character space ifTrue: [ selectedItem ifNotNil: [ selectedItem hasSubMenu ifTrue: [ evt hand newMouseFocus: selectedItem subMenu.                    ^selectedItem subMenu takeKeyboardFocus ] ifFalse: [ ^selectedItem invokeWithEvent: evt ] ].        (selectable := self items) size = 1 ifTrue: [ ^selectable first invokeWithEvent: evt ].        ^self ].  (char = Character arrowLeft or: [ char = Character arrowRight ]) ifTrue: [ (selectedItem notNil and: [ selectedItem hasSubMenu ]) ifTrue: [ evt hand newMouseFocus: selectedItem subMenu.              selectedItem subMenu moveSelectionDown: 1 event: evt.              ^evt hand newKeyboardFocus: selectedItem subMenu ] ].  char = Character arrowUp ifTrue: [ ^self moveSelectionDown: -1 event: evt ].  char = Character arrowDown ifTrue: [ ^self moveSelectionDown: 1 event: evt ].  char = Character pageUp ifTrue: [ ^self moveSelectionDown: -5 event: evt ].  char = Character pageDown ifTrue: [ ^self moveSelectionDown: 5 event: evt ]oldSelectedIndexes  ^oldSelectedIndexesclippingBounds  ^tab modifyClippingBounds: super clippingBoundsactiveEnabledNotOverDownFillStyle: aFillStyle  self stateMap atPath: #(active enabled notOver down) put: aFillStyle.  self changedinitialize  super initialize.  self     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     wrapCentering: #topLeft;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 2;     rubberBandCells: trueworld  ^selfselectedDisabledFillStyle  ^self theme buttonSelectedDisabledFillStyleFor: selfreturnToOldResizingStrategy: aCollection  self submorphs with: aCollection third do: [:aMorph :resizingParameter |  aMorph returnToOldResizingStrategy: resizingParameter ].  self hResizing: aCollection first.  self vResizing: aCollection secondlabel  ^self labelMorph contentsheight  ^bounds heightoverlapsHorizontal: aSplitter  ^aSplitter left <= self right and: [ aSplitter right >= self left ]asString  ^self item packageNamenumSelectionsInView  ^scroller numberOfItemsPotentiallyInViewWith: scroller submorphs last getListSizepageOfNodeIndex: anIndex  ^(anIndex > 0 and: [ anIndex <= self nodeList size ]) ifTrue: [ (anIndex - 1) // pageSize + 1 ] ifFalse: [ nil ]initialize  super initialize.  self     initializeLayout;     initializeAppearance;     tasks: #();     orderedTasks: OrderedCollection newopenModal: aSystemWindow  | baseArea areas searching foundRect |  aSystemWindow extent: aSystemWindow initialExtent.  areas := self currentWorld submorphs select: [:m |  m isKindOf: DialogWindow ] thenCollect: [:m |  m bounds expandBy: 8 ].  baseArea := RealEstateAgent maximumUsableArea insetBy: 8.  searching := true.  baseArea allAreasOutsideList: areas do: [:rect |  searching ifTrue: [ aSystemWindow extent <= (rect insetBy: 8) extent ifTrue: [ foundRect := rect.                    searching := false ] ] ].  searching ifTrue: [ foundRect := baseArea ].  aSystemWindow setWindowColor: self theme windowColor.  aSystemWindow position: foundRect topLeft + 8.  aSystemWindow openAsIs.  ^aSystemWindowdiscoveredWorldMenu  ^worldState discoveredWorldMenuresizable  ^resizable ifNil: [ resizable := true ]listDirection  ^#topToBottomcontainsPoint: aPoint  | w |  ^(super containsPoint: aPoint) and: [ w := SystemWindow borderWidth.        ((self bounds translateBy: (w @ w) negated) containsPoint: aPoint) not ]lastSelection  ^selectedItem ifNotNil: [ selectedItem selector ]arrowBoundsAt: endPoint from: priorPoint  | d v angle wingBase arrowSpec length width |  v := endPoint - priorPoint.  angle := v degrees.  d := borderWidth max: 1.  arrowSpec := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  length := arrowSpec x abs.  width := arrowSpec y abs.  wingBase := endPoint + (Point r: d * length degrees: angle + 180.0).  arrowSpec x >= 0 ifTrue: [ ^{endPoint .         (wingBase + (Point r: d * width degrees: angle + 125.0)) .         (wingBase + (Point r: d * width degrees: angle - 125.0))} ] ifFalse: [ ^{endPoint .         (wingBase + (Point r: d * width degrees: angle + 125.0)) .         wingBase .         (wingBase + (Point r: d * width degrees: angle - 125.0))} ]topHeaderBackground  ^topHeaderBackground ifNil: [ topHeaderBackground := Color transparent ]newStateForSelected: aBoolean  ^self subclassResponsibilitytoggleDragNDrop  self enableDragNDrop: self dragNDropEnabled notaddStandardHaloMenuItemsTo: aMenu hand: aHandMorph  self addWorldHaloMenuItemsTo: aMenu hand: aHandMorphactionAttributesUnder: aClickPoint event: anEvent do: aBlock  | startBlock |  startBlock := self characterBlockAtPoint: aClickPoint.  (text attributesAt: startBlock stringIndex forStyle: textStyle) select: [:attribute |  attribute mayActOnEvent: anEvent ] thenDo: [:attribute |  | range boxes |        range := text rangeOf: attribute startingAt: startBlock stringIndex.        boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) to: (self characterBlockForIndex: range last + 1).        boxes detect: [:each |  each containsPoint: aClickPoint ] ifFound: [ aBlock cull: attribute cull: boxes ] ]defaultBorderColor  ^self defaultColor twiceDarker alpha: 0.75splitsTopAndBottom  ^falsehasDisableTableLayoutString  ^self disableTableLayout -> 'disable layout in tables' translatedshouldCopy  ^copymouseMove: evt  | aMorph |  aMorph := self itemFromPoint: evt position.  evt hand hasSubmorphs ifFalse: [ (aMorph isNil or: [ aMorph highlightedForMouseDown not ]) ifTrue: [ scroller submorphsDo: [:m |  m highlightedForMouseDown ifTrue: [ m highlightForMouseDown: false ] ].              aMorph ifNotNil: [ aMorph highlightForMouseDown ] ] ].  (self dropEnabled and: [ evt hand hasSubmorphs ]) ifFalse: [ ^super mouseMove: evt ].  potentialDropMorph ifNotNil: [ (potentialDropMorph containsPoint: (potentialDropMorph point: evt position from: self)) ifTrue: [ ^self ] ].  self mouseLeaveDragging: evt.  (self containsPoint: evt position) ifTrue: [ self mouseEnterDragging: evt ]mouseDown: anEvent  | cp |  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: anEvent cursorPoint) ifTrue: [ oldColor := self color.        self setGrabbedColor ].  cp := anEvent cursorPoint.  lastMouse := {cp .   (cp - self position)}noteRemovalOfAll: aCollection  scroller removeAllMorphsIn: aCollection.  (aCollection includes: selectedMorph) ifTrue: [ self setSelectedMorph: nil ]roundedCorners  owner isFloating ifTrue: [ ^#(1 4) ].  owner isAdheringToTop ifTrue: [ ^#(1 4) ].  owner isAdheringToBottom ifTrue: [ ^#(2 3) ].  owner isAdheringToLeft ifTrue: [ ^#(1 2) ].  owner isAdheringToRight ifTrue: [ ^#(3 4) ].  ^#(1 2 3 4)icon: aForm  icon image: aForm.  label ifNotNil: [ icon setBalloonText: label maxLineLength: 100 ].  action ifNotNil: [ icon on: #click send: #value to: action ]topLeftColor  ^self colorselectIndex: rowIndex event: event  self toggleIndex: rowIndexselectedRowsIndexesFrom: anInteger  | index selfSelection |  index := anInteger.  self recentlyChanged ifTrue: [ ^(self dataSource table selectedIndexes select: [:each |  each between: index and: index + self numberOfVisibleChildren ]) ifEmpty: [ {} ] ifNotEmpty: [ {index} ] ].  selfSelection := (self dataSource table selectedIndexes includes: index) ifTrue: [ {index} ] ifFalse: [ {} ].  self isExpanded ifFalse: [ ^selfSelection ].  index := index + 1.  ^(self children flatCollect: [:child |  | result |        result := child selectedRowsIndexesFrom: index.        index := index + 1 + child numberOfVisibleChildren.        result ]) , selfSelectionreplaceFrom: start to: stop with: aText  text replaceFrom: start to: stop with: aText.  self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop - start + 1)drawSubmorphsOnAthensCanvas: anAthensCanvas  super drawSubmorphsOnAthensCanvas: anAthensCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOnAthensCanvas: anAthensCanvas ]doAutoAccept: evt  self autoAccept == true ifTrue: [ self editView hasUnacceptedEdits ifTrue: [ self editor accept ] ]listCenteringString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self listCenteringincrement  bar incrementgrabMorph: evt  evt hand grabMorph: selfthemeChanged  self allMorphsDo: [:m |  (m isKindOf: StringMorph) ifTrue: [ m color: self theme textColor ] ].  super themeChangedmouseLeave: event  hasFocus := falsestepTime  ^50childNodeClassFromItem: anItem  ^PackageMethodCategoryNodeExamplechooseColor  | newColor |  newColor := self theme chooseColorIn: ((self ownerThatIsA: SystemWindow) ifNil: [ self ]) title: 'Choose Color' translated color: self labelMorph color.  newColor ifNil: [ ^self ].  self labelMorph color: newColor.  self solidLabelMorph color: newColor beOpaque.  self setColorSelector ifNotNil: [ self model perform: self setColorSelector with: newColor ]anyModifierKeyPressed  ^recentModifiers anyMask: 16r0EonColor: colorWhenOn offColor: colorWhenOff  onColor := colorWhenOn.  offColor := colorWhenOff.  self update: #onOffColor.  self update: getStateSelectordelete  self isCloseable ifFalse: [ ^self ].  self deleteDiscardingChangesbuildTopHeader  | subs |  subs := OrderedCollection new.  self columns do: [:col |  col container: self.        subs add: (col header                 hResizing: #rigid;                 layoutChanged;                 yourself) ].  topHeader := Morph new fillStyle: self topHeaderBackground.  self addMorph: topHeader.  topHeader clipSubmorphs: true.  topHeader borderColor: Color veryLightGray.  topHeader color: Color transparent.  topHeader borderWidth: 0.  topHeader addAllMorphs: subs.  topHeader bounds: (scroller left @ self top corner: scroller right @ (self top + self topHeaderHeight))plugOne  | l |  rootClass := Object.  l := PluggableListMorph on: self list: #rootItems selected: #selected changeSelected: #selected:.  (l embeddedInMorphicWindowLabeled: 'test') openInWorldstring: aString  string := aStringcreateWindowGroup  | group pos ext |  pos := self position.  ext := self extent.  group := GroupWindowMorph new.  group addWindow: self.  (group openInWindowLabeled: 'Group: ' translated , self label)     extent: ext;     position: pos;     model: groupintoWorld: aWorld  aWorld ifNil: [ ^self ].  self wantsSteps ifTrue: [ aWorld startStepping: self ].  self submorphsDo: [:m |  m intoWorld: aWorld ]layoutBounds: aRectangle  super layoutBounds: aRectangle.  self computeSliderclipboardText  ^self osWindow clipboardTextmaxDepth  ^maxDepthcontainingWindow  ^self ownerThatIsA: SystemWindowcloseable: anObject  closeable := anObject.  anObject ifTrue: [ self setUnlockedIcon ] ifFalse: [ self setLockedIcon ]minExtentOf: aMorph in: newBounds  ^0 @ 0rootMorphsAt: aPoint  ^self submorphs select: [:m |  (m fullContainsPoint: aPoint) and: [ m isLocked not ] ]update: aSymbol  aSymbol == getSelectionSelector ifTrue: [ self selection: self getCurrentSelectionItem.        ^self ].  aSymbol == getListSelector ifTrue: [ self list: self getList.        ^self ].  ((aSymbol isKindOf: Array) and: [ aSymbol size > 1 and: [ aSymbol first == getListSelector and: [ aSymbol second == #openPath ] ] ]) ifTrue: [ ^(scroller submorphs at: 1 ifAbsent: [ ^self ]) openPath: (aSymbol allButFirst: 2) ].  ((aSymbol isKindOf: Array) and: [ aSymbol size > 1 and: [ aSymbol first == getListSelector and: [ aSymbol second == #openItemPath ] ] ]) ifTrue: [ ^(scroller submorphs at: 1 ifAbsent: [ ^self ]) openItemPath: (aSymbol allButFirst: 2) ].  ((aSymbol isKindOf: Array) and: [ aSymbol notEmpty and: [ aSymbol first == #openPath ] ]) ifTrue: [ ^(scroller submorphs at: 1 ifAbsent: [ ^self ]) openPath: aSymbol allButFirst ].  ((aSymbol isKindOf: Array) and: [ aSymbol size = 2 and: [ aSymbol first = getListSelector and: [ aSymbol second == #expandRoots ] ] ]) ifTrue: [ ^self expandRoots ].  ((aSymbol isKindOf: Array) and: [ aSymbol notEmpty and: [ aSymbol first = getListSelector and: [ aSymbol second == #expandAll ] ] ]) ifTrue: [ ^self expandAll ]subMenu  ^subMenudrawColumnOn: aCanvas  self isPotentialDropTarget ifTrue: [ aCanvas frameAndFillRectangle: self dataBounds fillColor: ((Color gray alpha: 0.1) alphaMixed: 0.9 with: (self color ifNotNil: [:c |  c asColor ] ifNil: [ Color transparent ])) borderWidth: 2 borderColor: Color gray ] ifFalse: [ self color ifNotNil: [:c |  c isColor ifTrue: [ aCanvas frameAndFillRectangle: self dataBounds fillColor: self color borderWidth: 0 borderColor: Color transparent ] ifFalse: [ c origin: self dataBounds topLeft.                    c direction: 0 @ self dataBounds height.                    aCanvas fillRectangle: self dataBounds basicFillStyle: c ] ] ]width: anObject  width := anObjectremoveListener: anObject from: aListenerGroup  | listeners |  aListenerGroup ifNil: [ ^nil ].  listeners := aListenerGroup.  listeners := listeners copyWithout: anObject.  listeners := listeners copyWithout: nil.  listeners isEmpty ifTrue: [ listeners := nil ].  ^listenerswrapScrolling: aBoolean  wrapScrolling := aBoolean.  self     changed: #leftButtonEnabled;     changed: #rightButtonEnabledaddTab: aStringOrMorph selected: selectedStringOrMorph  self tabs add: (self newLabelMorph: aStringOrMorph selected: selectedStringOrMorph).  self updateTabswantsDroppedObject: anotherItem  ^falsescreenRectangle  ^self fullBoundsisLinkedTo: aMorph  self firstInChain withSuccessorsDo: [:m |  m == aMorph ifTrue: [ ^true ] ].  ^falsedrawSubmorphsOn: aCanvas  | tab |  super drawSubmorphsOn: aCanvas.  (self hasKeyboardFocus and: [ (tab := self selectedTab) notNil and: [ tab owner notNil ] ]) ifTrue: [ self clipSubmorphs ifTrue: [ aCanvas clipBy: (aCanvas clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: [:c |  tab drawKeyboardFocusOn: c ] ] ifFalse: [ tab drawKeyboardFocusOn: aCanvas ] ]addMorphsTo: morphList from: aCollection allowSorting: sortBoolean withExpandedItems: expandedItems atLevel: newIndent  | priorMorph newCollection firstAddition |  priorMorph := nil.  newCollection := (sortBoolean and: [ sortingSelector notNil ]) ifTrue: [ (aCollection asSortedCollection: [:a :b |  (a perform: sortingSelector) <= (b perform: sortingSelector) ]) asOrderedCollection ] ifFalse: [ aCollection ].  firstAddition := nil.  newCollection do: [:item |  priorMorph := self indentingItemClass basicNew initWithContents: item prior: priorMorph forList: self indentLevel: newIndent.        firstAddition ifNil: [ firstAddition := priorMorph ].        morphList add: priorMorph.        ((item hasEquivalentIn: expandedItems) or: [ priorMorph isExpanded ]) ifTrue: [ priorMorph isExpanded: true.              priorMorph addChildrenForList: self addingTo: morphList withExpandedItems: expandedItems ] ].  ^firstAdditiontestSortDataSourceWithChainedSortFunction  | dataSource |  dataSource := self complexDataSourceForTesting.  strategy sortFunction: [:element |  element \\ 10 ] ascending , #yourself ascending.  self assert: dataSource elements equals: self complexElementsForTestDataSource.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(10 20 70 80 3 28 29).  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(29 28 3 80 70 20 10).  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: self complexElementsForTestDataSourceshowCurrentPage  self buildPanel.  treeMorph scroller removeAllMorphs.  (self nodeList isNil or: [ self nodeList isEmpty ]) ifTrue: [ ^treeMorph emptySelection ].  treeMorph addSubmorphsFromNodeList.  treeMorph updateColumnMorphs.  treeMorph scrollSelectionIntoViewfillsOwnerString  ^self fillsOwner -> 'fills owner' translatedisSelected  ^self selectedaddAllMorphs: aCollection after: anotherMorph  ^self privateAddAllMorphs: aCollection atIndex: (anotherMorph index ifNil: [ submorphs size ])animateRestoreFromMinimized  | tb buttonRect restoredRect rects steps |  tb := self worldTaskbar ifNil: [ ^self ].  buttonRect := ((tb taskButtonOf: self) ifNil: [ ^self ]) bounds.  restoredRect := self isFlexed ifTrue: [ (owner transform globalPointToLocal: fullFrame topLeft) extent: fullFrame extent ] ifFalse: [ fullFrame ].  steps := self theme numberOfStepsForAnimations.  rects := (1 / steps to: 1 by: 1 / steps) collect: [:x |  buttonRect interpolateTo: restoredRect at: ((20 raisedTo: x) - 1) / 19 ].  self fastAnimateRectangles: rectsclose: aSystemProgressItemMorph  self bars isEmpty ifTrue: [ ^self ].  lock critical: [ aSystemProgressItemMorph delete.        self bars size = 0 ifTrue: [ self width: 0.              self delete ] ].  self refreshfullDrawOn: aCanvas  super fullDrawOn: (aCanvas asAlphaBlendingCanvas: alpha)testResizingClosing  | coll |  window := SystemWindow labelled: 'foo'.  coll := OrderedCollection new.  window openInWorld.  window announcer when: WindowAnnouncement do: [:ann |  coll add: ann ].  self assertEmpty: coll.  window minimizeOrRestore.  self assert: coll size equals: 4.  self assert: coll first isResized.  self assert: coll second isMoved.  self assert: coll third isDeActivated.  self assert: coll fourth isCollapsed.  window delete.  self assert: coll size equals: 5.  self assert: coll fifth isClosed.  window := nilnewGroupboxForAll: controls  ^self theme newGroupboxIn: self forAll: controlsexpandFullBoundsForDropShadow: aRectangle  ^(aRectangle expandBy: self shadowMargins) quickMerge: aRectangleisSticky  extension ifNil: [ ^false ].  ^extension stickypoint: aPoint in: aReferenceMorph  owner ifNil: [ ^aPoint ].  ^(owner transformFrom: aReferenceMorph) localPointToGlobal: aPointonAnnouncement: anAnnouncement send: aMessageSelector to: anObject  self announcer when: anAnnouncement send: aMessageSelector to: anObjectrelease  traceMorph := nil.  oldColor := nil.  container := nil.  self releaseActionMap.  super releasedataSource: anObject  dataSource := anObject.  children do: [:item |  item dataSource: anObject ]position  ^positionhandlesKeyStroke: evt  ^self handlesKeyboard: evthighlightPotentialDropRow: row on: aCanvas  | drawBounds |  drawBounds := self drawBoundsForRow: row.  drawBounds := drawBounds intersect: self bounds ifNone: [ ^self ].  aCanvas frameRectangle: drawBounds color: Color bluehasDataSource  ^self dataSource notNilveryDeepInner: deepCopier  super veryDeepInner: deepCopier.  isEnabled := isEnabled veryDeepCopyWith: deepCopier.  subMenu := subMenu veryDeepCopyWith: deepCopier.  isSelected := isSelected veryDeepCopyWith: deepCopier.  icon := icon veryDeepCopyWith: deepCopier.  arguments := argumentscursorPoint  ^positionrememberOverList  mouseOverMorphs := overMorphs contentsrepressedImage: anObject  repressedImage := anObject.  self invalidRect: self boundshighlightingColor  ^self theme selectionColorisFirstItem  ^owner notNil and: [ owner submorphs first == self ]hScrollbar: anObject  hScrollbar := anObjectwindowEventHandler  ^WindowEventHandlercurrentCursor  ^currentCursorisTopWindow  ^self == TopWindowshortcutCharacter: aCharacter  shortcutCharacter := aCharacterforwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectiongenerateWindowEvent: evtBuf  | evt |  evt := WindowEvent new.  evt setTimeStamp: evtBuf second.  evt timeStamp = 0 ifTrue: [ evt setTimeStamp: Time millisecondClockValue ].  evt action: evtBuf third.  evt rectangle: (Rectangle origin: evtBuf fourth @ evtBuf fifth corner: evtBuf sixth @ evtBuf seventh).  ^evtdrawOnCanvasWrapperFor: anAthensCanvas  self drawOn: anAthensCanvas asCanvasWrapperwantsKeyboardFocusNavigation  ^super wantsKeyboardFocusNavigation and: [ self valueOfProperty: #wantsKeyboardFocusNavigation ifAbsent: [ true ] ]spawnFilterUpdateThread  [ | oldPattern |  oldPattern := nil.  [ isEditingSemaphore wait.  oldPattern ~= pattern ifTrue: [ oldPattern := pattern.        0.2 seconds wait.        oldPattern = pattern ifTrue: [ self filter ] ] ] repeat ] forkAt: Processor userBackgroundPriorityhandleSize  ^self class splitterWidth @ 30disableSort  self sortingStrategy: (FTNullColumnSortingStrategy column: self)selectedMouseOverFillStyle  ^self theme taskbarItemSelectedMouseOverFillStyleFor: selfempty  self selectedNodePathList: OrderedCollection newexternalName  ^self assureExtension externalName ifNil: [ self printString ]displayScaleFactor  ^self currentWorld displayScaleFactorremoveColumn: aTreeColumn  self removeColumnAtIndex: (self columns indexOf: aTreeColumn)rightFraction: aNumber  rightFraction := aNumberblue  ^(self selectedColor blue * 255) asIntegernewBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum help: helpText  ^self newBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: nil help: helpTextanimateClose  defaultBounds  ^0 @ 0 corner: 16 @ 100selector  ^selectorresetPotentialDropMorph  potentialDropMorph ifNotNil: [ potentialDropMorph resetHighlightForDrop.        potentialDropMorph := nil ]hands  ^worldState handsscrollSelectionIntoView  | row |  row := self getCurrentSelectionIndex.  self scrollSelectionToRow: rowmouseLeaveDragging: anEvent  (self dropEnabled and: [ anEvent hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: anEvent ].  self resetPotentialDropMorph.  anEvent hand releaseMouseFocus: selfadd: aLabelString selector: aSymbol  self add: aLabelString target: defaultTarget selector: aSymbol argumentList: EmptyArraychooseDropList: aStringOrText list: aList  ^self chooseDropList: aStringOrText title: 'Choose' translated list: aListstring: aString fontName: aName size: aSize wrap: shouldWrap  shouldWrap ifTrue: [ self contentsWrapped: aString ] ifFalse: [ self contents: aString ].  self fontName: aName size: aSizenewString: aStringOrText  ^self theme newStringIn: self label: aStringOrText font: self theme labelFont style: #plainpopUpFor: aMorph event: evt  | hand anEvent |  self flag: #workAround.  anEvent := evt ifNil: [ hand := aMorph world ifNotNil: [:w |  w activeHand ].        hand ifNil: [ hand := aMorph world primaryHand ].        hand lastEvent transformedBy: (aMorph transformedFrom: nil) ] ifNotNil: [ hand := evt hand.        evt ].  self target: aMorph.  hand halo: self.  hand world addMorphFront: self.  positionOffset := anEvent position - (aMorph point: aMorph position in: owner).  self startSteppingboundsForKeyText: aString font: aFont  | ktp ktw b |  ktp := self owner hasSubMenu ifTrue: [ self owner right - self owner subMenuMarker width ] ifFalse: [ self owner right ].  ktp := ktp - (ktw := aFont widthOfString: aString).  b := ktp @ ((self owner bounds top + self owner bounds bottom - aFont height) // 2) extent: ktw @ self owner height.  ^bredButtonChanged  ^whichButton anyMask: self class redButtonaddFirstInHistory: aTab  self removeFromHistory: aTab.  selectionHistory addFirst: aTabsmoothOrSegmentedPhrase  | lineName |  lineName := (closed ifTrue: [ 'outline' ] ifFalse: [ 'line' ]) translated.  ^self isCurve ifTrue: [ 'make segmented {1}' translated format: {lineName} ] ifFalse: [ 'make smooth {1}' translated format: {lineName} ]rightFraction: aNumber offset: anInteger  rightFraction := aNumber.  rightOffset := anIntegerwithHandPositionDo: aBlock  aBlock value: self positiononImage: aForm  self image: aFormcolumnInset: anInteger  columnInset := anIntegertaskThumbnailOfSize: thumbExtent  | min thumb |  min := self isMinimized ifTrue: [ self restoreBeforeGeneratingThumbnail.        true ] ifFalse: [ false ].  thumb := self basicTaskThumbnailOfSize: thumbExtent.  min ifTrue: [ self minimizeAfterGeneratingThumbnail ].  ^thumbnullIndex  ^#(0 0)handlesKeyboard: evt  ^trueadd: aLabelString target: target selector: aSymbol argument: arg  ^self add: aLabelString target: target selector: aSymbol argumentList: (Array with: arg)updateGradients  | bgm b |  b := self innerBounds.  bgm := self submorphs last.  bgm bounds: b.  bgm fillStyle     origin: b topLeft;     direction: 0 @ b height.  self fillStyle     origin: b topLeft;     direction: b width @ 0.  self updateSelectedLocationmouseEnter: anEvent fromMorph: aMorph  ^self notify: anEvent from: aMorphdrawOnAthensCanvas: aCanvas  super drawOnAthensCanvas: aCanvas.  aCanvas morphicDrawString: self label in: self labelBounds font: self font color: self fontColoraddARowCentered: aCollectionOfMorphs  ^(self addARow: aCollectionOfMorphs)     hResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #leftCenterbrickDoubleLink: aDoubleLink  self setProperty: #brickDoubleLink toValue: aDoubleLinkinitialize  super initialize.  scrollDelta := 0.02.  pageDelta := 0.2contentsMenu: aMenu  (self submorphs asSortedCollection: [:w1 :w2 |  w1 class name caseInsensitiveLessOrEqual: w2 class name ]) do: [:w |  aMenu add: w class name target: w selector: #comeToFront ].  ^aMenuhandleColor  ^handleColor ifNil: [ self setDefaultColors.        handleColor ]action  ^actiondropItemSelector: aSymbol  dropItemSelector := aSymbol.  aSymbol ifNotNil: [ self dropEnabled: true ]showScrollBarsOnlyWhenNeeded: bool  self showHScrollBarOnlyWhenNeeded: bool.  self showVScrollBarOnlyWhenNeeded: boolhandleFatalDrawingError: errMsg  Display deferUpdates: false.  self primitiveError: errMsgprivateAddAllMorphs: aCollection atIndex: index  | myWorld otherSubmorphs |  myWorld := self world.  otherSubmorphs := submorphs copyWithoutAll: aCollection.  (index between: 0 and: otherSubmorphs size) ifFalse: [ ^self error: 'index out of range' ].  index = 0 ifTrue: [ submorphs := aCollection asArray , otherSubmorphs ] ifFalse: [ index = otherSubmorphs size ifTrue: [ submorphs := otherSubmorphs , aCollection ] ifFalse: [ submorphs := otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ] ].  aCollection do: [:m |  | itsOwner itsWorld |        itsOwner := m owner.        itsOwner ifNotNil: [ itsWorld := m world.              itsWorld == myWorld ifFalse: [ itsWorld ifNotNil: [ self privateInvalidateMorph: m ].                    m outOfWorld: itsWorld ].              itsOwner ~~ self ifTrue: [ m owner privateRemove: m.                    m owner removedMorph: m ] ].        m privateOwner: self.        myWorld ifNotNil: [ self privateInvalidateMorph: m ].        myWorld == itsWorld ifFalse: [ m intoWorld: myWorld ].        itsOwner == self ifFalse: [ self addedMorph: m.              m noteNewOwner: self ] ].  self layoutChangedsetOptimalResizing  self hResizing: #rigid.  self vResizing: #rigidcopy  ^super copy text: text copy textStyle: textStyle copy wrap: wrapFlag color: color predecessor: nil successor: nilconfigureForEmbedding  labelArea owner notNil ifTrue: [ self           hasDropShadow: false;           beWithoutGrips;           removeLabelArea;           makeBorderless.        self submorphsDo: [:m |  m unlock ] ]layout: aSymbol  | old |  (old := layout) = aSymbol ifTrue: [ ^self ].  layout := aSymbol.  ((old = #scaled or: [ old = #scaledAspect ]) or: [ aSymbol = #scaled or: [ aSymbol = #scaledAspect ] ]) ifTrue: [ self cachedForm: nil ].  self changedptName  ^#bottomRightescapePressed  self cancelactivate  (self morph respondsTo: #restoreAndActivate) ifTrue: [ self morph restoreAndActivate ]newSliderFor: aModel getValue: getSel setValue: setSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: 0 max: 1 quantum: nil getEnabled: nil help: helpTextisTaskbar  ^falsestart  self startSteppingreleaseCachedState  super releaseCachedState.  self cleanseStepListlayoutProportionallyIn: newBounds  | box frame |  frame := self layoutFrame ifNil: [ ^self ].  box := frame layout: self bounds in: newBounds.  box = self bounds ifTrue: [ ^self ].  ^self layoutInBounds: boxwasHandled: aBool  wasHandled := aBoolrestore  self isMinimized ifTrue: [ self collapseBoxHit ] ifFalse: [ self isMaximized ifTrue: [ self expandBoxHit ] ]printOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     print: self;     nextPut: $)beRadioButton  self buttonMorph beRadioButtondefaultBorderWidth  ^0morphsInFrontOverlapping: aRectangle  | morphList |  morphList := Array new writeStream.  self morphsInFrontOf: nil overlapping: aRectangle do: [:m |  morphList nextPut: m ].  ^morphList contentsnewCloseButtonFor: aModel  ^self theme newCloseButtonIn: self for: aModelwantsDroppedMorph: aMorph event: evt  self visible ifFalse: [ ^false ].  self dropEnabled ifFalse: [ ^false ].  ^truelineSegmentsDo: endPointsBlock  | cs x y beginPoint |  vertices size < 1 ifTrue: [ ^self ].  self isCurvy ifFalse: [ beginPoint := nil.        vertices do: [:vert |  beginPoint ifNotNil: [ endPointsBlock value: beginPoint value: vert ].              beginPoint := vert ].        (closed or: [ vertices size = 1 ]) ifTrue: [ endPointsBlock value: beginPoint value: vertices first ].        ^self ].  cs := self coefficients.  beginPoint := (x := cs first first) @ (y := cs fifth first).  (closed ifTrue: [ 1 to: cs first size ] ifFalse: [ 1 to: cs first size - 1 ]) do: [:i |  | t n x3 y3 x1 endPoint x2 y1 y2 |        x1 := cs second at: i.        y1 := cs sixth at: i.        x2 := cs third at: i.        y2 := cs seventh at: i.        x3 := cs fourth at: i.        y3 := cs eighth at: i.        n := cs ninth at: i.        1 to: n - 1 do: [:j |  t := j asFloat / n asFloat.              endPoint := (((x3 * t + x2) * t + x1) * t + x) @ (((y3 * t + y2) * t + y1) * t + y).              endPointsBlock value: beginPoint value: endPoint.              beginPoint := endPoint ].        endPoint := (x := cs first atWrap: i + 1) @ (y := cs fifth atWrap: i + 1).        endPointsBlock value: beginPoint value: endPoint.        beginPoint := endPoint ]font  ^self labelMorph fontaddColumnResizers  columnResizers := self columnResizerFrames withIndexCollect: [:frm :idx |  (MorphTreeResizerMorph container: self index: idx) bounds: (frm translateBy: scroller offset x negated @ 0) ].  self addAllMorphs: columnResizers.  self columnResizersToFrontchildrenItems  ^self parentNode item selectorsInProtocol: self itemcolumnDropUnabled: aBoolean  columnDropUnabled := aBooleankeystrokeActionSelector  ^keystrokeActionSelectorunderlined  self changeEmphasis: #underlinedsetNextDirectionFromEvent: event  nextPageDirection := bounds isWide ifTrue: [ event cursorPoint x >= slider center x ] ifFalse: [ event cursorPoint y >= slider center y ]layout: aMorph in: newBounds  handlesMouseOver: evt  (self existsSubscriptionsFor: #mouseEnter) ifTrue: [ ^true ].  (self existsSubscriptionsFor: #mouseLeave) ifTrue: [ ^true ].  (self existsSubscriptionsFor: #mouseOver) ifTrue: [ ^true ].  ^falseresult: anObject  lock critical: [ hasResult := true.        result := anObject ]veryDeepInner: deepCopier  super veryDeepInner: deepCopier.  actWhen := actWhen veryDeepCopyWith: deepCopier.  oldColor := oldColor veryDeepCopyWith: deepCopier.  label := label veryDeepCopyWith: deepCopiersetStateSelector: anObject  setStateSelector := anObjectinitialize  super initialize.  self showWhenNeededchangeAlignment: aSymbol  self editor applyAttribute: (TextAlignment perform: aSymbol).  self updateFromParagraphbackgroundColorFor: aRow  | return |  aRow ifNil: [ ^nil ].  self enabled ifFalse: [ return := Color white darker darker ].  self backgroundColoringBlockOrSelector ifNotNil: [:blockOrSelector |  | anItem |        anItem := getListElementSelector ifNil: [ list at: aRow ifAbsent: [ ^nil ] ] ifNotNil: [ model perform: getListElementSelector with: aRow ].        return := blockOrSelector isBlock ifTrue: [ blockOrSelector cull: anItem cull: aRow ] ifFalse: [ blockOrSelector isSymbol ifTrue: [ blockOrSelector numArgs == 0 ifTrue: [ anItem perform: blockOrSelector ] ifFalse: [ self model perform: blockOrSelector withEnoughArguments: {anItem .                                 aRow} ] ] ifFalse: [ nil ] ] ].  ^return isColor ifTrue: [ return ] ifFalse: [ nil ]addAllMorphs: array  super addAllMorphs: array.  array do: [:m |  self startSteppingSubmorphsOf: m ]setActWhen  | selections |  selections := #(#buttonDown #buttonUp #whilePressed #startDrag).  actWhen := UIManager default chooseFrom: (selections collect: [:t |  t translated ]) values: selections title: 'Choose one of the following conditions' translatedworld: anObject  world := anObjectbeTransparent  self color: Color transparenttabs  ^tabsisSingle  ^self isMultiple notprivateFullBounds  | box |  submorphs isEmpty ifTrue: [ ^self outerBounds ].  box := self outerBounds copy.  box := box quickMerge: (self clipSubmorphs ifTrue: [ self submorphBounds intersect: self clippingBounds ifNone: [ self clippingBounds ] ] ifFalse: [ self submorphBounds ]).  ^box origin asIntegerPoint corner: box corner asIntegerPointextent: newExtent  | safeExtent center |  center := self referencePosition.  safeExtent := newExtent max: 20 @ 20.  self setVertices: (vertices collect: [:p |  (p - center) * (safeExtent asFloatPoint / (bounds extent max: 1 @ 1)) + center ])taskbarButtonFor: aTaskBar  ^nilmouseLeave: anEvent  self canResizeColumn ifFalse: [ ^self ].  super mouseLeave: anEventisKeyboard  ^truenewRadioButtonFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newRadioButtonIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpTextselectionColor: aColor  selectionColor := aColor.  paragraph ifNotNil: [:p |  p selectionColor: aColor ]calculateExactVisibleRows  | visibleRows |  visibleRows := self height / (self table rowHeight + self table intercellSpacing y).  ^headerRow ifNotNil: [ visibleRows - 1 ] ifNil: [ visibleRows ]stepTime  ^100selectionColor: aColor  | window |  aColor ifNil: [ self removeProperty: #selectionColor ] ifNotNil: [ self setProperty: #selectionColor toValue: aColor ].  window := self ownerThatIsA: SystemWindow.  self selectionColorToUse: ((self theme fadedBackgroundWindows not or: [ window isNil or: [ window isActive ] ]) ifTrue: [ aColor ] ifFalse: [ self theme unfocusedSelectionColor ])alwaysShowHScrollbar  ^self class alwaysShowHScrollbarupdatePinForm  pinBox ifNotNil: [ pinBox           labelGraphic: self pinForm;           extent: self boxExtent ]updateColor  | fill |  self autoGradient ifFalse: [ ^self ].  fill := GradientFillStyle ramp: self gradientRamp.  fill origin: self topLeft.  self isVertical ifTrue: [ fill direction: self width @ 0 ] ifFalse: [ fill direction: 0 @ self height ].  self fillStyle: fillnewLabelGroup: labelsAndControls  ^self theme newLabelGroupIn: self for: labelsAndControlsisExpanded: aBoolean  selectAll  self editor selectFrom: 1 to: text sizeforwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectionhelpText  ^self balloonTextupdateData  selectionContainsPoint: aPoint  ^self selectionRects anySatisfy: [:rect |  rect containsPoint: aPoint ]page: aMorph  self selectedPageIndex: (self pages indexOf: aMorph)handlesDropShadowInHand  ^falsedatasource: aDS  dataSource := aDSenvironment: anObject  deselectAndFocusOutermenuOn: anEvent  self selectItem: nil event: anEvent.  anEvent hand newMouseFocus: popUpOwner owner.  ^anEvent hand newKeyboardFocus: popUpOwner ownerexecuteSortingOn: aDataSource  aDataSource sortWith: self context ascendingSortFunction reversedaddHalo: evt  | halo |  self halosEnabled ifFalse: [ ^self ].  halo := (Smalltalk globals at: self haloClass ifAbsent: [ HaloMorph ]) new.  halo bounds: (halo worldBoundsForMorph: self).  halo popUpFor: self event: evt.  ^haloinitialize  super initialize.  value := 0.0.  descending := false.  self initializeSlidergetOldColor  ^oldColor ifNil: [ Color transparent ]step  ^stepheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]internalSpaces: spacesInteger  internalSpaces := spacesIntegerautoDeselect: trueOrFalse  autoDeselect := trueOrFalsenewCloseControlFor: aModel action: aValuable help: helpText  ^self theme newCloseControlIn: self for: aModel action: aValuable help: helpTextaddColumn: aColumn  columns := columns copyWith: aColumndropMorph: aMorph event: anEvent  | event dropped |  (anEvent isMouseUp and: [ aMorph shouldDropOnMouseUp not ]) ifTrue: [ ^self ].  self privateRemove: aMorph.  aMorph privateOwner: self.  dropped := aMorph.  (dropped hasProperty: #addedFlexAtGrab) ifTrue: [ dropped := aMorph removeFlexShell ].  event := DropEvent new setPosition: self position contents: dropped hand: self.  self sendEvent: event focus: nil.  event wasHandled ifFalse: [ aMorph rejectDropMorphEvent: event ].  aMorph owner == self ifTrue: [ aMorph delete ].  self mouseOverHandler processMouseOver: anEventextent  ^bounds extentmessage: aStringOrText  ^self message: aStringOrText title: 'Information' translatedlastPaneColor: anObject  lastPaneColor := anObjectnewDialogPanel  ^self theme newDialogPanelIn: selfminWidth  ^self hResizing = #shrinkWrap ifTrue: [ self scrollTarget minExtent x + self scrollbarThickness + 5 ] ifFalse: [ super minWidth ]themeChanged  self fillStyle: self normalFillStyle.  super themeChangednodeExpandRequest: anAnnounce  anAnnounce nodes ifEmpty: [ self expandAll ] ifNotEmpty: [:nodes |  anAnnounce recur ifTrue: [ self expandAllFromNode: nodes last ] ifFalse: [ self expandNodePath: nodes ] ]isMultipleSelection  ^self multipleSelectiontabAddedToSelection: aTab  aTab selected ifTrue: [ ^self ].  numberOfSelectedTabs := numberOfSelectedTabs + 1.  self addInHistory: aTab.  aTab silentlySelected: true.  self adjustLayout.  self triggerEvent: #tabAddedToSelection with: aTabkeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  aBoolean ifTrue: [ self defaultFocusMorph ifNotNil: [:b |  b takeKeyboardFocus ] ]exportAsPNGSilently  | fName time |  time := (DateAndTime now asString copyReplaceAll: ':' with: '-') copyReplaceAll: '.' with: '-'.  fName := self externalName , time , '.png'.  PNGReadWriter putForm: self imageForm onFileNamed: fNamenewButtonFor: aModel action: actionSel label: stringOrText help: helpText  ^self newButtonFor: aModel getState: nil action: actionSel arguments: nil getEnabled: nil label: stringOrText help: helpTextlayoutBounds  | box |  box := super layoutBounds.  ^box withTop: box top + self labelHeighthasDocumentAnchorString  ^(self textAnchorType == #document) -> 'Document' translatedaddCustomMenuItems: aMenu hand: aHandMorph  super addCustomMenuItems: aMenu hand: aHandMorph.  aMenu addLine.  aMenu add: 'list font...' target: self selector: #setListFont.  aMenu add: 'copy list to clipboard' target: self selector: #copyListToClipboard.  aMenu add: 'copy selection to clipboard' target: self selector: #copySelectionToClipboardwantsDroppedMorph: aMorph event: event  aMorph isTransferable ifFalse: [ ^false ].  ^self dataSource wantsDropElements: aMorph passenger type: aMorph dragTransferType index: ((self container rowIndexContainingPoint: event position) ifNil: [ 0 ])calculateMinVisibleRows  ^self calculateExactVisibleRows floormatches: aString  ^aString includesSubstring: pattern caseSensitive: falseupdateList  | index |  self listMorph listChanged.  self setScrollDeltas.  scrollBar setValue: 0.0.  index := self getCurrentSelectionIndex.  self resetPotentialDropRow.  index ifNotNil: [ index := index min: self getListSize.        index > 0 ifTrue: [ self selectionIndex: index ] ].  self searchedElement: niladdUpdating: aWordingSelector selector: aSymbol  self addUpdating: aWordingSelector target: defaultTarget selector: aSymbol argumentList: EmptyArraystartStepping  self startStepping: #stepAt: at: Time millisecondClockValue arguments: nil stepTime: nilnewOKButton  ^self newOKButtonFor: selfaMorph: anObject  aMorph := anObjectdrawBackgroundForSelectedRow: row on: aCanvas  self drawBackgroundForRow: row on: aCanvas color: listSource selectionColorToUsestate: anObject  state := anObjectrealSearch  | founds |  founds := self table dataSource searchText: pattern.  founds ifNotEmpty: [ self table selectIndex: founds first ].  self table highlightIndexes: founds.  ^founds notEmptycanResizeColumn  ^(container columns at: index) resizablecellPositioningString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self cellPositioningcolor: aColor  color := aColorinitialize  super initialize.  self extent: 8 @ 8addExtraSpace: aPoint  extraSpace ifNil: [ extraSpace := aPoint ] ifNotNil: [ extraSpace := extraSpace + aPoint ]commandKeyHandler  ^self valueOfProperty: #commandKeyHandler ifAbsent: [ nil ]wantsExpandBox  ^falseextent: aPoint  | newExtent w oldExtent |  newExtent := self isCollapsed ifTrue: [ aPoint max: self labelWidgetAllowance @ 0 ] ifFalse: [ aPoint max: self minimumExtent ].  newExtent = self extent ifTrue: [ ^self ].  oldExtent := self extent.  isCollapsed ifTrue: [ super extent: newExtent x @ self labelHeight ] ifFalse: [ super extent: newExtent ].  isCollapsed ifTrue: [ collapsedFrame := self bounds ] ifFalse: [ fullFrame := self bounds ].  (self isCollapsed or: [ label isNil ]) ifFalse: [ label minWidth: nil.        label fitContents.        label width > (bounds width - labelWidgetAllowance) ifTrue: [ label setBalloonText: label contents ] ifFalse: [ label setBalloonText: nil ].        w := label width min: bounds width - labelWidgetAllowance.        label           setWidth: w;           minWidth: w.        label align: label bounds topCenter with: bounds topCenter + (0 @ borderWidth).        collapsedFrame ifNotNil: [ collapsedFrame := collapsedFrame withWidth: label width + labelWidgetAllowance ] ].  self theme windowExtentChangedFor: self.  self announce: (WindowResizing new           oldSize: oldExtent;           newSize: newExtent;           window: self;           yourself)expandedNodesFrom: aMorpList  ^(aMorpList select: [:each |  each isExpanded ]) collect: [:each |  each complexContents ]root: anObject  self roots: {anObject}path  ^parent ifNil: [ OrderedCollection with: self ] ifNotNil: [ parent path           add: self;           yourself ]actionBlock  ^actionBlockbackgroundColor: aColor  backgroundColor := aColorcomposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY  | newResult |  newResult := self composer composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY textStyle: textStyle text: text container: container wantsColumnBreaks: wantsColumnBreaks == true.  lines := newResult first asArray.  ^maxRightX := newResult secondtextEntry: aStringOrText title: aString  ^self textEntry: aStringOrText title: aString entryText: ''moveOrResizeFromKeystroke: anEvent  | dir |  anEvent keyValue = 28 ifTrue: [ dir := -1 @ 0 ].  anEvent keyValue = 29 ifTrue: [ dir := 1 @ 0 ].  anEvent keyValue = 30 ifTrue: [ dir := 0 @ -1 ].  anEvent keyValue = 31 ifTrue: [ dir := 0 @ 1 ].  dir notNil ifTrue: [ anEvent controlKeyPressed ifTrue: [ dir := dir * 10 ].        anEvent shiftPressed ifTrue: [ self extent: self extent + dir ] ifFalse: [ self position: self position + dir ] ]lineSegments  | lineSegments |  lineSegments := OrderedCollection new.  self lineSegmentsDo: [:p1 :p2 |  lineSegments addLast: (Array with: p1 with: p2) ].  ^lineSegmentsathensSurface  ^owner ifNil: [ nil ] ifNotNil: [ owner athensSurface ]isMouse  ^truemenuColumn: column row: rowIndex  ^nilsetRotationCenterFrom: aPoint  self rotationCenter: (aPoint - self bounds origin) / self bounds extent asFloatPointfieldHeigh  ^StandardFonts defaultFont pixelSize + 10isScrolledFromTop  ^scroller offset y > 0testMouseLeaveFromMorph  morph eventHandler on: #mouseLeave send: #value to: true.  self assert: (morph mouseLeave: nil) identicalTo: trueextent: newExtent  super extent: newExtent.  graphicalMorph ifNotNil: [ graphicalMorph position: self center - (graphicalMorph extent // 2) ]newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: menuSelector  ^self theme newTextEditorIn: self for: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: menuSelectorminWidth  ^super minWidth max: self theme buttonMinWidthcopyHandlerState: anEvent  handler := anEvent handler.  wasHandled := anEvent wasHandledkeystrokeActionSelector: keyActionSel  keystrokeActionSelector := keyActionSelanchorMorph: aMorph at: aPoint type: anchorType  | relPt index newText block |  aMorph owner == self ifTrue: [ self removeMorph: aMorph ].  aMorph textAnchorType: nil.  aMorph relativeTextAnchorPosition: nil.  self addMorphFront: aMorph.  aMorph textAnchorType: anchorType.  aMorph relativeTextAnchorPosition: nil.  anchorType == #document ifTrue: [ ^self ].  relPt := self transformFromWorld globalPointToLocal: aPoint.  index := (self paragraph characterBlockAtPoint: relPt) stringIndex.  newText := Text string: (String value: 1) attribute: (TextAnchor new anchoredMorph: aMorph).  anchorType == #inline ifTrue: [ self paragraph replaceFrom: index to: index - 1 with: newText displaying: false ] ifFalse: [ index := index min: paragraph text size.        index := paragraph text string lastIndexOf: Character cr startingAt: index ifAbsent: [ 0 ].        block := paragraph characterBlockForIndex: index + 1.        aMorph relativeTextAnchorPosition: (relPt x - bounds left) @ (relPt y - block top).        self paragraph replaceFrom: index + 1 to: index with: newText displaying: false ].  self fitnormalFillStyle  ^self theme tabLabelNormalFillStyleFor: selfminWidth  | gap |  gap := container ifNil: [ 0 ] ifNotNil: [ self indentGap ].  ^gap max: super minWidthaddLayoutMenuItems: topMenu hand: aHand  | aMenu |  aMenu := UIManager default newMenuIn: self for: self.  aMenu addUpdating: #hasNoLayoutString selector: #changeNoLayout.  aMenu addUpdating: #hasProportionalLayoutString selector: #changeProportionalLayout.  aMenu addUpdating: #hasTableLayoutString selector: #changeTableLayout.  aMenu addLine.  aMenu add: 'change layout inset...' selector: #changeLayoutInset:.  aMenu addLine.  self addCellLayoutMenuItems: aMenu hand: aHand.  self addTableLayoutMenuItems: aMenu hand: aHand.  topMenu ifNotNil: [ topMenu add: 'layout' subMenu: aMenu ].  ^aMenumaximumExtent: aPoint  ^self setProperty: #maximumExtent toValue: aPointcomputeColors  width = 0 ifTrue: [ ^colors := #() ].  style == #complexFramed ifTrue: [ ^self computeFramedColors ].  style == #complexAltFramed ifTrue: [ ^self computeAltFramedColors ].  style == #complexRaised ifTrue: [ ^self computeRaisedColors ].  style == #complexAltRaised ifTrue: [ ^self computeAltRaisedColors ].  style == #complexInset ifTrue: [ ^self computeInsetColors ].  style == #complexAltInset ifTrue: [ ^self computeAltInsetColors ].  self error: 'Unknown border style: ' , style printStringmouseMove: evt  actWhen == #buttonDown ifTrue: [ ^self ].  self updateVisualState: evtmouseOverButtonBorderStyle  ^self theme scrollbarMouseOverButtonBorderStyleFor: selfrefreshWorld  | aWorld |  (aWorld := self world) ifNotNil: [ aWorld displayWorldSafely ]newHSVAColorSelectorMorph  ^HSVAColorSelectorMorph new     extent: 40 @ 28 + 152;     when: #selectedColor send: #colorSelected: to: selftakesKeyboardFocus  ^self enabledmorphsAt: aPoint unlocked: aBool do: aBlock  (self fullBounds containsPoint: aPoint) ifFalse: [ ^self ].  (aBool and: [ self isLocked or: [ self visible not ] ]) ifTrue: [ ^self ].  self submorphsDo: [:m |  | tfm |        tfm := m transformedFrom: self.        m morphsAt: (tfm globalPointToLocal: aPoint) unlocked: aBool do: aBlock ].  (self containsPoint: aPoint) ifTrue: [ aBlock value: self ]addHandlesTo: aHaloMorph box: box  aHaloMorph haloBox: box.  HaloMorph currentHaloSpecifications do: [:aSpec |  | wantsIt aSelector |        aSelector := aSpec addHandleSelector.        (wantsIt := self wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph) ifTrue: [ (#(addDupHandle:) includes: aSelector) ifTrue: [ wantsIt := self preferredDuplicationHandleSelector = aSelector ] ].        wantsIt ifTrue: [ aHaloMorph perform: aSelector with: aSpec ] ].  aHaloMorph innerTarget addOptionalHandlesTo: aHaloMorph box: boxactualClass  ^FTAscendingSortingStatenewRadioButtonFor: aModel getSelected: getSel setSelected: setSel label: stringOrText help: helpText  ^self newRadioButtonFor: aModel getSelected: getSel setSelected: setSel getEnabled: nil label: stringOrText help: helpTextcanBeClosed  ^toolbar canBeClosedhSetScrollDelta  | range delta |  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  delta := self scrollDeltaWidth.  range := self hLeftoverScrollRange.  range = 0 ifTrue: [ hScrollBar           scrollDelta: 0.02 pageDelta: 0.2;           interval: 1.0;           setValue: 0.        ^self ].  hScrollBar scrollDelta: (delta / range) asFloat pageDelta: ((self innerBounds width - delta) / range) asFloat.  hScrollBar interval: (self innerBounds width / self hTotalScrollRange) asFloat.  hScrollBar setValue: (scroller offset x / range min: 1.0) asFloatensureLayoutAndAddMorph: aMorph  aMorph layoutFrame ifNil: [ aMorph layoutFrame: LayoutFrame identity ].  self addMorph: aMorphhasYellowButtonMenu  ^self wantsYellowButtonMenulistDirectionString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self listDirectionballoonText  ^balloonTextfractions: fractionsOrNil offsets: offsetsOrNil  | fractions offsets |  self deprecated: 'Do not use this method. It forces to create spurious objects (rectangle or points) for nothing.'.  fractions := fractionsOrNil ifNil: [ 0 @ 0 extent: 0 @ 0 ].  offsets := offsetsOrNil ifNil: [ 0 @ 0 extent: 0 @ 0 ].  ^self     topFraction: fractions top offset: offsets top;     leftFraction: fractions left offset: offsets left;     bottomFraction: fractions bottom offset: offsets bottom;     rightFraction: fractions right offset: offsets rightbuttonExtent  | size |  size := self theme scrollbarThickness.  ^bounds isWide ifTrue: [ upButton ifNil: [ size @ size ] ifNotNil: [ upButton extent ] ] ifFalse: [ downButton ifNil: [ size @ size ] ifNotNil: [ downButton extent ] ]asMouseOver  ^MouseEvent basicNew     setType: #mouseOver position: position buttons: buttons hand: source;     setTimeStamp: self timeStampsentTo: anObject  ^anObject handleUnknownEvent: selfaddWorldHandlesTo: aHaloMorph box: box  aHaloMorph haloBox: box.  HaloMorph haloSpecificationsForWorld do: [:aSpec |  aHaloMorph perform: aSpec addHandleSelector with: aSpec ].  aHaloMorph innerTarget addOptionalHandlesTo: aHaloMorph box: boxsetUp  super setUp.  column := self actualClass newageMorph  ^(self theme newTextEntryIn: self currentWorld for: self get: #age set: #age: class: Integer getEnabled: nil help: nil) color: Color transparentresizeCursor  self subclassResponsibilityinitWithContents: aString font: aFont emphasis: emphasisCode  offset := 1.  alpha := 0.5.  super initWithContents: aString font: aFont emphasis: emphasisCodevalueOfProperty: aSymbol ifAbsentPut: aBlock  ^self assureExtension valueOfProperty: aSymbol ifAbsentPut: aBlockresetListSelector: aSelector  resetListSelector := aSelectorpositionIn: aBox horizontalPlacement: horiz verticalPlacement: vert  | xCoord yCoord |  horiz == #left ifTrue: [ xCoord := aBox left ].  horiz == #leftCenter ifTrue: [ xCoord := aBox left + (aBox width // 4) ].  horiz == #center ifTrue: [ xCoord := (aBox left + aBox right) // 2 ].  horiz == #rightCenter ifTrue: [ xCoord := aBox left + (3 * aBox width // 4) ].  horiz == #right ifTrue: [ xCoord := aBox right ].  vert == #top ifTrue: [ yCoord := aBox top ].  vert == #topCenter ifTrue: [ yCoord := aBox top + (aBox height // 4) ].  vert == #center ifTrue: [ yCoord := (aBox top + aBox bottom) // 2 ].  vert == #bottomCenter ifTrue: [ yCoord := aBox top + (3 * aBox height // 4) ].  vert == #bottom ifTrue: [ yCoord := aBox bottom ].  ^xCoord asInteger @ yCoord asIntegernormalizedY: y  ^(y max: self topBoundary) min: self bottomBoundarydrawSubmenuMarkerOn: aCanvas  | subMenuMarker subMenuMarkerPosition |  self hasSubMenu ifFalse: [ ^self ].  subMenuMarker := self subMenuMarker.  subMenuMarkerPosition := (self right - subMenuMarker width) @ ((self top + self bottom - subMenuMarker height) // 2).  aCanvas paintImage: subMenuMarker at: subMenuMarkerPositiondoesBevels  ^falsedragTransferType  ^transferTypestyle  ^#dashedexternalName  ^'Selected {1} objects' translated format: {self selectedItems size}followHand: aHand forEachPointDo: block1 lastPointDo: block2  hand := aHand.  pointBlock := block1.  lastPointBlock := block2.  self position: hand lastEvent cursorPoint - (self extent // 2)userString  ^(String new: indentLevel withAll: Character tab) , super userStringexpand: aMorph suchThat: aBlock  (aBlock value: aMorph complexContents) ifTrue: [ aMorph isExpanded ifFalse: [ aMorph expand ].        aMorph childrenDo: [:ch |  self expandSilently: ch suchThat: aBlock ] ].  self innerWidgetChangediconFor: index  | class |  class := self elementAt: index.  ((class includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ class isAbstract not ]) ifTrue: [ class hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        class hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        class hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  class organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ((class includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ class isAbstract not ]) ifTrue: [ class hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        class hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        class hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  class organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ^class systemIconinitialize  super initialize.  self elements: Smalltalk allClassesAndTraits shuffledaddSimpleHandlesTo: aHaloMorph box: aBox  | aHandle |  target isWorldMorph ifTrue: [ ^self addSimpleHandlesForWorldHalos ].  self removeAllMorphs.  self bounds: (self worldBoundsForMorph: target renderedMorph).  self addHandleAt: (aBox topLeft + aBox leftCenter) // 2 + self simpleFudgeOffset color: Color paleBuff icon: #haloMoreHandlesIcon on: #mouseDown send: #addFullHandles to: self.  aHandle := self addGraphicalHandle: #rotateIcon at: aBox bottomLeft on: #mouseDown send: #startRot:with: to: self.  aHandle on: #mouseMove send: #doRot:with: to: self.  target shouldFlex ifTrue: [ (self addGraphicalHandle: #scaleIcon at: aBox bottomRight on: #mouseDown send: #startScale:with: to: self) on: #mouseMove send: #doScale:with: to: self ] ifFalse: [ (self addGraphicalHandle: #scaleIcon at: aBox bottomRight on: #mouseDown send: #startGrow:with: to: self) on: #mouseMove send: #doGrow:with: to: self ].  growingOrRotating := false.  self layoutChanged.  self changedtabClicked: evt with: aMorph  self selectedIndex: (self tabs indexOf: aMorph)delete  window ifNotNil: [ window delete ]chooseFont  ^self chooseFont: nilhelpText: aString  self setBalloonText: aStringstep  owner ifNil: [ ^self stopStepping ].  self updateContents.  self changedupdateColor  self theme preferGradientFill ifFalse: [ ^self ].  self fillStyle: (self theme menuFillStyleFor: self).  titleMorph ifNotNil: [:tm |  tm fillStyle: (self theme menuTitleFillStyleFor: tm) ]actualScreenSize  ^240 @ 120labelArea  ^labelAreamenubar  ^self submorphs detect: #isMenubardoubleClick: anEvent on: aMorph  self doubleClickSelector ifNil: [ ^false ].  client model perform: self doubleClickSelector withEnoughArguments: {anEvent .         aMorph}.  ^trueaddDebuggingItemsTo: aMenu hand: aHandMorph  aMenu add: 'debug...' subMenu: (self buildDebugMenu: aHandMorph).  aMenu lastItem icon: (self iconNamed: #smallDebugIcon)basicSelectIndexes: anArray  selectedIndexes := anArray asArraynewSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpTextshortcutProvider  ^PharoShortcuts currentnewButtonFor: aModel action: actionSel getEnabled: enabledSel label: stringOrText help: helpText  ^self newButtonFor: aModel getState: nil action: actionSel arguments: nil getEnabled: enabledSel label: stringOrText help: helpTextcoefficients  curveState ifNotNil: [ ^curveState at: 1 ].  ^self vertices size < 1 ifTrue: [ self ] ifFalse: [ self coefficientsForMoreThanThreePoints ]worldMenu  ^self menuBuilder menuEntitled: self discoveredMenuTitleinitializeActionButtonNamed: aString  actionButton := PluggableButtonMorph newButtonFor: self action: #execute label: aString help: nilpaddingWidth  ^paddingWidthresult: anObject  lock critical: [ hasResult := true.        result := anObject ]updatePageIndex: index  self pageMorph ifNotNil: [:p |  self contentMorph removeMorph: p ].  index > 0 ifTrue: [ self contentMorph addMorph: (self pages at: index) ].  self pageMorph ifNotNil: [:pm |  pm layoutChanged ].  self adoptPaneColor: self paneColorfullscreenMargin  ^self class fullscreenMarginisCollapsed  ^falsevSetScrollDelta  | pd |  pd := self vPageDelta.  self vScrollbar     scrollDelta: pd / 10 pageDelta: pd;     interval: self vScrollbarInterval;     setValue: self vScrollbarValuerootClass: aClass  rootClass := aClasshandleMonthNameTouched  | newMonthName dayCount |  newMonthName := UIManager default chooseDropList: 'Choose a month:' list: #('January' 'February' 'March' 'April' 'May' 'June' 'July' 'August' 'September' 'October' 'November' 'December').  newMonthName ifNil: [ ^self ].  dayCount := (Month year: date year month: newMonthName) daysInMonth.  self date: (Date year: date year month: newMonthName day: (date dayOfMonth min: dayCount)).  self changedallowsCellSelection  ^falseshouldFlex  ^self isFlexMorphpositionDirectionShaft: shaft  | alphaRadians unitVector |  alphaRadians := target heading degreesToRadians.  unitVector := alphaRadians sin @ alphaRadians cos negated.  shaft setVertices: {(unitVector * 6 + directionArrowAnchor) .         (unitVector * self directionArrowLength + directionArrowAnchor)}promptForCancel  ^self confirm: 'Changes have not been saved.Is it OK to cancel changes?' translatedenabled: aBoolean  aBoolean ~= enabled ifTrue: [ enabled := aBoolean.        self requestView: MorphTreeChangeRequest enabled ]testIndexFromPosition  self subclassResponsibilityhandler  ^handlerlockedString  ^self isLocked -> 'be locked' translatedselectedIndex: anObject  selectedIndex := anObjectinitialize  super initialize.  self     isRadioButton: false;     enabled: true;     onImage: self theme checkboxMarkerForm;     fillStyle: self fillStyleToUse;     borderStyle: self borderStyleToUsesliderColor  sliderColor ifNil: [ ^(color alphaMixed: 0.7 with: Color white) slightlyLighter ].  ^sliderColorprocessEvents  ^self processEventsFromQueue: self eventQueuegetMenuSelector: anObject  getMenuSelector := anObjectdeselectTimeOut: evt  owner selectedItem == self ifTrue: [ evt hand releaseMouseFocus: owner.        owner selectItem: nil event: evt ]arguments  ^arguments ifNil: [ Array new ]showShortcut  ShortcutReminder showShortcut: selfbeSplitsTopAndBottom  splitsTopAndBottom := truetreeItemFor: anItem  ^FTBasicTreeListItem new     datasource: dataSource;     depth: depth + 1;     item: anItemenable  self enabled: truerelativeTextAnchorPosition: aPoint  ^self setProperty: #relativeTextAnchorPosition toValue: aPointadd: wordingString font: aFont icon: aForm help: helpString subMenu: aMenuMorph  | item |  item := DockingBarToggleMenuItemMorph new.  item     font: aFont;     contents: wordingString;     subMenu: aMenuMorph;     icon: aForm.  helpString ifNotNil: [ item setBalloonText: helpString ].  self addMorphBack: itemrejectsEvent: anEvent  (anEvent isMouse and: [ anEvent isMouseDown ]) ifTrue: [ ^(self submorphs anySatisfy: [:each |  each containsPoint: anEvent cursorPoint ]) not ].  ^super rejectsEvent: anEventhScrollbarShowing  ^self hScrollbar owner notNilinitialize  super initialize.  self     changeTableLayout;     color: Color transparent;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     cellInset: 16;     imageMorph: self newImageMorph;     textMorph: self newTextMorph;     addMorphBack: self imageMorph;     addMorphBack: self textMorphhIsScrollable  ^self hLeftoverScrollRange > 0newFuzzyLabelFor: aModel label: aString offset: offset alpha: alpha getEnabled: enabledSel  ^self theme newFuzzyLabelIn: self for: aModel label: aString offset: offset alpha: alpha getEnabled: enabledSelborderStyle: newStyle  newStyle = self borderStyle ifTrue: [ ^self ].  (self canDrawBorder: newStyle) ifFalse: [ ^self borderStyle: (BorderStyle width: newStyle width color: (newStyle trackColorFrom: self) color) ].  self assureExtension.  self extension borderStyle: newStyle.  self changedneedsToBeDrawn  | cursor |  (savedPatch notNil or: [ (submorphs anySatisfy: [:ea |  ea visible ]) or: [ temporaryCursor notNil and: [ hardwareCursor isNil ] ] ]) ifTrue: [ Cursor blank isCurrent ifFalse: [ Cursor blank show ].        ^true ].  cursor := hardwareCursor ifNil: [ Cursor normal ].  cursor isCurrent ifFalse: [ cursor show ].  ^falsegetListRow: row  getListElementSelector ifNotNil: [ ^model perform: getListElementSelector with: row ].  ^self getList at: rowopenModal: aSystemWindow  aSystemWindow setWindowColor: self theme windowColor.  ^super openModal: aSystemWindowcheckTimeoutFrom: aHand  localStamp ifNil: [ localStamp := Time millisecondClockValue.        ^self ].  Time millisecondClockValue - localStamp > dblClickTime ifFalse: [ ^self ].  clickState == #firstClickDown ifTrue: [ clickState := #firstClickTimedOut.        dragSelector ifNotNil: [ ^self ] ].  aHand resetClickState.  self doubleClickTimeout.  clickState == #firstClickTimedOut ifTrue: [ self click ]isOn  ^color = onColorstrikethroughColor  ^self stringColorunhighlightSelection  self searchedElement: nilnewMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: nil useIndex: true help: helpTextstartBlinking  self canChangeText ifTrue: [ super startBlinking ] ifFalse: [ self paragraph showCaret: true ]mouseDown: evt  oldColor := self fillStylegtInspectorMorphExtensionIn: composite  < gtInspectorPresentationOrder: 15>  ^composite table     title: 'Extension';     showOnly: 50;     display: [ self extension gtInspectorVariableValuePairs asSortedCollection ];     when: [ extension notNil ];     column: 'Variable' evaluated: [:assoc |  GTObjectPrinter asNonTruncatedTextFrom: assoc key ];     column: 'Value' evaluated: [:assoc |  GTObjectPrinter asTruncatedTextFrom: assoc value ];     send: #value;     morphicSelectionAct: [:list |  list selection value browse ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse';     morphicSelectionAct: [:list |  list selection value inspect ] icon: GLMUIThemeExtraIcons glamorousInspect on: $i entitled: 'Inspect';     selectionAct: [:list |  ((list selection pointersToExcept: {list selection}) reject: [:each |  each pointsOnlyWeaklyTo: list selection ]) inspect ] on: $t entitled: 'Open pointers to'selectedMouseOverBorderStyle  ^self theme buttonSelectedMouseOverBorderStyleFor: selfdrawBoundsForRow: row  | topLeft drawBounds item height |  item := [ self getListItem: row ] on: SubscriptOutOfBounds do: [:ex |  self getListItem: (row min: self getListSize) ].  height := item heightToDisplayInList: self.  topLeft := self topLeft x @ (self topLeft y + ((row - 1) * height)).  drawBounds := topLeft extent: self width @ height.  ^drawBoundsbottom  ^bounds bottomdrawSubmorphsOn: canvas  super drawSubmorphsOn: canvas.  self drawLinesOn: canvashash  ^position hash + buttons hashnewYesButtonFor: aModel  ^self theme newYesButtonIn: self for: aModelisDefault  ^self extension isDefaultdeleteIfPopUp: evt  owner ifNotNil: [ owner deleteIfPopUp: evt ]paneColor: aColor  self setProperty: #paneColor toValue: aColor.  self adoptPaneColorchangeTableLayout  | layout |  ((layout := self layoutPolicy) notNil and: [ layout isTableLayout ]) ifTrue: [ ^self ].  self layoutPolicy: TableLayout new.  self layoutChangednewColorComponentFieldMorph: aspect  ^(self newTextEntryFor: self get: aspect set: (aspect , ':') asSymbol class: Integer getEnabled: nil help: nil) minWidth: 40verticalScrollBar  ^verticalScrollBarkeyStroke: evt  | matchString char asc selectable help |  help := self theme builder newBalloonHelp: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.  help popUpForHand: self activeHand.  (self rootMenu hasProperty: #hasUsedKeyboard) ifFalse: [ self rootMenu setProperty: #hasUsedKeyboard toValue: true.        self changed ].  (evt commandKeyPressed and: [ self commandKeyHandler notNil ]) ifTrue: [ self commandKeyHandler commandKeyTypedIntoMenu: evt.        ^self deleteIfPopUp: evt ].  char := evt keyCharacter.  asc := char asciiValue.  char = Character cr ifTrue: [ selectedItem ifNotNil: [ selectedItem hasSubMenu ifTrue: [ evt hand newMouseFocus: selectedItem subMenu.                    ^evt hand newKeyboardFocus: selectedItem subMenu ] ifFalse: [ ^selectedItem invokeWithEvent: evt ] ].        (selectable := self items) size = 1 ifTrue: [ ^selectable first invokeWithEvent: evt ].        ^self ].  asc = 27 ifTrue: [ self valueOfProperty: #matchString ifPresentDo: [:str |  str isEmpty ifFalse: [ self setProperty: #matchString toValue: String new.                    self selectItem: nil event: evt.                    ^self displayFiltered: evt ] ].        popUpOwner ifNil: [ ^self delete ].        ^self deselectAndFocusOutermenuOn: evt ].  asc = 28 ifTrue: [ ^self leftArrowStroked: evt ].  asc = 29 ifTrue: [ (self rightArrowStroked: evt) ifTrue: [ ^self ] ].  asc = 30 ifTrue: [ ^self moveSelectionDown: -1 event: evt ].  asc = 31 ifTrue: [ ^self moveSelectionDown: 1 event: evt ].  asc = 11 ifTrue: [ ^self moveSelectionDown: -5 event: evt ].  asc = 12 ifTrue: [ ^self moveSelectionDown: 5 event: evt ].  matchString := self valueOfProperty: #matchString ifAbsentPut: [ String new ].  (char = Character backspace and: [ matchString notEmpty ]) ifTrue: [ matchString := matchString allButLast.        self recordFiltering: matchString.        self displayFiltered: evt ].  char isAlphaNumeric ifFalse: [ ^self ].  matchString := matchString , char asString.  self recordFiltering: matchString.  self displayFiltered: evttable: anObject  table := anObjectchanged  hasChanged := truehandlesMouseDown: evt  ^(self isEditable: evt) ifTrue: [ true ] ifFalse: [ super handlesMouseDown: evt ]hasEquivalentIn: aCollection  ^aCollection anySatisfy: [:each |  each withoutListWrapper = item withoutListWrapper ]hasDropShadow: aBool  aBool ifTrue: [ self setProperty: #hasDropShadow toValue: true ] ifFalse: [ self removeProperty: #hasDropShadow ]doAnnounce: anAnnouncement  (self valueOfProperty: #announcer ifAbsent: [ ^self ]) announce: anAnnouncementdefaultColor  ^self theme selectionColorownerChanged  super ownerChanged.  self updateLayoutInDockingBarheaderLabel: aString  headerLabel := aStringdrawOnAthensCanvas: aCanvas  | keyBounds |  keyBounds := self boundsForKeyText: self keyText font: self owner fontToUse.  self owner drawText: keyText onAthensCanvas: aCanvas in: keyBounds color: self owner theme disabledTextColorallItems  ^(submorphs detect: [:each |  each class = TransformMorph ]) submorphsaddPage: aMorph label: aStringOrMorph selected: selectedStringOrMorph  aMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  self pages add: aMorph.  self tabSelectorMorph addTab: aStringOrMorph selected: selectedStringOrMorphshadowForm  shadowForm ifNil: [ self computeShadow ].  ^shadowFormdoScrollDown  (self waitForDelay1: 200 delay2: 40) ifFalse: [ ^self ].  self setValue: (value + scrollDelta + 0.000001 min: 1.0)addGripsIfWanted  self wantsGrips ifTrue: [ self addGrips ]lineColor  | colored |  lineColor ifNotNil: [ ^lineColor ].  colored := self color isTransparent ifTrue: [ self firstOwnerSuchThat: [:o |  o isWorldOrHandMorph not and: [ o color isTransparent not ] ] ] ifFalse: [ self ].  colored ifNil: [ ^Color black ].  ^colored color luminance > 0.5 ifTrue: [ Color black ] ifFalse: [ Color white ]autoDeselect  ^self resetListSelector ifNotNil: [ true ] ifNil: [ self allowsDeselection ]chooseForSaveFileReference: title extensions: exts path: path  ^self chooseForSaveFileReference: title extensions: exts path: path preview: nilnewBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newBracketSliderIn: self for: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpTextarguments  ^argumentsadjustBottomY  | heights bottomY verticalSize |  heights := lines collect: [:each |  each lineHeight ].  verticalSize := heights sum.  bottomY := container top + verticalSize.  container := container withBottom: bottomYwantsDroppedMorph: aMorph event: evt  ^trueheaderBounds  | positions controlBounds currPos currLeft |  controlBounds := OrderedCollection new.  currPos := scroller left.  (positions := self columnResizers asOrderedCollection collect: [:r |  r position ]) ifNotEmpty: [ | currRight |        currPos := positions removeFirst x.        currLeft := scroller left - scroller offset x.        currRight := currPos.        controlBounds add: (currLeft @ topHeader top corner: currRight @ topHeader bottom).        [ positions notEmpty ] whileTrue: [ currLeft := currPos + self resizerWidth.              currPos := positions removeFirst x.              currRight := currPos.              controlBounds add: (currLeft @ topHeader top corner: currRight @ topHeader bottom) ] ].  self columnResizers size < self columns size ifTrue: [ currLeft := currPos + self resizerWidth.        controlBounds add: ((currLeft min: scroller right) @ topHeader top corner: scroller right @ topHeader bottom) ].  ^controlBoundstopLeftCorner  ^self intersectionWithLineSegmentFromCenterTo: bounds topLeftdragTarget: event  | thePoint |  thePoint := target point: event position - positionOffset from: owner.  target setConstrainedPosition: thePoint hangOut: true.  event hand newMouseFocus: selftrackColorFrom: aMorph  baseColor ifNil: [ self color: aMorph raisedColor ]listChanged  listItems := Array new: self getListSize withAll: nil.  self removeAllMorphs.  selectedRow := nil.  selectedRows := PluggableSet integerSet.  maxWidth := nil.  self adjustHeight.  self adjustWidth.  self changedkeystrokeSelector: aSymbol  keystrokeSelector := aSymbolalpha  ^alphaupdateContentsWithPreviouslyExpanded: aNodeList  super updateContentsWithPreviouslyExpanded: aNodeList.  self updatePagerdropItemSelector  ^dropItemSelectorsearchText: aString  | result |  aString isEmptyOrNil ifTrue: [ ^#() ].  result := OrderedCollection new.  self elements withIndexDo: [:each :index |  ((self toString: each) beginsWith: aString) ifTrue: [ result add: index ] ].  ^result asArrayprintOn: aStream  | string |  aStream nextPutAll: '3PButton'.  arguments notEmpty ifTrue: [ string := arguments at: (2 min: arguments size) ].  aStream nextPutAll: '('.  (string notNil and: [ string ~~ self ]) ifTrue: [ aStream           print: string;           space ] ifFalse: [ aStream           print: actionSelector;           space ].  aStream     print: self identityHash;     nextPutAll: ')'shadowOffset: aPoint  (aPoint isNil or: [ aPoint isZero ]) ifTrue: [ self removeProperty: #shadowOffset ] ifFalse: [ self setProperty: #shadowOffset toValue: aPoint ]icon  ^self iconNamed: #smallExpertIconballoonTextForNode: node  getHelpSelector ifNil: [ ^nil ].  ^model perform: getHelpSelector with: node itemprintOn: aStream  aStream nextPut: $[.  aStream     nextPutAll: self cursorPoint printString;     space.  aStream     nextPutAll: type;     space.  aStream     print: self direction;     space.  aStream nextPutAll: self modifierString.  aStream nextPutAll: self buttonString.  aStream     nextPutAll: timeStamp printString;     space.  aStream nextPutAll: self windowIndex printString.  aStream nextPut: $]activeFillStyle  ^self theme windowActiveFillStyleFor: selfchildren: aCollectionsOfItems  children := aCollectionsOfItemssplitsTopAndBottom  ^falsechooseExistingFileReference: title extensions: exts path: path preview: preview  ^self theme chooseExistingFileReferenceIn: self title: title extensions: exts path: path preview: previewmenuIcon  ^self class menuIconclipSubmorphs  ^trueminExtent  | extra |  self page ifNil: [ ^super minExtent max: self tabSelectorMorph minExtent ].  extra := 0 @ self tabSelectorMorph minExtent y + (self contentMorph borderWidth * 2).  extra := extra + (self contentMorph layoutInset * 2).  ^super minExtent max: ((self pages inject: 0 @ 0 into: [:mw :pm |  mw max: pm minExtent ]) + extra max: self tabSelectorMorph minExtent)getIconSelector  ^getIconSelectorrowInset  ^rowInset ifNil: [ rowInset := 0 ]rowIndexContainingPoint: aPoint  self exposedRows keysAndValuesDo: [:rowIndex :row |  (row bounds containsPoint: aPoint) ifTrue: [ ^rowIndex ] ].  ^nilbasicSelectRowIndexes: anArray  self deprecated: 'Use #basicSelectIndexes: instead' transformWith: '`@receiver basicSelectRowIndexes: `@statements' -> '`@receiver basicSelectIndexes: `@statements'.  self basicSelectIndexes: anArraynewButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: stringOrText help: helpTextminCellSize  ^minCellSizeacceptDroppingMorph: aSystemWindow event: evt  self addWindow: aSystemWindowisClosed  ^false= aFrame  ^self species = aFrame species and: [ self leftFraction == aFrame leftFraction and: [ self leftOffset == aFrame leftOffset and: [ self topFraction == aFrame topFraction and: [ self topOffset == aFrame topOffset and: [ self rightFraction == aFrame rightFraction and: [ self rightOffset == aFrame rightOffset and: [ self bottomFraction == aFrame bottomFraction and: [ self bottomOffset == aFrame bottomOffset ] ] ] ] ] ] ] ]wantsHalo  ^falsenewColorPresenterFor: aModel getColor: getSel help: helpText  ^self theme newColorPresenterIn: self for: aModel getColor: getSel help: helpTextclosestPointTo: aPoint  | pt |  pt := self bounds pointNearestTo: aPoint.  self wantsRoundedCorners ifFalse: [ ^pt ].  self bounds corners with: (self bounds insetBy: 6) corners do: [:out :in |  (pt - out) abs < (6 @ 6) ifTrue: [ ^(in + (Point r: 5.0 degrees: (pt - in) degrees)) asIntegerPoint ] ].  ^ptinToggleArea: aPoint  ^self toggleRectangle containsPoint: aPointactivateFilterWith: patternString  (function isKindOf: FTFilterFunction) ifFalse: [ ^self ].  function filterNowWith: patternStringraisedColor  (color isColor and: [ color isTransparent and: [ owner notNil ] ]) ifTrue: [ ^owner raisedColor ].  ^color asColor raisedColordraggedTo: aPoint  self position: aPoint + startGapbold  self changeEmphasis: #boldautoDeselection: aBoolean  autoDeselection := aBooleanfont: aFont  self normalLabel allMorphsDo: [:m |  (m respondsTo: #font:) ifTrue: [ m font: aFont ] ].  self selectedLabel allMorphsDo: [:m |  (m respondsTo: #font:) ifTrue: [ m font: aFont ] ]isResizeableMorph: submorph forSplitter: e  | done |  done := e splitsTopAndBottom ifTrue: [ submorph layoutFrame isVerticallyResizeable ] ifFalse: [ submorph layoutFrame isHorizontallyResizeable ].  ^donenewMenuFor: aModel  ^self theme newMenuIn: self for: aModelselectItemsRequest: anAnnounce  self selectedItems: anAnnounce itemsToSelectmouseUpOnSingle: event  | row mdr |  row := self rowAtLocation: event position.  event hand hasSubmorphs ifFalse: [ mdr := self mouseDownRow.        self mouseDownRow: nil.        mdr ifNil: [ ^self ] ].  (self enabled and: [ model okToChange ]) ifFalse: [ ^self ].  row == self selectionIndex ifTrue: [ self autoDeselect ifTrue: [ row = 0 ifFalse: [ self changeModelSelection: 0 ] ] ifFalse: [ self changeModelSelection: row ] ] ifFalse: [ self changeModelSelection: row ].  Cursor normal showsearchedElement  ^searchedElementpageSize: anInteger  pageSize := anIntegerdoFastFrameDrag: grabPoint  (FastDraggingFrameMorph forDragging: self clickedAt: grabPoint) openInWorldhandlesMouseDown: anEvent  ^truecalculateArcLengths  | array radius |  radius := self cornerRadius.  array := Array new: radius.  1 to: radius do: [:i |  | x |        x := i - 0.5.        array at: i put: (radius - (2 * x * radius - (x * x)) sqrt) asInteger ].  self arcLengths: arrayinitialize  super initialize.  self highlighted: falseinstallEditorToReplace: priorEditor  | stateArray |  priorEditor ifNotNil: [ stateArray := priorEditor stateArray ].  editor := self editorClass forMorph: self.  priorEditor ifNotNil: [ editor stateArrayPut: stateArray ].  self selectionChanged.  ^editorchangeMargins: evt  | handle origin aHand newMargin |  aHand := evt ifNil: [ self primaryHand ] ifNotNil: [ evt hand ].  origin := aHand position.  handle := HandleMorph new forEachPointDo: [:newPoint |  handle removeAllMorphs.        handle addMorph: (LineMorph from: origin to: newPoint color: Color black width: 1).        newMargin := (newPoint - origin max: 0 @ 0) // 5.        self margins: newMargin asMargin ] lastPointDo: [:newPoint |  handle deleteBalloon.        self halo ifNotNil: [:halo |  halo addHandles ] ].  aHand attachMorph: handle.  handle showBalloon: 'Move cursor down and to the rightto increase margin inset.Click when done.' hand: evt hand.  handle startSteppingcleanStepList  ^stepList sortBlock: self stepListSortBlockdefaultColor  ^defaultColor ifNil: [ self theme textColor ]owner  ^ownerinitialize  pressed := false.  super initializenewMouseFocus: aMorphOrNil  self mouseFocus: aMorphOrNilcontentString  ^self valueOfProperty: #contentStringinitializeScrollBars  (scrollBar := ScrollBar new     model: self;     setValueSelector: #vScrollBarValue:)     borderWidth: 1;     borderColor: Color black.  (hScrollBar := ScrollBar new     model: self;     setValueSelector: #hScrollBarValue:)     borderWidth: 1;     borderColor: Color black.  self initializeScroller.  self addMorph: scrollBar.  self addMorph: hScrollBar.  self alwaysShowVScrollbar ifTrue: [ self alwaysShowVScrollBar: true ].  self alwaysHideHScrollbar ifTrue: [ self hideHScrollBarIndefinitely: true ] ifFalse: [ self alwaysShowHScrollbar ifTrue: [ self alwaysShowHScrollBar: true ] ]adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self hasSubMenu ifTrue: [ self subMenu adoptPaneColor: paneColor ]borderColorForItems: colorCollection  (selectedItems select: [:m |  m isKindOf: BorderedMorph ]) with: colorCollection do: [:m :c |  m borderColor: c ]buildToggleButtonNoLabel  ^PluggableToggleButtonMorph on: self getState: nil action: #toggleAction: label: nil icon: #icon menu: nildefaultColor  ^Color r: 0.8 g: 1.0 b: 0.8wrapScrolling  ^wrapScrollingiconRightOffset  ^10 * self displayScaleFactordefaultColor  ^Color transparentaddIfNeededTitle: aTitle andIcon: anIcon  (aTitle notNil or: [ anIcon notNil ]) ifTrue: [ self addTitle: aTitle icon: anIcon ]toggleExpandedState  isExpanded := isExpanded not.  self refreshExpandedStatefullBounds  fullBounds ifNotNil: [ ^fullBounds ].  ^submorphs ifEmpty: [ bounds ] ifNotEmpty: [ self doLayoutIn: self layoutBounds.        fullBounds ]nextWindow  | sys |  sys := self systemWindows.  sys ifEmpty: [ ^nil ].  ^sys after: self currentWindow ifAbsent: [ sys first ]scrollSelectionIntoView  self listManager selectedMorph ifNotNil: [:morph |  self scrollToShow: morph contentBounds ]reduceVertices  | dup |  [ (dup := self nextDuplicateVertexIndex) > 0 ] whileTrue: [ self setVertices: (vertices copyWithoutIndex: dup) ].  ^vertices sizeaddNestedYellowButtonItemsTo: aMenu event: evt  | underMouse submenu |  self addYellowButtonMenuItemsTo: aMenu event: evt.  underMouse := self submorphThat: [:each |  each containsPoint: evt position ] ifNone: [ ^self ].  (underMouse addMyYellowButtonMenuItemsToSubmorphMenus and: [ underMouse hasYellowButtonMenu ]) ifFalse: [ ^self ].  aMenu addLine.  submenu := UIManager default newMenuIn: underMouse for: underMouse.  underMouse addNestedYellowButtonItemsTo: submenu event: evt.  aMenu add: underMouse externalName icon: (underMouse iconOrThumbnailOfSize: 16) subMenu: submenucolor: aColor  selectAll  self isMultipleSelection ifFalse: [ ^self ].  self selectionModeStrategy selectAllwrapDirection: aSymbol  wrapDirection := aSymbollabel  ^labeldrawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: aCanvas ]balloonHelpDelayTime  ^self theme settings balloonHelpDelayTimetopHeaderBackground: aFillStyle  topHeaderBackground := aFillStyleitems  ^itemsroundedCorners  ^#(1 4)selectionStart: startBlock selectionStop: stopBlock  selectionStart := startBlock.  selectionStop := stopBlockgetRootsSelector  ^getRootsSelectortestSortFunction  | dataSource |  dataSource := self dataSourceForTesting.  strategy sortFunction: #yourself ascending.  self assert: dataSource elements equals: self elementsForTestDataSource.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy reset.  strategy sortFunction: #asString ascending.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 10 2 3 4 5 6 7 8 9)on: anObject getState: getStateSel action: actionSel label: labelSel icon: iconSel menu: menuSel  self model: anObject.  getStateSelector := getStateSel.  actionSelector := actionSel.  getLabelSelector := labelSel.  getIconSelector := iconSel.  getMenuSelector := menuSel.  self     update: (labelSel ifNil: [ iconSel ]);     update: getStateSelminWidth  ^self perform: #minWidth withArguments: #() inSuperclass: MorphselectedItems  ^self selectedNodes collect: [:n |  n item ]initialize  super initialize.  self orientation: #horizontalsetContentMorph: aMorph  self removeAllMorphs.  self addMorph: aMorph fullFrame: LayoutFrame identitystraightLineSegmentsDo: endPointsBlock  | beginPoint |  beginPoint := nil.  vertices do: [:vert |  beginPoint ifNotNil: [ endPointsBlock value: beginPoint value: vert ].        beginPoint := vert ].  (closed or: [ vertices size = 1 ]) ifTrue: [ endPointsBlock value: beginPoint value: vertices first ]icon: aForm  composeAllStartingAt: characterIndex  firstCharacterIndex := characterIndex.  offsetToEnd := text size - firstCharacterIndex.  self composeAlltab: anObject  tab := anObjectselectItems: aNodeItemCollection  self selectedItems: aNodeItemCollectionmodel: anObject  model ifNotNil: [ model removeDependent: self ].  anObject ifNotNil: [ anObject addDependent: self ].  model := anObjectdrawable: aBoolean  drawable := aBooleandefaultBounds  ^0 @ 0 extent: 10 @ 10browseAction  | classDefiningAction |  classDefiningAction := self model class whichClassIncludesSelector: self actionSelector.  Smalltalk tools browser openOnClass: classDefiningAction selector: self actionSelectordrawOnAthensCanvas: anAthensCanvas  super drawOnAthensCanvas: anAthensCanvas.  self drawKeyTextOnAthenCanvas: anAthensCanvassortingIcon  ^self subclassResponsibilityborderWidth  ^self borderStyle widthexpandItemPath: aNodePath  (self allNodeMorphs at: 1 ifAbsent: [ ^self ]) openItemPath: aNodePathhandleMouseWheel: anEvent  ^self dispatchDefault: anEvent with: morphsearchingString  ^self contents asStringfilterListWith: char  | matchString |  matchString := self valueOfProperty: #matchString ifAbsentPut: [ String new ].  matchString := char = Character backspace ifTrue: [ matchString isEmpty ifTrue: [ matchString ] ifFalse: [ matchString allButLast ] ] ifFalse: [ matchString copyWith: char ].  self setProperty: #matchString toValue: matchStringaddMorphs  self addMorph: toolbar fullFrame: (LayoutFrame identity           bottomFraction: 0;           bottomOffset: TabMorph defaultHeight + (2 * self displayScaleFactor);           yourself).  self addMorph: container fullFrame: (LayoutFrame identity           topOffset: TabMorph defaultHeight + 2;           yourself).  container addMorph: contentsWrapper fullFrame: (LayoutFrame identity           topOffset: 2;           rightOffset: -1;           bottomOffset: -1;           leftOffset: 2;           yourself)invalidRect: aRectangle from: aMorph  | damageRect |  aRectangle hasPositiveExtent ifFalse: [ ^self ].  damageRect := aRectangle.  aMorph == self ifFalse: [ self clipSubmorphs ifTrue: [ damageRect := aRectangle intersect: self clippingBounds ifNone: [ ^self ] ] ].  owner ifNotNil: [ owner invalidRect: damageRect from: self ]heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]step  collapseItem  dataSource updateAvailableRows: 1 - self availableRows.  children := #().  expanded := falsenewTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletion  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletionsliderExtent  ^bounds isWide ifTrue: [ self sliderThickness @ self innerBounds height ] ifFalse: [ self innerBounds width @ self sliderThickness ]step  target ifNotNil: [ self position: target position + offsetFromTarget ]extent: aPoint  self extent = aPoint ifTrue: [ ^self ].  super extent: aPoint.  self     updateTabs;     ensureSelectedTabIsVisibleexploreItem  self inspecttestIsBeforeColumn  self deny: (strategy is: 3 beforeColumn: 9).  self deny: (strategy is: 3 beforeColumn: 4).  self deny: (strategy is: 3 beforeColumn: 7)handleNextMonthTouched  self date: date onNextMonth.  self changedremoveHaloFromClick: anEvent on: aMorph  | halo |  halo := self halo ifNil: [ ^self ].  (halo target hasOwner: self) ifTrue: [ ^self ].  (halo staysUpWhenMouseIsDownIn: aMorph) ifFalse: [ self removeHalo ]addFontSizeHandle: haloSpec  innerTarget isTextMorph ifTrue: [ self addHandle: haloSpec on: #mouseDown send: #chooseFont to: innerTarget ]addMorphInFrontOfLayer: aMorph  | targetLayer |  targetLayer := aMorph morphicLayerNumber.  submorphs do: [:each |  | layerHere |        each == aMorph ifTrue: [ ^self ].        layerHere := each morphicLayerNumber.        targetLayer <= layerHere ifTrue: [ ^self addMorph: aMorph inFrontOf: each ] ].  self addMorphBack: aMorphsetActualFont: aFont  actualFont := aFont.  aFont textStyle ifNotNil: [:ts |  fontNumber := ts fontIndexOf: aFont ]notExpandedForm  ^self theme treeUnexpandedFormcellPositioning: aSymbol  self assureTableProperties cellPositioning: aSymbol.  self layoutChangeduseDefaultFill  self fillStyle: self defaultColorchangeBorderWidth: evt  | aHand origin handle newWidth |  aHand := evt ifNil: [ self primaryHand ] ifNotNil: [ evt hand ].  origin := aHand position.  handle := HandleMorph new forEachPointDo: [:newPoint |  handle removeAllMorphs.        handle addMorph: (LineMorph from: origin to: newPoint color: Color black width: 1).        newWidth := (newPoint - origin) r asInteger // 5.        self borderWidth: newWidth ] lastPointDo: [:newPoint |  handle deleteBalloon.        self halo ifNotNil: [:halo |  halo addHandles ] ].  aHand attachMorph: handle.  handle showBalloon: 'Move cursor farther fromthis point to increase border width.Click when done.' translated hand: evt hand.  handle startSteppingisMultiple  ^falseisRoot  ^trueuncollapseToHand  | nakedMorph |  nakedMorph := uncollapsedMorph.  uncollapsedMorph := nil.  nakedMorph setProperty: #collapsedPosition toValue: self position.  mustNotClose := false.  self delete.  ActiveHand attachMorph: nakedMorphmouseUp: evt  | result |  result := super mouseUp: evt.  self pressed: index.  ^resultlastSelectedNodePath  ^self subclassResponsibilityupdate: aSelector  self textSelector ifNotNil: [ aSelector = self textSelector ifTrue: [ | morph |              morph := (aSelector isSymbol and: [ model notNil ]) ifTrue: [ (self model perform: aSelector) asMorph ] ifFalse: [ aSelector value asMorph ].              self subMorph: morph ] ].  self changedselectLastVisibleRow  ^self selectRowIndex: (container exposedRows ifNotEmpty: [:rows |  rows keys last ] ifEmpty: [ 0 ])initRow  self buildRowMorph.  self layoutChangedupdateSelectionWithCollectBlock: aBlock  | index |  self table selectedIndexes ifEmpty: [ ^self ].  index := self indexOfChangedItem.  self table selectIndexes: (self table selectedIndexes collect: [:ind |  aBlock value: ind value: index ]) asSet asArray andMakeVisibleIf: falseisVerticallyResizeable  ^self bottomFraction ~= self topFractionsvMorph  ^svMorphdecrement  self value: self value - self quantumextent: aPoint  super extent: aPoint.  self adoptPaneColorflushLayoutCache  cachedMinExtent := niladoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self selectionColor: self selectionColor.  self borderStyle baseColor: paneColor twiceDarkerelementAt: index  ^self elements at: indexgetModelState  model ifNil: [ ^false ].  ^getStateSelector ifNil: [ false ] ifNotNil: [ getStateSelector numArgs = 0 ifTrue: [ model perform: getStateSelector ] ifFalse: [ argumentsProvider ifNotNil: [ arguments := argumentsProvider perform: argumentsSelector ].              model perform: getStateSelector withEnoughArguments: arguments ] ]currentlyExpanded  ^self expandedNodesFrom: self allNodeMorphsindexForInserting: aPoint inList: morphList horizontal: aBool target: aMorph  | cmp1 cmp2 cmp3 noWrap |  properties := aMorph layoutProperties.  noWrap := properties wrapDirection == #none.  aBool ifTrue: [ properties listDirection == #rightToLeft ifTrue: [ cmp1 := [:rect |  aPoint x > rect left ] ] ifFalse: [ cmp1 := [:rect |  aPoint x < rect right ] ].        properties wrapDirection == #bottomToTop ifTrue: [ cmp2 := [:rect |  aPoint y > rect top ].              cmp3 := [:rect |  aPoint y > rect bottom ] ] ifFalse: [ cmp2 := [:rect |  aPoint y < rect bottom ].              cmp3 := [:rect |  aPoint y < rect top ] ] ] ifFalse: [ properties listDirection == #bottomToTop ifTrue: [ cmp1 := [:rect |  aPoint y > rect top ] ] ifFalse: [ cmp1 := [:rect |  aPoint y < rect bottom ] ].        properties wrapDirection == #rightToLeft ifTrue: [ cmp2 := [:rect |  aPoint x > rect left ].              cmp3 := [:rect |  aPoint x > rect right ] ] ifFalse: [ cmp2 := [:rect |  aPoint x < rect right ].              cmp3 := [:rect |  aPoint x < rect left ] ] ].  morphList keysAndValuesDo: [:index :m |  | box |        self flag: #pharoFixMe.        box := m fullBounds.        noWrap ifTrue: [ (cmp1 value: box) ifTrue: [ ^index ] ] ifFalse: [ (cmp3 value: box) ifTrue: [ ^index ].              ((cmp1 value: box) and: [ cmp2 value: box ]) ifTrue: [ ^index ] ] ].  ^morphList size + 1onSelectionChangeSend: aSelector to: anObject  self on: MorphTreeSelectionChanged send: aSelector to: anObjectnewContents: stringOrText  | newText embeddedMorphs |  newText := stringOrText isString ifTrue: [ | textSize |        (text notNil and: [ (textSize := text size) > 0 and: [ (text runLengthFor: 1) = textSize ] ]) ifTrue: [ | attribs |              attribs := text attributesAt: 1 forStyle: textStyle.              Text string: stringOrText copy attributes: attribs ] ifFalse: [ Text fromString: stringOrText copy ] ] ifFalse: [ stringOrText copy asText ].  (text = newText and: [ text runs = newText runs ]) ifTrue: [ ^self ].  text ifNotNil: [ (embeddedMorphs := text embeddedMorphs) ifNotNil: [ self removeAllMorphsIn: embeddedMorphs.              embeddedMorphs do: [:m |  m delete ] ] ].  text := newText.  newText embeddedMorphs do: [:m |  self addMorph: m.        m position: -1000 @ 0 ].  self releaseParagraph.  self paragraph.  self world ifNotNil: [ self world startSteppingSubmorphsOf: self ]setType: evtType startPoint: evtStart endPoint: evtEnd trail: evtTrail buttons: evtButtons hand: evtHand stamp: stamp  type := evtType.  startPoint := evtStart.  position := evtEnd.  trail := evtTrail.  buttons := evtButtons.  source := evtHand.  wasHandled := false.  timeStamp := stampisExplicit  self subclassResponsibilitywantsEasySelection  ^self isEasySelectingnumberOfRows  ^self elements ifNotNil: [ self elements size ] ifNil: [ 0 ]privateBounds: boundsRect  fullBounds := nil.  bounds := boundsRectkeyStrokeArrowDown: event  (self selectionModeStrategy is: self selectedIndex aboveRow: self numberOfRows) ifFalse: [ ^self ].  self resetFunction.  self selectIndex: (self selectionModeStrategy selectableIndexBellow: self selectedIndex) event: eventmouseEnterThumb: event  slider     fillStyle: self mouseOverThumbFillStyle;     borderStyle: self mouseOverThumbBorderStyle;     changed.  upButton     fillStyle: self mouseOverThumbButtonFillStyle;     borderStyle: self mouseOverThumbButtonBorderStyle;     changed.  downButton     fillStyle: self mouseOverThumbButtonFillStyle;     borderStyle: self mouseOverThumbButtonBorderStyle;     changedchangeClipSubmorphs  self clipSubmorphs: self clipSubmorphs notsetDirectionFrom: aPoint  | delta degrees inner |  inner := self renderedMorph.  inner == self ifTrue: [ ^self ].  delta := (inner transformFromWorld globalPointToLocal: aPoint) - inner referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedmouseDown: event  container enabled ifFalse: [ ^self ].  complexContents mouseDown: eventrootItems: aListOfItems  initialRootItems := aListOfItems.  super rootItems: initialRootItems copy.  self updateListstepListSortBlock  ^[:stepMsg1 :stepMsg2 |  stepMsg1 scheduledTime <= stepMsg2 scheduledTime ]addSourceToRootItem  rootItem dataSource: selflinkSplittersToSplitters  self splitters do: [:each |  each splitsTopAndBottom ifTrue: [ self splitters do: [:eachMorph |  eachMorph splitsTopAndBottom ~= each splitsTopAndBottom ifTrue: [ eachMorph layoutFrame bottomFraction = each layoutFrame topFraction ifTrue: [ each addLeftOrTop: eachMorph ].                          eachMorph layoutFrame topFraction = each layoutFrame bottomFraction ifTrue: [ each addRightOrBottom: eachMorph ] ] ] ] ifFalse: [ self splitters do: [:eachMorph |  eachMorph splitsTopAndBottom ~= each splitsTopAndBottom ifTrue: [ eachMorph layoutFrame rightFraction = each layoutFrame leftFraction ifTrue: [ each addLeftOrTop: eachMorph ].                          eachMorph layoutFrame leftFraction = each layoutFrame rightFraction ifTrue: [ each addRightOrBottom: eachMorph ] ] ] ] ]popUpOwner  ^nilsortingIcon  ^self state sortingIconwasHandled: aBool  drawOn: canvas  super drawOn: canvas.  self drawRowsOn: canvasinitialize  super initialize.  outOfWorldCount := intoWorldCount := 0selectionChanged  self paragraph selectionRects do: [:r |  | intr |        intr := r intersect: self fullBounds ifNone: [ nil ].        intr ifNotNil: [ self invalidRect: (self expandFullBoundsForDropShadow: intr) ] ]expandedForm  ^self theme treeExpandedFormhandleMouseEnter: anEvent  ^self dispatchDefault: anEvent with: morphnewButtonLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newButtonLabelIn: self for: aModel label: aString getEnabled: enabledSelmatches: aString  ^(regex matchesIn: aString) notEmptyadd: aLabelString selector: aSymbol argument: arg  ^self add: aLabelString target: defaultTarget selector: aSymbol argumentList: (Array with: arg)originalObject  ^originalObjectmouseLeaveDragging: evt  self noMorePotentialDropTargethandleDropFiles: anEvent  ^self dispatchDefault: anEvent with: morphacceptContents  isExpanded  ^trueballoonText  ^complexContents balloonText ifNil: [ super balloonText ]drawDaysOn: aCanvas  days do: [:each |  each drawOn: aCanvas offset: self bounds topLeft ]notify: anEvent from: sourceMorph  | arity |  recipient ifNil: [ ^self ].  arity := selector numArgs.  arity = 0 ifTrue: [ ^recipient perform: selector ].  arity = 1 ifTrue: [ ^recipient perform: selector with: anEvent ].  arity = 2 ifTrue: [ ^recipient perform: selector with: anEvent with: sourceMorph ].  arity = 3 ifTrue: [ ^recipient perform: selector with: valueParameter with: anEvent with: sourceMorph ].  self error: 'Event handling selectors must be Symbols and take 0-3 arguments'newGroupbox: aString forAll: controls  ^self theme newGroupboxIn: self label: aString forAll: controlsnewToolDockingBar  ^self theme newToolDockingBarIn: selfrotationDegrees: degrees  | ref newPos flex origAngle origCenter |  ref := self referencePosition.  origAngle := originalAngle ifNil: [ self heading ].  origCenter := originalCenter ifNil: [ self center ].  flex := (MorphicTransform offset: ref negated) withAngle: (degrees - origAngle) degreesToRadians.  newPos := (flex transform: origCenter) - flex offset.  self position: (self position + newPos - self center) asIntegerPoint.  referencePosition := ref.  originalAngle := origAngle.  originalCenter := origCenter.  self forwardDirection: degrees.  self changedborderWidth: anInteger  super borderWidth: anInteger.  self updateGradientsnodeStringGetter: aSelectorOrAValuable  rowMorphGetSelector := aSelectorOrAValuable isSymbol ifTrue: [ [:node |  (node complexContents perform: aSelectorOrAValuable) asMorph ] ] ifFalse: [ [:node |  (aSelectorOrAValuable value: node complexContents) asMorph ] ]getImageSelector  ^getImageSelectorgetLabelSelector  ^getLabelSelectordrawKeyboardFocusOnAthensCanvas: anAthensCanvas  self focusIndicatorMorph drawOnAthensCanvas: anAthensCanvasdefaultBorderColor  ^self defaultColor muchDarkerhResizing  | props |  props := self layoutProperties.  ^props ifNil: [ #rigid ] ifNotNil: [ props hResizing ]visibleClearArea  ^self viewBox intersect: self clearArea ifNone: [ 0 @ 0 corner: 0 @ 0 ]showMenuForPosition: aPoint  | tuple |  tuple := self container rowAndColumnIndexContainingPoint: aPoint.  self showMenuForIndex: tupleinitializeTrackedMorphs  leftMorphs := OrderedCollection new.  overMorphs := WriteStream on: #().  enteredMorphs := WriteStream on: #()setNameTo: aName  | nameToUse nameString |  nameToUse := aName ifNotNil: [ (nameString := aName asString) notEmpty ifTrue: [ nameString ] ifFalse: [ '*' ] ].  self setNamePropertyTo: nameToUsetargetPoint  ^self target bounds pointAtSideOrCorner: self edgeNametestRowIndexFrom  self subclassResponsibilityisCursorOverHandle  ^self class showSplitterHandles not or: [ self handleRect containsPoint: ActiveHand cursorPoint ]red: anInteger  | c |  c := self selectedColor.  self selectedColor: ((Color r: anInteger g: c green * 255 b: c blue * 255 range: 255) alpha: c alpha)keepOpen  ^self class keepOpennewAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletionsetGridSpec  | response result |  response := UIManager default request: 'New grid origin (usually 0@0):' translated initialAnswer: self gridOrigin printString.  response isEmpty ifTrue: [ ^self ].  result := [ self class compiler evaluate: response ] ifError: [ ^self ].  (result isPoint and: [ result >= (0 @ 0) ]) ifTrue: [ self gridOrigin: result ] ifFalse: [ self inform: 'Must be a Point with coordinates (for example 10@10)' translated ].  response := UIManager default request: 'New grid spacing:' translated initialAnswer: self gridModulus printString.  response isEmptyOrNil ifTrue: [ ^self ].  result := [ self class compiler evaluate: response ] ifError: [ ^self ].  (result isPoint and: [ result > (0 @ 0) ]) ifTrue: [ self gridModulus: result ] ifFalse: [ self inform: 'Must be a Point with coordinates (for example 10@10)' translated ]drawArrowOnAthensCanvas: anAthensCanvas at: endPoint from: priorPoint  | pts spec wingBase path |  pts := self arrowBoundsAt: endPoint from: priorPoint.  wingBase := pts size = 4 ifTrue: [ pts third ] ifFalse: [ (pts copyFrom: 2 to: 3) average ].  spec := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  path := anAthensCanvas createPath: [:builder |  builder absolute.        builder moveTo: pts first.        pts allButFirst do: [:p |  builder lineTo: p ].        builder close ].  spec x sign = spec y sign ifTrue: [ anAthensCanvas setPaint: self borderColor ] ifFalse: [ (anAthensCanvas setStrokePaint: self borderColor) width: (borderWidth + 1) // 2 ].  anAthensCanvas drawShape: path.  ^wingBasehasCloseBox  ^closeBox notNilcolorFor: index  index odd ifTrue: [ ^Smalltalk ui theme lightBackgroundColor ].  ^Smalltalk ui theme backgroundColormarried  ^marriednextSibling  ^nextSiblingnewSVSelector: aColor help: helpText  ^self theme newSVSelectorIn: self color: aColor help: helpTextimageForm: depth forRectangle: rect  | canvas |  canvas := Display defaultCanvasClass extent: rect extent depth: depth.  canvas translateBy: rect topLeft negated during: [:tempCanvas |  tempCanvas fullDrawMorph: self ].  ^canvas form offset: rect topLeftnewHSVColorMorph  ^HSVColorSelectorMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     when: #colorSelected send: #colorSelected: to: selfnumberOfMethodsColumn: column row: rowIndex  ^FTCellMorph new     addMorph: (self elementAt: rowIndex) numberOfMethods asStringMorph;     yourselffeedbackColor: aColor  feedbackColor := aColor.  self changeddefaultLabel  ^'|'pagerColor  ^treeMorph pagerColorcleanProcesses  processes do: [:each |  each terminate ].  processes removeAllfirstName: aString  self item firstName: aString.  self changed: #firstNameaddARow: aCollectionOfMorphs  | row |  row := self class inARow: aCollectionOfMorphs.  self addMorphBack: row.  ^rowdrawOn: aCanvas  drawable ifFalse: [ container buildRowMorphsFrom: self ] ifTrue: [ super drawOn: aCanvas ]isMouseLeave  ^self type == #mouseLeavedropItemSelector  ^dropItemSelectormouseLeaveUpButton: event  event redButtonPressed ifFalse: [ upButton           fillStyle: self normalButtonFillStyle;           borderStyle: self normalButtonBorderStyle;           changed ]leftCenter  ^bounds leftCentersubmorphBounds  ^(self localVisibleSubmorphBounds ifNotNil: [:box |  transform localBoundsToGlobal: box ] ifNil: [ self bounds ]) truncatedactivateOwnerMenu: evt  | popUpOwner |  (owner isNil or: [ owner isMenuMorph not ]) ifTrue: [ ^false ].  (owner fullContainsPoint: evt position) ifTrue: [ owner activate: evt.        ^true ].  popUpOwner := owner popUpOwner.  [ popUpOwner ] whileNotNil: [ (popUpOwner owner fullContainsPoint: evt position) ifTrue: [ popUpOwner owner activate: evt.              ^true ] ifFalse: [ popUpOwner := popUpOwner owner popUpOwner ] ].  ^falsestep  | eventSource |  eventSource := hand lastEvent.  eventSource anyButtonPressed ifTrue: [ waitingForClickInside := false.        self position: eventSource cursorPoint - (self extent // 2).        pointBlock value: self center ] ifFalse: [ waitingForClickInside ifTrue: [ (self containsPoint: eventSource cursorPoint) ifFalse: [ ^self delete ] ] ifFalse: [ lastPointBlock value: self center.              ^self delete ] ]defaultBorderWidth  ^1labelMorph: anObject  labelMorph := anObjecthighlight  self allMorphsDo: [:m |  (m isKindOf: StringMorph) ifTrue: [ m setProperty: #originalColor toValue: m color.              m color: self theme selectionTextColor ] ].  complexContents highlightingColor ifNotNil: [:c |  self setProperty: #originalColor toValue: color.        self color: c ]wantsYellowButtonMenu  ^falsedoesOwnRotation  ^falseactivateFromKeyboard: evt  evt hand newMouseFocus: self.  self activate: evt.  self takeKeyboardFocus.  self moveSelectionDown: 1 event: evtremoveObsoleteEventHandlers  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  scroller submorphs do: [:m |  m           eventHandler: nil;           highlightForMouseDown: false;           resetExtension ]wantsKeyboardFocusFor: aSubmorph  aSubmorph wouldAcceptKeyboardFocus ifTrue: [ ^true ].  ^super wantsKeyboardFocusFor: aSubmorphopenInWindowLabeled: aString inWorld: aWorld  | window extent |  window := (SystemWindow labelled: aString) model: nil.  window     bounds: (RealEstateAgent initialFrameFor: window initialExtent: self fullBounds extent world: aWorld);     addMorph: self frame: (0 @ 0 extent: 1 @ 1);     updatePaneColors.  extent := self fullBounds extent + (window borderWidth @ window labelHeight) + window borderWidth + ((window class borderWidth * 2) @ (window class borderWidth + 1)).  window extent: extent.  aWorld addMorph: window.  window activate.  aWorld startSteppingSubmorphsOf: window.  window announceOpened.  ^windowfont: aFont  titleContainer ifNil: [ ^self ].  titleContainer submorphsDo: [:stringMorph |  stringMorph font: aFont ]veryDeepInner: deepCopier  super veryDeepInner: deepCopier.  selectedItem := selectedItem veryDeepCopyWith: deepCopier.  stayUp := stayUp veryDeepCopyWith: deepCopier.  popUpOwner := popUpOwner.  activeSubMenu := activeSubMenuenablementSelector: anObject  enablementSelector := anObjectmouseOverButtonFillStyle  ^self theme scrollbarMouseOverButtonFillStyleFor: selfnewAlphaImage: aForm help: helpText  ^self theme newAlphaImageIn: self image: aForm help: helpTextupdateButtonsAndPreview  self     updateTaskButtons;     updatePreview.  self world ifNotNil: [ self center: self world center ]initialize  super initialize.  self     changeTableLayout;     cellPositioning: #topLeft;     cellInset: 2;     vResizing: #shrinkWrap;     hResizing: #rigidmouseUp: anEvent  (self bounds containsPoint: anEvent cursorPoint) ifFalse: [ anEvent hand showTemporaryCursor: nil ].  self adoptPaneColor: self paneColordefaultBorderColor  ^self theme darkBaseColordrawOn: aCanvas  super drawOn: aCanvas.  self columns do: [:col |  col drawColumnOn: aCanvas ]cellColumn: column row: rowIndex  | object text icon |  object := self elementAt: rowIndex.  icon := self getIconSelector ifNotNil: [:selector |  self model perform: selector with: object ].  text := column transform: (self elementWrapped: object).  ^self createCellText: text icon: iconselected: x  selected := x.  self changed: #selecteddetachSubMenu: evt  | possibleTargets item subMenu index |  possibleTargets := self items select: [:any |  any hasSubMenu ].  possibleTargets isEmpty ifTrue: [ ^self ].  index := UIManager default chooseFrom: (possibleTargets collect: [:t |  t contents asString ]) title: 'Which menu?' translated.  index = 0 ifTrue: [ ^self ].  item := possibleTargets at: index.  subMenu := item subMenu.  subMenu ifNotNil: [ item subMenu: nil.        item delete.        subMenu stayUp: true.        subMenu popUpOwner: nil.        subMenu addTitle: item contents.        evt hand attachMorph: subMenu ]veryDeepFixupWith: deepCopier  | old |  super veryDeepFixupWith: deepCopier.  1 to: self class instSize do: [:ii |  old := self instVarAt: ii.        self instVarAt: ii put: (deepCopier references at: old ifAbsent: [ old ]) ]allMorphsInto: aSet  submorphs do: [:m |  m allMorphsInto: aSet ].  self allNonSubmorphMorphs do: [:m |  (aSet includes: m) ifFalse: [ m allMorphsInto: aSet ] ].  aSet add: self.  ^aSetisHorizontallyResizeable  ^self rightFraction ~= self leftFractionred  ^(self selectedColor red * 255) asIntegerresetFunction  function resetshowMouseFocusEvent: evt  ShowEvents == true ifTrue: [ | ofs |        ofs := ((owner hands indexOf: self) - 1) * 60.        self mouseFocus printString displayAt: 0 @ ofs + (0 @ 15) ]label: anObject  label := anObjectnewPluggableDialogWindow: title for: contentMorph  ^self theme newPluggableDialogWindowIn: self title: title for: contentMorphchildrenItems  ^(self item subclasses asArray sort: [:a :b |  a name < b name ]) asOrderedCollectionnewEmbeddedMenu  ^self theme newEmbeddedMenuIn: self for: selftoggleResistsRemoval  self resistsRemoval ifTrue: [ self removeProperty: #resistsRemoval ] ifFalse: [ self setProperty: #resistsRemoval toValue: true ]icon: aForm  directionArrowLength  ^25drawOn: aCanvas  super drawOn: aCanvas.  (self enabled not and: [ self disabledStyle = #inset ]) ifTrue: [ aCanvas drawString: self contents in: (self stringBounds translateBy: 1) font: self fontToUse color: self theme lightBackgroundColor ]blue: anInteger  | c |  c := self selectedColor.  self selectedColor: ((Color r: c red * 255 g: c green * 255 b: anInteger range: 255) alpha: c alpha)hResizing: aSymbol  self assureLayoutProperties hResizing: aSymbol.  self layoutChangedmove: anEvent for: model controller: editor  | action clickPoint |  clickPoint := anEvent cursorPoint.  action := false.  self actionAttributesUnder: clickPoint event: anEvent do: [:attribute |  | target |        target := model ifNil: [ editor morph ].        (attribute actOnMove: anEvent for: target in: self editor: editor) == true ifTrue: [ ^true ] ].  (action and: [ Cursor currentCursor == Cursor webLink ]) ifTrue: [ Cursor normal show ].  ^actionstep  | newBounds |  target ifNil: [ ^self ].  newBounds := target isWorldMorph ifTrue: [ target bounds ] ifFalse: [ self localHaloBoundsFor: target renderedMorph ].  newBounds = self bounds ifTrue: [ ^self ].  newBounds extent = self bounds extent ifTrue: [ ^self position: newBounds origin ].  growingOrRotating ifFalse: [ submorphs size > 1 ifTrue: [ self addHandles ] ].  self bounds: newBoundsnewDataSourceMatching: aFTFilter  | newElements wrappedItem text newDataSource modelCopy |  newElements := self elements select: [:each |  wrappedItem := self elementWrapped: each.        table columns anySatisfy: [:column |  text := column transform: wrappedItem.              aFTFilter matches: text ] ].  newDataSource := self copy.  modelCopy := self model copy.  modelCopy prepareForFilteredDataSourceWith: newElements.  newDataSource model: modelCopy.  ^newDataSourcebuttonImageColor  ^self theme scrollbarImageColorFor: selfeventHandler  ^eventHandlerthemeChanged  self initializeAppearance.  self removeAllMorphs.  super themeChanged.  self updateTaskButtonsreadFromFile  | fileName |  fileName := UIManager default request: 'Please enter the image file name' translated initialAnswer: 'fileName'.  fileName isEmptyOrNil ifTrue: [ ^self ].  self form: (Form fromFileNamed: fileName)textBounds  ^boundscanDisplayChildrenOf: item  ^self maxDepth ifNil: [ true ] ifNotNil: [ self maxDepth > item depth ]newStack  ^self theme newStackIn: self for: #()nodeList  ^treeMorph nodeListactiveDisabledNotOverDownFillStyle: aFillStyle  self stateMap atPath: #(active disabled notOver down) put: aFillStyle.  self changedtextStyle  ^self actualFont textStyle ifNil: [ TextStyle default ]actualClass  ^self subclassResponsibilityfirstCharacterIndex  ^self paragraph firstCharacterIndexhandle: aFileReference in: pasteUp dropEvent: anEvent  | fileName services theOne |  fileName := aFileReference fullName.  services := self servicesForFileNamed: fileName.  services isEmpty ifTrue: [ aFileReference inspect.        ^self ].  theOne := self chooseServiceFrom: services.  theOne ifNotNil: [ theOne performServiceFor: aFileReference ]isSystemWindow  ^trueaddAddHandMenuItemsForHalo: aMenu hand: aHandMorph  checkMorphsLeftOrTopFrom: splitter  | index size |  size := submorphs size.  index := submorphs identityIndexOf: splitter.  index := index + 1.  [ index <= size ] whileTrue: [ | submorph done |        submorph := submorphs at: index.        splitter addLeftOrTop: submorph.        done := self isResizeableMorph: submorph forSplitter: splitter.        done ifTrue: [ index := size + 1 ].        index := index + 1 ]barDeleted: aBar  self closeactiveHand: aHand  ActiveHand := aHand.  activeHand := aHandstoreOn: aStream  super storeOn: aStream.  aStream space.  self startPoint x storeOn: aStream.  aStream space.  self startPoint y storeOn: aStream.  aStream spacerefreshExpandedState  | newChildren toDelete c |  toDelete := OrderedCollection new.  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aNode recursiveAddTo: toDelete ] ].  container noteRemovalOfAll: toDelete.  (isExpanded and: [ complexContents hasContents ]) ifFalse: [ ^self changed ].  (c := complexContents contents) isEmpty ifTrue: [ ^self changed ].  newChildren := container addSubmorphsAfter: self fromCollection: c allowSorting: true.  firstChild := newChildren firsttreeLineDashes: anArrayOfInteger  treeLineDashes := anArrayOfIntegerdeactivate  doFastReframe: ptName  | newBounds |  newBounds := self boundsInWorld newRectButtonPressedDo: [:rectangle :cursorPoint |  rectangle withSideOrCorner: ptName setToPoint: cursorPoint minExtent: self minimumExtent ].  Display deferUpdatesIn: Display boundingBox while: [ self bounds: newBounds ].  ^newBoundslayoutBounds: aRectangle  super layoutBounds: aRectangle.  self updateFillStyle.  slider horizontal: self bounds isWide.  sliderShadow horizontal: self bounds isWidetextStyle: aTextStyle  textStyle := aTextStyleupdateSelectedLocation  self locationMorph position: self selectedLocation - (self locationMorph extent // 2 + (self locationMorph extent \\ 2))scrollDown: count  self setValue: (value + (scrollDelta * count) + 0.000001 min: 1.0)extent: aPoint  self basicExtent: aPoint.  (self layout = #scaled or: [ self layout = #scaledAspect ]) ifTrue: [ self cachedForm: nil ]announce: anAnnouncement  self doAnnounce: anAnnouncementsetTarget: evt  | rootMorphs |  rootMorphs := self world rootMorphsAt: evt hand targetPoint.  target := rootMorphs size > 1 ifTrue: [ rootMorphs second ]alpha: anObject  alpha := anObject.  self     cachedForm: nil;     changed;     changed: #alphadrawOnAthensCanvas: canvas  | bnd |  bnd := self bounds topLeft + self layoutInset.  font := self fontToUse.  canvas pathTransform restoreAfter: [ canvas pathTransform translateBy: bnd.        canvas pathTransform translateX: 0 Y: font getPreciseAscent.        canvas           setPaint: color;           setFont: self fontToUse;           drawString: contents ]isAdheringToBottom  ^self edgeToAdhereTo == #bottomrenameTo: aName  self topRendererOrSelf setNameTo: aName.  ^aNamesearchedElement  ^searchedElementstep  self subMorph step.  self changedhandlesMouseDown: evt  ^truesliderMorph: anObject  sliderMorph := anObjecticon  ^iconscreenLocation  ^self fullBounds originunlock  self lock: falseexpandAll  self roots reverseDo: [:m |  self expandAllSilently: m ].  self innerWidgetChangedaddDropShadowMenuItems: aMenu hand: aHand  | menu |  menu := UIManager default newMenuIn: self for: self.  menu addUpdating: #hasDropShadowString selector: #toggleDropShadow.  menu addLine.  menu add: 'shadow color...' target: self selector: #changeShadowColor.  menu add: 'shadow offset...' target: self selector: #setShadowOffset:.  aMenu add: 'drop shadow' subMenu: menuframeRectangle8: aRectangle on: aCanvas  | r |  r := aRectangle insetBy: self width // 2.  self width odd ifTrue: [ r := r insetBy: (0 @ 0 corner: 1 @ 1) ].  aCanvas     line: r topLeft + (8 @ 0) to: r topRight - (8 @ 0) width: self width color: self color;     line: r topRight + (-7 @ 1) to: r topRight + (-6 @ 1) width: self width color: self color;     line: r topRight + (-5 @ 2) to: r topRight + (-2 @ 5) width: self width color: self color;     line: r topRight + (-1 @ 6) to: r topRight + (-1 @ 7) width: self width color: self color;     line: r topRight + (0 @ 8) to: r bottomRight - (0 @ 8) width: self width color: self color;     line: r bottomRight - (1 @ 7) to: r bottomRight - (1 @ 6) width: self width color: self color;     line: r bottomRight - (2 @ 5) to: r bottomRight - (5 @ 2) width: self width color: self color;     line: r bottomRight - (6 @ 1) to: r bottomRight - (7 @ 1) width: self width color: self color;     line: r bottomRight - (8 @ 0) to: r bottomLeft + (8 @ 0) width: self width color: self color;     line: r bottomLeft - (-7 @ 1) to: r bottomLeft - (-6 @ 1) width: self width color: self color;     line: r bottomLeft - (-5 @ 2) to: r bottomLeft - (-2 @ 5) width: self width color: self color;     line: r bottomLeft - (-1 @ 6) to: r bottomLeft - (-1 @ 7) width: self width color: self color;     line: r bottomLeft - (0 @ 8) to: r topLeft + (0 @ 8) width: self width color: self color;     line: r topLeft + (1 @ 7) to: r topLeft + (1 @ 6) width: self width color: self color;     line: r topLeft + (2 @ 5) to: r topLeft + (5 @ 2) width: self width color: self color;     line: r topLeft + (6 @ 1) to: r topLeft + (7 @ 1) width: self width color: self colorisVisible  ^self tabSelector ifNil: [ false ] ifNotNil: [:selector |  selector visibleTabs includes: self ]beRight  self option: #righttrackPaneColor  ^trackPaneColorturnOff  self borderColor: #raised.  self color: offColorinitialize  super initialize.  needsRefreshExposedRows := false.  startColumnIndex := 0wantsDropElements: aCollection type: type index: rowIndex  ^falsestepTime  (self hasProperty: #doesButtonAction) ifTrue: [ ^1 ].  ^super stepTimesegmentedSlopesOf: knots  ^knots collectWithIndex: [:x :i |  (knots atWrap: i + 1) - x ]ownerChanged  self updateBounds.  ^super ownerChangedsecondName: anObject  secondName := anObjectdefaultBorderColor  ^Color r: 0.0 g: 0.419 b: 0.935vResizeScrollBar  | w topLeft |  w := self scrollBarThickness.  topLeft := bounds topRight - ((w + borderWidth - 0) @ (0 - borderWidth)).  scrollBar bounds: (topLeft extent: w @ self vScrollBarHeight)asMouseLeave  ^self shallowCopy setType: #mouseLeaveisDraggingEvent  ^falseenabled: aBoolean  self submorphsDo: [:m |  m enabled: aBoolean ]isComplex  ^falsenewTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletion  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletionisPressed  ^pressedstartDrag: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #startDrag from: sourceMorphmouseOverBorderStyle  ^self theme taskbarItemMouseOverBorderStyleFor: selfhandlesKeyboard: evt  ^evt anyModifierKeyPressed not or: [ evt commandKeyPressed and: [ self commandKeyHandler notNil ] ]testLeakingSelectionsOnUpdate  | c w t |  c := ClassTreeExample new.  [ w := c openOn: Collection.  t := c dependents last.  t expandAll.  t selectAll.  c updateList.  t listManager selectedMorphList do: [:each |  self assert: (t allNodeMorphs includes: each) ] ] ensure: [ w close ]stepAt: millisecondClockValue  self steprotationDegrees  ^0.0cellInset: aNumber  cellInset := aNumberthemeChanged  self selectionColor: self theme selectionColor.  self color: self defaultColor.  super themeChangeddrawOnAthensCanvas: anAthensCanvas  self drawOnCanvasWrapperFor: anAthensCanvaskeyStroke: anEvent  anEvent keyString = '<Cmd-a>' ifTrue: [ self selectAll ].  anEvent keyString = '<Cmd-A>' ifTrue: [ self deselectAll ]newCheckboxFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpTextstartAt: aNumber  startValue := aNumberhExtraScrollRange  ^5handlesKeyDown: evt  ^self handlesKeyboard: evtsubMorph  subMorph ifNil: [ self update: self textSelector ].  ^subMorphdrawOnAthensCanvas: anAthensCanvas bounds: aRectangle color: aColor  self displayCaretAndSelectionOnAthensCanvas: anAthensCanvas.  self displayExtraSelectionOnAthensCanvas: anAthensCanvas.  anAthensCanvas setPaint: aColor.  self displayTextOnAthensCanvas: anAthensCanvas in: aRectangledrawOn: aCanvas  self perform: #drawOn: withArguments: {aCanvas} inSuperclass: Morph.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: aCanvas ]initialize  super initialize.  self initForKeystrokesexploreItem  self inspectsubMenuMarker  owner isFloating ifTrue: [ ^self bottomArrow ].  owner isAdheringToTop ifTrue: [ ^self bottomArrow ].  owner isAdheringToBottom ifTrue: [ ^self upArrow ].  owner isAdheringToLeft ifTrue: [ ^self rightArrow ].  owner isAdheringToRight ifTrue: [ ^self leftArrow ].  ^self rightArrowmoveSelectionRight: direction event: anEvent  | index |  index := (submorphs indexOf: selectedItem ifAbsent: [ 1 - direction ]) + direction.  submorphs do: [:unused |  | m |        m := submorphs atWrap: index.        (m isMenuItemMorph and: [ m isEnabled ]) ifTrue: [ ^self selectItem: m event: anEvent ].        index := index + direction sign ].  ^self selectItem: nil event: anEventstyle  ^#insetflags  ^flags ifNil: [ 0 ]cleanupFilter  (function isKindOf: FTFilterFunction) ifTrue: [ function terminateFilterProcess ]testProperty  | dataSource |  dataSource := self dataSourceForTesting.  strategy property: #yourself.  self assert: dataSource elements equals: self elementsForTestDataSource.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy reset.  strategy property: #asString.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 10 2 3 4 5 6 7 8 9)iconBlock: aValuableWithOneArg  iconBlock := aValuableWithOneArgminResizerOffset  ^20selectablesToHighlightFromRow: aFTRow at: aRowIndex withHighlightedIndexes: highligtedIndexes andPrimaryIndex: primarySelectionIndex  | selectablesToColorMap |  selectablesToColorMap := Dictionary new.  (highligtedIndexes includes: aRowIndex) ifTrue: [ selectablesToColorMap at: aFTRow put: primarySelectionIndex = aRowIndex ].  ^selectablesToColorMapmouseDown: event onItem: aMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersgetAllButFirstCharacter  | aString |  ^(aString := text string) size > 1 ifTrue: [ aString copyFrom: 2 to: aString size ] ifFalse: [ '·' ]nonWindows  ^self submorphs select: [:m |  m isSystemWindow not and: [ m wantsToBeTopmost not ] ]wasActivatedFromDockingBar  ^activatorDockingBar notNilgetIconSelector: aSelector  self dataSource getIconSelector: aSelectorhandleEvent: aKeyboardEvent  aKeyboardEvent isWindowNavigation ifFalse: [ ^false ].  world theme openTaskListIn: world from: aKeyboardEvent.  ^trueborderInset  self borderColor: #insetmouseDown: evt  (evt shiftPressed and: [ self isEditable ]) ifTrue: [ ^super mouseDown: evt ].  isSelected ifTrue: [ owner selectItem: nil event: evt ] ifFalse: [ owner activate: evt.        owner selectItem: self event: evt ]newWindowFor: aModel title: titleString  ^self theme newWindowIn: self for: aModel title: titleStringuseSelectionBar  ^falsebuildRowMorphsFrom: aNodeMorph increment: anIncrement  Cursor wait showWhile: [ | subs idx max |        subs := self allNodeMorphs.        idx := aNodeMorph index.        max := idx + anIncrement min: subs size.        self buildRowMorphsFromIndex: idx to: max ]frameRectangle4: aRectangle on: aCanvas  | r |  r := aRectangle insetBy: self width // 2.  self width odd ifTrue: [ r := r insetBy: (0 @ 0 corner: 1 @ 1) ].  aCanvas     line: r topLeft + (4 @ 0) to: r topRight - (4 @ 0) width: self width color: self color;     line: r topRight + (-3 @ 1) to: r topRight + (-1 @ 2) width: self width color: self color;     line: r topRight + (-1 @ 2) to: r topRight + (-1 @ 3) width: self width color: self color;     line: r topRight + (0 @ 4) to: r bottomRight - (0 @ 4) width: self width color: self color;     line: r bottomRight - (1 @ 3) to: r bottomRight - (1 @ 2) width: self width color: self color;     line: r bottomRight - (2 @ 1) to: r bottomRight - (3 @ 1) width: self width color: self color;     line: r bottomRight - (4 @ 0) to: r bottomLeft + (4 @ 0) width: self width color: self color;     line: r bottomLeft - (-3 @ 1) to: r bottomLeft - (-2 @ 1) width: self width color: self color;     line: r bottomLeft - (-1 @ 2) to: r bottomLeft - (-1 @ 3) width: self width color: self color;     line: r bottomLeft - (0 @ 4) to: r topLeft + (0 @ 4) width: self width color: self color;     line: r topLeft + (1 @ 3) to: r topLeft + (1 @ 2) width: self width color: self color;     line: r topLeft + (2 @ 1) to: r topLeft + (3 @ 1) width: self width color: self colormoveToEvent: anEvent  self handleEvent: (MouseMoveEvent basicNew setType: #mouseMove startPoint: self position endPoint: anEvent position trail: (Array with: self position with: anEvent position) buttons: anEvent buttons hand: self stamp: anEvent timeStamp)createShortcutMorphFor: aMenuItem  ^FadingMorph new     addMorphBack: (self createLabelMorph: aMenuItem contents);     addMorphBack: (self createKeyTextMorph: aMenuItem keyText);     color: backgroundColor;     yourselfmouseUp: evt  super mouseUp: evt.  self selectedItem ifNil: [ ^self ].  self selectedItem selector ifNil: [ ^self ].  (self selectedItem containsPoint: evt cursorPoint) ifFalse: [ ^self ].  self selectedItem invokeWithEvent: evt.  self selectItem: nil event: evtupdateContentsWithPreviouslyExpanded: aNodeList  nodeList := nil.  self noteRemovalOfAll: self allNodeMorphs.  (self nodeList isNil or: [ self nodeList isEmpty ]) ifTrue: [ nodeList := nil.        ^self emptySelection ].  self addSubmorphsFromNodeList: self currentNodelist previouslyExpanded: aNodeList.  self listManager updateLastClickedMorphhandlesMouseOverDragging: evt  ^truetaskList  ^taskListselector: anObject  selector := anObjectprimaryHand  | outer |  outer := self outermostWorldMorph ifNil: [ ^nil ].  ^outer activeHand ifNil: [ outer firstHand ]close  SystemProgressMorph uniqueInstance close: self.  self removeDependent: SystemProgressMorph uniqueInstanceinitWithContents: aString font: aFont emphasis: emphasisCode  super initialize.  font := aFont.  emphasis := emphasisCode.  hasFocus := false.  self contents: aStringdoesBevels  ^truemouseEnterDragging: evt  super mouseEnterDragging: evt.  self over: truecreateMenuButton  | form msb |  form := self theme windowMenuForm.  msb := MultistateButtonMorph new extent: form extent.  msb activeEnabledNotOverUpFillStyle: (ImageFillStyle form: form).  form := self theme windowMenuPassiveForm.  msb extent: form extent.  msb activeDisabledNotOverUpFillStyle: (ImageFillStyle form: form).  msb passiveEnabledNotOverUpFillStyle: (ImageFillStyle form: form).  msb passiveDisabledNotOverUpFillStyle: (ImageFillStyle form: form).  form := self theme windowMenuForm.  msb extent: form extent.  msb     activeEnabledOverUpFillStyle: (ImageFillStyle form: form);     passiveEnabledOverUpFillStyle: (ImageFillStyle form: form).  form := self theme windowMenuPassiveForm.  msb     extent: form extent;     activeEnabledOverDownFillStyle: (ImageFillStyle form: form);     passiveEnabledOverDownFillStyle: (ImageFillStyle form: form);     addUpAction: [ self popUpMenu ];     setBalloonText: 'tab menu' translated;     extent: 16 @ 16.  ^msbdrawOn: aCanvas  | style |  self isOpaque ifTrue: [ aCanvas drawImage: image at: self innerBounds origin ] ifFalse: [ aCanvas translucentImage: image at: self innerBounds origin ].  (style := self borderStyle) ifNotNil: [ style frameRectangle: bounds on: aCanvas ]updateFromEvent: anEvent  | pNew pOld delta selfTop selfBottom selfLeft selfRight |  pNew := anEvent cursorPoint - lastMouse second.  pOld := lastMouse first - lastMouse second.  delta := splitsTopAndBottom ifTrue: [ 0 @ ((self normalizedY: pNew y) - pOld y) ] ifFalse: [ ((self normalizedX: pNew x) - pOld x) @ 0 ].  lastMouse at: 1 put: (splitsTopAndBottom ifTrue: [ pNew x @ (self normalizedY: pNew y) + lastMouse second ] ifFalse: [ (self normalizedX: pNew x) @ pNew y + lastMouse second ]).  leftOrTop do: [:each |  | firstRight firstBottom |        firstRight := each layoutFrame rightOffset ifNil: [ 0 ].        firstBottom := each layoutFrame bottomOffset ifNil: [ 0 ].        each layoutFrame rightOffset: firstRight + delta x.        each layoutFrame bottomOffset: firstBottom + delta y.        (each layoutFrame leftFraction = each layoutFrame rightFraction and: [ each layoutFrame leftFraction ~= 0 ]) ifTrue: [ each layoutFrame leftOffset: (each layoutFrame leftOffset ifNil: [ 0 ]) + delta x ].        (each layoutFrame topFraction = each layoutFrame bottomFraction and: [ each layoutFrame topFraction ~= 0 ]) ifTrue: [ each layoutFrame topOffset: (each layoutFrame topOffset ifNil: [ 0 ]) + delta y ] ].  rightOrBottom do: [:each |  | secondLeft secondTop |        secondLeft := each layoutFrame leftOffset ifNil: [ 0 ].        secondTop := each layoutFrame topOffset ifNil: [ 0 ].        each layoutFrame leftOffset: secondLeft + delta x.        each layoutFrame topOffset: secondTop + delta y.        (each layoutFrame leftFraction = each layoutFrame rightFraction and: [ each layoutFrame rightFraction ~= 1 ]) ifTrue: [ each layoutFrame rightOffset: (each layoutFrame rightOffset ifNil: [ 0 ]) + delta x ].        (each layoutFrame topFraction = each layoutFrame bottomFraction and: [ each layoutFrame bottomFraction ~= 1 ]) ifTrue: [ each layoutFrame bottomOffset: (each layoutFrame bottomOffset ifNil: [ 0 ]) + delta y ] ].  selfTop := self layoutFrame topOffset ifNil: [ 0 ].  selfBottom := self layoutFrame bottomOffset ifNil: [ 0 ].  selfLeft := self layoutFrame leftOffset ifNil: [ 0 ].  selfRight := self layoutFrame rightOffset ifNil: [ 0 ].  self layoutFrame topOffset: selfTop + delta y.  self layoutFrame bottomOffset: selfBottom + delta y.  self layoutFrame leftOffset: selfLeft + delta x.  self layoutFrame rightOffset: selfRight + delta x.  self owner layoutChangeddefaultImage  ^DefaultFormisRoot  ^falsemouseLeaveDragging: evt  self mouseLeave: evtdrawOn: aCanvas  submorphs isEmpty ifTrue: [ super drawOn: aCanvas ]initialize  super initialize.  acceptOnCR := false.  autoAccept := false.  acceptOnFocusChange := falselastClicked: aBoolean  menuImage  ^self class boxOfSize: (self buttonExtent x min: self buttonExtent y) color: self thumbColorcurrentCursor: aCursor  ActiveHand world currentCursor: aCursor.  ActiveHand world isCursorOwner ifTrue: [ aCursor activateInCursorOwner: ActiveHand world ]griddingString  ^(self griddingOn ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'use gridding' translatedghostString  ^ghostStringfillStyleForItems: fillStyleCollection  selectedItems with: fillStyleCollection do: [:m :c |  m fillStyle: c ]bounds  ^boundsreleaseParagraphReally  self releaseEditor.  paragraph ifNotNil: [ paragraph := nil ].  container ifNotNil: [ container releaseCachedState ]testTransformReturnASubArea  | lf rectangle refRectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  refRectangle := 0 @ 0 extent: 100 @ 200.  rectangle := lf transform: refRectangle.  self assert: rectangle width equals: 80.  self assert: rectangle height equals: 180sortingStrategy: anObject  sortingStrategy := anObjectpaneColorToUse  ^Display depth <= 2 ifTrue: [ Color white ] ifFalse: [ self paneColor ]initialize  super initialize.  self     scroller: self newScroller;     hScrollbar: self newHScrollbar;     vScrollbar: self newVScrollbar;     scrollTarget: self defaultScrollTarget.  self     addMorph: self scroller;     resizeScrollerdoActivate  closeUnchangedWindows  (self confirm: 'Do you really want to close all windowsexcept those with unaccepted edits?' translated) ifFalse: [ ^self ].  self closeAllUnchangedWindowsbeCheckbox  self buttonMorph beCheckboxsliderThickness  ^((self bounds isWide ifTrue: [ self height ] ifFalse: [ self width ]) // 2 max: 8) // 2 * 2 + 1newTitle: aString for: control  ^self theme newTitleIn: self label: aString for: controldisplayInLine: line on: aCanvas  | startIdx stopIdx leftX rightX |  startIdx := first stringIndex.  stopIdx := last stringIndex.  (stopIdx < line first or: [ startIdx > (line last + 1) ]) ifTrue: [ ^self ].  (stopIdx = line first and: [ last textLine ~= line ]) ifTrue: [ ^self ].  (startIdx = (line last + 1) and: [ last textLine ~= line ]) ifTrue: [ ^self ].  leftX := (startIdx < line first ifTrue: [ line ] ifFalse: [ first ]) left.  rightX := (stopIdx > (line last + 1) or: [ stopIdx = (line last + 1) and: [ last textLine ~= line ] ]) ifTrue: [ line right ] ifFalse: [ last left ].  aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom) color: colormouseLeaveDragging: evt  owner ifNil: [ ^self ].  evt hand mouseFocus == owner ifFalse: [ ^self ].  subMenu ifNil: [ owner selectItem: nil event: evt ] ifNotNil: [ self addAlarm: #deselectTimeOut: with: evt after: 500 ]showOverEditableTextCursor  | o |  owner ifNil: [ ^self ].  o := owner isWorldMorph ifTrue: [ self ] ifFalse: [ owner ].  (o boundsInWorld containsPoint: self currentHand position) ifTrue: [ self currentHand showTemporaryCursor: (self theme overTextCursorFor: self) ]drawBackgroundForPotentialDrop: row on: aCanvas  | selectionDrawBounds |  selectionDrawBounds := self drawBoundsForRow: row.  selectionDrawBounds := selectionDrawBounds intersect: self bounds ifNone: [ ^self ].  aCanvas fillRectangle: selectionDrawBounds color: self color muchLighter darkernewToolSpacer  ^self theme newToolSpacerIn: selfwantsRecolorHandle  ^image notNil and: [ image depth = 1 ]getListItem: index  getListElementSelector ifNotNil: [ ^self itemMorphFor: (model perform: getListElementSelector with: index) index: index ].  (list notNil and: [ list size >= index ]) ifTrue: [ ^list at: index ].  ^self wrapItem: (self getList at: index) index: indexmouseDown: evt  self deletenewAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpTextallNodeMorphs  ^client allNodeMorphsonAnnouncement: anAnnouncement do: aValuable  self announcer when: anAnnouncement do: aValuabletestReset  | dataSource |  dataSource := self dataSourceForTesting.  strategy property: #yourself.  self assert: dataSource elements equals: self elementsForTestDataSource.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy reset.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10)decrement  ^progressBar decrementshouldDropOnMouseUp  | former |  former := self formerPosition ifNil: [ ^false ].  ^(former distanceTo: self position) > 10topLayoutFrame  ^(0 @ 0 corner: 1 @ 0) asLayoutFrame     topLeftOffset: 22 @ -29;     bottomRightOffset: -22 @ (SystemWindow borderWidth - 29)drawOnAthensCanvas: anAthensCanvas  self drawOnCanvasWrapperFor: anAthensCanvasgetSelectedPathSelector: aSymbol  getSelectedPathSelector := aSymbolisAdheringToRight  ^falsefullDrawOn: aCanvas  super fullDrawOn: aCanvas.  self theme drawTabGroupFinishingFor: self on: aCanvasisProportionalLayout  ^trueprintOn: aStream  super printOn: aStream.  aStream nextPutAll: '('.  aStream     print: self identityHash;     nextPutAll: ')'contents  ^contentssaturation: anInteger  | c |  c := self selectedColor.  self selectedColor: ((Color h: c hue s: anInteger / 255 v: c brightness) alpha: c alpha)stepTime  ^100selected  ^falseenabled  ^enabledtextSelector: aSymbol  textSelector := aSymbolfont: aFont  self tabSelectorMorph font: aFontspecifyDashedLine  | executableSpec newSpec |  executableSpec := UIManager default request: 'Enter a dash specification as{ major dash length. minor dash length. minor dash color }The major dash will have the normal border color.A blank response will remove the dash specification.[Note: You may give 5 items as, eg, {10. 5. Color white. 0. 3}where the 4th ityem is zero, and the 5th is the number of pixelsby which the dashes will move in each step of animation]' translated initialAnswer: '{ 10. 5. Color red }'.  executableSpec isEmptyOrNil ifTrue: [ ^self           stopStepping;           dashedBorder: nil ].  newSpec := [ self class compiler evaluate: executableSpec ] ifError: [ ^self           stopStepping;           dashedBorder: nil ].  (newSpec first isNumber and: [ newSpec second isNumber and: [ newSpec third isColor ] ]) ifFalse: [ ^self           stopStepping;           dashedBorder: nil ].  newSpec size = 3 ifTrue: [ ^self           stopStepping;           dashedBorder: newSpec ].  (newSpec size = 5 and: [ newSpec fourth isNumber and: [ newSpec fifth isNumber ] ]) ifTrue: [ ^self           dashedBorder: newSpec;           startStepping ]initialize  super initialize.  progressBar := ProgressBarMorph new.  progressBar hResizing: #spaceFill.  self extent: 200 @ 20.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     cellPositioning: #leftCenter;     cellInset: 3;     listCentering: #center;     hResizing: #spaceFill;     vResizing: #shrinkWrap.  self addMorphBack: progressBar.  self addInterruptionButtondrawOn: aCanvas  self useSelectionBar ifTrue: [ self paragraph displaySelectionBarOn: aCanvas ].  self useExtraSelection ifTrue: [ self paragraph displayExtraSelectionOn: aCanvas ].  super drawOn: aCanvasnormalizedY: y  ^yhasKeymapCategoryNamed: aString  ^self kmDispatcher targets anySatisfy: [:e |  e category name = aString ]discoveredMenuPragmaKeyword  ^self class discoveredMenuPragmaKeywordreset  self state: (FTUnsortedSortingState context: self)dropItemSelector: aSelector  dropItemSelector := aSelectorsetNamePropertyTo: aName  self assureExtension externalName: aNameisWorldMorph  ^trueminimumExtent  | minExt |  textStyle ifNil: [ ^9 @ 16 ].  borderWidth ifNil: [ ^9 @ 16 ].  minExt := 9 @ (textStyle lineGrid + 2) + (borderWidth * 2).  ^((0 @ 0 extent: minExt) expandBy: margins) extenthighlightIndex: aNumber  self highlightIndexes: {aNumber}mouseWheel: event  event isUp ifTrue: [ ^scrollBar scrollUp: 3 ].  event isDown ifTrue: [ ^scrollBar scrollDown: 3 ].  event isLeft ifTrue: [ ^hScrollBar scrollLeft: 3 ].  event isRight ifTrue: [ ^hScrollBar scrollRight: 3 ]arguments: aCollection  arguments := aCollection asArray copymaybeDoDup: evt with: dupHandle  evt hand obtainHalo: self.  ^self doDup: evt with: dupHandlefrom: aNodeMorph to: anotherNodeMorph do: action  | idx1 idx2 |  idx1 := ((self getSelectionIndexOf: aNodeMorph) min: self allNodeMorphs size) max: 1.  idx2 := ((self getSelectionIndexOf: anotherNodeMorph) min: self allNodeMorphs size) max: 1.  (idx1 min: idx2) to: (idx1 max: idx2) do: [:idx |  action value: (self allNodeMorphs at: idx) ]allowsRowSelection  ^truesetValue: newValue  | scaled |  value := newValue.  self scaledValue: (scaled := self scaledValue).  self model ifNotNil: [ self setValueSelector ifNotNil: [:sel |  self model perform: sel with: scaled ] ]handlesMouseOver: anEvent  ^truehandleDropMorph: anEvent  | aMorph |  aMorph := anEvent contents.  (self wantsDroppedMorph: aMorph event: anEvent) ifFalse: [ ^self ].  anEvent wasHandled: true.  self acceptDroppingMorph: aMorph event: anEvent.  aMorph justDroppedInto: self event: anEventhScrollbarShowAlways  self hScrollbar showAlways.  self updateScrollbarscellInset  | props |  props := self layoutProperties.  ^props ifNil: [ 0 ] ifNotNil: [ props cellInset ]hasChildrenSelector  ^hasChildrenSelectorresetHandlerFields  handler := nil.  wasHandled := falseaddHelpHandle: haloSpec  target balloonText ifNotNil: [ (self addHandle: haloSpec on: #mouseDown send: #mouseDownOnHelpHandle: to: innerTarget) on: #mouseUp send: #deleteBalloon to: innerTarget ]mouseListeners: anArrayOrNil  mouseListeners := anArrayOrNilrightOffset  ^rightOffsetdefaultColor  ^Color transparentaboutToBeGrabbedBy: aHand  self formerOwner: owner.  self formerPosition: self position.  ^selfgridVisibleString  ^(self gridVisible ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'show grid when gridding' translateddrawKeyTextOn: aCanvas  self keyText ifNil: [ ^self ].  self itemShortcut drawOn: aCanvasaboutToBeGrabbedBy: aHand  slippage := 0 @ 0.  ^super aboutToBeGrabbedBy: aHandpointFromWorld: aPoint  ^self point: aPoint from: self worldmouseMove: evt  | editEvt |  super mouseMove: evt.  evt redButtonPressed ifFalse: [ ^self ].  editEvt := evt transformedBy: (self transformedFrom: editView) inverseTransformation.  (editEvt position y between: editView top and: editView bottom) ifFalse: [ self startStepping: #autoScrollView: at: Time millisecondClockValue arguments: (Array with: editEvt) stepTime: 100 ] ifTrue: [ self stopSteppingSelector: #autoScrollView: ]navigateWindowForward  self nextWindow ifNotNil: [:m |  self currentWindow ifNotNil: [:w |  w sendToBack ].        m isCollapsed ifTrue: [ m collapseOrExpand ].        m activate ]initialize  super initialize.  selectedIndex := 0.  self     tabs: OrderedCollection new;     wrapScrolling: false;     visibleTabRange: (1 to: 0);     controls: self newControls;     roundedCorners: #(1 4);     borderWidth: 0;     changeTableLayout;     listDirection: #leftToRight;     cellInset: (self theme tabSelectorCellInsetFor: self)rootItems  ^rootItems ifNil: [ rootItems := (1 to: 1000) collect: [:i |  PersonDataExample firstName: 'Person' , i asString secondName: 'Person' , i asString , ' second name' age: i married: false ] ]updateShowIcon  (self selected not and: [ self width < 100 ]) ifTrue: [ self hideCloseIcon ] ifFalse: [ self showCloseIcon ]mouseUp: evt  (self containsPoint: evt cursorPoint) ifTrue: [ self setSwitchState: oldColor = offColor.        self doButtonAction ] ifFalse: [ self setSwitchState: oldColor = onColor ]acceptDroppingObject: anotherItem  ^item acceptDroppingObject: anotherItemupdateFromEvent: anEvent  | delta |  delta := (anEvent cursorPoint - lastMouse first) x.  (delta > 0 and: [ delta > (rightColumn width - self width - 5) ]) ifTrue: [ delta := rightColumn width - self width - 5 ].  (delta < 0 and: [ delta negated > (leftColumn width - self width - 5) ]) ifTrue: [ delta := (leftColumn width - self width - 5) negated ].  leftColumn column width: (leftColumn column width ifNil: [ leftColumn width ]) + delta.  rightColumn column width: (rightColumn column width ifNil: [ rightColumn width ]) - delta.  container changedprepareForRotating  ^selfmorphicLayerNumber  ^8arrowForms  arrowForms ifNotNil: [ ^arrowForms ].  arrowForms := Array new.  self hasArrows ifFalse: [ ^arrowForms ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ arrowForms := arrowForms copyWith: (self computeArrowFormAt: vertices last from: self nextToLastPoint) ].  (arrows == #back or: [ arrows == #both ]) ifTrue: [ arrowForms := arrowForms copyWith: (self computeArrowFormAt: vertices first from: self nextToFirstPoint) ].  ^arrowFormsballoonColor  ^balloonColormouseOverBorderStyle  ^self theme controlButtonMouseOverBorderStyleFor: selffirstHand  ^worldState hands firstupdateButtonDown: evt  self wantsKeyboardFocusOnMouseDown ifTrue: [ self takeKeyboardFocus ].  self updateButton: evtwantsKeyboardFocusNavigation  ^falsecomputeAltInsetColors  | base light dark w colorArray param hw |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  colorArray := Array new: w * 2.  hw := 0.5 / w.  0 to: w - 1 do: [:i |  param := false ifTrue: [ 0.5 + (hw * i) ] ifFalse: [ 0.5 + (hw * (w - i)) ].        colorArray at: i + 1 put: (base mixed: param with: dark).        colorArray at: colorArray size - i put: (base mixed: param with: light) ].  ^colorArraydraggedMorph: aMorph  draggedMorph := aMorphhandlesMouseOverDragging: evt  ^truenewPluggableDialogWindow: title for: contentMorph  ^self theme newPluggableDialogWindowIn: self title: title for: contentMorphheaderButton  self header: (MorphTreeColumnButton new           layoutPolicy: RowLayout new;           listDirection: #leftToRight;           wrapCentering: #center;           cellInset: 5 @ 0;           layoutInset: 5 @ 0;           yourself)resetHandlerFields  wasHandled := falserootNodes  | computedRootNodes |  computedRootNodes := super rootNodes.  self defaultChunkSize ifNotNil: [ computedRootNodes size > self defaultChunkSize ifTrue: [ self chunkSize: self defaultChunkSize ] ] ifNil: [ self defaultPageSize ifNotNil: [ computedRootNodes size > self defaultPageSize ifTrue: [ self pageSize: self defaultPageSize ] ] ].  ^computedRootNodesextent: newExtent  bounds extent = newExtent ifTrue: [ ^self ].  super extent: newExtent.  self setScrollDeltaskeyUp: anEvent  initialize  super initialize.  self layoutInset: (self theme controlButtonLabelInsetFor: self)labelMorph  ^labelMorphinitialize  super initialize.  self form: self defaultImagestringColor  ^self colorshowsAlways  ^self showState == #alwaysnormalBorderStyle  ^self theme controlButtonNormalBorderStyleFor: selfstate  ^statereferencePosition  ^self valueOfProperty: #referencePosition ifAbsent: [ super referencePosition ]getMenu: shiftKeyState  ^shiftKeyState not ifTrue: [ editor yellowButtonMenu ] ifFalse: [ editor shiftedYellowButtonMenu ]imageToUse  ^self imageFromName: stategetListSelector: aSelector  self dataSource getListSelector: aSelectordrawWithoutSelectedOn: canvas  canvas line: self bottomLeft + (0 @ -1) to: self bottomRight + (0 @ -1) width: 1 color: self borderColorfillStyleToUse  ^self isActive ifTrue: [ self activeFillStyle ] ifFalse: [ self inactiveFillStyle ]basicBox  | aBox minSide anExtent w |  minSide := 4 * self handleSize.  anExtent := (self width + self handleSize + 8 max: minSide) @ (self height + self handleSize + 8 max: minSide).  aBox := Rectangle center: self center extent: anExtent.  w := self world ifNil: [ target outermostWorldMorph ].  ^w ifNil: [ aBox ] ifNotNil: [ aBox intersect: (w viewBox insetBy: 8 @ 8) ifNone: [ self error: 'should not happen' ] ]inspectInMorphic: evt  Smalltalk tools inspector inspect: selfselectNext  | index nextSelection |  index := tabs indexOf: self selectedTab.  nextSelection := tabs at: index + 1 ifAbsent: [ ^self ].  nextSelection selected: truedefaultColor  ^Color orangestartDrag: evt  self eventHandler ifNotNil: [ self eventHandler startDrag: evt fromMorph: self ]newButtonLabel: aString  ^self newButtonLabelFor: nil label: aString getEnabled: nilplayRestoreDownSound  self theme windowRestoreDownSound playoffImage: aForm  offImage := aForm.  self invalidRect: self boundsnewSliderFor: aModel getValue: getSel setValue: setSel getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: 0 max: 1 quantum: nil getEnabled: enabledSel help: helpTextcloseAllTabs  toolbar closeAllTabsblinkStart  ^self valueOfProperty: #blinkStart ifAbsent: [ Time millisecondClockValue ]addMorph: aMorph  self addMorphFront: aMorphisStayUpItem  ^selector == #toggleStayUp:displayBlock  ^displayBlockhUnadjustedScrollRange  | itemsToCheck item index |  maxWidth ifNotNil: [ ^maxWidth ].  listItems isEmpty ifTrue: [ ^0 ].  itemsToCheck := 30 min: listItems size.  maxWidth := 0.  index := 1.  [ index < itemsToCheck ] whileTrue: [ item := self getListItem: index.        maxWidth := maxWidth max: (item widthToDisplayInList: self).        index := index + 1 ].  itemsToCheck < listItems size ifTrue: [ maxWidth := maxWidth * 2 ].  ^maxWidthdrawIconOn: aCanvas  | iconForm |  self hasIcon ifFalse: [ ^self ].  iconForm := self iconForm.  aCanvas translucentImage: iconForm at: bounds left @ (self top + ((self height - iconForm height) // 2))menuColumn: column row: rowIndex  menuBlock ifNil: [ ^nil ].  rowIndex = 0 ifTrue: [ ^nil ].  ^menuBlock value: (self elementAt: rowIndex)keyboardFocusOnMouseDown  ^self class keyboardFocusOnMouseDownchangeShadowColor  (UIManager default chooseColor: self shadowColor) ifNotNil: [:nc |  self shadowColor: nc ]containsPoint: aPoint  | radius other delta xOverY |  (bounds containsPoint: aPoint) ifFalse: [ ^false ].  (bounds width = 1 or: [ bounds height = 1 ]) ifTrue: [ ^true ].  radius := bounds height asFloat / 2.  other := bounds width asFloat / 2.  delta := aPoint - bounds topLeft - (other @ radius).  xOverY := bounds width asFloat / bounds height asFloat.  ^(delta x asFloat / xOverY) squared + delta y squared <= radius squaredacceptDroppingMorph: aMorph event: event  self dataSource dropElements: aMorph passenger index: ((self container rowIndexContainingPoint: event position) ifNil: [ 0 ]).  self basicHighlightIndexes: #().  self refreshrealElementAt: anIndex  ^self elementAt: anIndexfullscreenChanged: fullscreenAnnouncement  self currentWorld worldState worldRenderer fullscreenMode: fullscreenAnnouncement fullscreenhandleWindowEvent: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (self wantsWindowEvent: anEvent) ifFalse: [ ^self ].  anEvent wasHandled: true.  self windowEvent: anEventselected: aBoolean  oldPosition  ^oldPositiondescending  ^descending == truelayoutChanged  (self owner isNil or: [ self owner isWorldMorph not ]) ifTrue: [ ^super layoutChanged ].  fullBounds := nil.  self layoutPolicy ifNotNil: [:layout |  layout flushLayoutCache ]handlesMouseOver: evt  ^trueitem: index  | newItem itemWidth |  (index between: 1 and: listItems size) ifFalse: [ ^self getListItem: index ].  (listItems at: index) ifNil: [ newItem := self getListItem: index.        maxWidth ifNotNil: [ itemWidth := newItem widthToDisplayInList: self.              itemWidth > maxWidth ifTrue: [ maxWidth := itemWidth.                    self adjustWidth ] ].        listItems at: index put: newItem ].  ^listItems at: indexspaceFillWeight  ^self valueOfProperty: #spaceFillWeight ifAbsent: [ 1 ]leftOffset: anInteger  leftOffset := anIntegercellInset: aNumber  self assureTableProperties cellInset: aNumber.  self layoutChangedwrapDirectionString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self wrapDirectionwithSearch: aBoolean  withSearch := aBoolean.  self buildPanelrootItems  ^OrderedCollection with: self rootClassnewCheckboxFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel getLabel: labelSel help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel getLabel: labelSel help: helpTextinitialize  super initialize.  lock := Semaphore forMutualExclusion.  lastRefresh := 0.  self     setDefaultParameters;     setProperty: #morphicLayerNumber toValue: self morphicLayerNumber;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #topCenter;     cellInset: 5;     listCentering: #center;     hResizing: #rigid;     vResizing: #shrinkWrap;     layoutInset: 10 @ 6;     minWidth: 150newRow  ^self theme newRowIn: self for: #()sentTo: anObject  type == #mouseWheel ifTrue: [ ^anObject handleMouseWheel: self ].  ^super sentTo: anObjectinitialize  super initialize.  self     borderWidth: 0;     changeTableLayout;     cellInset: 4;     listDirection: #leftToRight;     cellPositioning: #topLeft;     svMorph: self newSVColorMorph;     hMorph: self newHColorMorph;     addMorphBack: self svMorph;     addMorphBack: self hMorph;     extent: 192 @ 152;     hue: 0.5itemWithWording: wording  (self contents asString sameAs: wording) ifTrue: [ ^self ].  subMenu ifNotNil: [ ^subMenu itemWithWording: wording ].  ^nilnewCheckboxFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpTextraisedColor  ^self paneColor raisedColormaybeAddCollapseItemTo: aMenu  | anOwner |  (anOwner := self topRendererOrSelf owner) ifNotNil: [ anOwner isWorldMorph ifTrue: [ aMenu add: 'collapse' target: self selector: #collapse ] ]font: aFontOrNil  self listMorph font: aFontOrNilfullscreen  self bounds: self fullscreenBoundsdefaultBackgroundColor  ^Color graydoOneCycleNow  worldState doOneCycleNowFor: selfreverseTableCells  ^falseposition: newPos  | oldPos |  isCollapsed ifTrue: [ oldPos := collapsedFrame origin ] ifFalse: [ oldPos := fullFrame origin ].  super position: newPos.  isCollapsed ifTrue: [ collapsedFrame := self bounds ] ifFalse: [ fullFrame := self bounds ].  oldPos ~= newPos ifTrue: [ self announce: (WindowMoved new                 oldPosition: oldPos;                 newPosition: newPos;                 window: self) ]unrotatedWidth: aWidth  self borderWidth: aWidthindexFromPosition: aTuple  ^self subclassResponsibilitydrawText: aStringOrText on: aCanvas in: aRectangle color: stringColor  (self enabled not and: [ self theme disabledItemStyle = #inset ]) ifTrue: [ aCanvas           drawString: aStringOrText in: aRectangle font: self fontToUse color: stringColor muchLighter lighter;           drawString: aStringOrText in: (aRectangle translateBy: -1) font: self fontToUse color: stringColor ] ifFalse: [ aCanvas drawString: aStringOrText in: aRectangle font: self fontToUse color: stringColor ]resizeAllSubviews  self resizeVerticalScrollBar.  horizontalScrollBar ifNotNil: [ self resizeHorizontalScrollBar ].  self recalculateVerticalScrollBar.  self resizeContainer.  self container setNeedsRefreshExposedRows.  self container updateExposedRows.  self verticalScrollBar value: (self rowIndexToVerticalScrollBarValue: showIndex).  function isExplicit ifTrue: [ function resizeWidget ]buildRowMorphsFromIndex: startIndex to: stopIndex  | rowMorphsWidths subs |  subs := self allNodeMorphs.  rowMorphsWidths := self rowMorphsWidths.  startIndex to: stopIndex do: [:p |  (subs at: p)           buildRowMorph;           updateColumnMorphsWidthWith: rowMorphsWidths ].  self setScrollDeltas.  self adjustSubmorphPositionsFrom: startIndex to: stopIndex.  self setScrollDeltas.  startIndex to: stopIndex do: [:pos |  (subs at: pos) drawable: true ]handleKeyDown: anEvent  ^self dispatchDefault: anEvent with: morphseparatorBlockOrSelector  ^separatorBlockOrSelectorremovedMorph: aMorph  resetTimer  timeOfMouseDown := Time millisecondClockValue.  timeOfLastScroll := timeOfMouseDown - 1000 max: 0.  nextPageDirection := nil.  currentScrollDelay := nilpassiveEnabledOverUpFillStyle: aFillStyle  self stateMap atPath: #(passive enabled over up) put: aFillStyle.  self changedmanageCursor  (paragraph isNil or: [ paragraph focused not ]) ifTrue: [ ^self           resetBlinkCursor;           stopBlinking ].  TextEditor blinkingCursor ifTrue: [ self startBlinking ] ifFalse: [ self ensureCursor ]newLabelGroup: labelsAndControls font: aFont labelColor: aColor  ^self theme newLabelGroupIn: self for: labelsAndControls font: aFont labelColor: aColorperformAction: event  enabled ifFalse: [ ^self ].  askBeforeChanging ifTrue: [ model okToChange ifFalse: [ ^self ] ].  self pressed: self isPressed not.  self actionBlock ifNotNil: [ ^self actionBlock cull: self isPressed cull: event ].  actionSelector ifNil: [ ^self ].  arguments := argumentsProvider ifNotNil: [ argumentsProvider perform: argumentsSelector ] ifNil: [ #() ].  model perform: actionSelector withArguments: (arguments copyWithFirst: self isPressed)tabEmptyContents: aTab  contentsWrapper removeAllMorphsbeRowNotHomogeneous  | oldContainer |  oldContainer := container.  container := FTTableContainerRowNotHomogeneousMorph new.  self replaceSubmorph: oldContainer by: container.  self resizeAllSubviewswantsGrips  ^self isResizeableprepareForRotating  ^self addFlexShellsearchText: aString  | index result |  aString isEmptyOrNil ifTrue: [ ^#() ].  index := 0.  result := OrderedCollection new.  self items do: [:elements |  elements do: [:each |  index := index + 1.              ((self toString: each) beginsWith: aString) ifTrue: [ result add: index ] ] ].  ^result asArraywithoutListWrapper  ^item withoutListWrapperacceptContents  self updateFromParagraph.  editView accepttopVisibleRowForCanvas: aCanvas  ^self rowAtLocation: aCanvas clipRect topLeftsmoothing: cellSize  smoothing := cellSize.  self changedrecentlyChanged  self subclassResponsibilityadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self borderStyle baseColor: paneColor twiceDarkerhandleSize  ^20max  ^maxstopSteppingSelector: aSelector  | w |  w := self world.  w ifNotNil: [ w stopStepping: self selector: aSelector ]handlesMouseDown: evt  ^trueborders  ^bordersmenu: aBlock  self dataSource menu: aBlockhelpText: aString  self setBalloonText: aStringnewMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newMorphDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpTextbasicActivate  | outerMorph |  outerMorph := self topRendererOrSelf.  outerMorph owner ifNil: [ ^self ].  self isTopWindow ifTrue: [ ^self ].  self beTopWindow.  outerMorph owner firstSubmorph == outerMorph ifFalse: [ outerMorph owner addMorphFront: outerMorph ].  self submorphsDo: [:m |  m unlock ].  labelArea ifNotNil: [ labelArea submorphsDo: [:m |  m unlock ].        self setStripeColorsFrom: self paneColorToUse ].  self isCollapsed ifFalse: [ model modelWakeUpIn: self.        self positionSubmorphs.        labelArea ifNil: [ self adjustBorderUponActivationWhenLabeless ] ].  self     privateFullBounds: nil;     changedbeUnresizeable  isResizeable := false.  self isResizeable ifFalse: [ self removeGrips ]okayToResizeEasily  ^truesimulateKeyStrokes: aString  aString do: [:c |  self simulateKeyStroke: c ]popUpInWorld: aWorld  ^self popUpAt: aWorld primaryHand position forHand: aWorld primaryHand in: aWorldsetActionsFrom: aBlock  self actions: aBlock valuerootNodeClassFromItem: anItem  ^ClassTreeNodeExamplenewBalloonHelp: aTextStringOrMorph for: aMorph corner: cornerSymbol  ^self theme newBalloonHelpIn: self contents: aTextStringOrMorph for: aMorph corner: cornerSymbolborderColor: aColorOrSymbolOrNil  | style newStyle |  style := self borderStyle.  style baseColor = aColorOrSymbolOrNil ifTrue: [ ^self ].  aColorOrSymbolOrNil isColor ifTrue: [ style style = #none ifTrue: [ self borderStyle: (SimpleBorder width: 0 color: aColorOrSymbolOrNil) ] ifFalse: [ style baseColor: aColorOrSymbolOrNil.              self changed ].        ^self ].  self borderStyle: (({nil .         #none} includes: aColorOrSymbolOrNil) ifTrue: [ BorderStyle default ] ifFalse: [ self doesBevels ifFalse: [ ^self ].              newStyle := (BorderStyle perform: aColorOrSymbolOrNil)                 color: style color;                 width: style width;                 yourself.              (self canDrawBorder: newStyle) ifTrue: [ newStyle ] ifFalse: [ style ] ])defaultImage  ^DefaultImage ifNil: [ DefaultImage := DefaultForm asFormOfDepth: 32 ]client: anObject  client := anObjectreposition  | xPos yPos margin |  margin := 20.  xPos := Display boundingBox width - self fullBounds width - (2 * margin).  xPos := xPos * self class horizontalPosition + margin.  yPos := Display boundingBox height - self fullBounds height - (2 * margin).  yPos := yPos * self class verticalPosition + margin.  self align: self fullBounds topLeft with: Display boundingBox topLeft + (xPos @ yPos).  self refreshlarge  ^55rowHeight: rowIndex default: aNumber  ^aNumberrectangle: lineRectangle  left := lineRectangle left.  right := lineRectangle right.  top := lineRectangle top.  bottom := lineRectangle bottomisEnabled  | state |  self enablementSelector ifNil: [ ^super isEnabled ].  state := self enablementSelector isSymbol ifTrue: [ self target perform: self enablementSelector ] ifFalse: [ self enablementSelector value ].  self isEnabled: state.  ^stateglmAnimateValue: aNumber duration: anInteger  anInteger <= 0 ifTrue: [ self setValue: aNumber ] ifFalse: [ | startTime start end |        startTime := Time millisecondClockValue.        start := value.        [ | delta |        [ (delta := Time millisecondClockValue - startTime) < anInteger ] whileTrue: [ self setValue: (aNumber - start) * (delta / anInteger) + start.              Processor yield ].        self setValue: aNumber ] fork ]handleColorAt: vertIndex  ^Color yellowexportAsPNG  self exportAs: 'png' using: PNGReadWritergrabMorph: aMorph  | grabbed |  aMorph = self currentWorld ifTrue: [ ^self ].  self releaseMouseFocus.  grabbed := aMorph aboutToBeGrabbedBy: self.  grabbed ifNil: [ ^self ].  grabbed := grabbed topRendererOrSelf.  ^self grabMorph: grabbed from: grabbed ownerdrawSubmenuMarkerOn: aCanvas  drawOn: aCanvas  listItems isEmpty ifTrue: [ ^self ].  aCanvas fillRectangle: aCanvas clipRect color: (self theme listNormalFillStyleFor: self).  (self topVisibleRowForCanvas: aCanvas) to: (self bottomVisibleRowForCanvas: aCanvas) do: [:row |  (listSource itemSelectedAmongMultiple: row) ifTrue: [ self drawBackgroundForSelectedRow: row on: aCanvas ] ifFalse: [ listSource searchedElement = row ifTrue: [ self drawBackgroundForSearchedRow: row on: aCanvas ] ifFalse: [ (listSource backgroundColorFor: row) ifNotNil: [:col |  self drawBackgroundForRow: row on: aCanvas color: col ] ] ].        selectedRow = row ifTrue: [ self drawSelectionOn: aCanvas ].        (listSource separatorAfterARow: row) ifTrue: [ self drawSeparatorAfter: row on: aCanvas ].        self display: (self item: row) atRow: row on: aCanvas ].  listSource potentialDropRow > 0 ifTrue: [ self highlightPotentialDropRow: listSource potentialDropRow on: aCanvas ]calculateStartIndexWhenShowing: visibleRows  | currentIndex startIndex oldIndex |  currentIndex := self table showIndex.  currentIndex + visibleRows - 1 > self table numberOfRows ifTrue: [ currentIndex := self table numberOfRows - visibleRows + 2 ].  startIndex := currentIndex max: 1.  oldIndex := self table showIndex.  self table basicMoveShowIndexTo: startIndex.  self table announceScrollChangedFrom: oldIndex to: self table showIndex.  ^startIndexinitialize  super initialize.  self borderStyle: (self theme taskbarItemNormalBorderStyleFor: self)disableDragNDrop  self enableDragNDrop: falsetextEntry: aStringOrText  ^self textEntry: aStringOrText title: 'Entry' translatedshowSelectionFeedback: aBoolean  showSelectionFeedback := aBooleancurrentPageToString  ^self currentPage asStringvScrollbarShowAlways  self vScrollbar showAlways.  self updateScrollbarsnewTextMorph  ^StringMorph contents: ''closeAllUnchangedWindows  (self windowsSatisfying: [:w |  w model canDiscardEdits ]) do: [:w |  w delete ]numSelectionsInView  ^client numSelectionsInViewnewTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpTextdefaultColor  ^self theme menubarFillStyleFor: selfstateMap: anObject  stateMap := anObjectmargins: newMargins  margins := newMargins asMargin.  self composeToBoundshandleMouseLeave: anEvent  ^self dispatchDefault: anEvent with: morphbottomVisibleRowForCanvas: aCanvas  ^self rowAtLocation: aCanvas clipRect bottomLeftaddWorldHaloMenuItemsTo: aMenu hand: aHandMorph  self addFillStyleMenuItems: aMenu hand: aHandMorph.  self addLayoutMenuItems: aMenu hand: aHandMorph.  aMenu addLine.  self addWorldToggleItemsToHaloMenu: aMenu.  aMenu addLine.  self addExportMenuItems: aMenu hand: aHandMorph.  self addMiscExtrasTo: aMenu.  self addDebuggingItemsTo: aMenu hand: aHandMorph.  aMenu addLine.  aMenu defaultTarget: aHandMorphhasClipSubmorphsString  ^self clipSubmorphs -> 'provide clipping' translatedscrollValue: aPoint  self     hScrollValue: aPoint x;     vScrollValue: aPoint yhideVScrollBarIndefinitely: bool  self setProperty: #noVScrollBarPlease toValue: bool.  self vHideOrShowScrollBarfillStyle: aColor  undoProperties ifNil: [ undoProperties := selectedItems collect: [:m |  m fillStyle ] ].  selectedItems do: [:m |  m fillStyle: aColor ]question: aStringOrText  ^self question: aStringOrText title: 'Question' translatedvalue: newValue  value := newValue min: 1.0 max: 0.0.  self computeSliderkeyStroke: evt  (self localHandleKeystroke: evt) ifTrue: [ ^self ].  (self maxLength isNil or: [ self text size < self maxLength or: [ self editor selectionInterval size > 0 or: [ self isEditEvent: evt ] ] ]) ifTrue: [ self doAutoAccept: evt ].  super keyStroke: evtpreferredCornerStyle  ^self theme dialogWindowPreferredCornerStyleFor: selfmouseDown: evt  | selectors row |  row := self rowAtLocation: evt position.  evt yellowButtonPressed ifTrue: [ self isMultipleSelection ifTrue: [ evt commandKeyPressed ifFalse: [ (self yellowButtonActivity: evt shiftPressed) ifTrue: [ ^super mouseDown: evt ] ] ] ifFalse: [ (self yellowButtonActivity: evt shiftPressed) ifTrue: [ ^super mouseDown: evt ] ] ].  self enabled ifFalse: [ ^super mouseDown: evt ].  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ].  row := self rowAtLocation: evt position.  row = 0 ifTrue: [ ^super mouseDown: evt ].  self mouseDownRow: row.  self isMultipleSelection ifTrue: [ self mouseDownOnMultiple: evt forRow: row ].  selectors := Array with: #click: with: (doubleClickSelector ifNotNil: [ #doubleClick: ]) with: nil with: (self dragEnabled ifTrue: [ #startDrag: ] ifFalse: [ nil ]).  evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: 10.  super mouseDown: evtbackgroundColor  ^Smalltalk ui theme darkBaseColorchangeOpacity  self isOpaque: self isOpaque notmouseDownHighlightColor  | c colored |  c := self lineColor.  c isTransparent ifFalse: [ ^c ].  colored := self color isTransparent ifTrue: [ self firstOwnerSuchThat: [:o |  o isWorldOrHandMorph not and: [ o color isTransparent not ] ] ] ifFalse: [ self ].  colored ifNil: [ ^Color black ].  ^colored color luminance > 0.5 ifTrue: [ Color black ] ifFalse: [ Color white ]selected  ^selected ifNil: [ selected := 1 ]originMenuColumn: column row: rowIndex  | method menu |  method := (self elementAt: rowIndex) method.  menu := UIManager default newMenuIn: self table for: self.  menu add: 'Browse ' , method methodClass name target: method methodClass selector: #browse.  ^menuhandlesMouseDown: evt  ^truewidthForRounding  ^self widthmouseUp: evt  scroller hasSubmorphs ifTrue: [ scroller submorphs last mouseUp: (evt transformedBy: (scroller transformFrom: self)) ]modalSelection  ^self valueOfProperty: #modalSelection ifAbsent: [ nil ]selectedColor: aColor  self aMorph value: aColor alpha.  self hsvMorph selectedColor: aColor beOpaquecurrentPage: anIndex  anIndex = self currentPage ifTrue: [ ^self ].  anIndex = 1 ifTrue: [ self setPageInterval: (1 to: (pageSize min: self nodeList size)) ] ifFalse: [ | lastIdx |        lastIdx := anIndex * pageSize.        lastIdx <= self nodeList size ifTrue: [ self setPageInterval: ((lastIdx - pageSize + 1 max: 1) to: lastIdx) ] ifFalse: [ self setPageInterval: ((self lastPage - 1) * pageSize + 1 to: self nodeList size) ] ]allMorphs  | all |  all := (Array new: submorphs size) writeStream.  self allMorphsDo: [:m |  all nextPut: m ].  ^all contentstextMorph: anObject  textMorph := anObjecthandlesMouseDown: evt  ^trueselectedColor  ^self theme selectionColoryellowButtonActivity: shiftState  ^falseflash  (self hasProperty: #activeModalFlash) ifTrue: [ ^self ].  self setProperty: #activeModalFlash toValue: true.  [ | oldColor newColor duration |  oldColor := self fillStyle.  newColor := self color alphaMixed: 0.5 with: Color white.  duration := 0.  2 timesRepeat: [ duration milliSeconds asDuration wait.        duration := 200.        self color: newColor.        duration milliSeconds asDuration wait.        self color = newColor ifFalse: [ oldColor := self fillStyle ].        self fillStyle: oldColor ].  self removeProperty: #activeModalFlash ] forkmustTakeIntoAccountCheckSpace  ^container listManager isCheckListstep  (self hasProperty: #doesButtonAction) ifTrue: [ self doButtonAction.        self setProperty: #didButtonAction toValue: true ]isSelectedMatchingTheState: aBoolean  ^aBooleanminimizeAfterGeneratingThumbnail  self isMinimized ifTrue: [ ^self ].  isCollapsed := true.  paneMorphs do: [:m |  m           delete;           releaseCachedState ].  self setBoundsWithFlex: (-10 @ -10 extent: 2 @ 2).  self hide.  self layoutChangedresistsRemoval: aBoolean  aBoolean ifTrue: [ self setProperty: #resistsRemoval toValue: true ] ifFalse: [ self removeProperty: #resistsRemoval ]themeChanged  self fillStyle: (self theme morphTreeColumnFillStyleFor: self).  self borderStyle: (self theme morphTreeColumnBorderStyleFor: self).  super themeChangedtrimSize  ^trimSize ifNil: [ trimSize := 0 ]rotationDegrees  ^self angle radiansToDegrees negateddisplayAt: aPoint during: aBlock  self currentWorld addMorph: self centeredNear: aPoint.  self world displayWorld.  aBlock value.  self deletenewImageMorph  ^AlphaImageMorph new     borderStyle: (BorderStyle inset width: 1);     color: Color white;     alpha: 1.0for: aTextMorph minWidth: wid  textMorph := aTextMorph.  minWidth := wid.  fillsOwner := true.  avoidsOcclusions := falseupdateIcon  target ifNotNil: [ self icon: (target perform: iconSelector) ]selectFrom: a to: b  self editor selectFrom: a to: bchooseDirectory: title path: path  ^self theme chooseDirectoryIn: self title: title path: pathrowIndexFrom: anIndex  ^self subclassResponsibilityanimateMaximize  | expandedRect restoredRect rects steps |  expandedRect := self fullscreenBounds.  restoredRect := self bounds.  steps := self theme numberOfStepsForAnimations.  rects := (1 / steps to: 1 by: 1 / steps) collect: [:x |  restoredRect interpolateTo: expandedRect at: ((20 raisedTo: x) - 1) / 19 ].  self fastAnimateRectangles: rectsiconSelector: anObject  iconSelector := anObject.  self updateIcontextColor  ^textColorsetAsColumn  self     listDirection: #topToBottom;     hResizing: #spaceFill;     extent: 1 @ 1;     vResizing: #spaceFillfillsOwner: aBoolean  fillsOwner := aBoolean.  self updateLayoutPropertiesexpandAllTo: aLevel  self roots do: [:m |  self expand: m to: aLevel ].  self innerWidgetChangednextMorphInWindow  ^self hasSubmorphs ifTrue: [ self submorphs first ]processEvent: anEvent using: defaultDispatcher  (self rejectsEvent: anEvent) ifTrue: [ ^#rejected ].  ^defaultDispatcher dispatchEvent: anEvent with: selfcomputeNextToEndPoints  | pointAfterFirst pointBeforeLast |  pointAfterFirst := nil.  self lineSegmentsDo: [:p1 :p2 |  pointAfterFirst ifNil: [ pointAfterFirst := p2 asIntegerPoint ].        pointBeforeLast := p1 asIntegerPoint ].  curveState at: 2 put: pointAfterFirst.  curveState at: 3 put: pointBeforeLastreferencePositionInWorld: aPoint  | localPosition |  localPosition := owner ifNil: [ aPoint ] ifNotNil: [ (owner transformFrom: self world) globalPointToLocal: aPoint ].  self referencePosition: localPositionframeRectangle: aRectangle on: aCanvas  (aRectangle width < self width or: [ aRectangle height < self width ]) ifTrue: [ ^self ].  aCanvas frameRectangle: aRectangle width: self width colors: self dashColors dashes: self dashLengthshandlesMouseOver: evt  ^self enabledselectionStrategy  ^selectionStrategykeyStroke: anEvent from: aTreeView  autoMultiSelection: aBoolean  autoMultiSelection := aBooleanselectedRowIndex  self deprecated: 'Use #selectedIndex instead' transformWith: '`@receiver selectedRowIndex' -> '`@receiver selectedIndex'.  ^self selectedIndexfont  ^self tabSelectorMorph fontbuildVerticesFrom: borderVertices  ^borderVerticesmainDockingBars  ^self dockingBars select: [:each |  each hasProperty: #mainDockingBarTimeStamp ]delete  accepted ifFalse: [ self dropNotifyRecipient ifNotNil: [ self dropNotifyRecipient dropRejectedMorph: self ] ].  self changed: #deleted.  self breakDependents.  super deleteicon  ^icontoggleEnabled  self enabled: self enabled notgetListSize  ^listSource ifNil: [ 0 ] ifNotNil: [:source |  source getListSize ]expandToDepth: aNumber  depth = aNumber ifTrue: [ ^self ].  self expandItem.  children do: [:each |  each expandToDepth: aNumber ]cornerRadius: anObject  cornerRadius := anObjectstartRot: evt with: rotHandle  self obtainHaloForEvent: evt andRemoveAllHandlesBut: rotHandle.  target prepareForRotating.  growingOrRotating := true.  angleOffset := evt cursorPoint - (target pointInWorld: target referencePosition).  angleOffset := Point r: angleOffset r degrees: angleOffset degrees - target rotationDegreespopUpAt: aPoint forHand: hand in: aWorld  ^self popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: self menuKeyboardControlsimplySetVisible: aBoolean  self visible: aBooleanselected: aBoolean  selected = aBoolean ifTrue: [ ^self ].  container ifNil: [ ^self ].  aBoolean ifTrue: [ container selectedMorphList add: self ] ifFalse: [ selected ifNotNil: [ container selectedMorphList remove: self ] ].  selected := aBoolean.  self complexContents selected: aBooleanaddSplitterOn: tabs delta: delta  | leftProcess rightProcess |  tabs overlappingPairsWithIndexDo: [:left :right :index |  leftProcess := left retrieveMorph: [:leftContents |  leftContents ifNil: [ TabWithNoContents signalTab: left ].              rightProcess := right retrieveMorph: [:rightContents |  | splitter |                    rightContents ifNil: [ TabWithNoContents signalTab: right ].                    splitter := ProportionalSplitterMorph new                       addLeftOrTop: leftContents;                       addRightOrBottom: rightContents;                       yourself.                    contentsWrapper addMorph: splitter fullFrame: (LayoutFrame identity                             leftFraction: index * delta;                             rightFraction: index * delta;                             leftOffset: -2;                             rightOffset: 2) ] ] ].  leftProcess ifNotNil: [ processes add: leftProcess ].  rightProcess ifNotNil: [ processes add: rightProcess ]handleAsMouseOver: anEvent  anEvent hand handleEvent: anEvent asMouseOveronColor  ^onColortestIntoWorldCollapseOutOfWorld  | m1 m2 collapsed |  m1 := TestInWorldMorph new.  m2 := TestInWorldMorph new.  self assert: m1 intoWorldCount equals: 0.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 0.  self assert: m2 outOfWorldCount equals: 0.  morph addMorphFront: m1.  m1 addMorphFront: m2.  self assert: m1 intoWorldCount equals: 0.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 0.  self assert: m2 outOfWorldCount equals: 0.  morph openInWorld.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 0.  collapsed := CollapsedMorph new beReplacementFor: morph.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 1.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 1.  collapsed collapseOrExpand.  self assert: m1 intoWorldCount equals: 2.  self assert: m1 outOfWorldCount equals: 1.  self assert: m2 intoWorldCount equals: 2.  self assert: m2 outOfWorldCount equals: 1.  morph delete.  self assert: m1 intoWorldCount equals: 2.  self assert: m1 outOfWorldCount equals: 2.  self assert: m2 intoWorldCount equals: 2.  self assert: m2 outOfWorldCount equals: 2updateFillStyle  | b fs |  fs := self fillStyle.  fs isOrientedFill ifTrue: [ b := self innerBounds.        fs origin: b topLeft.        fs direction: (b isWide ifTrue: [ b width @ 0 ] ifFalse: [ 0 @ b height ]) ]isCheckList: aBoolean  isCheckList := aBooleandrawClippedBorderOn: aCanvas usingEnds: anArray  aCanvas clipBy: self bounds during: [:cc |  self drawBorderOn: cc usingEnds: anArray ]handlesMouseOver: anEvent  ^trueisLineMorph  ^falsecreateCloseBox  ^self theme createCloseBoxFor: selfenableSearch  function := FTSearchFunction table: selfinitialize  super initialize.  nextPageAllowed := trueupdateLastClickedMorph  lastClickedMorph ifNil: [ lastClickedMorph := self selectedMorphList ifEmpty: [  ] ifNotEmpty: [ self selectedMorphList last ] ] ifNotNil: [ self allNodeMorphs do: [:each |  each complexContents withoutListWrapper = lastClickedMorph complexContents withoutListWrapper ifTrue: [ lastClickedMorph := each ] ] ]drawOnAthensCanvas: aCanvas  | cached style |  cached := aCanvas cacheAt: image ifAbsentPut: [ image asAthensPaintOn: aCanvas ].  aCanvas setPaint: cached.  aCanvas paintTransform restoreAfter: [ aCanvas paintTransform translateBy: self innerBounds origin.        aCanvas drawShape: self innerBounds ].  (style := self borderStyle) ifNotNil: [ aCanvas setStrokePaint: style.        aCanvas drawShape: bounds ]rightOrBottomVertices: r  ^self orientation == #vertical ifTrue: [ {(r topRight - (0 @ 1)) .         ((r right - (r height // 2 + (r height \\ 2))) @ (r center y - ((r height + 1) \\ 2))) .         ((r right - (r height // 2 + (r height \\ 2))) @ r center y) .         r bottomRight} ] ifFalse: [ {(r center x @ (r bottom - 1 - (r width // 2 + (r width \\ 2)))) .         (r center x @ (r bottom - 1 - (r width // 2 + (r width \\ 2)))) .         r bottomRight .         (r bottomLeft - (1 @ 0))} ]goBehind  max: anObject  max := anObject.  self setValue: self valuepagingArea  ^selfbasicKeyPressed: aChar  ^aChar == Character space ifTrue: [ self interactWithSelectedItem ] ifFalse: [ super basicKeyPressed: aChar ]keyStrokeSearch: event  ^function keyStroke: eventdefaultColor  ^self theme backgroundColorhideColumnHeaders  showColumnHeaders ifFalse: [ ^self ].  showColumnHeaders := false.  self refreshalphaSelected: aFloat  self triggerSelectedColorhSpaceFill: aBool  flags := aBool ifTrue: [ self flags bitOr: 1 ] ifFalse: [ self flags bitClear: 1 ]vIsScrolled  ^scroller offset y > 0refreshExtraSelection  | fullRefreshNeeded |  fullRefreshNeeded := self useSelectionBar.  self useFindReplaceSelection ifTrue: [ fullRefreshNeeded := true.        self findText isEmpty ifTrue: [ self paragraph findReplaceSelectionRegex: nil ] ifFalse: [ self paragraph findReplaceSelectionRegex: self findRegex ] ].  self useSecondarySelection ifTrue: [ fullRefreshNeeded := true.        (self paragraph secondarySelection isNil and: [ self selection isEmptyOrNil not ]) ifTrue: [ self paragraph secondarySelection: (self text asString allRangesOfSubstring: self selection asString) ] ].  fullRefreshNeeded ifTrue: [ self paragraph extraSelectionChanged.        self invalidRect: self bounds ]complexElementsForTestDataSource  ^#(3 80 29 10 20 28 70)isAnimated  borderDashSpec ifNil: [ ^false ].  ^borderDashSpec size = 5 and: [ borderDashSpec fifth > 0 ]removeLink: actionCode  self eventHandler ifNotNil: [ self eventHandler on: actionCode send: nil to: nil ]editorClass  ^TextEditoractive: aBoolean  active := aBoolean.  self changedstartDrag: event  self editView startDrag: eventselectableIndexContainingPoint: aPoint  ^self subclassResponsibilityselectionChangedUpdateStatus: ann  self setSelectionListSelector ifNil: [ ^self ].  ann oldSelectedIndexes do: [:each |  self model perform: self setSelectionListSelector with: each with: false ].  ann newSelectedIndexes do: [:each |  self model perform: self setSelectionListSelector with: each with: true ]basicExtent: aPoint  ^super extent: aPointnewNoButton  ^self newNoButtonFor: selftaskThumbnailOfSize: thumbExtent  | f t r |  r := self bounds scaledAndCenteredIn: (0 @ 0 extent: thumbExtent).  f := Form extent: r extent depth: Display depth.  t := MatrixTransform2x3 withScale: f extent / self extent.  f getCanvas transformBy: t clippingTo: f boundingBox during: [:c |  c translateBy: self topLeft negated during: [:ct |  self fullDrawOn: ct ] ] smoothing: 2.  ^ImageMorph new form: frelease  lineColorBlock := nil.  columnResizers := nil.  preferedPaneColor := nil.  expandedToggleImage := nil.  notExpandedToggleImage := nil.  columns ifNotNil: [ columns do: [:col |  col release ].        columns := nil ].  listManager ifNotNil: [ listManager release.        listManager := nil ].  self releaseActionMap.  super releasemodel  ^modelexpand: aMorph to: level  | allChildren |  aMorph toggleExpandedState.  allChildren := OrderedCollection new: 10.  aMorph recursiveAddTo: allChildren.  allChildren do: [:each |  ((each canExpand and: [ each isExpanded not ]) and: [ level > 0 ]) ifTrue: [ self expand: each to: level - 1 ] ]calendar  ^calendarselectionColor: aColor  | window |  aColor ifNil: [ self removeProperty: #selectionColor ] ifNotNil: [ self setProperty: #selectionColor toValue: aColor ].  window := self ownerThatIsA: SystemWindow.  self selectionColorToUse: ((self theme fadedBackgroundWindows not or: [ window isNil or: [ window isActive ] ]) ifTrue: [ aColor ] ifFalse: [ self theme unfocusedSelectionColor ])keyStroke: event  event keyCharacter = Character escape ifTrue: [ ^self delete ].  event anyModifierKeyPressed ifFalse: [ ^self done ].  event keyString = '<Opt-Shift-tab>' ifTrue: [ ^self selectPreviousTask ].  event keyString = '<Opt-tab>' ifTrue: [ ^self selectNextTask ]pressedFillStyle  ^self theme taskbarItemPressedFillStyleFor: selfformat: aText  ^aTextdisabledStyle: anObject  disabledStyle := anObject.  self changedborderStyle: aBorderStyle  self borderStyle = aBorderStyle ifTrue: [ ^self ].  super borderStyle: aBorderStyle.  self setScrollDeltasbackgroundColor  ^state backgroundColorpotentialDropMorph  ^potentialDropMorphisEnabledMatchingTheState: aBoolean  ^aBoolean notcornerStyle: aSymbol  (extension isNil or: [ self cornerStyle == aSymbol ]) ifTrue: [ ^self ].  extension cornerStyle: nil.  self changedforwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectionlabel: aString  label morph: aString asMorphdisplayTextOnAthensCanvas: anAthensCanvas in: aRectangle  | athensDisplayScanner offset leftInRun |  anAthensCanvas clipBy: aRectangle during: [ anAthensCanvas pathTransform restoreAfter: [ offset := aRectangle topLeft - positionWhenComposed.              athensDisplayScanner := AthensDisplayScanner for: self on: anAthensCanvas.              leftInRun := 0.              self forLinesIn: anAthensCanvas clipRect do: [:line |  line first <= line last ifTrue: [ leftInRun := athensDisplayScanner displayLine: line offset: offset leftInRun: leftInRun ] ] ] ]hasUnacceptedEdits: aBoolean  editView hasUnacceptedEdits: aBooleanheaderColumn: column  ^nildrawOnAthensCanvas: anAthensCanvas  self theme flatMenu ifFalse: [ anAthensCanvas setPaint: self baseColor twiceDarker.        anAthensCanvas drawShape: (bounds topLeft corner: bounds rightCenter).        anAthensCanvas setPaint: self baseColor twiceLighter.        anAthensCanvas drawShape: (bounds leftCenter corner: bounds bottomRight) ] ifTrue: [ anAthensCanvas setPaint: self baseColor.        anAthensCanvas drawShape: (bounds topLeft corner: bounds bottomRight) ]shouldDraw  ^truehandleMouseMove: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (self handlesMouseMove: anEvent) ifFalse: [ ^self ].  anEvent wasHandled: true.  self mouseMove: anEvent.  (self handlesMouseStillDown: anEvent) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue arguments: {anEvent copy resetHandlerFields} stepTime: self mouseStillDownStepRate ].  ^self eventHandler ifNotNil: [:handler |  handler mouseMove: anEvent fromMorph: self ]secondarySelectionColor  ^self theme secondarySelectionColordepthIndent: aNumber  aNumber timesRepeat: [ self addIndendtation: 16 ]isAdheringToLeft  ^falsecanBeDragged  ^truenewSeparator  ^self theme newSeparatorIn: selfactivatedModalChild  self modalChild ifNotNil: [:modalChild |  modalChild owner ifNotNil: [ modalChild activate.              modalChild modalChild ifNil: [ modalChild indicateModalChild ].              ^true ] ].  ^falselayoutPolicy: aLayoutPolicy  self layoutPolicy == aLayoutPolicy ifTrue: [ ^self ].  self assureExtension layoutPolicy: aLayoutPolicy.  self layoutChangedproperty  ^propertywantsYellowButtonMenu  ^truetoggleStayUp  ^stayUp := stayUp notverticalScrollbarFrontier  ^0.98hideOrShowScrollBars  | wasHShowing wasVShowing |  wasVShowing := self vIsScrollbarShowing.  wasHShowing := self hIsScrollbarShowing.  self     vHideOrShowScrollBar;     hHideOrShowScrollBar;     resizeScrollBars.  (wasVShowing and: [ self vIsScrollbarShowing not ]) ifTrue: [ scroller offset y = 0 ifFalse: [ scroller offset: scroller offset x @ 0 ] ].  (wasHShowing and: [ self hIsScrollbarShowing not ]) ifTrue: [ scroller offset x <= 0 ifFalse: [ scroller offset: self hMargin negated @ scroller offset y ] ]submorphs  ^submorphsselectionFrame  ^selectedMorph ifNotNil: [ selectedMorph bounds: selectedMorph selectionFrame in: self ]minWidth  | w |  w := super minWidth.  self keyText ifNotNil: [ w := w + (self fontToUse widthOfString: self keyTextExpanded) + 12 ].  ^wlabelMorph  ^labelMorphnewLabelMorph  ^Morph newscrollPane: anObject  scrollPane := anObjectaddAllMorphs: aCollection after: anotherMorph  ^self privateAddAllMorphs: aCollection atIndex: (submorphs indexOf: anotherMorph ifAbsent: [ submorphs size ])testExecuteSortingOn  | dataSource |  dataSource := self dataSourceForTesting.  state executeSortingOn: dataSource.  self assert: dataSource elements equals: self elementsForTestDataSource.  state executeSortingOn: dataSource.  self assert: dataSource elements equals: self elementsForTestDataSourceacceptDroppingMorph: dropped event: evt  | aMorph |  aMorph := self morphToDropFrom: dropped.  super acceptDroppingMorph: aMorph event: evt.  aMorph submorphsDo: [:m |  (m isKindOf: HaloMorph) ifTrue: [ m delete ] ].  self bringTopmostsToFrontbuildWindowMenu  | aMenu |  aMenu := UIManager default newMenuIn: self for: self.  aMenu add: 'Change name...' selector: #relabel.  aMenu addLine.  aMenu add: 'Send to back' selector: #sendToBack.  aMenu add: 'Make next-to-topmost' selector: #makeSecondTopmost.  aMenu addLine.  self mustNotClose ifFalse: [ aMenu add: 'Make unclosable' selector: #makeUnclosable ] ifTrue: [ aMenu add: 'Make closable' translated selector: #makeClosable ].  aMenu add: (self isSticky ifTrue: [ 'Make draggable' ] ifFalse: [ 'Make undraggable' ]) selector: #toggleStickiness.  ^aMenunewMenuItem  ^MenubarItemMorph newisStepping: aMorph  ^worldState isStepping: aMorphleftFlush  self changeAlignment: #leftFlushsubMenuSelector: anObject  subMenuSelector := anObject.  self updateSubMenuborderRaised  self borderColor: #raisedhandleMouseMove: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (anEvent anyButtonPressed and: [ anEvent hand mouseFocus == self ]) ifFalse: [ ^self ].  anEvent wasHandled: true.  self mouseMove: anEvent.  (self handlesMouseStillDown: anEvent) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue arguments: {anEvent copy resetHandlerFields} stepTime: 1 ]keyStroke: evt  self basicKeyStroke: evtsetPosition: pos contents: aMorph hand: aHand  position := pos.  contents := aMorph.  source := aHand.  wasHandled := falseshadowMargins  | left right top bottom deltaX deltaY |  left := right := top := bottom := 0.  (deltaX := self shadowOffset x) < 0 ifTrue: [ left := deltaX ] ifFalse: [ right := deltaX ].  (deltaY := self shadowOffset x) < 0 ifTrue: [ top := deltaY ] ifFalse: [ bottom := deltaY ].  ^Margin left: left right: right top: top bottom: bottomveryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  predecessor := deepCopier references at: predecessor ifAbsent: [ nil ].  successor := deepCopier references at: successor ifAbsent: [ nil ]spaceFillWeight: aNumber  aNumber = 1 ifTrue: [ self removeProperty: #spaceFillWeight ] ifFalse: [ self setProperty: #spaceFillWeight toValue: aNumber ].  self layoutChangedhandlesBasicKeys  ^handlesBasicKeys ifNil: [ true ]newToolSpacer  ^self theme newToolSpacerIn: selfhUnadjustedScrollRange  | itemsToCheck item index |  maxWidth ifNotNil: [ ^maxWidth ].  listItems isEmpty ifTrue: [ ^0 ].  itemsToCheck := 30 min: listItems size.  maxWidth := 0.  index := 1.  [ index < itemsToCheck ] whileTrue: [ item := self getListItem: index.        maxWidth := maxWidth max: (self widthToDisplayItem: item).        index := index + 1 ].  itemsToCheck < listItems size ifTrue: [ maxWidth := maxWidth * 2 ].  ^maxWidth + 150alarmSortBlock  ^[:alarm1 :alarm2 |  alarm1 scheduledTime < alarm2 scheduledTime ]drawOn: aCanvas  | area |  area := self innerBounds.  aCanvas fillRectangle: area fillStyle: self fillStyle.  value > 0 ifTrue: [ cachedWidth := self completedWidth.        area := area origin extent: cachedWidth @ area height.        aCanvas fillRectangle: area fillStyle: self barFillStyle ].  self borderStyle frameRectangle: self bounds on: aCanvasselection: aSelection  selection := aSelectionpressedButtonFillStyle  ^self theme scrollbarPressedButtonFillStyleFor: selfscale  ^scaleowner  ^ownerpopUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean  | evt |  aWorld submorphs select: [:each |  (each isKindOf: MenuMorph) and: [ each stayUp not ] ] thenCollect: [:menu |  menu delete ].  self items isEmpty ifTrue: [ ^self ].  self layoutItems.  self positionAt: aPoint relativeTo: (selectedItem ifNil: [ self items first ]) inWorld: aWorld.  aWorld addMorphFront: self.  hand newMouseFocus: self.  aBoolean ifTrue: [ hand newKeyboardFocus: self ].  evt := hand lastEvent.  (evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ] ]) ifTrue: [ self moveSelectionDown: 1 event: evt ].  self updateColor.  self changedok  self     cancelled: false;     applyChanges;     deletediscoveredMenuOn: aBuilder  ^aBuilder menuEntitled: self discoveredMenuTitleshadowForm  | canvas |  canvas := (Display defaultCanvasClass extent: self fullBounds extent depth: 1) asShadowDrawingCanvas: Color black.  canvas translateBy: bounds topLeft negated during: [:tempCanvas |  tempCanvas fullDrawMorph: self ].  ^canvas form offset: bounds topLeftfilter  pattern ifNil: [ ^self ].  table dataSource: (pattern ifEmpty: [ initialDataSource ] ifNotEmpty: [ initialDataSource newDataSourceMatching: (filterClass pattern: pattern) ]).  table refresh.  table deselectAll.  self isExplicit ifTrue: [ self resizeWidget ]updatePagingAreaBounds  pagingArea bounds: self totalSliderAreacolumnColorForOdd: oddColor  columnColors at: 1 put: nil.  columnColors at: 2 put: oddColorfillsOwner  ^fillsOwnerinitialize  super initialize.  self margin: 0menuColumn: column row: rowIndex  | menu method |  rowIndex = 0 ifTrue: [ ^nil ].  method := (self elementAt: rowIndex) method.  menu := UIManager default newMenuIn: self table for: self.  menu add: 'Browse ' , method methodClass name , '>>#' , method selector target: method selector: #browse.  menu add: 'Inspect #' , method methodClass name , '>>#' , method selector target: method selector: #inspect.  ^menulabel  ^self isSelected ifTrue: [ self selectedLabel userString ifNil: [ self firstSubmorph ] ] ifFalse: [ self normalLabel userString ifNil: [ self firstSubmorph ] ]initialize  super initialize.  self     initializeAppearance;     initializeLayout;     beResetable;     resetAlpha.  fadingFactor := self defaultFadingFactorsetScrollDeltas  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        hScrollBar interval: 1.0.        ^self ].  self hideOrShowScrollBars.  self vIsScrollbarShowing ifTrue: [ self vSetScrollDelta ].  self hIsScrollbarShowing ifTrue: [ self hSetScrollDelta ]sortingIcon  ^self context morphicIconNamed: #arrowUpAndDownhasNoScaleOrRotation  ^transform isPureTranslationhash  ^self species hash bitXor: (self width hash bitXor: self color hash)title: aString  titleContainer ifNotNil: [ titleContainer delete ].  titleContainer := AlignmentMorph newColumn.  titleContainer     color: Color transparent;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     wrapCentering: #center;     layoutInset: 0;     layoutChanged.  aString translated linesDo: [:line |  titleContainer addMorphBack: (StringMorph contents: line font: StandardFonts menuFont) ].  pinBox ifNotNil: [ ^self addMorph: titleContainer inFrontOf: pinBox ].  self addMorphBack: titleContainertabAddedToSelection: aTab  self setMultipleContentsgetSelectionIndex  ^scroller submorphs indexOf: selectedMorphdefaultColor  ^Color lightGrayautoMultiSelection: aBoolean  self listManager autoMultiSelection: aBooleanfillStyle  ^extension ifNil: [ ^color ] ifNotNil: [ extension fillStyle ifNil: [ color ] ]selectionFillStyle  ^self theme menuItemInDockingBarSelectedFillStyleFor: selfindex: anInteger  index := anIntegertopFraction  ^topFractioninitialDataSource  ^(function isKindOf: FTFilterFunction) ifTrue: [ function initialDataSource ] ifFalse: [ nil ]newEditableDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newEditableDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpTextdisable  question: aStringOrText title: aString  ^self theme questionIn: self text: aStringOrText title: aStringviewBox  ^self pasteUpMorph viewBoxfont: aFont  mouseEnterUpButton: event  upButton     fillStyle: self mouseOverButtonFillStyle;     borderStyle: self mouseOverButtonBorderStyle;     changedprivateSubmorphs  ^submorphstestBoundsBug1035  | submorph aMorph |  submorph := (PolygonMorph vertices: {(0 @ 0) .         (100 @ 0) .         (0 @ 100)} color: Color red borderWidth: 0 borderColor: Color transparent) color: Color red.  submorph bounds.  aMorph := Morph new     color: Color blue;     layoutPolicy: ProportionalLayout new;     addMorph: submorph fullFrame: (0.1 @ 0.1 corner: 0.9 @ 0.9) asLayoutFrame.  submorph bounds.  aMorph fullBounds.  submorph bounds.  aMorph extent: 100 @ 100.  submorph bounds.  aMorph fullBounds.  submorph bounds.  self assert: aMorph fullBounds equals: (0 @ 0 extent: 100 @ 100).  self assert: submorph bounds equals: (10 @ 10 corner: 90 @ 90)newListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector help: helpText  ^self newListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: nil help: helpTextbackgroundImage: aForm layout: aSymbol  self backgroundMorph: ((self theme builder newAlphaImage: aForm help: nil)           autoSize: false;           layout: aSymbol;           lock)defaultWidth  ^ProportionalSplitterMorph splitterWidthhasUnacceptedEdits  ^(self submorphs select: [:e |  e respondsTo: #hasUnacceptedEdits ]) anySatisfy: [:e |  e hasUnacceptedEdits ]increment  bar incrementwantsRecolorHandle  ^trueprepareForRotating  ^selfcurrent  ^bar valueautoGradient: aBoolean  autoGradient := aBoolean.  self updateColornewStateForEnabled: aBoolean  self deny: aBoolean.  ^TabDisabled tab: self tabcollapseNodePath: aPath  self allNodeMorphs first collapseNodePath: aPathdefaultColor  ^Color transparentinitialize  enabled := true.  autoSize := true.  scale := 1.0.  layout := #topLeft.  alpha := 1.0.  super initializeresetPosition  showIndex := 0.  self verticalScrollBar value: 0.  horizontalScrollBar ifNotNil: [ self horizontalScrollBar value: 0 ].  self container setNeedsRefreshExposedRows.  self container updateExposedRowsnewSpacer  ^Morph new     borderWidth: 0;     color: Color transparent;     extent: 0 @ 0;     minWidth: 0;     hResizing: #spaceFillrotationCenter: aPointOrNil  aPointOrNil ifNil: [ self removeProperty: #rotationCenter ] ifNotNil: [ self setProperty: #rotationCenter toValue: aPointOrNil ]transferStateToRenderer: aRenderer  aRenderer simplySetVisible: self visiblehandlesMouseWheel: evt  ^self vIsScrollable or: [ self hIsScrollable ]vLeftoverScrollRange  scroller hasSubmorphs ifFalse: [ ^0 ].  ^(self vTotalScrollRange - self vScrollBarHeight roundTo: self scrollDeltaHeight) max: 0label: aStringOrMorph  | l |  l := aStringOrMorph isMorph ifTrue: [ aStringOrMorph ] ifFalse: [ (self theme buttonLabelForText: aStringOrMorph)           vResizing: #shrinkWrap;           hResizing: #shrinkWrap ].  self     normalLabel: l;     selectedLabel: l;     selected: self isSelectedcollapseNonWindows  self nonWindows reject: [:m |  m isSticky ] thenDo: [:m |  m collapse ]selectNodePath: aPath  aPath ifNil: [ self emptySelection ] ifNotNil: [ self firstChild ifNotNil: [:fc |  fc selectNodePath: aPath ] ]deselectAll  self requestView: MorphTreeChangeRequest deselectAllfindSubmorphFor: ptY  ^scroller findSubmorphBinary: [:item |  (ptY between: item top and: item bottom) ifTrue: [ 0 ] ifFalse: [ | itemCenter |              itemCenter := (item top + item bottom) // 2.              ptY < itemCenter ifTrue: [ -1 ] ifFalse: [ 1 ] ] ]cornerStyle: aSymbol  (extension isNil or: [ self cornerStyle == aSymbol ]) ifTrue: [ ^self ].  extension cornerStyle: nil.  self changeddrawLineFrom: startPoint to: stopPoint on: aCanvas  | delta length dir cos sin tfm w h w1 w2 h1 h2 fill |  width isPoint ifTrue: [ w := width x.        h := width y ] ifFalse: [ w := h := width ].  w1 := w // 2.  w2 := w - w1.  h1 := h // 2.  h2 := h - h1.  delta := stopPoint - startPoint.  length := delta r.  dir := length > 1.0e-10 ifTrue: [ delta / length ] ifFalse: [ 1 @ 0 ].  cos := dir dotProduct: 1 @ 0.  sin := dir crossProduct: 1 @ 0.  tfm := MatrixTransform2x3 new     a11: cos;     a12: sin;     a21: sin negated;     a22: cos.  tfm offset: startPoint.  fill := self fillStyleForDirection: dir.  aCanvas asBalloonCanvas transformBy: tfm during: [:cc |  cc drawPolygon: {((0 - w1) @ (0 - h1)) .               ((length + w2) @ (0 - h1)) .               ((length + w2) @ h2) .               ((0 - w1) @ h2)} fillStyle: fill ]convertAlarms  alarms ifNotNil: [ alarms sortBlock: self alarmSortBlock ]makeBorderless  | b |  b := self class borderWidth.  self submorphsDo: [:m |  | l |        l := m layoutFrame.        l ifNotNil: [ l rightFraction = 1 ifTrue: [ l rightOffset: l rightOffset + b ].              l leftFraction = 0 ifTrue: [ l leftOffset: l leftOffset - b ].              l bottomFraction = 1 ifTrue: [ l bottomOffset: l bottomOffset + b ] ] ].  self borderWidth: 0mouseLeavePagingArea: event  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStyle;     changed.  slider     fillStyle: self normalThumbFillStyle;     borderStyle: self normalThumbBorderStyle;     changed.  upButton     fillStyle: self normalButtonFillStyle;     borderStyle: self normalButtonBorderStyle;     changed.  downButton     fillStyle: self normalButtonFillStyle;     borderStyle: self normalButtonBorderStyle;     changedprepareForRotating  ^self addFlexShellprepareForRotating  ^self addFlexShellreferencePosition  | rendered |  ^(rendered := self renderedMorph) == self ifTrue: [ super referencePosition ] ifFalse: [ transform localPointToGlobal: rendered referencePosition ]maximumExtent  ^self valueOfProperty: #maximumExtentchildNodeFromItem: anItem  ^((self childNodeClassFromItem: anItem) with: anItem model: model)     parentNode: self;     yourselfmin  ^minkeyStroke: anEvent  ^falseextension  ^extensionlabel  ^labeltrackCenterOfRotation: anEvent with: rotationHandle  (rotationHandle hasProperty: #dragByCenterOfRotation) ifTrue: [ ^self doDrag: anEvent with: rotationHandle ].  anEvent hand obtainHalo: self.  rotationHandle center: anEvent cursorPointcreateKeyTextMorph: aString  ^(self fixKeyText: aString) asStringMorph     font: self keyTextFont emphasis: 2;     color: textColor;     yourselfnewString: aStringOrText  ^self theme newStringIn: self label: aStringOrText font: self theme labelFont style: #plaincolor  ^colornewTabGroup: labelsAndPages  ^self theme newTabGroupIn: self for: labelsAndPagessortingSelector: s  sortingSelector := smorphicIconNamed: aString  ^(self iconNamed: aString) asMorphstoredListTab  ^TabMorph label: 'Stored List Model' icon: (self iconNamed: #smallHelpIcon) retrievingBlock: [ listModel buildWithSpec ]sortingIcon  ^nilorigin  ^self method originjustDroppedInto: aMorph event: anEvent  patternModel  ^patternModeladdGrips  self     addCornerGrips;     addEdgeGripsbasicKeyPressed: aChar  | nextSelection milliSeconds slowKeyStroke oldSelection |  nextSelection := oldSelection := self getCurrentSelectionIndex.  milliSeconds := Time millisecondClockValue.  slowKeyStroke := milliSeconds - lastKeystrokeTime > 500.  lastKeystrokeTime := milliSeconds.  self searchedElement: nil.  lastKeystrokes := slowKeyStroke ifTrue: [ aChar asLowercase asString ] ifFalse: [ lastKeystrokes , aChar asLowercase asString ].  nextSelection := self listForSearching findFirst: [:a |  a beginsWith: lastKeystrokes fromList: self ].  nextSelection isZero ifTrue: [ ^0 ].  model okToChange ifFalse: [ ^0 ].  oldSelection = nextSelection ifTrue: [ ^0 ].  self searchedElement: nextSelection.  ^nextSelectionstoreOn: aStream  aStream     nextPutAll: '(';     nextPutAll: self class name;     nextPutAll: ' width: ';     print: self width;     nextPutAll: ' color: ';     print: self color;     nextPutAll: ')'initialize  super initialize.  self     cancelled: true;     addInitialPanelrootItems  ^RPackageOrganizer default packagescontents  ^contentsgetValueSelector: anObject  getValueSelector := anObjectaddPolyShapingMenuItems: aMenu hand: aHandMorph  aMenu addLine.  aMenu addWithLabel: 'make inscribed diamondOval' enablement: [ self isClosed ] action: #diamondOval.  aMenu addWithLabel: 'make enclosing rectangleOval' enablement: [ self isClosed ] action: #rectangleOvalupdateExtent  | margin usedHeight |  self fullBounds.  self fillsOwner ifFalse: [ ^self ].  self owner ifNotNil: [:anOwner |  margin := self avoidVisibleBordersAtEdge ifTrue: [ self borderWidth * 2 ] ifFalse: [ 0 ].        self isHorizontal ifTrue: [ self width: anOwner width + margin ].        self isVertical ifTrue: [ usedHeight := self usedHeightByPredominantDockingBarsOfChastes: #(#top #bottom).              self height: anOwner height + margin - usedHeight ] ]textColor: aColor  self setProperty: #textColor toValue: aColor.  self listMorph color: aColorinitialDataSource: aDataSource  (function isKindOf: FTFilterFunction) ifTrue: [ function initialDataSource: aDataSource ]paneColorOrNil  ^super paneColorOrNil ifNotNil: [:c |  self theme subgroupColorFrom: c ]handleKeyUp: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (self handlesKeyUp: anEvent) ifFalse: [ ^self ].  anEvent wasHandled: true.  ^self keyUp: anEventrowMorphGetSelector  ^rowMorphGetSelectorlayoutBounds  | lb left right |  lb := super layoutBounds.  container ifNil: [ ^lb ].  left := lb left + self spacerWidth.  right := lb right max: left + self spacerWidth.  ^Rectangle left: left right: right top: lb top bottom: lb bottombuildContents  nodeList := nil.  scroller removeAllMorphs.  (self nodeList isNil or: [ self nodeList isEmpty ]) ifTrue: [ nodeList := nil.        ^self emptySelection ].  self addSubmorphsFromNodeListptName  ^#bottomLeftadd: aLabelString icon: aForm subMenu: aMenuMorph  self addToggle: aLabelString target: nil selector: nil.  self lastItem     icon: aForm;     subMenu: aMenuMorph.  ^selfaddAllToSelection: aCollection  | selHolder |  self searchedElement: nil.  aCollection do: [:m |  m           highlight;           selected: true ].  self selectionChanged.  self selectionUpdateFromViewWhile: [ selHolder := self newSelectionHolderWithNodePath: (aCollection last path collect: [:m |  m complexContents ]).        self listModel selection: selHolder ]colorsAtCorners  ^self borders first colorsAtCornersgridModulus: newModulus  self gridSpecPut: (self gridOrigin extent: newModulus).  self changednewString: aStringOrText font: aFont style: aStyle  ^self theme newStringIn: self label: aStringOrText font: aFont style: aStylenavigateFocusForward  self nextMorphWantingFocus ifNotNil: [:m |  m takeKeyboardFocus ]newPluggableDialogWindow: title  ^self newPluggableDialogWindow: title for: nilrefresh  lastRefresh := Time millisecondClockValue.  UIManager default uiProcess == Processor activeProcess ifTrue: [ self currentWorld doOneCycleNow ]columnColors  ^columnColorsstartBlinking  self startStepping: #onBlinkCursor at: Time millisecondClockValue arguments: nil stepTime: 500.  self resetBlinkCursortranslatedBy: delta  ^self shallowCopy translateBy: deltadisable  self enabled: falseenabled  ^enabledredoTypeIn: aText interval: anInterval  self handleEdit: [ self editor redoTypeIn: aText interval: anInterval ]listManager  ^listManager ifNil: [ listManager := MorphTreeListManager new client: self ]isMenuLineMorph  ^truenumberOfRows  ^self items ifNotNil: [ | cpt |        cpt := 0.        self items do: [:elements |  cpt := cpt + elements size ].        cpt ] ifNil: [ 0 ]scrollTarget  ^self scroller submorphs firstlayoutBounds  ^self isFullscreen ifTrue: [ self perform: #layoutBounds withArguments: #() inSuperclass: Morph ] ifFalse: [ super layoutBounds ]openInExternalWindowModalCallback: aBlock  | world |  world := OSWindowWorldMorph new extent: self extent.  world     layoutPolicy: ProportionalLayout new;     clipSubmorphs: true;     closeCallback: [ aBlock cull: self ].  self layoutFrame: LayoutFrame identity.  self     hResizing: #spaceFill;     vResizing: #spaceFill.  self openInWorld: world.  self onAnnouncement: MorphDeleted do: [:announce |  world ifNotNil: [ world delete ].        world := nil ].  ^world openaddGraphicalHandleFrom: formKey at: aPoint  | handle aForm |  aForm := Smalltalk ui icons iconNamed: formKey ifNone: [ self iconNamed: #solidMenuIcon ].  handle := ImageMorph new     form: aForm;     bounds: (Rectangle center: aPoint extent: aForm extent).  handle wantsYellowButtonMenu: false.  self addMorph: handle.  handle on: #mouseUp send: #endInteraction to: self.  ^handleaddPaneVSplitterBetween: leftMorphs and: rightMorphs  | targetX fixed bottomFraction topFrame bottomFrame sorted morph leftGroup rightGroup splitter offset |  leftMorphs ifEmpty: [ ^self ].  targetX := leftMorphs first layoutFrame rightFraction.  fixed := leftMorphs select: [:m |  m layoutFrame leftFraction = m layoutFrame rightFraction ].  sorted := ((leftMorphs reject: [:m |  m layoutFrame leftFraction = m layoutFrame rightFraction ]) asSortedCollection: [:a :b |  a layoutFrame bottomFraction = b layoutFrame bottomFraction ifTrue: [ a layoutFrame topFraction <= b layoutFrame topFraction ] ifFalse: [ a layoutFrame bottomFraction <= b layoutFrame bottomFraction ] ]) readStream.  sorted contents ifEmpty: [ ^fixed ].  leftGroup := OrderedCollection new.  bottomFraction := sorted contents first layoutFrame topFraction.  [ sorted atEnd or: [ morph := sorted next.        morph layoutFrame topFraction ~= bottomFraction and: [ morph layoutFrame bottomFraction ~= bottomFraction ] ] ] whileFalse: [ leftGroup add: morph.        bottomFraction := morph layoutFrame bottomFraction ].  topFrame := leftGroup first layoutFrame.  bottomFrame := leftGroup last layoutFrame.  rightGroup := (rightMorphs reject: [:m |  m layoutFrame leftFraction = m layoutFrame rightFraction ]) select: [:m |  m layoutFrame topFraction between: topFrame topFraction and: bottomFrame bottomFraction ].  offset := (leftGroup collect: [:m |  m layoutFrame rightOffset ]) max.  splitter := ProportionalSplitterMorph new.  splitter layoutFrame: ((targetX @ topFrame topFraction corner: targetX @ bottomFrame bottomFraction) asLayoutFrame           leftOffset: offset;           topOffset: topFrame topOffset;           rightOffset: 4 + offset;           bottomOffset: bottomFrame bottomOffset).  leftGroup := leftGroup , fixed.  leftGroup do: [:m |  splitter addLeftOrTop: m ].  rightGroup do: [:m |  splitter addRightOrBottom: m ].  self addMorphBack: splitter.  ^leftGroupturnOn  self borderColor: #inset.  self color: onColorvalueOfProperty: aSymbol ifAbsent: aBlock  otherProperties ifNil: [ ^aBlock value ].  ^otherProperties at: aSymbol ifAbsent: [ ^aBlock value ]toggleStickiness  extension ifNil: [ ^self beSticky ].  extension sticky: extension sticky notchildNodeClassFromItem: anItem  ^self classinitialize  super initialize.  self     layoutPolicy: TableLayout new;     cellPositioning: #leftCenter;     listDirection: #leftToRight;     cellSpacing: #none;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     color: Color transparentgrabTransform  ^owner ifNil: [ IdentityTransform new ] ifNotNil: [ owner grabTransform ]mouseDown: evt  (self isEditable: evt) ifTrue: [ self launchEditor: evt ] ifFalse: [ super mouseDown: evt ]balloonColor: aColor  ^self setProperty: #balloonColor toValue: aColortotalBarWidth  ^self width - (2 * self borderWidth)rowHeight: roIndex  ^self table rowHeightkeyStroke: event  | args aCharacter |  aCharacter := event keyValue asCharacter.  event anyModifierKeyPressed ifFalse: [ self basicKeyPressed: aCharacter.        ^false ].  (self scrollByKeyboard: event) ifTrue: [ ^true ].  keystrokeActionSelector ifNil: [ ^false ].  (args := keystrokeActionSelector numArgs) = 1 ifTrue: [ ^model perform: keystrokeActionSelector with: aCharacter ].  args = 2 ifTrue: [ ^model perform: keystrokeActionSelector with: aCharacter with: self ].  ^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'adjustRightX  | shrink |  shrink := container right - maxRightX.  lines do: [:line |  line paddingWidth: line paddingWidth - shrink ].  container := container withRight: maxRightXadjustLayout  | length overlap |  length := self computeLength.  self removeAllMorphs.  length isZero ifTrue: [ ^self ].  overlap := self overlap.  selectionHistory do: [:tab |  | index |        index := (tabs indexOf: tab) - 1.        self addMorph: tab fullFrame: (LayoutFrame identity                 rightFraction: 0;                 leftOffset: index * (length - overlap);                 rightOffset: index * (length - overlap) + length;                 bottomOffset: -1;                 yourself).        tab updateShowIcon ].  self addActionsFor: self selectedTabbeExplicit  super beExplicit.  table addMorph: actionButton.  table selectedIndex = 0 ifTrue: [ table selectIndex: 1 ]selectableIndexBellow: anIndex  ^anIndex + 1mouseDown: anEvent  | cp |  (self class showSplitterHandles not and: [ self bounds containsPoint: anEvent cursorPoint ]) ifTrue: [ oldColor := self color.        self setGrabbedColor ].  cp := anEvent cursorPoint.  lastMouse := {cp .   (cp - self position)}drawWeekDayNamesOn: aCanvas  | cellHeight height topLeft topRight cellWidth |  topLeft := self bounds topLeft translateBy: 0 @ 25.  topRight := self bounds topRight translateBy: 0 @ 25.  height := self bounds height - 25.  cellHeight := height // 8.  cellWidth := self bounds width // 7.  aCanvas line: (topLeft translateBy: 0 @ cellHeight) to: (topRight translateBy: 0 @ cellHeight) width: 1 color: Color black.  #('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat') withIndexDo: [:dayName :dayIndex |  | cellPosX cellTopCenter textWidth |        cellPosX := cellWidth * (dayIndex - 1).        cellTopCenter := topLeft translateBy: (cellPosX + (cellWidth // 2) + 1) @ 0.        textWidth := self weekdayFont widthOfString: dayName.        aCanvas drawString: dayName at: (cellTopCenter translateBy: (textWidth // -2) @ 3) font: self weekdayFont color: Color darkGray ]maxBarWidth  ^self bars inject: 0 into: [:max :next |  next minExtent x max: max ]selectionChanged: ann  self selectionChangedUpdateStatus: ann.  self selectionChangedUpdateIndex: ann.  self selectionChangedResetIfEmpty: annasTableLayoutProperties  ^TableLayoutProperties new     hResizing: self hResizing;     vResizing: self vResizing;     disableTableLayout: self disableTableLayout;     yourselficonOrThumbnail  ^self icon ifNil: [ | maxExtent fb |        maxExtent := 320 @ 240.        fb := self fullBounds.        fb area <= (maxExtent x * maxExtent y) ifTrue: [ self imageForm ] ifFalse: [ self imageFormForRectangle: (fb topLeft extent: maxExtent) ] ]isTableLayout  ^falsekeyStroke: event  (self navigationKey: event) ifTrue: [ ^self ].  (event keyCharacter = Character space or: [ event keyCharacter = Character cr ]) ifTrue: [ self performAction ]bottomRightOffset: aPoint  bottomOffset := aPoint y.  rightOffset := aPoint xhLeftoverScrollRange  | w |  scroller hasSubmorphs ifFalse: [ ^0 ].  w := bounds width.  self vIsScrollbarShowing ifTrue: [ w := w - self scrollBarThickness ].  ^(self hTotalScrollRange - w roundTo: self scrollDeltaHeight) max: 0setItemFromBlock: aBlock  self setItem: aBlock valuebeSingleSelection  multipleSelection := falsebaseColor: aColor  morphsAt: aPoint  ^self morphsAt: aPoint unlocked: falseframeRectangle: aRectangle on: aCanvas  self drawLineFrom: aRectangle bottomLeft + (self trimSize @ 0) to: aRectangle bottomRight - (self trimSize @ 0) on: aCanvasaddAllFromPragma: aString target: anObject  self addAllFrom: (PragmaMenuBuilder pragmaKeyword: aString model: anObject) menuhandleMouseLeave: anEvent  anEvent hand removePendingBalloonFor: self.  anEvent isDraggingEvent ifTrue: [ (self handlesMouseOverDragging: anEvent) ifTrue: [ anEvent wasHandled: true.              self mouseLeaveDragging: anEvent ].        ^self eventHandler ifNotNil: [:handler |  handler mouseLeave: anEvent fromMorph: self ] ].  ^(self handlesMouseOver: anEvent) ifTrue: [ anEvent wasHandled: true.        self mouseLeave: anEvent ] ifFalse: [ self eventHandler ifNotNil: [:handler |  handler mouseLeave: anEvent fromMorph: self ] ]rejectsEvent: anEvent  (super rejectsEvent: anEvent) ifTrue: [ ^true ].  anEvent isDropEvent ifTrue: [ ^true ].  ^falsecouldHaveRoundedCorners  ^falseprivateUpdateColumnMorphs  self resetRootInfo.  self updateTopHeader.  self innerWidgetChangedmouseUp: evt  | all |  all := allButtons copy.  all ifNotNil: [ all do: [:m |  m showSelectionFeedback ifTrue: [ m                       showSelectionFeedback: false;                       changed;                       layoutChanged ] ] ].  all ifNil: [ ^self ].  allButtons := nil.  all do: [:m |  (m containsPoint: evt cursorPoint) ifTrue: [ m enabled ifTrue: [ m performAction: evt ] ] ].  self showSelectionFeedback ifTrue: [ self changed ]treeMorphClass  ^LazyMorphTreeMorphchangeScrollerTableLayout  self scroller changeTableLayoutselectSubmorphsOf: aMorph  | newItems removals |  newItems := aMorph submorphs select: [:m |  (bounds containsRect: m fullBounds) and: [ m ~~ self and: [ (m isKindOf: HaloMorph) not ] ] ].  otherSelection ifNil: [ ^selectedItems := newItems ].  removals := newItems intersection: itemsAlreadySelected.  otherSelection setSelectedItems: (itemsAlreadySelected copyWithoutAll: removals).  selectedItems := newItems copyWithoutAll: removalsselectedNodePathList  ^selectedNodePathList ifNil: [ selectedNodePathList := OrderedCollection new ]drawOnAthensCanvas: anAthensCanvas  | img |  anAthensCanvas setPaint: self fillStyle.  anAthensCanvas drawShape: self bounds.  anAthensCanvas setPaint: self borderStyle.  anAthensCanvas drawShape: self bounds.  img := self imageToUse.  img ifNotNil: [ anAthensCanvas setPaint: img.        anAthensCanvas drawShape: (self innerBounds center - (img extent // 2) extent: img extent) ].  ((self state == #pressed or: [ self state == #repressed ]) and: [ image isNil ]) ifTrue: [ anAthensCanvas setPaint: (self paneColor alpha: 0.3).        anAthensCanvas drawShape: self innerBounds ].  (self enabled not and: [ self theme fadeCheckboxWhenDisabled ]) ifTrue: [ anAthensCanvas setPaint: (self paneColor alpha: 0.4).        anAthensCanvas drawShape: self innerBounds ]sendListenEvent: anEvent to: listenerGroup  listenerGroup ifNil: [ ^self ].  listenerGroup do: [:listener |  listener ifNotNil: [ listener handleListenEvent: anEvent copy ] ]complexContents  ^complexContentstoggleSelection  self selected ifTrue: [ self removeFromSelection ] ifFalse: [ self addToSelection ]mouseLeaveDownButton: event  event redButtonPressed ifFalse: [ downButton           fillStyle: self normalButtonFillStyle;           borderStyle: self normalButtonBorderStyle;           changed ]shrinkWrap: aBoolean  shrinkWrap := aBooleansnapToEdgeIfAppropriate  | edgeSymbol oldBounds aWorld |  (edgeSymbol := self valueOfProperty: #edgeToAdhereTo) ifNotNil: [ oldBounds := bounds.        self adhereToEdge: edgeSymbol.        bounds ~= oldBounds ifTrue: [ (aWorld := self world) ifNotNil: [ aWorld viewBox ifNotNil: [ aWorld displayWorld ] ] ] ]mouseEnter: event  super mouseEnter: event.  self wantsKeyboardFocus ifFalse: [ ^self ].  self keyboardFocusOnMouseDown ifFalse: [ self takeKeyboardFocus ]showBalloon: msgString hand: aHand  | w h |  (w := self world) ifNil: [ ^self ].  h := aHand ifNil: [ w activeHand ].  (self theme builder newBalloonHelp: msgString for: self balloonHelpAligner) popUpFor: self hand: haddTab: aStringOrMorph  self tabs add: (self newLabelMorph: aStringOrMorph).  self updateTabslabel  ^labelStringinitialize  super initialize.  self     fillStyle: self defaultFillStyle;     borderStyle: (BorderStyle inset           baseColor: self paneColor;           width: 1);     sliderColor: Color black;     clipSubmorphs: trueupdateColor  self theme preferGradientFill ifFalse: [ ^self ].  self fillStyle: (self theme progressFillStyleFor: self)useBitmapFill  | fill |  self fillStyle isBitmapFill ifTrue: [ ^self ].  fill := BitmapFillStyle fromForm: self defaultBitmapFillForm.  fill origin: self bounds origin.  self fillStyle: fillsetType: evtType position: evtPos direction: dirSymbol buttons: evtButtons hand: evtHand stamp: stamp  type := evtType.  position := evtPos.  buttons := evtButtons.  source := evtHand.  wasHandled := false.  direction := dirSymbol.  timeStamp := stampdefaultColor  ^Color transparentcurrentPageFirstIndex  ^currentPageFirstIndex ifNil: [ currentPageFirstIndex := 1 ]lastNonZeroIndex  ^lastNonZeroIndex ifNil: [ lastNonZeroIndex := 0 ]popUpNoKeyboard  ^self popUpAt: ActiveHand position forHand: ActiveHand in: self currentWorld allowKeyboard: falseinitializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigationforEachPointDo: aBlock lastPointDo: otherBlock  pointBlock := aBlock.  lastPointBlock := otherBlocknotExpandedToggleImage  ^notExpandedToggleImage ifNil: [ notExpandedToggleImage := ImageMorph new form: self notExpandedForm ]contents  ^contents ifNil: [ contents := super contents ]width  ^widthcanExpand  ^complexContents hasContentstestIfTheTestedMethodIstheSameThatTheOneUsedInProd  self assert: self theMethodInProdThatShouldBeTested bytecode equals: (self class >> #updateOrderedTasksFrom:) bytecoderotationDegrees  ^0.0fillStyleForDirection: direction  | index fill dir |  index := direction degrees truncated // 10 + 1.  lineStyles ifNotNil: [ fill := lineStyles at: index.        fill ifNotNil: [ ^fill ] ].  dir := Point r: 1.0 degrees: (index - 1) * 10 + 5.  fill := GradientFillStyle colors: (self colorsForDirection: dir).  fill     direction: 0 @ width asPoint y;     radial: false.  fill origin: ((width asPoint x // 2) @ (width asPoint y // 2)) negated.  fill pixelRamp: (fill computePixelRampOfSize: 16).  fill isTranslucent.  lineStyles ifNil: [ lineStyles := Array new: 37 ].  lineStyles at: index put: fill.  ^fillareasRemainingToFill: aRectangle  ^Array with: aRectanglemouseDown: event  | targetMorph selectors |  self enabled ifFalse: [ ^self ].  mouseOverAllowed := true.  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ].  (event yellowButtonPressed and: [ (self commandOrCrontrolKeyPressed: event) not ]) ifTrue: [ ^self yellowButtonEvent: event ].  (targetMorph := self scrollerSubMorphFromPoint: event position) ifNotNil: [ targetMorph hasToggle ifTrue: [ (targetMorph inToggleArea: (targetMorph point: event position from: self)) ifTrue: [ ^self toggleExpandedState: targetMorph event: event ] ] ].  targetMorph ifNil: [ ^super mouseDown: event ].  targetMorph highlightForMouseDown.  selectors := Array with: #click: with: #doubleClick: with: nil with: (self dragEnabled ifTrue: [ #startDrag: ]).  event hand waitForClicksOrDrag: self event: event selectors: selectors threshold: 10.  self listManager mouseDown: event on: targetMorphenabled  ^state enabledbrowseItem  Smalltalk tools browser openOnClass: self itemClass selector: self selectorlineIndexForPoint: aPoint  | i py |  py := aPoint y truncated.  i := (self fastFindFirstLineSuchThat: [:line |  line bottom > py ]) min: lines size.  [ i < lines size and: [ (lines at: i + 1) top = (lines at: i) top and: [ aPoint x >= (lines at: i + 1) left ] ] ] whileTrue: [ i := i + 1 ].  ^ifontName: fontName size: fontSize  ^self font: (StrikeFont familyName: fontName size: fontSize) emphasis: 0updateSliderBounds  self     updateUpButtonBounds;     updateDownButtonBounds;     updatePagingAreaBounds.  super updateSliderBoundsglamourOptimalExtent  | tmpOldResizing tmpResult |  tmpOldResizing := self setOptimalResizingStrategyAndReturnOldOne.  tmpResult := self minExtent.  self returnToOldResizingStrategy: tmpOldResizing.  ^tmpResultdrawOnAthensCanvas: aCanvas  self subclassResponsibilitywantsToShow: aHashValue  ^limit < 0 or: [ (countDict at: aHashValue ifAbsent: [ 0 ]) < limit ]printOn: aStream  aStream nextPut: $[.  aStream     nextPutAll: type;     nextPutAll: ' '''.  self printKeyStringOn: aStream.  aStream nextPut: $'.  aStream nextPut: $]takesKeyboardFocus  ^self enabledlabel  ^label contentsinitialize  super initialize.  showIndex := 0.  showColumnHeaders := true.  columns := #().  needToggleAtMouseUp := false.  self beRowSelection.  self beNotResizable.  self beSingleSelection.  self enableSearch.  self initializeScrollBars.  self initializeContainer.  self initializeKeyBindings.  self resizeAllSubviewsicon  ^self iconNamed: #windowIconfullContainsPoint: pt  ^bounds containsPoint: ptselection: item  self selectionIndex: (self getList indexOf: item)arguments  ^argumentsonlyCloseAndPinable  self     withCloseBox;     title: '';     withPinBoxmakeAScreenshot  | filePrefix |  filePrefix := 'PharoScreenshot'.  (UIManager default chooseFrom: {'The entire world' translated .         'A selected area' translated} values: #(#world #area) message: 'What do you want to shoot? (File will be saved in image directory)' translated title: 'Make a screenshot') ifNotNil: [:choice |  | form name |        form := choice = #world ifTrue: [ self currentWorld imageForm ] ifFalse: [ Form fromUser ].        name := (FileSystem workingDirectory / filePrefix , 'png') nextVersion.        PNGReadWriter putForm: form onFileNamed: (FileSystem workingDirectory / filePrefix , 'png') nextVersion.        UIManager default inform: (String streamContents: [:s |  s                       nextPutAll: 'Screenshot saved under ';                       nextPutAll: name fullName;                       cr;                       nextPutAll: 'Click to open location' ]) actionOnClick: [ name openInOSFileBrowser ] ]showCloseIcon  closeIcon showaddDirectionHandles  | centerHandle d w directionShaft patch patchColor crossHairColor |  self showingDirectionHandles ifFalse: [ ^self ].  directionArrowAnchor := (target point: target referencePosition in: self world) rounded.  patch := target imageFormForRectangle: (Rectangle center: directionArrowAnchor extent: 3 @ 3).  patchColor := patch colorAt: 1 @ 1.  (directionShaft := LineMorph newSticky makeForwardArrow)     borderWidth: 2;     borderColor: (Color green orColorUnlike: patchColor).  self positionDirectionShaft: directionShaft.  self addMorphFront: directionShaft.  directionShaft     setCenteredBalloonText: 'Set forward direction' translated;     on: #mouseDown send: #doDirection:with: to: self;     on: #mouseMove send: #trackDirectionArrow:with: to: self;     on: #mouseUp send: #setDirection:with: to: self.  d := 15.  w := 3.  crossHairColor := Color red orColorUnlike: patchColor.  (centerHandle := EllipseMorph newBounds: (0 @ 0 extent: d @ d) color: Color transparent)     borderWidth: w;     borderColor: (Color blue orColorUnlike: patchColor);     addMorph: (LineMorph from: (d // 2) @ w to: (d // 2) @ (d - w - 1) color: crossHairColor width: 1) lock;     addMorph: (LineMorph from: w @ (d // 2) to: (d - w - 1) @ (d // 2) color: crossHairColor width: 1) lock;     align: centerHandle bounds center with: directionArrowAnchor.  centerHandle wantsYellowButtonMenu: false.  self addMorph: centerHandle.  centerHandle     setCenteredBalloonText: 'Rotation center (hold down the shift key and drag from here to change it)' translated;     on: #mouseDown send: #prepareToTrackCenterOfRotation:with: to: self;     on: #mouseMove send: #trackCenterOfRotation:with: to: self;     on: #mouseUp send: #setCenterOfRotation:with: to: selfselectableIndexBellow: anIndex  ^{(anIndex first + 1) .   anIndex second}allOwners  ^Array streamContents: [:strm |  self allOwnersDo: [:m |  strm nextPut: m ] ]handlesMouseStillDown: evt  ^actWhen == #whilePressedcolumnResizerFrames  | xOffset frms |  xOffset := 0.  frms := self columns collect: [:col |  xOffset := self minResizerOffset max: xOffset + col currentWidth.        (scroller left + xOffset) @ self top corner: (scroller left + xOffset + self resizerWidth) @ scroller bottom ].  self lastColumnUnbounded ifTrue: [ frms ifNotEmpty: [ frms removeLast ] ].  ^frms collect: [:f |  f translateBy: scroller offset x negated @ 0 ]unlockContents  self submorphsDo: [:m |  m unlock ]resizerChanged  self columns size > 1 ifTrue: [ self           updateColumnResizersXOffset;           resizeScroller;           updateColumnMorphs ] ifFalse: [ self updateTopHeader ]isOpaque: aBool  aBool == false ifTrue: [ self removeProperty: #isOpaque ] ifFalse: [ self setProperty: #isOpaque toValue: aBool ].  self changedinitializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigationsize  | n cell |  n := 0.  cell := self.  [ cell isNil ] whileFalse: [ n := n + 1.        cell := cell nextCell ].  ^nuseSolidFill  self fillStyle isSolidFill ifTrue: [ ^self ].  self fillStyle: self fillStyle asColorisEnabled  ^isEnabledelementAt: index  ^rootItem childAt: indexallOwnersDo: aBlock  owner ifNotNil: [ ^owner withAllOwnersDo: aBlock ]mouseOverPagingAreaButtonBorderStyle  ^self theme scrollbarMouseOverBarButtonBorderStyleFor: selfnewSliderFor: aModel getValue: getSel setValue: setSel getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: 0 max: 1 quantum: nil getEnabled: enabledSel help: helpTextnewCancelButton  ^self newCancelButtonFor: selfincrement  ^progressBar incrementbeCheckList  self isCheckList: trueaddSubmorphsFromNodeList  self addSubmorphsFromNodeList: self currentNodelist previouslyExpanded: #()bringWindowsFullOnscreen  | r |  bounds allAreasOutsideList: (self taskbars collect: [:t |  t bounds ]) do: [:e |  r ifNil: [ r := e ] ifNotNil: [ r area > e area ifTrue: [ r ] ifFalse: [ e ] ] ].  (self windowsSatisfying: [:w |  true ]) do: [:aWindow |  aWindow right: (aWindow right min: r right).        aWindow bottom: (aWindow bottom min: r bottom).        aWindow left: (aWindow left max: r left).        aWindow top: (aWindow top max: r top) ]honeIn: centerN step: step measure: measure withIn: closeEnough  | nTry |  step < 1 ifTrue: [ ^centerN ].  nTry := centerN - step.  ^measure > (closeEnough + (self measureFor: nTry)) ifTrue: [ self honeIn: centerN step: step // 2 measure: measure withIn: closeEnough ] ifFalse: [ self honeIn: nTry step: step // 2 measure: measure withIn: closeEnough ]pinBoxClicked  owner toggleStayUp.  self updatePinFormsetUp  super setUp.  strategy := self actualClass column: FTColumn newupdate: aSymbol with: anObject  super update: aSymbol.  aSymbol == #selectedIndex ifTrue: [ | selectedPage |        selectedPage := self tabGroup pages at: anObject ifAbsent: [ nil ].        selectedPage ifNotNil: [ selectedPage rememberKeyboardFocus: ActiveHand keyboardFocus.              self tabGroup page ifNotNil: [ self tabGroup page activate ] ] ]vHideScrollBar  self vIsScrollbarShowing ifFalse: [ ^self ].  self removeMorph: scrollBar.  self resetExtenthasSpecialCTRLKeyValue  ^self controlKeyPressed and: [ keyValue <= 26 & (keyValue ~= 4) & (keyValue ~= 1) ]searchText: aString  aString isEmptyOrNil ifTrue: [ ^#() ].  self elements withIndexDo: [:each :index |  (each name beginsWith: aString) ifTrue: [ ^{index} ] ].  ^#()add: wordingString icon: aForm help: helpString subMenu: aMenuMorph action: anAction keyText: aText  | item |  item := self newMenuItem     contents: wordingString;     subMenu: aMenuMorph;     icon: aForm;     keyText: aText;     yourself.  anAction ifNotNil: [:act |  item           target: act receiver;           selector: act selector;           arguments: act arguments ].  helpString ifNotNil: [ item setBalloonText: helpString ].  self addMorphBack: iteminvalidRect: damageRect  ^self invalidRect: damageRect from: selfenable  self enabled: truedoScrollUp  (self waitForDelay1: 200 delay2: 40) ifFalse: [ ^self ].  self setValue: (value - scrollDelta - 0.000001 max: 0.0)newColorChooserFor: aModel getColor: getSel setColor: setSel getEnabled: enabledSel help: helpText  ^self theme newColorChooserIn: self for: aModel getColor: getSel setColor: setSel getEnabled: enabledSel help: helpTextinitForEvents  mouseOverHandler := nil.  lastMouseEvent := MouseEvent basicNew setType: #mouseMove position: 0 @ 0 buttons: 0 hand: self.  lastEventBuffer := {1 .   0 .   0 .   0 .   0 .   0 .   nil .   nil}.  recentModifiers := 0.  self resetClickStatenewColorChooserFor: aModel getColor: getSel setColor: setSel help: helpText  ^self theme newColorChooserIn: self for: aModel getColor: getSel setColor: setSel getEnabled: nil help: helpTextassureLayoutProperties  | props |  props := self layoutProperties.  props == self ifTrue: [ props := nil ].  props ifNil: [ props := LayoutProperties new initializeFrom: self.        self layoutProperties: props ].  ^propssetWindowColor: incomingColor  | aColor |  incomingColor ifNil: [ ^self ].  aColor := incomingColor.  self setProperty: #paneColor toValue: aColor.  self setStripeColorsFrom: aColor.  self theme fadedBackgroundWindows ifFalse: [ self adoptPaneColor: aColor ].  self changednewGroupbox: aString  ^self theme newGroupboxIn: self label: aStringis: anIndex aboveRow: aRowIndex  ^anIndex < aRowIndexwithCloseBox  closeBox ifNotNil: [ closeBox delete ].  closeBox := self iconButtonCalling: #closeBoxClicked withForm: self theme menuCloseForm helpText: 'Close this menu'.  self addMorph: closeBox asElementNumber: 1menu: aBlock  menuBlock := aBlocknextMorphAcrossInWindow  ^(self owner notNil and: [ self owner isWorldMorph ]) ifTrue: [ self ] ifFalse: [ super nextMorphAcrossInWindow ]expandAll  self subclassResponsibilityframeRectangle6: aRectangle on: aCanvas  | r |  r := aRectangle insetBy: self width // 2.  self width odd ifTrue: [ r := r insetBy: (0 @ 0 corner: 1 @ 1) ].  aCanvas     line: r topLeft + (6 @ 0) to: r topRight - (6 @ 0) width: self width color: self color;     line: r topRight + (-5 @ 1) to: r topRight + (-3 @ 2) width: self width color: self color;     line: r topRight + (-2 @ 3) to: r topRight + (-2 @ 3) width: self width color: self color;     line: r topRight + (-1 @ 4) to: r topRight + (-1 @ 5) width: self width color: self color;     line: r topRight + (0 @ 6) to: r bottomRight - (0 @ 6) width: self width color: self color;     line: r bottomRight - (1 @ 5) to: r bottomRight - (2 @ 3) width: self width color: self color;     line: r bottomRight - (3 @ 2) to: r bottomRight - (4 @ 1) width: self width color: self color;     line: r bottomRight - (5 @ 1) to: r bottomRight - (6 @ 0) width: self width color: self color;     line: r bottomRight - (7 @ 0) to: r bottomLeft + (6 @ 0) width: self width color: self color;     line: r bottomLeft - (-5 @ 1) to: r bottomLeft - (-4 @ 1) width: self width color: self color;     line: r bottomLeft - (-3 @ 2) to: r bottomLeft - (-3 @ 2) width: self width color: self color;     line: r bottomLeft - (-2 @ 3) to: r bottomLeft - (-1 @ 5) width: self width color: self color;     line: r bottomLeft - (0 @ 6) to: r topLeft + (0 @ 6) width: self width color: self color;     line: r topLeft + (1 @ 5) to: r topLeft + (1 @ 4) width: self width color: self color;     line: r topLeft + (2 @ 3) to: r topLeft + (2 @ 3) width: self width color: self color;     line: r topLeft + (3 @ 2) to: r topLeft + (5 @ 1) width: self width color: self colordeeplyDetect: aBlock  self rootNodes do: [:sub |  (sub deeplyDetect: aBlock) ifNotNil: [:found |  ^found ] ].  ^nildelete  parent := nil.  complexContents := nil.  firstChild := nil.  container := nil.  nextSibling := nil.  controls := nil.  super deleteextraSelectionRects  ^Array streamContents: [:strm |  extraSelectionBlocks ifNotNil: [:blocks |  blocks do: [:selBlock |  strm nextPutAll: (self selectionRectsFrom: selBlock first to: selBlock last) ] ] ]spawnNewProcess  UIProcess := [ [ WorldMorph doOneCycle.  Processor yield.  false ] whileFalse: [  ] ] newProcess priority: Processor userSchedulingPriority.  UIProcess name: 'Morphic UI Process'.  UIProcess resumenewMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newMorphDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpTextdrawToggleOn: aCanvas in: aRectangle  | aForm centeringOffset |  aForm := self toggleImageForm.  centeringOffset := ((aRectangle height - aForm extent y) / 2.0) truncated.  ^aCanvas translucentImage: aForm at: (aRectangle topLeft translateBy: 0 @ centeringOffset)selectionColor  ^selectionColorkeyboardNavigationHandler  | aHandler |  aHandler := self valueOfProperty: #keyboardNavigationHandler ifAbsent: [ ^nil ].  (aHandler hasProperty: #moribund) ifTrue: [ self removeProperty: #keyboardNavigationHandler.        ^nil ].  ^aHandlerrightArrowStroked: evt  (selectedItem notNil and: [ selectedItem hasSubMenu ]) ifTrue: [ evt hand newMouseFocus: selectedItem subMenu.        selectedItem subMenu moveSelectionDown: 1 event: evt.        evt hand newKeyboardFocus: selectedItem subMenu.        ^true ].  ^falsenewHSVASelector: aColor help: helpText  ^self theme newHSVASelectorIn: self color: aColor help: helpTextcellSize: aPoint  cellSize := aPointnewDataSourceMatching: aFTFilter  ^selfgetIndexSelector: aSelector  getIndexSelector := aSelectorcornerStyle: aSymbol  super cornerStyle: aSymbol.  self layoutInset: (self theme buttonLabelInsetFor: self)insertNewMorphs: morphList  scroller addAllMorphs: morphListmagicAlpha: alpha  self setProperty: #magicAlpha toValue: alpha.  self changedcomposeAllLines  [ currCharIndex <= theText size and: [ currentY + defaultLineHeight <= theContainer bottom ] ] whileTrue: [ (nowSliding ifTrue: [ self slideOneLineDown ] ifFalse: [ self composeOneLine ]) ifNil: [ ^nil ] ]sliderShadowColor  ^Color black alpha: 0.6newCheckboxFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel getLabel: labelSel help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel getLabel: labelSel help: helpTextinitializeMorph  field := RubScrolledTextModel new newTextField     hResizing: #spaceFill;     autoAccept: true;     withGhostText: self ghostText;     yourself.  field model announcer when: RubTextUpdatedInModel send: #textUpdated: to: selfimages  ^images ifNil: [ images := Dictionary newFromPairs: {#off .               [ self offImage ] .               #pressed .               [ self pressedImage ] .               #on .               [ self onImage ] .               #repressed .               [ self repressedImage ifNil: [ self onImage ] ]} ]showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset  self changed.  temporaryCursorOffset ifNotNil: [ bounds := bounds translateBy: temporaryCursorOffset negated ].  cursorOrNil ifNil: [ temporaryCursor := temporaryCursorOffset := hardwareCursor := nil ] ifNotNil: [ temporaryCursor := cursorOrNil asCursorForm.        temporaryCursorOffset := temporaryCursor offset - hotSpotOffset.        (cursorOrNil isKindOf: Cursor) ifTrue: [ hardwareCursor := cursorOrNil ] ].  bounds := self cursorBounds.  self     layoutChanged;     changedchanged  | msRefreshRate isTimeForRefresh |  msRefreshRate := 25.  isTimeForRefresh := Time millisecondClockValue - lastRefresh >= msRefreshRate.  super changed.  (self isInWorld and: [ isTimeForRefresh ]) ifTrue: [ self refresh ]isCheckList: aBoolean  self listManager isCheckList: aBooleanisModalInvokationDone: aBool  self setProperty: #isModalInvokationDone toValue: aBoolresetWorldMenu  menuBuilder ifNotNil: [ menuBuilder reset.        menuBuilder := nil ]sortingIcon  ^self sortingStrategy sortingIconshiftedYellowButtonActivity  ^self yellowButtonActivity: trueselectPrefix: aString  | firstMatch |  self items do: [:item |  | match |        match := aString isEmpty or: [ item contents asString asLowercase beginsWith: aString ].        item isEnabled: match.        (match and: [ firstMatch isNil ]) ifTrue: [ firstMatch := item ] ].  ^firstMatchimageExtent  ^self form extentchangeSelectionRequest: anAnnounce  self updateSelectionFromModelfullscreenBounds  ^(RealEstateAgent maximumUsableAreaInWorld: self world) insetBy: self fullscreenMargintriggerSelectedColor  self triggerEvent: #selectedColor with: self selectedColorvalueOfProperty: aSymbol  ^extension ifNotNil: [ extension valueOfProperty: aSymbol ]useFindReplaceSelection  ^falsemaximize  self isMinimized ifTrue: [ self collapseOrExpand ].  self isMaximized ifFalse: [ self expandBoxHit ]createHandleAt: aPoint color: aColor iconName: iconName  | bou handle |  bou := Rectangle center: aPoint extent: self handleSize asPoint.  self gradientHalo ifTrue: [ handle := Morph newBounds: bou color: aColor.        handle borderWidth: 1.        handle useRoundedCorners.        self setColor: aColor toHandle: handle ] ifFalse: [ handle := EllipseMorph newBounds: bou color: aColor ].  handle borderColor: aColor muchDarker.  handle wantsYellowButtonMenu: false.  iconName ifNotNil: [ (self iconNamed: iconName) ifNotNil: [:form |  | image |              image := ImageMorph new.              image form: form.              image color: aColor contrastingBlackAndWhiteColor.              image lock.              handle addMorphCentered: image ] ].  ^handlemorphsAt: aPoint unlocked: aBool  | mList |  mList := Array new writeStream.  self morphsAt: aPoint unlocked: aBool do: [:m |  mList nextPut: m ].  ^mList contentsintersectionsWith: aRectangle  | retval |  retval := IdentitySet new: 4.  (self bounds intersects: aRectangle) ifFalse: [ ^retval ].  self lineSegmentsDo: [:lp1 :lp2 |  | polySeg |        polySeg := LineSegment from: lp1 to: lp2.        aRectangle lineSegmentsDo: [:rp1 :rp2 |  | rectSeg int |              rectSeg := LineSegment from: rp1 to: rp2.              int := polySeg intersectionWith: rectSeg.              int ifNotNil: [ retval add: int ] ] ].  ^retvalchooseForSaveFileReference: title extensions: exts path: path  ^self chooseForSaveFileReference: title extensions: exts path: path preview: niltestSelectableIndexBellow  self assert: (strategy selectableIndexBellow: 2) equals: 3columnMorphAt: anIndex  ^controls at: anIndexanyModifierKeyPressed  ^self buttons anyMask: 2r01110000ownerChanged  | priorEditor |  super ownerChanged.  container ifNotNil: [ editor ifNil: [ self releaseParagraph.              (container isKindOf: TextContainer) ifTrue: [ self installEditorToReplace: nil.                    self releaseParagraph ] ] ifNotNil: [ priorEditor := editor.              self releaseParagraph.              self installEditorToReplace: priorEditor ] ]defaultBounds  ^0 @ 0 corner: 200 @ 160adjustHeight  testSelectedRowIndex  table selectIndex: #(3 5).  self assert: strategy selectedRowIndex equals: 3.  table selectIndex: #(4 5).  self assert: strategy selectedRowIndex equals: 4printOn: aStream  super printOn: aStream.  aStream     nextPut: $[;     print: clickState;     nextPut: $]justDroppedInto: newOwner event: evt  selectedItems isEmpty ifTrue: [ ^self extendByHand: evt hand ].  dupLoc ifNotNil: [ dupDelta := self position - dupLoc ].  selectedItems reverseDo: [:m |  self defer: [ m referencePosition: (newOwner localPointToGlobal: m referencePosition).              newOwner handleDropMorph: (DropEvent new setPosition: evt cursorPoint contents: m hand: evt hand) ] ].  evt wasHandled: trueinitialize  super initialize.  self option: #leftexpandRoots  self roots do: [:each |  (each canExpand and: [ each isExpanded not ]) ifTrue: [ each toggleExpandedState ] ].  self adjustSubmorphPositionsisCurvy  ^smoothCurve and: [ vertices size > 2 ]wantsSteps  ^falseisAdheringToTop  ^falsenewDataSourceMatching: aFTFilter  | newItems |  newItems := items class withAll: (items collect: [:coll |  coll select: [:each |  aFTFilter matches: (self toString: each) ] ]).  ^self class new items: newItemspressedBorderStyle  ^self theme scrollbarPressedBorderStyleFor: selfmodel  ^self dataSource modelbackgroundColoringBlockOrSelector: aSelector  backgroundColoringBlockOrSelector := aSelectormouseUpInSlider: event  slider borderStyle style == #inset ifTrue: [ slider borderColor: #raised ].  sliderShadow hideinitialize  super initialize.  self     value: 1.0;     color: Color blackisDockingBar  ^truetransformedBy: aTransform  self changed.  self transform: (self transform composedWithGlobal: aTransform).  self computeBounds.  self changedupdateAllRows  self table isShowColumnHeaders ifTrue: [ self updateHeaderRow ] ifFalse: [ headerRow := nil ].  self updateExposedRowsopenInWorld: aWorld  self bounds: (RealEstateAgent initialFrameFor: self world: aWorld).  ^self openAsIsIn: aWorldtabRemovedFromSelection: aTab  numberOfSelectedTabs == 1 ifTrue: [ ^self ].  numberOfSelectedTabs := numberOfSelectedTabs - 1.  selectionHistory remove: aTab.  selectionHistory add: aTab afterIndex: selectionHistory size - numberOfSelectedTabs.  aTab silentlySelected: false.  self adjustLayout.  self triggerEvent: #tabRemovedFromSelection with: aTabkeyboardNavigationHandler: aHandler  aHandler ifNil: [ self removeProperty: #keyboardNavigationHandler ] ifNotNil: [ self setProperty: #keyboardNavigationHandler toValue: aHandler ]setPredecessor: newPredecessor  predecessor := newPredecessorbeTopWindow  | oldTopWindow |  oldTopWindow := TopWindow.  TopWindow := self.  oldTopWindow ifNotNil: [ oldTopWindow privateBePassive ].  self announceActivatedinspectElement  | key obj |  key := UIManager default chooseFrom: self sortedPropertyNames values: self sortedPropertyNames title: 'Inspect which property?' translated.  key ifNil: [ ^self ].  obj := otherProperties at: key ifAbsent: [ 'nOT a vALuE' ].  obj = 'nOT a vALuE' ifTrue: [ (self perform: key) inspect ] ifFalse: [ obj inspect ]newVerticalSeparator  ^self theme newVerticalSeparatorIn: selfoptimalExtent  ^self submorphBounds extent + (self borderWidth * 2)rubberBandCells: aBool  rubberBandCells := aBoolcolorForInsets  ^owner ifNil: [ color ] ifNotNil: [ owner color ]removeAllMorphs  | oldMorphs myWorld |  myWorld := self world.  (fullBounds notNil or: [ myWorld notNil ]) ifTrue: [ self invalidRect: self fullBounds ].  submorphs do: [:m |  myWorld ifNotNil: [ m outOfWorld: myWorld ].        m privateOwner: nil ].  oldMorphs := submorphs.  submorphs := EmptyArray.  oldMorphs do: [:m |  self removedMorph: m ].  self layoutChangedinitializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #WindowShortcutsbecomeActiveDuring: aBlock  | priorWorld priorHand priorEvent |  priorWorld := ActiveWorld.  priorHand := ActiveHand.  priorEvent := ActiveEvent.  ActiveWorld := self.  ActiveHand := self hands first.  ActiveEvent := nil.  aBlock on: Error do: [:ex |  ActiveWorld := priorWorld.        ActiveEvent := priorEvent.        ActiveHand := priorHand.        ex pass ]beComplete  self closeunselectRow: index  selectedRows remove: index ifAbsent: [ ^self ].  self invalidRect: (self selectionFrameForRow: index)minCellSize: aPoint  self assureTableProperties minCellSize: aPoint.  self layoutChangedmouseStillDown: evt  actWhen == #whilePressed ifFalse: [ ^self ].  (self containsPoint: evt cursorPoint) ifTrue: [ self doButtonAction ]drag: event  dragSelector ifNotNil: [ clickClient perform: dragSelector with: event ]listSpacing  ^#nonewrapCentering  ^wrapCenteringmodifyClippingBounds: clippingBounds  | rightOffset |  rightOffset := -10.  closeIcon visible ifTrue: [ rightOffset := rightOffset - 14 ].  ^clippingBounds withRight: (clippingBounds right + rightOffset) * self displayScaleFactorisExpanded  ^falserotationDegrees  ^self forwardDirectionprivateFullBounds: boundsRect  fullBounds := boundsRectnewButtonRow  | answer buttons e |  buttons := self newButtons.  e := 0 @ 0.  buttons do: [:b |  e := e max: b minExtent ].  buttons do: [:b |  b extent: e ].  answer := Morph new     color: Color transparent;     changeTableLayout;     cellInset: 8;     listDirection: #leftToRight;     listCentering: #bottomRight;     hResizing: #spaceFill;     vResizing: #shrinkWrap.  buttons do: [:b |  answer addMorphBack: b ].  ^answerisEasySelecting  ^worldState isEasySelectingshowDirectionHandles: wantToShow  self showDirectionHandles: wantToShow addHandles: truemouseFocus  ^mouseFocusbounds  ^boundshandleAllowanceForIconicHalos  ^12vUnadjustedScrollRange  | submorphBounds |  submorphBounds := scroller localSubmorphBounds ifNil: [ ^0 ].  ^submorphBounds bottomupdate: aSymbol  | msRefreshRate isTimeForRefresh |  aSymbol == #width ifTrue: [ self updateWidth ].  msRefreshRate := 60.  isTimeForRefresh := Time millisecondClockValue - self lastRefresh >= msRefreshRate.  (self isInWorld and: [ isTimeForRefresh ]) ifFalse: [ ^self ].  self refreshisOpen  ^closed notfillingOnOff  self fillsOwner: self fillsOwner notnewHSVSelector: aColor help: helpText  ^self theme newHSVSelectorIn: self color: aColor help: helpTextsource: anObject  source := anObjecthideLocation  self locationMorph     visible: false;     changedpaneColorOrNil  ^self paneColorpredecessor  ^predecessorunexpandedFrame  ^self valueOfProperty: #unexpandedFramepressed: aBoolean  pressed := aBoolean.  self update: (getLabelSelector ifNil: [ getIconSelector ])compositionRectangle  | compRect |  compRect := self innerBounds.  compRect := compRect insetBy: margins.  compRect width < 9 ifTrue: [ compRect := compRect withWidth: 9 ].  compRect height < 16 ifTrue: [ compRect := compRect withHeight: 16 ].  ^compRectwidthForRounding  ^0roundedCorners  owner isFloating ifTrue: [ ^#(1 4) ].  owner isAdheringToTop ifTrue: [ ^#(1 4) ].  owner isAdheringToBottom ifTrue: [ ^#(2 3) ].  owner isAdheringToLeft ifTrue: [ ^#(1 2) ].  owner isAdheringToRight ifTrue: [ ^#(3 4) ].  ^#(1 2 3 4)mouseDown: evt  evt yellowButtonPressed ifTrue: [ (self yellowButtonActivity: evt shiftPressed) ifTrue: [ ^self ] ].  self handleInteraction: [ editor mouseDown: evt ].  self hasKeyboardFocus ifFalse: [ self takeKeyboardFocus ].  super mouseDown: evtdefaultPageSize  ^niltextUpdated: anAnnouncement  self filterWith: field getTextFromModelthemeChanged  self color: self theme textColor.  super themeChangedwithSnapshotBorder  self borderStyle: ((ComplexBorder style: #complexFramed)           color: (Color r: 0.613 g: 1.0 b: 0.516);           width: 1;           yourself)expandItemPath: anItemPath  | rest |  rest := anItemPath asOrderedCollection.  [ rest notEmpty ] whileTrue: [ | res |        res := (1 to: self nodeList size) select: [:li |  (self nodeList at: li) item = rest first ].        res isEmpty ifTrue: [ ^self ].        self pager nextPage: res first.        (self allNodeMorphs at: 1 ifAbsent: [ ^self ]) openItemPath: {rest first}.        rest := rest copyWithoutFirst ].  ^selfnewAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletionpagerHeight  ^self pager ifNil: [ 0 ] ifNotNil: [ pager computedHeight ]outOfWorld: aWorld  aWorld ifNil: [ ^self ].  self submorphsDo: [:m |  m outOfWorld: aWorld ]activeSubmenu: aSubmenu  activeSubMenu ifNotNil: [ activeSubMenu delete ].  activeSubMenu := aSubmenusetTarget: aMorph  (target := aMorph) ifNotNil: [ offsetFromTarget := self position - target position ]children  ^childrennewPluggableDialogWindow  ^self newPluggableDialogWindow: 'Dialog'resetHandlerFields  initialize  super initialize.  self extent: self defaultWidth @ self defaultHeight.  self layoutFrame: self gripLayoutFrameborderWidth: anInteger  borderColor ifNil: [ borderColor := Color black ].  borderWidth := anInteger max: 0.  self changedlabel  ^labelrowMorphForNode: aNode inColumn: aColumn  | hasIcon |  hasIcon := (aColumn container iconBlock value: aNode) notNil.  (aColumn isFirstColumn and: [ hasIcon ]) ifTrue: [ ^super rowMorphForNode: aNode inColumn: aColumn ].  self layoutInset: aColumn container columnInset @ aColumn container rowInset.  self fitContents.  ^selfelementAt: index  | tmpIndex |  tmpIndex := index.  self items do: [:elements |  tmpIndex <= elements size ifTrue: [ ^elements at: tmpIndex ] ifFalse: [ tmpIndex := tmpIndex - elements size ] ].  self errorSubscriptBounds: indexbeAllFont: aFont  textStyle := TextStyle fontArray: (Array with: aFont).  self     releaseCachedState;     changedaddNodePath: aPath  self selectedNodePath: aPathhideScrollBarsIndefinitely  self hideScrollBarsIndefinitely: truecancelled  ^cancelleddoubleClickTimeout: anEvent fromMorph: aMorph  ^self notify: anEvent from: aMorphinitialize  super initialize.  columnColors := Array with: Color transparent with: Color transparent.  rowColors := Array with: self theme backgroundColor with: self theme backgroundColor.  self borderWidth: 0selectedDisabledBorderStyle  ^self theme controlButtonSelectedDisabledBorderStyleFor: selfpanelRect  ^self innerBounds insetBy: (0 @ self labelHeight corner: 0 @ 0)handleMouseUp: anEvent  anEvent wasHandled ifTrue: [ ^self ].  anEvent hand releaseMouseFocus: self.  anEvent wasHandled: true.  anEvent blueButtonChanged ifTrue: [ self blueButtonUp: anEvent ] ifFalse: [ self mouseUp: anEvent ]canBeMaximized  ^self isResizeable and: [ self isNotMaximized ]sortedPropertyNames  | props |  props := (Array new: 10) writeStream.  locked == true ifTrue: [ props nextPut: #locked ].  visible == false ifTrue: [ props nextPut: #visible ].  sticky == true ifTrue: [ props nextPut: #sticky ].  balloonText ifNotNil: [ props nextPut: #balloonText ].  externalName ifNotNil: [ props nextPut: #externalName ].  eventHandler ifNotNil: [ props nextPut: #eventHandler ].  otherProperties ifNotNil: [ otherProperties associationsDo: [:a |  props nextPut: a key ] ].  ^props contents sort: [:s1 :s2 |  s1 <= s2 ]currentNodelist  ^self nodeList copyFrom: 1 to: (self lastIndex min: self nodeList size)model: anObject  model ifNotNil: [ model removeDependent: self ].  anObject ifNotNil: [ anObject addDependent: self ].  model := anObjectdefaultBorderWidth  ^2delete  predecessor ifNotNil: [ predecessor setSuccessor: successor ].  successor ifNotNil: [ successor setPredecessor: predecessor.        successor recomposeChain ].  super deleteisStepping  | aWorld |  ^(aWorld := self world) ifNil: [ false ] ifNotNil: [ aWorld isStepping: self ]setColumnWidthsFor: aCanvas  | row topRow bottomRow |  columnWidths ifNil: [ columnWidths := (self item: 1) collect: [:ignored |  0 ] ].  topRow := (self topVisibleRowForCanvas: aCanvas) max: 1.  bottomRow := (self bottomVisibleRowForCanvas: aCanvas) max: 1.  topRow > bottomRow ifTrue: [ ^self ].  topRow to: bottomRow do: [:rowIndex |  row := self item: rowIndex.        columnWidths := columnWidths with: row collect: [:currentWidth :item |  | widthOfItem |              widthOfItem := font widthOfStringOrText: item.              widthOfItem > currentWidth ifTrue: [ self changed.                    widthOfItem ] ifFalse: [ currentWidth ] ] ]localHandleKeystroke: evt  (self editView keystrokeFromTextMorph: evt) ifTrue: [ ^true ].  (self autoAccept and: [ evt keyCharacter = Character cr and: [ self crAction notNil ] ]) ifTrue: [ (self crAction isKindOf: MessageSend) ifTrue: [ self crAction value ] ifFalse: [ self crAction value: self text ].        ^true ].  evt keyCharacter = Character tab ifTrue: [ evt shiftPressed ifTrue: [ (self editView respondsTo: #navigateFocusBackward) ifTrue: [ self editView navigateFocusBackward ] ] ifFalse: [ (self editView respondsTo: #navigateFocusForward) ifTrue: [ self editView navigateFocusForward ] ].        ^true ].  ^falsecolor: aColor  colorsAtCorners  | c c14 c23 |  c := self color.  c14 := c lighter.  c23 := c darker.  ^Array with: c14 with: c23 with: c23 with: c14vExtraScrollRange  ^super vExtraScrollRange + self topHeaderHeightminHeight: aNumber  aNumber ifNil: [ self removeProperty: #minHeight ] ifNotNil: [ self setProperty: #minHeight toValue: aNumber ].  self layoutChangednameSelector: aSymbol  nameSelector := aSymbol.  self updateContentsfocusColor  ^self borderStyle color contrastingBlackAndWhiteColornormalThumbFillStyle  ^self theme scrollbarNormalThumbFillStyleFor: selfpageMorph  ^self contentMorph hasSubmorphs ifTrue: [ self contentMorph submorphs first ]containsPoint: aPoint event: anEvent  (self fullBounds containsPoint: aPoint) ifFalse: [ ^false ].  (self containsPoint: aPoint) ifTrue: [ ^true ].  self submorphsDo: [:m |  (m isLocked and: [ m fullContainsPoint: ((m transformedFrom: self) globalPointToLocal: aPoint) ]) ifTrue: [ ^true ] ].  ^falsemouseOverPagingAreaButtonFillStyle  ^self theme scrollbarMouseOverBarButtonFillStyleFor: selfleftArrow  ^LeftArrownewVerticalSeparator  ^self theme newVerticalSeparatorIn: selfborderStyle  ^borderStylechangeFont  | newFont chooser |  chooser := FontChooser windowTitle: 'Choose a Font' for: self setSelector: #font: getSelector: self fontToUse.  self openModal: chooser.  newFont := chooser result.  newFont ifNotNil: [ self font: newFont ]handleDropFiles: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (self wantsDropFiles: anEvent) ifFalse: [ ^self ].  anEvent wasHandled: true.  self dropFiles: anEventdragEnabled  ^self editView dragEnabledisRestored  ^(self isMinimized or: [ self isMaximized ]) nottreeMorphClass  ^PaginatedMorphTreeMorphdrawLineToggleToTextOn: aCanvas hasToggle: hasToggle  | myBounds myCenter hLineY hLineLeft myTheme ldelta |  self isSoleItem ifTrue: [ ^self ].  self hasToggle ifTrue: [ ^self ].  myBounds := self toggleRectangle.  myCenter := myBounds center.  hLineY := myCenter y - 1.  ldelta := container treeLineWidth // 2.  hLineLeft := myCenter x - ldelta.  myTheme := self theme.  aCanvas frameRectangle: (hLineLeft @ hLineY corner: (myBounds right + 3 + ldelta) @ (hLineY + container treeLineWidth)) width: container treeLineWidth colors: (myTheme treeLineColorsFrom: (self parent ifNil: [ self lineColor ] ifNotNil: [ self parent lineColor ])) dashes: self treeLineDasheswantsRoundedCorners  ^self isFullscreen ifTrue: [ false ] ifFalse: [ ^super wantsRoundedCorners ]noteNewOwner: aMorph  super noteNewOwner: aMorph.  self updateLayoutInDockingBarnextToFirstPoint  self isCurvy ifTrue: [ curveState ifNil: [ self coefficients ].        ^curveState second ] ifFalse: [ ^vertices second ]frameRectangle: aRectangle on: aCanvas  | w h r |  self colors ifNil: [ ^super frameRectangle: aRectangle on: aCanvas ].  w := self width.  w isPoint ifTrue: [ h := w y.        w := w x ] ifFalse: [ h := w ].  1 to: h do: [:i |  r := aRectangle topLeft + (i - 1) extent: (aRectangle width - ((i - 1) * 2)) @ 1.        aCanvas fillRectangle: r color: (colors at: i).        r := aRectangle bottomLeft + (i @ (0 - i)) extent: (aRectangle width - ((i - 1) * 2) - 1) @ 1.        aCanvas fillRectangle: r color: (colors at: colors size - i + 1) ].  1 to: w do: [:i |  r := aRectangle topLeft + (i - 1) extent: 1 @ (aRectangle height - ((i - 1) * 2)).        aCanvas fillRectangle: r color: (colors at: i).        r := aRectangle topRight + ((0 - i) @ i) extent: 1 @ (aRectangle height - ((i - 1) * 2) - 1).        aCanvas fillRectangle: r color: (colors at: colors size - i + 1) ]workspace: aWorkspace  setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundednewHSplitterAt: anIndex  | above frame splitter index size |  size := submorphs size.  index := size - anIndex + 2.  above := self submorphs at: index.  frame := above layoutFrame.  splitter := self newHSplitter.  splitter layoutFrame: ((frame leftFraction @ frame bottomFraction corner: frame rightFraction @ frame bottomFraction) asLayoutFrame bottomOffset: 4).  self privateAddMorph: splitter atIndex: size - anIndex + 2privateFullMoveBy: delta  self privateMoveBy: delta.  transform := transform asMorphicTransform withOffset: transform offset - deltarunLocalStepMethods  worldState runLocalStepMethodsIn: selfkeyText: anObject  keyText := anObjectresetCount  countDict := Dictionary newsubmorphIndexOf: aMorph  ^submorphs indexOf: aMorph ifAbsent: [ nil ]setDefaultParameters  self theme setSystemProgressMorphDefaultParameters: selfasAthensPaintOn: anAthensCanvas  ^self topLeftColor = self bottomRightColor ifTrue: [ super asAthensPaintOn: anAthensCanvas ] ifFalse: [ self asTwoColorStrokePaintOn: anAthensCanvas ]addCustomMenuItems: aCustomMenu hand: aHandMorph  | outer |  super addCustomMenuItems: aCustomMenu hand: aHandMorph.  aCustomMenu addUpdating: #autoFitString target: self selector: #autoFitOnOff.  aCustomMenu addUpdating: #wrapString target: self selector: #wrapOnOff.  aCustomMenu add: 'text margins...' selector: #changeMargins:.  aCustomMenu add: 'add predecessor' selector: #addPredecessor:.  aCustomMenu add: 'add successor' selector: #addSuccessor:.  aCustomMenu add: 'code pane menu...' selector: #yellowButtonActivity.  aCustomMenu add: 'code pane shift menu...' selector: #shiftedYellowButtonActivity.  outer := self owner.  outer ifNotNil: [ outer isLineMorph ifTrue: [ container ifNotNil: [ aCustomMenu add: 'set baseline' selector: #setCurveBaseline: ] ] ifFalse: [ self fillsOwner ifFalse: [ aCustomMenu add: 'fill owner''s shape' selector: #fillingOnOff ] ifTrue: [ aCustomMenu add: 'rectangular bounds' selector: #fillingOnOff ].              self avoidsOcclusions ifFalse: [ aCustomMenu add: 'avoid occlusions' selector: #occlusionsOnOff ] ifTrue: [ aCustomMenu add: 'ignore occlusions' selector: #occlusionsOnOff ] ] ]event  ^eventclipText  | content |  content := self userString.  content ifNil: [ | list |        list := self allStringsAfter: nil.        list notEmpty ifTrue: [ content := String streamContents: [:stream |  list do: [:each |  stream                             nextPutAll: each;                             cr ] ] ] ].  content ifNil: [ self flash ] ifNotNil: [ Clipboard clipboardText: content ]borderWidth: bw  | newExtent |  super borderWidth: bw.  newExtent := 2 * bw + image extent min asPoint.  bounds extent = newExtent ifFalse: [ super extent: newExtent ]hasRubberBandCellsString  ^self rubberBandCells -> 'rubber band cells' translatedquestion: aStringOrText  ^self question: aStringOrText title: 'Question' translatedcolorSelected: aColor  self aMorph color: aColor.  self triggerSelectedColorstate  ^statenodeMorphsWithAllNodeItems: aNodeItemList  | result |  result := OrderedCollection new.  self allNodeMorphs do: [:m |  aNodeItemList do: [:sel |  m expandPath: sel ] ].  self allNodeMorphs do: [:m |  aNodeItemList do: [:sel |  (m matchPath: sel) ifNotNil: [:col |  result addAll: col ] ] ].  ^result flattenedgetListElementSelector  ^getListElementSelectortasks  ^tasksmouseDownOnMultiple: event forRow: row  | anInteger oldIndex oldVal valueKeeper |  canMove ifFalse: [ ^self ].  canMove := false.  model okToChange ifFalse: [ canMove := true.        ^self ].  canMove := true.  dragOnOrOff := (self listSelectionAt: row) not.  valueKeeper := dragOnOrOff.  (event shiftPressed not and: [ event yellowButtonPressed not and: [ self autoDeselect ] ]) ifTrue: [ self resetListSelection ].  oldIndex := self getCurrentSelectionIndex.  oldIndex ~= 0 ifTrue: [ oldVal := self listSelectionAt: oldIndex ].  anInteger := valueKeeper ifTrue: [ row ] ifFalse: [ 0 ].  setIndexSelector ifNotNil: [ model perform: setIndexSelector with: anInteger ].  oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].  event shiftPressed ifTrue: [ ((oldIndex max: 1) min: row) to: (oldIndex max: row) do: [:i |  self listSelectionAt: i put: valueKeeper ].        self changed ] ifFalse: [ self listSelectionAt: row put: valueKeeper ]getEnabledSelector  ^getEnabledSelectortabAmongFields  ^self theme settings tabAmongFields or: [ self hasProperty: #tabAmongFields ]rowMorphForColumn: aTreeColumn  ^self item ifNotNil: [:i |  self asString asMorph ]beResizeable  isResizeable := true.  self isResizeable ifTrue: [ self addGripsIfWanted ]minHeight  ^8 max: super minHeightcanvas: x  self worldRenderer canvas: x.  damageRecorder ifNil: [ damageRecorder := DamageRecorder new ] ifNotNil: [ damageRecorder doFullRepaint ]isRadioButton: anObject  isRadioButton := anObjectisResizable  ^resizablemodel: anObject  model := anObjectactiveSubmenu: aSubmenu  super activeSubmenu: aSubmenu.  aSubmenu ifNotNil: [ activeSubMenu activatedFromDockingBar: nil ]source  ^sourcetakesKeyboardFocus  ^falsethemeChanged  self fillStyle: self normalFillStyle.  super themeChangedprepareForRotating  ^self addFlexShellmouseLeave: evt  oldBorderStyle ifNil: [ ^self borderNormal ].  self borderStyle: oldBorderStyle.  oldBorderStyle := nilkeyboardFocusChange: gotFocus  self announceKeyboardFocusChange: gotFocus.  paragraph ifNotNil: [ paragraph focused: gotFocus ].  gotFocus ifTrue: [ self hasFocus ifFalse: [ self editor ].        self editor focused: true.        self showOverEditableTextCursor.        self useFindReplaceSelection ifTrue: [ self selectionChanged ] ] ifFalse: [ editor ifNotNil: [ editor focused: false ].        self hideOverEditableTextCursor ].  self manageCursor.  self editView ifNil: [ self focusChanged ] ifNotNil: [ self editView focusChanged ].  self acceptOnFocusChange == true ifTrue: [ self editView hasUnacceptedEdits ifTrue: [ self editor accept ] ]newTreeFor: aModel list: listSelector selected: getSelector changeSelected: setSelector  ^self theme newTreeIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelectorrootClass  ^rootClass ifNil: [ rootClass := Object ]removeFromSelection: aMorph  aMorph selected ifFalse: [ ^false ].  aMorph selected: false.  aMorph unhighlight.  self selectionUpdateFromViewWhile: [ | selHolder |        selHolder := self newSelectionHolderWithNodePath: nil.        self listModel selection: selHolder ].  ^trueoption  ^optionshowCloseIcon  closeable ifTrue: [ closeIcon show ]amendSteppingStatus  self wantsSteps ifTrue: [ self arrangeToStartStepping ] ifFalse: [ self stopStepping ]shadowOffset  extension ifNil: [ ^0 @ 0 ].  ^self valueOfProperty: #shadowOffset ifAbsent: [ 0 @ 0 ]minimumExtent  ^self defaultPreviewExtent + 64hScrollBarMenuButtonPressed: event  ^self scrollBarMenuButtonPressed: eventhasDirectionHandlesString  ^self wantsDirectionHandles -> 'direction handles' translatedminWidth  ^100asReadOnlyMorph  ^StringMorph contents: self textlastKeystrokes  ^lastKeystrokesactionMap  ^self updateableActionMaptoggleLocked  self lock: self isLocked notrestoreDisplayAfter: aBlock  aBlock value.  self currentWorld activeHand waitButton.  self currentWorld fullRepaintNeededpressedFillStyle  ^self theme splitterPressedFillStyleFor: selfrightCenter  ^bounds rightCenterunstyledTextFrom: aText  ^aTextinitialize  | anExtent |  super initialize.  anExtent := self valueOfProperty: #nominalExtent ifAbsent: [ 25 @ 25 ].  self extent: anExtentnewPanel  ^self theme newPanelIn: selfchooseFont  ^self chooseFont: nilscrollDeltaWidth  ^self scrollDeltaHeight // 2textAnchorType: aSymbol  aSymbol == #document ifTrue: [ ^self removeProperty: #textAnchorType ] ifFalse: [ ^self setProperty: #textAnchorType toValue: aSymbol ]adjustedCenter: c  self center: chandleListenEvent: anEvent  (anEvent isMouse and: [ anEvent isMove not ]) ifFalse: [ ^self ].  anEvent hand removeMouseListener: self.  (self world ifNil: [ target world ]) ifNil: [ ^self ].  self addHandlestextAlignment  ^self editor textAlignmentdisplayWorld: aWorld submorphs: submorphs  worldRenderer displayWorldState: self ofWorld: aWorld submorphs: submorphsaddRotateHandle: haloSpec  (self addHandle: haloSpec on: #mouseDown send: #startRot:with: to: self) on: #mouseMove send: #doRot:with: to: selftopCenter  ^bounds topCenterhash  ^self type hashupdateableActionMap  | actionMap |  self assureExtension.  actionMap := extension actionMap.  actionMap ifNil: [ actionMap := self createActionMap.        extension actionMap: actionMap ].  ^actionMapbackgroundColor  ^self subclassResponsibilitynextState  ^self subclassResponsibilityspacer: hsize  ^Morph new     color: Color transparent;     extent: hsize @ (self hasSubmorphs ifTrue: [ self computedHeight ] ifFalse: [ self preferedFont height + 8 ]);     yourselflocked: aBoolean  locked := aBooleanactivate  self activatedModalChild ifTrue: [ ^self ].  self addPaneSplittersIfNeeded.  super activate.  self isEmbedded ifFalse: [ self basicActivate ].  self navigateFocus.  self positionModalOwnerupdate: symbol  symbol == #refresh ifTrue: [ ^self refresh ].  ^super update: symboldrawOn: aCanvas  | dotBounds alphaCanvas windowBorderWidth dotBounds2 |  self shouldDraw ifFalse: [ ^self ].  windowBorderWidth := SystemWindow borderWidth.  alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.  dotBounds := self bounds.  dotBounds2 := dotBounds left: dotBounds right - windowBorderWidth.  dotBounds2 := dotBounds2 top: dotBounds2 bottom - windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds right: dotBounds right - windowBorderWidth.  dotBounds2 := dotBounds2 top: dotBounds2 bottom - windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds2 left: dotBounds2 left + 7.  dotBounds2 := dotBounds2 right: dotBounds2 right - 7.  alphaCanvas fillRectangle: dotBounds2 color: self dotColor.  dotBounds2 := dotBounds left: dotBounds right - windowBorderWidth.  dotBounds2 := dotBounds2 bottom: dotBounds2 bottom - windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds2 top: dotBounds2 top + 7.  dotBounds2 := dotBounds2 bottom: dotBounds2 bottom - 7.  alphaCanvas fillRectangle: dotBounds2 color: self dotColorwantsDropSelector  ^wantsDropSelectorgradient  self subclassResponsibilityvisibleTabRange: anInterval  visibleTabRange := anInterval.  self     changed: #leftButtonEnabled;     changed: #rightButtonEnabledtabResetSelection: aTab  selectionHistory ifNotEmpty: [ (selectionHistory last: numberOfSelectedTabs) do: [:each |  each == aTab ifFalse: [ each silentlySelected: false ] ] ].  numberOfSelectedTabs := 1.  self addInHistory: aTab.  self adjustLayout.  self triggerEvent: #tabResetSelection with: aTabdetachKeymapCategory: aCategoryName targetting: anObject  self kmDispatcher detachKeymapCategory: aCategoryName targetting: anObjectavoidVisibleBordersAtEdge: aBoolean  avoidVisibleBordersAtEdge := aBoolean.  self updateLayoutPropertiesupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]contents: newContents  self privateSetContents: newContents.  self fitContentsicon: anIcon  icon ifNotNil: [ self removeMorph: icon ].  anIcon ifNotNil: [ icon := anIcon.        self addMorphFront: anIcon ]mouseUp: evt  self enabled ifFalse: [ ^self perform: #mouseUp: withArguments: {evt} inSuperclass: Morph ].  actWhen == #buttonUp ifFalse: [ ^self perform: #mouseUp: withArguments: {evt} inSuperclass: Morph ].  (self containsPoint: evt cursorPoint) ifTrue: [ state == #repressed ifTrue: [ self state: #off ] ifFalse: [ self state: #on ].        self doButtonAction: evt ].  ^self perform: #mouseUp: withArguments: {evt} inSuperclass: MorphmeasureFor: n  | p1 measure |  p1 := self first.  measure := 0.  1 to: n do: [:i |  | p2 |        p2 := self polynomialEval: i / n asFloat.        measure := measure + (p2 distanceTo: p1).        p1 := p2 ].  ^measuresetSlider: aMorph withShadow: anotherMorph  slider ifNotNil: [ self removeMorph: slider ].  sliderShadow ifNotNil: [ self pagingArea removeMorph: sliderShadow ].  slider := aMorph.  sliderShadow := anotherMorph.  slider on: #mouseMove send: #scrollAbsolute: to: self.  slider on: #mouseDown send: #mouseDownInSlider: to: self.  slider on: #mouseUp send: #mouseUpInSlider: to: self.  self pagingArea addMorph: sliderShadow.  sliderShadow hide.  self addMorph: slider.  self computeSliderenabledString  ^self enabled -> 'enabled' translatedmodel  ^modelinterimContents: aString  self contents: aStringselectedRow: index  selectedRow ifNotNil: [ self selectionFrameChanged ].  selectedRow := index.  selectedRow ifNotNil: [ self selectionFrameChanged ]deepCopy  | new |  new := self copy.  new textStyle: textStyle copy lines: lines copy text: text deepCopy.  ^newrightButtonEnabled  ^self wrapScrolling or: [ self visibleTabRange last < self tabs size ]setType: aSymbol buttons: anInteger position: pos keyValue: aValue charCode: anInt hand: aHand stamp: stamp  type := aSymbol.  buttons := anInteger.  position := pos.  keyValue := aValue.  charCode := anInt.  source := aHand.  wasHandled := false.  timeStamp := stampdiscoveredMenuTitle  ^self class discoveredMenuTitlenudgeForLabel: aRectangle  | i flags nudge |  (self bounds intersects: aRectangle) ifFalse: [ ^0 @ 0 ].  flags := 0.  nudge := 0 @ 0.  i := 1.  aRectangle lineSegmentsDo: [:rp1 :rp2 |  | rectSeg |        rectSeg := LineSegment from: rp1 to: rp2.        self straightLineSegmentsDo: [:lp1 :lp2 |  | polySeg int |              polySeg := LineSegment from: lp1 to: lp2.              int := polySeg intersectionWith: rectSeg.              int ifNotNil: [ flags := flags bitOr: i ] ].        i := i * 2 ].  nudge := flags caseOf: {([ 0 ] -> [ 0 @ 0 ]) .         ([ 9 ] -> [ 1 @ 1 ]) .         ([ 3 ] -> [ -1 @ 1 ]) .         ([ 12 ] -> [ 1 @ -1 ]) .         ([ 6 ] -> [ -1 @ -1 ]) .         ([ 10 ] -> [ 0 @ -1 ]) .         ([ 5 ] -> [ 1 @ 0 ]) .         ([ 8 ] -> [ -1 @ 0 ]) .         ([ 1 ] -> [ 0 @ -1 ]) .         ([ 2 ] -> [ 1 @ 0 ]) .         ([ 4 ] -> [ 0 @ 1 ]) .         ([ 11 ] -> [ 0 @ 1 ]) .         ([ 13 ] -> [ 1 @ 0 ]) .         ([ 14 ] -> [ 0 @ -1 ]) .         ([ 7 ] -> [ -1 @ 0 ]) .         ([ 15 ] -> [ 1 @ -1 ])}.  ^nudgeenabled  ^self sliderMorph ifNil: [ super enabled ] ifNotNil: [:sm |  sm enabled ]initialize  super initialize.  tabs := OrderedCollection new.  selectionHistory := OrderedCollection new.  menuButton := self createMenuButton.  numberOfSelectedTabs := 1.  self changeProportionalLayout.  self addMenuButtonbuildToggleButton  ^PluggableToggleButtonMorph on: self getState: nil action: #toggleAction: label: #label menu: niladdToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol enablementSelector: enableSymbol  self addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol enablementSelector: enableSymbol argumentList: EmptyArrayhelpText  ^model helpTextbackgroundMorph: aMorph  self backgroundMorph ifNotNil: [ self backgroundMorph delete ].  backgroundMorph := aMorph.  aMorph ifNotNil: [ aMorph bounds: self bounds.        self addMorphBack: aMorph ]buildButtonWithIconBottom  ^(PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: nil) beIconBottomupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]containsPoint: aPoint  (bounds containsPoint: aPoint) ifFalse: [ ^false ].  self hasSubmorphs ifTrue: [ | localPoint |        localPoint := transform globalPointToLocal: aPoint.        self submorphsDo: [:m |  (m containsPoint: localPoint) ifTrue: [ ^true ] ].        ^false ] ifFalse: [ ^true ]rowAndColumnIndexContainingPoint: aPoint  self exposedRows keysAndValuesDo: [:rowIndex :row |  (row bounds containsPoint: aPoint) ifTrue: [ row submorphs withIndexDo: [:each :columnIndex |  (each bounds containsPoint: aPoint) ifTrue: [ ^{rowIndex .                           columnIndex} ] ] ] ].  ^{nil .   nil}startStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTime  worldState startStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTimetable  ^tableindex  ^indexrememberKeyboardFocus: aMorph  (aMorph isNil or: [ (aMorph hasOwner: self) not ]) ifFalse: [ self setProperty: #rememberedFocus toValue: aMorph ]filterClass  ^filterClassfont: aFont  font == aFont ifTrue: [ ^self ].  font := aFont.  self updateFontopenInWorld: aWorld extent: extent  self     position: (RealEstateAgent initialFrameFor: self initialExtent: extent world: aWorld) topLeft;     extent: extent.  ^self openAsIsIn: aWorldminExtentOf: aMorph in: newBounds  | min |  min := 0 @ 0.  aMorph submorphsDo: [:m |  | extent frame |        extent := m minExtent.        frame := m layoutFrame.        frame ifNotNil: [ extent := frame minExtentFrom: extent ].        min := min max: extent ].  ^minisKeystroke  ^self type == #keystrokeselectPath: path in: listItem  path isEmpty ifTrue: [ ^self setSelectedMorph: nil ].  listItem withSiblingsDo: [:each |  each complexContents item = path first ifTrue: [ each isExpanded ifFalse: [ each toggleExpandedState.                    self adjustSubmorphPositions ].              each changed.              path size = 1 ifTrue: [ ^self setSelectedMorph: each ].              each firstChild ifNil: [ ^self setSelectedMorph: nil ].              ^self selectPath: path allButFirst in: each firstChild ] ].  ^self setSelectedMorph: nilprivateSetContents: newContents  | scanner |  contents := newContents isText ifTrue: [ scanner := StringMorphAttributeScanner new initializeFromStringMorph: self.        (newContents attributesAt: 1 forStyle: self font textStyle) do: [:attr |  attr emphasizeScanner: scanner ].        emphasis := scanner emphasis.        font := scanner font emphasis: emphasis.        color := scanner textColor.        newContents string ] ifFalse: [ contents = newContents ifTrue: [ ^self ].        newContents ]isBrick  ^falsenewString: aStringOrText style: aStyle  ^self theme newStringIn: self label: aStringOrText font: self theme labelFont style: aStyledoScrollByPage  (self waitForDelay1: 300 delay2: 100) ifFalse: [ ^self ].  nextPageDirection ifTrue: [ self setValue: (value + pageDelta min: 1.0) ] ifFalse: [ self setValue: (value - pageDelta max: 0.0) ]autoAction  ^firstClickedMorph ifNotNil: [ firstClickedMorph selected ifTrue: [ #addToSelection: ] ifFalse: [ #removeFromSelection: ] ]isRowIndexSelected: anIndex  self deprecated: 'Use #isIndexSelected: instead' transformWith: '`@receiver isRowIndexSelected: `@statements1' -> '`@receiver isIndexSelected: `@statements1'.  ^self isIndexSelected: anIndexextent: aPoint  | delta |  self bounds extent = aPoint ifTrue: [ ^self ].  delta := (aPoint - self extent) // 2.  self fillStyles do: [:fs |  fs isOrientedFill ifTrue: [ fs origin: fs origin + delta ] ].  super extent: aPointdefaultWorldColor  ^self class defaultWorldColortable  ^self ownerdefaultTreeMorph  ^super defaultTreeMorph     multiSelection: true;     autoMultiSelection: true;     yourselfnormalFillStyle  ^self theme scrollbarNormalFillStyleFor: selfresetAlpha  alpha := 1.0selector: anObject  selector := anObjectbasicTaskThumbnailOfSize: thumbExtent  ^super taskThumbnailOfSize: thumbExtentminExtentOf: aMorph in: newBounds  | props extent |  cachedMinExtent ifNotNil: [ ^cachedMinExtent ].  aMorph submorphs ifEmpty: [ ^aMorph minWidth @ aMorph minHeight ].  extent := 0 @ 0.  cachedMinExtents := aMorph submorphs collect: [:m |  | min |        min := m minExtent.        extent := (extent x + min x) @ (extent y max: min y).        min ].  props := aMorph assureTableProperties.  ^cachedMinExtent := extent + (((aMorph submorphs size - 1) * (props cellInset isPoint ifTrue: [ props cellInset x ] ifFalse: [ props cellInset ])) @ 0)wantsToBeTopmost  ^trueselectionFrame  | frame |  frame := self bounds: self bounds in: container.  frame := self bounds: ((frame left: container innerBounds left) right: container innerBounds right) from: container.  ^framemodifierString  | string |  string := ''.  self commandKeyPressed ifTrue: [ string := string , 'CMD ' ].  self shiftPressed ifTrue: [ string := string , 'SHIFT ' ].  self controlKeyPressed ifTrue: [ string := string , 'CTRL ' ].  ^stringlast  ^lastIndexboundsWithinCorners  ^self bounds insetBy: 2actionSelector  ^actionSelectorgetListSizeSelector: aSelector  self dataSource getListSizeSelector: aSelectorreleaseCachedState  super releaseCachedState.  lastSketchForm := lastFormShown := nilinitializeWithHorizontalScrollBar  horizontalScrollBar := true.  self initializenewToolbar: controls  ^self theme newToolbarIn: self for: controlsupdateFont  self tabs do: [:t |  t font: self font ].  self updateTabstestAsLayoutFrame  | frame |  frame := #(0.66 0.5 1 0.77 1 2 3 25) asLayoutFrame.  self assert: frame leftFraction equals: 0.66.  self assert: frame topFraction equals: 0.5.  self assert: frame leftOffset equals: 1.  self assert: frame topOffset equals: 2.  self assert: frame rightFraction equals: 1.  self assert: frame bottomFraction equals: 0.77.  self assert: frame rightOffset equals: 3.  self assert: frame bottomOffset equals: 25measureContents  | f |  f := self fontToUse.  ^(((f widthOfString: contents) max: self minimumWidth) @ f height + (self layoutInset * 2)) ceilingstopStepping: aMorph selector: aSelector  lastStepMessage ifNotNil: [ (lastStepMessage receiver == aMorph and: [ lastStepMessage selector == aSelector ]) ifTrue: [ lastStepMessage := nil ] ].  stepList removeAll: (stepList select: [:stepMsg |  stepMsg receiver == aMorph and: [ stepMsg selector == aSelector ] ])newImage: aForm  ^self theme newImageIn: self form: aFormrowIndexFrom: anIndex  ^anIndex firstis: anIndex afterColumn: aColumnIndex  ^falseaddGraphicalHandle: formKey at: aPoint on: eventName send: selector to: recipient  | handle |  handle := self addGraphicalHandleFrom: formKey at: aPoint.  handle on: eventName send: selector to: recipient.  handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.  ^handlecharacterBlockAtPoint: aPoint  | line |  line := lines at: (self lineIndexForPoint: aPoint).  ^(CharacterBlockScanner new text: text textStyle: textStyle) characterBlockAtPoint: aPoint index: nil in: linepageSize: aPageSize  self pager ifNil: [ aPageSize ifNotNil: [ self addNavigationPane: (MorphTreePager on: self pageSize: aPageSize) ] ] ifNotNil: [ aPageSize ifNil: [ self removePager ] ifNotNil: [ self pager changePageSize: aPageSize ] ]label  ^labelopenAsIsIn: aWorld  super openAsIsIn: aWorld.  self allMorphs do: [:m |  m layoutChanged ]morph  ^morphanimateClose  | smallRect restoredRect rects steps |  self isMinimized ifTrue: [ ^self ].  restoredRect := self bounds.  smallRect := restoredRect scaledAndCenteredIn: (0 @ 0 extent: 20 @ 20).  smallRect := smallRect align: smallRect center with: restoredRect center.  steps := self theme numberOfStepsForAnimations.  rects := ((steps - 1) / steps to: 0 by: -1 / steps) collect: [:x |  smallRect interpolateTo: restoredRect at: ((20 raisedTo: x) - 1) / 19 ].  self currentWorld displayWorldSafely.  self fastAnimateRectangles: rectstextStyle  ^textStylecontainsPoint: aPoint  ^self bounds containsPoint: aPointcollapsedButton  ^self defaultButton     actionSelector: #expandItem;     labelGraphic: Smalltalk ui theme treeUnexpandedForm;     helpText: 'Expand Item';     yourselfupdateScrollbars  self     vUpdateScrollbar;     hUpdateScrollbar;     setScrollDeltashasExtension  ^extension notNilrowMorphAt: anIndex  ^self submorphs seconds submorphs at: anIndexselectableIndexBefore: anIndex  ^{anIndex first .   (anIndex second - 1)}stringBoundsToUse  ^self bounds left: self left + 4privateInvalidateMorph: aMorph  aMorph fullBounds.  aMorph changedhalosEnabled  ^self class halosEnabledselectedNodes  ^self lastSelectedNode ifNotNil: [:l |  OrderedCollection with: l ] ifNil: [ OrderedCollection new ]downImage  ^self class arrowOfDirection: (bounds isWide ifTrue: [ #right ] ifFalse: [ #bottom ]) size: (self buttonExtent x min: self buttonExtent y) color: self buttonImageColorlineIndexForCharacter: index  ^(self fastFindFirstLineSuchThat: [:line |  line first > index ]) - 1 max: 1basicGetListElementSelector: aSelector  self getListElementSelector: aSelectornewFuzzyLabel: aString  ^self theme newFuzzyLabelIn: self for: nil label: aString offset: 1 alpha: 0.5 getEnabled: niladdDupHandle: haloSpec  self addHandle: haloSpec on: #mouseDown send: #doDup:with: to: selfuserString  ^String streamContents: [:strm |  1 to: self getListSize do: [:i |  strm                 nextPutAll: (self getListItem: i);                 cr ] ]registerBarActions  toolbar     when: #tabSelected send: #tabSelected: to: self;     when: #barDeleted send: #barDeleted: to: self;     when: #tabsChanged send: #tabsChanged to: self;     when: #tabRefreshed send: #tabRefreshed: to: self;     when: #tabAddedToSelection send: #tabAddedToSelection: to: self;     when: #tabRemovedFromSelection send: #tabRemovedFromSelection: to: self;     when: #tabResetSelection send: #tabResetSelection: to: self;     when: #tabEmptyContents send: #tabEmptyContents: to: selfhelpText: aString  self setBalloonText: aStringnewBalloonHelp: aTextStringOrMorph for: aMorph  ^self theme newBalloonHelpIn: self contents: aTextStringOrMorph for: aMorph corner: #bottomLeftbeMultiple  self listManager multipleSelection: truehaloEnclosesFullBounds  ^self class haloEnclosesFullBoundselementsForTestDataSource  ^#(2 4 7 1 5 8 6 9 10 3)updateUpButtonImage  upButton removeAllMorphs.  upButton addMorphCentered: (ImageMorph new form: self upImage)bottomLeftCorner  ^self intersectionWithLineSegmentFromCenterTo: bounds bottomLeftfont  self textStyle fonts ifEmpty: [ ^TextStyle defaultFont ].  ^self textStyle defaultFonthorizontal  ^self orientation == #horizontalon: anObject selected: getSelectionSel changeSelected: setSelectionSel  self     model: anObject;     getStateSelector: getSelectionSel;     setStateSelector: setSelectionSel;     updateSelectionopenInWorld  self openInWorld: self currentWorldextraSelectionChanged  refreshExtraSelection := trueshowWhenNeeded  self showState: #whenNeededenabled: aBoolean  enabled := aBoolean.  self submorphsDo: [:sm |  sm allMorphsDo: [:m |  (m respondsTo: #enabled:) ifTrue: [ m enabled: aBoolean ] ] ].  self changed: #enabled.  self changedicon: anObject  icon ifNotNil: [ self removeMorph: icon ].  icon := anObject asAlphaImageMorph.  anObject ifNotNil: [ self addMorphFront: icon.        self adjustLayoutBounds ]model: anObject  model ifNotNil: [ model removeDependent: self ].  anObject ifNotNil: [ anObject addDependent: self ].  model := anObjectnewTabGroup: labelsAndPages  ^self theme newTabGroupIn: self for: labelsAndPageslock  self lock: truescrollPageInit: evt  self resetTimer.  self setNextDirectionFromEvent: evt.  self scrollBarAction: #doScrollByPage.  self doScrollByPage.  pagingArea     fillStyle: self pressedFillStyle;     borderStyle: self pressedBorderStyle.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nilacceptDroppingMorph: aMorph event: evt  self addMorphFront: aMorph fromWorldPosition: aMorph positionaddTitle: aString  self buildTitle: [:tm |  tm title: aString ]labelGap  ^2showColumnHeaders  showColumnHeaders ifTrue: [ ^self ].  showColumnHeaders := true.  self refreshsmall  ^15fullRepaintNeeded  worldState doFullRepaint.  self windowsSatisfying: [:w |  w makeMeVisible.        false ]depth: anObject  depth := anObjectcenteredAlert: aStringOrText title: aString configure: aBlock  ^self theme centeredAlertIn: self text: aStringOrText title: aString configure: aBlockdrawErrorOn: aCanvas  aCanvas frameAndFillRectangle: bounds fillColor: Color red borderWidth: 1 borderColor: Color yellow.  aCanvas line: bounds topLeft to: bounds bottomRight width: 1 color: Color yellow.  aCanvas line: bounds topRight to: bounds bottomLeft width: 1 color: Color yellow.  self valueOfProperty: #drawError ifPresentDo: [:error |  | trace stringBounds |        trace := String streamContents: [:s |  error signalerContext shortDebugStackOn: s ].        stringBounds := bounds insetBy: 5.        trace linesDo: [:aString |  aCanvas drawString: aString in: stringBounds.              stringBounds := stringBounds top: stringBounds top + (TextStyle defaultFont pixelSize * 1.2) ] ]setIndexSelector  ^setIndexSelectorselectRow: index  selectedRows add: index.  self invalidRect: (self drawBoundsForRow: index)testNilExtensionOnDraw  | morph |  morph := Morph new.  self assert: morph hasExtension not.  morph imageForm.  self assert: morph hasExtension notanimationForMoveSuccess: success  | start stop slideForm |  success ifTrue: [ ^self ] ifFalse: [ start := self fullBounds origin.        stop := self formerPosition ifNil: [ self source bounds origin ] ].  start = stop ifTrue: [ ^self ].  slideForm := self imageForm offset: 0 @ 0.  slideForm slideWithFirstFrom: start to: stop nSteps: 12 delay: 20normalButtonFillStyle  ^self theme scrollbarNormalButtonFillStyleFor: selfthemeChanged  super themeChanged.  self subMenu ifNotNil: [:m |  m themeChanged ]nextDuplicateVertexIndex  vertices doWithIndex: [:vert :index |  ((index between: 2 and: vertices size - 1) and: [ | epsilon v1 v2 |              v1 := vertices at: index - 1.              v2 := vertices at: index + 1.              epsilon := ((v1 x - v2 x) abs max: (v1 y - v2 y) abs) // 32 max: 1.              vert onLineFrom: v1 to: v2 within: epsilon ]) ifTrue: [ ^index ] ].  ^0getChildrenSelector: aSymbol  getChildrenSelector := aSymboltable  ^tablelineColorBlock: aValuable  lineColorBlock := aValuablecursorWrapped: aNumber  self setProperty: #textCursorLocation toValue: (aNumber rounded - 1) \\ text string size + 1center: targetMorph with: anotherMorph  self topOffset: (anotherMorph height - targetMorph height) // 2.  self leftOffset: (anotherMorph width - targetMorph width) // 2defaultBalloonFont  ^BalloonMorph balloonFontenabled: aBoolean  self sliderMorph ifNotNil: [:sm |  sm enabled: aBoolean ].  self     changed: #enabled;     changed: #minEnabled;     changed: #maxEnabledmouseUp: evt  evt hand showTemporaryCursor: nil.  self updateSelectedLocation.  self locationMorph visible: trueblueButtonChanged  ^whichButton anyMask: self class blueButtoncollapseAll: aMorph  | allChildren |  aMorph toggleExpandedState.  allChildren := OrderedCollection new: 10.  aMorph recursiveAddTo: allChildren.  allChildren do: [:each |  each isExpanded ifTrue: [ self collapseAll: each ] ]closeAllWindowsDiscardingChanges  self currentWorld systemWindows do: [:w |  [ w delete ] valueSupplyingAnswer: false ]initialize  super initialize.  hands := Array new.  damageRecorder := DamageRecorder new.  stepList := Heap sortBlock: self stepListSortBlock.  lastStepTime := 0.  lastAlarmTime := 0rootNodeClassFromItem: anItem  ^MorphTreeNodeModellimit  ^limitmouseOverBorderStyle  ^self theme buttonMouseOverBorderStyleFor: selfmakeForwardArrow  arrows := #forward.  self computeBoundspressedFillStyle  ^self theme splitterPressedFillStyleFor: selfwindowIndex  ^windowIndexremoveTopHeader  topHeader ifNotNil: [ self removeMorph: topHeader.        topHeader := nil ]checkMorphsLeftOrTopFrom: splitter size: size  | index |  index := submorphs identityIndexOf: splitter.  index := index + 1.  [ index <= size ] whileTrue: [ | submorph done |        submorph := submorphs at: index.        splitter addLeftOrTop: submorph.        done := self isResizeableMorph: submorph forSplitter: splitter.        done ifTrue: [ index := size + 1 ].        index := index + 1 ]labelMorph  ^labelMorphaddCustomMenuItems: aCustomMenu hand: aHandMorph  super addCustomMenuItems: aCustomMenu hand: aHandMorph.  aCustomMenu addLine.  aCustomMenu add: 'Edit label...' selector: #relabelinspectItem  self inspectkeyStroke: anEvent from: aTreeMorph  | c |  c := anEvent keyCharacter.  c = $b ifTrue: [ self browseItem.        ^true ].  c = $i ifTrue: [ self inspectItem.        ^true ].  c = $I ifTrue: [ self exploreItem.        ^true ].  ^falseaddIndendtation: aNumber  indentation := indentation + aNumber + self cellInsetaddChildrenForList: hostList addingTo: morphList withExpandedItems: expandedItems  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aNode delete ] ].  firstChild := nil.  complexContents hasContents ifFalse: [ ^self ].  firstChild := hostList addMorphsTo: morphList from: complexContents contents allowSorting: true withExpandedItems: expandedItems atLevel: indentLevel + 1newOverflowRowForAll: aCollectionOfMorphs  ^self theme newOverflowRowIn: self forAll: aCollectionOfMorphsmorph  ^morphdrawToggleOn: aCanvas in: aRectangle  | aForm centeringOffset |  complexContents hasContents ifFalse: [ ^self ].  aForm := isExpanded ifTrue: [ container expandedFormForMorph: self ] ifFalse: [ container notExpandedFormForMorph: self ].  centeringOffset := ((aRectangle height - aForm extent y) / 2.0) truncated.  ^aCanvas translucentImage: aForm at: (aRectangle topLeft translateBy: 0 @ centeringOffset)addToggleItemsToHaloMenu: aMenu  #(#(#resistsRemovalString #toggleResistsRemoval 'whether I should be reistant to easy deletion via the pink X handle' true) #(#stickinessString #toggleStickiness 'whether I should be resistant to a drag done by mousing down on me' true) #(#lockedString #lockUnlockMorph 'when "locked", I am inert to all user interactions' true) #(#hasClipSubmorphsString #changeClipSubmorphs 'whether the parts of objects within me that are outside my bounds should be masked.' false) #(#hasDirectionHandlesString #changeDirectionHandles 'whether direction handles are shown with the halo' false) #(#hasDragAndDropEnabledString #changeDragAndDrop 'whether I am open to having objects dropped into me' false)) do: [:each |  aMenu addUpdating: each first selector: each second.        aMenu balloonTextForLastItem: each third translated ].  self couldHaveRoundedCorners ifFalse: [ ^self ].  aMenu addUpdating: #roundedCornersString selector: #toggleCornerRounding.  aMenu balloonTextForLastItem: 'whether my corners should be rounded' translatednewMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newMorphDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpTextaddToggle: aString target: anObject selector: aSymbol  self addToggle: aString target: anObject selector: aSymbol getStateSelector: nil argumentList: EmptyArraymorphicLayerNumber  ^11visibleBounds  ^self header bounds withBottom: self container scroller bottomlayoutChanged  self computeBounds.  super layoutChangedbeCheckList  self isCheckList: trueselectedItems  ^selection ifNil: [ OrderedCollection new ] ifNotNil: [ selection selectedItems ]change: aTreeMorph  action ifNil: [ ^self ].  aTreeMorph perform: action withEnoughArguments: self argumentsremoveAllHandlesBut: aHandle  submorphs copy do: [:m |  m == aHandle ifFalse: [ m delete ] ]alwaysHideHScrollbar  ^self class alwaysHideHScrollbarminHeight  ^self fontToUse height max: super minHeightmodel  ^modeltarget: anObject  target := anObjectextent: aPoint  | result |  result := super extent: aPoint.  date notNil ifTrue: [ self computeDays ].  ^resulthandlesMouseDown: evt  ^self isEmbedded notrootClass: aClass  rootClass := aClasslabel: aString font: aFont  label ifNotNil: [ label delete ].  label := StringMorph contents: aString font: (aFont ifNil: [ StandardFonts buttonFont ]).  self extent: (label width + 6) @ (label height + 6).  label position: self center - (label extent // 2).  self addMorph: label.  label lockisMouseWheel  ^falsesetSelectionListSelector: getListSel  setSelectionListSelector := getListSeltopFraction: aNumber  topFraction := aNumberborderStyleToUse  ^self perform: (self availableBorderStyles at: (self interactionStates indexOf: self interactionState))transferFor: passenger from: aMorph  ^(self model transferFor: passenger from: self table) buildWithSpectestSelectAll  self subclassResponsibilityactiveHand  ^worldState activeHandhResizeScrollBar  | topLeft h |  (self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ]) ifTrue: [ ^self ].  bounds ifNil: [ self fullBounds ].  h := self scrollBarThickness.  topLeft := bounds bottomLeft + (borderWidth @ (h + borderWidth) negated).  hScrollBar bounds: (topLeft extent: self hScrollBarWidth @ h)green: anInteger  | c |  c := self selectedColor.  self selectedColor: ((Color r: c red * 255 g: anInteger b: c blue * 255 range: 255) alpha: c alpha)listSpacing  ^listSpacingdisabledFillStyle  ^self theme buttonDisabledFillStyleFor: selfinitializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigationverticalScrollBarWidth  self isVerticalScrollBarVisible ifFalse: [ ^0 ].  ^self scrollBarThicknesssetSelectedMorph: aNodeMorph  self listManager setSelectedMorph: aNodeMorphisSortEnabled  ^self sortingStrategy isSortingEnablednewHScrollbar  ^GeneralScrollBar new     model: self;     setValueSelector: #hScrollbarValue:closeBoxHit  self allowedToClose ifFalse: [ ^self ].  self playCloseSound.  self closescheduledTime  ^scheduledTimetitle: aString  super title: aString.  label fitContents.  self minimumExtent: ((label width + 20 min: Display width // 2) max: self minimumExtent x) @ self minimumExtent ygetEnabledSelector: aSymbol  getEnabledSelector := aSymbol.  self updateEnabledindicateModalChildForMorph: aMorph  (self buttonForMorph: aMorph) ifNotNil: [:b |  b indicateModalChild ]blueButtonDown: anEvent  | h tfm doNotDrag |  h := anEvent hand halo.  doNotDrag := false.  h ifNotNil: [ h innerTarget == self ifTrue: [ doNotDrag := true ].        (h innerTarget hasOwner: self) ifTrue: [ doNotDrag := true ].        (self hasOwner: h target) ifTrue: [ doNotDrag := true ] ].  tfm := (self transformedFrom: nil) inverseTransformation.  h := self addHalo: (anEvent transformedBy: tfm).  h ifNil: [ ^self ].  doNotDrag ifTrue: [ ^self ].  anEvent hand waitForClicksOrDrag: h event: (anEvent transformedBy: tfm) selectors: {nil .         nil .         nil .         #dragTarget:} threshold: 5.  anEvent hand newMouseFocus: hchooseAlignment  self editor changeAlignment.  self updateFromParagraphcheckSession  handlesMouseOver: evt  ^self mouseOverAllowednotOnFirstPage  ^self onFirstPage notstop: stopInteger  lastIndex := stopIntegersetOptimalResizing  self hResizing: #rigid.  self vResizing: #rigidoffColor: aColor  offColor := aColordefaultDesktopCommandKeyTriplets  self flag: #problem.  ^{{$r .   self currentWorld .   #restoreMorphicDisplay .   'Redraw the screen'} .   {$b .   Smalltalk tools browser .   #open .   'Open a new System Browser'} .   {$k .   Smalltalk tools workspace .   #open .   'Open a new, blank Workspace'} .   {$t .   Smalltalk tools transcript .   #open .   'Make a System Transcript visible'} .   {$W .   Smalltalk tools finder .   #open .   'Open a new Finder'} .   {$Z .   Smalltalk tools changeList .   #browseRecentLog .   'Browse recently-logged changes'} .   {$\ .   SystemWindow .   #sendTopWindowToBack .   'Send the top window to the back'}}getSelectionListSelector: aSelector  getSelectionListSelector := aSelectorisEasySelecting  ^falsefield  ^fieldisPartialMatch  | result |  result := false.  self contents do: [:each |  (each selected or: [ each isPartialMatch ]) ifTrue: [ result := true ] ].  ^resultchangeLayoutInset: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self layoutInset: (newPoint - evt cursorPoint) asIntegerPoint // 5 ].  evt hand attachMorph: handle.  handle startSteppingvUnadjustedScrollRange  scroller submorphs size > 0 ifFalse: [ ^0 ].  ^scroller submorphs last fullBounds bottomremoveAllMorphsIn: aCollection  | set myWorld |  set := IdentitySet new: aCollection size * 4 // 3.  aCollection do: [:each |  each owner == self ifTrue: [ set add: each ] ].  myWorld := self world.  (fullBounds notNil or: [ myWorld notNil ]) ifTrue: [ self invalidRect: self fullBounds ].  set do: [:m |  myWorld ifNotNil: [ m outOfWorld: myWorld ].        m privateOwner: nil ].  submorphs := submorphs reject: [:each |  set includes: each ].  set do: [:m |  self removedMorph: m ].  self layoutChangedmouseOverFillStyle  ^self theme scrollbarMouseOverFillStyleFor: selfnewButtonMorph  | instance |  instance := TickSelectionCheckboxButtonMorph new     target: self;     actionSelector: #toggleSelected;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap.  instance index: index.  ^instanceenabled: aBoolean  enabled = aBoolean ifTrue: [ ^self ].  enabled := aBoolean.  self updateLabelEnablement.  self changeddismissMorph: evt  self dismissMorphtestSelectFirst  table selectFirst.  self assert: table selectedIndexes equals: #(1)pressedFillStyle  ^self theme controlButtonPressedFillStyleFor: selfselectedRowIndex: aNumber  self deprecated: 'Use #selectedIndex: instead' transformWith: '`@receiver selectedRowIndex: `@statements1' -> '`@receiver selectedIndex: `@statements1'.  self selectedIndex: aNumberextent: newExtent  super extent: newExtent.  self listMorph width: (self innerBounds width max: listMorph hUnadjustedScrollRange)selectIndex: rowIndex event: event  self subclassResponsibilityisHandMorph  ^truecolumnDropUnabled  ^columnDropUnabled ifNil: [ columnDropUnabled := false ]mouseDown: anEvent  | cp |  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: anEvent cursorPoint) ifTrue: [ oldColor := self color.        self setGrabbedColor ].  cp := anEvent cursorPoint.  lastMouse := {cp .   (cp - self position)}kmDispatcher  ^self valueOfProperty: #kmDispatcher ifAbsentPut: [ | kmd |        kmd := KMDispatcher target: self.        self initializeShortcuts: kmd.        kmd ]previousMorphWantingFocus  | m |  m := self previousMorphInWindow ifNil: [ ^nil ].  [ m = self or: [ m wantsKeyboardFocusNavigation ] ] whileFalse: [ m := m previousMorphInWindow ifNil: [ ^nil ] ].  ^m wantsKeyboardFocusNavigation ifTrue: [ m ]top  | outerWidth |  outerWidth := minWidth + (2 * OuterMargin).  ^(self vertProfile findFirst: [:count |  count >= outerWidth ]) - 1 + shadowForm offset ychooseFileName: title extensions: exts path: path preview: preview  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: title extensions: exts path: path preview: previewdrawBackgroundForSearchedRow: row on: aCanvas  self drawBackgroundForRow: row on: aCanvas color: listSource secondarySelectionColorcleanseStepListForWorld: aWorld  | deletions morphToStep |  deletions := nil.  stepList do: [:entry |  morphToStep := entry receiver.        morphToStep world == aWorld ifFalse: [ deletions ifNil: [ deletions := OrderedCollection new ].              deletions addLast: entry ] ].  deletions ifNotNil: [ deletions do: [:entry |  self stopStepping: entry receiver ] ].  self alarms copy do: [:entry |  morphToStep := entry receiver.        (morphToStep isMorph and: [ morphToStep world == aWorld ]) ifFalse: [ self removeAlarm: entry selector for: entry receiver ] ]chunkSizeFromString: aString  | input newPageSize |  input := aString asString trimBoth.  input ifEmpty: [ treeMorph flash.        ^false ].  newPageSize := Integer readFromString: input.  newPageSize > 0 ifTrue: [ self changePageSize: newPageSize.        self nextPage.        pageSizeEditor ifNotNil: [ pageSizeEditor takeKeyboardFocus ] ] ifFalse: [ treeMorph flash.        ^false ].  ^truehsvMorph: anObject  hsvMorph := anObjectelementsForTestDataSource  ^#(2 4 7 1 5 8 6 9 10 3)listDirection: aSymbol  self assureTableProperties listDirection: aSymbol.  self layoutChangedpaneColorOrNil  ^self valueOfProperty: #paneColor ifAbsent: [ (self owner ifNil: [ ^nil ]) paneColorOrNil ]refreshContent  morph := nil.  self triggerEvent: #tabEmptyContents with: self.  self softRetrieveMorphdeselectTimeOut: evt  owner selectedItem == self ifTrue: [ evt hand newMouseFocus: owner.        owner selectItem: nil event: evt ]colorAt: aPoint  ^self isInWorld ifTrue: [ (Display colorAt: aPoint) beOpaque ] ifFalse: [ Color black ]veryDeepInner: deepCopier  super veryDeepInner: deepCopier.  label := label veryDeepCopyWith: deepCopier.  icon := icon veryDeepCopyWith: deepCopier.  shortcutCharacter := shortcutCharacter veryDeepCopyWith: deepCopier.  askBeforeChanging := askBeforeChanging veryDeepCopyWith: deepCopier.  triggerOnMouseDown := triggerOnMouseDown veryDeepCopyWith: deepCopier.  offColor := offColor veryDeepCopyWith: deepCopier.  onColor := onColor veryDeepCopyWith: deepCopier.  feedbackColor := feedbackColor veryDeepCopyWith: deepCopier.  showSelectionFeedback := showSelectionFeedback veryDeepCopyWith: deepCopier.  allButtons := nil.  arguments := arguments veryDeepCopyWith: deepCopier.  argumentsProvider := argumentsProvider veryDeepCopyWith: deepCopier.  argumentsSelector := argumentsSelectorthemeChanged  self     layoutInset: (self theme buttonLabelInsetFor: self);     cornerStyle: (self theme buttonCornerStyleIn: self window);     borderStyle: (self theme buttonNormalBorderStyleFor: self).  (self labelMorph isNil or: [ self label isMorph ]) ifFalse: [ self label: self label font: self labelMorph font.        self labelMorph color: self theme textColor ].  super themeChangedwidthToDisplayInTree: aTree  ^self minExtent xoutOfWorld: aWorld  aWorld ifNil: [ ^self ].  super outOfWorld: aWorld.  outOfWorldCount := outOfWorldCount + 1addCornerGrips  | tl tr lh |  lh := self labelHeight.  tl := TopLeftGripMorph new     target: self;     position: self position.  tl layoutFrame topOffset: lh negated.  tr := TopRightGripMorph new     target: self;     position: self position.  tr layoutFrame topOffset: lh negated.  self     addMorph: tl;     addMorph: tr;     addMorph: (BottomLeftGripMorph new           target: self;           position: self position);     addMorph: (BottomRightGripMorph new           target: self;           position: self position)keyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self focusChangedaddCustomMenuItems: aCustomMenu hand: aHandMorph  super addCustomMenuItems: aCustomMenu hand: aHandMorph.  aCustomMenu addLine.  aCustomMenu add: 'add title...' selector: #addTitle.  aCustomMenu add: 'set target...' selector: #setTarget:.  defaultTarget ifNotNil: [ aCustomMenu add: 'add item...' selector: #addItem ].  aCustomMenu add: 'add line' selector: #addLine.  (self items anySatisfy: [:any |  any hasSubMenu ]) ifTrue: [ aCustomMenu add: 'detach submenu' selector: #detachSubMenu: ]anchoredMorph: aMorph  anchoredMorph := aMorphgetListSize  | l |  getListSizeSelector ifNotNil: [ ^model perform: getListSizeSelector ].  l := self getList.  l isEmpty ifTrue: [ ^0 ].  ^l sizetransformFrom: uberMorph  (self == uberMorph or: [ owner isNil ]) ifTrue: [ ^transform ].  ^(owner transformFrom: uberMorph) composedWithLocal: transformnewButtonLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newButtonLabelIn: self for: aModel label: aString getEnabled: enabledSelforwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]data  ^datafirstName  ^self item firstNametabGroup  ^tabGroupsetDefaultLabel  self label: self defaultLabeldoubleClick  self selectedNode ifNotNil: [:n |  n doubleClick ]browseItem  vScrollBarValue: scrollValue  resumeAfterDrawError  self changed.  self removeProperty: #errorOnDraw.  self removeProperty: #drawError.  self changedpotentialTargetsAt: aPoint  | realOwner |  realOwner := self topRendererOrSelf owner ifNil: [ ^#() ].  ^realOwner morphsAt: aPointforbidColumnDrop  columnDropUnabled := falsesortingIcon  ^self context morphicIconNamed: #arrowDownupdateLayout  labelMorph contents isEmpty ifFalse: [ self addMorphBack: labelMorph ].  self addMorphBack: barselectionChangedUpdateIndex: ann  self setIndexSelector ifNil: [ ^self ].  self model perform: self setIndexSelector with: (ann newSelectedIndexes ifNotEmpty: [:indexes |  indexes first ] ifEmpty: [ 0 ])sortFunction  ^sortFunctionaddPaneSplitters  | splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |  self removePaneSplitters.  self removeCornerGrips.  remaining := submorphs reject: [:each |  each layoutFrame rightFraction = 1 ].  [ remaining notEmpty ] whileTrue: [ target := remaining first.        targetX := target layoutFrame rightFraction.        sameX := submorphs select: [:each |  each layoutFrame rightFraction = targetX ].        minY := (sameX detectMin: [:each |  each layoutFrame topFraction ]) layoutFrame topFraction.        maxY := (sameX detectMax: [:each |  each layoutFrame bottomFraction ]) layoutFrame bottomFraction.        splitter := ProportionalSplitterMorph new.        splitter layoutFrame: ((targetX @ minY corner: targetX @ maxY) asLayoutFrame                 leftOffset: target layoutFrame rightOffset;                 topOffset: target layoutFrame topOffset;                 rightOffset: 4 + target layoutFrame rightOffset;                 bottomOffset: target layoutFrame bottomOffset).        self addMorphBack: (splitter position: self position).        remaining := remaining copyWithoutAll: sameX ].  remaining := submorphs copy reject: [:each |  each layoutFrame bottomFraction = 1 ].  [ remaining notEmpty ] whileTrue: [ target := remaining first.        targetY := target layoutFrame bottomFraction.        sameY := submorphs select: [:each |  each layoutFrame bottomFraction = targetY ].        minX := (sameY detectMin: [:each |  each layoutFrame leftFraction ]) layoutFrame leftFraction.        maxX := (sameY detectMax: [:each |  each layoutFrame rightFraction ]) layoutFrame rightFraction.        splitter := ProportionalSplitterMorph new           beSplitsTopAndBottom;           yourself.        splitter layoutFrame: ((minX @ targetY corner: maxX @ targetY) asLayoutFrame                 leftOffset: target layoutFrame leftOffset;                 topOffset: target layoutFrame bottomOffset;                 rightOffset: target layoutFrame rightOffset;                 bottomOffset: 4 + target layoutFrame bottomOffset).        self addMorphBack: (splitter position: self position).        remaining := remaining copyWithoutAll: sameY ].  self linkSubmorphsToSplitters.  self splitters do: [:each |  each comeToFront ]obtainHalo: aHalo  self halo == aHalo ifTrue: [ ^self ].  self world hands detect: [:hand |  hand halo == aHalo ] ifFound: [:formerOwner |  formerOwner releaseHalo: aHalo ].  self halo: aHalosortWith: aSortFunction  self sortElements: aSortFunction.  self table refreshbuttonLabel: aLabel actionSelector: aSelector arguments: aCollection getEnabled: enableSelector help: helpText  | b |  b := (aLabel isString ifTrue: [ self basicButton ] ifFalse: [ self basicIcon ])     actionSelector: aSelector;     arguments: aCollection;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     setBalloonText: helpText;     yourself.  aLabel isString ifTrue: [ b label: aLabel font: self preferedFont ] ifFalse: [ | f |        f := (enableSelector isNil or: [ self perform: enableSelector ]) ifTrue: [ aLabel ] ifFalse: [ b lock.              self asDisabledForm: aLabel ].        b labelGraphic: f ].  ^binitialize  self basicSelectedColor: Color blue.  super initialize.  self selectedColor: self selectedColorchanged  | msRefreshRate isTimeForRefresh |  msRefreshRate := 60.  isTimeForRefresh := Time millisecondClockValue - self lastRefresh >= msRefreshRate.  (self isInWorld and: [ isTimeForRefresh ]) ifTrue: [ super changed ]testTestTime  | t |  cases := {(t := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ self assert: true ]scrollBounds  | b |  b := self innerBounds.  self vScrollbarNeeded ifTrue: [ b := b right: b right - self scrollBarThickness ].  self hScrollbarNeeded ifTrue: [ b := b bottom: b bottom - self scrollBarThickness ].  ^bathensDrawBackgroundForRow: row on: aCanvas color: aColor  aCanvas setPaint: aColor.  aCanvas drawShape: (self selectionFrameForRow: row)layoutChanged  | layout |  fullBounds := nil.  layout := self layoutPolicy.  layout ifNotNil: [ layout flushLayoutCache ].  owner ifNotNil: [ owner layoutChanged ]removeTab: aTab  | nextSelection |  (aTab selected and: [ selectionHistory size > 1 ]) ifTrue: [ nextSelection := selectionHistory at: selectionHistory size - 1.        nextSelection selected: true ].  self removeFromHistory: aTab.  tabs remove: aTab.  self adjustLayoutweekdayFont  ^LogicalFont familyName: 'Bitmap DejaVu Sans' pointSize: 9balloonTextForLastItem: balloonText  submorphs last setBalloonText: balloonTexthasChanged  ^hasChanged ifNil: [ true ]hasIcon  ^container hasIconBlock or: [ self complexContents icon notNil ]initializeLayout  self     changeTableLayout;     layoutInset: 6;     listDirection: #topToBottom;     cellPositioning: #topRight;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     cellInset: 0preferredColor  ^niltopBoundary  | morphs |  morphs := leftOrTop reject: [:m |  m layoutFrame topFraction ~= 0 and: [ m layoutFrame topFraction = m layoutFrame bottomFraction ] ].  morphs ifEmpty: [ ^(self splitterAbove ifNil: [ self containingWindow panelRect top ] ifNotNil: [:s |  s first top ]) + 25 ].  ^(morphs collect: [:m |  m top + m minExtent y + (self layoutFrame topOffset ifNil: [ 0 ]) - (m layoutFrame bottomOffset ifNil: [ 0 ]) ]) maxaddUpdating: aWordingSelector target: aTarget selector: aSymbol  self addUpdating: aWordingSelector target: aTarget selector: aSymbol argumentList: EmptyArraycontentMorph  ^self submorphs firstflash  ^editView flashinitializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigation.  aKMDispatcher attachCategory: #PluggableButtonMorphreplaceSubmorph: oldMorph by: newMorph  | index itsPosition w |  oldMorph stopStepping.  itsPosition := oldMorph referencePositionInWorld.  index := submorphs indexOf: oldMorph.  oldMorph privateDelete.  self privateAddMorph: newMorph atIndex: index.  newMorph referencePositionInWorld: itsPosition.  (w := newMorph world) ifNotNil: [ w startSteppingSubmorphsOf: newMorph ]setGrabbedColor  self fillStyle: self pressedFillStyleemphasis  ^emphasisfont  ^fonthResizing: aSymbol  hResizing := aSymbolbindKeyCombination: aShortcut toAction: anAction  self kmDispatcher bindKeyCombination: aShortcut asKeyCombination toAction: anActionactivateCursor: aCursor withMask: maskForm  aCursor beCursorWithMask: maskFormcolor: aColor  super color: aColor.  (image depth = 1 and: [ aColor isColor ]) ifTrue: [ image isColorForm ifFalse: [ image := ColorForm mappingWhiteToTransparentFrom: image ].        image colors: {Color transparent .               aColor}.        self changed ]initializeOtherProperties  otherProperties := SmallIdentityDictionary newtarget: aSystemWindow  target := aSystemWindow.  self color: (target paneColor alpha: 0.35).  self bounds: aSystemWindow bounds.  self currentHand newMouseFocus: selftreeMorph: aTreeMorph  treeMorph := aTreeMorphtabSelected: aTab  self setTabContentFrom: aTab.  self triggerEvent: #tabSelected with: aTabshiftedTextPaneMenuRequest  ^self yellowButtonActivity: truedrawLinesOn: aCanvas  self flag: #pharoTodoannounceOpened  self doAnnounce: (MorphOpened morph: self).  self submorphs do: #announceOpenedallowsCellSelection  ^truesearchText: aString  aString isEmptyOrNil ifTrue: [ ^#() ].  self elements withIndexDo: [:each :index |  (each name beginsWith: aString) ifTrue: [ ^{index} ] ].  ^#()adhereTo: edgeSymbol  (#(#left #top #right #bottom #none) includes: edgeSymbol) ifFalse: [ ^self error: 'invalid option' ].  self setToAdhereToEdge: edgeSymbol.  self updateLayoutProperties.  self updateColorscrollbarThickness  ^self theme scrollbarThicknessisMorphicModel  ^truenewSize: anObject  newSize := anObjectlastVisibleRowIndex  ^self exposedRows ifNotEmpty: [:rows |  rows keys last ] ifEmpty: [ 0 ]referencePosition  | box |  box := self bounds.  ^box origin + (self rotationCenter * box extent)balloonHelpTextForHandle: aHandle  (aHandle eventHandler mouseSelectorsInclude: #addOrRemoveItems:) ifTrue: [ ^'Add items to, or remove them from, this selection.' ].  ^super balloonHelpTextForHandle: aHandlebeCursorOwner  self class cursorOwnerWorld: selfaltKeyPressed  ^self optionKeyPressedstep  (self keepOpen not and: [ self activeHand anyModifierKeyPressed not ]) ifTrue: [ self done ]fullFrame  ^fullFramemouseDownInTitle: evt  evt hand grabMorph: selfdefaultTreeMorph  | col |  col := MorphTreeColumn new rowMorphGetSelector: [:node |  StringMorph contents: node item asString ].  self headerLabel ifNotNil: [ col headerButtonLabel: self headerLabel font: nil ].  ^(self treeMorphClass on: self)     columns: (Array with: col);     hResizing: #spaceFill;     vResizing: #spaceFill;     resizerWidth: 0;     columnInset: 0;     rowInset: 2;     keystrokeActionSelector: #keyStroke:;     multiSelection: self multiSelection;     autoMultiSelection: self autoMultiSelection;     itemStringGetter: [:item |  self wrapItem: item ];     isCheckList: self isCheckListtestSortDataSource  | dataSource |  dataSource := self dataSourceForTesting.  strategy sortFunction: #yourself ascending.  self assert: dataSource elements equals: self elementsForTestDataSource.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(10 9 8 7 6 5 4 3 2 1).  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: self elementsForTestDataSourcemidVertices  | midPts nextVertIx tweens |  vertices size < 2 ifTrue: [ ^vertices ].  midPts := OrderedCollection new.  nextVertIx := 2.  tweens := OrderedCollection new.  tweens add: vertices first asIntegerPoint.  self lineSegmentsDo: [:p1 :p2 |  tweens addLast: p2 asIntegerPoint.        p2 = (vertices atWrap: nextVertIx) ifTrue: [ midPts addLast: ((tweens atWrap: (tweens size + 1) // 2) + (tweens at: tweens size // 2 + 1)) // 2.              tweens := OrderedCollection new.              tweens add: p2 asIntegerPoint.              nextVertIx := nextVertIx + 1 ] ].  ^midPts asArrayinnerBounds  | inner |  inner := super innerBounds.  (submorphs includes: scrollBar) ifTrue: [ inner := inner topLeft corner: (inner right - scrollBar width) @ inner bottom ].  self hIsScrollbarShowing ifFalse: [ ^inner ] ifTrue: [ ^inner topLeft extent: inner extent - (0 @ self scrollBarThickness) ]chooseDirectory: title  ^self chooseDirectory: title path: nilenablementSelector  ^enablementSelectorpassiveDisabledNotOverUpFillStyle: aFillStyle  self stateMap atPath: #(passive disabled notOver up) put: aFillStyle.  self changedinnerWidgetChanged  self setScrollDeltas.  self updateColumnMorphsWidth.  self adjustSubmorphPositionscommentText  ^(self theme newTextIn: self currentWorld text: self item comment)     unlock;     wrapFlag: true;     yourselfselectionChanged  client selectionChangedfillStyleToUse  | map |  map := self active ifTrue: [ self stateMap at: #active ifAbsent: [ self stateMap at: #passive ifAbsent: [ Dictionary new ] ] ] ifFalse: [ self stateMap at: #passive ifAbsent: [ self stateMap at: #active ifAbsent: [ Dictionary new ] ] ].  map := self enabled ifTrue: [ map at: #enabled ifAbsent: [ map at: #disabled ifAbsent: [ Dictionary new ] ] ] ifFalse: [ map at: #disabled ifAbsent: [ map at: #enabled ifAbsent: [ Dictionary new ] ] ].  map := self over ifTrue: [ map at: #over ifAbsent: [ map at: #notOver ifAbsent: [ Dictionary new ] ] ] ifFalse: [ map at: #notOver ifAbsent: [ map at: #over ifAbsent: [ Dictionary new ] ] ].  ^map at: (self down ifTrue: [ #down ] ifFalse: [ #up ]) ifAbsent: [ map at: (self down ifTrue: [ #up ] ifFalse: [ #down ]) ifAbsent: [ Color transparent ] ]drawOn: aCanvas  | dotBounds size alphaCanvas dotSize |  self shouldDraw ifFalse: [ ^self ].  super drawOn: aCanvas.  self class showSplitterHandles ifTrue: [ size := self splitsTopAndBottom ifTrue: [ self handleSize transposed ] ifFalse: [ self handleSize ].        dotSize := self splitsTopAndBottom ifTrue: [ 6 @ self class splitterWidth ] ifFalse: [ self class splitterWidth @ 6 ].        alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.        dotBounds := Rectangle center: self bounds center extent: size.        alphaCanvas fillRectangle: dotBounds color: self handleColor.        dotBounds := Rectangle center: self bounds center extent: dotSize.        alphaCanvas fillRectangle: dotBounds color: self dotColor ]mouseOverHandler  ^mouseOverHandler ifNil: [ mouseOverHandler := MouseOverHandler new ]pattern: anObject  pattern := anObjectorderedTasks  ^orderedTasksnewCheckboxFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel getLabel: labelSel help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel getLabel: labelSel help: helpTexthScrollBarValue: scrollValue  | prev |  prev := scroller offset x.  super hScrollBarValue: scrollValue.  scroller offset x ~= prev ifTrue: [ self updateColumnResizersXOffset.        self updateTopHeader ]roots: anArray  roots := anArray collect: [:item |  PluggableTreeItemNode with: item model: self ].  self list: rootscellSpacing  ^cellSpacingstruckOut  self changeEmphasis: #struckOutsetDefaultColors  handleColor := Color lightGray lighter lighter.  dotColor := Color gray lighterperformAction: event  enabled ifFalse: [ ^self ].  askBeforeChanging ifTrue: [ model okToChange ifFalse: [ ^self ] ].  self actionBlock ifNotNil: [ ^self actionBlock cull: event ].  actionSelector ifNotNil: [ actionSelector numArgs = 0 ifTrue: [ model perform: actionSelector ] ifFalse: [ argumentsProvider ifNotNil: [ arguments := argumentsProvider perform: argumentsSelector ].              model perform: actionSelector withArguments: arguments ] ]bottomRight  ^right @ bottomselectLastPrefix: aString  | lastMatch |  self items reverseDo: [:item |  | match |        match := aString isEmpty or: [ item contents asString asLowercase beginsWith: aString ].        item isEnabled: match.        (match and: [ lastMatch isNil ]) ifTrue: [ lastMatch := item ] ].  ^lastMatchdown  ^downcheckRectangle  | tr |  tr := self toggleRectangle translateBy: 3 @ 0.  ^self mustTakeIntoAccountToggleSpace ifTrue: [ tr topRight + (self checkGap @ 0) corner: tr bottomRight + ((self checkGap + self checkWidth) @ 0) ] ifFalse: [ tr ]defaultIcon  ^self iconNamed: #blankIcondrawOnAthensCanvas: anAthensCanvas  | border shape stroke |  border := self borderStyle.  shape := self asAthensPathOn: anAthensCanvas.  self isClosed ifTrue: [ anAthensCanvas setPaint: self fillStyle.        anAthensCanvas drawShape: shape ].  stroke := anAthensCanvas setStrokePaint: border color.  stroke width: border width.  self dashedBorder notNil ifTrue: [ self setDashOnStroke: stroke ].  anAthensCanvas drawShape: shape.  self hasTwoColorDash ifTrue: [ self setSecondColorDashOnStroke: stroke.        anAthensCanvas drawShape: shape ].  self drawArrowsOnAthensCanvas: anAthensCanvasnewVerticalSeparator  ^self theme newVerticalSeparatorIn: selfisCursorOwner  ^self class cursorOwnerWorld == selfsetUp  super setUp.  morph := CircleMorph newborderWidth: aNumber  super borderWidth: aNumber.  self setScrollDeltasreplaceAll: aRegex with: aText startingAt: startIdx  self handleEdit: [ self editor replaceAll: aRegex with: aText startingAt: startIdx ]taskbarLabel  self model ifNotNil: [ self model taskbarLabel ifNotNil: [:str |  ^str ] ].  ^self labelStringmorphicLayerNumber  ^(owner isNil or: [ owner isWorldMorph ]) ifTrue: [ self valueOfProperty: #morphicLayerNumber ifAbsent: [ 100 ] ] ifFalse: [ owner morphicLayerNumber ]otherProperties  ^extension ifNotNil: [ extension otherProperties ]expand  | c newChildren |  isExpanded := true.  (c := complexContents contents) isEmpty ifTrue: [ ^self changed ].  newChildren := container addMorphsAfter: self fromCollection: c.  firstChild := newChildren first.  self updateChildrenselectablesToHighlightFromRow: aFTRow at: aRowIndex withHighlightedIndexes: highligtedIndexes andPrimaryIndex: primarySelectionIndex  | selectablesToColorMap |  selectablesToColorMap := Dictionary new.  self flag: #pharoFixMe.  aFTRow submorphs withIndexDo: [:each :columnIndex |  | cellIndex |        (highligtedIndexes includes: (cellIndex := {aRowIndex .               columnIndex})) ifTrue: [ selectablesToColorMap at: each put: primarySelectionIndex = cellIndex ] ].  ^selectablesToColorMapkeyStrokeAction: event  | result |  result := self model perform: self keystrokeSelector withEnoughArguments: {event .         self}.  ^result = truesortDataSource: aDataSource  getListSizeSelector  ^getListSizeSelectorhandlerForYellowButtonDown: anEvent  (self hasYellowButtonMenu or: [ self handlesMouseDown: anEvent ]) ifFalse: [ ^nil ].  anEvent handler ifNil: [ ^self ].  ^self mouseDownPriority >= anEvent handler mouseDownPriority ifFalse: [ nil ] ifTrue: [ self ]cornerStyle: aSymbol  aSymbol == self cornerStyle ifFalse: [ self assureExtension.        extension cornerStyle: aSymbol.        self changed ]highlightedIndexes  ^highlightedIndexesaddTabContents: tab at: index delta: delta  | process |  process := tab retrieveMorph: [:contents |  | leftOffset |        contents ifNil: [ TabWithNoContents signalTab: tab ].        leftOffset := index = 1 ifTrue: [ 0 ] ifFalse: [ 2 ].        contentsWrapper addMorph: contents fullFrame: (LayoutFrame identity                 leftFraction: (index - 1) * delta;                 leftOffset: leftOffset;                 rightOffset: -2;                 rightFraction: index * delta) ].  process ifNotNil: [ processes add: process ]mouseDown: event  self flag: #pharoTodofirstVisibleRowIndex  ^self exposedRows ifNotEmpty: [:rows |  rows keys first ] ifEmpty: [ 0 ]dispatchKeystroke: anEvent  | aChar ascii |  aChar := anEvent keyCharacter.  (ascii := aChar asciiValue) = 27 ifTrue: [ ^self invokeWorldMenuFromEscapeKey ].  (self navigationKey: anEvent) ifTrue: [ ^self ].  (anEvent commandKeyPressed and: [ TextEditor cmdKeysInText ]) ifTrue: [ ^self dispatchCommandKeyInWorld: aChar event: anEvent ].  self lastKeystroke: anEvent keyString.  self triggerEvent: #keyStroke.  super dispatchKeystroke: anEventcleanseOtherworldlySteppers  | old delta |  old := self currentWorld stepListSize.  self currentWorld steppingMorphsNotInWorld do: [:m |  m delete ].  self currentWorld cleanseStepList.  (delta := old - self currentWorld stepListSize) > 0 ifTrue: [ self crTrace: delta asString , ' morphs removed from steplist' ]spotterForKeysFor: aStep  < spotterOrder: 15>  (self hasProperty: #kmDispatcher) ifFalse: [ ^self ].  self kmDispatcher spotterForKeysFor: aStepexpandAllTo: aDepth  self rootItem expandAllTo: aDepthexpandAll: aMorph except: aBlock  | allChildren |  (aBlock value: aMorph complexContents) ifFalse: [ ^self ].  aMorph toggleExpandedState.  allChildren := OrderedCollection new: 10.  aMorph recursiveAddTo: allChildren.  allChildren do: [:each |  (each canExpand and: [ each isExpanded not ]) ifTrue: [ self expandAll: each except: aBlock ] ]selectionInterval  ^editor ifNotNil: [ editor selectionInterval ]taskClicked: aTask  self selectTask: aTask.  self donetakesKeyboardFocus  ^truepresentHelp  self inform: 'Sorry, no help has beenprovided here yet.'labelGraphic: aForm  graphicalMorph ifNotNil: [ graphicalMorph delete ].  graphicalMorph := ImageMorph new form: aForm.  self extent: graphicalMorph extent + (self borderWidth + self extraBorder).  graphicalMorph position: self center - (graphicalMorph extent // 2).  self addMorph: graphicalMorph.  graphicalMorph lockdirection  ^directionaddMorphCentered: aMorph  aMorph position: bounds center - (aMorph extent // 2).  self addMorphFront: aMorphmouseUp: evt  super mouseUp: evt.  oldColor ifNotNil: [ self color: oldColor.        oldColor := nil.        (self containsPoint: evt cursorPoint) ifTrue: [ actWhen == #buttonUp ifTrue: [ self doButtonAction ] ] ifFalse: [ self mouseLeave: evt ] ]selectedNodePath  ^selectedNodePathtextStyle: ts lines: l text: t  textStyle := ts.  lines := l.  text := tmouseUp: event on: aNodeMorph  | path cmdOrCtrl clickedTheCheckbox |  clickedTheCheckbox := self clicked: event inTheCheckboxOf: aNodeMorph.  self listModel okToChange ifFalse: [ ^self ].  self listModel okToDiscardEdits ifFalse: [ ^self ].  cmdOrCtrl := self commandOrCrontrolKeyPressed: event.  path := (event shiftPressed and: [ self isMultiple ]) ifTrue: [ self shiftSelectMorph: aNodeMorph ] ifFalse: [ self autoMultiSelection ifTrue: [ self selectedMorphList ifEmpty: [  ] ifNotEmpty: [:l |  l last path collect: [:p |  p complexContents ] ] ] ifFalse: [ self selectMorph: aNodeMorph multiple: ((cmdOrCtrl and: [ self isMultiple ]) or: [ self autoMultiSelection ]) clickedTheCheckBox: clickedTheCheckbox ] ].  self selectionUpdateFromViewWhile: [ | selHolder |        selHolder := self newSelectionHolderWithNodePath: path.        self listModel selection: selHolder ].  clickedTheCheckbox ifFalse: [ self lastClickedMorph: aNodeMorph ].  self selectionChangeddefaultBalloonColor  ^Display depth <= 2 ifTrue: [ Color white ] ifFalse: [ BalloonMorph balloonColor ]searchIn: item  | selfOrChildMatch |  selfOrChildMatch := false.  (self isMatching: item) ifTrue: [ result add: index.        selfOrChildMatch := true ].  index := index + 1.  (item hasChildren and: [ dataSource canDisplayChildrenOf: item ]) ifTrue: [ | itemIndex |        itemIndex := index.        (item children select: [:child |  self searchIn: child ]) ifNotEmpty: [ selfOrChildMatch := true.              item expand ] ifEmpty: [ item collapse.              index := itemIndex ] ].  ^selfOrChildMatchhide  owner ifNil: [ ^self ].  self visible ifFalse: [ ^self ].  self visible: false.  self changedrecursiveAddTo: aCollection  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aNode recursiveAddTo: aCollection ] ].  aCollection add: selfwantsSteps  ^self scrollBarAction notNilgetHelpSelector  ^getHelpSelectortextEntry: aStringOrText title: aString  ^self textEntry: aStringOrText title: aString entryText: ''wantsDroppedMorph: aMorph event: anEvent  ^model container columnDropUnabled and: [ aMorph isTransferable and: [ (aMorph passenger isKindOf: MorphTreeColumn) and: [ aMorph passenger ~= self model ] ] ]selectLastTab  toolbar selectLastTabfillStyleToUse  ^self enabled ifTrue: [ self theme sliderNormalFillStyleFor: self ] ifFalse: [ self theme sliderDisabledFillStyleFor: self ]unsortElements  unsortedElements ifNil: [ ^self ].  self elements: unsortedElements.  unsortedElements := nilhelpText  ^self balloonTextclick: event  (self isYellowButtonReallyPressed: event) ifTrue: [ self showMenuForPosition: event cursorPoint ]waitReadyMorphFor: timeoutDuration  morph ifNotNil: [ ^self ].  retrievingSemaphore wait: timeoutDurationmoveDown: evt  ^self moveSelectionDown: 1 event: evtkeyStrokeArrowLeft: event  (self selectionModeStrategy is: self selectedIndex afterColumn: 1) ifFalse: [ ^self ].  self resetFunction.  self selectIndex: (self selectionModeStrategy selectableIndexBefore: self selectedIndex) event: eventopen  window := manager openInWindow.  window extent: 400 @ 300.  self addTabsdrawGridOn: aCanvas  (self griddingOn and: [ self gridVisible ]) ifTrue: [ aCanvas fillRectangle: self bounds fillStyle: (self gridFormOrigin: self gridOrigin grid: self gridModulus background: nil line: Color lightGray) ]handlesKeyStroke: evt  ^self existsSubscriptionsFor: #keyStrokeaddCustomMenuItems: aMenu hand: aHandMorph  super addCustomMenuItems: aMenu hand: aHandMorph.  aMenu addLine.  aMenu add: 'add or remove items' target: self selector: #addOrRemoveItems: argument: aHandMorph.  aMenu addList: {#- .         {'Place into a row' .         #organizeIntoRow} .         {'Place into a column' .         #organizeIntoColumn} .         #- .         {'Align left edges' .         #alignLeftEdges} .         {'Align top edges' .         #alignTopEdges} .         {'Align right edges' .         #alignRightEdges} .         {'Align bottom edges' .         #alignBottomEdges} .         #- .         {'Align centers vertically' .         #alignCentersVertically} .         {'Align centers horizontally' .         #alignCentersHorizontally}}.  self selectedItems size > 2 ifTrue: [ aMenu addList: {#- .               {'Distribute vertically' .               #distributeVertically} .               {'Distribute horizontally' .               #distributeHorizontally}} ]active: anObject  active := anObject.  self changedinstall  owner := nil.  ActiveWorld := self.  World := self.  ActiveHand := self hands first.  ActiveEvent := nil.  submorphs do: [:ss |  ss owner ifNil: [ ss privateOwner: self ] ].  self viewBox: Display boundingBox.  Sensor flushAllButDandDEvents.  worldState handsDo: [:h |  h initForEvents ].  self borderWidth: 0.  SystemWindow noteTopWindowIn: self.  self displayWorldSafelylistMorph  listMorph ifNil: [ listMorph := self listMorphClass new.        listMorph listSource: self.        listMorph width: self scroller width.        listMorph color: self textColor ].  listMorph owner ~~ self scroller ifTrue: [ self scroller removeAllMorphs.        self scroller addMorph: listMorph ].  ^listMorphisYellowButtonReallyPressed: anEvent  anEvent yellowButtonPressed ifFalse: [ ^false ].  ^Smalltalk os isMacOS ifTrue: [ anEvent commandKeyPressed not ] ifFalse: [ anEvent controlKeyPressed not ]textAnchorType  ^self valueOfProperty: #textAnchorType ifAbsent: [ #document ]handlesMouseOver: anEvent  ^truesetStrategy  self subclassResponsibilityisAdheringToLeft  ^self edgeToAdhereTo == #leftoverrideExtent: newExtent  self isAutoFit ifTrue: [ self           setProperty: #autoFitContents toValue: false;           extent: newExtent;           setProperty: #autoFitContents toValue: true ]classButton  ^(self theme newButtonIn: self currentWorld for: self getState: nil action: #browseItem arguments: {} getEnabled: #enabled getLabel: nil help: 'Open a browser on ' translated , self item name)     label: (self theme windowLabelForText: self item name , '...');     yourselfpageSize  ^pageSizeblueButtonUp: anEvent  isInWorld  ^self world notNilimage: anImage  image := anImage.  super extent: (2 * self borderWidth) asPoint + image extent.  self changedactivateOwnerMenu: evt  ^self owner ifNil: [ false ] ifNotNil: [:o |  o activate: evt.        true ]stepAt: millisecondClockValue  (isCollapsed not or: [ self wantsStepsWhenCollapsed ]) ifTrue: [ model ifNotNil: [ model stepAt: millisecondClockValue in: self ].        super stepAt: millisecondClockValue ]mouseOverColor  ^self theme lightBackgroundColorrightArrow  ^SubMenuMarkertestRowIndexFrom  self assert: (strategy rowIndexFrom: #(3 5)) equals: 3addLine  (self hasItems and: [ self lastSubmorph isMenuLineMorph not ]) ifTrue: [ self addMorphBack: MenuLineMorph new ]verticalScrollBarValueToRowIndex: aNumber  | startingIndex |  startingIndex := self dataSource numberOfRows - self container calculateMinVisibleRows + 1.  ^(startingIndex * aNumber) asIntegerdefaultBorderWidth  ^0selected  ^falseisRenderer  ^falsenewRadioButtonFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newRadioButtonIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpTextremovePage: aMorph  | index |  index := self pages indexOf: aMorph.  self pages remove: aMorph.  self tabSelectorMorph removeTabIndex: indexshowingDirectionHandles  ^directionArrowAnchor notNilbaseColor  ^baseColor ifNil: [ Color transparent ]empty  self selectedNodePath: nilsetDefaultContentsIfNil  | toUse |  text ifNil: [ toUse := self valueOfProperty: #defaultContents.        toUse ifNil: [ toUse := '' asText ].        text := toUse ]contents  ^item submorphs collect: [:m |  self class with: m ]subMenu: aMenuMorph  subMenu := aMenuMorph.  self changednewColorPickerButtonMorph  ^self newButtonFor: self getState: nil action: #pickColor arguments: nil getEnabled: nil labelForm: ((self iconNamed: #eyedropperIcon) scaledIntoFormOfSize: 16) help: 'Pick a color from the screen' translatedglamourMinExtent  ^self minExtentnewEmbeddedMenu  ^self theme newEmbeddedMenuIn: self for: selftext  | keyParts |  keyParts := (self keyText substrings: '+') collect: #trimBoth.  ((keyParts includes: 'Shift') and: [ (keyParts first = 'Shift') not ]) ifTrue: [ keyParts := (keyParts copyWithout: 'Shift') copyWithFirst: 'Shift' ].  ^keyParts inject: Text new into: [:s :each |  s , (self class symbolTableAt: each ifAbsent: [ each capitalized ]) ]transformedBy: aTransform  aTransform isIdentity ifTrue: [ ^self ].  aTransform isPureTranslation ifTrue: [ ^self position: (aTransform localPointToGlobal: self position) ].  ^self addFlexShell transformedBy: aTransformcontainsPoint: aPoint event: anEvent  (anEvent isMouse and: [ anEvent isMouseDown and: [ anEvent blueButtonPressed ] ]) ifFalse: [ ^super containsPoint: aPoint event: anEvent ].  ^bounds containsPoint: anEvent positionisActive  ^self isFullscreen or: [ super isActive ]testColumnHasIconWithSorting  column sortableOnProperty: #name.  self assert: column sortingIcon isNotNiladdNullLineWithIndex: index andRectangle: r  lines addLast: ((TextLine start: index stop: index - 1 internalSpaces: 0 paddingWidth: 0)           rectangle: r;           lineHeight: defaultLineHeight baseline: theTextStyle baseline)setBalloonText: stringOrText maxLineLength: aLength  (extension isNil and: [ stringOrText isNil ]) ifTrue: [ ^self ].  self assureExtension balloonText: (stringOrText ifNotNil: [ stringOrText asString withNoLineLongerThan: aLength ])setSelectionIndexFromKeyboard: index multiSelection: multiSelect event: anEvent  | targetMorph |  index ifNil: [ ^self ].  index > self allNodeMorphs size ifTrue: [ ^self ].  targetMorph := index = 0 ifTrue: [ nil ] ifFalse: [ self allNodeMorphs at: index ].  lastClickedMorph ifNotNil: [ lastClickedMorph highlightForMouseDown: false ].  self isCheckList ifTrue: [ (multiSelect and: [ anEvent shiftPressed ]) ifTrue: [ self autoMultiSelect: targetMorph ] ] ifFalse: [ (multiSelect and: [ anEvent shiftPressed ]) ifTrue: [ self autoMultiSelect: targetMorph ] ifFalse: [ self setSelectedMorph: targetMorph ] ].  self lastClickedMorph: (firstClickedMorph := targetMorph).  anEvent shiftPressed ifTrue: [ lastClickedMorph highlightForMouseDown: true ].  self selectionChanged.  self scrollToShow: targetMorph contentBoundsmouseOverThumbBorderStyle  ^self theme scrollbarMouseOverThumbBorderStyleFor: selfintercellSpacing  ^intercellSpacing ifNil: [ self class defaultIntercellSpacing ]mouseMove: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseMove from: sourceMorphaddHaloActionsTo: aMenu  | subMenu |  subMenu := UIManager default newMenuIn: self for: self.  subMenu     buildTitle: [:menuTitle |  menuTitle bigTitle: self externalName ];     add: 'delete' selector: #dismissViaHalo.  subMenu balloonTextForLastItem: 'Delete this object -- warning -- can be destructive!' translated.  self maybeAddCollapseItemTo: subMenu.  subMenu add: 'grab' selector: #openInHand.  subMenu balloonTextForLastItem: 'Pick this object up -- warning, since this removes it from its container, it can have adverse effects.' translated.  subMenu addLine.  subMenu add: 'resize' selector: #resizeFromMenu.  subMenu balloonTextForLastItem: 'Change the size of this object' translated.  subMenu add: 'duplicate' selector: #maybeDuplicateMorph.  subMenu balloonTextForLastItem: 'Hand me a copy of this object'.  subMenu addLine.  subMenu add: 'set color' target: self renderedMorph selector: #changeColor.  subMenu balloonTextForLastItem: 'Change the color of this object'.  subMenu addLine.  subMenu add: 'inspect' target: self selector: #inspect.  subMenu balloonTextForLastItem: 'Open an Inspector on this object'.  aMenu add: 'halo actions...' subMenu: subMenumouseMove: anEvent  target ifNil: [ ^self ].  target fastFramingOn ifTrue: [ target doFastWindowReframe: self ptName ] ifFalse: [ lastMouse at: 1 put: anEvent cursorPoint.        self targetPoint: lastMouse first - lastMouse last.        self position: lastMouse first - lastMouse second ]getEnabledSelector  ^getEnabledSelectorareasRemainingToFill: aRectangle  (backgroundColor isNil or: [ backgroundColor isTranslucent ]) ifTrue: [ ^Array with: aRectangle ].  self wantsRoundedCorners ifTrue: [ (borderWidth > 0 and: [ borderColor isColor and: [ borderColor isTranslucent ] ]) ifTrue: [ ^aRectangle areasOutside: (self innerBounds intersect: self boundsWithinCorners ifNone: [ self error: 'cannot happen' ]) ] ifFalse: [ ^aRectangle areasOutside: self boundsWithinCorners ] ] ifFalse: [ (borderWidth > 0 and: [ borderColor isColor and: [ borderColor isTranslucent ] ]) ifTrue: [ ^aRectangle areasOutside: self innerBounds ] ifFalse: [ ^aRectangle areasOutside: self bounds ] ]reframePanesAdjoining: growingPane along: side to: aDisplayBox  | delta newRect minDim theMin horiz |  growingPane ifNil: [ ^self ].  newRect := aDisplayBox.  horiz := #(left right) includes: side.  theMin := horiz ifTrue: [ 40 ] ifFalse: [ 20 ].  minDim := (((paneMorphs select: [:pane |  pane bounds bordersOn: growingPane bounds along: side ]) collect: [:pane |  pane bounds adjustTo: newRect along: side ]) copyWith: aDisplayBox) inject: 999 into: [:was :rect |  was min: (horiz ifTrue: [ rect width ] ifFalse: [ rect height ]) ].  minDim > theMin ifFalse: [ delta := minDim - theMin.        newRect := newRect withSide: side setTo: ((newRect perform: side) > (growingPane bounds perform: side) ifTrue: [ (newRect perform: side) + delta ] ifFalse: [ (newRect perform: side) - delta ]) ].  paneMorphs do: [:pane |  (pane bounds bordersOn: growingPane bounds along: side) ifTrue: [ pane bounds: (pane bounds adjustTo: newRect along: side) ] ].  growingPane bounds: newRect.  self setPaneRectsFromBounds.  self extent: self extenthasLeftOrTop: aMorph  ^leftOrTop includes: aMorphdelete  super delete.  self releaseopenAsIs  ^self openAsIsIn: self currentWorldpopUpEvent: evt in: aWorld  | aHand aPosition |  aHand := evt ifNotNil: [ evt hand ] ifNil: [ ActiveHand ].  aPosition := aHand position truncated.  ^self popUpAt: aPosition forHand: aHand in: aWorldimageFormDepth: depth  ^self imageForm: depth forRectangle: self fullBoundstestIsAboveRow  self assert: (strategy is: #(3 7) aboveRow: 4).  self deny: (strategy is: #(3 7) aboveRow: 2).  self deny: (strategy is: #(3 7) aboveRow: 3)selectedLabel: anObject  selectedLabel := anObjectvResizing  | props |  props := self layoutProperties.  ^props ifNil: [ #rigid ] ifNotNil: [ props vResizing ]resize  | newWidth |  newWidth := self maxBarWidth + 50 max: self width.  self width: newWidthsplitterBelow  | splitters |  splitters := (self siblingSplitters select: [:each |  each top < self top and: [ self overlapsHorizontal: each ] ]) asSortedCollection: [:a :b |  a top > b top ].  ^splitters ifEmpty: [ nil ] ifNotEmpty: [:s |  s first ]acceptDroppingMorph: toDrop event: evt  complexContents acceptDroppingObject: toDrop complexContents.  toDrop delete.  self highlightForDrop: falsenewAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletioncurrentCursor: aCursor  ^worldState currentCursor: aCursoradjustSubmorphPositionsFrom: start to: stop  | subs p |  subs := self allNodeMorphs.  p := (subs at: start) position.  start to: subs size do: [:idx |  | each h |        each := subs at: idx.        h := each height.        each bounds: (p extent: each width @ h).        p := p + (0 @ h) ]keyDown: anEvent  inactiveLabelFillStyle  ^self theme windowInactiveLabelFillStyleFor: selfresetListSelector  ^resetListSelectorcontainer  container ifNil: [ successor ifNotNil: [ ^self compositionRectangle ].        wrapFlag ifTrue: [ ^self compositionRectangle withHeight: 9999999 ].        ^self compositionRectangle topLeft extent: 9999999 @ 9999999 ].  ^containertestSelectableIndexAfter  self assert: (strategy selectableIndexAfter: #(2 3)) equals: #(2 4)hasIcon  ^icon notNilfirstClickedMorph: aNodeMorph  firstClickedMorph := aNodeMorphfilterWith: aStringOrText  initialDataSource ifNil: [ self initializeFilter ].  pattern := aStringOrText asString trimBoth.  isEditingSemaphore signalembeddable  ^self valueOfProperty: #embeddable ifAbsent: [ false ]controlButtonWidth  ^self theme scrollbarThickness + (3 * self displayScaleFactor)autoGradientString  ^self autoGradient -> 'auto gradient' translatedhandsDo: aBlock  ^worldState handsDo: aBlockvScrollbarInterval  ^self scrollBounds height asFloat / self scrollTarget height min: 1.0initForKeystrokes  lastKeystrokeTime := 0.  lastKeystrokes := ''.  lastSelection := 0otherProperties  ^otherPropertieswidth: aNumber  width = aNumber ifTrue: [ ^self ].  width := aNumber truncated max: (width isPoint ifTrue: [ 0 @ 0 ] ifFalse: [ 0 ]).  self releaseCachedStatenewCloseButtonFor: aModel  ^self theme newCloseButtonIn: self for: aModelborderColor  ^self theme lightBackgroundColorhasContentsSelector  ^hasContentsSelectorbeWithGrips  self removeProperty: #noGrips.  (self isCollapsed not or: [ self isTaskbarPresent ]) ifTrue: [ self addGripsIfWanted ]pasteUpMorph  ^self ownerThatIsA: PasteUpMorphdefaultRowMorph  ^Morph new     color: Color red;     borderWidth: 0;     extent: 0 @ 0;     yourselfworldTaskbar  ^self world ifNotNil: [:world |  world submorphThat: [:morph |  morph isTaskbar ] ifNone: [ nil ] ]doubleClickSelector: aSelector  self listManager doubleClickSelector: aSelectorshowWindowPreview  ^self class showWindowPreviewopenInSceneView  ^AthensSceneView new     scene: (AthensMorphScene new morph: self);     openInWindowchooseFont: aFont  ^self theme chooseFontIn: self title: 'Font Selector' translated font: aFontcheckIfUpdateNeeded  damageRecorder updateIsNeeded ifTrue: [ ^true ].  hands do: [:h |  (h hasChanged and: [ h needsToBeDrawn ]) ifTrue: [ ^true ] ].  ^falsetarget  ^targetallIntervals  | intervals |  intervals := OrderedCollection new.  1 to: self lastPage do: [:p |  | start |        intervals add: (start := (p - 1) * self pageSize + 1) -> (start + pageSize - 1) ].  intervals last value: self nodeList size.  ^intervalsdrawBoundsForRow: row  | topLeft drawBounds item width height |  item := self getListItem: row.  height := (item collect: [:e |  e heightToDisplayInList: self ]) max.  width := self width.  topLeft := self topLeft x @ (self topLeft y + ((row - 1) * height)).  drawBounds := topLeft extent: width @ height.  ^drawBoundsupdateData  self children do: #updateDataselectPrevious  | index nextSelection |  index := tabs indexOf: self selectedTab.  nextSelection := tabs at: index - 1 ifAbsent: [ ^self ].  nextSelection selected: truenewScrollPaneFor: aMorph  ^self theme newScrollPaneIn: self for: aMorphchildren  ^childrencreateClosedPolygonPathFrom: aPointsArray on: anAthensCanvas  ^anAthensCanvas createPath: [:builder |  aPointsArray ifEmpty: [ builder ].        builder absolute.        builder moveTo: aPointsArray first.        aPointsArray allButFirstDo: [:p |  builder lineTo: p ].        builder close.        builder ]gapSize: anInteger  gapSize := anIntegeraddAlarm: aSelector with: arg1 with: arg2 at: scheduledTime  ^self addAlarm: aSelector withArguments: (Array with: arg1 with: arg2) at: scheduledTimelastColumnUnbounded  ^unboundLastColumn ifNil: [ unboundLastColumn := true ]addEmphasis: aCodeOrTextEmphasis  self emphasis: (emphasis bitOr: aCodeOrTextEmphasis value)mouseDownInSlider: event  self enabled ifFalse: [ ^self ].  ^super mouseDownInSlider: eventhasActions  ^actions notEmptygetStringSelector: aSymbol  self validateSelector: aSymbol.  getStringSelector := aSymbolrelease  container := nil.  header := nil.  self releaseActionMap.  super releaserotationDegrees  ^0.0label: aStringOrTextOrMorph  font ifNil: [ self label: aStringOrTextOrMorph font: self theme buttonFont ] ifNotNil: [ self label: aStringOrTextOrMorph font: font ]lazyIncrement  ^lazyIncrement ifNil: [ lazyIncrement := 20 ]distributeHorizontally  | minLeft maxRight totalWidth currentLeft space |  self selectedItems size > 2 ifFalse: [ ^self ].  minLeft := self selectedItems anyOne left.  maxRight := self selectedItems anyOne right.  totalWidth := 0.  self selectedItems do: [:each |  minLeft := minLeft min: each left.        maxRight := maxRight max: each right.        totalWidth := totalWidth + each width ].  currentLeft := minLeft.  space := ((maxRight - minLeft - totalWidth) / (self selectedItems size - 1)) rounded.  (self selectedItems asSortedCollection: [:x :y |  x left <= y left ]) do: [:each |  each left: currentLeft.        currentLeft := currentLeft + each width + space ].  self changedisIndexSelected: rowIndex  ^self selectedIndexes includes: rowIndexaddServices: services for: served extraLines: linesArray  services withIndexDo: [:service :i |  self           addService: service for: served;           balloonTextForLastItem: service description.        (service usingLineAfter or: [ linesArray includes: i ]) ifTrue: [ self addLine ] ]selectionFrameFor: aNodeMorph  ^aNodeMorph bounds: aNodeMorph selectionFrame in: selfwasHandled: aBool  wasHandled := aBoolstop  self stopSteppinglayoutInset  ^layoutInsetpreferredDuplicationHandleSelector  ^#addDupHandle:keyText  ^keyTextselectedIndexes  ^selectedIndexesdrawPolyPatchFrom: startPoint to: stopPoint on: aCanvas usingEnds: endsArray  | cos sin tfm fill dir fsOrigin fsDirection points x y |  dir := (stopPoint - startPoint) normalized.  cos := dir dotProduct: 1 @ 0.  sin := dir crossProduct: 1 @ 0.  fill := self fillStyleForDirection: dir.  false ifTrue: [ fill := fill shallowCopy.        x := fill origin x.        y := fill origin y.        fsOrigin := (x * cos + (y * sin) + startPoint x) @ (y * cos - (x * sin) + startPoint y).        x := fill direction x.        y := fill direction y.        fsDirection := (x * cos + (y * sin)) @ (y * cos - (x * sin)).        fill           origin: fsOrigin;           direction: fsDirection rounded;           normal: nil.        aCanvas asBalloonCanvas drawPolygon: endsArray fillStyle: fill ] ifFalse: [ tfm := MatrixTransform2x3 new           a11: cos;           a12: sin;           a21: sin negated;           a22: cos.        tfm offset: startPoint.        points := endsArray collect: [:pt |  tfm invertPoint: pt ].        aCanvas asBalloonCanvas transformBy: tfm during: [:cc |  cc drawPolygon: points fillStyle: fill ] ]waitButton  self captureEventsUntil: [:evt |  self anyButtonPressed ]deleteVertexAt: anIndex  self setVertices: (vertices copyReplaceFrom: anIndex to: anIndex with: #())isSelectionUpdateFromView  ^isSelectionUpdateFromView ifNil: [ isSelectionUpdateFromView := false ]drawLinesToNextSiblingOn: aCanvas lineColor: lineColor hasToggle: hasToggle  | myBounds nextSibBounds vLineX myCenter vLineTop vLineBottom myTheme |  myBounds := self toggleBounds.  nextSibBounds := self nextSibling toggleBounds.  myCenter := myBounds center.  vLineX := myCenter x.  vLineTop := myCenter y + 1.  vLineBottom := nextSibBounds center y - 1.  myTheme := self theme.  aCanvas frameRectangle: (vLineX @ vLineTop corner: (vLineX + 1) @ vLineBottom) width: myTheme treeLineWidth colors: (myTheme treeLineColorsFrom: lineColor) dashes: myTheme treeLineDashessecondarySelectionColor  ^secondarySelectionColor ifNil: [ self class defaultSecondarySelectionColor ]invokeMetaMenu: evt  stayUp ifFalse: [ ^self ].  ^super invokeMetaMenu: evtstrongSelectionChanged: ann  self doubleClickSelector ifNil: [ ^self ].  self model perform: self doubleClickSelector withEnoughArguments: {ann}fullBoundsInWorld  ^self bounds: self fullBounds in: self worldinactiveFillStyle  ^self theme windowInactiveFillStyleFor: selfname  ^self item itemName asStringshowingHandles  ^handles notNilfullList  self lastIndex < self nodeList size ifTrue: [ self nextPage: self nodeList size ]highlightColor  ^(self valueOfProperty: #highlightColor) ifNotNil: [:val |  val ifNil: [ self error: 'nil highlightColor' ] ] ifNil: [ owner ifNil: [ self color ] ifNotNil: [ owner highlightColor ] ]borderColor: aColor  | bordered |  bordered := selectedItems.  undoProperties ifNil: [ undoProperties := bordered collect: [:m |  m borderColor ] ].  bordered do: [:m |  m borderColor: aColor ]client: aMorph click: aClickSelector dblClick: aDblClickSelector dblClickTime: timeOut dblClickTimeout: aDblClickTimeoutSelector drag: aDragSelector threshold: aNumber event: firstClickEvent  clickClient := aMorph.  clickSelector := aClickSelector.  dblClickSelector := aDblClickSelector.  dblClickTime := timeOut.  dblClickTimeoutSelector := aDblClickTimeoutSelector.  dragSelector := aDragSelector.  dragThreshold := aNumber.  firstClickDown := firstClickEvent.  firstClickTime := firstClickEvent timeStamp.  clickState := #firstClickDown.  localStamp := Time millisecondClockValueborderRectsFor: aRectangle  | rTop rBottom rLeft rRight w |  w := self width.  rTop := aRectangle topLeft corner: aRectangle right @ (aRectangle top + w).  rBottom := aRectangle left @ (aRectangle bottom - w) corner: aRectangle bottomRight.  rLeft := aRectangle left @ (aRectangle top + w) corner: (aRectangle left + w) @ (aRectangle bottom - w).  rRight := (aRectangle right - w) @ (aRectangle top + w) corner: aRectangle right @ (aRectangle bottom - w).  ^{rTop .   rBottom .   rLeft .   rRight}setSelectedMorph: aMorph  | path |  path := aMorph ifNotNil: [ aMorph path collect: [:m |  m complexContents ] ].  self lastClickedMorph: aMorph.  self emptySelection.  aMorph ifNotNil: [ self addToSelection: lastClickedMorph ].  self selectionUpdateFromViewWhile: [ self listModel selection: (self newSelectionHolderWithNodePath: path) ]initialize  super initialize.  self color: Color transparentmustNotClose  ^mustNotClose == truenextState  ^FTAscendingSortingState context: self contexttestCollapsing  | t |  window := SystemWindow labelled: 'foo'.  t := 0.  window openInWorld.  window announcer when: WindowCollapsed do: [:ann |  t := t + 1 ].  self assert: t equals: 0.  window collapse.  self assert: t equals: 1setLockedIcon  closeIcon image: self class lockedIcontransform: anObject  ^anObjectfilterString  (function isKindOf: FTFilterFunction) ifFalse: [ ^'' ].  ^function pattern ifNil: [ '' ]setValueSelector: aSymbol  setValueSelector := aSymboltoogleSelectionValue  self item toogleSelectionValueathensHighlightPotentialDropRow: row on: anAthensCanvas  | drawBounds |  drawBounds := self drawBoundsForRow: row.  drawBounds := drawBounds intersect: self bounds ifNone: [ ^self ].  anAthensCanvas setStrokePaint: Color blue.  anAthensCanvas drawShape: drawBoundsadhereToTop  self adhereTo: #topnewTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpTextisWindowActive: aSystemWindow  ^self owner ifNil: [ true ] ifNotNil: [:o |  o isWindowActive: aSystemWindow ]passiveEnabledNotOverDownFillStyle: aFillStyle  self stateMap atPath: #(passive enabled notOver down) put: aFillStyle.  self changeddoubleClickTimeout: event  self removeProperty: #inactiveDoubleClickcustomizeArrows: evt  | handle origin aHand |  aHand := evt ifNil: [ self primaryHand ] ifNotNil: [ evt hand ].  origin := aHand position.  handle := HandleMorph new forEachPointDo: [:newPoint |  handle removeAllMorphs.        handle addMorph: (LineMorph from: origin to: newPoint color: Color black width: 1).        self arrowSpec: (newPoint - origin) / 5.0 ] lastPointDo: [:newPoint |  handle deleteBalloon.        self halo ifNotNil: [:halo |  halo addHandles ] ].  aHand attachMorph: handle.  handle showBalloon: 'Move cursor left and rightto change arrow length and style.Move it up and down to change width.Click when done.' hand: evt hand.  handle startSteppingitem  ^item= anEvent  anEvent isMorphicEvent ifFalse: [ ^false ].  ^self type = anEvent typecheckIfReadyToSlide  (possibleSlide and: [ currCharIndex > stopCharIndex ]) ifFalse: [ ^self ].  [ prevIndex < prevLines size and: [ (prevLines at: prevIndex) first < (currCharIndex - deltaCharIndex) ] ] whileTrue: [ prevIndex := prevIndex + 1 ].  (prevLines at: prevIndex) first = (currCharIndex - deltaCharIndex) ifTrue: [ prevIndex := prevIndex - 1.        possibleSlide := false.        nowSliding := true ] ifFalse: [ prevIndex = prevLines size ifTrue: [ possibleSlide := false ] ]hasExpandBox  ^expandBox notNilremoveBoxes  closeBox ifNotNil: [ closeBox delete.        closeBox := nil ].  menuBox ifNotNil: [ menuBox delete.        menuBox := nil ].  expandBox ifNotNil: [ expandBox delete.        expandBox := nil ].  collapseBox ifNotNil: [ collapseBox delete.        collapseBox := nil ]forceWidthTo: anInteger  currentWidth := anIntegerargumentsBlock: aBlock  self arguments: aBlock valueinitialize  super initialize.  topSeparator := false.  self     clipSubmorphs: true;     layoutPolicy: TableLayout new;     hResizing: #spaceFill;     vResizing: #spaceFill;     listDirection: #leftToRight;     listCentering: #topLeft;     wrapCentering: #centergrabFromScreen  self form: Form fromUserforceRefreshOnNextChange  lastRefresh := 0update: aSymbol  aSymbol == stateSelector ifTrue: [ ^self updateState ].  aSymbol == onImageSelector ifTrue: [ ^self updateOnImage ].  aSymbol == offImageSelector ifTrue: [ ^self updateOffImage ].  aSymbol == pressedImageSelector ifTrue: [ ^self updatePressedImage ].  ^super update: aSymbolrootNodeClassFromItem: anItem  ^PackageNodeExampletaskbarThumbnail  ^self taskThumbnailOfSize: self taskbarThumbnailExtentclipSubmorphs: anObject  clipSubmorphs := anObjectnewMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector help: helpText  ^self newMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: nil help: helpTextkeystrokeActionSelector  ^keystrokeActionSelectorclick: evt  ^self eventHandler ifNotNil: [ self eventHandler click: evt fromMorph: self ]highlightForDrop  self highlightForDrop: truesetNeedsRefreshExposedRows  needsRefreshExposedRows := truenewTransformMorph  ^TransformMorph newnormalLabel  ^normalLabeldisplayExtentChanged  self updateBoundscontentsMenuTitle  ^'World contents' translatedowner: aCalendarChooserMorph  owner := aCalendarChooserMorphcontrastingBackgroundColor  backgroundColor := self color contrastingBlackAndWhiteColorheaderColor  ^headerColor ifNil: [ self class defaultHeaderColor ]updateCount: aHashValue  | value |  value := countDict at: aHashValue ifAbsent: [ 0 ].  countDict at: aHashValue put: value + 1layoutItems  | maxIconWidth |  maxIconWidth := 0.  self items do: [:item |  item icon ifNotNil: [ maxIconWidth := maxIconWidth max: item icon width ].        item hasSubMenu ifTrue: [ item subMenu layoutItems ] ].  maxIconWidth isZero ifFalse: [ self addBlankIconsIfNecessary: (Smalltalk ui icons blankIconOfWidth: maxIconWidth) ]event: anEvent  event := anEventreleaseCachedState  shadowForm := nil.  vertProfile := nil.  rectangleCache := Dictionary newnewPluggableDialogWindow: title  ^self newPluggableDialogWindow: title for: nilannouncer  ^announcer ifNil: [ announcer := Announcer new ]menuStringBounds  | oldBounds |  oldBounds := super menuStringBounds.  ^oldBounds left: (oldBounds left + oldBounds right - self measureContents x) // 2beExplicit  self initializeMorph.  table     addMorph: field;     resizeAllSubviewswantsToBeCachedByHand  self isTranslucentButNotTransparent ifTrue: [ ^false ].  self submorphsDo: [:m |  m wantsToBeCachedByHand ifFalse: [ ^false ] ].  ^trueworldState  ^worldStatestate: anObject  state := anObjectcolorsAtCorners  ^Array new: 4 withAll: self colorbuildLabel: text withIcon: icon  ^(TabLabelItem tab: self)     morph: text asMorph;     icon: (AlphaImageMorph new image: icon);     yourselfcreateMenuBox  ^self theme createMenuBoxFor: selfisMouseEnter  ^self type == #mouseEntertargetPoint  ^self target bounds pointAtSideOrCorner: self ptNameexternalName  ^externalNameisSelectedMatchingTheState: aBoolean  ^aBoolean notadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self     fillStyle: self fillStyleToUse;     borderStyle: self borderStyleToUse;     sliderColor: (self enabled ifTrue: [ paneColor twiceDarker ] ifFalse: [ self paneColor twiceDarker paler ])drawMouseDownHighlightOn: aCanvas  | frame |  self highlightedForMouseDown ifTrue: [ container ifNil: [ ^super drawMouseDownHighlightOn: aCanvas ].        frame := self selectionFrame.        aCanvas frameRectangle: frame width: 1 colors: {container mouseDownHighlightColor .               Color transparent} dashes: #(1 1) ]initialize  super initialize.  hResizing := vResizing := #rigid.  disableLayout := falseadd: aLabelString target: anObject selector: aSymbol  ^self add: aLabelString target: anObject selector: aSymbol argumentList: EmptyArraybrickThemerChanged  self submorphs do: #brickThemerChangedhideCloseIcon  closeIcon hidemouseEnterDragging: evt  (self isTopWindow not and: [ evt hand hasSubmorphs ]) ifTrue: [ self submorphsDo: [:m |  m unlock ].        evt hand addMouseListener: self ]preview  ^previewlayoutFrame  ^layoutFrameoptionKeyPressed  ^buttons anyMask: 2r00100000optionalOperations  ^pattern isEmptyOrNil ifTrue: [ #() ] ifFalse: [ nil ]handlesMouseMove: anEvent  self eventHandler ifNotNil: [:handler |  (handler handlesMouseMove: anEvent) ifTrue: [ ^true ] ].  ^anEvent hand submorphs isEmpty and: [ anEvent anyButtonPressed and: [ anEvent hand mouseFocus == self ] ]testUpdateTaskBarShouldContainsTaskbarTasksForEachWindow  | window1 window2 |  taskbar := self.  world := self.  window1 := world addWindow.  window2 := world addWindow.  taskbar updateTasks.  self assert: taskbar tasks first morph equals: window1.  self assert: taskbar tasks second morph equals: window2setDefaultLabel  self labelGraphic: self class defaultGraphicstransform: coefficients toCubicPointPolynomialAt: vIndex  | transformed |  transformed := (1 to: 4) collect: [:i |  ((coefficients at: i) at: vIndex) @ ((coefficients at: 4 + i) at: vIndex) ].  ^Cubic withAll: transformedisDraggableNode: node  ^truewantsSteps  ^isCollapsed not and: [ model wantsStepsIn: self ]proceed: aStringOrText title: aString  ^self theme proceedIn: self text: aStringOrText title: aStringaddWithLabel: aLabelString enablement: anEnablementSelector action: aSymbol  self flag: #pharoToDeprecate.  self addToggle: aLabelString target: defaultTarget selector: aSymbol getStateSelector: nil enablementSelector: anEnablementSelector argumentList: EmptyArraywantsToBeTopmost  ^truecomputedHeight  ^self nodeList size > self lastIndex ifTrue: [ super computedHeight ] ifFalse: [ 0 ]initializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #ScrollPaneisMinimized  ^self state == #minimizedhHideScrollbar  self hScrollbarShowing ifFalse: [ ^self ].  self removeMorph: self hScrollbar.  self vResizeScrollbar.  self resizeScrollerrecentlyChanged  ^recentlyChanged ifFalse: [ false ] ifTrue: [ recentlyChanged := false.        true ]updateContents  self bounds: self computedBounds.  self color: treeMorph pagerColorhash  ^position hash + startPoint hash + buttons hashsetProperties: aList  1 to: aList size by: 2 do: [:ii |  self setProperty: (aList at: ii) toValue: (aList at: ii + 1) ]passivate  super passivate.  self setStripeColorsFrom: self paneColorToUse.  self isEmbedded ifTrue: [ ^self ].  self lockInactivePortions.  labelArea ifNil: [ self adjustBorderUponDeactivationWhenLabeless ]selectedIndex  ^selectedIndexid  ^idalign: aPoint1 with: aPoint2  ^self position: self position + (aPoint2 - aPoint1)addAlarm: aSelector after: delayTime  ^self addAlarm: aSelector withArguments: #() after: delayTimeprogress: aNormalizedNumber  ^progressBar value: aNormalizedNumber * 100tabDeleted: aTab  self removeTab: aTabaddList: aList  aList do: [:tuple |  tuple == #- ifTrue: [ self addLine ] ifFalse: [ self add: tuple first capitalized translated selector: tuple second.              (tuple size > 2 and: [ tuple third notNil ]) ifTrue: [ self balloonTextForLastItem: tuple third translated ].              (tuple size > 3 and: [ tuple fourth notNil ]) ifTrue: [ self lastItem icon: (self iconNamed: tuple fourth) ] ] ]releaseCachedState  super releaseCachedState.  self removeModalWindowtab: anObject  tab := anObjectenabled: aBoolean  enabled == aBoolean ifFalse: [ enabled := aBoolean.        self           changed: #enabled;           changed ]changed  ^fullBounds ifNil: [ self invalidRect: self privateFullBounds ] ifNotNil: [ self invalidRect: fullBounds ]createCommandContextBy: aPresenter forDropAt: anEvent  ^aPresenter createCommandContextForSelection: #()setTargetBounds: aRect  self target bounds: aRect.  self fitTargetOwner ifTrue: [ self fitTargetBoundsInOwner: aRect ]expandRoots  self rootsItems do: #expand.  self tableRefreshthemeChanged  super themeChanged.  morph color: morph defaultColor.  morph changedtestSelectFirst  self subclassResponsibilitykeyTextExpanded  ^ToggleMenuItemShortcut normalize: self keyTextinARow: aCollectionOfMorphs  self setAsRow     color: Color transparent;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     layoutInset: 1;     wrapCentering: #center;     cellPositioning: #leftCenter.  aCollectionOfMorphs do: [:each |  self addMorphBack: each ]tabSelector  ^tabSelectoradoptPaneColor: paneColor  paneColor ifNil: [ ^super adoptPaneColor: paneColor ].  self fillStyle: (self theme resizerGripNormalFillStyleFor: self)mouseLeave: anEvent fromMorph: aMorph  ^self notify: anEvent from: aMorphstringMorph  ^stringMorph ifNil: [ stringMorph := self mockStringMorph ]blueButtonDown: event  target ifNil: [ ^self delete ].  event hand obtainHalo: self.  positionOffset := event position - (target point: target position in: owner).  event hand waitForClicksOrDrag: self event: event selectors: {#transferHalo: .         nil .         nil .         #dragTarget:} threshold: 5submorphCount  ^submorphs sizewantsYellowButtonMenu  ^self getMenuSelector notNilsetItem: anObject  item := anObjecthandlesMouseDown: evt  ^trueactiveDisabledOverUpFillStyle: aFillStyle  self stateMap atPath: #(active disabled over up) put: aFillStyle.  self changedmouseSelectorsInclude: selector  | mouseEventTypes allSubscriptions |  mouseEventTypes := #(mouseDown mouseMove mouseStillDown mouseUp mouseEnter mouseLeave mouseEnterDragging mouseLeaveDragging doubleClick).  allSubscriptions := subscriptions values flatCollect: [:e |  e ].  ^allSubscriptions anySatisfy: [:e |  (mouseEventTypes includes: e event) and: [ e selector = selector ] ]isMenuItemMorph  ^falseupdateColumnMorphsWidth  | rowMorphsWidths |  self columns size > 1 ifFalse: [ ^self ].  rowMorphsWidths := self rowMorphsWidths.  self allNodeMorphs do: [:i |  i updateColumnMorphsWidthWith: rowMorphsWidths ]borderWidth: newWidth  super borderWidth: newWidth.  paragraph ifNotNil: [ self composeToBounds ]newNoButtonFor: aModel  ^self theme newNoButtonIn: self for: aModelannounceDeleted  complexContents ifNotNil: [ complexContents removeDependent: self ].  super announceDeletedchildNodeClassFromItem: anItem  ^PackageClassNodeExampledrawDropShadowOn: aCanvas  | bnd gap |  bnd := self bounds translateBy: self shadowOffset.  gap := self layoutInset.  bnd := bnd topLeft + gap corner: bnd bottomRight + gap.  aCanvas drawString: contents in: bnd font: self fontToUse color: self shadowColordrawSubmorphsOn: aCanvas  | drawBlock |  submorphs isEmpty ifTrue: [ ^self ].  drawBlock := [:canvas |  submorphs reverseDo: [:m |  canvas fullDrawMorph: m ] ].  self clipSubmorphs ifTrue: [ aCanvas clipBy: (aCanvas clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: drawBlock ] ifFalse: [ drawBlock value: aCanvas ]defaultColor  ^self balloonColorcolumns  ^columnsaddEmphasis: anInteger  emphasis := emphasis bitOr: anIntegertabSelector: anObject  tabSelector := anObjectresizeWidget  newPanel  ^self theme newPanelIn: selfisFullscreen  ^self owner isKindOf: FullscreenMorphupdateChildren  self childrenDo: [:child |  child parent: self ]adjustWakeupTimesIfNecessary  | now |  now := Time millisecondClockValue.  (now < lastStepTime or: [ now - lastStepTime > 5000 ]) ifTrue: [ self adjustWakeupTimes: now ]selectedColor  ^self hsvMorph selectedColor alpha: self aMorph valuetoString: anObject  ^anObject asStringchooseDropList: aStringOrText title: aString list: aList  ^self theme chooseDropListIn: self text: aStringOrText title: aString list: aListpositionSubmorphs  super positionSubmorphs.  self submorphsDo: [:aMorph |  aMorph positionSubmorphs ]scaleToMatch: aPoint  | scaleFactor tfm originalScale |  tfm := transform withScale: 1.0.  originalScale := ((tfm localBoundsToGlobal: self renderedMorph fullBounds) corner - (tfm localPointToGlobal: self renderedMorph referencePosition)) r.  originalScale < 1.0 ifTrue: [ originalScale := 1.0 ].  scaleFactor := (aPoint - self referencePosition) r / originalScale.  scaleFactor := scaleFactor < 1.0 ifTrue: [ scaleFactor detentBy: 0.05 atMultiplesOf: 0.25 snap: false ] ifFalse: [ scaleFactor detentBy: 0.1 atMultiplesOf: 0.5 snap: false ].  self adjustAfter: [ self scale: ((scaleFactor min: 8.0) max: 0.1) ]is: anIndex beforeColumn: aColumnIndex  ^anIndex second < aColumnIndexupdateOnImage  self onImage: (target perform: onImageSelector)addListener: anObject to: aListenerGroup  | listeners |  listeners := aListenerGroup.  (listeners notNil and: [ listeners includes: anObject ]) ifFalse: [ listeners ifNil: [ listeners := WeakArray with: anObject ] ifNotNil: [ listeners := listeners copyWith: anObject ] ].  listeners := listeners copyWithout: nil.  ^listenersicon  ^container iconBlock value: self complexContentsmenuBuilder  ^menuBuilder ifNil: [ menuBuilder := (PragmaMenuBuilder pragmaKeyword: self discoveredMenuPragmaKeyword model: self)           menuSpec;           yourself ]treeLineDashes  ^container treeLineDasheslastIndex: anIndex  lastIndex := anIndextopRightCorner  ^self intersectionWithLineSegmentFromCenterTo: bounds topRighttestChooseDirectory  | tmpDirectory answer |  tmpDirectory := FileSystem / 'tmp'.  answer := [ MorphicUIManager new chooseDirectory ] valueSupplyingAnswer: {'Choose Directory' .         tmpDirectory}.  self assert: answer equals: tmpDirectorylockInactivePortions  self isEmbedded ifTrue: [ ^self ].  self submorphsDo: [:m |  m == labelArea ifFalse: [ m lock ] ]newLabelFor: aModel getLabel: labelSel getEnabled: enabledSel  ^self theme newLabelIn: self for: aModel getLabel: labelSel getEnabled: enabledSelfinishedScrolling  | bcu bcd |  bcu := upButton borderStyle baseColor.  bcd := downButton borderStyle baseColor.  self stopStepping.  self scrollBarAction: nil.  upButton borderRaised.  upButton borderStyle baseColor: bcu.  downButton borderRaised.  downButton borderStyle baseColor: bcd.  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStylehandleMouseMove: anEvent  anEvent wasHandled ifTrue: [ ^self ].  anEvent anyButtonPressed ifFalse: [ ^self ].  anEvent wasHandled: true.  self mouseMove: anEventmouseMove: anEvent  target ifNil: [ ^self ].  self theme settings fastDragging ifTrue: [ target doFastReframe: self edgeName ] ifFalse: [ lastMouse at: 1 put: anEvent cursorPoint.        self targetPoint: lastMouse first - lastMouse last.        self positionPoint: lastMouse first - lastMouse second ]borderStyle  | style |  borderColor ifNil: [ ^BorderStyle default ].  borderWidth isZero ifTrue: [ ^BorderStyle default ].  self assureExtension.  style := extension borderStyle ifNil: [ BorderStyle default ].  (borderWidth = style width and: [ borderColor == style style or: [ #simple == style style and: [ borderColor = style color ] ] ]) ifFalse: [ style := borderColor isColor ifTrue: [ BorderStyle width: borderWidth color: borderColor ] ifFalse: [ (BorderStyle perform: borderColor) width: borderWidth ].        extension borderStyle: style ].  ^style trackColorFrom: selfmouseEnter: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseEnter from: sourceMorphsleep  worldState canvas ifNil: [ ^self ].  Cursor normal show.  worldState canvas: nil.  self fullReleaseCachedStateyellowButtonActivity: shiftState  | menu |  self isWorldMorph ifFalse: [ | outerOwner |        outerOwner := self outermostOwnerWithYellowButtonMenu.        outerOwner ifNil: [ ^false ].        outerOwner == self ifFalse: [ ^outerOwner yellowButtonActivity: shiftState ] ].  menu := self buildYellowButtonMenu: ActiveHand.  menu addTitle: self externalName icon: (self iconOrThumbnailOfSize: 28).  menu popUpInWorld: self currentWorld.  ^truenewAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel font: aFont help: helpTextnewGroupbox  ^self theme newGroupboxIn: selfnewFuzzyLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newFuzzyLabelIn: self for: aModel label: aString offset: 1 alpha: 0.5 getEnabled: enabledSelisMorph  ^truehandleMouseDown: anEvent  ^self dispatchMouseDown: anEvent with: morphnameSelector  ^nameSelectoraddSpace: sizePointOrNumber  | space |  space := Morph new.  space extent: sizePointOrNumber asPoint.  space color: Color transparent.  space borderWidth: 0.  self addMorphBack: spaceshowWidget  super showWidget.  table addMorph: actionButton.  table selectedIndex = 0 ifTrue: [ table selectIndex: 1 ]originalCenter  ^originalCentersnapToEdgeIfAppropriate  (self owner isNil or: [ self owner isHandMorph ]) ifTrue: [ ^self ].  self updateBoundsfastTable  ^fastTablesendSettingMessageTo: aModel  aModel perform: (self settingSelector ifNil: [ ^self ]) with: self withoutListWrappersetPosition: aPoint  position := aPointopenInWindowLabeled: aString  ^self openInWindowLabeled: aString inWorld: self currentWorldballoonHelp: aBalloonMorph  self balloonHelp ifNotNil: [:oldHelp |  oldHelp delete ].  aBalloonMorph ifNil: [ self removeProperty: #balloonHelpMorph ] ifNotNil: [ self setProperty: #balloonHelpMorph toValue: aBalloonMorph ]showWidget  self subclassResponsibilitymouseOver: anEvent  self eventHandler ifNotNil: [ self eventHandler mouseOver: anEvent fromMorph: self ]widthOfFullLabelText  ^StandardFonts windowTitleFont widthOfString: labelStringmorphicLayerNumber  ^self valueOfProperty: #morphicLayerNumber ifAbsent: [ 12 ]layoutPolicy: aLayoutPolicy  layoutPolicy := aLayoutPolicyemptySelection  self listManager emptySelectionchangeCellInset: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self cellInset: (newPoint - evt cursorPoint) asIntegerPoint // 5 ].  evt hand attachMorph: handle.  handle startSteppingselectMoreAtBottom  | last |  autoTargetMorph ifNil: [ ^self ].  last := autoTargetMorph index.  last < self allNodeMorphs size ifTrue: [ self autoMultiSelect: (self allNodeMorphs at: last + 1).        self selectionChanged ]gripLayoutFrame  self edgeName == #top ifTrue: [ ^self topLayoutFrame ].  self edgeName == #bottom ifTrue: [ ^self bottomLayoutFrame ].  self edgeName == #left ifTrue: [ ^self leftLayoutFrame ].  ^self rightLayoutFrameselectedItem  ^selectedItemchooseDirectory: title path: path  ^self theme chooseDirectoryIn: self title: title path: pathanchoredMorph  ^anchoredMorphscrollDownInit  | bc |  bc := downButton borderStyle baseColor.  downButton borderInset.  downButton borderStyle baseColor: bc.  self resetTimer.  self scrollBarAction: #doScrollDown.  self doScrollDown.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nil.  downButton fillStyle: self pressedButtonFillStyle.  downButton borderStyle: self pressedButtonBorderStyledefaultColor  ^self class defaultBackgroundColoralert: aStringOrText  ^self alert: aStringOrText title: 'Alert' translatedwrapSelector  ^wrapSelectorattachMorph: m  | delta |  self releaseMouseFocus.  delta := m bounds extent // 2.  m position: self position - delta.  m formerPosition: m position.  targetOffset := m position - self position.  self addMorphBack: mlineBorderColor  ^self borderColordefaultColor  ^Color transparentisPotentialDropTarget  ^isPotentialDropTarget ifNil: [ isPotentialDropTarget := false ]update: aSymbol  aSymbol = #select ifTrue: [ ^self selected: true ].  aSymbol = #deselect ifTrue: [ ^self selected: false ].  aSymbol = #takeHighlight ifTrue: [ ^self takeHighlight ].  super update: aSymboltaskbarButtonFor: aTaskbar  ^aTaskbar theme newTaskbarButtonIn: aTaskbar for: selfhandlesKeyboard: evt  ^truesetType: evtType position: evtPos which: button buttons: evtButtons hand: evtHand stamp: stamp  type := evtType.  position := evtPos.  buttons := evtButtons.  source := evtHand.  wasHandled := false.  whichButton := button.  timeStamp := stampselectionFrameChanged  | frame |  selectedRow ifNil: [ ^self ].  selectedRow = 0 ifTrue: [ ^self ].  selectedRow > self getListSize ifTrue: [ ^self ].  frame := self selectionFrameForRow: selectedRow.  self invalidRect: framenewDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpTextrubberBandCells  ^falseaddEdgeGrips  | t l r lh |  lh := self labelHeight.  t := WindowEdgeGripMorph new     target: self;     position: self position;     edgeName: #top.  t layoutFrame     topOffset: lh negated;     bottomOffset: lh negated + self class borderWidth.  l := WindowEdgeGripMorph new     target: self;     position: self position;     edgeName: #left.  l layoutFrame topOffset: lh negated + 22.  r := WindowEdgeGripMorph new     target: self;     position: self position;     edgeName: #right.  r layoutFrame topOffset: lh negated + 22.  self     addMorph: t;     addMorph: l;     addMorph: r;     addMorph: (WindowEdgeGripMorph new           target: self;           position: self position;           edgeName: #bottom)fitContents  | aMorph aCenter |  aCenter := self center.  submorphs isEmpty ifTrue: [ ^self ].  aMorph := submorphs first.  self extent: aMorph extent + (borderWidth + 6).  self center: aCenter.  aMorph position: aCenter - (aMorph extent // 2)iconColumn: column row: rowIndex  ^FTCellMorph new     addMorphBack: (self iconFor: rowIndex) asMorph;     yourselfgraphicalMorph: aMorph  self addMorph: aMorph.  aMorph lockalarms  ^alarms ifNil: [ alarms := Heap sortBlock: self alarmSortBlock ]buildBorderVertices  ^state buildBorderVerticesremoveNode: aNode  self subclassResponsibilitydrawOn: aCanvas  aCanvas fillRectangle: self bounds fillStyle: self fillStyle borderStyle: self borderStyleshowMenuForIndex: aTuple  | menu rowIndex columnIndex |  rowIndex := aTuple first.  columnIndex := aTuple second.  (rowIndex notNil and: [ (self isIndexSelected: rowIndex) not ]) ifTrue: [ self selectIndex: (self selectionModeStrategy indexFromPosition: aTuple) ].  menu := self dataSource menuColumn: (columnIndex ifNotNil: [ self columns at: columnIndex ]) row: (rowIndex ifNil: [ 0 ]).  (menu isNil or: [ menu isInWorld ]) ifTrue: [ ^self ].  menu popUpInWorld: self currentWorldvScrollValue: scrollValue  scrollBar setValue: scrollValuekeystrokeAction: event  | returnValue |  keystrokeSelector ifNil: [ ^nil ].  returnValue := model perform: keystrokeSelector withEnoughArguments: {event .         self}.  ^returnValue = trueselectedNodePath: aSelectionPath  selectedNodePath := aSelectionPathkeyStrokeArrowUp: event  (self selectionModeStrategy is: self selectedIndex bellowRow: 1) ifFalse: [ ^self ].  self resetFunction.  self selectIndex: (self selectionModeStrategy selectableIndexAbove: self selectedIndex) event: eventmouseDown: evt  (stayUp or: [ self fullContainsPoint: evt position ]) ifFalse: [ ^self deleteIfPopUp: evt ].  self comeToFrontname  ^self method selectormakeBordered  | b |  self borderWidth = 0 ifFalse: [ ^self ].  b := self class borderWidth.  self submorphsDo: [:m |  | l |        l := m layoutFrame.        l ifNotNil: [ l rightFraction = 1 ifTrue: [ l rightOffset: l rightOffset - b ].              l leftFraction = 0 ifTrue: [ l leftOffset: l leftOffset + b ].              l bottomFraction = 1 ifTrue: [ l bottomOffset: l bottomOffset - b ] ] ].  self theme configureWindowBorderFor: selfselected  ^trueaddMyYellowButtonMenuItemsToSubmorphMenus  ^truedefaultHeight  ^ProportionalSplitterMorph splitterWidthcomeToFrontAndAddHalo  self comeToFront.  self addHalorealSearch  | result index |  result := OrderedCollection new.  index := 1.  dataSource rootsItems do: [:item |  (self isMatching: item) ifTrue: [ result add: index ].        index := index + (item numberOfVisibleChildren + 1) ].  ^result asArrayptName  ^#topRightvalueFromContents  ^contentsfont: newFont  font := newFont ifNil: [ TextStyle default defaultFont ].  self adjustHeight.  self changedselectionModeStrategy  ^self table selectionModeStrategyon: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel  self model: anObject.  self getListSelector: getListSel.  self getIndexSelector: getSelectionSel.  self setIndexSelector: setSelectionSel.  self getMenuSelector: getMenuSel.  self keystrokeActionSelector: keyActionSelathensDisplay: item atRow: row on: aCanvas  row = self mouseDownRow ifTrue: [ (aCanvas setStrokePaint: (self colorForRow: row))           width: 1;           dashes: {1} offset: 0.        aCanvas drawShape: (self selectionFrameForRow: row) ]setAsSpacer: aColor  self     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0;     borderWidth: 0;     extent: 1 @ 1;     color: aColorroots  ^self rootsFrom: self allNodeMorphsicon  ^iconsetTarget: aMorph  target := aMorph topRendererOrSelf.  innerTarget := target renderedMorph.  innerTarget wantsDirectionHandles ifTrue: [ self showDirectionHandles: true addHandles: false ].  target hasHalo: truenewPluggableDialogWindow  ^self newPluggableDialogWindow: 'Dialog'stringBoundsToUse  ^self boundsnewTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: menuSelector  ^self theme newTextEditorIn: self for: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: menuSelectorupdateColumnResizersXOffset  self columnResizerFrames with: self columnResizers do: [:frm :resizer |  resizer bounds: (frm withBottom: scroller bottom) ]makeClosed  closed := true.  handles ifNotNil: [ self           removeHandles;           addHandles ].  self computeBoundsgetList  ^model rootNodeschangePageSize: aNumberOrNil  aNumberOrNil ifNotNil: [ self updateForNewPageSize: aNumberOrNil ] ifNil: [ treeMorph removePager ]selectionFillStyle  ^self theme menuItemSelectedFillStyleFor: selfjustDroppedInto: aMorph event: evt  | halo |  super justDroppedInto: aMorph event: evt.  halo := evt hand halo.  (halo notNil and: [ halo target hasOwner: self ]) ifTrue: [ self addHalo: evt ].  stayUp ifFalse: [ evt hand newMouseFocus: self ]select  editor ifNotNil: [ editor select ]rootMenu  popUpOwner ifNil: [ ^self ].  popUpOwner owner ifNil: [ ^self ].  ^popUpOwner owner rootMenuasAthensCurvedOpenPathOn: anAthensCanvas  | points |  points := self computeCurvedSegmentCtrlPoints.  ^anAthensCanvas createPath: [:builder |  self vertices notEmpty ifTrue: [ | prior |              prior := points first.              builder absolute.              builder moveTo: prior second.              builder curveVia: (points at: 2) first to: (points at: 2) second.              prior := points at: 2.              3 to: points size - 1 do: [:index |  | p |                    p := points at: index.                    builder curveVia: prior third and: p first to: p second.                    prior := p ].              builder curveVia: prior third to: points last second ].        builder ]isCursorOverHandle  ^truedrawIcon: aForm on: aCanvas in: aRectangle  | iconForm |  self isEnabled ifTrue: [ iconForm := aForm ] ifFalse: [ iconForm := Form extent: aForm extent depth: 32.        iconForm fillColor: (Color white alpha: 0.003922).        (iconForm getCanvas asAlphaBlendingCanvas: 0.5) drawImage: aForm at: 0 @ 0 ].  aCanvas translucentImage: iconForm at: aRectangle topLeft + (0 @ ((aRectangle height - iconForm height) // 2))nameColumn: column row: rowIndex  ^FTCellMorph new     addMorphBack: (self elementAt: rowIndex) name asStringMorph;     yourselfasAthensPathOn: anAthensCanvas  ^self isCurvy ifTrue: [ self isOpen ifTrue: [ self asAthensCurvedOpenPathOn: anAthensCanvas ] ifFalse: [ self asAthensCurvedPathOn: anAthensCanvas ] ] ifFalse: [ self asAthensLinePathOn: anAthensCanvas ]counter  ^counteropen  self openInWorldpopUpOwner  ^popUpOwneractivate  super activate.  self nonVisibleTabs do: [:t |  t activate ]openPath: anArray  | found |  anArray isEmpty ifTrue: [ ^container setSelectedMorph: nil ].  found := self findPathIn: anArray.  found ifNil: [ ^container setSelectedMorph: nil ].  found isExpanded ifTrue: [ found refreshExpandedState ] ifFalse: [ found toggleExpandedState ].  container adjustSubmorphPositions.  found changed.  anArray size = 1 ifTrue: [ ^container setSelectedMorph: found ].  ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild openPath: anArray allButFirst ]mouseLeave: evt  super mouseLeave: evt.  self hideOverEditableTextCursoranimateMinimize  | tb buttonRect restoredRect rects steps |  tb := self worldTaskbar ifNil: [ ^self ].  buttonRect := ((tb taskButtonOf: self) ifNil: [ ^self ]) bounds.  restoredRect := self isFlexed ifTrue: [ (owner transform globalPointToLocal: fullFrame topLeft) extent: fullFrame extent ] ifFalse: [ fullFrame ].  steps := self theme numberOfStepsForAnimations.  rects := ((steps - 1) / steps to: 0 by: -1 / steps) collect: [:x |  buttonRect interpolateTo: restoredRect at: ((20 raisedTo: x) - 1) / 19 ].  self fastAnimateRectangles: rectsoffset  ^offsetnextToLastPoint  self isCurvy ifTrue: [ curveState ifNil: [ self coefficients ].        ^curveState third ] ifFalse: [ ^vertices at: vertices size - 1 ]worldMenu  ^worldState worldMenusubmorphAfter  | ii |  owner ifNil: [ ^nil ].  ^(ii := owner submorphIndexOf: self) = owner submorphs size ifTrue: [ nil ] ifFalse: [ owner submorphs at: ii + 1 ]isBorderStyle  ^trueaddKern: kernDelta  kern := kern + kernDeltahandlesMouseOverDragging: evt  ^truecontentWidth  | w |  w := 0.  self container allNodeMorphs do: [:n |  w := w max: (n columnMorphAt: self index) width ].  ^wremoveIcon  icon ifNotNil: [ self removeMorph: icon ]theme  ^Smalltalk ui themeisOpaque  ^self valueOfProperty: #isOpaque ifAbsent: [ false ]selectIndex: anArray  self selectIndexes: {anArray}sharesFindReplace  ^falselabelFromString: aString  self labelGraphic: (StringMorph contents: aString) imageFormdone  self delete.  self activeTask ifNotNil: [:t |  t activate ]interactSelector  ^#interacticon: anIcon  anIcon ifNil: [ label icon: nil ] ifNotNil: [ label icon: (AlphaImageMorph new image: anIcon) ]iconSelector  ^iconSelectorstraighten  self setVertices: {vertices first .         vertices last}modalOwner  ^self valueOfProperty: #modalOwnerwantsDroppedMorph: aMorph event: anEvent  aMorph dragTransferType == #dragTransfer ifFalse: [ ^false ].  ^wantsDropSelector ifNil: [ model wantsDroppedMorph: aMorph event: anEvent inMorph: self ] ifNotNil: [ model perform: wantsDropSelector with: aMorph passenger ]forceDisplayUpdate  defaultColor  ^Color yellowshrinkWrap  ^shrinkWrap ifNil: [ shrinkWrap := false ]isSelected  ^isSelectedcolumnsChanged  self removeColumnResizers.  self removeTopHeader.  self buildTopHeader.  self addColumnResizershasSubMenu  ^subMenu notNilwidth  ^bounds widthcolumn  ^columntestSetForward  | t |  cases := {(t := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ t forwardDirection: 180.0.        self assert: t forwardDirection equals: 0.0 ]newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpTextreframedTo: aPoint  self bounds: (self bounds withSideOrCorner: location setToPoint: aPoint)setIndexSelector: aSelector  setIndexSelector := aSelectorhasContentsSelector: aSymbol  self validateSelector: aSymbol.  hasContentsSelector := aSymbolnewSliderFor: aModel getValue: getSel setValue: setSel getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: 0 max: 1 quantum: nil getEnabled: enabledSel help: helpTextrecentlyChanged  ^falseon: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel  getSelectionListSelector := getListSel.  setSelectionListSelector := setListSel.  self on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel.  self beMultipleSelection.  ^selfstep  self shouldCopy = dragHand shiftPressed ifTrue: [ ^self ].  self shouldCopy: dragHand shiftPressed.  self updateCopyIconrootsFrom: aCollectionOfNodes  ^aCollectionOfNodes select: [:each |  each indentLevel isZero ]scroller: aTransformMorph  scroller ifNotNil: [ scroller delete ].  scroller := aTransformMorph.  self addMorph: scroller.  self resizeScrollercellSpacing  | props |  props := self layoutProperties.  ^props ifNil: [ #none ] ifNotNil: [ props cellSpacing ]step  | action |  action := self scrollBarAction.  action ifNotNil: [ self perform: action ]wantsKeyboardFocus  ^self takesKeyboardFocus and: [ self visible and: [ self enabled ] ]getListSelector  ^self dataSource getListSelectornewOverflowRowForAll: aCollectionOfMorphs  ^self theme newOverflowRowIn: self forAll: aCollectionOfMorphspageSearchText: aString  | founds chosen chosenNode |  pageSearchText := aString.  self changed: #pageSearchText.  founds := OrderedCollection new.  self nodeList doWithIndex: [:n :idx |  (n includesSubstringAnywhere: pageSearchText) ifTrue: [ founds add: idx -> n ] ].  founds ifEmpty: [ ^self flash ].  founds size > 1 ifTrue: [ chosen := UIManager default chooseFrom: (founds collect: [:l |  l value ]) values: (founds collect: [:l |  l key ]) lines: nil title: ''.        chosen ifNil: [ ^self ] ] ifFalse: [ chosen := founds first key ].  self currentPage: (self pageOfNodeIndex: chosen).  chosenNode := self nodeList at: chosen.  treeMorph scroller submorphsDo: [:sm |  sm complexContents == chosenNode ifTrue: [ treeMorph listManager setSelectedMorph: sm.              ^treeMorph scrollSelectionIntoView ] ]getListSelector  ^getListSelectortreeLineWidth: anInteger  treeLineWidth := anIntegerheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]isMultiple  ^self subclassResponsibilitynoteNewOwner: o  super noteNewOwner: o.  self defer: [ self adoptPaneColor: self paneColor ]vResizing  ^vResizingtaskbarIcon  self model ifNotNil: [ self model taskbarIcon ifNotNil: [:ico |  ^ico ] ].  ^super taskbarIconnewMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: enabledSel help: helpText  ^self theme newMorphListIn: self for: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: enabledSel help: helpTexthaloMorphs  ^self hands collect: [:h |  h halo ] thenSelect: [:halo |  halo notNil ]collapseNodePath: anArray  | found |  anArray isEmpty ifTrue: [ ^container setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ each complexContents = anArray first ifTrue: [ found := each ] ] ].  found ifNotNil: [ (found isExpanded and: [ anArray size = 1 ]) ifTrue: [ found toggleExpandedState.              container adjustSubmorphPositions ].        found changed.        anArray size = 1 ifTrue: [ ^container listManager setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild collapseNodePath: anArray allButFirst ] ].  ^container setSelectedMorph: nilsetSelectionListSelector  ^setSelectionListSelectoraddHandlesForWorldHalos  | box w |  w := self world ifNil: [ target world ].  self removeAllMorphs.  self bounds: target bounds.  box := w bounds insetBy: 9.  target addWorldHandlesTo: self box: box.  self addNameBeneath: (box insetBy: (0 @ 0 corner: 0 @ 10)) string: innerTarget externalName.  growingOrRotating := false.  self layoutChanged.  self changedoffImageSelector  ^offImageSelectorarrowEvent: event key: aChar  | newIndex targetMorph targetIndex multi |  self allNodeMorphs ifEmpty: [ ^false ].  self listModel okToChange ifFalse: [ ^false ].  self listModel okToDiscardEdits ifFalse: [ ^false ].  newIndex := nil.  targetMorph := lastClickedMorph.  targetMorph ifNotNil: [ (self listModel arrowEvent: event key: aChar target: targetMorph) ifTrue: [ ^true ] ].  targetIndex := targetMorph ifNil: [ 0 ] ifNotNil: [ targetMorph index ].  multi := (event shiftPressed and: [ self isMultiple ]) or: [ self autoMultiSelection ].  aChar = Character arrowDown ifTrue: [ newIndex := targetIndex + 1 ].  aChar = Character arrowUp ifTrue: [ newIndex := targetIndex - 1 max: 1 ].  aChar = Character home ifTrue: [ newIndex := 1 ].  aChar = Character end ifTrue: [ newIndex := self allNodeMorphs size ].  aChar = Character pageUp ifTrue: [ newIndex := targetIndex - self numSelectionsInView max: 1 ].  aChar = Character pageDown ifTrue: [ newIndex := targetIndex + self numSelectionsInView ].  aChar = Character arrowRight ifTrue: [ targetMorph ifNil: [ ^false ].        (targetMorph canExpand and: [ targetMorph isExpanded not ]) ifTrue: [ self toggleExpandedState: targetMorph.              ^true ] ifFalse: [ newIndex := targetIndex + 1 ] ].  aChar = Character arrowLeft ifTrue: [ targetMorph ifNil: [ ^false ].        (targetMorph canExpand and: [ targetMorph isExpanded ]) ifTrue: [ self toggleExpandedState: targetMorph.              ^true ] ifFalse: [ | parent |              parent := targetMorph parent.              parent ifNil: [ newIndex := targetIndex - 1 max: 1 ] ifNotNil: [ self toggleExpandedState: parent.                    newIndex := parent index ] ] ].  newIndex notNil ifTrue: [ self setSelectionIndexFromKeyboard: newIndex multiSelection: multi event: event.        self selectionChanged.        ^true ].  ^falseadjustSubmorphPositionsOf: aCollection startIdx: anIndex startPos: aStartPoint  | p idx |  p := aStartPoint.  idx := anIndex.  aCollection do: [:each |  | h |        h := each height.        each index: idx.        each bounds: (p extent: each width @ h).        maxNodeWidth := maxNodeWidth max: each fullBounds width.        idx := idx + 1.        p := p + (0 @ h) ].  self setScrollDeltas.  ^ptasks  ^tasksremoveMatchString  self setProperty: #matchString toValue: String new.  self displayFiltered: nillayoutFrame: aLayoutFrame  self layoutFrame == aLayoutFrame ifTrue: [ ^self ].  self assureExtension layoutFrame: aLayoutFrame asLayoutFrame.  self layoutChangedpreferredButtonCornerStyle  ^nildrawDropShadowOn: aCanvas  | dropAreas |  dropAreas := self areasRemainingToFill: (self bounds expandBy: self shadowMargins).  (dropAreas anySatisfy: [:rect |  aCanvas isVisible: rect ]) ifFalse: [ ^self ].  self isActive ifTrue: [ self theme drawWindowActiveDropShadowFor: self on: aCanvas ] ifFalse: [ self theme drawWindowInactiveDropShadowFor: self on: aCanvas ]testForTiltedStickyness  | m |  m := Morph new openCenteredInWorld.  cases := Array with: m.  self assert: m topRendererOrSelf isSticky not.  m beSticky.  self assert: m topRendererOrSelf isSticky.  m addFlexShell.  cases := Array with: m topRendererOrSelf.  m topRendererOrSelf rotationDegrees: 45.0.  self assert: m topRendererOrSelf isSticky.  m beUnsticky.  self assert: m topRendererOrSelf isSticky not.  m topRendererOrSelf delete.  ^trueisMatching: anItem  ^(dataSource toString: anItem) beginsWith: patternupdate: aParameter  | state |  aParameter ifNil: [ ^self ].  (aParameter == getLabelSelector or: [ aParameter == getIconSelector ]) ifTrue: [ getIconSelector ifNotNil: [ self icon: (model perform: getIconSelector) ].        self label: (getLabelSelector ifNotNil: [ model perform: getLabelSelector ]) ].  aParameter == getFontSelector ifTrue: [ self font: (model perform: getFontSelector) ].  state := self getModelState.  (state ~= self lastState or: [ getStateSelector isNil and: [ aParameter == #onOffColor ] ]) ifTrue: [ self color: self colorToUse.        self lastState: state ].  aParameter == getEnabledSelector ifTrue: [ ^self enabled: (model perform: getEnabledSelector) ].  getColorSelector ifNotNil: [ | cc |        color = (cc := model perform: getColorSelector) ifFalse: [ self privateColor: cc.              self onColor: color offColor: color.              self changed ] ].  aParameter isArray ifFalse: [ ^self ].  aParameter size == 2 ifFalse: [ ^self ].  aParameter first = #askBeforeChanging: ifTrue: [ self askBeforeChanging: aParameter second ]model: anObject  | oldModel |  oldModel := self dataSource model.  oldModel ifNotNil: [ oldModel removeDependent: self ].  anObject ifNotNil: [ anObject addDependent: self ].  self dataSource model: anObjectvScrollValue: aNumber  self verticalScrollBar setValue: aNumbercontainsPoint: aPoint  (super containsPoint: aPoint) ifFalse: [ ^false ].  container ifNil: [ ^true ].  self startingIndex > text size ifTrue: [ ^super containsPoint: aPoint ].  ^self paragraph containsPoint: aPointfillsOwner: aBoolean  self fillsOwner == aBoolean ifTrue: [ ^self ].  self setContainer: (aBoolean ifTrue: [ wrapFlag := true.              container ifNil: [ TextContainer new for: self minWidth: textStyle lineGrid * 2 ] ifNotNil: [ container fillsOwner: true ] ] ifFalse: [ self avoidsOcclusions ifFalse: [ nil ] ifTrue: [ container fillsOwner: false ] ])commandOrCrontrolKeyPressed: anEvent  ^Smalltalk os isMacOS ifTrue: [ anEvent controlKeyPressed ] ifFalse: [ anEvent commandKeyPressed ]method  ^methodnewFuzzyLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newFuzzyLabelIn: self for: aModel label: aString offset: 1 alpha: 0.5 getEnabled: enabledSelheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]scaledIntoFormOfSize: aSmallInteger  ^self imageForm scaledIntoFormOfSize: aSmallIntegerstringColorToUse  ^self isEnabled ifTrue: [ self isSelected ifTrue: [ self theme menuItemSelectedTextColorFor: self ] ifFalse: [ self theme menuItemNormalTextColorFor: self ] ] ifFalse: [ self theme menuItemDisabledTextColorFor: self ]isKeystroke  ^falsevisible: aBoolean  (extension isNil and: [ aBoolean ]) ifTrue: [ ^self ].  self visible == aBoolean ifTrue: [ ^self ].  self assureExtension visible: aBoolean.  self changed.  owner ifNotNil: [ owner layoutChanged ]initializeDesktopCommandKeySelectors  | dict |  dict := IdentityDictionary new.  self defaultDesktopCommandKeyTriplets do: [:trip |  | messageSend |        messageSend := MessageSend receiver: trip second selector: trip third.        dict at: trip first put: messageSend ].  self setProperty: #commandKeySelectors toValue: dict.  ^dictnewGroupbox: aString  ^self theme newGroupboxIn: self label: aStringframeRectangle: aRectangle on: aCanvas  aCanvas frameAndFillRectangle: aRectangle fillColor: Color transparent borderWidth: self width topLeftColor: self topLeftColor bottomRightColor: self bottomRightColornewWindowFor: aModel title: titleString  ^self theme newWindowIn: self for: aModel title: titleStringhorizontalScrollBarHeight  ^horizontalScrollBar ifNil: [ 0 ] ifNotNil: [ self isHorizontalScrollBarVisible ifFalse: [ ^0 ].        self scrollBarThickness ]exportAs: anExtension using: aWriter  | reference |  reference := UIManager default chooseForSaveFileReference: 'Save Morph as ' , anExtension asUppercase extensions: {anExtension} path: self externalName , '.' , anExtension.  reference ifNotNil: [ aWriter putForm: self imageForm onFileNamed: reference ]verticalPlacement  ^verticalPlacementextent: newExtent  | oldW oldH wasHShowing wasVShowing noVPlease noHPlease minH minW |  oldW := self width.  oldH := self height.  wasHShowing := self hIsScrollbarShowing.  wasVShowing := self vIsScrollbarShowing.  noVPlease := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  noHPlease := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  minH := self scrollBarThickness + 16.  minW := self scrollBarThickness + 20.  noVPlease ifTrue: [ noHPlease ifTrue: [ minH := 1.              minW := 1 ] ifFalse: [ minH := self scrollBarThickness ] ] ifFalse: [ noHPlease ifTrue: [ minH := self scrollBarThickness + 5 ] ].  super extent: (newExtent max: minW @ minH).  self     resizeScrollBars;     resizeScroller;     hideOrShowScrollBars.  (self height ~~ oldH or: [ wasHShowing ~~ self hIsScrollbarShowing ]) ifTrue: [ self vIsScrollbarShowing ifTrue: [ self vSetScrollDelta ] ].  (self width ~~ oldW or: [ wasVShowing ~~ self vIsScrollbarShowing ]) ifTrue: [ self hIsScrollbarShowing ifTrue: [ self hSetScrollDelta ] ]setOffset: newOffset angle: newAngle scale: newScale  transform := MorphicTransform offset: newOffset angle: newAngle scale: newScale.  self changedupdatePager  self pager ifNotNil: [ self pager buildPanel ]newCloseButton  ^self newCloseButtonFor: selfokToClose  model ifNil: [ ^true ].  ^model okToClosedrawLinesToNextSiblingOn: aCanvas hasToggle: hasToggle  | myBounds nextSibBounds vLineX myCenter vLineTop vLineBottom myTheme ldelta gap |  myBounds := self toggleRectangle.  nextSibBounds := self nextSibling toggleRectangle.  myCenter := myBounds center.  vLineX := myCenter x.  gap := container notExpandedForm extent y // 2 + 1.  vLineTop := myCenter y + (self hasToggle ifTrue: [ gap ] ifFalse: [ 0 ]).  vLineBottom := nextSibBounds center y - (self nextSibling hasToggle ifTrue: [ gap ] ifFalse: [ 0 ]).  myTheme := self theme.  ldelta := container treeLineWidth // 2.  aCanvas frameRectangle: ((vLineX - ldelta) @ vLineTop corner: (vLineX + ldelta + (container treeLineWidth \\ 2)) @ vLineBottom) width: container treeLineWidth colors: (myTheme treeLineColorsFrom: self lineColor) dashes: self treeLineDashesopenOn: aClass  | window |  self rootClass: aClass.  window := StandardWindow new model: self.  window title: aClass name , ' hierarchy'.  window addMorph: self treeMorph fullFrame: LayoutFrame identity.  window themeChanged.  window openInWorld.  ^windowspotterActDefault  ^self isTopWindow ifTrue: [ self comeToFront ] ifFalse: [ self activate ]browseItem  Smalltalk tools browser openOnClass: self itemrotationDegrees  ^0.0searchText: aString  | search text result |  aString isEmptyOrNil ifTrue: [ ^#() ].  result := OrderedCollection new.  search := aString trimBoth asLowercase.  1 to: self numberOfRows do: [:rowIndex |  text := (self elementWrapped: (self elementAt: rowIndex)) contents trimBoth asLowercase.        (text beginsWith: search) ifTrue: [ result add: rowIndex ] ].  ^result asArraynewSize  ^newSizesplitterAbove  | splitters |  splitters := (self siblingSplitters select: [:each |  each top > self top and: [ self overlapsHorizontal: each ] ]) asSortedCollection: [:a :b |  a top < b top ].  ^splitters ifEmpty: [ nil ] ifNotEmpty: [:s |  s first ]headerRow  ^headerRowmouseMove: evt  self basicIsSticky ifFalse: [ self fastFramingOn ifTrue: [ self doFastFrameDrag: evt startPoint ] ifFalse: [ self grabSelfOrTopRenderer: evt ] ]hue  ^(self selectedColor hue / 359 * 255) asIntegertaskListButtonFor: aTasklist  ^self theme newTaskListButtonIn: aTasklist for: selfrestoreDefaultPaneColor  self setStripeColorsFrom: self paneColorbeIconTop  iconPosition := #top.  self update: getIconSelectorhighlighted  ^highlightedtakesKeyboardFocus  ^truewantsToBeTopmost  ^truedeleteIfPopUp  stayUp ifFalse: [ self topRendererOrSelf delete ].  (popUpOwner notNil and: [ popUpOwner isMenuItemMorph ]) ifTrue: [ popUpOwner isSelected: false.        popUpOwner owner isMenuMorph ifTrue: [ popUpOwner owner deleteIfPopUp ] ]useRoundedCorners  self cornerStyle: #roundedcolumn: anObject  column := anObjectpatternFromString: aString  ^[ aString asRegexIgnoringCase ] on: RegexSyntaxError do: [:ex |   ]model: aModel  model := aModelspotterItemsFor: aStep  < spotterOrder: 10>  self flag: #pharoFixMe.  ^aStep listProcessor     title: 'Items';     candidatesLimit: Float infinity;     allCandidates: [ self items ];     itemName: #contents;     itemIcon: [:item |  item icon ];     actLogic: [:item :step |  item hasSubMenu ifTrue: [ step diveIn ] ifFalse: [ item spotterActDefault.              step exit ] ];     filter: GTFilterSubstringreferencePositionInWorld  ^self pointInWorld: self referencePositiondisableTableLayout  ^disableLayoutinitializeLayout  self     changeTableLayout;     layoutInset: 16;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     extent: self minimumExtentwidth  ^widthborderStyleForSymbol: aStyleSymbol  | aStyle existing |  aStyle := BorderStyle borderStyleForSymbol: aStyleSymbol asSymbol.  aStyle ifNil: [ self error: 'bad style' ].  existing := self borderStyle.  aStyle     width: existing width;     baseColor: existing baseColor.  ^(self canDrawBorder: aStyle) ifTrue: [ aStyle ] ifFalse: [ nil ]wantsToBeTopmost  ^truedrawTodayOn: aCanvas  | text textHeight textTopLeft textWidth textBox |  text := 'Today: ' , (Date today printFormat: #(2 1 3 $  3 1 1)).  textWidth := self weekdayFont widthOfString: text.  textHeight := self weekdayFont height.  textTopLeft := self bounds bottomCenter translateBy: (textWidth // -2) @ (textHeight negated - 5).  textBox := textTopLeft extent: textWidth @ textHeight.  touchPoints at: textBox put: #handleTodayTouched.  aCanvas drawString: text at: textTopLeft font: self weekdayFont color: Color graynewDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel help: helpText  ^self newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: nil useIndex: true help: helpTextinitializeTasks  self tasks: ((self currentWorld submorphs collect: [:m |  m taskbarTask ]) select: [:m |  m notNil ]) asOrderedCollectionthemeChanged  super themeChanged.  morph ifNotNil: #themeChangedpattern: aString  super pattern: aString.  regex := self patternFromString: aStringdelete  hand ifNotNil: [ hand showTemporaryCursor: nil ].  super deletetrackColorFrom: aMorph  baseColor ifNil: [ self color: aMorph raisedColor ]hasTwoColorDash  ^self dashedBorder notNil and: [ self dashedBorder size > 2 ]modalUnlockFrom: aSystemWindow  self unlockpattern: aStringOrRegex  pattern := aStringOrRegexcloseable  ^closeableopenAsIsIn: aWorld  aWorld addMorphCentered: self.  self allMorphs do: [:m |  m layoutChanged ].  aWorld startSteppingSubmorphsOf: self.  self announceOpened.  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ]initializeFor: aTaskbar  | lm lab labSize |  labSize := self labelSizeIn: aTaskbar.  lab := self labelOfSize: labSize.  self addEmphaseTo: lab.  lm := self theme newRowIn: aTaskbar for: {(self model taskbarIcon ifNil: [ ^nil ]) asMorph .         lab}.  lm cellInset: 2.  self     label: lm font: self theme buttonFont;     extent: self minExtent;     hResizing: #rigid;     vResizing: #rigid;     useSquareCorners;     getMenuSelector: #taskbarButtonMenu:.  self initializeAnnouncements.  lab color: (self model isCollapsed ifTrue: [ self theme taskbarItemLabelColorForCollapsed: self ] ifFalse: [ self theme taskbarItemLabelColorForExpanded: self ])includesSubstringAnywhere: aString  ^(Array with: self asString) includesSubstringAnywhere: aStringsetDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedprogress  ^bar progresstestFillInTheBlank  | answer |  answer := [ MorphicUIManager new request: 'Your favorite color?' ] valueSupplyingAnswer: #('Your favorite color?' 'blue').  self assert: answer equals: 'blue'splitters  ^self submorphsSatisfying: [:each |  each isKindOf: ProportionalSplitterMorph ]updateSelectionFromModel  ^self listManager updateSelectionFromModelheightToDisplayInList: aList  ^self contents heightToDisplayInList: aListsetSelectedMorph: aMorph  model perform: (setSelectionSelector ifNil: [ ^self ]) with: aMorph complexContentsscrollDeltaHeight  ^10isRadioButton  ^isRadioButtoncanBeDragged  ^model isDraggableNode: selfdefaultTreeMorph  ^super defaultTreeMorph     chunkSize: 100;     yourselfmouseEnter: event  super mouseEnter: event.  self wantsKeyboardFocus ifFalse: [ ^self ].  self keyboardFocusOnMouseDown ifFalse: [ self takeKeyboardFocus ]abort: aStringOrText  ^self abort: aStringOrText title: 'Error' translatedtransformedBy: aTransform  aTransform isIdentity ifTrue: [ ^self ].  ^self center: (aTransform localPointToGlobal: self center)takeKeyboardFocus  self activeHand newKeyboardFocus: selfdrawNullTextOn: aCanvas  aCanvas fillRectangle: bounds color: (self backgroundColor ifNil: [ Color transparent ])resizeContainerFrom: topLefPoint to: bottomRightPoint  ^topLefPoint corner: bottomRightPointselectionColorToUse: aColor  aColor = self selectionColorToUse ifTrue: [ ^self ].  aColor ifNil: [ self removeProperty: #selectionColorToUse ] ifNotNil: [ self setProperty: #selectionColorToUse toValue: aColor ]topHeader  ^topHeaderlastRefresh  ^lastRefresh ifNil: [ lastRefresh := 0 ]scale: aNumber  scale = aNumber ifTrue: [ ^self ].  scale := aNumber.  self     cachedForm: nil;     changed;     changed: #scalekeyboardFocusChange: gotFocus  self announceKeyboardFocusChange: gotFocusspotterItemsFor: aStep  < spotterOrder: 10>  self hasSubMenu ifTrue: [ self subMenu spotterItemsFor: aStep ]getMenuSelector: aSelector  self dataSource getMenuSelector: aSelectorprivateSubmorphs: aCollection  submorphs := aCollectionvisibleSystemWindows  ^self submorphsSatisfying: [:m |  m isSystemWindow and: [ m visible ] ]addService: aService for: serviceUser  aService addServiceFor: serviceUser toMenu: selfhSetScrollDelta  | pd |  pd := self hPageDelta.  self hScrollbar     scrollDelta: pd / 10 pageDelta: pd;     interval: self hScrollbarInterval;     setValue: self hScrollbarValueactivate  super activate.  self world ifNil: [ ^self ].  self rememberedKeyboardFocus ifNil: [ self defaultFocusMorph ifNotNil: [:m |  m takeKeyboardFocus ] ]hExtraScrollRange  ^5addHandles  | tri |  self removeHandles.  handles := OrderedCollection new.  tri := Array with: 0 @ -4 with: 4 @ 3 with: -3 @ 3.  vertices withIndexDo: [:vertPt :vertIndex |  | handle newVert |        handle := EllipseMorph newBounds: (Rectangle center: vertPt extent: 8 @ 8) color: (self handleColorAt: vertIndex).        handle on: #mouseMove send: #dragVertex:event:fromHandle: to: self withValue: vertIndex.        handle on: #mouseUp send: #dropVertex:event:fromHandle: to: self withValue: vertIndex.        handle on: #click send: #clickVertex:event:fromHandle: to: self withValue: vertIndex.        self addMorph: handle.        handles addLast: handle.        (closed or: [ 1 = vertices size or: [ vertIndex < vertices size ] ]) ifTrue: [ newVert := PolygonMorph vertices: (tri collect: [:p |  p + ((vertPt + (vertices atWrap: vertIndex + 1)) // 2) ]) color: Color green borderWidth: 1 borderColor: Color black.              newVert on: #mouseDown send: #newVertex:event:fromHandle: to: self withValue: vertIndex.              self addMorph: newVert.              handles addLast: newVert ] ].  self isCurvy ifTrue: [ self           updateHandles;           layoutChanged ].  self changedworldMorphs  ^self world submorphs , ((self tasks select: [:t |  t morph owner = self world activeHand ]) collect: [:t |  t morph ])chooseDropList: aStringOrText title: aString list: aList  ^self theme chooseDropListIn: self text: aStringOrText title: aString list: aListorderedTasks  ^taskslayoutProperties: newProperties  layoutProperties := newPropertiesbuttonMorph  ^buttonMorphnewToolbar  ^self theme newToolbarIn: selfmouseDown: event  self column sortDataSource: self table dataSourcedefaultBackgroundColor  ^self theme windowColorFor: selfisLineMorph  ^closed notisDropEvent  ^falseactionSelector: aSymbolOrString  (nil = aSymbolOrString or: [ 'nil' = aSymbolOrString or: [ aSymbolOrString isEmpty ] ]) ifTrue: [ ^actionSelector := nil ].  actionSelector := aSymbolOrString asSymboldetachAllKeymapCategories  self kmDispatcher detachAllKeymapCategoriesselectionRectsFrom: characterBlock1 to: characterBlock2  | line1 line2 rects cb1 cb2 w |  characterBlock1 <= characterBlock2 ifTrue: [ cb1 := characterBlock1.        cb2 := characterBlock2 ] ifFalse: [ cb2 := characterBlock1.        cb1 := characterBlock2 ].  cb1 = cb2 ifTrue: [ w := self caretWidth.        ^Array with: (cb1 topLeft - (w @ 0) corner: cb1 bottomLeft + ((w + 1) @ 0)) ].  line1 := self lineIndexForCharacter: cb1 stringIndex.  line2 := self lineIndexForCharacter: cb2 stringIndex.  line1 = line2 ifTrue: [ ^Array with: (cb1 topLeft corner: cb2 bottomRight) ].  rects := OrderedCollection new.  rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).  line1 + 1 to: line2 - 1 do: [:i |  | line |        line := lines at: i.        (line left = rects last left and: [ line right = rects last right ]) ifTrue: [ | lastRect |              lastRect := rects removeLast.              rects add: (lastRect bottom: line bottom) ] ifFalse: [ rects add: line rectangle ] ].  rects addLast: ((lines at: line2) topLeft rectangle: cb2 bottomLeft).  ^rectschildrenDo: aBlock  self roots do: aBlockprepareForScaling  ^self addFlexShellbuildButtonWithIcon  ^PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: nilchanged  self assureExtension.  extension fillStyle: self fillStyleToUse.  color := self fillStyle asColor.  super changedsetFramesForLabelArea  self theme configureWindowLabelAreaFrameFor: selfleftArrowStroked: evt  | keyboardFocus |  super leftArrowStroked: evt.  keyboardFocus := evt hand keyboardFocus.  keyboardFocus isMenubar ifTrue: [ keyboardFocus keyStroke: evt ]addCustomMenuItems: aMenu hand: aHand  super addCustomMenuItems: aMenu hand: aHand.  aMenu addUpdating: #opacityString selector: #changeOpacityheader  ^header ifNil: [ header := (Morph new extent: 0 @ 0) color: Color transparent ]rowHeight: rowIndex  ^50drawSubmorphsOn: aCanvas  submorphs ifEmpty: [ ^self ].  aCanvas transformBy: transform clippingTo: (aCanvas clipRect intersect: owner clippingBounds ifNone: [ ^self ]) during: [:myCanvas |  | top bottom |        top := self topVisibleRowForCanvas: myCanvas.        bottom := self bottomVisibleRowForCanvas: myCanvas startingAt: top.        bottom to: top by: -1 do: [:row |  | m |              m := submorphs basicAt: row.              self drawRawColorOn: myCanvas forSubmorph: m.              myCanvas fullDrawMorph: m ] ] smoothing: smoothing.  owner withTreeLines ifTrue: [ owner drawLinesOn: aCanvas ].  owner enabled ifFalse: [ aCanvas fillRectangle: owner innerBounds fillStyle: (owner paneColor alpha: 0.2) ]columns  ^columnssendEvent: anEvent focus: focusHolder clear: aBlock  | result |  focusHolder ifNotNil: [ ^self sendFocusEvent: anEvent to: focusHolder clear: aBlock ].  ActiveEvent := anEvent.  result := owner processEvent: anEvent.  ActiveEvent := nil.  ^resultframeOval: aRectangle on: aCanvas  aCanvas frameOval: aRectangle width: self width color: self colorgetSelectionListSelector  ^getSelectionListSelectorexpandedFormForMorph: aMorph  ^(aMorph selected and: [ self selectionColor luminance < 0.7 ]) ifTrue: [ self theme whiteTreeExpandedForm ] ifFalse: [ self theme treeExpandedForm ]proceed: aStringOrText  ^self proceed: aStringOrText title: 'Proceed' translatedposition  ^self subclassResponsibilitykeystrokeSelector  ^keystrokeSelectorcellColumn: column row: rowIndex  ^FTCellMorph new     cellInset: 5;     addMorphBack: (self iconFor: rowIndex) asMorph;     addMorphBack: (self elementAt: rowIndex) name asMorph;     yourselfpointSize  ^size value: selfgridVisible  ^self hasProperty: #gridVisibleeditBalloonHelpContent: aString  | reply |  reply := UIManager default multiLineRequest: 'Edit the balloon help text for ' translated , self externalName initialAnswer: (aString ifNil: [ self noHelpString ] ifNotNil: [ aString ]) answerHeight: 200.  reply ifNil: [ ^self ].  (reply isEmpty or: [ reply asString = self noHelpString ]) ifTrue: [ self setBalloonText: nil ] ifFalse: [ self setBalloonText: reply ]sortElements: aSortFunction  unsortedElements ifNil: [ unsortedElements := self rootsItems ].  self rootItem children: (self rootItem children sorted: aSortFunction)drawOn: aCanvas  | tRect sRect columnScanner colorToUse columnLeft |  tRect := self toggleRectangle.  sRect := bounds withLeft: tRect right + 4.  self drawToggleOn: aCanvas in: tRect.  colorToUse := complexContents preferredColor ifNil: [ self theme textColor ].  icon ifNotNil: [ aCanvas translucentImage: icon at: sRect left @ (self top + ((self height - icon height) // 2)).        sRect := sRect left: sRect left + icon width + 2 ].  (container columns isNil or: [ (contents asString indexOf: Character tab) = 0 ]) ifTrue: [ sRect := sRect top: (sRect top + sRect bottom - self fontToUse height) // 2.        contents treeRenderOn: aCanvas bounds: sRect color: colorToUse font: self fontToUse from: self ] ifFalse: [ columnLeft := sRect left.        columnScanner := contents asString readStream.        container columns do: [:width |  | columnData columnRect |              columnRect := columnLeft @ sRect top extent: width @ sRect height.              columnData := columnScanner upTo: Character tab.              columnData isEmpty ifFalse: [ aCanvas drawString: columnData in: columnRect font: self fontToUse color: colorToUse ].              columnLeft := columnRect right + 5 ] ]tabHitWithEvent: anEvent  | currentFocus fieldList anIndex itemToHighlight |  currentFocus := anEvent hand keyboardFocus.  fieldList := self allMorphs select: [:aMorph |  aMorph wouldAcceptKeyboardFocusUponTab and: [ aMorph isLocked not ] ].  fieldList isEmpty ifTrue: [ ^self ].  anIndex := fieldList indexOf: currentFocus ifAbsent: [ nil ].  itemToHighlight := fieldList atWrap: (anIndex ifNotNil: [ anEvent shiftPressed ifTrue: [ anIndex - 1 ] ifFalse: [ anIndex + 1 ] ] ifNil: [ 1 ]).  anEvent hand newKeyboardFocus: itemToHighlight.  itemToHighlight editor selectAll.  itemToHighlight invalidRect: itemToHighlight boundsvExtraScrollRange  ^self scrollDeltaHeightminExtentHorizontal: aMorph  | inset minX minY maxX maxY n size width height |  size := properties minCellSize asPoint.  minX := size x.  minY := size y.  size := properties maxCellSize asPoint.  maxX := size x.  maxY := size y.  inset := properties cellInset asPoint.  n := 0.  width := height := 0.  aMorph submorphsDo: [:m |  | sizeY sizeX |        m disableTableLayout ifFalse: [ n := n + 1.              size := m minExtent.              sizeX := size x.              sizeY := size y.              sizeX < minX ifTrue: [ sizeX := minX ] ifFalse: [ sizeX > maxX ifTrue: [ sizeX := maxX ] ].              sizeY < minY ifTrue: [ sizeY := minY ] ifFalse: [ sizeY > maxY ifTrue: [ sizeY := maxY ] ].              width := width + sizeX.              sizeY > height ifTrue: [ height := sizeY ] ] ].  n > 1 ifTrue: [ width := width + ((n - 1) * inset x) ].  ^minExtentCache := width @ heightwantsKeyboardFocusOnMouseDown  ^self wantsKeyboardFocus and: [ self valueOfProperty: #wantsKeyboardFocusOnMouseDown ifAbsent: [ false ] ]showActions  | list cls selector adder |  list := SortedCollection new.  adder := [:mrClass :mrSel |  list add: (RGMethodDefinition realClass: mrClass selector: mrSel) ].  self eventHandler ifNotNil: [ list := self eventHandler methodRefList.        (self eventHandler handlesMouseDown: nil) ifFalse: [ adder value: HandMorph value: #grabMorph: ] ].  #(#keyStroke: #mouseDown: #mouseEnter: #mouseLeave: #mouseMove: #mouseUp: #doButtonAction) do: [:sel |  cls := self class whichClassIncludesSelector: sel.        cls ifNotNil: [ cls == Morph ifFalse: [ adder value: cls value: sel ] ] ].  (self respondsTo: #actionSelector) ifTrue: [ selector := self actionSelector.        cls := self target class whichClassIncludesSelector: selector.        cls ifNotNil: [ cls == Morph ifFalse: [ adder value: cls value: selector ] ] ].  Smalltalk tools messageList browse: list title: 'Actions of ' , self printStringaddIcon  self addMorph: closeIcon fullFrame: (LayoutFrame identity           bottomFraction: 0;           leftFraction: 1;           topOffset: 6 * self displayScaleFactor;           leftOffset: self iconRightOffset negated - (12 * self displayScaleFactor);           rightOffset: self iconRightOffset negated;           bottomOffset: 18 * self displayScaleFactor;           yourself)clipSubmorphs  ^trueshowTemporaryCursor: cursorOrNil  self showTemporaryCursor: cursorOrNil hotSpotOffset: 0 @ 0initializeLabelMorph  labelMorph := LabelMorph new     extent: 0 @ 0;     yourselfdefaultTreeMorph  ^super defaultTreeMorph     pageSize: 100;     yourselfenabled: aBoolean  dragItemSelector: aSymbol  dragItemSelector := aSymbol.  aSymbol ifNotNil: [ self dragEnabled: true ]initialize  super initialize.  self     fitTargetOwner: false;     edgeName: #right;     extent: self defaultWidth @ self defaultHeight;     hResizing: #spaceFill;     vResizing: #spaceFillwrapDirection  ^#nonetextHighlightColor  ^self valueOfProperty: #textHighlightColor ifAbsent: [ Color red ]toggleClosable  mustNotClose ifTrue: [ self makeClosable ] ifFalse: [ self makeUnclosable ]elements: anObject  elements := anObjectisLastColumn  ^container columns last = selfmouseLeaveDragging: anEvent onItem: aMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersalert: aStringOrText title: aString configure: aBlock  ^self theme alertIn: self text: aStringOrText title: aString configure: aBlockindexForInserting: aMorph at: aPoint in: someMorph  ^1doubleClick: event  (self selectionModeStrategy selectableIndexContainingPoint: event cursorPoint) ifNotNil: [:index |  self doAnnounce: (FTStrongSelectionChanged index: index event: event) ]changed  self extent > (200 @ 200) ifTrue: [ (target notNil and: [ target ~~ self world ]) ifTrue: [ (self fullBounds areasOutside: target bounds) do: [:r |  self invalidRect: r ] ].        self submorphsDo: [:m |  m changed ] ] ifFalse: [ super changed ]isMultipleSelection  ^self selectionStrategy isMultipleendShapeColor: aColor  self borderColor: aColor.  self isClosed ifTrue: [ self color: aColor ]canResizeColumn  ^container owner isResizablesetPageInterval: anInterval  currentPageFirstIndex := anInterval first.  self showCurrentPage.  self changed: #currentPagecontents  ^Array newcheckClickableZone  | topLeft icon |  topLeft := self computeCheckTopLeft.  icon := self retrieveCheckIcon.  ^topLeft corner: icon extent + topLeftstoreOn: aStream  aStream nextPutAll: type.  aStream space.  self timeStamp storeOn: aStream.  aStream space.  position x asInteger storeOn: aStream.  aStream space.  position y asInteger storeOn: aStream.  aStream space.  buttons storeOn: aStream.  aStream space.  keyValue storeOn: aStream.  aStream space.  charCode storeOn: aStream.  aStream space.  scanCode storeOn: aStreamselectableIndexContainingPoint: aPoint  ^self tableContainer rowIndexContainingPoint: aPointmodel: anObject  model := anObjectactualClass  ^FTColumnspInitializeColumsFrom: aModel  self columns: aModel columnsdrawOn: aCanvas  | stringColor |  self shouldBeHighlighted ifTrue: [ aCanvas fillRectangle: self bounds fillStyle: self selectionFillStyle.        stringColor := self selectionTextColor ] ifFalse: [ stringColor := color ].  self drawIconOn: aCanvas.  aCanvas drawString: self contents in: self menuStringBounds font: self fontToUse color: stringColor.  self drawSubmenuMarkerOn: aCanvasinitializeSelectedIndexes  selectedIndexes := #().  highlightedIndexes := #()getRootsSelector: aSelector  getRootsSelector := aSelector.  self update: getRootsSelectortestSelectedRowIndex  table selectIndex: 3.  self assert: strategy selectedRowIndex equals: 3.  table selectIndex: 4.  self assert: strategy selectedRowIndex equals: 4pasteBuffer  ^PasteBuffercanScrollDown  ^value < 1hideScrollBarsIndefinitely: bool  self hideVScrollBarIndefinitely: bool.  self hideHScrollBarIndefinitely: boolisOn  ^state == #onhasLeftMorphsChanged  ^(leftMorphs isEmpty and: [ enteredMorphs position = 0 ]) notaddToggleItemsToHaloMenu: aCustomMenu  super addToggleItemsToHaloMenu: aCustomMenu.  aCustomMenu addUpdating: #enabledString target: self selector: #toggleEnabledinitialize  indentation := 0.  super initialize.  self cellInset: 2minWidth  ^self valueOfProperty: #minWidth ifAbsent: [ self measureContents x ]enabled: aBoolean  self submorphs do: [:each |  each enabled: aBoolean ]adjustSubmorphPositions  | p |  p := 0 @ 0.  scroller submorphsDo: [:each |  | h |        h := each height.        each privateBounds: (p extent: each width @ h).        p := p + (0 @ h) ].  self     changed;     layoutChanged;     setScrollDeltashandlesMouseDown: event  ^trueremoveWindow: aSystemWindow  aSystemWindow isCloseable ifFalse: [ ^self ].  aSystemWindow announcer unsubscribe: self.  self tabGroup removePage: aSystemWindow.  aSystemWindow configureForUnembedding.  aSystemWindow deleteDiscardingChanges.  self tabGroup pages ifEmpty: [ self owner delete ]wantsDroppedMorph: aMorph event: anEvent  ^aMorph dragTransferType == #dragTransfer ifTrue: [ dropItemSelector ifNil: [ ^false ].        wantsDropSelector ifNil: [ ^true ].        model perform: wantsDropSelector with: aMorph passenger ] ifFalse: [ self model wantsDroppedMorph: aMorph event: anEvent inMorph: self ]target  ^targethIsScrollbarShowing  ^submorphs includes: hScrollBarwantsToBeDroppedInto: aMorph  ^aMorph isWorldMorph or: [ self embeddable ]thumbColor  ^self sliderColorshowFirstRowSelection  self deprecated: 'Use #showFirstSelection instead' transformWith: '`@receiver showFirstRowSelection' -> '`@receiver showFirstSelection'.  ^self showFirstSelectioninitializeDownButton  downButton := self theme newScrollBarDownButtonFor: self.  downButton color: self thumbColor.  downButton on: #mouseDown send: #scrollDownInit to: self.  downButton on: #mouseUp send: #finishedScrolling to: self.  self updateDownButtonImage.  downButton     borderWidth: 1;     borderColor: Color lightGray.  downButton cornerStyle: (self theme scrollbarButtonCornerStyleIn: self window).  downButton on: #mouseUp send: #finishedScrolling: to: self.  downButton on: #mouseEnter send: #mouseEnterDownButton: to: self.  downButton on: #mouseLeave send: #mouseLeaveDownButton: to: self.  self addMorph: downButtonupdateList  super rootItems: (self initialRootItems select: [:p |  (self pattern matchesIn: p name) notEmpty ]).  super updateListcreateCollapseBox  ^self theme createCollapseBoxFor: selfrowMorphForNode: aNode inColumn: aColumn  | rm |  rm := Morph new     color: Color transparent;     layoutPolicy: RowLayout new;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: aColumn container columnInset @ aColumn container rowInset;     listDirection: #leftToRight;     cellPositioning: #leftCenter;     cellInset: 4 @ 0;     yourself.  rm addMorph: self.  aColumn isFirstColumn ifTrue: [ | icon |        icon := aColumn container iconBlock value: aNode.        icon ifNotNil: [ rm addMorph: icon asMorph ].        rm layoutInset: 0 @ aColumn container rowInset ].  ^rmchildren  self subclassResponsibilityisMultiple  ^multipleSelection ifNil: [ multipleSelection := false ]selectedItemOrItemsOrNil  | theItems |  theItems := self selectedNodeList collect: [:each |  each item ].  ^theItems isEmpty ifTrue: [ nil ] ifFalse: [ theItems ]newAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletionisExplicit  ^false= aBorderStyle  ^super = aBorderStyle and: [ self borders = aBorderStyle borders ]step  | viewee |  viewee := self actualViewee.  viewee ifNil: [ self stopStepping.        ^self ].  self changeddisabledStyle  ^disabledStylebuildPanel  | widgets nextButton lastPageButton searchEditor |  self removeAllMorphs.  pageSize ifNil: [ ^self ].  self atBottom: (treeMorph scrollValue y <= self verticalScrollbarFrontier and: [ treeMorph vIsScrollable ]) not.  widgets := OrderedCollection new.  (self nodeList size > self lastIndex and: [ self atBottom ]) ifTrue: [ pageSizeEditor := self textEntryLabel: 'Page size' get: #pageSizeToString set: #chunkSizeFromString: help: 'Change the page size or the number of pages if the input begins with "/"' translated class: String.        pageSizeEditor hResizing: #rigid.        pageSizeEditor width: (self preferedFont widthOfString: '1000000').        widgets add: pageSizeEditor.        nextButton := self buttonLabel: self class smallToRightIcon actionSelector: #nextPage arguments: {} getEnabled: #notOnLastPage help: 'Next page'.        widgets add: nextButton.        lastPageButton := self buttonLabel: self class smallToRightEndIcon actionSelector: #fullList arguments: {} getEnabled: #notOnLastPage help: 'Last page'.        widgets add: lastPageButton.        widgets add: (self spacer: 10) ].  self withSearch ifTrue: [ searchEditor := self textEntryLabel: '' get: #pageSearchText set: #pageSearchText: help: 'Enter a text correspondig to your search' translated class: String.        searchEditor ghostText: 'Searched text'.        widgets add: searchEditor.        widgets add: (self spacer: 10) ].  widgets add: (self spacer: 1).  widgets add: (LabelMorph contents: self lastIndex asString , ' / ' , self nodeList size asString font: self preferedFont).  self addAllMorphs: widgets.  self updateContentsselectHandsToDrawForDamage: damageList  ^hands select: [:hand |  hand needsToBeDrawn and: [ hand hasChanged or: [ self is: hand overlappingDamagedAreaIn: damageList ] ] ]top: aNumber  self position: bounds left @ aNumbertestInform  | answer |  [ MorphicUIManager new inform: 'blah' ] on: Exception do: [:ex |  answer := ex messageText ].  self assert: answer equals: 'blah'addedMorph: aMorph  extent: newExtent  newExtent = bounds extent ifTrue: [ ^self ].  bounds isWide ifTrue: [ super extent: (newExtent x max: self sliderThickness * 2) @ newExtent y ] ifFalse: [ super extent: newExtent x @ (newExtent y max: self sliderThickness * 2) ].  self     removeAllMorphs;     initializeSlidernewTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletion  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletionpredominantDockingBarsOfChastes: predominantChastes  | allDockingBars byChaste byArrival |  (self owner isNil or: [ self owner isHandMorph ]) ifTrue: [ ^#() ].  allDockingBars := self owner dockingBars.  byChaste := allDockingBars select: [:each |  predominantChastes includes: each edgeToAdhereTo ].  (predominantChastes includes: self edgeToAdhereTo) ifFalse: [ ^byChaste ].  byChaste := byChaste reject: [:each |  each edgeToAdhereTo = self edgeToAdhereTo ].  byArrival := allDockingBars select: [:each |  each edgeToAdhereTo = self edgeToAdhereTo ].  byArrival := byArrival copyAfter: self.  ^byChaste , byArrivalsticky  ^stickyselectedDisabledFillStyle  ^self theme controlButtonSelectedDisabledFillStyleFor: selfapply: delta  | oldBounds |  oldBounds := target bounds.  target bounds: (oldBounds origin + (0 @ delta y) corner: oldBounds corner + (delta x @ 0))dismissViaHalo  self setProperty: #lastPosition toValue: self positionInWorld.  self dismissMorphhHideScrollBar  self hIsScrollbarShowing ifFalse: [ ^scroller offset: self hMargin negated @ scroller offset y ].  self removeMorph: hScrollBar.  scroller offset: self hMargin negated @ scroller offset y.  self resetExtentdisable  self subclassResponsibilitylineBorderWidth: anInteger  self borderWidth: anIntegerstoreValue  ^self owner owner storeValueallowDeselection  self allowsDeselection: truegenerateDropFilesEvent: evtBuf  | position buttons modifiers stamp numFiles dragType |  stamp := evtBuf second.  stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].  dragType := evtBuf third.  position := evtBuf fourth @ evtBuf fifth.  buttons := 0.  modifiers := evtBuf sixth.  buttons := buttons bitOr: (modifiers bitShift: 3).  numFiles := evtBuf seventh.  dragType = 4 ifTrue: [ owner borderWidth: 0.        ^DropFilesEvent new setPosition: position contents: numFiles hand: self ].  dragType = 1 ifTrue: [ owner           borderWidth: 4;           borderColor: owner color asColor negated ].  dragType = 2 ifTrue: [  ].  dragType = 3 ifTrue: [ owner borderWidth: 0 ].  ^nilactiveHand  | world |  world := self world ifNil: [ ^ActiveHand ].  ^world activeHand ifNil: [ ^ActiveHand ]expandAllTo: aDepth  self subclassResponsibilitywantsRoundedCorners  ^(self theme windowPreferredCornerStyleFor: self) == #roundedviewBox: newViewBox  (self viewBox isNil or: [ self viewBox extent ~= newViewBox extent ]) ifTrue: [ worldState canvas: nil ].  super viewBox: newViewBox.  worldState handsDo: [:hand |  hand releaseKeyboardFocus ].  self fullRepaintNeededhandlesMouseStillDown: anEvent  ^(self innerBounds containsPoint: anEvent position) notnewContentMorph  | p |  p := PanelMorph new     roundedCorners: #(2 3 4);     changeTableLayout;     layoutInset: 4;     cellInset: 8;     vResizing: #spaceFill;     hResizing: #spaceFill.  p borderStyle: (self theme tabPanelBorderStyleFor: self).  ^pupdateTabs  | tabsAndControls selectedTab |  tabsAndControls := self tabsAndControls.  self removeAllMorphs.  tabsAndControls ifEmpty: [ ^self ].  selectedTab := self selectedTab.  self tabs do: [:t |  t selected: t == selectedTab ].  self     addAllMorphs: self tabsAndControls;     adoptPaneColorkeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  paragraph ifNotNil: [ paragraph focused: aBoolean ].  aBoolean ifTrue: [ self hasFocus ifFalse: [ self editor ].        self showOverEditableTextCursor ] ifFalse: [ self world ifNotNil: [:w |  w handsDo: [:h |  h keyboardFocus == self ifTrue: [ ^self ] ].              self releaseEditor ].        self hideOverEditableTextCursor ].  self manageCursor.  self focusChangedfitInWorld  self bounds: (self bounds translatedAndSquishedToBeWithin: self world bounds)simulateMiddleClick  self simulateClickWith: MouseEvent blueButtonenabled: anObject  enabled = anObject ifTrue: [ ^self ].  enabled := anObject.  self changed: #enabled.  self     adoptPaneColor: self paneColor;     changedcreateCommandContextBy: aPresenter forDropAt: anEvent  | dropElementIndex receiverElement |  dropElementIndex := self container rowIndexContainingPoint: anEvent position.  dropElementIndex ifNil: [ ^super createCommandContextBy: aPresenter forDropAt: anEvent ].  receiverElement := dataSource elementAt: dropElementIndex.  ^aPresenter createCommandContextForSelection: {receiverElement}highlightedIndex  ^self highlightedIndexes ifNotEmpty: #first ifEmpty: [ 0 ]aboutToBeGrabbedBy: aHand  self beFloating.  self updateBounds.  self updateColor.  (self bounds containsPoint: aHand position) ifFalse: [ self center: aHand position ]setTimeStamp: stamp  timeStamp := stampdrawingClass  ^ImageMorphchangeDisableTableLayout  self disableTableLayout: self disableTableLayout not.  self layoutChangedtestMoving  | t oldBounds event |  window := SystemWindow labelled: 'foo'.  t := 0.  event := nil.  window openInWorld.  oldBounds := window bounds.  window announcer when: WindowMoved do: [:ann |  t := t + 1.        event := ann ].  self assert: t equals: 0.  self assert: event isNil.  window position: 50 @ 50.  self assert: t equals: 1.  self assert: event oldPosition equals: oldBounds origin.  self assert: event newPosition equals: 50 @ 50.  window position: 50 @ 50.  self assert: t equals: 1.  window extent: 50 @ 60.  self assert: t equals: 1windowsSatisfying: windowBlock  | windows |  windows := OrderedCollection new.  self submorphs do: [:m |  m embeddedWindowOrNil ifNotNil: [ (windowBlock value: m) ifTrue: [ windows addLast: m ] ] ].  ^windowsdataBounds  ^self visibleBounds withTop: self container topHeader bottomrunStepMethodsIn: aWorld  | queue nextInQueue |  queue := self class deferredUIMessages.  [ (nextInQueue := queue nextOrNil) isNil ] whileFalse: [ nextInQueue value ].  self runLocalStepMethodsIn: aWorld.  Transcript stepGlobaldefaultFadingFactor  ^0.04initialize  super initialize.  counter := 0wantsToBeTopmost  ^trueneedsRefreshExposedRows  ^needsRefreshExposedRowstoggleExpandedState: aMorph  aMorph toggleExpandedState.  client innerWidgetChangedwantsKeyboardFocusOnShiftClick  ^owner topRendererOrSelf wantsKeyboardFocusFor: selfsilentlySelected: aBoolean  (state isSelectedMatchingTheState: aBoolean) ifTrue: [ ^self ].  state := state newStateForSelected: aBoolean.  aBoolean ifTrue: [ self showCloseIcon ]deleteBalloonTarget: aMorph  self balloonHelp: nildefaultBorderColor  ^self theme menuBorderColorwantsSteps  ^self subMorph wantsStepsdrawDropShadowOn: aCanvas  aCanvas translateBy: self shadowOffset during: [:shadowCanvas |  shadowCanvas roundShadowCornersOf: self during: [ (shadowCanvas isVisible: self bounds) ifTrue: [ shadowCanvas fillRectangle: self bounds fillStyle: self shadowColor ] ] ]fillStyle  ^fillStyle ifNil: [ self color ]updateSliderBounds  slider bounds: self totalSliderArea.  sliderShadow bounds: self totalSliderArea.  self computeSliderpreferredKeyboardPosition  | pos |  pos := super preferredKeyboardPosition.  ^pos + (self bounds: self bounds in: self currentWorld) topLeftsetDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedcollapseAll  self requestView: MorphTreeChangeRequest collapseAllenabled  ^enabledchildrenBlock  ^childrenBlockhandleWindowEvent: anEvent  ^self dispatchWindowEvent: anEvent with: morphlabel  ^self labelMorph contentshands  ^handsmouseDown: evt  | aMorph selectors |  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ].  aMorph := self itemFromPoint: evt position.  (aMorph notNil and: [ aMorph inToggleArea: (aMorph point: evt position from: self) ]) ifTrue: [ ^self toggleExpandedState: aMorph event: evt ].  evt yellowButtonPressed ifTrue: [ (self yellowButtonActivity: evt shiftPressed) ifTrue: [ ^self ] ].  aMorph ifNil: [ ^super mouseDown: evt ].  aMorph highlightForMouseDown.  selectors := Array with: #click: with: nil with: nil with: (self dragEnabled ifTrue: [ #startDrag: ] ifFalse: [ nil ]).  evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: 10mouseDownRow  ^self valueOfProperty: #mouseDownRowensureAtLeastOneColumn  self columns ifNotEmpty: [ ^self ].  self addColumn: self class defaultColumnnormalLabel: anObject  normalLabel := anObjectthemedFillStyle  ^self theme morphTreeColumnFillStyleFor: selfisRowIndexExceding: rowIndex  | headerPresentModificator nextRowIndexByPosition heightWithSpacing |  headerPresentModificator := headerRow ifNotNil: [ 1 ] ifNil: [ 0 ].  nextRowIndexByPosition := rowIndex - self table showIndex + 1 + headerPresentModificator.  heightWithSpacing := self table rowHeight + self table intercellSpacing y.  ^nextRowIndexByPosition * heightWithSpacing > self heightnodeListSelector  ^#rootNodesaddHandles  self addCircleHandlesisSortingEnabled  ^falseendInteraction  | m |  (target isInWorld not or: [ owner isNil ]) ifTrue: [ ^self ].  [ target isFlexMorph and: [ target hasNoScaleOrRotation ] ] whileTrue: [ m := target firstSubmorph.        target removeFlexShell.        target := m ].  self isInWorld ifTrue: [ self comeToFront.        self addHandles ]layoutBounds  | inset box |  inset := self layoutInset.  box := self innerBounds.  inset isZero ifTrue: [ ^box ].  ^box insetBy: insethandlesKeyboard: evt  (super handlesKeyboard: evt) ifTrue: [ ^true ].  ^evt keyCharacter = Character escape or: [ self defaultButton notNil and: [ evt keyCharacter = Character cr ] ]acceptDroppingMorph: aMorph event: event  self dataSource dropItemSelector ifNotNil: [ ^super acceptDroppingMorph: aMorph event: event ].  self model acceptDroppingMorph: aMorph event: event inMorph: self.  self refreshasAthensLinePathOn: anAthensCanvas  | verts |  verts := self adjustSegmentPointsForArrows.  ^anAthensCanvas createPath: [:builder |  verts notEmpty ifTrue: [ builder absolute.              builder moveTo: verts first.              verts allButFirstDo: [:p |  builder lineTo: p ] ].        self isClosed ifTrue: [ builder close ].        builder ]windowEvent: anEvent  selectRowIndex: rowIndex event: event  self deprecated: 'Use #selectIndex:event: instead' transformWith: '`@receiver selectRowIndex: `@statements1 event: `@statements2' -> '`@receiver selectIndex: `@statements1 event: `@statements2'.  self selectIndex: rowIndex event: eventgetStateSelector: anObject  getStateSelector := anObject.  self updateSelectionselectNextTask  self selectTask: (self tasks after: self activeTask ifAbsent: [ self tasks isEmpty ifFalse: [ self tasks first ] ])firstChild  ^firstChildrotationDegrees: degrees  scaledImage  | i |  i := self form.  i boundingBox area = 0 ifTrue: [ ^i ].  (self layout == #scaled and: [ self extent ~= i extent ]) ifTrue: [ ^i magnify: i boundingBox by: self extent / i extent smoothing: 2 ].  (self layout == #scaledAspect and: [ self extent ~= i extent ]) ifTrue: [ ^self width / i width > (self height / i height) ifTrue: [ i magnify: i boundingBox by: self height / i height smoothing: 2 ] ifFalse: [ i magnify: i boundingBox by: self width / i width smoothing: 2 ] ].  self scale ~= 1 ifTrue: [ ^i magnify: i boundingBox by: self scale smoothing: 2 ].  ^iisStepping: aMorph  lastStepMessage ifNotNil: [ lastStepMessage receiver == aMorph ifTrue: [ ^true ] ].  stepList do: [:entry |  entry receiver == aMorph ifTrue: [ ^true ] ].  ^falsenewYesButtonFor: aModel  ^self theme newYesButtonIn: self for: aModelselectRowIndex: rowIndex event: event  self deprecated: 'Use #selectIndex:event: instead.' transformWith: '`@receiver selectRowIndex: `@statements1 event: `@statements2' -> '`@receiver selectIndex: `@statements1 event: `@statements2'.  self selectIndex: rowIndex event: eventdoneExtending  otherSelection ifNotNil: [ selectedItems := otherSelection selectedItems , selectedItems.        otherSelection delete.        self setOtherSelection: nil ].  self changed.  self layoutChanged.  super privateBounds: ((Rectangle merging: (selectedItems collect: [:m |  m fullBounds ])) expandBy: 8).  self changed.  self addHaloexpandedToggleImage  ^expandedToggleImage ifNil: [ expandedToggleImage := ImageMorph new form: self expandedForm ]arguments  ^argumentstarget  ^targetlistChanged  listItems := (1 to: self getListSize) collect: [:i |  self getListItem: i ].  self removeAllMorphs.  self extent: 0 @ 0.  listItems do: [:i |  self addMorphBack: i ].  selectedRow := nil.  selectedRows := PluggableSet integerSet.  maxWidth := nil.  self     adjustHeight;     adjustWidth.  listItems do: [:i |  i layoutChanged ].  self changedinvokeAt: aPoint in: aWorld  ^self invokeAt: aPoint in: aWorld allowKeyboard: self menuKeyboardControlbackgroundMorph  ^backgroundMorphheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]newAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletiondragNDropEnabled  self separateDragAndDrop.  ^self dragEnabled and: [ self dropEnabled ]colorToUse  ^self paneColorsystemWindows  ^self submorphsSatisfying: [:m |  m isSystemWindow ]treeMorphClass  ^MorphTreeMorphlabel: aLabel  label := aLabel.  icon setBalloonText: label maxLineLength: 100realWindowExtent: aValue  realWindowExtent := aValueisActivated  ^truelocalPointToGlobal: aPoint  ^self point: aPoint in: nilprintOn: aStream  aStream nextPut: $[.  aStream     nextPutAll: self cursorPoint printString;     space.  aStream     nextPutAll: type;     space.  aStream nextPutAll: self modifierString.  aStream nextPutAll: self buttonString.  aStream     nextPutAll: timeStamp printString;     space.  aStream nextPutAll: self windowIndex printString.  aStream nextPut: $]step  stringMorph contents: work printStringisMultiSelection  ^numberOfSelectedTabs > 1colorForRow: row  ^(self isRowSelected: row) ifTrue: [ self theme selectionTextColor ] ifFalse: [ self color ]initializeJob: aJob  super initialize.  lock := Semaphore forMutualExclusion.  job := aJob.  hasResult := false.  lastRefresh := 0.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #leftCenter;     listCentering: #center;     hResizing: #spaceFill;     vResizing: #shrinkWrap.  labelMorph := StringMorph contents: job title font: StandardFonts defaultFont.  bar := JobProgressBarMorph new.  bar     on: #mouseUp send: #debug to: self;     hResizing: #spaceFill.  self updateLayoutareasRemainingToFill: aRectangle  ^Array with: aRectanglecellSize  ^cellSizerelabelPage: aMorph with: aStringOrMorph  self tabSelectorMorph relabelTab: (self tabOfPage: aMorph) with: aStringOrMorphaddSimpleHandlesForWorldHalos  self addHandlesForWorldHalosbuildToggleButtonWithIcon  ^PluggableToggleButtonMorph on: self getState: nil action: #toggleAction: label: #label icon: #icon menu: nilnewYesButton  ^self newYesButtonFor: selfbuildButtonNoLabel  ^PluggableButtonMorph on: self getState: nil action: #action label: nil icon: #icon menu: nilleftMargin: lm  left := lmsetPaneRectsFromBounds  | layoutBounds |  layoutBounds := self layoutBounds.  paneMorphs do: [:m |  | frame right top box bottom left |        frame := m layoutFrame.        box := m bounds.        frame ifNotNil: [ left := box left - layoutBounds left - (frame leftOffset ifNil: [ 0 ]).              right := box right - layoutBounds left - (frame rightOffset ifNil: [ 0 ]).              top := box top - layoutBounds top - (frame topOffset ifNil: [ 0 ]).              bottom := box bottom - layoutBounds top - (frame bottomOffset ifNil: [ 0 ]).              frame leftFraction: left / layoutBounds width asFloat.              frame rightFraction: right / layoutBounds width asFloat.              frame topFraction: top / layoutBounds height asFloat.              frame bottomFraction: bottom / layoutBounds height asFloat ] ]setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedhighlight  self color: self highlightColoraddCustomMenuItems: aCustomMenu hand: aHandMorph  super addCustomMenuItems: aCustomMenu hand: aHandMorph.  smoothing = 1 ifTrue: [ aCustomMenu add: 'turn on smoothing' selector: #smoothingOn ] ifFalse: [ aCustomMenu add: 'turn off smoothing' selector: #smoothingOff ]addMenuButton  | topOffset rightOffset |  rightOffset := self actionOffset.  topOffset := (self height - 16) * self displayScaleFactor // 2.  self addMorph: menuButton fullFrame: (LayoutFrame identity           bottomFraction: 0;           leftFraction: 1;           rightOffset: rightOffset negated;           leftOffset: rightOffset negated - self menuButtonWidth;           topOffset: topOffset;           bottomOffset: topOffset + self menuButtonHeight)newColumn: controls  ^self theme newColumnIn: self for: controlsgetFirstCharacter  | aString |  ^(aString := text string) isEmpty ifTrue: [ '·' ] ifFalse: [ aString first asString ]newLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newLabelIn: self for: aModel label: aString getEnabled: enabledSelupdateButton: evt  self enabled ifFalse: [ ^self ].  evt isMouseDown ifTrue: [ self buttonMorph state == #on ifTrue: [ ^self buttonMorph state: #repressed ].        self buttonMorph state == #off ifTrue: [ ^self buttonMorph state: #pressed ] ].  evt isMouseUp ifTrue: [ self buttonMorph state == #repressed ifTrue: [ ^self buttonMorph                 state: #off;                 doButtonAction ].        self buttonMorph state == #pressed ifTrue: [ ^self buttonMorph                 state: #on;                 doButtonAction ] ].  evt isMove ifTrue: [ (self containsPoint: evt cursorPoint) ifTrue: [ self buttonMorph state == #on ifTrue: [ ^self buttonMorph state: #repressed ].              self buttonMorph state == #off ifTrue: [ ^self buttonMorph state: #pressed ] ] ifFalse: [ self buttonMorph state == #repressed ifTrue: [ ^self buttonMorph state: #on ].              self buttonMorph state == #pressed ifTrue: [ ^self buttonMorph state: #off ] ] ]buildMetaMenu: evt  | menu |  menu := UIManager default newMenuIn: self for: self.  self addStandardHaloMenuItemsTo: menu hand: evt hand.  ^menutestScrolling  | myMorph pane t |  window := SystemWindow labelled: 'foo'.  window extent: 300 @ 200.  myMorph := Morph new.  myMorph extent: 10000000000 @ 1000000000.  pane := ScrollPane new.  pane scroller addMorph: myMorph.  window addMorph: pane fullFrame: LayoutFrame identity.  t := 0 @ 0.  window openInWorld.  window announcer when: WindowScrolling do: [:ann |  t := t + ann step ].  pane hScrollBarValue: 10.  pane vScrollBarValue: 5.  window delete.  self assert: t equals: 10 @ 5.  window := nilselectableIndexAfter: anIndex  self shouldNotImplementoffset  ^transform offset + self innerBounds topLeftmaxCellSize  ^SmallInteger maxValinitialize  super initialize.  self     disabledStyle: #plain;     enabled: trueactualScreenSize  ^self worldState worldRenderer actualScreenSizepageSize: anIntegerOrNil  self setPageSize: anIntegerOrNil.  self announce: (MorphTreeChangeRequest pageSize: anIntegerOrNil)indentGap  ^indentGap ifNil: [ indentGap := 20 ]expand: aMorph to: level  | allChildren |  aMorph toggleExpandedState.  allChildren := OrderedCollection new: 10.  aMorph recursiveAddTo: allChildren.  allChildren do: [:each |  ((each canExpand and: [ each isExpanded not ]) and: [ level > 0 ]) ifTrue: [ self expand: each to: level - 1 ] ]privateOwner: newOwner  super privateOwner: newOwner.  container ifNotNil: [ newOwner ifNotNil: [ newOwner isWorldOrHandMorph ifTrue: [ self setContainer: nil ] ] ]secondarySelection  ^secondarySelectiontransform: aTransform  transform := aTransformis: anIndex aboveRow: aRowIndex  ^self subclassResponsibilityinvalidRectsFullBounds: aRectangle  ^totalRepaint ifTrue: [ Array with: aRectangle ] ifFalse: [ invalidRects copy ]bindingOf: varName  ^self editor bindingOf: varNamenewStaticItemFrom: anItem  ^FTStaticBasicItem new     data: anItem data;     depth: anItem depth;     children: #();     yourselfadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  originalColor := paneColor.  self borderStyle baseColor: paneColor.  self updateColoronLastPage  ^self currentPageLastIndex = self nodeList sizesaturation  ^(self selectedColor saturation * 255) asIntegerassuredCanvas  (self canvas isNil or: [ self canvas extent ~= self viewBox extent or: [ self canvas form depth ~= Display depth ] ]) ifTrue: [ self canvas: (Display defaultCanvasClass extent: self viewBox extent) ].  ^self canvasresizeCursor  ^Cursor resizeForEdge: self edgeNamenewCloseButton  ^self newCloseButtonFor: selfhandleKeystroke: anEvent  ^self dispatchDefault: anEvent with: morphstep  owner ifNotNil: [ ^self runLocalStepMethods ].  ^super stepregisterRequestHandlers  self model announcer when: MorphTreeChangeRequest send: #changeRequest: to: selftestWindowLabelling  | labels win |  labels := #().  self currentWorld announcer when: WindowLabelled do: [:ann |  win := ann window.        labels := labels copyWith: ann label ].  window := SystemWindow labelled: 'foo'.  window openInWorld.  self assert: win equals: window.  self assert: labels equals: #('foo').  window setLabel: 'bar'.  self assert: win equals: window.  self assert: labels equals: #('foo' 'bar')id: anObject  id := anObjectpageMorphs: anObject  pageMorphs := anObjectframeRectangle3: aRectangle on: aCanvas  | r |  r := aRectangle insetBy: self width // 2.  self width odd ifTrue: [ r := r insetBy: (0 @ 0 corner: 1 @ 1) ].  aCanvas     line: r topLeft + (3 @ 0) to: r topRight - (3 @ 0) width: self width color: self color;     line: r topRight + (-2 @ 1) to: r topRight + (-1 @ 1) width: self width color: self color;     line: r topRight + (-1 @ 1) to: r topRight + (-1 @ 2) width: self width color: self color;     line: r topRight + (0 @ 3) to: r bottomRight - (0 @ 3) width: self width color: self color;     line: r bottomRight - (1 @ 2) to: r bottomRight - (1 @ 1) width: self width color: self color;     line: r bottomRight - (1 @ 1) to: r bottomRight - (2 @ 1) width: self width color: self color;     line: r bottomRight - (3 @ 0) to: r bottomLeft + (3 @ 0) width: self width color: self color;     line: r bottomLeft - (-2 @ 1) to: r bottomLeft - (-1 @ 1) width: self width color: self color;     line: r bottomLeft - (-1 @ 1) to: r bottomLeft - (-1 @ 2) width: self width color: self color;     line: r bottomLeft - (0 @ 3) to: r topLeft + (0 @ 3) width: self width color: self color;     line: r topLeft + (1 @ 2) to: r topLeft + (1 @ 1) width: self width color: self color;     line: r topLeft + (1 @ 1) to: r topLeft + (2 @ 1) width: self width color: self colorremoveAlarm: aSelector  | scheduler |  scheduler := self alarmScheduler.  scheduler ifNotNil: [ scheduler removeAlarm: aSelector for: self ]argumentsProvider: anObject argumentsSelector: aSelector  argumentsProvider := anObject.  argumentsSelector := aSelectoraddBorderStyleMenuItems: aMenu hand: aHandMorph  invalidRect: damageRect from: aMorph  worldState recordDamagedRect: (damageRect intersect: self bounds ifNone: [ ^self ])acceptContents  self updateFromParagraphaddLabel  self addMorph: label fullFrame: (LayoutFrame identity           topFraction: 1;           leftOffset: self labelRightOffset;           topOffset: label height negated - self labelBottomOffset + 2;           yourself)forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]computeBounds  self hasSubmorphs ifTrue: [ bounds := (transform localBoundsToGlobal: (Rectangle merging: (self submorphs collect: [:m |  m fullBounds ]))) truncated expandBy: 1 ].  fullBounds := boundstopRendererOrSelf  | top topsOwner |  owner ifNil: [ ^self ].  self isWorldMorph ifTrue: [ ^self ].  top := self.  topsOwner := top owner.  [ topsOwner notNil and: [ topsOwner isRenderer ] ] whileTrue: [ top := topsOwner.        topsOwner := top owner ].  ^topaddAction: anAction  actions add: anActiontimeStamp  ^timeStamp ifNil: [ timeStamp := Time millisecondClockValue ]chooseColor: aColor title: title  ^self theme chooseColorIn: self title: title color: aColorupdateBounds  self     width: self owner width;     snapToEdgeIfAppropriatecolor  ^nilcomputeRaisedColors  | base light dark w colorArray param hw |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  colorArray := Array new: w * 2.  hw := 0.5 / w.  0 to: w - 1 do: [:i |  param := true ifTrue: [ 0.5 + (hw * i) ] ifFalse: [ 0.5 + (hw * (w - i)) ].        colorArray at: i + 1 put: (base mixed: param with: light).        colorArray at: colorArray size - i put: (base mixed: param with: dark) ].  ^colorArraytarget: aMorph  target := aMorph.  aMorph ifNotNil: [ self fillStyle: (aMorph theme resizerGripNormalFillStyleFor: self) ]setType: evtType position: evtPos buttons: evtButtons hand: evtHand  type := evtType.  position := evtPos.  buttons := evtButtons.  source := evtHand.  wasHandled := falselocked  ^lockedmouseOverForKeyboardFocus  ^self class mouseOverForKeyboardFocusselectedMorph  ^self scroller submorphs at: self selectionIndexescapePressed  ^self editView yellowButtonActivity: falsetable  ^self owner ifNotNil: #tablelistDirection  ^listDirectiontextEntry: aStringOrText title: aString entryText: defaultEntryText  ^self theme textEntryIn: self text: aStringOrText title: aString entryText: defaultEntryTextclickVertex: ix event: evt fromHandle: handle  vLeftoverScrollRange  ^self scrollTarget height - self scrollBounds height max: 0lineColorBlock  ^lineColorBlockhighlightIndexes: anArray  anArray = self highlightedIndexes ifTrue: [ ^self ].  self basicHighlightIndexes: anArray.  (self hasHighlighted and: [ (self isIndexVisible: self highlightedIndex) not ]) ifTrue: [ self moveShowIndexTo: self highlightedIndexes first.        ^self ].  (self hasSelection and: [ (self isIndexVisible: self selectedIndex) not ]) ifTrue: [ self moveShowIndexTo: self selectedIndex.        ^self ].  self refreshlayoutInset: aNumber  self assureTableProperties layoutInset: aNumber.  self layoutChangednodeMorphOfNode: aNode  ^self allNodeMorphs detect: [:m |  m complexContents = aNode ] ifNone: [  ]topLeftColor  ^width = 1 ifTrue: [ self color twiceDarker ] ifFalse: [ self color darker ]forwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectioncornerStyle: aSymbol  super cornerStyle: aSymbol.  self tabs do: [:t |  t cornerStyle: aSymbol ]setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedscrollDelta: d1 pageDelta: d2  scrollDelta := d1.  pageDelta := d2updatablePanes  ^updatablePanes ifNil: [ updatablePanes := #() ]actAsExecutor  self breakDependentslocalSubmorphBounds  localBounds ifNil: [ self hasSubmorphs ifFalse: [ ^nil ].        localBounds := self firstSubmorph fullBounds topLeft corner: owner maxNodeWidth @ (self lastSubmorph fullBounds bottom + owner extraScrollRange) ].  ^localBoundshandlesMouseDown: evt  ^self innerBounds containsPoint: evt cursorPointalarmScheduler  ^self worldasBrick  ^GLMMorphBrick on: selfsizes  ^#(#small #medium #large)getStateSelector: anObject  getStateSelector := anObjectheaderButtonLabel: aLabel font: aFont target: aReceiver actionSelector: aSelector arguments: aCollection  self headerButton.  self header label: aLabel font: aFont.  self header actionSelector: aSelector.  self header target: aReceiver.  self header arguments: aCollectionstopStepping  | w |  w := self world.  w ifNotNil: [ w stopStepping: self ]centeredAlert: aStringOrText title: aString configure: aBlock  ^self theme centeredAlertIn: self text: aStringOrText title: aString configure: aBlockarrowKey: aChar  | keyEvent |  keyEvent := aChar asciiValue.  keyEvent = 31 ifTrue: [ self setSelectionIndex: self getSelectionIndex + 1.        ^true ].  keyEvent = 30 ifTrue: [ self setSelectionIndex: (self getSelectionIndex - 1 max: 1).        ^true ].  keyEvent = 1 ifTrue: [ self setSelectionIndex: 1.        ^true ].  keyEvent = 4 ifTrue: [ self setSelectionIndex: scroller submorphs size.        ^true ].  keyEvent = 11 ifTrue: [ self setSelectionIndex: (self getSelectionIndex - self numSelectionsInView max: 1).        ^true ].  keyEvent = 12 ifTrue: [ self setSelectionIndex: self getSelectionIndex + self numSelectionsInView.        ^true ].  keyEvent = 29 ifTrue: [ selectedMorph ifNotNil: [ selectedMorph canExpand ifTrue: [ selectedMorph isExpanded not ifTrue: [ self toggleExpandedState: selectedMorph ] ifFalse: [ self setSelectionIndex: self getSelectionIndex + 1 ] ] ].        ^true ].  keyEvent = 28 ifTrue: [ selectedMorph ifNotNil: [ selectedMorph isExpanded ifTrue: [ self toggleExpandedState: selectedMorph ] ifFalse: [ | i |                    selectedMorph indentLevel > 0 ifTrue: [ i := self getSelectionIndex max: 1.                          [ i > 1 and: [ (scroller submorphs at: i) indentLevel >= selectedMorph indentLevel ] ] whileTrue: [ i := i - 1 max: 1 ].                          self setSelectionIndex: i ] ] ].        ^true ].  ^falseautoMultiSelect: aTargetMorph  autoTargetMorph := aTargetMorph.  self autoAction ifNotNil: [:act |  self from: firstClickedMorph to: aTargetMorph do: [:nd |  self perform: act with: nd ].        self selectionUpdateFromViewWhile: [ | selHolder |              selHolder := self newSelectionHolderWithNodePath: nil.              self listModel selection: selHolder ].        self selectionChanged.        self scrollToShow: aTargetMorph contentBounds ]newButtonLabel: aString  ^self newButtonLabelFor: nil label: aString getEnabled: nilblackGradientMorph  ^Morph new     hResizing: #spaceFill;     vResizing: #spaceFill;     fillStyle: self blackGradientstring  ^text stringnewGroupbox: aString for: control  ^self theme newGroupboxIn: self label: aString for: controldoActivate  InputEventFetcher default startUp.  InputEventSensor installMouseDecodeTable.  InputEventSensor default startUp.  Display setExtent: self actualScreenSize depth: 32.  Display beDisplay.  canvas := nil.  display := nil.  self assuredCanvas.  DisplayScreen refreshHostWindowTitle.  Display forceDisplayUpdate.  world displayWorldgtInspectorSubmorphsIn: composite  < gtInspectorPresentationOrder: 80>  composite tree     title: 'Submorphs';     rootsExpanded;     display: [:each |  {each} ];     icon: [:each |  | morphForm |        morphForm := each imageForm.        (morphForm extent x > 0 and: [ morphForm extent y > 0 ]) ifTrue: [ (morphForm scaledToSize: 16 @ 16) asMorph ] ifFalse: [ Form extent: 16 @ 16 ] ];     children: [:each |  each submorphs ];     when: [:each |  each submorphs notNil and: [ each hasSubmorphs ] ]questionWithoutCancel: aStringOrText  ^self questionWithoutCancel: aStringOrText title: 'Question' translatedsearchedElement: anElement  searchedElement := anElementborderStyleToUse  ^self enabled ifTrue: [ self theme sliderNormalBorderStyleFor: self ] ifFalse: [ self theme sliderDisabledBorderStyleFor: self ]beFloating  self adhereTo: #nonelayoutPolicy  ^layoutPolicymax: aNumber  (self sliderMorph ifNil: [ ^self ]) max: aNumberlast  ^lastreinitializeTable  table dataSource: initialDataSource.  ^trueuseSquareCorners  self cornerStyle: #squarepotentialDropMorph: aMorph  potentialDropMorph := aMorph.  aMorph highlightForDropsortDataSource: aDataSource  self state sort: aDataSourceinspectItem  self inspectselectAll  self listManager selectAllisAdheringToBottom  ^truemouseEnterDragging: evt  self hideLocation.  evt hand showTemporaryCursor: (Cursor crossHair copy offset: -9 @ -9)updatePreview  self preview removeAllMorphs.  self preview addMorphCentered: (self activeTask ifNil: [ 'No tasks...' asMorph ] ifNotNil: [:t |  t morph taskThumbnailOfSize: self preview extent ])keystrokeActionSelector: aSelector  self listManager keystrokeActionSelector: aSelectorhScrollbarShowNever  self hScrollbar showNever.  self updateScrollbarsnewStaticItemFrom: anItem  ^FTStaticBasicItem new     data: anItem data;     depth: anItem depth;     children: #();     yourselfpassivate  super passivate.  self active: falsehasClipLayoutCellsString  ^self clipLayoutCells -> 'clip to cell size' translatedbuttonMouseDown: evt  self wantsKeyboardFocusOnMouseDown ifTrue: [ self takeKeyboardFocus ]isMenuLineMorph  ^falsecolorText: aText  table dataSource numberOfRows ~= 0 ifTrue: [ aText makeAllColor: self table theme textColor ] ifFalse: [ aText addAttribute: (TextColor new color: Color red) ].  ^aTextpopUpOwner: aMenuItemMorph  popUpOwner := aMenuItemMorphchooseForSaveFileReference: title extensions: exts path: path preview: preview  ^self theme chooseForSaveFileReferenceIn: self title: title extensions: exts path: path preview: previewinitialize  locked := false.  visible := true.  sticky := falsesendEvent: anEvent focus: focusHolder  ^self sendEvent: anEvent focus: focusHolder clear: [ nil ]openInWorld: aWorld  (aWorld visibleClearArea origin ~= (0 @ 0) and: [ self position = (0 @ 0) ]) ifTrue: [ self position: aWorld visibleClearArea origin ].  aWorld addMorph: self.  aWorld startSteppingSubmorphsOf: self.  self announceOpeneddoOneCycleFor: aWorld  self interCyclePause: MinCycleLapse.  self doOneCycleNowFor: aWorldlocalHaloBoundsFor: aMorph  | r |  r := (self worldBoundsForMorph: aMorph) truncated.  aMorph world = self world ifFalse: [ ^r ].  ^(self transformFromOutermostWorld globalBoundsToLocal: r) truncatednewText: aStringOrText  ^self theme newTextIn: self text: aStringOrTexttransformFrom: uberMorph  (self == uberMorph or: [ owner isNil ]) ifTrue: [ ^IdentityTransform new ].  ^owner transformFrom: uberMorphreplaceSubmorph: oldMorph by: newMorph  | t b |  t := transform.  b := bounds.  super replaceSubmorph: oldMorph by: newMorph.  transform := t.  bounds := b.  self layoutChangedalignment  ^alignmentmodalLockTo: aSystemWindow  aSystemWindow setProperty: #modalOwner toValue: self.  self setProperty: #modalChild toValue: aSystemWindow.  closeBox ifNotNil: [ self setProperty: #preModalCloseEnabled toValue: closeBox enabled.        closeBox enabled: false ]pages  ^self pageMorphsaddWindow  ^world addWindowToWorldnormalFillStyle  ^self theme splitterNormalFillStyleFor: selfalpha  ^(self selectedColor alpha * 255) asIntegerbuildDebugMenu: aHand  | aMenu |  aMenu := UIManager default newMenuIn: self for: self.  (self hasProperty: #errorOnDraw) ifTrue: [ aMenu add: 'start drawing again' selector: #resumeAfterDrawError ].  (self hasProperty: #drawError) ifTrue: [ aMenu add: 'debug drawing error' selector: #debugDrawError.        aMenu addLine ].  (self hasProperty: #errorOnStep) ifTrue: [ aMenu add: 'start stepping again' selector: #resumeAfterStepError.        aMenu addLine ].  aMenu add: 'inspect morph' selector: #inspectInMorphic:.  aMenu lastItem icon: (self iconNamed: #smallInspectItIcon).  aMenu add: 'inspect owner chain' selector: #inspectOwnerChain.  aMenu lastItem icon: (self iconNamed: #smallInspectItIcon).  aMenu addLine.  aMenu add: 'browse morph class' target: self selector: #browseHierarchy.  ^aMenuselect: evt  self isSelected: true.  owner activeSubmenu: subMenu.  subMenu ifNotNil: [ subMenu delete.        subMenu popUpAdjacentTo: self adjacentTo forHand: evt hand from: self.        subMenu selectItem: nil event: evt ]addName  self addNameBeneath: self basicBox string: target externalNameexpandedForm  ^self theme treeExpandedFormbackgroundColor  ^Smalltalk ui theme disabledColornewFuzzyLabelFor: aModel label: aString offset: offset alpha: alpha getEnabled: enabledSel  ^self theme newFuzzyLabelIn: self for: aModel label: aString offset: offset alpha: alpha getEnabled: enabledSelbasicColor: aColor  super color: aColor beOpaque.  self fillStyle: self gradientisMovedOrResized  ^self isMoved or: [ self isResized ]label  ^labelsearchText: aString  ^#()childrenItems  ^self item organization categoriespassiveDisabledNotOverDownFillStyle: aFillStyle  self stateMap atPath: #(passive disabled notOver down) put: aFillStyle.  self changedmouseUp: event  | aMorph wasHigh |  aMorph := self itemFromPoint: event position.  wasHigh := aMorph notNil ifTrue: [ aMorph highlightedForMouseDown ] ifFalse: [ false ].  scroller submorphsDo: [:m |  m highlightedForMouseDown ifTrue: [ m highlightForMouseDown: false ] ].  aMorph ifNil: [ ^self ].  wasHigh ifFalse: [ ^self ].  model okToChange ifFalse: [ ^self ].  (autoDeselect == true and: [ aMorph == selectedMorph ]) ifTrue: [ self setSelectedMorph: nil ] ifFalse: [ self setSelectedMorph: aMorph ].  Cursor normal showhasRightOrBottom: aMorph  ^rightOrBottom includes: aMorphselectablesToHighlightFromRow: aFTRow at: aRowIndex withHighlightedIndexes: highligtedIndexes andPrimaryIndex: primarySelectionIndex  ^self subclassResponsibilitygetContentsSelector: aSymbol  self validateSelector: aSymbol.  getContentsSelector := aSymbolresistsRemovalString  ^self resistsRemoval -> 'resist being deleted' translatedmouseUp: evt  self handleInteraction: [ editor mouseUp: evt ].  (self boundsInWorld containsPoint: self currentHand position) ifFalse: [ self hideOverEditableTextCursor ]notifyMorphsOfEvent: anEvent ofType: eventType from: sourceMorph  | result |  result := false.  ((subscriptions includesKey: eventType) not or: [ (subscriptions at: eventType) isEmpty ]) ifTrue: [ ^false ].  (subscriptions at: eventType) do: [:s |  result := result | ((s notify: anEvent from: sourceMorph) == true) ].  ^resultnewSelectionHolderWithNodePath: aNodePath  ^self isMultiple ifTrue: [ MorphTreeMorphMultipleSelection new selectedNodePathList: (self selectedMorphList collect: [:s |  s path collect: [:m |  m complexContents ] ]) ] ifFalse: [ MorphTreeMorphSingleSelection new selectedNodePath: aNodePath ]privateBePassive  self isInWorld ifFalse: [ ^self ].  self     rememberKeyboardFocus: ActiveHand keyboardFocus;     passivate;     announceDeActivatedunhighlightSelection  selectedMorph ifNotNil: [ selectedMorph unhighlight ]on: anObject getValue: getSel setValue: setSel  self     model: anObject;     getValueSelector: getSel;     setValueSelector: setSel;     updateValueinitialize  super initialize.  self cornerRadius: 0okayToBrownDragEasily  ^truenewDataSourceMatching: aFTFilter  | newElements |  newElements := Array withAll: (elements select: [:each |  aFTFilter matches: (self toString: each) ]).  ^self class new elements: newElementsthumbColor  ^self class imageColorFor: selfspotterActDefault  self doButtonActionmouseUp: event  | morphRelativeHitPoint |  touchPoints keysAndValuesDo: [:eachBox :eachSelector |  (eachBox containsPoint: event cursorPoint) ifTrue: [ self perform: eachSelector ] ].  morphRelativeHitPoint := event cursorPoint translateBy: bounds origin negated.  days do: [:each |  each highlighted: false.        (each bounds containsPoint: morphRelativeHitPoint) ifTrue: [ self date: each date.              self announceDate ] ].  self changedmouseOverThumbFillStyle  ^self theme scrollbarMouseOverThumbFillStyleFor: selfnumberOfItemsInView  ^(submorphs select: [:ea |  self innerBounds intersects: (transform localBoundsToGlobal: ea bounds) ]) sizelayoutPolicy  ^extension ifNotNil: [ extension layoutPolicy ]mouseUp: evt  ^self eventHandler ifNotNil: [ self eventHandler mouseUp: evt fromMorph: self ]useRoundedCorners  super useRoundedCorners.  self == self currentWorld ifTrue: [ Display bits primFill: 0 ]display: item atRow: row on: aCanvas  | itemColor backgroundColor drawBounds |  drawBounds := self drawBoundsForRow: row.  itemColor := self colorForRow: row.  backgroundColor := self backgroundColorForRow: row.  item listRenderOn: aCanvas atRow: row bounds: drawBounds color: itemColor backgroundColor: backgroundColor from: self.  row = self mouseDownRow ifTrue: [ aCanvas frameRectangle: (self selectionFrameForRow: row) width: 1 colors: {itemColor .               Color transparent} dashes: #(1 1) ]newEndSpacer  ^Morph new     borderWidth: 0;     color: Color transparent;     extent: 6 @ 0expandAll  self requestView: MorphTreeChangeRequest expandAllbuttons  ^buttonsisDropEvent  ^truecollapse  CollapsedMorph new beReplacementFor: selfvalue: aNumber  | testWidth |  value := aNumber.  testWidth := self completedWidth.  testWidth ~= cachedWidth ifTrue: [ cachedWidth := testWidth.        self changed ]showLeftOrTop  self show.  leftOrTop do: [:m |  m show ]nodeList: aCollection  nodeList := aCollectionpatternFromString: aString  ^[ aString asRegexIgnoringCase ] on: RegexSyntaxError do: [:ex |   ]close  ^self deletehandlesMouseDown: evt  ^truenewSliderFor: aModel getValue: getSel setValue: setSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: 0 max: 1 quantum: nil getEnabled: nil help: helpTextmouseDown: evt  self eventHandler ifNotNil: [ self eventHandler mouseDown: evt fromMorph: self ]minWidth  | iconWidth |  iconWidth := self hasIcon ifTrue: [ self icon width + 2 ] ifFalse: [ 0 ].  ^13 * indentLevel + 15 + (contents widthToDisplayInTree: self) + iconWidth max: super minWidthleftOrTopVertices: r  ^self orientation == #vertical ifTrue: [ {(r topLeft - (0 @ 1)) .         ((r left + (r height // 2 + (r height \\ 2))) @ (r center y - ((r height + 1) \\ 2))) .         ((r left + (r height // 2 + (r height \\ 2))) @ r center y) .         r bottomLeft} ] ifFalse: [ {r topLeft .         ((r center x - ((r width + 1) \\ 2)) @ (r top + (r width // 2 + (r width \\ 2)))) .         (r center x @ (r top + (r width // 2 + (r width \\ 2)))) .         r topRight} ]newMouseFocus: aMorph event: event  aMorph ifNotNil: [ targetOffset := event cursorPoint - aMorph position ].  ^self newMouseFocus: aMorphmorphicLayerNumber  ^11enableDrag: aBoolean  self setProperty: #dragEnabled toValue: aBooleanremoveStayUpItems  self menuItems select: [:menuItem |  menuItem isStayUpItem ] thenDo: [:each |  each delete ]setSelectedItems: items  selectedItems := items.  self changedisMenubar  ^falsereset  canBeMaximized  ^self isResizeable ifTrue: [ super canBeMaximized ] ifFalse: [ false ]changeNoLayout  self layoutPolicy ifNil: [ ^self ].  self layoutPolicy: nil.  self layoutChangedscrollDeltaWidth  ^self scrollDeltaHeight // 2containsPoint: aPoint  | w |  ^(super containsPoint: aPoint) and: [ w := SystemWindow borderWidth.        ((self bounds translateBy: w @ w) containsPoint: aPoint) not ]dragTab: aSystemWindow event: anEvent in: aTabLabel  self removeWindow: aSystemWindow.  aSystemWindow position: anEvent targetPoint.  anEvent hand grabMorph: aSystemWindowmouseOverBorderStyle: aBorderStyle  mouseOverBorderStyle := aBorderStylesubmorphThat: block1 ifNone: block2  ^submorphs detect: [:m |  (block1 value: m) == true ] ifNone: block2justified  textStyle justifiedinstallForUIProcessReinstall  | morphs |  owner := nil.  morphs := World submorphs.  Sensor     flushNonKbdEvents;     flushKeyboard;     flushEvents;     shutDown.  self class shutDown.  self addHand: HandMorph new.  self borderWidth: 0.  self viewBox: Display boundingBox.  self borderWidth: 0.  self color: self class defaultWorldColor.  self addAllMorphs: morphs.  SystemWindow noteTopWindowIn: self.  World := self.  ActiveWorld := self.  ActiveHand := self hands first.  ActiveEvent := nil.  worldState handsDo: [:h |  h releaseCachedState ].  Sensor startUp.  self class startUp.  self displayWorldSafelyreleaseHalo: aHalo  self removeProperty: #halotopVisibleRowForCanvas: aCanvas startingAt: aPos  ^self rowAtLocation: aCanvas clipRect topLeft startingAt: aPosallowColumnDrop  columnDropUnabled := truechangeModelSelection: anInteger  setIndexSelector ifNotNil: [ model perform: setIndexSelector with: anInteger ].  self isMultipleSelection ifTrue: [ self listSelectionAt: self lastNonZeroIndex put: false.        self listSelectionAt: anInteger put: true ]isStepping: aMorph selector: aSelector  lastStepMessage ifNotNil: [ (lastStepMessage receiver == aMorph and: [ lastStepMessage selector == aSelector ]) ifTrue: [ ^true ] ].  stepList do: [:entry |  (entry receiver == aMorph and: [ entry selector == aSelector ]) ifTrue: [ ^true ] ].  ^falsefirstIndex: firstInteger lastIndex: lastInteger  firstIndex := firstInteger.  lastIndex := lastIntegerwantsBalloon  ^self balloonText notNil and: [ self balloonHelpEnabled ]removeEdgeGrips  | edges |  edges := self submorphsSatisfying: [:each |  each isKindOf: WindowEdgeGripMorph ].  edges do: [:each |  each delete ]addTitleForHaloMenu: aMenu  aMenu buildTitle: [:menuTitle |  menuTitle           bigTitle: self externalName;           icon: (self iconOrThumbnailOfSize: 18);           cellInset: 3 ]startDrag: evt with: dragHandle  self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.  positionOffset := dragHandle center - (target point: target position in: owner)expandAll  self roots do: [:m |  self expandAll: m ].  self adjustSubmorphPositionstextColor  ^textColorselectedColor: aColor  selectedColor := aColor.  self locationMorph visible ifTrue: [ self updateSelectedLocation ].  self triggerEvent: #colorSelected with: aColoralignTopEdges  | minTop |  minTop := (selectedItems collect: [:itm |  itm top ]) min.  selectedItems do: [:itm |  itm top: minTop ].  self changeddefaultColor  ^Color whiteremovedMorph: aMorph  | range |  range := text find: (TextAnchor new anchoredMorph: aMorph).  range ifNotNil: [ self paragraph replaceFrom: range first to: range last with: Text new displaying: false.        self fit ].  aMorph textAnchorType: nil.  aMorph relativeTextAnchorPosition: nil.  super removedMorph: aMorphmodalChild  ^self valueOfProperty: #modalChildvertexAt: n  ^vertices at: (n min: vertices size)selectAll  self editor selectAllsetOptimalResizing  self hResizing: #shrinkWrap.  self vResizing: #shrinkWrapinitialize  super initialize.  self dataSource: FTEasyListDataSource newreplaceAll: aRegex with: aText  self handleEdit: [ self editor replaceAll: aRegex with: aText ]isExpanded  ^self subclassResponsibilitycellColumn: column row: rowIndex  ^FTCellMorph new     cellInset: 5;     in: [:me |  (self iconFor: rowIndex) ifNotNil: [:icon |  me addMorphBack: icon asMorph ] ];     addMorphBack: (self displayFor: rowIndex) asMorph;     yourselfsendRightArrowPressedToMenubarOwner: evt  popUpOwner owner isMenubar ifTrue: [ popUpOwner owner keyStroke: evt ] ifFalse: [ popUpOwner owner sendRightArrowPressedToMenubarOwner: evt ]wrapDirection: aSymbol  self assureTableProperties wrapDirection: aSymbol.  self layoutChangedhasInlineAnchorString  ^(self textAnchorType == #inline) -> 'Inline' translatedheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]chooseColor: aColor title: title  ^self theme chooseColorIn: self title: title color: aColordaysForLine: aNumber  | dayCount firstWeekday previousDayCount previousMonthDays lastDay |  dayCount := date month daysInMonth.  firstWeekday := Date firstWeekdayOfMonth: date monthIndex year: date year.  previousDayCount := date month previous daysInMonth.  aNumber = 1 ifTrue: [ firstWeekday = 1 ifTrue: [ ^(previousDayCount - 6 to: previousDayCount) asArray ].        previousMonthDays := (firstWeekday - 1 to: 1 by: -1) collect: [:each |  previousDayCount - each + 1 ].        ^previousMonthDays , ((1 to: 7) asArray copyFrom: 1 to: 7 - previousMonthDays size) ].  lastDay := (self daysForLine: aNumber - 1) last.  (aNumber = 2 and: [ lastDay = previousDayCount ]) ifTrue: [ ^(1 to: 7) asArray ].  lastDay = dayCount ifTrue: [ ^(1 to: 7) asArray ].  ^(lastDay + 1 to: lastDay + 7) collect: [:each |  each <= dayCount ifTrue: [ each ] ifFalse: [ each - dayCount ] ]rubberBandCells  ^rubberBandCellsrectangle  ^rectanglenewWindowFor: aModel title: titleString  ^self theme newWindowIn: self for: aModel title: titleStringvResizeToFit: aBoolean  aBoolean ifTrue: [ self vResizing: #shrinkWrap ] ifFalse: [ self vResizing: #rigid ]justDroppedInto: aMorph event: anEvent  self removeHalo.  lastPointBlock ifNotNil: [ lastPointBlock value: self center ].  anEvent hand releaseKeyboardFocus: self.  self changed.  self deletequestion: aStringOrText title: aString  ^self theme questionIn: self text: aStringOrText title: aStringrootItems  ^rootClass allSubclasses asArray sort: [:a :b |  a name < b name ]drawLinesOn: aCanvas lineColor: lineColor  | hasToggle |  hasToggle := self hasToggle.  self drawLineToggleToTextOn: aCanvas lineColor: lineColor hasToggle: hasToggle.  self nextSibling ifNotNil: [ self drawLinesToNextSiblingOn: aCanvas lineColor: lineColor hasToggle: hasToggle ].  (self firstChild notNil and: [ self isExpanded ]) ifTrue: [ self drawLinesToFirstChildOn: aCanvas lineColor: lineColor ]isHorizontal  ^self isAdheringToTop or: [ self isAdheringToBottom ]tabs  ^OrderedCollection new     add: self storedListTab;     add: self freshListTab;     add: self blueMorphTab;     add: self redMorphTab;     yourselfreplacePane: oldPane with: newPane  | aLayoutFrame hadDep |  hadDep := model dependents includes: oldPane.  oldPane owner replaceSubmorph: oldPane by: newPane.  newPane     position: oldPane position;     extent: oldPane extent.  aLayoutFrame := oldPane layoutFrame.  paneMorphs := paneMorphs collect: [:each |  each == oldPane ifTrue: [ newPane ] ifFalse: [ each ] ].  aLayoutFrame ifNotNil: [ newPane layoutFrame: aLayoutFrame ].  newPane color: Color transparent.  hadDep ifTrue: [ model removeDependent: oldPane.        model addDependent: newPane ].  self changedbasicMinExtent  | minTabExtent controlExtent controlsExtent |  controlsExtent := 0 @ 0.  self controls do: [:control |  controlExtent := control minExtent.        controlsExtent := (controlsExtent x + controlExtent x) @ (controlsExtent y max: controlExtent y) ].  self tabs ifEmpty: [ ^controlsExtent ].  minTabExtent := 0 @ 0.  self tabs do: [:tab |  minTabExtent := minTabExtent max: tab minExtent ].  ^(minTabExtent x + controlsExtent x) @ (minTabExtent y max: controlsExtent y)renderedMorph  ^selfchooseColor: aColor title: label  ^self theme chooseColorIn: self modalMorph title: (label ifNil: [ 'Choose Color' translated ]) color: aColoron: aShortcut do: anAction  ^self bindKeyCombination: aShortcut toAction: anActionhsvaMorph  ^hsvaMorphscrollAbsolute: event  event redButtonPressed ifFalse: [ ^self ].  ^super scrollAbsolute: eventtestEmptyTaskBarList  taskbar := self.  world := self.  taskbar updateTasks.  self assert: taskbar tasks size equals: 0numberOfRows  ^availableRowslastState: anObject  lastState := anObjectframeRectangle: aRectangle on: aCanvas  (self borderRectsFor: aRectangle) do: [:r |  aCanvas fillRectangle: r fillStyle: self fillStyle ]addUpdating: wordingSelector target: target selector: aSymbol argumentList: argList  | aString str |  aString := (MessageSend receiver: target selector: wordingSelector) valueWithEnoughArguments: argList.  self flag: #pharoFixMe.  (aString isKindOf: Association) ifTrue: [ aString := aString value ] ifFalse: [ str := aString readStream.        (str skipTo: $>) ifTrue: [ aString := str upToEnd ] ].  self addToggle: aString target: target selector: aSymbol getStateSelector: wordingSelector enablementSelector: nil argumentList: argListfontColor  ^self theme textColorselectionFillStyle  ^self theme menubarItemSelectionFillStyleFor: selfnewString: aStringOrText style: aStyle  ^self theme newStringIn: self label: aStringOrText font: self theme labelFont style: aStyleasReadOnlyMorph  ^selfdrawClippedOnAthensCanvas: anAthensCanvas during: aBlock  ^self clipSubmorphs ifTrue: [ anAthensCanvas clipBy: (self clippingBounds intersect: anAthensCanvas clipRect ifNone: [ ^self ]) during: aBlock ] ifFalse: [ aBlock value ]left  ^leftwidthToDisplayInList: aList  ^self contents widthToDisplayInList: aListadjustWidth  self width: (listSource innerBounds width max: self hUnadjustedScrollRange)addAColumn: aCollectionOfMorphs  | col |  col := self class inAColumn: aCollectionOfMorphs.  self addMorphBack: col.  ^coldelete  super delete.  self releaseacceptOnCR  ^acceptOnCR == trueactWhen: condition  actWhen := condition.  actWhen == #startDrag ifFalse: [ self on: #startDrag send: nil to: nil ] ifTrue: [ self on: #startDrag send: #doButtonAction to: self ]autoDeselect: aBoolean  self allowsDeselection: aBooleannewColumn: controls  ^self theme newColumnIn: self for: controlshasFillStyle  ^falsechooseFont  self editor changeTextFont.  self updateFromParagraphacceptDroppingMorph: dropped event: evt  | aMorph |  aMorph := self morphToDropFrom: dropped.  self addMorphFront: aMorph.  (aMorph fullBounds intersects: self viewBox) ifFalse: [ self inform: 'Dropped morph not in bounds'.        aMorph position: self bounds center ].  aMorph submorphsDo: [:m |  (m isKindOf: HaloMorph) ifTrue: [ m delete ] ].  self bringTopmostsToFrontdefaultBounds  ^0 @ 0 corner: 100 @ self class defaultHeight * self displayScaleFactorcontentMorph  ^contentMorphupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]newSelectedIndexes  ^newSelectedIndexesextent: aPoint  textEntry: aStringOrText  ^self textEntry: aStringOrText title: 'Entry' translateddefaultHeight  ^22testSort  | dataSource |  dataSource := self dataSourceForTesting.  self assert: state context state equals: state.  state sort: dataSource.  self deny: state context state equals: stateisEnabledMatchingTheState: aBoolean  ^aBooleanenabled  ^trueprocessEvent: anEvent  ^self processEvent: anEvent using: self defaultEventDispatcherinitialize  super initialize.  contents := ''.  hasFocus := false.  isEnabled := true.  isSelected := false.  font := StandardFonts menuFont.  self     hResizing: #spaceFill;     vResizing: #shrinkWraptab: aTab  tab := aTabtopHeaderHeight  | h |  self topHeader ifNil: [ ^0 ] ifNotNil: [:th |  h := th borderWidth * 2.        self columns do: [:col |  h := h max: col height ].        ^h ]vResizeScrollbar  | b |  b := self innerBounds.  b := b left: b right - self scrollBarThickness.  self hScrollbarShowing ifTrue: [ b := b bottom: b bottom - self scrollBarThickness ].  self vScrollbar bounds: bboundsForBalloon  container ifNil: [ ^super boundsForBalloon ].  ^self boundsInWorld intersect: container boundsInWorld ifNone: [ self boundsInWorld ]limit: aNumber  limit := aNumbermorph: anObject  morph ifNotNil: [ self removeMorph: morph ].  morph := anObject.  morph ifNotNil: [ self addMorphBack: morph.        self adjustLayoutBounds ]editorClass  ^TextEditorbasicUpdateSelectionIndex  | rowIndex |  self getIndexSelector ifNil: [ ^self ].  rowIndex := self model perform: self getIndexSelector.  rowIndex = self selectedIndex ifTrue: [ ^self ].  rowIndex = 0 ifTrue: [ self basicSelectIndexes: #() ] ifFalse: [ self basicSelectIndexes: {rowIndex} ]getListSelector: anObject  getListSelector := anObjecttestWhenRemovingWindowInWorldListTaskListShouldUpdateConsequently  | window1 window2 |  taskbar := self.  world := self.  window1 := world addWindow.  window2 := world addWindow.  taskbar updateTasks.  world removeWindow: window1.  taskbar updateTasks.  self assert: taskbar tasks size equals: 1.  self assert: taskbar tasks first morph equals: window2printOn: aStream  super printOn: aStream.  aStream nextPutAll: ' [world]'mouseDown: anEvent  (self bounds containsPoint: anEvent cursorPoint) ifTrue: [ self window ifNotNil: [:w |  w activate ] ].  ^super mouseDown: anEventrootItems: aCollection  rootItems := aCollectioninactiveTitleFillStyle  ^self theme windowInactiveTitleFillStyleFor: selfgridOrigin  ^self gridSpec originisEditable  ^self editorProvider notNilfont  ^font ifNil: [ TextStyle defaultFont ]highlightForMouseDown: aBoolean  aBoolean ifTrue: [ self setProperty: #highlightedForMouseDown toValue: aBoolean ] ifFalse: [ self removeProperty: #highlightedForMouseDown ].  self changedisEmbedded  ^self owner isNotNil and: [ self owner ~= self world and: [ self owner ~= self activeHand ] ]allItems  | all |  all := OrderedCollection new.  self items do: [:each |  all add: each.        each hasSubMenu ifTrue: [ all addAll: each subMenu allItems ] ].  ^allwantsKeyboardFocusNavigation  ^self wantsKeyboardFocusdisplayWorldState: aWorldState ofWorld: aWorld submorphs: submorphs  | canvas worldDamageRects handsToDraw |  canvas := (Form extent: self actualScreenSize depth: 32) getCanvas.  submorphs do: [:m |  m fullBounds ].  aWorldState checkIfUpdateNeeded ifFalse: [ ^self ].  worldDamageRects := aWorldState drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  handsToDraw := aWorldState selectHandsToDrawForDamage: worldDamageRects.  handsToDraw reverseDo: [:h |  canvas fullDrawMorph: h ].  canvasveryDeepCopyWith: deepCopier  ^selfdo: aBlock  self changed.  ^[ aBlock value: self ] ensure: [ self close ]selectSearchedElement  self searchedElement ifNotNil: [:selectedMorph |  self setSelectedMorph: selectedMorph.        self searchedElement: nil ]updateLabel  self model ifNotNil: [:m |  self getLabelSelector ifNotNil: [:selector |  self label: (m perform: selector) ] ]newSelectedRowIndexes: anObject  self deprecated: 'Use #newSelectedIndexes: instead' transformWith: '`@receiver newSelectedRowIndexes: `@statements1' -> '`@receiver newSelectedIndexes: `@statements1'.  self newSelectedIndexes: anObjectnewButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpTextmessage: aStringOrText title: aString  ^self theme messageIn: self text: aStringOrText title: aStringimage: form size: imageSize  form ifNil: [ self imageMorph image: (self defaultImageFormOfSize: imageSize).        self textMorph contents: '' ] ifNotNil: [ self imageMorph image: form size: imageSize.        self textMorph contents: ('{1} x {2} pixels' translated format: {form width asString .                     form height asString}) ]firstNodeMorph  ^self allNodeMorphs ifEmpty: [ nil ] ifNotEmpty: [ scroller submorphs at: 1 ]offColor: colorWhenOff  self onColor: onColor offColor: colorWhenOfftestTwoEventHandlersAreAttached  | keyboardEvent first second |  keyboardEvent := KeyboardEvent new setType: #keystroke buttons: 2 position: nil keyValue: 65 charCode: 65 hand: nil stamp: nil.  first := false.  second := false.  morph eventHandler on: #keyStroke send: #value to: [ first := true ].  morph eventHandler on: #keyStroke send: #value to: [ second := true ].  morph handleKeystroke: keyboardEvent.  self assert: first.  self assert: secondvScrollBarValue: scrollValue  | systemWindow |  scroller hasSubmorphs ifFalse: [ ^self ].  scroller offset: scroller offset x @ (self vLeftoverScrollRange * scrollValue) rounded.  owner ifNil: [ ^self ].  systemWindow := self window.  systemWindow ifNotNil: [ systemWindow announce: (WindowScrolling new                 step: 0 @ scrollValue;                 window: systemWindow) ].  self announcer announce: (PaneScrolling new           step: 0 @ scrollValue;           scrollPane: self;           yourself)mouseLeave: evt  self color: self selectionColoradjustLineIndicesBy: delta  paragraph ifNotNil: [ paragraph adjustLineIndicesBy: delta ]getCharacters  ^self text string copyasDisabledForm: aForm  | disa |  disa := aForm copy.  (aForm colorsUsed reject: [:c |  c = Color transparent ]) do: [:c |  disa replaceColor: c withColor: (c alphaMixed: 0.4 with: Color white) ].  ^disanullIndex  ^0newAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpTextgetVertices  smoothCurve ifFalse: [ ^vertices ].  ^Array streamContents: [:s |  self lineSegmentsDo: [:pt1 :pt2 |  s nextPut: pt1 ] ]isMouseUp  ^self type == #mouseUpremoveHalo  self primaryHand removeHaloAround: selfupdateForNewPageSize: newPageSize  pageSize ~= newPageSize ifTrue: [ | oldLast |        oldLast := self currentPageLastIndex.        pageSize := newPageSize max: 1.        currentPageFirstIndex := oldLast + 1 - pageSize max: 1.        self nodeList ifNotNil: [ self showCurrentPage ] ]doRot: evt with: rotHandle  | degrees |  evt hand obtainHalo: self.  degrees := (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.  degrees := degrees - angleOffset degrees.  degrees := degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.  degrees = 0.0 ifTrue: [ self setColor: Color lightBlue toHandle: rotHandle ] ifFalse: [ self setColor: Color blue toHandle: rotHandle ].  rotHandle submorphsDo: [:m |  m color: rotHandle color contrastingBlackAndWhiteColor ].  self removeAllHandlesBut: rotHandle.  self showingDirectionHandles ifFalse: [ self showDirectionHandles: true addHandles: false ].  self addDirectionHandles.  target rotationDegrees: degrees.  rotHandle position: evt cursorPoint - (rotHandle extent // 2)fastFindFirstLineSuchThat: lineBlock  | index low high |  low := 1.  high := lines size.  [ index := (high + low) // 2.  low > high ] whileFalse: [ (lineBlock value: (lines at: index)) ifTrue: [ high := index - 1 ] ifFalse: [ low := index + 1 ] ].  ^lowwrapFlag  ^wrapFlagaddAlarm: aSelector withArguments: argArray for: aTarget at: scheduledTime  worldState addAlarm: aSelector withArguments: argArray for: aTarget at: scheduledTimemorphToView  objectToView ifNil: [ ^nil ].  ^objectToView isMorph ifTrue: [ objectToView ] ifFalse: [ Morph new color: Color blue ]fullContainsPoint: aPoint  (self fullBounds containsPoint: aPoint) ifFalse: [ ^false ].  (self containsPoint: aPoint) ifTrue: [ ^true ].  ^submorphs anySatisfy: [:m |  m fullContainsPoint: aPoint ]drawSubmorphsOn: aCanvas  | drawBlock |  submorphs isEmpty ifTrue: [ ^self ].  drawBlock := [:canvas |  submorphs reverseDo: [:m |  m ~~ backgroundMorph ifTrue: [ canvas fullDrawMorph: m ] ] ].  self clipSubmorphs ifTrue: [ aCanvas clipBy: (aCanvas clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: drawBlock ] ifFalse: [ drawBlock value: aCanvas ]toggleIndex: index  ((self table selectedIndexes includes: index) and: [ self table selectedIndexes size = 1 and: [ self table allowsDeselection ] ]) ifTrue: [ self table deselectAll ] ifFalse: [ self table selectIndex: index ]mouseEnter: evt  oldBorderStyle := self borderStyle.  self borderStyle: self mouseOverBorderStylewantsYellowButtonMenu  ^falseshowBoundsInHalo  ^self class showBoundsInHalochooseExistingFileReference: title extensions: exts path: path preview: preview  ^self theme chooseExistingFileReferenceIn: self title: title extensions: exts path: path preview: previewmouseDown: anEvent  (self fullContainsPoint: anEvent position) ifFalse: [ anEvent hand releaseMouseFocus: self ].  ^super mouseDown: anEventmouseOverFillStyle  ^self theme controlButtonMouseOverFillStyleFor: selfextent: aPoint  | newExtent |  newExtent := aPoint rounded.  (bounds extent closeTo: newExtent) ifTrue: [ ^self ].  self changed.  bounds := bounds topLeft extent: newExtent.  self layoutChanged.  self changednewMenu  ^self theme newMenuIn: self for: selficon  ^iconmouseDown: event fromMorph: sourceMorph  ((self handlesClickOrDrag: event) and: [ event redButtonPressed ]) ifTrue: [ event hand waitForClicksOrDrag: sourceMorph event: event ].  ^self notifyMorphsOfEvent: event ofType: #mouseDown from: sourceMorphnewButtonFor: aModel action: actionSel label: stringOrText help: helpText  ^self newButtonFor: aModel getState: nil action: actionSel arguments: nil getEnabled: nil label: stringOrText help: helpTextrowColors  ^rowColorsincludesTableProperties  ^falsepageDelta  ^pageDeltadoubleClick: evt  ^self eventHandler ifNotNil: [ self eventHandler doubleClick: evt fromMorph: self ]degreesOfFlex  ^0.0on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel wrapSelector: wrapSel  self model: anObject.  getListSelector := getListSel.  getIndexSelector := getSelectionSel.  setIndexSelector := setSelectionSel.  getMenuSelector := getMenuSel.  keystrokeActionSelector := keyActionSel.  wrapSelector := wrapSel.  self autoDeselect: true.  self borderWidth: 1.  self updateList.  self selectionIndex: self getCurrentSelectionIndex.  self initForKeystrokesstyle: newStyle  style == newStyle ifTrue: [ ^self ].  style := newStyle.  self releaseCachedStatenewString: aStringOrText font: aFont style: aStyle  ^self theme newStringIn: self label: aStringOrText font: aFont style: aStyledispatchMouseDown: anEvent with: aMorph  | globalPt localEvt index child morphs handler inside lastHandler |  globalPt := anEvent cursorPoint.  (aMorph fullBounds containsPoint: globalPt) ifFalse: [ ^#rejected ].  lastHandler := anEvent handler.  handler := aMorph handlerForMouseDown: anEvent.  handler ifNotNil: [ anEvent handler: handler ].  index := 1.  morphs := aMorph submorphs.  [ index <= morphs size ] whileTrue: [ child := morphs at: index.        localEvt := anEvent transformedBy: (child transformedFrom: aMorph).        (child processEvent: localEvt using: self) == #rejected ifFalse: [ inside := false.              localEvt wasHandled ifTrue: [ anEvent copyHandlerState: localEvt ].              index := morphs size ].        index := index + 1 ].  (inside == false or: [ aMorph containsPoint: anEvent cursorPoint event: anEvent ]) ifTrue: [ handler ifNotNil: [ handler handleEvent: anEvent ].        anEvent handler: lastHandler.        ^self ].  anEvent handler: lastHandler.  ^#rejectedchangeEmphasis  | reply |  reply := UIManager default chooseFrom: (self emphasisChoices collect: [:t |  t translated ]) values: self emphasisChoices.  reply ifNotNil: [ self emphasis: (TextEmphasis perform: reply) emphasisCode ]deselectAll  self selectIndexes: #()lastIndex  ^lastIndex ifNil: [ lastIndex := self pageSize ]denyDeselection  self allowsDeselection: falsetaskbarButtonClicked  self isMinimized ifTrue: [ self restore ] ifFalse: [ self isActive ifTrue: [ self minimize ] ifFalse: [ self activate ] ]scrollAbsolute: event  self enabled ifFalse: [ ^self ].  super scrollAbsolute: event.  self updateLabelarrowsContainPoint: aPoint  | retval f |  retval := {false .   false}.  (super containsPoint: aPoint) ifFalse: [ ^retval ].  (closed or: [ arrows == #none or: [ vertices size < 2 ] ]) ifTrue: [ ^retval ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ f := self arrowForms first.        retval at: 2 put: (f pixelValueAt: aPoint - f offset) > 0 ].  (arrows == #back or: [ arrows == #both ]) ifTrue: [ f := self arrowForms last.        retval at: 1 put: (f pixelValueAt: aPoint - f offset) > 0 ].  ^retvalresizeButton  | topLeft bottomRight |  self flag: #pharoTodo.  bottomRight := (table bounds right - table verticalScrollBarWidth) @ (table bottom - table horizontalScrollBarHeight).  topLeft := (bottomRight x - actionButton width) @ (table bounds bottom - self fieldHeigh - table horizontalScrollBarHeight).  actionButton bounds: (topLeft corner: bottomRight)handlesMouseDown: evt  ^(self existsSubscriptionsFor: #mouseDown) or: [ (self existsSubscriptionsFor: #mouseStillDown) or: [ (self existsSubscriptionsFor: #mouseUp) or: [ (self handlesClickOrDrag: evt) or: [ self handlesGestureStart: evt ] ] ] ]dispatchCommandKeyInWorld: aChar event: evt  | aMessageSend |  aMessageSend := self commandKeySelectors at: aChar ifAbsent: [ ^false ].  aMessageSend selector numArgs = 0 ifTrue: [ aMessageSend value ] ifFalse: [ aMessageSend valueWithArguments: (Array with: evt) ].  ^truedrawOn: aCanvas  | pc fuzzColor labelColor |  pc := self paneColor.  labelColor := self enabled ifTrue: [ self color ] ifFalse: [ pc twiceDarker ].  fuzzColor := self enabled ifTrue: [ labelColor twiceDarker darker contrastingBlackAndWhiteColor alpha: self alpha ] ifFalse: [ Color transparent ].  aCanvas depth < 8 ifTrue: [ fuzzColor := Color transparent alpha: 0.001 ].  fuzzColor isTransparent ifFalse: [ aCanvas           drawString: self contents in: (self bounds translateBy: 0 @ -1) font: self fontToUse color: fuzzColor;           drawString: self contents in: (self bounds translateBy: (self offset * 2) @ -1) font: self fontToUse color: fuzzColor;           drawString: self contents in: (self bounds translateBy: (self offset * 2) @ (self offset * 2 - 1)) font: self fontToUse color: fuzzColor;           drawString: self contents in: (self bounds translateBy: 0 @ (self offset * 2 - 1)) font: self fontToUse color: fuzzColor ].  aCanvas drawString: self contents in: (self bounds translateBy: self offset @ (self offset - 1)) font: self fontToUse color: labelColorhaloBox: aBox  haloBox := aBoxselectionColorToUse  ^self valueOfProperty: #selectionColorToUse ifAbsent: [ self theme selectionColor ]newTextEditorFor: aModel getText: getSel setText: setSel  ^self newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: nilcurrentPageInput: aString  | input currPage |  input := aString asString trimBoth.  input ifEmpty: [ treeMorph flash.        ^false ].  currPage := Integer readFromString: input.  ^self currentPage: currPagelastKeystroke  ^self valueOfProperty: #lastKeystroke ifAbsent: [ '' ]updateOrderedTasksFrom: tasksThatShouldBeUpdated  | deadTasks |  deadTasks := OrderedCollection new.  self orderedTasks do: [:aTaskbarTask |  tasksThatShouldBeUpdated detect: [:aTaskThatShouldBeUpdated |  aTaskThatShouldBeUpdated morph = aTaskbarTask morph ] ifFound: [:foundTask |  tasksThatShouldBeUpdated remove: foundTask ] ifNone: [ deadTasks add: aTaskbarTask ] ].  (deadTasks isEmpty and: [ tasksThatShouldBeUpdated isEmpty ]) ifTrue: [ ^self ].  self orderedTasks: (self orderedTasks           removeAll: deadTasks;           addAll: tasksThatShouldBeUpdated;           yourself)target  ^targetremoveNode: aNode  self selectedNodePathList remove: aNode path ifAbsent: [  ]displaySelectionBlock: aSelBlock inLine: line onAthensCanvas: anAthensCanvas  (selectionStart notNil and: [ selectionStop notNil and: [ selectionStart ~= selectionStop ] ]) ifTrue: [ | startIdx stopIdx selSartIdx selStopIdx selBlockRange selRange |        startIdx := aSelBlock first stringIndex.        stopIdx := aSelBlock last stringIndex.        selSartIdx := selectionStart stringIndex.        selStopIdx := selectionStop stringIndex.        selBlockRange := startIdx to: stopIdx.        selRange := selSartIdx to: selStopIdx.        ((selBlockRange rangeIncludes: selSartIdx + 1) or: [ (selBlockRange rangeIncludes: selStopIdx - 1) or: [ (selRange rangeIncludes: startIdx + 1) or: [ selRange rangeIncludes: stopIdx - 1 ] ] ]) ifTrue: [ ^self ] ].  aSelBlock displayInLine: line onAthensCanvas: anAthensCanvasballoonColor: aColor  balloonColor := aColor.  self color: aColoredgeToAdhereTo  ^self valueOfProperty: #edgeToAdhereTo ifAbsent: [ #none ]vScrollBarHeight  ^super vScrollBarHeight - self pagerHeightnewCheckboxFor: aModel getSelected: getSel setSelected: setSel label: stringOrText help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: nil label: stringOrText help: helpTexttoggleBounds  ^self toggleRectangledefer: aValuable  worldState defer: aValuablecheckboxFillStyleToUse  ^self selected ifTrue: [ self enabled ifTrue: [ self theme checkboxButtonSelectedFillStyleFor: self ] ifFalse: [ self theme checkboxButtonSelectedDisabledFillStyleFor: self ] ] ifFalse: [ self enabled ifTrue: [ self theme checkboxButtonNormalFillStyleFor: self ] ifFalse: [ self theme checkboxButtonDisabledFillStyleFor: self ] ]morphsAt: aPoint behind: aMorph unlocked: aBool  | isBack all tfm |  all := (aMorph isNil or: [ owner isNil ]) ifTrue: [ (self fullBounds containsPoint: aPoint) ifFalse: [ ^#() ].        (aBool and: [ self isLocked or: [ self visible not ] ]) ifTrue: [ ^#() ].        nil ] ifFalse: [ tfm := self transformedFrom: owner.        all := owner morphsAt: (tfm localPointToGlobal: aPoint) behind: self unlocked: aBool.        WriteStream with: all ].  isBack := aMorph isNil.  self submorphsDo: [:m |  | found |        isBack ifTrue: [ tfm := m transformedFrom: self.              found := m morphsAt: (tfm globalPointToLocal: aPoint) behind: nil unlocked: aBool.              found notEmpty ifTrue: [ all ifNil: [ all := Array new writeStream ].                    all nextPutAll: found ] ].        m == aMorph ifTrue: [ isBack := true ] ].  (isBack and: [ self containsPoint: aPoint ]) ifTrue: [ all ifNil: [ ^Array with: self ].        all nextPut: self ].  ^all ifNil: [ #() ] ifNotNil: [ all contents ]listSelectionAt: index put: value  self searchedElement: nil.  setSelectionListSelector ifNil: [ ^false ].  ^model perform: setSelectionListSelector with: index with: valuechangeOfChangesInSlopes: slopes of: verts  | n changes |  n := verts size.  n = slopes size ifFalse: [ ^self error: 'vertices and slopes differ in number' ].  changes := Array new: n.  1 to: n do: [:i |  changes at: i put: ((verts at: i) - (verts atWrap: i + 1)) * 2 + (slopes at: i) + (slopes atWrap: i + 1) ].  ^changesicon: anObject  icon ifNotNil: [ self removeMorph: icon ].  icon := anObject.  icon ifNotNil: [ self addMorphFront: icon ]drawNullTextOn: aCanvas  aCanvas paragraph: self paragraph bounds: bounds color: coloranyButtonPressed  ^lastMouseEvent anyButtonPressedalignLeftEdges  | minLeft |  minLeft := (selectedItems collect: [:itm |  itm left ]) min.  selectedItems do: [:itm |  itm left: minLeft ].  self changedoldSelectedRowIndexes  self deprecated: 'Use #oldSelectedIndexes instead' transformWith: '`@receiver oldSelectedRowIndexes' -> '`@receiver oldSelectedIndexes'.  ^self oldSelectedIndexesnewLabel: aString  ^self newLabelFor: nil label: aString getEnabled: nilwrapDirection  | props |  props := self layoutProperties.  ^props ifNil: [ #none ] ifNotNil: [ props wrapDirection ]sticky: aBoolean  extension sticky: aBooleanactive  ^activealert: aStringOrText title: aString configure: aBlock  ^self theme alertIn: self text: aStringOrText title: aString configure: aBlockmouseUp: evt  self isMultipleSelection ifTrue: [ self mouseUpOnMultiple: evt ] ifFalse: [ self mouseUpOnSingle: evt ]selectionColor  ^self valueOfProperty: #selectionColor ifAbsent: [ self theme selectionColor ]executeSortingOn: aDataSource  self subclassResponsibilitycreateCellText: aString icon: anIcon  | text icon cell |  text := aString.  icon := anIcon.  cell := FTCellMorph new     cellInset: 5;     yourself.  icon ifNotNil: [ icon := icon asMorph.        icon class = ImageMorph ifTrue: [ icon form: (icon form scaledToSize: 16 @ 16) ] ifFalse: [ icon bounds: (0 @ 0 corner: 16 @ 16) ].        cell addMorphBack: icon ].  cell addMorphBack: text asMorph.  ^cellmockStringMorph  ^StringMorph new     contents: 'Test';     on: #mouseEnter send: #mouseEnter:from: to: self;     yourselfnewStack: controls  ^self theme newStackIn: self for: controlsselectionColorToUse  ^selectionColorToUse ifNil: [ self theme selectionColor ]chooseFont: aFont  ^self theme chooseFontIn: self title: 'Font Selector' translated font: aFontmouseEnter: event  super mouseEnter: event.  self wantsKeyboardFocus ifFalse: [ ^self ].  self keyboardFocusOnMouseDown ifFalse: [ self takeKeyboardFocus ]notExpandedForm  ^self theme treeUnexpandedFormfindPathIn: anArray  | found |  found := self findExactPathMatchIn: anArray.  found ifNil: [ found := self findSimilarPathMatchIn: anArray ].  ^founddefaultColor  ^Color r: 0.781 g: 0.781 b: 0.781isCollapsed  ^truewantsRoundedCorners  ^self cornerStyle == #roundedcreateResizableHeaderWith: aMorph between: leftColumn and: rightColumn  ^Morph new     color: Color transparent;     clipSubmorphs: true;     layoutPolicy: FTRowLayout new;     bounds: aMorph bounds;     addMorphBack: (FTColumnResizerMorph container: self left: leftColumn right: rightColumn);     addMorphBack: aMorph;     yourselfradioFillStyleToUse  ^self selected ifTrue: [ self enabled ifTrue: [ self theme radioButtonSelectedFillStyleFor: self ] ifFalse: [ self theme radioButtonSelectedDisabledFillStyleFor: self ] ] ifFalse: [ self enabled ifTrue: [ self theme radioButtonNormalFillStyleFor: self ] ifFalse: [ self theme radioButtonDisabledFillStyleFor: self ] ]realElementAt: anIndex  ^(super realElementAt: anIndex) dataresizeBackgroundMorph  self backgroundMorph ifNotNil: [ self backgroundMorph extent: self extent ]scrollBarThickness  ^self theme scrollbarThicknessbottomLeft  ^bounds bottomLeftsentTo: anObject  ^anObject handleDropFiles: selfduplicateMorph: evt  | dup |  dup := self duplicate.  evt hand grabMorph: dup from: owner.  ^dupicon  ^label icontestIndexesToSelectInMultipleSelectionFromTo  self assert: (strategy indexesToSelectInMultipleSelectionFrom: #(8 1) to: #(21 3)) asArray equals: #(#(8 1) #(9 1) #(10 1) #(11 1) #(12 1) #(13 1) #(14 1) #(15 1) #(16 1) #(17 1) #(18 1) #(19 1) #(20 1) #(21 1) #(8 2) #(9 2) #(10 2) #(11 2) #(12 2) #(13 2) #(14 2) #(15 2) #(16 2) #(17 2) #(18 2) #(19 2) #(20 2) #(21 2) #(8 3) #(9 3) #(10 3) #(11 3) #(12 3) #(13 3) #(14 3) #(15 3) #(16 3) #(17 3) #(18 3) #(19 3) #(20 3) #(21 3))wantsYellowButtonMenu  ^falseopen  ^self openDialogWindowIn: self currentWorld title: 'Packages'initialize  super initialize.  self enableDragNDrop: true.  self fillStyle: (self theme morphTreeColumnFillStyleFor: self).  self borderStyle: (self theme morphTreeColumnBorderStyleFor: self)style  ^#nonecolor: aColor  self     basicColor: aColor;     selectedColor: (Color h: aColor hue s: self selectedColor saturation v: self selectedColor brightness)location: aSymbol  location := aSymboldataSourceForTesting  ^FTTableMorph new     dataSource: (FTSimpleDataSource elements: self elementsForTestDataSource);     dataSourcegetListElementSelector: aSelector  self dataSource getListElementSelector: aSelectordefaultBitmapFillForm  ^ImageMorph defaultFormhandleKeyDown: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (self handlesKeyDown: anEvent) ifFalse: [ ^self ].  anEvent wasHandled: true.  ^self keyDown: anEventdoFullRepaint  ^totalRepaint := trueisExpanded: aBoolean  isExpanded := aBoolean.  self complexContents isExpanded: aBooleaninitialize  super initialize.  smoothing := 1.  transform := MorphicTransform identityselectPrevious  toolbar selectPreviousstateMap  ^stateMapdefaultColor  ^Color r: 0.8 g: 1.0 b: 0.6isTaskbarPresent  ^self worldTaskbar notNilmenuBarItems  ^menuBarItemstestIsBellowRow  self assert: (strategy is: #(3 7) bellowRow: 2).  self deny: (strategy is: #(3 7) bellowRow: 4).  self deny: (strategy is: #(3 7) bellowRow: 3)colorsForDirection: direction  | colorArray dT cc |  cc := self colors.  direction x * direction y <= 0 ifTrue: [ colorArray := (direction x > 0 or: [ direction y < 0 ]) ifTrue: [ cc copyFrom: 1 to: width ] ifFalse: [ (cc copyFrom: width + 1 to: cc size) reversed ] ] ifFalse: [ colorArray := Array new: width.        dT := direction x asFloat / (direction x + direction y).        (direction x > 0 or: [ direction y >= 0 ]) ifTrue: [ 1 to: width do: [:i |  colorArray at: i put: ((cc at: i) mixed: dT with: (cc at: cc size - i + 1)) ] ] ifFalse: [ 1 to: width do: [:i |  colorArray at: i put: ((cc at: cc size - i + 1) mixed: dT with: (cc at: i)) ] ] ].  ^colorArrayisScrolled  ^truenavigationKey: event  (self world navigationKey: event) ifTrue: [ ^true ].  (self tabKey: event) ifTrue: [ ^true ].  (event keyCharacter = Character escape and: [ event anyModifierKeyPressed ]) ifTrue: [ ^self yellowButtonActivity: false ].  ^falsenewGroupbox  ^self theme newGroupboxIn: selfembeddedWindowOrNil  | s |  self submorphs size = 1 ifTrue: [ s := self firstSubmorph.        s isSystemWindow ifTrue: [ ^s ] ].  ^nildisplayExtentChanged  layoutInset: aNumber  layoutInset := aNumberreset  defaultScrollTarget  ^Morph new extent: 200 @ 150visibleRowMorphAtIndex: index  ^self exposedRows at: indexmouseStillDown: anEvent  anEvent hand position y > self innerBounds bottom ifTrue: [ self listManager selectMoreAtBottom ] ifFalse: [ anEvent hand position y < self innerBounds top ifTrue: [ self listManager selectMoreAtTop ] ifFalse: [ super mouseStillDown: anEvent ] ]filter  | items |  items := OrderedCollection new.  dataSource rootsItems do: [:item |  (self matchingFilter: item) ifNotNil: [:itemNew |  items add: itemNew ] ] displayingProgress: [:each |  'Looking inside ' , each printString ].  dataSource table selectIndex: 1.  ^dataSource class root: (FTRootItem new           children: items asArray;           yourself) children: dataSource childrenBlockselected  ^self item selectedviewBox  ^self worldRenderer viewBoxresetListSelection  self resetListSelectionSilently.  self changedupdateList  | value |  value := scrollBar value.  self updateContentsWithPreviouslyExpanded: self currentlyExpanded.  self vScrollValue: valuemouseUp: anEvent  (self bounds containsPoint: anEvent cursorPoint) ifFalse: [ anEvent hand showTemporaryCursor: nil ].  self class fastSplitterResize ifTrue: [ self updateFromEvent: anEvent ].  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUpaddGrabHandle: haloSpec  self addHandle: haloSpec on: #mouseDown send: #doGrab:with: to: selfaddSubscription: aSubscription toEvent: eventName  (subscriptions includesKey: eventName) ifFalse: [ subscriptions at: eventName put: Set new ].  (subscriptions at: eventName) add: aSubscriptionaddMorph: newMorph after: aMorph  ^self privateAddMorph: newMorph atIndex: (submorphs indexOf: aMorph) + 1newHSplitter  ^ProportionalSplitterMorph new     beSplitsTopAndBottom;     setProperty: #model toValue: selfisLeft  ^self option == #lefttopLeft: aPoint  self position: aPointdoubleClick: event  | index |  doubleClickSelector ifNil: [ ^super doubleClick: event ].  index := self rowAtLocation: event position.  index = 0 ifTrue: [ ^super doubleClick: event ].  ^self model perform: doubleClickSelectornewVScrollbar  ^GeneralScrollBar new     model: self;     setValueSelector: #vScrollbarValue:dashLengths  ^dashLengthscollapseAll  self updateContentsWithPreviouslyExpanded: Array newhandleListenEvent: anEvent  ^anEvent sentTo: selfresumeUIProcess: aProcess  UIProcess := aProcess.  UIProcess resumedrawLinesOn: aCanvas  | hasToggle |  hasToggle := self hasToggle.  self drawLineToggleToTextOn: aCanvas hasToggle: hasToggle.  self nextSibling ifNotNil: [ self drawLinesToNextSiblingOn: aCanvas hasToggle: hasToggle ].  (self firstChild notNil and: [ self isExpanded ]) ifTrue: [ self drawLinesToFirstChildOn: aCanvas ]addMorphs  | mainColumn |  self preview: self newPreviewMorph.  self taskList: self newTasksMorph.  mainColumn := self theme newColumnIn: self for: {self preview .         self taskList}.  mainColumn     vResizing: #shrinkWrap;     cellInset: 8;     cellPositioning: #center.  self addMorph: mainColumn.  self layoutChangedisExpanded  ^isExpandedbasicHighlightRowIndexes: anArray  self deprecated: 'Use #basicHighlightIndexes: instead' transformWith: '`@receiver basicHighlightRowIndexes: `@statements' -> '`@receiver basicHighlightIndexes: `@statements'.  ^self basicHighlightIndexes: anArraynewColorPresenterFor: aModel getColor: getSel help: helpText  ^self theme newColorPresenterIn: self for: aModel getColor: getSel help: helpTextgetIconSelector  ^getIconSelectoractivatedFromDockingBar: aDockingBar  activatorDockingBar := aDockingBarlocationMorph: anObject  locationMorph := anObjectwindow  ^self ownerThatIsA: SystemWindowexpandNodePath: aNodePath  (self allNodeMorphs at: 1 ifAbsent: [ ^self ]) openNodePath: aNodePathisNotRestored  ^self isMinimized or: [ self isMaximized ]sortDataSource: aDataSource  self subclassResponsibilitydisable  self enabled: falsebrowseItem  Smalltalk tools browser openOnClass: self iteminitialize  super initialize.  self     rubberBandCells: false;     listDirection: #topToBottom;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #center.  enabled := true.  self initializeLabelMorph.  askBeforeChanging := false.  triggerOnMouseDown := false.  showSelectionFeedback := false.  arguments := #().  self     layoutInset: (self theme buttonLabelInsetFor: self);     extent: 20 @ 15;     lastState: false;     cornerStyle: (self theme buttonCornerStyleIn: nil);     borderStyle: (self theme buttonNormalBorderStyleFor: self).  self clipSubmorphs: truetabRefreshed: aTab  self selectedTab = aTab ifFalse: [ ^self ].  self triggerEvent: #tabRefreshed with: aTabmouseEnterIcon  closeable ifFalse: [ ^self ].  fadeOut ifNotNil: [ fadeOut terminate ].  closeIcon image: self class closeOverIconnumberOfItemsPotentiallyInViewWith: listSize  | height |  height := self localSubmorphBounds height.  height isZero ifTrue: [ ^0 ].  ^self innerBounds height // (height / listSize)right  ^righttearDown  window ifNotNil: [ window delete ].  super tearDownhandlesMouseOverDragging: event  ^truetaskbarCloseAllLikeThis  (SystemWindow allSubInstances select: [:w |  w model isKindOf: self model class ]) do: [:w |  w delete ]delete  self setProperty: #deleting toValue: true.  super deleteremoveHalo  self halo ifNotNil: [:h |  self removeHaloAround: h target ]repelsMorph: aMorph event: ev  ^truebeResetable  resetable := trueactualClass  ^FTNullColumnSortingStrategyinnerExtent: aPoint  self extent: (aPoint x + (self cornerRadius * 2)) @ aPoint yshowLocation  self locationMorph     visible: true;     changedattachKeymapCategory: aCategoryName onProperty: aProperty  self kmDispatcher attachCategory: aCategoryName onProperty: aPropertyactualScreenSize  < primitive: 106>  self primitiveFailedmenuTitleSelector: aSelector  getMenuTitleSelector := aSelectornoticeMouseOver: aMorph event: anEvent  leftMorphs remove: aMorph ifAbsent: [ enteredMorphs nextPut: aMorph ].  overMorphs nextPut: aMorphdrawIconOn: aCanvas  | iconForm x y |  self hasIcon ifFalse: [ ^self ].  iconForm := self iconForm.  x := self menuStringBounds left - iconForm width - 5.  y := self top + ((self height - iconForm height) // 2).  aCanvas translucentImage: iconForm at: x @ ymouseDownInSlider: event  slider borderStyle style == #raised ifTrue: [ slider borderColor: #inset ].  sliderShadow color: self sliderShadowColor.  sliderShadow cornerStyle: slider cornerStyle.  sliderShadow bounds: slider bounds.  sliderShadow showshowWidget  hasNoOffsets  ^leftOffset = 0 and: [ rightOffset = 0 and: [ topOffset = 0 and: [ bottomOffset = 0 ] ] ]activeHand  ^activeHandmouseOverThumbButtonBorderStyle  ^self theme scrollbarMouseOverThumbButtonBorderStyleFor: selfdrawSubmorphsOnAthensCanvas: anAthensCanvas  | clip |  clip := self clippingBounds intersect: anAthensCanvas clipRect.  anAthensCanvas transformBy: self transform withClip: clip in: self innerBounds during: [:canvas |  | top bottom |        top := self topVisibleRowForCanvas: canvas.        bottom := self bottomVisibleRowForCanvas: canvas startingAt: top.        bottom to: top by: -1 do: [:row |  | m |              m := submorphs basicAt: row.              self drawRawColorOn: anAthensCanvas asCanvasWrapper forSubmorph: m.              canvas fullDrawMorph: m ] ].  owner withTreeLines ifTrue: [ owner drawLinesOn: anAthensCanvas asCanvasWrapper ].  owner enabled ifFalse: [ anAthensCanvas asCanvasWrapper fillRectangle: owner innerBounds fillStyle: (owner paneColor alpha: 0.2) ]initializeSlider  self setSlider: ((BracketMorph newBounds: self totalSliderArea)           horizontal: self bounds isWide;           color: self thumbColor;           borderStyle: (BorderStyle raised                 baseColor: Color white;                 width: 1)) withShadow: ((BracketMorph newBounds: self totalSliderArea)           horizontal: self bounds isWide;           color: self pagingArea color;           borderStyle: (BorderStyle inset                 baseColor: (Color white alpha: 0.6);                 width: 1))adhereToLeft  self adhereTo: #leftstringBounds  | bnd gap |  bnd := self bounds.  gap := self layoutInset.  ^bnd topLeft + gap corner: bnd bottomRight + gapisTranslucentButNotTransparent  ^color isColor and: [ color isTranslucentButNotTransparent ]initializeLabelArea  label := self theme windowLabelFor: self.  collapseBox := self createCollapseBox.  closeBox := self createCloseBox.  self wantsExpandBox ifTrue: [ expandBox := self createExpandBox.        self setExpandBoxBalloonText ].  menuBox := self createMenuBox.  stripes := Array with: (Morph newBounds: bounds) with: (Morph newBounds: bounds).  self addLabelArea.  labelArea goBehind.  self replaceBoxes.  labelArea fillStyle: self activeTitleFillStyleisKeyUp  ^self type == #keyUpdeleteIfPopUp: evt  evt ifNotNil: [ evt hand releaseMouseFocus: self ]deselectItem  | item |  self isSelected: false.  subMenu ifNotNil: [ subMenu deleteIfPopUp ].  owner isMenuMorph ifTrue: [ item := owner popUpOwner.        item isMenuItemMorph ifTrue: [ item deselectItem ] ]handlesKeyboard: evt  ^trueradioBorderStyleToUse  ^self selected ifTrue: [ self enabled ifTrue: [ self theme radioButtonSelectedBorderStyleFor: self ] ifFalse: [ self theme radioButtonSelectedDisabledBorderStyleFor: self ] ] ifFalse: [ self enabled ifTrue: [ self theme radioButtonNormalBorderStyleFor: self ] ifFalse: [ self theme radioButtonDisabledBorderStyleFor: self ] ]handleMouseOver: anEvent  anEvent hand mouseFocus == self ifTrue: [ (self containsPoint: anEvent position event: anEvent) ifFalse: [ ^self ] ].  anEvent hand noticeMouseOver: self event: anEventrootItems  ^self rootClass allSubclasses asArray sort: [:a :b |  a name < b name ]asString  ^item asStringsetActionSelector  | newSel |  newSel := UIManager default request: 'Please type the selector to be sent tothe target when this button is pressed' translated initialAnswer: actionSelector.  newSel isEmptyOrNil ifFalse: [ self actionSelector: newSel ]keyboardFocus: aMorphOrNil  self newKeyboardFocus: aMorphOrNilopenAsIs  ^self openAsIsIn: self currentWorldmouseMove: evt  self isForDragging ifTrue: [ self draggedTo: evt position ] ifFalse: [ self reframedTo: evt position ]acceptValue: aValue  | val |  self contents: (val := aValue asString).  ^valisHorizontal  ^self edgeName == #top or: [ self edgeName == #bottom ]move  copy := falsecompiledMethod  ^self itemClass compiledMethodAt: self selector ifAbsent: [ self itemClass class compiledMethodAt: self selector ifAbsent: [  ] ]mouseLeave: evt  owner ifNotNil: [ owner stayUp ifFalse: [ self mouseLeaveDragging: evt ] ]elementCount  ^self text string sizeage: anObject  age := anObjectslopes: knots  self isCurvy ifFalse: [ ^self segmentedSlopesOf: knots ].  ^closed ifTrue: [ self closedCubicSlopesOf: knots ] ifFalse: [ self naturalCubicSlopesOf: knots ]applyModelExtent  self extent: model initialExtentthemeChanged  self color: self defaultColor.  super themeChangedlayoutChanged  localBounds := nil.  ^super layoutChangedselectFirstVisibleRow  ^self selectIndex: (container exposedRows ifNotEmpty: [:rows |  rows keys first ] ifEmpty: [ 0 ])value: anArgument  | nArgs |  numArgs ifNil: [ numArgs := selector numArgs ].  nArgs := arguments ifNil: [ 0 ] ifNotNil: [ arguments size ].  nArgs = numArgs ifTrue: [ ^self value ].  ^arguments ifNil: [ receiver perform: selector with: anArgument ] ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: anArgument) ]newMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector help: helpText  ^self newMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: nil help: helpTextmorph: anObject  morph := anObjectlabelMorph: aMorph  labelMorph ifNotNil: [ labelMorph delete ].  labelMorph := aMorph.  labelMorph color: (self theme checkboxButtonLabelNormalFillStyleFor: self label: labelMorph).  self addMorphBack: aMorph.  self enabled: self enabledmodel: aModel  model := aModeladdHand: aHandMorph  hands := (hands copyWithout: aHandMorph) copyWith: aHandMorphaddEventListener: anObject  self eventListeners: (self addListener: anObject to: self eventListeners)adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self borderStyle baseColor: paneColor twiceDarkerrotationDegrees  ^0.0isDown  ^direction = Character arrowDowndoubleClick: anEvent fromMorph: aMorph  ^self notify: anEvent from: aMorphlabelRightOffset  ^12 * self displayScaleFactormouseOverPagingAreaThumbFillStyle  ^self theme scrollbarMouseOverBarThumbFillStyleFor: selfnewScroller  ^TransformWithLayoutMorph new color: Color transparentsimulateRightClick  self simulateClickWith: MouseEvent yellowButtontreeMorph  | treeMorph baseColor oddColor evenColor |  baseColor := Color lightBlue lighter.  oddColor := (GradientFillStyle ramp: {(0.0 -> baseColor whiter) .         (0.2 -> baseColor) .         (0.8 -> baseColor darker) .         (1.0 -> baseColor blacker)}) radial: false.  baseColor := Color veryLightGray muchLighter.  evenColor := (GradientFillStyle ramp: {(0.0 -> baseColor lighter lighter) .         (0.2 -> baseColor lighter) .         (0.8 -> baseColor) .         (1.0 -> baseColor blacker)}) radial: false.  treeMorph := self treeMorphClass new     model: self;     beMultiple;     columns: {(MorphTreeColumn new           startWidth: 100;           rowMorphGetSelector: #classButton;           headerButtonLabel: 'Class' font: nil icon: (self iconNamed: #smallOpenIcon) target: nil actionSelector: nil arguments: #()) .         (MorphTreeColumn new           rowMorphGetSelector: #commentText;           headerButtonLabel: 'Comments' font: nil icon: (self iconNamed: #smallPrintIcon) target: nil actionSelector: nil arguments: #())};     makeLastColumnUnbounded;     withHLines: true;     allowColumnDrop;     useSquareCorners;     hResizing: #spaceFill;     vResizing: #spaceFill;     rowInset: 5;     columnInset: 5;     resizerWidth: 2;     preferedPaneColor: Color white;     getMenuSelector: #menu:shifted:;     columnColorForEven: evenColor odd: oddColor.  ^treeMorph buildContentsprogress: aNormalizedNumber  bar progress = aNormalizedNumber ifFalse: [ bar progress: aNormalizedNumber.        self changed: #progressValue ]lastSelectedNodePath  ^self selectedNodePathList ifNotEmpty: [:l |  l last ]createActionButtonFor: anAction  ^TabActionButtonMorph forAction: anActionautoMultiSelection  ^autoMultiSelection ifNil: [ autoMultiSelection := false ]asAthensPaintOn: anAthensCanvas  ^AthensCompositeStrokePaint new fromBorderStyles: borders on: anAthensCanvasendPoint  ^positiongetList  ^(model perform: (getListSelector ifNil: [ ^#() ])) ifNil: [ #() ]defaultBorderColor  ^Color grayisDockingBar  ^falseselectAll  self table selectIndexes: ((1 to: self table numberOfRows) flatCollect: [:rowIndex |  (1 to: self table numberOfColumns) collect: [:columnIndex |  {rowIndex .                     columnIndex} ] ]) asArraymodel: anObject  model := anObjectnewListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpText  ^self theme newListIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpTextdata: aCollection  self children: (aCollection collect: [:object |  FTBasicItem data: object from: dataSource ]) asArrayprivateMoveBy: delta  super privateMoveBy: delta.  vertices := vertices collect: [:p |  p + delta ].  self arrowForms do: [:f |  f offset: f offset + delta ].  curveState := nil.  (self valueOfProperty: #referencePosition) ifNotNil: [:oldPos |  self setProperty: #referencePosition toValue: oldPos + delta ]newButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel labelForm: aForm help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: (AlphaImageMorph new image: aForm) help: helpTextselection: item  | i |  item ifNil: [ ^self selectionIndex: 0 ].  i := scroller submorphs findFirst: [:m |  m complexContents == item ].  i > 0 ifTrue: [ ^self selectionIndex: i ].  i := scroller submorphs findFirst: [:m |  m withoutListWrapper = item withoutListWrapper ].  self selectionIndex: inewTransformMorph  ^MorphTreeTransformMorph newdoubleClick: anEvent  | targetMorph |  targetMorph := self scrollerSubMorphFromPoint: anEvent position.  (self listManager doubleClick: anEvent on: targetMorph) ifFalse: [ super doubleClick: anEvent ]adhereToEdge  | menu |  menu := UIManager default newMenuIn: self for: self.  #(top right bottom left - center - topLeft topRight bottomRight bottomLeft - none) do: [:each |  each == #- ifTrue: [ menu addLine ] ifFalse: [ menu add: each asString selector: #setToAdhereToEdge: argument: each ] ].  menu popUpEvent: self currentEvent in: self worldhandlesShowingPhrase  ^(self showingHandles ifTrue: [ 'hide handles' ] ifFalse: [ 'show handles' ]) translatedhandlesMouseDown: evt  ^(super handlesMouseDown: evt) or: [ evt shiftPressed ]textColor  ^colorvalue: aNumber  (self sliderMorph ifNil: [ ^self ]) scaledValue: aNumber.  self model ifNotNil: [ self setValueSelector ifNotNil: [ self model perform: self setValueSelector with: self sliderMorph scaledValue ] ].  self     changed: #minEnabled;     changed: #maxEnabledresizeScroller  self scroller bounds: self scrollBoundsaddMainPanel  self addMorph: self newMainPanel frame: (0 @ 0 corner: 1 @ 1)handlesMouseOverDragging: evt  ^(self existsSubscriptionsFor: #mouseEnterDragging) or: [ self existsSubscriptionsFor: #mouseLeaveDragging ]font  ^fontdeselectAll  self isMultipleSelection ifFalse: [ ^self ].  self resetListSelectionsendKeyboardEvent: anEvent  ^self sendEvent: anEvent focus: self keyboardFocus clear: [ self keyboardFocus: nil ]interactWithSelection  | cell |  self hasSelection ifFalse: [ ^self ].  cell := (self container exposedRows at: self selectedIndex) submorphs first.  cell submorphsDo: [:each |  each update: #interact ]initialize  super initialize.  borderWidth := 0.  textStyle := TextStyle default copy.  wrapFlag := true.  margins := Margin left: 0 right: 0 top: 0 bottom: 0.  self attachKeymapCategory: #TextMorphthemeChanged  self     color: self defaultColor;     borderColor: self defaultBorderColor;     borderWidth: self defaultBorderWidth.  super themeChangedstartWidth: anInteger  currentWidth := anIntegerinitialize  super initialize.  self     dashColors: {Color black .         Color white};     dashLengths: #(1 1)newLabelGroup: labelsAndControls font: aFont labelColor: aColor  ^self theme newLabelGroupIn: self for: labelsAndControls font: aFont labelColor: aColoraddCircleHandles  | box |  target isWorldMorph ifTrue: [ ^self addHandlesForWorldHalos ].  self removeAllMorphs.  self bounds: (self worldBoundsForMorph: target renderedMorph).  box := self basicBox.  target addHandlesTo: self box: box.  self addName.  growingOrRotating := false.  self layoutChanged.  self changedgetStringSelector  ^getStringSelectorenabled: aBoolean  aBoolean ifTrue: [ text makeAllColor: self defaultColor ] ifFalse: [ text makeAllColor: self theme disabledTextColor ].  self changedsetAlignment: aSymbol  alignment := aSymboltextSelector  ^textSelectorquestion: aStringOrText  ^self question: aStringOrText title: 'Question' translatedtabSelectTo: aTab  | index selectedIndex |  index := tabs indexOf: aTab.  selectedIndex := tabs indexOf: self selectedTab ifAbsent: [ ^self ].  index compareWith: selectedIndex ifLesser: [ selectedIndex to: index by: -1 do: [:i |  (tabs at: i) addToSelection ] ] ifEqual: [  ] ifGreater: [ selectedIndex to: index do: [:i |  (tabs at: i) addToSelection ] ].  self addInHistory: aTab.  self adjustLayoutrecursiveDelete  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aNode recursiveDelete ] ].  self deletekeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self focusChangedallNodeMorphs  ^scroller submorphsmouseDownInSlider: event  interval = 1.0 ifTrue: [ self setValue: 0.        self model hideOrShowScrollBar ].  event redButtonPressed ifFalse: [ ^self ].  slider fillStyle: self pressedThumbFillStyle.  slider borderStyle: self pressedThumbBorderStyle.  self theme useScrollbarThumbShadow ifTrue: [ sliderShadow           color: self sliderShadowColor;           cornerStyle: slider cornerStyle;           bounds: slider bounds;           show ]addTabs  self tabs do: [:tab |  manager addTab: tab ]scrollDeltaHeight  ^scroller firstSubmorph heightblueButtonUp: anEvent  super blueButtonUp: anEvent.  self closeselectableIndexAbove: anIndex  ^self subclassResponsibilityvIsScrollbarNeeded  (self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ]) ifTrue: [ ^false ].  (self valueOfProperty: #vScrollBarAlways ifAbsent: [ false ]) ifTrue: [ ^true ].  ^self vIsScrollablethemeChanged  self color: (self theme menuColorFor: nil).  super themeChangedupdateFromSelection: aSelection  aSelection selectedNodePathList do: [:path |  self selectNodePath: path ].  self scrollSelectionIntoViewworldRenderer  ^worldRenderer ifNil: [ worldRenderer := NullWorldRenderer forWorld: self currentWorld ]text  ^texttargetOffset  ^targetOffsetisSingleSelection  ^self multipleSelection notnewOKButtonFor: aModel getEnabled: enabledSel  ^self theme newOKButtonIn: self for: aModel getEnabled: enabledSelwantsHaloFromClick  ^owner isSystemWindow nothandlesMouseDown: evt  ^truedataSource: anObject  dataSource := anObjectstyle  ^#tabbeddashedBorder: dashSpec  borderDashSpec := dashSpec.  self changedwantsRoundedCorners  ^(self theme dialogWindowPreferredCornerStyleFor: self) == #roundedreferencePosition: aPosition  | newPos intPos |  newPos := self position + (aPosition - self referencePosition).  intPos := newPos asIntegerPoint.  newPos = intPos ifTrue: [ self position: intPos ] ifFalse: [ self position: newPos ]notAtMin  ^self value > self minfillStyle: newColor  ^self isOpen ifTrue: [ self borderColor: newColor asColor ] ifFalse: [ super fillStyle: newColor ]emphasis: aCodeOrTextEmphasis  emphasis := aCodeOrTextEmphasis value.  ^self font: font emphasis: emphasison: anAnnouncementClass send: aSelector to: anObject  self announcer when: anAnnouncementClass send: aSelector to: anObjectdoDeferredUpdatingFor: aWorld  (Display deferUpdates: true) ifNil: [ ^false ].  (self canvas notNil and: [ self canvas form == Display ]) ifFalse: [ aWorld viewBox: self viewBox.        self canvas: (Display getCanvas copyClipRect: Display boundingBox) ].  ^trueopen  (self treeMorph     buildContents;     embeddedInMorphicWindowLabeled: 'Simple grid example') openInWorldmouseStillDownStepRate  ^200releaseParagraph  self releaseParagraphReallylabelSizeIn: aTaskbar  ^(150 // (aTaskbar tasks size + 1) max: 10) min: 30canRefreshValues  ^self needsRefreshExposedRows and: [ self table isNotNil and: [ self table hasDataSource ] ]forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]searchedElement: anObject  searchedElement := anObjectwantsDropElements: aCollection type: type index: rowIndex  self dropItemSelector ifNil: [ ^false ].  self wantsDropSelector ifNil: [ ^true ].  ^self model perform: self wantsDropSelector with: aCollectionbottomFraction: aNumber offset: anInteger  bottomFraction := aNumber.  bottomOffset := anIntegerworldMenu  ^owner worldMenufilter  | items |  items := OrderedCollection new.  dataSource rootsItems do: [:item |  (self matchingFilter: item) ifNotNil: [:itemNew |  items add: itemNew ] ] displayingProgress: [:each |  'Looking inside ' , each printString ].  dataSource table selectIndex: 1.  ^dataSource class root: (FTRootItem new           children: items asArray;           yourself) children: dataSource childrenBlockremoveProperty: aSymbol  extension ifNil: [ ^self ].  extension removeProperty: aSymbolnormalizedX: x  ^(x max: self leftBoundary) min: self rightBoundarymaybeAddCollapseItemTo: aMenu  isTableLayout  ^trueremoveDropShadow  self hasDropShadow ifFalse: [ ^self ].  self changed.  self hasDropShadow: false.  self shadowOffset: 0 @ 0.  self layoutChanged.  self changedisScrolled  ^falseaddCollapseBox  labelArea ifNil: [ ^self ].  collapseBox := self createCollapseBox.  collapseBox layoutFrame: (self theme windowCollapseBoxLayoutFor: self).  labelArea addMorphBack: collapseBoxupdateContents  treeMorph vIsScrollable ifFalse: [ self atBottom: true ].  super updateContentsparagraph  paragraph ifNotNil: [ ^paragraph ].  self setProperty: #CreatingParagraph toValue: true.  self setDefaultContentsIfNil.  paragraph := Paragraph new textOwner: self owner.  paragraph wantsColumnBreaks: successor notNil.  paragraph compose: text style: textStyle copy from: self startingIndex in: self container.  paragraph focused: self currentHand keyboardFocus == self.  self fit.  self removeProperty: #CreatingParagraph.  self selectionColor: self selectionColor.  ^paragraphselectIndex: index event: event  index ifNotNil: [ self selectionStrategy selectIndex: index event: event ] ifNil: [ self deselectAll ]selectAppendingIndex: index  | currentSelection newSelection |  currentSelection := self table selectedIndexes.  newSelection := (currentSelection includes: index) ifTrue: [ currentSelection copyWithout: index ] ifFalse: [ currentSelection copyWithFirst: index ].  self table selectIndexes: newSelectioninitialize  super initialize.  self     clipSubmorphs: true;     beStickycursor  | loc |  loc := self valueOfProperty: #textCursorLocation ifAbsentPut: [ 1 ].  loc := loc min: text string size.  ^loc roundedlabelHeight  label ifNil: [ ^self isEmbedded ifTrue: [ 0 ] ifFalse: [ self class borderWidth ] ].  ^label height + (self class borderWidth * 2) max: (collapseBox ifNotNil: [ collapseBox height ] ifNil: [ 10 ])mouseMove: evt  (self containsPoint: evt cursorPoint) ifTrue: [ self state: #pressed.        super mouseMove: evt ] ifFalse: [ self state: #off ]morphToGrab: event  self submorphsDo: [:m |  ((m rejectsEvent: event) not and: [ m fullContainsPoint: event cursorPoint ]) ifTrue: [ ^m ] ].  ^nilnewExpander: aString for: aControl  ^self theme newExpanderIn: self label: aString forAll: {aControl}disable  self enabled: falsesetFont: fontNum  fontNumber := fontNumjustifiedPadFor: spaceIndex  | pad |  internalSpaces = 0 ifTrue: [ ^0 ].  pad := paddingWidth // internalSpaces.  spaceIndex <= (paddingWidth \\ internalSpaces) ifTrue: [ ^pad + 1 ] ifFalse: [ ^pad ]initialize  super initialize.  self beStraightSegmentsballoonText: aText  self assureExtension balloonText: aTextnewTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpTextnewIncrementButton  ^(self theme builder newButtonFor: self action: #increment getEnabled: #maxEnabled label: (self newButtonLabel: #right ofSize: 24) help: nil)     vResizing: #spaceFill;     width: 64;     roundedCorners: #(3 4);     setProperty: #wantsKeyboardFocusNavigation toValue: false;     on: #mouseStillDown send: #increment to: selfright: aNumber  self position: (aNumber - bounds width) @ bounds topmatchingFilter: anItem  anItem isExpanded ifTrue: [ ((anItem children collect: [:each |  self matchingFilter: each ]) reject: #isNil) ifNotEmpty: [:coll |  ^(self newStaticItemFrom: anItem)                 children: coll asArray;                 expandWithoutChange;                 yourself ] ].  ^(pattern matchesIn: (self dataSource toString: anItem)) ifNotEmpty: [ anItem isExpanded ifTrue: [ self newStaticItemFrom: anItem ] ifFalse: [ anItem ] ] ifEmpty: [ nil ]setProperty: aSymbol toValue: anObject  anObject ifNil: [ ^self removeProperty: aSymbol ].  self assureExtension setProperty: aSymbol toValue: anObjecttestIntoWorldTransferToNewGuy  | m1 m2 |  m1 := TestInWorldMorph new.  m2 := TestInWorldMorph new.  self assert: m1 intoWorldCount equals: 0.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 0.  self assert: m2 outOfWorldCount equals: 0.  morph addMorphFront: m1.  m1 addMorphFront: m2.  self assert: m1 intoWorldCount equals: 0.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 0.  self assert: m2 outOfWorldCount equals: 0.  morph openInWorld.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 0.  morph addMorphFront: m2.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 0.  morph addMorphFront: m1.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 0.  m2 addMorphFront: m1.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 0.  morph delete.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 1.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 1handleMouseOver: anEvent  super handleMouseOver: anEvent.  (self handlesMouseOver: anEvent) ifTrue: [ anEvent wasHandled: true.        self mouseOver: anEvent ]mouseDown: evt  self perform: #mouseDown: withArguments: {evt} inSuperclass: Morph.  self enabled ifFalse: [ ^self ].  self isOn ifTrue: [ self state: #repressed ] ifFalse: [ self state: #pressed ].  actWhen == #buttonDown ifTrue: [ self doButtonAction ].  self mouseStillDown: evtsendToModel: aSelector  aSelector numArgs = 0 ifTrue: [ ^model perform: aSelector ].  aSelector numArgs = 1 ifTrue: [ ^model perform: aSelector with: item ].  aSelector numArgs = 2 ifTrue: [ ^model perform: aSelector with: item with: self ]displaySelectionBlock: aSelBlock inLine: line on: aCanvas  (selectionStart notNil and: [ selectionStop notNil and: [ selectionStart ~= selectionStop ] ]) ifTrue: [ | startIdx stopIdx selSartIdx selStopIdx selBlockRange selRange |        startIdx := aSelBlock first stringIndex.        stopIdx := aSelBlock last stringIndex.        selSartIdx := selectionStart stringIndex.        selStopIdx := selectionStop stringIndex.        selBlockRange := startIdx to: stopIdx.        selRange := selSartIdx to: selStopIdx.        ((selBlockRange rangeIncludes: selSartIdx + 1) or: [ (selBlockRange rangeIncludes: selStopIdx - 1) or: [ (selRange rangeIncludes: startIdx + 1) or: [ selRange rangeIncludes: stopIdx - 1 ] ] ]) ifTrue: [ ^self ] ].  aSelBlock displayInLine: line on: aCanvasexpandItemPath: anArray  | found |  anArray isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ (each complexContents withoutListWrapper = anArray first or: [ anArray first isNil ]) ifTrue: [ found := each ] ] ].  found ifNotNil: [ found isExpanded ifFalse: [ found toggleExpandedState ].        found changed.        anArray size = 1 ifTrue: [ ^container listManager setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild expandItemPath: anArray allButFirst ] ].  ^container setSelectedMorph: nilrecipient: anObject  recipient := anObjectveryDeepInner: deepCopier  super veryDeepInner: deepCopier.  offImage := offImage veryDeepCopyWith: deepCopier.  pressedImage := pressedImage veryDeepCopyWith: deepCopier.  state := state veryDeepCopyWith: deepCopier.  actWhen := actWhencaretRect  ^caretRectaddHandleAt: aPoint color: aColor on: eventName send: selector to: recipient  ^self addHandleAt: aPoint color: aColor icon: nil on: eventName send: selector to: recipientkeyStroke: anEvent  self subclassResponsibilitydrawLinesToFirstChildOn: aCanvas lineColor: lineColor  | vLineX vLineTop vLineBottom childBounds childCenter myTheme |  self firstChild hasToggle ifTrue: [ ^self ].  childBounds := self firstChild toggleBounds.  childCenter := childBounds center.  vLineX := childCenter x.  vLineTop := bounds bottom.  vLineBottom := self firstChild hasToggle ifTrue: [ childCenter y - (childBounds height // 2) + 1 ] ifFalse: [ childCenter y - 2 ].  myTheme := self theme.  aCanvas frameRectangle: (vLineX @ vLineTop corner: (vLineX + 1) @ vLineBottom) width: myTheme treeLineWidth colors: (myTheme treeLineColorsFrom: lineColor) dashes: myTheme treeLineDasheschooseFont: aFont  ^self theme chooseFontIn: self title: 'Font Selector' translated font: aFontposition  ^positionselectableIndexAfter: anIndex  ^{anIndex first .   (anIndex second + 1)}newToolbar  ^self theme newToolbarIn: selfownerChanged  super ownerChanged.  self updateLayoutInDockingBardrawSubmorphsOn: aCanvas  | drawBlock submorphsToDraw |  submorphs isEmpty ifTrue: [ ^self ].  submorphsToDraw := self computeSubmorphsToDraw.  drawBlock := [:canvas |  submorphsToDraw do: [:m |  canvas fullDrawMorph: m ] ].  self clipSubmorphs ifTrue: [ aCanvas clipBy: (aCanvas clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: drawBlock ] ifFalse: [ drawBlock value: aCanvas ]newAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpTextlabel: aString  self label: aString font: StandardFonts buttonFontsortChildrenBy: aBlock  sortingBlock := aBlocklistCentering  | props |  props := self layoutProperties.  ^props ifNil: [ #topLeft ] ifNotNil: [ props listCentering ]ptName  ^#topLeftborderStyleToUse  ^self isSelected ifTrue: [ self theme tabLabelSelectedBorderStyleFor: self ] ifFalse: [ self theme tabLabelNormalBorderStyleFor: self ]displayFor: rowIndex  | element |  element := self elementAt: rowIndex.  ^displayBlock ifNotNil: [ displayBlock value: element ] ifNil: [ ^element ]scroller  ^scrollerbrickDoubleLink  ^self valueOfProperty: #brickDoubleLink ifAbsentPut: [ nil ]startDrag: anItem with: anObject  self currentHand attachMorph: anObjectactivate: evt  evt hand newMouseFocus: self.  self takeKeyboardFocuspaneColor: aColor  self setProperty: #paneColor toValue: aColor.  self adoptPaneColor: aColorupdate: aSelector  aSelector = self interactSelector ifTrue: [ ^self doButtonAction ].  super update: aSelectoritem: index  | newItem itemWidth |  (index between: 1 and: listItems size) ifFalse: [ ^self getListItem: index ].  (listItems at: index) ifNil: [ newItem := self getListItem: index.        maxWidth ifNotNil: [ itemWidth := self widthToDisplayItem: newItem.              itemWidth > maxWidth ifTrue: [ maxWidth := itemWidth.                    self adjustWidth ] ].        listItems at: index put: newItem ].  ^listItems at: indexghostString: aString  ghostString := aStringquantum  ^(self sliderMorph ifNil: [ ^0 ]) quantumframeRectangle2: aRectangle on: aCanvas  | r |  r := aRectangle insetBy: self width // 2.  self width odd ifTrue: [ r := r insetBy: (0 @ 0 corner: 1 @ 1) ].  aCanvas     line: r topLeft + (2 @ 0) to: r topRight - (2 @ 0) width: self width color: self color;     line: r topRight + (-1 @ 1) to: r topRight + (-1 @ 1) width: self width color: self color;     line: r topRight + (0 @ 2) to: r bottomRight - (0 @ 2) width: self width color: self color;     line: r bottomRight - (1 @ 1) to: r bottomRight - (1 @ 1) width: self width color: self color;     line: r bottomRight - (2 @ 0) to: r bottomLeft + (2 @ 0) width: self width color: self color;     line: r bottomLeft - (-1 @ 1) to: r bottomLeft - (-1 @ 1) width: self width color: self color;     line: r bottomLeft - (0 @ 2) to: r topLeft + (0 @ 2) width: self width color: self color;     line: r topLeft + (1 @ 1) to: r topLeft + (1 @ 1) width: self width color: self coloractiveEnabledNotOverUpFillStyle: aFillStyle  self stateMap atPath: #(active enabled notOver up) put: aFillStyle.  self changedaskBeforeChanging  ^askBeforeChangingmodel  ^modelscrollByKeyboard: event  | sb |  sb := event commandKeyPressed ifTrue: [ self hScrollbar ] ifFalse: [ self vScrollbar ].  (event keyValue = 30 or: [ event keyValue = 11 ]) ifTrue: [ sb scrollUp: 3.        ^true ].  (event keyValue = 31 or: [ event keyValue = 12 ]) ifTrue: [ sb scrollDown: 3.        ^true ].  ^falseisClosed  ^trueprivateMoveBy: delta  referencePosition := referencePosition + delta.  originalCenter := (originalCenter ifNil: [ self center ]) + delta.  super privateMoveBy: deltausableArea  ^Display usableAreamouseMove: evt  | editEvt |  self perform: #mouseMove: withArguments: {evt} inSuperclass: TextMorph.  evt redButtonPressed ifFalse: [ ^self ].  editEvt := evt transformedBy: (self transformedFrom: editView) inverseTransformation.  (editView bounds containsPoint: editEvt position) ifFalse: [ self startStepping: #autoScrollView: at: Time millisecondClockValue arguments: (Array with: editEvt) stepTime: 100 ] ifTrue: [ self stopSteppingSelector: #autoScrollView: ]activeFillStyle  ^self theme dialogWindowActiveFillStyleFor: selfautoDeselect  ^autoDeselect ifNil: [ self resetListSelector notNil ] ifNotNil: [ autoDeselect ]cellColumn: column row: rowIndex  | item |  item := self elementAt: rowIndex.  ^item cellMorphFor: selfnewContentMorph  ^Morph new     color: Color transparent;     hResizing: #spaceFill;     vResizing: #spaceFilltargetWith: evt  | newTarget |  newTarget := UIManager default chooseFrom: (self potentialTargets collect: [:t |  t class name asString ]) values: self potentialTargets title: self externalName , ' targets...' translated.  newTarget ifNil: [ ^self ].  self target: newTargetunsortElements  self subclassResponsibilityactivate  self submorphsDo: [:m |  m activate ]newExpander: aString forAll: controls  ^self theme newExpanderIn: self label: aString forAll: controlshandlesKeyboard: evt  self eventHandler ifNotNil: [ ^self eventHandler handlesKeyboard: evt ].  ^falsemakeBothArrows  arrows := #both.  self computeBoundsnewContentMorph  | b |  b := (self theme newButtonIn: self for: self getState: nil action: #chooseColor arguments: #() getEnabled: #enabled label: (self newHatchMorph layoutInset: 2) help: nil) hResizing: #spaceFill.  b contentHolder hResizing: #spaceFill.  ^bdefersHaloOnClickTo: aSubMorph  ^falsenewLabel: aString  ^self newLabelFor: nil label: aString getEnabled: nilnewAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpTextselectedTab  ^selectionHistory ifEmpty: [ nil ] ifNotEmpty: [ selectionHistory last ]noMorePotentialDropTarget  self model noMorePotentialDropTargetposition  ^positionnewContentMorph  ^Morph new     color: Color transparent;     changeTableLayout;     borderStyle: (BorderStyle inset width: 1);     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: self newHatchMorph;     yourselfmouseMove: evt  self perform: #mouseMove: withArguments: {evt} inSuperclass: Morph.  self enabled ifFalse: [ ^self ].  (self containsPoint: evt cursorPoint) ifTrue: [ state == #on ifTrue: [ self state: #repressed ].        state == #off ifTrue: [ self state: #pressed ] ] ifFalse: [ state == #repressed ifTrue: [ self state: #on ].        state == #pressed ifTrue: [ self state: #off ] ]initialize  super initialize.  label := 'Test label'.  state := #on.  icon := self iconNamed: #smallOkIconisMultiple  ^truepointInWorld: aPoint  ^self point: aPoint in: self worldbackgroundColor  ^Smalltalk ui theme selectionColorselectTabAt: index ifAbsent: aBlock  | tab |  tab := tabs at: index ifAbsent: [ ^aBlock value ].  tab selected: trueautoFitOnOff  self setProperty: #autoFitContents toValue: self isAutoFit not.  self isAutoFit ifTrue: [ self fit ]handleDropMorph: anEvent  | aMorph localPt |  aMorph := anEvent contents.  ((self wantsDroppedMorph: aMorph event: anEvent) and: [ aMorph wantsToBeDroppedInto: self ]) ifFalse: [ ^self ].  anEvent wasHandled: true.  localPt := (self transformedFrom: anEvent hand world) globalPointToLocal: aMorph referencePosition.  aMorph referencePosition: localPt.  self acceptDroppingMorph: aMorph event: anEvent.  aMorph justDroppedInto: self event: anEventmouseLeaveDragging: anEvent onItem: aMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersservicesForFileNamed: aString  | allServices |  allServices := FileServices itemsForFile: aString.  ^allServices reject: [:svc |  self unwantedSelectors includes: svc selector ]expandAndRefresh  self expand.  self refreshTableadjustWakeupTimes: now  | deltaTime |  deltaTime := now - lastStepTime.  stepList do: [:entry |  entry scheduledTime: entry scheduledTime + deltaTime ].  lastStepTime := nowmerge: aPolygon  | shared mv vv hv xx |  shared := vertices select: [:mine |  aPolygon vertices includes: mine ].  shared size < 2 ifTrue: [ ^nil ].  mv := vertices asOrderedCollection.  [ shared includes: mv first ] whileFalse: [ vv := mv removeFirst.        mv addLast: vv ].  hv := aPolygon vertices asOrderedCollection.  [ mv first = hv first ] whileFalse: [ vv := hv removeFirst.        hv addLast: vv ].  [ shared size > 2 ] whileTrue: [ shared := shared asOrderedCollection.        (self mergeDropThird: mv in: hv from: shared) ifNil: [ ^nil ] ].  mv second = hv last ifTrue: [ mv           removeFirst;           removeFirst.        ^self setVertices: (hv , mv) asArray ].  hv second = mv last ifTrue: [ hv           removeFirst;           removeFirst.        ^self setVertices: (mv , hv) asArray ].  mv second = hv second ifTrue: [ hv removeFirst.        mv remove: mv second.        xx := mv removeFirst.        ^self setVertices: (hv , (Array with: xx) , mv reversed) asArray ].  mv last = hv last ifTrue: [ mv removeLast.        hv removeFirst.        ^self setVertices: (mv , hv reversed) asArray ].  ^nildismissViaHalo  self class resetmeasureContents  | f iconWidth |  f := self fontToUse.  iconWidth := self hasIcon ifTrue: [ self icon width + 2 ] ifFalse: [ 0 ].  ^((13 * indentLevel + 15 + iconWidth + (contents widthToDisplayInTree: self) max: self minimumWidth) @ ((contents heightToDisplayInTree: self) max: f height) + (self layoutInset * 2)) ceilingprepareForRotating  ^self addFlexShellreleaseActionMap  self removeProperty: #actionMapmouseEnterDragging: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseEnterDragging from: sourceMorphminResizerX  ^scroller left + self minResizerOffsetshowScrollBars  self     vShowScrollBar;     hShowScrollBartestInset  | lf rectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 140 @ 60) equals: rectanglerootNodeFromItem: anItem  ^(self rootNodeClassFromItem: anItem) with: anItem model: selfborderNormal  self borderStyle: (BorderStyle width: 2 color: Color transparent)borderDashOffset  borderDashSpec size < 4 ifTrue: [ ^0.0 ].  ^borderDashSpec fourth asFloatstartSteppingSubmorphsOf: aMorph  aMorph allMorphsDo: [:m |  m wantsSteps ifTrue: [ m arrangeToStartSteppingIn: m world ] ]rowAtLocation: aPoint  | pointInListMorphCoords |  pointInListMorphCoords := (self scroller transformFrom: self) transform: aPoint.  ^self listMorph rowAtLocation: pointInListMorphCoordsis: anIndex afterColumn: aColumnIndex  ^self subclassResponsibilitydrawLineFrom: startPoint to: stopPoint on: aCanvas  ^aCanvas line: startPoint to: stopPoint width: self width color: self colordropNotifyRecipient: anObject  dropNotifyRecipient := anObjectcontentsMenu: aMenu  | expanded collapsed |  expanded := self windowsSatisfying: [:w |  w isCollapsed not ].  collapsed := self windowsSatisfying: [:w |  w isCollapsed ].  (expanded asSortedCollection: [:w1 :w2 |  w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [:w |  aMenu add: (self truncatedMenuLabelFor: w label) target: w selector: #activateAndForceLabelToShow.        aMenu lastItem icon: w taskbarIcon.        w model canDiscardEdits ifFalse: [ aMenu lastItem color: Color red ] ].  aMenu addLine.  (collapsed asSortedCollection: [:w1 :w2 |  w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [:w |  aMenu add: (self truncatedMenuLabelFor: w label) target: w selector: #collapseOrExpand.        aMenu lastItem icon: w taskbarIcon.        w model canDiscardEdits ifFalse: [ aMenu lastItem color: Color red ] ].  aMenu addLine.  ((self submorphs reject: [:sm |  (expanded includes: sm) or: [ collapsed includes: sm ] ]) asSortedCollection: [:w1 :w2 |  w1 class name caseInsensitiveLessOrEqual: w2 class name ]) do: [:w |  aMenu add: (self truncatedMenuLabelFor: w class name) target: w selector: #comeToFront.        aMenu lastItem icon: w taskbarIcon ].  ^aMenuhMorph  ^hMorphnullIndex  ^self subclassResponsibilitybringTopmostsToFront  submorphs select: [:m |  m wantsToBeTopmost ] thenDo: [:m |  self addMorphInLayer: m ]adoptPaneColor  self adoptPaneColor: self paneColortextSize: aSymbol  (self sizes includes: aSymbol) ifFalse: [ self error ].  size := aSymbolstepTime  ^100hasSubmorphs  ^submorphs notEmptywrapCenteringString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self wrapCenteringvScrollBarHeight  | h |  h := bounds height - (2 * borderWidth).  self hIsScrollbarNeeded ifTrue: [ h := h - self scrollBarThickness ].  ^hadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self fillStyle: self normalFillStyletextColor: aColor  color = aColor ifTrue: [ ^self ].  color := aColor.  text addAttribute: (TextColor color: aColor).  self changedscrollBarAction  ^self valueOfProperty: #scrollBarActionstring: aString fontName: aName size: aSize  self string: aString fontName: aName size: aSize wrap: truecomputeCurvedSegmentCtrlPoints  | ctrls vert |  vert := self adjustSegmentPointsForArrows.  ctrls := (1 to: vert size) collect: [:i |  | prior current next lenpc lencn ctrl1 ctrl2 tangent |        prior := vert atWrap: i - 1.        current := vert atWrap: i.        next := vert atWrap: i + 1.        tangent := (next - prior) / 2.        lenpc := current distanceTo: prior.        lencn := next dist: current.        lenpc = 0 ifTrue: [ ctrl1 := prior ] ifFalse: [ ctrl1 := current - (tangent / (1 + (lencn / lenpc))) ].        lencn = 0 ifTrue: [ ctrl2 := next ] ifFalse: [ ctrl2 := current + (tangent / (1 + (lenpc / lencn))) ].        {ctrl1 asFloatPoint .         current .         ctrl2 asFloatPoint} ].  ^ctrlsnewOKButtonFor: aModel  ^self newOKButtonFor: aModel getEnabled: nilgetSelector  ^viewSelectorisMouseDown  ^self type == #mouseDownmouseDown: event  self editView ifNotNil: [ self editView mouseDownFromTextMorph: event ].  super mouseDown: event.  self flag: #hack.  (self editView respondsTo: #highlights) ifTrue: [ self editView highlights detect: [:h |  h containsPoint: event position in: (self bounds: self editView innerBounds from: self) ] ifFound: [:hl |  hl clicked: event ] ]selectedNode  ^self selectedNodePath ifNotNil: [:path |  path ifEmpty: [ nil ] ifNotEmpty: [ path last ] ]newSeparator  ^self theme newSeparatorIn: selfnewAlphaSelector: aModel getAlpha: getSel setAlpha: setSel help: helpText  ^self theme newAlphaSelectorIn: self for: aModel getAlpha: getSel setAlpha: setSel help: helpTextallNonSubmorphMorphs  ^OrderedCollection newaddSeparator  self addMorphBack: MenubarSeparatorMorph newballoonColor  ^self valueOfProperty: #balloonColor ifAbsent: [ self defaultBalloonColor ]newScrollingIndex  ^newScrollingIndexresizeWidget  self resizeField.  self resizeButtonthemeChanged  super themeChanged.  self     color: self defaultColor;     borderWidth: self defaultBorderWidthparagraph  | newParagraph |  paragraph ifNotNil: [ ^paragraph ].  self setProperty: #CreatingParagraph toValue: true.  self setDefaultContentsIfNil.  newParagraph := Paragraph new textOwner: self owner.  newParagraph wantsColumnBreaks: successor notNil.  newParagraph compose: text style: textStyle copy from: self startingIndex in: self container.  wrapFlag ifFalse: [ newParagraph adjustRightX ].  newParagraph focused: self currentHand keyboardFocus == self.  paragraph := newParagraph.  self fit.  self removeProperty: #CreatingParagraph.  ^paragraphwantsSteps  ^self hasProperty: #doesButtonActionannounceDeActivated  self announce: (WindowDeActivated new           window: self;           yourself)open  self menuBarItems do: [:each |  self add: each label icon: each icon help: each help subMenu: (each subMenu ifNotNil: #asMenubarMenuMorph) action: each action keyText: each keyText.        each separator ifTrue: [ self addSeparator ] ].  self     adhereToTop;     openInWorldresizeCursor  ^Cursor resizeForEdge: #topRighttestIsAboveRow  self assert: (strategy is: 3 aboveRow: 4).  self deny: (strategy is: 3 aboveRow: 2).  self deny: (strategy is: 3 aboveRow: 3)isActive  ^self isWindowActive: selfdefaultBounds  ^0 @ 0 extent: 40 @ 40drawCheckOn: aCanvas  | topLeft icon |  topLeft := self computeCheckTopLeft.  icon := self retrieveCheckIcon.  aCanvas drawImage: icon at: topLefticon  ^self iconNamed: #homeIconmouseDown: evt  self flag: #todo.  (evt yellowButtonPressed and: [ evt commandKeyPressed not ]) ifTrue: [ (self yellowButtonActivity: evt shiftPressed) ifTrue: [ ^super mouseDown: evt ] ].  scroller hasSubmorphs ifTrue: [ scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self)) ].  self eventHandler ifNotNil: [ self eventHandler mouseDown: evt fromMorph: self ]setBoundsWithFlex: newFrame  self isFlexed ifTrue: [ super bounds: ((owner transform globalPointToLocal: newFrame topLeft) extent: newFrame extent) ] ifFalse: [ super bounds: newFrame ]setValueSelector  ^setValueSelectoraddPaneHSplitters  | remaining targetBottom sameBottom sameTop |  remaining := paneMorphs reject: [:each |  each layoutFrame bottomFraction = 1 or: [ each layoutFrame bottomFraction = 0 ] ].  [ remaining notEmpty ] whileTrue: [ targetBottom := remaining first layoutFrame bottomFraction.        sameBottom := remaining select: [:each |  each layoutFrame bottomFraction = targetBottom ].        sameTop := paneMorphs select: [:each |  each layoutFrame topFraction = targetBottom ].        remaining := remaining copyWithoutAll: (self addPaneHSplitterBetween: sameBottom and: sameTop) ]secondarySelection: aSubstring  secondarySelection := aSubstringminHeight  ^super minHeight max: self theme buttonMinHeightleft: aNumber  self position: aNumber @ bounds topgetValueSelector  ^getValueSelectorgetLabelSelector  ^getLabelSelectoritemSelectedAmongMultiple: index  ^self isMultipleSelection ifTrue: [ (self listSelectionAt: index) == true ] ifFalse: [ false ]expand  isExpanded := true.  recentlyChanged := true.  self dataSource updateSelectionWithCollectBlock: [:indexOfCurrentSelection :indexOfCollapsedElement |  indexOfCurrentSelection <= indexOfCollapsedElement ifTrue: [ indexOfCurrentSelection ] ifFalse: [ indexOfCurrentSelection + self numberOfVisibleChildren ] ]avoidsOcclusions  ^avoidsOcclusions ifNil: [ false ]refresh  self ensureAtLeastOneColumn.  self recalculateVerticalScrollBar.  self verticalScrollBar changed.  horizontalScrollBar ifNotNil: [ self horizontalScrollBar changed ].  self container changedbeIconBottom  iconPosition := #bottom.  self update: getIconSelectornewToolSpacer  ^self theme newToolSpacerIn: selfmargin  ^marginsimulateClick  self simulateClickWith: MouseEvent redButtoncurrentCursor: anObject  currentCursor := anObjectclicked: event inTheCheckboxOf: aTargetMorph  | position |  aTargetMorph ifNil: [ ^false ].  position := aTargetMorph point: event position from: client.  ^self isCheckList and: [ (aTargetMorph checkClickableZone translateBy: 2 @ 0) containsPoint: position ]waitForDelay1: delay1 delay2: delay2  | now scrollDelay |  timeOfLastScroll ifNil: [ self resetTimer ].  now := Time millisecondClockValue.  (scrollDelay := currentScrollDelay) ifNil: [ scrollDelay := delay1 ].  currentScrollDelay := scrollDelay * 9 // 10 max: delay2.  timeOfLastScroll := now.  ^truemessage: aStringOrText title: aString  ^self theme messageIn: self text: aStringOrText title: aStringdrawSubmorphsOnAthensCanvas: anAthensCanvas  self drawClippedOnAthensCanvas: anAthensCanvas during: [ submorphs reverseDo: [:m |  anAthensCanvas fullDrawMorph: m ] ]columnInset  ^columnInset ifNil: [ columnInset := 0 ]rightBoundary  | morphs |  morphs := rightOrBottom reject: [:m |  m layoutFrame rightFraction ~= 1 and: [ m layoutFrame leftFraction = m layoutFrame rightFraction ] ].  morphs ifEmpty: [ ^(self splitterRight ifNil: [ self containingWindow panelRect right ] ifNotNil: [:s |  s left ]) + 25 ].  ^(morphs collect: [:m |  m right - m minExtent x - (m layoutFrame leftOffset ifNil: [ 0 ]) + (self layoutFrame rightOffset ifNil: [ 0 ]) ]) min - self class splitterWidthabort: aStringOrText title: aString  ^self theme abortIn: self text: aStringOrText title: aStringkeyStroke: anEvent  anEvent keyValue = 28 ifTrue: [ self moveSelectionRight: -1 event: anEvent ].  anEvent keyValue = 29 ifTrue: [ self moveSelectionRight: 1 event: anEvent ].  anEvent keyValue = 31 ifTrue: [ selectedItem ifNotNil: [ selectedItem subMenu ifNotNil: [:subMenu |  subMenu activateFromKeyboard: anEvent ] ] ].  ^super keyStroke: anEventtopLeft  ^bounds topLeftplayMinimizeSound  self theme windowMinimizeSound playexpandedFormForMorph: aMorph  ^(self selectedMorph = aMorph and: [ self theme selectionColor luminance < 0.6 ]) ifTrue: [ self theme whiteTreeExpandedForm ] ifFalse: [ self theme treeExpandedForm ]mouseMove: anEvent  self canResizeColumn ifFalse: [ ^self ].  anEvent hand temporaryCursor ifNil: [ ^self ].  self class fastSplitterResize ifTrue: [ traceMorph ifNil: [ traceMorph := Morph newBounds: self bounds.              traceMorph borderColor: Color lightGray.              traceMorph borderWidth: 1.              self owner addMorph: traceMorph ].        traceMorph position: (anEvent cursorPoint x - lastMouse second x) @ traceMorph position y ] ifFalse: [ self updateFromEvent: anEvent ]hasContents  hasContentsSelector ifNil: [ ^super hasContents ].  ^self sendToModel: hasContentsSelectorupdateExposedRows  | visibleRows columns columnWidths startIndex |  self canRefreshValues ifFalse: [ ^self ].  visibleRows := self calculateMaxVisibleRows.  startIndex := self calculateStartIndexWhenShowing: visibleRows.  columns := self table columns.  columnWidths := self calculateColumnWidths.  exposedRows := SmallDictionary new.  startIndex to: (startIndex + visibleRows - 1 min: self table numberOfRows) do: [:rowIndex |  | row |        row := FTTableRowMorph table: self table.        (self exposedColumnsRange: columnWidths) do: [:columnIndex |  | cell |              cell := self table dataSource cellColumn: (columns at: columnIndex) row: rowIndex.              cell width: (columnWidths at: columnIndex).              row addMorphBack: cell ].        row privateOwner: self.        exposedRows at: rowIndex put: row ]addTextAnchorMenuItems: topMenu hand: aHand  | aMenu |  aMenu := UIManager default newMenuIn: self for: self.  aMenu addUpdating: #hasInlineAnchorString selector: #changeInlineAnchor.  aMenu addUpdating: #hasParagraphAnchorString selector: #changeParagraphAnchor.  aMenu addUpdating: #hasDocumentAnchorString selector: #changeDocumentAnchor.  topMenu ifNotNil: [ topMenu add: 'text anchor' subMenu: aMenu ].  ^aMenumaybeCollapse: evt with: collapseHandle  evt hand obtainHalo: self.  self delete.  (collapseHandle containsPoint: evt cursorPoint) ifFalse: [ target addHalo: evt ] ifTrue: [ target collapse ]cursorPoint  ^self positionmultiSelection  ^multiSelection ifNil: [ multiSelection := false ]newColorChooserFor: aModel getColor: getSel setColor: setSel getEnabled: enabledSel help: helpText  ^self theme newColorChooserIn: self for: aModel getColor: getSel setColor: setSel getEnabled: enabledSel help: helpTextinnerBounds  | inner |  inner := super innerBounds.  inner := inner withBottom: inner bottom - self pagerHeight.  ^innermouseStillDownStepRate  ^1removeLabelArea  self removeGrips.  labelArea delete.  label := nil.  (self isCollapsed not or: [ self isTaskbarPresent ]) ifTrue: [ self addGripsIfWanted ]setUp  super setUp.  state := self actualClass context: (FTPropertyColumnSortingStrategy new           property: #yourself;           yourself).  state context state: statebeSmoothCurve  smoothCurve == true ifFalse: [ smoothCurve := true.        self computeBounds ]clipLayoutCells  ^self valueOfProperty: #clipLayoutCells ifAbsent: [ false ]position  ^temporaryCursor ifNil: [ bounds topLeft ] ifNotNil: [ temporaryCursorOffset ifNil: [ bounds topLeft ] ifNotNil: [:anOffset |  bounds topLeft - anOffset ] ]first  ^firstautoDeselection  ^autoDeselection ifNil: [ autoDeselection := false ]newRow  ^self theme newRowIn: self for: #()newEditableDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel ghostText: ghostText getEnabled: enabledSel help: helpText  ^self theme newEditableDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: String default: '' ghostText: ghostText getEnabled: enabledSel useIndex: false help: helpTextchildrenBlock  ^childrenBlockreleaseCachedState  | oo |  super releaseCachedState.  cacheCanvas := nil.  oo := owner.  self removeAllMorphs.  self initialize.  self privateOwner: oo.  self releaseAllFocusownerChanged  super ownerChanged.  self adjustLayoutintersects: aRectangle  | rect |  (super intersects: aRectangle) ifFalse: [ ^false ].  rect := self bounds: aRectangle in: self world.  self lineSegmentsDo: [:p1 :p2 |  (rect intersectsLineFrom: p1 to: p2) ifTrue: [ ^true ] ].  ^falseinitialize  super initialize.  self     borderWidth: 0;     changeTableLayout;     labelMorph: self newLabelMorph;     solidLabelMorph: self newLabelMorph;     contentMorph: self newContentMorph;     addMorphBack: self contentMorphaddAlarm: aSelector with: arg1 after: delayTime  ^self addAlarm: aSelector withArguments: (Array with: arg1) after: delayTimehandlesMouseDown: evt  ^truebuildContents  super buildContents.  self updatePagersearchText: aString  ^(self class searchStrategies at: self searchStrategy ifAbsent: [ self class searchStrategies at: #default ]) searchWith: aString dataSource: selfdefaultColor  ^self theme settings derivedMenuColorextent: newExtent  super extent: newExtent.  self selectSubmorphsOf: self pasteUpMorphnewPosition  ^newPositionnewExpander: aString forAll: controls  ^self theme newExpanderIn: self label: aString forAll: controlsmouseEnterDragging: anEvent onItem: aMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlerstestMouseEnterDraggingFromMorph  | event |  event := MouseEvent basicNew setType: #mouseOver position: nil buttons: 2 hand: Morph new.  morph eventHandler on: #mouseEnterDragging send: #value to: true.  self assert: (morph handleMouseEnter: event) identicalTo: truerectangle  ^self topLeft corner: self bottomRighthandlesKeyDown: evt  ^self existsSubscriptionsFor: #keyDowndrawSubmorphsOnAthensCanvas: anAthensCanvas  super drawSubmorphsOnAthensCanvas: anAthensCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOnAthensCanvas: anAthensCanvas ]colorSelected: aColor  self basicSelectedColor: aColorwindow  ^windowtopOffset  ^topOffsetvScrollbarShowNever  self vScrollbar showNever.  self updateScrollbarsscrollToShow: aRectangle  | offset |  offset := self scroller offset.  (aRectangle top - offset y >= 0 and: [ aRectangle bottom - offset y <= self innerBounds height ]) ifFalse: [ offset := offset x @ (aRectangle top min: self scrollTarget height - self innerBounds height) ].  (aRectangle left - offset x >= 0 and: [ aRectangle right - offset x <= self innerBounds width ]) ifFalse: [ offset := (aRectangle left min: self scrollTarget width - self innerBounds width) @ offset y ].  offset = self scroller offset ifFalse: [ self scroller offset: offset.        self setScrollDeltas ]beExplicit  startGrow: evt with: growHandle  | botRt |  self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.  botRt := target point: target bottomRight in: owner.  positionOffset := (self world viewBox containsPoint: botRt) ifTrue: [ evt cursorPoint - botRt ] ifFalse: [ 0 @ 0 ].  originalExtent := target extentveryDeepInner: deepCopier  super veryDeepInner: deepCopier.  viewSelector := viewSelector veryDeepCopyWith: deepCopier.  lastSketchForm := lastSketchForm veryDeepCopyWith: deepCopier.  lastFormShown := lastFormShown veryDeepCopyWith: deepCopier.  drawTime := drawTime veryDeepCopyWith: deepCopierfullDrawOn: aCanvas  self visible ifFalse: [ ^self ].  (aCanvas isVisible: self fullBounds) ifFalse: [ ^self ].  (self hasProperty: #errorOnDraw) ifTrue: [ ^self drawErrorOn: aCanvas ].  [ self hasDropShadow ifTrue: [ self drawDropShadowOn: aCanvas ].  aCanvas roundCornersOf: self during: [ (aCanvas isVisible: self bounds) ifTrue: [ aCanvas drawMorph: self ].        self drawSubmorphsOn: aCanvas.        self drawDropHighlightOn: aCanvas.        self drawMouseDownHighlightOn: aCanvas ] ] on: Error do: [:err |  self setProperty: #errorOnDraw toValue: true.        self setProperty: #drawError toValue: err freeze.        ^self drawErrorOn: aCanvas ]newAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpTextnewStateForEnabled: aBoolean  ^self subclassResponsibilitynewDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel help: helpText  ^self newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: nil useIndex: true help: helpTextobtainHaloForEvent: evt andRemoveAllHandlesBut: aHandle  evt hand obtainHalo: self.  self removeAllHandlesBut: aHandlepressed: anIndex  self complexContents pressed: anIndexforwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectioncomputeSubmorphsToDraw  owner width < tab showIconTreshold ifTrue: [ (storedIcon isNil and: [ icon notNil ]) ifTrue: [ storedIcon := icon.              self removeMorph: icon ].        ^{morph} ].  storedIcon ifNotNil: [ self addMorphFront: storedIcon.        storedIcon := nil ].  ^self submorphsleftFraction: aNumber offset: anInteger  leftFraction := aNumber.  leftOffset := anIntegerdrawOnAthensCanvas: anAthensCanvas  | fauxBounds |  self setDefaultContentsIfNil.  super drawOnAthensCanvas: anAthensCanvas.  self startingIndex > text size ifTrue: [ ^self ].  fauxBounds := self bounds topLeft corner: self innerBounds bottomRight.  self paragraph drawOnAthensCanvas: anAthensCanvas bounds: fauxBounds color: colorhandlerForMetaMenu: evt  self isWorldMorph ifTrue: [ ^self ].  evt handler ifNotNil: [ evt handler isWorldMorph ifTrue: [ ^self ] ].  ^nilstartStepping: aMorph  ^self startStepping: aMorph at: Time millisecondClockValue selector: #stepAt: arguments: nil stepTime: nilisBordered  ^falsemouseUp: evt  self noMorePotentialDropTarget.  super mouseUp: evtsortElements: aSortFunction  unsortedElements ifNil: [ unsortedElements := self elements ].  self elements: (self elements sorted: aSortFunction)runStepMethods  worldState runStepMethodsIn: selfintoWorld: aWorld  aWorld ifNil: [ ^self ].  super intoWorld: aWorld.  intoWorldCount := intoWorldCount + 1releaseAllFocus  mouseFocus := nil.  self newKeyboardFocus: nilitem  ^itemfocusIndicatorCornerRadius  ^self theme buttonFocusIndicatorCornerRadiusFor: selfisDefault  ^self valueOfProperty: #isDefault ifAbsent: [ false ]keyStroke: anEvent from: aTreeMorph  | c |  c := anEvent keyCharacter.  c = $b ifTrue: [ self browseItem.        ^true ].  c = $i ifTrue: [ self inspectItem.        ^true ].  c = $I ifTrue: [ self exploreItem.        ^true ].  ^falseremoveHaloAround: aMorph  | halo |  halo := self halo.  halo ifNil: [ ^self ].  halo target == aMorph ifFalse: [ ^self ].  self removeProperty: #halo.  halo deleteacceptDroppingMorph: aMorph event: evt  self model acceptDroppingMorph: aMorph event: evt inMorph: self.  self resetPotentialDropMorph.  evt hand releaseMouseFocus: self.  Cursor normal showbeLeft  self option: #leftopenNodePath: anArray  | found |  anArray isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ (each complexContents = anArray first or: [ anArray first isNil ]) ifTrue: [ found := each ] ] ].  found ifNotNil: [ found isExpanded ifFalse: [ found toggleExpandedState.              container adjustSubmorphPositions ].        found changed.        anArray size = 1 ifTrue: [ ^container setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild openNodePath: anArray allButFirst ] ].  ^container setSelectedMorph: nilflushLayoutCache  cachedMinExtent := nilhasIconOrMarker  ^self hasIcon or: [ self hasMarker ]withPinBox  pinBox ifNotNil: [ pinBox delete ].  pinBox := self iconButtonCalling: #pinBoxClicked withForm: self pinForm scaledByDisplayScaleFactor helpText: 'Keep this menu up'.  self addMorph: pinBox asElementNumber: 4textAlignmentSymbol  ^self editor textAlignmentSymbolpassiveEnabledNotOverUpFillStyle: aFillStyle  self stateMap atPath: #(passive enabled notOver up) put: aFillStyle.  self changedisMoved  ^falseremovePager  self pager ifNotNil: [ self removeMorph: self pager.        pager := nil.        self updateList.        self resizerChanged ]openOn: aClass  rootClass := aClass.  (self dialogWindowIn: self currentWorld title: 'All Object subclasses') openInWorldarguments: aCollection  arguments := aCollection asArray copydotColor  ^dotColor ifNil: [ self setDefaultColors.        dotColor ]selectionFrame  ^self bounds: self bounds in: containerhandleTodayTouched  self date: Date today.  self changedscrollToIndex: anIndex  (self container isRowIndexFullyVisible: anIndex) ifTrue: [ ^self ].  anIndex <= self showIndex ifTrue: [ self moveShowIndexTo: anIndex ] ifFalse: [ self moveShowIndexTo: (self selectionModeStrategy indexForRow: anIndex - self container calculateMinVisibleRows + 1) ]drawForForm: aForm on: aCanvas  | scale shrunkForm viewedObjectBox interimCanvas |  viewedObjectBox := aForm boundingBox.  scale := self scaleFor: viewedObjectBox in: self innerBounds.  interimCanvas := Display defaultCanvasClass extent: viewedObjectBox extent depth: aCanvas depth.  interimCanvas translateBy: viewedObjectBox topLeft negated during: [:tempCanvas |  tempCanvas drawImage: aForm at: 0 @ 0 ].  shrunkForm := interimCanvas form magnify: interimCanvas form boundingBox by: scale smoothing: 1.  lastFormShown := shrunkForm.  aCanvas paintImage: shrunkForm at: self center - shrunkForm boundingBox centerlastChild  | c |  c := self firstChild ifNil: [ ^nil ].  [ c nextSibling isNil ] whileFalse: [ c := c nextSibling ].  ^cupdate: aSymbol  super update: aSymbol.  aSymbol = self getValueSelector ifTrue: [ ^self updateValue ].  aSymbol = self getEnabledSelector ifTrue: [ ^self updateEnabled ]addFontStyleHandle: haloSpec  innerTarget isTextMorph ifTrue: [ self addHandle: haloSpec on: #mouseDown send: #chooseStyle to: innerTarget ]wantsDropSelector  ^wantsDropSelectorvSpaceFill: aBool  flags := aBool ifTrue: [ self flags bitOr: 2 ] ifFalse: [ self flags bitClear: 2 ]grabSelfOrTopRenderer: evt  | renderer |  renderer := self topRendererOrSelf.  evt hand grabMorph: renderer.  (renderer isKindOf: SystemWindow) ifTrue: [ renderer position: evt hand position + (renderer position - evt startPoint) ]unrotatedWidth  vertices size = 2 ifTrue: [ ^self borderWidth ].  ^((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) widthicon  ^self iconNamed: #smallExpertIconposition: aPoint  | adjustedPosition delta box |  adjustedPosition := aPoint.  temporaryCursor ifNotNil: [ adjustedPosition := adjustedPosition + temporaryCursorOffset ].  delta := adjustedPosition - bounds topLeft.  (delta x = 0 and: [ delta y = 0 ]) ifTrue: [ ^self ].  box := self fullBounds.  (delta dotProduct: delta) > 100 ifTrue: [ self invalidRect: box.        self invalidRect: (box translateBy: delta) ] ifFalse: [ self invalidRect: (box merge: (box translateBy: delta)) ].  self privateFullMoveBy: deltareleaseCachedState  super releaseCachedState.  self releaseParagraphpotentialDropRow  ^potentialDropRow ifNil: [ 0 ]newOKButtonFor: aModel  ^self newOKButtonFor: aModel getEnabled: nilstart: aNumber  startValue := aNumberupdateData  children := nilgetMenuSelector  ^getMenuSelectornumberOfRows  ^self rootItem numberOfVisibleChildrenpressed: anIndex  self owner owner pressed: anIndexresizeContainer  | topLeft bottomRight |  topLeft := (self bounds left - self borderWidth) @ self bounds top - self borderWidth.  bottomRight := (self bounds right - self verticalScrollBarWidth - self borderWidth) @ (self bounds bottom - self horizontalScrollBarHeight - self borderWidth).  self container bounds: (function isExplicit ifTrue: [ function resizeContainerFrom: topLeft to: bottomRight ] ifFalse: [ topLeft corner: bottomRight ])wantsHaloFromClick  ^owner notNil and: [ owner hasSubmorphs ]actionSelector: aSymbol  actionSelector := aSymbolmouseDown: evt  (evt shiftPressed and: [ self isEditable ]) ifTrue: [ ^super mouseDown: evt ].  isSelected ifTrue: [ evt hand newMouseFocus: nil.        owner selectItem: nil event: evt ] ifFalse: [ evt hand newMouseFocus: owner.        owner selectItem: self event: evt ]grabWindow  | windows choice |  windows := self world visibleSystemWindows.  choice := UIManager default chooseFrom: (windows collect: [:e |  e labelString ]) values: windows lines: #() message: 'Choose a window to add to the organiser' translated title: 'Grab window' translated.  choice ifNotNil: [ self addWindow: choice ]target  ^targetupdate: aSymbol  aSymbol = self nodeListSelector ifTrue: [ ^self updateList ].  super update: aSymbollayoutFrame  ^extension ifNotNil: [ extension layoutFrame ]initialize  super initialize.  self setDefaultParameters.  self listDirection: #topToBottom.  self hResizing: #shrinkWrap.  self vResizing: #shrinkWrap.  stayUp := false.  self setProperty: #morphicLayerNumber toValue: self morphicLayerNumber.  self theme currentSettings preferRoundCorner ifTrue: [ self useRoundedCorners ]withSuccessorsDo: aBlock  | each |  each := self.  [ each isNil ] whileFalse: [ aBlock value: each.        each := each successor ]drawOn: aCanvas  super drawOn: aCanvas.  searchedElement ifNotNil: [ aCanvas clipBy: self innerBounds during: [:c |  c fillRectangle: self searchedFrame color: (self secondarySelectionColor ifNil: [ self theme secondarySelectionColor ]) ] ].  selectedMorph ifNotNil: [ aCanvas clipBy: self innerBounds during: [:c |  c fillRectangle: self selectionFrame color: (self selectionColorToUse ifNil: [ self theme selectionColor ]) ] ].  self drawLinesOn: aCanvasexpandBoxHit  self isCollapsed ifTrue: [ self playRestoreUpSound.        self           hide;           collapseOrExpand.        self unexpandedFrame ifNil: [ self unexpandedFrame: fullFrame ].        self           fullscreen;           setExpandBoxBalloonText.        ^self show ].  self unexpandedFrame ifNil: [ self playMaximizeSound.        self theme shouldUseAnimations ifTrue: [ self animateMaximize ].        self           unexpandedFrame: fullFrame;           fullscreen ] ifNotNil: [ self playRestoreDownSound.        self theme shouldUseAnimations ifTrue: [ self animateRestore ].        self           bounds: self unexpandedFrame;           unexpandedFrame: nil ].  self setExpandBoxBalloonTextcorrectFrom: start to: stop with: aString  editor ifNotNil: [ editor correctFrom: start to: stop with: aString ]isMaximized  ^self unexpandedFrame notNilquestionWithoutCancel: aStringOrText title: aString  ^self theme questionWithoutCancelIn: self text: aStringOrText title: aStringcolumnOrderOfWidthDistribution  | idxToLast idxToFirstReversed |  self startColumnIndex isZero ifTrue: [ ^1 to: self table numberOfColumns ].  idxToLast := startColumnIndex to: self table numberOfColumns.  idxToFirstReversed := startColumnIndex > 1 ifTrue: [ startColumnIndex - 1 to: 1 by: -1 ] ifFalse: [ #() ].  ^idxToLast , idxToFirstReversedhasToggle  ^complexContents hasContentsgapAfterToggle  ^gapAfterToggle ifNil: [ gapAfterToggle := 5 ]scrollTabsRight  self visibleTabRange: (self visibleTabRange last \\ self tabs size + 1 to: 0).  self updateTabsgetImageSelector: anObject  getImageSelector := anObjectminimize  self isMinimized ifFalse: [ self collapseBoxHit ]model  ^modelpreview: anObject  preview := anObjectdate  ^dateitems: anObject  items := anObjectaddHalo: evt from: formerHaloOwner  ^self addHalo: evtoptimalExtent  ^self listMorph extent + (self borderWidth * 2) + self scrollBarThicknesstabsAndControls  | visibleTabs firstIndex |  self tabs ifEmpty: [ self visibleTabRange: (1 to: 0).        ^#() ].  visibleTabs := self calculateVisibleTabs.  visibleTabs ifEmpty: [ self visibleTabRange: (1 to: 0).        ^#() ].  firstIndex := self tabs indexOf: visibleTabs first.  self visibleTabRange: (firstIndex to: firstIndex + visibleTabs size - 1).  visibleTabs size = self tabs size ifFalse: [ visibleTabs           add: self newSpacer;           addAll: self controls.        self cornerStyle = #rounded ifTrue: [ visibleTabs add: self newEndSpacer ] ].  ^visibleTabslastRefresh  ^lastRefresh ifNil: [ lastRefresh := 0 ]focusIndicatorMorph  ^self theme focusIndicatorMorphFor: selfkern  ^kerncomposeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks  wantsColumnBreaks := argWantsColumnBreaks.  lines := argLinesCollection.  theTextStyle := argTextStyle.  theText := argText.  theContainer := argContainer.  deltaCharIndex := argDelta.  currCharIndex := startCharIndex := argStart.  stopCharIndex := argStop.  prevLines := argPriorLines.  currentY := argStartY.  defaultLineHeight := theTextStyle lineGrid.  maxRightX := theContainer left.  possibleSlide := stopCharIndex < theText size and: [ theContainer isMemberOf: Rectangle ].  nowSliding := false.  prevIndex := 1.  scanner := CompositionScanner new text: theText textStyle: theTextStyle.  scanner wantsColumnBreaks: wantsColumnBreaks.  isFirstLine := true.  self composeAllLines.  isFirstLine ifTrue: [ self addNullLineWithIndex: startCharIndex andRectangle: (theContainer left @ theContainer top extent: 0 @ defaultLineHeight) ] ifFalse: [ self fixupLastLineIfCR ].  ^{lines asArray .   maxRightX}fillStyleToUse  ^self perform: (self availableFillStyles at: (self interactionStates indexOf: self interactionState))autoMultiSelection  ^self listManager autoMultiSelectionhasDragAndDropEnabledString  ^self dragNDropEnabled -> 'accept drops' translatedselectedIndex  ^selectedIndexaddExportMenuItems: aMenu hand: aHandMorph  aMenu ifNotNil: [ | aSubMenu |        aSubMenu := UIManager default newMenuIn: self for: self.        aSubMenu add: 'BMP file' selector: #exportAsBMP.        aSubMenu add: 'GIF file' selector: #exportAsGIF.        aSubMenu add: 'JPEG file' selector: #exportAsJPEG.        aSubMenu add: 'PNG file' selector: #exportAsPNG.        aMenu add: 'export...' icon: (self iconNamed: #smallExportIcon) subMenu: aSubMenu.        aMenu lastItem icon: (self iconNamed: #smallExportIcon) ]playOpenSound  self theme windowOpenSound playtopRight  ^bounds topRightselectAll  self table selectIndexes: (1 to: self table numberOfRows) asArrayaction  ^self actionSelectorgetIconSelector  ^getIconSelectorframeRectangle0: aRectangle on: aCanvas  aCanvas frameAndFillRectangle: aRectangle fillColor: Color transparent borderWidth: self width borderColor: self colorbounds  container ifNil: [ ^bounds ].  ^container bounds ifNil: [ bounds ]style: anObject  style := anObject.  self changedtoggleImageForm  ^isExpanded ifTrue: [ container expandedFormForMorph: self ] ifFalse: [ container notExpandedFormForMorph: self ]layout: aMorph in: newBounds  aMorph submorphsDo: [:m |  m layoutProportionallyIn: newBounds ]addNodePath: aPath  self selectedNodePathList add: aPathselectedPressedBorderStyle  ^self theme buttonSelectedPressedBorderStyleFor: selfclose  self deleteeventHandler: anEventHandler  self assureExtension eventHandler: anEventHandlerdrawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: aCanvas ]testSortDataSource  self subclassResponsibilitysimulateClickWith: buttons  | noButtons |  noButtons := 0.  {(#mouseDown -> buttons) .   (#mouseUp -> noButtons)} do: [:type |  self activeHand handleEvent: (MouseButtonEvent new setType: type key position: (self pointInWorld: self center) which: (noButtons bitXor: buttons) buttons: type value hand: self activeHand stamp: Time millisecondClockValue) ]contentMorph  ^contentMorphselectionModeStrategy  ^selectionModeStrategyasPotentialDropTarget  isPotentialDropTarget := true.  self container invalidRect: self visibleBoundscrAction: aMessageSend  ^self setProperty: #crAction toValue: aMessageSendexistingPaneColor  | aColor |  aColor := self valueOfProperty: #paneColor.  aColor ifNil: [ self setProperty: #paneColor toValue: (aColor := self paneColor) ].  ^aColorembeddable  ^embeddable ifNil: [ embeddable := false ]onImage  | m form |  m := CheckboxButtonMorph new     privateOwner: self owner;     adoptPaneColor: self paneColor;     selected: true.  form := Form extent: m extent depth: 32.  form fillColor: (Color white alpha: 0.003922).  form getCanvas fullDrawMorph: m.  ^formduplicate  | newMorph topRend |  (topRend := self topRendererOrSelf) ~~ self ifTrue: [ ^topRend duplicate ].  newMorph := self veryDeepCopy.  newMorph arrangeToStartStepping.  newMorph privateOwner: nil.  ^newMorphprivateColor: aColor  color := aColorisSelected: aBoolean  isSelected := aBoolean.  self changedaddPaneHSplitterBetween: topMorphs and: bottomMorphs  | targetY fixed rightFraction leftFrame rightFrame sorted morph topGroup bottomGroup splitter offset |  topMorphs ifEmpty: [ ^self ].  targetY := topMorphs first layoutFrame bottomFraction.  fixed := topMorphs select: [:m |  m layoutFrame topFraction = m layoutFrame bottomFraction ].  sorted := ((topMorphs reject: [:m |  m layoutFrame topFraction = m layoutFrame bottomFraction ]) asSortedCollection: [:a :b |  a layoutFrame rightFraction = b layoutFrame rightFraction ifTrue: [ a layoutFrame leftFraction <= b layoutFrame leftFraction ] ifFalse: [ a layoutFrame rightFraction <= b layoutFrame rightFraction ] ]) readStream.  sorted contents ifEmpty: [ ^fixed ].  topGroup := OrderedCollection new.  rightFraction := sorted contents first layoutFrame leftFraction.  [ sorted atEnd or: [ morph := sorted next.        morph layoutFrame leftFraction ~= rightFraction and: [ morph layoutFrame rightFraction ~= rightFraction ] ] ] whileFalse: [ topGroup add: morph.        rightFraction := morph layoutFrame rightFraction ].  leftFrame := topGroup first layoutFrame.  rightFrame := topGroup last layoutFrame.  bottomGroup := (bottomMorphs reject: [:m |  m layoutFrame topFraction = m layoutFrame bottomFraction ]) select: [:m |  (m layoutFrame leftFraction between: leftFrame leftFraction and: rightFrame rightFraction) or: [ m layoutFrame rightFraction between: leftFrame leftFraction and: rightFrame rightFraction ] ].  offset := (topGroup collect: [:m |  m layoutFrame bottomOffset ]) max.  splitter := ProportionalSplitterMorph new beSplitsTopAndBottom.  splitter layoutFrame: ((leftFrame leftFraction @ targetY corner: rightFrame rightFraction @ targetY) asLayoutFrame           leftOffset: leftFrame leftOffset;           topOffset: offset;           rightOffset: rightFrame rightOffset;           bottomOffset: 4 + offset).  topGroup := topGroup , fixed.  topGroup do: [:m |  splitter addLeftOrTop: m ].  bottomGroup do: [:m |  splitter addRightOrBottom: m ].  self addMorphBack: splitter.  ^topGroupforceDamageToScreen: allDamage  asFlexOf: aMorph  | pos |  pos := aMorph position.  self addMorph: aMorph.  aMorph position: (aMorph extent // 2) negated.  self position: pos.  transform := transform withOffset: aMorph position - posimage: anImage  image := anImage depth = 1 ifTrue: [ ColorForm mappingWhiteToTransparentFrom: anImage ] ifFalse: [ anImage ].  self extent: 2 * self borderWidth + image extent min asPoint.  self changedimageForm: depth backgroundColor: aColor forRectangle: rect  | canvas |  canvas := Display defaultCanvasClass extent: rect extent depth: depth.  canvas translateBy: rect topLeft negated during: [:tempCanvas |  tempCanvas fillRectangle: rect color: aColor.        tempCanvas fullDrawMorph: self ].  ^canvas form offset: rect topLeftpasteBuffer: aMorphOrNil  PasteBuffer := aMorphOrNildrawOnAthensCanvas: anAthensCanvas  anAthensCanvas setPaint: (InfiniteForm with: self hatchForm).  anAthensCanvas drawShape: self innerBounds.  super drawOnAthensCanvas: anAthensCanvaslabelGraphic: anObject  minimumWidth  ^3selectedMouseOverBorderStyle  ^self theme taskbarItemSelectedMouseOverBorderStyleFor: selfselectedColor: aColor  self hue: aColor hue / 360.  self svMorph selectedColor: aColornewExpander: aString  ^self theme newExpanderIn: self label: aString forAll: #()athensDrawBackgroundForSelectedRow: row on: aCanvas  aCanvas setPaint: listSource selectionColorToUse.  aCanvas drawShape: (self selectionFrameForRow: row)chooseForSaveFileReference: title extensions: exts path: path preview: preview  ^self theme chooseForSaveFileReferenceIn: self title: title extensions: exts path: path preview: previewdisplayExtraSelectionOn: aCanvas  | visibleRectangle line |  visibleRectangle := aCanvas clipRect.  refreshExtraSelection = true ifTrue: [ self buildSelectionBlocksFrom: visibleRectangle topLeft to: visibleRectangle bottomRight.        refreshExtraSelection := false ].  extraSelectionBlocks ifNotNil: [ (self lineIndexForPoint: visibleRectangle topLeft) to: (self lineIndexForPoint: visibleRectangle bottomRight) do: [:i |  line := lines at: i.              extraSelectionBlocks do: [:selblock |  self displaySelectionBlock: selblock inLine: line on: aCanvas ] ] ]isLabelled  ^falsebuttonClickedForTaskList: aTasklist  aTasklist taskClicked: selfadjustedCenter  ^(self vertices last: 4) average roundedinitialize  super initialize.  self disableSortsecondSelection: anItem  | nodeMorph |  nodeMorph := self allNodeMorphs detect: [:e |  e complexContents item == anItem ].  self searchedElement: nodeMorph.  client changedhandleInteraction: interactionBlock  | oldEditor oldParagraph oldText |  oldEditor := self editor.  oldParagraph := paragraph.  oldText := oldParagraph text copy.  self selectionChanged.  interactionBlock value.  oldParagraph == paragraph ifTrue: [ editor := oldEditor ].  self selectionChanged.  (oldText = paragraph text and: [ oldText runs = paragraph text runs ]) ifFalse: [ self updateFromParagraph ]isMainWorld  ^World == selfapply: delta  | oldBounds |  oldBounds := target bounds.  target bounds: (oldBounds origin + delta corner: oldBounds corner)contentsMenuTitle  ^'Contents' translatedtopInactiveGap  ^5addActionsFor: aTab  | rightOffset |  aTab ifNil: [ ^self ].  rightOffset := self actionOffset.  aTab hasMenu ifTrue: [ rightOffset := 2 * rightOffset + self menuButtonWidth.        self addMenuButton ].  aTab actions reverseDo: [:each |  | topOffset |        topOffset := (self height - each icon height) // 2.        self addMorph: (self createActionButtonFor: each) fullFrame: (LayoutFrame identity                 bottomFraction: 0;                 leftFraction: 1;                 topOffset: topOffset;                 bottomOffset: topOffset + each icon height;                 rightOffset: rightOffset negated;                 leftOffset: rightOffset negated - each icon width).        rightOffset := rightOffset + each icon width + self actionOffset ]selectedNodes  ^OrderedCollection withAll: self selectedNodeListlineColor: aColor  lineColorBlock := [:node |  aColor ]newMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector help: helpText  ^self newMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: nil help: helpTextvScrollbarNeeded  self vScrollbar showsAlways ifTrue: [ ^true ].  self vScrollbar showsNever ifTrue: [ ^false ].  ^self scrollTarget height + (self scrollTarget width > self innerBounds width ifTrue: [ self scrollBarThickness ] ifFalse: [ 0 ]) > self innerBounds heightaddInitialPanel  self addMainPanelmultiSelection: aBoolean  self listManager multipleSelection: aBooleandefaultCharacterBlock  ^(CharacterBlock new stringIndex: firstCharacterIndex text: text topLeft: lines first topLeft extent: 0 @ 0) textLine: lines firstsentTo: anObject  ^anObject handleDropMorph: selfdefaultBorderWidth  ^1frameRectangle7: aRectangle on: aCanvas  | r |  r := aRectangle insetBy: self width // 2.  self width odd ifTrue: [ r := r insetBy: (0 @ 0 corner: 1 @ 1) ].  aCanvas     line: r topLeft + (7 @ 0) to: r topRight - (7 @ 0) width: self width color: self color;     line: r topRight + (-6 @ 1) to: r topRight + (-5 @ 1) width: self width color: self color;     line: r topRight + (-4 @ 2) to: r topRight + (-2 @ 4) width: self width color: self color;     line: r topRight + (-1 @ 5) to: r topRight + (-1 @ 6) width: self width color: self color;     line: r topRight + (0 @ 7) to: r bottomRight - (0 @ 7) width: self width color: self color;     line: r bottomRight - (1 @ 6) to: r bottomRight - (1 @ 5) width: self width color: self color;     line: r bottomRight - (2 @ 4) to: r bottomRight - (4 @ 2) width: self width color: self color;     line: r bottomRight - (5 @ 1) to: r bottomRight - (6 @ 1) width: self width color: self color;     line: r bottomRight - (7 @ 0) to: r bottomLeft + (7 @ 0) width: self width color: self color;     line: r bottomLeft - (-6 @ 1) to: r bottomLeft - (-5 @ 1) width: self width color: self color;     line: r bottomLeft - (-4 @ 2) to: r bottomLeft - (-2 @ 4) width: self width color: self color;     line: r bottomLeft - (-1 @ 5) to: r bottomLeft - (-1 @ 6) width: self width color: self color;     line: r bottomLeft - (0 @ 7) to: r topLeft + (0 @ 7) width: self width color: self color;     line: r topLeft + (1 @ 6) to: r topLeft + (1 @ 5) width: self width color: self color;     line: r topLeft + (2 @ 4) to: r topLeft + (4 @ 2) width: self width color: self color;     line: r topLeft + (5 @ 1) to: r topLeft + (6 @ 1) width: self width color: self colornormalFillStyle  ^self theme taskbarItemNormalFillStyleFor: selfmouseLeave: evt  super mouseLeave: evt.  self over: falsetestSortDataSource  | dataSource |  dataSource := self dataSourceForTesting.  strategy property: #yourself.  self assert: dataSource elements equals: self elementsForTestDataSource.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(10 9 8 7 6 5 4 3 2 1).  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: self elementsForTestDataSourcekeyStrokeModifierAction: event  | args character |  character := event keyCharacter.  args := self keystrokeActionSelector numArgs.  args = 1 ifTrue: [ ^self model perform: self keystrokeActionSelector with: character ].  args = 2 ifTrue: [ ^self model perform: self keystrokeActionSelector with: character with: self ].  ^self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'cellColumn: column row: rowIndex  ^FTCellMorph new     addMorphBack: (self elementAt: rowIndex) asMorph;     yourselfhandleMouseMove: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (anEvent isDraggingEvent or: [ anEvent anyButtonPressed and: [ anEvent hand mouseFocus == self ] ]) ifFalse: [ ^self ].  anEvent wasHandled: true.  self mouseMove: anEvent.  (self handlesMouseStillDown: anEvent) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue + self mouseStillDownThreshold arguments: {anEvent copy resetHandlerFields} stepTime: self mouseStillDownStepRate ]setModal: aSystemWindow  | area mySysWin keyboardFocus |  keyboardFocus := self activeHand keyboardFocus.  mySysWin := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  mySysWin ifNil: [ mySysWin := self ].  mySysWin modalLockTo: aSystemWindow.  area := RealEstateAgent maximumUsableArea.  aSystemWindow extent: aSystemWindow initialExtent.  aSystemWindow position = (0 @ 0) ifTrue: [ aSystemWindow position: self activeHand position - (aSystemWindow extent // 2) ].  aSystemWindow bounds: (aSystemWindow bounds translatedToBeWithin: area).  [ | aWidget |  aWidget := aSystemWindow.  [ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] ensure: [ mySysWin modalUnlockFrom: aSystemWindow.        self activeHand newKeyboardFocus: keyboardFocus ].  ^aSystemWindowtaskbarThumbnailExtent  ^self extent min: self defaultTaskbarThumbnailExtentgetMenu: shiftKeyState  | menu aMenu aTitle |  self getMenuSelector == nil ifTrue: [ ^nil ].  menu := UIManager default newMenuIn: self for: self model.  aTitle := getMenuTitleSelector ifNotNil: [ self model perform: getMenuTitleSelector ].  self getMenuSelector numArgs = 1 ifTrue: [ aMenu := self model perform: self getMenuSelector with: menu.        aTitle ifNotNil: [ aMenu addTitle: aTitle ].        ^aMenu ].  self getMenuSelector numArgs = 2 ifTrue: [ aMenu := self model perform: self getMenuSelector with: menu with: shiftKeyState.        aTitle ifNotNil: [ aMenu addTitle: aTitle ].        ^aMenu ].  ^self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'openInWindow  ^self openInWindowLabeled: self defaultLabelcolor: aColor  color := aColorcontents: aString withMarkers: aBool inverse: inverse  | markerIndex marker |  self contentString: nil.  aBool ifFalse: [ ^super contents: aString ].  self removeAllMorphs.  self hasIcon ifTrue: [ self icon: nil ].  self flag: #pharoFixMe.  (aString isKindOf: Association) ifTrue: [ super contents: aString value.        marker := aString key ifTrue: [ self onImage ] ifFalse: [ self offImage ] ] ifFalse: [ (aString notEmpty and: [ aString first = $< ]) ifFalse: [ ^super contents: aString ].        markerIndex := aString indexOf: $>.        markerIndex = 0 ifTrue: [ ^super contents: aString ].        marker := (aString copyFrom: 1 to: markerIndex) asLowercase.        (#('<on>' '<off>' '<yes>' '<no>') includes: marker) ifFalse: [ ^super contents: aString ].        self contentString: aString.        marker := (marker = '<on>' or: [ marker = '<yes>' ]) ~= inverse ifTrue: [ self onImage ] ifFalse: [ self offImage ].        super contents: (aString copyFrom: markerIndex + 1 to: aString size) ].  marker := ImageMorph new form: marker.  marker position: self left @ (self top + 2).  self addMorphFront: markerborderStyleToUse  ^self enabled ifTrue: [ self theme listNormalBorderStyleFor: self ] ifFalse: [ self theme listDisabledBorderStyleFor: self ]scrollDelta  ^scrollDeltadrawOnAthensCanvas: aCanvas  | keyParts text paragraph keyBounds keyFont |  keyParts := (self keyText substrings: '+') collect: #trimBoth.  ((keyParts includes: 'Shift') and: [ (keyParts first = 'Shift') not ]) ifTrue: [ keyParts := (keyParts copyWithout: 'Shift') copyWithFirst: 'Shift' ].  keyFont := self class symbolFont.  text := keyParts inject: Text new into: [:s :each |  s , (self class symbolTableAt: each ifAbsent: [ each capitalized ]) ].  keyBounds := self boundsForKeyText: text string font: keyFont.  paragraph := Paragraph new     compose: text style: (TextStyle fontArray: {keyFont}) from: 1 in: (0 @ 0 corner: keyBounds corner);     yourself.  aCanvas asCanvasWrapper paragraph: paragraph bounds: keyBounds color: self colorupdate: aSymbol  super update: aSymbol.  aSymbol == self getEnabledSelector ifTrue: [ self updateEnabled.        ^self ]mouseLeave: evt  self setProperty: #mouseEntered toValue: false.  self changed.  self color: (self color adjustBrightness: 0.09375).  super mouseLeave: evtmenuBox  ^menuBoxremoveFromSelection  self triggerEvent: #tabRemovedFromSelection with: selfisMove  ^trueextent: newExtent  super extent: newExtent.  self listMorph width: (self width max: listMorph hUnadjustedScrollRange) + 20isRowIndexVisible: rowIndex  self deprecated: 'Use #isIndexVisible: instead' transformWith: '`@receiver isRowIndexVisible: `@statements1' -> '`@receiver isIndexVisible: `@statements1'.  ^self isIndexVisible: rowIndexlistOfSteppingMorphs  ^worldState listOfSteppingMorphsoverlap  ^8 * self displayScaleFactornumberOfItemsPotentiallyInView  ^self numberOfItemsPotentiallyInViewWith: self submorphCountinactiveFillStyle  ^self theme dialogWindowInactiveFillStyleFor: selfleftOffset  ^leftOffsetdrawOnAthensCanvas: aCanvas bounds: aRectangle  navigationKey: event  event isUserInterrupt ifTrue: [ ^true ].  (event keyCharacter = Character escape and: [ event anyModifierKeyPressed ]) ifTrue: [ ^self yellowButtonActivity: false ].  self window ifNotNil: [:win |  (win handlesKeyStroke: event) ifTrue: [ (win keyStroke: event) ifTrue: [ ^true ] ] ].  ^falsevalidateSelector: aSymbol  (aSymbol numArgs between: 0 and: 2) ifFalse: [ ^self error: 'Invalid pluggable selector' ]firstInChain  | first |  first := self.  [ first predecessor isNil ] whileFalse: [ first := first predecessor ].  ^firstpressed: anIndex  self owner pressed: anIndexmultiSelection: aBoolean  multiSelection := aBooleanheaderButtonLabel: aLabel font: aFont icon: anIconForm target: aReceiver actionSelector: aSelector arguments: aCollection  self headerButton.  self header label: aLabel font: aFont.  self header icon: (ImageMorph new form: anIconForm).  self header actionSelector: aSelector.  self header target: aReceiver.  self header arguments: aCollectionnewColor  ^newColortestIsAboveRow  self subclassResponsibilityadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self color: (self preferedPaneColor ifNil: [ self theme backgroundColor ])adjustBorderUponActivationWhenLabeless  | aWidth |  (aWidth := self valueOfProperty: #borderWidthWhenActive) ifNotNil: [ self acquireBorderWidth: aWidth ]borderWidthForRounding  ^self borderWidthtransformedBy: aMorphicTransform  ^self shallowCopy transformBy: aMorphicTransformhandlesKeyboard: event  ^truelastSubmorphRecursive  ^self hasSubmorphs ifTrue: [ self lastSubmorph lastSubmorphRecursive ] ifFalse: [ self ]isWindowActive: aSystemWindow  ^self currentWindow == aSystemWindowselectLastMatch: aString  | lastMatch |  self items reverseDo: [:item |  | match |        match := aString isEmpty or: [ item contents asString asLowercase includesSubstring: aString ].        item isEnabled: match.        (match and: [ lastMatch isNil ]) ifTrue: [ lastMatch := item ] ].  ^lastMatchgetListSize  getListSizeSelector ifNotNil: [ ^model perform: getListSizeSelector ].  ^self getList sizemorphicLayerNumber  ^1basicDrawOn: aCanvas  | stringColor stringBounds |  stringColor := self stringColorToUse.  stringBounds := self stringBoundsToUse.  (self isSelected and: [ self isEnabled ]) ifTrue: [ aCanvas fillRectangle: self bounds fillStyle: self selectionFillStyle borderStyle: self selectionBorderStyle ].  self hasIcon ifTrue: [ | iconForm |        iconForm := self icon.        self drawIcon: iconForm on: aCanvas in: stringBounds.        stringBounds := stringBounds left: stringBounds left + iconForm width + (2 * self displayScaleFactor) ].  self hasMarker ifTrue: [ stringBounds := stringBounds left: stringBounds left + self submorphBounds width + (8 * self displayScaleFactor) ].  stringBounds := stringBounds top: (stringBounds top + stringBounds bottom - self fontToUse height) // 2.  stringBounds := stringBounds bottom: stringBounds top + self fontToUse height.  self drawText: contents on: aCanvas in: stringBounds.  self hasSubMenu ifTrue: [ | subMenuMarker |        subMenuMarker := self subMenuMarker deepCopy mapColor: Color black to: stringColor.        self drawSubMenuMarker: subMenuMarker on: aCanvas in: stringBounds ]repelsMorph: aMorph event: ev  ^falsehandleInteraction: interActionBlock  self editor model: editView model.  ^super handleInteraction: interActionBlockaddTableLayoutMenuItems: aMenu hand: aHand  | menu sub |  menu := UIManager default newMenuIn: self for: self.  menu addUpdating: #hasReverseCellsString selector: #changeReverseCells.  menu addUpdating: #hasClipLayoutCellsString selector: #changeClipLayoutCells.  menu addUpdating: #hasRubberBandCellsString selector: #changeRubberBandCells.  menu addLine.  menu add: 'change cell inset...' selector: #changeCellInset:.  menu add: 'change min cell size...' selector: #changeMinCellSize:.  menu add: 'change max cell size...' selector: #changeMaxCellSize:.  menu addLine.  sub := UIManager default newMenuIn: self for: self.  #(#leftToRight #rightToLeft #topToBottom #bottomToTop) do: [:sym |  sub addUpdating: #listDirectionString: target: self selector: #changeListDirection: argumentList: (Array with: sym) ].  menu add: 'list direction' subMenu: sub.  sub := UIManager default newMenuIn: self for: self.  #(#none #leftToRight #rightToLeft #topToBottom #bottomToTop) do: [:sym |  sub addUpdating: #wrapDirectionString: target: self selector: #wrapDirection: argumentList: (Array with: sym) ].  menu add: 'wrap direction' subMenu: sub.  sub := UIManager default newMenuIn: self for: self.  #(#center #topLeft #topRight #bottomLeft #bottomRight #topCenter #leftCenter #rightCenter #bottomCenter) do: [:sym |  sub addUpdating: #cellPositioningString: target: self selector: #cellPositioning: argumentList: (Array with: sym) ].  menu add: 'cell positioning' subMenu: sub.  sub := UIManager default newMenuIn: self for: self.  #(#topLeft #bottomRight #center #justified) do: [:sym |  sub addUpdating: #listCenteringString: target: self selector: #listCentering: argumentList: (Array with: sym) ].  menu add: 'list centering' subMenu: sub.  sub := UIManager default newMenuIn: self for: self.  #(#topLeft #bottomRight #center #justified) do: [:sym |  sub addUpdating: #wrapCenteringString: target: self selector: #wrapCentering: argumentList: (Array with: sym) ].  menu add: 'wrap centering' subMenu: sub.  sub := UIManager default newMenuIn: self for: self.  #(#none #equal) do: [:sym |  sub addUpdating: #listSpacingString: target: self selector: #listSpacing: argumentList: (Array with: sym) ].  menu add: 'list spacing' subMenu: sub.  sub := UIManager default newMenuIn: self for: self.  #(#none #localRect #localSquare #globalRect #globalSquare) do: [:sym |  sub addUpdating: #cellSpacingString: target: self selector: #cellSpacing: argumentList: (Array with: sym) ].  menu add: 'cell spacing' subMenu: sub.  aMenu ifNotNil: [ aMenu add: 'table layout' subMenu: menu ].  ^menuseparatorSize  ^separatorSize ifNil: [ separatorSize := 1 ]lineColor: aColor  self borderColor: aColorhandlesMouseOverDragging: evt  ^truenewColorChooserFor: aModel getColor: getSel setColor: setSel help: helpText  ^self theme newColorChooserIn: self for: aModel getColor: getSel setColor: setSel getEnabled: nil help: helpTextcenter  ^bounds centerdecrement  self value: self value - 1viewBox  ^Display boundingBoxbottomRight: aPoint  self position: (aPoint x - bounds width) @ (aPoint y - self height)initializeFrom: defaultProvider  self hResizing: defaultProvider hResizing.  self vResizing: defaultProvider vResizing.  self disableTableLayout: defaultProvider disableTableLayoutvisibleRowMorphAtIndex: index  ^container visibleRowMorphAtIndex: indexnewMainPanel  ^self newDialogPanel     addMorphBack: self newContentMorph;     addMorphBack: self newButtonRow;     yourselfdisplay: items atRow: row on: canvas  | drawBounds backgroundColor |  backgroundColor := self backgroundColorForRow: row.  drawBounds := self drawBoundsForRow: row.  drawBounds := drawBounds intersect: self bounds ifNone: [ ^self ].  items with: (1 to: items size) do: [:item :index |  index > 1 ifTrue: [ drawBounds := drawBounds left: drawBounds left + listSource gapSize + (columnWidths at: index - 1) ].        item listRenderOn: canvas atRow: row bounds: drawBounds color: color backgroundColor: backgroundColor from: self ]drawOn: aCanvas  | dotBounds alphaCanvas windowBorderWidth dotBounds2 |  self shouldDraw ifFalse: [ ^self ].  windowBorderWidth := SystemWindow borderWidth.  alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.  dotBounds := self bounds.  dotBounds2 := dotBounds right: dotBounds left + windowBorderWidth.  dotBounds2 := dotBounds2 bottom: dotBounds2 top + windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds left: dotBounds left + windowBorderWidth.  dotBounds2 := dotBounds2 bottom: dotBounds2 top + windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds2 left: dotBounds2 left + 7.  dotBounds2 := dotBounds2 right: dotBounds2 right - 7.  alphaCanvas fillRectangle: dotBounds2 color: self dotColor.  dotBounds2 := dotBounds right: dotBounds left + windowBorderWidth.  dotBounds2 := dotBounds2 top: dotBounds2 top + windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds2 top: dotBounds2 top + 7.  dotBounds2 := dotBounds2 bottom: dotBounds2 bottom - 7.  alphaCanvas fillRectangle: dotBounds2 color: self dotColorselectedFillStyle  ^self theme taskbarItemSelectedFillStyleFor: selfbuildPanel  self subclassResponsibilitymouseMove: evt  self isMultipleSelection ifTrue: [ self mouseMoveOnMultiple: evt ] ifFalse: [ self mouseMoveOnSingle: evt ]displayOn: aCanvas using: displayScanner at: somePosition  | visibleRectangle offset leftInRun line |  visibleRectangle := aCanvas clipRect.  offset := (somePosition - positionWhenComposed) truncated.  leftInRun := 0.  (self lineIndexForPoint: visibleRectangle topLeft) to: (self lineIndexForPoint: visibleRectangle bottomRight) do: [:i |  line := lines at: i.        self displaySelectionInLine: line on: aCanvas.        line first <= line last ifTrue: [ leftInRun := displayScanner displayLine: line offset: offset leftInRun: leftInRun ] ]isCheckList  ^isCheckList ifNil: [ isCheckList := false ]drawLineToggleToTextOn: aCanvas lineColor: lineColor hasToggle: hasToggle  | myBounds myCenter hLineY hLineLeft myTheme |  self isSoleItem ifTrue: [ ^self ].  self hasToggle ifTrue: [ ^self ].  myBounds := self toggleBounds.  myCenter := myBounds center.  hLineY := myCenter y - 1.  hLineLeft := myCenter x.  myTheme := self theme.  aCanvas frameRectangle: (hLineLeft @ hLineY corner: (myBounds right + 3) @ (hLineY + 1)) width: myTheme treeLineWidth colors: (myTheme treeLineColorsFrom: lineColor) dashes: myTheme treeLineDashessetDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedposition: aSymbol  (self positions includes: aSymbol) ifFalse: [ self error ].  position := aSymbolrestoreBeforeGeneratingThumbnail  self isMinimized ifFalse: [ ^self ].  isCollapsed := false.  self show.  self setBoundsWithFlex: fullFrame.  paneMorphs reverseDo: [:m |  self addMorph: m ].  self layoutChangedkeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self focusChangedsetValueSelector  ^setValueSelectorselectedNodePath  ^self selection ifNotNil: [:s |  s lastSelectedNodePath ]chooseColor  ^self chooseColor: Color blackprintOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     print: receiver;     space;     print: selector;     space;     print: scheduledTime;     nextPut: $)testMorphInline  | text morphTextAttribute |  text := 'Hello ' asText , Morph new asText , ' world' asText.  morphTextAttribute := text attributesAt: 7.  self assert: (morphTextAttribute first isKindOf: TextAnchor)dropEnabled  ^(self valueOfProperty: #dropEnabled) ~~ falseparagraph  ^super paragraph     selectionColor: self selectionColor;     yourselfmouseEnter: evt  owner ifNotNil: [ owner stayUp ifFalse: [ self mouseEnterDragging: evt ] ].  (owner selectedItem notNil and: [ owner selectedItem ~~ self ]) ifTrue: [ owner selectItem: self event: evt ]rotationDegrees: degrees  minHeight  ^owner isVertical ifTrue: [ self theme menuBorderWidth ] ifFalse: [ 10 ]updateColumnMorphsWidthWith: aListOfWidths  | sw |  (container columns isEmpty or: [ self hasSubmorphs not ]) ifTrue: [ ^self ].  sw := self spacerWidth.  1 to: aListOfWidths size - 1 do: [:idx |  | w |        w := aListOfWidths at: idx.        (controls at: idx) width: w - (idx = 1 ifTrue: [ sw ] ifFalse: [ 0 ]) ]mouseMove: evt  self isFullscreen ifTrue: [ ^self ].  ^super mouseMove: evtenabledFromModel  | val |  self model ifNil: [ ^self ].  val := self model enabled.  val ~= self enabled ifTrue: [ self enabled: val ]wantsSteps  super wantsSteps ifTrue: [ ^true ].  ^self isAnimatednewDialogPanel  ^self theme newDialogPanelIn: selfselectableIndexAbove: anIndex  ^{(anIndex first - 1) .   anIndex second}forceDamageToScreen: allDamage  ^Display forceDamageToScreen: allDamagefillStyle: fillStyle  fillStyle isColor ifTrue: [ self color: fillStyle ] ifFalse: [ super fillStyle: fillStyle ]release  traceMorph := nil.  oldColor := nil.  container := nil.  self releaseActionMap.  super releasecellMorphFor: aDataSource  | morph |  morph := FTIndentedCellMorph new.  morph depthIndent: depth.  self hasChildren ifTrue: [ morph addMorphBack: self generateButton ] ifFalse: [ morph addIndendtation: 15 ].  dataSource displayBlock value: item value: morph.  ^morphvertices: verts color: aColor borderWidth: borderWidthInteger borderColor: anotherColor  super initialize.  vertices := verts.  color := aColor.  borderWidth := borderWidthInteger.  borderColor := anotherColor.  closed := vertices size > 2.  arrows := #none.  self computeBoundscopyToPasteBuffer: evt  ^evt hand copyToPasteBuffer: selfextraBorder  ^6setOptimalResizingStrategyAndReturnOldOne  | tmpHResizing tmpVResizing tmpSubmorphResizing |  tmpHResizing := self hResizing.  tmpVResizing := self vResizing.  self setOptimalResizing.  tmpSubmorphResizing := self submorphs collect: [:aMorph |  aMorph setOptimalResizingStrategyAndReturnOldOne ].  ^{tmpHResizing .   tmpVResizing .   tmpSubmorphResizing}tabSelectorMorph: anObject  tabSelectorMorph := anObjectadhereToRight  self adhereTo: #rightsliderColor: newColor  super sliderColor: newColor.  slider ifNotNil: [ slider borderStyle baseColor: newColor ]getListItem: index  | element |  getListElementSelector ifNotNil: [ ^self wrapItem: (model perform: getListElementSelector with: index) index: index ].  list ifNotNil: [ ^list at: index ].  element := self getList at: index.  ^self wrapItem: element index: indexresult: aResult from: aResultGenerator  toggleExpandedState: aMorph  aMorph toggleExpandedState.  self adjustSubmorphPositionsactive  active ifNil: [ active := false ].  ^activemaybeDismiss: evt with: dismissHandle  | confirmed |  evt hand obtainHalo: self.  (dismissHandle containsPoint: evt cursorPoint) ifTrue: [ target resistsRemoval ifTrue: [ confirmed := self confirm: 'Really throw this away?' translated.              confirmed ifFalse: [ ^self ] ].        evt hand removeHalo.        self delete.        target dismissViaHalo ] ifFalse: [ self delete.        target addHalo: evt ]multiComposeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks  wantsColumnBreaks := argWantsColumnBreaks.  lines := argLinesCollection.  theTextStyle := argTextStyle.  theText := argText.  theContainer := argContainer.  deltaCharIndex := argDelta.  currCharIndex := startCharIndex := argStart.  stopCharIndex := argStop.  prevLines := argPriorLines.  currentY := argStartY.  defaultLineHeight := theTextStyle lineGrid.  maxRightX := theContainer left.  possibleSlide := stopCharIndex < theText size and: [ theContainer isMemberOf: Rectangle ].  nowSliding := false.  prevIndex := 1.  scanner := CompositionScanner new text: theText textStyle: theTextStyle.  scanner wantsColumnBreaks: wantsColumnBreaks.  isFirstLine := true.  self composeAllLines.  isFirstLine ifTrue: [ self addNullLineWithIndex: startCharIndex andRectangle: (theContainer topLeft extent: 0 @ defaultLineHeight) ] ifFalse: [ self fixupLastLineIfCR ].  ^{lines asArray .   maxRightX}testIsSortEnabled  column disableSort.  self deny: column isSortEnabled.  column sortableOnProperty: #name.  self assert: column isSortEnabledspotterForSubmorphsFor: aStep  < spotterOrder: 10>  self submorphs ifNil: [ ^self ].  aStep listProcessor     title: 'Submorphs';     allCandidates: [ self submorphs ];     candidatesLimit: 5;     filter: GTFilterSubstringaboutToBeGrabbedBy: aHand  | menu box |  (owner notNil and: [ owner hasSubmorphs ]) ifTrue: [ owner stayUp: true.        ^owner aboutToBeGrabbedBy: aHand ].  box := self bounds.  menu := UIManager default newMenuIn: self for: nil.  menu addMorphFront: self.  menu bounds: box.  menu stayUp: true.  self isSelected: false.  ^menumarried  ^self item marriedshedSelvedge  self extent: self extent - (6 @ 6)copyToPasteBuffer: aMorph  aMorph ifNil: [ ^PasteBuffer := nil ].  Cursor wait showWhile: [ PasteBuffer := aMorph topRendererOrSelf veryDeepCopy.        PasteBuffer privateOwner: nil ]isComposite  ^falsestate  ^statequestion: aStringOrText title: aString  ^self theme questionIn: self text: aStringOrText title: aStringchanged: anAspect with: anObject  self doAnnounce: (MorphChangedWithArguments new           morph: self;           selector: anAspect;           arguments: anObject)click: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #click from: sourceMorphtestExecuteSortingOn  self subclassResponsibilitynewListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector help: helpText  ^self newListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: nil help: helpTextnewControls  ^{self newLeftButton .   self newRightButton}onChoiceSend: aSymbol to: anObject  self announcer when: ChoseDate send: aSymbol to: anObjectchooseForSaveFileReference: title extensions: exts path: path  ^self chooseForSaveFileReference: title extensions: exts path: path preview: nilnewString: aStringOrText font: aFont style: aStyle  ^self theme newStringIn: self label: aStringOrText font: aFont style: aStylebrowseItem  Smalltalk tools browser openOnClass: self iteminteractionState: aSymbol  self submorphsDo: [:m |  (m respondsTo: #interactionState:) ifTrue: [ m interactionState: aSymbol ] ]getStateSelector  ^getStateSelectorlocalVisibleSubmorphBounds  | subBounds |  subBounds := nil.  self submorphsDo: [:m |  m visible ifTrue: [ subBounds ifNil: [ subBounds := m fullBounds copy ] ifNotNil: [ subBounds := subBounds quickMerge: m fullBounds ] ] ].  ^subBoundsindexOfChangedItem  1 to: self numberOfRows do: [:index |  (self elementAt: index) recentlyChanged ifTrue: [ ^index ] ].  ^self errorSubscriptBounds: self numberOfRows + 1wantsDropSelector: aSymbol  wantsDropSelector := aSymbolprintOn: aStream  super printOn: aStream.  aStream     nextPutAll: ' (';     print: addHandleSelector;     space;     print: iconSymbol;     nextPut: $)newCancelButton  ^self newCancelButtonFor: selfasShortcut  ^self asKeyCombinationcellColumn: column row: rowIndex  self subclassResponsibilitydeleteCloseBox  closeBox ifNotNil: [ closeBox delete.        closeBox := nil ]angle: newAngle  self changed.  transform := transform withAngle: newAngle.  self layoutChanged.  self changedmouseEnter: a from: b  counter := counter + 1themeChanged  self color: self defaultColor.  super themeChangedhandlesMouseWheel: evt  ^trueaddEmbeddingMenuItemsTo: aMenu hand: aHandMorph  | menu potentialEmbeddingTargets |  potentialEmbeddingTargets := self potentialEmbeddingTargets.  potentialEmbeddingTargets size > 1 ifFalse: [ ^self ].  menu := UIManager default newMenuIn: self for: self.  potentialEmbeddingTargets reverseDo: [:m |  menu add: m class name asString target: m selector: #addMorphFrontFromWorldPosition: argument: self topRendererOrSelf.        menu lastItem icon: (m iconOrThumbnailOfSize: 16).        self owner == m ifTrue: [ menu lastItem emphasis: 1 ] ].  aMenu add: 'embed into' subMenu: menu.  ^menuon: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel wrapSelector: wrapSel  self model: anObject.  self getListSelector: getListSel.  self getIndexSelector: getSelectionSel.  self setIndexSelector: setSelectionSel.  self getMenuSelector: getMenuSel.  self keystrokeActionSelector: keyActionSel.  self basicWrapSelector: wrapSelextent: aPoint  | ext |  ext := self extent.  super extent: aPoint.  self isHorizontal ifTrue: [ self extent y ~= ext y ifTrue: [ self adoptPaneColor: self paneColor ] ] ifFalse: [ self extent x ~= ext x ifTrue: [ self adoptPaneColor: self paneColor ] ]moveBy: delta  left := left + delta x.  right := right + delta x.  top := top + delta y.  bottom := bottom + delta yrubberBandCells  | props |  props := self layoutProperties.  ^props ifNil: [ false ] ifNotNil: [ props rubberBandCells ]defaultWidth  ^100handlesMouseDown: evt  self eventHandler ifNotNil: [ ^self eventHandler handlesMouseDown: evt ].  ^falsemouseMove: evt  scroller hasSubmorphs ifTrue: [ scroller submorphs last mouseMove: (evt transformedBy: (scroller transformFrom: self)) ]focusBounds  ^self boundsminExtent  | layout minExtent extra hFit vFit |  hFit := self hResizing.  vFit := self vResizing.  (hFit == #rigid and: [ vFit == #rigid ]) ifTrue: [ ^self fullBounds extent max: self minWidth @ self minHeight ].  self hasSubmorphs ifFalse: [ hFit == #shrinkWrap ifTrue: [ hFit := #rigid ].        vFit == #shrinkWrap ifTrue: [ vFit := #rigid ] ].  layout := self layoutPolicy.  layout ifNil: [ minExtent := 0 @ 0 ] ifNotNil: [ minExtent := layout minExtentOf: self in: self layoutBounds ].  hFit == #rigid ifTrue: [ minExtent := self fullBounds extent x @ minExtent y ] ifFalse: [ extra := self bounds width - self layoutBounds width.        minExtent := (minExtent x + extra) @ minExtent y ].  minExtent := vFit == #rigid ifTrue: [ minExtent x @ self fullBounds extent y ] ifFalse: [ extra := self bounds height - self layoutBounds height.        minExtent x @ (minExtent y + extra) ].  minExtent := minExtent max: self minWidth @ self minHeight.  ^minExtenticon: aForm  self subclassResponsibilitycancelEdits  self doneWithEditson: anObject color: getColSel changeColor: setColSel  self     on: anObject color: getColSel;     setColorSelector: setColSeladdYellowButtonMenuItemsTo: aMenu event: evt  aMenu defaultTarget: self.  self defaultYellowButtonMenuEnabled ifFalse: [ ^self ].  self addModelYellowButtonItemsTo: aMenu event: evt.  self cmdGesturesEnabled ifTrue: [ aMenu addLine.        aMenu add: 'inspect' selector: #inspect ].  aMenu addLine.  self isWorldMorph ifFalse: [ aMenu add: 'delete' selector: #delete ].  self world selectedObject == self ifTrue: [ aMenu add: 'halo off' selector: #removeHalo ] ifFalse: [ aMenu add: 'halo on' selector: #addHalo ].  (self isWorldMorph or: [ self wantsToBeTopmost ]) ifFalse: [ aMenu addLine.        aMenu add: 'send to back' selector: #goBehind.        aMenu add: 'bring to front' selector: #comeToFront.        self addEmbeddingMenuItemsTo: aMenu hand: evt hand ].  self isWorldMorph ifFalse: [ self isFullOnScreen ifFalse: [ aMenu add: 'move onscreen' selector: #goHome ] ].  self addLayoutMenuItems: aMenu hand: evt hand.  (owner notNil and: [ owner isTextMorph ]) ifTrue: [ self addTextAnchorMenuItems: aMenu hand: evt hand ].  self isWorldMorph ifFalse: [ aMenu addLine.        self addToggleItemsToHaloMenu: aMenu ].  aMenu addLine.  self isWorldMorph ifFalse: [ aMenu add: 'copy to paste buffer' selector: #copyToPasteBuffer: ].  (self allStringsAfter: nil) isEmpty ifFalse: [ aMenu add: 'copy text' selector: #clipText ].  self addExportMenuItems: aMenu hand: evt hand.  aMenu addLine.  aMenu add: 'adhere to edge...' selector: #adhereToEdge.  self addCustomMenuItems: aMenu hand: evt handpreferredKeyboardBounds  ^self bounds: self bounds in: self currentWorlddrawOn: aCanvas offset: origin  | box dayString textColor textTopLeft textWidth today |  dayString := date dayOfMonth printString.  textWidth := owner weekdayFont widthOfString: dayString.  textTopLeft := bounds topCenter translateBy: (textWidth // -2) @ 3.  box := ((textTopLeft extent: textWidth @ owner weekdayFont height) insetBy: -8 @ -1) translateBy: origin.  today := date = Date today.  textColor := date month = owner date month ifTrue: [ Color black ] ifFalse: [ Color veryLightGray ].  (date = owner date or: [ self highlighted ]) ifTrue: [ | lineColor fillColor |        lineColor := today ifTrue: [ Color red ] ifFalse: [ Color veryLightGray ].        fillColor := self highlighted ifTrue: [ Color veryVeryLightGray ] ifFalse: [ Color veryLightGray ].        aCanvas fillOval: box color: fillColor borderWidth: 1 borderColor: lineColor ].  today & (date ~= owner date) & self highlighted not ifTrue: [ aCanvas fillOval: box color: Color white borderWidth: 1 borderColor: Color red ].  aCanvas drawString: dayString at: textTopLeft + origin font: owner weekdayFont color: textColorenableDrop: aBoolean  self setProperty: #dropEnabled toValue: aBooleanmouseEnter: evt  super mouseEnter: evt.  self showOverEditableTextCursorchooseDropList: aStringOrText list: aList  ^self chooseDropList: aStringOrText title: 'Choose' translated list: aListdrawOn: aCanvas  self theme flatMenu ifFalse: [ aCanvas fillRectangle: (bounds topLeft corner: bounds rightCenter) color: self baseColor twiceDarker.        aCanvas fillRectangle: (bounds leftCenter corner: bounds bottomRight) color: self baseColor twiceLighter ] ifTrue: [ aCanvas fillRectangle: (bounds topLeft corner: bounds bottomRight) color: self baseColor ]minHeight  ^self class defaultRowHeight ceilingupdateFromParagraph  | newStyle sel oldLast oldEditor back |  paragraph ifNil: [ ^self ].  wrapFlag ifNil: [ wrapFlag := true ].  editor ifNotNil: [ oldEditor := editor.        sel := editor selectionInterval.        editor storeSelectionInParagraph ].  text := paragraph text.  paragraph textStyle = textStyle ifTrue: [ self fit ] ifFalse: [ newStyle := paragraph textStyle.        (self firstInChain text: text textStyle: newStyle) recomposeChain.        editor ifNotNil: [ self installEditorToReplace: editor ] ].  super layoutChanged.  sel ifNil: [ ^self ].  predecessor ifNotNil: [ sel first <= (self paragraph lines first last + 1) ifTrue: [ oldLast := predecessor lastCharacterIndex.              predecessor paragraph recomposeFrom: oldLast to: text size delta: 0.              oldLast = predecessor lastCharacterIndex ifFalse: [ predecessor changed.                    self predecessorChanged ] ] ].  ((back := predecessor notNil and: [ sel first <= self paragraph firstCharacterIndex ]) or: [ successor notNil and: [ sel first > (self paragraph lastCharacterIndex + 1) ] ]) ifTrue: [ back ifTrue: [ predecessor recomposeChain ] ifFalse: [ self recomposeChain ].        self firstInChain withSuccessorsDo: [:m |  (sel first between: m firstCharacterIndex and: m lastCharacterIndex + 1) ifTrue: [ m installEditorToReplace: oldEditor.                    ^self passKeyboardFocusTo: m ] ].        self error: 'Inconsistency in text editor' ].  editor ifNil: [ self installEditorToReplace: oldEditor ]getValueSelector  ^getValueSelectorusedHeightByPredominantDockingBarsOfChastes: predominantChastes  ^(self predominantDockingBarsOfChastes: predominantChastes) ifEmpty: [ 0 ] ifNotEmpty: [:predominants |  (predominants collect: [:each |  each height ]) sum ]disableTableLayout  | props |  props := self layoutProperties.  ^props ifNil: [ false ] ifNotNil: [ props disableTableLayout ]children  | children |  children := OrderedCollection new.  self childrenDo: [:each |  children add: each ].  ^childrenbackgroundColor  ^backgroundColorexpandedChildren  self isExpanded ifFalse: [ ^{} ].  ^self children flatCollect: #withExpandedChildrenshouldDraw  ^truesetUp  super setUp.  morph := Morph new.  morph eventHandler: MorphicEventHandler newnewAlphaSelector: aModel getAlpha: getSel setAlpha: setSel help: helpText  ^self theme newAlphaSelectorIn: self for: aModel getAlpha: getSel setAlpha: setSel help: helpTextvIsScrollable  ^self vLeftoverScrollRange > 0 and: [ self vTotalScrollRange > (self scrollDeltaHeight * 3 / 2) ]reset  self subclassResponsibilitycolor  ^color ifNil: [ self container columnColors at: self index \\ 2 + 1 ]handleUnknownEvent: anEvent  ^self dispatchDefault: anEvent with: morphhandlesMouseDown: evt  ^truestate  ^stateindexForRow: aRowIndex  ^self subclassResponsibilityscaledValue: newValue  | val |  val := newValue.  self quantum ifNotNil: [:q |  val := val roundTo: q ].  self value: (self max <= self min ifTrue: [ 0 ] ifFalse: [ (val - self min) / (self max - self min) ])lineColor  ^lineColor ifNil: [ lineColor := container lineColorForNode: self complexContents ]yellowButtonEvent: anEvent  (self scrollerSubMorphFromPoint: anEvent position) ifNotNil: [:sel |  sel selected ifFalse: [ self listManager setSelectedMorph: sel ].        ^self yellowButtonActivity: anEvent shiftPressed ].  ^self yellowButtonActivity: anEvent shiftPressedresizeCursor  ^Cursor resizeForEdge: #leftresetListSelector  ^resetListSelectortreeMorph  | treeMorph |  treeMorph := (MorphTreeMorph on: self)     beMultiple;     columns: {(MorphTreeColumn new           startWidth: 300;           rowMorphGetSelector: #classButton;           headerButtonLabel: 'Class' font: nil) .         (MorphTreeColumn new           startWidth: 500;           rowMorphGetSelector: #commentText;           headerButtonLabel: 'Comment' font: nil)};     rowInset: 4;     treeLineWidth: 1;     columnInset: 4;     getMenuSelector: #menu:shifted:;     rowColorForEven: Color lightGray muchLighter.  ^treeMorph buildContentsdrawBackgroundSketchOn: aCanvas  backgroundMorph ifNil: [ ^self ].  self clipSubmorphs ifTrue: [ aCanvas clipBy: self clippingBounds during: [:canvas |  canvas fullDrawMorph: backgroundMorph ] ] ifFalse: [ aCanvas fullDrawMorph: backgroundMorph ]printKeyStringOn: aStream  | kc inBrackets firstBracket keyString |  kc := self keyCharacter.  inBrackets := false.  firstBracket := [ inBrackets ifFalse: [ aStream nextPut: $<.        inBrackets := true ] ].  self controlKeyPressed ifTrue: [ firstBracket value.        aStream nextPutAll: 'Ctrl-' ].  self commandKeyPressed ifTrue: [ firstBracket value.        aStream nextPutAll: 'Cmd-' ].  (buttons anyMask: 32) ifTrue: [ firstBracket value.        aStream nextPutAll: 'Opt-' ].  (self shiftPressed and: [ keyValue between: 1 and: 31 ]) ifTrue: [ firstBracket value.        aStream nextPutAll: 'Shift-' ].  self hasSpecialCTRLKeyValue ifTrue: [ aStream nextPut: (keyValue + $a asciiValue - 1) asCharacter ] ifFalse: [ keyString := kc caseOf: {([ Character space ] -> [ ' ' ]) .               ([ Character tab ] -> [ 'tab' ]) .               ([ Character cr ] -> [ 'cr' ]) .               ([ Character lf ] -> [ 'lf' ]) .               ([ Character enter ] -> [ 'enter' ]) .               ([ Character backspace ] -> [ 'backspace' ]) .               ([ Character delete ] -> [ 'delete' ]) .               ([ Character escape ] -> [ 'escape' ]) .               ([ Character arrowDown ] -> [ 'down' ]) .               ([ Character arrowUp ] -> [ 'up' ]) .               ([ Character arrowLeft ] -> [ 'left' ]) .               ([ Character arrowRight ] -> [ 'right' ]) .               ([ Character end ] -> [ 'end' ]) .               ([ Character home ] -> [ 'home' ]) .               ([ Character pageDown ] -> [ 'pageDown' ]) .               ([ Character pageUp ] -> [ 'pageUp' ]) .               ([ Character euro ] -> [ 'euro' ]) .               ([ Character insert ] -> [ 'insert' ])} otherwise: [ String with: kc ].        keyString size > 1 ifTrue: [ firstBracket value ].        aStream nextPutAll: keyString ].  inBrackets ifTrue: [ aStream nextPut: $> ]addFontEmphHandle: haloSpec  innerTarget isTextMorph ifTrue: [ self addHandle: haloSpec on: #mouseDown send: #chooseEmphasisOrAlignment to: innerTarget ]clipSubmorphs  ^truetestRowIndexFrom  self assert: (strategy rowIndexFrom: 3) equals: 3sliderShadowColor  ^self sliderColor alphaMixed: 0.2 with: self pagingArea colorremoveNode: aNode  self selectedNodePath = aNode path ifTrue: [ self selectedNodePath: nil ]defaultBorderWidth  ^self theme borderWidthsecondNameMorph  ^(self theme newTextEntryIn: self currentWorld for: self get: #secondName set: #secondName: class: String getEnabled: nil help: nil) color: Color transparentchooseFont  ^self chooseFont: nilwrapItem: anItem index: anIndex  ^self wrapSelector ifNil: [ anItem asStringOrText ] ifNotNil: [:selector |  selector numArgs == 0 ifTrue: [ anItem perform: selector ] ifFalse: [ self model perform: selector withEnoughArguments: {anItem .                     anIndex} ] ]scroller: anObject  scroller := anObjectwrapSelector  ^wrapSelectoroldPosition: anObject  oldPosition := anObjecton: eventName send: selector to: recipient withValue: value  self eventHandler ifNil: [ self eventHandler: MorphicEventHandler new ].  self eventHandler on: eventName send: selector to: recipient withValue: valueshiftPressed  ^buttons anyMask: 8selectionColorToUse: aColor  aColor = self selectionColorToUse ifTrue: [ ^self ].  aColor ifNil: [ self removeProperty: #selectionColorToUse ] ifNotNil: [ self setProperty: #selectionColorToUse toValue: aColor ].  self selectionFrameChangedtoggleExpandedState: aMorph event: event  | oldState |  event yellowButtonPressed ifTrue: [ oldState := aMorph isExpanded.        self allNodeMorphs copy do: [:each |  (each canExpand and: [ each isExpanded = oldState ]) ifTrue: [ each toggleExpandedState ] ] ] ifFalse: [ aMorph toggleExpandedState ].  self adjustSubmorphPositionsorganizeIntoRow  ((AlignmentMorph inARow: (selectedItems asSortedCollection: [:x :y |  x left < y left ]))     setNameTo: 'Row';     color: Color orange muchLighter;     enableDragNDrop: true;     yourself) openInHandprepareForScaling  ^selfcolumnResizers  ^columnResizers ifNil: [ columnResizers := OrderedCollection new ]model  ^modelfindNextString: aSubstring startingAt: searchIdx  | where |  self handleEdit: [ where := self editor findNextString: aSubstring startingAt: searchIdx ].  ^whereasString  ^model printNode: selfcolor  ^Color transparentcomputeSlider  | r |  r := self roomToMove.  self descending ifFalse: [ slider position: (bounds isWide ifTrue: [ r topLeft + ((r width * value) asInteger @ 0) ] ifFalse: [ r topLeft + (0 @ (r height * value) asInteger) ]) ] ifTrue: [ slider position: (bounds isWide ifTrue: [ r bottomRight - ((r width * value) asInteger @ 0) ] ifFalse: [ r bottomRight - (0 @ (r height * value) asInteger) ]) ].  slider extent: self sliderExtentshowDebugEvent: evt  ShowEvents == true ifTrue: [ | ofs |        Display fill: (0 @ 0 extent: 500 @ 120) rule: Form over fillColor: Color white.        ofs := ((owner hands indexOf: self) - 1) * 60.        evt printString displayAt: 0 @ ofs + (evt isKeyboard ifTrue: [ 0 @ 30 ] ifFalse: [ 0 @ 0 ]).        self keyboardFocus printString displayAt: 0 @ ofs + (0 @ 45) ]asText  | anchor embedMorphSignal |  anchor := TextAnchor new anchoredMorph: self.  embedMorphSignal := (Character value: 1) asString.  ^Text string: embedMorphSignal attribute: anchoricon: aBlock  iconBlock := aBlocknewFuzzyLabel: aString  ^self theme newFuzzyLabelIn: self for: nil label: aString offset: 1 alpha: 0.5 getEnabled: nilchildNodeClassFromItem: anItem  ^PackageMethodNodeExampleframeRectangle: aRectangle on: aCanvas  aCanvas frameAndFillRectangle: aRectangle fillColor: Color transparent borderWidth: (self width - self margin max: 0) topLeftColor: self topLeftColor bottomRightColor: self bottomRightColorsolidLabelMorph  ^solidLabelMorphroomToMove  ^self bounds isWide ifTrue: [ self totalSliderArea insetBy: (((self sliderThickness // 2) @ 0) negated corner: (self sliderThickness // 2 + 1) @ 0) ] ifFalse: [ self totalSliderArea insetBy: (0 @ (self sliderThickness // 2) negated corner: 0 @ (self sliderThickness // 2 - (self sliderThickness \\ 2) + 1)) ]enabled  ^self isEnabledballoonHelp  ^self valueOfProperty: #balloonHelpMorphextent: aPoint  self changed.  bounds := bounds topLeft extent: aPoint.  self layoutChanged.  self changedpressedImage: aForm  pressedImage := aForm.  self invalidRect: self boundsaddPaneVSplitterBetween: leftMorph and: rightMorphs  | targetX minY maxY splitter |  targetX := leftMorph layoutFrame rightFraction.  minY := (rightMorphs detectMin: [:each |  each layoutFrame topFraction ]) layoutFrame topFraction.  maxY := (rightMorphs detectMax: [:each |  each layoutFrame bottomFraction ]) layoutFrame bottomFraction.  splitter := ProportionalSplitterMorph new.  splitter layoutFrame: ((targetX @ minY corner: targetX @ maxY) asLayoutFrame           leftOffset: leftMorph layoutFrame rightOffset;           rightOffset: 4 + leftMorph layoutFrame rightOffset;           topOffset: leftMorph layoutFrame topOffset;           bottomOffset: leftMorph layoutFrame bottomOffset).  self addMorphBack: (splitter position: self position)handlesMouseStillDown: evt  ^self existsSubscriptionsFor: #mouseStillDownreplaceSelectionWith: aReplacementText  self handleEdit: [ self editor replaceSelectionWith: aReplacementText ]isWindowNavigation  ^TaskListMorph isNavigationEvent: selfexecute  actionBlock cull: table dataSource cull: field getTextFromModel asString cull: (table selectedIndex = 0 ifFalse: [ table dataSource realElementAt: table selectedIndex ] ifTrue: [ nil ])shadowColor: aColor  self shadowColor = aColor ifFalse: [ self changed ].  self setProperty: #shadowColor toValue: aColorposition: aPoint  | delta box |  delta := aPoint asNonFractionalPoint - bounds topLeft.  (delta x = 0 and: [ delta y = 0 ]) ifTrue: [ ^self ].  box := self fullBounds.  (delta dotProduct: delta) > 100 ifTrue: [ self invalidRect: box.        self invalidRect: (box translateBy: delta) ] ifFalse: [ self invalidRect: (box merge: (box translateBy: delta)) ].  self privateFullMoveBy: delta.  owner ifNotNil: [ owner layoutChanged ]adjustAlarmTimes: nowTime  | deltaTime |  deltaTime := nowTime - lastAlarmTime.  self alarms do: [:alarm |  alarm scheduledTime: alarm scheduledTime + deltaTime ]changeRequest: anAnnounce  ^anAnnounce change: selfnewPluggableDialogWindow: title  ^self newPluggableDialogWindow: title for: niladdCloseBox  | frame |  labelArea ifNil: [ ^self ].  closeBox := self createCloseBox.  frame := LayoutFrame identity leftOffset: 2.  closeBox layoutFrame: frame.  labelArea addMorphBack: closeBoxnodeStringGetter: aValuable  self columns first nodeStringGetter: aValuableupdateState  (target perform: stateSelector) ifTrue: [ self state: #on ] ifFalse: [ self state: #off ]editorProvider: aValuable  self setProperty: #editorProvider toValue: aValuableheight  ^header ifNil: [ 0 ] ifNotNil: [ header height ]formerPosition: formerPosition  formerPosition ifNil: [ self removeProperty: #formerPosition ] ifNotNil: [ self setProperty: #formerPosition toValue: formerPosition ]getLabelSelector: aSymbol  getLabelSelector := aSymboldispatchKeystroke: anEvent  anEvent keyCharacter == Character tab ifTrue: [ self tabAmongFields ifTrue: [ ^self tabHitWithEvent: anEvent ] ]mayBeExtended  ^falsekeystrokeActionSelector: aSymbol  keystrokeActionSelector := aSymbolkeyValue  ^keyValueinitialize  super initialize.  toolbar := TabBarMorph new.  processes := OrderedCollection new.  self registerBarActions.  self registerShortcuts.  container := Morph new     color: self containerColor;     changeProportionalLayout;     yourself.  contentsWrapper := Morph new     color: self containerColor;     changeProportionalLayout;     yourself.  self changeProportionalLayout.  self addMorphsmouseUpOnMultiple: event  dragOnOrOff := nil.  event hand hasSubmorphs ifFalse: [ self mouseDownRow: nil ]acceptDroppingMorph: aMorph event: evt  dropItemSelector ifNotNil: [ | item |        dropItemSelector ifNil: [ ^self ].        item := aMorph passenger.        model perform: dropItemSelector with: item with: potentialDropRow ] ifNil: [ self model acceptDroppingMorph: aMorph event: evt inMorph: self ].  self resetPotentialDropRow.  evt hand releaseMouseFocus: self.  Cursor normal showdescending: aBoolean  descending := aBoolean.  self value: valuehatchForm  ^ColorPresenterMorph hatchFormrectangle: aValue  rectangle := aValuescrollDeltaWidth  ^self scrollDeltaHeight // 2deleteDockingBars  self dockingBars do: [:each |  each delete ]delete  super delete.  self triggerEvent: #barDeleted with: selfcancelled: anObject  cancelled := anObjectcornerStyle  ^cornerStyle ifNil: [ #square ]column: aColumn  column := aColumnarrangeToStartSteppingIn: aWorld  aWorld ifNil: [ ^self ].  aWorld startStepping: self.  self changeddoubleClick  dblClickSelector ifNotNil: [ clickClient perform: dblClickSelector with: firstClickDown ]wrapCentering: aSymbol  self assureTableProperties wrapCentering: aSymbol.  self layoutChangedaddOrRemoveItems: handOrEvent  | hand |  hand := handOrEvent isMorphicEvent ifFalse: [ handOrEvent ] ifTrue: [ handOrEvent hand ].  hand addMorphBack: ((self class newBounds: (hand lastEvent cursorPoint extent: 16 @ 16)) setOtherSelection: self)normalFillStyle  ^self theme morphTreeSplitterNormalFillStyleFor: selfgetMenuSelector: aSymbol  getMenuSelector := aSymbolnewLabelMorph  ^(LabelMorph contents: self label)     on: #mouseDown send: #toggleSelected to: self;     yourselfhandleRect  ^Rectangle center: self bounds center extent: (self splitsTopAndBottom ifTrue: [ self handleSize transposed ] ifFalse: [ self handleSize ])keyStroke: evt  super keyStroke: evt.  (self navigationKey: evt) ifTrue: [ ^true ].  ^falsedeliverTo: aHandler  ^aHandler update: selectorupdateDownButtonImage  downButton removeAllMorphs.  downButton addMorphCentered: (ImageMorph new form: self downImage)collapse  recentlyChanged := true.  self dataSource updateSelectionWithCollectBlock: [:indexOfCurrentSelection :indexOfCollapsedElement |  | changedBy |        changedBy := self numberOfVisibleChildren.        (indexOfCurrentSelection between: indexOfCollapsedElement and: indexOfCollapsedElement + changedBy) ifTrue: [ indexOfCollapsedElement ] ifFalse: [ indexOfCurrentSelection < indexOfCollapsedElement ifTrue: [ indexOfCurrentSelection ] ifFalse: [ indexOfCurrentSelection - changedBy ] ] ].  isExpanded := falsenewColorPresenterFor: aModel getColor: getSel help: helpText  ^self theme newColorPresenterIn: self for: aModel getColor: getSel help: helpTextwouldAcceptKeyboardFocusUponTab  ^falsecentered  self changeAlignment: #centeredinitialize  super initialize.  self addDependent: SystemProgressMorph uniqueInstanceputOnTop: aMorph  windows remove: aMorph.  windows addLast: aMorphnewExpander: aString forAll: controls  ^self theme newExpanderIn: self label: aString forAll: controlsisNotMinimized  ^self isCollapsed notmenuKeyboardControl  ^self theme settings menuKeyboardControlwithTreeLines: aBoolean  self treeLineWidth: 1privateMoveBy: delta  | fill border |  bounds := bounds translateBy: delta.  fullBounds ifNotNil: [ fullBounds := fullBounds translateBy: delta ].  fill := self fillStyle.  fill isOrientedFill ifTrue: [ fill origin: fill origin + delta ].  border := self borderStyle.  (border hasFillStyle and: [ border fillStyle isOrientedFill ]) ifTrue: [ border fillStyle origin: border fillStyle origin + delta ]add: wordingString icon: aForm help: helpString subMenu: aMenuMorph  self add: wordingString icon: aForm help: helpString subMenu: aMenuMorph action: nil keyText: nildisabledFillStyle  ^self theme taskbarItemDisabledFillStyleFor: selfadjacentTo  | verticalMargin |  verticalMargin := 4 + owner borderWidth.  owner isFloating ifTrue: [ ^{(self bounds bottomLeft + (5 @ verticalMargin))} ].  owner isAdheringToTop ifTrue: [ ^{(self bounds bottomLeft + (5 @ verticalMargin))} ].  owner isAdheringToLeft ifTrue: [ ^{(self bounds topRight + (5 @ verticalMargin))} ].  owner isAdheringToBottom ifTrue: [ ^{(self bounds topLeft + (5 @ verticalMargin))} ].  owner isAdheringToRight ifTrue: [ ^{(self bounds topLeft + (5 @ verticalMargin negate))} ].  ^{(self bounds bottomLeft + (3 @ verticalMargin))}cellColumn: column row: rowIndex  ^FTCellMorph new     color: (self colorFor: rowIndex);     cellInset: 5;     addMorphBack: (self iconFor: rowIndex) asMorph;     addMorphBack: (self elementAt: rowIndex) name asStringMorph;     yourselfinternalSpaces  ^internalSpacesfitAllVisibleWindows  | allowedArea |  allowedArea := RealEstateAgent maximumUsableAreaInWorld: self currentWorld.  (self windowsSatisfying: [:w |  w isCollapsed not ]) reverseDo: [:w |  w extent: w initialExtent.        w bounds: ((w position extent: w initialExtent) translatedAndSquishedToBeWithin: allowedArea) ].  self displayWorldclippingBounds  ^self innerBoundsexpandItemPath: anItemPath  self requestView: (MorphTreeChangeRequest expandItemPath: anItemPath)setTabs: aBlock  self tabs: aBlock valuesetToAdhereToEdge: anEdge  anEdge ifNil: [ ^self ].  anEdge == #none ifTrue: [ ^self removeProperty: #edgeToAdhereTo ].  self setProperty: #edgeToAdhereTo toValue: anEdgeselected: aBoolean  (self state == #pressed or: [ self state == #repressed ]) ifTrue: [ self state: (aBoolean ifTrue: [ #repressed ] ifFalse: [ #pressed ]) ] ifFalse: [ self state: (aBoolean ifTrue: [ #on ] ifFalse: [ #off ]) ]shiftPressed  ^lastMouseEvent shiftPressedrotationDegrees  ^0.0dragEnabled  ^(self valueOfProperty: #dragEnabled) == truevertProfile  vertProfile ifNil: [ self computeShadow ].  ^vertProfilebuildRowMorphsFrom: aNodeMorph  self buildRowMorphsFrom: aNodeMorph increment: self lazyIncrementfullReleaseCachedState  self allMorphsDo: [:m |  m releaseCachedState ]drawSubmorphsOn: aCanvas  | alpha |  (alpha := self magicAlpha) = 1.0 ifTrue: [ ^super drawSubmorphsOn: aCanvas ].  ^super drawSubmorphsOn: (aCanvas asAlphaBlendingCanvas: alpha)topVisibleRowForCanvas: aCanvas  ^self rowAtLocation: aCanvas clipRect topLefthUnadjustedScrollRange  ^self listMorph hUnadjustedScrollRangecollapseOrExpand  | cf |  self isTaskbarPresent ifTrue: [ ^self minimizeOrRestore ].  isCollapsed ifTrue: [ isCollapsed := false.        self activate.        collapsedFrame := self getBoundsWithFlex.        collapseBox ifNotNil: [ collapseBox setBalloonText: 'Collapse this window' ].        self setBoundsWithFlex: fullFrame.        paneMorphs reverseDo: [:m |  self addMorph: m unlock.              self world startSteppingSubmorphsOf: m ].        self           addPaneSplitters;           addGripsIfWanted ] ifFalse: [ isCollapsed := true.        fullFrame := self getBoundsWithFlex.        paneMorphs do: [:m |  m                 delete;                 releaseCachedState ].        self removePaneSplitters.        self removeGrips.        cf := self getCollapsedFrame.        collapsedFrame ifNil: [ collapsedFrame := cf ].        self setBoundsWithFlex: cf.        collapseBox ifNotNil: [ collapseBox setBalloonText: 'expand this window' ].        expandBox ifNotNil: [ expandBox setBalloonText: 'expand to full screen' ] ].  self layoutChanged.  self announce: (WindowCollapsed new           window: self;           yourself)menu: menu shifted: b  ^menuenable  self enabled: truebeSingleSelection  selectionStrategy := FTSimpleSelection table: selfaddDebugHandle: handleSpec  self class haloWithDebugHandle ifTrue: [ self addHandle: handleSpec on: #mouseDown send: #doDebug:with: to: self ]composeOneLine  | rectangles |  rectangles := theContainer rectanglesAt: currentY height: defaultLineHeight.  rectangles notEmpty ifTrue: [ (self composeAllRectangles: rectangles) ifNil: [ ^nil ] ] ifFalse: [ currentY := currentY + defaultLineHeight ].  self checkIfReadyToSlidenewCloseButtonFor: aModel  ^self theme newCloseButtonIn: self for: aModeleventHandler: newValue  eventHandler := newValuemodel  ^modelrotationCenter: aPointOrNil  | box |  aPointOrNil ifNil: [ self removeProperty: #referencePosition ] ifNotNil: [ box := self bounds.        self setProperty: #referencePosition toValue: box origin + (aPointOrNil * box extent) ]deferUpdates: aValue  ^Display deferUpdates: aValueveryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  defaultTarget := deepCopier references at: defaultTarget ifAbsent: [ defaultTarget ].  popUpOwner := deepCopier references at: popUpOwner ifAbsent: [ popUpOwner ].  activeSubMenu := deepCopier references at: activeSubMenu ifAbsent: [ activeSubMenu ]updateFeedbackForEvt: evt  | newState |  newState := self containsPoint: evt cursorPoint.  newState = showSelectionFeedback ifFalse: [ self showSelectionFeedback: newState.        self           changed;           layoutChanged ]disabledBorderStyle  ^self theme taskbarItemDisabledBorderStyleFor: selfhorizontal: aBoolean  ^self orientation: (aBoolean ifTrue: [ #horizontal ] ifFalse: [ #vertical ])selectedDisabledFillStyle  ^self theme taskbarItemSelectedDisabledFillStyleFor: selfsetScrollDeltas  self     hSetScrollDelta;     vSetScrollDeltatransformedBy: aMorphicTransform  addMenuItem: anItem  self addMorphBack: anItem.  ^anItemcloseItemPath: anArray  | found |  anArray isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ each complexContents withoutListWrapper = anArray first ifTrue: [ found := each ] ] ].  found ifNotNil: [ (found isExpanded and: [ anArray size = 1 ]) ifTrue: [ found toggleExpandedState.              container adjustSubmorphPositions ].        found changed.        anArray size = 1 ifTrue: [ ^container listManager setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild closeItemPath: anArray allButFirst ] ].  ^container setSelectedMorph: nilnewToolbar: controls  ^self theme newToolbarIn: self for: controlsvScrollbar: anObject  vScrollbar := anObjectminCellSize: aNumber  minCellSize := aNumberinvalidRect: aRectangle  beExplicite  self deprecated: 'Use #beExplicit instead' transformWith: '`@receiver beExplicite' -> '`@receiver beExplicit'.  ^self beExplicitdrawOn: aCanvas  (owner notNil and: [ owner containsPoint: self position ]) ifTrue: [ super drawOn: aCanvas ]subMenuMarker  ^self rightArrowdashColors: cols dashLengths: lens  cols size = lens size ifFalse: [ self error: 'Colors and Lengths must have the same size' ].  self     dashColors: cols;     dashLengths: lensthemeChanged  isEditEvent: anEvent  | key |  key := anEvent keyValue asCharacter.  ^key == Character cr or: [ key == Character escape or: [ key == Character backspace or: [ key == Character delete or: [ key == Character arrowLeft or: [ key == Character arrowRight or: [ key == Character home or: [ key == Character end or: [ anEvent commandKeyPressed and: [ key = $a ] ] ] ] ] ] ] ] ]stateSelector  ^stateSelectoruseSecondarySelection  ^TextEditor useSecondarySelectionscale: newScale  mouseMove: evt  allButtons ifNil: [ ^self ].  allButtons do: [:m |  m updateFeedbackForEvt: evt ]newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpTextouterGap  ^self cornerRadius * 2highlightRowIndex: aNumber  self deprecated: 'Use #highlightIndex: instead' transformWith: '`@receiver highlightRowIndex: `@statements1' -> '`@receiver highlightIndex: `@statements1'.  self highlightIndex: aNumberprintOn: aStream  aStream nextPut: $[.  aStream     nextPutAll: self type;     space.  aStream     nextPut: $(;     print: self rectangle;     nextPut: $).  aStream nextPut: $]areasRemainingToFill: aRectangle  ^Array with: aRectanglehandlesKeyboard: evt  ^truestylingEnabled  ^falsenewAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletionbuttonForMorph: aMorph  | index |  index := (self orderedTasks collect: [:t |  t morph ]) indexOf: aMorph.  ^index = 0 ifTrue: [ nil ] ifFalse: [ self submorphs at: index ifAbsent: [  ] ]rotationDegrees  ^0.0handlesKeyboard: evt  ^trueownerChanged  self owner ifNil: [ ^self ].  [ self updateBounds.  self updateTasks ] on: Exception do: [:ex |  self delete.        ex pass ].  super ownerChangedsmoothingOn  smoothing := 2.  self changeduiProcess  ^UIProcessdropElements: aCollection index: rowIndex  self dropItemSelector ifNil: [ ^self ].  self model perform: self dropItemSelector with: aCollection with: rowIndexminimumExtent: aPoint  self setProperty: #minimumExtent toValue: aPointpageSearchText  ^pageSearchText ifNil: [ pageSearchText := '' ]composeEachRectangleIn: rectangles  | myLine lastChar |  1 to: rectangles size do: [:i |  currCharIndex <= theText size ifFalse: [ ^false ].        myLine := scanner composeFrom: currCharIndex inRectangle: (rectangles at: i) firstLine: isFirstLine leftSide: i = 1 rightSide: i = rectangles size.        lines addLast: myLine.        actualHeight := actualHeight max: myLine lineHeight.        currCharIndex := myLine last + 1.        myLine last = 0 ifTrue: [ ^false ].        lastChar := theText at: myLine last.        (CharacterSet crlf includes: lastChar) ifTrue: [ ^#cr ].        wantsColumnBreaks ifTrue: [ lastChar = self class characterForColumnBreak ifTrue: [ ^#columnBreak ] ] ].  ^falsehasParagraphAnchorString  ^(self textAnchorType == #paragraph) -> 'Paragraph' translatedmodalLockTo: aSystemWindow  | lockStates |  lockStates := IdentityDictionary new.  self submorphsDo: [:m |  lockStates at: m put: m isLocked.        m lock ].  aSystemWindow unlock.  lockStates at: aSystemWindow put: aSystemWindow isLocked.  self setProperty: #submorphLockStates toValue: lockStatesclosestPointTo: aPoint  | closestPoint minDist |  closestPoint := minDist := nil.  self lineSegmentsDo: [:p1 :p2 |  | dist curvePoint |        curvePoint := aPoint nearestPointOnLineFrom: p1 to: p2.        dist := curvePoint distanceTo: aPoint.        (closestPoint isNil or: [ dist < minDist ]) ifTrue: [ closestPoint := curvePoint.              minDist := dist ] ].  ^closestPointscaledValue  | val |  val := self value * (self max - self min) + self min.  self quantum ifNotNil: [:q |  val := val roundTo: q ].  ^(val max: self min) min: self maxstartingIndex  predecessor ifNil: [ ^1 ].  ^predecessor lastCharacterIndex + 1maxRightX  ^maxRightXprepareToBeSaved  self releaseCachedState.  self formerOwner: nil.  self formerPosition: nil.  fullBounds := nilrootItems  ^rootItems ifNil: [ rootItems := {} ]mouseLeaveDragging: evt  evt hand showTemporaryCursor: nil.  self showLocationlabel: aStringOrMorph  self labelMorph: (aStringOrMorph isMorph ifTrue: [ aStringOrMorph ] ifFalse: [ self labelMorph contents: aStringOrMorph.              self newLabel ])setRight: x  right := xfont: aFont  | newTextStyle |  newTextStyle := aFont textStyle copy ifNil: [ TextStyle fontArray: {aFont} ].  textStyle := newTextStyle.  text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOf: aFont)).  paragraph ifNotNil: [ paragraph textStyle: newTextStyle ]testSelectLast  table selectLast.  self assert: table selectedIndexes equals: #(#(10 3))wrapBlockOrSelector: aBlockOrSelector  wrapBlockOrSelector := aBlockOrSelectorstartAt: aNumber  value := start := aNumberscrollRight: count  self scrollDown: countmouseDown: evt  | now dt |  self state: #pressed.  actWhen == #buttonDown ifTrue: [ self doButtonAction ] ifFalse: [ now := Time millisecondClockValue.        super mouseDown: evt.        dt := Time millisecondClockValue - now max: 0.        dt < 200 ifTrue: [ (Delay forMilliseconds: 200 - dt) wait ] ].  self mouseStillDown: evtselectionIndex: idx  | theMorph range index |  idx ifNil: [ ^self ].  index := idx min: scroller submorphs size max: 0.  (theMorph := index = 0 ifTrue: [ nil ] ifFalse: [ scroller submorphs at: index ]) ifNotNil: [ (theMorph bounds top - scroller offset y >= 0 and: [ theMorph bounds bottom - scroller offset y <= self innerBounds height ]) ifFalse: [ range := self vTotalScrollRange.              scrollBar value: (range > 0 ifTrue: [ (index - 1) * theMorph height / self vTotalScrollRange truncateTo: scrollBar scrollDelta ] ifFalse: [ 0 ]).              scroller offset: -3 @ (range * scrollBar value) ] ].  self selectedMorph: theMorphlineIndexOfCharacterIndex: characterIndex  ^self lineIndexForCharacter: characterIndexmouseEnter: evt  owner ifNotNil: [ owner stayUp ifFalse: [ self mouseEnterDragging: evt ] ]vResizingString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self vResizingonLastPage  ^self lastIndex = self nodeList sizetaskList: anObject  taskList := anObjectthumbnailOfSize: thumbExtent  | f t r |  r := self header fullBounds scaledAndCenteredIn: (0 @ 0 extent: thumbExtent).  f := Form extent: r extent depth: Display depth.  t := MatrixTransform2x3 withScale: 1.0.  f getCanvas transformBy: t clippingTo: f boundingBox during: [:c |  c translateBy: self visibleBounds topLeft negated during: [:ct |  self container fullDrawOn: ct ] ] smoothing: 6.  ^ImageMorph new form: fnewPanel  ^self theme newPanelIn: selfreverseTableCells: aBool  self assureTableProperties reverseTableCells: aBool.  self layoutChangedmoveCollapsedWindowsToTaskbar  (self systemWindows select: [:w |  w isCollapsed ]) do: [:w |  w           restore;           minimize ]extraSpace  ^extraSpace ifNil: [ 0 @ 0 ]basicButton  | button |  ^(button := SimpleButtonMorph new)     clipSubmorphs: true;     color: self pagerColor;     on: #mouseEnter send: #value to: [ button borderColor: self pagerColor muchDarker ];     on: #mouseLeave send: #value to: [ button borderColor: self pagerColor ];     target: self;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     listCentering: #leftCenter;     wrapCentering: #center;     layoutInset: 2 @ 0;     cellInset: 2 @ 0;     borderWidth: 1;     borderColor: self pagerColor;     yourselfsetEditView: editPane  editView := editPanescroller  ^scrollergetListElementSelector: anObject  getListElementSelector := anObjectmaxLength: anObject  maxLength := anObjectdraggedMorph  draggedMorph ifNil: [ self initDraggedMorph ].  ^draggedMorphresizeToFitString  ^(self resizeToFit ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'resize to fit' translatedbeSticky  self assureExtension sticky: trueisFlexed  ^owner notNil and: [ owner isFlexMorph ]drawSubmorphsOnAthensCanvas: anAthensCanvas  | clip |  clip := self clippingBounds intersect: anAthensCanvas clipRect.  anAthensCanvas transformBy: self transform withClip: clip in: self innerBounds during: [:c |  submorphs do: [:m |  m fullDrawOnAthensCanvas: c ] ]defaultColor  ^Color bluehash  ^anchoredMorph identityHashdrawLinesOn: aCanvas  self hasToggleAtRoot ifFalse: [ ^self ].  aCanvas transformBy: scroller transform clippingTo: scroller innerBounds during: [:clippedCanvas |  scroller submorphsDo: [:submorph |  | last |              ((submorph isExpanded and: [ (submorph nextSibling notNil and: [ clippedCanvas isVisible: (submorph fullBounds topLeft corner: submorph nextSibling fullBounds bottomRight) ]) or: [ submorph nextSibling isNil and: [ (last := submorph lastChild) notNil and: [ clippedCanvas isVisible: (submorph fullBounds topLeft corner: last fullBounds bottomRight) ] ] ] ]) or: [ (clippedCanvas isVisible: submorph fullBounds) or: [ submorph nextSibling notNil and: [ clippedCanvas isVisible: submorph nextSibling fullBounds ] ] ]) ifTrue: [ submorph drawLinesOn: clippedCanvas ] ] ] smoothing: scroller smoothingmarried: anObject  married := anObjectnewEditableDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel ghostText: ghostText getEnabled: enabledSel help: helpText  ^self theme newEditableDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: String default: '' ghostText: ghostText getEnabled: enabledSel useIndex: false help: helpTextdefaultColor  ^self theme menuTitleColorFor: nilchangeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand  (UIManager default chooseColor: aColor) ifNotNil: [:nc |  anObject perform: aSymbol with: nc ]enabled  ^trueexpandAll  children do: #expandAlladdWindow: aSystemWindow  aSystemWindow isTopWindow ifTrue: [ SystemWindow passivateTopWindow ].  self tabGroup     addPage: aSystemWindow configureForEmbedding label: (self tabLabelFor: aSystemWindow);     selectedPageIndex: self tabGroup pages size.  self isActive ifFalse: [ self tabGroup selectedTab passivate ].  self tabGroup selectedTab on: #startDrag send: #dragTab:event:in: to: self withValue: aSystemWindow.  aSystemWindow announcer when: WindowLabelled send: #onWindowLabelChanged: to: selfstoreValue: aValue  ^self owner owner storeValue: aValuehasProportionalLayoutString  | layout |  ^((layout := self layoutPolicy) notNil and: [ layout isProportionalLayout ]) -> 'proportional layout' translatedwantsRoundedCorners  ^self theme currentSettings preferRoundCornerstep  borderDashSpec ifNil: [ ^super step ].  borderDashSpec size < 5 ifTrue: [ ^super step ].  borderDashSpec at: 4 put: borderDashSpec fourth + borderDashSpec fifth.  self changed.  ^super steplistModel  ^client modelreverseTableCells  ^reverseTableCellsactualFont  ^actualFont ifNil: [ TextStyle defaultFont ]forwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectionexpandSlider  | r |  r := self totalSliderArea.  slider extent: (bounds isWide ifTrue: [ ((r width * interval) asInteger max: self sliderThickness) @ slider height ] ifFalse: [ slider width @ ((r height * interval) asInteger max: self sliderThickness) ])enabled  ^enabledhandsReverseDo: aBlock  ^worldState handsReverseDo: aBlockdefaultExtent  ^150 @ 120rowAtLocation: aPoint  | y |  y := aPoint y.  y < self top ifTrue: [ ^1 ].  ^(y - self top) // font height + 1 min: listItems size max: 0dropMorphs  self dropMorphs: lastMouseEventveryDeepInner: deepCopier  super veryDeepInner: deepCopier.  textStyle := textStyle veryDeepCopyWith: deepCopier.  text := text veryDeepCopyWith: deepCopier.  wrapFlag := wrapFlag veryDeepCopyWith: deepCopier.  paragraph := paragraph veryDeepCopyWith: deepCopier.  editor := editor veryDeepCopyWith: deepCopier.  container := container veryDeepCopyWith: deepCopier.  predecessor := predecessor.  successor := successor.  backgroundColor := backgroundColor veryDeepCopyWith: deepCopier.  margins := margins veryDeepCopyWith: deepCopiernewMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: enabledSel help: helpText  ^self theme newMorphListIn: self for: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: enabledSel help: helpTextdispatchDefault: anEvent with: aMorph  | localEvt index child morphs inside |  (aMorph fullBounds containsPoint: anEvent position) ifFalse: [ ^#rejected ].  index := 1.  morphs := aMorph submorphs.  inside := false.  [ index <= morphs size ] whileTrue: [ child := morphs at: index.        localEvt := anEvent transformedBy: (child transformedFrom: aMorph).        (child processEvent: localEvt using: self) == #rejected ifFalse: [ inside := true.              localEvt wasHandled ifTrue: [ anEvent copyHandlerState: localEvt ].              index := morphs size ].        index := index + 1 ].  inside ifFalse: [ inside := aMorph containsPoint: anEvent position event: anEvent ].  inside ifTrue: [ ^aMorph handleEvent: anEvent ].  ^#rejectedselectItem: aMenuItem event: anEvent  self owner ifNotNil: [ | menus |        menus := self owner submorphs select: [:m |  (m isKindOf: self class) and: [ m ~~ self ] ].        menus do: [:menu |  menu perform: #selectItem:event: withArguments: {nil .                     anEvent} inSuperclass: self class superclass ] ].  ^super selectItem: aMenuItem event: anEventcheckboxBorderStyleToUse  ^self selected ifTrue: [ self enabled ifTrue: [ self theme checkboxButtonSelectedBorderStyleFor: self ] ifFalse: [ self theme checkboxButtonSelectedDisabledBorderStyleFor: self ] ] ifFalse: [ self enabled ifTrue: [ self theme checkboxButtonNormalBorderStyleFor: self ] ifFalse: [ self theme checkboxButtonDisabledBorderStyleFor: self ] ]drawOn: aCanvas  | stringColor stringBounds |  (isSelected and: [ isEnabled ]) ifTrue: [ aCanvas fillRectangle: self bounds fillStyle: self selectionFillStyle.        stringColor := color negated ] ifFalse: [ stringColor := color ].  stringBounds := bounds.  stringBounds := stringBounds left: stringBounds left + 4.  self hasIcon ifTrue: [ | iconForm |        iconForm := self iconForm.        aCanvas translucentImage: iconForm at: stringBounds left @ (self top + ((self height - iconForm height) // 2)).        stringBounds := stringBounds left: stringBounds left + iconForm width + 2 ].  self hasMarker ifTrue: [ stringBounds := stringBounds left: stringBounds left + self submorphBounds width + 8 ].  stringBounds := stringBounds top: (stringBounds top + stringBounds bottom - self fontToUse height) // 2.  aCanvas drawString: self contents in: stringBounds font: self fontToUse color: stringColor.  self hasSubMenu ifTrue: [ | subMenuMarker subMenuMarkerPosition |        subMenuMarker := self subMenuMarker.        subMenuMarkerPosition := (self right - subMenuMarker width) @ ((self top + self bottom - subMenuMarker height) // 2).        subMenuMarkerPosition := subMenuMarkerPosition - (4 @ -1).        aCanvas paintImage: subMenuMarker at: subMenuMarkerPosition ]scrollDeltaWidth  ^10restoreFocus: originalFocusHolder in: aWorld  aWorld primaryHand keyboardFocus ifNotNil: [ ^self ].  originalFocusHolder ifNotNil: [ aWorld primaryHand newKeyboardFocus: originalFocusHolder ]testWindowCreationAndDeletion  | t newWindowCreated |  t := 0.  self currentWorld announcer when: WindowOpened do: [:ann |  t := t + 1.        newWindowCreated := ann window ].  self currentWorld announcer when: WindowClosed do: [:ann |  t := t + 10.        newWindowCreated := ann window ].  window := SystemWindow labelled: 'foo'.  window openInWorld.  self assert: t equals: 1.  self assert: window identicalTo: newWindowCreated.  window delete.  self assert: t equals: 11.  self assert: window identicalTo: newWindowCreatedalpha  ^alphalayout: aMorph in: bounds  | props spare extra height inset fillCount x width |  aMorph submorphs ifEmpty: [ ^self ].  props := aMorph assureTableProperties.  width := (self minExtentOf: aMorph in: bounds) x.  spare := bounds width - width max: 0.  fillCount := 0.  spare > 0 ifTrue: [ fillCount := aMorph submorphs size.        extra := fillCount = 0 ifTrue: [ 0 ] ifFalse: [ spare // fillCount ].        spare := spare - ((fillCount - 1) * extra) ] ifFalse: [ extra := 0 ].  x := fillCount > 0 ifTrue: [ bounds left ] ifFalse: [ props listCentering == #center ifTrue: [ bounds center x - (width // 2) ] ifFalse: [ props listCentering == #bottomRight ifTrue: [ bounds right - width ] ifFalse: [ bounds left ] ] ].  height := bounds height.  inset := props cellInset isPoint ifTrue: [ props cellInset x ] ifFalse: [ props cellInset ].  aMorph submorphs withIndexDo: [:eachMorph :index |  | pos box cell |        width := (eachMorph width = 0 and: [ fillCount > 0 ]) ifTrue: [ (bounds width + bounds left - x) / (fillCount - index + 1) ] ifFalse: [ eachMorph width ].        cell := x @ bounds top extent: width @ height.        box := cell origin extent: cell width @ cell height.        pos := props cellPositioning.        box := box align: (box perform: pos) with: (cell perform: pos).        eachMorph bounds: box.        x := x + width + inset ]autoSize: anObject  autoSize := anObjectupdate: anAspect  ^selfright  ^bounds rightcurrentWorld  ActiveWorld ifNotNil: [ ^ActiveWorld ].  ^WorldsetDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedmenuColumn: column row: rowIndex  rowIndex = 0 ifTrue: [ ^nil ].  ^(UIManager default newMenuIn: self table for: self)     add: 'Expand All ' target: self selector: #expandAll;     add: 'Collapse All' target: self selector: #collapseAll;     yourselfaddInHistory: aTab  self removeFromHistory: aTab.  selectionHistory addLast: aTablabel: aLabel  label := aLabel.  self changedrowHeight: aNumber  rowHeight := aNumberavailableBorderStyles  ^#(normalBorderStyle mouseOverBorderStyle pressedBorderStyle disabledBorderStyle selectedBorderStyle selectedPressedBorderStyle selectedMouseOverBorderStyle selectedDisabledBorderStyle)tabSelector: anObject  tabSelector := anObjectaddToggle: aString selector: aSymbol  self addToggle: aString target: defaultTarget selector: aSymbol getStateSelector: nil argumentList: EmptyArrayselectLastTab  tabs ifEmpty: [ ^self ].  tabs last selected: truemaxDepth: anObject  maxDepth := anObjectisDockingBar  ^trueupdate: aSymbol  super update: aSymbol.  aSymbol == #selectedIndex ifTrue: [ self tabGroup page activate ]secondarySelectionColor  ^self theme secondarySelectionColorclosestSegmentTo: aPoint  | closestPoint minDist vertexIndex closestVertexIndex |  vertexIndex := 0.  closestVertexIndex := 0.  closestPoint := minDist := nil.  self lineSegmentsDo: [:p1 :p2 |  | curvePoint dist |        p1 = (self vertices at: vertexIndex + 1) ifTrue: [ vertexIndex := vertexIndex + 1 ].        curvePoint := aPoint nearestPointOnLineFrom: p1 to: p2.        dist := curvePoint distanceTo: aPoint.        (closestPoint isNil or: [ dist < minDist ]) ifTrue: [ closestPoint := curvePoint.              minDist := dist.              closestVertexIndex := vertexIndex ] ].  ^closestVertexIndexmouseEnter: evt  ^self eventHandler ifNotNil: [ self eventHandler mouseEnter: evt fromMorph: self ]deny: aStringOrText title: aString  ^self theme denyIn: self text: aStringOrText title: aStringgetEnabledSelector: aSymbol  getEnabledSelector := aSymbol.  self updateEnabledcontext: anObject  context := anObjectdisplayFiltered: evt  | matchStr matches feedbackMorph |  matchStr := self valueOfProperty: #matchString.  matches := self menuItems select: [:m |  | isMatch |        isMatch := matchStr isEmpty or: [ m contents includesSubstring: matchStr caseSensitive: false ].        m isEnabled: isMatch.        isMatch ].  feedbackMorph := self valueOfProperty: #feedbackMorph.  feedbackMorph ifNil: [ feedbackMorph := TextMorph new           autoFit: true;           color: Color darkGray.        self           addLine;           addMorphBack: feedbackMorph lock.        self setProperty: #feedbackMorph toValue: feedbackMorph.        self fullBounds ].  feedbackMorph contents: '<' , matchStr , '>'.  matchStr isEmpty ifTrue: [ feedbackMorph delete.        self lastSubmorph delete.        self removeProperty: #feedbackMorph ].  (evt notNil and: [ matches size >= 1 ]) ifTrue: [ self selectItem: matches first event: evt ]wrapCentering: aSymbol  wrapCentering := aSymbolisAutoFit  ^self valueOfProperty: #autoFitContents ifAbsent: [ true ]invalidRect: damageRect from: aMorph  hasChanged := true.  aMorph == self ifTrue: [ ^self ].  damageRecorder recordInvalidRect: damageRectdrawOn: aCanvas  (owner notNil and: [ owner containsPoint: self position ]) ifTrue: [ super drawOn: aCanvas ]newKeyboardFocus: aMorphOrNil  | oldFocus |  keyboardFocus == aMorphOrNil ifTrue: [ ^self ].  oldFocus := keyboardFocus.  keyboardFocus := aMorphOrNil.  oldFocus ifNotNil: [ oldFocus keyboardFocusChange: false ].  aMorphOrNil ifNotNil: [ aMorphOrNil keyboardFocusChange: true ]addTargetingMenuItems: aCustomMenu hand: aHandMorph  aCustomMenu addLine.  aCustomMenu add: 'set target' selector: #targetWith:.  target ifNotNil: [ aCustomMenu add: 'clear target' translated selector: #clearTarget ]potentialEmbeddingTargets  | oneUp topRend |  (oneUp := (topRend := self topRendererOrSelf) owner) ifNil: [ ^#() ].  ^(oneUp morphsAt: topRend referencePosition behind: topRend unlocked: true) reject: [:m |  m isFlexMorph ]updateIsNeeded  ^totalRepaint or: [ invalidRects notEmpty ]collapseAndRefresh  self collapse.  self refreshTablethemeChanged  super themeChanged.  toolbar themeChanged.  container     color: self theme lightBaseColor;     changed.  contentsWrapper     color: self theme lightBaseColor;     changeddoButtonAction: evt  target ifNil: [ ^self ].  actionSelector ifNil: [ ^self ].  Cursor normal showWhile: [ | moreArgs |        moreArgs := actionSelector numArgs > arguments size ifTrue: [ arguments copyWith: evt ] ifFalse: [ arguments ].        target perform: actionSelector withArguments: moreArgs ]transform: outerReferenceRectangle  | left right top bottom |  left := (outerReferenceRectangle left + (outerReferenceRectangle width * leftFraction) + leftOffset) rounded asInteger.  right := (outerReferenceRectangle right - (outerReferenceRectangle width * (1 - rightFraction)) + rightOffset) rounded asInteger.  top := (outerReferenceRectangle top + (outerReferenceRectangle height * topFraction) + topOffset) rounded asInteger.  bottom := (outerReferenceRectangle bottom - (outerReferenceRectangle height * (1 - bottomFraction)) + bottomOffset) rounded asInteger.  right < left ifTrue: [ right := left ].  bottom < top ifTrue: [ bottom := top ].  ^Rectangle left: left right: right top: top bottom: bottomdropMorphs: anEvent  self submorphsReverseDo: [:m |  self dropMorph: m event: anEvent ]setVertices: newVertices  vertices := newVertices.  handles ifNotNil: [ self           removeHandles;           addHandles ].  self computeBoundsacceptDroppingMorph: toDrop event: evt  complexContents acceptDroppingObject: toDrop complexContents.  toDrop delete.  self highlightForDrop: falsehatchForm  ^self class hatchFormrowHeight: rowIndex default: aNumber  ^self table dataSource rowHeight: rowIndextheme: aUITheme  self theme = aUITheme ifFalse: [ self setProperty: #theme toValue: aUITheme.        self themeChanged ]selectionChanged  self sharesFindReplace ifTrue: [ self editor findReplaceService changed: #findReplaceSelection ].  self useExtraSelection ifTrue: [ self refreshExtraSelection ].  super selectionChangednewHSVASelector: aColor help: helpText  ^self theme newHSVASelectorIn: self color: aColor help: helpTextsetCenterOfRotation: evt with: rotationHandle  | localPt |  evt hand obtainHalo: self.  evt hand showTemporaryCursor: nil.  (rotationHandle hasProperty: #dragByCenterOfRotation) ifFalse: [ localPt := innerTarget transformFromWorld globalPointToLocal: rotationHandle center.        innerTarget setRotationCenterFrom: localPt ].  rotationHandle removeProperty: #dragByCenterOfRotation.  self endInteractionselect: evt  self isEnabled ifFalse: [ ^self ].  ^super select: evtforwardDirection  | rendee |  ^(rendee := self renderedMorph) == self ifTrue: [ 0.0 ] ifFalse: [ ^rendee forwardDirection ]selectionChanged  self changedactivateAndForceLabelToShow  self activate.  bounds top < 0 ifTrue: [ self position: self position x @ 0 ]basicGetListElementSelector: aSymbol  getListElementSelector := aSymboltreeMorph: aTreeMorph pageSize: anInteger  self treeMorph: aTreeMorph.  self pageSize: anIntegerprivateDelete  owner ifNotNil: [ owner removeMorph: self ]removePaneSplitters  self splitters do: [:each |  each delete ]keyStroke: anEvent from: aTreeMorph  self selectedNode ifNotNil: [:current |  current keyStroke: anEvent from: aTreeMorph ]layoutLeftToRight: aMorph in: newBounds  | inset extent block posX posY centering extraPerCell amount minX minY maxX maxY n width extra last cell size height sum vFill first |  size := properties minCellSize asPoint.  minX := size x.  minY := size y.  size := properties maxCellSize asPoint.  maxX := size x.  maxY := size y.  inset := properties cellInset asPoint x.  extent := newBounds extent.  n := 0.  vFill := false.  sum := 0.  width := height := 0.  first := last := nil.  block := [:m |  | sizeY sizeX props |  props := m layoutProperties ifNil: [ m ].  props disableTableLayout ifFalse: [ n := n + 1.        cell := LayoutCell new target: m.        props hResizing == #spaceFill ifTrue: [ cell hSpaceFill: true.              extra := m spaceFillWeight.              cell extraSpace: extra.              sum := sum + extra ] ifFalse: [ cell hSpaceFill: false ].        props vResizing == #spaceFill ifTrue: [ vFill := true ].        size := m minExtent.        sizeX := size x.        sizeY := size y.        sizeX < minX ifTrue: [ sizeX := minX ] ifFalse: [ sizeX > maxX ifTrue: [ sizeX := maxX ] ].        sizeY < minY ifTrue: [ sizeY := minY ] ifFalse: [ sizeY > maxY ifTrue: [ sizeY := maxY ] ].        cell cellSize: sizeX.        last ifNil: [ first := cell ] ifNotNil: [ last nextCell: cell ].        last := cell.        width := width + sizeX.        sizeY > height ifTrue: [ height := sizeY ] ] ].  properties reverseTableCells ifTrue: [ aMorph submorphsReverseDo: block ] ifFalse: [ aMorph submorphsDo: block ].  n > 1 ifTrue: [ width := width + ((n - 1) * inset) ].  (properties hResizing == #shrinkWrap and: [ properties rubberBandCells or: [ sum isZero ] ]) ifTrue: [ extent := width @ (extent y max: height) ].  (properties vResizing == #shrinkWrap and: [ properties rubberBandCells or: [ vFill not ] ]) ifTrue: [ extent := (extent x max: width) @ height ].  posX := newBounds left.  posY := newBounds top.  extra := extent y - height.  extra < 0 ifTrue: [ extra := 0 ].  extra > 0 ifTrue: [ vFill ifTrue: [ height := extent y ] ifFalse: [ centering := properties wrapCentering.              centering == #bottomRight ifTrue: [ posY := posY + extra ].              centering == #center ifTrue: [ posY := posY + (extra // 2) ] ] ].  extra := extent x - width.  extra < 0 ifTrue: [ extra := 0 ].  extraPerCell := 0.  extra > 0 ifTrue: [ sum isZero ifTrue: [ centering := properties listCentering.              centering == #bottomRight ifTrue: [ posX := posX + extra ].              centering == #center ifTrue: [ posX := posX + (extra // 2) ] ] ifFalse: [ extraPerCell := extra asFloat / sum asFloat ] ].  n := 0.  extra := last := 0.  cell := first.  [ cell == nil ] whileFalse: [ n := n + 1.        width := cell cellSize.        (extraPerCell > 0 and: [ cell hSpaceFill ]) ifTrue: [ extra := (last := extra) + (extraPerCell * cell extraSpace).              amount := extra truncated - last truncated.              width := width + amount ].        cell target layoutInBounds: (posX @ posY extent: width @ height).        posX := posX + width + inset.        cell := cell nextCell ]newMultistateButton  ^self theme newMultistateButtonIn: selfslider  ^sliderwrapItem: anItem  ^self wrapBlockOrSelector isBlock ifTrue: [ wrapBlockOrSelector cull: anItem ] ifFalse: [ wrapBlockOrSelector isSymbol ifTrue: [ | numArgs |              numArgs := wrapBlockOrSelector numArgs.              numArgs isZero ifTrue: [ anItem perform: wrapBlockOrSelector ] ifFalse: [ numArgs = 1 ifTrue: [ anItem perform: wrapBlockOrSelector with: anItem ] ifFalse: [ self error: 'Wrong number of arguments' ] ] ] ifFalse: [ anItem ] ]rotationDegrees: degrees  | flex center |  (center := self valueOfProperty: #referencePosition) ifNil: [ self setProperty: #referencePosition toValue: (center := self bounds center) ].  flex := (MorphicTransform offset: center negated) withAngle: (degrees - self forwardDirection) degreesToRadians.  self setVertices: (vertices collect: [:v |  (flex transform: v) - flex offset ]).  self forwardDirection: degreescurrentCursor  ^worldState currentCursoractionMap: anObject  actionMap := anObjectborderWidth: bw  | newExtent |  newExtent := 2 * bw + image extent.  bounds extent = newExtent ifFalse: [ super extent: newExtent ].  super borderWidth: bwheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]newGroupbox: aString  ^self theme newGroupboxIn: self label: aStringchildren: aBlock  childrenBlock := aBlockdefaultColor  ^self theme windowColor lightericonFor: rowIndex  iconBlock ifNil: [ ^nil ].  ^iconBlock value: (self elementAt: rowIndex)generateButton  ^expanded ifTrue: [ self expandedButton ] ifFalse: [ self collapsedButton ]target: anObject  target := anObjectmatchesExtension: aExtension  (self extension isNil or: [ aExtension isNil ]) ifTrue: [ ^false ].  FileSystem disk isCaseSensitive ifTrue: [ ^extension = aExtension ] ifFalse: [ ^extension sameAs: aExtension ]updateAvailableRows: aNumber  availableRows := availableRows + aNumber.  aNumber isZero ifFalse: [ self tableRefresh ]drawOn: aCanvas  self drawTabOn: aCanvas.  self drawSubMorphOn: aCanvascommandKeyTypedIntoMenu: evt  ^self modifierKeyPressed: evtlistSpacing  | props |  props := self layoutProperties.  ^props ifNil: [ #none ] ifNotNil: [ props listSpacing ]colorForInsets  ^owner colorForInsetsreleaseCachedState  context  ^contextselectionFrameForRow: row  | frame |  frame := self drawBoundsForRow: row.  frame := frame intersect: self bounds.  frame := self bounds: frame in: listSource.  frame := self bounds: ((frame left: listSource innerBounds left) right: listSource innerBounds right) from: listSource.  ^framemouseOver: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseOver from: sourceMorphsetMultipleSelection: aBoolean  multipleSelection := aBooleaninitialize  enabled := true.  super initializescrollSelectionToRow: row  row = 0 ifTrue: [ ^self ].  self scrollToShow: (self listMorph drawBoundsForRow: row)startDrag: evt onItem: itemMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersmouseDown: evt  super mouseDown: evt.  self enabled ifFalse: [ ^self ].  self down: truewithTopSeparator  topSeparator := trueexpandAll  (self windowsSatisfying: [:w |  w isCollapsed ]) reverseDo: [:w |  w collapseOrExpand.        self displayWorld ]borderStyle: anObject  borderStyle := anObjectdrawOn: aCanvas  container withHLines ifTrue: [ aCanvas frameRectangle: self selectionFrame width: 1 colors: {Color veryLightGray .               Color transparent} dashes: #(1 2) ].  self hasToggle ifTrue: [ self drawToggleOn: aCanvas in: self toggleRectangle ].  container listManager isCheckList ifTrue: [ self drawCheckOn: aCanvas ]expandPath: anAssociation  anAssociation ifNil: [ ^false ].  ^anAssociation treeNodeHead = self complexContents withoutListWrapper ifFalse: [ false ] ifTrue: [ anAssociation treeNodeTail ifNil: [ ^true ].        (self isExpanded not and: [ self canExpand ]) ifTrue: [ self toggleExpandedState.              container innerWidgetChanged ].        self children anySatisfy: [:child |  child expandPath: anAssociation treeNodeTail ] ]opacityString  ^self isOpaque -> 'opaque' translatedmouseDown: evt  ^evt shiftPressed ifTrue: [ ((owner isKindOf: PolygonMorph) and: [ owner includesHandle: self ]) ifTrue: [ ^super mouseDown: evt ].        self toggleHandles.        handles ifNil: [ ^self ].        vertices withIndexDo: [:vertPt :vertIndex |  ((handles at: vertIndex * 2 - 1 ifAbsent: [ ^self ]) containsPoint: evt cursorPoint) ifTrue: [ evt hand newMouseFocus: (handles at: vertIndex * 2 - 1) ] ] ] ifFalse: [ super mouseDown: evt ]defer: aValuable  self owner ifNotNil: [ self owner defer: aValuable ] ifNil: [ UIManager default defer: aValuable ]getSelector: aSelector  self objectToView: objectToView viewSelector: aSelectorproperty: aString  property := aStringreleaseKeyboardFocus  self newKeyboardFocus: nilcomputeInsetColors  | base light dark w colorArray param hw |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  colorArray := Array new: w * 2.  hw := 0.5 / w.  0 to: w - 1 do: [:i |  param := true ifTrue: [ 0.5 + (hw * i) ] ifFalse: [ 0.5 + (hw * (w - i)) ].        colorArray at: i + 1 put: (base mixed: param with: dark).        colorArray at: colorArray size - i put: (base mixed: param with: light) ].  ^colorArraysortElements: aSortFunction  self subclassResponsibilityaddMorph: aMorph fullFrame: aLayoutFrame  | left right bottom top windowBorderWidth frame |  frame := aLayoutFrame asLayoutFrame.  windowBorderWidth := self class borderWidth.  left := frame leftOffset.  right := frame rightOffset.  bottom := frame bottomOffset.  top := frame topOffset.  frame rightFraction = 1 ifTrue: [ frame rightOffset: right - windowBorderWidth - self theme windowRightOffset ].  frame leftFraction = 0 ifTrue: [ frame leftOffset: left + windowBorderWidth + self theme windowLeftOffset ] ifFalse: [ frame leftFraction = 1 ifFalse: [ frame leftOffset: left + ProportionalSplitterMorph splitterWidth ] ].  frame bottomFraction = 1 ifTrue: [ frame bottomOffset: bottom - windowBorderWidth - self theme windowBottomOffset ].  frame topFraction = 0 ifTrue: [ frame topOffset: top + self theme windowTopOffset ] ifFalse: [ frame topFraction = 1 ifFalse: [ frame topOffset: top + ProportionalSplitterMorph splitterWidth ] ].  super addMorph: aMorph fullFrame: frame.  paneMorphs := paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).  aMorph borderStyle: (self theme windowPaneBorderStyleFor: aMorph in: self).  self addMorphBack: aMorph.  self owner ifNotNil: [ self addPaneSplitters ]updateForNewPageSize: aPageSize  pageSize := aPageSize max: 1.  self changed: #pageSizetargetPoint  ^self position - targetOffsetthemeChanged  self color: self defaultColor.  super themeChangedavoidsOcclusions: aBoolean  avoidsOcclusions := aBoolean.  self releaseCachedStateosWindow  ^niltab  ^tabnavigateVisibleWindowForward  self nextVisibleWindow ifNil: [ SystemWindow passivateTopWindow ] ifNotNil: [:m |  m activate ]naturalCubicSlopesOf: knots  | x gamma delta D n1 |  n1 := knots size.  n1 < 3 ifTrue: [ self error: 'Less than 3 points makes a poor curve' ].  x := knots.  gamma := Array new: n1.  delta := Array new: n1.  D := Array new: n1.  gamma at: 1 put: 1.0 / 2.0.  2 to: n1 - 1 do: [:i |  gamma at: i put: 1.0 / (4.0 - (gamma at: i - 1)) ].  gamma at: n1 put: 1.0 / (2.0 - (gamma at: n1 - 1)).  delta at: 1 put: 3.0 * ((x at: 2) - (x at: 1)) * (gamma at: 1).  2 to: n1 - 1 do: [:i |  delta at: i put: (3.0 * ((x at: i + 1) - (x at: i - 1)) - (delta at: i - 1)) * (gamma at: i) ].  delta at: n1 put: (3.0 * ((x at: n1) - (x at: n1 - 1)) - (delta at: n1 - 1)) * (gamma at: n1).  D at: n1 put: (delta at: n1).  (1 to: n1 - 1) reverseDo: [:i |  D at: i put: (delta at: i) - ((gamma at: i) * (D at: i + 1)) ].  ^Dcontents  getContentsSelector ifNil: [ ^#() ].  ^self sendToModel: getContentsSelectordrawText: aStringOrText onAthensCanvas: aCanvas in: aRectangle color: stringColor  | wrapper |  wrapper := aCanvas asCanvasWrapper.  (self enabled not and: [ self theme disabledItemStyle = #inset ]) ifTrue: [ wrapper           drawString: aStringOrText in: aRectangle font: self fontToUse color: stringColor muchLighter lighter;           drawString: aStringOrText in: (aRectangle translateBy: -1) font: self fontToUse color: stringColor ] ifFalse: [ wrapper drawString: aStringOrText in: aRectangle font: self fontToUse color: stringColor ]morph  ^morphnewBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum help: helpText  ^self newBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: nil help: helpTextlistCentering: aSymbol  listCentering := aSymbolhasFocus  ^editor notNilbeResizable  resizable := truenewAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText entryCompletion: anEntryCompletionisIndexVisible: anIndex  ^self container isRowIndexVisible: anIndexforLinesIn: aVisibleRect do: aBlock  (self lineIndexForPoint: aVisibleRect topLeft) to: (self lineIndexForPoint: aVisibleRect bottomRight) do: [:i |  aBlock value: (lines at: i) ]alwaysShowVScrollBar: bool  self setProperty: #vScrollBarAlways toValue: bool.  self vHideOrShowScrollBarsetValue: newValue  ^self perform: #setValue: withArguments: {newValue} inSuperclass: SlideraddPage: aMorph label: aStringOrMorph  aMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  self pages add: aMorph.  self tabSelectorMorph addTab: aStringOrMorphupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]layoutInset  ^0update: aParameter  (aParameter == getListSelector or: [ aParameter == getListElementSelector ]) ifTrue: [ self updateList.        ^self ].  aParameter == getIndexSelector ifTrue: [ self selectionIndex: self getCurrentSelectionIndex.        ^self ].  aParameter == #allSelections ifTrue: [ self selectionIndex: self getCurrentSelectionIndex.        ^self changed ].  aParameter isArray ifFalse: [ ^self ].  aParameter size == 2 ifFalse: [ ^self ].  aParameter first = #setMultipleSelection: ifTrue: [ self setMultipleSelection: aParameter second ]rightFlush  textStyle rightFlushhandlerForBlueButtonDown: anEvent  ^selfsetInvokingView: invokingView  self items do: [:item |  item hasSubMenu ifTrue: [ item subMenu setInvokingView: invokingView ] ifFalse: [ item arguments isEmptyOrNil ifTrue: [ item arguments: (Array with: item selector with: invokingView).                    item selector: #perform:orSendTo: ] ] ]tabSelected: aTab  self isMultiSelection ifTrue: [ self tabResetSelection: aTab ] ifFalse: [ self selectedTab ifNotNil: [ self selectedTab selected: false ].        self addInHistory: aTab.        self adjustLayout.        self triggerEvent: #tabSelected with: aTab ]initialize  super initialize.  self     changeTableLayout;     listDirection: #leftToRight;     cellPositioning: #center;     cellInset: 2;     borderWidth: 0;     color: Color transparent;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     extent: 20 @ 16noteNewOwner: aMorph  super noteNewOwner: aMorph.  self submorphs do: [:each |  each adjustLayoutBounds ]alignRightEdges  | maxRight |  maxRight := (selectedItems collect: [:itm |  itm right ]) max.  selectedItems do: [:itm |  itm right: maxRight ].  self changedhExtraScrollRange  ^12openDialogOn: aClass  rootClass := aClass.  ^self openDialogWindowIn: self currentWorld title: 'All Object subclasses'drawSubmenuMarkerOn: aCanvas  delete  activeSubMenu ifNotNil: [ activeSubMenu delete ].  ^super deleterefreshTable  dataSource tableRefresh.  dataSource table resetFunctiongetEnabledSelector  ^getEnabledSelector ifNil: [ nil ]drawOn: aCanvas  aCanvas fillRectangle: self bounds fillStyle: self fillStyle borderStyle: self borderStyle.  (self cachedForm width = 0 or: [ self cachedForm height = 0 ]) ifTrue: [ ^self ].  self layout == #tiled ifTrue: [ aCanvas fillRectangle: self innerBounds fillStyle: (AlphaInfiniteForm with: self cachedForm) ] ifFalse: [ aCanvas clipBy: self innerBounds during: [:c |  c translucentImage: self cachedForm at: self layoutPosition ] ]setUp  super setUp.  morph := Morph newnewYesButton  ^self newYesButtonFor: selfhandleMouseMove: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (anEvent anyButtonPressed and: [ anEvent hand mouseFocus == self ]) ifFalse: [ ^self ].  anEvent wasHandled: true.  self mouseMove: anEvent.  (self handlesMouseStillDown: anEvent) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue arguments: {anEvent copy resetHandlerFields} stepTime: 1 ]removeGrips  self     removeCornerGrips;     removeEdgeGripsrootItem  ^rootItemlocalSubmorphBounds  localBounds ifNil: [ self submorphsDo: [:m |  localBounds ifNil: [ localBounds := m fullBounds ] ifNotNil: [ localBounds := localBounds quickMerge: m fullBounds ] ] ].  ^localBoundsnewBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum help: helpText  ^self newBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: nil help: helpTextserverMode  ^self class serverModehandlesMouseWheel: evt  ^falseopenAsIs  self openAsIsIn: self currentWorldscrollPoint: event  | r p |  r := self roomToMove.  bounds isWide ifTrue: [ r width = 0 ifTrue: [ ^self ] ] ifFalse: [ r height = 0 ifTrue: [ ^self ] ].  p := event position - (self sliderThickness // 2) adhereTo: r.  self descending ifFalse: [ self setValue: (bounds isWide ifTrue: [ (p x - r left) asFloat / r width ] ifFalse: [ (p y - r top) asFloat / r height ]) ] ifTrue: [ self setValue: (bounds isWide ifTrue: [ (r right - p x) asFloat / r width ] ifFalse: [ (r bottom - p y) asFloat / r height ]) ]startGap: aPoint  startGap := aPointkeyStrokeArrowRight: event  (self selectionModeStrategy is: self selectedIndex beforeColumn: self numberOfColumns) ifFalse: [ ^self ].  self resetFunction.  self selectIndex: (self selectionModeStrategy selectableIndexAfter: self selectedIndex) event: eventhandleMouseMove: anEvent  anEvent wasHandled ifTrue: [ ^self ].  anEvent hand hasSubmorphs ifTrue: [ ^self ].  anEvent wasHandled: true.  self mouseMove: anEvent.  (anEvent anyButtonPressed and: [ anEvent hand mouseFocus == self ]) ifFalse: [ ^self ].  (self handlesMouseStillDown: anEvent) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue arguments: {anEvent copy resetHandlerFields} stepTime: 1 ]heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]printOn: aStream  super printOn: aStream.  aStream     space;     print: firstIndex;     nextPutAll: ' to: ';     print: lastIndexextraScrollRange  ^self scrollDeltaHeightboxExtent  ^18 @ 18 * self displayScaleFactorisComposite  ^truestoreValue  ^storeValuetestIsBeforeColumn  self assert: (strategy is: #(3 7) beforeColumn: 9).  self deny: (strategy is: #(3 7) beforeColumn: 4).  self deny: (strategy is: #(3 7) beforeColumn: 7)newListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: enabledSel help: helpText  ^self theme newListIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: enabledSel help: helpTexthandleListenEvent: evt  evt isMouse ifFalse: [ ^self ].  evt hand hasSubmorphs ifTrue: [ ^self ].  self isTopWindow ifFalse: [ self lockInactivePortions ].  evt hand removeMouseListener: selfselectedTab  ^self tabSelectorMorph selectedTabreverseTableCells  | props |  props := self layoutProperties.  ^props ifNil: [ false ] ifNotNil: [ props reverseTableCells ]cornerStyle: anObject  cornerStyle := anObjectbottomRightColor  ^width = 1 ifTrue: [ self color twiceDarker ] ifFalse: [ self color darker ]visibleTabs  ^self tabs select: [:t |  t owner notNil ]initialize  super initialize.  indentLevel := 0.  isExpanded := falsenewLabelGroup: labelsAndControls  ^self theme newLabelGroupIn: self for: labelsAndControlscellColumn: column row: rowIndex  | cell |  cell := FTCellMorph new     addMorphBack: (self elementAt: rowIndex) asMorph;     yourself.  (self needSeparatorBefore: rowIndex) ifTrue: [ cell withTopSeparator ].  ^celllabelOfSize: labSize  ^self theme buttonLabelForText: (self model taskbarLabel truncateWithElipsisTo: labSize)changeDirectionHandles  ^self wantsDirectionHandles: self wantsDirectionHandles notrootClass  ^rootClass ifNil: [ rootClass := Object ]currentIcon  ^TabMorph perform: (#refreshIcon , progress asString) asSymbolis: anIndex beforeColumn: aColumn  ^falseaddLabelItemsTo: aCustomMenu hand: aHandMorph  privateAddAllMorphs: aCollection atIndex: index  submorphs := Array new: submorphs size + aCollection size streamContents: [:str |  1 to: index do: [:p |  str nextPut: (submorphs atWrap: p) ].        str nextPutAll: aCollection.        index + 1 to: submorphs size do: [:p |  str nextPut: (submorphs atWrap: p) ] ].  aCollection do: [:m |  m fullBounds.        m privateOwner: self ].  self layoutChangedgrabTransform  ^owner ifNil: [ self transform ] ifNotNil: [ owner grabTransform composedWithLocal: self transform ]is: anIndex beforeColumn: aColumn  ^self subclassResponsibilityinsertNewMorphs: morphList  morphList do: [:m |  m           font: self font;           extent: m minWidth @ m minHeight ].  ^super insertNewMorphs: morphListmeasureContents  ^super measureContents + 2asKeyCombination  ^KMKeyCombination fromKeyboardEvent: selfbeReplacementFor: aMorph  | itsWorld priorPosition |  (itsWorld := aMorph world) ifNil: [ ^self ].  uncollapsedMorph := aMorph.  self setLabel: aMorph externalName.  aMorph delete.  itsWorld addMorphFront: self.  self collapseOrExpand.  (priorPosition := aMorph valueOfProperty: #collapsedPosition ifAbsent: [ nil ]) ifNotNil: [ self position: priorPosition ]beCenter  self option: #centershowBalloon: msgString  | w |  self showBalloon: msgString hand: ((w := self world) ifNotNil: [ w activeHand ])hash  ^super hash bitXor: self borders hashembedInWindow  | window worldToUse |  worldToUse := self world.  window := (SystemWindow labelled: self defaultLabel) model: nil.  window bounds: (self position - (0 @ window labelHeight + window borderWidth) corner: self bottomRight + window borderWidth).  window addMorph: self frame: (0 @ 0 extent: 1 @ 1).  window updatePaneColors.  worldToUse addMorph: window.  window activatebottomLeft: aPoint  self position: aPoint x @ (aPoint y - self height)action: aBlockClosure named: aString  actionBlock := aBlockClosure.  self initializeActionButtonNamed: aStringlistSource: aListSource  listSource := aListSource.  self listChangedsetCharacters: chars  self getCharacters = chars ifFalse: [ self newContents: chars ]gtInspectorIcon  ^self class systemIconlineWidth  ^self borderWidthtextMorph  ^textMorphseasideMimeDocument  ^self imageForm seasideMimeDocumentbeginsWith: aString fromList: aMorph  | string |  string := self userString ifNil: [ (self submorphs collect: [:m |  m userString ]) detect: [:us |  us notNil ] ifNone: [ '' ] ].  ^string asString beginsWith: aString fromList: aMorphselectableIndexBellow: anIndex  ^self subclassResponsibilityicon  ^model iconOfNode: selfshouldBeHighlighted  ^isSelected and: [ isEnabled ]previousMorphInWindow  ^self submorphBefore notNil ifTrue: [ self submorphBefore lastSubmorphRecursive ] ifFalse: [ self owner ]removeVertex: aVert  | newVertices |  vertices size < 2 ifTrue: [ ^self ].  newVertices := vertices copyWithout: aVert.  newVertices size caseOf: {([ 1 ] -> [ newVertices := {newVertices first .               newVertices first} ]) .         ([ 0 ] -> [ newVertices := {aVert .               aVert} ])} otherwise: [  ].  self setVertices: newVerticespreviousMorphInWindow  ^self hasSubmorphs ifTrue: [ self lastSubmorphRecursive ]hasNoLayoutString  ^self layoutPolicy isNil -> 'no layout' translatedcopyWeakly  ^#(formerOwner)computeShadow  | canvas bounds theText |  bounds := self bounds.  theText := textMorph.  canvas := (Display defaultCanvasClass extent: bounds extent depth: 1) asShadowDrawingCanvas: Color black.  canvas translateBy: bounds topLeft negated during: [:tempCanvas |  | back |        self fillsOwner ifTrue: [ tempCanvas fullDrawMorph: (theText owner copyWithoutSubmorph: theText) ] ifFalse: [ tempCanvas fillRectangle: textMorph bounds color: Color black ].        self avoidsOcclusions ifTrue: [ back := tempCanvas form deepCopy.              tempCanvas form fillWhite.              theText owner submorphsInFrontOf: theText do: [:m |  (textMorph isLinkedTo: m) ifTrue: [  ] ifFalse: [ tempCanvas fullDrawMorph: m ] ].              back displayOn: tempCanvas form at: 0 @ 0 rule: Form reverse ] ].  shadowForm := canvas form offset: bounds topLeft.  vertProfile := shadowForm yTallyPixelValue: 1 orNot: false.  rectangleCache := Dictionary new.  ^shadowFormsortDataSource: aDataSource  (aDataSource table columns copyWithout: self) do: #resetSorting.  self sortingStrategy sortDataSource: aDataSourcerelabel  | newLabel |  newLabel := UIManager default request: 'New title for this window' translated initialAnswer: labelString.  newLabel isEmptyOrNil ifTrue: [ ^self ].  self setLabel: newLabelfollowHand: aHand forEachPointDo: block1 lastPointDo: block2 withCursor: aCursor  hand := aHand.  hand showTemporaryCursor: aCursor.  borderWidth := 0.  color := Color transparent.  pointBlock := block1.  lastPointBlock := block2.  self position: hand lastEvent cursorPoint - (self extent // 2)boundsForBalloon  container ifNil: [ ^super boundsForBalloon ].  ^self boundsInWorld intersect: container boundsInWorld ifNone: [ self boundsInWorld ]enableFilterWithAction: aBlock  self enableFilterWithAction: aBlock named: 'Validate.'source: anObject  source := anObjectdrawOn: aCanvas  temporaryCursor ifNil: [ aCanvas paintImage: NormalCursor at: bounds topLeft ] ifNotNil: [ aCanvas paintImage: temporaryCursor at: bounds topLeft ]tearDown  morph := nil.  super tearDownnewRadioButtonFor: aModel getSelected: getSel setSelected: setSel label: stringOrText help: helpText  ^self newRadioButtonFor: aModel getSelected: getSel setSelected: setSel getEnabled: nil label: stringOrText help: helpTextremoveMouseListener: anObject  self mouseListeners: (self removeListener: anObject from: self mouseListeners)isExpanded  ^isExpandedavoidVisibleBordersAtEdge  ^avoidVisibleBordersAtEdgearrows  ^arrowscomputeCellArrangement: cellHolder in: newBounds horizontal: aBool target: aMorph  | cells wrap spacing output maxExtent n sum index max cell first last w cellMax maxCell hFill vFill inset |  maxCell := cellHolder key.  cells := cellHolder value.  properties wrapDirection == #none ifTrue: [ wrap := SmallInteger maxVal ] ifFalse: [ wrap := aBool ifTrue: [ newBounds width ] ifFalse: [ newBounds height ].        wrap < maxCell x ifTrue: [ wrap := maxCell x ] ].  spacing := properties cellSpacing.  (spacing == #globalRect or: [ spacing = #globalSquare ]) ifTrue: [ ^self computeGlobalCellArrangement: cells in: newBounds horizontal: aBool wrap: wrap spacing: spacing ].  output := Array new writeStream.  inset := properties cellInset asPoint.  aBool ifFalse: [ inset := inset transposed ].  first := last := nil.  maxExtent := 0 @ 0.  sum := 0.  index := 1.  n := 0.  hFill := vFill := false.  [ index <= cells size ] whileTrue: [ w := sum.        cell := cells at: index.        cellMax := maxExtent max: cell cellSize.        (spacing == #localRect or: [ spacing == #localSquare ]) ifTrue: [ spacing == #localSquare ifTrue: [ max := cellMax x max: cellMax y ] ifFalse: [ max := cellMax x ].              sum := (n + 1) * max ] ifFalse: [ sum := sum + cell cellSize x ].        (sum + (n * inset x) > wrap and: [ first notNil ]) ifTrue: [ (spacing == #localSquare or: [ spacing == #localRect ]) ifTrue: [ spacing == #localSquare ifTrue: [ maxExtent := (maxExtent x max: maxExtent y) asPoint ].                    first do: [:c |  c cellSize: maxExtent ] ].              w := w + ((n - 1) * inset x).              first nextCell ifNotNil: [ first nextCell do: [:c |  c addExtraSpace: inset x @ 0 ] ].              last := LayoutCell new.              last cellSize: w @ maxExtent y.              last hSpaceFill: hFill.              last vSpaceFill: vFill.              last nextCell: first.              output position = 0 ifFalse: [ last addExtraSpace: 0 @ inset y ].              output nextPut: last.              first := nil.              maxExtent := 0 @ 0.              sum := 0.              n := 0.              hFill := vFill := false ] ifFalse: [ first ifNil: [ first := last := cell ] ifNotNil: [ last nextCell: cell.                    last := cell ].              index := index + 1.              n := n + 1.              maxExtent := cellMax.              hFill := hFill or: [ cell hSpaceFill ].              vFill := vFill or: [ cell vSpaceFill ] ] ].  first ifNotNil: [ last := LayoutCell new.        sum := sum + ((n - 1) * inset x).        first nextCell ifNotNil: [ first nextCell do: [:c |  c addExtraSpace: inset x @ 0 ] ].        last cellSize: sum @ maxExtent y.        last hSpaceFill: hFill.        last vSpaceFill: vFill.        last nextCell: first.        output position = 0 ifFalse: [ last addExtraSpace: 0 @ inset y ].        output nextPut: last ].  output := output contents.  properties listSpacing == #equal ifTrue: [ max := output inject: 0 into: [:size :c |  size max: c cellSize y ].        output do: [:c |  c cellSize: c cellSize x @ max ] ].  ^outputpressedImage  ^pressedImagemouseMove: evt  | thePoint |  thePoint := target point: evt position - positionOffset from: owner.  target setConstrainedPosition: thePoint hangOut: truedataSource  ^dataSourceactualClass  ^FTDescendingSortingStateshowsWhenNeeded  ^self showState == #whenNeededokToChange  ^self tabGroup pages allSatisfy: [:each |  each model okToChange ]parent  ^parenthasFocus  ^falsehandlesKeyboard: evt  ^trueenabled  ^super enabled and: [ self isLocked not ]minHeight  ^self fontToUse height rounded max: super minHeightadd: wordingString icon: aForm subMenu: aMenuMorph  ^self add: wordingString icon: aForm help: nil subMenu: aMenuMorphnewButtonFor: aModel action: actionSel label: stringOrText help: helpText  ^self newButtonFor: aModel getState: nil action: actionSel arguments: nil getEnabled: nil label: stringOrText help: helpTextsetSelectedSelector  ^setSelectionSelectornewRow: controls  ^self theme newRowIn: self for: controlsnewToolbarHandle  ^self theme newToolbarHandleIn: selfmouseEnter: anEvent  self canResizeColumn ifFalse: [ ^self ].  (owner notNil and: [ owner bounds containsPoint: anEvent position ]) ifTrue: [ super mouseEnter: anEvent ]hResizingString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self hResizingisSortingEnabled  ^trueupdate: aSymbol  aSymbol == self getColorSelector ifTrue: [ self updateColor.        ^self ]isResizeable  ^isResizeable ifNil: [ isResizeable := self defaultIsResizeable ]mouseMove: evt  | targetMorph |  self enabled ifFalse: [ ^self ].  targetMorph := self scrollerSubMorphFromPoint: evt position.  evt hand hasSubmorphs ifFalse: [ (self innerBounds containsPoint: evt position) ifTrue: [ self listManager mouseMove: evt on: targetMorph ] ].  (self dropEnabled and: [ evt hand hasSubmorphs ]) ifFalse: [ ^super mouseMove: evt ].  potentialDropMorph ifNotNil: [ (potentialDropMorph containsPoint: (potentialDropMorph point: evt position from: self)) ifTrue: [ ^self ] ].  self mouseLeaveDragging: evt.  (self containsPoint: evt position) ifTrue: [ self mouseEnterDragging: evt ]recalculateVerticalScrollBarVisibilityIfHidden: aBlock  self container calculateExactVisibleRows >= self dataSource numberOfRows ifTrue: [ self isVerticalScrollBarVisible ifTrue: [ self removeMorph: self verticalScrollBar ].        self resizeContainer.        aBlock value ] ifFalse: [ self isVerticalScrollBarVisible ifFalse: [ self resizeVerticalScrollBar.              self addMorph: self verticalScrollBar ] ]initializeFromStringMorph: aStringMorph  fontNumber := 1.  self setActualFont: (aStringMorph font ifNil: [ TextStyle defaultFont ]).  emphasis := actualFont emphasis.  textColor := aStringMorph coloropenFullscreen  ^FullscreenMorph new     setContentMorph: self;     openInWorlddefaultIsResizeable  ^truetasks: anObject  tasks := anObjectdrawMouseDownHighlightOn: aCanvas  self highlightedForMouseDown ifTrue: [ container ifNil: [ ^super drawMouseDownHighlightOn: aCanvas ].        self storeValue ifNil: [ self storeValue: self complexContents selected not ].        self complexContents selected: self storeValue.        aCanvas frameRectangle: self selectionFrame width: 1 colors: {container mouseDownHighlightColor .               Color transparent} dashes: #(1 1) ]unrotatedLength  vertices size = 2 ifTrue: [ ^(vertices second - vertices first) r ].  ^((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) heightisModalInvokationDone  ^self valueOfProperty: #isModalInvokationDone ifAbsent: [ false ]griddingOnOff  griddingOn := self griddingOn not.  self changedselected  ^selected ifNil: [ selected := false ]newString: aStringOrText  ^self theme newStringIn: self label: aStringOrText font: self theme labelFont style: #plainmenuButtonWidth  ^16 * self displayScaleFactorinitialize  leftOffset := rightOffset := topOffset := bottomOffset := 0.  leftFraction := topFraction := 0.  rightFraction := bottomFraction := 1level  ^parentNode ifNil: [ 1 ] ifNotNil: [ parentNode level + 1 ]worldRenderer: anObject  worldRenderer := anObject.  worldRenderer activateborderRaised  self borderStyle: (BorderStyle raised width: 2)extraSpaceForActions  | space offsets |  space := 0.  offsets := 1.  self hasMenu ifTrue: [ offsets := offsets + 1.        space := space + self menuIcon width ].  self actions do: [:each |  space := space + each icon width.        offsets := offsets + 1 ].  ^space + (offsets * self actionOffset)keyCharacter  ^Unicode value: charCodefindSubmorphFor: ptY  ^scroller submorphThat: [:item |  ptY between: item top and: item bottom ] ifNone: [  ]fullBounds  | bnds |  bnds := super fullBounds.  submorphs isEmpty ifTrue: [ ^bnds ] ifFalse: [ ^bnds topLeft corner: bnds bottomRight + self shadowOffset ]drawOnAthensCanvas: aCanvas  | pc |  pc := self owner ifNil: [ self paneColor ] ifNotNil: [ self owner color isTransparent ifTrue: [ self owner paneColor ] ifFalse: [ self owner color ] ].  aCanvas clipBy: self bounds during: [ aCanvas pathTransform restoreAfter: [ aCanvas pathTransform translateX: self left Y: self top + self fontToUse ascent.              aCanvas                 setFont: self fontToUse;                 setPaint: (self enabled ifTrue: [ self color ] ifFalse: [ pc muchDarker ]);                 drawString: self contents ] ]handleKeystroke: anEvent  anEvent wasHandled ifTrue: [ ^self ].  self allowsKeymapping ifTrue: [ self dispatchKeystrokeForEvent: anEvent ].  anEvent wasHandled ifTrue: [ ^self ].  (self handlesKeyStroke: anEvent) ifFalse: [ ^self ].  self keyStroke: anEvent.  anEvent wasHandled: trueisActive  ^falseaddSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean  | priorMorph morphList newCollection |  priorMorph := nil.  newCollection := (sortBoolean and: [ sortingSelector notNil ]) ifTrue: [ (aCollection asSortedCollection: [:a :b |  (a perform: sortingSelector) <= (b perform: sortingSelector) ]) asOrderedCollection ] ifFalse: [ aCollection ].  morphList := OrderedCollection new.  newCollection do: [:item |  priorMorph := self indentingItemClass basicNew initWithContents: item prior: priorMorph forList: self indentLevel: parentMorph indentLevel + 1.        morphList add: priorMorph ].  scroller addAllMorphs: morphList after: parentMorph.  ^morphListnoteRemovalOfAll: aCollection  self listManager noteRemovalOfAll: aCollection.  aCollection do: [:each |  each delete ].  scroller removeAllMorphsIn: aCollection.  self adjustSubmorphPositionswidth  ^textMorph owner widthsentTo: anObject  type == #keystroke ifTrue: [ ^anObject handleKeystroke: self ].  type == #keyDown ifTrue: [ ^anObject handleKeyDown: self ].  type == #keyUp ifTrue: [ ^anObject handleKeyUp: self ].  ^super sentTo: anObjectinitialize  super initialize.  growingOrRotating := false.  self borderStyle: (SimpleBorder width: 2 color: self theme menuSelectionColor)drawOn: aCanvas  | text paragraph keyBounds keyFont |  text := self text.  keyFont := self class symbolFont.  keyBounds := self boundsForKeyText: text string font: keyFont.  paragraph := Paragraph new     compose: text style: (TextStyle fontArray: {keyFont}) from: 1 in: (0 @ 0 corner: keyBounds corner);     yourself.  aCanvas paragraph: paragraph bounds: keyBounds color: self colorhideOverEditableTextCursor  self currentHand showTemporaryCursor: nilupdateSelectionIndex  self basicUpdateSelectionIndex.  self refreshisTranslucentButNotTransparent  backgroundColor ifNil: [ ^true ].  (backgroundColor isColor and: [ backgroundColor isTranslucentButNotTransparent ]) ifTrue: [ ^true ].  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) ifTrue: [ ^true ].  ^falsesortableOnProperty: aProperty  self sortingStrategy: (FTPropertyColumnSortingStrategy column: self property: aProperty)drawOnAthensCanvas: anAthensCanvas  submorphs isEmpty ifTrue: [ super drawOnAthensCanvas: anAthensCanvas ]mouseLeaveDragging: anEvent  (self dragEnabled or: [ anEvent hand hasSubmorphs ]) ifFalse: [ self listMorph mouseDownRow: nil ].  (self dropEnabled and: [ anEvent hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: anEvent ].  self resetPotentialDropRow.  anEvent hand releaseMouseFocus: selfnoMorePotentialDropTarget  isPotentialDropTarget := false.  self container invalidRect: self visibleBoundsactiveTitleFillStyle  ^self theme windowActiveTitleFillStyleFor: selfrootItemsTest  ^rootClass allSubclasses asArray sort: [:a :b |  a name < b name ]asString  string ifNotNil: [ ^string ].  getStringSelector ifNil: [ ^super asString ].  ^self sendToModel: getStringSelectorstayUp: aBoolean  stayUp := aBoolean.  titleMorph ifNotNil: [ titleMorph updatePinForm ]enabled  ^enabledchunkSize: aPageSize  self pager ifNil: [ aPageSize ifNotNil: [ self addNavigationPane: (MorphTreeChunkPager on: self pageSize: aPageSize) ] ] ifNotNil: [ aPageSize ifNil: [ self removePager ] ifNotNil: [ self pager changePageSize: aPageSize ] ]acceptOnCR  ^falseselectedMorph: aMorph  self unhighlightSelection.  selectedMorph := aMorph.  self highlightSelectionballoonText  ^model balloonTextForNode: selflayout: aMorph in: layoutBounds  | props spare extra height inset newBounds minExt fillCount x width |  aMorph submorphs ifEmpty: [ ^self ].  props := aMorph assureTableProperties.  minExt := aMorph minWidth @ aMorph minHeight - aMorph extent + aMorph layoutBounds extent max: 0 @ 0.  newBounds := layoutBounds origin extent: (layoutBounds extent max: minExt).  width := 0.  width := (self minExtentOf: aMorph in: newBounds) x.  spare := newBounds width - width max: 0.  fillCount := 0.  spare > 0 ifTrue: [ fillCount := aMorph submorphs inject: 0 into: [:tot :m |  tot + (m hResizing == #spaceFill ifTrue: [ 1 ] ifFalse: [ 0 ]) ].        extra := fillCount = 0 ifTrue: [ 0 ] ifFalse: [ spare // fillCount ].        spare := spare - ((fillCount - 1) * extra) ] ifFalse: [ extra := 0 ].  x := fillCount > 0 ifTrue: [ newBounds left ] ifFalse: [ props listCentering == #center ifTrue: [ newBounds center x - (width // 2) ] ifFalse: [ props listCentering == #bottomRight ifTrue: [ newBounds right - width ] ifFalse: [ newBounds left ] ] ].  height := newBounds height.  inset := props cellInset isPoint ifTrue: [ props cellInset x ] ifFalse: [ props cellInset ].  aMorph submorphs with: cachedMinExtents do: [:m :ext |  | pos vr box cell |        width := m hResizing == #spaceFill ifTrue: [ fillCount := fillCount - 1.              ext x + (fillCount > 0 ifTrue: [ spare ] ifFalse: [ extra ]) ] ifFalse: [ ext x ].        cell := x @ newBounds top extent: width @ height.        ((vr := m vResizing) == #shrinkWrap or: [ m bounds ~= cell ]) ifTrue: [ ((vr == #shrinkWrap) not and: [ m extent = cell extent ]) ifTrue: [ m position: cell origin ] ifFalse: [ box := m bounds.                    m hResizing == #spaceFill ifTrue: [ box := cell origin extent: cell width @ box height ].                    vr == #spaceFill ifTrue: [ box := box origin extent: box width @ cell height ].                    vr == #shrinkWrap ifTrue: [ box := box origin extent: box width @ ext y ].                    pos := props cellPositioning.                    box := box align: (box perform: pos) with: (cell perform: pos).                    m bounds: box ] ].        x := x + width + inset ]addActions: aCollection  actions addAll: aCollectionsendFocusEvent: anEvent to: focusHolder clear: aBlock  | result w |  w := focusHolder world ifNil: [ ^aBlock value ].  w becomeActiveDuring: [ ActiveHand := self.        ActiveEvent := anEvent.        result := focusHolder handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ].  ^resultkeyStroke: anEvent from: aTreeMorph  | c |  c := anEvent keyCharacter.  c = $b ifTrue: [ self browseItem.        ^true ].  c = $i ifTrue: [ self inspectItem.        ^true ].  c = $I ifTrue: [ self exploreItem.        ^true ].  ^falsecaptureEventsWhile: aBlock  ^self captureEventsUntil: [:evt |  (aBlock value: evt) not ]sortingStrategy  ^sortingStrategyabort: aStringOrText title: aString  ^self theme abortIn: self text: aStringOrText title: aStringprintOn: aStream  super printOn: aStream.  aStream     nextPut: $[;     nextPutAll: (self dataSource toString: data);     nextPut: $]slide: delta  firstIndex := firstIndex + delta.  lastIndex := lastIndex + deltainitialize  super initialize.  labelClickable := true.  self     borderWidth: 2;     borderColor: Color transparent;     enabled: true;     changeTableLayout;     listDirection: #leftToRight;     wrapCentering: #center;     cellInset: 4;     labelMorph: self newLabelMorph;     buttonMorph: self newButtonMorph;     on: #click send: #updateButton: to: self;     on: #mouseMove send: #updateButton: to: self;     on: #mouseUp send: #updateButton: to: selfselectionColor  ^self valueOfProperty: #selectionColor ifAbsent: [  ]hasHalo  ^self hasProperty: #hasHaloborderColor  ^borderColorboxExtent  label ifNil: [ ^14 @ 14 * self displayScaleFactor ].  ^14 @ 14 * self displayScaleFactor max: label height @ label heightbeExplicit  self subclassResponsibilityupdateLabel  self model ifNotNil: [ self getLabelSelector ifNotNil: [ self label: (self model perform: self getLabelSelector) ] ]visibleTabRange  ^visibleTabRangecollapseBoxHit  self isCollapsed ifTrue: [ self playRestoreUpSound ] ifFalse: [ self playMinimizeSound ].  self collapseOrExpandupdateTasks  | wm deadTasks newTasks taskbarTasksFromWorldMorph |  wm := self worldMorphs asOrderedCollection.  taskbarTasksFromWorldMorph := (wm collect: [:m |  m taskbarTask ]) reject: [:m |  m isNil ].  self tasks: taskbarTasksFromWorldMorph.  deadTasks := self orderedTasks difference: self tasks.  newTasks := self tasks difference: self orderedTasks.  (newTasks isEmpty and: [ deadTasks isEmpty ]) ifTrue: [ ^self ].  newTasks copy do: [:t |  self orderedTasks detect: [:ot |  ot morph = t morph ] ifFound: [:ot |  self orderedTasks replaceAll: ot with: t.              deadTasks remove: ot.              newTasks remove: t ] ].  self orderedTasks     removeAll: deadTasks;     addAll: newTasks reversed.  self updateTaskButtons.  self defer: [ self layoutChanged ]selectedMorph  ^self selectedMorphList ifNotEmpty: [:l |  l last ] ifEmpty: [  ]horizontalPlacement  ^horizontalPlacementupdateTaskButtons  self taskList removeAllMorphs.  self tasks do: [:t |  | button |        button := t taskListButtonFor: self.        button ifNotNil: [ self taskList addMorphBack: button ] ]newText: aStringOrText  ^self theme newTextIn: self text: aStringOrTextstationarySetup  self actWhen: #startDrag.  self cornerStyle: #rounded.  self borderNormal.  self on: #mouseEnter send: #borderThick to: self.  self on: #mouseDown send: nil to: nil.  self on: #mouseLeave send: #borderNormal to: self.  self on: #mouseLeaveDragging send: #borderNormal to: self.  self on: #mouseUp send: #borderThick to: selfopenOn: aClass  | window |  self rootClass: aClass.  window := StandardWindow new model: self.  window title: aClass name , ' hierarchy'.  window addMorph: self treeMorph fullFrame: LayoutFrame identity.  window themeChanged.  window openInWorld.  ^windowlineHeight  ^bottom - topcontents: stringOrText  ^self contentsAsIs: stringOrTexthasKeyboardFocus  ^((self world ifNil: [ ^false ]) activeHand ifNil: [ ^false ]) keyboardFocus = selfselectedItems  ^selectedItemsnormalFillStyle  ^self theme buttonNormalFillStyleFor: selfshowState: anObject  showState := anObjectdrawOnFormCanvas: aCanvas  vertices size < 1 ifTrue: [ self error: 'a polygon must have at least one point' ].  closed & color isTransparent not ifTrue: [ aCanvas stencil: self filledForm at: bounds topLeft - 1 color: color ].  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) ifTrue: [ aCanvas stencil: self borderForm at: bounds topLeft color: borderColor ] ifFalse: [ self drawBorderOn: aCanvas ].  self arrowForms do: [:f |  aCanvas stencil: f at: f offset color: (borderColor isColor ifTrue: [ borderColor ] ifFalse: [ color ]) ]selectMorph: aNodeMorph multiple: withMultipleSelection  | path mult |  self lastClickedMorph: aNodeMorph.  aNodeMorph ifNil: [ self emptySelection.        ^nil ].  aNodeMorph selected ifTrue: [ withMultipleSelection ifTrue: [ self removeFromSelection: aNodeMorph ] ifFalse: [ mult := self selectedMorphList size > 1.              path := aNodeMorph path collect: [:m |  m complexContents ].              (self autoDeselection or: [ mult ]) ifTrue: [ self emptySelection.                    mult ifTrue: [ self addToSelection: aNodeMorph ] ifFalse: [ path := nil ] ] ] ] ifFalse: [ withMultipleSelection ifFalse: [ self emptySelection ].        self addToSelection: aNodeMorph.        path := aNodeMorph path collect: [:m |  m complexContents ] ].  self selectionChanged.  ^pathkeyboardFocus  ^keyboardFocusballoonFont  ^self valueOfProperty: #balloonFont ifAbsent: [ self defaultBalloonFont ]displayArea  ^self worldState worldRenderer usableAreachangeParagraphAnchor  | newType |  newType := self textAnchorType == #paragraph ifTrue: [ #document ] ifFalse: [ #paragraph ].  owner isTextMorph ifTrue: [ owner anchorMorph: self at: self position type: newType ]nodeCollapseRequest: anAnnounce  anAnnounce nodes ifEmpty: [ self collapseAll ] ifNotEmpty: [:nodes |  self collapseNodePath: nodes ]expandAll  self expand.  self children do: #expandAllnewTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: menuSelector  ^self theme newTextEditorIn: self for: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: menuSelectorsetSelection: aSelection  selection := aSelectionprepareToTrackCenterOfRotation: evt with: rotationHandle  evt hand obtainHalo: self.  evt shiftPressed ifTrue: [ self removeAllHandlesBut: rotationHandle ] ifFalse: [ rotationHandle setProperty: #dragByCenterOfRotation toValue: true.        self startDrag: evt with: rotationHandle ].  evt hand showTemporaryCursor: Cursor blankwasHandled  ^wasHandledelementAt: index  | curr b |  curr := 0.  b := nil.  b := [:p |  p do: [:each |  (curr := curr + 1) = index ifTrue: [ ^each ] ifFalse: [ b value: each children ] ] ].  b value: rootItems.  SubscriptOutOfBounds signal: indexvalue  ^valueshowHScrollBarOnlyWhenNeeded: bool  self setProperty: #noHScrollBarPlease toValue: bool.  self setProperty: #hScrollBarAlways toValue: bool.  self hHideOrShowScrollBarisEnabled: aBoolean  isEnabled = aBoolean ifTrue: [ ^self ].  isEnabled := aBoolean.  self color: (aBoolean ifTrue: [ Color black ] ifFalse: [ Color gray ])highlighted: aBoolean  highlighted := aBooleanselectAllRowIndexes  self deprecated: 'Use #selectAll instead' transformWith: '`@receiver selectAllRowIndexes' -> '`@receiver selectAll'.  ^self selectAllacceptDroppingObject: anotherItem  ^model dropNode: anotherItem on: selfcomputedHeightFromContents  | h |  h := 0.  self submorphsDo: [:sm |  h := h max: sm height ].  ^hdrawLineFrom: startPoint to: stopPoint on: aCanvas  | lineColor |  lineColor := (stopPoint truncated quadrantOf: startPoint truncated) > 2 ifTrue: [ self topLeftColor ] ifFalse: [ self bottomRightColor ].  aCanvas line: startPoint to: stopPoint width: self width color: lineColorleftFlush  textStyle leftFlushdefaultColor  ^Color transparentorderedSelectedTabs  ^tabs select: [:e |  e selected ]selectedTabs  ^(selectionHistory last: numberOfSelectedTabs) reversedtype  ^#(windowMetricChange windowClose windowIconise windowActivated windowPaint) at: action ifAbsent: [ #windowEventUnknown ]numberOfRows  self hasDataSource ifFalse: [ ^0 ].  ^self dataSource numberOfRowsupdateHeaderRow  | columns columnHeaders columnWidths |  self canRefreshValues ifFalse: [ ^self ].  headerRow := nil.  columns := self table columns.  columnHeaders := OrderedCollection new.  columnWidths := self calculateColumnWidths.  (self exposedColumnsRange: columnWidths) do: [:index |  | column headerCell columnWidth |        column := columns at: index.        columnWidth := columnWidths at: index.        headerCell := self table dataSource headerColumn: column.        headerCell ifNil: [ ^self ].        headerCell           color: self table headerColor;           width: columnWidth.        columnHeaders addLast: headerCell.        FTDisplayColumn column: column width: columnWidth ].  headerRow := (FTTableHeaderRowMorph table: self table)     privateOwner: self;     addAllMorphs: columnHeaders;     yourselfsliderExtent  ^slider extenttabs: anObject  tabs := anObjecttestExtent  | m1 m2 v1 v2 v3 b1 b2 |  m1 := Morph new.  m2 := Morph new.  v1 := 100.000001.  v2 := 100.000001000001.  v3 := 100.000001000002.  m1 extent: v1 @ v1.  b1 := m1 bounds.  m2 extent: v2 @ v3.  b2 := m2 bounds.  self assert: b2 equals: b1addMorph: aMorph centeredNear: aPoint  | trialRect delta |  trialRect := Rectangle center: aPoint extent: aMorph fullBounds extent.  delta := trialRect amountToTranslateWithin: bounds.  aMorph position: trialRect origin + delta.  self addMorph: aMorphstep  alpha <= fadingFactor ifTrue: [ ^self delete ].  alpha := alpha - fadingFactor.  self changedtoggle  self active: self active notdefaultTreeMorph  ^super defaultTreeMorph     multiSelection: true;     autoMultiSelection: true;     yourselfitalic  self changeEmphasis: #italichandsDo: aBlock  ^hands do: aBlockaddToggleItemsToHaloMenu: aCustomMenu  super addToggleItemsToHaloMenu: aCustomMenu.  aCustomMenu addUpdating: #enabledString target: self selector: #toggleEnabledopenFindDialog  self sharesFindReplace ifTrue: [ (self findReplaceDialog on: self) open ] ifFalse: [ self flash ]getContentsSelector  ^getContentsSelectorextent: newExtent  super extent: newExtent.  label ifNotNil: [ label position: self center - (label extent // 2) ]labelClickable: aBoolean  labelClickable := aBooleanoldScrollingIndex: anObject  oldScrollingIndex := anObjectballoonText  ^nilselectedMorphList  ^self listManager selectedMorphListdragSelectionColor  ^Color magentagetIconSelector: aSymbol  getIconSelector := aSymbolminimumExtent  | minExt |  (textStyle isNil or: [ borderWidth isNil or: [ self paragraph lines isEmpty ] ]) ifTrue: [ ^9 @ 16 ].  minExt := 9 @ self paragraph lines first lineHeight ceiling + (borderWidth * 2).  ^((0 @ 0 extent: minExt) expandBy: margins) extentminExtentVertical: aMorph  | inset minX minY maxX maxY n size width height |  size := properties minCellSize asPoint.  minX := size x.  minY := size y.  size := properties maxCellSize asPoint.  maxX := size x.  maxY := size y.  inset := properties cellInset asPoint.  n := 0.  width := height := 0.  aMorph submorphsDo: [:m |  | sizeX sizeY |        m disableTableLayout ifFalse: [ n := n + 1.              size := m minExtent.              sizeX := size x.              sizeY := size y.              sizeX < minX ifTrue: [ sizeX := minX ] ifFalse: [ sizeX > maxX ifTrue: [ sizeX := maxX ] ].              sizeY < minY ifTrue: [ sizeY := minY ] ifFalse: [ sizeY > maxY ifTrue: [ sizeY := maxY ] ].              height := height + sizeY.              sizeX > width ifTrue: [ width := sizeX ] ] ].  n > 1 ifTrue: [ height := height + ((n - 1) * inset y) ].  ^minExtentCache := width @ heightvScrollBarValue: scrollValue  | old |  old := atBottom.  self atBottom: scrollValue >= self verticalScrollbarFrontier.  old ~= atBottom ifTrue: [ self buildPanel ]selection: aSelection  self setSelection: aSelection.  self requestView: MorphTreeChangeRequest updateSelectionFromModelstate: newState  newState == state ifTrue: [ ^self ].  state := newState.  self invalidRect: boundslabelBottomOffset  ^5 * self displayScaleFactorisLabelled  ^truekeystrokeActionSelector: aSelector  keystrokeActionSelector := aSelectorclipSubmorphs  ^clipSubmorphsstyle  ^#simpleowner  ^ownerdisable  self enabled: falsewidth: anObject  width := anObjectlongMessage: aStringOrText title: aString  ^self theme longMessageIn: self text: aStringOrText title: aStringenabled  ^truedoFullRepaint  damageRecorder doFullRepainttextSize  ^sizeresetSorting  self sortingStrategy resetborderThick  self borderStyle: (BorderStyle width: 2 color: self raisedColor twiceDarker)positionInWorld  ^self pointInWorld: self positionlabel: aString  self label isEmpty ifTrue: [ self forceRefreshOnNextChange ].  self labelMorph contents: aString.  self changedkeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self focusChangedsimulateKeyStroke: aCharacter  | event |  event := KeyboardEvent new setType: #keystroke buttons: 0 position: 0 @ 0 keyValue: aCharacter charCode charCode: aCharacter charCode hand: ActiveHand stamp: 0.  self keyStroke: eventmouseEnterDragging: evt  self eventHandler ifNotNil: [ ^self eventHandler mouseEnterDragging: evt fromMorph: self ]subMorph: aMorph  subMorph := aMorphdate: aDate  date := aDateoffImage  | m form |  m := CheckboxButtonMorph new     privateOwner: self owner;     adoptPaneColor: self paneColor;     selected: false.  form := Form extent: m extent depth: 32.  form fillColor: (Color white alpha: 0.003922).  form getCanvas fullDrawMorph: m.  ^formleftMargin  ^self leftcomputeArrowFormAt: endPoint from: priorPoint  | p1 pts box arrowForm bb origin |  pts := self arrowBoundsAt: endPoint from: priorPoint.  box := ((pts first rectangle: pts last) encompass: pts second) expandBy: 1.  arrowForm := Form extent: box extent asIntegerPoint.  bb := (BitBlt toForm: arrowForm)     sourceForm: nil;     fillColor: Color black;     combinationRule: Form over;     width: 1;     height: 1.  origin := box topLeft.  p1 := pts last - origin.  pts do: [:p |  bb drawFrom: p1 to: p - origin.        p1 := p - origin ].  arrowForm convexShapeFill: Color black.  ^arrowForm offset: box topLeftgtInspectorMappingsIn: composite  < gtInspectorPresentationOrder: 95>  (self hasProperty: #kmDispatcher) ifFalse: [ ^self ].  self kmDispatcher gtInspectorMappingsIn: compositeinitializePagingArea  pagingArea := Morph newBounds: self totalSliderArea color: (Color r: 0.6 g: 0.6 b: 0.8).  pagingArea on: #mouseDown send: #scrollPageInit: to: self.  pagingArea on: #mouseUp send: #finishedScrolling to: self.  self addMorph: pagingArea.  pagingArea cornerStyle: (self theme scrollbarPagingAreaCornerStyleIn: self window).  pagingArea on: #mouseUp send: #finishedScrolling: to: self.  self on: #mouseEnter send: #mouseEnterPagingArea: to: self.  self on: #mouseLeave send: #mouseLeavePagingArea: to: selfisCheckList  ^isCheckList ifNil: [ isCheckList := false ]doButtonAction  resizeContainerFrom: topLeftPoint to: bottomLeftPoint  ^topLeftPoint corner: bottomLeftPoint x @ (bottomLeftPoint y - self fieldHeigh)selectedItems: aNodeItemCollection  self listModel okToDiscardEdits ifFalse: [ ^self ].  self emptySelection.  (self nodeMorphsWithAllNodeItems: aNodeItemCollection) ifNotEmpty: [:selection |  self addAllToSelection: selection ].  lastClickedMorph ifNil: [ lastClickedMorph := self selectedMorphList ifEmpty: [  ] ifNotEmpty: [ self selectedMorphList last ] ]removeFromHistory: aTab  selectionHistory remove: aTab ifAbsent: [  ]prepareForRotating  ^self addFlexShellmouseUp: event onItem: aMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlerschooseDirectory: title path: path  ^self theme chooseDirectoryIn: self title: title path: pathtableContainer  ^self table containerhandleMouseMove: anEvent  ^self dispatchDefault: anEvent with: morphmouseMove: anEvent  self canResizeColumn ifFalse: [ ^self ].  anEvent hand temporaryCursor ifNil: [ ^self ].  traceMorph ifNil: [ traceMorph := Morph newBounds: (self bounds withHeight: container height).        traceMorph color: self theme fastTableColumnResizingColor.        traceMorph borderWidth: 0.        container addMorph: traceMorph ].  traceMorph position: (anEvent cursorPoint x - lastMouse second x) @ traceMorph position ychanged  container ifNil: [ super changed ] ifNotNil: [ container invalidRect: self selectionFrame ]hasToggleAtRoot  ^hasToggleAtRoot ifNil: [ hasToggleAtRoot := self roots anySatisfy: [:s |  s hasToggle ] ]veryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  target := deepCopier references at: target ifAbsent: [ target ].  arguments := arguments collect: [:each |  deepCopier references at: each ifAbsent: [ each ] ]noticeMouseOver: aMorph event: anEvent  mouseOverHandler ifNil: [ ^self ].  mouseOverHandler noticeMouseOver: aMorph event: anEventinARightColumn: aCollectionOfMorphs  self setAsColumn     vResizing: #shrinkWrap;     layoutInset: 1;     wrapCentering: #bottomRight;     cellPositioning: #topCenter.  aCollectionOfMorphs do: [:each |  self addMorphBack: each ]sortingIcon  ^self context morphicIconNamed: #arrowUpcontainsPoint: aPoint  | w |  ^(super containsPoint: aPoint) and: [ w := SystemWindow borderWidth.        ((self bounds translateBy: w negated @ w) containsPoint: aPoint) not ]contentString: aString  aString ifNil: [ self removeProperty: #contentString ] ifNotNil: [ self setProperty: #contentString toValue: aString ]nextTokenFrom: start direction: dir  ^self editor nextTokenFrom: start direction: dirscrollByKeyboard: event  (event controlKeyPressed or: [ event commandKeyPressed ]) ifFalse: [ ^false ].  event keyValue = 30 ifTrue: [ scrollBar scrollUp: 3.        ^true ].  event keyValue = 31 ifTrue: [ scrollBar scrollDown: 3.        ^true ].  ^falseaddToSelection  self triggerEvent: #tabAddedToSelection with: selflayoutSymbols  ^#(#center #tiled #scaled #scaledAspect #topLeft #topCenter #topRight #rightCenter #bottomRight #bottomCenter #bottomLeft #leftCenter)empty  self subclassResponsibilitybeIconLeft  iconPosition := #left.  self update: getIconSelectoruserString  ^contentsindentingItemClass  ^IndentingListItemMorphdragHand: aHandMorph  dragHand := aHandMorphinvokeAt: aPoint in: aWorld allowKeyboard: aBoolean  | w originalFocusHolder |  originalFocusHolder := aWorld primaryHand keyboardFocus.  self popUpAt: aPoint forHand: aWorld primaryHand in: aWorld allowKeyboard: aBoolean.  w := aWorld outermostWorldMorph.  [ self isInWorld ] whileTrue: [ w doOneSubCycle ].  self delete.  self restoreFocus: originalFocusHolder in: aWorld.  ^selectedItem ifNotNil: [ selectedItem target ]slideBackToFormerSituation: evt  | slideForm formerOwner formerPosition aWorld startPoint endPoint trans |  formerOwner := self formerOwner.  formerPosition := self formerPosition.  aWorld := evt hand world.  trans := formerOwner transformFromWorld.  slideForm := trans isPureTranslation ifTrue: [ self imageForm offset: 0 @ 0 ] ifFalse: [ ((TransformationMorph new asFlexOf: self) transform: trans) imageForm offset: 0 @ 0 ].  startPoint := evt hand fullBounds origin.  endPoint := trans localPointToGlobal: formerPosition.  owner removeMorph: self.  aWorld displayWorld.  slideForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.  formerOwner addMorph: self.  self position: formerPosition.  self justDroppedInto: formerOwner event: evtflushLayoutCache  selectionColor: aColor  selectionColor := aColor.  self color: selectionColormorph  ^morphshowState  ^showStatefocusIndicatorCornerRadius  ^self theme focusIndicatorCornerRadiusFor: selfedgeToAdhereTo  ^#bottomexternalName  ^labelStringstep  pointBlock value: self centeradjacentTo  ^{(self bounds topRight + (10 @ 0)) .   self bounds topLeft}locationMorph  ^locationMorphfont  ^self fontToUsenormalBorderStyle  ^self theme scrollbarNormalBorderStyleFor: selfonImageSelector  ^onImageSelectorexploreItem  self inspectsetTarget: evt  | oldDefaultTarget |  oldDefaultTarget := defaultTarget.  oldDefaultTarget ~~ defaultTarget ifTrue: [ self updateItemsWithTarget: defaultTarget orWithHand: evt hand ]dashColors: anObject  dashColors := anObjectmouseMove: anEvent  target ifNil: [ ^self ].  self theme settings fastDragging ifTrue: [ target doFastWindowReframe: self edgeName ] ifFalse: [ super mouseMove: anEvent ]trackPaneColor: anObject  trackPaneColor := anObjectreleaseEditor  editor ifNotNil: [ self selectionChanged.        self paragraph selectionStart: nil selectionStop: nil.        editor := nil ]veryDeepInner: deepCopier  bounds := bounds shallowCopy.  submorphs := submorphs veryDeepCopyWith: deepCopier.  color := color veryDeepCopyWith: deepCopier.  extension := extension veryDeepCopyWith: deepCopiersimpleFudgeOffset  ^0 @ 0headerColumn: column  ^self basicHeaderCellFor: columnsetSuccessor: newSuccessor  successor := newSuccessor.  paragraph ifNotNil: [ paragraph wantsColumnBreaks: successor notNil ]disable  field ifNotNil: [ field delete.        field := nil ]rowAtLocation: aPoint startingAt: aPosition  | y |  y := aPoint y.  submorphs ifEmpty: [ ^nil ].  aPosition to: submorphs size do: [:idx |  | m |        m := submorphs basicAt: idx.        m topLeft y >= y ifTrue: [ ^idx - 1 max: 1 ] ].  ^submorphs sizetopWindow  ^self class topWindowprivateRemove: aMorph  submorphs := submorphs copyWithout: aMorph.  self layoutChangedautoFit: trueOrFalse  self isAutoFit = trueOrFalse ifTrue: [ ^self ].  self autoFitOnOffcollapseAll  (self windowsSatisfying: [:w |  w isCollapsed not ]) reverseDo: [:w |  w collapseOrExpand.        self displayWorld ].  self collapseNonWindowsstep  ^stephighlight  complexContents highlightingColor ifNotNil: [ self color: complexContents highlightingColor ].  self changedrightArrowStroked: evt  (super rightArrowStroked: evt) ifTrue: [ ^true ].  popUpOwner ifNotNil: [ self deselectAndFocusOutermenuOn: evt.        self sendRightArrowPressedToMenubarOwner: evt.        ^true ].  ^falseinitialize  super initialize.  self     hResizing: #spaceFill;     vResizing: #rigid;     changeTableLayout;     listDirection: #leftToRight;     cellInset: 2 @ 0;     layoutInset: 3 @ 0;     listCentering: #center;     clipSubmorphs: true;     borderWidth: 0;     borderColor: Color lightGrayfillStyleToUse  ^self enabled ifTrue: [ self theme listNormalFillStyleFor: self ] ifFalse: [ self theme listDisabledFillStyleFor: self ]indexesToSelectInMultipleSelectionFrom: firstIndex to: endIndex  | step |  step := firstIndex <= endIndex ifTrue: [ 1 ] ifFalse: [ -1 ].  ^firstIndex to: endIndex by: stepshowWorldTaskbar: aBoolean  aBoolean ifTrue: [ self createTaskbarIfNecessary ] ifFalse: [ self removeTaskbar ]textHighlightColor: aColor  self setProperty: #textHighlightColor toValue: aColoraddNode: aNode  self addNodePath: aNode pathaddMorphBack: aMorph  ^self privateAddMorph: aMorph atIndex: submorphs size + 1newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpTexthandleFocusEvent: evt  self processEvent: evt.  evt isKeyboard ifTrue: [ ^self handleEvent: evt ].  (evt isMouseOver or: [ evt isMouse not ]) ifTrue: [ ^self ].  evt isMove ifFalse: [ ^self handleEvent: evt ].  selectedItem ifNotNil: [ (selectedItem activateSubmenu: evt) ifTrue: [ ^self ] ].  (self fullContainsPoint: evt position) ifFalse: [ popUpOwner ifNotNil: [ (popUpOwner activateOwnerMenu: evt) ifTrue: [ ^self ] ] ]highlightForMouseDown  self highlightForMouseDown: trueresetListSelector: aSelector  resetListSelector := aSelectorwantsDropElements: aCollection type: type index: rowIndex  ^aCollection allSatisfy: #isClassrightButtonLabel  ^AlphaImageMorph new image: (ScrollBar arrowOfDirection: #right size: self controlButtonWidth - (3 * self displayScaleFactor) color: self paneColor darker)update: symbol  (symbol == self getListSelector or: [ symbol == self getListElementSelector ]) ifTrue: [ ^self updateList ].  symbol == self getIndexSelector ifTrue: [ ^self updateSelectionIndex ]newYesButtonFor: aModel  ^self theme newYesButtonIn: self for: aModelnewSVSelector: aColor help: helpText  ^self theme newSVSelectorIn: self color: aColor help: helpTextlistMorphClass  ^LazyListMorphcolumn  ^columnballoonFont: aFont  ^self setProperty: #balloonFont toValue: aFonttoggleVisibleAndRaise  self isActive ifTrue: [ self world navigateVisibleWindowForward ].  super toggleVisibleAndRaise.  self visible ifTrue: [ self activate ]firstSubmorph  ^submorphs firstdefaultBorderColor  ^Color blackjob: aJob  job := aJobtestMouseEnterFromMorph  morph eventHandler on: #mouseEnter send: #value to: true.  self assert: (morph mouseEnter: nil) identicalTo: truechildrenItems  ^self item classestriggerOnMouseDown: aBoolean  triggerOnMouseDown := aBooleanfont: aFont emphasis: emphasisCode  font := aFont.  emphasis := emphasisCode.  self fitContentsrootNodes  ^(self rootItems ifNil: [ ^nil ]) collect: [:ci |  self rootNodeFromItem: ci ]addRecolorHandle: haloSpec  self addHandle: haloSpec on: #mouseUp send: #doRecolor:with: to: selfisTextMorph  ^falsetabEmptyContents: aTab  self selectedTab = aTab ifFalse: [ ^self ].  (selectionHistory last: numberOfSelectedTabs) do: [:each |  each == aTab ifFalse: [ each silentlySelected: false ] ].  numberOfSelectedTabs := 1.  self adjustLayout.  self triggerEvent: #tabEmptyContents with: aTabkeyStroke: event  (self navigationKey: event) ifTrue: [ ^self ].  super keyStroke: eventtoggleHandles  handles ifNil: [ self addHandles ] ifNotNil: [ self removeHandles ]changeEmphasis: aSymbol  self editor applyAttribute: (TextEmphasis perform: aSymbol).  self updateFromParagraphmustTakeIntoAccountToggleSpace  ^indentLevel > 0 or: [ container hasToggleAtRoot ]parentNode  ^parentNodeselectedItem  selectedItem ifNil: [ ^nil ].  ^selectedItem isSelected ifTrue: [ selectedItem ] ifFalse: [ nil ]resize: newSize  self form: (image scaledToSize: newSize)roundedCornersString  ^(self wantsRoundedCorners ifTrue: [ '<yes>' translated ] ifFalse: [ '<no>' translated ]) , 'round corners' translatedownerChanged  self snapToEdgeIfAppropriateeventHandler  ^extension ifNotNil: [ extension eventHandler ]handleDropMorph: anEvent  ^self dispatchDropEvent: anEvent with: morphfitContents  | newBounds boundsChanged |  newBounds := self measureContents.  boundsChanged := bounds extent ~= newBounds.  self extent: newBounds.  boundsChanged ifFalse: [ self changed ]goHome  | box fb |  owner ifNil: [ ^self ].  self visible ifFalse: [ ^self ].  box := owner visibleClearArea.  fb := self fullBounds.  fb left < box left ifTrue: [ self left: box left - fb left + self left ].  fb right > box right ifTrue: [ self right: box right - fb right + self right ].  fb top < box top ifTrue: [ self top: box top - fb top + self top ].  fb bottom > box bottom ifTrue: [ self bottom: box bottom - fb bottom + self bottom ]scale: scaleFactor  | flex center ratio |  ratio := self scaleFactor / scaleFactor.  self borderWidth: ((self borderWidth / ratio) rounded max: 0).  center := self referencePosition.  flex := (MorphicTransform offset: center negated) withScale: ratio.  self setVertices: (vertices collect: [:v |  (flex transform: v) - flex offset ]).  super scale: scaleFactorremoveHandles  handles ifNotNil: [ handles do: [:h |  h delete ].        handles := nil ]alwaysShowHScrollBar: bool  self setProperty: #hScrollBarAlways toValue: bool.  self hHideOrShowScrollBarhandlePreviousMonthTouched  self date: date onPreviousMonth.  self changedpotentialDropMorph  ^potentialDropMorphnewMorphListFor: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: enabledSel help: helpText  ^self theme newMorphListIn: self for: aModel list: listSelector getSelected: getSelector setSelected: setSelector getEnabled: enabledSel help: helpTextupdateTaskButtons  | oldButtons size |  oldButtons := self submorphs copy.  self removeAllMorphs.  self defer: [ oldButtons do: [:b |  b model: nil ] ].  size := self orderedTasks size.  (self orderedTasks copyFrom: (size - self class maximumButtons + 1 max: 1) to: size) do: [:t |  | button |        button := t taskbarButtonFor: self.        button ifNotNil: [ self addMorphBack: button ] ]step: anObject  step := anObjectmenu: menu shifted: b  menu add: 'Browse (b)' target: self selector: #browseItem.  menu add: 'Inspect (i)' target: self selector: #inspectItem.  menu add: 'Explore (I)' target: self selector: #exploreItemnewTextEditorFor: aModel getText: getSel setText: setSel  ^self newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: nilframeRectangle: aRectangle on: aCanvas  | w h r tab |  w := self width.  w isPoint ifTrue: [ h := w y.        w := w x ] ifFalse: [ h := w ].  r := aRectangle topLeft extent: w @ aRectangle height.  aCanvas fillRectangle: r color: self color.  r := aRectangle topRight - (w @ 0) extent: w @ aRectangle height.  aCanvas fillRectangle: r color: self color.  r := aRectangle bottomLeft + (w @ h negated) extent: (aRectangle width - w - w) @ h.  aCanvas fillRectangle: r color: self color.  tab := self selectedTab.  (tab isNil or: [ tab owner isNil ]) ifTrue: [ r := aRectangle topLeft + (w @ 0) corner: aRectangle topRight - (w @ h negated).        aCanvas fillRectangle: r color: self color.        ^self ].  r := aRectangle topLeft + (w @ 0) corner: (tab bounds left + w) @ (aRectangle top + h).  aCanvas fillRectangle: r color: self color.  r := (tab bounds left + w) @ aRectangle top corner: (tab bounds right - w) @ (aRectangle top + h).  aCanvas fillRectangle: r color: tab paneColor.  r := (tab bounds right - w) @ aRectangle top corner: aRectangle topRight - (w @ h negated).  aCanvas fillRectangle: r color: self coloritemFromPoint: aPoint  | ptY |  scroller hasSubmorphs ifFalse: [ ^nil ].  (scroller fullBounds containsPoint: aPoint) ifFalse: [ ^nil ].  ptY := (scroller firstSubmorph point: aPoint from: self) y.  scroller firstSubmorph top > ptY ifTrue: [ ^nil ].  scroller lastSubmorph bottom < ptY ifTrue: [ ^nil ].  ^self findSubmorphFor: ptYdropNotifyRecipient  ^dropNotifyRecipientcollapseOrExpand  | aWorld |  isCollapsed ifTrue: [ uncollapsedMorph setProperty: #collapsedPosition toValue: self position.        labelString ifNotNil: [ uncollapsedMorph setNameTo: labelString ].        mustNotClose := false.        self delete.        (aWorld := self currentWorld) addMorphFront: uncollapsedMorph.        aWorld startSteppingSubmorphsOf: uncollapsedMorph ] ifFalse: [ super collapseOrExpand ]scrollBar  ^scrollBarshowFilterFieldFromKeystrokeEvent: anEvent  | text ed |  text := anEvent keyCharacter asString asText.  self initializeFilter.  self filterWith: text.  ed := RubFloatingEditorBuilder new     customizeEditorWith: [:editor |  editor bounds: (self table bottomLeft + (0 @ 2) corner: self table bottomRight + (0 @ (editor font height + 6))) ];     withEditedContentsDo: [:contents :editor |  self filterWith: contents.        editor setTextWith: (self colorText: contents) ].  ed autoAccept: true.  ed whenEditorEscapedDo: [ self reinitializeTable ].  ed openEditorWithContents: (self colorText: text)acceptOnFocusChange: anObject  acceptOnFocusChange := anObjectmagicAlpha  ^self valueOfProperty: #magicAlpha ifAbsent: [ 1.0 ]hScrollbarValue: scrollValue  | r |  r := self scrollTarget width - self scrollBounds width max: 0.  self scroller offset: (r * scrollValue) rounded @ self scroller offset ytarget: newTarget  target := newTargetstepTime  ^100enable  self enabled: true= aMorphicEvent  super = aMorphicEvent ifFalse: [ ^false ].  position = aMorphicEvent position ifFalse: [ ^false ].  startPoint = aMorphicEvent startPoint ifFalse: [ ^false ].  buttons = aMorphicEvent buttons ifFalse: [ ^false ].  ^truecopyHandlerState: anEvent  wasHandled := anEvent wasHandledtestUpdatingSelectionsOnUpdate  | c w t |  c := ClassTreeExample new.  [ w := c openOn: Collection.  t := c dependents last.  t expandAll.  c selectItems: {Bag .         CharacterSet}.  c selection selectedNodes do: [:e |  self assert: (t selectedMorphList anySatisfy: [:sm |  sm complexContents = e ]) ].  c rootClass: Bag.  c updateList.  c selection selectedNodes do: [:e |  self assert: (t selectedMorphList anySatisfy: [:sm |  sm complexContents = e ]) ] ] ensure: [ w close ]mouseEnterDragging: evt  | aMorph |  (evt hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: evt ].  (self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifTrue: [ aMorph := self itemFromPoint: evt position.        aMorph ifNotNil: [ self potentialDropMorph: aMorph ].        evt hand newMouseFocus: self ]mouseUp: anEvent  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: anEvent cursorPoint) ifFalse: [ anEvent hand showTemporaryCursor: nil ].  self updateFromEvent: anEvent.  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUpnextState  ^FTUnsortedSortingState context: self contextselectableIndexBefore: anIndex  ^self subclassResponsibilitymouseUp: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseUp from: sourceMorphleft  ^bounds lefthasMenuBox  ^menuBox notNilmouseUpInSlider: event  super mouseUpInSlider: event.  self updateLabelpreferedPaneColor  ^preferedPaneColorseparatorBlockOrSelector: aBlockOrSelector  separatorBlockOrSelector := aBlockOrSelectorshow: aJob  | progressMorph |  self flag: #pharoFixMe.  progressMorph := self addItemShowing: aJob.  self openInWorld.  self updateWidth.  ^progressMorphhandleMouseDown: anEvent  anEvent wasHandled ifTrue: [ ^self ].  anEvent hand removePendingBalloonFor: self.  anEvent wasHandled: true.  (anEvent controlKeyPressed and: [ self cmdGesturesEnabled and: [ anEvent shiftPressed ] ]) ifTrue: [ self invokeMetaMenu: anEvent.        ^self eventHandler ifNotNil: [:handler |  handler mouseDown: anEvent fromMorph: self ] ].  anEvent hand newMouseFocus: self event: anEvent.  anEvent blueButtonChanged ifTrue: [ ^self blueButtonDown: anEvent ].  self mouseDown: anEvent.  anEvent hand removeHaloFromClick: anEvent on: self.  (self handlesMouseStillDown: anEvent) ifTrue: [ self startStepping: #handleMouseStillDown: at: Time millisecondClockValue + self mouseStillDownThreshold arguments: {anEvent copy resetHandlerFields} stepTime: self mouseStillDownStepRate ]canScrollUp  ^value > 0searchStrategy: anObject  searchStrategy := anObjectenabledString  ^self enabled -> 'enabled' translatedmouseStillDownThreshold  ^200heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]selectedNodePathList  ^self selectedNodePath ifNil: [ #() ] ifNotNil: [ Array with: self selectedNodePath ]becomeModal  self currentWorld ifNotNil: [ self currentWorld modalWindow: self ]sendToBack  | otherSystemWindows |  otherSystemWindows := self world submorphs select: [:morph |  morph isSystemWindow and: morph ~~ self ].  otherSystemWindows ifNotEmpty: [ otherSystemWindows first activate.        self world addMorph: self behind: otherSystemWindows last ]stepTime  | rendered |  rendered := self renderedMorph.  rendered = self ifTrue: [ ^super stepTime ].  ^rendered stepTimechangeListDirection: aSymbol  | listDir wrapDir |  self listDirection: aSymbol.  self wrapDirection == #none ifTrue: [ ^self ].  listDir := self listDirection.  wrapDir := self wrapDirection.  (listDir == #leftToRight or: [ listDir == #rightToLeft ]) ifTrue: [ wrapDir == #leftToRight ifTrue: [ ^self wrapDirection: #topToBottom ].        wrapDir == #rightToLeft ifTrue: [ ^self wrapDirection: #bottomToTop ] ] ifFalse: [ wrapDir == #topToBottom ifTrue: [ ^self wrapDirection: #leftToRight ].        wrapDir == #bottomToTop ifTrue: [ ^self wrapDirection: #rightToLeft ] ]newButtonFor: aModel action: actionSel getEnabled: enabledSel label: stringOrText help: helpText  ^self newButtonFor: aModel getState: nil action: actionSel arguments: nil getEnabled: enabledSel label: stringOrText help: helpTextprivateExtension: aMorphExtension  extension := aMorphExtensionicon: anObject  icon := anObjectviewBox  ^0 @ 0 corner: self actualScreenSizemouseDown: evt  super mouseDown: evt.  evt yellowButtonPressed ifTrue: [ ^self ].  oldColor := self fillStyle.  actWhen == #buttonDown ifTrue: [ self doButtonAction ] ifFalse: [ self updateVisualState: evt ].  self mouseStillDown: evtdiscoveredWorldMenu  ^owner discoveredWorldMenufillStyle: fillStyle  fillStyle isColor ifTrue: [ self color: fillStyle ] ifFalse: [ super fillStyle: fillStyle ]fit  | newExtent para cBounds lastOfLines heightOfLast |  self isAutoFit ifTrue: [ newExtent := (self paragraph extent max: 9 @ textStyle lineGrid) + (0 @ 2).        newExtent := newExtent + (2 * borderWidth).        newExtent := ((0 @ 0 extent: newExtent) expandBy: margins) extent.        newExtent ~= bounds extent ifTrue: [ (container isNil and: [ successor isNil ]) ifTrue: [ para := paragraph.                    super extent: newExtent.                    paragraph := para ] ].        (container notNil and: [ successor isNil ]) ifTrue: [ cBounds := container bounds truncated.              lastOfLines := self paragraph lines last.              heightOfLast := lastOfLines bottom - lastOfLines top.              (lastOfLines last < text size and: [ lastOfLines bottom + heightOfLast >= self bottom ]) ifTrue: [ container releaseCachedState.                    cBounds := cBounds origin corner: cBounds corner + (0 @ heightOfLast) ].              self privateBounds: cBounds ] ].  self paragraph positionWhenComposed: self position.  successor ifNotNil: [ successor predecessorChanged ].  self changedselectItem: aMenuItem event: anEvent  selectedItem ifNotNil: [ selectedItem deselect: anEvent ].  selectedItem := aMenuItem.  selectedItem ifNotNil: [ selectedItem select: anEvent ]doButtonAction  (target notNil and: [ actionSelector notNil ]) ifTrue: [ Cursor normal showWhile: [ target perform: actionSelector withArguments: arguments ] ].  actWhen == #startDrag ifTrue: [ oldColor ifNotNil: [ self color: oldColor ] ]testSelectableIndexAbove  self assert: (strategy selectableIndexAbove: 2) equals: 1arguments: anObject  arguments := anObjecttestSelectableIndexBefore  self assert: (strategy selectableIndexBefore: #(2 3)) equals: #(2 2)actWhen  ^actWhenfirstVertex  ^vertices firstdamageRecorder  ^damageRecorderframeRectangle: aRectangle on: aCanvas  self cornerRadius = 0 ifTrue: [ ^self frameRectangle0: aRectangle on: aCanvas ].  self cornerRadius = 1 ifTrue: [ ^self frameRectangle1: aRectangle on: aCanvas ].  self cornerRadius = 2 ifTrue: [ ^self frameRectangle2: aRectangle on: aCanvas ].  self cornerRadius = 3 ifTrue: [ ^self frameRectangle3: aRectangle on: aCanvas ].  self cornerRadius = 4 ifTrue: [ ^self frameRectangle4: aRectangle on: aCanvas ].  self cornerRadius = 5 ifTrue: [ ^self frameRectangle5: aRectangle on: aCanvas ].  self cornerRadius = 6 ifTrue: [ ^self frameRectangle6: aRectangle on: aCanvas ].  self cornerRadius = 7 ifTrue: [ ^self frameRectangle7: aRectangle on: aCanvas ].  self cornerRadius = 8 ifTrue: [ ^self frameRectangle8: aRectangle on: aCanvas ].  ^super frameRectangle: aRectangle on: aCanvashScrollBarValue: scrollValue  | x systemWindow |  self hIsScrollbarShowing ifFalse: [ ^scroller offset: (0 - self hMargin) @ scroller offset y ].  (x := self hLeftoverScrollRange * scrollValue) <= 0 ifTrue: [ x := 0 - self hMargin ].  scroller offset: x @ scroller offset y.  owner ifNil: [ ^self ].  systemWindow := self window.  systemWindow ifNotNil: [ systemWindow announce: (WindowScrolling new                 step: scrollValue @ 0;                 window: systemWindow) ].  self announcer announce: (PaneScrolling new           step: scrollValue @ 0;           scrollPane: self;           yourself)isMinimized  ^self isCollapsedcancel  self closelayoutBounds: aRectangle  | outer inner |  outer := self bounds.  inner := self layoutBounds.  bounds := aRectangle origin + (outer origin - inner origin) corner: aRectangle corner + (outer corner - inner corner)isMouseMove  ^self type == #mouseMovecurveBounds  | pointAfterFirst pointBeforeLast oX oY cX cY |  self isCurvy ifFalse: [ ^(Rectangle encompassing: vertices) expandBy: borderWidth * 0.5 ].  curveState := nil.  pointAfterFirst := nil.  self lineSegmentsDo: [:p1 :p2 |  pointAfterFirst ifNil: [ pointAfterFirst := p2 floor.              oX := cX := p1 x.              oY := cY := p1 y ].        oX := oX min: p2 x.        cX := cX max: p2 x.        oY := oY min: p2 y.        cY := cY max: p2 y.        pointBeforeLast := p1 floor ].  curveState at: 2 put: pointAfterFirst.  curveState at: 3 put: pointBeforeLast.  ^(oX @ oY corner: cX @ cY) expandBy: borderWidth * 0.5haloClass  ^#HaloMorphbuildRowMorph  | rowControls colAndControls |  controls := OrderedCollection new.  colAndControls := container columns collect: [:col |  | v |        v := col rowMorphFor: complexContents.        controls add: v.        col -> v ].  rowControls := OrderedCollection new.  colAndControls do: [:ctrl |  | col morph |        col := ctrl key.        morph := ctrl value.        morph clipSubmorphs: true.        morph vResizing: #shrinkWrap.        rowControls add: morph.        (morph = controls last and: [ container lastColumnUnbounded ]) ifFalse: [ morph hResizing: #rigid ].        (col resizable not and: [ col shrinkWrap ]) ifTrue: [ col currentWidth < morph width ifTrue: [ col forceWidthTo: morph width ] ] ].  self addAllMorphs: rowControls.  self layoutChangedopenInWorld: aWorld  ^self openAsIsIn: aWorlddefaultContainer  ^FTTableContainerMorph newselectedItems: aNodeItemCollection  self listManager selectedItems: aNodeItemCollectionscanCode: anInt  scanCode := anIntcomputeGlobalCellArrangement: cells in: newBounds horizontal: aBool wrap: wrap spacing: spacing  | output maxExtent n cell first last hFill vFill |  output := Array new writeStream.  first := last := nil.  maxExtent := cells inject: 0 @ 0 into: [:size :c |  size max: c cellSize ].  spacing == #globalSquare ifTrue: [ maxExtent := (maxExtent x max: maxExtent y) asPoint ].  n := wrap // maxExtent x max: 1.  hFill := vFill := false.  1 to: cells size do: [:i |  cell := cells at: i.        hFill := hFill or: [ cell hSpaceFill ].        vFill := vFill or: [ cell vSpaceFill ].        cell cellSize: maxExtent.        first ifNil: [ first := last := cell ] ifNotNil: [ last nextCell: cell.              last := cell ].        i \\ n = 0 ifTrue: [ last := LayoutCell new.              last cellSize: (maxExtent x * n) @ maxExtent y.              last hSpaceFill: hFill.              last vSpaceFill: vFill.              hFill := vFill := false.              last nextCell: first.              output nextPut: last.              first := nil ] ].  first ifNotNil: [ last := LayoutCell new.        last cellSize: (maxExtent x * n) @ maxExtent y.        self flag: #pharoFixMe.        last nextCell: first.        output nextPut: last ].  ^output contentsdataSource: anObject  dataSource := anObjectfillStyle: anObject  fillStyle := anObject.  anObject ifNotNil: [ self baseColor: anObject asColor ]cursorPoint  | pos |  pos := self position.  (self currentWorld isNil or: [ self currentWorld == owner ]) ifTrue: [ ^pos ].  ^self currentWorld point: pos from: ownermouseDown: event  needToggleAtMouseUp ifTrue: [ ^self ].  (self selectionModeStrategy selectableIndexContainingPoint: event cursorPoint) ifNotNil: [:index |  (self selectedIndexes includes: index) ifFalse: [ self selectIndex: index event: event ] ifTrue: [ needToggleAtMouseUp := true ] ] ifNil: [ ^self ].  self wantsKeyboardFocus ifTrue: [ self takeKeyboardFocus ].  event hand waitForClicksOrDrag: self event: eventage  ^self item agelastSelectedNodePath  ^self selectedNodePathforwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectioncurrentWidth: anInteger  self resizable ifTrue: [ currentWidth := anInteger ]initializeSlider  slider := BorderedMorph newBounds: self totalSliderArea color: self theme baseColor.  sliderShadow := BorderedMorph newBounds: self totalSliderArea color: self pagingArea color.  slider on: #mouseMove send: #scrollAbsolute: to: self.  slider on: #mouseDown send: #mouseDownInSlider: to: self.  slider on: #mouseUp send: #mouseUpInSlider: to: self.  slider     borderWidth: 1;     borderColor: self theme baseColor.  sliderShadow     borderWidth: 1;     borderColor: #inset.  self pagingArea addMorph: sliderShadow.  sliderShadow hide.  self addMorph: slider.  self computeSliderhash  ^((((((((self species hash + leftFraction hash) hashMultiply + leftOffset hash) hashMultiply + topFraction hash) hashMultiply + topOffset hash) hashMultiply + rightFraction hash) hashMultiply + rightOffset hash) hashMultiply + bottomFraction hash) hashMultiply + bottomOffset hash) hashMultiplyisCurve  ^smoothCurvechangeBorderColor: evt  self theme chooseColorIn: self title: 'Choose Color' translated color: self borderStyle color for: [:newColor |  self borderColor: newColor ]setLabelWidgetAllowance  ^labelWidgetAllowance := self boxExtent x * 7hue: aFloat  self hMorph value: aFloat.  self svMorph color: (Color h: aFloat * 359.9 s: 1.0 v: 1.0)newButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: stringOrText help: helpTextstepTime  ^0menuColumn: column row: rowIndex  rowIndex = 0 ifTrue: [ ^nil ].  column id = 'Name' ifTrue: [ ^self nameMenuColumn: column row: rowIndex ].  column id = 'Origin' ifTrue: [ ^self originMenuColumn: column row: rowIndex ].  ^nillistMorphClass  ^LazyMorphListMorphtestSpaceFill  | lf rectangle |  lf := LayoutFrame identity.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (50 @ 10 corner: 150 @ 70) equals: rectangledefaultIsResizeable  ^falserowMorphGetSelector: aSelector  rowMorphGetSelector := aSelectoralert: aStringOrText  ^self alert: aStringOrText title: 'Alert' translatedaddDismissHandle: handleSpec  | dismissHandle |  target okayToAddDismissHandle ifTrue: [ dismissHandle := self addHandle: handleSpec on: #mouseDown send: #mouseDownInDimissHandle:with: to: self.        dismissHandle on: #mouseUp send: #maybeDismiss:with: to: self.        dismissHandle on: #mouseDown send: #setDismissColor:with: to: self.        dismissHandle on: #mouseMove send: #setDismissColor:with: to: self ]extent: aPoint  super extent: aPoint.  container extent: aPoint.  self resizeAllSubviewsspEnsureLayoutAndAddMorph: aMorph  aMorph layoutFrame ifNil: [ aMorph layoutFrame: LayoutFrame identity ].  self addMorph: aMorphleftButtonLabel  ^AlphaImageMorph new image: (ScrollBar arrowOfDirection: #left size: self controlButtonWidth - (3 * self displayScaleFactor) color: self paneColor darker)brickTransparentImageForm  | background form brickBorder |  self isBrick ifTrue: [ brickBorder := self border.        self border: GLMBrickBorder new ].  background := self color.  self color: Color transparent.  form := self imageForm.  self color: background.  self isBrick ifTrue: [ self border: brickBorder ].  ^formvShowScrollbar  self vResizeScrollbar.  self vScrollbarShowing ifTrue: [ ^self ].  self privateAddMorph: self vScrollbar atIndex: 1.  self hResizeScrollbar.  self resizeScrollerselectTask: aTask  self tasks do: [:t |  t state: #restored ].  aTask ifNotNil: [ aTask state: #active ].  self updateButtonsAndPreviewcontrols: anObject  controls := anObjectjustDroppedInto: aMorph event: anEvent  isCollapsed ifTrue: [ self position: ((self position max: 0 @ 0) grid: 8 @ 8).        collapsedFrame := self bounds ] ifFalse: [ fullFrame := self bounds.        self isTopWindow ifFalse: [ self activate ] ].  anEvent hand releaseMouseFocus.  ^super justDroppedInto: aMorph event: anEventdiamondOval  | b |  b := self bounds.  self setVertices: {b leftCenter .         b bottomCenter .         b rightCenter .         b topCenter}basicWrapSelector: aSelector  self dataSource wrapSelector: aSelectorextension  ^extensionscrollBy: delta  | newYoffset r newXoffset |  newYoffset := scroller offset y - delta y max: 0.  newXoffset := scroller offset x - delta x max: self hMargin negated.  scroller offset: newXoffset @ newYoffset.  (r := self vLeftoverScrollRange) = 0 ifTrue: [ scrollBar value: 0.0 ] ifFalse: [ scrollBar value: newYoffset asFloat / r ].  (r := self hLeftoverScrollRange) = 0 ifTrue: [ hScrollBar value: 0.0 ] ifFalse: [ hScrollBar value: newXoffset asFloat / r ]veryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  target := deepCopier references at: target ifAbsent: [ target ].  arguments := arguments collect: [:each |  deepCopier references at: each ifAbsent: [ each ] ]secondarySelectionColor  ^self theme secondarySelectionColorgripLayoutFrame  ^(1 @ 0 corner: 1 @ 0) asLayoutFrame topLeftOffset: self defaultWidth negated @ -27dashColors  ^dashColorsnotOnLastPage  ^self onLastPage notgetLabelSelector: aSymbol  getLabelSelector := aSymbol.  self updateLabelnewButtonMorph  ^(CheckboxButtonMorph new     target: self;     actionSelector: #toggleSelected;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap) on: #mouseDown send: #buttonMouseDown: to: selfstepTime  ^stepTimenearestOwnerThat: conditionBlock  ^self firstOwnerSuchThat: conditionBlockaddCustomMenuItems: aCustomMenu hand: aHandMorph  super addCustomMenuItems: aCustomMenu hand: aHandMorph.  self addLabelItemsTo: aCustomMenu hand: aHandMorph.  aCustomMenu add: 'change action selector' selector: #setActionSelector.  aCustomMenu add: 'change arguments' selector: #setArguments.  aCustomMenu add: 'change when to act' selector: #setActWhen.  self addTargetingMenuItems: aCustomMenu hand: aHandMorphautoGradient  ^autoGradientinitialize  super initialize.  self initializeSelections.  self hideColumnHeaders.  self dataSource: FTPluggableIconListMorphAdaptorDataSource newwantsDirectionHandles: aBool  self setProperty: #wantsDirectionHandles toValue: aBoollayoutPosition  self layout == #topCenter ifTrue: [ ^self innerBounds topCenter - ((self cachedForm width // 2) @ 0) ].  self layout == #topRight ifTrue: [ ^self innerBounds topRight - (self cachedForm width @ 0) ].  self layout == #rightCenter ifTrue: [ ^self innerBounds rightCenter - (self cachedForm width @ (self cachedForm height // 2)) ].  self layout == #bottomRight ifTrue: [ ^self innerBounds bottomRight - self cachedForm extent ].  self layout == #bottomCenter ifTrue: [ ^self innerBounds bottomCenter - ((self cachedForm width // 2) @ self cachedForm height) ].  self layout == #bottomLeft ifTrue: [ ^self innerBounds bottomLeft - (0 @ self cachedForm height) ].  self layout == #leftCenter ifTrue: [ ^self innerBounds leftCenter - (0 @ (self cachedForm height // 2)) ].  (self layout == #center or: [ self layout == #scaledAspect ]) ifTrue: [ ^self innerBounds center - (self cachedForm extent // 2) ].  ^self innerBounds topLeftorientation: anObject  orientation := anObject.  self changedcopy  ^self veryDeepCopycontrolsExtent  ^self controls first minExtent + (self controls last minExtent x @ 0)moveBy: delta  lines do: [:line |  line moveBy: delta ].  positionWhenComposed ifNotNil: [ positionWhenComposed := positionWhenComposed + delta ].  container := container translateBy: deltahandlesMouseOverDragging: evt  ^trueindentingItemClass  ^TickSelectionListNodeMorphgetIconSelector: anObject  getIconSelector := anObjectresizerWidth: anInteger  resizerWidth := anIntegertabOfPage: aMorph  ^self tabSelectorMorph tabs at: (self pages indexOf: aMorph)scrollValue  ^hScrollBar value @ scrollBar valuefillStyle  ^fillStyledrawOnAthensCanvas: anAthensCanvas  self useSelectionBar ifTrue: [ self paragraph displaySelectionBarOnAthensCanvas: anAthensCanvas ].  self useExtraSelection ifTrue: [ self paragraph displayExtraSelectionOnAthensCanvas: anAthensCanvas ].  super drawOnAthensCanvas: anAthensCanvasasAthensPaintOn: anAthensCanvas  ^AthensCompositeStrokePaint new fromDashedBorderStyle: self on: anAthensCanvasindexesToSelectInMultipleSelectionFrom: firstIndex to: endIndex  ^self subclassResponsibilityselectionColorToUse  self enabled ifFalse: [ ^self paneColor ].  ^self valueOfProperty: #selectionColorToUse ifAbsent: [ self theme selectionColor ]itemStringGetter: aSelectorOrAValuable  rowMorphGetSelector := aSelectorOrAValuable isSymbol ifTrue: [ [:node |  (node complexContents item perform: aSelectorOrAValuable) asMorph ] ] ifFalse: [ [:node |  (aSelectorOrAValuable value: node complexContents item) asMorph ] ]target: anObject  target ifNotNil: [ target removeDependent: self ].  anObject ifNotNil: [ anObject addDependent: self ].  target := anObjectnewAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpTexttasks  ^tasksbottomCenter  ^bounds bottomCentertoggleFillsOwner  self fillsOwner: self fillsOwner notthemeChanged  rowColors at: 1 put: (rowColors asSet size = 1 ifTrue: [ self theme backgroundColor ] ifFalse: [ rowColors at: 1 put: self theme backgroundColor contrastingColorAdjustment ]).  rowColors at: 2 put: self theme backgroundColor.  super themeChangedresistsRemoval  ^self hasProperty: #resistsRemovalonBlinkCursor  | para |  para := self paragraph ifNil: [ ^nil ].  Time millisecondClockValue < self blinkStart ifTrue: [ ^para showCaret: para focused ].  para showCaret: para showCaret not.  para caretRect ifNotNil: [:r |  self invalidRect: r ]updateCopyIcon  | copyIcon |  copyIcon := self submorphWithProperty: #tmCopyIcon.  self shouldCopy ifFalse: [ ^copyIcon ifNotNil: [ copyIcon delete ] ].  copyIcon ifNotNil: [ ^self ].  copyIcon := ImageMorph new form: CopyPlusIcon.  copyIcon setProperty: #tmCopyIcon toValue: true.  ^self addMorphFront: copyIconaddHandleSelector  ^addHandleSelectormouseStillDown: evt  actWhen == #whilePressed ifFalse: [ ^self ].  (self containsPoint: evt cursorPoint) ifTrue: [ self doButtonAction ]unhighlight  complexContents highlightingColor ifNotNil: [ (self valueOfProperty: #originalColor ifAbsent: [ Color black ]) ifNotNil: [:c |  self color: c ] ].  self allMorphsDo: [:m |  (m isKindOf: StringMorph) ifTrue: [ m color: (m valueOfProperty: #originalColor ifAbsent: [ self theme textColor ]) ] ]label: aStringOrTextOrMorph font: aFont  | containerMorph |  self removeAllMorphs.  containerMorph := AlignmentMorph new     borderWidth: 0;     layoutInset: 0;     cellInset: 2;     color: Color transparent;     hResizing: #shrinkWrap;     vResizing: #spaceFill;     wrapCentering: #center;     listCentering: #center;     cellPositioning: #center;     yourself.  (self iconPosition == #top or: [ self iconPosition == #bottom ]) ifTrue: [ containerMorph setAsColumn ] ifFalse: [ containerMorph setAsRow ].  label := aStringOrTextOrMorph.  self label ifNotNil: [ labelMorph := self label isMorph ifTrue: [ self label ] ifFalse: [ self newLabel: aFont ].        containerMorph addMorph: labelMorph ].  self icon ifNotNil: [ iconMorph := self icon asMorph.        (self iconPosition == #right or: [ self iconPosition == #bottom ]) ifTrue: [ containerMorph addMorphBack: iconMorph ] ifFalse: [ containerMorph addMorphFront: iconMorph ] ].  self addMorph: containerMorph.  self updateLabelEnablementinformMouseLeaveToLeftMorphsUsing: anEvent  | asMouseLeaveEvent |  asMouseLeaveEvent := anEvent asMouseLeave.  leftMorphs do: [:aLeftMorph |  self inform: asMouseLeaveEvent to: aLeftMorph originatedFrom: anEvent ifNotFocusedDo: [ overMorphs nextPut: aLeftMorph ] ]imageForm  ^self imageFormForRectangle: self fullBoundsdoButtonAction  self hasItems ifTrue: [ self menuItems first doButtonAction ]shouldInvalidateOnMouseTransition  ^self class showSplitterHandlesforwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectionselectableIndexBefore: anIndex  self shouldNotImplementdefaultTreeMorph  ^super defaultTreeMorph     doubleClickSelector: #doubleClick;     nodeStringGetter: #asString;     getMenuSelector: #menu:shifted:flashFillStyle  ^Color blackcalculateMaxVisibleRows  ^self calculateExactVisibleRows ceilingstartDrag: evt  | transferMorph draggedItem passenger |  dragItemSelector ifNotNil: [ ^self startDragExtended: evt ].  evt hand hasSubmorphs ifTrue: [ ^self ].  self dragEnabled ifFalse: [ ^self ].  ActiveHand anyButtonPressed ifFalse: [ ^self ].  draggedItem := self getListItem: (self mouseDownRow ifNil: [ self lastNonZeroIndex ]).  draggedItem ifNil: [ ^self ].  passenger := self model dragPassengersFor: draggedItem inMorph: self.  passenger ifNil: [ ^self ].  transferMorph := self model transferFor: passenger from: self.  transferMorph align: transferMorph draggedMorph bottomLeft with: evt position.  self mouseDownRow: nil.  transferMorph dragTransferType: (self model dragTransferTypeForMorph: self).  [ evt hand grabMorph: transferMorph ] ensure: [ Cursor normal show.        evt hand releaseMouseFocus: self ]fullBounds  fullBounds ifNotNil: [ ^fullBounds ].  fullBounds := bounds.  ^fullBoundsoldSelectedRowIndexes: anObject  self deprecated: 'Use #oldSelectedIndexes: instead' transformWith: '`@receiver oldSelectedRowIndexes: `@statements1' -> '`@receiver oldSelectedIndexes: `@statements1'.  self oldSelectedIndexes: anObjectshowAlways  self showState: #alwaysresizeCursor  ^Cursor resizeForEdge: #topLeftremoveHand: aHandMorph  (worldState hands includes: aHandMorph) ifFalse: [ ^self ].  aHandMorph dropMorphs.  self invalidRect: aHandMorph fullBounds.  worldState removeHand: aHandMorphthemeChanged  self submorphsDo: [:m |  m themeChanged ].  self changeddropVertex: ix event: evt fromHandle: handle  | p |  p := vertices at: ix.  (vertices size >= 2 and: [ ((vertices atWrap: ix - 1) distanceTo: p) < 3 or: [ ((vertices atWrap: ix + 1) distanceTo: p) < 3 ] ]) ifTrue: [ self deleteVertexAt: ix ].  evt shiftPressed ifTrue: [ self removeHandles ] ifFalse: [ self addHandles ]exportAsGIF  self exportAs: 'gif' using: GIFReadWritervTotalScrollRange  ^self vUnadjustedScrollRange + self vExtraScrollRangeinitializeAppearance  self     color: (Color black alpha: 0.15);     fillStyle: (self theme taskListFillStyleFor: self);     borderStyle: (self theme taskbarThumbnailNormalBorderStyleFor: self);     cornerStyle: (self theme taskbarThumbnailCornerStyleFor: self)focusBounds  ^self selectedTab ifNil: [ super focusBounds ] ifNotNil: [:tab |  tab focusBounds ]setLabel: aString  | frame announcement |  labelString := aString.  announcement := WindowLabelled new     window: self;     label: aString;     yourself.  self announce: announcement.  self currentWorld announcer announce: announcement.  label ifNil: [ ^self ].  label contents: aString.  self labelWidgetAllowance.  self isCollapsed ifTrue: [ self extent: (label width + labelWidgetAllowance) @ (self labelHeight + 2) ] ifFalse: [ label width > (bounds width - labelWidgetAllowance) ifTrue: [ label setBalloonText: label contents ] ifFalse: [ label setBalloonText: nil ].        label           fitContents;           setWidth: (label width min: bounds width - labelWidgetAllowance).        label align: label bounds topCenter with: bounds topCenter + (0 @ borderWidth).        collapsedFrame ifNotNil: [ collapsedFrame := collapsedFrame withWidth: label width + labelWidgetAllowance ] ].  frame := LayoutFrame new.  frame     leftFraction: 0.5;     topFraction: 0.5;     leftOffset: label width negated // 2;     topOffset: label height negated // 2.  label layoutFrame: frameisResized  ^falseusedWidthByPredominantDockingBarsOfChastes: predominantChastes  ^(self predominantDockingBarsOfChastes: predominantChastes) ifEmpty: [ 0 ] ifNotEmpty: [:predominants |  (predominants collect: [:each |  each width ]) sum ]searchedElement: anInteger  searchedElement := anInteger.  anInteger ifNil: [ self vScrollValue: self scrollValue y ] ifNotNil: [ self vScrollValue: (anInteger - 1) / self getListSize ]openAsIsIn: aWorld  aWorld addMorph: self.  (self submorphs notEmpty and: [ self submorphs first isSystemWindow ]) ifTrue: [ self submorphs first openedFullscreen ].  aWorld startSteppingSubmorphsOf: self.  self announceOpenedthemeChanged  self cornerStyle: (self theme tabGroupCornerStyleIn: self window).  self pageMorphs do: [:morph |  morph themeChanged ].  super themeChangedbasicKeyPressed: aChar  | nextSelection milliSeconds slowKeyStroke oldSelection list |  nextSelection := oldSelection := lastSelection.  milliSeconds := Time millisecondClockValue.  slowKeyStroke := milliSeconds - lastKeystrokeTime > 500.  lastKeystrokeTime := milliSeconds.  self searchedElement: nil.  slowKeyStroke ifTrue: [ lastKeystrokes := aChar asLowercase asString ] ifFalse: [ lastKeystrokes := lastKeystrokes , aChar asLowercase asString ].  model okToChange ifFalse: [ ^self ].  list := self allItems.  list detect: [:a |  a searchingString trimBoth asLowercase beginsWith: lastKeystrokes ] ifFound: [:nextSelectionNode |  nextSelection := list indexOf: nextSelectionNode ifAbsent: [ 0 ].        self searchedElement: nextSelectionNode.        lastSelection := nextSelection.        ^self vScrollValue: (nextSelection - 1) / list size ]printOn: aStream  super printOn: aStream.  label ifNotNil: [ aStream nextPutAll: ' named: ' , self labelString ]selectedColor  ^self svMorph selectedColorwantsYellowButtonMenu: aBoolean  self setProperty: #wantsYellowButtonMenu toValue: aBooleanwithoutListWrapper  ^complexContents withoutListWrappernewTaskFor: window  ^TaskbarTask morph: window state: #aNilState icon: nil label: 'a Label'minWidth  ^super minWidth max: self theme buttonMinWidthdoOneSubCycleFor: aWorld  | currentHand |  currentHand := self activeHand.  self doOneCycleFor: aWorld.  self activeHand: currentHandlayoutTopToBottom: aMorph in: newBounds  | inset extent block posX posY centering extraPerCell amount minX minY maxX maxY n height extra last cell size width sum vFill first |  size := properties minCellSize asPoint.  minX := size x.  minY := size y.  size := properties maxCellSize asPoint.  maxX := size x.  maxY := size y.  inset := properties cellInset asPoint y.  extent := newBounds extent.  n := 0.  vFill := false.  sum := 0.  width := height := 0.  first := last := nil.  block := [:m |  | sizeX props sizeY |  props := m layoutProperties ifNil: [ m ].  props disableTableLayout ifFalse: [ n := n + 1.        cell := LayoutCell new target: m.        props vResizing == #spaceFill ifTrue: [ cell vSpaceFill: true.              extra := m spaceFillWeight.              cell extraSpace: extra.              sum := sum + extra ] ifFalse: [ cell vSpaceFill: false ].        props hResizing == #spaceFill ifTrue: [ vFill := true ].        size := m minExtent.        sizeX := size x.        sizeY := size y.        sizeX < minX ifTrue: [ sizeX := minX ] ifFalse: [ sizeX > maxX ifTrue: [ sizeX := maxX ] ].        sizeY < minY ifTrue: [ sizeY := minY ] ifFalse: [ sizeY > maxY ifTrue: [ sizeY := maxY ] ].        cell cellSize: sizeY.        first ifNil: [ first := cell ] ifNotNil: [ last nextCell: cell ].        last := cell.        height := height + sizeY.        sizeX > width ifTrue: [ width := sizeX ] ] ].  properties reverseTableCells ifTrue: [ aMorph submorphsReverseDo: block ] ifFalse: [ aMorph submorphsDo: block ].  n > 1 ifTrue: [ height := height + ((n - 1) * inset) ].  (properties vResizing == #shrinkWrap and: [ properties rubberBandCells or: [ sum isZero ] ]) ifTrue: [ extent := (extent x max: width) @ height ].  (properties hResizing == #shrinkWrap and: [ properties rubberBandCells or: [ vFill not ] ]) ifTrue: [ extent := width @ (extent y max: height) ].  posX := newBounds left.  posY := newBounds top.  extra := extent x - width.  extra < 0 ifTrue: [ extra := 0 ].  extra > 0 ifTrue: [ vFill ifTrue: [ width := extent x ] ifFalse: [ centering := properties wrapCentering.              centering == #bottomRight ifTrue: [ posX := posX + extra ].              centering == #center ifTrue: [ posX := posX + (extra // 2) ] ] ].  extra := extent y - height.  extra < 0 ifTrue: [ extra := 0 ].  extraPerCell := 0.  extra > 0 ifTrue: [ sum isZero ifTrue: [ centering := properties listCentering.              centering == #bottomRight ifTrue: [ posY := posY + extra ].              centering == #center ifTrue: [ posY := posY + (extra // 2) ] ] ifFalse: [ extraPerCell := extra asFloat / sum asFloat ] ].  n := 0.  extra := last := 0.  cell := first.  [ cell == nil ] whileFalse: [ n := n + 1.        height := cell cellSize.        (extraPerCell > 0 and: [ cell vSpaceFill ]) ifTrue: [ extra := (last := extra) + (extraPerCell * cell extraSpace).              amount := extra truncated - last truncated.              height := height + amount ].        cell target layoutInBounds: (posX @ posY extent: width @ height).        posY := posY + height + inset.        cell := cell nextCell ]shouldntTakeLong: aBlock  ^self should: aBlock notTakeMoreThanMilliseconds: self longselectableIndexAbove: anIndex  ^anIndex - 1newLabelMorph: aStringOrMorph selected: selectedStringOrMorph  ^TabLabelMorph new     roundedCorners: #(1 4);     cornerStyle: self cornerStyle;     changeTableLayout;     listDirection: #leftToRight;     listCentering: #center;     layoutInset: (self theme tabLabelInsetFor: self);     hResizing: #shrinkWrap;     vResizing: #spaceFill;     label: aStringOrMorph selected: selectedStringOrMorph;     font: self font;     on: #mouseDown send: #tabClicked:with: to: self;     tabSelector: selfcollapseAll  self children do: #collapseAll.  self collapselazyIncrement: anInteger  lazyIncrement := anIntegerchooseExistingFileReference: title extensions: exts path: path  ^self chooseExistingFileReference: title extensions: exts path: path preview: nildefaultLabel  ^'Flash'borderColor  ^self borderStyle colordrawIconOnAthensCanvas: anAthensCanvas  self hasIcon ifFalse: [ ^self ].  anAthensCanvas setPaint: self iconForm.  anAthensCanvas drawShape: (0 @ 0 extent: self iconForm extent).  anAthensCanvas pathTransform translateX: self iconForm width + 2 Y: 0state: newState  newState == state ifTrue: [ ^self ].  state := newState.  self     adoptPaneColor: self paneColor;     changedselection  ^selectionadoptPaneColor: aColor  handlesMouseDown: evt  ^trueresetClickState  mouseClickState := nilmouseLeave: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseLeave from: sourceMorphtaskbarTask  (self valueOfProperty: #noTaskbarTask ifAbsent: [ false ]) ifTrue: [ ^nil ].  ^TaskbarTask morph: self state: self taskbarState icon: self taskbarIcon label: self taskbarLabelfillStyle  self assureExtension.  ^extension fillStyle ifNil: [ backgroundColor ifNil: [ Color transparent ] ]defaultBorderColor  ^#insetupdateSelection  self buttonMorph ifNotNil: [:m |  m selected: self isSelected ].  self changed: #isSelectedscrollTarget: aMorph  self scroller     removeAllMorphs;     addMorph: aMorph.  self updateScrollbarsfallbackMenuExplanations  | workspace wsBindings |  wsBindings := Dictionary newFrom: {(#menu -> self)}.  workspace := Smalltalk tools workspace openContents: '"Something is wrong with this menu. To investigate just debug following expression:"menu debug'.  workspace     label: 'Fallback menu explanations';     setBindings: wsBindingstearDown  cases do: [:each |  each delete ].  super tearDowntoggleRectangle  ^(bounds left + self indentGap) @ bounds top extent: container toggleImageWidth @ bounds heighteditor  editor ifNotNil: [ ^editor ].  ^self installEditorToReplace: nilcornerRadius  ^cornerRadiusbuildWindowMenu  ^self menuBuilder menuhasMenu  ^menu notNil or: [ retrievingBlock notNil ]mouseDown: anEvent  releaseMouseFocus: aMorph  self mouseFocus == aMorph ifTrue: [ self releaseMouseFocus ]bottomOffset: anInteger  bottomOffset := anIntegerrotationCenter: aPointOrNil  | newRef box |  aPointOrNil ifNotNil: [ box := self bounds.        newRef := box origin + (aPointOrNil * box extent).        self setRotationCenterFrom: newRef ]veryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  objectToView := deepCopier references at: objectToView ifAbsent: [ objectToView ]isTranslucentButNotTransparent  (color isColor and: [ color isTranslucentButNotTransparent ]) ifTrue: [ ^true ].  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) ifTrue: [ ^true ].  ^falseupdateSelectionFromModel  self listModel selection ifNotNil: [:selHolder |  self isSelectionUpdateFromView ifTrue: [ self listModel selectionChanged.              self selectionChanged ] ifFalse: [ selHolder updateView: client forModel: self listModel ] ]deselect: evt  self isSelected: false.  subMenu ifNotNil: [ owner ifNotNil: [ owner activeSubmenu: nil ].        self removeAlarm: #deselectTimeOut: ]increment  self value: self value + 1showRightOrBottom  self show.  rightOrBottom do: [:m |  m show ]outerBounds  | box |  box := self bounds.  self hasDropShadow ifTrue: [ box := self expandFullBoundsForDropShadow: box ].  ^boxtabRefreshed: aTab  self setMultipleContentsthemeChanged  self     setProperty: #textColor toValue: self theme textColor;     updateList.  self selectionColor ifNotNil: [ self selectionColor: self theme selectionColor ].  super themeChangedautoAccept  ^autoAcceptchangeColor  | dialog |  dialog := ColorSelectorDialogWindow new     title: 'Choose color';     selectedColor: self color.  self openModal: dialog.  dialog cancelled ifFalse: [ self fillStyle: dialog selectedColor ]getColorSelector  ^getColorSelectorreset  self subclassResponsibilitykeyText  ^keyTextacceptOnFocusChange  ^acceptOnFocusChangeaddMorph: aMorph asElementNumber: aNumber  (submorphs includes: aMorph) ifTrue: [ aMorph privateDelete ].  aNumber <= submorphs size ifTrue: [ self addMorph: aMorph inFrontOf: (submorphs at: aNumber) ] ifFalse: [ self addMorphBack: aMorph ]canvas: x  canvas := xmeasureContents  ^super measureContents ceiling + (self offset * 2) asPointcrAction  ^self valueOfProperty: #crActionbasicBoxForSimpleHalos  | w |  w := self world ifNil: [ target outermostWorldMorph ].  ^((self worldBoundsForMorph: target topRendererOrSelf) expandBy: self handleAllowanceForIconicHalos) intersect: (w bounds insetBy: 8 @ 8) ifNone: [ self error: 'should not happen' ]activate: evt  evt hand newMouseFocus: selfdeny: aStringOrText title: aString  ^self theme denyIn: self text: aStringOrText title: aStringsearchFor: aStringOrText  pattern := aStringOrText asString trim.  ^self realSearchaddDragHandle: haloSpec  (self addHandle: haloSpec on: #mouseDown send: #startDrag:with: to: self) on: #mouseMove send: #doDrag:with: to: selfjustifiedPadFor: spaceIndex font: aFont  | pad |  internalSpaces = 0 ifTrue: [ ^0 ].  ^(aFont notNil and: [ aFont isSubPixelPositioned ]) ifTrue: [ paddingWidth * 1.0 / internalSpaces ] ifFalse: [ pad := paddingWidth // internalSpaces.        spaceIndex <= (paddingWidth \\ internalSpaces) ifTrue: [ pad + 1 ] ifFalse: [ pad ] ]lineColor  ^self borderColordisplaySelectionBarOn: aCanvas  | visibleRectangle line |  selectionStart ifNil: [ ^self ].  selectionStop ifNil: [ ^self ].  visibleRectangle := aCanvas clipRect.  selectionStart textLine = selectionStop textLine ifFalse: [ ^self ].  line := selectionStart textLine.  aCanvas fillRectangle: (visibleRectangle left @ line top corner: visibleRectangle right @ line bottom) color: self selectionBarColornewHueSelector: aModel getHue: getSel setHue: setSel help: helpText  ^self theme newHueSelectorIn: self for: aModel getHue: getSel setHue: setSel help: helpTextexpandAll: aMorph except: aBlock  | allChildren |  (aBlock value: aMorph complexContents) ifFalse: [ ^self ].  aMorph toggleExpandedState.  allChildren := OrderedCollection new: 10.  aMorph recursiveAddTo: allChildren.  allChildren do: [:each |  (each canExpand and: [ each isExpanded not ]) ifTrue: [ self expandAll: each except: aBlock ] ]defaultBorderWidth  ^1fastFramingOn  ^self theme settings fastDragging and: [ self isFlexed not ]pageSize  ^pageSizenewSliderMorph  | slider |  slider := self theme builder newBracketSliderFor: self getValue: #value setValue: #value: min: 0 max: 100 quantum: 1 getEnabled: #enabled help: nil.  slider fillStyle: self defaultSliderFillStyle.  ^slidertestUpdatingSelectionsOnUpdateWithRemoval  | c w t |  c := ClassTreeExample new.  [ w := c openOn: Collection.  t := c dependents last.  t expandAll.  c selectItems: {Bag .         CharacterSet}.  c selection selectedNodes do: [:e |  self assert: (t selectedMorphList anySatisfy: [:sm |  sm complexContents = e ]) ].  c rootClass: Bag.  c updateList.  self assert: t selectedMorphList size equals: 1.  self assert: t selectedMorphList first complexContents withoutListWrapper identicalTo: Bag.  c selection selectedNodes do: [:e |  self assert: (t selectedMorphList anySatisfy: [:sm |  sm complexContents = e ]) ] ] ensure: [ w close ]removeOnlyLastSelected: aBoolean  self listManager removeOnlyLastSelected: aBooleantext: t textStyle: s  text := t.  defaultColor := (t attributesAt: 1) detect: [:e |  e isKindOf: TextColor ] ifNone: [ self color ].  textStyle := s.  paragraph ifNotNil: [ paragraph textStyle: s ]sticky: aBoolean  sticky := aBooleanbounds: b  super bounds: b.  self adjustLayoutprepareForRotating  indicateModalChild  | fs c w d |  fs := self fillStyle.  c := self color alphaMixed: 0.5 with: Color black.  w := self world.  d := 0.  self assureExtension.  2 timesRepeat: [ (Delay forDuration: d milliSeconds) wait.        d := 200.        extension fillStyle: c.        self privateColor: c.        self invalidRect: self bounds.        w ifNotNil: [ w displayWorldSafely ].        (Delay forDuration: d milliSeconds) wait.        self fillStyle: fs.        w ifNotNil: [ w displayWorldSafely ].        self invalidRect: self bounds ]splitterLeft  | splitters |  splitters := (self siblingSplitters select: [:each |  each left < self left and: [ self overlapsVertical: each ] ]) asSortedCollection: [:a :b |  a left > b left ].  ^splitters ifEmpty: [ nil ] ifNotEmpty: [:s |  s first ]fullBounds  fullBounds ifNotNil: [ ^fullBounds ].  self computeFullBounds.  ^fullBoundssetRotationCenterFrom: aPoint  referencePosition := aPoint.  originalCenter := self center.  originalAngle := self headingcolor: aColor  color = aColor ifTrue: [ ^self ].  color := aColor.  self releaseCachedStateicon  ^(target perform: iconSelector) ifNil: [ super icon ]handleKeystrokeWithKeymappings: aKeystrokeEvent  self allowsKeymapping ifTrue: [ self dispatchKeystrokeForEvent: aKeystrokeEvent ]paneColorTracksModel  ^trueactualClass  ^FTPropertyColumnSortingStrategybaseline  ^baselinepagerColor  ^self color darker alpha: 0.6rightFraction  ^rightFractionlabelsAndPages: assocs  self contentMorph removeAllMorphs.  self tabSelectorMorph removeAllMorphs.  assocs do: [:a |  self addPage: a value label: a key ]newImage: aForm  ^self theme newImageIn: self form: aFormmodel: anObject  model ifNotNil: [ model removeDependent: self ].  anObject ifNotNil: [ anObject addDependent: self ].  model := anObjecttaskbarCloseAllToRight  | wasFound |  wasFound := false.  self worldTaskbar ifNotNil: [:worldTaskbar |  worldTaskbar orderedTasks copy do: [:task |  wasFound ifTrue: [ task morph delete ] ifFalse: [ wasFound := task morph == self ] ] ]isHorizontalScrollBarVisible  ^horizontalScrollBar ifNil: [ false ] ifNotNil: [ self horizontalScrollBar owner isNotNil ]arrowSpec: specPt  self setProperty: #arrowSpec toValue: specPt.  self computeBoundsvUpdateScrollbar  self vScrollbarNeeded ifTrue: [ self           vShowScrollbar;           vResizeScrollbar ] ifFalse: [ self vHideScrollbar ]noteNewOwner: aMorph  super noteNewOwner: aMorph.  (self isFullscreen and: [ labelArea owner notNil ]) ifTrue: [ self           beWithoutGrips;           removeLabelArea;           makeBorderless.        (self submorphs size = 1 and: [ self submorphs first isKindOf: PanelMorph ]) ifTrue: [ self submorphs first roundedCorners: #() ] ]delete  super delete.  morph ifNotNil: [ morph delete ].  retrievingProcess ifNotNil: [ retrievingProcess terminate ].  self triggerEvent: #tabDeleted with: selfextent: aPoint  bounds extent = aPoint ifTrue: [ ^self ].  self changed.  bounds := (bounds topLeft extent: aPoint) rounded.  super layoutChanged.  self changedhandlesMouseDown: event  ^truecellPositioning  ^cellPositioninghandleFatalDrawingError: errMsg  self worldRenderer deferUpdates: false.  self primitiveError: errMsgresetRootInfo  hasToggleAtRoot := nillabelClicked  labelClickable ifTrue: [ self toggleSelected ].  self doAnnounce: (LabelClicked source: self stateChanged: labelClickable)testForward  | t |  cases := {(t := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ self assert: t forwardDirection equals: 0.0 ]initializeLayout  self     changeTableLayout;     layoutInset: 2;     cellInset: 2;     listDirection: #leftToRight;     wrapDirection: #topToBottom;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     extent: self minimumExtentinitialize  super initialize.  self smoothingOnrefresh  lastRefresh := Time millisecondClockValue.  UIManager default uiProcess == Processor activeProcess ifTrue: [ self currentWorld doOneCycleNow ]initializeFilter  initialDataSource := table dataSource.  isEditingSemaphore := Semaphore new.  self spawnFilterUpdateThreadaddMorphFront: aMorph  ^self addMorphInFrontOfLayer: aMorphnewVertex: ix event: evt fromHandle: handle  | pt |  pt := evt cursorPoint.  self insertVertexAt: ix put: pt.  evt hand newMouseFocus: (handles at: (ix + 1) * 2 - 1)adoptPaneColor: aColor  aColor ifNil: [ ^self ].  self sliderColor: aColortheme  (self valueOfProperty: #theme) ifNotNil: [:t |  ^t ].  ^self class themerotationDegrees  ^0.0cancelEdits  self releaseParagraphmarried: aBoolean  self item married: aBoolean.  self changed: #marriedthemeChanged  self     layoutInset: (self theme buttonLabelInsetFor: self);     cornerStyle: (self theme buttonCornerStyleIn: self window);     fillStyle: self themedFillStyle.  label ifNotNil: [ label color: self fillStyle asColor contrastingBlackAndWhiteColor ].  super themeChangedquestionWithoutCancel: aStringOrText  ^self questionWithoutCancel: aStringOrText title: 'Question' translatedveryDeepInner: deepCopier  super veryDeepInner: deepCopier.  positionOffset := positionOffset veryDeepCopyWith: deepCopier.  angleOffset := angleOffset veryDeepCopyWith: deepCopier.  growingOrRotating := growingOrRotating veryDeepCopyWith: deepCopier.  directionArrowAnchor := directionArrowAnchor.  haloBox := haloBox.  originalExtent := originalExtent.  nameMorph := nameMorphselectedPressedBorderStyle  ^self theme taskbarItemSelectedPressedBorderStyleFor: selfclick  clickSelector ifNotNil: [ clickClient perform: clickSelector with: firstClickDown ]handlesDropShadowInHand  ^self theme handlesWindowDropShadowInHandFor: selfupdateCacheCanvas: aCanvas  | subBnds rectList nPix |  subBnds := Rectangle merging: (submorphs collect: [:m |  m fullBounds ]).  rectList := damageRecorder invalidRectsFullBounds: subBnds.  damageRecorder reset.  (rectList isEmpty and: [ cacheCanvas notNil and: [ cacheCanvas extent = subBnds extent ] ]) ifTrue: [ ^self ].  self submorphsDo: [:m |  m wantsToBeCachedByHand ifFalse: [ cacheCanvas := nil.              cachedCanvasHasHoles := true.              ^self ] ].  (cacheCanvas isNil or: [ cacheCanvas extent ~= subBnds extent ]) ifTrue: [ cacheCanvas := (aCanvas allocateForm: subBnds extent) getCanvas.        cacheCanvas translateBy: subBnds origin negated during: [:tempCanvas |  self drawSubmorphsOn: tempCanvas ].        self submorphsDo: [:m |  (m areasRemainingToFill: subBnds) isEmpty ifTrue: [ ^cachedCanvasHasHoles := false ] ].        nPix := cacheCanvas form tallyPixelValues first.        cachedCanvasHasHoles := (nPix = 48 and: [ submorphs size = 1 and: [ submorphs first wantsRoundedCorners ] ]) ifTrue: [ false ] ifFalse: [ nPix > 0 ].        ^self ].  cacheCanvas translateBy: subBnds origin negated during: [:cc |  rectList do: [:r |  cc clipBy: r during: [:c |  c fillColor: Color transparent.                    self drawSubmorphsOn: c ] ] ]lastKeystrokes: anObject  lastKeystrokes := anObjectnewVSplitter  ^ProportionalSplitterMorph new setProperty: #model toValue: selflayoutInBounds: cellBounds  | box aSymbol |  cellBounds = self bounds ifTrue: [ ^self ].  cellBounds extent = self bounds extent ifTrue: [ ^self position: cellBounds origin ].  box := bounds.  self hResizing == #shrinkWrap ifTrue: [ box := box origin extent: self minExtent x @ box height ].  self vResizing == #shrinkWrap ifTrue: [ box := box origin extent: box width @ self minExtent y ].  self hResizing == #spaceFill ifTrue: [ box := box origin extent: cellBounds width @ box height ].  self vResizing == #spaceFill ifTrue: [ box := box origin extent: box width @ cellBounds height ].  aSymbol := (owner ifNil: [ self ]) cellPositioning.  box := box align: (box perform: aSymbol) with: (cellBounds perform: aSymbol).  self bounds: boxdispatchWindowEvent: anEvent with: aMorph  aMorph isWorldMorph ifFalse: [ ^#rejected ].  anEvent wasHandled ifTrue: [ ^self ].  ^aMorph handleEvent: anEventfont: aFont  font := aFont.  ^self font: font emphasis: emphasisrecenter  self repositiontoggleRectangle  | h |  h := bounds height.  ^(bounds left + (13 * indentLevel)) @ bounds top extent: 9 @ haddCollapseHandle: handleSpec  | collapseHandle |  (target owner notNil and: [ target owner isWorldOrHandMorph ]) ifFalse: [ ^self ].  collapseHandle := self addHandle: handleSpec on: #mouseDown send: #mouseDownInCollapseHandle:with: to: self.  collapseHandle on: #mouseUp send: #maybeCollapse:with: to: self.  collapseHandle on: #mouseMove send: #setDismissColor:with: to: selfrowAtLocation: aPoint  | y |  y := aPoint y.  submorphs ifEmpty: [ ^nil ].  submorphs doWithIndex: [:m :idx |  m topLeft y >= y ifTrue: [ ^idx - 1 max: 1 ] ].  ^submorphs sizewidth  ^0setCenteredBalloonText: aString  self setBalloonText: aStringgetLastCharacter  | aString |  ^(aString := text string) size > 0 ifTrue: [ aString last asString ] ifFalse: [ '·' ]colorForInsets  ^self paneColor colorForInsetsdotOfSize: diameter forDirection: aDirection  | form |  form := Form extent: diameter @ diameter depth: Display depth.  form getCanvas fillOval: form boundingBox color: self color.  ^formtextOwner: ignored  highlightForDrop: aBoolean  self setProperty: #highlightedForDrop toValue: aBoolean.  self changedkeystrokeActionSelector  ^keystrokeActionSelectorupdateEnabled  self model ifNotNil: [:m |  self getEnabledSelector ifNotNil: [:s |  self enabled: (m perform: s) ] ]setOtherSelection: otherOrNil  otherSelection := otherOrNil.  otherOrNil ifNil: [ super borderColor: Color blue ] ifNotNil: [ itemsAlreadySelected := otherSelection selectedItems.        super borderColor: Color green ]handlesKeyboard: evt  ^truestyle: aText  add: aLabelString subMenu: aMenuMorph  self add: aLabelString icon: nil subMenu: aMenuMorphtoggleImageWidth  ^self expandedToggleImage width max: self notExpandedToggleImage widthactiveTask  ^self tasks detect: [:t |  t isActive ] ifNone: [  ]alwaysShowVScrollbar  ^self class alwaysShowVScrollbarbuilder: aPragmaMenuBuilder  builder := aPragmaMenuBuilderisMorphicEvent  ^truerealSearch  self subclassResponsibilityprivateInvalidateMorph: aMorph  removeAlarm: aSelector for: aTarget  self alarms detect: [:any |  any receiver == aTarget and: [ any selector == aSelector ] ] ifFound: [:alarm |  self alarms remove: alarm ]initializeKeyBindings  super initializeKeyBindings.  self bindKeyCombination: Character space asKeyCombination toAction: [ self interactWithSelection ]newSVSelector: aColor help: helpText  ^self theme newSVSelectorIn: self color: aColor help: helpTextkeyboardFocusChange: aBoolean  aBoolean ifTrue: [ self editView selectAll ] ifFalse: [ self editView selectFrom: 1 to: 0 ].  super keyboardFocusChange: aBooleanlabel  ^(self labelMorph ifNil: [ ^'' ]) contentsnewButtons  ^{(self newOKButton isDefault: true) .   self newCancelButton}newOverflowRowForAll: aCollectionOfMorphs  ^self theme newOverflowRowIn: self forAll: aCollectionOfMorphsbrickImageForm: aColor  | canvas rect |  rect := self fullBounds origin extent: self measureContents.  canvas := Display defaultCanvasClass extent: rect extent depth: Display depth.  canvas form fillColor: aColor.  canvas translateBy: rect topLeft negated during: [:tempCanvas |  tempCanvas fullDrawMorph: self ].  ^canvas form offset: rect topLeftinteractionStates  ^#(normal mouseOver pressed disabled selected selectedPressed selectedMouseOver selectedDisabled)actionSelector  ^actionSelectortoggleImageHeight  ^self expandedToggleImage height max: self notExpandedToggleImage heightstart: aNumber  startValue := aNumberselectionColor  ^self focused ifTrue: [ self theme selectionColor ] ifFalse: [ self theme unfocusedSelectionColor ]fullBounds  self contents ifNil: [ self contents: 'String Morph' ].  ^super fullBoundsmouseLeaveDragging: evt  self eventHandler ifNotNil: [ self eventHandler mouseLeaveDragging: evt fromMorph: self ]stayUp  ^stayUpfitTargetOwner  ^fitTargetOwnerchangeReverseCells  self reverseTableCells: self reverseTableCells notnewIncrementalSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newIncrementalSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpTextchooseExistingFileReference: title extensions: exts path: path  ^self chooseExistingFileReference: title extensions: exts path: path preview: nilmouseDown: anEvent  lastMouse := anEvent cursorPointinitialize  super initialize.  lastKeystrokeTime := 0.  lastKeystrokes := ''.  lastSelection := 0.  removeOnlyLastSelected := falseresetPotentialDropRow  potentialDropRow ifNotNil: [ potentialDropRow ~= 0 ifTrue: [ potentialDropRow := 0.              self changed ] ]addAlarm: aSelector withArguments: args at: scheduledTime  | scheduler |  scheduler := self alarmScheduler.  scheduler ifNotNil: [ scheduler addAlarm: aSelector withArguments: args for: self at: scheduledTime ]addMenuHandle: haloSpec  self addHandle: haloSpec on: #mouseDown send: #doMenu:with: to: selfpassKeyboardFocusTo: otherMorph  self flag: #pharoFixMe.  self world ifNotNil: [:world |  world handsDo: [:h |  h keyboardFocus == self ifTrue: [ h newKeyboardFocus: otherMorph ] ] ]displayExtentChanged  self updateBoundsmarriedMorph  ^(self theme newCheckboxIn: self currentWorld for: self getSelected: #married setSelected: #married: getEnabled: nil label: '' help: nil) color: Color transparentwantsKeyboardFocusFor: aSubmorph  ^falseaddTransparentSpacerOfSize: aPoint  self addMorphBack: (self transparentSpacerOfSize: aPoint)translateBy: delta  self releaseCachedStatefilterField  ^(function isKindOf: FTFilterFunction) ifTrue: [ function field ] ifFalse: [ nil ]justDroppedInto: aMorph event: anEvent  | ownerBounds leftRegion droppedPosition rightRegion topRegion bottomRegion |  super justDroppedInto: aMorph event: anEvent.  self owner ifNil: [ ^self ].  ownerBounds := aMorph bounds.  topRegion := ownerBounds bottom: ownerBounds top + (ownerBounds height // 5).  bottomRegion := ownerBounds top: ownerBounds bottom - (ownerBounds height // 5).  leftRegion := ownerBounds right: ownerBounds left + (ownerBounds width // 5).  leftRegion := leftRegion top: topRegion bottom.  leftRegion := leftRegion bottom: bottomRegion top.  rightRegion := ownerBounds left: ownerBounds right - (ownerBounds width // 5).  rightRegion := rightRegion top: topRegion bottom.  rightRegion := rightRegion bottom: bottomRegion top.  droppedPosition := anEvent position.  (topRegion containsPoint: droppedPosition) ifTrue: [ ^self adhereToTop ].  (bottomRegion containsPoint: droppedPosition) ifTrue: [ ^self adhereToBottom ].  (leftRegion containsPoint: droppedPosition) ifTrue: [ ^self adhereToLeft ].  (rightRegion containsPoint: droppedPosition) ifTrue: [ ^self adhereToRight ].  self beFloatinglines  ^lines ifNil: [ ^Array new ]mouseOverThumbButtonFillStyle  ^self theme scrollbarMouseOverThumbButtonFillStyleFor: selfextraSpace  ^tabs max: [:each |  each extraSpaceForActions ]= aTaskbarTask  ^self species = aTaskbarTask species and: [ self morph == aTaskbarTask morph and: [ self state == aTaskbarTask state and: [ self icon = aTaskbarTask icon and: [ self label = aTaskbarTask label ] ] ] ]splitsTopAndBottom  ^splitsTopAndBottomisDefault  locked == true ifTrue: [ ^false ].  visible == false ifTrue: [ ^false ].  sticky == true ifTrue: [ ^false ].  balloonText ifNotNil: [ ^false ].  externalName ifNotNil: [ ^false ].  eventHandler ifNotNil: [ ^false ].  otherProperties ifNotNil: [ otherProperties isEmpty ifFalse: [ ^false ] ].  ^trueclick: anEvent fromMorph: aMorph  ^self notify: anEvent from: aMorphnormalThumbBorderStyle  ^self theme scrollbarNormalThumbBorderStyleFor: selfrotationDegrees  ^self forwardDirectionaction  ^actionisSteppingSelector: aSelector  | aWorld |  ^(aWorld := self world) ifNil: [ false ] ifNotNil: [ aWorld isStepping: self selector: aSelector ]testClickFromMorph  morph eventHandler on: #click send: #value to: true.  self assert: (morph click: nil) identicalTo: truedropElements: aCollection index: rowIndex  ^falseremoveFromWorld  | mins animation |  mins := self tasks select: [:t |  t isMinimized ].  animation := self theme shouldUseAnimations.  animation ifTrue: [ self theme useAnimation: false ].  [ mins do: [:t |  t morph           restore;           resetCollapsedFrame ].  self delete.  mins do: [:t |  t morph minimize ] ] ensure: [ animation ifTrue: [ self theme useAnimation: true ] ]elementAt: rowIndex  self subclassResponsibilityfirstVisibleRowIndex  ^self container firstVisibleRowIndexmouseUp: anEvent  (self bounds containsPoint: anEvent cursorPoint) ifFalse: [ anEvent hand showTemporaryCursor: nil.        self           setDefaultColors;           changed ]collapse  self isCollapsed ifFalse: [ self collapseOrExpand ]embeddedInMorphicWindowLabeled: labelString  | window |  window := (SystemWindow labelled: labelString) model: nil.  window setStripeColorsFrom: (self theme windowColorFor: self).  window addMorph: self frame: (0 @ 0 extent: 1 @ 1).  ^windowformerOwner  ^self valueOfProperty: #formerOwnerreset  morphicLayerNumber  ^5invalidRect: damageRect from: aMorph  aMorph == self ifTrue: [ super invalidRect: damageRect from: self ] ifFalse: [ super invalidRect: (((transform localBoundsToGlobal: damageRect) intersect: bounds ifNone: [ ^self ]) expandBy: 1) from: self ]pathIn: aCollection  self parentNode ifNotNil: [ (aCollection includes: self parentNode) ifFalse: [ self parentNode pathIn: aCollection ] ].  aCollection add: self.  ^aCollectionnewDecrementButton  ^(self theme builder newButtonFor: self action: #decrement getEnabled: #minEnabled label: (self newButtonLabel: #left ofSize: 24) help: nil)     vResizing: #spaceFill;     width: 64;     roundedCorners: #(1 2);     setProperty: #wantsKeyboardFocusNavigation toValue: false;     on: #mouseStillDown send: #decrement to: selftestSelectableIndexAbove  self assert: (strategy selectableIndexAbove: #(2 3)) equals: #(1 3)selectLast  self selectionModeStrategy selectLastheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]updateColor  | col |  self getColorSelector ifNotNil: [ col := (self model perform: self getColorSelector) ifNil: [ Color transparent ].        self setColor: col ]isExplicite  self deprecated: 'Use #isExplicit instead' transformWith: '`@receiver isExplicite' -> '`@receiver isExplicit'.  ^self isExplicitmouseMove: evt on: aTargetMorph  (aTargetMorph isNil or: [ aTargetMorph highlightedForMouseDown not ]) ifTrue: [ self allNodeMorphs do: [:m |  m highlightedForMouseDown ifTrue: [ m highlightForMouseDown: false ] ].        aTargetMorph ifNotNil: [ aTargetMorph highlightForMouseDown.              (self autoMultiSelection and: [ evt shiftPressed not ]) ifTrue: [ self autoMultiSelect: aTargetMorph.                    self selectionChanged ] ] ]drawMouseDownHighlightOn: aCanvas  self highlightedForMouseDown ifTrue: [ container ifNil: [ ^super drawMouseDownHighlightOn: aCanvas ].        aCanvas frameRectangle: self bounds width: 1 colors: {container mouseDownHighlightColor .               Color transparent} dashes: #(1 1) ]setHand: aHand  source := aHandopenDialogWindowIn: aWindow title: aTitle selectedtems: aCollection  | dialog |  dialog := self dialogWindowIn: aWindow title: aTitle selectedtems: aCollection.  aWindow openModal: dialog.  ^dialog cancelled ifFalse: [ self selectedItems ]stateChanged  ^stateChangedjustGrabbedFrom: formerOwner  (self isRenderer and: [ self hasSubmorphs ]) ifTrue: [ self firstSubmorph justGrabbedFrom: formerOwner ]selectNextTab  self selectedIndex: self selectedIndex \\ self tabs size + 1initialize  alreadyActivated := falsestyleSymbols  ^#(plain inset insetNoHighlight raised raisedNoHighlight)reset  beMultipleSelection  selectionStrategy := FTMultipleSelection table: selfhasHalo: aBool  super hasHalo: aBool.  aBool ifFalse: [ (self hasProperty: #deleting) ifFalse: [ self delete ] ]initialize  super initialize.  self changeProportionalLayout.  state := TabEnabled tab: self.  closeable := true.  label := self buildLabel: 'tab' withIcon: self defaultIcon.  closeIcon := AlphaImageMorph withForm: self class closeIcon scaledByDisplayScaleFactor.  actions := OrderedCollection new.  retrievingSemaphore := Semaphore new.  self addLabel.  self addIcon.  self addActionsToIconaddCornerGrips  self addMorphBack: (TopLeftGripMorph new           target: self;           position: self position).  self addMorphBack: (TopRightGripMorph new           target: self;           position: self position).  self addMorphBack: (BottomLeftGripMorph new           target: self;           position: self position).  self addMorphBack: (BottomRightGripMorph new           target: self;           position: self position)displayExtentChanged  self updateBoundsaddAlarm: aSelector with: arg1 at: scheduledTime  ^self addAlarm: aSelector withArguments: (Array with: arg1) at: scheduledTimetaskbarButtonFor: aTaskBar  ^self morph taskbarButtonFor: aTaskBarbottomRight  ^bounds bottomRightbottomOffset  ^bottomOffsethandleMouseEnter: anEvent  anEvent isDraggingEvent ifTrue: [ (self handlesMouseOverDragging: anEvent) ifTrue: [ anEvent wasHandled: true.              self mouseEnterDragging: anEvent ].        ^self eventHandler ifNotNil: [:handler |  handler mouseEnterDragging: anEvent fromMorph: self ] ].  self wantsBalloon ifTrue: [ anEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime ].  ^(self handlesMouseOver: anEvent) ifTrue: [ anEvent wasHandled: true.        self mouseEnter: anEvent ] ifFalse: [ self eventHandler ifNotNil: [:handler |  handler mouseEnter: anEvent fromMorph: self ] ]softRetrieveMorph  | oldIcon |  morph ifNotNil: [ ^self ].  retrievingProcess ifNotNil: [ retrievingProcess isTerminated ifFalse: [ ^self ] ].  oldIcon := self icon ifNotNil: [:i |  i form ].  label icon: TabBuildingIconMorph new.  retrievingProcess := [ [ morph := retrievingBlock value ] ensure: [ UIManager default defer: [ self icon: oldIcon.              self triggerEvent: #tabRefreshed with: self ].        [ retrievingSemaphore isEmpty ] whileFalse: [ retrievingSemaphore signal ] ] ] forkAt: Processor activePriority - 2addColumn: aTreeColumn afterIndex: aPosition  aTreeColumn container: self.  self columns add: aTreeColumn afterIndex: aPosition.  self columnsChanged.  self updateColumnMorphs.  self updateListexpandSilently: aMorph suchThat: aBlock  (aBlock value: aMorph complexContents) ifTrue: [ aMorph isExpanded ifFalse: [ aMorph expand ].        aMorph childrenDo: [:ch |  self expandSilently: ch suchThat: aBlock ] ]index  ^self container columns indexOf: selfhandsReverseDo: aBlock  ^hands reverseDo: aBlockgetColorSelector: aSymbol  getColorSelector := aSymbol.  self update: getColorSelectorposition: pos  ^super position: pos asIntegerPointnewCancelButtonFor: aModel  ^self theme newCancelButtonIn: self for: aModelclipSubmorphs  extension ifNil: [ ^false ].  ^extension clipSubmorphs ifNil: [ false ]borderStyle  ^(target notNil and: [ self showBoundsInHalo and: [ target isWorldMorph not ] ]) ifTrue: [ super borderStyle ] ifFalse: [ SimpleBorder width: 0 color: Color transparent ]setBorderStyle: aSymbol  | aStyle |  aStyle := self borderStyleForSymbol: aSymbol.  aStyle ifNil: [ ^self ].  (self canDrawBorder: aStyle) ifTrue: [ self borderStyle: aStyle ]newAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpTextnewButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel labelForm: aForm help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: (AlphaImageMorph new image: aForm) help: helpTextgripLayoutFrame  ^(0 @ 0 corner: 0 @ 0) asLayoutFrame     topOffset: -27;     rightOffset: self defaultWidthnewButtonLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newButtonLabelIn: self for: aModel label: aString getEnabled: enabledSelpath  ^self pathIn: OrderedCollection newminimumExtent  | ext |  (ext := self valueOfProperty: #minimumExtent) ifNotNil: [ ^ext ].  ^100 @ 80mouseListeners  ^mouseListenershandlesMouseOverDragging: evt  ^trueinitializeUpButton  upButton := self theme newScrollBarUpButtonFor: self.  upButton color: self thumbColor.  upButton on: #mouseDown send: #scrollUpInit to: self.  upButton on: #mouseUp send: #finishedScrolling to: self.  self updateUpButtonImage.  upButton     borderWidth: 1;     borderColor: Color lightGray.  upButton cornerStyle: (self theme scrollbarButtonCornerStyleIn: self window).  upButton on: #mouseUp send: #finishedScrolling: to: self.  upButton on: #mouseEnter send: #mouseEnterUpButton: to: self.  upButton on: #mouseLeave send: #mouseLeaveUpButton: to: self.  self addMorph: upButtonlastClickedMorph  ^lastClickedMorphselectionTextColor  ^color negatedborderInitialize  borderColor := self defaultBorderColor.  borderWidth := self defaultBorderWidthlabelGraphic  ^graphicalMorph formtheme  (self valueOfProperty: #theme) ifNotNil: [:t |  ^t ].  ^(self owner ifNil: [ self class ]) themestartColumnIndex: anObject  startColumnIndex := anObjectlabelBounds  | deltaY deltaX labelWidth treshold bnd |  bnd := self innerBounds.  labelWidth := self font widthOfStringOrText: self label.  deltaY := (self height - self font height) / 2.  treshold := bnd left + self labelGap + labelWidth.  deltaX := (slider left < treshold or: [ sliderShadow visible and: [ sliderShadow left < treshold ] ]) ifTrue: [ bnd width - self labelGap - labelWidth ] ifFalse: [ self labelGap ].  ^bnd translateBy: deltaX @ deltaYreset  invalidRects := OrderedCollection new: 15.  totalRepaint := falseselectionUpdateFromViewWhile: aBlock  | prev |  prev := self isSelectionUpdateFromView.  isSelectionUpdateFromView := true.  aBlock ensure: [ isSelectionUpdateFromView := prev ]openCenteredInWorld  self     fullBounds;     openInWorld;     center: self world clearArea centerscrollUp: count  self setValue: (value - (scrollDelta * count) - 0.000001 max: 0.0)veryDeepInner: deepCopier  | namesOfWeaklyCopiedProperties weaklyCopiedValues |  super veryDeepInner: deepCopier.  locked := locked veryDeepCopyWith: deepCopier.  visible := visible veryDeepCopyWith: deepCopier.  sticky := sticky veryDeepCopyWith: deepCopier.  balloonText := balloonText veryDeepCopyWith: deepCopier.  externalName := externalName veryDeepCopyWith: deepCopier.  eventHandler := eventHandler veryDeepCopyWith: deepCopier.  fillStyle := fillStyle veryDeepCopyWith: deepCopier.  layoutPolicy := layoutPolicy veryDeepCopyWith: deepCopier.  layoutFrame := layoutFrame veryDeepCopyWith: deepCopier.  layoutProperties := layoutProperties veryDeepCopyWith: deepCopier.  borderStyle := borderStyle veryDeepCopyWith: deepCopier.  cornerStyle := cornerStyle veryDeepCopyWith: deepCopier.  actionMap := actionMap veryDeepCopyWith: deepCopier.  clipSubmorphs := clipSubmorphs veryDeepCopyWith: deepCopier.  otherProperties ifNil: [ ^self ].  otherProperties := otherProperties copy.  self propertyNamesNotCopied do: [:propName |  otherProperties removeKey: propName ifAbsent: [  ] ].  namesOfWeaklyCopiedProperties := self copyWeakly.  weaklyCopiedValues := namesOfWeaklyCopiedProperties collect: [:propName |  otherProperties removeKey: propName ifAbsent: [  ] ].  otherProperties := otherProperties veryDeepCopyWith: deepCopier.  namesOfWeaklyCopiedProperties with: weaklyCopiedValues do: [:name :value |  value ifNotNil: [ otherProperties at: name put: value ] ]expandRoots  self roots do: [:each |  (each canExpand and: [ each isExpanded not ]) ifTrue: [ each toggleExpandedState ] ].  self innerWidgetChangedworldBoundsForMorph: aMorph  | r |  r := self haloEnclosesFullBounds ifFalse: [ aMorph boundsIn: nil ] ifTrue: [ aMorph fullBoundsInWorld ].  self showBoundsInHalo ifTrue: [ ^r expandBy: 2 ].  ^rtrail  ^trail ifNil: [ #() ]computeFullBounds  [ self doLayoutIn: self layoutBounds ] on: Error do: [:ex |  fullBounds := bounds.        ex pass ]selectionTextColor  ^self theme menubarItemSelectionTextColorFor: selfselected  ^self state == #repressed or: [ self state == #on ]swapColumn: aColumn withColumn: anotherColumn  self swapColumnAt: aColumn index withColumnAt: anotherColumn indexisSelectedMatchingTheState: aBoolean  ^aBoolean notupdateBounds  self bounds: self owner clearAreatakeHighlight  container listManager lastClickedMorph: self.  container selectionChangeddataSource: anObject  dataSource := anObject.  dataSource table: self.  dataSource readyToBeDisplayed.  self resetPosition.  self refreshassureTableProperties  | props |  props := self layoutProperties.  props == self ifTrue: [ props := nil ].  props ifNil: [ props := TableLayoutProperties new initializeFrom: self.        self layoutProperties: props ].  props includesTableProperties ifFalse: [ self layoutProperties: (props := props asTableLayoutProperties) ].  ^propstitle: aString  self setLabel: aStringinitializeNewSearch  result := OrderedCollection new.  index := 1composeToBounds  self     releaseParagraph;     paragraph.  container ifNotNil: [ self privateBounds: container bounds truncated ].  self paragraph positionWhenComposed: self position.  successor ifNotNil: [ successor predecessorChanged ]newDataSourceMatching: aFTFilter  ^(self class searchStrategies at: self searchStrategy ifAbsent: [ self class searchStrategies at: #default ]) filterWith: aFTFilter pattern dataSource: selfdrawOn: aCanvas  touchPoints := Dictionary new.  aCanvas clipBy: self bounds during: [:clippedCanvas |  clippedCanvas fillRectangle: self bounds color: Color white.        self           drawMonthHeaderOn: clippedCanvas;           drawWeekDayNamesOn: clippedCanvas;           drawDaysOn: clippedCanvas;           drawTodayOn: aCanvas.        clippedCanvas frameRectangle: self bounds width: 1 color: Color black ]forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]mouseDown: evt  evt redButtonPressed ifFalse: [ ^super mouseDown: evt ].  evt hand showTemporaryCursor: (Cursor crossHair copy offset: -9 @ -9).  self hideLocation.  self selectColorAt: evt position.  ^super mouseDown: evtdrawLinesOn: aCanvas  | lColor |  lColor := self lineColor.  aCanvas transformBy: scroller transform clippingTo: scroller innerBounds during: [:clippedCanvas |  scroller submorphs do: [:submorph |  | last |              ((submorph isExpanded and: [ (submorph nextSibling notNil and: [ clippedCanvas isVisible: (submorph fullBounds topLeft corner: submorph nextSibling fullBounds bottomRight) ]) or: [ submorph nextSibling isNil and: [ (last := submorph lastChild) notNil and: [ clippedCanvas isVisible: (submorph fullBounds topLeft corner: last fullBounds bottomRight) ] ] ] ]) or: [ (clippedCanvas isVisible: submorph fullBounds) or: [ submorph nextSibling notNil and: [ clippedCanvas isVisible: submorph nextSibling fullBounds ] ] ]) ifTrue: [ submorph drawLinesOn: clippedCanvas lineColor: lColor ] ] ] smoothing: scroller smoothinghandleMouseUp: anEvent  anEvent wasHandled ifTrue: [ ^self ].  anEvent hand mouseFocus == self ifFalse: [ ^self ].  anEvent hand releaseMouseFocus: self.  anEvent wasHandled: true.  ^anEvent blueButtonChanged ifTrue: [ self blueButtonUp: anEvent.        self eventHandler ifNotNil: [:handler |  handler mouseUp: anEvent fromMorph: self ] ] ifFalse: [ | result |        result := self mouseUp: anEvent.        self stopSteppingSelector: #handleMouseStillDown:.        result ]computeExtraSpacing: arrangement in: newBounds horizontal: aBool target: aMorph  | extent extra centering n extraPerCell cell last hFill vFill max amount allow |  extent := newBounds extent.  aBool ifFalse: [ extent := extent transposed ].  hFill := vFill := false.  max := 0 @ 0.  arrangement do: [:c |  max := (max x max: c cellSize x) @ (max y + c cellSize y).        max := max max: c cellSize.        hFill := hFill or: [ c hSpaceFill ].        vFill := vFill or: [ c vSpaceFill ] ].  allow := properties rubberBandCells not.  aMorph hResizing == #shrinkWrap ifTrue: [ aBool ifTrue: [ allow & hFill ifFalse: [ extent := max x @ (max y max: extent y) ] ] ifFalse: [ allow & vFill ifFalse: [ extent := (max x max: extent x) @ max y ] ] ].  aMorph vResizing == #shrinkWrap ifTrue: [ aBool ifFalse: [ allow & hFill ifFalse: [ extent := max x @ (max y max: extent y) ] ] ifTrue: [ allow & vFill ifFalse: [ extent := (max x max: extent x) @ max y ] ] ].  extra := extent y - (arrangement inject: 0 into: [:sum :c |  sum + c cellSize y ]).  extra > 0 ifTrue: [ vFill ifTrue: [ n := arrangement inject: 0 into: [:sum :c |  c vSpaceFill ifTrue: [ sum + 1 ] ifFalse: [ sum ] ].              n isZero ifFalse: [ extraPerCell := extra asFloat / n asFloat ].              extra := last := 0.              arrangement do: [:c |  c vSpaceFill ifTrue: [ extra := (last := extra) + extraPerCell.                          amount := 0 @ (extra truncated - last truncated).                          c do: [:cc |  cc cellSize: cc cellSize + amount ] ] ] ] ifFalse: [ centering := properties wrapCentering.              centering == #bottomRight ifTrue: [ arrangement first addExtraSpace: 0 @ extra ].              centering == #center ifTrue: [ arrangement first addExtraSpace: 0 @ (extra // 2) ].              centering == #justified ifTrue: [ n := arrangement size - 1 max: 1.                    extraPerCell := extra asFloat / n asFloat.                    extra := last := 0.                    arrangement do: [:c |  c addExtraSpace: 0 @ (extra truncated - last truncated).                          extra := (last := extra) + extraPerCell ] ] ] ].  centering := properties listCentering.  1 to: arrangement size do: [:i |  cell := arrangement at: i.        extra := extent x - cell cellSize x.        extra > 0 ifTrue: [ cell := cell nextCell.              cell hSpaceFill ifTrue: [ n := cell inject: 0 into: [:sum :c |  c hSpaceFill ifTrue: [ sum + c target spaceFillWeight ] ifFalse: [ sum ] ].                    n isZero ifFalse: [ extraPerCell := extra asFloat / n asFloat ].                    extra := last := 0.                    cell do: [:c |  c hSpaceFill ifTrue: [ extra := (last := extra) + (extraPerCell * c target spaceFillWeight).                                amount := extra truncated - last truncated.                                c cellSize: c cellSize + (amount @ 0) ] ] ] ifFalse: [ centering == #bottomRight ifTrue: [ cell addExtraSpace: extra @ 0 ].                    centering == #center ifTrue: [ cell addExtraSpace: (extra // 2) @ 0 ].                    centering == #justified ifTrue: [ n := cell size - 1 max: 1.                          extraPerCell := extra asFloat / n asFloat.                          extra := last := 0.                          cell do: [:c |  c addExtraSpace: (extra truncated - last truncated) @ 0.                                extra := (last := extra) + extraPerCell ] ] ] ] ]on: eventName send: selector to: recipient  self addSubscription: (MorphEventSubscription on: eventName send: selector to: recipient) toEvent: eventNameframePolyline: vertices on: aCanvas  | prev next |  prev := vertices first.  2 to: vertices size do: [:i |  next := vertices at: i.        self drawLineFrom: prev to: next on: aCanvas.        prev := next ]trackColorFrom: aMorph  activate  super activate.  self active: truenewButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpTexttoggleExpandedState: aMorph event: event  | oldState |  event yellowButtonPressed ifTrue: [ oldState := aMorph isExpanded.        scroller submorphs copy do: [:each |  (each canExpand and: [ each isExpanded = oldState ]) ifTrue: [ each toggleExpandedState ] ] ] ifFalse: [ aMorph toggleExpandedState ].  self adjustSubmorphPositionsnewLabelFor: aModel getLabel: labelSel getEnabled: enabledSel  ^self theme newLabelIn: self for: aModel getLabel: labelSel getEnabled: enabledSelstateChanged: anObject  stateChanged := anObjectresumeAfterStepError  self startStepping.  self removeProperty: #errorOnStepcheckForNewScreenSize  mergeDropThird: mv in: hv from: shared  | mdrop vv |  (shared includes: (mv at: mv size - 2)) ifTrue: [ (shared includes: mv last) ifTrue: [ mdrop := mv last ] ] ifFalse: [ (shared includes: mv last) ifTrue: [ (shared includes: mv second) ifTrue: [ mdrop := mv first ] ] ].  (shared includes: mv third) ifTrue: [ (shared includes: mv second) ifTrue: [ mdrop := mv second ] ].  mdrop ifNil: [ ^nil ].  mv remove: mdrop.  hv remove: mdrop.  shared remove: mdrop.  [ shared includes: mv first ] whileFalse: [ vv := mv removeFirst.        mv addLast: vv ].  [ mv first = hv first ] whileFalse: [ vv := hv removeFirst.        hv addLast: vv ]playRestoreUpSound  self theme windowRestoreUpSound playnextPage: theIndexOfAnElement  self currentPage: (self pageOfNodeIndex: theIndexOfAnElement)doDrag: evt with: dragHandle  | thePoint |  evt hand obtainHalo: self.  thePoint := target point: evt position - positionOffset from: owner.  target setConstrainedPosition: thePoint hangOut: truepressedFillStyle  ^self theme morphTreeSplitterPressedFillStyleFor: selftoggleState  self isOn ifTrue: [ self turnOff ] ifFalse: [ self turnOn ]changeDragAndDrop  ^self enableDragNDrop: self dragNDropEnabled notisComplex  ^truenewNoButton  ^self newNoButtonFor: selfaddPaneSplittersIfNeeded  (isCollapsed not and: [ self paneMorphs isNotEmpty and: [ self splitters isEmpty ] ]) ifTrue: [ self addPaneSplitters ]modifierKeyPressed: event  | args aChar |  aChar := event keyCharacter.  keystrokeActionSelector ifNil: [ ^nil ].  args := keystrokeActionSelector numArgs.  args = 1 ifTrue: [ ^model perform: keystrokeActionSelector with: aChar ].  args = 2 ifTrue: [ ^model perform: keystrokeActionSelector with: aChar with: self ].  ^self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'doScale: evt with: scaleHandle  | newHandlePos colorToUse |  evt hand obtainHalo: self.  newHandlePos := evt cursorPoint - (scaleHandle extent // 2).  target scaleToMatch: newHandlePos.  colorToUse := target scale = 1.0 ifTrue: [ Color yellow ] ifFalse: [ Color orange ].  self setColor: colorToUse toHandle: scaleHandle.  scaleHandle submorphsDo: [:m |  m color: colorToUse contrastingBlackAndWhiteColor ].  scaleHandle position: newHandlePosis: hand overlappingDamagedAreaIn: damageList  | handBounds |  handBounds := hand fullBounds.  ^damageList anySatisfy: [:r |  r intersects: handBounds ]intercellSpacing: aNumberOrPoint  intercellSpacing := aNumberOrPoint asPointrestoreMorphicDisplay  worldState worldRenderer restoreMorphicDisplaynewTextEntryFor: aModel getText: getSel setText: setSel help: helpText  ^self newTextEntryFor: aModel get: getSel set: setSel class: String getEnabled: nil help: helpTextdisplayScaleFactor  ^self class displayScaleFactorwidthToDisplayItem: item  | widths |  widths := item collect: [:each |  each widthToDisplayInList: self ].  ^widths sum + ((listSource gapSize + 4) * (widths size - 1))normalBorderStyle  ^self theme taskbarItemNormalBorderStyleFor: selfshiftedYellowButtonActivity  self editor pluggableYellowButtonActivity: true.  self changedstepTime: aNumber  stepTime := aNumberscaleFactor  ^transform scaleasSpAdapter  self deprecated: 'Instead of #asSpAdapter you should use a SpMorphPresenter'.  ^(SpBindings value adapterClass: #GenericAdapter) morph: selfactionsChanged: aTab  self selectedTab = aTab ifFalse: [ ^self ].  self adjustLayouthasIcon  ^icon notNildepth: aNumber  depth := aNumberadjustSegmentPointsForArrows  | verts |  (self isClosed or: [ self hasArrows not ]) ifTrue: [ ^self vertices ].  verts := self vertices copy.  (arrows == #back or: [ arrows == #both ]) ifTrue: [ | arrow |        arrow := self arrowBoundsAt: verts first from: verts second.        arrow size = 4 ifTrue: [ verts at: 1 put: arrow third ] ifFalse: [ verts at: 1 put: (arrow copyFrom: 2 to: 3) average ] ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ | arrow |        arrow := self arrowBoundsAt: verts last from: verts nextToLast.        arrow size = 4 ifTrue: [ verts at: verts size put: arrow third ] ifFalse: [ verts at: verts size put: (arrow copyFrom: 2 to: 3) average ] ].  ^vertsoriginalColor  ^originalColorsource  ^sourcescheduledTime: msecs  scheduledTime := msecsensureVisibleFirstSelection  | rowIndex |  (self hasSelection not or: [ self container isRowIndexFullyVisible: (rowIndex := self selectionModeStrategy selectedRowIndex) ]) ifTrue: [ ^self ].  rowIndex < self showIndex ifTrue: [ self moveShowIndexTo: self selectedIndex ] ifFalse: [ self moveShowIndexTo: (self selectionModeStrategy indexForRow: rowIndex - self container calculateMinVisibleRows + 1) ]defaultTaskbarThumbnailExtent  ^320 @ 320color  ^color ifNil: [ Color transparent ]handlesMouseOver: anEvent  ^truelistItemHeight  ^12initialize  super initialize.  width := 1.  color := Color transparenthandleEvent: anEvent  ^anEvent sentTo: selfquestionWithoutCancel: aStringOrText title: aString  ^self theme questionWithoutCancelIn: self text: aStringOrText title: aStringclipSubmorphs  ^truehasHalo: aBool  aBool ifTrue: [ self setProperty: #hasHalo toValue: true ] ifFalse: [ self removeProperty: #hasHalo ]nextMorphWantingFocus  | m |  m := self nextMorphInWindow ifNil: [ ^nil ].  [ m = self or: [ m wantsKeyboardFocusNavigation ] ] whileFalse: [ m := m nextMorphInWindow ].  ^m wantsKeyboardFocusNavigation ifTrue: [ m ]isStepping: aMorph selector: aSelector  ^worldState isStepping: aMorph selector: aSelectorexpandAll  self expand: SmallInteger maxValdefaultColor  ^Color transparentdrawDashedBorderOn: aCanvas  self drawDashedBorderOn: aCanvas usingEnds: (Array with: vertices first with: vertices last)proceed: aStringOrText  ^self proceed: aStringOrText title: 'Proceed' translatedemptyTabColor: aColor  contentsWrapper color: aColorprivateRemoveMorph: aMorph  backgroundMorph == aMorph ifTrue: [ backgroundMorph := nil ].  ^super privateRemoveMorph: aMorphindentLevel  ^indentLevelsetUpdatablePanesFrom: getSelectors  | aList possibles |  aList := OrderedCollection new.  possibles := OrderedCollection new.  self allMorphsDo: [:pane |  (pane isKindOf: PluggableListMorph) ifTrue: [ possibles add: pane ] ].  getSelectors do: [:sel |  possibles detect: [:pane |  pane getListSelector == sel ] ifFound: [:aPane |  aList add: aPane ] ].  updatablePanes := aList asArraynewGroupboxFor: control  ^self theme newGroupboxIn: self for: controltype  ^self subclassResponsibilityhandleMouseUp: anEvent  ^self dispatchDefault: anEvent with: morphinitialize  super initialize.  self     hResizing: #spaceFill;     vResizing: #spaceFillrejectsEvent: anEvent  ^(anEvent isMouse and: [ anEvent isMouseDown ]) or: [ super rejectsEvent: anEvent ]current: aNumber  bar value: aNumber.  self changedpopUpForHand: aHand  | worldBounds |  self lock.  self fullBounds.  self setProperty: #morphicLayerNumber toValue: self morphicLayerNumber.  aHand world addMorphFront: self.  ((worldBounds := aHand world bounds) containsRect: self bounds) ifFalse: [ self bounds: (self bounds translatedToBeWithin: worldBounds) ].  aHand balloonHelp: selfstep  progress := progress + 1.  progress > 10 ifTrue: [ progress := 1 ].  progressIconMorph form: self currentIconcolor: aColor  super color: aColor.  originalColor := aColor asColor.  self updateColorveryDeepCopyWith: deepCopier  self prepareToBeSaved.  ^super veryDeepCopyWith: deepCopierselectedItem  ^self selectedNode ifNotNil: [:node |  node item ]pasteUpMorphHandlingTabAmongFields  | aPasteUp |  aPasteUp := self owner.  [ aPasteUp notNil ] whileTrue: [ aPasteUp tabAmongFields ifTrue: [ ^aPasteUp ].        aPasteUp := aPasteUp owner ].  ^nilmouseLeaveDragging: anEvent  (self dropEnabled and: [ anEvent hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: anEvent ].  self resetPotentialDropMorph.  anEvent hand releaseMouseFocus: selfautoScrollHeightLimit  ^20testSelectedRowIndex  self subclassResponsibilityshadowColor  ^self valueOfProperty: #shadowColor ifAbsent: [ Color black ]comeToFront  | outerMorph |  outerMorph := self topRendererOrSelf.  (outerMorph owner isNil or: [ outerMorph owner hasSubmorphs not ]) ifTrue: [ ^self ].  outerMorph owner firstSubmorph == outerMorph ifFalse: [ outerMorph owner addMorphFront: outerMorph ]basicHeaderCellFor: column  | cell |  column id ifNil: [ ^nil ].  cell := FTHeaderColumnCellMorph new     listCentering: #center;     column: column;     cellInset: 5;     addMorph: column id asStringMorph;     yourself.  column sortingIcon ifNotNil: [:icon |  cell addMorph: icon ].  ^cellcountAvailableRows  availableRows := rootItems inject: 0 into: [:sum :item |  sum + item availableRows ]initialize  super initialize.  touchPoints := Dictionary newdo: aBlock  self changed.  ^[ aBlock value: self ] ensure: [ self close ]isEditable: evt  ^self isEditable and: [ evt shiftPressed ]title  ^self labelnewTasksMorph  ^Morph new     changeTableLayout;     listDirection: #leftToRight;     wrapDirection: #topToBottom;     cellInset: 1;     color: Color transparent;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     yourselfmouseMove: event  event redButtonPressed ifFalse: [ ^self ].  self handleInteraction: [ editor mouseMove: event ]selectRowIndex: aNumber  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver selectRowIndex: `@statements1' -> '`@receiver selectIndex: `@statements1'.  self selectIndex: aNumbergetTextSelector  ^getTextSelectorinitWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel  container := hostList.  complexContents := anObject.  indentLevel := newLevel.  self initWithContents: anObject asString font: StandardFonts listFont emphasis: nil.  isExpanded := false.  nextSibling := firstChild := nil.  priorMorph ifNotNil: [ priorMorph nextSibling: self ].  icon := anObject icon.  self extent: self minWidth @ self minHeightnewExpander: aString for: aControl  ^self theme newExpanderIn: self label: aString forAll: {aControl}pinboxClicked  self stayUp: truearrowEvent: event key: aChar target: aMorph  ^falseenabled  ^enableddefaultTarget  ^defaultTargettestSelectableIndexBefore  self subclassResponsibilitytype  ^#dropEventinitialize  super initialize.  state := #off.  actionSelector := #flash.  arguments := EmptyArray.  actWhen := #buttonUpdelete  self mustNotClose ifTrue: [ ^self ].  self model ifNotNil: [ self model okToChange ifFalse: [ ^self ].        self model okToClose ifFalse: [ ^self ] ].  self isFullscreen ifTrue: [ self owner delete ] ifFalse: [ super delete ]testKeyStrokeFromMorph  | keyboardEvent |  keyboardEvent := KeyboardEvent new setType: #keystroke buttons: 2 position: nil keyValue: nil charCode: 65 hand: nil stamp: nil.  morph eventHandler on: #keyStroke send: #value to: true.  self assert: (morph handleKeystroke: keyboardEvent) identicalTo: trueselected: aBoolean  self removeAllMorphs.  self isSelected ifTrue: [ self addMorph: self selectedLabel ] ifFalse: [ self addMorph: self normalLabel ]direction: anObject  direction := anObjectdrawOn: aCanvas  self     isEnabled;     basicDrawOn: aCanvas;     drawKeyTextOn: aCanvassetDashOnStroke: anAthensStrokePaint  | d commonOffset |  d := self dashedBorder.  commonOffset := d size > 3 ifTrue: [ d fourth ] ifFalse: [ 0 ].  anAthensStrokePaint dashes: {d first .         d second} offset: commonOffsetnewStack  ^self theme newStackIn: self for: #()announcer  ^self valueOfProperty: #announcer ifAbsentPut: [ Announcer new ]initialize  super initialize.  referencePosition := self centerapplyChanges  self acceptTextMorphsdecrement  bar decrementreplaceBoxes  labelArea removeAllMorphs.  self setLabelWidgetAllowance.  self theme configureWindowLabelAreaFor: self.  self setFramesForLabelArea.  self isActive ifFalse: [ labelArea passivate ]borderColor  ^self theme lightBackgroundColornoteRemovalOfAll: aMorphList  aMorphList do: [:each |  self selectedMorphList remove: each ifAbsent: [  ].        lastClickedMorph == each ifTrue: [ lastClickedMorph := nil ] ]form: aForm  image := aForm.  super extent: (2 * self borderWidth) asPoint + image extent.  self changedtoggleVisibleAndRaise  self visible ifTrue: [ self hide ] ifFalse: [ self           comeToFront;           show ]splitsTopAndBottom  ^self isHorizontalkeyStroke: event  | aChar |  (self scrollByKeyboard: event) ifTrue: [ ^self ].  (self navigationKey: event) ifTrue: [ ^self ].  aChar := event keyCharacter.  keystrokeSelector ifNotNil: [ (self keystrokeAction: event) ifTrue: [ ^self ] ].  aChar asciiValue < 32 ifTrue: [ ^self specialKeyPressed: event ].  (event anyModifierKeyPressed or: [ self handlesBasicKeys not ]) ifTrue: [ ^self modifierKeyPressed: event ].  ^self basicKeyPressed: aCharpinForm  ^CircleMorph new     extent: 8 @ 8;     borderWidth: 2;     color: self pinColor;     imageFormhandlesKeyboard: evt  ^truepotentialDropItem  self potentialDropRow = 0 ifTrue: [ ^self ].  ^self getListItem: self potentialDropRowaddAlarm: aSelector with: arg1 with: arg2 after: delayTime  ^self addAlarm: aSelector withArguments: (Array with: arg1 with: arg2) after: delayTimeorganizeIntoColumn  ((AlignmentMorph inAColumn: (selectedItems asSortedCollection: [:x :y |  x top < y top ]))     setNameTo: 'Column';     color: Color orange muchLighter;     enableDragNDrop: true;     yourself) openInHandprintOn: aStream  aStream nextPut: $[.  aStream     nextPutAll: self position printString;     space.  aStream     nextPutAll: self type;     space.  aStream nextPutAll: self windowIndex printString.  aStream nextPut: $]drawOnAthensCanvas: aCanvas  listItems isEmpty ifTrue: [ ^self ].  1 to: listItems size do: [:row |  (listSource itemSelectedAmongMultiple: row) ifTrue: [ self athensDrawBackgroundForSelectedRow: row on: aCanvas ] ifFalse: [ listSource searchedElement = row ifTrue: [ self athensDrawBackgroundForSearchedRow: row on: aCanvas ] ifFalse: [ (listSource backgroundColorFor: row) ifNotNil: [:col |  self athensDrawBackgroundForRow: row on: aCanvas color: col ] ] ].        selectedRow = row ifTrue: [ self athensDrawSelectionOn: aCanvas ].        (listSource separatorAfterARow: row) ifTrue: [ self athensDrawSeparatorAfter: row on: aCanvas ].        self athensDisplay: (self item: row) atRow: row on: aCanvas ].  listSource potentialDropRow > 0 ifTrue: [ self athensHighlightPotentialDropRow: listSource potentialDropRow on: aCanvas ]passiveEnabledOverDownFillStyle: aFillStyle  self stateMap atPath: #(passive enabled over down) put: aFillStyle.  self changedisMove  ^falseenable  self enabled: truecommandKeySelectors  | aDict |  aDict := self valueOfProperty: #commandKeySelectors ifAbsentPut: [ self initializeDesktopCommandKeySelectors ].  ^aDictupdateLayoutInDockingBar  owner isVertical ifTrue: [ self hResizing: #spaceFill.        self vResizing: #shrinkWrap ] ifFalse: [ self hResizing: #shrinkWrap.        self vResizing: #spaceFill ].  self extent: self minWidth @ self minHeightadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self selectionColor: self selectionColor.  self fillStyle: self fillStyleToUse.  self borderWidth > 0 ifTrue: [ self borderStyle: self borderStyleToUse ]toggleEnabled  self enabled: self enabled notrenderedMorph  submorphs isEmpty ifTrue: [ ^self ].  ^self firstSubmorph renderedMorphtakesKeyboardFocus  ^truegetMenu: shiftKeyState  | aMenu |  aMenu := super getMenu: shiftKeyState.  aMenu ifNotNil: [ aMenu commandKeyHandler: self ].  ^aMenuasText  ^textdrawOnAthensCanvas: anAthensCanvas  self drawOnCanvasWrapperFor: anAthensCanvaswidth  ^widthbuildWithSpec  ^selfexpandWithoutChange  isExpanded := trueinteractionState  | state mo |  state := self getModelState.  mo := (self valueOfProperty: #mouseEntered) == true.  ^(self enabled ifNil: [ true ]) ifTrue: [ showSelectionFeedback ifTrue: [ state ifTrue: [ #selectedPressed ] ifFalse: [ #pressed ] ] ifFalse: [ mo ifTrue: [ state ifTrue: [ #selectedMouseOver ] ifFalse: [ #mouseOver ] ] ifFalse: [ state ifTrue: [ #selected ] ifFalse: [ #normal ] ] ] ] ifFalse: [ state ifTrue: [ #selectedDisabled ] ifFalse: [ #disabled ] ]handler: anObject  handler := anObjectresetWorldMenu  worldState resetWorldMenudefaultColor  ^Color transparentaddMorph: newMorph inFrontOf: aMorph  ^self privateAddMorph: newMorph atIndex: ((submorphs indexOf: aMorph) max: 1)areasRemainingToFill: aRectangle  ^self isOpaque ifTrue: [ aRectangle areasOutside: self bounds ] ifFalse: [ Array with: aRectangle ]column  ^columnactiveHand: aHandMorph  worldState activeHand: aHandMorphdebugDrawLineRectsOn: aCanvas  self paragraph lines do: [:line |  aCanvas frameRectangle: line rectangle color: Color brown ]positionPoint: aPoint  (#(top bottom) includes: self edgeName) ifTrue: [ ^self position: self left @ aPoint y ].  (#(left right) includes: self edgeName) ifTrue: [ ^self position: aPoint x @ self top ].  ^self position: aPointwantsGradientByDefault  ^falsemorph: anObject  morph := anObjectboundsInWorld  ^self bounds: self bounds in: self worldrightLayoutFrame  ^(1 @ 0 corner: 1 @ 1) asLayoutFrame     topLeftOffset: SystemWindow borderWidth negated @ -7;     bottomOffset: SystemWindow borderWidth - 26removeProperty: aSymbol  otherProperties ifNil: [ ^self ].  otherProperties removeKey: aSymbol ifAbsent: [  ].  otherProperties isEmpty ifTrue: [ self removeOtherProperties ]setItem: anObject model: aModel  item := anObject.  model := aModelhandlesKeyboard: evt  ^trueresizeCursor  ^Cursor resizeForEdge: #bottomRighteditBalloonHelpText  self editBalloonHelpContent: self balloonTextlayoutBounds: aRectangle  super layoutBounds: aRectangle.  self     resizeScroller;     setScrollDeltasisInSystemWindow  ^owner isMorph and: [ owner isSystemWindow or: [ owner isInSystemWindow ] ]retrieveMorph: aBlock  morph ifNotNil: [ aBlock value: morph.        ^nil ].  retrievingSemaphore isSignaled ifFalse: [ self softRetrieveMorph ].  ^[ retrievingSemaphore wait.  morph ifNotNil: [ UIManager default defer: [ aBlock value: morph ] ] ] forkrecomposeChain  self withSuccessorsDo: [:m |  m           text: text textStyle: textStyle;           releaseParagraph;           fit ]findSimilarPathMatchIn: anArray  self withSiblingsDo: [:each |  (each complexContents asString sameAs: anArray first) ifTrue: [ ^each ] ].  ^nilensureSafePattern: aPattern  ^[ aPattern asRegexIgnoringCase ] on: RegexSyntaxError do: [:ex |   ]world: aWorldMorph  world := aWorldMorphdashLengths: anObject  dashLengths := anObjectshouldInvalidateOnMouseTransition  ^falsehighlightForMouseDown: aBoolean  aBoolean ifTrue: [ self setProperty: #highlightedForMouseDown toValue: aBoolean ] ifFalse: [ self removeProperty: #highlightedForMouseDown.        self resetExtension ].  self changedcolumnColorForEven: evenColor  columnColors at: 2 put: nil.  columnColors at: 1 put: evenColortopLeftOffset: aPoint  topOffset := aPoint y.  leftOffset := aPoint xbrickApi  ^self valueOfProperty: #brickApi ifAbsentPut: [ GLMBrickMorphWrapper on: self ]removeEventListener: anObject  self eventListeners: (self removeListener: anObject from: self eventListeners)navigateFocus  self rememberedKeyboardFocus ifNil: [ self navigateFocusForward ] ifNotNil: [:keyboardFocus |  keyboardFocus world ifNotNil: [ keyboardFocus wantsKeyboardFocus ifTrue: [ keyboardFocus takeKeyboardFocus ] ifFalse: [ self navigateFocusForward ] ] ]transformBy: aMorphicTransform  position := aMorphicTransform globalPointToLocal: position.  startPoint := aMorphicTransform globalPointToLocal: startPointgetListSelector  ^getListSelectorhandleAsMouseLeave: anEvent  self keepLeftMorphsOrder.  self informMouseLeaveToLeftMorphsUsing: anEventdoButtonAction  (target notNil and: [ actionSelector notNil ]) ifTrue: [ Cursor normal showWhile: [ target perform: actionSelector withArguments: arguments ].        target isMorph ifTrue: [ target changed ] ]setSelectedSelector: aSymbol  setSelectionSelector := aSymbolbounds: newBounds  selectedItems := OrderedCollection new.  self     position: newBounds topLeft;     extent: newBounds extenthasFocus  ^hasFocusisExpanded  ^isExpandedwindow  ^windowfitTargetOwner: anObject  fitTargetOwner := anObjecttargetPoint: aPoint  | minExt rect |  rect := self target bounds withSideOrCorner: self ptName setToPoint: aPoint.  minExt := self target minimumExtent.  rect width <= minExt x ifTrue: [ (self ptName = #topLeft or: [ self ptName = #bottomLeft ]) ifTrue: [ rect := rect withSideOrCorner: #left setToPoint: self target bounds bottomRight - minExt ] ifFalse: [ rect := rect withSideOrCorner: #right setToPoint: self target bounds topLeft + minExt ] ].  rect height <= minExt y ifTrue: [ (self ptName = #topLeft or: [ self ptName = #topRight ]) ifTrue: [ rect := rect withSideOrCorner: #top setToPoint: self target bounds bottomRight - minExt ] ifFalse: [ rect := rect withSideOrCorner: #bottom setToPoint: self target bounds topLeft + minExt ] ].  self target bounds: rectcompletedWidth  | range fraction progress |  range := end - start.  progress := value - start.  fraction := progress / range.  ^(fraction * self totalBarWidth) truncatedselectionOneOf: aListOfItems  aListOfItems do: [:item |  | index |        index := scroller submorphs findFirst: [:m |  m withoutListWrapper = item withoutListWrapper ].        index > 0 ifTrue: [ ^self selectionIndex: index ] ].  self selectionIndex: 0initialize  super initialize.  filterClass := FTRegexFilterdefaultBorderWidth  ^self theme menubarBorderWidthFor: selffindA: aClass  ^self submorphs detect: [:p |  p isKindOf: aClass ] ifNone: [ nil ]buildHandleMenu: aHand  | menu |  menu := UIManager default newMenuIn: self for: self.  menu addLine.  self addStandardHaloMenuItemsTo: menu hand: aHand.  menu defaultTarget: aHand.  self addAddHandMenuItemsForHalo: menu hand: aHand.  menu defaultTarget: self.  self addCustomHaloMenuItems: menu hand: aHand.  menu defaultTarget: aHand.  ^menugriddingOn  ^griddingOn ifNil: [ false ]toggleResizeToFit  self vResizeToFit: self resizeToFit notsetUp  super setUp.  windows := OrderedCollection new.  tasks := OrderedCollection new.  self theMethodInProdThatShouldBeTestedtestExecuteSortingOn  | dataSource |  dataSource := self dataSourceForTesting.  state executeSortingOn: dataSource.  self assert: dataSource elements equals: #(10 9 8 7 6 5 4 3 2 1).  state executeSortingOn: dataSource.  self assert: dataSource elements equals: #(10 9 8 7 6 5 4 3 2 1)minimumExtent  ^40 @ 25keyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self focusChangedalwaysShowScrollBars: bool  self     alwaysShowHScrollBar: bool;     alwaysShowVScrollBar: boolnewTextEntryFor: aModel getText: getSel setText: setSel help: helpText  ^self newTextEntryFor: aModel get: getSel set: setSel class: String getEnabled: nil help: helpTextfirstChild  ^self firstNodeMorphaddAllMorphs: aCollection  ^self privateAddAllMorphs: aCollection atIndex: submorphs sizekeyStroke: evt  (self scrollByKeyboard: evt) ifTrue: [ ^self ].  scroller submorphs last keyStroke: evtnoteNewOwner: aMorph  super noteNewOwner: aMorph.  self updateLayoutInDockingBarselectIndexesUpTo: endIndex  | oldSelected firstIndex |  oldSelected := self table selectedIndexes.  firstIndex := oldSelected ifNotEmpty: [ oldSelected first ] ifEmpty: [ endIndex ].  self selectIndexes: endIndex previous: (oldSelected union: (self table selectionModeStrategy indexesToSelectInMultipleSelectionFrom: firstIndex to: endIndex))initialize  super initialize.  self     clipSubmorphs: true;     layoutPolicy: FTRowLayout newlaunchEditor: evt  self editorProvider ifNil: [ ^self ].  self editorProvider openEditorForStringMorph: selffixStateForClickAndModifierIssue  self isMouseUp ifFalse: [ ^self ].  self yellowButtonChanged ifFalse: [ ^self ].  self anyModifierKeyPressed ifFalse: [ ^self ].  whichButton := MouseEvent redButtondoLayoutIn: layoutBounds  | box priorBounds |  priorBounds := self outerBounds.  submorphs isEmpty ifTrue: [ ^fullBounds := priorBounds ].  submorphs do: [:m |  m ownerChanged ].  self layoutPolicy ifNotNil: [:layout |  layout layout: self in: (0 @ 0 extent: layoutBounds extent // self scale) ].  self adjustLayoutBounds.  fullBounds := self privateFullBounds.  box := self outerBounds.  box = priorBounds ifFalse: [ self invalidRect: (priorBounds quickMerge: box) ]visible  extension ifNil: [ ^true ].  ^extension visiblenewListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector help: helpText  ^self newListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: nil help: helpTexttargetPoint: aPoint  | minExt rect |  rect := self target bounds withSideOrCorner: self edgeName setToPoint: aPoint.  minExt := (self target layoutPolicy notNil and: [ self target layoutPolicy isTableLayout ]) ifTrue: [ self target layoutPolicy minExtentOf: self target in: self target layoutBounds ] ifFalse: [ self target minimumExtent ].  rect width <= minExt x ifTrue: [ rect := self edgeName = #left ifTrue: [ rect withSideOrCorner: #left setToPoint: self target bounds bottomRight - minExt ] ifFalse: [ rect withSideOrCorner: #right setToPoint: self target bounds topLeft + minExt ] ].  rect height <= minExt y ifTrue: [ rect := self edgeName = #top ifTrue: [ rect withSideOrCorner: #top setToPoint: self target bounds bottomRight - minExt ] ifFalse: [ rect withSideOrCorner: #bottom setToPoint: self target bounds topLeft + minExt ] ].  self setTargetBounds: rectcreateActionIconOn: aBrowser  ^Smalltalk ui icons iconNamed: #scriptManagerIconrowInset: anInteger  rowInset := anIntegerballoonText  ^complexContents balloonText ifNil: [ super balloonText ]releaseMouseFocus  self newMouseFocus: nilhScrollbar  ^hScrollbarlistCentering: aSymbol  self assureTableProperties listCentering: aSymbol.  self layoutChangeddefaultLabel  ^'Color Selector' translatedwithExpandedChildren  ^{self} , self expandedChildrenselectedMorph  ^self listManager selectedMorphworldBounds  ^self world boundskeystrokeActionSelector: aSymbol  keystrokeActionSelector := aSymbolon: eventName send: selector to: recipient  self eventHandler ifNil: [ self eventHandler: MorphicEventHandler new ].  self eventHandler on: eventName send: selector to: recipientupdateOffImage  self offImage: (target perform: offImageSelector)arguments: aCollection  arguments := aCollectionmyDependents  ^(self valueOfProperty: #myDependents) ifNil: [ #() ]distributeVertically  | minTop maxBottom totalHeight currentTop space |  self selectedItems size > 2 ifFalse: [ ^self ].  minTop := self selectedItems anyOne top.  maxBottom := self selectedItems anyOne bottom.  totalHeight := 0.  self selectedItems do: [:each |  minTop := minTop min: each top.        maxBottom := maxBottom max: each bottom.        totalHeight := totalHeight + each height ].  currentTop := minTop.  space := ((maxBottom - minTop - totalHeight) / (self selectedItems size - 1)) rounded.  (self selectedItems asSortedCollection: [:x :y |  x top <= y top ]) do: [:each |  each top: currentTop.        currentTop := currentTop + each height + space ].  self changedtext  ^textnewCheckboxFor: aModel getSelected: getSel setSelected: setSel label: stringOrText help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: nil label: stringOrText help: helpTextdeselectAll  self listManager deselectAllmouseUp: evt  evt hand mouseFocus == owner ifFalse: [ ^self ].  self contentString ifNotNil: [ self contents: self contentString withMarkers: true inverse: true.        self refreshWorld.        (Delay forMilliseconds: 200) wait ].  owner rootMenu selectItem: nil event: evt.  self invokeWithEvent: evtmouseEnterDragging: evt  (evt hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: evt ].  (self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifTrue: [ self asPotentialDropTarget ]closeWindowAction  self closelabel: aString  self label isEmpty ifTrue: [ aString isEmptyOrNil ifTrue: [ ^self ].        self removeAllMorphs.        self labelMorph contents: aString.        self updateLayout.        self changed: #width ].  self labelMorph contents = aString ifFalse: [ self labelMorph contents: aString.        aString isEmptyOrNil ifTrue: [ self removeMorph: self labelMorph ].        self changed: #width ].  self changed: #widthmouseDown: event onItem: aMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlershighlightedRowIndexes  self deprecated: 'Use #highlightedIndexes instead' transformWith: '`@receiver highlightedRowIndexes' -> '`@receiver highlightedIndexes'.  ^self highlightedIndexesmidpoint  | middle |  middle := self totalLength.  middle < 2 ifTrue: [ ^self center ].  middle := middle / 2.  self lineSegmentsDo: [:a :b |  | dist |        dist := a distanceTo: b.        middle < dist ifTrue: [ ^(a + ((b - a) * (middle / dist))) asIntegerPoint ].        middle := middle - dist ].  self error: 'can''t happen'isRight  ^self option == #rightrootItemsOrig  ^rootClass allSubclasses asArray sort: [:a :b |  a name < b name ]borderColor  ^self theme borderColormouseDown: event  | morphRelativeHitPoint |  morphRelativeHitPoint := event cursorPoint translateBy: bounds origin negated.  days do: [:each |  each highlighted: (each bounds containsPoint: morphRelativeHitPoint) ].  self changedhMorph: anObject  hMorph := anObjectaddHandle: handleSpec on: eventName send: selector to: recipient  | handle aPoint |  aPoint := self positionIn: haloBox horizontalPlacement: handleSpec horizontalPlacement verticalPlacement: handleSpec verticalPlacement.  handle := self addHandleAt: aPoint color: (Color colorFrom: handleSpec color) icon: handleSpec iconSymbol on: eventName send: selector to: recipient.  ^handlecommandKeyHandler: anObject  self setProperty: #commandKeyHandler toValue: anObjectselectionRects  selectionStart ifNil: [ ^Array new ].  ^self selectionRectsFrom: selectionStart to: selectionStopsetStrategy  table beRowSelectiontrackColorFrom: aMorph  baseColor ifNil: [ self color: aMorph insetColor ]selectionBorderStyle  ^self theme menuItemSelectedBorderStyleFor: selfdefaultMultipleSelectionValue  ^falseiconFor: rowIndex  ^(self elementAt: rowIndex) actionOn: selfmin  ^(self sliderMorph ifNil: [ ^0 ]) minarcLengths  arcLengths ifNil: [ self calculateArcLengths ].  ^arcLengthscontentsWrapped: stringOrText  wrapFlag := true.  self newContents: stringOrTextchooseExistingFileReference: title extensions: exts path: path  ^self chooseExistingFileReference: title extensions: exts path: path preview: nilsetBalloonText: stringOrText  self setBalloonText: stringOrText maxLineLength: self theme settings maxBalloonHelpLineLengthaddSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean  | answer |  answer := super addSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean.  self flag: #issue12027.  ^answerisVerticalScrollBarVisible  ^self verticalScrollBar owner isNotNildoubleClickSelector: aSymbol  doubleClickSelector := aSymbolinnerBounds  ^self bounds insetBy: self borderWidthupdateVisualState: evt  oldColor ifNotNil: [ self color: ((self containsPoint: evt cursorPoint) ifTrue: [ oldColor mixed: 0.5 with: Color white ] ifFalse: [ oldColor ]) ]computeCheckTopLeft  | center offset |  center := self checkRectangle center.  offset := (self checkWidth / 2.0) truncated.  ^(center x - offset) @ (center y - offset - 1)toggleCornerRounding  self cornerStyle == #rounded ifTrue: [ self cornerStyle: #square ] ifFalse: [ self cornerStyle: #rounded ].  self changedareasRemainingToFill: aRectangle  self fillStyle isTranslucent ifTrue: [ ^Array with: aRectangle ].  self wantsRoundedCorners ifTrue: [ (self borderWidth > 0 and: [ self borderColor isColor and: [ self borderColor isTranslucent ] ]) ifTrue: [ ^aRectangle areasOutside: (self innerBounds intersect: self boundsWithinCorners) ] ifFalse: [ ^aRectangle areasOutside: self boundsWithinCorners ] ] ifFalse: [ (self borderWidth > 0 and: [ self borderColor isColor and: [ self borderColor isTranslucent ] ]) ifTrue: [ ^aRectangle areasOutside: self innerBounds ] ifFalse: [ ^aRectangle areasOutside: self bounds ] ]selectColorAt: aPoint  | b p |  b := self innerBounds.  p := (b containsPoint: aPoint) ifTrue: [ aPoint ] ifFalse: [ b pointNearestTo: aPoint ].  p := (p - b topLeft) / b extent.  self selectedColor: (Color h: self color hue s: p x v: 1.0 - p y)basicIcon  | button |  ^(button := IconicButton new)     clipSubmorphs: true;     color: self pagerColor;     on: #mouseEnter send: #value to: [ button borderColor: self pagerColor muchDarker ];     on: #mouseLeave send: #value to: [ button borderColor: self pagerColor ];     target: self;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     listCentering: #leftCenter;     wrapCentering: #center;     layoutInset: 2 @ 0;     cellInset: 2 @ 0;     borderWidth: 1;     borderColor: self pagerColor;     yourselfinitializeExtension  extension := MorphExtension newmouseDown: evt  self enabled ifFalse: [ ^self ].  allButtons := nil.  evt yellowButtonPressed ifTrue: [ ^self invokeMenu: evt ].  self wantsKeyboardFocusOnMouseDown ifTrue: [ self takeKeyboardFocus ].  triggerOnMouseDown ifTrue: [ self performAction: evt ] ifFalse: [ allButtons := owner submorphs select: [:m |  m class = self class ].        self updateFeedbackForEvt: evt ]expandFullBoundsForRolloverBorder: aRectangle  | delta |  delta := self valueOfProperty: #rolloverWidth ifAbsent: [ 10 @ 10 ].  ^aRectangle expandBy: deltawouldAcceptKeyboardFocusUponTab  ^falseminExtent  ^100 @ 50 * self displayScaleFactornewAlphaImage: aForm help: helpText  ^self theme newAlphaImageIn: self image: aForm help: helpTextinitialize  balloonColor := self class balloonColor.  super initialize.  self beSmoothCurve.  offsetFromTarget := 0 @ 0handleEvent: evt from: aHand  | localEvt timedOut isDrag |  timedOut := evt timeStamp - firstClickTime > dblClickTime.  localEvt := evt transformedBy: (clickClient transformedFrom: aHand owner).  isDrag := (localEvt position - firstClickDown position) r > dragThreshold.  clickState == #firstClickDown ifTrue: [ (timedOut and: [ localEvt isMouseUp not ]) ifTrue: [ clickState := #firstClickTimedOut.              dragSelector ifNil: [ aHand resetClickState.                    self                       doubleClickTimeout;                       click ].              ^true ].        localEvt isMouseUp ifTrue: [ (timedOut or: [ dblClickSelector isNil ]) ifTrue: [ self click.                    aHand resetClickState.                    ^true ].              firstClickUp := evt copy.              clickState := #firstClickUp.              self click.              aHand handleEvent: firstClickUp.              ^false ].        isDrag ifTrue: [ self doubleClickTimeout.              aHand resetClickState.              dragSelector ifNil: [ self click ] ifNotNil: [ self drag: firstClickDown ].              ^true ].        ^false ].  clickState == #firstClickTimedOut ifTrue: [ localEvt isMouseUp ifTrue: [ aHand resetClickState.              self                 doubleClickTimeout;                 click.              ^true ].        isDrag ifTrue: [ aHand resetClickState.              self                 doubleClickTimeout;                 drag: firstClickDown.              ^true ].        ^false ].  clickState == #firstClickUp ifTrue: [ timedOut ifTrue: [ aHand resetClickState.              self doubleClickTimeout.              ^true ].        localEvt isMouseDown ifTrue: [ clickState := #secondClickDown.              ^false ] ].  clickState == #secondClickDown ifTrue: [ timedOut ifTrue: [ aHand resetClickState.              self doubleClickTimeout.              ^true ].        isDrag ifTrue: [ self doubleClickTimeout.              aHand resetClickState.              dragSelector ifNil: [ self click ] ifNotNil: [ self drag: firstClickDown ].              ^true ].        localEvt isMouseUp ifTrue: [ aHand resetClickState.              self doubleClick.              ^false ] ].  ^truecontainer: aTreeMorph  container := aTreeMorphcolor  ^colordispatchEvent: anEvent with: aMorph  morph := aMorph.  [ ^anEvent sentTo: self ] ensure: [ morph := nil ]wantsDroppedMorph: aMorph event: anEvent  ^self model wantsDroppedMorph: aMorph event: anEvent inMorph: selfallRecipients  ^subscriptions collect: #recipientschanged  self table ifNil: [ ^self ].  self setNeedsRefreshExposedRows.  super changedcalcEnoughSegments  ^self enough: 4 withMeasure: (self measureFor: 2) withIn: self leewaykeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self changedadoptPaneColor: aColor  rotationDegrees: degrees  initialize  super initialize.  cellSpacing := listSpacing := wrapDirection := #none.  cellPositioning := #center.  listCentering := wrapCentering := #topLeft.  listDirection := #topToBottom.  reverseTableCells := rubberBandCells := false.  layoutInset := cellInset := minCellSize := 0.  maxCellSize := 1073741823bottomRightCorner  ^self intersectionWithLineSegmentFromCenterTo: bounds bottomRightalert: aStringOrText title: aString  ^self alert: aStringOrText title: aString configure: [:d |   ]executeSortingOn: aDataSource  aDataSource sortWith: self context ascendingSortFunctionkeystrokeSelector: aSelector  keystrokeSelector := aSelectorbuildButtonWithIconRight  ^(PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: nil) beIconRightcontents: aString withMarkers: aBool  ^self contents: aString withMarkers: aBool inverse: falsecontentMorph: anObject  contentMorph := anObjectdisplay: aBlock  self dataSource display: aBlockdefaultSliderFillStyle  ^(GradientFillStyle colors: {Color white .         Color black})     origin: self topLeft;     direction: (self bounds isWide ifTrue: [ self width @ 0 ] ifFalse: [ 0 @ self height ])children: aCollectionOfItem  children := aCollectionOfItemdefaultBounds  ^0 @ 0 corner: 50 @ 40doubleClick: event onItem: aMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlerswrapBlockOrSelector  ^wrapBlockOrSelector ifNil: [ wrapBlockOrSelector := #printString ]commandKeyPressed  ^buttons anyMask: 2r01000000shouldGetStepsFrom: aWorld  (self isWorldMorph and: [ owner notNil ]) ifTrue: [ ^self outermostWorldMorph == aWorld ].  ^super shouldGetStepsFrom: aWorldkey  ^Smalltalk os keyForValue: keyValuesetLabelWidgetAllowance  ^labelWidgetAllowance := 0preferedPaneColor: aColor  self color: (preferedPaneColor := aColor)openOrClosePhrase  | curveName |  curveName := (self isCurve ifTrue: [ 'curve' ] ifFalse: [ 'polygon' ]) translated.  ^closed ifTrue: [ 'make open {1}' translated format: {curveName} ] ifFalse: [ 'make closed {1}' translated format: {curveName} ]roots  ^rootstype  ^#dropFilesEventchooseColor  ^self chooseColor: Color blackupdateProgressValue  color: aColor  (aColor isColor or: [ aColor isKindOf: InfiniteForm ]) ifFalse: [ ^self fillStyle: aColor ].  color = aColor ifFalse: [ self assureExtension.        extension fillStyle: nil.        color := aColor.        self changed ]getOldColor  ^oldColor ifNil: [ Color transparent ]getMenu: shiftPressed  | menu |  getMenuSelector ifNil: [ ^nil ].  menu := self theme newMenuIn: self for: model.  getMenuSelector numArgs = 1 ifTrue: [ ^model perform: getMenuSelector with: menu ].  getMenuSelector numArgs = 2 ifTrue: [ ^model perform: getMenuSelector with: menu with: shiftPressed ].  ^self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'recursiveAddTo: aCollection  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aNode recursiveAddTo: aCollection ] ].  aCollection add: selfextent: newExtent  super extent: newExtent.  self resizerChangedshiftSelectMorph: aNodeMorph  | m |  m := aNodeMorph ifNil: [ self allNodeMorphs last ].  self emptySelection.  self searchedElement: nil.  self from: firstClickedMorph to: m do: [:nd |  self addToSelection: nd ].  self lastClickedMorph: m.  ^m path collect: [:p |  p complexContents ]initialize  super initialize.  self hResizing: #spaceFill.  self vResizing: #spaceFill.  splitsTopAndBottom := false.  leftOrTop := OrderedCollection new.  rightOrBottom := OrderedCollection newarguments: args  arguments := argsremoveOnlyLastSelected: aBoolean  removeOnlyLastSelected := aBooleansort: aDataSource  | nextState |  nextState := self nextState.  self context state: nextState.  nextState executeSortingOn: aDataSourceaddMorphFront: aMorph  ^self privateAddMorph: aMorph atIndex: 1balloonHelpEnabled  ^self theme settings balloonHelpEnableddefaultColor  ^self containingWindow ifNil: [ Color lightGreen ] ifNotNil: [:w |  w defaultBackgroundColor ]newStack  ^self theme newStackIn: self for: #()autoScrollView: evt  | localEvt |  localEvt := evt transformedBy: (self transformedFrom: editView).  super mouseMove: localEvt.  editView scrollSelectionIntoView: localEvtcollapseAll  self roots do: [:m |  self collapseAll: m ].  self adjustSubmorphPositionsgridFormOrigin: origin grid: smallGrid background: backColor line: lineColor  | bigGrid gridForm gridOrigin |  gridOrigin := origin \\ smallGrid.  bigGrid := smallGrid asPoint x @ smallGrid asPoint y.  gridForm := Form extent: bigGrid depth: Display depth.  backColor ifNotNil: [ gridForm fillWithColor: backColor ].  gridOrigin x to: gridForm width by: smallGrid x do: [:x |  gridForm fill: (x @ 0 extent: 1 @ gridForm height) fillColor: lineColor ].  gridOrigin y to: gridForm height by: smallGrid y do: [:y |  gridForm fill: (0 @ y extent: gridForm width @ 1) fillColor: lineColor ].  ^InfiniteForm with: gridFormtoggleStayUp: evt  self items do: [:item |  item isStayUpItem ifTrue: [ self stayUp: stayUp not.              stayUp ifTrue: [ item contents: 'dismiss this menu' ] ifFalse: [ item contents: 'keep this menu up' ] ] ].  evt hand releaseMouseFocus: self.  stayUp ifFalse: [ self topRendererOrSelf delete ]defaultColor  ^Color gray alpha: 0.15drawLinesToFirstChildOn: aCanvas  | vLineX vLineTop vLineBottom childBounds childCenter myTheme ldelta |  self firstChild hasToggle ifTrue: [ ^self ].  childBounds := self firstChild toggleRectangle.  childCenter := childBounds center.  vLineX := childCenter x.  vLineTop := bounds bottom.  ldelta := container treeLineWidth // 2.  self firstChild hasToggle ifTrue: [ vLineBottom := childCenter y - (childBounds height // 2) + ldelta ] ifFalse: [ vLineBottom := childCenter y - 2 ].  myTheme := self theme.  aCanvas frameRectangle: ((vLineX - ldelta) @ vLineTop corner: (vLineX + ldelta + (container treeLineWidth \\ 2)) @ vLineBottom) width: container treeLineWidth colors: (myTheme treeLineColorsFrom: self lineColor) dashes: self treeLineDashesfontSized: aPointSize  ^LogicalFont familyName: self defaultFontFamiliyName pointSize: aPointSizeisKeyboard  ^falseboundsForBalloon  ^self boundsInWorldicon  | originalIcon |  originalIcon := super icon.  originalIcon ifNil: [ ^originalIcon ].  ^self isPressed ifTrue: [ (originalIcon asFormOfDepth: 32) dimmed ] ifFalse: [ originalIcon ]extent: p  super extent: p.  self updateGradientsdefaultBorderColor  ^Color r: 0.861 g: 1.0 b: 0.722itemMorphGetter: aSelectorOrAValuable  rowMorphGetSelector := aSelectorOrAValuable isSymbol ifTrue: [ [:node |  node complexContents item perform: aSelectorOrAValuable ] ] ifFalse: [ [:node |  aSelectorOrAValuable value: node complexContents item ] ]removeMenuBox  menuBox ifNotNil: [ menuBox delete.        menuBox := nil ]icon  | state |  self getStateSelector ifNil: [ ^super icon ].  state := (MessageSend receiver: self target selector: self getStateSelector) valueWithEnoughArguments: self arguments.  self flag: #pharoFixMe.  (state isKindOf: Association) ifTrue: [ ^state key ifTrue: [ self onImage ] ifFalse: [ self offImage ] ] ifFalse: [ (state = true or: [ state isString and: [ (state beginsWith: '<yes>') or: [ state beginsWith: '<on>' ] ] ]) ifTrue: [ ^self onImage ].        (state = false or: [ state isString and: [ (state beginsWith: '<no>') or: [ state beginsWith: '<off>' ] ] ]) ifTrue: [ ^self offImage ] ].  ^super iconendAt: aNumber  end := aNumberlastPage  | p |  p := (self nodeList size / pageSize) asInteger.  self nodeList size \\ pageSize > 0 ifTrue: [ p := p + 1 ].  ^pbrightness  ^(self selectedColor brightness * 255) asIntegerfindReplaceSelectionRegex: aRegex  findReplaceSelectionRegex := aRegexmodel: anObject  super model: anObject.  self title: self titleupdateHandles  | newVert |  self isCurvy ifTrue: [ handles first center: vertices first.        handles last center: vertices last.        self midVertices withIndexDo: [:midPt :vertIndex |  (closed or: [ vertIndex < vertices size ]) ifTrue: [ newVert := handles atWrap: vertIndex * 2.                    newVert position: midPt - (newVert extent // 2) ] ] ] ifFalse: [ vertices withIndexDo: [:vertPt :vertIndex |  | oldVert |              oldVert := handles at: vertIndex * 2 - 1.              oldVert position: vertPt - (oldVert extent // 2).              (closed or: [ vertIndex < vertices size ]) ifTrue: [ newVert := handles at: vertIndex * 2.                    newVert position: (vertPt + (vertices atWrap: vertIndex + 1) - newVert extent) // 2 + (1 @ -1) ] ] ]rowAtLocation: aPoint  | y |  y := aPoint y.  y < self top ifTrue: [ ^1 ].  listItems with: (1 to: listItems size) do: [:i :row |  y < i bottom ifTrue: [ ^row ] ].  ^listItems sizemorph: anObject  morph := anObject.  self triggerEvent: #tabRefreshed with: selfwantsWindowEvent: anEvent  ^self windowEventHandler notNilclassOrMetaClass: aBehavior  keyStroke: evt  (self scrollByKeyboard: evt) ifTrue: [ ^self ].  self scrollTarget keyStroke: evtbasicKeyStroke: evt  | action |  evt keyValue = 13 ifTrue: [ action := self crAction.        action ifNotNil: [ evt hand newKeyboardFocus: nil.              ^action value ] ].  self handleInteraction: [ editor keystroke: evt ].  self updateFromParagraph.  super keyStroke: evtnewStateForSelected: aBoolean  ^selfnextSibling: anotherMorph  nextSibling := anotherMorphdefaultMorphIn: aThemable  | treeMorph patternMorph |  treeMorph := self defaultTreeMorph buildContents.  patternMorph := patternModel newTextField     hResizing: #spaceFill;     autoAccept: autoAccept;     withGhostText: ghostString;     textFont: StandardFonts defaultFont;     yourself.  patternMorph ghostTextRuler font: StandardFonts defaultFont.  patternMorph announcer when: RubReturnEntered send: #whenReturnInFilter: to: self.  ^self theme newColumnIn: aThemable for: {patternMorph .         treeMorph}keyStroke: event  (self navigationKey: event) ifTrue: [ ^true ].  (self scrollByKeyboard: event) ifTrue: [ ^true ].  ^self listManager keyStroke: eventdoubleClick  self browseItemmenu: menu shifted: b  menu add: 'Expand all' target: self selector: #expandAll.  menu add: 'Browse (b)' target: self selector: #browseItem.  menu add: 'Inspect (i)' target: self selector: #inspectItem.  menu add: 'Explore (I)' target: self selector: #exploreIteminitialize  super initialize.  self     initializeTasks;     initializeLayout;     initializeAppearance;     addMorphs;     updateButtonsAndPreview;     adoptPaneColor: self colorlayoutProportionallyIn: newBounds  self layoutFrame ifNil: [ ^self ].  self isAutoFit ifTrue: [ self fullBounds ].  ^super layoutProportionallyIn: newBoundsisTaskbar  ^trueinsertionPointColor  self focused ifFalse: [ ^Color transparent ].  ^Display depth <= 2 ifTrue: [ Color black ] ifFalse: [ self class insertionPointColor ]outermostWorldMorph  ^self world ifNil: [ self currentWorld ]takesKeyboardFocus  ^truefirstClickedMorph  ^firstClickedMorphnotify: aString at: anInteger in: aStream  ^self editor notify: aString at: anInteger in: aStreamkeyStroke: event  (self navigationKey: event) ifTrue: [ ^self ].  event keyCharacter = Character arrowLeft ifTrue: [ self selectPreviousTab ].  event keyCharacter = Character arrowRight ifTrue: [ self selectNextTab ]isSelectedMatchingTheState: aBoolean  ^self subclassResponsibilityminWidth  ^10 * self displayScaleFactorstoreOn: aStream  aStream nextPutAll: type.  aStream space.  self timeStamp storeOn: aStream.  aStream space.  position x storeOn: aStream.  aStream space.  position y storeOn: aStream.  aStream space.  buttons storeOn: aStreamnewLabel: aFont  ^self newLabel font: aFontmoveUp: evt  ^self moveSelectionDown: -1 event: evthUpdateScrollbar  self hScrollbarNeeded ifTrue: [ self           hShowScrollbar;           hResizeScrollbar ] ifFalse: [ self hHideScrollbar ]clipLayoutCells: aBool  aBool == false ifTrue: [ self removeProperty: #clipLayoutCells ] ifFalse: [ self setProperty: #clipLayoutCells toValue: aBool ].  self changedcellSpacing: aSymbol  self assureTableProperties cellSpacing: aSymbol.  self layoutChangedtable  ^tableclient: aMorphList  client := aMorphListtestIsBellowRow  self subclassResponsibilitynewTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel  ^self newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: nilhash  ^buttons hash + keyValue hashaddAlarm: aSelector withArguments: args after: delayTime  ^self addAlarm: aSelector withArguments: args at: Time millisecondClockValue + delayTimeadjustSubmorphPositions  maxNodeWidth := 0.  ^self adjustSubmorphPositionsOf: self allNodeMorphs startIdx: 1 startPos: 0 @ 0resizable: aBoolean  resizable := aBooleanage: anInteger  self item age: anInteger.  self changed: #agemouseTrailFrom: currentBuf  | nextEvent trail |  trail := (Array new: 1) writeStream.  trail nextPut: currentBuf third @ currentBuf fourth.  [ (nextEvent := Sensor peekEvent) isNil ] whileFalse: [ nextEvent first = currentBuf first ifFalse: [ ^trail contents ].        nextEvent fifth = currentBuf fifth ifFalse: [ ^trail contents ].        nextEvent sixth = currentBuf sixth ifFalse: [ ^trail contents ].        nextEvent := Sensor nextEvent.        nextEvent ifNotNil: [ trail nextPut: nextEvent third @ nextEvent fourth ] ].  ^trail contentsinterrupted  self releaseAllFocustab  ^tabdrawBorderOn: aCanvas usingEnds: anArray  | bigClipRect style |  borderDashSpec ifNotNil: [ ^self drawDashedBorderOn: aCanvas usingEnds: anArray ].  style := self borderStyle.  bigClipRect := aCanvas clipRect expandBy: (self borderWidth + 1) // 2.  self lineSegmentsDo: [:p1 :p2 |  | p1i p2i |        p1i := p1 asIntegerPoint.        p2i := p2 asIntegerPoint.        self hasArrows ifTrue: [ ((arrows == #back or: [ arrows == #both ]) and: [ p1 = vertices first ]) ifTrue: [ p1i := anArray first asIntegerPoint ].              ((arrows == #forward or: [ arrows == #both ]) and: [ p2 = vertices last ]) ifTrue: [ p2i := anArray last asIntegerPoint ] ].        (closed or: [ ((p1i min: p2i) max: bigClipRect origin) <= ((p1i max: p2i) min: bigClipRect corner) ]) ifTrue: [ style drawLineFrom: p1i to: p2i on: aCanvas ] ]nextVisibleWindow  ^self visibleSystemWindows ifEmpty: [ nil ] ifNotEmpty: [:windows |  windows after: self currentWindow ifAbsent: [ windows first ] ]depth  ^depth ifNil: [ depth := 0 ]layoutBounds: aRectangle  super layoutBounds: aRectangle.  self updateGradientskeyStroke: anEvent  (anEvent anyModifierKeyPressed or: [ anEvent keyCharacter isAlphaNumeric not ]) ifTrue: [ ^false ].  currentSelIndex := self table selectedIndex.  currentHighlightedIndexes := self table highlightedIndexes.  self showSearchFieldFromKeystrokeEvent: anEvent.  ^truemenu  | newMenu |  newMenu := MenuMorph new defaultTarget: self.  menu ifNotNil: [ menu cull: newMenu ].  self addRefreshMenuItemOn: newMenu.  ^newMenuwrapSelector: aSymbol  self basicWrapSelector: aSymbol.  self updateListaddNodePath: aPath  ^self subclassResponsibilityprintOn: aStream  super printOn: aStream.  aStream nextPutAll: ' ( '.  aStream     print: self leftFraction @ self topFraction;     nextPutAll: ' + ';     print: self leftOffset @ self topOffset;     nextPutAll: 'px corner: ';     print: self rightFraction @ self bottomFraction;     nextPutAll: ' + ';     print: self rightOffset @ self bottomOffset;     nextPutAll: 'px ) 'stepTime  ^model ifNotNil: [ model stepTimeIn: self ] ifNil: [ 200 ]recomposeFrom: start to: stop delta: delta  | startLine newLines |  startLine := (self lineIndexForCharacter: start) - 1 max: 1.  [ startLine > 1 and: [ (lines at: startLine - 1) top = (lines at: startLine) top ] ] whileTrue: [ startLine := startLine - 1 ].  newLines := OrderedCollection new: lines size + 1.  1 to: startLine - 1 do: [:i |  newLines addLast: (lines at: i) ].  text string isOctetString ifTrue: [ ^self composeLinesFrom: (lines at: startLine) first to: stop delta: delta into: newLines priorLines: lines atY: (lines at: startLine) top ].  self multiComposeLinesFrom: (lines at: startLine) first to: stop delta: delta into: newLines priorLines: lines atY: (lines at: startLine) topinitialize  super initialize.  self     extent: 180 @ 168;     changeTableLayout;     cellInset: 4;     aMorph: self newAColorMorph;     hsvMorph: self newHSVColorMorph;     addMorphBack: self hsvMorph;     addMorphBack: self aMorph.  self aMorph color: self hsvMorph selectedColormorphPreceding: aSubmorph  | anIndex |  anIndex := submorphs indexOf: aSubmorph ifAbsent: [ ^nil ].  ^anIndex > 1 ifTrue: [ submorphs at: anIndex - 1 ] ifFalse: [ nil ]updateItemsWithTarget: aTarget orWithHand: aHand  self items do: [:item |  item target ifNotNil: [ item target isHandMorph ifTrue: [ item target: aHand ] ifFalse: [ item target: aTarget ] ] ]initialize  super initialize.  self     listDirection: #leftToRight;     vResizing: #shrinkWrap;     wrapCentering: #topLeft;     cellPositioning: #center;     cellSpacing: #none;     layoutInset: 2;     clipSubmorphs: truemodel: anObject  super model: anObject.  self paneColorTracksModel ifTrue: [ self           setProperty: #paneColor toValue: self defaultBackgroundColor;           fillStyle: self fillStyleToUse;           setStripeColorsFrom: self paneColorToUse.        self theme fadedBackgroundWindows ifFalse: [ self adoptPaneColor: self paneColor ] ].  self minimumExtent: ((anObject respondsTo: #minimumExtent) ifTrue: [ anObject minimumExtent ]).  menuBox ifNotNil: [ menuBox           labelGraphic: (self theme windowMenuIconFor: self);           height: self boxExtent y ]rootNodeClassFromItem: anItem  ^ClassListNodeExampleupImage  ^self class arrowOfDirection: (bounds isWide ifTrue: [ #left ] ifFalse: [ #top ]) size: (self buttonExtent x min: self buttonExtent y) color: self buttonImageColoracquireWidth: anOwnerWidth  ^self widthOrUndefined min: anOwnerWidthaddMorphFrontFromWorldPosition: aMorph  ^self addMorphFront: aMorph fromWorldPosition: aMorph positionInWorldaddRightOrBottom: aMorph  rightOrBottom add: aMorphnewCancelButtonFor: aModel  ^self theme newCancelButtonIn: self for: aModelcellColumn: column row: rowIndex  ^FTCellMorph new     cellInset: 5;     addMorphBack: (self iconFor: rowIndex) asMorph;     addMorphBack: (Morph new           changeTableLayout;           hResizing: #shrinkWrap;           listDirection: #topToBottom;           color: Color transparent;           addMorphBack: ((self elementAt: rowIndex) protocol asMorph emphasis: 2r10);           addMorphBack: (self elementAt: rowIndex) name asMorph;           yourself);     yourselfgtInspectorMorphIn: composite  < gtInspectorPresentationOrder: 90>  | morphPresentation |  morphPresentation := composite morph.  morphPresentation     title: 'Morph';     display: [ [ self imageForm asMorph on: #mouseDown send: #value: to: [:event |  morphPresentation selection: (self morphsAt: event position) ] ] on: Error do: [ IconicListItem text: 'Error drawing Morph' icon: (self iconNamed: #smallWarningIcon) ] ];     act: [:pres |  self exportAsPNG ] entitled: 'Export as PNG';     act: [:pres |  self delete ] entitled: 'Delete'drawTabOn: aCanvas  | top myColor cornerRadius myArcLengths myBounds |  cornerRadius := self cornerRadius.  myBounds := self bounds.  self active ifTrue: [ top := myBounds top.        myColor := self color ] ifFalse: [ top := myBounds top + self topInactiveGap.        myColor := self color whiter whiter ].  aCanvas fillRectangle: ((myBounds left + cornerRadius) @ (top + cornerRadius) corner: (myBounds right - cornerRadius) @ self bottom) color: myColor.  aCanvas fillRectangle: ((myBounds left + (cornerRadius * 2)) @ top corner: (myBounds right - (cornerRadius * 2)) @ (top + cornerRadius)) color: myColor.  aCanvas fillOval: ((myBounds left + self cornerRadius) @ top corner: (myBounds left + (self cornerRadius * 3)) @ (top + (self cornerRadius * 2))) color: myColor.  aCanvas fillOval: ((myBounds right - (self cornerRadius * 3)) @ top corner: (myBounds right - self cornerRadius) @ (top + (self cornerRadius * 2))) color: myColor.  myArcLengths := self arcLengths.  1 to: myArcLengths size do: [:i |  | length |        length := myArcLengths at: i.        aCanvas line: (myBounds left + cornerRadius - i) @ (myBounds bottom - 1) to: (myBounds left + cornerRadius - i) @ (myBounds bottom - length - 1) color: myColor.        aCanvas line: (myBounds right - cornerRadius + i - 1) @ (myBounds bottom - 1) to: (myBounds right - cornerRadius + i - 1) @ (myBounds bottom - length - 1) color: myColor ]isMouseWheel  ^trueminWidth  | subMenuWidth iconWidth markerWidth |  subMenuWidth := self hasSubMenu ifTrue: [ 10 ] ifFalse: [ 0 ].  iconWidth := self hasIcon ifTrue: [ self icon width + 2 ] ifFalse: [ 0 ].  markerWidth := self hasMarker ifTrue: [ self submorphBounds width + 8 ] ifFalse: [ 0 ].  ^(self fontToUse widthOfString: contents) + subMenuWidth + iconWidth + markerWidth + 10activateCursor: aCursor  aCursor beCursortestIsBellowRow  self assert: (strategy is: 3 bellowRow: 2).  self deny: (strategy is: 3 bellowRow: 4).  self deny: (strategy is: 3 bellowRow: 3)openFindDialog  self flashenableDragNDrop  self enableDragNDrop: truevScrollbarShowing  ^self vScrollbar owner notNilactiveLabelFillStyle  ^self theme windowActiveLabelFillStyleFor: selfalpha: anInteger  | c |  c := self selectedColor.  self selectedColor: (c alpha: anInteger / 255)rectanglesAt: lineY height: lineHeight  | hProfile rects thisWidth thisX count pair outerWidth lineRect lineForm |  pair := Array with: lineY with: lineHeight.  rects := rectangleCache at: pair ifAbsent: [ nil ].  rects ifNotNil: [ ^rects ].  outerWidth := minWidth + (2 * OuterMargin).  self shadowForm.  lineRect := 0 @ (lineY - shadowForm offset y) extent: shadowForm width @ lineHeight.  lineForm := shadowForm copy: lineRect.  lineForm tallyPixelValues second = lineRect area ifTrue: [ rects := Array with: (shadowForm offset x @ lineY extent: lineRect extent) ] ifFalse: [ hProfile := lineForm xTallyPixelValue: 1 orNot: false.        rects := OrderedCollection new.        thisWidth := 0.        thisX := 0.        1 to: hProfile size do: [:i |  count := hProfile at: i.              count >= lineHeight ifTrue: [ thisWidth := thisWidth + 1 ] ifFalse: [ thisWidth >= outerWidth ifTrue: [ rects addLast: ((thisX + shadowForm offset x) @ lineY extent: thisWidth @ lineHeight) ].                    thisWidth := 0.                    thisX := i ] ].        thisWidth >= outerWidth ifTrue: [ rects addLast: ((thisX + shadowForm offset x) @ lineY extent: thisWidth @ lineHeight) ] ].  rects := rects collect: [:r |  r insetBy: OuterMargin @ 0 ].  rectangleCache at: pair put: rects.  ^rectsimageFormForRectangle: rect  ^self imageForm: Display depth forRectangle: rectinitializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigationoffset: newOffset  transform := transform withOffset: newOffset - self innerBounds topLeft.  self changedstartAt: aNumber  startValue := aNumberupdate: what  what ifNil: [ ^self ].  what == getRootsSelector ifTrue: [ self roots: (model perform: getRootsSelector) ].  what == getSelectedPathSelector ifTrue: [ ^self selectPath: (model perform: getSelectedPathSelector) in: (scroller submorphs at: 1 ifAbsent: [ ^self ]) ].  ^super update: whatdrawOn: aCanvas  aCanvas     fillRectangle: self bounds fillStyle: self backgroundColor;     drawString: self contents in: self stringBounds font: self fontToUse color: self stringColor underline: (emphasis bitAnd: 2r100) ~~ 0 underlineColor: self underlineColor strikethrough: (emphasis bitAnd: 2r10000) ~~ 0 strikethroughColor: self strikethroughColorrootNodeClassFromItem: anItem  ^SimpleGridNodeExampleframeRectangle: aRectangle on: aCanvas  | r |  r := aRectangle.  self borders do: [:b |  b frameRectangle: r on: aCanvas.        r := r insetBy: b width ]mouseEnter: anEvent  self isCursorOverHandle ifTrue: [ self setInverseColors.        self shouldInvalidateOnMouseTransition ifTrue: [ self changed ].        anEvent hand showTemporaryCursor: self resizeCursor ]repressedImage  ^repressedImagerotationDegrees: degrees  setLabel  | newLabel |  newLabel := UIManager default request: 'Please enter a new label for this button' translated initialAnswer: self label.  newLabel isEmptyOrNil ifFalse: [ self labelString: newLabel ]doubleClickSelector  ^doubleClickSelectornewMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: nil useIndex: true help: helpTextdrawOnAthensCanvas: anAthensCanvas  self perform: #drawOnAthensCanvas: withArguments: {anAthensCanvas} inSuperclass: Morph.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOnAthensCanvas: anAthensCanvas ]indexForRow: aRowIndex  ^aRowIndexdragItemSelector: aSymbol  dragItemSelector := aSymbol.  aSymbol ifNotNil: [ self dragEnabled: true ]asMouseEnter  ^self shallowCopy setType: #mouseEnterstartDrag: anEvent  | aTransferMorph |  self dragEnabled ifFalse: [ ^self ].  anEvent hand hasSubmorphs ifTrue: [ ^self ].  oldColor ifNotNil: [ self fillStyle: oldColor.        oldColor := nil ].  aTransferMorph := self model transferFor: self model from: self.  aTransferMorph align: aTransferMorph draggedMorph center with: anEvent position.  anEvent hand grabMorph: aTransferMorph.  anEvent hand releaseMouseFocus: selficonFor: index  | class |  class := self elementAt: index.  ((class includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ class isAbstract not ]) ifTrue: [ class hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        class hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        class hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  class organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ((class includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ class isAbstract not ]) ifTrue: [ class hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        class hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        class hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  class organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ^class systemIconsmoothingOff  smoothing := 1.  self changedaddToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol  self addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol argumentList: EmptyArraybrickImageForm: aBackground  | background form brickBorder |  self isBrick ifFalse: [ ^self imageForm ].  brickBorder := self border.  self border: GLMBrickBorder new.  background := self color.  self color: aBackground.  form := self imageForm.  self color: background.  self border: brickBorder.  ^formnewColorChooserFor: aModel getColor: getSel setColor: setSel getEnabled: enabledSel help: helpText  ^self theme newColorChooserIn: self for: aModel getColor: getSel setColor: setSel getEnabled: enabledSel help: helpTextisDeActivated  ^falselongMessage: aStringOrText title: aString  ^self theme longMessageIn: self text: aStringOrText title: aStringvExtraScrollRange  ^8hasChildrenSelector: aSymbol  hasChildrenSelector := aSymbolwantsToBeCachedByHand  self isTranslucentButNotTransparent ifTrue: [ ^false ].  self clipSubmorphs ifTrue: [ ^true ].  self bounds = self fullBounds ifTrue: [ ^true ].  self submorphsDo: [:m |  (self bounds containsRect: m fullBounds) ifFalse: [ m wantsToBeCachedByHand ifFalse: [ ^false ] ] ].  ^truesubmorphsBehind: aMorph do: aBlock  | behind |  behind := false.  submorphs do: [:m |  m == aMorph ifTrue: [ behind := true ] ifFalse: [ behind ifTrue: [ aBlock value: m ] ] ]mouseDownRow: anIntegerOrNil  self listMorph mouseDownRow: anIntegerOrNilmouseUp: evt  | cp |  cp := evt cursorPoint.  submorphs do: [:m |  (m containsPoint: cp) ifTrue: [ m mouseUp: evt ] ]mouseOverBorderStyle  ^self theme scrollbarMouseOverBorderStyleFor: selftransformFromWorld  ^self transformFrom: nillabelFont  ^self fontSized: self pointSizedefaultLimit  ^5newNoButton  ^self newNoButtonFor: selfgetTextSelector: aSymbol  getTextSelector := aSymbol.  self updateTextalignCentersHorizontally  | minLeft leftMost |  selectedItems size > 1 ifFalse: [ ^self ].  minLeft := (selectedItems collect: [:itm |  itm left ]) min.  leftMost := selectedItems detect: [:m |  m left = minLeft ].  selectedItems do: [:itm |  itm center: itm center x @ leftMost center y ].  self changedlistSelectionAt: index  index isZero ifFalse: [ lastNonZeroIndex := index ].  getSelectionListSelector ifNil: [ ^false ].  ^model perform: getSelectionListSelector with: indexsetDismissColor: evt with: dismissHandle  | colorToUse |  evt hand obtainHalo: self.  colorToUse := (dismissHandle containsPoint: evt cursorPoint) ifFalse: [ Color red muchLighter ] ifTrue: [ Color lightGray ].  self setColor: colorToUse toHandle: dismissHandleselectedRowIndexes  self deprecated: 'Use #selectedIndexes instead' transformWith: '`@receiver selectedRowIndexes' -> '`@receiver selectedIndexes'.  ^self selectedIndexeshandleFocusEvent: evt  (evt isMouse and: [ evt isMouseUp ]) ifTrue: [ ^self mouseUp: evt ].  self processEvent: evt.  evt isKeyboard ifTrue: [ ^self handleEvent: evt ].  (evt isMouseOver or: [ evt isMouse not ]) ifTrue: [ ^self ].  evt isMove ifFalse: [ ^self handleEvent: evt ].  selectedItem ifNotNil: [ (selectedItem activateSubmenu: evt) ifTrue: [ ^self ] ]bottom  ^(self vertProfile findLast: [:count |  count >= minWidth ]) + shadowForm offset ysliderMorph  ^sliderMorphaction: aSymbol  action := aSymbolupdateBalloonText  target ifNotNil: [ self balloonText: (target perform: balloonTextSelector) ]update: aSymbol  aSymbol == self getEnabledSelector ifTrue: [ self updateEnabled.        ^self ].  aSymbol == self getTextSelector ifTrue: [ self updateText.        ^self ]colorForInsets  self owner isSystemWindow ifTrue: [ ^self owner colorForInsets ].  ^super colorForInsetsremoveColumnAtIndex: aPosition  self columns removeAt: aPosition.  self columnsChanged.  self updateListseparatorColor  ^separatorColor ifNil: [ separatorColor := Color gray ]long  ^50margin: anObject  margin := anObjecthandlesMouseOver: event  ^falsetaskbarButtonLeft: aButton event: evt in: aMorph  self valueOfProperty: #taskbarThumbnail ifPresentDo: [:thumb |  thumb delete.        self removeProperty: #taskbarThumbnail ]searchedElement: index  self highlightIndex: indexselectedPressedFillStyle  ^self theme controlButtonSelectedPressedFillStyleFor: selfmouseEnter: event  hasFocus := truedisable  self enabled: falsegetMenuSelector  ^getMenuSelectordoMenu: evt with: menuHandle  | menu |  self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.  target world displayWorld.  menu := innerTarget buildHandleMenu: evt hand.  innerTarget addTitleForHaloMenu: menu.  menu popUpEvent: evt in: target worlddefaultMorphIn: aThemable  ^self defaultTreeMorphtestInitialize  TextMorph initializemouseDownRow: anInteger  anInteger = self mouseDownRow ifTrue: [ ^self ].  self mouseDownRowFrameChanged.  self setProperty: #mouseDownRow toValue: anInteger.  self mouseDownRowFrameChangedmodalSelection: anObject  self setProperty: #modalSelection toValue: anObject.  self isModalInvokationDone: trueisWindowEvent  ^falseisRowIndexVisible: rowIndex  self exposedRows ifNil: [ ^false ].  ^self exposedRows includesKey: rowIndexselectedMouseOverBorderStyle  ^self theme controlButtonSelectedMouseOverBorderStyleFor: selfexpandAllSilently: aMorph  aMorph isExpanded ifFalse: [ aMorph expand ].  aMorph childrenDo: [:ch |  self expandAllSilently: ch ]contents: stringOrText wrappedTo: width  self newContents: ''.  wrapFlag := true.  super extent: width truncated @ self height.  self newContents: stringOrTextselectRowIndexes: anArray andMakeVisibleIf: shouldEnsureVisibleSelection  self deprecated: 'Use #selectIndexes:andMakeVisibleIf: instead' transformWith: '`@receiver selectRowIndexes: `@statements1 andMakeVisibleIf: `@statements2' -> '`@receiver selectIndexes: `@statements1 andMakeVisibleIf: `@statements2'.  self selectIndexes: anArray andMakeVisibleIf: shouldEnsureVisibleSelectiondrawArrowsOnAthensCanvas: aAthensCanvas  | array |  self hasArrows ifFalse: [ ^#() ].  array := Array with: vertices first with: vertices last.  borderColor isColor ifFalse: [ ^array ].  (arrows == #forward or: [ arrows == #both ]) ifTrue: [ array at: 2 put: (self drawArrowOnAthensCanvas: aAthensCanvas at: vertices last from: self nextToLastPoint) ].  (arrows == #back or: [ arrows == #both ]) ifTrue: [ array at: 1 put: (self drawArrowOnAthensCanvas: aAthensCanvas at: vertices first from: self nextToFirstPoint) ].  ^arraydeliverTo: aHandler  ^aHandler update: selector with: argumentsaction: aSymbol  actionSelector := aSymbolnewListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpText  ^self theme newListIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpTextdrawSubMenuMarker: aForm on: aCanvas in: aRectangle  | markerRect |  markerRect := aRectangle topRight + ((aForm width * self displayScaleFactor) negated @ ((aRectangle height - (aForm height * self displayScaleFactor)) // 2)) extent: aForm extent * self displayScaleFactor.  self drawIcon: aForm scaledByDisplayScaleFactor on: aCanvas in: markerRectremoveColumnResizers  self removeAllMorphsIn: self columnResizers.  self columnResizers do: [:r |  r release ].  self columnResizers removeAllselectNodePath: aNodePath  self selection: (MorphTreeMorphSingleSelection new selectedNodePath: aNodePath)normalFillStyle  ^self theme morphTreeSplitterNormalFillStyleFor: selffocusBounds  ^self theme listFocusBoundsFor: selfkeyStroke: anEvent  self isExplicit ifTrue: [ ^false ].  (anEvent keyCharacter = Character escape and: [ initialDataSource isNotNil ]) ifTrue: [ ^self reinitializeTable ].  (anEvent anyModifierKeyPressed or: [ anEvent keyCharacter isAlphaNumeric not ]) ifTrue: [ ^false ].  self showFilterFieldFromKeystrokeEvent: anEvent.  ^truestepTime  ^10startScale: evt with: scaleHandle  self obtainHaloForEvent: evt andRemoveAllHandlesBut: scaleHandle.  target prepareForScaling.  growingOrRotating := true.  positionOffset := 0 @ 0.  originalExtent := target extentlistForSearching  ^getListSelector ifNotNil: [ self getList ] ifNil: [ getListElementSelector ifNil: [ #() ] ifNotNil: [ (1 to: self getListSize) collect: [:index |  self getListItem: index ] ] ]nameMenuColumn: column row: rowIndex  | method menu |  method := (self elementAt: rowIndex) method.  menu := UIManager default newMenuIn: self table for: self.  menu add: 'Browse ' , method methodClass name , '>>#' , method selector target: method selector: #browse.  menu add: 'Inspect #' , method methodClass name , '>>#' , method selector target: method selector: #inspect.  ^menunewPluggableDialogWindow  ^self newPluggableDialogWindow: 'Dialog'actualClass  ^FTSortFunctionColumnSortingStrategyasMouseMove  ^MouseMoveEvent basicNew setType: #mouseMove startPoint: position endPoint: position trail: {position .         position} buttons: buttons hand: source stamp: self timeStampnormalColor  ^self theme buttonColorFor: selficonForm  ^isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScale ]selectedDisabledBorderStyle  ^self theme taskbarItemSelectedDisabledBorderStyleFor: selfkeyStroke: anEvent from: aTreeMorph  self selectedNode ifNotNil: [:current |  current keyStroke: anEvent from: aTreeMorph ]invokeWorldMenu: evt  | menu |  self class shouldShowWorldMenu ifFalse: [ ^self ].  self bringTopmostsToFront.  (menu := self worldMenu) popUpEvent: evt in: self.  ^menucolumn: anObject  column := anObjectfocusBounds  ^(self bounds width < 6 or: [ self bounds height < 6 ]) ifTrue: [ super focusBounds ] ifFalse: [ super focusBounds insetBy: (2 @ 2 corner: 2 @ 0) ]arrowLength: aLength  | theta horizontalOffset verticalOffset newTip delta |  delta := vertices second - vertices first.  theta := delta theta.  horizontalOffset := aLength * theta cos.  verticalOffset := aLength * theta sin.  newTip := vertices first + (horizontalOffset @ verticalOffset).  self verticesAt: 2 put: newTipbottomFraction: aNumber  bottomFraction := aNumbertoggleVisible  self visible ifTrue: [ self hide ] ifFalse: [ self show ]bePressed  self pressed: trueminWidth  ^owner isVertical ifTrue: [ 10 ] ifFalse: [ self theme menuBorderWidth ]setSelectedMorph: aMorph  self changeModelSelection: (scroller submorphs indexOf: aMorph)newAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpTextmaxLength  ^maxLengthis: anIndex bellowRow: aRowIndex  ^self subclassResponsibilityflipHAroundX: centerX  | cent |  cent := centerX ifNil: [ bounds center x ] ifNotNil: [ centerX ].  self setVertices: (vertices collect: [:vv |  ((vv x - cent) * -1 + cent) @ vv y ]) reversedrestoreMorphicDisplay  world     extent: self actualScreenSize;     viewBox: self viewBox;     handsDo: [:h |  h           visible: true;           showTemporaryCursor: nil ];     resizeBackgroundMorph;     submorphsDo: [:each |  each displayExtentChanged ];     fullRepaintNeeded.  world defer: [ Cursor normal show ].  world layoutChangedborderInset  self borderStyle: (BorderStyle inset width: 2)getEnabledSelector  ^getEnabledSelectorintersectFrom: startPt with: startDir to: endPt with: endDir  | det deltaPt alpha beta |  det := startDir x * endDir y - (startDir y * endDir x).  det = 0.0 ifTrue: [ ^nil ].  deltaPt := endPt - startPt.  alpha := deltaPt x * endDir y - (deltaPt y * endDir x).  beta := deltaPt x * startDir y - (deltaPt y * startDir x).  alpha := alpha / det.  beta := beta / det.  alpha < 0 ifTrue: [ ^nil ].  beta > 1.0 ifTrue: [ ^nil ].  ^(startPt x + (alpha * startDir x)) @ (startPt y + (alpha * startDir y))barFillStyle: aFillStyle  ^self setProperty: #barFillStyle toValue: aFillStylepreviousPage  self currentPageFirstIndex > 1 ifTrue: [ currentPageFirstIndex := currentPageFirstIndex - pageSize max: 1.        self showCurrentPage ]displayWorldState: aWorldState ofWorld: aWorld submorphs: submorphs  | deferredUpdateMode handsToDraw allDamage |  submorphs do: [:m |  m fullBounds ].  aWorldState checkIfUpdateNeeded ifFalse: [ ^self ].  deferredUpdateMode := self doDeferredUpdatingFor: aWorld.  deferredUpdateMode ifFalse: [ self assuredCanvas ].  self canvas ifNotNil: [ self canvas roundCornersOf: aWorld during: [ | worldDamageRects handDamageRects |              worldDamageRects := aWorldState drawWorld: aWorld submorphs: submorphs invalidAreasOn: self canvas.              handsToDraw := aWorldState selectHandsToDrawForDamage: worldDamageRects.              handDamageRects := handsToDraw collect: [:h |  h savePatchFrom: self canvas ].              allDamage := worldDamageRects , handDamageRects.              handsToDraw reverseDo: [:h |  self canvas fullDrawMorph: h ] ] ].  aWorldState class debugShowDamage ifTrue: [ aWorld flashRects: allDamage color: Color black ].  self canvas ifNotNil: [:c |  c finish ].  deferredUpdateMode ifTrue: [ self forceDamageToScreen: allDamage ] ifFalse: [ self canvas showAt: aWorld viewBox origin invalidRects: allDamage ].  handsToDraw do: [:h |  h restoreSavedPatchOn: self canvas ].  self     deferUpdates: false;     forceDisplayUpdatemaxEnabled  ^self enabled and: [ self notAtMax ]getBoundsWithFlex  self isFlexed ifTrue: [ ^(owner transform localPointToGlobal: bounds topLeft) extent: bounds extent ] ifFalse: [ ^self bounds ]state: anObject  state := anObjectlastState  ^lastStateresetExtension  (extension notNil and: [ extension isDefault ]) ifTrue: [ extension := nil ]vScrollbarValue: scrollValue  | r |  r := self scrollTarget height - self scrollBounds height max: 0.  self scroller offset: self scroller offset x @ (r * scrollValue) roundedmodelWakeUpIn: aWindow  self viewBox = aWindow panelRect ifFalse: [ self viewBox: aWindow panelRect ]fastTable: aFastTable  fastTable := aFastTablehIsScrollbarNeeded  (self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ]) ifTrue: [ ^false ].  (self valueOfProperty: #hScrollBarAlways ifAbsent: [ false ]) ifTrue: [ ^true ].  ^self hIsScrollableinitWithContents: aString font: aFont emphasis: emphasisCode  super initWithContents: aString font: aFont emphasis: emphasisCode.  self     style: #inset;     trackPaneColor: trueelements  ^self model getListnotAtMax  ^self value < self maxhasMarker  ^self hasSubmorphsdefaultColor  ^self theme textColorpressedThumbFillStyle  ^self theme scrollbarPressedThumbFillStyleFor: selfdisable  self enabled: falseicon: aForm  worldRenderer icon: aFormshow  self visible ifTrue: [ ^self ].  self visible: true.  self changednormal  self changeEmphasis: #normalselectionColor: aColor  exportAsBMP  self exportAs: 'bmp' using: BMPReadWriternewFuzzyLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newFuzzyLabelIn: self for: aModel label: aString offset: 1 alpha: 0.5 getEnabled: enabledSelselectedIndex: index  | oldIndex |  selectedIndex == index ifTrue: [ ^self ].  oldIndex := selectedIndex.  selectedIndex := index min: self tabs size.  self visibleTabRange first > index ifTrue: [ self visibleTabRange: ((index max: 1) to: 0) ] ifFalse: [ self visibleTabRange last < index ifTrue: [ self visibleTabRange: (0 to: index) ] ].  self updateTabs.  self changed: #selectedIndex with: oldIndexgetSelectionListSelector: getListSel  getSelectionListSelector := getListSeldisplayWorldSafely  worldState displayWorldSafely: selfmethodRefList  | list |  list := OrderedCollection new.  subscriptions do: [:subscriptionSet |  subscriptionSet do: [:s |  s ifNotNil: [ list add: (RGMethodDefinition realClass: (s recipient class whichClassIncludesSelector: s selector) selector: s selector) ] ] ].  ^listscanCode  ^scanCodeaddOptionalHandlesTo: aHalo box: box  aHalo addHandleAt: box leftCenter color: Color blue icon: nil on: #mouseUp send: #addOrRemoveItems: to: selfbackgroundColor: aColor  backgroundColor := aColorselectedColor  ^selectedColorcellSpacingString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self cellSpacingprivateMoveBy: delta  super privateMoveBy: delta.  (self fillStyles copyWithout: self fillStyle) do: [:fs |  fs isOrientedFill ifTrue: [ fs origin: fs origin + delta ] ]isRowIndexFullyVisible: rowIndex  ^(self isRowIndexVisible: rowIndex) and: [ (self isRowIndexExceding: rowIndex) not ]ensureCursor  paragraph ifNotNil: [:p |  p showCaret: true ]handleMouseUp: anEvent  container enabled ifFalse: [ ^false ].  (container commandOrCrontrolKeyPressed: anEvent) ifTrue: [ ^container listManager mouseUp: anEvent on: self ].  ^super handleMouseUp: anEventaddToSelection: aMorph  aMorph selected ifTrue: [ ^false ].  self searchedElement: nil.  aMorph highlight.  aMorph selected: true.  ^truelastCharacterIndex  ^self paragraph lastCharacterIndexdata: aData  self subclassResponsibilityopenInWorldExtent: extent  self openInWorld: self currentWorld extent: extentsubmorphsReverseDo: aBlock  submorphs reverseDo: aBlockwantsDropFiles: anEvent  ^self class allowDropFilesmouseDown: evt  self isEmbedded ifTrue: [ ^self ].  self isTopWindow ifTrue: [ self comeToFront ] ifFalse: [ self activate ].  evt hand waitForClicksOrDrag: self event: evt.  evt wasHandled: false.  self submorphsDo: [:morph |  (morph containsPoint: evt cursorPoint) ifTrue: [ morph processEvent: evt ] ].  evt wasHandled: trueinspectItem  self inspectelements  ^elementsgetEnabledSelector: anObject  getEnabledSelector := anObject.  self updateEnabledvalueOfProperty: aSymbol ifAbsentPut: aBlock  ^self assureOtherProperties at: aSymbol ifAbsentPut: aBlocknewSelectedIndexes: anObject  newSelectedIndexes := anObjectathensDrawSelectionOn: anAthensCanvas  selectedRow ifNil: [ ^self ].  selectedRow = 0 ifTrue: [ ^self ].  self athensDrawBackgroundForSelectedRow: selectedRow on: anAthensCanvastheme  ^Smalltalk ui themepotentialDropMorph: aMorph  potentialDropMorph := aMorph.  aMorph highlightForDropderivs: a first: point1 second: point2 third: point3  | len v anArray |  len := a size.  len < 2 ifTrue: [ ^self ].  len > 2 ifTrue: [ v := Array new: len.        v at: 1 put: 4.0.        anArray := Array new: len.        anArray at: 1 put: 6.0 * (a first - (a second * 2.0) + a third).        2 to: len - 2 do: [:i |  v at: i put: 4.0 - (1.0 / (v at: i - 1)).              anArray at: i put: 6.0 * ((a at: i) - ((a at: i + 1) * 2.0) + (a at: i + 2)) - ((anArray at: i - 1) / (v at: i - 1)) ].        point2 at: len - 1 put: (anArray at: len - 2) / (v at: len - 2).        len - 2 to: 2 by: 0 - 1 do: [:i |  point2 at: i put: ((anArray at: i - 1) - (point2 at: i + 1)) / (v at: i - 1) ] ].  point2 at: 1 put: (point2 at: len put: 0.0).  1 to: len - 1 do: [:i |  point1 at: i put: (a at: i + 1) - (a at: i) - (((point2 at: i) * 2.0 + (point2 at: i + 1)) / 6.0).        point3 at: i put: (point2 at: i + 1) - (point2 at: i) ]isLeft  ^direction = Character arrowLeftaddPolyArrowMenuItems: aMenu hand: aHandMorph  aMenu addLine.  aMenu addWithLabel: '---' enablement: [ self isOpen and: [ arrows ~~ #none ] ] action: #makeNoArrows.  aMenu addWithLabel: '-->' enablement: [ self isOpen and: [ arrows ~~ #forward ] ] action: #makeForwardArrow.  aMenu addWithLabel: '<--' enablement: [ self isOpen and: [ arrows ~~ #back ] ] action: #makeBackArrow.  aMenu addWithLabel: '<->' enablement: [ self isOpen and: [ arrows ~~ #both ] ] action: #makeBothArrows.  aMenu add: 'customize arrows' selector: #customizeArrows:.  (self hasProperty: #arrowSpec) ifTrue: [ aMenu add: 'standard arrows' selector: #standardArrows ]stopBlinking  self stopSteppingSelector: #onBlinkCursortestIsMorph  self assert: morph isMorphchildren  ^childrenredMorphTab  ^(LockableTabMorph label: 'Red Morph' icon: (self iconNamed: #smallBackIcon) morph: (Morph new           color: Color red;           yourself))     closeable: false;     yourselfisLocked  extension ifNil: [ ^false ].  ^extension lockeddegreesOfFlex  ^self rotationDegreeschooseColor: aColor  ^self theme chooseColorIn: self title: 'Colour Selector' translated color: aColordoubleClick: event  self isResizeable ifFalse: [ ^self ].  (labelArea containsPoint: event position) ifTrue: [ self expandBoxHit ]transformedBy: aTransform  self setVertices: (self vertices collect: [:v |  aTransform localPointToGlobal: v ])scrollerSubMorphFromPoint: aPoint  | ptY |  scroller hasSubmorphs ifFalse: [ ^nil ].  ptY := (scroller firstSubmorph point: aPoint from: self) y.  scroller firstSubmorph top > ptY ifTrue: [ ^nil ].  scroller lastSubmorph bottom < ptY ifTrue: [ ^nil ].  ^scroller findSubmorphBinary: [:item |  (ptY between: item top and: item bottom) ifTrue: [ 0 ] ifFalse: [ (item top + item bottom) // 2 > ptY ifTrue: [ -1 ] ifFalse: [ 1 ] ] ]setDefaultParameters  self     color: self theme settings derivedMenuColor;     borderWidth: self theme menuBorderWidth;     borderColor: self theme menuBorderColor.  self theme settings flatMenu ifFalse: [ self borderStyle: BorderStyle thinGray.        self           hasDropShadow: true;           shadowColor: self theme menuShadowColor;           shadowOffset: 1 @ 1 ].  self layoutInset: 3.  self cellInset: 0 @ 1updateDownButtonBounds  downButton bounds: (self theme scrollBarDownButtonBoundsFor: self)isOpened  ^falsedisplay: item atRow: row on: aCanvas  | c frame |  row = self mouseDownRow ifFalse: [ ^self ].  frame := self selectionFrameForRow: row.  c := self colorForRow: row.  aCanvas frameRectangle: frame width: 1 colors: {c .         Color transparent} dashes: #(1 1)bottomRightColor  ^width = 1 ifTrue: [ self color twiceLighter ] ifFalse: [ self color lighter ]container: aTreeMorph index: anInteger  container := aTreeMorph.  index := anIntegerupdateData  self subclassResponsibilityhandlesMouseDown: evt  ^trueinvokeMenu: evt  | menu |  menu := self getMenu: evt shiftPressed.  menu ifNotNil: [ menu popUpEvent: evt in: self world ]selectNext  toolbar selectNextownerThatIsA: aClass  ^self firstOwnerSuchThat: [:m |  m isKindOf: aClass ]showSearchFieldFromKeystrokeEvent: anEvent  | s ed founds |  s := anEvent keyCharacter asString asText.  founds := self searchFor: s.  ed := RubFloatingEditorBuilder new     customizeEditorWith: [:editor |  editor bounds: (self table bottomLeft + (0 @ 2) corner: self table bottomRight + (0 @ (editor font height + 6))) ];     withEditedContentsDo: [:contents :editor |  contents ifEmpty: [ founds ifTrue: [ self table selectIndex: currentSelIndex ].              self table highlightIndexes: currentHighlightedIndexes ] ifNotEmpty: [ founds := self searchFor: contents.              founds ifTrue: [ editor setTextWith: (contents                             makeAllColor: self table theme textColor;                             yourself) ] ifFalse: [ editor setTextWith: (contents                             addAttribute: (TextColor new color: Color red);                             yourself) ] ] ];     whenEditorEscapedDo: [ founds ifTrue: [ self table selectIndex: currentSelIndex ].        self table highlightIndexes: currentHighlightedIndexes ].  ed autoAccept: true.  founds ifFalse: [ s addAttribute: (TextColor new color: Color red) ] ifTrue: [ s makeAllColor: self table theme textColor ].  ed openEditorWithContents: smouseDownPriority  ^0isCursorOwner  ^falsemenu: menu shifted: b  self selectedNode ifNotNil: [:current |  current menu: menu shifted: b ].  ^menupressedBorderStyle  ^self theme buttonPressedBorderStyleFor: selflistChanged  columnWidths := nil.  super listChangedvalue  ^valuetriggerBalloonFor: aMorph after: timeOut  self addAlarm: #spawnBalloonFor: with: aMorph after: timeOutfocused  ^focused ifNil: [ focused := false ]setUp  super setUp.  table := FTTableMorph new     addColumn: (FTColumn id: 'column1');     addColumn: (FTColumn id: 'column2');     addColumn: (FTColumn id: 'column3');     dataSource: (FTSimpleDataSource elements: (1 to: 10));     yourself.  self setStrategy.  strategy := table selectionModeStrategyactiveDisabledOverDownFillStyle: aFillStyle  self stateMap atPath: #(active disabled over down) put: aFillStyle.  self changedbeWithoutGrips  self setProperty: #noGrips toValue: true.  self removeGripsrejectsEvent: anEvent  (anEvent isMouse and: [ anEvent isMouseWheel ]) ifTrue: [ ^self visible not ].  ^self isLocked or: [ self visible not ]protocol  ^self method protocolabort: aStringOrText title: aString  ^self theme abortIn: self text: aStringOrText title: aStringcontrols  ^controlsmorphsInFrontOverlapping: aRectangle do: aBlock  ^self morphsInFrontOf: nil overlapping: aRectangle do: aBlockselectionColor: aColor  | window |  selectionColor := aColor.  window := self ownerThatIsA: SystemWindow.  self selectionColorToUse: ((self theme fadedBackgroundWindows not or: [ window isNil or: [ window isActive ] ]) ifTrue: [ aColor ] ifFalse: [ self theme unfocusedSelectionColor ])buildBorderVertices  | borderVertices |  borderVertices := OrderedCollection new.  borderVertices     add: tab bottomLeft;     add: tab topLeft;     add: tab topRight;     add: tab bottomRight.  ^borderVerticeshideHScrollBarIndefinitely: bool  self setProperty: #noHScrollBarPlease toValue: bool.  self hHideOrShowScrollBarcontainsPoint: aPoint  (super containsPoint: aPoint) ifFalse: [ ^false ].  (closed and: [ color isTransparent not ]) ifTrue: [ ^(self filledForm pixelValueAt: aPoint - bounds topLeft + 1) > 0 ].  self lineSegmentsDo: [:p1 :p2 |  (aPoint onLineFrom: p1 to: p2 within: (3 max: (borderWidth + 1) // 2) asFloat) ifTrue: [ ^true ] ].  self arrowForms do: [:f |  (f pixelValueAt: aPoint - f offset) > 0 ifTrue: [ ^true ] ].  ^falsenewFuzzyLabelFor: aModel label: aString offset: offset alpha: alpha getEnabled: enabledSel  ^self theme newFuzzyLabelIn: self for: aModel label: aString offset: offset alpha: alpha getEnabled: enabledSellabel: anObject  label := anObjectshow: aString from: startNumber to: endNumber during: aBlock  | progressMorph result |  self openInWorld.  progressMorph := self addItemShowing: aString from: startNumber to: endNumber.  self     refresh;     reposition.  [ result := progressMorph do: aBlock ] ensure: [ self close: progressMorph ].  ^resultmorphsInFrontOf: someMorph overlapping: aRectangle do: aBlock  self submorphsDo: [:m |  m == someMorph ifTrue: [ owner ifNil: [ ^self ].              ^owner morphsInFrontOf: self overlapping: aRectangle do: aBlock ].        (m fullBoundsInWorld intersects: aRectangle) ifTrue: [ aBlock value: m ] ].  owner ifNil: [ ^self ].  ^owner morphsInFrontOf: self overlapping: aRectangle do: aBlockexportAsJPEG  self exportAs: 'jpeg' using: PluginBasedJPEGReadWritercancelEdits  self releaseParagraph.  editView cancelgradientHalo  ^truesetUp  super setUp.  prototypes add: (TextLine start: 1 stop: 50 internalSpaces: 2 paddingWidth: 1)outerBounds  ^self boundsmakeOpen  closed := false.  handles ifNotNil: [ self           removeHandles;           addHandles ].  self computeBoundslineBorderWidth  ^self borderWidthnewButtonFor: aModel action: actionSel getEnabled: enabledSel label: stringOrText help: helpText  ^self newButtonFor: aModel getState: nil action: actionSel arguments: nil getEnabled: enabledSel label: stringOrText help: helpTextselectedMorphList  ^selectedMorphList ifNil: [ selectedMorphList := LinkedList new ]sentTo: anObject  ^anObject handleWindowEvent: selfpassivate  self submorphsDo: [:m |  m passivate ]autoDeselection: trueOrFalse  self listManager autoDeselection: trueOrFalseprintOn: aStream  super printOn: aStream.  aStream print: contentscenterWidget: aWindow  aWindow     fullBounds;     center: self centernewGroupbox: aString for: control  ^self theme newGroupboxIn: self label: aString for: controlnotExpandedFormForMorph: aMorph  ^(aMorph selected and: [ self selectionColor luminance < 0.7 ]) ifTrue: [ self theme whiteTreeUnexpandedForm ] ifFalse: [ self theme treeUnexpandedForm ]selectFirst  self table selectIndex: 1edgeName: aSymbol  edgeName := aSymbol.  self     setLayoutSizingFor: aSymbol;     layoutFrame: self gripLayoutFrame;     layoutChangedpressedFillStyle  ^self theme buttonPressedFillStyleFor: selfhasNodeContents: node  hasChildrenSelector ifNil: [ ^node contents isNotEmpty ].  ^model perform: hasChildrenSelector with: node itemlayout: oldBounds in: newBounds  ^self transform: newBoundsisMenubar  ^truegradientRamp: colorRamp  gradientRamp := colorRamp.  self updateColorupArrow  ^UpArrowdoOneSubCycle  worldState doOneSubCycleFor: selfaddMiscExtrasTo: aMenu  | subMenu |  self isWorldMorph ifTrue: [ ^self ].  subMenu := UIManager default newMenuIn: self for: self.  self renderedMorph isSystemWindow ifFalse: [ subMenu add: 'put in a window' selector: #embedInWindow ].  subMenu add: 'adhere to edge...' selector: #adhereToEdge.  aMenu add: 'extras...' subMenu: subMenuindexForInserting: aMorph at: aPoint in: owner  | horizontal morphList index |  owner hasSubmorphs ifFalse: [ ^1 ].  aMorph disableTableLayout ifTrue: [ ^1 ].  horizontal := (owner listDirection == #topToBottom or: [ owner listDirection == #bottomToTop ]) not.  morphList := owner submorphs.  owner reverseTableCells ifTrue: [ morphList := morphList reversed ].  index := self indexForInserting: aPoint inList: morphList horizontal: horizontal target: owner.  owner reverseTableCells ifTrue: [ index := morphList size - index + 2 ].  ^index ifNil: [ 1 ]dataSource  ^dataSourceactualClass  ^FTUnsortedSortingStatedebug  job isRunning ifTrue: [ job debug ]handlesKeyboard: evt  ^(self handlesKeyDown: evt) or: [ (self handlesKeyUp: evt) or: [ self handlesKeyStroke: evt ] ]fullDrawOn: aCanvas  | disableCaching subBnds roundCorners rounded |  self visible ifFalse: [ ^self ].  (aCanvas isVisible: self fullBounds) ifFalse: [ ^self ].  disableCaching := false.  disableCaching ifTrue: [ self nonCachingFullDrawOn: aCanvas.        ^self ].  submorphs isEmpty ifTrue: [ cacheCanvas := nil.        ^self drawOn: aCanvas ].  subBnds := Rectangle merging: (submorphs collect: [:m |  m fullBounds ]).  self updateCacheCanvas: aCanvas.  (cacheCanvas isNil or: [ cachedCanvasHasHoles and: [ cacheCanvas depth = 1 ] ]) ifTrue: [ self nonCachingFullDrawOn: aCanvas.        ^self ].  roundCorners := cachedCanvasHasHoles == false and: [ submorphs size = 1 and: [ submorphs first wantsRoundedCorners ] ].  roundCorners ifTrue: [ rounded := submorphs first.        aCanvas asShadowDrawingCanvas translateBy: self shadowOffset during: [:shadowCanvas |  shadowCanvas roundCornersOf: rounded during: [ (subBnds areasOutside: (rounded boundsWithinCorners translateBy: self shadowOffset negated)) do: [:r |  shadowCanvas fillRectangle: r color: Color black ] ] ].        aCanvas roundCornersOf: rounded during: [ aCanvas drawImage: cacheCanvas form at: subBnds origin sourceRect: cacheCanvas form boundingBox ].        ^self drawOn: aCanvas ].  (submorphs anySatisfy: [:m |  m handlesDropShadowInHand not ]) ifTrue: [ aCanvas asShadowDrawingCanvas translateBy: self shadowOffset during: [:shadowCanvas |  cachedCanvasHasHoles ifTrue: [ shadowCanvas paintImage: cacheCanvas form at: subBnds origin ] ifFalse: [ (subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do: [:r |  shadowCanvas fillRectangle: r color: Color black ] ] ] ].  cachedCanvasHasHoles ifTrue: [ aCanvas paintImage: cacheCanvas form at: subBnds origin ] ifFalse: [ aCanvas drawImage: cacheCanvas form at: subBnds origin sourceRect: cacheCanvas form boundingBox ].  self drawOn: aCanvasascendingSortFunction  ^self subclassResponsibilitynewImageFor: aModel get: getSel help: helpText  ^self theme newImageIn: self for: aModel get: getSel help: helpTexttaskOf: aMorph  ^self orderedTasks detect: [:t |  t morph = aMorph ] ifNone: [  ]vHideScrollbar  self vScrollbarShowing ifFalse: [ ^self ].  self removeMorph: self vScrollbar.  self hResizeScrollbar.  self resizeScrollernewGroupboxForAll: controls  ^self theme newGroupboxIn: self forAll: controlsopenPath: anArray  | found |  anArray isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ (each complexContents asString = anArray first or: [ anArray first isNil ]) ifTrue: [ found := each ] ] ].  found ifNil: [ self withSiblingsDo: [:each |  found ifNil: [ (each complexContents asString sameAs: anArray first) ifTrue: [ found := each ] ] ] ].  found ifNotNil: [ found isExpanded ifFalse: [ found toggleExpandedState.              container adjustSubmorphPositions ].        found changed.        anArray size = 1 ifTrue: [ ^container setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild openPath: anArray allButFirst ] ].  ^container setSelectedMorph: nilstartColumnIndex  startColumnIndex ifNil: [ startColumnIndex := 0 ].  ^startColumnIndexselectAllNodePaths: aCollectionOfNodePath  self selection: (MorphTreeMorphMultipleSelection new selectedNodePathList: aCollectionOfNodePath)newMultistateButton  ^self theme newMultistateButtonIn: selfhelpText  ^nilminHeight  ^self theme menuBorderWidthhorizontalScrollBar  ^horizontalScrollBarprintOn: aStream  super printOn: aStream.  aStream     space;     nextPut: $(;     print: self identityHash;     nextPut: $).  locked == true ifTrue: [ aStream nextPutAll: ' [locked] ' ].  visible == false ifTrue: [ aStream nextPutAll: '[not visible] ' ].  sticky == true ifTrue: [ aStream nextPutAll: ' [sticky] ' ].  balloonText ifNotNil: [ aStream nextPutAll: ' [balloonText] ' ].  externalName ifNotNil: [ aStream           nextPutAll: ' [externalName = ' , externalName;           nextPutAll: ' ] ' ].  eventHandler ifNotNil: [ aStream           nextPutAll: ' [eventHandler = ' , eventHandler printString;           nextPutAll: '] ' ].  (otherProperties isNil or: [ otherProperties isEmpty ]) ifTrue: [ ^self ].  aStream nextPutAll: ' [other: '.  self otherProperties keysDo: [:aKey |  aStream           nextPutAll: ' (' , aKey , ' -> ' , (self otherProperties at: aKey) printString;           nextPutAll: ')' ].  aStream nextPut: $]colorToUse  | c |  c := self getModelState ifTrue: [ onColor ifNil: [ self paneColor ] ifNotNil: [ onColor isTransparent ifTrue: [ self paneColor ] ifFalse: [ onColor ] ] ] ifFalse: [ offColor ifNil: [ self paneColor ] ifNotNil: [ offColor isTransparent ifTrue: [ self paneColor ] ifFalse: [ offColor ] ] ].  ^cwouldAcceptKeyboardFocus  ^self isLocked notisSelected  ^self tabSelector ifNil: [ false ] ifNotNil: [:selector |  selector selectedTab == self ]testMaintainingSelectionsOnUpdate  | c w t |  c := ClassTreeExample new.  [ w := c openOn: Collection.  t := c dependents last.  t expandAll.  c selectItems: {Bag .         CharacterSet}.  t selectedMorphList do: [:e |  self assert: ({Bag .               CharacterSet} includes: e complexContents withoutListWrapper) ].  c updateList.  t selectedMorphList do: [:e |  self assert: ({Bag .               CharacterSet} includes: e complexContents withoutListWrapper) ] ] ensure: [ w close ]dragHand  ^dragHandcursorBounds  temporaryCursor ifNil: [ ^self position extent: NormalCursor extent ] ifNotNil: [ ^self position + temporaryCursorOffset extent: temporaryCursor extent ]setAsRow  self     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     borderWidth: 0vScrollbarValue  | tw sw v |  tw := self scrollTarget height.  sw := self scrollBounds height.  v := tw - sw max: 0.  v = 0 ifFalse: [ v := self scroller offset y asFloat / v min: 1.0 ].  ^vresizeScrollBars  self extent = self defaultExtent ifFalse: [ super resizeScrollBars ]intoWorld: aWorld  self     setToAdhereToEdge: #bottomLeft;     updateBounds.  super intoWorld: aWorldresetCollapsedFrame  collapsedFrame := niltestSelectAll  table beSingleSelection.  table selectFirst.  table selectAll.  self assert: table selectedIndexes equals: #(1).  table beMultipleSelection.  table selectFirst.  table selectAll.  self assert: table selectedIndexes equals: #(1 2 3 4 5 6 7 8 9 10)keepLeftMorphsOrder  leftMorphs size > 1 ifTrue: [ leftMorphs := mouseOverMorphs intersection: leftMorphs ]rootItems  ^self itemsForTest asArray sort: [:a :b |  a name < b name ]beMultipleSelection  multipleSelection := trueavoidsOcclusions  ^container notNil and: [ container avoidsOcclusions ]drawable  ^drawable ifNil: [ false ]narrow  self changeEmphasis: #narrowtestWindowCreation  | t oldBounds newBounds |  t := 0.  self currentWorld announcer when: WindowResizing do: [:ann |  t := t + 1 ].  window := SystemWindow labelled: 'foo'.  window setProperty: #minimumExtent toValue: 1 @ 1.  window openInWorld.  oldBounds := window bounds.  window announcer when: WindowResizing do: [:ann |  t := t + 1 ].  self assert: t equals: 0.  window extent: 50 @ 60.  newBounds := window bounds.  self assert: t equals: 1keyStroke: event  self flag: #pharoTodo.  ((super keyStroke: event) or: [ self navigationKey: event ]) ifTrue: [ ^true ].  ^self keyStrokeSearch: eventchooseEmphasisOrAlignment  self editor changeEmphasisOrAlignment.  self updateFromParagraphnewSelectedRowIndexes  self deprecated: 'Use #newSelectedIndexes instead' transformWith: '`@receiver newSelectedRowIndexes' -> '`@receiver newSelectedIndexes'.  ^self newSelectedIndexeskeyStroke: anEvent  | char args |  char := anEvent keyValue asCharacter.  (self arrowEvent: anEvent key: char) ifTrue: [ ^true ].  char = Character cr ifTrue: [ self selectSearchedElement.        ^true ].  anEvent anyModifierKeyPressed ifFalse: [ self basicKeyPressed: char.        ^true ].  self keystrokeActionSelector ifNil: [ ^false ].  args := self keystrokeActionSelector numArgs.  (args = 0 or: [ args > 2 ]) ifTrue: [ ^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol' ] ifFalse: [ ^args = 1 ifTrue: [ self listModel perform: self keystrokeActionSelector with: anEvent ] ifFalse: [ self listModel perform: self keystrokeActionSelector with: anEvent with: self ] ]backgroundColor  ^backgroundColorselectedMorph  ^selectedMorphisTranslucentButNotTransparent  ^truestartDrag: anEvent  | aTransferMorph itemMorph passenger |  self dragEnabled ifTrue: [ itemMorph := self allNodeMorphs detect: [:any |  any highlightedForMouseDown ] ifNone: [  ] ].  (itemMorph isNil or: [ anEvent hand hasSubmorphs ]) ifTrue: [ ^self ].  itemMorph highlightForMouseDown: false.  (self listManager selectedMorphList includes: itemMorph) ifFalse: [ self listManager setSelectedMorph: itemMorph ].  passenger := self model dragPassengerFor: itemMorph inMorph: self.  passenger ifNotNil: [ aTransferMorph := self model transferFor: passenger from: self.        aTransferMorph align: aTransferMorph draggedMorph center with: anEvent position.        aTransferMorph dragTransferType: (self model dragTransferTypeForMorph: self).        anEvent hand grabMorph: aTransferMorph ].  anEvent hand releaseMouseFocus: selfhandlesMouseOver: evt  self table ifNotNil: [:table |  ^table selectionModeStrategy allowsRowSelection ].  ^falsesetStripeColorsFrom: paneColor  stripes ifNil: [ ^self ].  self fillStyle: self fillStyleToUse.  self isActive ifTrue: [ label ifNotNil: [ label color: self activeLabelFillStyle ].        labelArea fillStyle: self activeTitleFillStyle ] ifFalse: [ label ifNotNil: [ label color: self inactiveLabelFillStyle ].        labelArea fillStyle: self inactiveTitleFillStyle ].  self adoptPaneColor: self paneColororderedTasks: anObject  orderedTasks := anObjectgenerateMouseEvent: evtBuf  | position buttons modifiers type trail stamp oldButtons evtChanged |  self class environment at: #KMBuffer ifPresent: [:kmBuffer |  kmBuffer uniqueInstance clearBuffer ].  evtBuf first = lastEventBuffer first ifTrue: [ evtChanged := false.        3 to: evtBuf size do: [:i |  (lastEventBuffer at: i) = (evtBuf at: i) ifFalse: [ evtChanged := true ] ].        evtChanged ifFalse: [ ^nil ] ].  stamp := evtBuf second.  stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].  position := evtBuf third @ evtBuf fourth.  buttons := evtBuf fifth.  modifiers := evtBuf sixth.  type := buttons = 0 ifTrue: [ lastEventBuffer fifth = 0 ifTrue: [ #mouseMove ] ifFalse: [ #mouseUp ] ] ifFalse: [ lastEventBuffer fifth = 0 ifTrue: [ #mouseDown ] ifFalse: [ #mouseMove ] ].  buttons := buttons bitOr: (modifiers bitShift: 3).  oldButtons := lastEventBuffer fifth bitOr: (lastEventBuffer sixth bitShift: 3).  lastEventBuffer := evtBuf.  type == #mouseMove ifTrue: [ trail := self mouseTrailFrom: evtBuf.        ^MouseMoveEvent basicNew setType: type startPoint: self position endPoint: trail last trail: trail buttons: buttons hand: self stamp: stamp ].  ^MouseButtonEvent basicNew setType: type position: position which: (oldButtons bitXor: buttons) buttons: buttons hand: self stamp: stampnewDialogPanel  ^self theme newDialogPanelIn: selfcellInset  ^cellInsetdisabledFillStyle  ^self theme controlButtonDisabledFillStyleFor: selfminHeight  ^self minimumExtent y max: super minHeightextent: aPoint  self extent = aPoint ifTrue: [ ^self ].  super extent: aPoint.  self updateOrientation: aPointpressedBorderStyle  ^self theme taskbarItemPressedBorderStyleFor: selfstepTime  ^100secondName  ^self item secondNamehighlightColor: aColor  self setProperty: #highlightColor toValue: aColorisKeyDown  ^self type == #keyDowncmdGesturesEnabled  ^self class cmdGesturesEnabledseparatorColor: aColor  separatorColor := aColorcolor  ^color ifNil: [ self theme ghostTextColor ]atBottom: aBoolean  atBottom ~= aBoolean ifTrue: [ atBottom := aBoolean ]handleEdit: editBlock  self selectionChanged.  editBlock value.  self selectionChanged.  self updateFromParagraphstartDragExtended: evt  dragItemSelector ifNil: [ ^self ].  evt hand hasSubmorphs ifTrue: [ ^self ].  [ | dragIndex draggedItem ddm ddRect |  (self dragEnabled and: [ model okToChange ]) ifFalse: [ ^self ].  dragIndex := self rowAtLocation: evt position.  dragIndex = 0 ifTrue: [ ^self ].  draggedItem := model perform: dragItemSelector with: dragIndex.  draggedItem ifNil: [ ^self ].  self mouseDownRow: nil.  ddm := self model transferFor: draggedItem from: self.  ddRect := ddm draggedMorph bounds.  ddm position: evt position - (ddRect center - ddRect origin).  ddm dragTransferType: #dragTransfer.  evt hand grabMorph: ddm ] ensure: [ Cursor normal show.        evt hand newMouseFocus: self ]emphasisChoices  ^#(normal bold italic narrow underlined struckOut)defaultColor  ^Color lightGreenwantsDroppedMorph: aMorph event: evt  self visible ifFalse: [ ^false ].  self dropEnabled ifFalse: [ ^false ].  (self tabGroup tabSelectorMorph bounds containsPoint: evt position) ifFalse: [ ^false ].  ^aMorph isSystemWindowaddOptionalHandlesTo: aHalo box: box  testSortDataSource  | dataSource |  dataSource := self dataSourceForTesting.  self assert: dataSource elements equals: self elementsForTestDataSource.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: self elementsForTestDataSourcequestionWithoutCancel: aStringOrText  ^self questionWithoutCancel: aStringOrText title: 'Question' translatedtestHaloIsDisable  | isHaloEnable |  isHaloEnable := Morph halosEnabled.  Morph halosEnabled: false.  self assert: (Morph new addHalo: nil) ~= (Smalltalk globals at: #HaloMorph).  Morph halosEnabled: isHaloEnableprogress  ^progressBar value / 100isWrapped  ^wrapFlagiconSymbol  ^iconSymbolselectedPressedFillStyle  ^self theme buttonSelectedPressedFillStyleFor: selfaboutTitle  | title |  title := self model ifNil: [ 'SystemWindow' ] ifNotNil: [ (self model respondsTo: #aboutTitle) ifTrue: [ self model aboutTitle ] ifFalse: [ self model class name ] ].  ^'About {1}' translated format: {title}waitForClicksOrDrag: aMorph event: evt  ^self waitForClicksOrDrag: aMorph event: evt selectors: #(#click: #doubleClick: #doubleClickTimeout: #startDrag:) threshold: 10elementAt: rowIndex  ^self getListElementSelector ifNotNil: [ self model perform: self getListElementSelector with: rowIndex ] ifNil: [ (self model perform: self getListSelector) at: rowIndex ]mouseDown: anEvent  | cp |  (self bounds containsPoint: anEvent cursorPoint) ifTrue: [ self fillStyle: self pressedFillStyle ].  cp := anEvent cursorPoint.  lastMouse := {cp .   (cp - self position) .   (cp - self targetPoint)}.  self eventHandler ifNotNil: [ self eventHandler mouseDown: anEvent fromMorph: self ]handleMouseMove: anEvent  (anEvent wasHandled or: [ resetable not ]) ifTrue: [ ^self ].  self resetAlpha.  anEvent wasHandled: truesliderColor: newColor  super sliderColor: (self enabled ifTrue: [ Color black ] ifFalse: [ self sliderShadowColor ]).  slider ifNotNil: [ slider borderStyle baseColor: Color white ]newImage: aForm size: aPoint  ^self theme newImageIn: self form: aForm size: aPointdrawIconAndLabelOnAthensCanvas: anAthensCanvas  anAthensCanvas pathTransform restoreAfter: [ self drawIconOnAthensCanvas: anAthensCanvas.        self drawLabelOnAthensCanvas: anAthensCanvas ]handlesDoubleClick  ^self editView handlesDoubleClickinitialize  super initialize.  self locationMorph: self newLocationMorph.  self     clipSubmorphs: true;     color: Color blue;     borderStyle: (BorderStyle inset width: 1);     addMorphBack: self locationMorph;     addMorphBack: self blackGradientMorphheaderColumn: column  ^self basicHeaderCellFor: columnownerChain  | c next |  c := OrderedCollection with: self.  next := self.  [ (next := next owner) notNil ] whileTrue: [ c add: next ].  ^c asArrayroundedCorners: anArray  anArray = #(1 2 3 4) ifTrue: [ self removeProperty: #roundedCorners ] ifFalse: [ self setProperty: #roundedCorners toValue: anArray ].  self changeddefaultColor  ^Color transparentdoDup: evt with: dupHandle  (target isKindOf: SelectionMorph) ifTrue: [ ^target doDup: evt fromHalo: self handle: dupHandle ].  self obtainHaloForEvent: evt andRemoveAllHandlesBut: dupHandle.  self setTarget: (target duplicateMorph: evt).  evt hand grabMorph: target.  self step.  evt hand addMouseListener: selfextent  ^container width @ (lines last bottom - lines first top)handlesKeyboard: evt  ^trueghostText  ^'Filter...'expandedButton  ^self defaultButton     actionSelector: #collapseItem;     labelGraphic: Smalltalk ui theme treeExpandedForm;     helpText: 'Collapse Item';     yourselfroot  (owner isNil or: [ owner isWorldOrHandMorph ]) ifTrue: [ ^self ].  ^owner rootsetArrowheads  | aParameter result |  aParameter := self renderedMorph valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  result := Morph obtainArrowheadFor: 'Head size for arrowheads: ' translated defaultValue: aParameter asString.  result ifNotNil: [ self renderedMorph setProperty: #arrowSpec toValue: result ] ifNil: [ self inform: 'Invalid input' ]hasFillStyle  ^truestyle  ^#raisedmakeBackArrow  arrows := #back.  self computeBoundsmethodsInCategory: aCat  ^self item selectorsInProtocol: aCatasAthensPaintOn: anAthensCanvas  | stroke |  stroke := self color asStrokePaintOn: anAthensCanvas.  stroke width: self width.  stroke joinMiter.  ^strokedisableTableLayout: aBool  disableLayout := aBoolupdateOrientation: aPoint  | butts |  butts := self buttons.  aPoint x >= aPoint y ifTrue: [ self listDirection: #leftToRight.        butts first           roundedCorners: #(1 2);           hResizing: #rigid;           vResizing: #spaceFill;           width: aPoint y;           label: (self newButtonLabel: #left ofSize: aPoint y // 2).        butts last           roundedCorners: #(3 4);           hResizing: #rigid;           vResizing: #spaceFill;           width: aPoint y;           label: (self newButtonLabel: #right ofSize: aPoint y // 2) ] ifFalse: [ self listDirection: #topToBottom.        butts first           roundedCorners: #(1 4);           hResizing: #spaceFill;           vResizing: #rigid;           height: aPoint x;           label: (self newButtonLabel: #top ofSize: aPoint x // 2).        butts last           roundedCorners: #(2 3);           hResizing: #spaceFill;           vResizing: #rigid;           height: aPoint x;           label: (self newButtonLabel: #bottom ofSize: aPoint x // 2) ]computeDays  | cellHeight cellWidth height topLeft lastMonth nextMonth theDay thisMonth |  topLeft := 0 @ 25.  height := self bounds height - 25.  cellHeight := height // 8.  height := height - cellHeight.  cellWidth := self bounds width // 7.  lastMonth := date month previous.  thisMonth := date month.  nextMonth := date month next.  days := OrderedCollection new.  1 to: 6 do: [:lineIndex |  | yOffset |        yOffset := topLeft y + (lineIndex * cellHeight).        (self daysForLine: lineIndex) withIndexDo: [:day :dayIndex |  | cellPosX dayDate |              dayDate := thisMonth asDate addDays: day - 1.              (lineIndex = 1 and: [ day > 7 ]) ifTrue: [ dayDate := lastMonth asDate addDays: day - 1 ].              (lineIndex > 4 and: [ day < 15 ]) ifTrue: [ dayDate := nextMonth asDate addDays: day - 1 ].              cellPosX := cellWidth * (dayIndex - 1).              days add: (theDay := CalendarDayMorph on: dayDate for: self).              theDay bounds: (cellPosX @ yOffset extent: cellWidth @ cellHeight) ] ]adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self fillStyle: self fillStyleToUse.  self borderStyle: self borderStyleToUse.  self cornerStyle: (self isRadioButton ifTrue: [ self theme radioButtonCornerStyleFor: self ] ifFalse: [ self theme checkboxCornerStyleFor: self ])transformFromOutermostWorld  ^self transformFrom: self outermostWorldMorphinvokeWithEvent: evt  | w |  self isEnabled ifFalse: [ ^self ].  owner ifNotNil: [ self isStayUpItem ifFalse: [ self flag: #workAround.              (w := self world) ifNotNil: [ owner deleteIfPopUp: evt.                    w displayWorldSafely ] ] ].  selector ifNil: [ ^self ].  Cursor normal showWhile: [ | selArgCount |        (selArgCount := selector numArgs) = 0 ifTrue: [ target perform: selector ] ifFalse: [ selArgCount = arguments size ifTrue: [ target perform: selector withArguments: arguments ] ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].        self showShortcut.        self changed ]addLabelItemsTo: aCustomMenu hand: aHandMorph  aCustomMenu add: 'change label' selector: #setLabelremovePageIndex: anInteger  self pages removeAt: anInteger.  self tabSelectorMorph removeTabIndex: anIntegermodel  ^modelgripLayoutFrame  ^(1 @ 1 corner: 1 @ 1) asLayoutFrame topLeftOffset: (0 - self defaultWidth) @ (0 - self defaultHeight)valueOfProperty: aSymbol ifPresentDo: aBlock  extension ifNil: [ ^self ].  ^aBlock value: (extension valueOfProperty: aSymbol ifAbsent: [ ^self ])topLeft  ^left @ topaddHalo  ^self addHalo: nilrubberBandCells: aBool  self assureTableProperties rubberBandCells: aBool.  self layoutChangedmouseDownOnHelpHandle: anEvent  | str |  anEvent shiftPressed ifTrue: [ ^self editBalloonHelpText ].  str := self balloonText.  str ifNil: [ str := self noHelpString ].  self showBalloon: str hand: anEvent handtarget  ^targetannounceActivated  self announce: (WindowActivated new           window: self;           yourself)handlesMouseWheel: event  ^self isVerticalScrollBarVisible and: [ self hasDataSource ]coefficientsForMoreThanThreePoints  | verts coefficients vertXs slopeXs vertYs slopeYs bestSegments |  verts := self vertices.  coefficients := {(vertXs := verts collect: [:p |  p x asFloat ]) .   (slopeXs := self slopes: vertXs) .   (self changeInSlopes: slopeXs of: vertXs) .   (self changeOfChangesInSlopes: slopeXs of: vertXs) .   (vertYs := verts collect: [:p |  p y asFloat ]) .   (slopeYs := self slopes: vertYs) .   (self changeInSlopes: slopeYs of: vertYs) .   (self changeOfChangesInSlopes: slopeYs of: vertYs) .   (Array new: verts size withAll: 12)}.  bestSegments := (1 to: verts size) collect: [:i |  (self transform: coefficients toCubicPointPolynomialAt: i) bestSegments ].  coefficients at: 9 put: bestSegments.  curveState := {coefficients .   nil .   nil}.  self computeNextToEndPoints.  ^coefficientsnewText: aStringOrText  ^self theme newTextIn: self text: aStringOrTextdefaultBorderWidth  ^1tableRefresh  table ifNotNil: [ table refresh ]offImage  | form |  form := Form extent: (self fontToUse ascent - 2) asPoint depth: 16.  form getCanvas frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.9) borderWidth: 1 borderColor: Color black.  ^formtestExecuteSortingOn  | dataSource |  dataSource := self dataSourceForTesting.  state executeSortingOn: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10).  state executeSortingOn: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10)backgroundColorForRow: row  ^(self isRowSelected: row) ifTrue: [ listSource selectionColorToUse ] ifFalse: [ self theme backgroundColor ]hideOrShowScrollBar  (self valueOfProperty: #noScrollBarPlease ifAbsent: [ false ]) ifTrue: [ ^self ].  (self vIsScrollbarNeeded not and: [ self isScrolledFromTop not ]) ifTrue: [ self vHideScrollBar ].  (self vIsScrollbarNeeded or: [ self isScrolledFromTop ]) ifTrue: [ self vShowScrollBar ]backgroundColor  ^backgroundColorbuildButtonWithIconTop  ^(PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: nil) beIconTopisVertical  ^self isAdheringToLeft or: [ self isAdheringToRight ]bigTitle: aTitle  self     withCloseBox;     title: aTitle;     font: StandardFonts windowTitleFont;     withPinBoxhorizontalPlacement: hp verticalPlacement: vp color: col iconSymbol: is addHandleSelector: sel  horizontalPlacement := hp.  verticalPlacement := vp.  color := col.  iconSymbol := is asSymbol.  addHandleSelector := selallowedToClose  ^self mustNotClose not and: [ self modalChild isNil ]closeAllTabs  tabs copy do: [:tab |  tab close ]value: aNumber  ^progressBar value: aNumbernewTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel help: helpText  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel help: helpTextexpandAllTo: aDepth  children do: [:each |  each expandAllTo: aDepth ]isActive  ^self state == #activenumberOfRows  ^self subclassResponsibilityforwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectionannounceDeleted  self doAnnounce: (MorphDeleted morph: self).  self submorphs do: #announceDeletedhandlesMouseDown: evt  ^truefindReplaceSelectionColor  ^self theme currentSettings findReplaceSelectionColornewCheckboxFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpTextinitializeSlider  super initializeSlider.  slider borderStyle: (BorderStyle raised           baseColor: slider color;           width: 1)layoutBounds  | inner |  inner := self innerBounds.  ^indentation = 0 ifTrue: [ inner ] ifFalse: [ indentation @ 0 + inner origin corner: inner corner ]selectAll  self allNodeMorphs isEmpty ifTrue: [ ^self ].  self isMultiple ifFalse: [ ^self ].  self addAllToSelection: self allNodeMorphslabelWidgetAllowance  ^labelWidgetAllowance ifNil: [ self setLabelWidgetAllowance ]pattern  ^patterncomputedHeight  ^computedHeight ifNil: [ computedHeight := self computedHeightFromContents + self layoutInset asPoint y + self cellInset asPoint y ]top  ^toprejectDropEvent: anEvent  (self repelsMorph: anEvent contents event: anEvent) ifFalse: [ ^self ].  (self fullContainsPoint: anEvent position) ifFalse: [ ^self ].  anEvent wasHandled: true.  anEvent contents rejectDropMorphEvent: anEventsetFirstCharacter: source  | aChar chars |  aChar := source asCharacter.  (chars := self getCharacters) isEmpty ifTrue: [ self newContents: (String with: aChar) ] ifFalse: [ chars first = aChar ifFalse: [ self newContents: (String streamContents: [:aStream |  aStream nextPut: aChar.                          aStream nextPutAll: (chars copyFrom: 2 to: chars size) ]) ] ]addTab: aTab  toolbar addTab: aTabchooseDropList: aStringOrText list: aList  ^self chooseDropList: aStringOrText title: 'Choose' translated list: aListdrawOnAthensCanvas: anAthensCanvas  self drawOnCanvasWrapperFor: anAthensCanvascontents: aString  ^self contents: aString withMarkers: truedisplayCaretAndSelectionOnAthensCanvas: anAthensCanvas  selectionStart ifNil: [ ^self ].  selectionStart = selectionStop ifTrue: [ self drawCaretOnAthensCanvas: anAthensCanvas ] ifFalse: [ | selection |        caretRect := nil.        selection := ParagraphSelectionBlock first: selectionStart last: selectionStop color: self selectionColor.        self forLinesIn: anAthensCanvas clipRect do: [:line |  selection displayInLine: line onAthensCanvas: anAthensCanvas ] ]getStateSelector  ^getStateSelectorselectRowIndexes: anArray  self deprecated: 'Use #selectIndexes: instead' transformWith: '`@receiver selectRowIndexes: `@statements1' -> '`@receiver selectIndexes: `@statements1'.  self selectIndexes: anArraydo: aBlock  aBlock value: self.  nextCell ifNotNil: [ nextCell do: aBlock ]chooseColor: aColor  ^self theme chooseColorIn: self title: 'Colour Selector' translated color: aColorwantsKeyboardFocusFor: aSubmorph  aSubmorph wouldAcceptKeyboardFocus ifTrue: [ ^true ].  ^super wantsKeyboardFocusFor: aSubmorphvResizing: aSymbol  vResizing := aSymbolheader: aString  self ensureAtLeastOneColumn.  self columns first id: aStringinitializeAppearance  self     color: Color gray;     borderStyle: (BorderStyle inset width: 3)duplicate  selectedItems := selectedItems collect: #duplicate.  selectedItems reverseDo: [:m |  (owner ifNil: [ self currentWorld ]) addMorph: m ].  dupLoc := self position.  ActiveHand grabMorph: selfpositionAt: aPoint relativeTo: aMenuItem inWorld: aWorld  | i yOffset sub delta |  self fullBounds.  i := 0.  yOffset := 0.  [ (sub := self submorphs at: (i := i + 1)) == aMenuItem ] whileFalse: [ yOffset := yOffset + sub height ].  self position: aPoint - (2 @ (yOffset + 8)).  self right > aWorld worldBounds right ifTrue: [ self right: aPoint x + 1 ].  delta := self bounds amountToTranslateWithin: (aWorld worldBounds withHeight: (aWorld worldBounds height - 18 max: ActiveHand position y + 1)).  delta = (0 @ 0) ifFalse: [ self position: self position + delta ]resizerWidth  ^resizerWidth ifNil: [ resizerWidth := 3 ]withSiblingsDo: aBlock  | node |  node := self.  [ node isNil ] whileFalse: [ aBlock value: node.        node := node nextSibling ]enableFilterWithAction: aBlock named: aString  function := FTFilterFunctionWithAction table: self action: aBlock named: aString.  self explicitFunctionmakeLastColumnBounded  self lastColumnBounded ifFalse: [ unboundLastColumn := false.        self columnsChanged ]handlesKeyboard: evt  ^truecolumns: anArray  columns := anArraydrawOn: aCanvas  | img |  aCanvas fillRectangle: self bounds fillStyle: self fillStyle borderStyle: self borderStyle.  img := self imageToUse.  img ifNotNil: [ aCanvas translucentImage: img at: self innerBounds center - (img extent // 2) ].  ((self state == #pressed or: [ self state == #repressed ]) and: [ image isNil ]) ifTrue: [ aCanvas fillRectangle: self innerBounds fillStyle: (self paneColor alpha: 0.3) ].  (self enabled not and: [ self theme fadeCheckboxWhenDisabled ]) ifTrue: [ aCanvas fillRectangle: self innerBounds fillStyle: (self paneColor alpha: 0.4) ]scrollDownByPageDelta  self scrollDown: self pageDeltaadhereToEdge: edgeSymbol  | edgeMessage |  (owner isNil or: [ owner isHandMorph ]) ifTrue: [ ^self ].  (owner class canUnderstand: edgeSymbol) ifFalse: [ ^self ].  (self class canUnderstand: (edgeMessage := (edgeSymbol , ':') asSymbol)) ifFalse: [ ^self ].  self perform: edgeMessage withArguments: (Array with: (owner perform: edgeSymbol))layoutMenuPropertyString: aSymbol from: currentSetting  | wording |  wording := String streamContents: [:stream |  | index |        index := 1.        aSymbol keysAndValuesDo: [:idx :ch |  ch isUppercase ifTrue: [ stream nextPutAll: (aSymbol copyFrom: index to: idx - 1) asLowercase.                    stream nextPutAll: ' '.                    index := idx ] ].        index < aSymbol size ifTrue: [ stream nextPutAll: (aSymbol copyFrom: index to: aSymbol size) asLowercase ] ].  ^(aSymbol == currentSetting) -> wording translatednewIncrementalSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newIncrementalSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpTextlabelString: aString  label ifNil: [ self label: aString ] ifNotNil: [ label contents: aString.        self fitContents ]max: aNumber  endValue := aNumberminExtentOf: aMorph in: newBounds  | min extent |  cachedMinExtent ifNotNil: [ ^cachedMinExtent ].  aMorph submorphs ifEmpty: [ ^0 @ 0 ].  extent := 0 @ 0.  cachedMinExtents := aMorph submorphs collect: [:m |  min := m minExtent.        extent := extent max: min.        min ].  ^cachedMinExtent := extenthScrollBarWidth  | w |  w := bounds width - (2 * borderWidth).  self vIsScrollbarNeeded ifTrue: [ w := w - self scrollBarThickness ].  ^wmakeSecondTopmost  | aWorld |  aWorld := self world.  aWorld submorphs detect: [:m |  m isSystemWindow and: [ m ~~ self ] ] ifFound: [:nextWindow |  nextWindow activate.        aWorld addMorph: self behind: nextWindow ]currentWindow  ^self class environment at: #SystemWindow ifPresent: [:systemWindow |  systemWindow topWindow ]cellSpacing  ^#nonedate: aDate  | recompute |  recompute := date isNil or: [ date month ~= aDate month ].  date := aDate.  recompute ifTrue: [ self computeDays ]listCentering  ^listCenteringenabled: aBoolean  aBoolean ifTrue: [ self color: self defaultColor ] ifFalse: [ self color: self theme disabledTextColor ]deleteSelectedTabs  toolbar selectedTab ifNotNil: [ toolbar deleteSelectedTabs ] ifNil: [ self owner takeKeyboardFocus ]newRow: controls  ^self theme newRowIn: self for: controlsinitWithContents: aString font: aFont emphasis: emphasisCode  super initWithContents: aString font: aFont emphasis: emphasisCode.  self     disabledStyle: #plain;     enabled: truehighlightSelection  rotationDegrees  ^0.0textEntry: aStringOrText title: aString  ^self textEntry: aStringOrText title: aString entryText: ''updateChildrenRecursively  self childrenDo: [:child |  child parent: self.        child updateChildrenRecursively ]submorphsDo: aBlock  submorphs do: aBlockmenuBuilder  ^menuBuilder ifNil: [ menuBuilder := PragmaMenuBuilder pragmaKeyword: self discoveredMenuPragmaKeyword model: self ]selectedDisabledBorderStyle  ^self theme buttonSelectedDisabledBorderStyleFor: selfdisplayBounds  ^self layoutPosition extent: self cachedForm extentupdateUpButtonBounds  upButton bounds: (self theme scrollBarUpButtonBoundsFor: self)showCaret  ^showCaret ifNil: [ true ]makeLastColumnUnbounded  unboundLastColumn := trueiconButtonCalling: aSelector withForm: aForm helpText: aText  ^IconicButton new     target: self;     actionSelector: aSelector;     labelGraphic: aForm;     color: Color transparent;     extent: self boxExtent;     borderWidth: 0;     helpText: aText translated;     yourselfextendByHand: aHand  | startPoint handle |  startPoint := self position.  handle := NewHandleMorph new followHand: aHand forEachPointDo: [:newPoint |  | localPt |        localPt := (self transformFrom: self world) globalPointToLocal: newPoint.        self bounds: (startPoint rectangle: localPt) ] lastPointDo: [:newPoint |  selectedItems isEmpty ifTrue: [ self delete ] ifFalse: [ selectedItems size = 1 ifTrue: [ self delete.                    selectedItems anyOne addHalo ] ifFalse: [ self doneExtending ] ] ].  aHand attachMorph: handle.  handle startSteppinglastSubmorph  ^submorphs lastwantsToBeDroppedInto: aMorph  ^truesharesFindReplace  ^trueabort: aStringOrText  ^self abort: aStringOrText title: 'Error' translatedhandleFocusEvent: anEvent  self processEvent: anEvent.  (anEvent isMouse and: [ anEvent isMouseDown and: [ (self fullContainsPoint: anEvent position) not ] ]) ifFalse: [ ^super handleFocusEvent: anEvent ].  self eventHandler ifNotNil: [ self eventHandler mouseDown: anEvent fromMorph: self ]counter: anObject  counter := anObjectisSoleItem  ^self isFirstItem and: [ owner submorphs size = 1 ]mouseEnterDragging: evt  | aMorph |  (evt hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: evt ].  (self wantsDroppedMorph: evt hand firstSubmorph event: evt) ifTrue: [ aMorph := self scrollerSubMorphFromPoint: evt position.        aMorph ifNotNil: [ self potentialDropMorph: aMorph ].        evt hand newMouseFocus: self ]dropItemSelector  ^dropItemSelectorstartSteppingSelector: aSelector  self startStepping: aSelector at: Time millisecondClockValue arguments: nil stepTime: nilhasOwner: aMorph  aMorph ifNil: [ ^true ].  self allOwnersDo: [:m |  m = aMorph ifTrue: [ ^true ] ].  ^falsecheckForNewScreenSize  Display extent = DisplayScreen actualScreenSize ifTrue: [ ^Display ].  Display setExtent: self actualScreenSize depth: 32.  Display beDisplay.  world worldState realWindowExtent: self actualScreenSize.  world restoreMorphicDisplaytaskList  ^self submorphs detect: [:e |  e isKindOf: TaskListMorph ] ifNone: [ NullTaskList in: self ]externalName: aString  externalName := aStringselectLast  self subclassResponsibilityinitialize  super initialize.  waitingForClickInside := truecontentsAsIs: stringOrText  wrapFlag := false.  container ifNotNil: [ container fillsOwner ifTrue: [ wrapFlag := true ] ].  self newContents: stringOrTextunhighlight  complexContents highlightingColor ifNotNil: [ self color: self theme textColor ].  self changedrestoreMainDockingBarDisplay  self dockingBars do: [:each |  each updateBounds ]triggerAlarmsBefore: nowTime  | pending |  lastAlarmTime ifNil: [ lastAlarmTime := nowTime ].  (nowTime < lastAlarmTime or: [ nowTime - lastAlarmTime > 10000 ]) ifTrue: [ self adjustAlarmTimes: nowTime ].  pending := self alarms.  [ pending isEmpty not and: [ pending first scheduledTime < nowTime ] ] whileTrue: [ pending removeFirst value: nowTime ].  lastAlarmTime := nowTimematchingFilter: anItem  ((anItem children collect: [:it |  self matchingFilter: it ]) reject: #isNil) ifNotEmpty: [:coll |  ^(self newStaticItemFrom: anItem)           children: coll asArray;           dataSource: anItem dataSource;           expandWithoutChange;           yourself ].  ^(pattern matchesIn: (self dataSource toString: anItem)) ifEmpty: [ nil ] ifNotEmpty: [ self newStaticItemFrom: anItem ]startDrag: evt onItem: itemMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlerslayout: aMorph in: box  | cells arrangement horizontal newBounds |  aMorph hasSubmorphs ifFalse: [ ^self ].  properties := aMorph assureTableProperties.  newBounds := box origin asIntegerPoint corner: box corner asIntegerPoint.  (properties wrapDirection == #none and: [ properties cellSpacing == #none ]) ifTrue: [ properties listCentering == #justified ifFalse: [ properties listDirection == #leftToRight ifTrue: [ ^self layoutLeftToRight: aMorph in: newBounds ].              properties listDirection == #topToBottom ifTrue: [ ^self layoutTopToBottom: aMorph in: newBounds ] ] ].  horizontal := (properties listDirection == #topToBottom or: [ properties listDirection == #bottomToTop ]) not.  cells := self computeCellSizes: aMorph in: (0 @ 0 corner: newBounds extent) horizontal: horizontal.  arrangement := self computeCellArrangement: cells in: newBounds horizontal: horizontal target: aMorph.  self computeExtraSpacing: arrangement in: newBounds horizontal: horizontal target: aMorph.  self placeCells: arrangement in: newBounds horizontal: horizontal target: aMorphnewListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: enabledSel help: helpText  ^self theme newListIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: enabledSel help: helpTextshadowOffset  ^6 @ 8scrollBarThickness  ^self theme scrollbarThicknessdataSourceForTesting  ^FTTableMorph new     dataSource: (FTSimpleDataSource elements: self elementsForTestDataSource);     dataSourcetoggleExpandedState  | toDelete |  self isExpanded: self isExpanded not.  toDelete := OrderedCollection new.  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aNode recursiveAddTo: toDelete ] ].  container noteRemovalOfAll: toDelete.  (isExpanded and: [ complexContents hasContents ]) ifFalse: [ ^self changed ].  self expandtopFraction: aNumber offset: anInteger  topFraction := aNumber.  topOffset := anIntegerbeRadioButton  self     isRadioButton: true;     onImage: self theme radioButtonMarkerForm;     cornerStyle: (self theme radioButtonCornerStyleFor: self);     fillStyle: self fillStyleToUse;     borderStyle: self borderStyleToUseupdate: aParameter  aParameter = getEnabledSelector ifTrue: [ ^self updateEnabled ].  aParameter = getValueSelector ifTrue: [ ^self updateValue ].  aParameter = getLabelSelector ifTrue: [ ^self updateLabel ].  aParameter isArray ifFalse: [ ^self ].  aParameter size == 2 ifFalse: [ ^self ].  aParameter first = #max: ifTrue: [ self max: aParameter second ].  aParameter first = #min: ifTrue: [ self min: aParameter second ].  aParameter first = #quantum: ifTrue: [ self quantum: aParameter second ].  aParameter first = #scaledValue: ifTrue: [ self scaledValue: aParameter second ].  aParameter first = #value: ifTrue: [ self value: aParameter second ]rotationDegrees: degrees  initializeOwner: aMenuItem keyText: aString  self initialize.  owner := aMenuItem.  keyText := self class normalize: aStringhandlesKeyboard: evt  (super handlesKeyboard: evt) ifTrue: [ ^true ].  ^evt anyModifierKeyPressed and: [ evt keyCharacter = Character arrowLeft or: [ evt keyCharacter = Character arrowRight or: [ evt keyCharacter = Character delete or: [ evt keyCharacter = $w or: [ evt keyCharacter = Character tab ] ] ] ] ]addUpAction: aValuable  upAction := aValuablefallbackMenuOn: menu  menu addTitle: 'Fallback menu'.  menu commandKeyHandler: self.  menu addLine.  menu     defaultTarget: Smalltalk tools;     addList: Smalltalk tools menuItems.  menu addLine.  menu add: 'Save' target: self class selector: #saveSession.  menu add: 'Save as...' target: self class selector: #saveAs.  menu add: 'Save and quit' target: self class selector: #saveAndQuit.  menu add: 'Quit' target: self class selector: #quitSessiontarget: anObject  target := anObjectsensitiveToggleRectangle  ^(bounds left + self indentGap) @ bounds top extent: (container toggleImageWidth + container gapAfterToggle) @ bounds heightinform: evt to: aLeftMorph originatedFrom: anEvent ifNotFocusedDo: aBlock  ^(self is: anEvent withFocusOver: aLeftMorph) ifTrue: [ self transform: evt from: anEvent andSendTo: aLeftMorph ] ifFalse: aBlockvisible: aBoolean  self needsToBeDrawn ifFalse: [ ^self ].  super visible: aBooleandrawOn: aCanvas  | r |  r := self horizontal ifTrue: [ self bounds insetBy: (2 @ 1 corner: 2 @ 1) ] ifFalse: [ self bounds insetBy: (1 @ 2 corner: 1 @ 2) ].  aCanvas     drawPolygon: (self leftOrTopVertices: self bounds) fillStyle: self borderColor;     drawPolygon: (self leftOrTopVertices: r) fillStyle: self fillStyle;     drawPolygon: (self rightOrBottomVertices: self bounds) fillStyle: self borderColor;     drawPolygon: (self rightOrBottomVertices: r) fillStyle: self fillStyleresizeWidget  self subclassResponsibilityhasSeveralPages  ^self lastPage > 1embeddedWindowOrNil  ^selftestIndexFromPosition  self assert: (strategy indexFromPosition: #(3 7)) equals: 3activate  alreadyActivated ifTrue: [ ^self ].  self doActivate.  alreadyActivated := truenewEditableDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newEditableDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpTextcurrent: aNumber  bar value: aNumber.  self changedinitializeTable: tableMorph  self initialize.  self cellInset: tableMorph intercellSpacing.  self flag: #pharoTodooffImageSelector: anObject  offImageSelector := anObjectcomputeAltRaisedColors  | base light dark w colorArray param hw |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  colorArray := Array new: w * 2.  hw := 0.5 / w.  0 to: w - 1 do: [:i |  param := false ifTrue: [ 0.5 + (hw * i) ] ifFalse: [ 0.5 + (hw * (w - i)) ].        colorArray at: i + 1 put: (base mixed: param with: light).        colorArray at: colorArray size - i put: (base mixed: param with: dark) ].  ^colorArrayprepareForRotating  ^self addFlexShellstopStepping: aMorph selector: aSelector  worldState stopStepping: aMorph selector: aSelectorsortingIcon  ^self subclassResponsibilityclearTarget  target := nilavailableFillStyles  ^#(normalFillStyle mouseOverFillStyle pressedFillStyle disabledFillStyle selectedFillStyle selectedPressedFillStyle selectedMouseOverFillStyle selectedDisabledFillStyle)newButtonLabel: aString  ^self newButtonLabelFor: nil label: aString getEnabled: nilinitializeAnnouncements  self     on: #mouseEnter send: #taskbarButtonEntered:event:in: to: self model withValue: self;     on: #mouseLeave send: #taskbarButtonLeft:event:in: to: self model withValue: selflineColor: aColor  ^lineColor := aColordragItemSelector  ^dragItemSelectorrotationDegrees: degrees  freshListTab  < haltOrBreakpointForTesting>  ^(TabMorph label: 'Fresh List' icon: nil retrievingBlock: [ 1 second asDelay wait.        SpListPresenter new           items: (1 to: 50) asOrderedCollection;           buildWithSpec ] actions: {(TabAction action: [ self halt ] icon: (self iconNamed: #smallConfigurationIcon) label: 'Halt!')})     menu: [:menu |  menu add: 'Fubu' target: self selector: #halt ];     yourselfrealSearch  | result cpt |  result := OrderedCollection new.  cpt := 0.  dataSource rootsItems do: [:item |  1 to: item numberOfVisibleChildren + 1 do: [:index |  | elem |              elem := item selfOrChildAt: index.              (self isMatching: elem) ifTrue: [ result add: index + cpt ] ].        cpt := cpt + (item numberOfVisibleChildren + 1) ].  ^result asArrayforwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectioncontents  ^self childrenItems collect: [:ci |  self childNodeFromItem: ci ]mouseDown: event  dropEnabled: aBool  ^self enableDrop: aBooldrawOn: aCanvas  | canvas form1 form2 box |  super drawOn: aCanvas.  box := self bounds.  selectedItems do: [:m |  box := box merge: m fullBounds ].  box := box expandBy: 1.  canvas := Display defaultCanvasClass extent: box extent depth: 8.  canvas translateBy: box topLeft negated during: [:tempCanvas |  selectedItems do: [:m |  tempCanvas fullDrawMorph: m ] ].  form1 := (Form extent: box extent) copyBits: (0 @ 0 extent: box extent) from: canvas form at: 0 @ 0 colorMap: (Color maskingMap: 8).  form2 := Form extent: box extent.  (0 @ 0) fourNeighbors do: [:d |  form1 displayOn: form2 at: d rule: Form under ].  form1 displayOn: form2 at: 0 @ 0 rule: Form erase.  aCanvas stencil: form2 at: box topLeft sourceRect: form2 boundingBox color: self borderColormouseWheel: event  event isUp ifTrue: [ self verticalScrollBar scrollRestrictedUp: 3.        ^self ].  event isDown ifTrue: [ self verticalScrollBar scrollRestrictedDown: 3.        ^self ].  super mouseWheel: eventwithTreeLines  ^self treeLineWidth > 0fullDrawOnAthensCanvas: anAthensCanvas  self visible ifFalse: [ ^self ].  (anAthensCanvas isVisible: self fullBounds) ifFalse: [ ^self ].  (self hasProperty: #errorOnDraw) ifTrue: [ ^self ].  (anAthensCanvas isVisible: self bounds) ifTrue: [ anAthensCanvas draw: self ].  submorphs isEmpty ifTrue: [ ^self ].  self drawSubmorphsOnAthensCanvas: anAthensCanvasselectedMouseOverFillStyle  ^self theme buttonSelectedMouseOverFillStyleFor: selftestDoubleClickTimeoutFromMorph  morph eventHandler on: #doubleClickTimeout send: #value to: true.  self assert: (morph doubleClickTimeout: nil) identicalTo: trueremoveCornerGrips  | corners |  corners := self submorphsSatisfying: [:each |  each isKindOf: CornerGripMorph ].  corners do: [:each |  each delete ]chooseColor: aColor  ^self theme chooseColorIn: self title: 'Colour Selector' translated color: aColorimageRectangleFromDisplayRectangle: aRectangle  | db |  db := self displayBounds.  db area = 0 ifTrue: [ ^db ].  self layout == #scaledAspect ifTrue: [ ^((aRectangle translateBy: self layoutPosition negated) scaleBy: self form width / db width) rounded ].  self layout == #scaled ifTrue: [ ^((aRectangle translateBy: self layoutPosition negated) scaleBy: (self form width / db width) @ (self form height / db height)) rounded ].  ^self scale = 1 ifTrue: [ aRectangle translateBy: self layoutPosition negated ] ifFalse: [ ((aRectangle translateBy: self layoutPosition negated) scaleBy: 1 / self scale) rounded ]basicKeyPressed: aChar  | nextSelection oldSelection milliSeconds slowKeyStroke nextSelectionNodeMorph |  (aChar == Character space and: [ lastClickedMorph notNil ]) ifTrue: [ self selectMorph: lastClickedMorph multiple: (self isMultiple or: [ self autoMultiSelection ]).        self selectionUpdateFromViewWhile: [ | selHolder |              selHolder := self newSelectionHolderWithNodePath: lastClickedMorph complexContents path.              self listModel selection: selHolder ] ].  nextSelection := oldSelection := lastSelection.  milliSeconds := Time millisecondClockValue.  slowKeyStroke := milliSeconds - lastKeystrokeTime > 500.  lastKeystrokeTime := milliSeconds.  self searchedElement: nil.  slowKeyStroke ifTrue: [ oldSelection := oldSelection + 1.        lastKeystrokes := aChar asLowercase asString ] ifFalse: [ lastKeystrokes := lastKeystrokes , aChar asLowercase asString ].  oldSelection isZero ifFalse: [ nextSelectionNodeMorph := self allNodeMorphs detect: [:a |  a index >= oldSelection and: [ a complexContents asString trimBoth asLowercase beginsWith: lastKeystrokes ] ] ifNone: [ oldSelection := 0 ] ].  oldSelection isZero ifTrue: [ nextSelectionNodeMorph := self allNodeMorphs detect: [:a |  a complexContents asString trimBoth asLowercase beginsWith: lastKeystrokes ] ifNone: [ ^self ] ].  nextSelection := nextSelectionNodeMorph index.  self listModel okToChange ifFalse: [ ^self ].  self searchedElement: nextSelectionNodeMorph.  lastSelection := nextSelection.  self scrollToShow: nextSelectionNodeMorph contentBounds.  self selectionChangedmodalUnlockFrom: aSystemWindow  | lockStates |  lockStates := self valueOfProperty: #submorphLockStates ifAbsent: [ ^self ].  self removeProperty: #submorphLockStates.  lockStates keysAndValuesDo: [:m :locked |  locked ifFalse: [ m unlock ] ]resetDamageRecorder  damageRecorder resetvalue  ^self getValueSelector ifNil: [ (self sliderMorph ifNil: [ ^0 ]) scaledValue ] ifNotNil: [ self model ifNil: [ (self sliderMorph ifNil: [ ^0 ]) scaledValue ] ifNotNil: [ self model perform: self getValueSelector ] ]hUnadjustedScrollRange  maxWidth ifNotNil: [ ^maxWidth ].  listItems isEmpty ifTrue: [ ^0 ].  maxWidth := 0.  listItems do: [:each |  each ifNotNil: [ maxWidth := maxWidth max: (each widthToDisplayInList: self) ] ].  ^maxWidthpaddingWidth: padWidthInteger  paddingWidth := padWidthIntegerstepTime  drawTime ifNil: [ ^250 ].  ^20 * drawTime max: 250handleKeystroke: anEvent  anEvent wasHandled ifTrue: [ ^self ].  self shortcutsHandler ifNotNil: [:handler |  handler handleKeystroke: anEvent inMorph: self.        anEvent wasHandled ifTrue: [ ^self ] ].  (self handlesKeyStroke: anEvent) ifFalse: [ ^self ].  anEvent wasHandled: true.  self keyStroke: anEvent.  ^self eventHandler ifNotNil: [:handler |  handler keyStroke: anEvent fromMorph: self ]shortcutCharacter  ^shortcutCharacterinvokeWorldMenuFromEscapeKey  self invokeWorldMenu: ActiveEventdisplayWorldSafely: aWorld  [ aWorld displayWorld ] ifError: [:err :rcvr |  | errCtx errMorph |        errCtx := thisContext.        [ errCtx := errCtx sender.        [ errCtx notNil and: [ errCtx receiver isMorph not ] ] whileTrue: [ errCtx := errCtx sender ].        errCtx ifNil: [ ^self handleFatalDrawingError: err ].        errMorph := errCtx receiver.        errMorph hasProperty: #errorOnDraw ] whileTrue.        errMorph setProperty: #errorOnDraw toValue: true.        rcvr error: err ]isAdheringToTop  ^self edgeToAdhereTo == #toplistDirection  | props |  props := self layoutProperties.  ^props ifNil: [ #topToBottom ] ifNotNil: [ props listDirection ]setWindowColor  (UIManager default chooseColor: self paneColor) ifNotNil: [:nc |  self setWindowColor: nc ]enabled: aBoolean  self isEnabled: aBooleangridVisibleOnOff  self setProperty: #gridVisible toValue: self gridVisible not.  self changedupdateView: aTreeMorph forModel: aTreeModel  aTreeMorph updateFromSelection: self.  aTreeModel selectionChangedcellColumn: column row: rowIndex  column id = '#' ifTrue: [ ^FTCellMorph new addMorph: rowIndex asMorph ].  column id = 'Name' ifTrue: [ ^self nameColumn: column row: rowIndex ].  column id = 'Protocol' ifTrue: [ ^self protocolColumn: column row: rowIndex ].  column id = 'Origin' ifTrue: [ ^self originColumn: column row: rowIndex ].  self error: 'Invalid column'fillStyleToUse  ^self isRadioButton ifTrue: [ self radioFillStyleToUse ] ifFalse: [ self checkboxFillStyleToUse ]newLabelMorph: aStringOrMorph  ^TabLabelMorph new     roundedCorners: #(1 4);     cornerStyle: self cornerStyle;     changeTableLayout;     listDirection: #leftToRight;     listCentering: #center;     layoutInset: (self theme tabLabelInsetFor: self);     hResizing: #shrinkWrap;     vResizing: #spaceFill;     label: aStringOrMorph;     font: self font;     on: #mouseDown send: #tabClicked:with: to: self;     tabSelector: selfnewGroupbox  ^self theme newGroupboxIn: selfopenModal: aSystemWindow  aSystemWindow     theme: self theme;     setWindowColor: self paneColor.  ^super openModal: aSystemWindowballoonText  ^self target perform: balloonTextSelectormaxCellSize: aNumber  maxCellSize := aNumberkeyDown: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #keyDown from: sourceMorphmouseDownRow  ^self listMorph mouseDownRowselectionBorderStyle  ^self theme menuItemInDockingBarSelectedBorderStyleFor: selfdate  ^datecomputedHeightFromContents  | h |  h := 0.  self submorphsDo: [:sm |  h := h max: sm height ].  ^h max: self preferedFont height + 8font  ^fontpinColor  ^owner stayUp ifTrue: [ Color gray lighter ] ifFalse: [ Color black ]viewBox  ^worldState viewBoxroundedCorners  ^self valueOfProperty: #roundedCorners ifAbsent: [ #(1 2 3 4) ]deleteIfPopUp: evt  stayUp ifFalse: [ self topRendererOrSelf delete ].  popUpOwner notNil ifTrue: [ popUpOwner isSelected: false.        popUpOwner deleteIfPopUp: evt ].  evt ifNotNil: [ evt hand releaseMouseFocus: self ]enabled  ^enabledisMouse  ^falsechooseSmoothing  smoothing := (self scale < 1.0 or: [ self angle ~= (self angle roundTo: Float pi / 2.0) ]) ifTrue: [ 2 ] ifFalse: [ 1 ]color  ^complexContents color ifNil: [ self index ifNotNil: [ container rowColors at: self index \\ 2 + 1 ] ]nextPage  | last |  nextPageAllowed ifTrue: [ [ nextPageAllowed := false.        pageSizeEditor ifNotNil: [ pageSizeEditor acceptTextInModel ].        self changed: #pageSize.        treeMorph scroller hasSubmorphs ifTrue: [ last := treeMorph scroller lastSubmorph ].        self nextPage: (self lastIndex + pageSize min: self nodeList size).        last ifNotNil: [ | b1 b2 |              b2 := (treeMorph bounds: treeMorph innerBounds in: self world) bottom - treeMorph vExtraScrollRange.              b1 := last boundsInWorld bottom.              treeMorph scrollBy: 0 @ (b2 - b1) ].        self buildPanel ] ensure: [ nextPageAllowed := true ] ]addMorphsTo: morphList from: aCollection withExpandedItems: expandedItems atLevel: newIndent  | priorMorph firstAddition |  priorMorph := nil.  firstAddition := nil.  aCollection doWithIndex: [:item :idx |  priorMorph := self indentingItemClass new initWithContents: item prior: priorMorph forList: self indentLevel: newIndent.        firstAddition ifNil: [ firstAddition := priorMorph ].        morphList add: priorMorph.        ((item hasEquivalentIn: expandedItems) or: [ priorMorph isExpanded ]) ifTrue: [ priorMorph isExpanded: true.              priorMorph addChildrenForList: self addingTo: morphList withExpandedItems: expandedItems ] ].  ^firstAdditionhandlesKeyUp: evt  ^self handlesKeyboard: evtmessage: aStringOrText  ^self message: aStringOrText title: 'Information' translatedtext  ^keyTextquestionWithoutCancel: aStringOrText title: aString  ^self theme questionWithoutCancelIn: self text: aStringOrText title: aStringbounds: newBounds  | oldExtent newExtent |  oldExtent := self extent.  newExtent := newBounds extent.  (oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue: [ self           position: newBounds topLeft;           extent: newExtent ] ifFalse: [ self           extent: newExtent;           position: newBounds topLeft ]whenReturnInFilter: anAnnouncement  patternModel acceptEditsInViewreturnPressed  (self defaultButton ifNil: [ ^self ]) performActionselectionModeStrategy: aStrategy  selectionModeStrategy = aStrategy ifTrue: [ ^self ].  selectionModeStrategy := aStrategy.  self initializeSelectedIndexesdefaultFillStyle  ^(GradientFillStyle colors: {(self color alpha: 0) .         self color})     origin: self topLeft;     direction: (self bounds isWide ifTrue: [ self width @ 0 ] ifFalse: [ 0 @ self height ])isProportionalLayout  ^falsedoubleClickTimeout: evt  ^self eventHandler ifNotNil: [ self eventHandler doubleClickTimeout: evt fromMorph: self ]drawOn: aCanvas  state == #off ifTrue: [ offImage ifNotNil: [ aCanvas translucentImage: offImage at: bounds origin ] ].  state == #pressed ifTrue: [ pressedImage ifNotNil: [ aCanvas translucentImage: pressedImage at: bounds origin ] ].  state == #on ifTrue: [ image ifNotNil: [ aCanvas translucentImage: image at: bounds origin ] ]nodeList  ^nodeList ifNil: [ nodeList := self getList ]drawRawColorOn: aCanvas forSubmorph: aSubMorph  | c frame |  frame := (aSubMorph fullBounds withWidth: owner scroller innerBounds width) translateBy: owner scroller offset x @ 0.  aSubMorph = owner listManager searchedElement ifTrue: [ aCanvas fillRectangle: frame color: owner secondarySelectionColor.        ^self ].  owner listManager isCheckList ifTrue: [ aSubMorph = owner listManager lastClickedMorph ifTrue: [ aCanvas fillRectangle: frame color: owner selectionColorToUse.              ^self ] ] ifFalse: [ aSubMorph selected ifTrue: [ aCanvas fillRectangle: frame color: owner selectionColorToUse.              ^self ] ].  (c := aSubMorph color) notNil ifTrue: [ c isColor ifTrue: [ aCanvas frameAndFillRectangle: frame fillColor: c borderWidth: 0 borderColor: Color transparent ] ifFalse: [ c origin: aSubMorph bounds topLeft.              c direction: aSubMorph bounds width @ 0.              aCanvas fillRectangle: frame basicFillStyle: c ] ]yellowButtonActivity: shiftKeyState  self wantsYellowButtonMenu ifFalse: [ ^false ].  (self getMenu: shiftKeyState) ifNotNil: [:menu |  menu setInvokingView: self editor.        menu invokeModal.        self changed.        ^true ].  ^truesliderThickness  ^self theme scrollbarMinimumThumbThicknessselectedColor  ^selectedColor ifNil: [ self color ]autoFitString  ^(self isAutoFit ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'text auto fit' translatedhorizontalScrollBarValue: aNumber  horizontalScrollBar ifNotNil: [ self container adjustToHorizontalScrollBarValue: aNumber ]dataSource  ^dataSourceenableMouseCommands: aMouseActivationClass withContextFrom: someObjectWithCommandContext  aMouseActivationClass enableInMorph: self withCommandsFrom: someObjectWithCommandContextactiveEnabledOverDownFillStyle: aFillStyle  self stateMap atPath: #(active enabled over down) put: aFillStyle.  self changedtarget  ^targetforwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]fillsOwner  ^container notNil and: [ container fillsOwner ]newTitle: aString for: control  ^self theme newTitleIn: self label: aString for: controladdTitle  | string |  string := UIManager default request: 'Title for this menu?'.  string isEmptyOrNil ifTrue: [ ^self ].  self addTitle: stringdrawMonthHeaderOn: aCanvas  | headerWidth headerString box textBox textTopLeft monthBox monthNameWidth yearBox previousMonthBox nextMonthBox |  headerString := date asMonth printString.  headerWidth := self monthNameFont widthOfString: headerString.  box := self bounds topLeft extent: self bounds width @ 23.  textTopLeft := self bounds topCenter translateBy: (headerWidth // -2) @ 5.  textBox := textTopLeft extent: headerWidth @ self monthNameFont height.  monthNameWidth := self monthNameFont widthOfString: self date monthName , ' '.  monthBox := textBox topLeft extent: monthNameWidth @ textBox height.  yearBox := monthBox topRight corner: textBox bottomRight.  previousMonthBox := (self bounds topLeft translateBy: 10 @ 5) extent: 10 @ self monthNameFont height.  nextMonthBox := (self bounds topRight translateBy: -20 @ 5) extent: 10 @ self monthNameFont height.  touchPoints     at: monthBox put: #handleMonthNameTouched;     at: yearBox put: #handleYearTouched;     at: (previousMonthBox expandBy: 10 @ 5) put: #handlePreviousMonthTouched;     at: (nextMonthBox expandBy: 10 @ 5) put: #handleNextMonthTouched.  aCanvas     frameAndFillRectangle: box fillColor: Color veryLightGray borderWidth: 1 borderColor: Color black;     line: box bottomLeft to: box bottomRight width: 2 color: Color black;     drawString: '<' at: previousMonthBox origin font: self monthNameFont color: Color black;     drawString: '>' at: nextMonthBox origin font: self monthNameFont color: Color black;     drawString: headerString at: (self bounds topCenter translateBy: (headerWidth // -2) @ 5) font: self monthNameFont color: Color blackreferencePosition  ^referencePositioncopyTitle  Clipboard clipboardText: self label.  self inform: 'Window title copied.'listItemHeight  ^12textUpdated: anAnnouncement  newOKButtonFor: aModel getEnabled: enabledSel  ^self theme newOKButtonIn: self for: aModel getEnabled: enabledSelindentGap: anInteger  indentGap := anIntegerbuttonMorph: aMorph  buttonMorph ifNotNil: [ self removeDependent: buttonMorph.        buttonMorph delete ].  buttonMorph := aMorph.  self     addDependent: aMorph;     addMorphFront: aMorphchoose: aString  | item |  item := self itemWithWording: aString.  item ifNil: [ self error: 'Menu does not have "' , aString , '" item' ].  item simulateClicksubmorphBounds  self hasSubmorphs ifFalse: [ ^nil ].  ^self firstSubmorph topLeft corner: owner scroller bounds bottomLeft + (0 @ owner extraScrollRange)fillStyle  ^self isOpen ifTrue: [ self borderColor ] ifFalse: [ super fillStyle ]minEnabled  ^self enabled and: [ self notAtMin ]defaultFillStyle  ^(GradientFillStyle colors: ((0.0 to: 359.9 by: 0.1) collect: [:a |  Color h: a s: 1.0 v: 1.0 ]))     origin: self topLeft;     direction: (self bounds isWide ifTrue: [ self width @ 0 ] ifFalse: [ 0 @ self height ])color: aColor  aColor ifNil: [ ^self ].  (aColor = self color and: [ self getModelState = self lastState ]) ifTrue: [ ^self ].  super color: aColorenabled  ^enabled ifNil: [ enabled := true ]sortableUsing: aSortFunction  self sortingStrategy: (FTSortFunctionColumnSortingStrategy column: self sortFunction: aSortFunction)resizeScrollBars  self     vResizeScrollBar;     hResizeScrollBargetListElementSelector: aSymbol  self basicGetListElementSelector: aSymbol.  list := nil.  self updateListmenu: menu shifted: b  menu add: 'Browse (b)' target: self selector: #browseItem.  menu add: 'Inspect (i)' target: self selector: #inspectItem.  menu add: 'Explore (I)' target: self selector: #exploreItemthemeChanged  (self theme desktopImageFor: self) ifNotNil: [:aForm |  self color: Color white.        self backgroundImage: aForm layout: self theme desktopImageLayout ].  super themeChangedasDraggableMorph  ^selfaddMorphInLayer: aMorph  submorphs do: [:each |  each == aMorph ifTrue: [ ^self ].        aMorph morphicLayerNumber < each morphicLayerNumber ifTrue: [ ^self addMorph: aMorph inFrontOf: each ] ].  self addMorphBack: aMorphprintOn: aStream  super printOn: aStream.  submorphs isEmpty ifTrue: [ aStream nextPutAll: ' with no transformee!' ] ifFalse: [ aStream nextPutAll: ' on ' , submorphs first printString ]selectionFrameForRow: row  | frame |  frame := self drawBoundsForRow: row.  frame := frame expandBy: self cellInset // 2.  self cellInset odd ifTrue: [ frame := frame bottom: frame bottom + 1 ].  frame := frame intersect: self bounds ifNone: [ self error: 'should not happen' ].  frame := self bounds: frame in: listSource.  frame := self bounds: ((frame left: listSource innerBounds left) right: listSource innerBounds right) from: listSource.  ^frameinitializeContainer: aTableContainerMorph left: aColumn right: otherColumn  self initialize.  self width: self class resizerWidth.  container := aTableContainerMorph.  leftColumn := aColumn.  rightColumn := otherColumninitializeScrollBars  verticalScrollBar := ScrollBar new     model: self;     setValueSelector: #verticalScrollBarValue:;     yourself.  self addMorph: verticalScrollBar.  horizontalScrollBar ifNotNil: [ horizontalScrollBar := ScrollBar new           model: self;           setValueSelector: #horizontalScrollBarValue:;           yourself.        self addMorph: horizontalScrollBar ]borders: anObject  borders := anObjectdrawOnAthensCanvas: anAthensCanvas  | r |  r := self horizontal ifTrue: [ self bounds insetBy: (2 @ 1 corner: 2 @ 1) ] ifFalse: [ self bounds insetBy: (1 @ 2 corner: 1 @ 2) ].  anAthensCanvas setPaint: self borderColor.  anAthensCanvas drawShape: (self createClosedPolygonPathFrom: (self leftOrTopVertices: self bounds) on: anAthensCanvas).  anAthensCanvas setPaint: self fillStyle.  anAthensCanvas drawShape: (self createClosedPolygonPathFrom: (self leftOrTopVertices: r) on: anAthensCanvas).  anAthensCanvas setPaint: self borderColor.  anAthensCanvas drawShape: (self createClosedPolygonPathFrom: (self rightOrBottomVertices: self bounds) on: anAthensCanvas).  anAthensCanvas setPaint: self fillStyle.  anAthensCanvas drawShape: (self createClosedPolygonPathFrom: (self rightOrBottomVertices: r) on: anAthensCanvas)keyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self focusChangedtestSelectFirst  table selectFirst.  self assert: table selectedIndexes equals: #(#(1 1))testSelectableIndexAfter  self should: [ strategy selectableIndexAfter: 2 ] raise: ErroroutOfWorldCount  ^outOfWorldCountallowsKeymapping: aBoolean  ^self setProperty: #allowsKeymapping toValue: aBooleanrotationCenter  | refPos |  refPos := self referencePosition.  ^(refPos - self bounds origin) / self bounds extent asFloatPointbuttonFor: item  ^((self canDisplayChildrenOf: item) and: [ item children isNotEmpty ]) ifTrue: [ item generateButton ] ifFalse: [ self class emptyMorph ]isWorldMorph  ^falsepaneMorphs  ^paneMorphslistOfSteppingMorphs  ^stepList collect: [:entry |  entry receiver ]doOneCycleNowFor: aWorld  self worldRenderer checkForNewScreenSize.  LastCycleTime := Time millisecondClockValue.  self handsDo: [:h |  self activeHand: h.        h processEvents.        self activeHand: nil ].  self activeHand: self hands first.  aWorld runStepMethods.  self displayWorldSafely: aWorldinitialize  super initialize.  self resetcomplexDataSourceForTesting  ^FTTableMorph new     dataSource: (FTSimpleDataSource elements: self complexElementsForTestDataSource);     dataSourcecursorPoint  ^positioncolors  ^colors ifNil: [ colors := self computeColors ]athensDrawBackgroundForSearchedRow: row on: aCanvas  aCanvas setPaint: listSource secondarySelectionColor.  aCanvas drawShape: (self selectionFrameForRow: row)doubleClickOnSelectedText: event  self deselectlastSelection  ^lastSelectionhelpText  ^self balloonTextenabled: aBoolean  (state isEnabledMatchingTheState: aBoolean) ifTrue: [ ^self ].  state := state newStateForEnabled: aBoolean.  label enabled: aBoolean.  self changedon: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel  self model: anObject.  getListSelector := getListSel.  getSelectionSelector := getSelectionSel.  setSelectionSelector := setSelectionSel.  getMenuSelector := getMenuSel.  keystrokeActionSelector := keyActionSel.  autoDeselect := true.  self borderWidth: 1.  self list: self getListbasicKeyPressed: aChar  ^selfdrawOnAthensCanvas: anAthensCanvas  | bnd |  bnd := self bounds topLeft + self layoutInset.  anAthensCanvas pathTransform restoreAfter: [ anAthensCanvas pathTransform translateBy: bnd.        self drawBackgroundOnAthensCanvas: anAthensCanvas.        self drawIconAndLabelOnAthensCanvas: anAthensCanvas.        self drawSubMenuMarkerOnAthensCanvas: anAthensCanvas ]unsortElements  self rootItem children: unsortedElements.  unsortedElements := nilshouldDropOnMouseUp  ^trueattachKeymapCategory: aCategoryName targetting: anObject  self kmDispatcher attachCategory: aCategoryName targetting: anObjectcreateBox  | box |  box := IconicButton new.  box     color: Color transparent;     target: self;     useSquareCorners;     borderWidth: 0.  ^boxcanvas  ^nilchangeInSlopes: slopes of: verts  | n slopeChanges |  n := verts size.  n = slopes size ifFalse: [ ^self error: 'vertices and slopes differ in number' ].  slopeChanges := Array new: n.  1 to: n do: [:i |  slopeChanges at: i put: ((verts atWrap: i + 1) - (verts at: i)) * 3 - ((slopes at: i) * 2) - (slopes atWrap: i + 1) ].  ^slopeChangescentered  textStyle centeredautoSize  ^autoSizethemeChanged  scrollBar theme: self theme.  hScrollBar theme: self theme.  super themeChangedextent: aPoint  super extent: aPoint.  worldState viewBox ifNotNil: [ worldState canvas: nil ]handlesMouseDown: anEvent  ^truewantsKeyboardFocusFor: aSubmorph  ^trueduplicateMorph: evt  | dup menu |  dup := self duplicate isSelected: false.  menu := UIManager default newMenuIn: self for: nil.  menu addMorphFront: dup.  menu bounds: self bounds.  menu stayUp: true.  evt hand grabMorph: menu from: owner.  ^menucalculateColumnWidths  | undefinedColumnWidths widths remainingWidth |  remainingWidth := self table bounds width.  widths := Array new: self table numberOfColumns withAll: 0.  self columnOrderOfWidthDistribution do: [:idx |  | column columnWidth |        column := self table columns at: idx.        columnWidth := column acquireWidth: remainingWidth.        widths at: idx put: columnWidth.        remainingWidth := remainingWidth - columnWidth ].  undefinedColumnWidths := widths count: #isZero.  undefinedColumnWidths isZero ifTrue: [ widths size > 1 ifTrue: [ widths at: widths size put: widths last + remainingWidth ].        ^widths ].  self columnOrderOfWidthDistribution do: [:idx |  (widths at: idx) = 0 ifTrue: [ widths at: idx put: remainingWidth / undefinedColumnWidths ] ].  ^widthsdrawOnAthensCanvas: anAthensCanvas  | paint |  paint := offImage.  state == #pressed ifTrue: [ paint := pressedImage ].  state == #on ifTrue: [ paint := image ].  paint ifNil: [ ^self ].  anAthensCanvas setPaint: paint.  anAthensCanvas paintTransform restoreAfter: [ anAthensCanvas paintTransform translateBy: self innerBounds origin.        anAthensCanvas drawShape: self innerBounds ]forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]removeHand: aHandMorph  (hands includes: aHandMorph) ifFalse: [ ^self ].  hands := hands copyWithout: aHandMorph.  activeHand == aHandMorph ifTrue: [ activeHand := nil ].  ActiveHand == aHandMorph ifTrue: [ ActiveHand := nil ]updateFromParagraph  super updateFromParagraph.  editView setScrollDeltaskeyStroke: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #keyStroke from: sourceMorphselectAll  self subclassResponsibilitymouseEnter: evt  self setProperty: #mouseEntered toValue: true.  self changed.  self color: (self color adjustBrightness: -0.09375).  super mouseEnter: evtgenerateButton  ^isExpanded ifTrue: [ self expandedButton ] ifFalse: [ self collpasedButton ]selectedObject  ^self primaryHand selectedObjectstylingEnabled: aBoolean  updateList  | items |  items := self selectedItems.  self requestView: MorphTreeChangeRequest updateList.  self selectItems: itemsleeway  ^0.1initialize  super initialize.  patternModel := RubScrolledTextModel new.  patternModel announcer when: RubTextUpdatedInModel send: #whenPatternChanged: to: self.  autoAccept := true.  ghostString := ''updatePosition  self owner ifNotNil: [:anOwner |  | edgeSymbol margin usedHeight |        edgeSymbol := self edgeToAdhereTo.        edgeSymbol == #none ifTrue: [ self perform: (edgeSymbol , ':') asSymbol with: (anOwner perform: edgeSymbol) ].        margin := (self avoidVisibleBordersAtEdge ifTrue: [ self borderWidth ] ifFalse: [ 0 ]) asPoint.        self isAdheringToTop ifTrue: [ usedHeight := self usedHeightByPredominantDockingBarsOfChastes: #(#top).              self topLeft: anOwner topLeft - margin + (0 @ usedHeight) ].        self isAdheringToBottom ifTrue: [ usedHeight := self usedHeightByPredominantDockingBarsOfChastes: #(#bottom).              self bottomLeft: anOwner bottomLeft + (-1 @ 1 * margin) - (0 @ usedHeight) ].        self isAdheringToLeft ifTrue: [ | usedWidth |              usedHeight := self usedHeightByPredominantDockingBarsOfChastes: #(#top).              usedWidth := self usedWidthByPredominantDockingBarsOfChastes: #(#left).              self topLeft: anOwner topLeft - margin + (usedWidth @ usedHeight) ].        self isAdheringToRight ifTrue: [ | usedWidth |              usedHeight := self usedHeightByPredominantDockingBarsOfChastes: #(#top).              usedWidth := self usedWidthByPredominantDockingBarsOfChastes: #(#right).              self topRight: anOwner topRight + (1 @ -1 * margin) + (usedWidth negated @ usedHeight) ] ]click  (self handlesMouseDown: nil) ifTrue: [ self mouseDown: nil.        self mouseUp: nil ]aboutToBeGrabbedBy: aHand  super aboutToBeGrabbedBy: aHand.  self draggedMorph.  self formerPosition: self position.  aHand newKeyboardFocus: selfdoDup: evt fromHalo: halo handle: dupHandle  selectedItems := selectedItems collect: #duplicate.  selectedItems do: [:m |  self owner addMorph: m ].  dupDelta ifNil: [ dupLoc := self position.        evt hand grabMorph: self.        halo removeAllHandlesBut: dupHandle ] ifNotNil: [ dupLoc := nil.        self position: self position + dupDelta ]actWhen: condition  actWhen := conditionnewToolDockingBar  ^self theme newToolDockingBarIn: selfinitialize  super initialize.  self changeProportionalLayout.  self tabGroup: self newTabGroup.  self tabGroup tabSelectorMorph addDependent: self.  self     dropEnabled: true;     addMorph: self tabGroup fullFrame: LayoutFrame identity.  self tabGroup color: Color transparentborderStyle: newStyle  | newExtent |  self borderStyle = newStyle ifTrue: [ ^self ].  newExtent := 2 * newStyle width + image extent.  bounds extent = newExtent ifFalse: [ super extent: newExtent ].  super borderStyle: newStylewantsHaloFor: aSubMorph  ^falsepopUpFor: aMorph hand: aHand  balloonOwner := aMorph.  self popUpForHand: aHandvSpaceFill  ^self flags anyMask: 2result: result  ^self result: result from: nilmouseDown: evt  super mouseDown: evt.  self currentWindow ifNotNil: [:topWindow |  SystemWindow passivateTopWindow ]useFunction: aFilterFunctionClass do: aBlock  function := aFilterFunctionClass table: self.  aBlock cull: function cull: selfpressedThumbBorderStyle  ^self theme scrollbarPressedThumbBorderStyleFor: selfaddLeftOrTop: aMorph  leftOrTop add: aMorphdrawKeyboardFocusOn: aCanvas  self focusIndicatorMorph drawOn: aCanvascollapseRequest: anAnnounce  anAnnounce nodes ifEmpty: [ ^self collapseAll ] ifNotEmpty: [:nodes |  self collapseNodePath: nodes ]newNoButtonFor: aModel  ^self theme newNoButtonIn: self for: aModelterminateFilterProcess  isEditingSemaphore ifNotNil: [ isEditingSemaphore terminateProcess ]initialize  super initialize.  self borderWidth: 3.  self extent: self extent + 2.  onColor := Color r: 1.0 g: 0.6 b: 0.6.  offColor := Color lightGray.  color := offColorroundedCorners: anArray  super roundedCorners: anArray.  self layoutInset: (self theme buttonLabelInsetFor: self)selectedRowIndex  self deprecated: 'Use #selectedIndex instead' transformWith: '`@receiver selectedRowIndex' -> '`@receiver selectedIndex'.  ^self selectedIndexdata: anObject  data := anObjectisExpanded: aBoolean  isExpanded := aBooleanexecuteSortingOn: aDataSource  aDataSource unsortdecrement  bar decrementfont  ^StandardFonts defaultFontgridSpec  ^self valueOfProperty: #gridSpec ifAbsent: [ 0 @ 0 extent: 8 @ 8 ]isDefault  ^truenewAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletion  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel font: aFont help: helpText entryCompletion: anEntryCompletionkeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self focusChangedcheckGap  ^2drawOn: aCanvas  self getListSize = 0 ifTrue: [ ^self ].  self setColumnWidthsFor: aCanvas.  self adjustWidth.  super drawOn: aCanvaswindow  ^selffocused: aBoolean  focused := aBooleanprintNode: node  getLabelSelector ifNil: [ ^node item printString ].  ^model perform: getLabelSelector with: node itemfixupLastLineIfCR  (theText size > 0 and: [ CharacterSet crlf includes: theText last ]) ifFalse: [ ^self ].  self addNullLineForIndex: theText size + 1resetBlinkCursor  | para |  self blinkStart: Time millisecondClockValue + 500.  para := self paragraph ifNil: [ ^self ].  para showCaret = para focused ifFalse: [ para caretRect ifNotNil: [:r |  self invalidRect: r ].        para showCaret: para focused ]setExpandBoxBalloonText  expandBox ifNil: [ ^self ].  self unexpandedFrame ifNil: [ expandBox setBalloonText: 'Expand to full screen' translated ] ifNotNil: [ expandBox setBalloonText: 'Contract to original size' translated ]listForSearching  ^super listForSearching collect: #firstwantsHaloFromClick  ^falsemouseLeaveDragging: evt  (self isTopWindow not and: [ evt hand hasSubmorphs ]) ifTrue: [ self lockInactivePortions.        evt hand removeMouseListener: self ]textColor: anObject  textColor := anObjectisRootItem  ^self depth = 0setValue: newValue  newValue >= 1.0 ifTrue: [ ^super setValue: 1.0 ].  ^super setValue: (newValue roundTo: scrollDelta)initializeMethod: aMethod  self initialize.  method := aMethodextent: newExtent  self extent = newExtent ifTrue: [ ^self ].  super extent: newExtent.  self updatePagerdispatchKeystrokeForEvent: evt  self kmDispatcher dispatchKeystroke: evtinvokeMetaMenu: evt  | menu |  self world ifNil: [ ^self ].  menu := self buildMetaMenu: evt.  self addTitleForHaloMenu: menu.  menu popUpEvent: evt in: self worldstartDrag: anEvent  | aTransferMorph itemMorph passenger |  self dragEnabled ifTrue: [ itemMorph := scroller submorphs detect: [:any |  any highlightedForMouseDown ] ifNone: [  ] ].  (itemMorph isNil or: [ anEvent hand hasSubmorphs ]) ifTrue: [ ^self ].  itemMorph highlightForMouseDown: false.  itemMorph ~= self selectedMorph ifTrue: [ self setSelectedMorph: itemMorph ].  passenger := self model dragPassengerFor: itemMorph inMorph: self.  passenger ifNotNil: [ aTransferMorph := self model transferFor: passenger from: self.        aTransferMorph align: aTransferMorph draggedMorph center with: anEvent position.        aTransferMorph dragTransferType: (self model dragTransferTypeForMorph: self).        anEvent hand grabMorph: aTransferMorph ].  anEvent hand releaseMouseFocus: selfsiblingSplitters  ^self owner submorphsSatisfying: [:each |  (each isKindOf: self class) and: [ self splitsTopAndBottom = each splitsTopAndBottom and: [ each ~= self ] ] ]multipleSelection  ^multipleSelection ifNil: [ multipleSelection := false ]testBoundingBoxOfSubmorphs  | subMorph |  subMorph := morph copy     topLeft: morph topLeft + 5;     yourself.  morph addMorph: subMorph.  self assert: morph boundingBoxOfSubmorphs equals: subMorph boundsnewStack: controls  ^self theme newStackIn: self for: controlsprivateMoveBy: delta  super privateMoveBy: delta.  editor ifNil: [ paragraph ifNotNil: [ paragraph moveBy: delta ] ] ifNotNil: [ paragraph moveBy: delta.        self installEditorToReplace: editor ]resetHighlightForDrop  self highlightForDrop: falsenewMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: nil useIndex: true help: helpTextdefaultFontFamiliyName  ^'Source Sans Pro'drawOnAthensCanvas: aCanvas  super drawOnAthensCanvas: aCanvas.  backgroundMorph ifNotNil: [ aCanvas clipBy: self clippingBounds during: [ aCanvas fullDrawMorph: backgroundMorph ] ]cornerStyle: aSymbol  super cornerStyle: aSymbol.  self tabSelectorMorph cornerStyle: aSymbol.  self contentMorph cornerStyle: aSymboltestOpenInWorld  morph openInWorldadhereToBottom  self adhereTo: #bottomselector  ^selectorsetOptimalResizing  self hResizing: #rigid.  self vResizing: #rigidtestDisableSort  column disableSort.  self deny: column isSortEnabledwhenPatternChanged: anAnnouncement  self updateListheader: aMorph  header := aMorph     clipSubmorphs: true;     yourself.  header model: selfinitialize  super initialize.  self initForEvents.  bounds := 0 @ 0 extent: Cursor normal extent.  damageRecorder := DamageRecorder new.  cachedCanvasHasHoles := false.  self initForEventsnewOKButtonFor: aModel  ^self newOKButtonFor: aModel getEnabled: nilobjectToView: objectOrNil viewSelector: aSelector  self objectToView: objectOrNil.  viewSelector := aSelectorselectedFillStyle  ^self theme controlButtonSelectedFillStyleFor: selfgetIndexSelector  ^getIndexSelectorcopySelectionToClipboard  self selection ifNotNil: [ Clipboard clipboardText: self selection asString ] ifNil: [ self flash ]acceptDroppingMorph: aMorph event: evt  self model container swapColumn: self model withColumn: aMorph passenger.  evt hand releaseMouseFocus: self.  self noMorePotentialDropTarget.  self model container changed.  Cursor normal showdeleteBalloon  | w |  w := self world ifNil: [ ^self ].  w deleteBalloonTarget: selfnumberOfInstanceVariablesColumn: column row: rowIndex  ^FTCellMorph new     addMorph: (self elementAt: rowIndex) instSize asStringMorph;     yourselfkeyStroke: anEvent from: aTreeMorph  self selectedNode ifNotNil: [:current |  current keyStroke: anEvent from: aTreeMorph ]detachKeymapCategory: aCategoryName  self kmDispatcher detachKeymapCategory: aCategoryNameselectFirst  self subclassResponsibilitycontainer  ^containerupdateLayoutInDockingBar  owner isVertical ifFalse: [ self hResizing: #shrinkWrap.        self vResizing: #spaceFill ] ifTrue: [ self hResizing: #spaceFill.        self vResizing: #shrinkWrap ].  self extent: self minWidth @ self minHeightdrawOnAthensCanvas: anAthensCanvas  | border |  border := self borderStyle.  anAthensCanvas setPaint: self fillStyle.  anAthensCanvas drawShape: self bounds.  anAthensCanvas drawShape: (self bounds insetBy: border width).  anAthensCanvas setStrokePaint: border.  anAthensCanvas drawShape: (self bounds insetBy: border width / 2 asFloat)handleKeyUp: anEvent  ^self dispatchDefault: anEvent with: morphpositionShortcut: aMorph  | area |  area := self currentWorld clearArea insetBy: 3.  aMorph     cellPositioning: position;     fullBounds.  aMorph perform: (position , ':') asSymbol with: (position value: area)useSelectionBar  ^TextEditor useSelectionBarbuildTitle: aBlock  titleMorph ifNil: [ self createTitleMorph ].  aBlock value: titleMorphgetListSizeSelector: anObject  getListSizeSelector := anObjectcalculateVisibleTabs  | widths answer availableWidth accumulatedWidth tabStr widthStr width |  widths := self tabs collect: [:t |  t minExtent x ].  availableWidth := self layoutBounds width.  self cornerStyle = #rounded ifTrue: [ availableWidth := availableWidth - 6 ].  widths sum <= availableWidth ifTrue: [ ^self tabs ].  availableWidth := availableWidth - self controlsExtent x.  answer := OrderedCollection new.  accumulatedWidth := 0.  self visibleTabRange last = 0 ifTrue: [ tabStr := (self tabs copyFrom: self visibleTabRange first to: self tabs size) readStream.        widthStr := (widths copyFrom: self visibleTabRange first to: widths size) readStream.        [ accumulatedWidth <= availableWidth and: [ tabStr atEnd not ] ] whileTrue: [ answer add: tabStr next.              accumulatedWidth := accumulatedWidth + widthStr next ].        accumulatedWidth > availableWidth ifTrue: [ answer removeLast ].        ^answer ] ifFalse: [ tabStr := (self tabs copyFrom: 1 to: self visibleTabRange last) reversed readStream.        widthStr := (widths copyFrom: 1 to: self visibleTabRange last) reversed readStream.        [ accumulatedWidth <= availableWidth and: [ tabStr atEnd not ] ] whileTrue: [ answer addFirst: tabStr next.              accumulatedWidth := accumulatedWidth + (width := widthStr next) ].        accumulatedWidth > availableWidth ifTrue: [ answer removeFirst.              accumulatedWidth := accumulatedWidth - width ].        tabStr := (self tabs copyFrom: self visibleTabRange last + 1 to: self tabs size) readStream.        widthStr := (widths copyFrom: self visibleTabRange last + 1 to: widths size) readStream.        [ accumulatedWidth <= availableWidth and: [ tabStr atEnd not ] ] whileTrue: [ answer add: tabStr next.              accumulatedWidth := accumulatedWidth + widthStr next ].        accumulatedWidth > availableWidth ifTrue: [ answer removeLast ].        ^answer ]addSpacer  self addMorphBack: (AlignmentMorph newSpacer: Color transparent)isEasySelecting  ^self class easySelectingWorldbackgroundColor: newColor  backgroundColor := newColor.  self changednoHelpString  ^'Help not yet supplied' translatedrestoreDisplay  self currentWorld restoreMorphicDisplayhandleMouseWheel: anEvent  anEvent wasHandled ifTrue: [ ^self ].  (self handlesMouseWheel: anEvent) ifTrue: [ anEvent wasHandled: true.        self mouseWheel: anEvent ]newMultistateButton  ^self theme newMultistateButtonIn: selfselectedTab  ^self selectedIndex = 0 ifFalse: [ self tabs at: self selectedIndex ifAbsent: [ nil ] ]newCloseButton  ^self newCloseButtonFor: selfgetEnabledSelector: aSymbol  getEnabledSelector := aSymbol.  self update: aSymbolisResizeable: aBoolean  aBoolean = isResizeable ifTrue: [ ^self ].  aBoolean ifTrue: [ self beResizeable ] ifFalse: [ self beUnresizeable ]selectIndex: index event: event  event shiftPressed ifTrue: [ ^self selectIndexesUpTo: index ].  OSPlatform current isMacOS ifTrue: [ event commandKeyPressed ifTrue: [ ^self selectAppendingIndex: index ] ] ifFalse: [ event controlKeyPressed ifTrue: [ ^self selectAppendingIndex: index ] ].  self toggleIndex: indexoriginalObject: anObject  originalObject := anObjectdefaultBackgroundColor  ^self theme windowColorFor: selfcontentMorph: anObject  contentMorph := anObjectisSticky  submorphs isEmpty ifFalse: [ ^submorphs first isSticky ].  ^falseselectedNodeList  ^self selectedNodePathList ifNil: [ #() ] ifNotNil: [:l |  l collect: [:path |  path last ] ]brightness: anInteger  | c |  c := self selectedColor.  self selectedColor: ((Color h: c hue s: c saturation v: anInteger / 255) alpha: c alpha)isExpanded  ^falseaddMenuControl  labelArea ifNil: [ ^self ].  menuBox ifNotNil: [ menuBox delete ].  labelArea addMorphBack: (menuBox := self createMenuBox)enabled  ^falseaddItem  | string sel |  string := UIManager default request: 'Label for new item?'.  string isEmpty ifTrue: [ ^self ].  sel := UIManager default request: 'Selector?'.  sel isEmpty ifFalse: [ sel := sel asSymbol ].  self add: string selector: selstepListSize  ^worldState stepListSizeacceptTextMorphs  self allMorphs do: [:p |  ((p respondsTo: #accept) and: [ (p respondsTo: #hasUnacceptedEdits) and: [ p hasUnacceptedEdits ] ]) ifTrue: [ p accept ] ]bars  ^self submorphschanged  | lc pc bs |  self assureExtension.  extension borderStyle: (bs := self borderStyleToUse).  borderColor := bs style.  borderWidth := bs width.  extension fillStyle: self fillStyleToUse.  self layoutInset: (self theme buttonLabelInsetFor: self).  self privateColor: self fillStyle asColor.  (self labelMorph respondsTo: #interactionState:) ifTrue: [ self labelMorph interactionState: self interactionState ] ifFalse: [ (self labelMorph isNil or: [ label isMorph ]) ifFalse: [ pc := self normalColor.              lc := self enabled ifTrue: [ pc contrastingBlackAndWhiteColor ] ifFalse: [ pc contrastingBlackAndWhiteColor muchDarker ].              self labelMorph color: lc ] ].  super changedputSelector  ^nilsortFunction: aString  sortFunction := aStringlastKeystrokeTime: anObject  lastKeystrokeTime := anObjectmouseWheel: event  (self scrollTarget handlesMouseWheel: event) ifTrue: [ ^self scrollTarget mouseWheel: event ].  event isUp ifTrue: [ ^vScrollbar scrollUp: 3 ].  event isDown ifTrue: [ ^vScrollbar scrollDown: 3 ].  event isLeft ifTrue: [ ^hScrollbar scrollLeft: 3 ].  event isRight ifTrue: [ ^hScrollbar scrollRight: 3 ]forEachPointDo: aBlock  pointBlock := aBlockbounds: aRectangle  bounds := aRectangleupdateColumnMorphs  self privateUpdateColumnMorphsrecordInvalidRect: newRect  | mergeRect zeroRect |  totalRepaint ifTrue: [ ^self ].  zeroRect := 0 @ 0 corner: 0 @ 0.  invalidRects do: [:rect |  | a |        ((a := (rect intersect: newRect ifNone: [ zeroRect ]) area) > 40 and: [ a > (newRect area // 4) or: [ a > (rect area // 4) ] ]) ifTrue: [ rect setPoint: (rect origin min: newRect origin) truncated point: (rect corner max: newRect corner) truncated.              ^self ] ].  invalidRects size >= 50 ifTrue: [ mergeRect := Rectangle merging: invalidRects.        self reset.        invalidRects addLast: mergeRect ].  newRect hasPositiveExtent ifTrue: [ invalidRects addLast: (newRect topLeft truncated corner: newRect bottomRight truncated) ]contents  ^model contentsOfNode: selfheight: aNumber  self extent: self width @ aNumber asIntegertopLeft  ^textMorph owner topLeftnewGroupbox: aString forAll: controls  ^self theme newGroupboxIn: self label: aString forAll: controlschunkSize: anIntegerOrNil  self setPageSize: anIntegerOrNil.  self announce: (MorphTreeChangeRequest chunkSize: anIntegerOrNil)proceed: aStringOrText title: aString  ^self theme proceedIn: self text: aStringOrText title: aStringmouseEnterDragging: event  self enabled ifFalse: [ ^self ].  (event hand hasSubmorphs and: [ self dropEnabled ]) ifFalse: [ ^super mouseEnterDragging: event ]newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel help: helpText  ^self newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: nil useIndex: true help: helpTextnewTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpTexttheMethodInProdThatShouldBeTested  ^TaskbarMorph >> #updateOrderedTasksFrom:selectedBorderStyle  ^self theme taskbarItemSelectedBorderStyleFor: selfresizeVerticalScrollBar  | width height corner |  width := self scrollBarThickness.  height := self bounds height - (self borderWidth * 2) - self horizontalScrollBarHeight.  corner := self bounds topRight - ((width + self borderWidth) @ (0 - self borderWidth)).  self verticalScrollBar bounds: (corner extent: width @ height)newEmbeddedMenu  ^self theme newEmbeddedMenuIn: self for: selfcolumns: aCollection  columns := aCollection asArraystep: anObject  step := anObjectleftBoundary  | morphs |  morphs := leftOrTop reject: [:m |  m layoutFrame leftFraction ~= 0 and: [ m layoutFrame leftFraction = m layoutFrame rightFraction ] ].  morphs ifEmpty: [ ^(self splitterLeft ifNil: [ self containingWindow panelRect left ] ifNotNil: [:s |  s left ]) + 25 ].  ^(morphs collect: [:m |  m left + m minExtent x + (self layoutFrame leftOffset ifNil: [ 0 ]) - (m layoutFrame rightOffset ifNil: [ 0 ]) ]) maxsendMouseEvent: anEvent  ^self sendEvent: anEvent focus: self mouseFocus clear: [ self mouseFocus: nil ]storeOn: aStream  super storeOn: aStream.  aStream space.  whichButton storeOn: aStreamdrawOn: aCanvas  super drawOn: aCanvas.  aCanvas drawString: self label in: self labelBounds font: self font color: self fontColorhandlesMouseMove: evt  ^self existsSubscriptionsFor: #mouseMovemouseDown: evt  super mouseDown: evt.  (actWhen == #buttonDown and: [ evt hand mouseFocus ~= self ]) ifTrue: [ self mouseLeave: evt ]handlerForMouseDown: anEvent  ^(self hasProperty: #submorphLockStates) ifFalse: [ super handlerForMouseDown: anEvent ]couldHaveRoundedCorners  ^truecollapseAll  rootItem collapseAll.  self tableRefreshtransformedFrom: uberMorph  owner ifNil: [ ^IdentityTransform basicNew ].  ^owner transformFrom: uberMorphmenuBarItems: anObject  menuBarItems := anObjectinitialize  super initialize.  self borderInitializehighlightedRowIndex  self deprecated: 'Use #highlightedIndex instead' transformWith: '`@receiver highlightedRowIndex' -> '`@receiver highlightedIndex'.  ^self highlightedIndexleftFraction  ^leftFractiondisableTableLayout: aBool  self assureLayoutProperties disableTableLayout: aBool.  self layoutChangedrefresh  lastRefresh := Time millisecondClockValue.  self width: labelMorph width + 25newButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: stringOrText help: helpTextinitializeAppearance  self     color: (self theme textColor alpha: 0.3);     fillStyle: (self theme taskbarFillStyleFor: self)current  ^bar valuelongMessage: aStringOrText title: aString  ^self theme longMessageIn: self text: aStringOrText title: aStringmenuButtonHeight  ^16 * self displayScaleFactorisTransferable  ^trueinitialize  super initialize.  self borderWidth: 1.  self color: (Color r: 0.4 g: 0.8 b: 0.6).  self borderColor: self color darker.  self borderStyle: BorderStyle thinGray.  actionSelector := #flash.  arguments := EmptyArray.  actWhen := #buttonUp.  self setDefaultLabeltestIndexesToSelectInMultipleSelectionFromTo  self assert: (strategy indexesToSelectInMultipleSelectionFrom: 3 to: 11) asArray equals: #(3 4 5 6 7 8 9 10 11).  self assert: (strategy indexesToSelectInMultipleSelectionFrom: 11 to: 3) asArray equals: #(11 10 9 8 7 6 5 4 3).  self assert: (strategy indexesToSelectInMultipleSelectionFrom: 3 to: 3) asArray equals: #(3)drawSeparatorAfter: aRow on: aCanvas  | frame rectangle height separatorColor |  height := listSource separatorSize.  separatorColor := listSource separatorColor.  frame := self selectionFrameForRow: aRow.  rectangle := frame left @ (frame bottom - height) corner: frame right @ frame bottom.  aCanvas fillRectangle: rectangle color: separatorColorchildAt: anIndex  | tmpIndex |  tmpIndex := anIndex.  self children do: [:item |  | size |        size := item numberOfVisibleChildren + 1.        tmpIndex <= size ifTrue: [ ^item selfOrChildAt: tmpIndex ] ifFalse: [ tmpIndex := tmpIndex - size ] ].  self errorSubscriptBounds: anIndexdrawOn: aCanvas  | dotBounds alphaCanvas windowBorderWidth dotBounds2 |  self shouldDraw ifFalse: [ ^self ].  windowBorderWidth := SystemWindow borderWidth.  alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.  dotBounds := self bounds.  dotBounds2 := dotBounds left: dotBounds right - windowBorderWidth.  dotBounds2 := dotBounds2 bottom: dotBounds2 top + windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds right: dotBounds right - windowBorderWidth.  dotBounds2 := dotBounds2 bottom: dotBounds2 top + windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds2 left: dotBounds2 left + 7.  dotBounds2 := dotBounds2 right: dotBounds2 right - 7.  alphaCanvas fillRectangle: dotBounds2 color: self dotColor.  dotBounds2 := dotBounds left: dotBounds right - windowBorderWidth.  dotBounds2 := dotBounds2 top: dotBounds2 top + windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds2 top: dotBounds2 top + 7.  dotBounds2 := dotBounds2 bottom: dotBounds2 bottom - 7.  alphaCanvas fillRectangle: dotBounds2 color: self dotColormatchPath: anAssociation  anAssociation ifNil: [ ^nil ].  ^anAssociation treeNodeHead = self complexContents withoutListWrapper ifFalse: [ nil ] ifTrue: [ | matchingChildren |        anAssociation treeNodeTail ifNil: [ ^{self} ].        matchingChildren := self children collect: [:child |  child matchPath: anAssociation treeNodeTail ].        ^matchingChildren select: [:e |  e notNil ] ]showNever  self showState: #neverlineHeight: height baseline: ascent  bottom := top + height.  baseline := ascenthideLeftOrTop  self hide.  leftOrTop do: [:m |  m hide ]minHeight  ^self valueOfProperty: #minHeight ifAbsent: [ 2 ]selectItem: aMenuItem event: anEvent  selectedItem ifNotNil: [ selectedItem deselect: anEvent ].  selectedItem := aMenuItem.  selectedItem ifNotNil: [ selectedItem select: anEvent ]secondarySelectionColor: aColor  secondarySelectionColor := aColorwantsDroppedNode: srcNode on: dstNode  dropItemSelector ifNil: [ ^false ].  wantsDropSelector ifNil: [ ^true ].  ^(model perform: wantsDropSelector with: srcNode with: dstNode) == truedrawOn: aCanvas  | box |  self style == #plain ifTrue: [ ^super drawOn: aCanvas ].  box := self bounds.  (self style == #inset or: [ self style == #insetNoHighlight ]) ifTrue: [ self style == #insetNoHighlight ifFalse: [ aCanvas drawString: self contents in: (box translateBy: 1) font: self fontToUse color: self color veryMuchLighter ].        aCanvas           drawString: self contents in: (box translateBy: -1) font: self fontToUse color: self color muchDarker;           drawString: self contents in: box font: self fontToUse color: self color ] ifFalse: [ self style == #raisedNoHighlight ifFalse: [ aCanvas drawString: self contents in: (box translateBy: -1) font: self fontToUse color: self color veryMuchLighter ].        aCanvas           drawString: self contents in: (box translateBy: 1) font: self fontToUse color: self color muchDarker;           drawString: self contents in: box font: self fontToUse color: self color ]handlesMouseOverDragging: evt  ^trueokToDiscardEdits  ^self canDiscardEdits or: [ self promptForCancel ]invokeModalAt: aPoint in: aWorld allowKeyboard: aBoolean  | w originalFocusHolder |  originalFocusHolder := aWorld primaryHand keyboardFocus.  self popUpAt: aPoint forHand: aWorld primaryHand in: aWorld allowKeyboard: aBoolean.  self isModalInvokationDone: false.  w := aWorld outermostWorldMorph.  [ self isInWorld and: [ self isModalInvokationDone not ] ] whileTrue: [ w doOneSubCycle ].  self delete.  self restoreFocus: originalFocusHolder in: aWorld.  ^self modalSelectionadjustWidth  self width: (listSource width max: self hUnadjustedScrollRange) + 20initialize  countDict := Dictionary new.  limit := self defaultLimit.  size := #small.  position := #bottomLeft.  backgroundColor := self defaultBackgroundColor.  textColor := self defaultTextColordragThroughOnDesktop: evt  | selection |  selection := SelectionMorph newBounds: (evt cursorPoint extent: 8 @ 8).  self addMorph: selection.  ^selection extendByHand: evt handcanChangeText  ^self editView enabledcontainer  ^containeraddBlankIconsIfNecessary: anIcon  self items reject: [:each |  each hasIconOrMarker ] thenDo: [:each |  each icon: anIcon ]hScrollbarNeeded  self hScrollbar showsAlways ifTrue: [ ^true ].  self hScrollbar showsNever ifTrue: [ ^false ].  ^self scrollTarget width + (self scrollTarget height > self innerBounds height ifTrue: [ self scrollBarThickness ] ifFalse: [ 0 ]) > self innerBounds widthpaneMorphSatisfying: aBlock  ^paneMorphs detect: aBlock ifNone: [ nil ]newCloseControlFor: aModel action: aValuable help: helpText  ^self theme newCloseControlIn: self for: aModel action: aValuable help: helpTextalert: aStringOrText title: aString configure: aBlock  ^self theme alertIn: self text: aStringOrText title: aString configure: aBlockkeyStroke: event  (self navigationKey: event) ifTrue: [ ^self ].  event keyCharacter = Character space ifTrue: [ self toggleSelected ]delete  activeSubMenu ifNotNil: [ activeSubMenu delete ].  ^super deleteaddMouseListener: anObject  self mouseListeners: (self addListener: anObject to: self mouseListeners)normalizedX: x  ^xhighlightedForMouseDown  ^(self valueOfProperty: #highlightedForMouseDown) == truenumberOfChildren  ^self children ifEmpty: [ 0 ] ifNotEmpty: [:children2 |  children2 size + (children2 collect: [:item |  item numberOfChildren ]) sum ]exposedRows  ^exposedRowsmorphToDropFrom: aMorph  ^aMorphpressedFillStyle  ^self theme scrollbarPressedFillStyleFor: selfextraSpace: aPoint  extraSpace := aPointcanBeClosed  ^tabs allSatisfy: [:tab |  tab closeable ]scrollToShow: aRectangle  client scrollToShow: aRectanglebrickThemer  ^(self nearestOwnerThat: [:each |  (each isKindOf: GLMFoundationBrick) | (each isKindOf: GLMBrick) ]) ifNotNil: [:brick |  brick themer ] ifNil: [ self theme brickThemer ]childrenFor: anItem  | children |  children := childrenBlock value: anItem.  ^sortingBlock ifNil: [ children ] ifNotNil: [ children sort: sortingBlock ]hScrollValue: scrollValue  hScrollBar setValue: scrollValueinsetColor  owner ifNil: [ ^self color ].  ^self colorForInsetsscrollBarAction: aSymbol  self setProperty: #scrollBarAction toValue: aSymbolmodalWindow: aMorph  (self valueOfProperty: #modalWindow) ifNotNil: [:morph |  morph delete ].  self setProperty: #modalWindow toValue: aMorph.  aMorph ifNotNil: [ self when: #aboutToLeaveWorld send: #removeModalWindow to: self ]paneColorChanged  self changedtextStyle  ^textStylebeComplete  self closedeactivate  self subclassResponsibilityupdateEnabled  self model ifNotNil: [ self getEnabledSelector ifNotNil: [ self enabled: (self model perform: self getEnabledSelector) ] ]handlerForMouseDown: anEvent  anEvent blueButtonPressed ifTrue: [ ^self handlerForBlueButtonDown: anEvent ].  anEvent yellowButtonPressed ifTrue: [ ^self handlerForYellowButtonDown: anEvent ].  anEvent controlKeyPressed ifTrue: [ ^self handlerForMetaMenu: anEvent ].  (self handlesMouseDown: anEvent) ifFalse: [ ^nil ].  anEvent handler ifNil: [ ^self ].  ^self mouseDownPriority >= anEvent handler mouseDownPriority ifTrue: [ self ] ifFalse: [ nil ]simulateClickWith: buttons position: position  | noButtons hand |  noButtons := 0.  hand := HandMorph new     mouseFocus: self;     yourself.  hand privateOwner: self.  {(#mouseDown -> buttons) .   (#mouseUp -> noButtons)} do: [:type |  hand handleEvent: (MouseButtonEvent new setType: type key position: position which: (noButtons bitXor: buttons) buttons: type value hand: hand stamp: Time millisecondClockValue) ]newScrollingIndex: anObject  newScrollingIndex := anObjectinAColumn: aCollectionOfMorphs  self setAsColumn     color: Color transparent;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     layoutInset: 1;     wrapCentering: #center;     cellPositioning: #topCenter.  aCollectionOfMorphs do: [:each |  self addMorphBack: each ].  ^selfoverlapsVertical: aSplitter  ^aSplitter top <= self bottom and: [ aSplitter bottom >= self top ]pattern  ^patternglobalPointToLocal: aPoint  ^self point: aPoint from: nilnavigateFocusForward  self nextMorphWantingFocus ifNil: [ self takeKeyboardFocus ] ifNotNil: [ super navigateFocusForward ]arrangeToStartStepping  self arrangeToStartSteppingIn: self worldscrollBarThickness  ^self theme scrollbarThicknessnewStack: controls  ^self theme newStackIn: self for: controlsisAlignmentMorph  ^falseunderlineColor  ^self stringColorchanged  container ifNil: [ ^super changed ].  self invalidRect: self selectionFrame.  super changedcanvas  ^worldState canvascolorSelected: aColor  self triggerEvent: #colorSelected with: aColorhasDropShadow  ^self valueOfProperty: #hasDropShadow ifAbsent: [ false ]drawOn: aCanvas  | dotBounds alphaCanvas windowBorderWidth dotBounds2 |  self shouldDraw ifFalse: [ ^self ].  windowBorderWidth := SystemWindow borderWidth.  alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.  dotBounds := self bounds.  dotBounds2 := dotBounds right: dotBounds left + windowBorderWidth.  dotBounds2 := dotBounds2 top: dotBounds2 bottom - windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds left: dotBounds left + windowBorderWidth.  dotBounds2 := dotBounds2 top: dotBounds2 bottom - windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds2 left: dotBounds2 left + 7.  dotBounds2 := dotBounds2 right: dotBounds2 right - 7.  alphaCanvas fillRectangle: dotBounds2 color: self dotColor.  dotBounds2 := dotBounds right: dotBounds left + windowBorderWidth.  dotBounds2 := dotBounds2 bottom: dotBounds2 bottom - windowBorderWidth.  alphaCanvas fillRectangle: dotBounds2 color: self handleColor.  dotBounds2 := dotBounds2 top: dotBounds2 top + 7.  dotBounds2 := dotBounds2 bottom: dotBounds2 bottom - 7.  alphaCanvas fillRectangle: dotBounds2 color: self dotColordefaultLabel  ^'Window' translatedmouseMoveOnSingle: evt  | row |  self enabled ifFalse: [ ^self ].  row := self rowAtLocation: evt position.  evt hand hasSubmorphs ifFalse: [ ((self containsPoint: evt position) and: [ row ~= 0 ]) ifTrue: [ self mouseDownRow: row ] ifFalse: [ self mouseDownRow: nil ] ].  (self dropEnabled and: [ evt hand hasSubmorphs ]) ifFalse: [ ^self eventHandler ifNotNil: [ self eventHandler mouseMove: evt fromMorph: self ] ].  (self containsPoint: evt position) ifTrue: [ self mouseEnterDragging: evt ] ifFalse: [ self mouseLeaveDragging: evt ]defaultBorderColor  ^Color yellowdrawOn: aCanvas  | fauxBounds |  self setDefaultContentsIfNil.  super drawOn: aCanvas.  false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  self startingIndex > text size ifTrue: [ self drawNullTextOn: aCanvas ].  fauxBounds := self bounds topLeft corner: self innerBounds bottomRight.  aCanvas paragraph: self paragraph bounds: fauxBounds color: colorchangeClipLayoutCells  self invalidRect: self fullBounds.  self clipLayoutCells: self clipLayoutCells not.  self invalidRect: self fullBoundsrememberedKeyboardFocus  ^self valueOfProperty: #rememberedFocususeSortedTabsBy: sortBlock  tabs := SortedCollection sortBlock: sortBlockcomposeAll  ^self multiComposeLinesFrom: firstCharacterIndex to: text size delta: 0 into: OrderedCollection new priorLines: Array new atY: container topretrievingBlock: anObject  retrievingBlock := anObject.  retrievingBlock ifNotNil: [ self softRetrieveMorph ]extent: aPoint  | newExtent priorEditor |  bounds extent = aPoint ifTrue: [ ^self ].  priorEditor := editor.  self isAutoFit ifTrue: [ wrapFlag ifFalse: [ ^self ].        newExtent := aPoint truncated max: self minimumExtent.        newExtent x = self extent x ifTrue: [ ^self ].        self releaseParagraphReally.        super extent: newExtent.        priorEditor ifNil: [ self fit ] ifNotNil: [ self installEditorToReplace: priorEditor ] ] ifFalse: [ super extent: (aPoint truncated max: self minimumExtent).        wrapFlag ifFalse: [ ^self ].        self composeToBounds ]blueMorphTab  | tab |  tab := TabMorph label: 'Blue Morph' icon: (self iconNamed: #smallBackIcon) morph: Morph new.  tab actions: {(TabAction action: [ tab morph color: Color random ] icon: (self iconNamed: #smallConfigurationIcon) label: 'Randomize color')}.  tab     closeable: false;     menu: [:menu |  menu add: 'Fubu' target: self selector: #halt ].  ^taballowsDeselection  ^allowsDeselection ifNil: [ self class defaultAllowsDeselection ]addMorph: newMorph behind: aMorph  ^self privateAddMorph: newMorph atIndex: (submorphs indexOf: aMorph) + 1lostFocusWithoutAccepting  self acceptContentsinitialize  super initialize.  emphasis := 0.  hasFocus := false.  backgroundColor := Color transparenton: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel  self getSelectionListSelector: getListSel.  self setSelectionListSelector: setListSel.  self on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel.  self beMultipleSelectionwrapSelector: anObject  wrapSelector := anObjectcornerStyle: aSymbol  super cornerStyle: aSymbol.  self imageMorph cornerStyle: aSymboloffset: anObject  offset := anObject.  self fitContentsexpand  self isCollapsed ifTrue: [ self collapseOrExpand ]defaultFocusMorph  ^self defaultButton ifNil: [ (self respondsTo: #nextMorphWantingFocus) ifTrue: [ self nextMorphWantingFocus ] ] ifNotNil: [:b |  b enabled ifTrue: [ b ] ]getEnabledSelector  ^getEnabledSelectoractionBlock: aBlock  actionBlock := aBlockhasSubMenu: aMenuMorph  subMenu ifNil: [ ^false ].  subMenu == aMenuMorph ifTrue: [ ^true ].  ^subMenu hasSubMenu: aMenuMorphvisible  ^visiblevalueOfProperty: aSymbol  ^self valueOfProperty: aSymbol ifAbsent: [  ]avoidVisibleBordersAtEdgeString  ^self avoidVisibleBordersAtEdge -> 'avoid visible borders at edge' translatedveryDeepFixupWith: deepCopier  owner := deepCopier references at: owner ifAbsent: [ nil ]newAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel font: aFont help: helpTextnewTabGroup: labelsAndPages  ^self theme newTabGroupIn: self for: labelsAndPagesselectTabAt: index  toolbar selectTabAt: index ifAbsent: [  ]headerButtonLabel: aLabel font: aFont  self headerButton.  self header label: aLabel font: aFontnewGroupboxFor: control  ^self theme newGroupboxIn: self for: controlwidth  ^right - leftselectOnlyLastHighlighted  ^removeOnlyLastSelectedclosestPointTo: aPoint  ^self intersectionWithLineSegmentFromCenterTo: aPointasArray  ^{leftFraction .   topFraction .   rightFraction .   bottomFraction .   leftOffset .   topOffset .   rightOffset .   bottomOffset}green  ^(self selectedColor green * 255) asIntegerisActivated  ^falseprocessEventsFromQueue: anEventQueue  | evt evtBuf type hadAny |  ActiveEvent ifNotNil: [ self mouseOverHandler processMouseOver: lastMouseEvent ].  hadAny := false.  [ anEventQueue isNotNil and: [ (evtBuf := anEventQueue nextEvent) isNotNil ] ] whileTrue: [ evt := nil.        type := evtBuf first.        type = EventTypeMouse ifTrue: [ self world beCursorOwner.              recentModifiers := evtBuf sixth.              evt := self generateMouseEvent: evtBuf ].        type = EventTypeKeyboard ifTrue: [ recentModifiers := evtBuf fifth.              evt := self generateKeyboardEvent: evtBuf ].        type = EventTypeDragDropFiles ifTrue: [ evt := self generateDropFilesEvent: evtBuf ].        type = EventTypeWindow ifTrue: [ evt := self generateWindowEvent: evtBuf ].        (type ~= EventTypeDragDropFiles and: [ evt isNil ]) ifTrue: [ ^self ].        evt ifNotNil: [ self handleEvent: evt.              hadAny := true.              (evt isMouse and: [ evt isMouseWheel not ]) ifTrue: [ ^self ] ] ].  mouseClickState notNil ifTrue: [ mouseClickState handleEvent: lastMouseEvent asMouseMove from: self ].  hadAny ifFalse: [ self mouseOverHandler processMouseOver: lastMouseEvent ]defaultButton  ^self findDeepSubmorphThat: [:m |  (m isKindOf: PluggableButtonMorph) and: [ m isDefault ] ] ifAbsent: [  ]numberOfRows  ^self model ifNotNil: [ self getListSizeSelector ifNotNil: [ self model perform: self getListSizeSelector ] ifNil: [ (self model perform: self getListSelector) size ] ] ifNil: [ 0 ]mouseUp: evt  target ifNotNil: [ Display deferUpdatesIn: Display boundingBox while: [ target bounds: self bounds ] ].  self deleteinitialDataSource  ^initialDataSourceupdateText  self model ifNotNil: [ self getTextSelector ifNotNil: [ self contents: (self model perform: self getTextSelector) ] ]addAlarm: aSelector withArguments: argArray for: aTarget at: scheduledTime  self alarms add: (MorphicAlarm scheduledAt: scheduledTime receiver: aTarget selector: aSelector arguments: argArray)updateLabelEnablement  self labelMorph enabled: self enabledtotalLength  | length |  length := 0.  self lineSegmentsDo: [:a :b |  length := length + (a distanceTo: b) ].  ^lengthinitialize  super initialize.  fillsOwner := true.  avoidVisibleBordersAtEdge := true.  autoGradient := self wantsGradientByDefault.  self color: self defaultColor.  self beFloating.  self layoutInset: 0nextMorphInWindow  ^self hasSubmorphs ifTrue: [ self submorphs first ] ifFalse: [ self nextMorphAcrossInWindow ]canvas  ^canvasbottom: aNumber  self position: bounds left @ (aNumber - self height)drawCaretOnAthensCanvas: anAthensCanvas  (self showCaret not or: [ selectionStart isNil ]) ifTrue: [ ^self ].  caretRect := selectionStart topLeft asIntegerPoint extent: 1 @ selectionStart height.  anAthensCanvas setPaint: self insertionPointColor.  anAthensCanvas drawShape: self caretRectroots: aCollection  rootItems := aCollection collect: [:each |  FTBasicTreeListItem new           item: each;           datasource: self ].  self countAvailableRowsinitializeSelections  self onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: selfkeystrokeActionSelector: aSelectorOrBlock  keystrokeActionSelector := aSelectorOrBlocklabel: anObject  label := anObjectisFlexMorph  ^truedrawSubMenuMarker: aForm on: aCanvas in: aRectangle  | markerRect |  markerRect := aRectangle topRight + (aForm width negated @ ((aRectangle height - aForm height) // 2)) extent: aForm extent.  markerRect translateBy: -4 @ 1.  self drawIcon: aForm on: aCanvas in: markerRectenabled  ^enabled ifNil: [ enabled := super enabled ]okayToRotateEasily  ^self respondsTo: #prepareForRotatingdefaultTextColor  ^Color blackisRowSelected: row  ^(selectedRow notNil and: [ row = selectedRow ]) or: [ listSource itemSelectedAmongMultiple: row ]recursiveDelete  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aNode recursiveDelete ] ].  self deleteoption: aSymbol  option := aSymbol.  self     changed: #isLeft;     changed: #isCenter;     changed: #isRightupdatePaneColors  self setStripeColorsFrom: self paneColorToUsenewHSVASelector: aColor help: helpText  ^self theme newHSVASelectorIn: self color: aColor help: helpTextpattern  ^self ensureSafePattern: patternModel getText asString trimBothprintOn: aStream  aStream nextPutAll: 'NodeMorph('.  complexContents printOn: aStream.  aStream nextPut: $)mouseMove: evt  (self containsPoint: evt cursorPoint) ifTrue: [ self setSwitchState: oldColor = offColor ] ifFalse: [ self setSwitchState: oldColor = onColor ]beUnResetable  resetable := falserotationCenter  | refPos |  refPos := self valueOfProperty: #referencePosition ifAbsent: [ ^0.5 @ 0.5 ].  ^(refPos - self bounds origin) / self bounds extent asFloatPointnewBalloonHelp: aTextStringOrMorph for: aMorph corner: cornerSymbol  ^self theme newBalloonHelpIn: self contents: aTextStringOrMorph for: aMorph corner: cornerSymbolgetSelectedPathSelector  ^getSelectedPathSelectortoggleAction: aBoolean  self inform: (aBoolean ifTrue: [ 'Button pressed' ] ifFalse: [ 'Button unpressed' ])normalFillStyle  ^self theme controlButtonNormalFillStyleFor: selflayout: aMorph in: layoutBounds  | props cell box pos vr newBounds minExt |  aMorph submorphs ifEmpty: [ ^self ].  props := aMorph assureTableProperties.  minExt := self minExtentOf: aMorph in: layoutBounds.  newBounds := layoutBounds origin extent: (layoutBounds extent max: minExt).  cell := newBounds.  aMorph submorphs with: cachedMinExtents do: [:m :ext |  ((vr := m vResizing) == #shrinkWrap or: [ m bounds ~= cell ]) ifTrue: [ ((vr == #shrinkWrap) not and: [ m extent = cell extent ]) ifTrue: [ m position: cell origin ] ifFalse: [ box := m bounds.                    m hResizing == #spaceFill ifTrue: [ box := cell origin extent: cell width @ box height ].                    vr == #spaceFill ifTrue: [ box := box origin extent: box width @ cell height ].                    vr == #shrinkWrap ifTrue: [ box := box origin extent: box width @ ext y ].                    pos := props cellPositioning.                    box := box align: (box perform: pos) with: (cell perform: pos).                    m bounds: box ] ] ]childrenDo: aBlock  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aBlock value: aNode ] ]mouseLeave: anEvent  self canResizeColumn ifFalse: [ ^self ].  super mouseLeave: anEventindexesToSelectInMultipleSelectionFrom: firstIndex to: endIndex  | stepV stepH |  stepV := firstIndex first <= endIndex first ifTrue: [ 1 ] ifFalse: [ -1 ].  stepH := firstIndex second <= endIndex second ifTrue: [ 1 ] ifFalse: [ -1 ].  ^(firstIndex second to: endIndex second by: stepH) flatCollect: [:v |  (firstIndex first to: endIndex first by: stepV) collect: [:h |  {h .               v} ] ]registerActionsFor: aTab  aTab     when: #tabSelected send: #tabSelected: to: self;     when: #tabDeleted send: #tabDeleted: to: self;     when: #rightKeyPressed send: #rightKeyPressed: to: self;     when: #leftKeyPressed send: #leftKeyPressed: to: self;     when: #tabRefreshed send: #tabRefreshed: to: self;     when: #actionsChanged send: #actionsChanged: to: self;     when: #tabResetSelection send: #tabResetSelection: to: self;     when: #tabAddedToSelection send: #tabAddedToSelection: to: self;     when: #tabRemovedFromSelection send: #tabRemovedFromSelection: to: self;     when: #tabSelectTo send: #tabSelectTo: to: self;     when: #tabEmptyContents send: #tabEmptyContents: to: selfchildrenBlock: aBlockClosure  childrenBlock := aBlockClosureactualClass  self subclassResponsibilityredButtonPressed  ^buttons anyMask: self class redButtonsilentlySetSelectedMorph: aMorph  | path |  path := aMorph ifNotNil: [ aMorph path collect: [:m |  m complexContents ] ].  self isMultiple ifFalse: [ self emptySelection ].  aMorph ifNotNil: [ self addToSelection: aMorph ].  self selectionUpdateFromViewWhile: [ self listModel selection: (self newSelectionHolderWithNodePath: path) ]wantsGradientByDefault  ^self theme preferGradientFillshouldGetStepsFrom: aWorld  ^self world == aWorldadjustHeight  self height: (listItems size max: 1) * font heightnewLabelFor: aModel getLabel: labelSel getEnabled: enabledSel  ^self theme newLabelIn: self for: aModel getLabel: labelSel getEnabled: enabledSelgoBehind  | cont |  container ifNil: [ ^super goBehind ].  self releaseParagraph.  cont := container.  super goBehind.  container := cont.  self changedcolumnColorForEven: evenColor odd: oddColor  columnColors at: 2 put: oddColor.  columnColors at: 1 put: evenColortaskbars  ^self submorphs select: [:each |  each isTaskbar ]editorProvider  ^self valueOfProperty: #editorProvider ifAbsent: [  ]newTabGroup  ^(self newTabGroup: #()) cornerStyle: #squareenough: nTry withMeasure: lastMeasure withIn: closeEnough  | measure |  measure := self measureFor: nTry.  measure > (lastMeasure + closeEnough) ifFalse: [ ^nTry // 2 ].  ^self enough: 2 * nTry withMeasure: measure withIn: closeEnoughwasHandled  ^wasHandledhScrollbarShowWhenNeeded  self hScrollbar showWhenNeeded.  self updateScrollbarscreateTitleMorph  titleMorph ifNotNil: [ titleMorph delete ].  titleMorph := MenuTitleMorph new.  titleMorph on: #mouseDown send: #mouseDownInTitle: to: self.  self addMorphFront: titleMorphlistSpacing: aSymbol  listSpacing := aSymbolforwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]drawOn: aCanvas  aCanvas fillRectangle: self innerBounds fillStyle: (InfiniteForm with: self hatchForm).  super drawOn: aCanvasfont  ^(self textStyle fontAt: self fontNumber) copyveryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  target := deepCopier references at: target ifAbsent: [ target ].  arguments notNil ifTrue: [ arguments := arguments collect: [:each |  deepCopier references at: each ifAbsent: [ each ] ] ]newLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newLabelIn: self for: aModel label: aString getEnabled: enabledSelsubmorphWithProperty: aSymbol  ^submorphs detect: [:aMorph |  aMorph hasProperty: aSymbol ] ifNone: [ nil ]selectedPressedFillStyle  ^self theme taskbarItemSelectedPressedFillStyleFor: selfclassButton  ^(self theme newButtonIn: self currentWorld for: self getState: nil action: #browseItem arguments: {} getEnabled: #enabled getLabel: nil help: 'Open a browser on ' translated , self item name)     label: (self theme windowLabelForText: self item name , '...');     yourselfaction: anObject  action := anObject.  icon on: #click send: #value to: actionfillsOwner: aBoolean  fillsOwner := aBoolean.  self releaseCachedStatetabGroup: anObject  tabGroup := anObjectcachedForm: anObject  cachedForm := anObjectcustomSettingsOn: aBuilder  (aBuilder pickOne: #position)     order: 1;     target: self;     label: 'Position in World';     description: 'Select one of the positons available to specify where the shortcut notification morph will be shown';     default: #bottomLeft;     domainValues: self positions.  (aBuilder pickOne: #textSize)     order: 2;     target: self;     label: 'Size of the reminder';     description: 'Set the size (small medium or large) of the reminder morph shown';     domainValues: self sizes.  (aBuilder setting: #textColor)     order: 3;     target: self;     label: 'Text color';     default: self defaultTextColor.  (aBuilder setting: #backgroundColor)     target: self;     label: 'Background color';     default: self defaultBackgroundColor.  (aBuilder range: #limit)     order: 6;     target: self;     label: 'Notification limit';     description: 'Set the limit of how many notifications per menu entry one should be reminded about. Setting the value to -1 means that it will allways remind you';     default: self defaultLimit;     range: (-1 to: 100).  (aBuilder group: #'Reset count')     order: 7;     target: self;     label: 'Reset the reminder count';     dialog: [ self createResetCountButtonMorph ]selectedPageIndex: index  self tabSelectorMorph selectedIndex: indexdialogWindowIn: aWindow title: aTitle  ^self dialogWindowIn: aWindow title: aTitle selectedtems: Array newopenedFullscreen  self allMorphs do: [:m |  m layoutChanged ].  self activatedoRecolor: evt with: aHandle  evt hand obtainHalo: self.  (aHandle containsPoint: evt cursorPoint) ifFalse: [ self delete.        target addHalo: evt ] ifTrue: [ innerTarget changeColor ].  self showingDirectionHandles ifTrue: [ self addHandles ]textMorph  ^textMorphdropElements: aCollection index: rowIndex  self elements: (rowIndex = 0 ifTrue: [ self elements , aCollection ] ifFalse: [ (self elements first: rowIndex) , aCollection , (self elements allButFirst: rowIndex) ])max: aNumber  endValue := aNumberwindow: anObject  window := anObjectseparateDragAndDrop  | dnd |  (self hasProperty: #dragNDropEnabled) ifFalse: [ ^self ].  dnd := (self valueOfProperty: #dragNDropEnabled) == true.  self dragEnabled: dnd.  self dropEnabled: dnd.  self removeProperty: #dragNDropEnabledtaskbarTask  ^nilitem: anItem  item := anItemdefaultBorderWidth  ^self theme dockingBarBorderWidthedgeName  ^edgeNamehoneIn: enough  [ enough isPowerOfTwo ] assert.  enough < 2 ifTrue: [ ^enough ].  ^self honeIn: enough step: enough // 2 measure: (self measureFor: enough) withIn: self leewayprintOn: aStream  self storeOn: aStreamenable  self enabled: truedelete  morphDeleted := true.  super deleteinitializeLabelArea  super initializeLabelArea.  self removeBoxes.  self replaceBoxesexpand: aNumber  rootItems do: [:each |  each expandToDepth: aNumber ]rightOffset: anInteger  rightOffset := anIntegerhandlesGestureStart: evt  ^self existsSubscriptionsFor: #gestureStartroundedCorners  self wasActivatedFromDockingBar ifTrue: [ activatorDockingBar isFloating ifTrue: [ ^#(2 3) ].        activatorDockingBar isAdheringToTop ifTrue: [ ^#(2 3) ].        activatorDockingBar isAdheringToBottom ifTrue: [ ^#(1 4) ].        activatorDockingBar isAdheringToLeft ifTrue: [ ^#(3 4) ].        activatorDockingBar isAdheringToRight ifTrue: [ ^#(1 2) ] ].  ^super roundedCornerstextEntry: aStringOrText title: aString entryText: defaultEntryText  ^self theme textEntryIn: self text: aStringOrText title: aString entryText: defaultEntryTextpressedButtonBorderStyle  ^self theme scrollbarPressedButtonBorderStyleFor: selfbuttonString  | string |  string := ''.  self redButtonPressed ifTrue: [ string := string , 'red ' ].  self yellowButtonPressed ifTrue: [ string := string , 'yellow ' ].  self blueButtonPressed ifTrue: [ string := string , 'blue ' ].  ^stringsetFramesForLabelArea  self theme configureDialogWindowLabelAreaFrameFor: selfhHideOrShowScrollBar  self hIsScrollbarNeeded ifTrue: [ self hShowScrollBar ] ifFalse: [ self hHideScrollBar ]addPolyLIneCurveMenuItems: aMenu hand: aHandMorph  aMenu     addLine;     addUpdating: #openOrClosePhrase target: self selector: #toggleOpenOrClosed.  aMenu addUpdating: #smoothOrSegmentedPhrase target: self selector: #toggleSmoothingbounds: aRectangle from: referenceMorph  owner ifNil: [ ^aRectangle ].  ^(owner transformFrom: referenceMorph) globalBoundsToLocal: aRectanglegetCurrentSelectionIndex  self getIndexSelector ifNil: [ ^0 ].  ^self model perform: self getIndexSelectortestDoubleClickFromMorph  morph eventHandler on: #doubleClick send: #value to: true.  self assert: (morph doubleClick: nil) identicalTo: truedrawSubmorphsOn: aCanvas  aCanvas transformBy: transform clippingTo: self innerBounds during: [:myCanvas |  (self angle ~= 0.0 or: [ self scale ~= 1.0 ]) ifTrue: [ FreeTypeSettings current forceNonSubPixelDuring: [ submorphs reverseDo: [:m |  myCanvas fullDrawMorph: m ] ] ] ifFalse: [ submorphs reverseDo: [:m |  myCanvas fullDrawMorph: m ] ] ] smoothing: smoothingnewHSVSelector: aColor help: helpText  ^self theme newHSVSelectorIn: self color: aColor help: helpTextnewExpander: aString  ^self theme newExpanderIn: self label: aString forAll: #()takesKeyboardFocus  ^truetestSelectableIndexBefore  self should: [ strategy selectableIndexBefore: 2 ] raise: ErrorbuttonSetup  self actWhen: #buttonUp.  self cornerStyle: #rounded.  self borderNormal.  self on: #mouseEnter send: #borderRaised to: self.  self on: #mouseLeave send: #borderNormal to: self.  self on: #mouseLeaveDragging send: #borderNormal to: self.  self on: #mouseDown send: #borderInset to: self.  self on: #mouseUp send: #borderRaised to: selfadoptPaneColor: paneColor  self submorphsDo: [:m |  m adoptPaneColor: paneColor ]update: aSymbol  aSymbol = #relabel ifTrue: [ ^model ifNotNil: [ self setLabel: model labelString ] ].  aSymbol = #close ifTrue: [ self delete ]