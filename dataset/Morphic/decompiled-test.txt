selectedFillStyle  ^self theme tabLabelSelectedFillStyleFor: self-=JUAMPI=-printStructureOn: arg1 indent: arg2  arg2 timesRepeat: [ arg1 tab ].  self printOn: arg1.  arg1 cr.  self submorphsDo: [:arg3 |  arg3 printStructureOn: arg1 indent: arg2 + 1 ]-=JUAMPI=-updateFromEvent: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 cursorPoint - lastMouse second.  tmp4 := index = 1 ifTrue: [ container minResizerX ] ifFalse: [ (container columnResizers at: index - 1) right + container minResizerOffset ].  tmp5 := tmp4 max: tmp1 x.  index = 1 ifTrue: [ tmp5 := tmp5 + 3 ].  self left: tmp5.  tmp2 := index = 1 ifTrue: [ container scroller left - container scroller offset x + 3 ] ifFalse: [ (container columnResizers at: index - 1) left ].  tmp3 := self left - tmp2.  (container columns at: index) currentWidth: tmp3.  container resizerChanged-=JUAMPI=-displaySelectionInLine: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  selectionStart ifNil: [ ^self ].  arg2 isShadowDrawing ifTrue: [ ^self ].  selectionStart = selectionStop ifTrue: [ selectionStart textLine ~= arg1 ifTrue: [ ^self ] ] ifFalse: [ (selectionStop stringIndex < arg1 first or: [ selectionStart stringIndex > (arg1 last + 1) ]) ifTrue: [ ^self ].        (selectionStop stringIndex = arg1 first and: [ selectionStop textLine ~= arg1 ]) ifTrue: [ ^self ].        (selectionStart stringIndex = (arg1 last + 1) and: [ selectionStop textLine ~= arg1 ]) ifTrue: [ ^self ] ].  tmp1 := (selectionStart stringIndex < arg1 first ifTrue: [ arg1 ] ifFalse: [ selectionStart ]) left.  tmp2 := (selectionStop stringIndex > (arg1 last + 1) or: [ selectionStop stringIndex = (arg1 last + 1) and: [ selectionStop textLine ~= arg1 ] ]) ifTrue: [ arg1 right ] ifFalse: [ selectionStop left ].  selectionStart = selectionStop ifTrue: [ tmp2 := tmp2 + 1.        tmp3 := self caretWidth.        caretRect := (tmp1 - tmp3) @ arg1 top corner: (tmp2 + tmp3) @ arg1 bottom.        self showCaret ifFalse: [ ^self ].        tmp4 := self insertionPointColor.        1 to: tmp3 do: [:arg3 |  arg2 fillRectangle: ((tmp1 - tmp3 + arg3 - 1) @ (arg1 top + arg3 - 1) extent: ((tmp3 - arg3) * 2 + 3) @ 1) color: tmp4.              arg2 fillRectangle: ((tmp1 - tmp3 + arg3 - 1) @ (arg1 bottom - arg3) extent: ((tmp3 - arg3) * 2 + 3) @ 1) color: tmp4 ].        arg2 fillRectangle: (tmp1 @ arg1 top corner: tmp2 @ arg1 bottom) color: tmp4 ] ifFalse: [ caretRect := nil.        arg2 fillRectangle: (tmp1 @ arg1 top corner: tmp2 @ arg1 bottom) color: self selectionColor ]-=JUAMPI=-enabled: arg1  enabled := arg1.  self     cachedForm: nil;     changed-=JUAMPI=-ghostText  self subclassResponsibility-=JUAMPI=-toggle  self isExpanded ifTrue: [ self collapseAndRefresh ] ifFalse: [ self expandAndRefresh ]-=JUAMPI=-flashBounds  5 timesRepeat: [ Display flash: self boundsInWorld andWait: 120 ]-=JUAMPI=-handlesClickOrDrag: arg1  ^(self existsSubscriptionsFor: #click) or: [ (self existsSubscriptionsFor: #doubleClick) or: [ self existsSubscriptionsFor: #startDrag ] ]-=JUAMPI=-newLabel  ^self theme checkboxLabelFor: self-=JUAMPI=-targetPoint  ^position - source targetOffset-=JUAMPI=-copyHandlerState: arg1  -=JUAMPI=-table: arg1  table := arg1-=JUAMPI=-font: arg1  font := arg1.  self update: getLabelSelector-=JUAMPI=-wantsColumnBreaks: arg1  wantsColumnBreaks := arg1-=JUAMPI=-gripLayoutFrame  ^(0 @ 1 corner: 0 @ 1) asLayoutFrame     topOffset: self defaultHeight negated;     rightOffset: self defaultWidth-=JUAMPI=-testTransform  | tmp1 tmp2 |  tmp1 := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  tmp2 := tmp1 layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 140 @ 60) equals: tmp2-=JUAMPI=-defaultColor  ^Color green lighter-=JUAMPI=-changePropotionalLayout  | tmp1 |  ((tmp1 := self layoutPolicy) notNil and: [ tmp1 isProportionalLayout ]) ifTrue: [ ^self ].  self layoutPolicy: ProportionalLayout new.  self layoutChanged-=JUAMPI=-setGrabbedColor  self fillStyle: self theme fastTableColumnSplitterSelectedColor-=JUAMPI=-calculateVisibleRows  ^self calculateMaxVisibleRows min: self table numberOfRows-=JUAMPI=-newGroupbox: arg1 for: arg2  ^self theme newGroupboxIn: self label: arg1 for: arg2-=JUAMPI=-drawText: arg1 on: arg2 in: arg3  ^self drawText: arg1 on: arg2 in: arg3 color: self stringColorToUse-=JUAMPI=-drawLinesOn: arg1  self selectedTab ifNotNil: [ self drawWithSelectionOn: arg1 ] ifNil: [ self drawWithoutSelectedOn: arg1 ]-=JUAMPI=-selectRow: arg1  selectedRows add: arg1.  self invalidRect: (self selectionFrameForRow: arg1)-=JUAMPI=-scrollBarColor  ^self paneColor-=JUAMPI=-flushLayoutCache  minExtentCache := nil-=JUAMPI=-colorFor: arg1  arg1 odd ifTrue: [ ^Smalltalk ui theme lightBackgroundColor ].  ^Smalltalk ui theme backgroundColor-=JUAMPI=-finishedScrolling: arg1  self finishedScrolling.  (self containsPoint: arg1 position) ifTrue: [ pagingArea           fillStyle: self mouseOverFillStyle;           borderStyle: self mouseOverBorderStyle ] ifFalse: [ pagingArea           fillStyle: self normalFillStyle;           borderStyle: self normalBorderStyle ].  (upButton containsPoint: arg1 position) ifTrue: [ upButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: arg1 position) ifTrue: [ upButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ upButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ].  (downButton containsPoint: arg1 position) ifTrue: [ downButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: arg1 position) ifTrue: [ downButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ downButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ]-=JUAMPI=-theme  ^Smalltalk ui theme-=JUAMPI=-mouseUp: arg1  actWhen == #buttonUp ifFalse: [ ^super mouseUp: arg1 ].  (self containsPoint: arg1 cursorPoint) ifTrue: [ self state: #on.        self doButtonAction: arg1 ] ifFalse: [ self state: #off ]-=JUAMPI=-preferredKeyboardPosition  ^(self bounds: self bounds in: self currentWorld) topLeft-=JUAMPI=-indexFromPosition: arg1  ^arg1 first-=JUAMPI=-initializeTable: arg1  table := arg1.  self initialize-=JUAMPI=-handleFocusEvent: arg1  ^self handleEvent: arg1-=JUAMPI=-rotationDegrees  ^0.0-=JUAMPI=-target: arg1  self setTarget: arg1.  target ifNotNil: [ self addHandles ]-=JUAMPI=-wantsDirectionHandles  ^false-=JUAMPI=-gridSpecPut: arg1  ^self setProperty: #gridSpec toValue: arg1-=JUAMPI=-wantsKeyboardFocusOnMouseDown  ^self wantsKeyboardFocus and: [ self valueOfProperty: #wantsKeyboardFocusOnMouseDown ifAbsent: [ false ] ]-=JUAMPI=-selectionBarColor  ^self theme selectionBarColor-=JUAMPI=-itemWithWording: arg1  self items do: [:arg2 |  | tmp1 |        tmp1 := arg2 itemWithWording: arg1.        tmp1 ifNotNil: [ ^tmp1 ] ].  ^nil-=JUAMPI=-compositionRectangle  ^container-=JUAMPI=-tasks: arg1  tasks := arg1-=JUAMPI=-inject: arg1 into: arg2  | tmp1 |  tmp1 := arg1.  self do: [:arg3 |  tmp1 := arg2 value: tmp1 value: arg3 ].  ^tmp1-=JUAMPI=-selectionIndex  ^self listMorph selectedRow ifNil: [ 0 ]-=JUAMPI=-positionModalOwner  self modalOwner ifNotNil: [:arg1 |  (arg1 isKindOf: SystemWindow) ifTrue: [ arg1 bringBehind: self ] ]-=JUAMPI=-down: arg1  down := arg1.  self changed-=JUAMPI=-addNameBeneath: arg1 string: arg2  | tmp1 tmp2 |  tmp2 := self world ifNil: [ target world ].  nameMorph := StringMorph contents: arg2 font: StandardFonts haloFont.  nameMorph     wantsYellowButtonMenu: false;     color: self theme balloonTextColor;     backgroundColor: self theme balloonBackgroundColor;     target: innerTarget.  tmp1 := arg1 bottomCenter - ((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).  nameMorph position: (tmp1 min: tmp2 viewBox bottomRight - nameMorph extent y + 2).  self addMorph: nameMorph.  ^nameMorph-=JUAMPI=-acceptOnCR: arg1  acceptOnCR := arg1-=JUAMPI=-drawSubmorphsOn: arg1  super drawSubmorphsOn: arg1.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: arg1 ]-=JUAMPI=-initialize  super initialize.  self elements: #()-=JUAMPI=-table  ^table-=JUAMPI=-getChildren  ^dataSource childrenBlock isSymbol ifTrue: [ dataSource childrenBlock value: data ] ifFalse: [ dataSource childrenBlock cull: data cull: self ]-=JUAMPI=-setType: arg1  type := arg1-=JUAMPI=-getIconSelector: arg1  getIconSelector := arg1-=JUAMPI=-takesKeyboardFocus  ^true-=JUAMPI=-addItemShowing: arg1 from: arg2 to: arg3  lock critical: [ | tmp1 tmp2 |        tmp1 := SystemProgressItemMorph labeled: arg1 from: arg2 to: arg3.        tmp2 := self bars size.        tmp2 < 10 ifTrue: [ self addMorphBack: tmp1.              self recenter ].        ^tmp1 ]-=JUAMPI=-wantsStepsWhenCollapsed  ^false-=JUAMPI=-updateTasks  | tmp1 |  tmp1 := windows collect: [:arg1 |  self newTaskFor: arg1 ].  self updateOrderedTasksFrom: tmp1-=JUAMPI=-lineWidth: arg1  self borderWidth: (arg1 rounded max: 1)-=JUAMPI=-scrollUpInit  | tmp1 |  tmp1 := upButton borderStyle baseColor.  upButton borderInset.  upButton borderStyle baseColor: tmp1.  self resetTimer.  self scrollBarAction: #doScrollUp.  self doScrollUp.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nil.  upButton fillStyle: self pressedButtonFillStyle.  upButton borderStyle: self pressedButtonBorderStyle-=JUAMPI=-action  self inform: 'Button pressed'-=JUAMPI=-changeMinCellSize: arg1  | tmp1 |  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  self minCellSize: (arg2 - arg1 cursorPoint) asIntegerPoint ].  arg1 hand attachMorph: tmp1.  tmp1 startStepping-=JUAMPI=-beIconRight  iconPosition := #right.  self update: getIconSelector-=JUAMPI=-on: arg1 color: arg2  self     model: arg1;     getColorSelector: arg2;     updateColor-=JUAMPI=-getChildrenSelector  ^getChildrenSelector-=JUAMPI=-indexForRow: arg1  ^{arg1 .   self table selectedIndex second}-=JUAMPI=-newLocationMorph  ^ImageMorph new form: Cursor crossHair withMask asCursorForm-=JUAMPI=-defaultColor  ^self theme menuSelectionColor alpha: 0.08-=JUAMPI=-cellColumn: arg1 row: arg2  arg1 id = 'Icon' ifTrue: [ ^self iconColumn: arg1 row: arg2 ].  arg1 id = 'Name' ifTrue: [ ^self nameColumn: arg1 row: arg2 ].  arg1 id = 'Number of methods' ifTrue: [ ^self numberOfMethodsColumn: arg1 row: arg2 ].  arg1 id = 'Number of instance variables' ifTrue: [ ^self numberOfInstanceVariablesColumn: arg1 row: arg2 ].  self error: 'Invalid column'-=JUAMPI=-indentingItemClass  ^MorphTreeNodeMorph-=JUAMPI=-hasTableLayoutString  | tmp1 |  ^((tmp1 := self layoutPolicy) notNil and: [ tmp1 isTableLayout ]) -> 'table layout' translated-=JUAMPI=-wantsExpandBox  ^true-=JUAMPI=-deriveHScrollRange  | tmp1 tmp2 |  (list isNil or: [ list isEmpty ]) ifTrue: [ hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0 ] ifFalse: [ tmp1 := self listMorph hUnadjustedScrollRange.        tmp2 := tmp1 + self hExtraScrollRange + self hMargin.        hScrollRangeCache := Array with: tmp2 with: tmp1 with: list size with: list first with: list last ]-=JUAMPI=-headerColumn: arg1  ^self basicHeaderCellFor: arg1-=JUAMPI=-setIndexSelector: arg1  setIndexSelector := arg1-=JUAMPI=-windowEventHandler: arg1  WindowEventHandler := arg1-=JUAMPI=-initialExtent  ^(self model respondsTo: #initialExtent) ifTrue: [ self model initialExtent ] ifFalse: [ RealEstateAgent standardWindowExtent ]-=JUAMPI=-ownerChanged  super ownerChanged.  self updateLayoutInDockingBar-=JUAMPI=-newOKButton  ^self newOKButtonFor: self-=JUAMPI=-currentlyExpanded  ^(scroller submorphs select: [:arg1 |  arg1 isExpanded ]) collect: [:arg1 |  arg1 complexContents ]-=JUAMPI=-acquireBorderWidth: arg1  | tmp1 |  (tmp1 := arg1 - self borderWidth) = 0 ifTrue: [ ^self ].  self bounds: (self bounds origin - (tmp1 @ tmp1) corner: self bounds corner + (tmp1 @ tmp1)).  self borderWidth: arg1.  self layoutChanged-=JUAMPI=-allSiblingItems  | tmp1 tmp2 tmp3 |  tmp2 := (Array new: 40) writeStream.  tmp1 := self owner submorphs select: [:arg1 |  arg1 isKindOf: self class ].  tmp1 := (tmp1 copyFrom: (tmp3 := tmp1 indexOf: self) to: tmp1 size) , (tmp1 copyFrom: 1 to: tmp3 - 1).  tmp1 do: [:arg2 |  tmp2 nextPutAll: arg2 items ].  ^tmp2 contents-=JUAMPI=-userString  ^nil-=JUAMPI=-visible: arg1  visible := arg1-=JUAMPI=-target: arg1  -=JUAMPI=-headerButtonLabel: arg1 icon: arg2  self headerButtonLabel: arg1 font: nil.  self header cellInset: 3 @ 0.  self header icon: (ImageMorph new form: arg2)-=JUAMPI=-newLabel  | tmp1 |  tmp1 := self theme buttonLabelFor: self.  font ifNotNil: [ tmp1 font: font.        tmp1 extent: tmp1 optimalExtent ].  ^tmp1-=JUAMPI=-arguments  ^arguments-=JUAMPI=-handlesMouseDown: arg1  ^true-=JUAMPI=-getListSelector: arg1  getListSelector := arg1.  self changed.  self updateList-=JUAMPI=-basicBorderWidth: arg1  borderWidth := arg1-=JUAMPI=-doGrow: arg1 with: arg2  | tmp1 tmp2 tmp3 |  arg1 hand obtainHalo: self.  tmp1 := (target pointFromWorld: arg1 cursorPoint - positionOffset) - target topLeft.  arg1 shiftPressed ifTrue: [ tmp3 := tmp1 x / (originalExtent x max: 1) min: tmp1 y / (originalExtent y max: 1).        tmp1 := (originalExtent x * tmp3) asInteger @ (originalExtent y * tmp3) asInteger ].  (tmp1 x < 1 or: [ tmp1 y < 1 ]) ifTrue: [ ^self ].  target renderedMorph extent: (tmp2 := tmp1).  arg2 position: arg1 cursorPoint - (arg2 extent // 2).  self layoutChanged-=JUAMPI=-focusBounds  ^self theme buttonFocusBoundsFor: self-=JUAMPI=-isMouseOver  ^self type == #mouseOver-=JUAMPI=-getCurrentSelectionIndex  getIndexSelector ifNil: [ ^0 ].  ^model perform: getIndexSelector-=JUAMPI=-restoreAndActivate  self isMinimized ifTrue: [ self restore ].  self isActive ifFalse: [ self activate ]-=JUAMPI=-removeFlexShell  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := self referencePosition.  tmp3 := self world.  tmp1 := self halo.  submorphs isEmpty ifTrue: [ ^self delete ].  tmp5 := (owner submorphIndexOf: self) ifNil: [ 1 ].  tmp2 := self firstSubmorph.  self submorphs do: [:arg1 |  arg1 position: self center - (arg1 extent // 2).        owner addMorph: arg1 asElementNumber: tmp5 ].  tmp1 ifNotNil: [ tmp1 setTarget: tmp2 ].  tmp3 ifNotNil: [ tmp3 startSteppingSubmorphsOf: tmp2 ].  self delete.  tmp2 referencePosition: tmp4.  ^tmp2-=JUAMPI=-selectionColor  ^selectionColor-=JUAMPI=-includesTableProperties  ^true-=JUAMPI=-newBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newBracketSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8-=JUAMPI=-needSeparatorBefore: arg1  | tmp1 |  arg1 <= 1 ifTrue: [ ^false ].  tmp1 := arg1.  self items do: [:arg2 |  arg2 size >= tmp1 ifTrue: [ ^tmp1 = 1 ] ifFalse: [ tmp1 := tmp1 - arg2 size ] ].  self errorSubscriptBounds: arg1-=JUAMPI=-drawBackgroundOnAthensCanvas: arg1  (isSelected and: [ isEnabled ]) ifFalse: [ ^self ].  arg1 setPaint: self selectionFillStyle.  arg1 drawShape: (0 @ 0 extent: self extent)-=JUAMPI=-lastKeystroke: arg1  ^self setProperty: #lastKeystroke toValue: arg1-=JUAMPI=-lastColumnBounded  ^self lastColumnUnbounded not-=JUAMPI=-selection  ^editor ifNotNil: [ editor selection ]-=JUAMPI=-actions  ^actions-=JUAMPI=-drawOn: arg1  arg1 fillOval: bounds fillStyle: self fillStyle borderWidth: borderWidth borderColor: borderColor-=JUAMPI=-selfOrChildAt: arg1  ^arg1 = 1 ifTrue: [ self ] ifFalse: [ self childAt: arg1 - 1 ]-=JUAMPI=-setMultipleContents  | tmp1 tmp2 tmp3 |  contentsWrapper removeAllMorphs.  self cleanProcesses.  tmp1 := toolbar orderedSelectedTabs.  tmp2 := tmp1 size.  tmp3 := 1 / tmp2.  tmp1 allButLast keysAndValuesDo: [:arg1 :arg2 |  self addTabContents: arg2 at: arg1 delta: tmp3 ].  self addLastTabContents: tmp1 last among: tmp2 delta: tmp3.  self addSplitterOn: tmp1 delta: tmp3-=JUAMPI=-drawSubMorphOn: arg1  | tmp1 |  tmp1 := self bounds insetBy: (self cornerRadius + 3) @ (self topInactiveGap // 2 + 2).  tmp1 := tmp1 translateBy: 0 @ (self topInactiveGap // 2 + 1).  self active ifTrue: [ tmp1 := tmp1 translateBy: 0 @ (self topInactiveGap // 2 + 1) negated ].  self subMorph bounds height < tmp1 height ifTrue: [ tmp1 := tmp1 insetBy: 0 @ ((tmp1 height - self subMorph bounds height) // 2) ].  self subMorph bounds width < tmp1 width ifTrue: [ tmp1 := tmp1 insetBy: ((tmp1 width - self subMorph bounds width) // 2) @ 0 ].  self subMorph bounds: tmp1.  arg1 drawMorph: self subMorph-=JUAMPI=-defaultGraphics  ^DefaultGraphics-=JUAMPI=-bringBehind: arg1  | tmp1 |  tmp1 := self topRendererOrSelf.  tmp1 owner ifNil: [ ^self ].  tmp1 owner addMorph: tmp1 after: arg1 topRendererOrSelf.  self modalOwner ifNotNil: [:arg2 |  arg2 bringBehind: self ]-=JUAMPI=-checkMorphsRightOrBottomFrom: arg1  | tmp1 |  tmp1 := submorphs identityIndexOf: arg1.  tmp1 := tmp1 - 1.  [ tmp1 > 0 ] whileTrue: [ | tmp2 tmp3 |        tmp2 := submorphs at: tmp1.        arg1 addRightOrBottom: tmp2.        tmp3 := self isResizeableMorph: tmp2 forSplitter: arg1.        tmp3 ifTrue: [ tmp1 := 0 ].        tmp1 := tmp1 - 1 ]-=JUAMPI=-controlKeyPressed  ^buttons anyMask: 2r00010000-=JUAMPI=-prepareForRotating  ^self addFlexShell-=JUAMPI=-addFlexShell  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := self world.  tmp1 := self halo.  tmp4 := self owner submorphIndexOf: self.  self owner addMorph: (tmp2 := self newTransformationMorph asFlexOf: self) asElementNumber: tmp4.  self transferStateToRenderer: tmp2.  tmp1 ifNotNil: [ tmp1 setTarget: tmp2 ].  tmp3 ifNotNil: [ tmp3 startSteppingSubmorphsOf: tmp2 ].  ^tmp2-=JUAMPI=-handlesMouseOverDragging: arg1  ^self dropEnabled-=JUAMPI=-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-=JUAMPI=-mouseLeaveDragging: arg1  (self dropEnabled and: [ arg1 hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: arg1 ].  self basicHighlightIndexes: #().  self refresh-=JUAMPI=-handleKeystroke: arg1 inMorph: arg2  -=JUAMPI=-wrapOnOff  self wrapFlag: wrapFlag not-=JUAMPI=-pressedBorderStyle  ^self theme controlButtonPressedBorderStyleFor: self-=JUAMPI=-aMorph  ^aMorph-=JUAMPI=-newSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8-=JUAMPI=-splitterRight  | tmp1 |  tmp1 := (self siblingSplitters select: [:arg1 |  arg1 left > self left and: [ self overlapsVertical: arg1 ] ]) asSortedCollection: [:arg2 :arg3 |  arg2 left < arg3 left ].  ^tmp1 ifEmpty: [ nil ] ifNotEmpty: [:arg4 |  arg4 first ]-=JUAMPI=-listSpacing: arg1  self assureTableProperties listSpacing: arg1.  self layoutChanged-=JUAMPI=-onImage  | tmp1 |  tmp1 := Form extent: (self fontToUse ascent - 2) asPoint depth: 16.  tmp1 getCanvas     frameAndFillRectangle: tmp1 boundingBox fillColor: (Color gray: 0.8) borderWidth: 1 borderColor: Color black;     fillRectangle: (tmp1 boundingBox insetBy: 2) fillStyle: Color black.  ^tmp1-=JUAMPI=-expandItem  expanded := true.  children := (dataSource childrenFor: item) collect: [:arg1 |  self treeItemFor: arg1 ].  dataSource updateAvailableRows: self availableRows - 1-=JUAMPI=-fillWithRamp: arg1 oriented: arg2  arg1 isColor ifTrue: [ self color: arg1 ] ifFalse: [ | tmp1 |        tmp1 := GradientFillStyle ramp: arg1.        tmp1 origin: self bounds topLeft.        tmp1 direction: (self bounds extent * arg2) truncated.        tmp1 radial: false.        self fillStyle: tmp1.        self borderColor: (arg1 first value mixed: 0.5 with: arg1 last value) muchDarker ]-=JUAMPI=-adjustToHorizontalScrollBarValue: arg1  | tmp1 |  tmp1 := (self table numberOfColumns * arg1) rounded min: self table numberOfColumns max: 1.  tmp1 ~= self startColumnIndex ifTrue: [ self startColumnIndex: tmp1.        self changed ]-=JUAMPI=-testUpdateEmptyTaskBarWithNewWindow  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: taskbar tasks size equals: 1-=JUAMPI=-iconOrThumbnailOfSize: arg1  ^self iconOrThumbnail scaledIntoFormOfSize: arg1-=JUAMPI=-handlesKeyboard: arg1  ^true-=JUAMPI=-newFuzzyLabel: arg1  ^self theme newFuzzyLabelIn: self for: nil label: arg1 offset: 1 alpha: 0.5 getEnabled: nil-=JUAMPI=-matches: arg1  self subclassResponsibility-=JUAMPI=-debug  [ builder menuSpec asMenuMorph ] ensure: [ builder reset ]-=JUAMPI=-world  ^world-=JUAMPI=-mouseFocus: arg1  mouseFocus := arg1-=JUAMPI=-mouseEnter: arg1  self canResizeColumn ifFalse: [ ^self ].  (owner notNil and: [ owner bounds containsPoint: arg1 position ]) ifTrue: [ super mouseEnter: arg1 ]-=JUAMPI=-verticesAt: arg1 put: arg2  vertices at: arg1 put: arg2.  self computeBounds-=JUAMPI=-newAColorMorph  ^AColorSelectorMorph new     model: self;     hResizing: #spaceFill;     vResizing: #rigid;     setValueSelector: #alphaSelected:;     extent: 24 @ 24-=JUAMPI=-vShowScrollBar  self vIsScrollbarShowing ifTrue: [ ^self ].  self vResizeScrollBar.  self privateAddMorph: scrollBar atIndex: 1.  self resetExtent-=JUAMPI=-menu: arg1 shifted: arg2  super menu: arg1 shifted: arg2.  arg1 addLine.  self selectedNode ifNotNil: [:arg3 |  arg3 menu: arg1 shifted: arg2.        arg1 addLine.        arg1 add: 'Expand all from here' target: self selector: #expandAllFromNode: argument: arg3 ].  ^arg1-=JUAMPI=-mouseUp: arg1  needToggleAtMouseUp ifFalse: [ ^self ].  (self selectionModeStrategy selectableIndexContainingPoint: arg1 cursorPoint) ifNotNil: [:arg2 |  self selectIndex: arg2 event: arg1 ].  needToggleAtMouseUp := false-=JUAMPI=-event  ^event-=JUAMPI=-userString  ^list ifNotNil: [ String streamContents: [:arg1 |  list do: [:arg2 |  arg1                       nextPutAll: arg2 string;                       cr ] ] ]-=JUAMPI=-layoutProperties  ^extension ifNotNil: [ extension layoutProperties ]-=JUAMPI=-modifiedCharacter  self flag: #hack.  ^(self hasSpecialCTRLKeyValue and: [ #(MacOSX Windows) includes: Smalltalk os platformFamily ]) ifTrue: [ (self keyValue + $a asciiValue - 1) asCharacter ] ifFalse: [ Smalltalk os isWindows ifTrue: [ self keyCharacter asLowercase ] ifFalse: [ self keyCharacter ] ]-=JUAMPI=-newGroupboxFor: arg1  ^self theme newGroupboxIn: self for: arg1-=JUAMPI=-openInWindowLabeled: arg1 inWorld: arg2  self layoutInset: 0.  ^super openInWindowLabeled: arg1 inWorld: arg2-=JUAMPI=-isAutoFit  ^false-=JUAMPI=-removeWindow: arg1  windows remove: arg1-=JUAMPI=-useSecondarySelection  ^false-=JUAMPI=-mouseEnter: arg1  super mouseEnter: arg1.  self over: true-=JUAMPI=-selectAll  self isMultipleSelection ifFalse: [ ^self ].  1 to: self maximumSelection do: [:arg1 |  self listSelectionAt: arg1 put: true ]-=JUAMPI=-getListSelector  ^getListSelector-=JUAMPI=-basicBorderColor: arg1  borderColor := arg1-=JUAMPI=-newAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7-=JUAMPI=-view: arg1  -=JUAMPI=-defaultButton  ^IconicButton new     target: self;     color: Color transparent;     borderWidth: 0;     yourself-=JUAMPI=-selectedIndex  ^self selectedIndexes ifNotEmpty: #first ifEmpty: [ self selectionModeStrategy nullIndex ]-=JUAMPI=-negateBottomRightOffsets  bottomOffset := bottomOffset negated.  rightOffset := rightOffset negated-=JUAMPI=-keyStroke: arg1  ^false-=JUAMPI=-mouseLeaveDragging: arg1  super mouseLeaveDragging: arg1.  self over: false-=JUAMPI=-assureExtension  extension ifNil: [ self initializeExtension ].  ^extension-=JUAMPI=-vSetScrollDelta  | tmp1 tmp2 |  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  tmp2 := self scrollDeltaHeight.  tmp1 := self vLeftoverScrollRange.  tmp1 = 0 ifTrue: [ ^scrollBar           scrollDelta: 0.02 pageDelta: 0.2;           interval: 1.0;           setValue: 0 ].  scrollBar scrollDelta: (tmp2 / tmp1) asFloat pageDelta: ((self innerBounds height - tmp2) / tmp1) asFloat.  scrollBar interval: (self innerBounds height / self vTotalScrollRange) asFloat.  scrollBar setValue: (scroller offset y / tmp1 min: 1.0) asFloat-=JUAMPI=-passenger: arg1  passenger := arg1-=JUAMPI=-paneWithLongestSide: arg1 near: arg2  | tmp1 tmp2 tmp3 |  tmp3 := 0.  paneMorphs do: [:arg3 |  | tmp4 |        tmp4 := arg3 bounds.        tmp4 forPoint: arg2 closestSideDistLen: [:arg4 :arg5 :arg6 |  (arg5 <= 5 and: [ arg6 > tmp3 ]) ifTrue: [ tmp1 := arg3.                    tmp2 := arg4.                    tmp3 := arg6 ] ] ].  arg1 value: tmp2.  ^tmp1-=JUAMPI=-emptySelection  self selectedMorphList do: [:arg1 |  arg1           unhighlight;           setSelectedSilently: false ].  self selectedMorphList removeAll.  self selectionChanged-=JUAMPI=-hasUnacceptedEdits: arg1  -=JUAMPI=-toggleEnabled  self enabled: self enabled not-=JUAMPI=-newSeparator  ^self theme newSeparatorIn: self-=JUAMPI=-leftArrowStroked: arg1  popUpOwner ifNil: [ ^self ].  ^self deselectAndFocusOutermenuOn: arg1-=JUAMPI=-unsort  self unsortElements.  self table refresh-=JUAMPI=-nextState  ^FTDescendingSortingState context: self context-=JUAMPI=-getLabelSelector  ^getLabelSelector-=JUAMPI=-enabled: arg1  enabled = arg1 ifTrue: [ ^self ].  enabled := arg1.  self changed: #enabled.  self     adoptPaneColor: self paneColor;     changed-=JUAMPI=-currentCursor  ^ActiveHand world currentCursor-=JUAMPI=-imageFromName: arg1  ^self images at: arg1 ifPresent: [:arg2 |  arg2 value ] ifAbsent: [  ]-=JUAMPI=-isClosed  ^closed-=JUAMPI=-topLeftColor  ^width = 1 ifTrue: [ self color twiceLighter ] ifFalse: [ self color lighter ]-=JUAMPI=-displayWorld  worldState displayWorld: self submorphs: submorphs-=JUAMPI=-findDeepSubmorphThat: arg1 ifAbsent: arg2  self allMorphsDo: [:arg3 |  (arg1 value: arg3) == true ifTrue: [ ^arg3 ] ].  ^arg2 value-=JUAMPI=-selected  ^state selected-=JUAMPI=-addToggleItemsToHaloMenu: arg1  super addToggleItemsToHaloMenu: arg1.  arg1 addUpdating: #enabledString target: self selector: #toggleEnabled-=JUAMPI=-defaultColor  ^Color white-=JUAMPI=-isRight  ^direction = Character arrowRight-=JUAMPI=-formerPosition  ^self valueOfProperty: #formerPosition-=JUAMPI=-initialize  super initialize.  hasFocus := false.  self initializeScrollBars.  self extent: self defaultExtent.  self hideOrShowScrollBars-=JUAMPI=-addHandleAt: arg1 color: arg2 icon: arg3 on: arg4 send: arg5 to: arg6  | tmp1 |  tmp1 := self createHandleAt: arg1 color: arg2 iconName: arg3.  self addMorph: tmp1.  tmp1 on: #mouseUp send: #endInteraction to: self.  tmp1 on: arg4 send: arg5 to: arg6.  tmp1 setBalloonText: (target balloonHelpTextForHandle: tmp1) translated.  ^tmp1-=JUAMPI=-steppingMorphsNotInWorld  | tmp1 |  tmp1 := self allMorphs.  ^self listOfSteppingMorphs reject: [:arg1 |  tmp1 includes: arg1 ]-=JUAMPI=-enableFilter  function := FTFilterFunction table: self-=JUAMPI=-selectPreviousTab  self selectedIndex: (self selectedIndex < 2 ifTrue: [ self tabs size ] ifFalse: [ self selectedIndex - 1 ])-=JUAMPI=-wantsYellowButtonMenu  self valueOfProperty: #wantsYellowButtonMenu ifPresentDo: [:arg1 |  ^arg1 ].  self isInSystemWindow ifTrue: [ ^false ].  ^self defaultYellowButtonMenuEnabled-=JUAMPI=-model  ^nil-=JUAMPI=-on: arg1 send: arg2 to: arg3 withValue: arg4  arg2 numArgs = 3 ifFalse: [ self error: 'Warning: value parameters are passed as first of 3 arguments' ].  self addSubscription: (MorphEventSubscription on: arg1 send: arg2 to: arg3 withValue: arg4) toEvent: arg1-=JUAMPI=-truncatedMenuLabelFor: arg1  ^arg1 truncateWithElipsisTo: 47-=JUAMPI=-selectedNodePathList: arg1  selectedNodePathList := arg1-=JUAMPI=-newBalloonHelp: arg1 for: arg2  ^self theme newBalloonHelpIn: self contents: arg1 for: arg2 corner: #bottomLeft-=JUAMPI=-unshiftedYellowButtonActivity  ^self yellowButtonActivity: false-=JUAMPI=-keyStroke: arg1  | tmp1 |  owner isHandMorph ifFalse: [ ^self ].  tmp1 := arg1 keyValue.  tmp1 = 28 ifTrue: [ ^self position: self position - (1 @ 0) ].  tmp1 = 29 ifTrue: [ ^self position: self position + (1 @ 0) ].  tmp1 = 30 ifTrue: [ ^self position: self position - (0 @ 1) ].  tmp1 = 31 ifTrue: [ ^self position: self position + (0 @ 1) ].  tmp1 = 13 ifTrue: [ owner releaseKeyboardFocus: self.        self delete ]-=JUAMPI=-testSelectLast  table selectLast.  self assert: table selectedIndexes equals: #(10)-=JUAMPI=-selectIndexes: arg1 andMakeVisibleIf: arg2  | tmp1 |  arg1 = self selectedIndexes ifTrue: [ ^self ].  tmp1 := self selectedIndexes.  self basicSelectIndexes: arg1.  arg2 ifTrue: [ self ensureVisibleFirstSelection ].  self refresh.  self doAnnounce: ((FTSelectionChanged from: tmp1 to: self selectedIndexes)           fastTable: self;           yourself)-=JUAMPI=-privateFullMoveBy: arg1  self privateMoveBy: arg1.  submorphs do: [:arg2 |  arg2 privateFullMoveBy: arg1 ]-=JUAMPI=-updateImage  (self model notNil and: [ self getImageSelector notNil ]) ifTrue: [ (self model perform: self getImageSelector) ifNotNil: [:arg1 |  self image: arg1 ] ]-=JUAMPI=-createExpandBox  ^self theme createExpandBoxFor: self-=JUAMPI=-spotterWindowsFor: arg1  < spotterOrder: 100>  arg1 listProcessor     title: 'Windows';     allCandidates: [ self class allSubInstances ];     itemName: [:arg2 |  '**' , arg2 label , '**' ];     filter: GTFilterSubstring-=JUAMPI=-vHideOrShowScrollBar  self vIsScrollbarNeeded ifTrue: [ self vShowScrollBar ] ifFalse: [ self vHideScrollBar ]-=JUAMPI=-children  | tmp1 |  tmp1 := OrderedCollection new.  self childrenDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1-=JUAMPI=-keyStroke: arg1  (super keyStroke: arg1) ifTrue: [ ^true ].  self keystrokeSelector ifNotNil: [ (self keyStrokeAction: arg1) ifTrue: [ ^true ] ].  (self keystrokeActionSelector notNil and: [ arg1 anyModifierKeyPressed ]) ifTrue: [ (self keyStrokeModifierAction: arg1) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-cachedForm  | tmp1 tmp2 tmp3 |  cachedForm ifNil: [ tmp2 := self scaledImage.        tmp3 := self enabled ifTrue: [ self alpha ] ifFalse: [ self alpha / 2 ].        tmp3 = 1.0 ifTrue: [ self cachedForm: tmp2 ] ifFalse: [ tmp1 := Form extent: tmp2 extent depth: 32.              tmp1 fillColor: (Color white alpha: 0.003922).              (tmp1 getCanvas asAlphaBlendingCanvas: tmp3) drawImage: tmp2 at: 0 @ 0.              self cachedForm: tmp1 ] ].  ^cachedForm-=JUAMPI=-newColumn: arg1  ^self theme newColumnIn: self for: arg1-=JUAMPI=-reversedSelectedTabs  ^selectionHistory last: numberOfSelectedTabs-=JUAMPI=-openInExternalWindow  | tmp1 |  tmp1 := OSWindowWorldMorph new extent: self fullBounds extent.  tmp1     layoutPolicy: ProportionalLayout new;     clipSubmorphs: true.  self     hResizing: #spaceFill;     vResizing: #spaceFill.  self openInWorld: tmp1.  self onAnnouncement: MorphDeleted do: [:arg1 |  tmp1 ifNotNil: [ tmp1 delete ].        tmp1 := nil ].  ^tmp1 open-=JUAMPI=-removePendingBalloonFor: arg1  self removeAlarm: #spawnBalloonFor:.  self deleteBalloonTarget: arg1-=JUAMPI=-expandAllSuchThat: arg1  self roots do: [:arg2 |  self expand: arg2 suchThat: arg1 ].  self innerWidgetChanged-=JUAMPI=-setSwitchState: arg1  arg1 ifTrue: [ self turnOn ] ifFalse: [ self turnOff ]-=JUAMPI=-tabKey: arg1  arg1 controlKeyPressed ifFalse: [ arg1 keyCharacter = Character tab ifTrue: [ arg1 shiftPressed ifTrue: [ self navigateFocusBackward ] ifFalse: [ self navigateFocusForward ].              ^true ] ].  ^false-=JUAMPI=-newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4  ^self newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: nil-=JUAMPI=-alpha: arg1  alpha := arg1.  self changed-=JUAMPI=-hue: arg1  | tmp1 |  tmp1 := self selectedColor.  self selectedColor: ((Color h: (arg1 / 255 * 359) rounded s: tmp1 saturation v: tmp1 brightness) alpha: tmp1 alpha)-=JUAMPI=-testIndexesToSelectInMultipleSelectionFromTo  self subclassResponsibility-=JUAMPI=-borderWidth: arg1  borderColor ifNil: [ borderColor := Color black ].  borderWidth := arg1 max: 0.  self computeBounds-=JUAMPI=-getEnabledSelector: arg1  getEnabledSelector := arg1.  self updateEnabled-=JUAMPI=-submorphBounds  | tmp1 |  submorphs do: [:arg1 |  | tmp2 |        arg1 visible ifTrue: [ tmp2 := arg1 fullBounds.              tmp1 ifNil: [ tmp1 := tmp2 copy ] ifNotNil: [ tmp1 := tmp1 quickMerge: tmp2 ] ] ].  tmp1 ifNil: [ ^self bounds ].  ^tmp1 origin asIntegerPoint corner: tmp1 corner asIntegerPoint-=JUAMPI=-isPartialMatch  ^self complexContents isPartialMatch-=JUAMPI=-dropItemSelector: arg1  self dataSource dropItemSelector: arg1-=JUAMPI=-onWindowLabelChanged: arg1  self tabGroup relabelPage: arg1 window with: (self tabLabelFor: arg1 window)-=JUAMPI=-potentialDropMorph: arg1  potentialDropMorph := arg1-=JUAMPI=-activateCursor: arg1 withMask: arg2  -=JUAMPI=-imageExport  ^self form bits asArray-=JUAMPI=-maximumSelection  ^scroller submorphs size-=JUAMPI=-vanishAfterSlidingTo: arg1 event: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self imageForm offset: 0 @ 0.  tmp2 := self world.  tmp3 := arg2 hand fullBounds origin.  self delete.  tmp2 displayWorld.  tmp4 := arg1.  tmp1 slideFrom: tmp3 to: tmp4 nSteps: 12 delay: 15-=JUAMPI=-yellowButtonPressed  ^buttons anyMask: self class yellowButton-=JUAMPI=-drawOn: arg1  super drawOn: arg1.  (ActiveHand notNil and: [ ActiveHand keyboardFocus == self and: [ self rootMenu hasProperty: #hasUsedKeyboard ] ]) ifTrue: [ arg1 frameAndFillRectangle: self innerBounds fillColor: Color transparent borderWidth: self theme menuBorderWidth borderColor: self theme menuKeyboardFocusColor ]-=JUAMPI=-maximumSelection  ^self getListSize-=JUAMPI=-newMenu  ^self theme newMenuIn: self for: self-=JUAMPI=-selectFirst  self table selectIndex: #(1 1)-=JUAMPI=-gridOrigin: arg1  ^self gridSpecPut: (arg1 extent: self gridModulus)-=JUAMPI=-borderColor: arg1  super borderColor: arg1.  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) == (arg1 isColor and: [ arg1 isTranslucentButNotTransparent ]) ifFalse: [ self releaseCachedState ]-=JUAMPI=-is: arg1 bellowRow: arg2  ^arg1 > arg2-=JUAMPI=-hResizeScrollBar  super hResizeScrollBar.  hScrollBar bounds: ((hScrollBar bounds withTop: hScrollBar top - self pagerHeight) withBottom: hScrollBar bottom - self pagerHeight)-=JUAMPI=-taskbarButtonMenu: arg1  | tmp1 tmp2 tmp3 |  tmp2 := self theme.  tmp1 := tmp2 newMenuIn: self for: self.  tmp1 addToggle: 'Restore' translated target: self selector: #restore getStateSelector: nil enablementSelector: #isNotRestored.  tmp1 lastItem     icon: self theme windowMaximizeForm;     font: tmp2 menuFont.  tmp1 addToggle: 'Minimize' translated target: self selector: #minimize getStateSelector: nil enablementSelector: #isNotMinimized.  tmp1 lastItem     icon: self theme windowMinimizeForm;     font: tmp2 menuFont.  tmp1 addToggle: 'Maximize' translated target: self selector: #maximize getStateSelector: nil enablementSelector: #canBeMaximized.  tmp1 lastItem     icon: self theme windowMaximizeForm;     font: tmp2 menuFont.  tmp1 addLine.  tmp3 := tmp2 newMenuIn: self for: self.  tmp1 add: 'Close all' icon: self theme windowCloseForm subMenu: tmp3.  tmp3 addToggle: 'windows to right' translated target: self selector: #taskbarCloseAllToRight getStateSelector: nil enablementSelector: true.  tmp3 addToggle: 'windows like this' translated target: self selector: #taskbarCloseAllLikeThis getStateSelector: nil enablementSelector: true.  tmp3 addToggle: 'unchanged windows' translated target: self currentWorld selector: #closeAllUnchangedWindows getStateSelector: nil enablementSelector: true.  tmp3 addToggle: 'close all debuggers' translated target: Smalltalk tools debugger selector: #closeAllDebuggers getStateSelector: nil enablementSelector: true.  tmp1 addToggle: 'Close' translated target: self selector: #closeBoxHit getStateSelector: nil enablementSelector: #allowedToClose.  tmp1 lastItem     icon: self theme windowCloseForm;     font: tmp2 menuFont.  ^tmp1-=JUAMPI=-couldHaveRoundedCorners  ^false-=JUAMPI=-font: arg1  self labelMorph font: arg1-=JUAMPI=-cellInset  ^0-=JUAMPI=-normalFillStyle  ^self theme splitterNormalFillStyleFor: self-=JUAMPI=-tearDown  morph delete.  super tearDown-=JUAMPI=-drawOnAthensCanvas: arg1  self getListSize = 0 ifTrue: [ ^self ].  self setColumnWidthsFor: arg1.  self adjustWidth.  super drawOnAthensCanvas: arg1-=JUAMPI=-newHatchMorph  ^Morph new     color: Color transparent;     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     minWidth: 48;     minHeight: 12;     addMorph: (Morph new color: Color white) fullFrame: (0 @ 0 corner: 0.3 @ 1) asLayoutFrame;     addMorph: (Morph new fillStyle: (InfiniteForm with: self hatchForm)) fullFrame: (0.3 @ 0 corner: 0.7 @ 1) asLayoutFrame;     addMorph: self solidLabelMorph fullFrame: (0.7 @ 0 corner: 1 @ 1) asLayoutFrame;     addMorph: self labelMorph fullFrame: (0 @ 0 corner: 1 @ 1) asLayoutFrame-=JUAMPI=-dismissMorph  | tmp1 |  tmp1 := self world ifNil: [ ^self ].  tmp1 stopStepping: self.  self delete-=JUAMPI=-extent: arg1  self adjustAfter: [ | tmp1 |        tmp1 := self scale * arg1 r / self fullBounds extent r max: 0.1.        self scale: (tmp1 detentBy: 0.1 atMultiplesOf: 1.0 snap: false) ]-=JUAMPI=-defaultImageFormOfSize: arg1  ^(defaultImageForm isNil or: [ defaultImageForm extent ~= arg1 ]) ifTrue: [ defaultImageForm := Form extent: arg1 ] ifFalse: [ defaultImageForm ]-=JUAMPI=-sliderThickness  ^7-=JUAMPI=-testHeading  | tmp1 |  cases := {(tmp1 := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ [ self assert: tmp1 heading equals: 0.0 ] ensure: [ tmp1 delete ] ]-=JUAMPI=-setListFont  StandardFonts chooseFontWithTitle: 'Choose the font for this list' translated for: self setSelector: #font: getSelector: #font-=JUAMPI=-menuColumn: arg1 row: arg2  | tmp1 |  self getMenuSelector ifNil: [ ^nil ].  tmp1 := UIManager default newMenuIn: self table for: self model.  self getMenuSelector numArgs = 1 ifTrue: [ ^self model perform: self getMenuSelector with: tmp1 ].  ^self model perform: self getMenuSelector with: tmp1 with: false-=JUAMPI=-clipboardText: arg1  ^self osWindow clipboardText: arg1-=JUAMPI=-newHColorMorph  ^HColorSelectorMorph new     model: self;     setValueSelector: #hue:;     hResizing: #rigid;     vResizing: #spaceFill;     extent: 36 @ 36-=JUAMPI=-getListElementSelector  ^self dataSource getListElementSelector-=JUAMPI=-minWidth  | tmp1 tmp2 tmp3 |  tmp1 := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  tmp2 := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  tmp3 := tmp1 ifTrue: [ tmp2 ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness * 3 ] ] ifFalse: [ tmp2 ifTrue: [ self scrollBarThickness + 20 ] ifFalse: [ self scrollBarThickness * 3 + 2 ] ].  ^tmp3 max: super minWidth-=JUAMPI=-requestDropReference: arg1  | tmp1 |  fileNames ifNil: [ ^FileReference requestDropReference: arg1 ].  tmp1 := self fileNames at: arg1.  ^(FilePathEncoder decode: tmp1) asFileReference-=JUAMPI=-explicitFunction  function showWidget-=JUAMPI=-outerBounds  ^self bounds-=JUAMPI=-cellPositioning: arg1  cellPositioning := arg1-=JUAMPI=-actionOffset  ^4 * self displayScaleFactor-=JUAMPI=-wantsHaloFromClick  ^true-=JUAMPI=-removeKeyCombination: arg1  self kmDispatcher removeKeyCombination: arg1-=JUAMPI=-wantsToBeTopmost  ^false-=JUAMPI=-listDirection: arg1  listDirection := arg1-=JUAMPI=-beStraightSegments  smoothCurve == false ifFalse: [ smoothCurve := false.        self computeBounds ]-=JUAMPI=-wantsWindowEvent: arg1  ^true-=JUAMPI=-setColor: arg1  self labelMorph color: arg1.  self solidLabelMorph color: arg1 beOpaque-=JUAMPI=-testWhenChangingOrderInWorldListTaskOrderShouldRemains  | tmp1 tmp2 |  taskbar := self.  world := self.  tmp1 := world addWindow.  tmp2 := world addWindow.  taskbar updateTasks.  world putOnTop: tmp1.  taskbar updateTasks.  self assert: taskbar tasks first morph equals: tmp1.  self assert: taskbar tasks second morph equals: tmp2-=JUAMPI=-selectMoreAtTop  | tmp1 |  autoTargetMorph ifNil: [ ^self ].  tmp1 := autoTargetMorph index.  tmp1 > 1 ifTrue: [ self autoMultiSelect: (self allNodeMorphs at: tmp1 - 1).        self selectionChanged ]-=JUAMPI=-actionSelector  ^actionSelector-=JUAMPI=-adoptGradientColor: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  arg1 ifNil: [ ^self ].  tmp1 := arg1.  tmp2 := self normalThumbFillStyle.  tmp3 := self normalButtonFillStyle.  tmp4 := self normalThumbBorderStyle.  tmp5 := self normalButtonBorderStyle.  sliderColor := tmp1.  downButton     fillStyle: tmp3;     borderStyle: tmp5.  upButton     fillStyle: tmp3 shallowCopy;     borderStyle: tmp5.  slider     fillStyle: tmp2;     borderStyle: tmp4.  self updateUpButtonImage.  self updateDownButtonImage-=JUAMPI=-newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 getLabel: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 getLabel: arg6 help: arg7-=JUAMPI=-setTabContentFrom: arg1  | tmp1 |  contentsWrapper removeAllMorphs.  self cleanProcesses.  tmp1 := arg1 retrieveMorph: [:arg2 |  arg2 ifNil: [ TabWithNoContents signalTab: arg1 ].        contentsWrapper addMorph: arg2 fullFrame: LayoutFrame identity ].  tmp1 ifNotNil: [ processes add: tmp1 ]-=JUAMPI=-outermostMorphThat: arg1  | tmp1 |  self allOwnersDo: [:arg2 |  (arg1 value: arg2) ifTrue: [ tmp1 := arg2 ] ].  ^tmp1-=JUAMPI=-getColorSelector: arg1  getColorSelector := arg1-=JUAMPI=-wantsDroppedMorph: arg1 event: arg2  ^arg1 dragTransferType == #dragTransfer ifTrue: [ super wantsDroppedMorph: arg1 event: arg2 ] ifFalse: [ self model wantsDroppedMorph: arg1 event: arg2 inMorph: self ]-=JUAMPI=-minHeight  | tmp1 |  tmp1 := self hasIcon ifTrue: [ self icon height + 2 ] ifFalse: [ 0 ].  ^((self contents heightToDisplayInTree: self) max: tmp1) max: super minHeight-=JUAMPI=-wantsHaloHandleWithSelector: arg1 inHalo: arg2  (#(addDismissHandle:) includes: arg1) ifTrue: [ ^self resistsRemoval not ].  (#(addDragHandle:) includes: arg1) ifTrue: [ ^self okayToBrownDragEasily ].  (#(addGrowHandle: addScaleHandle:) includes: arg1) ifTrue: [ ^self okayToResizeEasily ].  (#(addRotateHandle:) includes: arg1) ifTrue: [ ^self okayToRotateEasily ].  (#(addRecolorHandle:) includes: arg1) ifTrue: [ ^self renderedMorph wantsRecolorHandle ].  ^true-=JUAMPI=-transform: arg1 from: arg2 andSendTo: arg3  | tmp1 |  tmp1 := arg1 transformedBy: (arg3 transformedFrom: arg2 hand).  ^arg3 handleEvent: tmp1-=JUAMPI=-releaseKeyboardFocus: arg1  self keyboardFocus == arg1 ifTrue: [ self releaseKeyboardFocus ]-=JUAMPI=-computedBounds  | tmp1 tmp2 tmp3 |  tmp1 := treeMorph bounds.  tmp2 := treeMorph borderWidth.  tmp3 := self layoutInset asPoint y + self cellInset asPoint y.  ^tmp1 bottomLeft + (tmp2 @ (self computedHeight + tmp3) negated) corner: tmp1 bottomRight - ((tmp2 * 2) @ tmp3)-=JUAMPI=-newHueSelector: arg1 getHue: arg2 setHue: arg3 help: arg4  ^self theme newHueSelectorIn: self for: arg1 getHue: arg2 setHue: arg3 help: arg4-=JUAMPI=-nextPage: arg1  | tmp1 |  arg1 > self lastIndex ifFalse: [ ^self ].  self lastIndex < self nodeList size ifTrue: [ tmp1 := self nodeList copyFrom: 1 to: arg1.        self lastIndex: arg1.        treeMorph scroller removeAllMorphs.        treeMorph addSubmorphsFromNodeList: tmp1 previouslyExpanded: treeMorph currentlyExpanded ]-=JUAMPI=-isAdheringToRight  ^self edgeToAdhereTo == #right-=JUAMPI=-hasSelection  ^self selectedIndexes isNotEmpty-=JUAMPI=-generateKeyboardEvent: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp5 := arg1 second.  tmp5 = 0 ifTrue: [ tmp5 := Time millisecondClockValue ].  tmp4 := arg1 fourth.  tmp4 = EventKeyDown ifTrue: [ tmp3 := #keyDown.        lastKeyScanCode := arg1 third ].  tmp4 = EventKeyUp ifTrue: [ tmp3 := #keyUp ].  tmp4 = EventKeyChar ifTrue: [ tmp3 := #keystroke ].  tmp2 := arg1 fifth.  tmp1 := tmp2 bitShift: 3.  tmp7 := arg1 third.  tmp6 := arg1 sixth.  tmp3 = #keystroke ifTrue: [ combinedChar ifNil: [ | tmp9 |              tmp9 := Sensor peekEvent.              (tmp9 notNil and: [ tmp9 fourth = EventKeyDown ]) ifTrue: [ (CombinedChar isCompositionCharacter: tmp6) ifTrue: [ combinedChar := CombinedChar new.                          combinedChar simpleAdd: tmp6 asCharacter.                          (combinedChar combinesWith: tmp9 third asCharacter) ifTrue: [ ^nil ] ] ] ] ifNotNil: [ (combinedChar simpleAdd: tmp6 asCharacter) ifTrue: [ tmp6 := combinedChar combined charCode ].              combinedChar := nil ] ].  (tmp3 = #keystroke and: [ (tmp1 anyMask: 16) and: [ {Character arrowUp .               Character arrowDown} includes: tmp6 asCharacter ] ]) ifTrue: [ ^MouseWheelEvent fromCharacter: tmp6 asCharacter position: lastMouseEvent cursorPoint buttons: tmp1 hand: self stamp: tmp5 ].  self flag: #pharoFixMe.  (tmp6 notNil and: [ tmp6 > 255 ]) ifTrue: [ tmp7 := 0 ].  tmp8 := KeyboardEvent new setType: tmp3 buttons: tmp1 position: self position keyValue: tmp7 charCode: tmp6 hand: self stamp: tmp5.  tmp8 scanCode: lastKeyScanCode.  ^tmp8-=JUAMPI=-mouseLeave: arg1  ^self eventHandler ifNotNil: [ self eventHandler mouseLeave: arg1 fromMorph: self ]-=JUAMPI=-leftLayoutFrame  ^(0 @ 0 corner: 0 @ 1) asLayoutFrame     topOffset: -7;     bottomRightOffset: SystemWindow borderWidth @ (SystemWindow borderWidth - 26)-=JUAMPI=-selectMorph: arg1 multiple: arg2 clickedTheCheckBox: arg3  | tmp1 tmp2 |  arg3 ifFalse: [ self lastClickedMorph: arg1 ].  arg1 ifNil: [ self emptySelection.        ^nil ].  arg1 selected ifTrue: [ arg2 ifTrue: [ self removeFromSelection: arg1 ] ifFalse: [ tmp2 := self selectedMorphList size > 1.              tmp1 := arg1 path collect: [:arg4 |  arg4 complexContents ].              (self autoDeselection or: [ tmp2 ]) ifTrue: [ self emptySelection.                    tmp2 ifTrue: [ self addToSelection: arg1 ] ifFalse: [ tmp1 := nil ] ] ] ] ifFalse: [ arg2 ifFalse: [ self emptySelection ].        self addToSelection: arg1 clickedTheCheckBox: arg3.        tmp1 := arg1 path collect: [:arg4 |  arg4 complexContents ] ].  self selectionChanged.  ^tmp1-=JUAMPI=-takesKeyboardFocus  ^true-=JUAMPI=-releaseCachedState  self borderStyle releaseCachedState-=JUAMPI=-labelMorph  ^labelMorph-=JUAMPI=-drawDropHighlightOn: arg1  self highlightedForDrop ifTrue: [ arg1 frameRectangle: self fullBounds color: self dropHighlightColor ]-=JUAMPI=-item: arg1  item := arg1-=JUAMPI=-newOKButton  ^self newOKButtonFor: self-=JUAMPI=-shouldFlex  ^true-=JUAMPI=-layoutFrame: arg1  layoutFrame := arg1-=JUAMPI=-borderStyleToUse  ^self isRadioButton ifTrue: [ self radioBorderStyleToUse ] ifFalse: [ self checkboxBorderStyleToUse ]-=JUAMPI=-newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: true help: arg6-=JUAMPI=-adoptPaneColor: arg1  self color: arg1-=JUAMPI=-adjustBorderUponDeactivationWhenLabeless  | tmp1 |  (tmp1 := self valueOfProperty: #borderWidthWhenInactive) ifNotNil: [ self acquireBorderWidth: tmp1 ]-=JUAMPI=-enabled: arg1  arg1 = self enabled ifFalse: [ enabled := arg1.        self           adoptPaneColor: self paneColor;           changed ]-=JUAMPI=-balloonText  extension ifNil: [ ^nil ].  ^extension balloonText ifNotNil: [:arg1 |  arg1 asString withNoLineLongerThan: self theme settings maxBalloonHelpLineLength ]-=JUAMPI=-drawWithSelectionOn: arg1  arg1 line: self bottomLeft + (0 @ -1) to: self selectedTab bottomLeft width: 1 color: self borderColor.  arg1 line: self selectedTab bottomLeft to: self selectedTab bottomRight width: 1 color: self selectedColor.  arg1 line: self selectedTab bottomRight to: self bottomRight + (0 @ -1) width: 1 color: self borderColor-=JUAMPI=-setDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) rounded-=JUAMPI=-allowsKeymapping  ^self valueOfProperty: #allowsKeymapping ifAbsent: [ true ]-=JUAMPI=-originColumn: arg1 row: arg2  ^FTCellMorph new     color: (self colorFor: arg2);     addMorph: (self elementAt: arg2) origin name asMorph;     yourself-=JUAMPI=-paneColor  ^self paneColorOrNil ifNil: [ self color ]-=JUAMPI=-mouseUp: arg1  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: arg1 cursorPoint) ifFalse: [ arg1 hand showTemporaryCursor: nil ].  self class fastSplitterResize ifTrue: [ self updateFromEvent: arg1 ].  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUp-=JUAMPI=-buildVerticesFrom: arg1  ^state buildVerticesFrom: arg1-=JUAMPI=-scrollPane  ^scrollPane-=JUAMPI=-mouseOverBorderStyle  ^mouseOverBorderStyle ifNil: [ BorderStyle thinGray ]-=JUAMPI=-selectedLabel  ^selectedLabel-=JUAMPI=-canvas: arg1  -=JUAMPI=-useExtraSelection  ^self useFindReplaceSelection or: [ self useSecondarySelection ]-=JUAMPI=-themeChanged  self fillStyle: self normalFillStyle.  super themeChanged-=JUAMPI=-complexContents  ^complexContents-=JUAMPI=-addInterruptionButton  self isInterruptable ifFalse: [ ^self ].  self addMorphBack: (self iconNamed: #stopIcon) asMorph-=JUAMPI=-hand  ^source-=JUAMPI=-shouldDraw  ^super shouldDraw or: [ self class showSplitterHandles ]-=JUAMPI=-mouseEnterDragging: arg1  arg1 hand mouseFocus == owner ifTrue: [ owner selectItem: self event: arg1 ]-=JUAMPI=-bounds: arg1 in: arg2  owner ifNil: [ ^arg1 ].  ^(owner transformFrom: arg2) localBoundsToGlobal: arg1-=JUAMPI=-transformBy: arg1  position := arg1 globalPointToLocal: position-=JUAMPI=-getEnabledSelector  ^getEnabledSelector-=JUAMPI=-index: arg1  index := arg1-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: (splitsTopAndBottom ifTrue: [ #top ] ifFalse: [ #left ])-=JUAMPI=-asAthensCurvedPathOn: arg1  | tmp1 |  tmp1 := self computeCurvedSegmentCtrlPoints.  ^arg1 createPath: [:arg2 |  self vertices notEmpty ifTrue: [ | tmp2 |              tmp2 := tmp1 first.              arg2 absolute.              arg2 moveTo: tmp2 second.              tmp1 allButFirst do: [:arg3 |  arg2 curveVia: tmp2 third and: arg3 first to: arg3 second.                    tmp2 := arg3 ].              self isClosed ifTrue: [ arg2 curveVia: tmp2 third and: tmp1 first first to: tmp1 first second.                    arg2 close ] ].        arg2 ]-=JUAMPI=-bottomFraction  ^bottomFraction-=JUAMPI=-newHSVSelector: arg1 help: arg2  ^self theme newHSVSelectorIn: self color: arg1 help: arg2-=JUAMPI=-handlesKeyboard: arg1  ^true-=JUAMPI=-getLabelSelector: arg1  getLabelSelector := arg1.  self updateLabel-=JUAMPI=-hasProperty: arg1  extension ifNil: [ ^false ].  ^extension hasProperty: arg1-=JUAMPI=-intoWorldCount  ^intoWorldCount-=JUAMPI=-labelString  ^label ifNil: [ labelString ] ifNotNil: [ label contents asString ]-=JUAMPI=-getListItem: arg1  ^listSource getListRow: arg1-=JUAMPI=-addToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 argumentList: arg5  self addToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 enablementSelector: nil argumentList: arg5-=JUAMPI=-navigateWindowBackward  self previousWindow ifNotNil: [:arg1 |  arg1 isCollapsed ifTrue: [ arg1 collapseOrExpand ].        arg1 activate ]-=JUAMPI=-icon: arg1  icon := arg1-=JUAMPI=-adoptPaneColor: arg1  (arg1 notNil and: [ self trackPaneColor ]) ifTrue: [ self color: arg1 ].  super adoptPaneColor: arg1-=JUAMPI=-selectedObject  | tmp1 |  tmp1 := self halo.  tmp1 ifNil: [ ^nil ].  ^tmp1 target renderedMorph-=JUAMPI=-contents  ^text-=JUAMPI=-activeSubmenu: arg1  activeSubMenu ifNotNil: [ activeSubMenu delete ].  activeSubMenu := arg1.  arg1 ifNil: [ ^self ].  activeSubMenu selectItem: nil event: nil.  activeSubMenu borderColor: self borderColor.  activeSubMenu beSticky.  activeSubMenu resistsRemoval: true.  activeSubMenu removeMatchString-=JUAMPI=-setProperty: arg1 toValue: arg2  self assureOtherProperties at: arg1 put: arg2-=JUAMPI=-showFirstSelection  self hasSelection ifFalse: [ ^self ].  self moveShowIndexTo: self selectedIndex-=JUAMPI=-hasContents  ^self contents isEmpty not-=JUAMPI=-lastVertex  ^vertices last-=JUAMPI=-removeMorph: arg1  | tmp1 |  arg1 owner == self ifFalse: [ ^self ].  tmp1 := self world.  tmp1 ifNotNil: [ arg1 outOfWorld: tmp1.        self privateInvalidateMorph: arg1 ].  self privateRemove: arg1.  arg1 privateOwner: nil.  self removedMorph: arg1-=JUAMPI=-handlesMouseDown: arg1  ^true-=JUAMPI=-selectedPressedBorderStyle  ^self theme controlButtonSelectedPressedBorderStyleFor: self-=JUAMPI=-highlightSelection  selectedMorph ifNotNil: [ selectedMorph highlight ]-=JUAMPI=-max  ^(self sliderMorph ifNil: [ ^0 ]) max-=JUAMPI=-newTabSelectorMorph  ^TabSelectorMorph new     vResizing: #shrinkWrap;     hResizing: #spaceFill-=JUAMPI=-announceDate  | tmp1 |  tmp1 := ChoseDate of: self date from: self.  announcer ifNotNil: [ announcer announce: tmp1 ]-=JUAMPI=-setColor: arg1 toHandle: arg2  arg2 color: arg1.  self gradientHalo ifTrue: [ | tmp1 |        tmp1 := GradientFillStyle ramp: {(0.0 -> arg1 muchLighter) .               (1.0 -> arg1 darker)}.        tmp1 origin: arg2 topLeft.        tmp1 direction: arg2 extent.        arg2 fillStyle: tmp1 ]-=JUAMPI=-isCloseable  ^self mustNotClose not and: [ model ifNotNil: [ model okToChange ] ifNil: [ true ] ]-=JUAMPI=-selectLast  self table selectIndex: self table numberOfRows-=JUAMPI=-objectToPaste  ^Cursor wait showWhile: [ PasteBuffer veryDeepCopy ]-=JUAMPI=-halo  ^self primaryHand halo ifNotNil: [:arg1 |  arg1 target == self ifTrue: [ arg1 ] ]-=JUAMPI=-themeChanged  self     removeAllMorphs;     initializeSlider.  super themeChanged-=JUAMPI=-initialize  super initialize.  self cellInset: 7-=JUAMPI=-setValue: arg1  self value: arg1.  setValueSelector ifNotNil: [ ^model perform: setValueSelector with: value ]-=JUAMPI=-target  ^objectToView-=JUAMPI=-shadowPoint: arg1  self changed.  self shadowOffset: (arg1 - self center) // 5.  fullBounds ifNotNil: [ fullBounds := self privateFullBounds ].  self changed-=JUAMPI=-disable  self enabled: false-=JUAMPI=-athensDisplay: arg1 atRow: arg2 on: arg3  | tmp1 tmp2 tmp3 |  tmp3 := self drawBoundsForRow: arg2.  tmp1 := self colorForRow: arg2.  tmp2 := self backgroundColorForRow: arg2.  arg1 listRenderOn: arg3 asCanvasWrapper atRow: arg2 bounds: tmp3 color: tmp1 backgroundColor: tmp2 from: self.  arg2 = self mouseDownRow ifTrue: [ (arg3 setStrokePaint: tmp1)           width: 1;           dashes: {1} offset: 0.        arg3 drawShape: (self selectionFrameForRow: arg2) ]-=JUAMPI=-color: arg1  super color: arg1.  self setProperty: #basicColor toValue: arg1-=JUAMPI=-themeChanged  self onImage: (self isRadioButton ifTrue: [ self theme radioButtonMarkerForm ] ifFalse: [ self theme checkboxMarkerForm ]).  self adoptPaneColor: self paneColor.  super themeChanged-=JUAMPI=-separatorAfterARow: arg1  arg1 ifNil: [ ^false ].  self separatorBlockOrSelector ifNotNil: [:arg2 |  | tmp1 |        tmp1 := getListElementSelector ifNil: [ list at: arg1 ifAbsent: [ ^false ] ] ifNotNil: [ model perform: getListElementSelector with: arg1 ].        ^arg2 isBlock ifTrue: [ arg2 cull: tmp1 cull: arg1 ] ifFalse: [ arg2 isSymbol ifTrue: [ arg2 numArgs == 0 ifTrue: [ tmp1 perform: arg2 ] ifFalse: [ self model perform: arg2 withEnoughArguments: {tmp1 .                                 arg1} ] ] ifFalse: [ false ] ] ].  ^false-=JUAMPI=-selectLast  self table selectIndex: {self table numberOfRows .         self table numberOfColumns}-=JUAMPI=-scrollLeft: arg1  self scrollUp: arg1-=JUAMPI=-offColor  ^offColor-=JUAMPI=-scrollAbsolute: arg1  | tmp1 tmp2 |  tmp1 := self roomToMove.  bounds isWide ifTrue: [ tmp1 width = 0 ifTrue: [ ^self ] ] ifFalse: [ tmp1 height = 0 ifTrue: [ ^self ] ].  tmp2 := arg1 targetPoint adhereTo: tmp1.  self descending ifFalse: [ self setValue: (bounds isWide ifTrue: [ (tmp2 x - tmp1 left) asFloat / tmp1 width ] ifFalse: [ (tmp2 y - tmp1 top) asFloat / tmp1 height ]) ] ifTrue: [ self setValue: (bounds isWide ifTrue: [ (tmp1 right - tmp2 x) asFloat / tmp1 width ] ifFalse: [ (tmp1 bottom - tmp2 y) asFloat / tmp1 height ]) ]-=JUAMPI=-transform  ^transform-=JUAMPI=-filterNowWith: arg1  pattern := arg1.  self field setText: pattern.  self filterWith: pattern.  self filter-=JUAMPI=-oldScrollingIndex  ^oldScrollingIndex-=JUAMPI=-newContentMorph  self hsvaMorph: self newHSVAColorSelectorMorph.  ^self newRow: {(self newGroupbox: 'Color' translated forAll: {self hsvaMorph .               ((self newRow: {((self newLabelGroup: {('Selected color' translated -> self newColorPresenterMorph)}) vResizing: #shrinkWrap) .                     self newColorPickerButtonMorph}) cellPositioning: #leftCenter)}) .         ((self newGroupbox: 'Values' translated for: (self newLabelGroup: {('Red' translated -> (self newColorComponentFieldMorph: #red)) .                     ('Green' translated -> (self newColorComponentFieldMorph: #green)) .                     ('Blue' translated -> (self newColorComponentFieldMorph: #blue)) .                     ('Hue' translated -> (self newColorComponentFieldMorph: #hue)) .                     ('Saturation' translated -> (self newColorComponentFieldMorph: #saturation)) .                     ('Brightness' translated -> (self newColorComponentFieldMorph: #brightness)) .                     ('Alpha' translated -> (self newColorComponentFieldMorph: #alpha))})) hResizing: #shrinkWrap)}-=JUAMPI=-containsPoint: arg1  ^(lines at: (self lineIndexForPoint: arg1)) rectangle containsPoint: arg1-=JUAMPI=-removeOtherProperties  otherProperties := nil-=JUAMPI=-setMultipleSelection: arg1  arg1 ifTrue: [ self beMultipleSelection ] ifFalse: [ self beSingleSelection ]-=JUAMPI=-addColumn: arg1  self addColumn: arg1 afterIndex: self columns size-=JUAMPI=-selectionColor: arg1  selectionColor := arg1-=JUAMPI=-display: arg1  displayBlock := arg1-=JUAMPI=-isFullOnScreen  owner ifNil: [ ^true ].  self visible ifFalse: [ ^true ].  ^owner clearArea containsRect: self fullBounds-=JUAMPI=-offerWindowMenu  | tmp1 |  tmp1 := self buildWindowMenu.  model ifNotNil: [ model addModelItemsToWindowMenu: tmp1 ].  tmp1 popUpEvent: self currentEvent in: self world-=JUAMPI=-initialize  super initialize.  icon := ImageMorph new-=JUAMPI=-privateMoveBy: arg1  super privateMoveBy: arg1-=JUAMPI=-icon  ^icon-=JUAMPI=-addARowCentered: arg1 cellInset: arg2  ^(self addARow: arg1)     hResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #leftCenter;     cellInset: arg2-=JUAMPI=-menuStringBounds  | tmp1 |  tmp1 := bounds.  self hasIcon ifTrue: [ | tmp2 |        tmp2 := self iconForm.        tmp1 := tmp1 left: tmp1 left + tmp2 width + 2 ].  self hasMarker ifTrue: [ tmp1 := tmp1 left: tmp1 left + self submorphBounds width + 8 ].  ^tmp1 top: (tmp1 top + tmp1 bottom - self fontToUse height) // 2-=JUAMPI=-basicMoveShowIndexTo: arg1  showIndex := arg1-=JUAMPI=-tabs: arg1  toolbar tabs: arg1-=JUAMPI=-openModal: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self activeHand keyboardFocus.  tmp2 := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  tmp2 ifNil: [ tmp2 := self ].  tmp2 modalLockTo: arg1.  tmp1 := RealEstateAgent maximumUsableArea.  arg1 extent: arg1 initialExtent.  arg1 position = (0 @ 0) ifTrue: [ arg1 position: self activeHand position - (arg1 extent // 2) ].  arg1 bounds: (arg1 bounds translatedToBeWithin: tmp1).  [ | tmp4 |  tmp4 := arg1 openAsIs.  self activeHand mouseFocus: tmp4.  [ tmp4 world notNil ] whileTrue: [ tmp4 outermostWorldMorph doOneCycle ] ] ensure: [ tmp2 modalUnlockFrom: arg1.        self activeHand newKeyboardFocus: tmp3 ].  ^arg1-=JUAMPI=-modalUnlockFrom: arg1  arg1 removeProperty: #modalOwner.  self removeProperty: #modalChild.  closeBox ifNotNil: [:arg2 |  arg2 enabled: (self valueOfProperty: #preModalCloseEnabled ifAbsent: [ true ]) ].  self removeProperty: #preModalCloseEnabled.  self activate-=JUAMPI=-defaultBorderWidth  ^0-=JUAMPI=-passivate  super passivate.  self nonVisibleTabs do: [:arg1 |  arg1 passivate ]-=JUAMPI=-activeDisabledNotOverUpFillStyle: arg1  self stateMap atPath: #(active disabled notOver up) put: arg1.  self changed-=JUAMPI=-menuItems  ^submorphs select: [:arg1 |  arg1 isMenuItemMorph ]-=JUAMPI=-calendar: arg1  calendar := arg1-=JUAMPI=-updateWidth  self resize-=JUAMPI=-doubleClickSelector: arg1  doubleClickSelector := arg1-=JUAMPI=-apply: arg1  | tmp1 |  tmp1 := target bounds.  target bounds: (tmp1 origin corner: tmp1 corner + arg1)-=JUAMPI=-cellPositioning  ^#center-=JUAMPI=-newEditableDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: arg6 default: arg7 ghostText: arg8 getEnabled: arg9 useIndex: arg10 help: arg11  ^self theme newEditableDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: arg6 default: arg7 ghostText: arg8 getEnabled: arg9 useIndex: arg10 help: arg11-=JUAMPI=-collpasedButton  ^IconicButton new     target: self;     actionSelector: #expandAndRefresh;     arguments: {};     labelGraphic: self class unexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-=JUAMPI=-recipient  ^recipient-=JUAMPI=-newHueSelector: arg1 getHue: arg2 setHue: arg3 help: arg4  ^self theme newHueSelectorIn: self for: arg1 getHue: arg2 setHue: arg3 help: arg4-=JUAMPI=-trackDirectionArrow: arg1 with: arg2  arg1 hand obtainHalo: self.  arg2 setVertices: {directionArrowAnchor .         arg1 cursorPoint}.  self layoutChanged-=JUAMPI=-stateSelector: arg1  stateSelector := arg1-=JUAMPI=-newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 icon: arg5 getEnabled: arg6 help: arg7  ^self theme newListIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4 icon: arg5 getEnabled: arg6 help: arg7-=JUAMPI=-drawOn: arg1  | tmp1 |  tmp1 := self boundsForKeyText: self keyText font: self owner fontToUse.  self owner drawText: keyText on: arg1 in: tmp1 color: self color-=JUAMPI=-userString  ^String streamContents: [:arg1 |  1 to: self getListSize do: [:arg2 |  (self getListItem: arg2) submorphs detect: [:arg3 |  arg3 userString notNil ] ifFound: [:arg3 |  arg1 nextPutAll: arg3 userString ].              arg1 cr ] ]-=JUAMPI=-triggerOnMouseDown  ^triggerOnMouseDown-=JUAMPI=-currentNodelist  ^self nodeList-=JUAMPI=-newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7  ^self theme newDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7-=JUAMPI=-setColorSelector: arg1  setColorSelector := arg1-=JUAMPI=-canDrawBorder: arg1  ^arg1 style == #simple-=JUAMPI=-setLastCharacter: arg1  | tmp1 tmp2 |  tmp1 := arg1 asCharacter.  (tmp2 := self getCharacters) size > 0 ifFalse: [ self newContents: (String with: tmp1) ] ifTrue: [ tmp2 last = tmp1 ifFalse: [ self newContents: (String streamContents: [:arg2 |  arg2 nextPutAll: (tmp2 copyFrom: 1 to: tmp2 size - 1).                          arg2 nextPut: tmp1 ]) ] ]-=JUAMPI=-bottomRightColor  ^self color-=JUAMPI=-doneWithEdits  hasFocus := false-=JUAMPI=-chooseFileName: arg1 extensions: arg2 path: arg3 preview: arg4  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4-=JUAMPI=-chooseServiceFrom: arg1  arg1 size = 1 ifTrue: [ ^arg1 anyOne ].  ^UIManager default chooseFrom: (arg1 collect: [:arg2 |  arg2 label ]) values: arg1-=JUAMPI=-medium  ^27-=JUAMPI=-on: arg1 list: arg2 selected: arg3 changeSelected: arg4 menu: arg5 keystroke: arg6  self model: arg1.  getListSelector := arg2.  getIndexSelector := arg3.  setIndexSelector := arg4.  getMenuSelector := arg5.  keystrokeActionSelector := arg6.  self autoDeselect: true.  self borderWidth: 1.  self updateList.  self selectionIndex: self getCurrentSelectionIndex.  self initForKeystrokes-=JUAMPI=-selectedFillStyle  ^self theme buttonSelectedFillStyleFor: self-=JUAMPI=-setUp  super setUp.  prototypes     add: (TextAnchor new anchoredMorph: Morph new initialize);     add: (TextAnchor new anchoredMorph: EllipseMorph new initialize)-=JUAMPI=-font: arg1  font := arg1-=JUAMPI=-beRowSelection  self selectionModeStrategy: (FTRowSelectionModeStrategy table: self)-=JUAMPI=-roomToMove  ^self totalSliderArea insetBy: (0 @ 0 extent: self sliderExtent)-=JUAMPI=-treeLineWidth  ^treeLineWidth ifNil: [ treeLineWidth := self theme treeLineWidth ]-=JUAMPI=-fontName: arg1 pointSize: arg2  | tmp1 |  tmp1 := ((TextStyle named: arg1 asSymbol) ifNil: [ TextStyle default ]) copy.  tmp1 ifNil: [ self error: 'font ' , arg1 , ' not found.' ].  textStyle := tmp1.  text addAttribute: (TextFontChange fontNumber: (tmp1 fontIndexOfPointSize: arg2)).  paragraph ifNotNil: [ paragraph textStyle: tmp1 ]-=JUAMPI=-currentNodelist  ^self pager ifNil: [ super nodeList ] ifNotNil: [ self pager currentNodelist ]-=JUAMPI=-hasHighlighted  ^self highlightedIndexes notEmpty-=JUAMPI=-adoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self assureExtension.  extension fillStyle ifNil: [ self color: arg1 ].  self borderStyle baseColor: arg1 darker-=JUAMPI=-recordDamagedRect: arg1  damageRecorder ifNotNil: [ damageRecorder recordInvalidRect: arg1 truncated ]-=JUAMPI=-initialize  super initialize.  self     style: #inset;     trackPaneColor: true-=JUAMPI=-showSelectionFeedback  ^showSelectionFeedback-=JUAMPI=-computeFramedColors  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self color asColor.  tmp2 := Color white.  tmp3 := Color black.  tmp4 := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  tmp4 := tmp4 asInteger.  tmp4 = 1 ifTrue: [ ^{(tmp1 mixed: 0.5 with: tmp2) .         (tmp1 mixed: 0.5 with: tmp3)} ].  tmp6 := Array new: tmp4.  tmp5 := tmp4 // 2.  0 to: tmp5 - 1 do: [:arg1 |  tmp7 := 0.5 + (arg1 asFloat / tmp5 * 0.5).        tmp6 at: arg1 + 1 put: (tmp1 mixed: tmp7 with: tmp2).        tmp6 at: tmp4 - arg1 put: (tmp1 mixed: tmp7 with: tmp3) ].  tmp4 odd ifTrue: [ tmp6 at: tmp5 + 1 put: tmp1 ].  ^tmp6 , tmp6-=JUAMPI=-newAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 font: arg5 help: arg6  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 font: arg5 help: arg6-=JUAMPI=-newLeftButton  ^(ControlButtonMorph on: self getState: nil action: #scrollTabsLeft label: #leftButtonLabel)     getEnabledSelector: #leftButtonEnabled;     hResizing: #rigid;     vResizing: #spaceFill;     cornerStyle: #square;     extent: self controlButtonWidth asPoint-=JUAMPI=-rowColorForOdd: arg1  rowColors at: 2 put: arg1-=JUAMPI=-hasChildren  ^(dataSource childrenBlock value: item) isNotEmpty-=JUAMPI=-initWithContents: arg1 prior: arg2 forList: arg3 indentLevel: arg4  container := arg3.  self cellInset: container resizerWidth @ 0.  complexContents := arg1.  complexContents addDependent: self.  isExpanded := complexContents isExpanded.  nextSibling := firstChild := nil.  arg2 ifNotNil: [ arg2 nextSibling: self ].  indentLevel := arg4.  self setBalloonText: complexContents helpText.  self initRow.  complexContents selected ifTrue: [ self selectedWithoutNotifyingComplexContents: true ]-=JUAMPI=-selectionChanged  self requestView: (MorphTreeSelectionChanged new selection: self selection)-=JUAMPI=-handlerForBlueButtonDown: arg1  self wantsHaloFromClick ifFalse: [ ^nil ].  self class cycleHalosBothDirections ifTrue: [ arg1 handler ifNil: [ ^self ].        (arg1 handler isKindOf: PasteUpMorph) ifTrue: [ ^self ] ].  arg1 shiftPressed ifFalse: [ ^nil ] ifTrue: [ ^self ]-=JUAMPI=-resizeFromMenu  self resizeMorph: ActiveEvent-=JUAMPI=-handleStep: arg1  ^self dispatchDefault: arg1 with: morph-=JUAMPI=-separatorSize: arg1  separatorSize := arg1-=JUAMPI=-yellowButtonActivity: arg1  (self getMenu: arg1) ifNotNil: [:arg2 |  arg2 setInvokingView: self.        arg2 popUpEvent: self activeHand lastEvent in: self world.        ^true ].  ^false-=JUAMPI=-translateBy: arg1  position := position + arg1-=JUAMPI=-itemsForTest  ^rootClass allSubclasses-=JUAMPI=-minExtentFrom: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 x + leftOffset - rightOffset.  tmp2 := arg1 y + topOffset - bottomOffset.  tmp3 := rightFraction - leftFraction.  tmp4 := bottomFraction - topFraction.  tmp1 := tmp3 = 0 ifTrue: [ 0 ] ifFalse: [ tmp1 / tmp3 ].  tmp2 := tmp4 = 0 ifTrue: [ 0 ] ifFalse: [ tmp2 / tmp4 ].  ^tmp1 truncated @ tmp2 truncated-=JUAMPI=-maxNodeWidth  ^maxNodeWidth ifNil: [ maxNodeWidth := 0 ]-=JUAMPI=-themedFillStyle  ^self theme buttonNormalFillStyleFor: self-=JUAMPI=-addToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 enablementSelector: arg5 argumentList: arg6  | tmp1 |  tmp1 := ToggleMenuItemMorph new     contents: arg1;     target: arg2;     selector: arg3;     arguments: arg6;     getStateSelector: arg4;     enablementSelector: arg5.  ^self addMenuItem: tmp1-=JUAMPI=-configureForUnembedding  labelArea owner ifNil: [ self           makeBordered;           initializeLabelArea;           themeChanged;           addGrips ]-=JUAMPI=-hasItems  ^submorphs anySatisfy: [:arg1 |  arg1 isMenuItemMorph ]-=JUAMPI=-newRow  ^self theme newRowIn: self for: #()-=JUAMPI=-autoAccept: arg1  autoAccept := arg1-=JUAMPI=-multipleSelection  ^multipleSelection ifNil: [ multipleSelection := self defaultMultipleSelectionValue ]-=JUAMPI=-selectIndexes: arg1 previous: arg2  self table selectIndexes: (((arg2 includes: arg1) ifTrue: [ arg2 copyWithout: arg1 ] ifFalse: [ arg2 ]) copyWithFirst: arg1)-=JUAMPI=-resizeToFit  ^self vResizing == #shrinkWrap-=JUAMPI=-adoptPaneColor: arg1  super adoptPaneColor: arg1.  scrollBar adoptPaneColor: arg1.  hScrollBar adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self borderWidth > 0 ifTrue: [ self borderStyle: self borderStyleToUse ]-=JUAMPI=-passengerAt: arg1  ^self elementAt: arg1-=JUAMPI=-removeCollapseBox  collapseBox ifNotNil: [ collapseBox delete.        collapseBox := nil ]-=JUAMPI=-adjustLineIndicesBy: arg1  firstCharacterIndex := firstCharacterIndex + arg1.  lines do: [:arg2 |  arg2 slide: arg1 ]-=JUAMPI=-setType: arg1 buttons: arg2 position: arg3 keyValue: arg4 hand: arg5 stamp: arg6  type := arg1.  buttons := arg2.  position := arg3.  keyValue := arg4.  source := arg5.  wasHandled := false.  timeStamp := arg6-=JUAMPI=-handlesMouseOver: arg1  ^true-=JUAMPI=-model: arg1  self model ifNotNil: [ self model announcer unsubscribe: self ].  super model: arg1.  self registerRequestHandlers-=JUAMPI=-asSpecAdapter  ^MorphicGenericAdapter morph: self-=JUAMPI=-toggleSelected  self takeKeyboardFocus.  self enabled ifFalse: [ ^self ].  self model ifNil: [ ^self ].  (self setStateSelector ifNil: [ ^self ]) numArgs = 0 ifTrue: [ self model perform: self setStateSelector ].  self setStateSelector numArgs = 1 ifTrue: [ self model perform: self setStateSelector with: self isSelected not ].  self updateSelection-=JUAMPI=-handleMouseOver: arg1  ^self dispatchDefault: arg1 with: morph-=JUAMPI=-cellPositioning  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #center ] ifNotNil: [ tmp1 cellPositioning ]-=JUAMPI=-menu: arg1 shifted: arg2  super menu: arg1 shifted: arg2.  arg1 addLine.  self selectedNode ifNotNil: [:arg3 |  arg3 menu: arg1 shifted: arg2 ].  ^arg1-=JUAMPI=-balloonHelpTextForHandle: arg1  (arg1 eventHandler mouseSelectorsInclude: #doRecolor:with:) ifTrue: [ ^'Change color' ].  (arg1 eventHandler mouseSelectorsInclude: #mouseDownInDimissHandle:with:) ifTrue: [ ^'Remove from screen' translated ].  #(#(#addFullHandles 'More halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#trackCenterOfRotation:with: 'Set center of rotation')) do: [:arg2 |  (arg1 eventHandler mouseSelectorsInclude: arg2 first) ifTrue: [ ^arg2 last ] ].  ^'unknown halo handle' translated-=JUAMPI=-initializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigation.  arg1 attachCategory: #TabMorphsNavigation-=JUAMPI=-collapsedFrame  ^collapsedFrame-=JUAMPI=-subMenuSelector  ^subMenuSelector-=JUAMPI=-show: arg1 from: arg2 to: arg3  | tmp1 |  self flag: #pharoFixMe.  self openInWorld.  tmp1 := self addItemShowing: arg1 from: arg2 to: arg3.  self     refresh;     reposition.  ^tmp1-=JUAMPI=-resetPotentialDropMorph  potentialDropMorph ifNotNil: [ potentialDropMorph resetHighlightForDrop.        potentialDropMorph := nil ]-=JUAMPI=-wrapFlag: arg1  arg1 == wrapFlag ifTrue: [ ^self ].  wrapFlag := arg1.  self composeToBounds-=JUAMPI=-secondarySelectionColor  ^self theme secondarySelectionColor-=JUAMPI=-seeClassSide  -=JUAMPI=-addNavigationPane: arg1  pager := arg1.  self addMorph: pager.  pager buildPanel.  self updatePager.  self changed-=JUAMPI=-icon: arg1  self dataSource icon: arg1-=JUAMPI=-parent: arg1  parent := arg1-=JUAMPI=-popUpForHand: arg1 in: arg2  | tmp1 |  tmp1 := arg1 position truncated.  ^self popUpAt: tmp1 forHand: arg1 in: arg2-=JUAMPI=-fromArray: arg1  | tmp1 |  tmp1 := arg1 readStream.  #(leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset:) do: [:arg2 |  tmp1 next ifNil: [ ^self ] ifNotNil: [:arg3 |  self perform: arg2 with: arg3 ] ]-=JUAMPI=-doFastWindowReframe: arg1  (FastDraggingFrameMorph forResizing: self fromLocation: arg1) openInWorld-=JUAMPI=-baseColor  ^self theme autoMenuColor ifTrue: [ owner color twiceDarker ] ifFalse: [ self theme currentSettings flatMenu ifFalse: [ owner color ] ifTrue: [ owner color twiceDarker ] ]-=JUAMPI=-initialize  super initialize.  self     changeProportionalLayout;     bounds: self currentWorld clearArea;     beSticky-=JUAMPI=-computeLength  | tmp1 tmp2 tmp3 |  tmp2 := tabs size.  tmp2 isZero ifTrue: [ ^0 ].  tmp1 := self width - self extraSpace + ((tmp2 - 1) * self overlap).  tmp3 := tmp1 / tmp2.  tmp3 := tmp3 min: 150 * self displayScaleFactor.  tmp3 := tmp3 max: 33 * self displayScaleFactor.  ^tmp3-=JUAMPI=-newPluggableDialogWindow: arg1 for: arg2  ^self theme newPluggableDialogWindowIn: self title: arg1 for: arg2-=JUAMPI=-iconFor: arg1  ^(self elementAt: arg1) actionOn: self-=JUAMPI=-fileNames  ^fileNames-=JUAMPI=-initDraggedMorph  draggedMorph ifNotNil: [ ^self ].  draggedMorph := self passenger asDraggableMorph.  self addMorphBack: draggedMorph.  self updateCopyIcon.  self     changed;     fullBounds-=JUAMPI=-useSortedTabsBy: arg1  toolbar useSortedTabsBy: arg1-=JUAMPI=-eventListeners  ^eventListeners-=JUAMPI=-actualViewee  | tmp1 tmp2 |  tmp1 := self morphToView ifNil: [ ^nil ].  tmp1 isInWorld ifFalse: [ ^nil ].  tmp2 := viewSelector ifNil: [ tmp1 ] ifNotNil: [ objectToView perform: viewSelector ].  tmp2 = 0 ifTrue: [ ^nil ].  tmp2 ifNil: [ tmp2 := objectToView ].  (tmp2 isMorph and: [ tmp2 isFlexMorph and: [ tmp2 submorphs size = 1 ] ]) ifTrue: [ tmp2 := tmp2 firstSubmorph ].  ^tmp2-=JUAMPI=-popUpAdjacentTo: arg1 forHand: arg2 from: arg3  | tmp1 tmp2 |  arg2 world startSteppingSubmorphsOf: self.  popUpOwner := arg3.  self fullBounds.  self updateColor.  tmp2 := selectedItem ifNil: [ self items ifEmpty: [ 0 @ 0 ] ifNotEmpty: [:arg4 |  arg4 first position - self position ] ] ifNotNil: [ selectedItem position - self position ].  tmp1 := [:arg5 :arg6 |  | tmp3 |  self position: arg5 - tmp2.  tmp3 := self fullBoundsInWorld amountToTranslateWithin: arg3 worldBounds.  (tmp3 x = 0 or: [ arg6 ]) ifTrue: [ tmp3 = (0 @ 0) ifFalse: [ self position: self position + tmp3 ].        arg3 world addMorphFront: self.        ^self ] ].  tmp1     value: arg1 first value: false;     value: arg1 last - (self width @ 0) value: false;     value: arg1 first value: true-=JUAMPI=-modalLockTo: arg1  self lock-=JUAMPI=-displaySelectionBarOnAthensCanvas: arg1  | tmp1 tmp2 |  selectionStart ifNil: [ ^self ].  selectionStop ifNil: [ ^self ].  tmp1 := arg1 clipRect.  selectionStart textLine = selectionStop textLine ifFalse: [ ^self ].  tmp2 := selectionStart textLine.  arg1 setPaint: self selectionBarColor.  arg1 drawShape: (tmp1 left @ tmp2 top corner: tmp1 right @ tmp2 bottom)-=JUAMPI=-hResizeScrollbar  | tmp1 |  tmp1 := self innerBounds.  tmp1 := tmp1 top: tmp1 bottom - self scrollBarThickness.  self vScrollbarShowing ifTrue: [ tmp1 := tmp1 right: tmp1 right - self scrollBarThickness ].  self hScrollbar bounds: tmp1-=JUAMPI=-initializeLabel: arg1 start: arg2 end: arg3  lock := Semaphore forMutualExclusion.  hasResult := false.  lastRefresh := 0.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #center;     cellInset: 5;     listCentering: #center;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap.  labelMorph := StringMorph contents: arg1 font: StandardFonts windowTitleFont.  self addMorphBack: labelMorph.  bar := ProgressBarMorph from: arg2 to: arg3.  self addMorphBack: bar-=JUAMPI=-withHLines: arg1  withHLines := arg1-=JUAMPI=-themeChanged  super themeChanged.  tabs do: #themeChanged-=JUAMPI=-withText: arg1 label: arg2  self title: arg2.  self addMorph: (RubScrolledTextMorph new           setText: arg1 asString;           yourself) fullFrame: LayoutFrame identity.  self themeChanged-=JUAMPI=-invokeModal  ^self invokeModal: self menuKeyboardControl-=JUAMPI=-valueParameter: arg1  valueParameter := arg1-=JUAMPI=-leftMarginForAlignment: arg1  arg1 = RightFlush ifTrue: [ ^self left + paddingWidth ].  arg1 = Centered ifTrue: [ ^self left + (paddingWidth // 2) ].  ^self left-=JUAMPI=-minWidth  ^self minimumExtent x max: super minWidth-=JUAMPI=-fillStyle: arg1  fillStyle := arg1-=JUAMPI=-deny: arg1 title: arg2  ^self theme denyIn: self text: arg1 title: arg2-=JUAMPI=-wantsRoundedCorners  ^color isTransparent not and: [ owner wantsRoundedCorners ]-=JUAMPI=-usableArea  ^self viewBox-=JUAMPI=-minHeight  | tmp1 tmp2 tmp3 |  tmp1 := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  tmp2 := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  tmp3 := tmp1 ifTrue: [ tmp2 ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness ] ] ifFalse: [ tmp2 ifTrue: [ self scrollBarThickness * 3 ] ifFalse: [ self scrollBarThickness * 4 + 2 ] ].  ^tmp3 max: super minHeight-=JUAMPI=-disabledBorderStyle  ^self theme buttonDisabledBorderStyleFor: self-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: #left-=JUAMPI=-addPaneVSplitters  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := paneMorphs reject: [:arg1 |  arg1 layoutFrame rightFraction = 1 or: [ arg1 layoutFrame rightFraction = 0 ] ].  [ tmp1 notEmpty ] whileTrue: [ tmp2 := tmp1 first layoutFrame rightFraction.        tmp3 := tmp1 select: [:arg1 |  arg1 layoutFrame rightFraction = tmp2 ].        tmp4 := paneMorphs select: [:arg1 |  arg1 layoutFrame leftFraction = tmp2 and: [ arg1 layoutFrame rightFraction ~= tmp2 ] ].        tmp1 := tmp1 copyWithoutAll: (self addPaneVSplitterBetween: tmp3 and: tmp4) ]-=JUAMPI=-world  ^owner ifNotNil: [ owner world ]-=JUAMPI=-removeFlexShell  self isFlexed ifTrue: [ self owner removeFlexShell ]-=JUAMPI=-activateSubmenu: arg1  subMenu ifNil: [ ^false ].  (subMenu fullContainsPoint: arg1 position) ifFalse: [ ^false ].  subMenu activate: arg1.  self removeAlarm: #deselectTimeOut:.  ^true-=JUAMPI=-exposedColumnsRange: arg1  ^self startColumnIndex isZero ifTrue: [ 1 to: self table numberOfColumns ] ifFalse: [ (1 to: arg1 size) select: [:arg2 |  (arg1 at: arg2) > 0 ] ]-=JUAMPI=-updateOrderedTasksFrom: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self orderedTasks do: [:arg2 |  arg1 detect: [:arg3 |  arg3 morph = arg2 morph ] ifFound: [:arg4 |  arg1 remove: arg4 ] ifNone: [ tmp1 add: arg2 ] ].  (tmp1 isEmpty and: [ arg1 isEmpty ]) ifTrue: [ ^self ].  self orderedTasks: (self orderedTasks           removeAll: tmp1;           addAll: arg1;           yourself)-=JUAMPI=-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-=JUAMPI=-scrollValue  ^0 @ self verticalScrollBar value-=JUAMPI=-addHandlesTo: arg1 box: arg2  | tmp1 |  arg1 haloBox: arg2.  tmp1 := #(addDismissHandle: addMenuHandle: addGrabHandle: addDragHandle: addDupHandle: addHelpHandle: addGrowHandle: addFontSizeHandle: addFontStyleHandle: addFontEmphHandle: addRecolorHandle:).  HaloMorph currentHaloSpecifications do: [:arg3 |  (tmp1 includes: arg3 addHandleSelector) ifTrue: [ arg1 perform: arg3 addHandleSelector with: arg3 ] ].  arg1 innerTarget addOptionalHandlesTo: arg1 box: arg2-=JUAMPI=-releaseCachedState  colors := nil.  lineStyles := nil-=JUAMPI=-keyUp: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #keyUp from: arg2-=JUAMPI=-filter  self subclassResponsibility-=JUAMPI=-addMorph: arg1 fullFrame: arg2  arg1 layoutFrame: arg2 asLayoutFrame.  arg1     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorph: arg1-=JUAMPI=-containsPoint: arg1  ^target ifNil: [ super containsPoint: arg1 ] ifNotNil: [ false ]-=JUAMPI=-newGroupbox: arg1 forAll: arg2  ^self theme newGroupboxIn: self label: arg1 forAll: arg2-=JUAMPI=-pressedFillStyle  ^self theme morphTreeSplitterPressedFillStyleFor: self-=JUAMPI=-setRotationCenterFrom: arg1  self setProperty: #referencePosition toValue: arg1-=JUAMPI=-eventListeners: arg1  eventListeners := arg1-=JUAMPI=-actionSelector: arg1  (nil = arg1 or: [ 'nil' = arg1 or: [ arg1 isEmpty ] ]) ifTrue: [ ^actionSelector := nil ].  actionSelector := arg1 asSymbol-=JUAMPI=-changeMaxCellSize: arg1  | tmp1 |  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  self maxCellSize: (arg2 - arg1 cursorPoint) asIntegerPoint ].  arg1 hand attachMorph: tmp1.  tmp1 startStepping-=JUAMPI=-clyAddEmphasis: arg1  self emphasis: (emphasis bitOr: arg1 emphasisCode)-=JUAMPI=-initializeShortcuts: arg1  arg1 attachCategory: #MorphFocusCtrlNavigation-=JUAMPI=-findReplaceDialog  ^EditorFindReplaceDialogWindow singleton-=JUAMPI=-veryDeepCopyWith: arg1  ^self-=JUAMPI=-newSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8-=JUAMPI=-animateRestore  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self bounds.  tmp2 := self unexpandedFrame.  tmp4 := self theme numberOfStepsForAnimations.  tmp3 := ((tmp4 - 1) / tmp4 to: 0 by: -1 / tmp4) collect: [:arg1 |  tmp2 interpolateTo: tmp1 at: ((20 raisedTo: arg1) - 1) / 19 ].  self fastAnimateRectangles: tmp3-=JUAMPI=-asAthensShapeOn: arg1  | tmp1 tmp2 |  self bounds area > 0 ifFalse: [ ^self ].  tmp1 := self bounds width / 2 asFloat.  tmp2 := self bounds height / 2 asFloat.  ^arg1 createPath: [:arg2 |  arg2           absolute;           moveTo: self bounds center;           relative;           moveTo: tmp1 negated @ 0;           curveVia: 0 @ (tmp2 negated * 0.55) and: (0.45 * tmp1) @ tmp2 negated to: tmp1 @ tmp2 negated;           curveVia: (tmp1 * 0.55) @ 0 and: tmp1 @ (0.45 * tmp2) to: tmp1 @ tmp2;           curveVia: 0 @ (tmp2 * 0.55) and: (0.45 * tmp1 negated) @ tmp2 to: tmp1 negated @ tmp2;           curveVia: (tmp1 negated * 0.55) @ 0 and: tmp1 negated @ (tmp2 negated * 0.45) to: tmp1 negated @ tmp2 negated ]-=JUAMPI=-nextCell  ^nextCell-=JUAMPI=-veryDeepInner: arg1  super veryDeepInner: arg1.  activatorDockingBar := activatorDockingBar-=JUAMPI=-chooseForSaveFileReference: arg1 extensions: arg2 path: arg3 preview: arg4  ^self theme chooseForSaveFileReferenceIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4-=JUAMPI=-initialize  expanded := false.  depth := 0.  children := #()-=JUAMPI=-topRight: arg1  self position: (arg1 x - bounds width) @ arg1 y-=JUAMPI=-alignBottomEdges  | tmp1 |  tmp1 := (selectedItems collect: [:arg1 |  arg1 bottom ]) max.  selectedItems do: [:arg1 |  arg1 bottom: tmp1 ].  self changed-=JUAMPI=-treeRenderOn: arg1 bounds: arg2 color: arg3 font: arg4 from: arg5  self bounds: arg2.  arg5 addMorphBack: self-=JUAMPI=-string  ^string-=JUAMPI=-setColorSelector  ^setColorSelector-=JUAMPI=-originalCenter: arg1  originalCenter := arg1-=JUAMPI=-selectedWithoutNotifyingComplexContents: arg1  arg1 ifFalse: [ ^self ].  container listManager silentlySetSelectedMorph: self.  selected := arg1-=JUAMPI=-undoRedoExchange: arg1 with: arg2  self handleEdit: [ self editor undoRedoExchange: arg1 with: arg2 ]-=JUAMPI=-defaultBorderWidth  ^self theme borderWidth-=JUAMPI=-navigationKey: arg1  self isMultipleSelection ifTrue: [ | tmp1 |        tmp1 := arg1 keyString.        tmp1 = '<Cmd-a>' ifTrue: [ self selectAll.              ^true ].        tmp1 = '<Cmd-A>' ifTrue: [ self deselectAll.              ^true ] ].  ^super navigationKey: arg1-=JUAMPI=-asMorph  ^self-=JUAMPI=-isUp  ^direction = Character arrowUp-=JUAMPI=-mouseUp: arg1  self storeValue: nil.  super mouseUp: arg1-=JUAMPI=-isMenuMorph  ^false-=JUAMPI=-testMouseEnterEventIsNotDuplicated  | tmp1 tmp2 tmp3 |  tmp1 := MockObjectForEventTests new.  [ tmp2 := tmp1 stringMorph openInWindow.  tmp3 := MouseButtonEvent new setType: nil position: tmp1 stringMorph center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  self assert: tmp1 counter equals: 0.  tmp1 stringMorph handleMouseEnter: tmp3.  self assert: tmp1 counter equals: 1 ] ensure: [ tmp2 ifNotNil: #close ]-=JUAMPI=-mouseEnter: arg1  self color: (selectionColor isTransparent ifTrue: [ self mouseOverColor ] ifFalse: [ self mouseOverColor mixed: 0.5 with: selectionColor ])-=JUAMPI=-mouseUpInSlider: arg1  sliderShadow hide.  (slider containsPoint: arg1 position) ifTrue: [ slider           fillStyle: self mouseOverThumbFillStyle;           borderStyle: self mouseOverThumbBorderStyle ] ifFalse: [ self mouseLeaveThumb: arg1 ].  slider changed-=JUAMPI=-on: arg1 getState: arg2 action: arg3 label: arg4 menu: arg5  self on: arg1 getState: arg2 action: arg3 label: arg4 icon: nil menu: arg5-=JUAMPI=-indentationLevel: arg1  indent := arg1-=JUAMPI=-lastKeystrokeTime  ^lastKeystrokeTime-=JUAMPI=-paneColor  ^self paneColorOrNil ifNil: [ self owner ifNil: [ Color transparent ] ifNotNil: [ self owner color ] ]-=JUAMPI=-rowHeight  ^rowHeight ifNil: [ rowHeight := self class defaultRowHeight ]-=JUAMPI=-selectableIndexAfter: arg1  ^self subclassResponsibility-=JUAMPI=-lastSelection: arg1  lastSelection := arg1-=JUAMPI=-drawOnAthensCanvas: arg1  | tmp1 tmp2 |  self bounds area > 0 ifFalse: [ ^self ].  tmp1 := self borderStyle.  tmp2 := self asAthensShapeOn: arg1.  arg1 setPaint: self fillStyle.  arg1 setShape: tmp2.  arg1 draw.  (arg1 setStrokePaint: tmp1 color) width: tmp1 width.  arg1 draw-=JUAMPI=-orientation  ^orientation-=JUAMPI=-selectToMe  self triggerEvent: #tabSelectTo with: self-=JUAMPI=-bottomArrow  ^BottomArrow-=JUAMPI=-buildPanel  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  self removeAllMorphs.  pageSize ifNil: [ ^self ].  self nodeList ifNil: [ ^self ].  tmp1 := OrderedCollection new.  self nodeList size > pageSize ifTrue: [ tmp2 := self buttonLabel: self class smallToLeftEndIcon actionSelector: #currentPage: arguments: {1} getEnabled: #notOnFirstPage help: 'First page'.        tmp1 add: tmp2.        tmp3 := self buttonLabel: self class smallToLeftIcon actionSelector: #previousPage arguments: {} getEnabled: #notOnFirstPage help: 'Previous page'.        tmp1 add: tmp3.        tmp4 := self textEntryLabel: '' get: #currentPageToString set: #currentPageInput: help: 'Index of page to view' translated class: String.        tmp4 hResizing: #rigid.        tmp4 width: (self preferedFont widthOfString: '1000000').        tmp1 add: tmp4.        tmp1 add: (self buttonLabel: self class smallDiezeIcon actionSelector: #choosePage arguments: {} getEnabled: nil help: 'Choose page').        tmp5 := self buttonLabel: self class smallToRightIcon actionSelector: #nextPage arguments: {} getEnabled: #notOnLastPage help: 'Next page'.        tmp1 add: tmp5.        tmp6 := self buttonLabel: self class smallToRightEndIcon actionSelector: #currentPage: arguments: {self lastPage} getEnabled: #notOnLastPage help: 'Last page'.        tmp1 add: tmp6.        tmp1 add: (self spacer: 10) ].  tmp1 add: (LabelMorph contents: 'Page size: ' font: self preferedFont).  tmp7 := self textEntryLabel: 'Page size' get: #pageSizeToString set: #pageSizeFromString: help: 'Change the page size or the number of pages if the input begins with "/"' translated class: String.  tmp7 hResizing: #rigid.  tmp7 width: (self preferedFont widthOfString: '1000000').  tmp1 add: tmp7.  self withSearch ifTrue: [ tmp8 := self textEntryLabel: '' get: #pageSearchText set: #pageSearchText: help: 'Enter a text correspondig to your search' translated class: String.        tmp8 ghostText: 'Searched text'.        tmp1 add: tmp8 ].  self addAllMorphs: tmp1.  self updateContents-=JUAMPI=-testSelectableIndexAbove  self subclassResponsibility-=JUAMPI=-basicSelectedColor: arg1  selectedColor := arg1.  self     changed: #selectedColor;     changed: #red;     changed: #green;     changed: #blue;     changed: #hue;     changed: #saturation;     changed: #brightness;     changed: #alpha.  self announcer announce: (ColorChanged to: selectedColor)-=JUAMPI=-autoAccept: arg1  autoAccept := arg1-=JUAMPI=-newAlphaImage: arg1 help: arg2  ^self theme newAlphaImageIn: self image: arg1 help: arg2-=JUAMPI=-proceed: arg1  ^self proceed: arg1 title: 'Proceed' translated-=JUAMPI=-extent: arg1  | tmp1 |  tmp1 := self extent.  super extent: arg1.  self extent = tmp1 ifTrue: [ ^self ].  self updateColor-=JUAMPI=-findDeeplyA: arg1  ^(self allMorphs copyWithout: self) detect: [:arg2 |  arg2 isKindOf: arg1 ] ifNone: [ nil ]-=JUAMPI=-setStrategy  table beCellSelection-=JUAMPI=-indentingItemClass  ^LazyMorphTreeNodeMorph-=JUAMPI=-left  ^textMorph owner left-=JUAMPI=-color: arg1  super color: arg1 beOpaque.  self fillStyle: self defaultFillStyle-=JUAMPI=-drawOn: arg1  | tmp1 |  tmp1 := Time millisecondClockValue.  self drawMeOn: arg1.  drawTime := Time millisecondClockValue - tmp1.  drawTime < 0 ifTrue: [ drawTime := nil ]-=JUAMPI=-hasFocus  ^hasFocus ifNil: [ false ]-=JUAMPI=-itemStringGetter: arg1  self columns first itemStringGetter: arg1-=JUAMPI=-fillStyleToUse  ^self isSelected ifTrue: [ self selectedFillStyle ] ifFalse: [ self normalFillStyle ]-=JUAMPI=-openOn: arg1  rootClass := arg1.  (self defaultTreeMorph buildContents embeddedInMorphicWindowLabeled: 'test') openInWorld-=JUAMPI=-openDialogOn: arg1  rootClass := arg1.  ^self openDialogWindowIn: self currentWorld title: 'All Object subclasses'-=JUAMPI=-deselect  editor ifNotNil: [ editor deselect ]-=JUAMPI=-allEnabledSiblingItems  ^self allSiblingItems select: [:arg1 |  arg1 isEnabled ]-=JUAMPI=-setSelectedSilently: arg1  selected := arg1.  self complexContents selected: arg1-=JUAMPI=-beUnsticky  extension ifNotNil: [ extension sticky: false ]-=JUAMPI=-announcer  WorldAnnouncer ifNil: [ WorldAnnouncer := Announcer new ].  ^WorldAnnouncer-=JUAMPI=-needSpaceForActions  | tmp1 |  tmp1 := self selectedTab.  tmp1 ifNil: [ ^false ].  ^self selectedTab hasMenu or: [ self selectedTab hasActions ]-=JUAMPI=-isSelfEvaluating  ^false-=JUAMPI=-indentBy: arg1  indentation := arg1 + self cellInset-=JUAMPI=-acceptDroppingMorph: arg1 event: arg2  | tmp1 tmp2 |  dropItemSelector ifNil: [ model acceptDroppingMorph: arg1 event: arg2 inMorph: self ] ifNotNil: [ tmp1 := arg1 passenger.        tmp2 := (self itemFromPoint: arg2 position) withoutListWrapper.        model perform: dropItemSelector with: tmp1 with: tmp2 ].  arg2 hand releaseMouseFocus: self.  Cursor normal show-=JUAMPI=-halo  ^self valueOfProperty: #halo-=JUAMPI=-playMaximizeSound  self theme windowMaximizeSound play-=JUAMPI=-drawOn: arg1  super drawOn: arg1.  self drawGridOn: arg1.  self drawBackgroundSketchOn: arg1-=JUAMPI=-openItemPath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  tmp1 := nil.  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ (arg2 complexContents withoutListWrapper = arg1 first or: [ arg1 first isNil ]) ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNotNil: [ tmp1 isExpanded ifFalse: [ tmp1 toggleExpandedState ].        tmp1 changed.        arg1 size = 1 ifTrue: [ ^container listManager setSelectedMorph: tmp1 ].        ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild openItemPath: arg1 allButFirst ] ].  ^self-=JUAMPI=-minExtent  ^self theme tabSelectorMorphMinExtentFor: self-=JUAMPI=-transferHalo: arg1 from: arg2  | tmp1 tmp2 tmp3 |  self flag: #workAround.  (arg2 == self and: [ self isRenderer and: [ self wantsHaloFromClick not ] ]) ifTrue: [ arg1 shiftPressed ifTrue: [ tmp3 := owner.              tmp1 := arg1 transformedBy: (self transformedFrom: owner) ] ifFalse: [ tmp3 := self renderedMorph.              tmp1 := arg1 transformedBy: (tmp3 transformedFrom: self) ].        ^tmp3 transferHalo: tmp1 from: tmp3 ].  (self isWorldMorph and: [ owner isNil ]) ifFalse: [ (self wantsHaloFromClick and: [ arg2 ~~ self ]) ifTrue: [ ^self addHalo: arg1 from: arg2 ] ].  arg1 shiftPressed ifTrue: [ owner ifNotNil: [ ^owner transferHalo: arg1 from: arg2 ].        arg2 removeHalo.        ^self processEvent: arg1 copy resetHandlerFields ].  self submorphsDo: [:arg3 |  tmp1 := arg1 transformedBy: (arg3 transformedFrom: self).        (arg3 fullContainsPoint: tmp1 position) ifTrue: [ ^arg3 transferHalo: arg1 from: arg2 ] ].  arg2 removeHalo.  (tmp2 := self world) ifNil: [ ^self ].  tmp1 := arg1 transformedBy: (self transformedFrom: tmp2) inverseTransformation.  ^tmp2 processEvent: tmp1 resetHandlerFields-=JUAMPI=-invokeModal: arg1  ^self invokeModalAt: ActiveHand position in: self currentWorld allowKeyboard: arg1-=JUAMPI=-setSelectionIndex: arg1  | tmp1 tmp2 |  arg1 ifNil: [ ^self ].  tmp2 := arg1 min: scroller submorphs size max: 0.  tmp1 := tmp2 = 0 ifTrue: [ nil ] ifFalse: [ scroller submorphs at: tmp2 ].  self setSelectedMorph: tmp1-=JUAMPI=-inToggleArea: arg1  ^self sensitiveToggleRectangle containsPoint: arg1-=JUAMPI=-onImage  ^image-=JUAMPI=-initialize  isExpanded := false.  recentlyChanged := false-=JUAMPI=-textColor: arg1  textColor := arg1-=JUAMPI=-fontNumber  ^fontNumber-=JUAMPI=-deleteBalloonTarget: arg1  self handsDo: [:arg2 |  arg2 deleteBalloonTarget: arg1 ]-=JUAMPI=-expandAll: arg1  | tmp1 |  self expandAllSilently: arg1.  arg1 updateChildrenRecursively.  tmp1 := self scroller submorphs.  1 to: tmp1 size do: [:arg2 |  (tmp1 at: arg2) index: arg2 ].  self innerWidgetChanged-=JUAMPI=-initializeClass: arg1  self initialize.  self elements: ((arg1 selectors sorted: [:arg2 :arg3 |  arg2 < arg3 ]) collect: [:arg4 |  FTExampleMethodModel method: arg1 >> arg4 ])-=JUAMPI=-nextMorphAcrossInWindow  ^self submorphAfter ifNil: [ (self owner ifNil: [ ^self ]) nextMorphAcrossInWindow ]-=JUAMPI=-privateMoveBy: arg1  | tmp1 |  super privateMoveBy: arg1.  tmp1 := self barFillStyle.  tmp1 isOrientedFill ifTrue: [ tmp1 origin: tmp1 origin + arg1 ]-=JUAMPI=-gradientRamp  ^gradientRamp ifNil: [ {(0.0 -> originalColor muchLighter) .         (1.0 -> originalColor twiceDarker)} ]-=JUAMPI=-lastSelectedNode  ^self lastSelectedNodePath ifNotNil: [:arg1 |  arg1 ifEmpty: [ nil ] ifNotEmpty: [:arg2 |  arg1 last ] ]-=JUAMPI=-resetHScrollRange  hScrollRangeCache := nil.  self deriveHScrollRange-=JUAMPI=-includesHandle: arg1  handles ifNil: [ ^false ].  ^handles includes: arg1-=JUAMPI=-noteNewOwner: arg1  -=JUAMPI=-delete  self removeHalo.  self activeHand     releaseKeyboardFocus: self;     releaseMouseFocus: self.  owner ifNotNil: [ self privateDelete.        self announceDeleted ]-=JUAMPI=-spSetModal: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self activeHand keyboardFocus.  tmp2 := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  tmp2 ifNil: [ tmp2 := self ].  tmp2 modalLockTo: arg1.  tmp1 := RealEstateAgent maximumUsableArea.  arg1 extent: arg1 initialExtent.  arg1 position = (0 @ 0) ifTrue: [ arg1 position: self activeHand position - (arg1 extent // 2) ].  arg1 bounds: (arg1 bounds translatedToBeWithin: tmp1).  [ | tmp4 |  tmp4 := arg1.  [ tmp4 world notNil ] whileTrue: [ tmp4 outermostWorldMorph doOneCycle ] ] ensure: [ tmp2 modalUnlockFrom: arg1.        self activeHand newKeyboardFocus: tmp3 ].  ^arg1-=JUAMPI=-label  ^label-=JUAMPI=-drawOn: arg1  super drawOn: arg1.  topSeparator ifTrue: [ arg1 line: bounds topLeft to: bounds topRight color: self seperatorColor ]-=JUAMPI=-computeCellSizes: arg1 in: arg2 horizontal: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := (Array new: arg1 submorphCount) writeStream.  tmp3 := properties minCellSize asPoint.  tmp4 := properties maxCellSize asPoint.  arg3 ifTrue: [ tmp3 := tmp3 transposed.        tmp4 := tmp4 transposed ].  tmp5 := 0 @ 0.  tmp2 := [:arg4 |  | tmp6 tmp7 |  arg4 disableTableLayout ifFalse: [ tmp7 := arg4 minExtent asIntegerPoint.        tmp6 := LayoutCell new target: arg4.        arg3 ifTrue: [ tmp6 hSpaceFill: arg4 hResizing == #spaceFill.              tmp6 vSpaceFill: arg4 vResizing == #spaceFill ] ifFalse: [ tmp6 hSpaceFill: arg4 vResizing == #spaceFill.              tmp6 vSpaceFill: arg4 hResizing == #spaceFill.              tmp7 := tmp7 transposed ].        tmp7 := (tmp7 min: tmp4) max: tmp3.        tmp6 cellSize: tmp7.        tmp5 := tmp5 max: tmp7.        tmp1 nextPut: tmp6 ] ].  properties reverseTableCells ifTrue: [ arg1 submorphsReverseDo: tmp2 ] ifFalse: [ arg1 submorphsDo: tmp2 ].  ^tmp5 -> tmp1 contents-=JUAMPI=-setContainer: arg1  self changed.  container := arg1.  self releaseParagraph-=JUAMPI=-wantsColumnBreaks  ^wantsColumnBreaks-=JUAMPI=-addLine  submorphs isEmpty ifTrue: [ ^self ].  (self lastSubmorph isKindOf: DockingBarMenuLineMorph) ifFalse: [ self addMorphBack: DockingBarMenuLineMorph new ]-=JUAMPI=-transformedBy: arg1  ^self shallowCopy transformBy: arg1-=JUAMPI=-enabled  ^enabled ifNil: [ enabled := true ]-=JUAMPI=-terminateUIProcess  UIProcess     suspend;     terminate.  UIProcess := nil-=JUAMPI=-checkSplitters  (self submorphsSatisfying: [:arg1 |  arg1 isKindOf: ProportionalSplitterMorph ]) do: [:arg2 |  self checkMorphsLeftOrTopFrom: arg2.        self checkMorphsRightOrBottomFrom: arg2 ]-=JUAMPI=-setSelectionListSelector: arg1  setSelectionListSelector := arg1-=JUAMPI=-startDrag: arg1  | tmp1 tmp2 |  arg1 hand hasSubmorphs ifTrue: [ ^self ].  self dragEnabled ifFalse: [ ^self ].  arg1 hand anyButtonPressed ifFalse: [ ^self ].  self hasSelection ifFalse: [ ^self ].  tmp1 := self selectedIndexes collect: [:arg2 |  self dataSource passengerAt: arg2 ].  tmp2 := self dataSource transferFor: tmp1 from: self.  tmp2 align: tmp2 draggedMorph topLeft with: arg1 position.  tmp2 dragTransferType: self dataSource dragTransferType.  arg1 hand grabMorph: tmp2-=JUAMPI=-expandAllFromNode: arg1  self requestView: (MorphTreeChangeRequest expandAllFromNode: arg1)-=JUAMPI=-initializeContainer  container := self defaultContainer.  self addMorph: container-=JUAMPI=-leftFraction: arg1  leftFraction := arg1-=JUAMPI=-initialDataSource: arg1  initialDataSource := arg1-=JUAMPI=-isFirstItem  ^owner submorphs first == self-=JUAMPI=-selectMatch: arg1  | tmp1 |  self items do: [:arg2 |  | tmp2 |        tmp2 := arg1 isEmpty or: [ arg2 contents asString asLowercase includesSubstring: arg1 ].        arg2 isEnabled: tmp2.        (tmp2 and: [ tmp1 isNil ]) ifTrue: [ tmp1 := arg2 ] ].  ^tmp1-=JUAMPI=-result  ^result-=JUAMPI=-newImageFor: arg1 get: arg2 help: arg3  ^self theme newImageIn: self for: arg1 get: arg2 help: arg3-=JUAMPI=-pressed: arg1  self model pressed: arg1-=JUAMPI=-showWidget  self initializeMorph.  table     addMorph: field;     resizeAllSubviews-=JUAMPI=-newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7  ^self theme newDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7-=JUAMPI=-deactivate  InputEventSensor default shutDown.  Display shutDown.  InputEventFetcher default shutDown-=JUAMPI=-testLeftTopAligned  | tmp1 tmp2 |  tmp1 := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightFraction: 0 offset: 60;     bottomFraction: 0 offset: 25;     yourself.  tmp2 := tmp1 layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 110 @ 35) equals: tmp2-=JUAMPI=-removeAlarm: arg1 for: arg2  worldState removeAlarm: arg1 for: arg2-=JUAMPI=-deselectTimeOut: arg1  owner selectedItem == self ifTrue: [ arg1 hand releaseMouseFocus: owner.        owner selectItem: nil event: arg1 ]-=JUAMPI=-showIconTreshold  ^(closeIcon visible ifTrue: [ 54 ] ifFalse: [ 40 ]) * self displayScaleFactor-=JUAMPI=-chooseDirectory: arg1  ^self chooseDirectory: arg1 path: nil-=JUAMPI=-mouseDown: arg1  self enabled ifTrue: [ self           scrollPoint: arg1;           computeSlider ].  super mouseDown: arg1.  self enabled ifFalse: [ ^self ].  arg1 hand newMouseFocus: slider event: arg1.  slider     mouseEnter: arg1 copy;     mouseDown: arg1 copy-=JUAMPI=-hasSubMenu: arg1  ^submorphs anySatisfy: [:arg2 |  arg2 isMenuItemMorph and: (arg2 hasSubMenu: arg1) ]-=JUAMPI=-containsPoint: arg1  | tmp1 |  ^(super containsPoint: arg1) and: [ tmp1 := SystemWindow borderWidth.        ((self bounds translateBy: tmp1 @ tmp1 negated) containsPoint: arg1) not ]-=JUAMPI=-updateContents  target ifNotNil: [ contents := target perform: nameSelector ]-=JUAMPI=-characterBlockForIndex: arg1  | tmp1 |  tmp1 := lines at: (self lineIndexForCharacter: arg1).  ^(CharacterBlockScanner new text: text textStyle: textStyle) characterBlockAtPoint: nil index: ((arg1 max: tmp1 first) min: text size + 1) in: tmp1-=JUAMPI=-type: arg1 extension: arg2 action: arg3  action := arg3.  type := arg1.  extension := arg2-=JUAMPI=-layoutProperties: arg1  self layoutProperties == arg1 ifTrue: [ ^self ].  self assureExtension layoutProperties: arg1-=JUAMPI=-focusChanged  | tmp1 tmp2 |  tmp2 := self focusIndicatorMorph.  tmp2 fillStyle isTransparent ifTrue: [ tmp2 borderWidth > 0 ifTrue: [ tmp1 := tmp2 bounds areasOutside: (tmp2 bounds insetBy: tmp2 borderWidth).              tmp1 do: [:arg1 |  self invalidRect: arg1 ] ] ] ifFalse: [ self invalidRect: tmp2 bounds ]-=JUAMPI=-isFirstColumn  ^container columns first = self-=JUAMPI=-initialize  super initialize.  vertices := Array with: 5 @ 0 with: 20 @ 10 with: 0 @ 20.  closed := true.  smoothCurve := false.  arrows := #none.  self computeBounds.  self beSmoothCurve.  self diamondOval-=JUAMPI=-dropEnabled  ^(self valueOfProperty: #dropEnabled) == true-=JUAMPI=-onImageSelector: arg1  onImageSelector := arg1-=JUAMPI=-defersHaloOnClickTo: arg1  ^true-=JUAMPI=-moveSelectionDown: arg1 event: arg2  | tmp1 tmp2 |  tmp1 := self allEnabledSiblingItems.  tmp2 := (tmp1 indexOf: selectedItem ifAbsent: [ 0 + (arg1 negative ifTrue: [ 1 ] ifFalse: [ 0 ]) ]) + arg1.  tmp1 do: [:arg3 |  | tmp3 |        tmp3 := tmp1 atWrap: tmp2.        (tmp3 isMenuItemMorph and: [ tmp3 isEnabled ]) ifTrue: [ tmp3 owner = self owner ifFalse: [ arg2 hand newKeyboardFocus: tmp3 owner ].              ^tmp3 owner selectItem: tmp3 event: arg2 ].        tmp2 := tmp2 + arg1 sign ].  ^self selectItem: nil event: arg2-=JUAMPI=-font  ^self listMorph font-=JUAMPI=-testSelectLast  self subclassResponsibility-=JUAMPI=-leftButtonEnabled  ^self wrapScrolling or: [ self visibleTabRange first > 1 ]-=JUAMPI=-getRawLabel  | tmp1 |  tmp1 := label shallowCopy fitContents.  tmp1 extent: (label extent x min: tmp1 extent x) @ tmp1 extent y.  ^tmp1-=JUAMPI=-doDebug: arg1 with: arg2  | tmp1 |  self world displayWorld.  arg1 shiftPressed ifTrue: [ self delete.        ^innerTarget inspectInMorphic: arg1 ].  tmp1 := innerTarget buildDebugMenu: arg1 hand.  tmp1     buildTitle: [:arg3 |  arg3           title: (innerTarget externalName asString truncateWithElipsisTo: 40);           withCloseBox;           withPinBox ];     popUpEvent: arg1 in: self world-=JUAMPI=-moveSelectionDown: arg1 event: arg2  | tmp1 |  tmp1 := (submorphs indexOf: selectedItem ifAbsent: [ 1 - arg1 ]) + arg1.  submorphs do: [:arg3 |  | tmp2 |        tmp2 := submorphs atWrap: tmp1.        (tmp2 isMenuItemMorph and: [ tmp2 isEnabled ]) ifTrue: [ ^self selectItem: tmp2 event: arg2 ].        tmp1 := tmp1 + arg1 sign ].  ^self selectItem: nil event: arg2-=JUAMPI=-mouseLeaveDragging: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseLeaveDragging from: arg2-=JUAMPI=-bestSegments  ^self honeIn: self calcEnoughSegments-=JUAMPI=-findSubmorphBinary: arg1  ^submorphs findBinary: arg1 do: [:arg2 |  arg2 ] ifNone: [:arg3 :arg4 |   ]-=JUAMPI=-hasExtraSelection  ^extraSelectionBlocks isEmptyOrNil not-=JUAMPI=-internalSpaces: arg1 paddingWidth: arg2  internalSpaces := arg1.  paddingWidth := arg2-=JUAMPI=-extent: arg1  arg1 x > arg1 y ifTrue: [ super extent: (arg1 max: (42 @ 8) scaledByDisplayScaleFactor) ] ifFalse: [ super extent: (arg1 max: (8 @ 42) scaledByDisplayScaleFactor) ]-=JUAMPI=-abort: arg1  ^self abort: arg1 title: 'Error' translated-=JUAMPI=-prepareForRotating  ^self addFlexShell-=JUAMPI=-wantsDropSelector: arg1  wantsDropSelector := arg1-=JUAMPI=-model  ^self complexContents-=JUAMPI=-computeBounds  | tmp1 tmp2 tmp3 |  vertices ifNil: [ ^self ].  self changed.  tmp1 := bounds.  self releaseCachedState.  bounds := self curveBounds expanded.  self arrowForms do: [:arg1 |  bounds := bounds merge: (arg1 offset extent: arg1 extent) ].  handles ifNotNil: [ self updateHandles ].  (tmp1 notNil and: [ (tmp2 := bounds origin - tmp1 origin) ~= (0 @ 0) ]) ifTrue: [ tmp3 := IdentitySet new.        handles ifNotNil: [ tmp3 addAll: handles ].        self submorphsDo: [:arg2 |  (tmp3 includes: arg2) ifFalse: [ arg2 position: arg2 position + tmp2 ] ] ].  self layoutChanged.  self changed-=JUAMPI=-hash  ^self morph hash bitXor: (self state hash bitXor: (self icon hash bitXor: self label hash))-=JUAMPI=-newExpander: arg1  ^self theme newExpanderIn: self label: arg1 forAll: #()-=JUAMPI=-rotationDegrees: arg1  self adjustAfter: [ self angle: arg1 degreesToRadians negated ]-=JUAMPI=-childrenItems  ^Array new-=JUAMPI=-addMorph: arg1 frame: arg2  ^self addMorph: arg1 fullFrame: arg2-=JUAMPI=-deselectAll  | tmp1 |  self allNodeMorphs isEmpty ifTrue: [ ^self ].  self emptySelection.  self selectionUpdateFromViewWhile: [ tmp1 := self newSelectionHolderWithNodePath: nil.        self listModel selection: tmp1 ]-=JUAMPI=-newMenuFor: arg1  ^self theme newMenuIn: self for: arg1-=JUAMPI=-setSelectedMorph: arg1  selectedWrapper := arg1 complexContents.  self selection: selectedWrapper.  setSelectionSelector ifNotNil: [ model perform: setSelectionSelector with: (selectedWrapper ifNotNil: [ selectedWrapper item ]) ]-=JUAMPI=-drawArrowOn: arg1 at: arg2 from: arg3  | tmp1 tmp2 tmp3 |  tmp1 := self arrowBoundsAt: arg2 from: arg3.  tmp3 := tmp1 size = 4 ifTrue: [ tmp1 third ] ifFalse: [ (tmp1 copyFrom: 2 to: 3) average ].  tmp2 := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  tmp2 x sign = tmp2 y sign ifTrue: [ arg1 drawPolygon: tmp1 fillStyle: borderColor ] ifFalse: [ arg1 drawPolygon: tmp1 fillStyle: Color transparent borderWidth: (borderWidth + 1) // 2 borderColor: borderColor ].  ^tmp3-=JUAMPI=-adjacentTo  ^{(self bounds topRight + (5 @ 0)) .   (self bounds topLeft + (2 @ 0))}-=JUAMPI=-testIsBeforeColumn  self subclassResponsibility-=JUAMPI=-replaceFrom: arg1 to: arg2 with: arg3 displaying: arg4  text replaceFrom: arg1 to: arg2 with: arg3.  self recomposeFrom: arg1 to: arg1 + arg3 size - 1 delta: arg3 size - (arg2 - arg1 + 1)-=JUAMPI=-initForKeystrokes  canMove := true.  lastKeystrokeTime := 0.  lastKeystrokes := ''-=JUAMPI=-defaultTarget: arg1  defaultTarget := arg1-=JUAMPI=-secondName: arg1  self item secondName: arg1.  self changed: #secondName-=JUAMPI=-pageSizeToString  ^self pageSize asString-=JUAMPI=-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-=JUAMPI=-debugPrint  ^(WriteStream on: (String new: 10))     print: self class;     nextPutAll: ' (';     print: self date;     nextPutAll: ' - ';     print: self bounds;     nextPut: $);     contents-=JUAMPI=-handle: arg1 in: arg2 dropEvent: arg3  ^action cull: arg1 cull: arg2 cull: arg3-=JUAMPI=-gridModulus  ^self gridSpec extent-=JUAMPI=-listMorphClass  ^MulticolumnLazyListMorph-=JUAMPI=-commentText  ^(self theme newTextIn: self currentWorld text: self item comment)     unlock;     wrapFlag: true;     yourself-=JUAMPI=-vScrollBarMenuButtonPressed: arg1  ^self scrollBarMenuButtonPressed: arg1-=JUAMPI=-handlesMouseOver: arg1  ^false-=JUAMPI=-isSelected  self model ifNil: [ ^false ].  ^self model perform: (self getStateSelector ifNil: [ ^false ])-=JUAMPI=-taskbarThumbnailExtent  ^self isMinimized ifTrue: [ self fullFrame extent min: self defaultTaskbarThumbnailExtent ] ifFalse: [ super taskbarThumbnailExtent ]-=JUAMPI=-extent: arg1  | tmp1 tmp2 |  tmp2 := self rotationCenter.  tmp1 := arg1 x min: arg1 y.  super extent: tmp1 @ tmp1.  self rotationCenter: tmp2-=JUAMPI=-startPoint  ^startPoint-=JUAMPI=-prepareForScaling  ^self-=JUAMPI=-releaseCachedState  super releaseCachedState.  filledForm := nil.  arrowForms := nil.  borderForm := nil.  curveState := nil.  (self hasProperty: #flex) ifTrue: [ self removeProperty: #flex ]-=JUAMPI=-indentationOfLineIndex: arg1 ifBlank: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := CharacterSet crlf.  tmp1 := arg1.  [ tmp2 := (lines at: tmp1) first.  tmp2 > 1 and: [ tmp4 includes: (text string at: tmp2 - 1) ] ] whileTrue: [ tmp1 := tmp1 - 1 ].  tmp3 := (lines at: tmp1) last.  ^(text string copyFrom: tmp2 to: tmp3) indentationIfBlank: arg2-=JUAMPI=-chooseDirectory: arg1  ^self chooseDirectory: arg1 path: nil-=JUAMPI=-selectedLocation  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self innerBounds.  tmp2 := self selectedColor.  tmp3 := tmp2 saturation * (tmp1 width - 1).  tmp4 := (1 - tmp2 brightness) * (tmp1 height - 1).  ^tmp3 truncated @ tmp4 truncated + tmp1 topLeft-=JUAMPI=-grabMorph: arg1 from: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self releaseMouseFocus.  tmp1 := arg1.  arg1 keepsTransform ifTrue: [ tmp4 := tmp5 := IdentityTransform new ] ifFalse: [ tmp4 := arg2 ifNil: [ IdentityTransform new ] ifNotNil: [ arg2 grabTransform ].        tmp5 := arg2 ifNil: [ IdentityTransform new ] ifNotNil: [ arg2 transformFrom: owner ] ].  tmp3 := tmp5 globalPointToLocal: self position.  tmp2 := tmp3 - (tmp4 globalPointToLocal: self position).  tmp1 := tmp1 transformedBy: tmp4.  tmp1 == arg1 ifFalse: [ tmp1 setProperty: #addedFlexAtGrab toValue: true ].  tmp1 position: tmp1 position - tmp2 asIntegerPoint.  targetOffset := tmp1 position - self position.  self addMorphBack: tmp1.  tmp1 justGrabbedFrom: arg2-=JUAMPI=-firstName  ^firstName-=JUAMPI=-drawBackgroundForRow: arg1 on: arg2 color: arg3  | tmp1 |  tmp1 := self selectionFrameForRow: arg1.  arg2 fillRectangle: tmp1 color: arg3-=JUAMPI=-newPosition: arg1  newPosition := arg1-=JUAMPI=-setLayoutSizingFor: arg1  (arg1 = #left or: [ arg1 = #right ]) ifTrue: [ self           hResizing: #rigid;           vResizing: #spaceFill ].  (arg1 = #top or: [ arg1 = #bottom ]) ifTrue: [ self           hResizing: #spaceFill;           vResizing: #rigid ]-=JUAMPI=-getEnabledSelector  ^getEnabledSelector-=JUAMPI=-addScaleHandle: arg1  target shouldFlex ifTrue: [ (self addHandle: arg1 on: #mouseDown send: #startScale:with: to: self) on: #mouseMove send: #doScale:with: to: self ]-=JUAMPI=-initializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigation-=JUAMPI=-keyString  ^String streamContents: [:arg1 |  self printKeyStringOn: arg1 ]-=JUAMPI=-drawKeyTextOnAthenCanvas: arg1  self keyText ifNil: [ ^self ].  (ToggleMenuItemShortcut owner: self keyText: self keyText) drawOnAthensCanvas: arg1-=JUAMPI=-hasDropShadowString  ^self hasDropShadow -> 'show shadow' translated-=JUAMPI=-playCloseSound  self theme windowCloseSound play-=JUAMPI=-monthNameFont  | tmp1 tmp2 |  tmp1 := LogicalFont familyName: 'Bitmap DejaVu Sans' pointSize: 12.  tmp2 := TextEmphasis italic emphasisCode | TextEmphasis bold emphasisCode.  ^tmp1 emphasis: tmp2-=JUAMPI=-indicateModalChild  (self isMinimized and: [ self isTaskbarPresent ]) ifTrue: [ self worldTaskbar ifNotNil: [:arg1 |  arg1 indicateModalChildForMorph: self ] ] ifFalse: [ self flash ]-=JUAMPI=-withAllOwners  ^Array streamContents: [:arg1 |  self withAllOwnersDo: [:arg2 |  arg1 nextPut: arg2 ] ]-=JUAMPI=-expandNodePath: arg1  self requestView: (MorphTreeChangeRequest expandNodePath: arg1)-=JUAMPI=-submorphsSatisfying: arg1  ^submorphs select: [:arg2 |  (arg1 value: arg2) == true ]-=JUAMPI=-dragVertex: arg1 event: arg2 fromHandle: arg3  | tmp1 |  tmp1 := arg2 cursorPoint.  arg3 position: tmp1 - (arg3 extent // 2).  self verticesAt: arg1 put: tmp1-=JUAMPI=-firstChild  ^firstChild-=JUAMPI=-keyStroke: arg1  | tmp1 |  editView keyStroke: arg1.  (editView scrollByKeyboard: arg1) ifTrue: [ ^self ].  (acceptOnCR and: [ arg1 keyCharacter = Character cr ]) ifFalse: [ (editView navigationKey: arg1) ifTrue: [ ^self ] ].  self editor model: editView model.  tmp1 := editView.  (acceptOnCR and: [ arg1 keyCharacter = Character cr ]) ifTrue: [ ^self editor accept ].  super keyStroke: arg1.  tmp1 textChanged.  tmp1 scrollSelectionIntoView.  self doAutoAccept: arg1.  tmp1 scrollSelectionIntoView-=JUAMPI=-nextSibling  ^nextSibling-=JUAMPI=-drawOn: arg1  | tmp1 tmp2 |  tmp1 := self buildBorderVertices.  tmp2 := self buildVerticesFrom: tmp1.  arg1 drawPolygon: tmp2 color: self backgroundColor borderWidth: 0 borderColor: Color transparent.  tmp1 overlappingPairsDo: [:arg2 :arg3 |  arg1 line: arg2 to: arg3 width: 1 color: self borderColor ]-=JUAMPI=-textColor  ^self valueOfProperty: #textColor ifAbsent: [ self theme textColor ]-=JUAMPI=-lastVisibleRowIndex  ^self container lastVisibleRowIndex-=JUAMPI=-widthToDisplayInList: arg1  ^self minExtent x-=JUAMPI=-mouseStillDown: arg1  self eventHandler ifNotNil: [ self eventHandler mouseStillDown: arg1 fromMorph: self ]-=JUAMPI=-eventQueue  ^Sensor-=JUAMPI=-container  ^container-=JUAMPI=-privateFullMoveBy: arg1  | tmp1 tmp2 |  selectedItems isEmpty ifTrue: [ ^super privateFullMoveBy: arg1 ].  tmp2 := self pasteUpMorph.  tmp2 ifNil: [ ^super privateFullMoveBy: arg1 ].  tmp1 := arg1 + slippage.  slippage := 0.  super privateFullMoveBy: tmp1.  selectedItems do: [:arg2 |  arg2 position: arg2 position + tmp1 ]-=JUAMPI=-toggleRowIndex: arg1  self deprecated: 'Use #toggleIndex: instead.' transformWith: '`@receiver toggleRowIndex: `@statements' -> '`@receiver toggleIndex: `@statements'.  self toggleIndex: arg1-=JUAMPI=-buildMetaMenu: arg1  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 add: 'grab' selector: #grabMorph:.  tmp1 add: 'copy to paste buffer' selector: #copyToPasteBuffer:.  self maybeAddCollapseItemTo: tmp1.  tmp1 add: 'delete' selector: #dismissMorph:.  tmp1 addLine.  tmp1 add: 'copy text' selector: #clipText.  tmp1 addLine.  tmp1 add: 'go behind' selector: #goBehind.  tmp1 add: 'add halo' selector: #addHalo:.  tmp1 add: 'duplicate' selector: #maybeDuplicateMorph:.  self addEmbeddingMenuItemsTo: tmp1 hand: arg1 hand.  tmp1 add: 'resize' selector: #resizeMorph:.  self addFillStyleMenuItems: tmp1 hand: arg1 hand.  self addDropShadowMenuItems: tmp1 hand: arg1 hand.  self addLayoutMenuItems: tmp1 hand: arg1 hand.  tmp1 addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().  tmp1 addLine.  tmp1 add: 'inspect' selector: #inspectAt:event: argument: arg1 position.  tmp1 add: 'explore' selector: #inspect.  tmp1 lastItem icon: (self iconNamed: #smallInspectItIcon).  tmp1 addLine.  tmp1 add: 'show actions' selector: #showActions.  tmp1 addLine.  self addDebuggingItemsTo: tmp1 hand: arg1 hand.  self addCustomMenuItems: tmp1 hand: arg1 hand.  ^tmp1-=JUAMPI=-withoutListWrapper  ^complexContents withoutListWrapper-=JUAMPI=-wantsDropSelector: arg1  wantsDropSelector := arg1-=JUAMPI=-shouldDraw  ^self fillStyle isTransparent not-=JUAMPI=-justified  self changeAlignment: #justified-=JUAMPI=-elementWrapped: arg1  ^self wrapSelector ifNotNil: [:arg2 |  self model perform: arg2 with: arg1 ] ifNil: [ arg1 ]-=JUAMPI=-testUpdateTaskBarShouldContainsTaskbarTasks  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: (taskbar tasks first isKindOf: TaskbarTask)-=JUAMPI=-hasProperty: arg1  | tmp1 |  otherProperties ifNil: [ ^false ].  tmp1 := otherProperties at: arg1 ifAbsent: [  ].  tmp1 ifNil: [ ^false ].  tmp1 == false ifTrue: [ ^false ].  ^true-=JUAMPI=-setTextStyle: arg1  textStyle := arg1.  self     releaseCachedState;     changed-=JUAMPI=-forwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1-=JUAMPI=-newToolDockingBar  ^self theme newToolDockingBarIn: self-=JUAMPI=-setDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) rounded-=JUAMPI=-positionSubmorphs  self submorphsDo: [:arg1 |  arg1 snapToEdgeIfAppropriate ]-=JUAMPI=-hasCollapseBox  ^collapseBox notNil-=JUAMPI=-newYesButton  ^self newYesButtonFor: self-=JUAMPI=-calculateExactVisibleRows  | tmp1 tmp2 tmp3 |  self table hasDataSource ifFalse: [ ^super calculateExactVisibleRows ].  tmp1 := self table showIndex max: 1.  tmp3 := 0.  tmp2 := self height.  headerRow ifNotNil: [ tmp2 := tmp2 - headerRow height ].  [ tmp3 < tmp2 and: [ tmp1 <= self table dataSource numberOfRows ] ] whileTrue: [ tmp3 := tmp3 + (self table dataSource rowHeight: tmp1).        tmp1 := tmp1 + 1 ].  ^tmp1 - self table showIndex-=JUAMPI=-ghostText  ^'Search...'-=JUAMPI=-spawnBalloonFor: arg1  arg1 showBalloon: arg1 balloonText hand: self-=JUAMPI=-wantsDirectionHandles  ^self valueOfProperty: #wantsDirectionHandles ifAbsent: [ false ]-=JUAMPI=-fitTargetBoundsInOwner: arg1  | tmp1 tmp2 |  tmp2 := self target owner ifNil: [ ^self ].  tmp1 := tmp2 minExtent.  tmp1 x > self target owner width ifTrue: [ self edgeName = #left ifTrue: [ self target bounds: ((arg1 left + (tmp1 x - tmp2 width)) @ arg1 top extent: (arg1 width - (tmp1 x - tmp2 width)) @ arg1 height) ] ifFalse: [ self target bounds: (arg1 origin extent: (arg1 width - (tmp1 x - tmp2 width)) @ arg1 height) ] ].  tmp1 y > self target owner height ifTrue: [ self edgeName = #top ifTrue: [ self target bounds: (arg1 left @ (arg1 top + (tmp1 y - tmp2 height)) extent: arg1 width @ (arg1 height - (tmp1 y - tmp2 height))) ] ifFalse: [ self target bounds: (arg1 origin extent: arg1 width @ (arg1 height - (tmp1 y - tmp2 height))) ] ]-=JUAMPI=-hasChildren  ^self children size ~= 0-=JUAMPI=-value  ^progressBar value-=JUAMPI=-translateBy: arg1  position := position + arg1.  startPoint := startPoint + arg1-=JUAMPI=-showAbout  self theme longMessageIn: self text: self aboutText title: self aboutTitle-=JUAMPI=-colorForInsets  (color isColor and: [ color isTransparent and: [ owner notNil ] ]) ifTrue: [ ^owner colorForInsets ].  ^color colorForInsets-=JUAMPI=-clipSubmorphs: arg1  self invalidRect: self fullBounds.  arg1 == self clipSubmorphs ifFalse: [ self assureExtension.        extension clipSubmorphs: arg1.        self invalidRect: self fullBounds ]-=JUAMPI=-getMenuSelector: arg1  getMenuSelector := arg1-=JUAMPI=-readyToBeDisplayed  -=JUAMPI=-isDeActivated  ^true-=JUAMPI=-allMorphsDo: arg1  submorphs do: [:arg2 |  arg2 allMorphsDo: arg1 ].  arg1 value: self-=JUAMPI=-canDrawBorder: arg1  ^true-=JUAMPI=-sliderColor: arg1  | tmp1 |  super sliderColor: arg1.  self lastPaneColor: arg1.  tmp1 := self thumbColor.  upButton color: tmp1.  downButton color: tmp1.  slider color: tmp1 slightlyLighter.  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStyle.  (self theme scrollbarPagingAreaCornerStyleIn: self window) = #rounded ifTrue: [ self fillStyle: self normalButtonFillStyle ] ifFalse: [ self fillStyle: self normalFillStyle ].  self borderWidth: 0.  ^self adoptGradientColor: arg1-=JUAMPI=-putLabelItemsInLabelArea  labelArea ifNotNil: [ stripes ifNotNil: [ stripes do: [:arg1 |  labelArea addMorph: arg1 ] ].        closeBox ifNotNil: [ labelArea addMorph: closeBox ].        menuBox ifNotNil: [ labelArea addMorph: menuBox ].        collapseBox ifNotNil: [ labelArea addMorph: collapseBox ].        label ifNotNil: [ labelArea addMorph: label ] ]-=JUAMPI=-simulateKeyStroke: arg1  | tmp1 |  tmp1 := arg1 asKeyCombination.  self handleEvent: (KeyboardEvent new setType: #keystroke buttons: tmp1 modifier eventCode position: self position keyValue: tmp1 key asciiValue charCode: tmp1 key asciiValue hand: self activeHand stamp: DateAndTime now)-=JUAMPI=-intersects: arg1  ^self fullBoundsInWorld intersects: arg1-=JUAMPI=-newPreviewMorph  ^Morph new     color: Color transparent;     extent: self defaultPreviewExtent;     yourself-=JUAMPI=-mouseMoveOnMultiple: arg1  | tmp1 tmp2 tmp3 |  canMove ifFalse: [ ^self ].  arg1 position y < self top ifTrue: [ scrollBar scrollUp: 1.        tmp3 := self rowAtLocation: scroller topLeft + (1 @ 1) ] ifFalse: [ tmp3 := arg1 position y > self bottom ifTrue: [ scrollBar scrollDown: 1.              self rowAtLocation: scroller bottomLeft + (1 @ -1) ] ifFalse: [ self rowAtLocation: arg1 position ] ].  tmp3 = 0 ifTrue: [ ^super mouseDown: arg1 ].  (self potentialDropItem notNil and: [ self dropEnabled ]) ifTrue: [ ^self ].  dragOnOrOff ifNil: [ dragOnOrOff := (self listSelectionAt: tmp3) not ].  tmp1 := self getCurrentSelectionIndex.  tmp1 ~= 0 ifTrue: [ tmp2 := self listSelectionAt: tmp1 ].  tmp1 ~= 0 ifTrue: [ self listSelectionAt: tmp1 put: tmp2 ].  self listSelectionAt: tmp3 put: dragOnOrOff.  tmp3 changed-=JUAMPI=-drawSubmorphsOn: arg1  super drawSubmorphsOn: arg1.  self drawLinesOn: arg1-=JUAMPI=-addPaneSplitters  self removePaneSplitters.  self addPaneVSplitters.  self addPaneHSplitters.  self linkSplittersToSplitters-=JUAMPI=-dropFiles: arg1  | tmp1 |  tmp1 := arg1 contents.  1 to: tmp1 do: [:arg2 |  | tmp2 tmp3 |        tmp2 := arg1 requestDropReference: arg2.        tmp3 := ExternalDropHandler lookupExternalDropHandler: tmp2.        tmp3 ifNotNil: [ tmp3 handle: tmp2 in: self dropEvent: arg1 ] ]-=JUAMPI=-bounds: arg1  | tmp1 |  tmp1 := arg1 width min: arg1 height.  super bounds: (Rectangle origin: arg1 origin extent: tmp1 @ tmp1)-=JUAMPI=-searchStrategy  ^searchStrategy ifNil: [ #default ]-=JUAMPI=-textEntry: arg1 title: arg2 entryText: arg3  ^self theme textEntryIn: self text: arg1 title: arg2 entryText: arg3-=JUAMPI=-is: arg1 afterColumn: arg2  ^arg1 second > arg2-=JUAMPI=-minWidth  ^self valueOfProperty: #minWidth ifAbsent: [ 2 ]-=JUAMPI=-controls  ^controls-=JUAMPI=-rowIndexToVerticalScrollBarValue: arg1  | tmp1 |  tmp1 := self numberOfRows - self container calculateMinVisibleRows.  ^(tmp1 = 0 or: [ arg1 <= 1 ]) ifTrue: [ 0.0 ] ifFalse: [ ((arg1 / tmp1) asFloat max: 0.0) min: 1.0 ]-=JUAMPI=-image: arg1  ^self image: arg1 size: arg1 extent-=JUAMPI=-allSubmorphNamesDo: arg1  ^self-=JUAMPI=-dragItemSelector  ^dragItemSelector-=JUAMPI=-pressedImageSelector  ^pressedImageSelector-=JUAMPI=-minCellSize  ^0-=JUAMPI=-vScrollbar  ^vScrollbar-=JUAMPI=-showsNever  ^self showState == #never-=JUAMPI=-index: arg1  index := arg1-=JUAMPI=-updateValue  self model ifNotNil: [ self getValueSelector ifNotNil: [ self sliderMorph ifNotNil: [:arg1 |  arg1 scaledValue: self value.                    self                       changed: #minEnabled;                       changed: #maxEnabled ] ] ]-=JUAMPI=-getEnabledSelector: arg1  getEnabledSelector := arg1.  self updateEnabled-=JUAMPI=-newRow: arg1  ^self theme newRowIn: self for: arg1-=JUAMPI=-handleUpdate: arg1  ^arg1 deliverTo: self-=JUAMPI=-testIndexFromPosition  self assert: (strategy indexFromPosition: #(3 7)) equals: #(3 7)-=JUAMPI=-printOn: arg1  arg1 nextPutAll: 'Node('.  self item printOn: arg1.  arg1 nextPut: $)-=JUAMPI=-getListSizeSelector: arg1  getListSizeSelector := arg1-=JUAMPI=-icon  ^icon-=JUAMPI=-message: arg1  ^self message: arg1 title: 'Information' translated-=JUAMPI=-tabs  ^tabs-=JUAMPI=-optimalExtent  ^(Paragraph new     compose: text style: textStyle copy from: 1 in: (0 @ 0 extent: 9999999 @ 9999999);     adjustRightX;     extent) + (self borderWidth * 2) + (2 @ 0)-=JUAMPI=-tabRemovedFromSelection: arg1  self setMultipleContents-=JUAMPI=-drawLineFrom: arg1 to: arg2 on: arg3  | tmp1 |  tmp1 := (arg2 truncated quadrantOf: arg1 truncated) > 2 ifTrue: [ self topLeftColor ] ifFalse: [ self bottomRightColor ].  arg3 line: arg1 to: arg2 width: (self width - self margin max: 0) color: tmp1-=JUAMPI=-beCellSelection  self selectionModeStrategy: (FTCellSelectionModeStrategy table: self)-=JUAMPI=-newScrollPaneFor: arg1  ^self theme newScrollPaneIn: self for: arg1-=JUAMPI=-currentNodelist  ^self nodeList copyFrom: self currentPageFirstIndex to: self currentPageLastIndex-=JUAMPI=-removeDependent: arg1  self announcer unsubscribe: arg1-=JUAMPI=-mouseOverAllowed  ^mouseOverAllowed ifNil: [ mouseOverAllowed := false ]-=JUAMPI=-unexpandAllChildOf: arg1  arg1 children do: [:arg2 |  arg2 isExpanded ifTrue: [ self unexpandAllChildOf: arg2 ].        arg2 collapse ] displayingProgress: [:arg3 |  'Rearanging ' , arg3 name ]-=JUAMPI=-addCustomHaloMenuItems: arg1 hand: arg2  self addCustomMenuItems: arg1 hand: arg2-=JUAMPI=-passiveDisabledOverDownFillStyle: arg1  self stateMap atPath: #(passive disabled over down) put: arg1.  self changed-=JUAMPI=-handlesMouseOver: arg1  self table ifNotNil: [:arg2 |  ^arg2 selectionModeStrategy allowsCellSelection ].  ^false-=JUAMPI=-captureEventsUntil: arg1  | tmp1 |  tmp1 := false.  captureBlock := [:arg2 |  tmp1 := arg1 value: arg2 ].  [ [ self world doOneCycle.  tmp1 ] whileFalse ] ensure: [ captureBlock := nil ]-=JUAMPI=-table: arg1  table := arg1-=JUAMPI=-makeMeVisible  self world extent > (0 @ 0) ifFalse: [ ^self ].  ((self world bounds insetBy: (0 @ 0 corner: self labelHeight asPoint)) containsPoint: self position) ifTrue: [ ^self ].  self isCollapsed ifTrue: [ self position: (RealEstateAgent assignCollapsePointFor: self) ] ifFalse: [ self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent world: self world) topLeft ]-=JUAMPI=-allowsRowSelection  ^false-=JUAMPI=-offerWindowMenu  | tmp1 |  tmp1 := self buildWindowMenu.  tmp1     addLine;     add: 'Grab window...' target: self selector: #grabWindow.  tmp1 lastItem icon: (self iconNamed: #smallWindowIcon).  self tabGroup page ifNotNil: [:arg1 |  arg1 model addModelItemsToWindowMenu: tmp1 ].  tmp1 popUpEvent: self currentEvent in: self world-=JUAMPI=-matchesTypes: arg1  (self type isNil or: [ arg1 isNil ]) ifTrue: [ ^false ].  ^arg1 anySatisfy: [:arg2 |  arg2 beginsWith: self type ]-=JUAMPI=-numberOfLines  ^lines size-=JUAMPI=-interactionState: arg1  -=JUAMPI=-collapseAll  self subclassResponsibility-=JUAMPI=-colorForSelection: arg1  ^arg1 ifTrue: [ self selectionColor ] ifFalse: [ self secondarySelectionColor ]-=JUAMPI=-minimumSelection  ^1-=JUAMPI=-stayUp  ^false-=JUAMPI=-preferredButtonCornerStyle  ^#square-=JUAMPI=-adoptPaneColor: arg1  super adoptPaneColor: arg1.  self hScrollbar adoptPaneColor: arg1.  self vScrollbar adoptPaneColor: arg1-=JUAMPI=-moveShowIndexTo: arg1  | tmp1 tmp2 |  tmp1 := self selectionModeStrategy rowIndexFrom: arg1.  tmp2 := showIndex.  self basicMoveShowIndexTo: tmp1.  self verticalScrollBar value: (self rowIndexToVerticalScrollBarValue: tmp1).  self refresh.  self announceScrollChangedFrom: tmp2 to: tmp1-=JUAMPI=-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-=JUAMPI=-= arg1  ^arg1 class == self class and: [ arg1 anchoredMorph == anchoredMorph ]-=JUAMPI=-menu  | tmp1 |  tmp1 := UIManager default newMenuIn: self currentWorld for: self.  tmp1 buildTitle: [:arg1 |  arg1 onlyCloseAndPinable ].  tmp1 add: 'Why you see this menu' target: self selector: #fallbackMenuExplanations.  tmp1 add: 'Debug' target: self selector: #debug.  tmp1 addLine.  client fallbackMenuOn: tmp1.  ^tmp1-=JUAMPI=-expandAll  rootItem expandAll.  self tableRefresh-=JUAMPI=-centeredAlert: arg1 title: arg2 configure: arg3  ^self theme centeredAlertIn: self text: arg1 title: arg2 configure: arg3-=JUAMPI=-newStateForSelected: arg1  ^TabEnabled tab: self tab-=JUAMPI=-useGradientFill  | tmp1 tmp2 tmp3 |  self fillStyle isGradientFill ifTrue: [ ^self ].  tmp2 := self color asColor.  tmp3 := tmp2 negated.  tmp1 := GradientFillStyle ramp: {(0.0 -> tmp2) .         (1.0 -> tmp3)}.  tmp1 origin: self topLeft.  tmp1 direction: 0 @ self bounds extent y.  tmp1 normal: self bounds extent x @ 0.  tmp1 radial: false.  self fillStyle: tmp1-=JUAMPI=-optionalOperations  pattern isEmptyOrNil ifTrue: [ self unexpandAllChildOf: dataSource rootItem.        ^#() ] ifFalse: [ ^nil ]-=JUAMPI=-imageMorph: arg1  imageMorph := arg1-=JUAMPI=-initialize  super initialize.  self initForKeystrokes.  self on: #mouseMove send: #mouseStillDown:onItem: to: self-=JUAMPI=-adjustAfter: arg1  arg1 value.  self chooseSmoothing.  self layoutChanged.  owner ifNotNil: [ owner invalidRect: bounds ]-=JUAMPI=-userString  ^text string-=JUAMPI=-newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: true help: arg6-=JUAMPI=-computeAltFramedColors  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self color asColor.  tmp2 := Color white.  tmp3 := Color black.  tmp4 := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  tmp4 := tmp4 asInteger.  tmp4 = 1 ifTrue: [ ^{(tmp1 mixed: 0.5 with: tmp2) .         (tmp1 mixed: 0.5 with: tmp3)} ].  tmp6 := Array new: tmp4.  tmp5 := tmp4 // 2.  0 to: tmp5 - 1 do: [:arg1 |  tmp7 := 0.5 + (arg1 asFloat / tmp5 * 0.5).        tmp6 at: arg1 + 1 put: (tmp1 mixed: tmp7 with: tmp3).        tmp6 at: tmp4 - arg1 put: (tmp1 mixed: tmp7 with: tmp2) ].  tmp4 odd ifTrue: [ tmp6 at: tmp5 + 1 put: tmp1 ].  ^tmp6 , tmp6-=JUAMPI=-filterClass: arg1  filterClass := arg1-=JUAMPI=-doubleClickTimeout  dblClickTimeoutSelector ifNotNil: [ clickClient perform: dblClickTimeoutSelector with: firstClickDown ]-=JUAMPI=-first: arg1 last: arg2 color: arg3  first := arg1.  last := arg2.  color := arg3-=JUAMPI=-wrapCentering  ^#topLeft-=JUAMPI=-initializeColumsFrom: arg1  self columns: arg1 columns-=JUAMPI=-chooseColor  ^self chooseColor: Color black-=JUAMPI=-wasHandled  ^false-=JUAMPI=-addDependent: arg1  dependents := #().  super addDependent: arg1-=JUAMPI=-hsvaMorph: arg1  hsvaMorph := arg1-=JUAMPI=-roundedCorners  self isAdheringToTop ifTrue: [ ^#(2 3) ].  self isAdheringToBottom ifTrue: [ ^#(1 4) ].  self isAdheringToLeft ifTrue: [ ^#(3 4) ].  self isAdheringToRight ifTrue: [ ^#(1 2) ].  ^#(1 2 3 4)-=JUAMPI=-predecessor: arg1 successor: arg2  predecessor := arg1.  successor := arg2-=JUAMPI=-blueButtonPressed  ^buttons anyMask: self class blueButton-=JUAMPI=-iconPosition  ^iconPosition ifNil: [ iconPosition := #left ]-=JUAMPI=-