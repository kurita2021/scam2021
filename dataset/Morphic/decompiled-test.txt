selectedFillStyle  ^self theme tabLabelSelectedFillStyleFor: self-======-printStructureOn: arg1 indent: arg2  arg2 timesRepeat: [ arg1 tab ].  self printOn: arg1.  arg1 cr.  self submorphsDo: [:arg3 |  arg3 printStructureOn: arg1 indent: arg2 + 1 ]-======-updateFromEvent: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 cursorPoint - lastMouse second.  tmp4 := index = 1 ifTrue: [ container minResizerX ] ifFalse: [ (container columnResizers at: index - 1) right + container minResizerOffset ].  tmp5 := tmp4 max: tmp1 x.  index = 1 ifTrue: [ tmp5 := tmp5 + 3 ].  self left: tmp5.  tmp2 := index = 1 ifTrue: [ container scroller left - container scroller offset x + 3 ] ifFalse: [ (container columnResizers at: index - 1) left ].  tmp3 := self left - tmp2.  (container columns at: index) currentWidth: tmp3.  container resizerChanged-======-displaySelectionInLine: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  selectionStart ifNil: [ ^self ].  arg2 isShadowDrawing ifTrue: [ ^self ].  selectionStart = selectionStop ifTrue: [ selectionStart textLine ~= arg1 ifTrue: [ ^self ] ] ifFalse: [ (selectionStop stringIndex < arg1 first or: [ selectionStart stringIndex > (arg1 last + 1) ]) ifTrue: [ ^self ].        (selectionStop stringIndex = arg1 first and: [ selectionStop textLine ~= arg1 ]) ifTrue: [ ^self ].        (selectionStart stringIndex = (arg1 last + 1) and: [ selectionStop textLine ~= arg1 ]) ifTrue: [ ^self ] ].  tmp1 := (selectionStart stringIndex < arg1 first ifTrue: [ arg1 ] ifFalse: [ selectionStart ]) left.  tmp2 := (selectionStop stringIndex > (arg1 last + 1) or: [ selectionStop stringIndex = (arg1 last + 1) and: [ selectionStop textLine ~= arg1 ] ]) ifTrue: [ arg1 right ] ifFalse: [ selectionStop left ].  selectionStart = selectionStop ifTrue: [ tmp2 := tmp2 + 1.        tmp3 := self caretWidth.        caretRect := (tmp1 - tmp3) @ arg1 top corner: (tmp2 + tmp3) @ arg1 bottom.        self showCaret ifFalse: [ ^self ].        tmp4 := self insertionPointColor.        1 to: tmp3 do: [:arg3 |  arg2 fillRectangle: ((tmp1 - tmp3 + arg3 - 1) @ (arg1 top + arg3 - 1) extent: ((tmp3 - arg3) * 2 + 3) @ 1) color: tmp4.              arg2 fillRectangle: ((tmp1 - tmp3 + arg3 - 1) @ (arg1 bottom - arg3) extent: ((tmp3 - arg3) * 2 + 3) @ 1) color: tmp4 ].        arg2 fillRectangle: (tmp1 @ arg1 top corner: tmp2 @ arg1 bottom) color: tmp4 ] ifFalse: [ caretRect := nil.        arg2 fillRectangle: (tmp1 @ arg1 top corner: tmp2 @ arg1 bottom) color: self selectionColor ]-======-enabled: arg1  enabled := arg1.  self     cachedForm: nil;     changed-======-ghostText  self subclassResponsibility-======-toggle  self isExpanded ifTrue: [ self collapseAndRefresh ] ifFalse: [ self expandAndRefresh ]-======-flashBounds  5 timesRepeat: [ Display flash: self boundsInWorld andWait: 120 ]-======-handlesClickOrDrag: arg1  ^(self existsSubscriptionsFor: #click) or: [ (self existsSubscriptionsFor: #doubleClick) or: [ self existsSubscriptionsFor: #startDrag ] ]-======-newLabel  ^self theme checkboxLabelFor: self-======-targetPoint  ^position - source targetOffset-======-copyHandlerState: arg1  -======-table: arg1  table := arg1-======-font: arg1  font := arg1.  self update: getLabelSelector-======-wantsColumnBreaks: arg1  wantsColumnBreaks := arg1-======-gripLayoutFrame  ^(0 @ 1 corner: 0 @ 1) asLayoutFrame     topOffset: self defaultHeight negated;     rightOffset: self defaultWidth-======-testTransform  | tmp1 tmp2 |  tmp1 := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  tmp2 := tmp1 layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 140 @ 60) equals: tmp2-======-defaultColor  ^Color green lighter-======-changePropotionalLayout  | tmp1 |  ((tmp1 := self layoutPolicy) notNil and: [ tmp1 isProportionalLayout ]) ifTrue: [ ^self ].  self layoutPolicy: ProportionalLayout new.  self layoutChanged-======-setGrabbedColor  self fillStyle: self theme fastTableColumnSplitterSelectedColor-======-calculateVisibleRows  ^self calculateMaxVisibleRows min: self table numberOfRows-======-newGroupbox: arg1 for: arg2  ^self theme newGroupboxIn: self label: arg1 for: arg2-======-drawText: arg1 on: arg2 in: arg3  ^self drawText: arg1 on: arg2 in: arg3 color: self stringColorToUse-======-drawLinesOn: arg1  self selectedTab ifNotNil: [ self drawWithSelectionOn: arg1 ] ifNil: [ self drawWithoutSelectedOn: arg1 ]-======-selectRow: arg1  selectedRows add: arg1.  self invalidRect: (self selectionFrameForRow: arg1)-======-scrollBarColor  ^self paneColor-======-flushLayoutCache  minExtentCache := nil-======-colorFor: arg1  arg1 odd ifTrue: [ ^Smalltalk ui theme lightBackgroundColor ].  ^Smalltalk ui theme backgroundColor-======-finishedScrolling: arg1  self finishedScrolling.  (self containsPoint: arg1 position) ifTrue: [ pagingArea           fillStyle: self mouseOverFillStyle;           borderStyle: self mouseOverBorderStyle ] ifFalse: [ pagingArea           fillStyle: self normalFillStyle;           borderStyle: self normalBorderStyle ].  (upButton containsPoint: arg1 position) ifTrue: [ upButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: arg1 position) ifTrue: [ upButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ upButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ].  (downButton containsPoint: arg1 position) ifTrue: [ downButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: arg1 position) ifTrue: [ downButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ downButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ]-======-theme  ^Smalltalk ui theme-======-mouseUp: arg1  actWhen == #buttonUp ifFalse: [ ^super mouseUp: arg1 ].  (self containsPoint: arg1 cursorPoint) ifTrue: [ self state: #on.        self doButtonAction: arg1 ] ifFalse: [ self state: #off ]-======-preferredKeyboardPosition  ^(self bounds: self bounds in: self currentWorld) topLeft-======-indexFromPosition: arg1  ^arg1 first-======-initializeTable: arg1  table := arg1.  self initialize-======-handleFocusEvent: arg1  ^self handleEvent: arg1-======-rotationDegrees  ^0.0-======-target: arg1  self setTarget: arg1.  target ifNotNil: [ self addHandles ]-======-wantsDirectionHandles  ^false-======-gridSpecPut: arg1  ^self setProperty: #gridSpec toValue: arg1-======-wantsKeyboardFocusOnMouseDown  ^self wantsKeyboardFocus and: [ self valueOfProperty: #wantsKeyboardFocusOnMouseDown ifAbsent: [ false ] ]-======-selectionBarColor  ^self theme selectionBarColor-======-itemWithWording: arg1  self items do: [:arg2 |  | tmp1 |        tmp1 := arg2 itemWithWording: arg1.        tmp1 ifNotNil: [ ^tmp1 ] ].  ^nil-======-compositionRectangle  ^container-======-tasks: arg1  tasks := arg1-======-inject: arg1 into: arg2  | tmp1 |  tmp1 := arg1.  self do: [:arg3 |  tmp1 := arg2 value: tmp1 value: arg3 ].  ^tmp1-======-selectionIndex  ^self listMorph selectedRow ifNil: [ 0 ]-======-positionModalOwner  self modalOwner ifNotNil: [:arg1 |  (arg1 isKindOf: SystemWindow) ifTrue: [ arg1 bringBehind: self ] ]-======-down: arg1  down := arg1.  self changed-======-addNameBeneath: arg1 string: arg2  | tmp1 tmp2 |  tmp2 := self world ifNil: [ target world ].  nameMorph := StringMorph contents: arg2 font: StandardFonts haloFont.  nameMorph     wantsYellowButtonMenu: false;     color: self theme balloonTextColor;     backgroundColor: self theme balloonBackgroundColor;     target: innerTarget.  tmp1 := arg1 bottomCenter - ((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).  nameMorph position: (tmp1 min: tmp2 viewBox bottomRight - nameMorph extent y + 2).  self addMorph: nameMorph.  ^nameMorph-======-acceptOnCR: arg1  acceptOnCR := arg1-======-drawSubmorphsOn: arg1  super drawSubmorphsOn: arg1.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: arg1 ]-======-initialize  super initialize.  self elements: #()-======-table  ^table-======-getChildren  ^dataSource childrenBlock isSymbol ifTrue: [ dataSource childrenBlock value: data ] ifFalse: [ dataSource childrenBlock cull: data cull: self ]-======-setType: arg1  type := arg1-======-getIconSelector: arg1  getIconSelector := arg1-======-takesKeyboardFocus  ^true-======-addItemShowing: arg1 from: arg2 to: arg3  lock critical: [ | tmp1 tmp2 |        tmp1 := SystemProgressItemMorph labeled: arg1 from: arg2 to: arg3.        tmp2 := self bars size.        tmp2 < 10 ifTrue: [ self addMorphBack: tmp1.              self recenter ].        ^tmp1 ]-======-wantsStepsWhenCollapsed  ^false-======-updateTasks  | tmp1 |  tmp1 := windows collect: [:arg1 |  self newTaskFor: arg1 ].  self updateOrderedTasksFrom: tmp1-======-lineWidth: arg1  self borderWidth: (arg1 rounded max: 1)-======-scrollUpInit  | tmp1 |  tmp1 := upButton borderStyle baseColor.  upButton borderInset.  upButton borderStyle baseColor: tmp1.  self resetTimer.  self scrollBarAction: #doScrollUp.  self doScrollUp.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nil.  upButton fillStyle: self pressedButtonFillStyle.  upButton borderStyle: self pressedButtonBorderStyle-======-action  self inform: 'Button pressed'-======-changeMinCellSize: arg1  | tmp1 |  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  self minCellSize: (arg2 - arg1 cursorPoint) asIntegerPoint ].  arg1 hand attachMorph: tmp1.  tmp1 startStepping-======-beIconRight  iconPosition := #right.  self update: getIconSelector-======-on: arg1 color: arg2  self     model: arg1;     getColorSelector: arg2;     updateColor-======-getChildrenSelector  ^getChildrenSelector-======-indexForRow: arg1  ^{arg1 .   self table selectedIndex second}-======-newLocationMorph  ^ImageMorph new form: Cursor crossHair withMask asCursorForm-======-defaultColor  ^self theme menuSelectionColor alpha: 0.08-======-cellColumn: arg1 row: arg2  arg1 id = 'Icon' ifTrue: [ ^self iconColumn: arg1 row: arg2 ].  arg1 id = 'Name' ifTrue: [ ^self nameColumn: arg1 row: arg2 ].  arg1 id = 'Number of methods' ifTrue: [ ^self numberOfMethodsColumn: arg1 row: arg2 ].  arg1 id = 'Number of instance variables' ifTrue: [ ^self numberOfInstanceVariablesColumn: arg1 row: arg2 ].  self error: 'Invalid column'-======-indentingItemClass  ^MorphTreeNodeMorph-======-hasTableLayoutString  | tmp1 |  ^((tmp1 := self layoutPolicy) notNil and: [ tmp1 isTableLayout ]) -> 'table layout' translated-======-wantsExpandBox  ^true-======-deriveHScrollRange  | tmp1 tmp2 |  (list isNil or: [ list isEmpty ]) ifTrue: [ hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0 ] ifFalse: [ tmp1 := self listMorph hUnadjustedScrollRange.        tmp2 := tmp1 + self hExtraScrollRange + self hMargin.        hScrollRangeCache := Array with: tmp2 with: tmp1 with: list size with: list first with: list last ]-======-headerColumn: arg1  ^self basicHeaderCellFor: arg1-======-setIndexSelector: arg1  setIndexSelector := arg1-======-windowEventHandler: arg1  WindowEventHandler := arg1-======-initialExtent  ^(self model respondsTo: #initialExtent) ifTrue: [ self model initialExtent ] ifFalse: [ RealEstateAgent standardWindowExtent ]-======-ownerChanged  super ownerChanged.  self updateLayoutInDockingBar-======-newOKButton  ^self newOKButtonFor: self-======-currentlyExpanded  ^(scroller submorphs select: [:arg1 |  arg1 isExpanded ]) collect: [:arg1 |  arg1 complexContents ]-======-acquireBorderWidth: arg1  | tmp1 |  (tmp1 := arg1 - self borderWidth) = 0 ifTrue: [ ^self ].  self bounds: (self bounds origin - (tmp1 @ tmp1) corner: self bounds corner + (tmp1 @ tmp1)).  self borderWidth: arg1.  self layoutChanged-======-allSiblingItems  | tmp1 tmp2 tmp3 |  tmp2 := (Array new: 40) writeStream.  tmp1 := self owner submorphs select: [:arg1 |  arg1 isKindOf: self class ].  tmp1 := (tmp1 copyFrom: (tmp3 := tmp1 indexOf: self) to: tmp1 size) , (tmp1 copyFrom: 1 to: tmp3 - 1).  tmp1 do: [:arg2 |  tmp2 nextPutAll: arg2 items ].  ^tmp2 contents-======-userString  ^nil-======-visible: arg1  visible := arg1-======-target: arg1  -======-headerButtonLabel: arg1 icon: arg2  self headerButtonLabel: arg1 font: nil.  self header cellInset: 3 @ 0.  self header icon: (ImageMorph new form: arg2)-======-newLabel  | tmp1 |  tmp1 := self theme buttonLabelFor: self.  font ifNotNil: [ tmp1 font: font.        tmp1 extent: tmp1 optimalExtent ].  ^tmp1-======-arguments  ^arguments-======-handlesMouseDown: arg1  ^true-======-getListSelector: arg1  getListSelector := arg1.  self changed.  self updateList-======-basicBorderWidth: arg1  borderWidth := arg1-======-doGrow: arg1 with: arg2  | tmp1 tmp2 tmp3 |  arg1 hand obtainHalo: self.  tmp1 := (target pointFromWorld: arg1 cursorPoint - positionOffset) - target topLeft.  arg1 shiftPressed ifTrue: [ tmp3 := tmp1 x / (originalExtent x max: 1) min: tmp1 y / (originalExtent y max: 1).        tmp1 := (originalExtent x * tmp3) asInteger @ (originalExtent y * tmp3) asInteger ].  (tmp1 x < 1 or: [ tmp1 y < 1 ]) ifTrue: [ ^self ].  target renderedMorph extent: (tmp2 := tmp1).  arg2 position: arg1 cursorPoint - (arg2 extent // 2).  self layoutChanged-======-focusBounds  ^self theme buttonFocusBoundsFor: self-======-isMouseOver  ^self type == #mouseOver-======-getCurrentSelectionIndex  getIndexSelector ifNil: [ ^0 ].  ^model perform: getIndexSelector-======-restoreAndActivate  self isMinimized ifTrue: [ self restore ].  self isActive ifFalse: [ self activate ]-======-removeFlexShell  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := self referencePosition.  tmp3 := self world.  tmp1 := self halo.  submorphs isEmpty ifTrue: [ ^self delete ].  tmp5 := (owner submorphIndexOf: self) ifNil: [ 1 ].  tmp2 := self firstSubmorph.  self submorphs do: [:arg1 |  arg1 position: self center - (arg1 extent // 2).        owner addMorph: arg1 asElementNumber: tmp5 ].  tmp1 ifNotNil: [ tmp1 setTarget: tmp2 ].  tmp3 ifNotNil: [ tmp3 startSteppingSubmorphsOf: tmp2 ].  self delete.  tmp2 referencePosition: tmp4.  ^tmp2-======-selectionColor  ^selectionColor-======-includesTableProperties  ^true-======-newBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newBracketSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8-======-needSeparatorBefore: arg1  | tmp1 |  arg1 <= 1 ifTrue: [ ^false ].  tmp1 := arg1.  self items do: [:arg2 |  arg2 size >= tmp1 ifTrue: [ ^tmp1 = 1 ] ifFalse: [ tmp1 := tmp1 - arg2 size ] ].  self errorSubscriptBounds: arg1-======-drawBackgroundOnAthensCanvas: arg1  (isSelected and: [ isEnabled ]) ifFalse: [ ^self ].  arg1 setPaint: self selectionFillStyle.  arg1 drawShape: (0 @ 0 extent: self extent)-======-lastKeystroke: arg1  ^self setProperty: #lastKeystroke toValue: arg1-======-lastColumnBounded  ^self lastColumnUnbounded not-======-selection  ^editor ifNotNil: [ editor selection ]-======-actions  ^actions-======-drawOn: arg1  arg1 fillOval: bounds fillStyle: self fillStyle borderWidth: borderWidth borderColor: borderColor-======-selfOrChildAt: arg1  ^arg1 = 1 ifTrue: [ self ] ifFalse: [ self childAt: arg1 - 1 ]-======-setMultipleContents  | tmp1 tmp2 tmp3 |  contentsWrapper removeAllMorphs.  self cleanProcesses.  tmp1 := toolbar orderedSelectedTabs.  tmp2 := tmp1 size.  tmp3 := 1 / tmp2.  tmp1 allButLast keysAndValuesDo: [:arg1 :arg2 |  self addTabContents: arg2 at: arg1 delta: tmp3 ].  self addLastTabContents: tmp1 last among: tmp2 delta: tmp3.  self addSplitterOn: tmp1 delta: tmp3-======-drawSubMorphOn: arg1  | tmp1 |  tmp1 := self bounds insetBy: (self cornerRadius + 3) @ (self topInactiveGap // 2 + 2).  tmp1 := tmp1 translateBy: 0 @ (self topInactiveGap // 2 + 1).  self active ifTrue: [ tmp1 := tmp1 translateBy: 0 @ (self topInactiveGap // 2 + 1) negated ].  self subMorph bounds height < tmp1 height ifTrue: [ tmp1 := tmp1 insetBy: 0 @ ((tmp1 height - self subMorph bounds height) // 2) ].  self subMorph bounds width < tmp1 width ifTrue: [ tmp1 := tmp1 insetBy: ((tmp1 width - self subMorph bounds width) // 2) @ 0 ].  self subMorph bounds: tmp1.  arg1 drawMorph: self subMorph-======-defaultGraphics  ^DefaultGraphics-======-bringBehind: arg1  | tmp1 |  tmp1 := self topRendererOrSelf.  tmp1 owner ifNil: [ ^self ].  tmp1 owner addMorph: tmp1 after: arg1 topRendererOrSelf.  self modalOwner ifNotNil: [:arg2 |  arg2 bringBehind: self ]-======-checkMorphsRightOrBottomFrom: arg1  | tmp1 |  tmp1 := submorphs identityIndexOf: arg1.  tmp1 := tmp1 - 1.  [ tmp1 > 0 ] whileTrue: [ | tmp2 tmp3 |        tmp2 := submorphs at: tmp1.        arg1 addRightOrBottom: tmp2.        tmp3 := self isResizeableMorph: tmp2 forSplitter: arg1.        tmp3 ifTrue: [ tmp1 := 0 ].        tmp1 := tmp1 - 1 ]-======-controlKeyPressed  ^buttons anyMask: 2r00010000-======-prepareForRotating  ^self addFlexShell-======-addFlexShell  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := self world.  tmp1 := self halo.  tmp4 := self owner submorphIndexOf: self.  self owner addMorph: (tmp2 := self newTransformationMorph asFlexOf: self) asElementNumber: tmp4.  self transferStateToRenderer: tmp2.  tmp1 ifNotNil: [ tmp1 setTarget: tmp2 ].  tmp3 ifNotNil: [ tmp3 startSteppingSubmorphsOf: tmp2 ].  ^tmp2-======-handlesMouseOverDragging: arg1  ^self dropEnabled-======-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-======-mouseLeaveDragging: arg1  (self dropEnabled and: [ arg1 hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: arg1 ].  self basicHighlightIndexes: #().  self refresh-======-handleKeystroke: arg1 inMorph: arg2  -======-wrapOnOff  self wrapFlag: wrapFlag not-======-pressedBorderStyle  ^self theme controlButtonPressedBorderStyleFor: self-======-aMorph  ^aMorph-======-newSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8-======-splitterRight  | tmp1 |  tmp1 := (self siblingSplitters select: [:arg1 |  arg1 left > self left and: [ self overlapsVertical: arg1 ] ]) asSortedCollection: [:arg2 :arg3 |  arg2 left < arg3 left ].  ^tmp1 ifEmpty: [ nil ] ifNotEmpty: [:arg4 |  arg4 first ]-======-listSpacing: arg1  self assureTableProperties listSpacing: arg1.  self layoutChanged-======-onImage  | tmp1 |  tmp1 := Form extent: (self fontToUse ascent - 2) asPoint depth: 16.  tmp1 getCanvas     frameAndFillRectangle: tmp1 boundingBox fillColor: (Color gray: 0.8) borderWidth: 1 borderColor: Color black;     fillRectangle: (tmp1 boundingBox insetBy: 2) fillStyle: Color black.  ^tmp1-======-expandItem  expanded := true.  children := (dataSource childrenFor: item) collect: [:arg1 |  self treeItemFor: arg1 ].  dataSource updateAvailableRows: self availableRows - 1-======-fillWithRamp: arg1 oriented: arg2  arg1 isColor ifTrue: [ self color: arg1 ] ifFalse: [ | tmp1 |        tmp1 := GradientFillStyle ramp: arg1.        tmp1 origin: self bounds topLeft.        tmp1 direction: (self bounds extent * arg2) truncated.        tmp1 radial: false.        self fillStyle: tmp1.        self borderColor: (arg1 first value mixed: 0.5 with: arg1 last value) muchDarker ]-======-adjustToHorizontalScrollBarValue: arg1  | tmp1 |  tmp1 := (self table numberOfColumns * arg1) rounded min: self table numberOfColumns max: 1.  tmp1 ~= self startColumnIndex ifTrue: [ self startColumnIndex: tmp1.        self changed ]-======-testUpdateEmptyTaskBarWithNewWindow  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: taskbar tasks size equals: 1-======-iconOrThumbnailOfSize: arg1  ^self iconOrThumbnail scaledIntoFormOfSize: arg1-======-handlesKeyboard: arg1  ^true-======-newFuzzyLabel: arg1  ^self theme newFuzzyLabelIn: self for: nil label: arg1 offset: 1 alpha: 0.5 getEnabled: nil-======-matches: arg1  self subclassResponsibility-======-debug  [ builder menuSpec asMenuMorph ] ensure: [ builder reset ]-======-world  ^world-======-mouseFocus: arg1  mouseFocus := arg1-======-mouseEnter: arg1  self canResizeColumn ifFalse: [ ^self ].  (owner notNil and: [ owner bounds containsPoint: arg1 position ]) ifTrue: [ super mouseEnter: arg1 ]-======-verticesAt: arg1 put: arg2  vertices at: arg1 put: arg2.  self computeBounds-======-newAColorMorph  ^AColorSelectorMorph new     model: self;     hResizing: #spaceFill;     vResizing: #rigid;     setValueSelector: #alphaSelected:;     extent: 24 @ 24-======-vShowScrollBar  self vIsScrollbarShowing ifTrue: [ ^self ].  self vResizeScrollBar.  self privateAddMorph: scrollBar atIndex: 1.  self resetExtent-======-menu: arg1 shifted: arg2  super menu: arg1 shifted: arg2.  arg1 addLine.  self selectedNode ifNotNil: [:arg3 |  arg3 menu: arg1 shifted: arg2.        arg1 addLine.        arg1 add: 'Expand all from here' target: self selector: #expandAllFromNode: argument: arg3 ].  ^arg1-======-mouseUp: arg1  needToggleAtMouseUp ifFalse: [ ^self ].  (self selectionModeStrategy selectableIndexContainingPoint: arg1 cursorPoint) ifNotNil: [:arg2 |  self selectIndex: arg2 event: arg1 ].  needToggleAtMouseUp := false-======-event  ^event-======-userString  ^list ifNotNil: [ String streamContents: [:arg1 |  list do: [:arg2 |  arg1                       nextPutAll: arg2 string;                       cr ] ] ]-======-layoutProperties  ^extension ifNotNil: [ extension layoutProperties ]-======-modifiedCharacter  self flag: #hack.  ^(self hasSpecialCTRLKeyValue and: [ #(MacOSX Windows) includes: Smalltalk os platformFamily ]) ifTrue: [ (self keyValue + $a asciiValue - 1) asCharacter ] ifFalse: [ Smalltalk os isWindows ifTrue: [ self keyCharacter asLowercase ] ifFalse: [ self keyCharacter ] ]-======-newGroupboxFor: arg1  ^self theme newGroupboxIn: self for: arg1-======-openInWindowLabeled: arg1 inWorld: arg2  self layoutInset: 0.  ^super openInWindowLabeled: arg1 inWorld: arg2-======-isAutoFit  ^false-======-removeWindow: arg1  windows remove: arg1-======-useSecondarySelection  ^false-======-mouseEnter: arg1  super mouseEnter: arg1.  self over: true-======-selectAll  self isMultipleSelection ifFalse: [ ^self ].  1 to: self maximumSelection do: [:arg1 |  self listSelectionAt: arg1 put: true ]-======-getListSelector  ^getListSelector-======-basicBorderColor: arg1  borderColor := arg1-======-newAutoAcceptTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 font: arg6 help: arg7-======-view: arg1  -======-defaultButton  ^IconicButton new     target: self;     color: Color transparent;     borderWidth: 0;     yourself-======-selectedIndex  ^self selectedIndexes ifNotEmpty: #first ifEmpty: [ self selectionModeStrategy nullIndex ]-======-negateBottomRightOffsets  bottomOffset := bottomOffset negated.  rightOffset := rightOffset negated-======-keyStroke: arg1  ^false-======-mouseLeaveDragging: arg1  super mouseLeaveDragging: arg1.  self over: false-======-assureExtension  extension ifNil: [ self initializeExtension ].  ^extension-======-vSetScrollDelta  | tmp1 tmp2 |  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  tmp2 := self scrollDeltaHeight.  tmp1 := self vLeftoverScrollRange.  tmp1 = 0 ifTrue: [ ^scrollBar           scrollDelta: 0.02 pageDelta: 0.2;           interval: 1.0;           setValue: 0 ].  scrollBar scrollDelta: (tmp2 / tmp1) asFloat pageDelta: ((self innerBounds height - tmp2) / tmp1) asFloat.  scrollBar interval: (self innerBounds height / self vTotalScrollRange) asFloat.  scrollBar setValue: (scroller offset y / tmp1 min: 1.0) asFloat-======-passenger: arg1  passenger := arg1-======-paneWithLongestSide: arg1 near: arg2  | tmp1 tmp2 tmp3 |  tmp3 := 0.  paneMorphs do: [:arg3 |  | tmp4 |        tmp4 := arg3 bounds.        tmp4 forPoint: arg2 closestSideDistLen: [:arg4 :arg5 :arg6 |  (arg5 <= 5 and: [ arg6 > tmp3 ]) ifTrue: [ tmp1 := arg3.                    tmp2 := arg4.                    tmp3 := arg6 ] ] ].  arg1 value: tmp2.  ^tmp1-======-emptySelection  self selectedMorphList do: [:arg1 |  arg1           unhighlight;           setSelectedSilently: false ].  self selectedMorphList removeAll.  self selectionChanged-======-hasUnacceptedEdits: arg1  -======-toggleEnabled  self enabled: self enabled not-======-newSeparator  ^self theme newSeparatorIn: self-======-leftArrowStroked: arg1  popUpOwner ifNil: [ ^self ].  ^self deselectAndFocusOutermenuOn: arg1-======-unsort  self unsortElements.  self table refresh-======-nextState  ^FTDescendingSortingState context: self context-======-getLabelSelector  ^getLabelSelector-======-enabled: arg1  enabled = arg1 ifTrue: [ ^self ].  enabled := arg1.  self changed: #enabled.  self     adoptPaneColor: self paneColor;     changed-======-currentCursor  ^ActiveHand world currentCursor-======-imageFromName: arg1  ^self images at: arg1 ifPresent: [:arg2 |  arg2 value ] ifAbsent: [  ]-======-isClosed  ^closed-======-topLeftColor  ^width = 1 ifTrue: [ self color twiceLighter ] ifFalse: [ self color lighter ]-======-displayWorld  worldState displayWorld: self submorphs: submorphs-======-findDeepSubmorphThat: arg1 ifAbsent: arg2  self allMorphsDo: [:arg3 |  (arg1 value: arg3) == true ifTrue: [ ^arg3 ] ].  ^arg2 value-======-selected  ^state selected-======-addToggleItemsToHaloMenu: arg1  super addToggleItemsToHaloMenu: arg1.  arg1 addUpdating: #enabledString target: self selector: #toggleEnabled-======-defaultColor  ^Color white-======-isRight  ^direction = Character arrowRight-======-formerPosition  ^self valueOfProperty: #formerPosition-======-initialize  super initialize.  hasFocus := false.  self initializeScrollBars.  self extent: self defaultExtent.  self hideOrShowScrollBars-======-addHandleAt: arg1 color: arg2 icon: arg3 on: arg4 send: arg5 to: arg6  | tmp1 |  tmp1 := self createHandleAt: arg1 color: arg2 iconName: arg3.  self addMorph: tmp1.  tmp1 on: #mouseUp send: #endInteraction to: self.  tmp1 on: arg4 send: arg5 to: arg6.  tmp1 setBalloonText: (target balloonHelpTextForHandle: tmp1) translated.  ^tmp1-======-steppingMorphsNotInWorld  | tmp1 |  tmp1 := self allMorphs.  ^self listOfSteppingMorphs reject: [:arg1 |  tmp1 includes: arg1 ]-======-enableFilter  function := FTFilterFunction table: self-======-selectPreviousTab  self selectedIndex: (self selectedIndex < 2 ifTrue: [ self tabs size ] ifFalse: [ self selectedIndex - 1 ])-======-wantsYellowButtonMenu  self valueOfProperty: #wantsYellowButtonMenu ifPresentDo: [:arg1 |  ^arg1 ].  self isInSystemWindow ifTrue: [ ^false ].  ^self defaultYellowButtonMenuEnabled-======-model  ^nil-======-on: arg1 send: arg2 to: arg3 withValue: arg4  arg2 numArgs = 3 ifFalse: [ self error: 'Warning: value parameters are passed as first of 3 arguments' ].  self addSubscription: (MorphEventSubscription on: arg1 send: arg2 to: arg3 withValue: arg4) toEvent: arg1-======-truncatedMenuLabelFor: arg1  ^arg1 truncateWithElipsisTo: 47-======-selectedNodePathList: arg1  selectedNodePathList := arg1-======-newBalloonHelp: arg1 for: arg2  ^self theme newBalloonHelpIn: self contents: arg1 for: arg2 corner: #bottomLeft-======-unshiftedYellowButtonActivity  ^self yellowButtonActivity: false-======-keyStroke: arg1  | tmp1 |  owner isHandMorph ifFalse: [ ^self ].  tmp1 := arg1 keyValue.  tmp1 = 28 ifTrue: [ ^self position: self position - (1 @ 0) ].  tmp1 = 29 ifTrue: [ ^self position: self position + (1 @ 0) ].  tmp1 = 30 ifTrue: [ ^self position: self position - (0 @ 1) ].  tmp1 = 31 ifTrue: [ ^self position: self position + (0 @ 1) ].  tmp1 = 13 ifTrue: [ owner releaseKeyboardFocus: self.        self delete ]-======-testSelectLast  table selectLast.  self assert: table selectedIndexes equals: #(10)-======-selectIndexes: arg1 andMakeVisibleIf: arg2  | tmp1 |  arg1 = self selectedIndexes ifTrue: [ ^self ].  tmp1 := self selectedIndexes.  self basicSelectIndexes: arg1.  arg2 ifTrue: [ self ensureVisibleFirstSelection ].  self refresh.  self doAnnounce: ((FTSelectionChanged from: tmp1 to: self selectedIndexes)           fastTable: self;           yourself)-======-privateFullMoveBy: arg1  self privateMoveBy: arg1.  submorphs do: [:arg2 |  arg2 privateFullMoveBy: arg1 ]-======-updateImage  (self model notNil and: [ self getImageSelector notNil ]) ifTrue: [ (self model perform: self getImageSelector) ifNotNil: [:arg1 |  self image: arg1 ] ]-======-createExpandBox  ^self theme createExpandBoxFor: self-======-spotterWindowsFor: arg1  < spotterOrder: 100>  arg1 listProcessor     title: 'Windows';     allCandidates: [ self class allSubInstances ];     itemName: [:arg2 |  '**' , arg2 label , '**' ];     filter: GTFilterSubstring-======-vHideOrShowScrollBar  self vIsScrollbarNeeded ifTrue: [ self vShowScrollBar ] ifFalse: [ self vHideScrollBar ]-======-children  | tmp1 |  tmp1 := OrderedCollection new.  self childrenDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1-======-keyStroke: arg1  (super keyStroke: arg1) ifTrue: [ ^true ].  self keystrokeSelector ifNotNil: [ (self keyStrokeAction: arg1) ifTrue: [ ^true ] ].  (self keystrokeActionSelector notNil and: [ arg1 anyModifierKeyPressed ]) ifTrue: [ (self keyStrokeModifierAction: arg1) ifTrue: [ ^true ] ].  ^false-======-cachedForm  | tmp1 tmp2 tmp3 |  cachedForm ifNil: [ tmp2 := self scaledImage.        tmp3 := self enabled ifTrue: [ self alpha ] ifFalse: [ self alpha / 2 ].        tmp3 = 1.0 ifTrue: [ self cachedForm: tmp2 ] ifFalse: [ tmp1 := Form extent: tmp2 extent depth: 32.              tmp1 fillColor: (Color white alpha: 0.003922).              (tmp1 getCanvas asAlphaBlendingCanvas: tmp3) drawImage: tmp2 at: 0 @ 0.              self cachedForm: tmp1 ] ].  ^cachedForm-======-newColumn: arg1  ^self theme newColumnIn: self for: arg1-======-reversedSelectedTabs  ^selectionHistory last: numberOfSelectedTabs-======-openInExternalWindow  | tmp1 |  tmp1 := OSWindowWorldMorph new extent: self fullBounds extent.  tmp1     layoutPolicy: ProportionalLayout new;     clipSubmorphs: true.  self     hResizing: #spaceFill;     vResizing: #spaceFill.  self openInWorld: tmp1.  self onAnnouncement: MorphDeleted do: [:arg1 |  tmp1 ifNotNil: [ tmp1 delete ].        tmp1 := nil ].  ^tmp1 open-======-removePendingBalloonFor: arg1  self removeAlarm: #spawnBalloonFor:.  self deleteBalloonTarget: arg1-======-expandAllSuchThat: arg1  self roots do: [:arg2 |  self expand: arg2 suchThat: arg1 ].  self innerWidgetChanged-======-setSwitchState: arg1  arg1 ifTrue: [ self turnOn ] ifFalse: [ self turnOff ]-======-tabKey: arg1  arg1 controlKeyPressed ifFalse: [ arg1 keyCharacter = Character tab ifTrue: [ arg1 shiftPressed ifTrue: [ self navigateFocusBackward ] ifFalse: [ self navigateFocusForward ].              ^true ] ].  ^false-======-newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4  ^self newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: nil-======-alpha: arg1  alpha := arg1.  self changed-======-hue: arg1  | tmp1 |  tmp1 := self selectedColor.  self selectedColor: ((Color h: (arg1 / 255 * 359) rounded s: tmp1 saturation v: tmp1 brightness) alpha: tmp1 alpha)-======-testIndexesToSelectInMultipleSelectionFromTo  self subclassResponsibility-======-borderWidth: arg1  borderColor ifNil: [ borderColor := Color black ].  borderWidth := arg1 max: 0.  self computeBounds-======-getEnabledSelector: arg1  getEnabledSelector := arg1.  self updateEnabled-======-submorphBounds  | tmp1 |  submorphs do: [:arg1 |  | tmp2 |        arg1 visible ifTrue: [ tmp2 := arg1 fullBounds.              tmp1 ifNil: [ tmp1 := tmp2 copy ] ifNotNil: [ tmp1 := tmp1 quickMerge: tmp2 ] ] ].  tmp1 ifNil: [ ^self bounds ].  ^tmp1 origin asIntegerPoint corner: tmp1 corner asIntegerPoint-======-isPartialMatch  ^self complexContents isPartialMatch-======-dropItemSelector: arg1  self dataSource dropItemSelector: arg1-======-onWindowLabelChanged: arg1  self tabGroup relabelPage: arg1 window with: (self tabLabelFor: arg1 window)-======-potentialDropMorph: arg1  potentialDropMorph := arg1-======-activateCursor: arg1 withMask: arg2  -======-imageExport  ^self form bits asArray-======-maximumSelection  ^scroller submorphs size-======-vanishAfterSlidingTo: arg1 event: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self imageForm offset: 0 @ 0.  tmp2 := self world.  tmp3 := arg2 hand fullBounds origin.  self delete.  tmp2 displayWorld.  tmp4 := arg1.  tmp1 slideFrom: tmp3 to: tmp4 nSteps: 12 delay: 15-======-yellowButtonPressed  ^buttons anyMask: self class yellowButton-======-drawOn: arg1  super drawOn: arg1.  (ActiveHand notNil and: [ ActiveHand keyboardFocus == self and: [ self rootMenu hasProperty: #hasUsedKeyboard ] ]) ifTrue: [ arg1 frameAndFillRectangle: self innerBounds fillColor: Color transparent borderWidth: self theme menuBorderWidth borderColor: self theme menuKeyboardFocusColor ]-======-maximumSelection  ^self getListSize-======-newMenu  ^self theme newMenuIn: self for: self-======-selectFirst  self table selectIndex: #(1 1)-======-gridOrigin: arg1  ^self gridSpecPut: (arg1 extent: self gridModulus)-======-borderColor: arg1  super borderColor: arg1.  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) == (arg1 isColor and: [ arg1 isTranslucentButNotTransparent ]) ifFalse: [ self releaseCachedState ]-======-is: arg1 bellowRow: arg2  ^arg1 > arg2-======-hResizeScrollBar  super hResizeScrollBar.  hScrollBar bounds: ((hScrollBar bounds withTop: hScrollBar top - self pagerHeight) withBottom: hScrollBar bottom - self pagerHeight)-======-taskbarButtonMenu: arg1  | tmp1 tmp2 tmp3 |  tmp2 := self theme.  tmp1 := tmp2 newMenuIn: self for: self.  tmp1 addToggle: 'Restore' translated target: self selector: #restore getStateSelector: nil enablementSelector: #isNotRestored.  tmp1 lastItem     icon: self theme windowMaximizeForm;     font: tmp2 menuFont.  tmp1 addToggle: 'Minimize' translated target: self selector: #minimize getStateSelector: nil enablementSelector: #isNotMinimized.  tmp1 lastItem     icon: self theme windowMinimizeForm;     font: tmp2 menuFont.  tmp1 addToggle: 'Maximize' translated target: self selector: #maximize getStateSelector: nil enablementSelector: #canBeMaximized.  tmp1 lastItem     icon: self theme windowMaximizeForm;     font: tmp2 menuFont.  tmp1 addLine.  tmp3 := tmp2 newMenuIn: self for: self.  tmp1 add: 'Close all' icon: self theme windowCloseForm subMenu: tmp3.  tmp3 addToggle: 'windows to right' translated target: self selector: #taskbarCloseAllToRight getStateSelector: nil enablementSelector: true.  tmp3 addToggle: 'windows like this' translated target: self selector: #taskbarCloseAllLikeThis getStateSelector: nil enablementSelector: true.  tmp3 addToggle: 'unchanged windows' translated target: self currentWorld selector: #closeAllUnchangedWindows getStateSelector: nil enablementSelector: true.  tmp3 addToggle: 'close all debuggers' translated target: Smalltalk tools debugger selector: #closeAllDebuggers getStateSelector: nil enablementSelector: true.  tmp1 addToggle: 'Close' translated target: self selector: #closeBoxHit getStateSelector: nil enablementSelector: #allowedToClose.  tmp1 lastItem     icon: self theme windowCloseForm;     font: tmp2 menuFont.  ^tmp1-======-couldHaveRoundedCorners  ^false-======-font: arg1  self labelMorph font: arg1-======-cellInset  ^0-======-normalFillStyle  ^self theme splitterNormalFillStyleFor: self-======-tearDown  morph delete.  super tearDown-======-drawOnAthensCanvas: arg1  self getListSize = 0 ifTrue: [ ^self ].  self setColumnWidthsFor: arg1.  self adjustWidth.  super drawOnAthensCanvas: arg1-======-newHatchMorph  ^Morph new     color: Color transparent;     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     minWidth: 48;     minHeight: 12;     addMorph: (Morph new color: Color white) fullFrame: (0 @ 0 corner: 0.3 @ 1) asLayoutFrame;     addMorph: (Morph new fillStyle: (InfiniteForm with: self hatchForm)) fullFrame: (0.3 @ 0 corner: 0.7 @ 1) asLayoutFrame;     addMorph: self solidLabelMorph fullFrame: (0.7 @ 0 corner: 1 @ 1) asLayoutFrame;     addMorph: self labelMorph fullFrame: (0 @ 0 corner: 1 @ 1) asLayoutFrame-======-dismissMorph  | tmp1 |  tmp1 := self world ifNil: [ ^self ].  tmp1 stopStepping: self.  self delete-======-extent: arg1  self adjustAfter: [ | tmp1 |        tmp1 := self scale * arg1 r / self fullBounds extent r max: 0.1.        self scale: (tmp1 detentBy: 0.1 atMultiplesOf: 1.0 snap: false) ]-======-defaultImageFormOfSize: arg1  ^(defaultImageForm isNil or: [ defaultImageForm extent ~= arg1 ]) ifTrue: [ defaultImageForm := Form extent: arg1 ] ifFalse: [ defaultImageForm ]-======-sliderThickness  ^7-======-testHeading  | tmp1 |  cases := {(tmp1 := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ [ self assert: tmp1 heading equals: 0.0 ] ensure: [ tmp1 delete ] ]-======-setListFont  StandardFonts chooseFontWithTitle: 'Choose the font for this list' translated for: self setSelector: #font: getSelector: #font-======-menuColumn: arg1 row: arg2  | tmp1 |  self getMenuSelector ifNil: [ ^nil ].  tmp1 := UIManager default newMenuIn: self table for: self model.  self getMenuSelector numArgs = 1 ifTrue: [ ^self model perform: self getMenuSelector with: tmp1 ].  ^self model perform: self getMenuSelector with: tmp1 with: false-======-clipboardText: arg1  ^self osWindow clipboardText: arg1-======-newHColorMorph  ^HColorSelectorMorph new     model: self;     setValueSelector: #hue:;     hResizing: #rigid;     vResizing: #spaceFill;     extent: 36 @ 36-======-getListElementSelector  ^self dataSource getListElementSelector-======-minWidth  | tmp1 tmp2 tmp3 |  tmp1 := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  tmp2 := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  tmp3 := tmp1 ifTrue: [ tmp2 ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness * 3 ] ] ifFalse: [ tmp2 ifTrue: [ self scrollBarThickness + 20 ] ifFalse: [ self scrollBarThickness * 3 + 2 ] ].  ^tmp3 max: super minWidth-======-requestDropReference: arg1  | tmp1 |  fileNames ifNil: [ ^FileReference requestDropReference: arg1 ].  tmp1 := self fileNames at: arg1.  ^(FilePathEncoder decode: tmp1) asFileReference-======-explicitFunction  function showWidget-======-outerBounds  ^self bounds-======-cellPositioning: arg1  cellPositioning := arg1-======-actionOffset  ^4 * self displayScaleFactor-======-wantsHaloFromClick  ^true-======-removeKeyCombination: arg1  self kmDispatcher removeKeyCombination: arg1-======-wantsToBeTopmost  ^false-======-listDirection: arg1  listDirection := arg1-======-beStraightSegments  smoothCurve == false ifFalse: [ smoothCurve := false.        self computeBounds ]-======-wantsWindowEvent: arg1  ^true-======-setColor: arg1  self labelMorph color: arg1.  self solidLabelMorph color: arg1 beOpaque-======-testWhenChangingOrderInWorldListTaskOrderShouldRemains  | tmp1 tmp2 |  taskbar := self.  world := self.  tmp1 := world addWindow.  tmp2 := world addWindow.  taskbar updateTasks.  world putOnTop: tmp1.  taskbar updateTasks.  self assert: taskbar tasks first morph equals: tmp1.  self assert: taskbar tasks second morph equals: tmp2-======-selectMoreAtTop  | tmp1 |  autoTargetMorph ifNil: [ ^self ].  tmp1 := autoTargetMorph index.  tmp1 > 1 ifTrue: [ self autoMultiSelect: (self allNodeMorphs at: tmp1 - 1).        self selectionChanged ]-======-actionSelector  ^actionSelector-======-adoptGradientColor: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  arg1 ifNil: [ ^self ].  tmp1 := arg1.  tmp2 := self normalThumbFillStyle.  tmp3 := self normalButtonFillStyle.  tmp4 := self normalThumbBorderStyle.  tmp5 := self normalButtonBorderStyle.  sliderColor := tmp1.  downButton     fillStyle: tmp3;     borderStyle: tmp5.  upButton     fillStyle: tmp3 shallowCopy;     borderStyle: tmp5.  slider     fillStyle: tmp2;     borderStyle: tmp4.  self updateUpButtonImage.  self updateDownButtonImage-======-newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 getLabel: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 getLabel: arg6 help: arg7-======-setTabContentFrom: arg1  | tmp1 |  contentsWrapper removeAllMorphs.  self cleanProcesses.  tmp1 := arg1 retrieveMorph: [:arg2 |  arg2 ifNil: [ TabWithNoContents signalTab: arg1 ].        contentsWrapper addMorph: arg2 fullFrame: LayoutFrame identity ].  tmp1 ifNotNil: [ processes add: tmp1 ]-======-outermostMorphThat: arg1  | tmp1 |  self allOwnersDo: [:arg2 |  (arg1 value: arg2) ifTrue: [ tmp1 := arg2 ] ].  ^tmp1-======-getColorSelector: arg1  getColorSelector := arg1-======-wantsDroppedMorph: arg1 event: arg2  ^arg1 dragTransferType == #dragTransfer ifTrue: [ super wantsDroppedMorph: arg1 event: arg2 ] ifFalse: [ self model wantsDroppedMorph: arg1 event: arg2 inMorph: self ]-======-minHeight  | tmp1 |  tmp1 := self hasIcon ifTrue: [ self icon height + 2 ] ifFalse: [ 0 ].  ^((self contents heightToDisplayInTree: self) max: tmp1) max: super minHeight-======-wantsHaloHandleWithSelector: arg1 inHalo: arg2  (#(addDismissHandle:) includes: arg1) ifTrue: [ ^self resistsRemoval not ].  (#(addDragHandle:) includes: arg1) ifTrue: [ ^self okayToBrownDragEasily ].  (#(addGrowHandle: addScaleHandle:) includes: arg1) ifTrue: [ ^self okayToResizeEasily ].  (#(addRotateHandle:) includes: arg1) ifTrue: [ ^self okayToRotateEasily ].  (#(addRecolorHandle:) includes: arg1) ifTrue: [ ^self renderedMorph wantsRecolorHandle ].  ^true-======-transform: arg1 from: arg2 andSendTo: arg3  | tmp1 |  tmp1 := arg1 transformedBy: (arg3 transformedFrom: arg2 hand).  ^arg3 handleEvent: tmp1-======-releaseKeyboardFocus: arg1  self keyboardFocus == arg1 ifTrue: [ self releaseKeyboardFocus ]-======-computedBounds  | tmp1 tmp2 tmp3 |  tmp1 := treeMorph bounds.  tmp2 := treeMorph borderWidth.  tmp3 := self layoutInset asPoint y + self cellInset asPoint y.  ^tmp1 bottomLeft + (tmp2 @ (self computedHeight + tmp3) negated) corner: tmp1 bottomRight - ((tmp2 * 2) @ tmp3)-======-newHueSelector: arg1 getHue: arg2 setHue: arg3 help: arg4  ^self theme newHueSelectorIn: self for: arg1 getHue: arg2 setHue: arg3 help: arg4-======-nextPage: arg1  | tmp1 |  arg1 > self lastIndex ifFalse: [ ^self ].  self lastIndex < self nodeList size ifTrue: [ tmp1 := self nodeList copyFrom: 1 to: arg1.        self lastIndex: arg1.        treeMorph scroller removeAllMorphs.        treeMorph addSubmorphsFromNodeList: tmp1 previouslyExpanded: treeMorph currentlyExpanded ]-======-isAdheringToRight  ^self edgeToAdhereTo == #right-======-hasSelection  ^self selectedIndexes isNotEmpty-======-generateKeyboardEvent: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp5 := arg1 second.  tmp5 = 0 ifTrue: [ tmp5 := Time millisecondClockValue ].  tmp4 := arg1 fourth.  tmp4 = EventKeyDown ifTrue: [ tmp3 := #keyDown.        lastKeyScanCode := arg1 third ].  tmp4 = EventKeyUp ifTrue: [ tmp3 := #keyUp ].  tmp4 = EventKeyChar ifTrue: [ tmp3 := #keystroke ].  tmp2 := arg1 fifth.  tmp1 := tmp2 bitShift: 3.  tmp7 := arg1 third.  tmp6 := arg1 sixth.  tmp3 = #keystroke ifTrue: [ combinedChar ifNil: [ | tmp9 |              tmp9 := Sensor peekEvent.              (tmp9 notNil and: [ tmp9 fourth = EventKeyDown ]) ifTrue: [ (CombinedChar isCompositionCharacter: tmp6) ifTrue: [ combinedChar := CombinedChar new.                          combinedChar simpleAdd: tmp6 asCharacter.                          (combinedChar combinesWith: tmp9 third asCharacter) ifTrue: [ ^nil ] ] ] ] ifNotNil: [ (combinedChar simpleAdd: tmp6 asCharacter) ifTrue: [ tmp6 := combinedChar combined charCode ].              combinedChar := nil ] ].  (tmp3 = #keystroke and: [ (tmp1 anyMask: 16) and: [ {Character arrowUp .               Character arrowDown} includes: tmp6 asCharacter ] ]) ifTrue: [ ^MouseWheelEvent fromCharacter: tmp6 asCharacter position: lastMouseEvent cursorPoint buttons: tmp1 hand: self stamp: tmp5 ].  self flag: #pharoFixMe.  (tmp6 notNil and: [ tmp6 > 255 ]) ifTrue: [ tmp7 := 0 ].  tmp8 := KeyboardEvent new setType: tmp3 buttons: tmp1 position: self position keyValue: tmp7 charCode: tmp6 hand: self stamp: tmp5.  tmp8 scanCode: lastKeyScanCode.  ^tmp8-======-mouseLeave: arg1  ^self eventHandler ifNotNil: [ self eventHandler mouseLeave: arg1 fromMorph: self ]-======-leftLayoutFrame  ^(0 @ 0 corner: 0 @ 1) asLayoutFrame     topOffset: -7;     bottomRightOffset: SystemWindow borderWidth @ (SystemWindow borderWidth - 26)-======-selectMorph: arg1 multiple: arg2 clickedTheCheckBox: arg3  | tmp1 tmp2 |  arg3 ifFalse: [ self lastClickedMorph: arg1 ].  arg1 ifNil: [ self emptySelection.        ^nil ].  arg1 selected ifTrue: [ arg2 ifTrue: [ self removeFromSelection: arg1 ] ifFalse: [ tmp2 := self selectedMorphList size > 1.              tmp1 := arg1 path collect: [:arg4 |  arg4 complexContents ].              (self autoDeselection or: [ tmp2 ]) ifTrue: [ self emptySelection.                    tmp2 ifTrue: [ self addToSelection: arg1 ] ifFalse: [ tmp1 := nil ] ] ] ] ifFalse: [ arg2 ifFalse: [ self emptySelection ].        self addToSelection: arg1 clickedTheCheckBox: arg3.        tmp1 := arg1 path collect: [:arg4 |  arg4 complexContents ] ].  self selectionChanged.  ^tmp1-======-takesKeyboardFocus  ^true-======-releaseCachedState  self borderStyle releaseCachedState-======-labelMorph  ^labelMorph-======-drawDropHighlightOn: arg1  self highlightedForDrop ifTrue: [ arg1 frameRectangle: self fullBounds color: self dropHighlightColor ]-======-item: arg1  item := arg1-======-newOKButton  ^self newOKButtonFor: self-======-shouldFlex  ^true-======-layoutFrame: arg1  layoutFrame := arg1-======-borderStyleToUse  ^self isRadioButton ifTrue: [ self radioBorderStyleToUse ] ifFalse: [ self checkboxBorderStyleToUse ]-======-newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: true help: arg6-======-adoptPaneColor: arg1  self color: arg1-======-adjustBorderUponDeactivationWhenLabeless  | tmp1 |  (tmp1 := self valueOfProperty: #borderWidthWhenInactive) ifNotNil: [ self acquireBorderWidth: tmp1 ]-======-enabled: arg1  arg1 = self enabled ifFalse: [ enabled := arg1.        self           adoptPaneColor: self paneColor;           changed ]-======-balloonText  extension ifNil: [ ^nil ].  ^extension balloonText ifNotNil: [:arg1 |  arg1 asString withNoLineLongerThan: self theme settings maxBalloonHelpLineLength ]-======-drawWithSelectionOn: arg1  arg1 line: self bottomLeft + (0 @ -1) to: self selectedTab bottomLeft width: 1 color: self borderColor.  arg1 line: self selectedTab bottomLeft to: self selectedTab bottomRight width: 1 color: self selectedColor.  arg1 line: self selectedTab bottomRight to: self bottomRight + (0 @ -1) width: 1 color: self borderColor-======-setDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) rounded-======-allowsKeymapping  ^self valueOfProperty: #allowsKeymapping ifAbsent: [ true ]-======-originColumn: arg1 row: arg2  ^FTCellMorph new     color: (self colorFor: arg2);     addMorph: (self elementAt: arg2) origin name asMorph;     yourself-======-paneColor  ^self paneColorOrNil ifNil: [ self color ]-======-mouseUp: arg1  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: arg1 cursorPoint) ifFalse: [ arg1 hand showTemporaryCursor: nil ].  self class fastSplitterResize ifTrue: [ self updateFromEvent: arg1 ].  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUp-======-buildVerticesFrom: arg1  ^state buildVerticesFrom: arg1-======-scrollPane  ^scrollPane-======-mouseOverBorderStyle  ^mouseOverBorderStyle ifNil: [ BorderStyle thinGray ]-======-selectedLabel  ^selectedLabel-======-canvas: arg1  -======-useExtraSelection  ^self useFindReplaceSelection or: [ self useSecondarySelection ]-======-themeChanged  self fillStyle: self normalFillStyle.  super themeChanged-======-complexContents  ^complexContents-======-addInterruptionButton  self isInterruptable ifFalse: [ ^self ].  self addMorphBack: (self iconNamed: #stopIcon) asMorph-======-hand  ^source-======-shouldDraw  ^super shouldDraw or: [ self class showSplitterHandles ]-======-mouseEnterDragging: arg1  arg1 hand mouseFocus == owner ifTrue: [ owner selectItem: self event: arg1 ]-======-bounds: arg1 in: arg2  owner ifNil: [ ^arg1 ].  ^(owner transformFrom: arg2) localBoundsToGlobal: arg1-======-transformBy: arg1  position := arg1 globalPointToLocal: position-======-getEnabledSelector  ^getEnabledSelector-======-index: arg1  index := arg1-======-resizeCursor  ^Cursor resizeForEdge: (splitsTopAndBottom ifTrue: [ #top ] ifFalse: [ #left ])-======-asAthensCurvedPathOn: arg1  | tmp1 |  tmp1 := self computeCurvedSegmentCtrlPoints.  ^arg1 createPath: [:arg2 |  self vertices notEmpty ifTrue: [ | tmp2 |              tmp2 := tmp1 first.              arg2 absolute.              arg2 moveTo: tmp2 second.              tmp1 allButFirst do: [:arg3 |  arg2 curveVia: tmp2 third and: arg3 first to: arg3 second.                    tmp2 := arg3 ].              self isClosed ifTrue: [ arg2 curveVia: tmp2 third and: tmp1 first first to: tmp1 first second.                    arg2 close ] ].        arg2 ]-======-bottomFraction  ^bottomFraction-======-newHSVSelector: arg1 help: arg2  ^self theme newHSVSelectorIn: self color: arg1 help: arg2-======-handlesKeyboard: arg1  ^true-======-getLabelSelector: arg1  getLabelSelector := arg1.  self updateLabel-======-hasProperty: arg1  extension ifNil: [ ^false ].  ^extension hasProperty: arg1-======-intoWorldCount  ^intoWorldCount-======-labelString  ^label ifNil: [ labelString ] ifNotNil: [ label contents asString ]-======-getListItem: arg1  ^listSource getListRow: arg1-======-addToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 argumentList: arg5  self addToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 enablementSelector: nil argumentList: arg5-======-navigateWindowBackward  self previousWindow ifNotNil: [:arg1 |  arg1 isCollapsed ifTrue: [ arg1 collapseOrExpand ].        arg1 activate ]-======-icon: arg1  icon := arg1-======-adoptPaneColor: arg1  (arg1 notNil and: [ self trackPaneColor ]) ifTrue: [ self color: arg1 ].  super adoptPaneColor: arg1-======-selectedObject  | tmp1 |  tmp1 := self halo.  tmp1 ifNil: [ ^nil ].  ^tmp1 target renderedMorph-======-contents  ^text-======-activeSubmenu: arg1  activeSubMenu ifNotNil: [ activeSubMenu delete ].  activeSubMenu := arg1.  arg1 ifNil: [ ^self ].  activeSubMenu selectItem: nil event: nil.  activeSubMenu borderColor: self borderColor.  activeSubMenu beSticky.  activeSubMenu resistsRemoval: true.  activeSubMenu removeMatchString-======-setProperty: arg1 toValue: arg2  self assureOtherProperties at: arg1 put: arg2-======-showFirstSelection  self hasSelection ifFalse: [ ^self ].  self moveShowIndexTo: self selectedIndex-======-hasContents  ^self contents isEmpty not-======-lastVertex  ^vertices last-======-removeMorph: arg1  | tmp1 |  arg1 owner == self ifFalse: [ ^self ].  tmp1 := self world.  tmp1 ifNotNil: [ arg1 outOfWorld: tmp1.        self privateInvalidateMorph: arg1 ].  self privateRemove: arg1.  arg1 privateOwner: nil.  self removedMorph: arg1-======-handlesMouseDown: arg1  ^true-======-selectedPressedBorderStyle  ^self theme controlButtonSelectedPressedBorderStyleFor: self-======-highlightSelection  selectedMorph ifNotNil: [ selectedMorph highlight ]-======-max  ^(self sliderMorph ifNil: [ ^0 ]) max-======-newTabSelectorMorph  ^TabSelectorMorph new     vResizing: #shrinkWrap;     hResizing: #spaceFill-======-announceDate  | tmp1 |  tmp1 := ChoseDate of: self date from: self.  announcer ifNotNil: [ announcer announce: tmp1 ]-======-setColor: arg1 toHandle: arg2  arg2 color: arg1.  self gradientHalo ifTrue: [ | tmp1 |        tmp1 := GradientFillStyle ramp: {(0.0 -> arg1 muchLighter) .               (1.0 -> arg1 darker)}.        tmp1 origin: arg2 topLeft.        tmp1 direction: arg2 extent.        arg2 fillStyle: tmp1 ]-======-isCloseable  ^self mustNotClose not and: [ model ifNotNil: [ model okToChange ] ifNil: [ true ] ]-======-selectLast  self table selectIndex: self table numberOfRows-======-objectToPaste  ^Cursor wait showWhile: [ PasteBuffer veryDeepCopy ]-======-halo  ^self primaryHand halo ifNotNil: [:arg1 |  arg1 target == self ifTrue: [ arg1 ] ]-======-themeChanged  self     removeAllMorphs;     initializeSlider.  super themeChanged-======-initialize  super initialize.  self cellInset: 7-======-setValue: arg1  self value: arg1.  setValueSelector ifNotNil: [ ^model perform: setValueSelector with: value ]-======-target  ^objectToView-======-shadowPoint: arg1  self changed.  self shadowOffset: (arg1 - self center) // 5.  fullBounds ifNotNil: [ fullBounds := self privateFullBounds ].  self changed-======-disable  self enabled: false-======-athensDisplay: arg1 atRow: arg2 on: arg3  | tmp1 tmp2 tmp3 |  tmp3 := self drawBoundsForRow: arg2.  tmp1 := self colorForRow: arg2.  tmp2 := self backgroundColorForRow: arg2.  arg1 listRenderOn: arg3 asCanvasWrapper atRow: arg2 bounds: tmp3 color: tmp1 backgroundColor: tmp2 from: self.  arg2 = self mouseDownRow ifTrue: [ (arg3 setStrokePaint: tmp1)           width: 1;           dashes: {1} offset: 0.        arg3 drawShape: (self selectionFrameForRow: arg2) ]-======-color: arg1  super color: arg1.  self setProperty: #basicColor toValue: arg1-======-themeChanged  self onImage: (self isRadioButton ifTrue: [ self theme radioButtonMarkerForm ] ifFalse: [ self theme checkboxMarkerForm ]).  self adoptPaneColor: self paneColor.  super themeChanged-======-separatorAfterARow: arg1  arg1 ifNil: [ ^false ].  self separatorBlockOrSelector ifNotNil: [:arg2 |  | tmp1 |        tmp1 := getListElementSelector ifNil: [ list at: arg1 ifAbsent: [ ^false ] ] ifNotNil: [ model perform: getListElementSelector with: arg1 ].        ^arg2 isBlock ifTrue: [ arg2 cull: tmp1 cull: arg1 ] ifFalse: [ arg2 isSymbol ifTrue: [ arg2 numArgs == 0 ifTrue: [ tmp1 perform: arg2 ] ifFalse: [ self model perform: arg2 withEnoughArguments: {tmp1 .                                 arg1} ] ] ifFalse: [ false ] ] ].  ^false-======-selectLast  self table selectIndex: {self table numberOfRows .         self table numberOfColumns}-======-scrollLeft: arg1  self scrollUp: arg1-======-offColor  ^offColor-======-scrollAbsolute: arg1  | tmp1 tmp2 |  tmp1 := self roomToMove.  bounds isWide ifTrue: [ tmp1 width = 0 ifTrue: [ ^self ] ] ifFalse: [ tmp1 height = 0 ifTrue: [ ^self ] ].  tmp2 := arg1 targetPoint adhereTo: tmp1.  self descending ifFalse: [ self setValue: (bounds isWide ifTrue: [ (tmp2 x - tmp1 left) asFloat / tmp1 width ] ifFalse: [ (tmp2 y - tmp1 top) asFloat / tmp1 height ]) ] ifTrue: [ self setValue: (bounds isWide ifTrue: [ (tmp1 right - tmp2 x) asFloat / tmp1 width ] ifFalse: [ (tmp1 bottom - tmp2 y) asFloat / tmp1 height ]) ]-======-transform  ^transform-======-filterNowWith: arg1  pattern := arg1.  self field setText: pattern.  self filterWith: pattern.  self filter-======-oldScrollingIndex  ^oldScrollingIndex-======-newContentMorph  self hsvaMorph: self newHSVAColorSelectorMorph.  ^self newRow: {(self newGroupbox: 'Color' translated forAll: {self hsvaMorph .               ((self newRow: {((self newLabelGroup: {('Selected color' translated -> self newColorPresenterMorph)}) vResizing: #shrinkWrap) .                     self newColorPickerButtonMorph}) cellPositioning: #leftCenter)}) .         ((self newGroupbox: 'Values' translated for: (self newLabelGroup: {('Red' translated -> (self newColorComponentFieldMorph: #red)) .                     ('Green' translated -> (self newColorComponentFieldMorph: #green)) .                     ('Blue' translated -> (self newColorComponentFieldMorph: #blue)) .                     ('Hue' translated -> (self newColorComponentFieldMorph: #hue)) .                     ('Saturation' translated -> (self newColorComponentFieldMorph: #saturation)) .                     ('Brightness' translated -> (self newColorComponentFieldMorph: #brightness)) .                     ('Alpha' translated -> (self newColorComponentFieldMorph: #alpha))})) hResizing: #shrinkWrap)}-======-containsPoint: arg1  ^(lines at: (self lineIndexForPoint: arg1)) rectangle containsPoint: arg1-======-removeOtherProperties  otherProperties := nil-======-setMultipleSelection: arg1  arg1 ifTrue: [ self beMultipleSelection ] ifFalse: [ self beSingleSelection ]-======-addColumn: arg1  self addColumn: arg1 afterIndex: self columns size-======-selectionColor: arg1  selectionColor := arg1-======-display: arg1  displayBlock := arg1-======-isFullOnScreen  owner ifNil: [ ^true ].  self visible ifFalse: [ ^true ].  ^owner clearArea containsRect: self fullBounds-======-offerWindowMenu  | tmp1 |  tmp1 := self buildWindowMenu.  model ifNotNil: [ model addModelItemsToWindowMenu: tmp1 ].  tmp1 popUpEvent: self currentEvent in: self world-======-initialize  super initialize.  icon := ImageMorph new-======-privateMoveBy: arg1  super privateMoveBy: arg1-======-icon  ^icon-======-addARowCentered: arg1 cellInset: arg2  ^(self addARow: arg1)     hResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #leftCenter;     cellInset: arg2-======-menuStringBounds  | tmp1 |  tmp1 := bounds.  self hasIcon ifTrue: [ | tmp2 |        tmp2 := self iconForm.        tmp1 := tmp1 left: tmp1 left + tmp2 width + 2 ].  self hasMarker ifTrue: [ tmp1 := tmp1 left: tmp1 left + self submorphBounds width + 8 ].  ^tmp1 top: (tmp1 top + tmp1 bottom - self fontToUse height) // 2-======-basicMoveShowIndexTo: arg1  showIndex := arg1-======-tabs: arg1  toolbar tabs: arg1-======-openModal: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self activeHand keyboardFocus.  tmp2 := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  tmp2 ifNil: [ tmp2 := self ].  tmp2 modalLockTo: arg1.  tmp1 := RealEstateAgent maximumUsableArea.  arg1 extent: arg1 initialExtent.  arg1 position = (0 @ 0) ifTrue: [ arg1 position: self activeHand position - (arg1 extent // 2) ].  arg1 bounds: (arg1 bounds translatedToBeWithin: tmp1).  [ | tmp4 |  tmp4 := arg1 openAsIs.  self activeHand mouseFocus: tmp4.  [ tmp4 world notNil ] whileTrue: [ tmp4 outermostWorldMorph doOneCycle ] ] ensure: [ tmp2 modalUnlockFrom: arg1.        self activeHand newKeyboardFocus: tmp3 ].  ^arg1-======-modalUnlockFrom: arg1  arg1 removeProperty: #modalOwner.  self removeProperty: #modalChild.  closeBox ifNotNil: [:arg2 |  arg2 enabled: (self valueOfProperty: #preModalCloseEnabled ifAbsent: [ true ]) ].  self removeProperty: #preModalCloseEnabled.  self activate-======-defaultBorderWidth  ^0-======-passivate  super passivate.  self nonVisibleTabs do: [:arg1 |  arg1 passivate ]-======-activeDisabledNotOverUpFillStyle: arg1  self stateMap atPath: #(active disabled notOver up) put: arg1.  self changed-======-menuItems  ^submorphs select: [:arg1 |  arg1 isMenuItemMorph ]-======-calendar: arg1  calendar := arg1-======-updateWidth  self resize-======-doubleClickSelector: arg1  doubleClickSelector := arg1-======-apply: arg1  | tmp1 |  tmp1 := target bounds.  target bounds: (tmp1 origin corner: tmp1 corner + arg1)-======-cellPositioning  ^#center-======-newEditableDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: arg6 default: arg7 ghostText: arg8 getEnabled: arg9 useIndex: arg10 help: arg11  ^self theme newEditableDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 addToList: arg5 class: arg6 default: arg7 ghostText: arg8 getEnabled: arg9 useIndex: arg10 help: arg11-======-collpasedButton  ^IconicButton new     target: self;     actionSelector: #expandAndRefresh;     arguments: {};     labelGraphic: self class unexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-======-recipient  ^recipient-======-newHueSelector: arg1 getHue: arg2 setHue: arg3 help: arg4  ^self theme newHueSelectorIn: self for: arg1 getHue: arg2 setHue: arg3 help: arg4-======-trackDirectionArrow: arg1 with: arg2  arg1 hand obtainHalo: self.  arg2 setVertices: {directionArrowAnchor .         arg1 cursorPoint}.  self layoutChanged-======-stateSelector: arg1  stateSelector := arg1-======-newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 icon: arg5 getEnabled: arg6 help: arg7  ^self theme newListIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4 icon: arg5 getEnabled: arg6 help: arg7-======-drawOn: arg1  | tmp1 |  tmp1 := self boundsForKeyText: self keyText font: self owner fontToUse.  self owner drawText: keyText on: arg1 in: tmp1 color: self color-======-userString  ^String streamContents: [:arg1 |  1 to: self getListSize do: [:arg2 |  (self getListItem: arg2) submorphs detect: [:arg3 |  arg3 userString notNil ] ifFound: [:arg3 |  arg1 nextPutAll: arg3 userString ].              arg1 cr ] ]-======-triggerOnMouseDown  ^triggerOnMouseDown-======-currentNodelist  ^self nodeList-======-newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7  ^self theme newDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7-======-setColorSelector: arg1  setColorSelector := arg1-======-canDrawBorder: arg1  ^arg1 style == #simple-======-setLastCharacter: arg1  | tmp1 tmp2 |  tmp1 := arg1 asCharacter.  (tmp2 := self getCharacters) size > 0 ifFalse: [ self newContents: (String with: tmp1) ] ifTrue: [ tmp2 last = tmp1 ifFalse: [ self newContents: (String streamContents: [:arg2 |  arg2 nextPutAll: (tmp2 copyFrom: 1 to: tmp2 size - 1).                          arg2 nextPut: tmp1 ]) ] ]-======-bottomRightColor  ^self color-======-doneWithEdits  hasFocus := false-======-chooseFileName: arg1 extensions: arg2 path: arg3 preview: arg4  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4-======-chooseServiceFrom: arg1  arg1 size = 1 ifTrue: [ ^arg1 anyOne ].  ^UIManager default chooseFrom: (arg1 collect: [:arg2 |  arg2 label ]) values: arg1-======-medium  ^27-======-on: arg1 list: arg2 selected: arg3 changeSelected: arg4 menu: arg5 keystroke: arg6  self model: arg1.  getListSelector := arg2.  getIndexSelector := arg3.  setIndexSelector := arg4.  getMenuSelector := arg5.  keystrokeActionSelector := arg6.  self autoDeselect: true.  self borderWidth: 1.  self updateList.  self selectionIndex: self getCurrentSelectionIndex.  self initForKeystrokes-======-selectedFillStyle  ^self theme buttonSelectedFillStyleFor: self-======-setUp  super setUp.  prototypes     add: (TextAnchor new anchoredMorph: Morph new initialize);     add: (TextAnchor new anchoredMorph: EllipseMorph new initialize)-======-font: arg1  font := arg1-======-beRowSelection  self selectionModeStrategy: (FTRowSelectionModeStrategy table: self)-======-roomToMove  ^self totalSliderArea insetBy: (0 @ 0 extent: self sliderExtent)-======-treeLineWidth  ^treeLineWidth ifNil: [ treeLineWidth := self theme treeLineWidth ]-======-fontName: arg1 pointSize: arg2  | tmp1 |  tmp1 := ((TextStyle named: arg1 asSymbol) ifNil: [ TextStyle default ]) copy.  tmp1 ifNil: [ self error: 'font ' , arg1 , ' not found.' ].  textStyle := tmp1.  text addAttribute: (TextFontChange fontNumber: (tmp1 fontIndexOfPointSize: arg2)).  paragraph ifNotNil: [ paragraph textStyle: tmp1 ]-======-currentNodelist  ^self pager ifNil: [ super nodeList ] ifNotNil: [ self pager currentNodelist ]-======-hasHighlighted  ^self highlightedIndexes notEmpty-======-adoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self assureExtension.  extension fillStyle ifNil: [ self color: arg1 ].  self borderStyle baseColor: arg1 darker-======-recordDamagedRect: arg1  damageRecorder ifNotNil: [ damageRecorder recordInvalidRect: arg1 truncated ]-======-initialize  super initialize.  self     style: #inset;     trackPaneColor: true-======-showSelectionFeedback  ^showSelectionFeedback-======-computeFramedColors  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self color asColor.  tmp2 := Color white.  tmp3 := Color black.  tmp4 := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  tmp4 := tmp4 asInteger.  tmp4 = 1 ifTrue: [ ^{(tmp1 mixed: 0.5 with: tmp2) .         (tmp1 mixed: 0.5 with: tmp3)} ].  tmp6 := Array new: tmp4.  tmp5 := tmp4 // 2.  0 to: tmp5 - 1 do: [:arg1 |  tmp7 := 0.5 + (arg1 asFloat / tmp5 * 0.5).        tmp6 at: arg1 + 1 put: (tmp1 mixed: tmp7 with: tmp2).        tmp6 at: tmp4 - arg1 put: (tmp1 mixed: tmp7 with: tmp3) ].  tmp4 odd ifTrue: [ tmp6 at: tmp5 + 1 put: tmp1 ].  ^tmp6 , tmp6-======-newAutoAcceptTextEntryFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 font: arg5 help: arg6  ^self theme newAutoAcceptTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: arg4 font: arg5 help: arg6-======-newLeftButton  ^(ControlButtonMorph on: self getState: nil action: #scrollTabsLeft label: #leftButtonLabel)     getEnabledSelector: #leftButtonEnabled;     hResizing: #rigid;     vResizing: #spaceFill;     cornerStyle: #square;     extent: self controlButtonWidth asPoint-======-rowColorForOdd: arg1  rowColors at: 2 put: arg1-======-hasChildren  ^(dataSource childrenBlock value: item) isNotEmpty-======-initWithContents: arg1 prior: arg2 forList: arg3 indentLevel: arg4  container := arg3.  self cellInset: container resizerWidth @ 0.  complexContents := arg1.  complexContents addDependent: self.  isExpanded := complexContents isExpanded.  nextSibling := firstChild := nil.  arg2 ifNotNil: [ arg2 nextSibling: self ].  indentLevel := arg4.  self setBalloonText: complexContents helpText.  self initRow.  complexContents selected ifTrue: [ self selectedWithoutNotifyingComplexContents: true ]-======-selectionChanged  self requestView: (MorphTreeSelectionChanged new selection: self selection)-======-handlerForBlueButtonDown: arg1  self wantsHaloFromClick ifFalse: [ ^nil ].  self class cycleHalosBothDirections ifTrue: [ arg1 handler ifNil: [ ^self ].        (arg1 handler isKindOf: PasteUpMorph) ifTrue: [ ^self ] ].  arg1 shiftPressed ifFalse: [ ^nil ] ifTrue: [ ^self ]-======-resizeFromMenu  self resizeMorph: ActiveEvent-======-handleStep: arg1  ^self dispatchDefault: arg1 with: morph-======-separatorSize: arg1  separatorSize := arg1-======-yellowButtonActivity: arg1  (self getMenu: arg1) ifNotNil: [:arg2 |  arg2 setInvokingView: self.        arg2 popUpEvent: self activeHand lastEvent in: self world.        ^true ].  ^false-======-translateBy: arg1  position := position + arg1-======-itemsForTest  ^rootClass allSubclasses-======-minExtentFrom: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 x + leftOffset - rightOffset.  tmp2 := arg1 y + topOffset - bottomOffset.  tmp3 := rightFraction - leftFraction.  tmp4 := bottomFraction - topFraction.  tmp1 := tmp3 = 0 ifTrue: [ 0 ] ifFalse: [ tmp1 / tmp3 ].  tmp2 := tmp4 = 0 ifTrue: [ 0 ] ifFalse: [ tmp2 / tmp4 ].  ^tmp1 truncated @ tmp2 truncated-======-maxNodeWidth  ^maxNodeWidth ifNil: [ maxNodeWidth := 0 ]-======-themedFillStyle  ^self theme buttonNormalFillStyleFor: self-======-addToggle: arg1 target: arg2 selector: arg3 getStateSelector: arg4 enablementSelector: arg5 argumentList: arg6  | tmp1 |  tmp1 := ToggleMenuItemMorph new     contents: arg1;     target: arg2;     selector: arg3;     arguments: arg6;     getStateSelector: arg4;     enablementSelector: arg5.  ^self addMenuItem: tmp1-======-configureForUnembedding  labelArea owner ifNil: [ self           makeBordered;           initializeLabelArea;           themeChanged;           addGrips ]-======-hasItems  ^submorphs anySatisfy: [:arg1 |  arg1 isMenuItemMorph ]-======-newRow  ^self theme newRowIn: self for: #()-======-autoAccept: arg1  autoAccept := arg1-======-multipleSelection  ^multipleSelection ifNil: [ multipleSelection := self defaultMultipleSelectionValue ]-======-selectIndexes: arg1 previous: arg2  self table selectIndexes: (((arg2 includes: arg1) ifTrue: [ arg2 copyWithout: arg1 ] ifFalse: [ arg2 ]) copyWithFirst: arg1)-======-resizeToFit  ^self vResizing == #shrinkWrap-======-adoptPaneColor: arg1  super adoptPaneColor: arg1.  scrollBar adoptPaneColor: arg1.  hScrollBar adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self borderWidth > 0 ifTrue: [ self borderStyle: self borderStyleToUse ]-======-passengerAt: arg1  ^self elementAt: arg1-======-removeCollapseBox  collapseBox ifNotNil: [ collapseBox delete.        collapseBox := nil ]-======-adjustLineIndicesBy: arg1  firstCharacterIndex := firstCharacterIndex + arg1.  lines do: [:arg2 |  arg2 slide: arg1 ]-======-setType: arg1 buttons: arg2 position: arg3 keyValue: arg4 hand: arg5 stamp: arg6  type := arg1.  buttons := arg2.  position := arg3.  keyValue := arg4.  source := arg5.  wasHandled := false.  timeStamp := arg6-======-handlesMouseOver: arg1  ^true-======-model: arg1  self model ifNotNil: [ self model announcer unsubscribe: self ].  super model: arg1.  self registerRequestHandlers-======-asSpecAdapter  ^MorphicGenericAdapter morph: self-======-toggleSelected  self takeKeyboardFocus.  self enabled ifFalse: [ ^self ].  self model ifNil: [ ^self ].  (self setStateSelector ifNil: [ ^self ]) numArgs = 0 ifTrue: [ self model perform: self setStateSelector ].  self setStateSelector numArgs = 1 ifTrue: [ self model perform: self setStateSelector with: self isSelected not ].  self updateSelection-======-handleMouseOver: arg1  ^self dispatchDefault: arg1 with: morph-======-cellPositioning  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #center ] ifNotNil: [ tmp1 cellPositioning ]-======-menu: arg1 shifted: arg2  super menu: arg1 shifted: arg2.  arg1 addLine.  self selectedNode ifNotNil: [:arg3 |  arg3 menu: arg1 shifted: arg2 ].  ^arg1-======-balloonHelpTextForHandle: arg1  (arg1 eventHandler mouseSelectorsInclude: #doRecolor:with:) ifTrue: [ ^'Change color' ].  (arg1 eventHandler mouseSelectorsInclude: #mouseDownInDimissHandle:with:) ifTrue: [ ^'Remove from screen' translated ].  #(#(#addFullHandles 'More halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#trackCenterOfRotation:with: 'Set center of rotation')) do: [:arg2 |  (arg1 eventHandler mouseSelectorsInclude: arg2 first) ifTrue: [ ^arg2 last ] ].  ^'unknown halo handle' translated-======-initializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigation.  arg1 attachCategory: #TabMorphsNavigation-======-collapsedFrame  ^collapsedFrame-======-subMenuSelector  ^subMenuSelector-======-show: arg1 from: arg2 to: arg3  | tmp1 |  self flag: #pharoFixMe.  self openInWorld.  tmp1 := self addItemShowing: arg1 from: arg2 to: arg3.  self     refresh;     reposition.  ^tmp1-======-resetPotentialDropMorph  potentialDropMorph ifNotNil: [ potentialDropMorph resetHighlightForDrop.        potentialDropMorph := nil ]-======-wrapFlag: arg1  arg1 == wrapFlag ifTrue: [ ^self ].  wrapFlag := arg1.  self composeToBounds-======-secondarySelectionColor  ^self theme secondarySelectionColor-======-seeClassSide  -======-addNavigationPane: arg1  pager := arg1.  self addMorph: pager.  pager buildPanel.  self updatePager.  self changed-======-icon: arg1  self dataSource icon: arg1-======-parent: arg1  parent := arg1-======-popUpForHand: arg1 in: arg2  | tmp1 |  tmp1 := arg1 position truncated.  ^self popUpAt: tmp1 forHand: arg1 in: arg2-======-fromArray: arg1  | tmp1 |  tmp1 := arg1 readStream.  #(leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset:) do: [:arg2 |  tmp1 next ifNil: [ ^self ] ifNotNil: [:arg3 |  self perform: arg2 with: arg3 ] ]-======-doFastWindowReframe: arg1  (FastDraggingFrameMorph forResizing: self fromLocation: arg1) openInWorld-======-baseColor  ^self theme autoMenuColor ifTrue: [ owner color twiceDarker ] ifFalse: [ self theme currentSettings flatMenu ifFalse: [ owner color ] ifTrue: [ owner color twiceDarker ] ]-======-initialize  super initialize.  self     changeProportionalLayout;     bounds: self currentWorld clearArea;     beSticky-======-computeLength  | tmp1 tmp2 tmp3 |  tmp2 := tabs size.  tmp2 isZero ifTrue: [ ^0 ].  tmp1 := self width - self extraSpace + ((tmp2 - 1) * self overlap).  tmp3 := tmp1 / tmp2.  tmp3 := tmp3 min: 150 * self displayScaleFactor.  tmp3 := tmp3 max: 33 * self displayScaleFactor.  ^tmp3-======-newPluggableDialogWindow: arg1 for: arg2  ^self theme newPluggableDialogWindowIn: self title: arg1 for: arg2-======-iconFor: arg1  ^(self elementAt: arg1) actionOn: self-======-fileNames  ^fileNames-======-initDraggedMorph  draggedMorph ifNotNil: [ ^self ].  draggedMorph := self passenger asDraggableMorph.  self addMorphBack: draggedMorph.  self updateCopyIcon.  self     changed;     fullBounds-======-useSortedTabsBy: arg1  toolbar useSortedTabsBy: arg1-======-eventListeners  ^eventListeners-======-actualViewee  | tmp1 tmp2 |  tmp1 := self morphToView ifNil: [ ^nil ].  tmp1 isInWorld ifFalse: [ ^nil ].  tmp2 := viewSelector ifNil: [ tmp1 ] ifNotNil: [ objectToView perform: viewSelector ].  tmp2 = 0 ifTrue: [ ^nil ].  tmp2 ifNil: [ tmp2 := objectToView ].  (tmp2 isMorph and: [ tmp2 isFlexMorph and: [ tmp2 submorphs size = 1 ] ]) ifTrue: [ tmp2 := tmp2 firstSubmorph ].  ^tmp2-======-popUpAdjacentTo: arg1 forHand: arg2 from: arg3  | tmp1 tmp2 |  arg2 world startSteppingSubmorphsOf: self.  popUpOwner := arg3.  self fullBounds.  self updateColor.  tmp2 := selectedItem ifNil: [ self items ifEmpty: [ 0 @ 0 ] ifNotEmpty: [:arg4 |  arg4 first position - self position ] ] ifNotNil: [ selectedItem position - self position ].  tmp1 := [:arg5 :arg6 |  | tmp3 |  self position: arg5 - tmp2.  tmp3 := self fullBoundsInWorld amountToTranslateWithin: arg3 worldBounds.  (tmp3 x = 0 or: [ arg6 ]) ifTrue: [ tmp3 = (0 @ 0) ifFalse: [ self position: self position + tmp3 ].        arg3 world addMorphFront: self.        ^self ] ].  tmp1     value: arg1 first value: false;     value: arg1 last - (self width @ 0) value: false;     value: arg1 first value: true-======-modalLockTo: arg1  self lock-======-displaySelectionBarOnAthensCanvas: arg1  | tmp1 tmp2 |  selectionStart ifNil: [ ^self ].  selectionStop ifNil: [ ^self ].  tmp1 := arg1 clipRect.  selectionStart textLine = selectionStop textLine ifFalse: [ ^self ].  tmp2 := selectionStart textLine.  arg1 setPaint: self selectionBarColor.  arg1 drawShape: (tmp1 left @ tmp2 top corner: tmp1 right @ tmp2 bottom)-======-hResizeScrollbar  | tmp1 |  tmp1 := self innerBounds.  tmp1 := tmp1 top: tmp1 bottom - self scrollBarThickness.  self vScrollbarShowing ifTrue: [ tmp1 := tmp1 right: tmp1 right - self scrollBarThickness ].  self hScrollbar bounds: tmp1-======-initializeLabel: arg1 start: arg2 end: arg3  lock := Semaphore forMutualExclusion.  hasResult := false.  lastRefresh := 0.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #center;     cellInset: 5;     listCentering: #center;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap.  labelMorph := StringMorph contents: arg1 font: StandardFonts windowTitleFont.  self addMorphBack: labelMorph.  bar := ProgressBarMorph from: arg2 to: arg3.  self addMorphBack: bar-======-withHLines: arg1  withHLines := arg1-======-themeChanged  super themeChanged.  tabs do: #themeChanged-======-withText: arg1 label: arg2  self title: arg2.  self addMorph: (RubScrolledTextMorph new           setText: arg1 asString;           yourself) fullFrame: LayoutFrame identity.  self themeChanged-======-invokeModal  ^self invokeModal: self menuKeyboardControl-======-valueParameter: arg1  valueParameter := arg1-======-leftMarginForAlignment: arg1  arg1 = RightFlush ifTrue: [ ^self left + paddingWidth ].  arg1 = Centered ifTrue: [ ^self left + (paddingWidth // 2) ].  ^self left-======-minWidth  ^self minimumExtent x max: super minWidth-======-fillStyle: arg1  fillStyle := arg1-======-deny: arg1 title: arg2  ^self theme denyIn: self text: arg1 title: arg2-======-wantsRoundedCorners  ^color isTransparent not and: [ owner wantsRoundedCorners ]-======-usableArea  ^self viewBox-======-minHeight  | tmp1 tmp2 tmp3 |  tmp1 := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  tmp2 := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  tmp3 := tmp1 ifTrue: [ tmp2 ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness ] ] ifFalse: [ tmp2 ifTrue: [ self scrollBarThickness * 3 ] ifFalse: [ self scrollBarThickness * 4 + 2 ] ].  ^tmp3 max: super minHeight-======-disabledBorderStyle  ^self theme buttonDisabledBorderStyleFor: self-======-resizeCursor  ^Cursor resizeForEdge: #left-======-addPaneVSplitters  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := paneMorphs reject: [:arg1 |  arg1 layoutFrame rightFraction = 1 or: [ arg1 layoutFrame rightFraction = 0 ] ].  [ tmp1 notEmpty ] whileTrue: [ tmp2 := tmp1 first layoutFrame rightFraction.        tmp3 := tmp1 select: [:arg1 |  arg1 layoutFrame rightFraction = tmp2 ].        tmp4 := paneMorphs select: [:arg1 |  arg1 layoutFrame leftFraction = tmp2 and: [ arg1 layoutFrame rightFraction ~= tmp2 ] ].        tmp1 := tmp1 copyWithoutAll: (self addPaneVSplitterBetween: tmp3 and: tmp4) ]-======-world  ^owner ifNotNil: [ owner world ]-======-removeFlexShell  self isFlexed ifTrue: [ self owner removeFlexShell ]-======-activateSubmenu: arg1  subMenu ifNil: [ ^false ].  (subMenu fullContainsPoint: arg1 position) ifFalse: [ ^false ].  subMenu activate: arg1.  self removeAlarm: #deselectTimeOut:.  ^true-======-exposedColumnsRange: arg1  ^self startColumnIndex isZero ifTrue: [ 1 to: self table numberOfColumns ] ifFalse: [ (1 to: arg1 size) select: [:arg2 |  (arg1 at: arg2) > 0 ] ]-======-updateOrderedTasksFrom: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self orderedTasks do: [:arg2 |  arg1 detect: [:arg3 |  arg3 morph = arg2 morph ] ifFound: [:arg4 |  arg1 remove: arg4 ] ifNone: [ tmp1 add: arg2 ] ].  (tmp1 isEmpty and: [ arg1 isEmpty ]) ifTrue: [ ^self ].  self orderedTasks: (self orderedTasks           removeAll: tmp1;           addAll: arg1;           yourself)-======-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-======-scrollValue  ^0 @ self verticalScrollBar value-======-addHandlesTo: arg1 box: arg2  | tmp1 |  arg1 haloBox: arg2.  tmp1 := #(addDismissHandle: addMenuHandle: addGrabHandle: addDragHandle: addDupHandle: addHelpHandle: addGrowHandle: addFontSizeHandle: addFontStyleHandle: addFontEmphHandle: addRecolorHandle:).  HaloMorph currentHaloSpecifications do: [:arg3 |  (tmp1 includes: arg3 addHandleSelector) ifTrue: [ arg1 perform: arg3 addHandleSelector with: arg3 ] ].  arg1 innerTarget addOptionalHandlesTo: arg1 box: arg2-======-releaseCachedState  colors := nil.  lineStyles := nil-======-keyUp: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #keyUp from: arg2-======-filter  self subclassResponsibility-======-addMorph: arg1 fullFrame: arg2  arg1 layoutFrame: arg2 asLayoutFrame.  arg1     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorph: arg1-======-containsPoint: arg1  ^target ifNil: [ super containsPoint: arg1 ] ifNotNil: [ false ]-======-newGroupbox: arg1 forAll: arg2  ^self theme newGroupboxIn: self label: arg1 forAll: arg2-======-pressedFillStyle  ^self theme morphTreeSplitterPressedFillStyleFor: self-======-setRotationCenterFrom: arg1  self setProperty: #referencePosition toValue: arg1-======-eventListeners: arg1  eventListeners := arg1-======-actionSelector: arg1  (nil = arg1 or: [ 'nil' = arg1 or: [ arg1 isEmpty ] ]) ifTrue: [ ^actionSelector := nil ].  actionSelector := arg1 asSymbol-======-changeMaxCellSize: arg1  | tmp1 |  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  self maxCellSize: (arg2 - arg1 cursorPoint) asIntegerPoint ].  arg1 hand attachMorph: tmp1.  tmp1 startStepping-======-clyAddEmphasis: arg1  self emphasis: (emphasis bitOr: arg1 emphasisCode)-======-initializeShortcuts: arg1  arg1 attachCategory: #MorphFocusCtrlNavigation-======-findReplaceDialog  ^EditorFindReplaceDialogWindow singleton-======-veryDeepCopyWith: arg1  ^self-======-newSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8-======-animateRestore  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self bounds.  tmp2 := self unexpandedFrame.  tmp4 := self theme numberOfStepsForAnimations.  tmp3 := ((tmp4 - 1) / tmp4 to: 0 by: -1 / tmp4) collect: [:arg1 |  tmp2 interpolateTo: tmp1 at: ((20 raisedTo: arg1) - 1) / 19 ].  self fastAnimateRectangles: tmp3-======-asAthensShapeOn: arg1  | tmp1 tmp2 |  self bounds area > 0 ifFalse: [ ^self ].  tmp1 := self bounds width / 2 asFloat.  tmp2 := self bounds height / 2 asFloat.  ^arg1 createPath: [:arg2 |  arg2           absolute;           moveTo: self bounds center;           relative;           moveTo: tmp1 negated @ 0;           curveVia: 0 @ (tmp2 negated * 0.55) and: (0.45 * tmp1) @ tmp2 negated to: tmp1 @ tmp2 negated;           curveVia: (tmp1 * 0.55) @ 0 and: tmp1 @ (0.45 * tmp2) to: tmp1 @ tmp2;           curveVia: 0 @ (tmp2 * 0.55) and: (0.45 * tmp1 negated) @ tmp2 to: tmp1 negated @ tmp2;           curveVia: (tmp1 negated * 0.55) @ 0 and: tmp1 negated @ (tmp2 negated * 0.45) to: tmp1 negated @ tmp2 negated ]-======-nextCell  ^nextCell-======-veryDeepInner: arg1  super veryDeepInner: arg1.  activatorDockingBar := activatorDockingBar-======-chooseForSaveFileReference: arg1 extensions: arg2 path: arg3 preview: arg4  ^self theme chooseForSaveFileReferenceIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4-======-initialize  expanded := false.  depth := 0.  children := #()-======-topRight: arg1  self position: (arg1 x - bounds width) @ arg1 y-======-alignBottomEdges  | tmp1 |  tmp1 := (selectedItems collect: [:arg1 |  arg1 bottom ]) max.  selectedItems do: [:arg1 |  arg1 bottom: tmp1 ].  self changed-======-treeRenderOn: arg1 bounds: arg2 color: arg3 font: arg4 from: arg5  self bounds: arg2.  arg5 addMorphBack: self-======-string  ^string-======-setColorSelector  ^setColorSelector-======-originalCenter: arg1  originalCenter := arg1-======-selectedWithoutNotifyingComplexContents: arg1  arg1 ifFalse: [ ^self ].  container listManager silentlySetSelectedMorph: self.  selected := arg1-======-undoRedoExchange: arg1 with: arg2  self handleEdit: [ self editor undoRedoExchange: arg1 with: arg2 ]-======-defaultBorderWidth  ^self theme borderWidth-======-navigationKey: arg1  self isMultipleSelection ifTrue: [ | tmp1 |        tmp1 := arg1 keyString.        tmp1 = '<Cmd-a>' ifTrue: [ self selectAll.              ^true ].        tmp1 = '<Cmd-A>' ifTrue: [ self deselectAll.              ^true ] ].  ^super navigationKey: arg1-======-asMorph  ^self-======-isUp  ^direction = Character arrowUp-======-mouseUp: arg1  self storeValue: nil.  super mouseUp: arg1-======-isMenuMorph  ^false-======-testMouseEnterEventIsNotDuplicated  | tmp1 tmp2 tmp3 |  tmp1 := MockObjectForEventTests new.  [ tmp2 := tmp1 stringMorph openInWindow.  tmp3 := MouseButtonEvent new setType: nil position: tmp1 stringMorph center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  self assert: tmp1 counter equals: 0.  tmp1 stringMorph handleMouseEnter: tmp3.  self assert: tmp1 counter equals: 1 ] ensure: [ tmp2 ifNotNil: #close ]-======-mouseEnter: arg1  self color: (selectionColor isTransparent ifTrue: [ self mouseOverColor ] ifFalse: [ self mouseOverColor mixed: 0.5 with: selectionColor ])-======-mouseUpInSlider: arg1  sliderShadow hide.  (slider containsPoint: arg1 position) ifTrue: [ slider           fillStyle: self mouseOverThumbFillStyle;           borderStyle: self mouseOverThumbBorderStyle ] ifFalse: [ self mouseLeaveThumb: arg1 ].  slider changed-======-on: arg1 getState: arg2 action: arg3 label: arg4 menu: arg5  self on: arg1 getState: arg2 action: arg3 label: arg4 icon: nil menu: arg5-======-indentationLevel: arg1  indent := arg1-======-lastKeystrokeTime  ^lastKeystrokeTime-======-paneColor  ^self paneColorOrNil ifNil: [ self owner ifNil: [ Color transparent ] ifNotNil: [ self owner color ] ]-======-rowHeight  ^rowHeight ifNil: [ rowHeight := self class defaultRowHeight ]-======-selectableIndexAfter: arg1  ^self subclassResponsibility-======-lastSelection: arg1  lastSelection := arg1-======-drawOnAthensCanvas: arg1  | tmp1 tmp2 |  self bounds area > 0 ifFalse: [ ^self ].  tmp1 := self borderStyle.  tmp2 := self asAthensShapeOn: arg1.  arg1 setPaint: self fillStyle.  arg1 setShape: tmp2.  arg1 draw.  (arg1 setStrokePaint: tmp1 color) width: tmp1 width.  arg1 draw-======-orientation  ^orientation-======-selectToMe  self triggerEvent: #tabSelectTo with: self-======-bottomArrow  ^BottomArrow-======-buildPanel  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  self removeAllMorphs.  pageSize ifNil: [ ^self ].  self nodeList ifNil: [ ^self ].  tmp1 := OrderedCollection new.  self nodeList size > pageSize ifTrue: [ tmp2 := self buttonLabel: self class smallToLeftEndIcon actionSelector: #currentPage: arguments: {1} getEnabled: #notOnFirstPage help: 'First page'.        tmp1 add: tmp2.        tmp3 := self buttonLabel: self class smallToLeftIcon actionSelector: #previousPage arguments: {} getEnabled: #notOnFirstPage help: 'Previous page'.        tmp1 add: tmp3.        tmp4 := self textEntryLabel: '' get: #currentPageToString set: #currentPageInput: help: 'Index of page to view' translated class: String.        tmp4 hResizing: #rigid.        tmp4 width: (self preferedFont widthOfString: '1000000').        tmp1 add: tmp4.        tmp1 add: (self buttonLabel: self class smallDiezeIcon actionSelector: #choosePage arguments: {} getEnabled: nil help: 'Choose page').        tmp5 := self buttonLabel: self class smallToRightIcon actionSelector: #nextPage arguments: {} getEnabled: #notOnLastPage help: 'Next page'.        tmp1 add: tmp5.        tmp6 := self buttonLabel: self class smallToRightEndIcon actionSelector: #currentPage: arguments: {self lastPage} getEnabled: #notOnLastPage help: 'Last page'.        tmp1 add: tmp6.        tmp1 add: (self spacer: 10) ].  tmp1 add: (LabelMorph contents: 'Page size: ' font: self preferedFont).  tmp7 := self textEntryLabel: 'Page size' get: #pageSizeToString set: #pageSizeFromString: help: 'Change the page size or the number of pages if the input begins with "/"' translated class: String.  tmp7 hResizing: #rigid.  tmp7 width: (self preferedFont widthOfString: '1000000').  tmp1 add: tmp7.  self withSearch ifTrue: [ tmp8 := self textEntryLabel: '' get: #pageSearchText set: #pageSearchText: help: 'Enter a text correspondig to your search' translated class: String.        tmp8 ghostText: 'Searched text'.        tmp1 add: tmp8 ].  self addAllMorphs: tmp1.  self updateContents-======-testSelectableIndexAbove  self subclassResponsibility-======-basicSelectedColor: arg1  selectedColor := arg1.  self     changed: #selectedColor;     changed: #red;     changed: #green;     changed: #blue;     changed: #hue;     changed: #saturation;     changed: #brightness;     changed: #alpha.  self announcer announce: (ColorChanged to: selectedColor)-======-autoAccept: arg1  autoAccept := arg1-======-newAlphaImage: arg1 help: arg2  ^self theme newAlphaImageIn: self image: arg1 help: arg2-======-proceed: arg1  ^self proceed: arg1 title: 'Proceed' translated-======-extent: arg1  | tmp1 |  tmp1 := self extent.  super extent: arg1.  self extent = tmp1 ifTrue: [ ^self ].  self updateColor-======-findDeeplyA: arg1  ^(self allMorphs copyWithout: self) detect: [:arg2 |  arg2 isKindOf: arg1 ] ifNone: [ nil ]-======-setStrategy  table beCellSelection-======-indentingItemClass  ^LazyMorphTreeNodeMorph-======-left  ^textMorph owner left-======-color: arg1  super color: arg1 beOpaque.  self fillStyle: self defaultFillStyle-======-drawOn: arg1  | tmp1 |  tmp1 := Time millisecondClockValue.  self drawMeOn: arg1.  drawTime := Time millisecondClockValue - tmp1.  drawTime < 0 ifTrue: [ drawTime := nil ]-======-hasFocus  ^hasFocus ifNil: [ false ]-======-itemStringGetter: arg1  self columns first itemStringGetter: arg1-======-fillStyleToUse  ^self isSelected ifTrue: [ self selectedFillStyle ] ifFalse: [ self normalFillStyle ]-======-openOn: arg1  rootClass := arg1.  (self defaultTreeMorph buildContents embeddedInMorphicWindowLabeled: 'test') openInWorld-======-openDialogOn: arg1  rootClass := arg1.  ^self openDialogWindowIn: self currentWorld title: 'All Object subclasses'-======-deselect  editor ifNotNil: [ editor deselect ]-======-allEnabledSiblingItems  ^self allSiblingItems select: [:arg1 |  arg1 isEnabled ]-======-setSelectedSilently: arg1  selected := arg1.  self complexContents selected: arg1-======-beUnsticky  extension ifNotNil: [ extension sticky: false ]-======-announcer  WorldAnnouncer ifNil: [ WorldAnnouncer := Announcer new ].  ^WorldAnnouncer-======-needSpaceForActions  | tmp1 |  tmp1 := self selectedTab.  tmp1 ifNil: [ ^false ].  ^self selectedTab hasMenu or: [ self selectedTab hasActions ]-======-isSelfEvaluating  ^false-======-indentBy: arg1  indentation := arg1 + self cellInset-======-acceptDroppingMorph: arg1 event: arg2  | tmp1 tmp2 |  dropItemSelector ifNil: [ model acceptDroppingMorph: arg1 event: arg2 inMorph: self ] ifNotNil: [ tmp1 := arg1 passenger.        tmp2 := (self itemFromPoint: arg2 position) withoutListWrapper.        model perform: dropItemSelector with: tmp1 with: tmp2 ].  arg2 hand releaseMouseFocus: self.  Cursor normal show-======-halo  ^self valueOfProperty: #halo-======-playMaximizeSound  self theme windowMaximizeSound play-======-drawOn: arg1  super drawOn: arg1.  self drawGridOn: arg1.  self drawBackgroundSketchOn: arg1-======-openItemPath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  tmp1 := nil.  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ (arg2 complexContents withoutListWrapper = arg1 first or: [ arg1 first isNil ]) ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNotNil: [ tmp1 isExpanded ifFalse: [ tmp1 toggleExpandedState ].        tmp1 changed.        arg1 size = 1 ifTrue: [ ^container listManager setSelectedMorph: tmp1 ].        ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild openItemPath: arg1 allButFirst ] ].  ^self-======-minExtent  ^self theme tabSelectorMorphMinExtentFor: self-======-transferHalo: arg1 from: arg2  | tmp1 tmp2 tmp3 |  self flag: #workAround.  (arg2 == self and: [ self isRenderer and: [ self wantsHaloFromClick not ] ]) ifTrue: [ arg1 shiftPressed ifTrue: [ tmp3 := owner.              tmp1 := arg1 transformedBy: (self transformedFrom: owner) ] ifFalse: [ tmp3 := self renderedMorph.              tmp1 := arg1 transformedBy: (tmp3 transformedFrom: self) ].        ^tmp3 transferHalo: tmp1 from: tmp3 ].  (self isWorldMorph and: [ owner isNil ]) ifFalse: [ (self wantsHaloFromClick and: [ arg2 ~~ self ]) ifTrue: [ ^self addHalo: arg1 from: arg2 ] ].  arg1 shiftPressed ifTrue: [ owner ifNotNil: [ ^owner transferHalo: arg1 from: arg2 ].        arg2 removeHalo.        ^self processEvent: arg1 copy resetHandlerFields ].  self submorphsDo: [:arg3 |  tmp1 := arg1 transformedBy: (arg3 transformedFrom: self).        (arg3 fullContainsPoint: tmp1 position) ifTrue: [ ^arg3 transferHalo: arg1 from: arg2 ] ].  arg2 removeHalo.  (tmp2 := self world) ifNil: [ ^self ].  tmp1 := arg1 transformedBy: (self transformedFrom: tmp2) inverseTransformation.  ^tmp2 processEvent: tmp1 resetHandlerFields-======-invokeModal: arg1  ^self invokeModalAt: ActiveHand position in: self currentWorld allowKeyboard: arg1-======-setSelectionIndex: arg1  | tmp1 tmp2 |  arg1 ifNil: [ ^self ].  tmp2 := arg1 min: scroller submorphs size max: 0.  tmp1 := tmp2 = 0 ifTrue: [ nil ] ifFalse: [ scroller submorphs at: tmp2 ].  self setSelectedMorph: tmp1-======-inToggleArea: arg1  ^self sensitiveToggleRectangle containsPoint: arg1-======-onImage  ^image-======-initialize  isExpanded := false.  recentlyChanged := false-======-textColor: arg1  textColor := arg1-======-fontNumber  ^fontNumber-======-deleteBalloonTarget: arg1  self handsDo: [:arg2 |  arg2 deleteBalloonTarget: arg1 ]-======-expandAll: arg1  | tmp1 |  self expandAllSilently: arg1.  arg1 updateChildrenRecursively.  tmp1 := self scroller submorphs.  1 to: tmp1 size do: [:arg2 |  (tmp1 at: arg2) index: arg2 ].  self innerWidgetChanged-======-initializeClass: arg1  self initialize.  self elements: ((arg1 selectors sorted: [:arg2 :arg3 |  arg2 < arg3 ]) collect: [:arg4 |  FTExampleMethodModel method: arg1 >> arg4 ])-======-nextMorphAcrossInWindow  ^self submorphAfter ifNil: [ (self owner ifNil: [ ^self ]) nextMorphAcrossInWindow ]-======-privateMoveBy: arg1  | tmp1 |  super privateMoveBy: arg1.  tmp1 := self barFillStyle.  tmp1 isOrientedFill ifTrue: [ tmp1 origin: tmp1 origin + arg1 ]-======-gradientRamp  ^gradientRamp ifNil: [ {(0.0 -> originalColor muchLighter) .         (1.0 -> originalColor twiceDarker)} ]-======-lastSelectedNode  ^self lastSelectedNodePath ifNotNil: [:arg1 |  arg1 ifEmpty: [ nil ] ifNotEmpty: [:arg2 |  arg1 last ] ]-======-resetHScrollRange  hScrollRangeCache := nil.  self deriveHScrollRange-======-includesHandle: arg1  handles ifNil: [ ^false ].  ^handles includes: arg1-======-noteNewOwner: arg1  -======-delete  self removeHalo.  self activeHand     releaseKeyboardFocus: self;     releaseMouseFocus: self.  owner ifNotNil: [ self privateDelete.        self announceDeleted ]-======-spSetModal: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self activeHand keyboardFocus.  tmp2 := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  tmp2 ifNil: [ tmp2 := self ].  tmp2 modalLockTo: arg1.  tmp1 := RealEstateAgent maximumUsableArea.  arg1 extent: arg1 initialExtent.  arg1 position = (0 @ 0) ifTrue: [ arg1 position: self activeHand position - (arg1 extent // 2) ].  arg1 bounds: (arg1 bounds translatedToBeWithin: tmp1).  [ | tmp4 |  tmp4 := arg1.  [ tmp4 world notNil ] whileTrue: [ tmp4 outermostWorldMorph doOneCycle ] ] ensure: [ tmp2 modalUnlockFrom: arg1.        self activeHand newKeyboardFocus: tmp3 ].  ^arg1-======-label  ^label-======-drawOn: arg1  super drawOn: arg1.  topSeparator ifTrue: [ arg1 line: bounds topLeft to: bounds topRight color: self seperatorColor ]-======-computeCellSizes: arg1 in: arg2 horizontal: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := (Array new: arg1 submorphCount) writeStream.  tmp3 := properties minCellSize asPoint.  tmp4 := properties maxCellSize asPoint.  arg3 ifTrue: [ tmp3 := tmp3 transposed.        tmp4 := tmp4 transposed ].  tmp5 := 0 @ 0.  tmp2 := [:arg4 |  | tmp6 tmp7 |  arg4 disableTableLayout ifFalse: [ tmp7 := arg4 minExtent asIntegerPoint.        tmp6 := LayoutCell new target: arg4.        arg3 ifTrue: [ tmp6 hSpaceFill: arg4 hResizing == #spaceFill.              tmp6 vSpaceFill: arg4 vResizing == #spaceFill ] ifFalse: [ tmp6 hSpaceFill: arg4 vResizing == #spaceFill.              tmp6 vSpaceFill: arg4 hResizing == #spaceFill.              tmp7 := tmp7 transposed ].        tmp7 := (tmp7 min: tmp4) max: tmp3.        tmp6 cellSize: tmp7.        tmp5 := tmp5 max: tmp7.        tmp1 nextPut: tmp6 ] ].  properties reverseTableCells ifTrue: [ arg1 submorphsReverseDo: tmp2 ] ifFalse: [ arg1 submorphsDo: tmp2 ].  ^tmp5 -> tmp1 contents-======-setContainer: arg1  self changed.  container := arg1.  self releaseParagraph-======-wantsColumnBreaks  ^wantsColumnBreaks-======-addLine  submorphs isEmpty ifTrue: [ ^self ].  (self lastSubmorph isKindOf: DockingBarMenuLineMorph) ifFalse: [ self addMorphBack: DockingBarMenuLineMorph new ]-======-transformedBy: arg1  ^self shallowCopy transformBy: arg1-======-enabled  ^enabled ifNil: [ enabled := true ]-======-terminateUIProcess  UIProcess     suspend;     terminate.  UIProcess := nil-======-checkSplitters  (self submorphsSatisfying: [:arg1 |  arg1 isKindOf: ProportionalSplitterMorph ]) do: [:arg2 |  self checkMorphsLeftOrTopFrom: arg2.        self checkMorphsRightOrBottomFrom: arg2 ]-======-setSelectionListSelector: arg1  setSelectionListSelector := arg1-======-startDrag: arg1  | tmp1 tmp2 |  arg1 hand hasSubmorphs ifTrue: [ ^self ].  self dragEnabled ifFalse: [ ^self ].  arg1 hand anyButtonPressed ifFalse: [ ^self ].  self hasSelection ifFalse: [ ^self ].  tmp1 := self selectedIndexes collect: [:arg2 |  self dataSource passengerAt: arg2 ].  tmp2 := self dataSource transferFor: tmp1 from: self.  tmp2 align: tmp2 draggedMorph topLeft with: arg1 position.  tmp2 dragTransferType: self dataSource dragTransferType.  arg1 hand grabMorph: tmp2-======-expandAllFromNode: arg1  self requestView: (MorphTreeChangeRequest expandAllFromNode: arg1)-======-initializeContainer  container := self defaultContainer.  self addMorph: container-======-leftFraction: arg1  leftFraction := arg1-======-initialDataSource: arg1  initialDataSource := arg1-======-isFirstItem  ^owner submorphs first == self-======-selectMatch: arg1  | tmp1 |  self items do: [:arg2 |  | tmp2 |        tmp2 := arg1 isEmpty or: [ arg2 contents asString asLowercase includesSubstring: arg1 ].        arg2 isEnabled: tmp2.        (tmp2 and: [ tmp1 isNil ]) ifTrue: [ tmp1 := arg2 ] ].  ^tmp1-======-result  ^result-======-newImageFor: arg1 get: arg2 help: arg3  ^self theme newImageIn: self for: arg1 get: arg2 help: arg3-======-pressed: arg1  self model pressed: arg1-======-showWidget  self initializeMorph.  table     addMorph: field;     resizeAllSubviews-======-newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7  ^self theme newDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: arg6 help: arg7-======-deactivate  InputEventSensor default shutDown.  Display shutDown.  InputEventFetcher default shutDown-======-testLeftTopAligned  | tmp1 tmp2 |  tmp1 := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightFraction: 0 offset: 60;     bottomFraction: 0 offset: 25;     yourself.  tmp2 := tmp1 layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 110 @ 35) equals: tmp2-======-removeAlarm: arg1 for: arg2  worldState removeAlarm: arg1 for: arg2-======-deselectTimeOut: arg1  owner selectedItem == self ifTrue: [ arg1 hand releaseMouseFocus: owner.        owner selectItem: nil event: arg1 ]-======-showIconTreshold  ^(closeIcon visible ifTrue: [ 54 ] ifFalse: [ 40 ]) * self displayScaleFactor-======-chooseDirectory: arg1  ^self chooseDirectory: arg1 path: nil-======-mouseDown: arg1  self enabled ifTrue: [ self           scrollPoint: arg1;           computeSlider ].  super mouseDown: arg1.  self enabled ifFalse: [ ^self ].  arg1 hand newMouseFocus: slider event: arg1.  slider     mouseEnter: arg1 copy;     mouseDown: arg1 copy-======-hasSubMenu: arg1  ^submorphs anySatisfy: [:arg2 |  arg2 isMenuItemMorph and: (arg2 hasSubMenu: arg1) ]-======-containsPoint: arg1  | tmp1 |  ^(super containsPoint: arg1) and: [ tmp1 := SystemWindow borderWidth.        ((self bounds translateBy: tmp1 @ tmp1 negated) containsPoint: arg1) not ]-======-updateContents  target ifNotNil: [ contents := target perform: nameSelector ]-======-characterBlockForIndex: arg1  | tmp1 |  tmp1 := lines at: (self lineIndexForCharacter: arg1).  ^(CharacterBlockScanner new text: text textStyle: textStyle) characterBlockAtPoint: nil index: ((arg1 max: tmp1 first) min: text size + 1) in: tmp1-======-type: arg1 extension: arg2 action: arg3  action := arg3.  type := arg1.  extension := arg2-======-layoutProperties: arg1  self layoutProperties == arg1 ifTrue: [ ^self ].  self assureExtension layoutProperties: arg1-======-focusChanged  | tmp1 tmp2 |  tmp2 := self focusIndicatorMorph.  tmp2 fillStyle isTransparent ifTrue: [ tmp2 borderWidth > 0 ifTrue: [ tmp1 := tmp2 bounds areasOutside: (tmp2 bounds insetBy: tmp2 borderWidth).              tmp1 do: [:arg1 |  self invalidRect: arg1 ] ] ] ifFalse: [ self invalidRect: tmp2 bounds ]-======-isFirstColumn  ^container columns first = self-======-initialize  super initialize.  vertices := Array with: 5 @ 0 with: 20 @ 10 with: 0 @ 20.  closed := true.  smoothCurve := false.  arrows := #none.  self computeBounds.  self beSmoothCurve.  self diamondOval-======-dropEnabled  ^(self valueOfProperty: #dropEnabled) == true-======-onImageSelector: arg1  onImageSelector := arg1-======-defersHaloOnClickTo: arg1  ^true-======-moveSelectionDown: arg1 event: arg2  | tmp1 tmp2 |  tmp1 := self allEnabledSiblingItems.  tmp2 := (tmp1 indexOf: selectedItem ifAbsent: [ 0 + (arg1 negative ifTrue: [ 1 ] ifFalse: [ 0 ]) ]) + arg1.  tmp1 do: [:arg3 |  | tmp3 |        tmp3 := tmp1 atWrap: tmp2.        (tmp3 isMenuItemMorph and: [ tmp3 isEnabled ]) ifTrue: [ tmp3 owner = self owner ifFalse: [ arg2 hand newKeyboardFocus: tmp3 owner ].              ^tmp3 owner selectItem: tmp3 event: arg2 ].        tmp2 := tmp2 + arg1 sign ].  ^self selectItem: nil event: arg2-======-font  ^self listMorph font-======-testSelectLast  self subclassResponsibility-======-leftButtonEnabled  ^self wrapScrolling or: [ self visibleTabRange first > 1 ]-======-getRawLabel  | tmp1 |  tmp1 := label shallowCopy fitContents.  tmp1 extent: (label extent x min: tmp1 extent x) @ tmp1 extent y.  ^tmp1-======-doDebug: arg1 with: arg2  | tmp1 |  self world displayWorld.  arg1 shiftPressed ifTrue: [ self delete.        ^innerTarget inspectInMorphic: arg1 ].  tmp1 := innerTarget buildDebugMenu: arg1 hand.  tmp1     buildTitle: [:arg3 |  arg3           title: (innerTarget externalName asString truncateWithElipsisTo: 40);           withCloseBox;           withPinBox ];     popUpEvent: arg1 in: self world-======-moveSelectionDown: arg1 event: arg2  | tmp1 |  tmp1 := (submorphs indexOf: selectedItem ifAbsent: [ 1 - arg1 ]) + arg1.  submorphs do: [:arg3 |  | tmp2 |        tmp2 := submorphs atWrap: tmp1.        (tmp2 isMenuItemMorph and: [ tmp2 isEnabled ]) ifTrue: [ ^self selectItem: tmp2 event: arg2 ].        tmp1 := tmp1 + arg1 sign ].  ^self selectItem: nil event: arg2-======-mouseLeaveDragging: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #mouseLeaveDragging from: arg2-======-bestSegments  ^self honeIn: self calcEnoughSegments-======-findSubmorphBinary: arg1  ^submorphs findBinary: arg1 do: [:arg2 |  arg2 ] ifNone: [:arg3 :arg4 |   ]-======-hasExtraSelection  ^extraSelectionBlocks isEmptyOrNil not-======-internalSpaces: arg1 paddingWidth: arg2  internalSpaces := arg1.  paddingWidth := arg2-======-extent: arg1  arg1 x > arg1 y ifTrue: [ super extent: (arg1 max: (42 @ 8) scaledByDisplayScaleFactor) ] ifFalse: [ super extent: (arg1 max: (8 @ 42) scaledByDisplayScaleFactor) ]-======-abort: arg1  ^self abort: arg1 title: 'Error' translated-======-prepareForRotating  ^self addFlexShell-======-wantsDropSelector: arg1  wantsDropSelector := arg1-======-model  ^self complexContents-======-computeBounds  | tmp1 tmp2 tmp3 |  vertices ifNil: [ ^self ].  self changed.  tmp1 := bounds.  self releaseCachedState.  bounds := self curveBounds expanded.  self arrowForms do: [:arg1 |  bounds := bounds merge: (arg1 offset extent: arg1 extent) ].  handles ifNotNil: [ self updateHandles ].  (tmp1 notNil and: [ (tmp2 := bounds origin - tmp1 origin) ~= (0 @ 0) ]) ifTrue: [ tmp3 := IdentitySet new.        handles ifNotNil: [ tmp3 addAll: handles ].        self submorphsDo: [:arg2 |  (tmp3 includes: arg2) ifFalse: [ arg2 position: arg2 position + tmp2 ] ] ].  self layoutChanged.  self changed-======-hash  ^self morph hash bitXor: (self state hash bitXor: (self icon hash bitXor: self label hash))-======-newExpander: arg1  ^self theme newExpanderIn: self label: arg1 forAll: #()-======-rotationDegrees: arg1  self adjustAfter: [ self angle: arg1 degreesToRadians negated ]-======-childrenItems  ^Array new-======-addMorph: arg1 frame: arg2  ^self addMorph: arg1 fullFrame: arg2-======-deselectAll  | tmp1 |  self allNodeMorphs isEmpty ifTrue: [ ^self ].  self emptySelection.  self selectionUpdateFromViewWhile: [ tmp1 := self newSelectionHolderWithNodePath: nil.        self listModel selection: tmp1 ]-======-newMenuFor: arg1  ^self theme newMenuIn: self for: arg1-======-setSelectedMorph: arg1  selectedWrapper := arg1 complexContents.  self selection: selectedWrapper.  setSelectionSelector ifNotNil: [ model perform: setSelectionSelector with: (selectedWrapper ifNotNil: [ selectedWrapper item ]) ]-======-drawArrowOn: arg1 at: arg2 from: arg3  | tmp1 tmp2 tmp3 |  tmp1 := self arrowBoundsAt: arg2 from: arg3.  tmp3 := tmp1 size = 4 ifTrue: [ tmp1 third ] ifFalse: [ (tmp1 copyFrom: 2 to: 3) average ].  tmp2 := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  tmp2 x sign = tmp2 y sign ifTrue: [ arg1 drawPolygon: tmp1 fillStyle: borderColor ] ifFalse: [ arg1 drawPolygon: tmp1 fillStyle: Color transparent borderWidth: (borderWidth + 1) // 2 borderColor: borderColor ].  ^tmp3-======-adjacentTo  ^{(self bounds topRight + (5 @ 0)) .   (self bounds topLeft + (2 @ 0))}-======-testIsBeforeColumn  self subclassResponsibility-======-replaceFrom: arg1 to: arg2 with: arg3 displaying: arg4  text replaceFrom: arg1 to: arg2 with: arg3.  self recomposeFrom: arg1 to: arg1 + arg3 size - 1 delta: arg3 size - (arg2 - arg1 + 1)-======-initForKeystrokes  canMove := true.  lastKeystrokeTime := 0.  lastKeystrokes := ''-======-defaultTarget: arg1  defaultTarget := arg1-======-secondName: arg1  self item secondName: arg1.  self changed: #secondName-======-pageSizeToString  ^self pageSize asString-======-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-======-debugPrint  ^(WriteStream on: (String new: 10))     print: self class;     nextPutAll: ' (';     print: self date;     nextPutAll: ' - ';     print: self bounds;     nextPut: $);     contents-======-handle: arg1 in: arg2 dropEvent: arg3  ^action cull: arg1 cull: arg2 cull: arg3-======-gridModulus  ^self gridSpec extent-======-listMorphClass  ^MulticolumnLazyListMorph-======-commentText  ^(self theme newTextIn: self currentWorld text: self item comment)     unlock;     wrapFlag: true;     yourself-======-vScrollBarMenuButtonPressed: arg1  ^self scrollBarMenuButtonPressed: arg1-======-handlesMouseOver: arg1  ^false-======-isSelected  self model ifNil: [ ^false ].  ^self model perform: (self getStateSelector ifNil: [ ^false ])-======-taskbarThumbnailExtent  ^self isMinimized ifTrue: [ self fullFrame extent min: self defaultTaskbarThumbnailExtent ] ifFalse: [ super taskbarThumbnailExtent ]-======-extent: arg1  | tmp1 tmp2 |  tmp2 := self rotationCenter.  tmp1 := arg1 x min: arg1 y.  super extent: tmp1 @ tmp1.  self rotationCenter: tmp2-======-startPoint  ^startPoint-======-prepareForScaling  ^self-======-releaseCachedState  super releaseCachedState.  filledForm := nil.  arrowForms := nil.  borderForm := nil.  curveState := nil.  (self hasProperty: #flex) ifTrue: [ self removeProperty: #flex ]-======-indentationOfLineIndex: arg1 ifBlank: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := CharacterSet crlf.  tmp1 := arg1.  [ tmp2 := (lines at: tmp1) first.  tmp2 > 1 and: [ tmp4 includes: (text string at: tmp2 - 1) ] ] whileTrue: [ tmp1 := tmp1 - 1 ].  tmp3 := (lines at: tmp1) last.  ^(text string copyFrom: tmp2 to: tmp3) indentationIfBlank: arg2-======-chooseDirectory: arg1  ^self chooseDirectory: arg1 path: nil-======-selectedLocation  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self innerBounds.  tmp2 := self selectedColor.  tmp3 := tmp2 saturation * (tmp1 width - 1).  tmp4 := (1 - tmp2 brightness) * (tmp1 height - 1).  ^tmp3 truncated @ tmp4 truncated + tmp1 topLeft-======-grabMorph: arg1 from: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self releaseMouseFocus.  tmp1 := arg1.  arg1 keepsTransform ifTrue: [ tmp4 := tmp5 := IdentityTransform new ] ifFalse: [ tmp4 := arg2 ifNil: [ IdentityTransform new ] ifNotNil: [ arg2 grabTransform ].        tmp5 := arg2 ifNil: [ IdentityTransform new ] ifNotNil: [ arg2 transformFrom: owner ] ].  tmp3 := tmp5 globalPointToLocal: self position.  tmp2 := tmp3 - (tmp4 globalPointToLocal: self position).  tmp1 := tmp1 transformedBy: tmp4.  tmp1 == arg1 ifFalse: [ tmp1 setProperty: #addedFlexAtGrab toValue: true ].  tmp1 position: tmp1 position - tmp2 asIntegerPoint.  targetOffset := tmp1 position - self position.  self addMorphBack: tmp1.  tmp1 justGrabbedFrom: arg2-======-firstName  ^firstName-======-drawBackgroundForRow: arg1 on: arg2 color: arg3  | tmp1 |  tmp1 := self selectionFrameForRow: arg1.  arg2 fillRectangle: tmp1 color: arg3-======-newPosition: arg1  newPosition := arg1-======-setLayoutSizingFor: arg1  (arg1 = #left or: [ arg1 = #right ]) ifTrue: [ self           hResizing: #rigid;           vResizing: #spaceFill ].  (arg1 = #top or: [ arg1 = #bottom ]) ifTrue: [ self           hResizing: #spaceFill;           vResizing: #rigid ]-======-getEnabledSelector  ^getEnabledSelector-======-addScaleHandle: arg1  target shouldFlex ifTrue: [ (self addHandle: arg1 on: #mouseDown send: #startScale:with: to: self) on: #mouseMove send: #doScale:with: to: self ]-======-initializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #MorphFocusNavigation-======-keyString  ^String streamContents: [:arg1 |  self printKeyStringOn: arg1 ]-======-drawKeyTextOnAthenCanvas: arg1  self keyText ifNil: [ ^self ].  (ToggleMenuItemShortcut owner: self keyText: self keyText) drawOnAthensCanvas: arg1-======-hasDropShadowString  ^self hasDropShadow -> 'show shadow' translated-======-playCloseSound  self theme windowCloseSound play-======-monthNameFont  | tmp1 tmp2 |  tmp1 := LogicalFont familyName: 'Bitmap DejaVu Sans' pointSize: 12.  tmp2 := TextEmphasis italic emphasisCode | TextEmphasis bold emphasisCode.  ^tmp1 emphasis: tmp2-======-indicateModalChild  (self isMinimized and: [ self isTaskbarPresent ]) ifTrue: [ self worldTaskbar ifNotNil: [:arg1 |  arg1 indicateModalChildForMorph: self ] ] ifFalse: [ self flash ]-======-withAllOwners  ^Array streamContents: [:arg1 |  self withAllOwnersDo: [:arg2 |  arg1 nextPut: arg2 ] ]-======-expandNodePath: arg1  self requestView: (MorphTreeChangeRequest expandNodePath: arg1)-======-submorphsSatisfying: arg1  ^submorphs select: [:arg2 |  (arg1 value: arg2) == true ]-======-dragVertex: arg1 event: arg2 fromHandle: arg3  | tmp1 |  tmp1 := arg2 cursorPoint.  arg3 position: tmp1 - (arg3 extent // 2).  self verticesAt: arg1 put: tmp1-======-firstChild  ^firstChild-======-keyStroke: arg1  | tmp1 |  editView keyStroke: arg1.  (editView scrollByKeyboard: arg1) ifTrue: [ ^self ].  (acceptOnCR and: [ arg1 keyCharacter = Character cr ]) ifFalse: [ (editView navigationKey: arg1) ifTrue: [ ^self ] ].  self editor model: editView model.  tmp1 := editView.  (acceptOnCR and: [ arg1 keyCharacter = Character cr ]) ifTrue: [ ^self editor accept ].  super keyStroke: arg1.  tmp1 textChanged.  tmp1 scrollSelectionIntoView.  self doAutoAccept: arg1.  tmp1 scrollSelectionIntoView-======-nextSibling  ^nextSibling-======-drawOn: arg1  | tmp1 tmp2 |  tmp1 := self buildBorderVertices.  tmp2 := self buildVerticesFrom: tmp1.  arg1 drawPolygon: tmp2 color: self backgroundColor borderWidth: 0 borderColor: Color transparent.  tmp1 overlappingPairsDo: [:arg2 :arg3 |  arg1 line: arg2 to: arg3 width: 1 color: self borderColor ]-======-textColor  ^self valueOfProperty: #textColor ifAbsent: [ self theme textColor ]-======-lastVisibleRowIndex  ^self container lastVisibleRowIndex-======-widthToDisplayInList: arg1  ^self minExtent x-======-mouseStillDown: arg1  self eventHandler ifNotNil: [ self eventHandler mouseStillDown: arg1 fromMorph: self ]-======-eventQueue  ^Sensor-======-container  ^container-======-privateFullMoveBy: arg1  | tmp1 tmp2 |  selectedItems isEmpty ifTrue: [ ^super privateFullMoveBy: arg1 ].  tmp2 := self pasteUpMorph.  tmp2 ifNil: [ ^super privateFullMoveBy: arg1 ].  tmp1 := arg1 + slippage.  slippage := 0.  super privateFullMoveBy: tmp1.  selectedItems do: [:arg2 |  arg2 position: arg2 position + tmp1 ]-======-toggleRowIndex: arg1  self deprecated: 'Use #toggleIndex: instead.' transformWith: '`@receiver toggleRowIndex: `@statements' -> '`@receiver toggleIndex: `@statements'.  self toggleIndex: arg1-======-buildMetaMenu: arg1  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 add: 'grab' selector: #grabMorph:.  tmp1 add: 'copy to paste buffer' selector: #copyToPasteBuffer:.  self maybeAddCollapseItemTo: tmp1.  tmp1 add: 'delete' selector: #dismissMorph:.  tmp1 addLine.  tmp1 add: 'copy text' selector: #clipText.  tmp1 addLine.  tmp1 add: 'go behind' selector: #goBehind.  tmp1 add: 'add halo' selector: #addHalo:.  tmp1 add: 'duplicate' selector: #maybeDuplicateMorph:.  self addEmbeddingMenuItemsTo: tmp1 hand: arg1 hand.  tmp1 add: 'resize' selector: #resizeMorph:.  self addFillStyleMenuItems: tmp1 hand: arg1 hand.  self addDropShadowMenuItems: tmp1 hand: arg1 hand.  self addLayoutMenuItems: tmp1 hand: arg1 hand.  tmp1 addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().  tmp1 addLine.  tmp1 add: 'inspect' selector: #inspectAt:event: argument: arg1 position.  tmp1 add: 'explore' selector: #inspect.  tmp1 lastItem icon: (self iconNamed: #smallInspectItIcon).  tmp1 addLine.  tmp1 add: 'show actions' selector: #showActions.  tmp1 addLine.  self addDebuggingItemsTo: tmp1 hand: arg1 hand.  self addCustomMenuItems: tmp1 hand: arg1 hand.  ^tmp1-======-withoutListWrapper  ^complexContents withoutListWrapper-======-wantsDropSelector: arg1  wantsDropSelector := arg1-======-shouldDraw  ^self fillStyle isTransparent not-======-justified  self changeAlignment: #justified-======-elementWrapped: arg1  ^self wrapSelector ifNotNil: [:arg2 |  self model perform: arg2 with: arg1 ] ifNil: [ arg1 ]-======-testUpdateTaskBarShouldContainsTaskbarTasks  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: (taskbar tasks first isKindOf: TaskbarTask)-======-hasProperty: arg1  | tmp1 |  otherProperties ifNil: [ ^false ].  tmp1 := otherProperties at: arg1 ifAbsent: [  ].  tmp1 ifNil: [ ^false ].  tmp1 == false ifTrue: [ ^false ].  ^true-======-setTextStyle: arg1  textStyle := arg1.  self     releaseCachedState;     changed-======-forwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1-======-newToolDockingBar  ^self theme newToolDockingBarIn: self-======-setDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) rounded-======-positionSubmorphs  self submorphsDo: [:arg1 |  arg1 snapToEdgeIfAppropriate ]-======-hasCollapseBox  ^collapseBox notNil-======-newYesButton  ^self newYesButtonFor: self-======-calculateExactVisibleRows  | tmp1 tmp2 tmp3 |  self table hasDataSource ifFalse: [ ^super calculateExactVisibleRows ].  tmp1 := self table showIndex max: 1.  tmp3 := 0.  tmp2 := self height.  headerRow ifNotNil: [ tmp2 := tmp2 - headerRow height ].  [ tmp3 < tmp2 and: [ tmp1 <= self table dataSource numberOfRows ] ] whileTrue: [ tmp3 := tmp3 + (self table dataSource rowHeight: tmp1).        tmp1 := tmp1 + 1 ].  ^tmp1 - self table showIndex-======-ghostText  ^'Search...'-======-spawnBalloonFor: arg1  arg1 showBalloon: arg1 balloonText hand: self-======-wantsDirectionHandles  ^self valueOfProperty: #wantsDirectionHandles ifAbsent: [ false ]-======-fitTargetBoundsInOwner: arg1  | tmp1 tmp2 |  tmp2 := self target owner ifNil: [ ^self ].  tmp1 := tmp2 minExtent.  tmp1 x > self target owner width ifTrue: [ self edgeName = #left ifTrue: [ self target bounds: ((arg1 left + (tmp1 x - tmp2 width)) @ arg1 top extent: (arg1 width - (tmp1 x - tmp2 width)) @ arg1 height) ] ifFalse: [ self target bounds: (arg1 origin extent: (arg1 width - (tmp1 x - tmp2 width)) @ arg1 height) ] ].  tmp1 y > self target owner height ifTrue: [ self edgeName = #top ifTrue: [ self target bounds: (arg1 left @ (arg1 top + (tmp1 y - tmp2 height)) extent: arg1 width @ (arg1 height - (tmp1 y - tmp2 height))) ] ifFalse: [ self target bounds: (arg1 origin extent: arg1 width @ (arg1 height - (tmp1 y - tmp2 height))) ] ]-======-hasChildren  ^self children size ~= 0-======-value  ^progressBar value-======-translateBy: arg1  position := position + arg1.  startPoint := startPoint + arg1-======-showAbout  self theme longMessageIn: self text: self aboutText title: self aboutTitle-======-colorForInsets  (color isColor and: [ color isTransparent and: [ owner notNil ] ]) ifTrue: [ ^owner colorForInsets ].  ^color colorForInsets-======-clipSubmorphs: arg1  self invalidRect: self fullBounds.  arg1 == self clipSubmorphs ifFalse: [ self assureExtension.        extension clipSubmorphs: arg1.        self invalidRect: self fullBounds ]-======-getMenuSelector: arg1  getMenuSelector := arg1-======-readyToBeDisplayed  -======-isDeActivated  ^true-======-allMorphsDo: arg1  submorphs do: [:arg2 |  arg2 allMorphsDo: arg1 ].  arg1 value: self-======-canDrawBorder: arg1  ^true-======-sliderColor: arg1  | tmp1 |  super sliderColor: arg1.  self lastPaneColor: arg1.  tmp1 := self thumbColor.  upButton color: tmp1.  downButton color: tmp1.  slider color: tmp1 slightlyLighter.  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStyle.  (self theme scrollbarPagingAreaCornerStyleIn: self window) = #rounded ifTrue: [ self fillStyle: self normalButtonFillStyle ] ifFalse: [ self fillStyle: self normalFillStyle ].  self borderWidth: 0.  ^self adoptGradientColor: arg1-======-putLabelItemsInLabelArea  labelArea ifNotNil: [ stripes ifNotNil: [ stripes do: [:arg1 |  labelArea addMorph: arg1 ] ].        closeBox ifNotNil: [ labelArea addMorph: closeBox ].        menuBox ifNotNil: [ labelArea addMorph: menuBox ].        collapseBox ifNotNil: [ labelArea addMorph: collapseBox ].        label ifNotNil: [ labelArea addMorph: label ] ]-======-simulateKeyStroke: arg1  | tmp1 |  tmp1 := arg1 asKeyCombination.  self handleEvent: (KeyboardEvent new setType: #keystroke buttons: tmp1 modifier eventCode position: self position keyValue: tmp1 key asciiValue charCode: tmp1 key asciiValue hand: self activeHand stamp: DateAndTime now)-======-intersects: arg1  ^self fullBoundsInWorld intersects: arg1-======-newPreviewMorph  ^Morph new     color: Color transparent;     extent: self defaultPreviewExtent;     yourself-======-mouseMoveOnMultiple: arg1  | tmp1 tmp2 tmp3 |  canMove ifFalse: [ ^self ].  arg1 position y < self top ifTrue: [ scrollBar scrollUp: 1.        tmp3 := self rowAtLocation: scroller topLeft + (1 @ 1) ] ifFalse: [ tmp3 := arg1 position y > self bottom ifTrue: [ scrollBar scrollDown: 1.              self rowAtLocation: scroller bottomLeft + (1 @ -1) ] ifFalse: [ self rowAtLocation: arg1 position ] ].  tmp3 = 0 ifTrue: [ ^super mouseDown: arg1 ].  (self potentialDropItem notNil and: [ self dropEnabled ]) ifTrue: [ ^self ].  dragOnOrOff ifNil: [ dragOnOrOff := (self listSelectionAt: tmp3) not ].  tmp1 := self getCurrentSelectionIndex.  tmp1 ~= 0 ifTrue: [ tmp2 := self listSelectionAt: tmp1 ].  tmp1 ~= 0 ifTrue: [ self listSelectionAt: tmp1 put: tmp2 ].  self listSelectionAt: tmp3 put: dragOnOrOff.  tmp3 changed-======-drawSubmorphsOn: arg1  super drawSubmorphsOn: arg1.  self drawLinesOn: arg1-======-addPaneSplitters  self removePaneSplitters.  self addPaneVSplitters.  self addPaneHSplitters.  self linkSplittersToSplitters-======-dropFiles: arg1  | tmp1 |  tmp1 := arg1 contents.  1 to: tmp1 do: [:arg2 |  | tmp2 tmp3 |        tmp2 := arg1 requestDropReference: arg2.        tmp3 := ExternalDropHandler lookupExternalDropHandler: tmp2.        tmp3 ifNotNil: [ tmp3 handle: tmp2 in: self dropEvent: arg1 ] ]-======-bounds: arg1  | tmp1 |  tmp1 := arg1 width min: arg1 height.  super bounds: (Rectangle origin: arg1 origin extent: tmp1 @ tmp1)-======-searchStrategy  ^searchStrategy ifNil: [ #default ]-======-textEntry: arg1 title: arg2 entryText: arg3  ^self theme textEntryIn: self text: arg1 title: arg2 entryText: arg3-======-is: arg1 afterColumn: arg2  ^arg1 second > arg2-======-minWidth  ^self valueOfProperty: #minWidth ifAbsent: [ 2 ]-======-controls  ^controls-======-rowIndexToVerticalScrollBarValue: arg1  | tmp1 |  tmp1 := self numberOfRows - self container calculateMinVisibleRows.  ^(tmp1 = 0 or: [ arg1 <= 1 ]) ifTrue: [ 0.0 ] ifFalse: [ ((arg1 / tmp1) asFloat max: 0.0) min: 1.0 ]-======-image: arg1  ^self image: arg1 size: arg1 extent-======-allSubmorphNamesDo: arg1  ^self-======-dragItemSelector  ^dragItemSelector-======-pressedImageSelector  ^pressedImageSelector-======-minCellSize  ^0-======-vScrollbar  ^vScrollbar-======-showsNever  ^self showState == #never-======-index: arg1  index := arg1-======-updateValue  self model ifNotNil: [ self getValueSelector ifNotNil: [ self sliderMorph ifNotNil: [:arg1 |  arg1 scaledValue: self value.                    self                       changed: #minEnabled;                       changed: #maxEnabled ] ] ]-======-getEnabledSelector: arg1  getEnabledSelector := arg1.  self updateEnabled-======-newRow: arg1  ^self theme newRowIn: self for: arg1-======-handleUpdate: arg1  ^arg1 deliverTo: self-======-testIndexFromPosition  self assert: (strategy indexFromPosition: #(3 7)) equals: #(3 7)-======-printOn: arg1  arg1 nextPutAll: 'Node('.  self item printOn: arg1.  arg1 nextPut: $)-======-getListSizeSelector: arg1  getListSizeSelector := arg1-======-icon  ^icon-======-message: arg1  ^self message: arg1 title: 'Information' translated-======-tabs  ^tabs-======-optimalExtent  ^(Paragraph new     compose: text style: textStyle copy from: 1 in: (0 @ 0 extent: 9999999 @ 9999999);     adjustRightX;     extent) + (self borderWidth * 2) + (2 @ 0)-======-tabRemovedFromSelection: arg1  self setMultipleContents-======-drawLineFrom: arg1 to: arg2 on: arg3  | tmp1 |  tmp1 := (arg2 truncated quadrantOf: arg1 truncated) > 2 ifTrue: [ self topLeftColor ] ifFalse: [ self bottomRightColor ].  arg3 line: arg1 to: arg2 width: (self width - self margin max: 0) color: tmp1-======-beCellSelection  self selectionModeStrategy: (FTCellSelectionModeStrategy table: self)-======-newScrollPaneFor: arg1  ^self theme newScrollPaneIn: self for: arg1-======-currentNodelist  ^self nodeList copyFrom: self currentPageFirstIndex to: self currentPageLastIndex-======-removeDependent: arg1  self announcer unsubscribe: arg1-======-mouseOverAllowed  ^mouseOverAllowed ifNil: [ mouseOverAllowed := false ]-======-unexpandAllChildOf: arg1  arg1 children do: [:arg2 |  arg2 isExpanded ifTrue: [ self unexpandAllChildOf: arg2 ].        arg2 collapse ] displayingProgress: [:arg3 |  'Rearanging ' , arg3 name ]-======-addCustomHaloMenuItems: arg1 hand: arg2  self addCustomMenuItems: arg1 hand: arg2-======-passiveDisabledOverDownFillStyle: arg1  self stateMap atPath: #(passive disabled over down) put: arg1.  self changed-======-handlesMouseOver: arg1  self table ifNotNil: [:arg2 |  ^arg2 selectionModeStrategy allowsCellSelection ].  ^false-======-captureEventsUntil: arg1  | tmp1 |  tmp1 := false.  captureBlock := [:arg2 |  tmp1 := arg1 value: arg2 ].  [ [ self world doOneCycle.  tmp1 ] whileFalse ] ensure: [ captureBlock := nil ]-======-table: arg1  table := arg1-======-makeMeVisible  self world extent > (0 @ 0) ifFalse: [ ^self ].  ((self world bounds insetBy: (0 @ 0 corner: self labelHeight asPoint)) containsPoint: self position) ifTrue: [ ^self ].  self isCollapsed ifTrue: [ self position: (RealEstateAgent assignCollapsePointFor: self) ] ifFalse: [ self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent world: self world) topLeft ]-======-allowsRowSelection  ^false-======-offerWindowMenu  | tmp1 |  tmp1 := self buildWindowMenu.  tmp1     addLine;     add: 'Grab window...' target: self selector: #grabWindow.  tmp1 lastItem icon: (self iconNamed: #smallWindowIcon).  self tabGroup page ifNotNil: [:arg1 |  arg1 model addModelItemsToWindowMenu: tmp1 ].  tmp1 popUpEvent: self currentEvent in: self world-======-matchesTypes: arg1  (self type isNil or: [ arg1 isNil ]) ifTrue: [ ^false ].  ^arg1 anySatisfy: [:arg2 |  arg2 beginsWith: self type ]-======-numberOfLines  ^lines size-======-interactionState: arg1  -======-collapseAll  self subclassResponsibility-======-colorForSelection: arg1  ^arg1 ifTrue: [ self selectionColor ] ifFalse: [ self secondarySelectionColor ]-======-minimumSelection  ^1-======-stayUp  ^false-======-preferredButtonCornerStyle  ^#square-======-adoptPaneColor: arg1  super adoptPaneColor: arg1.  self hScrollbar adoptPaneColor: arg1.  self vScrollbar adoptPaneColor: arg1-======-moveShowIndexTo: arg1  | tmp1 tmp2 |  tmp1 := self selectionModeStrategy rowIndexFrom: arg1.  tmp2 := showIndex.  self basicMoveShowIndexTo: tmp1.  self verticalScrollBar value: (self rowIndexToVerticalScrollBarValue: tmp1).  self refresh.  self announceScrollChangedFrom: tmp2 to: tmp1-======-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-======-= arg1  ^arg1 class == self class and: [ arg1 anchoredMorph == anchoredMorph ]-======-menu  | tmp1 |  tmp1 := UIManager default newMenuIn: self currentWorld for: self.  tmp1 buildTitle: [:arg1 |  arg1 onlyCloseAndPinable ].  tmp1 add: 'Why you see this menu' target: self selector: #fallbackMenuExplanations.  tmp1 add: 'Debug' target: self selector: #debug.  tmp1 addLine.  client fallbackMenuOn: tmp1.  ^tmp1-======-expandAll  rootItem expandAll.  self tableRefresh-======-centeredAlert: arg1 title: arg2 configure: arg3  ^self theme centeredAlertIn: self text: arg1 title: arg2 configure: arg3-======-newStateForSelected: arg1  ^TabEnabled tab: self tab-======-useGradientFill  | tmp1 tmp2 tmp3 |  self fillStyle isGradientFill ifTrue: [ ^self ].  tmp2 := self color asColor.  tmp3 := tmp2 negated.  tmp1 := GradientFillStyle ramp: {(0.0 -> tmp2) .         (1.0 -> tmp3)}.  tmp1 origin: self topLeft.  tmp1 direction: 0 @ self bounds extent y.  tmp1 normal: self bounds extent x @ 0.  tmp1 radial: false.  self fillStyle: tmp1-======-optionalOperations  pattern isEmptyOrNil ifTrue: [ self unexpandAllChildOf: dataSource rootItem.        ^#() ] ifFalse: [ ^nil ]-======-imageMorph: arg1  imageMorph := arg1-======-initialize  super initialize.  self initForKeystrokes.  self on: #mouseMove send: #mouseStillDown:onItem: to: self-======-adjustAfter: arg1  arg1 value.  self chooseSmoothing.  self layoutChanged.  owner ifNotNil: [ owner invalidRect: bounds ]-======-userString  ^text string-======-newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self newMorphDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: true help: arg6-======-computeAltFramedColors  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self color asColor.  tmp2 := Color white.  tmp3 := Color black.  tmp4 := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  tmp4 := tmp4 asInteger.  tmp4 = 1 ifTrue: [ ^{(tmp1 mixed: 0.5 with: tmp2) .         (tmp1 mixed: 0.5 with: tmp3)} ].  tmp6 := Array new: tmp4.  tmp5 := tmp4 // 2.  0 to: tmp5 - 1 do: [:arg1 |  tmp7 := 0.5 + (arg1 asFloat / tmp5 * 0.5).        tmp6 at: arg1 + 1 put: (tmp1 mixed: tmp7 with: tmp3).        tmp6 at: tmp4 - arg1 put: (tmp1 mixed: tmp7 with: tmp2) ].  tmp4 odd ifTrue: [ tmp6 at: tmp5 + 1 put: tmp1 ].  ^tmp6 , tmp6-======-filterClass: arg1  filterClass := arg1-======-doubleClickTimeout  dblClickTimeoutSelector ifNotNil: [ clickClient perform: dblClickTimeoutSelector with: firstClickDown ]-======-first: arg1 last: arg2 color: arg3  first := arg1.  last := arg2.  color := arg3-======-wrapCentering  ^#topLeft-======-initializeColumsFrom: arg1  self columns: arg1 columns-======-chooseColor  ^self chooseColor: Color black-======-wasHandled  ^false-======-addDependent: arg1  dependents := #().  super addDependent: arg1-======-hsvaMorph: arg1  hsvaMorph := arg1-======-roundedCorners  self isAdheringToTop ifTrue: [ ^#(2 3) ].  self isAdheringToBottom ifTrue: [ ^#(1 4) ].  self isAdheringToLeft ifTrue: [ ^#(3 4) ].  self isAdheringToRight ifTrue: [ ^#(1 2) ].  ^#(1 2 3 4)-======-predecessor: arg1 successor: arg2  predecessor := arg1.  successor := arg2-======-blueButtonPressed  ^buttons anyMask: self class blueButton-======-iconPosition  ^iconPosition ifNil: [ iconPosition := #left ]-======-