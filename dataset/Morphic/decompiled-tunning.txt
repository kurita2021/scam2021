pressedImageSelector: arg1  pressedImageSelector := arg1newTextEntryFor: arg1 getText: arg2 setText: arg3 help: arg4  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: String getEnabled: nil help: arg4selectedRowIndex  ^self rowIndexFrom: self table selectedIndexhandleAsMouseEnter: arg1  | tmp1 |  tmp1 := arg1 asMouseEnter.  enteredMorphs := enteredMorphs contents.  enteredMorphs reverseDo: [:arg2 |  self inform: tmp1 to: arg2 originatedFrom: arg1 ifNotFocusedDo: [  ] ]initialize  super initialize.  self     clipLayoutCells: true;     color: Color transparent.  progress := 1.  progressIconMorph := self currentIcon asMorph.  self addMorphBack: progressIconMorph.  self extent: progressIconMorph extentfindExactPathMatchIn: arg1  self withSiblingsDo: [:arg2 |  (arg2 complexContents asString = arg1 first or: [ arg1 first isNil ]) ifTrue: [ ^arg2 ] ].  ^nilupdateValue  self model ifNotNil: [:arg1 |  self getValueSelector ifNotNil: [:arg2 |  self scaledValue: (arg1 perform: arg2) ] ]deny: arg1  ^self deny: arg1 title: 'Access Denied' translatedstyle  ^stylechoosePage  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  self allIntervals doWithIndex: [:arg1 :arg2 |  | tmp3 |        tmp3 := arg2 asString , ': ' , (self nodeList at: arg1 key) asString , ' ... ' , (self nodeList at: arg1 value) asString.        tmp1 add: arg2 -> tmp3 ].  tmp2 := UIManager default chooseFrom: (tmp1 collect: [:arg3 |  arg3 value ]) values: (tmp1 collect: [:arg3 |  arg3 key ]) lines: nil title: 'Choose a page'.  tmp2 ifNil: [ ^self ].  self currentPage: tmp2sentTo: arg1  type == #mouseMove ifTrue: [ ^arg1 handleMouseMove: self ].  ^super sentTo: arg1taskButtonOf: arg1  ^self submorphs detect: [:arg2 |  arg2 model = arg1 ] ifNone: [  ]transferHalo: arg1  target ifNil: [ ^self delete ].  target transferHalo: (arg1 transformedBy: (target transformedFrom: self)) from: targetnewBalloonHelp: arg1 for: arg2  ^self theme newBalloonHelpIn: self contents: arg1 for: arg2 corner: #bottomLefttopPasteUp  ^self outermostMorphThat: [:arg1 |  arg1 isKindOf: PasteUpMorph ]chooseFileName: arg1 extensions: arg2 path: arg3 preview: arg4  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4retrieveCheckIcon  ^self selected ifTrue: [ self iconNamed: #checkedBoxIcon ] ifFalse: [ self isPartialMatch ifTrue: [ self iconNamed: #partialCheckedBoxIcon ] ifFalse: [ self iconNamed: #uncheckedBoxIcon ] ]activeEnabledOverUpFillStyle: arg1  self stateMap atPath: #(active enabled over up) put: arg1.  self changedisRenderer  ^truescrollToShow: arg1  | tmp1 tmp2 tmp3 |  tmp1 := Rectangle origin: scroller offset extent: self innerBounds extent.  tmp2 := arg1 width < tmp1 width ifTrue: [ tmp1 right - arg1 right min: 0 max: tmp1 left - arg1 left ] ifFalse: [ tmp1 left - arg1 left min: 0 max: tmp1 right - arg1 right ].  tmp3 := arg1 height < tmp1 height ifTrue: [ tmp1 bottom - arg1 bottom min: 0 max: tmp1 top - arg1 top ] ifFalse: [ tmp1 top - arg1 top min: 0 max: tmp1 bottom - arg1 bottom ].  self scrollBy: tmp2 @ tmp3stickinessString  ^self isSticky -> 'resist being picked up' translatedisDefault: arg1  arg1 ifTrue: [ self setProperty: #isDefault toValue: true ] ifFalse: [ self removeProperty: #isDefault ].  self changedmouseEnter: arg1  owner ifNotNil: [ owner stayUp ifFalse: [ self mouseEnterDragging: arg1 ] ].  (owner selectedItem notNil and: [ owner selectedItem ~~ self ]) ifTrue: [ owner selectItem: self event: arg1 ]yellowButtonChanged  ^whichButton anyMask: self class yellowButtonisAlignmentMorph  ^truecleanseStepList  worldState cleanseStepListForWorld: selfisResized  ^trueadd: arg1 subMenu: arg2  self add: arg1 icon: nil subMenu: arg2selectedBorderStyle  ^self theme buttonSelectedBorderStyleFor: selfexpandAll: arg1  | tmp1 |  arg1 toggleExpandedState.  tmp1 := OrderedCollection new: 10.  arg1 recursiveAddTo: tmp1.  tmp1 do: [:arg2 |  (arg2 canExpand and: [ arg2 isExpanded not ]) ifTrue: [ self expandAll: arg2 ] ]getList  getListSelector ifNil: [ ^#() ].  list := model perform: getListSelector.  list ifNil: [ ^#() ].  list := list collectWithIndex: [:arg1 :arg2 |  self itemMorphFor: arg1 index: arg2 ].  ^listinitialize  super initialize.  manager := TabManagerMorph new.  manager when: #tabManagerDeleted send: #delete to: self.  listModel := SpListPresenter new.  listModel items: (1 to: 1000) asOrderedCollectionrowColorForEven: arg1 odd: arg2  rowColors at: 2 put: arg2.  rowColors at: 1 put: arg1mouseUp: arg1  arg1 hand mouseFocus == owner ifFalse: [ ^self ].  self contentString ifNotNil: [ self contents: self contentString withMarkers: true inverse: true.        self refreshWorld.        (Delay forMilliseconds: 200) wait ].  owner rootMenu selectItem: nil event: arg1.  self invokeWithEvent: arg1display: arg1  displayBlock := arg1contentHolder  ^self submorphs firstmouseDown: arg1  | tmp1 |  tmp1 := Array with: #click: with: nil with: nil with: (self dragEnabled ifTrue: [ #startDrag: ] ifFalse: [ nil ]).  arg1 hand waitForClicksOrDrag: self event: arg1 selectors: tmp1 threshold: 10.  super mouseDown: arg1newImage: arg1  ^self theme newImageIn: self form: arg1chooseStyle  self editor changeStyle.  self updateFromParagraphsolidLabelMorph: arg1  solidLabelMorph := arg1newRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6  ^self theme newRadioButtonIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: arg4 label: arg5 help: arg6quantum: arg1  (self sliderMorph ifNil: [ ^self ]) quantum: arg1compose: arg1 style: arg2 from: arg3 in: arg4  text := arg1.  textStyle := arg2.  firstCharacterIndex := arg3.  offsetToEnd := text size - firstCharacterIndex.  container := arg4.  self composeAllopen  ^self openOn: ObjectmouseDownInDimissHandle: arg1 with: arg2  arg1 hand obtainHalo: self.  self removeAllHandlesBut: arg2.  self setColor: Color darkGray toHandle: arg2lastClickedMorph: arg1  lastClickedMorph ifNotNil: [ lastClickedMorph complexContents lastClicked: false ].  lastClickedMorph := arg1.  arg1 ifNotNil: [ arg1 complexContents lastClicked: true ]askBeforeChanging: arg1  askBeforeChanging := arg1heading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]setButtonFont: arg1  | tmp1 tmp2 |  tmp1 := self buttons.  tmp2 := 0 @ 0.  tmp1 do: [:arg2 |  | tmp3 tmp4 |        tmp3 := arg2 hResizing.        tmp4 := arg2 vResizing.        arg2           hResizing: #shrinkWrap;           vResizing: #shrinkWrap.        arg2 label: arg2 label font: arg1.        tmp2 := tmp2 max: arg2 minExtent.        arg2           hResizing: tmp3;           vResizing: tmp4 ].  tmp1 do: [:arg2 |  arg2 extent: tmp2 ]borderForm  | tmp1 |  borderForm ifNotNil: [ ^borderForm ].  tmp1 := (Display defaultCanvasClass extent: bounds extent depth: 1) asShadowDrawingCanvas: Color black.  tmp1 translateBy: bounds topLeft negated during: [:arg1 |  self drawBorderOn: arg1 ].  borderForm := tmp1 form.  self arrowForms do: [:arg2 |  borderForm copy: arg2 boundingBox from: arg2 to: arg2 offset - self position rule: Form erase ].  ^borderFormtestTop  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Morph new.  tmp2 := 10.  tmp3 := self defaultTop + tmp2.  tmp4 := self defaultBounds translateBy: 0 @ tmp2.  tmp1 top: tmp3.  self     assert: tmp1 top equals: tmp3;     assert: tmp1 bounds equals: tmp4addDependent: arg1  self announcer when: MorphChanged , MorphChangedWithArguments send: #handleUpdate: to: arg1.  ^arg1ascendingSortFunction  ^self sortFunctionclose  closeable ifFalse: [ ^self ].  self okToClose ifFalse: [ ^self ].  self deletetoggleAutoGradient  self autoGradient: self autoGradient notselector: arg1  selector := arg1fileNames: arg1  fileNames := arg1isSimple  ^self isMultiple notdrawMeOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  super drawOn: arg1.  (tmp6 := self formOrMorphToView) isForm ifTrue: [ ^self drawForForm: tmp6 on: arg1 ].  (((tmp6 notNil and: [ (tmp5 := tmp6 world) notNil ]) and: [ tmp5 ~~ tmp6 or: [ lastFormShown isNil ] ]) and: [ RecursionDepth + 1 < RecursionMax ]) ifTrue: [ RecursionDepth := RecursionDepth + 1.        tmp1 := tmp6 fullBounds.        tmp2 := self scaleFor: tmp1 in: self innerBounds.        tmp3 := Display defaultCanvasClass extent: tmp1 extent depth: arg1 depth.        tmp3 translateBy: tmp1 topLeft negated during: [:arg2 |  arg2 fullDrawMorph: tmp6 ].        tmp4 := tmp3 form magnify: tmp3 form boundingBox by: tmp2 smoothing: 1.        lastFormShown := tmp4.        RecursionDepth := RecursionDepth - 1 ] ifFalse: [ lastFormShown ifNotNil: [ tmp4 := lastFormShown ] ].  tmp4 ifNotNil: [ arg1 paintImage: tmp4 at: self center - tmp4 boundingBox center ]drawDashedBorderOn: arg1 usingEnds: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  (borderColor isNil or: [ borderColor isColor and: [ borderColor isTransparent ] ]) ifTrue: [ ^self ].  tmp5 := borderColor.  tmp1 := false.  borderColor == #raised ifTrue: [ tmp2 := color lighter.        tmp3 := color darker.        tmp1 := true ].  borderColor == #inset ifTrue: [ tmp2 := owner colorForInsets darker.        tmp3 := owner colorForInsets lighter.        tmp1 := true ].  tmp4 := arg1 clipRect expandBy: (self borderWidth + 1) // 2.  tmp6 := self borderDashOffset.  self lineSegmentsDo: [:arg3 :arg4 |  | tmp7 tmp8 |        tmp8 := arg3 asIntegerPoint.        tmp7 := arg4 asIntegerPoint.        self hasArrows ifTrue: [ ((arrows == #back or: [ arrows == #both ]) and: [ arg3 = vertices first ]) ifTrue: [ tmp8 := arg2 first asIntegerPoint ].              ((arrows == #forward or: [ arrows == #both ]) and: [ arg4 = vertices last ]) ifTrue: [ tmp7 := arg2 last asIntegerPoint ] ].        (closed or: [ ((tmp8 min: tmp7) max: tmp4 origin) <= ((tmp8 max: tmp7) min: tmp4 corner) ]) ifTrue: [ tmp1 ifTrue: [ tmp5 := (tmp8 quadrantOf: tmp7) > 2 ifTrue: [ tmp2 ] ifFalse: [ tmp3 ] ].              tmp6 := arg1 line: tmp8 to: tmp7 width: borderWidth color: tmp5 dashLength: borderDashSpec first secondColor: borderDashSpec third secondDashLength: borderDashSpec second startingOffset: tmp6 ] ]protocolColumn: arg1 row: arg2  ^FTCellMorph new     color: (self colorFor: arg2);     addMorph: (self elementAt: arg2) protocol asStringMorph;     yourselfballoonHelpAligner  ^(self valueOfProperty: #balloonTarget) ifNil: [ self ]mouseLeave: arg1  arg1 hand showTemporaryCursor: nil.  self setDefaultColors.  self shouldInvalidateOnMouseTransition ifTrue: [ self changed ]adoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self pager ifNotNil: [:arg2 |  arg2 color: self pagerColor ]registerShortcuts  self     bindKeyCombination: $] meta shift toAction: [ self selectNext ];     bindKeyCombination: $[ meta shift toAction: [ self selectPrevious ];     bindKeyCombination: $w command toAction: [ self deleteSelectedTabs ];     bindKeyCombination: $w command shift toAction: [ self closeAllTabs ].  1 to: 9 do: [:arg1 |  self bindKeyCombination: arg1 asString first meta toAction: [ self selectTabAt: arg1 ] ].  self bindKeyCombination: $0 meta toAction: [ self selectLastTab ]listRenderOn: arg1 atRow: arg2 bounds: arg3 color: arg4 backgroundColor: arg5 from: arg6  self color: arg5.  self bounds: arg3.  self fullDrawOn: arg1.  arg6 addMorph: selfshortcutsHandler  ^ShortcutsHandlerfractions: arg1  self deprecated: 'Do not use this method. It forces to create spurious objects for nothing.'.  ^self fractions: arg1 offsets: nilcolorsAtCorners  | tmp1 tmp2 tmp3 |  tmp1 := self color.  tmp2 := tmp1 lighter.  tmp3 := tmp1 darker.  ^Array with: tmp3 with: tmp2 with: tmp2 with: tmp3addLastTabContents: arg1 among: arg2 delta: arg3  | tmp1 |  tmp1 := arg1 retrieveMorph: [:arg4 |  arg4 ifNil: [ TabWithNoContents signalTab: arg1 ].        contentsWrapper addMorph: arg4 fullFrame: (LayoutFrame identity                 leftFraction: (arg2 - 1) * arg3;                 leftOffset: 2;                 rightFraction: 1) ].  tmp1 ifNotNil: [ processes add: tmp1 ]newMenu  ^self theme newMenuIn: self for: selfforceRefreshOnNextChange  lastRefresh := 0newIncrementalSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newIncrementalSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8mouseUp: arg1  (arg1 commandKeyPressed or: [ arg1 controlKeyPressed ]) ifTrue: [ self toggleSelection ] ifFalse: [ arg1 shiftPressed ifTrue: [ self selectToMe ] ifFalse: [ self selected: true ] ]newToolbar  ^self theme newToolbarIn: selfautoDeselect: arg1  autoDeselect := arg1clippingRectangle  ^self innerBoundsareasRemainingToFill: arg1  ^Array with: arg1keepsTransform  ^falsemouseEnterDownButton: arg1  downButton     fillStyle: self mouseOverButtonFillStyle;     borderStyle: self mouseOverButtonBorderStyle;     changedwindowIndex: arg1  windowIndex := arg1expandRoots  self requestView: MorphTreeChangeRequest expandRootskeyStroke: arg1  super keyStroke: arg1.  (self defaultButton notNil and: [ arg1 keyCharacter = Character cr ]) ifTrue: [ self returnPressed.        ^true ].  arg1 keyCharacter = Character escape ifTrue: [ self escapePressed.        ^true ].  ^falseaddToSelection: arg1 clickedTheCheckBox: arg2  arg1 selected ifTrue: [ ^false ].  self searchedElement: nil.  arg2 ifFalse: [ arg1 highlight ].  arg1 selected: true.  ^truetestAthensRender  | tmp1 |  tmp1 := AthensCairoSurface extent: Display extent.  tmp1 drawDuring: [:arg1 |  self fullDrawOnAthensCanvas: arg1 ].  Display getCanvas drawImage: tmp1 asForm at: 0 @ 0firstNameMorph  ^(self theme newTextEntryIn: self currentWorld for: self get: #firstName set: #firstName: class: String getEnabled: nil help: nil) color: Color transparentresizeContainerFrom: arg1 to: arg2  self subclassResponsibilityaddResizeSplitters  | tmp1 tmp2 tmp3 |  tmp1 := self calculateColumnWidths.  tmp2 := self left.  tmp3 := FTColumnResizerMorph resizerWidth / 2.  self table columns overlappingPairsWithIndexDo: [:arg1 :arg2 :arg3 |  tmp2 := tmp2 + (tmp1 at: arg3) + self table intercellSpacing x.        self addMorph: ((FTColumnResizerMorph container: self left: (FTDisplayColumn column: arg1 width: (tmp1 at: arg3)) right: (FTDisplayColumn column: arg2 width: (tmp1 at: arg3 + 1)))                 bounds: ((tmp2 - tmp3) @ self top extent: tmp3 @ self height);                 color: Color transparent;                 yourself) ]increment  self value: self value + self quantumsetCurveBaseline: arg1  | tmp1 tmp2 |  tmp2 := arg1 cursorPoint.  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  tmp1 removeAllMorphs.        tmp1 addMorph: (PolygonMorph vertices: (Array with: tmp2 with: arg2) color: Color black borderWidth: 1 borderColor: Color black).        container baseline: (arg2 - tmp2) y negated asInteger // 5.        self paragraph composeAll ].  arg1 hand attachMorph: tmp1.  tmp1 startSteppinghandleMouseStillDown: arg1  arg1 hand mouseFocus == self ifFalse: [ ^self stopSteppingSelector: #handleMouseStillDown: ].  self mouseStillDown: arg1.  ^self eventHandler ifNotNil: [:arg2 |  arg2 mouseStillDown: arg1 fromMorph: self ]initialRootItems  ^initialRootItems ifNil: [ initialRootItems := #() ]chooseEmphasis  self editor changeEmphasis.  self updateFromParagraphhideRightOrBottom  self hide.  rightOrBottom do: [:arg1 |  arg1 hide ]rowColorForEven: arg1  rowColors at: 1 put: arg1remind: arg1  | tmp1 |  tmp1 := (arg1 contents hash + arg1 keyText hash) hashMultiply.  (self wantsToShow: tmp1) ifFalse: [ ^self ].  self     show: arg1;     updateCount: tmp1theme  ^Smalltalk ui themeinsertVertexAt: arg1 put: arg2  self setVertices: (vertices copyReplaceFrom: arg1 + 1 to: arg1 with: (Array with: arg2))orderedTasks: arg1  tasks := arg1doubleClick: arg1  self isResizeable ifTrue: [ super doubleClick: arg1 ]selectionFillStyle  Display depth <= 2 ifTrue: [ ^Color gray ].  ^self theme menuSelectionColornavigateFocusBackward  self previousMorphWantingFocus ifNotNil: [:arg1 |  arg1 takeKeyboardFocus ]viewBox: arg1  super position: arg1 topLeft.  fullBounds := bounds := arg1newStateForSelected: arg1  self assert: arg1.  ^TabSelected tab: self tabsearchedElement  ^searchedElementenable  self enabled: truehTotalScrollRange  ^self hUnadjustedScrollRange + self hExtraScrollRange + self hMarginhScrollbarInterval  ^self scrollBounds width asFloat / self scrollTarget width min: 1.0update: arg1  super update: arg1.  arg1 = self getImageSelector ifTrue: [ self updateImage ]handleBasicKeys: arg1  handlesBasicKeys := arg1displayExtraSelectionOnAthensCanvas: arg1  | tmp1 |  tmp1 := arg1 clipRect.  refreshExtraSelection = true ifTrue: [ self buildSelectionBlocksFrom: tmp1 topLeft to: tmp1 bottomRight.        refreshExtraSelection := false ].  extraSelectionBlocks ifNotNil: [ self forLinesIn: tmp1 do: [:arg2 |  extraSelectionBlocks do: [:arg3 |  self displaySelectionBlock: arg3 inLine: arg2 onAthensCanvas: arg1 ] ] ]seasideMimeDocumentType: arg1  ^self imageForm seasideMimeDocumentType: arg1newListFor: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newListIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4 getEnabled: arg5 help: arg6list: arg1  | tmp1 tmp2 |  tmp1 := self currentlyExpanded.  scroller removeAllMorphs.  (arg1 isNil or: [ arg1 isEmpty ]) ifTrue: [ ^self selectedMorph: nil ].  tmp2 := OrderedCollection new.  self addMorphsTo: tmp2 from: arg1 allowSorting: false withExpandedItems: tmp1 atLevel: 0.  self insertNewMorphs: tmp2addBlankIconsIfNecessary: arg1  self items reject: [:arg2 |  arg2 hasIconOrMarker ] thenDo: [:arg2 |  arg2 icon: arg1 ]doLayoutIn: arg1  | tmp1 tmp2 |  tmp2 := self outerBounds.  submorphs isEmpty ifTrue: [ ^fullBounds := tmp2 ].  submorphs do: [:arg2 |  arg2 ownerChanged ].  self layoutPolicy ifNotNil: [:arg3 |  arg3 layout: self in: arg1 ].  self adjustLayoutBounds.  fullBounds := self privateFullBounds.  tmp1 := self outerBounds.  tmp1 = tmp2 ifFalse: [ self invalidRect: (tmp2 quickMerge: tmp1) ]openInWorld  super openInWorld.  self width: 200.  self resizekeyboardFocusChange: arg1  super keyboardFocusChange: arg1.  arg1 ifTrue: [ (self ownerThatIsA: GeneralScrollPane) ifNotNil: [:arg2 |  arg2 scrollToShow: self bounds ] ] ifFalse: [ self selectItem: nil event: nil ]getFiltering: arg1  ^self valueOfProperty: #matchString ifAbsentPut: [ String new ]selectInvisiblyFrom: arg1 to: arg2  editor ifNotNil: [ editor selectInvisiblyFrom: arg1 to: arg2 ]indentLevel  ^indentLevelpreferedFont  ^self balloonFontscrollRestrictedDown: arg1  self canScrollDown ifFalse: [ ^self ].  self scrollDown: arg1on: arg1 getValue: arg2 setValue: arg3  self     model: arg1;     getValueSelector: arg2;     setValueSelector: arg3;     updateValueisCenter  ^self option == #centerupdateBounds  self updateExtent.  self isFloating ifFalse: [ self updatePosition ]getListItem: arg1  ^listSource getListItem: arg1startStepping: arg1 at: arg2 selector: arg3 arguments: arg4 stepTime: arg5  self stopStepping: arg1 selector: arg3.  self adjustWakeupTimesIfNecessary.  stepList add: (StepMessage scheduledAt: arg2 stepTime: arg5 receiver: arg1 selector: arg3 arguments: arg4)stopSteppingSelfAndSubmorphs  self allMorphsDo: [:arg1 |  arg1 stopStepping ]listRenderOn: arg1 atRow: arg2 bounds: arg3 color: arg4 backgroundColor: arg5 from: arg6  self bounds: arg3.  self fullDrawOn: arg1.  (arg6 submorphs includes: self) ifFalse: [ arg6 addMorph: self ]form  ^imageformerOwner: arg1  arg1 ifNil: [ self removeProperty: #formerOwner ] ifNotNil: [ self setProperty: #formerOwner toValue: arg1 ]waitForClicksOrDrag: arg1 event: arg2 selectors: arg3 threshold: arg4  mouseClickState := MouseClickState new client: arg1 click: arg3 first dblClick: arg3 second dblClickTime: DoubleClickTime dblClickTimeout: arg3 third drag: arg3 fourth threshold: arg4 event: arg2hasFilter  function ifNil: [ ^false ].  ^function isKindOf: FTFilterFunctionsetConstrainedPosition: arg1 hangOut: arg2  | tmp1 tmp2 tmp3 tmp4 |  owner ifNil: [ ^self ].  tmp1 := arg1 extent: self bounds extent.  tmp3 := self topRendererOrSelf owner.  tmp2 := tmp3 ifNil: [ 0 @ 0 ] ifNotNil: [ tmp4 := arg2 ifTrue: [ tmp3 bounds insetBy: self extent negated + tmp3 borderWidth + (2 @ 2) ] ifFalse: [ tmp3 bounds ].        tmp1 amountToTranslateWithin: tmp4 ].  self position: arg1 + tmp2.  self layoutChangedfastAnimateRectangles: arg1  | tmp1 tmp2 tmp3 |  arg1 ifEmpty: [ ^self ].  tmp1 := Delay forMilliseconds: self theme animationSettings delay.  tmp2 := Color gray alpha: 0.5.  tmp3 := arg1 first.  arg1 withIndexDo: [:arg2 :arg3 |  Display border: arg2 rounded width: 1 rule: Form blend fillColor: tmp2.        tmp3 := tmp3 merge: arg2.        tmp1 wait ].  tmp3 := tmp3 expandBy: 1.  self currentWorld invalidRect: tmp3 from: selfsubMenuMarker  owner isFloating ifTrue: [ ^self bottomArrow ].  owner isAdheringToTop ifTrue: [ ^self bottomArrow ].  owner isAdheringToBottom ifTrue: [ ^self upArrow ].  owner isAdheringToLeft ifTrue: [ ^self rightArrow ].  owner isAdheringToRight ifTrue: [ ^self leftArrow ].  ^self rightArrowis: arg1 aboveRow: arg2  ^arg1 first < arg2pageMorphs  ^pageMorphsdrawOn: arg1  super drawOn: arg1.  icon ifNil: [ ^self ].  icon form ifNil: [ ^self ].  arg1 translucentImage: icon form at: self topLeftkeyStroke: arg1  super keyStroke: arg1.  self selectedObject ifNotNil: [:arg2 |  arg2 moveOrResizeFromKeystroke: arg1 ].  self dispatchKeystroke: arg1wrapDirection  ^wrapDirectionhasYellowButtonMenu  ^self wantsYellowButtonMenu or: [ model ifNil: [ false ] ifNotNil: [:arg1 |  arg1 hasModelYellowButtonMenuItems ] ]hExtraScrollRange  ^self scrollDeltaWidthgetListElementSelector  ^getListElementSelectorchildren  ^children ifNil: [ children := self calculateChildren ]veryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  target := arg1 references at: target ifAbsent: [ target ].  innerTarget := arg1 references at: innerTarget ifAbsent: [ innerTarget ]contentsClipped: arg1  contents = arg1 ifTrue: [ ^self ].  contents := arg1.  self changedicon: arg1  icon ifNotNil: [ icon delete ].  icon := arg1 asMorph.  closeBox ifNotNil: [ ^self addMorph: icon after: closeBox ].  self addMorphFront: iconjustDroppedInto: arg1 event: arg2  | tmp1 |  (self formerOwner notNil and: [ self formerOwner ~~ arg1 ]) ifTrue: [ self removeHalo ].  self formerOwner: nil.  self formerPosition: nil.  (tmp1 := arg1 ownerThatIsA: SystemWindow) ifNotNil: [ tmp1 isActive ifFalse: [ tmp1 activate ] ].  (self hasProperty: #beFullyVisibleAfterDrop) ifTrue: [ arg1 == self currentWorld ifTrue: [ self goHome ].        self removeProperty: #beFullyVisibleAfterDrop ]hasContentToShow  ^self complexContents hasContentToShownewMenuFor: arg1  ^self theme newMenuIn: self for: arg1initialize  super initialize.  self layoutPolicy: TableLayout new.  self     listDirection: #leftToRight;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: 3;     cellInset: 3;     wrapCentering: #center;     cellPositioning: #leftCenter.  self borderStyle: (BorderStyle width: 1 color: Color lightGray).  accepted := false.  copy := false.  self on: #keyStroke send: #keyStroke: to: selftestTransformReturnEmptyRectangleWhenNotPossibleToPlace  | tmp1 tmp2 tmp3 |  tmp1 := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  tmp3 := 0 @ 0 extent: 10 @ 10.  tmp2 := tmp1 transform: tmp3.  self assert: tmp2 width equals: 0.  self assert: tmp2 height equals: 0isCheckList: arg1  ^isCheckList := arg1= arg1  self species = arg1 species ifTrue: [ ^((firstIndex = arg1 first and: [ lastIndex = arg1 last ]) and: [ internalSpaces = arg1 internalSpaces ]) and: [ paddingWidth = arg1 paddingWidth ] ] ifFalse: [ ^false ]blackGradient  ^(InterpolatedGradientFillStyle colors: {(Color black alpha: 0) .         Color black})     origin: self innerBounds topLeft;     direction: 0 @ self innerBounds heightwindowEvent: arg1  self windowEventHandler ifNotNil: [ ^self windowEventHandler windowEvent: arg1 ].  (arg1 type == #windowClose and: [ self valueOfProperty: #canOpenCloseDialog ifAbsent: true ]) ifTrue: [ self setProperty: #canOpenCloseDialog toValue: false.        WorldState quitSession.        self removeProperty: #canOpenCloseDialog ]balloonTextSelector  ^balloonTextSelectortotalSliderArea  | tmp1 |  tmp1 := upButton.  bounds isWide ifTrue: [ upButton right > tmp1 right ifTrue: [ tmp1 := upButton ].        ^tmp1 bounds topRight corner: downButton bounds bottomLeft ] ifFalse: [ upButton bottom > tmp1 bottom ifTrue: [ tmp1 := upButton ].        ^tmp1 bounds bottomLeft corner: downButton bounds topRight ]selector  ^self itemhScrollbarValue  | tmp1 tmp2 tmp3 |  tmp1 := self scrollTarget width.  tmp2 := self scrollBounds width.  tmp3 := tmp1 - tmp2 max: 0.  tmp3 = 0 ifFalse: [ tmp3 := self scroller offset x asFloat / tmp3 min: 1.0 ].  ^tmp3showIndex  ^showIndexinsertCharacters: arg1  | tmp1 |  tmp1 := self cursor max: 1.  paragraph replaceFrom: tmp1 to: tmp1 - 1 with: arg1 asText displaying: true.  self updateFromParagraphchanged: arg1  self doAnnounce: (MorphChanged new           morph: self;           selector: arg1)isExpanded  ^truemouseLeaveIcon  closeable ifFalse: [ ^self ].  fadeOut ifNotNil: [ fadeOut terminate ].  fadeOut := [ closeIcon image: self class closeHalfOverIcon.  50 milliSeconds asDelay wait.  closeIcon image: self class closeIcon ] forkcloseable: arg1  closeable := arg1.  arg1 ifTrue: [ self showCloseIcon ] ifFalse: [ self hideCloseIcon ]setUnlockedIcon  closeIcon image: self class closeIconfontName: arg1 size: arg2  | tmp1 |  tmp1 := ((TextStyle named: arg1 asSymbol) ifNil: [ TextStyle default ]) copy.  textStyle := tmp1.  text addAttribute: (TextFontChange fontNumber: (tmp1 fontIndexOfSize: arg2)).  paragraph ifNotNil: [ paragraph textStyle: tmp1 ]gapAfterToggle: arg1  gapAfterToggle := arg1calculateChildren  ^self getChildren collect: [:arg1 |  (self class data: arg1 from: dataSource)           depth: self depth + 1;           yourself ]initialize  super initialize.  self fillStyle: self fillStyleToUse.  self borderStyle: self borderStyleToUsemakeUnclosable  mustNotClose := true.  self deleteCloseBoxstopStepping: arg1  lastStepMessage ifNotNil: [ lastStepMessage receiver == arg1 ifTrue: [ lastStepMessage := nil ] ].  stepList removeAll: (stepList select: [:arg2 |  arg2 receiver == arg1 ])addDropShadow  self hasDropShadow ifTrue: [ ^self ].  self changed.  self hasDropShadow: true.  self shadowOffset: 3 @ 3.  self layoutChanged.  self changedmouseOverFillStyle  ^self theme buttonMouseOverFillStyleFor: selfundoTypeIn: arg1 interval: arg2  self handleEdit: [ self editor undoTypeIn: arg1 interval: arg2 ]morphsInFrontOf: arg1 overlapping: arg2 do: arg3  self handsDo: [:arg4 |  arg4 == arg1 ifTrue: [ owner ifNil: [ ^self ].              ^owner morphsInFrontOf: self overlapping: arg2 do: arg3 ].        arg4 needsToBeDrawn ifTrue: [ (arg4 fullBoundsInWorld intersects: arg2) ifTrue: [ arg3 value: arg4 ] ] ].  ^super morphsInFrontOf: arg1 overlapping: arg2 do: arg3icon  ^iconenable  self enabled: trueheading  | tmp1 |  ^(tmp1 := self renderedMorph) == self ifTrue: [ 0.0 ] ifFalse: [ tmp1 heading ]newCancelButton  ^self newCancelButtonFor: selftransformVerticesFrom: arg1 to: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := self world.  tmp1 := arg1 ifNil: [ IdentityTransform new ] ifNotNil: [ arg1 transformFrom: tmp3 ].  tmp2 := arg2 ifNil: [ IdentityTransform new ] ifNotNil: [ arg2 transformFrom: tmp3 ].  tmp4 := vertices collect: [:arg3 |  tmp2 globalPointToLocal: (tmp1 localPointToGlobal: arg3) ].  self setVertices: tmp4multiComposeLinesFrom: arg1 to: arg2 delta: arg3 into: arg4 priorLines: arg5 atY: arg6  | tmp1 |  tmp1 := self composer multiComposeLinesFrom: arg1 to: arg2 delta: arg3 into: arg4 priorLines: arg5 atY: arg6 textStyle: textStyle text: text container: container wantsColumnBreaks: wantsColumnBreaks == true.  lines := tmp1 first asArray.  ^maxRightX := tmp1 secondtestSelectableIndexBellow  self subclassResponsibilitycornerRadius  ^5handlesKeyUp: arg1  ^self existsSubscriptionsFor: #keyUpwantsYellowButtonMenu  ^self defaultYellowButtonMenuEnabledarguments: arg1  arguments := arg1hMargin  ^3baseColor: arg1  | tmp1 |  tmp1 := arg1 isTransparent ifTrue: [ nil ] ifFalse: [ arg1 ].  baseColor = tmp1 ifTrue: [ ^self ].  baseColor := tmp1.  self releaseCachedState.  self color: tmp1hasContents  ^model hasNodeContents: selfselectItems: arg1  self selection: nil.  self requestView: (MorphTreeChangeRequest selectItems: arg1)getEnabledSelector: arg1  getEnabledSelector := arg1.  self updateEnabledtestSelectableIndexBellow  self assert: (strategy selectableIndexBellow: #(2 3)) equals: #(3 3)mouseOverFillStyle  ^self theme taskbarItemMouseOverFillStyleFor: selfcreateResetCountButtonMorph  ^SimpleButtonMorph new     target: self;     label: 'Reset notification counts';     actionSelector: #resetCount;     themeChanged;     yourselfborderColor: arg1  self doesBevels ifFalse: [ arg1 isColor ifFalse: [ ^self ] ].  borderColor = arg1 ifFalse: [ borderColor := arg1.        self changed ]topOffset: arg1  topOffset := arg1minCellSize  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ 0 ] ifNotNil: [ tmp1 minCellSize ]initialize  offset := 1.  alpha := 0.5.  super initializemouseMove: arg1  arg1 redButtonPressed ifFalse: [ ^super mouseMove: arg1 ].  self selectColorAt: arg1 position.  ^super mouseMove: arg1resizeMorph: arg1  | tmp1 |  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  self extent: arg2 - self bounds topLeft ].  arg1 hand attachMorph: tmp1.  tmp1 startSteppingwantsDropSelector  ^wantsDropSelectoraddExpandBox  labelArea ifNil: [ ^self ].  expandBox := self createExpandBox.  self setExpandBoxBalloonText.  expandBox layoutFrame: (LayoutFrame new           leftFraction: 1;           leftOffset: (self boxExtent x * 2 + 3) negated).  labelArea addMorphBack: expandBoxbuttons  ^{self firstSubmorph .   self lastSubmorph}dialogWindowIn: arg1 title: arg2 selectedtems: arg3  | tmp1 tmp2 |  tmp1 := self theme newPluggableDialogWindowIn: arg1 title: arg2 for: (tmp2 := self defaultMorphIn: arg1).  tmp2     buildContents;     selectedItems: arg3.  tmp1 minimumExtent: 300 @ 500.  tmp1 beResizeable.  ^tmp1enabled: arg1  enabled := arg1.  self changedadjustedFirstCharacterIndex  offsetToEnd ifNil: [ ^-1 ].  ^text size - offsetToEndvertices  ^verticesautoMultiSelection: arg1  autoMultiSelection := arg1.  arg1 ifTrue: [ self multipleSelection: true ]enabledString  ^self enabled -> 'enabled' translatedforwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]borderWidth  ^borderWidthposition  ^bounds topLeft= arg1  super = arg1 ifFalse: [ ^false ].  position = arg1 position ifFalse: [ ^false ].  buttons = arg1 buttons ifFalse: [ ^false ].  ^truebuildYellowButtonMenu: arg1  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  self addNestedYellowButtonItemsTo: tmp1 event: ActiveEvent.  ^tmp1angle  ^transform anglelabelMorph  ^labelMorphdoGrab: arg1 with: arg2  self obtainHaloForEvent: arg1 andRemoveAllHandlesBut: arg2.  arg1 hand grabMorph: target.  self step.  arg1 hand addMouseListener: selfdrawSubmorphsOn: arg1  super drawSubmorphsOn: arg1.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: arg1 ]pressedFillStyle  ^self theme windowEdgePressedFillStyleFor: selfinitialize  super initialize.  emphasis := 0.  indent := 0.  kern := 0.  fontNumber := 1.  actualFont := TextStyle defaultFontbasicLabel  ^labelselection  ^selectioncontentsOfNode: arg1  | tmp1 |  getChildrenSelector ifNil: [ ^#() ].  tmp1 := model perform: getChildrenSelector with: arg1 item.  ^tmp1 collect: [:arg2 |  PluggableTreeItemNode with: arg2 model: self ]initialize  super initialize.  value := 0.  start := 0.  end := 100.  height := DefaultHeight.  width := DefaultWidth.  cachedWidth := 0.  self     fillStyle: (self theme progressBarFillStyleFor: self);     borderStyle: (self theme progressBarBorderStyleFor: self);     barFillStyle: (self theme progressBarProgressFillStyleFor: self);     extent: width @ height + (2 * self borderWidth)extent: arg1  | tmp1 |  bounds extent = arg1 ifTrue: [ ^self ].  super extent: arg1.  tmp1 := (self vScrollbarShowing = self vScrollbarNeeded) not.  tmp1 := tmp1 or: [ (self hScrollbarShowing = self hScrollbarNeeded) not ].  self updateScrollbars.  tmp1 ifFalse: [ self resizeScroller ]insertNewMorphs: arg1  scroller addAllMorphs: arg1.  self adjustSubmorphPositions.  self selection: self getCurrentSelectionItem.  self setScrollDeltasupdateLayoutProperties  (self isHorizontal or: [ self isFloating ]) ifTrue: [ self listDirection: #leftToRight ] ifFalse: [ self listDirection: #topToBottom ].  self hResizing: #shrinkWrap.  self vResizing: #shrinkWrap.  self fillsOwner ifTrue: [ self isHorizontal ifTrue: [ self hResizing: #spaceFill ].        self isVertical ifTrue: [ self vResizing: #spaceFill ] ]containerColor  ^self theme lightBaseColoraddItemShowing: arg1  lock critical: [ | tmp1 tmp2 |        tmp1 := JobProgressMorph job: arg1.        tmp2 := self bars size.        tmp2 < 10 ifTrue: [ self addMorphBack: tmp1.              self resize ].        ^tmp1 ]boundingBoxOfSubmorphs  | tmp1 tmp2 |  tmp2 := submorphs select: [:arg1 |  arg1 visible ].  tmp2 ifEmpty: [ ^bounds origin extent: self minimumExtent ].  tmp1 := tmp2 first fullBounds.  tmp2 allButFirst do: [:arg1 |  tmp1 := tmp1 quickMerge: arg1 fullBounds ].  ^tmp1newButtonFor: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 labelForm: arg6 help: arg7  ^self theme newButtonIn: self for: arg1 getState: arg2 action: arg3 arguments: arg4 getEnabled: arg5 label: (AlphaImageMorph new image: arg6) help: arg7performAction  self performAction: nilresizeField  | tmp1 tmp2 |  self flag: #pharoTodo.  tmp1 := table bounds left @ (table bounds bottom - self fieldHeigh - table horizontalScrollBarHeight).  tmp2 := (table bounds right - table verticalScrollBarWidth - (actionButton width + 5)) @ (table bottom - table horizontalScrollBarHeight).  field bounds: (tmp1 corner: tmp2)updateData  self rootItem updateData.  self tableRefreshwrapCentering  | tmp1 |  tmp1 := self layoutProperties.  ^tmp1 ifNil: [ #topLeft ] ifNotNil: [ tmp1 wrapCentering ]clearArea  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self top.  tmp2 := self bottom.  tmp3 := self left.  tmp4 := self right.  self dockingBars do: [:arg1 |  (arg1 isAdheringToTop and: [ arg1 bottom > tmp1 ]) ifTrue: [ tmp1 := arg1 bottom ].        (arg1 isAdheringToBottom and: [ arg1 top < tmp2 ]) ifTrue: [ tmp2 := arg1 top ].        (arg1 isAdheringToLeft and: [ arg1 right > tmp3 ]) ifTrue: [ tmp3 := arg1 right ].        (arg1 isAdheringToRight and: [ arg1 left < tmp4 ]) ifTrue: [ tmp4 := arg1 left ] ].  ^Rectangle left: tmp3 right: tmp4 top: tmp1 bottom: tmp2minHeight  ^self vResizing = #shrinkWrap ifTrue: [ self scrollTarget minExtent y + self scrollbarThickness + 5 ] ifFalse: [ super minHeight ]deleteSelectedTabs  self selectedTabs do: [:arg1 |  arg1 close ]initialize  super initialize.  selectionColor := self defaultColorupdateColumnResizersHeight  self columnResizers do: [:arg1 |  | tmp1 |        tmp1 := arg1 bounds.        tmp1 := tmp1 left @ self top corner: tmp1 right @ scroller bottom.        arg1 bounds: tmp1 ]embeddable: arg1  embeddable := arg1basicIsSticky  ^super isStickyindent  ^indentbounds: arg1  self     extent: arg1 extent;     position: arg1 topLeftwantsSteps  | tmp1 |  tmp1 := self class.  [ tmp1 includesSelector: #step ] whileFalse: [ tmp1 := tmp1 superclass ].  ^tmp1 ~= MorphheightToDisplayInTree: arg1  ^self minExtent ytoggleSmoothing  smoothCurve := smoothCurve not.  handles ifNotNil: [ self           removeHandles;           addHandles ].  self computeBoundsnewColorChooserFor: arg1 getColor: arg2 setColor: arg3 help: arg4  ^self theme newColorChooserIn: self for: arg1 getColor: arg2 setColor: arg3 getEnabled: nil help: arg4handleMouseUp: arg1  arg1 blueButtonChanged ifTrue: [ self blueButtonUp: arg1 ] ifFalse: [ super handleMouseUp: arg1 ]center: arg1  self position: arg1 - (self extent // 2)cornerStyle  ^extension ifNil: [ #square ] ifNotNil: [ extension cornerStyle ]defaultEventDispatcher  ^self class defaultEventDispatchercolumnResizersToFront  self columnResizers do: [:arg1 |  arg1           comeToFront;           fillStyle: arg1 normalFillStyle ]staysUpWhenMouseIsDownIn: arg1  ^arg1 == target or: [ arg1 hasOwner: self ]chooseDropList: arg1 title: arg2 list: arg3  ^self theme chooseDropListIn: self text: arg1 title: arg2 list: arg3lastChild  | tmp1 |  tmp1 := self firstChild ifNil: [ ^nil ].  [ tmp1 nextSibling isNil ] whileFalse: [ tmp1 := tmp1 nextSibling ].  ^tmp1aboutText  ^self model ifNil: [ 'This is a system window without a model' translated ] ifNotNil: [ self model class instanceSide organization classComment ifEmpty: [ 'The model of this window has no class comment' ] ifNotEmpty: [:arg1 |  arg1 ] ]basicWrapSelector: arg1  wrapSelector := arg1backgroundColoringBlockOrSelector  ^backgroundColoringBlockOrSelectormodel: arg1  model := arg1themeChanged  self labelArea delete.  self removeGrips.  self theme     configureWindowBorderFor: self;     configureWindowDropShadowFor: self.  self paneColor: self defaultBackgroundColor.  label ifNotNil: [ self initializeLabelArea ].  self setStripeColorsFrom: self paneColor.  (self isCollapsed not or: [ self isTaskbarPresent ]) ifTrue: [ self addGripsIfWanted ].  self isEmbedded ifTrue: [ self borderWidth: 0 ].  super themeChangedadoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self fillStyle: self fillStyleToUse.  self borderStyle: self borderStyleToUsebottomLayoutFrame  ^(0 @ 1 corner: 1 @ 1) asLayoutFrame     topLeftOffset: 22 @ SystemWindow borderWidth negated;     rightOffset: -22drawOnAthensCanvas: arg1  super drawOnAthensCanvas: arg1.  (ActiveHand notNil and: [ ActiveHand keyboardFocus == self and: [ self rootMenu hasProperty: #hasUsedKeyboard ] ]) ifTrue: [ (arg1 setStrokePaint: self theme menuKeyboardFocusColor) width: self theme menuBorderWidth.        arg1 drawShape: self innerBounds ]innerBounds  | tmp1 |  tmp1 := super innerBounds.  tmp1 := tmp1 withTop: self top + self topHeaderHeight.  ^tmp1items  ^self menuItemsmyDependents: arg1  arg1 ifNil: [ self removeProperty: #myDependents ] ifNotNil: [ self setProperty: #myDependents toValue: arg1 ]scrollRestrictedUp: arg1  self canScrollUp ifFalse: [ ^self ].  self scrollUp: arg1oldSelectedIndexes: arg1  oldSelectedIndexes := arg1objectToView: arg1  (arg1 isMorph and: [ arg1 allMorphs includes: self ]) ifTrue: [ objectToView := nil.        ^self ].  objectToView := arg1defaultBounds  ^0 @ 0 corner: 200 @ 100shiftSubmorphsOtherThan: arg1 by: arg2  | tmp1 |  tmp1 := arg1 ifNil: [ OrderedCollection new ].  (submorphs copyWithoutAll: tmp1) do: [:arg3 |  arg3 position: arg3 position + arg2 ]icon  ^self valueOfProperty: #iconnewBracketSliderFor: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8  ^self theme newBracketSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: arg4 max: arg5 quantum: arg6 getEnabled: arg7 help: arg8iconOfNode: arg1  getIconSelector ifNil: [ ^nil ].  ^model perform: getIconSelector with: arg1 itemhasReverseCellsString  ^self reverseTableCells -> 'reverse table cells' translatedunwantedSelectors  ^#(#removeLineFeeds: #compressFile:)open  ^self openOn: Objectdate: arg1  date := arg1emphasizeScanner: arg1  currentPage  ^self currentPageLastIndex \\ pageSize > 0 ifTrue: [ (self currentPageLastIndex / pageSize) asInteger + 1 ] ifFalse: [ (self currentPageLastIndex / pageSize) asInteger ]addNullLineForIndex: arg1  | tmp1 tmp2 |  tmp1 := lines last.  tmp1 last - tmp1 first >= 0 ifFalse: [ ^self ].  tmp1 last = (arg1 - 1) ifFalse: [ ^self ].  tmp2 := tmp1 left @ tmp1 bottom extent: 0 @ (tmp1 bottom - tmp1 top).  self addNullLineWithIndex: arg1 andRectangle: tmp2rootMenu  ^selfaddWorldToggleItemsToHaloMenu: arg1  #(#(hasDragAndDropEnabledString changeDragAndDrop 'whether I am open to having objects dropped into me') #(roundedCornersString toggleCornerRounding 'whether the world should have rounded corners')) do: [:arg2 |  arg1 addUpdating: arg2 first selector: arg2 second.        arg1 balloonTextForLastItem: arg2 third ]selectableIndexContainingPoint: arg1  ^self tableContainer rowAndColumnIndexContainingPoint: arg1stepTime  ^0initializeClass: arg1  self initialize.  self elements: ((arg1 allSelectors sorted: [:arg2 :arg3 |  arg2 < arg3 ]) collect: [:arg4 |  FTExampleMethodModel method: (arg1 lookupSelector: arg4) ])taskbarState  ^self isMinimized ifTrue: [ #minimized ] ifFalse: [ self isMaximized ifTrue: [ #maximized ] ifFalse: [ self isActive ifTrue: [ #active ] ifFalse: [ #restored ] ] ]frameRectangle1: arg1 on: arg2  | tmp1 |  tmp1 := arg1 insetBy: self width // 2.  self width odd ifTrue: [ tmp1 := tmp1 insetBy: (0 @ 0 corner: 1 @ 1) ].  arg2     line: tmp1 topLeft + (1 @ 0) to: tmp1 topRight - (1 @ 0) width: self width color: self color;     line: tmp1 topRight + (0 @ 1) to: tmp1 bottomRight - (0 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 0) to: tmp1 bottomLeft + (1 @ 0) width: self width color: self color;     line: tmp1 bottomLeft - (0 @ 1) to: tmp1 topLeft + (0 @ 1) width: self width color: self colorselectIndexes: arg1  self selectIndexes: arg1 andMakeVisibleIf: trueopenInHand  self currentHand attachMorph: selfbuildSelectionBlocksFrom: arg1 to: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  Display depth = 1 ifTrue: [ ^self ].  Display depth = 2 ifTrue: [ ^self ].  tmp2 := selectionStart notNil ifTrue: [ selectionStart stringIndex to: selectionStop stringIndex - 1 ] ifFalse: [ 0 to: -1 ].  tmp3 := self characterBlockAtPoint: arg1.  tmp4 := self characterBlockAtPoint: arg2.  tmp7 := tmp3 stringIndex.  tmp8 := tmp4 stringIndex.  tmp1 := (self text copyFrom: tmp7 to: tmp8) asString.  self theme currentSettings haveSecondarySelectionTextColor ifTrue: [ self text removeAttribute: TextSelectionColor secondarySelection ].  self theme currentSettings haveFindReplaceSelectionTextColor ifTrue: [ self text removeAttribute: TextSelectionColor findReplaceSelection ].  tmp5 := #().  extraSelectionBlocks := Array streamContents: [:arg3 |  findReplaceSelectionRegex ifNotNil: [ tmp5 := findReplaceSelectionRegex matchingRangesIn: tmp1.              tmp5 := (tmp5 collect: [:arg4 |  arg4 + tmp3 stringIndex - 1 ]) reject: [:arg4 |  tmp2 size > 0 and: [ (arg4 includes: tmp2 first) or: [ tmp2 includes: arg4 first ] ] ].              tmp5 do: [:arg4 |  self theme currentSettings haveFindReplaceSelectionTextColor ifTrue: [ self text addAttribute: TextSelectionColor findReplaceSelection from: arg4 first to: arg4 last ].                    arg3 nextPut: (ParagraphSelectionBlock first: (self characterBlockForIndex: arg4 first) last: (self characterBlockForIndex: arg4 last + 1) color: self findReplaceSelectionColor) ] ].        secondarySelection ifNotNil: [ tmp6 := (secondarySelection reject: [:arg5 |  (tmp5 includes: arg5) or: [ arg5 = tmp2 or: [ arg5 first > self text size ] ] ]) collect: [:arg5 |  arg5 first to: (arg5 last min: self text size) ].              tmp6 do: [:arg4 |  self theme currentSettings haveSecondarySelectionTextColor ifTrue: [ self text addAttribute: TextSelectionColor secondarySelection from: arg4 first to: arg4 last ].                    arg3 nextPut: (ParagraphSelectionBlock first: (self characterBlockForIndex: arg4 first) last: (self characterBlockForIndex: arg4 last + 1) color: self secondarySelectionColor) ] ] ].  findReplaceSelectionRegex := nil.  secondarySelection := nilcaretWidth  ^TextEditor dumbbellCursor ifTrue: [ 2 ] ifFalse: [ 0 ]expandAllTo: arg1  self expand.  arg1 > self depth ifTrue: [ self children do: [:arg2 |  arg2 expandAllTo: arg1 ] ]close  SystemProgressMorph uniqueInstance close: selfis: arg1 withFocusOver: arg2  | tmp1 |  tmp1 := arg1 hand mouseFocus.  ^arg2 = tmp1 or: [ arg2 hasOwner: tmp1 ]focusColor  ^self color contrastingBlackAndWhiteColorrealWindowExtent  ^realWindowExtentalert: arg1 title: arg2  ^self alert: arg1 title: arg2 configure: [:arg3 |   ]hPageDelta  | tmp1 tmp2 tmp3 |  tmp2 := self scrollTarget width.  tmp3 := self scrollBounds width.  tmp1 := tmp2 - tmp3 max: 0.  tmp1 = 0 ifFalse: [ tmp1 := tmp3 / tmp1 ].  ^tmp1noteNewOwner: arg1  super noteNewOwner: arg1.  self updateLayoutInDockingBarbasicKeyPressed: arg1  arg1 == Character space ifTrue: [ ^self model toogleSelectionValue ].  ^super basicKeyPressed: arg1wantsSteps  ^truewidthOrUndefined  ^self width ifNil: [ self class undefinedColumnWidth ]cellSpacing: arg1  cellSpacing := arg1numberOfVisibleChildren  ^(self isExpanded and: [ self children isNotEmpty ]) ifTrue: [ self children size + (self children collect: [:arg1 |  arg1 numberOfVisibleChildren ]) sum ] ifFalse: [ 0 ]quantum  ^quantumdrawSubmorphsOn: arg1  | tmp1 |  submorphs isEmpty ifTrue: [ ^self ].  tmp1 := [:arg2 |  | tmp2 |  (self topVisibleRowForCanvas: arg1) to: (self bottomVisibleRowForCanvas: arg1) do: [:arg3 |  tmp2 := self item: arg3.        arg2 fullDrawMorph: tmp2 ] ].  self clipSubmorphs ifTrue: [ arg1 clipBy: (arg1 clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: tmp1 ] ifFalse: [ tmp1 value: arg1 ]forwardDirection: arg1  self setProperty: #forwardDirection toValue: arg1unrotatedLength: arg1  vertices size = 2 ifTrue: [ ^self arrowLength: arg1 ].  self setVertices: ((((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) height: arg1) rotationDegrees: 0) verticesisWindowActive: arg1  ^self tabGroup page == arg1 and: [ arg1 isTopWindow ]runLocalStepMethodsIn: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Time millisecondClockValue.  tmp4 := ActiveWorld.  ActiveWorld := arg1.  self triggerAlarmsBefore: tmp1.  stepList isEmpty ifTrue: [ ActiveWorld := tmp4.        ^self ].  (tmp1 < lastStepTime or: [ tmp1 - lastStepTime > 5000 ]) ifTrue: [ self adjustWakeupTimes: tmp1 ].  [ stepList isEmpty not and: [ stepList first scheduledTime < tmp1 ] ] whileTrue: [ lastStepMessage := stepList removeFirst.        tmp2 := lastStepMessage receiver.        (tmp2 shouldGetStepsFrom: arg1) ifTrue: [ lastStepMessage value: tmp1.              lastStepMessage ifNotNil: [ tmp3 := lastStepMessage stepTime ifNil: [ tmp2 stepTime ].                    lastStepMessage scheduledTime: tmp1 + (tmp3 max: 1).                    stepList add: lastStepMessage ] ].        lastStepMessage := nil ].  lastStepTime := tmp1.  ActiveWorld := tmp4rightMargin  ^self rightjustDroppedInto: arg1 event: arg2  | tmp1 |  tmp1 := self formerPosition.  super justDroppedInto: arg1 event: arg2.  self formerPosition: tmp1.  accepted := arg1 ~= self world.  self animationForMoveSuccess: accepted.  accepted ifTrue: [ self dropNotifyRecipient ifNotNil: [ self dropNotifyRecipient dropAcceptedMorph: self from: arg1 ] ].  self deletedoubleClickSelector: arg1  doubleClickSelector := arg1defaultBounds  ^0 @ 0 corner: 50 @ 40addTab: arg1  (tabs includes: arg1) ifTrue: [ ^self ].  tabs add: arg1.  self registerActionsFor: arg1.  self selectedTab ifNil: [ arg1 selected: true ].  self addFirstInHistory: arg1.  self adjustLayout.  self changed.  self triggerEvent: #tabAdded with: arg1deepCopy  self error: 'Please use veryDeepCopy'relativeTextAnchorPosition  ^self valueOfProperty: #relativeTextAnchorPositionadjustedCenter  ^self centerselectionColor  ^selectionColor ifNil: [ self theme selectionColor ]= arg1  super = arg1 ifFalse: [ ^false ].  buttons = arg1 buttons ifFalse: [ ^false ].  keyValue = arg1 keyValue ifFalse: [ ^false ].  ^truepotentialTargets  owner ifNil: [ ^#() ].  ^owner morphsAt: self referencePosition behind: self unlocked: true notatBottom  ^atBottom ifNil: [ atBottom := false ]positionNear: arg1 forExtent: arg2 adjustmentSuggestion: arg3  | tmp1 |  tmp1 := arg1.  [ (self morphsAt: tmp1 + (arg2 // 2)) size > 1 and: [ bounds containsPoint: tmp1 ] ] whileTrue: [ tmp1 := tmp1 + arg3 ].  ^tmp1add: arg1 icon: arg2 help: arg3 action: arg4 keyText: arg5  | tmp1 |  tmp1 := self newMenuItem.  tmp1 contents: arg1.  tmp1 keyText: arg5.  arg4 ifNotNil: [:arg6 |  tmp1           target: arg6 receiver;           selector: arg6 selector;           arguments: arg6 arguments ].  tmp1 icon: arg2.  arg3 ifNotNil: [ tmp1 setBalloonText: arg3 ].  self addMorphBack: tmp1svMorph: arg1  svMorph := arg1preferredCornerStyle  ^#squarekeyStroke: arg1  arg1 keyCharacter ~= Character escape ifTrue: [ ^self ].  self deleteinitialize  | tmp1 tmp2 |  super initialize.  self extent: 300 @ 50.  self color: Color red.  self addMorphBack: (stringMorph := StringMorph new).  morphDeleted := false.  tmp1 := [ work := 0.  [ 10 milliSeconds asDelay wait.  work := work + 1.  morphDeleted ] whileFalse ] newProcess name: 'Background worker'.  tmp2 := [ [ tmp1 resume.  self color: Color green.  10 milliSeconds asDelay wait.  tmp1 suspend.  self color: Color red.  10 milliSeconds asDelay wait.  morphDeleted ] whileFalse ] newProcess name: 'Controller'.  tmp2 resumeinitialize  super initialize.  self positionWhenComposed: 0 @ 0selection  self selectionIndex = 0 ifTrue: [ ^nil ].  list ifNotNil: [ ^list at: self selectionIndex ].  ^self getListItem: self selectionIndexalert: arg1  ^self alert: arg1 title: 'Alert' translateddrawBorderOn: arg1  self drawClippedBorderOn: arg1 usingEnds: (Array with: vertices first with: vertices last)printOn: arg1  arg1     print: self class;     nextPutAll: ' (';     print: self date;     nextPut: $)selectedTab  ^(self tabSelector ifNil: [ ^nil ]) selectedTabpaneColor  ^self theme paneColorFor: selfwouldAcceptKeyboardFocusUponTab  ^trueselectionFrameChanged  selectedMorph ifNil: [ ^self ].  self invalidRect: self selectionFrameaddRefreshMenuItemOn: arg1  retrievingBlock ifNil: [ ^self ].  arg1 addLine.  arg1 add: 'Refresh content' target: self selector: #refreshContentfirstName: arg1  firstName := arg1testReset  | tmp1 |  tmp1 := self dataSourceForTesting.  strategy sortFunction: #yourself ascending.  self assert: tmp1 elements equals: self elementsForTestDataSource.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy reset.  strategy sortDataSource: tmp1.  self assert: tmp1 elements equals: #(1 2 3 4 5 6 7 8 9 10)stepTime  ^currentScrollDelay ifNil: [ 300 ]copyListToClipboard  | tmp1 |  tmp1 := (String new: self getList size * 40) writeStream.  list do: [:arg1 |  tmp1 nextPutAll: arg1 asString ] separatedBy: [ tmp1 nextPut: Character cr ].  Clipboard clipboardText: tmp1 contentsfixedWidth: arg1  currentWidth := arg1.  resizable := falseblinkStart: arg1  ^self setProperty: #blinkStart toValue: arg1drawOn: arg1  self subclassResponsibilityicon  ^nilmouseDown: arg1  (arg1 shiftPressed and: [ self isEditable ]) ifTrue: [ ^super mouseDown: arg1 ].  arg1 hand newMouseFocus: owner.  owner selectItem: self event: arg1bottomVisibleRowForCanvas: arg1  ^self rowAtLocation: arg1 clipRect bottomRighttabLabelFor: arg1  ^self newRow: {((self newButtonLabel: (arg1 labelString truncateWithElipsisTo: 40)) setBalloonText: arg1 labelString) .         (self newCloseControlFor: nil action: [ self removeWindow: arg1 ] help: 'Close this tab and free the window')}newTreeFor: arg1 list: arg2 selected: arg3 changeSelected: arg4  ^self theme newTreeIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4openItemPath: arg1  | tmp1 |  arg1 isEmpty ifTrue: [ ^container setSelectedMorph: nil ].  tmp1 := nil.  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ (arg2 complexContents withoutListWrapper == arg1 first or: [ arg1 first isNil ]) ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNotNil: [ tmp1 isExpanded ifFalse: [ tmp1 toggleExpandedState.              container adjustSubmorphPositions ].        tmp1 changed.        arg1 size = 1 ifTrue: [ ^container setSelectedMorph: tmp1 ].        ^tmp1 firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ tmp1 firstChild openItemPath: arg1 allButFirst ] ].  ^container setSelectedMorph: nilscaleFactor  ^self valueOfProperty: #scaleFactor ifAbsent: [ 1.0 ]initialize  super initialize.  self useSquareCornersmouseMove: arg1  arg1 hand temporaryCursor ifNil: [ ^self ].  self class fastSplitterResize ifFalse: [ self updateFromEvent: arg1 ] ifTrue: [ traceMorph ifNil: [ traceMorph := Morph newBounds: self bounds.              traceMorph borderColor: Color lightGray.              traceMorph borderWidth: 1.              self owner addMorph: traceMorph ].        splitsTopAndBottom ifTrue: [ traceMorph position: traceMorph position x @ (self normalizedY: arg1 cursorPoint y) ] ifFalse: [ traceMorph position: (self normalizedX: arg1 cursorPoint x) @ traceMorph position y ] ]arguments  ^argumentsmaxCellSize  ^maxCellSizepassenger  ^passengerdefaultColor  ^self theme backgroundColoracceptDroppingMorph: arg1 event: arg2  self model acceptDroppingMorph: arg1 event: arg2 inMorph: self.  self resetPotentialDropMorph.  arg2 hand releaseMouseFocus: self.  Cursor normal showdrawSelectionOn: arg1  selectedRow ifNil: [ ^self ].  selectedRow = 0 ifTrue: [ ^self ].  self drawBackgroundForSelectedRow: selectedRow on: arg1expandAllFromNode: arg1  self expandAll: ((self nodeMorphOfNode: arg1) ifNil: [ ^self ]).  self adjustSubmorphPositionsnormalButtonBorderStyle  ^self theme scrollbarNormalButtonBorderStyleFor: selfdefer: arg1  self class defer: arg1show: arg1  | tmp1 |  tmp1 := self createShortcutMorphFor: arg1.  self positionShortcut: tmp1.  tmp1 openInWorlddrawLabelOnAthensCanvas: arg1  arg1 pathTransform translateX: 0 Y: self fontToUse getPreciseAscent.  arg1     setPaint: self color;     setFont: self fontToUse;     drawString: contentsflipVAroundY: arg1  | tmp1 |  tmp1 := arg1 ifNil: [ bounds center y ] ifNotNil: [ arg1 ].  self setVertices: (vertices collect: [:arg2 |  arg2 x @ ((arg2 y - tmp1) * -1 + tmp1) ]) reversedsentTo: arg1  type == #mouseOver ifTrue: [ ^arg1 handleMouseOver: self ].  type == #mouseEnter ifTrue: [ ^arg1 handleMouseEnter: self ].  type == #mouseLeave ifTrue: [ ^arg1 handleMouseLeave: self ].  ^super sentTo: arg1newCancelButtonFor: arg1  ^self theme newCancelButtonIn: self for: arg1elements: arg1  self dataSource elements: arg1themeChanged  self color: self defaultColor.  super themeChanged.  self refreshpagingArea  ^pagingArearemoveModalWindow  self modalWindow: nilpageSizeFromString: arg1  | tmp1 |  tmp1 := arg1 asString trimBoth.  tmp1 ifEmpty: [ tmp1 := '1' ].  (tmp1 beginsWith: '/') ifTrue: [ | tmp2 |        tmp1 := (tmp1 copyFrom: 2 to: tmp1 size) trimBoth.        tmp2 := Integer readFromString: tmp1.        tmp2 > 0 ifTrue: [ self changePageSize: self nodeList size // tmp2 ] ifFalse: [ treeMorph flash.              ^false ] ] ifFalse: [ | tmp3 |        tmp3 := Integer readFromString: tmp1.        tmp3 > 0 ifTrue: [ self changePageSize: tmp3 ] ifFalse: [ treeMorph flash.              ^false ] ].  ^truetestIdentity  self assert: LayoutFrame new equals: LayoutFrame identitytoggleOpenOrClosed  closed ifTrue: [ self makeOpen ] ifFalse: [ self makeClosed ]rotationCenter  ^self valueOfProperty: #rotationCenter ifAbsent: [ 0.5 @ 0.5 ]dropItemSelector: arg1  dropItemSelector := arg1.  arg1 ifNotNil: [ self dropEnabled: true ]addLabelArea  labelArea := self theme newWindowHeaderFor: self.  self addMorph: labelAreaadoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self adoptColor: self colorToUsebuildButton  ^PluggableButtonMorph on: self getState: nil action: #action label: #label menu: nilhsvMorph  ^hsvMorphmouseDownInCollapseHandle: arg1 with: arg2  self obtainHaloForEvent: arg1 andRemoveAllHandlesBut: arg2.  self setDismissColor: arg1 with: arg2removeObsoleteEventHandlers  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  scroller submorphs do: [:arg1 |  arg1           eventHandler: nil;           highlightForMouseDown: false;           resetExtension ]startStepping: arg1 at: arg2 arguments: arg3 stepTime: arg4  | tmp1 |  tmp1 := self world.  tmp1 ifNotNil: [ tmp1 startStepping: self at: arg2 selector: arg1 arguments: arg3 stepTime: arg4.        self changed ]wantsDroppedMorph: arg1 event: arg2  ^self dropEnabledmouseUp: arg1  (self fullContainsPoint: arg1 position) ifFalse: [ arg1 hand releaseMouseFocus: self.        ^self deleteIfPopUp: arg1 ].  stayUp ifFalse: [ arg1 hand newMouseFocus: self ]newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4  ^self newTextEditorFor: arg1 getText: arg2 setText: arg3 getEnabled: arg4 menu: nilnonVisibleTabs  ^self tabs select: [:arg1 |  arg1 owner isNil ]recalculateVerticalScrollBar  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self hasDataSource ifFalse: [ ^self ].  self recalculateVerticalScrollBarVisibilityIfHidden: [ ^self ].  tmp4 := self container calculateExactVisibleRows.  tmp5 := self dataSource numberOfRows.  tmp5 = 0 ifTrue: [ ^self ].  tmp1 := (tmp4 / tmp5) asFloat.  tmp2 := 1 / tmp5.  tmp3 := (tmp4 - 1) floor * tmp2.  self verticalScrollBar     scrollDelta: tmp2 pageDelta: tmp3;     interval: tmp1calculateChildren  newCloseControlFor: arg1 action: arg2 help: arg3  ^self theme newCloseControlIn: self for: arg1 action: arg2 help: arg3potentialDropMorph  ^potentialDropMorphevent: arg1  event := arg1drawSubMenuMarkerOnAthensCanvas: arg1  self hasSubMenu ifFalse: [ ^self ].  arg1 pathTransform restoreAfter: [ arg1 pathTransform translateX: self extent x - self subMenuMarker width Y: 0.        arg1 pathTransform translateX: 0 Y: self subMenuMarker height // 2.        arg1 setPaint: self subMenuMarker.        arg1 drawShape: (0 @ 0 extent: self subMenuMarker extent) ]extent: arg1  super extent: arg1.  self fillStyle isOrientedFill ifTrue: [ self fillStyle: (self theme progressBarFillStyleFor: self) ].  self barFillStyle isOrientedFill ifTrue: [ self barFillStyle: (self theme progressBarProgressFillStyleFor: self) ]scale: arg1  self changed.  transform := transform withScale: arg1.  self layoutChanged.  self changedenableAllMouseCommandsFrom: arg1  self     enableMouseCommands: CmdClickActivation withContextFrom: arg1;     enableMouseCommands: CmdDoubleClickActivation withContextFrom: arg1handlesMouseDown: arg1  ^truegetColorSelector  ^getColorSelectorpickColor  | tmp1 tmp2 tmp3 |  tmp3 := self activeHand.  tmp3 showTemporaryCursor: (self iconNamed: #eyedropperIcon) hotSpotOffset: 6 @ 31.  tmp3 captureEventsUntil: [:arg1 |  arg1 isMove ifTrue: [ tmp1 := arg1 position.              (self hsvaMorph containsPoint: tmp1) ifFalse: [ tmp2 := Display depth = 32 ifTrue: [ Color colorFromPixelValue: ((Display pixelValueAt: tmp1) bitOr: 16rFF000000) depth: 32 ] ifFalse: [ Display colorAt: tmp1 ] ].              tmp3 position: tmp1.              self selectedColor ~= tmp2 ifTrue: [ self selectedColor: tmp2 ] ].        tmp3 anyButtonPressed ].  tmp3 showTemporaryCursor: nilpredecessorChanged  | tmp1 tmp2 |  (self hasProperty: #CreatingParagraph) ifTrue: [ ^self ].  tmp1 := predecessor ifNil: [ 1 ] ifNotNil: [ predecessor lastCharacterIndex + 1 ].  (self paragraph adjustedFirstCharacterIndex ~= tmp1 or: [ tmp1 >= text size ]) ifTrue: [ paragraph composeAllStartingAt: tmp1.        self fit ] ifFalse: [ tmp2 := self firstCharacterIndex.        self withSuccessorsDo: [:arg1 |  arg1 adjustLineIndicesBy: tmp1 - tmp2 ] ]listCentering  ^#topLeftdismissViaHalo  super dismissViaHalo.  selectedItems do: [:arg1 |  arg1 dismissViaHalo ]newGroupboxForAll: arg1  ^self theme newGroupboxIn: self forAll: arg1chooseExistingFileReference: arg1 extensions: arg2 path: arg3 preview: arg4  ^self theme chooseExistingFileReferenceIn: self title: arg1 extensions: arg2 path: arg3 preview: arg4setStateSelector  ^setStateSelectorborderWidth: arg1  | tmp1 |  tmp1 := self borderStyle.  tmp1 width = arg1 ifTrue: [ ^self ].  tmp1 style = #none ifTrue: [ self borderStyle: (SimpleBorder width: arg1 color: Color transparent) ] ifFalse: [ tmp1 width: arg1.        self changed ]setSecondColorDashOnStroke: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self dashedBorder.  tmp2 := tmp1 third.  tmp3 := tmp1 size > 3 ifTrue: [ tmp1 fourth ] ifFalse: [ 0 ].  arg1 fillPaint: tmp2.  arg1 dashes: {tmp1 second .         tmp1 first} offset: tmp3 + tmp1 secondcurrentPageLastIndex  ^pageSize ifNil: [ self nodeList size ] ifNotNil: [ self currentPageFirstIndex + pageSize - 1 min: self nodeList size ]defaultLabel  ^'Dialog' translatedselected: arg1  (state isSelectedMatchingTheState: arg1) ifTrue: [ ^self triggerEvent: #tabResetSelection with: self ].  state := state newStateForSelected: arg1.  arg1 ifTrue: [ self triggerEvent: #tabSelected with: self.        self showCloseIcon ]enabled: arg1  enabled := arg1.  self contentMorph ifNotNil: [:arg2 |  arg2 enabled: arg1 ].  self changed: #enableddeny: arg1  ^self deny: arg1 title: 'Access Denied' translatedtarget  ^targetwhichButton  ^whichButtonnewCheckboxFor: arg1 getSelected: arg2 setSelected: arg3 label: arg4 help: arg5  ^self theme newCheckboxIn: self for: arg1 getSelected: arg2 setSelected: arg3 getEnabled: nil label: arg4 help: arg5icon: arg1  icon := arg1initialize  mouseOverMorphs := #().  self initializeTrackedMorphsbuttons  ^self paneMorphs last lastSubmorph submorphstop  ^bounds topresizeHorizontalScrollBar  | tmp1 tmp2 tmp3 |  horizontalScrollBar ifNotNil: [ tmp1 := self bounds width - (self borderWidth * 2) - self verticalScrollBarWidth.        tmp2 := self scrollBarThickness.        tmp3 := self bounds bottomLeft - ((tmp1 + self borderWidth) @ (0 - self borderWidth)).        tmp3 := self bounds bottomLeft - ((0 - self borderWidth) @ (tmp2 + self borderWidth)).        self horizontalScrollBar bounds: (tmp3 extent: tmp1 @ tmp2) ]drawOn: arg1  | tmp1 |  vertices size < 1 ifTrue: [ self error: 'a polygon must have at least one point' ].  closed ifTrue: [ arg1 drawPolygon: self getVertices fillStyle: self fillStyle ].  tmp1 := self drawArrowsOn: arg1.  self drawClippedBorderOn: arg1 usingEnds: tmp1hasContentToShow  ^falsefillsOwner  ^fillsOwner ifNil: [ true ]result  ^resultnoButtonPressed  ^self anyButtonPressed notbaseColor  ^Color transparentborderStyleToUse  ^self enabled ifTrue: [ self theme scrollPaneNormalBorderStyleFor: self ] ifFalse: [ self theme scrollPaneDisabledBorderStyleFor: self ]setWidth: arg1  self extent: (arg1 @ (font ifNil: [ TextStyle defaultFont ]) height) ceilingisDisplayed  ^self world notNilspacerWidth  | tmp1 |  tmp1 := self mustTakeIntoAccountCheckSpace ifTrue: [ self checkRectangle ] ifFalse: [ self toggleRectangle ].  ^(self mustTakeIntoAccountToggleSpace or: [ self mustTakeIntoAccountCheckSpace ]) ifTrue: [ tmp1 right + container gapAfterToggle - bounds left ] ifFalse: [ tmp1 left - bounds left ]seperatorColor  ^self theme scrollbarColorbarFillStyle  ^self valueOfProperty: #barFillStyle ifAbsent: [ self theme menuTitleColor ]veryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  otherProperties ifNil: [ ^self ].  self copyWeakly do: [:arg2 |  otherProperties at: arg2 ifPresent: [:arg3 |  otherProperties at: arg2 put: (arg1 references at: arg3 ifAbsent: [ arg3 ]) ] ]doLayoutIn: arg1  | tmp1 |  super doLayoutIn: arg1.  tmp1 := (self vScrollbarShowing = self vScrollbarNeeded) not.  tmp1 := tmp1 or: [ (self hScrollbarShowing = self hScrollbarNeeded) not ].  self updateScrollbars.  tmp1 ifFalse: [ self resizeScroller ].  super doLayoutIn: arg1testPager  | tmp1 tmp2 tmp3 |  tmp3 := PaginatedMorphTreeModel itemsList: (1 to: 100) asArray.  tmp2 := tmp3 theme newWindowIn: self currentWorld for: tmp3 title: 'test'.  tmp1 := tmp3 defaultTreeMorph.  tmp1 pageSize: 30.  tmp1 buildContents.  tmp2 addMorph: tmp1 fullFrame: LayoutFrame identity.  tmp2 open.  tmp3 expandItemPath: {40}.  self assert: tmp1 pager currentPage identicalTo: 2.  tmp2 closenewDisplayDepthNoRestore: arg1  | tmp1 tmp2 |  arg1 = Display depth ifTrue: [ ^Display ].  arg1 abs < Display depth ifFalse: [ tmp1 := Display boundingBox area.        tmp2 := tmp1 * (arg1 abs - Display depth) // 8 + Smalltalk lowSpaceThreshold.        (Smalltalk garbageCollectMost <= tmp2 and: [ Smalltalk garbageCollect <= tmp2 ]) ifTrue: [ self error: 'Insufficient free space' ] ].  Display setExtent: Display extent depth: arg1.  DisplayScreen startUpselectedMouseOverFillStyle  ^self theme controlButtonSelectedMouseOverFillStyleFor: selfyellowButtonActivity  ^self yellowButtonActivity: falsereleaseCachedState  super releaseCachedState.  image hibernateselectionChangedResetIfEmpty: arg1  self resetListSelector ifNil: [ ^self ].  arg1 newSelectedIndexes ifNotEmpty: [ ^self ].  self model perform: self resetListSelectorselectPreviousTask  self selectTask: (self tasks before: self activeTask ifAbsent: [ self tasks isEmpty ifFalse: [ self tasks last ] ])settingSelector  ^nilminExtent  | tmp1 |  tmp1 := super minExtent.  ^(24 max: tmp1 x) @ (24 max: tmp1 y)propertyNamesNotCopied  ^#(connectedConstraints connectionHighlights highlightedTargets)addMorphFront: arg1 fromWorldPosition: arg2  self addMorphFront: arg1.  arg1 position: (self transformFromWorld globalPointToLocal: arg2)submorphsInFrontOf: arg1 do: arg2  | tmp1 |  tmp1 := false.  submorphs do: [:arg3 |  arg3 == arg1 ifTrue: [ tmp1 := true ] ifFalse: [ tmp1 ifFalse: [ arg2 value: arg3 ] ] ]withAllOwnersDo: arg1  arg1 value: self.  owner ifNotNil: [ ^owner withAllOwnersDo: arg1 ]handlesMouseOverDragging: arg1  ^self dropEnabledclipDuring: arg1 canvas: arg2  self clipSubmorphs ifTrue: [ arg2 clipBy: self clippingBounds during: arg1 ] ifFalse: [ ^arg1 value ]popUpContentsMenu: arg1  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  self contentsMenu: tmp1.  tmp1     buildTitle: [:arg2 |  arg2 bigTitle: self contentsMenuTitle ];     popUpEvent: arg1 in: (self world ifNil: [ self ])embeddable: arg1  self setProperty: #embeddable toValue: arg1hSpaceFill  ^self flags anyMask: 1placeCells: arg1 in: arg2 horizontal: arg3 target: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp10 := properties cellInset.  (tmp10 isNumber and: [ tmp10 isZero ]) ifTrue: [ tmp10 := nil ].  arg3 ifTrue: [ properties listDirection == #rightToLeft ifTrue: [ tmp1 := -1 @ 0.              properties wrapDirection == #bottomToTop ifTrue: [ tmp2 := 0 @ -1.                    tmp3 := arg2 bottomRight ] ifFalse: [ tmp2 := 0 @ 1.                    tmp3 := arg2 topRight ] ] ifFalse: [ tmp1 := 1 @ 0.              properties wrapDirection == #bottomToTop ifTrue: [ tmp2 := 0 @ -1.                    tmp3 := arg2 bottomLeft ] ifFalse: [ tmp2 := 0 @ 1.                    tmp3 := arg2 topLeft ] ] ] ifFalse: [ properties listDirection == #bottomToTop ifTrue: [ tmp1 := 0 @ -1.              properties wrapDirection == #rightToLeft ifTrue: [ tmp2 := -1 @ 0.                    tmp3 := arg2 bottomRight ] ifFalse: [ tmp2 := 1 @ 0.                    tmp3 := arg2 bottomLeft ] ] ifFalse: [ tmp1 := 0 @ 1.              tmp3 := properties wrapDirection == #rightToLeft ifTrue: [ tmp2 := -1 @ 0.                    arg2 topRight ] ifFalse: [ tmp2 := 1 @ 0.                    arg2 topLeft ] ] ].  1 to: arg1 size do: [:arg5 |  tmp6 := arg1 at: arg5.        tmp6 extraSpace ifNotNil: [ tmp3 := tmp3 + (tmp6 extraSpace y * tmp2) ].        tmp4 := tmp6 cellSize y * tmp2.        tmp5 := tmp3.        tmp6 := tmp6 nextCell.        [ tmp6 isNil ] whileFalse: [ tmp6 extraSpace ifNotNil: [ tmp5 := tmp5 + (tmp6 extraSpace x * tmp1) ].              tmp7 := tmp6 cellSize x * tmp1.              tmp9 := tmp5 + tmp7 + tmp4.              tmp8 := Rectangle origin: (tmp5 min: tmp9) corner: (tmp5 max: tmp9).              tmp10 ifNotNil: [ tmp8 := tmp8 insetBy: tmp10 ].              tmp6 target layoutInBounds: tmp8.              tmp5 := tmp5 + tmp7.              tmp6 := tmp6 nextCell ].        tmp3 := tmp3 + tmp4 ]prepareForScaling  takesKeyboardFocus  ^truefindRegex  ^self editor findRegexinitializeKeyBindings  self bindKeyCombination: Character arrowUp shift | Character arrowUp asKeyCombination toAction: [:arg1 :arg2 :arg3 |  self keyStrokeArrowUp: arg3 ].  self bindKeyCombination: Character arrowDown shift | Character arrowDown asKeyCombination toAction: [:arg1 :arg2 :arg3 |  self keyStrokeArrowDown: arg3 ].  self bindKeyCombination: Character arrowLeft shift | Character arrowLeft asKeyCombination toAction: [:arg1 :arg2 :arg3 |  self keyStrokeArrowLeft: arg3 ].  self bindKeyCombination: Character arrowRight shift | Character arrowRight asKeyCombination toAction: [:arg1 :arg2 :arg3 |  self keyStrokeArrowRight: arg3 ].  self bindKeyCombination: Character home asKeyCombination toAction: [ self selectFirst ].  self bindKeyCombination: Character end asKeyCombination toAction: [ self selectLast ].  self bindKeyCombination: self shortcutProvider selectAllShortcut toAction: [ self selectAll ]debugDrawError  (self valueOfProperty: #drawError) debugaddWindowToWorld  | tmp1 |  tmp1 := Morph new.  windows add: tmp1.  ^tmp1headerColor: arg1  self deprecated: 'This method will be removed in the next Pharo version. The header color is not the responsibility of the FastTable. If you want to change the color of the table''s header you should do it in the datasource. In the datasource there is a method to return a header''s cell, you should change the color there.' on: '29-04-2019' in: #Pharo8.  headerColor := arg1delete  super delete.  self triggerEvent: #tabManagerDeleted with: selfoldSize: arg1  oldSize := arg1newTextEntryFor: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6  ^self theme newTextEntryIn: self for: arg1 get: arg2 set: arg3 class: arg4 getEnabled: arg5 help: arg6preferredKeyboardPosition  | tmp1 tmp2 |  tmp1 := (self bounds: self bounds in: self currentWorld) topLeft.  paragraph ifNil: [ ^tmp1 ].  tmp2 := paragraph selectionRects.  tmp2 size = 0 ifTrue: [ ^tmp1 ].  ^tmp2 first topLefttemporaryCursor  ^temporaryCursorminExtentOf: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  minExtentCache ifNotNil: [ ^minExtentCache ].  arg1 hasSubmorphs ifFalse: [ ^0 @ 0 ].  properties := arg1 assureTableProperties.  (properties wrapDirection == #none and: [ properties cellSpacing == #none ]) ifTrue: [ tmp7 := properties listDirection.        (tmp7 == #leftToRight or: [ tmp7 == #rightToLeft ]) ifTrue: [ ^self minExtentHorizontal: arg1 ].        (tmp7 == #topToBottom or: [ tmp7 == #bottomToTop ]) ifTrue: [ ^self minExtentVertical: arg1 ] ].  tmp4 := arg2 origin asIntegerPoint corner: arg2 corner asIntegerPoint.  tmp3 := (properties listDirection == #topToBottom or: [ properties listDirection == #bottomToTop ]) not.  tmp1 := self computeCellSizes: arg1 in: (0 @ 0 corner: tmp4 extent) horizontal: tmp3.  tmp2 := self computeCellArrangement: tmp1 in: tmp4 horizontal: tmp3 target: arg1.  tmp5 := tmp6 := 0.  tmp2 do: [:arg3 |  tmp5 := tmp5 max: arg3 cellSize x + arg3 extraSpace x.        tmp6 := tmp6 + arg3 cellSize y + arg3 extraSpace y ].  minExtentCache := tmp3 ifTrue: [ tmp5 @ tmp6 ] ifFalse: [ tmp6 @ tmp5 ].  ^minExtentCachenewButtonLabel: arg1 ofSize: arg2  ^AlphaImageMorph new image: (ScrollBar arrowOfDirection: arg1 size: arg2 color: self paneColor darker)newToolbar: arg1  ^self theme newToolbarIn: self for: arg1enableFilter: arg1  self enableFilter.  function filterClass: arg1testSelectableIndexAfter  self subclassResponsibilityhandlesMouseStillDown: arg1  ^actWhen == #whilePressedactionMap  ^actionMap ifNil: [ self valueOfProperty: #actionMap ifAbsent: [  ] ]newSVColorMorph  ^SVColorSelectorMorph new     extent: 152 @ 152;     hResizing: #spaceFill;     vResizing: #spaceFill;     when: #colorSelected send: #colorSelected: to: selfpoint: arg1 from: arg2  owner ifNil: [ ^arg1 ].  ^(owner transformFrom: arg2) globalPointToLocal: arg1rotationDegrees: arg1  graphicalMorph  ^graphicalMorphrejectsEvent: arg1  (arg1 isMouse and: [ arg1 isMouseDown ]) ifTrue: [ ^(self submorphs anySatisfy: [:arg2 |  arg2 containsPoint: arg1 cursorPoint ]) not ].  ^super rejectsEvent: arg1rowIndexFrom: arg1  ^arg1testIsAfterColumn  self subclassResponsibilitypreferredCornerStyle  ^self theme windowPreferredCornerStyleFor: selfsuccessor  ^successordefaultTop  ^self defaultBounds toplayout  ^layoutsetDirectionFrom: arg1  | tmp1 tmp2 |  tmp1 := (self transformFromWorld globalPointToLocal: arg1) - self referencePosition.  tmp2 := tmp1 degrees + 90.0.  self forwardDirection: (tmp2 \\ 360) roundedinitRow  fillStyle: arg1  self assureExtension.  extension fillStyle = arg1 ifTrue: [ ^self ].  extension fillStyle: arg1.  color := arg1 asColor.  self changedminWidth: arg1  arg1 ifNil: [ self removeProperty: #minWidth ] ifNotNil: [ self setProperty: #minWidth toValue: arg1 ].  self layoutChangedtestResizing  | tmp1 tmp2 tmp3 |  window := SystemWindow labelled: 'foo'.  window setProperty: #minimumExtent toValue: 1 @ 1.  tmp1 := 0.  window openInWorld.  tmp2 := window bounds.  window announcer when: WindowResizing do: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 0.  window extent: 50 @ 60.  tmp3 := window bounds.  self assert: tmp1 equals: 1storeValue: arg1  storeValue := arg1click: arg1 for: arg2 controller: arg3  | tmp1 tmp2 |  tmp2 := arg1 cursorPoint.  tmp1 := false.  self actionAttributesUnder: tmp2 event: arg1 do: [:arg4 |  | tmp3 |        tmp3 := arg2 ifNil: [ arg3 morph ].        (arg4 actOnClick: arg1 for: tmp3 in: self editor: arg3) == true ifTrue: [ ^true ] ].  (tmp1 and: [ Cursor currentCursor == Cursor webLink ]) ifTrue: [ Cursor normal show ].  ^tmp1icon  ^iconquantum: arg1  quantum := arg1.  self setValue: self valueselectionColor  ^selectionColor ifNil: [ self class defaultSelectionColor ]nextSibling: arg1  nextSibling := arg1setArguments  | tmp1 tmp2 |  tmp1 := UIManager default request: 'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated initialAnswer: (String streamContents: [:arg1 |  arguments do: [:arg2 |  arg2 printOn: arg1.                    arg1 nextPutAll: '. ' ] ]).  tmp1 isEmptyOrNil ifFalse: [ tmp2 := self class compiler           source: '{' , tmp1 , '}';           receiver: self;           evaluate.        self arguments: tmp2 ]assureOtherProperties  otherProperties ifNil: [ self initializeOtherProperties ].  ^otherPropertiesprocessMouseOver: arg1  self initializeProcessMouseOver.  self handleAsMouseOver: arg1.  self hasLeftMorphsChanged ifTrue: [ self handleAsMouseLeave: arg1.        self handleAsMouseEnter: arg1.        self rememberOverList ].  self initializeTrackedMorphsgetCollapsedFrame  ^RealEstateAgent assignCollapseFrameFor: selfadoptPaneColor: arg1  super adoptPaneColor: arg1.  self fillStyle: self normalFillStylecollapseNodePath: arg1  self requestView: (MorphTreeChangeRequest collapseNodePath: arg1)canChangeText  ^self enabledaddPredecessor: arg1  | tmp1 |  tmp1 := self copy predecessor: predecessor successor: self.  tmp1 extent: self width @ 100.  predecessor ifNotNil: [ predecessor setSuccessor: tmp1 ].  self setPredecessor: tmp1.  predecessor recomposeChain.  arg1 hand attachMorph: tmp1acceptDroppingMorph: arg1 event: arg2  | tmp1 |  tmp1 := self layoutPolicy.  tmp1 ifNil: [ ^self addMorph: arg1 ].  self privateAddMorph: arg1 atIndex: (tmp1 indexForInserting: arg1 at: arg2 position in: self)fixKeyText: arg1  ^ToggleMenuItemShortcut normalize: arg1activateCursor: arg1 withMask: arg2  worldState worldRenderer activateCursor: arg1 withMask: arg2isEnabled: arg1  isEnabled = arg1 ifTrue: [ ^self ].  isEnabled := arg1.  self changedupdateSubMenu  target ifNotNil: [ subMenu := target perform: subMenuSelector ]newVSplitterAt: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := submorphs size.  tmp4 := tmp5 - arg1 + 2.  tmp1 := self submorphs at: tmp4.  tmp2 := tmp1 layoutFrame.  tmp3 := self newVSplitter.  tmp3 layoutFrame: ((tmp2 rightFraction @ tmp2 topFraction corner: tmp2 rightFraction @ tmp2 bottomFraction) asLayoutFrame rightOffset: 4).  self privateAddMorph: tmp3 atIndex: tmp5 - arg1 + 2firstCharacterIndex  ^firstCharacterIndexnewImage: arg1 size: arg2  ^self theme newImageIn: self form: arg1 size: arg2selectedNodePathList  ^self subclassResponsibilitytabSelector  ^tabSelectorcolumns: arg1  self removeColumnResizers.  topHeader ifNotNil: [ self removeMorph: topHeader ].  columns := arg1 asOrderedCollection.  arg1 do: [:arg2 |  arg2 container: self ].  self buildTopHeader.  self addColumnResizersdrawWorld: arg1 submorphs: arg2 invalidAreasOn: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := damageRecorder invalidRectsFullBounds: arg1 viewBox.  tmp1 := tmp1 asArray sort: [:arg4 :arg5 |  arg4 area > arg5 area ].  damageRecorder reset.  tmp2 := arg2 size.  tmp3 := OrderedCollection new: tmp2 * 2.  tmp4 := OrderedCollection new: tmp2 * 2.  tmp5 := OrderedCollection new: tmp2 * 2.  tmp1 do: [:arg6 |  arg6 allAreasOutsideList: tmp5 do: [:arg7 |  | tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 |              tmp12 := arg7.              tmp11 := OrderedCollection with: arg7.              tmp8 := 1.              [ tmp11 isEmpty or: [ tmp8 > tmp2 ] ] whileFalse: [ tmp6 := arg2 at: tmp8.                    ((tmp10 := tmp11 select: [:arg8 |  tmp6 fullBounds intersects: arg8 ]) notEmpty and: [ tmp6 visible ]) ifTrue: [ tmp3 addLast: tmp6.                          tmp4 addLast: (Rectangle merging: (tmp10 collect: [:arg8 |  tmp6 fullBounds intersect: arg8 ])).                          tmp11 removeAll: tmp10.                          tmp10 do: [:arg9 |  tmp11 addAll: (tmp6 areasRemainingToFill: arg9) ].                          tmp11 size = 1 ifTrue: [ tmp12 := tmp11 first ].                          tmp11 isEmpty ifTrue: [ tmp12 := nil ] ].                    tmp8 := tmp8 + 1 ].              tmp12 ifNotNil: [ arg1 drawOn: (tmp9 := arg3 copyClipRect: tmp12) ].              [ tmp3 isEmpty ] whileFalse: [ (tmp7 := tmp4 removeLast) == tmp12 ifFalse: [ tmp9 := arg3 copyClipRect: (tmp12 := tmp7) ].                    tmp9 fullDrawMorph: tmp3 removeLast ].              tmp3 reset.              tmp4 reset.              tmp5 add: arg7 ] ].  ^tmp5hResizing  ^hResizingbasicTheme: arg1  self theme = arg1 ifFalse: [ self setProperty: #theme toValue: arg1 ]age  ^agefractionRectangle  ^leftFraction @ topFraction corner: rightFraction @ bottomFractionintersectionWithLineSegmentFromCenterTo: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  (self containsPoint: arg1) ifTrue: [ ^arg1 ].  tmp1 := arg1 x - self center x.  tmp9 := arg1 y - self center y.  tmp1 = 0 ifTrue: [ ^self bounds pointNearestTo: arg1 ].  tmp4 := tmp9 / tmp1.  tmp5 := tmp4 squared.  tmp2 := (self bounds width / 2) squared.  tmp3 := (self bounds height / 2) squared.  tmp6 := 1 / (1 / tmp2 + (tmp5 / tmp3)).  tmp7 := tmp6 sqrt.  tmp1 < 0 ifTrue: [ tmp7 := tmp7 negated ].  tmp8 := tmp4 * tmp7.  ^self center + (tmp7 @ tmp8) asIntegerPointlistSpacingString: arg1  ^self layoutMenuPropertyString: arg1 from: self listSpacingnameMorph  ^LabelMorph new     contents: self name;     enabled: false;     hResizing: #spaceFill;     yourselfpopUpMenu  | tmp1 |  tmp1 := self selectedTab menu.  tmp1 popUpAt: menuButton bottomRight forHand: ActiveHand in: self currentWorldtreeMorph  | tmp1 |  tmp1 := (self treeMorphClass on: self)     beCheckList;     beMultiple;     columns: {(MorphTreeColumn new           startWidth: 100;           rowMorphGetSelector: #firstNameMorph;           headerButtonLabel: 'First name' font: nil) .         (MorphTreeColumn new           startWidth: 150;           rowMorphGetSelector: #secondNameMorph;           headerButtonLabel: 'Second name' font: nil) .         (MorphTreeColumn new           startWidth: 50;           rowMorphGetSelector: #ageMorph;           headerButtonLabel: 'Age' font: nil) .         (MorphTreeColumn new           startWidth: 50;           rowMorphGetSelector: #marriedMorph;           headerButtonLabel: 'Married' font: nil)};     columnInset: 3;     rowInset: 1;     preferedPaneColor: Color white;     rowColorForEven: Color veryLightGray muchLighter odd: Color white.  ^tmp1delete  target ifNotNil: [ target hasHalo: false ].  super deletemin: arg1  (self sliderMorph ifNil: [ ^self ]) min: arg1addSuccessor: arg1  | tmp1 |  tmp1 := self copy predecessor: self successor: successor.  tmp1 extent: self width @ 100.  successor ifNotNil: [ successor setPredecessor: tmp1 ].  self setSuccessor: tmp1.  successor recomposeChain.  arg1 hand attachMorph: tmp1tabs: arg1  tabs do: [:arg2 |  arg2 silentlySelected: false ].  tabs := arg1.  selectionHistory removeAll.  arg1 do: [:arg3 |  self registerActionsFor: arg3.        self selectedTab ifNil: [ arg3 selected: true ].        self addFirstInHistory: arg3 ].  self adjustLayout.  self changed.  self triggerEvent: #tabsChangedarcLengths: arg1  arcLengths := arg1openDialogWindowIn: arg1 title: arg2  ^self openDialogWindowIn: arg1 title: arg2 selectedtems: Array newcommandOrCrontrolKeyPressed: arg1  ^client commandOrCrontrolKeyPressed: arg1permitsThumbnailing  ^trueclose  self canBeClosed ifFalse: [ ^self ].  self deletedefaultColor  ^Color transparentmessage: arg1 title: arg2  ^self theme messageIn: self text: arg1 title: arg2borderStyle: arg1  arg1 = self borderStyle ifTrue: [ ^self ].  self assureExtension.  (self canDrawBorder: arg1) ifFalse: [ ^self borderStyle: (BorderStyle width: arg1 width color: (arg1 trackColorFrom: self) color) ].  arg1 width = self borderStyle width ifFalse: [ self changed ].  (arg1 isNil or: [ arg1 == BorderStyle default ]) ifTrue: [ extension borderStyle: nil.        borderWidth := 0.        ^self changed ].  extension borderStyle: arg1.  borderWidth := arg1 width.  borderColor := arg1 style == #simple ifTrue: [ arg1 color ] ifFalse: [ arg1 style ].  self changedsliderColor: arg1  sliderColor := arg1.  slider ifNotNil: [ slider color: sliderColor ]nextPage  self currentPageLastIndex < self nodeList size ifTrue: [ currentPageFirstIndex := currentPageFirstIndex + pageSize min: self nodeList size.        self showCurrentPage ]mouseUp: arg1  arg1 hand mouseFocus == owner ifFalse: [ ^self ].  self contentString ifNotNil: [ self contents: self contentString withMarkers: true inverse: true.        self refreshWorld.        (Delay forMilliseconds: 200) wait ].  self deselect: arg1.  self invokeWithEvent: arg1fillStyleToUse  ^self enabled ifTrue: [ self theme listNormalFillStyleFor: self ] ifFalse: [ self theme listDisabledFillStyleFor: self ]isMouseMove  ^falserotationDegrees: arg1  dragTransferType  ^self getListElementSelectorisSoleItem  ^self isFirstItem and: [ owner submorphs size = 1 ]fontToUse  | tmp1 |  tmp1 := font ifNil: [ TextStyle defaultFont ] ifNotNil: [ font ].  (emphasis isNil or: [ emphasis = 0 ]) ifTrue: [ ^tmp1 ] ifFalse: [ ^tmp1 emphasized: emphasis ]handleYearTouched  | tmp1 tmp2 |  tmp1 := UIManager default chooseOrRequestFrom: (2000 to: 2020) lines: #() title: 'Choose a year:'.  tmp1 ifNil: [ ^self ].  tmp1 := tmp1 asNumber.  tmp2 := (Month year: tmp1 month: date monthIndex) daysInMonth.  self date: (Date year: tmp1 month: date monthIndex day: (date dayOfMonth min: tmp2)).  self changeddiscoveredMenuPragmaKeyword  ^'windowMenu'isOpened  ^trueopenModal  self openInWorld.  self theme runModal: selfallowsDeselection: arg1  allowsDeselection := arg1addModelYellowButtonItemsTo: arg1 event: arg2  self model ifNotNil: [:arg3 |  arg3 addModelYellowButtonMenuItemsTo: arg1 forMorph: self hand: arg2 hand ]image: arg1 size: arg2  | tmp1 |  (arg1 depth < 32 and: [ arg1 depth > 4 ]) ifTrue: [ tmp1 := Form extent: arg2 depth: 32.        tmp1 fillColor: (Color white alpha: 0.003922).        tmp1 getCanvas translucentImage: arg1 at: 0 @ 0.        tmp1 fixAlpha ] ifFalse: [ tmp1 := arg1 ].  tmp1 := tmp1 scaledToSize: arg2.  self autoSize ifTrue: [ super image: tmp1 ] ifFalse: [ image := tmp1.        self changed ].  self cachedForm: nil.  self changed: #imageExtentpage  ^self pageMorphnextCell: arg1  nextCell := arg1lastPaneColor  ^lastPaneColorshadowForm  | tmp1 tmp2 |  tmp1 := Rectangle merging: (submorphs collect: [:arg1 |  arg1 fullBounds ]).  tmp2 := (Display defaultCanvasClass extent: tmp1 extent depth: 1) asShadowDrawingCanvas: Color black.  tmp2 translateBy: tmp1 topLeft negated during: [:arg2 |  self drawSubmorphsOn: arg2 ].  ^tmp2 form offset: tmp1 topLeftresizeWidget  | tmp1 tmp2 |  self flag: #pharoTodo.  tmp1 := table bounds left @ (table bounds bottom - self fieldHeigh - table horizontalScrollBarHeight).  tmp2 := (table bounds right - table verticalScrollBarWidth) @ (table bottom - table horizontalScrollBarHeight).  field bounds: (tmp1 corner: tmp2)enabled  ^enabled ifNil: [ true ]initialize  super initialize.  self enableDragNDrop.  self clipSubmorphs: truedispatchDropEvent: arg1 with: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  (arg2 fullBounds containsPoint: arg1 cursorPoint) ifFalse: [ ^#rejected ].  arg2 rejectDropEvent: arg1.  arg1 wasHandled ifTrue: [ ^self ].  tmp2 := 1.  tmp1 := false.  tmp3 := arg2 submorphs.  [ tmp2 <= tmp3 size ] whileTrue: [ tmp4 := tmp3 at: tmp2.        tmp5 := arg1 transformedBy: (tmp4 transformedFrom: arg2).        (tmp4 processEvent: tmp5 using: self) == #rejected ifFalse: [ tmp5 wasHandled ifTrue: [ ^arg1 wasHandled: true ].              tmp1 := true.              tmp2 := tmp3 size ].        tmp2 := tmp2 + 1 ].  tmp1 ifFalse: [ tmp1 := arg2 containsPoint: arg1 cursorPoint event: arg1 ].  tmp1 ifTrue: [ ^arg2 handleEvent: arg1 ].  ^#rejectedprintOn: arg1  arg1 nextPut: $[.  arg1     nextPutAll: self startPoint printString;     space.  arg1     nextPutAll: self endPoint printString;     space.  arg1     nextPutAll: self type;     space.  arg1 nextPutAll: self modifierString.  arg1 nextPutAll: self buttonString.  arg1     nextPutAll: timeStamp printString;     space.  arg1 nextPutAll: self windowIndex printString.  arg1 nextPut: $]imageForm: arg1 forRectangle: arg2  | tmp1 |  tmp1 := Display defaultCanvasClass extent: arg2 extent depth: arg1.  backgroundColor isTransparent ifTrue: [ tmp1 form fillColor: self theme backgroundColor ].  tmp1 translateBy: arg2 topLeft negated during: [:arg3 |  arg3 fullDrawMorph: self ].  ^tmp1 form offset: arg2 topLeftkeystrokeActionSelector  ^keystrokeActionSelectorminimizeOrRestore  | tmp1 tmp2 |  isCollapsed ifTrue: [ self theme shouldUseAnimations ifTrue: [ self animateRestoreFromMinimized ].        isCollapsed := false.        self           setBoundsWithFlex: fullFrame;           comeToFront;           show.        tmp1 := self modalChild.        paneMorphs reverseDo: [:arg1 |  tmp1 ifNil: [ arg1 unlock ].              self addMorph: arg1.              self world startSteppingSubmorphsOf: arg1 ].        self activate ] ifFalse: [ isCollapsed := true.        fullFrame := self getBoundsWithFlex.        paneMorphs do: [:arg1 |  arg1                 delete;                 releaseCachedState ].        self           setBoundsWithFlex: (-100 @ -100 extent: 2 @ 2);           hide.        self theme shouldUseAnimations ifTrue: [ self animateMinimize ].        self isActive ifTrue: [ self world navigateVisibleWindowForward ] ].  self layoutChanged.  tmp2 := self isMinimized ifTrue: [ WindowCollapsed new ] ifFalse: [ WindowExpanded new ].  tmp2 window: self.  self announce: tmp2dataSource: arg1  dataSource := arg1.  children ifNotNil: [ children do: [:arg2 |  arg2 dataSource: arg1 ] ]rowMorphGetterBlock  ^self rowMorphGetSelector isSymbol ifTrue: [ self rowMorphGetSelector numArgs = 0 ifTrue: [ [:arg1 :arg2 |  arg1 perform: self rowMorphGetSelector ] ] ifFalse: [ [:arg1 :arg2 |  arg1 perform: self rowMorphGetSelector with: self container ] ] ] ifFalse: [ self rowMorphGetSelector numArgs = 2 ifTrue: [ self rowMorphGetSelector ] ifFalse: [ [:arg1 :arg2 |  self rowMorphGetSelector value: arg1 ] ] ]specialKeyPressed: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 keyString.  tmp1 = '<escape>' ifTrue: [ ^ActiveEvent shiftPressed ifTrue: [ self currentWorld invokeWorldMenuFromEscapeKey ] ifFalse: [ (self yellowButtonActivity: false) ifTrue: [ ^self ] ] ].  tmp1 = '<cr>' ifTrue: [ self selectSearchedElement ].  tmp2 := self maximumSelection.  tmp2 > 0 ifFalse: [ ^self ].  tmp3 := tmp4 := self getCurrentSelectionIndex.  tmp1 = '<down>' ifTrue: [ self resetListSelectionSilently.        tmp3 := tmp4 + 1.        tmp3 > tmp2 ifTrue: [ tmp3 := tmp2 ] ].  tmp1 = '<up>' ifTrue: [ self resetListSelectionSilently.        tmp3 := tmp4 - 1.        tmp3 < 1 ifTrue: [ tmp3 := 1 ] ].  tmp1 = '<home>' ifTrue: [ self resetListSelectionSilently.        tmp3 := 1 ].  tmp1 = '<end>' ifTrue: [ self resetListSelectionSilently.        tmp3 := tmp2 ].  tmp5 := self numSelectionsInView.  tmp1 = '<pageUp>' ifTrue: [ self resetListSelectionSilently.        tmp3 := 1 max: tmp4 - tmp5 ].  tmp1 = '<pageDown>' ifTrue: [ self resetListSelectionSilently.        tmp3 := tmp4 + tmp5 min: tmp2 ].  (self enabled and: [ model okToChange ]) ifFalse: [ ^self ].  tmp4 = tmp3 ifTrue: [ ^self ].  ^self changeModelSelection: tmp3passiveDisabledOverUpFillStyle: arg1  self stateMap atPath: #(passive disabled over up) put: arg1.  self changedgetList  getListSelector == nil ifTrue: [ ^#() ].  list := model perform: getListSelector.  list == nil ifTrue: [ ^#() ].  list := list collectWithIndex: [:arg1 :arg2 |  self wrapItem: arg1 index: arg2 ].  ^listsetWidth: arg1  self extent: arg1 @ (self fontToUse height ceiling + (2 * self offset))mouseMove: arg1  self eventHandler ifNotNil: [ self eventHandler mouseMove: arg1 fromMorph: self ]newTitle: arg1 for: arg2  ^self theme newTitleIn: self label: arg1 for: arg2hShowScrollbar  self hResizeScrollbar.  self hScrollbarShowing ifTrue: [ ^self ].  self privateAddMorph: self hScrollbar atIndex: 1.  self vResizeScrollbar.  self resizeScrollercolumns  ^columns ifNil: [ self columns: (OrderedCollection with: MorphTreeColumn new).        columns ]rootItem: arg1  rootItem := arg1mouseUp: arg1  super mouseUp: arg1.  self enabled ifFalse: [ ^self ].  self down: false.  (self containsPoint: arg1 cursorPoint) ifTrue: [ upAction value ]searchedFrame  ^searchedElement ifNotNil: [:arg1 |  arg1 bounds: arg1 selectionFrame in: self ]isUserInterrupt  ^UserInterruptHandler cmdDotEnabled and: [ self keyCharacter = $. and: [ self commandKeyPressed ] ]wouldAcceptKeyboardFocus  ^falseexpandedButton  ^IconicButton new     target: self;     actionSelector: #collapseAndRefresh;     arguments: {};     labelGraphic: self class expandedForm;     color: Color transparent;     helpText: 'Unexpand Item';     borderWidth: 0newTreeFor: arg1 list: arg2 selected: arg3 changeSelected: arg4  ^self theme newTreeIn: self for: arg1 list: arg2 selected: arg3 changeSelected: arg4positionWhenComposed: arg1  positionWhenComposed := arg1doubleClick: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #doubleClick from: arg2label: arg1 selected: arg2  | tmp1 tmp2 |  tmp1 := arg1 isMorph ifTrue: [ arg1 ] ifFalse: [ (self theme buttonLabelForText: arg1)           vResizing: #shrinkWrap;           hResizing: #shrinkWrap ].  tmp2 := arg2 isMorph ifTrue: [ arg2 ] ifFalse: [ (self theme buttonLabelForText: arg2)           vResizing: #shrinkWrap;           hResizing: #shrinkWrap ].  self     normalLabel: tmp1;     selectedLabel: tmp2;     selected: self isSelecteddisable  self enabled: falseinitializeShortcuts: arg1  super initializeShortcuts: arg1.  arg1 attachCategory: #SimpleHierarchicalList.  arg1 attachCategory: #MorphFocusNavigationboundsIn: arg1  ^self bounds: self bounds in: arg1minHeight  | tmp1 |  tmp1 := self hasIcon ifTrue: [ self icon height + 2 ] ifFalse: [ 0 ].  ^self fontToUse height max: tmp1displayInLine: arg1 onAthensCanvas: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := first stringIndex.  tmp2 := last stringIndex.  (tmp2 < arg1 first or: [ tmp1 > (arg1 last + 1) ]) ifTrue: [ ^self ].  (tmp2 = arg1 first and: [ last textLine ~= arg1 ]) ifTrue: [ ^self ].  (tmp1 = (arg1 last + 1) and: [ last textLine ~= arg1 ]) ifTrue: [ ^self ].  tmp3 := (tmp1 < arg1 first ifTrue: [ arg1 ] ifFalse: [ first ]) left.  tmp4 := (tmp2 > (arg1 last + 1) or: [ tmp2 = (arg1 last + 1) and: [ last textLine ~= arg1 ] ]) ifTrue: [ arg1 right ] ifFalse: [ last left ].  arg2 setPaint: color.  arg2 drawShape: (tmp3 @ arg1 top corner: tmp4 @ arg1 bottom)initialize  super initialize.  self     borderWidth: 0;     changeTableLayout;     cellPositioning: #topLeft;     cellInset: 0 @ -1;     reverseTableCells: true;     pageMorphs: OrderedCollection new;     tabSelectorMorph: self newTabSelectorMorph;     contentMorph: self newContentMorph;     addMorph: self tabSelectorMorph;     addMorph: self contentMorph.  self tabSelectorMorph addDependent: self= arg1  ^self species = arg1 species and: [ self style == arg1 style and: [ self width = arg1 width and: [ self color = arg1 color ] ] ]hasToggle  ^self canExpandtype  ^typeprepareForRotating  ^self addFlexShelltoggleAvoidVisibleBordersAtEdge  self avoidVisibleBordersAtEdge: self avoidVisibleBordersAtEdge notupdatePressedImage  self pressedImage: (target perform: pressedImageSelector)indentGap  ^container indentGap * indentLevelnewSliderFor: arg1 getValue: arg2 setValue: arg3 help: arg4  ^self theme newSliderIn: self for: arg1 getValue: arg2 setValue: arg3 min: 0 max: 1 quantum: nil getEnabled: nil help: arg4hUnadjustedScrollRange  | tmp1 |  tmp1 := scroller localSubmorphBounds ifNil: [ ^0 ].  ^tmp1 rightlabelRect  ^self innerBounds withHeight: self labelHeightborderStyle: arg1  | tmp1 |  self borderStyle = arg1 ifTrue: [ ^self ].  super borderStyle: arg1.  tmp1 := 2 * arg1 width + image extent min asPoint.  bounds extent = tmp1 ifFalse: [ self extent: tmp1 ]addStandardHaloMenuItemsTo: arg1 hand: arg2  arg1 add: 'send to back' selector: #goBehind.  arg1 add: 'bring to front' selector: #comeToFront.  self addEmbeddingMenuItemsTo: arg1 hand: arg2.  arg1 addLine.  self addFillStyleMenuItems: arg1 hand: arg2.  self addBorderStyleMenuItems: arg1 hand: arg2.  self addDropShadowMenuItems: arg1 hand: arg2.  self addLayoutMenuItems: arg1 hand: arg2.  self addHaloActionsTo: arg1.  owner isTextMorph ifTrue: [ self addTextAnchorMenuItems: arg1 hand: arg2 ].  arg1 addLine.  self addToggleItemsToHaloMenu: arg1.  arg1 addLine.  self addExportMenuItems: arg1 hand: arg2.  self addMiscExtrasTo: arg1.  self addDebuggingItemsTo: arg1 hand: arg2.  arg1 addLine.  arg1 defaultTarget: arg2isMenuMorph  ^trueaddActionsToIcon  closeIcon     on: #mouseEnter send: #mouseEnterIcon to: self;     on: #click send: #close to: self;     on: #mouseLeave send: #mouseLeaveIcon to: selfnewLabelFor: arg1 label: arg2 getEnabled: arg3  ^self theme newLabelIn: self for: arg1 label: arg2 getEnabled: arg3taskbarButtonEntered: arg1 event: arg2 in: arg3  arg1 owner ifNotNil: [:arg4 |  | tmp1 |        arg4 showWindowPreview ifFalse: [ ^self ].        tmp1 := self valueOfProperty: #taskbarThumbnail.        tmp1 ifNil: [ tmp1 := self theme newTaskbarThumbnailIn: self for: self ] ifNotNil: [ ^self ].        self setProperty: #taskbarThumbnail toValue: tmp1.        tmp1 bottomLeft: (arg1 left min: arg1 owner right - tmp1 width) @ (arg1 owner top - 4).        tmp1 openInWorld ]lastItem  submorphs reverseDo: [:arg1 |  arg1 isMenuItemMorph ifTrue: [ ^arg1 ] ].  ^submorphs lastchangeProportionalLayout  | tmp1 |  ((tmp1 := self layoutPolicy) notNil and: [ tmp1 isProportionalLayout ]) ifTrue: [ ^self ].  self layoutPolicy: ProportionalLayout new.  self layoutChangedimageMorph  ^imageMorphnewTransformationMorph  ^TransformationMorph newnumberOfColumns  ^columns sizeflashFinished: arg1 original: arg2  self fillStyle == arg1 ifTrue: [ self fillStyle: arg2 ]resetExtent  self resizeScrollerballoonTextSelector: arg1  balloonTextSelector := arg1.  self updateBalloonTexticonBlock  ^iconBlock ifNil: [ [:arg1 |  arg1 icon ] ]fallbackMenuOn: arg1  arg1 addToggle: 'Close' translated target: self selector: #closeBoxHit getStateSelector: nil enablementSelector: #allowedToClose.  arg1 lastItem icon: self theme windowCloseForminitializeSlider  self     initializeUpButton;     initializeDownButton;     initializePagingArea.  super initializeSlider.  self sliderColor: self sliderColor.  self slider     width: self theme scrollbarThickness;     height: self theme scrollbarThickness.  slider cornerStyle: (self theme scrollbarThumbCornerStyleIn: self window).  slider on: #mouseEnter send: #mouseEnterThumb: to: self.  slider on: #mouseLeave send: #mouseLeaveThumb: to: selfname: arg1  arg1 isString ifTrue: [ self setNameTo: arg1 ]scale  ^transform scaleinspectOwnerChain  self ownerChain inspectWithLabel: 'Owner chain for ' , self printStringtestIntoWorldDeleteOutOfWorld  | tmp1 tmp2 |  tmp1 := TestInWorldMorph new.  tmp2 := TestInWorldMorph new.  self assert: tmp1 intoWorldCount equals: 0.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 0.  self assert: tmp2 outOfWorldCount equals: 0.  morph addMorphFront: tmp1.  tmp1 addMorphFront: tmp2.  self assert: tmp1 intoWorldCount equals: 0.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 0.  self assert: tmp2 outOfWorldCount equals: 0.  morph openInWorld.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 0.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 0.  morph delete.  self assert: tmp1 intoWorldCount equals: 1.  self assert: tmp1 outOfWorldCount equals: 1.  self assert: tmp2 intoWorldCount equals: 1.  self assert: tmp2 outOfWorldCount equals: 1mouseStillDownStepRate  ^10newDropListFor: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 help: arg6  ^self theme newDropListIn: self for: arg1 list: arg2 getSelected: arg3 setSelected: arg4 getEnabled: arg5 useIndex: true help: arg6handleUnknownEvent: arg1  self inform: 'Unknown event: ' , arg1 printString.  arg1 printString displayAt: 0 @ 0.  arg1 wasHandled: truemouseEnterDragging: arg1 onItem: arg2  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersboundsForBalloon  | tmp1 |  ^((owner notNil and: [ (tmp1 := owner owner) notNil ]) and: [ tmp1 isKindOf: PluggableListMorph ]) ifTrue: [ self boundsInWorld intersect: tmp1 boundsInWorld ifNone: [ self boundsInWorld ] ] ifFalse: [ super boundsForBalloon ]initialize  super initialize.  self color: self theme textColor.  font := StandardFonts listFont.  listItems := #().  selectedRows := PluggableSet integerSet.  self adjustHeightwithSiblingsDo: arg1  | tmp1 |  tmp1 := self.  [ tmp1 isNil ] whileFalse: [ arg1 value: tmp1.        tmp1 := tmp1 nextSibling ]adoptPaneColor: arg1  super adoptPaneColor: arg1.  arg1 ifNil: [ ^self ].  self color: arg1handlesMouseOverDragging: arg1  self eventHandler ifNotNil: [ ^self eventHandler handlesMouseOverDragging: arg1 ].  ^falseupdateList  (showIndex < self dataSource numberOfRows and: [ self isIndexVisible: showIndex ]) ifFalse: [ self resetPosition ].  self basicUpdateSelectionIndex.  (self hasSelection and: [ self isIndexVisible: self selectedIndex ]) ifFalse: [ self resetPosition.        self ensureVisibleFirstSelection ].  self refreshinteractWithSelectedItem  self selection ifNotNil: [:arg1 |  arg1 submorphs do: [:arg2 |  arg2 update: #interact ] ]setLabelFont: arg1  label ifNil: [ ^self ].  label font: arg1isExplicit  ^field isNotNildeleteDiscardingChanges  | tmp1 tmp2 tmp3 |  tmp3 := self visible and: [ self world notNil and: [ self theme shouldUseAnimations and: [ self theme animationSettings animateClosing ] ] ].  self removePaneSplitters.  tmp1 := self world.  self isFlexed ifTrue: [ owner delete ] ifFalse: [ super delete ].  model ifNotNil: [ model           windowIsClosing;           releaseActionMap ].  model := nil.  tmp3 ifTrue: [ self animateClose ].  SystemWindow noteTopWindowIn: tmp1.  tmp2 := WindowClosed new     window: self;     yourself.  self announce: tmp2.  self currentWorld announcer announce: tmp2addFullHandles  self addCircleHandlesisForDragging  ^location isNilavailableRows  ^expanded ifTrue: [ children inject: 1 into: [:arg1 :arg2 |  arg1 + arg2 availableRows ] ] ifFalse: [ 1 ]min: arg1  min := arg1.  self setValue: self valuewantsDroppedMorph: arg1 event: arg2  ^self model wantsDroppedMorph: arg1 event: arg2 inMorph: selfaddBorderStyleMenuItems: arg1 hand: arg2  | tmp1 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 add: 'border width...' selector: #changeBorderWidth:.  tmp1 add: 'border color...' selector: #changeBorderColor:.  tmp1 addLine.  BorderStyle borderStyleChoices do: [:arg3 |  (self borderStyleForSymbol: arg3) ifNotNil: [ tmp1 add: arg3 target: self selector: #setBorderStyle: argument: arg3 ] ].  arg1 add: 'border style' subMenu: tmp1savePatchFrom: arg1  | tmp1 tmp2 |  tmp1 := tmp2 := self fullBounds.  savedPatch ifNotNil: [ tmp1 := tmp2 merge: (savedPatch offset extent: savedPatch extent) ].  (savedPatch isNil or: [ savedPatch extent ~= tmp2 extent ]) ifTrue: [ savedPatch := arg1 form allocateForm: tmp2 extent ].  arg1 contentsOfArea: (tmp2 translateBy: arg1 origin) into: savedPatch.  savedPatch offset: tmp2 topLeft.  ^tmp1setValueSelector: arg1  setValueSelector := arg1mainPanel  ^self paneMorphs isEmpty ifFalse: [ self paneMorphs first ]collapseAll  children do: #collapseAllitemMorphFor: arg1 index: arg2  | tmp1 tmp2 |  tmp1 := IconicListItem new     originalObject: arg1;     yourself.  tmp2 := self getIconSelector ifNotNil: [ self model perform: self getIconSelector withEnoughArguments: {arg1 .               arg2} ].  tmp2 ifNotNil: [ tmp1 icon: tmp2 asMorph ].  tmp1 morph: (self wrapItem: arg1 index: arg2) asMorph.  ^tmp1disableFunction  function isExplicit ifTrue: [ function disable.        self resizeAllSubviews ].  function := FTNilFunction table: selfdefaultBorderColor  ^self theme settings flatMenu ifFalse: [ #inset ] ifTrue: [ self theme settings derivedMenuColor muchDarker ]sentTo: arg1  type == #mouseDown ifTrue: [ ^arg1 handleMouseDown: self ].  type == #mouseUp ifTrue: [ ^arg1 handleMouseUp: self ].  ^super sentTo: arg1morphicLayerNumber  ^self valueOfProperty: #morphicLayerNumber ifAbsent: [ stayUp ifTrue: [ 100 ] ifFalse: [ 10 ] ]fullscreenMode: arg1  Display fullscreenMode: arg1.  self checkForNewScreenSizelockUnlockMorph  self isLocked ifTrue: [ self unlock ] ifFalse: [ self lock ]doDirection: arg1 with: arg2  arg1 hand obtainHalo: self.  self removeAllHandlesBut: arg2gradientWithColor: arg1  | tmp1 |  tmp1 := {(0.0 -> Color white) .   (1.0 -> arg1)}.  ^(GradientFillStyle ramp: tmp1)     radial: true;     origin: self bounds origin;     direction: 0 @ 223;     normal: 223 @ 0rectangleOval  self setVertices: self bounds cornersnewColorPresenterMorph  ^self newColorPresenterFor: self getColor: #selectedColor help: 'Shows the selected color' translatednameColumn: arg1 row: arg2  ^FTCellMorph new     color: (self colorFor: arg2);     cellInset: 5;     addMorphBack: (self iconFor: arg2) asMorph;     addMorphBack: (self elementAt: arg2) name asStringMorph;     yourselfdefaultFillStyle  ^Color grayhasArrows  ^(closed or: [ arrows == #none or: [ vertices size < 2 ] ]) notisEnabledMatchingTheState: arg1  ^self subclassResponsibilityfirst  ^firstIndextabSelectorMorph  ^tabSelectorMorphscrollUpByPageDelta  self scrollUp: self pageDeltacolorFor: arg1  ^Color transparentselectNodePath: arg1  | tmp1 |  arg1 ifNil: [ ^self ].  arg1 isEmpty ifTrue: [ ^self ].  self withSiblingsDo: [:arg2 |  tmp1 ifNil: [ (arg2 complexContents = arg1 first or: [ arg1 first isNil ]) ifTrue: [ tmp1 := arg2 ] ] ].  tmp1 ifNotNil: [ arg1 size = 1 ifTrue: [ ^container listManager addToSelection: tmp1 ].        tmp1 firstChild ifNotNil: [:arg3 |  arg3 selectNodePath: arg1 allButFirst ] ]tabResetSelection: arg1  self setTabContentFrom: arg1chunkSize  ^pageSizeselectedTab  ^toolbar selectedTabgetSelectionIndexOf: arg1  ^arg1 ifNil: [ 0 ] ifNotNil: [ arg1 index ]asDraggableMorph  ^self thumbnailOfSize: self header fullBounds extentreverseTableCells: arg1  reverseTableCells := arg1isNotMaximized  ^self unexpandedFrame isNilhIsScrolled  ^scroller offset x > 0findAndSelect: arg1 startingAt: arg2 searchBackwards: arg3  | tmp1 |  self handleEdit: [ tmp1 := self editor findAndSelect: arg1 startingAt: arg2 searchBackwards: arg3 ].  editView scrollSelectionIntoView.  ^tmp1mouseLeaveThumb: arg1  | tmp1 tmp2 |  arg1 redButtonPressed ifFalse: [ slider           fillStyle: self normalThumbFillStyle;           borderStyle: self normalThumbBorderStyle;           changed ].  (self containsPoint: arg1 position) ifTrue: [ tmp1 := self mouseOverPagingAreaButtonFillStyle.        tmp2 := self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ tmp1 := self normalButtonFillStyle.        tmp2 := self normalButtonBorderStyle ].  upButton     fillStyle: tmp1;     borderStyle: tmp2.  downButton     fillStyle: tmp1;     borderStyle: tmp2newBalloonHelp: arg1 for: arg2 corner: arg3  ^self theme newBalloonHelpIn: self contents: arg1 for: arg2 corner: arg3editView  ^editViewoutermostOwnerWithYellowButtonMenu  | tmp1 |  tmp1 := self outermostMorphThat: [:arg1 |  arg1 isWorldMorph not and: [ arg1 hasYellowButtonMenu ] ].  ^tmp1 ifNil: [ self hasYellowButtonMenu ifTrue: [ self ] ifFalse: [  ] ]withSearch  ^withSearch ifNil: [ withSearch := false ]selectedColor: arg1  self basicSelectedColor: arg1.  self hsvaMorph selectedColor: arg1beNotResizable  resizable := falsescaleFor: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := arg2 width asFloat / arg1 width.  tmp3 := arg2 height asFloat / arg1 height.  tmp4 := tmp2 / tmp3.  tmp5 := 1.0 / EccentricityThreshhold.  tmp4 < tmp5 ifTrue: [ tmp1 := tmp2 @ (tmp5 * tmp3) ] ifFalse: [ tmp4 > EccentricityThreshhold ifTrue: [ tmp1 := (tmp5 * tmp2) @ tmp3 ] ifFalse: [ tmp1 := tmp2 min: tmp3 ] ].  ^tmp1defaultColor  ^self theme windowColorstyle  ^styleselectedPageIndex  ^self tabSelectorMorph selectedIndexupdate: arg1  super update: arg1.  arg1 == #selectedIndex ifTrue: [ self updatePageIndex: self selectedPageIndex ]forceDisplayUpdate  ^Display forceDisplayUpdatemultipleSelection: arg1  multipleSelection := arg1over  ^overisWindowEvent  ^trueoffImage  ^offImageonColor: arg1  onColor := arg1mouseUp: arg1  | tmp1 tmp2 |  self enabled ifFalse: [ ^self ].  mouseOverAllowed := false.  tmp1 := self scrollerSubMorphFromPoint: arg1 position.  tmp2 := tmp1 notNil ifTrue: [ tmp1 highlightedForMouseDown ] ifFalse: [ false ].  self allNodeMorphs do: [:arg2 |  arg2 highlightedForMouseDown ifTrue: [ arg2 highlightForMouseDown: false ] ].  tmp2 ifFalse: [ tmp1 ifNotNil: [ ^self ] ].  self listManager mouseUp: arg1 on: tmp1transformBy: arg1  position := arg1 globalPointToLocal: positionsetShadowOffset: arg1  | tmp1 |  tmp1 := HandleMorph new forEachPointDo: [:arg2 |  self shadowPoint: arg2 ].  arg1 hand attachMorph: tmp1.  tmp1 startSteppinghighlightedForDrop  ^(self valueOfProperty: #highlightedForDrop) == trueicon: arg1  icon := arg1newLabelGroup: arg1  ^self theme newLabelGroupIn: self for: arg1mouseDownHighlightColor  | tmp1 |  tmp1 := self color isTransparent ifTrue: [ self firstOwnerSuchThat: [:arg1 |  arg1 isWorldOrHandMorph not and: [ arg1 color isTransparent not ] ] ] ifFalse: [ self ].  tmp1 ifNil: [ ^Color black ].  ^tmp1 color luminance > 0.5 ifTrue: [ Color black ] ifFalse: [ Color white ]dragTransferType: arg1  transferType := arg1selectionColorToUse: arg1  arg1 = self selectionColorToUse ifTrue: [ ^self ].  selectionColorToUse := arg1.  self listMorph selectionFrameChangeddoOneCycle  worldState doOneCycleFor: selfdropHighlightColor  ^Color bluewantsRoundedCorners  ^self theme currentSettings preferRoundCornerrealSearch  self initializeNewSearch.  dataSource rootsItems do: [:arg1 |  self searchIn: arg1 ] displayingProgress: [:arg2 |  'Looking inside ' , arg2 name ].  ^result asArrayframePolygon: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 tmp16 tmp17 tmp18 tmp19 tmp20 tmp21 tmp22 tmp23 tmp24 |  tmp21 := arg2 asBalloonCanvas.  tmp21 == arg2 ifFalse: [ tmp21 deferred: true ].  tmp22 := Array new: 6.  tmp16 := width * 0.5.  tmp12 := nil.  1 to: arg1 size do: [:arg3 |  tmp17 := arg1 atWrap: arg3.        tmp18 := arg1 atWrap: arg3 + 1.        tmp19 := arg1 atWrap: arg3 + 2.        tmp20 := arg1 atWrap: arg3 + 3.        tmp1 := tmp18 - tmp17.        tmp2 := tmp19 - tmp18.        tmp3 := tmp20 - tmp19.        arg3 = 1 | true ifTrue: [ tmp10 := tmp2 crossProduct: tmp1.              tmp4 := tmp1 normalized.              tmp4 := (tmp4 y * tmp16) @ ((0 - tmp4 x) * tmp16).              tmp5 := tmp2 normalized.              tmp5 := (tmp5 y * tmp16) @ ((0 - tmp5 x) * tmp16).              tmp10 < 0 ifTrue: [ tmp4 := tmp4 negated.                    tmp5 := tmp5 negated ].              tmp7 := (tmp17 x + tmp4 x) @ (tmp17 y + tmp4 y).              tmp8 := (tmp18 x + tmp5 x) @ (tmp18 y + tmp5 y).              tmp12 := self intersectFrom: tmp7 with: tmp1 to: tmp8 with: tmp2.              tmp7 := (tmp17 x - tmp4 x) @ (tmp17 y - tmp4 y).              tmp8 := (tmp18 x - tmp5 x) @ (tmp18 y - tmp5 y).              tmp13 := (tmp7 + tmp1 + tmp8) * 0.5.              tmp13 := tmp18 + ((tmp13 - tmp18) normalized * tmp16).              tmp14 := tmp8 ].        tmp11 := tmp3 crossProduct: tmp2.        tmp5 := tmp2 normalized.        tmp5 := (tmp5 y * tmp16) @ ((0 - tmp5 x) * tmp16).        tmp6 := tmp3 normalized.        tmp6 := (tmp6 y * tmp16) @ ((0 - tmp6 x) * tmp16).        tmp11 < 0 ifTrue: [ tmp5 := tmp5 negated.              tmp6 := tmp6 negated ].        tmp8 := (tmp18 x + tmp5 x) @ (tmp18 y + tmp5 y).        tmp9 := (tmp19 x + tmp6 x) @ (tmp19 y + tmp6 y).        tmp15 := self intersectFrom: tmp8 with: tmp2 to: tmp9 with: tmp3.        tmp8 := (tmp18 x - tmp5 x) @ (tmp18 y - tmp5 y).        tmp9 := (tmp19 x - tmp6 x) @ (tmp19 y - tmp6 y).        tmp24 := tmp8 + tmp2.        tmp23 := (tmp24 + tmp9) * 0.5.        tmp23 := tmp19 + ((tmp23 - tmp19) normalized * tmp16).        tmp10 * tmp11 < 0.0 ifTrue: [ tmp22                 at: 1 put: tmp12;                 at: 2 put: tmp13;                 at: 3 put: tmp14;                 at: 4 put: tmp15;                 at: 5 put: tmp23;                 at: 6 put: tmp24 ] ifFalse: [ tmp22                 at: 1 put: tmp12;                 at: 2 put: tmp13;                 at: 3 put: tmp14;                 at: 4 put: tmp24;                 at: 5 put: tmp23;                 at: 6 put: tmp15 ].        self drawPolyPatchFrom: tmp18 to: tmp19 on: tmp21 usingEnds: tmp22.        tmp12 := tmp15.        tmp13 := tmp23.        tmp14 := tmp24.        tmp10 := tmp11 ].  tmp21 == arg2 ifFalse: [ tmp21 flush ]adoptPaneColor: arg1  super adoptPaneColor: arg1.  self fillStyle: self normalFillStyleverifyContents  | tmp1 tmp2 tmp3 |  tmp3 := list ifNil: [ #() ].  tmp1 := self getList.  (tmp3 == tmp1 or: [ tmp3 = tmp1 ]) ifTrue: [ ^self ].  tmp2 := tmp3 isEmpty ifTrue: [ self listMorph selectedRow ] ifFalse: [ (self selectionIndex between: 1 and: tmp1 size) ifTrue: [ self selectionIndex ] ifFalse: [ nil ] ].  self updateList.  tmp2 notNil ifTrue: [ self selectionIndex: tmp2 ] ifFalse: [ self changeModelSelection: 0 ]popUpInWorld  ^self popUpInWorld: self currentWorldprivateOwner: arg1  owner := arg1vUnadjustedScrollRange  scroller submorphs size > 0 ifFalse: [ ^0 ].  ^scroller submorphs last fullBounds bottomjustifiedTabDeltaFor: arg1  | tmp1 tmp2 |  internalSpaces = 0 ifTrue: [ ^0 ].  tmp1 := paddingWidth // internalSpaces.  tmp2 := paddingWidth \\ internalSpaces.  arg1 <= tmp2 ifTrue: [ ^arg1 * (tmp1 + 1) ] ifFalse: [ ^tmp2 * (tmp1 + 1) + ((arg1 - tmp2) * tmp1) ]newRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 label: arg4 help: arg5  ^self newRadioButtonFor: arg1 getSelected: arg2 setSelected: arg3 getEnabled: nil label: arg4 help: arg5minimumSelection  ^1lastCharacterIndex  ^lines last lastgetFontSelector: arg1  getFontSelector := arg1.  self update: getFontSelectorasLayoutFrame  ^selfcreateTaskbarIfNecessary  self taskbars ifEmpty: [ TaskbarMorph new openInWorld: self.        self moveCollapsedWindowsToTaskbar ]selectionIndex: arg1  | tmp1 |  self unhighlightSelection.  tmp1 := arg1 ifNil: [ 0 ].  tmp1 := tmp1 min: self maximumSelection.  self listMorph selectedRow: tmp1.  self highlightSelection.  self scrollSelectionToRow: tmp1deferUpdates: arg1  ^arg1 valuedefaultLineHeight  ^textStyle lineGridgetHelpSelector: arg1  getHelpSelector := arg1drawSubmorphsOnAthensCanvas: arg1  super drawSubmorphsOnAthensCanvas: arg1.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOnAthensCanvas: arg1 ]is: arg1 bellowRow: arg2  ^arg1 first > arg2actions: arg1  actions := arg1.  self triggerEvent: #actionsChanged with: selfopenAsIsIn: arg1  self playOpenSound.  arg1 addMorph: self.  self activate.  arg1 startSteppingSubmorphsOf: self.  self announceOpened.  self currentWorld announcer announce: (WindowOpened new           window: self;           yourself)outerBounds  | tmp1 |  tmp1 := super outerBounds.  container ifNil: [ ^tmp1 ].  ^tmp1 left: (tmp1 left min: self selectionFrame left)slideIndexBy: arg1 andMoveTopTo: arg2  firstIndex := firstIndex + arg1.  lastIndex := lastIndex + arg1.  bottom := bottom + (arg2 - top).  top := arg2checkWidth  ^10styleInBackgroundProcess: arg1  text: arg1 textStyle: arg2 wrap: arg3 color: arg4 predecessor: arg5 successor: arg6  text := arg1.  defaultColor := (arg1 attributesAt: 1) detect: [:arg7 |  arg7 isKindOf: TextColor ].  textStyle := arg2.  wrapFlag := arg3.  color := arg4.  paragraph := editor := container := nil.  self predecessor: arg5 successor: arg6basicHighlightIndexes: arg1  highlightedIndexes := arg1 asArrayfullBounds  fullBounds ifNotNil: [ ^fullBounds ].  fullBounds := bounds.  submorphs do: [:arg1 |  arg1 ownerChanged ].  ^fullBoundsgetFontSelector  ^getFontSelectorborderWidthForItems: arg1  (selectedItems select: [:arg2 |  arg2 isKindOf: BorderedMorph ]) with: arg1 do: [:arg2 :arg3 |  arg2 borderWidth: arg3 ]tabsChanged  filledForm  | tmp1 tmp2 |  closed ifFalse: [ ^filledForm := nil ].  filledForm ifNotNil: [ ^filledForm ].  filledForm := Form extent: bounds extent + 2.  tmp1 := (BitBlt toForm: filledForm)     sourceForm: nil;     fillColor: Color black;     combinationRule: Form over;     width: 1;     height: 1.  tmp2 := bounds topLeft asIntegerPoint - 1.  self lineSegmentsDo: [:arg1 :arg2 |  tmp1 drawFrom: arg1 asIntegerPoint - tmp2 to: arg2 asIntegerPoint - tmp2 ].  filledForm convexShapeFill: Color black.  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) ifTrue: [ filledForm copy: self borderForm boundingBox from: self borderForm to: 1 @ 1 rule: Form erase ].  ^filledFormaddCellLayoutMenuItems: arg1 hand: arg2  | tmp1 tmp2 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp1 addUpdating: #hasDisableTableLayoutString selector: #changeDisableTableLayout.  tmp1 addLine.  tmp2 := UIManager default newMenuIn: self for: self.  #(#rigid #shrinkWrap #spaceFill) do: [:arg3 |  tmp2 addUpdating: #hResizingString: target: self selector: #hResizing: argumentList: (Array with: arg3) ].  tmp1 add: 'horizontal resizing' subMenu: tmp2.  tmp2 := UIManager default newMenuIn: self for: self.  #(#rigid #shrinkWrap #spaceFill) do: [:arg3 |  tmp2 addUpdating: #vResizingString: target: self selector: #vResizing: argumentList: (Array with: arg3) ].  tmp1 add: 'vertical resizing' subMenu: tmp2.  arg1 ifNotNil: [ arg1 add: 'child layout' subMenu: tmp1 ].  ^tmp1flash  | tmp1 tmp2 |  tmp2 := self flashFillStyle.  tmp1 := self fillStyle.  self fillStyle: tmp2.  self addAlarm: #flashFinished:original: withArguments: {tmp2 .         tmp1} after: 50grabTransform  self renderedMorph isWorldMorph ifTrue: [ ^owner ifNil: [ IdentityTransform new ] ifNotNil: [ owner grabTransform ] ].  ^owner ifNil: [ self transform ] ifNotNil: [ owner grabTransform composedWithLocal: self transform ]isInDockingBar  ^owner notNil and: [ owner isDockingBar ]selectFirst  self selectionModeStrategy selectFirstfindText  ^self editor findTextlabel  ^labelmouseDown: arg1  | tmp1 tmp2 |  (self class isMenuOpenByLeftClick ifTrue: [ arg1 yellowButtonPressed ] ifFalse: [ arg1 redButtonPressed ]) ifTrue: [ ^self popUpContentsMenu: arg1 ].  tmp1 := self morphToGrab: arg1.  tmp1 ifNotNil: [ tmp1 isSticky ifTrue: [ ^self ].        ^arg1 hand grabMorph: tmp1 ].  (super handlesMouseDown: arg1) ifTrue: [ ^super mouseDown: arg1 ].  tmp2 := arg1 hand halo notNil.  arg1 hand removeHalo.  arg1 hand releaseKeyboardFocus.  (arg1 shiftPressed not and: [ self isWorldMorph not and: [ self wantsEasySelection not ] ]) ifTrue: [ arg1 wasHandled: false.        ^self ].  (arg1 shiftPressed or: [ self wantsEasySelection ]) ifTrue: [ | tmp3 |        arg1 shiftPressed ifTrue: [ tmp3 := #popUpContentsMenu: ] ifFalse: [ tmp3 := #invokeWorldMenu: ].        arg1 hand waitForClicksOrDrag: self event: arg1 selectors: {tmp3 .               nil .               nil .               #dragThroughOnDesktop:} threshold: 5 ] ifFalse: [ self invokeWorldMenu: arg1 ]privateFullMoveBy: arg1  super privateFullMoveBy: arg1.  self changed: #positionmouseDownRowFrameChanged  | tmp1 tmp2 |  tmp2 := self mouseDownRow ifNil: [ ^self ].  tmp1 := self selectionFrameForRow: tmp2.  self invalidRect: tmp1forAction: arg1  | tmp1 |  tmp1 := self theme baseColor.  self extent: arg1 icon extent.  self activeEnabledNotOverUpFillStyle: tmp1.  self activeDisabledNotOverUpFillStyle: (self theme buttonDisabledFillStyleFor: self).  self passiveEnabledNotOverUpFillStyle: tmp1.  self passiveDisabledNotOverUpFillStyle: tmp1.  self     activeEnabledOverUpFillStyle: (self theme buttonMouseOverFillStyleFor: self);     passiveEnabledOverUpFillStyle: (self theme buttonMouseOverFillStyleFor: self).  self     activeEnabledOverDownFillStyle: (self theme buttonPressedFillStyleFor: self);     passiveEnabledOverDownFillStyle: (self theme buttonPressedFillStyleFor: self);     addUpAction: [ arg1 action value ];     setBalloonText: arg1 label;     extent: 16 @ 16.  icon := arg1 icon.  ^selfdoubleClickTimeout: arg1 fromMorph: arg2  ^self notifyMorphsOfEvent: arg1 ofType: #doubleClickTimeout from: arg2maybeDuplicateMorph: arg1  ^self duplicateMorph: arg1selector  ^selectornewImageFor: arg1 get: arg2 help: arg3  ^self theme newImageIn: self for: arg1 get: arg2 help: arg3showVScrollBarOnlyWhenNeeded: arg1  self setProperty: #noVScrollBarPlease toValue: arg1.  self setProperty: #vScrollBarAlways toValue: arg1.  self vHideOrShowScrollBartotalSliderArea  ^self innerBoundsbreakDependents  self removeProperty: #announcerremoveExpandBox  expandBox ifNotNil: [ expandBox delete.        expandBox := nil ]adoptPaneColor: arg1  arg1 ifNil: [ ^super adoptPaneColor: arg1 ].  super adoptPaneColor: (self theme subgroupColorFrom: arg1).  self contentMorph borderStyle: (self theme tabPanelBorderStyleFor: self)inspectAt: arg1 event: arg2  | tmp1 tmp2 |  tmp1 := self morphsAt: arg1.  (tmp1 includes: self) ifFalse: [ tmp1 := tmp1 copyWith: self ].  tmp2 := UIManager default chooseFrom: (tmp1 collect: [:arg3 |  arg3 class name asString ]) values: tmp1 title: 'inspect whom? (deepest at top)' translated.  tmp2 ifNil: [ ^self ].  tmp2 inspectInMorphic: arg2interCyclePause: arg1  | tmp1 tmp2 |  tmp1 := self serverMode ifTrue: [ 50 ] ifFalse: [ tmp2 := (lastCycleTime notNil and: [ CanSurrenderToOS ~~ false ]) ifFalse: [ 0 ] ifTrue: [ lastCycleTime + arg1 - Time millisecondClockValue ].        self flag: 'Issue 14754 - wait2>millisecs is only True for clock rollover. Remove it once delay scheduler is based on microsecondClock - Ben Coman 19.01.2015'.        tmp2 > arg1 ifTrue: [ 0 ] ifFalse: [ tmp2 ] ].  tmp1 > 0 ifTrue: [ (Delay forMilliseconds: tmp1) wait ].  lastCycleTime := Time millisecondClockValue.  CanSurrenderToOS := truemodel  ^modelsetUp  super setUp.  cases := #()keyTextFont  ^self fontSized: self pointSize * 2areasRemainingToFill: arg1  ^Array with: arg1minExtent  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := self hResizing.  tmp5 := self vResizing.  (tmp4 == #spaceFill or: [ tmp5 == #spaceFill ]) ifFalse: [ ^self fullBounds extent ].  tmp1 := self layoutPolicy.  tmp2 := tmp1 ifNil: [ 0 @ 0 ] ifNotNil: [ tmp1 minExtentOf: self in: self layoutBounds ].  tmp2 := tmp4 == #rigid ifTrue: [ self fullBounds extent x @ tmp2 y ] ifFalse: [ tmp3 := self bounds width - self layoutBounds width.        (tmp2 x + tmp3) @ tmp2 y ].  tmp2 := tmp5 == #rigid ifTrue: [ tmp2 x @ self fullBounds extent y ] ifFalse: [ tmp3 := self bounds height - self layoutBounds height.        tmp2 x @ (tmp2 y + tmp3) ].  tmp2 := tmp2 max: self minWidth @ self minHeight.  ^tmp2width: arg1  addAllFrom: arg1  arg1 submorphsDo: [:arg2 |  self addMorphBack: arg2 ]textEntryLabel: arg1 get: arg2 set: arg3 help: arg4 class: arg5  ^RubPluggableTextFieldMorph new     on: self text: arg2 accept: arg3 readSelection: nil menu: nil;     setBalloonText: arg4;     yourselfdockingBars  ^self submorphs select: [:arg1 |  arg1 isDockingBar ]formOrMorphToView  | tmp1 |  objectToView isForm ifTrue: [ ^objectToView ].  tmp1 := viewSelector ifNil: [ objectToView ] ifNotNil: [ objectToView perform: viewSelector ].  ^tmp1 = 0 ifTrue: [ nil ] ifFalse: [ tmp1 ]frameRectangle: arg1 on: arg2  arg2 frameRectangle: arg1 width: self width color: self colorcontentBounds  ^self fullBounds insetOriginBy: self indentGap @ 0 cornerBy: 0 @ 0columnDropUnabled  ^columnDropUnabledgapSize  ^gapSize ifNil: [ gapSize := 10 ]initialize  self stateMap: KeyedTree new.  enabled := true.  active := true.  over := false.  down := false.  super initializeenabled: arg1  enabled := arg1.  self labelMorph ifNotNil: [:arg2 |  arg2 enabled: arg1 ].  self buttonMorph ifNotNil: [:arg2 |  arg2 enabled: arg1 ].  self changed: #enableddrawSubmorphsOn: arg1  drawable ifFalse: [ ^self ].  super drawSubmorphsOn: arg1isFloating  ^self isHorizontal not and: [ self isVertical not ]isTextMorph  ^truecanvas  ^self worldRenderer canvaschangeColor  self setWindowColordoButtonAction  | tmp1 |  (target notNil and: [ actionSelector notNil ]) ifTrue: [ tmp1 := color = onColor.        target perform: actionSelector withArguments: (arguments copyWith: tmp1) ]newOKButtonFor: arg1 getEnabled: arg2  ^self theme newOKButtonIn: self for: arg1 getEnabled: arg2gradient  | tmp1 |  tmp1 := self innerBounds.  ^(GradientFillStyle colors: {Color white .         self color})     origin: tmp1 topLeft;     direction: tmp1 width @ 0filter  ^dataSource class root: (FTRootItem new           children: (dataSource rootsItems select: [:arg1 |  (pattern matchesIn: (self dataSource toString: arg1)) notEmpty ]);           yourself) children: dataSource childrenBlockallStringsAfter: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := arg1 isNil.  self allMorphsDo: [:arg2 |  | tmp3 |        tmp2 ifFalse: [ tmp2 := arg2 == arg1 ].        tmp2 ifTrue: [ (tmp3 := arg2 userString) ifNotNil: [ tmp3 isString ifTrue: [ tmp1 add: tmp3 ] ifFalse: [ tmp1 addAll: tmp3 ] ] ] ].  ^tmp1addCustomMenuItems: arg1 hand: arg2  super addCustomMenuItems: arg1 hand: arg2.  arg1 add: 'change font' selector: #changeFont.  arg1 add: 'change emphasis' selector: #changeEmphasisinitialize  super initialize.  self     color: self defaultColor;     borderWidth: self defaultBorderWidthinitialize  super initialize.  self sliderMorph: self newSliderMorph.  self     changeTableLayout;     listDirection: #leftToRight;     cellInset: 0;     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     borderColor: Color transparent;     addMorphBack: self newDecrementButton;     addMorphBack: self sliderMorph;     addMorphBack: self newIncrementButtonrelabelTab: arg1 with: arg2  arg1 label: arg2.  arg1 owner ifNotNil: [ self updateTabs.        (arg1 isSelected and: [ arg1 isVisible not ]) ifTrue: [ self ensureSelectedTabIsVisible ] ]addStandardHaloMenuItemsTo: arg1 hand: arg2  arg1 add: 'browse action' selector: #browseAction.  arg1 addLine.  super addStandardHaloMenuItemsTo: arg1 hand: arg2anyButtonPressed  ^buttons anyMask: self class anyButtoncurrentWidth  ^currentWidth ifNil: [ currentWidth := self defaultWidth ]selectSearchedElement  self searchedElement ifNotNil: [:arg1 |  ActiveEvent commandKeyPressed ifFalse: [ self resetListSelectionSilently ].        self changeModelSelection: arg1.        self isMultipleSelection ifTrue: [ self listSelectionAt: arg1 put: true ].        self vScrollValue: (arg1 - 1) / self getListSize ]maybeDuplicateMorph  ^self duplicate openInHandstartDrag: arg1  | tmp1 tmp2 tmp3 |  self dragEnabled ifTrue: [ tmp2 := scroller submorphs detect: [:arg2 |  arg2 highlightedForMouseDown ] ifNone: [  ] ].  (tmp2 isNil or: [ arg1 hand hasSubmorphs ]) ifTrue: [ ^self ].  tmp2 highlightForMouseDown: false.  tmp2 ~= self selectedMorph ifTrue: [ self setSelectedMorph: tmp2 ].  tmp3 := dragItemSelector ifNil: [ self model dragPassengerFor: tmp2 withoutListWrapper inMorph: self ] ifNotNil: [ self model perform: dragItemSelector withEnoughArguments: {tmp2 withoutListWrapper .               self} ].  tmp3 ifNotNil: [ tmp1 := self model transferFor: tmp3 from: self.        tmp1 dragTransferType: #dragTransfer.        tmp1 align: tmp1 draggedMorph center with: arg1 position.        arg1 hand grabMorph: tmp1 ].  arg1 hand releaseMouseFocus: selftoggleDropShadow  self hasDropShadow ifTrue: [ self removeDropShadow ] ifFalse: [ self addDropShadow ]disabledBorderStyle  ^self theme controlButtonDisabledBorderStyleFor: selffullBounds  ^self perform: #fullBounds withArguments: #() inSuperclass: MorphveryDeepFixupWith: arg1  super veryDeepFixupWith: arg1.  model := arg1 references at: model ifAbsent: [ model ]optimalExtent  ^self form extent * self scale + (self borderWidth * 2)stringColor  ^self enabled ifTrue: [ self color ] ifFalse: [ self theme labelDisabledColorFor: self ]getIndexSelector: arg1  getIndexSelector := arg1frameRectangle5: arg1 on: arg2  | tmp1 |  tmp1 := arg1 insetBy: self width // 2.  self width odd ifTrue: [ tmp1 := tmp1 insetBy: (0 @ 0 corner: 1 @ 1) ].  arg2     line: tmp1 topLeft + (5 @ 0) to: tmp1 topRight - (5 @ 0) width: self width color: self color;     line: tmp1 topRight + (-4 @ 1) to: tmp1 topRight + (-2 @ 2) width: self width color: self color;     line: tmp1 topRight + (-1 @ 3) to: tmp1 topRight + (-1 @ 4) width: self width color: self color;     line: tmp1 topRight + (0 @ 5) to: tmp1 bottomRight - (0 @ 5) width: self width color: self color;     line: tmp1 bottomRight - (1 @ 4) to: tmp1 bottomRight - (2 @ 2) width: self width color: self color;     line: tmp1 bottomRight - (3 @ 1) to: tmp1 bottomRight - (4 @ 1) width: self width color: self color;     line: tmp1 bottomRight - (5 @ 0) to: tmp1 bottomLeft + (5 @ 0) width: self width color: self color;     line: tmp1 bottomLeft - (-4 @ 1) to: tmp1 bottomLeft - (-3 @ 1) width: self width color: self color;     line: tmp1 bottomLeft - (-2 @ 2) to: tmp1 bottomLeft - (-1 @ 4) width: self width color: self color;     line: tmp1 bottomLeft - (0 @ 5) to: tmp1 topLeft + (0 @ 5) width: self width color: self color;     line: tmp1 topLeft + (1 @ 4) to: tmp1 topLeft + (1 @ 3) width: self width color: self color;     line: tmp1 topLeft + (2 @ 2) to: tmp1 topLeft + (4 @ 1) width: self width color: self colorshowCaret: arg1  showCaret := arg1drawDropShadowOn: arg1  arg1 fillOval: bounds fillStyle: self shadowColor borderWidth: 0 borderColor: nilsecondName  ^secondNamewidth: arg1  self extent: arg1 asInteger @ self heightstepTime  ^250lineColorForNode: arg1  ^lineColorBlock ifNotNil: [ lineColorBlock value: arg1 ] ifNil: [ | tmp1 |        tmp1 := self color isTransparent ifTrue: [ self firstOwnerSuchThat: [:arg2 |  arg2 isWorldOrHandMorph not and: [ arg2 color isTransparent not ] ] ] ifFalse: [ self ].        tmp1 ifNil: [ Color black ] ifNotNil: [ tmp1 color luminance > 0.5 ifTrue: [ Color black ] ifFalse: [ Color white ] ] ]doubleClickSelector  ^doubleClickSelectorproceed: arg1 title: arg2  ^self theme proceedIn: self text: arg1 title: arg2update: arg1  arg1 == self getStateSelector ifTrue: [ self updateSelection.        ^self ].  arg1 == self getEnabledSelector ifTrue: [ self updateEnabled.        ^self ].  arg1 == self getLabelSelector ifTrue: [ self updateLabel.        ^self ].  arg1 isArray ifFalse: [ ^self ].  arg1 size == 2 ifFalse: [ ^self ].  arg1 first = #labelClickable: ifTrue: [ self labelClickable: arg1 second ].  arg1 first = #label: ifTrue: [ self label: arg1 second ]search  ^self optionalOperations ifNotNil: [:arg1 |  arg1 ] ifNil: [ self realSearch ]updateTopHeader  self topHeader ifNotNil: [:arg1 |  | tmp1 |        arg1 width: scroller width.        tmp1 := self headerBounds.        arg1 submorphsDo: [:arg2 |  tmp1 ifNotEmpty: [ arg2                       bounds: tmp1 removeFirst;                       layoutInset: self columnInset @ 0 ] ] ]enableDragNDrop: arg1  self separateDragAndDrop.  self enableDrag: arg1.  self enableDrop: arg1dropFiles: arg1  initialize  super initialize.  selectedItems := OrderedCollection new.  itemsAlreadySelected := OrderedCollection new.  slippage := 0 @ 0type  ^typealert: arg1 title: arg2  ^self alert: arg1 title: arg2 configure: [:arg3 |   ]handlesMouseStillDown: arg1  self eventHandler ifNotNil: [ ^self eventHandler handlesMouseStillDown: arg1 ].  ^falseinitialize  super initialize.  labelString ifNil: [ labelString := 'Untitled Window' ].  isCollapsed := false.  paneMorphs := Array new.  self layoutPolicy: ProportionalLayout new.  self clipSubmorphs: true.  self theme     configureWindowBorderFor: self;     configureWindowDropShadowFor: self.  self initializeLabelArea.  self cellPositioning: #topLeft.  self addGripsIfWanted.  self extent: (300 @ 200) scaledByDisplayScaleFactor.  mustNotClose := false.  updatablePanes := Array newdrawBoundsForRow: arg1  (arg1 between: 1 and: listItems size) ifFalse: [ ^0 @ 0 corner: 0 @ 0 ].  ^(listItems at: arg1) boundsvalueOfProperty: arg1 ifAbsent: arg2  ^extension ifNotNil: [ extension valueOfProperty: arg1 ifAbsent: arg2 ] ifNil: [ arg2 value ]newAlphaSelector: arg1 getAlpha: arg2 setAlpha: arg3 help: arg4  ^self theme newAlphaSelectorIn: self for: arg1 getAlpha: arg2 setAlpha: arg3 help: arg4spotterPreviewMorphIn: arg1  < spotterPreview: 20>  arg1 custom: (self imageForm asAlphaImageMorph asBrick margin: 20)tableRefresh  ^self table refreshisCollapsed  ^isCollapsedchangeRubberBandCells  self rubberBandCells: self rubberBandCells notmouseEnterPagingArea: arg1  pagingArea     fillStyle: self mouseOverFillStyle;     borderStyle: self mouseOverBorderStyle;     changed.  slider     fillStyle: self mouseOverPagingAreaThumbFillStyle;     borderStyle: self mouseOverPagingAreaThumbBorderStyle;     changed.  upButton     fillStyle: self mouseOverPagingAreaButtonFillStyle;     borderStyle: self mouseOverPagingAreaButtonBorderStyle;     changed.  downButton     fillStyle: self mouseOverPagingAreaButtonFillStyle;     borderStyle: self mouseOverPagingAreaButtonBorderStyle;     changedinitialExtent  | tmp1 tmp2 tmp3 |  tmp1 := self getRawLabel.  tmp2 := self mainPanel ifNil: [ 0 @ 0 ] ifNotNil: [:arg1 |  arg1 minExtent ].  tmp3 := tmp2 + (2 @ self labelHeight) + (2 * self class borderWidth) max: tmp1 extent + 20.  self isResizeable ifTrue: [ self title: self title.        self minimumExtent: (tmp3 x max: self minimumExtent x) @ (tmp3 y max: self minimumExtent y) ].  ^tmp3findWindow: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := UIManager default newMenuIn: self for: self.  tmp2 := self windowsSatisfying: [:arg2 |  arg2 isCollapsed not ].  tmp3 := self windowsSatisfying: [:arg2 |  arg2 isCollapsed ].  tmp4 := self submorphsSatisfying: [:arg3 |  arg3 isSystemWindow not ].  (tmp2 isEmpty and: [ tmp3 isEmpty and: [ tmp4 isEmpty ] ]) ifTrue: [ ^self inform: 'No morph in world' ].  (tmp2 asSortedCollection: [:arg4 :arg5 |  arg4 label caseInsensitiveLessOrEqual: arg5 label ]) do: [:arg2 |  tmp1 add: arg2 label target: arg2 selector: #activateAndForceLabelToShow.        arg2 model canDiscardEdits ifFalse: [ tmp1 lastItem color: Color red ] ].  (tmp2 isEmpty or: [ tmp3 isEmpty and: [ tmp4 isEmpty ] ]) ifFalse: [ tmp1 addLine ].  (tmp3 asSortedCollection: [:arg4 :arg5 |  arg4 label caseInsensitiveLessOrEqual: arg5 label ]) do: [:arg2 |  tmp1 add: arg2 label target: arg2 selector: #collapseOrExpand.        arg2 model canDiscardEdits ifFalse: [ tmp1 lastItem color: Color red ] ].  tmp4 isEmpty ifFalse: [ tmp1 addLine ].  (tmp4 asSortedCollection: [:arg4 :arg5 |  arg4 class name caseInsensitiveLessOrEqual: arg5 class name ]) do: [:arg2 |  tmp1 add: arg2 class name target: arg2 selector: #comeToFrontAndAddHalo ].  tmp1 addTitle: 'find window'.  tmp1 popUpEvent: arg1 in: selftestIsAfterColumn  self assert: (strategy is: #(3 7) afterColumn: 4).  self deny: (strategy is: #(3 7) afterColumn: 9).  self deny: (strategy is: #(3 7) afterColumn: 7)lock: arg1  (extension isNil and: [ arg1 not ]) ifTrue: [ ^self ].  self assureExtension locked: arg1defaultChunkSize  ^nilwantsToBeDroppedInto: arg1  ^(arg1 isWorldMorph or: [ submorphs size = 1 ]) or: [ self embeddable ]copyWithoutSubmorph: arg1  ^self shallowCopy privateSubmorphs: (submorphs copyWithout: arg1)mouseLeave: arg1  super mouseLeave: arg1.  (owner notNil and: [ owner isKindOf: EmbeddedMenuMorph ]) ifTrue: [ owner selectedItem == self ifTrue: [ owner selectItem: nil event: arg1 ] ]canExpand  ^complexContents ifNotNil: [ complexContents hasContents ] ifNil: [ false ]morphicLayerNumber  ^7newRightButton  ^(ControlButtonMorph on: self getState: nil action: #scrollTabsRight label: #rightButtonLabel)     getEnabledSelector: #rightButtonEnabled;     hResizing: #rigid;     vResizing: #spaceFill;     cornerStyle: #square;     extent: self controlButtonWidth asPointvisible: arg1  super visible: arg1.  submorphs isEmptyOrNil ifFalse: [ submorphs first visible: arg1 ]apply: arg1  | tmp1 |  tmp1 := target bounds.  target bounds: (tmp1 origin + (arg1 x @ 0) corner: tmp1 corner + (0 @ arg1 y))borderStyle  extension ifNil: [ ^BorderStyle default trackColorFrom: self ].  ^(extension borderStyle ifNil: [ BorderStyle default ]) trackColorFrom: selflastEvent  ^lastMouseEventtrimSize: arg1  trimSize := arg1maxCellSize: arg1  self assureTableProperties maxCellSize: arg1.  self layoutChangedstopStepping: arg1  worldState stopStepping: arg1childrenDo: arg1  firstChild ifNotNil: [ firstChild withSiblingsDo: [:arg2 |  arg1 value: arg2 ] ]showDirectionHandles: arg1 addHandles: arg2  directionArrowAnchor := arg1 ifTrue: [ target referencePositionInWorld ] ifFalse: [ nil ].  arg2 ifTrue: [ self addHandles ]athensDisplay: arg1 atRow: arg2 on: arg3  | tmp1 tmp2 |  tmp2 := self backgroundColorForRow: arg2.  tmp1 := self drawBoundsForRow: arg2.  tmp1 := tmp1 intersect: self bounds ifNone: [ ^self ].  arg1 with: (1 to: arg1 size) do: [:arg4 :arg5 |  arg5 > 1 ifTrue: [ tmp1 := tmp1 left: tmp1 left + listSource gapSize + (columnWidths at: arg5 - 1) ].        arg3 morphicDrawString: arg4 asString at: tmp1 topLeft font: self font color: color ]defaultLabel  ^self printString truncateTo: 40extent: arg1  super extent: arg1.  self updateFillStyletestLastClickedMorphSetUponUpdateList  | tmp1 tmp2 tmp3 |  tmp1 := ClassTreeExample new.  [ tmp2 := tmp1 openOn: Collection.  tmp3 := tmp1 dependents last.  tmp3 expandAll.  tmp1 selectItems: {CharacterSet}.  self assert: tmp3 listManager lastClickedMorph notNil.  tmp1 rootClass: Bag.  tmp1 updateList.  self assert: tmp3 listManager lastClickedMorph isNil.  tmp1 selectItems: {Bag}.  self assert: tmp3 listManager lastClickedMorph notNil ] ensure: [ tmp2 close ]indexFromPosition: arg1  ^arg1rightFlush  self changeAlignment: #rightFlushisMoved  ^trueheightToDisplayInList: arg1  ^self minExtent ynewNoButtonFor: arg1  ^self theme newNoButtonIn: self for: arg1wrapString  ^(wrapFlag ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'text wrap to bounds' translatedasTwoColorStrokePaintOn: arg1  ^AthensBorderStrokePaint topLeftColor: self topLeftColor bottomRightColor: self bottomRightColor width: self width on: arg1headerLabel  ^headerLabelstepTime  ^self subMorph stepTimeballoonText: arg1  balloonText := arg1swapColumnAt: arg1 withColumnAt: arg2  self columns swap: arg1 with: arg2.  self columnsChanged.  self updateList.  self columnResizersToFronttextUpdated: arg1  self searchFor: field getTextFromModelinitialize  super initialize.  drawable := falseembeddedWindowOrNil  ^nilmargins  ^marginsadjacentTo  self owner isFloating ifTrue: [ ^{(self bounds bottomLeft + (3 @ 3)) .         (self bounds bottomRight + (5 @ 3))} ].  self owner isAdheringToTop ifTrue: [ ^{(self bounds bottomLeft + (5 @ 5))} ].  self owner isAdheringToLeft ifTrue: [ ^{(self bounds topRight + (5 @ 5))} ].  self owner isAdheringToBottom ifTrue: [ ^{(self bounds topLeft + (5 @ 5))} ].  self owner isAdheringToRight ifTrue: [ ^{(self bounds topLeft + (5 @ -5))} ].  ^{(self bounds bottomLeft + (3 @ 5))}newLabelGroup: arg1 font: arg2 labelColor: arg3  ^self theme newLabelGroupIn: self for: arg1 font: arg2 labelColor: arg3addMorphInLayer: arg1  super addMorphInLayer: arg1.  arg1 wantsToBeTopmost ifFalse: [ self bringTopmostsToFront ]