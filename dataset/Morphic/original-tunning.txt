pressedImageSelector: anObject  pressedImageSelector := anObjectnewTextEntryFor: aModel getText: getSel setText: setSel help: helpText  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: nil help: helpTextselectedRowIndex  ^self rowIndexFrom: self table selectedIndexhandleAsMouseEnter: anEvent  | asMouseEnterEvent |  asMouseEnterEvent := anEvent asMouseEnter.  enteredMorphs := enteredMorphs contents.  enteredMorphs reverseDo: [:anEnteredMorph |  self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [  ] ]initialize  super initialize.  self     clipLayoutCells: true;     color: Color transparent.  progress := 1.  progressIconMorph := self currentIcon asMorph.  self addMorphBack: progressIconMorph.  self extent: progressIconMorph extentfindExactPathMatchIn: anArray  self withSiblingsDo: [:each |  (each complexContents asString = anArray first or: [ anArray first isNil ]) ifTrue: [ ^each ] ].  ^nilupdateValue  self model ifNotNil: [:m |  self getValueSelector ifNotNil: [:s |  self scaledValue: (m perform: s) ] ]deny: aStringOrText  ^self deny: aStringOrText title: 'Access Denied' translatedstyle  ^stylechoosePage  | choiceList chosen |  choiceList := OrderedCollection new.  self allIntervals doWithIndex: [:assoc :idx |  | choiceString |        choiceString := idx asString , ': ' , (self nodeList at: assoc key) asString , ' ... ' , (self nodeList at: assoc value) asString.        choiceList add: idx -> choiceString ].  chosen := UIManager default chooseFrom: (choiceList collect: [:c |  c value ]) values: (choiceList collect: [:c |  c key ]) lines: nil title: 'Choose a page'.  chosen ifNil: [ ^self ].  self currentPage: chosensentTo: anObject  type == #mouseMove ifTrue: [ ^anObject handleMouseMove: self ].  ^super sentTo: anObjecttaskButtonOf: aMorph  ^self submorphs detect: [:t |  t model = aMorph ] ifNone: [  ]transferHalo: event  target ifNil: [ ^self delete ].  target transferHalo: (event transformedBy: (target transformedFrom: self)) from: targetnewBalloonHelp: aTextStringOrMorph for: aMorph  ^self theme newBalloonHelpIn: self contents: aTextStringOrMorph for: aMorph corner: #bottomLefttopPasteUp  ^self outermostMorphThat: [:m |  m isKindOf: PasteUpMorph ]chooseFileName: title extensions: exts path: path preview: preview  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: title extensions: exts path: path preview: previewretrieveCheckIcon  ^self selected ifTrue: [ self iconNamed: #checkedBoxIcon ] ifFalse: [ self isPartialMatch ifTrue: [ self iconNamed: #partialCheckedBoxIcon ] ifFalse: [ self iconNamed: #uncheckedBoxIcon ] ]activeEnabledOverUpFillStyle: aFillStyle  self stateMap atPath: #(active enabled over up) put: aFillStyle.  self changedisRenderer  ^truescrollToShow: aRectangle  | visibleRect dx dy |  visibleRect := Rectangle origin: scroller offset extent: self innerBounds extent.  dx := aRectangle width < visibleRect width ifTrue: [ visibleRect right - aRectangle right min: 0 max: visibleRect left - aRectangle left ] ifFalse: [ visibleRect left - aRectangle left min: 0 max: visibleRect right - aRectangle right ].  dy := aRectangle height < visibleRect height ifTrue: [ visibleRect bottom - aRectangle bottom min: 0 max: visibleRect top - aRectangle top ] ifFalse: [ visibleRect top - aRectangle top min: 0 max: visibleRect bottom - aRectangle bottom ].  self scrollBy: dx @ dystickinessString  ^self isSticky -> 'resist being picked up' translatedisDefault: aBoolean  aBoolean ifTrue: [ self setProperty: #isDefault toValue: true ] ifFalse: [ self removeProperty: #isDefault ].  self changedmouseEnter: evt  owner ifNotNil: [ owner stayUp ifFalse: [ self mouseEnterDragging: evt ] ].  (owner selectedItem notNil and: [ owner selectedItem ~~ self ]) ifTrue: [ owner selectItem: self event: evt ]yellowButtonChanged  ^whichButton anyMask: self class yellowButtonisAlignmentMorph  ^truecleanseStepList  worldState cleanseStepListForWorld: selfisResized  ^trueadd: aString subMenu: aMenuMorph  self add: aString icon: nil subMenu: aMenuMorphselectedBorderStyle  ^self theme buttonSelectedBorderStyleFor: selfexpandAll: aMorph  | allChildren |  aMorph toggleExpandedState.  allChildren := OrderedCollection new: 10.  aMorph recursiveAddTo: allChildren.  allChildren do: [:each |  (each canExpand and: [ each isExpanded not ]) ifTrue: [ self expandAll: each ] ]getList  getListSelector ifNil: [ ^#() ].  list := model perform: getListSelector.  list ifNil: [ ^#() ].  list := list collectWithIndex: [:item :index |  self itemMorphFor: item index: index ].  ^listinitialize  super initialize.  manager := TabManagerMorph new.  manager when: #tabManagerDeleted send: #delete to: self.  listModel := SpListPresenter new.  listModel items: (1 to: 1000) asOrderedCollectionrowColorForEven: evenColor odd: oddColor  rowColors at: 2 put: oddColor.  rowColors at: 1 put: evenColormouseUp: evt  evt hand mouseFocus == owner ifFalse: [ ^self ].  self contentString ifNotNil: [ self contents: self contentString withMarkers: true inverse: true.        self refreshWorld.        (Delay forMilliseconds: 200) wait ].  owner rootMenu selectItem: nil event: evt.  self invokeWithEvent: evtdisplay: aBlock  displayBlock := aBlockcontentHolder  ^self submorphs firstmouseDown: anEvent  | selectors |  selectors := Array with: #click: with: nil with: nil with: (self dragEnabled ifTrue: [ #startDrag: ] ifFalse: [ nil ]).  anEvent hand waitForClicksOrDrag: self event: anEvent selectors: selectors threshold: 10.  super mouseDown: anEventnewImage: aForm  ^self theme newImageIn: self form: aFormchooseStyle  self editor changeStyle.  self updateFromParagraphsolidLabelMorph: anObject  solidLabelMorph := anObjectnewRadioButtonFor: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpText  ^self theme newRadioButtonIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: enabledSel label: stringOrText help: helpTextquantum: aNumber  (self sliderMorph ifNil: [ ^self ]) quantum: aNumbercompose: t style: ts from: startingIndex in: textContainer  text := t.  textStyle := ts.  firstCharacterIndex := startingIndex.  offsetToEnd := text size - firstCharacterIndex.  container := textContainer.  self composeAllopen  ^self openOn: ObjectmouseDownInDimissHandle: evt with: dismissHandle  evt hand obtainHalo: self.  self removeAllHandlesBut: dismissHandle.  self setColor: Color darkGray toHandle: dismissHandlelastClickedMorph: aNodeMorph  lastClickedMorph ifNotNil: [ lastClickedMorph complexContents lastClicked: false ].  lastClickedMorph := aNodeMorph.  aNodeMorph ifNotNil: [ aNodeMorph complexContents lastClicked: true ]askBeforeChanging: aBoolean  askBeforeChanging := aBooleanheading  ^self owner ifNil: [ self forwardDirection ] ifNotNil: [ self forwardDirection + self owner degreesOfFlex ]setButtonFont: aFont  | buttons e |  buttons := self buttons.  e := 0 @ 0.  buttons do: [:b |  | hRes vRes |        hRes := b hResizing.        vRes := b vResizing.        b           hResizing: #shrinkWrap;           vResizing: #shrinkWrap.        b label: b label font: aFont.        e := e max: b minExtent.        b           hResizing: hRes;           vResizing: vRes ].  buttons do: [:b |  b extent: e ]borderForm  | borderCanvas |  borderForm ifNotNil: [ ^borderForm ].  borderCanvas := (Display defaultCanvasClass extent: bounds extent depth: 1) asShadowDrawingCanvas: Color black.  borderCanvas translateBy: bounds topLeft negated during: [:tempCanvas |  self drawBorderOn: tempCanvas ].  borderForm := borderCanvas form.  self arrowForms do: [:f |  borderForm copy: f boundingBox from: f to: f offset - self position rule: Form erase ].  ^borderFormtestTop  | morph factor newTop newBounds |  morph := Morph new.  factor := 10.  newTop := self defaultTop + factor.  newBounds := self defaultBounds translateBy: 0 @ factor.  morph top: newTop.  self     assert: morph top equals: newTop;     assert: morph bounds equals: newBoundsaddDependent: anObject  self announcer when: MorphChanged , MorphChangedWithArguments send: #handleUpdate: to: anObject.  ^anObjectascendingSortFunction  ^self sortFunctionclose  closeable ifFalse: [ ^self ].  self okToClose ifFalse: [ ^self ].  self deletetoggleAutoGradient  self autoGradient: self autoGradient notselector: aSymbol  selector := aSymbolfileNames: anObject  fileNames := anObjectisSimple  ^self isMultiple notdrawMeOn: aCanvas  | viewedMorphBox scale c shrunkForm aWorld aFormOrMorph |  super drawOn: aCanvas.  (aFormOrMorph := self formOrMorphToView) isForm ifTrue: [ ^self drawForForm: aFormOrMorph on: aCanvas ].  (((aFormOrMorph notNil and: [ (aWorld := aFormOrMorph world) notNil ]) and: [ aWorld ~~ aFormOrMorph or: [ lastFormShown isNil ] ]) and: [ RecursionDepth + 1 < RecursionMax ]) ifTrue: [ RecursionDepth := RecursionDepth + 1.        viewedMorphBox := aFormOrMorph fullBounds.        scale := self scaleFor: viewedMorphBox in: self innerBounds.        c := Display defaultCanvasClass extent: viewedMorphBox extent depth: aCanvas depth.        c translateBy: viewedMorphBox topLeft negated during: [:tempCanvas |  tempCanvas fullDrawMorph: aFormOrMorph ].        shrunkForm := c form magnify: c form boundingBox by: scale smoothing: 1.        lastFormShown := shrunkForm.        RecursionDepth := RecursionDepth - 1 ] ifFalse: [ lastFormShown ifNotNil: [ shrunkForm := lastFormShown ] ].  shrunkForm ifNotNil: [ aCanvas paintImage: shrunkForm at: self center - shrunkForm boundingBox center ]drawDashedBorderOn: aCanvas usingEnds: anArray  | bevel topLeftColor bottomRightColor bigClipRect lineColor segmentOffset |  (borderColor isNil or: [ borderColor isColor and: [ borderColor isTransparent ] ]) ifTrue: [ ^self ].  lineColor := borderColor.  bevel := false.  borderColor == #raised ifTrue: [ topLeftColor := color lighter.        bottomRightColor := color darker.        bevel := true ].  borderColor == #inset ifTrue: [ topLeftColor := owner colorForInsets darker.        bottomRightColor := owner colorForInsets lighter.        bevel := true ].  bigClipRect := aCanvas clipRect expandBy: (self borderWidth + 1) // 2.  segmentOffset := self borderDashOffset.  self lineSegmentsDo: [:p1 :p2 |  | p2i p1i |        p1i := p1 asIntegerPoint.        p2i := p2 asIntegerPoint.        self hasArrows ifTrue: [ ((arrows == #back or: [ arrows == #both ]) and: [ p1 = vertices first ]) ifTrue: [ p1i := anArray first asIntegerPoint ].              ((arrows == #forward or: [ arrows == #both ]) and: [ p2 = vertices last ]) ifTrue: [ p2i := anArray last asIntegerPoint ] ].        (closed or: [ ((p1i min: p2i) max: bigClipRect origin) <= ((p1i max: p2i) min: bigClipRect corner) ]) ifTrue: [ bevel ifTrue: [ lineColor := (p1i quadrantOf: p2i) > 2 ifTrue: [ topLeftColor ] ifFalse: [ bottomRightColor ] ].              segmentOffset := aCanvas line: p1i to: p2i width: borderWidth color: lineColor dashLength: borderDashSpec first secondColor: borderDashSpec third secondDashLength: borderDashSpec second startingOffset: segmentOffset ] ]protocolColumn: column row: rowIndex  ^FTCellMorph new     color: (self colorFor: rowIndex);     addMorph: (self elementAt: rowIndex) protocol asStringMorph;     yourselfballoonHelpAligner  ^(self valueOfProperty: #balloonTarget) ifNil: [ self ]mouseLeave: anEvent  anEvent hand showTemporaryCursor: nil.  self setDefaultColors.  self shouldInvalidateOnMouseTransition ifTrue: [ self changed ]adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self pager ifNotNil: [:p |  p color: self pagerColor ]registerShortcuts  self     bindKeyCombination: $] meta shift toAction: [ self selectNext ];     bindKeyCombination: $[ meta shift toAction: [ self selectPrevious ];     bindKeyCombination: $w command toAction: [ self deleteSelectedTabs ];     bindKeyCombination: $w command shift toAction: [ self closeAllTabs ].  1 to: 9 do: [:index |  self bindKeyCombination: index asString first meta toAction: [ self selectTabAt: index ] ].  self bindKeyCombination: $0 meta toAction: [ self selectLastTab ]listRenderOn: aCanvas atRow: aRow bounds: drawBounds color: drawColor backgroundColor: backgroundColor from: aMorph  self color: backgroundColor.  self bounds: drawBounds.  self fullDrawOn: aCanvas.  aMorph addMorph: selfshortcutsHandler  ^ShortcutsHandlerfractions: fractionsOrNil  self deprecated: 'Do not use this method. It forces to create spurious objects for nothing.'.  ^self fractions: fractionsOrNil offsets: nilcolorsAtCorners  | c c14 c23 |  c := self color.  c14 := c lighter.  c23 := c darker.  ^Array with: c23 with: c14 with: c14 with: c23addLastTabContents: aTab among: size delta: delta  | process |  process := aTab retrieveMorph: [:contents |  contents ifNil: [ TabWithNoContents signalTab: aTab ].        contentsWrapper addMorph: contents fullFrame: (LayoutFrame identity                 leftFraction: (size - 1) * delta;                 leftOffset: 2;                 rightFraction: 1) ].  process ifNotNil: [ processes add: process ]newMenu  ^self theme newMenuIn: self for: selfforceRefreshOnNextChange  lastRefresh := 0newIncrementalSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newIncrementalSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpTextmouseUp: event  (event commandKeyPressed or: [ event controlKeyPressed ]) ifTrue: [ self toggleSelection ] ifFalse: [ event shiftPressed ifTrue: [ self selectToMe ] ifFalse: [ self selected: true ] ]newToolbar  ^self theme newToolbarIn: selfautoDeselect: trueOrFalse  autoDeselect := trueOrFalseclippingRectangle  ^self innerBoundsareasRemainingToFill: aRectangle  ^Array with: aRectanglekeepsTransform  ^falsemouseEnterDownButton: event  downButton     fillStyle: self mouseOverButtonFillStyle;     borderStyle: self mouseOverButtonBorderStyle;     changedwindowIndex: aValue  windowIndex := aValueexpandRoots  self requestView: MorphTreeChangeRequest expandRootskeyStroke: evt  super keyStroke: evt.  (self defaultButton notNil and: [ evt keyCharacter = Character cr ]) ifTrue: [ self returnPressed.        ^true ].  evt keyCharacter = Character escape ifTrue: [ self escapePressed.        ^true ].  ^falseaddToSelection: aMorph clickedTheCheckBox: checkBox  aMorph selected ifTrue: [ ^false ].  self searchedElement: nil.  checkBox ifFalse: [ aMorph highlight ].  aMorph selected: true.  ^truetestAthensRender  | surf |  surf := AthensCairoSurface extent: Display extent.  surf drawDuring: [:can |  self fullDrawOnAthensCanvas: can ].  Display getCanvas drawImage: surf asForm at: 0 @ 0firstNameMorph  ^(self theme newTextEntryIn: self currentWorld for: self get: #firstName set: #firstName: class: String getEnabled: nil help: nil) color: Color transparentresizeContainerFrom: topLefPoint to: bottomRightPoint  self subclassResponsibilityaddResizeSplitters  | columnWidths nextColumn delta |  columnWidths := self calculateColumnWidths.  nextColumn := self left.  delta := FTColumnResizerMorph resizerWidth / 2.  self table columns overlappingPairsWithIndexDo: [:leftColumn :rightColumn :index |  nextColumn := nextColumn + (columnWidths at: index) + self table intercellSpacing x.        self addMorph: ((FTColumnResizerMorph container: self left: (FTDisplayColumn column: leftColumn width: (columnWidths at: index)) right: (FTDisplayColumn column: rightColumn width: (columnWidths at: index + 1)))                 bounds: ((nextColumn - delta) @ self top extent: delta @ self height);                 color: Color transparent;                 yourself) ]increment  self value: self value + self quantumsetCurveBaseline: evt  | handle origin |  origin := evt cursorPoint.  handle := HandleMorph new forEachPointDo: [:newPoint |  handle removeAllMorphs.        handle addMorph: (PolygonMorph vertices: (Array with: origin with: newPoint) color: Color black borderWidth: 1 borderColor: Color black).        container baseline: (newPoint - origin) y negated asInteger // 5.        self paragraph composeAll ].  evt hand attachMorph: handle.  handle startSteppinghandleMouseStillDown: anEvent  anEvent hand mouseFocus == self ifFalse: [ ^self stopSteppingSelector: #handleMouseStillDown: ].  self mouseStillDown: anEvent.  ^self eventHandler ifNotNil: [:handler |  handler mouseStillDown: anEvent fromMorph: self ]initialRootItems  ^initialRootItems ifNil: [ initialRootItems := #() ]chooseEmphasis  self editor changeEmphasis.  self updateFromParagraphhideRightOrBottom  self hide.  rightOrBottom do: [:m |  m hide ]rowColorForEven: evenColor  rowColors at: 1 put: evenColorremind: aMenuItem  | itemHash |  itemHash := (aMenuItem contents hash + aMenuItem keyText hash) hashMultiply.  (self wantsToShow: itemHash) ifFalse: [ ^self ].  self     show: aMenuItem;     updateCount: itemHashtheme  ^Smalltalk ui themeinsertVertexAt: anIndex put: aValue  self setVertices: (vertices copyReplaceFrom: anIndex + 1 to: anIndex with: (Array with: aValue))orderedTasks: aCollection  tasks := aCollectiondoubleClick: event  self isResizeable ifTrue: [ super doubleClick: event ]selectionFillStyle  Display depth <= 2 ifTrue: [ ^Color gray ].  ^self theme menuSelectionColornavigateFocusBackward  self previousMorphWantingFocus ifNotNil: [:m |  m takeKeyboardFocus ]viewBox: newViewBox  super position: newViewBox topLeft.  fullBounds := bounds := newViewBoxnewStateForSelected: aBoolean  self assert: aBoolean.  ^TabSelected tab: self tabsearchedElement  ^searchedElementenable  self enabled: truehTotalScrollRange  ^self hUnadjustedScrollRange + self hExtraScrollRange + self hMarginhScrollbarInterval  ^self scrollBounds width asFloat / self scrollTarget width min: 1.0update: aSymbol  super update: aSymbol.  aSymbol = self getImageSelector ifTrue: [ self updateImage ]handleBasicKeys: aBoolean  handlesBasicKeys := aBooleandisplayExtraSelectionOnAthensCanvas: anAthensCanvas  | visibleRectangle |  visibleRectangle := anAthensCanvas clipRect.  refreshExtraSelection = true ifTrue: [ self buildSelectionBlocksFrom: visibleRectangle topLeft to: visibleRectangle bottomRight.        refreshExtraSelection := false ].  extraSelectionBlocks ifNotNil: [ self forLinesIn: visibleRectangle do: [:line |  extraSelectionBlocks do: [:selblock |  self displaySelectionBlock: selblock inLine: line onAthensCanvas: anAthensCanvas ] ] ]seasideMimeDocumentType: aMimeType  ^self imageForm seasideMimeDocumentType: aMimeTypenewListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: enabledSel help: helpText  ^self theme newListIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelector getEnabled: enabledSel help: helpTextlist: aCollection  | wereExpanded morphList |  wereExpanded := self currentlyExpanded.  scroller removeAllMorphs.  (aCollection isNil or: [ aCollection isEmpty ]) ifTrue: [ ^self selectedMorph: nil ].  morphList := OrderedCollection new.  self addMorphsTo: morphList from: aCollection allowSorting: false withExpandedItems: wereExpanded atLevel: 0.  self insertNewMorphs: morphListaddBlankIconsIfNecessary: anIcon  self items reject: [:each |  each hasIconOrMarker ] thenDo: [:each |  each icon: anIcon ]doLayoutIn: layoutBounds  | box priorBounds |  priorBounds := self outerBounds.  submorphs isEmpty ifTrue: [ ^fullBounds := priorBounds ].  submorphs do: [:m |  m ownerChanged ].  self layoutPolicy ifNotNil: [:layout |  layout layout: self in: layoutBounds ].  self adjustLayoutBounds.  fullBounds := self privateFullBounds.  box := self outerBounds.  box = priorBounds ifFalse: [ self invalidRect: (priorBounds quickMerge: box) ]openInWorld  super openInWorld.  self width: 200.  self resizekeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  aBoolean ifTrue: [ (self ownerThatIsA: GeneralScrollPane) ifNotNil: [:sp |  sp scrollToShow: self bounds ] ] ifFalse: [ self selectItem: nil event: nil ]getFiltering: matchString  ^self valueOfProperty: #matchString ifAbsentPut: [ String new ]selectInvisiblyFrom: start to: stop  editor ifNotNil: [ editor selectInvisiblyFrom: start to: stop ]indentLevel  ^indentLevelpreferedFont  ^self balloonFontscrollRestrictedDown: aValue  self canScrollDown ifFalse: [ ^self ].  self scrollDown: aValueon: anObject getValue: getSel setValue: setSel  self     model: anObject;     getValueSelector: getSel;     setValueSelector: setSel;     updateValueisCenter  ^self option == #centerupdateBounds  self updateExtent.  self isFloating ifFalse: [ self updatePosition ]getListItem: index  ^listSource getListItem: indexstartStepping: aMorph at: scheduledTime selector: aSelector arguments: args stepTime: stepTime  self stopStepping: aMorph selector: aSelector.  self adjustWakeupTimesIfNecessary.  stepList add: (StepMessage scheduledAt: scheduledTime stepTime: stepTime receiver: aMorph selector: aSelector arguments: args)stopSteppingSelfAndSubmorphs  self allMorphsDo: [:m |  m stopStepping ]listRenderOn: aCanvas atRow: aRow bounds: drawBounds color: drawColor backgroundColor: backgroundColor from: aMorph  self bounds: drawBounds.  self fullDrawOn: aCanvas.  (aMorph submorphs includes: self) ifFalse: [ aMorph addMorph: self ]form  ^imageformerOwner: aMorphOrNil  aMorphOrNil ifNil: [ self removeProperty: #formerOwner ] ifNotNil: [ self setProperty: #formerOwner toValue: aMorphOrNil ]waitForClicksOrDrag: aMorph event: evt selectors: clickAndDragSelectors threshold: threshold  mouseClickState := MouseClickState new client: aMorph click: clickAndDragSelectors first dblClick: clickAndDragSelectors second dblClickTime: DoubleClickTime dblClickTimeout: clickAndDragSelectors third drag: clickAndDragSelectors fourth threshold: threshold event: evthasFilter  function ifNil: [ ^false ].  ^function isKindOf: FTFilterFunctionsetConstrainedPosition: aPoint hangOut: partiallyOutside  | trialRect delta boundingMorph bRect |  owner ifNil: [ ^self ].  trialRect := aPoint extent: self bounds extent.  boundingMorph := self topRendererOrSelf owner.  delta := boundingMorph ifNil: [ 0 @ 0 ] ifNotNil: [ bRect := partiallyOutside ifTrue: [ boundingMorph bounds insetBy: self extent negated + boundingMorph borderWidth + (2 @ 2) ] ifFalse: [ boundingMorph bounds ].        trialRect amountToTranslateWithin: bRect ].  self position: aPoint + delta.  self layoutChangedfastAnimateRectangles: rects  | delay col merged |  rects ifEmpty: [ ^self ].  delay := Delay forMilliseconds: self theme animationSettings delay.  col := Color gray alpha: 0.5.  merged := rects first.  rects withIndexDo: [:r :i |  Display border: r rounded width: 1 rule: Form blend fillColor: col.        merged := merged merge: r.        delay wait ].  merged := merged expandBy: 1.  self currentWorld invalidRect: merged from: selfsubMenuMarker  owner isFloating ifTrue: [ ^self bottomArrow ].  owner isAdheringToTop ifTrue: [ ^self bottomArrow ].  owner isAdheringToBottom ifTrue: [ ^self upArrow ].  owner isAdheringToLeft ifTrue: [ ^self rightArrow ].  owner isAdheringToRight ifTrue: [ ^self leftArrow ].  ^self rightArrowis: anIndex aboveRow: aRowIndex  ^anIndex first < aRowIndexpageMorphs  ^pageMorphsdrawOn: aCanvas  super drawOn: aCanvas.  icon ifNil: [ ^self ].  icon form ifNil: [ ^self ].  aCanvas translucentImage: icon form at: self topLeftkeyStroke: anEvent  super keyStroke: anEvent.  self selectedObject ifNotNil: [:selected |  selected moveOrResizeFromKeystroke: anEvent ].  self dispatchKeystroke: anEventwrapDirection  ^wrapDirectionhasYellowButtonMenu  ^self wantsYellowButtonMenu or: [ model ifNil: [ false ] ifNotNil: [:aModel |  aModel hasModelYellowButtonMenuItems ] ]hExtraScrollRange  ^self scrollDeltaWidthgetListElementSelector  ^getListElementSelectorchildren  ^children ifNil: [ children := self calculateChildren ]veryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  target := deepCopier references at: target ifAbsent: [ target ].  innerTarget := deepCopier references at: innerTarget ifAbsent: [ innerTarget ]contentsClipped: aString  contents = aString ifTrue: [ ^self ].  contents := aString.  self changedicon: aForm  icon ifNotNil: [ icon delete ].  icon := aForm asMorph.  closeBox ifNotNil: [ ^self addMorph: icon after: closeBox ].  self addMorphFront: iconjustDroppedInto: aMorph event: anEvent  | aWindow |  (self formerOwner notNil and: [ self formerOwner ~~ aMorph ]) ifTrue: [ self removeHalo ].  self formerOwner: nil.  self formerPosition: nil.  (aWindow := aMorph ownerThatIsA: SystemWindow) ifNotNil: [ aWindow isActive ifFalse: [ aWindow activate ] ].  (self hasProperty: #beFullyVisibleAfterDrop) ifTrue: [ aMorph == self currentWorld ifTrue: [ self goHome ].        self removeProperty: #beFullyVisibleAfterDrop ]hasContentToShow  ^self complexContents hasContentToShownewMenuFor: aModel  ^self theme newMenuIn: self for: aModelinitialize  super initialize.  self layoutPolicy: TableLayout new.  self     listDirection: #leftToRight;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: 3;     cellInset: 3;     wrapCentering: #center;     cellPositioning: #leftCenter.  self borderStyle: (BorderStyle width: 1 color: Color lightGray).  accepted := false.  copy := false.  self on: #keyStroke send: #keyStroke: to: selftestTransformReturnEmptyRectangleWhenNotPossibleToPlace  | lf rectangle refRectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  refRectangle := 0 @ 0 extent: 10 @ 10.  rectangle := lf transform: refRectangle.  self assert: rectangle width equals: 0.  self assert: rectangle height equals: 0isCheckList: aBoolean  ^isCheckList := aBoolean= line  self species = line species ifTrue: [ ^((firstIndex = line first and: [ lastIndex = line last ]) and: [ internalSpaces = line internalSpaces ]) and: [ paddingWidth = line paddingWidth ] ] ifFalse: [ ^false ]blackGradient  ^(InterpolatedGradientFillStyle colors: {(Color black alpha: 0) .         Color black})     origin: self innerBounds topLeft;     direction: 0 @ self innerBounds heightwindowEvent: anEvent  self windowEventHandler ifNotNil: [ ^self windowEventHandler windowEvent: anEvent ].  (anEvent type == #windowClose and: [ self valueOfProperty: #canOpenCloseDialog ifAbsent: true ]) ifTrue: [ self setProperty: #canOpenCloseDialog toValue: false.        WorldState quitSession.        self removeProperty: #canOpenCloseDialog ]balloonTextSelector  ^balloonTextSelectortotalSliderArea  | upperBoundsButton |  upperBoundsButton := upButton.  bounds isWide ifTrue: [ upButton right > upperBoundsButton right ifTrue: [ upperBoundsButton := upButton ].        ^upperBoundsButton bounds topRight corner: downButton bounds bottomLeft ] ifFalse: [ upButton bottom > upperBoundsButton bottom ifTrue: [ upperBoundsButton := upButton ].        ^upperBoundsButton bounds bottomLeft corner: downButton bounds topRight ]selector  ^self itemhScrollbarValue  | tw sw v |  tw := self scrollTarget width.  sw := self scrollBounds width.  v := tw - sw max: 0.  v = 0 ifFalse: [ v := self scroller offset x asFloat / v min: 1.0 ].  ^vshowIndex  ^showIndexinsertCharacters: aSource  | aLoc |  aLoc := self cursor max: 1.  paragraph replaceFrom: aLoc to: aLoc - 1 with: aSource asText displaying: true.  self updateFromParagraphchanged: anAspect  self doAnnounce: (MorphChanged new           morph: self;           selector: anAspect)isExpanded  ^truemouseLeaveIcon  closeable ifFalse: [ ^self ].  fadeOut ifNotNil: [ fadeOut terminate ].  fadeOut := [ closeIcon image: self class closeHalfOverIcon.  50 milliSeconds asDelay wait.  closeIcon image: self class closeIcon ] forkcloseable: anObject  closeable := anObject.  anObject ifTrue: [ self showCloseIcon ] ifFalse: [ self hideCloseIcon ]setUnlockedIcon  closeIcon image: self class closeIconfontName: fontName size: fontSize  | newTextStyle |  newTextStyle := ((TextStyle named: fontName asSymbol) ifNil: [ TextStyle default ]) copy.  textStyle := newTextStyle.  text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOfSize: fontSize)).  paragraph ifNotNil: [ paragraph textStyle: newTextStyle ]gapAfterToggle: anInteger  gapAfterToggle := anIntegercalculateChildren  ^self getChildren collect: [:elem |  (self class data: elem from: dataSource)           depth: self depth + 1;           yourself ]initialize  super initialize.  self fillStyle: self fillStyleToUse.  self borderStyle: self borderStyleToUsemakeUnclosable  mustNotClose := true.  self deleteCloseBoxstopStepping: aMorph  lastStepMessage ifNotNil: [ lastStepMessage receiver == aMorph ifTrue: [ lastStepMessage := nil ] ].  stepList removeAll: (stepList select: [:stepMsg |  stepMsg receiver == aMorph ])addDropShadow  self hasDropShadow ifTrue: [ ^self ].  self changed.  self hasDropShadow: true.  self shadowOffset: 3 @ 3.  self layoutChanged.  self changedmouseOverFillStyle  ^self theme buttonMouseOverFillStyleFor: selfundoTypeIn: aText interval: anInterval  self handleEdit: [ self editor undoTypeIn: aText interval: anInterval ]morphsInFrontOf: someMorph overlapping: aRectangle do: aBlock  self handsDo: [:m |  m == someMorph ifTrue: [ owner ifNil: [ ^self ].              ^owner morphsInFrontOf: self overlapping: aRectangle do: aBlock ].        m needsToBeDrawn ifTrue: [ (m fullBoundsInWorld intersects: aRectangle) ifTrue: [ aBlock value: m ] ] ].  ^super morphsInFrontOf: someMorph overlapping: aRectangle do: aBlockicon  ^iconenable  self enabled: trueheading  | rendee |  ^(rendee := self renderedMorph) == self ifTrue: [ 0.0 ] ifFalse: [ rendee heading ]newCancelButton  ^self newCancelButtonFor: selftransformVerticesFrom: oldOwner to: newOwner  | oldTransform newTransform world newVertices |  world := self world.  oldTransform := oldOwner ifNil: [ IdentityTransform new ] ifNotNil: [ oldOwner transformFrom: world ].  newTransform := newOwner ifNil: [ IdentityTransform new ] ifNotNil: [ newOwner transformFrom: world ].  newVertices := vertices collect: [:ea |  newTransform globalPointToLocal: (oldTransform localPointToGlobal: ea) ].  self setVertices: newVerticesmultiComposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY  | newResult |  newResult := self composer multiComposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY textStyle: textStyle text: text container: container wantsColumnBreaks: wantsColumnBreaks == true.  lines := newResult first asArray.  ^maxRightX := newResult secondtestSelectableIndexBellow  self subclassResponsibilitycornerRadius  ^5handlesKeyUp: evt  ^self existsSubscriptionsFor: #keyUpwantsYellowButtonMenu  ^self defaultYellowButtonMenuEnabledarguments: anArray  arguments := anArrayhMargin  ^3baseColor: aColor  | cc |  cc := aColor isTransparent ifTrue: [ nil ] ifFalse: [ aColor ].  baseColor = cc ifTrue: [ ^self ].  baseColor := cc.  self releaseCachedState.  self color: cchasContents  ^model hasNodeContents: selfselectItems: aListOfItems  self selection: nil.  self requestView: (MorphTreeChangeRequest selectItems: aListOfItems)getEnabledSelector: anObject  getEnabledSelector := anObject.  self updateEnabledtestSelectableIndexBellow  self assert: (strategy selectableIndexBellow: #(2 3)) equals: #(3 3)mouseOverFillStyle  ^self theme taskbarItemMouseOverFillStyleFor: selfcreateResetCountButtonMorph  ^SimpleButtonMorph new     target: self;     label: 'Reset notification counts';     actionSelector: #resetCount;     themeChanged;     yourselfborderColor: colorOrSymbolOrNil  self doesBevels ifFalse: [ colorOrSymbolOrNil isColor ifFalse: [ ^self ] ].  borderColor = colorOrSymbolOrNil ifFalse: [ borderColor := colorOrSymbolOrNil.        self changed ]topOffset: anInteger  topOffset := anIntegerminCellSize  | props |  props := self layoutProperties.  ^props ifNil: [ 0 ] ifNotNil: [ props minCellSize ]initialize  offset := 1.  alpha := 0.5.  super initializemouseMove: evt  evt redButtonPressed ifFalse: [ ^super mouseMove: evt ].  self selectColorAt: evt position.  ^super mouseMove: evtresizeMorph: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self extent: newPoint - self bounds topLeft ].  evt hand attachMorph: handle.  handle startSteppingwantsDropSelector  ^wantsDropSelectoraddExpandBox  labelArea ifNil: [ ^self ].  expandBox := self createExpandBox.  self setExpandBoxBalloonText.  expandBox layoutFrame: (LayoutFrame new           leftFraction: 1;           leftOffset: (self boxExtent x * 2 + 3) negated).  labelArea addMorphBack: expandBoxbuttons  ^{self firstSubmorph .   self lastSubmorph}dialogWindowIn: aWindow title: aTitle selectedtems: aCollection  | dialog dialogMorph |  dialog := self theme newPluggableDialogWindowIn: aWindow title: aTitle for: (dialogMorph := self defaultMorphIn: aWindow).  dialogMorph     buildContents;     selectedItems: aCollection.  dialog minimumExtent: 300 @ 500.  dialog beResizeable.  ^dialogenabled: anObject  enabled := anObject.  self changedadjustedFirstCharacterIndex  offsetToEnd ifNil: [ ^-1 ].  ^text size - offsetToEndvertices  ^verticesautoMultiSelection: aBoolean  autoMultiSelection := aBoolean.  aBoolean ifTrue: [ self multipleSelection: true ]enabledString  ^self enabled -> 'enabled' translatedforwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]borderWidth  ^borderWidthposition  ^bounds topLeft= aMorphicEvent  super = aMorphicEvent ifFalse: [ ^false ].  position = aMorphicEvent position ifFalse: [ ^false ].  buttons = aMorphicEvent buttons ifFalse: [ ^false ].  ^truebuildYellowButtonMenu: aHand  | menu |  menu := UIManager default newMenuIn: self for: self.  self addNestedYellowButtonItemsTo: menu event: ActiveEvent.  ^menuangle  ^transform anglelabelMorph  ^labelMorphdoGrab: evt with: grabHandle  self obtainHaloForEvent: evt andRemoveAllHandlesBut: grabHandle.  evt hand grabMorph: target.  self step.  evt hand addMouseListener: selfdrawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: aCanvas ]pressedFillStyle  ^self theme windowEdgePressedFillStyleFor: selfinitialize  super initialize.  emphasis := 0.  indent := 0.  kern := 0.  fontNumber := 1.  actualFont := TextStyle defaultFontbasicLabel  ^labelselection  ^selectioncontentsOfNode: node  | children |  getChildrenSelector ifNil: [ ^#() ].  children := model perform: getChildrenSelector with: node item.  ^children collect: [:item |  PluggableTreeItemNode with: item model: self ]initialize  super initialize.  value := 0.  start := 0.  end := 100.  height := DefaultHeight.  width := DefaultWidth.  cachedWidth := 0.  self     fillStyle: (self theme progressBarFillStyleFor: self);     borderStyle: (self theme progressBarBorderStyleFor: self);     barFillStyle: (self theme progressBarProgressFillStyleFor: self);     extent: width @ height + (2 * self borderWidth)extent: newExtent  | scrollbarChange |  bounds extent = newExtent ifTrue: [ ^self ].  super extent: newExtent.  scrollbarChange := (self vScrollbarShowing = self vScrollbarNeeded) not.  scrollbarChange := scrollbarChange or: [ (self hScrollbarShowing = self hScrollbarNeeded) not ].  self updateScrollbars.  scrollbarChange ifFalse: [ self resizeScroller ]insertNewMorphs: morphList  scroller addAllMorphs: morphList.  self adjustSubmorphPositions.  self selection: self getCurrentSelectionItem.  self setScrollDeltasupdateLayoutProperties  (self isHorizontal or: [ self isFloating ]) ifTrue: [ self listDirection: #leftToRight ] ifFalse: [ self listDirection: #topToBottom ].  self hResizing: #shrinkWrap.  self vResizing: #shrinkWrap.  self fillsOwner ifTrue: [ self isHorizontal ifTrue: [ self hResizing: #spaceFill ].        self isVertical ifTrue: [ self vResizing: #spaceFill ] ]containerColor  ^self theme lightBaseColoraddItemShowing: aJob  lock critical: [ | item items |        item := JobProgressMorph job: aJob.        items := self bars size.        items < 10 ifTrue: [ self addMorphBack: item.              self resize ].        ^item ]boundingBoxOfSubmorphs  | aBox visibleSubmorphs |  visibleSubmorphs := submorphs select: [:m |  m visible ].  visibleSubmorphs ifEmpty: [ ^bounds origin extent: self minimumExtent ].  aBox := visibleSubmorphs first fullBounds.  visibleSubmorphs allButFirst do: [:m |  aBox := aBox quickMerge: m fullBounds ].  ^aBoxnewButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel labelForm: aForm help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel label: (AlphaImageMorph new image: aForm) help: helpTextperformAction  self performAction: nilresizeField  | topLeft bottomRight |  self flag: #pharoTodo.  topLeft := table bounds left @ (table bounds bottom - self fieldHeigh - table horizontalScrollBarHeight).  bottomRight := (table bounds right - table verticalScrollBarWidth - (actionButton width + 5)) @ (table bottom - table horizontalScrollBarHeight).  field bounds: (topLeft corner: bottomRight)updateData  self rootItem updateData.  self tableRefreshwrapCentering  | props |  props := self layoutProperties.  ^props ifNil: [ #topLeft ] ifNotNil: [ props wrapCentering ]clearArea  | visTop visBottom visLeft visRight |  visTop := self top.  visBottom := self bottom.  visLeft := self left.  visRight := self right.  self dockingBars do: [:each |  (each isAdheringToTop and: [ each bottom > visTop ]) ifTrue: [ visTop := each bottom ].        (each isAdheringToBottom and: [ each top < visBottom ]) ifTrue: [ visBottom := each top ].        (each isAdheringToLeft and: [ each right > visLeft ]) ifTrue: [ visLeft := each right ].        (each isAdheringToRight and: [ each left < visRight ]) ifTrue: [ visRight := each left ] ].  ^Rectangle left: visLeft right: visRight top: visTop bottom: visBottomminHeight  ^self vResizing = #shrinkWrap ifTrue: [ self scrollTarget minExtent y + self scrollbarThickness + 5 ] ifFalse: [ super minHeight ]deleteSelectedTabs  self selectedTabs do: [:e |  e close ]initialize  super initialize.  selectionColor := self defaultColorupdateColumnResizersHeight  self columnResizers do: [:col |  | b |        b := col bounds.        b := b left @ self top corner: b right @ scroller bottom.        col bounds: b ]embeddable: aBoolean  embeddable := aBooleanbasicIsSticky  ^super isStickyindent  ^indentbounds: newBounds  self     extent: newBounds extent;     position: newBounds topLeftwantsSteps  | c |  c := self class.  [ c includesSelector: #step ] whileFalse: [ c := c superclass ].  ^c ~= MorphheightToDisplayInTree: aTree  ^self minExtent ytoggleSmoothing  smoothCurve := smoothCurve not.  handles ifNotNil: [ self           removeHandles;           addHandles ].  self computeBoundsnewColorChooserFor: aModel getColor: getSel setColor: setSel help: helpText  ^self theme newColorChooserIn: self for: aModel getColor: getSel setColor: setSel getEnabled: nil help: helpTexthandleMouseUp: anEvent  anEvent blueButtonChanged ifTrue: [ self blueButtonUp: anEvent ] ifFalse: [ super handleMouseUp: anEvent ]center: aPoint  self position: aPoint - (self extent // 2)cornerStyle  ^extension ifNil: [ #square ] ifNotNil: [ extension cornerStyle ]defaultEventDispatcher  ^self class defaultEventDispatchercolumnResizersToFront  self columnResizers do: [:cl |  cl           comeToFront;           fillStyle: cl normalFillStyle ]staysUpWhenMouseIsDownIn: aMorph  ^aMorph == target or: [ aMorph hasOwner: self ]chooseDropList: aStringOrText title: aString list: aList  ^self theme chooseDropListIn: self text: aStringOrText title: aString list: aListlastChild  | c |  c := self firstChild ifNil: [ ^nil ].  [ c nextSibling isNil ] whileFalse: [ c := c nextSibling ].  ^caboutText  ^self model ifNil: [ 'This is a system window without a model' translated ] ifNotNil: [ self model class instanceSide organization classComment ifEmpty: [ 'The model of this window has no class comment' ] ifNotEmpty: [:comment |  comment ] ]basicWrapSelector: aSymbol  wrapSelector := aSymbolbackgroundColoringBlockOrSelector  ^backgroundColoringBlockOrSelectormodel: anObject  model := anObjectthemeChanged  self labelArea delete.  self removeGrips.  self theme     configureWindowBorderFor: self;     configureWindowDropShadowFor: self.  self paneColor: self defaultBackgroundColor.  label ifNotNil: [ self initializeLabelArea ].  self setStripeColorsFrom: self paneColor.  (self isCollapsed not or: [ self isTaskbarPresent ]) ifTrue: [ self addGripsIfWanted ].  self isEmbedded ifTrue: [ self borderWidth: 0 ].  super themeChangedadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self fillStyle: self fillStyleToUse.  self borderStyle: self borderStyleToUsebottomLayoutFrame  ^(0 @ 1 corner: 1 @ 1) asLayoutFrame     topLeftOffset: 22 @ SystemWindow borderWidth negated;     rightOffset: -22drawOnAthensCanvas: anAthensCanvas  super drawOnAthensCanvas: anAthensCanvas.  (ActiveHand notNil and: [ ActiveHand keyboardFocus == self and: [ self rootMenu hasProperty: #hasUsedKeyboard ] ]) ifTrue: [ (anAthensCanvas setStrokePaint: self theme menuKeyboardFocusColor) width: self theme menuBorderWidth.        anAthensCanvas drawShape: self innerBounds ]innerBounds  | inner |  inner := super innerBounds.  inner := inner withTop: self top + self topHeaderHeight.  ^inneritems  ^self menuItemsmyDependents: aCollectionOrNil  aCollectionOrNil ifNil: [ self removeProperty: #myDependents ] ifNotNil: [ self setProperty: #myDependents toValue: aCollectionOrNil ]scrollRestrictedUp: aValue  self canScrollUp ifFalse: [ ^self ].  self scrollUp: aValueoldSelectedIndexes: anObject  oldSelectedIndexes := anObjectobjectToView: objectOrNil  (objectOrNil isMorph and: [ objectOrNil allMorphs includes: self ]) ifTrue: [ objectToView := nil.        ^self ].  objectToView := objectOrNildefaultBounds  ^0 @ 0 corner: 200 @ 100shiftSubmorphsOtherThan: listNotToShift by: delta  | rejectList |  rejectList := listNotToShift ifNil: [ OrderedCollection new ].  (submorphs copyWithoutAll: rejectList) do: [:m |  m position: m position + delta ]icon  ^self valueOfProperty: #iconnewBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newBracketSliderIn: self for: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpTexticonOfNode: node  getIconSelector ifNil: [ ^nil ].  ^model perform: getIconSelector with: node itemhasReverseCellsString  ^self reverseTableCells -> 'reverse table cells' translatedunwantedSelectors  ^#(#removeLineFeeds: #compressFile:)open  ^self openOn: Objectdate: aDate  date := aDateemphasizeScanner: scanner  currentPage  ^self currentPageLastIndex \\ pageSize > 0 ifTrue: [ (self currentPageLastIndex / pageSize) asInteger + 1 ] ifFalse: [ (self currentPageLastIndex / pageSize) asInteger ]addNullLineForIndex: index  | oldLastLine r |  oldLastLine := lines last.  oldLastLine last - oldLastLine first >= 0 ifFalse: [ ^self ].  oldLastLine last = (index - 1) ifFalse: [ ^self ].  r := oldLastLine left @ oldLastLine bottom extent: 0 @ (oldLastLine bottom - oldLastLine top).  self addNullLineWithIndex: index andRectangle: rrootMenu  ^selfaddWorldToggleItemsToHaloMenu: aMenu  #(#(hasDragAndDropEnabledString changeDragAndDrop 'whether I am open to having objects dropped into me') #(roundedCornersString toggleCornerRounding 'whether the world should have rounded corners')) do: [:trip |  aMenu addUpdating: trip first selector: trip second.        aMenu balloonTextForLastItem: trip third ]selectableIndexContainingPoint: aPoint  ^self tableContainer rowAndColumnIndexContainingPoint: aPointstepTime  ^0initializeClass: aClass  self initialize.  self elements: ((aClass allSelectors sorted: [:a :b |  a < b ]) collect: [:each |  FTExampleMethodModel method: (aClass lookupSelector: each) ])taskbarState  ^self isMinimized ifTrue: [ #minimized ] ifFalse: [ self isMaximized ifTrue: [ #maximized ] ifFalse: [ self isActive ifTrue: [ #active ] ifFalse: [ #restored ] ] ]frameRectangle1: aRectangle on: aCanvas  | r |  r := aRectangle insetBy: self width // 2.  self width odd ifTrue: [ r := r insetBy: (0 @ 0 corner: 1 @ 1) ].  aCanvas     line: r topLeft + (1 @ 0) to: r topRight - (1 @ 0) width: self width color: self color;     line: r topRight + (0 @ 1) to: r bottomRight - (0 @ 1) width: self width color: self color;     line: r bottomRight - (1 @ 0) to: r bottomLeft + (1 @ 0) width: self width color: self color;     line: r bottomLeft - (0 @ 1) to: r topLeft + (0 @ 1) width: self width color: self colorselectIndexes: anArray  self selectIndexes: anArray andMakeVisibleIf: trueopenInHand  self currentHand attachMorph: selfbuildSelectionBlocksFrom: topLeft to: bottomRight  | viewedString primary topLeftBlk bottomRightBlk findReplaceIntervals secondarySelectionIntervals startIdx stopIdx |  Display depth = 1 ifTrue: [ ^self ].  Display depth = 2 ifTrue: [ ^self ].  primary := selectionStart notNil ifTrue: [ selectionStart stringIndex to: selectionStop stringIndex - 1 ] ifFalse: [ 0 to: -1 ].  topLeftBlk := self characterBlockAtPoint: topLeft.  bottomRightBlk := self characterBlockAtPoint: bottomRight.  startIdx := topLeftBlk stringIndex.  stopIdx := bottomRightBlk stringIndex.  viewedString := (self text copyFrom: startIdx to: stopIdx) asString.  self theme currentSettings haveSecondarySelectionTextColor ifTrue: [ self text removeAttribute: TextSelectionColor secondarySelection ].  self theme currentSettings haveFindReplaceSelectionTextColor ifTrue: [ self text removeAttribute: TextSelectionColor findReplaceSelection ].  findReplaceIntervals := #().  extraSelectionBlocks := Array streamContents: [:strm |  findReplaceSelectionRegex ifNotNil: [ findReplaceIntervals := findReplaceSelectionRegex matchingRangesIn: viewedString.              findReplaceIntervals := (findReplaceIntervals collect: [:r |  r + topLeftBlk stringIndex - 1 ]) reject: [:r |  primary size > 0 and: [ (r includes: primary first) or: [ primary includes: r first ] ] ].              findReplaceIntervals do: [:r |  self theme currentSettings haveFindReplaceSelectionTextColor ifTrue: [ self text addAttribute: TextSelectionColor findReplaceSelection from: r first to: r last ].                    strm nextPut: (ParagraphSelectionBlock first: (self characterBlockForIndex: r first) last: (self characterBlockForIndex: r last + 1) color: self findReplaceSelectionColor) ] ].        secondarySelection ifNotNil: [ secondarySelectionIntervals := (secondarySelection reject: [:i |  (findReplaceIntervals includes: i) or: [ i = primary or: [ i first > self text size ] ] ]) collect: [:i |  i first to: (i last min: self text size) ].              secondarySelectionIntervals do: [:r |  self theme currentSettings haveSecondarySelectionTextColor ifTrue: [ self text addAttribute: TextSelectionColor secondarySelection from: r first to: r last ].                    strm nextPut: (ParagraphSelectionBlock first: (self characterBlockForIndex: r first) last: (self characterBlockForIndex: r last + 1) color: self secondarySelectionColor) ] ] ].  findReplaceSelectionRegex := nil.  secondarySelection := nilcaretWidth  ^TextEditor dumbbellCursor ifTrue: [ 2 ] ifFalse: [ 0 ]expandAllTo: aDepth  self expand.  aDepth > self depth ifTrue: [ self children do: [:each |  each expandAllTo: aDepth ] ]close  SystemProgressMorph uniqueInstance close: selfis: anEvent withFocusOver: aMorph  | focusedMorph |  focusedMorph := anEvent hand mouseFocus.  ^aMorph = focusedMorph or: [ aMorph hasOwner: focusedMorph ]focusColor  ^self color contrastingBlackAndWhiteColorrealWindowExtent  ^realWindowExtentalert: aStringOrText title: aString  ^self alert: aStringOrText title: aString configure: [:d |   ]hPageDelta  | pd tw sw |  tw := self scrollTarget width.  sw := self scrollBounds width.  pd := tw - sw max: 0.  pd = 0 ifFalse: [ pd := sw / pd ].  ^pdnoteNewOwner: aMorph  super noteNewOwner: aMorph.  self updateLayoutInDockingBarbasicKeyPressed: aCharacter  aCharacter == Character space ifTrue: [ ^self model toogleSelectionValue ].  ^super basicKeyPressed: aCharacterwantsSteps  ^truewidthOrUndefined  ^self width ifNil: [ self class undefinedColumnWidth ]cellSpacing: aSymbol  cellSpacing := aSymbolnumberOfVisibleChildren  ^(self isExpanded and: [ self children isNotEmpty ]) ifTrue: [ self children size + (self children collect: [:item |  item numberOfVisibleChildren ]) sum ] ifFalse: [ 0 ]quantum  ^quantumdrawSubmorphsOn: aCanvas  | drawBlock |  submorphs isEmpty ifTrue: [ ^self ].  drawBlock := [:canvas |  | i |  (self topVisibleRowForCanvas: aCanvas) to: (self bottomVisibleRowForCanvas: aCanvas) do: [:row |  i := self item: row.        canvas fullDrawMorph: i ] ].  self clipSubmorphs ifTrue: [ aCanvas clipBy: (aCanvas clipRect intersect: self clippingBounds ifNone: [ ^self ]) during: drawBlock ] ifFalse: [ drawBlock value: aCanvas ]forwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirectionunrotatedLength: aLength  vertices size = 2 ifTrue: [ ^self arrowLength: aLength ].  self setVertices: ((((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) height: aLength) rotationDegrees: 0) verticesisWindowActive: aSystemWindow  ^self tabGroup page == aSystemWindow and: [ aSystemWindow isTopWindow ]runLocalStepMethodsIn: aWorld  | now morphToStep stepTime priorWorld |  now := Time millisecondClockValue.  priorWorld := ActiveWorld.  ActiveWorld := aWorld.  self triggerAlarmsBefore: now.  stepList isEmpty ifTrue: [ ActiveWorld := priorWorld.        ^self ].  (now < lastStepTime or: [ now - lastStepTime > 5000 ]) ifTrue: [ self adjustWakeupTimes: now ].  [ stepList isEmpty not and: [ stepList first scheduledTime < now ] ] whileTrue: [ lastStepMessage := stepList removeFirst.        morphToStep := lastStepMessage receiver.        (morphToStep shouldGetStepsFrom: aWorld) ifTrue: [ lastStepMessage value: now.              lastStepMessage ifNotNil: [ stepTime := lastStepMessage stepTime ifNil: [ morphToStep stepTime ].                    lastStepMessage scheduledTime: now + (stepTime max: 1).                    stepList add: lastStepMessage ] ].        lastStepMessage := nil ].  lastStepTime := now.  ActiveWorld := priorWorldrightMargin  ^self rightjustDroppedInto: targetMorph event: anEvent  | formerPosition |  formerPosition := self formerPosition.  super justDroppedInto: targetMorph event: anEvent.  self formerPosition: formerPosition.  accepted := targetMorph ~= self world.  self animationForMoveSuccess: accepted.  accepted ifTrue: [ self dropNotifyRecipient ifNotNil: [ self dropNotifyRecipient dropAcceptedMorph: self from: targetMorph ] ].  self deletedoubleClickSelector: aSelector  doubleClickSelector := aSelectordefaultBounds  ^0 @ 0 corner: 50 @ 40addTab: aTab  (tabs includes: aTab) ifTrue: [ ^self ].  tabs add: aTab.  self registerActionsFor: aTab.  self selectedTab ifNil: [ aTab selected: true ].  self addFirstInHistory: aTab.  self adjustLayout.  self changed.  self triggerEvent: #tabAdded with: aTabdeepCopy  self error: 'Please use veryDeepCopy'relativeTextAnchorPosition  ^self valueOfProperty: #relativeTextAnchorPositionadjustedCenter  ^self centerselectionColor  ^selectionColor ifNil: [ self theme selectionColor ]= aMorphicEvent  super = aMorphicEvent ifFalse: [ ^false ].  buttons = aMorphicEvent buttons ifFalse: [ ^false ].  keyValue = aMorphicEvent keyValue ifFalse: [ ^false ].  ^truepotentialTargets  owner ifNil: [ ^#() ].  ^owner morphsAt: self referencePosition behind: self unlocked: true notatBottom  ^atBottom ifNil: [ atBottom := false ]positionNear: aPoint forExtent: anExtent adjustmentSuggestion: adjustmentPoint  | adjustedPosition |  adjustedPosition := aPoint.  [ (self morphsAt: adjustedPosition + (anExtent // 2)) size > 1 and: [ bounds containsPoint: adjustedPosition ] ] whileTrue: [ adjustedPosition := adjustedPosition + adjustmentPoint ].  ^adjustedPositionadd: wordingString icon: aForm help: helpString action: anAction keyText: aText  | item |  item := self newMenuItem.  item contents: wordingString.  item keyText: aText.  anAction ifNotNil: [:act |  item           target: act receiver;           selector: act selector;           arguments: act arguments ].  item icon: aForm.  helpString ifNotNil: [ item setBalloonText: helpString ].  self addMorphBack: itemsvMorph: anObject  svMorph := anObjectpreferredCornerStyle  ^#squarekeyStroke: evt  evt keyCharacter ~= Character escape ifTrue: [ ^self ].  self deleteinitialize  | workerProcess controllerProcess |  super initialize.  self extent: 300 @ 50.  self color: Color red.  self addMorphBack: (stringMorph := StringMorph new).  morphDeleted := false.  workerProcess := [ work := 0.  [ 10 milliSeconds asDelay wait.  work := work + 1.  morphDeleted ] whileFalse ] newProcess name: 'Background worker'.  controllerProcess := [ [ workerProcess resume.  self color: Color green.  10 milliSeconds asDelay wait.  workerProcess suspend.  self color: Color red.  10 milliSeconds asDelay wait.  morphDeleted ] whileFalse ] newProcess name: 'Controller'.  controllerProcess resumeinitialize  super initialize.  self positionWhenComposed: 0 @ 0selection  self selectionIndex = 0 ifTrue: [ ^nil ].  list ifNotNil: [ ^list at: self selectionIndex ].  ^self getListItem: self selectionIndexalert: aStringOrText  ^self alert: aStringOrText title: 'Alert' translateddrawBorderOn: aCanvas  self drawClippedBorderOn: aCanvas usingEnds: (Array with: vertices first with: vertices last)printOn: aStream  aStream     print: self class;     nextPutAll: ' (';     print: self date;     nextPut: $)selectedTab  ^(self tabSelector ifNil: [ ^nil ]) selectedTabpaneColor  ^self theme paneColorFor: selfwouldAcceptKeyboardFocusUponTab  ^trueselectionFrameChanged  selectedMorph ifNil: [ ^self ].  self invalidRect: self selectionFrameaddRefreshMenuItemOn: aMenu  retrievingBlock ifNil: [ ^self ].  aMenu addLine.  aMenu add: 'Refresh content' target: self selector: #refreshContentfirstName: anObject  firstName := anObjecttestReset  | dataSource |  dataSource := self dataSourceForTesting.  strategy sortFunction: #yourself ascending.  self assert: dataSource elements equals: self elementsForTestDataSource.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10).  strategy reset.  strategy sortDataSource: dataSource.  self assert: dataSource elements equals: #(1 2 3 4 5 6 7 8 9 10)stepTime  ^currentScrollDelay ifNil: [ 300 ]copyListToClipboard  | stream |  stream := (String new: self getList size * 40) writeStream.  list do: [:ea |  stream nextPutAll: ea asString ] separatedBy: [ stream nextPut: Character cr ].  Clipboard clipboardText: stream contentsfixedWidth: anInteger  currentWidth := anInteger.  resizable := falseblinkStart: msecs  ^self setProperty: #blinkStart toValue: msecsdrawOn: aCanvas  self subclassResponsibilityicon  ^nilmouseDown: evt  (evt shiftPressed and: [ self isEditable ]) ifTrue: [ ^super mouseDown: evt ].  evt hand newMouseFocus: owner.  owner selectItem: self event: evtbottomVisibleRowForCanvas: aCanvas  ^self rowAtLocation: aCanvas clipRect bottomRighttabLabelFor: aSystemWindow  ^self newRow: {((self newButtonLabel: (aSystemWindow labelString truncateWithElipsisTo: 40)) setBalloonText: aSystemWindow labelString) .         (self newCloseControlFor: nil action: [ self removeWindow: aSystemWindow ] help: 'Close this tab and free the window')}newTreeFor: aModel list: listSelector selected: getSelector changeSelected: setSelector  ^self theme newTreeIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelectoropenItemPath: anArray  | found |  anArray isEmpty ifTrue: [ ^container setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ (each complexContents withoutListWrapper == anArray first or: [ anArray first isNil ]) ifTrue: [ found := each ] ] ].  found ifNotNil: [ found isExpanded ifFalse: [ found toggleExpandedState.              container adjustSubmorphPositions ].        found changed.        anArray size = 1 ifTrue: [ ^container setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild openItemPath: anArray allButFirst ] ].  ^container setSelectedMorph: nilscaleFactor  ^self valueOfProperty: #scaleFactor ifAbsent: [ 1.0 ]initialize  super initialize.  self useSquareCornersmouseMove: anEvent  anEvent hand temporaryCursor ifNil: [ ^self ].  self class fastSplitterResize ifFalse: [ self updateFromEvent: anEvent ] ifTrue: [ traceMorph ifNil: [ traceMorph := Morph newBounds: self bounds.              traceMorph borderColor: Color lightGray.              traceMorph borderWidth: 1.              self owner addMorph: traceMorph ].        splitsTopAndBottom ifTrue: [ traceMorph position: traceMorph position x @ (self normalizedY: anEvent cursorPoint y) ] ifFalse: [ traceMorph position: (self normalizedX: anEvent cursorPoint x) @ traceMorph position y ] ]arguments  ^argumentsmaxCellSize  ^maxCellSizepassenger  ^passengerdefaultColor  ^self theme backgroundColoracceptDroppingMorph: aMorph event: evt  self model acceptDroppingMorph: aMorph event: evt inMorph: self.  self resetPotentialDropMorph.  evt hand releaseMouseFocus: self.  Cursor normal showdrawSelectionOn: aCanvas  selectedRow ifNil: [ ^self ].  selectedRow = 0 ifTrue: [ ^self ].  self drawBackgroundForSelectedRow: selectedRow on: aCanvasexpandAllFromNode: aNode  self expandAll: ((self nodeMorphOfNode: aNode) ifNil: [ ^self ]).  self adjustSubmorphPositionsnormalButtonBorderStyle  ^self theme scrollbarNormalButtonBorderStyleFor: selfdefer: aValuable  self class defer: aValuableshow: aMenuItem  | shortcutMorph |  shortcutMorph := self createShortcutMorphFor: aMenuItem.  self positionShortcut: shortcutMorph.  shortcutMorph openInWorlddrawLabelOnAthensCanvas: anAthensCanvas  anAthensCanvas pathTransform translateX: 0 Y: self fontToUse getPreciseAscent.  anAthensCanvas     setPaint: self color;     setFont: self fontToUse;     drawString: contentsflipVAroundY: centerY  | cent |  cent := centerY ifNil: [ bounds center y ] ifNotNil: [ centerY ].  self setVertices: (vertices collect: [:vv |  vv x @ ((vv y - cent) * -1 + cent) ]) reversedsentTo: anObject  type == #mouseOver ifTrue: [ ^anObject handleMouseOver: self ].  type == #mouseEnter ifTrue: [ ^anObject handleMouseEnter: self ].  type == #mouseLeave ifTrue: [ ^anObject handleMouseLeave: self ].  ^super sentTo: anObjectnewCancelButtonFor: aModel  ^self theme newCancelButtonIn: self for: aModelelements: aSequenceableCollection  self dataSource elements: aSequenceableCollectionthemeChanged  self color: self defaultColor.  super themeChanged.  self refreshpagingArea  ^pagingArearemoveModalWindow  self modalWindow: nilpageSizeFromString: aString  | input |  input := aString asString trimBoth.  input ifEmpty: [ input := '1' ].  (input beginsWith: '/') ifTrue: [ | numberOfPages |        input := (input copyFrom: 2 to: input size) trimBoth.        numberOfPages := Integer readFromString: input.        numberOfPages > 0 ifTrue: [ self changePageSize: self nodeList size // numberOfPages ] ifFalse: [ treeMorph flash.              ^false ] ] ifFalse: [ | newPageSize |        newPageSize := Integer readFromString: input.        newPageSize > 0 ifTrue: [ self changePageSize: newPageSize ] ifFalse: [ treeMorph flash.              ^false ] ].  ^truetestIdentity  self assert: LayoutFrame new equals: LayoutFrame identitytoggleOpenOrClosed  closed ifTrue: [ self makeOpen ] ifFalse: [ self makeClosed ]rotationCenter  ^self valueOfProperty: #rotationCenter ifAbsent: [ 0.5 @ 0.5 ]dropItemSelector: aSymbol  dropItemSelector := aSymbol.  aSymbol ifNotNil: [ self dropEnabled: true ]addLabelArea  labelArea := self theme newWindowHeaderFor: self.  self addMorph: labelAreaadoptPaneColor: aColor  super adoptPaneColor: aColor.  aColor ifNil: [ ^self ].  self adoptColor: self colorToUsebuildButton  ^PluggableButtonMorph on: self getState: nil action: #action label: #label menu: nilhsvMorph  ^hsvMorphmouseDownInCollapseHandle: evt with: collapseHandle  self obtainHaloForEvent: evt andRemoveAllHandlesBut: collapseHandle.  self setDismissColor: evt with: collapseHandleremoveObsoleteEventHandlers  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  scroller submorphs do: [:m |  m           eventHandler: nil;           highlightForMouseDown: false;           resetExtension ]startStepping: aSelector at: scheduledTime arguments: args stepTime: stepTime  | w |  w := self world.  w ifNotNil: [ w startStepping: self at: scheduledTime selector: aSelector arguments: args stepTime: stepTime.        self changed ]wantsDroppedMorph: aMorph event: evt  ^self dropEnabledmouseUp: evt  (self fullContainsPoint: evt position) ifFalse: [ evt hand releaseMouseFocus: self.        ^self deleteIfPopUp: evt ].  stayUp ifFalse: [ evt hand newMouseFocus: self ]newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel  ^self newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: nilnonVisibleTabs  ^self tabs select: [:t |  t owner isNil ]recalculateVerticalScrollBar  | interval delta pageDelta visibleRows numberOfRows |  self hasDataSource ifFalse: [ ^self ].  self recalculateVerticalScrollBarVisibilityIfHidden: [ ^self ].  visibleRows := self container calculateExactVisibleRows.  numberOfRows := self dataSource numberOfRows.  numberOfRows = 0 ifTrue: [ ^self ].  interval := (visibleRows / numberOfRows) asFloat.  delta := 1 / numberOfRows.  pageDelta := (visibleRows - 1) floor * delta.  self verticalScrollBar     scrollDelta: delta pageDelta: pageDelta;     interval: intervalcalculateChildren  newCloseControlFor: aModel action: aValuable help: helpText  ^self theme newCloseControlIn: self for: aModel action: aValuable help: helpTextpotentialDropMorph  ^potentialDropMorphevent: anEvent  event := anEventdrawSubMenuMarkerOnAthensCanvas: anAthensCanvas  self hasSubMenu ifFalse: [ ^self ].  anAthensCanvas pathTransform restoreAfter: [ anAthensCanvas pathTransform translateX: self extent x - self subMenuMarker width Y: 0.        anAthensCanvas pathTransform translateX: 0 Y: self subMenuMarker height // 2.        anAthensCanvas setPaint: self subMenuMarker.        anAthensCanvas drawShape: (0 @ 0 extent: self subMenuMarker extent) ]extent: aPoint  super extent: aPoint.  self fillStyle isOrientedFill ifTrue: [ self fillStyle: (self theme progressBarFillStyleFor: self) ].  self barFillStyle isOrientedFill ifTrue: [ self barFillStyle: (self theme progressBarProgressFillStyleFor: self) ]scale: newScale  self changed.  transform := transform withScale: newScale.  self layoutChanged.  self changedenableAllMouseCommandsFrom: someObjectWithCommandContext  self     enableMouseCommands: CmdClickActivation withContextFrom: someObjectWithCommandContext;     enableMouseCommands: CmdDoubleClickActivation withContextFrom: someObjectWithCommandContexthandlesMouseDown: event  ^truegetColorSelector  ^getColorSelectorpickColor  | p c h |  h := self activeHand.  h showTemporaryCursor: (self iconNamed: #eyedropperIcon) hotSpotOffset: 6 @ 31.  h captureEventsUntil: [:evt |  evt isMove ifTrue: [ p := evt position.              (self hsvaMorph containsPoint: p) ifFalse: [ c := Display depth = 32 ifTrue: [ Color colorFromPixelValue: ((Display pixelValueAt: p) bitOr: 16rFF000000) depth: 32 ] ifFalse: [ Display colorAt: p ] ].              h position: p.              self selectedColor ~= c ifTrue: [ self selectedColor: c ] ].        h anyButtonPressed ].  h showTemporaryCursor: nilpredecessorChanged  | newStart oldStart |  (self hasProperty: #CreatingParagraph) ifTrue: [ ^self ].  newStart := predecessor ifNil: [ 1 ] ifNotNil: [ predecessor lastCharacterIndex + 1 ].  (self paragraph adjustedFirstCharacterIndex ~= newStart or: [ newStart >= text size ]) ifTrue: [ paragraph composeAllStartingAt: newStart.        self fit ] ifFalse: [ oldStart := self firstCharacterIndex.        self withSuccessorsDo: [:m |  m adjustLineIndicesBy: newStart - oldStart ] ]listCentering  ^#topLeftdismissViaHalo  super dismissViaHalo.  selectedItems do: [:m |  m dismissViaHalo ]newGroupboxForAll: controls  ^self theme newGroupboxIn: self forAll: controlschooseExistingFileReference: title extensions: exts path: path preview: preview  ^self theme chooseExistingFileReferenceIn: self title: title extensions: exts path: path preview: previewsetStateSelector  ^setStateSelectorborderWidth: aNumber  | style |  style := self borderStyle.  style width = aNumber ifTrue: [ ^self ].  style style = #none ifTrue: [ self borderStyle: (SimpleBorder width: aNumber color: Color transparent) ] ifFalse: [ style width: aNumber.        self changed ]setSecondColorDashOnStroke: anAthensStrokePaint  | d c commonOffset |  d := self dashedBorder.  c := d third.  commonOffset := d size > 3 ifTrue: [ d fourth ] ifFalse: [ 0 ].  anAthensStrokePaint fillPaint: c.  anAthensStrokePaint dashes: {d second .         d first} offset: commonOffset + d secondcurrentPageLastIndex  ^pageSize ifNil: [ self nodeList size ] ifNotNil: [ self currentPageFirstIndex + pageSize - 1 min: self nodeList size ]defaultLabel  ^'Dialog' translatedselected: aBoolean  (state isSelectedMatchingTheState: aBoolean) ifTrue: [ ^self triggerEvent: #tabResetSelection with: self ].  state := state newStateForSelected: aBoolean.  aBoolean ifTrue: [ self triggerEvent: #tabSelected with: self.        self showCloseIcon ]enabled: aBoolean  enabled := aBoolean.  self contentMorph ifNotNil: [:m |  m enabled: aBoolean ].  self changed: #enableddeny: aStringOrText  ^self deny: aStringOrText title: 'Access Denied' translatedtarget  ^targetwhichButton  ^whichButtonnewCheckboxFor: aModel getSelected: getSel setSelected: setSel label: stringOrText help: helpText  ^self theme newCheckboxIn: self for: aModel getSelected: getSel setSelected: setSel getEnabled: nil label: stringOrText help: helpTexticon: anIcon  icon := anIconinitialize  mouseOverMorphs := #().  self initializeTrackedMorphsbuttons  ^self paneMorphs last lastSubmorph submorphstop  ^bounds topresizeHorizontalScrollBar  | width height corner |  horizontalScrollBar ifNotNil: [ width := self bounds width - (self borderWidth * 2) - self verticalScrollBarWidth.        height := self scrollBarThickness.        corner := self bounds bottomLeft - ((width + self borderWidth) @ (0 - self borderWidth)).        corner := self bounds bottomLeft - ((0 - self borderWidth) @ (height + self borderWidth)).        self horizontalScrollBar bounds: (corner extent: width @ height) ]drawOn: aCanvas  | array |  vertices size < 1 ifTrue: [ self error: 'a polygon must have at least one point' ].  closed ifTrue: [ aCanvas drawPolygon: self getVertices fillStyle: self fillStyle ].  array := self drawArrowsOn: aCanvas.  self drawClippedBorderOn: aCanvas usingEnds: arrayhasContentToShow  ^falsefillsOwner  ^fillsOwner ifNil: [ true ]result  ^resultnoButtonPressed  ^self anyButtonPressed notbaseColor  ^Color transparentborderStyleToUse  ^self enabled ifTrue: [ self theme scrollPaneNormalBorderStyleFor: self ] ifFalse: [ self theme scrollPaneDisabledBorderStyleFor: self ]setWidth: width  self extent: (width @ (font ifNil: [ TextStyle defaultFont ]) height) ceilingisDisplayed  ^self world notNilspacerWidth  | baseRect |  baseRect := self mustTakeIntoAccountCheckSpace ifTrue: [ self checkRectangle ] ifFalse: [ self toggleRectangle ].  ^(self mustTakeIntoAccountToggleSpace or: [ self mustTakeIntoAccountCheckSpace ]) ifTrue: [ baseRect right + container gapAfterToggle - bounds left ] ifFalse: [ baseRect left - bounds left ]seperatorColor  ^self theme scrollbarColorbarFillStyle  ^self valueOfProperty: #barFillStyle ifAbsent: [ self theme menuTitleColor ]veryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  otherProperties ifNil: [ ^self ].  self copyWeakly do: [:propertyName |  otherProperties at: propertyName ifPresent: [:property |  otherProperties at: propertyName put: (deepCopier references at: property ifAbsent: [ property ]) ] ]doLayoutIn: layoutBounds  | scrollbarChange |  super doLayoutIn: layoutBounds.  scrollbarChange := (self vScrollbarShowing = self vScrollbarNeeded) not.  scrollbarChange := scrollbarChange or: [ (self hScrollbarShowing = self hScrollbarNeeded) not ].  self updateScrollbars.  scrollbarChange ifFalse: [ self resizeScroller ].  super doLayoutIn: layoutBoundstestPager  | treeMorph aWindow aModel |  aModel := PaginatedMorphTreeModel itemsList: (1 to: 100) asArray.  aWindow := aModel theme newWindowIn: self currentWorld for: aModel title: 'test'.  treeMorph := aModel defaultTreeMorph.  treeMorph pageSize: 30.  treeMorph buildContents.  aWindow addMorph: treeMorph fullFrame: LayoutFrame identity.  aWindow open.  aModel expandItemPath: {40}.  self assert: treeMorph pager currentPage identicalTo: 2.  aWindow closenewDisplayDepthNoRestore: pixelSize  | area need |  pixelSize = Display depth ifTrue: [ ^Display ].  pixelSize abs < Display depth ifFalse: [ area := Display boundingBox area.        need := area * (pixelSize abs - Display depth) // 8 + Smalltalk lowSpaceThreshold.        (Smalltalk garbageCollectMost <= need and: [ Smalltalk garbageCollect <= need ]) ifTrue: [ self error: 'Insufficient free space' ] ].  Display setExtent: Display extent depth: pixelSize.  DisplayScreen startUpselectedMouseOverFillStyle  ^self theme controlButtonSelectedMouseOverFillStyleFor: selfyellowButtonActivity  ^self yellowButtonActivity: falsereleaseCachedState  super releaseCachedState.  image hibernateselectionChangedResetIfEmpty: ann  self resetListSelector ifNil: [ ^self ].  ann newSelectedIndexes ifNotEmpty: [ ^self ].  self model perform: self resetListSelectorselectPreviousTask  self selectTask: (self tasks before: self activeTask ifAbsent: [ self tasks isEmpty ifFalse: [ self tasks last ] ])settingSelector  ^nilminExtent  | superMin |  superMin := super minExtent.  ^(24 max: superMin x) @ (24 max: superMin y)propertyNamesNotCopied  ^#(connectedConstraints connectionHighlights highlightedTargets)addMorphFront: aMorph fromWorldPosition: wp  self addMorphFront: aMorph.  aMorph position: (self transformFromWorld globalPointToLocal: wp)submorphsInFrontOf: aMorph do: aBlock  | behind |  behind := false.  submorphs do: [:m |  m == aMorph ifTrue: [ behind := true ] ifFalse: [ behind ifFalse: [ aBlock value: m ] ] ]withAllOwnersDo: aBlock  aBlock value: self.  owner ifNotNil: [ ^owner withAllOwnersDo: aBlock ]handlesMouseOverDragging: evt  ^self dropEnabledclipDuring: aBlock canvas: aCanvas  self clipSubmorphs ifTrue: [ aCanvas clipBy: self clippingBounds during: aBlock ] ifFalse: [ ^aBlock value ]popUpContentsMenu: evt  | menu |  menu := UIManager default newMenuIn: self for: self.  self contentsMenu: menu.  menu     buildTitle: [:titleMorph |  titleMorph bigTitle: self contentsMenuTitle ];     popUpEvent: evt in: (self world ifNil: [ self ])embeddable: aBoolean  self setProperty: #embeddable toValue: aBooleanhSpaceFill  ^self flags anyMask: 1placeCells: arrangement in: newBounds horizontal: aBool target: aMorph  | xDir yDir anchor yDist place cell xDist cellRect corner inset |  inset := properties cellInset.  (inset isNumber and: [ inset isZero ]) ifTrue: [ inset := nil ].  aBool ifTrue: [ properties listDirection == #rightToLeft ifTrue: [ xDir := -1 @ 0.              properties wrapDirection == #bottomToTop ifTrue: [ yDir := 0 @ -1.                    anchor := newBounds bottomRight ] ifFalse: [ yDir := 0 @ 1.                    anchor := newBounds topRight ] ] ifFalse: [ xDir := 1 @ 0.              properties wrapDirection == #bottomToTop ifTrue: [ yDir := 0 @ -1.                    anchor := newBounds bottomLeft ] ifFalse: [ yDir := 0 @ 1.                    anchor := newBounds topLeft ] ] ] ifFalse: [ properties listDirection == #bottomToTop ifTrue: [ xDir := 0 @ -1.              properties wrapDirection == #rightToLeft ifTrue: [ yDir := -1 @ 0.                    anchor := newBounds bottomRight ] ifFalse: [ yDir := 1 @ 0.                    anchor := newBounds bottomLeft ] ] ifFalse: [ xDir := 0 @ 1.              anchor := properties wrapDirection == #rightToLeft ifTrue: [ yDir := -1 @ 0.                    newBounds topRight ] ifFalse: [ yDir := 1 @ 0.                    newBounds topLeft ] ] ].  1 to: arrangement size do: [:i |  cell := arrangement at: i.        cell extraSpace ifNotNil: [ anchor := anchor + (cell extraSpace y * yDir) ].        yDist := cell cellSize y * yDir.        place := anchor.        cell := cell nextCell.        [ cell isNil ] whileFalse: [ cell extraSpace ifNotNil: [ place := place + (cell extraSpace x * xDir) ].              xDist := cell cellSize x * xDir.              corner := place + xDist + yDist.              cellRect := Rectangle origin: (place min: corner) corner: (place max: corner).              inset ifNotNil: [ cellRect := cellRect insetBy: inset ].              cell target layoutInBounds: cellRect.              place := place + xDist.              cell := cell nextCell ].        anchor := anchor + yDist ]prepareForScaling  takesKeyboardFocus  ^truefindRegex  ^self editor findRegexinitializeKeyBindings  self bindKeyCombination: Character arrowUp shift | Character arrowUp asKeyCombination toAction: [:target :morph :event |  self keyStrokeArrowUp: event ].  self bindKeyCombination: Character arrowDown shift | Character arrowDown asKeyCombination toAction: [:target :morph :event |  self keyStrokeArrowDown: event ].  self bindKeyCombination: Character arrowLeft shift | Character arrowLeft asKeyCombination toAction: [:target :morph :event |  self keyStrokeArrowLeft: event ].  self bindKeyCombination: Character arrowRight shift | Character arrowRight asKeyCombination toAction: [:target :morph :event |  self keyStrokeArrowRight: event ].  self bindKeyCombination: Character home asKeyCombination toAction: [ self selectFirst ].  self bindKeyCombination: Character end asKeyCombination toAction: [ self selectLast ].  self bindKeyCombination: self shortcutProvider selectAllShortcut toAction: [ self selectAll ]debugDrawError  (self valueOfProperty: #drawError) debugaddWindowToWorld  | morph |  morph := Morph new.  windows add: morph.  ^morphheaderColor: aColor  self deprecated: 'This method will be removed in the next Pharo version. The header color is not the responsibility of the FastTable. If you want to change the color of the table''s header you should do it in the datasource. In the datasource there is a method to return a header''s cell, you should change the color there.' on: '29-04-2019' in: #Pharo8.  headerColor := aColordelete  super delete.  self triggerEvent: #tabManagerDeleted with: selfoldSize: anObject  oldSize := anObjectnewTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpText  ^self theme newTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel help: helpTextpreferredKeyboardPosition  | default rects |  default := (self bounds: self bounds in: self currentWorld) topLeft.  paragraph ifNil: [ ^default ].  rects := paragraph selectionRects.  rects size = 0 ifTrue: [ ^default ].  ^rects first topLefttemporaryCursor  ^temporaryCursorminExtentOf: aMorph in: box  | cells arrangement horizontal newBounds minX minY dir |  minExtentCache ifNotNil: [ ^minExtentCache ].  aMorph hasSubmorphs ifFalse: [ ^0 @ 0 ].  properties := aMorph assureTableProperties.  (properties wrapDirection == #none and: [ properties cellSpacing == #none ]) ifTrue: [ dir := properties listDirection.        (dir == #leftToRight or: [ dir == #rightToLeft ]) ifTrue: [ ^self minExtentHorizontal: aMorph ].        (dir == #topToBottom or: [ dir == #bottomToTop ]) ifTrue: [ ^self minExtentVertical: aMorph ] ].  newBounds := box origin asIntegerPoint corner: box corner asIntegerPoint.  horizontal := (properties listDirection == #topToBottom or: [ properties listDirection == #bottomToTop ]) not.  cells := self computeCellSizes: aMorph in: (0 @ 0 corner: newBounds extent) horizontal: horizontal.  arrangement := self computeCellArrangement: cells in: newBounds horizontal: horizontal target: aMorph.  minX := minY := 0.  arrangement do: [:cell |  minX := minX max: cell cellSize x + cell extraSpace x.        minY := minY + cell cellSize y + cell extraSpace y ].  minExtentCache := horizontal ifTrue: [ minX @ minY ] ifFalse: [ minY @ minX ].  ^minExtentCachenewButtonLabel: direction ofSize: size  ^AlphaImageMorph new image: (ScrollBar arrowOfDirection: direction size: size color: self paneColor darker)newToolbar: controls  ^self theme newToolbarIn: self for: controlsenableFilter: aFTFilterClass  self enableFilter.  function filterClass: aFTFilterClasstestSelectableIndexAfter  self subclassResponsibilityhandlesMouseStillDown: evt  ^actWhen == #whilePressedactionMap  ^actionMap ifNil: [ self valueOfProperty: #actionMap ifAbsent: [  ] ]newSVColorMorph  ^SVColorSelectorMorph new     extent: 152 @ 152;     hResizing: #spaceFill;     vResizing: #spaceFill;     when: #colorSelected send: #colorSelected: to: selfpoint: aPoint from: aReferenceMorph  owner ifNil: [ ^aPoint ].  ^(owner transformFrom: aReferenceMorph) globalPointToLocal: aPointrotationDegrees: degrees  graphicalMorph  ^graphicalMorphrejectsEvent: anEvent  (anEvent isMouse and: [ anEvent isMouseDown ]) ifTrue: [ ^(self submorphs anySatisfy: [:each |  each containsPoint: anEvent cursorPoint ]) not ].  ^super rejectsEvent: anEventrowIndexFrom: anIndex  ^anIndextestIsAfterColumn  self subclassResponsibilitypreferredCornerStyle  ^self theme windowPreferredCornerStyleFor: selfsuccessor  ^successordefaultTop  ^self defaultBounds toplayout  ^layoutsetDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) roundedinitRow  fillStyle: aFillStyle  self assureExtension.  extension fillStyle = aFillStyle ifTrue: [ ^self ].  extension fillStyle: aFillStyle.  color := aFillStyle asColor.  self changedminWidth: aNumber  aNumber ifNil: [ self removeProperty: #minWidth ] ifNotNil: [ self setProperty: #minWidth toValue: aNumber ].  self layoutChangedtestResizing  | t oldBounds newBounds |  window := SystemWindow labelled: 'foo'.  window setProperty: #minimumExtent toValue: 1 @ 1.  t := 0.  window openInWorld.  oldBounds := window bounds.  window announcer when: WindowResizing do: [:ann |  t := t + 1 ].  self assert: t equals: 0.  window extent: 50 @ 60.  newBounds := window bounds.  self assert: t equals: 1storeValue: anObject  storeValue := anObjectclick: anEvent for: model controller: editor  | action clickPoint |  clickPoint := anEvent cursorPoint.  action := false.  self actionAttributesUnder: clickPoint event: anEvent do: [:attribute |  | target |        target := model ifNil: [ editor morph ].        (attribute actOnClick: anEvent for: target in: self editor: editor) == true ifTrue: [ ^true ] ].  (action and: [ Cursor currentCursor == Cursor webLink ]) ifTrue: [ Cursor normal show ].  ^actionicon  ^iconquantum: anObject  quantum := anObject.  self setValue: self valueselectionColor  ^selectionColor ifNil: [ self class defaultSelectionColor ]nextSibling: anotherMorph  nextSibling := anotherMorphsetArguments  | newArgs newArgsArray |  newArgs := UIManager default request: 'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated initialAnswer: (String streamContents: [:str |  arguments do: [:arg |  arg printOn: str.                    str nextPutAll: '. ' ] ]).  newArgs isEmptyOrNil ifFalse: [ newArgsArray := self class compiler           source: '{' , newArgs , '}';           receiver: self;           evaluate.        self arguments: newArgsArray ]assureOtherProperties  otherProperties ifNil: [ self initializeOtherProperties ].  ^otherPropertiesprocessMouseOver: anEvent  self initializeProcessMouseOver.  self handleAsMouseOver: anEvent.  self hasLeftMorphsChanged ifTrue: [ self handleAsMouseLeave: anEvent.        self handleAsMouseEnter: anEvent.        self rememberOverList ].  self initializeTrackedMorphsgetCollapsedFrame  ^RealEstateAgent assignCollapseFrameFor: selfadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self fillStyle: self normalFillStylecollapseNodePath: aNodePath  self requestView: (MorphTreeChangeRequest collapseNodePath: aNodePath)canChangeText  ^self enabledaddPredecessor: evt  | newMorph |  newMorph := self copy predecessor: predecessor successor: self.  newMorph extent: self width @ 100.  predecessor ifNotNil: [ predecessor setSuccessor: newMorph ].  self setPredecessor: newMorph.  predecessor recomposeChain.  evt hand attachMorph: newMorphacceptDroppingMorph: aMorph event: evt  | layout |  layout := self layoutPolicy.  layout ifNil: [ ^self addMorph: aMorph ].  self privateAddMorph: aMorph atIndex: (layout indexForInserting: aMorph at: evt position in: self)fixKeyText: aString  ^ToggleMenuItemShortcut normalize: aStringactivateCursor: aCursor withMask: maskForm  worldState worldRenderer activateCursor: aCursor withMask: maskFormisEnabled: aBoolean  isEnabled = aBoolean ifTrue: [ ^self ].  isEnabled := aBoolean.  self changedupdateSubMenu  target ifNotNil: [ subMenu := target perform: subMenuSelector ]newVSplitterAt: anIndex  | left frame splitter index size |  size := submorphs size.  index := size - anIndex + 2.  left := self submorphs at: index.  frame := left layoutFrame.  splitter := self newVSplitter.  splitter layoutFrame: ((frame rightFraction @ frame topFraction corner: frame rightFraction @ frame bottomFraction) asLayoutFrame rightOffset: 4).  self privateAddMorph: splitter atIndex: size - anIndex + 2firstCharacterIndex  ^firstCharacterIndexnewImage: aForm size: aPoint  ^self theme newImageIn: self form: aForm size: aPointselectedNodePathList  ^self subclassResponsibilitytabSelector  ^tabSelectorcolumns: aListOfTreeColumn  self removeColumnResizers.  topHeader ifNotNil: [ self removeMorph: topHeader ].  columns := aListOfTreeColumn asOrderedCollection.  aListOfTreeColumn do: [:col |  col container: self ].  self buildTopHeader.  self addColumnResizersdrawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas  | rectList n morphs rects validList |  rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.  rectList := rectList asArray sort: [:r1 :r2 |  r1 area > r2 area ].  damageRecorder reset.  n := submorphs size.  morphs := OrderedCollection new: n * 2.  rects := OrderedCollection new: n * 2.  validList := OrderedCollection new: n * 2.  rectList do: [:dirtyRect |  dirtyRect allAreasOutsideList: validList do: [:r |  | mm rect i c remnantIntersects remnants rectToFill |              rectToFill := r.              remnants := OrderedCollection with: r.              i := 1.              [ remnants isEmpty or: [ i > n ] ] whileFalse: [ mm := submorphs at: i.                    ((remnantIntersects := remnants select: [:each |  mm fullBounds intersects: each ]) notEmpty and: [ mm visible ]) ifTrue: [ morphs addLast: mm.                          rects addLast: (Rectangle merging: (remnantIntersects collect: [:each |  mm fullBounds intersect: each ])).                          remnants removeAll: remnantIntersects.                          remnantIntersects do: [:eachIntersect |  remnants addAll: (mm areasRemainingToFill: eachIntersect) ].                          remnants size = 1 ifTrue: [ rectToFill := remnants first ].                          remnants isEmpty ifTrue: [ rectToFill := nil ] ].                    i := i + 1 ].              rectToFill ifNotNil: [ aWorld drawOn: (c := aCanvas copyClipRect: rectToFill) ].              [ morphs isEmpty ] whileFalse: [ (rect := rects removeLast) == rectToFill ifFalse: [ c := aCanvas copyClipRect: (rectToFill := rect) ].                    c fullDrawMorph: morphs removeLast ].              morphs reset.              rects reset.              validList add: r ] ].  ^validListhResizing  ^hResizingbasicTheme: aUITheme  self theme = aUITheme ifFalse: [ self setProperty: #theme toValue: aUITheme ]age  ^agefractionRectangle  ^leftFraction @ topFraction corner: rightFraction @ bottomFractionintersectionWithLineSegmentFromCenterTo: aPoint  | dx aSquared bSquared m mSquared xSquared x y dy |  (self containsPoint: aPoint) ifTrue: [ ^aPoint ].  dx := aPoint x - self center x.  dy := aPoint y - self center y.  dx = 0 ifTrue: [ ^self bounds pointNearestTo: aPoint ].  m := dy / dx.  mSquared := m squared.  aSquared := (self bounds width / 2) squared.  bSquared := (self bounds height / 2) squared.  xSquared := 1 / (1 / aSquared + (mSquared / bSquared)).  x := xSquared sqrt.  dx < 0 ifTrue: [ x := x negated ].  y := m * x.  ^self center + (x @ y) asIntegerPointlistSpacingString: aSymbol  ^self layoutMenuPropertyString: aSymbol from: self listSpacingnameMorph  ^LabelMorph new     contents: self name;     enabled: false;     hResizing: #spaceFill;     yourselfpopUpMenu  | menu |  menu := self selectedTab menu.  menu popUpAt: menuButton bottomRight forHand: ActiveHand in: self currentWorldtreeMorph  | treeMorph |  treeMorph := (self treeMorphClass on: self)     beCheckList;     beMultiple;     columns: {(MorphTreeColumn new           startWidth: 100;           rowMorphGetSelector: #firstNameMorph;           headerButtonLabel: 'First name' font: nil) .         (MorphTreeColumn new           startWidth: 150;           rowMorphGetSelector: #secondNameMorph;           headerButtonLabel: 'Second name' font: nil) .         (MorphTreeColumn new           startWidth: 50;           rowMorphGetSelector: #ageMorph;           headerButtonLabel: 'Age' font: nil) .         (MorphTreeColumn new           startWidth: 50;           rowMorphGetSelector: #marriedMorph;           headerButtonLabel: 'Married' font: nil)};     columnInset: 3;     rowInset: 1;     preferedPaneColor: Color white;     rowColorForEven: Color veryLightGray muchLighter odd: Color white.  ^treeMorphdelete  target ifNotNil: [ target hasHalo: false ].  super deletemin: aNumber  (self sliderMorph ifNil: [ ^self ]) min: aNumberaddSuccessor: evt  | newMorph |  newMorph := self copy predecessor: self successor: successor.  newMorph extent: self width @ 100.  successor ifNotNil: [ successor setPredecessor: newMorph ].  self setSuccessor: newMorph.  successor recomposeChain.  evt hand attachMorph: newMorphtabs: aCollection  tabs do: [:e |  e silentlySelected: false ].  tabs := aCollection.  selectionHistory removeAll.  aCollection do: [:aTab |  self registerActionsFor: aTab.        self selectedTab ifNil: [ aTab selected: true ].        self addFirstInHistory: aTab ].  self adjustLayout.  self changed.  self triggerEvent: #tabsChangedarcLengths: anArrayOfIntegers  arcLengths := anArrayOfIntegersopenDialogWindowIn: aWindow title: aTitle  ^self openDialogWindowIn: aWindow title: aTitle selectedtems: Array newcommandOrCrontrolKeyPressed: anEvent  ^client commandOrCrontrolKeyPressed: anEventpermitsThumbnailing  ^trueclose  self canBeClosed ifFalse: [ ^self ].  self deletedefaultColor  ^Color transparentmessage: aStringOrText title: aString  ^self theme messageIn: self text: aStringOrText title: aStringborderStyle: aBorderStyle  aBorderStyle = self borderStyle ifTrue: [ ^self ].  self assureExtension.  (self canDrawBorder: aBorderStyle) ifFalse: [ ^self borderStyle: (BorderStyle width: aBorderStyle width color: (aBorderStyle trackColorFrom: self) color) ].  aBorderStyle width = self borderStyle width ifFalse: [ self changed ].  (aBorderStyle isNil or: [ aBorderStyle == BorderStyle default ]) ifTrue: [ extension borderStyle: nil.        borderWidth := 0.        ^self changed ].  extension borderStyle: aBorderStyle.  borderWidth := aBorderStyle width.  borderColor := aBorderStyle style == #simple ifTrue: [ aBorderStyle color ] ifFalse: [ aBorderStyle style ].  self changedsliderColor: newColor  sliderColor := newColor.  slider ifNotNil: [ slider color: sliderColor ]nextPage  self currentPageLastIndex < self nodeList size ifTrue: [ currentPageFirstIndex := currentPageFirstIndex + pageSize min: self nodeList size.        self showCurrentPage ]mouseUp: evt  evt hand mouseFocus == owner ifFalse: [ ^self ].  self contentString ifNotNil: [ self contents: self contentString withMarkers: true inverse: true.        self refreshWorld.        (Delay forMilliseconds: 200) wait ].  self deselect: evt.  self invokeWithEvent: evtfillStyleToUse  ^self enabled ifTrue: [ self theme listNormalFillStyleFor: self ] ifFalse: [ self theme listDisabledFillStyleFor: self ]isMouseMove  ^falserotationDegrees: degrees  dragTransferType  ^self getListElementSelectorisSoleItem  ^self isFirstItem and: [ owner submorphs size = 1 ]fontToUse  | fontToUse |  fontToUse := font ifNil: [ TextStyle defaultFont ] ifNotNil: [ font ].  (emphasis isNil or: [ emphasis = 0 ]) ifTrue: [ ^fontToUse ] ifFalse: [ ^fontToUse emphasized: emphasis ]handleYearTouched  | newYear dayCount |  newYear := UIManager default chooseOrRequestFrom: (2000 to: 2020) lines: #() title: 'Choose a year:'.  newYear ifNil: [ ^self ].  newYear := newYear asNumber.  dayCount := (Month year: newYear month: date monthIndex) daysInMonth.  self date: (Date year: newYear month: date monthIndex day: (date dayOfMonth min: dayCount)).  self changeddiscoveredMenuPragmaKeyword  ^'windowMenu'isOpened  ^trueopenModal  self openInWorld.  self theme runModal: selfallowsDeselection: aBoolean  allowsDeselection := aBooleanaddModelYellowButtonItemsTo: aCustomMenu event: evt  self model ifNotNil: [:mod |  mod addModelYellowButtonMenuItemsTo: aCustomMenu forMorph: self hand: evt hand ]image: aForm size: aPoint  | f |  (aForm depth < 32 and: [ aForm depth > 4 ]) ifTrue: [ f := Form extent: aPoint depth: 32.        f fillColor: (Color white alpha: 0.003922).        f getCanvas translucentImage: aForm at: 0 @ 0.        f fixAlpha ] ifFalse: [ f := aForm ].  f := f scaledToSize: aPoint.  self autoSize ifTrue: [ super image: f ] ifFalse: [ image := f.        self changed ].  self cachedForm: nil.  self changed: #imageExtentpage  ^self pageMorphnextCell: aCell  nextCell := aCelllastPaneColor  ^lastPaneColorshadowForm  | bnds canvas |  bnds := Rectangle merging: (submorphs collect: [:m |  m fullBounds ]).  canvas := (Display defaultCanvasClass extent: bnds extent depth: 1) asShadowDrawingCanvas: Color black.  canvas translateBy: bnds topLeft negated during: [:tempCanvas |  self drawSubmorphsOn: tempCanvas ].  ^canvas form offset: bnds topLeftresizeWidget  | topLeft bottomRight |  self flag: #pharoTodo.  topLeft := table bounds left @ (table bounds bottom - self fieldHeigh - table horizontalScrollBarHeight).  bottomRight := (table bounds right - table verticalScrollBarWidth) @ (table bottom - table horizontalScrollBarHeight).  field bounds: (topLeft corner: bottomRight)enabled  ^enabled ifNil: [ true ]initialize  super initialize.  self enableDragNDrop.  self clipSubmorphs: truedispatchDropEvent: anEvent with: aMorph  | inside index morphs child localEvt |  (aMorph fullBounds containsPoint: anEvent cursorPoint) ifFalse: [ ^#rejected ].  aMorph rejectDropEvent: anEvent.  anEvent wasHandled ifTrue: [ ^self ].  index := 1.  inside := false.  morphs := aMorph submorphs.  [ index <= morphs size ] whileTrue: [ child := morphs at: index.        localEvt := anEvent transformedBy: (child transformedFrom: aMorph).        (child processEvent: localEvt using: self) == #rejected ifFalse: [ localEvt wasHandled ifTrue: [ ^anEvent wasHandled: true ].              inside := true.              index := morphs size ].        index := index + 1 ].  inside ifFalse: [ inside := aMorph containsPoint: anEvent cursorPoint event: anEvent ].  inside ifTrue: [ ^aMorph handleEvent: anEvent ].  ^#rejectedprintOn: aStream  aStream nextPut: $[.  aStream     nextPutAll: self startPoint printString;     space.  aStream     nextPutAll: self endPoint printString;     space.  aStream     nextPutAll: self type;     space.  aStream nextPutAll: self modifierString.  aStream nextPutAll: self buttonString.  aStream     nextPutAll: timeStamp printString;     space.  aStream nextPutAll: self windowIndex printString.  aStream nextPut: $]imageForm: depth forRectangle: rect  | canvas |  canvas := Display defaultCanvasClass extent: rect extent depth: depth.  backgroundColor isTransparent ifTrue: [ canvas form fillColor: self theme backgroundColor ].  canvas translateBy: rect topLeft negated during: [:tempCanvas |  tempCanvas fullDrawMorph: self ].  ^canvas form offset: rect topLeftkeystrokeActionSelector  ^keystrokeActionSelectorminimizeOrRestore  | mc windowEvent |  isCollapsed ifTrue: [ self theme shouldUseAnimations ifTrue: [ self animateRestoreFromMinimized ].        isCollapsed := false.        self           setBoundsWithFlex: fullFrame;           comeToFront;           show.        mc := self modalChild.        paneMorphs reverseDo: [:m |  mc ifNil: [ m unlock ].              self addMorph: m.              self world startSteppingSubmorphsOf: m ].        self activate ] ifFalse: [ isCollapsed := true.        fullFrame := self getBoundsWithFlex.        paneMorphs do: [:m |  m                 delete;                 releaseCachedState ].        self           setBoundsWithFlex: (-100 @ -100 extent: 2 @ 2);           hide.        self theme shouldUseAnimations ifTrue: [ self animateMinimize ].        self isActive ifTrue: [ self world navigateVisibleWindowForward ] ].  self layoutChanged.  windowEvent := self isMinimized ifTrue: [ WindowCollapsed new ] ifFalse: [ WindowExpanded new ].  windowEvent window: self.  self announce: windowEventdataSource: anObject  dataSource := anObject.  children ifNotNil: [ children do: [:item |  item dataSource: anObject ] ]rowMorphGetterBlock  ^self rowMorphGetSelector isSymbol ifTrue: [ self rowMorphGetSelector numArgs = 0 ifTrue: [ [:node :cont |  node perform: self rowMorphGetSelector ] ] ifFalse: [ [:node :cont |  node perform: self rowMorphGetSelector with: self container ] ] ] ifFalse: [ self rowMorphGetSelector numArgs = 2 ifTrue: [ self rowMorphGetSelector ] ifFalse: [ [:node :cont |  self rowMorphGetSelector value: node ] ] ]specialKeyPressed: anEvent  | keyString max nextSelection oldSelection howManyItemsShowing |  keyString := anEvent keyString.  keyString = '<escape>' ifTrue: [ ^ActiveEvent shiftPressed ifTrue: [ self currentWorld invokeWorldMenuFromEscapeKey ] ifFalse: [ (self yellowButtonActivity: false) ifTrue: [ ^self ] ] ].  keyString = '<cr>' ifTrue: [ self selectSearchedElement ].  max := self maximumSelection.  max > 0 ifFalse: [ ^self ].  nextSelection := oldSelection := self getCurrentSelectionIndex.  keyString = '<down>' ifTrue: [ self resetListSelectionSilently.        nextSelection := oldSelection + 1.        nextSelection > max ifTrue: [ nextSelection := max ] ].  keyString = '<up>' ifTrue: [ self resetListSelectionSilently.        nextSelection := oldSelection - 1.        nextSelection < 1 ifTrue: [ nextSelection := 1 ] ].  keyString = '<home>' ifTrue: [ self resetListSelectionSilently.        nextSelection := 1 ].  keyString = '<end>' ifTrue: [ self resetListSelectionSilently.        nextSelection := max ].  howManyItemsShowing := self numSelectionsInView.  keyString = '<pageUp>' ifTrue: [ self resetListSelectionSilently.        nextSelection := 1 max: oldSelection - howManyItemsShowing ].  keyString = '<pageDown>' ifTrue: [ self resetListSelectionSilently.        nextSelection := oldSelection + howManyItemsShowing min: max ].  (self enabled and: [ model okToChange ]) ifFalse: [ ^self ].  oldSelection = nextSelection ifTrue: [ ^self ].  ^self changeModelSelection: nextSelectionpassiveDisabledOverUpFillStyle: aFillStyle  self stateMap atPath: #(passive disabled over up) put: aFillStyle.  self changedgetList  getListSelector == nil ifTrue: [ ^#() ].  list := model perform: getListSelector.  list == nil ifTrue: [ ^#() ].  list := list collectWithIndex: [:item :index |  self wrapItem: item index: index ].  ^listsetWidth: width  self extent: width @ (self fontToUse height ceiling + (2 * self offset))mouseMove: evt  self eventHandler ifNotNil: [ self eventHandler mouseMove: evt fromMorph: self ]newTitle: aString for: control  ^self theme newTitleIn: self label: aString for: controlhShowScrollbar  self hResizeScrollbar.  self hScrollbarShowing ifTrue: [ ^self ].  self privateAddMorph: self hScrollbar atIndex: 1.  self vResizeScrollbar.  self resizeScrollercolumns  ^columns ifNil: [ self columns: (OrderedCollection with: MorphTreeColumn new).        columns ]rootItem: anObject  rootItem := anObjectmouseUp: evt  super mouseUp: evt.  self enabled ifFalse: [ ^self ].  self down: false.  (self containsPoint: evt cursorPoint) ifTrue: [ upAction value ]searchedFrame  ^searchedElement ifNotNil: [:elt |  elt bounds: elt selectionFrame in: self ]isUserInterrupt  ^UserInterruptHandler cmdDotEnabled and: [ self keyCharacter = $. and: [ self commandKeyPressed ] ]wouldAcceptKeyboardFocus  ^falseexpandedButton  ^IconicButton new     target: self;     actionSelector: #collapseAndRefresh;     arguments: {};     labelGraphic: self class expandedForm;     color: Color transparent;     helpText: 'Unexpand Item';     borderWidth: 0newTreeFor: aModel list: listSelector selected: getSelector changeSelected: setSelector  ^self theme newTreeIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelectorpositionWhenComposed: pos  positionWhenComposed := posdoubleClick: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #doubleClick from: sourceMorphlabel: aStringOrMorph selected: selectedStringOrMorph  | l s |  l := aStringOrMorph isMorph ifTrue: [ aStringOrMorph ] ifFalse: [ (self theme buttonLabelForText: aStringOrMorph)           vResizing: #shrinkWrap;           hResizing: #shrinkWrap ].  s := selectedStringOrMorph isMorph ifTrue: [ selectedStringOrMorph ] ifFalse: [ (self theme buttonLabelForText: selectedStringOrMorph)           vResizing: #shrinkWrap;           hResizing: #shrinkWrap ].  self     normalLabel: l;     selectedLabel: s;     selected: self isSelecteddisable  self enabled: falseinitializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #SimpleHierarchicalList.  aKMDispatcher attachCategory: #MorphFocusNavigationboundsIn: referenceMorph  ^self bounds: self bounds in: referenceMorphminHeight  | iconHeight |  iconHeight := self hasIcon ifTrue: [ self icon height + 2 ] ifFalse: [ 0 ].  ^self fontToUse height max: iconHeightdisplayInLine: line onAthensCanvas: anAthensCanvas  | startIdx stopIdx leftX rightX |  startIdx := first stringIndex.  stopIdx := last stringIndex.  (stopIdx < line first or: [ startIdx > (line last + 1) ]) ifTrue: [ ^self ].  (stopIdx = line first and: [ last textLine ~= line ]) ifTrue: [ ^self ].  (startIdx = (line last + 1) and: [ last textLine ~= line ]) ifTrue: [ ^self ].  leftX := (startIdx < line first ifTrue: [ line ] ifFalse: [ first ]) left.  rightX := (stopIdx > (line last + 1) or: [ stopIdx = (line last + 1) and: [ last textLine ~= line ] ]) ifTrue: [ line right ] ifFalse: [ last left ].  anAthensCanvas setPaint: color.  anAthensCanvas drawShape: (leftX @ line top corner: rightX @ line bottom)initialize  super initialize.  self     borderWidth: 0;     changeTableLayout;     cellPositioning: #topLeft;     cellInset: 0 @ -1;     reverseTableCells: true;     pageMorphs: OrderedCollection new;     tabSelectorMorph: self newTabSelectorMorph;     contentMorph: self newContentMorph;     addMorph: self tabSelectorMorph;     addMorph: self contentMorph.  self tabSelectorMorph addDependent: self= aBorderStyle  ^self species = aBorderStyle species and: [ self style == aBorderStyle style and: [ self width = aBorderStyle width and: [ self color = aBorderStyle color ] ] ]hasToggle  ^self canExpandtype  ^typeprepareForRotating  ^self addFlexShelltoggleAvoidVisibleBordersAtEdge  self avoidVisibleBordersAtEdge: self avoidVisibleBordersAtEdge notupdatePressedImage  self pressedImage: (target perform: pressedImageSelector)indentGap  ^container indentGap * indentLevelnewSliderFor: aModel getValue: getSel setValue: setSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: 0 max: 1 quantum: nil getEnabled: nil help: helpTexthUnadjustedScrollRange  | submorphBounds |  submorphBounds := scroller localSubmorphBounds ifNil: [ ^0 ].  ^submorphBounds rightlabelRect  ^self innerBounds withHeight: self labelHeightborderStyle: newStyle  | newExtent |  self borderStyle = newStyle ifTrue: [ ^self ].  super borderStyle: newStyle.  newExtent := 2 * newStyle width + image extent min asPoint.  bounds extent = newExtent ifFalse: [ self extent: newExtent ]addStandardHaloMenuItemsTo: aMenu hand: aHandMorph  aMenu add: 'send to back' selector: #goBehind.  aMenu add: 'bring to front' selector: #comeToFront.  self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.  aMenu addLine.  self addFillStyleMenuItems: aMenu hand: aHandMorph.  self addBorderStyleMenuItems: aMenu hand: aHandMorph.  self addDropShadowMenuItems: aMenu hand: aHandMorph.  self addLayoutMenuItems: aMenu hand: aHandMorph.  self addHaloActionsTo: aMenu.  owner isTextMorph ifTrue: [ self addTextAnchorMenuItems: aMenu hand: aHandMorph ].  aMenu addLine.  self addToggleItemsToHaloMenu: aMenu.  aMenu addLine.  self addExportMenuItems: aMenu hand: aHandMorph.  self addMiscExtrasTo: aMenu.  self addDebuggingItemsTo: aMenu hand: aHandMorph.  aMenu addLine.  aMenu defaultTarget: aHandMorphisMenuMorph  ^trueaddActionsToIcon  closeIcon     on: #mouseEnter send: #mouseEnterIcon to: self;     on: #click send: #close to: self;     on: #mouseLeave send: #mouseLeaveIcon to: selfnewLabelFor: aModel label: aString getEnabled: enabledSel  ^self theme newLabelIn: self for: aModel label: aString getEnabled: enabledSeltaskbarButtonEntered: aButton event: evt in: aMorph  aButton owner ifNotNil: [:buttonBar |  | thumb |        buttonBar showWindowPreview ifFalse: [ ^self ].        thumb := self valueOfProperty: #taskbarThumbnail.        thumb ifNil: [ thumb := self theme newTaskbarThumbnailIn: self for: self ] ifNotNil: [ ^self ].        self setProperty: #taskbarThumbnail toValue: thumb.        thumb bottomLeft: (aButton left min: aButton owner right - thumb width) @ (aButton owner top - 4).        thumb openInWorld ]lastItem  submorphs reverseDo: [:each |  each isMenuItemMorph ifTrue: [ ^each ] ].  ^submorphs lastchangeProportionalLayout  | layout |  ((layout := self layoutPolicy) notNil and: [ layout isProportionalLayout ]) ifTrue: [ ^self ].  self layoutPolicy: ProportionalLayout new.  self layoutChangedimageMorph  ^imageMorphnewTransformationMorph  ^TransformationMorph newnumberOfColumns  ^columns sizeflashFinished: flashFill original: originalFill  self fillStyle == flashFill ifTrue: [ self fillStyle: originalFill ]resetExtent  self resizeScrollerballoonTextSelector: anObject  balloonTextSelector := anObject.  self updateBalloonTexticonBlock  ^iconBlock ifNil: [ [:node |  node icon ] ]fallbackMenuOn: menu  menu addToggle: 'Close' translated target: self selector: #closeBoxHit getStateSelector: nil enablementSelector: #allowedToClose.  menu lastItem icon: self theme windowCloseForminitializeSlider  self     initializeUpButton;     initializeDownButton;     initializePagingArea.  super initializeSlider.  self sliderColor: self sliderColor.  self slider     width: self theme scrollbarThickness;     height: self theme scrollbarThickness.  slider cornerStyle: (self theme scrollbarThumbCornerStyleIn: self window).  slider on: #mouseEnter send: #mouseEnterThumb: to: self.  slider on: #mouseLeave send: #mouseLeaveThumb: to: selfname: aName  aName isString ifTrue: [ self setNameTo: aName ]scale  ^transform scaleinspectOwnerChain  self ownerChain inspectWithLabel: 'Owner chain for ' , self printStringtestIntoWorldDeleteOutOfWorld  | m1 m2 |  m1 := TestInWorldMorph new.  m2 := TestInWorldMorph new.  self assert: m1 intoWorldCount equals: 0.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 0.  self assert: m2 outOfWorldCount equals: 0.  morph addMorphFront: m1.  m1 addMorphFront: m2.  self assert: m1 intoWorldCount equals: 0.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 0.  self assert: m2 outOfWorldCount equals: 0.  morph openInWorld.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 0.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 0.  morph delete.  self assert: m1 intoWorldCount equals: 1.  self assert: m1 outOfWorldCount equals: 1.  self assert: m2 intoWorldCount equals: 1.  self assert: m2 outOfWorldCount equals: 1mouseStillDownStepRate  ^10newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpTexthandleUnknownEvent: anEvent  self inform: 'Unknown event: ' , anEvent printString.  anEvent printString displayAt: 0 @ 0.  anEvent wasHandled: truemouseEnterDragging: anEvent onItem: aMorph  self deprecated: 'This feature is not working and will be removed.' on: '07-28-2019' in: #Pharo8.  self removeObsoleteEventHandlersboundsForBalloon  | ownerOwner |  ^((owner notNil and: [ (ownerOwner := owner owner) notNil ]) and: [ ownerOwner isKindOf: PluggableListMorph ]) ifTrue: [ self boundsInWorld intersect: ownerOwner boundsInWorld ifNone: [ self boundsInWorld ] ] ifFalse: [ super boundsForBalloon ]initialize  super initialize.  self color: self theme textColor.  font := StandardFonts listFont.  listItems := #().  selectedRows := PluggableSet integerSet.  self adjustHeightwithSiblingsDo: aBlock  | node |  node := self.  [ node isNil ] whileFalse: [ aBlock value: node.        node := node nextSibling ]adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self color: paneColorhandlesMouseOverDragging: evt  self eventHandler ifNotNil: [ ^self eventHandler handlesMouseOverDragging: evt ].  ^falseupdateList  (showIndex < self dataSource numberOfRows and: [ self isIndexVisible: showIndex ]) ifFalse: [ self resetPosition ].  self basicUpdateSelectionIndex.  (self hasSelection and: [ self isIndexVisible: self selectedIndex ]) ifFalse: [ self resetPosition.        self ensureVisibleFirstSelection ].  self refreshinteractWithSelectedItem  self selection ifNotNil: [:sel |  sel submorphs do: [:each |  each update: #interact ] ]setLabelFont: aFont  label ifNil: [ ^self ].  label font: aFontisExplicit  ^field isNotNildeleteDiscardingChanges  | thisWorld announcement animateClose |  animateClose := self visible and: [ self world notNil and: [ self theme shouldUseAnimations and: [ self theme animationSettings animateClosing ] ] ].  self removePaneSplitters.  thisWorld := self world.  self isFlexed ifTrue: [ owner delete ] ifFalse: [ super delete ].  model ifNotNil: [ model           windowIsClosing;           releaseActionMap ].  model := nil.  animateClose ifTrue: [ self animateClose ].  SystemWindow noteTopWindowIn: thisWorld.  announcement := WindowClosed new     window: self;     yourself.  self announce: announcement.  self currentWorld announcer announce: announcementaddFullHandles  self addCircleHandlesisForDragging  ^location isNilavailableRows  ^expanded ifTrue: [ children inject: 1 into: [:sum :each |  sum + each availableRows ] ] ifFalse: [ 1 ]min: anObject  min := anObject.  self setValue: self valuewantsDroppedMorph: aMorph event: anEvent  ^self model wantsDroppedMorph: aMorph event: anEvent inMorph: selfaddBorderStyleMenuItems: aMenu hand: aHandMorph  | subMenu |  subMenu := UIManager default newMenuIn: self for: self.  subMenu add: 'border width...' selector: #changeBorderWidth:.  subMenu add: 'border color...' selector: #changeBorderColor:.  subMenu addLine.  BorderStyle borderStyleChoices do: [:sym |  (self borderStyleForSymbol: sym) ifNotNil: [ subMenu add: sym target: self selector: #setBorderStyle: argument: sym ] ].  aMenu add: 'border style' subMenu: subMenusavePatchFrom: aCanvas  | damageRect myBnds |  damageRect := myBnds := self fullBounds.  savedPatch ifNotNil: [ damageRect := myBnds merge: (savedPatch offset extent: savedPatch extent) ].  (savedPatch isNil or: [ savedPatch extent ~= myBnds extent ]) ifTrue: [ savedPatch := aCanvas form allocateForm: myBnds extent ].  aCanvas contentsOfArea: (myBnds translateBy: aCanvas origin) into: savedPatch.  savedPatch offset: myBnds topLeft.  ^damageRectsetValueSelector: anObject  setValueSelector := anObjectmainPanel  ^self paneMorphs isEmpty ifFalse: [ self paneMorphs first ]collapseAll  children do: #collapseAllitemMorphFor: anObject index: anIndex  | item icon |  item := IconicListItem new     originalObject: anObject;     yourself.  icon := self getIconSelector ifNotNil: [ self model perform: self getIconSelector withEnoughArguments: {anObject .               anIndex} ].  icon ifNotNil: [ item icon: icon asMorph ].  item morph: (self wrapItem: anObject index: anIndex) asMorph.  ^itemdisableFunction  function isExplicit ifTrue: [ function disable.        self resizeAllSubviews ].  function := FTNilFunction table: selfdefaultBorderColor  ^self theme settings flatMenu ifFalse: [ #inset ] ifTrue: [ self theme settings derivedMenuColor muchDarker ]sentTo: anObject  type == #mouseDown ifTrue: [ ^anObject handleMouseDown: self ].  type == #mouseUp ifTrue: [ ^anObject handleMouseUp: self ].  ^super sentTo: anObjectmorphicLayerNumber  ^self valueOfProperty: #morphicLayerNumber ifAbsent: [ stayUp ifTrue: [ 100 ] ifFalse: [ 10 ] ]fullscreenMode: aValue  Display fullscreenMode: aValue.  self checkForNewScreenSizelockUnlockMorph  self isLocked ifTrue: [ self unlock ] ifFalse: [ self lock ]doDirection: anEvent with: directionHandle  anEvent hand obtainHalo: self.  self removeAllHandlesBut: directionHandlegradientWithColor: aColor  | ramp |  ramp := {(0.0 -> Color white) .   (1.0 -> aColor)}.  ^(GradientFillStyle ramp: ramp)     radial: true;     origin: self bounds origin;     direction: 0 @ 223;     normal: 223 @ 0rectangleOval  self setVertices: self bounds cornersnewColorPresenterMorph  ^self newColorPresenterFor: self getColor: #selectedColor help: 'Shows the selected color' translatednameColumn: column row: rowIndex  ^FTCellMorph new     color: (self colorFor: rowIndex);     cellInset: 5;     addMorphBack: (self iconFor: rowIndex) asMorph;     addMorphBack: (self elementAt: rowIndex) name asStringMorph;     yourselfdefaultFillStyle  ^Color grayhasArrows  ^(closed or: [ arrows == #none or: [ vertices size < 2 ] ]) notisEnabledMatchingTheState: aBoolean  ^self subclassResponsibilityfirst  ^firstIndextabSelectorMorph  ^tabSelectorMorphscrollUpByPageDelta  self scrollUp: self pageDeltacolorFor: index  ^Color transparentselectNodePath: anArray  | found |  anArray ifNil: [ ^self ].  anArray isEmpty ifTrue: [ ^self ].  self withSiblingsDo: [:each |  found ifNil: [ (each complexContents = anArray first or: [ anArray first isNil ]) ifTrue: [ found := each ] ] ].  found ifNotNil: [ anArray size = 1 ifTrue: [ ^container listManager addToSelection: found ].        found firstChild ifNotNil: [:fc |  fc selectNodePath: anArray allButFirst ] ]tabResetSelection: aTab  self setTabContentFrom: aTabchunkSize  ^pageSizeselectedTab  ^toolbar selectedTabgetSelectionIndexOf: aMorph  ^aMorph ifNil: [ 0 ] ifNotNil: [ aMorph index ]asDraggableMorph  ^self thumbnailOfSize: self header fullBounds extentreverseTableCells: aBool  reverseTableCells := aBoolisNotMaximized  ^self unexpandedFrame isNilhIsScrolled  ^scroller offset x > 0findAndSelect: aRegex startingAt: anIndex searchBackwards: searchBackwards  | where |  self handleEdit: [ where := self editor findAndSelect: aRegex startingAt: anIndex searchBackwards: searchBackwards ].  editView scrollSelectionIntoView.  ^wheremouseLeaveThumb: event  | buttonFillStyle buttonBorderStyle |  event redButtonPressed ifFalse: [ slider           fillStyle: self normalThumbFillStyle;           borderStyle: self normalThumbBorderStyle;           changed ].  (self containsPoint: event position) ifTrue: [ buttonFillStyle := self mouseOverPagingAreaButtonFillStyle.        buttonBorderStyle := self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ buttonFillStyle := self normalButtonFillStyle.        buttonBorderStyle := self normalButtonBorderStyle ].  upButton     fillStyle: buttonFillStyle;     borderStyle: buttonBorderStyle.  downButton     fillStyle: buttonFillStyle;     borderStyle: buttonBorderStylenewBalloonHelp: aTextStringOrMorph for: aMorph corner: cornerSymbol  ^self theme newBalloonHelpIn: self contents: aTextStringOrMorph for: aMorph corner: cornerSymboleditView  ^editViewoutermostOwnerWithYellowButtonMenu  | outermost |  outermost := self outermostMorphThat: [:ea |  ea isWorldMorph not and: [ ea hasYellowButtonMenu ] ].  ^outermost ifNil: [ self hasYellowButtonMenu ifTrue: [ self ] ifFalse: [  ] ]withSearch  ^withSearch ifNil: [ withSearch := false ]selectedColor: aColor  self basicSelectedColor: aColor.  self hsvaMorph selectedColor: aColorbeNotResizable  resizable := falsescaleFor: viewedMorphBox in: myBox  | scale scaleX scaleY ratio factor |  scaleX := myBox width asFloat / viewedMorphBox width.  scaleY := myBox height asFloat / viewedMorphBox height.  ratio := scaleX / scaleY.  factor := 1.0 / EccentricityThreshhold.  ratio < factor ifTrue: [ scale := scaleX @ (factor * scaleY) ] ifFalse: [ ratio > EccentricityThreshhold ifTrue: [ scale := (factor * scaleX) @ scaleY ] ifFalse: [ scale := scaleX min: scaleY ] ].  ^scaledefaultColor  ^self theme windowColorstyle  ^styleselectedPageIndex  ^self tabSelectorMorph selectedIndexupdate: aSymbol  super update: aSymbol.  aSymbol == #selectedIndex ifTrue: [ self updatePageIndex: self selectedPageIndex ]forceDisplayUpdate  ^Display forceDisplayUpdatemultipleSelection: anObject  multipleSelection := anObjectover  ^overisWindowEvent  ^trueoffImage  ^offImageonColor: aColor  onColor := aColormouseUp: event  | nodeMorph wasHigh |  self enabled ifFalse: [ ^self ].  mouseOverAllowed := false.  nodeMorph := self scrollerSubMorphFromPoint: event position.  wasHigh := nodeMorph notNil ifTrue: [ nodeMorph highlightedForMouseDown ] ifFalse: [ false ].  self allNodeMorphs do: [:m |  m highlightedForMouseDown ifTrue: [ m highlightForMouseDown: false ] ].  wasHigh ifFalse: [ nodeMorph ifNotNil: [ ^self ] ].  self listManager mouseUp: event on: nodeMorphtransformBy: aMorphicTransform  position := aMorphicTransform globalPointToLocal: positionsetShadowOffset: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self shadowPoint: newPoint ].  evt hand attachMorph: handle.  handle startSteppinghighlightedForDrop  ^(self valueOfProperty: #highlightedForDrop) == trueicon: anObject  icon := anObjectnewLabelGroup: labelsAndControls  ^self theme newLabelGroupIn: self for: labelsAndControlsmouseDownHighlightColor  | colored |  colored := self color isTransparent ifTrue: [ self firstOwnerSuchThat: [:o |  o isWorldOrHandMorph not and: [ o color isTransparent not ] ] ] ifFalse: [ self ].  colored ifNil: [ ^Color black ].  ^colored color luminance > 0.5 ifTrue: [ Color black ] ifFalse: [ Color white ]dragTransferType: aSymbol  transferType := aSymbolselectionColorToUse: aColor  aColor = self selectionColorToUse ifTrue: [ ^self ].  selectionColorToUse := aColor.  self listMorph selectionFrameChangeddoOneCycle  worldState doOneCycleFor: selfdropHighlightColor  ^Color bluewantsRoundedCorners  ^self theme currentSettings preferRoundCornerrealSearch  self initializeNewSearch.  dataSource rootsItems do: [:item |  self searchIn: item ] displayingProgress: [:each |  'Looking inside ' , each name ].  ^result asArrayframePolygon: vertices on: aCanvas  | dir1 dir2 dir3 nrm1 nrm2 nrm3 point1 point2 point3 cross1 cross2 pointA pointB pointC pointD w p1 p2 p3 p4 balloon ends pointE pointF |  balloon := aCanvas asBalloonCanvas.  balloon == aCanvas ifFalse: [ balloon deferred: true ].  ends := Array new: 6.  w := width * 0.5.  pointA := nil.  1 to: vertices size do: [:i |  p1 := vertices atWrap: i.        p2 := vertices atWrap: i + 1.        p3 := vertices atWrap: i + 2.        p4 := vertices atWrap: i + 3.        dir1 := p2 - p1.        dir2 := p3 - p2.        dir3 := p4 - p3.        i = 1 | true ifTrue: [ cross1 := dir2 crossProduct: dir1.              nrm1 := dir1 normalized.              nrm1 := (nrm1 y * w) @ ((0 - nrm1 x) * w).              nrm2 := dir2 normalized.              nrm2 := (nrm2 y * w) @ ((0 - nrm2 x) * w).              cross1 < 0 ifTrue: [ nrm1 := nrm1 negated.                    nrm2 := nrm2 negated ].              point1 := (p1 x + nrm1 x) @ (p1 y + nrm1 y).              point2 := (p2 x + nrm2 x) @ (p2 y + nrm2 y).              pointA := self intersectFrom: point1 with: dir1 to: point2 with: dir2.              point1 := (p1 x - nrm1 x) @ (p1 y - nrm1 y).              point2 := (p2 x - nrm2 x) @ (p2 y - nrm2 y).              pointB := (point1 + dir1 + point2) * 0.5.              pointB := p2 + ((pointB - p2) normalized * w).              pointC := point2 ].        cross2 := dir3 crossProduct: dir2.        nrm2 := dir2 normalized.        nrm2 := (nrm2 y * w) @ ((0 - nrm2 x) * w).        nrm3 := dir3 normalized.        nrm3 := (nrm3 y * w) @ ((0 - nrm3 x) * w).        cross2 < 0 ifTrue: [ nrm2 := nrm2 negated.              nrm3 := nrm3 negated ].        point2 := (p2 x + nrm2 x) @ (p2 y + nrm2 y).        point3 := (p3 x + nrm3 x) @ (p3 y + nrm3 y).        pointD := self intersectFrom: point2 with: dir2 to: point3 with: dir3.        point2 := (p2 x - nrm2 x) @ (p2 y - nrm2 y).        point3 := (p3 x - nrm3 x) @ (p3 y - nrm3 y).        pointF := point2 + dir2.        pointE := (pointF + point3) * 0.5.        pointE := p3 + ((pointE - p3) normalized * w).        cross1 * cross2 < 0.0 ifTrue: [ ends                 at: 1 put: pointA;                 at: 2 put: pointB;                 at: 3 put: pointC;                 at: 4 put: pointD;                 at: 5 put: pointE;                 at: 6 put: pointF ] ifFalse: [ ends                 at: 1 put: pointA;                 at: 2 put: pointB;                 at: 3 put: pointC;                 at: 4 put: pointF;                 at: 5 put: pointE;                 at: 6 put: pointD ].        self drawPolyPatchFrom: p2 to: p3 on: balloon usingEnds: ends.        pointA := pointD.        pointB := pointE.        pointC := pointF.        cross1 := cross2 ].  balloon == aCanvas ifFalse: [ balloon flush ]adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self fillStyle: self normalFillStyleverifyContents  | newList existingSelection oldList |  oldList := list ifNil: [ #() ].  newList := self getList.  (oldList == newList or: [ oldList = newList ]) ifTrue: [ ^self ].  existingSelection := oldList isEmpty ifTrue: [ self listMorph selectedRow ] ifFalse: [ (self selectionIndex between: 1 and: newList size) ifTrue: [ self selectionIndex ] ifFalse: [ nil ] ].  self updateList.  existingSelection notNil ifTrue: [ self selectionIndex: existingSelection ] ifFalse: [ self changeModelSelection: 0 ]popUpInWorld  ^self popUpInWorld: self currentWorldprivateOwner: aMorph  owner := aMorphvUnadjustedScrollRange  scroller submorphs size > 0 ifFalse: [ ^0 ].  ^scroller submorphs last fullBounds bottomjustifiedTabDeltaFor: spaceIndex  | pad extraPad |  internalSpaces = 0 ifTrue: [ ^0 ].  pad := paddingWidth // internalSpaces.  extraPad := paddingWidth \\ internalSpaces.  spaceIndex <= extraPad ifTrue: [ ^spaceIndex * (pad + 1) ] ifFalse: [ ^extraPad * (pad + 1) + ((spaceIndex - extraPad) * pad) ]newRadioButtonFor: aModel getSelected: getSel setSelected: setSel label: stringOrText help: helpText  ^self newRadioButtonFor: aModel getSelected: getSel setSelected: setSel getEnabled: nil label: stringOrText help: helpTextminimumSelection  ^1lastCharacterIndex  ^lines last lastgetFontSelector: anObject  getFontSelector := anObject.  self update: getFontSelectorasLayoutFrame  ^selfcreateTaskbarIfNecessary  self taskbars ifEmpty: [ TaskbarMorph new openInWorld: self.        self moveCollapsedWindowsToTaskbar ]selectionIndex: index  | row |  self unhighlightSelection.  row := index ifNil: [ 0 ].  row := row min: self maximumSelection.  self listMorph selectedRow: row.  self highlightSelection.  self scrollSelectionToRow: rowdeferUpdates: aValue  ^aValue valuedefaultLineHeight  ^textStyle lineGridgetHelpSelector: aSymbol  getHelpSelector := aSymboldrawSubmorphsOnAthensCanvas: anAthensCanvas  super drawSubmorphsOnAthensCanvas: anAthensCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOnAthensCanvas: anAthensCanvas ]is: anIndex bellowRow: aRowIndex  ^anIndex first > aRowIndexactions: aCollection  actions := aCollection.  self triggerEvent: #actionsChanged with: selfopenAsIsIn: aWorld  self playOpenSound.  aWorld addMorph: self.  self activate.  aWorld startSteppingSubmorphsOf: self.  self announceOpened.  self currentWorld announcer announce: (WindowOpened new           window: self;           yourself)outerBounds  | box |  box := super outerBounds.  container ifNil: [ ^box ].  ^box left: (box left min: self selectionFrame left)slideIndexBy: delta andMoveTopTo: newTop  firstIndex := firstIndex + delta.  lastIndex := lastIndex + delta.  bottom := bottom + (newTop - top).  top := newTopcheckWidth  ^10styleInBackgroundProcess: aText  text: t textStyle: s wrap: wrap color: c predecessor: pred successor: succ  text := t.  defaultColor := (t attributesAt: 1) detect: [:e |  e isKindOf: TextColor ].  textStyle := s.  wrapFlag := wrap.  color := c.  paragraph := editor := container := nil.  self predecessor: pred successor: succbasicHighlightIndexes: anArray  highlightedIndexes := anArray asArrayfullBounds  fullBounds ifNotNil: [ ^fullBounds ].  fullBounds := bounds.  submorphs do: [:m |  m ownerChanged ].  ^fullBoundsgetFontSelector  ^getFontSelectorborderWidthForItems: widthCollection  (selectedItems select: [:m |  m isKindOf: BorderedMorph ]) with: widthCollection do: [:m :c |  m borderWidth: c ]tabsChanged  filledForm  | bb origin |  closed ifFalse: [ ^filledForm := nil ].  filledForm ifNotNil: [ ^filledForm ].  filledForm := Form extent: bounds extent + 2.  bb := (BitBlt toForm: filledForm)     sourceForm: nil;     fillColor: Color black;     combinationRule: Form over;     width: 1;     height: 1.  origin := bounds topLeft asIntegerPoint - 1.  self lineSegmentsDo: [:p1 :p2 |  bb drawFrom: p1 asIntegerPoint - origin to: p2 asIntegerPoint - origin ].  filledForm convexShapeFill: Color black.  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) ifTrue: [ filledForm copy: self borderForm boundingBox from: self borderForm to: 1 @ 1 rule: Form erase ].  ^filledFormaddCellLayoutMenuItems: aMenu hand: aHand  | menu sub |  menu := UIManager default newMenuIn: self for: self.  menu addUpdating: #hasDisableTableLayoutString selector: #changeDisableTableLayout.  menu addLine.  sub := UIManager default newMenuIn: self for: self.  #(#rigid #shrinkWrap #spaceFill) do: [:sym |  sub addUpdating: #hResizingString: target: self selector: #hResizing: argumentList: (Array with: sym) ].  menu add: 'horizontal resizing' subMenu: sub.  sub := UIManager default newMenuIn: self for: self.  #(#rigid #shrinkWrap #spaceFill) do: [:sym |  sub addUpdating: #vResizingString: target: self selector: #vResizing: argumentList: (Array with: sym) ].  menu add: 'vertical resizing' subMenu: sub.  aMenu ifNotNil: [ aMenu add: 'child layout' subMenu: menu ].  ^menuflash  | originalFill flashFill |  flashFill := self flashFillStyle.  originalFill := self fillStyle.  self fillStyle: flashFill.  self addAlarm: #flashFinished:original: withArguments: {flashFill .         originalFill} after: 50grabTransform  self renderedMorph isWorldMorph ifTrue: [ ^owner ifNil: [ IdentityTransform new ] ifNotNil: [ owner grabTransform ] ].  ^owner ifNil: [ self transform ] ifNotNil: [ owner grabTransform composedWithLocal: self transform ]isInDockingBar  ^owner notNil and: [ owner isDockingBar ]selectFirst  self selectionModeStrategy selectFirstfindText  ^self editor findTextlabel  ^labelmouseDown: evt  | grabbedMorph handHadHalos |  (self class isMenuOpenByLeftClick ifTrue: [ evt yellowButtonPressed ] ifFalse: [ evt redButtonPressed ]) ifTrue: [ ^self popUpContentsMenu: evt ].  grabbedMorph := self morphToGrab: evt.  grabbedMorph ifNotNil: [ grabbedMorph isSticky ifTrue: [ ^self ].        ^evt hand grabMorph: grabbedMorph ].  (super handlesMouseDown: evt) ifTrue: [ ^super mouseDown: evt ].  handHadHalos := evt hand halo notNil.  evt hand removeHalo.  evt hand releaseKeyboardFocus.  (evt shiftPressed not and: [ self isWorldMorph not and: [ self wantsEasySelection not ] ]) ifTrue: [ evt wasHandled: false.        ^self ].  (evt shiftPressed or: [ self wantsEasySelection ]) ifTrue: [ | clickSelector |        evt shiftPressed ifTrue: [ clickSelector := #popUpContentsMenu: ] ifFalse: [ clickSelector := #invokeWorldMenu: ].        evt hand waitForClicksOrDrag: self event: evt selectors: {clickSelector .               nil .               nil .               #dragThroughOnDesktop:} threshold: 5 ] ifFalse: [ self invokeWorldMenu: evt ]privateFullMoveBy: delta  super privateFullMoveBy: delta.  self changed: #positionmouseDownRowFrameChanged  | frame row |  row := self mouseDownRow ifNil: [ ^self ].  frame := self selectionFrameForRow: row.  self invalidRect: frameforAction: anAction  | baseColor |  baseColor := self theme baseColor.  self extent: anAction icon extent.  self activeEnabledNotOverUpFillStyle: baseColor.  self activeDisabledNotOverUpFillStyle: (self theme buttonDisabledFillStyleFor: self).  self passiveEnabledNotOverUpFillStyle: baseColor.  self passiveDisabledNotOverUpFillStyle: baseColor.  self     activeEnabledOverUpFillStyle: (self theme buttonMouseOverFillStyleFor: self);     passiveEnabledOverUpFillStyle: (self theme buttonMouseOverFillStyleFor: self).  self     activeEnabledOverDownFillStyle: (self theme buttonPressedFillStyleFor: self);     passiveEnabledOverDownFillStyle: (self theme buttonPressedFillStyleFor: self);     addUpAction: [ anAction action value ];     setBalloonText: anAction label;     extent: 16 @ 16.  icon := anAction icon.  ^selfdoubleClickTimeout: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #doubleClickTimeout from: sourceMorphmaybeDuplicateMorph: evt  ^self duplicateMorph: evtselector  ^selectornewImageFor: aModel get: getSel help: helpText  ^self theme newImageIn: self for: aModel get: getSel help: helpTextshowVScrollBarOnlyWhenNeeded: bool  self setProperty: #noVScrollBarPlease toValue: bool.  self setProperty: #vScrollBarAlways toValue: bool.  self vHideOrShowScrollBartotalSliderArea  ^self innerBoundsbreakDependents  self removeProperty: #announcerremoveExpandBox  expandBox ifNotNil: [ expandBox delete.        expandBox := nil ]adoptPaneColor: paneColor  paneColor ifNil: [ ^super adoptPaneColor: paneColor ].  super adoptPaneColor: (self theme subgroupColorFrom: paneColor).  self contentMorph borderStyle: (self theme tabPanelBorderStyleFor: self)inspectAt: aPoint event: evt  | morphs target |  morphs := self morphsAt: aPoint.  (morphs includes: self) ifFalse: [ morphs := morphs copyWith: self ].  target := UIManager default chooseFrom: (morphs collect: [:t |  t class name asString ]) values: morphs title: 'inspect whom? (deepest at top)' translated.  target ifNil: [ ^self ].  target inspectInMorphic: evtinterCyclePause: milliSecs  | wait wait2 |  wait := self serverMode ifTrue: [ 50 ] ifFalse: [ wait2 := (lastCycleTime notNil and: [ CanSurrenderToOS ~~ false ]) ifFalse: [ 0 ] ifTrue: [ lastCycleTime + milliSecs - Time millisecondClockValue ].        self flag: 'Issue 14754 - wait2>millisecs is only True for clock rollover. Remove it once delay scheduler is based on microsecondClock - Ben Coman 19.01.2015'.        wait2 > milliSecs ifTrue: [ 0 ] ifFalse: [ wait2 ] ].  wait > 0 ifTrue: [ (Delay forMilliseconds: wait) wait ].  lastCycleTime := Time millisecondClockValue.  CanSurrenderToOS := truemodel  ^modelsetUp  super setUp.  cases := #()keyTextFont  ^self fontSized: self pointSize * 2areasRemainingToFill: aRectangle  ^Array with: aRectangleminExtent  | layout minExtent extra hFit vFit |  hFit := self hResizing.  vFit := self vResizing.  (hFit == #spaceFill or: [ vFit == #spaceFill ]) ifFalse: [ ^self fullBounds extent ].  layout := self layoutPolicy.  minExtent := layout ifNil: [ 0 @ 0 ] ifNotNil: [ layout minExtentOf: self in: self layoutBounds ].  minExtent := hFit == #rigid ifTrue: [ self fullBounds extent x @ minExtent y ] ifFalse: [ extra := self bounds width - self layoutBounds width.        (minExtent x + extra) @ minExtent y ].  minExtent := vFit == #rigid ifTrue: [ minExtent x @ self fullBounds extent y ] ifFalse: [ extra := self bounds height - self layoutBounds height.        minExtent x @ (minExtent y + extra) ].  minExtent := minExtent max: self minWidth @ self minHeight.  ^minExtentwidth: aNumber  addAllFrom: aMenuMorph  aMenuMorph submorphsDo: [:m |  self addMorphBack: m ]textEntryLabel: aLabel get: getSel set: setSel help: helpText class: aClass  ^RubPluggableTextFieldMorph new     on: self text: getSel accept: setSel readSelection: nil menu: nil;     setBalloonText: helpText;     yourselfdockingBars  ^self submorphs select: [:each |  each isDockingBar ]formOrMorphToView  | actualViewee |  objectToView isForm ifTrue: [ ^objectToView ].  actualViewee := viewSelector ifNil: [ objectToView ] ifNotNil: [ objectToView perform: viewSelector ].  ^actualViewee = 0 ifTrue: [ nil ] ifFalse: [ actualViewee ]frameRectangle: aRectangle on: aCanvas  aCanvas frameRectangle: aRectangle width: self width color: self colorcontentBounds  ^self fullBounds insetOriginBy: self indentGap @ 0 cornerBy: 0 @ 0columnDropUnabled  ^columnDropUnabledgapSize  ^gapSize ifNil: [ gapSize := 10 ]initialize  self stateMap: KeyedTree new.  enabled := true.  active := true.  over := false.  down := false.  super initializeenabled: aBoolean  enabled := aBoolean.  self labelMorph ifNotNil: [:m |  m enabled: aBoolean ].  self buttonMorph ifNotNil: [:m |  m enabled: aBoolean ].  self changed: #enableddrawSubmorphsOn: aCanvas  drawable ifFalse: [ ^self ].  super drawSubmorphsOn: aCanvasisFloating  ^self isHorizontal not and: [ self isVertical not ]isTextMorph  ^truecanvas  ^self worldRenderer canvaschangeColor  self setWindowColordoButtonAction  | newState |  (target notNil and: [ actionSelector notNil ]) ifTrue: [ newState := color = onColor.        target perform: actionSelector withArguments: (arguments copyWith: newState) ]newOKButtonFor: aModel getEnabled: enabledSel  ^self theme newOKButtonIn: self for: aModel getEnabled: enabledSelgradient  | b |  b := self innerBounds.  ^(GradientFillStyle colors: {Color white .         self color})     origin: b topLeft;     direction: b width @ 0filter  ^dataSource class root: (FTRootItem new           children: (dataSource rootsItems select: [:each |  (pattern matchesIn: (self dataSource toString: each)) notEmpty ]);           yourself) children: dataSource childrenBlockallStringsAfter: aSubmorph  | list ok |  list := OrderedCollection new.  ok := aSubmorph isNil.  self allMorphsDo: [:sub |  | string |        ok ifFalse: [ ok := sub == aSubmorph ].        ok ifTrue: [ (string := sub userString) ifNotNil: [ string isString ifTrue: [ list add: string ] ifFalse: [ list addAll: string ] ] ] ].  ^listaddCustomMenuItems: aCustomMenu hand: aHandMorph  super addCustomMenuItems: aCustomMenu hand: aHandMorph.  aCustomMenu add: 'change font' selector: #changeFont.  aCustomMenu add: 'change emphasis' selector: #changeEmphasisinitialize  super initialize.  self     color: self defaultColor;     borderWidth: self defaultBorderWidthinitialize  super initialize.  self sliderMorph: self newSliderMorph.  self     changeTableLayout;     listDirection: #leftToRight;     cellInset: 0;     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     borderColor: Color transparent;     addMorphBack: self newDecrementButton;     addMorphBack: self sliderMorph;     addMorphBack: self newIncrementButtonrelabelTab: aTab with: aStringOrMorph  aTab label: aStringOrMorph.  aTab owner ifNotNil: [ self updateTabs.        (aTab isSelected and: [ aTab isVisible not ]) ifTrue: [ self ensureSelectedTabIsVisible ] ]addStandardHaloMenuItemsTo: aMenu hand: aHandMorph  aMenu add: 'browse action' selector: #browseAction.  aMenu addLine.  super addStandardHaloMenuItemsTo: aMenu hand: aHandMorphanyButtonPressed  ^buttons anyMask: self class anyButtoncurrentWidth  ^currentWidth ifNil: [ currentWidth := self defaultWidth ]selectSearchedElement  self searchedElement ifNotNil: [:index |  ActiveEvent commandKeyPressed ifFalse: [ self resetListSelectionSilently ].        self changeModelSelection: index.        self isMultipleSelection ifTrue: [ self listSelectionAt: index put: true ].        self vScrollValue: (index - 1) / self getListSize ]maybeDuplicateMorph  ^self duplicate openInHandstartDrag: anEvent  | aTransferMorph itemMorph passenger |  self dragEnabled ifTrue: [ itemMorph := scroller submorphs detect: [:any |  any highlightedForMouseDown ] ifNone: [  ] ].  (itemMorph isNil or: [ anEvent hand hasSubmorphs ]) ifTrue: [ ^self ].  itemMorph highlightForMouseDown: false.  itemMorph ~= self selectedMorph ifTrue: [ self setSelectedMorph: itemMorph ].  passenger := dragItemSelector ifNil: [ self model dragPassengerFor: itemMorph withoutListWrapper inMorph: self ] ifNotNil: [ self model perform: dragItemSelector withEnoughArguments: {itemMorph withoutListWrapper .               self} ].  passenger ifNotNil: [ aTransferMorph := self model transferFor: passenger from: self.        aTransferMorph dragTransferType: #dragTransfer.        aTransferMorph align: aTransferMorph draggedMorph center with: anEvent position.        anEvent hand grabMorph: aTransferMorph ].  anEvent hand releaseMouseFocus: selftoggleDropShadow  self hasDropShadow ifTrue: [ self removeDropShadow ] ifFalse: [ self addDropShadow ]disabledBorderStyle  ^self theme controlButtonDisabledBorderStyleFor: selffullBounds  ^self perform: #fullBounds withArguments: #() inSuperclass: MorphveryDeepFixupWith: deepCopier  super veryDeepFixupWith: deepCopier.  model := deepCopier references at: model ifAbsent: [ model ]optimalExtent  ^self form extent * self scale + (self borderWidth * 2)stringColor  ^self enabled ifTrue: [ self color ] ifFalse: [ self theme labelDisabledColorFor: self ]getIndexSelector: aSelector  getIndexSelector := aSelectorframeRectangle5: aRectangle on: aCanvas  | r |  r := aRectangle insetBy: self width // 2.  self width odd ifTrue: [ r := r insetBy: (0 @ 0 corner: 1 @ 1) ].  aCanvas     line: r topLeft + (5 @ 0) to: r topRight - (5 @ 0) width: self width color: self color;     line: r topRight + (-4 @ 1) to: r topRight + (-2 @ 2) width: self width color: self color;     line: r topRight + (-1 @ 3) to: r topRight + (-1 @ 4) width: self width color: self color;     line: r topRight + (0 @ 5) to: r bottomRight - (0 @ 5) width: self width color: self color;     line: r bottomRight - (1 @ 4) to: r bottomRight - (2 @ 2) width: self width color: self color;     line: r bottomRight - (3 @ 1) to: r bottomRight - (4 @ 1) width: self width color: self color;     line: r bottomRight - (5 @ 0) to: r bottomLeft + (5 @ 0) width: self width color: self color;     line: r bottomLeft - (-4 @ 1) to: r bottomLeft - (-3 @ 1) width: self width color: self color;     line: r bottomLeft - (-2 @ 2) to: r bottomLeft - (-1 @ 4) width: self width color: self color;     line: r bottomLeft - (0 @ 5) to: r topLeft + (0 @ 5) width: self width color: self color;     line: r topLeft + (1 @ 4) to: r topLeft + (1 @ 3) width: self width color: self color;     line: r topLeft + (2 @ 2) to: r topLeft + (4 @ 1) width: self width color: self colorshowCaret: aBool  showCaret := aBooldrawDropShadowOn: aCanvas  aCanvas fillOval: bounds fillStyle: self shadowColor borderWidth: 0 borderColor: nilsecondName  ^secondNamewidth: aNumber  self extent: aNumber asInteger @ self heightstepTime  ^250lineColorForNode: aNode  ^lineColorBlock ifNotNil: [ lineColorBlock value: aNode ] ifNil: [ | colored |        colored := self color isTransparent ifTrue: [ self firstOwnerSuchThat: [:o |  o isWorldOrHandMorph not and: [ o color isTransparent not ] ] ] ifFalse: [ self ].        colored ifNil: [ Color black ] ifNotNil: [ colored color luminance > 0.5 ifTrue: [ Color black ] ifFalse: [ Color white ] ] ]doubleClickSelector  ^doubleClickSelectorproceed: aStringOrText title: aString  ^self theme proceedIn: self text: aStringOrText title: aStringupdate: aParameter  aParameter == self getStateSelector ifTrue: [ self updateSelection.        ^self ].  aParameter == self getEnabledSelector ifTrue: [ self updateEnabled.        ^self ].  aParameter == self getLabelSelector ifTrue: [ self updateLabel.        ^self ].  aParameter isArray ifFalse: [ ^self ].  aParameter size == 2 ifFalse: [ ^self ].  aParameter first = #labelClickable: ifTrue: [ self labelClickable: aParameter second ].  aParameter first = #label: ifTrue: [ self label: aParameter second ]search  ^self optionalOperations ifNotNil: [:res |  res ] ifNil: [ self realSearch ]updateTopHeader  self topHeader ifNotNil: [:th |  | w |        th width: scroller width.        w := self headerBounds.        th submorphsDo: [:sm |  w ifNotEmpty: [ sm                       bounds: w removeFirst;                       layoutInset: self columnInset @ 0 ] ] ]enableDragNDrop: aBoolean  self separateDragAndDrop.  self enableDrag: aBoolean.  self enableDrop: aBooleandropFiles: anEvent  initialize  super initialize.  selectedItems := OrderedCollection new.  itemsAlreadySelected := OrderedCollection new.  slippage := 0 @ 0type  ^typealert: aStringOrText title: aString  ^self alert: aStringOrText title: aString configure: [:d |   ]handlesMouseStillDown: evt  self eventHandler ifNotNil: [ ^self eventHandler handlesMouseStillDown: evt ].  ^falseinitialize  super initialize.  labelString ifNil: [ labelString := 'Untitled Window' ].  isCollapsed := false.  paneMorphs := Array new.  self layoutPolicy: ProportionalLayout new.  self clipSubmorphs: true.  self theme     configureWindowBorderFor: self;     configureWindowDropShadowFor: self.  self initializeLabelArea.  self cellPositioning: #topLeft.  self addGripsIfWanted.  self extent: (300 @ 200) scaledByDisplayScaleFactor.  mustNotClose := false.  updatablePanes := Array newdrawBoundsForRow: row  (row between: 1 and: listItems size) ifFalse: [ ^0 @ 0 corner: 0 @ 0 ].  ^(listItems at: row) boundsvalueOfProperty: aSymbol ifAbsent: aBlock  ^extension ifNotNil: [ extension valueOfProperty: aSymbol ifAbsent: aBlock ] ifNil: [ aBlock value ]newAlphaSelector: aModel getAlpha: getSel setAlpha: setSel help: helpText  ^self theme newAlphaSelectorIn: self for: aModel getAlpha: getSel setAlpha: setSel help: helpTextspotterPreviewMorphIn: aComposite  < spotterPreview: 20>  aComposite custom: (self imageForm asAlphaImageMorph asBrick margin: 20)tableRefresh  ^self table refreshisCollapsed  ^isCollapsedchangeRubberBandCells  self rubberBandCells: self rubberBandCells notmouseEnterPagingArea: event  pagingArea     fillStyle: self mouseOverFillStyle;     borderStyle: self mouseOverBorderStyle;     changed.  slider     fillStyle: self mouseOverPagingAreaThumbFillStyle;     borderStyle: self mouseOverPagingAreaThumbBorderStyle;     changed.  upButton     fillStyle: self mouseOverPagingAreaButtonFillStyle;     borderStyle: self mouseOverPagingAreaButtonBorderStyle;     changed.  downButton     fillStyle: self mouseOverPagingAreaButtonFillStyle;     borderStyle: self mouseOverPagingAreaButtonBorderStyle;     changedinitialExtent  | rl paneExt ext |  rl := self getRawLabel.  paneExt := self mainPanel ifNil: [ 0 @ 0 ] ifNotNil: [:pane |  pane minExtent ].  ext := paneExt + (2 @ self labelHeight) + (2 * self class borderWidth) max: rl extent + 20.  self isResizeable ifTrue: [ self title: self title.        self minimumExtent: (ext x max: self minimumExtent x) @ (ext y max: self minimumExtent y) ].  ^extfindWindow: evt  | menu expanded collapsed nakedMorphs |  menu := UIManager default newMenuIn: self for: self.  expanded := self windowsSatisfying: [:w |  w isCollapsed not ].  collapsed := self windowsSatisfying: [:w |  w isCollapsed ].  nakedMorphs := self submorphsSatisfying: [:m |  m isSystemWindow not ].  (expanded isEmpty and: [ collapsed isEmpty and: [ nakedMorphs isEmpty ] ]) ifTrue: [ ^self inform: 'No morph in world' ].  (expanded asSortedCollection: [:w1 :w2 |  w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [:w |  menu add: w label target: w selector: #activateAndForceLabelToShow.        w model canDiscardEdits ifFalse: [ menu lastItem color: Color red ] ].  (expanded isEmpty or: [ collapsed isEmpty and: [ nakedMorphs isEmpty ] ]) ifFalse: [ menu addLine ].  (collapsed asSortedCollection: [:w1 :w2 |  w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [:w |  menu add: w label target: w selector: #collapseOrExpand.        w model canDiscardEdits ifFalse: [ menu lastItem color: Color red ] ].  nakedMorphs isEmpty ifFalse: [ menu addLine ].  (nakedMorphs asSortedCollection: [:w1 :w2 |  w1 class name caseInsensitiveLessOrEqual: w2 class name ]) do: [:w |  menu add: w class name target: w selector: #comeToFrontAndAddHalo ].  menu addTitle: 'find window'.  menu popUpEvent: evt in: selftestIsAfterColumn  self assert: (strategy is: #(3 7) afterColumn: 4).  self deny: (strategy is: #(3 7) afterColumn: 9).  self deny: (strategy is: #(3 7) afterColumn: 7)lock: aBoolean  (extension isNil and: [ aBoolean not ]) ifTrue: [ ^self ].  self assureExtension locked: aBooleandefaultChunkSize  ^nilwantsToBeDroppedInto: aMorph  ^(aMorph isWorldMorph or: [ submorphs size = 1 ]) or: [ self embeddable ]copyWithoutSubmorph: sub  ^self shallowCopy privateSubmorphs: (submorphs copyWithout: sub)mouseLeave: evt  super mouseLeave: evt.  (owner notNil and: [ owner isKindOf: EmbeddedMenuMorph ]) ifTrue: [ owner selectedItem == self ifTrue: [ owner selectItem: nil event: evt ] ]canExpand  ^complexContents ifNotNil: [ complexContents hasContents ] ifNil: [ false ]morphicLayerNumber  ^7newRightButton  ^(ControlButtonMorph on: self getState: nil action: #scrollTabsRight label: #rightButtonLabel)     getEnabledSelector: #rightButtonEnabled;     hResizing: #rigid;     vResizing: #spaceFill;     cornerStyle: #square;     extent: self controlButtonWidth asPointvisible: aBoolean  super visible: aBoolean.  submorphs isEmptyOrNil ifFalse: [ submorphs first visible: aBoolean ]apply: delta  | oldBounds |  oldBounds := target bounds.  target bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))borderStyle  extension ifNil: [ ^BorderStyle default trackColorFrom: self ].  ^(extension borderStyle ifNil: [ BorderStyle default ]) trackColorFrom: selflastEvent  ^lastMouseEventtrimSize: anObject  trimSize := anObjectmaxCellSize: aPoint  self assureTableProperties maxCellSize: aPoint.  self layoutChangedstopStepping: aMorph  worldState stopStepping: aMorphchildrenDo: aBlock  firstChild ifNotNil: [ firstChild withSiblingsDo: [:aNode |  aBlock value: aNode ] ]showDirectionHandles: wantToShow addHandles: needHandles  directionArrowAnchor := wantToShow ifTrue: [ target referencePositionInWorld ] ifFalse: [ nil ].  needHandles ifTrue: [ self addHandles ]athensDisplay: items atRow: row on: anAthensCanvas  | drawBounds backgroundColor |  backgroundColor := self backgroundColorForRow: row.  drawBounds := self drawBoundsForRow: row.  drawBounds := drawBounds intersect: self bounds ifNone: [ ^self ].  items with: (1 to: items size) do: [:item :index |  index > 1 ifTrue: [ drawBounds := drawBounds left: drawBounds left + listSource gapSize + (columnWidths at: index - 1) ].        anAthensCanvas morphicDrawString: item asString at: drawBounds topLeft font: self font color: color ]defaultLabel  ^self printString truncateTo: 40extent: aPoint  super extent: aPoint.  self updateFillStyletestLastClickedMorphSetUponUpdateList  | c w t |  c := ClassTreeExample new.  [ w := c openOn: Collection.  t := c dependents last.  t expandAll.  c selectItems: {CharacterSet}.  self assert: t listManager lastClickedMorph notNil.  c rootClass: Bag.  c updateList.  self assert: t listManager lastClickedMorph isNil.  c selectItems: {Bag}.  self assert: t listManager lastClickedMorph notNil ] ensure: [ w close ]indexFromPosition: aTuple  ^aTuplerightFlush  self changeAlignment: #rightFlushisMoved  ^trueheightToDisplayInList: aList  ^self minExtent ynewNoButtonFor: aModel  ^self theme newNoButtonIn: self for: aModelwrapString  ^(wrapFlag ifTrue: [ '<yes>' ] ifFalse: [ '<no>' ]) , 'text wrap to bounds' translatedasTwoColorStrokePaintOn: anAthensCanvas  ^AthensBorderStrokePaint topLeftColor: self topLeftColor bottomRightColor: self bottomRightColor width: self width on: anAthensCanvasheaderLabel  ^headerLabelstepTime  ^self subMorph stepTimeballoonText: newValue  balloonText := newValueswapColumnAt: oneIndex withColumnAt: anotherIndex  self columns swap: oneIndex with: anotherIndex.  self columnsChanged.  self updateList.  self columnResizersToFronttextUpdated: anAnnouncement  self searchFor: field getTextFromModelinitialize  super initialize.  drawable := falseembeddedWindowOrNil  ^nilmargins  ^marginsadjacentTo  self owner isFloating ifTrue: [ ^{(self bounds bottomLeft + (3 @ 3)) .         (self bounds bottomRight + (5 @ 3))} ].  self owner isAdheringToTop ifTrue: [ ^{(self bounds bottomLeft + (5 @ 5))} ].  self owner isAdheringToLeft ifTrue: [ ^{(self bounds topRight + (5 @ 5))} ].  self owner isAdheringToBottom ifTrue: [ ^{(self bounds topLeft + (5 @ 5))} ].  self owner isAdheringToRight ifTrue: [ ^{(self bounds topLeft + (5 @ -5))} ].  ^{(self bounds bottomLeft + (3 @ 5))}newLabelGroup: labelsAndControls font: aFont labelColor: aColor  ^self theme newLabelGroupIn: self for: labelsAndControls font: aFont labelColor: aColoraddMorphInLayer: aMorph  super addMorphInLayer: aMorph.  aMorph wantsToBeTopmost ifFalse: [ self bringTopmostsToFront ]