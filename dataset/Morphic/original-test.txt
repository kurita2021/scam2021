selectedFillStyle  ^self theme tabLabelSelectedFillStyleFor: self-=JUAMPI=-printStructureOn: aStream indent: tabCount  tabCount timesRepeat: [ aStream tab ].  self printOn: aStream.  aStream cr.  self submorphsDo: [:m |  m printStructureOn: aStream indent: tabCount + 1 ]-=JUAMPI=-updateFromEvent: anEvent  | pNew previousX newWidth minX newLeft |  pNew := anEvent cursorPoint - lastMouse second.  minX := index = 1 ifTrue: [ container minResizerX ] ifFalse: [ (container columnResizers at: index - 1) right + container minResizerOffset ].  newLeft := minX max: pNew x.  index = 1 ifTrue: [ newLeft := newLeft + 3 ].  self left: newLeft.  previousX := index = 1 ifTrue: [ container scroller left - container scroller offset x + 3 ] ifFalse: [ (container columnResizers at: index - 1) left ].  newWidth := self left - previousX.  (container columns at: index) currentWidth: newWidth.  container resizerChanged-=JUAMPI=-displaySelectionInLine: line on: aCanvas  | leftX rightX w caretColor |  selectionStart ifNil: [ ^self ].  aCanvas isShadowDrawing ifTrue: [ ^self ].  selectionStart = selectionStop ifTrue: [ selectionStart textLine ~= line ifTrue: [ ^self ] ] ifFalse: [ (selectionStop stringIndex < line first or: [ selectionStart stringIndex > (line last + 1) ]) ifTrue: [ ^self ].        (selectionStop stringIndex = line first and: [ selectionStop textLine ~= line ]) ifTrue: [ ^self ].        (selectionStart stringIndex = (line last + 1) and: [ selectionStop textLine ~= line ]) ifTrue: [ ^self ] ].  leftX := (selectionStart stringIndex < line first ifTrue: [ line ] ifFalse: [ selectionStart ]) left.  rightX := (selectionStop stringIndex > (line last + 1) or: [ selectionStop stringIndex = (line last + 1) and: [ selectionStop textLine ~= line ] ]) ifTrue: [ line right ] ifFalse: [ selectionStop left ].  selectionStart = selectionStop ifTrue: [ rightX := rightX + 1.        w := self caretWidth.        caretRect := (leftX - w) @ line top corner: (rightX + w) @ line bottom.        self showCaret ifFalse: [ ^self ].        caretColor := self insertionPointColor.        1 to: w do: [:i |  aCanvas fillRectangle: ((leftX - w + i - 1) @ (line top + i - 1) extent: ((w - i) * 2 + 3) @ 1) color: caretColor.              aCanvas fillRectangle: ((leftX - w + i - 1) @ (line bottom - i) extent: ((w - i) * 2 + 3) @ 1) color: caretColor ].        aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom) color: caretColor ] ifFalse: [ caretRect := nil.        aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom) color: self selectionColor ]-=JUAMPI=-enabled: anObject  enabled := anObject.  self     cachedForm: nil;     changed-=JUAMPI=-ghostText  self subclassResponsibility-=JUAMPI=-toggle  self isExpanded ifTrue: [ self collapseAndRefresh ] ifFalse: [ self expandAndRefresh ]-=JUAMPI=-flashBounds  5 timesRepeat: [ Display flash: self boundsInWorld andWait: 120 ]-=JUAMPI=-handlesClickOrDrag: evt  ^(self existsSubscriptionsFor: #click) or: [ (self existsSubscriptionsFor: #doubleClick) or: [ self existsSubscriptionsFor: #startDrag ] ]-=JUAMPI=-newLabel  ^self theme checkboxLabelFor: self-=JUAMPI=-targetPoint  ^position - source targetOffset-=JUAMPI=-copyHandlerState: anEvent  -=JUAMPI=-table: aTable  table := aTable-=JUAMPI=-font: anObject  font := anObject.  self update: getLabelSelector-=JUAMPI=-wantsColumnBreaks: aBoolean  wantsColumnBreaks := aBoolean-=JUAMPI=-gripLayoutFrame  ^(0 @ 1 corner: 0 @ 1) asLayoutFrame     topOffset: self defaultHeight negated;     rightOffset: self defaultWidth-=JUAMPI=-testTransform  | lf rectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 140 @ 60) equals: rectangle-=JUAMPI=-defaultColor  ^Color green lighter-=JUAMPI=-changePropotionalLayout  | layout |  ((layout := self layoutPolicy) notNil and: [ layout isProportionalLayout ]) ifTrue: [ ^self ].  self layoutPolicy: ProportionalLayout new.  self layoutChanged-=JUAMPI=-setGrabbedColor  self fillStyle: self theme fastTableColumnSplitterSelectedColor-=JUAMPI=-calculateVisibleRows  ^self calculateMaxVisibleRows min: self table numberOfRows-=JUAMPI=-newGroupbox: aString for: control  ^self theme newGroupboxIn: self label: aString for: control-=JUAMPI=-drawText: aStringOrText on: aCanvas in: aRectangle  ^self drawText: aStringOrText on: aCanvas in: aRectangle color: self stringColorToUse-=JUAMPI=-drawLinesOn: canvas  self selectedTab ifNotNil: [ self drawWithSelectionOn: canvas ] ifNil: [ self drawWithoutSelectedOn: canvas ]-=JUAMPI=-selectRow: index  selectedRows add: index.  self invalidRect: (self selectionFrameForRow: index)-=JUAMPI=-scrollBarColor  ^self paneColor-=JUAMPI=-flushLayoutCache  minExtentCache := nil-=JUAMPI=-colorFor: index  index odd ifTrue: [ ^Smalltalk ui theme lightBackgroundColor ].  ^Smalltalk ui theme backgroundColor-=JUAMPI=-finishedScrolling: event  self finishedScrolling.  (self containsPoint: event position) ifTrue: [ pagingArea           fillStyle: self mouseOverFillStyle;           borderStyle: self mouseOverBorderStyle ] ifFalse: [ pagingArea           fillStyle: self normalFillStyle;           borderStyle: self normalBorderStyle ].  (upButton containsPoint: event position) ifTrue: [ upButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: event position) ifTrue: [ upButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ upButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ].  (downButton containsPoint: event position) ifTrue: [ downButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: event position) ifTrue: [ downButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ downButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ]-=JUAMPI=-theme  ^Smalltalk ui theme-=JUAMPI=-mouseUp: evt  actWhen == #buttonUp ifFalse: [ ^super mouseUp: evt ].  (self containsPoint: evt cursorPoint) ifTrue: [ self state: #on.        self doButtonAction: evt ] ifFalse: [ self state: #off ]-=JUAMPI=-preferredKeyboardPosition  ^(self bounds: self bounds in: self currentWorld) topLeft-=JUAMPI=-indexFromPosition: aTuple  ^aTuple first-=JUAMPI=-initializeTable: aTable  table := aTable.  self initialize-=JUAMPI=-handleFocusEvent: anEvent  ^self handleEvent: anEvent-=JUAMPI=-rotationDegrees  ^0.0-=JUAMPI=-target: aMorph  self setTarget: aMorph.  target ifNotNil: [ self addHandles ]-=JUAMPI=-wantsDirectionHandles  ^false-=JUAMPI=-gridSpecPut: newSpec  ^self setProperty: #gridSpec toValue: newSpec-=JUAMPI=-wantsKeyboardFocusOnMouseDown  ^self wantsKeyboardFocus and: [ self valueOfProperty: #wantsKeyboardFocusOnMouseDown ifAbsent: [ false ] ]-=JUAMPI=-selectionBarColor  ^self theme selectionBarColor-=JUAMPI=-itemWithWording: wording  self items do: [:anItem |  | found |        found := anItem itemWithWording: wording.        found ifNotNil: [ ^found ] ].  ^nil-=JUAMPI=-compositionRectangle  ^container-=JUAMPI=-tasks: anObject  tasks := anObject-=JUAMPI=-inject: thisValue into: binaryBlock  | nextValue |  nextValue := thisValue.  self do: [:each |  nextValue := binaryBlock value: nextValue value: each ].  ^nextValue-=JUAMPI=-selectionIndex  ^self listMorph selectedRow ifNil: [ 0 ]-=JUAMPI=-positionModalOwner  self modalOwner ifNotNil: [:modalOwner |  (modalOwner isKindOf: SystemWindow) ifTrue: [ modalOwner bringBehind: self ] ]-=JUAMPI=-down: anObject  down := anObject.  self changed-=JUAMPI=-addNameBeneath: outerRectangle string: aString  | namePosition w |  w := self world ifNil: [ target world ].  nameMorph := StringMorph contents: aString font: StandardFonts haloFont.  nameMorph     wantsYellowButtonMenu: false;     color: self theme balloonTextColor;     backgroundColor: self theme balloonBackgroundColor;     target: innerTarget.  namePosition := outerRectangle bottomCenter - ((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).  nameMorph position: (namePosition min: w viewBox bottomRight - nameMorph extent y + 2).  self addMorph: nameMorph.  ^nameMorph-=JUAMPI=-acceptOnCR: trueOrFalse  acceptOnCR := trueOrFalse-=JUAMPI=-drawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: aCanvas ]-=JUAMPI=-initialize  super initialize.  self elements: #()-=JUAMPI=-table  ^table-=JUAMPI=-getChildren  ^dataSource childrenBlock isSymbol ifTrue: [ dataSource childrenBlock value: data ] ifFalse: [ dataSource childrenBlock cull: data cull: self ]-=JUAMPI=-setType: aSymbol  type := aSymbol-=JUAMPI=-getIconSelector: anObject  getIconSelector := anObject-=JUAMPI=-takesKeyboardFocus  ^true-=JUAMPI=-addItemShowing: aString from: startNumber to: endNumber  lock critical: [ | item items |        item := SystemProgressItemMorph labeled: aString from: startNumber to: endNumber.        items := self bars size.        items < 10 ifTrue: [ self addMorphBack: item.              self recenter ].        ^item ]-=JUAMPI=-wantsStepsWhenCollapsed  ^false-=JUAMPI=-updateTasks  | tasksThatShouldBeUpdated |  tasksThatShouldBeUpdated := windows collect: [:window |  self newTaskFor: window ].  self updateOrderedTasksFrom: tasksThatShouldBeUpdated-=JUAMPI=-lineWidth: anInteger  self borderWidth: (anInteger rounded max: 1)-=JUAMPI=-scrollUpInit  | bc |  bc := upButton borderStyle baseColor.  upButton borderInset.  upButton borderStyle baseColor: bc.  self resetTimer.  self scrollBarAction: #doScrollUp.  self doScrollUp.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nil.  upButton fillStyle: self pressedButtonFillStyle.  upButton borderStyle: self pressedButtonBorderStyle-=JUAMPI=-action  self inform: 'Button pressed'-=JUAMPI=-changeMinCellSize: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self minCellSize: (newPoint - evt cursorPoint) asIntegerPoint ].  evt hand attachMorph: handle.  handle startStepping-=JUAMPI=-beIconRight  iconPosition := #right.  self update: getIconSelector-=JUAMPI=-on: anObject color: getColSel  self     model: anObject;     getColorSelector: getColSel;     updateColor-=JUAMPI=-getChildrenSelector  ^getChildrenSelector-=JUAMPI=-indexForRow: aRowIndex  ^{aRowIndex .   self table selectedIndex second}-=JUAMPI=-newLocationMorph  ^ImageMorph new form: Cursor crossHair withMask asCursorForm-=JUAMPI=-defaultColor  ^self theme menuSelectionColor alpha: 0.08-=JUAMPI=-cellColumn: column row: rowIndex  column id = 'Icon' ifTrue: [ ^self iconColumn: column row: rowIndex ].  column id = 'Name' ifTrue: [ ^self nameColumn: column row: rowIndex ].  column id = 'Number of methods' ifTrue: [ ^self numberOfMethodsColumn: column row: rowIndex ].  column id = 'Number of instance variables' ifTrue: [ ^self numberOfInstanceVariablesColumn: column row: rowIndex ].  self error: 'Invalid column'-=JUAMPI=-indentingItemClass  ^MorphTreeNodeMorph-=JUAMPI=-hasTableLayoutString  | layout |  ^((layout := self layoutPolicy) notNil and: [ layout isTableLayout ]) -> 'table layout' translated-=JUAMPI=-wantsExpandBox  ^true-=JUAMPI=-deriveHScrollRange  | unadjustedRange totalRange |  (list isNil or: [ list isEmpty ]) ifTrue: [ hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0 ] ifFalse: [ unadjustedRange := self listMorph hUnadjustedScrollRange.        totalRange := unadjustedRange + self hExtraScrollRange + self hMargin.        hScrollRangeCache := Array with: totalRange with: unadjustedRange with: list size with: list first with: list last ]-=JUAMPI=-headerColumn: column  ^self basicHeaderCellFor: column-=JUAMPI=-setIndexSelector: aSelector  setIndexSelector := aSelector-=JUAMPI=-windowEventHandler: anObject  WindowEventHandler := anObject-=JUAMPI=-initialExtent  ^(self model respondsTo: #initialExtent) ifTrue: [ self model initialExtent ] ifFalse: [ RealEstateAgent standardWindowExtent ]-=JUAMPI=-ownerChanged  super ownerChanged.  self updateLayoutInDockingBar-=JUAMPI=-newOKButton  ^self newOKButtonFor: self-=JUAMPI=-currentlyExpanded  ^(scroller submorphs select: [:each |  each isExpanded ]) collect: [:each |  each complexContents ]-=JUAMPI=-acquireBorderWidth: aBorderWidth  | delta |  (delta := aBorderWidth - self borderWidth) = 0 ifTrue: [ ^self ].  self bounds: (self bounds origin - (delta @ delta) corner: self bounds corner + (delta @ delta)).  self borderWidth: aBorderWidth.  self layoutChanged-=JUAMPI=-allSiblingItems  | menus str index |  str := (Array new: 40) writeStream.  menus := self owner submorphs select: [:m |  m isKindOf: self class ].  menus := (menus copyFrom: (index := menus indexOf: self) to: menus size) , (menus copyFrom: 1 to: index - 1).  menus do: [:menu |  str nextPutAll: menu items ].  ^str contents-=JUAMPI=-userString  ^nil-=JUAMPI=-visible: newValue  visible := newValue-=JUAMPI=-target: aMorph  -=JUAMPI=-headerButtonLabel: aLabel icon: anIconForm  self headerButtonLabel: aLabel font: nil.  self header cellInset: 3 @ 0.  self header icon: (ImageMorph new form: anIconForm)-=JUAMPI=-newLabel  | lbl |  lbl := self theme buttonLabelFor: self.  font ifNotNil: [ lbl font: font.        lbl extent: lbl optimalExtent ].  ^lbl-=JUAMPI=-arguments  ^arguments-=JUAMPI=-handlesMouseDown: event  ^true-=JUAMPI=-getListSelector: sel  getListSelector := sel.  self changed.  self updateList-=JUAMPI=-basicBorderWidth: aNumber  borderWidth := aNumber-=JUAMPI=-doGrow: evt with: growHandle  | newExtent extentToUse scale |  evt hand obtainHalo: self.  newExtent := (target pointFromWorld: evt cursorPoint - positionOffset) - target topLeft.  evt shiftPressed ifTrue: [ scale := newExtent x / (originalExtent x max: 1) min: newExtent y / (originalExtent y max: 1).        newExtent := (originalExtent x * scale) asInteger @ (originalExtent y * scale) asInteger ].  (newExtent x < 1 or: [ newExtent y < 1 ]) ifTrue: [ ^self ].  target renderedMorph extent: (extentToUse := newExtent).  growHandle position: evt cursorPoint - (growHandle extent // 2).  self layoutChanged-=JUAMPI=-focusBounds  ^self theme buttonFocusBoundsFor: self-=JUAMPI=-isMouseOver  ^self type == #mouseOver-=JUAMPI=-getCurrentSelectionIndex  getIndexSelector ifNil: [ ^0 ].  ^model perform: getIndexSelector-=JUAMPI=-restoreAndActivate  self isMinimized ifTrue: [ self restore ].  self isActive ifFalse: [ self activate ]-=JUAMPI=-removeFlexShell  | oldHalo unflexed myWorld refPos aPosition |  refPos := self referencePosition.  myWorld := self world.  oldHalo := self halo.  submorphs isEmpty ifTrue: [ ^self delete ].  aPosition := (owner submorphIndexOf: self) ifNil: [ 1 ].  unflexed := self firstSubmorph.  self submorphs do: [:m |  m position: self center - (m extent // 2).        owner addMorph: m asElementNumber: aPosition ].  oldHalo ifNotNil: [ oldHalo setTarget: unflexed ].  myWorld ifNotNil: [ myWorld startSteppingSubmorphsOf: unflexed ].  self delete.  unflexed referencePosition: refPos.  ^unflexed-=JUAMPI=-selectionColor  ^selectionColor-=JUAMPI=-includesTableProperties  ^true-=JUAMPI=-newBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newBracketSliderIn: self for: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpText-=JUAMPI=-needSeparatorBefore: index  | tmpIndex |  index <= 1 ifTrue: [ ^false ].  tmpIndex := index.  self items do: [:elements |  elements size >= tmpIndex ifTrue: [ ^tmpIndex = 1 ] ifFalse: [ tmpIndex := tmpIndex - elements size ] ].  self errorSubscriptBounds: index-=JUAMPI=-drawBackgroundOnAthensCanvas: anAthensCanvas  (isSelected and: [ isEnabled ]) ifFalse: [ ^self ].  anAthensCanvas setPaint: self selectionFillStyle.  anAthensCanvas drawShape: (0 @ 0 extent: self extent)-=JUAMPI=-lastKeystroke: aString  ^self setProperty: #lastKeystroke toValue: aString-=JUAMPI=-lastColumnBounded  ^self lastColumnUnbounded not-=JUAMPI=-selection  ^editor ifNotNil: [ editor selection ]-=JUAMPI=-actions  ^actions-=JUAMPI=-drawOn: aCanvas  aCanvas fillOval: bounds fillStyle: self fillStyle borderWidth: borderWidth borderColor: borderColor-=JUAMPI=-selfOrChildAt: anIndex  ^anIndex = 1 ifTrue: [ self ] ifFalse: [ self childAt: anIndex - 1 ]-=JUAMPI=-setMultipleContents  | tabs size delta |  contentsWrapper removeAllMorphs.  self cleanProcesses.  tabs := toolbar orderedSelectedTabs.  size := tabs size.  delta := 1 / size.  tabs allButLast keysAndValuesDo: [:index :tab |  self addTabContents: tab at: index delta: delta ].  self addLastTabContents: tabs last among: size delta: delta.  self addSplitterOn: tabs delta: delta-=JUAMPI=-drawSubMorphOn: aCanvas  | morphBounds |  morphBounds := self bounds insetBy: (self cornerRadius + 3) @ (self topInactiveGap // 2 + 2).  morphBounds := morphBounds translateBy: 0 @ (self topInactiveGap // 2 + 1).  self active ifTrue: [ morphBounds := morphBounds translateBy: 0 @ (self topInactiveGap // 2 + 1) negated ].  self subMorph bounds height < morphBounds height ifTrue: [ morphBounds := morphBounds insetBy: 0 @ ((morphBounds height - self subMorph bounds height) // 2) ].  self subMorph bounds width < morphBounds width ifTrue: [ morphBounds := morphBounds insetBy: ((morphBounds width - self subMorph bounds width) // 2) @ 0 ].  self subMorph bounds: morphBounds.  aCanvas drawMorph: self subMorph-=JUAMPI=-defaultGraphics  ^DefaultGraphics-=JUAMPI=-bringBehind: aMorph  | outerMorph |  outerMorph := self topRendererOrSelf.  outerMorph owner ifNil: [ ^self ].  outerMorph owner addMorph: outerMorph after: aMorph topRendererOrSelf.  self modalOwner ifNotNil: [:mo |  mo bringBehind: self ]-=JUAMPI=-checkMorphsRightOrBottomFrom: splitter  | index |  index := submorphs identityIndexOf: splitter.  index := index - 1.  [ index > 0 ] whileTrue: [ | submorph done |        submorph := submorphs at: index.        splitter addRightOrBottom: submorph.        done := self isResizeableMorph: submorph forSplitter: splitter.        done ifTrue: [ index := 0 ].        index := index - 1 ]-=JUAMPI=-controlKeyPressed  ^buttons anyMask: 2r00010000-=JUAMPI=-prepareForRotating  ^self addFlexShell-=JUAMPI=-addFlexShell  | oldHalo flexMorph myWorld anIndex |  myWorld := self world.  oldHalo := self halo.  anIndex := self owner submorphIndexOf: self.  self owner addMorph: (flexMorph := self newTransformationMorph asFlexOf: self) asElementNumber: anIndex.  self transferStateToRenderer: flexMorph.  oldHalo ifNotNil: [ oldHalo setTarget: flexMorph ].  myWorld ifNotNil: [ myWorld startSteppingSubmorphsOf: flexMorph ].  ^flexMorph-=JUAMPI=-handlesMouseOverDragging: evt  ^self dropEnabled-=JUAMPI=-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-=JUAMPI=-mouseLeaveDragging: event  (self dropEnabled and: [ event hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: event ].  self basicHighlightIndexes: #().  self refresh-=JUAMPI=-handleKeystroke: aKeystrokeEvent inMorph: aMorph  -=JUAMPI=-wrapOnOff  self wrapFlag: wrapFlag not-=JUAMPI=-pressedBorderStyle  ^self theme controlButtonPressedBorderStyleFor: self-=JUAMPI=-aMorph  ^aMorph-=JUAMPI=-newSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText-=JUAMPI=-splitterRight  | splitters |  splitters := (self siblingSplitters select: [:each |  each left > self left and: [ self overlapsVertical: each ] ]) asSortedCollection: [:a :b |  a left < b left ].  ^splitters ifEmpty: [ nil ] ifNotEmpty: [:s |  s first ]-=JUAMPI=-listSpacing: aSymbol  self assureTableProperties listSpacing: aSymbol.  self layoutChanged-=JUAMPI=-onImage  | form |  form := Form extent: (self fontToUse ascent - 2) asPoint depth: 16.  form getCanvas     frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) borderWidth: 1 borderColor: Color black;     fillRectangle: (form boundingBox insetBy: 2) fillStyle: Color black.  ^form-=JUAMPI=-expandItem  expanded := true.  children := (dataSource childrenFor: item) collect: [:each |  self treeItemFor: each ].  dataSource updateAvailableRows: self availableRows - 1-=JUAMPI=-fillWithRamp: rampSpecsOrColor oriented: aRatio  rampSpecsOrColor isColor ifTrue: [ self color: rampSpecsOrColor ] ifFalse: [ | fill |        fill := GradientFillStyle ramp: rampSpecsOrColor.        fill origin: self bounds topLeft.        fill direction: (self bounds extent * aRatio) truncated.        fill radial: false.        self fillStyle: fill.        self borderColor: (rampSpecsOrColor first value mixed: 0.5 with: rampSpecsOrColor last value) muchDarker ]-=JUAMPI=-adjustToHorizontalScrollBarValue: aNumber  | newStartColumnIndex |  newStartColumnIndex := (self table numberOfColumns * aNumber) rounded min: self table numberOfColumns max: 1.  newStartColumnIndex ~= self startColumnIndex ifTrue: [ self startColumnIndex: newStartColumnIndex.        self changed ]-=JUAMPI=-testUpdateEmptyTaskBarWithNewWindow  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: taskbar tasks size equals: 1-=JUAMPI=-iconOrThumbnailOfSize: aNumberOrPoint  ^self iconOrThumbnail scaledIntoFormOfSize: aNumberOrPoint-=JUAMPI=-handlesKeyboard: evt  ^true-=JUAMPI=-newFuzzyLabel: aString  ^self theme newFuzzyLabelIn: self for: nil label: aString offset: 1 alpha: 0.5 getEnabled: nil-=JUAMPI=-matches: aString  self subclassResponsibility-=JUAMPI=-debug  [ builder menuSpec asMenuMorph ] ensure: [ builder reset ]-=JUAMPI=-world  ^world-=JUAMPI=-mouseFocus: aMorphOrNil  mouseFocus := aMorphOrNil-=JUAMPI=-mouseEnter: anEvent  self canResizeColumn ifFalse: [ ^self ].  (owner notNil and: [ owner bounds containsPoint: anEvent position ]) ifTrue: [ super mouseEnter: anEvent ]-=JUAMPI=-verticesAt: ix put: newPoint  vertices at: ix put: newPoint.  self computeBounds-=JUAMPI=-newAColorMorph  ^AColorSelectorMorph new     model: self;     hResizing: #spaceFill;     vResizing: #rigid;     setValueSelector: #alphaSelected:;     extent: 24 @ 24-=JUAMPI=-vShowScrollBar  self vIsScrollbarShowing ifTrue: [ ^self ].  self vResizeScrollBar.  self privateAddMorph: scrollBar atIndex: 1.  self resetExtent-=JUAMPI=-menu: menu shifted: b  super menu: menu shifted: b.  menu addLine.  self selectedNode ifNotNil: [:current |  current menu: menu shifted: b.        menu addLine.        menu add: 'Expand all from here' target: self selector: #expandAllFromNode: argument: current ].  ^menu-=JUAMPI=-mouseUp: event  needToggleAtMouseUp ifFalse: [ ^self ].  (self selectionModeStrategy selectableIndexContainingPoint: event cursorPoint) ifNotNil: [:index |  self selectIndex: index event: event ].  needToggleAtMouseUp := false-=JUAMPI=-event  ^event-=JUAMPI=-userString  ^list ifNotNil: [ String streamContents: [:strm |  list do: [:i |  strm                       nextPutAll: i string;                       cr ] ] ]-=JUAMPI=-layoutProperties  ^extension ifNotNil: [ extension layoutProperties ]-=JUAMPI=-modifiedCharacter  self flag: #hack.  ^(self hasSpecialCTRLKeyValue and: [ #(MacOSX Windows) includes: Smalltalk os platformFamily ]) ifTrue: [ (self keyValue + $a asciiValue - 1) asCharacter ] ifFalse: [ Smalltalk os isWindows ifTrue: [ self keyCharacter asLowercase ] ifFalse: [ self keyCharacter ] ]-=JUAMPI=-newGroupboxFor: control  ^self theme newGroupboxIn: self for: control-=JUAMPI=-openInWindowLabeled: aString inWorld: aWorld  self layoutInset: 0.  ^super openInWindowLabeled: aString inWorld: aWorld-=JUAMPI=-isAutoFit  ^false-=JUAMPI=-removeWindow: aMorph  windows remove: aMorph-=JUAMPI=-useSecondarySelection  ^false-=JUAMPI=-mouseEnter: evt  super mouseEnter: evt.  self over: true-=JUAMPI=-selectAll  self isMultipleSelection ifFalse: [ ^self ].  1 to: self maximumSelection do: [:i |  self listSelectionAt: i put: true ]-=JUAMPI=-getListSelector  ^getListSelector-=JUAMPI=-basicBorderColor: aColor  borderColor := aColor-=JUAMPI=-newAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText-=JUAMPI=-view: aViewOrMorph  -=JUAMPI=-defaultButton  ^IconicButton new     target: self;     color: Color transparent;     borderWidth: 0;     yourself-=JUAMPI=-selectedIndex  ^self selectedIndexes ifNotEmpty: #first ifEmpty: [ self selectionModeStrategy nullIndex ]-=JUAMPI=-negateBottomRightOffsets  bottomOffset := bottomOffset negated.  rightOffset := rightOffset negated-=JUAMPI=-keyStroke: anEvent  ^false-=JUAMPI=-mouseLeaveDragging: evt  super mouseLeaveDragging: evt.  self over: false-=JUAMPI=-assureExtension  extension ifNil: [ self initializeExtension ].  ^extension-=JUAMPI=-vSetScrollDelta  | range delta |  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  delta := self scrollDeltaHeight.  range := self vLeftoverScrollRange.  range = 0 ifTrue: [ ^scrollBar           scrollDelta: 0.02 pageDelta: 0.2;           interval: 1.0;           setValue: 0 ].  scrollBar scrollDelta: (delta / range) asFloat pageDelta: ((self innerBounds height - delta) / range) asFloat.  scrollBar interval: (self innerBounds height / self vTotalScrollRange) asFloat.  scrollBar setValue: (scroller offset y / range min: 1.0) asFloat-=JUAMPI=-passenger: anObject  passenger := anObject-=JUAMPI=-paneWithLongestSide: sideBlock near: aPoint  | thePane theSide theLen |  theLen := 0.  paneMorphs do: [:pane |  | box |        box := pane bounds.        box forPoint: aPoint closestSideDistLen: [:side :dist :len |  (dist <= 5 and: [ len > theLen ]) ifTrue: [ thePane := pane.                    theSide := side.                    theLen := len ] ] ].  sideBlock value: theSide.  ^thePane-=JUAMPI=-emptySelection  self selectedMorphList do: [:n |  n           unhighlight;           setSelectedSilently: false ].  self selectedMorphList removeAll.  self selectionChanged-=JUAMPI=-hasUnacceptedEdits: aBoolean  -=JUAMPI=-toggleEnabled  self enabled: self enabled not-=JUAMPI=-newSeparator  ^self theme newSeparatorIn: self-=JUAMPI=-leftArrowStroked: evt  popUpOwner ifNil: [ ^self ].  ^self deselectAndFocusOutermenuOn: evt-=JUAMPI=-unsort  self unsortElements.  self table refresh-=JUAMPI=-nextState  ^FTDescendingSortingState context: self context-=JUAMPI=-getLabelSelector  ^getLabelSelector-=JUAMPI=-enabled: anObject  enabled = anObject ifTrue: [ ^self ].  enabled := anObject.  self changed: #enabled.  self     adoptPaneColor: self paneColor;     changed-=JUAMPI=-currentCursor  ^ActiveHand world currentCursor-=JUAMPI=-imageFromName: aSymbol  ^self images at: aSymbol ifPresent: [:block |  block value ] ifAbsent: [  ]-=JUAMPI=-isClosed  ^closed-=JUAMPI=-topLeftColor  ^width = 1 ifTrue: [ self color twiceLighter ] ifFalse: [ self color lighter ]-=JUAMPI=-displayWorld  worldState displayWorld: self submorphs: submorphs-=JUAMPI=-findDeepSubmorphThat: block1 ifAbsent: block2  self allMorphsDo: [:m |  (block1 value: m) == true ifTrue: [ ^m ] ].  ^block2 value-=JUAMPI=-selected  ^state selected-=JUAMPI=-addToggleItemsToHaloMenu: aCustomMenu  super addToggleItemsToHaloMenu: aCustomMenu.  aCustomMenu addUpdating: #enabledString target: self selector: #toggleEnabled-=JUAMPI=-defaultColor  ^Color white-=JUAMPI=-isRight  ^direction = Character arrowRight-=JUAMPI=-formerPosition  ^self valueOfProperty: #formerPosition-=JUAMPI=-initialize  super initialize.  hasFocus := false.  self initializeScrollBars.  self extent: self defaultExtent.  self hideOrShowScrollBars-=JUAMPI=-addHandleAt: aPoint color: aColor icon: iconName on: eventName send: selector to: recipient  | handle |  handle := self createHandleAt: aPoint color: aColor iconName: iconName.  self addMorph: handle.  handle on: #mouseUp send: #endInteraction to: self.  handle on: eventName send: selector to: recipient.  handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.  ^handle-=JUAMPI=-steppingMorphsNotInWorld  | all |  all := self allMorphs.  ^self listOfSteppingMorphs reject: [:m |  all includes: m ]-=JUAMPI=-enableFilter  function := FTFilterFunction table: self-=JUAMPI=-selectPreviousTab  self selectedIndex: (self selectedIndex < 2 ifTrue: [ self tabs size ] ifFalse: [ self selectedIndex - 1 ])-=JUAMPI=-wantsYellowButtonMenu  self valueOfProperty: #wantsYellowButtonMenu ifPresentDo: [:value |  ^value ].  self isInSystemWindow ifTrue: [ ^false ].  ^self defaultYellowButtonMenuEnabled-=JUAMPI=-model  ^nil-=JUAMPI=-on: eventName send: selector to: recipient withValue: value  selector numArgs = 3 ifFalse: [ self error: 'Warning: value parameters are passed as first of 3 arguments' ].  self addSubscription: (MorphEventSubscription on: eventName send: selector to: recipient withValue: value) toEvent: eventName-=JUAMPI=-truncatedMenuLabelFor: aWindowLabel  ^aWindowLabel truncateWithElipsisTo: 47-=JUAMPI=-selectedNodePathList: aCollectionOfPath  selectedNodePathList := aCollectionOfPath-=JUAMPI=-newBalloonHelp: aTextStringOrMorph for: aMorph  ^self theme newBalloonHelpIn: self contents: aTextStringOrMorph for: aMorph corner: #bottomLeft-=JUAMPI=-unshiftedYellowButtonActivity  ^self yellowButtonActivity: false-=JUAMPI=-keyStroke: evt  | keyValue |  owner isHandMorph ifFalse: [ ^self ].  keyValue := evt keyValue.  keyValue = 28 ifTrue: [ ^self position: self position - (1 @ 0) ].  keyValue = 29 ifTrue: [ ^self position: self position + (1 @ 0) ].  keyValue = 30 ifTrue: [ ^self position: self position - (0 @ 1) ].  keyValue = 31 ifTrue: [ ^self position: self position + (0 @ 1) ].  keyValue = 13 ifTrue: [ owner releaseKeyboardFocus: self.        self delete ]-=JUAMPI=-testSelectLast  table selectLast.  self assert: table selectedIndexes equals: #(10)-=JUAMPI=-selectIndexes: anArray andMakeVisibleIf: shouldEnsureVisibleSelection  | oldSelectedIndexes |  anArray = self selectedIndexes ifTrue: [ ^self ].  oldSelectedIndexes := self selectedIndexes.  self basicSelectIndexes: anArray.  shouldEnsureVisibleSelection ifTrue: [ self ensureVisibleFirstSelection ].  self refresh.  self doAnnounce: ((FTSelectionChanged from: oldSelectedIndexes to: self selectedIndexes)           fastTable: self;           yourself)-=JUAMPI=-privateFullMoveBy: delta  self privateMoveBy: delta.  submorphs do: [:each |  each privateFullMoveBy: delta ]-=JUAMPI=-updateImage  (self model notNil and: [ self getImageSelector notNil ]) ifTrue: [ (self model perform: self getImageSelector) ifNotNil: [:i |  self image: i ] ]-=JUAMPI=-createExpandBox  ^self theme createExpandBoxFor: self-=JUAMPI=-spotterWindowsFor: aStep  < spotterOrder: 100>  aStep listProcessor     title: 'Windows';     allCandidates: [ self class allSubInstances ];     itemName: [:window |  '**' , window label , '**' ];     filter: GTFilterSubstring-=JUAMPI=-vHideOrShowScrollBar  self vIsScrollbarNeeded ifTrue: [ self vShowScrollBar ] ifFalse: [ self vHideScrollBar ]-=JUAMPI=-children  | children |  children := OrderedCollection new.  self childrenDo: [:each |  children add: each ].  ^children-=JUAMPI=-keyStroke: event  (super keyStroke: event) ifTrue: [ ^true ].  self keystrokeSelector ifNotNil: [ (self keyStrokeAction: event) ifTrue: [ ^true ] ].  (self keystrokeActionSelector notNil and: [ event anyModifierKeyPressed ]) ifTrue: [ (self keyStrokeModifierAction: event) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-cachedForm  | form i effectiveAlpha |  cachedForm ifNil: [ i := self scaledImage.        effectiveAlpha := self enabled ifTrue: [ self alpha ] ifFalse: [ self alpha / 2 ].        effectiveAlpha = 1.0 ifTrue: [ self cachedForm: i ] ifFalse: [ form := Form extent: i extent depth: 32.              form fillColor: (Color white alpha: 0.003922).              (form getCanvas asAlphaBlendingCanvas: effectiveAlpha) drawImage: i at: 0 @ 0.              self cachedForm: form ] ].  ^cachedForm-=JUAMPI=-newColumn: controls  ^self theme newColumnIn: self for: controls-=JUAMPI=-reversedSelectedTabs  ^selectionHistory last: numberOfSelectedTabs-=JUAMPI=-openInExternalWindow  | world |  world := OSWindowWorldMorph new extent: self fullBounds extent.  world     layoutPolicy: ProportionalLayout new;     clipSubmorphs: true.  self     hResizing: #spaceFill;     vResizing: #spaceFill.  self openInWorld: world.  self onAnnouncement: MorphDeleted do: [:announce |  world ifNotNil: [ world delete ].        world := nil ].  ^world open-=JUAMPI=-removePendingBalloonFor: aMorph  self removeAlarm: #spawnBalloonFor:.  self deleteBalloonTarget: aMorph-=JUAMPI=-expandAllSuchThat: aBlock  self roots do: [:m |  self expand: m suchThat: aBlock ].  self innerWidgetChanged-=JUAMPI=-setSwitchState: aBoolean  aBoolean ifTrue: [ self turnOn ] ifFalse: [ self turnOff ]-=JUAMPI=-tabKey: event  event controlKeyPressed ifFalse: [ event keyCharacter = Character tab ifTrue: [ event shiftPressed ifTrue: [ self navigateFocusBackward ] ifFalse: [ self navigateFocusForward ].              ^true ] ].  ^false-=JUAMPI=-newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel  ^self newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: nil-=JUAMPI=-alpha: anObject  alpha := anObject.  self changed-=JUAMPI=-hue: anInteger  | c |  c := self selectedColor.  self selectedColor: ((Color h: (anInteger / 255 * 359) rounded s: c saturation v: c brightness) alpha: c alpha)-=JUAMPI=-testIndexesToSelectInMultipleSelectionFromTo  self subclassResponsibility-=JUAMPI=-borderWidth: anInteger  borderColor ifNil: [ borderColor := Color black ].  borderWidth := anInteger max: 0.  self computeBounds-=JUAMPI=-getEnabledSelector: anObject  getEnabledSelector := anObject.  self updateEnabled-=JUAMPI=-submorphBounds  | box |  submorphs do: [:m |  | subBox |        m visible ifTrue: [ subBox := m fullBounds.              box ifNil: [ box := subBox copy ] ifNotNil: [ box := box quickMerge: subBox ] ] ].  box ifNil: [ ^self bounds ].  ^box origin asIntegerPoint corner: box corner asIntegerPoint-=JUAMPI=-isPartialMatch  ^self complexContents isPartialMatch-=JUAMPI=-dropItemSelector: aSelector  self dataSource dropItemSelector: aSelector-=JUAMPI=-onWindowLabelChanged: ann  self tabGroup relabelPage: ann window with: (self tabLabelFor: ann window)-=JUAMPI=-potentialDropMorph: anObject  potentialDropMorph := anObject-=JUAMPI=-activateCursor: aCursor withMask: maskForm  -=JUAMPI=-imageExport  ^self form bits asArray-=JUAMPI=-maximumSelection  ^scroller submorphs size-=JUAMPI=-vanishAfterSlidingTo: aPosition event: evt  | aForm aWorld startPoint endPoint |  aForm := self imageForm offset: 0 @ 0.  aWorld := self world.  startPoint := evt hand fullBounds origin.  self delete.  aWorld displayWorld.  endPoint := aPosition.  aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15-=JUAMPI=-yellowButtonPressed  ^buttons anyMask: self class yellowButton-=JUAMPI=-drawOn: aCanvas  super drawOn: aCanvas.  (ActiveHand notNil and: [ ActiveHand keyboardFocus == self and: [ self rootMenu hasProperty: #hasUsedKeyboard ] ]) ifTrue: [ aCanvas frameAndFillRectangle: self innerBounds fillColor: Color transparent borderWidth: self theme menuBorderWidth borderColor: self theme menuKeyboardFocusColor ]-=JUAMPI=-maximumSelection  ^self getListSize-=JUAMPI=-newMenu  ^self theme newMenuIn: self for: self-=JUAMPI=-selectFirst  self table selectIndex: #(1 1)-=JUAMPI=-gridOrigin: newOrigin  ^self gridSpecPut: (newOrigin extent: self gridModulus)-=JUAMPI=-borderColor: aColor  super borderColor: aColor.  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) == (aColor isColor and: [ aColor isTranslucentButNotTransparent ]) ifFalse: [ self releaseCachedState ]-=JUAMPI=-is: anIndex bellowRow: aRowIndex  ^anIndex > aRowIndex-=JUAMPI=-hResizeScrollBar  super hResizeScrollBar.  hScrollBar bounds: ((hScrollBar bounds withTop: hScrollBar top - self pagerHeight) withBottom: hScrollBar bottom - self pagerHeight)-=JUAMPI=-taskbarButtonMenu: aMenu  | menu theme submenu |  theme := self theme.  menu := theme newMenuIn: self for: self.  menu addToggle: 'Restore' translated target: self selector: #restore getStateSelector: nil enablementSelector: #isNotRestored.  menu lastItem     icon: self theme windowMaximizeForm;     font: theme menuFont.  menu addToggle: 'Minimize' translated target: self selector: #minimize getStateSelector: nil enablementSelector: #isNotMinimized.  menu lastItem     icon: self theme windowMinimizeForm;     font: theme menuFont.  menu addToggle: 'Maximize' translated target: self selector: #maximize getStateSelector: nil enablementSelector: #canBeMaximized.  menu lastItem     icon: self theme windowMaximizeForm;     font: theme menuFont.  menu addLine.  submenu := theme newMenuIn: self for: self.  menu add: 'Close all' icon: self theme windowCloseForm subMenu: submenu.  submenu addToggle: 'windows to right' translated target: self selector: #taskbarCloseAllToRight getStateSelector: nil enablementSelector: true.  submenu addToggle: 'windows like this' translated target: self selector: #taskbarCloseAllLikeThis getStateSelector: nil enablementSelector: true.  submenu addToggle: 'unchanged windows' translated target: self currentWorld selector: #closeAllUnchangedWindows getStateSelector: nil enablementSelector: true.  submenu addToggle: 'close all debuggers' translated target: Smalltalk tools debugger selector: #closeAllDebuggers getStateSelector: nil enablementSelector: true.  menu addToggle: 'Close' translated target: self selector: #closeBoxHit getStateSelector: nil enablementSelector: #allowedToClose.  menu lastItem     icon: self theme windowCloseForm;     font: theme menuFont.  ^menu-=JUAMPI=-couldHaveRoundedCorners  ^false-=JUAMPI=-font: aFont  self labelMorph font: aFont-=JUAMPI=-cellInset  ^0-=JUAMPI=-normalFillStyle  ^self theme splitterNormalFillStyleFor: self-=JUAMPI=-tearDown  morph delete.  super tearDown-=JUAMPI=-drawOnAthensCanvas: anAthensCanvas  self getListSize = 0 ifTrue: [ ^self ].  self setColumnWidthsFor: anAthensCanvas.  self adjustWidth.  super drawOnAthensCanvas: anAthensCanvas-=JUAMPI=-newHatchMorph  ^Morph new     color: Color transparent;     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     minWidth: 48;     minHeight: 12;     addMorph: (Morph new color: Color white) fullFrame: (0 @ 0 corner: 0.3 @ 1) asLayoutFrame;     addMorph: (Morph new fillStyle: (InfiniteForm with: self hatchForm)) fullFrame: (0.3 @ 0 corner: 0.7 @ 1) asLayoutFrame;     addMorph: self solidLabelMorph fullFrame: (0.7 @ 0 corner: 1 @ 1) asLayoutFrame;     addMorph: self labelMorph fullFrame: (0 @ 0 corner: 1 @ 1) asLayoutFrame-=JUAMPI=-dismissMorph  | w |  w := self world ifNil: [ ^self ].  w stopStepping: self.  self delete-=JUAMPI=-extent: newExtent  self adjustAfter: [ | scaleFactor |        scaleFactor := self scale * newExtent r / self fullBounds extent r max: 0.1.        self scale: (scaleFactor detentBy: 0.1 atMultiplesOf: 1.0 snap: false) ]-=JUAMPI=-defaultImageFormOfSize: aPoint  ^(defaultImageForm isNil or: [ defaultImageForm extent ~= aPoint ]) ifTrue: [ defaultImageForm := Form extent: aPoint ] ifFalse: [ defaultImageForm ]-=JUAMPI=-sliderThickness  ^7-=JUAMPI=-testHeading  | t |  cases := {(t := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ [ self assert: t heading equals: 0.0 ] ensure: [ t delete ] ]-=JUAMPI=-setListFont  StandardFonts chooseFontWithTitle: 'Choose the font for this list' translated for: self setSelector: #font: getSelector: #font-=JUAMPI=-menuColumn: column row: rowIndex  | menu |  self getMenuSelector ifNil: [ ^nil ].  menu := UIManager default newMenuIn: self table for: self model.  self getMenuSelector numArgs = 1 ifTrue: [ ^self model perform: self getMenuSelector with: menu ].  ^self model perform: self getMenuSelector with: menu with: false-=JUAMPI=-clipboardText: aString  ^self osWindow clipboardText: aString-=JUAMPI=-newHColorMorph  ^HColorSelectorMorph new     model: self;     setValueSelector: #hue:;     hResizing: #rigid;     vResizing: #spaceFill;     extent: 36 @ 36-=JUAMPI=-getListElementSelector  ^self dataSource getListElementSelector-=JUAMPI=-minWidth  | noVPlease noHPlease minW |  noVPlease := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  noHPlease := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  minW := noVPlease ifTrue: [ noHPlease ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness * 3 ] ] ifFalse: [ noHPlease ifTrue: [ self scrollBarThickness + 20 ] ifFalse: [ self scrollBarThickness * 3 + 2 ] ].  ^minW max: super minWidth-=JUAMPI=-requestDropReference: i  | fileName |  fileNames ifNil: [ ^FileReference requestDropReference: i ].  fileName := self fileNames at: i.  ^(FilePathEncoder decode: fileName) asFileReference-=JUAMPI=-explicitFunction  function showWidget-=JUAMPI=-outerBounds  ^self bounds-=JUAMPI=-cellPositioning: aSymbol  cellPositioning := aSymbol-=JUAMPI=-actionOffset  ^4 * self displayScaleFactor-=JUAMPI=-wantsHaloFromClick  ^true-=JUAMPI=-removeKeyCombination: aShortcut  self kmDispatcher removeKeyCombination: aShortcut-=JUAMPI=-wantsToBeTopmost  ^false-=JUAMPI=-listDirection: aSymbol  listDirection := aSymbol-=JUAMPI=-beStraightSegments  smoothCurve == false ifFalse: [ smoothCurve := false.        self computeBounds ]-=JUAMPI=-wantsWindowEvent: anEvent  ^true-=JUAMPI=-setColor: aColor  self labelMorph color: aColor.  self solidLabelMorph color: aColor beOpaque-=JUAMPI=-testWhenChangingOrderInWorldListTaskOrderShouldRemains  | window1 window2 |  taskbar := self.  world := self.  window1 := world addWindow.  window2 := world addWindow.  taskbar updateTasks.  world putOnTop: window1.  taskbar updateTasks.  self assert: taskbar tasks first morph equals: window1.  self assert: taskbar tasks second morph equals: window2-=JUAMPI=-selectMoreAtTop  | first |  autoTargetMorph ifNil: [ ^self ].  first := autoTargetMorph index.  first > 1 ifTrue: [ self autoMultiSelect: (self allNodeMorphs at: first - 1).        self selectionChanged ]-=JUAMPI=-actionSelector  ^actionSelector-=JUAMPI=-adoptGradientColor: aColor  | c fs bfs bs bbs |  aColor ifNil: [ ^self ].  c := aColor.  fs := self normalThumbFillStyle.  bfs := self normalButtonFillStyle.  bs := self normalThumbBorderStyle.  bbs := self normalButtonBorderStyle.  sliderColor := c.  downButton     fillStyle: bfs;     borderStyle: bbs.  upButton     fillStyle: bfs shallowCopy;     borderStyle: bbs.  slider     fillStyle: fs;     borderStyle: bs.  self updateUpButtonImage.  self updateDownButtonImage-=JUAMPI=-newButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpText-=JUAMPI=-setTabContentFrom: aTab  | process |  contentsWrapper removeAllMorphs.  self cleanProcesses.  process := aTab retrieveMorph: [:contents |  contents ifNil: [ TabWithNoContents signalTab: aTab ].        contentsWrapper addMorph: contents fullFrame: LayoutFrame identity ].  process ifNotNil: [ processes add: process ]-=JUAMPI=-outermostMorphThat: conditionBlock  | outermost |  self allOwnersDo: [:m |  (conditionBlock value: m) ifTrue: [ outermost := m ] ].  ^outermost-=JUAMPI=-getColorSelector: anObject  getColorSelector := anObject-=JUAMPI=-wantsDroppedMorph: aMorph event: anEvent  ^aMorph dragTransferType == #dragTransfer ifTrue: [ super wantsDroppedMorph: aMorph event: anEvent ] ifFalse: [ self model wantsDroppedMorph: aMorph event: anEvent inMorph: self ]-=JUAMPI=-minHeight  | iconHeight |  iconHeight := self hasIcon ifTrue: [ self icon height + 2 ] ifFalse: [ 0 ].  ^((self contents heightToDisplayInTree: self) max: iconHeight) max: super minHeight-=JUAMPI=-wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph  (#(addDismissHandle:) includes: aSelector) ifTrue: [ ^self resistsRemoval not ].  (#(addDragHandle:) includes: aSelector) ifTrue: [ ^self okayToBrownDragEasily ].  (#(addGrowHandle: addScaleHandle:) includes: aSelector) ifTrue: [ ^self okayToResizeEasily ].  (#(addRotateHandle:) includes: aSelector) ifTrue: [ ^self okayToRotateEasily ].  (#(addRecolorHandle:) includes: aSelector) ifTrue: [ ^self renderedMorph wantsRecolorHandle ].  ^true-=JUAMPI=-transform: anEvent from: originalEvent andSendTo: aMorph  | transformedEvent |  transformedEvent := anEvent transformedBy: (aMorph transformedFrom: originalEvent hand).  ^aMorph handleEvent: transformedEvent-=JUAMPI=-releaseKeyboardFocus: aMorph  self keyboardFocus == aMorph ifTrue: [ self releaseKeyboardFocus ]-=JUAMPI=-computedBounds  | tb tbw yGap |  tb := treeMorph bounds.  tbw := treeMorph borderWidth.  yGap := self layoutInset asPoint y + self cellInset asPoint y.  ^tb bottomLeft + (tbw @ (self computedHeight + yGap) negated) corner: tb bottomRight - ((tbw * 2) @ yGap)-=JUAMPI=-newHueSelector: aModel getHue: getSel setHue: setSel help: helpText  ^self theme newHueSelectorIn: self for: aModel getHue: getSel setHue: setSel help: helpText-=JUAMPI=-nextPage: newLast  | addedNodeList |  newLast > self lastIndex ifFalse: [ ^self ].  self lastIndex < self nodeList size ifTrue: [ addedNodeList := self nodeList copyFrom: 1 to: newLast.        self lastIndex: newLast.        treeMorph scroller removeAllMorphs.        treeMorph addSubmorphsFromNodeList: addedNodeList previouslyExpanded: treeMorph currentlyExpanded ]-=JUAMPI=-isAdheringToRight  ^self edgeToAdhereTo == #right-=JUAMPI=-hasSelection  ^self selectedIndexes isNotEmpty-=JUAMPI=-generateKeyboardEvent: evtBuf  | buttons modifiers type pressType stamp charCode keyValue keyEvent |  stamp := evtBuf second.  stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].  pressType := evtBuf fourth.  pressType = EventKeyDown ifTrue: [ type := #keyDown.        lastKeyScanCode := evtBuf third ].  pressType = EventKeyUp ifTrue: [ type := #keyUp ].  pressType = EventKeyChar ifTrue: [ type := #keystroke ].  modifiers := evtBuf fifth.  buttons := modifiers bitShift: 3.  keyValue := evtBuf third.  charCode := evtBuf sixth.  type = #keystroke ifTrue: [ combinedChar ifNil: [ | peekedEvent |              peekedEvent := Sensor peekEvent.              (peekedEvent notNil and: [ peekedEvent fourth = EventKeyDown ]) ifTrue: [ (CombinedChar isCompositionCharacter: charCode) ifTrue: [ combinedChar := CombinedChar new.                          combinedChar simpleAdd: charCode asCharacter.                          (combinedChar combinesWith: peekedEvent third asCharacter) ifTrue: [ ^nil ] ] ] ] ifNotNil: [ (combinedChar simpleAdd: charCode asCharacter) ifTrue: [ charCode := combinedChar combined charCode ].              combinedChar := nil ] ].  (type = #keystroke and: [ (buttons anyMask: 16) and: [ {Character arrowUp .               Character arrowDown} includes: charCode asCharacter ] ]) ifTrue: [ ^MouseWheelEvent fromCharacter: charCode asCharacter position: lastMouseEvent cursorPoint buttons: buttons hand: self stamp: stamp ].  self flag: #pharoFixMe.  (charCode notNil and: [ charCode > 255 ]) ifTrue: [ keyValue := 0 ].  keyEvent := KeyboardEvent new setType: type buttons: buttons position: self position keyValue: keyValue charCode: charCode hand: self stamp: stamp.  keyEvent scanCode: lastKeyScanCode.  ^keyEvent-=JUAMPI=-mouseLeave: evt  ^self eventHandler ifNotNil: [ self eventHandler mouseLeave: evt fromMorph: self ]-=JUAMPI=-leftLayoutFrame  ^(0 @ 0 corner: 0 @ 1) asLayoutFrame     topOffset: -7;     bottomRightOffset: SystemWindow borderWidth @ (SystemWindow borderWidth - 26)-=JUAMPI=-selectMorph: aNodeMorph multiple: withMultipleSelection clickedTheCheckBox: checkBox  | path mult |  checkBox ifFalse: [ self lastClickedMorph: aNodeMorph ].  aNodeMorph ifNil: [ self emptySelection.        ^nil ].  aNodeMorph selected ifTrue: [ withMultipleSelection ifTrue: [ self removeFromSelection: aNodeMorph ] ifFalse: [ mult := self selectedMorphList size > 1.              path := aNodeMorph path collect: [:m |  m complexContents ].              (self autoDeselection or: [ mult ]) ifTrue: [ self emptySelection.                    mult ifTrue: [ self addToSelection: aNodeMorph ] ifFalse: [ path := nil ] ] ] ] ifFalse: [ withMultipleSelection ifFalse: [ self emptySelection ].        self addToSelection: aNodeMorph clickedTheCheckBox: checkBox.        path := aNodeMorph path collect: [:m |  m complexContents ] ].  self selectionChanged.  ^path-=JUAMPI=-takesKeyboardFocus  ^true-=JUAMPI=-releaseCachedState  self borderStyle releaseCachedState-=JUAMPI=-labelMorph  ^labelMorph-=JUAMPI=-drawDropHighlightOn: aCanvas  self highlightedForDrop ifTrue: [ aCanvas frameRectangle: self fullBounds color: self dropHighlightColor ]-=JUAMPI=-item: newItem  item := newItem-=JUAMPI=-newOKButton  ^self newOKButtonFor: self-=JUAMPI=-shouldFlex  ^true-=JUAMPI=-layoutFrame: aLayoutFrame  layoutFrame := aLayoutFrame-=JUAMPI=-borderStyleToUse  ^self isRadioButton ifTrue: [ self radioBorderStyleToUse ] ifFalse: [ self checkboxBorderStyleToUse ]-=JUAMPI=-newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpText-=JUAMPI=-adoptPaneColor: aColor  self color: aColor-=JUAMPI=-adjustBorderUponDeactivationWhenLabeless  | aWidth |  (aWidth := self valueOfProperty: #borderWidthWhenInactive) ifNotNil: [ self acquireBorderWidth: aWidth ]-=JUAMPI=-enabled: aBoolean  aBoolean = self enabled ifFalse: [ enabled := aBoolean.        self           adoptPaneColor: self paneColor;           changed ]-=JUAMPI=-balloonText  extension ifNil: [ ^nil ].  ^extension balloonText ifNotNil: [:text |  text asString withNoLineLongerThan: self theme settings maxBalloonHelpLineLength ]-=JUAMPI=-drawWithSelectionOn: canvas  canvas line: self bottomLeft + (0 @ -1) to: self selectedTab bottomLeft width: 1 color: self borderColor.  canvas line: self selectedTab bottomLeft to: self selectedTab bottomRight width: 1 color: self selectedColor.  canvas line: self selectedTab bottomRight to: self bottomRight + (0 @ -1) width: 1 color: self borderColor-=JUAMPI=-setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) rounded-=JUAMPI=-allowsKeymapping  ^self valueOfProperty: #allowsKeymapping ifAbsent: [ true ]-=JUAMPI=-originColumn: column row: rowIndex  ^FTCellMorph new     color: (self colorFor: rowIndex);     addMorph: (self elementAt: rowIndex) origin name asMorph;     yourself-=JUAMPI=-paneColor  ^self paneColorOrNil ifNil: [ self color ]-=JUAMPI=-mouseUp: anEvent  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: anEvent cursorPoint) ifFalse: [ anEvent hand showTemporaryCursor: nil ].  self class fastSplitterResize ifTrue: [ self updateFromEvent: anEvent ].  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUp-=JUAMPI=-buildVerticesFrom: borderVertices  ^state buildVerticesFrom: borderVertices-=JUAMPI=-scrollPane  ^scrollPane-=JUAMPI=-mouseOverBorderStyle  ^mouseOverBorderStyle ifNil: [ BorderStyle thinGray ]-=JUAMPI=-selectedLabel  ^selectedLabel-=JUAMPI=-canvas: x  -=JUAMPI=-useExtraSelection  ^self useFindReplaceSelection or: [ self useSecondarySelection ]-=JUAMPI=-themeChanged  self fillStyle: self normalFillStyle.  super themeChanged-=JUAMPI=-complexContents  ^complexContents-=JUAMPI=-addInterruptionButton  self isInterruptable ifFalse: [ ^self ].  self addMorphBack: (self iconNamed: #stopIcon) asMorph-=JUAMPI=-hand  ^source-=JUAMPI=-shouldDraw  ^super shouldDraw or: [ self class showSplitterHandles ]-=JUAMPI=-mouseEnterDragging: evt  evt hand mouseFocus == owner ifTrue: [ owner selectItem: self event: evt ]-=JUAMPI=-bounds: aRectangle in: referenceMorph  owner ifNil: [ ^aRectangle ].  ^(owner transformFrom: referenceMorph) localBoundsToGlobal: aRectangle-=JUAMPI=-transformBy: aMorphicTransform  position := aMorphicTransform globalPointToLocal: position-=JUAMPI=-getEnabledSelector  ^getEnabledSelector-=JUAMPI=-index: anIndex  index := anIndex-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: (splitsTopAndBottom ifTrue: [ #top ] ifFalse: [ #left ])-=JUAMPI=-asAthensCurvedPathOn: anAthensCanvas  | points |  points := self computeCurvedSegmentCtrlPoints.  ^anAthensCanvas createPath: [:builder |  self vertices notEmpty ifTrue: [ | prior |              prior := points first.              builder absolute.              builder moveTo: prior second.              points allButFirst do: [:p |  builder curveVia: prior third and: p first to: p second.                    prior := p ].              self isClosed ifTrue: [ builder curveVia: prior third and: points first first to: points first second.                    builder close ] ].        builder ]-=JUAMPI=-bottomFraction  ^bottomFraction-=JUAMPI=-newHSVSelector: aColor help: helpText  ^self theme newHSVSelectorIn: self color: aColor help: helpText-=JUAMPI=-handlesKeyboard: evt  ^true-=JUAMPI=-getLabelSelector: anObject  getLabelSelector := anObject.  self updateLabel-=JUAMPI=-hasProperty: aSymbol  extension ifNil: [ ^false ].  ^extension hasProperty: aSymbol-=JUAMPI=-intoWorldCount  ^intoWorldCount-=JUAMPI=-labelString  ^label ifNil: [ labelString ] ifNotNil: [ label contents asString ]-=JUAMPI=-getListItem: index  ^listSource getListRow: index-=JUAMPI=-addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol argumentList: argList  self addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol enablementSelector: nil argumentList: argList-=JUAMPI=-navigateWindowBackward  self previousWindow ifNotNil: [:m |  m isCollapsed ifTrue: [ m collapseOrExpand ].        m activate ]-=JUAMPI=-icon: anObject  icon := anObject-=JUAMPI=-adoptPaneColor: paneColor  (paneColor notNil and: [ self trackPaneColor ]) ifTrue: [ self color: paneColor ].  super adoptPaneColor: paneColor-=JUAMPI=-selectedObject  | halo |  halo := self halo.  halo ifNil: [ ^nil ].  ^halo target renderedMorph-=JUAMPI=-contents  ^text-=JUAMPI=-activeSubmenu: aSubmenu  activeSubMenu ifNotNil: [ activeSubMenu delete ].  activeSubMenu := aSubmenu.  aSubmenu ifNil: [ ^self ].  activeSubMenu selectItem: nil event: nil.  activeSubMenu borderColor: self borderColor.  activeSubMenu beSticky.  activeSubMenu resistsRemoval: true.  activeSubMenu removeMatchString-=JUAMPI=-setProperty: aSymbol toValue: abObject  self assureOtherProperties at: aSymbol put: abObject-=JUAMPI=-showFirstSelection  self hasSelection ifFalse: [ ^self ].  self moveShowIndexTo: self selectedIndex-=JUAMPI=-hasContents  ^self contents isEmpty not-=JUAMPI=-lastVertex  ^vertices last-=JUAMPI=-removeMorph: aMorph  | aWorld |  aMorph owner == self ifFalse: [ ^self ].  aWorld := self world.  aWorld ifNotNil: [ aMorph outOfWorld: aWorld.        self privateInvalidateMorph: aMorph ].  self privateRemove: aMorph.  aMorph privateOwner: nil.  self removedMorph: aMorph-=JUAMPI=-handlesMouseDown: evt  ^true-=JUAMPI=-selectedPressedBorderStyle  ^self theme controlButtonSelectedPressedBorderStyleFor: self-=JUAMPI=-highlightSelection  selectedMorph ifNotNil: [ selectedMorph highlight ]-=JUAMPI=-max  ^(self sliderMorph ifNil: [ ^0 ]) max-=JUAMPI=-newTabSelectorMorph  ^TabSelectorMorph new     vResizing: #shrinkWrap;     hResizing: #spaceFill-=JUAMPI=-announceDate  | announcement |  announcement := ChoseDate of: self date from: self.  announcer ifNotNil: [ announcer announce: announcement ]-=JUAMPI=-setColor: aColor toHandle: aHandle  aHandle color: aColor.  self gradientHalo ifTrue: [ | fill |        fill := GradientFillStyle ramp: {(0.0 -> aColor muchLighter) .               (1.0 -> aColor darker)}.        fill origin: aHandle topLeft.        fill direction: aHandle extent.        aHandle fillStyle: fill ]-=JUAMPI=-isCloseable  ^self mustNotClose not and: [ model ifNotNil: [ model okToChange ] ifNil: [ true ] ]-=JUAMPI=-selectLast  self table selectIndex: self table numberOfRows-=JUAMPI=-objectToPaste  ^Cursor wait showWhile: [ PasteBuffer veryDeepCopy ]-=JUAMPI=-halo  ^self primaryHand halo ifNotNil: [:h |  h target == self ifTrue: [ h ] ]-=JUAMPI=-themeChanged  self     removeAllMorphs;     initializeSlider.  super themeChanged-=JUAMPI=-initialize  super initialize.  self cellInset: 7-=JUAMPI=-setValue: newValue  self value: newValue.  setValueSelector ifNotNil: [ ^model perform: setValueSelector with: value ]-=JUAMPI=-target  ^objectToView-=JUAMPI=-shadowPoint: newPoint  self changed.  self shadowOffset: (newPoint - self center) // 5.  fullBounds ifNotNil: [ fullBounds := self privateFullBounds ].  self changed-=JUAMPI=-disable  self enabled: false-=JUAMPI=-athensDisplay: item atRow: row on: aCanvas  | c backgroundColor drawBounds |  drawBounds := self drawBoundsForRow: row.  c := self colorForRow: row.  backgroundColor := self backgroundColorForRow: row.  item listRenderOn: aCanvas asCanvasWrapper atRow: row bounds: drawBounds color: c backgroundColor: backgroundColor from: self.  row = self mouseDownRow ifTrue: [ (aCanvas setStrokePaint: c)           width: 1;           dashes: {1} offset: 0.        aCanvas drawShape: (self selectionFrameForRow: row) ]-=JUAMPI=-color: aColor  super color: aColor.  self setProperty: #basicColor toValue: aColor-=JUAMPI=-themeChanged  self onImage: (self isRadioButton ifTrue: [ self theme radioButtonMarkerForm ] ifFalse: [ self theme checkboxMarkerForm ]).  self adoptPaneColor: self paneColor.  super themeChanged-=JUAMPI=-separatorAfterARow: aRow  aRow ifNil: [ ^false ].  self separatorBlockOrSelector ifNotNil: [:blockOrSelector |  | anItem |        anItem := getListElementSelector ifNil: [ list at: aRow ifAbsent: [ ^false ] ] ifNotNil: [ model perform: getListElementSelector with: aRow ].        ^blockOrSelector isBlock ifTrue: [ blockOrSelector cull: anItem cull: aRow ] ifFalse: [ blockOrSelector isSymbol ifTrue: [ blockOrSelector numArgs == 0 ifTrue: [ anItem perform: blockOrSelector ] ifFalse: [ self model perform: blockOrSelector withEnoughArguments: {anItem .                                 aRow} ] ] ifFalse: [ false ] ] ].  ^false-=JUAMPI=-selectLast  self table selectIndex: {self table numberOfRows .         self table numberOfColumns}-=JUAMPI=-scrollLeft: count  self scrollUp: count-=JUAMPI=-offColor  ^offColor-=JUAMPI=-scrollAbsolute: event  | r p |  r := self roomToMove.  bounds isWide ifTrue: [ r width = 0 ifTrue: [ ^self ] ] ifFalse: [ r height = 0 ifTrue: [ ^self ] ].  p := event targetPoint adhereTo: r.  self descending ifFalse: [ self setValue: (bounds isWide ifTrue: [ (p x - r left) asFloat / r width ] ifFalse: [ (p y - r top) asFloat / r height ]) ] ifTrue: [ self setValue: (bounds isWide ifTrue: [ (r right - p x) asFloat / r width ] ifFalse: [ (r bottom - p y) asFloat / r height ]) ]-=JUAMPI=-transform  ^transform-=JUAMPI=-filterNowWith: patternString  pattern := patternString.  self field setText: pattern.  self filterWith: pattern.  self filter-=JUAMPI=-oldScrollingIndex  ^oldScrollingIndex-=JUAMPI=-newContentMorph  self hsvaMorph: self newHSVAColorSelectorMorph.  ^self newRow: {(self newGroupbox: 'Color' translated forAll: {self hsvaMorph .               ((self newRow: {((self newLabelGroup: {('Selected color' translated -> self newColorPresenterMorph)}) vResizing: #shrinkWrap) .                     self newColorPickerButtonMorph}) cellPositioning: #leftCenter)}) .         ((self newGroupbox: 'Values' translated for: (self newLabelGroup: {('Red' translated -> (self newColorComponentFieldMorph: #red)) .                     ('Green' translated -> (self newColorComponentFieldMorph: #green)) .                     ('Blue' translated -> (self newColorComponentFieldMorph: #blue)) .                     ('Hue' translated -> (self newColorComponentFieldMorph: #hue)) .                     ('Saturation' translated -> (self newColorComponentFieldMorph: #saturation)) .                     ('Brightness' translated -> (self newColorComponentFieldMorph: #brightness)) .                     ('Alpha' translated -> (self newColorComponentFieldMorph: #alpha))})) hResizing: #shrinkWrap)}-=JUAMPI=-containsPoint: aPoint  ^(lines at: (self lineIndexForPoint: aPoint)) rectangle containsPoint: aPoint-=JUAMPI=-removeOtherProperties  otherProperties := nil-=JUAMPI=-setMultipleSelection: aBoolean  aBoolean ifTrue: [ self beMultipleSelection ] ifFalse: [ self beSingleSelection ]-=JUAMPI=-addColumn: aTreeColumn  self addColumn: aTreeColumn afterIndex: self columns size-=JUAMPI=-selectionColor: aColor  selectionColor := aColor-=JUAMPI=-display: aBlock  displayBlock := aBlock-=JUAMPI=-isFullOnScreen  owner ifNil: [ ^true ].  self visible ifFalse: [ ^true ].  ^owner clearArea containsRect: self fullBounds-=JUAMPI=-offerWindowMenu  | aMenu |  aMenu := self buildWindowMenu.  model ifNotNil: [ model addModelItemsToWindowMenu: aMenu ].  aMenu popUpEvent: self currentEvent in: self world-=JUAMPI=-initialize  super initialize.  icon := ImageMorph new-=JUAMPI=-privateMoveBy: delta  super privateMoveBy: delta-=JUAMPI=-icon  ^icon-=JUAMPI=-addARowCentered: aCollectionOfMorphs cellInset: cellInsetInteger  ^(self addARow: aCollectionOfMorphs)     hResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #leftCenter;     cellInset: cellInsetInteger-=JUAMPI=-menuStringBounds  | stringBounds |  stringBounds := bounds.  self hasIcon ifTrue: [ | iconForm |        iconForm := self iconForm.        stringBounds := stringBounds left: stringBounds left + iconForm width + 2 ].  self hasMarker ifTrue: [ stringBounds := stringBounds left: stringBounds left + self submorphBounds width + 8 ].  ^stringBounds top: (stringBounds top + stringBounds bottom - self fontToUse height) // 2-=JUAMPI=-basicMoveShowIndexTo: aNumber  showIndex := aNumber-=JUAMPI=-tabs: aCollection  toolbar tabs: aCollection-=JUAMPI=-openModal: aSystemWindow  | area mySysWin keyboardFocus |  keyboardFocus := self activeHand keyboardFocus.  mySysWin := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  mySysWin ifNil: [ mySysWin := self ].  mySysWin modalLockTo: aSystemWindow.  area := RealEstateAgent maximumUsableArea.  aSystemWindow extent: aSystemWindow initialExtent.  aSystemWindow position = (0 @ 0) ifTrue: [ aSystemWindow position: self activeHand position - (aSystemWindow extent // 2) ].  aSystemWindow bounds: (aSystemWindow bounds translatedToBeWithin: area).  [ | aWidget |  aWidget := aSystemWindow openAsIs.  self activeHand mouseFocus: aWidget.  [ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] ensure: [ mySysWin modalUnlockFrom: aSystemWindow.        self activeHand newKeyboardFocus: keyboardFocus ].  ^aSystemWindow-=JUAMPI=-modalUnlockFrom: aSystemWindow  aSystemWindow removeProperty: #modalOwner.  self removeProperty: #modalChild.  closeBox ifNotNil: [:cl |  cl enabled: (self valueOfProperty: #preModalCloseEnabled ifAbsent: [ true ]) ].  self removeProperty: #preModalCloseEnabled.  self activate-=JUAMPI=-defaultBorderWidth  ^0-=JUAMPI=-passivate  super passivate.  self nonVisibleTabs do: [:t |  t passivate ]-=JUAMPI=-activeDisabledNotOverUpFillStyle: aFillStyle  self stateMap atPath: #(active disabled notOver up) put: aFillStyle.  self changed-=JUAMPI=-menuItems  ^submorphs select: [:m |  m isMenuItemMorph ]-=JUAMPI=-calendar: aCalendarChooserMorph  calendar := aCalendarChooserMorph-=JUAMPI=-updateWidth  self resize-=JUAMPI=-doubleClickSelector: aSelector  doubleClickSelector := aSelector-=JUAMPI=-apply: delta  | oldBounds |  oldBounds := target bounds.  target bounds: (oldBounds origin corner: oldBounds corner + delta)-=JUAMPI=-cellPositioning  ^#center-=JUAMPI=-newEditableDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newEditableDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpText-=JUAMPI=-collpasedButton  ^IconicButton new     target: self;     actionSelector: #expandAndRefresh;     arguments: {};     labelGraphic: self class unexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-=JUAMPI=-recipient  ^recipient-=JUAMPI=-newHueSelector: aModel getHue: getSel setHue: setSel help: helpText  ^self theme newHueSelectorIn: self for: aModel getHue: getSel setHue: setSel help: helpText-=JUAMPI=-trackDirectionArrow: anEvent with: shaft  anEvent hand obtainHalo: self.  shaft setVertices: {directionArrowAnchor .         anEvent cursorPoint}.  self layoutChanged-=JUAMPI=-stateSelector: anObject  stateSelector := anObject-=JUAMPI=-newListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpText  ^self theme newListIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpText-=JUAMPI=-drawOn: aCanvas  | keyBounds |  keyBounds := self boundsForKeyText: self keyText font: self owner fontToUse.  self owner drawText: keyText on: aCanvas in: keyBounds color: self color-=JUAMPI=-userString  ^String streamContents: [:stream |  1 to: self getListSize do: [:i |  (self getListItem: i) submorphs detect: [:morph |  morph userString notNil ] ifFound: [:morph |  stream nextPutAll: morph userString ].              stream cr ] ]-=JUAMPI=-triggerOnMouseDown  ^triggerOnMouseDown-=JUAMPI=-currentNodelist  ^self nodeList-=JUAMPI=-newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText-=JUAMPI=-setColorSelector: anObject  setColorSelector := anObject-=JUAMPI=-canDrawBorder: aBorderStyle  ^aBorderStyle style == #simple-=JUAMPI=-setLastCharacter: source  | aChar chars |  aChar := source asCharacter.  (chars := self getCharacters) size > 0 ifFalse: [ self newContents: (String with: aChar) ] ifTrue: [ chars last = aChar ifFalse: [ self newContents: (String streamContents: [:aStream |  aStream nextPutAll: (chars copyFrom: 1 to: chars size - 1).                          aStream nextPut: aChar ]) ] ]-=JUAMPI=-bottomRightColor  ^self color-=JUAMPI=-doneWithEdits  hasFocus := false-=JUAMPI=-chooseFileName: title extensions: exts path: path preview: preview  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: title extensions: exts path: path preview: preview-=JUAMPI=-chooseServiceFrom: aCollection  aCollection size = 1 ifTrue: [ ^aCollection anyOne ].  ^UIManager default chooseFrom: (aCollection collect: [:each |  each label ]) values: aCollection-=JUAMPI=-medium  ^27-=JUAMPI=-on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel  self model: anObject.  getListSelector := getListSel.  getIndexSelector := getSelectionSel.  setIndexSelector := setSelectionSel.  getMenuSelector := getMenuSel.  keystrokeActionSelector := keyActionSel.  self autoDeselect: true.  self borderWidth: 1.  self updateList.  self selectionIndex: self getCurrentSelectionIndex.  self initForKeystrokes-=JUAMPI=-selectedFillStyle  ^self theme buttonSelectedFillStyleFor: self-=JUAMPI=-setUp  super setUp.  prototypes     add: (TextAnchor new anchoredMorph: Morph new initialize);     add: (TextAnchor new anchoredMorph: EllipseMorph new initialize)-=JUAMPI=-font: anObject  font := anObject-=JUAMPI=-beRowSelection  self selectionModeStrategy: (FTRowSelectionModeStrategy table: self)-=JUAMPI=-roomToMove  ^self totalSliderArea insetBy: (0 @ 0 extent: self sliderExtent)-=JUAMPI=-treeLineWidth  ^treeLineWidth ifNil: [ treeLineWidth := self theme treeLineWidth ]-=JUAMPI=-fontName: fontName pointSize: fontSize  | newTextStyle |  newTextStyle := ((TextStyle named: fontName asSymbol) ifNil: [ TextStyle default ]) copy.  newTextStyle ifNil: [ self error: 'font ' , fontName , ' not found.' ].  textStyle := newTextStyle.  text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOfPointSize: fontSize)).  paragraph ifNotNil: [ paragraph textStyle: newTextStyle ]-=JUAMPI=-currentNodelist  ^self pager ifNil: [ super nodeList ] ifNotNil: [ self pager currentNodelist ]-=JUAMPI=-hasHighlighted  ^self highlightedIndexes notEmpty-=JUAMPI=-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self assureExtension.  extension fillStyle ifNil: [ self color: paneColor ].  self borderStyle baseColor: paneColor darker-=JUAMPI=-recordDamagedRect: damageRect  damageRecorder ifNotNil: [ damageRecorder recordInvalidRect: damageRect truncated ]-=JUAMPI=-initialize  super initialize.  self     style: #inset;     trackPaneColor: true-=JUAMPI=-showSelectionFeedback  ^showSelectionFeedback-=JUAMPI=-computeFramedColors  | base light dark w hw colorArray param |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  w = 1 ifTrue: [ ^{(base mixed: 0.5 with: light) .         (base mixed: 0.5 with: dark)} ].  colorArray := Array new: w.  hw := w // 2.  0 to: hw - 1 do: [:i |  param := 0.5 + (i asFloat / hw * 0.5).        colorArray at: i + 1 put: (base mixed: param with: light).        colorArray at: w - i put: (base mixed: param with: dark) ].  w odd ifTrue: [ colorArray at: hw + 1 put: base ].  ^colorArray , colorArray-=JUAMPI=-newAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel font: aFont help: helpText-=JUAMPI=-newLeftButton  ^(ControlButtonMorph on: self getState: nil action: #scrollTabsLeft label: #leftButtonLabel)     getEnabledSelector: #leftButtonEnabled;     hResizing: #rigid;     vResizing: #spaceFill;     cornerStyle: #square;     extent: self controlButtonWidth asPoint-=JUAMPI=-rowColorForOdd: oddColor  rowColors at: 2 put: oddColor-=JUAMPI=-hasChildren  ^(dataSource childrenBlock value: item) isNotEmpty-=JUAMPI=-initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel  container := hostList.  self cellInset: container resizerWidth @ 0.  complexContents := anObject.  complexContents addDependent: self.  isExpanded := complexContents isExpanded.  nextSibling := firstChild := nil.  priorMorph ifNotNil: [ priorMorph nextSibling: self ].  indentLevel := newLevel.  self setBalloonText: complexContents helpText.  self initRow.  complexContents selected ifTrue: [ self selectedWithoutNotifyingComplexContents: true ]-=JUAMPI=-selectionChanged  self requestView: (MorphTreeSelectionChanged new selection: self selection)-=JUAMPI=-handlerForBlueButtonDown: anEvent  self wantsHaloFromClick ifFalse: [ ^nil ].  self class cycleHalosBothDirections ifTrue: [ anEvent handler ifNil: [ ^self ].        (anEvent handler isKindOf: PasteUpMorph) ifTrue: [ ^self ] ].  anEvent shiftPressed ifFalse: [ ^nil ] ifTrue: [ ^self ]-=JUAMPI=-resizeFromMenu  self resizeMorph: ActiveEvent-=JUAMPI=-handleStep: anEvent  ^self dispatchDefault: anEvent with: morph-=JUAMPI=-separatorSize: anInteger  separatorSize := anInteger-=JUAMPI=-yellowButtonActivity: shiftKeyState  (self getMenu: shiftKeyState) ifNotNil: [:menu |  menu setInvokingView: self.        menu popUpEvent: self activeHand lastEvent in: self world.        ^true ].  ^false-=JUAMPI=-translateBy: delta  position := position + delta-=JUAMPI=-itemsForTest  ^rootClass allSubclasses-=JUAMPI=-minExtentFrom: minExtent  | width height widthProp heightProp |  width := minExtent x + leftOffset - rightOffset.  height := minExtent y + topOffset - bottomOffset.  widthProp := rightFraction - leftFraction.  heightProp := bottomFraction - topFraction.  width := widthProp = 0 ifTrue: [ 0 ] ifFalse: [ width / widthProp ].  height := heightProp = 0 ifTrue: [ 0 ] ifFalse: [ height / heightProp ].  ^width truncated @ height truncated-=JUAMPI=-maxNodeWidth  ^maxNodeWidth ifNil: [ maxNodeWidth := 0 ]-=JUAMPI=-themedFillStyle  ^self theme buttonNormalFillStyleFor: self-=JUAMPI=-addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol enablementSelector: enableSymbol argumentList: argList  | item |  item := ToggleMenuItemMorph new     contents: aString;     target: anObject;     selector: aSymbol;     arguments: argList;     getStateSelector: stateSymbol;     enablementSelector: enableSymbol.  ^self addMenuItem: item-=JUAMPI=-configureForUnembedding  labelArea owner ifNil: [ self           makeBordered;           initializeLabelArea;           themeChanged;           addGrips ]-=JUAMPI=-hasItems  ^submorphs anySatisfy: [:each |  each isMenuItemMorph ]-=JUAMPI=-newRow  ^self theme newRowIn: self for: #()-=JUAMPI=-autoAccept: aBoolean  autoAccept := aBoolean-=JUAMPI=-multipleSelection  ^multipleSelection ifNil: [ multipleSelection := self defaultMultipleSelectionValue ]-=JUAMPI=-selectIndexes: index previous: oldSelection  self table selectIndexes: (((oldSelection includes: index) ifTrue: [ oldSelection copyWithout: index ] ifFalse: [ oldSelection ]) copyWithFirst: index)-=JUAMPI=-resizeToFit  ^self vResizing == #shrinkWrap-=JUAMPI=-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  scrollBar adoptPaneColor: paneColor.  hScrollBar adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self borderWidth > 0 ifTrue: [ self borderStyle: self borderStyleToUse ]-=JUAMPI=-passengerAt: rowIndex  ^self elementAt: rowIndex-=JUAMPI=-removeCollapseBox  collapseBox ifNotNil: [ collapseBox delete.        collapseBox := nil ]-=JUAMPI=-adjustLineIndicesBy: delta  firstCharacterIndex := firstCharacterIndex + delta.  lines do: [:line |  line slide: delta ]-=JUAMPI=-setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp  type := aSymbol.  buttons := anInteger.  position := pos.  keyValue := aValue.  source := aHand.  wasHandled := false.  timeStamp := stamp-=JUAMPI=-handlesMouseOver: evt  ^true-=JUAMPI=-model: aTreeModel  self model ifNotNil: [ self model announcer unsubscribe: self ].  super model: aTreeModel.  self registerRequestHandlers-=JUAMPI=-asSpecAdapter  ^MorphicGenericAdapter morph: self-=JUAMPI=-toggleSelected  self takeKeyboardFocus.  self enabled ifFalse: [ ^self ].  self model ifNil: [ ^self ].  (self setStateSelector ifNil: [ ^self ]) numArgs = 0 ifTrue: [ self model perform: self setStateSelector ].  self setStateSelector numArgs = 1 ifTrue: [ self model perform: self setStateSelector with: self isSelected not ].  self updateSelection-=JUAMPI=-handleMouseOver: anEvent  ^self dispatchDefault: anEvent with: morph-=JUAMPI=-cellPositioning  | props |  props := self layoutProperties.  ^props ifNil: [ #center ] ifNotNil: [ props cellPositioning ]-=JUAMPI=-menu: menu shifted: b  super menu: menu shifted: b.  menu addLine.  self selectedNode ifNotNil: [:current |  current menu: menu shifted: b ].  ^menu-=JUAMPI=-balloonHelpTextForHandle: aHandle  (aHandle eventHandler mouseSelectorsInclude: #doRecolor:with:) ifTrue: [ ^'Change color' ].  (aHandle eventHandler mouseSelectorsInclude: #mouseDownInDimissHandle:with:) ifTrue: [ ^'Remove from screen' translated ].  #(#(#addFullHandles 'More halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#trackCenterOfRotation:with: 'Set center of rotation')) do: [:pair |  (aHandle eventHandler mouseSelectorsInclude: pair first) ifTrue: [ ^pair last ] ].  ^'unknown halo handle' translated-=JUAMPI=-initializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigation.  aKMDispatcher attachCategory: #TabMorphsNavigation-=JUAMPI=-collapsedFrame  ^collapsedFrame-=JUAMPI=-subMenuSelector  ^subMenuSelector-=JUAMPI=-show: aString from: startNumber to: endNumber  | progressMorph |  self flag: #pharoFixMe.  self openInWorld.  progressMorph := self addItemShowing: aString from: startNumber to: endNumber.  self     refresh;     reposition.  ^progressMorph-=JUAMPI=-resetPotentialDropMorph  potentialDropMorph ifNotNil: [ potentialDropMorph resetHighlightForDrop.        potentialDropMorph := nil ]-=JUAMPI=-wrapFlag: aBoolean  aBoolean == wrapFlag ifTrue: [ ^self ].  wrapFlag := aBoolean.  self composeToBounds-=JUAMPI=-secondarySelectionColor  ^self theme secondarySelectionColor-=JUAMPI=-seeClassSide  -=JUAMPI=-addNavigationPane: aNavigPane  pager := aNavigPane.  self addMorph: pager.  pager buildPanel.  self updatePager.  self changed-=JUAMPI=-icon: aBlock  self dataSource icon: aBlock-=JUAMPI=-parent: aNodeMorph  parent := aNodeMorph-=JUAMPI=-popUpForHand: hand in: aWorld  | p |  p := hand position truncated.  ^self popUpAt: p forHand: hand in: aWorld-=JUAMPI=-fromArray: anArray  | str |  str := anArray readStream.  #(leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset:) do: [:sel |  str next ifNil: [ ^self ] ifNotNil: [:value |  self perform: sel with: value ] ]-=JUAMPI=-doFastWindowReframe: aSideOrCornerName  (FastDraggingFrameMorph forResizing: self fromLocation: aSideOrCornerName) openInWorld-=JUAMPI=-baseColor  ^self theme autoMenuColor ifTrue: [ owner color twiceDarker ] ifFalse: [ self theme currentSettings flatMenu ifFalse: [ owner color ] ifTrue: [ owner color twiceDarker ] ]-=JUAMPI=-initialize  super initialize.  self     changeProportionalLayout;     bounds: self currentWorld clearArea;     beSticky-=JUAMPI=-computeLength  | width size length |  size := tabs size.  size isZero ifTrue: [ ^0 ].  width := self width - self extraSpace + ((size - 1) * self overlap).  length := width / size.  length := length min: 150 * self displayScaleFactor.  length := length max: 33 * self displayScaleFactor.  ^length-=JUAMPI=-newPluggableDialogWindow: title for: contentMorph  ^self theme newPluggableDialogWindowIn: self title: title for: contentMorph-=JUAMPI=-iconFor: rowIndex  ^(self elementAt: rowIndex) actionOn: self-=JUAMPI=-fileNames  ^fileNames-=JUAMPI=-initDraggedMorph  draggedMorph ifNotNil: [ ^self ].  draggedMorph := self passenger asDraggableMorph.  self addMorphBack: draggedMorph.  self updateCopyIcon.  self     changed;     fullBounds-=JUAMPI=-useSortedTabsBy: sortBlock  toolbar useSortedTabsBy: sortBlock-=JUAMPI=-eventListeners  ^eventListeners-=JUAMPI=-actualViewee  | aMorph actualViewee |  aMorph := self morphToView ifNil: [ ^nil ].  aMorph isInWorld ifFalse: [ ^nil ].  actualViewee := viewSelector ifNil: [ aMorph ] ifNotNil: [ objectToView perform: viewSelector ].  actualViewee = 0 ifTrue: [ ^nil ].  actualViewee ifNil: [ actualViewee := objectToView ].  (actualViewee isMorph and: [ actualViewee isFlexMorph and: [ actualViewee submorphs size = 1 ] ]) ifTrue: [ actualViewee := actualViewee firstSubmorph ].  ^actualViewee-=JUAMPI=-popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem  | tryToPlace selectedOffset |  hand world startSteppingSubmorphsOf: self.  popUpOwner := sourceItem.  self fullBounds.  self updateColor.  selectedOffset := selectedItem ifNil: [ self items ifEmpty: [ 0 @ 0 ] ifNotEmpty: [:col |  col first position - self position ] ] ifNotNil: [ selectedItem position - self position ].  tryToPlace := [:where :mustFit |  | delta |  self position: where - selectedOffset.  delta := self fullBoundsInWorld amountToTranslateWithin: sourceItem worldBounds.  (delta x = 0 or: [ mustFit ]) ifTrue: [ delta = (0 @ 0) ifFalse: [ self position: self position + delta ].        sourceItem world addMorphFront: self.        ^self ] ].  tryToPlace     value: rightOrLeftPoint first value: false;     value: rightOrLeftPoint last - (self width @ 0) value: false;     value: rightOrLeftPoint first value: true-=JUAMPI=-modalLockTo: aSystemWindow  self lock-=JUAMPI=-displaySelectionBarOnAthensCanvas: anAthensCanvas  | visibleRectangle line |  selectionStart ifNil: [ ^self ].  selectionStop ifNil: [ ^self ].  visibleRectangle := anAthensCanvas clipRect.  selectionStart textLine = selectionStop textLine ifFalse: [ ^self ].  line := selectionStart textLine.  anAthensCanvas setPaint: self selectionBarColor.  anAthensCanvas drawShape: (visibleRectangle left @ line top corner: visibleRectangle right @ line bottom)-=JUAMPI=-hResizeScrollbar  | b |  b := self innerBounds.  b := b top: b bottom - self scrollBarThickness.  self vScrollbarShowing ifTrue: [ b := b right: b right - self scrollBarThickness ].  self hScrollbar bounds: b-=JUAMPI=-initializeLabel: aString start: startNumber end: endNumber  lock := Semaphore forMutualExclusion.  hasResult := false.  lastRefresh := 0.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #center;     cellInset: 5;     listCentering: #center;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap.  labelMorph := StringMorph contents: aString font: StandardFonts windowTitleFont.  self addMorphBack: labelMorph.  bar := ProgressBarMorph from: startNumber to: endNumber.  self addMorphBack: bar-=JUAMPI=-withHLines: aBoolean  withHLines := aBoolean-=JUAMPI=-themeChanged  super themeChanged.  tabs do: #themeChanged-=JUAMPI=-withText: aStringOrText label: title  self title: title.  self addMorph: (RubScrolledTextMorph new           setText: aStringOrText asString;           yourself) fullFrame: LayoutFrame identity.  self themeChanged-=JUAMPI=-invokeModal  ^self invokeModal: self menuKeyboardControl-=JUAMPI=-valueParameter: anObject  valueParameter := anObject-=JUAMPI=-leftMarginForAlignment: alignmentCode  alignmentCode = RightFlush ifTrue: [ ^self left + paddingWidth ].  alignmentCode = Centered ifTrue: [ ^self left + (paddingWidth // 2) ].  ^self left-=JUAMPI=-minWidth  ^self minimumExtent x max: super minWidth-=JUAMPI=-fillStyle: anObject  fillStyle := anObject-=JUAMPI=-deny: aStringOrText title: aString  ^self theme denyIn: self text: aStringOrText title: aString-=JUAMPI=-wantsRoundedCorners  ^color isTransparent not and: [ owner wantsRoundedCorners ]-=JUAMPI=-usableArea  ^self viewBox-=JUAMPI=-minHeight  | noVPlease noHPlease minH |  noVPlease := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  noHPlease := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  minH := noVPlease ifTrue: [ noHPlease ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness ] ] ifFalse: [ noHPlease ifTrue: [ self scrollBarThickness * 3 ] ifFalse: [ self scrollBarThickness * 4 + 2 ] ].  ^minH max: super minHeight-=JUAMPI=-disabledBorderStyle  ^self theme buttonDisabledBorderStyleFor: self-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: #left-=JUAMPI=-addPaneVSplitters  | remaining targetRight sameRight sameLeft |  remaining := paneMorphs reject: [:each |  each layoutFrame rightFraction = 1 or: [ each layoutFrame rightFraction = 0 ] ].  [ remaining notEmpty ] whileTrue: [ targetRight := remaining first layoutFrame rightFraction.        sameRight := remaining select: [:each |  each layoutFrame rightFraction = targetRight ].        sameLeft := paneMorphs select: [:each |  each layoutFrame leftFraction = targetRight and: [ each layoutFrame rightFraction ~= targetRight ] ].        remaining := remaining copyWithoutAll: (self addPaneVSplitterBetween: sameRight and: sameLeft) ]-=JUAMPI=-world  ^owner ifNotNil: [ owner world ]-=JUAMPI=-removeFlexShell  self isFlexed ifTrue: [ self owner removeFlexShell ]-=JUAMPI=-activateSubmenu: evt  subMenu ifNil: [ ^false ].  (subMenu fullContainsPoint: evt position) ifFalse: [ ^false ].  subMenu activate: evt.  self removeAlarm: #deselectTimeOut:.  ^true-=JUAMPI=-exposedColumnsRange: columnWidths  ^self startColumnIndex isZero ifTrue: [ 1 to: self table numberOfColumns ] ifFalse: [ (1 to: columnWidths size) select: [:idx |  (columnWidths at: idx) > 0 ] ]-=JUAMPI=-updateOrderedTasksFrom: tasksThatShouldBeUpdated  | deadTasks |  deadTasks := OrderedCollection new.  self orderedTasks do: [:aTaskbarTask |  tasksThatShouldBeUpdated detect: [:aTaskThatShouldBeUpdated |  aTaskThatShouldBeUpdated morph = aTaskbarTask morph ] ifFound: [:foundTask |  tasksThatShouldBeUpdated remove: foundTask ] ifNone: [ deadTasks add: aTaskbarTask ] ].  (deadTasks isEmpty and: [ tasksThatShouldBeUpdated isEmpty ]) ifTrue: [ ^self ].  self orderedTasks: (self orderedTasks           removeAll: deadTasks;           addAll: tasksThatShouldBeUpdated;           yourself)-=JUAMPI=-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-=JUAMPI=-scrollValue  ^0 @ self verticalScrollBar value-=JUAMPI=-addHandlesTo: aHaloMorph box: box  | onlyThese |  aHaloMorph haloBox: box.  onlyThese := #(addDismissHandle: addMenuHandle: addGrabHandle: addDragHandle: addDupHandle: addHelpHandle: addGrowHandle: addFontSizeHandle: addFontStyleHandle: addFontEmphHandle: addRecolorHandle:).  HaloMorph currentHaloSpecifications do: [:aSpec |  (onlyThese includes: aSpec addHandleSelector) ifTrue: [ aHaloMorph perform: aSpec addHandleSelector with: aSpec ] ].  aHaloMorph innerTarget addOptionalHandlesTo: aHaloMorph box: box-=JUAMPI=-releaseCachedState  colors := nil.  lineStyles := nil-=JUAMPI=-keyUp: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #keyUp from: sourceMorph-=JUAMPI=-filter  self subclassResponsibility-=JUAMPI=-addMorph: aMorph fullFrame: aLayoutFrame  aMorph layoutFrame: aLayoutFrame asLayoutFrame.  aMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorph: aMorph-=JUAMPI=-containsPoint: aPoint  ^target ifNil: [ super containsPoint: aPoint ] ifNotNil: [ false ]-=JUAMPI=-newGroupbox: aString forAll: controls  ^self theme newGroupboxIn: self label: aString forAll: controls-=JUAMPI=-pressedFillStyle  ^self theme morphTreeSplitterPressedFillStyleFor: self-=JUAMPI=-setRotationCenterFrom: aPoint  self setProperty: #referencePosition toValue: aPoint-=JUAMPI=-eventListeners: anArrayOrNil  eventListeners := anArrayOrNil-=JUAMPI=-actionSelector: aSymbolOrString  (nil = aSymbolOrString or: [ 'nil' = aSymbolOrString or: [ aSymbolOrString isEmpty ] ]) ifTrue: [ ^actionSelector := nil ].  actionSelector := aSymbolOrString asSymbol-=JUAMPI=-changeMaxCellSize: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self maxCellSize: (newPoint - evt cursorPoint) asIntegerPoint ].  evt hand attachMorph: handle.  handle startStepping-=JUAMPI=-clyAddEmphasis: aTextEmphasis  self emphasis: (emphasis bitOr: aTextEmphasis emphasisCode)-=JUAMPI=-initializeShortcuts: aKMDispatcher  aKMDispatcher attachCategory: #MorphFocusCtrlNavigation-=JUAMPI=-findReplaceDialog  ^EditorFindReplaceDialogWindow singleton-=JUAMPI=-veryDeepCopyWith: deepCopier  ^self-=JUAMPI=-newSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText-=JUAMPI=-animateRestore  | expandedRect restoredRect rects steps |  expandedRect := self bounds.  restoredRect := self unexpandedFrame.  steps := self theme numberOfStepsForAnimations.  rects := ((steps - 1) / steps to: 0 by: -1 / steps) collect: [:x |  restoredRect interpolateTo: expandedRect at: ((20 raisedTo: x) - 1) / 19 ].  self fastAnimateRectangles: rects-=JUAMPI=-asAthensShapeOn: anAthensCanvas  | halfWidth halfHeight |  self bounds area > 0 ifFalse: [ ^self ].  halfWidth := self bounds width / 2 asFloat.  halfHeight := self bounds height / 2 asFloat.  ^anAthensCanvas createPath: [:builder |  builder           absolute;           moveTo: self bounds center;           relative;           moveTo: halfWidth negated @ 0;           curveVia: 0 @ (halfHeight negated * 0.55) and: (0.45 * halfWidth) @ halfHeight negated to: halfWidth @ halfHeight negated;           curveVia: (halfWidth * 0.55) @ 0 and: halfWidth @ (0.45 * halfHeight) to: halfWidth @ halfHeight;           curveVia: 0 @ (halfHeight * 0.55) and: (0.45 * halfWidth negated) @ halfHeight to: halfWidth negated @ halfHeight;           curveVia: (halfWidth negated * 0.55) @ 0 and: halfWidth negated @ (halfHeight negated * 0.45) to: halfWidth negated @ halfHeight negated ]-=JUAMPI=-nextCell  ^nextCell-=JUAMPI=-veryDeepInner: deepCopier  super veryDeepInner: deepCopier.  activatorDockingBar := activatorDockingBar-=JUAMPI=-chooseForSaveFileReference: title extensions: exts path: path preview: preview  ^self theme chooseForSaveFileReferenceIn: self title: title extensions: exts path: path preview: preview-=JUAMPI=-initialize  expanded := false.  depth := 0.  children := #()-=JUAMPI=-topRight: aPoint  self position: (aPoint x - bounds width) @ aPoint y-=JUAMPI=-alignBottomEdges  | maxBottom |  maxBottom := (selectedItems collect: [:itm |  itm bottom ]) max.  selectedItems do: [:itm |  itm bottom: maxBottom ].  self changed-=JUAMPI=-treeRenderOn: aCanvas bounds: drawBounds color: drawColor font: aFont from: aMorph  self bounds: drawBounds.  aMorph addMorphBack: self-=JUAMPI=-string  ^string-=JUAMPI=-setColorSelector  ^setColorSelector-=JUAMPI=-originalCenter: anObject  originalCenter := anObject-=JUAMPI=-selectedWithoutNotifyingComplexContents: aBoolean  aBoolean ifFalse: [ ^self ].  container listManager silentlySetSelectedMorph: self.  selected := aBoolean-=JUAMPI=-undoRedoExchange: aninterval with: anotherInterval  self handleEdit: [ self editor undoRedoExchange: aninterval with: anotherInterval ]-=JUAMPI=-defaultBorderWidth  ^self theme borderWidth-=JUAMPI=-navigationKey: anEvent  self isMultipleSelection ifTrue: [ | keyString |        keyString := anEvent keyString.        keyString = '<Cmd-a>' ifTrue: [ self selectAll.              ^true ].        keyString = '<Cmd-A>' ifTrue: [ self deselectAll.              ^true ] ].  ^super navigationKey: anEvent-=JUAMPI=-asMorph  ^self-=JUAMPI=-isUp  ^direction = Character arrowUp-=JUAMPI=-mouseUp: event  self storeValue: nil.  super mouseUp: event-=JUAMPI=-isMenuMorph  ^false-=JUAMPI=-testMouseEnterEventIsNotDuplicated  | mockObject window evt |  mockObject := MockObjectForEventTests new.  [ window := mockObject stringMorph openInWindow.  evt := MouseButtonEvent new setType: nil position: mockObject stringMorph center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  self assert: mockObject counter equals: 0.  mockObject stringMorph handleMouseEnter: evt.  self assert: mockObject counter equals: 1 ] ensure: [ window ifNotNil: #close ]-=JUAMPI=-mouseEnter: evt  self color: (selectionColor isTransparent ifTrue: [ self mouseOverColor ] ifFalse: [ self mouseOverColor mixed: 0.5 with: selectionColor ])-=JUAMPI=-mouseUpInSlider: event  sliderShadow hide.  (slider containsPoint: event position) ifTrue: [ slider           fillStyle: self mouseOverThumbFillStyle;           borderStyle: self mouseOverThumbBorderStyle ] ifFalse: [ self mouseLeaveThumb: event ].  slider changed-=JUAMPI=-on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel  self on: anObject getState: getStateSel action: actionSel label: labelSel icon: nil menu: menuSel-=JUAMPI=-indentationLevel: anInteger  indent := anInteger-=JUAMPI=-lastKeystrokeTime  ^lastKeystrokeTime-=JUAMPI=-paneColor  ^self paneColorOrNil ifNil: [ self owner ifNil: [ Color transparent ] ifNotNil: [ self owner color ] ]-=JUAMPI=-rowHeight  ^rowHeight ifNil: [ rowHeight := self class defaultRowHeight ]-=JUAMPI=-selectableIndexAfter: anIndex  ^self subclassResponsibility-=JUAMPI=-lastSelection: anObject  lastSelection := anObject-=JUAMPI=-drawOnAthensCanvas: anAthensCanvas  | border ellipse |  self bounds area > 0 ifFalse: [ ^self ].  border := self borderStyle.  ellipse := self asAthensShapeOn: anAthensCanvas.  anAthensCanvas setPaint: self fillStyle.  anAthensCanvas setShape: ellipse.  anAthensCanvas draw.  (anAthensCanvas setStrokePaint: border color) width: border width.  anAthensCanvas draw-=JUAMPI=-orientation  ^orientation-=JUAMPI=-selectToMe  self triggerEvent: #tabSelectTo with: self-=JUAMPI=-bottomArrow  ^BottomArrow-=JUAMPI=-buildPanel  | widgets firstPageButton previousButton wid nextButton lastPageButton pageSizeEditor searchEditor |  self removeAllMorphs.  pageSize ifNil: [ ^self ].  self nodeList ifNil: [ ^self ].  widgets := OrderedCollection new.  self nodeList size > pageSize ifTrue: [ firstPageButton := self buttonLabel: self class smallToLeftEndIcon actionSelector: #currentPage: arguments: {1} getEnabled: #notOnFirstPage help: 'First page'.        widgets add: firstPageButton.        previousButton := self buttonLabel: self class smallToLeftIcon actionSelector: #previousPage arguments: {} getEnabled: #notOnFirstPage help: 'Previous page'.        widgets add: previousButton.        wid := self textEntryLabel: '' get: #currentPageToString set: #currentPageInput: help: 'Index of page to view' translated class: String.        wid hResizing: #rigid.        wid width: (self preferedFont widthOfString: '1000000').        widgets add: wid.        widgets add: (self buttonLabel: self class smallDiezeIcon actionSelector: #choosePage arguments: {} getEnabled: nil help: 'Choose page').        nextButton := self buttonLabel: self class smallToRightIcon actionSelector: #nextPage arguments: {} getEnabled: #notOnLastPage help: 'Next page'.        widgets add: nextButton.        lastPageButton := self buttonLabel: self class smallToRightEndIcon actionSelector: #currentPage: arguments: {self lastPage} getEnabled: #notOnLastPage help: 'Last page'.        widgets add: lastPageButton.        widgets add: (self spacer: 10) ].  widgets add: (LabelMorph contents: 'Page size: ' font: self preferedFont).  pageSizeEditor := self textEntryLabel: 'Page size' get: #pageSizeToString set: #pageSizeFromString: help: 'Change the page size or the number of pages if the input begins with "/"' translated class: String.  pageSizeEditor hResizing: #rigid.  pageSizeEditor width: (self preferedFont widthOfString: '1000000').  widgets add: pageSizeEditor.  self withSearch ifTrue: [ searchEditor := self textEntryLabel: '' get: #pageSearchText set: #pageSearchText: help: 'Enter a text correspondig to your search' translated class: String.        searchEditor ghostText: 'Searched text'.        widgets add: searchEditor ].  self addAllMorphs: widgets.  self updateContents-=JUAMPI=-testSelectableIndexAbove  self subclassResponsibility-=JUAMPI=-basicSelectedColor: anObject  selectedColor := anObject.  self     changed: #selectedColor;     changed: #red;     changed: #green;     changed: #blue;     changed: #hue;     changed: #saturation;     changed: #brightness;     changed: #alpha.  self announcer announce: (ColorChanged to: selectedColor)-=JUAMPI=-autoAccept: anObject  autoAccept := anObject-=JUAMPI=-newAlphaImage: aForm help: helpText  ^self theme newAlphaImageIn: self image: aForm help: helpText-=JUAMPI=-proceed: aStringOrText  ^self proceed: aStringOrText title: 'Proceed' translated-=JUAMPI=-extent: aPoint  | old |  old := self extent.  super extent: aPoint.  self extent = old ifTrue: [ ^self ].  self updateColor-=JUAMPI=-findDeeplyA: aClass  ^(self allMorphs copyWithout: self) detect: [:p |  p isKindOf: aClass ] ifNone: [ nil ]-=JUAMPI=-setStrategy  table beCellSelection-=JUAMPI=-indentingItemClass  ^LazyMorphTreeNodeMorph-=JUAMPI=-left  ^textMorph owner left-=JUAMPI=-color: aColor  super color: aColor beOpaque.  self fillStyle: self defaultFillStyle-=JUAMPI=-drawOn: aCanvas  | time |  time := Time millisecondClockValue.  self drawMeOn: aCanvas.  drawTime := Time millisecondClockValue - time.  drawTime < 0 ifTrue: [ drawTime := nil ]-=JUAMPI=-hasFocus  ^hasFocus ifNil: [ false ]-=JUAMPI=-itemStringGetter: aValuable  self columns first itemStringGetter: aValuable-=JUAMPI=-fillStyleToUse  ^self isSelected ifTrue: [ self selectedFillStyle ] ifFalse: [ self normalFillStyle ]-=JUAMPI=-openOn: aClass  rootClass := aClass.  (self defaultTreeMorph buildContents embeddedInMorphicWindowLabeled: 'test') openInWorld-=JUAMPI=-openDialogOn: aClass  rootClass := aClass.  ^self openDialogWindowIn: self currentWorld title: 'All Object subclasses'-=JUAMPI=-deselect  editor ifNotNil: [ editor deselect ]-=JUAMPI=-allEnabledSiblingItems  ^self allSiblingItems select: [:item |  item isEnabled ]-=JUAMPI=-setSelectedSilently: aBoolean  selected := aBoolean.  self complexContents selected: aBoolean-=JUAMPI=-beUnsticky  extension ifNotNil: [ extension sticky: false ]-=JUAMPI=-announcer  WorldAnnouncer ifNil: [ WorldAnnouncer := Announcer new ].  ^WorldAnnouncer-=JUAMPI=-needSpaceForActions  | tab |  tab := self selectedTab.  tab ifNil: [ ^false ].  ^self selectedTab hasMenu or: [ self selectedTab hasActions ]-=JUAMPI=-isSelfEvaluating  ^false-=JUAMPI=-indentBy: aNumber  indentation := aNumber + self cellInset-=JUAMPI=-acceptDroppingMorph: aMorph event: evt  | item dropTarget |  dropItemSelector ifNil: [ model acceptDroppingMorph: aMorph event: evt inMorph: self ] ifNotNil: [ item := aMorph passenger.        dropTarget := (self itemFromPoint: evt position) withoutListWrapper.        model perform: dropItemSelector with: item with: dropTarget ].  evt hand releaseMouseFocus: self.  Cursor normal show-=JUAMPI=-halo  ^self valueOfProperty: #halo-=JUAMPI=-playMaximizeSound  self theme windowMaximizeSound play-=JUAMPI=-drawOn: aCanvas  super drawOn: aCanvas.  self drawGridOn: aCanvas.  self drawBackgroundSketchOn: aCanvas-=JUAMPI=-openItemPath: anArray  | found |  anArray isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ (each complexContents withoutListWrapper = anArray first or: [ anArray first isNil ]) ifTrue: [ found := each ] ] ].  found ifNotNil: [ found isExpanded ifFalse: [ found toggleExpandedState ].        found changed.        anArray size = 1 ifTrue: [ ^container listManager setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild openItemPath: anArray allButFirst ] ].  ^self-=JUAMPI=-minExtent  ^self theme tabSelectorMorphMinExtentFor: self-=JUAMPI=-transferHalo: event from: formerHaloOwner  | localEvt w target |  self flag: #workAround.  (formerHaloOwner == self and: [ self isRenderer and: [ self wantsHaloFromClick not ] ]) ifTrue: [ event shiftPressed ifTrue: [ target := owner.              localEvt := event transformedBy: (self transformedFrom: owner) ] ifFalse: [ target := self renderedMorph.              localEvt := event transformedBy: (target transformedFrom: self) ].        ^target transferHalo: localEvt from: target ].  (self isWorldMorph and: [ owner isNil ]) ifFalse: [ (self wantsHaloFromClick and: [ formerHaloOwner ~~ self ]) ifTrue: [ ^self addHalo: event from: formerHaloOwner ] ].  event shiftPressed ifTrue: [ owner ifNotNil: [ ^owner transferHalo: event from: formerHaloOwner ].        formerHaloOwner removeHalo.        ^self processEvent: event copy resetHandlerFields ].  self submorphsDo: [:m |  localEvt := event transformedBy: (m transformedFrom: self).        (m fullContainsPoint: localEvt position) ifTrue: [ ^m transferHalo: event from: formerHaloOwner ] ].  formerHaloOwner removeHalo.  (w := self world) ifNil: [ ^self ].  localEvt := event transformedBy: (self transformedFrom: w) inverseTransformation.  ^w processEvent: localEvt resetHandlerFields-=JUAMPI=-invokeModal: allowKeyboardControl  ^self invokeModalAt: ActiveHand position in: self currentWorld allowKeyboard: allowKeyboardControl-=JUAMPI=-setSelectionIndex: idx  | theMorph index |  idx ifNil: [ ^self ].  index := idx min: scroller submorphs size max: 0.  theMorph := index = 0 ifTrue: [ nil ] ifFalse: [ scroller submorphs at: index ].  self setSelectedMorph: theMorph-=JUAMPI=-inToggleArea: aPoint  ^self sensitiveToggleRectangle containsPoint: aPoint-=JUAMPI=-onImage  ^image-=JUAMPI=-initialize  isExpanded := false.  recentlyChanged := false-=JUAMPI=-textColor: aColor  textColor := aColor-=JUAMPI=-fontNumber  ^fontNumber-=JUAMPI=-deleteBalloonTarget: aMorph  self handsDo: [:h |  h deleteBalloonTarget: aMorph ]-=JUAMPI=-expandAll: aMorph  | subs |  self expandAllSilently: aMorph.  aMorph updateChildrenRecursively.  subs := self scroller submorphs.  1 to: subs size do: [:pos |  (subs at: pos) index: pos ].  self innerWidgetChanged-=JUAMPI=-initializeClass: aClass  self initialize.  self elements: ((aClass selectors sorted: [:a :b |  a < b ]) collect: [:each |  FTExampleMethodModel method: aClass >> each ])-=JUAMPI=-nextMorphAcrossInWindow  ^self submorphAfter ifNil: [ (self owner ifNil: [ ^self ]) nextMorphAcrossInWindow ]-=JUAMPI=-privateMoveBy: delta  | fill |  super privateMoveBy: delta.  fill := self barFillStyle.  fill isOrientedFill ifTrue: [ fill origin: fill origin + delta ]-=JUAMPI=-gradientRamp  ^gradientRamp ifNil: [ {(0.0 -> originalColor muchLighter) .         (1.0 -> originalColor twiceDarker)} ]-=JUAMPI=-lastSelectedNode  ^self lastSelectedNodePath ifNotNil: [:path |  path ifEmpty: [ nil ] ifNotEmpty: [:p |  path last ] ]-=JUAMPI=-resetHScrollRange  hScrollRangeCache := nil.  self deriveHScrollRange-=JUAMPI=-includesHandle: aMorph  handles ifNil: [ ^false ].  ^handles includes: aMorph-=JUAMPI=-noteNewOwner: aMorph  -=JUAMPI=-delete  self removeHalo.  self activeHand     releaseKeyboardFocus: self;     releaseMouseFocus: self.  owner ifNotNil: [ self privateDelete.        self announceDeleted ]-=JUAMPI=-spSetModal: aSystemWindow  | area mySysWin keyboardFocus |  keyboardFocus := self activeHand keyboardFocus.  mySysWin := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  mySysWin ifNil: [ mySysWin := self ].  mySysWin modalLockTo: aSystemWindow.  area := RealEstateAgent maximumUsableArea.  aSystemWindow extent: aSystemWindow initialExtent.  aSystemWindow position = (0 @ 0) ifTrue: [ aSystemWindow position: self activeHand position - (aSystemWindow extent // 2) ].  aSystemWindow bounds: (aSystemWindow bounds translatedToBeWithin: area).  [ | aWidget |  aWidget := aSystemWindow.  [ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] ensure: [ mySysWin modalUnlockFrom: aSystemWindow.        self activeHand newKeyboardFocus: keyboardFocus ].  ^aSystemWindow-=JUAMPI=-label  ^label-=JUAMPI=-drawOn: aCanvas  super drawOn: aCanvas.  topSeparator ifTrue: [ aCanvas line: bounds topLeft to: bounds topRight color: self seperatorColor ]-=JUAMPI=-computeCellSizes: aMorph in: newBounds horizontal: aBool  | cells block minSize maxSize maxCell |  cells := (Array new: aMorph submorphCount) writeStream.  minSize := properties minCellSize asPoint.  maxSize := properties maxCellSize asPoint.  aBool ifTrue: [ minSize := minSize transposed.        maxSize := maxSize transposed ].  maxCell := 0 @ 0.  block := [:m |  | cell size |  m disableTableLayout ifFalse: [ size := m minExtent asIntegerPoint.        cell := LayoutCell new target: m.        aBool ifTrue: [ cell hSpaceFill: m hResizing == #spaceFill.              cell vSpaceFill: m vResizing == #spaceFill ] ifFalse: [ cell hSpaceFill: m vResizing == #spaceFill.              cell vSpaceFill: m hResizing == #spaceFill.              size := size transposed ].        size := (size min: maxSize) max: minSize.        cell cellSize: size.        maxCell := maxCell max: size.        cells nextPut: cell ] ].  properties reverseTableCells ifTrue: [ aMorph submorphsReverseDo: block ] ifFalse: [ aMorph submorphsDo: block ].  ^maxCell -> cells contents-=JUAMPI=-setContainer: newContainer  self changed.  container := newContainer.  self releaseParagraph-=JUAMPI=-wantsColumnBreaks  ^wantsColumnBreaks-=JUAMPI=-addLine  submorphs isEmpty ifTrue: [ ^self ].  (self lastSubmorph isKindOf: DockingBarMenuLineMorph) ifFalse: [ self addMorphBack: DockingBarMenuLineMorph new ]-=JUAMPI=-transformedBy: aMorphicTransform  ^self shallowCopy transformBy: aMorphicTransform-=JUAMPI=-enabled  ^enabled ifNil: [ enabled := true ]-=JUAMPI=-terminateUIProcess  UIProcess     suspend;     terminate.  UIProcess := nil-=JUAMPI=-checkSplitters  (self submorphsSatisfying: [:e |  e isKindOf: ProportionalSplitterMorph ]) do: [:splitter |  self checkMorphsLeftOrTopFrom: splitter.        self checkMorphsRightOrBottomFrom: splitter ]-=JUAMPI=-setSelectionListSelector: aSelector  setSelectionListSelector := aSelector-=JUAMPI=-startDrag: event  | passengers transferMorph |  event hand hasSubmorphs ifTrue: [ ^self ].  self dragEnabled ifFalse: [ ^self ].  event hand anyButtonPressed ifFalse: [ ^self ].  self hasSelection ifFalse: [ ^self ].  passengers := self selectedIndexes collect: [:each |  self dataSource passengerAt: each ].  transferMorph := self dataSource transferFor: passengers from: self.  transferMorph align: transferMorph draggedMorph topLeft with: event position.  transferMorph dragTransferType: self dataSource dragTransferType.  event hand grabMorph: transferMorph-=JUAMPI=-expandAllFromNode: aNode  self requestView: (MorphTreeChangeRequest expandAllFromNode: aNode)-=JUAMPI=-initializeContainer  container := self defaultContainer.  self addMorph: container-=JUAMPI=-leftFraction: aNumber  leftFraction := aNumber-=JUAMPI=-initialDataSource: aDataSource  initialDataSource := aDataSource-=JUAMPI=-isFirstItem  ^owner submorphs first == self-=JUAMPI=-selectMatch: aString  | firstMatch |  self items do: [:item |  | match |        match := aString isEmpty or: [ item contents asString asLowercase includesSubstring: aString ].        item isEnabled: match.        (match and: [ firstMatch isNil ]) ifTrue: [ firstMatch := item ] ].  ^firstMatch-=JUAMPI=-result  ^result-=JUAMPI=-newImageFor: aModel get: getSel help: helpText  ^self theme newImageIn: self for: aModel get: getSel help: helpText-=JUAMPI=-pressed: anIndex  self model pressed: anIndex-=JUAMPI=-showWidget  self initializeMorph.  table     addMorph: field;     resizeAllSubviews-=JUAMPI=-newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText-=JUAMPI=-deactivate  InputEventSensor default shutDown.  Display shutDown.  InputEventFetcher default shutDown-=JUAMPI=-testLeftTopAligned  | lf rectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightFraction: 0 offset: 60;     bottomFraction: 0 offset: 25;     yourself.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 110 @ 35) equals: rectangle-=JUAMPI=-removeAlarm: aSelector for: aTarget  worldState removeAlarm: aSelector for: aTarget-=JUAMPI=-deselectTimeOut: evt  owner selectedItem == self ifTrue: [ evt hand releaseMouseFocus: owner.        owner selectItem: nil event: evt ]-=JUAMPI=-showIconTreshold  ^(closeIcon visible ifTrue: [ 54 ] ifFalse: [ 40 ]) * self displayScaleFactor-=JUAMPI=-chooseDirectory: title  ^self chooseDirectory: title path: nil-=JUAMPI=-mouseDown: anEvent  self enabled ifTrue: [ self           scrollPoint: anEvent;           computeSlider ].  super mouseDown: anEvent.  self enabled ifFalse: [ ^self ].  anEvent hand newMouseFocus: slider event: anEvent.  slider     mouseEnter: anEvent copy;     mouseDown: anEvent copy-=JUAMPI=-hasSubMenu: aMenuMorph  ^submorphs anySatisfy: [:m |  m isMenuItemMorph and: (m hasSubMenu: aMenuMorph) ]-=JUAMPI=-containsPoint: aPoint  | w |  ^(super containsPoint: aPoint) and: [ w := SystemWindow borderWidth.        ((self bounds translateBy: w @ w negated) containsPoint: aPoint) not ]-=JUAMPI=-updateContents  target ifNotNil: [ contents := target perform: nameSelector ]-=JUAMPI=-characterBlockForIndex: index  | line |  line := lines at: (self lineIndexForCharacter: index).  ^(CharacterBlockScanner new text: text textStyle: textStyle) characterBlockAtPoint: nil index: ((index max: line first) min: text size + 1) in: line-=JUAMPI=-type: aType extension: anExtension action: anAction  action := anAction.  type := aType.  extension := anExtension-=JUAMPI=-layoutProperties: newProperties  self layoutProperties == newProperties ifTrue: [ ^self ].  self assureExtension layoutProperties: newProperties-=JUAMPI=-focusChanged  | rects fm |  fm := self focusIndicatorMorph.  fm fillStyle isTransparent ifTrue: [ fm borderWidth > 0 ifTrue: [ rects := fm bounds areasOutside: (fm bounds insetBy: fm borderWidth).              rects do: [:r |  self invalidRect: r ] ] ] ifFalse: [ self invalidRect: fm bounds ]-=JUAMPI=-isFirstColumn  ^container columns first = self-=JUAMPI=-initialize  super initialize.  vertices := Array with: 5 @ 0 with: 20 @ 10 with: 0 @ 20.  closed := true.  smoothCurve := false.  arrows := #none.  self computeBounds.  self beSmoothCurve.  self diamondOval-=JUAMPI=-dropEnabled  ^(self valueOfProperty: #dropEnabled) == true-=JUAMPI=-onImageSelector: anObject  onImageSelector := anObject-=JUAMPI=-defersHaloOnClickTo: aSubMorph  ^true-=JUAMPI=-moveSelectionDown: anInteger event: anEvent  | allEnabledSiblingItems index |  allEnabledSiblingItems := self allEnabledSiblingItems.  index := (allEnabledSiblingItems indexOf: selectedItem ifAbsent: [ 0 + (anInteger negative ifTrue: [ 1 ] ifFalse: [ 0 ]) ]) + anInteger.  allEnabledSiblingItems do: [:unused |  | m |        m := allEnabledSiblingItems atWrap: index.        (m isMenuItemMorph and: [ m isEnabled ]) ifTrue: [ m owner = self owner ifFalse: [ anEvent hand newKeyboardFocus: m owner ].              ^m owner selectItem: m event: anEvent ].        index := index + anInteger sign ].  ^self selectItem: nil event: anEvent-=JUAMPI=-font  ^self listMorph font-=JUAMPI=-testSelectLast  self subclassResponsibility-=JUAMPI=-leftButtonEnabled  ^self wrapScrolling or: [ self visibleTabRange first > 1 ]-=JUAMPI=-getRawLabel  | contentsFit |  contentsFit := label shallowCopy fitContents.  contentsFit extent: (label extent x min: contentsFit extent x) @ contentsFit extent y.  ^contentsFit-=JUAMPI=-doDebug: evt with: menuHandle  | menu |  self world displayWorld.  evt shiftPressed ifTrue: [ self delete.        ^innerTarget inspectInMorphic: evt ].  menu := innerTarget buildDebugMenu: evt hand.  menu     buildTitle: [:menuTitle |  menuTitle           title: (innerTarget externalName asString truncateWithElipsisTo: 40);           withCloseBox;           withPinBox ];     popUpEvent: evt in: self world-=JUAMPI=-moveSelectionDown: direction event: evt  | index |  index := (submorphs indexOf: selectedItem ifAbsent: [ 1 - direction ]) + direction.  submorphs do: [:unused |  | m |        m := submorphs atWrap: index.        (m isMenuItemMorph and: [ m isEnabled ]) ifTrue: [ ^self selectItem: m event: evt ].        index := index + direction sign ].  ^self selectItem: nil event: evt-=JUAMPI=-mouseLeaveDragging: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseLeaveDragging from: sourceMorph-=JUAMPI=-bestSegments  ^self honeIn: self calcEnoughSegments-=JUAMPI=-findSubmorphBinary: aBlock  ^submorphs findBinary: aBlock do: [:found |  found ] ifNone: [:a :b |   ]-=JUAMPI=-hasExtraSelection  ^extraSelectionBlocks isEmptyOrNil not-=JUAMPI=-internalSpaces: spacesInteger paddingWidth: padWidthInteger  internalSpaces := spacesInteger.  paddingWidth := padWidthInteger-=JUAMPI=-extent: p  p x > p y ifTrue: [ super extent: (p max: (42 @ 8) scaledByDisplayScaleFactor) ] ifFalse: [ super extent: (p max: (8 @ 42) scaledByDisplayScaleFactor) ]-=JUAMPI=-abort: aStringOrText  ^self abort: aStringOrText title: 'Error' translated-=JUAMPI=-prepareForRotating  ^self addFlexShell-=JUAMPI=-wantsDropSelector: aSelector  wantsDropSelector := aSelector-=JUAMPI=-model  ^self complexContents-=JUAMPI=-computeBounds  | oldBounds delta excludeHandles |  vertices ifNil: [ ^self ].  self changed.  oldBounds := bounds.  self releaseCachedState.  bounds := self curveBounds expanded.  self arrowForms do: [:f |  bounds := bounds merge: (f offset extent: f extent) ].  handles ifNotNil: [ self updateHandles ].  (oldBounds notNil and: [ (delta := bounds origin - oldBounds origin) ~= (0 @ 0) ]) ifTrue: [ excludeHandles := IdentitySet new.        handles ifNotNil: [ excludeHandles addAll: handles ].        self submorphsDo: [:each |  (excludeHandles includes: each) ifFalse: [ each position: each position + delta ] ] ].  self layoutChanged.  self changed-=JUAMPI=-hash  ^self morph hash bitXor: (self state hash bitXor: (self icon hash bitXor: self label hash))-=JUAMPI=-newExpander: aString  ^self theme newExpanderIn: self label: aString forAll: #()-=JUAMPI=-rotationDegrees: degrees  self adjustAfter: [ self angle: degrees degreesToRadians negated ]-=JUAMPI=-childrenItems  ^Array new-=JUAMPI=-addMorph: aMorph frame: rectangle  ^self addMorph: aMorph fullFrame: rectangle-=JUAMPI=-deselectAll  | selHolder |  self allNodeMorphs isEmpty ifTrue: [ ^self ].  self emptySelection.  self selectionUpdateFromViewWhile: [ selHolder := self newSelectionHolderWithNodePath: nil.        self listModel selection: selHolder ]-=JUAMPI=-newMenuFor: aModel  ^self theme newMenuIn: self for: aModel-=JUAMPI=-setSelectedMorph: aMorph  selectedWrapper := aMorph complexContents.  self selection: selectedWrapper.  setSelectionSelector ifNotNil: [ model perform: setSelectionSelector with: (selectedWrapper ifNotNil: [ selectedWrapper item ]) ]-=JUAMPI=-drawArrowOn: aCanvas at: endPoint from: priorPoint  | pts spec wingBase |  pts := self arrowBoundsAt: endPoint from: priorPoint.  wingBase := pts size = 4 ifTrue: [ pts third ] ifFalse: [ (pts copyFrom: 2 to: 3) average ].  spec := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  spec x sign = spec y sign ifTrue: [ aCanvas drawPolygon: pts fillStyle: borderColor ] ifFalse: [ aCanvas drawPolygon: pts fillStyle: Color transparent borderWidth: (borderWidth + 1) // 2 borderColor: borderColor ].  ^wingBase-=JUAMPI=-adjacentTo  ^{(self bounds topRight + (5 @ 0)) .   (self bounds topLeft + (2 @ 0))}-=JUAMPI=-testIsBeforeColumn  self subclassResponsibility-=JUAMPI=-replaceFrom: start to: stop with: aText displaying: displayBoolean  text replaceFrom: start to: stop with: aText.  self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop - start + 1)-=JUAMPI=-initForKeystrokes  canMove := true.  lastKeystrokeTime := 0.  lastKeystrokes := ''-=JUAMPI=-defaultTarget: anObject  defaultTarget := anObject-=JUAMPI=-secondName: aString  self item secondName: aString.  self changed: #secondName-=JUAMPI=-pageSizeToString  ^self pageSize asString-=JUAMPI=-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-=JUAMPI=-debugPrint  ^(WriteStream on: (String new: 10))     print: self class;     nextPutAll: ' (';     print: self date;     nextPutAll: ' - ';     print: self bounds;     nextPut: $);     contents-=JUAMPI=-handle: dropStream in: pasteUp dropEvent: anEvent  ^action cull: dropStream cull: pasteUp cull: anEvent-=JUAMPI=-gridModulus  ^self gridSpec extent-=JUAMPI=-listMorphClass  ^MulticolumnLazyListMorph-=JUAMPI=-commentText  ^(self theme newTextIn: self currentWorld text: self item comment)     unlock;     wrapFlag: true;     yourself-=JUAMPI=-vScrollBarMenuButtonPressed: event  ^self scrollBarMenuButtonPressed: event-=JUAMPI=-handlesMouseOver: evt  ^false-=JUAMPI=-isSelected  self model ifNil: [ ^false ].  ^self model perform: (self getStateSelector ifNil: [ ^false ])-=JUAMPI=-taskbarThumbnailExtent  ^self isMinimized ifTrue: [ self fullFrame extent min: self defaultTaskbarThumbnailExtent ] ifFalse: [ super taskbarThumbnailExtent ]-=JUAMPI=-extent: aPoint  | size oldRotationCenter |  oldRotationCenter := self rotationCenter.  size := aPoint x min: aPoint y.  super extent: size @ size.  self rotationCenter: oldRotationCenter-=JUAMPI=-startPoint  ^startPoint-=JUAMPI=-prepareForScaling  ^self-=JUAMPI=-releaseCachedState  super releaseCachedState.  filledForm := nil.  arrowForms := nil.  borderForm := nil.  curveState := nil.  (self hasProperty: #flex) ifTrue: [ self removeProperty: #flex ]-=JUAMPI=-indentationOfLineIndex: lineIndex ifBlank: aBlock  | arrayIndex first last crlf |  crlf := CharacterSet crlf.  arrayIndex := lineIndex.  [ first := (lines at: arrayIndex) first.  first > 1 and: [ crlf includes: (text string at: first - 1) ] ] whileTrue: [ arrayIndex := arrayIndex - 1 ].  last := (lines at: arrayIndex) last.  ^(text string copyFrom: first to: last) indentationIfBlank: aBlock-=JUAMPI=-chooseDirectory: title  ^self chooseDirectory: title path: nil-=JUAMPI=-selectedLocation  | b c x y |  b := self innerBounds.  c := self selectedColor.  x := c saturation * (b width - 1).  y := (1 - c brightness) * (b height - 1).  ^x truncated @ y truncated + b topLeft-=JUAMPI=-grabMorph: aMorph from: formerOwner  | grabbed offset targetPoint grabTransform fullTransform |  self releaseMouseFocus.  grabbed := aMorph.  aMorph keepsTransform ifTrue: [ grabTransform := fullTransform := IdentityTransform new ] ifFalse: [ grabTransform := formerOwner ifNil: [ IdentityTransform new ] ifNotNil: [ formerOwner grabTransform ].        fullTransform := formerOwner ifNil: [ IdentityTransform new ] ifNotNil: [ formerOwner transformFrom: owner ] ].  targetPoint := fullTransform globalPointToLocal: self position.  offset := targetPoint - (grabTransform globalPointToLocal: self position).  grabbed := grabbed transformedBy: grabTransform.  grabbed == aMorph ifFalse: [ grabbed setProperty: #addedFlexAtGrab toValue: true ].  grabbed position: grabbed position - offset asIntegerPoint.  targetOffset := grabbed position - self position.  self addMorphBack: grabbed.  grabbed justGrabbedFrom: formerOwner-=JUAMPI=-firstName  ^firstName-=JUAMPI=-drawBackgroundForRow: row on: aCanvas color: aColor  | frame |  frame := self selectionFrameForRow: row.  aCanvas fillRectangle: frame color: aColor-=JUAMPI=-newPosition: anObject  newPosition := anObject-=JUAMPI=-setLayoutSizingFor: aSymbol  (aSymbol = #left or: [ aSymbol = #right ]) ifTrue: [ self           hResizing: #rigid;           vResizing: #spaceFill ].  (aSymbol = #top or: [ aSymbol = #bottom ]) ifTrue: [ self           hResizing: #spaceFill;           vResizing: #rigid ]-=JUAMPI=-getEnabledSelector  ^getEnabledSelector-=JUAMPI=-addScaleHandle: haloSpec  target shouldFlex ifTrue: [ (self addHandle: haloSpec on: #mouseDown send: #startScale:with: to: self) on: #mouseMove send: #doScale:with: to: self ]-=JUAMPI=-initializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigation-=JUAMPI=-keyString  ^String streamContents: [:s |  self printKeyStringOn: s ]-=JUAMPI=-drawKeyTextOnAthenCanvas: aCanvas  self keyText ifNil: [ ^self ].  (ToggleMenuItemShortcut owner: self keyText: self keyText) drawOnAthensCanvas: aCanvas-=JUAMPI=-hasDropShadowString  ^self hasDropShadow -> 'show shadow' translated-=JUAMPI=-playCloseSound  self theme windowCloseSound play-=JUAMPI=-monthNameFont  | font boldItalic |  font := LogicalFont familyName: 'Bitmap DejaVu Sans' pointSize: 12.  boldItalic := TextEmphasis italic emphasisCode | TextEmphasis bold emphasisCode.  ^font emphasis: boldItalic-=JUAMPI=-indicateModalChild  (self isMinimized and: [ self isTaskbarPresent ]) ifTrue: [ self worldTaskbar ifNotNil: [:tb |  tb indicateModalChildForMorph: self ] ] ifFalse: [ self flash ]-=JUAMPI=-withAllOwners  ^Array streamContents: [:strm |  self withAllOwnersDo: [:m |  strm nextPut: m ] ]-=JUAMPI=-expandNodePath: aNodePath  self requestView: (MorphTreeChangeRequest expandNodePath: aNodePath)-=JUAMPI=-submorphsSatisfying: aBlock  ^submorphs select: [:m |  (aBlock value: m) == true ]-=JUAMPI=-dragVertex: ix event: evt fromHandle: handle  | p |  p := evt cursorPoint.  handle position: p - (handle extent // 2).  self verticesAt: ix put: p-=JUAMPI=-firstChild  ^firstChild-=JUAMPI=-keyStroke: evt  | view |  editView keyStroke: evt.  (editView scrollByKeyboard: evt) ifTrue: [ ^self ].  (acceptOnCR and: [ evt keyCharacter = Character cr ]) ifFalse: [ (editView navigationKey: evt) ifTrue: [ ^self ] ].  self editor model: editView model.  view := editView.  (acceptOnCR and: [ evt keyCharacter = Character cr ]) ifTrue: [ ^self editor accept ].  super keyStroke: evt.  view textChanged.  view scrollSelectionIntoView.  self doAutoAccept: evt.  view scrollSelectionIntoView-=JUAMPI=-nextSibling  ^nextSibling-=JUAMPI=-drawOn: aCanvas  | borderVertices vertices |  borderVertices := self buildBorderVertices.  vertices := self buildVerticesFrom: borderVertices.  aCanvas drawPolygon: vertices color: self backgroundColor borderWidth: 0 borderColor: Color transparent.  borderVertices overlappingPairsDo: [:start :end |  aCanvas line: start to: end width: 1 color: self borderColor ]-=JUAMPI=-textColor  ^self valueOfProperty: #textColor ifAbsent: [ self theme textColor ]-=JUAMPI=-lastVisibleRowIndex  ^self container lastVisibleRowIndex-=JUAMPI=-widthToDisplayInList: aList  ^self minExtent x-=JUAMPI=-mouseStillDown: evt  self eventHandler ifNotNil: [ self eventHandler mouseStillDown: evt fromMorph: self ]-=JUAMPI=-eventQueue  ^Sensor-=JUAMPI=-container  ^container-=JUAMPI=-privateFullMoveBy: delta  | deltaSlipped griddingMorph |  selectedItems isEmpty ifTrue: [ ^super privateFullMoveBy: delta ].  griddingMorph := self pasteUpMorph.  griddingMorph ifNil: [ ^super privateFullMoveBy: delta ].  deltaSlipped := delta + slippage.  slippage := 0.  super privateFullMoveBy: deltaSlipped.  selectedItems do: [:m |  m position: m position + deltaSlipped ]-=JUAMPI=-toggleRowIndex: index  self deprecated: 'Use #toggleIndex: instead.' transformWith: '`@receiver toggleRowIndex: `@statements' -> '`@receiver toggleIndex: `@statements'.  self toggleIndex: index-=JUAMPI=-buildMetaMenu: evt  | menu |  menu := UIManager default newMenuIn: self for: self.  menu add: 'grab' selector: #grabMorph:.  menu add: 'copy to paste buffer' selector: #copyToPasteBuffer:.  self maybeAddCollapseItemTo: menu.  menu add: 'delete' selector: #dismissMorph:.  menu addLine.  menu add: 'copy text' selector: #clipText.  menu addLine.  menu add: 'go behind' selector: #goBehind.  menu add: 'add halo' selector: #addHalo:.  menu add: 'duplicate' selector: #maybeDuplicateMorph:.  self addEmbeddingMenuItemsTo: menu hand: evt hand.  menu add: 'resize' selector: #resizeMorph:.  self addFillStyleMenuItems: menu hand: evt hand.  self addDropShadowMenuItems: menu hand: evt hand.  self addLayoutMenuItems: menu hand: evt hand.  menu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().  menu addLine.  menu add: 'inspect' selector: #inspectAt:event: argument: evt position.  menu add: 'explore' selector: #inspect.  menu lastItem icon: (self iconNamed: #smallInspectItIcon).  menu addLine.  menu add: 'show actions' selector: #showActions.  menu addLine.  self addDebuggingItemsTo: menu hand: evt hand.  self addCustomMenuItems: menu hand: evt hand.  ^menu-=JUAMPI=-withoutListWrapper  ^complexContents withoutListWrapper-=JUAMPI=-wantsDropSelector: aSymbol  wantsDropSelector := aSymbol-=JUAMPI=-shouldDraw  ^self fillStyle isTransparent not-=JUAMPI=-justified  self changeAlignment: #justified-=JUAMPI=-elementWrapped: object  ^self wrapSelector ifNotNil: [:selector |  self model perform: selector with: object ] ifNil: [ object ]-=JUAMPI=-testUpdateTaskBarShouldContainsTaskbarTasks  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: (taskbar tasks first isKindOf: TaskbarTask)-=JUAMPI=-hasProperty: aSymbol  | property |  otherProperties ifNil: [ ^false ].  property := otherProperties at: aSymbol ifAbsent: [  ].  property ifNil: [ ^false ].  property == false ifTrue: [ ^false ].  ^true-=JUAMPI=-setTextStyle: aTextStyle  textStyle := aTextStyle.  self     releaseCachedState;     changed-=JUAMPI=-forwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirection-=JUAMPI=-newToolDockingBar  ^self theme newToolDockingBarIn: self-=JUAMPI=-setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) rounded-=JUAMPI=-positionSubmorphs  self submorphsDo: [:aMorph |  aMorph snapToEdgeIfAppropriate ]-=JUAMPI=-hasCollapseBox  ^collapseBox notNil-=JUAMPI=-newYesButton  ^self newYesButtonFor: self-=JUAMPI=-calculateExactVisibleRows  | rowIndex maxHeight height |  self table hasDataSource ifFalse: [ ^super calculateExactVisibleRows ].  rowIndex := self table showIndex max: 1.  height := 0.  maxHeight := self height.  headerRow ifNotNil: [ maxHeight := maxHeight - headerRow height ].  [ height < maxHeight and: [ rowIndex <= self table dataSource numberOfRows ] ] whileTrue: [ height := height + (self table dataSource rowHeight: rowIndex).        rowIndex := rowIndex + 1 ].  ^rowIndex - self table showIndex-=JUAMPI=-ghostText  ^'Search...'-=JUAMPI=-spawnBalloonFor: aMorph  aMorph showBalloon: aMorph balloonText hand: self-=JUAMPI=-wantsDirectionHandles  ^self valueOfProperty: #wantsDirectionHandles ifAbsent: [ false ]-=JUAMPI=-fitTargetBoundsInOwner: aRect  | ownerMinExt targetOwner |  targetOwner := self target owner ifNil: [ ^self ].  ownerMinExt := targetOwner minExtent.  ownerMinExt x > self target owner width ifTrue: [ self edgeName = #left ifTrue: [ self target bounds: ((aRect left + (ownerMinExt x - targetOwner width)) @ aRect top extent: (aRect width - (ownerMinExt x - targetOwner width)) @ aRect height) ] ifFalse: [ self target bounds: (aRect origin extent: (aRect width - (ownerMinExt x - targetOwner width)) @ aRect height) ] ].  ownerMinExt y > self target owner height ifTrue: [ self edgeName = #top ifTrue: [ self target bounds: (aRect left @ (aRect top + (ownerMinExt y - targetOwner height)) extent: aRect width @ (aRect height - (ownerMinExt y - targetOwner height))) ] ifFalse: [ self target bounds: (aRect origin extent: aRect width @ (aRect height - (ownerMinExt y - targetOwner height))) ] ]-=JUAMPI=-hasChildren  ^self children size ~= 0-=JUAMPI=-value  ^progressBar value-=JUAMPI=-translateBy: delta  position := position + delta.  startPoint := startPoint + delta-=JUAMPI=-showAbout  self theme longMessageIn: self text: self aboutText title: self aboutTitle-=JUAMPI=-colorForInsets  (color isColor and: [ color isTransparent and: [ owner notNil ] ]) ifTrue: [ ^owner colorForInsets ].  ^color colorForInsets-=JUAMPI=-clipSubmorphs: aBool  self invalidRect: self fullBounds.  aBool == self clipSubmorphs ifFalse: [ self assureExtension.        extension clipSubmorphs: aBool.        self invalidRect: self fullBounds ]-=JUAMPI=-getMenuSelector: aSymbol  getMenuSelector := aSymbol-=JUAMPI=-readyToBeDisplayed  -=JUAMPI=-isDeActivated  ^true-=JUAMPI=-allMorphsDo: aBlock  submorphs do: [:m |  m allMorphsDo: aBlock ].  aBlock value: self-=JUAMPI=-canDrawBorder: aBorderStyle  ^true-=JUAMPI=-sliderColor: aColor  | buttonColor |  super sliderColor: aColor.  self lastPaneColor: aColor.  buttonColor := self thumbColor.  upButton color: buttonColor.  downButton color: buttonColor.  slider color: buttonColor slightlyLighter.  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStyle.  (self theme scrollbarPagingAreaCornerStyleIn: self window) = #rounded ifTrue: [ self fillStyle: self normalButtonFillStyle ] ifFalse: [ self fillStyle: self normalFillStyle ].  self borderWidth: 0.  ^self adoptGradientColor: aColor-=JUAMPI=-putLabelItemsInLabelArea  labelArea ifNotNil: [ stripes ifNotNil: [ stripes do: [:stripe |  labelArea addMorph: stripe ] ].        closeBox ifNotNil: [ labelArea addMorph: closeBox ].        menuBox ifNotNil: [ labelArea addMorph: menuBox ].        collapseBox ifNotNil: [ labelArea addMorph: collapseBox ].        label ifNotNil: [ labelArea addMorph: label ] ]-=JUAMPI=-simulateKeyStroke: aCharacterOrShortcut  | shortcut |  shortcut := aCharacterOrShortcut asKeyCombination.  self handleEvent: (KeyboardEvent new setType: #keystroke buttons: shortcut modifier eventCode position: self position keyValue: shortcut key asciiValue charCode: shortcut key asciiValue hand: self activeHand stamp: DateAndTime now)-=JUAMPI=-intersects: aRectangle  ^self fullBoundsInWorld intersects: aRectangle-=JUAMPI=-newPreviewMorph  ^Morph new     color: Color transparent;     extent: self defaultPreviewExtent;     yourself-=JUAMPI=-mouseMoveOnMultiple: event  | oldIndex oldVal row |  canMove ifFalse: [ ^self ].  event position y < self top ifTrue: [ scrollBar scrollUp: 1.        row := self rowAtLocation: scroller topLeft + (1 @ 1) ] ifFalse: [ row := event position y > self bottom ifTrue: [ scrollBar scrollDown: 1.              self rowAtLocation: scroller bottomLeft + (1 @ -1) ] ifFalse: [ self rowAtLocation: event position ] ].  row = 0 ifTrue: [ ^super mouseDown: event ].  (self potentialDropItem notNil and: [ self dropEnabled ]) ifTrue: [ ^self ].  dragOnOrOff ifNil: [ dragOnOrOff := (self listSelectionAt: row) not ].  oldIndex := self getCurrentSelectionIndex.  oldIndex ~= 0 ifTrue: [ oldVal := self listSelectionAt: oldIndex ].  oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].  self listSelectionAt: row put: dragOnOrOff.  row changed-=JUAMPI=-drawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self drawLinesOn: aCanvas-=JUAMPI=-addPaneSplitters  self removePaneSplitters.  self addPaneVSplitters.  self addPaneHSplitters.  self linkSplittersToSplitters-=JUAMPI=-dropFiles: anEvent  | numFiles |  numFiles := anEvent contents.  1 to: numFiles do: [:i |  | aFileReference handler |        aFileReference := anEvent requestDropReference: i.        handler := ExternalDropHandler lookupExternalDropHandler: aFileReference.        handler ifNotNil: [ handler handle: aFileReference in: self dropEvent: anEvent ] ]-=JUAMPI=-bounds: aRectangle  | size |  size := aRectangle width min: aRectangle height.  super bounds: (Rectangle origin: aRectangle origin extent: size @ size)-=JUAMPI=-searchStrategy  ^searchStrategy ifNil: [ #default ]-=JUAMPI=-textEntry: aStringOrText title: aString entryText: defaultEntryText  ^self theme textEntryIn: self text: aStringOrText title: aString entryText: defaultEntryText-=JUAMPI=-is: anIndex afterColumn: aColumnIndex  ^anIndex second > aColumnIndex-=JUAMPI=-minWidth  ^self valueOfProperty: #minWidth ifAbsent: [ 2 ]-=JUAMPI=-controls  ^controls-=JUAMPI=-rowIndexToVerticalScrollBarValue: aNumber  | numberOfRows |  numberOfRows := self numberOfRows - self container calculateMinVisibleRows.  ^(numberOfRows = 0 or: [ aNumber <= 1 ]) ifTrue: [ 0.0 ] ifFalse: [ ((aNumber / numberOfRows) asFloat max: 0.0) min: 1.0 ]-=JUAMPI=-image: anImage  ^self image: anImage size: anImage extent-=JUAMPI=-allSubmorphNamesDo: nameBlock  ^self-=JUAMPI=-dragItemSelector  ^dragItemSelector-=JUAMPI=-pressedImageSelector  ^pressedImageSelector-=JUAMPI=-minCellSize  ^0-=JUAMPI=-vScrollbar  ^vScrollbar-=JUAMPI=-showsNever  ^self showState == #never-=JUAMPI=-index: anIndex  index := anIndex-=JUAMPI=-updateValue  self model ifNotNil: [ self getValueSelector ifNotNil: [ self sliderMorph ifNotNil: [:sm |  sm scaledValue: self value.                    self                       changed: #minEnabled;                       changed: #maxEnabled ] ] ]-=JUAMPI=-getEnabledSelector: aSymbol  getEnabledSelector := aSymbol.  self updateEnabled-=JUAMPI=-newRow: controls  ^self theme newRowIn: self for: controls-=JUAMPI=-handleUpdate: aMorphChangedAnnouncement  ^aMorphChangedAnnouncement deliverTo: self-=JUAMPI=-testIndexFromPosition  self assert: (strategy indexFromPosition: #(3 7)) equals: #(3 7)-=JUAMPI=-printOn: aStream  aStream nextPutAll: 'Node('.  self item printOn: aStream.  aStream nextPut: $)-=JUAMPI=-getListSizeSelector: aSymbol  getListSizeSelector := aSymbol-=JUAMPI=-icon  ^icon-=JUAMPI=-message: aStringOrText  ^self message: aStringOrText title: 'Information' translated-=JUAMPI=-tabs  ^tabs-=JUAMPI=-optimalExtent  ^(Paragraph new     compose: text style: textStyle copy from: 1 in: (0 @ 0 extent: 9999999 @ 9999999);     adjustRightX;     extent) + (self borderWidth * 2) + (2 @ 0)-=JUAMPI=-tabRemovedFromSelection: aTab  self setMultipleContents-=JUAMPI=-drawLineFrom: startPoint to: stopPoint on: aCanvas  | lineColor |  lineColor := (stopPoint truncated quadrantOf: startPoint truncated) > 2 ifTrue: [ self topLeftColor ] ifFalse: [ self bottomRightColor ].  aCanvas line: startPoint to: stopPoint width: (self width - self margin max: 0) color: lineColor-=JUAMPI=-beCellSelection  self selectionModeStrategy: (FTCellSelectionModeStrategy table: self)-=JUAMPI=-newScrollPaneFor: aMorph  ^self theme newScrollPaneIn: self for: aMorph-=JUAMPI=-currentNodelist  ^self nodeList copyFrom: self currentPageFirstIndex to: self currentPageLastIndex-=JUAMPI=-removeDependent: anObject  self announcer unsubscribe: anObject-=JUAMPI=-mouseOverAllowed  ^mouseOverAllowed ifNil: [ mouseOverAllowed := false ]-=JUAMPI=-unexpandAllChildOf: anItem  anItem children do: [:item |  item isExpanded ifTrue: [ self unexpandAllChildOf: item ].        item collapse ] displayingProgress: [:each |  'Rearanging ' , each name ]-=JUAMPI=-addCustomHaloMenuItems: aMenu hand: aHandMorph  self addCustomMenuItems: aMenu hand: aHandMorph-=JUAMPI=-passiveDisabledOverDownFillStyle: aFillStyle  self stateMap atPath: #(passive disabled over down) put: aFillStyle.  self changed-=JUAMPI=-handlesMouseOver: evt  self table ifNotNil: [:table |  ^table selectionModeStrategy allowsCellSelection ].  ^false-=JUAMPI=-captureEventsUntil: aBlock  | release |  release := false.  captureBlock := [:evt |  release := aBlock value: evt ].  [ [ self world doOneCycle.  release ] whileFalse ] ensure: [ captureBlock := nil ]-=JUAMPI=-table: anObject  table := anObject-=JUAMPI=-makeMeVisible  self world extent > (0 @ 0) ifFalse: [ ^self ].  ((self world bounds insetBy: (0 @ 0 corner: self labelHeight asPoint)) containsPoint: self position) ifTrue: [ ^self ].  self isCollapsed ifTrue: [ self position: (RealEstateAgent assignCollapsePointFor: self) ] ifFalse: [ self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent world: self world) topLeft ]-=JUAMPI=-allowsRowSelection  ^false-=JUAMPI=-offerWindowMenu  | aMenu |  aMenu := self buildWindowMenu.  aMenu     addLine;     add: 'Grab window...' target: self selector: #grabWindow.  aMenu lastItem icon: (self iconNamed: #smallWindowIcon).  self tabGroup page ifNotNil: [:page |  page model addModelItemsToWindowMenu: aMenu ].  aMenu popUpEvent: self currentEvent in: self world-=JUAMPI=-matchesTypes: types  (self type isNil or: [ types isNil ]) ifTrue: [ ^false ].  ^types anySatisfy: [:mimeType |  mimeType beginsWith: self type ]-=JUAMPI=-numberOfLines  ^lines size-=JUAMPI=-interactionState: aSymbol  -=JUAMPI=-collapseAll  self subclassResponsibility-=JUAMPI=-colorForSelection: primarySelection  ^primarySelection ifTrue: [ self selectionColor ] ifFalse: [ self secondarySelectionColor ]-=JUAMPI=-minimumSelection  ^1-=JUAMPI=-stayUp  ^false-=JUAMPI=-preferredButtonCornerStyle  ^#square-=JUAMPI=-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self hScrollbar adoptPaneColor: paneColor.  self vScrollbar adoptPaneColor: paneColor-=JUAMPI=-moveShowIndexTo: arg  | index oldIndex |  index := self selectionModeStrategy rowIndexFrom: arg.  oldIndex := showIndex.  self basicMoveShowIndexTo: index.  self verticalScrollBar value: (self rowIndexToVerticalScrollBarValue: index).  self refresh.  self announceScrollChangedFrom: oldIndex to: index-=JUAMPI=-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-=JUAMPI=-= other  ^other class == self class and: [ other anchoredMorph == anchoredMorph ]-=JUAMPI=-menu  | menu |  menu := UIManager default newMenuIn: self currentWorld for: self.  menu buildTitle: [:menuTitle |  menuTitle onlyCloseAndPinable ].  menu add: 'Why you see this menu' target: self selector: #fallbackMenuExplanations.  menu add: 'Debug' target: self selector: #debug.  menu addLine.  client fallbackMenuOn: menu.  ^menu-=JUAMPI=-expandAll  rootItem expandAll.  self tableRefresh-=JUAMPI=-centeredAlert: aStringOrText title: aString configure: aBlock  ^self theme centeredAlertIn: self text: aStringOrText title: aString configure: aBlock-=JUAMPI=-newStateForSelected: aBoolean  ^TabEnabled tab: self tab-=JUAMPI=-useGradientFill  | fill color1 color2 |  self fillStyle isGradientFill ifTrue: [ ^self ].  color1 := self color asColor.  color2 := color1 negated.  fill := GradientFillStyle ramp: {(0.0 -> color1) .         (1.0 -> color2)}.  fill origin: self topLeft.  fill direction: 0 @ self bounds extent y.  fill normal: self bounds extent x @ 0.  fill radial: false.  self fillStyle: fill-=JUAMPI=-optionalOperations  pattern isEmptyOrNil ifTrue: [ self unexpandAllChildOf: dataSource rootItem.        ^#() ] ifFalse: [ ^nil ]-=JUAMPI=-imageMorph: anObject  imageMorph := anObject-=JUAMPI=-initialize  super initialize.  self initForKeystrokes.  self on: #mouseMove send: #mouseStillDown:onItem: to: self-=JUAMPI=-adjustAfter: changeBlock  changeBlock value.  self chooseSmoothing.  self layoutChanged.  owner ifNotNil: [ owner invalidRect: bounds ]-=JUAMPI=-userString  ^text string-=JUAMPI=-newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpText-=JUAMPI=-computeAltFramedColors  | base light dark w hw colorArray param |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  w = 1 ifTrue: [ ^{(base mixed: 0.5 with: light) .         (base mixed: 0.5 with: dark)} ].  colorArray := Array new: w.  hw := w // 2.  0 to: hw - 1 do: [:i |  param := 0.5 + (i asFloat / hw * 0.5).        colorArray at: i + 1 put: (base mixed: param with: dark).        colorArray at: w - i put: (base mixed: param with: light) ].  w odd ifTrue: [ colorArray at: hw + 1 put: base ].  ^colorArray , colorArray-=JUAMPI=-filterClass: aFTFilterClass  filterClass := aFTFilterClass-=JUAMPI=-doubleClickTimeout  dblClickTimeoutSelector ifNotNil: [ clickClient perform: dblClickTimeoutSelector with: firstClickDown ]-=JUAMPI=-first: firstCharBlock last: lastCharBlock color: aColor  first := firstCharBlock.  last := lastCharBlock.  color := aColor-=JUAMPI=-wrapCentering  ^#topLeft-=JUAMPI=-initializeColumsFrom: aModel  self columns: aModel columns-=JUAMPI=-chooseColor  ^self chooseColor: Color black-=JUAMPI=-wasHandled  ^false-=JUAMPI=-addDependent: aDependent  dependents := #().  super addDependent: aDependent-=JUAMPI=-hsvaMorph: anObject  hsvaMorph := anObject-=JUAMPI=-roundedCorners  self isAdheringToTop ifTrue: [ ^#(2 3) ].  self isAdheringToBottom ifTrue: [ ^#(1 4) ].  self isAdheringToLeft ifTrue: [ ^#(3 4) ].  self isAdheringToRight ifTrue: [ ^#(1 2) ].  ^#(1 2 3 4)-=JUAMPI=-predecessor: pred successor: succ  predecessor := pred.  successor := succ-=JUAMPI=-blueButtonPressed  ^buttons anyMask: self class blueButton-=JUAMPI=-iconPosition  ^iconPosition ifNil: [ iconPosition := #left ]-=JUAMPI=-