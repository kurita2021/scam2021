selectedFillStyle  ^self theme tabLabelSelectedFillStyleFor: self-======-printStructureOn: aStream indent: tabCount  tabCount timesRepeat: [ aStream tab ].  self printOn: aStream.  aStream cr.  self submorphsDo: [:m |  m printStructureOn: aStream indent: tabCount + 1 ]-======-updateFromEvent: anEvent  | pNew previousX newWidth minX newLeft |  pNew := anEvent cursorPoint - lastMouse second.  minX := index = 1 ifTrue: [ container minResizerX ] ifFalse: [ (container columnResizers at: index - 1) right + container minResizerOffset ].  newLeft := minX max: pNew x.  index = 1 ifTrue: [ newLeft := newLeft + 3 ].  self left: newLeft.  previousX := index = 1 ifTrue: [ container scroller left - container scroller offset x + 3 ] ifFalse: [ (container columnResizers at: index - 1) left ].  newWidth := self left - previousX.  (container columns at: index) currentWidth: newWidth.  container resizerChanged-======-displaySelectionInLine: line on: aCanvas  | leftX rightX w caretColor |  selectionStart ifNil: [ ^self ].  aCanvas isShadowDrawing ifTrue: [ ^self ].  selectionStart = selectionStop ifTrue: [ selectionStart textLine ~= line ifTrue: [ ^self ] ] ifFalse: [ (selectionStop stringIndex < line first or: [ selectionStart stringIndex > (line last + 1) ]) ifTrue: [ ^self ].        (selectionStop stringIndex = line first and: [ selectionStop textLine ~= line ]) ifTrue: [ ^self ].        (selectionStart stringIndex = (line last + 1) and: [ selectionStop textLine ~= line ]) ifTrue: [ ^self ] ].  leftX := (selectionStart stringIndex < line first ifTrue: [ line ] ifFalse: [ selectionStart ]) left.  rightX := (selectionStop stringIndex > (line last + 1) or: [ selectionStop stringIndex = (line last + 1) and: [ selectionStop textLine ~= line ] ]) ifTrue: [ line right ] ifFalse: [ selectionStop left ].  selectionStart = selectionStop ifTrue: [ rightX := rightX + 1.        w := self caretWidth.        caretRect := (leftX - w) @ line top corner: (rightX + w) @ line bottom.        self showCaret ifFalse: [ ^self ].        caretColor := self insertionPointColor.        1 to: w do: [:i |  aCanvas fillRectangle: ((leftX - w + i - 1) @ (line top + i - 1) extent: ((w - i) * 2 + 3) @ 1) color: caretColor.              aCanvas fillRectangle: ((leftX - w + i - 1) @ (line bottom - i) extent: ((w - i) * 2 + 3) @ 1) color: caretColor ].        aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom) color: caretColor ] ifFalse: [ caretRect := nil.        aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom) color: self selectionColor ]-======-enabled: anObject  enabled := anObject.  self     cachedForm: nil;     changed-======-ghostText  self subclassResponsibility-======-toggle  self isExpanded ifTrue: [ self collapseAndRefresh ] ifFalse: [ self expandAndRefresh ]-======-flashBounds  5 timesRepeat: [ Display flash: self boundsInWorld andWait: 120 ]-======-handlesClickOrDrag: evt  ^(self existsSubscriptionsFor: #click) or: [ (self existsSubscriptionsFor: #doubleClick) or: [ self existsSubscriptionsFor: #startDrag ] ]-======-newLabel  ^self theme checkboxLabelFor: self-======-targetPoint  ^position - source targetOffset-======-copyHandlerState: anEvent  -======-table: aTable  table := aTable-======-font: anObject  font := anObject.  self update: getLabelSelector-======-wantsColumnBreaks: aBoolean  wantsColumnBreaks := aBoolean-======-gripLayoutFrame  ^(0 @ 1 corner: 0 @ 1) asLayoutFrame     topOffset: self defaultHeight negated;     rightOffset: self defaultWidth-======-testTransform  | lf rectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 140 @ 60) equals: rectangle-======-defaultColor  ^Color green lighter-======-changePropotionalLayout  | layout |  ((layout := self layoutPolicy) notNil and: [ layout isProportionalLayout ]) ifTrue: [ ^self ].  self layoutPolicy: ProportionalLayout new.  self layoutChanged-======-setGrabbedColor  self fillStyle: self theme fastTableColumnSplitterSelectedColor-======-calculateVisibleRows  ^self calculateMaxVisibleRows min: self table numberOfRows-======-newGroupbox: aString for: control  ^self theme newGroupboxIn: self label: aString for: control-======-drawText: aStringOrText on: aCanvas in: aRectangle  ^self drawText: aStringOrText on: aCanvas in: aRectangle color: self stringColorToUse-======-drawLinesOn: canvas  self selectedTab ifNotNil: [ self drawWithSelectionOn: canvas ] ifNil: [ self drawWithoutSelectedOn: canvas ]-======-selectRow: index  selectedRows add: index.  self invalidRect: (self selectionFrameForRow: index)-======-scrollBarColor  ^self paneColor-======-flushLayoutCache  minExtentCache := nil-======-colorFor: index  index odd ifTrue: [ ^Smalltalk ui theme lightBackgroundColor ].  ^Smalltalk ui theme backgroundColor-======-finishedScrolling: event  self finishedScrolling.  (self containsPoint: event position) ifTrue: [ pagingArea           fillStyle: self mouseOverFillStyle;           borderStyle: self mouseOverBorderStyle ] ifFalse: [ pagingArea           fillStyle: self normalFillStyle;           borderStyle: self normalBorderStyle ].  (upButton containsPoint: event position) ifTrue: [ upButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: event position) ifTrue: [ upButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ upButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ].  (downButton containsPoint: event position) ifTrue: [ downButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: event position) ifTrue: [ downButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ downButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ]-======-theme  ^Smalltalk ui theme-======-mouseUp: evt  actWhen == #buttonUp ifFalse: [ ^super mouseUp: evt ].  (self containsPoint: evt cursorPoint) ifTrue: [ self state: #on.        self doButtonAction: evt ] ifFalse: [ self state: #off ]-======-preferredKeyboardPosition  ^(self bounds: self bounds in: self currentWorld) topLeft-======-indexFromPosition: aTuple  ^aTuple first-======-initializeTable: aTable  table := aTable.  self initialize-======-handleFocusEvent: anEvent  ^self handleEvent: anEvent-======-rotationDegrees  ^0.0-======-target: aMorph  self setTarget: aMorph.  target ifNotNil: [ self addHandles ]-======-wantsDirectionHandles  ^false-======-gridSpecPut: newSpec  ^self setProperty: #gridSpec toValue: newSpec-======-wantsKeyboardFocusOnMouseDown  ^self wantsKeyboardFocus and: [ self valueOfProperty: #wantsKeyboardFocusOnMouseDown ifAbsent: [ false ] ]-======-selectionBarColor  ^self theme selectionBarColor-======-itemWithWording: wording  self items do: [:anItem |  | found |        found := anItem itemWithWording: wording.        found ifNotNil: [ ^found ] ].  ^nil-======-compositionRectangle  ^container-======-tasks: anObject  tasks := anObject-======-inject: thisValue into: binaryBlock  | nextValue |  nextValue := thisValue.  self do: [:each |  nextValue := binaryBlock value: nextValue value: each ].  ^nextValue-======-selectionIndex  ^self listMorph selectedRow ifNil: [ 0 ]-======-positionModalOwner  self modalOwner ifNotNil: [:modalOwner |  (modalOwner isKindOf: SystemWindow) ifTrue: [ modalOwner bringBehind: self ] ]-======-down: anObject  down := anObject.  self changed-======-addNameBeneath: outerRectangle string: aString  | namePosition w |  w := self world ifNil: [ target world ].  nameMorph := StringMorph contents: aString font: StandardFonts haloFont.  nameMorph     wantsYellowButtonMenu: false;     color: self theme balloonTextColor;     backgroundColor: self theme balloonBackgroundColor;     target: innerTarget.  namePosition := outerRectangle bottomCenter - ((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).  nameMorph position: (namePosition min: w viewBox bottomRight - nameMorph extent y + 2).  self addMorph: nameMorph.  ^nameMorph-======-acceptOnCR: trueOrFalse  acceptOnCR := trueOrFalse-======-drawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: aCanvas ]-======-initialize  super initialize.  self elements: #()-======-table  ^table-======-getChildren  ^dataSource childrenBlock isSymbol ifTrue: [ dataSource childrenBlock value: data ] ifFalse: [ dataSource childrenBlock cull: data cull: self ]-======-setType: aSymbol  type := aSymbol-======-getIconSelector: anObject  getIconSelector := anObject-======-takesKeyboardFocus  ^true-======-addItemShowing: aString from: startNumber to: endNumber  lock critical: [ | item items |        item := SystemProgressItemMorph labeled: aString from: startNumber to: endNumber.        items := self bars size.        items < 10 ifTrue: [ self addMorphBack: item.              self recenter ].        ^item ]-======-wantsStepsWhenCollapsed  ^false-======-updateTasks  | tasksThatShouldBeUpdated |  tasksThatShouldBeUpdated := windows collect: [:window |  self newTaskFor: window ].  self updateOrderedTasksFrom: tasksThatShouldBeUpdated-======-lineWidth: anInteger  self borderWidth: (anInteger rounded max: 1)-======-scrollUpInit  | bc |  bc := upButton borderStyle baseColor.  upButton borderInset.  upButton borderStyle baseColor: bc.  self resetTimer.  self scrollBarAction: #doScrollUp.  self doScrollUp.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nil.  upButton fillStyle: self pressedButtonFillStyle.  upButton borderStyle: self pressedButtonBorderStyle-======-action  self inform: 'Button pressed'-======-changeMinCellSize: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self minCellSize: (newPoint - evt cursorPoint) asIntegerPoint ].  evt hand attachMorph: handle.  handle startStepping-======-beIconRight  iconPosition := #right.  self update: getIconSelector-======-on: anObject color: getColSel  self     model: anObject;     getColorSelector: getColSel;     updateColor-======-getChildrenSelector  ^getChildrenSelector-======-indexForRow: aRowIndex  ^{aRowIndex .   self table selectedIndex second}-======-newLocationMorph  ^ImageMorph new form: Cursor crossHair withMask asCursorForm-======-defaultColor  ^self theme menuSelectionColor alpha: 0.08-======-cellColumn: column row: rowIndex  column id = 'Icon' ifTrue: [ ^self iconColumn: column row: rowIndex ].  column id = 'Name' ifTrue: [ ^self nameColumn: column row: rowIndex ].  column id = 'Number of methods' ifTrue: [ ^self numberOfMethodsColumn: column row: rowIndex ].  column id = 'Number of instance variables' ifTrue: [ ^self numberOfInstanceVariablesColumn: column row: rowIndex ].  self error: 'Invalid column'-======-indentingItemClass  ^MorphTreeNodeMorph-======-hasTableLayoutString  | layout |  ^((layout := self layoutPolicy) notNil and: [ layout isTableLayout ]) -> 'table layout' translated-======-wantsExpandBox  ^true-======-deriveHScrollRange  | unadjustedRange totalRange |  (list isNil or: [ list isEmpty ]) ifTrue: [ hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0 ] ifFalse: [ unadjustedRange := self listMorph hUnadjustedScrollRange.        totalRange := unadjustedRange + self hExtraScrollRange + self hMargin.        hScrollRangeCache := Array with: totalRange with: unadjustedRange with: list size with: list first with: list last ]-======-headerColumn: column  ^self basicHeaderCellFor: column-======-setIndexSelector: aSelector  setIndexSelector := aSelector-======-windowEventHandler: anObject  WindowEventHandler := anObject-======-initialExtent  ^(self model respondsTo: #initialExtent) ifTrue: [ self model initialExtent ] ifFalse: [ RealEstateAgent standardWindowExtent ]-======-ownerChanged  super ownerChanged.  self updateLayoutInDockingBar-======-newOKButton  ^self newOKButtonFor: self-======-currentlyExpanded  ^(scroller submorphs select: [:each |  each isExpanded ]) collect: [:each |  each complexContents ]-======-acquireBorderWidth: aBorderWidth  | delta |  (delta := aBorderWidth - self borderWidth) = 0 ifTrue: [ ^self ].  self bounds: (self bounds origin - (delta @ delta) corner: self bounds corner + (delta @ delta)).  self borderWidth: aBorderWidth.  self layoutChanged-======-allSiblingItems  | menus str index |  str := (Array new: 40) writeStream.  menus := self owner submorphs select: [:m |  m isKindOf: self class ].  menus := (menus copyFrom: (index := menus indexOf: self) to: menus size) , (menus copyFrom: 1 to: index - 1).  menus do: [:menu |  str nextPutAll: menu items ].  ^str contents-======-userString  ^nil-======-visible: newValue  visible := newValue-======-target: aMorph  -======-headerButtonLabel: aLabel icon: anIconForm  self headerButtonLabel: aLabel font: nil.  self header cellInset: 3 @ 0.  self header icon: (ImageMorph new form: anIconForm)-======-newLabel  | lbl |  lbl := self theme buttonLabelFor: self.  font ifNotNil: [ lbl font: font.        lbl extent: lbl optimalExtent ].  ^lbl-======-arguments  ^arguments-======-handlesMouseDown: event  ^true-======-getListSelector: sel  getListSelector := sel.  self changed.  self updateList-======-basicBorderWidth: aNumber  borderWidth := aNumber-======-doGrow: evt with: growHandle  | newExtent extentToUse scale |  evt hand obtainHalo: self.  newExtent := (target pointFromWorld: evt cursorPoint - positionOffset) - target topLeft.  evt shiftPressed ifTrue: [ scale := newExtent x / (originalExtent x max: 1) min: newExtent y / (originalExtent y max: 1).        newExtent := (originalExtent x * scale) asInteger @ (originalExtent y * scale) asInteger ].  (newExtent x < 1 or: [ newExtent y < 1 ]) ifTrue: [ ^self ].  target renderedMorph extent: (extentToUse := newExtent).  growHandle position: evt cursorPoint - (growHandle extent // 2).  self layoutChanged-======-focusBounds  ^self theme buttonFocusBoundsFor: self-======-isMouseOver  ^self type == #mouseOver-======-getCurrentSelectionIndex  getIndexSelector ifNil: [ ^0 ].  ^model perform: getIndexSelector-======-restoreAndActivate  self isMinimized ifTrue: [ self restore ].  self isActive ifFalse: [ self activate ]-======-removeFlexShell  | oldHalo unflexed myWorld refPos aPosition |  refPos := self referencePosition.  myWorld := self world.  oldHalo := self halo.  submorphs isEmpty ifTrue: [ ^self delete ].  aPosition := (owner submorphIndexOf: self) ifNil: [ 1 ].  unflexed := self firstSubmorph.  self submorphs do: [:m |  m position: self center - (m extent // 2).        owner addMorph: m asElementNumber: aPosition ].  oldHalo ifNotNil: [ oldHalo setTarget: unflexed ].  myWorld ifNotNil: [ myWorld startSteppingSubmorphsOf: unflexed ].  self delete.  unflexed referencePosition: refPos.  ^unflexed-======-selectionColor  ^selectionColor-======-includesTableProperties  ^true-======-newBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newBracketSliderIn: self for: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpText-======-needSeparatorBefore: index  | tmpIndex |  index <= 1 ifTrue: [ ^false ].  tmpIndex := index.  self items do: [:elements |  elements size >= tmpIndex ifTrue: [ ^tmpIndex = 1 ] ifFalse: [ tmpIndex := tmpIndex - elements size ] ].  self errorSubscriptBounds: index-======-drawBackgroundOnAthensCanvas: anAthensCanvas  (isSelected and: [ isEnabled ]) ifFalse: [ ^self ].  anAthensCanvas setPaint: self selectionFillStyle.  anAthensCanvas drawShape: (0 @ 0 extent: self extent)-======-lastKeystroke: aString  ^self setProperty: #lastKeystroke toValue: aString-======-lastColumnBounded  ^self lastColumnUnbounded not-======-selection  ^editor ifNotNil: [ editor selection ]-======-actions  ^actions-======-drawOn: aCanvas  aCanvas fillOval: bounds fillStyle: self fillStyle borderWidth: borderWidth borderColor: borderColor-======-selfOrChildAt: anIndex  ^anIndex = 1 ifTrue: [ self ] ifFalse: [ self childAt: anIndex - 1 ]-======-setMultipleContents  | tabs size delta |  contentsWrapper removeAllMorphs.  self cleanProcesses.  tabs := toolbar orderedSelectedTabs.  size := tabs size.  delta := 1 / size.  tabs allButLast keysAndValuesDo: [:index :tab |  self addTabContents: tab at: index delta: delta ].  self addLastTabContents: tabs last among: size delta: delta.  self addSplitterOn: tabs delta: delta-======-drawSubMorphOn: aCanvas  | morphBounds |  morphBounds := self bounds insetBy: (self cornerRadius + 3) @ (self topInactiveGap // 2 + 2).  morphBounds := morphBounds translateBy: 0 @ (self topInactiveGap // 2 + 1).  self active ifTrue: [ morphBounds := morphBounds translateBy: 0 @ (self topInactiveGap // 2 + 1) negated ].  self subMorph bounds height < morphBounds height ifTrue: [ morphBounds := morphBounds insetBy: 0 @ ((morphBounds height - self subMorph bounds height) // 2) ].  self subMorph bounds width < morphBounds width ifTrue: [ morphBounds := morphBounds insetBy: ((morphBounds width - self subMorph bounds width) // 2) @ 0 ].  self subMorph bounds: morphBounds.  aCanvas drawMorph: self subMorph-======-defaultGraphics  ^DefaultGraphics-======-bringBehind: aMorph  | outerMorph |  outerMorph := self topRendererOrSelf.  outerMorph owner ifNil: [ ^self ].  outerMorph owner addMorph: outerMorph after: aMorph topRendererOrSelf.  self modalOwner ifNotNil: [:mo |  mo bringBehind: self ]-======-checkMorphsRightOrBottomFrom: splitter  | index |  index := submorphs identityIndexOf: splitter.  index := index - 1.  [ index > 0 ] whileTrue: [ | submorph done |        submorph := submorphs at: index.        splitter addRightOrBottom: submorph.        done := self isResizeableMorph: submorph forSplitter: splitter.        done ifTrue: [ index := 0 ].        index := index - 1 ]-======-controlKeyPressed  ^buttons anyMask: 2r00010000-======-prepareForRotating  ^self addFlexShell-======-addFlexShell  | oldHalo flexMorph myWorld anIndex |  myWorld := self world.  oldHalo := self halo.  anIndex := self owner submorphIndexOf: self.  self owner addMorph: (flexMorph := self newTransformationMorph asFlexOf: self) asElementNumber: anIndex.  self transferStateToRenderer: flexMorph.  oldHalo ifNotNil: [ oldHalo setTarget: flexMorph ].  myWorld ifNotNil: [ myWorld startSteppingSubmorphsOf: flexMorph ].  ^flexMorph-======-handlesMouseOverDragging: evt  ^self dropEnabled-======-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-======-mouseLeaveDragging: event  (self dropEnabled and: [ event hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: event ].  self basicHighlightIndexes: #().  self refresh-======-handleKeystroke: aKeystrokeEvent inMorph: aMorph  -======-wrapOnOff  self wrapFlag: wrapFlag not-======-pressedBorderStyle  ^self theme controlButtonPressedBorderStyleFor: self-======-aMorph  ^aMorph-======-newSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText-======-splitterRight  | splitters |  splitters := (self siblingSplitters select: [:each |  each left > self left and: [ self overlapsVertical: each ] ]) asSortedCollection: [:a :b |  a left < b left ].  ^splitters ifEmpty: [ nil ] ifNotEmpty: [:s |  s first ]-======-listSpacing: aSymbol  self assureTableProperties listSpacing: aSymbol.  self layoutChanged-======-onImage  | form |  form := Form extent: (self fontToUse ascent - 2) asPoint depth: 16.  form getCanvas     frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) borderWidth: 1 borderColor: Color black;     fillRectangle: (form boundingBox insetBy: 2) fillStyle: Color black.  ^form-======-expandItem  expanded := true.  children := (dataSource childrenFor: item) collect: [:each |  self treeItemFor: each ].  dataSource updateAvailableRows: self availableRows - 1-======-fillWithRamp: rampSpecsOrColor oriented: aRatio  rampSpecsOrColor isColor ifTrue: [ self color: rampSpecsOrColor ] ifFalse: [ | fill |        fill := GradientFillStyle ramp: rampSpecsOrColor.        fill origin: self bounds topLeft.        fill direction: (self bounds extent * aRatio) truncated.        fill radial: false.        self fillStyle: fill.        self borderColor: (rampSpecsOrColor first value mixed: 0.5 with: rampSpecsOrColor last value) muchDarker ]-======-adjustToHorizontalScrollBarValue: aNumber  | newStartColumnIndex |  newStartColumnIndex := (self table numberOfColumns * aNumber) rounded min: self table numberOfColumns max: 1.  newStartColumnIndex ~= self startColumnIndex ifTrue: [ self startColumnIndex: newStartColumnIndex.        self changed ]-======-testUpdateEmptyTaskBarWithNewWindow  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: taskbar tasks size equals: 1-======-iconOrThumbnailOfSize: aNumberOrPoint  ^self iconOrThumbnail scaledIntoFormOfSize: aNumberOrPoint-======-handlesKeyboard: evt  ^true-======-newFuzzyLabel: aString  ^self theme newFuzzyLabelIn: self for: nil label: aString offset: 1 alpha: 0.5 getEnabled: nil-======-matches: aString  self subclassResponsibility-======-debug  [ builder menuSpec asMenuMorph ] ensure: [ builder reset ]-======-world  ^world-======-mouseFocus: aMorphOrNil  mouseFocus := aMorphOrNil-======-mouseEnter: anEvent  self canResizeColumn ifFalse: [ ^self ].  (owner notNil and: [ owner bounds containsPoint: anEvent position ]) ifTrue: [ super mouseEnter: anEvent ]-======-verticesAt: ix put: newPoint  vertices at: ix put: newPoint.  self computeBounds-======-newAColorMorph  ^AColorSelectorMorph new     model: self;     hResizing: #spaceFill;     vResizing: #rigid;     setValueSelector: #alphaSelected:;     extent: 24 @ 24-======-vShowScrollBar  self vIsScrollbarShowing ifTrue: [ ^self ].  self vResizeScrollBar.  self privateAddMorph: scrollBar atIndex: 1.  self resetExtent-======-menu: menu shifted: b  super menu: menu shifted: b.  menu addLine.  self selectedNode ifNotNil: [:current |  current menu: menu shifted: b.        menu addLine.        menu add: 'Expand all from here' target: self selector: #expandAllFromNode: argument: current ].  ^menu-======-mouseUp: event  needToggleAtMouseUp ifFalse: [ ^self ].  (self selectionModeStrategy selectableIndexContainingPoint: event cursorPoint) ifNotNil: [:index |  self selectIndex: index event: event ].  needToggleAtMouseUp := false-======-event  ^event-======-userString  ^list ifNotNil: [ String streamContents: [:strm |  list do: [:i |  strm                       nextPutAll: i string;                       cr ] ] ]-======-layoutProperties  ^extension ifNotNil: [ extension layoutProperties ]-======-modifiedCharacter  self flag: #hack.  ^(self hasSpecialCTRLKeyValue and: [ #(MacOSX Windows) includes: Smalltalk os platformFamily ]) ifTrue: [ (self keyValue + $a asciiValue - 1) asCharacter ] ifFalse: [ Smalltalk os isWindows ifTrue: [ self keyCharacter asLowercase ] ifFalse: [ self keyCharacter ] ]-======-newGroupboxFor: control  ^self theme newGroupboxIn: self for: control-======-openInWindowLabeled: aString inWorld: aWorld  self layoutInset: 0.  ^super openInWindowLabeled: aString inWorld: aWorld-======-isAutoFit  ^false-======-removeWindow: aMorph  windows remove: aMorph-======-useSecondarySelection  ^false-======-mouseEnter: evt  super mouseEnter: evt.  self over: true-======-selectAll  self isMultipleSelection ifFalse: [ ^self ].  1 to: self maximumSelection do: [:i |  self listSelectionAt: i put: true ]-======-getListSelector  ^getListSelector-======-basicBorderColor: aColor  borderColor := aColor-======-newAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText-======-view: aViewOrMorph  -======-defaultButton  ^IconicButton new     target: self;     color: Color transparent;     borderWidth: 0;     yourself-======-selectedIndex  ^self selectedIndexes ifNotEmpty: #first ifEmpty: [ self selectionModeStrategy nullIndex ]-======-negateBottomRightOffsets  bottomOffset := bottomOffset negated.  rightOffset := rightOffset negated-======-keyStroke: anEvent  ^false-======-mouseLeaveDragging: evt  super mouseLeaveDragging: evt.  self over: false-======-assureExtension  extension ifNil: [ self initializeExtension ].  ^extension-======-vSetScrollDelta  | range delta |  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  delta := self scrollDeltaHeight.  range := self vLeftoverScrollRange.  range = 0 ifTrue: [ ^scrollBar           scrollDelta: 0.02 pageDelta: 0.2;           interval: 1.0;           setValue: 0 ].  scrollBar scrollDelta: (delta / range) asFloat pageDelta: ((self innerBounds height - delta) / range) asFloat.  scrollBar interval: (self innerBounds height / self vTotalScrollRange) asFloat.  scrollBar setValue: (scroller offset y / range min: 1.0) asFloat-======-passenger: anObject  passenger := anObject-======-paneWithLongestSide: sideBlock near: aPoint  | thePane theSide theLen |  theLen := 0.  paneMorphs do: [:pane |  | box |        box := pane bounds.        box forPoint: aPoint closestSideDistLen: [:side :dist :len |  (dist <= 5 and: [ len > theLen ]) ifTrue: [ thePane := pane.                    theSide := side.                    theLen := len ] ] ].  sideBlock value: theSide.  ^thePane-======-emptySelection  self selectedMorphList do: [:n |  n           unhighlight;           setSelectedSilently: false ].  self selectedMorphList removeAll.  self selectionChanged-======-hasUnacceptedEdits: aBoolean  -======-toggleEnabled  self enabled: self enabled not-======-newSeparator  ^self theme newSeparatorIn: self-======-leftArrowStroked: evt  popUpOwner ifNil: [ ^self ].  ^self deselectAndFocusOutermenuOn: evt-======-unsort  self unsortElements.  self table refresh-======-nextState  ^FTDescendingSortingState context: self context-======-getLabelSelector  ^getLabelSelector-======-enabled: anObject  enabled = anObject ifTrue: [ ^self ].  enabled := anObject.  self changed: #enabled.  self     adoptPaneColor: self paneColor;     changed-======-currentCursor  ^ActiveHand world currentCursor-======-imageFromName: aSymbol  ^self images at: aSymbol ifPresent: [:block |  block value ] ifAbsent: [  ]-======-isClosed  ^closed-======-topLeftColor  ^width = 1 ifTrue: [ self color twiceLighter ] ifFalse: [ self color lighter ]-======-displayWorld  worldState displayWorld: self submorphs: submorphs-======-findDeepSubmorphThat: block1 ifAbsent: block2  self allMorphsDo: [:m |  (block1 value: m) == true ifTrue: [ ^m ] ].  ^block2 value-======-selected  ^state selected-======-addToggleItemsToHaloMenu: aCustomMenu  super addToggleItemsToHaloMenu: aCustomMenu.  aCustomMenu addUpdating: #enabledString target: self selector: #toggleEnabled-======-defaultColor  ^Color white-======-isRight  ^direction = Character arrowRight-======-formerPosition  ^self valueOfProperty: #formerPosition-======-initialize  super initialize.  hasFocus := false.  self initializeScrollBars.  self extent: self defaultExtent.  self hideOrShowScrollBars-======-addHandleAt: aPoint color: aColor icon: iconName on: eventName send: selector to: recipient  | handle |  handle := self createHandleAt: aPoint color: aColor iconName: iconName.  self addMorph: handle.  handle on: #mouseUp send: #endInteraction to: self.  handle on: eventName send: selector to: recipient.  handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.  ^handle-======-steppingMorphsNotInWorld  | all |  all := self allMorphs.  ^self listOfSteppingMorphs reject: [:m |  all includes: m ]-======-enableFilter  function := FTFilterFunction table: self-======-selectPreviousTab  self selectedIndex: (self selectedIndex < 2 ifTrue: [ self tabs size ] ifFalse: [ self selectedIndex - 1 ])-======-wantsYellowButtonMenu  self valueOfProperty: #wantsYellowButtonMenu ifPresentDo: [:value |  ^value ].  self isInSystemWindow ifTrue: [ ^false ].  ^self defaultYellowButtonMenuEnabled-======-model  ^nil-======-on: eventName send: selector to: recipient withValue: value  selector numArgs = 3 ifFalse: [ self error: 'Warning: value parameters are passed as first of 3 arguments' ].  self addSubscription: (MorphEventSubscription on: eventName send: selector to: recipient withValue: value) toEvent: eventName-======-truncatedMenuLabelFor: aWindowLabel  ^aWindowLabel truncateWithElipsisTo: 47-======-selectedNodePathList: aCollectionOfPath  selectedNodePathList := aCollectionOfPath-======-newBalloonHelp: aTextStringOrMorph for: aMorph  ^self theme newBalloonHelpIn: self contents: aTextStringOrMorph for: aMorph corner: #bottomLeft-======-unshiftedYellowButtonActivity  ^self yellowButtonActivity: false-======-keyStroke: evt  | keyValue |  owner isHandMorph ifFalse: [ ^self ].  keyValue := evt keyValue.  keyValue = 28 ifTrue: [ ^self position: self position - (1 @ 0) ].  keyValue = 29 ifTrue: [ ^self position: self position + (1 @ 0) ].  keyValue = 30 ifTrue: [ ^self position: self position - (0 @ 1) ].  keyValue = 31 ifTrue: [ ^self position: self position + (0 @ 1) ].  keyValue = 13 ifTrue: [ owner releaseKeyboardFocus: self.        self delete ]-======-testSelectLast  table selectLast.  self assert: table selectedIndexes equals: #(10)-======-selectIndexes: anArray andMakeVisibleIf: shouldEnsureVisibleSelection  | oldSelectedIndexes |  anArray = self selectedIndexes ifTrue: [ ^self ].  oldSelectedIndexes := self selectedIndexes.  self basicSelectIndexes: anArray.  shouldEnsureVisibleSelection ifTrue: [ self ensureVisibleFirstSelection ].  self refresh.  self doAnnounce: ((FTSelectionChanged from: oldSelectedIndexes to: self selectedIndexes)           fastTable: self;           yourself)-======-privateFullMoveBy: delta  self privateMoveBy: delta.  submorphs do: [:each |  each privateFullMoveBy: delta ]-======-updateImage  (self model notNil and: [ self getImageSelector notNil ]) ifTrue: [ (self model perform: self getImageSelector) ifNotNil: [:i |  self image: i ] ]-======-createExpandBox  ^self theme createExpandBoxFor: self-======-spotterWindowsFor: aStep  < spotterOrder: 100>  aStep listProcessor     title: 'Windows';     allCandidates: [ self class allSubInstances ];     itemName: [:window |  '**' , window label , '**' ];     filter: GTFilterSubstring-======-vHideOrShowScrollBar  self vIsScrollbarNeeded ifTrue: [ self vShowScrollBar ] ifFalse: [ self vHideScrollBar ]-======-children  | children |  children := OrderedCollection new.  self childrenDo: [:each |  children add: each ].  ^children-======-keyStroke: event  (super keyStroke: event) ifTrue: [ ^true ].  self keystrokeSelector ifNotNil: [ (self keyStrokeAction: event) ifTrue: [ ^true ] ].  (self keystrokeActionSelector notNil and: [ event anyModifierKeyPressed ]) ifTrue: [ (self keyStrokeModifierAction: event) ifTrue: [ ^true ] ].  ^false-======-cachedForm  | form i effectiveAlpha |  cachedForm ifNil: [ i := self scaledImage.        effectiveAlpha := self enabled ifTrue: [ self alpha ] ifFalse: [ self alpha / 2 ].        effectiveAlpha = 1.0 ifTrue: [ self cachedForm: i ] ifFalse: [ form := Form extent: i extent depth: 32.              form fillColor: (Color white alpha: 0.003922).              (form getCanvas asAlphaBlendingCanvas: effectiveAlpha) drawImage: i at: 0 @ 0.              self cachedForm: form ] ].  ^cachedForm-======-newColumn: controls  ^self theme newColumnIn: self for: controls-======-reversedSelectedTabs  ^selectionHistory last: numberOfSelectedTabs-======-openInExternalWindow  | world |  world := OSWindowWorldMorph new extent: self fullBounds extent.  world     layoutPolicy: ProportionalLayout new;     clipSubmorphs: true.  self     hResizing: #spaceFill;     vResizing: #spaceFill.  self openInWorld: world.  self onAnnouncement: MorphDeleted do: [:announce |  world ifNotNil: [ world delete ].        world := nil ].  ^world open-======-removePendingBalloonFor: aMorph  self removeAlarm: #spawnBalloonFor:.  self deleteBalloonTarget: aMorph-======-expandAllSuchThat: aBlock  self roots do: [:m |  self expand: m suchThat: aBlock ].  self innerWidgetChanged-======-setSwitchState: aBoolean  aBoolean ifTrue: [ self turnOn ] ifFalse: [ self turnOff ]-======-tabKey: event  event controlKeyPressed ifFalse: [ event keyCharacter = Character tab ifTrue: [ event shiftPressed ifTrue: [ self navigateFocusBackward ] ifFalse: [ self navigateFocusForward ].              ^true ] ].  ^false-======-newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel  ^self newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: nil-======-alpha: anObject  alpha := anObject.  self changed-======-hue: anInteger  | c |  c := self selectedColor.  self selectedColor: ((Color h: (anInteger / 255 * 359) rounded s: c saturation v: c brightness) alpha: c alpha)-======-testIndexesToSelectInMultipleSelectionFromTo  self subclassResponsibility-======-borderWidth: anInteger  borderColor ifNil: [ borderColor := Color black ].  borderWidth := anInteger max: 0.  self computeBounds-======-getEnabledSelector: anObject  getEnabledSelector := anObject.  self updateEnabled-======-submorphBounds  | box |  submorphs do: [:m |  | subBox |        m visible ifTrue: [ subBox := m fullBounds.              box ifNil: [ box := subBox copy ] ifNotNil: [ box := box quickMerge: subBox ] ] ].  box ifNil: [ ^self bounds ].  ^box origin asIntegerPoint corner: box corner asIntegerPoint-======-isPartialMatch  ^self complexContents isPartialMatch-======-dropItemSelector: aSelector  self dataSource dropItemSelector: aSelector-======-onWindowLabelChanged: ann  self tabGroup relabelPage: ann window with: (self tabLabelFor: ann window)-======-potentialDropMorph: anObject  potentialDropMorph := anObject-======-activateCursor: aCursor withMask: maskForm  -======-imageExport  ^self form bits asArray-======-maximumSelection  ^scroller submorphs size-======-vanishAfterSlidingTo: aPosition event: evt  | aForm aWorld startPoint endPoint |  aForm := self imageForm offset: 0 @ 0.  aWorld := self world.  startPoint := evt hand fullBounds origin.  self delete.  aWorld displayWorld.  endPoint := aPosition.  aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15-======-yellowButtonPressed  ^buttons anyMask: self class yellowButton-======-drawOn: aCanvas  super drawOn: aCanvas.  (ActiveHand notNil and: [ ActiveHand keyboardFocus == self and: [ self rootMenu hasProperty: #hasUsedKeyboard ] ]) ifTrue: [ aCanvas frameAndFillRectangle: self innerBounds fillColor: Color transparent borderWidth: self theme menuBorderWidth borderColor: self theme menuKeyboardFocusColor ]-======-maximumSelection  ^self getListSize-======-newMenu  ^self theme newMenuIn: self for: self-======-selectFirst  self table selectIndex: #(1 1)-======-gridOrigin: newOrigin  ^self gridSpecPut: (newOrigin extent: self gridModulus)-======-borderColor: aColor  super borderColor: aColor.  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) == (aColor isColor and: [ aColor isTranslucentButNotTransparent ]) ifFalse: [ self releaseCachedState ]-======-is: anIndex bellowRow: aRowIndex  ^anIndex > aRowIndex-======-hResizeScrollBar  super hResizeScrollBar.  hScrollBar bounds: ((hScrollBar bounds withTop: hScrollBar top - self pagerHeight) withBottom: hScrollBar bottom - self pagerHeight)-======-taskbarButtonMenu: aMenu  | menu theme submenu |  theme := self theme.  menu := theme newMenuIn: self for: self.  menu addToggle: 'Restore' translated target: self selector: #restore getStateSelector: nil enablementSelector: #isNotRestored.  menu lastItem     icon: self theme windowMaximizeForm;     font: theme menuFont.  menu addToggle: 'Minimize' translated target: self selector: #minimize getStateSelector: nil enablementSelector: #isNotMinimized.  menu lastItem     icon: self theme windowMinimizeForm;     font: theme menuFont.  menu addToggle: 'Maximize' translated target: self selector: #maximize getStateSelector: nil enablementSelector: #canBeMaximized.  menu lastItem     icon: self theme windowMaximizeForm;     font: theme menuFont.  menu addLine.  submenu := theme newMenuIn: self for: self.  menu add: 'Close all' icon: self theme windowCloseForm subMenu: submenu.  submenu addToggle: 'windows to right' translated target: self selector: #taskbarCloseAllToRight getStateSelector: nil enablementSelector: true.  submenu addToggle: 'windows like this' translated target: self selector: #taskbarCloseAllLikeThis getStateSelector: nil enablementSelector: true.  submenu addToggle: 'unchanged windows' translated target: self currentWorld selector: #closeAllUnchangedWindows getStateSelector: nil enablementSelector: true.  submenu addToggle: 'close all debuggers' translated target: Smalltalk tools debugger selector: #closeAllDebuggers getStateSelector: nil enablementSelector: true.  menu addToggle: 'Close' translated target: self selector: #closeBoxHit getStateSelector: nil enablementSelector: #allowedToClose.  menu lastItem     icon: self theme windowCloseForm;     font: theme menuFont.  ^menu-======-couldHaveRoundedCorners  ^false-======-font: aFont  self labelMorph font: aFont-======-cellInset  ^0-======-normalFillStyle  ^self theme splitterNormalFillStyleFor: self-======-tearDown  morph delete.  super tearDown-======-drawOnAthensCanvas: anAthensCanvas  self getListSize = 0 ifTrue: [ ^self ].  self setColumnWidthsFor: anAthensCanvas.  self adjustWidth.  super drawOnAthensCanvas: anAthensCanvas-======-newHatchMorph  ^Morph new     color: Color transparent;     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     minWidth: 48;     minHeight: 12;     addMorph: (Morph new color: Color white) fullFrame: (0 @ 0 corner: 0.3 @ 1) asLayoutFrame;     addMorph: (Morph new fillStyle: (InfiniteForm with: self hatchForm)) fullFrame: (0.3 @ 0 corner: 0.7 @ 1) asLayoutFrame;     addMorph: self solidLabelMorph fullFrame: (0.7 @ 0 corner: 1 @ 1) asLayoutFrame;     addMorph: self labelMorph fullFrame: (0 @ 0 corner: 1 @ 1) asLayoutFrame-======-dismissMorph  | w |  w := self world ifNil: [ ^self ].  w stopStepping: self.  self delete-======-extent: newExtent  self adjustAfter: [ | scaleFactor |        scaleFactor := self scale * newExtent r / self fullBounds extent r max: 0.1.        self scale: (scaleFactor detentBy: 0.1 atMultiplesOf: 1.0 snap: false) ]-======-defaultImageFormOfSize: aPoint  ^(defaultImageForm isNil or: [ defaultImageForm extent ~= aPoint ]) ifTrue: [ defaultImageForm := Form extent: aPoint ] ifFalse: [ defaultImageForm ]-======-sliderThickness  ^7-======-testHeading  | t |  cases := {(t := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ [ self assert: t heading equals: 0.0 ] ensure: [ t delete ] ]-======-setListFont  StandardFonts chooseFontWithTitle: 'Choose the font for this list' translated for: self setSelector: #font: getSelector: #font-======-menuColumn: column row: rowIndex  | menu |  self getMenuSelector ifNil: [ ^nil ].  menu := UIManager default newMenuIn: self table for: self model.  self getMenuSelector numArgs = 1 ifTrue: [ ^self model perform: self getMenuSelector with: menu ].  ^self model perform: self getMenuSelector with: menu with: false-======-clipboardText: aString  ^self osWindow clipboardText: aString-======-newHColorMorph  ^HColorSelectorMorph new     model: self;     setValueSelector: #hue:;     hResizing: #rigid;     vResizing: #spaceFill;     extent: 36 @ 36-======-getListElementSelector  ^self dataSource getListElementSelector-======-minWidth  | noVPlease noHPlease minW |  noVPlease := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  noHPlease := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  minW := noVPlease ifTrue: [ noHPlease ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness * 3 ] ] ifFalse: [ noHPlease ifTrue: [ self scrollBarThickness + 20 ] ifFalse: [ self scrollBarThickness * 3 + 2 ] ].  ^minW max: super minWidth-======-requestDropReference: i  | fileName |  fileNames ifNil: [ ^FileReference requestDropReference: i ].  fileName := self fileNames at: i.  ^(FilePathEncoder decode: fileName) asFileReference-======-explicitFunction  function showWidget-======-outerBounds  ^self bounds-======-cellPositioning: aSymbol  cellPositioning := aSymbol-======-actionOffset  ^4 * self displayScaleFactor-======-wantsHaloFromClick  ^true-======-removeKeyCombination: aShortcut  self kmDispatcher removeKeyCombination: aShortcut-======-wantsToBeTopmost  ^false-======-listDirection: aSymbol  listDirection := aSymbol-======-beStraightSegments  smoothCurve == false ifFalse: [ smoothCurve := false.        self computeBounds ]-======-wantsWindowEvent: anEvent  ^true-======-setColor: aColor  self labelMorph color: aColor.  self solidLabelMorph color: aColor beOpaque-======-testWhenChangingOrderInWorldListTaskOrderShouldRemains  | window1 window2 |  taskbar := self.  world := self.  window1 := world addWindow.  window2 := world addWindow.  taskbar updateTasks.  world putOnTop: window1.  taskbar updateTasks.  self assert: taskbar tasks first morph equals: window1.  self assert: taskbar tasks second morph equals: window2-======-selectMoreAtTop  | first |  autoTargetMorph ifNil: [ ^self ].  first := autoTargetMorph index.  first > 1 ifTrue: [ self autoMultiSelect: (self allNodeMorphs at: first - 1).        self selectionChanged ]-======-actionSelector  ^actionSelector-======-adoptGradientColor: aColor  | c fs bfs bs bbs |  aColor ifNil: [ ^self ].  c := aColor.  fs := self normalThumbFillStyle.  bfs := self normalButtonFillStyle.  bs := self normalThumbBorderStyle.  bbs := self normalButtonBorderStyle.  sliderColor := c.  downButton     fillStyle: bfs;     borderStyle: bbs.  upButton     fillStyle: bfs shallowCopy;     borderStyle: bbs.  slider     fillStyle: fs;     borderStyle: bs.  self updateUpButtonImage.  self updateDownButtonImage-======-newButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpText-======-setTabContentFrom: aTab  | process |  contentsWrapper removeAllMorphs.  self cleanProcesses.  process := aTab retrieveMorph: [:contents |  contents ifNil: [ TabWithNoContents signalTab: aTab ].        contentsWrapper addMorph: contents fullFrame: LayoutFrame identity ].  process ifNotNil: [ processes add: process ]-======-outermostMorphThat: conditionBlock  | outermost |  self allOwnersDo: [:m |  (conditionBlock value: m) ifTrue: [ outermost := m ] ].  ^outermost-======-getColorSelector: anObject  getColorSelector := anObject-======-wantsDroppedMorph: aMorph event: anEvent  ^aMorph dragTransferType == #dragTransfer ifTrue: [ super wantsDroppedMorph: aMorph event: anEvent ] ifFalse: [ self model wantsDroppedMorph: aMorph event: anEvent inMorph: self ]-======-minHeight  | iconHeight |  iconHeight := self hasIcon ifTrue: [ self icon height + 2 ] ifFalse: [ 0 ].  ^((self contents heightToDisplayInTree: self) max: iconHeight) max: super minHeight-======-wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph  (#(addDismissHandle:) includes: aSelector) ifTrue: [ ^self resistsRemoval not ].  (#(addDragHandle:) includes: aSelector) ifTrue: [ ^self okayToBrownDragEasily ].  (#(addGrowHandle: addScaleHandle:) includes: aSelector) ifTrue: [ ^self okayToResizeEasily ].  (#(addRotateHandle:) includes: aSelector) ifTrue: [ ^self okayToRotateEasily ].  (#(addRecolorHandle:) includes: aSelector) ifTrue: [ ^self renderedMorph wantsRecolorHandle ].  ^true-======-transform: anEvent from: originalEvent andSendTo: aMorph  | transformedEvent |  transformedEvent := anEvent transformedBy: (aMorph transformedFrom: originalEvent hand).  ^aMorph handleEvent: transformedEvent-======-releaseKeyboardFocus: aMorph  self keyboardFocus == aMorph ifTrue: [ self releaseKeyboardFocus ]-======-computedBounds  | tb tbw yGap |  tb := treeMorph bounds.  tbw := treeMorph borderWidth.  yGap := self layoutInset asPoint y + self cellInset asPoint y.  ^tb bottomLeft + (tbw @ (self computedHeight + yGap) negated) corner: tb bottomRight - ((tbw * 2) @ yGap)-======-newHueSelector: aModel getHue: getSel setHue: setSel help: helpText  ^self theme newHueSelectorIn: self for: aModel getHue: getSel setHue: setSel help: helpText-======-nextPage: newLast  | addedNodeList |  newLast > self lastIndex ifFalse: [ ^self ].  self lastIndex < self nodeList size ifTrue: [ addedNodeList := self nodeList copyFrom: 1 to: newLast.        self lastIndex: newLast.        treeMorph scroller removeAllMorphs.        treeMorph addSubmorphsFromNodeList: addedNodeList previouslyExpanded: treeMorph currentlyExpanded ]-======-isAdheringToRight  ^self edgeToAdhereTo == #right-======-hasSelection  ^self selectedIndexes isNotEmpty-======-generateKeyboardEvent: evtBuf  | buttons modifiers type pressType stamp charCode keyValue keyEvent |  stamp := evtBuf second.  stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].  pressType := evtBuf fourth.  pressType = EventKeyDown ifTrue: [ type := #keyDown.        lastKeyScanCode := evtBuf third ].  pressType = EventKeyUp ifTrue: [ type := #keyUp ].  pressType = EventKeyChar ifTrue: [ type := #keystroke ].  modifiers := evtBuf fifth.  buttons := modifiers bitShift: 3.  keyValue := evtBuf third.  charCode := evtBuf sixth.  type = #keystroke ifTrue: [ combinedChar ifNil: [ | peekedEvent |              peekedEvent := Sensor peekEvent.              (peekedEvent notNil and: [ peekedEvent fourth = EventKeyDown ]) ifTrue: [ (CombinedChar isCompositionCharacter: charCode) ifTrue: [ combinedChar := CombinedChar new.                          combinedChar simpleAdd: charCode asCharacter.                          (combinedChar combinesWith: peekedEvent third asCharacter) ifTrue: [ ^nil ] ] ] ] ifNotNil: [ (combinedChar simpleAdd: charCode asCharacter) ifTrue: [ charCode := combinedChar combined charCode ].              combinedChar := nil ] ].  (type = #keystroke and: [ (buttons anyMask: 16) and: [ {Character arrowUp .               Character arrowDown} includes: charCode asCharacter ] ]) ifTrue: [ ^MouseWheelEvent fromCharacter: charCode asCharacter position: lastMouseEvent cursorPoint buttons: buttons hand: self stamp: stamp ].  self flag: #pharoFixMe.  (charCode notNil and: [ charCode > 255 ]) ifTrue: [ keyValue := 0 ].  keyEvent := KeyboardEvent new setType: type buttons: buttons position: self position keyValue: keyValue charCode: charCode hand: self stamp: stamp.  keyEvent scanCode: lastKeyScanCode.  ^keyEvent-======-mouseLeave: evt  ^self eventHandler ifNotNil: [ self eventHandler mouseLeave: evt fromMorph: self ]-======-leftLayoutFrame  ^(0 @ 0 corner: 0 @ 1) asLayoutFrame     topOffset: -7;     bottomRightOffset: SystemWindow borderWidth @ (SystemWindow borderWidth - 26)-======-selectMorph: aNodeMorph multiple: withMultipleSelection clickedTheCheckBox: checkBox  | path mult |  checkBox ifFalse: [ self lastClickedMorph: aNodeMorph ].  aNodeMorph ifNil: [ self emptySelection.        ^nil ].  aNodeMorph selected ifTrue: [ withMultipleSelection ifTrue: [ self removeFromSelection: aNodeMorph ] ifFalse: [ mult := self selectedMorphList size > 1.              path := aNodeMorph path collect: [:m |  m complexContents ].              (self autoDeselection or: [ mult ]) ifTrue: [ self emptySelection.                    mult ifTrue: [ self addToSelection: aNodeMorph ] ifFalse: [ path := nil ] ] ] ] ifFalse: [ withMultipleSelection ifFalse: [ self emptySelection ].        self addToSelection: aNodeMorph clickedTheCheckBox: checkBox.        path := aNodeMorph path collect: [:m |  m complexContents ] ].  self selectionChanged.  ^path-======-takesKeyboardFocus  ^true-======-releaseCachedState  self borderStyle releaseCachedState-======-labelMorph  ^labelMorph-======-drawDropHighlightOn: aCanvas  self highlightedForDrop ifTrue: [ aCanvas frameRectangle: self fullBounds color: self dropHighlightColor ]-======-item: newItem  item := newItem-======-newOKButton  ^self newOKButtonFor: self-======-shouldFlex  ^true-======-layoutFrame: aLayoutFrame  layoutFrame := aLayoutFrame-======-borderStyleToUse  ^self isRadioButton ifTrue: [ self radioBorderStyleToUse ] ifFalse: [ self checkboxBorderStyleToUse ]-======-newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpText-======-adoptPaneColor: aColor  self color: aColor-======-adjustBorderUponDeactivationWhenLabeless  | aWidth |  (aWidth := self valueOfProperty: #borderWidthWhenInactive) ifNotNil: [ self acquireBorderWidth: aWidth ]-======-enabled: aBoolean  aBoolean = self enabled ifFalse: [ enabled := aBoolean.        self           adoptPaneColor: self paneColor;           changed ]-======-balloonText  extension ifNil: [ ^nil ].  ^extension balloonText ifNotNil: [:text |  text asString withNoLineLongerThan: self theme settings maxBalloonHelpLineLength ]-======-drawWithSelectionOn: canvas  canvas line: self bottomLeft + (0 @ -1) to: self selectedTab bottomLeft width: 1 color: self borderColor.  canvas line: self selectedTab bottomLeft to: self selectedTab bottomRight width: 1 color: self selectedColor.  canvas line: self selectedTab bottomRight to: self bottomRight + (0 @ -1) width: 1 color: self borderColor-======-setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) rounded-======-allowsKeymapping  ^self valueOfProperty: #allowsKeymapping ifAbsent: [ true ]-======-originColumn: column row: rowIndex  ^FTCellMorph new     color: (self colorFor: rowIndex);     addMorph: (self elementAt: rowIndex) origin name asMorph;     yourself-======-paneColor  ^self paneColorOrNil ifNil: [ self color ]-======-mouseUp: anEvent  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: anEvent cursorPoint) ifFalse: [ anEvent hand showTemporaryCursor: nil ].  self class fastSplitterResize ifTrue: [ self updateFromEvent: anEvent ].  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUp-======-buildVerticesFrom: borderVertices  ^state buildVerticesFrom: borderVertices-======-scrollPane  ^scrollPane-======-mouseOverBorderStyle  ^mouseOverBorderStyle ifNil: [ BorderStyle thinGray ]-======-selectedLabel  ^selectedLabel-======-canvas: x  -======-useExtraSelection  ^self useFindReplaceSelection or: [ self useSecondarySelection ]-======-themeChanged  self fillStyle: self normalFillStyle.  super themeChanged-======-complexContents  ^complexContents-======-addInterruptionButton  self isInterruptable ifFalse: [ ^self ].  self addMorphBack: (self iconNamed: #stopIcon) asMorph-======-hand  ^source-======-shouldDraw  ^super shouldDraw or: [ self class showSplitterHandles ]-======-mouseEnterDragging: evt  evt hand mouseFocus == owner ifTrue: [ owner selectItem: self event: evt ]-======-bounds: aRectangle in: referenceMorph  owner ifNil: [ ^aRectangle ].  ^(owner transformFrom: referenceMorph) localBoundsToGlobal: aRectangle-======-transformBy: aMorphicTransform  position := aMorphicTransform globalPointToLocal: position-======-getEnabledSelector  ^getEnabledSelector-======-index: anIndex  index := anIndex-======-resizeCursor  ^Cursor resizeForEdge: (splitsTopAndBottom ifTrue: [ #top ] ifFalse: [ #left ])-======-asAthensCurvedPathOn: anAthensCanvas  | points |  points := self computeCurvedSegmentCtrlPoints.  ^anAthensCanvas createPath: [:builder |  self vertices notEmpty ifTrue: [ | prior |              prior := points first.              builder absolute.              builder moveTo: prior second.              points allButFirst do: [:p |  builder curveVia: prior third and: p first to: p second.                    prior := p ].              self isClosed ifTrue: [ builder curveVia: prior third and: points first first to: points first second.                    builder close ] ].        builder ]-======-bottomFraction  ^bottomFraction-======-newHSVSelector: aColor help: helpText  ^self theme newHSVSelectorIn: self color: aColor help: helpText-======-handlesKeyboard: evt  ^true-======-getLabelSelector: anObject  getLabelSelector := anObject.  self updateLabel-======-hasProperty: aSymbol  extension ifNil: [ ^false ].  ^extension hasProperty: aSymbol-======-intoWorldCount  ^intoWorldCount-======-labelString  ^label ifNil: [ labelString ] ifNotNil: [ label contents asString ]-======-getListItem: index  ^listSource getListRow: index-======-addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol argumentList: argList  self addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol enablementSelector: nil argumentList: argList-======-navigateWindowBackward  self previousWindow ifNotNil: [:m |  m isCollapsed ifTrue: [ m collapseOrExpand ].        m activate ]-======-icon: anObject  icon := anObject-======-adoptPaneColor: paneColor  (paneColor notNil and: [ self trackPaneColor ]) ifTrue: [ self color: paneColor ].  super adoptPaneColor: paneColor-======-selectedObject  | halo |  halo := self halo.  halo ifNil: [ ^nil ].  ^halo target renderedMorph-======-contents  ^text-======-activeSubmenu: aSubmenu  activeSubMenu ifNotNil: [ activeSubMenu delete ].  activeSubMenu := aSubmenu.  aSubmenu ifNil: [ ^self ].  activeSubMenu selectItem: nil event: nil.  activeSubMenu borderColor: self borderColor.  activeSubMenu beSticky.  activeSubMenu resistsRemoval: true.  activeSubMenu removeMatchString-======-setProperty: aSymbol toValue: abObject  self assureOtherProperties at: aSymbol put: abObject-======-showFirstSelection  self hasSelection ifFalse: [ ^self ].  self moveShowIndexTo: self selectedIndex-======-hasContents  ^self contents isEmpty not-======-lastVertex  ^vertices last-======-removeMorph: aMorph  | aWorld |  aMorph owner == self ifFalse: [ ^self ].  aWorld := self world.  aWorld ifNotNil: [ aMorph outOfWorld: aWorld.        self privateInvalidateMorph: aMorph ].  self privateRemove: aMorph.  aMorph privateOwner: nil.  self removedMorph: aMorph-======-handlesMouseDown: evt  ^true-======-selectedPressedBorderStyle  ^self theme controlButtonSelectedPressedBorderStyleFor: self-======-highlightSelection  selectedMorph ifNotNil: [ selectedMorph highlight ]-======-max  ^(self sliderMorph ifNil: [ ^0 ]) max-======-newTabSelectorMorph  ^TabSelectorMorph new     vResizing: #shrinkWrap;     hResizing: #spaceFill-======-announceDate  | announcement |  announcement := ChoseDate of: self date from: self.  announcer ifNotNil: [ announcer announce: announcement ]-======-setColor: aColor toHandle: aHandle  aHandle color: aColor.  self gradientHalo ifTrue: [ | fill |        fill := GradientFillStyle ramp: {(0.0 -> aColor muchLighter) .               (1.0 -> aColor darker)}.        fill origin: aHandle topLeft.        fill direction: aHandle extent.        aHandle fillStyle: fill ]-======-isCloseable  ^self mustNotClose not and: [ model ifNotNil: [ model okToChange ] ifNil: [ true ] ]-======-selectLast  self table selectIndex: self table numberOfRows-======-objectToPaste  ^Cursor wait showWhile: [ PasteBuffer veryDeepCopy ]-======-halo  ^self primaryHand halo ifNotNil: [:h |  h target == self ifTrue: [ h ] ]-======-themeChanged  self     removeAllMorphs;     initializeSlider.  super themeChanged-======-initialize  super initialize.  self cellInset: 7-======-setValue: newValue  self value: newValue.  setValueSelector ifNotNil: [ ^model perform: setValueSelector with: value ]-======-target  ^objectToView-======-shadowPoint: newPoint  self changed.  self shadowOffset: (newPoint - self center) // 5.  fullBounds ifNotNil: [ fullBounds := self privateFullBounds ].  self changed-======-disable  self enabled: false-======-athensDisplay: item atRow: row on: aCanvas  | c backgroundColor drawBounds |  drawBounds := self drawBoundsForRow: row.  c := self colorForRow: row.  backgroundColor := self backgroundColorForRow: row.  item listRenderOn: aCanvas asCanvasWrapper atRow: row bounds: drawBounds color: c backgroundColor: backgroundColor from: self.  row = self mouseDownRow ifTrue: [ (aCanvas setStrokePaint: c)           width: 1;           dashes: {1} offset: 0.        aCanvas drawShape: (self selectionFrameForRow: row) ]-======-color: aColor  super color: aColor.  self setProperty: #basicColor toValue: aColor-======-themeChanged  self onImage: (self isRadioButton ifTrue: [ self theme radioButtonMarkerForm ] ifFalse: [ self theme checkboxMarkerForm ]).  self adoptPaneColor: self paneColor.  super themeChanged-======-separatorAfterARow: aRow  aRow ifNil: [ ^false ].  self separatorBlockOrSelector ifNotNil: [:blockOrSelector |  | anItem |        anItem := getListElementSelector ifNil: [ list at: aRow ifAbsent: [ ^false ] ] ifNotNil: [ model perform: getListElementSelector with: aRow ].        ^blockOrSelector isBlock ifTrue: [ blockOrSelector cull: anItem cull: aRow ] ifFalse: [ blockOrSelector isSymbol ifTrue: [ blockOrSelector numArgs == 0 ifTrue: [ anItem perform: blockOrSelector ] ifFalse: [ self model perform: blockOrSelector withEnoughArguments: {anItem .                                 aRow} ] ] ifFalse: [ false ] ] ].  ^false-======-selectLast  self table selectIndex: {self table numberOfRows .         self table numberOfColumns}-======-scrollLeft: count  self scrollUp: count-======-offColor  ^offColor-======-scrollAbsolute: event  | r p |  r := self roomToMove.  bounds isWide ifTrue: [ r width = 0 ifTrue: [ ^self ] ] ifFalse: [ r height = 0 ifTrue: [ ^self ] ].  p := event targetPoint adhereTo: r.  self descending ifFalse: [ self setValue: (bounds isWide ifTrue: [ (p x - r left) asFloat / r width ] ifFalse: [ (p y - r top) asFloat / r height ]) ] ifTrue: [ self setValue: (bounds isWide ifTrue: [ (r right - p x) asFloat / r width ] ifFalse: [ (r bottom - p y) asFloat / r height ]) ]-======-transform  ^transform-======-filterNowWith: patternString  pattern := patternString.  self field setText: pattern.  self filterWith: pattern.  self filter-======-oldScrollingIndex  ^oldScrollingIndex-======-newContentMorph  self hsvaMorph: self newHSVAColorSelectorMorph.  ^self newRow: {(self newGroupbox: 'Color' translated forAll: {self hsvaMorph .               ((self newRow: {((self newLabelGroup: {('Selected color' translated -> self newColorPresenterMorph)}) vResizing: #shrinkWrap) .                     self newColorPickerButtonMorph}) cellPositioning: #leftCenter)}) .         ((self newGroupbox: 'Values' translated for: (self newLabelGroup: {('Red' translated -> (self newColorComponentFieldMorph: #red)) .                     ('Green' translated -> (self newColorComponentFieldMorph: #green)) .                     ('Blue' translated -> (self newColorComponentFieldMorph: #blue)) .                     ('Hue' translated -> (self newColorComponentFieldMorph: #hue)) .                     ('Saturation' translated -> (self newColorComponentFieldMorph: #saturation)) .                     ('Brightness' translated -> (self newColorComponentFieldMorph: #brightness)) .                     ('Alpha' translated -> (self newColorComponentFieldMorph: #alpha))})) hResizing: #shrinkWrap)}-======-containsPoint: aPoint  ^(lines at: (self lineIndexForPoint: aPoint)) rectangle containsPoint: aPoint-======-removeOtherProperties  otherProperties := nil-======-setMultipleSelection: aBoolean  aBoolean ifTrue: [ self beMultipleSelection ] ifFalse: [ self beSingleSelection ]-======-addColumn: aTreeColumn  self addColumn: aTreeColumn afterIndex: self columns size-======-selectionColor: aColor  selectionColor := aColor-======-display: aBlock  displayBlock := aBlock-======-isFullOnScreen  owner ifNil: [ ^true ].  self visible ifFalse: [ ^true ].  ^owner clearArea containsRect: self fullBounds-======-offerWindowMenu  | aMenu |  aMenu := self buildWindowMenu.  model ifNotNil: [ model addModelItemsToWindowMenu: aMenu ].  aMenu popUpEvent: self currentEvent in: self world-======-initialize  super initialize.  icon := ImageMorph new-======-privateMoveBy: delta  super privateMoveBy: delta-======-icon  ^icon-======-addARowCentered: aCollectionOfMorphs cellInset: cellInsetInteger  ^(self addARow: aCollectionOfMorphs)     hResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #leftCenter;     cellInset: cellInsetInteger-======-menuStringBounds  | stringBounds |  stringBounds := bounds.  self hasIcon ifTrue: [ | iconForm |        iconForm := self iconForm.        stringBounds := stringBounds left: stringBounds left + iconForm width + 2 ].  self hasMarker ifTrue: [ stringBounds := stringBounds left: stringBounds left + self submorphBounds width + 8 ].  ^stringBounds top: (stringBounds top + stringBounds bottom - self fontToUse height) // 2-======-basicMoveShowIndexTo: aNumber  showIndex := aNumber-======-tabs: aCollection  toolbar tabs: aCollection-======-openModal: aSystemWindow  | area mySysWin keyboardFocus |  keyboardFocus := self activeHand keyboardFocus.  mySysWin := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  mySysWin ifNil: [ mySysWin := self ].  mySysWin modalLockTo: aSystemWindow.  area := RealEstateAgent maximumUsableArea.  aSystemWindow extent: aSystemWindow initialExtent.  aSystemWindow position = (0 @ 0) ifTrue: [ aSystemWindow position: self activeHand position - (aSystemWindow extent // 2) ].  aSystemWindow bounds: (aSystemWindow bounds translatedToBeWithin: area).  [ | aWidget |  aWidget := aSystemWindow openAsIs.  self activeHand mouseFocus: aWidget.  [ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] ensure: [ mySysWin modalUnlockFrom: aSystemWindow.        self activeHand newKeyboardFocus: keyboardFocus ].  ^aSystemWindow-======-modalUnlockFrom: aSystemWindow  aSystemWindow removeProperty: #modalOwner.  self removeProperty: #modalChild.  closeBox ifNotNil: [:cl |  cl enabled: (self valueOfProperty: #preModalCloseEnabled ifAbsent: [ true ]) ].  self removeProperty: #preModalCloseEnabled.  self activate-======-defaultBorderWidth  ^0-======-passivate  super passivate.  self nonVisibleTabs do: [:t |  t passivate ]-======-activeDisabledNotOverUpFillStyle: aFillStyle  self stateMap atPath: #(active disabled notOver up) put: aFillStyle.  self changed-======-menuItems  ^submorphs select: [:m |  m isMenuItemMorph ]-======-calendar: aCalendarChooserMorph  calendar := aCalendarChooserMorph-======-updateWidth  self resize-======-doubleClickSelector: aSelector  doubleClickSelector := aSelector-======-apply: delta  | oldBounds |  oldBounds := target bounds.  target bounds: (oldBounds origin corner: oldBounds corner + delta)-======-cellPositioning  ^#center-======-newEditableDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newEditableDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpText-======-collpasedButton  ^IconicButton new     target: self;     actionSelector: #expandAndRefresh;     arguments: {};     labelGraphic: self class unexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-======-recipient  ^recipient-======-newHueSelector: aModel getHue: getSel setHue: setSel help: helpText  ^self theme newHueSelectorIn: self for: aModel getHue: getSel setHue: setSel help: helpText-======-trackDirectionArrow: anEvent with: shaft  anEvent hand obtainHalo: self.  shaft setVertices: {directionArrowAnchor .         anEvent cursorPoint}.  self layoutChanged-======-stateSelector: anObject  stateSelector := anObject-======-newListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpText  ^self theme newListIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpText-======-drawOn: aCanvas  | keyBounds |  keyBounds := self boundsForKeyText: self keyText font: self owner fontToUse.  self owner drawText: keyText on: aCanvas in: keyBounds color: self color-======-userString  ^String streamContents: [:stream |  1 to: self getListSize do: [:i |  (self getListItem: i) submorphs detect: [:morph |  morph userString notNil ] ifFound: [:morph |  stream nextPutAll: morph userString ].              stream cr ] ]-======-triggerOnMouseDown  ^triggerOnMouseDown-======-currentNodelist  ^self nodeList-======-newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText-======-setColorSelector: anObject  setColorSelector := anObject-======-canDrawBorder: aBorderStyle  ^aBorderStyle style == #simple-======-setLastCharacter: source  | aChar chars |  aChar := source asCharacter.  (chars := self getCharacters) size > 0 ifFalse: [ self newContents: (String with: aChar) ] ifTrue: [ chars last = aChar ifFalse: [ self newContents: (String streamContents: [:aStream |  aStream nextPutAll: (chars copyFrom: 1 to: chars size - 1).                          aStream nextPut: aChar ]) ] ]-======-bottomRightColor  ^self color-======-doneWithEdits  hasFocus := false-======-chooseFileName: title extensions: exts path: path preview: preview  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: title extensions: exts path: path preview: preview-======-chooseServiceFrom: aCollection  aCollection size = 1 ifTrue: [ ^aCollection anyOne ].  ^UIManager default chooseFrom: (aCollection collect: [:each |  each label ]) values: aCollection-======-medium  ^27-======-on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel  self model: anObject.  getListSelector := getListSel.  getIndexSelector := getSelectionSel.  setIndexSelector := setSelectionSel.  getMenuSelector := getMenuSel.  keystrokeActionSelector := keyActionSel.  self autoDeselect: true.  self borderWidth: 1.  self updateList.  self selectionIndex: self getCurrentSelectionIndex.  self initForKeystrokes-======-selectedFillStyle  ^self theme buttonSelectedFillStyleFor: self-======-setUp  super setUp.  prototypes     add: (TextAnchor new anchoredMorph: Morph new initialize);     add: (TextAnchor new anchoredMorph: EllipseMorph new initialize)-======-font: anObject  font := anObject-======-beRowSelection  self selectionModeStrategy: (FTRowSelectionModeStrategy table: self)-======-roomToMove  ^self totalSliderArea insetBy: (0 @ 0 extent: self sliderExtent)-======-treeLineWidth  ^treeLineWidth ifNil: [ treeLineWidth := self theme treeLineWidth ]-======-fontName: fontName pointSize: fontSize  | newTextStyle |  newTextStyle := ((TextStyle named: fontName asSymbol) ifNil: [ TextStyle default ]) copy.  newTextStyle ifNil: [ self error: 'font ' , fontName , ' not found.' ].  textStyle := newTextStyle.  text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOfPointSize: fontSize)).  paragraph ifNotNil: [ paragraph textStyle: newTextStyle ]-======-currentNodelist  ^self pager ifNil: [ super nodeList ] ifNotNil: [ self pager currentNodelist ]-======-hasHighlighted  ^self highlightedIndexes notEmpty-======-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self assureExtension.  extension fillStyle ifNil: [ self color: paneColor ].  self borderStyle baseColor: paneColor darker-======-recordDamagedRect: damageRect  damageRecorder ifNotNil: [ damageRecorder recordInvalidRect: damageRect truncated ]-======-initialize  super initialize.  self     style: #inset;     trackPaneColor: true-======-showSelectionFeedback  ^showSelectionFeedback-======-computeFramedColors  | base light dark w hw colorArray param |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  w = 1 ifTrue: [ ^{(base mixed: 0.5 with: light) .         (base mixed: 0.5 with: dark)} ].  colorArray := Array new: w.  hw := w // 2.  0 to: hw - 1 do: [:i |  param := 0.5 + (i asFloat / hw * 0.5).        colorArray at: i + 1 put: (base mixed: param with: light).        colorArray at: w - i put: (base mixed: param with: dark) ].  w odd ifTrue: [ colorArray at: hw + 1 put: base ].  ^colorArray , colorArray-======-newAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel font: aFont help: helpText-======-newLeftButton  ^(ControlButtonMorph on: self getState: nil action: #scrollTabsLeft label: #leftButtonLabel)     getEnabledSelector: #leftButtonEnabled;     hResizing: #rigid;     vResizing: #spaceFill;     cornerStyle: #square;     extent: self controlButtonWidth asPoint-======-rowColorForOdd: oddColor  rowColors at: 2 put: oddColor-======-hasChildren  ^(dataSource childrenBlock value: item) isNotEmpty-======-initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel  container := hostList.  self cellInset: container resizerWidth @ 0.  complexContents := anObject.  complexContents addDependent: self.  isExpanded := complexContents isExpanded.  nextSibling := firstChild := nil.  priorMorph ifNotNil: [ priorMorph nextSibling: self ].  indentLevel := newLevel.  self setBalloonText: complexContents helpText.  self initRow.  complexContents selected ifTrue: [ self selectedWithoutNotifyingComplexContents: true ]-======-selectionChanged  self requestView: (MorphTreeSelectionChanged new selection: self selection)-======-handlerForBlueButtonDown: anEvent  self wantsHaloFromClick ifFalse: [ ^nil ].  self class cycleHalosBothDirections ifTrue: [ anEvent handler ifNil: [ ^self ].        (anEvent handler isKindOf: PasteUpMorph) ifTrue: [ ^self ] ].  anEvent shiftPressed ifFalse: [ ^nil ] ifTrue: [ ^self ]-======-resizeFromMenu  self resizeMorph: ActiveEvent-======-handleStep: anEvent  ^self dispatchDefault: anEvent with: morph-======-separatorSize: anInteger  separatorSize := anInteger-======-yellowButtonActivity: shiftKeyState  (self getMenu: shiftKeyState) ifNotNil: [:menu |  menu setInvokingView: self.        menu popUpEvent: self activeHand lastEvent in: self world.        ^true ].  ^false-======-translateBy: delta  position := position + delta-======-itemsForTest  ^rootClass allSubclasses-======-minExtentFrom: minExtent  | width height widthProp heightProp |  width := minExtent x + leftOffset - rightOffset.  height := minExtent y + topOffset - bottomOffset.  widthProp := rightFraction - leftFraction.  heightProp := bottomFraction - topFraction.  width := widthProp = 0 ifTrue: [ 0 ] ifFalse: [ width / widthProp ].  height := heightProp = 0 ifTrue: [ 0 ] ifFalse: [ height / heightProp ].  ^width truncated @ height truncated-======-maxNodeWidth  ^maxNodeWidth ifNil: [ maxNodeWidth := 0 ]-======-themedFillStyle  ^self theme buttonNormalFillStyleFor: self-======-addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol enablementSelector: enableSymbol argumentList: argList  | item |  item := ToggleMenuItemMorph new     contents: aString;     target: anObject;     selector: aSymbol;     arguments: argList;     getStateSelector: stateSymbol;     enablementSelector: enableSymbol.  ^self addMenuItem: item-======-configureForUnembedding  labelArea owner ifNil: [ self           makeBordered;           initializeLabelArea;           themeChanged;           addGrips ]-======-hasItems  ^submorphs anySatisfy: [:each |  each isMenuItemMorph ]-======-newRow  ^self theme newRowIn: self for: #()-======-autoAccept: aBoolean  autoAccept := aBoolean-======-multipleSelection  ^multipleSelection ifNil: [ multipleSelection := self defaultMultipleSelectionValue ]-======-selectIndexes: index previous: oldSelection  self table selectIndexes: (((oldSelection includes: index) ifTrue: [ oldSelection copyWithout: index ] ifFalse: [ oldSelection ]) copyWithFirst: index)-======-resizeToFit  ^self vResizing == #shrinkWrap-======-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  scrollBar adoptPaneColor: paneColor.  hScrollBar adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self borderWidth > 0 ifTrue: [ self borderStyle: self borderStyleToUse ]-======-passengerAt: rowIndex  ^self elementAt: rowIndex-======-removeCollapseBox  collapseBox ifNotNil: [ collapseBox delete.        collapseBox := nil ]-======-adjustLineIndicesBy: delta  firstCharacterIndex := firstCharacterIndex + delta.  lines do: [:line |  line slide: delta ]-======-setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp  type := aSymbol.  buttons := anInteger.  position := pos.  keyValue := aValue.  source := aHand.  wasHandled := false.  timeStamp := stamp-======-handlesMouseOver: evt  ^true-======-model: aTreeModel  self model ifNotNil: [ self model announcer unsubscribe: self ].  super model: aTreeModel.  self registerRequestHandlers-======-asSpecAdapter  ^MorphicGenericAdapter morph: self-======-toggleSelected  self takeKeyboardFocus.  self enabled ifFalse: [ ^self ].  self model ifNil: [ ^self ].  (self setStateSelector ifNil: [ ^self ]) numArgs = 0 ifTrue: [ self model perform: self setStateSelector ].  self setStateSelector numArgs = 1 ifTrue: [ self model perform: self setStateSelector with: self isSelected not ].  self updateSelection-======-handleMouseOver: anEvent  ^self dispatchDefault: anEvent with: morph-======-cellPositioning  | props |  props := self layoutProperties.  ^props ifNil: [ #center ] ifNotNil: [ props cellPositioning ]-======-menu: menu shifted: b  super menu: menu shifted: b.  menu addLine.  self selectedNode ifNotNil: [:current |  current menu: menu shifted: b ].  ^menu-======-balloonHelpTextForHandle: aHandle  (aHandle eventHandler mouseSelectorsInclude: #doRecolor:with:) ifTrue: [ ^'Change color' ].  (aHandle eventHandler mouseSelectorsInclude: #mouseDownInDimissHandle:with:) ifTrue: [ ^'Remove from screen' translated ].  #(#(#addFullHandles 'More halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#trackCenterOfRotation:with: 'Set center of rotation')) do: [:pair |  (aHandle eventHandler mouseSelectorsInclude: pair first) ifTrue: [ ^pair last ] ].  ^'unknown halo handle' translated-======-initializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigation.  aKMDispatcher attachCategory: #TabMorphsNavigation-======-collapsedFrame  ^collapsedFrame-======-subMenuSelector  ^subMenuSelector-======-show: aString from: startNumber to: endNumber  | progressMorph |  self flag: #pharoFixMe.  self openInWorld.  progressMorph := self addItemShowing: aString from: startNumber to: endNumber.  self     refresh;     reposition.  ^progressMorph-======-resetPotentialDropMorph  potentialDropMorph ifNotNil: [ potentialDropMorph resetHighlightForDrop.        potentialDropMorph := nil ]-======-wrapFlag: aBoolean  aBoolean == wrapFlag ifTrue: [ ^self ].  wrapFlag := aBoolean.  self composeToBounds-======-secondarySelectionColor  ^self theme secondarySelectionColor-======-seeClassSide  -======-addNavigationPane: aNavigPane  pager := aNavigPane.  self addMorph: pager.  pager buildPanel.  self updatePager.  self changed-======-icon: aBlock  self dataSource icon: aBlock-======-parent: aNodeMorph  parent := aNodeMorph-======-popUpForHand: hand in: aWorld  | p |  p := hand position truncated.  ^self popUpAt: p forHand: hand in: aWorld-======-fromArray: anArray  | str |  str := anArray readStream.  #(leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset:) do: [:sel |  str next ifNil: [ ^self ] ifNotNil: [:value |  self perform: sel with: value ] ]-======-doFastWindowReframe: aSideOrCornerName  (FastDraggingFrameMorph forResizing: self fromLocation: aSideOrCornerName) openInWorld-======-baseColor  ^self theme autoMenuColor ifTrue: [ owner color twiceDarker ] ifFalse: [ self theme currentSettings flatMenu ifFalse: [ owner color ] ifTrue: [ owner color twiceDarker ] ]-======-initialize  super initialize.  self     changeProportionalLayout;     bounds: self currentWorld clearArea;     beSticky-======-computeLength  | width size length |  size := tabs size.  size isZero ifTrue: [ ^0 ].  width := self width - self extraSpace + ((size - 1) * self overlap).  length := width / size.  length := length min: 150 * self displayScaleFactor.  length := length max: 33 * self displayScaleFactor.  ^length-======-newPluggableDialogWindow: title for: contentMorph  ^self theme newPluggableDialogWindowIn: self title: title for: contentMorph-======-iconFor: rowIndex  ^(self elementAt: rowIndex) actionOn: self-======-fileNames  ^fileNames-======-initDraggedMorph  draggedMorph ifNotNil: [ ^self ].  draggedMorph := self passenger asDraggableMorph.  self addMorphBack: draggedMorph.  self updateCopyIcon.  self     changed;     fullBounds-======-useSortedTabsBy: sortBlock  toolbar useSortedTabsBy: sortBlock-======-eventListeners  ^eventListeners-======-actualViewee  | aMorph actualViewee |  aMorph := self morphToView ifNil: [ ^nil ].  aMorph isInWorld ifFalse: [ ^nil ].  actualViewee := viewSelector ifNil: [ aMorph ] ifNotNil: [ objectToView perform: viewSelector ].  actualViewee = 0 ifTrue: [ ^nil ].  actualViewee ifNil: [ actualViewee := objectToView ].  (actualViewee isMorph and: [ actualViewee isFlexMorph and: [ actualViewee submorphs size = 1 ] ]) ifTrue: [ actualViewee := actualViewee firstSubmorph ].  ^actualViewee-======-popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem  | tryToPlace selectedOffset |  hand world startSteppingSubmorphsOf: self.  popUpOwner := sourceItem.  self fullBounds.  self updateColor.  selectedOffset := selectedItem ifNil: [ self items ifEmpty: [ 0 @ 0 ] ifNotEmpty: [:col |  col first position - self position ] ] ifNotNil: [ selectedItem position - self position ].  tryToPlace := [:where :mustFit |  | delta |  self position: where - selectedOffset.  delta := self fullBoundsInWorld amountToTranslateWithin: sourceItem worldBounds.  (delta x = 0 or: [ mustFit ]) ifTrue: [ delta = (0 @ 0) ifFalse: [ self position: self position + delta ].        sourceItem world addMorphFront: self.        ^self ] ].  tryToPlace     value: rightOrLeftPoint first value: false;     value: rightOrLeftPoint last - (self width @ 0) value: false;     value: rightOrLeftPoint first value: true-======-modalLockTo: aSystemWindow  self lock-======-displaySelectionBarOnAthensCanvas: anAthensCanvas  | visibleRectangle line |  selectionStart ifNil: [ ^self ].  selectionStop ifNil: [ ^self ].  visibleRectangle := anAthensCanvas clipRect.  selectionStart textLine = selectionStop textLine ifFalse: [ ^self ].  line := selectionStart textLine.  anAthensCanvas setPaint: self selectionBarColor.  anAthensCanvas drawShape: (visibleRectangle left @ line top corner: visibleRectangle right @ line bottom)-======-hResizeScrollbar  | b |  b := self innerBounds.  b := b top: b bottom - self scrollBarThickness.  self vScrollbarShowing ifTrue: [ b := b right: b right - self scrollBarThickness ].  self hScrollbar bounds: b-======-initializeLabel: aString start: startNumber end: endNumber  lock := Semaphore forMutualExclusion.  hasResult := false.  lastRefresh := 0.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #center;     cellInset: 5;     listCentering: #center;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap.  labelMorph := StringMorph contents: aString font: StandardFonts windowTitleFont.  self addMorphBack: labelMorph.  bar := ProgressBarMorph from: startNumber to: endNumber.  self addMorphBack: bar-======-withHLines: aBoolean  withHLines := aBoolean-======-themeChanged  super themeChanged.  tabs do: #themeChanged-======-withText: aStringOrText label: title  self title: title.  self addMorph: (RubScrolledTextMorph new           setText: aStringOrText asString;           yourself) fullFrame: LayoutFrame identity.  self themeChanged-======-invokeModal  ^self invokeModal: self menuKeyboardControl-======-valueParameter: anObject  valueParameter := anObject-======-leftMarginForAlignment: alignmentCode  alignmentCode = RightFlush ifTrue: [ ^self left + paddingWidth ].  alignmentCode = Centered ifTrue: [ ^self left + (paddingWidth // 2) ].  ^self left-======-minWidth  ^self minimumExtent x max: super minWidth-======-fillStyle: anObject  fillStyle := anObject-======-deny: aStringOrText title: aString  ^self theme denyIn: self text: aStringOrText title: aString-======-wantsRoundedCorners  ^color isTransparent not and: [ owner wantsRoundedCorners ]-======-usableArea  ^self viewBox-======-minHeight  | noVPlease noHPlease minH |  noVPlease := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  noHPlease := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  minH := noVPlease ifTrue: [ noHPlease ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness ] ] ifFalse: [ noHPlease ifTrue: [ self scrollBarThickness * 3 ] ifFalse: [ self scrollBarThickness * 4 + 2 ] ].  ^minH max: super minHeight-======-disabledBorderStyle  ^self theme buttonDisabledBorderStyleFor: self-======-resizeCursor  ^Cursor resizeForEdge: #left-======-addPaneVSplitters  | remaining targetRight sameRight sameLeft |  remaining := paneMorphs reject: [:each |  each layoutFrame rightFraction = 1 or: [ each layoutFrame rightFraction = 0 ] ].  [ remaining notEmpty ] whileTrue: [ targetRight := remaining first layoutFrame rightFraction.        sameRight := remaining select: [:each |  each layoutFrame rightFraction = targetRight ].        sameLeft := paneMorphs select: [:each |  each layoutFrame leftFraction = targetRight and: [ each layoutFrame rightFraction ~= targetRight ] ].        remaining := remaining copyWithoutAll: (self addPaneVSplitterBetween: sameRight and: sameLeft) ]-======-world  ^owner ifNotNil: [ owner world ]-======-removeFlexShell  self isFlexed ifTrue: [ self owner removeFlexShell ]-======-activateSubmenu: evt  subMenu ifNil: [ ^false ].  (subMenu fullContainsPoint: evt position) ifFalse: [ ^false ].  subMenu activate: evt.  self removeAlarm: #deselectTimeOut:.  ^true-======-exposedColumnsRange: columnWidths  ^self startColumnIndex isZero ifTrue: [ 1 to: self table numberOfColumns ] ifFalse: [ (1 to: columnWidths size) select: [:idx |  (columnWidths at: idx) > 0 ] ]-======-updateOrderedTasksFrom: tasksThatShouldBeUpdated  | deadTasks |  deadTasks := OrderedCollection new.  self orderedTasks do: [:aTaskbarTask |  tasksThatShouldBeUpdated detect: [:aTaskThatShouldBeUpdated |  aTaskThatShouldBeUpdated morph = aTaskbarTask morph ] ifFound: [:foundTask |  tasksThatShouldBeUpdated remove: foundTask ] ifNone: [ deadTasks add: aTaskbarTask ] ].  (deadTasks isEmpty and: [ tasksThatShouldBeUpdated isEmpty ]) ifTrue: [ ^self ].  self orderedTasks: (self orderedTasks           removeAll: deadTasks;           addAll: tasksThatShouldBeUpdated;           yourself)-======-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-======-scrollValue  ^0 @ self verticalScrollBar value-======-addHandlesTo: aHaloMorph box: box  | onlyThese |  aHaloMorph haloBox: box.  onlyThese := #(addDismissHandle: addMenuHandle: addGrabHandle: addDragHandle: addDupHandle: addHelpHandle: addGrowHandle: addFontSizeHandle: addFontStyleHandle: addFontEmphHandle: addRecolorHandle:).  HaloMorph currentHaloSpecifications do: [:aSpec |  (onlyThese includes: aSpec addHandleSelector) ifTrue: [ aHaloMorph perform: aSpec addHandleSelector with: aSpec ] ].  aHaloMorph innerTarget addOptionalHandlesTo: aHaloMorph box: box-======-releaseCachedState  colors := nil.  lineStyles := nil-======-keyUp: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #keyUp from: sourceMorph-======-filter  self subclassResponsibility-======-addMorph: aMorph fullFrame: aLayoutFrame  aMorph layoutFrame: aLayoutFrame asLayoutFrame.  aMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorph: aMorph-======-containsPoint: aPoint  ^target ifNil: [ super containsPoint: aPoint ] ifNotNil: [ false ]-======-newGroupbox: aString forAll: controls  ^self theme newGroupboxIn: self label: aString forAll: controls-======-pressedFillStyle  ^self theme morphTreeSplitterPressedFillStyleFor: self-======-setRotationCenterFrom: aPoint  self setProperty: #referencePosition toValue: aPoint-======-eventListeners: anArrayOrNil  eventListeners := anArrayOrNil-======-actionSelector: aSymbolOrString  (nil = aSymbolOrString or: [ 'nil' = aSymbolOrString or: [ aSymbolOrString isEmpty ] ]) ifTrue: [ ^actionSelector := nil ].  actionSelector := aSymbolOrString asSymbol-======-changeMaxCellSize: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self maxCellSize: (newPoint - evt cursorPoint) asIntegerPoint ].  evt hand attachMorph: handle.  handle startStepping-======-clyAddEmphasis: aTextEmphasis  self emphasis: (emphasis bitOr: aTextEmphasis emphasisCode)-======-initializeShortcuts: aKMDispatcher  aKMDispatcher attachCategory: #MorphFocusCtrlNavigation-======-findReplaceDialog  ^EditorFindReplaceDialogWindow singleton-======-veryDeepCopyWith: deepCopier  ^self-======-newSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText-======-animateRestore  | expandedRect restoredRect rects steps |  expandedRect := self bounds.  restoredRect := self unexpandedFrame.  steps := self theme numberOfStepsForAnimations.  rects := ((steps - 1) / steps to: 0 by: -1 / steps) collect: [:x |  restoredRect interpolateTo: expandedRect at: ((20 raisedTo: x) - 1) / 19 ].  self fastAnimateRectangles: rects-======-asAthensShapeOn: anAthensCanvas  | halfWidth halfHeight |  self bounds area > 0 ifFalse: [ ^self ].  halfWidth := self bounds width / 2 asFloat.  halfHeight := self bounds height / 2 asFloat.  ^anAthensCanvas createPath: [:builder |  builder           absolute;           moveTo: self bounds center;           relative;           moveTo: halfWidth negated @ 0;           curveVia: 0 @ (halfHeight negated * 0.55) and: (0.45 * halfWidth) @ halfHeight negated to: halfWidth @ halfHeight negated;           curveVia: (halfWidth * 0.55) @ 0 and: halfWidth @ (0.45 * halfHeight) to: halfWidth @ halfHeight;           curveVia: 0 @ (halfHeight * 0.55) and: (0.45 * halfWidth negated) @ halfHeight to: halfWidth negated @ halfHeight;           curveVia: (halfWidth negated * 0.55) @ 0 and: halfWidth negated @ (halfHeight negated * 0.45) to: halfWidth negated @ halfHeight negated ]-======-nextCell  ^nextCell-======-veryDeepInner: deepCopier  super veryDeepInner: deepCopier.  activatorDockingBar := activatorDockingBar-======-chooseForSaveFileReference: title extensions: exts path: path preview: preview  ^self theme chooseForSaveFileReferenceIn: self title: title extensions: exts path: path preview: preview-======-initialize  expanded := false.  depth := 0.  children := #()-======-topRight: aPoint  self position: (aPoint x - bounds width) @ aPoint y-======-alignBottomEdges  | maxBottom |  maxBottom := (selectedItems collect: [:itm |  itm bottom ]) max.  selectedItems do: [:itm |  itm bottom: maxBottom ].  self changed-======-treeRenderOn: aCanvas bounds: drawBounds color: drawColor font: aFont from: aMorph  self bounds: drawBounds.  aMorph addMorphBack: self-======-string  ^string-======-setColorSelector  ^setColorSelector-======-originalCenter: anObject  originalCenter := anObject-======-selectedWithoutNotifyingComplexContents: aBoolean  aBoolean ifFalse: [ ^self ].  container listManager silentlySetSelectedMorph: self.  selected := aBoolean-======-undoRedoExchange: aninterval with: anotherInterval  self handleEdit: [ self editor undoRedoExchange: aninterval with: anotherInterval ]-======-defaultBorderWidth  ^self theme borderWidth-======-navigationKey: anEvent  self isMultipleSelection ifTrue: [ | keyString |        keyString := anEvent keyString.        keyString = '<Cmd-a>' ifTrue: [ self selectAll.              ^true ].        keyString = '<Cmd-A>' ifTrue: [ self deselectAll.              ^true ] ].  ^super navigationKey: anEvent-======-asMorph  ^self-======-isUp  ^direction = Character arrowUp-======-mouseUp: event  self storeValue: nil.  super mouseUp: event-======-isMenuMorph  ^false-======-testMouseEnterEventIsNotDuplicated  | mockObject window evt |  mockObject := MockObjectForEventTests new.  [ window := mockObject stringMorph openInWindow.  evt := MouseButtonEvent new setType: nil position: mockObject stringMorph center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  self assert: mockObject counter equals: 0.  mockObject stringMorph handleMouseEnter: evt.  self assert: mockObject counter equals: 1 ] ensure: [ window ifNotNil: #close ]-======-mouseEnter: evt  self color: (selectionColor isTransparent ifTrue: [ self mouseOverColor ] ifFalse: [ self mouseOverColor mixed: 0.5 with: selectionColor ])-======-mouseUpInSlider: event  sliderShadow hide.  (slider containsPoint: event position) ifTrue: [ slider           fillStyle: self mouseOverThumbFillStyle;           borderStyle: self mouseOverThumbBorderStyle ] ifFalse: [ self mouseLeaveThumb: event ].  slider changed-======-on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel  self on: anObject getState: getStateSel action: actionSel label: labelSel icon: nil menu: menuSel-======-indentationLevel: anInteger  indent := anInteger-======-lastKeystrokeTime  ^lastKeystrokeTime-======-paneColor  ^self paneColorOrNil ifNil: [ self owner ifNil: [ Color transparent ] ifNotNil: [ self owner color ] ]-======-rowHeight  ^rowHeight ifNil: [ rowHeight := self class defaultRowHeight ]-======-selectableIndexAfter: anIndex  ^self subclassResponsibility-======-lastSelection: anObject  lastSelection := anObject-======-drawOnAthensCanvas: anAthensCanvas  | border ellipse |  self bounds area > 0 ifFalse: [ ^self ].  border := self borderStyle.  ellipse := self asAthensShapeOn: anAthensCanvas.  anAthensCanvas setPaint: self fillStyle.  anAthensCanvas setShape: ellipse.  anAthensCanvas draw.  (anAthensCanvas setStrokePaint: border color) width: border width.  anAthensCanvas draw-======-orientation  ^orientation-======-selectToMe  self triggerEvent: #tabSelectTo with: self-======-bottomArrow  ^BottomArrow-======-buildPanel  | widgets firstPageButton previousButton wid nextButton lastPageButton pageSizeEditor searchEditor |  self removeAllMorphs.  pageSize ifNil: [ ^self ].  self nodeList ifNil: [ ^self ].  widgets := OrderedCollection new.  self nodeList size > pageSize ifTrue: [ firstPageButton := self buttonLabel: self class smallToLeftEndIcon actionSelector: #currentPage: arguments: {1} getEnabled: #notOnFirstPage help: 'First page'.        widgets add: firstPageButton.        previousButton := self buttonLabel: self class smallToLeftIcon actionSelector: #previousPage arguments: {} getEnabled: #notOnFirstPage help: 'Previous page'.        widgets add: previousButton.        wid := self textEntryLabel: '' get: #currentPageToString set: #currentPageInput: help: 'Index of page to view' translated class: String.        wid hResizing: #rigid.        wid width: (self preferedFont widthOfString: '1000000').        widgets add: wid.        widgets add: (self buttonLabel: self class smallDiezeIcon actionSelector: #choosePage arguments: {} getEnabled: nil help: 'Choose page').        nextButton := self buttonLabel: self class smallToRightIcon actionSelector: #nextPage arguments: {} getEnabled: #notOnLastPage help: 'Next page'.        widgets add: nextButton.        lastPageButton := self buttonLabel: self class smallToRightEndIcon actionSelector: #currentPage: arguments: {self lastPage} getEnabled: #notOnLastPage help: 'Last page'.        widgets add: lastPageButton.        widgets add: (self spacer: 10) ].  widgets add: (LabelMorph contents: 'Page size: ' font: self preferedFont).  pageSizeEditor := self textEntryLabel: 'Page size' get: #pageSizeToString set: #pageSizeFromString: help: 'Change the page size or the number of pages if the input begins with "/"' translated class: String.  pageSizeEditor hResizing: #rigid.  pageSizeEditor width: (self preferedFont widthOfString: '1000000').  widgets add: pageSizeEditor.  self withSearch ifTrue: [ searchEditor := self textEntryLabel: '' get: #pageSearchText set: #pageSearchText: help: 'Enter a text correspondig to your search' translated class: String.        searchEditor ghostText: 'Searched text'.        widgets add: searchEditor ].  self addAllMorphs: widgets.  self updateContents-======-testSelectableIndexAbove  self subclassResponsibility-======-basicSelectedColor: anObject  selectedColor := anObject.  self     changed: #selectedColor;     changed: #red;     changed: #green;     changed: #blue;     changed: #hue;     changed: #saturation;     changed: #brightness;     changed: #alpha.  self announcer announce: (ColorChanged to: selectedColor)-======-autoAccept: anObject  autoAccept := anObject-======-newAlphaImage: aForm help: helpText  ^self theme newAlphaImageIn: self image: aForm help: helpText-======-proceed: aStringOrText  ^self proceed: aStringOrText title: 'Proceed' translated-======-extent: aPoint  | old |  old := self extent.  super extent: aPoint.  self extent = old ifTrue: [ ^self ].  self updateColor-======-findDeeplyA: aClass  ^(self allMorphs copyWithout: self) detect: [:p |  p isKindOf: aClass ] ifNone: [ nil ]-======-setStrategy  table beCellSelection-======-indentingItemClass  ^LazyMorphTreeNodeMorph-======-left  ^textMorph owner left-======-color: aColor  super color: aColor beOpaque.  self fillStyle: self defaultFillStyle-======-drawOn: aCanvas  | time |  time := Time millisecondClockValue.  self drawMeOn: aCanvas.  drawTime := Time millisecondClockValue - time.  drawTime < 0 ifTrue: [ drawTime := nil ]-======-hasFocus  ^hasFocus ifNil: [ false ]-======-itemStringGetter: aValuable  self columns first itemStringGetter: aValuable-======-fillStyleToUse  ^self isSelected ifTrue: [ self selectedFillStyle ] ifFalse: [ self normalFillStyle ]-======-openOn: aClass  rootClass := aClass.  (self defaultTreeMorph buildContents embeddedInMorphicWindowLabeled: 'test') openInWorld-======-openDialogOn: aClass  rootClass := aClass.  ^self openDialogWindowIn: self currentWorld title: 'All Object subclasses'-======-deselect  editor ifNotNil: [ editor deselect ]-======-allEnabledSiblingItems  ^self allSiblingItems select: [:item |  item isEnabled ]-======-setSelectedSilently: aBoolean  selected := aBoolean.  self complexContents selected: aBoolean-======-beUnsticky  extension ifNotNil: [ extension sticky: false ]-======-announcer  WorldAnnouncer ifNil: [ WorldAnnouncer := Announcer new ].  ^WorldAnnouncer-======-needSpaceForActions  | tab |  tab := self selectedTab.  tab ifNil: [ ^false ].  ^self selectedTab hasMenu or: [ self selectedTab hasActions ]-======-isSelfEvaluating  ^false-======-indentBy: aNumber  indentation := aNumber + self cellInset-======-acceptDroppingMorph: aMorph event: evt  | item dropTarget |  dropItemSelector ifNil: [ model acceptDroppingMorph: aMorph event: evt inMorph: self ] ifNotNil: [ item := aMorph passenger.        dropTarget := (self itemFromPoint: evt position) withoutListWrapper.        model perform: dropItemSelector with: item with: dropTarget ].  evt hand releaseMouseFocus: self.  Cursor normal show-======-halo  ^self valueOfProperty: #halo-======-playMaximizeSound  self theme windowMaximizeSound play-======-drawOn: aCanvas  super drawOn: aCanvas.  self drawGridOn: aCanvas.  self drawBackgroundSketchOn: aCanvas-======-openItemPath: anArray  | found |  anArray isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ (each complexContents withoutListWrapper = anArray first or: [ anArray first isNil ]) ifTrue: [ found := each ] ] ].  found ifNotNil: [ found isExpanded ifFalse: [ found toggleExpandedState ].        found changed.        anArray size = 1 ifTrue: [ ^container listManager setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild openItemPath: anArray allButFirst ] ].  ^self-======-minExtent  ^self theme tabSelectorMorphMinExtentFor: self-======-transferHalo: event from: formerHaloOwner  | localEvt w target |  self flag: #workAround.  (formerHaloOwner == self and: [ self isRenderer and: [ self wantsHaloFromClick not ] ]) ifTrue: [ event shiftPressed ifTrue: [ target := owner.              localEvt := event transformedBy: (self transformedFrom: owner) ] ifFalse: [ target := self renderedMorph.              localEvt := event transformedBy: (target transformedFrom: self) ].        ^target transferHalo: localEvt from: target ].  (self isWorldMorph and: [ owner isNil ]) ifFalse: [ (self wantsHaloFromClick and: [ formerHaloOwner ~~ self ]) ifTrue: [ ^self addHalo: event from: formerHaloOwner ] ].  event shiftPressed ifTrue: [ owner ifNotNil: [ ^owner transferHalo: event from: formerHaloOwner ].        formerHaloOwner removeHalo.        ^self processEvent: event copy resetHandlerFields ].  self submorphsDo: [:m |  localEvt := event transformedBy: (m transformedFrom: self).        (m fullContainsPoint: localEvt position) ifTrue: [ ^m transferHalo: event from: formerHaloOwner ] ].  formerHaloOwner removeHalo.  (w := self world) ifNil: [ ^self ].  localEvt := event transformedBy: (self transformedFrom: w) inverseTransformation.  ^w processEvent: localEvt resetHandlerFields-======-invokeModal: allowKeyboardControl  ^self invokeModalAt: ActiveHand position in: self currentWorld allowKeyboard: allowKeyboardControl-======-setSelectionIndex: idx  | theMorph index |  idx ifNil: [ ^self ].  index := idx min: scroller submorphs size max: 0.  theMorph := index = 0 ifTrue: [ nil ] ifFalse: [ scroller submorphs at: index ].  self setSelectedMorph: theMorph-======-inToggleArea: aPoint  ^self sensitiveToggleRectangle containsPoint: aPoint-======-onImage  ^image-======-initialize  isExpanded := false.  recentlyChanged := false-======-textColor: aColor  textColor := aColor-======-fontNumber  ^fontNumber-======-deleteBalloonTarget: aMorph  self handsDo: [:h |  h deleteBalloonTarget: aMorph ]-======-expandAll: aMorph  | subs |  self expandAllSilently: aMorph.  aMorph updateChildrenRecursively.  subs := self scroller submorphs.  1 to: subs size do: [:pos |  (subs at: pos) index: pos ].  self innerWidgetChanged-======-initializeClass: aClass  self initialize.  self elements: ((aClass selectors sorted: [:a :b |  a < b ]) collect: [:each |  FTExampleMethodModel method: aClass >> each ])-======-nextMorphAcrossInWindow  ^self submorphAfter ifNil: [ (self owner ifNil: [ ^self ]) nextMorphAcrossInWindow ]-======-privateMoveBy: delta  | fill |  super privateMoveBy: delta.  fill := self barFillStyle.  fill isOrientedFill ifTrue: [ fill origin: fill origin + delta ]-======-gradientRamp  ^gradientRamp ifNil: [ {(0.0 -> originalColor muchLighter) .         (1.0 -> originalColor twiceDarker)} ]-======-lastSelectedNode  ^self lastSelectedNodePath ifNotNil: [:path |  path ifEmpty: [ nil ] ifNotEmpty: [:p |  path last ] ]-======-resetHScrollRange  hScrollRangeCache := nil.  self deriveHScrollRange-======-includesHandle: aMorph  handles ifNil: [ ^false ].  ^handles includes: aMorph-======-noteNewOwner: aMorph  -======-delete  self removeHalo.  self activeHand     releaseKeyboardFocus: self;     releaseMouseFocus: self.  owner ifNotNil: [ self privateDelete.        self announceDeleted ]-======-spSetModal: aSystemWindow  | area mySysWin keyboardFocus |  keyboardFocus := self activeHand keyboardFocus.  mySysWin := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  mySysWin ifNil: [ mySysWin := self ].  mySysWin modalLockTo: aSystemWindow.  area := RealEstateAgent maximumUsableArea.  aSystemWindow extent: aSystemWindow initialExtent.  aSystemWindow position = (0 @ 0) ifTrue: [ aSystemWindow position: self activeHand position - (aSystemWindow extent // 2) ].  aSystemWindow bounds: (aSystemWindow bounds translatedToBeWithin: area).  [ | aWidget |  aWidget := aSystemWindow.  [ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] ensure: [ mySysWin modalUnlockFrom: aSystemWindow.        self activeHand newKeyboardFocus: keyboardFocus ].  ^aSystemWindow-======-label  ^label-======-drawOn: aCanvas  super drawOn: aCanvas.  topSeparator ifTrue: [ aCanvas line: bounds topLeft to: bounds topRight color: self seperatorColor ]-======-computeCellSizes: aMorph in: newBounds horizontal: aBool  | cells block minSize maxSize maxCell |  cells := (Array new: aMorph submorphCount) writeStream.  minSize := properties minCellSize asPoint.  maxSize := properties maxCellSize asPoint.  aBool ifTrue: [ minSize := minSize transposed.        maxSize := maxSize transposed ].  maxCell := 0 @ 0.  block := [:m |  | cell size |  m disableTableLayout ifFalse: [ size := m minExtent asIntegerPoint.        cell := LayoutCell new target: m.        aBool ifTrue: [ cell hSpaceFill: m hResizing == #spaceFill.              cell vSpaceFill: m vResizing == #spaceFill ] ifFalse: [ cell hSpaceFill: m vResizing == #spaceFill.              cell vSpaceFill: m hResizing == #spaceFill.              size := size transposed ].        size := (size min: maxSize) max: minSize.        cell cellSize: size.        maxCell := maxCell max: size.        cells nextPut: cell ] ].  properties reverseTableCells ifTrue: [ aMorph submorphsReverseDo: block ] ifFalse: [ aMorph submorphsDo: block ].  ^maxCell -> cells contents-======-setContainer: newContainer  self changed.  container := newContainer.  self releaseParagraph-======-wantsColumnBreaks  ^wantsColumnBreaks-======-addLine  submorphs isEmpty ifTrue: [ ^self ].  (self lastSubmorph isKindOf: DockingBarMenuLineMorph) ifFalse: [ self addMorphBack: DockingBarMenuLineMorph new ]-======-transformedBy: aMorphicTransform  ^self shallowCopy transformBy: aMorphicTransform-======-enabled  ^enabled ifNil: [ enabled := true ]-======-terminateUIProcess  UIProcess     suspend;     terminate.  UIProcess := nil-======-checkSplitters  (self submorphsSatisfying: [:e |  e isKindOf: ProportionalSplitterMorph ]) do: [:splitter |  self checkMorphsLeftOrTopFrom: splitter.        self checkMorphsRightOrBottomFrom: splitter ]-======-setSelectionListSelector: aSelector  setSelectionListSelector := aSelector-======-startDrag: event  | passengers transferMorph |  event hand hasSubmorphs ifTrue: [ ^self ].  self dragEnabled ifFalse: [ ^self ].  event hand anyButtonPressed ifFalse: [ ^self ].  self hasSelection ifFalse: [ ^self ].  passengers := self selectedIndexes collect: [:each |  self dataSource passengerAt: each ].  transferMorph := self dataSource transferFor: passengers from: self.  transferMorph align: transferMorph draggedMorph topLeft with: event position.  transferMorph dragTransferType: self dataSource dragTransferType.  event hand grabMorph: transferMorph-======-expandAllFromNode: aNode  self requestView: (MorphTreeChangeRequest expandAllFromNode: aNode)-======-initializeContainer  container := self defaultContainer.  self addMorph: container-======-leftFraction: aNumber  leftFraction := aNumber-======-initialDataSource: aDataSource  initialDataSource := aDataSource-======-isFirstItem  ^owner submorphs first == self-======-selectMatch: aString  | firstMatch |  self items do: [:item |  | match |        match := aString isEmpty or: [ item contents asString asLowercase includesSubstring: aString ].        item isEnabled: match.        (match and: [ firstMatch isNil ]) ifTrue: [ firstMatch := item ] ].  ^firstMatch-======-result  ^result-======-newImageFor: aModel get: getSel help: helpText  ^self theme newImageIn: self for: aModel get: getSel help: helpText-======-pressed: anIndex  self model pressed: anIndex-======-showWidget  self initializeMorph.  table     addMorph: field;     resizeAllSubviews-======-newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText-======-deactivate  InputEventSensor default shutDown.  Display shutDown.  InputEventFetcher default shutDown-======-testLeftTopAligned  | lf rectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightFraction: 0 offset: 60;     bottomFraction: 0 offset: 25;     yourself.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 110 @ 35) equals: rectangle-======-removeAlarm: aSelector for: aTarget  worldState removeAlarm: aSelector for: aTarget-======-deselectTimeOut: evt  owner selectedItem == self ifTrue: [ evt hand releaseMouseFocus: owner.        owner selectItem: nil event: evt ]-======-showIconTreshold  ^(closeIcon visible ifTrue: [ 54 ] ifFalse: [ 40 ]) * self displayScaleFactor-======-chooseDirectory: title  ^self chooseDirectory: title path: nil-======-mouseDown: anEvent  self enabled ifTrue: [ self           scrollPoint: anEvent;           computeSlider ].  super mouseDown: anEvent.  self enabled ifFalse: [ ^self ].  anEvent hand newMouseFocus: slider event: anEvent.  slider     mouseEnter: anEvent copy;     mouseDown: anEvent copy-======-hasSubMenu: aMenuMorph  ^submorphs anySatisfy: [:m |  m isMenuItemMorph and: (m hasSubMenu: aMenuMorph) ]-======-containsPoint: aPoint  | w |  ^(super containsPoint: aPoint) and: [ w := SystemWindow borderWidth.        ((self bounds translateBy: w @ w negated) containsPoint: aPoint) not ]-======-updateContents  target ifNotNil: [ contents := target perform: nameSelector ]-======-characterBlockForIndex: index  | line |  line := lines at: (self lineIndexForCharacter: index).  ^(CharacterBlockScanner new text: text textStyle: textStyle) characterBlockAtPoint: nil index: ((index max: line first) min: text size + 1) in: line-======-type: aType extension: anExtension action: anAction  action := anAction.  type := aType.  extension := anExtension-======-layoutProperties: newProperties  self layoutProperties == newProperties ifTrue: [ ^self ].  self assureExtension layoutProperties: newProperties-======-focusChanged  | rects fm |  fm := self focusIndicatorMorph.  fm fillStyle isTransparent ifTrue: [ fm borderWidth > 0 ifTrue: [ rects := fm bounds areasOutside: (fm bounds insetBy: fm borderWidth).              rects do: [:r |  self invalidRect: r ] ] ] ifFalse: [ self invalidRect: fm bounds ]-======-isFirstColumn  ^container columns first = self-======-initialize  super initialize.  vertices := Array with: 5 @ 0 with: 20 @ 10 with: 0 @ 20.  closed := true.  smoothCurve := false.  arrows := #none.  self computeBounds.  self beSmoothCurve.  self diamondOval-======-dropEnabled  ^(self valueOfProperty: #dropEnabled) == true-======-onImageSelector: anObject  onImageSelector := anObject-======-defersHaloOnClickTo: aSubMorph  ^true-======-moveSelectionDown: anInteger event: anEvent  | allEnabledSiblingItems index |  allEnabledSiblingItems := self allEnabledSiblingItems.  index := (allEnabledSiblingItems indexOf: selectedItem ifAbsent: [ 0 + (anInteger negative ifTrue: [ 1 ] ifFalse: [ 0 ]) ]) + anInteger.  allEnabledSiblingItems do: [:unused |  | m |        m := allEnabledSiblingItems atWrap: index.        (m isMenuItemMorph and: [ m isEnabled ]) ifTrue: [ m owner = self owner ifFalse: [ anEvent hand newKeyboardFocus: m owner ].              ^m owner selectItem: m event: anEvent ].        index := index + anInteger sign ].  ^self selectItem: nil event: anEvent-======-font  ^self listMorph font-======-testSelectLast  self subclassResponsibility-======-leftButtonEnabled  ^self wrapScrolling or: [ self visibleTabRange first > 1 ]-======-getRawLabel  | contentsFit |  contentsFit := label shallowCopy fitContents.  contentsFit extent: (label extent x min: contentsFit extent x) @ contentsFit extent y.  ^contentsFit-======-doDebug: evt with: menuHandle  | menu |  self world displayWorld.  evt shiftPressed ifTrue: [ self delete.        ^innerTarget inspectInMorphic: evt ].  menu := innerTarget buildDebugMenu: evt hand.  menu     buildTitle: [:menuTitle |  menuTitle           title: (innerTarget externalName asString truncateWithElipsisTo: 40);           withCloseBox;           withPinBox ];     popUpEvent: evt in: self world-======-moveSelectionDown: direction event: evt  | index |  index := (submorphs indexOf: selectedItem ifAbsent: [ 1 - direction ]) + direction.  submorphs do: [:unused |  | m |        m := submorphs atWrap: index.        (m isMenuItemMorph and: [ m isEnabled ]) ifTrue: [ ^self selectItem: m event: evt ].        index := index + direction sign ].  ^self selectItem: nil event: evt-======-mouseLeaveDragging: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseLeaveDragging from: sourceMorph-======-bestSegments  ^self honeIn: self calcEnoughSegments-======-findSubmorphBinary: aBlock  ^submorphs findBinary: aBlock do: [:found |  found ] ifNone: [:a :b |   ]-======-hasExtraSelection  ^extraSelectionBlocks isEmptyOrNil not-======-internalSpaces: spacesInteger paddingWidth: padWidthInteger  internalSpaces := spacesInteger.  paddingWidth := padWidthInteger-======-extent: p  p x > p y ifTrue: [ super extent: (p max: (42 @ 8) scaledByDisplayScaleFactor) ] ifFalse: [ super extent: (p max: (8 @ 42) scaledByDisplayScaleFactor) ]-======-abort: aStringOrText  ^self abort: aStringOrText title: 'Error' translated-======-prepareForRotating  ^self addFlexShell-======-wantsDropSelector: aSelector  wantsDropSelector := aSelector-======-model  ^self complexContents-======-computeBounds  | oldBounds delta excludeHandles |  vertices ifNil: [ ^self ].  self changed.  oldBounds := bounds.  self releaseCachedState.  bounds := self curveBounds expanded.  self arrowForms do: [:f |  bounds := bounds merge: (f offset extent: f extent) ].  handles ifNotNil: [ self updateHandles ].  (oldBounds notNil and: [ (delta := bounds origin - oldBounds origin) ~= (0 @ 0) ]) ifTrue: [ excludeHandles := IdentitySet new.        handles ifNotNil: [ excludeHandles addAll: handles ].        self submorphsDo: [:each |  (excludeHandles includes: each) ifFalse: [ each position: each position + delta ] ] ].  self layoutChanged.  self changed-======-hash  ^self morph hash bitXor: (self state hash bitXor: (self icon hash bitXor: self label hash))-======-newExpander: aString  ^self theme newExpanderIn: self label: aString forAll: #()-======-rotationDegrees: degrees  self adjustAfter: [ self angle: degrees degreesToRadians negated ]-======-childrenItems  ^Array new-======-addMorph: aMorph frame: rectangle  ^self addMorph: aMorph fullFrame: rectangle-======-deselectAll  | selHolder |  self allNodeMorphs isEmpty ifTrue: [ ^self ].  self emptySelection.  self selectionUpdateFromViewWhile: [ selHolder := self newSelectionHolderWithNodePath: nil.        self listModel selection: selHolder ]-======-newMenuFor: aModel  ^self theme newMenuIn: self for: aModel-======-setSelectedMorph: aMorph  selectedWrapper := aMorph complexContents.  self selection: selectedWrapper.  setSelectionSelector ifNotNil: [ model perform: setSelectionSelector with: (selectedWrapper ifNotNil: [ selectedWrapper item ]) ]-======-drawArrowOn: aCanvas at: endPoint from: priorPoint  | pts spec wingBase |  pts := self arrowBoundsAt: endPoint from: priorPoint.  wingBase := pts size = 4 ifTrue: [ pts third ] ifFalse: [ (pts copyFrom: 2 to: 3) average ].  spec := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  spec x sign = spec y sign ifTrue: [ aCanvas drawPolygon: pts fillStyle: borderColor ] ifFalse: [ aCanvas drawPolygon: pts fillStyle: Color transparent borderWidth: (borderWidth + 1) // 2 borderColor: borderColor ].  ^wingBase-======-adjacentTo  ^{(self bounds topRight + (5 @ 0)) .   (self bounds topLeft + (2 @ 0))}-======-testIsBeforeColumn  self subclassResponsibility-======-replaceFrom: start to: stop with: aText displaying: displayBoolean  text replaceFrom: start to: stop with: aText.  self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop - start + 1)-======-initForKeystrokes  canMove := true.  lastKeystrokeTime := 0.  lastKeystrokes := ''-======-defaultTarget: anObject  defaultTarget := anObject-======-secondName: aString  self item secondName: aString.  self changed: #secondName-======-pageSizeToString  ^self pageSize asString-======-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-======-debugPrint  ^(WriteStream on: (String new: 10))     print: self class;     nextPutAll: ' (';     print: self date;     nextPutAll: ' - ';     print: self bounds;     nextPut: $);     contents-======-handle: dropStream in: pasteUp dropEvent: anEvent  ^action cull: dropStream cull: pasteUp cull: anEvent-======-gridModulus  ^self gridSpec extent-======-listMorphClass  ^MulticolumnLazyListMorph-======-commentText  ^(self theme newTextIn: self currentWorld text: self item comment)     unlock;     wrapFlag: true;     yourself-======-vScrollBarMenuButtonPressed: event  ^self scrollBarMenuButtonPressed: event-======-handlesMouseOver: evt  ^false-======-isSelected  self model ifNil: [ ^false ].  ^self model perform: (self getStateSelector ifNil: [ ^false ])-======-taskbarThumbnailExtent  ^self isMinimized ifTrue: [ self fullFrame extent min: self defaultTaskbarThumbnailExtent ] ifFalse: [ super taskbarThumbnailExtent ]-======-extent: aPoint  | size oldRotationCenter |  oldRotationCenter := self rotationCenter.  size := aPoint x min: aPoint y.  super extent: size @ size.  self rotationCenter: oldRotationCenter-======-startPoint  ^startPoint-======-prepareForScaling  ^self-======-releaseCachedState  super releaseCachedState.  filledForm := nil.  arrowForms := nil.  borderForm := nil.  curveState := nil.  (self hasProperty: #flex) ifTrue: [ self removeProperty: #flex ]-======-indentationOfLineIndex: lineIndex ifBlank: aBlock  | arrayIndex first last crlf |  crlf := CharacterSet crlf.  arrayIndex := lineIndex.  [ first := (lines at: arrayIndex) first.  first > 1 and: [ crlf includes: (text string at: first - 1) ] ] whileTrue: [ arrayIndex := arrayIndex - 1 ].  last := (lines at: arrayIndex) last.  ^(text string copyFrom: first to: last) indentationIfBlank: aBlock-======-chooseDirectory: title  ^self chooseDirectory: title path: nil-======-selectedLocation  | b c x y |  b := self innerBounds.  c := self selectedColor.  x := c saturation * (b width - 1).  y := (1 - c brightness) * (b height - 1).  ^x truncated @ y truncated + b topLeft-======-grabMorph: aMorph from: formerOwner  | grabbed offset targetPoint grabTransform fullTransform |  self releaseMouseFocus.  grabbed := aMorph.  aMorph keepsTransform ifTrue: [ grabTransform := fullTransform := IdentityTransform new ] ifFalse: [ grabTransform := formerOwner ifNil: [ IdentityTransform new ] ifNotNil: [ formerOwner grabTransform ].        fullTransform := formerOwner ifNil: [ IdentityTransform new ] ifNotNil: [ formerOwner transformFrom: owner ] ].  targetPoint := fullTransform globalPointToLocal: self position.  offset := targetPoint - (grabTransform globalPointToLocal: self position).  grabbed := grabbed transformedBy: grabTransform.  grabbed == aMorph ifFalse: [ grabbed setProperty: #addedFlexAtGrab toValue: true ].  grabbed position: grabbed position - offset asIntegerPoint.  targetOffset := grabbed position - self position.  self addMorphBack: grabbed.  grabbed justGrabbedFrom: formerOwner-======-firstName  ^firstName-======-drawBackgroundForRow: row on: aCanvas color: aColor  | frame |  frame := self selectionFrameForRow: row.  aCanvas fillRectangle: frame color: aColor-======-newPosition: anObject  newPosition := anObject-======-setLayoutSizingFor: aSymbol  (aSymbol = #left or: [ aSymbol = #right ]) ifTrue: [ self           hResizing: #rigid;           vResizing: #spaceFill ].  (aSymbol = #top or: [ aSymbol = #bottom ]) ifTrue: [ self           hResizing: #spaceFill;           vResizing: #rigid ]-======-getEnabledSelector  ^getEnabledSelector-======-addScaleHandle: haloSpec  target shouldFlex ifTrue: [ (self addHandle: haloSpec on: #mouseDown send: #startScale:with: to: self) on: #mouseMove send: #doScale:with: to: self ]-======-initializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigation-======-keyString  ^String streamContents: [:s |  self printKeyStringOn: s ]-======-drawKeyTextOnAthenCanvas: aCanvas  self keyText ifNil: [ ^self ].  (ToggleMenuItemShortcut owner: self keyText: self keyText) drawOnAthensCanvas: aCanvas-======-hasDropShadowString  ^self hasDropShadow -> 'show shadow' translated-======-playCloseSound  self theme windowCloseSound play-======-monthNameFont  | font boldItalic |  font := LogicalFont familyName: 'Bitmap DejaVu Sans' pointSize: 12.  boldItalic := TextEmphasis italic emphasisCode | TextEmphasis bold emphasisCode.  ^font emphasis: boldItalic-======-indicateModalChild  (self isMinimized and: [ self isTaskbarPresent ]) ifTrue: [ self worldTaskbar ifNotNil: [:tb |  tb indicateModalChildForMorph: self ] ] ifFalse: [ self flash ]-======-withAllOwners  ^Array streamContents: [:strm |  self withAllOwnersDo: [:m |  strm nextPut: m ] ]-======-expandNodePath: aNodePath  self requestView: (MorphTreeChangeRequest expandNodePath: aNodePath)-======-submorphsSatisfying: aBlock  ^submorphs select: [:m |  (aBlock value: m) == true ]-======-dragVertex: ix event: evt fromHandle: handle  | p |  p := evt cursorPoint.  handle position: p - (handle extent // 2).  self verticesAt: ix put: p-======-firstChild  ^firstChild-======-keyStroke: evt  | view |  editView keyStroke: evt.  (editView scrollByKeyboard: evt) ifTrue: [ ^self ].  (acceptOnCR and: [ evt keyCharacter = Character cr ]) ifFalse: [ (editView navigationKey: evt) ifTrue: [ ^self ] ].  self editor model: editView model.  view := editView.  (acceptOnCR and: [ evt keyCharacter = Character cr ]) ifTrue: [ ^self editor accept ].  super keyStroke: evt.  view textChanged.  view scrollSelectionIntoView.  self doAutoAccept: evt.  view scrollSelectionIntoView-======-nextSibling  ^nextSibling-======-drawOn: aCanvas  | borderVertices vertices |  borderVertices := self buildBorderVertices.  vertices := self buildVerticesFrom: borderVertices.  aCanvas drawPolygon: vertices color: self backgroundColor borderWidth: 0 borderColor: Color transparent.  borderVertices overlappingPairsDo: [:start :end |  aCanvas line: start to: end width: 1 color: self borderColor ]-======-textColor  ^self valueOfProperty: #textColor ifAbsent: [ self theme textColor ]-======-lastVisibleRowIndex  ^self container lastVisibleRowIndex-======-widthToDisplayInList: aList  ^self minExtent x-======-mouseStillDown: evt  self eventHandler ifNotNil: [ self eventHandler mouseStillDown: evt fromMorph: self ]-======-eventQueue  ^Sensor-======-container  ^container-======-privateFullMoveBy: delta  | deltaSlipped griddingMorph |  selectedItems isEmpty ifTrue: [ ^super privateFullMoveBy: delta ].  griddingMorph := self pasteUpMorph.  griddingMorph ifNil: [ ^super privateFullMoveBy: delta ].  deltaSlipped := delta + slippage.  slippage := 0.  super privateFullMoveBy: deltaSlipped.  selectedItems do: [:m |  m position: m position + deltaSlipped ]-======-toggleRowIndex: index  self deprecated: 'Use #toggleIndex: instead.' transformWith: '`@receiver toggleRowIndex: `@statements' -> '`@receiver toggleIndex: `@statements'.  self toggleIndex: index-======-buildMetaMenu: evt  | menu |  menu := UIManager default newMenuIn: self for: self.  menu add: 'grab' selector: #grabMorph:.  menu add: 'copy to paste buffer' selector: #copyToPasteBuffer:.  self maybeAddCollapseItemTo: menu.  menu add: 'delete' selector: #dismissMorph:.  menu addLine.  menu add: 'copy text' selector: #clipText.  menu addLine.  menu add: 'go behind' selector: #goBehind.  menu add: 'add halo' selector: #addHalo:.  menu add: 'duplicate' selector: #maybeDuplicateMorph:.  self addEmbeddingMenuItemsTo: menu hand: evt hand.  menu add: 'resize' selector: #resizeMorph:.  self addFillStyleMenuItems: menu hand: evt hand.  self addDropShadowMenuItems: menu hand: evt hand.  self addLayoutMenuItems: menu hand: evt hand.  menu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().  menu addLine.  menu add: 'inspect' selector: #inspectAt:event: argument: evt position.  menu add: 'explore' selector: #inspect.  menu lastItem icon: (self iconNamed: #smallInspectItIcon).  menu addLine.  menu add: 'show actions' selector: #showActions.  menu addLine.  self addDebuggingItemsTo: menu hand: evt hand.  self addCustomMenuItems: menu hand: evt hand.  ^menu-======-withoutListWrapper  ^complexContents withoutListWrapper-======-wantsDropSelector: aSymbol  wantsDropSelector := aSymbol-======-shouldDraw  ^self fillStyle isTransparent not-======-justified  self changeAlignment: #justified-======-elementWrapped: object  ^self wrapSelector ifNotNil: [:selector |  self model perform: selector with: object ] ifNil: [ object ]-======-testUpdateTaskBarShouldContainsTaskbarTasks  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: (taskbar tasks first isKindOf: TaskbarTask)-======-hasProperty: aSymbol  | property |  otherProperties ifNil: [ ^false ].  property := otherProperties at: aSymbol ifAbsent: [  ].  property ifNil: [ ^false ].  property == false ifTrue: [ ^false ].  ^true-======-setTextStyle: aTextStyle  textStyle := aTextStyle.  self     releaseCachedState;     changed-======-forwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirection-======-newToolDockingBar  ^self theme newToolDockingBarIn: self-======-setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) rounded-======-positionSubmorphs  self submorphsDo: [:aMorph |  aMorph snapToEdgeIfAppropriate ]-======-hasCollapseBox  ^collapseBox notNil-======-newYesButton  ^self newYesButtonFor: self-======-calculateExactVisibleRows  | rowIndex maxHeight height |  self table hasDataSource ifFalse: [ ^super calculateExactVisibleRows ].  rowIndex := self table showIndex max: 1.  height := 0.  maxHeight := self height.  headerRow ifNotNil: [ maxHeight := maxHeight - headerRow height ].  [ height < maxHeight and: [ rowIndex <= self table dataSource numberOfRows ] ] whileTrue: [ height := height + (self table dataSource rowHeight: rowIndex).        rowIndex := rowIndex + 1 ].  ^rowIndex - self table showIndex-======-ghostText  ^'Search...'-======-spawnBalloonFor: aMorph  aMorph showBalloon: aMorph balloonText hand: self-======-wantsDirectionHandles  ^self valueOfProperty: #wantsDirectionHandles ifAbsent: [ false ]-======-fitTargetBoundsInOwner: aRect  | ownerMinExt targetOwner |  targetOwner := self target owner ifNil: [ ^self ].  ownerMinExt := targetOwner minExtent.  ownerMinExt x > self target owner width ifTrue: [ self edgeName = #left ifTrue: [ self target bounds: ((aRect left + (ownerMinExt x - targetOwner width)) @ aRect top extent: (aRect width - (ownerMinExt x - targetOwner width)) @ aRect height) ] ifFalse: [ self target bounds: (aRect origin extent: (aRect width - (ownerMinExt x - targetOwner width)) @ aRect height) ] ].  ownerMinExt y > self target owner height ifTrue: [ self edgeName = #top ifTrue: [ self target bounds: (aRect left @ (aRect top + (ownerMinExt y - targetOwner height)) extent: aRect width @ (aRect height - (ownerMinExt y - targetOwner height))) ] ifFalse: [ self target bounds: (aRect origin extent: aRect width @ (aRect height - (ownerMinExt y - targetOwner height))) ] ]-======-hasChildren  ^self children size ~= 0-======-value  ^progressBar value-======-translateBy: delta  position := position + delta.  startPoint := startPoint + delta-======-showAbout  self theme longMessageIn: self text: self aboutText title: self aboutTitle-======-colorForInsets  (color isColor and: [ color isTransparent and: [ owner notNil ] ]) ifTrue: [ ^owner colorForInsets ].  ^color colorForInsets-======-clipSubmorphs: aBool  self invalidRect: self fullBounds.  aBool == self clipSubmorphs ifFalse: [ self assureExtension.        extension clipSubmorphs: aBool.        self invalidRect: self fullBounds ]-======-getMenuSelector: aSymbol  getMenuSelector := aSymbol-======-readyToBeDisplayed  -======-isDeActivated  ^true-======-allMorphsDo: aBlock  submorphs do: [:m |  m allMorphsDo: aBlock ].  aBlock value: self-======-canDrawBorder: aBorderStyle  ^true-======-sliderColor: aColor  | buttonColor |  super sliderColor: aColor.  self lastPaneColor: aColor.  buttonColor := self thumbColor.  upButton color: buttonColor.  downButton color: buttonColor.  slider color: buttonColor slightlyLighter.  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStyle.  (self theme scrollbarPagingAreaCornerStyleIn: self window) = #rounded ifTrue: [ self fillStyle: self normalButtonFillStyle ] ifFalse: [ self fillStyle: self normalFillStyle ].  self borderWidth: 0.  ^self adoptGradientColor: aColor-======-putLabelItemsInLabelArea  labelArea ifNotNil: [ stripes ifNotNil: [ stripes do: [:stripe |  labelArea addMorph: stripe ] ].        closeBox ifNotNil: [ labelArea addMorph: closeBox ].        menuBox ifNotNil: [ labelArea addMorph: menuBox ].        collapseBox ifNotNil: [ labelArea addMorph: collapseBox ].        label ifNotNil: [ labelArea addMorph: label ] ]-======-simulateKeyStroke: aCharacterOrShortcut  | shortcut |  shortcut := aCharacterOrShortcut asKeyCombination.  self handleEvent: (KeyboardEvent new setType: #keystroke buttons: shortcut modifier eventCode position: self position keyValue: shortcut key asciiValue charCode: shortcut key asciiValue hand: self activeHand stamp: DateAndTime now)-======-intersects: aRectangle  ^self fullBoundsInWorld intersects: aRectangle-======-newPreviewMorph  ^Morph new     color: Color transparent;     extent: self defaultPreviewExtent;     yourself-======-mouseMoveOnMultiple: event  | oldIndex oldVal row |  canMove ifFalse: [ ^self ].  event position y < self top ifTrue: [ scrollBar scrollUp: 1.        row := self rowAtLocation: scroller topLeft + (1 @ 1) ] ifFalse: [ row := event position y > self bottom ifTrue: [ scrollBar scrollDown: 1.              self rowAtLocation: scroller bottomLeft + (1 @ -1) ] ifFalse: [ self rowAtLocation: event position ] ].  row = 0 ifTrue: [ ^super mouseDown: event ].  (self potentialDropItem notNil and: [ self dropEnabled ]) ifTrue: [ ^self ].  dragOnOrOff ifNil: [ dragOnOrOff := (self listSelectionAt: row) not ].  oldIndex := self getCurrentSelectionIndex.  oldIndex ~= 0 ifTrue: [ oldVal := self listSelectionAt: oldIndex ].  oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].  self listSelectionAt: row put: dragOnOrOff.  row changed-======-drawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self drawLinesOn: aCanvas-======-addPaneSplitters  self removePaneSplitters.  self addPaneVSplitters.  self addPaneHSplitters.  self linkSplittersToSplitters-======-dropFiles: anEvent  | numFiles |  numFiles := anEvent contents.  1 to: numFiles do: [:i |  | aFileReference handler |        aFileReference := anEvent requestDropReference: i.        handler := ExternalDropHandler lookupExternalDropHandler: aFileReference.        handler ifNotNil: [ handler handle: aFileReference in: self dropEvent: anEvent ] ]-======-bounds: aRectangle  | size |  size := aRectangle width min: aRectangle height.  super bounds: (Rectangle origin: aRectangle origin extent: size @ size)-======-searchStrategy  ^searchStrategy ifNil: [ #default ]-======-textEntry: aStringOrText title: aString entryText: defaultEntryText  ^self theme textEntryIn: self text: aStringOrText title: aString entryText: defaultEntryText-======-is: anIndex afterColumn: aColumnIndex  ^anIndex second > aColumnIndex-======-minWidth  ^self valueOfProperty: #minWidth ifAbsent: [ 2 ]-======-controls  ^controls-======-rowIndexToVerticalScrollBarValue: aNumber  | numberOfRows |  numberOfRows := self numberOfRows - self container calculateMinVisibleRows.  ^(numberOfRows = 0 or: [ aNumber <= 1 ]) ifTrue: [ 0.0 ] ifFalse: [ ((aNumber / numberOfRows) asFloat max: 0.0) min: 1.0 ]-======-image: anImage  ^self image: anImage size: anImage extent-======-allSubmorphNamesDo: nameBlock  ^self-======-dragItemSelector  ^dragItemSelector-======-pressedImageSelector  ^pressedImageSelector-======-minCellSize  ^0-======-vScrollbar  ^vScrollbar-======-showsNever  ^self showState == #never-======-index: anIndex  index := anIndex-======-updateValue  self model ifNotNil: [ self getValueSelector ifNotNil: [ self sliderMorph ifNotNil: [:sm |  sm scaledValue: self value.                    self                       changed: #minEnabled;                       changed: #maxEnabled ] ] ]-======-getEnabledSelector: aSymbol  getEnabledSelector := aSymbol.  self updateEnabled-======-newRow: controls  ^self theme newRowIn: self for: controls-======-handleUpdate: aMorphChangedAnnouncement  ^aMorphChangedAnnouncement deliverTo: self-======-testIndexFromPosition  self assert: (strategy indexFromPosition: #(3 7)) equals: #(3 7)-======-printOn: aStream  aStream nextPutAll: 'Node('.  self item printOn: aStream.  aStream nextPut: $)-======-getListSizeSelector: aSymbol  getListSizeSelector := aSymbol-======-icon  ^icon-======-message: aStringOrText  ^self message: aStringOrText title: 'Information' translated-======-tabs  ^tabs-======-optimalExtent  ^(Paragraph new     compose: text style: textStyle copy from: 1 in: (0 @ 0 extent: 9999999 @ 9999999);     adjustRightX;     extent) + (self borderWidth * 2) + (2 @ 0)-======-tabRemovedFromSelection: aTab  self setMultipleContents-======-drawLineFrom: startPoint to: stopPoint on: aCanvas  | lineColor |  lineColor := (stopPoint truncated quadrantOf: startPoint truncated) > 2 ifTrue: [ self topLeftColor ] ifFalse: [ self bottomRightColor ].  aCanvas line: startPoint to: stopPoint width: (self width - self margin max: 0) color: lineColor-======-beCellSelection  self selectionModeStrategy: (FTCellSelectionModeStrategy table: self)-======-newScrollPaneFor: aMorph  ^self theme newScrollPaneIn: self for: aMorph-======-currentNodelist  ^self nodeList copyFrom: self currentPageFirstIndex to: self currentPageLastIndex-======-removeDependent: anObject  self announcer unsubscribe: anObject-======-mouseOverAllowed  ^mouseOverAllowed ifNil: [ mouseOverAllowed := false ]-======-unexpandAllChildOf: anItem  anItem children do: [:item |  item isExpanded ifTrue: [ self unexpandAllChildOf: item ].        item collapse ] displayingProgress: [:each |  'Rearanging ' , each name ]-======-addCustomHaloMenuItems: aMenu hand: aHandMorph  self addCustomMenuItems: aMenu hand: aHandMorph-======-passiveDisabledOverDownFillStyle: aFillStyle  self stateMap atPath: #(passive disabled over down) put: aFillStyle.  self changed-======-handlesMouseOver: evt  self table ifNotNil: [:table |  ^table selectionModeStrategy allowsCellSelection ].  ^false-======-captureEventsUntil: aBlock  | release |  release := false.  captureBlock := [:evt |  release := aBlock value: evt ].  [ [ self world doOneCycle.  release ] whileFalse ] ensure: [ captureBlock := nil ]-======-table: anObject  table := anObject-======-makeMeVisible  self world extent > (0 @ 0) ifFalse: [ ^self ].  ((self world bounds insetBy: (0 @ 0 corner: self labelHeight asPoint)) containsPoint: self position) ifTrue: [ ^self ].  self isCollapsed ifTrue: [ self position: (RealEstateAgent assignCollapsePointFor: self) ] ifFalse: [ self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent world: self world) topLeft ]-======-allowsRowSelection  ^false-======-offerWindowMenu  | aMenu |  aMenu := self buildWindowMenu.  aMenu     addLine;     add: 'Grab window...' target: self selector: #grabWindow.  aMenu lastItem icon: (self iconNamed: #smallWindowIcon).  self tabGroup page ifNotNil: [:page |  page model addModelItemsToWindowMenu: aMenu ].  aMenu popUpEvent: self currentEvent in: self world-======-matchesTypes: types  (self type isNil or: [ types isNil ]) ifTrue: [ ^false ].  ^types anySatisfy: [:mimeType |  mimeType beginsWith: self type ]-======-numberOfLines  ^lines size-======-interactionState: aSymbol  -======-collapseAll  self subclassResponsibility-======-colorForSelection: primarySelection  ^primarySelection ifTrue: [ self selectionColor ] ifFalse: [ self secondarySelectionColor ]-======-minimumSelection  ^1-======-stayUp  ^false-======-preferredButtonCornerStyle  ^#square-======-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self hScrollbar adoptPaneColor: paneColor.  self vScrollbar adoptPaneColor: paneColor-======-moveShowIndexTo: arg  | index oldIndex |  index := self selectionModeStrategy rowIndexFrom: arg.  oldIndex := showIndex.  self basicMoveShowIndexTo: index.  self verticalScrollBar value: (self rowIndexToVerticalScrollBarValue: index).  self refresh.  self announceScrollChangedFrom: oldIndex to: index-======-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-======-= other  ^other class == self class and: [ other anchoredMorph == anchoredMorph ]-======-menu  | menu |  menu := UIManager default newMenuIn: self currentWorld for: self.  menu buildTitle: [:menuTitle |  menuTitle onlyCloseAndPinable ].  menu add: 'Why you see this menu' target: self selector: #fallbackMenuExplanations.  menu add: 'Debug' target: self selector: #debug.  menu addLine.  client fallbackMenuOn: menu.  ^menu-======-expandAll  rootItem expandAll.  self tableRefresh-======-centeredAlert: aStringOrText title: aString configure: aBlock  ^self theme centeredAlertIn: self text: aStringOrText title: aString configure: aBlock-======-newStateForSelected: aBoolean  ^TabEnabled tab: self tab-======-useGradientFill  | fill color1 color2 |  self fillStyle isGradientFill ifTrue: [ ^self ].  color1 := self color asColor.  color2 := color1 negated.  fill := GradientFillStyle ramp: {(0.0 -> color1) .         (1.0 -> color2)}.  fill origin: self topLeft.  fill direction: 0 @ self bounds extent y.  fill normal: self bounds extent x @ 0.  fill radial: false.  self fillStyle: fill-======-optionalOperations  pattern isEmptyOrNil ifTrue: [ self unexpandAllChildOf: dataSource rootItem.        ^#() ] ifFalse: [ ^nil ]-======-imageMorph: anObject  imageMorph := anObject-======-initialize  super initialize.  self initForKeystrokes.  self on: #mouseMove send: #mouseStillDown:onItem: to: self-======-adjustAfter: changeBlock  changeBlock value.  self chooseSmoothing.  self layoutChanged.  owner ifNotNil: [ owner invalidRect: bounds ]-======-userString  ^text string-======-newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpText-======-computeAltFramedColors  | base light dark w hw colorArray param |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  w = 1 ifTrue: [ ^{(base mixed: 0.5 with: light) .         (base mixed: 0.5 with: dark)} ].  colorArray := Array new: w.  hw := w // 2.  0 to: hw - 1 do: [:i |  param := 0.5 + (i asFloat / hw * 0.5).        colorArray at: i + 1 put: (base mixed: param with: dark).        colorArray at: w - i put: (base mixed: param with: light) ].  w odd ifTrue: [ colorArray at: hw + 1 put: base ].  ^colorArray , colorArray-======-filterClass: aFTFilterClass  filterClass := aFTFilterClass-======-doubleClickTimeout  dblClickTimeoutSelector ifNotNil: [ clickClient perform: dblClickTimeoutSelector with: firstClickDown ]-======-first: firstCharBlock last: lastCharBlock color: aColor  first := firstCharBlock.  last := lastCharBlock.  color := aColor-======-wrapCentering  ^#topLeft-======-initializeColumsFrom: aModel  self columns: aModel columns-======-chooseColor  ^self chooseColor: Color black-======-wasHandled  ^false-======-addDependent: aDependent  dependents := #().  super addDependent: aDependent-======-hsvaMorph: anObject  hsvaMorph := anObject-======-roundedCorners  self isAdheringToTop ifTrue: [ ^#(2 3) ].  self isAdheringToBottom ifTrue: [ ^#(1 4) ].  self isAdheringToLeft ifTrue: [ ^#(3 4) ].  self isAdheringToRight ifTrue: [ ^#(1 2) ].  ^#(1 2 3 4)-======-predecessor: pred successor: succ  predecessor := pred.  successor := succ-======-blueButtonPressed  ^buttons anyMask: self class blueButton-======-iconPosition  ^iconPosition ifNil: [ iconPosition := #left ]-======-