arguments  ^argumentsremoveElement: element  ^self basicRemoveElement: elementtestReciprocal  self     assert: 1 reciprocal equals: 1;     assert: 2 reciprocal equals: 1 / 2;     assert: -1 reciprocal equals: -1;     assert: -3 reciprocal equals: -1 / 3.  self should: [ 0 reciprocal ] raise: ZeroDividetestTicks  self assert: aDuration ticks equals: #(1 7384 5)home  closureOrNil == nil ifTrue: [ ^self ].  ^closureOrNil outerContext hometestDigitsAccess  self assert: (42 digitAt: 2 base: 10) equals: 4.  self assert: (42 digitAt: 1 base: 10) equals: 2.  self assert: (1 digitAt: 2 base: 10) equals: 0.  self assert: (16rFF digitAt: 1 base: 16) equals: 15.  self assert: (42 decimalDigitAt: 2) equals: 4.  self assert: (42 decimalDigitAt: 1) equals: 2.  self assert: 42 decimalDigitLength equals: 2.  self assert: 0 decimalDigitLength equals: 1.  self assert: 100000000000 decimalDigitLength equals: 12.  self assert: 255 lastDigit equals: 255.  self assert: 256 lastDigit equals: 1.  self assert: (256 * 256 - 1) lastDigit equals: 255.  self assert: (256 * 256) lastDigit equals: 1testSymmetric  | t1 t2 |  t1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  t2 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self assert: t2 equals: t1.  self assert: t1 equals: t2testIsLiteral  self assert: 1.00s2 isLiteral description: 'every literal obviously isLiteral'.  self deny: (1 / 3.00s2) isLiteral description: 'this number cannot represent itself as a literal'secondsSinceMidnightLocalTime  ^self localSeconds \\ SecondsInDaytestSuperclassOrder  | ordered orderedSuperclasses shuffledSuperclasses |  orderedSuperclasses := {ProtoObject .   Object .   Collection .   SequenceableCollection}.  shuffledSuperclasses := {Collection .   SequenceableCollection .   ProtoObject .   Object}.  ordered := Class superclassOrder: shuffledSuperclasses.  self assert: ordered equals: orderedSuperclasses asOrderedCollectiontestAsTime  self assert: aDateAndTime asTime equals: (Time hour: 13 minute: 33 second: 0)createTwin  self reflectiveMethod: (ReflectiveMethod on: self)testIfNotNilDo  nil ifNotNil: [ self fail: 'should not get here' ]bitOr: arg  < primitive: 15>  self >= 0 ifTrue: [ ^arg bitOr: self ].  ^arg < 0 ifTrue: [ (self bitInvert bitAnd: arg bitInvert) bitInvert ] ifFalse: [ (self bitInvert bitClear: arg) bitInvert ]printDebugOn: aStream  | blockSource blockSourceSize |  self printOn: aStream.  self outerContext ifNil: [ ^self ].  aStream nextPutAll: ' in Block: '.  blockSource := closureOrNil printStringLimitedTo: 50.  blockSourceSize := blockSource size.  blockSource := blockSource copyUpTo: Character cr.  aStream nextPutAll: blockSource.  blockSource size < blockSourceSize ifTrue: [ aStream nextPutAll: '...' ]alwaysReadOnlyObjects  ^{1}typeOfClass  self classLayout isCustomLayout ifTrue: [ ^self classLayout class name asSymbol ].  self isBytes ifTrue: [ ^self instSpec = CompiledMethod instSpec ifTrue: [ #compiledMethod ] ifFalse: [ #bytes ] ].  (self isWords and: [ self isPointers not ]) ifTrue: [ ^self instSpec = SmallInteger instSpec ifTrue: [ #immediate ] ifFalse: [ #words ] ].  self isWeak ifTrue: [ ^#weak ].  self isVariable ifTrue: [ ^#variable ].  self isEphemeronClass ifTrue: [ ^#ephemeron ].  ^#normaltestYyyymmdd  self assert: january23rd2004 yyyymmdd equals: '2004-01-23'testFromDateAndTime  | oc1 oc2 |  oc1 := OrderedCollection new.  DateAndTime today to: DateAndTime tomorrow by: 10 hours do: [:dt |  oc1 add: dt ].  oc2 := {DateAndTime today .   (DateAndTime today + 10 hours) .   (DateAndTime today + 20 hours)}.  self assert: oc1 asArray equals: oc2sizePushReceiver  ^self sizeOpcodeSelector: #genPushReceiver withArguments: #()classClass  self deprecated: 'Please use #classSide instead' transformWith: '`@receiver classClasss' -> '`@receiver classSide'.  ^self classSidetestNew  self should: [ Integer new ] raise: self defaultTestErrortestIsPrime2  #(-100 -5 -3 -2 -1 0 1) do: [:each |  self deny: each isPrime ].  #(17 78901 104729 15485863 2038074743) do: [:each |  self assert: each isPrime ].  #(561 2821 6601 10585 15841 256 29996224275831) do: [:each |  self deny: each isPrime ]testSupplyAnswerOfFillInTheBlank  self should: [ 'blue' = ([ UIManager default request: 'Your favorite color?' ] valueSupplyingAnswer: #('Your favorite color?' 'blue')) ]previous: dayName  | days |  days := (7 + self weekdayIndex - (self class dayOfWeek: dayName)) \\ 7.  days = 0 ifTrue: [ days := 7 ].  ^self subtractDays: daysprint24: hr24 showSeconds: showSeconds on: aStream  | h m s |  h := self hour.  m := self minute.  s := self second.  hr24 ifTrue: [ h < 10 ifTrue: [ aStream nextPut: $0 ].        h printOn: aStream ] ifFalse: [ h > 12 ifTrue: [ h - 12 printOn: aStream ] ifFalse: [ h < 1 ifTrue: [ 12 printOn: aStream ] ifFalse: [ h printOn: aStream ] ] ].  aStream nextPutAll: (m < 10 ifTrue: [ ':0' ] ifFalse: [ ':' ]).  m printOn: aStream.  showSeconds ifTrue: [ aStream nextPutAll: (s < 10 ifTrue: [ ':0' ] ifFalse: [ ':' ]).        s printOn: aStream.        nanos = 0 ifFalse: [ | n len |              n := nanos.              len := 9.              [ n \\ 10 = 0 ] whileTrue: [ n := n / 10.                    len := len - 1 ].              aStream nextPut: $..              n printOn: aStream base: 10 length: len padded: true ] ].  hr24 ifFalse: [ aStream nextPutAll: (h < 12 ifTrue: [ ' am' ] ifFalse: [ ' pm' ]) ]testOnForkSplit  | sema timeout forkedContexts myContexts c |  self     flag: 'This test is too brittle, failing often on CI';     skip.  sema := Semaphore new.  [ 1 / 0 ] on: Exception fork: [ | ctx |        forkedContexts := IdentitySet new.        ctx := thisContext.        [ ctx notNil ] whileTrue: [ forkedContexts add: ctx.              ctx := ctx sender ].        sema signal ].  timeout := sema waitTimeoutSeconds: 1.  self assert: timeout == false description: 'fork lasted more than one second'.  myContexts := IdentitySet new.  c := thisContext.  [ c notNil ] whileTrue: [ myContexts add: c.        c := c sender ].  self assert: (myContexts noneSatisfy: [:b |  forkedContexts includes: b ]) description: 'myContexts are not within forkedContexts'.  self assert: (forkedContexts noneSatisfy: [:b |  myContexts includes: b ]) description: 'forkedContexts are not within myContexts'acceptsLoggingOfCompilation  ^truerecompile  ^self methodClass recompile: self selectorclassThatDefinesClassVariable: classVarName  (self classPool includesKey: classVarName asSymbol) ifTrue: [ ^self ].  ^self superclass ifNotNil: [ self superclass classThatDefinesClassVariable: classVarName ]testTo  self assert: (aDateAndTime to: aDateAndTime) equals: ((DateAndTime year: 1970 month: 1 day: 1) to: (DateAndTime year: 1970 month: 1 day: 1))testYearMonthDayHourMinuteSecondNanosSecondOffset  self assert: aDateAndTime equals: (DateAndTime year: 1980 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours).  self assert: (DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours) + (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) equals: (DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)testSupplySeveralAnswersToSeveralQuestions  self should: [ #(false true) = ([ {(self confirm: 'One') .               (self confirm: 'Two')} ] valueSupplyingAnswers: #(#('One' false) #('Two' true))) ].  self should: [ #(true false) = ([ {(self confirm: 'One') .               (self confirm: 'Two')} ] valueSupplyingAnswers: #(#('One' true) #('Two' false))) ]nbCall: fnSpec module: aModuleNameOrHandle options: callOptions  < ffiCalloutTranslator>  self deprecated: 'use ffiCall:module:options: instead'.  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     options: callOptions;     function: fnSpec library: aModuleNameOrHandlegtDisplayString  | limitedString limit |  limit := 1000.  limitedString := String streamContents: [:s |  self gtDisplayOn: s ] limitedTo: limit.  limitedString size < limit ifTrue: [ ^limitedString ].  ^limitedString , ' ...'spotterActDefault  ^self method browse- aNumber  < primitive: 42>  ^aNumber adaptToFloat: self andSend: #-valueNoContextSwitch  < primitive: 209>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  self primitiveFailedtestIsLiteral  self assert: nil isLiteralyearsDo: aBlock  self do: aBlock with: start asYearcheckDynamic: value  self assert: TestDynamicVariable value equals: valueabstractBytecodeMessagesDo: aBlock  ^self compiledBlock abstractBytecodeMessagesDo: aBlocksetPinned: aBoolean  self setPinnedInMemory: aBooleannumberOfCategoryOfElement: element  | indexOfElementInElementArray |  indexOfElementInElementArray := elementArray identityIndexOf: element asSymbol ifAbsent: [ ^0 ].  ^categoryStops findFirst: [:stopIndex |  stopIndex >= indexOfElementInElementArray ]scanner  ^InstructionStream on: selfgtInspectorAllReferencesIn: composite  < gtInspectorPresentationOrder: 20>  composite list     title: 'All Ref';     display: [ (SystemNavigation default allReferencesTo: self binding) sorted: [:x :y |  x name < y name ] ];     format: #name;     tags: [:each |  {each package name} ]testHash  self assert: aDateAndTime hash equals: (DateAndTime year: 1970 month: 1 day: 1) hashenvironmentKeyNotFound  self error: 'Environment key not found'duringTestCompileSilently: code storeSource: storeSource  ^self duringTestCompileSilently: code storeSource: storeSource classified: #UnclassifiedtestMutateByteSymbolUsingPrivateAtPut  | guineaPig |  [ guineaPig := #hello.  guineaPig beReadOnlyObject.  self should: [ guineaPig privateAt: 1 put: $q ] raise: ModificationForbidden ] ensure: [ guineaPig beWritableObject ].  self assert: guineaPig first equals: $hyourself  ^selfsomeInstance  < primitive: 77>  ^niltestDeepCopy  self assert: nil deepCopy isNilhasPositiveExtent  ^corner x > origin x and: [ corner y > origin y ]debug: context title: title full: bool  ^UIManager default debugProcess: self context: context label: title fullView: booldrTestsName  ^self selector asStringtestNanoSecond  self assert: aDateAndTime nanoSecond equals: 0includesKey: aKey  1 to: self basicSize do: [:i |  (self basicAt: i) key == aKey ifTrue: [ ^true ] ].  ^falsestackOfSize: limit  | stack context |  stack := OrderedCollection new.  stack addLast: (context := self).  [ (context := context sender) ~~ nil and: [ stack size < limit ] ] whileTrue: [ stack addLast: context ].  ^stacktestthoroughWhichMethodsReferTo  | array |  array := #(thisIsOnlyHereIntestthoroughWhichMethodsReferTo).  self assert: (Point thoroughWhichMethodsReferTo: #x) notEmpty.  self assert: (Point thoroughWhichMethodsReferTo: #+) notEmpty.  self assert: (self class thoroughWhichMethodsReferTo: array first) notEmpty.  self assert: (self class thoroughWhichMethodsReferTo: ('this' , 'doesNotExist') asSymbol) isEmptyhandleFailingBasicNew: sizeRequested  < primitive: 71>  | bytesRequested |  bytesRequested := self byteSizeOfInstanceOfSize: sizeRequested.  Smalltalk garbageCollect < bytesRequested ifTrue: [ Smalltalk growMemoryByAtLeast: bytesRequested ].  ^self handleFailingFailingBasicNew: sizeRequestedtestNaN5  self assert: ((Float nan asIEEE32BitWord printPaddedWith: $0 to: 32 base: 2) copyFrom: 2 to: 9) equals: '11111111'.  self assert: (Float fromIEEE32Bit: (Integer readFrom: '01111111110000000000000000000000' readStream base: 2)) isNaNtestMinute  self assert: aDateAndTime minute equals: 0removeDangerouslyKey: key ifAbsent: aBlock  | index element |  index := self findElementOrNil: key.  (self basicAt: index) ifNil: [ ^aBlock value ].  element := array at: index.  array at: index put: nil.  self basicAt: index put: nil.  tally := tally - 1.  self fixCollisionsFrom: index.  ^elementtestReadFromNoException  #('0:00:00:00' '0:00:00:00.000000001' '0:00:00:00.999999999' '0:00:00:00.100000000' '0:00:00:00.10' '0:00:00:00.1' '0:00:00:01' '0:12:45:45' '1:00:00:00' '365:00:00:00' '-7:09:12:06.10' '+0:01:02:55' '+0:01:02:3') do: [:each |  each asDuration printString = each ]genPushReceiver  stream nextPut: 76inspectOnce  | node |  node := thisContext sender sourceNodeExecuted.  (node hasProperty: #Once) ifTrue: [ ^self ].  node propertyAt: #Once put: true.  ^self inspectoldDefinition  ^self definitionaddCategory: catString before: nextCategory  | index newCategory |  newCategory := catString asSymbol.  (categoryArray indexOf: newCategory) > 0 ifTrue: [ ^self ].  index := categoryArray indexOf: nextCategory ifAbsent: [ categoryArray size + 1 ].  categoryArray := categoryArray copyReplaceFrom: index to: index - 1 with: (Array with: newCategory).  categoryStops := categoryStops copyReplaceFrom: index to: index - 1 with: (Array with: (index = 1 ifTrue: [ 0 ] ifFalse: [ categoryStops at: index - 1 ])).  (newCategory ~= Default and: [ (self listAtCategoryNamed: Default) isEmpty ]) ifTrue: [ self removeCategory: Default ]preemptedProcess  | list |  activeProcess priority to: 1 by: -1 do: [:priority |  list := quiescentProcessLists at: priority.        list isEmpty ifFalse: [ ^list last ] ].  ^niltestIsReferenced  self assert: Object isReferenced.  self deny: Object class isReferencedmarkerOrNil  ^self encoderClass markerOrNilFor: selftestHour12  self assert: aDateAndTime hour12 equals: DateAndTime new hour12.  self assert: aDateAndTime hour12 equals: 12xor: alternativeBlock  ^alternativeBlock value notfullPrintString  ^String streamContents: [:s |  self printOn: s ]testDaysInMonthForYear  self assert: (Date daysInMonth: #February forYear: 2008) equals: 29.  self assert: (Date daysInMonth: #February forYear: 2000) equals: 29.  self assert: (Date daysInMonth: #February forYear: 2100) equals: 28.  self assert: (Date daysInMonth: #July forYear: 2100) equals: 31basicCheck: aMethod  aMethod isDeprecated ifTrue: [ ^false ].  ^aMethod overriddenMethods anySatisfy: #isDeprecatedtestEncodingSourcePointer  | trailer |  trailer := CompiledMethodTrailer new.  CompiledMethod allInstancesDo: [:method |  | ptr |        trailer method: method.        self assert: (ptr := method sourcePointer) identicalTo: trailer sourcePointer.        ptr ~= 0 ifTrue: [ self assert: method endPC equals: trailer endPC ] ]printOn: aStream  self printOn: aStream format: #(1 2 3 $  3 1)round: numberOfWishedDecimal  ^(super round: numberOfWishedDecimal) asScaledDecimal: (scale max: numberOfWishedDecimal)testNew  self should: [ UndefinedObject new ] raise: ErrortestIsOpenPunctuation  self checkCorrespondanceOf: #isOpenPunctuation: and: #PstallyCPUUsageFor: seconds  ^self tallyCPUUsageFor: seconds every: 10testSharedPools  self assert: Point sharedPools equals: OrderedCollection new.  self assert: Date sharedPools first equals: ChronologyConstants.  self assert: Date sharedPools size equals: 1.  Date class sharedPools.  self assert: RootClassPoolUser sharedPools size equals: 1.  self assert: ClassMultiplePoolUser sharedPools size equals: 2.  self assertEmpty: SubclassPoolUser sharedPoolstestAsWeek  self assert: aTimespan asWeek equals: jan01 asWeektestNestedLoopsExample1  | arrays result |  arrays := OrderedCollection new.  arrays     add: #(#a #b);     add: #(1 2 3 4);     add: #('w' 'x' 'y' 'z').  result := OrderedCollection new.  CollectionCombinator new forArrays: arrays processWith: [:item |  result addLast: item ].  self assert: (self nestedLoopsExample: arrays) equals: resultdeprecatedMethod4  self deprecated: 'Example of a deprecated method with transform' on: '01/01/1970' in: #Pharo6 transformWith: '`@receiver deprecatedMethod4' -> '`@receiver deprecatedMethod4'quo: aNumber  | ng quo |  aNumber isInteger ifTrue: [ ng := self negative == aNumber negative == false.        quo := (self digitDiv: aNumber neg: ng) at: 1.        ^quo normalize ].  ^aNumber adaptToInteger: self andSend: #quo:bindingOf: varName  ^self instanceSide classBindingOf: varNamemontgomeryDigitLength  < primitive: 'primMontgomeryDigitLength' module: 'LargeIntegers'>  ^8cannotInterpret: aMessage  (self class lookupSelector: aMessage selector) ifNotNil: [ ^aMessage sentTo: self ].  Error signal: 'MethodDictionary fault'.  ^aMessage sentTo: selftestHours  self assert: aDuration hours equals: 2.  self assert: (Duration hours: 2) hours equals: 2testAsYear  self assert: aTimespan asYear equals: jan01 asYeargroup  ^'Design Flaws'receiver: anObject  receiver := anObjectgtInspectorDetailsIn: composite  < gtInspectorPresentationOrder: 30>  ^composite table     title: 'Details';     display: [ {('iso' -> self yyyymmdd) .         ('year' -> self year) .         ('month' -> self monthIndex) .         ('month name' -> self monthName) .         ('day of month' -> self dayOfMonth) .         ('day of week' -> self dayOfWeekName) .         ('day of year' -> self dayOfYear)} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valueasWeek  ^selfglamourValueWithArgs: anArray  self numArgs = 0 ifTrue: [ ^self value ].  self numArgs = anArray size ifTrue: [ ^self valueWithArguments: anArray ].  self numArgs > anArray size ifTrue: [ ^self valueWithArguments: anArray , (Array new: self numArgs - anArray size) ].  ^self valueWithArguments: (anArray copyFrom: 1 to: self numArgs)numArgs  ^args sizetruncateTo: aDuration  ^self class nanoSeconds: (self asNanoSeconds truncateTo: aDuration asNanoSeconds)testIfNil  < haltOrBreakpointForTesting>  self should: [ nil ifNil: [ self error ] ] raise: ErrorasDateAndTime  ^selfsizeJump: distance  ^self sizeOpcodeSelector: #genJump: withArguments: {distance}genSendSuper: selectorLiteralIndex numArgs: nArgs  nArgs < 0 ifTrue: [ ^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 ].  selectorLiteralIndex < 0 ifTrue: [ ^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255 ].  (selectorLiteralIndex < 32 and: [ nArgs < 8 ]) ifTrue: [ stream           nextPut: 133;           nextPut: (nArgs bitShift: 5) + selectorLiteralIndex.        ^self ].  (selectorLiteralIndex < 256 and: [ nArgs < 32 ]) ifTrue: [ stream           nextPut: 132;           nextPut: 32 + nArgs;           nextPut: selectorLiteralIndex.        ^self ].  nArgs >= 32 ifTrue: [ ^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 ].  selectorLiteralIndex >= 256 ifTrue: [ ^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255 ]subclass: aSubclassSymbol slots: slotDefinition classVariables: classVarDefinition package: aCategorySymbol  ^self subclass: aSubclassSymbol slots: slotDefinition classVariables: classVarDefinition poolDictionaries: '' package: aCategorySymbolwait: aDuration onCompletion: completionBlock onTimeout: timeoutBlock  | d |  d := DelayWaitTimeout new setDelay: aDuration asMilliSeconds forSemaphore: self.  ^d waitOnCompletion: completionBlock onTimeout: timeoutBlocksetUp  super setUp.  checkerBackup := PharoBootstrapRule classVarNamed: 'DependencyChecker'defaultSelector  ^#DoIt numArgs: self numArgsnewProcess  < primitive: 19>  ^Process forContext: [ self value.        Processor terminateActive ] asContext priority: Processor activePriorityprintOn: aStream base: base  self subclassResponsibilitydate  | encodedDate yearsSinceDosEpoch month day year |  encodedDate := self high16Bits.  yearsSinceDosEpoch := encodedDate >> 9.  month := encodedDate >> 5 & 2r1111.  day := encodedDate & 2r11111.  year := self epoch year + yearsSinceDosEpoch.  ^Date year: year month: month day: daytestMutateObjectInstVarUsingInstVarAtPut  | guineaPig |  guineaPig := WriteBarrierStub new.  guineaPig beReadOnlyObject.  self should: [ guineaPig instVarAt: 1 put: #test ] raise: ModificationForbidden.  [ guineaPig instVarAt: 1 put: #test ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig var1 equals: #testisObsolete  ^self instanceCount = 0basicAt: index put: value  < primitive: 211>  index isInteger ifTrue: [ self errorSubscriptBounds: index ].  index isNumber ifTrue: [ ^self at: index asInteger put: value ] ifFalse: [ self errorNonIntegerIndex ]useNonUtcTimeZoneDuring: aBlock  self useTimeZone: 'EDT' during: aBlocktestSlotNamed  self assert: (Point slotNamed: #x) name equals: #xto: stop  ^Interval from: self to: stop by: 1executeMethod: compiledMethod  ^self withArgs: #() executeMethod: compiledMethodtempNames  ^self ast argumentNames , self ast temporaryNamesgetSourceFromFile  ^[ SourceFiles sourceCodeAt: self sourcePointer ] on: Error do: [ '' ]aboutToReturn: result through: firstUnwindContext  self methodReturnContext return: result through: firstUnwindContexttestEpoch  self assert: aDateAndTime equals: '1980-01-01T00:00:00+00:00' asDateAndTimetestStartingEnding  self assert: aTimespan equals: (Timespan starting: jan01 ending: jan08)compileSilently: code classified: category notifying: requestor  ^SystemAnnouncer uniqueInstance suspendAllWhile: [ self compile: code classified: category notifying: requestor ]qCompress: string  | utf8str stream oddNibble |  string isEmpty ifTrue: [ ^self qCompress: ' ' ].  utf8str := string convertToEncoding: 'utf8'.  stream := WriteStream on: (ByteArray new: utf8str size).  oddNibble := nil.  utf8str do: [:char |  | ix |        ix := 'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()' indexOf: char ifAbsent: 0.        (ix = 0 ifTrue: [ {0 .               (char asInteger // 16) .               (char asInteger \\ 16)} ] ifFalse: [ ix <= 11 ifTrue: [ {ix} ] ifFalse: [ {(ix // 16 + 12) .                     (ix \\ 16)} ] ]) do: [:nibble |  oddNibble ifNotNil: [ stream nextPut: oddNibble * 16 + nibble.                    oddNibble := nil ] ifNil: [ oddNibble := nibble ] ] ].  oddNibble ifNotNil: [ stream nextPut: oddNibble * 16 + 4 ].  ^streamasSeconds  ^(self - self class epoch) asSecondstestTerminationShouldProceedEnsureBlocks  | ensureCalled process semaphore |  ensureCalled := false.  semaphore := Semaphore new.  process := [ [ semaphore signal.  [ 10 milliSeconds wait ] repeat ] ensure: [ ensureCalled := true ] ] fork.  semaphore wait.  process terminate.  self assert: ensureCalledstoreIntoTemporaryVariable: offset  self at: offset + 1 put: self topffiCall: fnSpec module: aModuleName  < ffiCalloutTranslator>  self ffiCall: fnSpec library: aModuleNameinitialize  super initialize.  methodSelectors := IdentitySet new.  name := self class defaultNamenormalize  < primitive: 'primNormalizePositive' module: 'LargeIntegers'>  | sLen val len oldLen |  len := oldLen := self bytesCount.  [ len = 0 ifTrue: [ ^0 ].  (self byteAt: len) = 0 ] whileTrue: [ len := len - 1 ].  sLen := SmallInteger maxVal > 16r3FFFFFFF ifTrue: [ 8 ] ifFalse: [ 4 ].  (len <= sLen and: [ (self byteAt: sLen) <= (SmallInteger maxVal byteAt: sLen) ]) ifTrue: [ val := 0.        len to: 1 by: -1 do: [:i |  val := val * 256 + (self byteAt: i) ].        ^val ].  len < oldLen ifTrue: [ ^self growto: len ] ifFalse: [ ^self ]instanceVariableWriteNodes  ^self ast instanceVariableWriteNodessetTraitComposition: aTraitComposition  ^self classInstaller update: self to: [:builder |  builder           fillFor: self;           traitComposition: aTraitComposition asTraitComposition;           classTraitComposition: aTraitComposition asTraitComposition classComposition ]quo: anInteger  < primitive: 33>  ^super quo: anIntegerreciprocalModulo: n  | u v f fPlusN b result result2 |  (self <= 0 or: [ n <= 0 ]) ifTrue: [ self error: 'self and n must be greater than zero' ].  self >= n ifTrue: [ self error: 'self must be < n' ].  b := n highBit + 1.  f := 1 bitShift: b.  v := (self bitShift: b) + 1.  u := n bitShift: b.  fPlusN := f + n.  [ v >= fPlusN ] whileTrue: [ v := u \\ (u := v) ].  result := v - f.  (result2 := result + n) > 0 ifFalse: [ self error: 'no inverse' ].  ^result positive ifTrue: [ result ] ifFalse: [ result2 ]testAsDateAndTime  self assert: aTime asDateAndTime equals: DateAndTime current midnight + aTimemethodClass: aClass  ^self numLiterals > 0 ifTrue: [ self literalAt: self numLiterals put: aClass binding ]bitClear: aMask  ^(self bitOr: aMask) - aMaskusesPrimaryBytecodeSet  ^self header >= 0abstractMethod  ^self subclassResponsibilitytestSimpleCallCC  | x continuation |  x := self callcc: [:cc |  continuation := cc.        false ].  x ifFalse: [ continuation value: true ].  self assert: xprintOn: aStream  self outerContext ifNil: [ | selector class mclass |        self method == nil ifTrue: [ ^super printOn: aStream ].        class := self receiver class.        mclass := self methodClass.        selector := self selector ifNil: [ self method defaultSelector ].        aStream nextPutAll: class name.        mclass == class ifFalse: [ aStream nextPut: $(.              aStream nextPutAll: mclass name.              aStream nextPut: $) ].        aStream nextPutAll: '>>'.        aStream nextPutAll: selector.        selector = #doesNotUnderstand: ifTrue: [ aStream space.              (self tempAt: 1) selector printOn: aStream ] ] ifNotNil: [:outerContext |  aStream nextPutAll: closureOrNil printString , ' in '.        outerContext printOn: aStream ]remove: anObj oneStarWithTry: aTree continuation: oh  ^aTree ifNil: [ oh value: #absent ] ifNotNil: [ | car cdr naturalRecursion |        car := aTree value.        cdr := aTree nextLink.        naturalRecursion := [ | newCdr |        newCdr := self remove: anObj oneStarWithTry: cdr continuation: oh.        car ~~> newCdr ].        (car isMemberOf: ValueLink) ifTrue: [ Continuation try: [:ooh |  | newCar |                    newCar := self remove: anObj oneStarWithTry: car continuation: ooh.                    newCar ~~> cdr ] otherwise: naturalRecursion ] ifFalse: [ anObj = car ifTrue: [ cdr ] ifFalse: naturalRecursion ] ]collectionsPackages  ^(CollectionsAssembly parts collect: #key) reject: [:each |  each = #'Collections-Atomic' ]example2: anInteger  < sampleInstance>  | factorial trace |  trace := OrderedCollection new.  factorial := [:x :dumper :trace2 |  | localDumper |  localDumper := [:collection |  collection add: x.  dumper value: collection ].  x = 1 ifTrue: [ localDumper value: trace2.        1 ] ifFalse: [ (factorial value: x - 1 value: localDumper value: trace2) * x ] ].  factorial value: anInteger value: [:collection |   ] value: trace.  ^tracetestAsDate  self assert: aDateAndTime asDate equals: ('February 29, 2004' asDate translateTo: 2 hours)testConvertFromInteger  | sd |  sd := 13 asScaledDecimal.  self assert: 0 equals: sd scale.  self assert: '13s0' equals: sd printString.  sd := -13 asScaledDecimal.  self assert: 0 equals: sd scale.  self assert: '-13s0' equals: sd printString.  sd := 130000000013 asScaledDecimal.  self assert: 0 equals: sd scale.  self assert: '130000000013s0' equals: sd printString.  sd := -130000000013 asScaledDecimal.  self assert: 0 equals: sd scale.  self assert: '-130000000013s0' equals: sd printStringtestExampleFromSwikiPage  | sat shows |  sat := Year current asMonth dates detect: [:d |  d dayOfWeekName = #Saturday ].  sat := sat start + (Duration hours: 20.5).  shows := Schedule starting: sat ending: Year current end.  shows schedule: {(Duration days: 1) .         (Duration days: 6)}.  shows dateAndTimes.  shows dateAndTimes collect: [:dt |  dt dayOfWeekName ]dayOfYear  ^self dayMonthYearDo: [:d :m :y |  | monthStart |        monthStart := #(1 32 60 91 121 152 182 213 244 274 305 335) at: m.        (m > 2 and: [ Year isLeapYear: y ]) ifTrue: [ monthStart + d ] ifFalse: [ monthStart + d - 1 ] ]propertyAt: propName put: propValue  | propertiesOrSelector |  (propertiesOrSelector := self penultimateLiteral) isMethodProperties ifFalse: [ self penultimateLiteral: ((self class methodPropertiesClass selector: propertiesOrSelector with: (Association key: propName asSymbol value: propValue))                 setMethod: self;                 yourself).        ^propValue ].  (propertiesOrSelector includesProperty: propName) ifTrue: [ ^propertiesOrSelector at: propName put: propValue ].  self penultimateLiteral: (propertiesOrSelector copyWith: (Association key: propName asSymbol value: propValue)).  ^propValuetestIsDecimalDigit  self checkCorrespondanceOf: #isDecimalDigit: and: #NdtestIsOtherSymbol  self checkCorrespondanceOf: #isOtherSymbol: and: #SosecondsSinceMidnightUTC  ^secondstestIsEnclosingMark  self checkCorrespondanceOf: #isEnclosingMark: and: #MeshouldFileOutPool: aPoolName  ^self confirm: 'FileOut the sharedPool ' , aPoolName , '?'right: aNumber  ^origin corner: aNumber @ corner ytestBytecode  | method expectedResult |  method := Object >> #halt.  expectedResult := (method encoderClass name endsWith: 'SistaV1') ifTrue: [ #[16 129 216 88] ] ifFalse: [ #[64 209 135 120] ].  self assertCollection: (Object >> #halt) bytecode equals: expectedResult>= aMagnitude  ^aMagnitude <= selfat: index putLink: aLink  | previousLink nextLink |  (self validIndex: index) ifFalse: [ ^self errorOutOfBounds ].  index = 1 ifTrue: [ aLink nextLink: self firstLink nextLink.        firstLink := aLink.        aLink nextLink ifNil: [ lastLink := aLink ].        ^aLink ].  previousLink := self linkAt: index - 1.  nextLink := previousLink nextLink nextLink.  nextLink ifNil: [ aLink nextLink: self lastLink ] ifNotNil: [ aLink nextLink: nextLink ].  previousLink nextLink: aLink.  nextLink ifNil: [ lastLink := aLink.        aLink nextLink: nil ].  ^aLinkactivateReturn: aContext value: value  ^Processor activeProcess evaluate: [ suspendedContext := suspendedContext activateReturn: aContext value: value ] onBehalfOf: selfvalueSupplyingMetacelloAnswers: aListOfPairs  ^[ self value ] on: ProvideAnswerNotification do: [:notify |  | caption |        caption := notify messageText withSeparatorsCompacted.        aListOfPairs detect: [:each |  caption = each first or: [ (caption includesSubstring: each first caseSensitive: false) or: [ (each first match: caption) or: [ (String includesSelector: #matchesRegex:) and: [ [ caption matchesRegex: each first ] on: Error do: [:ignored |  false ] ] ] ] ] ] ifFound: [:answer |  notify resume: answer second ] ifNone: [ | outerAnswer |              outerAnswer := ProvideAnswerNotification signal: notify messageText.              outerAnswer ifNil: [ notify resume ] ifNotNil: [ notify resume: outerAnswer ] ] ]followingPc  ^self nextPc: (self method at: pc)successor  | ulp |  self isFinite ifFalse: [ (self isNaN or: [ self positive ]) ifTrue: [ ^self ].        ^Float fmax negated ].  self = 0.0 ifTrue: [ ^Float fmin ].  ulp := self ulp.  ^self + (0.5 * ulp) = self ifTrue: [ self + ulp ] ifFalse: [ self + (0.5 * ulp) ]readSlotNamed: aName  ^(self class slotNamed: aName) read: selfcondition: aBlock  condition := aBlockisNaN  ^falsetestSimpleIsNested  self assertSuccess: (ExceptionTester new runTest: #simpleIsNestedTest)criticClass  ^self methodClasssetUp  super setUp.  ticker := self classForTicker new.  suspendedDelaysHeap := self classForScheduler defaultSuspendedDelaysHeap.  scheduler := self classForScheduler onTicker: ticker suspendedDelaysHeap: suspendedDelaysHeap.  scheduler startTimerEventLoopPriority: Processor activePriority + 1.  DebugMe ifNil: [ DebugMe := false ].  scheduler debug: DebugMepointersTo  ^self pointersToExcept: #()at: anIndex put: anObject  | basicSize counter |  anIndex > 0 ifTrue: [ basicSize := self basicSize.        anIndex <= basicSize ifTrue: [ counter := 0.              1 to: basicSize do: [:i |  (self basicAt: i) == nil ifFalse: [ (counter := counter + 1) = anIndex ifTrue: [ ^self basicAt: i put: anObject ] ] ] ] ].  self error: 'access with an index out of bounds'printOn: stream base: base length: minimumLength padded: padWithZeroes  | n numberOfDigits totalLength divisor |  self < 0 ifTrue: [ n := self negated.        totalLength := 1 ] ifFalse: [ n := self.        totalLength := 0 ].  numberOfDigits := n numberOfDigitsInBase: base.  totalLength := totalLength + numberOfDigits.  padWithZeroes ifFalse: [ [ totalLength < minimumLength ] whileTrue: [ stream space.              totalLength := totalLength + 1 ] ].  n = self ifFalse: [ stream nextPut: $- ].  padWithZeroes ifTrue: [ [ totalLength < minimumLength ] whileTrue: [ stream nextPut: $0.              totalLength := totalLength + 1 ] ].  divisor := base raisedToInteger: numberOfDigits - 1.  [ divisor > 0 ] whileTrue: [ | digit |        digit := n // divisor.        stream nextPut: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: digit + 1).        n := n - (digit * divisor).        divisor := divisor // base ]methodName  ^'testMethod'indexOfLiteral: literal  2 to: self numLiterals - 1 do: [:index |  literal == (self objectAt: index) ifTrue: [ ^index - 1 ] ].  ^0testMonth  self assert: aTimespan month equals: 1.  self assert: aTimespan monthName equals: 'January'.  self assert: aTimespan monthIndex equals: 1decodeEmbeddedSourceZip  self decodeZipprecodeCommentOrInheritedCommentFor: selector  | aSuper aComment |  ^(aComment := self firstPrecodeCommentFor: selector) isEmptyOrNil ifTrue: [ (self == Behavior or: [ self superclass == nil or: [ (aSuper := self superclass whichClassIncludesSelector: selector) == nil ] ]) ifFalse: [ aSuper precodeCommentOrInheritedCommentFor: selector ] ] ifFalse: [ aComment ]asGlamorousArray  ^Array with: selfweakSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self weakSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: catassertCode: code print: aString  self assert: (self class evaluate: code) printString equals: aStringbasicSqueakToIso  self deprecated: 'Use #basicPharoToIso instead.' transformWith: '`@receiver basicSqueakToIso' -> '`@receiver basicPharoToIso'.  ^self basicPharoToIsoinitialize  self initializeTicker: DelayMicrosecondTicker new suspendedDelaysHeap: DelayBasicScheduler defaultSuspendedDelaysHeaplog  | res |  self <= 0 ifTrue: [ ^DomainError signal: 'log is only defined for x > 0' from: 0 ].  numerator < denominator ifTrue: [ ^self reciprocal log negated ].  res := super log.  res isFinite ifTrue: [ ^res ].  ^numerator log - denominator logtestIsLetterModifier  self checkCorrespondanceOf: #isLetterModifier: and: #LmtestParsingMMPatternWithSingleDigitFails  self assertReading: '04.2.2345' as: 'dd.mm.yyyy' raise: DateErrorsignalerContext  ^signalContext findContextSuchThat: [:context |  (context receiver == self or: [ context receiver == self class ]) not ]messageText  ^messageText ifNil: [ messageText := self standardMessageText ]testPrintStringNoOffset  | localOffsetHours localOffsetMinutes signString |  signString := DateAndTime localOffset hours positive ifTrue: [ '+' ] ifFalse: [ '-' ].  localOffsetHours := DateAndTime localOffset hours abs printStringPadded: 2.  localOffsetMinutes := DateAndTime localOffset minutes printStringPadded: 2.  self assert: '2002-05-16T17:20' asDateAndTime printString equals: ('2002-05-16T17:20:00{1}{2}:{3}' format: {signString .               localOffsetHours .               localOffsetMinutes}).  self assert: '2002-05-16T17:20:45' asDateAndTime printString equals: ('2002-05-16T17:20:45{1}{2}:{3}' format: {signString .               localOffsetHours .               localOffsetMinutes})hasMethodReturn  ^self compiledBlock hasMethodReturnwrappedInValueHolderIfNeeded  ^self asValueHoldertestContinuationExample1  | array |  array := (1 to: 20) asOrderedCollection.  self assert: (self continuationExample1: array) equals: arrayprintOn: aStream base: b nDigits: n  | halfPower half head tail |  n <= 1 ifTrue: [ n <= 0 ifTrue: [ self error: 'Number of digits n should be > 0' ].        ^aStream nextPut: (Character digitValue: self) ].  halfPower := n bitShift: -1.  half := b raisedToInteger: halfPower.  head := self quo: half.  tail := self - (head * half).  head printOn: aStream base: b nDigits: n - halfPower.  tail printOn: aStream base: b nDigits: halfPowertestArithmetic  | ts1 ts2 d |  ts1 := timespan + 2 days.  ts2 := ts1 - 2 days.  d := ts1 - (DateAndTime year: 2003 month: 03 day: 20).  self     assert: ts1 start equals: (DateAndTime year: 2003 month: 03 day: 24 hour: 12 minute: 0 second: 0);     assert: ts1 duration equals: timespan duration;     assert: ts2 start equals: timespan start;     assert: ts2 duration equals: timespan duration.  self assert: d equals: (Duration days: 4 hours: 12 minutes: 0 seconds: 0)testNegativeIntegerPrinting  self assert: (-2 printStringBase: 2) equals: '-10'.  self assert: (-2 radix: 2) equals: '-10'.  self assert: -2 printStringHex equals: '-2'.  self assert: (-2 storeStringBase: 2) equals: '-2r10'.  self assert: -2 storeStringHex equals: '-16r2'.  self assert: (-21 printStringBase: 3) equals: '-210'.  self assert: (-21 radix: 3) equals: '-210'.  self assert: -21 printStringHex equals: '-15'.  self assert: (-21 storeStringBase: 3) equals: '-3r210'.  self assert: -21 storeStringHex equals: '-16r15'.  self assert: (-228 printStringBase: 4) equals: '-3210'.  self assert: (-228 radix: 4) equals: '-3210'.  self assert: -228 printStringHex equals: '-E4'.  self assert: (-228 storeStringBase: 4) equals: '-4r3210'.  self assert: -228 storeStringHex equals: '-16rE4'.  self assert: (-2930 printStringBase: 5) equals: '-43210'.  self assert: (-2930 radix: 5) equals: '-43210'.  self assert: -2930 printStringHex equals: '-B72'.  self assert: (-2930 storeStringBase: 5) equals: '-5r43210'.  self assert: -2930 storeStringHex equals: '-16rB72'.  self assert: (-44790 printStringBase: 6) equals: '-543210'.  self assert: (-44790 radix: 6) equals: '-543210'.  self assert: -44790 printStringHex equals: '-AEF6'.  self assert: (-44790 storeStringBase: 6) equals: '-6r543210'.  self assert: -44790 storeStringHex equals: '-16rAEF6'.  self assert: (-800667 printStringBase: 7) equals: '-6543210'.  self assert: (-800667 radix: 7) equals: '-6543210'.  self assert: -800667 printStringHex equals: '-C379B'.  self assert: (-800667 storeStringBase: 7) equals: '-7r6543210'.  self assert: -800667 storeStringHex equals: '-16rC379B'.  self assert: (-16434824 printStringBase: 8) equals: '-76543210'.  self assert: (-16434824 radix: 8) equals: '-76543210'.  self assert: -16434824 printStringHex equals: '-FAC688'.  self assert: (-16434824 storeStringBase: 8) equals: '-8r76543210'.  self assert: -16434824 storeStringHex equals: '-16rFAC688'.  self assert: (-381367044 printStringBase: 9) equals: '-876543210'.  self assert: (-381367044 radix: 9) equals: '-876543210'.  self assert: -381367044 printStringHex equals: '-16BB3304'.  self assert: (-381367044 storeStringBase: 9) equals: '-9r876543210'.  self assert: -381367044 storeStringHex equals: '-16r16BB3304'.  self assert: (-9876543210 printStringBase: 10) equals: '-9876543210'.  self assert: (-9876543210 radix: 10) equals: '-9876543210'.  self assert: -9876543210 printStringHex equals: '-24CB016EA'.  self assert: (-9876543210 storeStringBase: 10) equals: '-9876543210'.  self assert: -9876543210 storeStringHex equals: '-16r24CB016EA'.  self assert: (-282458553905 printStringBase: 11) equals: '-A9876543210'.  self assert: (-282458553905 radix: 11) equals: '-A9876543210'.  self assert: -282458553905 printStringHex equals: '-41C3D77E31'.  self assert: (-282458553905 storeStringBase: 11) equals: '-11rA9876543210'.  self assert: -282458553905 storeStringHex equals: '-16r41C3D77E31'.  self assert: (-8842413667692 printStringBase: 12) equals: '-BA9876543210'.  self assert: (-8842413667692 radix: 12) equals: '-BA9876543210'.  self assert: -8842413667692 printStringHex equals: '-80AC8ECF56C'.  self assert: (-8842413667692 storeStringBase: 12) equals: '-12rBA9876543210'.  self assert: -8842413667692 storeStringHex equals: '-16r80AC8ECF56C'.  self assert: (-300771807240918 printStringBase: 13) equals: '-CBA9876543210'.  self assert: (-300771807240918 radix: 13) equals: '-CBA9876543210'.  self assert: -300771807240918 printStringHex equals: '-1118CE4BAA2D6'.  self assert: (-300771807240918 storeStringBase: 13) equals: '-13rCBA9876543210'.  self assert: -300771807240918 storeStringHex equals: '-16r1118CE4BAA2D6'.  self assert: (-11046255305880158 printStringBase: 14) equals: '-DCBA9876543210'.  self assert: (-11046255305880158 radix: 14) equals: '-DCBA9876543210'.  self assert: -11046255305880158 printStringHex equals: '-273E82BB9AF25E'.  self assert: (-11046255305880158 storeStringBase: 14) equals: '-14rDCBA9876543210'.  self assert: -11046255305880158 storeStringHex equals: '-16r273E82BB9AF25E'.  self assert: (-435659737878916215 printStringBase: 15) equals: '-EDCBA9876543210'.  self assert: (-435659737878916215 radix: 15) equals: '-EDCBA9876543210'.  self assert: -435659737878916215 printStringHex equals: '-60BC6392F366C77'.  self assert: (-435659737878916215 storeStringBase: 15) equals: '-15rEDCBA9876543210'.  self assert: -435659737878916215 storeStringHex equals: '-16r60BC6392F366C77'.  self assert: (-18364758544493064720 printStringBase: 16) equals: '-FEDCBA9876543210'.  self assert: (-18364758544493064720 radix: 16) equals: '-FEDCBA9876543210'.  self assert: -18364758544493064720 printStringHex equals: '-FEDCBA9876543210'.  self assert: (-18364758544493064720 storeStringBase: 16) equals: '-16rFEDCBA9876543210'.  self assert: -18364758544493064720 storeStringHex equals: '-16rFEDCBA9876543210'.  self assert: (-824008854613343261192 printStringBase: 17) equals: '-GFEDCBA9876543210'.  self assert: (-824008854613343261192 radix: 17) equals: '-GFEDCBA9876543210'.  self assert: -824008854613343261192 printStringHex equals: '-2CAB6B877C1CD2D208'.  self assert: (-824008854613343261192 storeStringBase: 17) equals: '-17rGFEDCBA9876543210'.  self assert: -824008854613343261192 storeStringHex equals: '-16r2CAB6B877C1CD2D208'.  self assert: (-39210261334551566857170 printStringBase: 18) equals: '-HGFEDCBA9876543210'.  self assert: (-39210261334551566857170 radix: 18) equals: '-HGFEDCBA9876543210'.  self assert: -39210261334551566857170 printStringHex equals: '-84D97AFCAE81415B3D2'.  self assert: (-39210261334551566857170 storeStringBase: 18) equals: '-18rHGFEDCBA9876543210'.  self assert: -39210261334551566857170 storeStringHex equals: '-16r84D97AFCAE81415B3D2'.  self assert: (-1972313422155189164466189 printStringBase: 19) equals: '-IHGFEDCBA9876543210'.  self assert: (-1972313422155189164466189 radix: 19) equals: '-IHGFEDCBA9876543210'.  self assert: -1972313422155189164466189 printStringHex equals: '-1A1A75329C5C6FC00600D'.  self assert: (-1972313422155189164466189 storeStringBase: 19) equals: '-19rIHGFEDCBA9876543210'.  self assert: -1972313422155189164466189 storeStringHex equals: '-16r1A1A75329C5C6FC00600D'.  self assert: (-104567135734072022160664820 printStringBase: 20) equals: '-JIHGFEDCBA9876543210'.  self assert: (-104567135734072022160664820 radix: 20) equals: '-JIHGFEDCBA9876543210'.  self assert: -104567135734072022160664820 printStringHex equals: '-567EF3C9636D242A8C68F4'.  self assert: (-104567135734072022160664820 storeStringBase: 20) equals: '-20rJIHGFEDCBA9876543210'.  self assert: -104567135734072022160664820 storeStringHex equals: '-16r567EF3C9636D242A8C68F4'.  self assert: (-5827980550840017565077671610 printStringBase: 21) equals: '-KJIHGFEDCBA9876543210'.  self assert: (-5827980550840017565077671610 radix: 21) equals: '-KJIHGFEDCBA9876543210'.  self assert: -5827980550840017565077671610 printStringHex equals: '-12D4CAE2B8A09BCFDBE30EBA'.  self assert: (-5827980550840017565077671610 storeStringBase: 21) equals: '-21rKJIHGFEDCBA9876543210'.  self assert: -5827980550840017565077671610 storeStringHex equals: '-16r12D4CAE2B8A09BCFDBE30EBA'.  self assert: (-340653664490377789692799452102 printStringBase: 22) equals: '-LKJIHGFEDCBA9876543210'.  self assert: (-340653664490377789692799452102 radix: 22) equals: '-LKJIHGFEDCBA9876543210'.  self assert: -340653664490377789692799452102 printStringHex equals: '-44CB61B5B47E1A5D8F88583C6'.  self assert: (-340653664490377789692799452102 storeStringBase: 22) equals: '-22rLKJIHGFEDCBA9876543210'.  self assert: -340653664490377789692799452102 storeStringHex equals: '-16r44CB61B5B47E1A5D8F88583C6'.  self assert: (-20837326537038308910317109288851 printStringBase: 23) equals: '-MLKJIHGFEDCBA9876543210'.  self assert: (-20837326537038308910317109288851 radix: 23) equals: '-MLKJIHGFEDCBA9876543210'.  self assert: -20837326537038308910317109288851 printStringHex equals: '-1070108876456E0EF115B389F93'.  self assert: (-20837326537038308910317109288851 storeStringBase: 23) equals: '-23rMLKJIHGFEDCBA9876543210'.  self assert: -20837326537038308910317109288851 storeStringHex equals: '-16r1070108876456E0EF115B389F93'.  self assert: (-1331214537196502869015340298036888 printStringBase: 24) equals: '-NMLKJIHGFEDCBA9876543210'.  self assert: (-1331214537196502869015340298036888 radix: 24) equals: '-NMLKJIHGFEDCBA9876543210'.  self assert: -1331214537196502869015340298036888 printStringHex equals: '-41A24A285154B026B6ED206C6698'.  self assert: (-1331214537196502869015340298036888 storeStringBase: 24) equals: '-24rNMLKJIHGFEDCBA9876543210'.  self assert: -1331214537196502869015340298036888 storeStringHex equals: '-16r41A24A285154B026B6ED206C6698'.  self assert: (-88663644327703473714387251271141900 printStringBase: 25) equals: '-ONMLKJIHGFEDCBA9876543210'.  self assert: (-88663644327703473714387251271141900 radix: 25) equals: '-ONMLKJIHGFEDCBA9876543210'.  self assert: -88663644327703473714387251271141900 printStringHex equals: '-111374860A2C6CEBE5999630398A0C'.  self assert: (-88663644327703473714387251271141900 storeStringBase: 25) equals: '-25rONMLKJIHGFEDCBA9876543210'.  self assert: -88663644327703473714387251271141900 storeStringHex equals: '-16r111374860A2C6CEBE5999630398A0C'.  self assert: (-6146269788878825859099399609538763450 printStringBase: 26) equals: '-PONMLKJIHGFEDCBA9876543210'.  self assert: (-6146269788878825859099399609538763450 radix: 26) equals: '-PONMLKJIHGFEDCBA9876543210'.  self assert: -6146269788878825859099399609538763450 printStringHex equals: '-49FBA7F30B0F48BD14E6A99BD8ADABA'.  self assert: (-6146269788878825859099399609538763450 storeStringBase: 26) equals: '-26rPONMLKJIHGFEDCBA9876543210'.  self assert: -6146269788878825859099399609538763450 storeStringHex equals: '-16r49FBA7F30B0F48BD14E6A99BD8ADABA'.  self assert: (-442770531899482980347734468443677777577 printStringBase: 27) equals: '-QPONMLKJIHGFEDCBA9876543210'.  self assert: (-442770531899482980347734468443677777577 radix: 27) equals: '-QPONMLKJIHGFEDCBA9876543210'.  self assert: -442770531899482980347734468443677777577 printStringHex equals: '-14D1A80A997343640C1145A073731DEA9'.  self assert: (-442770531899482980347734468443677777577 storeStringBase: 27) equals: '-27rQPONMLKJIHGFEDCBA9876543210'.  self assert: -442770531899482980347734468443677777577 storeStringHex equals: '-16r14D1A80A997343640C1145A073731DEA9'.  self assert: (-33100056003358651440264672384704297711484 printStringBase: 28) equals: '-RQPONMLKJIHGFEDCBA9876543210'.  self assert: (-33100056003358651440264672384704297711484 radix: 28) equals: '-RQPONMLKJIHGFEDCBA9876543210'.  self assert: -33100056003358651440264672384704297711484 printStringHex equals: '-6145B6E6DACFA25D0E936F51D25932377C'.  self assert: (-33100056003358651440264672384704297711484 storeStringBase: 28) equals: '-28rRQPONMLKJIHGFEDCBA9876543210'.  self assert: -33100056003358651440264672384704297711484 storeStringHex equals: '-16r6145B6E6DACFA25D0E936F51D25932377C'.  self assert: (-2564411043271974895869785066497940850811934 printStringBase: 29) equals: '-SRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-2564411043271974895869785066497940850811934 radix: 29) equals: '-SRQPONMLKJIHGFEDCBA9876543210'.  self assert: -2564411043271974895869785066497940850811934 printStringHex equals: '-1D702071CBA4A1597D4DD37E95EFAC79241E'.  self assert: (-2564411043271974895869785066497940850811934 storeStringBase: 29) equals: '-29rSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -2564411043271974895869785066497940850811934 storeStringHex equals: '-16r1D702071CBA4A1597D4DD37E95EFAC79241E'.  self assert: (-205646315052919334126040428061831153388822830 printStringBase: 30) equals: '-TSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-205646315052919334126040428061831153388822830 radix: 30) equals: '-TSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -205646315052919334126040428061831153388822830 printStringHex equals: '-938B4343B54B550989989D02998718FFB212E'.  self assert: (-205646315052919334126040428061831153388822830 storeStringBase: 30) equals: '-30rTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -205646315052919334126040428061831153388822830 storeStringHex equals: '-16r938B4343B54B550989989D02998718FFB212E'.  self assert: (-17050208381689099029767742314582582184093573615 printStringBase: 31) equals: '-UTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-17050208381689099029767742314582582184093573615 radix: 31) equals: '-UTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -17050208381689099029767742314582582184093573615 printStringHex equals: '-2FC8ECB1521BA16D24A69E976D53873E2C661EF'.  self assert: (-17050208381689099029767742314582582184093573615 storeStringBase: 31) equals: '-31rUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -17050208381689099029767742314582582184093573615 storeStringHex equals: '-16r2FC8ECB1521BA16D24A69E976D53873E2C661EF'.  self assert: (-1459980823972598128486511383358617792788444579872 printStringBase: 32) equals: '-VUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-1459980823972598128486511383358617792788444579872 radix: 32) equals: '-VUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -1459980823972598128486511383358617792788444579872 printStringHex equals: '-FFBBCDEB38BDAB49CA307B9AC5A928398A418820'.  self assert: (-1459980823972598128486511383358617792788444579872 storeStringBase: 32) equals: '-32rVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -1459980823972598128486511383358617792788444579872 storeStringHex equals: '-16rFFBBCDEB38BDAB49CA307B9AC5A928398A418820'.  self assert: (-128983956064237823710866404905431464703849549412368 printStringBase: 33) equals: '-WVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-128983956064237823710866404905431464703849549412368 radix: 33) equals: '-WVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -128983956064237823710866404905431464703849549412368 printStringHex equals: '-584120A0328DE272AB055A8AA003CE4A559F223810'.  self assert: (-128983956064237823710866404905431464703849549412368 storeStringBase: 33) equals: '-33rWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -128983956064237823710866404905431464703849549412368 storeStringHex equals: '-16r584120A0328DE272AB055A8AA003CE4A559F223810'.  self assert: (-11745843093701610854378775891116314824081102660800418 printStringBase: 34) equals: '-XWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-11745843093701610854378775891116314824081102660800418 radix: 34) equals: '-XWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -11745843093701610854378775891116314824081102660800418 printStringHex equals: '-1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.  self assert: (-11745843093701610854378775891116314824081102660800418 storeStringBase: 34) equals: '-34rXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -11745843093701610854378775891116314824081102660800418 storeStringHex equals: '-16r1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.  self assert: (-1101553773143634726491620528194292510495517905608180485 printStringBase: 35) equals: '-YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-1101553773143634726491620528194292510495517905608180485 radix: 35) equals: '-YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -1101553773143634726491620528194292510495517905608180485 printStringHex equals: '-B8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.  self assert: (-1101553773143634726491620528194292510495517905608180485 storeStringBase: 35) equals: '-35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -1101553773143634726491620528194292510495517905608180485 storeStringHex equals: '-16rB8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.  self assert: (-106300512100105327644605138221229898724869759421181854980 printStringBase: 36) equals: '-ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-106300512100105327644605138221229898724869759421181854980 radix: 36) equals: '-ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -106300512100105327644605138221229898724869759421181854980 printStringHex equals: '-455D441E55A37239AB4C303189576071AF5578FFCA80504'.  self assert: (-106300512100105327644605138221229898724869759421181854980 storeStringBase: 36) equals: '-36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -106300512100105327644605138221229898724869759421181854980 storeStringHex equals: '-16r455D441E55A37239AB4C303189576071AF5578FFCA80504'packages  ^self extendingPackages asSet copy     add: self package;     yourselfstandardMessageText  ^String streamContents: [:stream |  stream << 'primitive '.        stream print: self selector.        stream << ' in '.        stream print: self signaler class.        stream << ' failed' ]isSelfEvaluating  ^self isObsolete nothasLinks  self deprecated: 'use #hasMetaLinks' transformWith: '`@receiver hasLinks' -> '`@receiver hasMetaLinks'.  ^self hasMetaLinkssend: selector to: rcvr with: arguments lookupIn: lookupClass  | meth primIndex val ctxt |  (meth := lookupClass lookupSelector: selector) ifNil: [ ^self send: #doesNotUnderstand: to: rcvr with: {(Message selector: selector arguments: arguments)} lookupIn: lookupClass ].  (primIndex := meth primitive) > 0 ifTrue: [ val := self doPrimitive: primIndex method: meth receiver: rcvr args: arguments.        (self isPrimFailToken: val) ifFalse: [ ^val ] ].  (selector == #doesNotUnderstand: and: [ lookupClass == ProtoObject ]) ifTrue: [ ^self error: 'Simulated message ' , arguments first selector , ' not understood' ].  ctxt := Context sender: self receiver: rcvr method: meth arguments: arguments.  primIndex > 0 ifTrue: [ ctxt failPrimitiveWith: val ].  ^ctxtselectorsWithArgs: numberOfArgs  ^self selectors select: [:selector |  selector numArgs = numberOfArgs ]ceiling  browse  ^Smalltalk tools browser openOnClass: self classsetSender: newSender receiver: newReceiver method: newMethod arguments: arguments  sender := newSender.  receiver := newReceiver.  method := newMethod.  closureOrNil := nil.  pc := method initialPC.  self stackp: method numTemps.  1 to: arguments size do: [:i |  self at: i put: (arguments at: i) ]value  ^(Processor activeProcess psValueAt: index) ifNil: [ self default ]usesLocalPoolVarNamed: aString  ^falseactionForEvent: anEventSelector ifAbsent: anExceptionBlock  | actions |  actions := self actionMap at: anEventSelector asSymbol ifAbsent: [ nil ].  actions ifNil: [ ^anExceptionBlock value ].  ^actions asMinimalRepresentationnotify: aString at: location  self notify: aStringtestBadBase  self should: [ 2 printStringBase: 1 ] raise: ErrornonDeprecatedMethodName  ^'not' , self deprecatedMethodNametestIsLeapYear  self assert: (Year isLeapYear: 2000).  self deny: (Year isLeapYear: 2001).  self assert: (Year isLeapYear: 2004).  self deny: (Year isLeapYear: 2100).  self deny: (Year isLeapYear: 2002)testReadFromOffset  self assert: (DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream) offset printString equals: '-0:05:00:00'parseVariableDigitDay  day := self parse: 'day'testZero1  self assert: Float negativeZero equals: 0 asFloat.  self assert: (Float negativeZero at: 1) ~= (0 asFloat at: 1)epiceaBrowsersAsString  ^String streamContents: [:stream |  stream           nextPutAll: self asDate epiceaBrowsersAsString;           nextPutAll: ', '.        self asTime print24: false showSeconds: false on: stream ]withAllSuperAndSubclasses  ^self allSuperclasses , self withAllSubclassesisNil  ^falsedigitSum  ^self abs asString inject: 0 into: [:value :new |  value + new digitValue ]asText  ^self asString asTextspecies  ^TimespanargumentNamed: aSymbol  ^self argumentNamed: aSymbol ifNone: [ self error: 'No argument of this name.' ]anyProcessesAbove: highestPriority  ^(Process allInstances select: [:aProcess |  aProcess priority > highestPriority ]) isEmptytestDynamicVariableAccessFromDifferentProcess  | process sem result |  sem := Semaphore new.  process := [ TestDynamicVariable value: 123 during: [ sem wait ] ] fork.  Processor yield.  Processor activeProcess evaluate: [ result := TestDynamicVariable value ] onBehalfOf: process.  sem signal.  self assert: result equals: 123link: aMetaLink toMethodNamed: aMethodName  self link: aMetaLink toAST: (MetalinkTargetResolver methodNamed: aMethodName for: self)abstractBytecodeMessageAt: pc  ^[ (InstructionStream new method: self pc: pc) interpretNextInstructionFor: nil ] on: MessageNotUnderstood do: [:ex |  ex message ]classify: aSymbol under: aProtocolName  ^self classify: aSymbol under: aProtocolName suppressIfDefault: truelocalAt: aNumber put: anObject  ^self at: aNumber put: anObjectsizeOpcodeSelector: genSelector withArguments: args  stream := self.  position := 0.  self perform: genSelector withArguments: args.  ^positionundeclaredName  ^undeclaredNameaddDependent: anObject  | dependents |  dependents := self dependents.  (dependents includes: anObject) ifFalse: [ self myDependents: (dependents copyWithDependent: anObject) ].  ^anObjectinstallValue: anExecutionEnvironment intoForked: newProcess from: ownerProcess  super installValue: anExecutionEnvironment intoForked: newProcess from: ownerProcess.  anExecutionEnvironment prepareForNewProcess: newProcessretrySelector  ^retrySelectorcritical: mutuallyExcludedBlock  | blockValue caught |  caught := false.  [ caught := true.  self wait.  blockValue := mutuallyExcludedBlock value ] ensure: [ caught ifTrue: [ self signal ] ].  ^blockValuedigitValue  self asInteger > 255 ifTrue: [ ^self characterSet digitValueOf: self ].  ^DigitValues at: 1 + self asIntegerasTwoCharacterString  ^(self >= 0 and: [ self < 10 ]) ifTrue: [ '0' , self printString ] ifFalse: [ self printString copyFrom: 1 to: 2 ]classComment  ^self commentisEmpty  ^firstLink isNiltestIsEnclosingMark  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isEnclosingMark: ch) equals: (charset isEnclosingMark: ch) ]size  < primitive: 62>  self class isVariable ifFalse: [ self errorNotIndexable ].  ^0testLargePrimesUpTo  | nn |  nn := (2 raisedTo: 17) - 1.  self deny: (Integer primesUpTo: nn) last equals: nn.  self assert: (Integer primesUpTo: nn + 1) last equals: nngenJump: distance  (distance > 0 and: [ distance < 9 ]) ifTrue: [ stream nextPut: 144 + distance - 1.        ^self ].  ^self genJumpLong: distancegenUnsignedSingleExtendB: extendedIndex  (extendedIndex between: 0 and: 255) ifFalse: [ ^self outOfRangeError: 'index' index: extendedIndex range: 0 to: 255 ].  stream     nextPut: 225;     nextPut: extendedIndexthreeWayCompareTo: anotherObject  ^self = anotherObject ifTrue: [ 0 ] ifFalse: [ self < anotherObject ifTrue: [ -1 ] ifFalse: [ 1 ] ]testSetIsReadOnlyFailureProxy  self alwaysWritableObjects do: [:each |  self testProxyObject: each initialState: false tuples: #(#(true false false) #(false false false)) ]testPrintPaddedWithTo  self assert: (1.0 printPaddedWith: $0 to: 2.2) equals: '01.00'.  self assert: (1.0 printPaddedWith: $X to: 2.2) equals: 'X1.0X'.  self assert: (1.0 printPaddedWith: $0 to: 2) equals: '01.0'.  self assert: (12345.6789 printPaddedWith: $0 to: 2) equals: '12345.6789'.  self assert: (12345.6789 printPaddedWith: $0 to: 2.2) equals: '12345.6789'.  self assert: (12.34 printPaddedWith: $0 to: 2.2) equals: '12.34'.  self assert: (12345.6789 printPaddedWith: $0 to: 2.2) equals: '12345.6789'.  self assert: (123.456 printPaddedWith: $X to: 4.4) equals: 'X123.456X'.  self assert: (1.0 printPaddedWith: $0 to: 2.1) equals: '01.0'.  self assert: (1.0 printPaddedWith: $0 to: 2.2) equals: '01.00'.  self assert: (1.0 printPaddedWith: $0 to: 2.3) equals: '01.000'.  self assert: (1.0 printPaddedWith: $0 to: 2.4) equals: '01.0000'.  self assert: (1.0 printPaddedWith: $0 to: 2.5) equals: '01.00000'testMutateByteArrayUsingByteAtPut  | guineaPig |  guineaPig := ByteArray new: 5.  guineaPig beReadOnlyObject.  self should: [ guineaPig byteAt: 1 put: 12 ] raise: ModificationForbidden.  [ guineaPig byteAt: 1 put: 12 ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first equals: 12testWeekday  self assert: january23rd2004 weekday equals: #Friday.  self assert: january23rd2004 weekdayIndex equals: 6isSpLayout  ^falsetestAsUTC  self assert: aDateAndTime asUTC equals: aDateAndTimeisComposedBy: aTrait  aTrait isTrait ifFalse: [ ^false ].  ^self hasTraitComposition ifTrue: [ self traitComposition includesTrait: aTrait ] ifFalse: [ false ]asFunction  ^self asFunction: #()testTicks  self assert: aDateAndTime ticks equals: ((DateAndTime julianDayNumber: 2453065) + 41580 seconds) ticks.  self assert: aDateAndTime ticks equals: #(2453065 41580 0)basicCategory  ^categorynoteCompilationOfMethod: aCompiledMethod meta: isMeta  self noteCompilationOf: aCompiledMethod selector meta: isMetaat: aKey put: aValue  | keyAlreadyExists |  keyAlreadyExists := false.  1 to: self basicSize do: [:i |  | propertyOrPragma |        (propertyOrPragma := self basicAt: i) key == aKey ifTrue: [ keyAlreadyExists := true.              propertyOrPragma isVariableBinding ifTrue: [ propertyOrPragma value: aValue ] ifFalse: [ self basicAt: i put: aValue ] ] ].  keyAlreadyExists ifFalse: [ method propertyAt: aKey put: aValue ].  ^aValueinstallEnvIntoForked: newProcess  env ifNil: [ ^self ].  InheritablePSKeys ifNil: [ ^self ].  1 to: InheritablePSKeys size do: [:i |  | varIndex varValue |        varIndex := InheritablePSKeys at: i.        varIndex <= env size ifTrue: [ varValue := env at: varIndex.              varValue ifNotNil: [ (PSKeys at: varIndex) installValue: varValue intoForked: newProcess from: self ] ] ]isTestMethod  ^self subclassResponsibilityddmmyyyy  ^self printFormat: #(1 2 3 $/ 1 1)- operand  ^(operand respondsTo: #asDateAndTime) ifTrue: [ self start - operand ] ifFalse: [ self + operand negated ]/ operand  ^operand isNumber ifTrue: [ self class nanoSeconds: (self asNanoSeconds / operand) asInteger ] ifFalse: [ self asNanoSeconds / operand asDuration asNanoSeconds ]restartTop  suspendedContext privRefreshsetTraitComposition: aComposition  ^self subclassResponsibilityprintOn: aStream base: b  aStream nextPut: $-.  self abs printOn: aStream base: bnumTemps  ^(self header bitShift: -18) bitAnd: 16r3Fand: alternativeBlock  ^alternativeBlock valuetestWorkDatesDo  | count |  count := 0.  aTimespan workDatesDo: [:each |  count := count + 1 ].  self assert: count equals: 5testAsNanoSeconds  self assert: (Duration nanoSeconds: 1) asNanoSeconds equals: 1.  self assert: (Duration seconds: 1) asNanoSeconds equals: 1000000000.  self assert: aDuration asNanoSeconds equals: 93784000000005storeDataOn: aDataStream  | cntInstVars cntIndexedVars |  cntInstVars := self class instSize.  cntIndexedVars := self basicSize.  aDataStream beginInstance: self class size: cntInstVars + cntIndexedVars.  1 to: cntInstVars do: [:i |  aDataStream nextPut: (self instVarAt: i) ].  self class isBits ifFalse: [ 1 to: cntIndexedVars do: [:i |  aDataStream nextPut: (self basicAt: i) ] ]testTicksOffset  self assert: aDateAndTime equals: (aDateAndTime ticks: #(2415386 0 0) offset: DateAndTime localOffset)scanFor: scanBlock  | method encoderClass end byte |  method := self method.  end := method endPC.  encoderClass := method encoderClass.  [ pc <= end ] whileTrue: [ (scanBlock value: (byte := method at: pc)) ifTrue: [ ^true ].        pc := pc + (encoderClass bytecodeSize: byte) ].  ^falseinterpretNextSistaV1InstructionFor: client  | byte div16 offset method extA extB savedPC |  method := self method.  extA := extB := 0.  savedPC := pc.  [ byte := self method at: pc.  pc := pc + 1.  byte between: 16rE0 and: 16rE1 ] whileTrue: [ | extByte |        extByte := self method at: pc.        pc := pc + 1.        byte = 16rE0 ifTrue: [ extA := (extA bitShift: 8) + extByte ] ifFalse: [ extB := (extB = 0 and: [ extByte > 127 ]) ifTrue: [ extByte - 256 ] ifFalse: [ (extB bitShift: 8) + extByte ] ] ].  div16 := byte // 16.  offset := byte \\ 16.  div16 < 11 ifTrue: [ div16 < 6 ifTrue: [ div16 < 4 ifTrue: [ div16 < 2 ifTrue: [ div16 = 0 ifTrue: [ ^client pushReceiverVariable: offset ].                          ^client pushLiteralVariable: (method literalAt: offset + 1) ].                    ^client pushConstant: (method literalAt: byte \\ 32 + 1) ].              div16 = 4 ifTrue: [ offset < 12 ifTrue: [ ^client pushTemporaryVariable: offset ].                    offset = 12 ifTrue: [ ^client pushReceiver ].                    offset = 13 ifTrue: [ ^client pushConstant: true ].                    offset = 14 ifTrue: [ ^client pushConstant: false ].                    offset = 15 ifTrue: [ ^client pushConstant: nil ] ].              offset < 2 ifTrue: [ ^client pushConstant: offset ].              offset = 2 ifTrue: [ ^self interpretSistaV1ExtendedPush: extB for: client ].              offset = 3 ifTrue: [ ^client doDup ].              offset = 8 ifTrue: [ ^client methodReturnReceiver ].              offset = 9 ifTrue: [ ^client methodReturnConstant: true ].              offset = 10 ifTrue: [ ^client methodReturnConstant: false ].              offset = 11 ifTrue: [ ^client methodReturnConstant: nil ].              offset = 12 ifTrue: [ ^client methodReturnTop ].              offset = 13 ifTrue: [ ^client blockReturnConstant: nil ].              offset = 14 ifTrue: [ ^client blockReturnTop ].              offset = 15 ifTrue: [ ^client doNop ].              ^self unusedBytecode: client at: savedPC ].        div16 = 6 ifTrue: [ ^client send: (Smalltalk specialSelectorAt: offset + 1) super: false numArgs: (Smalltalk specialNargsAt: offset + 1) ].        div16 = 7 ifTrue: [ ^client send: (Smalltalk specialSelectorAt: offset + 17) super: false numArgs: (Smalltalk specialNargsAt: offset + 17) ].        ^client send: (method literalAt: offset + 1) super: false numArgs: div16 - 8 ].  div16 < 14 ifTrue: [ div16 = 11 ifTrue: [ offset < 8 ifTrue: [ ^client jump: offset + 1 ].              ^client jump: offset - 7 if: true ].        div16 = 12 ifTrue: [ offset < 8 ifTrue: [ ^client jump: offset + 1 if: false ].              ^client popIntoReceiverVariable: offset - 8 ].        offset < 8 ifTrue: [ ^client popIntoTemporaryVariable: offset ].        offset = 8 ifTrue: [ ^client doPop ].        offset = 9 ifTrue: [ ^client trap ].        ^self unusedBytecode: client at: savedPC ].  byte < 248 ifTrue: [ ^self interpretNext2ByteSistaV1Instruction: byte for: client extA: extA extB: extB startPC: savedPC ].  ^self interpretNext3ByteSistaV1Instruction: byte for: client extA: extA extB: extB startPC: savedPCinstanceVariables  self deprecated: 'Please use #instVarNames or #slotNames instead' transformWith: '`@receiver instanceVariables' -> '`@receiver instVarNames'.  ^self instVarNamesfindContextSuchThat: testBlock  | context |  context := self.  [ context isNil ] whileFalse: [ (testBlock value: context) ifTrue: [ ^context ].        context := context sender ].  ^nilnormal  | n d |  n := y negated @ x.  (d := n x * n x + (n y * n y)) = 0 ifTrue: [ ^-1 @ 0 ].  ^n / d sqrtmessageText  ^'This block accepts ' , (self printArgumentsCount: expectedArgumentsCount) , ', but was called with ' , (self printArgumentsCount: calledArgumentsCount) , '.'asString  ^self sourceCodetestLessThan  self assert: aDateAndTime < (aDateAndTime + '1:00:00:00').  self assert: aDateAndTime + -1 < aDateAndTimeinstanceVariablesString  ^String streamContents: [:stream |  self localSlots do: [:each |  stream nextPutAll: each name ] separatedBy: [ stream space ] ]isRingObject  ^falsegtInspectorTempNodes  ^self tempNames withIndexCollect: [:tempName :tempIndex |  GTInspectorContextNamedTempNode hostObject: self tempName: tempName tempIndex: tempIndex ]initialize  super initialize.  self setTop: 0 left: 0 bottom: 0 right: 0signFlag  ^self header < 0currentMillenium  ^(Date current year / 100) asInteger * 100testSize  self     assert: (DependentsArray with: nil) size equals: 0;     assert: (DependentsArray with: nil with: 1 with: nil) size equals: 1;     assert: (DependentsArray with: 1 with: 3) size equals: 2;     assert: (DependentsArray with: nil with: nil with: nil) size equals: 0methodWithNotification  MyTestNotification signal: self testStringlongPrintOn: aStream  self class allInstVarNames doWithIndex: [:title :index |  aStream           nextPutAll: title;           nextPut: $:;           space;           tab;           print: (self instVarAt: index);           cr ]startTimerEventLoop  self startTimerEventLoopPriority: Processor timingPrioritywhichClassDefinesInstVar: aString  ^self whichSuperclassSatisfies: [:aClass |  aClass instVarNames includes: aString ]testIsCasedLetter  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isCasedLetter: ch) equals: (charset isCasedLetter: ch) ]hasLiteralSuchThat: aBlock  1 to: self basicSize do: [:i |  | propertyOrPragma |        propertyOrPragma := self basicAt: i.        (propertyOrPragma isVariableBinding ifTrue: [ (aBlock value: propertyOrPragma key) or: [ (aBlock value: propertyOrPragma value) or: [ propertyOrPragma value isArray and: [ propertyOrPragma value hasLiteralSuchThat: aBlock ] ] ] ] ifFalse: [ propertyOrPragma hasLiteralSuchThat: aBlock ]) ifTrue: [ ^true ] ].  ^falsetestValueWithinTimingNestedOuter  | time |  time := [ [ 3 timesRepeat: [ [ 5 seconds asDelay wait ] valueWithin: 100 milliSeconds onTimeout: [  ] ] ] valueWithin: 150 milliSeconds onTimeout: [  ] ] durationToRun.  self assert: time > 100 milliSeconds.  self assert: time < 5000 milliSecondstestRounded  self assert: 0.9 rounded equals: 1.  self assert: 1.0 rounded equals: 1.  self assert: 1.1 rounded equals: 1.  self assert: -1.9 rounded equals: -2.  self assert: -2.0 rounded equals: -2.  self assert: -2.1 rounded equals: -2.  self assert: 1.5 rounded equals: 2.  self assert: -1.5 rounded equals: -2testSizeInMemoryOfCharacters  self assert: 0 asCharacter sizeInMemory isZero.  self assert: 255 asCharacter sizeInMemory isZero.  self assert: 256 asCharacter sizeInMemory isZero.  self assert: 16r10FFFF asCharacter sizeInMemory isZeronamedTempAt: index put: aValue  ^self tempNamed: (self tempNames at: index) put: aValuemax: aMagnitude  self > aMagnitude ifTrue: [ ^self ] ifFalse: [ ^aMagnitude ]montgomeryNumberOfDigits  ^(self bytesCount * 8 + (self montgomeryDigitLength - 1)) // self montgomeryDigitLengthhasClassSide  ^falsesubclass: aName uses: aTraitCompositionOrArray instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory  ^self subclass: aName uses: aTraitCompositionOrArray layout: self classLayout class slots: someInstanceVariableNames asSlotCollection classVariablesNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategoryasSymbol  ^Symbol internCharacter: selfresume  suspendSemaphore ifNil: [ ^self error: 'Not suspended' ].  suspendSemaphore signalallSelectorsInProtocol: aName  ^self withAllSuperclasses flatCollectAsSet: [:class |  class organization listAtCategoryNamed: aName ]embeddedSourceCode: aString  self clear.  data := aString asString.  kind := data isWideString ifTrue: [ #EmbeddedSourceWide ] ifFalse: [ #EmbeddedSource ].  self encodetriggerEvent: anEventSelector  ^(self actionForEvent: anEventSelector) valuetestDaysInMonth  self assert: aDateAndTime daysInMonth equals: 31testIsControlOther  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isControlOther: ch) equals: (charset isControlOther: ch) ]testDNU  self should: [ self runSimulated: [ self absentMethod ] ] raise: MessageNotUnderstoodsqrt  | squareRoot |  squareRoot := self asFraction sqrt.  ^squareRoot isFloat ifTrue: [ squareRoot ] ifFalse: [ squareRoot asScaledDecimal: scale ]brickValue: anObject withEnoughArguments: aCollection  ^selftestRemoveUptoLast  self assert: (self remove: #cookies uptoLast: (LinkedList new                 add: #cookies;                 add: #chocolate;                 add: #mints;                 add: #caramel;                 add: #delight;                 add: #ginger;                 add: #snaps;                 add: #desserts;                 add: #chocolate;                 add: #mousse;                 add: #vanilla;                 add: #ice;                 add: #cream;                 add: #German;                 add: #chocolate;                 add: #cake;                 add: #more;                 add: #cookies;                 add: #gingerbreadman;                 add: #chocolate;                 add: #chip;                 add: #brownies;                 yourself)) equals: (LinkedList new           add: #gingerbreadman;           add: #chocolate;           add: #chip;           add: #brownies;           yourself)manifestBuilderForRuleChecker: aRuleChecker  ^aRuleChecker manifestBuilderOfMethod: selfgtDisplayOn: stream  self method gtDisplayOn: stream.  stream space.  self printOn: streamtestBitLogic  | n |  1 to: 100 do: [:i |  self assert: ((1 bitShift: i) bitShift: i negated) equals: 1 ].  1 to: 100 do: [:i |  self assert: ((-1 bitShift: i) bitShift: i negated) equals: -1 ].  1 to: 100 do: [:i |  self assert: ((1 bitShift: i) bitAnd: -1) equals: (1 bitShift: i) ].  1 to: 100 do: [:i |  n := 1 bitShift: i.        self assert: (n bitAnd: n negated) equals: n ].  1 to: 100 do: [:i |  n := 1 bitShift: i.        self assert: n negated equals: (n bitXor: -1) + 1 ].  1 to: 100 do: [:i |  n := 1 bitShift: i.        self assert: n + (n bitXor: -1) equals: -1 ].  1 to: 100 do: [:i |  n := 1 bitShift: i.        self assert: n negated equals: (n bitXor: -1) + 1 ]withAllSubclasses  ^self allSubclasses     add: self;     yourselfisParagraphSeparator  ^self characterSet isParagraphSeparator: selfsizeReturnReceiver  ^self sizeOpcodeSelector: #genReturnReceiver withArguments: #()time  | encodedTime hours minutes secondsHalved seconds |  encodedTime := self low16Bits.  hours := encodedTime >> 11.  minutes := encodedTime >> 5 & 2r111111.  secondsHalved := encodedTime & 2r11111.  seconds := (secondsHalved * 2) floor.  ^Time hour: hours minute: minutes second: secondstestRefersToLiteralsReturnsTrueWhenLiteralIsInPragmaSelector  self assert: (self compiledMethod1 hasLiteralThorough: #pragma1:foo:)withoutOffset  ^self offset: 0referredInstVars  | allInstVarNames instVarNames |  allInstVarNames := self methodClass allInstVarNames.  self isReturnField ifTrue: [ ^Set with: (allInstVarNames at: self returnField + 1) ].  instVarNames := Set new.  self abstractBytecodeMessagesDo: [:msg |  (#(#popIntoReceiverVariable: #pushReceiverVariable: #storeIntoReceiverVariable:) includes: msg selector) ifTrue: [ instVarNames add: (allInstVarNames at: msg argument + 1) ] ].  ^instVarNamestestAsSmallerPowerOfTwo  self should: [ (2 raisedTo: 80) negated asSmallerPowerOfTwo ] raise: DomainError.  self should: [ -1 asSmallerPowerOfTwo ] raise: DomainError.  self should: [ 0 asSmallerPowerOfTwo ] raise: DomainError.  self assert: 1 asSmallerPowerOfTwo equals: 1.  self assert: 2 asSmallerPowerOfTwo equals: 2.  self assert: 3 asSmallerPowerOfTwo equals: 2.  self assert: 4 asSmallerPowerOfTwo equals: 4.  self assert: 5 asSmallerPowerOfTwo equals: 4.  self assert: ((2 raisedTo: 80) + 1) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (2 raisedTo: 80) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: ((2 raisedTo: 80) - 1) asSmallerPowerOfTwo equals: (2 raisedTo: 80 - 1)testUtcOffset  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1901-01-01T12:00:00+12:00' asDateAndTimetestCullCullCull  [  ] cull: 1 cull: 2 cull: 3.  [:x |   ] cull: 1 cull: 2 cull: 3.  [:x :y |   ] cull: 1 cull: 2 cull: 3.  [:x :y :z |   ] cull: 1 cull: 2 cull: 3.  self should: [ [:x :y :z :a |   ] cull: 1 cull: 2 cull: 3 ] raise: Error.  self should: [ [:x :y :z :a :b |   ] cull: 1 cull: 2 cull: 3 ] raise: Error.  self assert: ([ 0 ] cull: 1 cull: 2 cull: 3) equals: 0.  self assert: ([:x |  x ] cull: 1 cull: 2 cull: 3) equals: 1.  self assert: ([:x :y |  y ] cull: 1 cull: 2 cull: 3) equals: 2.  self assert: ([:x :y :z |  z ] cull: 1 cull: 2 cull: 3) equals: 3testReentrantBlockOldEnvironment  | fib |  fib := self constructFibonacciBlockInDeadFrame.  self should: [ fib value: 0 ] raise: self classForTestResult error.  self assert: (fib value: 1) equals: 1.  self assert: (fib value: 2) equals: 1.  self assert: (fib value: 3) equals: 2.  self assert: (fib value: 4) equals: 3.  self assert: (fib value: 5) equals: 5.  self assert: (fib value: 6) equals: 8timespans  ^timespans ifNil: [ timespans := OrderedCollection new ]defaultAction  UnhandledError signalForException: selftestAllMethods  | allMethods nonOverridenMethods |  allMethods := IdentitySet new     addAll: Object allMethods;     yourself.  self assert: (allMethods includesAll: Object methods).  nonOverridenMethods := OrderedCollection new.  ProtoObject selectorsAndMethodsDo: [:sel :method |  (Object includesSelector: sel) ifFalse: [ nonOverridenMethods add: method ] ].  self assert: (allMethods includesAll: nonOverridenMethods)digitDiv: arg neg: ng  < primitive: 'primDigitDivNegative' module: 'LargeIntegers'>  | quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |  arg = 0 ifTrue: [ ^(ZeroDivide dividend: self) signal ].  l := self bytesCount - arg bytesCount + 1.  l <= 0 ifTrue: [ ^Array with: 0 with: self ].  d := 8 - arg lastDigit highBitOfPositiveReceiver.  div := arg digitLshift: d.  div := div growto: div bytesCount + 1.  rem := self digitLshift: d.  rem bytesCount = self bytesCount ifTrue: [ rem := rem growto: self bytesCount + 1 ].  quo := Integer new: l neg: ng.  dl := div bytesCount - 1.  ql := l.  dh := div byteAt: dl.  dnh := dl = 1 ifTrue: [ 0 ] ifFalse: [ div byteAt: dl - 1 ].  1 to: ql do: [:k |  j := rem bytesCount + 1 - k.        (rem byteAt: j) = dh ifTrue: [ qhi := qlo := 15 ] ifFalse: [ t := ((rem byteAt: j) bitShift: 4) + ((rem byteAt: j - 1) bitShift: -4).              qhi := t // dh.              t := (t \\ dh bitShift: 4) + ((rem byteAt: j - 1) bitAnd: 15).              qlo := t // dh.              t := t \\ dh.              hi := qhi * dnh.              lo := qlo * dnh + ((hi bitAnd: 15) bitShift: 4).              hi := (hi bitShift: -4) + (lo bitShift: -8).              lo := lo bitAnd: 255.              r3 := j < 3 ifTrue: [ 0 ] ifFalse: [ rem byteAt: j - 2 ].              [ (t < hi or: [ t = hi and: [ r3 < lo ] ]) and: [ qlo := qlo - 1.                    lo := lo - dnh.                    lo < 0 ifTrue: [ hi := hi - 1.                          lo := lo + 256 ].                    hi >= dh ] ] whileTrue: [ hi := hi - dh ].              qlo < 0 ifTrue: [ qhi := qhi - 1.                    qlo := qlo + 16 ] ].        l := j - dl.        a := 0.        1 to: div bytesCount do: [:i |  hi := (div byteAt: i) * qhi.              lo := a + (rem byteAt: l) - ((hi bitAnd: 15) bitShift: 4) - ((div byteAt: i) * qlo).              rem byteAt: l put: lo - (lo // 256 * 256).              a := lo // 256 - (hi bitShift: -4).              l := l + 1 ].        a < 0 ifTrue: [ qlo := qlo - 1.              l := j - dl.              a := 0.              1 to: div bytesCount do: [:i |  a := (a bitShift: -8) + (rem byteAt: l) + (div byteAt: i).                    rem byteAt: l put: (a bitAnd: 255).                    l := l + 1 ] ].        quo byteAt: quo bytesCount + 1 - k put: (qhi bitShift: 4) + qlo ].  rem := rem digitRshift: d bytes: 0 lookfirst: dl.  ^Array with: quo with: reminstVarNameForIndex: index  | slot |  self deprecated: 'Please use the slot API directly'.  slot := self classLayout allSlots detect: [:each |  each isVirtual not and: [ each index = index ] ] ifNone: [ ^nil ].  ^slot namesetConfiguration: aString withInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setConfiguration: aString withBlock: selfinterpretV3PlusClosureJump  | byte |  byte := self method at: pc.  (byte between: 144 and: 151) ifTrue: [ pc := pc + 1.        ^byte - 143 ].  (byte between: 160 and: 167) ifTrue: [ pc := pc + 2.        ^(byte - 164) * 256 + (self method at: pc - 1) ].  ^niltestFailedCriticalSectionShouldUnblockWaitingOne  | lastCriticalExecuted semaphoreToHoldMutex processHoldingMutex |  lastCriticalExecuted := false.  semaphoreToHoldMutex := Semaphore new.  processHoldingMutex := self fork: [ [ mutex critical: [ semaphoreToHoldMutex wait.              self error: 'critical section failed' ] ] ifError: [  ] ].  self waitLastProcessLock.  self fork: [ mutex critical: [ lastCriticalExecuted := true ] ].  self waitLastProcessLock.  semaphoreToHoldMutex signal.  self waitLastProcessTerminate.  self assert: lastCriticalExecutedreActivate  self     suspend;     activatemethodClass  ^method methodClasscanBeRemoved  ^falseisTest  ^falsetruncated  ^self quo: 1sharedPools  ^sharedPools ifNil: [ sharedPools := OrderedCollection new ]allMethodsReadingSlot: aSlot  ^self withAllSubclasses flatCollect: [:class |  class methodsReadingSlot: aSlot ]arcTan: denominator  ^self asFloat arcTan: denominatorhours  ^self houruses: aTraitCompositionOrArray  ^self uses: aTraitCompositionOrArray slots: #()unicodeCategoryTableLookup: codePoint  ^self class unicodeCategoryTableLookup: codePointlogCr: aString  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver logCr: `@statements1' -> '`@receiver traceCr: `@statements1'.  self traceCr: aStringisTreeNodeModel  ^falsetestAsDuration  self assert: aTimespan asDuration equals: aWeekseconds  ^seconds rem: SecondsInMinutetestMonth  self assert: aDateAndTime month equals: 2.  self assert: aDateAndTime monthAbbreviation equals: 'Feb'.  self assert: aDateAndTime monthName equals: 'February'.  self assert: aDateAndTime monthIndex equals: 2newCallbackWithSignature: signature block: aBlock  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     newCallbackWithSignature: signature block: aBlock library: self ffiLibraryappendTo: aCollection  ^aCollection addLast: selfhasPragmaNamed: arg1  ^self subclassResponsibilityscaleBy: factor  ^(factor x * x) @ (factor y * y)testLn  self assert: (100 ln closeTo: 10 ln * 2).  self assert: ((2 raisedTo: Float emax + 3) ln closeTo: 2 ln * (Float emax + 3)) description: 'Integer>>ln should not overflow'withSide: side setTo: value  ^self perform: (#(withLeft: withRight: withTop: withBottom:) at: (#(left right top bottom) indexOf: side)) with: valuesearchFrom: aContext  signalContext := aContext contextTag* operand  ^self class nanoSeconds: (self asNanoSeconds * operand) asIntegerclassVarNamed: aString put: anObject  self writeClassVariableNamed: aString value: anObjectcanBeNonGlobalVarInitial  ^self characterSet canBeNonGlobalVarInitial: selfdegrees  | tan theta |  ^x = 0 ifTrue: [ y >= 0 ifTrue: [ 90.0 ] ifFalse: [ 270.0 ] ] ifFalse: [ tan := y asFloat / x asFloat.        theta := tan arcTan.        x >= 0 ifTrue: [ y >= 0 ifTrue: [ theta radiansToDegrees ] ifFalse: [ 360.0 + theta radiansToDegrees ] ] ifFalse: [ 180.0 + theta radiansToDegrees ] ]testForMilliseconds  | delay |  delay := Delay forMilliseconds: 1000.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: delay.  scheduler simulate_vmMilliseconds: 1099.  self deny: delay isExpired.  scheduler simulate_vmMilliseconds: 1100.  self assert: delay isExpiredseconds  ^Duration seconds: selfvariableReadNodes  ^self ast variableReadNodestestOffset  self assert: aDateAndTime offset equals: '0:00:00:00' asDuration.  self assert: (aDateAndTime offset: '-0:12:00:00') equals: '1900-12-31T12:00:00-12:00' asDateAndTime.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1901-01-01T12:00:00+12:00' asDateAndTimetestAnd  self deny: (false and: [ 'alternativeBlock' ])vmSimNextWakeupMilliseconds  ^vmSimNextWakeupTickhasSlot: aSlot  ^self allSlots identityIncludes: aSlotcriticTheNonMetaclassClass  ^self methodClass instanceSidetestEqualityClassSideMethod  | method1 method2 |  method1 := TestCase class compiler compile: 'aMethod'.  method2 := TestCase class compiler compile: 'aMethod'.  self assert: method1 equals: method2asYear  ^self asDateAndTime asYeartestOneGBAllocation  | sz array failed |  failed := false.  sz := 1024 * 1024 * 1024.  array := [ ByteArray new: sz ] on: OutOfMemory do: [:ex |  failed := true ].  self assert: (failed or: [ array size = sz ])messageText  ^messageText ifNil: [ messageText := self standardMessageText ]testNow  self deny: aDateAndTime equals: DateAndTime nowacceptDroppingMorph: transferMorph event: evt inMorph: dstListMorph  ^falsevalueWithArguments: anArray  | strongReceiver |  strongReceiver := self receiver.  (self ensureReceiverAndArguments: strongReceiver) ifFalse: [ ^nil ].  ^strongReceiver perform: selector withArguments: (self collectArguments: anArray)dist: aPoint  | dx dy |  dx := aPoint x - x.  dy := aPoint y - y.  ^(dx * dx + (dy * dy)) sqrtsetUp  super setUp.  restoredTimeZone := DateAndTime localTimeZone.  DateAndTime localTimeZone: (TimeZone timeZones detect: [:tz |  tz abbreviation = 'GMT' ]).  firstEvent := DateAndTime year: 2003 month: 1 day: 4 hour: 20 minute: 30.  aSchedule := Schedule starting: firstEvent duration: 52 weeks.  aSchedule schedule: {(Duration days: 1) .         (Duration days: 6)}join: aSequenceableCollection  ^self asString join: aSequenceableCollectiongenPushLiteral: literalIndex  literalIndex < 0 ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255 ].  literalIndex < 32 ifTrue: [ stream nextPut: 32 + literalIndex.        ^self ].  literalIndex < 64 ifTrue: [ stream           nextPut: 128;           nextPut: 128 + literalIndex.        ^self ].  literalIndex < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 96;           nextPut: literalIndex.        ^self ].  ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255suitableRulesFrom: aReRuleManager  ^aReRuleManager classRulesjulianDayOffset  ^((seconds + self offset asSeconds) / SecondsInDay) floorputSource: source withPreamble: preambleBlock  SourceFiles writeSource: source preamble: (String streamContents: preambleBlock) onSuccess: [:newSourcePointer :theChangesFileStream |  (SourceChunkWriteStream on: theChangesFileStream) nextPut: ' '.        self setSourcePointer: newSourcePointer ] onFail: [ self becomeForward: (self copyWithSource: source) ]gtInspectorInstanceVariablesIn: composite  < gtInspectorPresentationOrder: 21>  composite table     title: 'InstVars';     display: [ self class allInstVarNames sorted collect: [:each |  each -> (self instVarNamed: each) ] ];     column: 'Variable' evaluated: [:each |  each key ];     column: 'Value' evaluated: [:each |  each value ]dateParserClass  ^DateParserexternalProperties  | pragmas externalProperties |  pragmas := Pragma allNamed: #eProperty from: self class to: ProtoObject.  externalProperties := OrderedCollection new.  pragmas do: [:pragma |  [ externalProperties addAll: (pragma method valueWithReceiver: self arguments: #()) ] on: Exception do: [:ex |  ReExceptionStrategy current handle: ex about: self forProppertiesDo: [:prop |  externalProperties add: prop ] ] ].  ^externalPropertiesliteralAt: index  ^self objectAt: index + 1testMethodIsBottomContext  self     assert: aMethodContext bottomContext equals: aSender;     assert: aMethodContext secondFromBottom equals: aMethodContextdebug  ^self debugWithTitle: 'Debug'classVariableNamed: aString  ^self classPool associationAt: aString asSymbol ifAbsent: [ self error: 'no such class var' ]isPrime  ^self isProbablyPrimetestStart  | yyyy |  yyyy := DateAndTime now year.  self assert: Year current start equals: (DateAndTime year: yyyy month: 1 day: 1)testHash  self assert: aDateAndTime hash equals: (DateAndTime year: 1980 month: 1 day: 1) hashprintOn: aStream  aStream     nextPutAll: self class name;     nextPutAll: ' (';     nextPutAll: self name;     nextPutAll: ') - ';     print: self methodSelectors size;     nextPutAll: ' selector(s)'cos  ^self asFloat costestAsNumberWithoutDecimalPoint  | sd |  sd := '123s0' asNumber.  self assert: ScaledDecimal identicalTo: sd class.  self assert: sd scale equals: 0.  self assert: '123s0' equals: sd printStringvariableSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self variableSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: catsourceCode  ^self method sourceCodeisTitlecaseLetter  ^self characterSet isTitlecaseLetter: selfselectorsDo: selectorBlock  ^self methodDict keysDo: selectorBlock> aNumber  aNumber class = self class ifTrue: [ ^self asFraction > aNumber asFraction ].  ^self asFraction > aNumberorigin  ^self methodClass findOriginClassOf: selftestEveryDo  | count duration |  count := 0.  duration := 7 days.  aTimespan every: duration do: [:each |  count := count + 1 ].  self assert: count equals: 1testInjectingMultipleExceptionHandlersIntoRunningProcess  | error process lastHandler firstHandler sema started |  DefaultExecutionEnvironment beActive.  started := firstHandler := lastHandler := false.  sema := Semaphore new.  process := [ started := true.  sema wait.  error signal ] fork.  [ started ] whileFalse: [ Processor yield ].  process on: ZeroDivide do: [:err |  firstHandler := true ].  process on: Error do: [:err |  lastHandler := true ].  error := ZeroDivide new.  sema signal.  [ process isTerminated ] whileFalse: [ Processor yield ].  self assert: firstHandler.  self deny: lastHandler.  started := firstHandler := lastHandler := false.  sema := Semaphore new.  process := [ started := true.  sema wait.  error signal ] fork.  [ started ] whileFalse: [ Processor yield ].  process on: ZeroDivide do: [:err |  firstHandler := true ].  process on: Error do: [:err |  lastHandler := true ].  error := Error new.  sema signal.  [ process isTerminated ] whileFalse: [ Processor yield ].  self deny: firstHandler.  self assert: lastHandleronDNU: selector do: handleBlock  ^self on: MessageNotUnderstood do: [:exception |  exception message selector = selector ifTrue: [ handleBlock cull: exception ] ifFalse: [ exception pass ] ]renameProtocol: oldName into: newName  (self existsProtocolNamed: newName) ifTrue: [ self moveMethodsFrom: oldName to: newName.        self removeProtocolNamed: oldName ] ifFalse: [ ^(self protocolNamed: oldName)           name: newName;           yourself ]min: maxValue max: minValue  ^(self min: maxValue) max: minValuesignBit  ^0rangeForPC: aPC  ^(self sourceNodeForPC: aPC) debugHighlightRangefromSton: stonReader  stonReader parseListDo: [:each :index |  index = 1 ifTrue: [ x := each ].        index = 2 ifTrue: [ y := each ] ]interpretV3PlusClosureExtension: offset in: method for: client  | type offset2 byte2 byte3 byte4 |  offset <= 6 ifTrue: [ byte2 := method at: pc.        pc := pc + 1.        offset <= 2 ifTrue: [ type := byte2 // 64.              offset2 := byte2 \\ 64.              offset = 0 ifTrue: [ type = 0 ifTrue: [ ^client pushReceiverVariable: offset2 ].                    type = 1 ifTrue: [ ^client pushTemporaryVariable: offset2 ].                    type = 2 ifTrue: [ ^client pushConstant: (method literalAt: offset2 + 1) ].                    type = 3 ifTrue: [ ^client pushLiteralVariable: (method literalAt: offset2 + 1) ] ].              offset = 1 ifTrue: [ type = 0 ifTrue: [ ^client storeIntoReceiverVariable: offset2 ].                    type = 1 ifTrue: [ ^client storeIntoTemporaryVariable: offset2 ].                    type = 2 ifTrue: [ self error: 'illegalStore' ].                    type = 3 ifTrue: [ ^client storeIntoLiteralVariable: (method literalAt: offset2 + 1) ] ].              offset = 2 ifTrue: [ type = 0 ifTrue: [ ^client popIntoReceiverVariable: offset2 ].                    type = 1 ifTrue: [ ^client popIntoTemporaryVariable: offset2 ].                    type = 2 ifTrue: [ self error: 'illegalStore' ].                    type = 3 ifTrue: [ ^client popIntoLiteralVariable: (method literalAt: offset2 + 1) ] ] ].        offset = 3 ifTrue: [ ^client send: (method literalAt: byte2 \\ 32 + 1) super: false numArgs: byte2 // 32 ].        offset = 4 ifTrue: [ byte3 := method at: pc.              pc := pc + 1.              type := byte2 // 32.              type = 0 ifTrue: [ ^client send: (method literalAt: byte3 + 1) super: false numArgs: byte2 \\ 32 ].              type = 1 ifTrue: [ ^client send: (method literalAt: byte3 + 1) super: true numArgs: byte2 \\ 32 ].              type = 2 ifTrue: [ ^client pushReceiverVariable: byte3 ].              type = 3 ifTrue: [ ^client pushConstant: (method literalAt: byte3 + 1) ].              type = 4 ifTrue: [ ^client pushLiteralVariable: (method literalAt: byte3 + 1) ].              type = 5 ifTrue: [ ^client storeIntoReceiverVariable: byte3 ].              type = 6 ifTrue: [ ^client popIntoReceiverVariable: byte3 ].              type = 7 ifTrue: [ ^client storeIntoLiteralVariable: (method literalAt: byte3 + 1) ] ].        offset = 5 ifTrue: [ ^client send: (method literalAt: byte2 \\ 32 + 1) super: true numArgs: byte2 // 32 ].        offset = 6 ifTrue: [ ^client send: (method literalAt: byte2 \\ 64 + 1) super: false numArgs: byte2 // 64 ] ].  offset = 7 ifTrue: [ ^client doPop ].  offset = 8 ifTrue: [ ^client doDup ].  offset = 9 ifTrue: [ ^client pushActiveContext ].  byte2 := method at: pc.  pc := pc + 1.  offset = 10 ifTrue: [ ^byte2 < 128 ifTrue: [ client pushNewArrayOfSize: byte2 ] ifFalse: [ client pushConsArrayWithElements: byte2 - 128 ] ].  byte3 := method at: pc.  pc := pc + 1.  offset = 11 ifTrue: [ ^client callPrimitive: byte2 + (byte3 * 256) ].  offset = 12 ifTrue: [ ^client pushRemoteTemp: byte2 inVectorAt: byte3 ].  offset = 13 ifTrue: [ ^client storeIntoRemoteTemp: byte2 inVectorAt: byte3 ].  offset = 14 ifTrue: [ ^client popIntoRemoteTemp: byte2 inVectorAt: byte3 ].  byte4 := method at: pc.  pc := pc + 1.  ^client pushClosureCopyNumCopiedValues: (byte2 bitShift: -4) numArgs: (byte2 bitAnd: 16rF) blockSize: byte3 * 256 + byte4organization  ^organizationvariable  ^variablesubtractTime: timeAmount  ^self class seconds: self asSeconds - timeAmount asSecondstagWith: aSymbol  self protocol: aSymboltestLn  self assert: ((1 / 100) ln closeTo: -2 * 10 ln).  self assert: (((2 raisedTo: Float emax + 11) / 3) ln closeTo: (Float emax + 11) * 2 ln - 3 ln) description: 'Fraction>>ln should not overflow'.  self assert: ((3 / (2 raisedTo: Float precision - Float emin)) ln closeTo: (Float emin - Float precision) * 2 ln + 3 ln) description: 'Fraction>>ln should not underflow'genPushTemp: tempIndex  (tempIndex < 0 or: [ tempIndex > 63 ]) ifTrue: [ ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63 ].  tempIndex < 12 ifTrue: [ stream nextPut: 64 + tempIndex.        ^self ].  stream     nextPut: 229;     nextPut: tempIndexunion: aTimespan  | aBegin anEnd |  aBegin := self start min: aTimespan start.  anEnd := self end max: aTimespan end.  ^Timespan starting: aBegin ending: anEnd + DateAndTime clockPrecisiontestusingMethods  | result |  result := ChronologyConstants usingMethods.  self assert: (result includes: (Duration >> #asNanoSeconds) methodReference).  self assert: (result includes: (ClassTest >> #testSharedPoolOfVarNamed) methodReference)testIsBefore  | tzm8 tzp10 |  tzm8 := january23rd2004 translateTo: -8 hours.  tzp10 := january23rd2004 translateTo: 10 hours.  self     assert: (tzm8 isBefore: tzp10) not;     assert: (june2nd1973 isBefore: january23rd2004);     assert: (june2nd1973 isBefore: june2nd1973) notuntagFrom: aSymbol  self protocol = aSymbol ifTrue: [ self protocol: Protocol unclassified ]add: link after: otherLinkOrObject  | otherLink |  otherLink := self linkAt: (self indexOf: otherLinkOrObject).  ^self add: link afterLink: otherLinktestNotInstantiable  self should: [ Integer new ] raise: Exceptionoffset  ^offsetwaitTimeoutSeconds: anInteger onCompletion: completionBlock onTimeout: timeoutBlock  | d |  d := DelayWaitTimeout new setDelay: (anInteger * 1000 max: 0) forSemaphore: self.  ^d waitOnCompletion: completionBlock onTimeout: timeoutBlockhasPragmaNamed: aSymbol  ^self pragmas anySatisfy: [:pragma |  pragma selector = aSymbol ]isMessageSend  ^truewillJumpIfTrue  ^self method encoderClass isBranchIfTrueAt: pc in: self methodisTall  ^self height > self widthasMetacelloSemanticVersionNumber  ^MetacelloSemanticVersionNumber fromString: ''notifyOfChangedCategoryFrom: oldNameOrNil to: newNameOrNil  (self hasSubject and: [ oldNameOrNil ~= newNameOrNil ]) ifTrue: [ SystemAnnouncer uniqueInstance protocolRenamedFrom: oldNameOrNil to: newNameOrNil inClass: self subject.        SystemAnnouncer uniqueInstance classReorganized: self subject ]last  ^self lastLink valuecategories: anArray  | newCategories newStops newElements newElementsSet catName list runningTotal |  anArray size < 2 ifTrue: [ ^self ].  newCategories := Array new: anArray size.  newStops := Array new: anArray size.  newElements := OrderedCollection new: anArray size.  runningTotal := 0.  1 to: anArray size do: [:i |  catName := (anArray at: i) asSymbol.        list := self listAtCategoryNamed: catName.        newElements addAllLast: list.        newCategories at: i put: catName.        newStops at: i put: (runningTotal := runningTotal + list size) ].  newElements := newElements asArray.  newElementsSet := newElements asSet.  elementArray do: [:element |  (newElementsSet includes: element) ifFalse: [ ^self error: 'New categories must match old ones' ] ].  categoryArray := newCategories.  categoryStops := newStops.  elementArray := newElementssizePushInstVar: instVarIndex  ^self sizeOpcodeSelector: #genPushInstVar: withArguments: {instVarIndex}testAllInstances  self assert: UndefinedObject allInstances size = 1 description: 'There should be a single instance of UndefinedObject'.  self assert: (UndefinedObject allInstances includes: nil) description: 'nil should be an instance of UndefinedObject'isEmptyCategoryNumber: anInteger  | firstIndex lastIndex |  (anInteger < 1 or: [ anInteger > categoryStops size ]) ifTrue: [ ^true ].  firstIndex := self firstIndexOfCategoryNumber: anInteger.  lastIndex := self lastIndexOfCategoryNumber: anInteger.  ^firstIndex > lastIndexthreeDigitName  | units answer |  self = 0 ifTrue: [ ^'' ].  units := #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten' 'eleven' 'twelve' 'thirteen' 'fourteen' 'fifteen' 'sixteen' 'seventeen' 'eighteen' 'nineteen').  self > 99 ifTrue: [ answer := (units at: self // 100) , ' hundred'.        self \\ 100 = 0 ifFalse: [ answer := answer , ' ' , (self \\ 100) threeDigitName ].        ^answer ].  self < 20 ifTrue: [ ^units at: self ].  answer := #('twenty' 'thirty' 'forty' 'fifty' 'sixty' 'seventy' 'eighty' 'ninety') at: self // 10 - 1.  self \\ 10 = 0 ifFalse: [ answer := answer , '-' , (units at: self \\ 10) ].  ^answervoidCogVMState  < primitive: 215>  ^self flushCachereturn: value to: aSender  self releaseTo: aSender.  aSender ifNil: [ ^nil ].  ^aSender push: valuegenStoreLiteralVar: literalIndex  literalIndex < 0 ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255 ].  literalIndex < 64 ifTrue: [ stream           nextPut: 129;           nextPut: 192 + literalIndex.        ^self ].  literalIndex < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 224;           nextPut: literalIndex.        ^self ].  ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255testStoreOnRoundTrip  self assert: (self class compiler evaluate: 0.5s1 squared storeString) * 4 equals: 0.5s1 squared * 4.  self assert: 0.25s2 storeString equals: '0.25s2'daysLeftInYear  ^start daysLeftInYeartestReadsField  | method |  method := self class compiledMethodAt: #readX.  self assert: (method readsField: 4).  method := self class compiledMethodAt: #readXandY.  self assert: (method readsField: 5).  method := self class compiledMethodAt: #writeX.  self deny: (method readsField: 4).  method := self class compiledMethodAt: #writeXandY.  self deny: (method readsField: 4).  method := self class compiledMethodAt: #writeXandY.  self deny: (method readsField: 5)fork: aBlock at: priority  | newProcess |  newProcess := aBlock forkAt: priority named: testSelector.  forkedProcesses add: newProcess.  ^newProcesssetUp  super setUp.  aDateAndTime := DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours.  aTimeZone := TimeZone default.  aDuration := Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0bitStringLength  ^self bytesCount * 8 + (self positive ifTrue: [ 1 ] ifFalse: [ 0 ])copyWith: aPropertyOrPragma  | bs copy |  (Association == aPropertyOrPragma class or: [ Pragma == aPropertyOrPragma class ]) ifFalse: [ self error: self class name , ' instances should hold only Associations or Pragmas.' ].  copy := self class basicNew: (bs := self basicSize) + 1.  1 to: bs do: [:i |  copy basicAt: i put: (self basicAt: i) shallowCopy ].  copy basicAt: bs + 1 put: aPropertyOrPragma.  1 to: self class instSize do: [:i |  copy instVarAt: i put: (self instVarAt: i) ].  ^copyprivRefreshWith: aCompiledMethod  aCompiledMethod isCompiledMethod ifFalse: [ self error: 'method can only be set to aCompiledMethod' ].  method := aCompiledMethod.  [ closureOrNil == nil ] assert.  self privRefreshname  ^name ifNil: [ super name ]sourceCodeTemplate  ^'messageSelectorAndArgumentNames	"comment stating purpose of class-side message"	"scope: class-variables  &  class-instance-variables"					| temporary variable names |	statements'jsonOn: aRenderer  aRenderer dateAndTime: selfpcPreviousTo: pc  | scanner client prevPc |  pc > self endPC ifTrue: [ ^self endPC ].  scanner := InstructionStream on: self.  client := InstructionClient new.  [ scanner pc < pc ] whileTrue: [ prevPc := scanner pc.        scanner interpretNextInstructionFor: client ].  ^prevPcaddSelector: selector withMethod: compiledMethod  | priorMethodOrNil oldProtocol |  priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [ nil ].  oldProtocol := priorMethodOrNil ifNotNil: [ priorMethodOrNil protocol ].  self addSelectorSilently: selector withMethod: compiledMethod.  priorMethodOrNil ifNil: [ SystemAnnouncer uniqueInstance methodAdded: compiledMethod ] ifNotNil: [ SystemAnnouncer uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod oldProtocol: oldProtocol ]testBehaviorClassClassDescriptionMetaclassHierarchy  self assert: Class superclass identicalTo: ClassDescription.  self assert: Metaclass superclass identicalTo: ClassDescription.  self assert: ClassDescription superclass identicalTo: Behavior.  self assert: Behavior superclass equals: Object.  self assert: Class class class identicalTo: Metaclass.  self assert: Metaclass class class identicalTo: Metaclass.  self assert: ClassDescription class class identicalTo: Metaclass.  self assert: Behavior class class identicalTo: Metaclassarguments: anArray  arguments := WeakArray withAll: anArray.  shouldBeNil := Array withAll: (anArray collect: [:ea |  ea isNil ])superclass  ^superclasscomeFullyUpOnReload: smartRefStream  ^selftestListAtCategoryNamed  | methods |  methods := self organization listAtCategoryNamed: 'empty'.  self assertEmpty: methods.  methods := self organization listAtCategoryNamed: 'one'.  self assert: methods size equals: 1.  self assert: methods first equals: #oneromanDigits: digits for: base on: aStream  | n |  n := self \\ (base * 10) // base.  n = 9 ifTrue: [ ^aStream           nextPut: digits last;           nextPut: digits first ].  n = 4 ifTrue: [ ^aStream           nextPut: digits last;           nextPut: digits second ].  n > 4 ifTrue: [ aStream nextPut: digits second ].  n \\ 5 timesRepeat: [ aStream nextPut: digits last ]testInstVarNamedPut  | obj |  obj := ObjectMockForTest new.  self assert: (obj instVarNamed: 'variable') isNil.  obj instVarNamed: 'variable' put: 1.  self assert: (obj instVarNamed: 'variable') equals: 1.  self shouldnt: [ obj instVarNamed: 'variable' put: 1 ] raise: InstanceVariableNotFound.  self should: [ obj instVarNamed: 'timoleon' put: 1 ] raise: InstanceVariableNotFoundvalueWithEnoughArguments: anArray  | args |  anArray size == self numArgs ifTrue: [ ^self valueWithArguments: anArray ].  args := Array new: self numArgs.  args replaceFrom: 1 to: (anArray size min: args size) with: anArray startingAt: 1.  ^self valueWithArguments: argsclassBindingOf: varName  ^self bindingOf: varNamewithAtLeastNDigits: desiredLength  | new |  self size >= desiredLength ifTrue: [ ^self ].  new := self class new: desiredLength.  new replaceFrom: 1 to: self size with: self startingAt: 1.  ^newnotify: aString  Warning signal: aStringsharedPoolsString  ^String streamContents: [:stream |  self sharedPools do: [:each |  stream nextPutAll: (self environment keyAtIdentityValue: each ifAbsent: [ each isObsolete ifTrue: [ each name ] ifFalse: [ 'private' ] ]) ] separatedBy: [ stream space ] ]methods  self deprecated: 'Use #methodSelectors instead.' transformWith: '`@receiver methods' -> '`@receiver methodSelectors'.  ^self methodSelectorsbyteAt: index  < primitive: 60>  self bytesCount < index ifTrue: [ ^0 ] ifFalse: [ ^super at: index ]julianDayNumberUTC  ^julianDayNumbertestCopy  | copy |  copy := atPragma copy.  self deny: atPragma identicalTo: copy.  self assert: atPragma method identicalTo: copy method.  self assert: atPragma selector identicalTo: copy selector.  self assert: atPragma arguments identicalTo: copy argumentssubscript: anObject  subscript := anObjecttestAsDos  | remoteDatetime |  self assert: '21 May 2012 3:02:44 pm' asDateAndTime asDosTimestamp equals: 16r40B57856.  remoteDatetime := DateAndTime current offset: DateAndTime localOffset + 2 hours.  self assert: remoteDatetime asDosTimestamp equals: remoteDatetime asLocal asDosTimestampchangeFromCategorySpecs: categorySpecs  self internalChangeFromString: categorySpecssubclass: aSubclassSymbol uses: aTraitCompositionOrArray slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames package: aCategorySymbol  ^self subclass: aSubclassSymbol uses: aTraitCompositionOrArray layout: self classLayout class slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames category: aCategorySymbolhasTemporaryVariableNamed: aName  ^self tempNames includes: aNametestErrorWhenDayIsBeforeMonthStart  self should: [ DateAndTime year: 2004 month: 2 day: -1 ] raise: Error.  self should: [ DateAndTime year: 2004 month: 2 day: 0 ] raise: Error.  DateAndTime year: 2004 month: 2 day: 1isLarge  ^trueisEscape  ^char = $\minutes  ^self minutetestRaisedToInteger  self assert: (3.0s1 raisedToInteger: -1) scale equals: 1.  self assert: (3.0s1 raisedToInteger: -1) equals: 1 / 3.  self assert: (3.0s1 raisedToInteger: 0) scale equals: 1.  self assert: (3.0s1 raisedToInteger: 0) equals: 1.  self assert: (3.0s1 raisedToInteger: 1) scale equals: 1.  self assert: (3.0s1 raisedToInteger: 1) equals: 3.  self assert: (3.0s1 raisedToInteger: 2) scale equals: 1.  self assert: (3.0s1 raisedToInteger: 2) equals: 9asMargin  ^Margin fromNumber: selftestShallowCopy  self assert: nil shallowCopy isNilcompile: code  ^self compile: code notifying: niltestMinusADuration  self assert: aTimespan - aDay equals: anOverlappingTimespan.  self assert: aDisjointTimespan - aWeek equals: aTimespanhash  < primitive: 171>  ^self primitiveFailedinitialize  mightBeASquare  ^falsestoreOn: aStream  self shouldBePrintedAsLiteral ifTrue: [ self printOn: aStream ] ifFalse: [ aStream           nextPut: $(;           store: numerator;           nextPut: $/;           store: denominator;           nextPut: $s;           store: scale;           nextPut: $) ]isRealPrimitive  ^self isPrimitive and: [ self isQuick not ]tempNames  ^self sourceNodeExecuted scope allTempNamestestEmbeddingSourceCode: sourceCode  | trailer newTrailer |  trailer := CompiledMethodTrailer new.  trailer embeddedSourceCode: sourceCode.  newTrailer := trailer testEncoding.  self assert: (#(EmbeddedSource EmbeddedSourceWide) includes: trailer kind).  self assert: newTrailer sourceCode equals: sourceCode.  self assert: newTrailer endPC equals: 0isObsolete  ^self propertyAt: #obsolete ifAbsent: falseisExtensionProtocol  ^self name first = $*testBetweenAndDoDisjointWithSchedule  | count |  count := 0.  aSchedule between: (DateAndTime year: 2004 month: 4 day: 1) and: (DateAndTime year: 2004 month: 4 day: 30) do: [:each |  count := count + 1 ].  self assert: count equals: 0isDeprecated  ^self package isDeprecatedtestOR  self assert: false | true.  self deny: false | falsesetBaseline: aString withInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setBaseline: aString withBlock: selfallInstVarNamesEverywhere  ^self withAllSuperAndSubclasses flatCollectAsSet: [:cls |  cls instVarNames ]when: anEventSelector send: aMessageSelector to: anObject with: anArg  self when: anEventSelector evaluate: (WeakMessageSend receiver: anObject selector: aMessageSelector arguments: {anArg})parseVariableDigitMonth  month := self parse: 'month'testOffset  self assert: aDateAndTime offset equals: '0:00:00:00' asDuration.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1970-01-01T12:00:00+12:00' asDateAndTimeclassForScheduler  ^DelayBasicSchedulergpsExample1: aCollection  | gps i s |  gps := [:idx :exp :sum |  | cnt |  cnt := 1.  sum first value: 0.  [ idx first value: cnt.  sum first value: sum last value + exp last value.  cnt := cnt + 1.  cnt <= aCollection size ] whileTrue: [  ].  sum last value ].  ^gps value: (Array with: [:val |  i := val ] with: [ i ]) value: (Array with: [:val |  aCollection at: i put: val ] with: [ aCollection at: i ]) value: (Array with: [:val |  s := val ] with: [ s ])testSeconds  self assert: (Time readFrom: '20:33:14.321-05:00' readStream) asDuration seconds equals: 14comment  ^self methodClass firstPrecodeCommentFor: self selectormethodDictionary  ^self methodDictcanBeRemoved  ^self isEmptyasRingDefinition  ^self instanceSide asRingDefinition classSideifNotNil: aBlock  ^selfgtInspectorRawIn: composite  ^composite custom: GTObjectVariablesBrowser neworigin  ^origindefaultReturnValue  ^niltestArithmetic  | t1 t2 t3 |  t1 := time addSeconds: 70.  self     assert: t1 hours equals: 4;     assert: t1 minutes equals: 3;     assert: t1 seconds equals: 57.  t2 := t1 addTime: (self timeClass fromSeconds: 60 * 60 * 5).  self     assert: t2 hours equals: 9;     assert: t2 minutes equals: 3;     assert: t2 seconds equals: 57.  t3 := t2 subtractTime: (self timeClass fromSeconds: 60 * 60 * 5 + 70).  self assert: t3 equals: timevalueSelector  ^#valueallSlots  ^self classLayout allVisibleSlotsdoubleResumeTest  [ self doSomething.  MyResumableTestError signal.  self doSomethingElse.  MyResumableTestError signal.  self doYetAnotherThing ] on: MyResumableTestError do: [:ex |  ex resume ]asWeek  ^Week starting: selfreciprocal  numerator abs = 1 ifTrue: [ ^denominator * numerator ].  ^self class numerator: denominator denominator: numeratorexistsProtocolNamed: aProtocolName  ^self allProtocols anySatisfy: [:e |  e name = aProtocolName ]addToComposition: aTrait  self setTraitComposition: self traitComposition + aTraitcopyWithout: aPropertyOrPragma  | bs copy offset |  copy := self class basicNew: (bs := self basicSize) - ((self includes: aPropertyOrPragma) ifTrue: [ 1 ] ifFalse: [ 0 ]).  offset := 0.  1 to: bs do: [:i |  (self basicAt: i) = aPropertyOrPragma ifTrue: [ offset := 1 ] ifFalse: [ copy basicAt: i - offset put: (self basicAt: i) shallowCopy ] ].  1 to: self class instSize do: [:i |  copy instVarAt: i put: (self instVarAt: i) ].  ^copyprintOn: aStream format: formatArray  BasicDatePrinter default printDate: self format: formatArray on: aStreamnormalize  ^selfaddObsoleteSubclass: aClass  | obs |  obs := self basicObsoleteSubclasses at: self ifAbsent: [ WeakArray new ].  (obs includes: aClass) ifTrue: [ ^self ].  obs := obs copyWithout: nil.  obs := obs copyWith: aClass.  self basicObsoleteSubclasses at: self put: obstimesTwoPower: anInteger  < primitive: 554>  anInteger < -29 ifTrue: [ ^self * (2.0 raisedToInteger: anInteger) ].  anInteger < 0 ifTrue: [ ^self / (1 bitShift: 0 - anInteger) asFloat ].  anInteger < 30 ifTrue: [ ^self * (1 bitShift: anInteger) asFloat ].  ^self * (2.0 raisedToInteger: anInteger)obsoleteSubclasses  self isMetaclassOfClassOrNil ifTrue: [ ^#() ].  ^self instanceSide obsoleteSubclasses collect: [:aSubclass |  aSubclass classSide ]simpleNoTimeoutTest  [ self doSomething ] valueWithin: 1 day onTimeout: [ self doSomethingElse ]bitShift: shiftCount  | magnitudeShift |  magnitudeShift := self bitShiftMagnitude: shiftCount.  ^((self negative and: [ shiftCount negative ]) and: [ self anyBitOfMagnitudeFrom: 1 to: shiftCount negated ]) ifTrue: [ magnitudeShift - 1 ] ifFalse: [ magnitudeShift ]printStringOfTree: aValueLink  ^String streamContents: [:aStream |  self printStringOfTree: aValueLink onStream: aStream ]obsolete  bitAt: anInteger  | digitIndex bitIndex i |  digitIndex := (anInteger - 1) // 8 + 1.  digitIndex > self bytesCount ifTrue: [ ^1 ].  bitIndex := (anInteger - 1) \\ 8 + 1.  i := 1.  [ i = digitIndex ifTrue: [ ^(self byteAt: digitIndex) negated bitAt: bitIndex ].  (self byteAt: i) = 0 ] whileTrue: [ i := i + 1 ].  ^1 - ((self byteAt: digitIndex) bitAt: bitIndex)index  ^indexlink: aMetaLink toAST: aNode  aNode link: aMetaLinkmetacelloSemanticIntegerLessThanSelf: anInteger  ^self error: 'Invalid Metacello verson component - should be String or Integer.'testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 0.  self assert: aDateAndTime hour equals: aDateAndTime hoursprivateSetOrigin: topLeft  origin := topLeftprevious  ^self class starting: self start - 1= aCharacter  < primitive: 110>  ^self == aCharacterupperBound: anObject  upperBound := anObjecttestSchedulesFIFO  | semaphore waitingLongestResumed higherPriorityResumed |  waitingLongestResumed := higherPriorityResumed := false.  semaphore := Semaphore new.  [ semaphore wait.  waitingLongestResumed := true ] forkAt: Processor activeProcess priority + 10.  [ semaphore wait.  higherPriorityResumed := true ] forkAt: Processor activeProcess priority + 20.  self deny: waitingLongestResumed.  self deny: higherPriorityResumed.  semaphore signal.  self assert: waitingLongestResumed.  semaphore signal.  self assert: higherPriorityResumedat: index put: value  ^self basicAt: index put: valuetotalSeconds  ^nanos = 0 ifTrue: [ seconds ] ifFalse: [ self asNanoSeconds / 1e9 ]sortsBefore: otherPoint  ^y = otherPoint y ifTrue: [ x <= otherPoint x ] ifFalse: [ y <= otherPoint y ]cleanUp  readsRef: literalAssociation  (self localReadsRef: literalAssociation) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:cb |  cb readsRef: literalAssociation ]testMidnight  self assert: aDateAndTime midnight equals: aDateAndTimewaitProcessSuspend: aProcess  self waitFor: [ aProcess isSuspended ]addExclusion: exception  ^exclusions add: exceptiongreaseInteger  ^self truncatedtestRemoveClassSlot  | tutu slot1 slot2 |  tutu := testEnvironment at: #TUTU.  slot1 := #X => InstanceVariableSlot.  slot2 := #Y => InstanceVariableSlot.  tutu addClassSlot: slot1.  self assert: tutu class instVarNames equals: #(#X).  tutu addClassSlot: slot2.  self assert: tutu class instVarNames equals: #(#X #Y).  tutu removeClassSlot: slot2.  self assert: tutu class instVarNames equals: #(#X).  tutu removeClassSlot: slot1.  self assert: tutu class instVarNames equals: #()testBitXor  self assert: (2r1100 bitXor: 2r1010) equals: 2r0110indirectDeprecatedMethod  testFloorLog  self assert: (1 / 100 floorLog: 10) equals: -2.  self assert: ((2 raisedTo: Float emax + 11) / 3 floorLog: 10) = ((Float emax + 11) * 2 log - 3 log) floor description: 'Fraction>>log should not overflow'.  self assert: (3 / (2 raisedTo: Float precision - Float emin) floorLog: 10) = ((Float emin - Float precision) * 2 log + 3 log) floor description: 'Fraction>>log should not underflow'genStorePopInstVar: instVarIndex  instVarIndex >= 0 ifTrue: [ instVarIndex < 8 ifTrue: [ stream nextPut: 96 + instVarIndex.              ^self ].        instVarIndex < 64 ifTrue: [ stream                 nextPut: 130;                 nextPut: instVarIndex.              ^self ] ].  self genStorePopInstVarLong: instVarIndexsplit: aSequenceableCollection indicesDo: aBlock  | position |  position := 1.  aSequenceableCollection withIndexDo: [:element :idx |  (self value: element) ifTrue: [ aBlock value: position value: idx - 1.              position := idx + 1 ] ].  aBlock value: position value: aSequenceableCollection sizetestSizeInMemoryOfByteObjects  self assert: 'a' sizeInMemory equals: (self paddedByteStringSize: 1).  self assert: 'abcd' sizeInMemory equals: (self paddedByteStringSize: 4).  self assert: '' sizeInMemory equals: (self paddedByteStringSize: 0).  self assert: 'abcde' sizeInMemory equals: (self paddedByteStringSize: 5).  self assert: 'abcdefghi' sizeInMemory equals: (self paddedByteStringSize: 9)value: anObject1 value: anObject2  ^receiver perform: selector with: anObject1 with: anObject2sqrt  < primitive: 555>  | exp guess eps delta |  self <= 0.0 ifTrue: [ self = 0.0 ifTrue: [ ^0.0 ] ifFalse: [ ^DomainError signal: 'sqrt undefined for number less than zero.' ] ].  exp := self exponent // 2.  guess := self timesTwoPower: 0 - exp.  eps := guess * Epsilon.  eps := eps * eps.  delta := (self - (guess * guess)) / (guess * 2.0).  [ delta * delta > eps ] whileTrue: [ guess := guess + delta.        delta := (self - (guess * guess)) / (guess * 2.0) ].  ^guessregistrationsCompareEqual: aMetacelloProjectSpec  ^self = aMetacelloProjectSpechash  ^self identityHashdaysInMonth  ^self duration daysinitialize  super initialize.  semaphore := Semaphore forMutualExclusionsetBlessingInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setBlessing: selflink: aMetaLink toSlotNamed: aSlotName  self link: aMetaLink toSlot: (MetalinkTargetResolver slotNamed: aSlotName for: self)isExplicitlyRequired  ^self isExplicitlyRequired: self markerOrNilensureReceiver  self receiver ifNil: [ ^false ].  self receiver class isObsolete ifTrue: [ ^false ].  (self receiver isBehavior and: [ self receiver isObsolete ]) ifTrue: [ ^false ].  ^truehasLiteralSuchThat: aBlock  ^(aBlock value: self selector) or: [ arguments hasLiteralSuchThat: aBlock ]testYearDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 2004 day: 60 hour: 13 minute: 33 second: 0 offset: 2 hours)removeAll  | newSelf |  tally = 0 ifTrue: [ ^self ].  newSelf := self species newForCapacity: self basicSize.  self copyFrom: newSelftestYearMonthDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0)reflectivityDisabled  ^self hasPragmaNamed: #disableReflectivitydayMonthYearDo: aBlock  | l n i j monthDay month fullYear |  l := self julianDayNumber + 68569.  n := 4 * l // 146097.  l := l - ((146097 * n + 3) // 4).  i := 4000 * (l + 1) // 1461001.  l := l - (1461 * i // 4) + 31.  j := 80 * l // 2447.  monthDay := l - (2447 * j // 80).  l := j // 11.  month := j + 2 - (12 * l).  fullYear := 100 * (n - 49) + i + l.  ^aBlock value: monthDay value: month value: fullYearnumArgs: n  numArgs := nprintOn: aStream  | d h m s n |  d := self days abs.  h := self hours abs.  m := self minutes abs.  s := self seconds abs truncated.  n := self nanoSeconds abs.  self negative ifTrue: [ aStream nextPut: $- ].  d printOn: aStream.  aStream nextPut: $:.  h < 10 ifTrue: [ aStream nextPut: $0 ].  h printOn: aStream.  aStream nextPut: $:.  m < 10 ifTrue: [ aStream nextPut: $0 ].  m printOn: aStream.  aStream nextPut: $:.  s < 10 ifTrue: [ aStream nextPut: $0 ].  s printOn: aStream.  n = 0 ifFalse: [ | z ps |        aStream nextPut: $..        ps := n printString padLeftTo: 9 with: $0.        z := ps findLast: [:c |  c asciiValue > $0 asciiValue ].        ps from: 1 to: z do: [:c |  aStream nextPut: c ] ]deprecatedMethod3  self deprecated: 'Example of a deprecated method with transform' transformWith: '`@receiver deprecatedMethod3' -> '`@receiver deprecatedMethod3'testResumableOuter  | result |  result := [ Notification signal.  4 ] on: Notification do: [:ex |  ex outer.        ex return: 5 ].  self assert: result equals: 5abstractBytecodeMessagesFrom: startpc to: endpc do: aBlock  | scanner |  scanner := InstructionStream new method: self pc: startpc.  [ scanner pc <= endpc ] whileTrue: [ [ scanner interpretNextInstructionFor: nil ] on: MessageNotUnderstood do: [:ex |  aBlock value: ex message ] ]testCreationFromBytes3  | maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |  Smalltalk vm wordSize = 4 ifFalse: [ ^self skip ].  maxSmallInt := SmallInteger maxVal.  hexString := (maxSmallInt - 1) printStringHex.  self assert: hexString size equals: 8.  byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.  byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.  byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.  byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.  builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.  self assert: builtInteger equals: maxSmallInt - 1.  self assert: builtInteger class equals: SmallIntegerexponent  < primitive: 553>  | positive |  self >= 1.0 ifTrue: [ ^self floorLog: 2 ].  self > 0.0 ifTrue: [ positive := (1.0 / self) exponent.        self = (1.0 / (1.0 timesTwoPower: positive)) ifTrue: [ ^positive negated ] ifFalse: [ ^positive negated - 1 ] ].  self = 0.0 ifTrue: [ ^-1 ].  ^self negated exponenttestSupplyAnswerUsingRegexMatchOfQuestion  (String includesSelector: #matchesRegex:) ifFalse: [ ^self ].  self should: [ true = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('.*Smalltalk\?' true)) ]cull: arg1 cull: arg2  ^selector numArgs < 2 ifTrue: [ self cull: arg1 ] ifFalse: [ self value: arg1 value: arg2 ]when: anEventSelector send: aMessageSelector to: anObject  self when: anEventSelector evaluate: (WeakMessageSend receiver: anObject selector: aMessageSelector)testMinus  self assert: aDateAndTime - aDateAndTime equals: '0:00:00:00' asDuration.  self assert: aDateAndTime - '0:00:00:00' asDuration equals: aDateAndTime.  self assert: aDateAndTime - aDuration equals: (DateAndTime year: 1979 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours)adaptToFraction: rcvr andCompare: selector  ^self adaptToFraction: rcvr andSend: selectorasFileNameCompatibleString  | stream |  stream := String new writeStream.  self printYMDOn: stream.  stream << '.'.  self printHMSWithDashesOn: stream.  ^stream contentsvalue  ^valuedependents  ^self myDependents ifNil: [ #() ]skipBackBeforeJump  | scanner client prevPc |  scanner := InstructionStream on: self method.  client := InstructionClient new.  [ scanner pc < pc ] whileTrue: [ prevPc := scanner pc.        scanner interpretNextInstructionFor: client ].  scanner pc: prevPc.  (scanner willJumpIfTrue or: [ scanner willJumpIfFalse ]) ifFalse: [ self error: 'Where''s the jump??' ].  self jump: prevPc - pctestAsTime  self assert: aDateAndTime asTime equals: Time midnightrandomCharacterAtOrAbove: lower  ^self randomCharacterBetween: lower and: Unicode maxValuetearDown  RPackage organizer unregisterPackageNamed: self categoryNameForTemporaryClasses.  super tearDownhasAtLeastTheSamePropertiesAs: aMethodProperties  aMethodProperties keysAndValuesDo: [:k :v |  (v isKindOf: Pragma) ifFalse: [ (self includes: k -> v) ifFalse: [ ^false ] ] ].  ^trueprintSeparatedBy: aDelimiter every: offset signed: printSigned on: aStream  ^self printSeparatedBy: aDelimiter every: offset signed: printSigned base: 10 on: aStreamsetMethod: aMethod  method := aMethod.  1 to: self basicSize do: [:i |  | propertyOrPragma |        (propertyOrPragma := self basicAt: i) isVariableBinding ifFalse: [ propertyOrPragma method: aMethod ] ]fuelAccept: aGeneralMapper  ^self <= 4294967295 ifTrue: [ aGeneralMapper mapAndTraceByClusterName: self to: FLPositive32SmallIntegerCluster ] ifFalse: [ aGeneralMapper visitBytesObject: self ]findGlobalVariable: lookupBlock ifNone: notFoundBlock  | var |  var := OCLiteralVariable new.  var scope: self.  self classPool associationsDo: [:assoc |  var assoc: assoc.        (lookupBlock value: var) ifTrue: [ ^var ] ].  self sharedPools do: [:pool |  pool classPool associationsDo: [:assoc |  var assoc: assoc.              (lookupBlock value: var) ifTrue: [ ^var ] ] ].  self environment associationsDo: [:assoc |  var assoc: assoc.        (lookupBlock value: var) ifTrue: [ ^var ] ].  ^notFoundBlock valuehaltIfNotTest  < debuggerCompleteToSender>  Halt ifNotTestintervalString  | d |  d := self asDuration.  ^String streamContents: [:s |  d hours > 0 ifTrue: [ s                 print: d hours;                 nextPutAll: ' hours' ].        d minutes > 0 ifTrue: [ s                 space;                 print: d minutes;                 nextPutAll: ' minutes' ].        d seconds > 0 ifTrue: [ s                 space;                 print: d seconds;                 nextPutAll: ' seconds' ] ]testParsingYYYYPatternWithWrongNumberOrDigitsShouldFails  self assertReading: '02.11.3' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.11.13' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.11.113' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.11.10113' as: 'dd.mm.yyyy' raise: DateErrorlocalSize  ^self sizetestAsSmallerPowerOfTwo  self assert: (1 / 2) asSmallerPowerOfTwo equals: 1 / 2.  self assert: (Fraction numerator: 2 denominator: 4) asSmallerPowerOfTwo equals: 1 / 2.  self assert: (2 / 5) asSmallerPowerOfTwo equals: 1 / 4.  self assert: (Fraction numerator: 10 denominator: 25) asSmallerPowerOfTwo equals: 1 / 4.  self assert: (Fraction numerator: 2 denominator: 1) asSmallerPowerOfTwo equals: 2.  self assert: (Fraction numerator: 4 denominator: 2) asSmallerPowerOfTwo equals: 2.  self assert: (11 / 2) asSmallerPowerOfTwo equals: 4.  self assert: (Fraction numerator: 44 denominator: 8) asSmallerPowerOfTwo equals: 4.  self assert: (1 / (2 raisedTo: 80)) asSmallerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160)) asSmallerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (1 / ((2 raisedTo: 80) - 1)) asSmallerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160) - 1) asSmallerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: 1) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 160) denominator: (2 raisedTo: 80)) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) + 1 denominator: 1) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 160) + 1 denominator: (2 raisedTo: 80)) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self should: [ (Fraction numerator: 0 denominator: 1) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 negated denominator: 2) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 denominator: 2 negated) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 2 negated denominator: 4) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 2 denominator: 4 negated) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 negated denominator: (2 raisedTo: 80)) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 denominator: (2 raisedTo: 80) negated) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: (2 raisedTo: 80) negated denominator: (2 raisedTo: 160)) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160) negated) asSmallerPowerOfTwo ] raise: DomainErrortempsAndValuesLimitedTo: sizeLimit indent: indent  ^String streamContents: [:aStream |  self tempNames do: [:name |  indent timesRepeat: [ aStream tab ].              aStream                 nextPutAll: name;                 nextPut: $:;                 space;                 tab.              aStream nextPutAll: ((self tempNamed: name) printStringLimitedTo: (sizeLimit - 3 - name size max: 1)) ] separatedBy: [ aStream cr ] ]isSelfEvaluating  ^truegenSendSpecial: specialSelectorIndex numArgs: nArgs  self assert: (specialSelectorIndex between: 1 and: Smalltalk specialSelectorSize).  self assert: nArgs = (Smalltalk specialNargsAt: specialSelectorIndex).  stream nextPut: specialSelectorIndex + 95asFloat  | a b mantissa exponent hasTruncatedBits lostBit n ha hb hm |  a := numerator abs.  b := denominator.  ha := a highBitOfMagnitude.  hb := b highBitOfMagnitude.  n := 1 + Float precision.  (ha < n and: [ hb < n ]) ifTrue: [ ^numerator asFloat / denominator asFloat ].  exponent := ha - hb - n.  exponent >= 0 ifTrue: [ b := b bitShift: exponent ] ifFalse: [ a := a bitShift: exponent negated ].  mantissa := a quo: b.  hasTruncatedBits := a > (mantissa * b).  hm := mantissa highBit.  lostBit := Float emin - (exponent + hm - 1).  lostBit > 0 ifTrue: [ n := n - lostBit max: 1 ].  hm > n ifTrue: [ exponent := exponent + hm - n.        hasTruncatedBits := hasTruncatedBits or: [ mantissa anyBitOfMagnitudeFrom: 1 to: hm - n ].        mantissa := mantissa bitShift: n - hm ].  (hasTruncatedBits and: [ mantissa odd ]) ifTrue: [ mantissa := mantissa + 1 ].  ^(self positive ifTrue: [ mantissa asFloat ] ifFalse: [ mantissa asFloat negated ]) timesTwoPower: exponenttestReciprocal  self     assert: (1 / 2) reciprocal equals: 2;     assert: (3 / 4) reciprocal equals: 4 / 3;     assert: (-1 / 3) reciprocal equals: -3;     assert: (-3 / 5) reciprocal equals: -5 / 3shouldBeSubstitutedByCleanCopy  ^self isCleanallSlots  ^#()repeatWithGCIf: testBlock  | ans |  ans := self value.  (testBlock value: ans) ifTrue: [ Smalltalk garbageCollect.        ans := self value ].  ^anstestMutateObjectInstVarUsingAtPut  | guineaPig |  guineaPig := Array new: 5.  guineaPig beReadOnlyObject.  self should: [ guineaPig at: 1 put: #test ] raise: ModificationForbidden.  [ guineaPig at: 1 put: #test ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first equals: #testgtInspectorSourceCodeIn: composite  minutes  ^self asDuration minutestestDegreeSin  (4 / 3) degreeSin.  -361 / 3 to: 359 / 3 do: [:i |  self assert: (i degreeSin closeTo: i degreesToRadians sin) ]testSuperclassOrderPreservingOrder  | noHierarchicalRelationship ordered |  noHierarchicalRelationship := {CharacterSet .   WideCharacterSet .   OrderedDictionary .   DependentsArray .   Bag .   SmallDictionary .   SequenceableCollection .   HashedCollection .   WeakRegistry .   Heap}.  ordered := Class superclassOrder: noHierarchicalRelationship.  self assert: ordered equals: noHierarchicalRelationship asOrderedCollectiondefinitionForNautilus  ^self definitionbetween: min and: max  ^self >= min and: [ self <= max ]testAsDateAndTime  self assert: aTimespan asDateAndTime equals: jan01dayOfWeekName  ^start dayOfWeekNametestAsHours  self assert: (Duration hours: 2) asHours equals: 2.  self assert: (Duration days: 1) asHours equals: 24.  self assert: (aDuration asHours closeTo: 26.0511)testNotNil  self deny: nil notNil> aCharacter  ^self asciiValue > aCharacter asciiValuesourceNode  ^self method sourceNodeForPC: self startpc - 1propertyAt: propName  ^self propertyAt: propName ifAbsent: [ nil ]asPoint  ^self @ self= anObject  ^anObject isMessageSend and: [ self receiver == anObject receiver and: [ selector == anObject selector and: [ (Array withAll: arguments) = (Array withAll: anObject arguments) ] ] ]forkAndWait  | semaphore |  semaphore := Semaphore new.  [ self ensure: [ semaphore signal ] ] fork.  semaphore waitprintYMDOn: aStream withLeadingSpace: printLeadingSpaceToo  | year month day |  self dayMonthYearDo: [:d :m :y |  year := y.        month := m.        day := d ].  year negative ifTrue: [ aStream nextPut: $- ] ifFalse: [ printLeadingSpaceToo ifTrue: [ aStream space ] ].  year abs printOn: aStream base: 10 length: 4 padded: true.  aStream nextPut: $-.  month printOn: aStream base: 10 length: 2 padded: true.  aStream nextPut: $-.  day printOn: aStream base: 10 length: 2 padded: truenewValue  ^newValuedecodeExtendedKind  self shouldBeImplementedbrowse  ^Smalltalk tools browser openOnClass: self methodClass selector: self selectorchangeFromString: aString  | categorySpecs |  categorySpecs := aString parseLiterals.  (categorySpecs isEmpty and: [ self protocolOrganizer protocols isEmpty ]) ifTrue: [ ^self protocolOrganizer reset ].  ^self changeFromCategorySpecs: categorySpecsbasicIdentityHash  < primitive: 171>  ^self primitiveFailedabstractBytecodeMessagesFrom: startpc to: endpc  | scanner abstractBytecodes |  scanner := InstructionStream new method: self pc: startpc.  abstractBytecodes := OrderedCollection new.  [ scanner pc <= endpc ] whileTrue: [ [ scanner interpretNextInstructionFor: nil ] on: MessageNotUnderstood do: [:ex |  abstractBytecodes add: ex message ] ].  ^abstractBytecodesisLeapYear  ^Year isLeapYear: self yearceiling  self isIntegerRectangle ifTrue: [ ^self ].  ^origin ceiling corner: corner ceilingtestReadFromDefaultOffsetNotSpecified  self assert: (DateAndTime readFrom: '2016-07-03T21:16:16.708241' readStream defaultOffset: Duration zero) offset equals: Duration zerotestPlus  self assert: aDuration + 0 hours equals: aDuration.  self assert: aDuration + aDuration equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10)shouldTransform  self class activateTransformations ifFalse: [ ^false ].  (condition isNil or: [ condition cull: self ]) ifFalse: [ ^false ].  ^rule isNotNiladdMethod: aSymbol  self deprecated: 'Use #addMethodSelector: instead' transformWith: '`@receiver addMethod: `@arg' -> '`@receiver addMethodSelector: `@arg'.  ^self addMethodSelector: aSymbolvalue: firstArg value: secondArg value: thirdArg value: fourthArg  < primitive: 205>  numArgs ~= 4 ifTrue: [ self numArgsError: 4 ].  ^self primitiveFailedstartUp  startUp  self resumeflipBy: direction centerAt: c  direction == #vertical ifTrue: [ ^x @ (c y * 2 - y) ].  direction == #horizontal ifTrue: [ ^(c x * 2 - x) @ y ].  self error: 'unrecognizable direction'testHandlingExceptionSetWithExclusion  | wasHandled |  wasHandled := false.  self should: [ [ ZeroDivide signalWithDividend: 1 ] on: (Error , ArithmeticError) - ZeroDivide do: [:exception |  wasHandled := true.              exception return ] ] raise: ZeroDivide.  self deny: wasHandledasScriptResultStringInCalypso  ^self printStringdateAndTimes  | dateAndTimes |  dateAndTimes := OrderedCollection new.  self scheduleDo: [:e |  dateAndTimes add: e ].  ^dateAndTimes asArrayisOnOrBefore: aDate  ^(self equals: aDate) or: [ self isBefore: aDate ]privRestartArgBlockTest  | firstTimeThrough |  firstTimeThrough := true.  self assert: 30 equals: ([:a |  | b |        self assert: 10 equals: a.        self assert: nil identicalTo: b.        b := a + 20.        firstTimeThrough ifTrue: [ firstTimeThrough := false.              thisContext restart ].        b ] value: 10)absPrintExactlyOn: aStream base: base  | fBase significand exp baseExpEstimate be be1 r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount |  self isInfinite ifTrue: [ aStream nextPutAll: 'Float infinity'.        ^self ].  fBase := base asFloat.  significand := self significandAsInteger.  roundingIncludesLimits := significand even.  exp := self exponent - 52 max: MinValLogBase2.  baseExpEstimate := (self exponent * fBase reciprocalLogBase2 - 1.0e-10) ceiling.  exp >= 0 ifTrue: [ be := 1 << exp.        significand ~= 16r10000000000000 ifTrue: [ r := significand * be * 2.              s := 2.              mPlus := be ] ifFalse: [ be1 := be * 2.              r := significand * be1 * 2.              s := 4.              mPlus := be1 ].        mMinus := be ] ifFalse: [ exp = MinValLogBase2 | (significand ~= 16r10000000000000) ifTrue: [ r := significand * 2.              s := (1 << exp negated) * 2.              mPlus := 1 ] ifFalse: [ r := significand * 4.              s := (1 << (exp negated + 1)) * 2.              mPlus := 2 ].        mMinus := 1 ].  baseExpEstimate >= 0 ifTrue: [ s := s * (base raisedToInteger: baseExpEstimate) ] ifFalse: [ scale := base raisedToInteger: baseExpEstimate negated.        r := r * scale.        mPlus := mPlus * scale.        mMinus := mMinus * scale ].  r + mPlus > s | (roundingIncludesLimits & (r + mPlus = s)) ifTrue: [ baseExpEstimate := baseExpEstimate + 1 ] ifFalse: [ r := r * base.        mPlus := mPlus * base.        mMinus := mMinus * base ].  (fixedFormat := baseExpEstimate between: -3 and: 6) ifTrue: [ decPointCount := baseExpEstimate.        baseExpEstimate <= 0 ifTrue: [ aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate) ] ] ifFalse: [ decPointCount := 1 ].  [ d := r // s.  r := r \\ s.  (tc1 := r < mMinus | (roundingIncludesLimits & (r = mMinus))) | (tc2 := r + mPlus > s | (roundingIncludesLimits & (r + mPlus = s))) ] whileFalse: [ aStream nextPut: (Character digitValue: d).        r := r * base.        mPlus := mPlus * base.        mMinus := mMinus * base.        decPointCount := decPointCount - 1.        decPointCount = 0 ifTrue: [ aStream nextPut: $. ] ].  tc2 ifTrue: [ tc1 not | (tc1 & (r * 2 >= s)) ifTrue: [ d := d + 1 ] ].  aStream nextPut: (Character digitValue: d).  decPointCount > 0 ifTrue: [ decPointCount - 1 to: 1 by: -1 do: [:i |  aStream nextPut: $0 ].        aStream nextPutAll: '.0' ].  fixedFormat ifFalse: [ aStream nextPut: $e.        aStream nextPutAll: (baseExpEstimate - 1) printString ]isZero  ^x isZero and: [ y isZero ]definedSelectors  ^self package definedSelectorsForClass: self// arg  arg isPoint ifTrue: [ ^(x // arg x) @ (y // arg y) ].  ^arg adaptToPoint: self andSend: #//onLineFrom: p1 to: p2 within: epsilon  p1 x < p2 x ifTrue: [ (x < (p1 x - epsilon) or: [ x > (p2 x + epsilon) ]) ifTrue: [ ^false ] ] ifFalse: [ (x < (p2 x - epsilon) or: [ x > (p1 x + epsilon) ]) ifTrue: [ ^false ] ].  p1 y < p2 y ifTrue: [ (y < (p1 y - epsilon) or: [ y > (p2 y + epsilon) ]) ifTrue: [ ^false ] ] ifFalse: [ (y < (p2 y - epsilon) or: [ y > (p1 y + epsilon) ]) ifTrue: [ ^false ] ].  ^(self distanceTo: (self nearestPointAlongLineFrom: p1 to: p2)) <= epsiloncrLog: aString  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver crLog: `@statements1' -> '`@receiver crTrace: `@statements1'.  self crTrace: aStringpushNewArrayOfSize: arraySize  self push: (Array new: arraySize)timeToRun  ^Duration milliSeconds: (Time millisecondsToRun: self)constructCannotReturnBlockInDeadFrame  ^[:arg |  ^arg ]do: aBlock with: aFirstElement when: aConditionBlock  | element end |  element := aFirstElement.  end := self end.  [ element start <= end ] whileTrue: [ (aConditionBlock value: element) ifTrue: [ aBlock value: element ].        element := element next ]isRGUnresolvedValue  ^falseisExtendedInPackage: aPackage  ^aPackage extendsClass: selfreset  self suspend.  timespans := nilprotocol: aString  ^self methodClass organization classify: self selector under: aStringsendsSelector: aSymbol  ^self messages includes: aSymboltestMonthPrintOn  | aMonth |  aMonth := Month starting: DateAndTime new duration: 31 days.  self assert: (String streamContents: [:str |  aMonth printOn: str ]) equals: 'January 1901'hasDynamicItems  ^falsetestParsingMPatternWithTwoDigitSucceeds  | date |  date := Date year: 2013 month: 11 day: 29.  self assertReading: '29.11.2013' as: 'dd.m.yyyy' equals: date.  self assertReading: '11.2013.29' as: 'm.yyyy.dd' equals: date.  self assertReading: '29.2013.11' as: 'dd.yyyy.m' equals: datetestPrinting  self     assert: time printString equals: '4:02:47 am';     assert: time intervalString equals: '4 hours 2 minutes 47 seconds';     assert: time print24 equals: '04:02:47';     assert: time printMinutes equals: '4:02 am';     assert: time hhmm24 equals: '0402'classToBeTested  ^MonthencodeOn: aDocument  self printOn: aDocumentlongPrintOn: aStream  self isQuick ifTrue: [ self isReturnSpecial ifTrue: [ ^aStream nextPutAll: 'Quick return ' , (#('self' 'true' 'false' 'nil' '-1' '0' '1' '2') at: self primitive - 255) ].        ^aStream nextPutAll: 'Quick return field ' , self returnField printString , ' (0-based)' ].  self isPrimitive ifTrue: [ self printPrimitiveOn: aStream ].  self symbolicBytecodes do: [:each |  each printOn: aStream ] separatedBy: [ aStream cr ]testIfNilIfNotNil  < haltOrBreakpointForTesting>  self should: [ nil ifNil: [ self error ] ifNotNil: [  ] ] raise: ErrorsquaredDistanceTo: aPoint  | delta |  delta := aPoint - self.  ^delta dotProduct: deltaadaptToCollection: rcvr andSend: selector  ^rcvr collect: [:element |  element perform: selector with: self ]<= aNumber  aNumber isInteger ifTrue: [ self negative == aNumber negative ifTrue: [ self negative ifTrue: [ ^(self bytesCompare: aNumber) >= 0 ] ifFalse: [ ^(self bytesCompare: aNumber) <= 0 ] ] ifFalse: [ ^self negative ] ].  ^aNumber adaptToInteger: self andCompare: #<=testJulianDayNumber  self assert: aDateAndTime equals: (DateAndTime julianDayNumber: 2415386).  self assert: aDateAndTime julianDayNumber equals: 2415386nonTrivial  ^self instVarNames notEmpty or: [ self hasMethods or: [ self hasTraitComposition ] ]setDebugOnOff  DebugMe := true.  DebugMe := falsetestReadFrom  self assert: aDuration equals: (Duration readFrom: '1:02:03:04.000000005' readStream)methodWithTranscript  self trace: 'something'classify: element under: heading suppressIfDefault: aBoolean  | catName catIndex elemIndex realHeading |  (heading = NullCategory or: [ heading == nil ]) ifTrue: [ realHeading := Default ] ifFalse: [ realHeading := heading asSymbol ].  (catName := self categoryOfElement: element) = realHeading ifTrue: [ ^self ].  catName ~~ nil ifTrue: [ (aBoolean and: [ realHeading = Default ]) ifTrue: [ ^self ].        self basicRemoveElement: element ].  (categoryArray indexOf: realHeading) = 0 ifTrue: [ self addCategory: realHeading ].  catIndex := categoryArray indexOf: realHeading.  elemIndex := catIndex > 1 ifTrue: [ categoryStops at: catIndex - 1 ] ifFalse: [ 0 ].  [ (elemIndex := elemIndex + 1) <= (categoryStops at: catIndex) and: [ element >= (elementArray at: elemIndex) ] ] whileTrue.  elementArray := elementArray copyReplaceFrom: elemIndex to: elemIndex - 1 with: (Array with: element).  catIndex to: categoryArray size do: [:i |  categoryStops at: i put: (categoryStops at: i) + 1 ].  ((categoryArray includes: Default) and: [ (self listAtCategoryNamed: Default) size = 0 ]) ifTrue: [ self removeCategory: Default ].  self assertInvariantobject: anObject instVarAt: anIndex put: aValue  < primitive: 74>  ^self object: anObject basicAt: anIndex - (self objectClass: anObject) instSize put: aValuedebuggerMap  ^self compilerClass debuggerMethodMapForMethod: selfnbCall: fnSpec  < ffiCalloutTranslator>  self deprecated: 'use ffiCall: instead'.  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     function: fnSpec library: self ffiLibraryNameprintStringBase: b nDigits: n  | integer next result |  result := String new: n.  integer := self.  n to: 1 by: -1 do: [:i |  next := integer // b.        result byteAt: i put: (Character digitValue: integer - (next * b)).        integer := next ].  ^resultmerge: aRectangle  ^Rectangle origin: (origin min: aRectangle origin) corner: (corner max: aRectangle corner)gtInspectorItemsIn: composite  testIsUppercase  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isUppercase: ch) equals: (charset isUppercase: ch) ]testPoolUsers  | result |  result := ChronologyConstants poolUsers.  self assert: result asSet equals: {Date .         DateAndTime .         Duration .         Month .         Time .         TimeZone .         Week .         LocalTimeZone .         AbstractTimeZone} asSettestDayOfWeek  self assert: aDateAndTime dayOfWeek equals: 5.  self assert: aDateAndTime dayOfWeekAbbreviation equals: 'Thu'.  self assert: aDateAndTime dayOfWeekName equals: 'Thursday'testSqrtFloor  #(-1234567890123 -10 -5 -1) do: [:each |  self should: [ each sqrtFloor ] raise: Error ].  #(0 1 2 3 4 5 10 16 30 160479924 386234481 501619156 524723498 580855366 766098594 834165249 1020363860 1042083924 1049218924 1459774772895569 3050005981408238 4856589481837079 5650488387708463 7831037396100244) do: [:each |  self assert: each asFloat sqrt floor equals: each sqrtFloor ]stepTimeIn: aSystemWindow  ^1000compiledMethodAt: selector ifPresent: aBlock ifAbsent: anotherBlock  ^self methodDict at: selector ifPresent: aBlock ifAbsent: anotherBlockcriticNameOn: aStream  aStream << self methodClass name << '>>#' << self selector << ' (' << self methodClass instanceSide category << ')'genTrap  stream nextPut: 217dragTransferTypeForMorph: dragSource  ^nilpopTo: aContext  self == Processor activeProcess ifTrue: [ ^self error: 'The active process cannot pop contexts' ].  ^(self calleeOf: aContext) ifNil: [ aContext ] ifNotNil: [:callee |  Processor activeProcess evaluate: [ self return: callee value: callee receiver ] onBehalfOf: self ]testAsNanoSeconds  self assert: aDateAndTime asNanoSeconds equals: 0 asDuration asNanoSecondssetTop: topNumber left: leftNumber bottom: bottomNumber right: rightNumber  top := topNumber.  left := leftNumber.  bottom := bottomNumber.  right := rightNumbertestNanoSecond  self assert: aTime nanoSecond equals: 0setUp  super setUp.  month := Month year: 1998 month: 7macRomanToUnicode  ^MacRomanTextConverter new unicodeToByte: selftestAllSlots  self assert: Context allSlots size equals: 6schedule: aDelay  accessProtect critical: [ super schedule: aDelay ]asWeakMessageSend  ^WeakMessageSend receiver: receiver selector: selector arguments: arguments copyvalue: anArg  < primitive: 202>  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  self primitiveFailedtestEveryDo  | count duration |  count := 0.  duration := 7 days.  aTimespan every: duration do: [:each |  count := count + 1 ].  self assert: count equals: 13isIntegerRectangle  ^origin isIntegerPoint and: [ corner isIntegerPoint ]testFloatPrinting  self assert: (0.1 + 0.2) printString equals: '0.30000000000000004'.  self assert: (-0.1 - 0.2) printString equals: '-0.30000000000000004'.  self assert: 240 degreesToRadians cos equals: -0.5000000000000004.  self assert: 240 degreesToRadians cos abs equals: 0.5000000000000004isZero  ^0 = top and: [ 0 = left and: [ 0 = right and: [ 0 = bottom ] ] ]storeOn: aStream  aStream nextPutAll: self nametestMetaclassPointOfCircularity  self assert: Metaclass class instanceCount equals: 1.  self assert: Metaclass class someInstance identicalTo: MetaclasstestMutateObjectInstVarUsingBasicAtPut  | guineaPig |  guineaPig := Array new: 5.  guineaPig beReadOnlyObject.  self should: [ guineaPig basicAt: 1 put: #test ] raise: ModificationForbidden.  [ guineaPig at: 1 put: #test ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first equals: #testbitString  ^(self bitStringLength to: 1 by: -1) collect: [:i |  Character value: $0 charCode + (self bitAt: i) ] as: StringcontextOfSender  ^context senderglamourValueWithArgs: anArray  ^selfwhileTrue  self value ifTrue: [ self whileTrue ]hour12  ^(self hour24 - 1) \\ 12 + 1testAllLocalCallsOn  self assert: (Point allLocalCallsOn: #asPoint) notEmpty.  self assert: (Point allLocalCallsOn: #asPoint) size equals: 4.  self assert: ((Point allLocalCallsOn: #asPoint) includes: Point >> #roundDownTo:).  self assert: ((Point allLocalCallsOn: #asPoint) includes: Point >> #roundUpTo:).  self assert: ((Point allLocalCallsOn: #asPoint) includes: Point >> #roundTo:).  self assert: ((Point allLocalCallsOn: #asPoint) includes: Point >> #truncateTo:)cull: arg1 cull: arg2 cull: arg3  ^selector numArgs < 3 ifTrue: [ self cull: arg1 cull: arg2 ] ifFalse: [ self value: arg1 value: arg2 value: arg3 ]index  ^(self asMonth dayOfWeek + self dayOfMonth - 2) // 7 + 1timeZone  ^TimeZone offset: self offsetduration  | ts last |  self isSuspended ifTrue: [ (ts := self timespans) isEmpty ifTrue: [ ts := {(Timespan starting: DateAndTime now duration: Duration zero)} ] ] ifFalse: [ last := self timespans last.        ts := self timespans allButLast           add: (last                 duration: DateAndTime now - last start;                 yourself);           yourself ].  ^(ts collect: [:t |  t duration ]) sumimmediateSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self immediateSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: cattestPointersTo  | myObject myArray |  myObject := Object new.  self assertEmpty: myObject pointersTo.  myArray := {myObject .   myObject}.  self assert: myObject pointersTo asArray equals: {myArray}memoizedUsing: cache  ^[:x |  cache at: x ifAbsentPut: [ self value: x ] ]testHasInstVarRef  | method |  method := self class compiledMethodAt: #readX.  self assert: method hasInstVarRef.  method := self class compiledMethodAt: #readXandY.  self assert: method hasInstVarRef.  method := self class compiledMethodAt: #writeX.  self assert: method hasInstVarRef.  method := self class compiledMethodAt: #writeXandY.  self assert: method hasInstVarRefjavascriptOn: aStream  self isNaN ifTrue: [ ^aStream nextPutAll: 'NaN' ].  self isInfinite ifTrue: [ ^aStream nextPutAll: (self positive ifTrue: [ 'Infinity' ] ifFalse: [ '-Infinity' ]) ].  super javascriptOn: aStreamsubclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames category: aCategorySymbol  self deprecated: 'use ... package: instead'.  ^self subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames package: aCategorySymbolarcTan: denominator  ^self = 0.0 ifTrue: [ denominator signBit = 0 ifTrue: [ 0 ] ifFalse: [ self signBit = 0 ifTrue: [ Pi ] ifFalse: [ Pi negated ] ] ] ifFalse: [ denominator = 0.0 ifTrue: [ self > 0.0 ifTrue: [ Halfpi ] ifFalse: [ Halfpi negated ] ] ifFalse: [ denominator > 0 ifTrue: [ (self / denominator) arcTan ] ifFalse: [ self > 0 ifTrue: [ (self / denominator) arcTan + Pi ] ifFalse: [ (self / denominator) arcTan - Pi ] ] ] ]fuelAccept: aGeneralMapper  ^aGeneralMapper visitHookPrimitive: selfvalueWithPossibleArguments: anArray  | args |  anArray size == self numArgs ifTrue: [ ^self valueWithArguments: anArray ].  args := Array new: self numArgs.  args replaceFrom: 1 to: (anArray size min: args size) with: anArray startingAt: 1.  ^self valueWithArguments: argstestMillisecondsToGo  | delay |  delay := Delay forMilliseconds: 100.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: delay.  scheduler simulate_vmMilliseconds: 160.  self assert: delay millisecondsToGo equals: 40gtInspectorPresentationsIn: composite inContext: aGTInspector  | pragmas |  pragmas := Pragma allNamed: aGTInspector class extensionsPragma from: self class to: ProtoObject sortedUsing: [:x :y |  (x argumentAt: 1) < (y argumentAt: 1) ].  pragmas := pragmas select: [:aPragma |  aGTInspector shouldDisplayPresentationCreatedBy: aPragma method ].  self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspectoreffectiveProcess  ^effectiveProcess ifNil: [ self ]definesClassVariableNamed: aString  ^self classVarNames includes: aStringphlowValue: anObject withEnoughArguments: aCollection  ^self valueWithEnoughArguments: aCollectionallCallsOnIn: aSystemNavigation  ^(aSystemNavigation allReferencesTo: (self environment associationAt: self instanceSide name)) , (aSystemNavigation allCallsOn: self instanceSide name)keysAndValuesDo: aBlock  1 to: self basicSize do: [:i |  | propertyOrPragma |        (propertyOrPragma := self basicAt: i) isVariableBinding ifTrue: [ aBlock value: propertyOrPragma key value: propertyOrPragma value ] ifFalse: [ aBlock value: propertyOrPragma selector value: propertyOrPragma ] ]initialize  super initialize.  exceptions := OrderedCollection newgenTrapIfNotInstanceOf: literalIndex  | extendedIndex |  (literalIndex < 0 or: [ literalIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65536 ].  (extendedIndex := literalIndex) > 255 ifTrue: [ self genUnsignedSingleExtendA: extendedIndex // 256.        extendedIndex := extendedIndex \\ 256 ].  stream     nextPut: 236;     nextPut: extendedIndextestcurrentYear  | yyyy |  yyyy := Year currentYear.  self assert: Date today asYear equals: yyyyclassComment: aString  ^self classComment: aString stamp: '<historical>'wantsChangeSetLogging  ^truetestBasicCheck2  | testMethod |  testMethod := testClass >> (testClass compile: 'testMethod').  self deny: (FloatReferencesRule new basicCheck: testMethod ast)changeFromString: aString  | categorySpecs |  categorySpecs := aString parseLiterals.  (categorySpecs isEmpty and: [ elementArray isEmpty ]) ifTrue: [ ^self setDefaultList: Array new ].  ^self changeFromCategorySpecs: categorySpecsyear  ^self dayMonthYearDo: [:d :m :y |  y ]subclass: t  ^self subclass: t instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: 'Unclassified'to: anEnd  | end |  end := (anEnd isKindOf: Timespan) ifTrue: [ anEnd end ] ifFalse: [ anEnd asDateAndTime ].  ^Timespan starting: self start ending: endsetUp  | pragma |  super setUp.  pragma := (Object compiledMethodAt: #at:) penultimateLiteral at: #primitive:.  amState := AdditionalMethodState selector: #at: with: pragma copyprintWithCommasOn: aStream  ^self printSeparatedBy: $, every: 3 signed: false on: aStreammixedMethod  LocalRecursionStopper during: [ self assert: value equals: 0.        value := value + 1.        LocalRecursionStopper during: [ value := value + 1 ].        self assert: value equals: 1.        self mixedMethod.        self assert: value equals: 1 ].  LocalRecursionStopper during: [ self assert: value equals: 1.        ^2 ].  self assert: value equals: 1.  ^valuesend: selector super: superFlag numArgs: numArgs  | currentReceiver arguments |  arguments := Array new: numArgs.  numArgs to: 1 by: -1 do: [:i |  arguments at: i put: self pop ].  currentReceiver := self pop.  QuickStep == self ifTrue: [ QuickStep := nil.        ^self quickSend: selector to: currentReceiver with: arguments super: superFlag ].  ^self send: selector to: currentReceiver with: arguments super: superFlagcharacterSet  ^self class characterSetproperties  ^nil -> niltestAsSeconds  self assert: aTime asSeconds equals: 45296testExecutionEnvironment  | newEnv |  newEnv := ExecutionEnvironmentStub new.  newEnv beActiveDuring: [ self assert: CurrentExecutionEnvironment value equals: newEnv.        DefaultExecutionEnvironment beActiveDuring: [ self assert: CurrentExecutionEnvironment value equals: DefaultExecutionEnvironment instance ].        self assert: CurrentExecutionEnvironment value equals: newEnv ]amountToTranslateWithin: aRectangle  | dx dy |  dx := 0.  dy := 0.  self right > aRectangle right ifTrue: [ dx := aRectangle right - self right ].  self bottom > aRectangle bottom ifTrue: [ dy := aRectangle bottom - self bottom ].  self left + dx < aRectangle left ifTrue: [ dx := aRectangle left - self left ].  self top + dy < aRectangle top ifTrue: [ dy := aRectangle top - self top ].  ^dx @ dytestRefersToLiteralsReturnsTrueWhenLiteralIsContainedInArrayOfLitterals  self assert: (self compiledMethod1 hasLiteralThorough: #add)level  < metaLinkOptions: #(+ optionDisabledLink)>  ^level ifNil: [ level := 0 ]testIsCurrencySymbol  self checkCorrespondanceOf: #isCurrencySymbol: and: #SctryEnterCritical: criticalBlock ifLocked: lockedBlock  | activeProcess |  activeProcess := Processor activeProcess.  activeProcess == owner ifTrue: [ ^criticalBlock value ].  ^semaphore critical: [ owner := activeProcess.        criticalBlock ensure: [ owner := nil ] ] ifLocked: lockedBlockcategoryOfElement: aSelector  ^self categoryOfElement: aSelector ifAbsent: [ nil ]instVarIndexFor: instVarName  ^self instVarIndexFor: instVarName ifAbsent: 0innerCompiledBlocksAnySatisfy: aBlock  self innerCompiledBlocksDo: [:cb |  (aBlock value: cb) ifTrue: [ ^true ] ].  ^falsetestPrintOn  self assert: (String streamContents: [:str |  aDateAndTime printOn: str ]) equals: '2004-02-29T13:33:00+02:00'.  self assert: (String streamContents: [:str |  aTimeZone printOn: str ]) equals: 'a TimeZone(UTC)'printDirectlyToDisplay  self asString displayAt: 0 @ 100method  ^methodisInfinite  ^self = Infinity or: [ self = NegativeInfinity ]nthRoot: aPositiveInteger  | guess |  guess := (numerator nthRootTruncated: aPositiveInteger) / (denominator nthRootTruncated: aPositiveInteger).  (guess raisedTo: aPositiveInteger) = self ifTrue: [ ^guess ].  ^(self abs ln / aPositiveInteger) exp * self signfileOutMethod: selector on: aStream  selector == #Comment ifTrue: [ ^self inform: 'Sorry, cannot file out class comment in isolation.' ].  (self includesSelector: selector) ifFalse: [ ^self error: 'Selector ' , selector asString , ' not found' ].  aStream     header;     timeStamp.  self printMethodChunk: selector on: aStreamlistAtCategoryNumber: aSmallInteger  ^(protocolOrganizer allProtocols at: aSmallInteger ifAbsent: [ ^{} ]) methods asArraymethods: aCollection  self deprecated: 'Use #methodSelectors: instead.' transformWith: '`@receiver methods: `@arg' -> '`@receiver methodSelectors: `@arg'.  ^self methodSelectors: aCollectiontestMonotonicity  | t1 t2 t3 t4 |  t1 := DateAndTime now.  t2 := DateAndTime now.  t3 := DateAndTime now.  t4 := DateAndTime now.  self     assert: t1 <= t2;     assert: t2 <= t3;     assert: t3 <= t4testPrintOn  self assert: (String streamContents: [:str |  aTime printOn: str ]) equals: '12:34:56 pm'comment  ^self instanceSide organization classComment ifEmpty: [ self classCommentBlank ]isJavascript  ^falsesignalAllInQueue: anOrderedCollection  queuesMutex critical: [ anOrderedCollection removeAllSuchThat: [:each |  each signal.              true ] ]hasMethodReturn  ^closureOrNil hasMethodReturnwithRight: x  ^origin x @ origin y corner: (x max: origin x) @ corner ytestDatesDo  | dateArray |  dateArray := OrderedCollection new.  7 to: 97 do: [:each |  dateArray addLast: (Date year: 2003 day: each) ].  dateArray := dateArray asArray.  self assert: aTimespan dates equals: dateArrayisAnonymous  ^truecull: firstArg cull: secondArg  ^numArgs < 2 ifTrue: [ self cull: firstArg ] ifFalse: [ self value: firstArg value: secondArg ]testAsDuration  self assert: aDateAndTime asDuration equals: 0 asDurationimmediateSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategory  ^self subclass: aName uses: aTraitComposition layout: ImmediateLayout slots: someInstanceVariableNames asSlotCollection classVariablesNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategoryasMonth  ^self asDateAndTime asMonthtestIsLetterModifier  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isLetterModifier: ch) equals: (charset isLetterModifier: ch) ]resume: resumptionValue  self isResumable ifFalse: [ IllegalResumeAttempt signal ].  self resumeUnchecked: resumptionValuestonOn: stonWriter  stonWriter writeObject: self listSingleton: self instanceSide name asSymbolpackage  ^RPackage organizer packageOf: selftempsAndValues  ^String streamContents: [:aStream |  self tempNames do: [:name |  aStream                 nextPutAll: name;                 nextPut: $:;                 space;                 tab.              self print: (self tempNamed: name) on: aStream ] separatedBy: [ aStream cr ] ]fullDisplayString  ^String streamContents: [:s |  self displayStringOn: s ]peekInstruction  | currentPc instruction |  currentPc := self pc.  instruction := self nextInstruction.  self pc: currentPc.  ^instructionexp  < primitive: 559>  | base fract correction delta div |  self < 0.0 ifTrue: [ ^self negated exp reciprocal ].  self = 0.0 ifTrue: [ ^1 ].  self abs > MaxValLn ifTrue: [ self error: 'exp overflow' ].  base := E raisedToInteger: self truncated.  fract := self fractionPart.  fract = 0.0 ifTrue: [ ^base ].  correction := 1.0 + fract.  delta := fract * fract / 2.0.  div := 2.0.  [ delta > Epsilon ] whileTrue: [ correction := correction + delta.        div := div + 1.0.        delta := delta * fract / div ].  correction := correction + delta.  ^base * correctiontestDayOfYear  self assert: aDateAndTime dayOfYear equals: 1testSecond  self assert: aDateAndTime second equals: 0compilerClass  ^self methodClass ifNil: [ Smalltalk compilerClass ] ifNotNil: [:class |  class compilerClass ]whileFalse: aBlock  self value ifFalse: [ aBlock value.        self whileFalse: aBlock ].  ^nilensureArguments  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg :flag |  arg ifNil: [ flag ifFalse: [ ^false ] ] ] ].  ^truecorner: aPoint  ^Rectangle origin: self corner: aPointsignalFromHandlerActionTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [ self doYetAnotherThing.        MyTestError signal ]removeAllMethodSelectors  ^methodSelectors removeAllabbreviation  ^self subclassResponsibilitycloseTo: anObject  ^[ self = anObject ] ifError: [ false ]printStringRadix: baseInteger  | tempString |  baseInteger = 10 ifTrue: [ tempString := self storeStringBase: baseInteger.        self negative ifTrue: [ ^'-10r' , (tempString copyFrom: 2 to: tempString size) ] ifFalse: [ ^'10r' , tempString ] ].  ^self storeStringBase: baseIntegertestErrorCodeNotFound  | ctx result resultSimu |  self skip.  Smalltalk vm isRunningCog ifFalse: [ ^self ].  result := self veryBasicAt: 1.  ctx := Context sender: nil receiver: nil method: Object >> #at: arguments: #(10).  resultSimu := ctx     push: nil;     push: 500;     doPrimitive: 117 method: self class >> #veryBasicAt: receiver: self args: #(999).  self assert: resultSimu isArray.  self assert: Context primitiveFailToken first identicalTo: resultSimu first.  self assert: result equals: resultSimu secondtestReadFromDateOnly  self assert: '2014-02-19' asDateAndTime translateToUTC printString equals: '2014-02-19T00:00:00+00:00'.  self assert: '2014-02-19Z' asDateAndTime printString equals: '2014-02-19T00:00:00+00:00'.  self assert: '2014-02-19T+07:00' asDateAndTime printString equals: '2014-02-19T00:00:00+07:00'.  self assert: '2014-02-19 -05:00' asDateAndTime printString equals: '2014-02-19T00:00:00-05:00'classThatDefinesInstVarNamed: instVarName  ^self slotNamed: instVarName ifFound: [:slot |  slot definingClass ] ifNone: nilmetacelloSemanticStringLessThanSelf: anInteger  ^self error: 'Invalid Metacello verson component - should be String or Integer.'highestPriority  ^quiescentProcessLists sizewindowIsClosing  gtInspectorASTIn: composite  < gtInspectorPresentationOrder: 35>  (GTSimpleRBTreeBrowser new treeIn: composite)     title: 'AST';     display: [:anObject |  {anObject ast} ]isPoint  ^falseasLargerPowerOfTwo  | quotient |  (numerator = 0 or: [ numerator sign ~= denominator sign ]) ifTrue: [ ^DomainError signal: 'Value outside (0 , infinity)' from: 0 ].  ^(quotient := denominator // numerator) > 0 ifTrue: [ Fraction numerator: 1 denominator: (1 bitShift: quotient highBit - 1) ] ifFalse: [ quotient := numerator // denominator.        (quotient isPowerOfTwo and: [ numerator \\ denominator = 0 ]) ifTrue: [ quotient ] ifFalse: [ 1 bitShift: quotient highBit ] ]methodStreamPosition  ^stream positionisEphemeronClass  ^self instSpec = 5compressTo: grid  ^Rectangle origin: (origin roundUpTo: grid) corner: (corner roundDownTo: grid)swapReceiver: newReceiver  receiver := newReceivertestNameOfMonth  | m |  m := #(#January #February #March #April #May #June #July #August #September #October #November #December).  m withIndexDo: [:item :index |  self assert: (Month nameOfMonth: index) equals: item ].  self should: [ Month nameOfMonth: 0 ] raise: self defaultTestError.  self should: [ Month nameOfMonth: 13 ] raise: self defaultTestError.  self should: [ Month nameOfMonth: #January ] raise: self defaultTestErrortestMultiProcessWaitOnSameDelay  | delay p1 p2 wasRun |  delay := Delay forSeconds: 1.  wasRun := false.  p1 := [ delay wait ] forkAt: Processor activePriority + 1.  p2 := [ self should: [ delay wait ] raise: Error.  wasRun := true ] forkAt: Processor activePriority + 1.  p1 terminate.  p2 terminate.  self assert: wasRunsign  ^-1asEmailString  | timeString |  timeString := self asTime print24 first: 8.  ^'{1}, {2} {3} {4} {5} {6}' format: {self dayOfWeekAbbreviation .         self dayOfMonth asString .         self monthAbbreviation .         self year asString .         timeString .         self offset asEmailTimeOffsetString}isProvided: marker  marker ifNil: [ ^true ].  ^(self isRequired: marker) not and: [ (self isDisabled: marker) not ]year  ^start yearselect: selectBlock thenCollect: collectBlock  | newCollection |  newCollection := self class new.  self do: [:each |  (selectBlock value: each) ifTrue: [ newCollection add: (collectBlock value: each) ] ].  ^newCollectiondefault  ^0testValueWithPossibleArgument  | block blockWithArg blockWith2Arg |  block := [ 1 ].  blockWithArg := [:arg |  arg ].  blockWith2Arg := [:arg1 :arg2 |  {arg1 .   arg2} ].  self assert: (block valueWithPossibleArgument: 1) equals: 1.  self assert: (blockWithArg valueWithPossibleArgument: 1) equals: 1.  self assert: (blockWith2Arg valueWithPossibleArgument: 1) equals: {1 .         nil}metacelloStringLessThanSelf: anInteger  ^self error: 'Invalid Metacello verson component - should be String or Integer.'testMonth  self assert: aDateAndTime month equals: 1.  self assert: aDateAndTime monthAbbreviation equals: 'Jan'.  self assert: aDateAndTime monthName equals: 'January'.  self assert: aDateAndTime monthIndex equals: 1testRefersToLiteralsReturnsTrueWhenLiteralIsByteString  self assert: (self compiledMethod1 hasLiteralThorough: 'Pharo loves tests')suspend  suspendSemaphore := Semaphore new.  timingSemaphore signaltestSelector  Author useAuthor: 'TUTU_TEST' during: [ | method cls |        method := self class >> #returnTrue.        self assert: method selector equals: #returnTrue.        Smalltalk removeClassNamed: #TUTU.        cls := Object subclass: #TUTU instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self categoryNameForTemporaryClasses.        cls compile: 'foo ^ 10'.        method := cls >> #foo.        Smalltalk removeClassNamed: #TUTU.        self assert: method selector equals: #foo ]protocolsNames  ^protocols collect: #name as: ArraypvtSignal: anException list: aList  < debuggerCompleteToSender>  | blocker |  self isActiveProcess ifFalse: [ ^self ].  anException signal.  blocker := Semaphore new.  [ self suspend.  suspendedContext := suspendedContext swapSender: nil.  aList class == Semaphore ifTrue: [ aList isSignaled ifTrue: [ aList wait.              self resume ] ifFalse: [ myList := aList.              aList add: self ] ] ifFalse: [ self resume ] ] fork.  blocker waithash  ^self identityHashinstanceVariableNamesDo: anUnaryBlock  | superInstSize |  (superInstSize := self superclass notNil ifTrue: [ self superclass instSize ] ifFalse: [ 0 ]) > 0 ifTrue: [ self superclass instanceVariableNamesDo: anUnaryBlock ].  1 to: self instSize - superInstSize do: [:i |  anUnaryBlock value: (self instVarNames at: i) ]setUp  super setUp.  unicodeGenerator := UnicodeTestRNG currenttestPrintFormat  | printFormat printedDate |  printFormat := #(1 2 3 $/ 1 1).  self assert: (january23rd2004 printFormat: printFormat) equals: '23/1/2004'.  printFormat at: 4 put: $-.  printedDate := january23rd2004 printFormat: printFormat.  self assert: printedDate equals: '23-1-2004'.  printFormat at: 5 put: 1.  self assert: ((printedDate splitOn: $-) at: 2) equals: '1'.  printFormat at: 5 put: 2.  printedDate := january23rd2004 printFormat: printFormat.  self assert: ((printedDate splitOn: $-) at: 2) equals: 'Jan'.  printFormat at: 5 put: 3.  printedDate := january23rd2004 printFormat: printFormat.  self assert: ((printedDate splitOn: $-) at: 2) equals: 'January'.  printFormat at: 5 put: 4.  printedDate := january23rd2004 printFormat: printFormat.  self assert: ((printedDate splitOn: $-) at: 2) equals: ''.  printFormat at: 6 put: 1.  printedDate := january23rd2004 printFormat: printFormat.  self assert: ((printedDate splitOn: $-) at: 3) equals: '2004'.  printFormat at: 6 put: 2.  printedDate := january23rd2004 printFormat: printFormat.  self assert: ((printedDate splitOn: $-) at: 3) equals: '04'.  printFormat at: 6 put: 2.  printedDate := january23rd2004 printFormat: printFormat.  self assert: ((printedDate splitOn: $-) at: 3) equals: '04'.  printFormat at: 6 put: 3.  printedDate := january23rd2004 printFormat: printFormat.  self assert: ((printedDate splitOn: $-) at: 3) equals: '04'.  self     assert: june2nd1973 mmddyyyy equals: '6/2/1973';     assert: june2nd1973 yyyymmdd equals: '1973-06-02';     assert: (june2nd1973 printFormat: #(3 1 2 $! 2 1 1)) equals: '1973!2!Jun';     assert: (june2nd1973 printFormat: #(1 2 3 0 1 1 2)) equals: '02061973';     assert: (june2nd1973 printFormat: #(2 1 3 0 1 1 2)) equals: '06021973';     assert: (june2nd1973 printFormat: #(3 2 1 0 1 1 2)) equals: '19730602';     assert: (june2nd1973 printFormat: #(1 2 3 0 1 1 1)) equals: '261973'setUp  super setUp.  aStopwatch := Stopwatch new.  aDelay := Delay forMilliseconds: 1testAsDuration  self assert: aTime asDuration equals: (Duration days: 0 hours: 12 minutes: 34 seconds: 56)keyword  self deprecated: 'Use #selector instead.' transformWith: '`@receiver keyword' -> '`@receiver selector'.  ^self selectortestLessThan  self assert: aDuration < (aDuration + 1 day).  self deny: aDuration < aDurationtearDown  class removeFromSystem.  super tearDownremoveLink: aLink  ^self removeLink: aLink ifAbsent: [ self error: 'no such method!' ]testErrorWhenDayIsAfterMonthEnd  self should: [ DateAndTime year: 2004 month: 2 day: 30 ] raise: Error.  DateAndTime year: 2004 month: 2 day: 29testUnion  | union |  union := timespan union: timespan.  self     assert: union start equals: timespan start;     assert: union duration equals: timespan durationtestPrintHumanReadableOn  self testHumanReadablePrintString- aNumber  < primitive: 542>  ^aNumber adaptToFloat: self andSend: #-shift  ^KMModifier shift + selftestBecomeForwardCopyIdentityHash  | a b identityHashOfA |  a := 'ab' copy.  b := 'cd' copy.  identityHashOfA := a identityHash.  a becomeForward: b copyHash: true.  self     assert: a identicalTo: b;     assert: a identityHash equals: identityHashOfA;     assert: b identityHash equals: identityHashOfAtestDayOfWeek  self assert: aTimespan dayOfWeek equals: 7.  self assert: aTimespan dayOfWeekName equals: 'Saturday'isFixed  ^self isVariable notenvironment  ^Smalltalk globalstestSecond  self assert: aDateAndTime second equals: 0testStoreOn  self assert: (String streamContents: [:str |  january23rd2004 storeOn: str ]) equals: '''23 January 2004'' asDate'testRefersToLiteralsReturnsFalseWhenLiteralNotIsInMethodPropertiesKey  [ self compiledMethod1 propertyAt: #Once put: true.  self deny: (self compiledMethod1 hasLiteralThorough: #Absent) ] ensure: [ self compiledMethod1 removeProperty: #Once ]lowestPriority  ^SystemRockBottomPriorityinterpretNextV3PlusClosureInstructionFor: client  | byte type offset method |  method := self method.  byte := method at: pc.  type := byte // 16.  offset := byte \\ 16.  pc := pc + 1.  type < 8 ifTrue: [ type < 4 ifTrue: [ type < 2 ifTrue: [ type < 1 ifTrue: [ ^client pushReceiverVariable: offset ] ifFalse: [ ^client pushTemporaryVariable: offset ] ] ifFalse: [ type < 3 ifTrue: [ ^client pushConstant: (method literalAt: offset + 1) ] ifFalse: [ ^client pushConstant: (method literalAt: offset + 17) ] ] ] ifFalse: [ type < 6 ifTrue: [ type < 5 ifTrue: [ ^client pushLiteralVariable: (method literalAt: offset + 1) ] ifFalse: [ ^client pushLiteralVariable: (method literalAt: offset + 17) ] ] ifFalse: [ type < 7 ifTrue: [ offset < 8 ifTrue: [ ^client popIntoReceiverVariable: offset ] ifFalse: [ ^client popIntoTemporaryVariable: offset - 8 ] ] ifFalse: [ offset = 0 ifTrue: [ ^client pushReceiver ].                          offset < 8 ifTrue: [ ^client pushConstant: (SpecialConstants at: offset) ].                          offset = 8 ifTrue: [ ^client methodReturnReceiver ].                          offset < 12 ifTrue: [ ^client methodReturnConstant: (SpecialConstants at: offset - 8) ].                          offset = 12 ifTrue: [ ^client methodReturnTop ].                          offset = 13 ifTrue: [ ^client blockReturnTop ].                          offset > 13 ifTrue: [ ^self unusedBytecode: client at: pc - 1 ] ] ] ] ] ifFalse: [ type < 12 ifTrue: [ type < 10 ifTrue: [ type < 9 ifTrue: [ ^self interpretV3PlusClosureExtension: offset in: method for: client ] ifFalse: [ offset < 8 ifTrue: [ ^client jump: offset + 1 ].                          ^client jump: offset - 8 + 1 if: false ] ] ifFalse: [ type < 11 ifTrue: [ byte := method at: pc.                          pc := pc + 1.                          offset < 8 ifTrue: [ ^client jump: (offset - 4) * 256 + byte ].                          ^client jump: (offset bitAnd: 3) * 256 + byte if: offset < 12 ] ifFalse: [ ^client send: (Smalltalk specialSelectorAt: offset + 1) super: false numArgs: (Smalltalk specialNargsAt: offset + 1) ] ] ] ifFalse: [ type = 12 ifTrue: [ ^client send: (Smalltalk specialSelectorAt: offset + 17) super: false numArgs: (Smalltalk specialNargsAt: offset + 17) ] ifFalse: [ ^client send: (method literalAt: offset + 1) super: false numArgs: type - 13 ] ] ]basicObsoleteSubclasses  ^ObsoleteSubclassestestDoubleResume  self assertSuccess: (ExceptionTester new runTest: #doubleResumeTest)testTranscriptPrinting  self runSimulated: [ self methodWithTranscript ]sizeStoreInstVarLong: instVarIndex  ^self sizeOpcodeSelector: #genStoreInstVarLong: withArguments: {instVarIndex}endPC  ^closureOrNil ifNil: [ self method endPC ] ifNotNil: [ closureOrNil endPC ]byteAt: index put: value  < primitive: 61>  ^super at: index put: valuetestValueWithinTimingNestedInner  | time |  time := [ [ [ 5 seconds asDelay wait ] valueWithin: 100 milliSeconds onTimeout: [  ] ] valueWithin: 500 milliSeconds onTimeout: [  ] ] durationToRun.  self assert: time < 500 milliSeconds- operand  ^self + operand negatedroundUpTo: grid  | gridPoint |  gridPoint := grid asPoint.  ^(x roundUpTo: gridPoint x) @ (y roundUpTo: gridPoint y)hasSharedPools  ^self sharedPools notEmptyasContextWithSender: aContext  ^(Context newForMethod: outerContext method)     setSender: aContext receiver: outerContext receiver method: outerContext method closure: self startpc: startpc;     privRefreshinstVarAt: index put: value  index = 3 ifTrue: [ self stackp: value.        ^value ].  ^super instVarAt: index put: valuewithTop: y  ^origin x @ (y min: corner y) corner: corner x @ corner ystonContainSubObjects  ^falsebecome: otherObject  {self} elementsExchangeIdentityWith: {otherObject}testIsInitialQuote  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isInitialQuote: ch) equals: (charset isInitialQuote: ch) ]argumentCount  ^selector numArgs - self arguments sizetestMetaclassSuperclass  self assert: Dictionary class superclass identicalTo: Dictionary superclass class.  self assert: OrderedCollection class superclass identicalTo: OrderedCollection superclass classgtIterator  self assert: (self numArgs between: 1 and: 2).  ^GTSpotterBlockIterator new     onDo: self;     yourselfbordersOn: her along: herSide  ((herSide = #right and: [ self left = her right ]) or: [ herSide = #left and: [ self right = her left ] ]) ifTrue: [ ^(self top max: her top) < (self bottom min: her bottom) ].  ((herSide = #bottom and: [ self top = her bottom ]) or: [ herSide = #top and: [ self bottom = her top ] ]) ifTrue: [ ^(self left max: her left) < (self right min: her right) ].  ^falsesignalIn: context  signalContext := context.  signaler ifNil: [ signaler := self receiver ].  ^signalContext nextHandlerContext handleSignal: selfasMargin  ^Margin fromRectangle: selfsharing: poolString  | oldPools |  oldPools := self sharedPools.  self sharedPools: OrderedCollection new.  (poolString substrings: ' ') do: [:poolName |  self sharedPools add: (self environment at: poolName asSymbol ifAbsent: [ (self confirm: 'The pool dictionary ' , poolName , ' does not exist.' , '\Do you want it automatically created?' withCRs) ifTrue: [ self classInstaller make: [:builder |  builder                                   superclass: SharedPool;                                   name: poolName;                                   category: self category ] ] ifFalse: [ ^self error: poolName , ' does not exist' ] ]) ].  self sharedPools isEmpty ifTrue: [ self sharedPools: nil ].  oldPools do: [:pool |  | found |        found := self sharedPools anySatisfy: [:p |  p == pool ].        found ifFalse: [ ^true ] ].  ^falsetestClassSide  self assert: Point classSide equals: Point class.  self assert: Point class classSide equals: Point classname  ^(self isEmpty and: [ protocolOrganizer protocols isEmpty ]) ifTrue: [ self class nullCategory ] ifFalse: [ name ]isOtherLetter  ^self characterSet isOtherLetter: selfsetFormat: aFormatInstanceDescription  format := aFormatInstanceDescriptiontestOnForkErrorExecutesBlock  | result sema |  sema := Semaphore new.  result := nil.  [ 1 / 0 ] on: Exception fork: [ result := 2.        sema signal ].  sema wait.  self assert: result equals: 2allSuperclassesDo: aBlockContext  continuationExample2: aCollection  | stream processor collector |  stream := [:collection |  | i localBlock |  i := 1.  localBlock := [ | current |  current := collection at: i.  i := i + 1.  Array with: current with: (i <= collection size ifTrue: [ localBlock ] ifFalse: [ nil ]) ] ].  processor := [:valueWithContinuation :activity |  | localBlock |  localBlock := [ | current |  current := valueWithContinuation value.  Array with: (activity value: current first) with: (current last notNil ifTrue: [ localBlock ]) ].  localBlock ].  collector := [:valueWithContinuation |  | oc |  oc := OrderedCollection new.  [ | local |  local := valueWithContinuation value.  oc add: local first.  local last notNil ] whileTrue: [  ].  oc ].  ^collector value: (processor value: (stream value: aCollection) value: [:x |  x * x ])tearDown  testingEnvironment removeKey: self globalName ifAbsent: [  ].  globalName := nil.  testClass := nil.  super tearDowntestAsYear  self assert: aDateAndTime asYear equals: (Year starting: '01-01-1980' asDate)spaceUsed  ^super spaceUsed + (self hasClassSide ifTrue: [ self classSide spaceUsed ] ifFalse: [ 0 ])when: anEventSelector send: aMessageSelector to: anObject withArguments: anArgArray  self when: anEventSelector evaluate: (WeakMessageSend receiver: anObject selector: aMessageSelector arguments: anArgArray)outOfRangeError: string index: index range: rangeStart to: rangeEnd  ^self error: thisContext sender method selector , ' ' , string , ' index ' , index printString , ' is out of range ' , rangeStart printString , ' to ' , rangeEnd printStringrelease  explicitRequirement  | originalMethod originalArguments errorBlock originalReceiver callingContext originalSelector |  errorBlock := [ ^self error: 'Explicitly required method' ].  callingContext := thisContext sender.  originalMethod := callingContext method.  originalMethod isFromTrait ifFalse: errorBlock.  originalReceiver := callingContext receiver.  originalSelector := originalMethod selector.  originalArguments := callingContext arguments.  originalReceiver class superclass withAllSuperclassesDo: [:superClass |  superClass compiledMethodAt: originalSelector ifPresent: [:method |  (method isProvided or: [ method isFromTrait not ]) ifTrue: [ callingContext return: (method valueWithReceiver: originalReceiver arguments: originalArguments) ] ] ].  errorBlock valuetestBasicCheck3  | testMethod |  testClass addClassVarNamed: #TestVar.  testMethod := testClass >> (testClass compile: 'testMethod TestVar yourself').  self assert: (testMethod externalProperties noneSatisfy: [:eprop |  eprop rule class = SendsDeprecatedMethodToGlobalRule ])testSchedulingSamePriorityFirstComeFirstServed  | gate checkAssert whichRan |  gate := Semaphore new signal.  checkAssert := Semaphore new.  [ gate wait.  whichRan := 1.  checkAssert signal ] fork.  [ gate wait.  whichRan := 2.  checkAssert signal ] fork.  checkAssert wait.  self assert: whichRan = 1 description: 'First scheduled process should run first'.  gate signal.  checkAssert wait.  self assert: whichRan = 2 description: 'Second scheduled process should run after'willStore  ^self method encoderClass isStoreAt: pc in: self methodtestReciprocal  self     assert: 1.0 reciprocal equals: 1.0;     assert: 2.0 reciprocal equals: 0.5;     assert: -1.0 reciprocal equals: -1.0;     assert: -2.0 reciprocal equals: -0.5.  self should: [ 0.0 reciprocal ] raise: ZeroDividepushArgs: arguments from: senderContext  closureOrNil ifNil: [ self error: 'context needs a closure!' ] ifNotNil: [ stackp ~= (closureOrNil numArgs + closureOrNil numCopiedValues) ifTrue: [ self error: 'stack pointer is incorrect!' ] ].  1 to: closureOrNil numArgs do: [:i |  self at: i put: (arguments at: i) ].  sender := senderContextveryDeepCopyWith: deepCopier  ^selftestFromSeconds  | t |  t := self timeClass fromSeconds: 14567.  self assert: t equals: timethirdByte  ^self method at: pc + 2value: anObject  self terminate: thisContext.  self restoreValues.  thisContext swapSender: values first.  ^anObjectyears  | years |  years := OrderedCollection new.  self yearsDo: [:m |  years add: m ].  ^years asArraytestArgumentNamedIfNone  | pragma |  pragma := (self class >> #methodWithPragma) pragmas anyOne.  self assert: (pragma argumentNamed: #arg3 ifNone: [ false ]).  self deny: (pragma argumentNamed: #nonExisting ifNone: [ false ])asLayoutFrame  ^LayoutFrame new     leftFraction: self left;     rightFraction: self right;     topFraction: self top;     bottomFraction: self bottom;     yourselfrecompile: selector from: oldClass  | method newMethod |  method := oldClass compiledMethodAt: selector.  newMethod := self compiler     source: (oldClass sourceCodeAt: selector);     class: self;     failBlock: [ ^self ];     compiledMethodTrailer: method trailer;     compile.  selector == newMethod selector ifFalse: [ self error: 'selector changed!' ].  self addSelectorSilently: selector withMethod: newMethodinterpretSistaV1ExtendedPush: extB for: client  extB = 0 ifTrue: [ ^client pushActiveContext ].  extB = 1 ifTrue: [ ^client pushActiveProcess ].  self error: 'undefined extended push'asRingDefinition  | ring |  ring := (RGClassDefinition named: self name)     category: self category;     superclassName: (self superclass ifNil: [ nil printString ] ifNotNil: [ self superclass name ]);     traitCompositionSource: self traitCompositionString;     addInstanceVariables: self instVarNames;     addClassVariables: self classVarNames;     addSharedPools: self sharedPoolNames;     comment: self organization classComment;     stamp: self organization commentStamp;     definitionSource: self oldDefinition;     package: self package asRingDefinition;     withMetaclass.  ring classSide     traitCompositionSource: self classSide traitCompositionString;     definitionSource: self classSide oldDefinition;     addInstanceVariables: self classSide instVarNames.  ^ringcomplexRecursion  LocalRecursionStopper during: [ self complexRecursionFirstCall ]isDecimalDigit  ^self characterSet isDecimalDigit: selfhaltIf: condition  < debuggerCompleteToSender>  Halt if: conditiontestInexactNthRoot  | tenth cubicRoot3 fifthRootTenth three |  three := 3.0s1.  cubicRoot3 := three raisedTo: 1 / 3.  self assert: cubicRoot3 isFloat.  self deny: cubicRoot3 squared equals: 3.  tenth := 0.10s2.  fifthRootTenth := tenth raisedTo: 1 / 5.  self assert: fifthRootTenth isFloat.  self deny: fifthRootTenth squared equals: tenthbanChecksForValidation  ^{self}method1  < pragma1: 123 foo: 'bar'>  | array |  array := Array new.  array at: 1 put: 'Pharo loves tests'.  #(#add #at: #remove) do: #printOn:testArgumentAt  | pragma |  pragma := (self class >> #methodWithPragma) pragmas anyOne.  self assert: (pragma argumentAt: 1) equals: #toto.  self assert: (pragma argumentAt: 2) equals: 2.  self assert: (pragma argumentAt: 3)newInstanceFrom: oldInstance variable: variable size: instSize map: map  | new |  variable ifTrue: [ new := self basicNew: oldInstance basicSize ] ifFalse: [ new := self basicNew ].  1 to: instSize do: [:offset |  (map at: offset) > 0 ifTrue: [ new instVarAt: offset put: (oldInstance instVarAt: (map at: offset)) ] ].  variable ifTrue: [ 1 to: oldInstance basicSize do: [:offset |  new basicAt: offset put: (oldInstance basicAt: offset) ] ].  ^newgtInspectorBytecodeIn: composite  < gtInspectorPresentationOrder: 30>  ^(GTBytecodeBrowser new treeIn: composite) title: 'Bytecode'storeOn: aStream  aStream nextPut: $(.  self class isVariable ifTrue: [ aStream           nextPutAll: '(' , self class name , ' basicNew: ';           store: self basicSize;           nextPutAll: ') ' ] ifFalse: [ aStream nextPutAll: self class name , ' basicNew' ].  1 to: self class instSize do: [:i |  aStream           nextPutAll: ' instVarAt: ';           store: i;           nextPutAll: ' put: ';           store: (self instVarAt: i);           nextPut: $; ].  1 to: self basicSize do: [:i |  aStream           nextPutAll: ' basicAt: ';           store: i;           nextPutAll: ' put: ';           store: (self basicAt: i);           nextPut: $; ].  aStream nextPutAll: ' yourself)'hasSharedPools  ^falsesideOf: otherPoint  | side |  side := (self crossProduct: otherPoint) sign.  ^{#right .   #center .   #left} at: side + 2lastIndexOfCategoryNumber: anInteger  anInteger > categoryStops size ifTrue: [ ^nil ].  ^categoryStops at: anIntegervar1  ^var1snapshotCopy  ^self shallowCopyslotNamed: aName  ^self classLayout resolveSlot: aName asSymbolname  ^'Access to a system class'instVarIndexFor: instVarName ifAbsent: aBlock  ^self slotNamed: instVarName ifFound: [:slot |  slot isVirtual ifTrue: aBlock ifFalse: [ slot index ] ] ifNone: aBlockresetPSValueAt: index  env ifNil: [ ^self ].  index > env size ifTrue: [ ^self ].  env at: index put: niltestPerformInSuperclassCanExecutelongMethodWithTemps  | temp1 temp2 temp3 |  temp1 := 33.  temp2 := 666.  temp3 := 42.  self assert: (self perform: #a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15: withArguments: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15) inSuperclass: self class) equals: 1isFraction  ^falseisLetter  ^self characterSet isLetter: selfcategoryNameForTemporaryClasses  ^'Dummy-Tests-Class'normalize  < primitive: 'primNormalizeNegative' module: 'LargeIntegers'>  | sLen val len oldLen minVal |  len := oldLen := self bytesCount.  [ len = 0 ifTrue: [ ^0 ].  (self byteAt: len) = 0 ] whileTrue: [ len := len - 1 ].  sLen := SmallInteger minVal < -16r40000000 ifTrue: [ 8 ] ifFalse: [ 4 ].  len <= sLen ifTrue: [ minVal := SmallInteger minVal.        (len < sLen or: [ (self byteAt: sLen) < minVal lastDigit ]) ifTrue: [ val := 0.              len to: 1 by: -1 do: [:i |  val := val * 256 - (self byteAt: i) ].              ^val ].        1 to: sLen do: [:i |  (self byteAt: i) = (minVal byteAt: i) ifFalse: [ len < oldLen ifTrue: [ ^self growto: len ] ifFalse: [ ^self ] ] ].        ^minVal ].  len < oldLen ifTrue: [ ^self growto: len ] ifFalse: [ ^self ]testOneArgumentWithGC  | m |  m := WeakMessageSend receiver: Array selector: #with: arguments: {Object new}.  Smalltalk garbageCollectMost.  self assert: m value isNiltestIsDigit  self checkCorrespondanceOf: #isDigit: and: #NdassignmentNodes  ^self methods flatCollect: [:each |  each assignmentNodes ]testStoreOnRoundTrip  | string |  string := String streamContents: [:stream |  nil storeOn: stream ].  self assert: (self class compiler evaluate: string) isNilasLargerPowerOfTwo  ^self isPowerOfTwo ifTrue: [ self ] ifFalse: [ self > 0 ifTrue: [ 1 bitShift: self highBit ] ifFalse: [ DomainError signal: 'Value outside (0 , infinity)' from: 0 ] ]testCurrent  self deny: aDateAndTime equals: DateAndTime currentinitializeReadingFrom: anInputStream pattern: aPattern  inputStream := anInputStream.  pattern := aPatternrestoreFromSnapshot: anObject  self copyFrom: anObjectsharedPoolOfVarNamed: aString  ^self sharedPools detect: [:each |  each usesClassVarNamed: aString ] ifNone: [ self superclass ifNil: [ nil ] ifNotNil: [ self superclass sharedPoolOfVarNamed: aString ] ]testDelayWaitTimeoutCompleted  | completed delay status |  completed := Semaphore new.  delay := DelayWaitTimeout new setDelay: 100 forSemaphore: completed.  completed signal.  delay waitOnCompletion: [ status := #completed ] onTimeout: [ status := #timedOut ].  self assert: status equals: #completedisInitialQuote  ^self characterSet isInitialQuote: selfasUnicode  | table charset value |  self leadingChar = 0 ifTrue: [ ^self asInteger ].  charset := self characterSet.  charset isCharset ifFalse: [ ^self charCode ].  table := charset ucsTable.  table ifNil: [ ^65533 ].  value := table at: self charCode + 1.  value = -1 ifTrue: [ ^65533 ].  ^valuecopy  ^self shallowCopy postCopylink: aMetaLink toSlot: aSlot  self shouldNotImplementat: index put: value  < primitive: 211>  index isInteger ifTrue: [ self errorSubscriptBounds: index ].  index isNumber ifTrue: [ ^self at: index asInteger put: value ] ifFalse: [ self errorNonIntegerIndex ]logTestResult: aString  | index |  index := self suiteLog size.  self suiteLog at: index put: (self suiteLog at: index) , ' ' , aStringsuspendFirstAt: aPriority ifNone: noneBlock  | aList |  aList := quiescentProcessLists at: aPriority.  aList isEmpty ifTrue: [ ^noneBlock value ] ifFalse: [ ^aList first suspend ]metacelloIntegerLessThanSelf: anInteger  ^self error: 'Invalid Metacello verson component - should be String or Integer.'subclass: aSubclassSymbol slots: slotDefinition classVariables: classVarDefinition category: aCategorySymbol  self deprecated: 'use ... package: instead'.  ^self subclass: aSubclassSymbol slots: slotDefinition classVariables: classVarDefinition package: aCategorySymbolprotocolsSorted  ^(self protocols collect: #name as: Array) sort copyWithFirst: allProtocol namesin  < primitive: 56>  | sum delta self2 i |  self < 0.0 ifTrue: [ ^0.0 - (0.0 - self) sin ].  self > Twopi ifTrue: [ ^(self \\ Twopi) sin ].  self > Pi ifTrue: [ ^0.0 - (self - Pi) sin ].  self > Halfpi ifTrue: [ ^(Pi - self) sin ].  sum := delta := self.  self2 := 0.0 - (self * self).  i := 2.0.  [ delta > Epsilon ] whileTrue: [ delta := delta * self2 / (i * (i + 1.0)).        i := i + 2.0.        sum := sum + delta.        delta := delta * self2 / (i * (i + 1.0)).        i := i + 2.0.        sum := sum + delta ].  ^sumasMilliSeconds  ^(seconds * NanosInSecond + nanos) // (10 raisedToInteger: 6)rounded  self fractionPart abs < 0.5 ifTrue: [ ^self truncated ] ifFalse: [ ^self truncated + self sign rounded ]usesClassVarNamed: aString  ^self allClassVarNames includes: aStringincludes: aDateAndTime  | dt |  dt := aDateAndTime asDateAndTime.  self scheduleDo: [:e |  e = dt ifTrue: [ ^true ] ].  ^falsemessageText  ^messageText ifNil: [ message ifNil: [ super messageText ] ifNotNil: [ message lookupClass == UndefinedObject ifTrue: [ 'receiver of "{1}" is nil' format: {message selector asString} ] ifFalse: [ message lookupClass printString , '>> #' , message selector asString ] ] ]removeClassSlot: aSlot  ^self classInstaller update: self to: [:builder |  builder           fillFor: self;           classSlots: (self class classLayout slots copyWithout: aSlot) ]firstIndexOfCategoryNumber: anInteger  anInteger < 1 ifTrue: [ ^nil ].  ^anInteger > 1 ifTrue: [ (categoryStops at: anInteger - 1) + 1 ] ifFalse: [ 1 ]mustBeBoolean  ^Boolean mustBeBooleanDeOptimize ifTrue: [ self mustBeBooleanDeOptimizeIn: thisContext sender ] ifFalse: [ self mustBeBooleanIn: thisContext sender ]category  ^self methodClass organization categoryOfElement: self selector= aNumber  < primitive: 47>  aNumber isNumber ifFalse: [ ^false ].  ^aNumber adaptToFloat: self andCompare: #=runBasicTests  self basicTestSelectors do: [:eachTestSelector |  self runTest: eachTestSelector ]displayStringLimitedTo: limit  ^self printStringLimitedTo: limit using: [:s |  self displayStringOn: s ]stepUntilSomethingOnStack  | context |  [ stackp = 0 ] whileTrue: [ self isDead ifTrue: [ ^self ].        context := self step.        context == self ifFalse: [ ^context ] ]isCharacter  ^falsesizeBranchPopTrue: distance  ^self sizeOpcodeSelector: #genBranchPopTrue: withArguments: {distance}testOrganization  | aClassOrganizer |  aClassOrganizer := ClassDescription organization.  self assert: (aClassOrganizer isKindOf: ClassOrganization)className  ^self class name asStringtestNaN2  | nan1 nan2 |  nan1 := Float nan copy.  nan2 := Float nan copy.  self deny: nan1 equals: nan2.  self deny: nan1 identicalTo: nan2.  self deny: nan1 equals: nan1.  self assert: nan1 identicalTo: nan1.  self assert: nan1 size equals: 2.  self assert: (nan1 at: 2) equals: 0.  nan1 at: 1 put: (nan1 at: 1) + 999.  self assert: nan1 isNaN.  self assert: nan2 isNaN.  self deny: (nan1 at: 1) equals: (nan2 at: 1).  self deny: nan1 equals: nan2.  self deny: nan1 identicalTo: nan2.  self deny: nan1 equals: nan1.  self assert: nan1 identicalTo: nan1linkAt: index  ^self linkAt: index ifAbsent: [ self errorSubscriptBounds: index ]removeProperty: propName  ^self removeProperty: propName ifAbsent: [ nil ]testPrintStringSecond  self assert: '-1199-01-05T20:33:14.321-05:00' asDateAndTime printString equals: '-1199-01-05T20:33:14.321-05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: '2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime printString equals: '2002-05-16T17:20:45-02:34'.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime printString equals: '2002-05-16T17:20:45+00:00'.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime printString equals: '1997-04-26T01:02:03+01:02:3'testStoreOn  | float |  float := -1.2.  self assert: (String streamContents: [:s |  float storeOn: s ]) equals: ' -1.2'.  float := 1.2.  self assert: (String streamContents: [:s |  float storeOn: s ]) equals: '1.2'asByteArrayOfSize: aSize  | answer digitPos |  aSize < self bytesCount ifTrue: [ self error: 'number to large for byte array' ].  answer := ByteArray new: aSize.  digitPos := 1.  aSize to: aSize - self bytesCount + 1 by: -1 do: [:pos |  answer at: pos put: (self byteAt: digitPos).        digitPos := digitPos + 1 ].  ^answerlongStack  ^String streamContents: [:stream |  (self stackOfSize: 100) do: [:item |  stream                 print: item;                 cr ] ]simpleResumeTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselftrailer  ^CompiledMethodTrailer new method: selfpointersToExcept: objectsToExclude  | c pointers objectsToAlwaysExclude |  Smalltalk garbageCollect.  pointers := OrderedCollection new.  SystemNavigation default allObjectsDo: [:e |  (e pointsTo: self) ifTrue: [ pointers add: e ] ].  objectsToAlwaysExclude := {thisContext .   thisContext sender .   thisContext sender sender .   objectsToExclude}.  c := thisContext.  ^(pointers removeAllSuchThat: [:ea |  ea == thisContext sender or: [ (objectsToAlwaysExclude identityIncludes: ea) or: [ objectsToExclude identityIncludes: ea ] ] ]) asArrayvariableByteSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat  ^self variableByteSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: catcategoriesSorted  ^self protocolOrganizer protocolsSortedifNotNil: ifNotNilBlock  ^ifNotNilBlock cull: selftestInCriticalWait  | s p |  s := Semaphore new.  p := [ s critical: [  ] ] fork.  Processor yield.  self assert: p suspendingList identicalTo: s.  p terminate.  self assert: (s instVarNamed: #excessSignals) equals: 0aboveCenter  ^(self topLeft + self bottomRight) // (2 @ 3)shouldBePrintedAsLiteral  ^self isLiteraltestStringAsNumber  self assert: '123' asNumber equals: 123.  self assert: '-123' asNumber equals: -123.  self assert: '123.' asNumber equals: 123.  self assert: '-123.' asNumber equals: -123.  self assert: '123This is not to be read' asNumber equals: 123.  self assert: '123s could be confused with a ScaledDecimal' asNumber equals: 123.  self assert: '123e could be confused with a Float' asNumber equals: 123asWidget  ^selfprepareForNewProcess: aProcess  self subclassResponsibilitysqrt  | d n |  n := numerator sqrt.  d := denominator sqrt.  (n isInfinite or: [ d isInfinite ]) ifTrue: [ ^self asFloat sqrt ].  ^n / dscanFor: anObject  | element start finish |  finish := array size.  start := anObject basicIdentityHash \\ finish + 1.  start to: finish do: [:index |  ((element := self basicAt: index) isNil or: [ element == anObject ]) ifTrue: [ ^index ] ].  1 to: start - 1 do: [:index |  ((element := self basicAt: index) isNil or: [ element == anObject ]) ifTrue: [ ^index ] ].  ^0isSelfEvaluating  ^trueisFinalQuote  ^self characterSet isFinalQuote: selfaddSeconds: nSeconds  ^self class seconds: self asSeconds + nSecondsspotterProcessorsFor: aSpotterStep  ^(((Pragma allNamed: #spotterOrder: from: self class to: Object) select: [:pragma |  aSpotterStep processorsFilter shouldEnableProcessorsCreateBy: pragma method ]) sort: [:first :second |  (first argumentAt: 1) < (second argumentAt: 1) ]) do: [:pragma |  | currentSize |        currentSize := aSpotterStep processors size.        self spotterProcessorsFor: aSpotterStep pragma: pragma.        aSpotterStep configureProcessorsStartingAt: currentSize + 1 with: (aSpotterStep processorsFilter configurationBlockForProcessorsCreatedBy: pragma method) ]testBasicCheck  | testMethod |  testMethod := testClass >> (testClass compile: 'testMethod BoxedFloat64').  self assert: (FloatReferencesRule new basicCheck: testMethod ast)delaySemaphore  ^delaySemaphoreslots  ^#()testMethodsAccessingSlot  | numberViaSlot numberViaIVar |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  numberViaSlot := (Point methodsAccessingSlot: (Point slotNamed: #x)) size.  numberViaIVar := (Point whichSelectorsAccess: 'x') size.  self assert: numberViaSlot equals: numberViaIVarclassDefinitions  ^Array with: self asClassDefinitiontestNBitAndNNegatedEqualsN  | n |  1 to: 100 do: [:i |  n := 1 bitShift: i.        self assert: (n bitAnd: n negated) equals: n ]dependencyChecker  ^(DependencyChecker ifNil: [ DADependencyChecker ]) newtraitCompositionString  ^'{}'testMutateByteArrayUsingFloatAtPut  < expectedFailure>  | guineaPig |  guineaPig := ByteArray new: 5.  guineaPig beReadOnlyObject.  self should: [ guineaPig floatAt: 1 put: 1.0 ] raise: ModificationForbidden.  [ guineaPig floatAt: 1 put: 1.0 ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first equals: 1.0handleFailingFailingBasicNew: sizeRequested  < primitive: 71>  OutOfMemory signal.  ^self basicNew: sizeRequestedretryModification  fieldIndex notNil ifTrue: [ object perform: retrySelector with: fieldIndex with: newValue ] ifFalse: [ object perform: retrySelector with: newValue ].  self resumeUnchecked: newValuecontextStack  ^self stackOfSize: 100000testAsTime  self assert: aTimespan asTime equals: jan01 asTimevalue: firstArg value: secondArg value: thirdArg  < primitive: 207>  | newContext |  numArgs ~= 3 ifTrue: [ self numArgsError: 3 ].  false ifTrue: [ newContext := self asContextWithSender: thisContext sender.        newContext at: 1 put: firstArg.        newContext at: 2 put: secondArg.        newContext at: 3 put: thirdArg.        thisContext privSender: newContext ] ifFalse: [ self primitiveFailed ]target: anObject  target := anObjectfirstDayOfMonth  ^self asMonth start daysetUp  super setUp.  className := #TUTU.  testEnvironment := Smalltalk globals.  self deleteClass.  Object subclass: className instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self categoryNameForTemporaryClassesaddCategory: aProtocolName before: aUselessArgument  self addCategory: aProtocolNamepcInOuter  | outer end instructionStream |  outer := self outerCode.  instructionStream := InstructionStream on: outer.  end := outer endPC.  [ instructionStream pc <= end ] whileTrue: [ (self encoderClass isCreateFullBlock: self code: outer at: instructionStream pc) ifTrue: [ ^instructionStream pc ].        instructionStream pc: (instructionStream nextPc: (outer at: instructionStream pc)) ].  self error: 'block not installed in outer code'addSharedPool: aSharedPool  (self sharedPools includes: aSharedPool) ifTrue: [ ^self error: 'This is already in my shared pool list' ].  self sharedPools == nil ifTrue: [ self sharedPools: (OrderedCollection with: aSharedPool) ] ifFalse: [ self sharedPools add: aSharedPool ]signalAll  ^self signalAll: niltestZeroRaisedToInteger  self should: [ 0.0s1 raisedToInteger: -1 ] raise: Error.  self assert: (0.0s1 raisedToInteger: 0) equals: 1.  self assert: (0.0s1 raisedToInteger: 0) scale equals: 1.  self assert: (0.0s1 raisedToInteger: 1) equals: 0.  self assert: (0.0s1 raisedToInteger: 1) scale equals: 1.  self assert: (0.0s1 raisedToInteger: 2) equals: 0.  self assert: (0.0s1 raisedToInteger: 2) scale equals: 1instVarName  ^instVarNameensureReceiverAndArguments: aReceiver  aReceiver ifNil: [ ^false ].  aReceiver class isObsolete ifTrue: [ ^false ].  (aReceiver isBehavior and: [ self receiver isObsolete ]) ifTrue: [ ^false ].  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg :flag |  arg ifNil: [ flag ifFalse: [ ^false ] ] ] ].  ^trueremoveSlot: aSlot  ^self subclassResponsibilitycopy: sel from: class classified: cat  | code category |  code := class sourceCodeAt: sel.  code ifNotNil: [ cat ifNil: [ category := class organization categoryOfElement: sel ] ifNotNil: [ category := cat ].        (self includesLocalSelector: sel) ifTrue: [ code asString = (self sourceCodeAt: sel) asString ifFalse: [ self error: self name , ' ' , sel , ' will be redefined if you proceed.' ] ].        self compile: code classified: category ]jump: distance if: condition  | bool |  bool := self pop.  (bool == true or: [ bool == false ]) ifFalse: [ ^self send: #mustBeBoolean to: bool with: {} super: false ].  (bool eqv: condition) ifTrue: [ self jump: distance ]supportsClosureOpcodes  ^trueepiceaBrowsersAsString  | numberOfDaysAgo |  numberOfDaysAgo := self class today subtractDate: self.  numberOfDaysAgo < 2 ifTrue: [ ^String streamContents: [:stream |  stream nextPutAll: (numberOfDaysAgo = 0 ifTrue: [ 'Today' ] ifFalse: [ 'Yesterday' ]) ] ].  (numberOfDaysAgo between: 2 and: 7) ifTrue: [ ^numberOfDaysAgo asString , ' days ago' ].  ^self asDate asStringisLiteral  ^trueflushCache  < primitive: 116>  testReadFromUTCOffset  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321Z' readStream) offset isZero.  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321+00' readStream) offset isZero.  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321+0000' readStream) offset isZero.  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321+00:00' readStream) offset isZerolink: aMetaLink toTemporaryNamed: aTempVarName inMethod: aMethodName option: option  aMetaLink installOnTempVarNamed: aTempVarName inMethod: aMethodName for: self option: option instanceSpecific: self intanceSpecificMetaLinksAvailableisExtended  ^self extendingPackages isEmptyhash  (self isFinite and: [ self fractionPart = 0.0 ]) ifTrue: [ ^self truncated hash ].  ^((self basicAt: 1) bitAnd: 16r00FFFF00) + ((self basicAt: 2) bitAnd: 16r00FFFF00) bitShift: -8testYearDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1970 day: 1 hour: 0 minute: 0 second: 0)namedTempAt: index  ^self tempNamed: (self tempNames at: index)includesAnyOf: aCollection  ^self includesAny: aCollectiontestAsLargerPowerOfTwo  self should: [ (2 raisedTo: 80) negated asLargerPowerOfTwo ] raise: DomainError.  self should: [ -1 asLargerPowerOfTwo ] raise: DomainError.  self should: [ 0 asLargerPowerOfTwo ] raise: DomainError.  self assert: 1 asLargerPowerOfTwo equals: 1.  self assert: 2 asLargerPowerOfTwo equals: 2.  self assert: 3 asLargerPowerOfTwo equals: 4.  self assert: 4 asLargerPowerOfTwo equals: 4.  self assert: 5 asLargerPowerOfTwo equals: 8.  self assert: ((2 raisedTo: 80) + 1) asLargerPowerOfTwo equals: (2 raisedTo: 80 + 1).  self assert: (2 raisedTo: 80) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self assert: ((2 raisedTo: 80) - 1) asLargerPowerOfTwo equals: (2 raisedTo: 80)bytesCompare: arg  < primitive: 'primDigitCompare' module: 'LargeIntegers'>  | len arglen argDigit selfDigit |  len := self bytesCount.  (arglen := arg bytesCount) ~= len ifTrue: [ arglen > len ifTrue: [ ^-1 ] ifFalse: [ ^1 ] ].  [ len > 0 ] whileTrue: [ (argDigit := arg byteAt: len) ~= (selfDigit := self byteAt: len) ifTrue: [ argDigit < selfDigit ifTrue: [ ^1 ] ifFalse: [ ^-1 ] ].        len := len - 1 ].  ^0debug: context title: title  ^self debug: context title: title full: falseactiveOuterContext  | outerContext |  self isBlockContext ifFalse: [ ^self ].  self sender ifNil: [ ^nil ].  outerContext := self outerContext.  ^self sender findContextSuchThat: [:ctxt |  ctxt = outerContext ]testCharacterization  self assert: Float fmax successor equals: Float infinity.  self assert: Float infinity predecessor equals: Float fmax.  self assert: Float fmax negated predecessor equals: Float infinity negated.  self assert: Float infinity negated successor equals: Float fmax negated.  self assert: Float fmin predecessor equals: 0.0.  self assert: 0.0 successor equals: Float fmin.  self assert: Float fmin negated successor equals: 0.0.  self assert: 0.0 predecessor equals: Float fmin negated.  self assert: Float one + Float epsilon > Float one.  self assert: Float one + Float epsilon equals: Float one successor.  self assert: Float one + (Float epsilon / Float radix) equals: Float one.  self assert: Float fmax exponent equals: Float emax.  self assert: Float fminNormalized exponent equals: Float emin.  Float denormalized ifTrue: [ self assert: Float fminDenormalized exponent equals: Float emin + 1 - Float precision ].  self assert: (Float radix - Float epsilon) * (Float radix raisedTo: Float emax) equals: Float fmax.  self assert: Float epsilon * (Float radix raisedTo: Float emin) equals: Float fmin.  self assert: Float one predecessor successor equals: Float one.  self assert: Float one successor predecessor equals: Float one.  self assert: Float one negated predecessor successor equals: Float one negated.  self assert: Float one negated successor predecessor equals: Float one negated.  self assert: Float infinity successor equals: Float infinity.  self assert: Float infinity negated predecessor equals: Float infinity negated.  self assert: Float nan predecessor isNaN.  self assert: Float nan successor isNaN.  self assert: Float fmax hex equals: '7FEFFFFFFFFFFFFF'.  self assert: Float fminDenormalized hex equals: '0000000000000001'.  self assert: Float fminNormalized hex equals: '0010000000000000'.  self assert: 0.0 hex equals: '0000000000000000'.  self assert: Float negativeZero hex equals: '8000000000000000'.  self assert: Float one hex equals: '3FF0000000000000'.  self assert: Float infinity hex equals: '7FF0000000000000'.  self assert: Float infinity negated hex equals: 'FFF0000000000000'fuelAccept: aGeneralMapper  ^aGeneralMapper visitHookPrimitive: selfmessages  | aSet |  aSet := self localMessages.  self innerCompiledBlocksDo: [:cb |  aSet := aSet , cb messages ].  ^aSetsourceNode  ^self subclassResponsibilityjsonOn: aRenderer  aRenderer nullallLiterals  | literals numberLiterals |  literals := Array new: (numberLiterals := self numLiterals).  1 to: numberLiterals do: [:index |  literals at: index put: (self objectAt: index + 1) ].  ^literalsprintOn: aStream showingDecimalPlaces: placesDesired  self printOn: aStream base: 10.  placesDesired <= 0 ifTrue: [ ^self ].  aStream nextPut: $..  placesDesired timesRepeat: [ aStream nextPut: $0 ]randomCodePoint  ^self randomCodePointBetween: 0 and: Unicode maxValuesunitAnnounce: aTestCase toResult: aTestResult  self resumetestPlus  self assert: aDateAndTime + '0:00:00:00' equals: aDateAndTime.  self assert: aDateAndTime + 0 equals: aDateAndTime.  self assert: aDateAndTime + aDuration equals: (DateAndTime year: 1980 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)package  ^self packageFromOrganizer: RPackage organizertestMutateByteStringyUsingAtPut  | guineaPig |  guineaPig := ByteString new: 5.  guineaPig beReadOnlyObject.  self should: [ guineaPig at: 1 put: $h ] raise: ModificationForbidden.  [ guineaPig at: 1 put: $h ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first equals: $hremoveSubclass: aClass  * aNumber  | d1 d2 |  aNumber isFraction ifTrue: [ d1 := numerator gcd: aNumber denominator.        d2 := denominator gcd: aNumber numerator.        (d2 = denominator and: [ d1 = aNumber denominator ]) ifTrue: [ ^numerator // d1 * (aNumber numerator // d2) ].        ^Fraction numerator: numerator // d1 * (aNumber numerator // d2) denominator: denominator // d2 * (aNumber denominator // d1) ].  ^aNumber adaptToFraction: self andSend: #*ticks  ^Array with: 0 with: seconds with: nanosisLineSeparator  ^self characterSet isLineSeparator: selfasNumber  ^selftestPerformCanExecutelongMethodWithTemps  | temp1 temp2 temp3 |  temp1 := 33.  temp2 := 666.  temp3 := 42.  self assert: (self perform: #a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15: withArguments: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)) equals: 1.  self assert: (self class >> #testPerformCanExecutelongMethodWithTemps) frameSize equals: CompiledMethod smallFrameSize.  self assert: (self class >> #a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15:) frameSize equals: CompiledMethod fullFrameSizetestIsSurrogateOther  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isSurrogateOther: ch) equals: (charset isSurrogateOther: ch) ]isAbstract  | marker |  marker := self markerOrNil ifNil: [ ^false ].  ^marker == self class subclassResponsibilityMarker or: [ marker == self class explicitRequirementMarker ]dependenciesOf: aPackageName  ^#('Collections-Strings' Kernel 'AST-Core')asDate  ^Date todaynominallyUnsent: aSelectorSymbol  false ifTrue: [ self flag: #nominallyUnsent: ]schedule: aDelay  aDelay delaySemaphore signalhasSourceCode  ^self subclassResponsibilitytestIsSpacingCombiningMark  self checkCorrespondanceOf: #isSpacingCombiningMark: and: #Mcx  ^xto: other  ^(self asciiValue to: other asciiValue) collect: [:ascii |  Character value: ascii ]testClockPrecisionDuration  | ts |  ts := Timespan starting: Date today duration: DateAndTime clockPrecision.  self assert: ts start equals: ts endallSelectors  ^self allSelectorsBelow: niltestDigitAtPut  | lpi |  lpi := LargePositiveInteger new: 20.  1 to: 20 do: [:i |  lpi byteAt: i put: i ].  self assert: 114605103402541699037609980192546360895434064385 equals: lpibasicTestSelectors  ^#(#simpleEnsureTest #simpleEnsureTestWithNotification #simpleEnsureTestWithUparrow #simpleEnsureTestWithError #signalFromHandlerActionTest #resumableFallOffTheEndHandler #nonResumableFallOffTheEndHandler #doubleResumeTest #simpleTimeoutWithZeroDurationTest #simpleTimeoutTest simpleNoTimeoutTest)testDenormalizedPrintString  | i i0 |  i := LargePositiveInteger new: 4.  i basicAt: 2 put: 255.  self assert: i size equals: 4.  self assert: i printString equals: '65280'.  self assert: i normalize equals: 65280.  self assert: (i normalize isMemberOf: SmallInteger).  i0 := LargePositiveInteger new: 0.  self assert: i0 size equals: 0.  self assert: i0 printString equals: '0'.  self assert: i0 normalize equals: 0.  self assert: (i0 normalize isMemberOf: SmallInteger)stack  ^self stackOfSize: 9999name  ^'Sends a deprecated message to a known global'sizeJumpLong: distance  ^self sizeOpcodeSelector: #genJumpLong: withArguments: {distance}subclass: aSubclassSymbol slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames category: aCategorySymbol  self deprecated: 'use ... package: instead'.  ^self subclass: aSubclassSymbol slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames package: aCategorySymboltestLessThan  self assert: aTime < (Time readFrom: '12:34:57' readStream)gtInspectorSourceIn: composite  < gtInspectorPresentationOrder: 30>  self method gtInspectorSourceIn: compositenegated  ^self class newFromNumber: super negated scale: scaletestMonthDurations  | jan feb dec |  jan := Duration month: #January.  feb := Duration month: #February.  dec := Duration month: #December.  self     assert: jan equals: Year current months first duration;     assert: feb equals: Year current months second duration;     assert: dec equals: Year current months last durationreturn  self return: self defaultReturnValueisResumable  ^truetestErrorWithErrorHandler  self runSimulated: [ [ self methodWithError ] on: Error do: [:err |   ] ]valueWithEnoughArguments: anArray  | args |  args := Array new: selector numArgs.  args replaceFrom: 1 to: (arguments size min: args size) with: arguments startingAt: 1.  args size > arguments size ifTrue: [ args replaceFrom: arguments size + 1 to: (arguments size + anArray size min: args size) with: anArray startingAt: 1 ].  ^receiver perform: selector withArguments: argstestBitMask  self assert: (2r11 allMask: 2r11).  self deny: (2r10 allMask: 2r11).  self deny: (2r01 allMask: 2r11).  self assert: (2r10 anyMask: 2r11).  self assert: (2r01 anyMask: 2r11).  self deny: (2r00 anyMask: 2r11)fileOutSharedPoolsOn: aFileStream  | poolsToFileOut |  poolsToFileOut := self sharedPools select: [:aPool |  self shouldFileOutPool: (self environment keyAtIdentityValue: aPool) ].  poolsToFileOut do: [:aPool |  self fileOutPool: aPool onFileStream: aFileStream ]x106kbits  ^(15 to: 55 by: 4) inject: 9876543210 into: [:big :bits |  (big * big << bits) + bits ]- aNumber  aNumber class = self class ifTrue: [ ^self asFraction - aNumber asFraction asScaledDecimal: (scale max: aNumber scale) ].  ^self coerce: self asFraction - aNumberacceptSettings: aVisitor  ^aVisitor visitObject: selfpackAsFloatToArity: arity  | rolledPointer |  rolledPointer := self.  1 to: arity do: [:index |  rolledPointer := rolledPointer pointerFloat ].  ^rolledPointersetTimestampInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setTimestampWithBlock: selfsizeStorePopInstVarLong: instVarIndex  ^self sizeOpcodeSelector: #genStorePopInstVarLong: withArguments: {instVarIndex}testYear  self assert: aDateAndTime year equals: 1980testHour12  self assert: aDateAndTime hour12 equals: 1low16Bits  ^value & 2r1111111111111111testIsCasedLetter  self aRandomSelectionOfCharactersDo: [:ch |  self deny: (Unicode isCasedLetter: ch) ]ffiArgumentNames  ^self propertyValueAt: #ffiArgumentNames ifAbsent: [ self propertyValueAt: #ffiArgumentNames put: self argumentNames ]testNanoSecond  self assert: aDateAndTime nanoSecond equals: 0spotterForImplementorsFor: aStep  < spotterOrder: 10>  aStep listProcessor     title: 'Implementors';     allCandidates: [ self implementors collect: #compiledMethod ];     filter: GTFilterSubstring;     keyBinding: $m commandheaderDescription  | s |  s := '' writeStream.  self header printOn: s.  s     cr;     nextPutAll: '"signFlag: '.  self signFlag printOn: s.  s nextPutAll: ' ('.  self encoderClass name printOn: s.  s nextPut: $).  s     cr;     nextPutAll: 'primitive: '.  self primitive printOn: s.  s     cr;     nextPutAll: ' numArgs: '.  self numArgs printOn: s.  s     cr;     nextPutAll: ' numTemps: '.  self numTemps printOn: s.  s     cr;     nextPutAll: ' numLiterals: '.  self numLiterals printOn: s.  s     cr;     nextPutAll: ' frameSize: '.  self frameSize printOn: s.  s     nextPut: $";     cr.  ^s contentsadaptToFraction: rcvr andSend: selector  ^(rcvr asScaledDecimal: scale) perform: selector with: selfobject: anObject eqeq: anOtherObject  < primitive: 110>  self primitiveFailedveryDeepCopyWith: deepCopier  roundDownTo: aNumber  ^(self / aNumber) floor * aNumbertestChangingStatus  aStopwatch activate.  self assert: aStopwatch isActive.  self assert: aStopwatch timespans size equals: 1.  aStopwatch suspend.  self assert: aStopwatch isSuspended.  self assert: aStopwatch timespans size equals: 1.  aStopwatch activate.  aStopwatch reActivate.  self assert: aStopwatch isActive.  self assert: aStopwatch timespans size equals: 3.  aStopwatch reset.  self assert: aStopwatch isSuspended.  self assert: aStopwatch timespans size equals: 0when: anEventSelector evaluate: anAction  | actions |  actions := self actionSequenceForEvent: anEventSelector.  (actions includes: anAction) ifTrue: [ ^self ].  self setActionSequence: (actions copyWith: anAction) forEvent: anEventSelectorinstanceSide  ^selfhour  ^self hour24waitUntil: aBlock maxMilliseconds: anIntegerOrNil  ^self waitUntil: aBlock for: nil maxMilliseconds: anIntegerOrNildistanceTo: aPoint  | dx dy |  dx := aPoint x - x.  dy := aPoint y - y.  ^(dx * dx + (dy * dy)) sqrtanyBitOfMagnitudeFrom: start to: stopArg  < primitive: 'primAnyBitFromTo' module: 'LargeIntegers'>  | magnitude firstDigitIx lastDigitIx rightShift leftShift stop |  start < 1 | (stopArg < 1) ifTrue: [ ^self error: 'out of range' ].  magnitude := self abs.  stop := stopArg min: magnitude highBit.  start > stop ifTrue: [ ^false ].  firstDigitIx := (start - 1) // 8 + 1.  lastDigitIx := (stop - 1) // 8 + 1.  rightShift := ((start - 1) \\ 8) negated.  leftShift := 7 - ((stop - 1) \\ 8).  firstDigitIx = lastDigitIx ifTrue: [ | digit mask |        mask := (255 bitShift: rightShift negated) bitAnd: (255 bitShift: leftShift negated).        digit := magnitude byteAt: firstDigitIx.        ^(digit bitAnd: mask) ~= 0 ].  ((magnitude byteAt: firstDigitIx) bitShift: rightShift) ~= 0 ifTrue: [ ^true ].  firstDigitIx + 1 to: lastDigitIx - 1 do: [:ix |  (magnitude byteAt: ix) ~= 0 ifTrue: [ ^true ] ].  (((magnitude byteAt: lastDigitIx) bitShift: leftShift) bitAnd: 255) ~= 0 ifTrue: [ ^true ].  ^falsedeactivated  whichSelectorsRead: instVarName  ^self slotNamed: instVarName ifFound: [:slot |  self selectors select: [:sel |  slot isReadIn: self >> sel ] ] ifNone: [ #() ]fileOutOn: aFileStream initializing: aBool  super fileOutOn: aFileStream.  (aBool and: [ self includesSelector: #initialize ]) ifTrue: [ aFileStream cr.        aFileStream cr.        aFileStream nextChunkPut: thisClass name , ' initialize'.        aFileStream cr ]doesNotUnderstand: aMessage  < debuggerCompleteToSender>  ^MessageNotUnderstood new     message: aMessage;     receiver: self;     signalreturn: returnValue  handlerContext return: returnValuetestDigitAtPut  | lni |  lni := LargeNegativeInteger new: 20.  1 to: 20 do: [:i |  lni byteAt: i put: i ].  self assert: -114605103402541699037609980192546360895434064385 equals: lnimethodWithError  self error: 'my error'completeProcess: aProcess with: aContext  ^aContext methodNode pragmaNamed: #debuggerCompleteToSender ifPresent: [ aProcess completeTo: aContext sender ] ifAbsent: [ super completeProcess: aProcess with: aContext ]setDefaultList: aSortedCollection  categoryArray := Array with: Default.  categoryStops := Array with: aSortedCollection size.  elementArray := aSortedCollection asArraycommentStamp: anObject  commentStamp := anObjectarcCos  ^Halfpi - self arcSinsetKeyword: aSymbol  self deprecated: 'Use #selector: instead.' transformWith: '`@receiver setKeyword: `@arg' -> '`@receiver selector: `@arg'.  self selector: aSymbolhome  ^homesourceNode  ^self compiledBlock sourceNodeInOutertestConvertFromFraction  | sd |  sd := 13 / 11 asScaledDecimal: 6.  self assert: ScaledDecimal identicalTo: sd class.  self assert: '1.181818s6' equals: sd printString.  self assert: 6 equals: sd scale.  sd := -13 / 11 asScaledDecimal: 6.  self assert: ScaledDecimal identicalTo: sd class.  self assert: '-1.181818s6' equals: sd printString.  self assert: 6 equals: sd scalevariable  ^variableisTaggedWith: aSymbol  ^self tags includes: aSymboltestNewProcess  | hasBlockRun block return |  hasBlockRun := false.  block := [ hasBlockRun := true ].  return := block newProcess.  self deny: hasBlockRun.  self assert: (return isKindOf: Process).  self assert: return isSuspendedexplore  self deprecated: 'Please use #inspect instead' transformWith: '`@receiver explore' -> '`@receiver inspect'.  ^self inspectrationale  ^'You should not reference ' , (self systemClassNames joinUsing: Character space) , ' as they are there for system purpose and should not be referenced directly.'min: aPoint  ^(x min: aPoint x) @ (y min: aPoint y)workDatesDo: aBlock  self do: aBlock with: start asDate when: [:d |  d dayOfWeek < 6 ]isContext  ^falseremoveSelector: aSelector  self methodDict removeKey: aSelector ifAbsent: [  ]genStorePopTemp: tempIndex  (tempIndex < 0 or: [ tempIndex > 63 ]) ifTrue: [ ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63 ].  tempIndex < 8 ifTrue: [ stream nextPut: 208 + tempIndex.        ^self ].  stream     nextPut: 242;     nextPut: tempIndexmonthName  ^start monthNamepackageFromOrganizer: anOrganizer  ^anOrganizer packageOf: selfeveryDayAtSameTimes  | count |  count := (Duration days: 1) / self scheduleDuration.  ^count >= 1 and: [ count isInteger ]printOn: aStream  aStream     print: self methodClass;     nextPutAll: '>>';     print: self selectorisMorph  ^falsebrickValue: aBrick  ^selfshouldFileOutPools  ^self confirm: 'FileOut selected sharedPools?'initialize  super initialize.  self resetbasicAt: index  < primitive: 38>  ^super basicAt: indexreservedNames  ^#('self' 'thisContext' 'stack top')isThisEverCalled  ^self isThisEverCalled: thisContext sender printStringaddAndClassifySelector: selector withMethod: compiledMethod inProtocol: category  | priorMethodOrNil priorOriginOrNil oldProtocol newProtocol |  priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [ nil ].  priorMethodOrNil ifNotNil: [ priorOriginOrNil := priorMethodOrNil origin ].  self addSelectorSilently: selector withMethod: compiledMethod.  oldProtocol := self organization categoryOfElement: selector.  SystemAnnouncer uniqueInstance suspendAllWhile: [ self organization classify: selector under: (category = Protocol unclassified ifTrue: [ oldProtocol ] ifFalse: [ category ]) ].  newProtocol := self organization categoryOfElement: selector.  self isAnonymous ifTrue: [ ^self ].  (priorMethodOrNil isNil or: [ priorOriginOrNil ~= compiledMethod origin ]) ifTrue: [ SystemAnnouncer uniqueInstance methodAdded: compiledMethod ] ifFalse: [ self notifyRepackage: selector method: compiledMethod oldProtocol: oldProtocol newProtocol: newProtocol.        SystemAnnouncer uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod oldProtocol: oldProtocol ]cannotReturn: result to: aContext  ^ContextCannotReturn result: result to: aContexttestMidnight  self assert: aDateAndTime midnight equals: '2004-02-29T00:00:00+02:00' asDateAndTimetestQuotient  | d1 d2 q |  d1 := 11.5 seconds.  d2 := d1 // 3.  self assert: d2 equals: (Duration seconds: 3 nanoSeconds: 833333333).  q := d1 // 3 seconds.  self assert: q equals: 3corners  ^Array with: self topLeft with: self bottomLeft with: self bottomRight with: self topRightremoveFromSystemUnlogged  ^self removeFromSystem: falserounded  ^Rectangle origin: origin rounded corner: corner roundedmetacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent  ^aMetacelloVersonComponent metacelloSemanticIntegerLessThanSelf: selftestInstVarNamed  | obj |  obj := ObjectMockForTest new.  self assert: (obj instVarNamed: 'variable') isNil.  obj variable: 1.  self assert: (obj instVarNamed: 'variable') equals: 1.  self shouldnt: [ obj instVarNamed: 'variable' ] raise: InstanceVariableNotFound.  self should: [ obj instVarNamed: 'timoleon' ] raise: InstanceVariableNotFound.  self assert: ([ obj instVarNamed: 'timoleon' ] on: InstanceVariableNotFound do: [:ex |  ex instVarName ]) equals: 'timoleon'subclasses  | classList |  classList := Array new writeStream.  self subclassesDo: [:class |  classList nextPut: class ].  ^classList contentsduringTestCompileSilently: code classified: aCategory  ^self duringTestCompileSilently: code storeSource: true classified: aCategorytestHour  self assert: aTime hour equals: 12.  self assert: aTime hour12 equals: 12.  self assert: aTime hour24 equals: 12.  self assert: aTime hours equals: 12detentBy: detent atMultiplesOf: grid snap: snap  | r1 r2 |  r1 := self roundTo: grid.  (self roundTo: detent) = r1 ifTrue: [ ^r1 ].  snap ifTrue: [ ^self ].  r2 := self < r1 ifTrue: [ r1 - (detent asFloat / 2) ] ifFalse: [ r1 + (detent asFloat / 2) ].  ^r1 + ((self - r2) * grid asFloat / (grid - detent))notifyOfRemovedCategory: protocolName  self hasSubject ifFalse: [ ^self ].  SystemAnnouncer uniqueInstance protocolRemoved: protocolName inClass: self subjecttestSupplyAnswerUsingTraditionalMatchOfQuestion  self should: [ true = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('*Smalltalk#' true)) ]printStringLimitedTo: limit using: printBlock  | limitedString |  limitedString := String streamContents: printBlock limitedTo: limit.  limitedString size < limit ifTrue: [ ^limitedString ].  ^limitedString , '...etc...'pointsTo: anObject  ^(self instVarsInclude: anObject) or: [ ^self class == anObject ]interpretJump  ^self method encoderClass interpretJumpIn: selfstandardMessageText  ^fieldIndex ifNil: [ self nonIndexedMessageText ] ifNotNil: [ self indexedMessageText ]sender  ^outerContext sendertestFirstDayOfMonth  self assert: aDateAndTime firstDayOfMonth equals: 1testAsMonth  self assert: aDateAndTime asMonth equals: ((Month year: 2004 month: 'February') translateTo: 2 hours)adaptToInteger: rcvr andCompare: selector  ^self adaptToInteger: rcvr andSend: selectorodd  ^self even == falsetestIsLeapYear  | dateInLeapYear dateInNonLeapYear |  dateInLeapYear := january23rd2004.  dateInNonLeapYear := dateInLeapYear + 365 days.  self assert: dateInLeapYear isLeapYear equals: true.  self assert: dateInNonLeapYear isLeapYear equals: falsetestIncludes  self assert: (aTimespan includes: jan01).  self deny: (aTimespan includes: jan08)category: aString  | oldCategory |  oldCategory := self basicCategory.  aString isString ifTrue: [ self basicCategory: aString asSymbol.        self environment organization classify: self name under: self basicCategory ] ifFalse: [ self errorCategoryName ].  SystemAnnouncer uniqueInstance class: self recategorizedFrom: oldCategory to: self basicCategorycontextOfDeprecatedMethod  ^contextscaleFrom: rect1 to: rect2  ^(origin scaleFrom: rect1 to: rect2) corner: (corner scaleFrom: rect1 to: rect2)isRectangle  ^true- exception  self addExclusion: exceptionisReferenced  ^self environment allBehaviors anySatisfy: [:behavior |  behavior hasSelectorReferringTo: self binding ]bitXor: n  < primitive: 'primDigitBitXor' module: 'LargeIntegers'>  | norm |  norm := n normalize.  ^self digitLogic: norm op: #bitXor: length: (self bytesCount max: norm bytesCount)gtInspectorHash  ^self hashwhileNotNil: aBlock  ^[ self value notNil ] whileTrue: [ aBlock value ]encodeEmbeddedSourceQCompress  | str length encodedLength |  [ data isString ] assert.  str := self qCompress: data.  length := str position.  encodedLength := self encodeLengthField: length.  str nextPutAll: encodedLength.  str nextPut: self kindAsByte + encodedLength size - 1.  encodedData := str contentsround: numberOfWishedDecimal  ^(self asFraction round: numberOfWishedDecimal) asFloatisColor  ^falselogCr  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver logCr' -> '`@receiver traceCr'.  self traceCronLineFrom: p1 to: p2  ^self onLineFrom: p1 to: p2 within: 2lowerBound: anObject  lowerBound := anObjectunschedule: aDelay  readyToUnschedule wait.  delayToStop := aDelay.  timingSemaphore signalinitialize  super initialize.  reachedDefaultHandler := falsesizeTrapIfNotInstanceOf: litIndex  ^self sizeOpcodeSelector: #genTrapIfNotInstanceOf: withArguments: {litIndex}ensureReceiver: anObject  anObject ifNil: [ ^false ].  anObject class isObsolete ifTrue: [ ^false ].  (anObject isBehavior and: [ anObject isObsolete ]) ifTrue: [ ^false ].  ^truetestRounding  self assert: (6 / 90 round: 2) equals: 7 / 100testSimpleRetryUsing  self assertSuccess: (ExceptionTester new runTest: #simpleRetryUsingTest)subclass: t uses: aTraitComposition  ^self subclass: t uses: aTraitComposition instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'Unclassified'testFractionAsFloatWithUnderflow  | underflowPower |  underflowPower := Float emin - Float precision.  self assert: (2 raisedTo: underflowPower) asFloat equals: 0.0.  self assert: (2 raisedTo: underflowPower) negated asFloat equals: 0.0.  self assert: (2 raisedTo: underflowPower) negated asFloat signBit = 1 description: 'a negative underflow should return a negative zero'asStringWithCommas  ^String streamContents: [:stream |  self printWithCommasOn: stream ]testIsInitialQuote  self checkCorrespondanceOf: #isInitialQuote: and: #PinowTick  self subclassResponsibilitytestYear  self assert: aDateAndTime year equals: 1970testDayOfYear  self assert: aDateAndTime dayOfYear equals: 1setUp  | deprClass |  super setUp.  deprClass := Object newAnonymousSubclass.  testingEnvironment at: self globalName put: deprClass new.  deprClass compile: self deprecatedMethodName , ' self deprecated: ''this method is deprecated'''.  deprClass compile: self nonDeprecatedMethodName.  testClass := Object newAnonymousSubclassasContext  ^selfasBit  ^0onNextMonth  ^self addMonths: 1createDate  ^Date year: year month: month day: daytickAfterMilliseconds: milliseconds  self subclassResponsibilitytestAsUTC  self assert: aDateAndTime asUTC equals: aDateAndTimetestAsSeconds  self assert: aDuration asSeconds equals: 48780.  self assert: aDateAndTime asSeconds equals: 3255507180definitionWithoutSlots  ^String streamContents: [:stream |  stream print: self.        stream           crtab;           nextPutAll: 'instanceVariableNames: ';           store: self instanceVariablesString ]elementSize  | instSpec |  instSpec := self instSpec.  instSpec < 9 ifTrue: [ ^Smalltalk wordSize ].  instSpec >= 16 ifTrue: [ ^1 ].  instSpec >= 12 ifTrue: [ ^2 ].  instSpec >= 10 ifTrue: [ ^4 ].  ^8inspect  ^Smalltalk tools inspector inspect: selfrem: aNumber  < primitive: 20>  aNumber isInteger ifTrue: [ | ng rem |        ng := self negative == aNumber negative == false.        rem := (self digitDiv: aNumber neg: ng) at: 2.        ^rem normalize ].  ^super rem: aNumbertestRounding  self assert: (10.1234 round: 2) equals: 10.12.  self assert: (10.1234 round: 0) equals: 10exceptionClass  ^self tempAt: 1gtDebuggerRawIn: composite  (GTObjectVariablesBrowser new variablesIn: composite)     title: 'Raw';     send: #valuetestNoon  self assert: aDateAndTime noon equals: '1901-01-01T12:00:00+00:00' asDateAndTimesubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat  ^self subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat> aNumber  < primitive: 4>  ^super > aNumberspotterPreviewRawIn: aComposite  < spotterPreview: 40>  aComposite table     title: [ self gtDisplayString ];     display: [:anObject |  anObject gtInspectorVariableValuePairs asSortedCollection asOrderedCollection yourself           addFirst: 'self' -> anObject;           yourself ];     column: 'Variable' evaluated: [:assoc |  GTObjectPrinter asNonTruncatedTextFrom: assoc key ] styled: [:aBrick |  aBrick           textPosition: #rightCenter;           margin: #(0 15 0 0);           textColor: aComposite themer textLightColor;           height: 30 ];     column: 'Value' evaluated: [:assoc |  GTObjectPrinter asTruncatedTextFrom: assoc value ] styled: [:aBrick |  aBrick           margin: #(0 0 0 15);           height: 30 ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'defaultAction  UIManager default warningDefaultAction: selfisMeta  ^self isClassSidecollect: aBlock  | aLink newCollection |  newCollection := self class new.  aLink := firstLink.  [ aLink == nil ] whileFalse: [ newCollection add: (aBlock value: aLink value).        aLink := aLink nextLink ].  ^newCollection= anObject  ^self == anObjectlistAtCategoryNumber: anInteger  | firstIndex lastIndex |  (anInteger < 1 or: [ anInteger > categoryStops size ]) ifTrue: [ ^nil ].  firstIndex := self firstIndexOfCategoryNumber: anInteger.  lastIndex := self lastIndexOfCategoryNumber: anInteger.  ^elementArray copyFrom: firstIndex to: lastIndexnextByte  ^self method at: pctestMultipleTimings  aStopwatch activate.  aDelay wait.  aStopwatch suspend.  aStopwatch activate.  aDelay wait.  aStopwatch suspend.  self assert: aStopwatch timespans size equals: 2.  self assert: aStopwatch timespans first asDateAndTime <= aStopwatch timespans last asDateAndTimegenPushCharacter: aCharacterOrCode  | code |  code := aCharacterOrCode isInteger ifTrue: [ aCharacterOrCode ] ifFalse: [ aCharacterOrCode asInteger ].  (code < 0 or: [ code > 65535 ]) ifTrue: [ ^self outOfRangeError: 'character' index: code range: 0 to: 65535 ].  code > 255 ifTrue: [ self genUnsignedSingleExtendB: (code bitShift: -8) ].  stream     nextPut: 233;     nextPut: (code bitAnd: 255)superclass: aClass  aClass ifNil: [ self basicSuperclass: aClass.        Object flushCache.        ^self ].  ^self classInstaller update: self to: [:builder |  builder           fillFor: self;           superclass: aClass ]tearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  super tearDownrfIsEqual: anObject  < metaLinkOptions: #(+ optionDisabledLink)>  < primitive: 110>  self primitiveFailedisPoint  ^trueselector  ^selectortestFirstDayOfMonth  self assert: aDateAndTime firstDayOfMonth equals: 1isEmptyOrNil  ^truetestWithComplexRecursion  self should: [ self complexRecursion ] notTakeMoreThanMilliseconds: 3outer  | prevOuterContext |  self isResumable ifTrue: [ prevOuterContext := outerContext.        outerContext := thisContext contextTag ].  self passdeepCopy  ^self copytestIvalidReadFrom  self should: [ Fraction readFromString: '+3' ] raise: Error description: 'numerator cannot specify a plus sign'.  self should: [ Fraction readFromString: '-2/+3' ] raise: Error description: 'denominator cannot specify a plus sign'.  self should: [ Fraction readFromString: '(3/2)' ] raise: Error description: 'parenthesis are not allowed'.  self should: [ Fraction readFromString: ' 3/25' ] raise: Error description: 'leading spaces are not allowed before numerator'.  self should: [ Fraction readFromString: '22/ 3' ] raise: Error description: 'leading spaces are not allowed before denominator'.  self assert: (Fraction readFromString: '12345with some trailing characters') = 12345 description: 'non numeric trailing characters interrupt decoding'.  self assert: (Fraction readFromString: '1 / 2') = 1 description: 'A space behind numerator interrupt decoding'.  self assert: (Fraction readFromString: '22.0/3') = 22 description: 'decimal point interrupt decoding'.  self assert: (Fraction readFromString: '23s0/3') = 23 description: 'scale specification interrupt decoding'testAsMonthInYear  self assert: (Date asMonth: 9 inYear: 2018) asString equals: 'September 2018'value  ^selfanalogousCodeTo: anObject  ^self class == anObject class and: [ self selector == anObject selector and: [ arguments = anObject arguments ] ]restoreLocalTimeZoneAfter: aBlock  | realTimeZone |  realTimeZone := DateAndTime localTimeZone.  aBlock ensure: [ DateAndTime localTimeZone: realTimeZone ]testEncodingNoTrailer  | trailer |  trailer := CompiledMethodTrailer new.  self assert: trailer kind identicalTo: #NoTrailer.  self assert: trailer size equals: 4.  trailer := trailer testEncoding.  self assert: trailer kind identicalTo: #NoTrailer.  self assert: trailer size equals: 4.  self assert: trailer endPC equals: 0basicAt: index put: value  < primitive: 61>  index isInteger ifTrue: [ self class isVariable ifTrue: [ (index between: 1 and: self size) ifFalse: [ ^self errorSubscriptBounds: index ] ] ifFalse: [ ^self errorNotIndexable ] ] ifFalse: [ ^index isNumber ifTrue: [ self basicAt: index asInteger put: value ] ifFalse: [ self errorNonIntegerIndex ] ].  self isReadOnlyObject ifTrue: [ ^self modificationForbiddenFor: #basicAt:put: index: index value: value ].  self errorImproperStoreisFailToken: anObject  ^(self objectClass: anObject) == Array and: [ anObject size = 2 and: [ (anObject at: 1) == PrimitiveFailToken ] ]month  ^start monthassert: a classAndValueEquals: b  self assert: a class equals: b class.  self assert: a equals: btestMethodsReferencingClasses  | collectionOfMethods collectionOfMethodsShouldBe |  collectionOfMethods := ((ClassTest methodsReferencingClasses: {(Smalltalk classNamed: #ExampleForTest12) .         (Smalltalk classNamed: #ExampleForTest1)}) sort: [:a :b |  a name <= b name ]) asArray.  collectionOfMethodsShouldBe := {(ClassTest >> #referencingMethod1) .   (ClassTest >> #referencingMethod2) .   (ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.  self assert: collectionOfMethods asSet equals: collectionOfMethodsShouldBe asSetcanHandleSignal: exception  ^falsebrickAlert  GLMAlertBrick alert: selfasEpiceaRingDefinition  | baseClassDefinition |  baseClassDefinition := self instanceSide asEpiceaRingDefinition.  ^baseClassDefinition withMetaclass classSide     traitCompositionSource: self classSide traitCompositionString;     definitionSource: self classSide oldDefinition;     addInstanceVariables: self classSide instVarNames;     yourselfasStringOrText  ^self asStringtestFirstThursday  1800 to: 2000 do: [:y |  | firstThursday |        firstThursday := (Year year: y) firstThursday.        self assert: firstThursday dayOfWeek equals: 5.        self assert: firstThursday year equals: y.        self assert: (firstThursday - 1 week) year equals: y - 1 ]reverseDo: aBlock  | dep |  self basicSize to: 1 by: -1 do: [:i |  (dep := self basicAt: i) ifNotNil: [ aBlock value: dep ] ]setTimestampInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setTimestamp: (aMetacelloVersionSpec project valueHolderSpec           value: self printString;           yourself)newDebugSessionNamed: aString startedAt: aContext  ^DebugSession named: aString on: self startedAt: aContextasApproximateFraction  ^self asApproximateFractionAtOrder: 0asHours  ^self asMinutes / 60.0testIntersectionWithSelf  self assert: (aTimespan intersection: aTimespan) equals: aTimespan.  self deny: (aTimespan intersection: anIncludedTimespan) equals: aTimespanwithoutListWrapper  ^selftestInitialStatus  self assert: aStopwatch isSuspended.  self deny: aStopwatch isActive.  self assert: aStopwatch duration equals: 0 secondsendPC  ^self blockCreationBytecodeMessage arguments last + startpc - 1sizeDup  ^self sizeOpcodeSelector: #genDup withArguments: #()testBasicProxyReadOnly  self alwaysReadOnlyObjects do: [:each |  self assert: (MirrorPrimitives isObjectReadOnly: each) equals: true ]printOn: stream  stream nextPutAll: self descriptionencodeEmbeddedSourceZip  self encodeUsingZipsubclass: aSubclassSymbol uses: aTraitCompositionOrArray slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames category: aCategorySymbol  ^self subclass: aSubclassSymbol uses: aTraitCompositionOrArray layout: self classLayout class slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames category: aCategorySymbolsizeReturnTopToCaller  ^self sizeOpcodeSelector: #genReturnTopToCaller withArguments: #()gcd: anInteger  | n m |  n := self.  m := anInteger.  [ n = 0 ] whileFalse: [ n := m \\ (m := n) ].  ^m absremoveLast  | oldLink aLink |  self emptyCheck.  oldLink := lastLink.  firstLink == lastLink ifTrue: [ firstLink := nil.        lastLink := nil ] ifFalse: [ aLink := firstLink.        [ aLink nextLink == oldLink ] whileFalse: [ aLink := aLink nextLink ].        aLink nextLink: nil.        lastLink := aLink ].  oldLink nextLink: nil.  ^oldLink valuetestYearMonthDay  self assert: aDateAndTime equals: (DateAndTime year: 1970 month: 1 day: 1)printOn: aStream  super printOn: aStream.  aStream     nextPutAll: ' top: ';     print: top;     nextPutAll: ' left: ';     print: left;     nextPutAll: ' bottom: ';     print: bottom;     nextPutAll: ' right: ';     print: rightspotterActDefault  ^self browseextendRectangle: aRectangle  ^Rectangle origin: aRectangle origin corner: aRectangle corner + (self width @ self height)testIsFinalQuote  self checkCorrespondanceOf: #isFinalQuote: and: #PftestAnalogousCodeTo  | state |  state := AdditionalMethodState new: 1.  state basicAt: 1 put: #traitSource -> TSortable.  self shouldnt: [ state analogousCodeTo: state ] raise: MessageNotUnderstoodpopIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex  (self at: tempVectorIndex + 1) at: remoteTempIndex + 1 put: self popspecies  ^ArraytestNot  self assert: false nottestTicksOffset  self assert: aDateAndTime equals: (aDateAndTime ticks: #(2444240 0 0) offset: DateAndTime localOffset)resignalAs: replacementException  ^replacementException signalIn: signalContextnumberOfReservedLiterals  ^1resumptionTick  ^resumptionTicktestAsWeeks  | full half quarter |  full := Duration days: 7.  half := Duration weeks: 0.5.  quarter := Duration weeks: 0.25.  self     assert: 1 weeks equals: full;     assert: 1.0 weeks equals: full;     assert: 0.5 weeks equals: half;     assert: (1 / 2) weeks equals: half;     assert: (1 / 4) weeks equals: quarter.  self assert: 1.4 weeks + 1.6 weeks equals: 3 weeksdefaultAction  ^UIManager default unhandledErrorDefaultAction: selftestDaysLeftInYear  self assert: aDateAndTime daysLeftInYear equals: 306isClass  ^truevalueAfterWaiting: aDelay  ^[ aDelay wait.  self value ] forkAt: Processor userBackgroundPriority named: (String streamContents: [:s |  s                 << 'After ';                 print: aDelay;                 << ' do: ';                 print: self ])testTerminatedCriticalSectionShouldUnblockWaitingOne  | lastCriticalExecuted semaphoreToHoldMutex processHoldingMutex |  lastCriticalExecuted := false.  semaphoreToHoldMutex := Semaphore new.  processHoldingMutex := self fork: [ mutex critical: [ semaphoreToHoldMutex wait.              self error: 'should not happen' ] ].  self waitLastProcessLock.  self fork: [ mutex critical: [ lastCriticalExecuted := true ] ].  self waitLastProcessLock.  processHoldingMutex terminate.  self waitLastProcessTerminate.  self assert: lastCriticalExecutednegated  ^self class seconds: seconds negated nanoSeconds: nanos negatedtrace: anObject  Transcript show: anObject asStringtestWaitTimeoutSecondsOnCompletionOnTimeout  self assert: (Semaphore new waitTimeoutSeconds: 0.05 onCompletion: [ #completed ] onTimeout: [ #timeout ]) identicalTo: #timeout.  self assert: (Semaphore new signal waitTimeoutSeconds: 0.05 onCompletion: [ #completed ] onTimeout: [ #timeout ]) identicalTo: #completedtestDegreeSinForExceptionalValues  self assert: Float nan degreeSin isNaN.  self assert: Float infinity degreeSin isNaN.  self assert: Float infinity negated degreeSin isNaNrenderOn: aRenderer  aRenderer text: selfnanoSecond  ^self nanoSecondstestIntegerReadsOkFromString  self assert: (Integer readFrom: '123') equals: 123.  self assert: (Integer readFrom: '-123') equals: -123.  self assert: (Integer readFrom: 'a3' base: 16) equals: 163.  self assert: (Integer readFrom: '-a3' base: 16) equals: -163commonSuperclassWith: aClass  ^self allSuperclasses detect: [:class |  aClass allSuperclasses includes: class ] ifNone: nilprimitive  | initialPC |  ^(self header anyMask: 65536) ifTrue: [ (self at: (initialPC := self initialPC) + 1) + ((self at: initialPC + 2) bitShift: 8) ] ifFalse: [ 0 ]testNanoSecond  self assert: aDateAndTime nanoSecond equals: 0activeHome  | methodReturnContext |  self isBlockContext ifFalse: [ ^self ].  self sender ifNil: [ ^nil ].  methodReturnContext := self methodReturnContext.  ^self sender findContextSuchThat: [:ctxt |  ctxt = methodReturnContext ]testMinutes  self assert: aDateAndTime minutes equals: 0waitForUserSignalled: timingSemaphore orExpired: activeDelay  | nextTick |  nextTick := self nowTick + (1 * 1000 * 1000).  activeDelay ifNotNil: [ nextTick := nextTick min: activeDelay resumptionTick ].  timingSemaphore initSignals.  self primSignal: timingSemaphore atUTCMicroseconds: nextTick.  timingSemaphore wait& aBoolean  ^aBooleantestAddInstVarName  | tutu |  tutu := testEnvironment at: #TUTU.  tutu addInstVarNamed: 'x'.  self assert: tutu instVarNames equals: #('x').  tutu addInstVarNamed: 'y'.  self assert: tutu instVarNames equals: #('x' 'y')nthRoot: aPositiveInteger  aPositiveInteger = 2 ifTrue: [ ^self sqrt ].  (aPositiveInteger isInteger not or: [ aPositiveInteger negative ]) ifTrue: [ ^ArithmeticError signal: 'nth root only defined for positive Integer n.' ].  ^self negative ifTrue: [ aPositiveInteger odd ifTrue: [ (self negated raisedTo: 1.0 / aPositiveInteger) negated ] ifFalse: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ] ] ifFalse: [ self raisedTo: 1.0 / aPositiveInteger ]hasClassSide  ^self subclassResponsibilitytestIndexOfDay  | days |  days := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).  days withIndexDo: [:item :index |  self assert: (Week indexOfDay: item) equals: index ].  self assert: (Week indexOfDay: 0) equals: 0.  self assert: (Week indexOfDay: 1) equals: 0.  self assert: (Week indexOfDay: 7) equals: 0.  self assert: (Week indexOfDay: 8) equals: 0.  self assert: (Week indexOfDay: #Sunnyday) equals: 0outerContext: ctxt  outerContext := ctxttestActiveHomeMethodContext  self     assert: aMethodContext activeHome identicalTo: aMethodContext;     assert: aMethodContext activeHome identicalTo: aMethodContext homecompile: code classified: heading  ^self compile: code classified: heading notifying: nilstartUp  Warning signal: 'Delay scheduler is NOT RUNNING!'testIsClassSide  self deny: Point isClassSide.  self assert: Point class isClassSidegrid: aPoint  | newX newY |  newX := x + (aPoint x // 2) truncateTo: aPoint x.  newY := y + (aPoint y // 2) truncateTo: aPoint y.  ^newX @ newYgreaseInteger  ^self charCodefirstComment  ^self comments ifEmpty: [ #() ] ifNotEmpty: [:comments |  comments first ]hours  ^self hourisStream  ^falsereadsField: varIndex  self isReturnField ifTrue: [ ^self returnField = (varIndex - 1) ].  ^super readsField: varIndexisPowerOfTwo  ^falsetestReferencedClasses  {(ExceptionTester -> {MyTestNotification .         Warning .         String .         MyResumableTestError .         OrderedCollection .         MyTestError}) .   (CollectionCombinator -> {Array}) .   (ExecutionEnvironmentStub -> {OrderedCollection})} do: [:assoc |  self assert: assoc key referencedClasses notEmpty.        self assert: (assoc key referencedClasses asSet includesAll: assoc value asSet) ]numArgs  ^closureOrNil ifNil: [ method numArgs ] ifNotNil: [ closureOrNil numArgs ]interpolateTo: end at: amountDone  ^self * (1 - amountDone) + (end * amountDone)testHighBitOfMagnitude  | suite |  suite := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA) , {SmallInteger maxVal .         (SmallInteger maxVal + 1)}.  suite := suite , (suite collect: [:e |  e raisedTo: 20 ]).  suite do: [:anInteger |  | highBit shifted |        highBit := 0.        shifted := 1.        [ shifted > anInteger ] whileFalse: [ highBit := highBit + 1.              shifted := shifted bitShift: 1 ].        self assert: anInteger highBitOfMagnitude equals: highBit.        self assert: anInteger negated highBitOfMagnitude equals: highBit ]testNegativeZeroAbs  self assert: Float negativeZero abs sign positive description: 'the absolute value of a negative zero is zero'fileOutInitializerOn: aStream  (self includesSelector: #initialize) ifTrue: [ aStream cr.        aStream nextChunkPut: self soleInstance name , ' initialize' ]pragmaDo: aBlock  1 to: self basicSize do: [:i |  | propertyOrPragma |        propertyOrPragma := self basicAt: i.        propertyOrPragma isVariableBinding ifFalse: [ aBlock value: propertyOrPragma ] ]asPolygonTransformedBy: aTransform  ^{(aTransform transform: origin) .   (aTransform transformX: corner x Y: origin y) .   (aTransform transform: corner) .   (aTransform transformX: origin x Y: corner y)}home: anObject  home := anObjecttestHandlerFromAction  | result |  result := [ [ [ self error: 'trigger error' ] on: ZeroDivide do: [:ex |  'inner' ] ] on: Error do: [:ex |  3 / 0 ] ] on: ZeroDivide do: [:ex |  'outer' ].  self assert: 'outer' = result description: 'Incorrect handler'testNow  self deny: aDateAndTime equals: DateAndTime nowreferencingMethod1  ^ExampleForTest1isClass  ^truedaysInMonth  ^self asMonth daysInMonthisExtensionInPackage: anRPackage  ^anRPackage includesExtensionSelector: self selector ofClass: self methodClassvariableWriteNodes  ^self methods flatCollect: [:each |  each variableWriteNodes ]copyTo: aContext  | copy |  self == aContext ifTrue: [ ^nil ].  copy := self copy.  self sender ifNotNil: [ copy privSender: (self sender copyTo: aContext) ].  ^copyinitializeFrom: anotherClassTrait  self traitComposition: self traitComposition copyTraitExpression.  self methodDict: self methodDict copy.  self basicOrganization: self organization copymethodReturnContext  ^self hometestHasSharedPools  self deny: Point hasSharedPools.  self assert: Date hasSharedPools.  self deny: Date class hasSharedPools.  self assert: RootClassPoolUser hasSharedPools.  self deny: SubclassPoolUser hasSharedPoolstestHour12  self assert: aDateAndTime hour12 equals: DateAndTime new hour12.  self assert: aDateAndTime hour12 equals: 12parseTwoDigitYear  year := self parse: 'year' expectedSize: 2doYetAnotherThing  self log: self doYetAnotherThingStringrewriterClass  ^self class environment at: #RBParseTreeRewriter ifAbsent: [ nil ]testValueWithinTimingRepeat  | time |  time := [ 3 timesRepeat: [ [ 500 milliSeconds asDelay wait ] valueWithin: 100 milliSeconds onTimeout: [  ] ] ] durationToRun.  self assert: time < 500 milliSecondstestIsPrime  self assert: 17 isPrime.  self assert: 78901 isPrime.  self assert: 104729 isPrime.  self assert: 15485863 isPrime.  self assert: 2038074743 isPrime.  self assert: 29996224275833 isPrime.  self deny: 561 isPrime.  self deny: 2821 isPrime.  self deny: 6601 isPrime.  self deny: 10585 isPrime.  self deny: 15841 isPrime.  self deny: 256 isPrime.  self deny: 29996224275831 isPrimeresumeUnchecked: resumptionValue  | ctxt |  outerContext ifNil: [ signalContext return: resumptionValue ] ifNotNil: [ ctxt := outerContext.        outerContext := ctxt tempAt: 1.        ctxt return: resumptionValue ]testAsDate  self assert: aDateAndTime asDate equals: 'January 1, 1901' asDateffiCalloutIn: aContext  ^self calloutAPIClass inContext: aContext// anInteger  < primitive: 32>  ^super // anIntegerthreeWayCompareTo: anotherObject  ^self asBit threeWayCompareTo: anotherObject asBitreading: aPattern pattern: aString  ^(self dateParserClass readingFrom: aString readStream pattern: aPattern) parseisRingResolved  ^trueveryDeepCopyWith: deepCopier  ^self shallowCopy= aRectangle  self species = aRectangle species ifTrue: [ ^origin = aRectangle origin and: [ corner = aRectangle corner ] ] ifFalse: [ ^false ]hasSource  ^kind == #EmbeddedSource or: [ kind == #EmbeddedSourceQCompress or: [ kind == #EmbeddedSourceZip ] ]testGeneralInquiries  | date aDateAndTime |  self should: [ self timeClass timeWords ] raise: MessageNotUnderstood.  date := '2 June 1973' asDate.  time := '4:02:47 am' asTime.  aDateAndTime := self timeClass dateAndTimeFromSeconds: 2285280000 + 14567.  self assert: aDateAndTime equals: {date .         time}testDegreeCos  45.0 degreeCos.  self assert: (45.0 degreeCos squared - 0.5) abs <= Float epsilon.  self assert: (60.0 degreeCos - 0.5) abs <= Float epsilon.  self assert: (120.0 degreeCos + 0.5) abs <= Float epsilon.  -360.0 to: 360.0 do: [:i |  self assert: (i degreeCos closeTo: i degreesToRadians cos) ].  -10.0 to: 10.0 do: [:k |  self assert: (k * 360 + 90) degreeCos equals: 0.        self assert: (k * 360 - 90) degreeCos equals: 0.        self assert: (k * 360 + 180) degreeCos + 1 equals: 0.        self assert: (k * 360) degreeCos - 1 equals: 0 ]even  ^self \\ 2 = 0julianDayNumber  ^start julianDayNumberfork: aBlock  | newProcess |  newProcess := aBlock forkNamed: testSelector.  forkedProcesses add: newProcess.  ^newProcessiconOrThumbnailOfSize: aNumberOrPoint  ^niltestIsQuick  | method |  method := self class compiledMethodAt: #returnTrue.  self assert: method isQuick.  method := self class compiledMethodAt: #returnPlusOne:.  self deny: method isQuick<= aPoint  ^x <= aPoint x and: [ y <= aPoint y ]testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 13.  self assert: aDateAndTime hour equals: aDateAndTime hoursspotterSuperMethodsFor: aStep  < spotterOrder: 11>  aStep listProcessor     title: 'Super instance methods';     allCandidates: [ self allMethods reject: [:each |  each methodClass = self ] ];     filter: GTFilterSubstringtempNames  ^self sourceNode temporaryNamesgenPushFullClosure: compiledBlockLiteralIndex numCopied: numCopied receiverOnStack: receiverOnStack outerContextNeeded: outerContextNeeded  | extendedIndex |  (numCopied < 0 or: [ numCopied > 64 ]) ifTrue: [ self outOfRangeError: 'num copied' index: numCopied range: 0 to: 64 ].  (compiledBlockLiteralIndex < 0 or: [ compiledBlockLiteralIndex > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: compiledBlockLiteralIndex range: 0 to: 32768 ].  (extendedIndex := compiledBlockLiteralIndex) > 255 ifTrue: [ self genUnsignedSingleExtendA: extendedIndex // 256.        extendedIndex := extendedIndex \\ 256 ].  stream     nextPut: 249;     nextPut: extendedIndex;     nextPut: (receiverOnStack asBit << 7) + (outerContextNeeded not asBit << 6) + numCopiedreturn: aContext value: value  suspendedContext == aContext ifTrue: [ ^Processor activeProcess evaluate: [ suspendedContext := aContext return: value from: aContext ] onBehalfOf: self ].  self activateReturn: aContext value: value.  ^self complete: aContextisFailedTest  ^self methodClass isTestCase and: [ self methodClass methodFailed: self selector ]testDoWith  | count |  count := 0.  aTimespan do: [:each |  count := count + 1 ] with: (Timespan starting: jan01 duration: aDay).  self assert: count equals: 7selector  | penultimateLiteral |  ^(penultimateLiteral := self penultimateLiteral) isMethodProperties ifTrue: [ penultimateLiteral selector ] ifFalse: [ penultimateLiteral ]simpleTimeoutWithZeroDurationTestResults  ^OrderedCollection new     add: self doSomethingElseString;     yourselfsameLiteralsAs: method  | numLits literal1 literal2 |  (numLits := self numLiterals) ~= method numLiterals ifTrue: [ ^false ].  1 to: numLits - 1 do: [:index |  literal1 := self literalAt: index.        literal2 := method literalAt: index.        (literal1 == literal2 or: [ literal1 literalEqual: literal2 ]) ifFalse: [ (index = 1 and: [ self isNamedPrimitive | self isExternalCallPrimitive ]) ifTrue: [ literal1 isArray ifTrue: [ (literal2 isArray and: [ literal1 allButLast = literal2 allButLast ]) ifFalse: [ ^false ] ] ifFalse: [ (literal1 analogousCodeTo: literal2) ifFalse: [ ^false ] ] ] ifFalse: [ index = (numLits - 1) ifTrue: [ (literal1 isSymbol and: [ literal2 isSymbol ]) ifFalse: [ (self properties analogousCodeTo: method properties) ifFalse: [ ^false ] ] ] ifFalse: [ ^false ] ] ] ].  literal1 := self literalAt: numLits.  literal2 := method literalAt: numLits.  ^literal1 class == literal2 class and: [ literal1 isVariableBinding ifTrue: [ literal1 key = literal2 key and: [ literal1 value = literal2 value ] ] ifFalse: [ literal1 = literal2 ] ]pushFullClosure: compiledBlock numCopied: numCopied receiverOnStack: onStack ignoreOuterContext: ignore  | copiedValues cls |  copiedValues := (1 to: numCopied) collect: [:i |  self pop ].  self push: (cls := (FullBlockClosure new: numCopied)           outerContext: (ignore ifFalse: [ self ]);           receiver: (onStack ifTrue: [ self pop ] ifFalse: [ receiver ]);           numArgs: compiledBlock numArgs;           compiledBlock: compiledBlock;           yourself).  copiedValues size to: 1 by: -1 do: [:i |  cls at: copiedValues size - i + 1 put: (copiedValues at: i) ]asSDLRect  ^SDL_Rect newX: origin x rounded y: origin y rounded w: (corner x - origin x) rounded h: (corner y - origin y) roundedclone  ^selftestSubclass  | cls |  (testEnvironment includesKey: #SubclassExample) ifTrue: [ (testEnvironment at: #SubclassExample) removeFromSystem ].  self deny: (testEnvironment includesKey: #SubclassExample).  cls := Object subclass: #SubclassExample.  self assert: (testEnvironment includesKey: #SubclassExample).  self assert: (testEnvironment at: #SubclassExample) identicalTo: cls.  self assert: cls category equals: self unclassifiedCategory.  self assert: cls instVarNames equals: #().  cls removeFromSystemtestDisplayString  self assert: Object new displayString equals: 'an Object'testAccessing  self     assert: timespan start equals: (DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0);     assert: timespan duration equals: (Duration hours: 100);     assert: timespan month equals: 3;     assert: timespan monthName equals: 'March';     assert: timespan monthAbbreviation equals: 'Mar'pointer  ^self pointerDoubleprintSeparatedBy: aDelimiter every: offset signed: printSigned base: base on: aStream  | digits |  digits := self abs printStringBase: base.  self signBit = 1 ifTrue: [ aStream nextPut: $- ] ifFalse: [ printSigned ifTrue: [ aStream nextPut: $+ ] ].  1 to: digits size do: [:i |  aStream nextPut: (digits at: i).        (i < digits size and: [ (i - digits size) \\ offset = 0 ]) ifTrue: [ aStream nextPut: aDelimiter ] ]squared  ^self class newFromNumber: super squared scale: scaledefaultAction  Smalltalk signalLowSpacecompiledBlock  ^startpcspotterSubclassesFor: aStep  < spotterOrder: 50>  aStep listProcessor     title: 'All subclasses';     allCandidates: [ self allSubclasses ];     itemIcon: #systemIcon;     filter: GTFilterSubstringraiseWarning  ^self class raiseWarningticks: ticks offset: utcOffset  self setJdn: (ticks at: 1) seconds: (ticks at: 2) nano: (ticks at: 3) offset: utcOffsettestIntegerReadsNotOkFromStream  self should: [ Integer readFrom: 'a23' readStream ] raise: Error.  self should: [ Integer readFrom: '-a23' readStream ] raise: Error.  self should: [ Integer readFrom: 'a3' readStream base: 8 ] raise: Error.  self should: [ Integer readFrom: '-a3' readStream base: 8 ] raise: Errorcomment: aStringOrText stamp: aStamp  self instanceSide classComment: aStringOrText stamp: aStampasKeyCombination  ^KMSingleKeyCombination from: self asCharacterwriteXandY  x := 33.  y := 66genSend: selectorLiteralIndex numArgs: nArgs  nArgs < 0 ifTrue: [ ^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 ].  selectorLiteralIndex < 0 ifTrue: [ (selectorLiteralIndex negated between: 176 and: 207) ifFalse: [ ^self outOfRangeError: 'special selector code' index: selectorLiteralIndex negated range: 176 to: 207 ].        stream nextPut: selectorLiteralIndex negated.        ^self ].  (selectorLiteralIndex < 16 and: [ nArgs < 3 ]) ifTrue: [ stream nextPut: 208 + (nArgs * 16) + selectorLiteralIndex.        ^self ].  (selectorLiteralIndex < 32 and: [ nArgs < 8 ]) ifTrue: [ stream           nextPut: 131;           nextPut: (nArgs bitShift: 5) + selectorLiteralIndex.        ^self ].  (selectorLiteralIndex < 64 and: [ nArgs < 4 ]) ifTrue: [ stream           nextPut: 134;           nextPut: (nArgs bitShift: 6) + selectorLiteralIndex.        ^self ].  (selectorLiteralIndex < 256 and: [ nArgs < 32 ]) ifTrue: [ stream           nextPut: 132;           nextPut: nArgs;           nextPut: selectorLiteralIndex.        ^self ].  nArgs >= 32 ifTrue: [ ^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 ].  selectorLiteralIndex >= 256 ifTrue: [ ^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255 ]instVarNamed: aString put: aValue  ^self class slotNamed: aString ifFound: [:slot |  slot write: aValue to: self ] ifNone: [ InstanceVariableNotFound signalFor: aString asString ]subclass: subclassName uses: aTraitComposition layout: aLayout slots: someSlots classVariables: someClassVariables poolDictionaries: somePoolDictionaries category: aCategory  ^self classInstaller make: [:builder |  builder           name: subclassName;           superclass: self;           slots: someSlots;           layoutClass: aLayout;           sharedVariables: someClassVariables;           sharedPools: somePoolDictionaries;           traitComposition: aTraitComposition asTraitComposition;           classTraitComposition: aTraitComposition asTraitComposition classComposition;           category: aCategory ]sends: aSelector  ^selector == aSelectorsetPreLoadDoItInMetacelloSpec: aMetacelloSpec  aMetacelloSpec setPreLoadDoIt: (aMetacelloSpec project valueHolderSpec           value: self;           yourself)testReadFrom  self should: [ (ScaledDecimal readFrom: '5.3') isKindOf: ScaledDecimal ] description: 'Reading a ScaledDecimal should answer a ScaledDecimal'.  self should: [ ((ScaledDecimal readFrom: '5.3') asScaledDecimal: 1) = (53 / 10 asScaledDecimal: 1) ] description: 'ScaledDecimal readFrom: should not use Float intermediate because it would introduce round off errors'initialize  super initialize.  self initialize: 4096highBit  ^self subclassResponsibilitytestWaitAndWaitTimeoutTogether  | semaphore value waitProcess waitTimeoutProcess |  semaphore := Semaphore new.  waitProcess := [ semaphore wait.  value := #wait ] fork.  waitTimeoutProcess := [ semaphore waitTimeoutMSecs: 50.  value := #waitTimeout ] fork.  (Delay forMilliseconds: 100) wait.  semaphore signal.  [ waitProcess isTerminated and: [ waitTimeoutProcess isTerminated ] ] whileFalse: [ (Delay forMilliseconds: 100) wait ].  self assert: value equals: #waitprintStringBase: base length: minimum padded: zeroFlag  ^String streamContents: [:s |  self printOn: s base: base length: minimum padded: zeroFlag ]bitShiftPoint: bits  x := x bitShift: bits.  y := y bitShift: bitsdefinesClassVariable: aGlobal  ^self classVariables includes: aGlobalprintOn: stream base: base  self isNaN ifTrue: [ ^stream nextPutAll: 'Float nan' ].  self isInfinite ifTrue: [ stream nextPutAll: 'Float infinity'.        ^self sign = -1 ifTrue: [ stream nextPutAll: ' negated' ] ].  self > 0.0 ifTrue: [ FloatPrintPolicy absPrint: self on: stream base: base ] ifFalse: [ self signBit = 1 ifTrue: [ stream nextPut: $- ].        self = 0.0 ifTrue: [ stream nextPutAll: '0.0' ] ifFalse: [ FloatPrintPolicy absPrint: self negated on: stream base: base ] ]rfvalueNoContextSwitch  < primitive: 221>  < metaLinkOptions: #(+ optionDisabledLink)>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  self primitiveFailedtestTerminationDuringUnwind  | unwindStarted unwindFinished p |  unwindStarted := unwindFinished := false.  p := [ [  ] ensure: [ unwindStarted := true.        Processor yield.        unwindFinished := true ] ] fork.  self deny: unwindStarted.  Processor yield.  self assert: unwindStarted.  self deny: unwindFinished.  p terminate.  self assert: unwindFinishedasSpotterCandidateLink  ^GTSpotterCandidateLink value: selfkeyAtIdentityValue: value ifAbsent: exceptionBlock  1 to: self basicSize do: [:index |  value == (array at: index) ifTrue: [ (self basicAt: index) ifNotNil: [:theKey |  ^theKey ] ] ].  ^exceptionBlock valueresume  self resume: self defaultResumeValueasFloatPoint  self isFloatPoint ifTrue: [ ^self ].  ^x asFloat @ y asFloathash  ^origin hash bitXor: corner hashtestSecondsRoundTrip  | now now2 |  now := DateAndTime fromSeconds: 0.  now2 := DateAndTime fromSeconds: now asSeconds.  self assert: now equals: now2areasOutside: aRectangle  (self intersects: aRectangle) ifFalse: [ ^Array with: self ].  ^Array new: 4 streamContents: [:aStream |  | yOrigin yCorner |        aRectangle origin y > origin y ifTrue: [ aStream nextPut: (origin corner: corner x @ (yOrigin := aRectangle origin y)) ] ifFalse: [ yOrigin := origin y ].        aRectangle corner y < corner y ifTrue: [ aStream nextPut: (origin x @ (yCorner := aRectangle corner y) corner: corner) ] ifFalse: [ yCorner := corner y ].        aRectangle origin x > origin x ifTrue: [ aStream nextPut: (origin x @ yOrigin corner: aRectangle origin x @ yCorner) ].        aRectangle corner x < corner x ifTrue: [ aStream nextPut: (aRectangle corner x @ yOrigin corner: corner x @ yCorner) ] ]protocolOrganizer  ^protocolOrganizernewCallbackWithSignature: signature block: aBlock library: aFFILibrary  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     newCallbackWithSignature: signature block: aBlock library: aFFILibrarygtInspectorPresentationsFromPragmas: aCollection In: composite inContext: aGTInspector  aCollection do: [:eachPragma |  eachPragma methodSelector numArgs = 0 ifTrue: [ | presentationSource |              presentationSource := self perform: eachPragma methodSelector.              presentationSource glmPresentation cull: composite cull: aGTInspector cull: self ].        eachPragma methodSelector numArgs = 1 ifTrue: [ thisContext object: self perform: eachPragma methodSelector withArguments: {composite} inClass: self class ].        eachPragma methodSelector numArgs = 2 ifTrue: [ thisContext object: self perform: eachPragma methodSelector withArguments: {composite .                     aGTInspector} inClass: self class ] ]testIsPrivateOther  self checkCorrespondanceOf: #isPrivateOther: and: #CotestFloorLog  self assert: (100 floorLog: 10) equals: 2.  self assert: ((2 raisedTo: Float emax + 3) floorLog: 10) = (2 log * (Float emax + 3)) floor description: 'Integer>>floorLog: should not overflow'pushActiveContext  self push: selfhex  ^self asInteger hexpcRangeContextIsActive: contextIsActive  | thePC |  thePC := pc ifNil: [ self method endPC ].  thePC := contextIsActive ifTrue: [ thePC ] ifFalse: [ thePC - 1 ].  ^self method rangeForPC: thePCcollect: aBlock  | basicSize newSelf size dep selection |  basicSize := self basicSize.  newSelf := self species new: basicSize.  size := 0.  1 to: basicSize do: [:i |  (dep := self basicAt: i) notNil ifTrue: [ newSelf basicAt: (size := size + 1) put: (aBlock value: dep) ] ].  selection := self species new: size.  selection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.  ^selectionintersect: aLinkedList withCollection: aCollection  ^aLinkedList ifNotEmpty: [ (self intersectValueLink: aLinkedList firstLink withCollection: aCollection) ifNil: [ LinkedList new ] ifNotNil: [:link |  LinkedList with: link ] ]isVariable  | instSpec |  instSpec := self instSpec.  ^instSpec >= 2 and: [ instSpec <= 4 or: [ instSpec >= 9 ] ]forbiddenSelectorsForMethodFinder  ^#()tempNamed: aName put: anObject  | scope var |  scope := self sourceNodeExecuted scope.  var := scope lookupVar: aName.  ^var writeFromContext: self scope: scope value: anObjectinitializeTicker: aDelayTicker suspendedDelaysHeap: aHeap  super initializeTicker: aDelayTicker suspendedDelaysHeap: aHeap.  accessProtect := Semaphore forMutualExclusiontestDay  self assert: aTimespan day equals: jan01 daysourceNodeExecutedForPC: arg1  ^self subclassResponsibilityclassVariablesString  ^String streamContents: [:stream |  self classVarNames do: [:each |  stream nextPutAll: each ] separatedBy: [ stream space ] ]testWithRecursion  self should: [ self recursion ] notTakeMoreThanMilliseconds: 3& aNumber  ^self bitAnd: aNumberinitialize  super initialize.  activeMethods := OrderedCollection newusesLocalPoolVarNamed: aString  ^self sharedPools anySatisfy: [:each |  each usesClassVarNamed: aString ]setR: rho degrees: degrees  | radians |  radians := degrees asFloat degreesToRadians.  x := rho asFloat * radians cos.  y := rho asFloat * radians sinsizePushSpecialLiteral: specialLiteral  ^self sizeOpcodeSelector: #genPushSpecialLiteral: withArguments: {specialLiteral}fuelAccept: aGeneralMapper  ^aGeneralMapper visitMetaclass: selftestTwoComplementBitLogicWithCarry  self assert: ((2 to: 80) allSatisfy: [:n |  ((2 raisedTo: n) negated bitAnd: (2 raisedTo: n) negated - 1) = (2 raisedTo: n + 1) negated ])acceptsLoggingOfCompilation  ^self instanceSide acceptsLoggingOfCompilationsubclass: aSubclassSymbol uses: aTraitCompositionOrArray layout: layoutClass slots: slotDefinition classVariables: classVarDefinition category: aCategorySymbol  ^self subclass: aSubclassSymbol uses: aTraitCompositionOrArray layout: layoutClass slots: slotDefinition classVariables: classVarDefinition poolDictionaries: '' category: aCategorySymbolnoteAddedSelector: aSelector meta: isMeta  interpolateTo: aNumber at: param  ^self * (1 - param) + (aNumber * param)testDay  self assert: aDateAndTime day equals: 60.  self deny: aDateAndTime day equals: 29argument  ^args at: 1split: aSequenceableCollection indicesDo: aBlock  | position oldPosition |  position := 1.  oldPosition := position.  position := aSequenceableCollection indexOf: self startingAt: position.  [ position > 0 ] whileTrue: [ aBlock value: oldPosition value: position - 1.        position := position + 1.        oldPosition := position.        position := aSequenceableCollection indexOf: self startingAt: position ].  aBlock value: oldPosition value: aSequenceableCollection sizeincludesSharedPoolNamed: aSharedPoolString  ^self sharedPools anySatisfy: [:each |  each name = aSharedPoolString ]gtDebuggerDoItBindings  ^(self method isDoIt and: [ self receiver isNil ]) ifTrue: [ self method literals select: [:each |  each class = WorkspaceVariable ] ] ifFalse: [ #() ]asTrueFraction  | signexp positive expPart exp fraction fractionPart signedFraction result zeroBitsCount |  self isInfinite ifTrue: [ self error: 'Cannot represent infinity as a fraction' ].  self isNaN ifTrue: [ self error: 'Cannot represent Not-a-Number as a fraction' ].  signexp := (self basicAt: 1) bitShift: -20.  positive := (signexp bitAnd: 16r800) = 0.  expPart := signexp bitAnd: 16r7FF.  fractionPart := (((self basicAt: 1) bitAnd: 16rFFFFF) bitShift: 32) + (self basicAt: 2).  (expPart = 0 and: [ fractionPart = 0 ]) ifTrue: [ ^0 ].  fraction := expPart = 0 ifTrue: [ fractionPart bitShift: 1 ] ifFalse: [ fractionPart bitOr: 16r0010000000000000 ].  signedFraction := positive ifTrue: [ fraction ] ifFalse: [ fraction negated ].  exp := 16r3FF + 52 - expPart.  exp negative ifTrue: [ result := signedFraction bitShift: exp negated ] ifFalse: [ zeroBitsCount := fraction lowBit - 1.        exp := exp - zeroBitsCount.        exp <= 0 ifTrue: [ zeroBitsCount := zeroBitsCount + exp.              result := signedFraction bitShift: zeroBitsCount negated ] ifFalse: [ result := Fraction numerator: (signedFraction bitShift: zeroBitsCount negated) denominator: (1 bitShift: exp) ] ].  ^resulttestSchedule  self assert: aSchedule schedule size equals: 2.  self assert: aSchedule schedule first equals: 1 days.  self assert: aSchedule schedule second equals: 6 daysasDelay  ^Delay forDuration: selftestFloor  self assert: 1.0 floor equals: 1.  self assert: 1.1 floor equals: 1.  self assert: -2.0 floor equals: -2.  self assert: -2.1 floor equals: -3acceptSettings: aVisitor  ^aVisitor visitClass: selflogMethodSource: aText forMethod: aCompiledMethod inCategory: category withStamp: changeStamp  aCompiledMethod putSource: aText class: self category: category withStamp: changeStamp priorMethod: (self compiledMethodAt: aCompiledMethod selector ifAbsent: [  ])method  ^selftestSlotNames  self assert: Point slotNames equals: #(x y)testDynamicVariableBlockReturnValue  | returnValue |  returnValue := TestDynamicVariable value: 10 during: [ TestDynamicVariable value + 1 ].  self assert: returnValue equals: 11testIntersectionWithIncluded  self assert: (aTimespan intersection: anIncludedTimespan) equals: anIncludedTimespantestYearsDo  | yearArray |  yearArray := Array with: (Year starting: (DateAndTime year: 2003 day: 7) duration: 365 days).  self assert: aTimespan years contents equals: yearArray contentstestNew  self should: [ Context new: 5 ] raise: Error.  [ Context new: 5 ] ifError: [:error |  error = 'Error: Contexts must only be created with newForMethod:' ].  [ Context new ] ifError: [:error |  error = 'Error: Contexts must only be created with newForMethod:' ].  [ Context basicNew ] ifError: [:error |  error = 'Error: Contexts must only be created with newForMethod:' ]value: anObject1 value: anObject2  | strongReceiver |  strongReceiver := self receiver.  (self ensureReceiver: strongReceiver) ifFalse: [ ^nil ].  ^strongReceiver perform: selector with: anObject1 with: anObject2sqrt  | selfAsFloat floatResult guess |  selfAsFloat := self asFloat.  floatResult := selfAsFloat sqrt.  floatResult isInfinite ifFalse: [ guess := floatResult truncated.        guess squared = self ifTrue: [ ^guess ] ].  selfAsFloat >= Float maxExactInteger asFloat squared ifTrue: [ guess := self sqrtFloor.        guess squared = self ifTrue: [ ^guess ].        guess := (self * 4) sqrtFloor.        ^(guess // 2 + (guess \\ 2)) asFloat ].  ^floatResultepoch  ^Date year: 1901 month: 1 day: 1testEnumerating  | weeks |  weeks := OrderedCollection new.  month weeksDo: [:w |  weeks add: w start ].  0 to: 4 do: [:i |  weeks remove: (Week starting: ('29 June 1998' asDate addDays: i * 7)) start ].  self assertEmpty: weeksroundTo: aDuration  ^self class nanoSeconds: (self asNanoSeconds roundTo: aDuration asNanoSeconds)combinesWith: char  | dict |  codes ifNil: [ ^false ].  dict := Compositions at: combined charCode ifAbsent: [ ^false ].  dict at: char charCode ifAbsent: [ ^false ].  ^truedeclareClassVariables: newVars  | conflicts |  conflicts := false.  (self classVariables reject: [:x |  newVars includes: x ]) do: [:var |  self removeClassVarNamed: var name interactive: false ].  (newVars reject: [:var |  self classVariables includes: var ]) do: [:var |  (self innerBindingOf: var key) ifNotNil: [ DuplicatedVariableError new                 variable: var name;                 signal: var name , ' is defined elsewhere'.              conflicts := true ] ].  newVars notEmpty ifTrue: [ self classPool: self classPool.        newVars do: [:var |  self classPool declareVariable: var from: Undeclared ] ].  ^conflictstearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  super tearDownat: index  ^self basicAt: indexbyteSizeOfInstance  < primitive: 181 error: ec>  self isVariable ifTrue: [ ^self byteSizeOfInstanceOfSize: 0 ].  self primitiveFailedgenReturnTop  stream nextPut: 124testIfNotNilIfNil  < haltOrBreakpointForTesting>  self should: [ nil ifNotNil: [  ] ifNil: [ self error ] ] raise: ErrorweakSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self weakSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: catdaysInYear  ^start daysInYeartestSeconds  self assert: aDateAndTime seconds equals: 0testmethodsAccessingPoolVariables  | result |  result := ChronologyConstants methodsAccessingPoolVariables.  self assert: (result includes: (Duration >> #asNanoSeconds) methodReference).  self deny: (result includes: (ClassTest >> #testSharedPoolOfVarNamed) methodReference)fileOutLocalMethodsInCategory: aSymbol on: aFileStream  | selectors |  aFileStream cr.  selectors := self selectorsToFileOutCategory: aSymbol.  selectors do: [:sel |  self printMethodChunk: sel on: aFileStream ].  ^selfallProtocols  ^self protocolOrganizer allProtocolssubclasses  self isMetaclassOfClassOrNil ifTrue: [ ^#() ].  ^self instanceSide subclasses collect: [:aSubclass |  aSubclass classSide ]doNop  parseTree  ^self methodClass compiler     source: self sourceCode;     failBlock: [ ^self decompile ];     parsespotterPreviewCodeIn: aComposite  < spotterPreview: 10>  aComposite pharoMethod     title: [ self name ];     display: #definition;     smalltalkClass: [ nil ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'callcc: aBlock  ^Continuation currentDo: aBlocktestLessThan  self assert: aDateAndTime < (aDateAndTime + '1:00:00:00').  self assert: aDateAndTime + -1 < aDateAndTimetestRaisedToIntegerWithFloats  self     assert: (2.0 raisedToInteger: 0) equals: 1.0;     assert: (2.0 raisedToInteger: 1) equals: 2.0;     assert: (2.0 raisedToInteger: 4) equals: 16.0;     assert: (0.0 raisedToInteger: 0) equals: 1.0;     assert: (0.0 raisedToInteger: 2) equals: 0.0;     assert: (2.0 raisedToInteger: -1) equals: 0.5;     assert: (2.0 raisedToInteger: -4) equals: 0.0625.  self     assert: (-3.0 raisedTo: 0) equals: 1.0;     assert: (-3.0 raisedTo: 1) equals: -3.0;     assert: (-3.0 raisedTo: 2) equals: 9.0;     assert: (-3.0 raisedTo: 3) equals: -27.0;     assert: (-2.0 raisedTo: -2) equals: 0.25;     assert: (-2.0 raisedTo: -3) equals: -0.125.  self should: [ 0.0 raisedTo: -1 ] raise: ZeroDividetestCategories  | categories |  categories := self organization categories.  self assert: categories notEmptycritical: aBlock  ^[ self enter.  aBlock value ] ensure: [ self exit ]asSeconds  ^secondsmax  ^self x max: self ytestIsRootInEnvironment  self assert: ProtoObject isRootInEnvironment.  self deny: Object isRootInEnvironmentjavascriptOn: aStream  aStream nextPutAll: 'new Date('.  #(year javascriptMonthIndex dayOfMonth hour minute second) do: [:each |  aStream javascript: (self perform: each) ] separatedBy: [ aStream nextPut: $, ].  aStream nextPut: $)testEmptyTemplate  | i |  i := LargeNegativeInteger new: 4.  self assert: i size equals: 4.  self assert: i printString equals: '-0'.  self assert: i normalize equals: 0testReentrantBlockOldEnvironmentWithBlockArguement  | fib |  fib := self constructFibonacciBlockWithBlockArgumentInDeadFrame.  self should: [ fib value: 0 value: fib ] raise: self classForTestResult error.  self assert: (fib value: 1 value: fib) equals: 1.  self assert: (fib value: 2 value: fib) equals: 1.  self assert: (fib value: 3 value: fib) equals: 2.  self assert: (fib value: 4 value: fib) equals: 3.  self assert: (fib value: 5 value: fib) equals: 5.  self assert: (fib value: 6 value: fib) equals: 8testSuppressInformUsingStringMatchOptions  self should: [ ([ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingMessages: #('Should not see this message or this test failed!')) isNil ].  self should: [ ([ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingMessages: #('not see this message')) isNil ].  self should: [ ([ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingMessages: #('*message*failed#')) isNil ]species  < primitive: 111>  ^self classtestDoWith  | count |  count := 0.  aTimespan do: [:each |  count := count + 1 ] with: (Timespan starting: aDate duration: 7 days).  self assert: count equals: 13insertSender: aContext  | context |  context := aContext bottomContext.  context privSender: self sender.  self privSender: aContext.  ^contextapprovedSelectorsForMethodFinder  ^#(isNil)isEmptyCategoryNamed: categoryName  ^(self protocolOrganizer protocolNamed: categoryName) isEmptybasicOrganization  ^organizationhours  ^(seconds rem: SecondsInDay) quo: SecondsInHourprintOn: aStream  self printOn: aStream base: 10asStringWithCommasSigned  ^String streamContents: [:stream |  self printWithCommasSignedOn: stream ]byteAt: n put: value  self error: 'You can''t store in a SmallInteger'isWeak  ^self instSpec = 4beActiveDuring: aBlock  CurrentExecutionEnvironment activate: self for: aBlockgtInspectorIcon  ^niladdModelItemsToWindowMenu: aMenu  second  ^self localSeconds \\ 60testNaN4  | dict |  dict := Dictionary new.  dict at: Float nan put: #NaN.  self deny: (dict includes: Float nan)montgomeryTimes: a modulo: m mInvModB: mInv  < primitive: 'primMontgomeryTimesModulo' module: 'LargeIntegers'>  ^niljsonOn: aRenderer  aRenderer string: (String with: self)asSeconds  ^start asSecondssourceMatchesBytecodeAt: selector  | method newMethod |  method := self compiledMethodAt: selector.  newMethod := self compiler     source: (self sourceCodeAt: selector);     class: self;     failBlock: [ ^false ];     compiledMethodTrailer: method trailer;     compile.  selector == newMethod selector ifFalse: [ self error: 'selector changed!!' ].  ^newMethod = methodtestMiddleOf  self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) equals: (Timespan starting: '12-31-1900' asDate duration: 2 days)deprecatedMethod6  testIsLeapYear  self assert: aDateAndTime isLeapYearasInteger  < primitive: 171>  ^self primitiveFailedtestAsSeconds  self assert: (Duration nanoSeconds: 1000000000) asSeconds equals: 1.  self assert: (Duration seconds: 1) asSeconds equals: 1.  self assert: aDuration asSeconds equals: 93784.  self assert: 1 asSeconds equals: (Duration seconds: 1).  self assert: (1 / 2) asSeconds equals: (Duration milliSeconds: 500)genNop  stream nextPut: 95testIsOpenPunctuation  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isOpenPunctuation: ch) equals: (charset isOpenPunctuation: ch) ]testIsAbstract  self deny: Behavior isAbstract.  self deny: Behavior class isAbstract.  self deny: ClassDescription isAbstract.  self deny: ClassDescription class isAbstract.  self deny: Class isAbstract.  self deny: Class class isAbstract.  self deny: Object isAbstract.  self deny: Object class isAbstracttestBecomeForwardIdentityHash  | a b ha |  a := 'ab' copy.  b := 'cd' copy.  ha := a identityHash.  a becomeForward: b.  self     assert: a identityHash equals: ha;     assert: b identityHash equals: haasYear  ^selfprimitiveErrorVariableName  self isPrimitive ifTrue: [ self pragmas do: [:pragma |  | kwds ecIndex |              ((kwds := pragma selector keywords) first = 'primitive:' and: [ (ecIndex := kwds indexOf: 'error:') > 0 ]) ifTrue: [ ^pragma argumentAt: ecIndex ] ] ].  ^nilhandleProcessTerminationOfWaitingContext: suspendedContext  ^suspendedContext method == (Semaphore compiledMethodAt: #critical:) ifTrue: [ suspendedContext home ] ifFalse: [ suspendedContext ]printShowingDecimalPlaces: placesDesired  ^String new: placesDesired + 10 streamContents: [:aStream |  self printOn: aStream showingDecimalPlaces: placesDesired ]isMonthPattern  ^char = $mabbreviation: aString  abbreviation := aStringprotocols  ^self organization categories copytestOr  self assert: (true or: [ 'alternativeBlock' ])fuelNew  ^self basicNewreleaseTo: caller  | contex senderContext |  contex := self.  [ contex == nil or: [ contex == caller ] ] whileFalse: [ senderContext := contex sender.        contex singleRelease.        contex := senderContext ]run  | proc |  proc := Processor activeProcess.  [ proc suspend.  self resume ] forkAt: Processor highestPriorityisFraction  ^falseveryDeepCopyWith: deepCopier  bytesCount  self subclassResponsibilityadaptToInteger: rcvr andSend: selector  ^self subclassResponsibilityremove: anObj uptoLast: aLinkedList  ^aLinkedList ifNotEmpty: [ | valueLink |        valueLink := Continuation currentDo: [:skip |  self remove: anObj uptoLastValueLink: aLinkedList firstLink continuation: skip ].        LinkedList with: valueLink ]testSimpleEnsureTestWithNotification  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithNotification)testStartStop  | sw t1 t2 t3 t4 |  sw := Stopwatch new.  t1 := DateAndTime now.  (Delay forMilliseconds: 10) wait.  sw     activate;     activate.  (Delay forMilliseconds: 10) wait.  t2 := DateAndTime now.  self     deny: sw isSuspended;     assert: sw isActive;     assert: sw timespans size equals: 1;     assert: t1 <= sw start;     assert: sw start <= t2.  (Delay forMilliseconds: 10) wait.  t3 := DateAndTime now.  (Delay forMilliseconds: 10) wait.  sw     suspend;     suspend.  (Delay forMilliseconds: 10) wait.  t4 := DateAndTime now.  self     assert: sw isSuspended;     deny: sw isActive;     assert: sw timespans size equals: 1;     assert: (sw end between: t3 and: t4);     assert: t3 <= sw end;     assert: sw end <= t4testPrintOn  self assert: (String streamContents: [:str |  aTimespan printOn: str ]) equals: 'a Timespan(2005-01-01T00:00:00+00:00D7:00:00:00)'printHMSOn: aStream  self printHMSOn: aStream separatedBy: $:completeTo: aContext  self suspendedContext == aContext ifTrue: [ ^aContext ].  ^self complete: (self calleeOf: aContext)spotterTraitUsersFor: aStep  < spotterOrder: 20>  self isTrait ifFalse: [ ^self ].  aStep listProcessor     title: 'Users';     allCandidates: [ self traitUsers asArray ];     itemIcon: #systemIcon;     filter: GTFilterSubstringrectangle: aPoint  ^Rectangle point: self point: aPointtest32bitConversion  #(16r0 16r80000000 16r1 16r12345 16r801FEDCB 16r7FFFFF 16r800000 16r468ACDEF 16rCABD1234 16r7F7FFFFF 16r7F800000 16rFF800000) do: [:originalWord |  self assert: (Float fromIEEE32Bit: originalWord) asIEEE32BitWord equals: originalWord ]sortCategories  | privateCategories publicCategories newCategories |  privateCategories := self categories select: [:one |  (one findString: 'private' startingAt: 1 caseSensitive: false) = 1 ].  publicCategories := self categories copyWithoutAll: privateCategories.  newCategories := publicCategories asSortedCollection asOrderedCollection     addAll: privateCategories;     asArray.  self categories: newCategorieswillJumpIfFalse  ^self method encoderClass isBranchIfFalseAt: pc in: self methodtestPreviousByName  self assert: (january23rd2004 previous: #Friday) equals: '2004-01-16' asDatetestDoublePassOuter  self assertSuccess: (ExceptionTester new runTest: #doublePassOuterTest)testAsUTC  self assert: aDateAndTime asUTC equals: aDateAndTimespotterPreviewIn: aComposite inContext: aSpotter  | pragmas |  pragmas := Pragma allNamed: #spotterPreview: from: self class to: Object sortedUsing: [:x :y |  (x argumentAt: 1) < (y argumentAt: 1) ].  pragmas do: [:eachPragma |  (eachPragma methodSelector findTokens: $:) size = 1 ifTrue: [ self perform: eachPragma methodSelector with: aComposite ].        (eachPragma methodSelector findTokens: $:) size = 2 ifTrue: [ self perform: eachPragma selector with: aComposite with: aSpotter ].        aComposite hasSubbricks ifTrue: [ ^self ] ]testBigReceiverInexactSqrt  | bigNum result |  bigNum := 100 factorial squared + 1.  self assert: bigNum asFloat isInfinite.  result := bigNum sqrt.  self assert: result isFloat.  self deny: result isInfinite.  self assert: result equals: 100 factorial asFloat.  self assert: (result successor asFraction squared - bigNum) abs >= (result asFraction squared - bigNum) abs.  self assert: (result predecessor asFraction squared - bigNum) abs >= (result asFraction squared - bigNum) abstestNanoSecond  self assert: aDateAndTime nanoSecond equals: 0parse: timeUnitName expectedSize: anInteger  | extractedString result |  extractedString := inputStream next: anInteger.  result := extractedString asInteger.  (result isNil or: [ extractedString size ~= anInteger ]) ifTrue: [ DateError signal: ' Expect a two digit ' , timeUnitName , ', got ' , extractedString ].  ^resultr  ^(self dotProduct: self) sqrtallSuperclassesIncluding: aClass  | temp |  self class == ProtoObject class ifTrue: [ ^OrderedCollection new ].  ^self superclass == aClass ifTrue: [ OrderedCollection with: aClass ] ifFalse: [ temp := self superclass allSuperclassesIncluding: aClass.        temp addFirst: self superclass.        temp ]testSourceNodeOptimized  | block |  block := [:ctx |  [ ctx atEnd ] whileTrue: [ 1 + 2 ] ].  self assert: block sourceNode printString equals: 'RBBlockNode([ :ctx | [ ctx atEnd ] whileTrue: [ 1 + 2 ] ])'doesNotUnderstand: aMessage  < debuggerCompleteToSender>  | exception resumeValue node |  (node := self findUndeclaredVariableIn: thisContext sender sourceNodeExecuted) ifNil: [ ^super doesNotUnderstand: aMessage ].  (exception := VariableNotDeclared new)     message: aMessage;     variableNode: node;     receiver: self.  resumeValue := exception signal.  ^exception reachedDefaultHandler ifTrue: [ aMessage sentTo: self ] ifFalse: [ resumeValue ]testLeftmost  | tree |  tree := #a ~~> nil ~~> nil ~~> (4 ~~> (Link new ~~> (1 ~~> nil ~~> nil))).  self assert: (self printStringOfTree: tree) equals: '(((#a)) 4 () (1))'.  self assert: (self leftmost: #isSymbol tree: tree) equals: #a.  self assert: (self leftmost: #isInteger tree: tree) equals: 4.  self assert: (self leftmost: [:v |  v = 1 ] tree: tree) equals: 1.  self assert: (self leftmost: #isNil tree: tree) equals: nil.  self assert: (self leftmost: [:v |  v = 5 ] tree: tree) equals: nilexampleStore  < sampleInstance>  instVar1 := 1.  instVar1 := 2.  ^thisContext copytestDegreeCosForExceptionalValues  self assert: Float nan degreeCos isNaN.  self assert: Float infinity degreeCos isNaN.  self assert: Float infinity negated degreeCos isNaNtestValueWithArguments  self shouldnt: [ aBlockContext valueWithArguments: #() ] raise: ArgumentsCountMismatch.  self should: [ aBlockContext valueWithArguments: #(1) ] raise: ArgumentsCountMismatch withExceptionDo: [:err |  self assert: err expectedArgumentsCount equals: 0.        self assert: err calledArgumentsCount equals: 1 ].  self should: [ [:i |  3 + 4 ] valueWithArguments: #(1 2) ] raise: ArgumentsCountMismatch withExceptionDo: [:err |  self assert: err expectedArgumentsCount equals: 1.        self assert: err calledArgumentsCount equals: 2 ]assert: a classAndValueEquals: b  self assert: a class equals: b class.  self assert: a equals: binspectInExternalWindow  ^GTInspector new openInExternalWindowOn: selftruncated  < primitive: 51>  (self isInfinite or: [ self isNaN ]) ifTrue: [ self error: 'Cannot truncate this number' ].  self abs < 2.0e16 ifTrue: [ | di df q r |        di := (SmallInteger maxVal bitShift: -1) + 1.        df := di asFloat.        q := self quo: df.        r := self - (q asFloat * df).        ^q * di + r truncated ] ifFalse: [ ^self asTrueFraction ]testprintSubclassesOnLevelFilterB  | expected result stream |  expected := '	ExampleForTest1 #()		ExampleForTest12 #()'.  result := String new: expected size.  stream := ReadWriteStream on: result.  ExampleForTest1 printSubclassesOn: stream level: 1 filter: {ExampleForTest1 .         ExampleForTest12 .         ExampleForTest112}.  self assert: result equals: expecteddefinitionForNautilus  self deprecated: 'Use #definition instead.' on: '2019-05-14' in: #Pharo8 transformWith: '`@receiver definitionForNautilus' -> '`@receiver definition'.  ^self definitiontestYearDay  self assert: aDateAndTime equals: (DateAndTime year: 1970 day: 1)isClass  ^falsefirstPrecodeCommentFor: selector  | method |  (#(Comment Definition Hierarchy) includes: selector) ifTrue: [ ^nil ].  method := self compiledMethodAt: selector asSymbol ifAbsent: [ ^nil ].  ^method ast firstPrecodeCommentprintOn: aStream  aStream nextPutAll: 'a Year ('.  self start year printOn: aStream.  aStream nextPutAll: ')'testIntersectionWithSeparate  self assert: (aTimespan intersection: aDisjointTimespan) isNil.  self deny: (aTimespan intersection: anOverlappingTimespan) isNil.  self assert: (aTimespan intersection: anIncludedTimespan) equals: anIncludedTimespantestByWeekNumberInCurrentYear  week := Week week: 2.  self assert: week year asYear equals: Year currenttestIfNotNilIfNil  | object returnValue block reached notReached |  object := ProtoObject new.  returnValue := Object new.  reached := false.  notReached := false.  object ifNotNil: [ reached := true ] ifNil: [ notReached := true ].  self assert: reached equals: true.  self assert: notReached equals: false.  reached := false.  notReached := false.  object ifNotNil: [:o |  reached := true ] ifNil: [ notReached := true ].  self assert: reached equals: true.  self assert: notReached equals: false.  reached := false.  notReached := false.  self assert: (object ifNotNil: [:o |  o == object ] ifNil: [ false ]).  self assert: (object ifNotNil: [ returnValue ] ifNil: [ false ]) identicalTo: returnValue.  self assert: (object ifNotNil: [:o |  returnValue ] ifNil: [ false ]) identicalTo: returnValue.  reached := false.  notReached := false.  block := [ reached := true ].  object ifNotNil: block ifNil: [ notReached := true ].  self assert: reached equals: true.  self assert: notReached equals: false.  reached := false.  notReached := false.  block := [:o |  reached := true ].  object ifNotNil: block ifNil: [ notReached := true ].  self assert: reached equals: true.  self assert: notReached equals: false.  block := [:o |  o == object ].  self assert: (object ifNotNil: block ifNil: [ false ]).  block := [ returnValue ].  self assert: (object ifNotNil: block ifNil: [ false ]) identicalTo: returnValue.  block := [:o |  returnValue ].  self assert: (object ifNotNil: block ifNil: [ false ]) identicalTo: returnValueremoveElement: aSymbol  | oldProtocol |  oldProtocol := self categoryOfElement: aSymbol.  self protocolOrganizer removeMethod: aSymbol.  self notifyOfChangedSelector: aSymbol from: oldProtocol to: (self categoryOfElement: aSymbol)sideNearestTo: aPoint  | distToLeft distToRight distToTop distToBottom closest side |  distToLeft := aPoint x - self left.  distToRight := self right - aPoint x.  distToTop := aPoint y - self top.  distToBottom := self bottom - aPoint y.  closest := distToLeft.  side := #left.  distToRight < closest ifTrue: [ closest := distToRight.        side := #right ].  distToTop < closest ifTrue: [ closest := distToTop.        side := #top ].  distToBottom < closest ifTrue: [ closest := distToBottom.        side := #bottom ].  ^sideisSpecLayout  ^falsetestLessThan  self assert: aTimespan < aDisjointTimespan.  self deny: anIncludedTimespan < aTimespanprivateSetCorner: bottomRight  corner := bottomRighttoFinalizeSend: aSelector to: aFinalizer with: aResourceHandle  self == aFinalizer ifTrue: [ self error: 'I cannot finalize myself' ].  self == aResourceHandle ifTrue: [ self error: 'I cannot finalize myself' ].  ^self finalizationRegistry add: self executor: (ObjectFinalizer new receiver: aFinalizer selector: aSelector argument: aResourceHandle)genPushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize  | numExtensions numCopiedMod8 numArgsMod8 extA |  (jumpSize < 0 or: [ jumpSize > 65535 ]) ifTrue: [ ^self outOfRangeError: 'block size' index: jumpSize range: 0 to: 65535 ].  (numCopied < 0 or: [ numCopied > 127 ]) ifTrue: [ ^self outOfRangeError: 'num copied' index: numCopied range: 0 to: 127 ].  (numArgs < 0 or: [ numArgs > 127 ]) ifTrue: [ ^self outOfRangeError: 'num args' index: numArgs range: 0 to: 127 ].  extA := numExtensions := 0.  (numArgsMod8 := numArgs) > 7 ifTrue: [ extA := numArgs // 8.        numArgsMod8 := numArgsMod8 \\ 8 ].  (numCopiedMod8 := numCopied) > 7 ifTrue: [ extA := extA + (numCopied // 8 * 16).        numCopiedMod8 := numCopiedMod8 \\ 8 ].  extA ~= 0 ifTrue: [ self genUnsignedSingleExtendA: extA.        numExtensions := 1 ].  jumpSize > 255 ifTrue: [ numExtensions := numExtensions + 1.        self genUnsignedSingleExtendB: jumpSize // 256 ].  stream     nextPut: 250;     nextPut: (numExtensions bitShift: 6) + (numCopiedMod8 bitShift: 3) + numArgsMod8;     nextPut: (jumpSize bitAnd: 16rFF)testByteAt  | lni |  lni := -114605103402541699037609980192546360895434064385.  1 to: 20 do: [:i |  | digit |        digit := lni byteAt: i.        self assert: i equals: digit ]basicIdentityHash  < primitive: 75>  self primitiveFailedclearFlag  self objectAt: 1 put: (self header bitAnd: (1 << 29) bitInvert)storeOn: aStream base: base length: minimum padded: zeroFlag  | prefix |  prefix := self negative ifTrue: [ '-' ] ifFalse: [ String new ].  base = 10 ifFalse: [ prefix := prefix , base printString , 'r' ].  self print: (self abs printStringBase: base) on: aStream prefix: prefix length: minimum padded: zeroFlagsimulate_vmMilliseconds: milliseconds  ticker simulate_vmMilliseconds: millisecondstestCullCullCullCull  [  ] cull: 1 cull: 2 cull: 3 cull: 4.  [:x |   ] cull: 1 cull: 2 cull: 3 cull: 4.  [:x :y |   ] cull: 1 cull: 2 cull: 3 cull: 4.  [:x :y :z |   ] cull: 1 cull: 2 cull: 3 cull: 4.  [:x :y :z :a |   ] cull: 1 cull: 2 cull: 3 cull: 4.  self should: [ [:x :y :z :a :b |   ] cull: 1 cull: 2 cull: 3 cull: 4 ] raise: Error.  self assert: ([ 0 ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 0.  self assert: ([:x |  x ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 1.  self assert: ([:x :y |  y ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 2.  self assert: ([:x :y :z |  z ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 3.  self assert: ([:x :y :z :a |  a ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 4cleanup  self checkOwnerProcess.  self critical: [ self privateCleanup ]testMutateObjectLastInstVarWithManyVars  | guineaPig failure |  guineaPig := WriteBarrierStub new.  guineaPig beReadOnlyObject.  failure := [ guineaPig var10: #test ] on: ModificationForbidden do: [:err |  err ].  self assert: failure fieldIndex equals: 10rfMinus: aNumber  < metaLinkOptions: #(+ optionDisabledLink)>  < primitive: 2>  ^super - aNumberremoveFromChanges  self class environment at: #ChangeSet ifPresent: [:changeSet |  changeSet current removeClassAndMetaClassChanges: self ]packAsDoubleToArity: arity  | rolledPointer |  rolledPointer := self.  1 to: arity do: [:index |  rolledPointer := rolledPointer pointerDouble ].  ^rolledPointerisSuspended  ^myList isNil or: [ myList isEmpty ]messageText  ^String streamContents: [:str |  self shouldTransform ifTrue: [ str nextPutAll: 'Automatic deprecation code rewrite: ' ].        str           nextPutAll: 'The method ';           nextPutAll: self deprecatedMethodName;           nextPutAll: ' called from ';           nextPutAll: self sendingMethodName;           nextPutAll: ' has been deprecated. ';           nextPutAll: explanationString ]testPositive  self assert: (Duration nanoSeconds: 0) positive.  self assert: aDuration positive.  self deny: aDuration negated positive/ aNumber  | quoRem |  aNumber isInteger ifTrue: [ quoRem := self digitDiv: aNumber neg: self negative ~~ aNumber negative.        (quoRem at: 2) = 0 ifTrue: [ ^(quoRem at: 1) normalize ] ifFalse: [ ^(Fraction numerator: self denominator: aNumber) reduced ] ].  ^aNumber adaptToInteger: self andSend: #/closeTo: num precision: aPrecision  num isNumber ifFalse: [ ^[ self = num ] ifError: [ false ] ].  self = 0.0 ifTrue: [ ^num abs < aPrecision ].  num = 0 ifTrue: [ ^self abs < aPrecision ].  ^self = num asFloat or: [ (self - num) abs / (self abs max: num abs) < aPrecision ]hasSourcePointer  ^self trailer hasSourcePointertestHandlingWithSeveralExclusionsAndExceptionSetsHandling  | wasHandled result |  wasHandled := false.  result := [ ZeroDivide signalWithDividend: 1.  2 ] on: Error - MessageNotUnderstood - Warning do: [:exception |  wasHandled := true.        exception return ].  self     assert: wasHandled;     assert: result isNil.  wasHandled := false.  result := [ ZeroDivide signalWithDividend: 1.  2 ] on: Error - (MessageNotUnderstood , Warning) do: [:exception |  wasHandled := true.        exception return ].  self     assert: wasHandled;     assert: result isNiltestCeiling  self assert: 2 ceiling equals: 2.  self assert: -2 ceiling equals: -2.  self assert: 2.1 ceiling equals: 3.  self assert: -2.1 ceiling equals: -2gtInspectorVariableNodesIn: aCollection  | indexableDisplayLimit top bottom topLimit bottomLimit |  indexableDisplayLimit := GTInspector indexableDisplayLimit.  top := 1.  bottom := self basicSize.  topLimit := indexableDisplayLimit min: bottom.  bottomLimit := indexableDisplayLimit max: bottom - indexableDisplayLimit.  top to: topLimit do: [:index |  aCollection add: (GTInspectorIndexedNode hostObject: self index: index) ].  bottomLimit + 1 to: bottom do: [:index |  aCollection add: (GTInspectorIndexedNode hostObject: self index: index) ].  aCollection addAll: (self class allSlots collect: [:slot |  GTInspectorSlotNode hostObject: self slot: slot ])testIsOtherNumber  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isOtherNumber: ch) equals: (charset isOtherNumber: ch) ]pc  ^pchumanReadableSIByteSize  ^String streamContents: [:s |  self humanReadableSIByteSizeOn: s ]isValueHolder  ^falseallSelectorsBelow: topClass  | coll |  coll := IdentitySet new.  self withAllSuperclassesDo: [:aClass |  aClass = topClass ifTrue: [ ^coll ] ifFalse: [ aClass selectorsDo: [:sel |  coll add: sel ] ] ].  ^collvariableWordSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self variableWordSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: catadaptToNumber: rcvr andSend: selector  ^rcvr @ rcvr perform: selector with: selftestAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)metaLinkOptions  ^{(#methodDict -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}genCallPrimitive: primitiveIndex  (primitiveIndex < 1 or: [ primitiveIndex > 65535 ]) ifTrue: [ self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 65535 ].  stream     nextPut: 248;     nextPut: (primitiveIndex bitAnd: 255);     nextPut: (primitiveIndex bitShift: -8)printOn: aStream  aStream nextPut: $(.  x printOn: aStream.  aStream nextPut: $@.  (y notNil and: [ y negative ]) ifTrue: [ aStream space ].  y printOn: aStream.  aStream nextPut: $)testWeeks  self assert: (Duration weeks: 1) days equals: 7isOverriding  ^(self origin superclass ifNotNil: [:c |  c lookupSelector: self selector ]) notNilasMessageSend  ^MessageSend receiver: self receiver selector: selector arguments: (Array withAll: self arguments)asDosTimestamp  ^start asDosTimestampjulianDayNumber  ^julianDayNumber + self julianDayOffsetuppercase  ^self asUppercaseisMemberOf: aClass  ^self class == aClasstestDayNames  self assert: Week dayNames equals: #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday)testSeconds  self assert: aDateAndTime seconds equals: 0hasTemporaryVariableNamed: aName  ^self tempNames includes: aNamemilliseconds  ^nanos quo: NanosInMillisecondbasicIdentityHash  < primitive: 171>  ^self primitiveFailedstonOn: stonWriter  self class isVariable ifTrue: [ stonWriter error: 'custom #stonOn: implementation needed for variable/indexable class' ] ifFalse: [ stonWriter writeObject: self ]testParsingYPatternWithFiveDigits  self assertReading: '2.11.10000' as: 'd.mm.y' equals: (Date year: 10000 month: 11 day: 2)testReturnsAsManyWaitsAsSignalsReceived  | semaphore semaphoreReturnedOnce semaphoreReturnedTwice |  semaphoreReturnedOnce := semaphoreReturnedTwice := false.  semaphore := Semaphore new.  [ semaphore wait.  semaphoreReturnedOnce := true.  semaphore wait.  semaphoreReturnedTwice := true ] fork.  Processor yield.  self deny: semaphoreReturnedOnce.  semaphore signal.  Processor yield.  self assert: semaphoreReturnedOnce.  self deny: semaphoreReturnedTwice.  semaphore signal.  Processor yield.  self assert: semaphoreReturnedTwicetestIfNil  | object block reachabilityTest |  reachabilityTest := false.  object := ProtoObject new.  object ifNil: [ reachabilityTest := true ].  self assert: (object ifNil: [ nil ]) identicalTo: object.  self assert: reachabilityTest equals: false.  reachabilityTest := false.  block := [ reachabilityTest := true ].  object ifNil: block.  block := [ nil ].  self assert: (object ifNil: block) identicalTo: object.  self assert: reachabilityTest equals: falsetestSqrt  self assert: (SmallInteger maxVal + 1) sqrt equals: (SmallInteger maxVal + 1) asFloat sqrtsizePushThisContext  ^self sizeOpcodeSelector: #genPushThisContext withArguments: #()gtInspectorVariableNodesIn: aCollection  aCollection addAll: (self literals collectWithIndex: [:aLiteral :anIndex |  GTInspectorDynamicNode hostObject: self label: 'literal' , anIndex asString value: aLiteral ]).  self initialPC to: self size do: [:index |  aCollection add: (GTInspectorDynamicNode hostObject: self label: 'bc ' , index asString value: (self at: index)) ]sender  ^senderwarningTest  self log: 'About to signal warning.'.  Warning signal: 'Ouch'.  self log: 'Warning signal handled and resumed.'testNormalize  self assert: SmallInteger maxVal + 1 - 1 identicalTo: SmallInteger maxVal.  self assert: SmallInteger maxVal + 3 - 6 identicalTo: SmallInteger maxVal - 3.  self should: SmallInteger minVal - 1 + 1 == SmallInteger minVal.  self assert: SmallInteger minVal - 3 + 6 identicalTo: SmallInteger minVal + 3argumentNames  ^self sourceNode argumentNamestransform  | node rewriteRule aMethod |  self shouldTransform ifFalse: [ ^self signal ].  self rewriterClass ifNil: [ ^self signal ].  aMethod := self contextOfSender method.  aMethod isDoIt ifTrue: [ ^self ].  node := self contextOfSender sourceNodeExecuted.  RecursionStopper during: [ rewriteRule := self rewriterClass new replace: rule key with: rule value.        (rewriteRule executeTree: node) ifFalse: [ ^self signal ].        node replaceWith: rewriteRule tree.        Author useAuthor: 'AutoDeprecationRefactoring' during: [ aMethod origin compile: aMethod ast formattedCode classified: aMethod protocol ].        Log ifNotNil: [:log |  log add: self ].        self logTranscript ]valueSupplyingAnswers: aListOfPairs  ^self on: ProvideAnswerNotification do: [:notify |  | caption |        caption := notify messageText withSeparatorsCompacted.        aListOfPairs detect: [:each |  caption = each first or: [ (caption includesSubstring: each first caseSensitive: false) or: [ (each first match: caption) or: [ (String includesSelector: #matchesRegex:) and: [ [ caption matchesRegex: each first ] on: Error do: [:ignored |  false ] ] ] ] ] ] ifFound: [:answer |  notify resume: answer second ] ifNone: [ | outerAnswer |              outerAnswer := ProvideAnswerNotification signal: notify messageText.              outerAnswer ifNil: [ notify resume ] ifNotNil: [ notify resume: outerAnswer ] ] ]isSelfEvaluating  ^self class == RectangledoublePassOuterTest  [ [ [ self doSomething.  MyTestNotification signal.  self doSomethingExceptional ] on: MyTestNotification do: [:ex |  ex pass.        self doSomethingExceptional ] ] on: MyTestNotification do: [:ex |  ex outer.        self doSomethingElse ] ] on: MyTestNotification do: [:ex |  self doYetAnotherThing.        ex resume ]isPassedTest  ^self methodClass isTestCase and: [ self methodClass methodPassed: self selector ]| anInteger  ^self bitOr: anIntegerinitialize: size  references := IdentityDictionary new: sizesubclass: aSubclassSymbol uses: aTraitCompositionOrArray slots: slotDefinition classVariables: classVarDefinition category: aCategorySymbol  ^self subclass: aSubclassSymbol uses: aTraitCompositionOrArray layout: self classLayout class slots: slotDefinition classVariables: classVarDefinition poolDictionaries: '' category: aCategorySymboltestDayMonthYearDo  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear ]) equals: 2004.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth ]) equals: 2.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay ]) equals: 29drawReverseFrame: rect  Display border: rect width: 2 rule: Form reverse fillColor: Color graycloseTo: num  num isFloat ifTrue: [ ^num closeTo: self asFloat ].  ^[ self = num ] ifError: [ false ]sizePushLiteral: literalIndex  ^self sizeOpcodeSelector: #genPushLiteral: withArguments: {literalIndex}tearDown  Week startDay: restoredStartDay.  DateAndTime localTimeZone: restoredTimeZone.  super tearDowntestFirstDayOfMonth  self deny: aDateAndTime firstDayOfMonth equals: 1.  self assert: aDateAndTime firstDayOfMonth equals: 32ffiCall: fnSpec library: aLibrary options: callOptions  < ffiCalloutTranslator>  | ffiLibrary |  ffiLibrary := aLibrary asFFILibrary.  ^(ffiLibrary calloutAPIClass inUFFIContext: thisContext)     convention: self ffiCallingConvention;     options: ffiLibrary options , callOptions;     function: fnSpec library: ffiLibrarypossibleVariablesFor: misspelled continuedFrom: oldResults  ^self instanceSide possibleVariablesFor: misspelled continuedFrom: oldResultshasSubclasses  ^self subclasses isNotEmptysafeArcCos  (self between: -1.0 and: 1.0) ifTrue: [ ^self arcCos ] ifFalse: [ ^self sign arcCos ]testSecondsAcrossTimeZones  | dateTime seconds dateTime2 utc |  dateTime := '1/15/2012 0000+00:00' asDateAndTime.  utc := TimeZone abbreviated: 'UTC'.  self useTimeZone: 'PDT' during: [:pdt |  seconds := dateTime asSeconds.        DateAndTime localTimeZone: utc.        dateTime2 := DateAndTime fromSeconds: seconds.        self assert: dateTime equals: dateTime2 ]assertSuccess: anExceptionTester  self should: [ anExceptionTester suiteLog first endsWith: 'succeeded' ]gtFilter  ^GTFilterBlock gtFiltertestPrintOn  self assert: (String streamContents: [:str |  aDateAndTime printOn: str ]) equals: '1901-01-01T00:00:00+00:00'.  self assert: (String streamContents: [:str |  aTimeZone printOn: str ]) equals: 'a TimeZone(ETZ)'testBecome  | a b c d |  a := 'ab' copy.  b := 'cd' copy.  c := a.  d := b.  a become: b.  self     assert: a equals: 'cd';     assert: b equals: 'ab';     assert: c equals: 'cd';     assert: d equals: 'ab'testForkAtHigherPriority  | hasBlockRun block return |  hasBlockRun := false.  block := [ hasBlockRun := true ].  return := block forkAt: Processor activeProcess priority + 1.  self assert: hasBlockRunweakSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self weakSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' category: cat// operand  ^operand isNumber ifTrue: [ self class nanoSeconds: (self asNanoSeconds // operand) asInteger ] ifFalse: [ self asNanoSeconds // operand asDuration asNanoSeconds ]fuelAccept: aGeneralMapper  ^self class == Rectangle ifTrue: [ aGeneralMapper visitRectangle: self ] ifFalse: [ super fuelAccept: aGeneralMapper ]isString  ^falsetestWaitTimeDuration  self assert: (Semaphore new wait: 50 milliSeconds) identicalTo: true.  self assert: (Semaphore new signal wait: 50 milliSeconds) identicalTo: falseextent  ^corner - originspotterActDefault: aStep  aStep exit.  self spotterActDefaultserializeOn: anEncoder  anEncoder encodeUint32: self asIntegertestNoon  self assert: aDateAndTime noon equals: '1980-01-01T12:00:00+00:00' asDateAndTimetestPrintOnBaseShowRadix  self assert: (String streamContents: [:str |  123 printOn: str base: 10 showRadix: false ]) equals: '123'.  self assert: (String streamContents: [:str |  123 printOn: str base: 10 showRadix: true ]) equals: '10r123'.  self assert: (String streamContents: [:str |  123 printOn: str base: 8 showRadix: false ]) equals: '173'.  self assert: (String streamContents: [:str |  123 printOn: str base: 8 showRadix: true ]) equals: '8r173'right  ^corner xvalueAt: blockPriority  | activeProcess result outsidePriority |  activeProcess := Processor activeProcess.  outsidePriority := activeProcess priority.  activeProcess priority: blockPriority.  result := self ensure: [ activeProcess priority: outsidePriority ].  blockPriority > outsidePriority ifTrue: [ Processor yield ].  ^resultsetSourcePointer: srcPointer  | trailer copy |  trailer := CompiledMethodTrailer new sourcePointer: srcPointer.  copy := self copyWithTrailerBytes: trailer.  (self trailer class == trailer class and: [ self size = copy size ]) ifTrue: [ | start |        start := self endPC + 1.        self replaceFrom: start to: self size with: copy startingAt: start ] ifFalse: [ self becomeForward: copy ].  ^selfdefaultAction  UIManager default systemNotificationDefaultAction: selflink: aMetaLink toClassVariable: aClassVariable  self shouldNotImplementtestTempNamedPut  | oneTemp |  oneTemp := 1.  self assert: (thisContext tempNamed: 'oneTemp') equals: oneTemp.  thisContext tempNamed: 'oneTemp' put: 2.  self assert: (thisContext tempNamed: 'oneTemp') equals: 2withArgs: argArray executeMethod: compiledMethod  < primitive: 188>  self primitiveFailedtestConverting  self assert: month asDate equals: '1 July 1998' asDatetestSubclasses  SystemNavigation new allClassesDo: [:cls |  self assert: (cls superclass isNil or: [ cls superclass subclasses includes: cls ]) description: cls name , ' is not in ' , (cls superclass ifNotNil: [:superclass |  superclass name ] ifNil: [ 'nil' ]) , '''s subclasses' ]nextObject  self shouldNotImplementasSeconds  ^secondsasYear  ^Year year: selfcanDiscardEdits  self dependents do: [:each |  each canDiscardEdits ifFalse: [ ^false ] ] without: self.  ^trueminutes  ^Duration minutes: selftimingPrioritySignalExpired  beingWaitedOn := false.  process suspendingList == delaySemaphore ifTrue: [ expired := true.        process           suspend;           resume ]nowTick  < primitive: 240>  self primitiveFailedshortStack  ^String streamContents: [:stream |  (self stackOfSize: 10) do: [:item |  stream                 print: item;                 cr ] ]meta  ^KMModifier meta + selftestByWeekNumber  week := Week year: 2013 week: 1.  self assert: week start equals: (DateAndTime year: 2012 month: 12 day: 31).  self assert: week start dayOfWeek equals: 2.  week := Week year: 2013 week: 32.  self assert: week start equals: (DateAndTime year: 2013 month: 8 day: 5).  self assert: week start dayOfWeek equals: 2.  week := Week year: 2013 week: 52.  self assert: week start equals: (DateAndTime year: 2013 month: 12 day: 23).  self assert: week start dayOfWeek equals: 2.  week := Week year: 2014 week: 1.  self assert: week start equals: (DateAndTime year: 2013 month: 12 day: 30).  self assert: week start dayOfWeek equals: 2deepCopy  ^x deepCopy @ y deepCopytestMinute  self assert: aDateAndTime minute equals: 0testNoon  self assert: aDateAndTime noon equals: '2004-02-29T12:00:00+02:00' asDateAndTimetestAsSeconds  self assert: aDateAndTime asSeconds equals: 2492985600testHeapForwards  | delay1 delay2 delay3 delay4 |  delay1 := Delay forMilliseconds: 1.  delay2 := Delay forMilliseconds: 2.  delay3 := Delay forMilliseconds: 3.  delay4 := Delay forMilliseconds: 4.  scheduler schedule: delay1.  scheduler schedule: delay2.  scheduler schedule: delay3.  scheduler schedule: delay4.  self assert: suspendedDelaysHeap removeFirstOrNil equals: delay2.  self assert: suspendedDelaysHeap removeFirstOrNil equals: delay3.  self assert: suspendedDelaysHeap removeFirstOrNil equals: delay4.  self assert: suspendedDelaysHeap removeFirstOrNil equals: nilvalueWithArguments: anArray  < primitive: 208>  | newContext |  numArgs ~= anArray size ifTrue: [ self numArgsError: anArray size ].  false ifTrue: [ newContext := self asContextWithSender: thisContext sender.        1 to: numArgs do: [:i |  newContext at: i put: (anArray at: i) ].        thisContext privSender: newContext ] ifFalse: [ self primitiveFailed ]at: index put: anObject  ^self at: index putLink: (self linkOf: anObject ifAbsent: [ anObject asLink ])testSourceNodeExecuted  | sourceNode |  sourceNode := thisContext sender sender sourceNodeExecuted.  self assert: sourceNode selector equals: #performTestreceiver  ^receivertestIncludes  self assert: (aSchedule includes: (DateAndTime year: 2003 month: 6 day: 15 hour: 20 minute: 30 second: 0 offset: 0 hours))testDaysInYear  self assert: (Year daysInYear: 2000) equals: 366.  self assert: (Year daysInYear: 2001) equals: 365.  self assert: (Year daysInYear: 2004) equals: 366.  self assert: (Year daysInYear: 2100) equals: 365.  self assert: (Year daysInYear: 2003) equals: 365name  ^name ifNil: [ self hash asString forceTo: 10 paddingStartWith: $  ]valueWithPossibleArguments: anArray  ^self valueWithEnoughArguments: anArrayrem: aNumber  ^self - ((self quo: aNumber) * aNumber)quadrantOf: otherPoint  ^x <= otherPoint x ifTrue: [ y < otherPoint y ifTrue: [ 1 ] ifFalse: [ 4 ] ] ifFalse: [ y <= otherPoint y ifTrue: [ 2 ] ifFalse: [ 3 ] ]removeSelector: selector  | priorMethod priorProtocol origin |  priorMethod := self compiledMethodAt: selector ifAbsent: [ ^nil ].  origin := priorMethod origin.  priorProtocol := self whichCategoryIncludesSelector: selector.  self organization removeElement: selector.  super removeSelector: selector.  SystemAnnouncer uniqueInstance methodRemoved: priorMethod protocol: priorProtocol origin: originabs  genBranchPopFalseLong: distance  | distanceMod256 |  (distance < 0 or: [ distance > 32767 ]) ifTrue: [ ^self outOfRangeError: 'distance' index: distance range: 0 to: 32767 ].  distanceMod256 := (distance < 0 or: [ distance > 255 ]) ifTrue: [ self genUnsignedSingleExtendB: (distance bitShift: -8).        distance bitAnd: 255 ] ifFalse: [ distance ].  stream     nextPut: 239;     nextPut: distanceMod256addSubclass: aClass  testCompiledMethodAsString  thisContext method asStringremoveProtocolIfEmpty: protocolName  (self protocolNamed: protocolName) ifNotNil: [:protocol |  (protocol isEmpty and: [ protocol canBeRemoved ]) ifTrue: [ self removeProtocol: protocol ] ]currentHand  ^ActiveHand ifNil: [ self currentWorld primaryHand ]pointerFloat  ^(ByteArray new: FFIFloat32 externalTypeSize)     floatAt: 1 put: self;     yourselfclassifyAll: aCollection under: heading  aCollection do: [:element |  self classify: element under: heading ]compiledBlock: aCompiledMethod  startpc := aCompiledMethodcenteredBeneath: aRectangle  ^self align: self topCenter with: aRectangle bottomCenterexitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil  | lock delay |  lock := queuesMutex critical: [ anOrderedCollection addLast: Semaphore new ].  self exit.  anIntegerOrNil ifNil: [ lock wait ] ifNotNil: [ delay := MonitorDelay signalLock: lock afterMSecs: anIntegerOrNil inMonitor: self queue: anOrderedCollection.        lock wait.        delay unschedule ].  self entertestIsModifierSymbol  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isModifierSymbol: ch) equals: (charset isModifierSymbol: ch) ]debug: aBoolean  self schedulingProcess == Delay schedulingProcess ifTrue: [ ^self ].  debug := aBooleantestInstSize  self assert: Object instSize equals: 0.  self assert: Point instSize equals: 2.  self assert: Metaclass instSize equals: 6testIsDigit  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isDigit: ch) equals: (charset isDigit: ch) ]readMe  translatedAndSquishedToBeWithin: aRectangle  ^(self translatedToBeWithin: aRectangle) squishedWithin: aRectangleremoveKey: aKey  ^self removeKey: aKey ifAbsent: [ self error: 'Property not found' ]testIsUsed  self assert: Object isUsed.  self assert: Object class isUsedtestSemaphoreNoTimeout  | sem process |  sem := Semaphore new.  [ | delay |  process := [ delay := Delay timeoutSemaphore: sem afterMSecs: 1000.  sem wait ] newProcess.  process priority: Processor highIOPriority.  process resume.  delay unschedule.  self deny: process isTerminated ] ensure: [ sem signal ].  self assert: process isTerminatedremoveMethod: aSymbol  self deprecated: 'Use #removeMethodSelector: instead' transformWith: '`@receiver removeMethod: `@arg' -> '`@receiver removeMethodSelector: `@arg'.  ^self removeMethodSelector: aSymbolnegative  ^falsegtDebuggerRetrieveVariableValuePairs  | fieldList |  fieldList := SortedCollection sortBlock: [:variablePair1 :variablePair2 |  variablePair1 key < variablePair2 key ].  fieldList addAll: (self receiver class allSlots collect: [:slot |  GTInspectorSlotNode hostObject: self receiver slot: slot ]).  fieldList addAll: self gtInspectorTempNodes.  fieldList addAll: (self gtDebuggerDoItBindings collect: [:aBinding |  (GTInspectorDynamicNode hostObject: self label: aBinding key value: aBinding value)                 variableTag: 'temp';                 yourself ]).  ^fieldList asOrderedCollection     addFirst: (GTInspectorSelfNode hostObject: self receiver);     addLast: (GTInspectorDynamicNode hostObject: self label: 'thisContext' value: self);     addLast: (GTInspectorDynamicNode hostObject: self label: 'stack top' value: (self stackPtr > 0 ifTrue: [ self top ]));     yourselfclassesThatImplementAllOf: selectorSet  | found remaining |  found := OrderedCollection new.  selectorSet do: [:sel |  (self includesSelector: sel) ifTrue: [ found add: sel ] ].  found isEmpty ifTrue: [ ^self subclasses inject: Array new into: [:subsThatDo :sub |  subsThatDo , (sub classesThatImplementAllOf: selectorSet) ] ] ifFalse: [ remaining := selectorSet copyWithoutAll: found.        remaining isEmpty ifTrue: [ ^Array with: self ].        ^self subclasses inject: Array new into: [:subsThatDo :sub |  subsThatDo , (sub classesThatImplementAllOf: remaining) ] ]fromRectangle: aRectangle  self setTop: aRectangle top left: aRectangle left bottom: aRectangle bottom right: aRectangle rightinsetOriginBy: originDeltaPoint cornerBy: cornerDeltaPoint  ^Rectangle origin: origin + originDeltaPoint corner: corner - cornerDeltaPointtestFirstWeekdayOfMonthYear  self assert: (Date firstWeekdayOfMonth: 'January' year: 2004) equals: 5min  ^self x min: self yisHeap  ^falsetestParsingPatternWithTrailingCharacterFails  self assertReading: '04.02.2013trailing' as: 'd.m.y' raise: DateErrororganizedClass  ^organizedClassmetaLevelScope  ^self isInstanceSide ifTrue: [ ClyInstanceSideScope ] ifFalse: [ ClyClassSideScope ]setTimestampInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setTimestamp: selfrename: newName  self name: newNamesettingStoreOn: aStream  ^self storeOn: aStreamceiling  self isIntegerPoint ifTrue: [ ^self ].  ^x ceiling @ y ceilingtestParsingYYPatternWithWrongNumberOrDigitsShouldFails  self assertReading: '02.11.3' as: 'dd.mm.yy' raise: DateError.  self assertReading: '02.11.113' as: 'dd.mm.yy' raise: DateErrortestIsLetterNumber  self checkCorrespondanceOf: #isLetterNumber: and: #NlsetDelay: milliseconds forSemaphore: aSemaphore  millisecondDelayDuration := milliseconds asInteger.  millisecondDelayDuration < 0 ifTrue: [ self error: 'delay times cannot be negative' ].  delaySemaphore := aSemaphore.  beingWaitedOn := falsecleanUp: aggressive  ^self cleanUpisActive: n  < metaLinkOptions: #(+ optionDisabledLink)>  ^level = n or: [ level == nil ]asSmallAngleDegrees  | pos |  pos := self \\ 360.  pos > 180 ifTrue: [ pos := pos - 360 ].  ^postestNoon  self assert: aDateAndTime noon equals: '1970-01-01T12:00:00+00:00' asDateAndTimetestErrorCodeNotFoundIndexed  | ctx result resultSimu |  Smalltalk vm isRunningCog ifFalse: [ ^self ].  result := self indexedBasicAt: 100.  ctx := Context sender: nil receiver: nil method: Object >> #at: arguments: #(10).  resultSimu := ctx     push: nil;     push: 500;     doPrimitive: 60 method: self class >> #indexedBasicAt: receiver: self args: #(100).  self assert: resultSimu isArray.  self assert: resultSimu size equals: 2.  self assert: Context primitiveFailToken first identicalTo: resultSimu first.  self assert: result equals: resultSimu secondraisedToInteger: exp modulo: m  exp = 0 ifTrue: [ ^1 ].  exp even ifTrue: [ ^(self raisedToInteger: exp // 2 modulo: m) squared \\ m ] ifFalse: [ ^self * (self raisedToInteger: exp - 1 modulo: m) \\ m ]variableByteSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self variableByteSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' category: cat= aMagnitude  ^self subclassResponsibilityaddSelectorTo: set  | selectorOrSelf |  (selectorOrSelf := self selectorToSendOrSelf) == self ifFalse: [ set add: selectorOrSelf ]evaluate: aBlock onBehalfOf: aProcess  | oldEffectiveProcess |  oldEffectiveProcess := effectiveProcess.  effectiveProcess := aProcess.  ^aBlock ensure: [ effectiveProcess := oldEffectiveProcess ]isText  ^falseodd  ^(self bitAnd: 1) = 1irPrimitive  | primNode n |  primNode := IRPrimitive new num: (n := self primitive).  (n = 117 or: [ n = 120 ]) ifTrue: [ primNode spec: (self literalAt: 1) ].  ^primNodeunload  method: method pc: startpc  sender := method.  pc := startpcisDoIt  ^falsetestExactNthRoot  | eight thousandth tenth two |  eight := 8.0s1.  two := eight raisedTo: 1 / 3.  self assert: two equals: 2.  self assert: (two class = eight class and: [ two scale = eight scale ]).  thousandth := 0.001s3.  tenth := thousandth raisedTo: 1 / 3.  self assert: tenth * 10 equals: 1.  self assert: (tenth class = thousandth class and: [ tenth scale = thousandth scale ])privHandlerContext  ^handlerContextreciprocal  ^self class newFromNumber: super reciprocal scale: scaletestRounded  self assert: 0 rounded equals: 0.  self assert: 1 rounded equals: 1.  self assert: (1 / 2) rounded equals: 1.  self assert: (1 / 2 - Float epsilon) rounded equals: 0charCode  ^self asInteger bitAnd: 4194303notEmpty  ^self basicSize > 0months  | months |  months := OrderedCollection new: 12.  self monthsDo: [:m |  months add: m ].  ^months asArray>= aNumber  < primitive: 6>  ^super >= aNumbertestOffset  | dateAndTime1 dateAndTime2 |  dateAndTime1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 1 hours.  dateAndTime2 := dateAndTime1 offset: 1 hour.  self assert: dateAndTime1 equals: dateAndTime2.  self assert: dateAndTime1 localSeconds equals: dateAndTime2 localSeconds.  dateAndTime2 := dateAndTime1 offset: -1 hour.  self assert: dateAndTime1 equals: dateAndTime2.  self deny: dateAndTime1 localSeconds identicalTo: dateAndTime2 localSeconds.  dateAndTime2 := dateAndTime1 offset: -2 hour.  self assert: dateAndTime1 equals: dateAndTime2.  self deny: dateAndTime1 localSeconds identicalTo: dateAndTime2 localSecondsusesUndeclares  (UndeclaredVariable inheritsFrom: LiteralVariable) ifTrue: [ self literalsDo: [:each |  each class == UndeclaredVariable ifTrue: [ ^true ].              (each isBlock not and: [ each value isBehavior and: [ each value isObsolete ] ]) ifTrue: [ ^true ] ] ] ifFalse: [ self literalsDo: [:each |  (each class == Association and: [ each key notNil and: [ (each value isKindOf: Slot) not ] ]) ifTrue: [ ^true ] ] ].  ^falsebeWritableObject  ^self setIsReadOnlyObject: falsehashMultiply  < primitive: 159>  | low |  low := self bitAnd: 16383.  ^16r260D * low + ((16r260D * (self bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384) bitAnd: 16r0FFFFFFFname: anObject  name := anObject asSymboloffset: aDuration  offset := aDurationremoveProperty: propName ifAbsent: aBlock  | value |  value := self propertyAt: propName ifAbsent: [ ^aBlock value ].  self penultimateLiteral: (self penultimateLiteral copyWithout: (Association key: propName value: value)).  ^valuespotterClassInstanceVariablesFor: aStep  < spotterOrder: 25>  self isTrait ifTrue: [ ^self ].  aStep listProcessor     title: 'Class instance variables';     allCandidates: [ self class classLayout allSlots ];     itemName: [:each |  each name asString ];     filter: GTFilterSubstringmethodSelector  ^method selectortestHasLiteralSuchThat  self deny: (Object >> #yourself hasLiteralSuchThat: [:lit |  lit == #yourself ]).  self assert: (Object >> #halt hasLiteralSuchThat: [:lit |  lit == #now ])testHash  self assert: aDateAndTime hash equals: DateAndTime new hashtestReadTimeZoneOffsetRFC822  self assert: (DateAndTime readTimezoneOffsetFrom: '+0530' readStream) printString equals: '0:05:30:00'testHeapBackwards  | delay1 delay2 delay3 delay4 |  delay1 := Delay forMilliseconds: 1.  delay2 := Delay forMilliseconds: 2.  delay3 := Delay forMilliseconds: 3.  delay4 := Delay forMilliseconds: 4.  scheduler schedule: delay4.  scheduler schedule: delay3.  scheduler schedule: delay2.  scheduler schedule: delay1.  self assert: suspendedDelaysHeap removeFirstOrNil equals: delay2.  self assert: suspendedDelaysHeap removeFirstOrNil equals: delay3.  self assert: suspendedDelaysHeap removeFirstOrNil equals: delay4.  self assert: suspendedDelaysHeap removeFirstOrNil equals: nilprintOn: aStream  aStream nextPut: $(.  numerator printOn: aStream.  aStream nextPut: $/.  denominator printOn: aStream.  aStream nextPut: $)brickValue: anObject withEnoughArguments: aCollection  ^anObjecttestTicksOffset  self assert: aDateAndTime equals: (aDateAndTime ticks: #(2453065 48780 0) offset: DateAndTime localOffset)sendsAnySelectorOf: aCollection  (self localSendsAnySelectorOf: aCollection) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:cb |  cb sendsAnySelectorOf: aCollection ]printHexByteOn: characterWriteStream  (self between: 0 and: 255) ifTrue: [ | highNibble lowNibble hexDigits |        highNibble := self bitShift: -4.        lowNibble := self bitAnd: 15.        hexDigits := '0123456789ABCDEF'.        characterWriteStream           nextPut: (hexDigits at: highNibble + 1);           nextPut: (hexDigits at: lowNibble + 1) ] ifFalse: [ self error: 'byte value between 0 and 255 expected' ]leftmost: aBlock tree: aTree continuation: out  ^(aTree isNotNil and: [ aTree isMemberOf: ValueLink ]) ifTrue: [ | car |        car := aTree value.        (car isKindOf: Link) ifTrue: [ self leftmost: aBlock tree: car continuation: out ] ifFalse: [ (aBlock value: car) ifTrue: [ out value: car ] ].        self leftmost: aBlock tree: aTree nextLink continuation: out ] ifFalse: [ nil ]testWholeMilliseconds  self assert: 0 seconds wholeMilliseconds equals: 0.  self assert: 1 second wholeMilliseconds equals: 0.  self assert: 1002003004 nanoSeconds wholeMilliseconds equals: 2first  ^self firstLink valuesignalLock: aSemaphore inQueue: anOrderedCollection  queuesMutex critical: [ aSemaphore signal.        anOrderedCollection remove: aSemaphore ifAbsent: [  ] ]addSelector: selector withMethod: compiledMethod notifying: requestor  self deprecated: 'Please use #addSelector:withMethod: instead' transformWith: '`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3' -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.  ^self addSelector: selector withMethod: compiledMethodmeridianAbbreviation  ^self asTime meridianAbbreviationtraceCr: anObject  self trace: anObject.  Transcript crprintFrequenceOn: stream  self frequency printOn: stream showingDecimalPlaces: 3.  stream << ' per second'ticks  | days |  days := self days.  ^Array with: days with: seconds - (days * SecondsInDay) with: nanosslotsNeedFullDefinition  ^self slots anySatisfy: [:each |  each needsFullDefinition ]timingPrioritySignalExpired  beingWaitedOn := false.  delaySemaphore signalsin  ^self asFloat sincopyFrom: otherOrganization  commentRemoteString := otherOrganization commentRemoteString.  commentStamp := otherOrganization commentStamp.  otherOrganization protocols do: [:p |  p methodSelectors do: [:m |  protocolOrganizer classify: m inProtocolNamed: p name ] ]receiver  ^receiverencodeOn: aDocument  aDocument print: self greaseStringprintOn: aStream showingDecimalPlaces: placesDesired  | rounder rounded roundedFractionPart |  placesDesired <= 0 ifTrue: [ ^self rounded printOn: aStream ].  rounder := 10 raisedToInteger: placesDesired.  rounded := self roundTo: rounder reciprocal.  rounded negative ifTrue: [ aStream nextPut: $- ].  rounded := rounded abs.  rounded integerPart truncated printOn: aStream.  aStream nextPut: $..  roundedFractionPart := (rounded fractionPart * rounder) truncated.  roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: trueschedule: aDelay  < haltOrBreakpointForTesting>  debug ifTrue: [ self halt ].  aDelay beingWaitedOn ifTrue: [ ^self error: 'This Delay has already been scheduled.' ].  delayToStart := aDelay.  timingSemaphore signal.  debug ifTrue: [ self halt ]shallowCopy  ^self - 0.0propertyAt: aKey ifAbsentPut: aBlock  ^self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]selectorsInProtocol: aName  | aColl |  aColl := Set withAll: (self organization listAtCategoryNamed: aName).  ^aColl asArray sorttestRounded  self assert: (1999 / 1000s2) printString equals: '2.00s2'.  self assert: (-1999 / 1000s2) printString equals: '-2.00s2'indexedBasicAt: index  < primitive: 60 error: code>  ^codeifNil: nilBlock ifNotNil: ifNotNilBlock  ^nilBlock valueffiCall: fnSpec  < ffiCalloutTranslator>  self ffiCall: fnSpec library: self ffiLibrarycopyStack  ^self copyTo: nilifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock  ^trueAlternativeBlock valueprotocolOfElement: element  ^self categoryOfElement: elementcanBeRenamed  ^falsedateClass  ^DatenumArgs  ^(self header bitShift: -24) bitAnd: 16r0FtestAsDuration  self assert: aDateAndTime asDuration equals: 0 asDurationtestMinute  self assert: aDateAndTime minute equals: 33testSimpleResignalAs  self assertSuccess: (ExceptionTester new runTest: #simpleResignalAsTest)extendBy: deltaMargin  ^deltaMargin asMargin extendRectangle: selfglamourValueWithArgs: anArray  self selector isUnary ifTrue: [ ^self value ].  self selector numArgs = anArray size ifTrue: [ ^self valueWithArguments: anArray ].  self selector numArgs > anArray size ifTrue: [ ^self valueWithArguments: anArray , (Array new: self selector numArgs - anArray size) ].  ^self valueWithArguments: (anArray copyFrom: 1 to: self selector numArgs)testYearMonthDayHourMinuteSecondNanosSecondOffset  self assert: aDateAndTime equals: (DateAndTime year: 1970 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours).  self assert: (DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours) + (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) equals: (DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)startpc  ^startpcactivate  self isSuspended ifTrue: [ self timespans add: (Timespan starting: DateAndTime now duration: Duration zero).        self state: #active ]allSelectorsToTestInMethodFinderWithArity: anInteger  ^self allSelectorsToTestInMethodFinder select: [:selector |  selector numArgs = anInteger ]innerCompiledBlocksDo: aBlock  1 to: self numLiterals - 1 do: [:index |  | lit |        lit := self objectAt: index + 1.        (lit isMemberOf: CompiledBlock) ifTrue: [ aBlock value: lit ] ]testObject: object initialState: initialState tuples: tuples  self testObject: object initialState: initialState tuples: tuples setReadOnlyBlock: [:value |  object setIsReadOnlyObject: value ]gtInspectorActions  | all |  all := (Pragma allNamed: #gtInspectorAction from: self class to: ProtoObject) collect: [:eachPragma |  thisContext object: self perform: eachPragma methodSelector withArguments: #() inClass: self class ].  ^all asSortedCollection: [:a :b |  | first second |        first := a isCategorized ifTrue: [ a category , a title ] ifFalse: [ a title ].        second := b isCategorized ifTrue: [ b category , b title ] ifFalse: [ b title ].        first < second ]default  ^defaultstoreOn: aStream  aStream nextPut: $(.  self printOn: aStream.  aStream nextPut: $)printString  ^self printStringLimitedTo: 50000gtInspectorSourceIn: composite  < gtInspectorPresentationOrder: 30>  (self method gtInspectorSourceIn: composite)     doItReceiver: [ self receiver ];     doItContext: [ self ]testAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)testSupplyAnswerOfFillInTheBlankUsingDefaultAnswer  self should: [ 'red' = ([ UIManager default request: 'Your favorite color?' initialAnswer: 'red' ] valueSupplyingAnswer: #('Your favorite color?' #default)) ]valueWithExit  self value: [ ^nil ]testAllSharedPools  self assert: Point allSharedPools equals: OrderedCollection new.  self assert: Date sharedPools first equals: ChronologyConstants.  self assert: Date sharedPools size equals: 1.  self assert: RootClassPoolUser sharedPools size equals: 1.  self assert: ClassMultiplePoolUser sharedPools size equals: 2.  self assertEmpty: SubclassPoolUser sharedPoolsdoSomethingString  ^'Do something.'findSimilarSender  ^self sender findContextSuchThat: [:context |  context method == method ]shift  ^KMModifier shift + selffollowingByte  ^self method at: pc + 1genStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex  (tempIndex < 0 or: [ tempIndex >= 256 ]) ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255 ].  (tempVectorIndex < 0 or: [ tempVectorIndex >= 128 ]) ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127 ].  stream     nextPut: 252;     nextPut: tempIndex;     nextPut: tempVectorIndexname: aString  name := aStringln  ^self asFloat lnselector: aSelector  | penultimateLiteral nl |  Symbol internSelector: aSelector.  (penultimateLiteral := self penultimateLiteral) isMethodProperties ifTrue: [ penultimateLiteral selector: aSelector ] ifFalse: [ (nl := self numLiterals) < 2 ifTrue: [ self error: 'insufficient literals to hold selector' ].        self literalAt: nl - 1 put: aSelector ]assert: aBlock description: aStringOrBlock  < debuggerCompleteToSender>  aBlock value ifFalse: [ AssertionFailure signal: aStringOrBlock value ]addSelector: selector withMethod: compiledMethod  ^self addSelectorSilently: selector withMethod: compiledMethodsubscript  ^subscriptisSpecContainer  ^false< anInteger  < primitive: 23>  ^super < anIntegersignaler  ^signaler\\ aNumber  < primitive: 11>  ^super \\ aNumbergtDebuggerRawIn: composite  < gtDebuggerPresentationOrder: 15>  (GTProtoObjectVariablesBrowser new variablesIn: composite)     title: 'Raw';     send: #valueversion: aString  versionString := aStringcompleteProcess: aProcess with: aContext  ^self signalerContexttestNonResumableFallOffTheEndHandler  self assertSuccess: (ExceptionTester new runTest: #nonResumableFallOffTheEndHandler)valuesDo: aBlock  tally = 0 ifTrue: [ ^self ].  1 to: self basicSize do: [:i |  (array at: i) ifNotNil: [:value |  aBlock value: value ] ]testLowBit  | suite |  self assert: 2r1011 lowBit equals: 1.  self assert: 2r1010 lowBit equals: 2.  self assert: 2r000000 lowBit equals: 0.  suite := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA) , {SmallInteger maxVal .         (SmallInteger maxVal + 1)}.  suite := suite , (suite collect: [:e |  e raisedTo: 20 ]).  suite do: [:anInteger |  | lowBit |        lowBit := (anInteger respondsTo: #bitAt:) ifTrue: [ (1 to: anInteger highBit) detect: [:bitIndex |  (anInteger bitAt: bitIndex) ~= 0 ] ifNone: [ 0 ] ] ifFalse: [ (1 to: anInteger highBit) detect: [:bitIndex |  (anInteger bitAnd: (1 bitShift: bitIndex - 1)) ~= 0 ] ifNone: [ 0 ] ].        self assert: anInteger lowBit equals: lowBit.        self assert: anInteger negated lowBit equals: lowBit ]testInstanceSide  self assert: Point instanceSide equals: Point.  self assert: Point class instanceSide equals: PointtestAsNumberWithoutDecimalPoint2  | sd |  sd := '123s2' asNumber.  self assert: ScaledDecimal identicalTo: sd class.  self assert: sd scale equals: 2.  self assert: '123.00s2' equals: sd printStringasMargin  ^selfisSelfEvaluating  ^self class == PointtestRaisedTo  self should: [ 0 raisedTo: -1 ] raise: ZeroDivide.  self should: [ 0 raisedTo: -1.0 ] raise: ZeroDividecreateMethod: numberOfBytesForAllButTrailer class: aCompiledMethodClass header: headerWord  | meth |  encodedData ifNil: [ self encode ].  meth := aCompiledMethodClass newMethod: numberOfBytesForAllButTrailer + size header: headerWord.  1 to: size do: [:i |  meth at: meth size - size + i put: (encodedData at: i) ].  ^methstandardMessageText  ^String streamContents: [:stream |  stream print: self selector.        stream << ' is not yet implemented in '.        stream print: self signaler class ]vmSimNextWakeupMilliseconds  ^vmSimNextWakeupTick / 1000testMemoizedLRUCache  | cache factorial result |  cache := LRUCache new maximumWeight: 3.  factorial := 0.  factorial := [:n |  n = 1 ifTrue: [ 1 ] ifFalse: [ (factorial value: n - 1) * n ] ] memoizedUsing: cache.  result := (1 to: 5) collect: factorial.  self assert: result equals: #(1 2 6 24 120).  self assert: cache testSupportGetCachedAssociations equals: {(3 -> 6) .         (4 -> 24) .         (5 -> 120)}postCopy  1 to: self basicSize do: [:i |  self basicAt: i put: (self basicAt: i) shallowCopy ]reentrant  ^selfoldDefinition  | aStream |  aStream := (String new: 800) writeStream.  superclass ifNil: [ aStream nextPutAll: 'ProtoObject' ] ifNotNil: [ aStream nextPutAll: superclass name ].  aStream     nextPutAll: self kindOfSubclass;     store: self name.  self hasTraitComposition ifTrue: [ aStream           cr;           tab;           nextPutAll: 'uses: ';           nextPutAll: self traitCompositionString ].  aStream     cr;     tab;     nextPutAll: 'instanceVariableNames: ';     store: self instanceVariablesString.  aStream     cr;     tab;     nextPutAll: 'classVariableNames: ';     store: self classVariablesString.  aStream     cr;     tab;     nextPutAll: 'poolDictionaries: ';     store: self sharedPoolsString.  aStream     cr;     tab;     nextPutAll: 'category: ';     store: self category asString.  superclass ifNil: [ aStream           nextPutAll: '.';           cr.        aStream nextPutAll: self name.        aStream           space;           nextPutAll: 'superclass: nil' ].  ^aStream contentscriticTheNonMetaclassClass  ^selfsend: selector to: aReceiver with: arguments super: superFlag  | class aMethod value context |  class := superFlag ifTrue: [ (self method literalAt: self method numLiterals) value superclass ] ifFalse: [ self objectClass: aReceiver ].  aMethod := class lookupSelector: selector.  aMethod == nil ifTrue: [ ^self send: #doesNotUnderstand: to: aReceiver with: (Array with: (Message selector: selector arguments: arguments)) super: superFlag ].  aMethod isCompiledMethod ifFalse: [ ^self send: #run:with:in: to: aMethod with: (Array with: selector with: arguments with: aReceiver) super: superFlag ].  value := self tryPrimitiveFor: aMethod receiver: aReceiver args: arguments.  (self isFailToken: value) ifFalse: [ ^value ].  (selector == #doesNotUnderstand: and: [ (class canUnderstand: #doesNotUnderstand:) not ]) ifTrue: [ ^self error: 'Simulated message ' , (arguments at: 1) selector , ' not understood' ].  context := self activateMethod: aMethod withArgs: arguments receiver: aReceiver class: class.  (context method at: context pc) = 129 ifTrue: [ context at: context stackPtr put: value last ].  ^contextaddModelYellowButtonMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph  Morph cmdGesturesEnabled ifTrue: [ aCustomMenu add: 'inspect model' target: self selector: #inspect ].  ^aCustomMenuat: aKey ifAbsent: aBlock  1 to: self basicSize do: [:i |  | propertyOrPragma |        (propertyOrPragma := self basicAt: i) key == aKey ifTrue: [ ^propertyOrPragma isVariableBinding ifTrue: [ propertyOrPragma value ] ifFalse: [ propertyOrPragma ] ] ].  ^aBlock valuegenCallPrimitive: primitiveIndex  (primitiveIndex < 1 or: [ primitiveIndex > 65535 ]) ifTrue: [ self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 65535 ].  stream     nextPut: 139;     nextPut: (primitiveIndex bitAnd: 255);     nextPut: (primitiveIndex bitShift: -8)genStoreLiteralVar: literalIndex  (literalIndex < 0 or: [ literalIndex > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 32768 ].  literalIndex > 255 ifTrue: [ self genUnsignedSingleExtendA: literalIndex // 256 ].  stream     nextPut: 244;     nextPut: literalIndex \\ 256primSignal: aSemaphore atUTCMicroseconds: aLargePositiveInteger  < primitive: 242>  ^self primitiveFailedtestDayMonthYearDo  january23rd2004 dayMonthYearDo: [:day :month :year |  self assert: day equals: 23.        self assert: month equals: 1.        self assert: year equals: 2004 ]printOn: aStream base: b  | halfDigits halfPower head tail nDigitsUnderestimate |  (self bytesCount = 0 or: [ (self byteAt: self bytesCount) = 0 ]) ifTrue: [ ^self normalize printOn: aStream base: b ].  nDigitsUnderestimate := b = 10 ifTrue: [ ((self highBit - 1) * 1233 >> 12) + 1 ] ifFalse: [ self highBit quo: b highBit ].  halfDigits := 1 bitShift: nDigitsUnderestimate highBit - 2.  halfDigits <= 1 ifTrue: [ ^self printOn: aStream base: b nDigits: (self numberOfDigitsInBase: b) ].  halfPower := b raisedToInteger: halfDigits.  head := self quo: halfPower.  tail := self - (head * halfPower).  head printOn: aStream base: b.  tail printOn: aStream base: b nDigits: halfDigitsasMonth  ^selfsourceNode  ^self sourceNodeInOuteractivateMethod: newMethod withArgs: args receiver: rcvr class: class  ^Context sender: self receiver: rcvr method: newMethod arguments: argstimeClass  ^Timedefinition  (self slotsNeedFullDefinition or: [ Slot showSlotClassDefinition ]) ifTrue: [ ^self definitionWithSlots ].  ^self definitionWithoutSlotsdebug  Processor activeProcess debug: self signalerContext title: self descriptionat: key ifAbsent: aBlock  | index |  index := self findElementOrNil: key.  (self basicAt: index) ifNil: [ ^aBlock value ].  ^array at: indexsuspendedContext  ^suspendedContextsubclass: aSubclassSymbol uses: aTraitCompositionOrArray slots: slotDefinition classVariables: classVarDefinition package: aCategorySymbol  ^self subclass: aSubclassSymbol uses: aTraitCompositionOrArray layout: self classLayout class slots: slotDefinition classVariables: classVarDefinition poolDictionaries: '' category: aCategorySymbolisValidTraitName: aSymbol  aSymbol ifNil: [ ^false ].  ^aSymbol isValidGlobalNameisOnOrAfter: aDate  ^(self equals: aDate) or: [ self isAfter: aDate ]propertyValueAt: propName  ^self propertyAt: propNamecurrentWorld  ^UIManager default currentWorldsize  < primitive: 212>  ^self primitiveFailleft: aNumber  ^aNumber @ origin y corner: cornerreciprocal  ^x reciprocal @ y reciprocalgenBranchPopTrueLong: distance  | distanceMod256 |  (distance < 0 or: [ distance > 32767 ]) ifTrue: [ ^self outOfRangeError: 'distance' index: distance range: 0 to: 32767 ].  (distance > 0 and: [ distance < 9 ]) ifTrue: [ stream nextPut: 183 + distance.        ^self ].  distanceMod256 := (distance < 0 or: [ distance > 255 ]) ifTrue: [ self genUnsignedSingleExtendB: (distance bitShift: -8).        distance bitAnd: 255 ] ifFalse: [ distance ].  stream     nextPut: 238;     nextPut: distanceMod256gtInspectorEProportiesIn: composite  < gtInspectorPresentationOrder: 20>  | eProperties ePropLazy |  ReSettings inspectorPluggin ifFalse: [ ^self ].  ePropLazy := [ eProperties ifNil: [ eProperties := self externalProperties ] ].  composite list     when: [ ePropLazy value notEmpty ];     title: [ ePropLazy value size asString , (' property' asPluralBasedOn: ePropLazy value) ];     titleIcon: [ CircleMorph new           extent: 16 @ 16;           borderWidth: 0;           color: Color red darker darker;           addMorphCentered: (ePropLazy value size asStringMorph                 color: Color white;                 emphasis: 1;                 yourself);           iconOrThumbnail ];     display: [ ePropLazy value ];     icon: #icon;     format: #titlenumerator  ^numeratornewRectFrom: newRectBlock  | rect newRect buttonStart buttonNow hand |  hand := self currentWorld activeHand.  buttonStart := buttonNow := hand anyButtonPressed.  rect := self.  self drawReverseFrame: rect.  hand captureEventsWhile: [:evt |  evt isMouse ifTrue: [ buttonNow := evt anyButtonPressed.              newRect := newRectBlock value: rect value: evt cursorPoint.              newRect = rect ifFalse: [ self drawReverseFrame: rect.                    self drawReverseFrame: newRect.                    rect := newRect ].              buttonNow = buttonStart ] ifFalse: [ true ] ].  self drawReverseFrame: rect.  hand     newMouseFocus: nil;     showTemporaryCursor: nil.  ^rectreturn: value  sender ifNil: [ ^self cannotReturn: value to: sender ].  sender resume: valuevariableWordSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat  ^self classInstaller make: [:builder |  builder           superclass: self;           name: t;           layoutClass: WordLayout;           slots: f asSlotCollection;           sharedVariablesFromString: d;           sharedPools: s;           category: cat;           environment: self environment ]stopTimerEventLoop  runTimerEventLoop := false.  timingSemaphore signal.  timerEventLoop isTerminated ifFalse: [ debug ifFalse: [ self error: 'Expected timing priority event loop terminated already' ].        timerEventLoop terminate ].  timerEventLoop := niltestValueWithExitBreak  | val |  [:break |  1 to: 10 do: [:i |  val := i.        i = 4 ifTrue: [ break value ] ] ] valueWithExit.  self assert: val equals: 4ast  ^ASTCache at: selftallyCPUUsageFor: seconds every: msec  | tally sem delay endDelay |  tally := IdentityBag new: 200.  delay := Delay forMilliseconds: msec truncated.  endDelay := Delay forSeconds: seconds.  endDelay schedule.  sem := Semaphore new.  [ [ endDelay isExpired ] whileFalse: [ delay wait.        tally add: Processor nextReadyProcess ].  sem signal ] forkAt: self highestPriority.  ^[ sem wait.  tally ]lookupClass: aClass  lookupClass := aClassmessageText  ^messageText ifNil: [ messageText := self standardMessageText ]singleRelease  stackp ifNotNil: [ 1 to: stackp do: [:i |  self at: i put: nil ] ].  sender := nil.  pc := niltestParsingMMPatternWithIncorrectMonthFails  self assertReading: '02.00.2013' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.13.2013' as: 'dd.mm.yyyy' raise: DateErrordigitAt: index put: value  self deprecated: 'Please use #byteAt:put: instead' transformWith: '`@receiver digitAt: `@statements1 put: `@statements2' -> '`@receiver byteAt: `@statements1 put: `@statements2'.  ^self byteAt: index put: valuehasMethods  ^super hasMethods or: [ self classSide hasMethods ]shouldNotImplementMethod  ^self shouldNotImplementprintSystemPath  ^self calypsoEnvironmentType printSystemPathTo: selfbottom  ^corner yclassComment: aString stamp: aStamp  | pointer header oldCommentRemoteString oldComment oldStamp preamble |  oldComment := self organization classComment.  oldStamp := self organization commentStamp.  aString string = oldComment string ifTrue: [ ^self ].  aString isRemoteString ifTrue: [ SystemAnnouncer uniqueInstance class: self oldComment: oldComment newComment: aString string oldStamp: oldStamp newStamp: aStamp.        ^self organization classComment: aString stamp: aStamp ].  oldCommentRemoteString := self organization commentRemoteString.  pointer := oldCommentRemoteString ifNil: [ 0 ] ifNotNil: [ oldCommentRemoteString sourcePointer ].  preamble := String streamContents: [:file |  file           cr;           nextPut: $!.        header := String streamContents: [:strm |  strm                 nextPutAll: self name;                 nextPutAll: ' commentStamp: '.              aStamp storeOn: strm.              strm                 nextPutAll: ' prior: ';                 nextPutAll: pointer printString ].        file           nextChunkPut: header;           cr ].  SourceFiles writeSource: aString preamble: preamble onSuccess: [:newSourcePointer |  self organization classComment: (SourceFiles remoteStringAt: newSourcePointer) stamp: aStamp ] onFail: [  ].  SystemAnnouncer uniqueInstance class: self oldComment: oldComment newComment: aString oldStamp: oldStamp newStamp: aStamptestAddSeconds  self assert: (aTime addSeconds: 1) equals: (Time readFrom: '12:34:57' readStream).  self assert: (aTime addSeconds: 60) equals: (Time readFrom: '12:35:56' readStream).  self assert: (aTime addSeconds: 3600) equals: (Time readFrom: '13:34:56' readStream).  self assert: (aTime addSeconds: 24 * 60 * 60) equals: (Time readFrom: '12:34:56' readStream)suspendedContext: aContext  suspendedContext := aContexttestScaleExtension  #(#* #+ #- #/) do: [:op |  self assert: (2.5s1 perform: op with: 1.000s3) scale equals: 3.        self assert: (3.5000s4 perform: op with: 1.0s1) scale equals: 4 ]referencingMethod3  ^selftestPrint24withNanos  self assert: '12:34:56.1' asTime print24 equals: '12:34:56'testIsProbablyPrime  #(-100 -5 -3 -2 -1 0 1) do: [:each |  self deny: each isProbablyPrime ].  #(17 78901 104729 15485863 2038074743 29996224275833) do: [:each |  self assert: each isProbablyPrime ].  #(561 2821 6601 10585 15841 256 29996224275831) do: [:each |  self deny: each isProbablyPrime ]removeSavedTemp: aTemp  self savedTemps ifNotNil: [:saved |  saved remove: aTemp.        saved ifEmpty: [ self removeProperty: #savedTemps ] ]command  ^KMModifier command + selfveryDeepCopyWith: deepCopier  interpretNextInstructionFor: client  ^self method encoderClass interpretNextInstructionFor: client in: selfvariableNode: anObject  variableNode := anObjectmonth  ^self dayMonthYearDo: [:d :m :y |  m ]traverseWithMemory: aMemory seen: anIdentitySet  aMemory accumulate: self.  anIdentitySet add: self.  self traversableInstVarIndexes do: [:index |  aMemory traverse: self value: (self instVarAt: index) seen: anIdentitySet ].  self traversableIndexableVarIndexes do: [:index |  aMemory traverse: self value: (self basicAt: index) seen: anIdentitySet ]selectorsToBeIgnored  | deprecated private special |  deprecated := #().  private := #().  special := #(#< #= #new #next #previous #printOn: #printOn:format: #storeOn: #fromString:).  ^super selectorsToBeIgnored , deprecated , private , specialasMinimalRepresentation  ^selftestComparing  | sameDate laterDate earlierDate |  sameDate := june2nd1973 asString asDate.  laterDate := june2nd1973 + 1 day.  earlierDate := june2nd1973 - 1 day.  self     assert: june2nd1973 equals: sameDate;     assert: june2nd1973 equals: june2nd1973 copy;     assert: june2nd1973 hash equals: sameDate hash.  self     assert: june2nd1973 < laterDate;     assert: june2nd1973 > earlierDateattemptToAssign: value withIndex: index  self modificationForbiddenFor: #instVarAt:put: index: index value: value.  thisContext sender jumphour24  ^(seconds rem: SecondsInDay) quo: SecondsInHourmethodReference  | class selector |  class := self methodClass ifNil: [ ^nil ].  selector := self selector ifNil: [ ^nil ].  ^(RGMethodDefinition realClass: class selector: selector)     package: self package asRingDefinition;     yourselftestArcTan  self assert: ((100 arcTan: 100) closeTo: Float pi / 4).  self assert: ((-100 arcTan: 100) closeTo: Float pi / -4).  self assert: ((100 arcTan: -100) closeTo: Float pi * 3 / 4).  self assert: ((-100 arcTan: -100) closeTo: Float pi * -3 / 4).  self assert: ((0 arcTan: 100) closeTo: 0).  self assert: ((0 arcTan: -100) closeTo: Float pi).  self assert: ((100 arcTan: 0) closeTo: Float pi / 2).  self assert: ((-100 arcTan: 0) closeTo: Float pi / -2).  self assert: ((Float negativeZero arcTan: 100) closeTo: 0).  self assert: ((Float negativeZero arcTan: -100) closeTo: Float pi * -1).  self assert: (0 arcTan: 0) equals: 0.  self assert: (Float negativeZero arcTan: 0) equals: 0.  self assert: ((0 arcTan: Float negativeZero) closeTo: Float pi).  self assert: ((Float negativeZero arcTan: Float negativeZero) closeTo: Float pi negated)constructFibonacciBlockInDeadFrame  | fib |  fib := [:val |  val <= 0 ifTrue: [ self error: 'not a natural number' ].  val <= 2 ifTrue: [ 1 ] ifFalse: [ (fib value: val - 1) + (fib value: val - 2) ] ].  ^fibtestReadFrom  | string t |  string := '4:02:47 am'.  t := self timeClass readFrom: string readStream.  self assert: time printString equals: t printStringtestTruncated  self assert: (3 / 2) truncated equals: 1.  self assert: (-3 / 2) truncated equals: -1setUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  aDateAndTime := DateAndTime     localTimeZone: TimeZone default;     epoch.  aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'Epoch Test Time Zone' abbreviation: 'ETZ'.  aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5sizeStorePopTemp: tempIndex  ^self sizeOpcodeSelector: #genStorePopTemp: withArguments: {tempIndex}restartTimerEventLoop  self stopTimerEventLoop.  self startTimerEventLooptranslatedToBeWithin: aRectangle  ^self translateBy: (self amountToTranslateWithin: aRectangle)testNotSymmetricWithString  | t1 t2 |  t1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  t2 := '0001-01-02T02:03:04.000000005+06:00'.  self deny: t1 equals: t2.  self deny: t2 equals: t1testPrintOn  self assert: (String streamContents: [:str |  aDateAndTime printOn: str ]) equals: '1980-01-01T00:00:00+00:00'.  self assert: (String streamContents: [:str |  aTimeZone printOn: str ]) equals: 'a TimeZone(DTZ)'testIsCurrencySymbol  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isCurrencySymbol: ch) equals: (charset isCurrencySymbol: ch) ]testAsDate  self assert: aTimespan asDate equals: jan01 asDateasDuration  ^self durationtop: aNumber  ^origin x @ aNumber corner: cornerisZero  ^self = 0.0isEqualRegardlessTrailerTo: aCompiledMethod  ^(self copyWithTrailerBytes: CompiledMethodTrailer empty) = (aCompiledMethod copyWithTrailerBytes: CompiledMethodTrailer empty)jsonOn: aRenderer  self error: 'Override #jsonOn: to make the receiver serializeable as JSON'methodDictionary: aDictionary  self methodDict: aDictionaryincludesAllOf: aCollection  self deprecated: 'Please use #includesAll: instead' transformWith: '`@receiver includesAllOf: `@statements' -> '`@receiver includesAll: `@statements'.  ^self includesAll: aCollectiongtInspectorVariableNodesIn: aCollection  aCollection     add: (GTInspectorDynamicNode hostObject: self label: '1' value: (self at: 1));     add: (GTInspectorDynamicNode hostObject: self label: '2' value: (self at: 2))compileAllFrom: oldClass  oldClass localSelectors do: [:sel |  self recompile: sel from: oldClass ]waitWhile: aBlock for: aSymbolOrNil  ^self waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: nilvariableWordSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self variableWordSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: catbecomeUncompact  stonOn: stonWriter  stonWriter writeNulltestHandlingWithExclusion  | wasHandled |  wasHandled := false.  self should: [ [ ZeroDivide signalWithDividend: 1 ] on: Error - ZeroDivide do: [:exception |  wasHandled := true.              exception return ] ] raise: ZeroDivide.  self deny: wasHandledlog  ^DomainError signal: 'log is only defined for x > 0' from: 0testAsNanoSeconds  self assert: aTime asNanoSeconds equals: 45296000000000testNext  self assert: aTimespan next equals: (Timespan starting: (DateAndTime year: 2005 month: 3 day: 26 hour: 0 minute: 0 second: 0) duration: aDuration)value: firstArg  < primitive: 207>  | newContext |  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  false ifTrue: [ newContext := self asContextWithSender: thisContext sender.        newContext at: 1 put: firstArg.        thisContext privSender: newContext ] ifFalse: [ self primitiveFailed ]packageFromOrganizer: anRPackageOrganizer  | originSelector |  self flag: 'TODO: use anRPackageOrganizer, or better delegate to anRPackageOrganizer'.  originSelector := self originMethod selector.  ^self origin packages detect: [:each |  self origin isMeta ifFalse: [ each includesSelector: originSelector ofClassName: self origin instanceSide originalName ] ifTrue: [ each includesSelector: originSelector ofMetaclassName: self origin instanceSide originalName ] ] ifNone: [ nil ]printOn: aStream  self isSelfEvaluating ifFalse: [ ^super printOn: aStream ].  aStream nextPutAll: #Processorchanged: anAspect with: anObject  self dependents do: [:aDependent |  aDependent update: anAspect with: anObject ]testYearDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1980 day: 1 hour: 0 minute: 0 second: 0)swap: ix1 with: ix2  | minIx maxIx link1Prev link2Prev link1 link2 link1Next link2Next newLink2Next |  ((self validIndex: ix1) and: [ self validIndex: ix2 ]) ifFalse: [ ^self errorOutOfBounds ].  ix1 = ix2 ifTrue: [ ^self ].  minIx := ix1 min: ix2.  maxIx := ix2 max: ix1.  link1Prev := minIx = 1 ifFalse: [ self linkAt: minIx - 1 ].  link1 := link1Prev ifNotNil: [ link1Prev nextLink ] ifNil: [ self linkAt: minIx ].  link1Next := link1 nextLink.  link2Prev := self linkAt: maxIx - 1.  link2 := link2Prev nextLink.  link2Next := link2 nextLink.  link1 = firstLink ifTrue: [ firstLink := link2 ] ifFalse: [ link1Prev nextLink: link2 ].  link2 = lastLink ifTrue: [ lastLink := link1 ] ifFalse: [  ].  newLink2Next := link1 nextLink = link2 ifTrue: [ link1 ] ifFalse: [ link2Prev nextLink: link1.        link1Next ].  link1 nextLink: link2Next.  link2 nextLink: newLink2NextdoWhileTrue: conditionBlock  | result |  [ result := self value.  conditionBlock value ] whileTrue.  ^resultrFwithArgs: argArray executeMethod: compiledMethod  < disableReflectivity>  < primitive: 188>  self primitiveFailedspotterCompositionFor: aStep  < spotterOrder: 25>  aStep listProcessor     title: 'Composing traits';     allCandidates: [ self allTraits ];     itemIcon: #systemIcon;     filter: GTFilterSubstringisClosePunctuation  ^self characterSet isClosePunctuation: selfcodePoint  ^self asciiValuehasMetaLinks  self reflectiveMethod ifNil: [ ^false ].  ^self reflectiveMethod hasMetaLinksblockCreationBytecodeMessage  ^self method encoderClass blockCreationBytecodeMessageAt: startpc method: self methodaddDependent: ignored  self error: 'Nil should not have dependents'secondByte  ^self method at: pc + 1someObject  < primitive: 138>  self primitiveFailedparseYear  self isFourDigitYearPattern ifTrue: [ ^self parseFourDigitYear ].  self isTwoDigitYearPattern ifTrue: [ ^self parseTwoDigitYear ].  self parseVariableDigitYearerrorSubscriptBounds: index  SubscriptOutOfBounds signalFor: indextestUnionWithOverlapping  self assert: (aTimespan union: anOverlappingTimespan) equals: (Timespan starting: dec31 duration: 8 days)sizeSendSuper: selectorLiteralIndex numArgs: nArgs  ^self sizeOpcodeSelector: #genSendSuper:numArgs: withArguments: {selectorLiteralIndex .         nArgs}testWeekPrintOn  | aWeek cs rw |  aWeek := Week starting: (DateAndTime year: 1900 month: 12 day: 31).  cs := 'a Week starting: 1900-12-30T00:00:00+00:00'.  rw := String new writeStream.  aWeek printOn: rw.  self assert: rw contents equals: cstestSecondsNanoSeconds  self assert: (Duration seconds: 0 nanoSeconds: 5) equals: (Duration nanoSeconds: 5).  self assert: (aDuration seconds: 0 nanoSeconds: 1) equals: (Duration nanoSeconds: 1)selector  ^selectordecodeSourcePointer  | msz |  size := 4.  msz := method size.  data := ((((method at: msz) - 251 << 8) + (method at: msz - 1) << 8) + (method at: msz - 2) << 8) + (method at: msz - 3)includesSelector: selector  ^protocols anySatisfy: [:each |  each includesSelector: selector ]testStart  self assert: aTimespan start equals: jan01.  aTimespan start: jan08.  self assert: aTimespan start equals: jan08methodNode  ^self subclassResponsibilityon: exception fork: handlerAction return: answerAction  ^self on: exception do: [:ex |  | onDoCtx handler bottom thisCtx |        onDoCtx := thisContext.        thisCtx := onDoCtx home.        [ onDoCtx sender == thisCtx ] whileFalse: [ onDoCtx := onDoCtx sender.              onDoCtx ifNil: [ ^handlerAction cull: ex ] ].        bottom := [ Processor terminateActive ] asContext.        onDoCtx privSender: bottom.        handler := [ handlerAction cull: ex ] asContext.        handler privSender: thisContext sender.        (Process forContext: handler priority: Processor activePriority) resume.        thisContext privSender: thisCtx.        answerAction cull: exception ]renameCategory: oldName toBe: newName  self silentlyRenameCategory: oldName toBe: newName.  self notifyOfChangedCategoryFrom: oldName to: newName.  (self protocolOrganizer protocolNamed: newName) methodSelectors do: [:each |  self notifyOfChangedSelector: each from: oldName to: newName ]sqrt  | selfAsFloat |  self mightBeASquare ifFalse: [ selfAsFloat := self asFloat.        selfAsFloat isFinite ifTrue: [ ^self asFloat sqrt ] ].  ^super sqrtwriteX  x := 33stepToCallee  Processor activeProcess evaluate: [ | ctxt |        ctxt := suspendedContext.        [ ctxt == suspendedContext ] whileTrue: [ suspendedContext := suspendedContext step ] ] onBehalfOf: self.  ^suspendedContextsymbolic  ^self longPrintStringtestWeeksDo  | weeks weekArray |  weeks := aTimespan weeks.  self assert: weeks size equals: (aDuration days / 7.0) ceiling + 1.  weekArray := OrderedCollection new.  weekArray     addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 19) duration: 7 days);     addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 26) duration: 7 days).  2 to: 79 by: 7 do: [:i |  weekArray addLast: (Week starting: (DateAndTime year: 2005 day: i) duration: 7 days) ].  weekArray := weekArray asArray.  self assert: aTimespan weeks equals: weekArraysimpleEnsureTestWithUparrow  [ self doSomething.  true ifTrue: [ ^nil ].  self doSomethingElse ] ensure: [ self doYetAnotherThing ]testBetweenAndDoIncludedInSchedule  | count |  count := 0.  aSchedule between: (DateAndTime year: 2003 month: 4 day: 1) and: (DateAndTime year: 2003 month: 4 day: 30) do: [:each |  count := count + 1 ].  self assert: count equals: 8checkClass: aClass  (self basicCheckClass: aClass) ifNotEmpty: [:warnings |  Warning new           messageText: 'VeryDeepCopy out of sync in some classes. Some classes contain veryDeepCopyWith: or veryDeepInner: methods that are not in sync with their instance variables. Check the exception #tag for a list of them';           tag: warnings;           signal ]testLiteralsDoesNotContainMethodClass  self deny: (self compiledMethod1 hasLiteralThorough: (self class environment associationAt: self class name asSymbol))printDate: aDate format: formatArray on: aStream  | day month year twoDigits element monthFormat |  aDate dayMonthYearDo: [:d :m :y |  day := d.        month := m.        year := y ].  twoDigits := formatArray size > 6 and: [ (formatArray at: 7) > 1 ].  1 to: 3 do: [:i |  element := formatArray at: i.        element = 1 ifTrue: [ twoDigits ifTrue: [ day printOn: aStream base: 10 length: 2 padded: true ] ifFalse: [ day printOn: aStream ] ].        element = 2 ifTrue: [ monthFormat := formatArray at: 5.              monthFormat = 1 ifTrue: [ twoDigits ifTrue: [ month printOn: aStream base: 10 length: 2 padded: true ] ifFalse: [ month printOn: aStream ] ].              monthFormat = 2 ifTrue: [ (Month nameOfMonth: month) from: 1 to: 3 do: [:each |  aStream nextPut: each ] ].              monthFormat = 3 ifTrue: [ aStream nextPutAll: (Month nameOfMonth: month) ] ].        element = 3 ifTrue: [ (formatArray at: 6) = 1 ifTrue: [ year printOn: aStream base: 10 length: 4 padded: true ] ifFalse: [ year \\ 100 printOn: aStream base: 10 length: 2 padded: true ] ].        i < 3 ifTrue: [ (formatArray at: 4) ~= 0 ifTrue: [ aStream nextPut: (formatArray at: 4) asCharacter ] ] ]humanReadablePrintString  ^String streamContents: [:out |  self printHumanReadableOn: out ]drTestsBrowse  Smalltalk tools browser openOnClass: self methodClass selector: self selectortestCeiling  self assert: (3 / 2) ceiling equals: 2.  self assert: (-3 / 2) ceiling equals: -1shutDown  versionString  ^versionString ifNil: [ 'unknown' ]asHexDigit  ^'0123456789ABCDEF' at: self + 1genPushInstVarLong: instVarIndex  (instVarIndex < 0 or: [ instVarIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535 ].  instVarIndex > 255 ifTrue: [ self genUnsignedSingleExtendA: instVarIndex // 256 ].  stream     nextPut: 226;     nextPut: instVarIndex \\ 256valueWithArguments: anArray  ^receiver perform: selector withArguments: (self collectArguments: anArray)basicSize  < primitive: 212>  ^self primitiveFailsourceNodeExecutedForPC: aPC  | blockNode |  blockNode := self outerCode sourceNodeExecutedForPC: self pcInOuter.  ^blockNode sourceNodeExecutedForPC: aPCtestBecomeForward  | pt1 pt2 pt3 |  pt1 := 0 @ 0.  pt2 := pt1.  pt3 := 100 @ 100.  pt1 becomeForward: pt3.  self assert: pt2 equals: 100 @ 100.  self assert: pt3 identicalTo: pt2.  self assert: pt1 equals: 100 @ 100outerMostContext  ^self outerContext ifNil: [ self ] ifNotNil: [ self outerContext ]testDuration  self assert: aTime duration equals: 0 secondstestSetIsReadOnlyFailure  self alwaysWritableObjects do: [:each |  self testObject: each initialState: false tuples: #(#(true false false) #(false false false)) ]taskbarIcon  ^self class taskbarIconhandles: exception  ^(super handles: exception) and: [ exclusions noneSatisfy: [:each |  each handles: exception ] ]includesAny: aCollection  ^aCollection anySatisfy: [:elem |  self includes: elem ]isDigit  ^self characterSet isDigit: selfgtInspectorDetailsIn: composite  < gtInspectorPresentationOrder: 30>  ^composite table     title: 'Details';     display: [ {('human readable' -> self humanReadablePrintString) .         ('days' -> self days) .         ('hours' -> self hours) .         ('minutes' -> self minutes) .         ('seconds' -> self seconds) .         ('nanoseconds' -> self nanoSeconds)} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valuelogTest: aSelector  self suiteLog add: aSelectorprintPaddedWith: aCharacter to: anInteger base: aRadix  | aStream padding digits |  aStream := (String new: 10) writeStream.  self printOn: aStream base: aRadix showRadix: false.  digits := aStream contents.  padding := anInteger - digits size.  padding > 0 ifFalse: [ ^digits ].  ^((String new: padding)     atAllPut: aCharacter;     yourself) , digitsselectorsToBeIgnored  | deprecated private special |  deprecated := #().  private := #(#printOn:).  special := #(#next).  ^super selectorsToBeIgnored , deprecated , private , specialassociationsDo: aBlock  tally = 0 ifTrue: [ ^self ].  1 to: self basicSize do: [:i |  (self basicAt: i) ifNotNil: [:key |  aBlock value: (Association key: key value: (array at: i)) ] ]traitSource  ^self propertyAt: #traitSourceisSurrogateOther  ^self characterSet isSurrogateOther: selfvalueNoContextSwitch: anArg  < primitive: 222>  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  self primitiveFailedtestNameOfDay  | days |  days := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).  days withIndexDo: [:item :index |  self assert: (Week nameOfDay: index) equals: item ].  self should: [ Week nameOfDay: 0 ] raise: self defaultTestError.  self should: [ Week nameOfDay: 8 ] raise: self defaultTestError.  self should: [ Week nameOfDay: #Sunday ] raise: self defaultTestErrortestMinutes  self assert: aDateAndTime minutes equals: 33comment: aStringOrText  self instanceSide classComment: aStringOrTexttestMixedMethod  | result |  self should: [ result := self mixedMethod ] notTakeMoreThanMilliseconds: 3.  self assert: result equals: 2reciprocal  ^1.0 / selfmethodSelectors  ^self protocolOrganizer allMethodSelectorsfileOutOn: aFileStream  ^self fileOutOn: aFileStream initializing: truebottom  ^bottomwhileNil: aBlock  ^[ self value isNil ] whileTrue: [ aBlock value ]blockReturnTop  [ closureOrNil isClosure ] assert.  ^self return: self pop from: selficonNamed: aSymbol  ^Smalltalk ui icons iconNamed: aSymbolto: anEnd by: aDuration do: aBlock  ^(self to: anEnd by: aDuration) scheduleDo: aBlockroundTo: grid  | gridPoint |  gridPoint := grid asPoint.  ^(x roundTo: gridPoint x) @ (y roundTo: gridPoint y)testNegative  self deny: aDuration negative.  self assert: aDuration negated negativetestExample1  self assert: (self example1: 5) equals: 5 factorialauthors  ^self methods , self classSide methods collect: [:each |  each author ] as: BaglinkAt: index ifAbsent: errorBlock  | i |  i := 0.  self linksDo: [:link |  (i := i + 1) = index ifTrue: [ ^link ] ].  ^errorBlock valuereadsField: varIndex  | varIndexCode scanner |  varIndexCode := varIndex - 1.  ((scanner := InstructionStream on: self) scanFor: (self encoderClass instVarReadScanBlockFor: varIndexCode using: scanner)) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:cb |  cb readsField: varIndex ]asFloat  ^selfprintOn: aStream  aStream nextPutAll: 'nil'genPop  stream nextPut: 216usesSecondaryBytecodeSet  ^self header < 0boundingBox  ^selfstonOn: stonWriter  stonWriter writeObject: self listSingleton: (String streamContents: [:stream |  self print24: true showSeconds: true on: stream ])addClassVariable: aGlobal  | symbol oldState |  oldState := self copyForAnnouncement.  symbol := aGlobal name asSymbol.  self withAllSubclasses do: [:subclass |  (subclass bindingOf: symbol) ifNotNil: [ ^self error: symbol asString , ' is already used as a variable name in class ' , subclass name ] ].  (self classPool includesKey: symbol) ifFalse: [ self classPool declareVariable: aGlobal from: Undeclared.        SystemAnnouncer uniqueInstance           classDefinitionChangedFrom: oldState to: self;           classModificationAppliedTo: self ]encodeLengthField: integer  | bytes value |  [ integer > 0 ] assert.  value := integer.  bytes := ByteArray streamContents: [:str |  [ value > 0 ] whileTrue: [ str nextPut: (value bitAnd: 255).              value := value >> 8 ] ].  [ bytes size <= 4 ] assert.  ^bytesreturnTrue  ^trueabsPrintInexactlyOn: aStream base: base  | significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |  self isInfinite ifTrue: [ aStream nextPutAll: 'Float infinity'.        ^self ].  significantBits := 50.  fBase := base asFloat.  exp := self exponent.  baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.  exp >= 0 ifTrue: [ r := self.        s := 1.0.        mPlus := 1.0 timesTwoPower: exp - significantBits.        mMinus := self significand ~= 1.0 ifTrue: [ mPlus ] ifFalse: [ mPlus / 2.0 ] ] ifFalse: [ r := self timesTwoPower: significantBits.        s := 1.0 timesTwoPower: significantBits.        mMinus := 1.0 timesTwoPower: (exp max: -1024).        mPlus := exp = MinValLogBase2 | (self significand ~= 1.0) ifTrue: [ mMinus ] ifFalse: [ mMinus * 2.0 ] ].  baseExpEstimate >= 0 ifTrue: [ s := s * (fBase raisedToInteger: baseExpEstimate).        exp = 1023 ifTrue: [ r := r / fBase.              s := s / fBase.              mPlus := mPlus / fBase.              mMinus := mMinus / fBase ] ] ifFalse: [ exp < -1023 ifTrue: [ d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.              scale := fBase raisedToInteger: d.              r := r * scale.              mPlus := mPlus * scale.              mMinus := mMinus * scale.              scale := fBase raisedToInteger: (baseExpEstimate + d) negated ] ifFalse: [ scale := fBase raisedToInteger: baseExpEstimate negated ].        s := s / scale ].  r + mPlus >= s ifTrue: [ baseExpEstimate := baseExpEstimate + 1 ] ifFalse: [ s := s / fBase ].  (fixedFormat := baseExpEstimate between: -3 and: 6) ifTrue: [ decPointCount := baseExpEstimate.        baseExpEstimate <= 0 ifTrue: [ aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate) ] ] ifFalse: [ decPointCount := 1 ].  [ d := (r / s) truncated.  r := r - (d * s).  (tc1 := r <= mMinus) | (tc2 := r + mPlus >= s) ] whileFalse: [ aStream nextPut: (Character digitValue: d).        r := r * fBase.        mPlus := mPlus * fBase.        mMinus := mMinus * fBase.        decPointCount := decPointCount - 1.        decPointCount = 0 ifTrue: [ aStream nextPut: $. ] ].  tc2 ifTrue: [ tc1 not | (tc1 & (r * 2.0 >= s)) ifTrue: [ d := d + 1 ] ].  aStream nextPut: (Character digitValue: d).  decPointCount > 0 ifTrue: [ decPointCount - 1 to: 1 by: -1 do: [:i |  aStream nextPut: $0 ].        aStream nextPutAll: '.0' ].  fixedFormat ifFalse: [ aStream nextPut: $e.        aStream nextPutAll: (baseExpEstimate - 1) printString ]testIfFalse  self assert: (true ifFalse: [ 'alternativeBlock' ]) isNilisBlock  ^truenewAnonymousSubclass  ^self instanceSide newAnonymousSubclass classsizeStorePopInstVar: instVarIndex  ^self sizeOpcodeSelector: #genStorePopInstVar: withArguments: {instVarIndex}error: aString  ^Error new signal: aStringstonOn: stonWriter  stonWriter writeObject: self listSingleton: (String streamContents: [:stream |  self printOn: stream withLeadingSpace: false ])middleOf: aDuration  | duration |  duration := aDuration asDuration.  ^Timespan starting: self - (duration / 2) duration: durationtestAccessing  self     assert: june2nd1973 day equals: 153;     assert: june2nd1973 julianDayNumber equals: 2441836;     assert: june2nd1973 monthIndex equals: 6;     assert: june2nd1973 monthName equals: #June;     assert: june2nd1973 weekday equals: #Saturday;     assert: june2nd1973 weekdayIndex equals: 7;     assert: june2nd1973 year equals: 1973remove: anObj uptoLastValueLink: aValueLink continuation: skip  ^aValueLink ifNotNil: [ | car cdr |        car := aValueLink value.        cdr := self remove: anObj uptoLastValueLink: aValueLink nextLink continuation: skip.        anObj = car ifTrue: [ skip value: cdr ] ifFalse: [ car ~~> cdr ] ]addInstVarNamed: aString  | fullString |  fullString := String streamContents: [:strm |  self instVarNames do: [:aString2 |  strm                 nextPutAll: aString2;                 space ].        strm nextPutAll: aString ].  self instanceVariableNames: fullStringasRingDefinition  ^selfisSpacingCombiningMark  ^self characterSet isSpacingCombiningMark: selftestStoppedSchedulerExpiresRemainingDelays  | delay1 delay2 delay3 |  delay1 := Delay new setDelay: 9 forSemaphore: Semaphore new.  delay2 := Delay new setDelay: 99 forSemaphore: Semaphore new.  delay3 := Delay new setDelay: 999 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  scheduler schedule: delay1.  scheduler schedule: delay2.  scheduler schedule: delay3.  self assert: delay2 beingWaitedOn.  self assert: delay1 beingWaitedOn.  self assert: delay3 beingWaitedOn.  scheduler simulate_vmMilliseconds: 25.  self assert: delay1 isExpired.  self deny: delay2 isExpired.  self deny: delay3 isExpired.  scheduler stopTimerEventLoop.  self assert: delay2 isExpired.  self assert: delay3 isExpiredpositive  ^trueclear  kind := #NoTrailer.  size := 4.  data := encodedData := method := nilgetPreambleFrom: aFileStream at: position  ^SourceFiles getPreambleFrom: aFileStream at: positionexception  ^exceptionaddAllMethodsFrom: aProtocol  aProtocol methodSelectors do: [:each |  self addMethodSelector: each ]defaultLabel  ^super defaultLabel , ': ' , self printStringinnerBindingOf: varName  ^self instanceSide innerBindingOf: varNameremoveSubclass: aClass  shiftLevelUp  < metaLinkOptions: #(+ optionDisabledLink)>  level ifNil: [ level := 0 ].  level := level rfPlus: 1testDateTimeDenotation1  | twoPmInLondon twoPmUTCInLocalTimeOfDetroit nineAmInDetroit |  twoPmInLondon := DateAndTime year: 2004 month: 11 day: 2 hour: 14 minute: 0 second: 0 offset: 0 hours.  twoPmUTCInLocalTimeOfDetroit := twoPmInLondon offset: -5 hours.  nineAmInDetroit := '2004-11-02T09:00:00-05:00' asDateAndTime.  self assert: twoPmUTCInLocalTimeOfDetroit equals: nineAmInDetroitisNotNil  ^falseprintMinutes  ^String new: 8 streamContents: [:aStream |  self print24: false showSeconds: false on: aStream ]testAsStringWithCommas  self assert: 123456789 asStringWithCommas equals: '123,456,789'.  self assert: -123456789 asStringWithCommas equals: '-123,456,789'insetBy: delta  ^delta asMargin insetRectangle: selfpsValueAt: index  env ifNil: [ ^nil ].  ^env at: index ifAbsent: niltestBitShift  1 to: 257 do: [:i |  self should: [ ((i bitShift: i) bitShift: 0 - i) == i ] ]isTwoDigitDayPattern  ^patternStream peekFor: $dtearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  super tearDowninitializeWith: aPc stackPtr: aStackPtr method: aMethod receiver: aReceiver sender: aSender  pc := aPc.  stackp := aStackPtr.  method := aMethod.  receiver := aReceiver.  sender := aSenderbasicIdentityHash  < primitive: 175>  self primitiveFailedprintString  ^String streamContents: [:str |  self printOn: str base: 10 ]printDateAndTime: aDateTime withLeadingSpace: printLeadingSpaceToo on: aStream  self printYMD: aDateTime withLeadingSpace: printLeadingSpaceToo on: aStream.  aStream nextPut: $T.  self printHMS: aDateTime separatedBy: $: on: aStream.  aDateTime nanoSecond ~= 0 ifTrue: [ | n len |        n := aDateTime nanoSecond.        len := 9.        [ n \\ 10 = 0 ] whileTrue: [ n := n / 10.              len := len - 1 ].        aStream nextPut: $..        n printOn: aStream base: 10 length: len padded: true ].  aStream nextPut: (aDateTime offset positive ifTrue: [ $+ ] ifFalse: [ $- ]).  aDateTime offset hours abs printOn: aStream base: 10 length: 2 padded: true.  aStream nextPut: $:.  aDateTime offset minutes abs printOn: aStream base: 10 length: 2 padded: true.  aDateTime offset seconds = 0 ifFalse: [ aStream           nextPut: $:;           print: aDateTime offset seconds abs truncated ]untagFrom: aSymbol  | package packageTag |  package := self package.  packageTag := package classTagForClass: self.  packageTag ifNil: [ ^#() ].  packageTag isRoot ifTrue: [ ^#() ].  packageTag name = aSymbol ifFalse: [ ^self ].  packageTag removeClass: self.  package addClass: selftestHugeIntegerCloseTo  self deny: (1.0 closeTo: 200 factorial).  self deny: (200 factorial closeTo: 1.0).  self assert: (Float infinity closeTo: 200 factorial) equals: (200 factorial closeTo: Float infinity)withMethodsReferTo: aLiteral do: aBlock  | specialIndex |  specialIndex := Smalltalk specialSelectorIndexOrNil: aLiteral.  self selectorsAndMethodsDo: [:selector :method |  ((method hasLiteral: aLiteral) or: [ specialIndex notNil and: [ method scanFor: method encoderClass firstSpecialSelectorByte + specialIndex ] ]) ifTrue: [ aBlock value: method ] ]copy  ^selfpropertyAt: propName ifAbsent: aBlock  | propertiesOrSelector |  ^(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifTrue: [ propertiesOrSelector propertyAt: propName ifAbsent: aBlock ] ifFalse: [ aBlock value ]mcWorkingCopy  MCWorkingCopy managersForClass: self methodClass selector: self selector do: [:package |  ^package ]asDraggableMorph  ^self asStringMorphclassPool  ^classPool ifNil: [ classPool := Dictionary new ]testTo  self assert: (aDateAndTime to: aDateAndTime) equals: ((DateAndTime year: 1980 month: 1 day: 1) to: (DateAndTime year: 1980 month: 1 day: 1))classify: element under: heading  self classify: element under: heading suppressIfDefault: true<= aNumber  aNumber class = self class ifTrue: [ ^self asFraction <= aNumber asFraction ].  ^self asFraction <= aNumberhasLiteralSuchThat: testBlock  ^falsecalypsoEnvironmentType  ^ClyClasstestYesterday  self deny: aDateAndTime equals: DateAndTime yesterdayobject  ^objecttestPrintString  self assert: Object new printString equals: 'an Object'return  self return: self receiverisValid  ^trueprintOn: aStream  aStream nextPutAll: ((self method hasSourceCode or: [ self class environment includesKey: #FBDDecompiler ]) ifTrue: [ self sourceNode formattedCode ] ifFalse: [ 'aBlockClosure(no source code or decompiler available)' ])breakDependents  self myDependents: nilasWeek  ^self asDateAndTime asWeekschedule: aDelay  aDelay beingWaitedOn ifTrue: [ ^self error: 'This Delay has already been scheduled.' ].  readyToSchedule wait.  delayToStart := aDelay.  timingSemaphore signalisPowerOfTwo  ^numerator = 1 and: [ denominator isPowerOfTwo ]subtractDate: aDate  ^(self start - aDate asDateAndTime) daystest32bitGradualUnderflow  | conv expected exponentPart |  conv := 2r0.11111111111111111111111e-126 asIEEE32BitWord.  exponentPart := 0.  expected := exponentPart bitOr: 2r11111111111111111111111.  self assert: expected equals: conv.  conv := 2r0.00000000000000000000001e-126 asIEEE32BitWord.  expected := exponentPart bitOr: 2r1.  self assert: expected equals: conv.  conv := 2r0.000000000000000000000011e-126 asIEEE32BitWord.  expected := exponentPart bitOr: 2r10.  self assert: expected equals: conv.  conv := 2r0.000000000000000000000101e-126 asIEEE32BitWord.  expected := exponentPart bitOr: 2r10.  self assert: expected equals: conv.  conv := 2r0.0000000000000000000001011e-126 asIEEE32BitWord.  expected := exponentPart bitOr: 2r11.  self assert: expected equals: convcrTrace: aString  Transcript cr.  self trace: aStringgrowto: n  ^self copyto: (self species new: n)push: value  self stackp: stackp + 1.  self at: stackp put: valuetestReadFromNoOffset  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321' readStream) offset equals: DateAndTime localOffsetisCurrencySymbol  ^self characterSet isCurrencySymbol: selfpreviousPcWithCorrectMapping  | neighborPC |  neighborPC := self isDead ifTrue: [ self startpc ] ifFalse: [ self previousPc ifNil: [ self startpc ] ].  [ self isPushLiteralNil: neighborPC ] whileTrue: [ neighborPC := neighborPC + 1 ].  [ self isPushTemp: neighborPC ] whileTrue: [ neighborPC := neighborPC + 1 ].  (self isBlockReturn: neighborPC) ifTrue: [ neighborPC := neighborPC - 1 ].  ^neighborPCrunSimulated: aBlock contextAtEachStep: block2  | current returnContext exception |  aBlock hasMethodReturn ifTrue: [ self error: 'simulation of blocks with ^ can run loose' ].  current := [ aBlock on: Exception do: [:ex |  SimulationExceptionWrapper signalForException: ex ] ] asContext.  returnContext := Context sender: nil receiver: self home receiver method: self home method arguments: self home arguments.  current pushArgs: Array new from: returnContext.  [ current == returnContext ] whileFalse: [ block2 value: current.        current := current step ].  exception := returnContext pop.  exception class == SimulationExceptionWrapper ifTrue: [ ^exception exception signal ].  ^exceptionlowIOPriority  ^LowIOPrioritynonResumableFallOffTheEndHandlerResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingExceptionalString;     add: self doYetAnotherThingString;     yourselftestPharoEpoch  self useNonUtcTimeZoneDuring: [ | localEpoch |        localEpoch := '1901-01-01T00:00:00' asDateAndTime.        self deny: DateAndTime epoch equals: localEpoch.        self deny: ((DateAndTime fromSeconds: 0) offset: 0) equals: localEpoch ].  self useTimeZone: 'UTC' during: [ | localEpoch |        localEpoch := '1901-01-01T00:00:00' asDateAndTime.        self assert: DateAndTime epoch equals: localEpoch.        self assert: ((DateAndTime fromSeconds: 0) offset: 0) equals: localEpoch ].  self assert: DateAndTime epoch equals: '1901-01-01T00:00:00+00:00' asDateAndTime.  self assert: ((DateAndTime fromSeconds: 0) offset: 0) equals: '1901-01-01T00:00:00+00:00' asDateAndTimecontextTag  ^selfisCompiledBlock  ^trueduration  ^Duration zeroprintStringPadded: minimal  ^self printStringLength: minimal padded: truetestSecondsSinceMidnightLocalTime  | dateAndTime |  dateAndTime := DateAndTime year: 1000 day: 100 hour: 0 minute: 0 second: 56 offset: 0 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 56.  dateAndTime := DateAndTime year: 1000 day: 100 hour: 0 minute: 1 second: 56 offset: 0 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 60 + 56.  dateAndTime := DateAndTime year: 1000 day: 100 hour: 1 minute: 0 second: 56 offset: 0 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 3600 + 56.  dateAndTime := DateAndTime year: 1000 day: 100 hour: 0 minute: 0 second: 56 offset: 1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 56.  dateAndTime := DateAndTime year: 1000 day: 100 hour: 0 minute: 1 second: 56 offset: 1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 60 + 56.  dateAndTime := DateAndTime year: 1000 day: 100 hour: 1 minute: 0 second: 56 offset: 1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 3600 + 56.  dateAndTime := DateAndTime year: 1000 day: 100 hour: 0 minute: 0 second: 56 offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 56.  dateAndTime := DateAndTime year: 1001 day: 101 hour: 0 minute: 1 second: 56 offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 60 + 56.  dateAndTime := DateAndTime year: 1002 day: 102 hour: 1 minute: 0 second: 56 offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 3600 + 56initialize  default := ExactFloatPrintPolicy newastForStylingInCalypso  ^self aststringForFileOut  ^self protocolOrganizer stringForFileOuttestToday  self deny: aDateAndTime equals: DateAndTime todayextendingPackages  ^RPackage organizer extendingPackagesOf: selfseasideUrl  ^selfmethodDict  ^methodDict ifNil: [ MethodDictionary new ]isOpenPunctuation  ^self characterSet isOpenPunctuation: selftestMinutes  self assert: aDateAndTime minutes equals: 0testNaNisLiteral  self deny: Float nan isLiteral description: 'there is no literal representation of NaN'failPrimitiveWith: maybePrimFailToken  self skipCallPrimitive.  ((self isPrimFailToken: maybePrimFailToken) and: [ method encoderClass isStoreAt: pc in: method ]) ifTrue: [ self at: stackp put: maybePrimFailToken last ]testNameOfDay  | dayNames firstDayName |  firstDayName := self dateClass nameOfDay: 1.  self assert: firstDayName equals: #Sunday.  dayNames := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).  (1 to: 7) do: [:i |  | dayName |        dayName := self dateClass nameOfDay: i.        self assert: dayName equals: (dayNames at: i) ]testLessThan  self assert: aDateAndTime < (aDateAndTime + '1:00:00:00').  self assert: aDateAndTime + -1 < aDateAndTimegenPushRemoteTemp: tempIndex inVectorAt: tempVectorIndex  (tempIndex >= 0 and: [ tempIndex < 256 and: [ tempVectorIndex >= 0 and: [ tempVectorIndex < 256 ] ] ]) ifTrue: [ stream           nextPut: 140;           nextPut: tempIndex;           nextPut: tempVectorIndex.        ^self ].  tempIndex >= 256 ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255 ].  tempVectorIndex >= 256 ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255 ]notifyOfAddedCategory: protocolName  self hasSubject ifFalse: [ ^self ].  SystemAnnouncer uniqueInstance protocolAdded: protocolName inClass: self subjecttestNewProcessWith  | hasBlockRun block process passedArguments receivedArgument1 receivedArgument2 |  hasBlockRun := false.  block := [:a :b |  receivedArgument1 := a.  receivedArgument2 := b.  hasBlockRun := true ].  passedArguments := #(1 2).  process := block newProcessWith: passedArguments.  self deny: hasBlockRun.  self assert: (process isKindOf: Process).  self assert: process isSuspended.  process resume.  [ process isTerminated ] whileFalse: [ Processor yield ].  self assert: {receivedArgument1 .         receivedArgument2} equals: passedArgumentstestInclusion  | t1 t2 t3 t4 |  t1 := timespan start.  t2 := timespan start + (timespan duration / 2).  t3 := timespan end.  t4 := timespan start + timespan duration.  self     assert: (timespan includes: t1);     assert: (timespan includes: t2);     assert: (timespan includes: t3)numberOfReservedLiterals  ^2signal: signalerText  self messageText: signalerText.  ^self signalhigh16Bits  ^value >> 16simpleResignalAsTest  [ self doSomething.  MyTestNotification signal.  self doSomethingElse ] on: MyTestNotification do: [:ex |  ex resignalAs: MyTestError new ]setTimestampInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setTimestampWithString: self printStringterminate  | ctxt unwindBlock oldList |  terminating := self isTerminating ifTrue: [ ^ProcessAlreadyTerminating signal ] ifFalse: [ true ].  self isActiveProcess ifTrue: [ ctxt := thisContext.        [ ctxt := ctxt findNextUnwindContextUpTo: nil.        ctxt isNil ] whileFalse: [ (ctxt tempAt: 2) ifNil: [ ctxt tempAt: 2 put: nil.                    unwindBlock := ctxt tempAt: 1.                    thisContext terminateTo: ctxt.                    unwindBlock value ] ].        thisContext terminateTo: nil.        self suspend ] ifFalse: [ oldList := self suspend.        suspendedContext ifNotNil: [ suspendedContext := oldList handleProcessTerminationOfWaitingContext: suspendedContext.              (suspendedContext findNextUnwindContextUpTo: nil) ifNotNil: [:outer |  (suspendedContext findContextSuchThat: [:c |  c closure == (outer tempAt: 1) ]) ifNotNil: [:inner |  suspendedContext runUntilErrorOrReturnFrom: inner ] ].              ctxt := self popTo: suspendedContext bottomContext.              [ ctxt == suspendedContext bottomContext ] whileFalse: [ | stackCopy |                    stackCopy := ctxt copyStack.                    [ UnwindError signalIn: stackCopy ] forkNamed: 'Unwind error during termination'.                    ctxt terminateTo: ctxt sender.                    ctxt := self popTo: suspendedContext bottomContext ].              (suspendedContext notNil and: [ suspendedContext isBottomContext ]) ifTrue: [ suspendedContext pc: nil ] ] ]testArray  self assertCode: '#(1 2 3)' print: '#(1 2 3)'.  self assertCode: '{1 . 2 . 3}' print: '#(1 2 3)'.  self assertCode: '{1 + 0 . 2 . 3}' print: '#(1 2 3)'.  self assertCode: '{1 + 0 . 1 @ 2 . 3}' print: '{1. (1@2). 3}'.  self assertCode: '{2@3}' print: '{(2@3)}'.  self assertCode: '{Object new}' print: 'an Array(an Object)'.  self assertCode: '{Rectangle new . Object new}' print: 'an Array(nil corner: nil an Object)'.  self assertCode: '{10@10 corner: 20@20 . 100@100 corner: 200@200}' print: '{(10@10) corner: (20@20). (100@100) corner: (200@200)}'decompile  ^Smalltalk globals at: #FBDDecompiler ifPresent: [:decompiler |  decompiler new decompile: self ] ifAbsent: [ RBParser parseMethod: self selector asMethodPreamble , '	self noSourceAvailable' ]classDepth  self superclass ifNil: [ ^1 ].  ^self superclass classDepth + 1testIsFormatOther  self checkCorrespondanceOf: #isFormatOther: and: #CfisMethodProperties  ^trueprint: anObject on: aStream  aStream nextPut: selftestSimpleRetry  self assertSuccess: (ExceptionTester new runTest: #simpleRetryTest)isMethodProperties  ^falsetestAsNanoSeconds  self assert: aDateAndTime asNanoSeconds equals: aDuration asNanoSeconds.  self assert: aDateAndTime asNanoSeconds equals: 48780000000000sizePushRemoteTemp: tempIndex inVectorAt: tempVectorIndex  ^self sizeOpcodeSelector: #genPushRemoteTemp:inVectorAt: withArguments: {tempIndex .         tempVectorIndex}testCannotReturn  | blk |  blk := self constructCannotReturnBlockInDeadFrame.  self should: [ blk value: 1 ] raise: ExceptionparseMonth  self isTwoDigitMonthPattern ifTrue: [ ^self parseTwoDigitMonth ].  self parseVariableDigitMonthtraversableInstVarIndexes  ^1 to: self class instSizeprintOn: aStream  self print24: false showSeconds: (self seconds ~= 0 or: [ self nanoSecond ~= 0 ]) on: aStreamlongPrintStringLimitedTo: aLimitValue  | str |  str := String streamContents: [:aStream |  self longPrintOn: aStream limitedTo: aLimitValue indent: 0 ].  ^str isEmpty ifTrue: [ self printString , String cr ] ifFalse: [ str ]testToday  self deny: aDateAndTime equals: DateAndTime todayremoveActionsWithReceiver: anObject forEvent: anEventSelector  self removeActionsSatisfying: [:anAction |  anAction receiver == anObject ] forEvent: anEventSelectorperform: aSymbol with: firstObject with: secondObject with: thirdObject  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: aSymbol withArguments: {firstObject .         secondObject .         thirdObject}clone  < primitive: 148 error: ec>  | class newObject |  ec == #'insufficient object memory' ifFalse: [ ^self primitiveFailed ].  newObject := (class := self class) isVariable ifTrue: [ class isCompiledMethodClass ifTrue: [ class newMethod: self basicSize - self initialPC + 1 header: self header ] ifFalse: [ class basicNew: self basicSize ] ] ifFalse: [ class basicNew ].  ^newObject copyFrom: selfclassToBeTested  ^self timeClassisTestMethod  self numArgs isZero ifFalse: [ ^false ].  ((self selector beginsWith: 'test') or: [ self selector beginsWith: 'should' ]) ifFalse: [ ^false ].  self methodClass isTestCase ifFalse: [ ^false ].  ^truetestallMethodsReadingSlot  | methods |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  methods := LookupKey allMethodsReadingSlot: (LookupKey slotNamed: #key).  self assert: (methods includes: Ephemeron >> #mourn)testLessThan  self assert: aDateAndTime < (aDateAndTime + '1:00:00:00').  self assert: aDateAndTime + -1 < aDateAndTimepragmas  | pragmaStream |  pragmaStream := WriteStream on: (Array new: self basicSize).  1 to: self basicSize do: [:i |  | propertyOrPragma |        (propertyOrPragma := self basicAt: i) isVariableBinding ifFalse: [ pragmaStream nextPut: propertyOrPragma ] ].  ^pragmaStream contentsgenJump: distance  (distance > 0 and: [ distance < 9 ]) ifTrue: [ stream nextPut: 175 + distance.        ^self ].  ^self genJumpLong: distancevalueUnpreemptively  | activeProcess oldPriority result semaphore |  activeProcess := Processor activeProcess.  oldPriority := activeProcess priority.  activeProcess priority: Processor highestPriority.  result := self ensure: [ activeProcess priority: oldPriority ].  semaphore := Semaphore new.  [ semaphore signal ] fork.  semaphore wait.  ^resultaddObsoleteSubclass: aClass  simpleRetryUsingTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:ex |  ex retryUsing: [ self doYetAnotherThing ] ]fromNumber: anInteger  self setTop: anInteger left: anInteger bottom: anInteger right: anIntegerprotocolOrganizer: anObject  protocolOrganizer := anObjectinitializeParsing  invalidPattern := false.  patternStream := pattern readStreamtestIsLowercase  self checkCorrespondanceOf: #isLowercase: and: #LlliteralStrings  | litStrs |  litStrs := OrderedCollection new: self numLiterals.  self literalsDo: [:lit |  lit isVariableBinding ifTrue: [ litStrs addLast: lit key ] ifFalse: [ lit isSymbol ifTrue: [ litStrs addAll: lit keywords ] ifFalse: [ litStrs addLast: lit printString ] ] ].  ^litStrstagWith: aSymbol  | package packageTag |  package := self package.  packageTag := package addClassTag: aSymbol.  packageTag addClass: selfreformat  self methodClass compile: self ast formattedCode classified: self categorydependentClasses  | cll |  cll := Set new.  self superclass ifNotNil: [ cll add: self superclass ].  self methods , self classSide methods do: [:m |  m literalsDo: [:l |  ((((l isVariableBinding and: [ l value notNil ]) and: [ l value isBehavior ]) and: [ m category notEmpty ]) and: [ m category first ~= $* ]) ifTrue: [ cll add: l value ] ] ].  ^cll asArrayisTwoDigitYearPattern  ^patternStream peekFor: $yuses: aTraitCompositionOrArray slots: slotArray  | theClass |  theClass := self instanceSide.  theClass := theClass classInstaller update: theClass to: [:builder |  builder           fillFor: theClass;           classTraitComposition: aTraitCompositionOrArray asTraitComposition;           classSlots: slotArray ].  ^theClass classSidelistAtCategoryNamed: categoryName  | i |  i := categoryArray indexOf: categoryName ifAbsent: [ ^Array new ].  ^self listAtCategoryNumber: icompile: code notifying: requestor  ^self compile: code classified: Protocol unclassified notifying: requestormethodsReferencingClasses: aCollectionOfClasses  ^self methods select: [:meth |  meth referencedClasses includesAny: aCollectionOfClasses ]classForTicker  ^DelayMicrosecondTickerSimulationremoveSlot: aSlot  (self classLayout slots includes: aSlot) ifFalse: [ self error: aSlot name , ' is not one of my slots' ].  ^self classInstaller update: self to: [:builder |  builder           fillFor: self;           slots: (self classLayout slots copyWithout: aSlot) ]treeNodeHead  ^selfisLowercase  ^self characterSet isLowercase: selfcomment  commentRemoteString ifNil: [ ^'' ].  ^commentRemoteString string ifNil: [ '' ]asCollectionElement  removeProtocol: aProtocol  | oldCategories |  oldCategories := self protocolOrganizer allProtocolsNames copy.  self protocolOrganizer removeProtocol: aProtocol.  self notifyOfRemovedCategory: aProtocol name.  self notifyOfChangedCategoriesFrom: oldCategories to: self protocolOrganizer allProtocolsNamesasRingMinimalDefinitionIn: anRGEnvironment  ^RGMetaclass named: self name parent: anRGEnvironmenthasAbstractMethods  ^super hasAbstractMethods or: [ self classSide hasAbstractMethods ]testFromDateAndTime  | timestamp |  timestamp := DosTimestamp fromDateAndTime: '21 May 2012 3:02:44 pm' asDateAndTime.  self assert: timestamp value equals: 16r40B57856asNonFractionalPoint  (x isFraction or: [ y isFraction ]) ifTrue: [ ^x asFloat @ y asFloat ]testLiteralsDoesNotContainMethodName  self deny: (self compiledMethod1 hasLiteralThorough: #method1)cull: firstArg cull: secondArg cull: thirdArg  ^numArgs < 3 ifTrue: [ self cull: firstArg cull: secondArg ] ifFalse: [ self value: firstArg value: secondArg value: thirdArg ]duringTestCompileSilently: code  ^self duringTestCompileSilently: code storeSource: truehasInstVarNamed: aString  ^self instVarNames includes: aStringtestOneCanProceedWhenIntroducingClasseVariablesBeginingWithLowerCaseCharacters  | class |  [ class := classFactory newSubclassOf: classFactory defaultSuperclass instanceVariableNames: 'a BVarName' classVariableNames: '' ] on: Exception do: [:ex |  ex resume ].  self assert: (testingEnvironment keys includes: class name)retrySelector: anObject  retrySelector := anObjectclassUnderTest  ^AsciiCharsetfactorial  self = 0 ifTrue: [ ^1 ].  self > 0 ifTrue: [ ^self * (self - 1) factorial ].  self error: 'Not valid for negative integers'noon  ^self dayMonthYearDo: [:d :m :y |  self class year: y month: m day: d hour: 12 minute: 0 second: 0 offset: offset ]setLeft: left right: right top: top bottom: bottom  origin := (left min: right) @ (top min: bottom).  corner := (left max: right) @ (top max: bottom)absPrint: float on: stream base: base  ^float absPrintInexactlyOn: stream base: baseactivePriority  ^activeProcess effectiveProcess priorityrfvalue  < primitive: 207>  < metaLinkOptions: #(+ optionDisabledLink)>  | newContext |  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  false ifTrue: [ newContext := self asContextWithSender: thisContext sender.        thisContext privSender: newContext ] ifFalse: [ self primitiveFailed ]willCreateBlock  ^self method encoderClass isCreateBlockAt: pc in: self methodbrowserPrintString  ^self browserPrintStringWith: suspendedContextbasicSuperclass: aClass  superclass := aClasspushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize  | copiedValues |  numCopied > 0 ifTrue: [ copiedValues := Array new: numCopied.        numCopied to: 1 by: -1 do: [:i |  copiedValues at: i put: self pop ] ] ifFalse: [ copiedValues := nil ].  self push: (BlockClosure outerContext: self startpc: pc numArgs: numArgs copiedValues: copiedValues).  self jump: blockSizeupdate: anAspect with: anObject  ^self update: anAspecttestFromDos  | aDateAndTime |  aDateAndTime := DateAndTime fromDosTimestamp: 16r40B57856.  self assert: aDateAndTime equals: '21 May 2012 3:02:44 pm' asDateAndTime.  self assert: aDateAndTime offset equals: DateAndTime localOffsettestMultiSchedule  | delay anotherDelay |  delay := Delay forSeconds: 1000.  scheduler schedule: delay.  self assert: delay beingWaitedOn.  self should: [ scheduler schedule: delay ] raise: Error.  [ anotherDelay := Delay forMilliseconds: 1000.  scheduler schedule: anotherDelay ] forkAt: Processor activePriority + 1.  self assert: anotherDelay beingWaitedOntestInjectingExceptionHandlerIntoRunningProcess  | error interceptedError process sema started interrupted |  DefaultExecutionEnvironment beActive.  error := Error new messageText: 'test error'.  sema := Semaphore new.  started := false.  interrupted := true.  process := [ started := true.  sema wait.  error signal.  interrupted := false ] newProcess.  process resume.  [ started ] whileFalse: [ Processor yield ].  process on: Error do: [:err |  interceptedError := err ].  sema signal.  [ process isTerminated ] whileFalse: [ Processor yield ].  self assert: interceptedError identicalTo: error.  self assert: interruptedsetNamedPrimitiveInformationFrom: fromMethod toMethod: toMethod  | spec |  spec := toMethod literalAt: 1.  spec replaceFrom: 1 to: spec size with: (fromMethod literalAt: 1) startingAt: 1testMinimumNegativeIntegerArithmetic  #(32 64) do: [:nBits |  | largePositiveInt largeNegativeInt |        largePositiveInt := 1 << (nBits - 1).        largeNegativeInt := largePositiveInt negated.        self assert: largeNegativeInt >> 3 equals: (largeNegativeInt bitInvert >> 3) bitInvert.        self assert: largeNegativeInt + 1 equals: (largePositiveInt - 1) negated.        self assert: largeNegativeInt - -1 equals: (largePositiveInt - 1) negated.        self assert: largeNegativeInt // -1 equals: largePositiveInt.        self assert: largeNegativeInt \\ -1 equals: 0.        self assert: (largeNegativeInt rem: -1) equals: 0.        self assert: (largeNegativeInt quo: -1) equals: largePositiveInt.        self assert: largeNegativeInt * -1 equals: largePositiveInt.        self assert: largeNegativeInt / -1 equals: largePositiveInt ]testNewDayMonthYear  self assert: (Date year: 2004 month: 1 day: 23) equals: january23rd2004testPercent  self assert: 20 / 40 equals: 50 percentmethodNode  ^self parseTreetestAsMonth  self assert: aDateAndTime asMonth equals: (Month year: 1901 month: 'January')testNanoSeconds  self assert: aDuration nanoSeconds equals: 5.  self assert: (Duration nanoSeconds: 5) nanoSeconds equals: 5cannotReturn: result  closureOrNil ifNotNil: [ ^BlockCannotReturn result: result from: self home ].  Processor activeProcess debug: thisContext title: 'computation has been terminated'displayStringOn: aStream  self printOn: aStreamwholeNanoseconds  ^nanos rem: 1e3valueSuppressingMessages: aListOfStrings supplyingAnswers: aListOfPairs  ^self valueSupplyingAnswers: aListOfPairs , (aListOfStrings collect: [:each |  {each .                     true} ])getName  ^nametestAsWeek  self assert: aDateAndTime asWeek equals: (Week starting: '12-31-1979' asDate)runTestsBy: aBlock  self subclassResponsibilitytestDegreeSin  45 degreeSin.  self assert: (45 degreeSin squared - (1 / 2)) abs <= Float epsilon.  self assert: (30 degreeSin - (1 / 2)) abs <= Float epsilon.  self assert: (-30 degreeSin + (1 / 2)) abs <= Float epsilon.  -360 to: 360 do: [:i |  self assert: (i degreeSin closeTo: i degreesToRadians sin) ].  -10 to: 10 do: [:k |  self assert: (k * 360 + 90) degreeSin - 1 equals: 0.        self assert: (k * 360 - 90) degreeSin + 1 equals: 0.        self assert: (k * 360 + 180) degreeSin equals: 0.        self assert: (k * 360) degreeSin equals: 0 ]testEquals  | tzm8 tzp10 |  tzm8 := january23rd2004 translateTo: -8 hours.  tzp10 := january23rd2004 translateTo: 10 hours.  self     assert: (january23rd2004 equals: tzm8);     assert: (january23rd2004 equals: tzp10);     assert: (tzm8 equals: tzp10);     assert: (january23rd2004 equals: june2nd1973) notdoubleResumeTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingElseString;     add: self doYetAnotherThingString;     yourselfwillBlockReturn  ^self method encoderClass isBlockReturnAt: pc in: self methodtestSimpleResume  self assertSuccess: (ExceptionTester new runTest: #simpleResumeTest)referencedClasses  ^self methods flatCollectAsSet: #referencedClassesstamp  ^self timeStamp> aNumber  < primitive: 544>  ^aNumber adaptToFloat: self andCompare: #>localMessages  | scanner aSet |  aSet := IdentitySet new.  scanner := InstructionStream on: self.  scanner scanFor: [:x |  scanner addSelectorTo: aSet.        false ].  ^aSettestIsOtherLetter  self checkCorrespondanceOf: #isOtherLetter: and: #LowaitFor: aBlock  [ 10 milliSeconds wait.  aBlock value ] whileFalsesupportsClosureOpcodes  ^falseasFloat  ^super asFloat negatedparseTwoDigitDay  day := self parse: 'day' expectedSize: 2dates  | dates |  dates := OrderedCollection new.  self datesDo: [:m |  dates add: m ].  ^dates asArrayfork  ^self newProcess resumeprintStringHex  ^self asInteger printStringBase: 16reBanName  ^self name , ' (Class)'testSimpleEnsureTestWithError  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithError)expanded  ^Rectangle origin: origin floor corner: corner ceilingtransposed  ^y @ xmonthName  ^Month nameOfMonth: self monthcorner  ^cornertestMethodContext  self assert: aMethodContext home notNil.  self assert: aMethodContext receiver notNil.  self assert: (aMethodContext method isKindOf: CompiledMethod)testReadFrom  | m |  m := Month readFrom: 'July 1998' readStream.  self assert: m equals: monthprintOn: aStream  aStream nextPutAll: 'a descendent of '.  self superclass printOn: aStreamsetUp  super setUp.  testClass := Object newAnonymousSubclasstestIntegerAsFloat  self deny: 16r1FFFFFFFFFFFF0801 asFloat equals: 16r1FFFFFFFFFFFF0800 asFloat.  self deny: 16r1FFFFFFFFFFFF0802 asFloat equals: 16r1FFFFFFFFFFFF0800 asFloat.  self assert: 16r1FFFFFFFFFFF1F800 asFloat equals: 16r1FFFFFFFFFFF20000 asFloat.  self assert: 16r1FFFFFFFFFFFF0800 asFloat equals: 16r1FFFFFFFFFFFF0000 asFloatstepToSendOrReturn  | context |  [ self isDead or: [ self willSend or: [ self willReturn or: [ self willStore or: [ self willCreateBlock ] ] ] ] ] whileFalse: [ context := self step.        context == self ifFalse: [ ^context ] ]new  thisClass class ~~ self ifTrue: [ ^thisClass := self basicNew ] ifFalse: [ self error: 'A Metaclass should only have one instance!' ]closeTo: num precision: aPrecision  num isFloat ifTrue: [ ^num closeTo: self asFloat precision: aPrecision ].  ^[ self = num ] ifError: [ false ]basicSize  < primitive: 62>  ^0visibleMethods  ^self methodsselector  ^self subclassResponsibilitytestMiddleOf  self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) equals: (Timespan starting: '12-31-1969' asDate duration: 2 days)fuelAccept: aGeneralMapper  ^aGeneralMapper visitClass: selfban: aCritique  ReSystemAnnouncer uniqueInstance notifyCritique: aCritique of: aCritique sourceAnchor entity bannedOn: self.  (TheManifestBuilder of: self) banRule: aCritique rule for: selfstandardMessageText  ^String streamContents: [:stream |  stream print: self selector.        stream << ' should have been implemented in '.        stream print: self signaler class ]testAllSelectors  self assert: ProtoObject allSelectors asSet equals: ProtoObject selectors asSet.  self assert: Object allSelectors asSet equals: (Object selectors asSet union: ProtoObject selectors).  self assert: (Object allSelectorsBelow: ProtoObject) asSet equals: Object selectors asSetdaysInYear  ^self asYear daysInYeararcTan  ^self asFloat arcTanstart  ^startactionSequenceForEvent: anEventSelector  ^(self actionMap at: anEventSelector asSymbol ifAbsent: [ ^WeakActionSequence new ]) asActionSequencehighBitOfMagnitude  self < 0 ifTrue: [ ^self negated highBitOfMagnitude ].  ^self highBitOfPositiveReceivermethodsInProtocol: aString  ^(self organization listAtCategoryNamed: aString) collect: [:each |  self compiledMethodAt: each ]asNanoSeconds  ^self asDuration asNanoSecondsgtInspectorSourceCodeIn: composite  < gtInspectorPresentationOrder: 40>  ^(self sourceNode gtInspectorSourceCodeIn: composite)     doItReceiver: [ self receiver ];     doItContext: [ self outerContext ]interpret  | endPC |  endPC := self method endPC.  [ pc > endPC ] whileFalse: [ self interpretNextInstructionFor: self ]= aNumber  < primitive: 7>  ^super = aNumbertestUtcOffset  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1970-01-01T12:00:00+12:00' asDateAndTimecompact  | newInstance |  newInstance := self compactWithoutBecome.  newInstance capacity = self capacity ifTrue: [ self copyFrom: newInstance ] ifFalse: [ self becomeForward: newInstance ]isAliasSelector: aSymbol  ^falsetestParsingPatternWithExtraCharacter  self assertReading: 'a4.2.2345' as: 'ad.m.y' equals: (Date year: 2345 month: 2 day: 4).  self assertReading: '4.2.2345' as: 'ad.m.y' raise: DateError.  self assertReading: 'a4.2.2345' as: 'd.m.y' raise: DateErrorprintHumanReadableOn: stream  | outputWritten count |  outputWritten := false.  self negative ifTrue: [ stream << '- '.        ^self abs printHumanReadableOn: stream ].  #(#(days 'day') #(hours 'hour') #(minutes 'minute') #(seconds 'second') #(wholeMilliseconds 'millisecond') #(wholeMicroseconds 'microsecond') #(wholeNanoseconds 'nanosecond')) do: [:each |  count := (self perform: each first) truncated.        count > 0 ifTrue: [ outputWritten ifTrue: [ stream space ].              count printWithCommasOn: stream.              stream                 space;                 << (each second asPluralBasedOn: count).              outputWritten := true ] ].  outputWritten ifFalse: [ stream << '0 seconds' ]messageText: signalerText  messageText := signalerTextradix: base  ^self printStringBase: basehighIOPriority  ^HighIOPriorityrfeffectiveProcess  < metaLinkOptions: #(+ optionDisabledLink)>  ^effectiveProcess ifNil: [ self ]testDigitLength  | lni |  lni := -114605103402541699037609980192546360895434064385.  self assert: 20 equals: lni bytesCounttestSeconds  self assert: aDateAndTime seconds equals: 0removeClassVarNamed: aString  self removeClassVarNamed: aString interactive: falsenoMask: mask  ^0 = (self bitAnd: mask)selectorsToFileOutCategory: aSymbol  ^self organization listAtCategoryNamed: aSymbolstoreString  ^String streamContents: [:s |  self storeOn: s ]soleInstance  ^thisClassspotterUsedTraitsFor: aStep  < spotterOrder: 60>  aStep listProcessor     title: 'Uses Traits';     allCandidates: [ self traits asArray ];     itemIcon: #systemIcon;     filter: GTFilterSubstringnanoSecond  ^nanostestIsMathSymbol  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isMathSymbol: ch) equals: (charset isMathSymbol: ch) ]assertWellMaterializedInto: aMethodContext in: aTestCase  aTestCase assert: self ~~ aMethodContext.  aTestCase assert: self class == aMethodContext class.  aTestCase assert: self tempNames = aMethodContext tempNames.  aTestCase assert: pc = aMethodContext pc.  aTestCase assert: stackp = aMethodContext stackPtr.  closureOrNil ifNil: [ aTestCase assert: aMethodContext closure isNil ] ifNotNil: [ closureOrNil assertWellMaterializedInto: aMethodContext closure in: aTestCase ].  aTestCase assert: receiver = aMethodContext receiver.  aTestCase assert: (method isEqualRegardlessTrailerTo: aMethodContext method).  sender ifNil: [ aTestCase assert: aMethodContext sender isNil ] ifNotNil: [ sender assertWellMaterializedInto: aMethodContext sender in: aTestCase ]debugStack: stackSize on: aStream  (self stackOfSize: stackSize) do: [:item |  item printDebugOn: aStream.        aStream cr ]wholeMilliseconds  ^nanos quo: 1e6testMethodTemps  | i continuation |  i := 0.  i := i + (self callcc: [:cc |  continuation := cc.              1 ]).  self assert: i ~= 3.  i = 2 ifFalse: [ continuation value: 2 ]testAfterCriticalWait  | s p |  s := Semaphore new.  p := [ s critical: [  ] ] forkAt: Processor activePriority - 1.  [ p suspendingList == s ] whileFalse: [ (Delay forMilliseconds: 10) wait ].  s signal.  p terminate.  self assert: (s instVarNamed: #excessSignals) equals: 1doWhileFalse: conditionBlock  | result |  [ result := self value.  conditionBlock value ] whileFalse.  ^resulttestNew  self assert: Timespan new equals: (Timespan starting: '01-01-1901' asDate)testPrintOn  self assert: (String streamContents: [:str |  aDuration printOn: str ]) equals: '1:02:03:04.000000005'isPushTemp: aPC  ^self method encoderClass isPushTempAt: aPC in: methodprintMSOn: aStream  self minute printOn: aStream base: 10 length: 2 padded: true.  aStream nextPut: $:.  self second printOn: aStream base: 10 length: 2 padded: truephlowValue: anObject withEnoughArguments: aCollection  ^selfcopyWith: newElement  ^self copy     add: newElement;     yourselftestYear  self assert: aDateAndTime year equals: 2004storeOn: aStream  aStream nextPutAll: 'nil'categories  ^self protocolOrganizer protocolsNamesbasicCheck: aNode  | messageReceiver |  aNode isMessage ifFalse: [ ^false ].  messageReceiver := aNode receiver.  messageReceiver isVariable ifFalse: [ ^false ].  messageReceiver isGlobal ifFalse: [ ^false ].  (self check: aNode selector forDeprecationIn: messageReceiver name) ifFalse: [ ^false ].  ^truecommentStamp: changeStamp  self organization commentStamp: changeStampsetUp  super setUp.  aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5testAsNanoSeconds  self assert: aDateAndTime asNanoSeconds equals: 0 asDuration asNanoSecondsgenStoreInstVarLong: instVarIndex  self genStorePopInstVarLong: instVarIndex.  self genPushInstVarLong: instVarIndexanalogousCodeTo: aMethodProperties  | bs |  self class == aMethodProperties class ifFalse: [ ^false ].  (bs := self basicSize) = aMethodProperties basicSize ifFalse: [ ^false ].  1 to: bs do: [:i |  ((self basicAt: i) analogousCodeTo: (aMethodProperties basicAt: i)) ifFalse: [ ^false ] ].  ^trueincludesMethod: aMethod  ^self methodDict identityIncludes: aMethodlcm: n  ^self // (self gcd: n) * ndaysInMonth  ^start daysInMonthroundDownTo: grid  | gridPoint |  gridPoint := grid asPoint.  ^(x roundDownTo: gridPoint x) @ (y roundDownTo: gridPoint y)isDoneParsing  ^patternStream atEnd or: [ inputStream atEnd or: [ invalidPattern ] ]sourceCodeTemplate  ^'messageSelectorAndArgumentNames	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temporary variable names |	statements'methodsTaggedWith: aSymbol  ^self localMethods select: [:each |  each isTaggedWith: aSymbol ]testEnvironment  ^testEnvironmentgetProtocolNamed: aByteString ifNone: aBlockClosure  ^protocols detect: [:e |  e name = aByteString ] ifNone: aBlockClosureasDosTimestamp  ^(DosTimestamp fromDateAndTime: self) valuestoreOn: aStream  | name |  self shouldBePrintedAsLiteral ifTrue: [ aStream           nextPut: $$;           nextPut: self ] ifFalse: [ name := self class constantNameFor: self.        name notNil ifTrue: [ aStream                 nextPutAll: self class name;                 space;                 nextPutAll: name ] ifFalse: [ aStream                 nextPut: $(;                 nextPutAll: self class name;                 nextPutAll: ' value: ';                 print: self asInteger;                 nextPut: $) ] ]isBlockContext  ^closureOrNil isClosureasDateAndTime  ^startisLiteral  ^falseexample2  < sampleInstance>  | ff |  ff := 1.  1 < 2 ifTrue: [ ff ifNotNil: [ ff := 'hallo' ] ].  ^ffsetSubject: anObject  organizedClass := anObjectsecond  ^self secondsgtInspectorInterestingObject  ^selfnegated  ^(0 - x) @ (0 - y)value  < primitive: 201>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  ^self primitiveFailedenclosedSetElement  self deprecated: 'Use #enclosedElement instead' transformWith: '`@receiver enclosedSetElement' -> '`@receiver enclosedElement'.  ^self enclosedElementtryPrimitive: primIndex withArgs: argumentArray  < primitive: 118 error: code>  ^Context primitiveFailTokenFor: coderemoveActionsForEvent: anEventSelector  | map |  map := self actionMap.  map removeKey: anEventSelector asSymbol ifAbsent: [  ].  map isEmpty ifTrue: [ self releaseActionMap ]modificationForbiddenFor: selector value: value  ^self modificationForbiddenFor: selector index: nil value: valuepropertyAt: aKey ifAbsent: aBlock  1 to: self basicSize do: [:i |  | propertyOrPragma |        propertyOrPragma := self basicAt: i.        (propertyOrPragma isVariableBinding and: [ propertyOrPragma key == aKey ]) ifTrue: [ ^propertyOrPragma value ] ].  ^aBlock valuegenStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex  (tempIndex >= 0 and: [ tempIndex < 256 and: [ tempVectorIndex >= 0 and: [ tempVectorIndex < 256 ] ] ]) ifTrue: [ stream           nextPut: 141;           nextPut: tempIndex;           nextPut: tempVectorIndex.        ^self ].  tempIndex >= 256 ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255 ].  tempVectorIndex >= 256 ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255 ]asEpiceaRingDefinition  ^(RGMethodDefinition named: self selector)     parentName: self methodClass name;     isMetaSide: self methodClass isMeta;     protocol: self category;     sourceCode: self sourceCode;     stamp: self timeStamp;     package: (self package ifNotNil: [:package |  package name ]);     yourselfaddMethodSelector: aSymbol  ^methodSelectors add: aSymbolcanonicalArgumentName  ^'aClass'copyAllCategoriesFrom: aClass  aClass organization categories do: [:cat |  self copyCategory: cat from: aClass ]standardMessageText  ^String streamContents: [:stream |  stream print: self selector.        stream << ' should not have been implemented in '.        stream print: self signaler class ]parseTwoDigitMonth  month := self parse: 'month' expectedSize: 2testDay  self assert: aDateAndTime day equals: DateAndTime new dayremoveMethod: aSymbol  (self protocolsOfSelector: aSymbol) do: [:p |  p removeMethodSelector: aSymbol ]allClassVariables  ^self withAllSuperclasses flatCollect: [:each |  each classVariables ]keysDo: aBlock  tally = 0 ifTrue: [ ^self ].  1 to: self basicSize do: [:i |  (self basicAt: i) ifNotNil: [:key |  aBlock value: key ] ]asRingMinimalDefinitionIn: anRGEnvironment  self error: 'For Protocol you need to use #asRingMinimalDefinitionIn:parent: because parent class cannot be resolved automatically'/ aNumber  < primitive: 550>  aNumber = 0.0 ifTrue: [ ^ZeroDivide signalWithDividend: self ].  ^aNumber adaptToFloat: self andSend: #/setBlessingInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setBlessingWithBlock: selftestIsInstalled  | method cls |  method := self class >> #returnTrue.  self assert: method isInstalled.  Smalltalk removeClassNamed: #TUTU.  cls := Object subclass: #TUTU instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self categoryNameForTemporaryClasses.  cls compile: 'foo ^ 10'.  method := cls >> #foo.  cls removeSelector: #foo.  self deny: method isInstalled.  Smalltalk removeClassNamed: #TUTUvalueSuppressingAllMessages  ^self valueSuppressingMessages: #('*')protocolOrganizer  ^protocolOrganizer= aNumber  < primitive: 547>  aNumber isNumber ifFalse: [ ^false ].  ^aNumber adaptToFloat: self andCompare: #=hasClassVariable: aGlobal  ^self classVariables identityIncludes: aGlobalsimpleReturnTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     yourselftestNoArguments  | block1 block2 |  block1 := [:arg |  1 + 2 ].  block2 := [:arg1 :arg2 |  1 + 2 ].  [ 10 timesRepeat: block1 ] ifError: [:err |  self deny: err equals: 'This block requires 1 arguments.' ].  [ 10 timesRepeat: block2 ] ifError: [:err |  self deny: err equals: 'This block requires 2 arguments.' ]removeSelectorSilently: selector  ^SystemAnnouncer uniqueInstance suspendAllWhile: [ self removeSelector: selector ]packToArity: arity  self error: 'Use #rollAsFloatArity: or #rollAsDoubleArity:'testSchedulerTermination  | process sema gotHere sema2 |  gotHere := false.  sema := Semaphore new.  sema2 := Semaphore new.  process := [ sema signal.  sema2 wait.  gotHere := true ] forkAt: Processor activeProcess priority.  sema wait.  process terminate.  sema2 signal.  Processor yield.  self assert: gotHere notorDefaultForUnresolved  ^selfremoveLink: aLink  self reflectiveMethod ifNotNil: [:rm |  rm removeLink: aLink ]schedulerSignalWaitingProcess  beingWaitedOn := false.  process suspendingList == delaySemaphore ifTrue: [ expired := true.        process           suspend;           resume ]pcRange  ^self sourceNodeExecuted debugHighlightRangetestProxyObject: object initialState: initialState tuples: tuples  self testObject: object initialState: initialState tuples: tuples setReadOnlyBlock: [:value |  MirrorPrimitives makeObject: object readOnly: value ]methodProperties  ^self method propertiestypeOfClass  ^#normal- anotherException  ^ExceptionSetWithExclusions new     add: self;     addExclusion: anotherException;     yourselfpredecessor  | ulp |  self isFinite ifFalse: [ (self isNaN or: [ self negative ]) ifTrue: [ ^self ].        ^Float fmax ].  self = 0.0 ifTrue: [ ^Float fmin negated ].  ulp := self ulp.  ^self - (0.5 * ulp) = self ifTrue: [ self - ulp ] ifFalse: [ self - (0.5 * ulp) ]nextPut: aByte  position := position + 1testLargeShift  | suite |  suite := #('101101011101001100110111110110011101101101000001110110011' '1101101001100010011001101110100000111011011010100011101100' '101101101011110011001100110011011101011001111000100011101000' '10101101101000101001111111111100101101011001011000100011100000' '1000101010101001111011101010111001011111110011110001000110000000' '1100101010101000010011101000110010111110110011110000000000000001').  suite := suite , (suite collect: [:e |  '1' , e reversed ]).  suite := suite , (suite collect: [:e |  e , e ]).  suite do: [:bits |  | num ls rs |        num := Integer readFrom: bits readStream base: 2.        0 to: bits size - 1 do: [:shift |  ls := (num bitShift: shift) printStringBase: 2.              rs := (num bitShift: 0 - shift) printStringBase: 2.              self assert: ls equals: bits , (String new: shift withAll: $0).              self assert: rs equals: (bits copyFrom: 1 to: bits size - shift) ] ]asExternalTypeOn: generator  ^FFIConst value: self asBitisBefore: aDate  | otherDate |  otherDate := aDate asDate.  ^self year < otherDate year or: [ self year = otherDate year and: [ self monthIndex < otherDate monthIndex or: [ self monthIndex = otherDate monthIndex and: [ self dayOfMonth < otherDate dayOfMonth ] ] ] ]withAllSuperclassesDo: aBlock  aBlock value: self.  self superclass == nil ifFalse: [ self superclass withAllSuperclassesDo: aBlock ]asUnixTime  ^((self offset: Duration zero) - self class unixEpoch) asSecondsfuelSet: julianDay nanoSecond: nanoSeconds seconds: numberOfSeconds offset: anOffset  self setJdn: julianDay seconds: numberOfSeconds nano: nanoSeconds offset: anOffsetsizeReturnTop  ^self sizeOpcodeSelector: #genReturnTop withArguments: #()height  ^self bottom + self topgenReturnTopToCaller  stream nextPut: 125sourceNode  ^self sourceNodeExecuted enclosingMethodOrBlockNodetestCoercion  #(#* #+ #- #/) do: [:op |  self assert: (1.0s1 perform: op with: 2) class equals: ScaledDecimal.        self assert: (1.0s1 perform: op with: 1 / 2) class equals: ScaledDecimal.        self deny: (1.0s1 perform: op with: 1.0) class equals: ScaledDecimal.        self assert: (1 perform: op with: 2.0s1) class equals: ScaledDecimal.        self assert: (1 / 2 perform: op with: 2.0s1) class equals: ScaledDecimal.        self deny: (1.0 perform: op with: 1.0s1) class equals: ScaledDecimal ]copyWith: newElement  | copy i |  copy := self class new: self size + 1.  i := 0.  self do: [:item |  copy basicAt: (i := i + 1) put: item ].  copy basicAt: (i := i + 1) put: newElement.  ^copyifNil: nilBlock  ^selfwaitProcessTermination: aProcess  self waitFor: [ aProcess isTerminated ]canBeGlobalVarInitial  ^self characterSet canBeGlobalVarInitial: selftestFork  | hasBlockRun block return checkAssert |  checkAssert := Semaphore new.  hasBlockRun := false.  block := [ hasBlockRun := true.  checkAssert signal ].  return := block fork.  self deny: hasBlockRun.  self assert: (return isKindOf: Process).  checkAssert wait.  self assert: hasBlockRungtDisplayOn: stream  self printOn: streamcategoryOfElement: element  | index |  index := self numberOfCategoryOfElement: element.  ^index = 0 ifTrue: [ nil ] ifFalse: [ categoryArray at: index ]value: anObject  ^receiver perform: selector with: anObjectsimpleRetryUsingTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     yourselfnotifyUserOfCommand: aCommand  self passwritesField: varIndex  self isQuick ifTrue: [ ^false ].  ^super writesField: varIndexcheckLocal: value  self assert: TestLocalVariable value equals: valueouterCode  ^self literalAt: self numLiteralsdefaultAction  < reflective: #unhandledErrorDefaultAction:message:>  ^UIManager default unhandledErrorDefaultAction: self exceptionasShortcut  ^self asKeyCombinationreceiver: anObject  self at: 1 put: anObjectclassVariablesNeedFullDefinition  ^self classVariables anySatisfy: [:each |  each needsFullDefinition ]testIsOtherSymbol  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isOtherSymbol: ch) equals: (charset isOtherSymbol: ch) ]includesProperty: aKey  1 to: self basicSize do: [:i |  | propertyOrPragma |        propertyOrPragma := self basicAt: i.        (propertyOrPragma isVariableBinding and: [ propertyOrPragma key == aKey ]) ifTrue: [ ^true ] ].  ^falsetranslateToUTC  ^self translateTo: 0nextInstance  self shouldNotImplementelapsedTime  ^elapsedTimecopySameFrom: otherObject  | myInstVars otherInstVars |  myInstVars := self class allInstVarNames.  otherInstVars := otherObject class allInstVarNames.  myInstVars doWithIndex: [:each :index |  | match |        (match := otherInstVars indexOf: each) > 0 ifTrue: [ self instVarAt: index put: (otherObject instVarAt: match) ] ].  1 to: (self basicSize min: otherObject basicSize) do: [:i |  self basicAt: i put: (otherObject basicAt: i) ]selectorsToBeIgnored  | deprecated private special primitives timing benchmarks |  deprecated := #().  private := #(#print24:on: #print24:showSeconds:on:).  special := #(#< #= #new #printOn: #storeOn:).  primitives := #(#primMillisecondClock #primSecondsClock #primUTCSecondsClock #primUTCMicrosecondsClock #primUTCMillisecondsClock).  timing := #(#millisecondClockValue #milliseconds:since: #millisecondsSince:).  benchmarks := #(#benchmarkMillisecondClock #benchmarkPrimitiveResponseDelay).  ^super selectorsToBeIgnored , deprecated , private , special , primitives , timing , benchmarksticks  ^Array with: julianDayNumber with: seconds with: nanosaddSelectorSilently: selector withMethod: compiledMethod  self methodDict at: selector put: compiledMethod.  compiledMethod methodClass: self.  compiledMethod selector: selectorexpectedArgumentsCount  ^expectedArgumentsCountwithHeight: height  ^origin corner: corner x @ (origin y + height)asDate  ^start asDateprintOn: aStream  aStream     print: self asDateAndTime;     nextPutAll: ' (';     print: self value;     nextPut: $)ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock  ^trueAlternativeBlock valueisSymbol  ^falseremoveEmptyCategories  | oldCategories removedProtocols |  oldCategories := self protocolOrganizer allProtocolsNames copy.  removedProtocols := self protocolOrganizer removeEmptyProtocols.  removedProtocols do: [:each |  self notifyOfRemovedCategory: each name ].  self notifyOfChangedCategoriesFrom: oldCategories to: self protocolOrganizer allProtocolsNamestestBasicNew  self should: [ SmallInteger basicNew ] raise: self defaultTestErrorsystemBackgroundPriority  ^SystemBackgroundPrioritywaitOnCompletion: completionBlock onTimeout: timeoutBlock  ^self wait ifTrue: [ timeoutBlock value ] ifFalse: [ completionBlock value ]testNaN3  | set item identitySet |  set := Set new.  set add: (item := Float nan).  self deny: (set includes: item).  identitySet := IdentitySet new.  identitySet add: (item := Float nan).  self assert: (identitySet includes: item)environment  ^environment ifNil: [ super environment ]genPushIntegerLong: anInteger  (anInteger < -32768 or: [ anInteger > 32767 ]) ifTrue: [ ^self outOfRangeError: 'integer' index: anInteger range: -32768 to: 32767 ].  self genSignedSingleExtendB: (anInteger bitShift: -8).  stream     nextPut: 232;     nextPut: (anInteger bitAnd: 255)object  ^object\\\ anInteger  ^self \\ anIntegerprintHMSOn: aStream separatedBy: aSeparator  BasicDatePrinter default printHMS: self separatedBy: aSeparator on: aStreamisPointers  ^self isBits notisIntegerPoint  ^x isInteger and: [ y isInteger ]benchmark  | size flags prime k count |  size := 8190.  1 to: self do: [:iter |  count := 0.        flags := (Array new: size) atAllPut: true.        1 to: size do: [:i |  (flags at: i) ifTrue: [ prime := i + 1.                    k := i + prime.                    [ k <= size ] whileTrue: [ flags at: k put: false.                          k := k + prime ].                    count := count + 1 ] ] ].  ^countsourceNodeForPC: aPC  ^self sourceNode sourceNodeForPC: aPCselector: aSymbol  selector := aSymbolarcTan  < primitive: 57>  | theta eps step sinTheta cosTheta |  self < 0.0 ifTrue: [ ^0.0 - (0.0 - self) arcTan ].  theta := self * Halfpi / (self + 1.0).  eps := Halfpi * Epsilon.  step := theta.  [ step * step > eps ] whileTrue: [ sinTheta := theta sin.        cosTheta := theta cos.        step := sinTheta * cosTheta - (self * cosTheta * cosTheta).        theta := theta - step ].  ^thetatestSuperclass  | s b |  s := OrderedCollection new.  b := [:cls |  cls ifNotNil: [ s add: cls.        b value: cls superclass ] ].  b value: OrderedCollection.  self assert: OrderedCollection allSuperclasses equals: s allButFirst.  self assert: OrderedCollection withAllSuperclasses equals: sgenStorePopInstVarLong: instVarIndex  (instVarIndex >= 0 and: [ instVarIndex < 256 ]) ifTrue: [ stream           nextPut: 132;           nextPut: 192;           nextPut: instVarIndex.        ^self ].  ^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255properties  | propertyStream |  propertyStream := WriteStream on: (Array new: self basicSize * 2).  1 to: self basicSize do: [:i |  | propertyOrPragma |        (propertyOrPragma := self basicAt: i) isVariableBinding ifTrue: [ propertyStream                 nextPut: propertyOrPragma key;                 nextPut: propertyOrPragma value ] ].  ^IdentityDictionary newFromPairs: propertyStream contentsdefaultAction  self subclassResponsibilitytestTomorrow  self assert: Date tomorrow equals: Date today + 1 day* aNumber  < primitive: 49>  ^aNumber adaptToFloat: self andSend: #*testTotalSeconds  self assert: 0 seconds totalSeconds equals: 0.  self assert: 1 second totalSeconds equals: 1.  self assert: 100 second totalSeconds equals: 100.  self assert: 500 milliSeconds totalSeconds equals: 1 / 2.  self assert: 1500 milliSeconds totalSeconds equals: 3 / 2.  self assert: 2500 milliSeconds totalSeconds equals: 5 / 2.  self assert: 1 second negated totalSeconds equals: -1hash  | initialPC endPC hash |  initialPC := self initialPC.  endPC := self endPC.  hash := self species hash + self header + initialPC + endPC + self methodClass hash bitAnd: 16rFFFFFFF.  initialPC to: endPC by: ((endPC - initialPC) // 20 max: 1) do: [:i |  hash := hash + (self at: i) ].  ^hashmethod  ^self outerCode methodtestIsInteger  self assert: 0 isIntegerallMask: mask  ^mask = (self bitAnd: mask)digitLength  self deprecated: 'Use #bytesCount instead.' transformWith: '`@receiver digitLength' -> '`@receiver bytesCount'.  ^self bytesCountspotterPreviewIn: composite  < spotterPreview: 10>  self method spotterPreviewCodeIn: compositereadSlot: aSlot  ^aSlot read: selfdeltaToEnsureInOrCentered: r extra: aNumber  | dX dY halfXDiff halfYDiff |  dX := dY := 0.  halfXDiff := ((r width - self width) * aNumber) truncated.  halfYDiff := ((r height - self height) * aNumber) truncated.  self left < r left ifTrue: [ dX := self left - r left - halfXDiff ] ifFalse: [ self right > r right ifTrue: [ dX := self right - r right + halfXDiff ] ].  self top < r top ifTrue: [ dY := self top - r top - halfYDiff ] ifFalse: [ self bottom > r bottom ifTrue: [ dY := self bottom - r bottom + halfYDiff ] ].  ^dX @ dYpostCopy  ^selfintersectAll: sets  ^sets ifNotEmpty: [ self intersect: sets first withAll: sets allButFirst ]fuelValueWithoutNotifications  SystemAnnouncer uniqueInstance suspendAllWhile: selfdeepCopy  cos  ^(self + Halfpi) sintestHash  self assert: 2 = 2.0 ==> (2 hash = 2.0 hash).  self assert: 1 / 2 = 0.5 ==> ((1 / 2) hash = 0.5 hash).  Float nan hash.  Float infinity hashcompile: text classified: category notifying: requestor  | stamp |  stamp := self acceptsLoggingOfCompilation ifTrue: [ Author changeStamp ] ifFalse: [ nil ].  ^self compile: text classified: category withStamp: stamp notifying: requestorwait  ^self waitMaxMilliseconds: niltheta  | tan theta |  ^x = 0 ifTrue: [ y >= 0 ifTrue: [ 1.570796326794897 ] ifFalse: [ 4.71238898038469 ] ] ifFalse: [ tan := y asFloat / x asFloat.        theta := tan arcTan.        x >= 0 ifTrue: [ y >= 0 ifTrue: [ theta ] ifFalse: [ 6.283185307179586 + theta ] ] ifFalse: [ 3.141592653589793 + theta ] ]isSelfEvaluating  ^self methodClass notNil and: [ self isDoIt not ]critical: mutuallyExcludedBlock ifLocked: alternativeBlock  excessSignals == 0 ifTrue: [ ^alternativeBlock value ].  ^self critical: mutuallyExcludedBlocktestRefersToLiteralsReturnsTrueWhenLiteralIsInMethodPropertiesKey  [ self compiledMethod1 propertyAt: #Once put: true.  self assert: (self compiledMethod1 hasLiteralThorough: #Once) ] ensure: [ self compiledMethod1 removeProperty: #Once ]keyAtValue: value ifAbsent: exceptionBlock  1 to: self basicSize do: [:index |  value = (array at: index) ifTrue: [ (self basicAt: index) ifNotNil: [:theKey |  ^theKey ] ] ].  ^exceptionBlock valuetestNonActiveBlockContextActiveHome  nonActiveBlockContext := self class returnNonActiveContextOfBlock.  self assert: nonActiveBlockContext activeHome isNiltestIsTerminatingForcedTerminationWithoutRunning  | process unwound started terminator |  unwound := false.  started := false.  process := [ started := true.  [ Semaphore new wait ] ensure: [ terminator := Processor activeProcess.        unwound := true ] ] newProcess.  process priority: Processor systemBackgroundPriority.  self assert: process isSuspended.  self deny: process isTerminating.  self deny: process isTerminated.  self deny: started.  self deny: unwound.  process resume.  self deny: process isSuspended.  self deny: process isTerminating.  self deny: process isTerminated.  self deny: unwound.  process terminate.  self assert: process isSuspended.  self assert: process isTerminating.  self assert: process isTerminated.  self deny: started.  self deny: unwound.  self deny: terminator identicalTo: process+ aNumber  < primitive: 541>  ^aNumber adaptToFloat: self andSend: #+adhereTo: aRectangle  (aRectangle containsPoint: self) ifTrue: [ ^self ].  ^((x max: aRectangle left) min: aRectangle right) @ ((y max: aRectangle top) min: aRectangle bottom)next  ^generator nextmethodDict: aDictionary  methodDict := aDictionaryverifyJumpWithSelector: selector  | guineaPig normalStackp readOnlyStackp |  guineaPig := SimulationMock new.  normalStackp := (guineaPig perform: selector) stackPtr.  guineaPig beReadOnlyObject.  [ readOnlyStackp := (guineaPig perform: selector) stackPtr ] on: ModificationForbidden do: [:ex |  ex resumeUnchecked: nil ].  self assert: normalStackp equals: readOnlyStackpsetNumerator: n denominator: d  d = 0 ifTrue: [ ^(ZeroDivide dividend: n) signal ] ifFalse: [ numerator := n asInteger.        denominator := d asInteger abs.        d < 0 ifTrue: [ numerator := numerator negated ] ]doSomethingExceptionalString  ^'Do something exceptional.'myDependents: aCollectionOrNil  aCollectionOrNil ifNil: [ DependentsFields removeKey: self ifAbsent: [  ] ] ifNotNil: [ DependentsFields at: self put: aCollectionOrNil ]step  ^Processor activeProcess evaluate: [ suspendedContext := suspendedContext step ] onBehalfOf: selfnumberOfInstanceVariables  self deprecated: 'Use #instSize or `slots size` instead.' transformWith: '`@receiver numberOfInstanceVariables' -> '`@receiver instSize'.  ^self instSizelinkOf: anObject ifAbsent: errorBlock  self linksDo: [:el |  el value = anObject ifTrue: [ ^el ] ].  ^errorBlock valuecanHandleSignal: exception  ^(self exceptionClass handles: exception) or: [ self nextHandlerContext canHandleSignal: exception ]postCopy  | penultimateLiteral |  (penultimateLiteral := self penultimateLiteral) isMethodProperties ifTrue: [ self penultimateLiteral: (penultimateLiteral copy                 method: self;                 yourself).        self penultimateLiteral pragmas do: [:p |  p method: self ] ]clearLog  log := nilobject: anObject perform: selector withArguments: argArray inClass: lookupClass  < primitive: 100 error: error>  selector isSymbol ifFalse: [ ^self error: 'selector argument must be a Symbol' ].  (argArray isMemberOf: Array) ifFalse: [ ^self error: 'argArray must be an Array' ].  selector numArgs = argArray size ifFalse: [ ^self error: 'incorrect number of arguments' ].  ((self objectClass: anObject) includesBehavior: lookupClass) ifFalse: [ ^self error: 'lookupClass is not in anObject''s inheritance chain' ].  self primitiveFailedtestZeroSignificandAsInteger  self assert: 0.0 significandAsInteger equals: 0asHTMLString  #($< '&lt;' $> '&gt;' $& '&amp;') pairsDo: [:k :v |  self = k ifTrue: [ ^v ] ].  ^String with: self, anException  self add: anExceptionunclassifiedCategory  ^#UnclassifiedfirstCommentAt: selector  self deprecated: 'use #firstComment on the method instead' transformWith: '`@receiver commentsAt: `@argument' -> '(`@receiver compiledMethodAt: `@argument) firstComment'.  ^(self compiledMethodAt: selector) firstCommenthasMethods  ^self methodDict notEmptyremoveFromSystem  self removeFromSystem: trueinitializeTicker: aDelayTicker suspendedDelaysHeap: aHeap  super initializeTicker: aDelayTicker suspendedDelaysHeap: aHeap.  readyToSchedule := Semaphore new signal.  readyToUnschedule := Semaphore new signaltestBecomeHash  | a b c d ha hb |  a := 'ab' copy.  b := 'cd' copy.  c := a.  d := b.  ha := a hash.  hb := b hash.  a become: b.  self     assert: a hash equals: hb;     assert: b hash equals: ha;     assert: c hash equals: hb;     assert: d hash equals: hadeprecatedMethod7  decimalDigitLength  ^self < 10000 ifTrue: [ self < 100 ifTrue: [ self < 10 ifTrue: [ 1 ] ifFalse: [ 2 ] ] ifFalse: [ self < 1000 ifTrue: [ 3 ] ifFalse: [ 4 ] ] ] ifFalse: [ self < 100000000 ifTrue: [ self < 1000000 ifTrue: [ self < 100000 ifTrue: [ 5 ] ifFalse: [ 6 ] ] ifFalse: [ self < 10000000 ifTrue: [ 7 ] ifFalse: [ 8 ] ] ] ifFalse: [ self < 1000000000000 ifTrue: [ self < 10000000000 ifTrue: [ self < 1000000000 ifTrue: [ 9 ] ifFalse: [ 10 ] ] ifFalse: [ self < 100000000000 ifTrue: [ 11 ] ifFalse: [ 12 ] ] ] ifFalse: [ self < 10000000000000000 ifTrue: [ self < 100000000000000 ifTrue: [ self < 10000000000000 ifTrue: [ 13 ] ifFalse: [ 14 ] ] ifFalse: [ self < 1000000000000000 ifTrue: [ 15 ] ifFalse: [ 16 ] ] ] ifFalse: [ self < 1000000000000000000 ifTrue: [ self < 100000000000000000 ifTrue: [ 17 ] ifFalse: [ 18 ] ] ifFalse: [ self < 10000000000000000000 ifTrue: [ 19 ] ifFalse: [ 20 ] ] ] ] ] ]spotterActDefault  ^self browsetestFlag  ProtoObject new flag: #hallokeysAndValuesDo: aBlock  tally = 0 ifTrue: [ ^self ].  1 to: self basicSize do: [:i |  (self basicAt: i) ifNotNil: [:key |  aBlock value: key value: (array at: i) ] ]stonOn: stonWriter  stonWriter writeFloat: self asFloattestCollectArguments  | msg rcvr c |  rcvr := OrderedCollection new.  c := Color green.  msg := WeakMessageSend receiver: rcvr selector: #add: arguments: {Color black}.  msg valueWithArguments: {}.  self assertCollection: rcvr asArray equals: {Color black}.  msg valueWithArguments: {#a .         (WeakArray with: c)}.  self assertCollection: rcvr asArray equals: {Color black .         #a}.  msg valueWithArguments: (WeakArray with: c).  self assertCollection: rcvr asArray equals: {Color black .         #a .         Color green}< aNumber  < primitive: 543>  ^aNumber adaptToFloat: self andCompare: #<isFloat  ^falsejsonOn: aRenderer  aRenderer boolean: selffloorLog: radix  ^(self log: radix) floorallProtocolsNames  ^self allProtocols collect: #namefuelIgnoredInstanceVariableNames  ^#()testFloatPrintPolicy  | pi |  pi := FloatPrintPolicy value: InexactFloatPrintPolicy new during: [ Float pi printString ].  self assert: (pi beginsWith: '3.14159').  pi := FloatPrintPolicy value: ExactFloatPrintPolicy new during: [ Float pi printString ].  self assert: (pi beginsWith: '3.14159')localReadsRef: literalAssociation  | litIndex scanner |  (litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue: [ ^false ].  litIndex := litIndex - 1.  ^(scanner := InstructionStream on: self) scanFor: (self encoderClass bindingReadScanBlockFor: litIndex using: scanner)testAsWeek  | full half quarter |  full := Duration days: 7.  half := Duration weeks: 0.5.  quarter := Duration weeks: 0.25.  self     assert: 1 week equals: full;     assert: 1.0 week equals: full;     assert: 0.5 week equals: half;     assert: (1 / 2) week equals: half;     assert: (1 / 4) week equals: quarter.  self assert: 0.4 week + 0.6 week equals: 1 weekbasicAt: index  < primitive: 60>  index isInteger ifTrue: [ self errorSubscriptBounds: index ].  index isNumber ifTrue: [ ^self basicAt: index asInteger ] ifFalse: [ self errorNonIntegerIndex ]sourceCodeAt: selector ifAbsent: aBlock  ^(self compiledMethodAt: selector ifAbsent: [ ^aBlock value ]) sourceCodeselector: aSelector  selector := aSelectoremptyMethodDictionary  ^MethodDictionary newouterCode: aCompiledCode  ^self literalAt: self numLiterals put: aCompiledCodesuperclass: aSuperclass  superclass := aSuperclasssystemIcon  ^self iconNamed: self systemIconNamedigitAdd: arg  < primitive: 'primDigitAdd' module: 'LargeIntegers'>  | len arglen accum sum |  accum := 0.  (len := self bytesCount) < (arglen := arg bytesCount) ifTrue: [ len := arglen ].  sum := Integer new: len neg: self negative.  1 to: len do: [:i |  accum := (accum bitShift: -8) + (self byteAt: i) + (arg byteAt: i).        sum byteAt: i put: (accum bitAnd: 255) ].  accum > 255 ifTrue: [ sum := sum growby: 1.        sum at: sum bytesCount put: (accum bitShift: -8) ].  ^sumisYearPattern  ^char = $yat: key ifPresent: aBlock  ^(array at: (self findElementOrNil: key)) ifNotNil: [:value |  aBlock cull: value ]testInstanceCreationFromADateAndATime  | date time instance |  date := Date today.  time := Time now.  instance := DateAndTime date: date time: time.  self assert: instance asDate equals: date.  self assert: instance asTime equals: timename  ^self monthNameobjectAt: index put: value  < primitive: 69>  self primitiveFailedtestBecomeForwardDontCopyIdentityHash  | a b identityHashOfB |  a := 'ab' copy.  b := 'cd' copy.  identityHashOfB := b identityHash.  a becomeForward: b copyHash: false.  self     assert: a identicalTo: b;     assert: a identityHash equals: identityHashOfB;     assert: b identityHash equals: identityHashOfBfindOriginMethodOf: aMethod  ^aMethod- aNumber  aNumber isInteger ifTrue: [ self negative == aNumber negative ifTrue: [ ^self digitSubtract: aNumber ] ifFalse: [ ^(self digitAdd: aNumber) normalize ] ].  aNumber isFraction ifTrue: [ ^Fraction numerator: self * aNumber denominator - aNumber numerator denominator: aNumber denominator ].  ^aNumber adaptToInteger: self andSend: #-wait  < primitive: 86>  self primitiveFailedexecutor  ^self shallowCopy actAsExecutortestHash  self assert: atPragma hash equals: atPragma hash.  self assert: atPragma hash equals: anotherAtPragma hash.  self assert: anotherAtPragma hash equals: atPragma hash.  self assert: atPragma hash equals: anotherAtPragma hash.  self assert: anotherAtPragma hash equals: yetAnotherAtPragma hash.  self assert: yetAnotherAtPragma hash equals: atPragma hashcopyWithTrailerBytes: trailer  | copy end start penultimateLiteral |  start := self initialPC.  end := self endPC.  copy := trailer createMethod: end - start + 1 class: self class header: self header.  1 to: self numLiterals do: [:i |  copy literalAt: i put: (self literalAt: i) ].  (penultimateLiteral := self penultimateLiteral) isMethodProperties ifTrue: [ copy penultimateLiteral: (penultimateLiteral copy                 setMethod: copy;                 yourself) ].  start to: end do: [:i |  copy at: i put: (self at: i) ].  ^copylocalSlots  ^self slots select: [:aSlot |  aSlot isLocal ]\\ operand  ^operand isNumber ifTrue: [ self class nanoSeconds: self asNanoSeconds \\ operand ] ifFalse: [ self - (operand * (self // operand)) ]testExample2  | producer1 producer2 monitor goal work counter goalReached activeProducers |  goal := (1 to: 1000) asOrderedCollection.  work := OrderedCollection new.  counter := 0.  goalReached := false.  activeProducers := 0.  monitor := Monitor new.  producer1 := [ monitor critical: [ activeProducers := activeProducers + 1 ].  [ monitor critical: [ monitor waitUntil: [ counter \\ 5 = 0 ].        goalReached or: [ work add: (counter := counter + 1) ].        goalReached := counter >= goal size.        monitor signal ].  goalReached ] whileFalse.  monitor critical: [ activeProducers := activeProducers - 1.        monitor signal: #finish ] ].  producer2 := [ monitor critical: [ activeProducers := activeProducers + 1 ].  [ monitor critical: [ monitor waitWhile: [ counter \\ 5 = 0 ].        goalReached or: [ work add: (counter := counter + 1) ].        goalReached := counter >= goal size.        monitor signal ].  goalReached ] whileFalse.  monitor critical: [ activeProducers := activeProducers - 1.        monitor signal: #finish ] ].  producer1 forkAt: Processor userBackgroundPriority.  producer2 forkAt: Processor userBackgroundPriority.  monitor critical: [ monitor waitUntil: [ activeProducers = 0 & goalReached ] for: #finish ].  self assert: goal equals: workvalueWithInterval: aDelay  ^[ [ self value.  aDelay wait ] repeat ] forkAt: Processor userBackgroundPriority named: (String streamContents: [:s |  s                 << 'every ';                 print: aDelay;                 << ' do: ';                 print: self ])representsSimpleAnnotationUser: someUserClass  ^self isKindOf: someUserClasstestJulianDayNumber  self assert: aDateAndTime equals: (DateAndTime julianDayNumber: 2444240).  self assert: aDateAndTime julianDayNumber equals: 2444240gtInspectorCharacterIn: composite  < gtInspectorPresentationOrder: 30>  ^composite table     title: 'Character';     display: [ {('self' -> self) .         ('codepoint' -> self codePoint) .         ('unicode' -> (String streamContents: [:stream |  stream << 'U+'.                    self codePoint printOn: stream base: 16 nDigits: 4 ]))} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: [:each |  each value printString ];     send: #valueisClassOrTrait  ^trueasSpecLayoutFrame  ^SpecLayoutFrame new     leftFraction: self left;     rightFraction: self right;     topFraction: self top;     bottomFraction: self bottom;     yourselfequals: aDate  ^self year = aDate year and: [ self monthIndex = aDate monthIndex and: [ self dayOfMonth = aDate dayOfMonth ] ]translateToUTC  ^self translateTo: 0 asDurationinspectWithLabel: aLabel  ^Smalltalk tools inspector inspect: self label: aLabelto: anEnd by: aDuration  ^(Schedule starting: self ending: anEnd asDateAndTime)     schedule: (Array with: aDuration asDuration);     yourselflink: aMetaLink toTemporary: aTempVar  self flag: 'Not sure what it should do. The tests are not passing for this... See method testLinkClassToTempVarNamed'.  aTempVar link: aMetaLinkcloseTo: aPoint  ^(x closeTo: aPoint x) and: [ y closeTo: aPoint y ]digitAt: index  self deprecated: 'Please use byteAt: instead.' transformWith: '`@receiver digitAt: `@statements1' -> '`@receiver byteAt: `@statements1'.  ^self byteAt: indexdebugWithTitle: title  | context |  context := self isActiveProcess ifTrue: [ thisContext ] ifFalse: [ self suspendedContext ].  ^self debug: context title: title full: trueauthor  self timeStamp ifNotEmpty: [:s |  | subS |        subS := s substrings first.        subS first isLetter ifTrue: [ ^subS ] ].  ^''testReciprocalModulo  | large r |  large := 1 bitShift: 48.  r := Random seed: 46912151.  4691 timesRepeat: [ | a b c t |        a := (r nextInt: large) + 1.        b := (r nextInt: large) + 1.        a > b ifTrue: [ t := a.              a := b.              b := t ].        (a gcd: b) = 1 ifTrue: [ c := a reciprocalModulo: b.              self assert: a * c \\ b equals: 1 ] ifFalse: [ self should: [ a reciprocalModulo: b ] raise: Error ] ]subclass: aTraitName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self subclass: aTraitName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' category: catsizeStoreTemp: tempIndex  ^self sizeOpcodeSelector: #genStoreTemp: withArguments: {tempIndex}rounded  ^(self + (self sign / 2)) truncatedtestBasicCheck2  | testMethod |  testMethod := testClass >> (testClass compile: 'testMethod ').  self assert: (testMethod externalProperties noneSatisfy: [:eprop |  eprop rule class = SendsDeprecatedMethodToGlobalRule ])popIntoReceiverVariable: offset  self object: self receiver instVarAt: offset + 1 put: self popunwindComplete  ^self tempAt: 2testIndexOfMonth  | m |  m := #(#January #February #March #April #May #June #July #August #September #October #November #December).  m withIndexDo: [:item :index |  self assert: (Month indexOfMonth: item) equals: index ].  self should: [ Month indexOfMonth: 1 ] raise: self defaultTestError.  self should: [ Month indexOfMonth: #Marsh ] raise: self defaultTestError.  self should: [ Month indexOfMonth: #UnexistingMonth ] raise: self defaultTestErrorreceiver  ^self at: 1categories  categoryArray ifNil: [ ^nil ].  (categoryArray size = 1 and: [ categoryArray first = Default & elementArray isEmpty ]) ifTrue: [ ^Array with: NullCategory ].  ^categoryArrayvalue  < primitive: 207>  | newContext |  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  false ifTrue: [ newContext := self asContextWithSender: thisContext sender.        thisContext privSender: newContext ] ifFalse: [ self primitiveFailed ]waitUntil: aBlock  ^self waitUntil: aBlock for: nil/ aNumber  < primitive: 50>  aNumber = 0.0 ifTrue: [ ^ZeroDivide signalWithDividend: self ].  ^aNumber adaptToFloat: self andSend: #/notifyOfChangedCategoriesFrom: oldCollectionOrNil to: newCollectionOrNil  (self hasSubject and: [ oldCollectionOrNil ~= newCollectionOrNil ]) ifTrue: [ SystemAnnouncer uniqueInstance classReorganized: self subject ]waitMaxMilliseconds: anIntegerOrNil  ^self waitFor: nil maxMilliseconds: anIntegerOrNiltestIntersectWith  self assert: (self intersect: (LinkedList with: #apple with: #banana with: #avocado) withCollection: (LinkedList with: 1 with: 2 with: #apple)) equals: (LinkedList with: #apple).  self assert: (self intersect: ((1 to: 10) as: LinkedList) withCollection: (9 to: 20)) equals: (9 to: 10).  self assert: (self intersect: ((1 to: 10) as: LinkedList) withCollection: (11 to: 20)) equals: {}stonContainSubObjects  ^false<< shiftAmount  shiftAmount < 0 ifTrue: [ self error: 'negative arg' ].  ^self bitShift: shiftAmountactAsExecutor  self breakDependentsprintOn: aStream withLeadingSpace: printLeadingSpaceToo  BasicDatePrinter default printDateAndTime: self withLeadingSpace: printLeadingSpaceToo on: aStreammethodReturnReceiver  ^self return: self receiver from: self methodReturnContexthasBreakpoint  ^Breakpoint isInstalledIn: selflogTranscript  self showWarning ifTrue: [ DeprecationPerformedNotification signal: self messageText ]criticalReleasingOnError: mutuallyExcludedBlock  | blockValue caught |  caught := false.  [ caught := true.  self wait.  blockValue := mutuallyExcludedBlock on: Exception do: [:e |  caught ifTrue: [ self signal ].        caught := false.        e pass ] ] ensure: [ caught ifTrue: [ self signal ] ].  ^blockValuelocalMethodNamed: selector ifAbsent: aBlock  ^self compiledMethodAt: selector ifAbsent: aBlockbasicReplaceFrom: start to: stop with: replacement startingAt: repStart  < primitive: 105>  start to: stop do: [:i |  self basicAt: i put: (replacement basicAt: repStart - start + i) ]testSecond  self assert: aTime second equals: 56.  self assert: aTime seconds equals: 56memoized  ^self memoizedUsing: Dictionary newclassForScheduler  ^DelayMutexSchedulerscale  ^scaledestroyTwin  self reflectiveMethod: nilheight  ^corner y - origin yreplaceFrom: start to: stop with: replacement startingAt: repStart  < primitive: 105>  ^super replaceFrom: start to: stop with: replacement startingAt: repStartglamourValue: anObject  | args |  args := anObject asGlamorousArray.  ^self glamourValueWithArgs: argscleanCopy  ^self class sender: nil receiver: receiver method: method arguments: #()hash  ^(julianDayNumber hashMultiply bitXor: seconds) bitXor: nanossqrt  self subclassResponsibilityasSeconds  ^Duration milliSeconds: self * 1000equivalentTo: aCompiledMethod  ^self = aCompiledMethod or: [ self class == aCompiledMethod class and: [ self numArgs = aCompiledMethod numArgs and: [ self numLiterals = aCompiledMethod numLiterals and: [ self methodNode = aCompiledMethod methodNode ] ] ] ]linkOf: anObject  ^self linkOf: anObject ifAbsent: [ self error: 'No such element' ]unicodeToMacRoman  ^MacRomanTextConverter new byteToUnicode: selfinstVarNames  | mySize superSize |  mySize := self instSize.  superSize := self superclass == nil ifTrue: [ 0 ] ifFalse: [ self superclass instSize ].  mySize = superSize ifTrue: [ ^#() ].  ^(superSize + 1 to: mySize) collect: [:i |  'inst' , i printString ]printOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     print: start;     nextPut: $D;     print: duration;     nextPut: $)jsonOn: aRenderer  self - self = 0.0 ifTrue: [ aRenderer number: self ] ifFalse: [ aRenderer null ]phlowValue: anObject withEnoughArguments: aCollection  ^anObject withArgs: aCollection executeMethod: selfhasProperties  ^self penultimateLiteral isMethodPropertiesasBrick  ^GLMMorphBrick on: self asMorphrunAllTests  self     runBasicTests;     runBasicANSISignaledExceptionTestsisEmpty  ^self basicSize = 0fileOut  | internalStream |  internalStream := (String new: 100) writeStream.  internalStream     header;     timeStamp.  self hasSharedPools ifTrue: [ self shouldFileOutPools ifTrue: [ self fileOutSharedPoolsOn: internalStream ] ].  self fileOutOn: internalStream.  CodeExporter writeSourceCodeFrom: internalStream baseName: self name isSt: trueprivateCleanup  queuesMutex critical: [ defaultQueue isEmpty ifTrue: [ defaultQueue := nil ].        queueDict ifNotNil: [ queueDict copy keysAndValuesDo: [:id :queue |  queue isEmpty ifTrue: [ queueDict removeKey: id ] ].              queueDict isEmpty ifTrue: [ queueDict := nil ] ] ]schedule  self class scheduler schedule: selfreformatAll  self methods do: [:method |  method reformat ]unpin  self unpinInMemoryabbreviation  ^String streamContents: [:s |  s           nextPutAll: 'LT';           print: self offset hours;           nextPut: $:.        s nextPutAll: (self offset minutes printPaddedWith: $0 to: 2) ]bootstrapPackages  ^#(#'AST-Core' #'Announcements-Core' #CodeExport #CodeImport #CodeImportCommandLineHandlers #Collections #Compression #'FileSystem-Core' #'FileSystem-Disk' #Files #Jobs #Kernel #Monticello #'Multilingual-Encodings' #'Multilingual-Languages' #'Multilingual-TextConversion' #'Network-UUID' #'OpalCompiler-Core' #'Random-Core' #'RPackage-Core' #'Ring-Definitions-Containers' #'Ring-Definitions-Core' #'Ring-Definitions-Monticello' #'Ring-OldChunkImporter' #'Slot-Core' #'System-Announcements' #'System-BasicCommandLineHandler' #'System-Changes' #'System-CommandLine' #'System-CommandLineHandler' #'System-Finalization' #'System-Hashing' #'System-Localization' #'System-Model' #'System-Platforms' #'System-SessionManager' #'System-Sources' #'System-Support' #Traits #'Transcript-Core' #UIManager #'Collections-Abstract' #'Collections-Arithmetic' #'Collections-Native' #'Collections-Sequenceable' #'Collections-Stack' #'Collections-Streams' #'Collections-Strings' #'Collections-Support' #'Collections-Unordered' #'Collections-Weak' #'Zinc-Character-Encoding-Core' #'Zinc-Resource-Meta-Core' #'PharoBootstrap-Initialization' #'Transcript-NonInteractive')ceiling  | truncation |  truncation := self truncated.  self <= 0 ifTrue: [ ^truncation ].  ^self = truncation ifTrue: [ truncation ] ifFalse: [ truncation + 1 ]new: sizeRequested  ^(self basicNew: sizeRequested) initializeasMorph  ^self asStringMorphnanoSeconds  ^Duration nanoSeconds: selfblockNodes  ^self methods flatCollect: [:each |  each blockNodes ]decodeClearedTrailer  self decodeLengthFielddeprecated: anExplanationString on: date in: version transformWith: aRule when: conditionBlock  Deprecation new     context: thisContext sender;     explanation: anExplanationString;     date: date;     version: version;     rule: aRule;     condition: conditionBlock;     transformasFloat  < primitive: 40>  self primitiveFailedstonOn: stonWriter  stonWriter writeObject: self streamShortList: [:array |  array           add: x;           add: y ]valueWithArguments: anArray  anArray size = 1 ifFalse: [ ^self error: 'continuations can only be resumed with one argument' ].  self value: anArray firststepTime  ^1000stepToHome: aContext  | home ctxt here error topContext context |  here := thisContext.  ctxt := self step.  ctxt = self ifFalse: [ error := nil.        context := aContext insertSender: (Context contextOn: UnhandledError do: [:ex |  error ifNil: [ error := ex exception.                          topContext := thisContext.                          ex resumeUnchecked: here jump ] ifNotNil: [ ex pass ] ]) ].  home := aContext home.  home == ctxt home ifTrue: [ ^{ctxt .         nil} ].  [ ctxt := ctxt step.  error ifNotNil: [ context ifNotNil: [ aContext terminateTo: context sender ].        ^{ctxt .         error} ].  home == ctxt home ] whileFalse: [ home isDead ifTrue: [ ^{ctxt .               nil} ] ].  context ifNotNil: [ aContext terminateTo: context sender ].  ^{ctxt .   nil}add: anAssociation  ^self at: anAssociation key put: anAssociation valueclassSymbol  ^self variableNode namecombined  ^combinedtestVeryDeepCopyWith  self assert: (nil veryDeepCopyWith: nil) isNiltestHandlerContext  | result |  result := [ [ [ MyResumableTestError signal ] on: MyTestError do: [ 'handler 2' ] ] on: MyResumableTestError do: [ MyTestError signal ] ] on: MyTestError do: [ 'handler 1' ].  self assert: 'handler 1' = result description: 'Incorrect handler'signal  < primitive: 85>  self primitiveFailedanyActive  ^activeDelay notNilisSelfEvaluating  ^truepackToArity: aNumber  ^selfhasActionsWithReceiver: anObject  ^self actionMap keys anySatisfy: [:eachEventSelector |  (self actionSequenceForEvent: eachEventSelector) anySatisfy: [:anAction |  anAction receiver == anObject ] ]sizeStorePopLiteralVar: literalIndex  ^self sizeOpcodeSelector: #genStorePopLiteralVar: withArguments: {literalIndex}eqv: aBoolean  ^self == aBooleantestParsingMPatternWithSingleDigitSucceeds  | date |  date := Date year: 2013 month: 2 day: 11.  self assertReading: '11.2.2013' as: 'dd.m.yyyy' equals: date.  self assertReading: '2.2013.11' as: 'm.yyyy.dd' equals: date.  self assertReading: '11.2013.2' as: 'dd.yyyy.m' equals: datedragPassengersFor: item inMorph: dragSource  ^{item}whichClassDefinesClassVar: aString  Symbol hasInterned: aString ifTrue: [:aSymbol |  ^self whichSuperclassSatisfies: [:aClass |  aClass classVarNames anySatisfy: [:each |  each = aSymbol ] ] ].  ^#()messageText  ^String streamContents: [:str |  originName putOn: str.        str nextPutAll: ' ('.        undeclaredName putOn: str.        str nextPutAll: ' is Undeclared)' ]critical: mutuallyExcludedBlock ifCurtailed: terminationBlock  ^self critical: [ mutuallyExcludedBlock ifCurtailed: terminationBlock ]asHistoricalRingDefinition  | ring |  ring := (RGMethodDefinition named: self selector)     parentName: self methodClass name;     isMetaSide: self methodClass isMeta.  self sourcePointer isZero ifTrue: [ ring           protocol: self category;           sourceCode: self sourceCode;           stamp: self timeStamp ] ifFalse: [ ring sourcePointer: self sourcePointer ].  ring asHistorical.  ^ringgenerateDelayProcesses: numberConcurrent priority: priority maxDuration: maxDuration fromSeed: seed  | randomGenerator sampleDurations sampleIndex |  randomGenerator := Random seed: seed.  sampleDurations := Array new: 1000.  1 to: sampleDurations size do: [:index |  sampleDurations at: index put: (randomGenerator nextInt: maxDuration) ].  sampleIndex := 0.  ^(1 to: numberConcurrent) collect: [:each |  [ [ | delay |        sampleIndex := (sampleIndex rem: sampleDurations size) + 1.        delay := Delay forMilliseconds: (sampleDurations at: sampleIndex).        EnterCount := EnterCount + 1.        delay wait.        ExitCount := ExitCount + 1.        Running ] whileTrue ] newProcess priority: priority ]largeIdentityHash  ^self identityHashasScaledDecimal  | pow2 pow5 q q5 |  pow2 := denominator lowBit - 1.  q := denominator bitShift: pow2 negated.  pow5 := 0.  [ q = 1 ] whileFalse: [ q5 := q // 5.        q - (5 * q5) = 0 ifFalse: [ ^super asScaledDecimal ].        q := q5.        pow5 := pow5 + 1 ].  ^self asScaledDecimal: (pow2 max: pow5)metaLinkOptions  ^{(#scanFor: -> #(+ optionCompileOnLinkInstallation)) .   (#at:put: -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}radiansToDegrees  ^self asFloat radiansToDegreesveryDeepCopyWith: deepCopier  ^selffindUndeclaredVariableIn: ast  ast nodesDo: [:node |  (node isVariable and: [ node isUndeclared ]) ifTrue: [ ^node ] ].  ^nilclassBinding  ^self literalAt: self numLiteralsallCallsOn: aSymbol  ^self withAllSubclasses flatCollect: [:cls |  cls thoroughWhichMethodsReferTo: aSymbol ]simpleEnsureTestWithNotificationResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingElseString;     add: self doYetAnotherThingString;     yourselfasDuration  ^Duration seconds: self secondsSinceMidnightLocalTime nanoSeconds: nanosencodeNoTrailer  size := 4.  encodedData := #[0 0 0 0]testDuration  self assert: aTimespan duration equals: aWeek.  aTimespan duration: aDay.  self assert: aTimespan duration equals: aDaytestShiftOneLeftThenRight  1 to: 100 do: [:i |  self assert: ((1 bitShift: i) bitShift: i negated) equals: 1 ]primitive  ^0asValueHolder  ^NewValueHolder value: selfzapOrganization  self organization: nil.  self isClassSide ifFalse: [ self classSide zapOrganization ]rfactiveProcess  < metaLinkOptions: #(+ optionDisabledLink)>  ^activeProcess rfeffectiveProcessnumTemps  ^self numCopiedValues + self numArgs + self numLocalTempsraisedTo: aNumber  aNumber isInteger ifTrue: [ ^self raisedToInteger: aNumber ].  aNumber isFraction ifTrue: [ ^self raisedToFraction: aNumber ].  self < 0 ifTrue: [ ^ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].  0 = aNumber ifTrue: [ ^self class one ].  1 = aNumber ifTrue: [ ^self ].  0 = self ifTrue: [ aNumber < 0 ifTrue: [ ^(ZeroDivide dividend: 1) signal ] ifFalse: [ ^self ] ].  ^(aNumber * self ln) exptestAddDays  self assert: (january23rd2004 addDays: 0) equals: '2004-01-23' asDate.  self assert: (january23rd2004 addDays: 31) equals: '2004-02-23' asDate.  self assert: (january23rd2004 addDays: 366) equals: '2005-01-23' asDatetestFractionPrinting  self assert: (353 / 359) printString equals: '(353/359)'.  self assert: (2 / 3 printStringBase: 2) equals: '(10/11)'.  self assert: (2 / 3 storeStringBase: 2) equals: '(2r10/2r11)'.  self assert: (5 / 7 printStringBase: 3) equals: '(12/21)'.  self assert: (5 / 7 storeStringBase: 3) equals: '(3r12/3r21)'.  self assert: (11 / 13 printStringBase: 4) equals: '(23/31)'.  self assert: (11 / 13 storeStringBase: 4) equals: '(4r23/4r31)'.  self assert: (17 / 19 printStringBase: 5) equals: '(32/34)'.  self assert: (17 / 19 storeStringBase: 5) equals: '(5r32/5r34)'.  self assert: (23 / 29 printStringBase: 6) equals: '(35/45)'.  self assert: (23 / 29 storeStringBase: 6) equals: '(6r35/6r45)'.  self assert: (31 / 37 printStringBase: 7) equals: '(43/52)'.  self assert: (31 / 37 storeStringBase: 7) equals: '(7r43/7r52)'.  self assert: (41 / 43 printStringBase: 8) equals: '(51/53)'.  self assert: (41 / 43 storeStringBase: 8) equals: '(8r51/8r53)'.  self assert: (47 / 53 printStringBase: 9) equals: '(52/58)'.  self assert: (47 / 53 storeStringBase: 9) equals: '(9r52/9r58)'.  self assert: (59 / 61 printStringBase: 10) equals: '(59/61)'.  self assert: (59 / 61 storeStringBase: 10) equals: '(59/61)'.  self assert: (67 / 71 printStringBase: 11) equals: '(61/65)'.  self assert: (67 / 71 storeStringBase: 11) equals: '(11r61/11r65)'.  self assert: (73 / 79 printStringBase: 12) equals: '(61/67)'.  self assert: (73 / 79 storeStringBase: 12) equals: '(12r61/12r67)'.  self assert: (83 / 89 printStringBase: 13) equals: '(65/6B)'.  self assert: (83 / 89 storeStringBase: 13) equals: '(13r65/13r6B)'.  self assert: (97 / 101 printStringBase: 14) equals: '(6D/73)'.  self assert: (97 / 101 storeStringBase: 14) equals: '(14r6D/14r73)'.  self assert: (103 / 107 printStringBase: 15) equals: '(6D/72)'.  self assert: (103 / 107 storeStringBase: 15) equals: '(15r6D/15r72)'.  self assert: (109 / 113 printStringBase: 16) equals: '(6D/71)'.  self assert: (109 / 113 storeStringBase: 16) equals: '(16r6D/16r71)'.  self assert: (127 / 131 printStringBase: 17) equals: '(78/7C)'.  self assert: (127 / 131 storeStringBase: 17) equals: '(17r78/17r7C)'.  self assert: (137 / 139 printStringBase: 18) equals: '(7B/7D)'.  self assert: (137 / 139 storeStringBase: 18) equals: '(18r7B/18r7D)'.  self assert: (149 / 151 printStringBase: 19) equals: '(7G/7I)'.  self assert: (149 / 151 storeStringBase: 19) equals: '(19r7G/19r7I)'.  self assert: (157 / 163 printStringBase: 20) equals: '(7H/83)'.  self assert: (157 / 163 storeStringBase: 20) equals: '(20r7H/20r83)'.  self assert: (167 / 173 printStringBase: 21) equals: '(7K/85)'.  self assert: (167 / 173 storeStringBase: 21) equals: '(21r7K/21r85)'.  self assert: (179 / 181 printStringBase: 22) equals: '(83/85)'.  self assert: (179 / 181 storeStringBase: 22) equals: '(22r83/22r85)'.  self assert: (191 / 193 printStringBase: 23) equals: '(87/89)'.  self assert: (191 / 193 storeStringBase: 23) equals: '(23r87/23r89)'.  self assert: (197 / 199 printStringBase: 24) equals: '(85/87)'.  self assert: (197 / 199 storeStringBase: 24) equals: '(24r85/24r87)'.  self assert: (211 / 223 printStringBase: 25) equals: '(8B/8N)'.  self assert: (211 / 223 storeStringBase: 25) equals: '(25r8B/25r8N)'.  self assert: (227 / 229 printStringBase: 26) equals: '(8J/8L)'.  self assert: (227 / 229 storeStringBase: 26) equals: '(26r8J/26r8L)'.  self assert: (233 / 239 printStringBase: 27) equals: '(8H/8N)'.  self assert: (233 / 239 storeStringBase: 27) equals: '(27r8H/27r8N)'.  self assert: (241 / 251 printStringBase: 28) equals: '(8H/8R)'.  self assert: (241 / 251 storeStringBase: 28) equals: '(28r8H/28r8R)'.  self assert: (257 / 263 printStringBase: 29) equals: '(8P/92)'.  self assert: (257 / 263 storeStringBase: 29) equals: '(29r8P/29r92)'.  self assert: (269 / 271 printStringBase: 30) equals: '(8T/91)'.  self assert: (269 / 271 storeStringBase: 30) equals: '(30r8T/30r91)'.  self assert: (277 / 281 printStringBase: 31) equals: '(8T/92)'.  self assert: (277 / 281 storeStringBase: 31) equals: '(31r8T/31r92)'.  self assert: (283 / 293 printStringBase: 32) equals: '(8R/95)'.  self assert: (283 / 293 storeStringBase: 32) equals: '(32r8R/32r95)'.  self assert: (307 / 311 printStringBase: 33) equals: '(9A/9E)'.  self assert: (307 / 311 storeStringBase: 33) equals: '(33r9A/33r9E)'.  self assert: (313 / 317 printStringBase: 34) equals: '(97/9B)'.  self assert: (313 / 317 storeStringBase: 34) equals: '(34r97/34r9B)'.  self assert: (331 / 337 printStringBase: 35) equals: '(9G/9M)'.  self assert: (331 / 337 storeStringBase: 35) equals: '(35r9G/35r9M)'.  self assert: (347 / 349 printStringBase: 36) equals: '(9N/9P)'.  self assert: (347 / 349 storeStringBase: 36) equals: '(36r9N/36r9P)'.  self assert: (-2 / 3 printStringBase: 2) equals: '(-10/11)'.  self assert: (-2 / 3 storeStringBase: 2) equals: '(-2r10/2r11)'.  self assert: (5 / -7 printStringBase: 3) equals: '(-12/21)'.  self assert: (5 / -7 storeStringBase: 3) equals: '(-3r12/3r21)'guarded  self max: 1 @ 1fromSpec: aSpec  aSpec do: [:spec |  | name methods |        name := spec first asSymbol.        methods := spec allButFirst asSet.        self addProtocol: (Protocol name: name methodSelectors: methods) ]sizePop  ^self sizeOpcodeSelector: #genPop withArguments: #()testAsDay  | full half quarter |  full := Duration minutes: 60 * 24.  half := Duration minutes: 60 * 12.  quarter := Duration minutes: 60 * 6.  self     assert: 1 day equals: full;     assert: 1.0 day equals: full;     assert: 0.5 day equals: half;     assert: (1 / 2) day equals: half;     assert: (1 / 4) day equals: quarter.  self assert: 0.4 day + 0.6 day equals: 1 daymessageText  ^messageText ifNil: [ messageText := self standardMessageText ]waitForUserSignalled: timingSemaphore orExpired: activeDelay  | nextTick |  nextTick := 0.  activeDelay ifNotNil: [ nextTick := nextTick min: activeDelay resumptionTick ].  timingSemaphore initSignals.  self primSignal: timingSemaphore atUTCMicroseconds: nextTick.  timingSemaphore waitvalue: anObject1 value: anObject2 value: anObject3  ^receiver perform: selector with: anObject1 with: anObject2 with: anObject3testDaysOfWeekAreConsistent  | originalDayOfWeekSet modifiedDayOfWeekSet start end |  originalDayOfWeekSet := (aSchedule dateAndTimes collect: [:each |  each dayOfWeek ]) asSet.  start := DateAndTime year: 2003 month: 1 day: 5 hour: 20 minute: 30.  end := DateAndTime year: 2003 month: 6 day: 4 hour: 20 minute: 30.  modifiedDayOfWeekSet := OrderedCollection new.  aSchedule between: start and: end do: [:eachStart |  modifiedDayOfWeekSet add: eachStart dayOfWeek ].  self assert: originalDayOfWeekSet equals: modifiedDayOfWeekSet asSetisSpAnnouncingObject  ^falseliteralAt: index put: value  ^self objectAt: index + 1 put: valueon: exception do: handlerAction  | currentContext root newRoot |  currentContext := self isActiveProcess ifTrue: [ thisContext ] ifFalse: [ self suspendedContext ].  root := currentContext bottomContext.  newRoot := [ [ root insertSender: thisContext.  currentContext jump ] on: exception do: handlerAction.  Processor terminateActive ] asContext.  self isActiveProcess ifTrue: [ newRoot jump ] ifFalse: [ self install: newRoot ]previousPc  ^self method pcPreviousTo: pcstoreIntoReceiverVariable: offset  self object: self receiver instVarAt: offset + 1 put: self topclassInstaller  ^self isAnonymous ifTrue: [ Smalltalk anonymousClassInstaller ] ifFalse: [ Smalltalk classInstaller ]putCommentOnFile: aFileStream forClass: aClass  | header |  self classComment isEmptyOrNil ifTrue: [ ^self ].  aFileStream     cr;     nextPut: $!.  header := String streamContents: [:strm |  strm           nextPutAll: aClass name;           nextPutAll: ' commentStamp: '.        commentStamp ifNil: [ commentStamp := '<historical>' ].        commentStamp storeOn: strm.        strm           nextPutAll: ' prior: ';           nextPutAll: '0' ].  aFileStream nextChunkPut: header.  aClass organization fileOutCommentOn: aFileStream.  aFileStream cr- operand  ^(operand respondsTo: #asDateAndTime) ifTrue: [ | other |        other := operand asDateAndTime.        Duration seconds: SecondsInDay * (julianDayNumber - other julianDayNumberUTC) + (seconds - other secondsSinceMidnightUTC) nanoSeconds: nanos - other nanoSecond ] ifFalse: [ self + operand negated ]primitiveFailed  self primitiveFailed: thisContext sender selectorusers  ^#()testCopyWithTrailerBytes  < pragma: #pragma>  | method copy |  method := thisContext method.  self assert: method pragmas notEmpty.  copy := method copyWithTrailerBytes: method trailer.  self assert: (method equivalentTo: copy).  self deny: method identicalTo: copy.  self assert: method symbolic equals: copy symbolic.  self assert: method ~~ copy.  self assert: copy penultimateLiteral method identicalTo: copy.  self assert: method penultimateLiteral method identicalTo: method.  method pragmas do: [:p |  self assert: p method identicalTo: method ].  copy pragmas do: [:p |  self assert: p method identicalTo: copy ]-> anObject  ^Association key: self value: anObjectexpectedArgumentsCount: anObject  expectedArgumentsCount := anObjectgenPushNClosureTemps: numTemps  numTemps timesRepeat: [ self genPushSpecialLiteral: nil ]newRectButtonPressedDo: newRectBlock  | rect newRect buttonNow hand |  hand := self currentWorld activeHand.  buttonNow := hand anyButtonPressed.  rect := self.  self drawReverseFrame: rect.  hand captureEventsWhile: [:evt |  evt isMouse ifTrue: [ buttonNow := evt anyButtonPressed.              newRect := newRectBlock value: rect value: evt cursorPoint.              newRect = rect ifFalse: [ self drawReverseFrame: rect.                    self drawReverseFrame: newRect.                    rect := newRect ].              buttonNow ] ifFalse: [ true ] ].  self drawReverseFrame: rect.  self currentWorld activeHand     newMouseFocus: nil;     showTemporaryCursor: nil.  ^rectmetaLinkOptions  ^{(#selector -> #(+ optionCompileOnLinkInstallation)) .   (#isMethodProperties -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}compressed  ^Rectangle origin: origin ceiling corner: corner floorreadFromString: aString  ^self readFrom: aString readStreamcompiler  ^self methodClass compilertestDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 1testMultiply  self assert: aDuration * 2 equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10)interpretV3ClosuresExtension: offset in: method for: client  | type offset2 byte2 byte3 byte4 |  offset <= 6 ifTrue: [ byte2 := method at: pc.        pc := pc + 1.        offset <= 2 ifTrue: [ type := byte2 // 64.              offset2 := byte2 \\ 64.              offset = 0 ifTrue: [ type = 0 ifTrue: [ ^client pushReceiverVariable: offset2 ].                    type = 1 ifTrue: [ ^client pushTemporaryVariable: offset2 ].                    type = 2 ifTrue: [ ^client pushConstant: (method literalAt: offset2 + 1) ].                    type = 3 ifTrue: [ ^client pushLiteralVariable: (method literalAt: offset2 + 1) ] ].              offset = 1 ifTrue: [ type = 0 ifTrue: [ ^client storeIntoReceiverVariable: offset2 ].                    type = 1 ifTrue: [ ^client storeIntoTemporaryVariable: offset2 ].                    type = 2 ifTrue: [ self error: 'illegalStore' ].                    type = 3 ifTrue: [ ^client storeIntoLiteralVariable: (method literalAt: offset2 + 1) ] ].              offset = 2 ifTrue: [ type = 0 ifTrue: [ ^client popIntoReceiverVariable: offset2 ].                    type = 1 ifTrue: [ ^client popIntoTemporaryVariable: offset2 ].                    type = 2 ifTrue: [ self error: 'illegalStore' ].                    type = 3 ifTrue: [ ^client popIntoLiteralVariable: (method literalAt: offset2 + 1) ] ] ].        offset = 3 ifTrue: [ ^client send: (method literalAt: byte2 \\ 32 + 1) super: false numArgs: byte2 // 32 ].        offset = 4 ifTrue: [ byte3 := method at: pc.              pc := pc + 1.              type := byte2 // 32.              type = 0 ifTrue: [ ^client send: (method literalAt: byte3 + 1) super: false numArgs: byte2 \\ 32 ].              type = 1 ifTrue: [ ^client send: (method literalAt: byte3 + 1) super: true numArgs: byte2 \\ 32 ].              type = 2 ifTrue: [ ^client pushReceiverVariable: byte3 ].              type = 3 ifTrue: [ ^client pushConstant: (method literalAt: byte3 + 1) ].              type = 4 ifTrue: [ ^client pushLiteralVariable: (method literalAt: byte3 + 1) ].              type = 5 ifTrue: [ ^client storeIntoReceiverVariable: byte3 ].              type = 6 ifTrue: [ ^client popIntoReceiverVariable: byte3 ].              type = 7 ifTrue: [ ^client storeIntoLiteralVariable: (method literalAt: byte3 + 1) ] ].        offset = 5 ifTrue: [ ^client send: (method literalAt: byte2 \\ 32 + 1) super: true numArgs: byte2 // 32 ].        offset = 6 ifTrue: [ ^client send: (method literalAt: byte2 \\ 64 + 1) super: false numArgs: byte2 // 64 ] ].  offset = 7 ifTrue: [ ^client doPop ].  offset = 8 ifTrue: [ ^client doDup ].  offset = 9 ifTrue: [ ^client pushActiveContext ].  byte2 := method at: pc.  pc := pc + 1.  offset = 10 ifTrue: [ ^byte2 < 128 ifTrue: [ client pushNewArrayOfSize: byte2 ] ifFalse: [ client pushConsArrayWithElements: byte2 - 128 ] ].  byte3 := method at: pc.  pc := pc + 1.  offset = 11 ifTrue: [ ^client callPrimitive: byte2 + (byte3 bitShift: 8) ].  offset = 12 ifTrue: [ ^client pushRemoteTemp: byte2 inVectorAt: byte3 ].  offset = 13 ifTrue: [ ^client storeIntoRemoteTemp: byte2 inVectorAt: byte3 ].  offset = 14 ifTrue: [ ^client popIntoRemoteTemp: byte2 inVectorAt: byte3 ].  byte4 := method at: pc.  pc := pc + 1.  ^client pushClosureCopyNumCopiedValues: (byte2 bitShift: -4) numArgs: (byte2 bitAnd: 16rF) blockSize: byte3 * 256 + byte4terminate: aContext  | context |  context := aContext.  [ context notNil ] whileTrue: [ context := context swapSender: nil ]gtInspectorMetaIn: composite  < gtInspectorPresentationOrder: 1000>  < gtInspectorTag: #basic>  ^composite custom: (GTSimpleMethodsBrowser new startOn: self)asStringMorph  ^self asString asStringMorphisZero  ^seconds = 0 and: [ nanos = 0 ]testExactRaisedTo  self assert: (4 raisedTo: 1 / 2) classAndValueEquals: 2.  self assert: (9 raisedTo: 1 / 2) classAndValueEquals: 3.  self assert: (9 raisedTo: -1 / 2) classAndValueEquals: 1 / 3.  self assert: (-1 raisedTo: 1 / 3) classAndValueEquals: -1.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:i |  self assert: (i squared raisedTo: 1 / 2) classAndValueEquals: i.        self assert: (i negated squared raisedTo: 1 / 2) classAndValueEquals: i ].  self assert: (8 raisedTo: 1 / 3) classAndValueEquals: 2.  self assert: (27 raisedTo: 1 / 3) classAndValueEquals: 3.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:i |  self assert: ((i raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: i.        self assert: ((i negated raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: i negated ].  self assert: (4 raisedTo: 3 / 2) classAndValueEquals: 8.  self assert: (8 raisedTo: 2 / 3) classAndValueEquals: 4.  self assert: (8 raisedTo: -2 / 3) classAndValueEquals: 1 / 4.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:i |  self assert: ((i raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: i * i.        self assert: ((i raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: i * i * i.        self assert: ((i negated raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: i * i.        self assert: ((i negated raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: i * i * i ].  self assert: (32 raisedTo: 3 / 5) classAndValueEquals: 8.  self assert: (8 raisedTo: 5 / 3) classAndValueEquals: 32.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:i |  self assert: ((i raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: i * i * i.        self assert: ((i raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: i * i * i * i * i.        self assert: ((i negated raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: (i * i * i) negated.        self assert: ((i negated raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: (i * i * i * i * i) negated.        self assert: ((i raisedTo: -5) raisedTo: 3 / 5) classAndValueEquals: 1 / (i * i * i).        self assert: ((i raisedTo: -3) raisedTo: 5 / 3) classAndValueEquals: 1 / (i * i * i * i * i).        self assert: ((i negated raisedTo: -5) raisedTo: 3 / 5) classAndValueEquals: -1 / (i * i * i).        self assert: ((i negated raisedTo: -3) raisedTo: 5 / 3) classAndValueEquals: -1 / (i * i * i * i * i).        self assert: ((i raisedTo: 5) raisedTo: -3 / 5) classAndValueEquals: 1 / (i * i * i).        self assert: ((i raisedTo: 3) raisedTo: -5 / 3) classAndValueEquals: 1 / (i * i * i * i * i).        self assert: ((i negated raisedTo: 5) raisedTo: -3 / 5) classAndValueEquals: -1 / (i * i * i).        self assert: ((i negated raisedTo: 3) raisedTo: -5 / 3) classAndValueEquals: -1 / (i * i * i * i * i).        self assert: ((i raisedTo: 3) + 1 raisedTo: 5 / 3) isFloat.        self assert: ((i negated raisedTo: 3) - 1 raisedTo: 5 / 3) isFloat ]temporaryVariableNamed: aName  (self hasTemporaryVariableNamed: aName) ifFalse: [ ^nil ].  ^TemporaryVariable name: aName context: selfbindingOf: varName  | aSymbol |  aSymbol := varName asSymbol.  ^(self innerBindingOf: aSymbol) ifNil: [ self environment bindingOf: aSymbol ]testHash  self assert: aDuration hash equals: (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) hashremove: anObj oneStarWithTry: aTree  ^Continuation try: [:oh |  self remove: anObj oneStarWithTry: aTree continuation: oh ] otherwise: [ aTree ]addClassVarNamed: aString  self addClassVariable: aString asSymbol => ClassVariabletestMixedMethod  | result |  self should: [ result := self mixedMethod ] notTakeMoreThanMilliseconds: 3.  self assert: result equals: 2ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock  self subclassResponsibilitywillStorePop  ^self method encoderClass isStorePopAt: pc in: self methodtestActiveBlockContextHomeAndActiveHome  [ self assert: thisContext home identicalTo: thisContext activeHome ] valuetestExactSqrt  self assert: 4 sqrt classAndValueEquals: 2.  self assert: 9 sqrt classAndValueEquals: 3.  self assert: Float maxExactInteger squared sqrt classAndValueEquals: Float maxExactInteger.  self assert: (Float maxExactInteger + 1) squared sqrt classAndValueEquals: Float maxExactInteger + 1.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:i |  self assert: i squared sqrt classAndValueEquals: i ]associationAt: key ifAbsent: aBlock  ^(array at: (self scanFor: key)) ifNil: [ aBlock value ] ifNotNil: [:value |  key -> value ]setUp  super setUp.  aBlockContext := [ 100 @ 100 corner: 200 @ 200 ].  contextOfaBlockContext := thisContextadaptToFraction: rcvr andSend: selector  ^self adaptToNumber: rcvr andSend: selectorvariable: aVariable  variable := aVariabletestDaysLeftInYear  self assert: aDateAndTime daysLeftInYear equals: 364isAfter: aDate  | otherDate |  otherDate := aDate asDate.  ^self year > otherDate year or: [ self year = otherDate year and: [ self monthIndex > otherDate monthIndex or: [ self monthIndex = otherDate monthIndex and: [ self dayOfMonth > otherDate dayOfMonth ] ] ] ]enter  self isOwnerProcess ifTrue: [ nestingLevel := nestingLevel + 1 ] ifFalse: [ mutex wait.        ownerProcess := Processor activeProcess.        nestingLevel := 1 ]protocolNamed: aString  ^self protocolOrganizer protocolNamed: aString ifAbsent: [ nil ]deprecated: anExplanationString on: date in: version  Deprecation new     context: thisContext sender;     explanation: anExplanationString;     date: date;     version: version;     signaltestMaxVal  Smalltalk vm wordSize = 4 ifTrue: [ self assert: SmallInteger maxVal equals: 16r3FFFFFFF ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: SmallInteger maxVal equals: 16rFFFFFFFFFFFFFFF ]schedule  ^schedulenegated  ^0 - selfdebugStackOn: aStream  ^self debugStack: 100 on: aStream<= anInteger  < primitive: 25>  ^super <= anIntegerisResumable  ^truetranslateBy: delta  ^(delta x + x) @ (delta y + y)as: aSimilarClass  aSimilarClass == self class ifTrue: [ ^self ].  ^aSimilarClass newFrom: selfremoveAllObsoleteSubclasses  self basicObsoleteSubclasses removeKey: self ifAbsent: [  ]rounded  self isIntegerPoint ifTrue: [ ^self ].  ^x rounded @ y roundedreadNextChar  char := patternStream nexttestIsLetterNumber  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isLetterNumber: ch) equals: (charset isLetterNumber: ch) ]uses: aTraitCompositionOrArray instanceVariableNames: instVarString  ^self uses: aTraitCompositionOrArray slots: instVarString asSlotCollectiontestEnvironment: anObject  testEnvironment := anObjectdependenciesOf: aPackageName  ^#(Foo Bar)// aNumber  | q |  aNumber = 0 ifTrue: [ ^(ZeroDivide dividend: self) signal ].  self = 0 ifTrue: [ ^0 ].  q := self quo: aNumber.  (q negative ifTrue: [ q * aNumber ~= self ] ifFalse: [ q = 0 and: [ self negative ~= aNumber negative ] ]) ifTrue: [ ^q - 1 ] ifFalse: [ ^q ]testMonotonicity  | t1 t2 t3 t4 |  t1 := DateAndTime now.  t2 := DateAndTime now.  (Delay forMilliseconds: 1000) wait.  t3 := DateAndTime now.  t4 := DateAndTime now.  self     assert: t1 <= t2;     assert: t2 < t3;     assert: t3 <= t4isPool  ^falseasTime  ^selftestUnionWithSelf  self assert: (aTimespan union: aTimespan) equals: aTimespanisUndefined  ^self instanceSide inheritsFrom: UndefinedClasstestMinutes  self assert: aDuration minutes equals: 3.  self assert: (Duration minutes: 3) minutes equals: 3genBranchPopFalse: distance  (distance > 0 and: [ distance < 9 ]) ifTrue: [ stream nextPut: 191 + distance.        ^self ].  ^self genBranchPopFalseLong: distancetestNext  | nextDay |  nextDay := june2nd1973 next.  self assert: nextDay equals: '3 June, 1973' asDatetimesRepeat: aBlock  | count |  count := 1.  [ count <= self ] whileTrue: [ aBlock value.        count := count + 1 ]testFromSeconds  self assert: aDateAndTime equals: (DateAndTime fromSeconds: 2177452800)testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 0.  self assert: aDateAndTime hour equals: aDateAndTime hoursintersect: aRectangle  ^self intersect: aRectangle ifNone: [ 0 @ 0 extent: 0 @ 0 ]tryPrimitiveFor: aMethod receiver: aReceiver args: arguments  | primIndex |  (primIndex := aMethod primitive) = 0 ifTrue: [ ^self class primitiveFailToken ].  ^self doPrimitive: primIndex method: aMethod receiver: aReceiver args: argumentssubclass: subclassName uses: aTraitComposition layout: aLayout slots: someSlots classVariables: someClassVariables poolDictionaries: somePoolDictionaries package: aCategory  ^self classInstaller make: [:builder |  builder           name: subclassName;           superclass: self;           slots: someSlots;           layoutClass: aLayout;           sharedVariables: someClassVariables;           sharedPools: somePoolDictionaries;           traitComposition: aTraitComposition asTraitComposition;           classTraitComposition: aTraitComposition asTraitComposition classComposition;           category: aCategory ]timeZoneName  ^self timeZone nametestclassVarNames  self assert: (Object classVarNames includes: #DependentsFields).  self assert: Object classVarNames equals: Object class classVarNamesexplanationString  ^explanationStringsignal  ^self signal: nilwhichMethodsReferTo: aLiteral  ^self methods select: [:method |  method hasLiteral: aLiteral ]translateBy: factor  ^Rectangle origin: origin + factor corner: corner + factorpositive  ^seconds = 0 ifTrue: [ nanos positive ] ifFalse: [ seconds positive ]= aNumber  aNumber isNumber ifFalse: [ ^false ].  aNumber isInteger ifTrue: [ aNumber negative == self negative ifTrue: [ ^(self bytesCompare: aNumber) = 0 ] ifFalse: [ ^false ] ].  ^aNumber adaptToInteger: self andCompare: #=wantsStepsIn: aSystemWindow  ^self wantsStepsperform: selector withArguments: argArray  < reflective: #object:performMessageWithArgs:>  < primitive: 84>  ^self perform: selector withArguments: argArray inSuperclass: self class* aNumber  < primitive: 9>  ^super * aNumbernext  ^self class starting: start + duration duration: durationdayOfMonth  ^self dayMonthYearDo: [:d :m :y |  d ]analogousCodeTo: anObject  ^self class == anObject class and: [ selector == anObject selector and: [ args = anObject arguments and: [ lookupClass == anObject lookupClass ] ] ]testHasSlot  self assert: (Context hasSlot: (Context slotNamed: #sender)).  self deny: (Context definesSlot: (Context slotNamed: #sender))testHasPoolVarNamed  self assert: (Date usesLocalPoolVarNamed: 'DayNames').  self deny: (Date class usesLocalPoolVarNamed: 'DayNames').  self assert: (RootClassPoolUser usesLocalPoolVarNamed: 'Author').  self deny: (SubclassPoolUser usesLocalPoolVarNamed: 'Author')start  ^self timespans first starttestInexactSqrt  | tenth sqrt3 sqrtTenth three |  three := 3.0s1.  sqrt3 := three sqrt.  self assert: sqrt3 isFloat.  self deny: sqrt3 squared equals: 3.  tenth := 0.10s2.  sqrtTenth := tenth sqrt.  self assert: sqrtTenth isFloat.  self deny: sqrtTenth squared equals: tenthtestDenormalizedPrintString  | i i0 |  i := LargeNegativeInteger new: 4.  i basicAt: 2 put: 255.  self assert: i size equals: 4.  self assert: i printString equals: '-65280'.  self assert: i normalize equals: -65280.  self assert: (i normalize isMemberOf: SmallInteger).  i0 := LargeNegativeInteger new: 0.  self assert: i0 size equals: 0.  self assert: i0 printString equals: '-0'.  self assert: i0 normalize equals: 0.  self assert: (i0 normalize isMemberOf: SmallInteger)storeStringHex  ^self storeStringBase: 16modificationForbiddenFor: selector index: index value: value  ^(ModificationForbidden for: self at: index with: value retrySelector: selector) signaltestHhmm24  self assert: aTime hhmm24 equals: '1234'gtDebuggerEvaluatorIn: composite  < gtDebuggerPresentationOrder: 10>  (GTProtoObjectVariablesBrowser new evaluatorIn: composite) title: 'Evaluator'mourn  exampleClosure  < sampleInstance>  instVar1 := 1.  [ 2 ] value.  ^thisContext copytestDayOfWeek  self assert: aDateAndTime dayOfWeek equals: 3.  self assert: aDateAndTime dayOfWeekAbbreviation equals: 'Tue'.  self assert: aDateAndTime dayOfWeekName equals: 'Tuesday'exceptionHandlerBlock  ^self tempAt: 2testAsWeek  self assert: aDateAndTime asWeek equals: (Week starting: '12-31-1969' asDate)isAbstract  ^super isAbstract or: [ self classSide isAbstract ]decodeNoTrailer  size := 4debuggerMap  ^self method debuggerMapshutDown  quickSend: selector to: aReceiver with: arguments super: superFlag  | lookupClass contextToReturnTo result |  contextToReturnTo := self.  lookupClass := superFlag ifTrue: [ (self method literalAt: self method numLiterals) value superclass ] ifFalse: [ self objectClass: aReceiver ].  [ | oldSender |  oldSender := thisContext sender swapSender: self.  result := self object: aReceiver perform: selector withArguments: arguments inClass: lookupClass.  thisContext sender swapSender: oldSender ] ifCurtailed: [ contextToReturnTo := thisContext sender receiver.        contextToReturnTo jump: -1.        contextToReturnTo nextByte = 16r7C ifTrue: [ contextToReturnTo push: (thisContext sender tempAt: 1) ].        thisContext swapSender: thisContext home sender.        contextToReturnTo ].  contextToReturnTo push: result.  ^contextToReturnTotestPlus  self assert: aDateAndTime + '0:00:00:00' equals: aDateAndTime.  self assert: aDateAndTime + 0 equals: aDateAndTime.  self assert: aDateAndTime + aDuration equals: (DateAndTime year: 1970 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)name  ^thisClass ifNil: [ 'a Metaclass' ] ifNotNil: [ thisClass name asString , ' class' ]testMethodsWritingSlot  | numberViaSlot numberViaIVar |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  numberViaSlot := (Point methodsWritingSlot: (Point slotNamed: #x)) size.  numberViaIVar := (Point whichSelectorsStoreInto: 'x') size.  self assert: numberViaSlot equals: numberViaIVaradd: aLinkOrObject beforeLink: otherLink  | currentLink |  firstLink == otherLink ifTrue: [ ^self addFirst: aLinkOrObject ].  currentLink := firstLink.  [ currentLink == nil ] whileFalse: [ currentLink nextLink == otherLink ifTrue: [ | aLink |              aLink := aLinkOrObject asLink.              aLink nextLink: currentLink nextLink.              currentLink nextLink: aLink.              ^aLink ].        currentLink := currentLink nextLink ].  ^self errorNotFound: otherLinksetUp  super setUp.  aDate := DateAndTime year: 2004 month: 12 day: 25 hour: 0 minute: 0 second: 0.  aDuration := Duration days: 91 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.  aTimespan := Timespan starting: aDate duration: aDurationln  | res h |  res := super ln.  res isFinite ifTrue: [ ^res ].  h := self highBit.  ^2 ln * h + (self / (1 << h)) asFloat lntestDaysLeftInYear  self assert: aDateAndTime daysLeftInYear equals: 364bitOr: n  < primitive: 'primDigitBitOr' module: 'LargeIntegers'>  | norm |  norm := n normalize.  ^self digitLogic: norm op: #bitOr: length: (self bytesCount max: norm bytesCount)> aNumber  aNumber isFraction ifTrue: [ ^numerator * aNumber denominator > (aNumber numerator * denominator) ].  ^aNumber adaptToFraction: self andCompare: #>localHasInstVarRef  | scanner end printer |  scanner := InstructionStream on: self.  printer := InstVarRefLocator new.  end := self endPC.  [ scanner pc <= end ] whileTrue: [ (printer interpretNextInstructionUsing: scanner) ifTrue: [ ^true ] ].  ^falsecomment  deepCopy  compilerClass  ^self instanceSide classSideCompilerClassclassBuilder  ^self classInstaller new buildersimpleOuterTest  [ [ self doSomething.  MyTestNotification signal.  self doSomethingExceptional ] on: MyTestNotification do: [:ex |  ex outer.        self doSomethingElse ] ] on: MyTestNotification do: [:ex |  self doYetAnotherThing.        ex resume ]removeProtocolNamed: aName  | protocolToRemove |  protocolToRemove := self protocolNamed: aName.  ^self removeProtocol: protocolToRemoveiterationsBeforeTimeout: anInteger  iterationsBeforeTimeout := anIntegerduration  ^Duration zeroprimSignal: aSemaphore atMilliseconds: aSmallInteger  < primitive: 136>  ^self primitiveFailedtestClosureRestart  self should: [ self privRestartBlockTest ] notTakeMoreThan: 0.1 second.  self should: [ self privRestartArgBlockTest ] notTakeMoreThan: 0.1 secondasTraitComposition  ^TaCompositionElement for: selfaddProtocol: aProtocol  ^protocols add: aProtocolrightRotated  ^y negated @ xcritical: aBlock  | activeProcess |  activeProcess := Processor activeProcess.  activeProcess == owner ifTrue: [ ^aBlock value ].  ^semaphore critical: [ owner := activeProcess.        aBlock ensure: [ owner := nil ] ]initialize  super initialize.  protocolOrganizer := ProtocolOrganizer newtestWaitTimeoutMSecs  self assert: (Semaphore new waitTimeoutMSecs: 50) identicalTo: true.  self assert: (Semaphore new signal waitTimeoutMSecs: 50) identicalTo: falseliteralEqual: other  ^(super literalEqual: other) and: [ self scale = other scale ]isClassOrTrait  ^self isClass or: [ self isTrait ]testIsLetter  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isLetter: ch) equals: (charset isLetter: ch) ]compiler  ^self class compilerClass new class: selftestSetUp  self assert: aBlockContext home equals: contextOfaBlockContext.  self assert: aBlockContext receiver equals: self.  self assert: (aBlockContext method isNil or: [ aBlockContext method isKindOf: CompiledCode ])testRaisedToErrorConditions  self should: [ -1 / 16 raisedTo: 1 / 4 ] raise: ArithmeticError.  self should: [ (((1 << 1024) + 1) / ((1 << 1024) + 3)) negated raisedTo: 1 / 4 ] raise: ArithmeticErrorlink: aMetaLink toSlot: aSlot  aSlot link: aMetaLinkseconds: secondCount  seconds := secondCount.  nanos := 0meta  ^KMModifier meta + selfbottom: aNumber  ^origin corner: corner x @ aNumberprintSubclassesOn: aStream level: level filter: filterCollection  | subclassNames |  filterCollection ifNotNil: [ (filterCollection includes: self) ifFalse: [ ^self ] ].  aStream crtab: level.  aStream nextPutAll: self name.  aStream     space;     print: self instVarNames.  self == Class ifTrue: [ aStream           crtab: level + 1;           nextPutAll: '[ ... all the Metaclasses ... ]'.        ^self ].  subclassNames := self subclasses asSortedCollection: [:c1 :c2 |  c1 name <= c2 name ].  subclassNames do: [:subclass |  subclass printSubclassesOn: aStream level: level + 1 filter: filterCollection ]sizeStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex  ^self sizeOpcodeSelector: #genStoreRemoteTemp:inVectorAt: withArguments: {tempIndex .         tempVectorIndex}pop  | value |  value := self at: stackp.  self stackp: stackp - 1.  ^valueasMethodConstant  | const constNode link |  const := self value.  constNode := thisContext sender sourceNodeExecuted.  link := MetaLink new     metaObject: const;     control: #instead.  constNode link: link.  ^consttestEmptyTemplate  | i |  i := LargePositiveInteger new: 4.  self assert: i size equals: 4.  self assert: i printString equals: '0'.  self assert: i normalize equals: 0testFloor  self assert: (3 / 2) floor equals: 1.  self assert: (-3 / 2) floor equals: -2removeSlot: aClassSlot  ^self instanceSide removeClassSlot: aClassSlot/ aNumber  aNumber class = self class ifTrue: [ ^self asFraction / aNumber asFraction asScaledDecimal: (scale max: aNumber scale) ].  ^self coerce: self asFraction / aNumbertimeToRunWithoutGC  ^Smalltalk vm totalGCTime + self timeToRun asMilliSeconds - Smalltalk vm totalGCTimeintegerPart  ^self truncatedtop  ^topisConcatenatedHtmlAttributeValue  ^falseascending  ^self asSortFunctionisFraction  ^truetestDigitSum  self assert: 1234 digitSum equals: 10adaptToPoint: rcvr andSend: selector  ^rcvr perform: selector with: self @ self>> selector  ^self compiledMethodAt: selectorpluralize: aSingularString with: aPluralString  ^self printString , ' ' , (self abs = 1 ifTrue: [ aSingularString ] ifFalse: [ aPluralString ])literalsDo: aBlock  1 to: self numLiterals do: [:index |  aBlock value: (self objectAt: index + 1) ]second  ^seconds rem: SecondsInMinuteisOtherSymbol  ^self characterSet isOtherSymbol: selftestIncludesMethod  self assert: (Object includesMethod: Object >> #halt).  self deny: (Class includesMethod: Object >> #halt).  self assert: (Point includesMethod: Point >> #x).  self deny: (LookupKey includesMethod: Point >> #x)wantsDroppedMorph: aMorph event: anEvent inMorph: destinationLM  ^falseoffset  ^start offsetsuspend  < primitive: 88>  | oldList |  myList ifNil: [ ^nil ].  oldList := myList.  myList := nil.  oldList remove: self ifAbsent: [  ].  ^oldListsystemIconName  ^#classIconround: numberOfWishedDecimal  ^selftestYearMonthDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours)asInteger  ^self truncatedwritesField: varIndex  | varIndexCode scanner |  varIndexCode := varIndex - 1.  ((scanner := InstructionStream on: self) scanFor: (self encoderClass instVarWriteScanBlockFor: varIndexCode using: scanner)) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:cb |  cb writesField: varIndex ]initialize  super initialize.  self basicSuperclass: Object.  self methodDict: self emptyMethodDictionary.  self setFormat: Object formattestPrintShowingDecimalPlaces  self assert: (111.2 printShowingDecimalPlaces: 2) equals: '111.20'.  self assert: (111.2 printShowingDecimalPlaces: 0) equals: '111'.  self assert: (111 printShowingDecimalPlaces: 0) equals: '111'.  self assert: (111111111111111 printShowingDecimalPlaces: 2) equals: '111111111111111.00'.  self assert: (10 printShowingDecimalPlaces: 20) equals: '10.00000000000000000000'.  self assert: (0.98 printShowingDecimalPlaces: 2) equals: '0.98'.  self assert: (-0.98 printShowingDecimalPlaces: 2) equals: '-0.98'.  self assert: (2.567 printShowingDecimalPlaces: 2) equals: '2.57'.  self assert: (-2.567 printShowingDecimalPlaces: 2) equals: '-2.57'.  self assert: (0.01 printShowingDecimalPlaces: 2) equals: '0.01'.  self assert: (-0.001 printShowingDecimalPlaces: 2) equals: '0.00'tan  ^self sin / self cossetUp  super setUp.  classFactory := ClassFactoryForTestCase newgreaseDeprecatedApi: apiString details: detailsString  GRDeprecatedApiNotification new     details: detailsString;     signal: apiStringdayOfYear  ^start dayOfYearmarkAsRingResolved  asTextMorph  ^TextMorph new contentsAsIs: self asStringOrTexttimesTwoPower: anInteger  < primitive: 54>  anInteger < -29 ifTrue: [ ^self * (2.0 raisedToInteger: anInteger) ].  anInteger < 0 ifTrue: [ ^self / (1 bitShift: 0 - anInteger) asFloat ].  anInteger < 30 ifTrue: [ ^self * (1 bitShift: anInteger) asFloat ].  ^self * (2.0 raisedToInteger: anInteger)shortDebugStack  ^String streamContents: [:stream |  self debugStack: 10 on: stream ]definitionWithoutSlots  | poolString stream |  poolString := self sharedPoolsString.  stream := (String new: 800) writeStream.  superclass ifNotNil: [ stream nextPutAll: superclass name ] ifNil: [ stream nextPutAll: 'ProtoObject' ].  stream     nextPutAll: self kindOfSubclass;     store: self name.  self hasTraitComposition ifTrue: [ stream           crtab;           nextPutAll: 'uses: ';           nextPutAll: self traitCompositionString ].  stream     crtab;     nextPutAll: 'instanceVariableNames: ';     store: self instanceVariablesString.  stream     crtab;     nextPutAll: 'classVariableNames: ';     store: self classVariablesString.  poolString = '' ifFalse: [ stream           crtab;           nextPutAll: 'poolDictionaries: ';           store: poolString ].  stream     crtab;     nextPutAll: 'package: ';     store: self category asString.  superclass ifNil: [ stream           nextPutAll: '.';           cr.        stream nextPutAll: self name.        stream           space;           nextPutAll: 'superclass: nil' ].  ^stream contentstestSetIsReadOnlyImmediate  self alwaysReadOnlyObjects do: [:each |  self testObject: each initialState: true tuples: #(#(true true true) #(false true true)) ]testSupplyAnswerThroughNestedBlocks  self should: [ true = ([ [ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('Blub' false) ] valueSupplyingAnswer: #('Smalltalk' true)) ]valueSuppressingMessages: aListOfStrings  ^self valueSuppressingMessages: aListOfStrings supplyingAnswers: #()testallMethodsWritingSlot  | methods |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  methods := LookupKey allMethodsWritingSlot: (LookupKey slotNamed: #key).  self assert: (methods includes: Association >> #key:value:)exception: anObject  exception := anObjectcalypsoEnvironmentType  ^self classtemporaryVariables  ^self tempNames collect: [:name |  TemporaryVariable new name: name ]setValue: newValue  self error: 'Characters are immutable'isOtherPunctuation  ^self characterSet isOtherPunctuation: selfincludesBehavior: aClass  self isTrait ifTrue: [ ^false ].  ^self == aClass or: [ self inheritsFrom: aClass ]superclass: aSuperclass withLayoutType: layoutType slots: slotArray  | superLayout newScope newLayout |  superLayout := aSuperclass ifNil: [ EmptyLayout instance ] ifNotNil: [ aSuperclass classLayout ].  newScope := superLayout slotScope extend: slotArray.  newLayout := layoutType extending: superLayout scope: newScope host: self.  newLayout checkSanity.  self superclass: aSuperclass layout: newLayoutbinding  ^self methodDict ifEmpty: [ LiteralVariable key: nil value: self ] ifNotEmpty: [:dict |  dict anyOne classBinding ]silentlyRenameCategory: oldName toBe: newName  self protocolOrganizer renameProtocol: oldName into: newNametestOnForkErrorTakesLessThanOneSecond  | sema timeout |  self     flag: 'This test is too brittle, failing often on Windows CI';     skip.  self flag: 'The following line makes the test pass under headless linux. Everywhere else this test works'.  Smalltalk os isUnix ifTrue: [ 1 milliSecond wait ].  sema := Semaphore new.  [ 1 / 0 ] on: Exception fork: [ sema signal ].  timeout := sema waitTimeoutSeconds: 1.  self assert: timeout identicalTo: falsetestCopy  self assert: 2.0 copy equals: 2.0.  self assert: -0.5 copy equals: -0.5.  self assert: Float nan copy isNaN.  self assert: Float infinity copy equals: Float infinity.  self assert: Float infinity negated copy equals: Float infinity negated.  self assert: 0.0 copy hex equals: 0.0 hex.  self assert: Float negativeZero copy hex equals: Float negativeZero hexasCollectionElement  ^CollectionElement withNilnumerator  ^selfwaitFor: aSymbolOrNil maxSeconds: aNumber  ^self waitFor: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asIntegerlowBit  | n result lastByte |  n := self.  n = 0 ifTrue: [ ^0 ].  result := 0.  [ (lastByte := n bitAnd: 16rFF) = 0 ] whileTrue: [ result := result + 8.        n := n bitShift: -8 ].  ^result + (#[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1] at: lastByte)removeFromSystem: logged  | myCategory |  self release.  self unload.  self superclass ifNotNil: [ self superclass addObsoleteSubclass: self ].  myCategory := self category.  self isReferenced ifTrue: [ Undeclared declare: self name asSymbol from: Smalltalk globals ].  self environment forgetClass: self logged: logged.  self obsolete.  logged ifTrue: [ SystemAnnouncer uniqueInstance classRemoved: self fromCategory: myCategory ]testPrintLimitedString  | actual |  actual := Object new printStringLimitedTo: 4.  self assert: actual equals: 'an O...etc...'testTimeoutWithZeroDuration  self assertSuccess: (ExceptionTester new runTest: #simpleTimeoutWithZeroDurationTest)simpleResumeTest  [ | it |  self doSomething.  it := MyResumableTestError signal.  it = 3 ifTrue: [ self doSomethingElse ].  it := MyResumableTestError signal.  it = 3 ifTrue: [ self doSomethingElse ] ] on: MyResumableTestError do: [:ex |  self doYetAnotherThing.        ex resume: 3 ]simpleTimeoutTest  | n |  [ 1 to: 1000000 do: [:i |  n := i.        self doSomething ] ] valueWithin: 50 milliSeconds onTimeout: [ self iterationsBeforeTimeout: n.        self doSomethingElse ]isDead  ^pc isNilsetDelay: anInteger forSemaphore: aSemaphore  super setDelay: anInteger forSemaphore: aSemaphore.  process := Processor activeProcess.  expired := falsetestFromSeconds  self assert: aDateAndTime equals: (DateAndTime fromSeconds: 2492985600)basicCheck: aPackage  (self bootstrapPackages includes: aPackage packageName) ifFalse: [ ^false ].  ^self newExternalDependencyExistFor: aPackagestoreOn: aStream  aStream nextPut: $(.  self printOn: aStream.  aStream nextPut: $)testIsOtherNumber  self checkCorrespondanceOf: #isOtherNumber: and: #NoincludesSelector: selector  ^methodSelectors includes: selectorasAlien  ^0step: aContext  ^Processor activeProcess evaluate: [ self suspendedContext == aContext ifTrue: [ suspendedContext := suspendedContext step ] ifFalse: [ self complete: (self calleeOf: aContext) ] ] onBehalfOf: selfselectorsToBeIgnored  | private |  private := #(#printOn:).  ^super selectorsToBeIgnored , privaterenameCategory: oldCatString toBe: newCatString  | index oldCategory newCategory |  oldCategory := oldCatString asSymbol.  newCategory := newCatString asSymbol.  (categoryArray indexOf: newCategory) > 0 ifTrue: [ ^self ].  (index := categoryArray indexOf: oldCategory) = 0 ifTrue: [ ^self ].  categoryArray := categoryArray copy.  categoryArray at: index put: newCategoryaddClassSlot: aSlot  ^self classInstaller update: self to: [:builder |  builder           fillFor: self;           classSlots: (self class classLayout slots copyWith: aSlot) ]renderOn: html  self value: htmltestLargeSqrtFloor  | large root |  large := (SmallInteger maxVal << 100) + 1 << 100.  root := large sqrtFloor.  self assert: root squared <= large.  self assert: (root + 1) squared > largecritiques  < eProperty>  ^ReCriticEngine critiquesOf: selfisShortcutDeclaration  ^self pragmas anySatisfy: [:p |  p selector = #shortcut ]printStringLength: minimal padded: zeroFlag  ^self printStringBase: 10 length: minimal padded: zeroFlagjavascriptOn: aStream  (String with: self) javascriptOn: aStreamtestSign  | negatives negz positives strictNegatives strictPositives zero |  strictPositives := {2 .   2.5 .   Float infinity}.  strictNegatives := {-3 .   -3.25 .   Float infinity negated}.  zero := 0.0.  negz := Float negativeZero.  positives := strictPositives copyWith: zero.  negatives := strictNegatives copyWith: negz.  strictPositives do: [:aPositive |  self assert: aPositive sign equals: 1 ].  strictNegatives do: [:aNegative |  self assert: aNegative sign equals: -1 ].  self assert: zero sign equals: 0.  self assert: negz sign equals: 0.  positives do: [:aPositiveSign |  positives do: [:aPositive |  self assert: (aPositive sign: aPositiveSign) equals: aPositive ].        negatives do: [:aNegative |  self assert: (aNegative sign: aPositiveSign) equals: aNegative negated ].        self assert: (zero sign: aPositiveSign) sign equals: 0.        self assert: (negz sign: aPositiveSign) sign equals: 0.        self assert: (zero sign: aPositiveSign) signBit equals: 0.        self assert: (negz sign: aPositiveSign) signBit equals: 0 ].  negatives do: [:aNegativeSign |  positives do: [:aPositive |  self assert: (aPositive sign: aNegativeSign) equals: aPositive negated ].        negatives do: [:aNegative |  self assert: (aNegative sign: aNegativeSign) equals: aNegative ].        self assert: (zero sign: aNegativeSign) sign equals: 0.        self assert: (negz sign: aNegativeSign) sign equals: 0.        self assert: (zero sign: aNegativeSign) signBit equals: 1.        self assert: (negz sign: aNegativeSign) signBit equals: 1 ]storeOn: aStream  aStream     print: self printString;     nextPutAll: ' asTime'gtInspectorVariableNodesIn: aCollection  | tempVariableValueNodes |  tempVariableValueNodes := self gtInspectorTempNodes sort: [:aNode :anotherNode |  aNode key < anotherNode key ].  aCollection addAll: tempVariableValueNodes.  super gtInspectorVariableNodesIn: aCollectiontestOffset  self assert: aDateAndTime offset equals: '0:00:00:00' asDuration.  self assert: (aDateAndTime offset: '-0:12:00:00') equals: '1979-12-31T12:00:00-12:00' asDateAndTime.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1980-01-01T12:00:00+12:00' asDateAndTimesetAuthorInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setAuthor: selfsourceNodeForPC: arg1  ^self subclassResponsibilitymethodsAccessingSlot: aSlot  ^self methods select: [:method |  method accessesSlot: aSlot ]bitShiftMagnitude: shiftCount  < primitive: 'primDigitBitShiftMagnitude' module: 'LargeIntegers'>  | rShift |  shiftCount >= 0 ifTrue: [ ^self digitLshift: shiftCount ].  rShift := 0 - shiftCount.  ^(self digitRshift: (rShift bitAnd: 7) bytes: (rShift bitShift: -3) lookfirst: self bytesCount) normalizeexplanation: aString  explanationString := aStringtestAsDuration  self assert: aDateAndTime asDuration equals: 0 asDurationtestInquiries  self     assert: june2nd1973 dayOfMonth equals: 2;     assert: june2nd1973 dayOfYear equals: 153;     assert: june2nd1973 daysInMonth equals: 30;     assert: june2nd1973 daysInYear equals: 365;     assert: june2nd1973 daysLeftInYear equals: 365 - 153;     assert: june2nd1973 firstDayOfMonth equals: 152simpleEnsureTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingElseString;     add: self doYetAnotherThingString;     yourselfisMeta  ^trueisLiteral  ^self isFinitenegated  ^(self copyto: (LargeNegativeInteger new: self bytesCount)) normalizeremoveSelf  | tempSelf |  tempSelf := receiver.  receiver := nil.  ^tempSelfhasSubject  ^organizedClass notNilgenerator  ^generatorstepAt: millisecondClockValue in: aWindow  ^self stepIn: aWindowtestMutateWideSymbolUsingPrivateAtPut  | guineaPig |  [ guineaPig := ('hello' , (Character codePoint: 8002) asString) asSymbol.  guineaPig beReadOnlyObject.  self should: [ guineaPig privateAt: 1 put: 65 ] raise: ModificationForbidden ] ensure: [ guineaPig beWritableObject ].  self assert: guineaPig first equals: $hdayMonthYearDo: aBlock  ^start dayMonthYearDo: aBlockallCategories  ^self protocolOrganizer allProtocolsNamesclassVarNames  ^self classPool keys sortparseIfError: aBlock  self initializeParsing.  [ self isDoneParsing ] whileFalse: [ self parseNextPattern ].  self isInvalidPattern ifTrue: aBlock.  self convertTwoDigitsYear.  (inputStream atEnd and: [ patternStream atEnd ]) ifFalse: [ DateError signal: 'Input doesn''t match given pattern.' ].  ^self createDateallSelectorsAbove  ^self allSelectorsAboveUntil: ProtoObjectheaderSize  ^8collatedBy: aSortFunction  self numArgs = 1 ifTrue: [ ^PropertySortFunction property: self collatedWith: aSortFunction asSortFunction ].  self error: 'Cant be converted to sort function. It should hava one arg'traceCrTab: anObject  self trace: anObject.  Transcript     cr;     tabveryDeepCopy  | copier new |  copier := DeepCopier new initialize: 4096.  new := self veryDeepCopyWith: copier.  copier references associationsDo: [:assoc |  assoc value veryDeepFixupWith: copier ].  copier fixDependents.  ^newtestOffset  self assert: aDateAndTime offset equals: '0:02:00:00' asDuration.  self assert: (aDateAndTime offset: '-0:12:00:00') equals: '2004-02-28T23:33:00-12:00' asDateAndTime.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '2004-02-29T23:33:00+12:00' asDateAndTimemoveMethodsFrom: fromProtocolNamed to: toProtocolNamed  | fromProtocol toProtocol |  fromProtocol := self protocolNamed: fromProtocolNamed.  toProtocol := self protocolNamed: toProtocolNamed.  toProtocol addAllMethodsFrom: fromProtocol.  fromProtocol removeAllMethodSelectors.  ^toProtocolreBanName  ^self name , ' (Method)'findNextUnwindContextUpTo: aContext  < primitive: 195>  | context |  context := self.  [ (context := context sender) == nil or: [ context == aContext ] ] whileFalse: [ context isUnwindContext ifTrue: [ ^context ] ].  ^nilmethodNode  ^self method methodNodescanFor: byte  ^(InstructionStream on: self) scanFor: [:instr |  instr = byte ]testExecutionCriticalSection  | actual |  actual := mutex critical: [ #result ].  self assert: actual equals: #resultrestoreResumptionTimes: delaysOrNils  | newBaseTick |  newBaseTick := self nowTick.  delaysOrNils do: [:delay |  delay ifNotNil: [ delay resumptionTickAdjustFrom: 0 to: newBaseTick ] ]highBitOfMagnitude  | realLength lastDigit |  realLength := self bytesCount.  [ (lastDigit := self byteAt: realLength) = 0 ] whileTrue: [ (realLength := realLength - 1) = 0 ifTrue: [ ^0 ] ].  ^lastDigit highBitOfPositiveReceiver + (8 * (realLength - 1))glmCritiqueSourceIn: composite  ^self gtInspectorSourceIn: compositeallAreasOutsideList: aCollection do: aBlock  ^self allAreasOutsideList: aCollection startingAt: 1 do: aBlockisDashPunctuation  ^self characterSet isDashPunctuation: selftestSchedulingHigherPriorityServedFirst  | gate checkAssert whichRan |  gate := Semaphore new signal.  checkAssert := Semaphore new.  [ gate wait.  whichRan := 11.  checkAssert signal ] forkAt: 11.  [ gate wait.  whichRan := 12.  checkAssert signal ] forkAt: 12.  checkAssert wait.  self assert: whichRan = 12 description: 'Second scheduled but higher priority should run first'.  gate signal.  checkAssert wait.  self assert: whichRan = 11 description: 'First scheduled but lower priority should run after'isReceiverOrAnyArgumentGarbage  ^self isReceiverGarbage or: [ self isAnyArgumentGarbage ]calypsoEnvironmentType  ^ClyMethod< aNumber  aNumber isInteger ifTrue: [ self negative == aNumber negative ifTrue: [ self negative ifTrue: [ ^(self bytesCompare: aNumber) > 0 ] ifFalse: [ ^(self bytesCompare: aNumber) < 0 ] ] ifFalse: [ ^self negative ] ].  ^aNumber adaptToInteger: self andCompare: #<variableWordSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategory  ^self subclass: aName uses: aTraitComposition layout: WordLayout slots: someInstanceVariableNames asSlotCollection classVariablesNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategorycategory  ^self instanceSide categoryargumentNames  ^self propertyAt: #argumentNames ifAbsent: [ self ast argumentNames ]adaptToFloat: rcvr andSend: selector  ^self adaptToNumber: rcvr andSend: selectorproperties  | propertiesOrSelector |  ^(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifTrue: [ propertiesOrSelector ] ifFalse: [ self class methodPropertiesClass forMethod: self selector: propertiesOrSelector ]ffiCall: fnSpec module: aModuleName options: callOptions  < ffiCalloutTranslator>  self ffiCall: fnSpec library: aModuleName options: callOptionssignBit  ^(self at: 1) bitShift: -31selectorToSendOrSelf  ^self method encoderClass selectorToSendOrItselfFor: self in: self method at: pctest32bitRoundingMode  | conv expected exponentPart |  conv := 2r1.0000000000000000000000111e25 asIEEE32BitWord.  exponentPart := 25 + 127 bitShift: 23.  expected := exponentPart bitOr: 2r10.  self assert: expected equals: conv.  conv := 2r1.0000000000000000000000110e25 asIEEE32BitWord.  expected := exponentPart bitOr: 2r10.  self assert: expected equals: conv.  conv := 2r1.0000000000000000000000010e25 asIEEE32BitWord.  expected := exponentPart bitOr: 2r0.  self assert: expected equals: conv.  conv := 2r1.0000000000000000000000011e25 asIEEE32BitWord.  expected := exponentPart bitOr: 2r1.  self assert: expected equals: convextent: aPoint  ^Rectangle origin: self extent: aPointsubclasses  ^subclasses ifNil: [ #() ] ifNotNil: [ subclasses copy ]gtDisplayOn: stream  ^self printOn: streamcull: anArg  < debuggerCompleteToSender>  ^numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: anArg ]propertyValueAt: propName put: propValue  ^self propertyAt: propName put: propValuedecimalDigitLength  ^self numberOfDigitsInBase: 10isProvided  ^self isProvided: self markerOrNilduration: aDuration  duration := aDurationpragmaAt: aKey  | propertiesOrSelector |  ^(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifTrue: [ propertiesOrSelector at: aKey ifAbsent: [ nil ] ] ifFalse: [ nil ]testAsSeconds  | secondsSinceEpoch dateUTC dateEDT datePST |  self useTimeZone: 'UTC' during: [ dateUTC := Date readFrom: '01-23-2004' readStream.        secondsSinceEpoch := (dateUTC start - DateAndTime epoch) asSeconds.        self assert: dateUTC asSeconds equals: secondsSinceEpoch.        self assert: (Date fromSeconds: dateUTC asSeconds) equals: dateUTC ].  self useTimeZone: 'EDT' during: [ dateEDT := Date readFrom: '01-23-2004' readStream.        secondsSinceEpoch := (dateEDT start - DateAndTime epoch) asSeconds.        self assert: dateEDT asSeconds equals: secondsSinceEpoch.        self assert: (Date fromSeconds: dateEDT asSeconds) equals: dateEDT ].  self useTimeZone: 'PST' during: [ datePST := Date readFrom: '01-23-2004' readStream.        secondsSinceEpoch := (datePST start - DateAndTime epoch) asSeconds.        self assert: datePST asSeconds equals: secondsSinceEpoch.        self assert: (Date fromSeconds: datePST asSeconds) equals: datePST ].  self assert: dateUTC asSeconds equals: dateEDT asSeconds - (4 * 3600).  self assert: dateUTC asSeconds equals: datePST asSeconds - (8 * 3600)isNumber  ^falsesimulate_vmMilliseconds: milliseconds  vmSimNextWakeupTick ~= 0 ifTrue: [ vmSimNow := milliseconds * 1000.        vmSimNow >= vmSimNextWakeupTick ifTrue: [ vmSimNextWakeupTick := 0.              vmSimTheTimerSemaphore signal ] ]paddedByteStringSize: numberOfChars  | originalSize |  originalSize := self headerSize + (numberOfChars = 0 ifTrue: [ 1 ] ifFalse: [ numberOfChars ]).  ^self align64Bits: originalSizethreadSafe  | sema |  RecursionStopper during: [ self assert: fork isNil.        sema := Semaphore new.        fork := [ self threadSafe.        sema signal ] fork.        sema wait.        self assert: fork isTerminated.        fork := nil ]testIsParagraphSeparator  self checkCorrespondanceOf: #isParagraphSeparator: and: #ZpclassSide  ^self subclassResponsibilitycopyFrom: anotherObject  < primitive: 168>  | mine his |  mine := self class allInstVarNames.  his := anotherObject class allInstVarNames.  1 to: (mine size min: his size) do: [:ind |  (mine at: ind) = (his at: ind) ifTrue: [ self instVarAt: ind put: (anotherObject instVarAt: ind) ] ].  self class isVariable & anotherObject class isVariable ifTrue: [ 1 to: (self basicSize min: anotherObject basicSize) do: [:ind |  self basicAt: ind put: (anotherObject basicAt: ind) ] ]asAthensShapeOn: anAthensCanvas  ^selfcopyForSaving  ^self shallowCopy postCopyfourNeighbors  ^Array with: self + (1 @ 0) with: self + (0 @ 1) with: self + (-1 @ 0) with: self + (0 @ -1)storeOn: aStream base: base  self isFinite ifTrue: [ self signBit = 1 ifTrue: [ aStream nextPutAll: ' -' ].        base = 10 ifFalse: [ aStream                 print: base;                 nextPut: $r ].        self = 0.0 ifTrue: [ aStream nextPutAll: '0.0' ] ifFalse: [ self abs absPrintExactlyOn: aStream base: base ] ] ifFalse: [ self isNaN ifTrue: [ aStream nextPutAll: 'Float nan' ] ifFalse: [ self > 0.0 ifTrue: [ aStream nextPutAll: 'Float infinity' ] ifFalse: [ aStream nextPutAll: 'Float infinity negated' ] ] ]deprecated: anExplanationString transformWith: aRule when: conditionBlock  Deprecation new     context: thisContext sender;     explanation: anExplanationString;     rule: aRule;     condition: conditionBlock;     transformoffset: anOffset  ^self class basicNew     ticks: self ticks offset: anOffset asDuration;     yourself+ aNumber  < primitive: 41>  ^aNumber adaptToFloat: self andSend: #+isLocalSelector: aSelector  ^self methodDict includesKey: aSelectorperform: selector orSendTo: otherTarget  ^(self respondsTo: selector) ifTrue: [ self perform: selector ] ifFalse: [ otherTarget perform: selector ]testBetweenAndDoOverlappingSchedule  | count |  count := 0.  aSchedule between: (DateAndTime year: 2002 month: 12 day: 1) and: (DateAndTime year: 2003 month: 1 day: 31) do: [:each |  count := count + 1 ].  self assert: count equals: 8receiver: anObject  receiver := anObjectffiLibraryName  self flag: 'HACK: avoid direct subclassResponsibility to not break RB test cases..'.  ^SubclassResponsibility signalFor: thisContext selectorprotocolNamed: aString ifAbsent: aBlock  ^self allProtocols detect: [:e |  e name = aString ] ifNone: aBlockcategoryOfElement: aSelector ifAbsent: aBlock  ^(self protocolOrganizer protocolsOfSelector: aSelector) ifEmpty: [ (organizedClass includesSelector: aSelector) ifTrue: [ Protocol unclassified ] ifFalse: aBlock ] ifNotEmpty: [:col |  col first name ]genStorePopInstVar: instVarIndex  (instVarIndex < 0 or: [ instVarIndex > 7 ]) ifTrue: [ ^self genStorePopInstVarLong: instVarIndex ].  stream nextPut: 200 + instVarIndexvariableSubclass: aClassName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self variableSubclass: aClassName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' category: cattestOneCanProceedWhenIntroducingCapitalizedInstanceVariables  | class |  [ class := classFactory newSubclassOf: classFactory defaultSuperclass instanceVariableNames: 'X Y' classVariableNames: '' ] on: Exception do: [:ex |  ex resume ].  self assert: (testingEnvironment keys includes: class name)hasSourceCode  ^self method hasSourceCodeasTimeUTC  ^Time seconds: self secondsSinceMidnightUTC nanoSeconds: nanosstoreIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex  (self at: tempVectorIndex + 1) at: remoteTempIndex + 1 put: self topinterpolateTo: end at: amountDone  ^(self origin interpolateTo: end origin at: amountDone) corner: (self corner interpolateTo: end corner at: amountDone)printOn: stream  super printOn: stream.  stream nextPut: $(.  self isEmpty ifTrue: [ stream << ' empty' ] ifFalse: [ iterations printWithCommasOn: stream.        stream           space;           << ('iteration' asPluralBasedOn: iterations).        stream << ' in '.        elapsedTime printHumanReadableOn: stream.        stream << '. '.        self printFrequenceOn: stream ].  stream nextPut: $)variableByteSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self variableByteSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: cattestWritesSlot  ({(Point >> #x) .   (Point >> #setX:setY:)} allSatisfy: #hasSourceCode) ifFalse: [ ^self ].  self deny: (Point >> #x writesSlot: (Point slotNamed: #x)).  self deny: (Point >> #x writesSlot: (Point slotNamed: #y)).  self assert: (Point >> #setX:setY: writesSlot: (Point slotNamed: #y)).  self assert: (Point >> #setX:setY: writesSlot: (Point slotNamed: #x))browse  ^Smalltalk tools browser openOnClass: selfdeepCopy  ^selfto: end  to := endconstructSharedClosureEnvironmentInDeadFrame  | array result |  result := 10.  array := Array new: 2.  array at: 1 put: [:arg |  result := arg ].  array at: 2 put: [ result ].  ^arraytestReadFromFoolProofExtension  self assert: (DateAndTime fuzzyReadFrom: '2008' readStream) printString equals: '2008-01-01T00:00:00+00:00'.  self assert: (DateAndTime fuzzyReadFrom: '2008-08' readStream) printString equals: '2008-08-01T00:00:00+00:00'.  self assert: (DateAndTime fuzzyReadFrom: '2006-08-28' readStream) printString equals: '2006-08-28T00:00:00+00:00'.  self assert: (DateAndTime fuzzyReadFrom: '2006-08-28T00:00:00.123456789' readStream) printString equals: '2006-08-28T00:00:00.123456789+00:00'.  self assert: (DateAndTime fuzzyReadFrom: '2006-08-28T00:00:00.123456789000' readStream) printString equals: '2006-08-28T00:00:00.123456789+00:00'swap: oneIndex with: otherIndex  | element |  element := self basicAt: oneIndex.  self basicAt: oneIndex put: (self basicAt: otherIndex).  self basicAt: otherIndex put: element.  array swap: oneIndex with: otherIndextestMin  | huge aThirdFloat |  self assert: (2 min: 3) equals: 2.  huge := Float fmax asInteger + 1.  self assert: (Float fmax min: huge) equals: Float fmax.  aThirdFloat := 0.33333333333333333333333333333333333333333.  self assert: (1 / 3 min: aThirdFloat) equals: aThirdFloatasTime  ^start asTimedefaultAction  UnhandledError signalForException: selftestEmbeddingSourceCodeBig  self testEmbeddingSourceCode: (String loremIpsum: 30000)fuelAccept: aGeneralMapper  ^aGeneralMapper visitHookPrimitive: selfparse  ^self parseIfError: [ DateError signal ]testBinding  self assert: Object binding value equals: Object.  self assert: Object binding key equals: #Object.  self assert: Object class binding value equals: Object class.  self assert: Object class binding key isNilisVariableBinding  ^false== anObject  < primitive: 110>  self primitiveFailedsimpleOuterTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselfdurationToRun  ^self timeToRuntickAfterMilliseconds: milliseconds  ^self nowTick + millisecondsspotterReferenceFor: aStep  < spotterOrder: 30>  aStep listProcessor     title: 'References';     allCandidates: [ (SystemNavigation default allReferencesTo: self binding) collect: #compiledMethod ];     itemName: [:method |  method gtDisplayString ];     filter: GTFilterSubstringiterations  ^iterationstestIsDashPunctuation  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isDashPunctuation: ch) equals: (charset isDashPunctuation: ch) ]interpretNext3ByteSistaV1Instruction: bytecode for: client extA: extA extB: extB startPC: startPC  | method byte2 byte3 |  method := self method.  byte2 := method at: pc.  byte3 := method at: pc + 1.  pc := pc + 2.  bytecode = 248 ifTrue: [ ^client callPrimitive: byte2 + (byte3 bitShift: 8) ].  bytecode = 250 ifTrue: [ ^client pushClosureCopyNumCopiedValues: ((byte2 bitShift: -3) bitAnd: 7) + (extA // 16 bitShift: 3) numArgs: (byte2 bitAnd: 7) + (extA \\ 16 bitShift: 3) blockSize: byte3 + (extB bitShift: 8) ].  bytecode = 251 ifTrue: [ ^client pushRemoteTemp: byte2 inVectorAt: byte3 ].  bytecode = 252 ifTrue: [ ^client storeIntoRemoteTemp: byte2 inVectorAt: byte3 ].  bytecode = 253 ifTrue: [ ^client popIntoRemoteTemp: byte2 inVectorAt: byte3 ].  bytecode = 254 ifTrue: [ ^client jumpOrPopIfNotInstanceOf: (method literalAt: (extA bitShift: 8) + byte2 + 1) distance: (extB bitShift: 8) + byte3 ].  bytecode = 249 ifTrue: [ ^client pushFullClosure: (method literalAt: (extA bitShift: 8) + byte2 + 1) numCopied: (byte3 bitAnd: 16r3F) receiverOnStack: (byte3 bitAt: 7) = 1 ignoreOuterContext: (byte3 bitAt: 8) = 1 ].  ^self unusedBytecode: client at: startPC>= aNumber  < primitive: 546>  ^aNumber adaptToFloat: self andCompare: #>=isRootInEnvironment  ^self superclass isNiltestIsSelfEvaluating  self assert: Processor printString equals: 'Processor'testError  self should: [ self runSimulated: [ self methodWithError ] ] raise: ErrorlastDigit  ^self byteAt: self bytesCountisDoIt  ^self selector isDoItvariableNodes  ^self ast variableNodesvalueWithPossibleArgument: anArg  | a |  numArgs = 0 ifTrue: [ ^self value ].  numArgs = 1 ifTrue: [ ^self value: anArg ].  a := Array new: numArgs.  a at: 1 put: anArg.  ^self valueWithArguments: atestDynamicVariableRemovedAfterUse  TestDynamicVariable value: 3 during: [  ].  self assert: (Processor activeProcess psValueAt: TestDynamicVariable soleInstance index) equals: nilasPoint  ^selftaskbarLabel  ^self class taskbarLabelassignmentNodes  ^self ast assignmentNodescopy  ^selftestFirstDayOfMonth  self assert: aTimespan firstDayOfMonth equals: 1.  self assert: aDisjointTimespan firstDayOfMonth equals: 1sortCategories  inspector  ^Smalltalk tools inspector inspector: selfend  ^self timespans last nextallSubInstancesDo: aBlock  self allInstancesDo: aBlock.  self allSubclassesDo: [:sub |  sub allInstancesDo: aBlock ]testCullCull  [  ] cull: 1 cull: 2.  [:x |   ] cull: 1 cull: 2.  [:x :y |   ] cull: 1 cull: 2.  self should: [ [:x :y :z |   ] cull: 1 cull: 2 ] raise: Error.  self should: [ [:x :y :z :a |   ] cull: 1 cull: 2 ] raise: Error.  self should: [ [:x :y :z :a :b |   ] cull: 1 cull: 2 ] raise: Error.  self assert: ([ 0 ] cull: 1 cull: 2) equals: 0.  self assert: ([:x |  x ] cull: 1 cull: 2) equals: 1.  self assert: ([:x :y |  y ] cull: 1 cull: 2) equals: 2testHasAbstractMethods  self deny: Object hasAbstractMethods.  self deny: Object class hasAbstractMethods.  self assert: Behavior hasAbstractMethods.  self deny: Behavior class hasAbstractMethods.  self assert: ObjectLayout hasAbstractMethods.  self assert: ObjectLayout class hasAbstractMethodsstepToSendOrReturn  ^Processor activeProcess evaluate: [ suspendedContext := suspendedContext stepToSendOrReturn ] onBehalfOf: selfallMethodsAccessingSlot: aSlot  ^self withAllSubclasses flatCollect: [:class |  class methodsAccessingSlot: aSlot ]refersToLiteral: aLiteral  ^self hasLiteralThorough: aLiteraltestPrintOn  self assert: (String streamContents: [:str |  january23rd2004 printOn: str ]) equals: '23 January 2004'testCrossSumBase  self assert: ((-20 to: 20) collect: [:each |  each crossSumBase: 10 ]) asArray equals: #(2 10 9 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 10 2).  self assert: ((-20 to: 20) collect: [:each |  each crossSumBase: 2 ]) asArray equals: #(2 3 2 2 1 4 3 3 2 3 2 2 1 3 2 2 1 2 1 1 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2).  self should: [ 10 crossSumBase: 1 ] raise: AssertionFailurecalledArgumentsCount  ^calledArgumentsCountenclosedElement  timePerExecution  ^self periodimmediateSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat  ^self classInstaller make: [:builder |  builder           superclass: self;           name: t;           layoutClass: ImmediateLayout;           slots: f asSlotCollection;           sharedVariablesFromString: d;           sharedPools: s;           category: cat;           environment: self environment ]testIsDecimalDigit  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isDecimalDigit: ch) equals: (charset isDecimalDigit: ch) ]hasInstVarRef  ^self method hasInstVarRefmethods  ^self methodDict valuesclosure  ^closureOrNilisMessageSend  ^falsetestMaxExactInteger  self assert: Float maxExactInteger asFloat truncated equals: Float maxExactInteger.  0 to: 10000 do: [:j |  self assert: (Float maxExactInteger - j) asFloat truncated equals: Float maxExactInteger - j ].  self deny: (Float maxExactInteger + 1) asFloat truncated equals: Float maxExactInteger + 1sourceNodeInOuter  ^self outerCode sourceNodeForPC: self pcInOuternegative  ^trueasString  ^String with: selffindNextHandlerContext  | context |  context := self findNextHandlerOrSignalingContext.  context ifNil: [ ^nil ].  context isHandlerContext ifTrue: [ ^context ].  ^context exception privHandlerContext nextHandlerContexttestWritesField  | method |  method := self class compiledMethodAt: #writeX.  self assert: (method writesField: 4).  method := self class compiledMethodAt: #writeXandY.  self assert: (method writesField: 4).  method := self class compiledMethodAt: #writeXandY.  self assert: (method writesField: 5).  method := self class compiledMethodAt: #readX.  self deny: (method writesField: 4).  method := self class compiledMethodAt: #readXandY.  self deny: (method writesField: 4).  method := self class compiledMethodAt: #readXandY.  self deny: (method writesField: 5)asShortcut  ^self asKeyCombinationoriginName  ^originNamegenReturnSpecialLiteral: aLiteral  | index |  index := #(true false nil) indexOf: aLiteral ifAbsent: 0.  index = 0 ifTrue: [ ^self error: 'return special literal: ' , aLiteral printString , ' is not one of true false nil' ].  stream nextPut: 88 + indextestAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)inspectorFields  | members |  members := WriteStream on: Array new.  self class allInstVarNames keysAndValuesDo: [:index :each |  members nextPut: each -> (self instVarAt: index) ].  self class isVariable ifTrue: [ 1 to: self basicSize do: [:index |  members nextPut: index -> (self basicAt: index) ] ].  ^members contentscomplete: aContext  | ctxt pair |  ctxt := suspendedContext.  suspendedContext := nil.  pair := Processor activeProcess evaluate: [ ctxt runUntilErrorOrReturnFrom: aContext ] onBehalfOf: self.  suspendedContext := pair first.  ^pair second ifNil: [ suspendedContext ] ifNotNil: [:error |  error completeProcess: self with: aContext ]signal  < debuggerCompleteToSender>  signalContext := thisContext contextTag.  signaler ifNil: [ signaler := self receiver ].  ^signalContext nextHandlerContext handleSignal: selfdoYetAnotherThingString  ^'Do yet another thing.'encodeUndefined  self error: 'use of an undefined kind of trailer encoding'tempAt: index put: value  < primitive: 211>  ^self at: index put: valuesetProject: aString withInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setProject: aString withString: selfallMethods  self deprecated: 'Use #allMethodSelectors instead' transformWith: '`@receiver allMethods' -> '`@receiver allMethodSelectors'.  ^self allMethodSelectorsinitializeFromContext: aContext  | valueStream context |  valueStream := WriteStream on: (Array new: 20).  context := aContext.  [ context notNil ] whileTrue: [ valueStream nextPut: context.        1 to: context class instSize do: [:i |  valueStream nextPut: (context instVarAt: i) ].        1 to: context size do: [:i |  valueStream nextPut: (context at: i) ].        context := context sender ].  values := valueStream contentsisRectangle  ^falsebasicRemoveElement: element  | categoryIndex elementIndex nextStop newElements |  categoryIndex := 1.  elementIndex := 0.  nextStop := 0.  newElements := (Array new: elementArray size) writeStream.  [ (elementIndex := elementIndex + 1) <= elementArray size ] whileTrue: [ [ elementIndex > (categoryStops at: categoryIndex) ] whileTrue: [ categoryStops at: categoryIndex put: nextStop.              categoryIndex := categoryIndex + 1 ].        (elementArray at: elementIndex) = element ifFalse: [ nextStop := nextStop + 1.              newElements nextPut: (elementArray at: elementIndex) ] ].  [ categoryIndex <= categoryStops size ] whileTrue: [ categoryStops at: categoryIndex put: nextStop.        categoryIndex := categoryIndex + 1 ].  elementArray := newElements contents.  self assertInvariantmethod  ^self compiledBlockhasTemporaryVariableNamed: aName  ^self tempNames includes: aNamearcSin  ^self asFloat arcSinprintObject: obj on: s  [ obj printOn: s ] on: Exception do: [:ex |  s << '<cannot print object>' ]testMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'AM'classAndMethodFor: aSymbol do: binaryBlock ifAbsent: absentBlock  self withAllSuperclassesDo: [:class |  | method |        method := class compiledMethodAt: aSymbol ifAbsent: [ nil ].        method ifNotNil: [ ^binaryBlock value: class value: method ] ].  ^absentBlock valuesourceCodeAt: selector  ^(self compiledMethodAt: selector) sourceCodejavascriptOn: aStream  aStream nextPutAll: 'null'testInjectingExceptionHandlerIntoProcessWithArg  | error interceptedError process interrupted processArg |  DefaultExecutionEnvironment beActive.  error := Error new messageText: 'test error'.  interrupted := true.  process := [:arg |  processArg := arg.  error signal.  interrupted := false ] newProcessWith: #(#arg).  process on: Error do: [:err |  interceptedError := err ].  process resume.  [ process isTerminated ] whileFalse: [ Processor yield ].  self assert: interceptedError identicalTo: error.  self assert: interrupted.  self assert: processArg equals: #argasciiValue  < primitive: 171>  ^self primitiveFailedstoreStringBase: base  ^String streamContents: [:strm |  self storeOn: strm base: base ]schedulingProcess  ^timerEventLoopclassAnnotations  ^ClassAnnotation findAllAnnotationsFor: selfmetacelloVersionComponentLessThan: aMetacelloVersonComponent  ^aMetacelloVersonComponent metacelloIntegerLessThanSelf: selfcheckOwnerProcess  self isOwnerProcess ifFalse: [ self error: 'Monitor access violation' ]accessesSlot: aSlot  ^aSlot isAccessedIn: selfmessage: aMessage  message := aMessagetestAsDelay  self deny: aDuration asDelay equals: aDurationfloor  self isIntegerPoint ifTrue: [ ^self ].  ^x floor @ y floorprintSeparateDateAndTimeOn: stream  stream     print: self asDate;     space;     print: self asTimesetName: aSymbol  name := aSymbolcomplexRecursionLastCall  self complexRecursionsizePushFullClosure: compiledBlockLiteralIndex numCopied: numCopied  ^self sizeOpcodeSelector: #genPushFullClosure:numCopied: withArguments: {compiledBlockLiteralIndex .         numCopied}value: firstArg value: secondArg  < primitive: 203>  numArgs ~= 2 ifTrue: [ self numArgsError: 2 ].  ^self primitiveFailedtestPrintSeparatedByEverySignedOn  | printer |  printer := [:integer :printSigned |  String streamContents: [:stream |  integer printSeparatedBy: $. every: 3 signed: printSigned on: stream ] ].  self assert: (printer value: 123456789 value: false) equals: '123.456.789'.  self assert: (printer value: -123456789 value: false) equals: '-123.456.789'.  self assert: (printer value: 123456789 value: true) equals: '+123.456.789'.  self assert: (printer value: -123456789 value: true) equals: '-123.456.789'testIntersectionWithDisjoint  self assert: (aTimespan intersection: aDisjointTimespan) isNilasFunction: aCollection  ^JSFunction new     add: self;     arguments: aCollectionreadX  | tmp |  tmp := x.  ^tmpwithAllSuperAndSubclassesDo: aBlock  self allSuperclassesDo: aBlock.  aBlock value: self.  self allSubclassesDo: aBlockisResumable  ^falsecommand  ^KMModifier command + selfbetween: aStart and: anEnd do: aBlock  | element end i startDate |  end := self end min: anEnd.  element := self start.  startDate := aStart asDate.  (startDate > element asDate and: [ self everyDayAtSameTimes ]) ifTrue: [ element := DateAndTime date: startDate time: element asTime ].  i := 1.  [ element < aStart ] whileTrue: [ element := element + (schedule at: i).        i := i + 1.        i > schedule size ifTrue: [ i := 1 ] ].  [ element <= end ] whileTrue: [ aBlock value: element.        element := element + (schedule at: i).        i := i + 1.        i > schedule size ifTrue: [ i := 1 ] ]perform: selector withArguments: argArray inSuperclass: lookupClass  < reflective: #object:performMessageInSuperclass:>  < primitive: 100>  selector isSymbol ifFalse: [ ^self error: 'selector argument must be a Symbol' ].  selector numArgs = argArray size ifFalse: [ ^self error: 'incorrect number of arguments' ].  (self class includesBehavior: lookupClass) ifFalse: [ ^self error: 'lookupClass is not in my inheritance chain' ].  self primitiveFailedisSafeForHTTP  ^self charCode < 128 and: [ self isAlphaNumeric or: [ '.-_' includes: (Character value: self charCode) ] ]and: alternativeBlock  ^selftestTimeZoneEquivalence2  | thisMoment thisMomentInMoscow |  thisMoment := DateAndTime year: 2004 month: 5 day: 24 hour: 22 minute: 40.  thisMomentInMoscow := thisMoment offset: 3 hours.  self assert: (thisMoment - thisMomentInMoscow) asSeconds equals: 0.  self assert: thisMoment equals: thisMomentInMoscowmillisecondsUntilResumptionTime: microsecondResumptionTime  ^(microsecondResumptionTime - Time microsecondClockValue) // 1000testOR  self assert: true | true.  self assert: true | falsehandleSignal: exception  ^exception resumeUnchecked: exception defaultActionserializeToFileNamed: aFilename  ^FLSerializer serialize: self toFileNamed: aFilenameround: numberOfWishedDecimal  ^self roundTo: (10 raisedTo: numberOfWishedDecimal negated)installLink: aMetaLink  self reflectiveMethod ifNil: [ self createTwin ].  self reflectiveMethod increaseLinkCount.  (aMetaLink optionCompileOnLinkInstallation or: [ self isRealPrimitive ]) ifTrue: [ self reflectiveMethod compileAndInstallCompiledMethod ] ifFalse: [ self invalidate ].  aMetaLink announceChangeisReturnSelf  ^self primitive = 256= aNumber  aNumber isNumber ifFalse: [ ^false ].  aNumber isFraction ifTrue: [ numerator = 0 ifTrue: [ ^aNumber numerator = 0 ].        ^numerator * aNumber denominator = (aNumber numerator * denominator) ].  ^aNumber adaptToFraction: self andCompare: #=testStoring  self     assert: time storeString equals: '''4:02:47 am'' asTime';     assert: time equals: '4:02:47 am' asTimetestHasSlotNamed  self assert: (Context hasSlotNamed: #sender).  self assert: (Context hasSlotNamed: #method)asSmallerPowerOfTwo  | quotient |  (numerator = 0 or: [ numerator sign ~= denominator sign ]) ifTrue: [ ^DomainError signal: 'Value outside (0 , infinity)' from: 0 ].  ^(quotient := denominator // numerator) > 0 ifTrue: [ (quotient isPowerOfTwo and: [ denominator \\ numerator = 0 ]) ifTrue: [ Fraction numerator: 1 denominator: quotient ] ifFalse: [ Fraction numerator: 1 denominator: (1 bitShift: quotient highBit) ] ] ifFalse: [ 1 bitShift: (numerator // denominator) highBit - 1 ]testPoolVariableAccessibleInSubclassOfClassUser  PoolDefiner initialize.  SubclassPoolUser compileAll.  self assert: SubclassPoolUser gloups equals: 42.  self assert: SubclassPoolUser author equals: 'Ducasse'printOn: aStream  super printOn: aStream.  aStream     nextPutAll: '(';     print: millisecondDelayDuration;     nextPutAll: ' msecs'.  beingWaitedOn ifTrue: [ aStream           nextPutAll: '; ';           print: self millisecondsToGo;           nextPutAll: ' msecs remaining' ].  aStream nextPutAll: ')'gtInspectorVariableValuePairs  | bindings |  bindings := OrderedCollection new.  self gtInspectorVariableNodesIn: bindings.  ^bindings collect: [:aNode |  aNode key -> aNode value ]testMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'AM'testToBy  self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) equals: (DateAndTime new to: DateAndTime new + 10 days by: 5 days)unreferencedInstanceVariables  ^self slots reject: [:slot |  slot isReferenced ]isDayPattern  ^char = $dtestDosEpoch  self useNonUtcTimeZoneDuring: [ | localEpoch |        localEpoch := '1 January 1980 00:00' asDateAndTime.        self deny: DateAndTime dosEpoch equals: localEpoch ].  self useTimeZone: 'UTC' during: [ | localEpoch |        localEpoch := '1 January 1980 00:00' asDateAndTime.        self assert: DateAndTime dosEpoch equals: localEpoch ].  self assert: DateAndTime dosEpoch equals: '1980-01-01T00:00:00+00:00' asDateAndTimeisConnectorPunctuation  ^self characterSet isConnectorPunctuation: selfsourceNodeExecuted  ^method sourceNodeExecutedForPC: self executedPCtestIntegerHex  | result |  result := 15 asInteger hex.  self assert: result equals: '16rF'.  result := 0 asInteger hex.  self assert: result equals: '16r0'.  result := 255 asInteger hex.  self assert: result equals: '16rFF'.  result := 90 asInteger hex.  self assert: result equals: '16r5A'testMutateByteStringyUsingByteAtPut  | guineaPig |  guineaPig := ByteString new: 5.  guineaPig beReadOnlyObject.  self should: [ guineaPig byteAt: 1 put: 100 ] raise: ModificationForbidden.  [ guineaPig byteAt: 1 put: 100 ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first asciiValue equals: 100isEmptyCategoryNamed: categoryName  | i |  i := categoryArray indexOf: categoryName ifAbsent: [ ^false ].  ^self isEmptyCategoryNumber: ineedsFrameSize: newFrameSize  self numTemps + newFrameSize > LargeFrame ifTrue: [ ^self error: 'Cannot compile -- stack including temps is too deep' ].  self setFrameBit: (self numTemps + newFrameSize > SmallFrame or: [ self primitive = 84 ])storeOn: aStream  self printOn: aStreamasStringYMDHM  ^String streamContents: [:aStream |  self printYMDOn: aStream.        aStream nextPut: Character space.        self hour printOn: aStream base: 10 length: 2 padded: true.        aStream nextPut: $:.        self minute printOn: aStream base: 10 length: 2 padded: true ]sizePushLiteralVar: literalIndex  ^self sizeOpcodeSelector: #genPushLiteralVar: withArguments: {literalIndex}actionMap  ^EventManager actionMapFor: selfremoveActionsSatisfying: aBlock  self actionMap keysDo: [:eachEventSelector |  self removeActionsSatisfying: aBlock forEvent: eachEventSelector ]waitUntil: aBlock maxSeconds: aNumber  ^self waitUntil: aBlock maxMilliseconds: (aNumber * 1000) asIntegertestPoolVariableAccessibleInClassUser  PoolDefiner initialize.  RootClassPoolUser compileAll.  self assert: RootClassPoolUser gloups equals: 42.  self assert: RootClassPoolUser author equals: 'Ducasse'header  ^self objectAt: 1isInstalled  self methodClass ifNotNil: [:class |  self selector ifNotNil: [:selector |  ^self == (class compiledMethodAt: selector ifAbsent: [  ]) ] ].  ^falseadaptToInteger: rcvr andSend: selector  ^rcvr asFloat perform: selector with: selfrecursion  RecursionStopper during: [ self recursion ]rfEnsure: aBlock  < primitive: 198>  < metaLinkOptions: #(+ optionDisabledLink)>  | returnValue complete |  returnValue := self rfvalueNoContextSwitch.  complete ifNil: [ complete := true.        aBlock rfvalue ].  ^returnValueorganization: aClassOrg  aClassOrg ifNotNil: [ aClassOrg setSubject: self ].  self basicOrganization: aClassOrgisInvalidPattern  ^year isNil or: [ month isNil or: [ day isNil or: [ invalidPattern ] ] ]testObjectAllSubclasses  | n2 |  n2 := Object allSubclasses size.  self assert: n2 equals: (Object allSubclasses select: [:cls |  (cls class isKindOf: Metaclass) or: [ cls isKindOf: Metaclass ] ]) sizeisBinarySelector  ^self selector allSatisfy: [:each |  each isSpecial ]testNotTheSame  | object1 object2 |  object1 := ProtoObject new.  object2 := ProtoObject new.  self assert: object1 ~~ object2.  self deny: object1 ~~ object1hasLiteral: literal  2 to: self numLiterals - 1 do: [:index |  | lit |        ((lit := self objectAt: index) literalEqual: literal) ifTrue: [ ^true ].        (lit isMemberOf: CompiledBlock) ifTrue: [ (lit hasLiteral: literal) ifTrue: [ ^true ] ] ].  ^falseisInterval  ^falsetree: aTree  | fst |  fst := Continuation currentDo: [:here |  leave := here.        self waddle: aTree.        leave value: nil ].  ^fst isSymbol ifTrue: [ self T: fst ] ifFalse: [ false ]setUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  aDateAndTime := DateAndTime     localTimeZone: TimeZone default;     unixEpoch.  aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'Unix Epoch Test Time Zone' abbreviation: 'UTZ'.  aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5asWords  | mils minus three num answer milCount |  self = 0 ifTrue: [ ^'zero' ].  mils := #('' ' thousand' ' million' ' billion' ' trillion' ' quadrillion' ' quintillion' ' sextillion' ' septillion' ' octillion' ' nonillion' ' decillion' ' undecillion' ' duodecillion' ' tredecillion' ' quattuordecillion' ' quindecillion' ' sexdecillion' ' septendecillion' ' octodecillion' ' novemdecillion' ' vigintillion').  num := self.  minus := ''.  self < 0 ifTrue: [ minus := 'negative '.        num := num negated ].  answer := String new.  milCount := 1.  [ num > 0 ] whileTrue: [ three := (num \\ 1000) threeDigitName.        num := num // 1000.        three isEmpty ifFalse: [ answer isEmpty ifFalse: [ answer := ', ' , answer ].              answer := three , (mils at: milCount) , answer ].        milCount := milCount + 1 ].  ^minus , answergrowby: n  ^self growto: self bytesCount + nfuelAccept: aGeneralMapper  ^self >= -4294967295 ifTrue: [ aGeneralMapper mapAndTraceByClusterName: self to: FLNegative32SmallIntegerCluster ] ifFalse: [ aGeneralMapper visitBytesObject: self ]isPrivateOther  ^self characterSet isPrivateOther: selfselectors  ^self methodDict keystestSourceNodeOptimizedBlock  | sourceNode method |  method := Smalltalk compiler     class: Object;     compile: 'test 1 to: 1 do: [ :i | ^ thisContext sourceNode ]'.  sourceNode := method valueWithReceiver: nil arguments: #().  self assert: sourceNode isBlockmmddyyyy  ^self printFormat: #(2 1 3 $/ 1 1)epoch  ^self class epochtestAND  self assert: true & true.  self deny: true & falseisSpecialLiteralForPush: literal  ^literal == false or: [ literal == true or: [ literal isNil or: [ literal isInteger and: [ literal between: -1 and: 2 ] ] ] ]removeProperty: propName  | value |  value := self propertyAt: propName ifAbsent: [ ^nil ].  self penultimateLiteral: (self penultimateLiteral copyWithout: (Association key: propName value: value)).  ^valuehandles: anException  ^exceptions anySatisfy: [:exception |  exception handles: anException ]waitWhile: aBlock for: aSymbolOrNil maxSeconds: aNumber  ^self waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asIntegerprotocols  ^protocols asArrayhaltOnce  < debuggerCompleteToSender>  Halt oncetestWaitTimeDurationWithCompletionAndTimeoutBlocks  self assert: (Semaphore new wait: 50 milliSeconds onCompletion: [ #completed ] onTimeout: [ #timeout ]) identicalTo: #timeout.  self assert: (Semaphore new signal wait: 50 milliSeconds onCompletion: [ #completed ] onTimeout: [ #timeout ]) identicalTo: #completedlogExit  self traceCr: 'Exited ' , thisContext sender printStringfileOutOn: aFileStream  aFileStream nextChunkPut: self definition.  self organization putCommentOnFile: aFileStream forClass: self.  self organization categories do: [:heading |  self fileOutLocalMethodsInCategory: heading on: aFileStream ]testAddMonths  self assert: (january23rd2004 addMonths: 0) equals: '2004-01-23' asDate.  self assert: (january23rd2004 addMonths: 1) equals: '2004-02-23' asDate.  self assert: (january23rd2004 addMonths: 12) equals: '2005-01-23' asDateasRingDefinition  ^self asActiveRingDefinitiontestTruncated  self assert: 1.0 truncated equals: 1.  self assert: 1.1 truncated equals: 1.  self assert: -2.0 truncated equals: -2.  self assert: -2.1 truncated equals: -2print: positiveNumberString on: aStream prefix: prefix length: minimum padded: zeroFlag  | padLength |  padLength := minimum - positiveNumberString size - prefix size.  padLength > 0 ifTrue: [ zeroFlag ifTrue: [ aStream                 nextPutAll: prefix;                 nextPutAll: (String new: padLength withAll: $0) ] ifFalse: [ aStream                 nextPutAll: (String new: padLength withAll: Character space);                 nextPutAll: prefix ] ] ifFalse: [ aStream nextPutAll: prefix ].  aStream nextPutAll: positiveNumberStringtearDown  fork ifNotNil: [ fork terminate.        fork := nil ].  super tearDownretryWithGC: execBlock until: testBlock  | blockValue |  blockValue := execBlock value.  (testBlock value: blockValue) ifTrue: [ ^blockValue ].  Smalltalk garbageCollectMost.  blockValue := execBlock value.  (testBlock value: blockValue) ifTrue: [ ^blockValue ].  Smalltalk garbageCollect.  ^execBlock valuetestTo  self assert: (anIncludedTimespan to: jan08) equals: aTimespanprepareForSimulationWith: numArgs  | newHeader |  newHeader := ((self header bitAnd: 2r01110000000000111111111111111111) bitOr: (numArgs bitShift: 24)) bitOr: (numArgs + 1 bitShift: 18).  newHeader := newHeader + (self class headerFlagForEncoder: self encoderClass).  self objectAt: 1 put: newHeader.  self encoderClass prepareMethod: self forSimulationWith: numArgstestArgumentNamed  | pragma |  pragma := (self class >> #methodWithPragma) pragmas anyOne.  self assert: (pragma argumentNamed: #testPragmaArg1) equals: #toto.  self assert: (pragma argumentNamed: #arg2) equals: 2.  self assert: (pragma argumentNamed: #arg3).  self should: [ pragma argumentNamed: #nonExisting ] raise: ErrortestLog  self assert: (100 log closeTo: 2).  self assert: ((2 raisedTo: Float emax + 3) log closeTo: 2 log * (Float emax + 3)) description: 'Integer>>log should not overflow'testDaysLeftInYear  self assert: aDateAndTime daysLeftInYear equals: 365testNegated  self assert: aDuration + aDuration negated equals: (Duration seconds: 0)spotterForSendersFor: aStep  < spotterOrder: 10>  self method spotterForSendersFor: aStepvalidIndex: index  ^index > 0 and: [ index <= self size ]testToBy  self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) equals: ((DateAndTime year: 1980 month: 1 day: 1) to: (DateAndTime year: 1980 month: 1 day: 1) + 10 days by: 5 days)testallClassVariables  self assert: SmalltalkImage allClassVariables last name equals: #DependentsFieldsinstancesSizeInMemory  | bytes |  bytes := 0.  self allInstancesDo: [:each |  bytes := bytes + each sizeInMemory ].  ^bytessubclass: aSubclassSymbol slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames package: aCategorySymbol  ^self classInstaller make: [:builder |  builder           name: aSubclassSymbol;           superclass: self;           slots: slotDefinition;           sharedVariables: classVarDefinition;           sharedPools: someSharedPoolNames;           category: aCategorySymbol ]tearDown  self deleteClass.  {self unclassifiedCategory .   self categoryNameForTemporaryClasses} do: [:category |  RPackage organizer unregisterPackageNamed: category ].  super tearDownmustBeBooleanCompileExpression: context andCache: cache  | sendNode methodNode pc method pcAfterJump |  pc := context pc - 1.  sendNode := context sourceNode sourceNodeForPC: pc.  RBParseTreeRewriter new     replace: '^ ``@value' with: 'ThisContext home return: ``@value';     executeTree: sendNode.  methodNode := sendNode copy asDoitForContext: context.  methodNode compilationContext: sendNode methodNode compilationContext copy.  methodNode compilationContext compilerOptions: #(- optionInlineIf optionInlineAndOr optionInlineWhile).  OCASTSemanticCleaner clean: methodNode.  method := methodNode generate.  pcAfterJump := sendNode irInstruction nextBytecodeOffsetAfterJump.  method propertyAt: #mustBeBooleanJump put: pcAfterJump.  cache at: pc put: method.  ^methodrecompile: selector  ^self recompile: selector from: selffractionPart  ^self - self integerParttestSourceNodeExecutedWhenContextIsJustAtStartpc  | sourceNode context |  context := Context sender: thisContext receiver: self method: self class >> testSelector arguments: #().  sourceNode := context sourceNodeExecuted.  self assert: sourceNode equals: (self class >> testSelector) ast sendNodes first receiverreturn: value through: firstUnwindContext  sender ifNil: [ self cannotReturn: value to: sender ].  sender resume: value through: firstUnwindContextsignBit  ^1print24: hr24 on: aStream  | h m s |  h := self hour.  m := self minute.  s := self second.  hr24 ifTrue: [ h < 10 ifTrue: [ aStream nextPut: $0 ].        h printOn: aStream ] ifFalse: [ h > 12 ifTrue: [ h - 12 printOn: aStream ] ifFalse: [ h < 1 ifTrue: [ 12 printOn: aStream ] ifFalse: [ h printOn: aStream ] ] ].  aStream nextPutAll: (m < 10 ifTrue: [ ':0' ] ifFalse: [ ':' ]).  m printOn: aStream.  aStream nextPutAll: (s < 10 ifTrue: [ ':0' ] ifFalse: [ ':' ]).  s printOn: aStream.  hr24 ifFalse: [ aStream nextPutAll: (h < 12 ifTrue: [ ' am' ] ifFalse: [ ' pm' ]) ]becomeForward: otherObject  {self} elementsForwardIdentityTo: {otherObject}ifTrue: alternativeBlock  ^nil= anObject  ^self class == anObject class and: [ context = anObject context and: [ context ifNil: [ explanationString = anObject explanationString ] ifNotNil: [ true ] ] ]printOn: aStream showingDecimalPlaces: placesDesired  | roundedFractionPart integerPart scaling |  placesDesired <= 0 ifTrue: [ self rounded printOn: aStream ] ifFalse: [ scaling := 10 raisedToInteger: placesDesired.        integerPart := numerator abs quo: denominator.        roundedFractionPart := (numerator abs - (integerPart * denominator)) * scaling * 2 + denominator quo: denominator * 2.        roundedFractionPart = scaling ifTrue: [ integerPart := integerPart + 1.              roundedFractionPart := 0 ].        (numerator negative and: [ integerPart > 0 or: [ roundedFractionPart > 0 ] ]) ifTrue: [ aStream nextPut: $- ].        integerPart printOn: aStream.        aStream nextPut: $..        roundedFractionPart printOn: aStream base: 10 length: placesDesired padded: true ]calleeOf: aContext  suspendedContext == aContext ifTrue: [ ^nil ].  ^(suspendedContext findContextSuchThat: [:c |  c sender == aContext ]) ifNil: [ self error: 'aContext not in process chain' ]isClosure  ^falseveryDeepCopyWith: deepCopier  ^selfisRingFullyResolved  ^truetraitConflict  self error: 'A class or trait does not properly resolve a conflict between multiple traits it uses.'sameLiteralsAs: method  | numLits literal1 literal2 |  (numLits := self numLiterals) ~= method numLiterals ifTrue: [ ^false ].  1 to: numLits - 1 do: [:index |  literal1 := self literalAt: index.        literal2 := method literalAt: index.        (literal1 == literal2 or: [ literal1 literalEqual: literal2 ]) ifFalse: [ ^false ] ].  ^truepopTo: aContext value: aValue  self == Processor activeProcess ifTrue: [ ^self error: 'The active process cannot pop contexts' ].  ^(self calleeOf: aContext) ifNil: [ aContext ] ifNotNil: [:callee |  Processor activeProcess evaluate: [ self return: callee value: aValue ] onBehalfOf: self ]linksDo: aBlock  | aLink |  aLink := firstLink.  [ aLink == nil ] whileFalse: [ aBlock value: aLink.        aLink := aLink nextLink ]<= aNumber  < primitive: 5>  ^super <= aNumberdecodeLengthField  | numBytes pos length |  pos := method size.  numBytes := ((method at: pos) bitAnd: 3) + 1.  length := 0.  1 to: numBytes do: [:i |  length := (length << 8) + (method at: pos - i) ].  size := 1 + numBytes + length.  ^lengthassertSqrtCorrectlyRoundedForExponent: exp  {1.5 .   1.25 squared .   2.0 predecessor} do: [:sf |  | f xe xp xm |        f := sf timesTwoPower: exp.        xe := f asInteger + (f ulp asInteger / 2).        xm := xe squared - 1.        xp := xe squared + 1.        self assert: xe squared sqrt equals: xe.        self assert: xe squared sqrt isInteger.        self assert: xm sqrt equals: f.        self assert: xm sqrt isFloat.        self assert: xp sqrt equals: f successor.        self assert: xp sqrt isFloat.        xe := f asInteger - (f ulp asInteger / 2).        xm := xe squared - 1.        xp := xe squared + 1.        self assert: xe squared sqrt equals: xe.        self assert: xe squared sqrt isInteger.        self assert: xm sqrt equals: f predecessor.        self assert: xm sqrt isFloat.        self assert: xp sqrt equals: f.        self assert: xp sqrt isFloat ]packToArity: arity  | rolledPointer |  rolledPointer := self.  1 to: arity do: [:index |  rolledPointer := rolledPointer pointer ].  ^rolledPointergenPushNewArray: size  (size < 0 or: [ size > 127 ]) ifTrue: [ ^self outOfRangeError: 'numElements' index: size range: 0 to: 127 ].  stream     nextPut: 138;     nextPut: sizeisRequired: marker  marker ifNil: [ ^false ].  (self isExplicitlyRequired: marker) ifTrue: [ ^true ].  (self isSubclassResponsibility: marker) ifTrue: [ ^true ].  ^falsetestAllReferencesTo  | result |  result := SystemNavigation new allReferencesTo: Point binding.  result do: [:each |  self assert: (each compiledMethod hasLiteral: Point binding) ].  self assert: (result anySatisfy: [:each |  each actualClass = self class and: [ each selector = #testAllReferencesTo ] ]).  result := SystemNavigation new allReferencesTo: #printOn:.  result do: [:each |  self assert: (each compiledMethod hasLiteralThorough: #printOn:) ].  self assert: (result anySatisfy: [:each |  each actualClass = self class and: [ each selector = #testAllReferencesTo ] ]).  result := SystemNavigation new allReferencesTo: #+.  result do: [:each |  self assert: ((each compiledMethod sendsSelector: #+) or: [ each compiledMethod hasLiteralThorough: #+ ]) ].  self assert: (result anySatisfy: [:each |  each actualClass = self class and: [ each selector = #testAllReferencesTo ] ])hasClassSide  ^self classSide notNiltestAsLargerPowerOfTwo  self assert: (1 / 2) asLargerPowerOfTwo equals: 1 / 2.  self assert: (Fraction numerator: 2 denominator: 4) asLargerPowerOfTwo equals: 1 / 2.  self assert: (2 / 5) asLargerPowerOfTwo equals: 1 / 2.  self assert: (Fraction numerator: 10 denominator: 25) asLargerPowerOfTwo equals: 1 / 2.  self assert: (Fraction numerator: 2 denominator: 1) asLargerPowerOfTwo equals: 2.  self assert: (Fraction numerator: 4 denominator: 2) asLargerPowerOfTwo equals: 2.  self assert: (3 / 2) asLargerPowerOfTwo equals: 2.  self assert: (Fraction numerator: 12 denominator: 8) asLargerPowerOfTwo equals: 2.  self assert: (1 / (2 raisedTo: 80)) asLargerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160)) asLargerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (1 / ((2 raisedTo: 80) + 1)) asLargerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160) + 1) asLargerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: 1) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 160) denominator: (2 raisedTo: 80)) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) - 1 denominator: 1) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 160) - 1 denominator: (2 raisedTo: 80)) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self should: [ (Fraction numerator: 0 denominator: 1) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 negated denominator: 2) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 denominator: 2 negated) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 2 negated denominator: 4) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 2 denominator: 4 negated) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 negated denominator: (2 raisedTo: 80)) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 denominator: (2 raisedTo: 80) negated) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: (2 raisedTo: 80) negated denominator: (2 raisedTo: 160)) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160) negated) asLargerPowerOfTwo ] raise: DomainErrortestLiterals  self assertEmpty: (Object >> #yourself) literals.  self assert: (Object >> #yourself) allLiterals size equals: 2.  self deny: (Object >> #yourself hasLiteral: #yourself)tearDown  scheduler debug: false.  super tearDownextensionSelectors  ^self extendingPackages flatCollect: [:each |  each extensionSelectorsForClass: self ]literalEqual: other  ^(super literalEqual: other) and: [ self isZero not or: [ self signBit = other signBit ] ]waitMaxSeconds: aNumber  ^self waitMaxMilliseconds: (aNumber * 1000) asIntegerrehash  | newInstance |  newInstance := self species newForCapacity: self basicSize.  1 to: self basicSize do: [:index |  (self basicAt: index) ifNotNil: [:key |  newInstance at: key put: (array at: index) ] ].  self copyFrom: newInstanceisResumable  ^truegenPushTemp: tempIndex  tempIndex < 0 ifTrue: [ ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63 ].  tempIndex < 16 ifTrue: [ stream nextPut: 16 + tempIndex.        ^self ].  tempIndex < 64 ifTrue: [ stream           nextPut: 128;           nextPut: 64 + tempIndex.        ^self ].  ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63testSubclassInstVar  | subclasses |  SystemNavigation new allClassesDo: [:cls |  subclasses := cls subclasses.        self assert: subclasses isNil not.        subclasses do: [:subclass |  self assert: (subclasses occurrencesOf: subclass) equals: 1.              self assert: subclass superclass identicalTo: cls ] ]asMonth  ^Month starting: selfgtInspectorIntegerIn: composite  < gtInspectorPresentationOrder: 30>  ^composite table     title: 'Integer';     display: [ | associations |        associations := {('decimal' -> self printString) .         ('hex' -> self printStringHex) .         ('octal' -> (self printStringBase: 8)) .         ('binary' -> (self printStringBase: 2))} asOrderedCollection.        (self between: 0 and: 16r10FFFF) ifTrue: [ associations add: 'character' -> self asCharacter ].        associations ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: [:each |  each value printString ];     send: #valuetestDuration  self assert: january23rd2004 duration equals: 24 hoursclassForScheduler  ^DelaySemaphoreSchedulerright  ^righttestAnd  self assert: (true and: [ 'alternativeBlock' ]) equals: 'alternativeBlock'isUsed  ^self isReferencedtestHandlingWhenThereIsSomeExclusionButDontApplies  | wasHandled result |  wasHandled := false.  result := [ ZeroDivide signalWithDividend: 1.  2 ] on: Error - MessageNotUnderstood do: [:exception |  wasHandled := true.        exception return ].  self     assert: wasHandled;     assert: result isNilsharedPoolOfVarNamed: aString  ^nildoubleOuterPassTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselfdividend  ^dividendtestAllMethodCategoriesIntegratedThrough  self assert: ((CompiledMethod selectorsInProtocol: 'testing') includes: #isAbstract).  CompiledMethod allProtocolsUpTo: Object.  self assert: ((CompiledMethod selectorsInProtocol: 'testing') includes: #isAbstract)asCharacter  < primitive: 170>  ^self primitiveFailedhasSelectorReferringTo: literal  ^self methods anySatisfy: [:method |  method hasLiteral: literal ]populateCBMenu: aMenu  super populateCBMenu: aMenu.  aMenu add: 'References to...' target: SystemNavigation new selector: #browseAllCallsOnClass: argument: selfrounded  ^self species basicNew ticks: {julianDayNumber .         (nanos * 2 >= NanosInSecond ifTrue: [ seconds + 1 ] ifFalse: [ seconds ]) .         0} offset: offsettestLocalVariable  | s1 s2 p1stopped p2stopped |  s1 := Semaphore new.  s2 := Semaphore new.  p1stopped := p2stopped := false.  [ self checkLocal: 0.  TestLocalVariable value: 1.  self checkLocal: 1.  (Delay forMilliseconds: 30) wait.  self checkLocal: 1.  TestLocalVariable value: 2.  self checkLocal: 2.  p1stopped := true.  s1 signal ] fork.  [ (Delay forMilliseconds: 30) wait.  self checkLocal: 0.  TestLocalVariable value: 3.  self checkLocal: 3.  (Delay forMilliseconds: 30) wait.  self checkLocal: 3.  TestLocalVariable value: 4.  self checkLocal: 4.  p2stopped := true.  s2 signal ] fork.  s1 waitTimeoutMSecs: 5000.  s2 waitTimeoutMSecs: 5000.  self assert: p1stopped.  self assert: p2stoppedseverity  ^#errortestReset  | sw |  sw := Stopwatch new.  sw activate.  sw reset.  self     assert: sw isSuspended;     assertEmpty: sw timespansfallbackMenuOn: aMenuMorph  testReadFromBogus  self should: [ Duration readFrom: '+0:01:02' readStream ] raise: ErrorisDisabled: marker  ^marker == self class disabledMarkerwhichSelectorsAccess: instVarName  ^self slotNamed: instVarName ifFound: [:slot |  self selectors select: [:sel |  slot isAccessedIn: self >> sel ] ] ifNone: [ #() ]>> shiftAmount  shiftAmount < 0 ifTrue: [ self error: 'negative arg' ].  ^self bitShift: 0 - shiftAmountkey  ^self selectortestUnionWithSeparate  self assert: (anOverlappingTimespan union: aDisjointTimespan) equals: (Timespan starting: anOverlappingTimespan start ending: aDisjointTimespan end + DateAndTime clockPrecision)hasSourceCode  | trailer source |  trailer := self trailer.  trailer sourceCode ifNotNil: [:code |  ^true ].  trailer hasSourcePointer ifFalse: [ ^false ].  source := [ self getSourceFromFile ] on: Error do: [:ex |  ex return: nil ].  source isEmptyOrNil ifTrue: [ ^false ].  ^truetestAddClassSlot  | tutu slot1 slot2 |  tutu := testEnvironment at: #TUTU.  slot1 := #X => InstanceVariableSlot.  slot2 := #Y => InstanceVariableSlot.  tutu addClassSlot: slot1.  self assert: tutu class instVarNames equals: #(#X).  tutu addClassSlot: slot2.  self assert: tutu class instVarNames equals: #(#X #Y)classThatDefinesInstanceVariable: instVarName  self deprecated: 'use #classThatDefinesInstVarNamed:' transformWith: '`@receiver classThatDefinesInstanceVariable: `@statement' -> '`@receiver classThatDefinesInstVarNamed: `@statement'.  ^self classThatDefinesInstVarNamed: instVarNametestTicks  self assert: aDateAndTime ticks equals: (DateAndTime julianDayNumber: 2415386) ticks.  self assert: aDateAndTime ticks equals: #(2415386 0 0)shiftLevelDown  < metaLinkOptions: #(+ optionDisabledLink)>  level ifNil: [ level := 0 ].  (level rfIsEqual: 0) ifTrue: [ ^level ].  (level rfIsEqual: 1) ifTrue: [ ^level := 0 ].  level := level rfMinus: 1wantsSteps  ^falsegreaseInteger  ^selforganization  self basicOrganization ifNil: [ self basicOrganization: (self isTrait ifTrue: [ ClassOrganization new ] ifFalse: [ ClassOrganization forClass: self ]) ].  ^self basicOrganization setSubject: selftearDown  forkedProcesses do: #terminate.  super tearDownactions  ^super actions copyWith: (RePropertyAction new           icon: (self iconNamed: #smallWindow);           description: 'Open dependency analyzer';           action: [:crit :package |  self openDependencyAnalyzerOn: package ];           yourself)print: anObject on: aStream  | title |  (anObject class canUnderstand: #printOn:) ifTrue: [ ^anObject printOn: aStream ].  title := anObject class name.  aStream     nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);     nextPutAll: titletestCloseTo  self deny: (Float nan closeTo: Float nan) description: 'NaN isn''t close to anything'.  self deny: (Float nan closeTo: 1.0) description: 'NaN isn''t close to anything'.  self deny: (1.0 closeTo: Float nan) description: 'NaN isn''t close to anything'.  self deny: (-1.0 closeTo: 1.0).  self deny: (1.0 closeTo: Float infinity).  self assert: (Float infinity closeTo: Float infinity) description: 'since they are =, they also are closeTo:'.  self assert: (1.0 / 3.0 closeTo: 1 / 3).  self assert: (1.0e-8 closeTo: 0).  self assert: (0 closeTo: 1.0e-8).  self assert: (1 + 1.0e-8 closeTo: 1.0).  self assert: (1000000001.0 closeTo: 1000000000.0).  self deny: (1000000001 closeTo: 1000000000) description: 'exact representation are considered closeTo: only if equal'testRuleDoesNotFailIfAppliedOnNonBootstrapPackage  | rule critiques |  rule := PharoBootstrapRule new.  rule class classVarNamed: 'DependencyChecker' put: PharoBootstrapAnalyzerStubWithNoNewDependency.  critiques := rule check: (RPackage named: #P1).  self assertEmpty: critiquesaddLast: aLinkOrObject  | aLink |  aLink := aLinkOrObject asLink.  self isEmpty ifTrue: [ firstLink := aLink ] ifFalse: [ lastLink nextLink: aLink ].  lastLink := aLink.  ^aLinkremoveLink: aLink ifAbsent: aBlock  | tempLink |  aLink == firstLink ifTrue: [ firstLink := aLink nextLink.        aLink == lastLink ifTrue: [ lastLink := nil ] ] ifFalse: [ tempLink := firstLink.        [ tempLink == nil ifTrue: [ ^aBlock value ].        tempLink nextLink == aLink ] whileFalse: [ tempLink := tempLink nextLink ].        tempLink nextLink: aLink nextLink.        aLink == lastLink ifTrue: [ lastLink := tempLink ] ].  ^aLinklargeIdentityHash  | remainder hash |  self >= 0 ifTrue: [ remainder := self.        hash := 0 ] ifFalse: [ remainder := 0 - self.        hash := 4095 ].  [ hash := hash bitXor: (remainder bitAnd: 4095).  (remainder := remainder bitShift: -12) = 0 ] whileFalse.  ^FLLargeIdentityHashedCollection permuteHash: hash + 1testOr  self assert: (false or: [ 'alternativeBlock' ]) equals: 'alternativeBlock'gtInspectorFloatIn: composite  < gtInspectorPresentationOrder: 30>  ^composite table     title: 'Float';     display: [ (self respondsTo: #binaryLiteralString) ifTrue: [ {('binary' -> self binaryLiteralString) .               ('significand' -> self significand) .               ('exponent' -> self exponent)} ] ifFalse: [ {('significand' -> self significand) .               ('exponent' -> self exponent)} ] ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valuemilliSeconds  ^Duration milliSeconds: selftestCompile  | behavior |  behavior := Behavior new.  behavior compile: 'thisIsATest ^2'.  behavior new thisIsATestswapSender: coroutine  | oldSender |  oldSender := sender.  sender := coroutine.  ^oldSender< aNumber  < primitive: 43>  ^aNumber adaptToFloat: self andCompare: #<valueOrNil  ^Processor activeProcess psValueAt: indexwriteStream  ^WriteStream on: selfclassSide  ^self classffiBindingOf: aName  ^self bindingOf: aNameparse: aTimeUnitName  ^Integer readFrom: inputStream ifFail: [ DateError signal: 'Expecting a ' , aTimeUnitName ]testPrintString  | sd |  sd := 13 / 11 asScaledDecimal: 6.  self assert: '1.181818s6' equals: sd printString.  sd := 13 / 11 asScaledDecimal: 5.  self assert: '1.18182s5' equals: sd printString.  sd := 13 / 11 asScaledDecimal: 5.  self deny: '1.18181s5' equals: sd printStringobject: anObject basicAt: index put: value  < primitive: 61>  index isInteger ifTrue: [ (index >= 1 and: [ index <= (self objectSize: anObject) ]) ifFalse: [ self errorSubscriptBounds: index ] ].  index isNumber ifTrue: [ ^self object: anObject basicAt: index asInteger put: value ] ifFalse: [ self errorNonIntegerIndex ].  anObject isReadOnlyObject ifTrue: [ ^(ModificationForbidden new           object: anObject;           fieldIndex: index;           newValue: value;           retrySelector: #basicAt:put:) signal ].  self errorImproperStoretestNew  self should: [ Boolean new ] raise: self defaultTestErrortestBitAt  | trials bitSequence2 |  self assert: (2r10 bitAt: 1) equals: 0.  self assert: (2r10 bitAt: 2) equals: 1.  self assert: ((1 to: 100) allSatisfy: [:i |  (0 bitAt: i) = 0 ]) description: 'all bits of zero are set to zero'.  self assert: ((1 to: 100) allSatisfy: [:i |  (-1 bitAt: i) = 1 ]) description: 'In two complements, all bits of -1 are set to 1'.  trials := #('2r10010011' '2r11100100' '2r10000000' '2r0000101011011001' '2r1000101011011001' '2r0101010101011000' '2r0010011110110010' '2r0010011000000000' '2r00100111101100101000101011011001' '2r01110010011110110010100110101101' '2r10101011101011001010000010110110' '2r10101000000000000000000000000000' '2r0010101110101001110010100000101101100010011110110010100010101100' '2r1010101110101100101000001011011000100111101100101000101011011001' '2r1010101110101000000000000000000000000000000000000000000000000000').  trials do: [:bitSequence |  | aNumber |        aNumber := Number readFrom: bitSequence.        bitSequence2 := (bitSequence size - 2 to: 1 by: -1) inject: '2r' into: [:string :i |  string copyWith: (Character digitValue: (aNumber bitAt: i)) ].        self assert: bitSequence2 equals: bitSequence ].  trials do: [:bitSequence |  | bitInvert |        bitInvert := -1 - (Number readFrom: bitSequence).        bitSequence2 := (bitSequence size - 2 to: 1 by: -1) inject: '2r' into: [:string :i |  string copyWith: (Character digitValue: 1 - (bitInvert bitAt: i)) ].        self assert: bitSequence2 = bitSequence description: '-1-x is similar to a bitInvert operation in two complement' ]sizePushNewArray: size  ^self sizeOpcodeSelector: #genPushNewArray: withArguments: {size}<= aMagnitude  ^(self > aMagnitude) notremoveMethodTag: aSymbol  self organization removeCategory: aSymbolgenStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex  (tempIndex < 0 or: [ tempIndex >= 256 ]) ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255 ].  (tempVectorIndex < 0 or: [ tempVectorIndex >= 128 ]) ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127 ].  stream     nextPut: 253;     nextPut: tempIndex;     nextPut: tempVectorIndexcopyWithout: oldElement  | newInst |  newInst := self class new.  self do: [:each |  each = oldElement ifFalse: [ newInst add: each ] ].  ^newInsttestAsTimeUTC  | dateAndTime |  dateAndTime := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 0 asDuration.  self assert: dateAndTime asTimeUTC equals: (Time hour: 1 minute: 2 second: 3).  dateAndTime := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: -5 hours.  self assert: dateAndTime asTimeUTC equals: (Time hour: 6 minute: 2 second: 3).  dateAndTime := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 5 hours.  self assert: dateAndTime asTimeUTC equals: (Time hour: 24 + 1 - 5 minute: 2 second: 3)findContextMatchingPredicate: aPredicate  ^self findContextSuchThat: [:ctx |  aPredicate matches: ctx ]testSimpleAccessors  | t |  t := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self     assert: t hours equals: t hours;     assert: t minutes equals: t minute;     assert: t seconds equals: t seconderrorNonIntegerIndex  self error: 'only integers should be used as indices'restoreLocalTimeZoneAfter: aBlock  | realTimeZone |  realTimeZone := DateAndTime localTimeZone.  aBlock ensure: [ DateAndTime localTimeZone: realTimeZone ]testYear  self assert: aDateAndTime year equals: 1901testActivateReturnValue  self assert: ((aSender activateReturn: aMethodContext value: #()) isKindOf: Context).  self assert: (aSender activateReturn: aMethodContext value: #()) receiver equals: aMethodContextcrossSumBase: aBase  | aResult |  [ aBase isInteger and: [ aBase >= 2 ] ] assert.  self < 0 ifTrue: [ ^self negated crossSumBase: aBase ].  self < aBase ifTrue: [ ^self ].  aResult := self \\ aBase + (self // aBase crossSumBase: aBase).  [ aResult \\ (aBase - 1) = 0 = (self \\ (aBase - 1) = 0) ] assert.  ^aResulttestIsOtherPunctuation  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isOtherPunctuation: ch) equals: (charset isOtherPunctuation: ch) ]populateCBMenu: aMenu  aMenu add: 'Browse' target: self selector: #browsemethod  ^methodincludes: aPropertyOrPragma  1 to: self basicSize do: [:i |  (self basicAt: i) = aPropertyOrPragma ifTrue: [ ^true ] ].  ^falsesizeStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex  ^self sizeOpcodeSelector: #genStorePopRemoteTemp:inVectorAt: withArguments: {tempIndex .         tempVectorIndex}notYetImplemented  NotYetImplemented signalFor: thisContext sender selectorasSmallerPowerOfTwo  ^self isPowerOfTwo ifTrue: [ self ] ifFalse: [ self > 0 ifTrue: [ 1 bitShift: self highBit - 1 ] ifFalse: [ DomainError signal: 'Value outside (0 , infinity)' from: 0 ] ]criticTheNonMetaclassClass  ^self instanceSide+ operand  ^self class nanoSeconds: self asNanoSeconds + operand asNanoSecondsprintOn: aStream  super printOn: aStream.  aStream nextPutAll: ' in '.  suspendedContext printOn: aStreamtestPrintPaddedWith  self assert: (123 printPaddedWith: $0 to: 10 base: 2) equals: '0001111011'.  self assert: (123 printPaddedWith: $0 to: 10 base: 8) equals: '0000000173'.  self assert: (123 printPaddedWith: $0 to: 10 base: 10) equals: '0000000123'.  self assert: (123 printPaddedWith: $0 to: 10 base: 16) equals: '000000007B'suspendFirstAt: aPriority  ^self suspendFirstAt: aPriority ifNone: [ self error: 'No Process to suspend' ]flushCache  < primitive: 89>  self primitiveFailedresumptionTickAdjustFrom: oldBaseTick to: newBaseTick  resumptionTick := resumptionTick - oldBaseTick + newBaseTickdefaultResumeValue  ^niltestConverting  self assert: time asSeconds equals: 14567raisedToInteger: anInteger  | bitProbe result |  anInteger negative ifTrue: [ ^(self raisedToInteger: anInteger negated) reciprocal ].  bitProbe := 1 bitShift: anInteger highBit - 1.  result := self class one.  [ (anInteger bitAnd: bitProbe) = 0 ifFalse: [ result := result * self ].  bitProbe := bitProbe bitShift: -1.  bitProbe > 0 ] whileTrue: [ result := result * result ].  ^result+ aNumber  aNumber class = self class ifTrue: [ ^self asFraction + aNumber asFraction asScaledDecimal: (scale max: aNumber scale) ].  ^self coerce: self asFraction + aNumberffiLibrary  ^self ffiLibraryName asFFILibrarybitAnd: n  < primitive: 'primDigitBitAnd' module: 'LargeIntegers'>  | norm |  norm := n normalize.  ^self digitLogic: norm op: #bitAnd: length: (self bytesCount max: norm bytesCount)classSideCompilerClass  ^Smalltalk compilerClasstestPrintShowingDecimalPlaces2  self assert: (5000000000000001.0 printShowingDecimalPlaces: 0) equals: '5000000000000001'.  self assert: (50000000000001.25 printShowingDecimalPlaces: 2) equals: '50000000000001.25'.  1.0e306 printShowingDecimalPlaces: 3nthRoot: anInteger  | nthRoot |  nthRoot := self asFraction nthRoot: anInteger.  ^nthRoot isFloat ifTrue: [ nthRoot ] ifFalse: [ nthRoot asScaledDecimal: scale ]doubleOuterPassTest  [ [ [ self doSomething.  MyTestNotification signal.  self doSomethingExceptional ] on: MyTestNotification do: [:ex |  ex outer.        self doSomethingElse ] ] on: MyTestNotification do: [:ex |  ex pass.        self doSomethingExceptional ] ] on: MyTestNotification do: [:ex |  self doYetAnotherThing.        ex resume ]testPreviousNext  | n p |  n := month next.  p := month previous.  self     assert: n year equals: 1998;     assert: n index equals: 8;     assert: p year equals: 1998;     assert: p index equals: 6value: anObject during: aBlock  | activeProcess oldValue |  activeProcess := Processor activeProcess.  oldValue := activeProcess psValueAt: index.  ^[ activeProcess psValueAt: index put: anObject.  aBlock value ] ensure: [ activeProcess psValueAt: index put: oldValue ]first  self do: [:dep |  ^dep ].  self error: 'this collection is empty'numberOfMethods  | num |  num := self localMethods size.  ^self isMeta ifTrue: [ num ] ifFalse: [ num + self classSide numberOfMethods ]addCategory: newCategory  ^self addCategory: newCategory before: niltestTallyInstructions  | expectedResult |  expectedResult := aBlockContext method encoderClass = EncoderForSistaV1 ifTrue: [ 26 ] ifFalse: [ 27 ].  self assert: (Context tallyInstructions: aBlockContext) size equals: expectedResultserializeOn: anEncoder  useNonUtcTimeZoneDuring: aBlock  self useTimeZone: 'EDT' during: aBlocktinyBenchmarks  | t1 t2 r n1 n2 |  n1 := 1.  [ t1 := Time millisecondsToRun: [ n1 benchmark ].  t1 < 1000 ] whileTrue: [ n1 := n1 * 2 ].  n2 := 28.  [ t2 := Time millisecondsToRun: [ r := n2 benchFib ].  t2 < 1000 ] whileTrue: [ n2 := n2 + 1 ].  ^(n1 * 500000 * 1000 // t1) printString , ' bytecodes/sec; ' , (r * 1000 // t2) printString , ' sends/sec'top  ^self at: stackpdecodeUndefined  self error: 'undefined method encoding'pass  handlerContext nextHandlerContext handleSignal: selfvariableWriteNodes  ^self ast variableWriteNodestestHumanReadablePrintString  self assert: 0 seconds humanReadablePrintString equals: '0 seconds'.  self assert: 1 second humanReadablePrintString equals: '1 second'.  self assert: 1 second negated humanReadablePrintString equals: '- 1 second'.  self assert: 1002003004 nanoSeconds humanReadablePrintString equals: '1 second 2 milliseconds 3 microseconds 4 nanoseconds'.  self assert: (Duration days: 1 hours: 1 minutes: 1 seconds: 1) humanReadablePrintString equals: '1 day 1 hour 1 minute 1 second'.  self assert: (Duration days: 2 hours: 4 minutes: 8 seconds: 16) humanReadablePrintString equals: '2 days 4 hours 8 minutes 16 seconds'.  self shouldnt: [ 17.6782 years humanReadablePrintString ] raise: MessageNotUnderstoodenvironment  ^self class environmentisCompact  ^falseinstVarName: anObject  instVarName := anObjecttestSetIsReadOnlySuccess  self maybeReadOnlyObjects do: [:each |  self testObject: each initialState: false tuples: #(#(true false true) #(false true false)) ]variableWordSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat  ^self variableWordSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: catparseSameChar  inputStream next = char ifFalse: [ invalidPattern := true ]object: anObject basicAt: index  < primitive: 60>  index isInteger ifTrue: [ self errorSubscriptBounds: index ].  index isNumber ifTrue: [ ^self object: anObject basicAt: index asInteger ] ifFalse: [ self errorNonIntegerIndex ]testFromSeconds  | d |  d := self dateClass fromSeconds: june2nd1973 asSeconds.  self assert: d equals: june2nd1973deprecatedMethod  self deprecated: 'I am deprecated for tests'ifFalse: alternativeBlock  self subclassResponsibilitygpsExample2: aCollection  | js i j |  js := [:a :idx :n |  | sum |  sum := 0.  idx first value: 1.  [ idx last value <= n last value ] whileTrue: [ sum := sum + a last value.        idx first value: idx last value + 1 ].  sum ].  ^js value: (Array with: [:val |  self error: 'can not assign to procedure' ] with: [ js value: (Array with: [:val |  (aCollection at: i) at: j put: val ] with: [ (aCollection at: i) at: j ]) value: (Array with: [:val |  j := val ] with: [ j ]) value: (Array with: [:val |  self error: 'can not assign to constant' ] with: [ aCollection size ]) ]) value: (Array with: [:val |  i := val ] with: [ i ]) value: (Array with: [:val |  self error: 'can not assign to constant' ] with: [ aCollection size ])testValueWithPossibleArgs  | block blockWithArg blockWith2Arg |  block := [ 1 ].  blockWithArg := [:arg |  arg ].  blockWith2Arg := [:arg1 :arg2 |  {arg1 .   arg2} ].  self assert: (block valueWithPossibleArgs: #()) equals: 1.  self assert: (block valueWithPossibleArgs: #(1)) equals: 1.  self assert: (blockWithArg valueWithPossibleArgs: #()) isNil.  self assert: (blockWithArg valueWithPossibleArgs: #(1)) equals: 1.  self assert: (blockWithArg valueWithPossibleArgs: #(1 2)) equals: 1.  self assert: (blockWith2Arg valueWithPossibleArgs: #()) equals: {nil .         nil}.  self assert: (blockWith2Arg valueWithPossibleArgs: #(1)) equals: {1 .         nil}.  self assert: (blockWith2Arg valueWithPossibleArgs: #(1 2)) equals: #(1 2).  self assert: (blockWith2Arg valueWithPossibleArgs: #(1 2 3)) equals: #(1 2)basicPharoToIso  | tmp1 |  self asInteger < 128 ifTrue: [ ^self ].  self asInteger > 255 ifTrue: [ ^self ].  tmp1 := #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 253 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 254 255 256) at: self asciiValue - 127.  ^Character value: tmp1simpleReturnTest  | it |  it := [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:ex |  ex return: 3 ].  it = 3 ifTrue: [ self doYetAnotherThing ]simpleEnsureTestWithError  [ self doSomething.  MyTestError signal.  self doSomethingElse ] ensure: [ self doYetAnotherThing ]invalidate  | reflectiveMethod |  self reflectivityDisabled ifTrue: [ ^self ].  reflectiveMethod := self reflectiveMethod.  reflectiveMethod ifNil: [ ^self ].  (self isRealPrimitive or: (reflectiveMethod ast metaLinkOptionsFromClassAndMethod includes: #optionCompileOnLinkInstallation)) ifTrue: [ reflectiveMethod compileAndInstallCompiledMethod ] ifFalse: [ reflectiveMethod installReflectiveMethod ]waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil  ^self waitWhile: [ aBlock value not ] for: aSymbolOrNil maxMilliseconds: anIntegerOrNiltestNew  self should: [ Number new ] raise: self defaultTestErrorprintStringLength: minimal  ^self printStringLength: minimal padded: falsetestStoreOn  self assert: (String streamContents: [:str |  aTime storeOn: str ]) equals: '''12:34:56 pm'' asTime'integerPart  ^self - self fractionPartsetSignFlag  self signFlag ifFalse: [ self objectAt: 1 put: self header + SmallInteger minVal ]completeStep: aContext  | callee |  self suspendedContext == aContext ifFalse: [ ^self complete: (self calleeOf: aContext) ].  callee := self step.  callee == aContext ifTrue: [ ^callee ].  aContext isDead ifTrue: [ ^self suspendedContext ].  ^self complete: calleetestSimpleReturn  self assertSuccess: (ExceptionTester new runTest: #simpleReturnTest)allTraits  ^#()lookupClass  ^lookupClassmin: aMin max: aMax  ^(self min: aMin) max: aMaxtestReadFromDefaultOffsetSpecified  self assert: (DateAndTime readFrom: '2016-07-03T21:16:16.708241+02:00' readStream defaultOffset: Duration zero) offset equals: (Duration hours: 2)testTallyMethods  self assert: (Context tallyMethods: aBlockContext) size equals: 7asAlien  ^0allSelectorsWithout: behaviors  | selectors |  selectors := IdentitySet new.  self withAllSuperclassesDo: [:class |  (behaviors includes: class) ifFalse: [ selectors addAll: class selectors ] ].  ^selectorscompiledMethod1  ^self class >> #method1unschedule: aDelay  accessProtect critical: [ super unschedule: aDelay ]classLayout: aClassLayout  layout := aClassLayouttestCanPerform  | c1 c2 |  c1 := Object subclass: 'MySuperclass' instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: self class category.  c1 compile: 'method1 ^self subclassResponsibility'.  c1 compile: 'method2 ^123'.  self deny: (c1 canPerform: #method1).  self assert: (c1 canPerform: #method2).  self deny: (c1 canPerform: #method3).  c2 := c1 subclass: 'MySubclass' instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self class category.  c2 compile: 'method1 ^ 3'.  c2 compile: 'method3 ^5'.  self assert: (c2 canPerform: #method1).  self assert: (c2 canPerform: #method3).  c2 removeFromSystem.  c1 removeFromSystemtestRefersToLiteralsReturnsTrueWhenLiteralIsInPragmaArguments  self assert: (self compiledMethod1 hasLiteralThorough: 'bar').  self assert: (self compiledMethod1 hasLiteralThorough: 123)isNotNil  ^truepragmas  ^self subclassResponsibilityarea  | w |  (w := self width) <= 0 ifTrue: [ ^0 ].  ^w * self height max: 0testNonCharacterPositive  | nonCps |  nonCps := (16rFDD0 to: 16rFDEF) asSet.  nonCps addAll: (16r0FFFE to: 16r10FFFE by: 16r10000).  nonCps addAll: (16r0FFFF to: 16r10FFFF by: 16r10000).  self assert: nonCps size equals: 66.  nonCps do: [:each |  self assert: (Unicode isNonCharacter: (Character codePoint: each)) ]whichSelectorsAssign: instVarName  self deprecated: 'Please use #whichSelectorsStoreInto: instead' transformWith: '`@receiver whichSelectorsAssign: `@statements' -> '`@receiver whichSelectorsStoreInto: `@statements'.  ^self whichSelectorsStoreInto: instVarNameremoveCategory: protocolName  (self protocolOrganizer hasProtocolNamed: protocolName) ifFalse: [ ^self ].  self removeProtocol: (self protocolNamed: protocolName)selectSubclasses: aBlock  | aSet |  aSet := Set new.  self allSubclasses do: [:aSubclass |  (aBlock value: aSubclass) ifTrue: [ aSet add: aSubclass ] ].  ^aSet= rhs  ^self value = rhs valueallSelectorsToTestInMethodFinder  ^(self approvedSelectorsForMethodFinder union: self superclass allSelectorsToTestInMethodFinder) difference: self forbiddenSelectorsForMethodFinder asSetisReadOnlyObject  < primitive: 163 error: ec>  ^self class isImmediateClassnegated  ^Fraction numerator: numerator negated denominator: denominatorsign  self > 0 ifTrue: [ ^1 ].  self < 0 ifTrue: [ ^-1 ].  ^0default  ^niltestPrintStringHex  self assert: 0 printStringHex equals: '0'.  self assert: 12 printStringHex equals: 'C'.  self assert: 1234 printStringHex equals: '4D2'setPackage: aString withInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setPackage: aString withBlock: selfisPrimitive  ^self primitive > 0testDay  self assert: aDateAndTime day equals: DateAndTime new daytestBitClear  self assert: (2r1111 bitClear: 2r1000) equals: 2r0111.  self assert: (2r1111 bitClear: 2r0100) equals: 2r1011.  self assert: (2r1111 bitClear: 2r0010) equals: 2r1101.  self assert: (2r1111 bitClear: 2r0001) equals: 2r1110testFindContextSuchThat  self assert: (aMethodContext findContextSuchThat: [:each |  true ]) printString equals: aMethodContext printString.  self assert: (aMethodContext hasContext: aMethodContext)testDaysInYear  self assert: (Date daysInYear: 2000) equals: 366.  self assert: (Date daysInYear: 2008) equals: 366.  self assert: (Date daysInYear: 2100) equals: 365testAsUTC  self assert: aDateAndTime asUTC equals: aDateAndTimehighBit  ^self shouldNotImplementtestRefersToLiteralsReturnsTrueWhenLiteralIsInMethodPropertiesValue  [ self compiledMethod1 propertyAt: #Once put: '123'.  self assert: (self compiledMethod1 hasLiteralThorough: '123') ] ensure: [ self compiledMethod1 removeProperty: #Once ]intersectWithCCAllWithCC: sets  ^sets ifNotEmpty: [ Continuation currentDo: [:cc |  self intersectWithCC: sets first withAll: sets allButFirst continuation: cc ] ]testHour12  self assert: aDateAndTime hour12 equals: DateAndTime new hour12.  self assert: aDateAndTime hour12 equals: 12unpinInMemory  ^self setPinnedInMemory: falsebanChecksForValidation  ^{self .   self methodClass}testSecond  self assert: aDateAndTime second equals: 0testIntersectionWithOverlapping  self assert: (aTimespan intersection: anOverlappingTimespan) equals: (Timespan starting: jan01 duration: (Duration days: 6))isNumber  ^trueclassToBeTested  ^StopwatchcompiledMethodAt: selector ifAbsent: aBlock  ^self methodDict at: selector ifAbsent: aBlockhash  ^self bytesCount <= 8 ifTrue: [ self ] ifFalse: [ ByteArray hashBytes: self startingWith: self species hash ]offset  self subclassResponsibilitytestIsLeapYear  self assert: aDateAndTime isLeapYeartestAsDate  self assert: january23rd2004 asDate equals: january23rd2004setPinnedInMemory: aBoolean  < primitive: 184 error: ec>  ^self primitiveFailedinstall: aContext  self == Processor activeProcess ifTrue: [ ^self error: 'The active process cannot install contexts' ].  suspendedContext := aContextsizePushTemp: tempIndex  ^self sizeOpcodeSelector: #genPushTemp: withArguments: {tempIndex}do: aBlock  | aLink |  aLink := firstLink.  [ aLink == nil ] whileFalse: [ aBlock value: aLink value.        aLink := aLink nextLink ]restartWithNewReceiver: obj  self     swapReceiver: obj;     restarttestDisplayStringLimitedString  | actual |  actual := Object new displayStringLimitedTo: 4.  self assert: actual equals: 'an O...etc...'arcSin  (self < -1.0 or: [ self > 1.0 ]) ifTrue: [ ^DomainError signal: 'Value out of range' from: -1 to: 1 ].  (self = -1.0 or: [ self = 1.0 ]) ifTrue: [ ^Halfpi * self ] ifFalse: [ ^(self / (1.0 - (self * self)) sqrt) arcTan ]isCompletionCharacter  ^self isAlphaNumeric or: [ self = $: ]classBinding: aBinding  ^self literalAt: self numLiterals put: aBindingtestDays  self assert: aDuration days equals: 1.  self assert: (Duration days: 1) days equals: 1descending  ^self asSortFunction reversedcopyWithSource: aString  ^self copyWithTrailerBytes: (CompiledMethodTrailer new sourceCode: aString)on: exception fork: handlerAction  ^self on: exception do: [:ex |  | copy onDoCtx process handler bottom thisCtx |        onDoCtx := thisContext.        thisCtx := onDoCtx home.        [ onDoCtx sender == thisCtx ] whileFalse: [ onDoCtx := onDoCtx sender.              onDoCtx ifNil: [ ^handlerAction cull: ex ] ].        bottom := [ Processor terminateActive ] asContext.        onDoCtx privSender: bottom.        handler := [ handlerAction cull: ex ] asContext.        handler privSender: thisContext sender.        (Process forContext: handler priority: Processor activePriority) resume.        thisContext privSender: thisCtx.        nil ]message  ^messagegenPushNewArray: size  (size < 0 or: [ size > 127 ]) ifTrue: [ ^self outOfRangeError: 'size' index: size range: 0 to: 127 ].  stream     nextPut: 231;     nextPut: sizegtInspectorInstancesOn: composite  < gtInspectorPresentationOrder: 40>  ^composite table     title: [ 'Instances' translated ];     display: [ self allInstances ];     column: 'Hash' evaluated: [:each |  each hash asString ];     column: 'Object' evaluated: [:each |  each printString ]asWeek  ^start asWeekusingMethods  self isAnonymous ifTrue: [ ^#() ].  ^self binding usingMethodsgreaseString  | converter |  converter := GRSignPrinter new , (GRNumberPrinter new precision: self scale).  ^converter print: selfselfMessages  ^self ast selfMessagesserializeOn: anEncoder  start serializeOn: anEncoder- aNumber  aNumber isInteger ifTrue: [ ^Fraction numerator: numerator - (denominator * aNumber) denominator: denominator ].  aNumber isFraction ifTrue: [ ^self + aNumber negated ].  ^aNumber adaptToFraction: self andSend: #-withSideOrCorner: side setToPoint: newPoint minExtent: minExtent  ^self withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: ((#(left top) includes: side) ifTrue: [ SmallInteger minVal ] ifFalse: [ SmallInteger maxVal ])isBlockReturn: aPC  ^method encoderClass isBlockReturnAt: aPC in: methodgenUnsignedMultipleExtendA: extendedIndex  extendedIndex > 255 ifTrue: [ self genUnsignedMultipleExtendA: extendedIndex // 256 ].  stream     nextPut: 224;     nextPut: extendedIndex \\ 256intersect: aLinkedList withCollection: aCollection continuation: hop  ^aCollection ifEmpty: [ hop value: aCollection ] ifNotEmpty: [ self intersect: aLinkedList withCollection: aCollection ]newInstanceFrom: oldInstance variable: variable size: instSize  | new value |  variable ifTrue: [ new := self basicNew: oldInstance basicSize ] ifFalse: [ new := self basicNew ].  self allSlots do: [:newSlot |  oldInstance class slotNamed: newSlot name ifFound: [:oldSlot |  newSlot wantsInitialization ifTrue: [ self initializeSlots: new ].              value := oldSlot read: oldInstance.              newSlot write: value to: new ] ].  variable ifTrue: [ 1 to: oldInstance basicSize do: [:offset |  new basicAt: offset put: (oldInstance basicAt: offset) ] ].  ^newtestThreeWayCompareTo  self assert: ($b threeWayCompareTo: $a) equals: 1.  self assert: ($a threeWayCompareTo: $b) equals: -1.  self assert: ($b threeWayCompareTo: $b) equals: 0arguments: anArray  arguments := anArraycleanUpCategoriesForClass: aClass  self allMethodSelectors do: [:each |  (aClass includesSelector: each) ifFalse: [ self removeElement: each ] ]leftRotated  ^y @ x negatedreduced  | gcd numer denom |  numerator = 0 ifTrue: [ ^0 ].  gcd := numerator gcd: denominator.  numer := numerator // gcd.  denom := denominator // gcd.  denom = 1 ifTrue: [ ^numer ].  ^Fraction numerator: numer denominator: denomtestAsMinutes  self assert: (Duration seconds: 60) asMinutes equals: 1.  self assert: (Duration hours: 1) asMinutes equals: 60.  self assert: (aDuration asMinutes closeTo: 1563.0666).  self assert: ((Duration milliSeconds: 100) asMinutes closeTo: 1 / 600)asOrderedCollection  ^OrderedCollection with: selfname  ^namedecompileIR  ^IRBytecodeDecompiler new decompile: selftestPrint24OnWithPM  self assert: (String streamContents: [:str |  aTime print24: false on: str ]) equals: '12:34:56 pm'seconds  ^self secondisTrait  ^falsetestLookupSymbol  | localVar |  localVar := 2.  instVarForTestLookupSymbol := 3.  classVarForTestLookupSymbol := 4.  self assert: (thisContext lookupSymbol: #localVar) equals: 2.  self assert: (thisContext lookupSymbol: #instVarForTestLookupSymbol) equals: 3.  self assert: (thisContext lookupSymbol: #classVarForTestLookupSymbol) equals: 4.  self assert: (thisContext lookupSymbol: #Smalltalk) equals: Smalltalkstackp: newStackp  < primitive: 76>  self error: 'stackp store failure'testInstructions  Object methods do: [:method |  | scanner printer end |        scanner := InstructionStream on: method.        printer := InstVarRefLocator new.        end := scanner method endPC.        [ scanner pc <= end ] whileTrue: [ printer interpretNextInstructionUsing: scanner ] ]testBasicCheck  | testMethod |  testMethod := testSubclass >> (testSubclass compile: self methodName).  self assert: (OverridesDeprecatedMethodRule new check: testMethod) isNotEmptyallInstVarNames  ^self superclass ifNil: [ self instVarNames ] ifNotNil: [:sup |  sup allInstVarNames , self instVarNames ]testOffset  | dt newWeek |  dt := DateAndTime fromString: '2018/01/01T00:00:00+10'.  newWeek := Week starting: dt duration: 0.  self assert: newWeek asDateAndTime offset equals: dt offsetasRingMinimalCommentDefinitionIn: anRGEnvironment  ^anRGEnvironment backend definitionFor: ('classComment:' , self name) asSymbol ifAbsentRegister: [ RGComment parent: (self asRingMinimalDefinitionIn: anRGEnvironment) ]testDaysInYear  self assert: aDateAndTime daysInYear equals: 366copyForAnnouncement  | newClass |  newClass := self class copy new     basicSuperclass: superclass;     methodDict: self methodDict copy;     setFormat: format;     setName: name;     organization: self organization copy;     classPool: classPool copy;     sharedPools: sharedPools copy.  self class instSize + 1 to: self class instSize do: [:offset |  newClass instVarAt: offset put: (self instVarAt: offset) ].  newClass classLayout: (layout copy host: newClass).  ^newClass* arg  arg isPoint ifTrue: [ ^(x * arg x) @ (y * arg y) ].  ^arg adaptToPoint: self andSend: #*definition  ^self sourceCodepositive  ^falsesquishedWithin: aRectangle  ^origin corner: (corner min: aRectangle bottomRight)isMeta  < metaLinkOptions: #(+ optionDisabledLink)>  level ifNil: [ level := 0 ].  ^level ~= 0nowTick  < primitive: 135>  ^0queueFor: aSymbol  aSymbol ifNil: [ ^self defaultQueue ].  ^self queueDict at: aSymbol ifAbsentPut: [ OrderedCollection new ]sqrtFloor  | guess guessSquared delta |  guess := 1 bitShift: (self highBit + 1) // 2.  [ guessSquared := guess * guess.  delta := (guessSquared - self) // (guess bitShift: 1).  delta = 0 ] whileFalse: [ guess := guess - delta ].  guessSquared = self ifFalse: [ guess := guess - 1 ].  ^guesshasPragmaNamed: aSymbol  ^falsepenultimateLiteral  ^self subclassResponsibilitymonth  ^self asMonthtestMethodClass  | method cls |  method := self class >> #returnTrue.  self assert: method selector equals: #returnTrue.  Smalltalk removeClassNamed: #TUTU.  cls := Object subclass: #TUTU instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self categoryNameForTemporaryClasses.  cls compile: 'foo ^ 10'.  method := cls >> #foo.  Smalltalk removeClassNamed: #TUTU.  self assert: method methodClass equals: clsraisedToFraction: aFraction  self isZero ifTrue: [ aFraction negative ifTrue: [ ^(ZeroDivide dividend: 1) signal ].        ^self ].  self negative ifFalse: [ ^(self ln * aFraction) exp ].  aFraction denominator even ifTrue: [ ^ArithmeticError signal: 'nth root only defined for positive Integer n.' ].  ^(self negated ln * aFraction) exp negatedrenderOn: html  center  ^(self topLeft + self bottomRight) // 2degreesToRadians  ^self * RadiansPerDegreetruncated  ^numerator quo: denominatorcrTrace  self crTrace: selfaddTime: timeAmount  ^self class seconds: self asSeconds + timeAmount asSecondsprevious  ^self class year: self year - 1gtDebuggerSUnitPrint  ^String streamContents: [:s |  self printSeparateDateAndTimeOn: s ]spotterSelectFor: aStep  localSendsAnySelectorOf: aCollection  self literalsDo: [:lit |  (lit isSymbol and: [ aCollection includes: lit ]) ifTrue: [ ^self messages includesAny: aCollection ] ].  ^falsetestStoreOnRoundTrip  self assert: (self class compiler evaluate: Float halfPi storeString) equals: Float halfPi.  self assert: (self class compiler evaluate: Float halfPi negated storeString) equals: Float halfPi negated.  self assert: (self class compiler evaluate: Float infinity storeString) equals: Float infinity.  self assert: (self class compiler evaluate: Float infinity negated storeString) equals: Float infinity negated.  self assert: (self class compiler evaluate: Float nan storeString) isNaNtestReadFromManyDigits  | s1 s2 |  s1 := '1' , (String new: 321 withAll: $0) , '.0e-321'.  s2 := '0.' , (String new: 320 withAll: $0) , '1e321'.  self assert: (Number readFrom: s1) equals: 1.  self assert: (Number readFrom: s2) equals: 1asOrderedCollection  ^OrderedCollection with: selfasGlamorousMultiValue  ^GLMMultiValue with: selfmetaLinkOptions  ^{(#isNil -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}notifyRepackage: selector method: compiledMethod oldProtocol: oldProtocol newProtocol: newProtocol  | oldPackage newPackage |  newProtocol = oldProtocol ifTrue: [ ^self ].  self class environment at: #RPackage ifPresent: [:rPackageClass |  newPackage := rPackageClass organizer packageForProtocol: newProtocol inClass: self.        oldPackage := rPackageClass organizer packageForProtocol: oldProtocol inClass: self.        newPackage = oldPackage ifFalse: [ SystemAnnouncer uniqueInstance methodRepackaged: compiledMethod from: oldPackage to: newPackage ] ].  SystemAnnouncer uniqueInstance methodRecategorized: compiledMethod oldProtocol: oldProtocolevery: aDuration do: aBlock  | element end |  element := self start.  end := self end.  [ element <= end ] whileTrue: [ aBlock value: element.        element := element + aDuration ]ephemeronSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat  ^self ephemeronSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cattestOnForkErrorOnSeparateProcess  | result forkedProc sema |  sema := Semaphore new.  result := [ 1 / 0 ] on: Exception fork: [ forkedProc := Processor activeProcess.        sema signal ].  sema wait.  self assert: forkedProc ~~ Processor activeProcesstestDefaultParsingSucceeds  | date |  date := Date year: 2013 month: 11 day: 29.  self assertReading: '29.11.2013' as: 'dd.mm.yyyy' equals: date.  self assertReading: '29.11.2013' as: 'd.m.y' equals: date.  self assertReading: '29.11.13' as: 'd.m.y' equals: datetestArithmeticAcrossDateBoundary  | t1 t2 |  t1 := '2004-01-07T11:55:00+00:00' asDateAndTime.  t2 := t1 - (42900 + 1) seconds.  self assert: t2 equals: '2004-01-06T23:59:59+00:00' asDateAndTimetestIndexOfMonth  self assert: (Date indexOfMonth: #January) equals: 1.  self assert: (Date indexOfMonth: #December) equals: 12.  self should: [ Date indexOfMonth: #NonExistantMonth ] raise: Errorschedule: anArrayOfDurations  schedule := anArrayOfDurationsto: stop do: aBlock  | nextValue |  nextValue := self.  [ nextValue <= stop ] whileTrue: [ aBlock value: nextValue.        nextValue := nextValue + 1 ]sizePushFullClosure: compiledBlockLiteralIndex numCopied: numCopied receiverOnStack: rcvrOnStack ignoreOuterContext: ignoreOuterContext  ^self sizeOpcodeSelector: #genPushFullClosure:numCopied:receiverOnStack:ignoreOuterContext: withArguments: {compiledBlockLiteralIndex .         numCopied .         rcvrOnStack .         ignoreOuterContext}asColorOfDepth: d  ^Color colorFromPixelValue: self depth: dtestallMethodsAccessingSlot  | methods |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  methods := LookupKey allMethodsAccessingSlot: (LookupKey slotNamed: #key).  self assert: (methods includes: Association >> #key:value:)subclassInstVarNames  ^self allSubclasses flatCollectAsSet: [:aSubclass |  aSubclass instVarNames ]isKindOf: aClass  ^self class == aClass or: [ self class inheritsFrom: aClass ]timeProfile  ^Smalltalk tools timeProfiler onBlock: selfremoveFromSystem  ^self methodClass removeSelector: self selectortestIsSpaceSeparator  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isSpaceSeparator: ch) equals: (charset isSpaceSeparator: ch) ]testSizeInMemorySmallIntegers  self assert: SmallInteger minVal sizeInMemory isZero.  self assert: 0 sizeInMemory isZero.  self assert: SmallInteger maxVal sizeInMemory isZero.  self assert: (SmallInteger minVal - 1) sizeInMemory > 0.  self assert: (SmallInteger maxVal + 1) sizeInMemory > 0asString  ^self printStringsetUp  super setUp.  class := Object subclass: #ClassForTests instanceVariableNames: '' classVariableNames: '' category: 'ClassOrganizer-Tests'.  organization := ClassOrganization forClass: class.  organization addCategory: 'empty'.  organization addCategory: 'one'.  organization classify: #one under: 'one' suppressIfDefault: truereciprocalLogBase2  ^self = 10.0 ifTrue: [ Ln2 / Ln10 ] ifFalse: [ Ln2 / self ln ]removeAllSuchThat: aBlock  self do: [:each |  (aBlock value: each) ifTrue: [ self remove: each ] ]runUntilErrorOrReturnFrom: aSender  | error context here topContext |  here := thisContext.  error := nil.  context := aSender insertSender: (Context contextOn: Error , Halt do: [:ex |  error ifNil: [ error := ex.                    topContext := thisContext.                    ex resumeUnchecked: here jump ] ifNotNil: [ ex pass ] ]).  context := context insertSender: (Context contextEnsure: [ error ifNil: [ topContext := thisContext.                    here jump ] ]).  self jump.  ^error ifNil: [ [ context isDead or: [ topContext isNil ] ] whileFalse: [ topContext := topContext stepToCallee ].        {topContext .         nil} ] ifNotNil: [ aSender terminateTo: context sender.        {topContext .         error} ]pragmas  ^#()waitWhile: aBlock inQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil  [ aBlock value ] whileTrue: [ self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil ]testIfTrue  self assert: (false ifTrue: [ 'alternativeBlock' ]) isNiltestOneArgument  | c |  c := OrderedCollection new.  c add: 'hello'.  [ c do: [ 1 + 2 ] ] ifError: [:err |  self deny: err equals: 'This block requires 0 arguments.' ].  [ c do: [:arg1 :arg2 |  1 + 2 ] ] ifError: [:err |  self deny: err equals: 'This block requires 2 arguments.' ]isObsolete  ^self soleInstance == nil or: [ self soleInstance classSide ~~ self or: [ self soleInstance isObsolete ] ]shutDown: quitting  ^self shutDowncull: arg  ^selector numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: arg ]testDegreeCos  (4 / 3) degreeCos.  -361 / 3 to: 359 / 3 do: [:i |  self assert: (i degreeCos closeTo: i degreesToRadians cos) ]asHelpTopic  ^SystemReference forClass: selfisTestMethod  ^falsesizeStoreLiteralVar: literalIndex  ^self sizeOpcodeSelector: #genStoreLiteralVar: withArguments: {literalIndex}variableWordSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self variableWordSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: catinitializeSlots: anObject  self classLayout initializeInstance: anObjectquo: aNumber  ^(self / aNumber) truncatedshallowCopy  tearDown  testClass := nil.  super tearDownbearingToPoint: anotherPoint  | deltaX deltaY |  deltaX := anotherPoint x - x.  deltaY := anotherPoint y - y.  deltaX abs < 0.001 ifTrue: [ ^deltaY > 0 ifTrue: [ 180 ] ifFalse: [ 0 ] ].  ^((deltaX >= 0 ifTrue: [ 90 ] ifFalse: [ 270 ]) - (deltaY / deltaX) arcTan negated radiansToDegrees) roundedallProtocolsUpTo: mostGenericClass  | otherClassCategories thisClassCategories lowercaseSortBlock |  otherClassCategories := OrderedCollection new.  lowercaseSortBlock := [:a :b |  a asLowercase <= b asLowercase ].  (self allSuperclassesIncluding: mostGenericClass) do: [:aClass |  otherClassCategories addAll: aClass organization categories ].  otherClassCategories remove: 'no messages' ifAbsent: [  ].  thisClassCategories := self organization categories sorted: lowercaseSortBlock.  ^thisClassCategories , ((otherClassCategories asSet removeAllSuchThat: [:each |  thisClassCategories includes: each ]) sorted: lowercaseSortBlock)embeddedSourceCode  ^dataclassAnnotationsDo: aBlock  ^(ClassAnnotation findAllAnnotationsFor: self) do: aBlockbasicANSISignaledExceptionTestSelectors  ^#(simpleIsNestedTest simpleOuterTest doubleOuterTest doubleOuterPassTest doublePassOuterTest simplePassTest simpleResignalAsTest simpleResumeTest simpleRetryTest simpleRetryUsingTest simpleReturnTest)* aNumber  < primitive: 549>  ^aNumber adaptToFloat: self andSend: #*testConvertFromIntegerWithScale  | sd |  sd := 13 asScaledDecimal: 6.  self assert: 6 equals: sd scale.  self assert: '13.000000s6' equals: sd printString.  sd := -13 asScaledDecimal: 4.  self assert: 4 equals: sd scale.  self assert: '-13.0000s4' equals: sd printString.  sd := 130000000013 asScaledDecimal: 3.  self assert: 3 equals: sd scale.  self assert: '130000000013.000s3' equals: sd printString.  sd := -130000000013 asScaledDecimal: 1.  self assert: 1 equals: sd scale.  self assert: '-130000000013.0s1' equals: sd printStringdecodeVarLengthSourcePointer  | pos shift |  pos := method size - 1.  shift := data := 0.  [ | value |  value := method at: pos.  data := ((value bitAnd: 16r7F) << shift) + data.  pos := pos - 1.  shift := shift + 7.  value > 127 ] whileTrue.  size := method size - posisExtension  ^self origin package ~= self packagetestDayOfWeek  self assert: aDateAndTime dayOfWeek equals: 1.  self assert: aDateAndTime dayOfWeekAbbreviation equals: 'Sun'.  self assert: aDateAndTime dayOfWeekName equals: 'Sunday'tearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  super tearDowncollectArguments: anArgArray  | staticArgs |  staticArgs := self arguments.  ^anArgArray size = staticArgs size ifTrue: [ anArgArray ] ifFalse: [ (staticArgs isEmpty ifTrue: [ staticArgs := Array new: selector numArgs ] ifFalse: [ staticArgs copy ]) replaceFrom: 1 to: (anArgArray size min: staticArgs size) with: anArgArray startingAt: 1 ]isAnnouncingObject  ^falsedragPassengerFor: item inMorph: dragSource  ^itemhash  ^self subclassResponsibilitysimulateValueWithArguments: anArray caller: aContext  | newContext |  newContext := (Context newForMethod: self compiledBlock) setSender: aContext receiver: receiver method: self compiledBlock closure: self startpc: self compiledBlock initialPC.  ((newContext objectClass: anArray) ~~ Array or: [ numArgs ~= anArray size ]) ifTrue: [ ^Context primitiveFailTokenFor: nil ].  newContext stackp: self compiledBlock numTemps.  1 to: numArgs do: [:i |  newContext at: i put: (anArray at: i) ].  1 to: self basicSize do: [:i |  newContext at: i + numArgs put: (self at: i) ].  ^newContexttestIntegerDivision  self assert: aDuration // aDuration equals: 1.  self assert: aDuration // 2 equals: aDuration / 2testUnionWithIncluded  self assert: (aTimespan union: anIncludedTimespan) equals: aTimespantestOffset  | dt newMonth |  dt := DateAndTime fromString: '2018/01/01T00:00:00+10'.  newMonth := Month starting: dt duration: 0.  self assert: newMonth asDateAndTime offset equals: dt offsetgenPushRemoteTemp: tempIndex inVectorAt: tempVectorIndex  (tempIndex < 0 or: [ tempIndex >= 256 ]) ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255 ].  (tempVectorIndex < 0 or: [ tempVectorIndex >= 128 ]) ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127 ].  stream     nextPut: 251;     nextPut: tempIndex;     nextPut: tempVectorIndexto: stop by: step do: aBlock  | nextValue |  nextValue := self.  step = 0 ifTrue: [ self error: 'step must be non-zero' ].  step < 0 ifTrue: [ [ stop <= nextValue ] whileTrue: [ aBlock value: nextValue.              nextValue := nextValue + step ] ] ifFalse: [ [ stop >= nextValue ] whileTrue: [ aBlock value: nextValue.              nextValue := nextValue + step ] ]halt: aString  < debuggerCompleteToSender>  Halt now: aStringifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock  ^falseAlternativeBlock valuehasSelector: selector  ^self hasSelector: selector specialSelectorIndex: (Smalltalk specialSelectorIndexOrNil: selector)isLetterNumber  ^self characterSet isLetterNumber: selfvalue: anObject  | strongReceiver |  strongReceiver := self receiver.  (self ensureReceiver: strongReceiver) ifFalse: [ ^nil ].  ^strongReceiver perform: selector with: anObjecttruncated  example1  < sampleInstance>  | ff |  1 < 2 ifTrue: [ tt ifNotNil: [ ff := 'hallo' ] ].  ^ff< aPoint  ^x < aPoint x and: [ y < aPoint y ]intersect: aSet withAll: sets  ^sets ifEmpty: [ aSet ] ifNotEmpty: [ self intersect: aSet withCollection: (self intersect: sets first withAll: sets allButFirst) ]exception  ^self tempAt: 1isLocalAliasSelector: aSymbol  ^falserestart  | context unwindBlock |  self isDead ifTrue: [ self cannotReturn: nil to: self ].  self privRefresh.  context := thisContext.  [ context := context findNextUnwindContextUpTo: self.  context isNil ] whileFalse: [ context unwindComplete ifNil: [ context unwindComplete: true.              unwindBlock := context unwindBlock.              thisContext terminateTo: context.              unwindBlock value ] ].  thisContext terminateTo: self.  self jumpisMathSymbol  ^self characterSet isMathSymbol: selfstandardMessageText  ^String streamContents: [:stream |  stream nextPutAll: self instVarName.        stream nextPutAll: ' not found in '.        stream print: self signaler ]asScaledDecimal: scale  ^ScaledDecimal newFromNumber: self scale: scaletestYearsDo  | yearArray |  yearArray := Array with: (Year year: 2004) with: (Year year: 2005).  self assert: aTimespan years equals: yearArraytestIsControlOther  self checkCorrespondanceOf: #isControlOther: and: #CcbottomLeft  ^origin x @ corner yprintStringOfTree: aValueLink onStream: aStream  aStream nextPut: $(.  (aValueLink isMemberOf: Link) ifFalse: [ | cell |        cell := aValueLink.        [ | car |        car := cell value.        (car isKindOf: Link) ifTrue: [ self printStringOfTree: car onStream: aStream ] ifFalse: [ car printOn: aStream ].        cell nextLink ifNotNil: [ aStream nextPut: Character space ].        cell := cell nextLink.        cell isMemberOf: ValueLink ] whileTrue.        cell ifNotNil: [ aStream                 nextPut: $.;                 nextPut: Character space.              cell printOn: aStream ] ].  aStream nextPut: $)remove: anObj oneStar: aTree sentinel: aSymbol continuation: oh  ^aTree ifNil: [ oh value: aSymbol ] ifNotNil: [ | car cdr naturalRecursion |        car := aTree value.        cdr := aTree nextLink.        naturalRecursion := [ | newCdr |        newCdr := self remove: anObj oneStar: cdr sentinel: aSymbol continuation: oh.        car ~~> newCdr ].        (car isMemberOf: ValueLink) ifTrue: [ | newCar |              newCar := Continuation currentDo: [:ooh |  self remove: anObj oneStar: car sentinel: aSymbol continuation: ooh ].              newCar = aSymbol ifTrue: naturalRecursion ifFalse: [ newCar ~~> cdr ] ] ifFalse: [ anObj = car ifTrue: [ cdr ] ifFalse: naturalRecursion ] ]propertyKeysAndValuesDo: aBlock  | propertiesOrSelector |  (propertiesOrSelector := self penultimateLiteral) isMethodProperties ifTrue: [ propertiesOrSelector propertyKeysAndValuesDo: aBlock ]stonShouldWriteNilInstVars  ^falsealign64Bits: size  size % 8 = 0 ifTrue: [ ^size ] ifFalse: [ ^size + 8 - (size % 8) ]unusedBytecode  ^self respondsToUnknownBytecodeprintAsConstantQueryItem  ^self printStringhasBindingOf: aString  ^falseisImmediateClass  ^self instSpec = 7testMethodsReferencingClass  self assert: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest111)) equals: {(ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.  self assert: ((ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest1)) sort: [:a :b |  a name <= b name ]) asArray equals: {(ClassTest >> #referencingMethod1) .         (ClassTest >> #referencingMethod2) .         (ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.  self assertEmpty: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #BehaviorTest))name  ^self printStringscanSchedule: aBlock startingAt: topPriority  topPriority to: 1 by: -1 do: [:priority |  | list |        list := quiescentProcessLists at: priority.        list do: [:proc |  aBlock value: proc ] ]size  | tally |  tally := 0.  self do: [:each |  tally := tally + 1 ].  ^tally~~> aValueLinkOrNil  ^ValueLink basicNew     value: self;     nextLink: aValueLinkOrNil;     yourselfmetacelloStringLessThanSelf: aString  ^truehashMultiply  ^(self bitAnd: 16rFFFFFFF) hashMultiplyresumeProcess: aProcess  | process |  process := self remove: aProcess ifAbsent: [ nil ].  process ifNotNil: [ process resume ]testTwoArguments  | m |  m := WeakMessageSend receiver: Array selector: #with:with: arguments: {1 .         2}.  Smalltalk garbageCollectMost.  self assert: m value equals: {1 .         2}complexRecursionFirstCall  LocalRecursionStopper during: [ self complexRecursionLastCall ]testMinute  self assert: aDateAndTime minute equals: 0consumeAllSignals  excessSignals := 0testIsPrivateOther  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isPrivateOther: ch) equals: (charset isPrivateOther: ch) ]phlowValue: anObject withEnoughArguments: aCollection  ^aCollection firsttestIsSpacingCombiningMark  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isSpacingCombiningMark: ch) equals: (charset isSpacingCombiningMark: ch) ]spotterSuperClassMethodsFor: aStep  < spotterOrder: 16>  | superclasses |  superclasses := self class withAllSuperclasses select: #isMeta.  aStep listProcessor     title: 'Super class methods';     allCandidates: [ self classSide allMethods select: [:each |  (each methodClass = self classSide) not & (superclasses includes: each methodClass) ] ];     filter: GTFilterSubstringtestRomanPrinting  self assert: 0 printStringRoman equals: ''.  self assert: 1 printStringRoman equals: 'I'.  self assert: 2 printStringRoman equals: 'II'.  self assert: 3 printStringRoman equals: 'III'.  self assert: 4 printStringRoman equals: 'IV'.  self assert: 5 printStringRoman equals: 'V'.  self assert: 6 printStringRoman equals: 'VI'.  self assert: 7 printStringRoman equals: 'VII'.  self assert: 8 printStringRoman equals: 'VIII'.  self assert: 9 printStringRoman equals: 'IX'.  self assert: 10 printStringRoman equals: 'X'.  self assert: 23 printStringRoman equals: 'XXIII'.  self assert: 36 printStringRoman equals: 'XXXVI'.  self assert: 49 printStringRoman equals: 'XLIX'.  self assert: 62 printStringRoman equals: 'LXII'.  self assert: 75 printStringRoman equals: 'LXXV'.  self assert: 88 printStringRoman equals: 'LXXXVIII'.  self assert: 99 printStringRoman equals: 'XCIX'.  self assert: 100 printStringRoman equals: 'C'.  self assert: 101 printStringRoman equals: 'CI'.  self assert: 196 printStringRoman equals: 'CXCVI'.  self assert: 197 printStringRoman equals: 'CXCVII'.  self assert: 198 printStringRoman equals: 'CXCVIII'.  self assert: 293 printStringRoman equals: 'CCXCIII'.  self assert: 294 printStringRoman equals: 'CCXCIV'.  self assert: 295 printStringRoman equals: 'CCXCV'.  self assert: 390 printStringRoman equals: 'CCCXC'.  self assert: 391 printStringRoman equals: 'CCCXCI'.  self assert: 392 printStringRoman equals: 'CCCXCII'.  self assert: 487 printStringRoman equals: 'CDLXXXVII'.  self assert: 488 printStringRoman equals: 'CDLXXXVIII'.  self assert: 489 printStringRoman equals: 'CDLXXXIX'.  self assert: 584 printStringRoman equals: 'DLXXXIV'.  self assert: 585 printStringRoman equals: 'DLXXXV'.  self assert: 586 printStringRoman equals: 'DLXXXVI'.  self assert: 681 printStringRoman equals: 'DCLXXXI'.  self assert: 682 printStringRoman equals: 'DCLXXXII'.  self assert: 683 printStringRoman equals: 'DCLXXXIII'.  self assert: 778 printStringRoman equals: 'DCCLXXVIII'.  self assert: 779 printStringRoman equals: 'DCCLXXIX'.  self assert: 780 printStringRoman equals: 'DCCLXXX'.  self assert: 875 printStringRoman equals: 'DCCCLXXV'.  self assert: 876 printStringRoman equals: 'DCCCLXXVI'.  self assert: 877 printStringRoman equals: 'DCCCLXXVII'.  self assert: 972 printStringRoman equals: 'CMLXXII'.  self assert: 973 printStringRoman equals: 'CMLXXIII'.  self assert: 974 printStringRoman equals: 'CMLXXIV'.  self assert: 1069 printStringRoman equals: 'MLXIX'.  self assert: 1070 printStringRoman equals: 'MLXX'.  self assert: 1071 printStringRoman equals: 'MLXXI'.  self assert: 1166 printStringRoman equals: 'MCLXVI'.  self assert: 1167 printStringRoman equals: 'MCLXVII'.  self assert: 1168 printStringRoman equals: 'MCLXVIII'.  self assert: 1263 printStringRoman equals: 'MCCLXIII'.  self assert: 1264 printStringRoman equals: 'MCCLXIV'.  self assert: 1265 printStringRoman equals: 'MCCLXV'.  self assert: 1360 printStringRoman equals: 'MCCCLX'.  self assert: 1361 printStringRoman equals: 'MCCCLXI'.  self assert: 1362 printStringRoman equals: 'MCCCLXII'.  self assert: 1457 printStringRoman equals: 'MCDLVII'.  self assert: 1458 printStringRoman equals: 'MCDLVIII'.  self assert: 1459 printStringRoman equals: 'MCDLIX'.  self assert: 1554 printStringRoman equals: 'MDLIV'.  self assert: 1555 printStringRoman equals: 'MDLV'.  self assert: 1556 printStringRoman equals: 'MDLVI'.  self assert: 1651 printStringRoman equals: 'MDCLI'.  self assert: 1652 printStringRoman equals: 'MDCLII'.  self assert: 1653 printStringRoman equals: 'MDCLIII'.  self assert: 1748 printStringRoman equals: 'MDCCXLVIII'.  self assert: 1749 printStringRoman equals: 'MDCCXLIX'.  self assert: 1750 printStringRoman equals: 'MDCCL'.  self assert: 1845 printStringRoman equals: 'MDCCCXLV'.  self assert: 1846 printStringRoman equals: 'MDCCCXLVI'.  self assert: 1847 printStringRoman equals: 'MDCCCXLVII'.  self assert: 1942 printStringRoman equals: 'MCMXLII'.  self assert: 1943 printStringRoman equals: 'MCMXLIII'.  self assert: 1944 printStringRoman equals: 'MCMXLIV'.  self assert: 2004 printStringRoman equals: 'MMIV'.  self assert: -1 printStringRoman equals: '-I'.  self assert: -2 printStringRoman equals: '-II'.  self assert: -3 printStringRoman equals: '-III'.  self assert: -4 printStringRoman equals: '-IV'.  self assert: -5 printStringRoman equals: '-V'.  self assert: -6 printStringRoman equals: '-VI'.  self assert: -7 printStringRoman equals: '-VII'.  self assert: -8 printStringRoman equals: '-VIII'.  self assert: -9 printStringRoman equals: '-IX'.  self assert: -10 printStringRoman equals: '-X'asPassiveRingDefinition  ^RGMethodDefinition new     name: self selector;     parentName: self methodClass name;     isMetaSide: self methodClass isMeta;     protocol: self category;     sourceCode: self sourceCode;     stamp: self timeStamp;     asPassive< aNumber  aNumber isFraction ifTrue: [ ^numerator * aNumber denominator < (aNumber numerator * denominator) ].  ^aNumber adaptToFraction: self andCompare: #<obsoleteSubclasses  | obs |  obs := self basicObsoleteSubclasses at: self ifAbsent: [ ^#() ].  ^obs copyWithout: niltestDaysInYear  self assert: aDateAndTime daysInYear equals: 366gtInspectorDetailsIn: composite  < gtInspectorPresentationOrder: 30>  ^composite table     title: 'Details';     display: [ {('iso' -> self print24) .         ('hours' -> self hours) .         ('minutes' -> self minutes) .         ('seconds' -> self seconds) .         ('nanoseconds' -> self nanoSecond) .         ('meridian' -> self meridianAbbreviation)} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valuemetacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent  ^self error: 'Invalid Metacello verson component - should be String or Integer.'removeProtocol: aString  | categoryName |  categoryName := aString asSymbol.  (self organization listAtCategoryNamed: categoryName) do: [:sel |  self removeSelector: sel ].  self organization removeCategory: categoryNametestCannotReturn  | context p |  p := [ context := thisContext ] fork.  [ p isTerminated ] whileFalse: [ 10 milliSeconds wait ].  [ context resume: #result.  self assert: false description: 'ContextCannotReturn should be signaled' ] on: ContextCannotReturn do: [:err |  self assert: err result equals: #result.        self assert: err target equals: context ]testPrintShowingDecimalPlaces3  self assert: (1.009 printShowingDecimalPlaces: 3) equals: '1.009'.  self assert: (35.900 printShowingDecimalPlaces: 3) equals: '35.900'.  self assert: (-0.097 printShowingDecimalPlaces: 3) equals: '-0.097'testBlockTemps  | y |  #(1 2 3) do: [:i |  | x |        x := i.        tmp ifNil: [ tmp2 := self callcc: [:cc |  tmp := cc.                    [:q |   ] ] ].        tmp2 value: x.        x := 17 ].  y := self callcc: [:cc |  tmp value: cc.        42 ].  self assert: y equals: 1scheduleDo: aBlock  self between: self start and: self end do: aBlockgtConstructDebuggerInspectorIn: composite for: aDebugger  ^composite custom: (GTDebuggerInspector new           debugger: aDebugger;           startOn: self)standardMessageText  ^String streamContents: [:stream |  self subscript ifNil: [ stream << 'subscript' ] ifNotNil: [ stream print: self subscript ].        (self lowerBound notNil and: [ self upperBound notNil ]) ifTrue: [ stream << ' is not between '.              stream print: self lowerBound.              stream << ' and '.              stream print: self upperBound ] ]alt  ^KMModifier alt + selfbase  ^codes firstopenDependencyAnalyzerOn: package  ^(DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: {package packageName}) opentestTerminatingBlockedCriticalWhichWasSignalledButNotResumedYet  | processWaitingForMutex firstCriticalExecuted lastCriticalExecuted semaphoreToHoldMutex |  firstCriticalExecuted := false.  lastCriticalExecuted := false.  semaphoreToHoldMutex := Semaphore new.  self fork: [ mutex critical: [ semaphoreToHoldMutex wait.              firstCriticalExecuted := true ] ] at: Processor activeProcess priority + 1.  self waitLastProcessLock.  processWaitingForMutex := self fork: [ mutex critical: [ self error: 'should not happen' ] ] at: Processor activeProcess priority - 1.  self waitLastProcessLock.  self deny: firstCriticalExecuted.  semaphoreToHoldMutex signal.  self assert: firstCriticalExecuted.  processWaitingForMutex terminate.  self fork: [ mutex critical: [ lastCriticalExecuted := true ] ].  self waitLastProcessTerminate.  self assert: lastCriticalExecuted description: 'consequent last critical should be executed'numberOfDigits  ^self numberOfDigitsInBase: 10decodeEmbeddedSourceWide  | len start end newSize byteArray |  len := self decodeLengthField.  start := method size - self size + 1.  end := method size - self size + len.  newSize := end - start + 1.  byteArray := (ByteArray new: newSize) replaceFrom: 1 to: newSize with: method startingAt: start.  data := byteArray utf8DecodedasScaledDecimal  #Numeric.  ^self asScaledDecimal: 8testReadFrom  self assert: (Fraction readFromString: '3') = 3 description: 'denominator is optional'.  self assert: (Fraction readFromString: '2/3') = (2 / 3) description: 'fraction and denominator must follow numerator'.  self assert: (Fraction readFromString: '-2/3') = (-2 / 3) description: 'numerator can specify a minus sign'.  self assert: (Fraction readFromString: '2/-5') = (-2 / 5) description: 'denominator can specify a minus sign'.  self assert: (Fraction readFromString: '-3/-7') = (3 / 7) description: 'numerator and denominator can both specify a minus sign'.  self assert: (Fraction readFromString: '2e3/3') = (2000 / 3) description: 'numerator can specify an exponent'.  self assert: (Fraction readFromString: '3/1e4') = (3 / 10000) description: 'denominator can specify an exponent'.  self assert: (Fraction readFromString: '16rA0/3') = (160 / 3) description: 'numerator can specify a radix'.  self assert: (Fraction readFromString: '1/3r22') = (1 / 8) description: 'denominator can specify a radix'testMutateObjectClass  | guineaPig |  guineaPig := WriteBarrierStub new.  guineaPig beReadOnlyObject.  self should: [ guineaPig primitiveChangeClassTo: WriteBarrierAnotherStub new ] raise: ModificationForbidden.  [ guineaPig primitiveChangeClassTo: WriteBarrierAnotherStub new ] on: ModificationForbidden do: [:modification |  modification object beWritableObject.        modification retryModification ].  self assert: guineaPig class equals: WriteBarrierAnotherStubclassVarNamed: aString  ^self readClassVariableNamed: aStringsettingFixedDomainValueNodeFrom: aSettingNode  ^aSettingNode fixedDomainValueNodeForObject: selfmethod  ^methodjavascriptMonthIndex  ^self monthIndex - 1testNNegatedEqualsNComplementedPlusOne  | n |  1 to: 100 do: [:i |  n := 1 bitShift: i.        self assert: n negated equals: (n bitXor: -1) + 1 ]originName: anObject  originName := anObjecttestIsAbstract  self assert: (self class >> #abstractMethod) isAbstract.  self deny: (self class >> #nonAbstractMethod) isAbstract.  self deny: (self class >> #shouldNotImplementMethod) isAbstractpushClosureTemps: numTemps  numTemps timesRepeat: [ self push: nil ]willJustPop  ^self method encoderClass isJustPopAt: pc in: self methodtestReadTimeWithOtherCharactersAfter  self assert: (DateAndTime readFrom: '2016-02-03 19:23:48 +0131 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #547' readStream) printString equals: '2016-02-03T19:23:48+01:31'writesSlot: aSlot  ^aSlot isWrittenIn: selfhighBitOfPositiveReceiver  | shifted bitNo |  shifted := self.  bitNo := 0.  [ shifted < 65536 ] whileFalse: [ shifted := shifted bitShift: -16.        bitNo := bitNo + 16 ].  shifted < 256 ifFalse: [ shifted := shifted bitShift: -8.        bitNo := bitNo + 8 ].  ^bitNo + (#[0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8] at: shifted + 1)allLocalCallsOn: aSymbol  ^self instanceSide withAllSuperAndSubclasses flatCollect: [:class |  (class thoroughWhichMethodsReferTo: aSymbol) , (class class thoroughWhichMethodsReferTo: aSymbol) ]digitAt: anExponent base: base  ^self // (base raisedToInteger: anExponent - 1) \\ baseconstructFibonacciBlockWithBlockArgumentInDeadFrame  ^[:val :blk |  val <= 0 ifTrue: [ self error: 'not a natural number' ].  val <= 2 ifTrue: [ 1 ] ifFalse: [ (blk value: val - 1 value: blk) + (blk value: val - 2 value: blk) ] ]testSubtractTime  self assert: (aTime subtractTime: aTime) equals: (Time readFrom: '00:00:00' readStream)absPrint: float on: stream base: base  ^float absPrintExactlyOn: stream base: basenonResumableFallOffTheEndHandler  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:ex |  self doSomethingExceptional ].  self doYetAnotherThingpointer  ^(ByteArray new: FFIExternalType pointerSize)     unsignedLongAt: 1 put: self;     yourselfspecies  ^Timespan+ aNumber  self subclassResponsibilitytestExactSqrt  | four hundredth tenth two |  four := 4.0s1.  two := four sqrt.  self assert: two equals: 2.  self assert: (two class = four class and: [ two scale = four scale ]).  hundredth := 0.01s2.  tenth := hundredth sqrt.  self assert: tenth * 10 equals: 1.  self assert: (tenth class = hundredth class and: [ tenth scale = hundredth scale ])atRandom  self = 0 ifTrue: [ ^0 ].  self < 0 ifTrue: [ ^self negated atRandom negated ].  ^self atRandom: SharedRandom globalGeneratorfromPoint: aPoint  self setTop: aPoint y left: aPoint x bottom: aPoint y right: aPoint xtestModulo  | d1 d2 d3 |  d1 := 11.5 seconds.  d2 := d1 \\ 3.  self assert: d2 equals: (Duration nanoSeconds: 1).  d3 := d1 \\ 3 seconds.  self assert: d3 equals: (Duration seconds: 2 nanoSeconds: 500000000).  self assert: aDuration \\ aDuration equals: (Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: aDuration \\ 2 equals: (Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 1)classForTicker  ^DelayMillisecondTickerSimulationwritesRef: literalAssociation  (self localWritesRef: literalAssociation) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:cb |  cb writesRef: literalAssociation ]jump: distance  pc := pc + distancetestIsAbstract  self assert: Integer isAbstracttestGoodSimulation  self runSimulated: [ 1 + 2 ]theMetaClass  self deprecated: 'Please use #classSide instead' transformWith: '`@receiver theMetaClass' -> '`@receiver classSide'.  ^self classSidegenPushInstVarLong: instVarIndex  (instVarIndex >= 0 and: [ instVarIndex < 256 ]) ifTrue: [ stream           nextPut: 132;           nextPut: 64;           nextPut: instVarIndex.        ^self ].  ^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255classPool  ^self instanceSide classPoolcompiler  ^self instanceSide classSideCompilerclassVariables  ^self instanceSide ifNil: [ #() ] ifNotNil: [:class |  class classVariables ]simpleAdd: char  | dict elem |  codes ifNil: [ codes := Array with: char.        combined := char.        ^true ].  dict := Compositions at: combined charCode ifAbsent: [ ^false ].  elem := dict at: char charCode ifAbsent: [ ^false ].  combined := Character leadingChar: self base leadingChar code: elem.  codes at: 1 put: combined.  ^trueeven  ^(self bitAnd: 1) = 0testMinus  self assert: aDuration - aDuration equals: (Duration seconds: 0).  self assert: aDuration - (Duration days: -1 hours: -2 minutes: -3 seconds: -4 nanoSeconds: -5) equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10).  self assert: aDuration - (Duration days: 0 hours: 1 minutes: 2 seconds: 3 nanoSeconds: 4) equals: (Duration days: 1 hours: 1 minutes: 1 seconds: 1 nanoSeconds: 1).  self assert: aDuration - (Duration days: 0 hours: 3 minutes: 0 seconds: 5 nanoSeconds: 0) equals: (Duration days: 0 hours: 23 minutes: 2 seconds: 59 nanoSeconds: 5)topCenter  ^self center x @ self toptestFromDays  | march18th1627 epochFromDays june2nd1973FromDays march18th1627FromDays january23rd2004FromDays |  epochFromDays := self dateClass fromDays: 0.  self assert: epochFromDays equals: (self epoch translateTo: 0).  june2nd1973FromDays := self dateClass fromDays: (june2nd1973 - self epoch) asDays.  self assert: june2nd1973FromDays equals: (june2nd1973 translateTo: 0).  march18th1627 := '18 March 1627' asDate.  march18th1627FromDays := self dateClass fromDays: (march18th1627 - self epoch) asDays.  self assert: march18th1627FromDays equals: (march18th1627 translateTo: 0).  january23rd2004FromDays := self dateClass fromDays: 103 * 365 + 22 + 25.  self assert: january23rd2004FromDays equals: (january23rd2004 translateTo: 0)cull: arg  ^selector numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: arg ]gtInspectorSourceIn: composite  < gtInspectorPresentationOrder: 30>  ^composite pharoMethod     title: 'Source';     smalltalkClass: [ self methodClass ];     display: [ self sourceCode ];     act: [ self browse ] icon: GLMUIThemeExtraIcons glamorousBrowse entitled: 'Browse'testRefersToLiteralsReturnsTrueWhenLiteralIsInMethodPropertiesValueArray  [ self compiledMethod1 propertyAt: #Once put: #(1 2 3).  self assert: (self compiledMethod1 hasLiteralThorough: 1) ] ensure: [ self compiledMethod1 removeProperty: #Once ]sizeStoreInstVar: instVarIndex  ^self sizeOpcodeSelector: #genStoreInstVar: withArguments: {instVarIndex}testsourceCodeTemplateFor  self assert: (Object sourceCodeTemplate includesSubstring: 'instance-side message').  self assert: (Object class sourceCodeTemplate includesSubstring: 'class-side message')argument: newValue  args at: 1 put: newValueprintOn: aStream  | title |  title := self class name.  aStream     nextPutAll: (title first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);     nextPutAll: titlefollowingBytecode  ^self method at: self followingPcisResumable  ^truestopTimerEventLoop  isCompiledBlock  ^falsetestAsUnixTimeIndependentOfTimezone  | datetimeWithOffset datetimeWithoutOffset |  datetimeWithoutOffset := DateAndTime current offset: Duration zero.  datetimeWithOffset := datetimeWithoutOffset offset: (Duration hours: 1).  self assert: datetimeWithOffset asUnixTime equals: datetimeWithoutOffset asUnixTimeisDefinedInPackage: aPackage  ^aPackage includesClass: selftestCreationFromBytes2  | maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |  Smalltalk vm wordSize = 4 ifFalse: [ ^self skip ].  maxSmallInt := SmallInteger maxVal.  hexString := (maxSmallInt + 1) printStringHex.  self assert: hexString size equals: 8.  byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.  byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.  byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.  byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.  builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.  self assert: builtInteger equals: maxSmallInt + 1.  self deny: builtInteger class equals: SmallIntegerbinding  ^LiteralVariable key: nil value: selfvar1  ^var1testDateTime  self assert: aDateAndTime equals: (DateAndTime date: '01-01-1980' asDate time: '00:00:00' asTime)printOn: aStream  aStream nextPutAll: self namehash  ^(context ifNil: [ explanationString ]) hashisUnwindContext  ^method primitive = 198classToBeTested  ^WeekbitShift: arg  < primitive: 17>  self >= 0 ifTrue: [ ^super bitShift: arg ].  ^arg >= 0 ifTrue: [ (self negated bitShift: arg) negated ] ifFalse: [ (self bitInvert bitShift: arg) bitInvert ]millisecondsUntilTick: delay  self subclassResponsibilityhasInstVarRef  self localHasInstVarRef ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:cb |  cb hasInstVarRef ]shouldNotImplement  ShouldNotImplement signalFor: thisContext sender selectortestIsPowerOfTwo  self deny: (1 / (2 raisedTo: 80) negated) isPowerOfTwo.  self deny: (1 negated / (2 raisedTo: 80)) isPowerOfTwo.  self deny: ((2 raisedTo: 80) negated / 3) isPowerOfTwo.  self deny: ((2 raisedTo: 80) / 4 negated) isPowerOfTwo.  self assert: (1 / 2) isPowerOfTwo.  self assert: (1 / (2 raisedTo: 80)) isPowerOfTwo.  self assert: (1 negated / (2 raisedTo: 80) negated) isPowerOfTwo.  self deny: ((2 raisedTo: 80) / 3) isPowerOfTwo.  self assert: ((2 raisedTo: 80) / 4) isPowerOfTwotestDynamicVariable  | s1 s2 p1stopped p2stopped |  s1 := Semaphore new.  s2 := Semaphore new.  p1stopped := p2stopped := false.  [ TestDynamicVariable value: 1 during: [ self checkDynamic: 1.        (Delay forMilliseconds: 30) wait.        self checkDynamic: 1.        TestDynamicVariable value: 3 during: [ (Delay forMilliseconds: 30) wait.              self checkDynamic: 3 ].        self checkDynamic: 1 ].  self checkDynamic: nil.  p1stopped := true.  s1 signal ] fork.  [ TestDynamicVariable value: 2 during: [ self checkDynamic: 2.        (Delay forMilliseconds: 30) wait.        self checkDynamic: 2 ].  self checkDynamic: nil.  p2stopped := true.  s2 signal ] fork.  s1 waitTimeoutSeconds: 2.  s2 waitTimeoutSeconds: 2.  self assert: p1stopped.  self assert: p2stoppedrenameSilently: aName  [ self rename: aName ] fuelValueWithoutNotificationsallSharedPools  ^self superclass allSharedPoolsln  < primitive: 558>  | expt n mant x div pow delta sum eps |  self <= 0.0 ifTrue: [ ^DomainError signal: 'ln is only defined for x > 0' from: 0 ].  expt := self exponent.  n := Ln2 * expt.  mant := self timesTwoPower: 0 - expt.  x := mant - 1.0.  div := 1.0.  pow := delta := sum := x.  x := x negated.  eps := Epsilon * (n abs + 1.0).  [ delta > eps ] whileTrue: [ div := div + 1.0.        pow := pow * x.        delta := pow / div.        sum := sum + delta.        div := div + 1.0.        pow := pow * x.        delta := pow / div.        sum := sum + delta ].  ^n + sumwait  [ self schedule.  beingWaitedOn ifTrue: [ delaySemaphore wait ] ifFalse: [ expired := true ] ] ensure: [ self unschedule ].  ^self isExpiredwithAllSubAndSuperclassesDo: aBlock  self withAllSubclassesDo: aBlock.  self allSuperclassesDo: aBlocktestMetaclassNumberOfInstances  self assert: Dictionary class allInstances size equals: 1.  self assert: OrderedCollection class allInstances size equals: 1initialize  super initialize.  self seconds: 0 nanoSeconds: 0ensureProperties  ^ClassProperties at: self ifAbsentPut: WeakKeyDictionary newprimeFactors  ^Array streamContents: [:s |  self primeFactorsOn: s ]printSubclassesOn: aStream level: level  self printSubclassesOn: aStream level: level filter: nilcompilerClass  ^Smalltalk compilerClassfileOutCategory: catName  | internalStream |  internalStream := (String new: 1000) writeStream.  internalStream     header;     timeStamp.  self fileOutCategory: catName on: internalStream.  internalStream trailer.  ^CodeExporter writeSourceCodeFrom: internalStream baseName: self name , '-' , catName isSt: truearguments: anArray  arguments := anArraytestValueWithinTimingBasic  | time |  time := [ [ 1000 milliSeconds asDelay wait ] valueWithin: 100 milliSeconds onTimeout: [  ] ] durationToRun.  self assert: time < 1000 milliSecondstestMutateObjectInstVarShouldCatchRightFailure  | guineaPig failure |  guineaPig := MessageSend new.  guineaPig beReadOnlyObject.  failure := [ guineaPig receiver: #test ] on: ModificationForbidden do: [:err |  err ].  self assert: failure object identicalTo: guineaPig.  self assert: failure newValue equals: #test.  self assert: failure fieldIndex equals: 1var10  ^var10protocol  ^self categorytarget  ^target| aBoolean  ^selfprintOn: aStream  self printOn: aStream showingDecimalPlaces: scale.  aStream     nextPut: $s;     print: scaleasFraction  ^denominator = 1 ifTrue: [ numerator ] ifFalse: [ Fraction numerator: numerator denominator: denominator ]testCannotReturn  | block p |  p := [ block := self blockWithNonLocalReturn: #result ] fork.  [ p isTerminated ] whileFalse: [ 10 milliSeconds wait ].  [ block value.  self assert: false description: 'BlockCannotReturn should be signaled' ] on: BlockCannotReturn do: [:err |  self assert: err result equals: #result.        self assert: err home equals: block home ]initialize  self cleartestIsLeapYear  self deny: aDateAndTime isLeapYearvalue: firstArg value: secondArg value: thirdArg  < primitive: 204>  numArgs ~= 3 ifTrue: [ self numArgsError: 3 ].  ^self primitiveFailed& aBoolean  ^selftestIfNilIfNotNil  | object returnValue block notReached1 reached1 notReached2 reached2 reached3 notReached3 reached4 notReached4 |  notReached1 := false.  reached1 := false.  notReached2 := false.  reached2 := false.  notReached3 := false.  reached3 := false.  notReached4 := false.  reached4 := false.  object := ProtoObject new.  returnValue := Object new.  object ifNil: [ notReached1 := true ] ifNotNil: [ reached1 := true ].  self assert: notReached1 equals: false.  self assert: reached1 equals: true.  object ifNil: [ notReached2 := true ] ifNotNil: [:o |  reached2 := true ].  self assert: notReached2 equals: false.  self assert: reached2 equals: true.  self assert: (object ifNil: [ false ] ifNotNil: [:o |  o == object ]).  self assert: (object ifNil: [ nil ] ifNotNil: [ returnValue ]) identicalTo: returnValue.  self assert: (object ifNil: [ nil ] ifNotNil: [:o |  returnValue ]) identicalTo: returnValue.  block := [ reached3 := true ].  object ifNil: [ notReached3 := true ] ifNotNil: block.  self assert: notReached3 equals: false.  self assert: reached3 equals: true.  block := [:o |  reached4 := true ].  object ifNil: [ notReached4 := true ] ifNotNil: block.  self assert: notReached4 equals: false.  self assert: reached4 equals: true.  block := [:o |  o == object ].  self assert: (object ifNil: [ false ] ifNotNil: block).  block := [ returnValue ].  self assert: (object ifNil: [ nil ] ifNotNil: block) equals: returnValue.  block := [:o |  returnValue ].  self assert: (object ifNil: [ nil ] ifNotNil: block) equals: returnValuetokenish  ^self isLetter or: [ self isDigit or: [ self = $_ or: [ self = $: ] ] ]** exponent  ^self raisedTo: exponenttestParsingMPatternWithIncorrectMonthFails  self assertReading: '1.0.2013' as: 'dd.m.yyyy' raise: DateError.  self assertReading: '22.13.2013' as: 'dd.m.yyyy' raise: DateErrorperform: aSymbol  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: aSymbol withArguments: (Array new: 0)isContext  ^trueencodeClearedTrailer  self clear.  kind := #NoTrailer.  ^self encodeprimitiveChangeClassTo: anObject  < primitive: 115>  self isReadOnlyObject ifTrue: [ ^self modificationForbiddenFor: #primitiveChangeClassTo: value: anObject ].  self primitiveFailedcloseTo: num  ^self closeTo: num precision: 0.0001isEpiceaInterestingJobOwner  ^false>= aPoint  ^x >= aPoint x and: [ y >= aPoint y ]testNthRoot  1 << 2000 nthRoot: 100.  self assert: (1 << 2000 nthRoot: 100) equals: 1 << 20abs  self <= 0.0 ifTrue: [ ^0.0 - self ] ifFalse: [ ^self ]negated  ^-1.0 * selfend  ^self duration asNanoSeconds = 0 ifTrue: [ self start ] ifFalse: [ self next start - DateAndTime clockPrecision ]classToBeTested  ^TimespandecodeEmbeddedSource  | len start end newSize byteArray |  len := self decodeLengthField.  start := method size - self size + 1.  end := method size - self size + len.  newSize := end - start + 1.  byteArray := (ByteArray new: newSize) replaceFrom: 1 to: newSize with: method startingAt: start.  data := byteArray asStringlog  | res h |  res := super log.  res isFinite ifTrue: [ ^res ].  h := self highBit.  ^2 log * h + (self / (1 << h)) asFloat logdayOfWeekName  ^Week nameOfDay: self dayOfWeektestDaysInYear  self assert: aDateAndTime daysInYear equals: 365value: firstArg value: secondArg value: thirdArg value: fourthArg  < primitive: 207>  | newContext |  numArgs ~= 4 ifTrue: [ self numArgsError: 4 ].  false ifTrue: [ newContext := self asContextWithSender: thisContext sender.        newContext at: 1 put: firstArg.        newContext at: 2 put: secondArg.        newContext at: 3 put: thirdArg.        newContext at: 4 put: fourthArg.        thisContext privSender: newContext ] ifFalse: [ self primitiveFailed ]nanoSecond  ^nanostestIntersectAll  self assert: (self intersectAll: {(LinkedList with: 3 with: #mangos with: #and) .               (LinkedList with: 3 with: #kiwis with: #and) .               (LinkedList with: 3 with: #hamburges)}) equals: {3}.  self assert: (self intersectAll: {(LinkedList with: 3 with: #steaks with: #and) .               (LinkedList with: #no with: #food with: #and) .               (LinkedList with: #three with: #baked with: #potatoes) .               (LinkedList with: 3 with: #diet with: #hamburges)}) equals: {}.  self assert: (self intersectAll: {(LinkedList with: 3 with: #steaks with: #and) .               LinkedList new .               (LinkedList with: #three with: #baked with: #potatoes) .               (LinkedList with: 3 with: #diet with: #hamburges)}) equals: {}.  self assert: (self intersectAllWithCC: {(LinkedList with: 3 with: #steaks with: #and) .               LinkedList new .               (LinkedList with: #three with: #baked with: #potatoes) .               (LinkedList with: 3 with: #diet with: #hamburges)}) equals: {}.  self assert: (self intersectWithCCAllWithCC: {(LinkedList with: 3 with: #steaks with: #and) .               (LinkedList with: #no with: #food with: #and) .               (LinkedList with: #three with: #baked with: #potatoes) .               (LinkedList with: 3 with: #diet with: #hamburges)}) equals: {}testIntegerPart  self     assert: 2 integerPart equals: 2;     assert: (1 / 2) integerPart equals: 0;     assert: (4 / 3) integerPart equals: 1;     assert: 2.0 integerPart equals: 2.0;     assert: 0.5 integerPart equals: 0.0;     assert: 2.5 integerPart equals: 2.0default  ^DefaultExecutionEnvironment instancetestJump  #(exampleClosure exampleSend exampleStore) do: [:selector |  self verifyJumpWithSelector: selector ]decimalDigitAt: anExponent  ^self digitAt: anExponent base: 10testPrinting  self assert: month printString equals: 'July 1998'testSetOfFloat  | size3 size4 |  size3 := (Set new: 3)     add: 3;     add: 3.0;     size.  size4 := (Set new: 4)     add: 3;     add: 3.0;     size.  self assert: size3 = size4 description: 'The size of a Set should not depend on its capacity.'variableByteSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat  | oldClassOrNil actualLayoutClass |  oldClassOrNil := self environment at: t ifAbsent: [ nil ].  actualLayoutClass := (oldClassOrNil notNil and: [ oldClassOrNil classLayout class == CompiledMethodLayout ]) ifTrue: [ CompiledMethodLayout ] ifFalse: [ ByteLayout ].  ^self classInstaller make: [:builder |  builder           superclass: self;           name: t;           layoutClass: actualLayoutClass;           slots: f asSlotCollection;           sharedVariablesFromString: d;           sharedPools: s;           category: cat;           environment: self environment ]deleteClass  | cl |  cl := testEnvironment at: className ifAbsent: [ ^self ].  testingEnvironment at: #ChangeSet ifPresent: [ cl removeFromChanges ].  cl removeFromSystemUnloggedtestNew  self should: [ False new ] raise: self defaultTestErrorencoderClass  ^self signFlag ifTrue: [ SecondaryBytecodeSetEncoderClass ] ifFalse: [ PrimaryBytecodeSetEncoderClass ]isAnyArgumentGarbage  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg :flag |  (flag not and: [ arg isNil ]) ifTrue: [ ^true ] ] ].  ^falsehome  ^outerContext hometestAs  | coll1 coll2 |  coll1 := {1 .   2 .   3}.  coll2 := coll1 as: OrderedCollection.  self assert: coll2 equals: (OrderedCollection with: 1 with: 2 with: 3).  self deny: coll1 identicalTo: coll2.  coll2 := coll1 as: Array.  self assert: coll1 identicalTo: coll2aRandomSelectionOfCharactersDo: aBlock  self aRandomSelectionOfCodePointsDo: [:cp |  aBlock value: (Character codePoint: cp) ]fileOut  ^self origin fileOutMethod: self selectorasYear  ^start asYearrenderGlamorouslyOn: aRenderer  ^aRenderer renderObject: selftestIsConnectorPunctuation  self checkCorrespondanceOf: #isConnectorPunctuation: and: #PctestIsOnOrBefore  | tzm8 tzp10 |  tzm8 := january23rd2004 translateTo: -8.  tzp10 := january23rd2004 translateTo: 10.  self     assert: (tzm8 isOnOrBefore: tzp10);     assert: (june2nd1973 isOnOrBefore: january23rd2004);     assert: (june2nd1973 isOnOrBefore: june2nd1973);     assert: (january23rd2004 isOnOrBefore: june2nd1973) notgenBranchPopFalse: distance  distance < 0 ifTrue: [ ^self outOfRangeError: 'distance' index: distance range: 0 to: 1023 ].  (distance > 0 and: [ distance < 9 ]) ifTrue: [ stream nextPut: 152 + distance - 1.        ^self ].  distance < 1024 ifTrue: [ stream           nextPut: 172 + (distance bitShift: -8);           nextPut: (distance + 1024) \\ 256.        ^self ].  ^self outOfRangeError: 'distance' index: distance range: 0 to: 1023bitAt: anInteger  ^(self bitShift: 1 - anInteger) bitAnd: 1ln  ^DomainError signal: 'ln is only defined for x > 0' from: 0>= aNumber  aNumber isFraction ifTrue: [ ^numerator * aNumber denominator >= (aNumber numerator * denominator) ].  ^aNumber adaptToFraction: self andCompare: #>=hasMethodReturn  | scanner endpc |  scanner := InstructionStream new method: outerContext method pc: startpc.  endpc := self endPC.  scanner scanFor: [:byte |  (outerContext method encoderClass methodReturnBytecodes includes: byte) or: [ scanner pc > endpc ] ].  ^scanner pc <= endpcwaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil  self exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNilprintLowercaseHexByteOn: characterWriteStream  (self between: 0 and: 255) ifTrue: [ | highNibble lowNibble hexDigits |        highNibble := self bitShift: -4.        lowNibble := self bitAnd: 15.        hexDigits := '0123456789abcdef'.        characterWriteStream           nextPut: (hexDigits at: highNibble + 1);           nextPut: (hexDigits at: lowNibble + 1) ] ifFalse: [ self error: 'byte value between 0 and 255 expected' ]testIsLineSeparator  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isLineSeparator: ch) equals: (charset isLineSeparator: ch) ]genPushInstVar: instVarIndex  (instVarIndex between: 0 and: 15) ifTrue: [ stream nextPut: 0 + instVarIndex.        ^self ].  self genPushInstVarLong: instVarIndexmethodClass  ^self classBinding valuestoreAt: offset inTempFrame: aContext  ^aContext tempAt: offset put: selfalignedTo: anInteger  ^(self + anInteger - 1) // anInteger * anIntegerisTwoDigitMonthPattern  ^patternStream peekFor: $mtestYesterday  self deny: aDateAndTime equals: DateAndTime yesterday+ operand  ^self species starting: self start + operand duration: self durationdayOfMonth  ^start dayOfMonthcull: arg1 cull: arg2 cull: arg3  ^selector numArgs < 3 ifTrue: [ self cull: arg1 cull: arg2 ] ifFalse: [ self value: arg1 value: arg2 value: arg3 ]testMultiSchedule  | delay |  delay := Delay forSeconds: 1.  delay schedule.  self should: [ delay schedule ] raise: ErrorprintOn: aStream  aStream nextPutAll: 'true'>= aNumber  aNumber class = self class ifTrue: [ ^self asFraction >= aNumber asFraction ].  ^self asFraction >= aNumbertestBecomeForward  | a b c d |  a := 'ab' copy.  b := 'cd' copy.  c := a.  d := b.  a becomeForward: b.  self     assert: a equals: 'cd';     assert: b equals: 'cd';     assert: c equals: 'cd';     assert: d equals: 'cd'testTransitive  | t1 t2 t3 |  t1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  t2 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  t3 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self assert: (t1 = t2 & (t2 = t3)) ==> (t1 = t3)testReadFrom  | rs i s |  rs := '123s could be confused with a ScaledDecimal' readStream.  i := Integer readFrom: rs.  self assert: i equals: 123.  s := rs upToEnd.  self assert: 's could be confused with a ScaledDecimal' equals: s.  rs := '123.s could be confused with a ScaledDecimal' readStream.  i := Integer readFrom: rs.  self assert: i equals: 123.  s := rs upToEnd.  self assert: '.s could be confused with a ScaledDecimal' equals: stestPrintStringBase  2 to: 32 do: [:b |  1 to: 1000 // b do: [:n |  | bRaisedToN |              bRaisedToN := b raisedTo: n.              self assert: (bRaisedToN - 1 printStringBase: b) equals: (String new: n withAll: (Character digitValue: b - 1)).              self assert: (bRaisedToN printStringBase: b) equals: '1' , (String new: n withAll: $0).              self assert: (bRaisedToN negated + 1 printStringBase: b) equals: '-' , (String new: n withAll: (Character digitValue: b - 1)).              self assert: (bRaisedToN negated printStringBase: b) equals: '-1' , (String new: n withAll: $0) ] ]runBackendLoopAtTimingPriority  < haltOrBreakpointForTesting>  [ [ runTimerEventLoop ] whileTrue: [ | nowTick |        ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay.        debug ifTrue: [ self halt ].        suspendSemaphore ifNotNil: [ self suspendAtTimingPriority ].        delayToStart ifNotNil: [ self scheduleAtTimingPriority ].        delayToStop ifNotNil: [ self unscheduleAtTimingPriority ].        nowTick := ticker nowTick.        [ activeDelay notNil and: [ nowTick >= activeDelay resumptionTick ] ] whileTrue: [ activeDelay timingPrioritySignalExpired.              activeDelay := suspendedDelays removeFirstOrNil ] ] ] ensure: [ debug ifTrue: [ self halt ].        [ activeDelay notNil ] whileTrue: [ activeDelay timingPrioritySignalExpired.              activeDelay := suspendedDelays removeFirstOrNil ] ]withAllSuperclasses  ^self allSuperclasses     addFirst: self;     yourselfblockReturnConstant: value  self assert: closureOrNil isClosure.  ^self return: value from: selfsendTo: anObject  ^anObject perform: self selector withArguments: self argumentsulp  | exponent |  self isFinite ifFalse: [ self isNaN ifTrue: [ ^self ].        ^Float infinity ].  self = 0.0 ifTrue: [ ^Float fmin ].  exponent := self exponent.  ^exponent < self class emin ifTrue: [ Float fminDenormalized ] ifFalse: [ Float epsilon timesTwoPower: exponent ]fileOutInitializerOn: aStream  ^self class fileOutInitializerOn: aStreamcopySignTo: aNumber  ^self signBit = 0 ifTrue: [ aNumber abs ] ifFalse: [ aNumber abs negated ]unpackFromArity: arity  self = 0 ifFalse: [ self error: 'Should not arrive here. FFI bad code.' ].  ^selfvariableWordSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self variableWordSubclass: className uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames package: catstartpc  ^closureOrNil ifNil: [ self method initialPC ] ifNotNil: [ closureOrNil startpc ]instVarMappingFrom: oldClass  | oldInstVarNames |  oldInstVarNames := oldClass allInstVarNames.  ^self allInstVarNames collect: [:instVarName |  oldInstVarNames indexOf: instVarName ]testBitAnd  self assert: (2r1100 bitAnd: 2r1010) equals: 2r1000.  self assert: 2r1100 & 2r1010 equals: 2r1000.  self assert: (-2 bitAnd: 16rFFFFFFFF) equals: 16rFFFFFFFE.  self assert: -2 & 16rFFFFFFFF equals: 16rFFFFFFFEprintOn: s  s << 'compiledBlock'testCopy  | copy |  copy := amState copy.  self deny: amState identicalTo: copy.  self assert: amState method identicalTo: copy method.  self assert: amState selector identicalTo: copy selector.  self assert: amState pragmas equals: copy pragmas.  self assert: amState properties equals: copy properties.  amState pragmas withIndexDo: [:el :index |  self deny: el identicalTo: (copy pragmas at: index) ]isNil  ^truetestZero  self assert: Duration zero equals: (Duration seconds: 0)testTimeZoneEquivalence  | twoPmInLondon nineAmInDetroit durationDifference |  twoPmInLondon := '2004-11-02T14:00:00+00:00' asDateAndTime.  nineAmInDetroit := '2004-11-02T09:00:00-05:00' asDateAndTime.  durationDifference := twoPmInLondon - nineAmInDetroit.  self assert: durationDifference asSeconds equals: 0.  self assert: twoPmInLondon equals: nineAmInDetroitln  < primitive: 58>  | expt n mant x div pow delta sum eps |  self <= 0.0 ifTrue: [ ^DomainError signal: 'ln is only defined for x > 0' from: 0 ].  expt := self exponent.  n := Ln2 * expt.  mant := self timesTwoPower: 0 - expt.  x := mant - 1.0.  div := 1.0.  pow := delta := sum := x.  x := x negated.  eps := Epsilon * (n abs + 1.0).  [ delta > eps ] whileTrue: [ div := div + 1.0.        pow := pow * x.        delta := pow / div.        sum := sum + delta.        div := div + 1.0.        pow := pow * x.        delta := pow / div.        sum := sum + delta ].  ^n + sumspaceUsed  | space |  space := 0.  self methodsDo: [:method |  space := space + 16.        space := space + (method size + 6).        method literalsDo: [:lit |  (lit isMemberOf: Array) ifTrue: [ space := space + ((lit size + 1) * 4) ].              (lit isMemberOf: Float) ifTrue: [ space := space + 12 ].              (lit isMemberOf: ByteString) ifTrue: [ space := space + (lit size + 6) ].              (lit isMemberOf: LargeNegativeInteger) ifTrue: [ space := space + ((lit size + 1) * 4) ].              (lit isMemberOf: LargePositiveInteger) ifTrue: [ space := space + ((lit size + 1) * 4) ] ] ].  ^spaceexpandTo: grid  ^Rectangle origin: (origin roundDownTo: grid) corner: (corner roundUpTo: grid)allSharedPools  ^OrderedCollection newnumArgs  ^self arguments sizesetUp  super setUp.  restoredStartDay := Week startDay.  restoredTimeZone := DateAndTime localTimeZone.  Week startDay: #Sunday.  DateAndTime localTimeZone: (TimeZone timeZones detect: [:tz |  tz abbreviation = 'GMT' ])testCommonSuperclassWith  self assert: (OrderedCollection commonSuperclassWith: Array) equals: SequenceableCollection.  self assert: (OrderedCollection commonSuperclassWith: OrderedCollection) equals: SequenceableCollection.  self assert: (ProtoObject commonSuperclassWith: Object) equals: niltestReplaceFromToWithStartingAt  | lni20 lni7 |  lni20 := LargeNegativeInteger new: 20.  1 to: 20 do: [:i |  lni20 byteAt: i put: i ].  lni7 := LargeNegativeInteger new: 7.  1 to: 7 do: [:i |  lni7 byteAt: i put: 11 - i ].  lni20 replaceFrom: 6 to: 10 with: lni7 startingAt: 2.  (1 to: 5) , (11 to: 20) do: [:e |  | digit |        digit := lni20 byteAt: e.        self assert: e equals: digit ].  6 to: 10 do: [:e |  | digit replacementDigit |        digit := lni20 byteAt: e.        replacementDigit := lni7 byteAt: e - 4.        self assert: replacementDigit equals: digit ]truncated  (origin x isInteger and: [ origin y isInteger and: [ corner x isInteger and: [ corner y isInteger ] ] ]) ifTrue: [ ^self ].  ^Rectangle origin: origin truncated corner: corner truncatedtestYearMonthDay  self assert: aDateAndTime equals: (DateAndTime year: 1901 month: 1 day: 1)basicNew: sizeRequested  < primitive: 71 error: ec>  ec == #'insufficient object memory' ifTrue: [ ^self handleFailingBasicNew: sizeRequested ].  self isVariable ifFalse: [ self error: self printString , ' cannot have variable sized instances' ].  self primitiveFailedcategory  | result |  self basicCategory ifNotNil: [:symbol |  ((self environment organization listAtCategoryNamed: symbol) includes: self name) ifTrue: [ ^symbol ] ].  result := (self environment organization categoryOfElement: self name) ifNil: [ #Unclassified ] ifNotNil: [:value |  value ].  self basicCategory: result.  ^resultclassSide  ^selfremoveSharedPool: aDictionary  | satisfiedSet workingSet aSubclass |  (self sharedPools includes: aDictionary) ifFalse: [ ^self error: 'the dictionary is not in my pool' ].  (self selectSuperclasses: [:class |  class sharedPools includes: aDictionary ]) isEmpty ifFalse: [ self sharedPools remove: aDictionary.        self sharedPools isEmpty ifTrue: [ self sharedPools: nil ].        ^self ].  workingSet := self subclasses asOrderedCollection.  satisfiedSet := Set new.  [ workingSet isEmpty ] whileFalse: [ aSubclass := workingSet removeFirst.        (aSubclass sharedPools includes: aDictionary) ifFalse: [ satisfiedSet add: aSubclass.              workingSet addAll: aSubclass subclasses ] ].  satisfiedSet add: self.  satisfiedSet do: [:sub |  aDictionary associationsDo: [:aGlobal |  (sub whichSelectorsReferTo: aGlobal) isEmpty ifFalse: [ ^self error: aGlobal key , ' is still used in code of class ' , sub name ] ] ].  self sharedPools remove: aDictionary.  self sharedPools isEmpty ifTrue: [ self sharedPools: nil ]genStoreInstVar: instVarIndex  (instVarIndex < 0 or: [ instVarIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535 ].  instVarIndex > 255 ifTrue: [ self genUnsignedSingleExtendA: instVarIndex // 256 ].  stream     nextPut: 243;     nextPut: instVarIndex \\ 256freeze  self freezeUpTo: thisContextisSignaled  ^excessSignals > 0arcTan  < primitive: 557>  | theta eps step sinTheta cosTheta |  self < 0.0 ifTrue: [ ^0.0 - (0.0 - self) arcTan ].  theta := self * Halfpi / (self + 1.0).  eps := Halfpi * Epsilon.  step := theta.  [ step * step > eps ] whileTrue: [ sinTheta := theta sin.        cosTheta := theta cos.        step := sinTheta * cosTheta - (self * cosTheta * cosTheta).        theta := theta - step ].  ^thetagtDebuggerSUnitPrint  ^self printStringisProbablyPrimeWithK: k andQ: q randomIndex: aRandomFloat  | x j y minusOne |  x := ((self - 2) * aRandomFloat) asInteger + 1.  j := 0.  y := x raisedTo: q modulo: self.  minusOne := self - 1.  [ y = 1 ifTrue: [ ^j = 0 ].  y = minusOne ifTrue: [ ^true ].  (j := j + 1) < k ] whileTrue: [ y := y squared \\ self ].  ^falseprintOn: aStream  ^self printOn: aStream withLeadingSpace: falsetestAsNanoSeconds  self assert: aDateAndTime asNanoSeconds equals: 0 asDuration asNanoSecondslocalWritesRef: literalAssociation  | litIndex scanner |  (litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue: [ ^false ].  litIndex := litIndex - 1.  ^(scanner := InstructionStream on: self) scanFor: (self encoderClass bindingWriteScanBlockFor: litIndex using: scanner)findOriginClassOf: aMethod  ^selfwaitForUserSignalled: timingSemaphore orExpired: activeDelay  | nextTick |  nextTick := self nowTick + (1 * 1000).  activeDelay ifNotNil: [ nextTick := nextTick min: activeDelay resumptionTick ].  timingSemaphore initSignals.  self primSignal: timingSemaphore atMilliseconds: nextTick.  timingSemaphore wait>= aNumber  < primitive: 46>  ^aNumber adaptToFloat: self andCompare: #>=subclassesDo: aBlock  self isMetaclassOfClassOrNil ifTrue: [ ^self ].  self instanceSide subclasses do: [:each |  aBlock value: each classSide ]spotterInstanceVariablesFor: aStep  < spotterOrder: 20>  self isTrait ifTrue: [ ^self ].  aStep listProcessor     title: 'Instance variables';     allCandidates: [ self classLayout allSlots ];     itemName: [:each |  each name asString ];     filter: GTFilterSubstringisAnonymous  ^self soleInstance isAnonymousmeridianAbbreviation  ^self hour < 12 ifTrue: [ 'AM' ] ifFalse: [ 'PM' ]instVarAt: index put: anObject  < primitive: 174 error: ec>  (index isInteger and: [ index between: 1 and: self class instSize + self basicSize ]) ifFalse: [ ^self errorSubscriptBounds: index ].  self isReadOnlyObject ifTrue: [ ^self modificationForbiddenFor: #instVarAt:put: index: index value: anObject ]testSupplySpecificAnswerToQuestion  self should: [ false = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('You like Smalltalk?' false)) ]resumableFallOffTheEndHandler  [ self doSomething.  MyTestNotification signal.  self doSomethingElse ] on: MyTestNotification do: [:ex |  self doSomethingExceptional ].  self doYetAnotherThingensureRingDefinitionIn: anRGEnvironment  | parentModel |  parentModel := self methodClass ensureRingDefinitionIn: anRGEnvironment.  ^parentModel methods detect: [:each |  each selector = self selector ] ifNone: [ | methodModel |        methodModel := self asRingMinimalDefinitionIn: anRGEnvironment.        parentModel addLocalMethod: methodModel.        methodModel ]priority: anInteger  (anInteger between: Processor lowestPriority and: Processor highestPriority) ifTrue: [ priority := anInteger ] ifFalse: [ self error: 'Invalid priority: ' , anInteger printString ]testIfTrue  self assert: (true ifTrue: [ 'alternativeBlock' ]) equals: 'alternativeBlock'metacelloIntegerLessThanSelf: anInteger  ^anInteger < selfleft  ^origin xsimulate_vmMilliseconds: milliseconds  vmSimNextWakeupTick ~= 0 ifTrue: [ vmSimNow := milliseconds.        vmSimNow >= vmSimNextWakeupTick ifTrue: [ vmSimNextWakeupTick := 0.              vmSimTheTimerSemaphore signal ] ]isSubclassResponsibility  ^self isSubclassResponsibility: self markerOrNiltestSimplePass  self assertSuccess: (ExceptionTester new runTest: #simplePassTest)testFromString  | d |  d := self dateClass fromString: '06.02.1973'.  self assert: d equals: june2nd1973.  d := self dateClass fromString: '06-02-1973'.  self assert: d equals: june2nd1973.  d := self dateClass fromString: '06/02/1973'.  self assert: d equals: june2nd1973asCharacter  ^selfasFixedTimeZone  ^TimeZone offset: self offset name: 'Fixed Local Time' abbreviation: self abbreviationwaitLastProcessSuspend  self waitProcessSuspend: forkedProcesses lastliterals  | literals numberLiterals |  literals := Array new: (numberLiterals := self numLiterals - self numberOfReservedLiterals).  1 to: numberLiterals do: [:index |  literals at: index put: (self objectAt: index + 1) ].  ^literalstestRefersToLiteralsReturnsTrueWhenLiteralIsArrayOfLiterals  self assert: (self compiledMethod1 hasLiteralThorough: #(#add #at: #remove))printStringLimitedTo: limit  ^self printStringLimitedTo: limit using: [:s |  self printOn: s ]printYMD: aDateTime withLeadingSpace: printLeadingSpaceToo on: aStream  | year month day |  aDateTime dayMonthYearDo: [:d :m :y |  year := y.        month := m.        day := d ].  year negative ifTrue: [ aStream nextPut: $- ] ifFalse: [ printLeadingSpaceToo ifTrue: [ aStream space ] ].  year abs printOn: aStream base: 10 length: 4 padded: true.  aStream nextPut: $-.  month printOn: aStream base: 10 length: 2 padded: true.  aStream nextPut: $-.  day printOn: aStream base: 10 length: 2 padded: truereformatAll  super reformatAll.  self classSide reformatAllgtConstructDebuggerInspectorIn: composite for: aDebugger  ^composite custom: ((GTDebuggerInspector new           debugger: aDebugger;           notifyPaneRemoved: true;           showFirst: [:a |  a custom: (aDebugger class variablesBrowserClass new                       debugger: aDebugger;                       startOn: self;                       restoreSettings;                       yourself) ];           yourself) startOn: self)milliSecond  ^self milliSecondsmidnight  self dayMonthYearDo: [:day :month :year |  ^self class basicYear: year month: month day: day hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: offset ]to  ^tochangeFromCategorySpecs: categorySpecs  | newCategories newStops temp cc currentStop oldElements newElements |  oldElements := elementArray asSet.  newCategories := Array new: categorySpecs size.  newStops := Array new: categorySpecs size.  currentStop := 0.  newElements := (Array new: 16) writeStream.  1 to: categorySpecs size do: [:i |  | selectors catSpec |        catSpec := categorySpecs at: i.        newCategories at: i put: catSpec first asSymbol.        selectors := catSpec allButFirst collect: [:each |  each isSymbol ifTrue: [ each ] ifFalse: [ each printString asSymbol ] ].        selectors asSortedCollection do: [:elem |  (oldElements remove: elem ifAbsent: [ nil ]) notNil ifTrue: [ newElements nextPut: elem.                    currentStop := currentStop + 1 ] ].        newStops at: i put: currentStop ].  oldElements := oldElements collect: [:elem |  Array with: (self categoryOfElement: elem) with: elem ].  newElements := newElements contents.  categoryArray := newCategories.  (cc := categoryArray asSet) size = categoryArray size ifFalse: [ temp := categoryArray asOrderedCollection.        temp removeAll: categoryArray asSet.        temp do: [:dup |  | tmp ii |              tmp := dup.              ii := categoryArray indexOf: tmp.              [ tmp := (tmp , ' #2') asSymbol.              cc includes: tmp ] whileTrue.              cc add: tmp.              categoryArray at: ii put: tmp ] ].  categoryStops := newStops.  elementArray := newElements.  oldElements do: [:pair |  self classify: pair last under: pair first ]testYearMonth  self assert: (DateAndTime year: 2018 month: 9) asDate asString equals: '1 September 2018'testYearMonthDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1970 month: 1 day: 1 hour: 0 minute: 0 second: 0)subclass: nameOfClass instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: poolDictnames category: category  Warning signal: 'Attempt to create ' , nameOfClass , ' as a subclass of nil.  Possibly a class is being loaded before its superclass.'.  ^Object subclass: nameOfClass instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: poolDictnames category: categorytestOneMWordAllocation  | sz array failed |  failed := false.  sz := 1024 * 1024.  array := [ Array new: sz ] on: OutOfMemory do: [:ex |  failed := true ].  self assert: (failed or: [ array size = sz ])testStringAsNumber  | aFloat |  aFloat := '10r-12.3456' asNumber.  self assert: -12.3456 equals: aFloat.  aFloat := '10r-12.3456e2' asNumber.  self assert: -1234.56 equals: aFloat.  aFloat := '10r-12.3456d2' asNumber.  self assert: -1234.56 equals: aFloat.  aFloat := '10r-12.3456q2' asNumber.  self assert: -1234.56 equals: aFloat.  aFloat := '-12.3456q2' asNumber.  self assert: -1234.56 equals: aFloat.  aFloat := '12.3456q2' asNumber.  self assert: 1234.56 equals: aFloatprintOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     print: selector;     nextPutAll: ' -> ';     print: self receiver;     nextPut: $)testLiteralEqual  self deny: (0.0 literalEqual: 0.0 negated).  self deny: (-0.0 literalEqual: -0.0 negated).  self deny: (0.0 literalEqual: -0.0)T: anObj  | n |  n := self getNext: anObj.  ^n isNotNil ifTrue: [ n = anObj or: [ self T: n ] ] ifFalse: [ false ]testFloatRounded  | x y int r |  int := 5000000000000001.  x := int asFloat.  y := (5 asFloat squared squared squared squared timesTwoPower: 15) + 1.  self assert: x equals: y.  self assert: x asTrueFraction equals: int.  self assert: x rounded equals: x asTrueFraction rounded.  self assert: x negated rounded equals: x negated asTrueFraction rounded.  r := Random new.  10000 timesRepeat: [ x := r next * 1.9999e16 + 1.0e12.        self assert: x rounded equals: x asTrueFraction rounded.        self assert: x negated rounded equals: x negated asTrueFraction rounded ]testAsMonth  self assert: aDateAndTime asMonth equals: (Month year: 1980 month: 'January')bytesCount  < primitive: 62>  self primitiveFailedsourceCode  kind == #EmbeddedSource ifTrue: [ ^data ].  kind == #EmbeddedSourceWide ifTrue: [ ^data ].  kind == #EmbeddedSourceQCompress ifTrue: [ ^data ].  kind == #EmbeddedSourceZip ifTrue: [ ^data ].  ^niltestAsTime  | dateAndTime |  dateAndTime := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 0 asDuration.  self assert: dateAndTime asTime equals: (Time hour: 1 minute: 2 second: 3).  dateAndTime := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 5 hours.  self assert: dateAndTime asTime equals: (Time hour: 1 minute: 2 second: 3).  dateAndTime := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: -5 hours.  self assert: dateAndTime asTime equals: (Time hour: 1 minute: 2 second: 3)hasSourcePointer  ^kind == #SourcePointer or: [ kind == #VarLengthSourcePointer ]criticalError  Processor activeProcess terminatetestRemoveNonExistingProtocol  self organization removeCategory: 'non-existent'assert: aBlock  < debuggerCompleteToSender>  self assert: aBlock description: 'Assertion failed'ifTrue: alternativeBlock  ^alternativeBlock valuegenReturnReceiver  stream nextPut: 120deprecatedMethodName  ^'deprecatedMethod'testIsParagraphSeparator  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isParagraphSeparator: ch) equals: (charset isParagraphSeparator: ch) ]hasProtocolNamed: aString  ^self allProtocols anySatisfy: [:each |  each name = aString ]sourcePointer  ^self subclassResponsibilityasResultForDrTest  ^DTTestLeaf content: selfasLink  ^ValueLink value: selfbasicIdentityHash  ^selfpostCopy  super postCopy.  self methodDict: self methodDict copyraisedToFraction: aFraction  | root |  root := (self numerator nthRootTruncated: aFraction denominator) / (self denominator nthRootTruncated: aFraction denominator).  (root raisedToInteger: aFraction denominator) = self ifTrue: [ ^root raisedToInteger: aFraction numerator ].  ^super raisedToFraction: aFractionsimpleTimeoutWithZeroDurationTest  [ self doSomething ] valueWithin: 0 seconds onTimeout: [ self doSomethingElse ]raiseWarningsIfAny: warnings  warnings ifNotEmpty: [ Warning new           messageText: 'VeryDeepCopy out of sync in some classes. Some classes contain veryDeepCopyWith: or veryDeepInner: methods that are not in sync with their instance variables. Check the exception #tag for a list of them';           tag: warnings;           signal ]ifError: errorHandlerBlock  ^self on: Error do: [:ex |  errorHandlerBlock cull: ex description cull: ex receiver ]encodeVarLengthSourcePointer  [ data >= 0 ] assert.  encodedData := data = 0 ifTrue: [ #[0] ] ifFalse: [ ByteArray streamContents: [:str |  | value |              value := data.              [ value > 0 ] whileTrue: [ value > 127 ifTrue: [ str nextPut: 128 + (value bitAnd: 16r7F) ] ifFalse: [ str nextPut: value ].                    value := value >> 7 ] ] ].  encodedData := encodedData reversed copyWith: self kindAsBytetestIsZero  self assert: 0.0 isZero.  self deny: 0.1 isZerowriteClassVariableNamed: aString value: anObject  (self classVariableNamed: aString) write: anObjectbyteAt: n  n = 1 ifTrue: [ ^self < 0 ifTrue: [ -256 - self bitAnd: 255 ] ifFalse: [ self bitAnd: 255 ] ].  ^self < 0 ifTrue: [ (-256 - self bitShift: -8) + 1 byteAt: n - 1 ] ifFalse: [ (self bitShift: 8 - (n bitShift: 3)) bitAnd: 255 ]> anInteger  < primitive: 24>  ^super > anIntegerforkedProcesses: anObject  forkedProcesses := anObject+ arg  arg isPoint ifTrue: [ ^(x + arg x) @ (y + arg y) ].  ^arg adaptToPoint: self andSend: #+testAsDateAndTime  | localOffset localOffsetSuffix |  #('-1199-01-05T20:33:14.321-05:00' '2002-05-16T17:20:45.1+01:01' '2002-05-16T17:20:45.02+01:01' '2002-05-16T17:20:45.003+01:01' '2002-05-16T17:20:45.0004+01:01' '2002-05-16T17:20:45+01:57' '2002-05-16T17:20:45.000006+01:01' '2002-05-16T17:20:45.0000007+01:01' '2002-05-16T17:20:45.00000008-01:01' '2002-05-16T17:20:45.000000009+01:01' '2002-05-16T17:20:45+00:00' '2002-05-16T17:20:45-02:34' '1997-04-26T01:02:03+01:02:3') do: [:each |  self assert: each asDateAndTime printString equals: each ].  localOffset := DateAndTime localOffset.  localOffsetSuffix := String streamContents: [:out |  out nextPut: (localOffset positive ifTrue: [ $+ ] ifFalse: [ $- ]).        localOffset hours abs printOn: out base: 10 length: 2 padded: true.        out nextPut: $:.        localOffset minutes abs printOn: out base: 10 length: 2 padded: true.        localOffset seconds = 0 ifFalse: [ out                 nextPut: $:;                 print: localOffset seconds rounded abs ] ].  #('2002-05-16T17:20:45.00005' '2002-05-16T17:20:00' '2002-05-16T17:20:45') do: [:each |  self assert: each asDateAndTime printString equals: each , localOffsetSuffix ]showWarning  ^self class showWarningisExpired  ^delaySemaphore isSignaledslotNames  ^self slots collect: [:each |  each name ]finalize  interpretSistaV1Jump  | method byte nextpc extB |  method := self method.  extB := 0.  nextpc := pc.  [ byte := self method at: nextpc.  nextpc := nextpc + 1.  byte = 225 ] whileTrue: [ | extByte |        extByte := self method at: nextpc.        nextpc := nextpc + 1.        extB := (extB = 0 and: [ extByte > 127 ]) ifTrue: [ extByte - 256 ] ifFalse: [ (extB bitShift: 8) + extByte ] ].  (byte between: 176 and: 183) ifTrue: [ pc := nextpc.        ^byte - 191 ].  byte = 237 ifTrue: [ byte := method at: nextpc.        pc := nextpc + 1.        ^(extB bitShift: 8) + byte ].  ^nilfromSton: stonReader  self class isVariable ifTrue: [ stonReader error: 'custom #fromSton: implementation needed for variable/indexable class' ] ifFalse: [ stonReader parseNamedInstVarsFor: self ]nbCall: fnSpec options: callOptions  < ffiCalloutTranslator>  self deprecated: 'use ffiCall:options: instead'.  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     options: callOptions;     function: fnSpec library: self ffiLibraryNametruncateTo: grid  ^Rectangle origin: (origin truncateTo: grid) corner: (corner truncateTo: grid)testReplaceFromToWithStartingAt  | lpi20 lpi7 |  lpi20 := LargePositiveInteger new: 20.  1 to: 20 do: [:i |  lpi20 byteAt: i put: i ].  lpi7 := LargePositiveInteger new: 7.  1 to: 7 do: [:i |  lpi7 byteAt: i put: 11 - i ].  lpi20 replaceFrom: 6 to: 10 with: lpi7 startingAt: 2.  (1 to: 5) , (11 to: 20) do: [:e |  | digit |        digit := lpi20 byteAt: e.        self assert: e equals: digit ].  6 to: 10 do: [:e |  | digit replacementDigit |        digit := lpi20 byteAt: e.        replacementDigit := lpi7 byteAt: e - 4.        self assert: replacementDigit equals: digit ]name  ^namewaitFor: aSymbolOrNil  ^self waitFor: aSymbolOrNil maxMilliseconds: nilgtSpotterCodePreviewIn: aComposite  < spotterPreview: 10>  ^self sourceNode gtSpotterCodePreviewIn: aCompositelog: aString  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver log: `@statements1' -> '`@receiver trace: `@statements1'.  self trace: aStringtestAsMilliSecond  self     assert: 1 milliSecond equals: (1 / 1000) second;     assert: (1 / 2) milliSecond equals: (1 / 2000) second;     assert: 0.5 milliSecond equals: (1 / 2000) second;     assert: 500 milliSecond equals: (1 / 2) secondweekday  ^self dayOfWeekNamestonOn: stonWriter  | representation |  representation := self offset isZero ifTrue: [ String new: 11 streamContents: [:out |  self printOn: out format: #(3 2 1 $- 1 1 2).              out nextPut: $Z ] ] ifFalse: [ String new: 32 streamContents: [:out |  self printOn: out format: #(3 2 1 $- 1 1 2).              out nextPut: (self offset positive ifTrue: [ $+ ] ifFalse: [ $- ]).              self offset hours abs printOn: out base: 10 length: 2 padded: true.              out nextPut: $:.              self offset minutes abs printOn: out base: 10 length: 2 padded: true.              self offset seconds = 0 ifFalse: [ out                       nextPut: $:;                       print: self offset seconds abs truncated ] ] ].  stonWriter writeObject: self listSingleton: representationtestTimeZone  self assert: aDateAndTime timeZoneName equals: 'Universal Time'.  self assert: aDateAndTime timeZoneAbbreviation equals: 'UTC'weakSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat  ^self weakSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: catargumentCount  ^numArgsreceiver  ^self signalerContext receiverabs  ^self class seconds: seconds abs nanoSeconds: nanos absasKeyCombination  | lowerCaseCombination |  self asLowercase = self ifTrue: [ ^KMSingleKeyCombination from: self ].  lowerCaseCombination := KMSingleKeyCombination from: self asLowercase.  ^KMModifiedKeyCombination modifier: KMModifier shift character: lowerCaseCombinationcallChainAnySatisfy: aBlock  (aBlock value: self) ifTrue: [ ^true ].  self sender ifNil: [ ^false ].  ^self sender callChainAnySatisfy: aBlockwriteSlotNamed: aName value: anObject  ^(self class slotNamed: aName) write: anObject to: selfsetProject: aString withInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setProject: aString withBlock: selfisClean  self numCopiedValues > 0 ifTrue: [ ^false ].  self abstractBytecodeMessagesDo: [:msg |  (#(pushReceiver pushReceiverVariable: popIntoReceiverVariable: storeIntoReceiverVariable: methodReturnConstant: methodReturnReceiver methodReturnTop) includes: msg selector) ifTrue: [ ^false ] ].  ^trueremove: aProcess ifAbsent: aBlock  (quiescentProcessLists at: aProcess priority) remove: aProcess ifAbsent: aBlock.  ^aProcessselectorsToBeIgnored  | private |  private := #(#printOn:).  ^super selectorsToBeIgnored , privatetestEnumerating  | days |  days := OrderedCollection new.  0 to: 6 do: [:i |  days add: ('28 June 1998' asDate addDays: i) ].  week datesDo: [:d |  days remove: d ].  self assertEmpty: days< aNumber  aNumber class = self class ifTrue: [ ^self asFraction < aNumber asFraction ].  ^self asFraction < aNumbersubclass: subclassName uses: aTraitComposition layout: aLayout slots: someSlots classVariablesNames: someClassVariablesNames poolDictionaries: somePoolDictionaries category: aCategory  ^self classInstaller make: [:builder |  builder           name: subclassName;           superclass: self;           slots: someSlots;           layoutClass: aLayout;           sharedVariablesFromString: someClassVariablesNames;           sharedPools: somePoolDictionaries;           traitComposition: aTraitComposition asTraitComposition;           classTraitComposition: aTraitComposition asTraitComposition classComposition;           category: aCategory ]checkCorrespondanceOf: aSelector and: aCategoryTag  | cat methodAnswer catFromTable |  cat := Unicode classPool at: aCategoryTag.  self aRandomSelectionOfCodePointsDo: [:cp |  methodAnswer := Unicode perform: aSelector with: (Character codePoint: cp).        catFromTable := self unicodeCategoryTableLookup: cp.        methodAnswer = (catFromTable = cat) ifFalse: [ self assert: methodAnswer = (catFromTable = cat) description: aSelector asString , 'and category ' , aCategoryTag asString , 'disagree at U+' , cp asHexString ] ]testAsNumberWithRadix  | sd |  sd := '10r-22.2s5' asNumber.  self assert: ScaledDecimal identicalTo: sd class.  self assert: sd scale equals: 5.  self assert: '-22.20000s5' equals: sd printStringprintOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: self abbreviation;     nextPut: $)includesMethodsAffectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsMethodsDefinedInClass: selftestEqual  self assert: january23rd2004 equals: 'January 23, 2004' asDateeightNeighbors  ^{(self + (1 @ 0)) .   (self + (1 @ 1)) .   (self + (0 @ 1)) .   (self + (-1 @ 1)) .   (self + (-1 @ 0)) .   (self + (-1 @ -1)) .   (self + (0 @ -1)) .   (self + (1 @ -1))}milliseconds  ^self milliSecondstestMinus  self assert: aDateAndTime - aDateAndTime equals: '0:00:00:00' asDuration.  self assert: aDateAndTime - '0:00:00:00' asDuration equals: aDateAndTime.  self assert: aDateAndTime - aDuration equals: (DateAndTime year: 1969 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours)isMeta  ^falsetemporaryVariables  ^self tempNames collect: [:name |  TemporaryVariable new name: name ]nthRootRounded: aPositiveInteger  | guess |  self = 0 ifTrue: [ ^0 ].  self negative ifTrue: [ aPositiveInteger even ifTrue: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ].        ^(self negated nthRootRounded: aPositiveInteger) negated ].  guess := self nthRootTruncated: aPositiveInteger.  ^self * 2 > ((guess + 1 raisedTo: aPositiveInteger) + (guess raisedTo: aPositiveInteger)) ifTrue: [ guess + 1 ] ifFalse: [ guess ]asJavascript  ^String streamContents: [:stream |  self javascriptOn: stream ]deprecated: anExplanationString on: date in: version transformWith: aRule  Deprecation new     context: thisContext sender;     explanation: anExplanationString;     date: date;     version: version;     rule: aRule;     transformtestFractionPart  self     assert: 2 fractionPart equals: 0;     assert: (1 / 2) fractionPart equals: 1 / 2;     assert: (4 / 3) fractionPart equals: 1 / 3;     assert: 2.0 fractionPart equals: 0.0;     assert: 0.5 fractionPart equals: 0.5;     assert: 2.5 fractionPart equals: 0.5testIsInstanceSide  self assert: Point isInstanceSide.  self deny: Point class isInstanceSidetestNew  self should: [ SmallInteger new ] raise: self defaultTestErrornextPc: currentByte  ^pc + (self method encoderClass bytecodeSize: currentByte)banLevelCandidates  ^{self} , self package banLevelCandidatesisThisEverCalled: msg  self error: 'This is indeed called: ' , msg printStringtestOnForkErrorReturnsNil  | result sema |  sema := Semaphore new.  result := [ 1 / 0 ] on: Exception fork: [ sema signal ].  sema wait.  self assert: result isNilassertWellMaterializedInto: aBlockClosure in: aTestCase  aTestCase assert: self ~~ aBlockClosure.  aTestCase assert: self class == aBlockClosure class.  aTestCase assert: numArgs = aBlockClosure numArgs.  aTestCase assert: startpc = aBlockClosure startpc.  outerContext ifNil: [ self assert: aBlockClosure outerContext isNil ] ifNotNil: [ self isClean ifTrue: [ self assert: (self method isEqualRegardlessTrailerTo: aBlockClosure method).              self assert: aBlockClosure outerContext sender isNil.              self assert: aBlockClosure outerContext arguments isEmpty ] ifFalse: [ outerContext assertWellMaterializedInto: aBlockClosure outerContext in: aTestCase ] ]method: aCompiledMethod  method := aCompiledMethodexecutedPC  | executedPC |  self isDead ifTrue: [ ^self startpc ].  executedPC := self previousPc ifNil: [ self startpc ].  (self isReturnAt: executedPC) ifTrue: [ executedPC := executedPC + 1 ].  [ self isPushLiteralNil: executedPC ] whileTrue: [ executedPC := executedPC + 1 ].  [ self isPushTemp: executedPC ] whileTrue: [ executedPC := executedPC + 1 ].  (self isReturnAt: executedPC) ifTrue: [ executedPC := executedPC + 1 ].  ^executedPChasContext: aContext  ^(self findContextSuchThat: [:context |  context == aContext ]) notNilbenchFor: duration  | count run started |  count := 0.  run := true.  [ duration wait.  run := false ] forkAt: Processor timingPriority - 1.  started := Time millisecondClockValue.  [ run ] whileTrue: [ self value.        count := count + 1 ].  ^BenchmarkResult new     iterations: count;     elapsedTime: (Time millisecondsSince: started) milliSeconds;     yourselfgtInspectorActionSpot  < gtInspectorAction>  ^GLMGenericAction new     action: [ GTSpotterMorph new           extent: ((self currentWorld width / 2.4) @ (self currentWorld height / 1.6)) asIntegerPoint;           doLayout;           spotterModel: (GTSpotter on: self);           openCenteredInWorld ];     icon: GLMUIThemeExtraIcons glamorousSearch;     condition: [ | fakeStep |        fakeStep := GTSpotter new newStep origin: self.        self spotterProcessorsFor: fakeStep.        fakeStep processors notEmpty ];     title: 'Search'testDateTime  self assert: aDateAndTime equals: (DateAndTime date: '01-01-1901' asDate time: '00:00:00' asTime)<= aNumber  < primitive: 545>  ^aNumber adaptToFloat: self andCompare: #<=signal: aSymbolOrNil  | queue |  self checkOwnerProcess.  queue := self queueFor: aSymbolOrNil.  queue isEmpty ifTrue: [ queue := self defaultQueue ].  self signalQueue: queuelink: aMetaLink toClassVariable: aClassVariable  aClassVariable link: aMetaLinkgenPushInstVar: instVarIndex  instVarIndex >= 0 ifTrue: [ instVarIndex < 16 ifTrue: [ stream nextPut: 0 + instVarIndex.              ^self ].        instVarIndex < 64 ifTrue: [ stream                 nextPut: 128;                 nextPut: instVarIndex.              ^self ] ].  self genPushInstVarLong: instVarIndextransferFor: passenger from: aMorph  ^TransferMorph withPassenger: passenger from: aMorphlog  ^self asFloat logtestHighBit  | suite |  self assert: 2r1110 highBit equals: 4.  self assert: 2r0110 highBit equals: 3.  self assert: 2r0000 highBit equals: 0.  suite := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA) , {SmallInteger maxVal .         (SmallInteger maxVal + 1)}.  suite := suite , (suite collect: [:e |  e raisedTo: 20 ]).  suite do: [:anInteger |  | highBit shifted |        highBit := 0.        shifted := 1.        [ shifted > anInteger ] whileFalse: [ highBit := highBit + 1.              shifted := shifted bitShift: 1 ].        self assert: anInteger highBit equals: highBit ]testIfFalseIfTrue  self assert: (true ifFalse: [ 'falseAlternativeBlock' ] ifTrue: [ 'trueAlternativeBlock' ]) equals: 'trueAlternativeBlock'var10: anObject  var10 := anObjectasSortFunction  self numArgs = 1 ifTrue: [ ^PropertySortFunction property: self ].  self numArgs = 2 ifTrue: [ ^CollatorBlockFunction usingBlock: self ].  self error: 'Cant be converted to sort function. It should has one or two args'copyStack  ^self copy install: suspendedContext copyStackdebug  Processor activeProcess debug: self signalerContext title: self smartDescriptionpenultimateLiteral: anObject  | pIndex |  (pIndex := self numLiterals - 1) > 0 ifTrue: [ self literalAt: pIndex put: anObject ] ifFalse: [ self error: 'insufficient literals' ]testDoWithWhen  | count |  count := 0.  aTimespan do: [:each |  count := count + 1 ] with: (Timespan starting: aDate duration: 7 days) when: [:each |  count < 5 ].  self assert: count equals: 5pointsTo: anObject  ^falsedays  ^Duration days: selflastLink  self emptyCheck.  ^lastLinkgtInspectorCommentIn: composite  < gtInspectorPresentationOrder: 20>  composite text     title: 'Comment';     display: [ self comment ];     act: [:text |  self comment: text text stamp: Author changeStamp ] icon: GLMUIThemeExtraIcons glamorousAccept on: $s entitled: 'Accept'seasidePossibleCauses  ^#()testString  ^'This is only a test.'schedulerSignalWaitingProcess  beingWaitedOn := false.  monitor signalLock: delaySemaphore inQueue: queuestonContainSubObjects  ^falsetestIsSurrogateOther  self checkCorrespondanceOf: #isSurrogateOther: and: #CstestPointersToCycle  | myObject myArray myArray2 pointingObjects |  myObject := Object new.  myArray := {myObject .   myObject}.  myArray2 := {myObject .   myArray}.  pointingObjects := myObject pointersTo asArray.  self assert: pointingObjects size equals: 2.  self assert: (pointingObjects includesAll: {myArray .               myArray2})bitAnd: arg  < primitive: 14>  self >= 0 ifTrue: [ ^arg bitAnd: self ].  ^(self bitInvert bitOr: arg bitInvert) bitInvertdoublePassOuterTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselfputSource: sourceStr class: class category: catName withStamp: changeStamp priorMethod: priorMethod  ^self putSource: sourceStr withPreamble: [:file |  class printCategoryChunk: catName on: file withStamp: changeStamp priorMethod: priorMethod.        file cr ]isMetaclassOfClassOrNil  ^self instanceSide ifNil: [ true ] ifNotNil: [:nonMetaClass |  nonMetaClass == Class ]systemNavigation  ^SystemNavigation newasDate  ^selfcompressSourceCode: aString  | temp |  self clear.  kind := #EmbeddedSourceQCompress.  data := aString asString.  self encode.  temp := encodedData.  kind := #EmbeddedSourceZip.  self encode.  encodedData size > temp size ifTrue: [ encodedData := temp.        kind := #EmbeddedSourceQCompress.        size := encodedData size ]testFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1901-01-01T00:00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1901-01-01T00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00')deprecatedMethodName  ^self contextOfDeprecatedMethod method printStringfileOutMethod: selector  | internalStream |  internalStream := (String new: 1000) writeStream.  self fileOutMethod: selector on: internalStream.  CodeExporter writeSourceCodeFrom: internalStream baseName: self name , '-' , (selector copyReplaceAll: ':' with: '') isSt: truepragmas  | selectorOrProperties |  ^(selectorOrProperties := self penultimateLiteral) isMethodProperties ifTrue: [ selectorOrProperties pragmas ] ifFalse: [ #() ]testAsTime  self assert: aDateAndTime asTime equals: Time midnightprimitiveResume  < primitive: 87>  self primitiveFailedtearDown  Week startDay: restoredStartDay.  week := nil.  super tearDownhasSelector: selector specialSelectorIndex: specialOrNil  (self hasLiteralThorough: selector) ifTrue: [ ^true ].  ^specialOrNil ifNil: [ false ] ifNotNil: [ self scanFor: self encoderClass firstSpecialSelectorByte + specialOrNil ]hour  ^self hourstestSizeInMemoryNormalClasses  self assert: Date today sizeInMemory equals: (self align64Bits: 2 * Smalltalk wordSize + self headerSize).  self assert: TestCase new sizeInMemory equals: (self align64Bits: 2 * Smalltalk wordSize + self headerSize)parseTreeFor: aSymbol  ^(self compiledMethodAt: aSymbol) parseTreetestFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1970-01-01T00:00:00+00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1970-01-01T00:00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1970-01-01T00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1970-01-01T00:00:00+00:00')bitAt: anInteger put: value  | b |  b := self bitAt: anInteger.  b = value ifTrue: [ ^self ].  0 = value ifTrue: [ ^self bitAnd: (1 bitShift: anInteger - 1) bitInvert ].  1 = value ifTrue: [ ^self bitOr: (1 bitShift: anInteger - 1) ].  self error: 'bit value should be 0 or 1'< aMagnitude  ^self subclassResponsibilitytestNoArguments  | m |  m := WeakMessageSend receiver: true selector: #yourself.  self assert: m valueprintOn: outputStream base: baseInteger showRadix: flagBoolean  | tempString startPos |  tempString := self printStringRadix: baseInteger.  flagBoolean ifTrue: [ ^outputStream nextPutAll: tempString ].  startPos := (tempString indexOf: $r ifAbsent: [ self error: 'radix indicator not found.' ]) + 1.  self negative ifTrue: [ outputStream nextPut: $- ].  outputStream nextPutAll: (tempString copyFrom: startPos to: tempString size)floor  isUsed  ^self hasSubclasses ifFalse: [ super isUsed ] ifTrue: [ true ]testOrdersMetaClassAfterItsClassInstance  | ordered |  ordered := Class superclassOrder: (OrderedCollection with: Boolean class with: True with: Boolean with: True class).  self assert: (ordered indexOf: Boolean) < (ordered indexOf: Boolean class).  self assert: (ordered indexOf: True) < (ordered indexOf: True class).  self assert: (ordered indexOf: Boolean class) < (ordered indexOf: True class).  self assert: (ordered indexOf: Boolean) < (ordered indexOf: True)testReadSlot  self assert: (5 @ 3 readSlot: (Point slotNamed: #x)) equals: 5jump  | top |  thisContext sender push: nil.  stackp = 0 ifTrue: [ self stepUntilSomethingOnStack ].  stackp = 0 ifTrue: [ self push: nil ].  top := self pop.  thisContext privSender: self.  ^topsourcePointer: ptr  self clear.  data := ptr.  kind := (ptr between: 16r1000000 and: 16r4FFFFFF) ifTrue: [ #SourcePointer ] ifFalse: [ #VarLengthSourcePointer ]bench: aDelaySchedulerClass  | schedulerClassToRestore |  self assert: (aDelaySchedulerClass inheritsFrom: DelayNullScheduler).  schedulerClassToRestore := Delay delaySchedulerClass.  [ Delay delaySchedulerClass: aDelaySchedulerClass.  self bench ] ensure: [ Delay delaySchedulerClass: schedulerClassToRestore ]testSubclassArithmetic  | timespans |  timespans := {Year currentYear .   Month current .   (Week starting: DateAndTime now) .   Date today .   (Timespan starting: DateAndTime now duration: 1 hour)}.  timespans do: [:ts |  self assert: ts + aDay - ts equals: aDay.        self assert: ts - aDay - ts equals: aDay negated.        timespans do: [:otherTs |  self assert: (ts intersection: otherTs) equals: (otherTs intersection: ts) ] ].  self assert: (timespans first intersection: timespans second) equals: timespans second.  self assert: (timespans first intersection: timespans fourth) equals: timespans fourth.  self assert: (timespans second intersection: timespans fourth) equals: timespans fourthisPrimitiveError  ^falsetestAsTime  self assert: aTime asTime equals: aTimetestRuleDoesNotFailIfNoNewExternalDependency  | rule critiques |  rule := PharoBootstrapRule new.  rule class classVarNamed: 'DependencyChecker' put: PharoBootstrapAnalyzerStubWithNoNewDependency.  critiques := rule check: (RPackage named: #Kernel).  self assertEmpty: critiquestestAsDate  self assert: aTime asDate equals: Date currentstoreOn: aStream  aStream     nextPut: $(;     nextPutAll: self class name;     nextPutAll: ' selector: ';     store: selector;     nextPutAll: ' arguments: ';     store: args;     nextPut: $)willJump  ^self method encoderClass isJumpAt: pc in: self methodhandleFailingBasicNew  < primitive: 70>  Smalltalk garbageCollect < 1048576 ifTrue: [ Smalltalk growMemoryByAtLeast: 1048576 ].  ^self handleFailingFailingBasicNewremoveKey: key ifAbsent: errorBlock  | copy removedValue |  copy := self copy.  removedValue := copy removeDangerouslyKey: key ifAbsent: [ ^errorBlock value ].  self copyFrom: copy.  key flushCache.  ^removedValuetestIncludesKey  self assert: (ChronologyConstants includesKey: #DayNames).  self deny: (ChronologyConstants includesKey: #DependentsFields)waitForUserSignalled: timingSemaphore orExpired: activeDelay  self subclassResponsibility/ anInteger  < primitive: 30>  ^super / anIntegerslidingLeftRightRaisedTo: n modulo: m  | pow j k w index oddPowersOfSelf square |  k := n highBit.  w := (k highBit - 1 >> 1 min: 16) max: 1.  oddPowersOfSelf := Array new: 1 << w.  oddPowersOfSelf at: 1 put: (pow := self).  square := self * self \\ m.  2 to: oddPowersOfSelf size do: [:i |  pow := oddPowersOfSelf at: i put: pow * square \\ m ].  pow := 1.  [ k > 0 ] whileTrue: [ pow := pow * pow \\ m.        (n bitAt: k) = 0 ifFalse: [ j := k - w max: 1.              [ j < k and: [ (n bitAt: j) = 0 ] ] whileTrue: [ j := j + 1 ].              index := 0.              [ k > j ] whileTrue: [ pow := pow * pow \\ m.                    index := (index << 1) + (n bitAt: k).                    k := k - 1 ].              pow := pow * (oddPowersOfSelf at: index + 1) \\ m ].        k := k - 1 ].  ^powprintShowingDecimalPlaces: placesDesired  ^self asTrueFraction printShowingDecimalPlaces: placesDesiredallMethodSelectors  ^elementArray sortedclassForTicker  ^DelayMillisecondTickerSimulationnewValue: anObject  newValue := anObjectisInheritable  ^self class isInheritabletestSignalFromHandlerActionTest  self assertSuccess: (ExceptionTester new runTest: #signalFromHandlerActionTest)crossProduct: aPoint  ^x * aPoint y - (y * aPoint x)immediateSubclass: aClassName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self immediateSubclass: aClassName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: cattestRaisedToInteger  self     assert: (2 raisedToInteger: 0) equals: 1;     assert: (2 raisedToInteger: 1) equals: 2;     assert: (2 raisedToInteger: 4) equals: 16;     assert: (0 raisedToInteger: 0) equals: 1;     assert: (0 raisedToInteger: 2) equals: 0;     assert: (2 raisedToInteger: -1) equals: 1 / 2;     assert: (2 raisedToInteger: -4) equals: 1 / 16.  self     assert: (-3 raisedTo: 0) equals: 1;     assert: (-3 raisedTo: 1) equals: -3;     assert: (-3 raisedTo: 2) equals: 9;     assert: (-3 raisedTo: 3) equals: -27;     assert: (-3 raisedTo: -2) equals: 1 / 9;     assert: (-3 raisedTo: -3) equals: -1 / 27.  self should: [ 0 raisedTo: -1 ] raise: ZeroDividetestAllSelectorsAboveUntil  | sels |  sels := Date allSelectorsAboveUntil: Object.  self deny: (sels includes: #mmddyyyy).  self deny: (sels includes: #weekday).  self assert: (sels includes: #at:).  self deny: (sels includes: #cannotInterpret:)setDescriptionInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setDescriptionWithBlock: selfpropertyAt: aString ifAbsent: aFullBlockClosure  ^aFullBlockClosure valueisBits  ^self instSpec >= 7testWholeMicroseconds  self assert: 0 seconds wholeMicroseconds equals: 0.  self assert: 1 second wholeMicroseconds equals: 0.  self assert: 1002003004 nanoSeconds wholeMicroseconds equals: 3addMonths: monthCount  | year month maxDaysInMonth day |  year := self year + ((monthCount + self monthIndex - 1) // 12).  month := (self monthIndex + monthCount - 1) \\ 12 + 1.  maxDaysInMonth := Month daysInMonth: month forYear: year.  day := self dayOfMonth min: maxDaysInMonth.  ^Date year: year month: month day: daytestMinusADateAndTime  self assert: aTimespan - dec31 equals: aDay.  self assert: aDisjointTimespan - jan01 equals: aWeeksharedPoolNames  ^self sharedPools collect: [:ea |  ea isObsolete ifTrue: [ ea name ] ifFalse: [ self environment keyAtIdentityValue: ea ] ]onPreviousMonth  ^self addMonths: -1containsHalt  ^self sendsAnySelectorOf: #(halt halt: haltIf: haltIfNil haltOnCount: haltOnce)pushActiveProcess  self push: Processor activeProcesstestAsMinute  | full half quarter |  full := Duration seconds: 60.  half := Duration seconds: 30.  quarter := Duration seconds: 15.  self     assert: 1 minute equals: full;     assert: 1.0 minute equals: full;     assert: 0.5 minute equals: half;     assert: (1 / 2) minute equals: half;     assert: (1 / 4) minute equals: quarter.  self assert: 0.4 minute + 0.6 minute equals: 1 minutetestDayOfWeek  | dayNames sundayIndex |  sundayIndex := self dateClass dayOfWeek: #Sunday.  self assert: sundayIndex equals: 1.  dayNames := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).  dayNames doWithIndex: [:e :i |  | dayIndex |        dayIndex := self dateClass dayOfWeek: e.        self assert: dayIndex equals: i ]testDaysInMonth  self assert: aTimespan daysInMonth equals: 31add: link before: otherLinkOrObject  | otherLink |  otherLink := self linkAt: (self indexOf: otherLinkOrObject).  ^self add: link beforeLink: otherLinktearDown  PharoBootstrapRule classVarNamed: 'DependencyChecker' put: checkerBackup.  super tearDowngtInspectorBytesIn: composite  < gtInspectorPresentationOrder: 30>  isSpecial  ^self class specialCharacters includes: selftestDayOfYear  self assert: aTimespan dayOfYear equals: 1shallowCopy  ^selfasDuration  ^Duration seconds: self asIntegerclassToBeTested  ^DateAndTime<= aNumber  aNumber isFraction ifTrue: [ ^numerator * aNumber denominator <= (aNumber numerator * denominator) ].  ^aNumber adaptToFraction: self andCompare: #<=perform: aSymbol with: firstObject with: secondObject  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)testReadFromSpaceBeforeOffset  self assert: '2012-07-26 16:38:48 +0200' asDateAndTime offset equals: 2 hour.  self assert: '2012-07-26 16:38:48 +02' asDateAndTime offset equals: 2 hourbeReadOnlyObject  ^self setIsReadOnlyObject: trueisSpecialLiteralForPush: literal  ^literal == false or: [ literal == true or: [ literal == nil or: [ (literal isInteger and: [ literal between: -32768 and: 32767 ]) or: [ literal isCharacter and: [ literal asInteger between: 0 and: 65535 ] ] ] ] ]treeNodeTail  ^nilcontrol  ^KMModifier ctrl + selfallAreasOutsideList: aCollection startingAt: startIndex do: aBlock  | yOrigin yCorner aRectangle index rr |  index := startIndex.  [ index <= aCollection size ifFalse: [ ^aBlock value: self ].  aRectangle := aCollection at: index.  origin <= aRectangle corner and: [ aRectangle origin <= corner ] ] whileFalse: [ index := index + 1 ].  aRectangle origin y > origin y ifTrue: [ rr := origin corner: corner x @ (yOrigin := aRectangle origin y).        rr allAreasOutsideList: aCollection startingAt: index + 1 do: aBlock ] ifFalse: [ yOrigin := origin y ].  aRectangle corner y < corner y ifTrue: [ rr := origin x @ (yCorner := aRectangle corner y) corner: corner.        rr allAreasOutsideList: aCollection startingAt: index + 1 do: aBlock ] ifFalse: [ yCorner := corner y ].  aRectangle origin x > origin x ifTrue: [ rr := origin x @ yOrigin corner: aRectangle origin x @ yCorner.        rr allAreasOutsideList: aCollection startingAt: index + 1 do: aBlock ].  aRectangle corner x < corner x ifTrue: [ rr := aRectangle corner x @ yOrigin corner: corner x @ yCorner.        rr allAreasOutsideList: aCollection startingAt: index + 1 do: aBlock ]metaLinkOptions  ^{(#penultimateLiteral -> #(+ optionCompileOnLinkInstallation)) .   (#selector -> #(+ optionCompileOnLinkInstallation)) .   (#objectAt: -> #(+ optionCompileOnLinkInstallation)) .   (#header -> #(+ optionCompileOnLinkInstallation)) .   (#numLiterals -> #(+ optionCompileOnLinkInstallation)) .   (#literalAt: -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}testSetIsReadOnlySuccessProxy  self maybeReadOnlyObjects do: [:each |  self testProxyObject: each initialState: false tuples: #(#(true false true) #(false true false)) ]numCopiedValues  < primitive: 62>  ^self basicSizeat: index  < primitive: 210>  index isInteger ifTrue: [ self errorSubscriptBounds: index ].  index isNumber ifTrue: [ ^self at: index asInteger ] ifFalse: [ self errorNonIntegerIndex ]defaultAction  UnhandledError signalForException: selftestDaysInMonth  self assert: aDateAndTime daysInMonth equals: 31wantsVisualFeedback  ^true- arg  arg isPoint ifTrue: [ ^(x - arg x) @ (y - arg y) ].  ^arg adaptToPoint: self andSend: #-methodsWritingSlot: aSlot  ^self methods select: [:method |  method writesSlot: aSlot ]asMargin  ^Margin fromPoint: selfdoSomething  self log: self doSomethingStringtestNew  | instance epoch |  instance := self dateClass new.  epoch := self epoch.  instance offset negative ifTrue: [ epoch := epoch - 1 day ].  self assert: instance equals: epochprintDetails: stream  | errorMessage string |  self printOn: stream.  stream cr.  stream     tab;     nextPutAll: 'Receiver: '.  errorMessage := '<<error during printing>>'.  stream nextPutAll: ([ receiver printStringLimitedTo: 90 ] ifError: [ errorMessage ]).  stream     cr;     tab;     nextPutAll: 'Arguments and temporary variables: ';     cr.  string := [ (self tempsAndValuesLimitedTo: 80 indent: 2) padRightTo: 1 with: $x ] ifError: [ errorMessage ].  stream nextPutAll: string allButLast.  stream     cr;     tab;     nextPutAll: 'Receiver''s instance variables: ';     cr.  receiver class allInstVarNames isEmpty ifTrue: [ stream nextPutAll: ([ receiver printStringLimitedTo: 90 ] ifError: [ errorMessage ]) ] ifFalse: [ [ receiver longPrintOn: stream limitedTo: 80 indent: 2 ] ifError: [ stream nextPutAll: errorMessage ] ].  stream crisCharacter  ^trueaddInstVarNamed: aString  aString substrings do: [:each |  self addSlot: (InstanceVariableSlot named: each asSymbol) ]testRaisedTo  self should: [ -1.23 raisedTo: 1 / 4 ] raise: ArithmeticErrorsmartDescription  message ifNil: [ ^self description ].  message lookupClass == UndefinedObject ifTrue: [ ^message selector printString , ' was sent to nil' ].  ^'Instance of ' , message lookupClass printString , ' did not understand ' , message selector printStringtestBehaviornewnewShouldNotCrash  Behavior new newgtInspectorDetailsIn: composite  < gtInspectorPresentationOrder: 30>  ^composite table     title: 'Details';     display: [ {('iso' -> self printString) .         ('utc' -> self asUTC) .         ('year' -> self year) .         ('month' -> self monthIndex) .         ('month name' -> self monthName) .         ('day of month' -> self dayOfMonth) .         ('day of week' -> self dayOfWeekName) .         ('day of year' -> self dayOfYear) .         ('hours' -> self hours) .         ('minutes' -> self minutes) .         ('seconds' -> self seconds) .         ('nanoseconds' -> self nanoSecond) .         ('meridian' -> self meridianAbbreviation) .         ('offset' -> self offset) .         ('date' -> self asDate) .         ('time' -> self asTime)} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valueprivHandlerContext: aContextTag  handlerContext := aContextTagfindNextHandlerOrSignalingContext  < primitive: 197>  | context |  context := self.  [ context isHandlerOrSignalingContext ifTrue: [ ^context ].  (context := context sender) == nil ] whileFalse.  ^niltestSqrt  self should: [ (SmallInteger minVal - 1) sqrt ] raise: DomainErrorvalueWithEnoughArguments: anArray  | args strongReceiver |  strongReceiver := self receiver.  (self ensureReceiverAndArguments: strongReceiver) ifFalse: [ ^nil ].  args := Array new: selector numArgs.  args replaceFrom: 1 to: (arguments size min: args size) with: arguments startingAt: 1.  args size > arguments size ifTrue: [ args replaceFrom: arguments size + 1 to: (arguments size + anArray size min: args size) with: anArray startingAt: 1 ].  ^strongReceiver perform: selector withArguments: argstempNamed: aName  | scope var |  scope := self sourceNodeExecuted scope.  var := scope lookupVar: aName.  ^var readFromContext: self scope: scopetemporaryVariableNamed: aName  (self hasTemporaryVariableNamed: aName) ifFalse: [ ^nil ].  ^TemporaryVariable name: aName method: selfdepthBelow: aContext  | context depth |  context := self.  depth := 0.  [ context == aContext or: [ context == nil ] ] whileFalse: [ context := context sender.        depth := depth + 1 ].  ^depthtestTwoComplementRightShift  | large small |  small := 2 << 16.  large := 2 << 32.  self assert: (small negated bitShift: -1) ~= ((small + 1) negated bitShift: -1) identicalTo: (large negated bitShift: -1) ~= ((large + 1) negated bitShift: -1).  self assert: (small bitShift: -1) ~= (small + 1 bitShift: -1) identicalTo: (large bitShift: -1) ~= (large + 1 bitShift: -1)allClassVarNames  ^self superclass ifNil: [ self classVarNames ] ifNotNil: [:sup |  sup allClassVarNames , self classVarNames ]firstDayOfMonth  ^start firstDayOfMonthshallowCopy  ^selfcopyAll: selArray from: class  self copyAll: selArray from: class classified: niljsonOn: aRenderer  aRenderer number: selfouterContext  ^closureOrNil ifNotNil: [ closureOrNil outerContext ]from: start  from := startabs  ^self negatedhaltFromCount: anInteger  < debuggerCompleteToSender>  Halt fromCount: anIntegerrelease  self releaseTo: nilembeddSourceInTrailer  self trailer hasSourcePointer ifTrue: [ ^self becomeForward: (self copyWithSource: self sourceCode) ]ifFalse: alternativeBlock  ^nilforkAt: priority named: name  | forkedProcess |  forkedProcess := self newProcess.  forkedProcess priority: priority.  forkedProcess name: name.  ^forkedProcess resumeto: anEnd  ^self asDateAndTime to: anEndisColorForm  ^falsemethodNamed: aSelector  ^self methodDict at: aSelectortestAsNumberNegatedWithoutDecimalPoint2  | sd |  sd := '-123s2' asNumber.  self assert: ScaledDecimal identicalTo: sd class.  self assert: sd scale equals: 2.  self assert: '-123.00s2' equals: sd printStringasMinimalRepresentation  ^selfprintBinaryLiteralOn: stream  | signBit exponentBits fractionBits |  signBit := (self basicAt: 1) bitShift: -31.  exponentBits := ((self basicAt: 1) bitShift: -20) bitAnd: 2r11111111111.  fractionBits := (((self basicAt: 1) bitAnd: 2r11111111111111111111) bitShift: 32) bitOr: (self basicAt: 2).  exponentBits = 2047 ifTrue: [ fractionBits = 0 ifTrue: [ stream nextPutAll: 'Float infinity'.              signBit = 1 ifTrue: [ stream nextPutAll: ' negated' ] ] ifFalse: [ stream nextPutAll: 'Float nan' ].        ^self ].  signBit = 1 ifTrue: [ stream nextPut: $- ].  exponentBits = 0 ifTrue: [ fractionBits = 0 ifTrue: [ stream nextPutAll: '0.0' ] ifFalse: [ stream nextPutAll: '2r0.'.              fractionBits printOn: stream base: 2 length: Float precision - 1 padded: true.              stream nextPutAll: 'e-1022' ].        ^self ].  stream nextPutAll: '2r1.'.  fractionBits printOn: stream base: 2 length: Float precision - 1 padded: true.  stream nextPut: $e.  exponentBits - 1023 printOn: stream base: 10deprecatedMethod2  self deprecated: 'example of a deprecated method' on: 'date' in: 'someversion'sendsToSuper  self localSendsToSuper ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:cb |  cb sendsToSuper ]testAsYear  self assert: aDateAndTime asYear equals: (Year starting: '01-01-1901' asDate)priority  ^prioritygtInspectorHash  ^self identityHashclassToBeTested  ^YeartestdaysInMonth  self assert: ((Year year: 2018) daysInMonth: 1) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 2) equals: 28.  self assert: ((Year year: 2016) daysInMonth: 2) equals: 29.  self assert: ((Year year: 2018) daysInMonth: 3) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 4) equals: 30.  self assert: ((Year year: 2018) daysInMonth: 5) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 6) equals: 30.  self assert: ((Year year: 2018) daysInMonth: 7) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 8) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 9) equals: 30.  self assert: ((Year year: 2018) daysInMonth: 10) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 11) equals: 30.  self assert: ((Year year: 2018) daysInMonth: 12) equals: 31add: anException  ^exceptions add: anExceptionprimSignal: sempahore atMilliseconds: nextTick  (sempahore isKindOf: Semaphore) ifTrue: [ vmSimTheTimerSemaphore := sempahore.        vmSimNextWakeupTick := nextTick ].  sempahore = nil ifTrue: [ vmSimTheTimerSemaphore := nil.        vmSimNextWakeupTick := 0 ]testSetIsReadOnlyImmediateProxy  self alwaysReadOnlyObjects do: [:each |  self testProxyObject: each initialState: true tuples: #(#(true true true) #(false true true)) ]setSelector: aSymbol arguments: anArray  selector := aSymbol.  args := anArrayshortPrintString  self isEmpty ifTrue: [ ^self printString ].  ^String streamContents: [:out |  self printFrequenceOn: out ]startTimerEventLoop  isDisabledSelector: selector  ^self classAndMethodFor: selector do: [:c :m |  m isDisabled ] ifAbsent: [ false ]fractionPart  < primitive: 552>  ^self - self truncated asFloatisTestCase  ^falsemethod: aMethod  | flagByte |  data := size := nil.  method := aMethod.  flagByte := method at: method size.  kind := self class trailerKinds at: 1 + (flagByte >> 2).  kind == #SourcePointer ifTrue: [ ^self decodeSourcePointer ].  kind == #VarLengthSourcePointer ifTrue: [ ^self decodeVarLengthSourcePointer ].  kind == #EmbeddedSource ifTrue: [ ^self decodeEmbeddedSource ].  kind == #NoTrailer ifTrue: [ ^self decodeNoTrailer ].  self perform: ('decode' , kind) asSymboltestMethods  self assert: Object methods equals: Object methodDict valuesfieldIndex: anObject  fieldIndex := anObjecttan  ^self asFloat tantestFractionAsFloat  | r m frac err collec |  r := Random new seed: 1234567.  m := (2 raisedTo: 54) - 1.  200 timesRepeat: [ frac := ((r nextInt: m) * (r nextInt: m) + 1) / ((r nextInt: m) * (r nextInt: m) + 1).        err := (frac - frac asFloat asTrueFraction) * frac reciprocal * (1 bitShift: 52).        self assert: err < (1 / 2) ].  collec := #(16r10000000000000 16r1FFFFFFFFFFFFF 1 2 16r20000000000000 16r20000000000001 16r3FFFFFFFFFFFFF 16r3FFFFFFFFFFFFE 16r3FFFFFFFFFFFFD).  collec do: [:num |  collec do: [:den |  frac := Fraction numerator: num denominator: den.              err := (frac - frac asFloat asTrueFraction) * frac reciprocal * (1 bitShift: 52).              self assert: err <= (1 / 2) ] ]isInsideCircle: a with: b with: c  ^(a dotProduct: a) * (b triangleArea: c with: self) - ((b dotProduct: b) * (a triangleArea: c with: self)) + ((c dotProduct: c) * (a triangleArea: b with: self)) - ((self dotProduct: self) * (a triangleArea: b with: c)) > 0.0value: firstArg value: secondArg  < primitive: 207>  | newContext |  numArgs ~= 2 ifTrue: [ self numArgsError: 2 ].  false ifTrue: [ newContext := self asContextWithSender: thisContext sender.        newContext at: 1 put: firstArg.        newContext at: 2 put: secondArg.        thisContext privSender: newContext ] ifFalse: [ self primitiveFailed ]scheduleAtTimingPriority  readyToSchedule signal.  super scheduleAtTimingPrioritybasicAddSelector: selector withMethod: compiledMethod  self deprecated: 'Please use #addSelectorSilently:withMethod: instead' transformWith: '`@receiver basicAddSelector: `@statements1 withMethod: `@statements2' -> '`@receiver addSelectorSilently: `@statements1 withMethod: `@statements2'.  self addSelectorSilently: selector withMethod: compiledMethodunplug  classPool: aDictionary  classPool := aDictionarytestComparing  | d1 d2 d3 |  d1 := Duration seconds: 10 nanoSeconds: 1.  d2 := Duration seconds: 10 nanoSeconds: 1.  d3 := Duration seconds: 10 nanoSeconds: 2.  self     assert: d1 equals: d1;     assert: d1 equals: d2;     deny: d1 equals: d3;     assert: d1 < d3testAbs  self assert: aDuration abs equals: aDuration.  self assert: (Duration nanoSeconds: -5) abs equals: (Duration nanoSeconds: 5)valueWithPossibleArgs: anArray  ^numArgs = 0 ifTrue: [ self value ] ifFalse: [ self valueWithArguments: (numArgs = anArray size ifTrue: [ anArray ] ifFalse: [ numArgs > anArray size ifTrue: [ anArray , (Array new: numArgs - anArray size) ] ifFalse: [ anArray copyFrom: 1 to: numArgs ] ]) ]includes: aDateAndTime  ^(aDateAndTime isKindOf: Timespan) ifTrue: [ (self includes: aDateAndTime start) and: [ self includes: aDateAndTime end ] ] ifFalse: [ aDateAndTime asDateAndTime between: start and: self end ]bitInvert32  ^self bitXor: 16rFFFFFFFFresume: value through: firstUnwindContext  | context unwindBlock |  self isDead ifTrue: [ self cannotReturn: value to: self ].  context := firstUnwindContext.  [ context isNil ] whileFalse: [ context unwindComplete ifNil: [ context unwindComplete: true.              unwindBlock := context unwindBlock.              thisContext terminateTo: context.              unwindBlock value ].        context := context findNextUnwindContextUpTo: self ].  thisContext terminateTo: self.  ^valuetestWriteSlotValue  | object |  object := 5 @ 6.  self assert: (object writeSlot: (Point slotNamed: #x) value: 7) equals: 7.  self assert: object equals: 7 @ 6minute  ^(seconds rem: SecondsInHour) quo: SecondsInMinutedegreesToRadians  ^self asFloat degreesToRadianstestEpoch  self assert: aDateAndTime equals: '1970-01-01T00:00:00+00:00' asDateAndTimeadoptInstance: oldInstance from: oldMetaClass  thisClass class == self ifTrue: [ ^self error: 'Metaclasses have only one instance' ].  oldMetaClass isMeta ifFalse: [ ^self error: 'Argument must be Metaclass' ].  oldInstance class == oldMetaClass ifFalse: [ ^self error: 'Not the class of argument' ].  ^thisClass := self newInstanceFrom: oldInstance variable: self isVariable size: self instSize map: (self instVarMappingFrom: oldMetaClass)stonPostReferenceResolution  = aPoint  ^self species = aPoint species ifTrue: [ x = aPoint x and: [ y = aPoint y ] ] ifFalse: [ false ]storeOn: aStream  self < 0 ifTrue: [ aStream space ].  super storeOn: aStreamtestReadFromWithNanos  #('4:02:47.5 am' '4:02:55.521 pm') do: [:each |  | t |        t := self timeClass readFrom: each readStream.        self assert: t printString equals: each ]instanceVariableWriteNodes  ^self methods flatCollect: [:each |  each instanceVariableWriteNodes ]bitXor: arg  < primitive: 16>  self >= 0 ifTrue: [ ^arg bitXor: self ].  ^arg < 0 ifTrue: [ self bitInvert bitXor: arg bitInvert ] ifFalse: [ (self bitInvert bitXor: arg) bitInvert ]recompile  self compileAllatEnd  ^pc > self method endPCisLocalMethodsProtocol: aProtocol  aProtocol methodSelectors ifEmpty: [ ^true ].  ^aProtocol methodSelectors anySatisfy: [:each |  self isLocalSelector: each ]years  ^Duration years: selftestAsBit  self assert: false asBit equals: 0classInstaller  ^Smalltalk classInstallerremoveProtocol: aProtocol  aProtocol canBeRemoved ifFalse: [ aProtocol isVirtualProtocol ifTrue: [ ^self ].        ProtocolRemovalException signal ].  ^protocols remove: aProtocol ifAbsent: [  ]split: aSequenceableCollection  | result |  result := OrderedCollection new: (aSequenceableCollection size / 2) asInteger.  self split: aSequenceableCollection do: [:item |  result add: item ].  ^resultmethodNode  ^self outerCode methodNodesetSender: newSender receiver: newReceiver method: newMethod closure: newClosure startpc: startpc  sender := newSender.  receiver := newReceiver.  method := newMethod.  closureOrNil := newClosure.  pc := startpc.  stackp := 0isSpecAdapter  ^falsestart: aDateAndTime  start := aDateAndTime asDateAndTimeisActiveProcess  ^self == Processor activeProcessreplaceFrom: start to: stop with: replacement startingAt: repStart  | j |  j := repStart.  start to: stop do: [:i |  self byteAt: i put: (replacement byteAt: j).        j := j + 1 ]genSend: selectorLiteralIndex numArgs: nArgs  | extendedIndex extendedNArgs |  (selectorLiteralIndex < 0 or: [ selectorLiteralIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535 ].  (nArgs < 0 or: [ nArgs > 31 ]) ifTrue: [ ^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 ].  (selectorLiteralIndex < 16 and: [ nArgs < 3 ]) ifTrue: [ stream nextPut: 128 + (nArgs * 16) + selectorLiteralIndex.        ^self ].  (extendedIndex := selectorLiteralIndex) > 31 ifTrue: [ self genUnsignedSingleExtendA: extendedIndex // 32.        extendedIndex := extendedIndex \\ 32 ].  (extendedNArgs := nArgs) > 7 ifTrue: [ self genUnsignedSingleExtendB: extendedNArgs // 8.        extendedNArgs := extendedNArgs \\ 8 ].  stream     nextPut: 234;     nextPut: extendedNArgs + (extendedIndex * 8)seasidePossibleCauses  | causes |  self receiver isNil ifFalse: [ ^#('you sent a message this type of object doesn''t understand') ].  causes := #('the receiver of the message is nil' 'a class extension hasn''t been loaded correctly' 'you sent the wrong message') asOrderedCollection.  self message selector = #contents ifTrue: [ causes addFirst: 'you forgot to send "super initialize" in a initialize method of a component or task' ].  ^causesdigitRshift: anInteger bytes: b lookfirst: a  | n x r f m digit count i |  n := 0 - anInteger.  x := 0.  f := n + 8.  i := a.  m := 255 bitShift: 0 - f.  digit := self byteAt: i.  [ ((digit bitShift: n) bitOr: x) = 0 and: [ i ~= 1 ] ] whileTrue: [ x := digit bitShift: f.        i := i - 1.        digit := self byteAt: i ].  i <= b ifTrue: [ ^Integer new: 0 neg: self negative ].  r := Integer new: i - b neg: self negative.  count := i.  x := (self byteAt: b + 1) bitShift: n.  b + 1 to: count do: [:j |  digit := self byteAt: j + 1.        r byteAt: j - b put: (((digit bitAnd: m) bitShift: f) bitOr: x).        x := digit bitShift: n ].  ^rsourceCode  ^self subclassResponsibilityisValid  ^truedegreeCos  ^(90 - ((180 + self) \\ 360 - 180) abs) degreesToRadians sinencompass: aPoint  ^Rectangle origin: (origin min: aPoint) corner: (corner max: aPoint)printWithCommasSignedOn: aStream  ^self printSeparatedBy: $, every: 3 signed: true on: aStreamcheckDeep  < script: 'DeepCopier new checkDeep'>  Warning signal: (String streamContents: [:stream |  stream nextPutAll: 'Instance variables shared with the original object when it is copied'.              (self systemNavigation allClassesImplementing: #veryDeepInner:) do: [:aClass |  | mm |                    (mm := aClass instVarNames size) > 0 ifTrue: [ aClass instSize - mm + 1 to: aClass instSize do: [:index |  ((aClass compiledMethodAt: #veryDeepInner:) writesField: index) ifFalse: [ stream                                         cr;                                         tab.                                      aClass name printOn: stream.                                      stream space.                                      (aClass allInstVarNames at: index) printOn: stream ] ] ] ] ])hasActionForEvent: anEventSelector  ^(self actionForEvent: anEventSelector) notNiltestEpoch  self assert: aDateAndTime equals: '1901-01-01T00:00:00+00:00' asDateAndTimetestAsYears  self     assert: 2 years days equals: 730;     assert: 0.5 year asHours equals: 364 / 2 * 24 + 12duration  ^durationsendTo: receiver  ^receiver perform: selector withArguments: argstestPrevious  self assert: aTimespan equals: aDisjointTimespan previous.  self assert: aTimespan next previous equals: aTimespanoriginMethod  ^self methodClass findOriginMethodOf: selfsetDelay: milliseconds  millisecondDelayDuration := milliseconds asIntegertestToBy  self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) equals: ((DateAndTime year: 1970 month: 1 day: 1) to: (DateAndTime year: 1970 month: 1 day: 1) + 10 days by: 5 days)fuelAccept: aGeneralMapper  ^aGeneralMapper visitSmallInteger: selftestPlus  self assert: aDateAndTime + '0:00:00:00' equals: aDateAndTime.  self assert: aDateAndTime + 0 equals: aDateAndTime.  self assert: aDateAndTime + aDuration equals: (DateAndTime year: 1901 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)testAsSecond  | full half quarter |  full := Duration seconds: 1.  half := Duration seconds: 0.5.  quarter := Duration seconds: 0.25.  self     assert: 1 second equals: full;     assert: 1.0 second equals: full;     assert: 0.5 second equals: half;     assert: (1 / 2) second equals: half;     assert: (1 / 4) second equals: quarter.  self assert: 0.4 second + 0.6 second equals: 1 seconddigitCompare: arg  self deprecated: 'Please use bytesCompare: instead.' transformWith: '`@receiver digitCompare: `@statements1' -> '`@receiver bytesCompare: `@statements1'.  ^self bytesCompare: argtestIsNotAbstract  self deny: SmallInteger isAbstractasActiveRingDefinition  ^RGMethodDefinition new     name: self selector;     parentName: self methodClass name;     isMetaSide: self methodClass isMeta;     asActivekind  ^kindtestDifferentBases  self assert: 2r10 equals: 2.  self assert: 3r210 equals: 21.  self assert: 4r3210 equals: 228.  self assert: 5r43210 equals: 2930.  self assert: 6r543210 equals: 44790.  self assert: 7r6543210 equals: 800667.  self assert: 8r76543210 equals: 16434824.  self assert: 9r876543210 equals: 381367044.  self assert: 10r9876543210 equals: 9876543210.  self assert: 11rA9876543210 equals: 282458553905.  self assert: 12rBA9876543210 equals: 8842413667692.  self assert: 13rCBA9876543210 equals: 300771807240918.  self assert: 14rDCBA9876543210 equals: 11046255305880158.  self assert: 15rEDCBA9876543210 equals: 435659737878916215.  self assert: 16rFEDCBA9876543210 equals: 18364758544493064720.  self assert: 17rGFEDCBA9876543210 equals: 824008854613343261192.  self assert: 18rHGFEDCBA9876543210 equals: 39210261334551566857170.  self assert: 19rIHGFEDCBA9876543210 equals: 1972313422155189164466189.  self assert: 20rJIHGFEDCBA9876543210 equals: 104567135734072022160664820.  self assert: 21rKJIHGFEDCBA9876543210 equals: 5827980550840017565077671610.  self assert: 22rLKJIHGFEDCBA9876543210 equals: 340653664490377789692799452102.  self assert: 23rMLKJIHGFEDCBA9876543210 equals: 20837326537038308910317109288851.  self assert: 24rNMLKJIHGFEDCBA9876543210 equals: 1331214537196502869015340298036888.  self assert: 25rONMLKJIHGFEDCBA9876543210 equals: 88663644327703473714387251271141900.  self assert: 26rPONMLKJIHGFEDCBA9876543210 equals: 6146269788878825859099399609538763450.  self assert: 27rQPONMLKJIHGFEDCBA9876543210 equals: 442770531899482980347734468443677777577.  self assert: 28rRQPONMLKJIHGFEDCBA9876543210 equals: 33100056003358651440264672384704297711484.  self assert: 29rSRQPONMLKJIHGFEDCBA9876543210 equals: 2564411043271974895869785066497940850811934.  self assert: 30rTSRQPONMLKJIHGFEDCBA9876543210 equals: 205646315052919334126040428061831153388822830.  self assert: 31rUTSRQPONMLKJIHGFEDCBA9876543210 equals: 17050208381689099029767742314582582184093573615.  self assert: 32rVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 1459980823972598128486511383358617792788444579872.  self assert: 33rWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 128983956064237823710866404905431464703849549412368.  self assert: 34rXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 11745843093701610854378775891116314824081102660800418.  self assert: 35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 1101553773143634726491620528194292510495517905608180485.  self assert: 36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 106300512100105327644605138221229898724869759421181854980.  self assert: -2r10 equals: -2.  self assert: -3r210 equals: -21.  self assert: -4r3210 equals: -228.  self assert: -5r43210 equals: -2930.  self assert: -6r543210 equals: -44790.  self assert: -7r6543210 equals: -800667.  self assert: -8r76543210 equals: -16434824.  self assert: -9r876543210 equals: -381367044.  self assert: -10r9876543210 equals: -9876543210.  self assert: -11rA9876543210 equals: -282458553905.  self assert: -12rBA9876543210 equals: -8842413667692.  self assert: -13rCBA9876543210 equals: -300771807240918.  self assert: -14rDCBA9876543210 equals: -11046255305880158.  self assert: -15rEDCBA9876543210 equals: -435659737878916215.  self assert: -16rFEDCBA9876543210 equals: -18364758544493064720.  self assert: -17rGFEDCBA9876543210 equals: -824008854613343261192.  self assert: -18rHGFEDCBA9876543210 equals: -39210261334551566857170.  self assert: -19rIHGFEDCBA9876543210 equals: -1972313422155189164466189.  self assert: -20rJIHGFEDCBA9876543210 equals: -104567135734072022160664820.  self assert: -21rKJIHGFEDCBA9876543210 equals: -5827980550840017565077671610.  self assert: -22rLKJIHGFEDCBA9876543210 equals: -340653664490377789692799452102.  self assert: -23rMLKJIHGFEDCBA9876543210 equals: -20837326537038308910317109288851.  self assert: -24rNMLKJIHGFEDCBA9876543210 equals: -1331214537196502869015340298036888.  self assert: -25rONMLKJIHGFEDCBA9876543210 equals: -88663644327703473714387251271141900.  self assert: -26rPONMLKJIHGFEDCBA9876543210 equals: -6146269788878825859099399609538763450.  self assert: -27rQPONMLKJIHGFEDCBA9876543210 equals: -442770531899482980347734468443677777577.  self assert: -28rRQPONMLKJIHGFEDCBA9876543210 equals: -33100056003358651440264672384704297711484.  self assert: -29rSRQPONMLKJIHGFEDCBA9876543210 equals: -2564411043271974895869785066497940850811934.  self assert: -30rTSRQPONMLKJIHGFEDCBA9876543210 equals: -205646315052919334126040428061831153388822830.  self assert: -31rUTSRQPONMLKJIHGFEDCBA9876543210 equals: -17050208381689099029767742314582582184093573615.  self assert: -32rVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -1459980823972598128486511383358617792788444579872.  self assert: -33rWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -128983956064237823710866404905431464703849549412368.  self assert: -34rXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -11745843093701610854378775891116314824081102660800418.  self assert: -35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -1101553773143634726491620528194292510495517905608180485.  self assert: -36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -106300512100105327644605138221229898724869759421181854980allSubclasses  | scan scanTop |  scan := OrderedCollection withAll: self subclasses.  scanTop := 1.  [ scanTop > scan size ] whileFalse: [ scan addAll: (scan at: scanTop) subclasses.        scanTop := scanTop + 1 ].  ^scanisPushLiteralNil: aPC  ^(self method at: aPC) = method encoderClass pushNilBytein: aBlock  ^aBlock value: selfensure: aBlock  < primitive: 198>  | complete returnValue |  returnValue := self valueNoContextSwitch.  complete ifNil: [ complete := true.        aBlock value ].  ^returnValueat: aKey  ^self at: aKey ifAbsent: [ self error: 'not found' ]sign  ^1hasLiteralSuchThat: litBlock  (self penultimateLiteral isMethodProperties and: [ self penultimateLiteral hasLiteralSuchThat: litBlock ]) ifTrue: [ ^true ].  2 to: self numLiterals - 1 do: [:index |  | lit |        lit := self objectAt: index.        ((litBlock value: lit) or: [ lit isArray and: [ lit hasLiteralSuchThat: litBlock ] ]) ifTrue: [ ^true ].        (lit isMemberOf: CompiledBlock) ifTrue: [ (lit hasLiteralSuchThat: litBlock) ifTrue: [ ^true ] ] ].  ^falseinstallValue: anObject intoForked: newProcess from: ownerProcess  newProcess psValueAt: index put: anObjectlongPrintOn: aStream limitedTo: sizeLimit indent: indent  self class allInstVarNames doWithIndex: [:title :index |  indent timesRepeat: [ aStream tab ].        aStream           nextPutAll: title;           nextPut: $:;           space;           tab;           nextPutAll: ((self instVarAt: index) printStringLimitedTo: (sizeLimit - 3 - title size max: 1));           cr ]testMidnight  self assert: aDateAndTime midnight equals: aDateAndTimepushConsArrayWithElements: numElements  | array |  array := Array new: numElements.  numElements to: 1 by: -1 do: [:i |  array at: i put: self pop ].  self push: arraysetPostLoadDoItInMetacelloSpec: aMetacelloSpec  aMetacelloSpec setPostLoadDoIt: (aMetacelloSpec project valueHolderSpec           value: self;           yourself)isTerminating  ^terminating ifNil: [ false ]notifyOfRecategorizedSelector: selector from: oldCategory to: newCategory  (self compiledMethodAt: selector ifAbsent: [ nil ]) ifNotNil: [:method |  SystemAnnouncer uniqueInstance methodRecategorized: method oldProtocol: oldCategory ]valueWithArguments: anArray  < primitive: 206>  | newContext ncv |  numArgs ~= anArray size ifTrue: [ self numArgsError: anArray size ].  newContext := self asContextWithSender: thisContext sender.  ncv := self numCopiedValues.  newContext stackp: ncv + numArgs.  1 to: numArgs do: [:i |  newContext at: i put: (anArray at: i) ].  1 to: ncv do: [:i |  newContext at: i + numArgs put: (self at: i) ].  thisContext privSender: newContextmetacelloRegistrationHash  ^self hashtestComparisonWhenPrimitiveFails  self deny: 0.5 < (1 / 4).  self deny: 0.5 < (1 / 2).  self assert: 0.5 < (3 / 4).  self deny: 0.5 <= (1 / 4).  self assert: 0.5 <= (1 / 2).  self assert: 0.5 <= (3 / 4).  self assert: 0.5 > (1 / 4).  self deny: 0.5 > (1 / 2).  self deny: 0.5 > (3 / 4).  self assert: 0.5 >= (1 / 4).  self assert: 0.5 >= (1 / 2).  self deny: 0.5 >= (3 / 4).  self deny: 0.5 equals: 1 / 4.  self assert: 0.5 equals: 1 / 2.  self deny: 0.5 equals: 3 / 4.  self assert: 0.5 ~= (1 / 4).  self deny: 0.5 ~= (1 / 2).  self assert: 0.5 ~= (3 / 4)daysInYear  ^self duration daysdefinitionWithSlots  ^String streamContents: [:stream |  stream print: self.        stream           crtab;           nextPutAll: 'slots: ';           nextPutAll: self slotDefinitionString ]digitLogic: arg op: op length: len  | i result neg1 neg2 rneg z1 z2 rz b1 b2 b |  neg1 := self negative.  neg2 := arg negative.  rneg := ((neg1 ifTrue: [ -1 ] ifFalse: [ 0 ]) perform: op with: (neg2 ifTrue: [ -1 ] ifFalse: [ 0 ])) < 0.  result := Integer new: len neg: rneg.  rz := z1 := z2 := true.  i := 0.  [ (i := i + 1) <= len or: [ rneg and: [ rz and: [ result := result growby: 1.                    true ] ] ] ] whileTrue: [ b1 := self byteAt: i.        neg1 ifTrue: [ b1 := z1 ifTrue: [ b1 = 0 ifTrue: [ 0 ] ifFalse: [ z1 := false.                          256 - b1 ] ] ifFalse: [ 255 - b1 ] ].        b2 := arg byteAt: i.        neg2 ifTrue: [ b2 := z2 ifTrue: [ b2 = 0 ifTrue: [ 0 ] ifFalse: [ z2 := false.                          256 - b2 ] ] ifFalse: [ 255 - b2 ] ].        b := b1 perform: op with: b2.        result byteAt: i put: (rneg ifTrue: [ rz ifTrue: [ b = 0 ifTrue: [ 0 ] ifFalse: [ rz := false.                                256 - b ] ] ifFalse: [ 255 - b ] ] ifFalse: [ b ]) ].  ^result normalizeintersect: aRectangle ifNone: aBlock  | aPoint left right top bottom |  (self intersects: aRectangle) ifFalse: [ ^aBlock value ].  aPoint := aRectangle origin.  left := aPoint x max: origin x.  top := aPoint y max: origin y.  aPoint := aRectangle corner.  right := aPoint x min: corner x.  bottom := aPoint y min: corner y.  ^Rectangle origin: left @ top corner: right @ bottomtestAsSeconds  self assert: aDateAndTime asSeconds equals: 0 asDuration asSecondsifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock  ^falseAlternativeBlock valuegenPushReceiver  stream nextPut: 112printHMS: aTime separatedBy: aSeparator on: aStream  aTime hour printOn: aStream base: 10 length: 2 padded: true.  aStream nextPut: aSeparator.  aTime minute printOn: aStream base: 10 length: 2 padded: true.  aStream nextPut: aSeparator.  aTime second printOn: aStream base: 10 length: 2 padded: truetheNonMetaClass  self deprecated: 'Please use #instanceSide instead' transformWith: '`@receiver theNonMetaClass' -> '`@receiver instanceSide'.  ^self instanceSidetestclassThatDefinesInstVarNamed  self assert: (Point classThatDefinesInstVarNamed: 'x') equals: Point.  self assert: (Class classThatDefinesInstVarNamed: 'methodDict') equals: Behavior.  self assert: (Point classThatDefinesInstVarNamed: 'methodDict') equals: nilsetUp  super setUp.  restoredStartDay := Week startDay.  Week startDay: #Sunday.  week := Week starting: '4 July 1998' asDatetestIsLetter  | letterCategories methodAnswer catFromTable |  letterCategories := #(Ll Lm Lo Lt Lu) collect: [:c |  Unicode classPool at: c ].  self aRandomSelectionOfCodePointsDo: [:cp |  methodAnswer := Unicode isLetter: (Character codePoint: cp).        catFromTable := self unicodeCategoryTableLookup: cp.        self assert: methodAnswer equals: (letterCategories includes: catFromTable) ]doPrimitive: primitiveIndex method: meth receiver: aReceiver args: arguments  | value |  ((primitiveIndex between: 201 and: 222) and: [ (self objectClass: aReceiver) includesBehavior: BlockClosure ]) ifTrue: [ ((primitiveIndex between: 201 and: 205) or: [ primitiveIndex between: 221 and: 222 ]) ifTrue: [ ^aReceiver simulateValueWithArguments: arguments caller: self ].        primitiveIndex = 206 ifTrue: [ ^aReceiver simulateValueWithArguments: arguments first caller: self ] ].  ((primitiveIndex between: 207 and: 209) and: [ (self objectClass: aReceiver) includesBehavior: FullBlockClosure ]) ifTrue: [ ^primitiveIndex = 208 ifTrue: [ aReceiver simulateValueWithArguments: arguments first caller: self ] ifFalse: [ aReceiver simulateValueWithArguments: arguments caller: self ] ].  primitiveIndex = 83 ifTrue: [ ^self send: arguments first to: aReceiver with: arguments allButFirst super: false ].  primitiveIndex = 84 ifTrue: [ ^self send: arguments first to: aReceiver with: (arguments at: 2) lookupIn: (self objectClass: aReceiver) ].  primitiveIndex = 100 ifTrue: [ arguments size = 3 ifTrue: [ ^self send: arguments first to: aReceiver with: (arguments at: 2) lookupIn: (arguments at: 3) ] ifFalse: [ ^self send: (arguments at: 2) to: (arguments at: 1) with: (arguments at: 3) lookupIn: (arguments at: 4) ] ].  (primitiveIndex = 186 or: [ primitiveIndex = 187 ]) ifTrue: [ | active effective |        active := Processor activeProcess.        effective := active effectiveProcess.        value := primitiveIndex = 186 ifTrue: [ aReceiver primitiveEnterCriticalSectionOnBehalfOf: effective ] ifFalse: [ aReceiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective ].        ^(self isPrimFailToken: value) ifTrue: [ value ] ifFalse: [ self push: value ] ].  primitiveIndex = 188 ifTrue: [ arguments size = 2 ifTrue: [ ^Context sender: self receiver: aReceiver method: (arguments at: 2) arguments: (arguments at: 1) ] ifFalse: [ ^Context sender: self receiver: (arguments at: 1) method: (arguments at: 3) arguments: (arguments at: 2) ] ].  (primitiveIndex = 200 and: [ self == aReceiver ]) ifTrue: [ ^self push: (BlockClosure outerContext: aReceiver startpc: pc + 2 numArgs: arguments first copiedValues: arguments last) ].  primitiveIndex = 118 ifTrue: [ (arguments size = 2 and: [ arguments first isInteger and: [ (self objectClass: arguments last) == Array ] ]) ifFalse: [ ^Context primitiveFailTokenFor: nil ].        ^self doPrimitive: arguments first method: meth receiver: aReceiver args: arguments last ].  value := primitiveIndex = 120 ifTrue: [ (meth literalAt: 1) tryInvokeWithArguments: arguments ] ifFalse: [ primitiveIndex = 117 ifTrue: [ self tryNamedPrimitiveIn: meth for: aReceiver withArgs: arguments ] ifFalse: [ aReceiver tryPrimitive: primitiveIndex withArgs: arguments ] ].  ^(self isPrimFailToken: value) ifTrue: [ value ] ifFalse: [ self push: value ]log  ^self ln / Ln10hash  ^(x hash hashMultiply + y hash) hashMultiplywaitUntil: aBlock for: aSymbolOrNil  ^self waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: niltestMutateWideStringUsingAtPut  | guineaPig |  guineaPig := 'hello' asWideString.  guineaPig beReadOnlyObject.  self should: [ guineaPig at: 1 put: $q ] raise: ModificationForbidden.  [ guineaPig at: 1 put: $q ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first equals: $qtestAsMonth  self assert: aTimespan asMonth equals: jan01 asMonthspotterMethodClassFor: aStep  < spotterOrder: 50>  aStep listProcessor     allCandidates: [ {self methodClass} ];     title: 'Class';     filter: GTFilterSubstring;     itemIcon: #systemIcontestParsingYPatternWithTwoDigitsReturnsASecondMillenaryYear  self assertReading: '2.11.13' as: 'd.mm.y' equals: (Date year: 2013 month: 11 day: 2)remove: aLinkOrObject ifAbsent: aBlock  | link |  link := self linkOf: aLinkOrObject ifAbsent: [ ^aBlock value ].  self removeLink: link ifAbsent: [ ^aBlock value ].  ^aLinkOrObjectnumTemps  ^closureOrNil ifNil: [ method numTemps ] ifNotNil: [ closureOrNil numTemps ]add: char  | dict elem |  codes ifNil: [ codes := Array with: char.        combined := char.        ^true ].  dict := Compositions at: combined charCode ifAbsent: [ ^false ].  elem := dict at: char charCode ifAbsent: [ ^false ].  codes := codes copyWith: char.  combined := Character leadingChar: self base leadingChar code: elem.  ^truespotterForSendersFor: aStep  < spotterOrder: 11>  aStep listProcessor     title: 'Senders';     allCandidates: [ self senders collect: #compiledMethod ];     filter: GTFilterSubstring;     keyBinding: $n commandisDeprecated  self methodClass isDeprecated ifTrue: [ ^true ].  (self sendsAnySelectorOf: #(#deprecated: #deprecated:on:in: #deprecated:on:in:transformWith: #deprecated:transformWith:)) ifTrue: [ ^true ].  $- split: self protocol asString do: [:each |  each withBlanksCondensed = 'deprecated' ifTrue: [ ^true ] ].  ^falsereorganize  ^self organizationpostCopy  | aLink |  super postCopy.  firstLink ifNotNil: [ aLink := firstLink := firstLink copy.        [ aLink nextLink isNil ] whileFalse: [ aLink nextLink: (aLink := aLink nextLink copy) ].        lastLink := aLink ]adaptToFraction: rcvr andSend: selector  ^self subclassResponsibilityisLetterModifier  ^self characterSet isLetterModifier: selfisDictionary  ^falsedaysInMonth  ^Date daysInMonthvalue  arguments ifNil: [ ^receiver perform: selector ].  ^receiver perform: selector withArguments: (self collectArguments: arguments)errorNotIndexable  self error: ('Instances of {1} are not indexable' format: {self class name})commentStamp  ^commentStampallMethodSelectors  ^self protocols flatCollect: [:p |  p methodSelectors ]deprecationRefactorings  ^#()populateCBMenu: aMenu  super populateCBMenu: aMenu.  aMenu     add: 'Implementors of...' target: SystemNavigation new selector: #browseAllImplementorsOf: argument: self selector;     add: 'Senders of...' target: SystemNavigation new selector: #browseAllSendersOf: argument: self selectorprint24  ^String new: 8 streamContents: [:aStream |  self print24: true on: aStream ]traceCr  self traceCr: selfwithSideOrCorner: side setToPoint: newPoint  ^self withSideOrCorner: side setToPoint: newPoint minExtent: 0 @ 0testParsingDPatternWithSingleDigitSucceeds  self assertReading: '2.11.2013' as: 'd.mm.yyyy' equals: (Date year: 2013 month: 11 day: 2)significandAsInteger  self isFinite ifTrue: [ ^(self timesTwoPower: self class precision - 1 - (self exponent max: self class emin)) truncated abs ].  ^(((self basicAt: 1) bitAnd: 16r000FFFFF) bitShift: 32) bitOr: (self basicAt: 2)defaultLabel  ^self class nameinitialize  super initialize.  exclusions := OrderedCollection newminutes  ^(seconds rem: SecondsInHour) quo: SecondsInMinutetestReentrant  | assoc |  assoc := self callcc: [:cc |  cc -> 0 ].  assoc value: assoc value + 1.  self assert: assoc value ~= 5.  assoc value = 4 ifFalse: [ assoc key value: assoc ]addFirst: aLinkOrObject  | aLink |  aLink := aLinkOrObject asLink.  self isEmpty ifTrue: [ lastLink := aLink ].  aLink nextLink: firstLink.  firstLink := aLink.  ^aLinkto: end1 intersects: start2 to: end2  | start1 sideStart sideEnd |  start1 := self.  (((start1 = start2 or: [ end1 = end2 ]) or: [ start1 = end2 ]) or: [ start2 = end1 ]) ifTrue: [ ^true ].  sideStart := start1 to: end1 sideOf: start2.  sideEnd := start1 to: end1 sideOf: end2.  sideStart = sideEnd ifTrue: [ ^false ].  sideStart := start2 to: end2 sideOf: start1.  sideEnd := start2 to: end2 sideOf: end1.  sideStart = sideEnd ifTrue: [ ^false ].  ^truefullName  ^self nameprivSender: aContext  sender := aContexthash  ^self value hashcaseError  self error: 'Case not found (' , self printString , '), and no otherwise clause'>>> anObject  ^self -> anObjectintersectValueLink: aValueLink withCollection: anotherSet  ^aValueLink ifNotNil: [ | car cdr |        car := aValueLink value.        cdr := self intersectValueLink: aValueLink nextLink withCollection: anotherSet.        (anotherSet includes: car) ifTrue: [ car ~~> cdr ] ifFalse: [ cdr ] ]raisedToInteger: anInteger  anInteger = 0 ifTrue: [ ^1 ].  anInteger < 0 ifTrue: [ ^self reciprocal raisedToInteger: anInteger negated ].  ^Fraction numerator: (numerator raisedToInteger: anInteger) denominator: (denominator raisedToInteger: anInteger)testOffset  | dt newYear |  dt := DateAndTime fromString: '2018/01/01T00:00:00+10'.  newYear := Year starting: dt duration: 0.  self assert: newYear asDateAndTime offset equals: dt offsetscaleBy: scale  ^Rectangle origin: origin * scale corner: corner * scalelistAtProtocolNamed: categoryName  ^self listAtCategoryNamed: categoryNameisRemoteString  ^falsesendNodes  ^self ast sendNodesisNested  ^handlerContext nextHandlerContext canHandleSignal: selfquickStep  self willSend ifTrue: [ QuickStep := self ].  ^self stepsentTo: receiver  ^lookupClass ifNil: [ receiver perform: selector withArguments: args ] ifNotNil: [ receiver perform: selector withArguments: args inSuperclass: lookupClass ]isWide  ^self width > self heightasBit  self subclassResponsibilitystandardMessageText  ^String streamContents: [:stream |  stream << 'for '.        stream print: self selector.        stream << ' in '.        stream print: self signaler class ]iterations: integer  iterations := integerflag: aSymbol  methodSelectors  ^methodSelectors* anInteger  < primitive: 29>  ^super * anIntegerasLiteralNode  ^RBLiteralNode value: selftestJulianDayNumber  self assert: (january23rd2004 translateTo: 0) equals: (Date julianDayNumber: (4713 + 2004) * 365 + 1323 offset: 0 hour)testFromSeconds  self assert: aDateAndTime equals: (DateAndTime fromSeconds: 0)createActionMap  ^IdentityDictionary newgenStorePopTemp: tempIndex  tempIndex < 0 ifTrue: [ ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63 ].  tempIndex < 8 ifTrue: [ stream nextPut: 104 + tempIndex.        ^self ].  tempIndex < 64 ifTrue: [ stream           nextPut: 130;           nextPut: 64 + tempIndex.        ^self ].  ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63flag  ^((self header bitShift: -29) bitAnd: 1) = 1setNumerator: n denominator: d scale: s  self setNumerator: n denominator: d.  scale := stestYesterday  self assert: Date yesterday equals: Date today - 1 daystonContainSubObjects  ^truetestIndexOfDay  self assert: (Week indexOfDay: 'Friday') equals: 6raisedTo: aNumber  ^self coerce: (super raisedTo: aNumber)parseVariableDigitYear  year := self parse: 'year'testStoreBase16  self assert: (20.0 storeStringBase: 16) = '16r14.0' description: 'the radix prefix should not be omitted, except in base 10'pin  self pinInMemorytestBasicWritable  self alwaysWritableObjects , self maybeReadOnlyObjects do: [:each |  self assert: each isReadOnlyObject equals: false ]subclassDefinerClass  ^Smalltalk compilerClasstestForSeconds  | delay |  delay := Delay forSeconds: 1.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: delay.  scheduler simulate_vmMilliseconds: 1099.  self deny: delay isExpired.  scheduler simulate_vmMilliseconds: 1100.  self assert: delay isExpiredinsetRectangle: aRectangle  | l r t b |  l := aRectangle left + self left.  r := left max: aRectangle right - self right.  t := aRectangle top + self top.  b := top max: aRectangle bottom - self bottom.  ^Rectangle left: l right: r top: t bottom: bupdate: aParameter  ^selfwait  self asDelay waitbackgroundProcess  ^BackgroundProcesscheck: anAST forCritiquesDo: aCriticBlock ifNone: alternativeBlock  | encounteredCritique |  encounteredCritique := false.  anAST nodesDo: [:node |  (node isVariable and: [ node binding ifNil: [ node doSemanticAnalysis ].              node isGlobal and: [ self systemClassNames includes: node name ] ]) ifTrue: [ encounteredCritique := true.              aCriticBlock cull: (ReTrivialCritique withAnchor: (ReIntervalSourceAnchor entity: anAST interval: node sourceInterval) by: self) ] ].  encounteredCritique ifFalse: alternativeBlocktestDoesNotActivateForDeprecatedMethods  | testMethod |  testMethod := testSubclass >> (testSubclass compile: self methodName , ' self deprecated: ''Add another explanation message''').  self assertEmpty: (OverridesDeprecatedMethodRule new check: testMethod)testRoundTo  self assert: (5 minutes + 37 seconds roundTo: 2 minutes) equals: 6 minutes.  self assert: (aDuration roundTo: (Duration days: 1)) equals: (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: (aDuration roundTo: (Duration hours: 1)) equals: (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: (aDuration roundTo: (Duration minutes: 1)) equals: (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0)testMutualExclusion  | lock steps |  steps := OrderedCollection new.  lock := Semaphore forMutualExclusion.  [ steps add: #startProcess1.  lock critical: [ steps add: #startCritical1.        [ steps includes: #startProcess2 ] whileFalse: [ Processor yield ].        steps add: #endCritical1 ] ] fork.  [ [ steps includes: #startProcess1 ] whileFalse: [ Processor yield ].  steps add: #startProcess2.  lock critical: [ steps add: #startCritical2.        Processor yield.        steps add: #endCritical2 ] ] fork.  [ steps size = 6 ] whileFalse: [ Processor yield ].  self assert: (steps hasEqualElements: #(startProcess1 startCritical1 startProcess2 endCritical1 startCritical2 endCritical2))round: numberOfWishedDecimal  < expr: 10.12345 round: 2 result: 10.12>  < expr: 10.199999999 round: 2 result: 10.2>  ^self subclassResponsibilitybitStringLength  ^self class maxVal highBit + 1pinInMemory  ^self setPinnedInMemory: true> aMagnitude  ^aMagnitude < selfchanged: aParameter  self dependents do: [:aDependent |  aDependent update: aParameter ]selector  ^self outerCode selectortestAsNumberWithExtendedScale  | sd |  sd := '123s2' asNumber.  self assert: ScaledDecimal identicalTo: sd class.  self assert: sd scale equals: 2.  self assert: '123.00s2' equals: sd printStringanyMask: mask  ^0 ~= (self bitAnd: mask)testInjectingExceptionHandlerIntoNotRunningProcess  | error interceptedError process interrupted |  DefaultExecutionEnvironment beActive.  error := Error new messageText: 'test error'.  interrupted := true.  process := [ error signal.  interrupted := false ] newProcess.  process on: Error do: [:err |  interceptedError := err ].  process resume.  [ process isTerminated ] whileFalse: [ Processor yield ].  self assert: interceptedError identicalTo: error.  self assert: interruptedtestWriteSlotNamedValue  | object |  object := 5 @ 6.  self assert: (object writeSlotNamed: #x value: 7) equals: 7.  self assert: object equals: 7 @ 6monthAbbreviation  ^start monthAbbreviationisSelfEvaluating  ^self isLiteralselectorsToBeIgnored  | deprecated private special |  deprecated := #().  private := #(#printOn:).  special := #(#next #do:).  ^super selectorsToBeIgnored , deprecated , private , special= comparand  ^self species = comparand species and: [ self start = comparand start and: [ self duration = comparand duration ] ]linesOfCode  | lines |  lines := self localMethods inject: 0 into: [:sum :each |  sum + each linesOfCode ].  ^self isMeta ifTrue: [ lines ] ifFalse: [ lines + self classSide linesOfCode ]isTransferable  ^falsetestTicks  self assert: aDateAndTime ticks equals: (DateAndTime julianDayNumber: 2444240) ticks.  self assert: aDateAndTime ticks equals: #(2444240 0 0)methodWithPragma  < testPragmaArg1: #toto arg2: 2 arg3: true>  ast  ^self subclassResponsibilitylink: aMetaLink toClassVariableNamed: aClassVariableName  self link: aMetaLink toClassVariable: (MetalinkTargetResolver classVariableNamed: aClassVariableName for: self)classToBeTested  ^self dateClasstestTwoInARow  | tree1 tree2 |  tree1 := #solid ~~> (#food ~~> nil ~~> (Link new ~~> nil)) ~~> (#food ~~> nil ~~> nil ~~> nil ~~> nil).  tree2 := #solid ~~> (#food ~~> nil ~~> (#marmellade ~~> nil)) ~~> (#food ~~> nil ~~> nil ~~> nil ~~> nil).  self assert: (self printStringOfTree: tree1) equals: '((#solid (#food) ()) (((#food))))'.  self assert: (TwoInARowStar new tree: tree1) equals: true.  self assert: (self printStringOfTree: tree2) equals: '((#solid (#food) #marmellade) (((#food))))'.  self assert: (TwoInARowStar new tree: tree2) equals: falseweeks  ^Duration weeks: selftestIsLeapYear  self deny: aDateAndTime isLeapYearbasicAt: index put: value  < primitive: 39>  ^super basicAt: index put: valuetrace  self trace: selftestRemoveCategory  self assert: self organization categories size equals: 2.  self should: [ self organization removeCategory: 'one' ] raise: Error.  self organization removeCategory: 'empty'.  self assert: self organization categories size equals: 1.  self assert: self organization categories first equals: 'one'roundTo: quantum  ^(self / quantum) rounded * quantumsubclass: aSubclassSymbol uses: aTraitCompositionOrArray layout: layoutClass slots: slotDefinition classVariables: classVarDefinition package: aCategorySymbol  ^self subclass: aSubclassSymbol uses: aTraitCompositionOrArray layout: layoutClass slots: slotDefinition classVariables: classVarDefinition poolDictionaries: '' category: aCategorySymboltestResumableFallOffTheEndHandler  self assertSuccess: (ExceptionTester new runTest: #resumableFallOffTheEndHandler)atRandom: aGenerator  ^aGenerator nextInt: selftestAsBit  self assert: true asBit equals: 1storeOn: aStream base: base  ^self subclassResponsibilitytestInstructions  | client |  client := InstructionClient new.  Object methods do: [:method |  | scanner |        scanner := InstructionStream on: method.        [ scanner pc <= method endPC ] whileTrue: [ scanner interpretNextInstructionFor: client ] ]queueDict  ^queueDict ifNil: [ queueDict := IdentityDictionary new ]asSendTo: anObject  ^MessageSend message: self to: anObjecttestWhichSelectorsAccess  self assert: ((Point whichSelectorsAccess: 'x') includes: #x).  self deny: ((Point whichSelectorsAccess: 'y') includes: #x)asMetacelloVersionNumber  ^MetacelloVersionNumber fromString: ''testPrintOn  | string |  string := String streamContents: [:stream |  nil printOn: stream ].  self assert: string equals: 'nil'testSetUp  self deny: aMethodContext isDead.  self assert: aMethodContext home equals: aMethodContext.  self assert: aMethodContext receiver equals: aReceiver.  self assert: (aMethodContext method isKindOf: CompiledMethod).  self assert: aMethodContext method equals: aCompiledMethod.  self assert: aMethodContext client printString equals: 'ContextTest>>#testSetUp'= aPragma  self == aPragma ifTrue: [ ^true ].  self species == aPragma species ifFalse: [ ^false ].  self method = aPragma method ifFalse: [ ^false ].  self method selector = aPragma method selector ifFalse: [ ^false ].  self selector = aPragma selector ifFalse: [ ^false ].  self arguments = aPragma arguments ifFalse: [ ^false ].  ^truedegreeCos  self isFinite ifTrue: [ ^super degreeCos ].  ^self degreesToRadians cosvariableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat  ^self variableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cattestTerminatingBlockedCriticalSectionShouldNotUnblockAnotherWaitingSection  | semaphoreToHoldMutex holdingCriticalExecutedFirst firstWaitingProcess lastCriticalExecuted |  holdingCriticalExecutedFirst := false.  semaphoreToHoldMutex := Semaphore new.  lastCriticalExecuted := false.  self fork: [ mutex critical: [ semaphoreToHoldMutex wait.              holdingCriticalExecutedFirst := lastCriticalExecuted not ] ].  self waitLastProcessLock.  firstWaitingProcess := self fork: [ mutex critical: [ self error: 'should not happen' ] ].  self waitLastProcessLock.  self fork: [ mutex critical: [ lastCriticalExecuted := true ] ].  self waitLastProcessLock.  firstWaitingProcess terminate.  self waitLastProcessLock.  semaphoreToHoldMutex signal.  self waitLastProcessTerminate.  self assert: holdingCriticalExecutedFirst.  self assert: lastCriticalExecutedtestTerminateActive  | lastStatementEvaluated block1HasRun block2HasRun p1 p2 |  block1HasRun := block2HasRun := lastStatementEvaluated := false.  p1 := [ block1HasRun := true.  Processor activeProcess terminate.  lastStatementEvaluated := true ] fork.  p2 := [ block2HasRun := true.  Processor terminateActive.  lastStatementEvaluated := true ] fork.  [ p1 isTerminated & p2 isTerminated ] whileFalse: [ Processor yield ].  self assert: block1HasRun.  self assert: block2HasRun.  self deny: lastStatementEvaluatedallInstancesDo: aBlock  | instances inst next |  instances := self allInstancesOrNil.  instances ifNotNil: [ instances do: aBlock.        ^self ].  inst := self someInstance.  [ inst == nil ] whileFalse: [ next := inst nextInstance.        aBlock value: inst.        inst := next ]testInfinityCloseTo  self deny: (Float infinity closeTo: Float infinity negated).  self deny: (Float infinity negated closeTo: Float infinity)abs  self < 0 ifTrue: [ ^self negated ] ifFalse: [ ^self ]ifNil: nilBlock ifNotNil: ifNotNilBlock  ^ifNotNilBlock cull: selfinnerCorners  | r1 |  r1 := self topLeft corner: self bottomRight - (1 @ 1).  ^Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRightendPC  method ifNil: [ self error: 'Cannot determine the endPC without compiled method' ].  ^method size - sizetestAddTime  self assert: (aTime addTime: aTime) equals: (Time readFrom: '01:09:52' readStream)gtInspectorHeaderIn: composite  < gtInspectorPresentationOrder: 40>  composite text     title: 'Header';     display: [ self headerDescription ]sunitExitWith: aValue  self return: aValueasLocalStringYMDHM  ^self asLocal asStringYMDHMxor: alternativeBlock  self subclassResponsibilitytagsForMethods  | allProtocols |  allProtocols := self organization protocols reject: [:each |  each name = Protocol unclassified | each isExtensionProtocol ].  ^allProtocols select: [:each |  self isLocalMethodsProtocol: each ] thenCollect: #name~= aNumber  < primitive: 548>  ^super ~= aNumberasJson  ^WAJsonCanvas builder render: [:json |  self jsonOn: json ]kindAsByte  | index |  index := self class trailerKinds indexOf: kind.  [ index ~~ 0 ] assert.  ^index - 1 << 2allMethodsWritingSlot: aSlot  ^self withAllSubclasses flatCollect: [:class |  class methodsWritingSlot: aSlot ]testMethodsReadingSlot  | numberViaSlot numberViaIVar |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  numberViaSlot := (Point methodsReadingSlot: (Point slotNamed: #x)) size.  numberViaIVar := (Point whichSelectorsRead: 'x') size.  self assert: numberViaSlot equals: numberViaIVarnextWakeUpTime  ^activeDelay ifNil: [ 0 ] ifNotNil: [:delay |  delay resumptionTick ]addSlot: aSlot  ^self classInstaller update: self to: [:builder |  builder           fillFor: self;           slots: (self localSlots copyWith: aSlot) ]testLog  self assert: ((1 / 100) log closeTo: -2).  self assert: (((2 raisedTo: Float emax + 11) / 3) log closeTo: (Float emax + 11) * 2 log - 3 log) description: 'Fraction>>log should not overflow'.  self assert: ((3 / (2 raisedTo: Float precision - Float emin)) log closeTo: (Float emin - Float precision) * 2 log + 3 log) description: 'Fraction>>log should not underflow'printOn: aStream base: base length: minimum padded: zeroFlag  | prefix |  prefix := self negative ifTrue: [ '-' ] ifFalse: [ '' ].  self print: (self abs printStringBase: base) on: aStream prefix: prefix length: minimum padded: zeroFlaggenStoreTemp: tempIndex  tempIndex < 0 ifTrue: [ ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63 ].  tempIndex < 64 ifTrue: [ stream           nextPut: 129;           nextPut: 64 + tempIndex.        ^self ].  ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63genStoreTemp: tempIndex  (tempIndex < 0 or: [ tempIndex > 63 ]) ifTrue: [ ^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63 ].  stream     nextPut: 245;     nextPut: tempIndexdividend: argument  dividend := argumentisResumable  ^trueinsideTriangle: p1 with: p2 with: p3  | p0 b0 b1 b2 b3 |  p0 := self.  b0 := (p2 x - p1 x) * (p3 y - p1 y) - ((p3 x - p1 x) * (p2 y - p1 y)).  b0 isZero ifTrue: [ ^false ].  b0 := 1.0 / b0.  b1 := ((p2 x - p0 x) * (p3 y - p0 y) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.  b2 := ((p3 x - p0 x) * (p1 y - p0 y) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.  b3 := ((p1 x - p0 x) * (p2 y - p0 y) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.  b1 < 0.0 ifTrue: [ ^false ].  b2 < 0.0 ifTrue: [ ^false ].  b3 < 0.0 ifTrue: [ ^false ].  ^truegenReturnSpecialLiteral: aLiteral  | index |  index := #(true false nil) indexOf: aLiteral ifAbsent: 0.  index = 0 ifTrue: [ ^self error: 'return special literal: ' , aLiteral printString , ' is not one of true false nil' ].  stream nextPut: 120 + indexfirstLink  self emptyCheck.  ^firstLinktestContinuationExample2  | array |  array := (1 to: 20) asOrderedCollection.  self assert: (self continuationExample2: array) equals: (array collect: [:x |  x * x ])indexedMessageText  ^String streamContents: [:s |  s << ' '.        self printObject: object on: s.        s << ' is read-only, hence its field '.        fieldIndex printOn: s.        s << ' cannot be modified with '.        self printObject: newValue on: s ]testPlus  self assert: aTimespan + aWeek equals: aDisjointTimespan.  self assert: anOverlappingTimespan + aDay equals: aTimespanadaptToFraction: rcvr andSend: selector  ^rcvr perform: selector with: (Fraction numerator: self denominator: 1)gtInspectorActionBrowse  < gtInspectorAction>  ^GLMGenericAction new     action: [ Smalltalk tools browser openOnClass: self class ];     icon: GLMUIThemeExtraIcons glamorousBrowse;     title: 'Browse'return: value from: aSender  | newTop context |  aSender isDead ifTrue: [ ^self send: #cannotReturn: to: self with: {value} super: false ].  newTop := aSender sender.  context := self findNextUnwindContextUpTo: newTop.  context ifNotNil: [ ^self send: #aboutToReturn:through: to: self with: {value .               context} super: false ].  self releaseTo: newTop.  newTop ifNotNil: [ newTop push: value ].  ^newTopasLowercase  ^self characterSet toLowercase: selfsignalQueue: anOrderedCollection  queuesMutex critical: [ anOrderedCollection isEmpty ifFalse: [ anOrderedCollection removeFirst signal ] ]addSelectorSilently: selector withMethod: compiledMethod  super addSelectorSilently: selector withMethod: compiledMethod.  self instanceSide noteAddedSelector: selector meta: self isMetaperform: aSymbol with: anObject  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: aSymbol withArguments: (Array with: anObject)timingPriorityUnschedule  beingWaitedOn := falsepushConstant: value  self push: valueclassToBeTested  ^Durationctrl  ^KMModifier ctrl + self/ aNumber  < primitive: 10>  aNumber isZero ifTrue: [ ^(ZeroDivide dividend: self) signal ].  ^(aNumber isMemberOf: SmallInteger) ifTrue: [ (Fraction numerator: self denominator: aNumber) reduced ] ifFalse: [ super / aNumber ]testNthRootErrorConditions  self should: [ -2 nthRoot: 1 / 4 ] raise: ArithmeticError.  self should: [ -2 nthRoot: 1.24 ] raise: ArithmeticErrorwantsChangeSetLogging  ^self instanceSide wantsChangeSetLoggingisInstanceSide  ^self isClassSide notobject: anObject instVarAt: anIndex  < primitive: 73>  ^self object: anObject basicAt: anIndex - (self objectClass: anObject) instSizeisAnonymous  ^self getName isNiltestBitShift  self assert: 2r11 << 2 equals: 2r1100.  self assert: (2r11 bitShift: 2) equals: 2r1100.  self assert: 2r1011 >> 2 equals: 2r10.  self assert: (2r1011 bitShift: -2) equals: 2r10methodsDo: aBlock  ^self methodDict valuesDo: aBlockgcd: anInteger  | higher u v k uHat vHat a b c d vPrime vPrimePrime q t |  higher := SmallInteger maxVal highBit.  u := self abs max: (v := anInteger abs).  v := self abs min: v.  [ v class == SmallInteger ] whileFalse: [ (uHat := u bitShift: (k := higher - u highBit)) class == SmallInteger ifFalse: [ k := k - 1.              uHat := uHat bitShift: -1 ].        vHat := v bitShift: k.        a := 1.        b := 0.        c := 0.        d := 1.        [ (vPrime := vHat + d) ~= 0 and: [ (vPrimePrime := vHat + c) ~= 0 and: [ (q := (uHat + a) // vPrimePrime) = ((uHat + b) // vPrime) ] ] ] whileTrue: [ c := a - (q * (a := c)).              d := b - (q * (b := d)).              vHat := uHat - (q * (uHat := vHat)) ].        b = 0 ifTrue: [ v := u rem: (u := v) ] ifFalse: [ t := u * a + (v * b).              v := u * c + (v * d).              u := t ] ].  ^v gcd: uwait: aDuration  | d |  d := DelayWaitTimeout new setDelay: aDuration asMilliSeconds forSemaphore: self.  ^d waitstoreOn: aStream base: base  | integer |  integer := self negative ifTrue: [ aStream nextPut: $-.        self negated ] ifFalse: [ self ].  base = 10 ifFalse: [ aStream           nextPutAll: base printString;           nextPut: $r ].  aStream nextPutAll: (integer printStringBase: base)rfvalueNoContextSwitch  < primitive: 209>  < metaLinkOptions: #(+ optionDisabledLink)>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  self primitiveFailedvariableNode  ^variableNodeisActive  ^self state = #activeprintCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod  aFileStream     cr;     nextPut: $!.  aFileStream nextChunkPut: (String streamContents: [:strm |  strm                 nextPutAll: self name;                 nextPutAll: ' methodsFor: ';                 print: category asString.              (changeStamp ~~ nil and: [ changeStamp size > 0 or: [ priorMethod ~~ nil ] ]) ifTrue: [ strm                       nextPutAll: ' stamp: ';                       print: changeStamp ].              priorMethod ~~ nil ifTrue: [ strm                       nextPutAll: ' prior: ';                       print: priorMethod sourcePointer ] ])isResumable  ^truegtInspectorIcon  ^self iconOrThumbnailOfSize: 16testNoTimeout  self assertSuccess: (ExceptionTester new runTest: #simpleNoTimeoutTest)timeZoneAbbreviation  ^self timeZone abbreviationisOwnerProcess  ^Processor activeProcess == ownerProcessincludesLocalSelector: aSymbol  ^self includesSelector: aSymboltestAsDateAndTime  self assert: aDateAndTime asDateAndTime equals: aDateAndTimeisAlphaNumeric  ^self isLetter or: [ self isDigit ]outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil  outerContext := aContext.  startpc := aStartpc.  numArgs := argCount.  1 to: self numCopiedValues do: [:i |  self at: i put: (anArrayOrNil at: i) ]removeAll  firstLink := lastLink := niltestSubclassInstanceVariableNames  | cls |  (testEnvironment includesKey: #SubclassExample) ifTrue: [ (testEnvironment at: #SubclassExample) removeFromSystem ].  self deny: (testEnvironment includesKey: #SubclassExample).  cls := Object subclass: #SubclassExample instanceVariableNames: 'x y'.  self assert: (testEnvironment includesKey: #SubclassExample).  self assert: (testEnvironment at: #SubclassExample) identicalTo: cls.  self assert: cls category equals: self unclassifiedCategory.  self assert: cls instVarNames equals: #('x' 'y').  cls removeFromSystemnotNil  ^falseresumableFallOffTheEndHandlerResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingExceptionalString;     add: self doYetAnotherThingString;     yourselfunschedule  self class scheduler unschedule: selfnumTemps  ^self compiledBlock numTempsdotProduct: aPoint  ^x * aPoint x + (y * aPoint y)< aCharacter  ^self asciiValue < aCharacter asciiValuedefinesSlot: aSlot  ^self slots identityIncludes: aSlotisEnclosingMark  ^self characterSet isEnclosingMark: selftestMax  | huge |  self assert: (2 max: 3) equals: 3.  huge := Float fmax asInteger + 1.  self assert: (Float fmax max: huge) equals: huge.  self assert: (1 / 3 max: 0.33333333333333333333333333333333333333333) equals: 1 / 3isMessageSend  ^truenanoSeconds  ^nanostestOrdersACollectionOfClassesBySuperclass  | ordered |  ordered := Class superclassOrder: (OrderedCollection with: ExampleForTest11 class with: ExampleForTest111 class with: ExampleForTest12 class with: ExampleForTest1 class with: ExampleForTest12 class with: ExampleForTest112 class).  self assert: (ordered indexOf: ExampleForTest1 class) < (ordered indexOf: ExampleForTest11 class).  self assert: (ordered indexOf: ExampleForTest11 class) < (ordered indexOf: ExampleForTest111 class).  self assert: (ordered indexOf: ExampleForTest11 class) < (ordered indexOf: ExampleForTest112 class).  self assert: (ordered indexOf: ExampleForTest1 class) < (ordered indexOf: ExampleForTest12 class)doSomethingExceptional  self log: self doSomethingExceptionalStringtestSizeInMemoryCompactClasses  self skip.  self assert: (Association key: 'aKey' value: 23) sizeInMemory equals: 12.  self assert: Rectangle new sizeInMemory equals: 12+ operand  | durationTicks |  durationTicks := operand asDuration ticks.  ^self class basicNew     setJdn: julianDayNumber + durationTicks first seconds: seconds + durationTicks second nano: nanos + durationTicks third offset: self offset;     yourselfgenStorePopLiteralVar: literalIndex  (literalIndex < 0 or: [ literalIndex > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 32768 ].  literalIndex > 255 ifTrue: [ self genUnsignedSingleExtendA: literalIndex // 256 ].  stream     nextPut: 241;     nextPut: literalIndex \\ 256initializeClass: aClass  self initialize.  organizedClass := aClass.  organizedClass selectors do: [:each |  self classify: each under: Protocol unclassified ]phlowValue: anObject  ^self cull: anObjectcontainsPoint: aPoint  ^origin <= aPoint and: [ aPoint < corner ]ownCategories  | traitsCategories |  traitsCategories := self subject traits inject: Set new into: [:set :trait |  set addAll: (trait organization protocolOrganizer protocols reject: [:eachProtocol |  self subject methods anySatisfy: [:eachMethod |  eachMethod origin = self subject and: [ eachMethod protocol = eachProtocol name ] ] ]).        set ].  ^((self protocolOrganizer protocols collect: #name) copyWithoutAll: (traitsCategories collect: #name)) asArraygenPop  stream nextPut: 135testMeridianAbbreviation  self assert: aTime meridianAbbreviation equals: 'PM'testDuration  self assert: aDateAndTime duration equals: 0 asDurationspecies  ^TimespantestIncludesAny  self deny: (aTimespan includesAnyOf: (Bag with: dec31)).  self assert: (aTimespan includesAnyOf: (Bag with: jan01 with: jan08))bindingOf: varName  ^self superclass bindingOf: varNameprivRefresh  closureOrNil ifNotNil: [ pc := closureOrNil startpc.        self stackp: closureOrNil numArgs + closureOrNil numCopiedValues.        1 to: closureOrNil numCopiedValues do: [:i |  self tempAt: closureOrNil numArgs + i put: (closureOrNil at: i) ] ] ifNil: [ pc := method initialPC.        self stackp: method numTemps.        method numArgs + 1 to: method numTemps do: [:i |  self tempAt: i put: nil ] ]popIntoTemporaryVariable: offset  self at: offset + 1 put: self popmightBeASquare  self subclassResponsibilitylongPrintOn: aStream  aStream     nextPutAll: '<<too complex to show>>';     crtestAsHour  | full half quarter |  full := Duration minutes: 60.  half := Duration minutes: 30.  quarter := Duration minutes: 15.  self     assert: 1 hour equals: full;     assert: 1.0 hour equals: full;     assert: 0.5 hour equals: half;     assert: (1 / 2) hour equals: half;     assert: (1 / 4) hour equals: quarteradoptInstance: anInstance  < primitive: 160 error: ec>  anInstance primitiveChangeClassTo: self basicNew.  ^selftestToByDo  asDuration  ^selfforArrays: anArray processWith: aBlock  collectionOfArrays := anArray.  resultProcessingBlock := aBlock.  buffer := Array new: anArray size.  self combineFromIdx: 1testDuration  self assert: aDateAndTime duration equals: 0 asDuration* aNumber  aNumber class = self class ifTrue: [ ^self asFraction * aNumber asFraction asScaledDecimal: (scale max: aNumber scale) ].  ^self coerce: self asFraction * aNumbermethodSelector  ^self method selectorsourcePointer  kind == #NativeCodeTrailer ifTrue: [ ^data at: 3 ].  ^(kind == #SourcePointer or: [ kind == #VarLengthSourcePointer ]) ifTrue: [ data ] ifFalse: [ 0 ]receiver  ^receiverserializeOn: anEncoder  anEncoder     encodeUint32: (self at: 1);     encodeUint32: (self at: 2)testIsClosePunctuation  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isClosePunctuation: ch) equals: (charset isClosePunctuation: ch) ]leftmost: aBlock tree: aTree  ^self callcc: [:skip |  self leftmost: aBlock tree: aTree continuation: skip ]referencingMethod2  ^{ExampleForTest12 .   ExampleForTest1}testDefinesSlotNamed  self assert: (Point definesSlotNamed: #x).  self deny: (Point definesSlotNamed: #z).  self assert: (Context definesSlotNamed: #stackp).  self deny: (Context definesSlotNamed: #sender)adaptToFraction: rcvr andCompare: selector  self isFinite ifFalse: [ selector == #= ifTrue: [ ^false ].        selector == #~= ifTrue: [ ^true ].        self isNaN ifTrue: [ ^false ].        (selector = #< or: [ selector = #<= ]) ifTrue: [ ^self positive ].        (selector = #> or: [ selector = #>= ]) ifTrue: [ ^self positive not ].        ^self error: 'unknow comparison selector' ].  selector == #= ifTrue: [ rcvr denominator isPowerOfTwo ifFalse: [ ^false ] ].  selector == #~= ifTrue: [ rcvr denominator isPowerOfTwo ifFalse: [ ^true ] ].  ^rcvr perform: selector with: self asTrueFractiontestMinutes  self assert: aDateAndTime minutes equals: 0manifestBuilderForRuleChecker: aRuleChecker  ^aRuleChecker manifestBuilderOfClass: selfsourceNodeForPC: aPC  | blockNode |  blockNode := self outerCode sourceNodeForPC: self pcInOuter.  ^blockNode sourceNodeForPC: aPCprepareForNewProcess: aProcess  ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock  self subclassResponsibilityisReturnAt: aPC  ^method encoderClass isReturnAt: aPC in: methodassertWithDescription: aStringOrABlock  | value |  self value ifTrue: [ ^self ].  value := aStringOrABlock value.  AssertionFailure signal: valuefloorLog: radix  (radix = 2 and: [ self > 0.0 ]) ifTrue: [ ^self exponent ].  ^(self log: radix) floorcommentsAt: selector  self deprecated: 'use #comments on the method instead' transformWith: '`@receiver commentsAt: `@argument' -> '(`@receiver compiledMethodAt: `@argument) comments'.  ^(self compiledMethodAt: selector) commentsisVirtualProtocol  ^truename: aString  name := aStringon: exception do: handlerAction  < primitive: 199>  ^self valuetestCanUnderstand  | c1 c2 |  c1 := Object subclass: 'MySuperclass' instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: self class category.  c1 compile: 'method1 ^self subclassResponsibility'.  c1 compile: 'method2 ^123'.  self assert: (c1 canUnderstand: #method1).  self assert: (c1 canUnderstand: #method2).  self deny: (c1 canUnderstand: #method3).  c2 := c1 subclass: 'MySubclass' instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self class category.  c2 compile: 'method1 ^ 3'.  c2 compile: 'method3 ^5'.  self assert: (c2 canUnderstand: #method1).  self assert: (c2 canUnderstand: #method3).  c2 removeFromSystem.  c1 removeFromSystemtestReadFromWithError  self should: [ Integer readFrom: 'invalid' ] raise: ErrorhighBit  ^self highBitOfMagnitudelog: aString  self log add: aStringtestTommorrow  self assert: DateAndTime today + 24 hours equals: DateAndTime tomorrow.  self deny: aDateAndTime equals: DateAndTime tomorrowangle  ^self y arcTan: self xtestValueWithinNonLocalReturnFixSimply  self valueWithinNonLocalReturn.  (Delay forMilliseconds: 50) waitsetUp  super setUp.  forkedProcesses := OrderedCollection new.  mutex := Mutex newgenDup  stream nextPut: 136species  ^TimespanasDateAndTime  ^DateAndTime date: self date time: self timebindAndJuggle: name  ReparseAfterSourceEditing signaltestParsingYYPatternReturnsASecondMillenaryYear  self assertReading: '2.11.13' as: 'd.mm.yy' equals: (Date year: 2013 month: 11 day: 2)isEmpty  ^kind == #NoTrailer or: [ kind == #ClearedTrailer ]classVariables  ^self classPool associationstestBasicPrinting  | printer |  printer := BasicDatePrinter new.  self assert: (String streamContents: [:s |  printer printDate: january23rd2004 format: #() on: s ]) equals: '2004-01-23'.  self assert: (String streamContents: [:s |  printer printDate: june2nd1973 format: #() on: s ]) equals: '1973-06-02'reachedDefaultHandler  ^reachedDefaultHandlerprintArgumentsCount: aNumber  ^aNumber printString , ' argument' , (aNumber = 1 ifTrue: [ '' ] ifFalse: [ 's' ])reduce  (self closeTo: self rounded) ifTrue: [ ^self rounded ]metacelloVersionComponentLessThan: aMetacelloVersonComponent  ^self error: 'Invalid Metacello verson component - should be String or Integer.'offset  ^offsetunwindComplete: aBoolean  self tempAt: 2 put: aBooleanraisedToFraction: aFraction  | root |  root := self nthRootTruncated: aFraction denominator.  (root raisedToInteger: aFraction denominator) = self ifTrue: [ ^root raisedToInteger: aFraction numerator ].  ^super raisedToFraction: aFractionweakSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory  ^self subclass: aName uses: aTraitComposition layout: WeakLayout slots: someInstanceVariableNames asSlotCollection classVariablesNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategoryisPrime  self <= 1 ifTrue: [ ^false ].  self even ifTrue: [ ^self = 2 ].  3 to: self sqrtFloor by: 2 do: [:each |  self \\ each = 0 ifTrue: [ ^false ] ].  ^trueinstVarAt: index  < primitive: 173 error: ec>  self primitiveFailedtestSubstracting02  | t |  t := '2004-01-07T11:55:00+00:00' asDateAndTime.  self assert: t - '2004-01-07T1:00:00+00:00' equals: (Duration fromString: '0:10:55:00')nearestPointOnLineFrom: p1 to: p2  ^(self nearestPointAlongLineFrom: p1 to: p2) adhereTo: (p1 rectangle: p2)testExample2  | method |  method := self class compiledMethodAt: #example2.  self deny: (self hasInstVarRef: method)spotterRePropertiesFor: aStep  < spotterOrder: 0>  ReSettings spotterPlugin ifFalse: [ ^self ].  aStep listProcessor     title: 'Renraku Properties';     items: [ self externalProperties asArray ];     itemName: #title;     itemIcon: #icon;     filter: GTFilterSubstringnegated  ^self copyto: (LargePositiveInteger new: self bytesCount)selectorsToBeIgnored  | private |  private := #(#printOn: #state:).  ^super selectorsToBeIgnored , privateshallowCopy  isEmpty  iterations isNil | elapsedTime isNil ifTrue: [ ^true ].  iterations isZero | elapsedTime isZero ifTrue: [ ^true ].  ^falsesetUp  super setUp.  atPragma := Pragma for: (Object methodDict at: #at:) selector: #primitive: arguments: (Array with: 60).  anotherAtPragma := Pragma for: (Object methodDict at: #at:) selector: #primitive: arguments: (Array with: 60).  yetAnotherAtPragma := Pragma for: (Object methodDict at: #at:) selector: #primitive: arguments: (Array with: 60).  atPutPragma := Pragma for: (Object methodDict at: #at:) selector: #primitive: arguments: (Array with: 61)even  ^((self byteAt: 1) bitAnd: 1) = 0testBeBetweenAnd  self assert: (10 beBetween: 5 and: 20) equals: 10.  self assert: (10 beBetween: 20 and: 5) equals: 10.  self assert: (5 beBetween: 5 and: 20) equals: 5.  self assert: (5 beBetween: 20 and: 5) equals: 5.  self assert: (20 beBetween: 5 and: 20) equals: 20.  self assert: (20 beBetween: 20 and: 5) equals: 20.  self assert: (1 beBetween: 5 and: 20) equals: 5.  self assert: (1 beBetween: 20 and: 5) equals: 5.  self assert: (30 beBetween: 5 and: 20) equals: 20.  self assert: (30 beBetween: 20 and: 5) equals: 20putOn: aStream  aStream nextPut: selfhours  ^Duration hours: selftestOneArgument  | m |  m := WeakMessageSend receiver: Array selector: #with: argument: 1.  Smalltalk garbageCollectMost.  self assert: m value equals: {1}fileOutCommentOn: aFileStream  self classComment ifNil: [ ^self ].  aFileStream     cr;     nextChunkPut: self classComment stringvariableByteSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self variableByteSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: catmethodsReferencingClass: aClass  ^self methodsReferencingClasses: {aClass}simpleRetryTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingString;     add: self doSomethingElseString;     yourselfallInstancesOrNil  < primitive: 177>  ^nilspotterMethodsFor: aStep  < spotterOrder: 10>  aStep listProcessor     title: 'Instance methods';     allCandidates: [ self methods ];     itemName: [:method |  method selector ];     filter: GTFilterSubstringtestBounds  self should: [ Delay forMilliseconds: -1 ] raise: Error.  Delay forMilliseconds: SmallInteger maxVal // 2 + 1.  Delay forMilliseconds: SmallInteger maxVal + 1.  (Delay forMilliseconds: Float pi) waitproperties: aMethodProperties  self literalAt: self numLiterals - 1 put: (aMethodProperties isEmpty ifTrue: [ aMethodProperties selector ] ifFalse: [ aMethodProperties                 setMethod: self;                 yourself ])datesDo: aBlock  self do: aBlock with: start asDategtListFilter  ^GTFilterSubstring newcull: arg1 cull: arg2  ^selector numArgs < 2 ifTrue: [ self cull: arg1 ] ifFalse: [ self value: arg1 value: arg2 ]hasLiteralThorough: literal  (self penultimateLiteral isMethodProperties and: [ self penultimateLiteral hasLiteralThorough: literal ]) ifTrue: [ ^true ].  2 to: self numLiterals - 1 do: [:index |  | lit |        (((lit := self objectAt: index) literalEqual: literal) or: [ lit isArray and: [ lit hasLiteral: literal ] ]) ifTrue: [ ^true ].        (lit isMemberOf: CompiledBlock) ifTrue: [ (lit hasLiteralThorough: literal) ifTrue: [ ^true ] ] ].  ^falselocalSeconds  ^seconds + self offset asSecondsisWords  ^self isBytes notspotterActDefault  ^self inspectisExternalType  ^falsespotterSuperclassesFor: aStep  < spotterOrder: 40>  aStep listProcessor     title: 'All superclasses';     allCandidates: [ self allSuperclasses ];     itemIcon: #systemIcon;     filter: GTFilterSubstringtestYearMonthDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1980 month: 1 day: 1 hour: 0 minute: 0 second: 0)allMethodSelectors  ^protocolOrganizer allMethodSelectorstestAsDateAndTime  self assert: aDateAndTime asDateAndTime equals: aDateAndTimesecondFromBottom  self sender ifNil: [ ^nil ].  ^self findContextSuchThat: [:context |  context sender sender isNil ]fractionPart  < primitive: 52>  ^self - self truncated asFloat// aNumber  ^(self / aNumber) floortestParsingDPatternWithTwoDigitSucceeds  self assertReading: '29.11.2013' as: 'd.mm.yyyy' equals: (Date year: 2013 month: 11 day: 29)genPushInteger: anInteger  anInteger = 0 ifTrue: [ stream nextPut: 80.        ^self ].  anInteger = 1 ifTrue: [ stream nextPut: 81.        ^self ].  (anInteger < 0 or: [ anInteger > 255 ]) ifTrue: [ ^self genPushIntegerLong: anInteger ].  stream     nextPut: 232;     nextPut: (anInteger bitAnd: 255)isStonReference  ^falseprimitiveError: aString  UIManager default onPrimitiveError: aStringtestNthRootTruncated  < timeout: 5>  | tooBigToBeAFloat large |  tooBigToBeAFloat := 1 << 2000.  self assert: (tooBigToBeAFloat nthRootTruncated: 100) equals: 1 << 20.  self assert: (tooBigToBeAFloat + 1 nthRootTruncated: 100) equals: 1 << 20.  self assert: (tooBigToBeAFloat - 1 nthRootTruncated: 100) equals: (1 << 20) - 1.  large := -3 raisedTo: 255.  self assert: (large nthRootTruncated: 17) equals: (-3 raisedTo: 15).  self assert: (large + 11 nthRootTruncated: 17) equals: (-3 raisedTo: 15) + 1.  self assert: (large - 11 nthRootTruncated: 17) equals: (-3 raisedTo: 15).  2 to: 10 do: [:thePower |  1 to: 10000 do: [:n |  | theTruncatedRoot |              theTruncatedRoot := n nthRootTruncated: thePower.              self assert: (theTruncatedRoot raisedTo: thePower) <= n.              self assert: (theTruncatedRoot + 1 raisedTo: thePower) > n ] ]testPrintOn  self assert: (String streamContents: [:str |  aStopwatch printOn: str ]) equals: 'a Stopwatch(suspended:0:00:00:00)'montgomeryDigitBase  ^1 << self montgomeryDigitLengthtestCompareWithIfLesserIfEqualIfGreater  self assert: ($b compareWith: $a ifLesser: [ 1 ] ifEqual: [ 2 ] ifGreater: [ 3 ]) equals: 3.  self assert: ($a compareWith: $b ifLesser: [ 1 ] ifEqual: [ 2 ] ifGreater: [ 3 ]) equals: 1.  self assert: ($b compareWith: $b ifLesser: [ 1 ] ifEqual: [ 2 ] ifGreater: [ 3 ]) equals: 2assertReading: aString as: aPattern equals: aDate  self assert: (self reading: aPattern pattern: aString) equals: aDatesunitAnnounce: aTestCase toResult: aTestResult  aTestResult addFailure: aTestCaseallTempNames  ^#()top  ^origin yasFilter  ^BlockFilter forBlock: selftestIfFalse  self assert: (false ifFalse: [ 'alternativeBlock' ]) equals: 'alternativeBlock'undeclaredName: anObject  undeclaredName := anObjectname  ^'Illegal dependency of Bootstrap Layer'mcWorkingCopy  MCWorkingCopy managersForClass: self do: [:package |  ^package ]shouldBePrintedAsLiteral  ^self asInteger between: 33 and: 255asDate  ^Date starting: selfroundUpTo: aNumber  ^(self / aNumber) ceiling * aNumberexternalCallFailed  | errCode |  errCode := ExternalFunction getLastError.  ^self error: (ExternalFunction errorMessageFor: errCode)testDivide  self assert: 1.5 / 2.0 equals: 0.75.  self assert: 2.0 / 1 equals: 2.0.  self should: [ 2.0 / 0 ] raise: ZeroDivide.  self should: [ 2.0 / 0.0 ] raise: ZeroDivide.  self should: [ 1.2 / Float negativeZero ] raise: ZeroDivide.  self should: [ 1.2 / (1.3 - 1.3) ] raise: ZeroDivideisLeapYear  ^start isLeapYearunusedBytecode: client at: startPC  ^client unusedBytecodesubject  ^organizedClasstestIsTitlecaseLetter  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isTitlecaseLetter: ch) equals: (charset isTitlecaseLetter: ch) ]testSizeInMemoryLargeInstances  self     assert: Smalltalk allClasses sizeInMemory equals: (self align64Bits: self headerSize + (3 * Smalltalk wordSize));     assert: Smalltalk allClasses asArray sizeInMemory equals: (self align64Bits: self headerSize + (Smalltalk allClasses asArray size * Smalltalk wordSize) + self headerSize)genReturnTop  stream nextPut: 92dayOfWeek  ^(self julianDayNumber + 1 rem: 7) + 1initialize  super initialize.  mutex := Semaphore forMutualExclusion.  queuesMutex := Semaphore forMutualExclusion.  nestingLevel := 0errorImproperStore  self error: 'Improper store into indexable object'testNext  self assert: aTimespan next equals: (Timespan starting: (DateAndTime year: 2003 month: 4 day: 8 hour: 0 minute: 0 second: 0) duration: aDuration)asEpiceaRingDefinition  | ring |  ring := (RGClassDefinition named: self name)     category: self category;     superclassName: self superclass asString;     traitCompositionSource: self traitCompositionString;     addInstanceVariables: self instVarNames;     addClassVariables: self classVarNames;     addSharedPools: self sharedPoolNames;     comment: self organization classComment;     stamp: self organization commentStamp;     definitionSource: self oldDefinition;     package: (EpPlatform current packageNameFor: self);     withMetaclass.  ring classSide     traitCompositionSource: self classSide traitCompositionString;     definitionSource: self classSide oldDefinition;     addInstanceVariables: self classSide instVarNames.  ^ringnowTick  ^vmSimNowtestUnixEpoch  self assert: DateAndTime unixEpoch equals: '1 January 1970 00:00+00:00' asDateAndTimeclassBuilder  ^self classInstaller new builderactivated  variable: anObject  variable := anObjecttestDivide  self assert: 2 / 1 equals: 2.  self assert: (3 / 2) isFraction.  self assert: 4 / 2 equals: 2.  self should: [ 1 / 0 ] raise: ZeroDividenegative  ^numerator negativetestEqualityInstanceSideMethod  | method1 method2 |  method1 := TestCase compiler compile: 'aMethod'.  method2 := TestCase compiler compile: 'aMethod'.  self assert: (method1 literalAt: method1 numLiterals) identicalTo: (method2 literalAt: method2 numLiterals).  self assert: method1 equals: method2addSlot: aSlot  ^self subclassResponsibilityenvironment: anEnvironment  environment := anEnvironmentinitialPC  ^(self numLiterals + 1) * Smalltalk wordSize + 1stringForFileOut  ^String streamContents: [:aStream |  self protocols do: [:p |  aStream                 nextPut: $(;                 nextPutAll: p name printString.              p methodSelectors do: [:m |  aStream                       space;                       nextPutAll: m ].              aStream                 nextPut: $);                 cr ] ]seconds  ^self secondidentityHash  ^self basicIdentityHashreset  protocols := IdentitySet new.  allProtocol := AllProtocol protocolOrganizer: selflogCrTab: aString  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver logCrTab: `@statements1' -> '`@receiver traceCrTab: `@statements1'.  self traceCrTab: aStringtestJulianDayNumber  self assert: aDateAndTime equals: (DateAndTime julianDayNumber: 2440588).  self assert: aDateAndTime julianDayNumber equals: 2440588montgomeryDigitMax  ^(1 << self montgomeryDigitLength) - 1haltIfNil  testToday  self deny: aDateAndTime equals: DateAndTime today/ arg  arg isPoint ifTrue: [ ^(x / arg x) @ (y / arg y) ].  ^arg adaptToPoint: self andSend: #/testEncodingZeroSourcePointer  | trailer |  trailer := CompiledMethodTrailer new.  self assert: (trailer sourcePointer: 0) testEncoding sourcePointer equals: 0standardMessageText  ^String streamContents: [:stream |  stream print: self signaler class.        stream << ' had the subclass responsibility to implement '.        stream print: self selector ]testStoreOn  | integer |  integer := 42.  self assert: (String streamContents: [:s |  integer storeOn: s ]) equals: '42'.  integer := -42.  self assert: (String streamContents: [:s |  integer storeOn: s ]) equals: ' -42'testTimeZone  aDateAndTime := '2004-02-29T13:33:00+00:00' asDateAndTime.  self assert: aDateAndTime timeZone name equals: 'Universal Time'.  self assert: aDateAndTime timeZone abbreviation equals: 'UTC'testWeeksDo  | weekArray |  weekArray := OrderedCollection new.  7 to: 98 by: 7 do: [:each |  weekArray addLast: (Week starting: (DateAndTime year: 2003 day: each) duration: 7 days) ].  weekArray := weekArray asArray.  self assert: aTimespan weeks equals: weekArrayabbreviation  ^abbreviationtestWithRecursion  self should: [ self recursion ] notTakeMoreThanMilliseconds: 3haltIfTest  < debuggerCompleteToSender>  Halt ifTestasDuration  ^Duration seconds: seconds nanoSeconds: nanosasSeconds  ^Duration seconds: selftestAddSlotAnonymous  | tutu |  tutu := Object newAnonymousSubclass.  self assert: tutu getName isNil.  tutu := tutu addSlot: #x => InstanceVariableSlot.  self assert: tutu instVarNames equals: #('x').  self assert: tutu getName isNil.  tutu := tutu addSlot: #y => InstanceVariableSlot.  self assert: tutu getName isNil.  self assert: tutu instVarNames equals: #('x' 'y')testAsWeek  self assert: aDateAndTime asWeek equals: ((Week starting: '02-29-2004' asDate) translateTo: 2 hours)asFraction  ^selfat: key put: value  | index |  index := self findElementOrNil: key.  (self basicAt: index) ifNil: [ tally := tally + 1.        self basicAt: index put: key ].  array at: index put: value.  key flushCache.  self fullCheck.  ^valuetestArithmetic  | laterDate |  laterDate := june2nd1973 addDays: 32.  self     assert: (laterDate subtractDate: june2nd1973) equals: 32;     assert: (june2nd1973 subtractDate: laterDate) equals: -32;     assert: (laterDate subtractDays: 32) equals: june2nd1973subclasses: aCollection  subclasses := aCollectiontestRuleFailsIfAnyNewExternalDependencyFound  | rule packageUnderTest critiques |  rule := PharoBootstrapRule new.  rule class classVarNamed: 'DependencyChecker' put: PharoBootstrapAnalyzerStubWithNewDependency.  packageUnderTest := RPackage named: #Kernel.  critiques := rule check: packageUnderTest.  self assert: critiques size equals: 1.  self assert: critiques anyOne sourceAnchor entity equals: packageUnderTestactionForEvent: anEventSelector  | actions |  actions := self actionMap at: anEventSelector asSymbol ifAbsent: [ ^nil ].  ^actions asMinimalRepresentationprintOn: aStream base: b nDigits: n  self printOn: aStream base: b length: n padded: trueallUnsentMessages  ^SystemNavigation new allUnsentMessagesIn: self selectorsgrow  | newSelf |  newSelf := self species newForCapacity: self basicSize * 2.  1 to: self basicSize do: [:i |  (self basicAt: i) ifNotNil: [:key |  newSelf at: key put: (array at: i) ] ].  self becomeForward: newSelfoverriddenMethods  | selector |  selector := self selector.  ^self methodClass allSuperclasses select: [:class |  class includesSelector: selector ] thenCollect: [:class |  class compiledMethodAt: selector ]elapsedTime: duration  elapsedTime := durationisClosure  ^trueprivRestartBlockArgsNoRemoteTempsTest  self assert: 30 equals: ([:a :first |  | b |        self assert: 10 equals: a.        self assert: nil identicalTo: b.        b := a + 20.        first ifTrue: [ thisContext tempAt: 2 put: false.              thisContext restart ].        b ] value: 10 value: true)simpleTimeoutTestResults  | things |  things := OrderedCollection new: self iterationsBeforeTimeout.  self iterationsBeforeTimeout timesRepeat: [ things add: self doSomethingString ].  things add: self doSomethingElseString.  ^thingspossibleVariablesFor: misspelled continuedFrom: oldResults  | results |  results := misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.  self sharedPools do: [:pool |  results := misspelled correctAgainstDictionary: pool classPool continuedFrom: results ].  self superclass == nil ifTrue: [ ^misspelled correctAgainstDictionary: self environment continuedFrom: results ] ifFalse: [ ^self superclass possibleVariablesFor: misspelled continuedFrom: results ]ifTrue: alternativeBlock  self subclassResponsibilitytestDayMonthYearDo  | iterations |  iterations := 0.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  iterations := iterations + 1 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear ]) equals: 1980.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay ]) equals: 1testAsYear  self assert: aDateAndTime asYear equals: ((Year starting: '02-29-2004' asDate) translateTo: 2 hours).  self assert: aDateAndTime asYear equals: ((Year starting: '01-01-2004' asDate) translateTo: 2 hours)setPoint: pt1 point: pt2  origin := (pt1 x min: pt2 x) @ (pt1 y min: pt2 y).  corner := (pt1 x max: pt2 x) @ (pt1 y max: pt2 y)testRemoveProperty  self class propertyAt: #testKeySelector put: 1.  self class removeProperty: #testKeySelector.  self assert: (self class propertyAt: #testKeySelector) equals: niltestOne  self     assert: Integer one equals: 1;     assert: Float one equals: 1.0;     assert: Fraction one equals: 1testBigReceiverInexactNthRoot  | bigNum result |  bigNum := (100 factorial raisedTo: 3) + 1.  self assert: bigNum asFloat isInfinite.  result := bigNum nthRoot: 3.  self assert: result isFloat.  self deny: result isInfinite.  self assert: result equals: 100 factorial asFloat.  self assert: 100 factorial asFloat equals: (100 factorial + 1) asFloatasAnnotationContext  ^SimpleAnnotationContext of: selfsourceNode  ^self astallSubclassesWithLevelDo: classAndLevelBlock startingLevel: level  | subclassNames |  classAndLevelBlock value: self value: level.  self == Class ifTrue: [ ^self ].  subclassNames := SortedCollection new.  self subclassesDo: [:subC |  subclassNames add: subC name ].  subclassNames do: [:name |  (self environment at: name) allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level + 1 ]fileOutOn: aFileStream  ^self fileOutOn: aFileStream initializing: trueisOctetCharacter  ^self asInteger < 256testTommorrow  self assert: DateAndTime today + 24 hours equals: DateAndTime tomorrow.  self deny: aDateAndTime equals: DateAndTime tomorrowsignBit  self < 0 ifTrue: [ ^1 ].  ^0printOn: aStream base: base  base = 10 ifFalse: [ self error: 'ScaledDecimals should be printed only in base 10' ].  self printOn: aStreammillisecondsUntilTick: microsecondsTick  ^microsecondsTick - self nowTick max: 0basicCategory: aSymbol  category := aSymboltestMinVal  Smalltalk vm wordSize = 4 ifTrue: [ self assert: SmallInteger minVal equals: -16r40000000 ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: SmallInteger minVal equals: -16r1000000000000000 ]asDoubleLink  ^DoubleLink value: selftestIsOtherPunctuation  self checkCorrespondanceOf: #isOtherPunctuation: and: #PotruncateTo: aNumber  ^(self quo: aNumber) * aNumberisDefined  ^self isUndefined notunwindBlock  ^self tempAt: 1testPreviousInLeapYear  | leap |  leap := Year year: 2008.  self assert: leap isLeapYear.  self assert: (Year year: leap year - 1) equals: leap previoustestPreviousNext  self     assert: week next equals: (Week starting: '6 July 1998' asDate);     assert: week previous equals: (Week starting: '22 June 1998' asDate)weakSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self weakSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: catallInstances  < primitive: 177>  | inst insts next |  insts := WriteStream on: (Array new: 64).  inst := self someInstance.  [ inst == nil ] whileFalse: [ next := inst nextInstance.        (inst == insts or: [ inst == insts originalContents ]) ifFalse: [ insts nextPut: inst ].        inst := next ].  ^insts contentsasFloat  | mantissa shift excess result n |  excess := self highBitOfMagnitude - Float precision.  excess > 7 ifTrue: [ mantissa := self bitShiftMagnitude: 7 - excess.        shift := excess - 7.        ((mantissa byteAt: 1) = 2r01000000 and: [ self anyBitOfMagnitudeFrom: 1 to: shift ]) ifTrue: [ mantissa := mantissa + 1 ] ] ifFalse: [ mantissa := self.        shift := 0 ].  result := (mantissa byteAt: (n := mantissa bytesCount)) asFloat.  [ (n := n - 1) > 0 ] whileTrue: [ result := 256.0 * result + (mantissa byteAt: n) asFloat ].  ^result timesTwoPower: shiftterminateTo: previousContext  < primitive: 196>  | currentContext sendingContext |  (self hasSender: previousContext) ifTrue: [ currentContext := sender.        [ currentContext == previousContext ] whileFalse: [ sendingContext := currentContext sender.              currentContext terminate.              currentContext := sendingContext ] ].  sender := previousContextbrickValue: anObject withEnoughArguments: aCollection  ^anObject withArgs: aCollection executeMethod: selfcaseOf: aBlockAssociationCollection  ^self caseOf: aBlockAssociationCollection otherwise: [ self caseError ]testUnwindFromForeignProcess  | sema process |  sema := Semaphore forMutualExclusion.  self assert: sema isSignaled.  process := [ sema critical: [ self deny: sema isSignaled.        sema wait ] ] forkAt: Processor userInterruptPriority.  self deny: sema isSignaled.  process terminate.  self assert: sema isSignaledbeBetween: minValue and: maxValue  ^minValue <= maxValue ifTrue: [ (self min: maxValue) max: minValue ] ifFalse: [ (self min: minValue) max: maxValue ]testIsNil  self assert: nil isNilmatchesQueryBrowserFilter: aQueryBrowserFilter  ^self calypsoEnvironmentType match: self forQueryBrowserFilter: aQueryBrowserFiltercrLog  self deprecated: 'Please use #crTrace instead' transformWith: '`@receiver crLog' -> '`@receiver crTrace'.  self crTracetestSeconds  self assert: aDuration seconds equals: 4.  self assert: (Duration nanoSeconds: 2) seconds equals: 0.  self assert: (Duration seconds: 2) seconds equals: 2.  self assert: (Duration days: 1 hours: 2 minutes: 3 seconds: 4) seconds equals: 4.  self deny: (Duration days: 1 hours: 2 minutes: 3 seconds: 4) seconds equals: 1 * 24 * 60 * 60 + (2 * 60 * 60) + (3 * 60) + 4fileOutChangedMessages: aSet on: aFileStream  | org |  (org := self organization) categories do: [:cat |  | sels |        sels := (org listAtCategoryNamed: cat) select: [:sel |  aSet includes: sel ].        sels do: [:sel |  self printMethodChunk: sel on: aFileStream ] ]waitWhile: aBlock maxMilliseconds: anIntegerOrNil  ^self waitWhile: aBlock for: nil maxMilliseconds: anIntegerOrNilwaddle: aTree  ^(aTree isNotNil and: [ aTree isMemberOf: ValueLink ]) ifTrue: [ | car cdr |        car := aTree value.        cdr := aTree nextLink.        (car isKindOf: Link) ifTrue: [ self waddle: car ] ifFalse: [ Continuation currentDo: [:rest |  fill := rest.                    leave value: car ] ].        self waddle: cdr ]hasModelYellowButtonMenuItems  ^Morph cmdGesturesEnabledstonOn: stonWriter  stonWriter writeFraction: selfcritical: mutuallyExcludedBlock ifError: errorBlock  | blockValue hasError errMsg errRcvr |  hasError := false.  self critical: [ blockValue := mutuallyExcludedBlock ifError: [:msg :rcvr |  hasError := true.              errMsg := msg.              errRcvr := rcvr ] ].  hasError ifTrue: [ ^errorBlock cull: errMsg cull: errRcvr ].  ^blockValuetestParsingYPatternWithSingleDigitReturnsASecondMillenaryYear  self assertReading: '2.11.3' as: 'd.mm.y' equals: (Date year: 2003 month: 11 day: 2)javascriptOn: aStream  aStream nextPutAll: 'new Date('.  #(year javascriptMonthIndex dayOfMonth) do: [:each |  aStream javascript: (self perform: each) ] separatedBy: [ aStream nextPut: $, ].  aStream nextPut: $)isPowerOfTwo  ^self ~= 0 and: [ (self bitAnd: self - 1) = 0 ]exp  < primitive: 59>  | base fract correction delta div |  self < 0.0 ifTrue: [ ^self negated exp reciprocal ].  self = 0.0 ifTrue: [ ^1 ].  self abs > MaxValLn ifTrue: [ self error: 'exp overflow' ].  base := E raisedToInteger: self truncated.  fract := self fractionPart.  fract = 0.0 ifTrue: [ ^base ].  correction := 1.0 + fract.  delta := fract * fract / 2.0.  div := 2.0.  [ delta > Epsilon ] whileTrue: [ correction := correction + delta.        div := div + 1.0.        delta := delta * fract / div ].  correction := correction + delta.  ^base * correctiontestInheritingExecutionEnvironment  | newEnv p |  newEnv := ExecutionEnvironmentStub new.  newEnv beActiveDuring: [ p := [ self assert: CurrentExecutionEnvironment value equals: newEnv ] fork ].  self assert: newEnv forkedProcesses anyOne equals: pcompactWithoutBecome  | newInstance |  newInstance := self species new: self size.  1 to: self basicSize do: [:index |  (self basicAt: index) ifNotNil: [:key |  newInstance at: key put: (array at: index) ] ].  ^newInstance\\ aNumber  ^self - (self // aNumber * aNumber)testParsingDDPatternWithIncorrectDaysFails  self assertReading: '02.00.2013' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.13.2013' as: 'dd.mm.yyyy' raise: DateErrorvariableSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory  ^self subclass: aName uses: aTraitComposition layout: VariableLayout slots: someInstanceVariableNames asSlotCollection classVariablesNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategorylocalAt: aNumber  ^self at: aNumbertriangleArea: b with: c  ^(b x - self x) * (c y - self y) - ((b y - self y) * (c x - self x))testDay  self assert: aDateAndTime day equals: DateAndTime new daytestDaysInMonth  self assert: aDateAndTime daysInMonth equals: 29terminate  sender := nil.  pc := nilclassAnnotationAt: selector  ^self classAnnotations detect: [:each |  each declarationSelector = selector ]isFloatPoint  ^x isFloat and: [ y isFloat ]fuelAccept: aGeneralMapper  ^aGeneralMapper visitHookPrimitive: selfrotateBy: angle about: center  | p r theta |  p := self - center.  r := p r.  theta := angle asFloat - p theta.  ^(center x asFloat + (r * theta cos)) @ (center y asFloat - (r * theta sin))raisedToInteger: aNumber  ^self class newFromNumber: (super raisedToInteger: aNumber) scale: scalepaintFillsUsing: aPaint on: anAthensCanvas  ^aPaint athensFillRectangle: self on: anAthensCanvasas31BitSmallInt  self highBit = 31 ifFalse: [ self error: 'more than 31 bits can not fit in a SmallInteger' ].  ^self - 16r80000000hasProperty: aKey  self propertyAt: aKey ifAbsent: [ ^false ].  ^truesystemClassNames  ^#(BoxedFloat64 SmallFloat64)ifNotNil: ifNotNilBlock ifNil: nilBlock  ^ifNotNilBlock cull: selftestDaysInMonth  self assert: (Month daysInMonth: 2 forYear: 2000) equals: 29.  self assert: (Month daysInMonth: 2 forYear: 2001) equals: 28.  self assert: (Month daysInMonth: 2 forYear: 2004) equals: 29.  self assert: (Month daysInMonth: 2 forYear: 2100) equals: 28.  self assert: (Month daysInMonth: 'January' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'February' forYear: 2003) equals: 28.  self assert: (Month daysInMonth: 'March' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'April' forYear: 2003) equals: 30.  self assert: (Month daysInMonth: 'May' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'June' forYear: 2003) equals: 30.  self assert: (Month daysInMonth: 'July' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'August' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'September' forYear: 2003) equals: 30.  self assert: (Month daysInMonth: 'October' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'November' forYear: 2003) equals: 30.  self assert: (Month daysInMonth: 'December' forYear: 2003) equals: 31hour  ^self hour24initializeBasicMethods  testMonthsDo  | monthArray |  monthArray := Array with: (Month starting: (DateAndTime year: 2004 day: 355) duration: 31 days) with: (Month starting: (DateAndTime year: 2005 day: 1) duration: 31 days) with: (Month starting: (DateAndTime year: 2005 day: 32) duration: 29 days) with: (Month starting: (DateAndTime year: 2005 day: 61) duration: 31 days).  self assert: aTimespan months equals: monthArrayhash  ^receiver hash bitXor: selector hashlongPrintString  | str |  str := String streamContents: [:aStream |  self longPrintOn: aStream ].  ^str isEmpty ifTrue: [ self printString , String cr ] ifFalse: [ str ]allMethods  ^self allSelectors asArray collect: [:s |  self lookupSelector: s ]phlowValue: anObject value: otherObject  ^anObjectinstVarsInclude: anObject  < primitive: 132>  1 to: self class instSize do: [:i |  (self instVarAt: i) == anObject ifTrue: [ ^true ] ].  1 to: self basicSize do: [:i |  (self basicAt: i) == anObject ifTrue: [ ^true ] ].  ^falsetestOrigin  | regularMethod methodFromTrait |  regularMethod := Behavior >> #name.  methodFromTrait := Behavior >> #adoptInstance:.  self assert: regularMethod origin identicalTo: regularMethod originMethod methodClass.  self assert: methodFromTrait origin identicalTo: methodFromTrait originMethod methodClasstestPrimesUpTo  | primes nn |  primes := Integer primesUpTo: 100.  self assert: primes equals: #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97).  primes := Integer primesUpTo: 5.  self assert: primes equals: #(2 3).  nn := 5.  self deny: (Integer primesUpTo: nn) last equals: nn.  self assert: (Integer primesUpTo: nn + 1) last equals: nntestIsNil  self deny: ProtoObject new isNiltestPrintString  | dt dtNoOffset |  dt := DateAndTime year: 2004 month: 11 day: 2 hour: 14 minute: 3 second: 5 nanoSecond: 12345 offset: (Duration seconds: 5 * 3600).  self assert: dt printString equals: '2004-11-02T14:03:05.000012345+05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: ' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime printString equals: '2002-05-16T17:20:45+00:00'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime printString equals: '2002-05-16T17:20:45-02:34'.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime printString equals: '2002-05-16T17:20:45+00:00'.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime printString equals: '1997-04-26T01:02:03+01:02:3'.  dtNoOffset := '2002-05-16T17:20' asDateAndTime.  self assert: (('2002-05-16T17:20:00*' match: dtNoOffset printString) and: [ dtNoOffset offset = DateAndTime localOffset ])hash  | initialPC endPC hash |  initialPC := self initialPC.  endPC := self endPC.  hash := self species hash + self header + initialPC + endPC.  initialPC to: endPC by: ((endPC - initialPC) // 20 max: 1) do: [:i |  hash := hash + (self at: i) ].  ^hashtestReadFromWithError  | string |  string := 'invalid'.  self should: [ self timeClass readFrom: string readStream ] raise: Error.  string := '0:invalid'.  self should: [ self timeClass readFrom: string readStream ] raise: Errory  ^ygenBranchPopTrue: distance  (distance > 0 and: [ distance < 9 ]) ifTrue: [ stream nextPut: 183 + distance.        ^self ].  ^self genBranchPopTrueLong: distancetestMutateWideStringUsingWordAtPut  | guineaPig |  guineaPig := 'hello' asWideString.  guineaPig beReadOnlyObject.  self should: [ guineaPig wordAt: 1 put: 65536 ] raise: ModificationForbidden.  [ guineaPig wordAt: 1 put: 65536 ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first asciiValue equals: 65536phlowValue: anObject  ^selfnextObject  < primitive: 139>  self primitiveFailedspotterClassMethodsFor: aStep  < spotterOrder: 15>  aStep listProcessor     title: 'Class methods';     allCandidates: [ self classSide methods ];     itemName: [:method |  method selector ];     filter: GTFilterSubstringpluralize: aSingularString  ^self pluralize: aSingularString with: (GRInflector pluralize: aSingularString)simplePassTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:ex |  self doYetAnotherThing.        ex pass ]asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackages: packsBoolean  | rgClass rgSlice rgPackageKeys |  rgSlice := RGSlice named: #fromImage.  packsBoolean ifTrue: [ rgPackageKeys := rgSlice loadPackagesFromImage ].  rgClass := self asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: rgPackageKeys in: rgSlice.  rgSlice cleanEmptyPackages.  rgSlice loadTraitUsers.  ^rgClasstestEmbeddingCompressedSourceCode  | trailer newTrailer code |  trailer := CompiledMethodTrailer new.  code := 'foo'.  trailer compressSourceCode: code.  newTrailer := trailer testEncoding.  self assert: trailer kind identicalTo: #EmbeddedSourceQCompress.  self assert: newTrailer sourceCode equals: code.  self assert: newTrailer endPC equals: 0.  code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: newTrailer sourceCode equals: code.'.  trailer compressSourceCode: code.  self assert: trailer kind identicalTo: #EmbeddedSourceZip.  newTrailer := trailer testEncoding.  self assert: newTrailer sourceCode equals: code.  self assert: newTrailer endPC equals: 0testAllSelectorsAbove  | sels |  sels := Date allSelectorsAbove.  self deny: (sels includes: #mmddyyyy).  self deny: (sels includes: #weekday).  self assert: (sels includes: #at:).  self assert: (sels includes: #cannotInterpret:)methodClass  ^self method methodClass ifNil: [ self receiver class ]rename: aString  | oldName newName |  (newName := aString asSymbol) = (oldName := self name) ifTrue: [ ^self ].  (self environment includesKey: newName) ifTrue: [ ^self error: newName , ' already exists' ].  self setName: newName.  self environment renameClass: self from: oldName.  (Undeclared includesKey: newName) ifTrue: [ self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.' ]longPrintOn: stream  | ctxt |  super printOn: stream.  stream cr.  ctxt := self suspendedContext.  [ ctxt isNil ] whileFalse: [ stream space.        ctxt printOn: stream.        stream cr.        ctxt := ctxt sender ]reciprocalFloorLog: radix  | adjust scale n |  adjust := 0.  scale := 1.0.  [ (n := radix / (self * scale)) isInfinite ] whileTrue: [ scale := scale * radix.        adjust := adjust + 1 ].  ^((n floorLog: radix) + adjust) negated/ aNumber  self subclassResponsibilitytemporaryVariables  ^self tempNames collect: [:name |  TemporaryVariable new name: name ]testcurrentYearNumber  | yyyy |  yyyy := Year currentYearNumber.  self assert: Date today year equals: yyyyfuelAccept: aGeneralMapper  ^aGeneralMapper visitCompiledMethod: selfprimOffset  < primitive: 'primitiveTimezoneOffset' module: 'LocalePlugin'>  ^0testMonthsDo  | monthArray |  monthArray := Array with: (Month starting: (DateAndTime year: 2003 day: 1) duration: 31 days) with: (Month starting: (DateAndTime year: 2003 day: 32) duration: 28 days) with: (Month starting: (DateAndTime year: 2003 day: 60) duration: 31 days) with: (Month starting: (DateAndTime year: 2003 day: 91) duration: 30 days).  self assert: aTimespan months equals: monthArraytestTimeZone  self assert: aDateAndTime timeZoneName equals: 'Universal Time'.  self assert: aDateAndTime timeZoneAbbreviation equals: 'UTC'testPropertyValueAtPut  | testValue |  testValue := Date today.  self class propertyAt: #testKeySelector put: testValue.  self assert: (self class propertyAt: #testKeySelector) equals: testValue.  self class removeProperty: #testKeySelectornot  ^falseremoveSubclass: aSubclass  self subclasses == nil ifFalse: [ self subclasses: (self subclasses copyWithout: aSubclass).        self subclasses isEmpty ifTrue: [ self subclasses: nil ] ]yield  < primitive: 167>  | semaphore |  semaphore := Semaphore new.  [ semaphore signal ] fork.  semaphore waitisResumable  ^trueinternalChangeFromString: categorySpecs  protocolOrganizer := ProtocolOrganizer fromSpec: categorySpecshome  ^outerContext ifNotNil: [ outerContext home ]asDays  ^self asHours / 24absPrintOn: aStream base: base digitCount: digitCount  | fuzz x exp q fBase scale logScale xi |  self isInfinite ifTrue: [ ^aStream nextPutAll: 'Infinity' ].  fBase := base asFloat.  exp := self floorLog: fBase.  scale := 1.0.  logScale := 0.  [ (x := fBase raisedTo: exp + logScale) = 0 ] whileTrue: [ scale := scale * fBase.        logScale := logScale + 1 ].  x := self * scale / x.  fuzz := fBase raisedTo: 1 - digitCount.  x := 0.5 * fuzz + x.  x >= fBase ifTrue: [ x := x / fBase.        exp := exp + 1 ].  (exp < 6 and: [ exp > -4 ]) ifTrue: [ q := 0.        exp < 0 ifTrue: [ 1 to: 1 - exp do: [:i |  aStream nextPut: ('0.0000' at: i) ] ] ] ifFalse: [ q := exp.        exp := 0 ].  [ x >= fuzz ] whileTrue: [ xi := x asInteger.        aStream nextPut: (Character digitValue: xi).        x := (x - xi asFloat) * fBase.        fuzz := fuzz * fBase.        exp := exp - 1.        exp = -1 ifTrue: [ aStream nextPut: $. ] ].  [ exp >= -1 ] whileTrue: [ aStream nextPut: $0.        exp := exp - 1.        exp = -1 ifTrue: [ aStream nextPut: $. ] ].  q ~= 0 ifTrue: [ aStream nextPut: $e.        q printOn: aStream ]sourceCode: aString  ^self embeddedSourceCode: aStringbottomContext  ^self findContextSuchThat: [:context |  context sender isNil ]removePropertiesIfEmpty  ^ClassProperties at: self ifPresent: [:dict |  dict ifEmpty: [ ClassProperties removeKey: self ] ]testParsingDPatternWithIncorrectDayFails  self assertReading: '0.11.2013' as: 'd.mm.yyyy' raise: DateError.  self assertReading: '32.2013.29' as: 'd.mm.yyyy' raise: DateErrornotNil  ^truetruncated  ^self species basicNew ticks: {julianDayNumber .         seconds .         0} offset: offsetisProbablyPrime  | k q randomNumbers |  self <= 1 ifTrue: [ ^false ].  self even ifTrue: [ ^self = 2 ].  q := self bitShift: -1.  k := q lowBit.  q := q bitShift: 1 - k.  randomNumbers := #(0.816980664067427 0.9940209812456839 0.5106317962103671 0.18859890764048273 0.7818407135931034 0.39687335928756434 0.25054954609393587 0.9862212007801148 0.41972151138806785 0.25944189925652084 0.44000080434605515 0.09351864414919105 0.7678522154539136 0.292185133924794 0.7555458740124227 0.4595045267881381 0.8925817282370206 0.621106479606175 0.9366027409846908 0.48226772969694237 0.47373301651036975 0.030808489784043512 0.7982878004192784 0.8230616468112272 0.19709795629470514).  randomNumbers do: [:rnd |  (self isProbablyPrimeWithK: k andQ: q randomIndex: rnd) ifFalse: [ ^false ] ].  ^trueasClassDefinition  self needsSlotClassDefinition ifFalse: [ ^MCClassDefinition name: self name superclassName: (self superclass ifNil: [ nil asString ] ifNotNil: [ self superclass name ]) traitComposition: self traitCompositionString classTraitComposition: self class traitCompositionString category: self category instVarNames: (self localSlots collect: #name) classVarNames: self classVarNames poolDictionaryNames: self sharedPoolNames classInstVarNames: (self class localSlots collect: #name) type: self typeOfClass comment: self organization classComment asString commentStamp: self organization commentStamp ].  ^MCClassDefinition name: self name superclassName: (self superclass ifNil: [ nil asString ] ifNotNil: [ self superclass name ]) traitComposition: self traitCompositionString classTraitComposition: self class traitCompositionString category: self category instVarNames: (self localSlots collect: #definitionString) classVarNames: (self classVariables collect: #definitionString) poolDictionaryNames: self sharedPoolNames classInstVarNames: (self class localSlots collect: #definitionString) type: self typeOfClass comment: self organization classComment asString commentStamp: self organization commentStamparguments  | arguments numargs |  numargs := self method numArgs.  arguments := Array new: numargs.  1 to: numargs do: [:i |  arguments at: i put: (self tempAt: i) ].  ^argumentsisReceiverGarbage  ^self receiver isNil= other  self == other ifTrue: [ ^true ].  self species = other species ifFalse: [ ^false ].  ^self hasEqualTicks: otherctrl  ^KMModifier ctrl + selfasCalypsoBrowserItem  ^self calypsoEnvironmentType convertToCalypsoBrowserItem: selfbaseClass  self deprecated: 'Please use #instanceSide instead' transformWith: '`@receiver baseClass' -> '`@receiver instanceSide'.  ^self instanceSidetestNew  self assert: self timeClass new asSeconds equals: 0assertInvariant  [ elementArray size = categoryStops last ] asserttestSupplySameAnswerToAllQuestions  self should: [ true = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: true) ].  self should: [ #(true true) = ([ {(self confirm: 'One') .               (self confirm: 'Two')} ] valueSupplyingAnswer: true) ]asExternalTypeOn: generator  ^FFIConst value: self type: (generator resolveType: #int32)gtInspectorDefinitionIn: composite  < gtInspectorPresentationOrder: 15>  composite pharoScript     title: 'Definition';     display: [ self definition ]monthsDo: aBlock  self do: aBlock with: start asMonthtestTo  self assert: (aDateAndTime to: aDateAndTime) equals: (DateAndTime new to: DateAndTime new)julianDayNumberUTC  ^start julianDayNumberUTCprintOn: aStream  aStream     nextPutAll: self class name;     nextPut: $(.  selector printOn: aStream.  aStream nextPutAll: ' -> '.  receiver printOn: aStream.  aStream nextPut: $)testPrintStringNanos  self assert: (Time hour: 15 minute: 15 second: 15 nanoSecond: 150 * 1000000) printString equals: '3:15:15.15 pm'asUnicodeChar  ^Unicode charFromUnicode: self asUnicodelink: aMetaLink toSlotNamed: aSlotName option: option  aMetaLink installOnSlotNamed: aSlotName for: self option: option instanceSpecific: self intanceSpecificMetaLinksAvailabletestDegreeCos  45 degreeCos.  self assert: (45 degreeCos squared - (1 / 2)) abs <= Float epsilon.  self assert: (60 degreeCos - (1 / 2)) abs <= Float epsilon.  self assert: (120 degreeCos + (1 / 2)) abs <= Float epsilon.  -360 to: 360 do: [:i |  self assert: (i degreeCos closeTo: i degreesToRadians cos) ].  -10 to: 10 do: [:k |  self assert: (k * 360 + 90) degreeCos equals: 0.        self assert: (k * 360 - 90) degreeCos equals: 0.        self assert: (k * 360 + 180) degreeCos + 1 equals: 0.        self assert: (k * 360) degreeCos - 1 equals: 0 ]asByteArray  | stream |  stream := ByteArray new writeStream.  self bytesCount to: 1 by: -1 do: [:digitIndex |  stream nextPut: (self byteAt: digitIndex) ].  ^stream contentsgenSendSpecial: specialSelectorIndex numArgs: nArgs  self assert: (specialSelectorIndex between: 1 and: Smalltalk specialSelectorSize).  self assert: nArgs = (Smalltalk specialNargsAt: specialSelectorIndex).  stream nextPut: specialSelectorIndex + 175testParsingDDPatternWithSingleDigitFails  self assertReading: '4.02.2345' as: 'dd.mm.yyyy' raise: DateErrordescription  ^String streamContents: [:stream |  | mt |        stream << self class name.        (mt := self messageText) isEmptyOrNil ifFalse: [ stream << ': ' << mt ] ]asLocal  ^self offset = self class localOffset ifTrue: [ self ] ifFalse: [ self offset: self class localOffset ]phlowValue: anObject value: otherObject  ^selftemporaryVariableNamed: aName  (self hasTemporaryVariableNamed: aName) ifFalse: [ ^nil ].  ^TemporaryVariable name: aName block: selfwait  self schedule.  [ delaySemaphore wait ] ifCurtailed: [ self unschedule ]testNthRootExactness  | inexactRoots largeExactPowersOf6 |  largeExactPowersOf6 := (2 to: 100) collect: [:k |  k raisedTo: 66 ].  inexactRoots := largeExactPowersOf6 reject: [:e |  (e nthRoot: 6) isInteger ].  self assert: inexactRoots isEmpty description: 'Failed to find the exact 6th root of these numbers'complexContents  ^selfhasArguments  ^args notEmptyrealClass  ^self methodClasstestIsSpaceSeparator  self checkCorrespondanceOf: #isSpaceSeparator: and: #ZssendingMethodName  ^self contextOfSender method printString| aBoolean  self subclassResponsibilitytestEncoding  encodedData ifNil: [ self encode ].  ^CompiledMethodTrailer new method: encodedDatanewProcessWith: anArray  < primitive: 19>  ^Process forContext: [ self valueWithArguments: anArray.        Processor terminateActive ] asContext priority: Processor activePriorityidentityHash  ^self hashMultiplyhumanReadableSIByteSizeOn: s  | exponent base |  base := 1000.  self < base ifTrue: [ ^s           print: self;           space;           nextPut: $B ].  exponent := (self log / base log) asInteger.  self / (base ** exponent) printOn: s showingDecimalPlaces: 2.  s     space;     nextPut: ('kMGTPE' at: exponent);     nextPut: $BencodeEmbeddedSource  | length str encodedLength |  length := data size.  str := WriteStream on: (ByteArray new: length).  encodedLength := self encodeLengthField: length.  str     nextPutAll: data asByteArray;     nextPutAll: encodedLength;     nextPut: self kindAsByte + encodedLength size - 1.  encodedData := str contentsast  ^self sourceNodeInOuterreadClassVariableNamed: aString  ^(self classVariableNamed: aString) readsetUp  super setUp.  value := 0stonContainSubObjects  ^falsecopyAll: selArray from: class classified: cat  selArray do: [:s |  (class includesLocalSelector: s) ifTrue: [ self copy: s from: class classified: cat ] ]quo: aNumber  < primitive: 13>  aNumber = 0 ifTrue: [ ^(ZeroDivide dividend: self) signal ].  (aNumber isMemberOf: SmallInteger) ifFalse: [ ^super quo: aNumber ].  (aNumber = -1 and: [ self = self class minVal ]) ifTrue: [ ^self negated ].  self primitiveFailedstoreStringBase: base length: minimum padded: zeroFlag  ^String streamContents: [:s |  self storeOn: s base: base length: minimum padded: zeroFlag ]asInteger  ^selftagsForAllMethods  | allProtocols |  allProtocols := self organization protocols reject: [:each |  each name = Protocol unclassified | each isExtensionProtocol ].  ^allProtocols select: [:protocol |  protocol methodSelectors ifEmpty: [ true ] ifNotEmpty: [:methods |  methods anySatisfy: [:method |  self selectors includes: method ] ] ] thenCollect: #nameisRequired  ^self isRequired: self markerOrNilscaleTo: anExtent  | factor sX sY |  factor := 3.0 reciprocal.  sX := anExtent x / self x asFloat.  sY := anExtent y / self y asFloat.  sX = sY ifTrue: [ ^sX @ sY ].  ^sX < sY ifTrue: [ sX @ (sX max: sY * factor) ] ifFalse: [ (sY max: sX * factor) @ sY ]testIsOtherLetter  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isOtherLetter: ch) equals: (charset isOtherLetter: ch) ]testBenchFor  | benchmarkResult duration minimumIterations |  duration := 500 milliSeconds.  benchmarkResult := [ 100 factorial ] benchFor: duration.  self deny: benchmarkResult isEmpty.  self assert: benchmarkResult elapsedTime >= duration.  minimumIterations := 10.  self assert: benchmarkResult iterations > minimumIterations.  self assert: benchmarkResult period < (duration / minimumIterations)testDigitSumOnNegative  self assert: -1234 digitSum equals: 10readXandY  ^x + ytestTerminationShouldProceedAllEnsureBlocksIfSomeWasFailed  | ensureCalled process ensureFailure forkedFailures started |  ensureFailure := Error new messageText: 'signalled inside ensure'.  ensureCalled := false.  started := false.  process := [ [ [ started := true.  10 seconds wait ] ensure: [ ensureFailure signal ] ] ensure: [ ensureCalled := true ] ] fork.  [ started ] whileFalse: [ Processor yield ].  process terminate.  Processor yield.  self assert: ensureCalled.  forkedFailures := TestExecutionEnvironment currentFailures.  self assert: forkedFailures size equals: 2.  self assert: forkedFailures first equals: ensureFailure.  self assert: forkedFailures last class equals: UnwindError.  self assert: forkedFailures last signalerContext exception equals: ensureFailure.  TestExecutionEnvironment resetFailurestestSimpleCommunication  | semaphore wasBlockStarted wasBlockFinished |  wasBlockStarted := wasBlockFinished := false.  semaphore := Semaphore new.  [ wasBlockStarted := true.  semaphore wait.  wasBlockFinished := true ] fork.  Processor yield.  self assert: wasBlockStarted.  self deny: wasBlockFinished.  semaphore signal.  Processor yield.  self assert: wasBlockFinishedgenPushSpecialLiteral: aLiteral  | index |  aLiteral isInteger ifTrue: [ aLiteral == 0 ifTrue: [ stream nextPut: 80.              ^self ].        aLiteral == 1 ifTrue: [ stream nextPut: 81.              ^self ].        ^self genPushInteger: aLiteral ].  index := #(true false nil) indexOf: aLiteral ifAbsent: [ ^self error: 'push special literal: ' , aLiteral printString , ' is not one of true false nil' ].  stream nextPut: 76 + indexadaptToFloat: rcvr andSend: selector  ^rcvr perform: selector with: self asFloatname  ^'Local Time'runBasicANSISignaledExceptionTests  self basicANSISignaledExceptionTestSelectors do: [:eachTestSelector |  self runTest: eachTestSelector ]realClass  ^selfshouldBeImplemented  ShouldBeImplemented signalFor: thisContext sender selectorx23kbits  ^(11 to: 44 by: 4) inject: 1234567890 into: [:big :bits |  (big * big << bits) + bits ]testIsDashPunctuation  self checkCorrespondanceOf: #isDashPunctuation: and: #PddefinesSlotNamed: aString  ^self slotNames includes: aStringparseNextPattern  self readNextChar.  self isEscape ifTrue: [ ^self parseEscapePattern ].  self isYearPattern ifTrue: [ ^self parseYear ].  self isMonthPattern ifTrue: [ ^self parseMonth ].  self isDayPattern ifTrue: [ ^self parseDay ].  self parseSameCharpushReceiver  self push: self receivertestInjectingMultipleExceptionHandlersIntoNotRunningProcess  | error process lastHandler firstHandler |  DefaultExecutionEnvironment beActive.  firstHandler := lastHandler := false.  process := [ error signal ] newProcess.  process on: ZeroDivide do: [:err |  firstHandler := true ].  process on: Error do: [:err |  lastHandler := true ].  error := ZeroDivide new.  process resume.  [ process isTerminated ] whileFalse: [ Processor yield ].  self assert: firstHandler.  self deny: lastHandler.  firstHandler := lastHandler := false.  process := [ error signal ] newProcess.  process on: ZeroDivide do: [:err |  firstHandler := true ].  process on: Error do: [:err |  lastHandler := true ].  error := Error new.  process resume.  [ process isTerminated ] whileFalse: [ Processor yield ].  self deny: firstHandler.  self assert: lastHandlertestPositiveIntegerPrinting  self assert: 0 printString equals: '0'.  self assert: 0 printStringHex equals: '0'.  self assert: 0 storeStringHex equals: '16r0'.  self assert: (2 printStringBase: 2) equals: '10'.  self assert: (2 radix: 2) equals: '10'.  self assert: 2 printStringHex equals: '2'.  self assert: (2 storeStringBase: 2) equals: '2r10'.  self assert: 2 storeStringHex equals: '16r2'.  self assert: (21 printStringBase: 3) equals: '210'.  self assert: (21 radix: 3) equals: '210'.  self assert: 21 printStringHex equals: '15'.  self assert: (21 storeStringBase: 3) equals: '3r210'.  self assert: 21 storeStringHex equals: '16r15'.  self assert: (228 printStringBase: 4) equals: '3210'.  self assert: (228 radix: 4) equals: '3210'.  self assert: 228 printStringHex equals: 'E4'.  self assert: (228 storeStringBase: 4) equals: '4r3210'.  self assert: 228 storeStringHex equals: '16rE4'.  self assert: (2930 printStringBase: 5) equals: '43210'.  self assert: (2930 radix: 5) equals: '43210'.  self assert: 2930 printStringHex equals: 'B72'.  self assert: (2930 storeStringBase: 5) equals: '5r43210'.  self assert: 2930 storeStringHex equals: '16rB72'.  self assert: (44790 printStringBase: 6) equals: '543210'.  self assert: (44790 radix: 6) equals: '543210'.  self assert: 44790 printStringHex equals: 'AEF6'.  self assert: (44790 storeStringBase: 6) equals: '6r543210'.  self assert: 44790 storeStringHex equals: '16rAEF6'.  self assert: (800667 printStringBase: 7) equals: '6543210'.  self assert: (800667 radix: 7) equals: '6543210'.  self assert: 800667 printStringHex equals: 'C379B'.  self assert: (800667 storeStringBase: 7) equals: '7r6543210'.  self assert: 800667 storeStringHex equals: '16rC379B'.  self assert: (16434824 printStringBase: 8) equals: '76543210'.  self assert: (16434824 radix: 8) equals: '76543210'.  self assert: 16434824 printStringHex equals: 'FAC688'.  self assert: (16434824 storeStringBase: 8) equals: '8r76543210'.  self assert: 16434824 storeStringHex equals: '16rFAC688'.  self assert: (381367044 printStringBase: 9) equals: '876543210'.  self assert: (381367044 radix: 9) equals: '876543210'.  self assert: 381367044 printStringHex equals: '16BB3304'.  self assert: (381367044 storeStringBase: 9) equals: '9r876543210'.  self assert: 381367044 storeStringHex equals: '16r16BB3304'.  self assert: (9876543210 printStringBase: 10) equals: '9876543210'.  self assert: (9876543210 radix: 10) equals: '9876543210'.  self assert: 9876543210 printStringHex equals: '24CB016EA'.  self assert: (9876543210 storeStringBase: 10) equals: '9876543210'.  self assert: 9876543210 storeStringHex equals: '16r24CB016EA'.  self assert: (282458553905 printStringBase: 11) equals: 'A9876543210'.  self assert: (282458553905 radix: 11) equals: 'A9876543210'.  self assert: 282458553905 printStringHex equals: '41C3D77E31'.  self assert: (282458553905 storeStringBase: 11) equals: '11rA9876543210'.  self assert: 282458553905 storeStringHex equals: '16r41C3D77E31'.  self assert: (8842413667692 printStringBase: 12) equals: 'BA9876543210'.  self assert: (8842413667692 radix: 12) equals: 'BA9876543210'.  self assert: 8842413667692 printStringHex equals: '80AC8ECF56C'.  self assert: (8842413667692 storeStringBase: 12) equals: '12rBA9876543210'.  self assert: 8842413667692 storeStringHex equals: '16r80AC8ECF56C'.  self assert: (300771807240918 printStringBase: 13) equals: 'CBA9876543210'.  self assert: (300771807240918 radix: 13) equals: 'CBA9876543210'.  self assert: 300771807240918 printStringHex equals: '1118CE4BAA2D6'.  self assert: (300771807240918 storeStringBase: 13) equals: '13rCBA9876543210'.  self assert: 300771807240918 storeStringHex equals: '16r1118CE4BAA2D6'.  self assert: (11046255305880158 printStringBase: 14) equals: 'DCBA9876543210'.  self assert: (11046255305880158 radix: 14) equals: 'DCBA9876543210'.  self assert: 11046255305880158 printStringHex equals: '273E82BB9AF25E'.  self assert: (11046255305880158 storeStringBase: 14) equals: '14rDCBA9876543210'.  self assert: 11046255305880158 storeStringHex equals: '16r273E82BB9AF25E'.  self assert: (435659737878916215 printStringBase: 15) equals: 'EDCBA9876543210'.  self assert: (435659737878916215 radix: 15) equals: 'EDCBA9876543210'.  self assert: 435659737878916215 printStringHex equals: '60BC6392F366C77'.  self assert: (435659737878916215 storeStringBase: 15) equals: '15rEDCBA9876543210'.  self assert: 435659737878916215 storeStringHex equals: '16r60BC6392F366C77'.  self assert: (18364758544493064720 printStringBase: 16) equals: 'FEDCBA9876543210'.  self assert: (18364758544493064720 radix: 16) equals: 'FEDCBA9876543210'.  self assert: 18364758544493064720 printStringHex equals: 'FEDCBA9876543210'.  self assert: (18364758544493064720 storeStringBase: 16) equals: '16rFEDCBA9876543210'.  self assert: 18364758544493064720 storeStringHex equals: '16rFEDCBA9876543210'.  self assert: (824008854613343261192 printStringBase: 17) equals: 'GFEDCBA9876543210'.  self assert: (824008854613343261192 radix: 17) equals: 'GFEDCBA9876543210'.  self assert: 824008854613343261192 printStringHex equals: '2CAB6B877C1CD2D208'.  self assert: (824008854613343261192 storeStringBase: 17) equals: '17rGFEDCBA9876543210'.  self assert: 824008854613343261192 storeStringHex equals: '16r2CAB6B877C1CD2D208'.  self assert: (39210261334551566857170 printStringBase: 18) equals: 'HGFEDCBA9876543210'.  self assert: (39210261334551566857170 radix: 18) equals: 'HGFEDCBA9876543210'.  self assert: 39210261334551566857170 printStringHex equals: '84D97AFCAE81415B3D2'.  self assert: (39210261334551566857170 storeStringBase: 18) equals: '18rHGFEDCBA9876543210'.  self assert: 39210261334551566857170 storeStringHex equals: '16r84D97AFCAE81415B3D2'.  self assert: (1972313422155189164466189 printStringBase: 19) equals: 'IHGFEDCBA9876543210'.  self assert: (1972313422155189164466189 radix: 19) equals: 'IHGFEDCBA9876543210'.  self assert: 1972313422155189164466189 printStringHex equals: '1A1A75329C5C6FC00600D'.  self assert: (1972313422155189164466189 storeStringBase: 19) equals: '19rIHGFEDCBA9876543210'.  self assert: 1972313422155189164466189 storeStringHex equals: '16r1A1A75329C5C6FC00600D'.  self assert: (104567135734072022160664820 printStringBase: 20) equals: 'JIHGFEDCBA9876543210'.  self assert: (104567135734072022160664820 radix: 20) equals: 'JIHGFEDCBA9876543210'.  self assert: 104567135734072022160664820 printStringHex equals: '567EF3C9636D242A8C68F4'.  self assert: (104567135734072022160664820 storeStringBase: 20) equals: '20rJIHGFEDCBA9876543210'.  self assert: 104567135734072022160664820 storeStringHex equals: '16r567EF3C9636D242A8C68F4'.  self assert: (5827980550840017565077671610 printStringBase: 21) equals: 'KJIHGFEDCBA9876543210'.  self assert: (5827980550840017565077671610 radix: 21) equals: 'KJIHGFEDCBA9876543210'.  self assert: 5827980550840017565077671610 printStringHex equals: '12D4CAE2B8A09BCFDBE30EBA'.  self assert: (5827980550840017565077671610 storeStringBase: 21) equals: '21rKJIHGFEDCBA9876543210'.  self assert: 5827980550840017565077671610 storeStringHex equals: '16r12D4CAE2B8A09BCFDBE30EBA'.  self assert: (340653664490377789692799452102 printStringBase: 22) equals: 'LKJIHGFEDCBA9876543210'.  self assert: (340653664490377789692799452102 radix: 22) equals: 'LKJIHGFEDCBA9876543210'.  self assert: 340653664490377789692799452102 printStringHex equals: '44CB61B5B47E1A5D8F88583C6'.  self assert: (340653664490377789692799452102 storeStringBase: 22) equals: '22rLKJIHGFEDCBA9876543210'.  self assert: 340653664490377789692799452102 storeStringHex equals: '16r44CB61B5B47E1A5D8F88583C6'.  self assert: (20837326537038308910317109288851 printStringBase: 23) equals: 'MLKJIHGFEDCBA9876543210'.  self assert: (20837326537038308910317109288851 radix: 23) equals: 'MLKJIHGFEDCBA9876543210'.  self assert: 20837326537038308910317109288851 printStringHex equals: '1070108876456E0EF115B389F93'.  self assert: (20837326537038308910317109288851 storeStringBase: 23) equals: '23rMLKJIHGFEDCBA9876543210'.  self assert: 20837326537038308910317109288851 storeStringHex equals: '16r1070108876456E0EF115B389F93'.  self assert: (1331214537196502869015340298036888 printStringBase: 24) equals: 'NMLKJIHGFEDCBA9876543210'.  self assert: (1331214537196502869015340298036888 radix: 24) equals: 'NMLKJIHGFEDCBA9876543210'.  self assert: 1331214537196502869015340298036888 printStringHex equals: '41A24A285154B026B6ED206C6698'.  self assert: (1331214537196502869015340298036888 storeStringBase: 24) equals: '24rNMLKJIHGFEDCBA9876543210'.  self assert: 1331214537196502869015340298036888 storeStringHex equals: '16r41A24A285154B026B6ED206C6698'.  self assert: (88663644327703473714387251271141900 printStringBase: 25) equals: 'ONMLKJIHGFEDCBA9876543210'.  self assert: (88663644327703473714387251271141900 radix: 25) equals: 'ONMLKJIHGFEDCBA9876543210'.  self assert: 88663644327703473714387251271141900 printStringHex equals: '111374860A2C6CEBE5999630398A0C'.  self assert: (88663644327703473714387251271141900 storeStringBase: 25) equals: '25rONMLKJIHGFEDCBA9876543210'.  self assert: 88663644327703473714387251271141900 storeStringHex equals: '16r111374860A2C6CEBE5999630398A0C'.  self assert: (6146269788878825859099399609538763450 printStringBase: 26) equals: 'PONMLKJIHGFEDCBA9876543210'.  self assert: (6146269788878825859099399609538763450 radix: 26) equals: 'PONMLKJIHGFEDCBA9876543210'.  self assert: 6146269788878825859099399609538763450 printStringHex equals: '49FBA7F30B0F48BD14E6A99BD8ADABA'.  self assert: (6146269788878825859099399609538763450 storeStringBase: 26) equals: '26rPONMLKJIHGFEDCBA9876543210'.  self assert: 6146269788878825859099399609538763450 storeStringHex equals: '16r49FBA7F30B0F48BD14E6A99BD8ADABA'.  self assert: (442770531899482980347734468443677777577 printStringBase: 27) equals: 'QPONMLKJIHGFEDCBA9876543210'.  self assert: (442770531899482980347734468443677777577 radix: 27) equals: 'QPONMLKJIHGFEDCBA9876543210'.  self assert: 442770531899482980347734468443677777577 printStringHex equals: '14D1A80A997343640C1145A073731DEA9'.  self assert: (442770531899482980347734468443677777577 storeStringBase: 27) equals: '27rQPONMLKJIHGFEDCBA9876543210'.  self assert: 442770531899482980347734468443677777577 storeStringHex equals: '16r14D1A80A997343640C1145A073731DEA9'.  self assert: (33100056003358651440264672384704297711484 printStringBase: 28) equals: 'RQPONMLKJIHGFEDCBA9876543210'.  self assert: (33100056003358651440264672384704297711484 radix: 28) equals: 'RQPONMLKJIHGFEDCBA9876543210'.  self assert: 33100056003358651440264672384704297711484 printStringHex equals: '6145B6E6DACFA25D0E936F51D25932377C'.  self assert: (33100056003358651440264672384704297711484 storeStringBase: 28) equals: '28rRQPONMLKJIHGFEDCBA9876543210'.  self assert: 33100056003358651440264672384704297711484 storeStringHex equals: '16r6145B6E6DACFA25D0E936F51D25932377C'.  self assert: (2564411043271974895869785066497940850811934 printStringBase: 29) equals: 'SRQPONMLKJIHGFEDCBA9876543210'.  self assert: (2564411043271974895869785066497940850811934 radix: 29) equals: 'SRQPONMLKJIHGFEDCBA9876543210'.  self assert: 2564411043271974895869785066497940850811934 printStringHex equals: '1D702071CBA4A1597D4DD37E95EFAC79241E'.  self assert: (2564411043271974895869785066497940850811934 storeStringBase: 29) equals: '29rSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 2564411043271974895869785066497940850811934 storeStringHex equals: '16r1D702071CBA4A1597D4DD37E95EFAC79241E'.  self assert: (205646315052919334126040428061831153388822830 printStringBase: 30) equals: 'TSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (205646315052919334126040428061831153388822830 radix: 30) equals: 'TSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 205646315052919334126040428061831153388822830 printStringHex equals: '938B4343B54B550989989D02998718FFB212E'.  self assert: (205646315052919334126040428061831153388822830 storeStringBase: 30) equals: '30rTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 205646315052919334126040428061831153388822830 storeStringHex equals: '16r938B4343B54B550989989D02998718FFB212E'.  self assert: (17050208381689099029767742314582582184093573615 printStringBase: 31) equals: 'UTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (17050208381689099029767742314582582184093573615 radix: 31) equals: 'UTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 17050208381689099029767742314582582184093573615 printStringHex equals: '2FC8ECB1521BA16D24A69E976D53873E2C661EF'.  self assert: (17050208381689099029767742314582582184093573615 storeStringBase: 31) equals: '31rUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 17050208381689099029767742314582582184093573615 storeStringHex equals: '16r2FC8ECB1521BA16D24A69E976D53873E2C661EF'.  self assert: (1459980823972598128486511383358617792788444579872 printStringBase: 32) equals: 'VUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (1459980823972598128486511383358617792788444579872 radix: 32) equals: 'VUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 1459980823972598128486511383358617792788444579872 printStringHex equals: 'FFBBCDEB38BDAB49CA307B9AC5A928398A418820'.  self assert: (1459980823972598128486511383358617792788444579872 storeStringBase: 32) equals: '32rVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 1459980823972598128486511383358617792788444579872 storeStringHex equals: '16rFFBBCDEB38BDAB49CA307B9AC5A928398A418820'.  self assert: (128983956064237823710866404905431464703849549412368 printStringBase: 33) equals: 'WVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (128983956064237823710866404905431464703849549412368 radix: 33) equals: 'WVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 128983956064237823710866404905431464703849549412368 printStringHex equals: '584120A0328DE272AB055A8AA003CE4A559F223810'.  self assert: (128983956064237823710866404905431464703849549412368 storeStringBase: 33) equals: '33rWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 128983956064237823710866404905431464703849549412368 storeStringHex equals: '16r584120A0328DE272AB055A8AA003CE4A559F223810'.  self assert: (11745843093701610854378775891116314824081102660800418 printStringBase: 34) equals: 'XWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (11745843093701610854378775891116314824081102660800418 radix: 34) equals: 'XWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 11745843093701610854378775891116314824081102660800418 printStringHex equals: '1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.  self assert: (11745843093701610854378775891116314824081102660800418 storeStringBase: 34) equals: '34rXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 11745843093701610854378775891116314824081102660800418 storeStringHex equals: '16r1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.  self assert: (1101553773143634726491620528194292510495517905608180485 printStringBase: 35) equals: 'YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (1101553773143634726491620528194292510495517905608180485 radix: 35) equals: 'YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 1101553773143634726491620528194292510495517905608180485 printStringHex equals: 'B8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.  self assert: (1101553773143634726491620528194292510495517905608180485 storeStringBase: 35) equals: '35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 1101553773143634726491620528194292510495517905608180485 storeStringHex equals: '16rB8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.  self assert: (106300512100105327644605138221229898724869759421181854980 printStringBase: 36) equals: 'ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (106300512100105327644605138221229898724869759421181854980 radix: 36) equals: 'ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 106300512100105327644605138221229898724869759421181854980 printStringHex equals: '455D441E55A37239AB4C303189576071AF5578FFCA80504'.  self assert: (106300512100105327644605138221229898724869759421181854980 storeStringBase: 36) equals: '36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 106300512100105327644605138221229898724869759421181854980 storeStringHex equals: '16r455D441E55A37239AB4C303189576071AF5578FFCA80504'stream: s  stream := srandomCharacter  ^self randomCharacterBetween: 0 and: Unicode maxValueifCurtailed: aBlock  < primitive: 198>  | complete result |  result := self valueNoContextSwitch.  complete := true.  ^resulttake: kk  | num denom |  kk < 0 ifTrue: [ ^0 ].  kk > self ifTrue: [ ^0 ].  num := 1.  self to: (kk max: self - kk) + 1 by: -1 do: [:factor |  num := num * factor ].  denom := 1.  1 to: (kk min: self - kk) do: [:factor |  denom := denom * factor ].  ^num // denom* aNumber  aNumber isInteger ifTrue: [ ^self digitMultiply: aNumber neg: self negative ~~ aNumber negative ].  ^aNumber adaptToInteger: self andSend: #*encodeUsingZip  | utf8str stream length encodedLength |  [ data isString ] assert.  utf8str := data convertToEncoding: 'utf8'.  stream := (ZipWriteStream on: (ByteArray new: utf8str size))     nextPutAll: utf8str asByteArray;     close;     encodedStream.  length := stream position.  encodedLength := self encodeLengthField: length.  stream nextPutAll: encodedLength.  stream nextPut: self kindAsByte + encodedLength size - 1.  encodedData := stream contentstestIntegerPadding  self assert: (1 printStringBase: 10 length: 0 padded: false) equals: '1'.  self assert: (1 printStringBase: 10 length: 1 padded: false) equals: '1'.  self assert: (1 printStringBase: 10 length: 2 padded: false) equals: ' 1'.  self assert: (1024 printStringBase: 10 length: 19 padded: false) equals: '               1024'.  self assert: (1024 printStringBase: 10 length: -1 padded: false) equals: '1024'.  self assert: (1024 printStringBase: 10 length: 5 padded: false) equals: ' 1024'.  self assert: (-1024 printStringBase: 10 length: 5 padded: false) equals: '-1024'.  self assert: (-1024 printStringBase: 10 length: 19 padded: false) equals: '              -1024'.  self assert: (1 printStringBase: 10 length: 0 padded: true) equals: '1'.  self assert: (1 printStringBase: 10 length: 1 padded: true) equals: '1'.  self assert: (1 printStringBase: 10 length: 2 padded: true) equals: '01'.  self assert: (1024 printStringBase: 10 length: 19 padded: true) equals: '0000000000000001024'.  self assert: (1024 printStringBase: 10 length: -1 padded: true) equals: '1024'.  self assert: (1024 printStringBase: 10 length: 5 padded: true) equals: '01024'.  self assert: (-1024 printStringBase: 10 length: 5 padded: true) equals: '-1024'.  self assert: (-1024 printStringBase: 10 length: 19 padded: true) equals: '-000000000000001024'.  self assert: (1 printStringBase: 16 length: 0 padded: false) equals: '1'.  self assert: (1 printStringBase: 16 length: 1 padded: false) equals: '1'.  self assert: (1 printStringBase: 16 length: 2 padded: false) equals: ' 1'.  self assert: (2047 printStringBase: 16 length: 19 padded: false) equals: '                7FF'.  self assert: (2047 printStringBase: 16 length: -1 padded: false) equals: '7FF'.  self assert: (2047 printStringBase: 16 length: 4 padded: false) equals: ' 7FF'.  self assert: (-2047 printStringBase: 16 length: 4 padded: false) equals: '-7FF'.  self assert: (-2047 printStringBase: 16 length: 19 padded: false) equals: '               -7FF'.  self assert: (1 printStringBase: 16 length: 0 padded: true) equals: '1'.  self assert: (1 printStringBase: 16 length: 1 padded: true) equals: '1'.  self assert: (1 printStringBase: 16 length: 2 padded: true) equals: '01'.  self assert: (2047 printStringBase: 16 length: 19 padded: true) equals: '00000000000000007FF'.  self assert: (2047 printStringBase: 16 length: -1 padded: true) equals: '7FF'.  self assert: (2047 printStringBase: 16 length: 4 padded: true) equals: '07FF'.  self assert: (-2047 printStringBase: 16 length: 4 padded: true) equals: '-7FF'.  self assert: (-2047 printStringBase: 16 length: 19 padded: true) equals: '-0000000000000007FF'.  self assert: (1 storeStringBase: 10 length: 0 padded: false) equals: '1'.  self assert: (1 storeStringBase: 10 length: 1 padded: false) equals: '1'.  self assert: (1 storeStringBase: 10 length: 2 padded: false) equals: ' 1'.  self assert: (1024 storeStringBase: 10 length: 19 padded: false) equals: '               1024'.  self assert: (1024 storeStringBase: 10 length: -1 padded: false) equals: '1024'.  self assert: (1024 storeStringBase: 10 length: 5 padded: false) equals: ' 1024'.  self assert: (-1024 storeStringBase: 10 length: 5 padded: false) equals: '-1024'.  self assert: (-1024 storeStringBase: 10 length: 19 padded: false) equals: '              -1024'.  self assert: (1 storeStringBase: 10 length: 0 padded: true) equals: '1'.  self assert: (1 storeStringBase: 10 length: 1 padded: true) equals: '1'.  self assert: (1 storeStringBase: 10 length: 2 padded: true) equals: '01'.  self assert: (1024 storeStringBase: 10 length: 19 padded: true) equals: '0000000000000001024'.  self assert: (1024 storeStringBase: 10 length: -1 padded: true) equals: '1024'.  self assert: (1024 storeStringBase: 10 length: 5 padded: true) equals: '01024'.  self assert: (-1024 storeStringBase: 10 length: 5 padded: true) equals: '-1024'.  self assert: (-1024 storeStringBase: 10 length: 19 padded: true) equals: '-000000000000001024'.  self assert: (1 storeStringBase: 16 length: 0 padded: false) equals: '16r1'.  self assert: (1 storeStringBase: 16 length: 4 padded: false) equals: '16r1'.  self assert: (1 storeStringBase: 16 length: 5 padded: false) equals: ' 16r1'.  self assert: (2047 storeStringBase: 16 length: 19 padded: false) equals: '             16r7FF'.  self assert: (2047 storeStringBase: 16 length: -1 padded: false) equals: '16r7FF'.  self assert: (2047 storeStringBase: 16 length: 7 padded: false) equals: ' 16r7FF'.  self assert: (-2047 storeStringBase: 16 length: 7 padded: false) equals: '-16r7FF'.  self assert: (-2047 storeStringBase: 16 length: 19 padded: false) equals: '            -16r7FF'.  self assert: (1 storeStringBase: 16 length: 0 padded: true) equals: '16r1'.  self assert: (1 storeStringBase: 16 length: 4 padded: true) equals: '16r1'.  self assert: (1 storeStringBase: 16 length: 5 padded: true) equals: '16r01'.  self assert: (2047 storeStringBase: 16 length: 19 padded: true) equals: '16r00000000000007FF'.  self assert: (2047 storeStringBase: 16 length: -1 padded: true) equals: '16r7FF'.  self assert: (2047 storeStringBase: 16 length: 7 padded: true) equals: '16r07FF'.  self assert: (-2047 storeStringBase: 16 length: 7 padded: true) equals: '-16r7FF'.  self assert: (-2047 storeStringBase: 16 length: 19 padded: true) equals: '-16r0000000000007FF'setMethod: aCompiledMethod  self deprecated: 'Use #method: instead.' transformWith: '`@receiver setMethod: `@arg' -> '`@receiver method: `@arg'.  self method: aCompiledMethodintersect: aSet withAll: sets continuation: hop  ^aSet ifEmpty: [ hop value: aSet ] ifNotEmpty: [ sets ifEmpty: [ aSet ] ifNotEmpty: [ self intersect: aSet withCollection: (self intersect: sets first withAll: sets allButFirst continuation: hop) ] ]~= anObject  ^self = anObject == falseremoveEmptyProtocols  | removedProtocols |  removedProtocols := protocols select: [:e |  e isEmpty and: [ e canBeRemoved ] ].  removedProtocols do: [:each |  self removeProtocol: each ].  ^removedProtocolsbindingOf: aString  ^nilunwindTo: aContext  | context unwindBlock |  context := self.  [ (context := context findNextUnwindContextUpTo: aContext) isNil ] whileFalse: [ context unwindComplete ifNil: [ context unwindComplete: true.              unwindBlock := context unwindBlock.              unwindBlock value ] ]setUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  aDateAndTime := DateAndTime     localTimeZone: TimeZone default;     dosEpoch.  aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'DOS Epoch Test Time Zone' abbreviation: 'DTZ'.  aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5format  ^formathandleProcessTerminationOfWaitingContext: suspendedContext  ^suspendedContextpointAtSideOrCorner: loc  ^self perform: (#(topLeft topCenter topRight rightCenter bottomRight bottomCenter bottomLeft leftCenter) at: (#(topLeft top topRight right bottomRight bottom bottomLeft left) indexOf: loc))testXor  self assert: (false xor: true) equals: true.  self assert: (false xor: false) equals: false.  self assert: (false xor: [ true ]) equals: true.  self assert: (false xor: [ false ]) equals: falseasUTC  ^offset isZero ifTrue: [ self ] ifFalse: [ self offset: 0 ]significand  ^self timesTwoPower: self exponent negatedtestBasicCheck1  | testMethod |  testMethod := testSubclass >> (testSubclass compile: self methodName , '1').  self assertEmpty: (OverridesDeprecatedMethodRule new check: testMethod)gtInspectorMethodsIn: composite  < gtInspectorPresentationOrder: 20>  composite list     title: 'Methods';     display: [ (self methods collect: #asRingDefinition) sorted: [:x :y |  x selector < y selector ] ];     format: #selector;     tags: [:each |  {each methodClass name} ]testInheritableVariable  | s1 s2 parentVar childVar |  s1 := Semaphore new.  s2 := Semaphore new.  TestInheritableVariable enable.  [ TestInheritableVariable value: #inheritedVar.  parentVar := TestInheritableVariable value.  [ childVar := TestInheritableVariable value.  s2 signal ] fork.  s1 signal ] fork.  s1 waitTimeoutSeconds: 2.  s2 waitTimeoutSeconds: 2.  TestInheritableVariable disable.  self assert: parentVar equals: #inheritedVar.  self assert: childVar equals: #inheritedVarcalloutAPIClass  ^self ffiLibrary calloutAPIClasscanUnderstand: selector  ^self classAndMethodFor: selector do: [:c :m |  true ] ifAbsent: [ false ]asBit  ^1testAsSeconds  self assert: aDateAndTime asSeconds equals: 2177452800testDelayWaitTimeoutTimedOut  | completed delay status |  completed := Semaphore new.  delay := DelayWaitTimeout new setDelay: 100 forSemaphore: completed.  delay waitOnCompletion: [ status := #completed ] onTimeout: [ status := #timedOut ].  self assert: status equals: #timedOutnumArgsError: numArgsForInvocation  ArgumentsCountMismatch signalExpectedArgumentsCount: numArgs calledArgumentsCount: numArgsForInvocationremoveAction: anAction forEvent: anEventSelector  self removeActionsSatisfying: [:action |  action = anAction ] forEvent: anEventSelectortestMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'PM'testPrintOnFormat  self assert: (String streamContents: [:str |  january23rd2004 printOn: str format: #(3 2 1 $* 2 2) ]) equals: '04*Jan*23'originalName  ^((self isObsolete and: [ self name beginsWith: 'AnObsolete' ]) ifTrue: [ self name copyFrom: 'AnObsolete' size + 1 to: self name size ] ifFalse: [ self name ]) asSymbolbottomCenter  ^self center x @ self bottomresult: r  result := r\\ aNumber  < primitive: 31>  aNumber isInteger ifTrue: [ | neg qr q r |        neg := self negative == aNumber negative == false.        qr := self digitDiv: aNumber neg: neg.        q := qr first normalize.        r := qr last normalize.        ^(q negative ifTrue: [ r isZero not ] ifFalse: [ q isZero and: [ neg ] ]) ifTrue: [ r + aNumber ] ifFalse: [ r ] ].  ^super \\ aNumbertestNonCharacterNegative  self aRandomSelectionOfCharactersDo: [:ch |  self deny: (Unicode isNonCharacter: ch) ]streamToMethod: aCompiledMethod  stream := WriteStream with: aCompiledMethod.  stream position: aCompiledMethod initialPC - 1testFromString  | fromString fromStringNoOffset |  fromString := DateAndTime fromString: '-1199-01-05T20:33:14.321-05:00'.  self assert: fromString printString equals: '-1199-01-05T20:33:14.321-05:00'.  fromStringNoOffset := DateAndTime fromString: '-1199-01-05T20:33:14.321'.  self assert: fromStringNoOffset offset equals: DateAndTime localOffsetincludesSelector: aSymbol  ^self methodDict includesKey: aSymboltestAsNumber  | sd |  sd := '1.40s2' asNumber.  self assert: ScaledDecimal identicalTo: sd class.  self assert: sd scale equals: 2.  self assert: '1.40s2' equals: sd printStringtestIfTrueIfFalse  self assert: (true ifTrue: [ 'trueAlternativeBlock' ] ifFalse: [ 'falseAlternativeBlock' ]) equals: 'trueAlternativeBlock'isBottomContext  ^sender isNilmessage  ^Message selector: self selector arguments: self argumentsbanLevelCandidates  ^{self} , self methodClass banLevelCandidatesreleaseActionMap  EventManager releaseActionMapFor: selfmonthIndex  ^self monthtestAsDateAndTime  | timestamp |  timestamp := DosTimestamp on: 16r40B57856.  self assert: timestamp asDateAndTime equals: '21 May 2012 3:02:44 pm' asDateAndTimerotateBy: direction centerAt: aPoint  ^(origin rotateBy: direction centerAt: aPoint) rectangle: (corner rotateBy: direction centerAt: aPoint)day  ^self dayOfYearnextInstance  < primitive: 78>  ^niltestIntegerReadsOkFromStream  self assert: (Integer readFrom: '123' readStream) equals: 123.  self assert: (Integer readFrom: '-123' readStream) equals: -123.  self assert: (Integer readFrom: 'a3' readStream base: 16) equals: 163.  self assert: (Integer readFrom: '-a3' readStream base: 16) equals: -163.  self assert: (Integer readFrom: '3a' readStream base: 10) equals: 3getSourceReplacingSelectorWith: newSelector  | oldKeywords newKeywords source newSource oldSelector start |  source := self sourceCode.  source ifNil: [ ^nil ].  oldSelector := self selector.  oldSelector = newSelector ifTrue: [ ^source ].  oldKeywords := oldSelector keywords.  newKeywords := (newSelector ifNil: [ self defaultSelector ]) keywords.  [ oldKeywords size = newKeywords size ] assert.  newSource := source.  start := 1.  oldKeywords with: newKeywords do: [:oldKey :newKey |  | pos |        pos := newSource findString: oldKey startingAt: start.        newSource := newSource copyReplaceFrom: pos to: pos + oldKey size - 1 with: newKey.        start := pos + newKey size ].  ^newSourcecompareWith: anotherMagnitude ifLesser: lesserBlock ifEqual: equalBlock ifGreater: greaterBlock  ^self < anotherMagnitude ifTrue: lesserBlock ifFalse: [ self = anotherMagnitude ifTrue: equalBlock ifFalse: greaterBlock ]not  ^truetestBasicCheck  | testMethod |  testMethod := testClass >> (testClass compile: 'testMethod ' , self globalName , ' ' , self deprecatedMethodName).  self assert: (testMethod externalProperties anySatisfy: [:eprop |  eprop rule class = SendsDeprecatedMethodToGlobalRule ])duplicateClassWithNewName: aSymbol  | copysName class |  copysName := aSymbol asSymbol.  copysName = self name ifTrue: [ ^self ].  (self environment includesKey: copysName) ifTrue: [ ^self error: copysName , ' already exists' ].  class := self classInstaller make: [:builder |  builder           fillFor: self;           name: copysName ].  class copyAllCategoriesFrom: self.  class class copyAllCategoriesFrom: self class.  ^classlink: aMetaLink toTemporary: aTempVar  self shouldNotImplementselector: aSymbol  selector := aSymbolbecomeForward: otherObject copyHash: copyHash  {self} elementsForwardIdentityTo: {otherObject} copyHash: copyHashtestReciprocalModulo  1 to: 512 do: [:a |  a + 1 to: 512 do: [:b |  | c |              (a gcd: b) = 1 ifTrue: [ c := a reciprocalModulo: b.                    self assert: a * c \\ b equals: 1 ] ifFalse: [ self should: [ a reciprocalModulo: b ] raise: Error ] ] ]isExplicitlyRequired: marker  ^marker == self class explicitRequirementMarkerserializeOn: anEncoder  anEncoder     encodeUint24: self asSeconds;     encodeUint32: self nanoSecondpointsOnlyWeaklyTo: anObject  self class isWeak ifFalse: [ ^false ].  1 to: self class instSize do: [:i |  (self instVarAt: i) == anObject ifTrue: [ ^false ] ].  ^truegenStorePopLiteralVar: literalIndex  literalIndex < 0 ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255 ].  literalIndex < 64 ifTrue: [ stream           nextPut: 130;           nextPut: 192 + literalIndex.        ^self ].  literalIndex < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 224;           nextPut: literalIndex.        self genPop.        ^self ].  ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255lowerBound  ^lowerBoundtestSendsSelector  self assert: (CompiledCode >> #sendsSelector: sendsSelector: #includes:).  self deny: (CompiledCode >> #sendsSelector: sendsSelector: #doBreakfastForMe)gtPlaygroundHumanReadableString  self < 1 minute ifTrue: [ ^'just now' ].  self < 2 minutes ifTrue: [ ^'1 minute ago' ].  self < 1 hour ifTrue: [ ^self minutes asString , ' minutes ago' ].  self < 1 day ifTrue: [ ^self hours asString , ' hours ago' ].  self < 1 year ifTrue: [ ^self days asString , ' days ago' ].  ^self printStringsimpleEnsureTest  [ self doSomething.  self doSomethingElse ] ensure: [ self doYetAnotherThing ]compile: code notifying: requestor  | method |  method := self compiler     source: code;     requestor: requestor;     failBlock: [ ^nil ];     compile.  method putSource: code withPreamble: [:f |  f           cr;           nextPut: $!;           nextChunkPut: 'Behavior method';           cr ].  self addSelector: method selector withMethod: method.  ^method selectorencodeEmbeddedSourceWide  | str length encodedLength utf8data |  [ data isString ] assert.  utf8data := data utf8Encoded.  str := WriteStream on: (ByteArray new: utf8data size).  length := utf8data size.  encodedLength := self encodeLengthField: length.  str nextPutAll: utf8data asByteArray.  str nextPutAll: encodedLength.  str nextPut: self kindAsByte + encodedLength size - 1.  encodedData := str contentsdate: aDate  deprecationDate := aDateextensionProtocols  ^self protocolOrganizer extensionProtocolsdecodeEmbeddedSourceQCompress  | len str input |  len := self decodeLengthField.  input := ReadStream on: method from: method size - size + 1 to: method size - size + len.  str := String streamContents: [:strm |  | nextNibble nibble peek charTable |        charTable := 'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'.        peek := true.        nextNibble := [ peek ifTrue: [ peek := false.              input peek ifNil: [ 0 ] ifNotNil: [:b |  b // 16 ] ] ifFalse: [ peek := true.              input next ifNil: [ 0 ] ifNotNil: [:b |  b \\ 16 ] ] ].        [ input atEnd ] whileFalse: [ (nibble := nextNibble value) = 0 ifTrue: [ input atEnd ifFalse: [ strm nextPut: (Character value: nextNibble value * 16 + nextNibble value) ] ] ifFalse: [ nibble <= 11 ifTrue: [ strm nextPut: (charTable at: nibble) ] ifFalse: [ strm nextPut: (charTable at: (nibble - 12) * 16 + nextNibble value) ] ] ] ].  data := str convertFromEncoding: 'utf8'usesPoolVarNamed: aString  ^falsesetJdn: julDays seconds: secs nano: nanoSecs offset: anOffset  julianDayNumber := julDays.  seconds := secs.  nanos := nanoSecs.  offset := anOffset.  self normalizeSecondsAndNanosisBehavior  ^truetestComparison  | method1 method2 |  method1 := Float class >> #nan.  method2 := thisContext method.  self assert: method1 equals: method1.  self assert: method2 equals: method2.  self deny: method1 equals: method2.  self deny: method2 equals: method1.  Object methods do: [:each |  self deny: method1 equals: each.        self deny: each equals: method1.        self deny: method2 equals: each.        self deny: each equals: method2 ]genPushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize  (jumpSize < 0 or: [ jumpSize > 65535 ]) ifTrue: [ ^self outOfRangeError: 'block size' index: jumpSize range: 0 to: 65535 ].  (numCopied < 0 or: [ numCopied > 15 ]) ifTrue: [ ^self outOfRangeError: 'num copied' index: numCopied range: 0 to: 15 ].  (numArgs < 0 or: [ numArgs > 15 ]) ifTrue: [ ^self outOfRangeError: 'num args' index: numArgs range: 0 to: 15 ].  stream     nextPut: 143;     nextPut: numArgs + (numCopied bitShift: 4);     nextPut: (jumpSize bitShift: -8);     nextPut: (jumpSize bitAnd: 16rFF)hex  ^self storeStringBase: 16interpretSistaV1JumpIfCond  | method byte nextpc extB |  method := self method.  extB := 0.  nextpc := pc.  [ byte := self method at: nextpc.  nextpc := nextpc + 1.  byte = 225 ] whileTrue: [ | extByte |        extByte := self method at: nextpc.        nextpc := nextpc + 1.        extB := (extB = 0 and: [ extByte > 127 ]) ifTrue: [ extByte - 256 ] ifFalse: [ (extB bitShift: 8) + extByte ] ].  (byte between: 184 and: 199) ifTrue: [ pc := nextpc.        ^(byte bitAnd: 7) + 1 ].  (byte between: 238 and: 239) ifTrue: [ byte := method at: nextpc.        pc := nextpc + 1.        ^(extB bitShift: 8) + byte ].  ^nilvariableReadNodes  ^self methods flatCollect: [:each |  each variableReadNodes ]testValueWithExitContinue  | val last |  val := 0.  1 to: 10 do: [:i |  [:continue |  i = 4 ifTrue: [ continue value ].        val := val + 1.        last := i ] valueWithExit ].  self assert: val equals: 9.  self assert: last equals: 10forkAt: priority  ^self newProcess     priority: priority;     resumetestTwoRecursiveCriticalsShouldNotWaitEachOther  | executed |  executed := false.  self fork: [ mutex critical: [ mutex critical: [ executed := true ] ] ].  self waitLastProcessTerminate.  self assert: executedtestOneRaisedToInteger  self assert: (1.0s1 raisedToInteger: -1) scale equals: 1.  self assert: (1.0s1 raisedToInteger: -1) equals: 1.  self assert: (1.0s1 raisedToInteger: 0) scale equals: 1.  self assert: (1.0s1 raisedToInteger: 0) equals: 1.  self assert: (1.0s1 raisedToInteger: 1) scale equals: 1.  self assert: (1.0s1 raisedToInteger: 1) equals: 1.  self assert: (1.0s1 raisedToInteger: 2) scale equals: 1.  self assert: (1.0s1 raisedToInteger: 2) equals: 1valueWithReceiver: aReceiver arguments: anArray  ^aReceiver withArgs: anArray executeMethod: selfwaitTimeoutSeconds: anInteger  ^self waitTimeoutMSecs: anInteger * 1000deprecatedMethod  self deprecated: 'example of a deprecated method'scaledByDisplayScaleFactor  ^self * self currentWorld displayScaleFactorstartTimerEventLoopPriority: processorPriority  timerEventLoop ifNotNil: [ self error: 'Timer event loop has already been started.' ].  runTimerEventLoop := true.  timerEventLoop := [ self runBackendLoopAtTimingPriority ] newProcess.  timerEventLoop     name: self className , '(' , ticker className , ')';     priority: processorPriority.  timerEventLoop resumeclearSignFlag  self signFlag ifTrue: [ self objectAt: 1 put: self header - SmallInteger minVal ]testToByDo  daysInMonth: aMonthNumber  ^(DateAndTime year: self year month: aMonthNumber day: 1) asMonth daysInMonthlistAtCategoryNamed: aName  ^(self protocolOrganizer methodsInProtocolNamed: aName) asArraycompressedSourceCode  kind == #EmbeddedSourceQCompress ifTrue: [ ^data ].  kind == #EmbeddedSourceZip ifTrue: [ ^data ].  ^nilstopMethod: aMethod during: aBlock  (activeMethods includes: aMethod) ifTrue: [ ^self ].  activeMethods add: aMethod.  aBlock ensure: [ activeMethods remove: aMethod ]from  ^frombyteSizeOfInstanceOfSize: basicSize  < primitive: 181 error: ec>  self isVariable ifTrue: [ (basicSize isInteger and: [ basicSize >= 16r1000000 ]) ifTrue: [ ^2 * (self byteSizeOfInstanceOfSize: (basicSize + 1) // 2) - (self byteSizeOfInstanceOfSize: 0) ] ] ifFalse: [ basicSize = 0 ifTrue: [ ^self byteSizeOfInstance ] ].  self primitiveFailedreciprocal  ^1 / self// aNumber  < primitive: 12>  ^super // aNumbertestDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 29negative  ^self < 0testCritical  | lock |  lock := Semaphore forMutualExclusion.  [ lock critical: [ self criticalError ] ] forkAt: Processor userInterruptPriority.  self assert: lock isSignaledtestMutateObjectFirstInstVarWithManyVars  | guineaPig failure |  guineaPig := WriteBarrierStub new.  guineaPig beReadOnlyObject.  failure := [ guineaPig var1: #test ] on: ModificationForbidden do: [:err |  err ].  self assert: failure fieldIndex equals: 1freezeUpTo: aContext  signalContext := signalContext copyTo: aContextsourceNodeExecutedForPC: aPC  ^self sourceNode sourceNodeExecutedForPC: aPCgtBytecodeDebuggerRetrieveContextValues  | fieldList displayedTemp slotsSize tempNames |  fieldList := OrderedCollection new.  displayedTemp := OrderedCollection new.  tempNames := self tempNames.  self stackPtr to: 1 by: -1 do: [:tempIndex |  | tempNode |        fieldList add: (tempIndex <= tempNames size ifTrue: [ displayedTemp add: (tempNames at: tempIndex).                    tempNode := GTInspectorContextNamedTempNode hostObject: self tempName: (tempNames at: tempIndex) tempIndex: tempIndex.                    GTInspectorWrapperNode hostObject: tempNode label: (tempIndex - 1) asString , ' [' , (tempNames at: tempIndex) , ']' ] ifFalse: [ tempNode := GTInspectorContextIndexedTempNode hostObject: self tempIndex: tempIndex.                    GTInspectorWrapperNode hostObject: tempNode label: (tempIndex - 1) asString ]) ].  (tempNames copy asOrderedCollection     removeAll: displayedTemp;     yourself) ifNotEmpty: [:uninitializedTemps |  uninitializedTemps do: [:each |  GTInspectorDynamicNode hostObject: self label: '- [' , each , ']' value: nil ] ].  fieldList addAll: (self gtDebuggerDoItBindings collect: [:aBinding |  (GTInspectorDynamicNode hostObject: self label: aBinding key value: aBinding value)                 variableTag: 'temp';                 yourself ]).  slotsSize := self receiver class allSlots size.  fieldList addAll: (self receiver class allSlots reverse collect: [:slot |  | slotNode |              slotNode := GTInspectorSlotNode hostObject: self receiver slot: slot.              GTInspectorWrapperNode hostObject: slotNode label: 'rcv' , (slotsSize := slotsSize - 1) asString , ' [' , slot name , ']' ]).  ^fieldList asOrderedCollection     addFirst: (GTInspectorSelfNode hostObject: self receiver);     addLast: (GTInspectorDynamicNode hostObject: self label: 'thisContext' value: self);     yourselfspotterProcessorsFor: aSpotterStep pragma: aPragma  [ | processorsSize addedProcessorsSize |  processorsSize := aSpotterStep processors size.  self perform: aPragma methodSelector with: aSpotterStep.  addedProcessorsSize := aSpotterStep processors size - processorsSize.  (aSpotterStep processors last: addedProcessorsSize) do: [:processor |  processor order: (aPragma argumentAt: 1) ] ] on: Error do: [:exception |  aSpotterStep exceptionHandler handleException: exception do: [ ('[Spotter] Exception while collecting processors for <' , self class name , '>: ' , exception asString) traceCr ] ]testXor  self assert: (true xor: true) equals: false.  self assert: (true xor: false) equals: true.  self assert: (true xor: [ true ]) equals: false.  self assert: (true xor: [ false ]) equals: truemethod  ^outerContext methodtestNumberOfMethods  self assert: Point numberOfMethods equals: Point localMethods size + Point class localMethods sizesuperMessages  ^self ast superMessagesunscheduleAtTimingPriority  readyToUnschedule signal.  super unscheduleAtTimingPrioritybaseLocalMethods  ^self instanceSide methodDictcritical: aBlock  ^self pvtCritical: aBlock startingAt: 1subclass: aTraitName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self subclass: aTraitName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cattestIfTrueIfFalse  self assert: (false ifTrue: [ 'trueAlternativeBlock' ] ifFalse: [ 'falseAlternativeBlock' ]) equals: 'falseAlternativeBlock'testDayMonthYearDo  | iterations |  iterations := 0.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  iterations := iterations + 1 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear ]) equals: 1901.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay ]) equals: 1penultimateLiteral  ^nilspotterPackageFor: aStep  < spotterOrder: 50>  aStep listProcessor     title: 'Package';     allCandidates: [ {self package} ];     itemName: [:item |  item packageName ];     itemIcon: #systemIcon;     filter: GTFilterSubstringtestDateAndTimes  | answer |  self assert: aSchedule dateAndTimes size equals: 104.  self assert: aSchedule dateAndTimes first equals: firstEvent.  answer := true.  aSchedule dateAndTimes do: [:each |  (each dayOfWeekName = 'Saturday' or: [ each dayOfWeekName = 'Sunday' ]) ifFalse: [ ^false ] ].  self assert: answersimpleIsNestedTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselfallSuperclasses  | temp |  ^self superclass == nil ifTrue: [ OrderedCollection new ] ifFalse: [ temp := self superclass allSuperclasses.        temp addFirst: self superclass.        temp ]highestPriority: newHighestPriority  | newProcessLists |  (quiescentProcessLists size > newHighestPriority and: [ self anyProcessesAbove: newHighestPriority ]) ifTrue: [ self error: 'There are processes with priority higher than ' , newHighestPriority printString ].  newProcessLists := Array new: newHighestPriority.  1 to: (quiescentProcessLists size min: newProcessLists size) do: [:priority |  newProcessLists at: priority put: (quiescentProcessLists at: priority) ].  quiescentProcessLists size to: newProcessLists size do: [:priority |  newProcessLists at: priority put: ProcessList new ].  quiescentProcessLists := newProcessListssimulatePrimitive: primitiveIndex in: aMethod receiver: aReceiver arguments: arguments  | key simulator |  key := primitiveIndex = 117 ifTrue: [ | literal |        literal := aMethod literalAt: 1.        {literal second .         literal first} ] ifFalse: [ primitiveIndex ].  simulator := self class specialPrimitiveSimulators at: key ifAbsent: [ ^primitiveIndex = 117 ifTrue: [ self withoutPrimitiveTryNamedPrimitiveIn: aMethod for: aReceiver withArgs: arguments ] ifFalse: [ aReceiver tryPrimitive: primitiveIndex withArgs: arguments ] ].  ^simulator simulatePrimitiveFor: aMethod receiver: aReceiver arguments: arguments context: selfmillisecondsToGo  ^ticker millisecondsUntilTick: resumptionTicktestInjectingExceptionHandlerFromProcessItself  | error interceptedError process interrupted |  DefaultExecutionEnvironment beActive.  error := Error new messageText: 'test error'.  interrupted := true.  process := [ Processor activeProcess on: Error do: [:err |  interceptedError := err ].  error signal.  interrupted := false ] fork.  [ process isTerminated ] whileFalse: [ Processor yield ].  self assert: interceptedError identicalTo: error.  self assert: interruptedisManifest  ^falsestoreOn: aStream  | noneYet |  aStream nextPutAll: '(('.  aStream nextPutAll: self class name.  aStream nextPutAll: ' newMethod: '.  aStream store: self size - self initialPC + 1.  aStream nextPutAll: ' header: '.  aStream store: self header.  aStream nextPut: $).  noneYet := self storeElementsFrom: self initialPC to: self endPC on: aStream.  1 to: self numLiterals do: [:index |  noneYet ifTrue: [ noneYet := false ] ifFalse: [ aStream nextPut: $; ].        aStream nextPutAll: ' literalAt: '.        aStream store: index.        aStream nextPutAll: ' put: '.        aStream store: (self literalAt: index) ].  noneYet ifFalse: [ aStream nextPutAll: '; yourself' ].  aStream nextPut: $)asPresenter  ^self asString asPresenterselector  ^selectorfuelAccept: aGeneralMapper  ^aGeneralMapper visitHookPrimitive: selfnbCall: fnSpec module: aModuleNameOrHandle  < ffiCalloutTranslator>  self deprecated: 'use ffiCall:module: instead'.  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     function: fnSpec library: aModuleNameOrHandleasMinimalRepresentation  self isReceiverOrAnyArgumentGarbage ifTrue: [ ^nil ] ifFalse: [ ^self ]days  ^seconds quo: SecondsInDaymethodReturnConstant: value  ^self return: value from: self methodReturnContextasYear  ^Year starting: selflink: aMetaLink toAST: aNode  aNode link: aMetaLink forObject: selfencodeOn: aDocument  testObjectFormatInstSize  | classes offending |  offending := SystemNavigation default allBehaviors reject: [:cls |  cls instSize = (cls allSlots reject: #isVirtual) size ].  self assertCollection: offending hasSameElements: {}.  classes := SystemNavigation default allBehaviors select: [:cls |  cls isTrait not and: [ cls instSpec = 0 ] ].  offending := classes reject: [:each |  each instVarNames isEmpty or: [ each isVariable not ] ].  self assertCollection: offending hasSameElements: {}printHMSWithDashesOn: aStream  self printHMSOn: aStream separatedBy: $-numLiterals  ^self header bitAnd: 16r7FFFat: index put: anObject  self shouldNotImplementsize  ^sizestonProcessSubObjects: block  1 to: self class instSize do: [:each |  self instVarAt: each put: (block value: (self instVarAt: each)) ].  (self class isVariable and: [ self class isBytes not ]) ifTrue: [ 1 to: self basicSize do: [:each |  self basicAt: each put: (block value: (self basicAt: each)) ] ]waitForProcessTermination: aProcess  aProcess priority: Processor activePriority + 1.  [ aProcess isTerminated ] whileFalse: [ Processor yield ]spotterForMessagesFor: aStep  < spotterOrder: 12>  aStep listProcessor     title: 'Messages';     allCandidates: [ self messages asSortedCollection collect: [:each |  GTSelector new name: each ] ];     filter: GTFilterSubstringshouldNotBeRedefined  ^(Smalltalk specialObjectsArray identityIndexOf: self ifAbsent: [ (self isKindOf: self) ifTrue: [ 1 ] ifFalse: [ 0 ] ]) ~= 0usesPoolVarNamed: aString  ^self allSharedPools anySatisfy: [:each |  each usesClassVarNamed: aString ]pointer  self error: 'You cannot get a pointer to me.'shutDown  self suspenddragTransferType  ^nilfourthByte  ^self method at: pc + 3isBehavior  ^falsequickMerge: aRectangle  | useRcvr rOrigin rCorner minX maxX minY maxY |  aRectangle ifNil: [ ^self ].  useRcvr := true.  rOrigin := aRectangle topLeft.  rCorner := aRectangle bottomRight.  minX := rOrigin x < origin x ifTrue: [ useRcvr := false.        rOrigin x ] ifFalse: [ origin x ].  maxX := rCorner x > corner x ifTrue: [ useRcvr := false.        rCorner x ] ifFalse: [ corner x ].  minY := rOrigin y < origin y ifTrue: [ useRcvr := false.        rOrigin y ] ifFalse: [ origin y ].  maxY := rCorner y > corner y ifTrue: [ useRcvr := false.        rCorner y ] ifFalse: [ corner y ].  useRcvr ifTrue: [ ^self ] ifFalse: [ ^Rectangle origin: minX @ minY corner: maxX @ maxY ]runSimulated: aBlock  thisContext runSimulated: aBlock contextAtEachStep: [:current |   ]mustBeBooleanDeOptimizeIn: context  | ret cache method |  cache := context method propertyAt: #mustBeBooleanCache ifAbsentPut: [ IdentityDictionary new ].  method := cache at: context pc - 1 ifAbsent: [ self mustBeBooleanCompileExpression: context andCache: cache ].  ret := context receiver withArgs: {context} executeMethod: method.  context pc: (method propertyAt: #mustBeBooleanJump).  ^retgenUnsignedSingleExtendA: extendedIndex  (extendedIndex between: 0 and: 255) ifFalse: [ ^self outOfRangeError: 'index' index: extendedIndex range: 0 to: 255 ].  stream     nextPut: 224;     nextPut: extendedIndexmin: aMagnitude  self < aMagnitude ifTrue: [ ^self ] ifFalse: [ ^aMagnitude ]lookupSymbol: aSymbol  | var |  var := self sourceNodeExecuted scope lookupVar: aSymbol.  var isTemp ifTrue: [ ^self tempNamed: aSymbol ].  var isInstance ifTrue: [ ^self receiver instVarNamed: aSymbol ].  var isGlobal ifTrue: [ ^var assoc value ].  ^niltestMonth  self assert: aDateAndTime month equals: 1.  self assert: aDateAndTime monthAbbreviation equals: 'Jan'.  self assert: aDateAndTime monthName equals: 'January'.  self assert: aDateAndTime monthIndex equals: 1testprintSubclassesOnLevelFilterA  | expected result stream |  expected := '	ExampleForTest1 #()		ExampleForTest11 #()			ExampleForTest112 #()'.  result := String new: expected size.  stream := ReadWriteStream on: result.  ExampleForTest1 printSubclassesOn: stream level: 1 filter: {ExampleForTest1 .         ExampleForTest11 .         ExampleForTest112}.  self assert: result equals: expectedrightCenter  ^self right @ self center ytestDateTimeDenotation2  | lateEveningInLondon lateEveningInLocalTimeOfMoscow localMoscowTimeFromDenotation |  lateEveningInLondon := DateAndTime year: 2004 month: 11 day: 30 hour: 23 minute: 30 second: 0 offset: 0 hours.  lateEveningInLocalTimeOfMoscow := lateEveningInLondon offset: 3 hours.  localMoscowTimeFromDenotation := '2004-12-01T02:30:00+03:00' asDateAndTime.  self assert: lateEveningInLocalTimeOfMoscow equals: localMoscowTimeFromDenotationnoteCompilationOf: aSelector meta: isMeta  reflectiveMethod: aReflectiveMethod  self propertyAt: #reflectiveMethod put: aReflectiveMethodhighBit  self < 0 ifTrue: [ ^self error: 'highBit is not defined for negative integers' ].  ^self highBitOfPositiveReceiverasSmallPositiveDegrees  ^self \\ 360labelForSelector: aSymbol  ^aSymbol asCapitalizedPhrasetestExample2  self assert: (self example2: 5) equals: (1 to: 5) asOrderedCollectiontestIfNotNil  nil ifNotNil: [ self fail: 'should not get here' ]isRingFullyUnresolved  ^falsefuelAccept: aGeneralMapper  self class isFixed ifTrue: [ ^aGeneralMapper visitFixedObject: self ].  self class isWeak ifTrue: [ ^aGeneralMapper visitWeakObject: self ].  self class isPointers ifTrue: [ ^aGeneralMapper visitVariableObject: self ].  self class isBytes ifTrue: [ ^aGeneralMapper visitBytesObject: self ].  self class isWords ifTrue: [ ^aGeneralMapper visitWordsObject: self ].  self error: 'Something is wrong!'adaptToFloat: rcvr andCompare: selector  rcvr isFinite ifFalse: [ selector == #= ifTrue: [ ^false ].        selector == #~= ifTrue: [ ^true ].        rcvr isNaN ifTrue: [ ^false ].        (selector = #< or: [ selector = #<= ]) ifTrue: [ ^rcvr positive not ].        (selector = #> or: [ selector = #>= ]) ifTrue: [ ^rcvr positive ].        ^self error: 'unknow comparison selector' ].  ^rcvr asTrueFraction perform: selector with: selftestSignalWithTag  | aTag |  aTag := Object new.  [ DomainError signal: 'aMessage' withTag: aTag.  self fail: 'The exception was not signaled' ] on: DomainError do: [:e |  self assert: e messageText equals: 'aMessage'.        self assert: e tag equals: aTag ]testDigitLength  | lpi |  lpi := 114605103402541699037609980192546360895434064385.  self assert: 20 equals: lpi bytesCountdeepCopy  ^self shallowCopytestMemoizedDictionary  | cache factorial result |  cache := Dictionary new.  factorial := 0.  factorial := [:n |  n = 1 ifTrue: [ 1 ] ifFalse: [ (factorial value: n - 1) * n ] ] memoizedUsing: cache.  result := (1 to: 5) collect: factorial.  self assert: result equals: #(1 2 6 24 120).  self assert: cache associations equals: {(1 -> 1) .         (2 -> 2) .         (3 -> 6) .         (4 -> 24) .         (5 -> 120)}whileFalse  self value ifFalse: [ self whileFalse ]finalizationRegistry  ^WeakRegistry defaultfuelAccept: aGeneralMapper  ^aGeneralMapper visitHookPrimitive: selfvalueNoContextSwitch  < primitive: 221>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  self primitiveFailednonObsoleteClass  | obsName |  obsName := self name.  [ obsName beginsWith: 'AnObsolete' ] whileTrue: [ obsName := obsName copyFrom: 'AnObsolete' size + 1 to: obsName size ].  ^self environment at: obsName asSymbolhour24  ^self localSeconds // SecondsInHour \\ 24ephemeronSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat  ^self classInstaller make: [:builder |  builder           superclass: self;           name: t;           layoutClass: EphemeronLayout;           slots: f asSlotCollection;           sharedVariablesFromString: d;           sharedPools: s;           category: cat;           environment: self environment ]asApproximateFractionAtOrder: maxOrder  | num1 denom1 num2 denom2 int frac newD temp order |  num1 := self asInteger.  denom1 := 1.  num2 := 1.  denom2 := 0.  int := num1.  frac := self fractionPart.  order := maxOrder = 0 ifTrue: [ -1 ] ifFalse: [ maxOrder ].  [ frac = 0 or: [ order = 0 ] ] whileFalse: [ order := order - 1.        newD := 1.0 / frac.        int := newD asInteger.        frac := newD fractionPart.        temp := num2.        num2 := num1.        num1 := num1 * int + temp.        temp := denom2.        denom2 := denom1.        denom1 := int * denom1 + temp.        10000000000.0 < denom1 ifTrue: [ num2 = 0.0 ifTrue: [ ^Fraction numerator: num1 denominator: denom1 ].              ^Fraction numerator: num2 denominator: denom2 ] ].  denom1 = 1 ifTrue: [ ^num1 ] ifFalse: [ ^Fraction numerator: num1 denominator: denom1 ]testTicks  self assert: aTime ticks equals: #(0 45296 0).  self assert: aTime equals: (Time new ticks: #(0 45296 0))printOn: aStream  aStream nextPutAll: 'a Week starting: '.  self start printOn: aStreamtestEqual  self assert: atPragma equals: atPragma.  self assert: atPragma equals: anotherAtPragma.  self assert: anotherAtPragma equals: atPragma.  self assert: atPragma equals: anotherAtPragma.  self assert: anotherAtPragma equals: yetAnotherAtPragma.  self assert: yetAnotherAtPragma equals: atPragma.  self deny: atPragma equals: atPutPragmacontinuationExample3: aCollection  | stream processor collector |  stream := [:collection |  | i localBlock |  i := 1.  localBlock := [ | current |  current := collection at: i.  i := i + 1.  Array with: current with: (i <= collection size ifTrue: [ localBlock ] ifFalse: [ nil ]) ] ].  processor := [:valueWithContinuation :activity |  | localBlock |  localBlock := [ | current |  current := valueWithContinuation value.  Array with: (activity value: current first) with: (current last notNil ifTrue: [ localBlock ]) ].  localBlock ].  collector := [:valueWithContinuation |  | oc |  oc := OrderedCollection new.  [ | local |  local := valueWithContinuation value.  oc add: local first.  local last notNil ] whileTrue: [  ].  oc ].  ^collector value: (processor value: (processor value: (stream value: aCollection) value: [:x |  x * x ]) value: [:x |  x - 10 ])smartDescription  message ifNil: [ ^self description ].  ^self classSymbol printString , ' is missing, and does not understand ' , message selector printStringstate: aSymbol  state := aSymbolisLiteral  ^trueselectorsToBeIgnored  | private |  private := #(#printOn:).  ^super selectorsToBeIgnored , privatetestHex  self assert: 0 hex equals: '16r0'.  self assert: 12 hex equals: '16rC'.  self assert: 1234 hex equals: '16r4D2'propertyAt: propName put: propValue  ^self ensureProperties at: propName ifAbsentPut: propValuegtInspectorPreviewIn: composite  < gtInspectorPresentationOrder: 30>  composite morph     title: 'Calendar';     morph: [ CalendarMorph on: self ]sign: aNumber  ^aNumber copySignTo: selfchanged  self changed: selfveryDeepCopyWith: deepCopier  waitingProcessesAt: aPriority  ^quiescentProcessLists at: aPrioritygtDebuggerEvaluatorIn: composite  (GTObjectVariablesBrowser new evaluatorIn: composite) title: 'Evaluator'size  ^self count: [:each |  true ]weakSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat  ^self classInstaller make: [:builder |  builder           superclass: self;           name: t;           layoutClass: WeakLayout;           slots: f asSlotCollection;           sharedVariablesFromString: d;           sharedPools: s;           category: cat;           environment: self environment ]intanceSpecificMetaLinksAvailable  ^falsegtFilter  ^selfpropertyValueAt: aKey  ^self propertyAt: aKeylink: aMetaLink toNodes: nodes  nodes do: [:node |  self link: aMetaLink toAST: node ]testNegativeZeroSign  self assert: Float negativeZero sign equals: 0.  self assert: Float negativeZero signBit equals: 1codeForNoSource  Smalltalk hasCompiler ifFalse: [ ^nil ].  ^(self compiler decompileMethod: self) formattedCodecriticClass  ^selfveryDeepFixupWith: deepCopier  simulateValueWithArguments: anArray caller: aContext  | newContext sz |  newContext := (Context newForMethod: outerContext method) setSender: aContext receiver: outerContext receiver method: outerContext method closure: self startpc: startpc.  ((newContext objectClass: anArray) ~~ Array or: [ numArgs ~= anArray size ]) ifTrue: [ ^Context primitiveFailTokenFor: nil ].  sz := self basicSize.  newContext stackp: sz + numArgs.  1 to: numArgs do: [:i |  newContext at: i put: (anArray at: i) ].  1 to: sz do: [:i |  newContext at: i + numArgs put: (self at: i) ].  ^newContextmessageText  ^messageText ifNil: [ String empty ]select: aBlock  | basicSize newSelf size selection |  basicSize := self basicSize.  newSelf := self species new: basicSize.  size := 0.  1 to: basicSize do: [:i |  (self basicAt: i) ifNotNil: [:dep |  (aBlock value: dep) ifTrue: [ newSelf basicAt: (size := size + 1) put: dep ] ] ].  selection := self species new: size.  selection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.  ^selectionencodeOn: aDocument  | converter |  converter := GRSignPrinter new , (GRNumberPrinter new precision: self scale).  converter print: self on: aDocumenttestTicksOffset  self assert: aDateAndTime equals: (aDateAndTime ticks: #(2415386 0 0) offset: DateAndTime localOffset)allProtocols  ^{allProtocol} , protocols asArrayisSelfEvaluating  ^self == ProcessortestDayMonthYearDo  | iterations |  iterations := 0.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  iterations := iterations + 1 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachYear ]) equals: 1970.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachMonth ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:eachDay :eachMonth :eachYear |  eachDay ]) equals: 1- anInteger  < primitive: 22>  ^super - anIntegertruncated  self isIntegerPoint ifTrue: [ ^self ].  ^x truncated @ y truncatedsetDescriptionInMetacelloVersion: aMetacelloVersionSpec  aMetacelloVersionSpec setDescription: selfprintString  | integer next result len |  self = 0 ifTrue: [ ^'0' ].  self < 0 ifTrue: [ ^'-' , self negated printString ].  len := self decimalDigitLength.  result := String new: len.  integer := self.  len to: 1 by: -1 do: [:i |  next := integer // 10.        result byteAt: i put: 48 + (integer - (next * 10)).        integer := next ].  ^resultcompiledMethod  ^selfcompileAll  ^self compileAllFrom: selfcaseOf: aBlockAssociationCollection otherwise: aBlock  aBlockAssociationCollection associationsDo: [:assoc |  assoc key value = self ifTrue: [ ^assoc value value ] ].  ^aBlock valuetestPrintMinutes  self assert: aTime printMinutes equals: '12:34 pm'testAddCategory  self organization addCategory: 'test-protocol'.  self assert: (self organization categories includes: 'test-protocol')\\\ anInteger  ^(self digitDiv: anInteger neg: false) secondrespondsTo: aSymbol  ^self class canUnderstand: aSymbolisInfinite  ^falseargumentNames  ^self propertyAt: #argumentNames ifAbsent: [ super argumentNames ]flipBy: direction centerAt: aPoint  ^(origin flipBy: direction centerAt: aPoint) rectangle: (corner flipBy: direction centerAt: aPoint)testDaysInYear  self assert: aTimespan daysInYear equals: 365isSystemWindow  ^falsepsValueAt: index put: value  env ifNil: [ env := WeakArray new: PSKeys size ].  env size < PSKeys size ifTrue: [ env := env grownBy: PSKeys size - env size ].  ^env at: index put: valuetestUnionWithDisjoint  self assert: (aTimespan union: aDisjointTimespan) equals: (Timespan starting: jan01 duration: 14 days)basicCheckClass: aClass  | warnings |  warnings := Set new.  (aClass includesSelector: #veryDeepInner:) ifTrue: [ | veryDeepInnerMethod |        veryDeepInnerMethod := aClass >> #veryDeepInner:.        (self doesMethod: #veryDeepInner: writeAllInstanceVariablesOfClass: aClass) ifFalse: [ warnings add: veryDeepInnerMethod ] ].  (aClass includesSelector: #veryDeepCopyWith:) ifTrue: [ | veryDeepCopyWithMethod |        veryDeepCopyWithMethod := aClass >> #veryDeepCopyWith:.        veryDeepCopyWithMethod size > 20 & (veryDeepCopyWithMethod literals includes: #veryDeepCopyWith:) not ifTrue: [ (self doesMethod: #veryDeepCopyWith: writeAllInstanceVariablesOfClass: aClass) ifFalse: [ warnings add: veryDeepCopyWithMethod ] ] ].  ^warningsasMinimalDecimalFraction  | significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead denominator numerator |  self isFinite ifFalse: [ self error: 'Only finite Float can be converted to a Fraction' ].  self = 0.0 ifTrue: [ ^0 ].  self < 0.0 ifTrue: [ ^self negated asMinimalDecimalFraction negated ].  numerator := 0.  denominator := 0.  significand := self significandAsInteger.  roundingIncludesLimits := significand even.  exp := self exponent - 52 max: MinValLogBase2.  baseExpEstimate := (self exponent * 10 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.  exp >= 0 ifTrue: [ significand ~= 16r10000000000000 ifTrue: [ r := significand bitShift: 1 + exp.              s := 2.              mPlus := mMinus := 1 bitShift: exp ] ifFalse: [ r := significand bitShift: 2 + exp.              s := 4.              mPlus := 2 * (mMinus := 1 bitShift: exp) ] ] ifFalse: [ (exp = MinValLogBase2 or: [ significand ~= 16r10000000000000 ]) ifTrue: [ r := significand bitShift: 1.              s := 1 bitShift: 1 - exp.              mPlus := mMinus := 1 ] ifFalse: [ r := significand bitShift: 2.              s := 1 bitShift: 2 - exp.              mPlus := 2.              mMinus := 1 ] ].  baseExpEstimate >= 0 ifTrue: [ s := s * (10 raisedToInteger: baseExpEstimate) ] ifFalse: [ scale := 10 raisedToInteger: baseExpEstimate negated.        r := r * scale.        mPlus := mPlus * scale.        mMinus := mMinus * scale ].  ((r + mPlus < s) not and: [ roundingIncludesLimits or: [ r + mPlus > s ] ]) ifTrue: [ baseExpEstimate := baseExpEstimate + 1 ] ifFalse: [ r := r * 10.        mPlus := mPlus * 10.        mMinus := mMinus * 10 ].  (fixedFormat := baseExpEstimate between: -3 and: 6) ifTrue: [ decPointCount := baseExpEstimate.        baseExpEstimate <= 0 ifTrue: [ denominator := 10 raisedTo: baseExpEstimate negated ] ] ifFalse: [ decPointCount := 1 ].  slowbit := 1 - s lowBit.  shead := s bitShift: slowbit.  [ d := (r bitShift: slowbit) // shead.  r := r - (d * s).  (tc1 := (r > mMinus) not and: [ roundingIncludesLimits or: [ r < mMinus ] ]) | (tc2 := (r + mPlus < s) not and: [ roundingIncludesLimits or: [ r + mPlus > s ] ]) ] whileFalse: [ numerator := 10 * numerator + d.        denominator := 10 * denominator.        r := r * 10.        mPlus := mPlus * 10.        mMinus := mMinus * 10.        decPointCount := decPointCount - 1.        decPointCount = 0 ifTrue: [ denominator := 1 ] ].  tc2 ifTrue: [ (tc1 not or: [ r * 2 >= s ]) ifTrue: [ d := d + 1 ] ].  numerator := 10 * numerator + d.  denominator := 10 * denominator.  decPointCount > 0 ifTrue: [ numerator := (10 raisedTo: decPointCount - 1) * numerator ].  fixedFormat ifFalse: [ baseExpEstimate - 1 > 0 ifTrue: [ numerator := (10 raisedTo: baseExpEstimate - 1) * numerator ] ifFalse: [ denominator := (10 raisedTo: 1 - baseExpEstimate) * (denominator max: 1) ] ].  denominator < 2 ifTrue: [ ^numerator ].  ^numerator / denominatortestRNG  | chars uniqueCount |  chars := (1 to: 100) collect: [:_ |  unicodeGenerator randomCharacter ].  uniqueCount := chars asSet size.  self assert: uniqueCount = 100 description: (100 - uniqueCount) asString , ' duplicates'benchFib  ^self < 2 ifTrue: [ 1 ] ifFalse: [ (self - 1) benchFib + (self - 2) benchFib + 1 ]testEmbeddingSourceCodeWide  self testEmbeddingSourceCode: 'doit ^''Под южно дърво, цъфтящо в синьо, бягаше малко пухкаво зайче.'' 'testExample1  | method |  method := self class compiledMethodAt: #example1.  self assert: (self hasInstVarRef: method)gtDisplayOn: aStream  aStream     print: self methodClass;     nextPutAll: '>>';     store: self selectorhasComment  ^self instanceSide organization hasCommentisLarge  ^falseprotocolsOfSelector: aSelector  ^(self protocols select: [:each |  each includesSelector: aSelector ]) asArrayscheduleDuration  ^schedule sumfileOutOn: aFileStream initializing: aBool  SystemNotification signal: self name.  super fileOutOn: aFileStream.  self class nonTrivial ifTrue: [ aFileStream           cr;           nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!';           cr;           cr.        self class fileOutOn: aFileStream initializing: aBool ]testIsTerminatingForcedTermination  | process unwound started terminator unwindChecks terminationSemaphore |  unwound := false.  started := false.  terminationSemaphore := Semaphore new.  terminationSemaphore signal.  process := [ started := true.  [ terminationSemaphore     wait;     wait ] ensure: [ terminator := Processor activeProcess.        unwindChecks value.        unwound := true ] ] newProcess.  process priority: Processor activePriority - 1.  self assert: process isSuspended.  self deny: process isTerminating.  self deny: process isTerminated.  self deny: started.  self deny: unwound.  process resume.  [ terminationSemaphore isSignaled ] whileTrue: [ 50 milliSeconds asDelay wait ].  self deny: process isSuspended.  self deny: process isTerminating.  self deny: process isTerminated.  self assert: started.  self deny: unwound.  self deny: terminator identicalTo: process.  terminationSemaphore signal.  process terminate.  unwindChecks := [ self assert: process isSuspended.  self assert: process isTerminating.  self deny: process isTerminated.  self assert: started.  self deny: unwound.  self assert: terminator identicalTo: process ].  [ process isTerminated ] whileFalse: [ 50 milliSeconds asDelay wait ].  self assert: process isSuspended.  self assert: process isTerminating.  self assert: process isTerminated.  self assert: started.  self assert: unwound.  self assert: terminator identicalTo: processfuelPointsTo: anObject  < primitive: 132>  hasMethodReturn  ^(InstructionStream on: self) scanFor: [:byte |  self encoderClass methodReturnBytecodes includes: byte ]asJob  ^Job block: selfprintOn: aStream  super printOn: aStream.  aStream     nextPutAll: '(';     nextPutAll: self identityHash printString;     nextPutAll: ') on ';     nextPutAll: ticker classNameasActionSequence  ^WeakActionSequence with: selfsetTraitComposition: aTraitCompositionOrArray  ^self uses: aTraitCompositionOrArray slots: self slotsstringForFileOut  ^String streamContents: [:aStream |  | elementIndex |        elementIndex := 1.        1 to: categoryArray size do: [:i |  aStream nextPut: $(.              (categoryArray at: i) asString printOn: aStream.              [ elementIndex <= (categoryStops at: i) ] whileTrue: [ aStream                       space;                       nextPutAll: (elementArray at: elementIndex).                    elementIndex := elementIndex + 1 ].              aStream                 nextPut: $);                 cr ] ]testEqual  self assert: aTime equals: (Time readFrom: '12:34:56' readStream).  self assert: aTime equals: (Time readFrom: '12:34:56.00' readStream).  self assert: aTime equals: (Time readFrom: '12:34:56.0000' readStream)numberOfDigitsInBase: b  | nDigits q total |  self negative ifTrue: [ ^self negated numberOfDigitsInBase: b ].  self < b ifTrue: [ ^1 ].  b isPowerOfTwo ifTrue: [ ^self highBit + b highBit - 2 quo: b highBit - 1 ].  q := self.  total := 0.  [ nDigits := b = 10 ifTrue: [ ((q highBit - 1) * 1233 >> 12) + 1 ] ifFalse: [ q highBit quo: b highBit ].  total := total + nDigits.  (q := q quo: (b raisedToInteger: nDigits)) < b ] whileFalse.  ^q = 0 ifTrue: [ total ] ifFalse: [ total + 1 ]handleSignal: exception  < debuggerCompleteToSender>  (self exceptionClass handles: exception) ifFalse: [ ^self nextHandlerContext handleSignal: exception ].  self evaluateSignal: exceptionisUsed  ^trueprint: anObject on: aStream  asIEEE32BitWord  | word1 word2 sign mantissa exponent destWord truncatedBits mask roundToUpper |  self = 0.0 ifTrue: [ ^self basicAt: 1 ].  word1 := self basicAt: 1.  word2 := self basicAt: 2.  sign := word1 bitAnd: 16r80000000.  exponent := ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.  mantissa := (word2 bitShift: -29) + ((word1 bitAnd: 16rFFFFF) bitShift: 3).  truncatedBits := word2 bitAnd: 16r1FFFFFFF.  exponent < -24 ifTrue: [ ^sign ].  exponent <= 0 ifTrue: [ mask := 1 bitShift: exponent negated.        mantissa := mantissa bitOr: 16r800000.        roundToUpper := (mantissa bitAnd: mask) isZero not and: [ truncatedBits isZero not or: [ (mantissa bitAnd: mask - 1) isZero not or: [ (mantissa bitAnd: mask * 2) isZero not ] ] ].        mantissa := mantissa bitShift: exponent - 1 ] ifFalse: [ roundToUpper := (truncatedBits bitAnd: 16r10000000) isZero not and: [ (mantissa bitAnd: 16r1) isZero not or: [ (truncatedBits bitAnd: 16r0FFFFFFF) isZero not ] ] ].  roundToUpper ifTrue: [ mantissa := mantissa + 1.        mantissa > 16r7FFFFF ifTrue: [ mantissa := 0.              exponent := exponent + 1 ] ].  exponent > 254 ifTrue: [ exponent := 255.        self isNaN ifTrue: [ mantissa isZero ifTrue: [ mantissa := 1 ] ] ifFalse: [ mantissa := 0 ] ].  destWord := (sign bitOr: ((exponent max: 0) bitShift: 23)) bitOr: mantissa.  ^destWordpropertyKeysAndValuesDo: aBlock  1 to: self basicSize do: [:i |  | propertyOrPragma |        (propertyOrPragma := self basicAt: i) isVariableBinding ifTrue: [ aBlock value: propertyOrPragma key value: propertyOrPragma value ] ]message  ^Message selector: selector arguments: argumentscallPrimitive: primNumber  | res |  res := receiver tryPrimitive: primNumber withArgs: self arguments.  primNumber >= (1 << 15) ifTrue: [ ^self push: res ].  (self isFailToken: res) ifTrue: [ ^self ].  self push: res.  self methodReturnTopas31BitSmallInt  ^selfsubclassesDo: aBlock  ^Class subclassesDo: [:cl |  cl isMeta ifTrue: [ aBlock value: cl soleInstance ] ]pvtCritical: aBlock startingAt: index  | mutex |  index > array size ifTrue: [ ^aBlock value ].  mutex := array at: index.  ^mutex critical: [ self pvtCritical: aBlock startingAt: index + 1 ]testNonResumableOuter  self should: [ [ Error signal.        4 ] on: Error do: [:ex |  ex outer.              ex return: 5 ] ] raise: ErrorinitSignals  excessSignals := 0isNaN  ^self ~= selfintanceSpecificMetaLinksAvailable  ^truebaseComposition  ^TaEmptyComposition newdeprecatedMethod5  addSubclass: aSubclass  aSubclass superclass ~~ self ifTrue: [ ^self error: aSubclass name , ' is not my subclass' ].  subclasses ifNil: [ self subclasses: (Array with: aSubclass).        ^self ].  self subclasses do: [:cl |  cl == aSubclass ifTrue: [ ^self ] ].  self subclasses: (subclasses copyWith: aSubclass)decodeZip  | len bytes |  len := self decodeLengthField.  bytes := ByteArray new: len.  1 to: len do: [:i |  bytes at: i put: (method at: method size - size + i) ].  data := (ZipReadStream on: bytes) contents asString convertFromEncoding: 'utf8'method  ^self subclassResponsibility