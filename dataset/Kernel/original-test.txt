radiansToDegrees  ^self / RadiansPerDegree-=JUAMPI=-withoutPrimitiveTryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments  | theMethod |  arguments size > 8 ifTrue: [ ^self class primitiveFailToken ].  theMethod := self class tryNamedPrimitiveTemplateMethod.  theMethod prepareForSimulationWith: arguments size.  theMethod == nil ifTrue: [ ^self class primitiveFailToken ].  self setNamedPrimitiveInformationFrom: aCompiledMethod toMethod: theMethod.  theMethod flushCache.  ^theMethod valueWithReceiver: aReceiver arguments: arguments-=JUAMPI=-forceNewFrom: anArray  | object max |  object := self new.  max := self instSize.  anArray doWithIndex: [:each :index |  index > max ifFalse: [ object instVarAt: index put: each ] ].  ^object-=JUAMPI=-ir  ^self ast ir-=JUAMPI=-defaultAction  Log ifNotNil: [:log |  log add: self ].  self logTranscript.  self raiseWarning ifTrue: [ super defaultAction ]-=JUAMPI=-adaptToInteger: rcvr andCompare: selector  self isFinite ifFalse: [ selector == #= ifTrue: [ ^false ].        selector == #~= ifTrue: [ ^true ].        self isNaN ifTrue: [ ^false ].        (selector = #< or: [ selector = #<= ]) ifTrue: [ ^self positive ].        (selector = #> or: [ selector = #>= ]) ifTrue: [ ^self positive not ].        ^self error: 'unknow comparison selector' ].  selector == #= ifTrue: [ self fractionPart = 0.0 ifFalse: [ ^false ] ].  selector == #~= ifTrue: [ self fractionPart = 0.0 ifFalse: [ ^true ] ].  ^rcvr perform: selector with: self asTrueFraction-=JUAMPI=-nthRoot: aPositiveInteger  | guess p |  guess := self nthRootRounded: aPositiveInteger.  (guess raisedTo: aPositiveInteger) = self ifTrue: [ ^guess ].  p := Float precision - guess highBitOfMagnitude.  p < 0 ifTrue: [ ^guess asFloat ].  guess := self << (p * aPositiveInteger) nthRootRounded: aPositiveInteger.  ^(guess / (1 << p)) asFloat-=JUAMPI=-numArgs  ^1-=JUAMPI=-storeIntoLiteralVariable: value  value value: self top-=JUAMPI=-suiteLog  suiteLog == nil ifTrue: [ suiteLog := OrderedCollection new ].  ^suiteLog-=JUAMPI=-startUp: resuming  ^self startUp-=JUAMPI=-testBasicCheck1  | testMethod |  testMethod := testClass >> (testClass compile: 'testMethod ' , self globalName , ' ' , self nonDeprecatedMethodName).  self assert: (testMethod externalProperties noneSatisfy: [:eprop |  eprop rule class = SendsDeprecatedMethodToGlobalRule ])-=JUAMPI=-testIntegerReadsNotOkFromString  self should: [ Integer readFrom: 'aaa' ] raise: Error.  self should: [ Integer readFrom: '-aaa' ] raise: Error.  self should: [ Integer readFrom: 'a3' base: 8 ] raise: Error-=JUAMPI=-doDup  self push: self top-=JUAMPI=-recursion  LocalRecursionStopper during: [ self recursion ]-=JUAMPI=-removeDependent: anObject  | dependents |  dependents := self dependents reject: [:each |  each == anObject ].  self myDependents: (dependents isEmpty ifFalse: [ dependents ]).  ^anObject-=JUAMPI=-readDataFrom: aDataStream size: varsOnDisk  | cntInstVars cntIndexedVars |  cntInstVars := self class instSize.  self class isVariable ifTrue: [ cntIndexedVars := varsOnDisk - cntInstVars.        cntIndexedVars < 0 ifTrue: [ self error: 'Class has changed too much.  Define a convertxxx method' ] ] ifFalse: [ cntIndexedVars := 0.        cntInstVars := varsOnDisk ].  aDataStream beginReference: self.  1 to: cntInstVars do: [:i |  self instVarAt: i put: aDataStream next ].  1 to: cntIndexedVars do: [:i |  self basicAt: i put: aDataStream next ].  ^self-=JUAMPI=-testNow  self deny: aDateAndTime equals: DateAndTime now-=JUAMPI=-testReadFrom  | s1 s2 s3 s4 s5 |  s1 := '2 June 1973' readStream.  s2 := '2-JUN-73' readStream.  s3 := 'June 2, 1973' readStream.  s4 := '6/2/73' readStream.  s5 := '2JUN73' readStream.  self     assert: (self dateClass readFrom: s1) equals: june2nd1973;     assert: (self dateClass readFrom: s2) equals: june2nd1973;     assert: (self dateClass readFrom: s3) equals: june2nd1973;     assert: (self dateClass readFrom: s4) equals: june2nd1973-=JUAMPI=-testSubtractDate  self assert: (january23rd2004 subtractDate: january23rd2004 previous) equals: 1.  self assert: (january23rd2004 subtractDate: january23rd2004) equals: 0.  self assert: (january23rd2004 subtractDate: january23rd2004 next) equals: -1-=JUAMPI=-weakSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategory  ^self weakSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory-=JUAMPI=-testMiddleOf  self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) equals: (Timespan starting: '12-31-1979' asDate duration: 2 days)-=JUAMPI=-halt  < debuggerCompleteToSender>  Halt now-=JUAMPI=-testSqrtErrorConditions  self should: [ (-1 / 4) sqrt ] raise: DomainError.  self should: [ (((1 << 1024) + 1) / ((1 << 1024) + 3)) negated sqrt ] raise: DomainError-=JUAMPI=-whichClassIncludesSelector: aSymbol  (self includesSelector: aSymbol) ifTrue: [ ^self ].  self superclass == nil ifTrue: [ ^nil ].  ^self superclass whichClassIncludesSelector: aSymbol-=JUAMPI=-pushLiteralVariable: value  self push: value value-=JUAMPI=-testBetweenAnd  self assert: (3 between: 0 and: 5).  self assert: (5.0 between: 5.0 and: 5.0).  self assert: (Date today between: Date today + 1 and: Date today + 3) not-=JUAMPI=-classVarNames  ^self instanceSide ifNil: [ #() ] ifNotNil: [:class |  class classVarNames ]-=JUAMPI=-nowTick  ^vmSimNow-=JUAMPI=-isPinnedInMemory  < primitive: 183 error: ec>  ^self primitiveFailed-=JUAMPI=-digitSubtract: arg  < primitive: 'primDigitSubtract' module: 'LargeIntegers'>  | smaller larger z sum sl al ng |  sl := self bytesCount.  al := arg bytesCount.  (sl = al ifTrue: [ [ (self byteAt: sl) = (arg byteAt: sl) and: [ sl > 1 ] ] whileTrue: [ sl := sl - 1 ].        al := sl.        (self byteAt: sl) < (arg byteAt: sl) ] ifFalse: [ sl < al ]) ifTrue: [ larger := arg.        smaller := self.        ng := self negative == false.        sl := al ] ifFalse: [ larger := self.        smaller := arg.        ng := self negative ].  sum := Integer new: sl neg: ng.  z := 0.  1 to: sl do: [:i |  z := z + (larger byteAt: i) - (smaller byteAt: i).        sum byteAt: i put: z - (z // 256 * 256).        z := z // 256 ].  ^sum normalize-=JUAMPI=-logEntry  self traceCr: 'Entered ' , thisContext sender printString-=JUAMPI=-asSpotterProcessorLink  ^GTSpotterProcessorLink value: self-=JUAMPI=-testNew  self assert: aDateAndTime equals: DateAndTime new-=JUAMPI=-testDuration  self assert: aDateAndTime duration equals: 0 asDuration-=JUAMPI=-prepareForNewProcess: aProcess  forkedProcesses add: aProcess-=JUAMPI=-testDayOfWeekWithUTC  | date |  date := DateAndTime julianDayNumber: 2456385 offset: (Duration hours: 2).  self assert: date dayOfWeek equals: 3-=JUAMPI=-raisedTo: n modulo: m  | a s mInv |  n = 0 ifTrue: [ ^1 ].  (self >= m or: [ self < 0 ]) ifTrue: [ ^self \\ m raisedTo: n modulo: m ].  n < 0 ifTrue: [ ^(self reciprocalModulo: m) raisedTo: n negated modulo: m ].  (n < 4096 or: [ m even ]) ifTrue: [ ^self slidingLeftRightRaisedTo: n modulo: m ].  mInv := self montgomeryDigitBase - ((m bitAnd: self montgomeryDigitMax) reciprocalModulo: self montgomeryDigitBase).  a := (1 bitShift: m montgomeryNumberOfDigits * m montgomeryDigitLength) \\ m.  (s := self montgomeryTimes: a * a \\ m modulo: m mInvModB: mInv) ifNil: [ ^self slidingLeftRightRaisedTo: n modulo: m ].  a := s montgomeryRaisedTo: n times: a modulo: m mInvModB: mInv.  ^a montgomeryTimes: 1 modulo: m mInvModB: mInv-=JUAMPI=-serializeOn: anEncoder  anEncoder     encodeUint32: self julianDayNumberUTC;     encodeUint32: self nanoSecond;     encodeInt24: self secondsSinceMidnightUTC;     encodeInt24: self offset asSeconds;     encodeInt32: self offset nanoSeconds-=JUAMPI=-testDigitAt  | lpi |  lpi := 114605103402541699037609980192546360895434064385.  1 to: 20 do: [:i |  | digit |        digit := lpi byteAt: i.        self assert: i equals: digit ]-=JUAMPI=-classSideCompiler  ^self classSideCompilerClass new     environment: self classSide environment;     class: self classSide-=JUAMPI=-testSqrtErrorConditions  self should: [ -1 sqrt ] raise: ArithmeticError-=JUAMPI=-waitUntil: aBlock for: aSymbolOrNil maxSeconds: aNumber  ^self waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asInteger-=JUAMPI=-hasSlotNamed: aString  ^self classLayout hasSlotNamed: aString-=JUAMPI=-deepCopy  -=JUAMPI=-testNoRecursion  RecursionStopper during: [ value := value + 1 ].  self assert: value equals: 1-=JUAMPI=-evaluate: aString  ^self compiler evaluate: aString-=JUAMPI=-testBasicReadOnly  self alwaysReadOnlyObjects do: [:each |  self assert: each isReadOnlyObject equals: true ]-=JUAMPI=-normalizeSecondsAndNanos  (NanosInSecond <= nanos or: [ nanos < 0 ]) ifTrue: [ seconds := seconds + (nanos // NanosInSecond).        nanos := nanos \\ NanosInSecond ].  (SecondsInDay <= seconds or: [ seconds < 0 ]) ifTrue: [ julianDayNumber := julianDayNumber + (seconds // SecondsInDay).        seconds := seconds \\ SecondsInDay ]-=JUAMPI=-valueNoContextSwitch: anArg  < primitive: 209>  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  self primitiveFailed-=JUAMPI=-degreeSin  self isFinite ifTrue: [ ^super degreeSin ].  ^self degreesToRadians sin-=JUAMPI=-ban: aCritique  ReSystemAnnouncer uniqueInstance notifyCritique: aCritique of: aCritique sourceAnchor entity bannedOn: self.  (TheManifestBuilder of: self) banRule: aCritique rule for: self-=JUAMPI=-valueSupplyingAnswer: anObject  ^(anObject isCollection and: [ anObject isString not ]) ifTrue: [ self valueSupplyingAnswers: {anObject} ] ifFalse: [ self valueSupplyingAnswers: {{'*' .               anObject}} ]-=JUAMPI=-symbolicBytecodes  ^SymbolicBytecodeBuilder decode: self-=JUAMPI=-testDaysInYear  self assert: aDateAndTime daysInYear equals: 365-=JUAMPI=-testIsAfter  | tzm8 tzp10 |  tzm8 := january23rd2004 translateTo: -8 hours.  tzp10 := january23rd2004 translateTo: 10 hours.  self     assert: (tzp10 isAfter: tzm8) not;     assert: (january23rd2004 isAfter: june2nd1973);     assert: (june2nd1973 isAfter: june2nd1973) not-=JUAMPI=-doPop  self pop-=JUAMPI=-stepIn: aWindow  ^self step-=JUAMPI=-index: anInteger  index := anInteger-=JUAMPI=-directionToLineFrom: p1 to: p2  ^(p2 x - p1 x) * (self y - p1 y) - ((self x - p1 x) * (p2 y - p1 y))-=JUAMPI=-testBlockVars  | continuation |  tmp := 0.  tmp := (self callcc: [:cc |  continuation := cc.        0 ]) + tmp.  tmp2 ifNotNil: [ tmp2 value ] ifNil: [ #(1 2 3) do: [:i |  self callcc: [:cc |  tmp2 := cc.                    continuation value: i ] ] ].  self assert: tmp equals: 6-=JUAMPI=-ticker  ^ticker-=JUAMPI=-testResumablePass  | result |  result := [ Notification signal.  4 ] on: Notification do: [:ex |  ex pass.        ex return: 5 ].  self assert: result equals: 4-=JUAMPI=-leftCenter  ^self left @ self center y-=JUAMPI=-sizePushConsArray: numElements  ^self sizeOpcodeSelector: #genPushConsArray: withArguments: {numElements}-=JUAMPI=-hash  ^self receiver hash bitXor: selector hash-=JUAMPI=-newSubclass  | i className |  i := 1.  [ className := (self name , i printString) asSymbol.  self environment includesKey: className ] whileTrue: [ i := i + 1 ].  ^self subclass: className instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: 'Unclassified'-=JUAMPI=-withAll: mutexList  array := mutexList-=JUAMPI=-resume  suspendedContext ifNil: [ ^self primitiveFailed ].  ^self primitiveResume-=JUAMPI=-- aNumber  self subclassResponsibility-=JUAMPI=-spotterPreviewCodeIn: aComposite  < spotterPreview: 10>  aComposite pharoMethod     title: [ self gtDisplayString ];     display: [:compiledMethod |  ' ' , compiledMethod sourceCode ];     smalltalkClass: [ self methodClass ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'-=JUAMPI=-classForTicker  ^DelayMillisecondTickerSimulation-=JUAMPI=-addCategory: aString  | oldCategories |  (self protocolOrganizer hasProtocolNamed: aString) ifTrue: [ ^self ].  oldCategories := self categories copy.  self protocolOrganizer addProtocolNamed: aString.  self notifyOfAddedCategory: aString.  self notifyOfChangedCategoriesFrom: oldCategories to: self categories-=JUAMPI=-propertyAt: propName ifAbsent: aBlock  self properties ifNil: [ ^aBlock value ].  ^self properties at: propName ifAbsent: aBlock-=JUAMPI=-localSendsToSuper  ^self encoderClass sendsToSuperFor: self-=JUAMPI=-instVarNames  ^self slots collect: [:each |  each name ]-=JUAMPI=-testStoreOn  | integer |  integer := SmallInteger maxVal + 1.  self     assert: integer class equals: LargePositiveInteger;     assert: (String streamContents: [:s |  integer storeOn: s ]) equals: integer asString-=JUAMPI=-testShiftMinusOne1LeftThenRight  1 to: 100 do: [:i |  self assert: ((-1 bitShift: i) bitShift: i negated) equals: -1 ]-=JUAMPI=-+ aNumber  < primitive: 1>  ^super + aNumber-=JUAMPI=-variableSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategory  ^self variableSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory-=JUAMPI=-subclass: aName uses: aTraitCompositionOrArray instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategory  ^self subclass: aName uses: aTraitCompositionOrArray layout: self classLayout class slots: someInstanceVariableNames asSlotCollection classVariablesNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory-=JUAMPI=-testStartStop  | error |  error := false.  [ scheduler stopTimerEventLoop ] on: Error do: [ error := true ].  self deny: error-=JUAMPI=-withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: limit  side = #top ifTrue: [ ^self withTop: (newPoint y min: corner y - minExtent y max: limit + minExtent y) ].  side = #bottom ifTrue: [ ^self withBottom: (newPoint y min: limit - minExtent y max: origin y + minExtent y) ].  side = #left ifTrue: [ ^self withLeft: (newPoint x min: corner x - minExtent x max: limit + minExtent x) ].  side = #right ifTrue: [ ^self withRight: (newPoint x min: limit - minExtent x max: origin x + minExtent x) ].  side = #topLeft ifTrue: [ ^(newPoint min: corner - minExtent) corner: self bottomRight ].  side = #bottomRight ifTrue: [ ^self topLeft corner: (newPoint max: origin + minExtent) ].  side = #bottomLeft ifTrue: [ ^self topRight rectangle: (newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y) ].  side = #topRight ifTrue: [ ^self bottomLeft rectangle: (newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y) ]-=JUAMPI=-hasInstVarRef: aMethod  | scanner end printer |  scanner := InstructionStream on: aMethod.  printer := InstVarRefLocator new.  end := scanner method endPC.  [ scanner pc <= end ] whileTrue: [ (printer interpretNextInstructionUsing: scanner) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-slotNamed: aName ifFound: foundBlock  ^self slotNamed: aName ifFound: foundBlock ifNone: [  ]-=JUAMPI=-combineFromIdx: myIdx  (collectionOfArrays at: myIdx) do: [:item |  buffer at: myIdx put: item.        myIdx = collectionOfArrays size ifTrue: [ resultProcessingBlock value: buffer shallowCopy ] ifFalse: [ self combineFromIdx: myIdx + 1 ] ]-=JUAMPI=-testIsClosePunctuation  self checkCorrespondanceOf: #isClosePunctuation: and: #Pe-=JUAMPI=-testPrintOn  self assert: (String streamContents: [:str |  aDateAndTime printOn: str ]) equals: '1970-01-01T00:00:00+00:00'.  self assert: (String streamContents: [:str |  aTimeZone printOn: str ]) equals: 'a TimeZone(UTZ)'-=JUAMPI=-handles: exception  ^false-=JUAMPI=-withAllSubclassesDo: aBlock  self withAllSubclasses do: aBlock-=JUAMPI=-propertyAt: aKey  ^self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]-=JUAMPI=-argumentAt: anInteger  ^self arguments at: anInteger-=JUAMPI=-testRetryingInstVarModification  | guineaPig |  guineaPig := MessageSend new.  guineaPig beReadOnlyObject.  [ guineaPig receiver: 1 ] on: ModificationForbidden do: [:err |  guineaPig beWritableObject.        err retryModification ].  self assert: guineaPig receiver equals: 1-=JUAMPI=-alt  ^KMModifier alt + self-=JUAMPI=-genJumpLong: distance  (distance between: -32768 and: 32767) ifFalse: [ ^self outOfRangeError: 'index' index: distance range: -32768 to: 32767 ].  (distance < 0 or: [ distance > 255 ]) ifTrue: [ self genSignedSingleExtendB: (distance bitShift: -8) ].  stream     nextPut: 237;     nextPut: (distance bitAnd: 255)-=JUAMPI=-isCollection  ^false-=JUAMPI=-parseDay  self isTwoDigitDayPattern ifTrue: [ ^self parseTwoDigitDay ].  self parseVariableDigitDay-=JUAMPI=-isExecutingBlock  ^self isBlockContext-=JUAMPI=-stonOn: stonWriter  stonWriter writeObject: self listSingleton: self asString-=JUAMPI=-blockNodes  ^self ast blockNodes-=JUAMPI=-allSelectorsAboveUntil: aRootClass  | coll |  coll := IdentitySet new.  (self allSuperclassesIncluding: aRootClass) do: [:aClass |  aClass selectorsDo: [:sel |  coll add: sel ] ].  ^coll-=JUAMPI=-senders  ^SystemNavigation default allSendersOf: self selector-=JUAMPI=-add: aLinkOrObject  ^self addLast: aLinkOrObject-=JUAMPI=-scaleFrom: rect1 to: rect2  ^rect2 topLeft + (((x - rect1 left) * rect2 width // rect1 width) @ ((y - rect1 top) * rect2 height // rect1 height))-=JUAMPI=-genJumpLong: distance  (distance >= -1024 and: [ distance < 1024 ]) ifTrue: [ stream           nextPut: 160 + (distance + 1024 bitShift: -8);           nextPut: (distance + 1024) \\ 256.        ^self ].  ^self outOfRangeError: 'distance' index: distance range: -1024 to: 1023-=JUAMPI=-testMutateByteArrayUsingDoubleAtPut  < expectedFailure>  | guineaPig |  guineaPig := ByteArray new: 8.  guineaPig beReadOnlyObject.  self should: [ guineaPig doubleAt: 1 put: (2 raisedTo: 65) asFloat ] raise: ModificationForbidden.  [ guineaPig doubleAt: 1 put: (2 raisedTo: 65) asFloat ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first equals: (2 raisedTo: 65) asFloat-=JUAMPI=-subclass: aSubclassSymbol instanceVariableNames: instVarNameList classVariableNames: classVarNames category: aCategorySymbol  ^self subclass: aSubclassSymbol instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: aCategorySymbol-=JUAMPI=-returnField  | prim |  prim := self primitive.  prim < 264 ifTrue: [ self error: 'only meaningful for quick-return' ] ifFalse: [ ^prim - 264 ]-=JUAMPI=-testPrint24OnWithoutSeconds  self assert: (String streamContents: [:str |  aTime print24: true showSeconds: true on: str ]) equals: '12:34:56'-=JUAMPI=-traitComposition  ^TaEmptyComposition new-=JUAMPI=-positive  ^self >= 0-=JUAMPI=-deprecated: anExplanationString  Deprecation new     context: thisContext sender;     explanation: anExplanationString;     signal-=JUAMPI=-valueSelector  self numArgs = 0 ifTrue: [ ^#value ].  ^(String streamContents: [:stream |  stream nextPutAll: 'value:'.        self numArgs - 1 timesRepeat: [ stream nextPutAll: 'value:' ] ]) asSymbol-=JUAMPI=-newExternalDependencyExistFor: aPackage  | dependencies newDependencies |  dependencies := self dependencyChecker dependenciesOf: aPackage packageName.  newDependencies := dependencies difference: self bootstrapPackages.  ^newDependencies notEmpty-=JUAMPI=-sizePushInstVarLong: instVarIndex  ^self sizeOpcodeSelector: #genPushInstVarLong: withArguments: {instVarIndex}-=JUAMPI=-drTestsBrowse  Smalltalk tools browser openOnClass: self-=JUAMPI=-testZeroDuration  | ts |  ts := Timespan starting: Date today duration: Duration zero.  self assert: ts start equals: ts end-=JUAMPI=-= aTime  ^[ self ticks = aTime ticks ] on: MessageNotUnderstood do: [ false ]-=JUAMPI=-isZero  ^origin isZero and: [ corner isZero ]-=JUAMPI=-hash  | tmp |  denominator isPowerOfTwo ifTrue: [ tmp := self asFloat.        tmp isFinite ifTrue: [ ^tmp hash ] ].  ^numerator hash bitXor: denominator hash-=JUAMPI=-bottomRight  ^corner-=JUAMPI=-signalException: anException  | oldList |  self isActiveProcess ifTrue: [ ^anException signal ].  myList ifNotNil: [ oldList := self suspend ].  suspendedContext := Context sender: suspendedContext receiver: self method: (self class lookupSelector: #pvtSignal:list:) arguments: (Array with: anException with: oldList).  oldList ifNotNil: [ self resume ]-=JUAMPI=-translateTo: anOffset  self dayMonthYearDo: [:day :month :year |  ^self class year: year month: month day: day hour: self hour minute: self minute second: self second nanoSecond: self nanoSecond offset: anOffset asDuration ]-=JUAMPI=-genStoreInstVar: instVarIndex  (instVarIndex >= 0 and: [ instVarIndex < 64 ]) ifTrue: [ stream           nextPut: 129;           nextPut: instVarIndex.        ^self ].  self genStoreInstVarLong: instVarIndex-=JUAMPI=-link: aMetaLink toSlotNamed: aSlotName  self link: aMetaLink toSlotNamed: aSlotName option: #all-=JUAMPI=-gtInspectorPragmasIn: composite  < gtInspectorPresentationOrder: 30>  composite tabulator     title: 'Pragmas';     when: [:x |  x pragmas notEmpty ];     with: [:t |  t           row: #pragmas;           row: #methods.        t transmit           to: #pragmas;           andShow: [:a |  a list                 title: 'Pragmas';                 display: [:method |  method pragmas ];                 when: [:x |  x pragmas notEmpty ] ].        t transmit           from: #pragmas;           to: #methods;           andShow: [:a |  a list                 title: 'Methods';                 display: [:pragma |  | methods |                    methods := OrderedCollection new.                    Object withAllSubclassesDo: [:each |  methods addAll: ((Pragma allNamed: pragma selector in: each) collect: #method) ].                    methods ];                 format: #selector ].        t transmit           toOutsidePort: #selection;           from: #methods port: #selection ];     startOn: self-=JUAMPI=-localMethods  ^self methods-=JUAMPI=-contextClass  ^self method methodClass-=JUAMPI=-asEnvironment  ^RBClassEnvironment class: self-=JUAMPI=-joinTo: stream  ^stream nextPut: self-=JUAMPI=-testReadTimeZoneOffsetISO822WithOtherCharactersAfter  self assert: (DateAndTime readTimezoneOffsetFrom: '+05:30 CommiterName' readStream) printString equals: '0:05:30:00'-=JUAMPI=-asFullRingDefinition  ^self instanceSide asFullRingDefinition classSide-=JUAMPI=-genPushConsArray: size  (size < 0 or: [ size > 127 ]) ifTrue: [ ^self outOfRangeError: 'size' index: size range: 0 to: 127 ].  stream     nextPut: 231;     nextPut: size + 128-=JUAMPI=-testIsZero  self assert: Duration zero isZero.  self assert: (Duration seconds: 0) isZero-=JUAMPI=-hasClassVarNamed: aString  ^self classVarNames includes: aString-=JUAMPI=-anyUserOfClassVarNamed: aSymbol  self withAllSubclasses do: [:subclass |  (Array with: subclass with: subclass class) do: [:classOrMeta |  (classOrMeta whichSelectorsReferTo: (self classPool associationAt: aSymbol)) ifNotEmpty: [ ^classOrMeta ] ] ].  ^nil-=JUAMPI=-fileOutPool: aPool onFileStream: aFileStream  | aPoolName |  (aPool isKindOf: SharedPool class) ifTrue: [ ^self notify: 'we do not fileout SharedPool type shared pools for now' ].  aPoolName := self environment keyAtIdentityValue: aPool.  SystemNotification signal: aPoolName.  aFileStream     nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!';     cr.  aFileStream     nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!';     cr.  aPool keys asSortedCollection do: [:aKey |  | aValue |        aValue := aPool at: aKey.        aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''' , ' put:  '.        (aValue isKindOf: Number) ifTrue: [ aValue printOn: aFileStream ] ifFalse: [ aFileStream nextPutAll: '('.              aValue printOn: aFileStream.              aFileStream nextPutAll: ')' ].        aFileStream           nextPutAll: '!';           cr ].  aFileStream cr-=JUAMPI=-testIsLineSeparator  self checkCorrespondanceOf: #isLineSeparator: and: #Zl-=JUAMPI=-gtInspectorRawIn: composite  < gtInspectorPresentationOrder: 10>  < gtInspectorTag: #basic>  ^composite custom: GTProtoObjectVariablesBrowser new-=JUAMPI=-encode  encodedData := nil.  self perform: ('encode' , kind) asSymbol.  [ encodedData notNil and: [ encodedData size > 0 ] ] assert.  size := encodedData size-=JUAMPI=-testCopy  < pragma: #pragma>  | method copy |  method := thisContext method.  self assert: method pragmas notEmpty.  copy := method copy.  self assert: (method equivalentTo: copy).  self assert: method header equals: copy header.  self assert: method equals: copy.  self assert: method ~~ copy.  self assert: copy penultimateLiteral method identicalTo: copy.  self assert: method penultimateLiteral method identicalTo: method.  method pragmas do: [:p |  self assert: p method identicalTo: method ].  copy pragmas do: [:p |  self assert: p method identicalTo: copy ]-=JUAMPI=-fuelAccept: aGeneralMapper  ^self shouldBeSubstitutedByCleanCopy ifTrue: [ aGeneralMapper visitSubstitution: self by: self cleanCopy onRecursionDo: [ aGeneralMapper visitVariableObject: self ] ] ifFalse: [ aGeneralMapper visitVariableObject: self ]-=JUAMPI=-waitWhile: aBlock maxSeconds: aNumber  ^self waitWhile: aBlock maxMilliseconds: (aNumber * 1000) asInteger-=JUAMPI=-simplePassTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: 'Unhandled Exception';     yourself-=JUAMPI=-isErrorTest  ^self methodClass isTestCase and: [ self methodClass methodRaisedError: self selector ]-=JUAMPI=-sourceCode  | trailer |  trailer := self trailer.  trailer sourceCode ifNotNil: [:code |  ^code ].  trailer hasSourcePointer ifFalse: [ ^self codeForNoSource ].  ^self getSourceFromFile ifEmpty: [ self codeForNoSource ]-=JUAMPI=-nonAbstractMethod  ^4 + 5-=JUAMPI=-isAbstract  ^false-=JUAMPI=-method: aMethodNodeOrNil  method := aMethodNodeOrNil-=JUAMPI=-objectAt: index  < primitive: 68>  self primitiveFailed-=JUAMPI=-waitWhile: aBlock  ^self waitWhile: aBlock for: nil-=JUAMPI=-traversableInstVarIndexes  ^super traversableInstVarIndexes copyWithout: (self class allInstVarNames indexOf: 'sender')-=JUAMPI=-randomCharacterBetween: lower and: upper  ^Character codePoint: (self randomCodePointBetween: lower and: upper)-=JUAMPI=-printOn: stream  args isEmpty ifTrue: [ ^stream nextPutAll: selector ].  args with: selector keywords do: [:arg :word |  stream nextPutAll: word.        stream space.        arg printOn: stream.        stream space ].  stream skip: -1-=JUAMPI=-testWholeNanoseconds  self assert: 0 seconds wholeNanoseconds equals: 0.  self assert: 1 second wholeNanoseconds equals: 0.  self assert: 1002003004 nanoSeconds wholeNanoseconds equals: 4-=JUAMPI=-testYear  self assert: aTimespan year equals: 2005-=JUAMPI=-testFirstDayOfMonth  self assert: aDateAndTime firstDayOfMonth equals: 1-=JUAMPI=-testReadSlotNamed  self assert: (5 @ 3 readSlotNamed: #x) equals: 5-=JUAMPI=-isControlOther  ^self characterSet isControlOther: self-=JUAMPI=-isMorphicEvent  ^false-=JUAMPI=-deprecated: anExplanationString transformWith: aRule  Deprecation new     context: thisContext sender;     explanation: anExplanationString;     rule: aRule;     transform-=JUAMPI=-isFFIMethod  ^self hasProperty: #isFFIMethod-=JUAMPI=-variableSubclass: aClassName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self variableSubclass: aClassName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat-=JUAMPI=-runTest: aSelector  | actualResult expectedResult |  [ self     logTest: aSelector;     clearLog;     perform: aSelector ] on: MyTestError do: [:ex |  self log: 'Unhandled Exception'.        ex return: nil ].  actualResult := self log.  expectedResult := self perform: (aSelector , #Results) asSymbol.  actualResult = expectedResult ifTrue: [ self logTestResult: 'succeeded' ] ifFalse: [ self logTestResult: 'failed' ]-=JUAMPI=-adaptToInteger: rcvr andSend: selector  ^(Fraction numerator: rcvr denominator: 1) perform: selector with: self-=JUAMPI=-previous  ^self class starting: start - duration duration: duration-=JUAMPI=-asMicroseconds  ^(seconds * NanosInSecond + nanos) // (10 raisedToInteger: 3)-=JUAMPI=-object: anObject  object := anObject-=JUAMPI=-printOn: aStream  aStream nextPutAll: 'false'-=JUAMPI=-removeMethodSelector: aSymbol  ^methodSelectors remove: aSymbol-=JUAMPI=-testAsInteger  self assert: 0.5 asInteger equals: 0.  self assert: (1 / 2) asInteger equals: 0-=JUAMPI=-testSlots  self assert: Context slots size equals: 4-=JUAMPI=-pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex  self push: ((self at: tempVectorIndex + 1) at: remoteTempIndex + 1)-=JUAMPI=-group  ^'Bugs'-=JUAMPI=-isCompiledMethod  ^false-=JUAMPI=-do: aBlock  | dep |  1 to: self basicSize do: [:i |  (dep := self basicAt: i) ifNotNil: [ aBlock value: dep ] ]-=JUAMPI=-testAsYear  self assert: aTime asYear equals: (DateAndTime current midnight + aTime) asYear-=JUAMPI=-userBackgroundPriority  ^UserBackgroundPriority-=JUAMPI=-testNanoSecond  self     assert: (Duration nanoSeconds: 5) equals: 5 nanoSecond;     assert: 0.5 nanoSecond equals: (Duration nanoSeconds: 0.5);     assert: (1 / 2) nanoSecond equals: (Duration nanoSeconds: 0.5)-=JUAMPI=-value: anObject  Processor activeProcess psValueAt: index put: anObject-=JUAMPI=-instSpec  ^(self format bitShift: -16) bitAnd: 16r1F-=JUAMPI=-exp  ^self asFloat exp-=JUAMPI=-fixDependents  DependentsFields associationsDo: [:pair |  pair value do: [:dep |  (references at: dep ifAbsent: [ nil ]) ifNotNil: [:newDep |  | newModel |                    newModel := references at: pair key ifAbsent: [ pair key ].                    newModel addDependent: newDep ] ] ]-=JUAMPI=-metacelloSemanticIntegerLessThanSelf: anInteger  ^anInteger < self-=JUAMPI=-testNameOfMonth  self assert: (Date nameOfMonth: 1) equals: #January.  self assert: (Date nameOfMonth: 12) equals: #December.  self should: [ Date nameOfMonth: 0 ] raise: SubscriptOutOfBounds.  self should: [ Date nameOfMonth: 13 ] raise: SubscriptOutOfBounds-=JUAMPI=-testSimpleOneDelay  | delay |  delay := Delay new setDelay: 2 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: delay beingWaitedOn.  scheduler schedule: delay.  self assert: delay beingWaitedOn.  scheduler simulate_vmMilliseconds: 11.  self deny: delay isExpired.  scheduler simulate_vmMilliseconds: 12.  self assert: delay isExpired-=JUAMPI=-simpleResignalAsTestResults  ^OrderedCollection new     add: self doSomethingString;     add: 'Unhandled Exception';     yourself-=JUAMPI=-mustBeBooleanIn: context  | proceedValue |  context skipBackBeforeJump.  proceedValue := NonBooleanReceiver new     object: self;     signal: 'proceed for truth.'.  ^proceedValue ~~ false-=JUAMPI=-testSharedClosureEnvironment  | blockArray |  blockArray := self constructSharedClosureEnvironmentInDeadFrame.  self assert: (blockArray at: 2) value equals: 10.  self assert: ((blockArray at: 1) value: 5) equals: 5.  self assert: (blockArray at: 2) value equals: 5-=JUAMPI=-classComment: aString  self comment: aString-=JUAMPI=-references  ^references-=JUAMPI=-inheritsFrom: aClass  | aSuperclass |  aSuperclass := self superclass.  [ aSuperclass == nil ] whileFalse: [ aSuperclass == aClass ifTrue: [ ^true ].        aSuperclass := aSuperclass superclass ].  ^false-=JUAMPI=-stonContainSubObjects  ^false-=JUAMPI=-hasAbstractMethods  self methodsDo: [:each |  each isAbstract ifTrue: [ ^true ] ].  ^false-=JUAMPI=-classToBeTested  ^Float-=JUAMPI=-testBecomeForwardHash  | a b c hb |  a := 'ab' copy.  b := 'cd' copy.  c := a.  hb := b hash.  a becomeForward: b.  self     assert: a hash equals: hb;     assert: b hash equals: hb;     assert: c hash equals: hb-=JUAMPI=-veryDeepCopyWith: deepCopier  | class selfNumberOfInstanceVariables fieldOfSelf copyOfSelf currentClass hasVeryDeepInnerMethod currentNumberOfInstanceVariables |  deepCopier references at: self ifPresent: [:newer |  ^newer ].  class := self class.  class isMeta ifTrue: [ ^self ].  copyOfSelf := self shallowCopy.  deepCopier references at: self put: copyOfSelf.  (class isVariable and: [ class isPointers ]) ifTrue: [ self basicSize to: 1 by: -1 do: [:i |  fieldOfSelf := self basicAt: i.              copyOfSelf basicAt: i put: (deepCopier references at: fieldOfSelf ifAbsent: [ fieldOfSelf veryDeepCopyWith: deepCopier ]) ] ].  copyOfSelf veryDeepInner: deepCopier.  currentClass := class.  selfNumberOfInstanceVariables := class instSize.  [ selfNumberOfInstanceVariables == 0 ] whileFalse: [ hasVeryDeepInnerMethod := currentClass includesSelector: #veryDeepInner:.        currentNumberOfInstanceVariables := currentClass instSize - currentClass superclass instSize.        hasVeryDeepInnerMethod ifTrue: [ selfNumberOfInstanceVariables := selfNumberOfInstanceVariables - currentNumberOfInstanceVariables ] ifFalse: [ currentNumberOfInstanceVariables timesRepeat: [ fieldOfSelf := self instVarAt: selfNumberOfInstanceVariables.                    copyOfSelf instVarAt: selfNumberOfInstanceVariables put: (deepCopier references at: fieldOfSelf ifAbsent: [ fieldOfSelf veryDeepCopyWith: deepCopier ]).                    selfNumberOfInstanceVariables := selfNumberOfInstanceVariables - 1 ] ].        currentClass := currentClass superclass ].  ^copyOfSelf-=JUAMPI=-ensureRingDefinitionIn: anRGEnvironment  ^anRGEnvironment ask behaviors detect: [:each |  each name = self name ] ifNone: [ | behaviorModel |        behaviorModel := self asRingMinimalDefinitionIn: anRGEnvironment.        anRGEnvironment addBehavior: behaviorModel.        behaviorModel ]-=JUAMPI=-removeActionsWithReceiver: anObject  self actionMap copy keysDo: [:eachEventSelector |  self removeActionsSatisfying: [:anAction |  anAction receiver == anObject ] forEvent: eachEventSelector ]-=JUAMPI=-implementors  ^SystemNavigation default allImplementorsOf: self selector-=JUAMPI=-testIsConnectorPunctuation  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isConnectorPunctuation: ch) equals: (charset isConnectorPunctuation: ch) ]-=JUAMPI=-parseEscapePattern  inputStream next = patternStream next ifFalse: [ invalidPattern := true ]-=JUAMPI=-fileOutOrganizationOn: aFileStream  aFileStream     cr;     nextPut: $!.  aFileStream     nextChunkPut: self name , ' reorganize';     cr.  aFileStream     nextChunkPut: self organization stringForFileOut;     cr-=JUAMPI=-testYearMonthDay  self assert: aDateAndTime equals: (DateAndTime year: 1980 month: 1 day: 1)-=JUAMPI=-genDup  stream nextPut: 83-=JUAMPI=-addMethodTag: aSymbol  self organization addCategory: aSymbol-=JUAMPI=-simpleEnsureTestWithNotification  [ self doSomething.  self methodWithNotification.  self doSomethingElse ] ensure: [ self doYetAnotherThing ]-=JUAMPI=-link: aMetaLink toTemporaryNamed: aTempVarName inMethod: aMethodName  self link: aMetaLink toTemporaryNamed: aTempVarName inMethod: aMethodName option: #all-=JUAMPI=-isFourDigitYearPattern  ^patternStream nextMatchAll: 'yyy'-=JUAMPI=-= anObject  ^self == anObject-=JUAMPI=-metacelloSemanticStringLessThanSelf: aString  ^true-=JUAMPI=-weeks  | weeks |  weeks := OrderedCollection new.  self weeksDo: [:m |  weeks add: m ].  ^weeks asArray-=JUAMPI=-isZero  ^self = 0-=JUAMPI=-testRaisedToErrorConditions  self should: [ -2 raisedTo: 1 / 4 ] raise: ArithmeticError.  self should: [ -2 raisedTo: 1.24 ] raise: ArithmeticError-=JUAMPI=-day  ^self dayOfYear-=JUAMPI=-execute: projectSpecBlock against: aScriptExecutor  aScriptExecutor executeBlock: self do: projectSpecBlock-=JUAMPI=-testDayOfYear  self assert: aDateAndTime dayOfYear equals: 60-=JUAMPI=-genPushThisContext  stream nextPut: 82-=JUAMPI=-testStoreOn  | integer |  integer := SmallInteger minVal - 1.  self     assert: integer class equals: LargeNegativeInteger;     assert: (String streamContents: [:s |  integer storeOn: s ]) equals: ' ' , integer asString-=JUAMPI=-< comparand  ^self asNanoSeconds < comparand asNanoSeconds-=JUAMPI=-& aBoolean  self subclassResponsibility-=JUAMPI=-selector: aSymbol  selector := aSymbol-=JUAMPI=-storeOn: aStream  aStream     nextPut: $(;     nextPutAll: self className;     nextPutAll: ' seconds: ';     print: seconds;     nextPutAll: ' nanoSeconds: ';     print: nanos;     nextPut: $)-=JUAMPI=-isDisabled  ^self isDisabled: self markerOrNil-=JUAMPI=-testCurrent  self deny: aDateAndTime equals: DateAndTime current-=JUAMPI=-isConflict  ^self markerOrNil == self class conflictMarker-=JUAMPI=-asFloat  self subclassResponsibility-=JUAMPI=-isOverridden  | selector |  selector := self selector.  self methodClass allSubclassesDo: [:each |  (each includesSelector: selector) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-forkedProcesses  ^forkedProcesses-=JUAMPI=-environment  ^thisClass environment-=JUAMPI=-methodReturnTop  ^self return: self pop from: self methodReturnContext-=JUAMPI=-pc: anInteger  pc := anInteger-=JUAMPI=-tickAfterMilliseconds: milliseconds  ^self nowTick + (1000 * milliseconds)-=JUAMPI=-valueUninterruptably  ^self ifCurtailed: [ ^self ]-=JUAMPI=-testCanEscapeSpecialCharacters  self assertReading: '4d\2m\2345y' as: 'd\d\\m\m\\y\y' equals: (Date year: 2345 month: 2 day: 4)-=JUAMPI=-isQuick  ^self primitive between: 256 and: 519-=JUAMPI=-initializeValue: anInteger  value := anInteger.  ^self-=JUAMPI=-randomCodePointBetween: lower and: upper  | max span codePoint |  max := upper min: 16rE01EF.  span := max - lower + 1.  [ codePoint := (self generator next * span) floor + lower.  Unicode isNonCharacter: (Character codePoint: codePoint) ] whileTrue.  ^codePoint-=JUAMPI=-isDivisibleBy: aNumber  aNumber = 0 ifTrue: [ ^false ].  aNumber isInteger ifFalse: [ ^false ].  ^self \\ aNumber = 0-=JUAMPI=-testBitOr  self assert: 2r0101 | 2r1010 equals: 2r1111.  self assert: (2r0101 bitOr: 2r1010) equals: 2r1111-=JUAMPI=-javascriptOn: aStream  self printOn: aStream-=JUAMPI=-a1: a1 a2: a2 a3: a3 a4: a4 a5: a5 a6: a6 a7: a7 a8: a8 a9: a9 a10: a10 a11: a11 a12: a12 a13: a13 a14: a14 a15: a15  ^a1 + a2 - a2-=JUAMPI=-retry  handlerContext restart-=JUAMPI=-bench  | benchmarkResult |  benchmarkResult := self benchFor: 5 seconds.  ^benchmarkResult shortPrintString-=JUAMPI=-example1: anInteger  < sampleInstance>  | factorial |  factorial := [:x |  x = 1 ifTrue: [ 1 ] ifFalse: [ (factorial value: x - 1) * x ] ].  ^factorial value: anInteger-=JUAMPI=-receiver: anObject  receiver := anObject-=JUAMPI=-comment: aString  commentRemoteString := aString isRemoteString ifTrue: [ aString ] ifFalse: [ aString isEmptyOrNil ifTrue: [ nil ] ifFalse: [ SourceFiles remoteStringForNewString: aString ] ]-=JUAMPI=-valueWithinNonLocalReturn  [ ^self ] valueWithin: 20 milliSeconds onTimeout: [  ]-=JUAMPI=-+ aNumber  aNumber isInteger ifTrue: [ self negative == aNumber negative ifTrue: [ ^(self digitAdd: aNumber) normalize ] ifFalse: [ ^self digitSubtract: aNumber ] ].  aNumber isFraction ifTrue: [ ^Fraction numerator: self * aNumber denominator + aNumber numerator denominator: aNumber denominator ].  ^aNumber adaptToInteger: self andSend: #+-=JUAMPI=-suspend  | ts |  self isActive ifTrue: [ ts := self timespans last.        ts duration: DateAndTime now - ts start.        self state: #suspended ]-=JUAMPI=-sizeWithoutTrailer  ^self trailer endPC-=JUAMPI=-minute  ^self minutes-=JUAMPI=-isArrow  ^{Character arrowUp .   Character arrowDown .   Character arrowLeft .   Character arrowRight} includes: self-=JUAMPI=-spotterItemsFor: aStep  -=JUAMPI=-step  ^self interpretNextInstructionFor: self-=JUAMPI=-instanceSide  ^self soleInstance-=JUAMPI=-testPrevious  | previousDay |  previousDay := june2nd1973 previous.  self assert: previousDay equals: '1 June, 1973' asDate-=JUAMPI=-indexOf: anElement startingAt: start ifAbsent: exceptionBlock  | currentLink index |  currentLink := self linkAt: start ifAbsent: [ nil ].  index := start.  [ currentLink isNil ] whileFalse: [ currentLink value = anElement value ifTrue: [ ^index ].        currentLink := currentLink nextLink.        index := index + 1 ].  ^exceptionBlock value-=JUAMPI=-testCeiling  self assert: 1.0 ceiling equals: 1.  self assert: 1.1 ceiling equals: 2.  self assert: -2.0 ceiling equals: -2.  self assert: -2.1 ceiling equals: -2-=JUAMPI=-asFraction  ^self asTrueFraction-=JUAMPI=-inspectAllInstances  | all allSize prefix |  all := self allInstances.  (allSize := all size) isZero ifTrue: [ ^self inform: 'There are no instances of ' , self name ].  prefix := allSize = 1 ifTrue: [ 'The lone instance' ] ifFalse: [ 'The ' , allSize printString , ' instances' ].  all asArray inspectWithLabel: prefix , ' of ' , self name-=JUAMPI=-testReadFrom  self assert: '-1199-01-05T20:33:14.321-05:00' asDateAndTime printString equals: '-1199-01-05T20:33:14.321-05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: ' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: ' 2002-05-16T17:20' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:00+00:00'.  self assert: '2002-05-16T17:20:45' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:45+00:00'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime equals: '2002-05-16T17:20:45-02:34' asDateAndTime.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime equals: '2002-05-16T17:20:45+00:00' asDateAndTime.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime equals: '1997-04-26T01:02:03+01:02:3' asDateAndTime-=JUAMPI=-rectanglesAt: y height: ht  y + ht > self bottom ifTrue: [ ^Array new ].  ^Array with: (origin x @ y corner: corner x @ (y + ht))-=JUAMPI=-testDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 1-=JUAMPI=-percent  ^self / 100-=JUAMPI=-testSimpleStoreCallCC  | x continuation |  continuation := self callcc: #yourself.  x := false.  continuation = true ifTrue: [ x := true ] ifFalse: [ continuation value: true.        self error: 'This message shouldn''t be sent, ever.' ].  self assert: x-=JUAMPI=-testDaysInMonth  self assert: aDateAndTime daysInMonth equals: 31-=JUAMPI=-testNaNCompare  | compareSelectors theNaN anotherNaN comparand brokenMethods warningMessage |  self skip.  compareSelectors := #(#< #<= #> #>= #=).  theNaN := Float nan.  anotherNaN := Float infinity - Float infinity.  comparand := {1 .   2.3 .   Float infinity .   (2 / 3) .   1.25s2 .   (2 raisedTo: 50)}.  comparand := comparand , (comparand collect: [:e |  e negated ]).  comparand := comparand , {theNaN .         anotherNaN}.  brokenMethods := Set new.  comparand do: [:comp |  compareSelectors do: [:op |  (theNaN perform: op with: comp) ifTrue: [ brokenMethods add: (theNaN class lookupSelector: op) ].              (comp perform: op with: theNaN) ifTrue: [ brokenMethods add: (comp class lookupSelector: op) ] ].        theNaN ~= comp ifFalse: [ brokenMethods add: (theNaN class lookupSelector: #~=) ].        comp ~= theNaN ifFalse: [ brokenMethods add: (comp class lookupSelector: #~=) ] ].  warningMessage := String streamContents: [:s |  s           nextPutAll: 'According to IEEE 754 comparing with a NaN should always return false, except ~= that should return true.';           cr.        s nextPutAll: 'All these methods failed to do so. They are either broken or call a broken one'.        brokenMethods do: [:e |  s                 cr;                 print: e methodClass;                 nextPutAll: '>>';                 print: e selector ] ].  brokenMethods := Set new.  comparand do: [:comp2 |  compareSelectors do: [:op2 |  self deny: (theNaN perform: op2 with: comp2) description: warningMessage.              self deny: (comp2 perform: op2 with: theNaN) description: warningMessage ].        self assert: theNaN ~= comp2 description: warningMessage.        self assert: comp2 ~= theNaN description: warningMessage ]-=JUAMPI=-deepCopy  | newObject class index |  class := self class.  class == Object ifTrue: [ ^self ].  class isVariable ifTrue: [ index := self basicSize.        newObject := class basicNew: index.        [ index > 0 ] whileTrue: [ newObject basicAt: index put: (self basicAt: index) deepCopy.              index := index - 1 ] ] ifFalse: [ newObject := class basicNew ].  index := class instSize.  [ index > 0 ] whileTrue: [ newObject instVarAt: index put: (self instVarAt: index) deepCopy.        index := index - 1 ].  ^newObject-=JUAMPI=-sqrt  self negative ifTrue: [ ^DomainError signal: 'sqrt undefined for number less than zero.' ].  ^super sqrt-=JUAMPI=-strictlyPositive  ^self > 0-=JUAMPI=-logExecution  self traceCr: 'Executing ' , thisContext sender printString-=JUAMPI=-deprecationDate  ^deprecationDate ifNil: [ 'unknown' ]-=JUAMPI=-compile: text classified: category withStamp: changeStamp notifying: requestor  ^self compile: text classified: category withStamp: changeStamp notifying: requestor logSource: self acceptsLoggingOfCompilation-=JUAMPI=-defaultAction  ^nil-=JUAMPI=-stackPtr  ^stackp-=JUAMPI=-testSecondsSinceMidnightLocalTimeNormalization  | dateAndTime |  dateAndTime := DateAndTime year: 1001 day: 101 hour: 0 minute: 1 second: 56 offset: 0 hours.  dateAndTime := dateAndTime offset: 1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 1 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 23 * 3600 + (1 * 60) + 56.  dateAndTime := DateAndTime year: 1001 day: 101 hour: 23 minute: 1 second: 56 offset: 0 hours.  dateAndTime := dateAndTime offset: 1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 0 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  dateAndTime := DateAndTime year: 1001 day: 101 hour: 0 minute: 1 second: 56 offset: 1 hours.  dateAndTime := dateAndTime offset: 2 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 1 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: 0 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 23 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  dateAndTime := DateAndTime year: 1001 day: 101 hour: 23 minute: 1 second: 56 offset: 1 hours.  dateAndTime := dateAndTime offset: 2 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 0 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: 0 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 21 * 3600 + (1 * 60) + 56-=JUAMPI=-timingPriorityScheduleTicker: aDelayTicker  beingWaitedOn ifTrue: [ ^false ].  beingWaitedOn := true.  ticker := aDelayTicker.  resumptionTick := ticker tickAfterMilliseconds: millisecondDelayDuration.  ^true-=JUAMPI=-testYearPrintOn  | aYear |  aYear := Year starting: DateAndTime new duration: 365 days.  self assert: (String streamContents: [:str |  aYear printOn: str ]) equals: 'a Year (1901)'-=JUAMPI=-allProtocol  ^allProtocol-=JUAMPI=-primeFactorsOn: aStream  self = 1 ifTrue: [ ^self ].  self even ifTrue: [ aStream nextPut: 2.        ^self / 2 primeFactorsOn: aStream ].  3 to: self sqrtFloor by: 2 do: [:each |  self \\ each = 0 ifTrue: [ aStream nextPut: each.              ^self / each primeFactorsOn: aStream ] ].  aStream nextPut: self-=JUAMPI=-basicOrganization: aClassOrg  organization := aClassOrg-=JUAMPI=-notifyOfChangedSelector: element from: oldCategory to: newCategory  (self hasSubject and: [ oldCategory ~= newCategory ]) ifTrue: [ self subject notifyOfRecategorizedSelector: element from: oldCategory to: newCategory ]-=JUAMPI=-testTranscriptPrintingWithOpenedTranscriptExists  self runSimulated: [ self methodWithTranscript ]-=JUAMPI=-testBinaryLiteralString  self assert: 0.0 binaryLiteralString equals: '0.0'.  self assert: 0.0 negated binaryLiteralString equals: '-0.0'.  self assert: Float infinity binaryLiteralString equals: 'Float infinity'.  self assert: Float infinity negated binaryLiteralString equals: 'Float infinity negated'.  self assert: Float nan binaryLiteralString equals: 'Float nan'.  self assert: Float fminDenormalized binaryLiteralString equals: '2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: Float fminNormalized binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: (Float fminNormalized - Float fminDenormalized) binaryLiteralString equals: '2r0.1111111111111111111111111111111111111111111111111111e-1022'.  self assert: Float epsilon binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-52'.  self assert: Float fmax binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: Float fminDenormalized negated binaryLiteralString equals: '-2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: Float fminNormalized negated binaryLiteralString equals: '-2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: 1.0 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e0'.  self assert: (1.0 + Float epsilon) binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000001e0'.  self assert: (1.0 - (Float epsilon / 2)) binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e-1'.  self assert: 2.0 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e1'.  self assert: 0.1 binaryLiteralString equals: '2r1.1001100110011001100110011001100110011001100110011010e-4'.  self assert: 0.2 binaryLiteralString equals: '2r1.1001100110011001100110011001100110011001100110011010e-3'.  self assert: 0.3 binaryLiteralString equals: '2r1.0011001100110011001100110011001100110011001100110011e-2'.  self assert: (0.1 + 0.2) binaryLiteralString equals: '2r1.0011001100110011001100110011001100110011001100110100e-2'.  self assert: 0.5 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-1'.  self assert: 2r0.0000000000000000000000000000000000000000000000000001e-1022 binaryLiteralString equals: '2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: 2r0.0101010101010101010101010101010101010101010101010101e-1022 binaryLiteralString equals: '2r0.0101010101010101010101010101010101010101010101010101e-1022'.  self assert: 2r0.1010101010101010101010101010101010101010101010101010e-1022 binaryLiteralString equals: '2r0.1010101010101010101010101010101010101010101010101010e-1022'.  self assert: 2r0.1111111111111111111111111111111111111111111111111111e-1022 binaryLiteralString equals: '2r0.1111111111111111111111111111111111111111111111111111e-1022'.  self assert: 2r1.0101010101010101010101010101010101010101010101010101e-3 binaryLiteralString equals: '2r1.0101010101010101010101010101010101010101010101010101e-3'.  self assert: 2r1.1010101010101010101010101010101010101010101010101010e3 binaryLiteralString equals: '2r1.1010101010101010101010101010101010101010101010101010e3'.  self assert: 2r1.1111111111111111111111111111111111111111111111111111e1023 binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: -2r0.0000000000000000000000000000000000000000000000000001e-1022 binaryLiteralString equals: '-2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: -2r1.0000000000000000000000000000000000000000000000000000e-1022 binaryLiteralString equals: '-2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: -2r1.1111111111111111111111111111111111111111111111111111e1023 binaryLiteralString equals: '-2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: (Float fromIEEE64Bit: 2r0111111111110000000000000000000000000000000000000000000000000001) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r0111111111111111111111111111111111111111111111111111111111111111) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r1111111111110000000000000000000000000000000000000000000000000001) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r1111111111111111111111111111111111111111111111111111111111111111) binaryLiteralString equals: 'Float nan'-=JUAMPI=-testNoRecursion  LocalRecursionStopper during: [ value := value + 1 ].  self assert: value equals: 1-=JUAMPI=-signaler: anObject  signaler := anObject-=JUAMPI=-testNumberOfDigits  2 to: 32 do: [:b |  1 to: 1000 // b do: [:n |  | bRaisedToN |              bRaisedToN := b raisedTo: n.              self assert: (bRaisedToN - 1 numberOfDigitsInBase: b) equals: n.              self assert: (bRaisedToN numberOfDigitsInBase: b) equals: n + 1.              self assert: (bRaisedToN + 1 numberOfDigitsInBase: b) equals: n + 1.              self assert: (bRaisedToN negated + 1 numberOfDigitsInBase: b) equals: n.              self assert: (bRaisedToN negated numberOfDigitsInBase: b) equals: n + 1.              self assert: (bRaisedToN negated - 1 numberOfDigitsInBase: b) equals: n + 1 ] ]-=JUAMPI=-methodSelectors: anObject  methodSelectors := anObject-=JUAMPI=-selector  ^selector-=JUAMPI=-isBlock  ^false-=JUAMPI=-genPushSpecialLiteral: aLiteral  | index |  index := #(true false nil -1 0 1 2) indexOf: aLiteral ifAbsent: 0.  index = 0 ifTrue: [ ^self error: 'push special literal: ' , aLiteral printString , ' is not one of true false nil -1 0 1 2' ].  stream nextPut: index + 112-=JUAMPI=-testallSuperclassesIncluding  | cls |  cls := ArrayedCollection allSuperclassesIncluding: Collection.  self deny: (cls includes: ArrayedCollection).  self deny: (cls includes: Object).  self assert: (cls includes: Collection).  self assert: (cls includes: SequenceableCollection)-=JUAMPI=-isUppercase  ^self characterSet isUppercase: self-=JUAMPI=-genPushConsArray: size  (size < 0 or: [ size > 127 ]) ifTrue: [ ^self outOfRangeError: 'numElements' index: size range: 0 to: 127 ].  stream     nextPut: 138;     nextPut: size + 128-=JUAMPI=-runTestCase: aTestCase  self subclassResponsibility-=JUAMPI=-sizePushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize  ^self sizeOpcodeSelector: #genPushClosureCopyNumCopiedValues:numArgs:jumpSize: withArguments: {numCopied .         numArgs .         jumpSize}-=JUAMPI=-asSetElement  self deprecated: 'Use #asCollectionElement instead' transformWith: '`@receiver asSetElement' -> '`@receiver asCollectionElement'.  ^self asCollectionElement-=JUAMPI=-testAsWeek  self assert: aDateAndTime asWeek equals: (Week starting: '12-31-1900' asDate)-=JUAMPI=-bitAt: anInteger  | digitIndex bitIndex |  digitIndex := (anInteger - 1) // 8 + 1.  digitIndex > self bytesCount ifTrue: [ ^0 ].  bitIndex := (anInteger - 1) \\ 8 + 1.  ^(self byteAt: digitIndex) bitAt: bitIndex-=JUAMPI=-getNext: previousObj  ^Continuation currentDo: [:here_again |  leave := here_again.        fill value: previousObj ]-=JUAMPI=-canPerform: selector  ^self classAndMethodFor: selector do: [:c :m |  m isProvided ] ifAbsent: [ false ]-=JUAMPI=-copy: sel from: class  self copy: sel from: class classified: nil-=JUAMPI=-testMmddyyyy  self assert: january23rd2004 mmddyyyy equals: '1/23/2004'-=JUAMPI=-aRandomSelectionOfCodePointsDo: aBlock  0 to: 255 do: [:cp |  aBlock value: cp ].  500 timesRepeat: [ aBlock value: (unicodeGenerator randomCodePointAtOrAbove: 256) ]-=JUAMPI=-testUsesPoolVarNamed  self assert: (Date usesPoolVarNamed: 'DayNames').  self deny: (Date class usesPoolVarNamed: 'DayNames').  self assert: (RootClassPoolUser usesPoolVarNamed: 'Author').  self assert: (SubclassPoolUser usesPoolVarNamed: 'Author')-=JUAMPI=-testDivide  self assert: aDuration / aDuration equals: 1.  self assert: aDuration / 2 equals: (Duration days: 0 hours: 13 minutes: 1 seconds: 32 nanoSeconds: 2).  self assert: aDuration / (1 / 2) equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10)-=JUAMPI=-testYield  | lowerHasRun lowerPriority same1HasRun same2HasRun |  lowerHasRun := same1HasRun := same2HasRun := false.  lowerPriority := Processor activeProcess priority - 10 min: 10.  [ lowerHasRun := true ] forkAt: lowerPriority.  [ same1HasRun := true ] fork.  [ same2HasRun := true ] fork.  Processor yield.  self assert: same1HasRun.  self assert: same2HasRun.  self deny: lowerHasRun-=JUAMPI=-sizeSend: selectorLiteralIndex numArgs: nArgs  ^self sizeOpcodeSelector: #genSend:numArgs: withArguments: {selectorLiteralIndex .         nArgs}-=JUAMPI=-testSuspendForSnapshot  | delay |  delay := Delay new setDelay: 2 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: delay beingWaitedOn.  scheduler schedule: delay.  self assert: delay beingWaitedOn.  self assert: delay millisecondsToGo equals: 2.  scheduler shutDown.  self assert: delay millisecondsToGo equals: 0.  scheduler simulate_vmMilliseconds: 20.  self assert: delay millisecondsToGo equals: 0.  self deny: delay isExpired.  scheduler startUp.  self assert: delay millisecondsToGo equals: 2.  self deny: delay isExpired.  scheduler simulate_vmMilliseconds: 23.  self assert: delay isExpired-=JUAMPI=-asTime  ^Time seconds: self secondsSinceMidnightLocalTime nanoSeconds: nanos-=JUAMPI=-javascriptMonthIndex  ^self monthIndex - 1-=JUAMPI=-allSubclassesDo: aBlock  self subclassesDo: [:cl |  aBlock value: cl.        cl allSubclassesDo: aBlock ]-=JUAMPI=-testRefersToLiteralsReturnsTrueWhenLiteralIsGlobalVariable  self assert: (self compiledMethod1 hasLiteralThorough: (self class environment associationAt: #Array))-=JUAMPI=-ifNil: aBlock  ^aBlock value-=JUAMPI=-testYearMonthDayHourMinuteSecondNanosSecondOffset  self assert: aDateAndTime equals: (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours).  self assert: (DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours) + (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) equals: (DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)-=JUAMPI=-suspendingList  ^myList-=JUAMPI=-obsolete  self superclass removeSubclass: self.  super obsolete-=JUAMPI=-group  ^'Architectural'-=JUAMPI=-printPaddedWith: aCharacter to: anInteger  ^self printPaddedWith: aCharacter to: anInteger base: 10-=JUAMPI=-testInexactRaisedTo  self assert: (((1 << 1024) + 1) / ((1 << 1024) + 3) raisedTo: 1 / 3) equals: 1.0.  self assert: ((((1 << 1024) + 1) / ((1 << 1024) + 3)) negated raisedTo: 1 / 3) equals: -1.0-=JUAMPI=-collect: collectBlock thenSelect: selectBlock  | newCollection newElement |  newCollection := self class new.  self do: [:each |  newElement := collectBlock value: each.        (selectBlock value: newElement) ifTrue: [ newCollection add: newElement ] ].  ^newCollection-=JUAMPI=-primitive  ^self subclassResponsibility-=JUAMPI=-sizeBranchPopFalse: distance  ^self sizeOpcodeSelector: #genBranchPopFalse: withArguments: {distance}-=JUAMPI=-stonOn: stonWriter  stonWriter writeScaledDecimal: self-=JUAMPI=-lowercase  ^self asLowercase-=JUAMPI=-at: index  ^(self linkAt: index) value-=JUAMPI=-testMinute  self assert: aTime minute equals: 34.  self assert: aTime minutes equals: 34-=JUAMPI=-testMonth  self assert: aDateAndTime month equals: 1.  self assert: aDateAndTime monthAbbreviation equals: 'Jan'.  self assert: aDateAndTime monthName equals: 'January'.  self assert: aDateAndTime monthIndex equals: 1-=JUAMPI=-testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 0.  self assert: aDateAndTime hour equals: aDateAndTime hours-=JUAMPI=-testRounded  self assert: (4 / 5) rounded equals: 1.  self assert: (6 / 5) rounded equals: 1.  self assert: (-4 / 5) rounded equals: -1.  self assert: (-6 / 5) rounded equals: -1.  self assert: (3 / 2) rounded equals: 2.  self assert: (-3 / 2) rounded equals: -2-=JUAMPI=-tearDown  DateAndTime localTimeZone: restoredTimeZone.  super tearDown-=JUAMPI=-testReadTimeZoneOffsetISO  self assert: (DateAndTime readTimezoneOffsetFrom: '+05:30' readStream) printString equals: '0:05:30:00'-=JUAMPI=-uncategorizedSelectors  ^self selectorsInProtocol: Protocol unclassified-=JUAMPI=-asPowerOfTwo  ^self asSmallerPowerOfTwo-=JUAMPI=-testUtcOffset  self assert: (aDateAndTime offset: '0:02:00:00') equals: '2004-02-29T13:33:00+02:00' asDateAndTime-=JUAMPI=-tearDown  month := nil.  super tearDown-=JUAMPI=-removeEmptyCategories  | categoryIndex currentStop keptCategories keptStops |  keptCategories := (Array new: 16) writeStream.  keptStops := (Array new: 16) writeStream.  currentStop := categoryIndex := 0.  [ (categoryIndex := categoryIndex + 1) <= categoryArray size ] whileTrue: [ (categoryStops at: categoryIndex) > currentStop ifTrue: [ keptCategories nextPut: (categoryArray at: categoryIndex).              keptStops nextPut: (currentStop := categoryStops at: categoryIndex) ] ].  categoryArray := keptCategories contents.  categoryStops := keptStops contents.  categoryArray isEmpty ifTrue: [ categoryArray := Array with: Default.        categoryStops := Array with: 0 ]-=JUAMPI=-testComments  self assert: (CompiledMethodTest >> #testComments) comments first equals: 'I am the first comment to be found in this test'.  self assert: (CompiledMethodTest >> #testComments) comments second equals: 'And I am the second comment to be found in this test'.  self assert: (CompiledMethod >> #compiledMethod) comments isEmpty-=JUAMPI=-testGpsExample2  | result array |  array := #(#(1 2 3 4 5) #(6 7 8 9 10) #(11 12 13 14 15) #(16 17 18 19 20) #(21 22 23 24 25)).  result := array inject: 0 into: [:sum :subarray |  sum + (subarray inject: 0 into: [:s :elem |  s + elem ]) ].  self assert: (self gpsExample2: array) equals: result-=JUAMPI=-alwaysWritableObjects  ^{ContextInstance .   Processor .   Processor activeProcess}-=JUAMPI=-monthIndex  ^super month-=JUAMPI=-runCase  SystemAnnouncer uniqueInstance suspendAllWhile: [ super runCase ]-=JUAMPI=-testJulianDayNumber  self assert: aTimespan julianDayNumber equals: jan01 julianDayNumber-=JUAMPI=-asSpLayoutFrame  ^SpLayoutFrame new     leftFraction: self left;     rightFraction: self right;     topFraction: self top;     bottomFraction: self bottom;     yourself-=JUAMPI=-testSuppressInform  self should: [ [ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingAllMessages isNil ]-=JUAMPI=-asMinutes  ^self asNanoSeconds / 60000000000.0-=JUAMPI=-value  | strongReceiver |  strongReceiver := self receiver.  ^arguments ifNil: [ (self ensureReceiver: strongReceiver) ifTrue: [ strongReceiver perform: selector ] ifFalse: [  ] ] ifNotNil: [ (self ensureReceiverAndArguments: strongReceiver) ifTrue: [ strongReceiver perform: selector withArguments: (Array withAll: arguments) ] ifFalse: [  ] ]-=JUAMPI=-scheduleAtTimingPriority  (delayToStart timingPriorityScheduleTicker: ticker) ifFalse: [ ^self ].  activeDelay ifNil: [ activeDelay := delayToStart ] ifNotNil: [ delayToStart resumptionTick < activeDelay resumptionTick ifTrue: [ suspendedDelays add: activeDelay.              activeDelay := delayToStart ] ifFalse: [ suspendedDelays add: delayToStart ] ].  delayToStart := nil-=JUAMPI=-testNext  self assert: aTimespan next equals: aDisjointTimespan-=JUAMPI=-setDelay: anInteger forSemaphore: aSemaphore monitor: aMonitor queue: anOrderedCollection  monitor := aMonitor.  queue := anOrderedCollection.  self setDelay: anInteger forSemaphore: aSemaphore-=JUAMPI=-tag: t  tag := t-=JUAMPI=-normalized  | r |  r := (x * x + (y * y)) sqrt.  ^(x / r) @ (y / r)-=JUAMPI=-testRounding  self assert: (5 round: 2) equals: 5-=JUAMPI=-readsSlot: aSlot  ^aSlot isReadIn: self-=JUAMPI=-\\ arg  arg isPoint ifTrue: [ ^(x \\ arg x) @ (y \\ arg y) ].  ^arg adaptToPoint: self andSend: #\\-=JUAMPI=-testSubstracting  | t |  t := '2004-01-07T11:55:00+00:00' asDateAndTime.  self assert: t - 5 equals: '2004-01-07T11:54:55+00:00' asDateAndTime-=JUAMPI=-privRestartBlockTest  | a firstTimeThrough |  firstTimeThrough := true.  a := 10.  self assert: 30 equals: [ | b |        self assert: 10 equals: a.        self assert: nil identicalTo: b.        b := a + 20.        firstTimeThrough ifTrue: [ firstTimeThrough := false.              thisContext restart ].        b ] value-=JUAMPI=-fileOutCategory: aSymbol on: aFileStream  | selectors |  aFileStream cr.  selectors := self selectorsToFileOutCategory: aSymbol.  selectors do: [:sel |  self printMethodChunk: sel on: aFileStream ].  ^self-=JUAMPI=-testCopySignTo  | negatives negz positives strictNegatives strictPositives zero |  strictPositives := {2 .   2.5 .   Float infinity}.  strictNegatives := {-3 .   -3.25 .   Float infinity negated}.  zero := 0.0.  negz := Float negativeZero.  positives := strictPositives copyWith: zero.  negatives := strictNegatives copyWith: negz.  positives do: [:aPositiveSign |  positives do: [:aPositive |  self assert: (aPositiveSign copySignTo: aPositive) equals: aPositive ].        negatives do: [:aNegative |  self assert: (aPositiveSign copySignTo: aNegative) equals: aNegative negated ].        self assert: (aPositiveSign copySignTo: zero) sign equals: 0.        self assert: (aPositiveSign copySignTo: negz) sign equals: 0 ].  negatives do: [:aNegativeSign |  positives do: [:aPositive |  self assert: (aNegativeSign copySignTo: aPositive) equals: aPositive negated ].        negatives do: [:aNegative |  self assert: (aNegativeSign copySignTo: aNegative) equals: aNegative ].        self assert: (aNegativeSign copySignTo: zero) sign equals: 0.        self assert: (aNegativeSign copySignTo: negz) sign equals: 0 ]-=JUAMPI=-testExactSqrt  | f |  self assert: (4 / 9) sqrt classAndValueEquals: 2 / 3.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:i :j |  f := i / j.        self assert: f squared sqrt classAndValueEquals: f.        f := j / i.        self assert: f squared sqrt classAndValueEquals: f ]-=JUAMPI=-compiledMethodAt: selector ifPresent: aBlock  ^self methodDict at: selector ifPresent: aBlock-=JUAMPI=-testIsPowerOfTwo  self deny: (2 raisedTo: 80) negated isPowerOfTwo.  self deny: -1 isPowerOfTwo.  self deny: 0 isPowerOfTwo.  self assert: 1 isPowerOfTwo.  self assert: 2 isPowerOfTwo.  self deny: 3 isPowerOfTwo.  self assert: 4 isPowerOfTwo.  self deny: 5 isPowerOfTwo.  self deny: ((2 raisedTo: 80) - 1) isPowerOfTwo.  self assert: (2 raisedTo: 80) isPowerOfTwo.  self deny: ((2 raisedTo: 80) + 1) isPowerOfTwo-=JUAMPI=-useTimeZone: abbreviation during: aBlock  | timeZone |  timeZone := TimeZone abbreviated: abbreviation.  self restoreLocalTimeZoneAfter: [ DateAndTime localTimeZone: timeZone.        aBlock cull: timeZone ]-=JUAMPI=-variableNodes  ^self methods flatCollect: [:each |  each variableNodes ]-=JUAMPI=-testFloatTruncated  | x y int r |  int := 10 raisedTo: 16.  x := int asFloat.  y := (5 raisedTo: 16) asFloat timesTwoPower: 16.  self assert: x equals: y.  self assert: x asInteger equals: int.  self assert: x asInteger equals: x asTrueFraction asInteger.  r := Random new.  10000 timesRepeat: [ x := r next * 1.9999e16 + 1.0e12.        self assert: x truncated equals: x asTrueFraction truncated ]-=JUAMPI=-testReceiverWithGC  | m |  m := WeakMessageSend receiver: Object new selector: #isNil.  Smalltalk garbageCollectMost.  self assert: m value isNil-=JUAMPI=-bytecodesHash  ^CRC crc16FromCollection: (ByteArray new: self size streamContents: [:stream |  self from: self initialPC to: self endPC do: [:byte |  stream nextPut: byte ] ])-=JUAMPI=-/ aNumber  aNumber isFraction ifTrue: [ ^self * aNumber reciprocal ].  ^aNumber adaptToFraction: self andSend: #/-=JUAMPI=-isExpired  ^expired-=JUAMPI=-fixCollisionsFrom: start  | key index |  index := start.  [ (key := self basicAt: (index := index \\ array size + 1)) == nil ] whileFalse: [ | newIndex |        (newIndex := self findElementOrNil: key) = index ifFalse: [ self swap: index with: newIndex ] ]-=JUAMPI=-classify: aSymbol inProtocolNamed: aProtocolName  | name protocol |  name := aProtocolName.  name = allProtocol name ifTrue: [ name := Protocol unclassified ].  (self protocolsOfSelector: aSymbol) do: [:p |  p removeMethodSelector: aSymbol ].  protocol := self getProtocolNamed: name ifNone: [ self addProtocolNamed: name ].  protocol addMethodSelector: aSymbol-=JUAMPI=-storeOn: aStream base: base  aStream nextPut: $(.  numerator storeOn: aStream base: base.  aStream nextPut: $/.  denominator storeOn: aStream base: base.  aStream nextPut: $)-=JUAMPI=-linesOfCode  | lines |  lines := 0.  self sourceCode lineIndicesDo: [:start :endWithoutDelimiters :end |  endWithoutDelimiters > start ifTrue: [ lines := lines + 1 ] ].  ^lines-=JUAMPI=-valueWithoutNotifications  ^SystemAnnouncer uniqueInstance suspendAllWhile: self-=JUAMPI=-restoreValues  | valueStream context |  valueStream := values readStream.  [ valueStream atEnd ] whileFalse: [ context := valueStream next.        1 to: context class instSize do: [:i |  context instVarAt: i put: valueStream next ].        1 to: context size do: [:i |  context at: i put: valueStream next ] ]-=JUAMPI=-testprintHierarchy  | expected result |  expected := 'ProtoObject #()	Object #()		ExampleForTest1 #()			ExampleForTest11 #()				ExampleForTest111 #()				ExampleForTest112 #()			ExampleForTest12 #()'.  result := ExampleForTest1 printHierarchy.  self assert: result equals: expected-=JUAMPI=-testInexactSqrt  self assert: (((1 << 1024) + 1) / ((1 << 1024) + 3)) sqrt equals: 1.0-=JUAMPI=-intersectAllWithCC: sets  ^sets ifNotEmpty: [ Continuation currentDo: [:cc |  self intersect: sets first withAll: sets allButFirst continuation: cc ] ]-=JUAMPI=-isFormatOther  ^self characterSet isFormatOther: self-=JUAMPI=-waitTimeoutMSecs: anInteger  | d |  d := DelayWaitTimeout new setDelay: (anInteger max: 0) forSemaphore: self.  ^d wait-=JUAMPI=-assertReading: aString as: aPattern raise: anErrorClass  self should: [ self reading: aPattern pattern: aString ] raise: anErrorClass-=JUAMPI=-tags  | protocol |  protocol := self protocol.  protocol ifNil: [ ^#() ].  protocol = Protocol unclassified ifTrue: [ ^#() ].  ^{protocol}-=JUAMPI=-binding  | binding |  binding := self environment associationAt: self name ifAbsent: [ LiteralVariable key: nil value: self ].  ^binding value == self ifTrue: [ binding ] ifFalse: [ LiteralVariable key: nil value: self ]-=JUAMPI=-arguments  ^arguments ifNil: [ Array new ]-=JUAMPI=-subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat  ^self classInstaller make: [:builder |  builder           superclass: self;           name: t;           layoutClass: self classLayout class;           slots: f asSlotCollection;           sharedVariablesFromString: d;           sharedPools: s;           category: cat;           environment: self environment ]-=JUAMPI=-definitionWithSlots  | stream poolString |  poolString := self sharedPoolsString.  stream := (String new: 800) writeStream.  superclass ifNotNil: [ stream nextPutAll: superclass name ] ifNil: [ stream nextPutAll: 'ProtoObject' ].  stream     nextPutAll: ' subclass: ';     store: self name.  self hasTraitComposition ifTrue: [ stream           crtab;           nextPutAll: 'uses: ';           nextPutAll: self traitCompositionString ].  (self classLayout isKindOf: FixedLayout) ifFalse: [ stream           crtab;           nextPutAll: 'layout: ';           nextPutAll: self classLayout class name ].  stream     crtab;     nextPutAll: 'slots: ';     nextPutAll: self slotDefinitionString.  stream     crtab;     nextPutAll: 'classVariables: ';     nextPutAll: self classVariableDefinitionString.  poolString = '' ifFalse: [ stream           crtab;           nextPutAll: 'poolDictionaries: ';           store: poolString ].  stream     crtab;     nextPutAll: 'package: ';     store: self category asString.  superclass ifNil: [ stream           nextPutAll: '.';           cr.        stream nextPutAll: self name.        stream           space;           nextPutAll: 'superclass: nil' ].  ^stream contents-=JUAMPI=-var10  ^var10-=JUAMPI=-adaptToCollection: rcvr andSend: selector  ^rcvr collect: [:element |  element perform: selector with: self ]-=JUAMPI=-stonContainSubObjects  ^false-=JUAMPI=-coerce: aNumber  aNumber class = self class ifTrue: [ ^self class newFromNumber: aNumber scale: (scale max: aNumber scale) ].  (aNumber isFraction or: [ aNumber isInteger ]) ifTrue: [ ^self class newFromNumber: aNumber scale: scale ].  ^aNumber-=JUAMPI=-testEven  self deny: 1073741825 even.  self assert: 1073741824 even-=JUAMPI=-testAsMonth  self assert: aDateAndTime asMonth equals: (Month year: 1970 month: 'January')-=JUAMPI=-testInfinity2  | i1 i2 |  i1 := 10000 exp.  i2 := 1000000000 exp.  i2 := 0 - i2.  self assert: i1 isInfinite & i2 isInfinite & i1 positive & i2 negative.  self deny: i1 equals: i2-=JUAMPI=-ensureReceiverAndArguments  self receiver ifNil: [ ^false ].  self receiver class isObsolete ifTrue: [ ^false ].  (self receiver isBehavior and: [ self receiver isObsolete ]) ifTrue: [ ^false ].  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg :flag |  arg ifNil: [ flag ifFalse: [ ^false ] ] ] ].  ^true-=JUAMPI=-selector: aSymbol  selector := aSymbol-=JUAMPI=-testIsLeapYear  self deny: aTimespan isLeapYear-=JUAMPI=-jsonOn: aRenderer  self numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: aRenderer ]-=JUAMPI=-testCompileAll  ClassTest compileAll-=JUAMPI=-testDurationLessThanMaxTicks  | delay |  delay := Delay new setDelay: 789 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: delay.  self assert: ticker vmSimNextWakeupMilliseconds equals: 100 + 789-=JUAMPI=-savedTemps  ^self propertyAt: #savedTemps ifAbsent: nil-=JUAMPI=-subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition category: aCategorySymbol  self deprecated: 'use ... package: instead'.  ^self subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition package: aCategorySymbol-=JUAMPI=-log  ^log ifNil: [ log := OrderedCollection new ]-=JUAMPI=-withBottom: y  ^origin x @ origin y corner: corner x @ (y max: origin y)-=JUAMPI=-weeksDo: aBlock  self do: aBlock with: self asWeek-=JUAMPI=-testprintSubclassesOnLevelFilterNil  | expected result stream |  expected := '	ExampleForTest1 #()		ExampleForTest11 #()			ExampleForTest111 #()			ExampleForTest112 #()		ExampleForTest12 #()'.  result := String new: expected size.  stream := ReadWriteStream on: result.  ExampleForTest1 printSubclassesOn: stream level: 1 filter: nil.  self assert: result equals: expected-=JUAMPI=-repeat  [ self value.  true ] whileTrue-=JUAMPI=-testAsMilliSeconds  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: (Duration seconds: 1) asMilliSeconds equals: 1000.  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: aDuration asMilliSeconds equals: 93784000.  self assert: (Duration milliSeconds: 3775) asSeconds equals: 3.  self assert: (Duration milliSeconds: 3775) nanoSeconds equals: 775000000.  self assert: (Duration milliSeconds: -3775) asSeconds equals: -3.  self assert: (Duration milliSeconds: -3775) nanoSeconds equals: -775000000-=JUAMPI=-terminateActive  activeProcess effectiveProcess terminate-=JUAMPI=-withLeft: x  ^(x min: corner x) @ origin y corner: corner x @ corner y-=JUAMPI=-simpleIsNestedTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:exception |  exception isNested ifTrue: [ self doYetAnotherThing.              exception resignalAs: MyTestNotification new ] ]-=JUAMPI=-whichCategoryIncludesSelector: aSelector  (self includesSelector: aSelector) ifTrue: [ ^self organization categoryOfElement: aSelector ] ifFalse: [ ^nil ]-=JUAMPI=-testCreationFromBytes1  | maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |  Smalltalk vm wordSize = 4 ifFalse: [ ^self skip ].  maxSmallInt := SmallInteger maxVal.  hexString := maxSmallInt printStringHex.  self assert: hexString size equals: 8.  byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.  byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.  byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.  byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.  builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.  self assert: builtInteger equals: maxSmallInt.  self assert: builtInteger class equals: SmallInteger-=JUAMPI=-leadingChar  ^(self asInteger bitAnd: 1069547520) bitShift: -22-=JUAMPI=-bytecode  | start stop bytecode |  start := self initialPC.  stop := self endPC.  bytecode := ByteArray new: stop - start + 1.  start to: stop do: [:index |  bytecode byteAt: index - start + 1 put: (self byteAt: index) ].  ^bytecode-=JUAMPI=-exception  ^self-=JUAMPI=-applyDeprecation  self deprecationRefactorings do: #execute-=JUAMPI=-asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: packageKeys in: aRGSlice  | rgClass rgMethod rgSuper rgSub subs |  rgClass := self asRingDefinition.  aRGSlice loadClass: rgClass using: packageKeys.  methodsBoolean ifTrue: [ self methodsDo: [:mth |  rgMethod := mth asActiveRingDefinition.              aRGSlice loadMethod: rgMethod inClass: rgClass using: packageKeys ].        self classSide methodsDo: [:mth |  rgMethod := mth asActiveRingDefinition.              aRGSlice loadMethod: rgMethod inClass: rgClass classSide using: packageKeys ] ].  supersBoolean ifTrue: [ self superclass ifNotNil: [ rgSuper := aRGSlice classNamed: self superclass name.              rgSuper ifNil: [ rgSuper := self superclass asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: packageKeys in: aRGSlice ].              rgClass superclass: rgSuper ] ].  subsBoolean ifTrue: [ subs := self subclasses reject: [:sub |  sub isMeta ].        rgClass name = #Trait ifTrue: [ subs := aRGSlice environment allTraits ].        subs do: [:each |  rgSub := aRGSlice classNamed: each name.              rgSub ifNil: [ rgSub := each asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: packageKeys in: aRGSlice ].              rgSub superclass: rgClass ] ].  ^rgClass-=JUAMPI=-sizeCallPrimitive: primitiveIndex  ^self sizeOpcodeSelector: #genCallPrimitive: withArguments: {primitiveIndex}-=JUAMPI=-testAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)-=JUAMPI=-testUtcOffset  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1980-01-01T12:00:00+12:00' asDateAndTime-=JUAMPI=-protocolNamed: aName  ^self protocolNamed: aName ifAbsent: [ Protocol empty ]-=JUAMPI=-floor  | truncation |  truncation := self truncated.  self >= 0 ifTrue: [ ^truncation ].  self = truncation ifTrue: [ ^truncation ] ifFalse: [ ^truncation - 1 ]-=JUAMPI=-contents  ^(self log inject: (String new: 80) writeStream into: [:result :item |  result           cr;           nextPutAll: item;           yourself ]) contents-=JUAMPI=-or: alternativeBlock  ^alternativeBlock value-=JUAMPI=-testAsDays  self assert: (Duration days: 2) asDays equals: 2.  self assert: (Duration weeks: 1) asDays equals: 7.  self assert: (aDuration asDays closeTo: 1.08546)-=JUAMPI=-testTicks  self assert: aDateAndTime ticks equals: (DateAndTime julianDayNumber: 2440588) ticks.  self assert: aDateAndTime ticks equals: #(2440588 0 0)-=JUAMPI=-digitLshift: shiftCount  | carry rShift mask len result digit byteShift bitShift highBit |  (highBit := self highBitOfMagnitude) = 0 ifTrue: [ ^0 ].  len := (highBit + shiftCount + 7) // 8.  result := Integer new: len neg: self negative.  byteShift := shiftCount // 8.  bitShift := shiftCount \\ 8.  bitShift = 0 ifTrue: [ ^result replaceFrom: byteShift + 1 to: len with: self startingAt: 1 ].  carry := 0.  rShift := bitShift - 8.  mask := 255 bitShift: 0 - bitShift.  1 to: byteShift do: [:i |  result byteAt: i put: 0 ].  1 to: len - byteShift do: [:i |  digit := self byteAt: i.        result byteAt: i + byteShift put: (((digit bitAnd: mask) bitShift: bitShift) bitOr: carry).        carry := digit bitShift: rShift ].  ^result-=JUAMPI=-selector  ^selector-=JUAMPI=-obsolete  self == Object ifTrue: [ ^self error: 'Object is NOT obsolete' ].  self setName: 'AnObsolete' , self name.  Object class instSize + 1 to: self classSide instSize do: [:i |  self instVarAt: i put: nil ].  self classPool: nil.  self sharedPools: nil.  self hasClassSide ifTrue: [ self classSide obsolete ].  self propertyAt: #obsolete put: true.  super obsolete-=JUAMPI=-degreeSin  ^(90 - self) degreeCos-=JUAMPI=-ffiCallingConvention  ^OSPlatform current ffiCallingConvention-=JUAMPI=-dayOfWeek  ^start dayOfWeek-=JUAMPI=-genBranchPopTrue: distance  distance < 0 ifTrue: [ ^self outOfRangeError: 'distance' index: distance range: 0 to: 1023 ].  distance < 1024 ifTrue: [ stream           nextPut: 168 + (distance bitShift: -8);           nextPut: (distance + 1024) \\ 256.        ^self ].  ^self outOfRangeError: 'distance' index: distance range: 0 to: 1023-=JUAMPI=-storeOn: aStream  self printOn: aStream-=JUAMPI=-testMutateIVObject  | guineaPig |  guineaPig := MessageSend new.  guineaPig beReadOnlyObject.  [ guineaPig receiver: 1 ] on: ModificationForbidden do: [:modification |   ].  guineaPig     beWritableObject;     selector: #+;     beReadOnlyObject.  [ guineaPig arguments: #(2) ] on: ModificationForbidden do: [:modification |   ].  self assert: guineaPig receiver isNil.  self assert: guineaPig arguments isNil.  self assert: guineaPig selector identicalTo: #+-=JUAMPI=-compileSilently: code  ^self compileSilently: code classified: 'not defined category' notifying: nil-=JUAMPI=-confirm: queryString  ^UIManager default confirm: queryString-=JUAMPI=-okToChange  ^true-=JUAMPI=-isSpaceSeparator  ^self characterSet isSpaceSeparator: self-=JUAMPI=-identityHash  ^self basicIdentityHash bitShift: 8-=JUAMPI=-compileSilently: code classified: category  ^self compileSilently: code classified: category notifying: nil-=JUAMPI=-blockWithNonLocalReturn: resultObject  ^[ ^resultObject ]-=JUAMPI=-lookupSelector: selector  | lookupClass |  lookupClass := self.  [ lookupClass == nil ] whileFalse: [ lookupClass methodDict at: selector ifPresent: [:method |  ^method ].        lookupClass := lookupClass superclass ].  ^nil-=JUAMPI=-testInquiries  self     assert: week start asDate equals: '28 June 1998' asDate;     assert: week end asDate equals: '4 July 1998' asDate;     assert: week index equals: 5;     assert: week duration equals: 7 days-=JUAMPI=-reflectiveMethod  ^self propertyAt: #reflectiveMethod ifAbsent: nil-=JUAMPI=-runTestCase: aTestCase  | testEnv |  testEnv := TestExecutionEnvironment new.  testEnv beActiveDuring: [ testEnv runTestCase: aTestCase ]-=JUAMPI=-isVowel  ^'AEIOU' includes: self asUppercase-=JUAMPI=-isResumable  ^false-=JUAMPI=-assert  self value ifFalse: [ AssertionFailure signal: 'Assertion failed' ]-=JUAMPI=-largeIdentityHash  ^self basicIdentityHash-=JUAMPI=-traversableIndexableVarIndexes  ^1 to: self basicSize-=JUAMPI=-slots  ^self classLayout visibleSlots-=JUAMPI=-isModifierSymbol  ^self characterSet isModifierSymbol: self-=JUAMPI=-setUp  super setUp.  aCompiledMethod := Rectangle methodDict at: #rightCenter.  aReceiver := 100 @ 100 corner: 200 @ 200.  aSender := thisContext.  aMethodContext := Context sender: aSender receiver: aReceiver method: aCompiledMethod arguments: #()-=JUAMPI=-isPinned  ^self isPinnedInMemory-=JUAMPI=-literalEqual: other  ^self class == other class and: [ self = other ]-=JUAMPI=-addProtocolNamed: aName  ^protocols add: (Protocol name: aName)-=JUAMPI=-intersectWithCC: aSet withAll: sets continuation: hop  ^aSet ifEmpty: [ hop value: aSet ] ifNotEmpty: [ sets ifEmpty: [ aSet ] ifNotEmpty: [ self intersect: aSet withCollection: (self intersectWithCC: sets first withAll: sets allButFirst continuation: hop) continuation: hop ] ]-=JUAMPI=-removeClassVariable: aGlobal  self removeClassVarNamed: aGlobal name-=JUAMPI=-copiedValueAt: i  < primitive: 60>  ^self basicAt: i-=JUAMPI=-spotterUsedSlotsFor: aStep  < spotterOrder: 70>  aStep listProcessor     title: 'Full Definition Slots';     allCandidates: [ self slots select: [:slot |  slot needsFullDefinition ] ];     itemName: [:item |  item definitionString ];     filter: GTFilterSubstring-=JUAMPI=-testSimpleTwoDelays  | delay1 delay2 |  delay1 := Delay new setDelay: 2 forSemaphore: Semaphore new.  delay2 := Delay new setDelay: 4 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: delay1 beingWaitedOn.  self deny: delay2 beingWaitedOn.  scheduler schedule: delay1.  scheduler schedule: delay2.  self assert: delay1 beingWaitedOn.  self assert: delay2 beingWaitedOn.  scheduler simulate_vmMilliseconds: 11.  self deny: delay1 isExpired.  self deny: delay2 isExpired.  scheduler simulate_vmMilliseconds: 12.  self assert: delay1 isExpired.  self deny: delay2 isExpired.  scheduler simulate_vmMilliseconds: 13.  self deny: delay2 isExpired.  scheduler simulate_vmMilliseconds: 14.  self assert: delay2 isExpired-=JUAMPI=-testIfNotNil  | object returnValue block reached |  object := ProtoObject new.  returnValue := Object new.  reached := false.  object ifNotNil: [ reached := true ].  self assert: reached equals: true.  reached := false.  object ifNotNil: [:o |  reached := true ].  self assert: reached equals: true.  self assert: (object ifNotNil: [:o |  o == object ]).  self assert: (object ifNotNil: [ returnValue ]) identicalTo: returnValue.  self assert: (object ifNotNil: [:o |  returnValue ]) identicalTo: returnValue.  block := [ reached := true ].  object ifNotNil: block.  self assert: reached equals: true.  reached := false.  block := [:o |  reached := true ].  object ifNotNil: block.  self assert: reached equals: true.  block := [:o |  o == object ].  self assert: (object ifNotNil: block).  block := [ returnValue ].  self assert: (object ifNotNil: block) equals: returnValue.  block := [:o |  returnValue ].  self assert: (object ifNotNil: block) equals: returnValue-=JUAMPI=-isLiteral  ^true-=JUAMPI=-isSeparator  | in |  ^(in := self asInteger) == 32 or: [ in == 13 or: [ in == 9 or: [ in == 10 or: [ in == 12 ] ] ] ]-=JUAMPI=-defaultQueue  defaultQueue ifNil: [ defaultQueue := OrderedCollection new ].  ^defaultQueue-=JUAMPI=-testMidnight  self assert: aDateAndTime midnight equals: aDateAndTime-=JUAMPI=-asContext  ^self asContextWithSender: nil-=JUAMPI=-subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames package: aCategorySymbol  ^self classInstaller make: [:builder |  builder           name: aSubclassSymbol;           superclass: self;           layoutClass: layoutClass;           slots: slotDefinition;           sharedVariables: classVarDefinition;           sharedPools: someSharedPoolNames;           category: aCategorySymbol ]-=JUAMPI=-removeProperty: propName ifAbsent: aBlock  | property |  self properties ifNil: [ ^aBlock value ].  property := self properties removeKey: propName ifAbsent: aBlock.  self removePropertiesIfEmpty.  ^property-=JUAMPI=-isInteger  ^false-=JUAMPI=-printStringRoman  | stream integer |  stream := String new writeStream.  integer := self negative ifTrue: [ stream nextPut: $-.        self negated ] ifFalse: [ self ].  integer // 1000 timesRepeat: [ stream nextPut: $M ].  integer     romanDigits: 'MDC' for: 100 on: stream;     romanDigits: 'CLX' for: 10 on: stream;     romanDigits: 'XVI' for: 1 on: stream.  ^stream contents-=JUAMPI=-testAsYear  self assert: aDateAndTime asYear equals: (Year starting: '01-01-1970' asDate)-=JUAMPI=-primitiveFail  ^self primitiveFailed-=JUAMPI=-testMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'AM'-=JUAMPI=-triggerEvent: anEventSelector withArguments: anArgumentList  ^(self actionForEvent: anEventSelector) valueWithArguments: anArgumentList-=JUAMPI=-updateableActionMap  ^EventManager updateableActionMapFor: self-=JUAMPI=-error  ^self error: 'Error!'-=JUAMPI=-bytesCount  | value length |  length := 1.  value := self.  value >= 0 ifTrue: [ [ value > 255 ] whileTrue: [ value := value bitShift: -8.              length := length + 1 ] ] ifFalse: [ [ value < -255 ] whileTrue: [ value := value bitShift: -8.              length := length + 1 ] ].  ^length-=JUAMPI=-asAlien  ^1-=JUAMPI=-innerBindingOf: aSymbol  (self classPool bindingOf: aSymbol) ifNotNil: [:binding |  ^binding ].  self sharedPools do: [:pool |  (pool bindingOf: aSymbol) ifNotNil: [:binding |  ^binding ] ].  self superclass ifNotNil: [:supercl |  ^supercl innerBindingOf: aSymbol ].  ^nil-=JUAMPI=-supermostPrecodeCommentFor: selector  | aSuper superComment |  (self == Behavior or: [ self superclass == nil or: [ (aSuper := self superclass whichClassIncludesSelector: selector) == nil ] ]) ifFalse: [ superComment := aSuper supermostPrecodeCommentFor: selector ].  ^superComment ifNil: [ self firstPrecodeCommentFor: selector ]-=JUAMPI=-expandRectangle: aRectangle  ^Rectangle left: aRectangle left - self left right: aRectangle right + self right top: aRectangle top - self top bottom: aRectangle bottom + self bottom-=JUAMPI=-valueWithArguments: aSequenceOfArguments  ^self-=JUAMPI=-cull: firstArg cull: secondArg cull: thirdArg cull: fourthArg  ^numArgs < 4 ifTrue: [ self cull: firstArg cull: secondArg cull: thirdArg ] ifFalse: [ self value: firstArg value: secondArg value: thirdArg value: fourthArg ]-=JUAMPI=-testAsYear  self     assert: 1 year days equals: 365;     assert: 0.5 year asHours equals: 364 / 2 * 24 + 12-=JUAMPI=-link: aMetaLink toClassVariableNamed: aClassVariableName option: option  aMetaLink installOnClassVarNamed: aClassVariableName for: self option: option instanceSpecific: self intanceSpecificMetaLinksAvailable-=JUAMPI=-basicNew  < primitive: 70 error: ec>  ec == #'insufficient object memory' ifTrue: [ ^self handleFailingBasicNew ].  self isVariable ifTrue: [ ^self basicNew: 0 ].  self primitiveFailed-=JUAMPI=-simpleRetryTest  | theMeaningOfLife |  theMeaningOfLife := nil.  [ self doSomething.  theMeaningOfLife == nil ifTrue: [ MyTestError signal ] ifFalse: [ self doSomethingElse ] ] on: MyTestError do: [:ex |  theMeaningOfLife := 42.        self doYetAnotherThing.        ex retry ]-=JUAMPI=-do: aBlock with: aFirstElement  self do: aBlock with: aFirstElement when: [:t |  true ]-=JUAMPI=-upperBound  ^upperBound-=JUAMPI=-isCompiledMethodClass  ^self instSpec >= 24-=JUAMPI=-superclass  ^superclass-=JUAMPI=-testIsPowerOfTwoM6873  self deny: ((1 to: 80) anySatisfy: [:n |  (2 raisedTo: n) negated isPowerOfTwo ]) description: 'A negative integer cannot be a power of two'-=JUAMPI=-asUppercase  ^self characterSet toUppercase: self-=JUAMPI=-modelWakeUpIn: aWindow  -=JUAMPI=-digitMultiply: arg neg: ng  < primitive: 'primDigitMultiplyNegative' module: 'LargeIntegers'>  | prod prodLen carry digit k ab |  (arg bytesCount = 1 and: [ (arg byteAt: 1) = 0 ]) ifTrue: [ ^0 ].  (self bytesCount = 1 and: [ (self byteAt: 1) = 0 ]) ifTrue: [ ^0 ].  prodLen := self bytesCount + arg bytesCount.  prod := Integer new: prodLen neg: ng.  1 to: self bytesCount do: [:i |  (digit := self byteAt: i) ~= 0 ifTrue: [ k := i.              carry := 0.              1 to: arg bytesCount do: [:j |  ab := (arg byteAt: j) * digit + carry + (prod byteAt: k).                    carry := ab bitShift: -8.                    prod byteAt: k put: (ab bitAnd: 255).                    k := k + 1 ].              prod byteAt: k put: carry ] ].  ^prod normalize-=JUAMPI=-testSimplestCallCC  | x |  x := self callcc: [:cc |  cc value: true ].  self assert: x-=JUAMPI=-printOn: aStream  aStream nextPutAll: self monthName , ' ' , self year printString-=JUAMPI=-collectArguments: anArgArray  | staticArgs |  staticArgs := self arguments.  ^anArgArray size = staticArgs size ifTrue: [ Array withAll: anArgArray ] ifFalse: [ (staticArgs isEmpty ifTrue: [ staticArgs := Array new: selector numArgs ] ifFalse: [ Array withAll: staticArgs ]) replaceFrom: 1 to: (anArgArray size min: staticArgs size) with: anArgArray startingAt: 1 ]-=JUAMPI=-stringForReadout  ^self rounded printString-=JUAMPI=-yyyymmdd  ^String new: 10 streamContents: [:aStream |  self printOn: aStream format: #(3 2 1 $- 1 1 2) ]-=JUAMPI=-< aTime  ^self asDuration < aTime asDuration-=JUAMPI=-protocols  ^self protocolOrganizer protocols-=JUAMPI=-testFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 2004-02-29T13:33:00+02:00')-=JUAMPI=-testConvertFromFloat  | aFloat sd f2 diff |  aFloat := 11 / 13 asFloat.  sd := aFloat asScaledDecimal: 2.  self assert: 2 equals: sd scale.  self assert: '0.85s2' equals: sd printString.  self assert: '-0.85s2' equals: sd negated printString.  f2 := sd asFloat.  diff := f2 - aFloat.  self assert: diff abs < 1.0e-9-=JUAMPI=-signal  | pragma |  (context method hasPragmaNamed: #transform:to:) ifFalse: [ ^super signal ].  pragma := context method pragmaAt: #transform:to:.  self rule: pragma arguments first -> pragma arguments second.  self transform-=JUAMPI=-testRemoveOneStar  | tree1 tree2 |  tree1 := #Swedish ~~> (#rye ~~> nil) ~~> (#French ~~> (#mustard ~~> (#salad ~~> (#turkey ~~> nil)) ~~> nil) ~~> (#salad ~~> nil)).  tree2 := #pasta ~~> (#meat ~~> nil) ~~> (#pasta ~~> (#noodles ~~> (#meat ~~> (#sauce ~~> nil)) ~~> (#meat ~~> (#tomatoes ~~> nil)))).  self assert: (self printStringOfTree: tree1) equals: '((#Swedish #rye) (#French (#mustard #salad #turkey)) #salad)'.  self assert: (self printStringOfTree: tree2) equals: '((#pasta #meat) #pasta (#noodles #meat #sauce) #meat #tomatoes)'.  self assert: (self printStringOfTree: (self remove: #salad oneStar: tree1)) equals: '((#Swedish #rye) (#French (#mustard #turkey)) #salad)'.  self assert: (self printStringOfTree: (self remove: #salad oneStarWithTry: tree1)) equals: '((#Swedish #rye) (#French (#mustard #turkey)) #salad)'.  self assert: (self printStringOfTree: (self remove: #meat oneStar: tree2)) equals: '((#pasta) #pasta (#noodles #meat #sauce) #meat #tomatoes)'.  self assert: (self printStringOfTree: (self remove: #meat oneStarWithTry: tree2)) equals: '((#pasta) #pasta (#noodles #meat #sauce) #meat #tomatoes)'-=JUAMPI=-exampleSend  < sampleInstance>  instVar1 := 1.  self yourself.  ^thisContext copy-=JUAMPI=-okToClose  ^true-=JUAMPI=-testCreationWithOffsets  | dt1 dt2 |  dt1 := DateAndTime year: 2222 month: 1 day: 22 hour: 1 minute: 22 second: 33 offset: 0 hours.  dt2 := DateAndTime year: 2222 month: 1 day: 22 hour: 1 minute: 22 second: 33 offset: 2 hours.  self deny: dt1 equals: dt2.  self assert: dt1 year equals: dt2 year.  self assert: dt1 month equals: dt2 month.  self assert: dt1 day equals: dt2 day.  self assert: dt1 hours equals: dt2 hours.  self assert: dt1 minutes equals: dt2 minutes.  self assert: dt1 seconds equals: dt2 seconds-=JUAMPI=-testChangingShapeDoesNotPutNilInMethodsLastLiteralKey  | tutu |  tutu := testEnvironment at: #TUTU.  tutu compile: 'foo'.  self deny: (tutu >> #foo) allLiterals last key isNil.  tutu addInstVarNamed: 'x'.  self deny: (tutu >> #foo) allLiterals last key isNil-=JUAMPI=-adoptForNewCalypsoQuery  ^self-=JUAMPI=-propertyValueAt: propName ifAbsent: aBlock  ^self propertyAt: propName ifAbsent: aBlock-=JUAMPI=-exception: anError  exception := anError-=JUAMPI=-shallowCopy  -=JUAMPI=-testBenchFib  self assert: 0 benchFib equals: 1.  self assert: 1 benchFib equals: 1.  self assert: 2 benchFib equals: 3-=JUAMPI=-javascriptOn: aStream  aStream javascript: self asMilliseconds-=JUAMPI=-serializeOn: anEncoder  -=JUAMPI=-thoroughWhichMethodsReferTo: literal  | specialIndex |  specialIndex := Smalltalk specialSelectorIndexOrNil: literal.  ^self methods select: [:method |  method hasSelector: literal specialSelectorIndex: specialIndex ]-=JUAMPI=-superclass: aClass methodDictionary: mDict format: fmt  super superclass: aClass methodDictionary: mDict format: fmt.  self organization: nil-=JUAMPI=-isEpEvent  ^false-=JUAMPI=-ffiCall: fnSpec library: aLibrary  < ffiCalloutTranslator>  self ffiCall: fnSpec library: aLibrary options: #()-=JUAMPI=-asMilliSeconds  ^self asDuration asMilliSeconds-=JUAMPI=-asFullRingDefinition  | rgClass rgMethod |  rgClass := self realClass asRingDefinition.  rgMethod := self asActiveRingDefinition.  rgClass addMethod: rgMethod.  rgMethod package: (RGContainer packageOfMethod: rgMethod).  ^rgMethod-=JUAMPI=-fuelSetOrigin: originPoint corner: cornerPoint  origin := originPoint.  corner := cornerPoint-=JUAMPI=-postCopy  array := array copy-=JUAMPI=-testByteAt  | number |  number := 16rABCDEF.  self assert: (number byteAt: 1) equals: 16rEF.  self assert: (number byteAt: 2) equals: 16rCD.  self assert: (number byteAt: 3) equals: 16rAB-=JUAMPI=-fourDirections  ^Array with: self leftRotated with: self negated with: self rightRotated with: self-=JUAMPI=-isHealthy  1 to: self basicSize do: [:i |  | selector |        selector := self basicAt: i.        selector ifNotNil: [ (self scanFor: selector) == i ifFalse: [ ^false ] ] ].  ^true-=JUAMPI=-raisedToFraction: aFraction  | result |  result := self asFraction raisedToFraction: aFraction.  ^result isFloat ifTrue: [ result ] ifFalse: [ result asScaledDecimal: scale ]-=JUAMPI=-doSomethingElse  self log: self doSomethingElseString-=JUAMPI=-testIsNonspacingMark  self checkCorrespondanceOf: #isNonspacingMark: and: #Mn-=JUAMPI=-testUnwindFromActiveProcess  | sema process |  sema := Semaphore forMutualExclusion.  self assert: sema isSignaled.  process := [ sema critical: [ self deny: sema isSignaled.        Processor activeProcess terminate ] ] forkAt: Processor userInterruptPriority.  self assert: sema isSignaled-=JUAMPI=-name  ^'Overrides a deprecated method'-=JUAMPI=-inspectSubInstances  | all allSize prefix |  all := self allSubInstances.  (allSize := all size) isZero ifTrue: [ ^self inform: 'There are no instances of ' , self name , 'or any of its subclasses' ].  prefix := allSize = 1 ifTrue: [ 'The lone instance' ] ifFalse: [ 'The ' , allSize printString , ' instances' ].  all asArray inspectWithLabel: prefix , ' of ' , self name , ' & its subclasses'-=JUAMPI=-genStorePopInstVarLong: instVarIndex  (instVarIndex < 0 or: [ instVarIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535 ].  instVarIndex > 255 ifTrue: [ self genUnsignedSingleExtendA: instVarIndex // 256 ].  stream     nextPut: 240;     nextPut: instVarIndex \\ 256-=JUAMPI=-isValid  ^self isReceiverOrAnyArgumentGarbage not-=JUAMPI=-renderOn: aRenderer  self numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: aRenderer ]-=JUAMPI=-printOn: aStream  | name |  (self asInteger > 32 and: [ self asInteger ~= 127 ]) ifTrue: [ aStream           nextPut: $$;           nextPut: self ] ifFalse: [ name := self class constantNameFor: self.        aStream nextPutAll: self class name.        name notNil ifTrue: [ aStream                 space;                 nextPutAll: name ] ifFalse: [ aStream                 nextPutAll: ' value: ';                 print: self asInteger ] ]-=JUAMPI=-testSimpleEnsureTestWithUparrow  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithUparrow)-=JUAMPI=-isOtherNumber  ^self characterSet isOtherNumber: self-=JUAMPI=-frameSize  (self header noMask: 16r20000) ifTrue: [ ^SmallFrame ] ifFalse: [ ^LargeFrame ]-=JUAMPI=-numberOfDigitsInBase: b  b = 10 ifFalse: [ ^super numberOfDigitsInBase: b ].  self < 0 ifTrue: [ ^self negated numberOfDigitsInBase: b ].  ^self decimalDigitLength-=JUAMPI=-scaledAndCenteredIn: aRect  ^self width / aRect width > (self height / aRect height) ifTrue: [ aRect left @ (aRect leftCenter y - (self height * (aRect width / self width) / 2)) corner: aRect right @ (aRect rightCenter y + (self height * (aRect width / self width) / 2)) ] ifFalse: [ (aRect topCenter x - (self width * (aRect height / self height) / 2)) @ aRect top corner: (aRect topCenter x + (self width * (aRect height / self height) / 2)) @ aRect bottom ]-=JUAMPI=-defaultAction  reachedDefaultHandler := true.  super defaultAction-=JUAMPI=-testAsDuration  self assert: aDateAndTime asDuration equals: aDuration-=JUAMPI=-testPrintOn  self assert: (String streamContents: [:stream |  false printOn: stream ]) equals: 'false'-=JUAMPI=-split: aSequenceableCollection do: aBlock  self split: aSequenceableCollection indicesDo: [:start :end |  aBlock value: (aSequenceableCollection copyFrom: start to: end) ]-=JUAMPI=->= anInteger  < primitive: 26>  ^super >= anInteger-=JUAMPI=-testOnFork  | result1 result2 |  result2 := nil.  result1 := [ 1 ] on: Exception fork: [ result2 := 2 ].  Processor yield.  self assert: result1 equals: 1.  self assert: result2 isNil-=JUAMPI=-hash  ^self ticks hash-=JUAMPI=-pushReceiverVariable: offset  self push: (self object: self receiver instVarAt: offset + 1)-=JUAMPI=-printStringHex  ^self printStringBase: 16-=JUAMPI=-max: aPoint  ^(x max: aPoint x) @ (y max: aPoint y)-=JUAMPI=-classComment: aString stamp: aStamp  self     comment: aString;     commentStamp: aStamp-=JUAMPI=-testDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 1-=JUAMPI=-testIsNonspacingMark  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isNonspacingMark: ch) equals: (charset isNonspacingMark: ch) ]-=JUAMPI=-storeOn: aStream  aStream     print: self printString;     nextPutAll: ' asDate'-=JUAMPI=-isNonspacingMark  ^self characterSet isNonspacingMark: self-=JUAMPI=-hasMultipleExecutors  ^false-=JUAMPI=-testBasicCheck1  | testMethod |  testMethod := testClass >> (testClass compile: 'testMethod SmallFloat64').  self assert: (FloatReferencesRule new basicCheck: testMethod ast)-=JUAMPI=-continuationExample1: aCollection  | streamCreator collector |  streamCreator := [:collection |  | i localBlock |  i := 1.  localBlock := [ | current |  current := collection at: i.  i := i + 1.  Array with: current with: (i <= collection size ifTrue: [ localBlock ] ifFalse: [ nil ]) ] ].  collector := [:valueWithContinuation |  | oc |  oc := OrderedCollection new.  [ | local |  local := valueWithContinuation value.  oc add: local first.  local last notNil ] whileTrue: [  ].  oc ].  ^collector value: (streamCreator value: aCollection)-=JUAMPI=-testBasicProxyWritable  self alwaysWritableObjects , self maybeReadOnlyObjects do: [:each |  self assert: (MirrorPrimitives isObjectReadOnly: each) equals: false ]-=JUAMPI=-isHandlerOrSignalingContext  ^method primitive = 199-=JUAMPI=-testNanoConstructor  | timeFromString timeFromNano timeFromNanoSecond |  timeFromString := Time fromString: '01:23:45.67809'.  timeFromNano := Time hour: 1 minute: 23 second: 45 nano: 67809.  timeFromNanoSecond := Time hour: 1 minute: 23 second: 45 nanoSecond: 67809.  self     assert: timeFromString equals: timeFromNano;     deny: timeFromNano equals: timeFromNanoSecond.  timeFromString := Time fromString: '01:23:45.0'.  timeFromNano := Time hour: 1 minute: 23 second: 45 nano: 0.  self assert: timeFromString equals: timeFromNano.  timeFromString := Time fromString: '01:23:45.1234567890'.  timeFromNano := Time hour: 1 minute: 23 second: 45 nano: 1234567890.  self assert: timeFromString equals: timeFromNano-=JUAMPI=-montgomeryRaisedTo: n times: y modulo: m mInvModB: mInv  | pow j k w index oddPowersOfSelf square |  k := n highBit.  w := (k highBit - 1 >> 1 min: 16) max: 1.  oddPowersOfSelf := Array new: 1 << w.  oddPowersOfSelf at: 1 put: (pow := self).  square := self montgomeryTimes: self modulo: m mInvModB: mInv.  2 to: oddPowersOfSelf size do: [:i |  pow := oddPowersOfSelf at: i put: (pow montgomeryTimes: square modulo: m mInvModB: mInv) ].  pow := y.  [ k > 0 ] whileTrue: [ pow := pow montgomeryTimes: pow modulo: m mInvModB: mInv.        (n bitAt: k) = 0 ifFalse: [ j := k - w max: 1.              [ j < k and: [ (n bitAt: j) = 0 ] ] whileTrue: [ j := j + 1 ].              index := 0.              [ k > j ] whileTrue: [ pow := pow montgomeryTimes: pow modulo: m mInvModB: mInv.                    index := (index << 1) + (n bitAt: k).                    k := k - 1 ].              pow := pow montgomeryTimes: (oddPowersOfSelf at: index + 1) modulo: m mInvModB: mInv ].        k := k - 1 ].  ^pow-=JUAMPI=-asScaledDecimal  ^ScaledDecimal newFromNumber: self scale: 0-=JUAMPI=-sampleMessageWithFirstArgument: firstArgument andInterleavedCommentBeforeSecondArgument: secondArgument  | thisIsAnUnusedTemp |  thisIsAnUnusedTemp := self.  ^thisIsAnUnusedTemp-=JUAMPI=-initialize  super initialize.  vmSimTheTimerSemaphore := Semaphore new.  vmSimNow := 0-=JUAMPI=-copyto: x  | stop |  stop := self bytesCount min: x bytesCount.  ^x replaceFrom: 1 to: stop with: self startingAt: 1-=JUAMPI=-hash  ^self-=JUAMPI=-checkAllClasses  | warnings |  warnings := (self systemNavigation allClassesImplementing: #veryDeepInner:) , (self systemNavigation allClassesImplementing: #veryDeepCopyWith:) flatCollect: [:aClass |  self basicCheckClass: aClass ].  self raiseWarningsIfAny: warnings-=JUAMPI=-truncateTo: grid  | gridPoint |  gridPoint := grid asPoint.  ^(x truncateTo: gridPoint x) @ (y truncateTo: gridPoint y)-=JUAMPI=-testDurationMoreThanMaxTicks  | delay |  delay := Delay new setDelay: 1234 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: delay.  self assert: ticker vmSimNextWakeupMilliseconds equals: 100 + 1000-=JUAMPI=-testFromString  self assert: aDuration equals: (Duration fromString: '1:02:03:04.000000005')-=JUAMPI=-deepCopy  ^self-=JUAMPI=-doesNotUnderstand: aMessage  < debuggerCompleteToSender>  | exception resumeValue |  (exception := MessageNotUnderstood new)     message: aMessage;     receiver: self.  resumeValue := exception signal.  ^exception reachedDefaultHandler ifTrue: [ aMessage sentTo: self ] ifFalse: [ resumeValue ]-=JUAMPI=-testRunSimulated  self assert: (Context runSimulated: aBlockContext) class equals: Rectangle-=JUAMPI=-ephemeronSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self ephemeronSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: cat-=JUAMPI=-testTimesAreLocal  | remoteDateAndTime remoteTimestamp localTimestamp |  remoteDateAndTime := DateAndTime current offset: DateAndTime localOffset + 2 hours.  remoteTimestamp := DosTimestamp fromDateAndTime: remoteDateAndTime.  localTimestamp := DosTimestamp fromDateAndTime: remoteDateAndTime asLocal.  self assert: remoteTimestamp equals: localTimestamp-=JUAMPI=-testMetaclassName  self assert: Dictionary class name equals: 'Dictionary class'.  self assert: OrderedCollection class name equals: 'OrderedCollection class'-=JUAMPI=-isExternalCallPrimitive  ^self primitive = 120-=JUAMPI=-testErrorToken  | token1 token2 |  token1 := Context primitiveFailToken.  token2 := Context primitiveFailTokenFor: 100.  self assert: token1 first identicalTo: token2 first.  self assert: token1 second isNil.  self assert: token2 second equals: 100-=JUAMPI=-setUp  super setUp.  value := 0-=JUAMPI=-saveTemp: aTemp  self savedTemps ifNil: [ self propertyAt: #savedTemps put: Set new ].  self savedTemps add: aTemp-=JUAMPI=-align: aPoint1 with: aPoint2  ^self translateBy: aPoint2 - aPoint1-=JUAMPI=-select: aBlock  | newCollection |  newCollection := self class new.  self do: [:each |  (aBlock value: each) ifTrue: [ newCollection add: each ] ].  ^newCollection-=JUAMPI=-testBecomeIdentityHash  | a b c d |  a := 'ab' copy.  b := 'cd' copy.  c := a.  d := b.  a become: b.  self     assert: a identityHash equals: c identityHash;     assert: b identityHash equals: d identityHash;     deny: a identityHash equals: b identityHash-=JUAMPI=-testNumberConvenienceMethods  self     assert: 1 week equals: (Duration days: 7);     assert: -1 week equals: (Duration days: -7);     assert: 1 day equals: (Duration days: 1);     assert: -1 day equals: (Duration days: -1);     assert: 1 hours equals: (Duration hours: 1);     assert: -1 hour equals: (Duration hours: -1);     assert: 1 minute equals: (Duration seconds: 60);     assert: -1 minute equals: (Duration seconds: -60);     assert: 1 second equals: (Duration seconds: 1);     assert: -1 second equals: (Duration seconds: -1);     assert: 1 milliSecond equals: (Duration milliSeconds: 1);     assert: -1 milliSecond equals: (Duration milliSeconds: -1);     assert: 1 nanoSecond equals: (Duration nanoSeconds: 1);     assert: -1 nanoSecond equals: (Duration nanoSeconds: -1)-=JUAMPI=-ifNotNil: ifNotNilBlock ifNil: nilBlock  ^nilBlock value-=JUAMPI=-brickValue: anObject withEnoughArguments: aCollection  ^self valueWithEnoughArguments: {anObject} , aCollection-=JUAMPI=-addCategory: newName before: aCategory  ^self organization addCategory: newName before: aCategory-=JUAMPI=-isPrimFailToken: anObject  ^(self objectClass: anObject) == Array and: [ anObject size = 2 and: [ anObject first == PrimitiveFailToken ] ]-=JUAMPI=-critiques  < eProperty>  | critiques |  critiques := ReCriticEngine critiquesOf: self.  critiques := critiques , (ReCriticEngine nodeCritiquesOf: self).  ^critiques-=JUAMPI=-at: aKey ifPresent: aBlock  ^aBlock value: (self at: aKey ifAbsent: [ ^self ])-=JUAMPI=-genPushLiteralVar: literalIndex  literalIndex < 0 ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255 ].  literalIndex < 32 ifTrue: [ stream nextPut: 64 + literalIndex.        ^self ].  literalIndex < 64 ifTrue: [ stream           nextPut: 128;           nextPut: 192 + literalIndex.        ^self ].  literalIndex < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 128;           nextPut: literalIndex.        ^self ].  ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255-=JUAMPI=-group  ^'Potential Bugs'-=JUAMPI=-testIncludesAll  self assert: (aTimespan includesAll: (Bag with: jan01)).  self deny: (aTimespan includesAll: (Bag with: jan01 with: jan08))-=JUAMPI=-properties  ^ClassProperties at: self ifAbsent: nil-=JUAMPI=-minute  ^self localSeconds // SecondsInMinute \\ 60-=JUAMPI=-triggerEvent: anEventSelector with: anObject  ^self triggerEvent: anEventSelector withArguments: {anObject}-=JUAMPI=-subtractDays: dayCount  ^(self asDateAndTime - dayCount days) asDate-=JUAMPI=-seconds: secondCount nanoSeconds: nanoCount  seconds := secondCount.  nanos := nanoCount-=JUAMPI=-rule: aRule  rule := aRule-=JUAMPI=-testMultDicAddSub  | n f f1 |  n := 100.  f := 100 factorial.  f1 := f * (n + 1).  n timesRepeat: [ f1 := f1 - f ].  self assert: f1 equals: f.  n timesRepeat: [ f1 := f1 + f ].  self assert: f1 // f equals: n + 1.  self assert: f1 negated equals: (Number readFrom: '-' , f1 printString)-=JUAMPI=-nextInstruction  ^self interpretNextInstructionFor: MessageCatcher new-=JUAMPI=-testSemaphoreTimeout  | sem |  sem := Semaphore new.  [ | process |  process := [ Delay timeoutSemaphore: sem afterMSecs: 0.  sem wait ] newProcess.  process priority: Processor highIOPriority.  process resume.  self assert: process isTerminated ] ensure: [ sem signal ]-=JUAMPI=-storeOn: aStream  self storeOn: aStream base: 10-=JUAMPI=-sharedPools: aCollection  sharedPools := aCollection-=JUAMPI=-testNot  self deny: true not-=JUAMPI=-testMillisecondsToGoExpired  | delay |  delay := Delay forMilliseconds: 100.  scheduler simulate_vmMilliseconds: 1.  scheduler schedule: delay.  scheduler simulate_vmMilliseconds: 200-=JUAMPI=-methodClass  ^self outerCode methodClass-=JUAMPI=-testSingleTiming  | timeBefore |  timeBefore := DateAndTime now.  aStopwatch activate.  aDelay wait.  aStopwatch suspend.  self assert: aStopwatch timespans size equals: 1.  self assert: aStopwatch timespans first asDateAndTime >= timeBefore.  self assert: aStopwatch timespans first asDateAndTime <= aStopwatch end-=JUAMPI=-name  ^'Sends a deprecated message to a known global'-=JUAMPI=-var1: anObject  var1 := anObject-=JUAMPI=-name  ^self subclassResponsibility-=JUAMPI=-testConvertFromDecimalFraction  0 to: 11 do: [:pow2 |  0 to: 11 do: [:pow5 |  | fraction sd sd2 |              fraction := 13 / (2 raisedTo: pow2) / (5 raisedTo: pow5).              sd := fraction asScaledDecimal.              self assert: sd scale equals: (pow2 max: pow5).              sd2 := ScaledDecimal readFrom: sd printString.              self assert: sd equals: sd2 ] ]-=JUAMPI=-allSharedPools  ^self superclass ifNil: [ self sharedPools copy ] ifNotNil: [ | aSet |        aSet := self superclass allSharedPools.        aSet           addAll: self sharedPools;           yourself ]-=JUAMPI=-retryUsing: alternativeBlock  handlerContext restartWithNewReceiver: alternativeBlock-=JUAMPI=-criticNameOn: aStream  aStream << self name << ' (' << self category << ')'-=JUAMPI=-methodsReadingSlot: aSlot  ^self methods select: [:method |  method readsSlot: aSlot ]-=JUAMPI=-fieldIndex  ^fieldIndex-=JUAMPI=-addDays: dayCount  ^(self asDateAndTime + dayCount days) asDate-=JUAMPI=-allSubInstances  | aCollection |  aCollection := OrderedCollection new.  self allSubInstancesDo: [:x |  x == aCollection ifFalse: [ aCollection add: x ] ].  ^aCollection-=JUAMPI=-critiqueFor: aPackage  ^ArchitecturalCritique withAnchor: (self anchorFor: aPackage) by: self-=JUAMPI=-testMetaclassSuperclassHierarchy  | s |  self assert: SequenceableCollection class instanceCount equals: 1.  self assert: Collection class instanceCount equals: 1.  self assert: Object class instanceCount equals: 1.  self assert: ProtoObject class instanceCount equals: 1.  s := OrderedCollection new     add: SequenceableCollection class;     add: Collection class;     add: Object class;     add: ProtoObject class;     add: Class;     add: ClassDescription;     add: Behavior;     add: Object;     add: ProtoObject;     yourself.  self assert: OrderedCollection class allSuperclasses equals: s-=JUAMPI=-testEncodingVarLengthSourcePointer  | trailer newTrailer |  trailer := CompiledMethodTrailer new.  trailer sourcePointer: 1.  newTrailer := trailer testEncoding.  self assert: newTrailer sourcePointer equals: 1.  trailer sourcePointer: 16r100000000000000.  newTrailer := trailer testEncoding.  self assert: newTrailer sourcePointer equals: 16r100000000000000.  self assert: newTrailer endPC equals: 0-=JUAMPI=-stonOn: stonWriter  stonWriter writeBoolean: self-=JUAMPI=-as31BitSmallInt  ^self subclassResponsibility-=JUAMPI=-index  ^self monthIndex-=JUAMPI=-genSendSuper: selectorLiteralIndex numArgs: nArgs  | extendedIndex extendedNArgs |  (selectorLiteralIndex < 0 or: [ selectorLiteralIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535 ].  (nArgs < 0 or: [ nArgs > 31 ]) ifTrue: [ ^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 ].  (extendedIndex := selectorLiteralIndex) > 31 ifTrue: [ self genUnsignedSingleExtendA: extendedIndex // 32.        extendedIndex := extendedIndex \\ 32 ].  (extendedNArgs := nArgs) > 7 ifTrue: [ self genUnsignedSingleExtendB: extendedNArgs // 8.        extendedNArgs := extendedNArgs \\ 8 ].  stream     nextPut: 235;     nextPut: extendedNArgs + (extendedIndex * 8)-=JUAMPI=-class  < primitive: 111>  self primitiveFailed-=JUAMPI=-