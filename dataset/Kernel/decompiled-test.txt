radiansToDegrees  ^self / RadiansPerDegree-======-withoutPrimitiveTryNamedPrimitiveIn: arg1 for: arg2 withArgs: arg3  | tmp1 |  arg3 size > 8 ifTrue: [ ^self class primitiveFailToken ].  tmp1 := self class tryNamedPrimitiveTemplateMethod.  tmp1 prepareForSimulationWith: arg3 size.  tmp1 == nil ifTrue: [ ^self class primitiveFailToken ].  self setNamedPrimitiveInformationFrom: arg1 toMethod: tmp1.  tmp1 flushCache.  ^tmp1 valueWithReceiver: arg2 arguments: arg3-======-forceNewFrom: arg1  | tmp1 tmp2 |  tmp1 := self new.  tmp2 := self instSize.  arg1 doWithIndex: [:arg2 :arg3 |  arg3 > tmp2 ifFalse: [ tmp1 instVarAt: arg3 put: arg2 ] ].  ^tmp1-======-ir  ^self ast ir-======-defaultAction  Log ifNotNil: [:arg1 |  arg1 add: self ].  self logTranscript.  self raiseWarning ifTrue: [ super defaultAction ]-======-adaptToInteger: arg1 andCompare: arg2  self isFinite ifFalse: [ arg2 == #= ifTrue: [ ^false ].        arg2 == #~= ifTrue: [ ^true ].        self isNaN ifTrue: [ ^false ].        (arg2 = #< or: [ arg2 = #<= ]) ifTrue: [ ^self positive ].        (arg2 = #> or: [ arg2 = #>= ]) ifTrue: [ ^self positive not ].        ^self error: 'unknow comparison selector' ].  arg2 == #= ifTrue: [ self fractionPart = 0.0 ifFalse: [ ^false ] ].  arg2 == #~= ifTrue: [ self fractionPart = 0.0 ifFalse: [ ^true ] ].  ^arg1 perform: arg2 with: self asTrueFraction-======-nthRoot: arg1  | tmp1 tmp2 |  tmp1 := self nthRootRounded: arg1.  (tmp1 raisedTo: arg1) = self ifTrue: [ ^tmp1 ].  tmp2 := Float precision - tmp1 highBitOfMagnitude.  tmp2 < 0 ifTrue: [ ^tmp1 asFloat ].  tmp1 := self << (tmp2 * arg1) nthRootRounded: arg1.  ^(tmp1 / (1 << tmp2)) asFloat-======-numArgs  ^1-======-storeIntoLiteralVariable: arg1  arg1 value: self top-======-suiteLog  suiteLog == nil ifTrue: [ suiteLog := OrderedCollection new ].  ^suiteLog-======-startUp: arg1  ^self startUp-======-testBasicCheck1  | tmp1 |  tmp1 := testClass >> (testClass compile: 'testMethod ' , self globalName , ' ' , self nonDeprecatedMethodName).  self assert: (tmp1 externalProperties noneSatisfy: [:arg1 |  arg1 rule class = SendsDeprecatedMethodToGlobalRule ])-======-testIntegerReadsNotOkFromString  self should: [ Integer readFrom: 'aaa' ] raise: Error.  self should: [ Integer readFrom: '-aaa' ] raise: Error.  self should: [ Integer readFrom: 'a3' base: 8 ] raise: Error-======-doDup  self push: self top-======-recursion  LocalRecursionStopper during: [ self recursion ]-======-removeDependent: arg1  | tmp1 |  tmp1 := self dependents reject: [:arg2 |  arg2 == arg1 ].  self myDependents: (tmp1 isEmpty ifFalse: [ tmp1 ]).  ^arg1-======-readDataFrom: arg1 size: arg2  | tmp1 tmp2 |  tmp1 := self class instSize.  self class isVariable ifTrue: [ tmp2 := arg2 - tmp1.        tmp2 < 0 ifTrue: [ self error: 'Class has changed too much.  Define a convertxxx method' ] ] ifFalse: [ tmp2 := 0.        tmp1 := arg2 ].  arg1 beginReference: self.  1 to: tmp1 do: [:arg3 |  self instVarAt: arg3 put: arg1 next ].  1 to: tmp2 do: [:arg3 |  self basicAt: arg3 put: arg1 next ].  ^self-======-testNow  self deny: aDateAndTime equals: DateAndTime now-======-testReadFrom  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := '2 June 1973' readStream.  tmp2 := '2-JUN-73' readStream.  tmp3 := 'June 2, 1973' readStream.  tmp4 := '6/2/73' readStream.  tmp5 := '2JUN73' readStream.  self     assert: (self dateClass readFrom: tmp1) equals: june2nd1973;     assert: (self dateClass readFrom: tmp2) equals: june2nd1973;     assert: (self dateClass readFrom: tmp3) equals: june2nd1973;     assert: (self dateClass readFrom: tmp4) equals: june2nd1973-======-testSubtractDate  self assert: (january23rd2004 subtractDate: january23rd2004 previous) equals: 1.  self assert: (january23rd2004 subtractDate: january23rd2004) equals: 0.  self assert: (january23rd2004 subtractDate: january23rd2004 next) equals: -1-======-weakSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 package: arg6  ^self weakSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 category: arg6-======-testMiddleOf  self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) equals: (Timespan starting: '12-31-1979' asDate duration: 2 days)-======-halt  < debuggerCompleteToSender>  Halt now-======-testSqrtErrorConditions  self should: [ (-1 / 4) sqrt ] raise: DomainError.  self should: [ (((1 << 1024) + 1) / ((1 << 1024) + 3)) negated sqrt ] raise: DomainError-======-whichClassIncludesSelector: arg1  (self includesSelector: arg1) ifTrue: [ ^self ].  self superclass == nil ifTrue: [ ^nil ].  ^self superclass whichClassIncludesSelector: arg1-======-pushLiteralVariable: arg1  self push: arg1 value-======-testBetweenAnd  self assert: (3 between: 0 and: 5).  self assert: (5.0 between: 5.0 and: 5.0).  self assert: (Date today between: Date today + 1 and: Date today + 3) not-======-classVarNames  ^self instanceSide ifNil: [ #() ] ifNotNil: [:arg1 |  arg1 classVarNames ]-======-nowTick  ^vmSimNow-======-isPinnedInMemory  < primitive: 183 error: ec>  ^self primitiveFailed-======-digitSubtract: arg1  < primitive: 'primDigitSubtract' module: 'LargeIntegers'>  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp5 := self bytesCount.  tmp6 := arg1 bytesCount.  (tmp5 = tmp6 ifTrue: [ [ (self byteAt: tmp5) = (arg1 byteAt: tmp5) and: [ tmp5 > 1 ] ] whileTrue: [ tmp5 := tmp5 - 1 ].        tmp6 := tmp5.        (self byteAt: tmp5) < (arg1 byteAt: tmp5) ] ifFalse: [ tmp5 < tmp6 ]) ifTrue: [ tmp2 := arg1.        tmp1 := self.        tmp7 := self negative == false.        tmp5 := tmp6 ] ifFalse: [ tmp2 := self.        tmp1 := arg1.        tmp7 := self negative ].  tmp4 := Integer new: tmp5 neg: tmp7.  tmp3 := 0.  1 to: tmp5 do: [:arg2 |  tmp3 := tmp3 + (tmp2 byteAt: arg2) - (tmp1 byteAt: arg2).        tmp4 byteAt: arg2 put: tmp3 - (tmp3 // 256 * 256).        tmp3 := tmp3 // 256 ].  ^tmp4 normalize-======-logEntry  self traceCr: 'Entered ' , thisContext sender printString-======-asSpotterProcessorLink  ^GTSpotterProcessorLink value: self-======-testNew  self assert: aDateAndTime equals: DateAndTime new-======-testDuration  self assert: aDateAndTime duration equals: 0 asDuration-======-prepareForNewProcess: arg1  forkedProcesses add: arg1-======-testDayOfWeekWithUTC  | tmp1 |  tmp1 := DateAndTime julianDayNumber: 2456385 offset: (Duration hours: 2).  self assert: tmp1 dayOfWeek equals: 3-======-raisedTo: arg1 modulo: arg2  | tmp1 tmp2 tmp3 |  arg1 = 0 ifTrue: [ ^1 ].  (self >= arg2 or: [ self < 0 ]) ifTrue: [ ^self \\ arg2 raisedTo: arg1 modulo: arg2 ].  arg1 < 0 ifTrue: [ ^(self reciprocalModulo: arg2) raisedTo: arg1 negated modulo: arg2 ].  (arg1 < 4096 or: [ arg2 even ]) ifTrue: [ ^self slidingLeftRightRaisedTo: arg1 modulo: arg2 ].  tmp3 := self montgomeryDigitBase - ((arg2 bitAnd: self montgomeryDigitMax) reciprocalModulo: self montgomeryDigitBase).  tmp1 := (1 bitShift: arg2 montgomeryNumberOfDigits * arg2 montgomeryDigitLength) \\ arg2.  (tmp2 := self montgomeryTimes: tmp1 * tmp1 \\ arg2 modulo: arg2 mInvModB: tmp3) ifNil: [ ^self slidingLeftRightRaisedTo: arg1 modulo: arg2 ].  tmp1 := tmp2 montgomeryRaisedTo: arg1 times: tmp1 modulo: arg2 mInvModB: tmp3.  ^tmp1 montgomeryTimes: 1 modulo: arg2 mInvModB: tmp3-======-serializeOn: arg1  arg1     encodeUint32: self julianDayNumberUTC;     encodeUint32: self nanoSecond;     encodeInt24: self secondsSinceMidnightUTC;     encodeInt24: self offset asSeconds;     encodeInt32: self offset nanoSeconds-======-testDigitAt  | tmp1 |  tmp1 := 114605103402541699037609980192546360895434064385.  1 to: 20 do: [:arg1 |  | tmp2 |        tmp2 := tmp1 byteAt: arg1.        self assert: arg1 equals: tmp2 ]-======-classSideCompiler  ^self classSideCompilerClass new     environment: self classSide environment;     class: self classSide-======-testSqrtErrorConditions  self should: [ -1 sqrt ] raise: ArithmeticError-======-waitUntil: arg1 for: arg2 maxSeconds: arg3  ^self waitUntil: arg1 for: arg2 maxMilliseconds: (arg3 * 1000) asInteger-======-hasSlotNamed: arg1  ^self classLayout hasSlotNamed: arg1-======-deepCopy  -======-testNoRecursion  RecursionStopper during: [ value := value + 1 ].  self assert: value equals: 1-======-evaluate: arg1  ^self compiler evaluate: arg1-======-testBasicReadOnly  self alwaysReadOnlyObjects do: [:arg1 |  self assert: arg1 isReadOnlyObject equals: true ]-======-normalizeSecondsAndNanos  (NanosInSecond <= nanos or: [ nanos < 0 ]) ifTrue: [ seconds := seconds + (nanos // NanosInSecond).        nanos := nanos \\ NanosInSecond ].  (SecondsInDay <= seconds or: [ seconds < 0 ]) ifTrue: [ julianDayNumber := julianDayNumber + (seconds // SecondsInDay).        seconds := seconds \\ SecondsInDay ]-======-valueNoContextSwitch: arg1  < primitive: 209>  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  self primitiveFailed-======-degreeSin  self isFinite ifTrue: [ ^super degreeSin ].  ^self degreesToRadians sin-======-ban: arg1  ReSystemAnnouncer uniqueInstance notifyCritique: arg1 of: arg1 sourceAnchor entity bannedOn: self.  (TheManifestBuilder of: self) banRule: arg1 rule for: self-======-valueSupplyingAnswer: arg1  ^(arg1 isCollection and: [ arg1 isString not ]) ifTrue: [ self valueSupplyingAnswers: {arg1} ] ifFalse: [ self valueSupplyingAnswers: {{'*' .               arg1}} ]-======-symbolicBytecodes  ^SymbolicBytecodeBuilder decode: self-======-testDaysInYear  self assert: aDateAndTime daysInYear equals: 365-======-testIsAfter  | tmp1 tmp2 |  tmp1 := january23rd2004 translateTo: -8 hours.  tmp2 := january23rd2004 translateTo: 10 hours.  self     assert: (tmp2 isAfter: tmp1) not;     assert: (january23rd2004 isAfter: june2nd1973);     assert: (june2nd1973 isAfter: june2nd1973) not-======-doPop  self pop-======-stepIn: arg1  ^self step-======-index: arg1  index := arg1-======-directionToLineFrom: arg1 to: arg2  ^(arg2 x - arg1 x) * (self y - arg1 y) - ((self x - arg1 x) * (arg2 y - arg1 y))-======-testBlockVars  | tmp1 |  tmp := 0.  tmp := (self callcc: [:arg1 |  tmp1 := arg1.        0 ]) + tmp.  tmp2 ifNotNil: [ tmp2 value ] ifNil: [ #(1 2 3) do: [:arg2 |  self callcc: [:arg1 |  tmp2 := arg1.                    tmp1 value: arg2 ] ] ].  self assert: tmp equals: 6-======-ticker  ^ticker-======-testResumablePass  | tmp1 |  tmp1 := [ Notification signal.  4 ] on: Notification do: [:arg1 |  arg1 pass.        arg1 return: 5 ].  self assert: tmp1 equals: 4-======-leftCenter  ^self left @ self center y-======-sizePushConsArray: arg1  ^self sizeOpcodeSelector: #genPushConsArray: withArguments: {arg1}-======-hash  ^self receiver hash bitXor: selector hash-======-newSubclass  | tmp1 tmp2 |  tmp1 := 1.  [ tmp2 := (self name , tmp1 printString) asSymbol.  self environment includesKey: tmp2 ] whileTrue: [ tmp1 := tmp1 + 1 ].  ^self subclass: tmp2 instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: 'Unclassified'-======-withAll: arg1  array := arg1-======-resume  suspendedContext ifNil: [ ^self primitiveFailed ].  ^self primitiveResume-======-- arg1  self subclassResponsibility-======-spotterPreviewCodeIn: arg1  < spotterPreview: 10>  arg1 pharoMethod     title: [ self gtDisplayString ];     display: [:arg2 |  ' ' , arg2 sourceCode ];     smalltalkClass: [ self methodClass ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'-======-classForTicker  ^DelayMillisecondTickerSimulation-======-addCategory: arg1  | tmp1 |  (self protocolOrganizer hasProtocolNamed: arg1) ifTrue: [ ^self ].  tmp1 := self categories copy.  self protocolOrganizer addProtocolNamed: arg1.  self notifyOfAddedCategory: arg1.  self notifyOfChangedCategoriesFrom: tmp1 to: self categories-======-propertyAt: arg1 ifAbsent: arg2  self properties ifNil: [ ^arg2 value ].  ^self properties at: arg1 ifAbsent: arg2-======-localSendsToSuper  ^self encoderClass sendsToSuperFor: self-======-instVarNames  ^self slots collect: [:arg1 |  arg1 name ]-======-testStoreOn  | tmp1 |  tmp1 := SmallInteger maxVal + 1.  self     assert: tmp1 class equals: LargePositiveInteger;     assert: (String streamContents: [:arg1 |  tmp1 storeOn: arg1 ]) equals: tmp1 asString-======-testShiftMinusOne1LeftThenRight  1 to: 100 do: [:arg1 |  self assert: ((-1 bitShift: arg1) bitShift: arg1 negated) equals: -1 ]-======-+ arg1  < primitive: 1>  ^super + arg1-======-variableSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 package: arg6  ^self variableSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 category: arg6-======-subclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 package: arg6  ^self subclass: arg1 uses: arg2 layout: self classLayout class slots: arg3 asSlotCollection classVariablesNames: arg4 poolDictionaries: arg5 category: arg6-======-testStartStop  | tmp1 |  tmp1 := false.  [ scheduler stopTimerEventLoop ] on: Error do: [ tmp1 := true ].  self deny: tmp1-======-withSideOrCorner: arg1 setToPoint: arg2 minExtent: arg3 limit: arg4  arg1 = #top ifTrue: [ ^self withTop: (arg2 y min: corner y - arg3 y max: arg4 + arg3 y) ].  arg1 = #bottom ifTrue: [ ^self withBottom: (arg2 y min: arg4 - arg3 y max: origin y + arg3 y) ].  arg1 = #left ifTrue: [ ^self withLeft: (arg2 x min: corner x - arg3 x max: arg4 + arg3 x) ].  arg1 = #right ifTrue: [ ^self withRight: (arg2 x min: arg4 - arg3 x max: origin x + arg3 x) ].  arg1 = #topLeft ifTrue: [ ^(arg2 min: corner - arg3) corner: self bottomRight ].  arg1 = #bottomRight ifTrue: [ ^self topLeft corner: (arg2 max: origin + arg3) ].  arg1 = #bottomLeft ifTrue: [ ^self topRight rectangle: (arg2 x min: corner x - arg3 x) @ (arg2 y max: origin y + arg3 y) ].  arg1 = #topRight ifTrue: [ ^self bottomLeft rectangle: (arg2 x max: origin x + arg3 x) @ (arg2 y min: corner y - arg3 y) ]-======-hasInstVarRef: arg1  | tmp1 tmp2 tmp3 |  tmp1 := InstructionStream on: arg1.  tmp3 := InstVarRefLocator new.  tmp2 := tmp1 method endPC.  [ tmp1 pc <= tmp2 ] whileTrue: [ (tmp3 interpretNextInstructionUsing: tmp1) ifTrue: [ ^true ] ].  ^false-======-slotNamed: arg1 ifFound: arg2  ^self slotNamed: arg1 ifFound: arg2 ifNone: [  ]-======-combineFromIdx: arg1  (collectionOfArrays at: arg1) do: [:arg2 |  buffer at: arg1 put: arg2.        arg1 = collectionOfArrays size ifTrue: [ resultProcessingBlock value: buffer shallowCopy ] ifFalse: [ self combineFromIdx: arg1 + 1 ] ]-======-testIsClosePunctuation  self checkCorrespondanceOf: #isClosePunctuation: and: #Pe-======-testPrintOn  self assert: (String streamContents: [:arg1 |  aDateAndTime printOn: arg1 ]) equals: '1970-01-01T00:00:00+00:00'.  self assert: (String streamContents: [:arg1 |  aTimeZone printOn: arg1 ]) equals: 'a TimeZone(UTZ)'-======-handles: arg1  ^false-======-withAllSubclassesDo: arg1  self withAllSubclasses do: arg1-======-propertyAt: arg1  ^self propertyAt: arg1 ifAbsent: [ self error: 'Property not found' ]-======-argumentAt: arg1  ^self arguments at: arg1-======-testRetryingInstVarModification  | tmp1 |  tmp1 := MessageSend new.  tmp1 beReadOnlyObject.  [ tmp1 receiver: 1 ] on: ModificationForbidden do: [:arg1 |  tmp1 beWritableObject.        arg1 retryModification ].  self assert: tmp1 receiver equals: 1-======-alt  ^KMModifier alt + self-======-genJumpLong: arg1  (arg1 between: -32768 and: 32767) ifFalse: [ ^self outOfRangeError: 'index' index: arg1 range: -32768 to: 32767 ].  (arg1 < 0 or: [ arg1 > 255 ]) ifTrue: [ self genSignedSingleExtendB: (arg1 bitShift: -8) ].  stream     nextPut: 237;     nextPut: (arg1 bitAnd: 255)-======-isCollection  ^false-======-parseDay  self isTwoDigitDayPattern ifTrue: [ ^self parseTwoDigitDay ].  self parseVariableDigitDay-======-isExecutingBlock  ^self isBlockContext-======-stonOn: arg1  arg1 writeObject: self listSingleton: self asString-======-blockNodes  ^self ast blockNodes-======-allSelectorsAboveUntil: arg1  | tmp1 |  tmp1 := IdentitySet new.  (self allSuperclassesIncluding: arg1) do: [:arg2 |  arg2 selectorsDo: [:arg3 |  tmp1 add: arg3 ] ].  ^tmp1-======-senders  ^SystemNavigation default allSendersOf: self selector-======-add: arg1  ^self addLast: arg1-======-scaleFrom: arg1 to: arg2  ^arg2 topLeft + (((x - arg1 left) * arg2 width // arg1 width) @ ((y - arg1 top) * arg2 height // arg1 height))-======-genJumpLong: arg1  (arg1 >= -1024 and: [ arg1 < 1024 ]) ifTrue: [ stream           nextPut: 160 + (arg1 + 1024 bitShift: -8);           nextPut: (arg1 + 1024) \\ 256.        ^self ].  ^self outOfRangeError: 'distance' index: arg1 range: -1024 to: 1023-======-testMutateByteArrayUsingDoubleAtPut  < expectedFailure>  | tmp1 |  tmp1 := ByteArray new: 8.  tmp1 beReadOnlyObject.  self should: [ tmp1 doubleAt: 1 put: (2 raisedTo: 65) asFloat ] raise: ModificationForbidden.  [ tmp1 doubleAt: 1 put: (2 raisedTo: 65) asFloat ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first equals: (2 raisedTo: 65) asFloat-======-subclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 category: arg4  ^self subclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: '' package: arg4-======-returnField  | tmp1 |  tmp1 := self primitive.  tmp1 < 264 ifTrue: [ self error: 'only meaningful for quick-return' ] ifFalse: [ ^tmp1 - 264 ]-======-testPrint24OnWithoutSeconds  self assert: (String streamContents: [:arg1 |  aTime print24: true showSeconds: true on: arg1 ]) equals: '12:34:56'-======-traitComposition  ^TaEmptyComposition new-======-positive  ^self >= 0-======-deprecated: arg1  Deprecation new     context: thisContext sender;     explanation: arg1;     signal-======-valueSelector  self numArgs = 0 ifTrue: [ ^#value ].  ^(String streamContents: [:arg1 |  arg1 nextPutAll: 'value:'.        self numArgs - 1 timesRepeat: [ arg1 nextPutAll: 'value:' ] ]) asSymbol-======-newExternalDependencyExistFor: arg1  | tmp1 tmp2 |  tmp1 := self dependencyChecker dependenciesOf: arg1 packageName.  tmp2 := tmp1 difference: self bootstrapPackages.  ^tmp2 notEmpty-======-sizePushInstVarLong: arg1  ^self sizeOpcodeSelector: #genPushInstVarLong: withArguments: {arg1}-======-drTestsBrowse  Smalltalk tools browser openOnClass: self-======-testZeroDuration  | tmp1 |  tmp1 := Timespan starting: Date today duration: Duration zero.  self assert: tmp1 start equals: tmp1 end-======-= arg1  ^[ self ticks = arg1 ticks ] on: MessageNotUnderstood do: [ false ]-======-isZero  ^origin isZero and: [ corner isZero ]-======-hash  | tmp1 |  denominator isPowerOfTwo ifTrue: [ tmp1 := self asFloat.        tmp1 isFinite ifTrue: [ ^tmp1 hash ] ].  ^numerator hash bitXor: denominator hash-======-bottomRight  ^corner-======-signalException: arg1  | tmp1 |  self isActiveProcess ifTrue: [ ^arg1 signal ].  myList ifNotNil: [ tmp1 := self suspend ].  suspendedContext := Context sender: suspendedContext receiver: self method: (self class lookupSelector: #pvtSignal:list:) arguments: (Array with: arg1 with: tmp1).  tmp1 ifNotNil: [ self resume ]-======-translateTo: arg1  self dayMonthYearDo: [:arg2 :arg3 :arg4 |  ^self class year: arg4 month: arg3 day: arg2 hour: self hour minute: self minute second: self second nanoSecond: self nanoSecond offset: arg1 asDuration ]-======-genStoreInstVar: arg1  (arg1 >= 0 and: [ arg1 < 64 ]) ifTrue: [ stream           nextPut: 129;           nextPut: arg1.        ^self ].  self genStoreInstVarLong: arg1-======-link: arg1 toSlotNamed: arg2  self link: arg1 toSlotNamed: arg2 option: #all-======-gtInspectorPragmasIn: arg1  < gtInspectorPresentationOrder: 30>  arg1 tabulator     title: 'Pragmas';     when: [:arg2 |  arg2 pragmas notEmpty ];     with: [:arg3 |  arg3           row: #pragmas;           row: #methods.        arg3 transmit           to: #pragmas;           andShow: [:arg4 |  arg4 list                 title: 'Pragmas';                 display: [:arg5 |  arg5 pragmas ];                 when: [:arg2 |  arg2 pragmas notEmpty ] ].        arg3 transmit           from: #pragmas;           to: #methods;           andShow: [:arg4 |  arg4 list                 title: 'Methods';                 display: [:arg6 |  | tmp1 |                    tmp1 := OrderedCollection new.                    Object withAllSubclassesDo: [:arg7 |  tmp1 addAll: ((Pragma allNamed: arg6 selector in: arg7) collect: #method) ].                    tmp1 ];                 format: #selector ].        arg3 transmit           toOutsidePort: #selection;           from: #methods port: #selection ];     startOn: self-======-localMethods  ^self methods-======-contextClass  ^self method methodClass-======-asEnvironment  ^RBClassEnvironment class: self-======-joinTo: arg1  ^arg1 nextPut: self-======-testReadTimeZoneOffsetISO822WithOtherCharactersAfter  self assert: (DateAndTime readTimezoneOffsetFrom: '+05:30 CommiterName' readStream) printString equals: '0:05:30:00'-======-asFullRingDefinition  ^self instanceSide asFullRingDefinition classSide-======-genPushConsArray: arg1  (arg1 < 0 or: [ arg1 > 127 ]) ifTrue: [ ^self outOfRangeError: 'size' index: arg1 range: 0 to: 127 ].  stream     nextPut: 231;     nextPut: arg1 + 128-======-testIsZero  self assert: Duration zero isZero.  self assert: (Duration seconds: 0) isZero-======-hasClassVarNamed: arg1  ^self classVarNames includes: arg1-======-anyUserOfClassVarNamed: arg1  self withAllSubclasses do: [:arg2 |  (Array with: arg2 with: arg2 class) do: [:arg3 |  (arg3 whichSelectorsReferTo: (self classPool associationAt: arg1)) ifNotEmpty: [ ^arg3 ] ] ].  ^nil-======-fileOutPool: arg1 onFileStream: arg2  | tmp1 |  (arg1 isKindOf: SharedPool class) ifTrue: [ ^self notify: 'we do not fileout SharedPool type shared pools for now' ].  tmp1 := self environment keyAtIdentityValue: arg1.  SystemNotification signal: tmp1.  arg2     nextPutAll: 'Transcript show: ''' , tmp1 , '''; cr!';     cr.  arg2     nextPutAll: 'Smalltalk at: #' , tmp1 , ' put: Dictionary new!';     cr.  arg1 keys asSortedCollection do: [:arg3 |  | tmp2 |        tmp2 := arg1 at: arg3.        arg2 nextPutAll: tmp1 , ' at: #''' , arg3 asString , '''' , ' put:  '.        (tmp2 isKindOf: Number) ifTrue: [ tmp2 printOn: arg2 ] ifFalse: [ arg2 nextPutAll: '('.              tmp2 printOn: arg2.              arg2 nextPutAll: ')' ].        arg2           nextPutAll: '!';           cr ].  arg2 cr-======-testIsLineSeparator  self checkCorrespondanceOf: #isLineSeparator: and: #Zl-======-gtInspectorRawIn: arg1  < gtInspectorPresentationOrder: 10>  < gtInspectorTag: #basic>  ^arg1 custom: GTProtoObjectVariablesBrowser new-======-encode  encodedData := nil.  self perform: ('encode' , kind) asSymbol.  [ encodedData notNil and: [ encodedData size > 0 ] ] assert.  size := encodedData size-======-testCopy  < pragma: #pragma>  | tmp1 tmp2 |  tmp1 := thisContext method.  self assert: tmp1 pragmas notEmpty.  tmp2 := tmp1 copy.  self assert: (tmp1 equivalentTo: tmp2).  self assert: tmp1 header equals: tmp2 header.  self assert: tmp1 equals: tmp2.  self assert: tmp1 ~~ tmp2.  self assert: tmp2 penultimateLiteral method identicalTo: tmp2.  self assert: tmp1 penultimateLiteral method identicalTo: tmp1.  tmp1 pragmas do: [:arg1 |  self assert: arg1 method identicalTo: tmp1 ].  tmp2 pragmas do: [:arg1 |  self assert: arg1 method identicalTo: tmp2 ]-======-fuelAccept: arg1  ^self shouldBeSubstitutedByCleanCopy ifTrue: [ arg1 visitSubstitution: self by: self cleanCopy onRecursionDo: [ arg1 visitVariableObject: self ] ] ifFalse: [ arg1 visitVariableObject: self ]-======-waitWhile: arg1 maxSeconds: arg2  ^self waitWhile: arg1 maxMilliseconds: (arg2 * 1000) asInteger-======-simplePassTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: 'Unhandled Exception';     yourself-======-isErrorTest  ^self methodClass isTestCase and: [ self methodClass methodRaisedError: self selector ]-======-sourceCode  | tmp1 |  tmp1 := self trailer.  tmp1 sourceCode ifNotNil: [:arg1 |  ^arg1 ].  tmp1 hasSourcePointer ifFalse: [ ^self codeForNoSource ].  ^self getSourceFromFile ifEmpty: [ self codeForNoSource ]-======-nonAbstractMethod  ^4 + 5-======-isAbstract  ^false-======-method: arg1  method := arg1-======-objectAt: arg1  < primitive: 68>  self primitiveFailed-======-waitWhile: arg1  ^self waitWhile: arg1 for: nil-======-traversableInstVarIndexes  ^super traversableInstVarIndexes copyWithout: (self class allInstVarNames indexOf: 'sender')-======-randomCharacterBetween: arg1 and: arg2  ^Character codePoint: (self randomCodePointBetween: arg1 and: arg2)-======-printOn: arg1  args isEmpty ifTrue: [ ^arg1 nextPutAll: selector ].  args with: selector keywords do: [:arg2 :arg3 |  arg1 nextPutAll: arg3.        arg1 space.        arg2 printOn: arg1.        arg1 space ].  arg1 skip: -1-======-testWholeNanoseconds  self assert: 0 seconds wholeNanoseconds equals: 0.  self assert: 1 second wholeNanoseconds equals: 0.  self assert: 1002003004 nanoSeconds wholeNanoseconds equals: 4-======-testYear  self assert: aTimespan year equals: 2005-======-testFirstDayOfMonth  self assert: aDateAndTime firstDayOfMonth equals: 1-======-testReadSlotNamed  self assert: (5 @ 3 readSlotNamed: #x) equals: 5-======-isControlOther  ^self characterSet isControlOther: self-======-isMorphicEvent  ^false-======-deprecated: arg1 transformWith: arg2  Deprecation new     context: thisContext sender;     explanation: arg1;     rule: arg2;     transform-======-isFFIMethod  ^self hasProperty: #isFFIMethod-======-variableSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 package: arg5  ^self variableSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 category: arg5-======-runTest: arg1  | tmp1 tmp2 |  [ self     logTest: arg1;     clearLog;     perform: arg1 ] on: MyTestError do: [:arg2 |  self log: 'Unhandled Exception'.        arg2 return: nil ].  tmp1 := self log.  tmp2 := self perform: (arg1 , #Results) asSymbol.  tmp1 = tmp2 ifTrue: [ self logTestResult: 'succeeded' ] ifFalse: [ self logTestResult: 'failed' ]-======-adaptToInteger: arg1 andSend: arg2  ^(Fraction numerator: arg1 denominator: 1) perform: arg2 with: self-======-previous  ^self class starting: start - duration duration: duration-======-asMicroseconds  ^(seconds * NanosInSecond + nanos) // (10 raisedToInteger: 3)-======-object: arg1  object := arg1-======-printOn: arg1  arg1 nextPutAll: 'false'-======-removeMethodSelector: arg1  ^methodSelectors remove: arg1-======-testAsInteger  self assert: 0.5 asInteger equals: 0.  self assert: (1 / 2) asInteger equals: 0-======-testSlots  self assert: Context slots size equals: 4-======-pushRemoteTemp: arg1 inVectorAt: arg2  self push: ((self at: arg2 + 1) at: arg1 + 1)-======-group  ^'Bugs'-======-isCompiledMethod  ^false-======-do: arg1  | tmp1 |  1 to: self basicSize do: [:arg2 |  (tmp1 := self basicAt: arg2) ifNotNil: [ arg1 value: tmp1 ] ]-======-testAsYear  self assert: aTime asYear equals: (DateAndTime current midnight + aTime) asYear-======-userBackgroundPriority  ^UserBackgroundPriority-======-testNanoSecond  self     assert: (Duration nanoSeconds: 5) equals: 5 nanoSecond;     assert: 0.5 nanoSecond equals: (Duration nanoSeconds: 0.5);     assert: (1 / 2) nanoSecond equals: (Duration nanoSeconds: 0.5)-======-value: arg1  Processor activeProcess psValueAt: index put: arg1-======-instSpec  ^(self format bitShift: -16) bitAnd: 16r1F-======-exp  ^self asFloat exp-======-fixDependents  DependentsFields associationsDo: [:arg1 |  arg1 value do: [:arg2 |  (references at: arg2 ifAbsent: [ nil ]) ifNotNil: [:arg3 |  | tmp1 |                    tmp1 := references at: arg1 key ifAbsent: [ arg1 key ].                    tmp1 addDependent: arg3 ] ] ]-======-metacelloSemanticIntegerLessThanSelf: arg1  ^arg1 < self-======-testNameOfMonth  self assert: (Date nameOfMonth: 1) equals: #January.  self assert: (Date nameOfMonth: 12) equals: #December.  self should: [ Date nameOfMonth: 0 ] raise: SubscriptOutOfBounds.  self should: [ Date nameOfMonth: 13 ] raise: SubscriptOutOfBounds-======-testSimpleOneDelay  | tmp1 |  tmp1 := Delay new setDelay: 2 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: tmp1 beingWaitedOn.  scheduler schedule: tmp1.  self assert: tmp1 beingWaitedOn.  scheduler simulate_vmMilliseconds: 11.  self deny: tmp1 isExpired.  scheduler simulate_vmMilliseconds: 12.  self assert: tmp1 isExpired-======-simpleResignalAsTestResults  ^OrderedCollection new     add: self doSomethingString;     add: 'Unhandled Exception';     yourself-======-mustBeBooleanIn: arg1  | tmp1 |  arg1 skipBackBeforeJump.  tmp1 := NonBooleanReceiver new     object: self;     signal: 'proceed for truth.'.  ^tmp1 ~~ false-======-testSharedClosureEnvironment  | tmp1 |  tmp1 := self constructSharedClosureEnvironmentInDeadFrame.  self assert: (tmp1 at: 2) value equals: 10.  self assert: ((tmp1 at: 1) value: 5) equals: 5.  self assert: (tmp1 at: 2) value equals: 5-======-classComment: arg1  self comment: arg1-======-references  ^references-======-inheritsFrom: arg1  | tmp1 |  tmp1 := self superclass.  [ tmp1 == nil ] whileFalse: [ tmp1 == arg1 ifTrue: [ ^true ].        tmp1 := tmp1 superclass ].  ^false-======-stonContainSubObjects  ^false-======-hasAbstractMethods  self methodsDo: [:arg1 |  arg1 isAbstract ifTrue: [ ^true ] ].  ^false-======-classToBeTested  ^Float-======-testBecomeForwardHash  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 'ab' copy.  tmp2 := 'cd' copy.  tmp3 := tmp1.  tmp4 := tmp2 hash.  tmp1 becomeForward: tmp2.  self     assert: tmp1 hash equals: tmp4;     assert: tmp2 hash equals: tmp4;     assert: tmp3 hash equals: tmp4-======-veryDeepCopyWith: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  arg1 references at: self ifPresent: [:arg2 |  ^arg2 ].  tmp1 := self class.  tmp1 isMeta ifTrue: [ ^self ].  tmp4 := self shallowCopy.  arg1 references at: self put: tmp4.  (tmp1 isVariable and: [ tmp1 isPointers ]) ifTrue: [ self basicSize to: 1 by: -1 do: [:arg3 |  tmp3 := self basicAt: arg3.              tmp4 basicAt: arg3 put: (arg1 references at: tmp3 ifAbsent: [ tmp3 veryDeepCopyWith: arg1 ]) ] ].  tmp4 veryDeepInner: arg1.  tmp5 := tmp1.  tmp2 := tmp1 instSize.  [ tmp2 == 0 ] whileFalse: [ tmp6 := tmp5 includesSelector: #veryDeepInner:.        tmp7 := tmp5 instSize - tmp5 superclass instSize.        tmp6 ifTrue: [ tmp2 := tmp2 - tmp7 ] ifFalse: [ tmp7 timesRepeat: [ tmp3 := self instVarAt: tmp2.                    tmp4 instVarAt: tmp2 put: (arg1 references at: tmp3 ifAbsent: [ tmp3 veryDeepCopyWith: arg1 ]).                    tmp2 := tmp2 - 1 ] ].        tmp5 := tmp5 superclass ].  ^tmp4-======-ensureRingDefinitionIn: arg1  ^arg1 ask behaviors detect: [:arg2 |  arg2 name = self name ] ifNone: [ | tmp1 |        tmp1 := self asRingMinimalDefinitionIn: arg1.        arg1 addBehavior: tmp1.        tmp1 ]-======-removeActionsWithReceiver: arg1  self actionMap copy keysDo: [:arg2 |  self removeActionsSatisfying: [:arg3 |  arg3 receiver == arg1 ] forEvent: arg2 ]-======-implementors  ^SystemNavigation default allImplementorsOf: self selector-======-testIsConnectorPunctuation  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isConnectorPunctuation: tmp2) equals: (tmp1 isConnectorPunctuation: tmp2) ]-======-parseEscapePattern  inputStream next = patternStream next ifFalse: [ invalidPattern := true ]-======-fileOutOrganizationOn: arg1  arg1     cr;     nextPut: $!.  arg1     nextChunkPut: self name , ' reorganize';     cr.  arg1     nextChunkPut: self organization stringForFileOut;     cr-======-testYearMonthDay  self assert: aDateAndTime equals: (DateAndTime year: 1980 month: 1 day: 1)-======-genDup  stream nextPut: 83-======-addMethodTag: arg1  self organization addCategory: arg1-======-simpleEnsureTestWithNotification  [ self doSomething.  self methodWithNotification.  self doSomethingElse ] ensure: [ self doYetAnotherThing ]-======-link: arg1 toTemporaryNamed: arg2 inMethod: arg3  self link: arg1 toTemporaryNamed: arg2 inMethod: arg3 option: #all-======-isFourDigitYearPattern  ^patternStream nextMatchAll: 'yyy'-======-= arg1  ^self == arg1-======-metacelloSemanticStringLessThanSelf: arg1  ^true-======-weeks  | tmp1 |  tmp1 := OrderedCollection new.  self weeksDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1 asArray-======-isZero  ^self = 0-======-testRaisedToErrorConditions  self should: [ -2 raisedTo: 1 / 4 ] raise: ArithmeticError.  self should: [ -2 raisedTo: 1.24 ] raise: ArithmeticError-======-day  ^self dayOfYear-======-execute: arg1 against: arg2  arg2 executeBlock: self do: arg1-======-testDayOfYear  self assert: aDateAndTime dayOfYear equals: 60-======-genPushThisContext  stream nextPut: 82-======-testStoreOn  | tmp1 |  tmp1 := SmallInteger minVal - 1.  self     assert: tmp1 class equals: LargeNegativeInteger;     assert: (String streamContents: [:arg1 |  tmp1 storeOn: arg1 ]) equals: ' ' , tmp1 asString-======-< arg1  ^self asNanoSeconds < arg1 asNanoSeconds-======-& arg1  self subclassResponsibility-======-selector: arg1  selector := arg1-======-storeOn: arg1  arg1     nextPut: $(;     nextPutAll: self className;     nextPutAll: ' seconds: ';     print: seconds;     nextPutAll: ' nanoSeconds: ';     print: nanos;     nextPut: $)-======-isDisabled  ^self isDisabled: self markerOrNil-======-testCurrent  self deny: aDateAndTime equals: DateAndTime current-======-isConflict  ^self markerOrNil == self class conflictMarker-======-asFloat  self subclassResponsibility-======-isOverridden  | tmp1 |  tmp1 := self selector.  self methodClass allSubclassesDo: [:arg1 |  (arg1 includesSelector: tmp1) ifTrue: [ ^true ] ].  ^false-======-forkedProcesses  ^forkedProcesses-======-environment  ^thisClass environment-======-methodReturnTop  ^self return: self pop from: self methodReturnContext-======-pc: arg1  pc := arg1-======-tickAfterMilliseconds: arg1  ^self nowTick + (1000 * arg1)-======-valueUninterruptably  ^self ifCurtailed: [ ^self ]-======-testCanEscapeSpecialCharacters  self assertReading: '4d\2m\2345y' as: 'd\d\\m\m\\y\y' equals: (Date year: 2345 month: 2 day: 4)-======-isQuick  ^self primitive between: 256 and: 519-======-initializeValue: arg1  value := arg1.  ^self-======-randomCodePointBetween: arg1 and: arg2  | tmp1 tmp2 tmp3 |  tmp1 := arg2 min: 16rE01EF.  tmp2 := tmp1 - arg1 + 1.  [ tmp3 := (self generator next * tmp2) floor + arg1.  Unicode isNonCharacter: (Character codePoint: tmp3) ] whileTrue.  ^tmp3-======-isDivisibleBy: arg1  arg1 = 0 ifTrue: [ ^false ].  arg1 isInteger ifFalse: [ ^false ].  ^self \\ arg1 = 0-======-testBitOr  self assert: 2r0101 | 2r1010 equals: 2r1111.  self assert: (2r0101 bitOr: 2r1010) equals: 2r1111-======-javascriptOn: arg1  self printOn: arg1-======-a1: arg1 a2: arg2 a3: arg3 a4: arg4 a5: arg5 a6: arg6 a7: arg7 a8: arg8 a9: arg9 a10: arg10 a11: arg11 a12: arg12 a13: arg13 a14: arg14 a15: arg15  ^arg1 + arg2 - arg2-======-retry  handlerContext restart-======-bench  | tmp1 |  tmp1 := self benchFor: 5 seconds.  ^tmp1 shortPrintString-======-example1: arg1  < sampleInstance>  | tmp1 |  tmp1 := [:arg2 |  arg2 = 1 ifTrue: [ 1 ] ifFalse: [ (tmp1 value: arg2 - 1) * arg2 ] ].  ^tmp1 value: arg1-======-receiver: arg1  receiver := arg1-======-comment: arg1  commentRemoteString := arg1 isRemoteString ifTrue: [ arg1 ] ifFalse: [ arg1 isEmptyOrNil ifTrue: [ nil ] ifFalse: [ SourceFiles remoteStringForNewString: arg1 ] ]-======-valueWithinNonLocalReturn  [ ^self ] valueWithin: 20 milliSeconds onTimeout: [  ]-======-+ arg1  arg1 isInteger ifTrue: [ self negative == arg1 negative ifTrue: [ ^(self digitAdd: arg1) normalize ] ifFalse: [ ^self digitSubtract: arg1 ] ].  arg1 isFraction ifTrue: [ ^Fraction numerator: self * arg1 denominator + arg1 numerator denominator: arg1 denominator ].  ^arg1 adaptToInteger: self andSend: #+-======-suspend  | tmp1 |  self isActive ifTrue: [ tmp1 := self timespans last.        tmp1 duration: DateAndTime now - tmp1 start.        self state: #suspended ]-======-sizeWithoutTrailer  ^self trailer endPC-======-minute  ^self minutes-======-isArrow  ^{Character arrowUp .   Character arrowDown .   Character arrowLeft .   Character arrowRight} includes: self-======-spotterItemsFor: arg1  -======-step  ^self interpretNextInstructionFor: self-======-instanceSide  ^self soleInstance-======-testPrevious  | tmp1 |  tmp1 := june2nd1973 previous.  self assert: tmp1 equals: '1 June, 1973' asDate-======-indexOf: arg1 startingAt: arg2 ifAbsent: arg3  | tmp1 tmp2 |  tmp1 := self linkAt: arg2 ifAbsent: [ nil ].  tmp2 := arg2.  [ tmp1 isNil ] whileFalse: [ tmp1 value = arg1 value ifTrue: [ ^tmp2 ].        tmp1 := tmp1 nextLink.        tmp2 := tmp2 + 1 ].  ^arg3 value-======-testCeiling  self assert: 1.0 ceiling equals: 1.  self assert: 1.1 ceiling equals: 2.  self assert: -2.0 ceiling equals: -2.  self assert: -2.1 ceiling equals: -2-======-asFraction  ^self asTrueFraction-======-inspectAllInstances  | tmp1 tmp2 tmp3 |  tmp1 := self allInstances.  (tmp2 := tmp1 size) isZero ifTrue: [ ^self inform: 'There are no instances of ' , self name ].  tmp3 := tmp2 = 1 ifTrue: [ 'The lone instance' ] ifFalse: [ 'The ' , tmp2 printString , ' instances' ].  tmp1 asArray inspectWithLabel: tmp3 , ' of ' , self name-======-testReadFrom  self assert: '-1199-01-05T20:33:14.321-05:00' asDateAndTime printString equals: '-1199-01-05T20:33:14.321-05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: ' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: ' 2002-05-16T17:20' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:00+00:00'.  self assert: '2002-05-16T17:20:45' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:45+00:00'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime equals: '2002-05-16T17:20:45-02:34' asDateAndTime.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime equals: '2002-05-16T17:20:45+00:00' asDateAndTime.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime equals: '1997-04-26T01:02:03+01:02:3' asDateAndTime-======-rectanglesAt: arg1 height: arg2  arg1 + arg2 > self bottom ifTrue: [ ^Array new ].  ^Array with: (origin x @ arg1 corner: corner x @ (arg1 + arg2))-======-testDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 1-======-percent  ^self / 100-======-testSimpleStoreCallCC  | tmp1 tmp2 |  tmp2 := self callcc: #yourself.  tmp1 := false.  tmp2 = true ifTrue: [ tmp1 := true ] ifFalse: [ tmp2 value: true.        self error: 'This message shouldn''t be sent, ever.' ].  self assert: tmp1-======-testDaysInMonth  self assert: aDateAndTime daysInMonth equals: 31-======-testNaNCompare  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  self skip.  tmp1 := #(#< #<= #> #>= #=).  tmp2 := Float nan.  tmp3 := Float infinity - Float infinity.  tmp4 := {1 .   2.3 .   Float infinity .   (2 / 3) .   1.25s2 .   (2 raisedTo: 50)}.  tmp4 := tmp4 , (tmp4 collect: [:arg1 |  arg1 negated ]).  tmp4 := tmp4 , {tmp2 .         tmp3}.  tmp5 := Set new.  tmp4 do: [:arg2 |  tmp1 do: [:arg3 |  (tmp2 perform: arg3 with: arg2) ifTrue: [ tmp5 add: (tmp2 class lookupSelector: arg3) ].              (arg2 perform: arg3 with: tmp2) ifTrue: [ tmp5 add: (arg2 class lookupSelector: arg3) ] ].        tmp2 ~= arg2 ifFalse: [ tmp5 add: (tmp2 class lookupSelector: #~=) ].        arg2 ~= tmp2 ifFalse: [ tmp5 add: (arg2 class lookupSelector: #~=) ] ].  tmp6 := String streamContents: [:arg4 |  arg4           nextPutAll: 'According to IEEE 754 comparing with a NaN should always return false, except ~= that should return true.';           cr.        arg4 nextPutAll: 'All these methods failed to do so. They are either broken or call a broken one'.        tmp5 do: [:arg1 |  arg4                 cr;                 print: arg1 methodClass;                 nextPutAll: '>>';                 print: arg1 selector ] ].  tmp5 := Set new.  tmp4 do: [:arg5 |  tmp1 do: [:arg6 |  self deny: (tmp2 perform: arg6 with: arg5) description: tmp6.              self deny: (arg5 perform: arg6 with: tmp2) description: tmp6 ].        self assert: tmp2 ~= arg5 description: tmp6.        self assert: arg5 ~= tmp2 description: tmp6 ]-======-deepCopy  | tmp1 tmp2 tmp3 |  tmp2 := self class.  tmp2 == Object ifTrue: [ ^self ].  tmp2 isVariable ifTrue: [ tmp3 := self basicSize.        tmp1 := tmp2 basicNew: tmp3.        [ tmp3 > 0 ] whileTrue: [ tmp1 basicAt: tmp3 put: (self basicAt: tmp3) deepCopy.              tmp3 := tmp3 - 1 ] ] ifFalse: [ tmp1 := tmp2 basicNew ].  tmp3 := tmp2 instSize.  [ tmp3 > 0 ] whileTrue: [ tmp1 instVarAt: tmp3 put: (self instVarAt: tmp3) deepCopy.        tmp3 := tmp3 - 1 ].  ^tmp1-======-sqrt  self negative ifTrue: [ ^DomainError signal: 'sqrt undefined for number less than zero.' ].  ^super sqrt-======-strictlyPositive  ^self > 0-======-logExecution  self traceCr: 'Executing ' , thisContext sender printString-======-deprecationDate  ^deprecationDate ifNil: [ 'unknown' ]-======-compile: arg1 classified: arg2 withStamp: arg3 notifying: arg4  ^self compile: arg1 classified: arg2 withStamp: arg3 notifying: arg4 logSource: self acceptsLoggingOfCompilation-======-defaultAction  ^nil-======-stackPtr  ^stackp-======-testSecondsSinceMidnightLocalTimeNormalization  | tmp1 |  tmp1 := DateAndTime year: 1001 day: 101 hour: 0 minute: 1 second: 56 offset: 0 hours.  tmp1 := tmp1 offset: 1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 1 * 3600 + (1 * 60) + 56.  tmp1 := tmp1 offset: -1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 23 * 3600 + (1 * 60) + 56.  tmp1 := DateAndTime year: 1001 day: 101 hour: 23 minute: 1 second: 56 offset: 0 hours.  tmp1 := tmp1 offset: 1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 0 * 3600 + (1 * 60) + 56.  tmp1 := tmp1 offset: -1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  tmp1 := DateAndTime year: 1001 day: 101 hour: 0 minute: 1 second: 56 offset: 1 hours.  tmp1 := tmp1 offset: 2 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 1 * 3600 + (1 * 60) + 56.  tmp1 := tmp1 offset: 0 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 23 * 3600 + (1 * 60) + 56.  tmp1 := tmp1 offset: -1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  tmp1 := DateAndTime year: 1001 day: 101 hour: 23 minute: 1 second: 56 offset: 1 hours.  tmp1 := tmp1 offset: 2 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 0 * 3600 + (1 * 60) + 56.  tmp1 := tmp1 offset: 0 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  tmp1 := tmp1 offset: -1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 21 * 3600 + (1 * 60) + 56-======-timingPriorityScheduleTicker: arg1  beingWaitedOn ifTrue: [ ^false ].  beingWaitedOn := true.  ticker := arg1.  resumptionTick := ticker tickAfterMilliseconds: millisecondDelayDuration.  ^true-======-testYearPrintOn  | tmp1 |  tmp1 := Year starting: DateAndTime new duration: 365 days.  self assert: (String streamContents: [:arg1 |  tmp1 printOn: arg1 ]) equals: 'a Year (1901)'-======-allProtocol  ^allProtocol-======-primeFactorsOn: arg1  self = 1 ifTrue: [ ^self ].  self even ifTrue: [ arg1 nextPut: 2.        ^self / 2 primeFactorsOn: arg1 ].  3 to: self sqrtFloor by: 2 do: [:arg2 |  self \\ arg2 = 0 ifTrue: [ arg1 nextPut: arg2.              ^self / arg2 primeFactorsOn: arg1 ] ].  arg1 nextPut: self-======-basicOrganization: arg1  organization := arg1-======-notifyOfChangedSelector: arg1 from: arg2 to: arg3  (self hasSubject and: [ arg2 ~= arg3 ]) ifTrue: [ self subject notifyOfRecategorizedSelector: arg1 from: arg2 to: arg3 ]-======-testTranscriptPrintingWithOpenedTranscriptExists  self runSimulated: [ self methodWithTranscript ]-======-testBinaryLiteralString  self assert: 0.0 binaryLiteralString equals: '0.0'.  self assert: 0.0 negated binaryLiteralString equals: '-0.0'.  self assert: Float infinity binaryLiteralString equals: 'Float infinity'.  self assert: Float infinity negated binaryLiteralString equals: 'Float infinity negated'.  self assert: Float nan binaryLiteralString equals: 'Float nan'.  self assert: Float fminDenormalized binaryLiteralString equals: '2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: Float fminNormalized binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: (Float fminNormalized - Float fminDenormalized) binaryLiteralString equals: '2r0.1111111111111111111111111111111111111111111111111111e-1022'.  self assert: Float epsilon binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-52'.  self assert: Float fmax binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: Float fminDenormalized negated binaryLiteralString equals: '-2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: Float fminNormalized negated binaryLiteralString equals: '-2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: 1.0 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e0'.  self assert: (1.0 + Float epsilon) binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000001e0'.  self assert: (1.0 - (Float epsilon / 2)) binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e-1'.  self assert: 2.0 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e1'.  self assert: 0.1 binaryLiteralString equals: '2r1.1001100110011001100110011001100110011001100110011010e-4'.  self assert: 0.2 binaryLiteralString equals: '2r1.1001100110011001100110011001100110011001100110011010e-3'.  self assert: 0.3 binaryLiteralString equals: '2r1.0011001100110011001100110011001100110011001100110011e-2'.  self assert: (0.1 + 0.2) binaryLiteralString equals: '2r1.0011001100110011001100110011001100110011001100110100e-2'.  self assert: 0.5 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-1'.  self assert: 2r0.0000000000000000000000000000000000000000000000000001e-1022 binaryLiteralString equals: '2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: 2r0.0101010101010101010101010101010101010101010101010101e-1022 binaryLiteralString equals: '2r0.0101010101010101010101010101010101010101010101010101e-1022'.  self assert: 2r0.1010101010101010101010101010101010101010101010101010e-1022 binaryLiteralString equals: '2r0.1010101010101010101010101010101010101010101010101010e-1022'.  self assert: 2r0.1111111111111111111111111111111111111111111111111111e-1022 binaryLiteralString equals: '2r0.1111111111111111111111111111111111111111111111111111e-1022'.  self assert: 2r1.0101010101010101010101010101010101010101010101010101e-3 binaryLiteralString equals: '2r1.0101010101010101010101010101010101010101010101010101e-3'.  self assert: 2r1.1010101010101010101010101010101010101010101010101010e3 binaryLiteralString equals: '2r1.1010101010101010101010101010101010101010101010101010e3'.  self assert: 2r1.1111111111111111111111111111111111111111111111111111e1023 binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: -2r0.0000000000000000000000000000000000000000000000000001e-1022 binaryLiteralString equals: '-2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: -2r1.0000000000000000000000000000000000000000000000000000e-1022 binaryLiteralString equals: '-2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: -2r1.1111111111111111111111111111111111111111111111111111e1023 binaryLiteralString equals: '-2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: (Float fromIEEE64Bit: 2r0111111111110000000000000000000000000000000000000000000000000001) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r0111111111111111111111111111111111111111111111111111111111111111) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r1111111111110000000000000000000000000000000000000000000000000001) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r1111111111111111111111111111111111111111111111111111111111111111) binaryLiteralString equals: 'Float nan'-======-testNoRecursion  LocalRecursionStopper during: [ value := value + 1 ].  self assert: value equals: 1-======-signaler: arg1  signaler := arg1-======-testNumberOfDigits  2 to: 32 do: [:arg1 |  1 to: 1000 // arg1 do: [:arg2 |  | tmp1 |              tmp1 := arg1 raisedTo: arg2.              self assert: (tmp1 - 1 numberOfDigitsInBase: arg1) equals: arg2.              self assert: (tmp1 numberOfDigitsInBase: arg1) equals: arg2 + 1.              self assert: (tmp1 + 1 numberOfDigitsInBase: arg1) equals: arg2 + 1.              self assert: (tmp1 negated + 1 numberOfDigitsInBase: arg1) equals: arg2.              self assert: (tmp1 negated numberOfDigitsInBase: arg1) equals: arg2 + 1.              self assert: (tmp1 negated - 1 numberOfDigitsInBase: arg1) equals: arg2 + 1 ] ]-======-methodSelectors: arg1  methodSelectors := arg1-======-selector  ^selector-======-isBlock  ^false-======-genPushSpecialLiteral: arg1  | tmp1 |  tmp1 := #(true false nil -1 0 1 2) indexOf: arg1 ifAbsent: 0.  tmp1 = 0 ifTrue: [ ^self error: 'push special literal: ' , arg1 printString , ' is not one of true false nil -1 0 1 2' ].  stream nextPut: tmp1 + 112-======-testallSuperclassesIncluding  | tmp1 |  tmp1 := ArrayedCollection allSuperclassesIncluding: Collection.  self deny: (tmp1 includes: ArrayedCollection).  self deny: (tmp1 includes: Object).  self assert: (tmp1 includes: Collection).  self assert: (tmp1 includes: SequenceableCollection)-======-isUppercase  ^self characterSet isUppercase: self-======-genPushConsArray: arg1  (arg1 < 0 or: [ arg1 > 127 ]) ifTrue: [ ^self outOfRangeError: 'numElements' index: arg1 range: 0 to: 127 ].  stream     nextPut: 138;     nextPut: arg1 + 128-======-runTestCase: arg1  self subclassResponsibility-======-sizePushClosureCopyNumCopiedValues: arg1 numArgs: arg2 jumpSize: arg3  ^self sizeOpcodeSelector: #genPushClosureCopyNumCopiedValues:numArgs:jumpSize: withArguments: {arg1 .         arg2 .         arg3}-======-asSetElement  self deprecated: 'Use #asCollectionElement instead' transformWith: '`@receiver asSetElement' -> '`@receiver asCollectionElement'.  ^self asCollectionElement-======-testAsWeek  self assert: aDateAndTime asWeek equals: (Week starting: '12-31-1900' asDate)-======-bitAt: arg1  | tmp1 tmp2 |  tmp1 := (arg1 - 1) // 8 + 1.  tmp1 > self bytesCount ifTrue: [ ^0 ].  tmp2 := (arg1 - 1) \\ 8 + 1.  ^(self byteAt: tmp1) bitAt: tmp2-======-getNext: arg1  ^Continuation currentDo: [:arg2 |  leave := arg2.        fill value: arg1 ]-======-canPerform: arg1  ^self classAndMethodFor: arg1 do: [:arg2 :arg3 |  arg3 isProvided ] ifAbsent: [ false ]-======-copy: arg1 from: arg2  self copy: arg1 from: arg2 classified: nil-======-testMmddyyyy  self assert: january23rd2004 mmddyyyy equals: '1/23/2004'-======-aRandomSelectionOfCodePointsDo: arg1  0 to: 255 do: [:arg2 |  arg1 value: arg2 ].  500 timesRepeat: [ arg1 value: (unicodeGenerator randomCodePointAtOrAbove: 256) ]-======-testUsesPoolVarNamed  self assert: (Date usesPoolVarNamed: 'DayNames').  self deny: (Date class usesPoolVarNamed: 'DayNames').  self assert: (RootClassPoolUser usesPoolVarNamed: 'Author').  self assert: (SubclassPoolUser usesPoolVarNamed: 'Author')-======-testDivide  self assert: aDuration / aDuration equals: 1.  self assert: aDuration / 2 equals: (Duration days: 0 hours: 13 minutes: 1 seconds: 32 nanoSeconds: 2).  self assert: aDuration / (1 / 2) equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10)-======-testYield  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := tmp3 := tmp4 := false.  tmp2 := Processor activeProcess priority - 10 min: 10.  [ tmp1 := true ] forkAt: tmp2.  [ tmp3 := true ] fork.  [ tmp4 := true ] fork.  Processor yield.  self assert: tmp3.  self assert: tmp4.  self deny: tmp1-======-sizeSend: arg1 numArgs: arg2  ^self sizeOpcodeSelector: #genSend:numArgs: withArguments: {arg1 .         arg2}-======-testSuspendForSnapshot  | tmp1 |  tmp1 := Delay new setDelay: 2 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: tmp1 beingWaitedOn.  scheduler schedule: tmp1.  self assert: tmp1 beingWaitedOn.  self assert: tmp1 millisecondsToGo equals: 2.  scheduler shutDown.  self assert: tmp1 millisecondsToGo equals: 0.  scheduler simulate_vmMilliseconds: 20.  self assert: tmp1 millisecondsToGo equals: 0.  self deny: tmp1 isExpired.  scheduler startUp.  self assert: tmp1 millisecondsToGo equals: 2.  self deny: tmp1 isExpired.  scheduler simulate_vmMilliseconds: 23.  self assert: tmp1 isExpired-======-asTime  ^Time seconds: self secondsSinceMidnightLocalTime nanoSeconds: nanos-======-javascriptMonthIndex  ^self monthIndex - 1-======-allSubclassesDo: arg1  self subclassesDo: [:arg2 |  arg1 value: arg2.        arg2 allSubclassesDo: arg1 ]-======-testRefersToLiteralsReturnsTrueWhenLiteralIsGlobalVariable  self assert: (self compiledMethod1 hasLiteralThorough: (self class environment associationAt: #Array))-======-ifNil: arg1  ^arg1 value-======-testYearMonthDayHourMinuteSecondNanosSecondOffset  self assert: aDateAndTime equals: (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours).  self assert: (DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours) + (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) equals: (DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)-======-suspendingList  ^myList-======-obsolete  self superclass removeSubclass: self.  super obsolete-======-group  ^'Architectural'-======-printPaddedWith: arg1 to: arg2  ^self printPaddedWith: arg1 to: arg2 base: 10-======-testInexactRaisedTo  self assert: (((1 << 1024) + 1) / ((1 << 1024) + 3) raisedTo: 1 / 3) equals: 1.0.  self assert: ((((1 << 1024) + 1) / ((1 << 1024) + 3)) negated raisedTo: 1 / 3) equals: -1.0-======-collect: arg1 thenSelect: arg2  | tmp1 tmp2 |  tmp1 := self class new.  self do: [:arg3 |  tmp2 := arg1 value: arg3.        (arg2 value: tmp2) ifTrue: [ tmp1 add: tmp2 ] ].  ^tmp1-======-primitive  ^self subclassResponsibility-======-sizeBranchPopFalse: arg1  ^self sizeOpcodeSelector: #genBranchPopFalse: withArguments: {arg1}-======-stonOn: arg1  arg1 writeScaledDecimal: self-======-lowercase  ^self asLowercase-======-at: arg1  ^(self linkAt: arg1) value-======-testMinute  self assert: aTime minute equals: 34.  self assert: aTime minutes equals: 34-======-testMonth  self assert: aDateAndTime month equals: 1.  self assert: aDateAndTime monthAbbreviation equals: 'Jan'.  self assert: aDateAndTime monthName equals: 'January'.  self assert: aDateAndTime monthIndex equals: 1-======-testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 0.  self assert: aDateAndTime hour equals: aDateAndTime hours-======-testRounded  self assert: (4 / 5) rounded equals: 1.  self assert: (6 / 5) rounded equals: 1.  self assert: (-4 / 5) rounded equals: -1.  self assert: (-6 / 5) rounded equals: -1.  self assert: (3 / 2) rounded equals: 2.  self assert: (-3 / 2) rounded equals: -2-======-tearDown  DateAndTime localTimeZone: restoredTimeZone.  super tearDown-======-testReadTimeZoneOffsetISO  self assert: (DateAndTime readTimezoneOffsetFrom: '+05:30' readStream) printString equals: '0:05:30:00'-======-uncategorizedSelectors  ^self selectorsInProtocol: Protocol unclassified-======-asPowerOfTwo  ^self asSmallerPowerOfTwo-======-testUtcOffset  self assert: (aDateAndTime offset: '0:02:00:00') equals: '2004-02-29T13:33:00+02:00' asDateAndTime-======-tearDown  month := nil.  super tearDown-======-removeEmptyCategories  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := (Array new: 16) writeStream.  tmp4 := (Array new: 16) writeStream.  tmp2 := tmp1 := 0.  [ (tmp1 := tmp1 + 1) <= categoryArray size ] whileTrue: [ (categoryStops at: tmp1) > tmp2 ifTrue: [ tmp3 nextPut: (categoryArray at: tmp1).              tmp4 nextPut: (tmp2 := categoryStops at: tmp1) ] ].  categoryArray := tmp3 contents.  categoryStops := tmp4 contents.  categoryArray isEmpty ifTrue: [ categoryArray := Array with: Default.        categoryStops := Array with: 0 ]-======-testComments  self assert: (CompiledMethodTest >> #testComments) comments first equals: 'I am the first comment to be found in this test'.  self assert: (CompiledMethodTest >> #testComments) comments second equals: 'And I am the second comment to be found in this test'.  self assert: (CompiledMethod >> #compiledMethod) comments isEmpty-======-testGpsExample2  | tmp1 tmp2 |  tmp2 := #(#(1 2 3 4 5) #(6 7 8 9 10) #(11 12 13 14 15) #(16 17 18 19 20) #(21 22 23 24 25)).  tmp1 := tmp2 inject: 0 into: [:arg1 :arg2 |  arg1 + (arg2 inject: 0 into: [:arg3 :arg4 |  arg3 + arg4 ]) ].  self assert: (self gpsExample2: tmp2) equals: tmp1-======-alwaysWritableObjects  ^{ContextInstance .   Processor .   Processor activeProcess}-======-monthIndex  ^super month-======-runCase  SystemAnnouncer uniqueInstance suspendAllWhile: [ super runCase ]-======-testJulianDayNumber  self assert: aTimespan julianDayNumber equals: jan01 julianDayNumber-======-asSpLayoutFrame  ^SpLayoutFrame new     leftFraction: self left;     rightFraction: self right;     topFraction: self top;     bottomFraction: self bottom;     yourself-======-testSuppressInform  self should: [ [ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingAllMessages isNil ]-======-asMinutes  ^self asNanoSeconds / 60000000000.0-======-value  | tmp1 |  tmp1 := self receiver.  ^arguments ifNil: [ (self ensureReceiver: tmp1) ifTrue: [ tmp1 perform: selector ] ifFalse: [  ] ] ifNotNil: [ (self ensureReceiverAndArguments: tmp1) ifTrue: [ tmp1 perform: selector withArguments: (Array withAll: arguments) ] ifFalse: [  ] ]-======-scheduleAtTimingPriority  (delayToStart timingPriorityScheduleTicker: ticker) ifFalse: [ ^self ].  activeDelay ifNil: [ activeDelay := delayToStart ] ifNotNil: [ delayToStart resumptionTick < activeDelay resumptionTick ifTrue: [ suspendedDelays add: activeDelay.              activeDelay := delayToStart ] ifFalse: [ suspendedDelays add: delayToStart ] ].  delayToStart := nil-======-testNext  self assert: aTimespan next equals: aDisjointTimespan-======-setDelay: arg1 forSemaphore: arg2 monitor: arg3 queue: arg4  monitor := arg3.  queue := arg4.  self setDelay: arg1 forSemaphore: arg2-======-tag: arg1  tag := arg1-======-normalized  | tmp1 |  tmp1 := (x * x + (y * y)) sqrt.  ^(x / tmp1) @ (y / tmp1)-======-testRounding  self assert: (5 round: 2) equals: 5-======-readsSlot: arg1  ^arg1 isReadIn: self-======-\\ arg1  arg1 isPoint ifTrue: [ ^(x \\ arg1 x) @ (y \\ arg1 y) ].  ^arg1 adaptToPoint: self andSend: #\\-======-testSubstracting  | tmp1 |  tmp1 := '2004-01-07T11:55:00+00:00' asDateAndTime.  self assert: tmp1 - 5 equals: '2004-01-07T11:54:55+00:00' asDateAndTime-======-privRestartBlockTest  | tmp1 tmp2 |  tmp2 := true.  tmp1 := 10.  self assert: 30 equals: [ | tmp3 |        self assert: 10 equals: tmp1.        self assert: nil identicalTo: tmp3.        tmp3 := tmp1 + 20.        tmp2 ifTrue: [ tmp2 := false.              thisContext restart ].        tmp3 ] value-======-fileOutCategory: arg1 on: arg2  | tmp1 |  arg2 cr.  tmp1 := self selectorsToFileOutCategory: arg1.  tmp1 do: [:arg3 |  self printMethodChunk: arg3 on: arg2 ].  ^self-======-testCopySignTo  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp5 := {2 .   2.5 .   Float infinity}.  tmp4 := {-3 .   -3.25 .   Float infinity negated}.  tmp6 := 0.0.  tmp2 := Float negativeZero.  tmp3 := tmp5 copyWith: tmp6.  tmp1 := tmp4 copyWith: tmp2.  tmp3 do: [:arg1 |  tmp3 do: [:arg2 |  self assert: (arg1 copySignTo: arg2) equals: arg2 ].        tmp1 do: [:arg3 |  self assert: (arg1 copySignTo: arg3) equals: arg3 negated ].        self assert: (arg1 copySignTo: tmp6) sign equals: 0.        self assert: (arg1 copySignTo: tmp2) sign equals: 0 ].  tmp1 do: [:arg4 |  tmp3 do: [:arg2 |  self assert: (arg4 copySignTo: arg2) equals: arg2 negated ].        tmp1 do: [:arg3 |  self assert: (arg4 copySignTo: arg3) equals: arg3 ].        self assert: (arg4 copySignTo: tmp6) sign equals: 0.        self assert: (arg4 copySignTo: tmp2) sign equals: 0 ]-======-testExactSqrt  | tmp1 |  self assert: (4 / 9) sqrt classAndValueEquals: 2 / 3.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:arg1 :arg2 |  tmp1 := arg1 / arg2.        self assert: tmp1 squared sqrt classAndValueEquals: tmp1.        tmp1 := arg2 / arg1.        self assert: tmp1 squared sqrt classAndValueEquals: tmp1 ]-======-compiledMethodAt: arg1 ifPresent: arg2  ^self methodDict at: arg1 ifPresent: arg2-======-testIsPowerOfTwo  self deny: (2 raisedTo: 80) negated isPowerOfTwo.  self deny: -1 isPowerOfTwo.  self deny: 0 isPowerOfTwo.  self assert: 1 isPowerOfTwo.  self assert: 2 isPowerOfTwo.  self deny: 3 isPowerOfTwo.  self assert: 4 isPowerOfTwo.  self deny: 5 isPowerOfTwo.  self deny: ((2 raisedTo: 80) - 1) isPowerOfTwo.  self assert: (2 raisedTo: 80) isPowerOfTwo.  self deny: ((2 raisedTo: 80) + 1) isPowerOfTwo-======-useTimeZone: arg1 during: arg2  | tmp1 |  tmp1 := TimeZone abbreviated: arg1.  self restoreLocalTimeZoneAfter: [ DateAndTime localTimeZone: tmp1.        arg2 cull: tmp1 ]-======-variableNodes  ^self methods flatCollect: [:arg1 |  arg1 variableNodes ]-======-testFloatTruncated  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := 10 raisedTo: 16.  tmp1 := tmp3 asFloat.  tmp2 := (5 raisedTo: 16) asFloat timesTwoPower: 16.  self assert: tmp1 equals: tmp2.  self assert: tmp1 asInteger equals: tmp3.  self assert: tmp1 asInteger equals: tmp1 asTrueFraction asInteger.  tmp4 := Random new.  10000 timesRepeat: [ tmp1 := tmp4 next * 1.9999e16 + 1.0e12.        self assert: tmp1 truncated equals: tmp1 asTrueFraction truncated ]-======-testReceiverWithGC  | tmp1 |  tmp1 := WeakMessageSend receiver: Object new selector: #isNil.  Smalltalk garbageCollectMost.  self assert: tmp1 value isNil-======-bytecodesHash  ^CRC crc16FromCollection: (ByteArray new: self size streamContents: [:arg1 |  self from: self initialPC to: self endPC do: [:arg2 |  arg1 nextPut: arg2 ] ])-======-/ arg1  arg1 isFraction ifTrue: [ ^self * arg1 reciprocal ].  ^arg1 adaptToFraction: self andSend: #/-======-isExpired  ^expired-======-fixCollisionsFrom: arg1  | tmp1 tmp2 |  tmp2 := arg1.  [ (tmp1 := self basicAt: (tmp2 := tmp2 \\ array size + 1)) == nil ] whileFalse: [ | tmp3 |        (tmp3 := self findElementOrNil: tmp1) = tmp2 ifFalse: [ self swap: tmp2 with: tmp3 ] ]-======-classify: arg1 inProtocolNamed: arg2  | tmp1 tmp2 |  tmp1 := arg2.  tmp1 = allProtocol name ifTrue: [ tmp1 := Protocol unclassified ].  (self protocolsOfSelector: arg1) do: [:arg3 |  arg3 removeMethodSelector: arg1 ].  tmp2 := self getProtocolNamed: tmp1 ifNone: [ self addProtocolNamed: tmp1 ].  tmp2 addMethodSelector: arg1-======-storeOn: arg1 base: arg2  arg1 nextPut: $(.  numerator storeOn: arg1 base: arg2.  arg1 nextPut: $/.  denominator storeOn: arg1 base: arg2.  arg1 nextPut: $)-======-linesOfCode  | tmp1 |  tmp1 := 0.  self sourceCode lineIndicesDo: [:arg1 :arg2 :arg3 |  arg2 > arg1 ifTrue: [ tmp1 := tmp1 + 1 ] ].  ^tmp1-======-valueWithoutNotifications  ^SystemAnnouncer uniqueInstance suspendAllWhile: self-======-restoreValues  | tmp1 tmp2 |  tmp1 := values readStream.  [ tmp1 atEnd ] whileFalse: [ tmp2 := tmp1 next.        1 to: tmp2 class instSize do: [:arg1 |  tmp2 instVarAt: arg1 put: tmp1 next ].        1 to: tmp2 size do: [:arg1 |  tmp2 at: arg1 put: tmp1 next ] ]-======-testprintHierarchy  | tmp1 tmp2 |  tmp1 := 'ProtoObject #()	Object #()		ExampleForTest1 #()			ExampleForTest11 #()				ExampleForTest111 #()				ExampleForTest112 #()			ExampleForTest12 #()'.  tmp2 := ExampleForTest1 printHierarchy.  self assert: tmp2 equals: tmp1-======-testInexactSqrt  self assert: (((1 << 1024) + 1) / ((1 << 1024) + 3)) sqrt equals: 1.0-======-intersectAllWithCC: arg1  ^arg1 ifNotEmpty: [ Continuation currentDo: [:arg2 |  self intersect: arg1 first withAll: arg1 allButFirst continuation: arg2 ] ]-======-isFormatOther  ^self characterSet isFormatOther: self-======-waitTimeoutMSecs: arg1  | tmp1 |  tmp1 := DelayWaitTimeout new setDelay: (arg1 max: 0) forSemaphore: self.  ^tmp1 wait-======-assertReading: arg1 as: arg2 raise: arg3  self should: [ self reading: arg2 pattern: arg1 ] raise: arg3-======-tags  | tmp1 |  tmp1 := self protocol.  tmp1 ifNil: [ ^#() ].  tmp1 = Protocol unclassified ifTrue: [ ^#() ].  ^{tmp1}-======-binding  | tmp1 |  tmp1 := self environment associationAt: self name ifAbsent: [ LiteralVariable key: nil value: self ].  ^tmp1 value == self ifTrue: [ tmp1 ] ifFalse: [ LiteralVariable key: nil value: self ]-======-arguments  ^arguments ifNil: [ Array new ]-======-subclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5  ^self classInstaller make: [:arg6 |  arg6           superclass: self;           name: arg1;           layoutClass: self classLayout class;           slots: arg2 asSlotCollection;           sharedVariablesFromString: arg3;           sharedPools: arg4;           category: arg5;           environment: self environment ]-======-definitionWithSlots  | tmp1 tmp2 |  tmp2 := self sharedPoolsString.  tmp1 := (String new: 800) writeStream.  superclass ifNotNil: [ tmp1 nextPutAll: superclass name ] ifNil: [ tmp1 nextPutAll: 'ProtoObject' ].  tmp1     nextPutAll: ' subclass: ';     store: self name.  self hasTraitComposition ifTrue: [ tmp1           crtab;           nextPutAll: 'uses: ';           nextPutAll: self traitCompositionString ].  (self classLayout isKindOf: FixedLayout) ifFalse: [ tmp1           crtab;           nextPutAll: 'layout: ';           nextPutAll: self classLayout class name ].  tmp1     crtab;     nextPutAll: 'slots: ';     nextPutAll: self slotDefinitionString.  tmp1     crtab;     nextPutAll: 'classVariables: ';     nextPutAll: self classVariableDefinitionString.  tmp2 = '' ifFalse: [ tmp1           crtab;           nextPutAll: 'poolDictionaries: ';           store: tmp2 ].  tmp1     crtab;     nextPutAll: 'package: ';     store: self category asString.  superclass ifNil: [ tmp1           nextPutAll: '.';           cr.        tmp1 nextPutAll: self name.        tmp1           space;           nextPutAll: 'superclass: nil' ].  ^tmp1 contents-======-var10  ^var10-======-adaptToCollection: arg1 andSend: arg2  ^arg1 collect: [:arg3 |  arg3 perform: arg2 with: self ]-======-stonContainSubObjects  ^false-======-coerce: arg1  arg1 class = self class ifTrue: [ ^self class newFromNumber: arg1 scale: (scale max: arg1 scale) ].  (arg1 isFraction or: [ arg1 isInteger ]) ifTrue: [ ^self class newFromNumber: arg1 scale: scale ].  ^arg1-======-testEven  self deny: 1073741825 even.  self assert: 1073741824 even-======-testAsMonth  self assert: aDateAndTime asMonth equals: (Month year: 1970 month: 'January')-======-testInfinity2  | tmp1 tmp2 |  tmp1 := 10000 exp.  tmp2 := 1000000000 exp.  tmp2 := 0 - tmp2.  self assert: tmp1 isInfinite & tmp2 isInfinite & tmp1 positive & tmp2 negative.  self deny: tmp1 equals: tmp2-======-ensureReceiverAndArguments  self receiver ifNil: [ ^false ].  self receiver class isObsolete ifTrue: [ ^false ].  (self receiver isBehavior and: [ self receiver isObsolete ]) ifTrue: [ ^false ].  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg1 :arg2 |  arg1 ifNil: [ arg2 ifFalse: [ ^false ] ] ] ].  ^true-======-selector: arg1  selector := arg1-======-testIsLeapYear  self deny: aTimespan isLeapYear-======-jsonOn: arg1  self numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: arg1 ]-======-testCompileAll  ClassTest compileAll-======-testDurationLessThanMaxTicks  | tmp1 |  tmp1 := Delay new setDelay: 789 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: tmp1.  self assert: ticker vmSimNextWakeupMilliseconds equals: 100 + 789-======-savedTemps  ^self propertyAt: #savedTemps ifAbsent: nil-======-subclass: arg1 layout: arg2 slots: arg3 classVariables: arg4 category: arg5  self deprecated: 'use ... package: instead'.  ^self subclass: arg1 layout: arg2 slots: arg3 classVariables: arg4 package: arg5-======-log  ^log ifNil: [ log := OrderedCollection new ]-======-withBottom: arg1  ^origin x @ origin y corner: corner x @ (arg1 max: origin y)-======-weeksDo: arg1  self do: arg1 with: self asWeek-======-testprintSubclassesOnLevelFilterNil  | tmp1 tmp2 tmp3 |  tmp1 := '	ExampleForTest1 #()		ExampleForTest11 #()			ExampleForTest111 #()			ExampleForTest112 #()		ExampleForTest12 #()'.  tmp2 := String new: tmp1 size.  tmp3 := ReadWriteStream on: tmp2.  ExampleForTest1 printSubclassesOn: tmp3 level: 1 filter: nil.  self assert: tmp2 equals: tmp1-======-repeat  [ self value.  true ] whileTrue-======-testAsMilliSeconds  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: (Duration seconds: 1) asMilliSeconds equals: 1000.  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: aDuration asMilliSeconds equals: 93784000.  self assert: (Duration milliSeconds: 3775) asSeconds equals: 3.  self assert: (Duration milliSeconds: 3775) nanoSeconds equals: 775000000.  self assert: (Duration milliSeconds: -3775) asSeconds equals: -3.  self assert: (Duration milliSeconds: -3775) nanoSeconds equals: -775000000-======-terminateActive  activeProcess effectiveProcess terminate-======-withLeft: arg1  ^(arg1 min: corner x) @ origin y corner: corner x @ corner y-======-simpleIsNestedTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:arg1 |  arg1 isNested ifTrue: [ self doYetAnotherThing.              arg1 resignalAs: MyTestNotification new ] ]-======-whichCategoryIncludesSelector: arg1  (self includesSelector: arg1) ifTrue: [ ^self organization categoryOfElement: arg1 ] ifFalse: [ ^nil ]-======-testCreationFromBytes1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  Smalltalk vm wordSize = 4 ifFalse: [ ^self skip ].  tmp1 := SmallInteger maxVal.  tmp2 := tmp1 printStringHex.  self assert: tmp2 size equals: 8.  tmp6 := Number readFrom: (tmp2 copyFrom: 1 to: 2) base: 16.  tmp5 := Number readFrom: (tmp2 copyFrom: 3 to: 4) base: 16.  tmp4 := Number readFrom: (tmp2 copyFrom: 5 to: 6) base: 16.  tmp3 := Number readFrom: (tmp2 copyFrom: 7 to: 8) base: 16.  tmp7 := Integer byte1: tmp3 byte2: tmp4 byte3: tmp5 byte4: tmp6.  self assert: tmp7 equals: tmp1.  self assert: tmp7 class equals: SmallInteger-======-leadingChar  ^(self asInteger bitAnd: 1069547520) bitShift: -22-======-bytecode  | tmp1 tmp2 tmp3 |  tmp1 := self initialPC.  tmp2 := self endPC.  tmp3 := ByteArray new: tmp2 - tmp1 + 1.  tmp1 to: tmp2 do: [:arg1 |  tmp3 byteAt: arg1 - tmp1 + 1 put: (self byteAt: arg1) ].  ^tmp3-======-exception  ^self-======-applyDeprecation  self deprecationRefactorings do: #execute-======-asRingDefinitionWithMethods: arg1 withSuperclasses: arg2 withSubclasses: arg3 withPackageKeys: arg4 in: arg5  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self asRingDefinition.  arg5 loadClass: tmp1 using: arg4.  arg1 ifTrue: [ self methodsDo: [:arg6 |  tmp2 := arg6 asActiveRingDefinition.              arg5 loadMethod: tmp2 inClass: tmp1 using: arg4 ].        self classSide methodsDo: [:arg6 |  tmp2 := arg6 asActiveRingDefinition.              arg5 loadMethod: tmp2 inClass: tmp1 classSide using: arg4 ] ].  arg2 ifTrue: [ self superclass ifNotNil: [ tmp3 := arg5 classNamed: self superclass name.              tmp3 ifNil: [ tmp3 := self superclass asRingDefinitionWithMethods: arg1 withSuperclasses: arg2 withSubclasses: arg3 withPackageKeys: arg4 in: arg5 ].              tmp1 superclass: tmp3 ] ].  arg3 ifTrue: [ tmp5 := self subclasses reject: [:arg7 |  arg7 isMeta ].        tmp1 name = #Trait ifTrue: [ tmp5 := arg5 environment allTraits ].        tmp5 do: [:arg8 |  tmp4 := arg5 classNamed: arg8 name.              tmp4 ifNil: [ tmp4 := arg8 asRingDefinitionWithMethods: arg1 withSuperclasses: arg2 withSubclasses: arg3 withPackageKeys: arg4 in: arg5 ].              tmp4 superclass: tmp1 ] ].  ^tmp1-======-sizeCallPrimitive: arg1  ^self sizeOpcodeSelector: #genCallPrimitive: withArguments: {arg1}-======-testAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)-======-testUtcOffset  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1980-01-01T12:00:00+12:00' asDateAndTime-======-protocolNamed: arg1  ^self protocolNamed: arg1 ifAbsent: [ Protocol empty ]-======-floor  | tmp1 |  tmp1 := self truncated.  self >= 0 ifTrue: [ ^tmp1 ].  self = tmp1 ifTrue: [ ^tmp1 ] ifFalse: [ ^tmp1 - 1 ]-======-contents  ^(self log inject: (String new: 80) writeStream into: [:arg1 :arg2 |  arg1           cr;           nextPutAll: arg2;           yourself ]) contents-======-or: arg1  ^arg1 value-======-testAsDays  self assert: (Duration days: 2) asDays equals: 2.  self assert: (Duration weeks: 1) asDays equals: 7.  self assert: (aDuration asDays closeTo: 1.08546)-======-testTicks  self assert: aDateAndTime ticks equals: (DateAndTime julianDayNumber: 2440588) ticks.  self assert: aDateAndTime ticks equals: #(2440588 0 0)-======-digitLshift: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  (tmp9 := self highBitOfMagnitude) = 0 ifTrue: [ ^0 ].  tmp4 := (tmp9 + arg1 + 7) // 8.  tmp5 := Integer new: tmp4 neg: self negative.  tmp7 := arg1 // 8.  tmp8 := arg1 \\ 8.  tmp8 = 0 ifTrue: [ ^tmp5 replaceFrom: tmp7 + 1 to: tmp4 with: self startingAt: 1 ].  tmp1 := 0.  tmp2 := tmp8 - 8.  tmp3 := 255 bitShift: 0 - tmp8.  1 to: tmp7 do: [:arg2 |  tmp5 byteAt: arg2 put: 0 ].  1 to: tmp4 - tmp7 do: [:arg2 |  tmp6 := self byteAt: arg2.        tmp5 byteAt: arg2 + tmp7 put: (((tmp6 bitAnd: tmp3) bitShift: tmp8) bitOr: tmp1).        tmp1 := tmp6 bitShift: tmp2 ].  ^tmp5-======-selector  ^selector-======-obsolete  self == Object ifTrue: [ ^self error: 'Object is NOT obsolete' ].  self setName: 'AnObsolete' , self name.  Object class instSize + 1 to: self classSide instSize do: [:arg1 |  self instVarAt: arg1 put: nil ].  self classPool: nil.  self sharedPools: nil.  self hasClassSide ifTrue: [ self classSide obsolete ].  self propertyAt: #obsolete put: true.  super obsolete-======-degreeSin  ^(90 - self) degreeCos-======-ffiCallingConvention  ^OSPlatform current ffiCallingConvention-======-dayOfWeek  ^start dayOfWeek-======-genBranchPopTrue: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'distance' index: arg1 range: 0 to: 1023 ].  arg1 < 1024 ifTrue: [ stream           nextPut: 168 + (arg1 bitShift: -8);           nextPut: (arg1 + 1024) \\ 256.        ^self ].  ^self outOfRangeError: 'distance' index: arg1 range: 0 to: 1023-======-storeOn: arg1  self printOn: arg1-======-testMutateIVObject  | tmp1 |  tmp1 := MessageSend new.  tmp1 beReadOnlyObject.  [ tmp1 receiver: 1 ] on: ModificationForbidden do: [:arg1 |   ].  tmp1     beWritableObject;     selector: #+;     beReadOnlyObject.  [ tmp1 arguments: #(2) ] on: ModificationForbidden do: [:arg1 |   ].  self assert: tmp1 receiver isNil.  self assert: tmp1 arguments isNil.  self assert: tmp1 selector identicalTo: #+-======-compileSilently: arg1  ^self compileSilently: arg1 classified: 'not defined category' notifying: nil-======-confirm: arg1  ^UIManager default confirm: arg1-======-okToChange  ^true-======-isSpaceSeparator  ^self characterSet isSpaceSeparator: self-======-identityHash  ^self basicIdentityHash bitShift: 8-======-compileSilently: arg1 classified: arg2  ^self compileSilently: arg1 classified: arg2 notifying: nil-======-blockWithNonLocalReturn: arg1  ^[ ^arg1 ]-======-lookupSelector: arg1  | tmp1 |  tmp1 := self.  [ tmp1 == nil ] whileFalse: [ tmp1 methodDict at: arg1 ifPresent: [:arg2 |  ^arg2 ].        tmp1 := tmp1 superclass ].  ^nil-======-testInquiries  self     assert: week start asDate equals: '28 June 1998' asDate;     assert: week end asDate equals: '4 July 1998' asDate;     assert: week index equals: 5;     assert: week duration equals: 7 days-======-reflectiveMethod  ^self propertyAt: #reflectiveMethod ifAbsent: nil-======-runTestCase: arg1  | tmp1 |  tmp1 := TestExecutionEnvironment new.  tmp1 beActiveDuring: [ tmp1 runTestCase: arg1 ]-======-isVowel  ^'AEIOU' includes: self asUppercase-======-isResumable  ^false-======-assert  self value ifFalse: [ AssertionFailure signal: 'Assertion failed' ]-======-largeIdentityHash  ^self basicIdentityHash-======-traversableIndexableVarIndexes  ^1 to: self basicSize-======-slots  ^self classLayout visibleSlots-======-isModifierSymbol  ^self characterSet isModifierSymbol: self-======-setUp  super setUp.  aCompiledMethod := Rectangle methodDict at: #rightCenter.  aReceiver := 100 @ 100 corner: 200 @ 200.  aSender := thisContext.  aMethodContext := Context sender: aSender receiver: aReceiver method: aCompiledMethod arguments: #()-======-isPinned  ^self isPinnedInMemory-======-literalEqual: arg1  ^self class == arg1 class and: [ self = arg1 ]-======-addProtocolNamed: arg1  ^protocols add: (Protocol name: arg1)-======-intersectWithCC: arg1 withAll: arg2 continuation: arg3  ^arg1 ifEmpty: [ arg3 value: arg1 ] ifNotEmpty: [ arg2 ifEmpty: [ arg1 ] ifNotEmpty: [ self intersect: arg1 withCollection: (self intersectWithCC: arg2 first withAll: arg2 allButFirst continuation: arg3) continuation: arg3 ] ]-======-removeClassVariable: arg1  self removeClassVarNamed: arg1 name-======-copiedValueAt: arg1  < primitive: 60>  ^self basicAt: arg1-======-spotterUsedSlotsFor: arg1  < spotterOrder: 70>  arg1 listProcessor     title: 'Full Definition Slots';     allCandidates: [ self slots select: [:arg2 |  arg2 needsFullDefinition ] ];     itemName: [:arg3 |  arg3 definitionString ];     filter: GTFilterSubstring-======-testSimpleTwoDelays  | tmp1 tmp2 |  tmp1 := Delay new setDelay: 2 forSemaphore: Semaphore new.  tmp2 := Delay new setDelay: 4 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: tmp1 beingWaitedOn.  self deny: tmp2 beingWaitedOn.  scheduler schedule: tmp1.  scheduler schedule: tmp2.  self assert: tmp1 beingWaitedOn.  self assert: tmp2 beingWaitedOn.  scheduler simulate_vmMilliseconds: 11.  self deny: tmp1 isExpired.  self deny: tmp2 isExpired.  scheduler simulate_vmMilliseconds: 12.  self assert: tmp1 isExpired.  self deny: tmp2 isExpired.  scheduler simulate_vmMilliseconds: 13.  self deny: tmp2 isExpired.  scheduler simulate_vmMilliseconds: 14.  self assert: tmp2 isExpired-======-testIfNotNil  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := ProtoObject new.  tmp2 := Object new.  tmp4 := false.  tmp1 ifNotNil: [ tmp4 := true ].  self assert: tmp4 equals: true.  tmp4 := false.  tmp1 ifNotNil: [:arg1 |  tmp4 := true ].  self assert: tmp4 equals: true.  self assert: (tmp1 ifNotNil: [:arg1 |  arg1 == tmp1 ]).  self assert: (tmp1 ifNotNil: [ tmp2 ]) identicalTo: tmp2.  self assert: (tmp1 ifNotNil: [:arg1 |  tmp2 ]) identicalTo: tmp2.  tmp3 := [ tmp4 := true ].  tmp1 ifNotNil: tmp3.  self assert: tmp4 equals: true.  tmp4 := false.  tmp3 := [:arg1 |  tmp4 := true ].  tmp1 ifNotNil: tmp3.  self assert: tmp4 equals: true.  tmp3 := [:arg1 |  arg1 == tmp1 ].  self assert: (tmp1 ifNotNil: tmp3).  tmp3 := [ tmp2 ].  self assert: (tmp1 ifNotNil: tmp3) equals: tmp2.  tmp3 := [:arg1 |  tmp2 ].  self assert: (tmp1 ifNotNil: tmp3) equals: tmp2-======-isLiteral  ^true-======-isSeparator  | tmp1 |  ^(tmp1 := self asInteger) == 32 or: [ tmp1 == 13 or: [ tmp1 == 9 or: [ tmp1 == 10 or: [ tmp1 == 12 ] ] ] ]-======-defaultQueue  defaultQueue ifNil: [ defaultQueue := OrderedCollection new ].  ^defaultQueue-======-testMidnight  self assert: aDateAndTime midnight equals: aDateAndTime-======-asContext  ^self asContextWithSender: nil-======-subclass: arg1 layout: arg2 slots: arg3 classVariables: arg4 poolDictionaries: arg5 package: arg6  ^self classInstaller make: [:arg7 |  arg7           name: arg1;           superclass: self;           layoutClass: arg2;           slots: arg3;           sharedVariables: arg4;           sharedPools: arg5;           category: arg6 ]-======-removeProperty: arg1 ifAbsent: arg2  | tmp1 |  self properties ifNil: [ ^arg2 value ].  tmp1 := self properties removeKey: arg1 ifAbsent: arg2.  self removePropertiesIfEmpty.  ^tmp1-======-isInteger  ^false-======-printStringRoman  | tmp1 tmp2 |  tmp1 := String new writeStream.  tmp2 := self negative ifTrue: [ tmp1 nextPut: $-.        self negated ] ifFalse: [ self ].  tmp2 // 1000 timesRepeat: [ tmp1 nextPut: $M ].  tmp2     romanDigits: 'MDC' for: 100 on: tmp1;     romanDigits: 'CLX' for: 10 on: tmp1;     romanDigits: 'XVI' for: 1 on: tmp1.  ^tmp1 contents-======-testAsYear  self assert: aDateAndTime asYear equals: (Year starting: '01-01-1970' asDate)-======-primitiveFail  ^self primitiveFailed-======-testMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'AM'-======-triggerEvent: arg1 withArguments: arg2  ^(self actionForEvent: arg1) valueWithArguments: arg2-======-updateableActionMap  ^EventManager updateableActionMapFor: self-======-error  ^self error: 'Error!'-======-bytesCount  | tmp1 tmp2 |  tmp2 := 1.  tmp1 := self.  tmp1 >= 0 ifTrue: [ [ tmp1 > 255 ] whileTrue: [ tmp1 := tmp1 bitShift: -8.              tmp2 := tmp2 + 1 ] ] ifFalse: [ [ tmp1 < -255 ] whileTrue: [ tmp1 := tmp1 bitShift: -8.              tmp2 := tmp2 + 1 ] ].  ^tmp2-======-asAlien  ^1-======-innerBindingOf: arg1  (self classPool bindingOf: arg1) ifNotNil: [:arg2 |  ^arg2 ].  self sharedPools do: [:arg3 |  (arg3 bindingOf: arg1) ifNotNil: [:arg2 |  ^arg2 ] ].  self superclass ifNotNil: [:arg4 |  ^arg4 innerBindingOf: arg1 ].  ^nil-======-supermostPrecodeCommentFor: arg1  | tmp1 tmp2 |  (self == Behavior or: [ self superclass == nil or: [ (tmp1 := self superclass whichClassIncludesSelector: arg1) == nil ] ]) ifFalse: [ tmp2 := tmp1 supermostPrecodeCommentFor: arg1 ].  ^tmp2 ifNil: [ self firstPrecodeCommentFor: arg1 ]-======-expandRectangle: arg1  ^Rectangle left: arg1 left - self left right: arg1 right + self right top: arg1 top - self top bottom: arg1 bottom + self bottom-======-valueWithArguments: arg1  ^self-======-cull: arg1 cull: arg2 cull: arg3 cull: arg4  ^numArgs < 4 ifTrue: [ self cull: arg1 cull: arg2 cull: arg3 ] ifFalse: [ self value: arg1 value: arg2 value: arg3 value: arg4 ]-======-testAsYear  self     assert: 1 year days equals: 365;     assert: 0.5 year asHours equals: 364 / 2 * 24 + 12-======-link: arg1 toClassVariableNamed: arg2 option: arg3  arg1 installOnClassVarNamed: arg2 for: self option: arg3 instanceSpecific: self intanceSpecificMetaLinksAvailable-======-basicNew  < primitive: 70 error: ec>  ec == #'insufficient object memory' ifTrue: [ ^self handleFailingBasicNew ].  self isVariable ifTrue: [ ^self basicNew: 0 ].  self primitiveFailed-======-simpleRetryTest  | tmp1 |  tmp1 := nil.  [ self doSomething.  tmp1 == nil ifTrue: [ MyTestError signal ] ifFalse: [ self doSomethingElse ] ] on: MyTestError do: [:arg1 |  tmp1 := 42.        self doYetAnotherThing.        arg1 retry ]-======-do: arg1 with: arg2  self do: arg1 with: arg2 when: [:arg3 |  true ]-======-upperBound  ^upperBound-======-isCompiledMethodClass  ^self instSpec >= 24-======-superclass  ^superclass-======-testIsPowerOfTwoM6873  self deny: ((1 to: 80) anySatisfy: [:arg1 |  (2 raisedTo: arg1) negated isPowerOfTwo ]) description: 'A negative integer cannot be a power of two'-======-asUppercase  ^self characterSet toUppercase: self-======-modelWakeUpIn: arg1  -======-digitMultiply: arg1 neg: arg2  < primitive: 'primDigitMultiplyNegative' module: 'LargeIntegers'>  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  (arg1 bytesCount = 1 and: [ (arg1 byteAt: 1) = 0 ]) ifTrue: [ ^0 ].  (self bytesCount = 1 and: [ (self byteAt: 1) = 0 ]) ifTrue: [ ^0 ].  tmp2 := self bytesCount + arg1 bytesCount.  tmp1 := Integer new: tmp2 neg: arg2.  1 to: self bytesCount do: [:arg3 |  (tmp4 := self byteAt: arg3) ~= 0 ifTrue: [ tmp5 := arg3.              tmp3 := 0.              1 to: arg1 bytesCount do: [:arg4 |  tmp6 := (arg1 byteAt: arg4) * tmp4 + tmp3 + (tmp1 byteAt: tmp5).                    tmp3 := tmp6 bitShift: -8.                    tmp1 byteAt: tmp5 put: (tmp6 bitAnd: 255).                    tmp5 := tmp5 + 1 ].              tmp1 byteAt: tmp5 put: tmp3 ] ].  ^tmp1 normalize-======-testSimplestCallCC  | tmp1 |  tmp1 := self callcc: [:arg1 |  arg1 value: true ].  self assert: tmp1-======-printOn: arg1  arg1 nextPutAll: self monthName , ' ' , self year printString-======-collectArguments: arg1  | tmp1 |  tmp1 := self arguments.  ^arg1 size = tmp1 size ifTrue: [ Array withAll: arg1 ] ifFalse: [ (tmp1 isEmpty ifTrue: [ tmp1 := Array new: selector numArgs ] ifFalse: [ Array withAll: tmp1 ]) replaceFrom: 1 to: (arg1 size min: tmp1 size) with: arg1 startingAt: 1 ]-======-stringForReadout  ^self rounded printString-======-yyyymmdd  ^String new: 10 streamContents: [:arg1 |  self printOn: arg1 format: #(3 2 1 $- 1 1 2) ]-======-< arg1  ^self asDuration < arg1 asDuration-======-protocols  ^self protocolOrganizer protocols-======-testFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 2004-02-29T13:33:00+02:00')-======-testConvertFromFloat  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 11 / 13 asFloat.  tmp2 := tmp1 asScaledDecimal: 2.  self assert: 2 equals: tmp2 scale.  self assert: '0.85s2' equals: tmp2 printString.  self assert: '-0.85s2' equals: tmp2 negated printString.  tmp3 := tmp2 asFloat.  tmp4 := tmp3 - tmp1.  self assert: tmp4 abs < 1.0e-9-======-signal  | tmp1 |  (context method hasPragmaNamed: #transform:to:) ifFalse: [ ^super signal ].  tmp1 := context method pragmaAt: #transform:to:.  self rule: tmp1 arguments first -> tmp1 arguments second.  self transform-======-testRemoveOneStar  | tmp1 tmp2 |  tmp1 := #Swedish ~~> (#rye ~~> nil) ~~> (#French ~~> (#mustard ~~> (#salad ~~> (#turkey ~~> nil)) ~~> nil) ~~> (#salad ~~> nil)).  tmp2 := #pasta ~~> (#meat ~~> nil) ~~> (#pasta ~~> (#noodles ~~> (#meat ~~> (#sauce ~~> nil)) ~~> (#meat ~~> (#tomatoes ~~> nil)))).  self assert: (self printStringOfTree: tmp1) equals: '((#Swedish #rye) (#French (#mustard #salad #turkey)) #salad)'.  self assert: (self printStringOfTree: tmp2) equals: '((#pasta #meat) #pasta (#noodles #meat #sauce) #meat #tomatoes)'.  self assert: (self printStringOfTree: (self remove: #salad oneStar: tmp1)) equals: '((#Swedish #rye) (#French (#mustard #turkey)) #salad)'.  self assert: (self printStringOfTree: (self remove: #salad oneStarWithTry: tmp1)) equals: '((#Swedish #rye) (#French (#mustard #turkey)) #salad)'.  self assert: (self printStringOfTree: (self remove: #meat oneStar: tmp2)) equals: '((#pasta) #pasta (#noodles #meat #sauce) #meat #tomatoes)'.  self assert: (self printStringOfTree: (self remove: #meat oneStarWithTry: tmp2)) equals: '((#pasta) #pasta (#noodles #meat #sauce) #meat #tomatoes)'-======-exampleSend  < sampleInstance>  instVar1 := 1.  self yourself.  ^thisContext copy-======-okToClose  ^true-======-testCreationWithOffsets  | tmp1 tmp2 |  tmp1 := DateAndTime year: 2222 month: 1 day: 22 hour: 1 minute: 22 second: 33 offset: 0 hours.  tmp2 := DateAndTime year: 2222 month: 1 day: 22 hour: 1 minute: 22 second: 33 offset: 2 hours.  self deny: tmp1 equals: tmp2.  self assert: tmp1 year equals: tmp2 year.  self assert: tmp1 month equals: tmp2 month.  self assert: tmp1 day equals: tmp2 day.  self assert: tmp1 hours equals: tmp2 hours.  self assert: tmp1 minutes equals: tmp2 minutes.  self assert: tmp1 seconds equals: tmp2 seconds-======-testChangingShapeDoesNotPutNilInMethodsLastLiteralKey  | tmp1 |  tmp1 := testEnvironment at: #TUTU.  tmp1 compile: 'foo'.  self deny: (tmp1 >> #foo) allLiterals last key isNil.  tmp1 addInstVarNamed: 'x'.  self deny: (tmp1 >> #foo) allLiterals last key isNil-======-adoptForNewCalypsoQuery  ^self-======-propertyValueAt: arg1 ifAbsent: arg2  ^self propertyAt: arg1 ifAbsent: arg2-======-exception: arg1  exception := arg1-======-shallowCopy  -======-testBenchFib  self assert: 0 benchFib equals: 1.  self assert: 1 benchFib equals: 1.  self assert: 2 benchFib equals: 3-======-javascriptOn: arg1  arg1 javascript: self asMilliseconds-======-serializeOn: arg1  -======-thoroughWhichMethodsReferTo: arg1  | tmp1 |  tmp1 := Smalltalk specialSelectorIndexOrNil: arg1.  ^self methods select: [:arg2 |  arg2 hasSelector: arg1 specialSelectorIndex: tmp1 ]-======-superclass: arg1 methodDictionary: arg2 format: arg3  super superclass: arg1 methodDictionary: arg2 format: arg3.  self organization: nil-======-isEpEvent  ^false-======-ffiCall: arg1 library: arg2  < ffiCalloutTranslator>  self ffiCall: arg1 library: arg2 options: #()-======-asMilliSeconds  ^self asDuration asMilliSeconds-======-asFullRingDefinition  | tmp1 tmp2 |  tmp1 := self realClass asRingDefinition.  tmp2 := self asActiveRingDefinition.  tmp1 addMethod: tmp2.  tmp2 package: (RGContainer packageOfMethod: tmp2).  ^tmp2-======-fuelSetOrigin: arg1 corner: arg2  origin := arg1.  corner := arg2-======-postCopy  array := array copy-======-testByteAt  | tmp1 |  tmp1 := 16rABCDEF.  self assert: (tmp1 byteAt: 1) equals: 16rEF.  self assert: (tmp1 byteAt: 2) equals: 16rCD.  self assert: (tmp1 byteAt: 3) equals: 16rAB-======-fourDirections  ^Array with: self leftRotated with: self negated with: self rightRotated with: self-======-isHealthy  1 to: self basicSize do: [:arg1 |  | tmp1 |        tmp1 := self basicAt: arg1.        tmp1 ifNotNil: [ (self scanFor: tmp1) == arg1 ifFalse: [ ^false ] ] ].  ^true-======-raisedToFraction: arg1  | tmp1 |  tmp1 := self asFraction raisedToFraction: arg1.  ^tmp1 isFloat ifTrue: [ tmp1 ] ifFalse: [ tmp1 asScaledDecimal: scale ]-======-doSomethingElse  self log: self doSomethingElseString-======-testIsNonspacingMark  self checkCorrespondanceOf: #isNonspacingMark: and: #Mn-======-testUnwindFromActiveProcess  | tmp1 tmp2 |  tmp1 := Semaphore forMutualExclusion.  self assert: tmp1 isSignaled.  tmp2 := [ tmp1 critical: [ self deny: tmp1 isSignaled.        Processor activeProcess terminate ] ] forkAt: Processor userInterruptPriority.  self assert: tmp1 isSignaled-======-name  ^'Overrides a deprecated method'-======-inspectSubInstances  | tmp1 tmp2 tmp3 |  tmp1 := self allSubInstances.  (tmp2 := tmp1 size) isZero ifTrue: [ ^self inform: 'There are no instances of ' , self name , 'or any of its subclasses' ].  tmp3 := tmp2 = 1 ifTrue: [ 'The lone instance' ] ifFalse: [ 'The ' , tmp2 printString , ' instances' ].  tmp1 asArray inspectWithLabel: tmp3 , ' of ' , self name , ' & its subclasses'-======-genStorePopInstVarLong: arg1  (arg1 < 0 or: [ arg1 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 65535 ].  arg1 > 255 ifTrue: [ self genUnsignedSingleExtendA: arg1 // 256 ].  stream     nextPut: 240;     nextPut: arg1 \\ 256-======-isValid  ^self isReceiverOrAnyArgumentGarbage not-======-renderOn: arg1  self numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: arg1 ]-======-printOn: arg1  | tmp1 |  (self asInteger > 32 and: [ self asInteger ~= 127 ]) ifTrue: [ arg1           nextPut: $$;           nextPut: self ] ifFalse: [ tmp1 := self class constantNameFor: self.        arg1 nextPutAll: self class name.        tmp1 notNil ifTrue: [ arg1                 space;                 nextPutAll: tmp1 ] ifFalse: [ arg1                 nextPutAll: ' value: ';                 print: self asInteger ] ]-======-testSimpleEnsureTestWithUparrow  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithUparrow)-======-isOtherNumber  ^self characterSet isOtherNumber: self-======-frameSize  (self header noMask: 16r20000) ifTrue: [ ^SmallFrame ] ifFalse: [ ^LargeFrame ]-======-numberOfDigitsInBase: arg1  arg1 = 10 ifFalse: [ ^super numberOfDigitsInBase: arg1 ].  self < 0 ifTrue: [ ^self negated numberOfDigitsInBase: arg1 ].  ^self decimalDigitLength-======-scaledAndCenteredIn: arg1  ^self width / arg1 width > (self height / arg1 height) ifTrue: [ arg1 left @ (arg1 leftCenter y - (self height * (arg1 width / self width) / 2)) corner: arg1 right @ (arg1 rightCenter y + (self height * (arg1 width / self width) / 2)) ] ifFalse: [ (arg1 topCenter x - (self width * (arg1 height / self height) / 2)) @ arg1 top corner: (arg1 topCenter x + (self width * (arg1 height / self height) / 2)) @ arg1 bottom ]-======-defaultAction  reachedDefaultHandler := true.  super defaultAction-======-testAsDuration  self assert: aDateAndTime asDuration equals: aDuration-======-testPrintOn  self assert: (String streamContents: [:arg1 |  false printOn: arg1 ]) equals: 'false'-======-split: arg1 do: arg2  self split: arg1 indicesDo: [:arg3 :arg4 |  arg2 value: (arg1 copyFrom: arg3 to: arg4) ]-======->= arg1  < primitive: 26>  ^super >= arg1-======-testOnFork  | tmp1 tmp2 |  tmp2 := nil.  tmp1 := [ 1 ] on: Exception fork: [ tmp2 := 2 ].  Processor yield.  self assert: tmp1 equals: 1.  self assert: tmp2 isNil-======-hash  ^self ticks hash-======-pushReceiverVariable: arg1  self push: (self object: self receiver instVarAt: arg1 + 1)-======-printStringHex  ^self printStringBase: 16-======-max: arg1  ^(x max: arg1 x) @ (y max: arg1 y)-======-classComment: arg1 stamp: arg2  self     comment: arg1;     commentStamp: arg2-======-testDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 1-======-testIsNonspacingMark  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isNonspacingMark: tmp2) equals: (tmp1 isNonspacingMark: tmp2) ]-======-storeOn: arg1  arg1     print: self printString;     nextPutAll: ' asDate'-======-isNonspacingMark  ^self characterSet isNonspacingMark: self-======-hasMultipleExecutors  ^false-======-testBasicCheck1  | tmp1 |  tmp1 := testClass >> (testClass compile: 'testMethod SmallFloat64').  self assert: (FloatReferencesRule new basicCheck: tmp1 ast)-======-continuationExample1: arg1  | tmp1 tmp2 |  tmp1 := [:arg2 |  | tmp3 tmp4 |  tmp3 := 1.  tmp4 := [ | tmp5 |  tmp5 := arg2 at: tmp3.  tmp3 := tmp3 + 1.  Array with: tmp5 with: (tmp3 <= arg2 size ifTrue: [ tmp4 ] ifFalse: [ nil ]) ] ].  tmp2 := [:arg3 |  | tmp6 |  tmp6 := OrderedCollection new.  [ | tmp7 |  tmp7 := arg3 value.  tmp6 add: tmp7 first.  tmp7 last notNil ] whileTrue: [  ].  tmp6 ].  ^tmp2 value: (tmp1 value: arg1)-======-testBasicProxyWritable  self alwaysWritableObjects , self maybeReadOnlyObjects do: [:arg1 |  self assert: (MirrorPrimitives isObjectReadOnly: arg1) equals: false ]-======-isHandlerOrSignalingContext  ^method primitive = 199-======-testNanoConstructor  | tmp1 tmp2 tmp3 |  tmp1 := Time fromString: '01:23:45.67809'.  tmp2 := Time hour: 1 minute: 23 second: 45 nano: 67809.  tmp3 := Time hour: 1 minute: 23 second: 45 nanoSecond: 67809.  self     assert: tmp1 equals: tmp2;     deny: tmp2 equals: tmp3.  tmp1 := Time fromString: '01:23:45.0'.  tmp2 := Time hour: 1 minute: 23 second: 45 nano: 0.  self assert: tmp1 equals: tmp2.  tmp1 := Time fromString: '01:23:45.1234567890'.  tmp2 := Time hour: 1 minute: 23 second: 45 nano: 1234567890.  self assert: tmp1 equals: tmp2-======-montgomeryRaisedTo: arg1 times: arg2 modulo: arg3 mInvModB: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp3 := arg1 highBit.  tmp4 := (tmp3 highBit - 1 >> 1 min: 16) max: 1.  tmp6 := Array new: 1 << tmp4.  tmp6 at: 1 put: (tmp1 := self).  tmp7 := self montgomeryTimes: self modulo: arg3 mInvModB: arg4.  2 to: tmp6 size do: [:arg5 |  tmp1 := tmp6 at: arg5 put: (tmp1 montgomeryTimes: tmp7 modulo: arg3 mInvModB: arg4) ].  tmp1 := arg2.  [ tmp3 > 0 ] whileTrue: [ tmp1 := tmp1 montgomeryTimes: tmp1 modulo: arg3 mInvModB: arg4.        (arg1 bitAt: tmp3) = 0 ifFalse: [ tmp2 := tmp3 - tmp4 max: 1.              [ tmp2 < tmp3 and: [ (arg1 bitAt: tmp2) = 0 ] ] whileTrue: [ tmp2 := tmp2 + 1 ].              tmp5 := 0.              [ tmp3 > tmp2 ] whileTrue: [ tmp1 := tmp1 montgomeryTimes: tmp1 modulo: arg3 mInvModB: arg4.                    tmp5 := (tmp5 << 1) + (arg1 bitAt: tmp3).                    tmp3 := tmp3 - 1 ].              tmp1 := tmp1 montgomeryTimes: (tmp6 at: tmp5 + 1) modulo: arg3 mInvModB: arg4 ].        tmp3 := tmp3 - 1 ].  ^tmp1-======-asScaledDecimal  ^ScaledDecimal newFromNumber: self scale: 0-======-sampleMessageWithFirstArgument: arg1 andInterleavedCommentBeforeSecondArgument: arg2  | tmp1 |  tmp1 := self.  ^tmp1-======-initialize  super initialize.  vmSimTheTimerSemaphore := Semaphore new.  vmSimNow := 0-======-copyto: arg1  | tmp1 |  tmp1 := self bytesCount min: arg1 bytesCount.  ^arg1 replaceFrom: 1 to: tmp1 with: self startingAt: 1-======-hash  ^self-======-checkAllClasses  | tmp1 |  tmp1 := (self systemNavigation allClassesImplementing: #veryDeepInner:) , (self systemNavigation allClassesImplementing: #veryDeepCopyWith:) flatCollect: [:arg1 |  self basicCheckClass: arg1 ].  self raiseWarningsIfAny: tmp1-======-truncateTo: arg1  | tmp1 |  tmp1 := arg1 asPoint.  ^(x truncateTo: tmp1 x) @ (y truncateTo: tmp1 y)-======-testDurationMoreThanMaxTicks  | tmp1 |  tmp1 := Delay new setDelay: 1234 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: tmp1.  self assert: ticker vmSimNextWakeupMilliseconds equals: 100 + 1000-======-testFromString  self assert: aDuration equals: (Duration fromString: '1:02:03:04.000000005')-======-deepCopy  ^self-======-doesNotUnderstand: arg1  < debuggerCompleteToSender>  | tmp1 tmp2 |  (tmp1 := MessageNotUnderstood new)     message: arg1;     receiver: self.  tmp2 := tmp1 signal.  ^tmp1 reachedDefaultHandler ifTrue: [ arg1 sentTo: self ] ifFalse: [ tmp2 ]-======-testRunSimulated  self assert: (Context runSimulated: aBlockContext) class equals: Rectangle-======-ephemeronSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4  ^self ephemeronSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: '' package: arg4-======-testTimesAreLocal  | tmp1 tmp2 tmp3 |  tmp1 := DateAndTime current offset: DateAndTime localOffset + 2 hours.  tmp2 := DosTimestamp fromDateAndTime: tmp1.  tmp3 := DosTimestamp fromDateAndTime: tmp1 asLocal.  self assert: tmp2 equals: tmp3-======-testMetaclassName  self assert: Dictionary class name equals: 'Dictionary class'.  self assert: OrderedCollection class name equals: 'OrderedCollection class'-======-isExternalCallPrimitive  ^self primitive = 120-======-testErrorToken  | tmp1 tmp2 |  tmp1 := Context primitiveFailToken.  tmp2 := Context primitiveFailTokenFor: 100.  self assert: tmp1 first identicalTo: tmp2 first.  self assert: tmp1 second isNil.  self assert: tmp2 second equals: 100-======-setUp  super setUp.  value := 0-======-saveTemp: arg1  self savedTemps ifNil: [ self propertyAt: #savedTemps put: Set new ].  self savedTemps add: arg1-======-align: arg1 with: arg2  ^self translateBy: arg2 - arg1-======-select: arg1  | tmp1 |  tmp1 := self class new.  self do: [:arg2 |  (arg1 value: arg2) ifTrue: [ tmp1 add: arg2 ] ].  ^tmp1-======-testBecomeIdentityHash  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 'ab' copy.  tmp2 := 'cd' copy.  tmp3 := tmp1.  tmp4 := tmp2.  tmp1 become: tmp2.  self     assert: tmp1 identityHash equals: tmp3 identityHash;     assert: tmp2 identityHash equals: tmp4 identityHash;     deny: tmp1 identityHash equals: tmp2 identityHash-======-testNumberConvenienceMethods  self     assert: 1 week equals: (Duration days: 7);     assert: -1 week equals: (Duration days: -7);     assert: 1 day equals: (Duration days: 1);     assert: -1 day equals: (Duration days: -1);     assert: 1 hours equals: (Duration hours: 1);     assert: -1 hour equals: (Duration hours: -1);     assert: 1 minute equals: (Duration seconds: 60);     assert: -1 minute equals: (Duration seconds: -60);     assert: 1 second equals: (Duration seconds: 1);     assert: -1 second equals: (Duration seconds: -1);     assert: 1 milliSecond equals: (Duration milliSeconds: 1);     assert: -1 milliSecond equals: (Duration milliSeconds: -1);     assert: 1 nanoSecond equals: (Duration nanoSeconds: 1);     assert: -1 nanoSecond equals: (Duration nanoSeconds: -1)-======-ifNotNil: arg1 ifNil: arg2  ^arg2 value-======-brickValue: arg1 withEnoughArguments: arg2  ^self valueWithEnoughArguments: {arg1} , arg2-======-addCategory: arg1 before: arg2  ^self organization addCategory: arg1 before: arg2-======-isPrimFailToken: arg1  ^(self objectClass: arg1) == Array and: [ arg1 size = 2 and: [ arg1 first == PrimitiveFailToken ] ]-======-critiques  < eProperty>  | tmp1 |  tmp1 := ReCriticEngine critiquesOf: self.  tmp1 := tmp1 , (ReCriticEngine nodeCritiquesOf: self).  ^tmp1-======-at: arg1 ifPresent: arg2  ^arg2 value: (self at: arg1 ifAbsent: [ ^self ])-======-genPushLiteralVar: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255 ].  arg1 < 32 ifTrue: [ stream nextPut: 64 + arg1.        ^self ].  arg1 < 64 ifTrue: [ stream           nextPut: 128;           nextPut: 192 + arg1.        ^self ].  arg1 < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 128;           nextPut: arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255-======-group  ^'Potential Bugs'-======-testIncludesAll  self assert: (aTimespan includesAll: (Bag with: jan01)).  self deny: (aTimespan includesAll: (Bag with: jan01 with: jan08))-======-properties  ^ClassProperties at: self ifAbsent: nil-======-minute  ^self localSeconds // SecondsInMinute \\ 60-======-triggerEvent: arg1 with: arg2  ^self triggerEvent: arg1 withArguments: {arg2}-======-subtractDays: arg1  ^(self asDateAndTime - arg1 days) asDate-======-seconds: arg1 nanoSeconds: arg2  seconds := arg1.  nanos := arg2-======-rule: arg1  rule := arg1-======-testMultDicAddSub  | tmp1 tmp2 tmp3 |  tmp1 := 100.  tmp2 := 100 factorial.  tmp3 := tmp2 * (tmp1 + 1).  tmp1 timesRepeat: [ tmp3 := tmp3 - tmp2 ].  self assert: tmp3 equals: tmp2.  tmp1 timesRepeat: [ tmp3 := tmp3 + tmp2 ].  self assert: tmp3 // tmp2 equals: tmp1 + 1.  self assert: tmp3 negated equals: (Number readFrom: '-' , tmp3 printString)-======-nextInstruction  ^self interpretNextInstructionFor: MessageCatcher new-======-testSemaphoreTimeout  | tmp1 |  tmp1 := Semaphore new.  [ | tmp2 |  tmp2 := [ Delay timeoutSemaphore: tmp1 afterMSecs: 0.  tmp1 wait ] newProcess.  tmp2 priority: Processor highIOPriority.  tmp2 resume.  self assert: tmp2 isTerminated ] ensure: [ tmp1 signal ]-======-storeOn: arg1  self storeOn: arg1 base: 10-======-sharedPools: arg1  sharedPools := arg1-======-testNot  self deny: true not-======-testMillisecondsToGoExpired  | tmp1 |  tmp1 := Delay forMilliseconds: 100.  scheduler simulate_vmMilliseconds: 1.  scheduler schedule: tmp1.  scheduler simulate_vmMilliseconds: 200-======-methodClass  ^self outerCode methodClass-======-testSingleTiming  | tmp1 |  tmp1 := DateAndTime now.  aStopwatch activate.  aDelay wait.  aStopwatch suspend.  self assert: aStopwatch timespans size equals: 1.  self assert: aStopwatch timespans first asDateAndTime >= tmp1.  self assert: aStopwatch timespans first asDateAndTime <= aStopwatch end-======-name  ^'Sends a deprecated message to a known global'-======-var1: arg1  var1 := arg1-======-name  ^self subclassResponsibility-======-testConvertFromDecimalFraction  0 to: 11 do: [:arg1 |  0 to: 11 do: [:arg2 |  | tmp1 tmp2 tmp3 |              tmp1 := 13 / (2 raisedTo: arg1) / (5 raisedTo: arg2).              tmp2 := tmp1 asScaledDecimal.              self assert: tmp2 scale equals: (arg1 max: arg2).              tmp3 := ScaledDecimal readFrom: tmp2 printString.              self assert: tmp2 equals: tmp3 ] ]-======-allSharedPools  ^self superclass ifNil: [ self sharedPools copy ] ifNotNil: [ | tmp1 |        tmp1 := self superclass allSharedPools.        tmp1           addAll: self sharedPools;           yourself ]-======-retryUsing: arg1  handlerContext restartWithNewReceiver: arg1-======-criticNameOn: arg1  arg1 << self name << ' (' << self category << ')'-======-methodsReadingSlot: arg1  ^self methods select: [:arg2 |  arg2 readsSlot: arg1 ]-======-fieldIndex  ^fieldIndex-======-addDays: arg1  ^(self asDateAndTime + arg1 days) asDate-======-allSubInstances  | tmp1 |  tmp1 := OrderedCollection new.  self allSubInstancesDo: [:arg1 |  arg1 == tmp1 ifFalse: [ tmp1 add: arg1 ] ].  ^tmp1-======-critiqueFor: arg1  ^ArchitecturalCritique withAnchor: (self anchorFor: arg1) by: self-======-testMetaclassSuperclassHierarchy  | tmp1 |  self assert: SequenceableCollection class instanceCount equals: 1.  self assert: Collection class instanceCount equals: 1.  self assert: Object class instanceCount equals: 1.  self assert: ProtoObject class instanceCount equals: 1.  tmp1 := OrderedCollection new     add: SequenceableCollection class;     add: Collection class;     add: Object class;     add: ProtoObject class;     add: Class;     add: ClassDescription;     add: Behavior;     add: Object;     add: ProtoObject;     yourself.  self assert: OrderedCollection class allSuperclasses equals: tmp1-======-testEncodingVarLengthSourcePointer  | tmp1 tmp2 |  tmp1 := CompiledMethodTrailer new.  tmp1 sourcePointer: 1.  tmp2 := tmp1 testEncoding.  self assert: tmp2 sourcePointer equals: 1.  tmp1 sourcePointer: 16r100000000000000.  tmp2 := tmp1 testEncoding.  self assert: tmp2 sourcePointer equals: 16r100000000000000.  self assert: tmp2 endPC equals: 0-======-stonOn: arg1  arg1 writeBoolean: self-======-as31BitSmallInt  ^self subclassResponsibility-======-index  ^self monthIndex-======-genSendSuper: arg1 numArgs: arg2  | tmp1 tmp2 |  (arg1 < 0 or: [ arg1 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'selectorLiteralIndex' index: arg1 range: 0 to: 65535 ].  (arg2 < 0 or: [ arg2 > 31 ]) ifTrue: [ ^self outOfRangeError: 'numArgs' index: arg2 range: 0 to: 31 ].  (tmp1 := arg1) > 31 ifTrue: [ self genUnsignedSingleExtendA: tmp1 // 32.        tmp1 := tmp1 \\ 32 ].  (tmp2 := arg2) > 7 ifTrue: [ self genUnsignedSingleExtendB: tmp2 // 8.        tmp2 := tmp2 \\ 8 ].  stream     nextPut: 235;     nextPut: tmp2 + (tmp1 * 8)-======-class  < primitive: 111>  self primitiveFailed-======-