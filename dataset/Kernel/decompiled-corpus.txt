arguments  ^argumentsremoveElement: arg1  ^self basicRemoveElement: arg1testReciprocal  self     assert: 1 reciprocal equals: 1;     assert: 2 reciprocal equals: 1 / 2;     assert: -1 reciprocal equals: -1;     assert: -3 reciprocal equals: -1 / 3.  self should: [ 0 reciprocal ] raise: ZeroDividetestTicks  self assert: aDuration ticks equals: #(1 7384 5)home  closureOrNil == nil ifTrue: [ ^self ].  ^closureOrNil outerContext hometestDigitsAccess  self assert: (42 digitAt: 2 base: 10) equals: 4.  self assert: (42 digitAt: 1 base: 10) equals: 2.  self assert: (1 digitAt: 2 base: 10) equals: 0.  self assert: (16rFF digitAt: 1 base: 16) equals: 15.  self assert: (42 decimalDigitAt: 2) equals: 4.  self assert: (42 decimalDigitAt: 1) equals: 2.  self assert: 42 decimalDigitLength equals: 2.  self assert: 0 decimalDigitLength equals: 1.  self assert: 100000000000 decimalDigitLength equals: 12.  self assert: 255 lastDigit equals: 255.  self assert: 256 lastDigit equals: 1.  self assert: (256 * 256 - 1) lastDigit equals: 255.  self assert: (256 * 256) lastDigit equals: 1testSymmetric  | tmp1 tmp2 |  tmp1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  tmp2 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self assert: tmp2 equals: tmp1.  self assert: tmp1 equals: tmp2testIsLiteral  self assert: 1.00s2 isLiteral description: 'every literal obviously isLiteral'.  self deny: (1 / 3.00s2) isLiteral description: 'this number cannot represent itself as a literal'secondsSinceMidnightLocalTime  ^self localSeconds \\ SecondsInDaytestSuperclassOrder  | tmp1 tmp2 tmp3 |  tmp2 := {ProtoObject .   Object .   Collection .   SequenceableCollection}.  tmp3 := {Collection .   SequenceableCollection .   ProtoObject .   Object}.  tmp1 := Class superclassOrder: tmp3.  self assert: tmp1 equals: tmp2 asOrderedCollectiontestAsTime  self assert: aDateAndTime asTime equals: (Time hour: 13 minute: 33 second: 0)createTwin  self reflectiveMethod: (ReflectiveMethod on: self)testIfNotNilDo  nil ifNotNil: [ self fail: 'should not get here' ]bitOr: arg1  < primitive: 15>  self >= 0 ifTrue: [ ^arg1 bitOr: self ].  ^arg1 < 0 ifTrue: [ (self bitInvert bitAnd: arg1 bitInvert) bitInvert ] ifFalse: [ (self bitInvert bitClear: arg1) bitInvert ]printDebugOn: arg1  | tmp1 tmp2 |  self printOn: arg1.  self outerContext ifNil: [ ^self ].  arg1 nextPutAll: ' in Block: '.  tmp1 := closureOrNil printStringLimitedTo: 50.  tmp2 := tmp1 size.  tmp1 := tmp1 copyUpTo: Character cr.  arg1 nextPutAll: tmp1.  tmp1 size < tmp2 ifTrue: [ arg1 nextPutAll: '...' ]alwaysReadOnlyObjects  ^{1}typeOfClass  self classLayout isCustomLayout ifTrue: [ ^self classLayout class name asSymbol ].  self isBytes ifTrue: [ ^self instSpec = CompiledMethod instSpec ifTrue: [ #compiledMethod ] ifFalse: [ #bytes ] ].  (self isWords and: [ self isPointers not ]) ifTrue: [ ^self instSpec = SmallInteger instSpec ifTrue: [ #immediate ] ifFalse: [ #words ] ].  self isWeak ifTrue: [ ^#weak ].  self isVariable ifTrue: [ ^#variable ].  self isEphemeronClass ifTrue: [ ^#ephemeron ].  ^#normaltestYyyymmdd  self assert: january23rd2004 yyyymmdd equals: '2004-01-23'testFromDateAndTime  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  DateAndTime today to: DateAndTime tomorrow by: 10 hours do: [:arg1 |  tmp1 add: arg1 ].  tmp2 := {DateAndTime today .   (DateAndTime today + 10 hours) .   (DateAndTime today + 20 hours)}.  self assert: tmp1 asArray equals: tmp2sizePushReceiver  ^self sizeOpcodeSelector: #genPushReceiver withArguments: #()classClass  self deprecated: 'Please use #classSide instead' transformWith: '`@receiver classClasss' -> '`@receiver classSide'.  ^self classSidetestNew  self should: [ Integer new ] raise: self defaultTestErrortestIsPrime2  #(-100 -5 -3 -2 -1 0 1) do: [:arg1 |  self deny: arg1 isPrime ].  #(17 78901 104729 15485863 2038074743) do: [:arg1 |  self assert: arg1 isPrime ].  #(561 2821 6601 10585 15841 256 29996224275831) do: [:arg1 |  self deny: arg1 isPrime ]testSupplyAnswerOfFillInTheBlank  self should: [ 'blue' = ([ UIManager default request: 'Your favorite color?' ] valueSupplyingAnswer: #('Your favorite color?' 'blue')) ]previous: arg1  | tmp1 |  tmp1 := (7 + self weekdayIndex - (self class dayOfWeek: arg1)) \\ 7.  tmp1 = 0 ifTrue: [ tmp1 := 7 ].  ^self subtractDays: tmp1print24: arg1 showSeconds: arg2 on: arg3  | tmp1 tmp2 tmp3 |  tmp1 := self hour.  tmp2 := self minute.  tmp3 := self second.  arg1 ifTrue: [ tmp1 < 10 ifTrue: [ arg3 nextPut: $0 ].        tmp1 printOn: arg3 ] ifFalse: [ tmp1 > 12 ifTrue: [ tmp1 - 12 printOn: arg3 ] ifFalse: [ tmp1 < 1 ifTrue: [ 12 printOn: arg3 ] ifFalse: [ tmp1 printOn: arg3 ] ] ].  arg3 nextPutAll: (tmp2 < 10 ifTrue: [ ':0' ] ifFalse: [ ':' ]).  tmp2 printOn: arg3.  arg2 ifTrue: [ arg3 nextPutAll: (tmp3 < 10 ifTrue: [ ':0' ] ifFalse: [ ':' ]).        tmp3 printOn: arg3.        nanos = 0 ifFalse: [ | tmp4 tmp5 |              tmp4 := nanos.              tmp5 := 9.              [ tmp4 \\ 10 = 0 ] whileTrue: [ tmp4 := tmp4 / 10.                    tmp5 := tmp5 - 1 ].              arg3 nextPut: $..              tmp4 printOn: arg3 base: 10 length: tmp5 padded: true ] ].  arg1 ifFalse: [ arg3 nextPutAll: (tmp1 < 12 ifTrue: [ ' am' ] ifFalse: [ ' pm' ]) ]testOnForkSplit  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self     flag: 'This test is too brittle, failing often on CI';     skip.  tmp1 := Semaphore new.  [ 1 / 0 ] on: Exception fork: [ | tmp6 |        tmp3 := IdentitySet new.        tmp6 := thisContext.        [ tmp6 notNil ] whileTrue: [ tmp3 add: tmp6.              tmp6 := tmp6 sender ].        tmp1 signal ].  tmp2 := tmp1 waitTimeoutSeconds: 1.  self assert: tmp2 == false description: 'fork lasted more than one second'.  tmp4 := IdentitySet new.  tmp5 := thisContext.  [ tmp5 notNil ] whileTrue: [ tmp4 add: tmp5.        tmp5 := tmp5 sender ].  self assert: (tmp4 noneSatisfy: [:arg1 |  tmp3 includes: arg1 ]) description: 'myContexts are not within forkedContexts'.  self assert: (tmp3 noneSatisfy: [:arg1 |  tmp4 includes: arg1 ]) description: 'forkedContexts are not within myContexts'acceptsLoggingOfCompilation  ^truerecompile  ^self methodClass recompile: self selectorclassThatDefinesClassVariable: arg1  (self classPool includesKey: arg1 asSymbol) ifTrue: [ ^self ].  ^self superclass ifNotNil: [ self superclass classThatDefinesClassVariable: arg1 ]testTo  self assert: (aDateAndTime to: aDateAndTime) equals: ((DateAndTime year: 1970 month: 1 day: 1) to: (DateAndTime year: 1970 month: 1 day: 1))testYearMonthDayHourMinuteSecondNanosSecondOffset  self assert: aDateAndTime equals: (DateAndTime year: 1980 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours).  self assert: (DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours) + (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) equals: (DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)testSupplySeveralAnswersToSeveralQuestions  self should: [ #(false true) = ([ {(self confirm: 'One') .               (self confirm: 'Two')} ] valueSupplyingAnswers: #(#('One' false) #('Two' true))) ].  self should: [ #(true false) = ([ {(self confirm: 'One') .               (self confirm: 'Two')} ] valueSupplyingAnswers: #(#('One' true) #('Two' false))) ]nbCall: arg1 module: arg2 options: arg3  < ffiCalloutTranslator>  self deprecated: 'use ffiCall:module:options: instead'.  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     options: arg3;     function: arg1 library: arg2gtDisplayString  | tmp1 tmp2 |  tmp2 := 1000.  tmp1 := String streamContents: [:arg1 |  self gtDisplayOn: arg1 ] limitedTo: tmp2.  tmp1 size < tmp2 ifTrue: [ ^tmp1 ].  ^tmp1 , ' ...'spotterActDefault  ^self method browse- arg1  < primitive: 42>  ^arg1 adaptToFloat: self andSend: #-valueNoContextSwitch  < primitive: 209>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  self primitiveFailedtestIsLiteral  self assert: nil isLiteralyearsDo: arg1  self do: arg1 with: start asYearcheckDynamic: arg1  self assert: TestDynamicVariable value equals: arg1abstractBytecodeMessagesDo: arg1  ^self compiledBlock abstractBytecodeMessagesDo: arg1setPinned: arg1  self setPinnedInMemory: arg1numberOfCategoryOfElement: arg1  | tmp1 |  tmp1 := elementArray identityIndexOf: arg1 asSymbol ifAbsent: [ ^0 ].  ^categoryStops findFirst: [:arg2 |  arg2 >= tmp1 ]scanner  ^InstructionStream on: selfgtInspectorAllReferencesIn: arg1  < gtInspectorPresentationOrder: 20>  arg1 list     title: 'All Ref';     display: [ (SystemNavigation default allReferencesTo: self binding) sorted: [:arg2 :arg3 |  arg2 name < arg3 name ] ];     format: #name;     tags: [:arg4 |  {arg4 package name} ]testHash  self assert: aDateAndTime hash equals: (DateAndTime year: 1970 month: 1 day: 1) hashenvironmentKeyNotFound  self error: 'Environment key not found'duringTestCompileSilently: arg1 storeSource: arg2  ^self duringTestCompileSilently: arg1 storeSource: arg2 classified: #UnclassifiedtestMutateByteSymbolUsingPrivateAtPut  | tmp1 |  [ tmp1 := #hello.  tmp1 beReadOnlyObject.  self should: [ tmp1 privateAt: 1 put: $q ] raise: ModificationForbidden ] ensure: [ tmp1 beWritableObject ].  self assert: tmp1 first equals: $hyourself  ^selfsomeInstance  < primitive: 77>  ^niltestDeepCopy  self assert: nil deepCopy isNilhasPositiveExtent  ^corner x > origin x and: [ corner y > origin y ]debug: arg1 title: arg2 full: arg3  ^UIManager default debugProcess: self context: arg1 label: arg2 fullView: arg3drTestsName  ^self selector asStringtestNanoSecond  self assert: aDateAndTime nanoSecond equals: 0includesKey: arg1  1 to: self basicSize do: [:arg2 |  (self basicAt: arg2) key == arg1 ifTrue: [ ^true ] ].  ^falsestackOfSize: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp1 addLast: (tmp2 := self).  [ (tmp2 := tmp2 sender) ~~ nil and: [ tmp1 size < arg1 ] ] whileTrue: [ tmp1 addLast: tmp2 ].  ^tmp1testthoroughWhichMethodsReferTo  | tmp1 |  tmp1 := #(thisIsOnlyHereIntestthoroughWhichMethodsReferTo).  self assert: (Point thoroughWhichMethodsReferTo: #x) notEmpty.  self assert: (Point thoroughWhichMethodsReferTo: #+) notEmpty.  self assert: (self class thoroughWhichMethodsReferTo: tmp1 first) notEmpty.  self assert: (self class thoroughWhichMethodsReferTo: ('this' , 'doesNotExist') asSymbol) isEmptyhandleFailingBasicNew: arg1  < primitive: 71>  | tmp1 |  tmp1 := self byteSizeOfInstanceOfSize: arg1.  Smalltalk garbageCollect < tmp1 ifTrue: [ Smalltalk growMemoryByAtLeast: tmp1 ].  ^self handleFailingFailingBasicNew: arg1testNaN5  self assert: ((Float nan asIEEE32BitWord printPaddedWith: $0 to: 32 base: 2) copyFrom: 2 to: 9) equals: '11111111'.  self assert: (Float fromIEEE32Bit: (Integer readFrom: '01111111110000000000000000000000' readStream base: 2)) isNaNtestMinute  self assert: aDateAndTime minute equals: 0removeDangerouslyKey: arg1 ifAbsent: arg2  | tmp1 tmp2 |  tmp1 := self findElementOrNil: arg1.  (self basicAt: tmp1) ifNil: [ ^arg2 value ].  tmp2 := array at: tmp1.  array at: tmp1 put: nil.  self basicAt: tmp1 put: nil.  tally := tally - 1.  self fixCollisionsFrom: tmp1.  ^tmp2testReadFromNoException  #('0:00:00:00' '0:00:00:00.000000001' '0:00:00:00.999999999' '0:00:00:00.100000000' '0:00:00:00.10' '0:00:00:00.1' '0:00:00:01' '0:12:45:45' '1:00:00:00' '365:00:00:00' '-7:09:12:06.10' '+0:01:02:55' '+0:01:02:3') do: [:arg1 |  arg1 asDuration printString = arg1 ]genPushReceiver  stream nextPut: 76inspectOnce  | tmp1 |  tmp1 := thisContext sender sourceNodeExecuted.  (tmp1 hasProperty: #Once) ifTrue: [ ^self ].  tmp1 propertyAt: #Once put: true.  ^self inspectoldDefinition  ^self definitionaddCategory: arg1 before: arg2  | tmp1 tmp2 |  tmp2 := arg1 asSymbol.  (categoryArray indexOf: tmp2) > 0 ifTrue: [ ^self ].  tmp1 := categoryArray indexOf: arg2 ifAbsent: [ categoryArray size + 1 ].  categoryArray := categoryArray copyReplaceFrom: tmp1 to: tmp1 - 1 with: (Array with: tmp2).  categoryStops := categoryStops copyReplaceFrom: tmp1 to: tmp1 - 1 with: (Array with: (tmp1 = 1 ifTrue: [ 0 ] ifFalse: [ categoryStops at: tmp1 - 1 ])).  (tmp2 ~= Default and: [ (self listAtCategoryNamed: Default) isEmpty ]) ifTrue: [ self removeCategory: Default ]preemptedProcess  | tmp1 |  activeProcess priority to: 1 by: -1 do: [:arg1 |  tmp1 := quiescentProcessLists at: arg1.        tmp1 isEmpty ifFalse: [ ^tmp1 last ] ].  ^niltestIsReferenced  self assert: Object isReferenced.  self deny: Object class isReferencedmarkerOrNil  ^self encoderClass markerOrNilFor: selftestHour12  self assert: aDateAndTime hour12 equals: DateAndTime new hour12.  self assert: aDateAndTime hour12 equals: 12xor: arg1  ^arg1 value notfullPrintString  ^String streamContents: [:arg1 |  self printOn: arg1 ]testDaysInMonthForYear  self assert: (Date daysInMonth: #February forYear: 2008) equals: 29.  self assert: (Date daysInMonth: #February forYear: 2000) equals: 29.  self assert: (Date daysInMonth: #February forYear: 2100) equals: 28.  self assert: (Date daysInMonth: #July forYear: 2100) equals: 31basicCheck: arg1  arg1 isDeprecated ifTrue: [ ^false ].  ^arg1 overriddenMethods anySatisfy: #isDeprecatedtestEncodingSourcePointer  | tmp1 |  tmp1 := CompiledMethodTrailer new.  CompiledMethod allInstancesDo: [:arg1 |  | tmp2 |        tmp1 method: arg1.        self assert: (tmp2 := arg1 sourcePointer) identicalTo: tmp1 sourcePointer.        tmp2 ~= 0 ifTrue: [ self assert: arg1 endPC equals: tmp1 endPC ] ]printOn: arg1  self printOn: arg1 format: #(1 2 3 $  3 1)round: arg1  ^(super round: arg1) asScaledDecimal: (scale max: arg1)testNew  self should: [ UndefinedObject new ] raise: ErrortestIsOpenPunctuation  self checkCorrespondanceOf: #isOpenPunctuation: and: #PstallyCPUUsageFor: arg1  ^self tallyCPUUsageFor: arg1 every: 10testSharedPools  self assert: Point sharedPools equals: OrderedCollection new.  self assert: Date sharedPools first equals: ChronologyConstants.  self assert: Date sharedPools size equals: 1.  Date class sharedPools.  self assert: RootClassPoolUser sharedPools size equals: 1.  self assert: ClassMultiplePoolUser sharedPools size equals: 2.  self assertEmpty: SubclassPoolUser sharedPoolstestAsWeek  self assert: aTimespan asWeek equals: jan01 asWeektestNestedLoopsExample1  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp1     add: #(#a #b);     add: #(1 2 3 4);     add: #('w' 'x' 'y' 'z').  tmp2 := OrderedCollection new.  CollectionCombinator new forArrays: tmp1 processWith: [:arg1 |  tmp2 addLast: arg1 ].  self assert: (self nestedLoopsExample: tmp1) equals: tmp2deprecatedMethod4  self deprecated: 'Example of a deprecated method with transform' on: '01/01/1970' in: #Pharo6 transformWith: '`@receiver deprecatedMethod4' -> '`@receiver deprecatedMethod4'quo: arg1  | tmp1 tmp2 |  arg1 isInteger ifTrue: [ tmp1 := self negative == arg1 negative == false.        tmp2 := (self digitDiv: arg1 neg: tmp1) at: 1.        ^tmp2 normalize ].  ^arg1 adaptToInteger: self andSend: #quo:bindingOf: arg1  ^self instanceSide classBindingOf: arg1montgomeryDigitLength  < primitive: 'primMontgomeryDigitLength' module: 'LargeIntegers'>  ^8cannotInterpret: arg1  (self class lookupSelector: arg1 selector) ifNotNil: [ ^arg1 sentTo: self ].  Error signal: 'MethodDictionary fault'.  ^arg1 sentTo: selftestHours  self assert: aDuration hours equals: 2.  self assert: (Duration hours: 2) hours equals: 2testAsYear  self assert: aTimespan asYear equals: jan01 asYeargroup  ^'Design Flaws'receiver: arg1  receiver := arg1gtInspectorDetailsIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 table     title: 'Details';     display: [ {('iso' -> self yyyymmdd) .         ('year' -> self year) .         ('month' -> self monthIndex) .         ('month name' -> self monthName) .         ('day of month' -> self dayOfMonth) .         ('day of week' -> self dayOfWeekName) .         ('day of year' -> self dayOfYear)} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valueasWeek  ^selfglamourValueWithArgs: arg1  self numArgs = 0 ifTrue: [ ^self value ].  self numArgs = arg1 size ifTrue: [ ^self valueWithArguments: arg1 ].  self numArgs > arg1 size ifTrue: [ ^self valueWithArguments: arg1 , (Array new: self numArgs - arg1 size) ].  ^self valueWithArguments: (arg1 copyFrom: 1 to: self numArgs)numArgs  ^args sizetruncateTo: arg1  ^self class nanoSeconds: (self asNanoSeconds truncateTo: arg1 asNanoSeconds)testIfNil  < haltOrBreakpointForTesting>  self should: [ nil ifNil: [ self error ] ] raise: ErrorasDateAndTime  ^selfsizeJump: arg1  ^self sizeOpcodeSelector: #genJump: withArguments: {arg1}genSendSuper: arg1 numArgs: arg2  arg2 < 0 ifTrue: [ ^self outOfRangeError: 'numArgs' index: arg2 range: 0 to: 31 ].  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'selector literal index' index: arg1 range: 0 to: 255 ].  (arg1 < 32 and: [ arg2 < 8 ]) ifTrue: [ stream           nextPut: 133;           nextPut: (arg2 bitShift: 5) + arg1.        ^self ].  (arg1 < 256 and: [ arg2 < 32 ]) ifTrue: [ stream           nextPut: 132;           nextPut: 32 + arg2;           nextPut: arg1.        ^self ].  arg2 >= 32 ifTrue: [ ^self outOfRangeError: 'numArgs' index: arg2 range: 0 to: 31 ].  arg1 >= 256 ifTrue: [ ^self outOfRangeError: 'selector literal index' index: arg1 range: 0 to: 255 ]subclass: arg1 slots: arg2 classVariables: arg3 package: arg4  ^self subclass: arg1 slots: arg2 classVariables: arg3 poolDictionaries: '' package: arg4wait: arg1 onCompletion: arg2 onTimeout: arg3  | tmp1 |  tmp1 := DelayWaitTimeout new setDelay: arg1 asMilliSeconds forSemaphore: self.  ^tmp1 waitOnCompletion: arg2 onTimeout: arg3setUp  super setUp.  checkerBackup := PharoBootstrapRule classVarNamed: 'DependencyChecker'defaultSelector  ^#DoIt numArgs: self numArgsnewProcess  < primitive: 19>  ^Process forContext: [ self value.        Processor terminateActive ] asContext priority: Processor activePriorityprintOn: arg1 base: arg2  self subclassResponsibilitydate  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self high16Bits.  tmp2 := tmp1 >> 9.  tmp3 := tmp1 >> 5 & 2r1111.  tmp4 := tmp1 & 2r11111.  tmp5 := self epoch year + tmp2.  ^Date year: tmp5 month: tmp3 day: tmp4testMutateObjectInstVarUsingInstVarAtPut  | tmp1 |  tmp1 := WriteBarrierStub new.  tmp1 beReadOnlyObject.  self should: [ tmp1 instVarAt: 1 put: #test ] raise: ModificationForbidden.  [ tmp1 instVarAt: 1 put: #test ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 var1 equals: #testisObsolete  ^self instanceCount = 0basicAt: arg1 put: arg2  < primitive: 211>  arg1 isInteger ifTrue: [ self errorSubscriptBounds: arg1 ].  arg1 isNumber ifTrue: [ ^self at: arg1 asInteger put: arg2 ] ifFalse: [ self errorNonIntegerIndex ]useNonUtcTimeZoneDuring: arg1  self useTimeZone: 'EDT' during: arg1testSlotNamed  self assert: (Point slotNamed: #x) name equals: #xto: arg1  ^Interval from: self to: arg1 by: 1executeMethod: arg1  ^self withArgs: #() executeMethod: arg1tempNames  ^self ast argumentNames , self ast temporaryNamesgetSourceFromFile  ^[ SourceFiles sourceCodeAt: self sourcePointer ] on: Error do: [ '' ]aboutToReturn: arg1 through: arg2  self methodReturnContext return: arg1 through: arg2testEpoch  self assert: aDateAndTime equals: '1980-01-01T00:00:00+00:00' asDateAndTimetestStartingEnding  self assert: aTimespan equals: (Timespan starting: jan01 ending: jan08)compileSilently: arg1 classified: arg2 notifying: arg3  ^SystemAnnouncer uniqueInstance suspendAllWhile: [ self compile: arg1 classified: arg2 notifying: arg3 ]qCompress: arg1  | tmp1 tmp2 tmp3 |  arg1 isEmpty ifTrue: [ ^self qCompress: ' ' ].  tmp1 := arg1 convertToEncoding: 'utf8'.  tmp2 := WriteStream on: (ByteArray new: tmp1 size).  tmp3 := nil.  tmp1 do: [:arg2 |  | tmp4 |        tmp4 := 'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()' indexOf: arg2 ifAbsent: 0.        (tmp4 = 0 ifTrue: [ {0 .               (arg2 asInteger // 16) .               (arg2 asInteger \\ 16)} ] ifFalse: [ tmp4 <= 11 ifTrue: [ {tmp4} ] ifFalse: [ {(tmp4 // 16 + 12) .                     (tmp4 \\ 16)} ] ]) do: [:arg3 |  tmp3 ifNotNil: [ tmp2 nextPut: tmp3 * 16 + arg3.                    tmp3 := nil ] ifNil: [ tmp3 := arg3 ] ] ].  tmp3 ifNotNil: [ tmp2 nextPut: tmp3 * 16 + 4 ].  ^tmp2asSeconds  ^(self - self class epoch) asSecondstestTerminationShouldProceedEnsureBlocks  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp3 := Semaphore new.  tmp2 := [ [ tmp3 signal.  [ 10 milliSeconds wait ] repeat ] ensure: [ tmp1 := true ] ] fork.  tmp3 wait.  tmp2 terminate.  self assert: tmp1storeIntoTemporaryVariable: arg1  self at: arg1 + 1 put: self topffiCall: arg1 module: arg2  < ffiCalloutTranslator>  self ffiCall: arg1 library: arg2initialize  super initialize.  methodSelectors := IdentitySet new.  name := self class defaultNamenormalize  < primitive: 'primNormalizePositive' module: 'LargeIntegers'>  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := tmp4 := self bytesCount.  [ tmp3 = 0 ifTrue: [ ^0 ].  (self byteAt: tmp3) = 0 ] whileTrue: [ tmp3 := tmp3 - 1 ].  tmp1 := SmallInteger maxVal > 16r3FFFFFFF ifTrue: [ 8 ] ifFalse: [ 4 ].  (tmp3 <= tmp1 and: [ (self byteAt: tmp1) <= (SmallInteger maxVal byteAt: tmp1) ]) ifTrue: [ tmp2 := 0.        tmp3 to: 1 by: -1 do: [:arg1 |  tmp2 := tmp2 * 256 + (self byteAt: arg1) ].        ^tmp2 ].  tmp3 < tmp4 ifTrue: [ ^self growto: tmp3 ] ifFalse: [ ^self ]instanceVariableWriteNodes  ^self ast instanceVariableWriteNodessetTraitComposition: arg1  ^self classInstaller update: self to: [:arg2 |  arg2           fillFor: self;           traitComposition: arg1 asTraitComposition;           classTraitComposition: arg1 asTraitComposition classComposition ]quo: arg1  < primitive: 33>  ^super quo: arg1reciprocalModulo: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  (self <= 0 or: [ arg1 <= 0 ]) ifTrue: [ self error: 'self and n must be greater than zero' ].  self >= arg1 ifTrue: [ self error: 'self must be < n' ].  tmp5 := arg1 highBit + 1.  tmp3 := 1 bitShift: tmp5.  tmp2 := (self bitShift: tmp5) + 1.  tmp1 := arg1 bitShift: tmp5.  tmp4 := tmp3 + arg1.  [ tmp2 >= tmp4 ] whileTrue: [ tmp2 := tmp1 \\ (tmp1 := tmp2) ].  tmp6 := tmp2 - tmp3.  (tmp7 := tmp6 + arg1) > 0 ifFalse: [ self error: 'no inverse' ].  ^tmp6 positive ifTrue: [ tmp6 ] ifFalse: [ tmp7 ]testAsDateAndTime  self assert: aTime asDateAndTime equals: DateAndTime current midnight + aTimemethodClass: arg1  ^self numLiterals > 0 ifTrue: [ self literalAt: self numLiterals put: arg1 binding ]bitClear: arg1  ^(self bitOr: arg1) - arg1usesPrimaryBytecodeSet  ^self header >= 0abstractMethod  ^self subclassResponsibilitytestSimpleCallCC  | tmp1 tmp2 |  tmp1 := self callcc: [:arg1 |  tmp2 := arg1.        false ].  tmp1 ifFalse: [ tmp2 value: true ].  self assert: tmp1printOn: arg1  self outerContext ifNil: [ | tmp1 tmp2 tmp3 |        self method == nil ifTrue: [ ^super printOn: arg1 ].        tmp2 := self receiver class.        tmp3 := self methodClass.        tmp1 := self selector ifNil: [ self method defaultSelector ].        arg1 nextPutAll: tmp2 name.        tmp3 == tmp2 ifFalse: [ arg1 nextPut: $(.              arg1 nextPutAll: tmp3 name.              arg1 nextPut: $) ].        arg1 nextPutAll: '>>'.        arg1 nextPutAll: tmp1.        tmp1 = #doesNotUnderstand: ifTrue: [ arg1 space.              (self tempAt: 1) selector printOn: arg1 ] ] ifNotNil: [:arg2 |  arg1 nextPutAll: closureOrNil printString , ' in '.        arg2 printOn: arg1 ]remove: arg1 oneStarWithTry: arg2 continuation: arg3  ^arg2 ifNil: [ arg3 value: #absent ] ifNotNil: [ | tmp1 tmp2 tmp3 |        tmp1 := arg2 value.        tmp2 := arg2 nextLink.        tmp3 := [ | tmp4 |        tmp4 := self remove: arg1 oneStarWithTry: tmp2 continuation: arg3.        tmp1 ~~> tmp4 ].        (tmp1 isMemberOf: ValueLink) ifTrue: [ Continuation try: [:arg4 |  | tmp5 |                    tmp5 := self remove: arg1 oneStarWithTry: tmp1 continuation: arg4.                    tmp5 ~~> tmp2 ] otherwise: tmp3 ] ifFalse: [ arg1 = tmp1 ifTrue: [ tmp2 ] ifFalse: tmp3 ] ]collectionsPackages  ^(CollectionsAssembly parts collect: #key) reject: [:arg1 |  arg1 = #'Collections-Atomic' ]example2: arg1  < sampleInstance>  | tmp1 tmp2 |  tmp2 := OrderedCollection new.  tmp1 := [:arg2 :arg3 :arg4 |  | tmp3 |  tmp3 := [:arg5 |  arg5 add: arg2.  arg3 value: arg5 ].  arg2 = 1 ifTrue: [ tmp3 value: arg4.        1 ] ifFalse: [ (tmp1 value: arg2 - 1 value: tmp3 value: arg4) * arg2 ] ].  tmp1 value: arg1 value: [:arg5 |   ] value: tmp2.  ^tmp2testAsDate  self assert: aDateAndTime asDate equals: ('February 29, 2004' asDate translateTo: 2 hours)testConvertFromInteger  | tmp1 |  tmp1 := 13 asScaledDecimal.  self assert: 0 equals: tmp1 scale.  self assert: '13s0' equals: tmp1 printString.  tmp1 := -13 asScaledDecimal.  self assert: 0 equals: tmp1 scale.  self assert: '-13s0' equals: tmp1 printString.  tmp1 := 130000000013 asScaledDecimal.  self assert: 0 equals: tmp1 scale.  self assert: '130000000013s0' equals: tmp1 printString.  tmp1 := -130000000013 asScaledDecimal.  self assert: 0 equals: tmp1 scale.  self assert: '-130000000013s0' equals: tmp1 printStringtestExampleFromSwikiPage  | tmp1 tmp2 |  tmp1 := Year current asMonth dates detect: [:arg1 |  arg1 dayOfWeekName = #Saturday ].  tmp1 := tmp1 start + (Duration hours: 20.5).  tmp2 := Schedule starting: tmp1 ending: Year current end.  tmp2 schedule: {(Duration days: 1) .         (Duration days: 6)}.  tmp2 dateAndTimes.  tmp2 dateAndTimes collect: [:arg2 |  arg2 dayOfWeekName ]dayOfYear  ^self dayMonthYearDo: [:arg1 :arg2 :arg3 |  | tmp1 |        tmp1 := #(1 32 60 91 121 152 182 213 244 274 305 335) at: arg2.        (arg2 > 2 and: [ Year isLeapYear: arg3 ]) ifTrue: [ tmp1 + arg1 ] ifFalse: [ tmp1 + arg1 - 1 ] ]propertyAt: arg1 put: arg2  | tmp1 |  (tmp1 := self penultimateLiteral) isMethodProperties ifFalse: [ self penultimateLiteral: ((self class methodPropertiesClass selector: tmp1 with: (Association key: arg1 asSymbol value: arg2))                 setMethod: self;                 yourself).        ^arg2 ].  (tmp1 includesProperty: arg1) ifTrue: [ ^tmp1 at: arg1 put: arg2 ].  self penultimateLiteral: (tmp1 copyWith: (Association key: arg1 asSymbol value: arg2)).  ^arg2testIsDecimalDigit  self checkCorrespondanceOf: #isDecimalDigit: and: #NdtestIsOtherSymbol  self checkCorrespondanceOf: #isOtherSymbol: and: #SosecondsSinceMidnightUTC  ^secondstestIsEnclosingMark  self checkCorrespondanceOf: #isEnclosingMark: and: #MeshouldFileOutPool: arg1  ^self confirm: 'FileOut the sharedPool ' , arg1 , '?'right: arg1  ^origin corner: arg1 @ corner ytestBytecode  | tmp1 tmp2 |  tmp1 := Object >> #halt.  tmp2 := (tmp1 encoderClass name endsWith: 'SistaV1') ifTrue: [ #[16 129 216 88] ] ifFalse: [ #[64 209 135 120] ].  self assertCollection: (Object >> #halt) bytecode equals: tmp2>= arg1  ^arg1 <= selfat: arg1 putLink: arg2  | tmp1 tmp2 |  (self validIndex: arg1) ifFalse: [ ^self errorOutOfBounds ].  arg1 = 1 ifTrue: [ arg2 nextLink: self firstLink nextLink.        firstLink := arg2.        arg2 nextLink ifNil: [ lastLink := arg2 ].        ^arg2 ].  tmp1 := self linkAt: arg1 - 1.  tmp2 := tmp1 nextLink nextLink.  tmp2 ifNil: [ arg2 nextLink: self lastLink ] ifNotNil: [ arg2 nextLink: tmp2 ].  tmp1 nextLink: arg2.  tmp2 ifNil: [ lastLink := arg2.        arg2 nextLink: nil ].  ^arg2activateReturn: arg1 value: arg2  ^Processor activeProcess evaluate: [ suspendedContext := suspendedContext activateReturn: arg1 value: arg2 ] onBehalfOf: selfvalueSupplyingMetacelloAnswers: arg1  ^[ self value ] on: ProvideAnswerNotification do: [:arg2 |  | tmp1 |        tmp1 := arg2 messageText withSeparatorsCompacted.        arg1 detect: [:arg3 |  tmp1 = arg3 first or: [ (tmp1 includesSubstring: arg3 first caseSensitive: false) or: [ (arg3 first match: tmp1) or: [ (String includesSelector: #matchesRegex:) and: [ [ tmp1 matchesRegex: arg3 first ] on: Error do: [:arg4 |  false ] ] ] ] ] ] ifFound: [:arg5 |  arg2 resume: arg5 second ] ifNone: [ | tmp2 |              tmp2 := ProvideAnswerNotification signal: arg2 messageText.              tmp2 ifNil: [ arg2 resume ] ifNotNil: [ arg2 resume: tmp2 ] ] ]followingPc  ^self nextPc: (self method at: pc)successor  | tmp1 |  self isFinite ifFalse: [ (self isNaN or: [ self positive ]) ifTrue: [ ^self ].        ^Float fmax negated ].  self = 0.0 ifTrue: [ ^Float fmin ].  tmp1 := self ulp.  ^self + (0.5 * tmp1) = self ifTrue: [ self + tmp1 ] ifFalse: [ self + (0.5 * tmp1) ]readSlotNamed: arg1  ^(self class slotNamed: arg1) read: selfcondition: arg1  condition := arg1isNaN  ^falsetestSimpleIsNested  self assertSuccess: (ExceptionTester new runTest: #simpleIsNestedTest)criticClass  ^self methodClasssetUp  super setUp.  ticker := self classForTicker new.  suspendedDelaysHeap := self classForScheduler defaultSuspendedDelaysHeap.  scheduler := self classForScheduler onTicker: ticker suspendedDelaysHeap: suspendedDelaysHeap.  scheduler startTimerEventLoopPriority: Processor activePriority + 1.  DebugMe ifNil: [ DebugMe := false ].  scheduler debug: DebugMepointersTo  ^self pointersToExcept: #()at: arg1 put: arg2  | tmp1 tmp2 |  arg1 > 0 ifTrue: [ tmp1 := self basicSize.        arg1 <= tmp1 ifTrue: [ tmp2 := 0.              1 to: tmp1 do: [:arg3 |  (self basicAt: arg3) == nil ifFalse: [ (tmp2 := tmp2 + 1) = arg1 ifTrue: [ ^self basicAt: arg3 put: arg2 ] ] ] ] ].  self error: 'access with an index out of bounds'printOn: arg1 base: arg2 length: arg3 padded: arg4  | tmp1 tmp2 tmp3 tmp4 |  self < 0 ifTrue: [ tmp1 := self negated.        tmp3 := 1 ] ifFalse: [ tmp1 := self.        tmp3 := 0 ].  tmp2 := tmp1 numberOfDigitsInBase: arg2.  tmp3 := tmp3 + tmp2.  arg4 ifFalse: [ [ tmp3 < arg3 ] whileTrue: [ arg1 space.              tmp3 := tmp3 + 1 ] ].  tmp1 = self ifFalse: [ arg1 nextPut: $- ].  arg4 ifTrue: [ [ tmp3 < arg3 ] whileTrue: [ arg1 nextPut: $0.              tmp3 := tmp3 + 1 ] ].  tmp4 := arg2 raisedToInteger: tmp2 - 1.  [ tmp4 > 0 ] whileTrue: [ | tmp5 |        tmp5 := tmp1 // tmp4.        arg1 nextPut: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: tmp5 + 1).        tmp1 := tmp1 - (tmp5 * tmp4).        tmp4 := tmp4 // arg2 ]methodName  ^'testMethod'indexOfLiteral: arg1  2 to: self numLiterals - 1 do: [:arg2 |  arg1 == (self objectAt: arg2) ifTrue: [ ^arg2 - 1 ] ].  ^0testMonth  self assert: aTimespan month equals: 1.  self assert: aTimespan monthName equals: 'January'.  self assert: aTimespan monthIndex equals: 1decodeEmbeddedSourceZip  self decodeZipprecodeCommentOrInheritedCommentFor: arg1  | tmp1 tmp2 |  ^(tmp2 := self firstPrecodeCommentFor: arg1) isEmptyOrNil ifTrue: [ (self == Behavior or: [ self superclass == nil or: [ (tmp1 := self superclass whichClassIncludesSelector: arg1) == nil ] ]) ifFalse: [ tmp1 precodeCommentOrInheritedCommentFor: arg1 ] ] ifFalse: [ tmp2 ]asGlamorousArray  ^Array with: selfweakSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 category: arg4  ^self weakSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4assertCode: arg1 print: arg2  self assert: (self class evaluate: arg1) printString equals: arg2basicSqueakToIso  self deprecated: 'Use #basicPharoToIso instead.' transformWith: '`@receiver basicSqueakToIso' -> '`@receiver basicPharoToIso'.  ^self basicPharoToIsoinitialize  self initializeTicker: DelayMicrosecondTicker new suspendedDelaysHeap: DelayBasicScheduler defaultSuspendedDelaysHeaplog  | tmp1 |  self <= 0 ifTrue: [ ^DomainError signal: 'log is only defined for x > 0' from: 0 ].  numerator < denominator ifTrue: [ ^self reciprocal log negated ].  tmp1 := super log.  tmp1 isFinite ifTrue: [ ^tmp1 ].  ^numerator log - denominator logtestIsLetterModifier  self checkCorrespondanceOf: #isLetterModifier: and: #LmtestParsingMMPatternWithSingleDigitFails  self assertReading: '04.2.2345' as: 'dd.mm.yyyy' raise: DateErrorsignalerContext  ^signalContext findContextSuchThat: [:arg1 |  (arg1 receiver == self or: [ arg1 receiver == self class ]) not ]messageText  ^messageText ifNil: [ messageText := self standardMessageText ]testPrintStringNoOffset  | tmp1 tmp2 tmp3 |  tmp3 := DateAndTime localOffset hours positive ifTrue: [ '+' ] ifFalse: [ '-' ].  tmp1 := DateAndTime localOffset hours abs printStringPadded: 2.  tmp2 := DateAndTime localOffset minutes printStringPadded: 2.  self assert: '2002-05-16T17:20' asDateAndTime printString equals: ('2002-05-16T17:20:00{1}{2}:{3}' format: {tmp3 .               tmp1 .               tmp2}).  self assert: '2002-05-16T17:20:45' asDateAndTime printString equals: ('2002-05-16T17:20:45{1}{2}:{3}' format: {tmp3 .               tmp1 .               tmp2})hasMethodReturn  ^self compiledBlock hasMethodReturnwrappedInValueHolderIfNeeded  ^self asValueHoldertestContinuationExample1  | tmp1 |  tmp1 := (1 to: 20) asOrderedCollection.  self assert: (self continuationExample1: tmp1) equals: tmp1printOn: arg1 base: arg2 nDigits: arg3  | tmp1 tmp2 tmp3 tmp4 |  arg3 <= 1 ifTrue: [ arg3 <= 0 ifTrue: [ self error: 'Number of digits n should be > 0' ].        ^arg1 nextPut: (Character digitValue: self) ].  tmp1 := arg3 bitShift: -1.  tmp2 := arg2 raisedToInteger: tmp1.  tmp3 := self quo: tmp2.  tmp4 := self - (tmp3 * tmp2).  tmp3 printOn: arg1 base: arg2 nDigits: arg3 - tmp1.  tmp4 printOn: arg1 base: arg2 nDigits: tmp1testArithmetic  | tmp1 tmp2 tmp3 |  tmp1 := timespan + 2 days.  tmp2 := tmp1 - 2 days.  tmp3 := tmp1 - (DateAndTime year: 2003 month: 03 day: 20).  self     assert: tmp1 start equals: (DateAndTime year: 2003 month: 03 day: 24 hour: 12 minute: 0 second: 0);     assert: tmp1 duration equals: timespan duration;     assert: tmp2 start equals: timespan start;     assert: tmp2 duration equals: timespan duration.  self assert: tmp3 equals: (Duration days: 4 hours: 12 minutes: 0 seconds: 0)testNegativeIntegerPrinting  self assert: (-2 printStringBase: 2) equals: '-10'.  self assert: (-2 radix: 2) equals: '-10'.  self assert: -2 printStringHex equals: '-2'.  self assert: (-2 storeStringBase: 2) equals: '-2r10'.  self assert: -2 storeStringHex equals: '-16r2'.  self assert: (-21 printStringBase: 3) equals: '-210'.  self assert: (-21 radix: 3) equals: '-210'.  self assert: -21 printStringHex equals: '-15'.  self assert: (-21 storeStringBase: 3) equals: '-3r210'.  self assert: -21 storeStringHex equals: '-16r15'.  self assert: (-228 printStringBase: 4) equals: '-3210'.  self assert: (-228 radix: 4) equals: '-3210'.  self assert: -228 printStringHex equals: '-E4'.  self assert: (-228 storeStringBase: 4) equals: '-4r3210'.  self assert: -228 storeStringHex equals: '-16rE4'.  self assert: (-2930 printStringBase: 5) equals: '-43210'.  self assert: (-2930 radix: 5) equals: '-43210'.  self assert: -2930 printStringHex equals: '-B72'.  self assert: (-2930 storeStringBase: 5) equals: '-5r43210'.  self assert: -2930 storeStringHex equals: '-16rB72'.  self assert: (-44790 printStringBase: 6) equals: '-543210'.  self assert: (-44790 radix: 6) equals: '-543210'.  self assert: -44790 printStringHex equals: '-AEF6'.  self assert: (-44790 storeStringBase: 6) equals: '-6r543210'.  self assert: -44790 storeStringHex equals: '-16rAEF6'.  self assert: (-800667 printStringBase: 7) equals: '-6543210'.  self assert: (-800667 radix: 7) equals: '-6543210'.  self assert: -800667 printStringHex equals: '-C379B'.  self assert: (-800667 storeStringBase: 7) equals: '-7r6543210'.  self assert: -800667 storeStringHex equals: '-16rC379B'.  self assert: (-16434824 printStringBase: 8) equals: '-76543210'.  self assert: (-16434824 radix: 8) equals: '-76543210'.  self assert: -16434824 printStringHex equals: '-FAC688'.  self assert: (-16434824 storeStringBase: 8) equals: '-8r76543210'.  self assert: -16434824 storeStringHex equals: '-16rFAC688'.  self assert: (-381367044 printStringBase: 9) equals: '-876543210'.  self assert: (-381367044 radix: 9) equals: '-876543210'.  self assert: -381367044 printStringHex equals: '-16BB3304'.  self assert: (-381367044 storeStringBase: 9) equals: '-9r876543210'.  self assert: -381367044 storeStringHex equals: '-16r16BB3304'.  self assert: (-9876543210 printStringBase: 10) equals: '-9876543210'.  self assert: (-9876543210 radix: 10) equals: '-9876543210'.  self assert: -9876543210 printStringHex equals: '-24CB016EA'.  self assert: (-9876543210 storeStringBase: 10) equals: '-9876543210'.  self assert: -9876543210 storeStringHex equals: '-16r24CB016EA'.  self assert: (-282458553905 printStringBase: 11) equals: '-A9876543210'.  self assert: (-282458553905 radix: 11) equals: '-A9876543210'.  self assert: -282458553905 printStringHex equals: '-41C3D77E31'.  self assert: (-282458553905 storeStringBase: 11) equals: '-11rA9876543210'.  self assert: -282458553905 storeStringHex equals: '-16r41C3D77E31'.  self assert: (-8842413667692 printStringBase: 12) equals: '-BA9876543210'.  self assert: (-8842413667692 radix: 12) equals: '-BA9876543210'.  self assert: -8842413667692 printStringHex equals: '-80AC8ECF56C'.  self assert: (-8842413667692 storeStringBase: 12) equals: '-12rBA9876543210'.  self assert: -8842413667692 storeStringHex equals: '-16r80AC8ECF56C'.  self assert: (-300771807240918 printStringBase: 13) equals: '-CBA9876543210'.  self assert: (-300771807240918 radix: 13) equals: '-CBA9876543210'.  self assert: -300771807240918 printStringHex equals: '-1118CE4BAA2D6'.  self assert: (-300771807240918 storeStringBase: 13) equals: '-13rCBA9876543210'.  self assert: -300771807240918 storeStringHex equals: '-16r1118CE4BAA2D6'.  self assert: (-11046255305880158 printStringBase: 14) equals: '-DCBA9876543210'.  self assert: (-11046255305880158 radix: 14) equals: '-DCBA9876543210'.  self assert: -11046255305880158 printStringHex equals: '-273E82BB9AF25E'.  self assert: (-11046255305880158 storeStringBase: 14) equals: '-14rDCBA9876543210'.  self assert: -11046255305880158 storeStringHex equals: '-16r273E82BB9AF25E'.  self assert: (-435659737878916215 printStringBase: 15) equals: '-EDCBA9876543210'.  self assert: (-435659737878916215 radix: 15) equals: '-EDCBA9876543210'.  self assert: -435659737878916215 printStringHex equals: '-60BC6392F366C77'.  self assert: (-435659737878916215 storeStringBase: 15) equals: '-15rEDCBA9876543210'.  self assert: -435659737878916215 storeStringHex equals: '-16r60BC6392F366C77'.  self assert: (-18364758544493064720 printStringBase: 16) equals: '-FEDCBA9876543210'.  self assert: (-18364758544493064720 radix: 16) equals: '-FEDCBA9876543210'.  self assert: -18364758544493064720 printStringHex equals: '-FEDCBA9876543210'.  self assert: (-18364758544493064720 storeStringBase: 16) equals: '-16rFEDCBA9876543210'.  self assert: -18364758544493064720 storeStringHex equals: '-16rFEDCBA9876543210'.  self assert: (-824008854613343261192 printStringBase: 17) equals: '-GFEDCBA9876543210'.  self assert: (-824008854613343261192 radix: 17) equals: '-GFEDCBA9876543210'.  self assert: -824008854613343261192 printStringHex equals: '-2CAB6B877C1CD2D208'.  self assert: (-824008854613343261192 storeStringBase: 17) equals: '-17rGFEDCBA9876543210'.  self assert: -824008854613343261192 storeStringHex equals: '-16r2CAB6B877C1CD2D208'.  self assert: (-39210261334551566857170 printStringBase: 18) equals: '-HGFEDCBA9876543210'.  self assert: (-39210261334551566857170 radix: 18) equals: '-HGFEDCBA9876543210'.  self assert: -39210261334551566857170 printStringHex equals: '-84D97AFCAE81415B3D2'.  self assert: (-39210261334551566857170 storeStringBase: 18) equals: '-18rHGFEDCBA9876543210'.  self assert: -39210261334551566857170 storeStringHex equals: '-16r84D97AFCAE81415B3D2'.  self assert: (-1972313422155189164466189 printStringBase: 19) equals: '-IHGFEDCBA9876543210'.  self assert: (-1972313422155189164466189 radix: 19) equals: '-IHGFEDCBA9876543210'.  self assert: -1972313422155189164466189 printStringHex equals: '-1A1A75329C5C6FC00600D'.  self assert: (-1972313422155189164466189 storeStringBase: 19) equals: '-19rIHGFEDCBA9876543210'.  self assert: -1972313422155189164466189 storeStringHex equals: '-16r1A1A75329C5C6FC00600D'.  self assert: (-104567135734072022160664820 printStringBase: 20) equals: '-JIHGFEDCBA9876543210'.  self assert: (-104567135734072022160664820 radix: 20) equals: '-JIHGFEDCBA9876543210'.  self assert: -104567135734072022160664820 printStringHex equals: '-567EF3C9636D242A8C68F4'.  self assert: (-104567135734072022160664820 storeStringBase: 20) equals: '-20rJIHGFEDCBA9876543210'.  self assert: -104567135734072022160664820 storeStringHex equals: '-16r567EF3C9636D242A8C68F4'.  self assert: (-5827980550840017565077671610 printStringBase: 21) equals: '-KJIHGFEDCBA9876543210'.  self assert: (-5827980550840017565077671610 radix: 21) equals: '-KJIHGFEDCBA9876543210'.  self assert: -5827980550840017565077671610 printStringHex equals: '-12D4CAE2B8A09BCFDBE30EBA'.  self assert: (-5827980550840017565077671610 storeStringBase: 21) equals: '-21rKJIHGFEDCBA9876543210'.  self assert: -5827980550840017565077671610 storeStringHex equals: '-16r12D4CAE2B8A09BCFDBE30EBA'.  self assert: (-340653664490377789692799452102 printStringBase: 22) equals: '-LKJIHGFEDCBA9876543210'.  self assert: (-340653664490377789692799452102 radix: 22) equals: '-LKJIHGFEDCBA9876543210'.  self assert: -340653664490377789692799452102 printStringHex equals: '-44CB61B5B47E1A5D8F88583C6'.  self assert: (-340653664490377789692799452102 storeStringBase: 22) equals: '-22rLKJIHGFEDCBA9876543210'.  self assert: -340653664490377789692799452102 storeStringHex equals: '-16r44CB61B5B47E1A5D8F88583C6'.  self assert: (-20837326537038308910317109288851 printStringBase: 23) equals: '-MLKJIHGFEDCBA9876543210'.  self assert: (-20837326537038308910317109288851 radix: 23) equals: '-MLKJIHGFEDCBA9876543210'.  self assert: -20837326537038308910317109288851 printStringHex equals: '-1070108876456E0EF115B389F93'.  self assert: (-20837326537038308910317109288851 storeStringBase: 23) equals: '-23rMLKJIHGFEDCBA9876543210'.  self assert: -20837326537038308910317109288851 storeStringHex equals: '-16r1070108876456E0EF115B389F93'.  self assert: (-1331214537196502869015340298036888 printStringBase: 24) equals: '-NMLKJIHGFEDCBA9876543210'.  self assert: (-1331214537196502869015340298036888 radix: 24) equals: '-NMLKJIHGFEDCBA9876543210'.  self assert: -1331214537196502869015340298036888 printStringHex equals: '-41A24A285154B026B6ED206C6698'.  self assert: (-1331214537196502869015340298036888 storeStringBase: 24) equals: '-24rNMLKJIHGFEDCBA9876543210'.  self assert: -1331214537196502869015340298036888 storeStringHex equals: '-16r41A24A285154B026B6ED206C6698'.  self assert: (-88663644327703473714387251271141900 printStringBase: 25) equals: '-ONMLKJIHGFEDCBA9876543210'.  self assert: (-88663644327703473714387251271141900 radix: 25) equals: '-ONMLKJIHGFEDCBA9876543210'.  self assert: -88663644327703473714387251271141900 printStringHex equals: '-111374860A2C6CEBE5999630398A0C'.  self assert: (-88663644327703473714387251271141900 storeStringBase: 25) equals: '-25rONMLKJIHGFEDCBA9876543210'.  self assert: -88663644327703473714387251271141900 storeStringHex equals: '-16r111374860A2C6CEBE5999630398A0C'.  self assert: (-6146269788878825859099399609538763450 printStringBase: 26) equals: '-PONMLKJIHGFEDCBA9876543210'.  self assert: (-6146269788878825859099399609538763450 radix: 26) equals: '-PONMLKJIHGFEDCBA9876543210'.  self assert: -6146269788878825859099399609538763450 printStringHex equals: '-49FBA7F30B0F48BD14E6A99BD8ADABA'.  self assert: (-6146269788878825859099399609538763450 storeStringBase: 26) equals: '-26rPONMLKJIHGFEDCBA9876543210'.  self assert: -6146269788878825859099399609538763450 storeStringHex equals: '-16r49FBA7F30B0F48BD14E6A99BD8ADABA'.  self assert: (-442770531899482980347734468443677777577 printStringBase: 27) equals: '-QPONMLKJIHGFEDCBA9876543210'.  self assert: (-442770531899482980347734468443677777577 radix: 27) equals: '-QPONMLKJIHGFEDCBA9876543210'.  self assert: -442770531899482980347734468443677777577 printStringHex equals: '-14D1A80A997343640C1145A073731DEA9'.  self assert: (-442770531899482980347734468443677777577 storeStringBase: 27) equals: '-27rQPONMLKJIHGFEDCBA9876543210'.  self assert: -442770531899482980347734468443677777577 storeStringHex equals: '-16r14D1A80A997343640C1145A073731DEA9'.  self assert: (-33100056003358651440264672384704297711484 printStringBase: 28) equals: '-RQPONMLKJIHGFEDCBA9876543210'.  self assert: (-33100056003358651440264672384704297711484 radix: 28) equals: '-RQPONMLKJIHGFEDCBA9876543210'.  self assert: -33100056003358651440264672384704297711484 printStringHex equals: '-6145B6E6DACFA25D0E936F51D25932377C'.  self assert: (-33100056003358651440264672384704297711484 storeStringBase: 28) equals: '-28rRQPONMLKJIHGFEDCBA9876543210'.  self assert: -33100056003358651440264672384704297711484 storeStringHex equals: '-16r6145B6E6DACFA25D0E936F51D25932377C'.  self assert: (-2564411043271974895869785066497940850811934 printStringBase: 29) equals: '-SRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-2564411043271974895869785066497940850811934 radix: 29) equals: '-SRQPONMLKJIHGFEDCBA9876543210'.  self assert: -2564411043271974895869785066497940850811934 printStringHex equals: '-1D702071CBA4A1597D4DD37E95EFAC79241E'.  self assert: (-2564411043271974895869785066497940850811934 storeStringBase: 29) equals: '-29rSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -2564411043271974895869785066497940850811934 storeStringHex equals: '-16r1D702071CBA4A1597D4DD37E95EFAC79241E'.  self assert: (-205646315052919334126040428061831153388822830 printStringBase: 30) equals: '-TSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-205646315052919334126040428061831153388822830 radix: 30) equals: '-TSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -205646315052919334126040428061831153388822830 printStringHex equals: '-938B4343B54B550989989D02998718FFB212E'.  self assert: (-205646315052919334126040428061831153388822830 storeStringBase: 30) equals: '-30rTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -205646315052919334126040428061831153388822830 storeStringHex equals: '-16r938B4343B54B550989989D02998718FFB212E'.  self assert: (-17050208381689099029767742314582582184093573615 printStringBase: 31) equals: '-UTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-17050208381689099029767742314582582184093573615 radix: 31) equals: '-UTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -17050208381689099029767742314582582184093573615 printStringHex equals: '-2FC8ECB1521BA16D24A69E976D53873E2C661EF'.  self assert: (-17050208381689099029767742314582582184093573615 storeStringBase: 31) equals: '-31rUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -17050208381689099029767742314582582184093573615 storeStringHex equals: '-16r2FC8ECB1521BA16D24A69E976D53873E2C661EF'.  self assert: (-1459980823972598128486511383358617792788444579872 printStringBase: 32) equals: '-VUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-1459980823972598128486511383358617792788444579872 radix: 32) equals: '-VUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -1459980823972598128486511383358617792788444579872 printStringHex equals: '-FFBBCDEB38BDAB49CA307B9AC5A928398A418820'.  self assert: (-1459980823972598128486511383358617792788444579872 storeStringBase: 32) equals: '-32rVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -1459980823972598128486511383358617792788444579872 storeStringHex equals: '-16rFFBBCDEB38BDAB49CA307B9AC5A928398A418820'.  self assert: (-128983956064237823710866404905431464703849549412368 printStringBase: 33) equals: '-WVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-128983956064237823710866404905431464703849549412368 radix: 33) equals: '-WVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -128983956064237823710866404905431464703849549412368 printStringHex equals: '-584120A0328DE272AB055A8AA003CE4A559F223810'.  self assert: (-128983956064237823710866404905431464703849549412368 storeStringBase: 33) equals: '-33rWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -128983956064237823710866404905431464703849549412368 storeStringHex equals: '-16r584120A0328DE272AB055A8AA003CE4A559F223810'.  self assert: (-11745843093701610854378775891116314824081102660800418 printStringBase: 34) equals: '-XWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-11745843093701610854378775891116314824081102660800418 radix: 34) equals: '-XWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -11745843093701610854378775891116314824081102660800418 printStringHex equals: '-1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.  self assert: (-11745843093701610854378775891116314824081102660800418 storeStringBase: 34) equals: '-34rXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -11745843093701610854378775891116314824081102660800418 storeStringHex equals: '-16r1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.  self assert: (-1101553773143634726491620528194292510495517905608180485 printStringBase: 35) equals: '-YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-1101553773143634726491620528194292510495517905608180485 radix: 35) equals: '-YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -1101553773143634726491620528194292510495517905608180485 printStringHex equals: '-B8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.  self assert: (-1101553773143634726491620528194292510495517905608180485 storeStringBase: 35) equals: '-35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -1101553773143634726491620528194292510495517905608180485 storeStringHex equals: '-16rB8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.  self assert: (-106300512100105327644605138221229898724869759421181854980 printStringBase: 36) equals: '-ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (-106300512100105327644605138221229898724869759421181854980 radix: 36) equals: '-ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -106300512100105327644605138221229898724869759421181854980 printStringHex equals: '-455D441E55A37239AB4C303189576071AF5578FFCA80504'.  self assert: (-106300512100105327644605138221229898724869759421181854980 storeStringBase: 36) equals: '-36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: -106300512100105327644605138221229898724869759421181854980 storeStringHex equals: '-16r455D441E55A37239AB4C303189576071AF5578FFCA80504'packages  ^self extendingPackages asSet copy     add: self package;     yourselfstandardMessageText  ^String streamContents: [:arg1 |  arg1 << 'primitive '.        arg1 print: self selector.        arg1 << ' in '.        arg1 print: self signaler class.        arg1 << ' failed' ]isSelfEvaluating  ^self isObsolete nothasLinks  self deprecated: 'use #hasMetaLinks' transformWith: '`@receiver hasLinks' -> '`@receiver hasMetaLinks'.  ^self hasMetaLinkssend: arg1 to: arg2 with: arg3 lookupIn: arg4  | tmp1 tmp2 tmp3 tmp4 |  (tmp1 := arg4 lookupSelector: arg1) ifNil: [ ^self send: #doesNotUnderstand: to: arg2 with: {(Message selector: arg1 arguments: arg3)} lookupIn: arg4 ].  (tmp2 := tmp1 primitive) > 0 ifTrue: [ tmp3 := self doPrimitive: tmp2 method: tmp1 receiver: arg2 args: arg3.        (self isPrimFailToken: tmp3) ifFalse: [ ^tmp3 ] ].  (arg1 == #doesNotUnderstand: and: [ arg4 == ProtoObject ]) ifTrue: [ ^self error: 'Simulated message ' , arg3 first selector , ' not understood' ].  tmp4 := Context sender: self receiver: arg2 method: tmp1 arguments: arg3.  tmp2 > 0 ifTrue: [ tmp4 failPrimitiveWith: tmp3 ].  ^tmp4selectorsWithArgs: arg1  ^self selectors select: [:arg2 |  arg2 numArgs = arg1 ]ceiling  browse  ^Smalltalk tools browser openOnClass: self classsetSender: arg1 receiver: arg2 method: arg3 arguments: arg4  sender := arg1.  receiver := arg2.  method := arg3.  closureOrNil := nil.  pc := method initialPC.  self stackp: method numTemps.  1 to: arg4 size do: [:arg5 |  self at: arg5 put: (arg4 at: arg5) ]value  ^(Processor activeProcess psValueAt: index) ifNil: [ self default ]usesLocalPoolVarNamed: arg1  ^falseactionForEvent: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := self actionMap at: arg1 asSymbol ifAbsent: [ nil ].  tmp1 ifNil: [ ^arg2 value ].  ^tmp1 asMinimalRepresentationnotify: arg1 at: arg2  self notify: arg1testBadBase  self should: [ 2 printStringBase: 1 ] raise: ErrornonDeprecatedMethodName  ^'not' , self deprecatedMethodNametestIsLeapYear  self assert: (Year isLeapYear: 2000).  self deny: (Year isLeapYear: 2001).  self assert: (Year isLeapYear: 2004).  self deny: (Year isLeapYear: 2100).  self deny: (Year isLeapYear: 2002)testReadFromOffset  self assert: (DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream) offset printString equals: '-0:05:00:00'parseVariableDigitDay  day := self parse: 'day'testZero1  self assert: Float negativeZero equals: 0 asFloat.  self assert: (Float negativeZero at: 1) ~= (0 asFloat at: 1)epiceaBrowsersAsString  ^String streamContents: [:arg1 |  arg1           nextPutAll: self asDate epiceaBrowsersAsString;           nextPutAll: ', '.        self asTime print24: false showSeconds: false on: arg1 ]withAllSuperAndSubclasses  ^self allSuperclasses , self withAllSubclassesisNil  ^falsedigitSum  ^self abs asString inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 digitValue ]asText  ^self asString asTextspecies  ^TimespanargumentNamed: arg1  ^self argumentNamed: arg1 ifNone: [ self error: 'No argument of this name.' ]anyProcessesAbove: arg1  ^(Process allInstances select: [:arg2 |  arg2 priority > arg1 ]) isEmptytestDynamicVariableAccessFromDifferentProcess  | tmp1 tmp2 tmp3 |  tmp2 := Semaphore new.  tmp1 := [ TestDynamicVariable value: 123 during: [ tmp2 wait ] ] fork.  Processor yield.  Processor activeProcess evaluate: [ tmp3 := TestDynamicVariable value ] onBehalfOf: tmp1.  tmp2 signal.  self assert: tmp3 equals: 123link: arg1 toMethodNamed: arg2  self link: arg1 toAST: (MetalinkTargetResolver methodNamed: arg2 for: self)abstractBytecodeMessageAt: arg1  ^[ (InstructionStream new method: self pc: arg1) interpretNextInstructionFor: nil ] on: MessageNotUnderstood do: [:arg2 |  arg2 message ]classify: arg1 under: arg2  ^self classify: arg1 under: arg2 suppressIfDefault: truelocalAt: arg1 put: arg2  ^self at: arg1 put: arg2sizeOpcodeSelector: arg1 withArguments: arg2  stream := self.  position := 0.  self perform: arg1 withArguments: arg2.  ^positionundeclaredName  ^undeclaredNameaddDependent: arg1  | tmp1 |  tmp1 := self dependents.  (tmp1 includes: arg1) ifFalse: [ self myDependents: (tmp1 copyWithDependent: arg1) ].  ^arg1installValue: arg1 intoForked: arg2 from: arg3  super installValue: arg1 intoForked: arg2 from: arg3.  arg1 prepareForNewProcess: arg2retrySelector  ^retrySelectorcritical: arg1  | tmp1 tmp2 |  tmp2 := false.  [ tmp2 := true.  self wait.  tmp1 := arg1 value ] ensure: [ tmp2 ifTrue: [ self signal ] ].  ^tmp1digitValue  self asInteger > 255 ifTrue: [ ^self characterSet digitValueOf: self ].  ^DigitValues at: 1 + self asIntegerasTwoCharacterString  ^(self >= 0 and: [ self < 10 ]) ifTrue: [ '0' , self printString ] ifFalse: [ self printString copyFrom: 1 to: 2 ]classComment  ^self commentisEmpty  ^firstLink isNiltestIsEnclosingMark  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isEnclosingMark: tmp2) equals: (tmp1 isEnclosingMark: tmp2) ]size  < primitive: 62>  self class isVariable ifFalse: [ self errorNotIndexable ].  ^0testLargePrimesUpTo  | tmp1 |  tmp1 := (2 raisedTo: 17) - 1.  self deny: (Integer primesUpTo: tmp1) last equals: tmp1.  self assert: (Integer primesUpTo: tmp1 + 1) last equals: tmp1genJump: arg1  (arg1 > 0 and: [ arg1 < 9 ]) ifTrue: [ stream nextPut: 144 + arg1 - 1.        ^self ].  ^self genJumpLong: arg1genUnsignedSingleExtendB: arg1  (arg1 between: 0 and: 255) ifFalse: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255 ].  stream     nextPut: 225;     nextPut: arg1threeWayCompareTo: arg1  ^self = arg1 ifTrue: [ 0 ] ifFalse: [ self < arg1 ifTrue: [ -1 ] ifFalse: [ 1 ] ]testSetIsReadOnlyFailureProxy  self alwaysWritableObjects do: [:arg1 |  self testProxyObject: arg1 initialState: false tuples: #(#(true false false) #(false false false)) ]testPrintPaddedWithTo  self assert: (1.0 printPaddedWith: $0 to: 2.2) equals: '01.00'.  self assert: (1.0 printPaddedWith: $X to: 2.2) equals: 'X1.0X'.  self assert: (1.0 printPaddedWith: $0 to: 2) equals: '01.0'.  self assert: (12345.6789 printPaddedWith: $0 to: 2) equals: '12345.6789'.  self assert: (12345.6789 printPaddedWith: $0 to: 2.2) equals: '12345.6789'.  self assert: (12.34 printPaddedWith: $0 to: 2.2) equals: '12.34'.  self assert: (12345.6789 printPaddedWith: $0 to: 2.2) equals: '12345.6789'.  self assert: (123.456 printPaddedWith: $X to: 4.4) equals: 'X123.456X'.  self assert: (1.0 printPaddedWith: $0 to: 2.1) equals: '01.0'.  self assert: (1.0 printPaddedWith: $0 to: 2.2) equals: '01.00'.  self assert: (1.0 printPaddedWith: $0 to: 2.3) equals: '01.000'.  self assert: (1.0 printPaddedWith: $0 to: 2.4) equals: '01.0000'.  self assert: (1.0 printPaddedWith: $0 to: 2.5) equals: '01.00000'testMutateByteArrayUsingByteAtPut  | tmp1 |  tmp1 := ByteArray new: 5.  tmp1 beReadOnlyObject.  self should: [ tmp1 byteAt: 1 put: 12 ] raise: ModificationForbidden.  [ tmp1 byteAt: 1 put: 12 ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first equals: 12testWeekday  self assert: january23rd2004 weekday equals: #Friday.  self assert: january23rd2004 weekdayIndex equals: 6isSpLayout  ^falsetestAsUTC  self assert: aDateAndTime asUTC equals: aDateAndTimeisComposedBy: arg1  arg1 isTrait ifFalse: [ ^false ].  ^self hasTraitComposition ifTrue: [ self traitComposition includesTrait: arg1 ] ifFalse: [ false ]asFunction  ^self asFunction: #()testTicks  self assert: aDateAndTime ticks equals: ((DateAndTime julianDayNumber: 2453065) + 41580 seconds) ticks.  self assert: aDateAndTime ticks equals: #(2453065 41580 0)basicCategory  ^categorynoteCompilationOfMethod: arg1 meta: arg2  self noteCompilationOf: arg1 selector meta: arg2at: arg1 put: arg2  | tmp1 |  tmp1 := false.  1 to: self basicSize do: [:arg3 |  | tmp2 |        (tmp2 := self basicAt: arg3) key == arg1 ifTrue: [ tmp1 := true.              tmp2 isVariableBinding ifTrue: [ tmp2 value: arg2 ] ifFalse: [ self basicAt: arg3 put: arg2 ] ] ].  tmp1 ifFalse: [ method propertyAt: arg1 put: arg2 ].  ^arg2installEnvIntoForked: arg1  env ifNil: [ ^self ].  InheritablePSKeys ifNil: [ ^self ].  1 to: InheritablePSKeys size do: [:arg2 |  | tmp1 tmp2 |        tmp1 := InheritablePSKeys at: arg2.        tmp1 <= env size ifTrue: [ tmp2 := env at: tmp1.              tmp2 ifNotNil: [ (PSKeys at: tmp1) installValue: tmp2 intoForked: arg1 from: self ] ] ]isTestMethod  ^self subclassResponsibilityddmmyyyy  ^self printFormat: #(1 2 3 $/ 1 1)- arg1  ^(arg1 respondsTo: #asDateAndTime) ifTrue: [ self start - arg1 ] ifFalse: [ self + arg1 negated ]/ arg1  ^arg1 isNumber ifTrue: [ self class nanoSeconds: (self asNanoSeconds / arg1) asInteger ] ifFalse: [ self asNanoSeconds / arg1 asDuration asNanoSeconds ]restartTop  suspendedContext privRefreshsetTraitComposition: arg1  ^self subclassResponsibilityprintOn: arg1 base: arg2  arg1 nextPut: $-.  self abs printOn: arg1 base: arg2numTemps  ^(self header bitShift: -18) bitAnd: 16r3Fand: arg1  ^arg1 valuetestWorkDatesDo  | tmp1 |  tmp1 := 0.  aTimespan workDatesDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 5testAsNanoSeconds  self assert: (Duration nanoSeconds: 1) asNanoSeconds equals: 1.  self assert: (Duration seconds: 1) asNanoSeconds equals: 1000000000.  self assert: aDuration asNanoSeconds equals: 93784000000005storeDataOn: arg1  | tmp1 tmp2 |  tmp1 := self class instSize.  tmp2 := self basicSize.  arg1 beginInstance: self class size: tmp1 + tmp2.  1 to: tmp1 do: [:arg2 |  arg1 nextPut: (self instVarAt: arg2) ].  self class isBits ifFalse: [ 1 to: tmp2 do: [:arg2 |  arg1 nextPut: (self basicAt: arg2) ] ]testTicksOffset  self assert: aDateAndTime equals: (aDateAndTime ticks: #(2415386 0 0) offset: DateAndTime localOffset)scanFor: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self method.  tmp3 := tmp1 endPC.  tmp2 := tmp1 encoderClass.  [ pc <= tmp3 ] whileTrue: [ (arg1 value: (tmp4 := tmp1 at: pc)) ifTrue: [ ^true ].        pc := pc + (tmp2 bytecodeSize: tmp4) ].  ^falseinterpretNextSistaV1InstructionFor: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp4 := self method.  tmp5 := tmp6 := 0.  tmp7 := pc.  [ tmp1 := self method at: pc.  pc := pc + 1.  tmp1 between: 16rE0 and: 16rE1 ] whileTrue: [ | tmp8 |        tmp8 := self method at: pc.        pc := pc + 1.        tmp1 = 16rE0 ifTrue: [ tmp5 := (tmp5 bitShift: 8) + tmp8 ] ifFalse: [ tmp6 := (tmp6 = 0 and: [ tmp8 > 127 ]) ifTrue: [ tmp8 - 256 ] ifFalse: [ (tmp6 bitShift: 8) + tmp8 ] ] ].  tmp2 := tmp1 // 16.  tmp3 := tmp1 \\ 16.  tmp2 < 11 ifTrue: [ tmp2 < 6 ifTrue: [ tmp2 < 4 ifTrue: [ tmp2 < 2 ifTrue: [ tmp2 = 0 ifTrue: [ ^arg1 pushReceiverVariable: tmp3 ].                          ^arg1 pushLiteralVariable: (tmp4 literalAt: tmp3 + 1) ].                    ^arg1 pushConstant: (tmp4 literalAt: tmp1 \\ 32 + 1) ].              tmp2 = 4 ifTrue: [ tmp3 < 12 ifTrue: [ ^arg1 pushTemporaryVariable: tmp3 ].                    tmp3 = 12 ifTrue: [ ^arg1 pushReceiver ].                    tmp3 = 13 ifTrue: [ ^arg1 pushConstant: true ].                    tmp3 = 14 ifTrue: [ ^arg1 pushConstant: false ].                    tmp3 = 15 ifTrue: [ ^arg1 pushConstant: nil ] ].              tmp3 < 2 ifTrue: [ ^arg1 pushConstant: tmp3 ].              tmp3 = 2 ifTrue: [ ^self interpretSistaV1ExtendedPush: tmp6 for: arg1 ].              tmp3 = 3 ifTrue: [ ^arg1 doDup ].              tmp3 = 8 ifTrue: [ ^arg1 methodReturnReceiver ].              tmp3 = 9 ifTrue: [ ^arg1 methodReturnConstant: true ].              tmp3 = 10 ifTrue: [ ^arg1 methodReturnConstant: false ].              tmp3 = 11 ifTrue: [ ^arg1 methodReturnConstant: nil ].              tmp3 = 12 ifTrue: [ ^arg1 methodReturnTop ].              tmp3 = 13 ifTrue: [ ^arg1 blockReturnConstant: nil ].              tmp3 = 14 ifTrue: [ ^arg1 blockReturnTop ].              tmp3 = 15 ifTrue: [ ^arg1 doNop ].              ^self unusedBytecode: arg1 at: tmp7 ].        tmp2 = 6 ifTrue: [ ^arg1 send: (Smalltalk specialSelectorAt: tmp3 + 1) super: false numArgs: (Smalltalk specialNargsAt: tmp3 + 1) ].        tmp2 = 7 ifTrue: [ ^arg1 send: (Smalltalk specialSelectorAt: tmp3 + 17) super: false numArgs: (Smalltalk specialNargsAt: tmp3 + 17) ].        ^arg1 send: (tmp4 literalAt: tmp3 + 1) super: false numArgs: tmp2 - 8 ].  tmp2 < 14 ifTrue: [ tmp2 = 11 ifTrue: [ tmp3 < 8 ifTrue: [ ^arg1 jump: tmp3 + 1 ].              ^arg1 jump: tmp3 - 7 if: true ].        tmp2 = 12 ifTrue: [ tmp3 < 8 ifTrue: [ ^arg1 jump: tmp3 + 1 if: false ].              ^arg1 popIntoReceiverVariable: tmp3 - 8 ].        tmp3 < 8 ifTrue: [ ^arg1 popIntoTemporaryVariable: tmp3 ].        tmp3 = 8 ifTrue: [ ^arg1 doPop ].        tmp3 = 9 ifTrue: [ ^arg1 trap ].        ^self unusedBytecode: arg1 at: tmp7 ].  tmp1 < 248 ifTrue: [ ^self interpretNext2ByteSistaV1Instruction: tmp1 for: arg1 extA: tmp5 extB: tmp6 startPC: tmp7 ].  ^self interpretNext3ByteSistaV1Instruction: tmp1 for: arg1 extA: tmp5 extB: tmp6 startPC: tmp7instanceVariables  self deprecated: 'Please use #instVarNames or #slotNames instead' transformWith: '`@receiver instanceVariables' -> '`@receiver instVarNames'.  ^self instVarNamesfindContextSuchThat: arg1  | tmp1 |  tmp1 := self.  [ tmp1 isNil ] whileFalse: [ (arg1 value: tmp1) ifTrue: [ ^tmp1 ].        tmp1 := tmp1 sender ].  ^nilnormal  | tmp1 tmp2 |  tmp1 := y negated @ x.  (tmp2 := tmp1 x * tmp1 x + (tmp1 y * tmp1 y)) = 0 ifTrue: [ ^-1 @ 0 ].  ^tmp1 / tmp2 sqrtmessageText  ^'This block accepts ' , (self printArgumentsCount: expectedArgumentsCount) , ', but was called with ' , (self printArgumentsCount: calledArgumentsCount) , '.'asString  ^self sourceCodetestLessThan  self assert: aDateAndTime < (aDateAndTime + '1:00:00:00').  self assert: aDateAndTime + -1 < aDateAndTimeinstanceVariablesString  ^String streamContents: [:arg1 |  self localSlots do: [:arg2 |  arg1 nextPutAll: arg2 name ] separatedBy: [ arg1 space ] ]isRingObject  ^falsegtInspectorTempNodes  ^self tempNames withIndexCollect: [:arg1 :arg2 |  GTInspectorContextNamedTempNode hostObject: self tempName: arg1 tempIndex: arg2 ]initialize  super initialize.  self setTop: 0 left: 0 bottom: 0 right: 0signFlag  ^self header < 0currentMillenium  ^(Date current year / 100) asInteger * 100testSize  self     assert: (DependentsArray with: nil) size equals: 0;     assert: (DependentsArray with: nil with: 1 with: nil) size equals: 1;     assert: (DependentsArray with: 1 with: 3) size equals: 2;     assert: (DependentsArray with: nil with: nil with: nil) size equals: 0methodWithNotification  MyTestNotification signal: self testStringlongPrintOn: arg1  self class allInstVarNames doWithIndex: [:arg2 :arg3 |  arg1           nextPutAll: arg2;           nextPut: $:;           space;           tab;           print: (self instVarAt: arg3);           cr ]startTimerEventLoop  self startTimerEventLoopPriority: Processor timingPrioritywhichClassDefinesInstVar: arg1  ^self whichSuperclassSatisfies: [:arg2 |  arg2 instVarNames includes: arg1 ]testIsCasedLetter  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isCasedLetter: tmp2) equals: (tmp1 isCasedLetter: tmp2) ]hasLiteralSuchThat: arg1  1 to: self basicSize do: [:arg2 |  | tmp1 |        tmp1 := self basicAt: arg2.        (tmp1 isVariableBinding ifTrue: [ (arg1 value: tmp1 key) or: [ (arg1 value: tmp1 value) or: [ tmp1 value isArray and: [ tmp1 value hasLiteralSuchThat: arg1 ] ] ] ] ifFalse: [ tmp1 hasLiteralSuchThat: arg1 ]) ifTrue: [ ^true ] ].  ^falsetestValueWithinTimingNestedOuter  | tmp1 |  tmp1 := [ [ 3 timesRepeat: [ [ 5 seconds asDelay wait ] valueWithin: 100 milliSeconds onTimeout: [  ] ] ] valueWithin: 150 milliSeconds onTimeout: [  ] ] durationToRun.  self assert: tmp1 > 100 milliSeconds.  self assert: tmp1 < 5000 milliSecondstestRounded  self assert: 0.9 rounded equals: 1.  self assert: 1.0 rounded equals: 1.  self assert: 1.1 rounded equals: 1.  self assert: -1.9 rounded equals: -2.  self assert: -2.0 rounded equals: -2.  self assert: -2.1 rounded equals: -2.  self assert: 1.5 rounded equals: 2.  self assert: -1.5 rounded equals: -2testSizeInMemoryOfCharacters  self assert: 0 asCharacter sizeInMemory isZero.  self assert: 255 asCharacter sizeInMemory isZero.  self assert: 256 asCharacter sizeInMemory isZero.  self assert: 16r10FFFF asCharacter sizeInMemory isZeronamedTempAt: arg1 put: arg2  ^self tempNamed: (self tempNames at: arg1) put: arg2max: arg1  self > arg1 ifTrue: [ ^self ] ifFalse: [ ^arg1 ]montgomeryNumberOfDigits  ^(self bytesCount * 8 + (self montgomeryDigitLength - 1)) // self montgomeryDigitLengthhasClassSide  ^falsesubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 category: arg6  ^self subclass: arg1 uses: arg2 layout: self classLayout class slots: arg3 asSlotCollection classVariablesNames: arg4 poolDictionaries: arg5 category: arg6asSymbol  ^Symbol internCharacter: selfresume  suspendSemaphore ifNil: [ ^self error: 'Not suspended' ].  suspendSemaphore signalallSelectorsInProtocol: arg1  ^self withAllSuperclasses flatCollectAsSet: [:arg2 |  arg2 organization listAtCategoryNamed: arg1 ]embeddedSourceCode: arg1  self clear.  data := arg1 asString.  kind := data isWideString ifTrue: [ #EmbeddedSourceWide ] ifFalse: [ #EmbeddedSource ].  self encodetriggerEvent: arg1  ^(self actionForEvent: arg1) valuetestDaysInMonth  self assert: aDateAndTime daysInMonth equals: 31testIsControlOther  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isControlOther: tmp2) equals: (tmp1 isControlOther: tmp2) ]testDNU  self should: [ self runSimulated: [ self absentMethod ] ] raise: MessageNotUnderstoodsqrt  | tmp1 |  tmp1 := self asFraction sqrt.  ^tmp1 isFloat ifTrue: [ tmp1 ] ifFalse: [ tmp1 asScaledDecimal: scale ]brickValue: arg1 withEnoughArguments: arg2  ^selftestRemoveUptoLast  self assert: (self remove: #cookies uptoLast: (LinkedList new                 add: #cookies;                 add: #chocolate;                 add: #mints;                 add: #caramel;                 add: #delight;                 add: #ginger;                 add: #snaps;                 add: #desserts;                 add: #chocolate;                 add: #mousse;                 add: #vanilla;                 add: #ice;                 add: #cream;                 add: #German;                 add: #chocolate;                 add: #cake;                 add: #more;                 add: #cookies;                 add: #gingerbreadman;                 add: #chocolate;                 add: #chip;                 add: #brownies;                 yourself)) equals: (LinkedList new           add: #gingerbreadman;           add: #chocolate;           add: #chip;           add: #brownies;           yourself)manifestBuilderForRuleChecker: arg1  ^arg1 manifestBuilderOfMethod: selfgtDisplayOn: arg1  self method gtDisplayOn: arg1.  arg1 space.  self printOn: arg1testBitLogic  | tmp1 |  1 to: 100 do: [:arg1 |  self assert: ((1 bitShift: arg1) bitShift: arg1 negated) equals: 1 ].  1 to: 100 do: [:arg1 |  self assert: ((-1 bitShift: arg1) bitShift: arg1 negated) equals: -1 ].  1 to: 100 do: [:arg1 |  self assert: ((1 bitShift: arg1) bitAnd: -1) equals: (1 bitShift: arg1) ].  1 to: 100 do: [:arg1 |  tmp1 := 1 bitShift: arg1.        self assert: (tmp1 bitAnd: tmp1 negated) equals: tmp1 ].  1 to: 100 do: [:arg1 |  tmp1 := 1 bitShift: arg1.        self assert: tmp1 negated equals: (tmp1 bitXor: -1) + 1 ].  1 to: 100 do: [:arg1 |  tmp1 := 1 bitShift: arg1.        self assert: tmp1 + (tmp1 bitXor: -1) equals: -1 ].  1 to: 100 do: [:arg1 |  tmp1 := 1 bitShift: arg1.        self assert: tmp1 negated equals: (tmp1 bitXor: -1) + 1 ]withAllSubclasses  ^self allSubclasses     add: self;     yourselfisParagraphSeparator  ^self characterSet isParagraphSeparator: selfsizeReturnReceiver  ^self sizeOpcodeSelector: #genReturnReceiver withArguments: #()time  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self low16Bits.  tmp2 := tmp1 >> 11.  tmp3 := tmp1 >> 5 & 2r111111.  tmp4 := tmp1 & 2r11111.  tmp5 := (tmp4 * 2) floor.  ^Time hour: tmp2 minute: tmp3 second: tmp5testRefersToLiteralsReturnsTrueWhenLiteralIsInPragmaSelector  self assert: (self compiledMethod1 hasLiteralThorough: #pragma1:foo:)withoutOffset  ^self offset: 0referredInstVars  | tmp1 tmp2 |  tmp1 := self methodClass allInstVarNames.  self isReturnField ifTrue: [ ^Set with: (tmp1 at: self returnField + 1) ].  tmp2 := Set new.  self abstractBytecodeMessagesDo: [:arg1 |  (#(#popIntoReceiverVariable: #pushReceiverVariable: #storeIntoReceiverVariable:) includes: arg1 selector) ifTrue: [ tmp2 add: (tmp1 at: arg1 argument + 1) ] ].  ^tmp2testAsSmallerPowerOfTwo  self should: [ (2 raisedTo: 80) negated asSmallerPowerOfTwo ] raise: DomainError.  self should: [ -1 asSmallerPowerOfTwo ] raise: DomainError.  self should: [ 0 asSmallerPowerOfTwo ] raise: DomainError.  self assert: 1 asSmallerPowerOfTwo equals: 1.  self assert: 2 asSmallerPowerOfTwo equals: 2.  self assert: 3 asSmallerPowerOfTwo equals: 2.  self assert: 4 asSmallerPowerOfTwo equals: 4.  self assert: 5 asSmallerPowerOfTwo equals: 4.  self assert: ((2 raisedTo: 80) + 1) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (2 raisedTo: 80) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: ((2 raisedTo: 80) - 1) asSmallerPowerOfTwo equals: (2 raisedTo: 80 - 1)testUtcOffset  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1901-01-01T12:00:00+12:00' asDateAndTimetestCullCullCull  [  ] cull: 1 cull: 2 cull: 3.  [:arg1 |   ] cull: 1 cull: 2 cull: 3.  [:arg1 :arg2 |   ] cull: 1 cull: 2 cull: 3.  [:arg1 :arg2 :arg3 |   ] cull: 1 cull: 2 cull: 3.  self should: [ [:arg1 :arg2 :arg3 :arg4 |   ] cull: 1 cull: 2 cull: 3 ] raise: Error.  self should: [ [:arg1 :arg2 :arg3 :arg4 :arg5 |   ] cull: 1 cull: 2 cull: 3 ] raise: Error.  self assert: ([ 0 ] cull: 1 cull: 2 cull: 3) equals: 0.  self assert: ([:arg1 |  arg1 ] cull: 1 cull: 2 cull: 3) equals: 1.  self assert: ([:arg1 :arg2 |  arg2 ] cull: 1 cull: 2 cull: 3) equals: 2.  self assert: ([:arg1 :arg2 :arg3 |  arg3 ] cull: 1 cull: 2 cull: 3) equals: 3testReentrantBlockOldEnvironment  | tmp1 |  tmp1 := self constructFibonacciBlockInDeadFrame.  self should: [ tmp1 value: 0 ] raise: self classForTestResult error.  self assert: (tmp1 value: 1) equals: 1.  self assert: (tmp1 value: 2) equals: 1.  self assert: (tmp1 value: 3) equals: 2.  self assert: (tmp1 value: 4) equals: 3.  self assert: (tmp1 value: 5) equals: 5.  self assert: (tmp1 value: 6) equals: 8timespans  ^timespans ifNil: [ timespans := OrderedCollection new ]defaultAction  UnhandledError signalForException: selftestAllMethods  | tmp1 tmp2 |  tmp1 := IdentitySet new     addAll: Object allMethods;     yourself.  self assert: (tmp1 includesAll: Object methods).  tmp2 := OrderedCollection new.  ProtoObject selectorsAndMethodsDo: [:arg1 :arg2 |  (Object includesSelector: arg1) ifFalse: [ tmp2 add: arg2 ] ].  self assert: (tmp1 includesAll: tmp2)digitDiv: arg1 neg: arg2  < primitive: 'primDigitDivNegative' module: 'LargeIntegers'>  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 tmp16 tmp17 |  arg1 = 0 ifTrue: [ ^(ZeroDivide dividend: self) signal ].  tmp12 := self bytesCount - arg1 bytesCount + 1.  tmp12 <= 0 ifTrue: [ ^Array with: 0 with: self ].  tmp4 := 8 - arg1 lastDigit highBitOfPositiveReceiver.  tmp5 := arg1 digitLshift: tmp4.  tmp5 := tmp5 growto: tmp5 bytesCount + 1.  tmp2 := self digitLshift: tmp4.  tmp2 bytesCount = self bytesCount ifTrue: [ tmp2 := tmp2 growto: self bytesCount + 1 ].  tmp1 := Integer new: tmp12 neg: arg2.  tmp8 := tmp5 bytesCount - 1.  tmp3 := tmp12.  tmp6 := tmp5 byteAt: tmp8.  tmp7 := tmp8 = 1 ifTrue: [ 0 ] ifFalse: [ tmp5 byteAt: tmp8 - 1 ].  1 to: tmp3 do: [:arg3 |  tmp11 := tmp2 bytesCount + 1 - arg3.        (tmp2 byteAt: tmp11) = tmp6 ifTrue: [ tmp9 := tmp10 := 15 ] ifFalse: [ tmp17 := ((tmp2 byteAt: tmp11) bitShift: 4) + ((tmp2 byteAt: tmp11 - 1) bitShift: -4).              tmp9 := tmp17 // tmp6.              tmp17 := (tmp17 \\ tmp6 bitShift: 4) + ((tmp2 byteAt: tmp11 - 1) bitAnd: 15).              tmp10 := tmp17 // tmp6.              tmp17 := tmp17 \\ tmp6.              tmp13 := tmp9 * tmp7.              tmp14 := tmp10 * tmp7 + ((tmp13 bitAnd: 15) bitShift: 4).              tmp13 := (tmp13 bitShift: -4) + (tmp14 bitShift: -8).              tmp14 := tmp14 bitAnd: 255.              tmp15 := tmp11 < 3 ifTrue: [ 0 ] ifFalse: [ tmp2 byteAt: tmp11 - 2 ].              [ (tmp17 < tmp13 or: [ tmp17 = tmp13 and: [ tmp15 < tmp14 ] ]) and: [ tmp10 := tmp10 - 1.                    tmp14 := tmp14 - tmp7.                    tmp14 < 0 ifTrue: [ tmp13 := tmp13 - 1.                          tmp14 := tmp14 + 256 ].                    tmp13 >= tmp6 ] ] whileTrue: [ tmp13 := tmp13 - tmp6 ].              tmp10 < 0 ifTrue: [ tmp9 := tmp9 - 1.                    tmp10 := tmp10 + 16 ] ].        tmp12 := tmp11 - tmp8.        tmp16 := 0.        1 to: tmp5 bytesCount do: [:arg4 |  tmp13 := (tmp5 byteAt: arg4) * tmp9.              tmp14 := tmp16 + (tmp2 byteAt: tmp12) - ((tmp13 bitAnd: 15) bitShift: 4) - ((tmp5 byteAt: arg4) * tmp10).              tmp2 byteAt: tmp12 put: tmp14 - (tmp14 // 256 * 256).              tmp16 := tmp14 // 256 - (tmp13 bitShift: -4).              tmp12 := tmp12 + 1 ].        tmp16 < 0 ifTrue: [ tmp10 := tmp10 - 1.              tmp12 := tmp11 - tmp8.              tmp16 := 0.              1 to: tmp5 bytesCount do: [:arg4 |  tmp16 := (tmp16 bitShift: -8) + (tmp2 byteAt: tmp12) + (tmp5 byteAt: arg4).                    tmp2 byteAt: tmp12 put: (tmp16 bitAnd: 255).                    tmp12 := tmp12 + 1 ] ].        tmp1 byteAt: tmp1 bytesCount + 1 - arg3 put: (tmp9 bitShift: 4) + tmp10 ].  tmp2 := tmp2 digitRshift: tmp4 bytes: 0 lookfirst: tmp8.  ^Array with: tmp1 with: tmp2instVarNameForIndex: arg1  | tmp1 |  self deprecated: 'Please use the slot API directly'.  tmp1 := self classLayout allSlots detect: [:arg2 |  arg2 isVirtual not and: [ arg2 index = arg1 ] ] ifNone: [ ^nil ].  ^tmp1 namesetConfiguration: arg1 withInMetacelloConfig: arg2  arg2 setConfiguration: arg1 withBlock: selfinterpretV3PlusClosureJump  | tmp1 |  tmp1 := self method at: pc.  (tmp1 between: 144 and: 151) ifTrue: [ pc := pc + 1.        ^tmp1 - 143 ].  (tmp1 between: 160 and: 167) ifTrue: [ pc := pc + 2.        ^(tmp1 - 164) * 256 + (self method at: pc - 1) ].  ^niltestFailedCriticalSectionShouldUnblockWaitingOne  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := Semaphore new.  tmp3 := self fork: [ [ mutex critical: [ tmp2 wait.              self error: 'critical section failed' ] ] ifError: [  ] ].  self waitLastProcessLock.  self fork: [ mutex critical: [ tmp1 := true ] ].  self waitLastProcessLock.  tmp2 signal.  self waitLastProcessTerminate.  self assert: tmp1reActivate  self     suspend;     activatemethodClass  ^method methodClasscanBeRemoved  ^falseisTest  ^falsetruncated  ^self quo: 1sharedPools  ^sharedPools ifNil: [ sharedPools := OrderedCollection new ]allMethodsReadingSlot: arg1  ^self withAllSubclasses flatCollect: [:arg2 |  arg2 methodsReadingSlot: arg1 ]arcTan: arg1  ^self asFloat arcTan: arg1hours  ^self houruses: arg1  ^self uses: arg1 slots: #()unicodeCategoryTableLookup: arg1  ^self class unicodeCategoryTableLookup: arg1logCr: arg1  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver logCr: `@statements1' -> '`@receiver traceCr: `@statements1'.  self traceCr: arg1isTreeNodeModel  ^falsetestAsDuration  self assert: aTimespan asDuration equals: aWeekseconds  ^seconds rem: SecondsInMinutetestMonth  self assert: aDateAndTime month equals: 2.  self assert: aDateAndTime monthAbbreviation equals: 'Feb'.  self assert: aDateAndTime monthName equals: 'February'.  self assert: aDateAndTime monthIndex equals: 2newCallbackWithSignature: arg1 block: arg2  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     newCallbackWithSignature: arg1 block: arg2 library: self ffiLibraryappendTo: arg1  ^arg1 addLast: selfhasPragmaNamed: arg1  ^self subclassResponsibilityscaleBy: arg1  ^(arg1 x * x) @ (arg1 y * y)testLn  self assert: (100 ln closeTo: 10 ln * 2).  self assert: ((2 raisedTo: Float emax + 3) ln closeTo: 2 ln * (Float emax + 3)) description: 'Integer>>ln should not overflow'withSide: arg1 setTo: arg2  ^self perform: (#(withLeft: withRight: withTop: withBottom:) at: (#(left right top bottom) indexOf: arg1)) with: arg2searchFrom: arg1  signalContext := arg1 contextTag* arg1  ^self class nanoSeconds: (self asNanoSeconds * arg1) asIntegerclassVarNamed: arg1 put: arg2  self writeClassVariableNamed: arg1 value: arg2canBeNonGlobalVarInitial  ^self characterSet canBeNonGlobalVarInitial: selfdegrees  | tmp1 tmp2 |  ^x = 0 ifTrue: [ y >= 0 ifTrue: [ 90.0 ] ifFalse: [ 270.0 ] ] ifFalse: [ tmp1 := y asFloat / x asFloat.        tmp2 := tmp1 arcTan.        x >= 0 ifTrue: [ y >= 0 ifTrue: [ tmp2 radiansToDegrees ] ifFalse: [ 360.0 + tmp2 radiansToDegrees ] ] ifFalse: [ 180.0 + tmp2 radiansToDegrees ] ]testForMilliseconds  | tmp1 |  tmp1 := Delay forMilliseconds: 1000.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: tmp1.  scheduler simulate_vmMilliseconds: 1099.  self deny: tmp1 isExpired.  scheduler simulate_vmMilliseconds: 1100.  self assert: tmp1 isExpiredseconds  ^Duration seconds: selfvariableReadNodes  ^self ast variableReadNodestestOffset  self assert: aDateAndTime offset equals: '0:00:00:00' asDuration.  self assert: (aDateAndTime offset: '-0:12:00:00') equals: '1900-12-31T12:00:00-12:00' asDateAndTime.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1901-01-01T12:00:00+12:00' asDateAndTimetestAnd  self deny: (false and: [ 'alternativeBlock' ])vmSimNextWakeupMilliseconds  ^vmSimNextWakeupTickhasSlot: arg1  ^self allSlots identityIncludes: arg1criticTheNonMetaclassClass  ^self methodClass instanceSidetestEqualityClassSideMethod  | tmp1 tmp2 |  tmp1 := TestCase class compiler compile: 'aMethod'.  tmp2 := TestCase class compiler compile: 'aMethod'.  self assert: tmp1 equals: tmp2asYear  ^self asDateAndTime asYeartestOneGBAllocation  | tmp1 tmp2 tmp3 |  tmp3 := false.  tmp1 := 1024 * 1024 * 1024.  tmp2 := [ ByteArray new: tmp1 ] on: OutOfMemory do: [:arg1 |  tmp3 := true ].  self assert: (tmp3 or: [ tmp2 size = tmp1 ])messageText  ^messageText ifNil: [ messageText := self standardMessageText ]testNow  self deny: aDateAndTime equals: DateAndTime nowacceptDroppingMorph: arg1 event: arg2 inMorph: arg3  ^falsevalueWithArguments: arg1  | tmp1 |  tmp1 := self receiver.  (self ensureReceiverAndArguments: tmp1) ifFalse: [ ^nil ].  ^tmp1 perform: selector withArguments: (self collectArguments: arg1)dist: arg1  | tmp1 tmp2 |  tmp1 := arg1 x - x.  tmp2 := arg1 y - y.  ^(tmp1 * tmp1 + (tmp2 * tmp2)) sqrtsetUp  super setUp.  restoredTimeZone := DateAndTime localTimeZone.  DateAndTime localTimeZone: (TimeZone timeZones detect: [:arg1 |  arg1 abbreviation = 'GMT' ]).  firstEvent := DateAndTime year: 2003 month: 1 day: 4 hour: 20 minute: 30.  aSchedule := Schedule starting: firstEvent duration: 52 weeks.  aSchedule schedule: {(Duration days: 1) .         (Duration days: 6)}join: arg1  ^self asString join: arg1genPushLiteral: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255 ].  arg1 < 32 ifTrue: [ stream nextPut: 32 + arg1.        ^self ].  arg1 < 64 ifTrue: [ stream           nextPut: 128;           nextPut: 128 + arg1.        ^self ].  arg1 < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 96;           nextPut: arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255suitableRulesFrom: arg1  ^arg1 classRulesjulianDayOffset  ^((seconds + self offset asSeconds) / SecondsInDay) floorputSource: arg1 withPreamble: arg2  SourceFiles writeSource: arg1 preamble: (String streamContents: arg2) onSuccess: [:arg3 :arg4 |  (SourceChunkWriteStream on: arg4) nextPut: ' '.        self setSourcePointer: arg3 ] onFail: [ self becomeForward: (self copyWithSource: arg1) ]gtInspectorInstanceVariablesIn: arg1  < gtInspectorPresentationOrder: 21>  arg1 table     title: 'InstVars';     display: [ self class allInstVarNames sorted collect: [:arg2 |  arg2 -> (self instVarNamed: arg2) ] ];     column: 'Variable' evaluated: [:arg2 |  arg2 key ];     column: 'Value' evaluated: [:arg2 |  arg2 value ]dateParserClass  ^DateParserexternalProperties  | tmp1 tmp2 |  tmp1 := Pragma allNamed: #eProperty from: self class to: ProtoObject.  tmp2 := OrderedCollection new.  tmp1 do: [:arg1 |  [ tmp2 addAll: (arg1 method valueWithReceiver: self arguments: #()) ] on: Exception do: [:arg2 |  ReExceptionStrategy current handle: arg2 about: self forProppertiesDo: [:arg3 |  tmp2 add: arg3 ] ] ].  ^tmp2literalAt: arg1  ^self objectAt: arg1 + 1testMethodIsBottomContext  self     assert: aMethodContext bottomContext equals: aSender;     assert: aMethodContext secondFromBottom equals: aMethodContextdebug  ^self debugWithTitle: 'Debug'classVariableNamed: arg1  ^self classPool associationAt: arg1 asSymbol ifAbsent: [ self error: 'no such class var' ]isPrime  ^self isProbablyPrimetestStart  | tmp1 |  tmp1 := DateAndTime now year.  self assert: Year current start equals: (DateAndTime year: tmp1 month: 1 day: 1)testHash  self assert: aDateAndTime hash equals: (DateAndTime year: 1980 month: 1 day: 1) hashprintOn: arg1  arg1     nextPutAll: self class name;     nextPutAll: ' (';     nextPutAll: self name;     nextPutAll: ') - ';     print: self methodSelectors size;     nextPutAll: ' selector(s)'cos  ^self asFloat costestAsNumberWithoutDecimalPoint  | tmp1 |  tmp1 := '123s0' asNumber.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: tmp1 scale equals: 0.  self assert: '123s0' equals: tmp1 printStringvariableSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4  ^self variableSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: '' package: arg4sourceCode  ^self method sourceCodeisTitlecaseLetter  ^self characterSet isTitlecaseLetter: selfselectorsDo: arg1  ^self methodDict keysDo: arg1> arg1  arg1 class = self class ifTrue: [ ^self asFraction > arg1 asFraction ].  ^self asFraction > arg1origin  ^self methodClass findOriginClassOf: selftestEveryDo  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := 7 days.  aTimespan every: tmp2 do: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 1testInjectingMultipleExceptionHandlersIntoRunningProcess  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  DefaultExecutionEnvironment beActive.  tmp6 := tmp4 := tmp3 := false.  tmp5 := Semaphore new.  tmp2 := [ tmp6 := true.  tmp5 wait.  tmp1 signal ] fork.  [ tmp6 ] whileFalse: [ Processor yield ].  tmp2 on: ZeroDivide do: [:arg1 |  tmp4 := true ].  tmp2 on: Error do: [:arg1 |  tmp3 := true ].  tmp1 := ZeroDivide new.  tmp5 signal.  [ tmp2 isTerminated ] whileFalse: [ Processor yield ].  self assert: tmp4.  self deny: tmp3.  tmp6 := tmp4 := tmp3 := false.  tmp5 := Semaphore new.  tmp2 := [ tmp6 := true.  tmp5 wait.  tmp1 signal ] fork.  [ tmp6 ] whileFalse: [ Processor yield ].  tmp2 on: ZeroDivide do: [:arg1 |  tmp4 := true ].  tmp2 on: Error do: [:arg1 |  tmp3 := true ].  tmp1 := Error new.  tmp5 signal.  [ tmp2 isTerminated ] whileFalse: [ Processor yield ].  self deny: tmp4.  self assert: tmp3onDNU: arg1 do: arg2  ^self on: MessageNotUnderstood do: [:arg3 |  arg3 message selector = arg1 ifTrue: [ arg2 cull: arg3 ] ifFalse: [ arg3 pass ] ]renameProtocol: arg1 into: arg2  (self existsProtocolNamed: arg2) ifTrue: [ self moveMethodsFrom: arg1 to: arg2.        self removeProtocolNamed: arg1 ] ifFalse: [ ^(self protocolNamed: arg1)           name: arg2;           yourself ]min: arg1 max: arg2  ^(self min: arg1) max: arg2signBit  ^0rangeForPC: arg1  ^(self sourceNodeForPC: arg1) debugHighlightRangefromSton: arg1  arg1 parseListDo: [:arg2 :arg3 |  arg3 = 1 ifTrue: [ x := arg2 ].        arg3 = 2 ifTrue: [ y := arg2 ] ]interpretV3PlusClosureExtension: arg1 in: arg2 for: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  arg1 <= 6 ifTrue: [ tmp3 := arg2 at: pc.        pc := pc + 1.        arg1 <= 2 ifTrue: [ tmp1 := tmp3 // 64.              tmp2 := tmp3 \\ 64.              arg1 = 0 ifTrue: [ tmp1 = 0 ifTrue: [ ^arg3 pushReceiverVariable: tmp2 ].                    tmp1 = 1 ifTrue: [ ^arg3 pushTemporaryVariable: tmp2 ].                    tmp1 = 2 ifTrue: [ ^arg3 pushConstant: (arg2 literalAt: tmp2 + 1) ].                    tmp1 = 3 ifTrue: [ ^arg3 pushLiteralVariable: (arg2 literalAt: tmp2 + 1) ] ].              arg1 = 1 ifTrue: [ tmp1 = 0 ifTrue: [ ^arg3 storeIntoReceiverVariable: tmp2 ].                    tmp1 = 1 ifTrue: [ ^arg3 storeIntoTemporaryVariable: tmp2 ].                    tmp1 = 2 ifTrue: [ self error: 'illegalStore' ].                    tmp1 = 3 ifTrue: [ ^arg3 storeIntoLiteralVariable: (arg2 literalAt: tmp2 + 1) ] ].              arg1 = 2 ifTrue: [ tmp1 = 0 ifTrue: [ ^arg3 popIntoReceiverVariable: tmp2 ].                    tmp1 = 1 ifTrue: [ ^arg3 popIntoTemporaryVariable: tmp2 ].                    tmp1 = 2 ifTrue: [ self error: 'illegalStore' ].                    tmp1 = 3 ifTrue: [ ^arg3 popIntoLiteralVariable: (arg2 literalAt: tmp2 + 1) ] ] ].        arg1 = 3 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp3 \\ 32 + 1) super: false numArgs: tmp3 // 32 ].        arg1 = 4 ifTrue: [ tmp4 := arg2 at: pc.              pc := pc + 1.              tmp1 := tmp3 // 32.              tmp1 = 0 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp4 + 1) super: false numArgs: tmp3 \\ 32 ].              tmp1 = 1 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp4 + 1) super: true numArgs: tmp3 \\ 32 ].              tmp1 = 2 ifTrue: [ ^arg3 pushReceiverVariable: tmp4 ].              tmp1 = 3 ifTrue: [ ^arg3 pushConstant: (arg2 literalAt: tmp4 + 1) ].              tmp1 = 4 ifTrue: [ ^arg3 pushLiteralVariable: (arg2 literalAt: tmp4 + 1) ].              tmp1 = 5 ifTrue: [ ^arg3 storeIntoReceiverVariable: tmp4 ].              tmp1 = 6 ifTrue: [ ^arg3 popIntoReceiverVariable: tmp4 ].              tmp1 = 7 ifTrue: [ ^arg3 storeIntoLiteralVariable: (arg2 literalAt: tmp4 + 1) ] ].        arg1 = 5 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp3 \\ 32 + 1) super: true numArgs: tmp3 // 32 ].        arg1 = 6 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp3 \\ 64 + 1) super: false numArgs: tmp3 // 64 ] ].  arg1 = 7 ifTrue: [ ^arg3 doPop ].  arg1 = 8 ifTrue: [ ^arg3 doDup ].  arg1 = 9 ifTrue: [ ^arg3 pushActiveContext ].  tmp3 := arg2 at: pc.  pc := pc + 1.  arg1 = 10 ifTrue: [ ^tmp3 < 128 ifTrue: [ arg3 pushNewArrayOfSize: tmp3 ] ifFalse: [ arg3 pushConsArrayWithElements: tmp3 - 128 ] ].  tmp4 := arg2 at: pc.  pc := pc + 1.  arg1 = 11 ifTrue: [ ^arg3 callPrimitive: tmp3 + (tmp4 * 256) ].  arg1 = 12 ifTrue: [ ^arg3 pushRemoteTemp: tmp3 inVectorAt: tmp4 ].  arg1 = 13 ifTrue: [ ^arg3 storeIntoRemoteTemp: tmp3 inVectorAt: tmp4 ].  arg1 = 14 ifTrue: [ ^arg3 popIntoRemoteTemp: tmp3 inVectorAt: tmp4 ].  tmp5 := arg2 at: pc.  pc := pc + 1.  ^arg3 pushClosureCopyNumCopiedValues: (tmp3 bitShift: -4) numArgs: (tmp3 bitAnd: 16rF) blockSize: tmp4 * 256 + tmp5organization  ^organizationvariable  ^variablesubtractTime: arg1  ^self class seconds: self asSeconds - arg1 asSecondstagWith: arg1  self protocol: arg1testLn  self assert: ((1 / 100) ln closeTo: -2 * 10 ln).  self assert: (((2 raisedTo: Float emax + 11) / 3) ln closeTo: (Float emax + 11) * 2 ln - 3 ln) description: 'Fraction>>ln should not overflow'.  self assert: ((3 / (2 raisedTo: Float precision - Float emin)) ln closeTo: (Float emin - Float precision) * 2 ln + 3 ln) description: 'Fraction>>ln should not underflow'genPushTemp: arg1  (arg1 < 0 or: [ arg1 > 63 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63 ].  arg1 < 12 ifTrue: [ stream nextPut: 64 + arg1.        ^self ].  stream     nextPut: 229;     nextPut: arg1union: arg1  | tmp1 tmp2 |  tmp1 := self start min: arg1 start.  tmp2 := self end max: arg1 end.  ^Timespan starting: tmp1 ending: tmp2 + DateAndTime clockPrecisiontestusingMethods  | tmp1 |  tmp1 := ChronologyConstants usingMethods.  self assert: (tmp1 includes: (Duration >> #asNanoSeconds) methodReference).  self assert: (tmp1 includes: (ClassTest >> #testSharedPoolOfVarNamed) methodReference)testIsBefore  | tmp1 tmp2 |  tmp1 := january23rd2004 translateTo: -8 hours.  tmp2 := january23rd2004 translateTo: 10 hours.  self     assert: (tmp1 isBefore: tmp2) not;     assert: (june2nd1973 isBefore: january23rd2004);     assert: (june2nd1973 isBefore: june2nd1973) notuntagFrom: arg1  self protocol = arg1 ifTrue: [ self protocol: Protocol unclassified ]add: arg1 after: arg2  | tmp1 |  tmp1 := self linkAt: (self indexOf: arg2).  ^self add: arg1 afterLink: tmp1testNotInstantiable  self should: [ Integer new ] raise: Exceptionoffset  ^offsetwaitTimeoutSeconds: arg1 onCompletion: arg2 onTimeout: arg3  | tmp1 |  tmp1 := DelayWaitTimeout new setDelay: (arg1 * 1000 max: 0) forSemaphore: self.  ^tmp1 waitOnCompletion: arg2 onTimeout: arg3hasPragmaNamed: arg1  ^self pragmas anySatisfy: [:arg2 |  arg2 selector = arg1 ]isMessageSend  ^truewillJumpIfTrue  ^self method encoderClass isBranchIfTrueAt: pc in: self methodisTall  ^self height > self widthasMetacelloSemanticVersionNumber  ^MetacelloSemanticVersionNumber fromString: ''notifyOfChangedCategoryFrom: arg1 to: arg2  (self hasSubject and: [ arg1 ~= arg2 ]) ifTrue: [ SystemAnnouncer uniqueInstance protocolRenamedFrom: arg1 to: arg2 inClass: self subject.        SystemAnnouncer uniqueInstance classReorganized: self subject ]last  ^self lastLink valuecategories: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  arg1 size < 2 ifTrue: [ ^self ].  tmp1 := Array new: arg1 size.  tmp2 := Array new: arg1 size.  tmp3 := OrderedCollection new: arg1 size.  tmp7 := 0.  1 to: arg1 size do: [:arg2 |  tmp5 := (arg1 at: arg2) asSymbol.        tmp6 := self listAtCategoryNamed: tmp5.        tmp3 addAllLast: tmp6.        tmp1 at: arg2 put: tmp5.        tmp2 at: arg2 put: (tmp7 := tmp7 + tmp6 size) ].  tmp3 := tmp3 asArray.  tmp4 := tmp3 asSet.  elementArray do: [:arg3 |  (tmp4 includes: arg3) ifFalse: [ ^self error: 'New categories must match old ones' ] ].  categoryArray := tmp1.  categoryStops := tmp2.  elementArray := tmp3sizePushInstVar: arg1  ^self sizeOpcodeSelector: #genPushInstVar: withArguments: {arg1}testAllInstances  self assert: UndefinedObject allInstances size = 1 description: 'There should be a single instance of UndefinedObject'.  self assert: (UndefinedObject allInstances includes: nil) description: 'nil should be an instance of UndefinedObject'isEmptyCategoryNumber: arg1  | tmp1 tmp2 |  (arg1 < 1 or: [ arg1 > categoryStops size ]) ifTrue: [ ^true ].  tmp1 := self firstIndexOfCategoryNumber: arg1.  tmp2 := self lastIndexOfCategoryNumber: arg1.  ^tmp1 > tmp2threeDigitName  | tmp1 tmp2 |  self = 0 ifTrue: [ ^'' ].  tmp1 := #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten' 'eleven' 'twelve' 'thirteen' 'fourteen' 'fifteen' 'sixteen' 'seventeen' 'eighteen' 'nineteen').  self > 99 ifTrue: [ tmp2 := (tmp1 at: self // 100) , ' hundred'.        self \\ 100 = 0 ifFalse: [ tmp2 := tmp2 , ' ' , (self \\ 100) threeDigitName ].        ^tmp2 ].  self < 20 ifTrue: [ ^tmp1 at: self ].  tmp2 := #('twenty' 'thirty' 'forty' 'fifty' 'sixty' 'seventy' 'eighty' 'ninety') at: self // 10 - 1.  self \\ 10 = 0 ifFalse: [ tmp2 := tmp2 , '-' , (tmp1 at: self \\ 10) ].  ^tmp2voidCogVMState  < primitive: 215>  ^self flushCachereturn: arg1 to: arg2  self releaseTo: arg2.  arg2 ifNil: [ ^nil ].  ^arg2 push: arg1genStoreLiteralVar: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255 ].  arg1 < 64 ifTrue: [ stream           nextPut: 129;           nextPut: 192 + arg1.        ^self ].  arg1 < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 224;           nextPut: arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255testStoreOnRoundTrip  self assert: (self class compiler evaluate: 0.5s1 squared storeString) * 4 equals: 0.5s1 squared * 4.  self assert: 0.25s2 storeString equals: '0.25s2'daysLeftInYear  ^start daysLeftInYeartestReadsField  | tmp1 |  tmp1 := self class compiledMethodAt: #readX.  self assert: (tmp1 readsField: 4).  tmp1 := self class compiledMethodAt: #readXandY.  self assert: (tmp1 readsField: 5).  tmp1 := self class compiledMethodAt: #writeX.  self deny: (tmp1 readsField: 4).  tmp1 := self class compiledMethodAt: #writeXandY.  self deny: (tmp1 readsField: 4).  tmp1 := self class compiledMethodAt: #writeXandY.  self deny: (tmp1 readsField: 5)fork: arg1 at: arg2  | tmp1 |  tmp1 := arg1 forkAt: arg2 named: testSelector.  forkedProcesses add: tmp1.  ^tmp1setUp  super setUp.  aDateAndTime := DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours.  aTimeZone := TimeZone default.  aDuration := Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0bitStringLength  ^self bytesCount * 8 + (self positive ifTrue: [ 1 ] ifFalse: [ 0 ])copyWith: arg1  | tmp1 tmp2 |  (Association == arg1 class or: [ Pragma == arg1 class ]) ifFalse: [ self error: self class name , ' instances should hold only Associations or Pragmas.' ].  tmp2 := self class basicNew: (tmp1 := self basicSize) + 1.  1 to: tmp1 do: [:arg2 |  tmp2 basicAt: arg2 put: (self basicAt: arg2) shallowCopy ].  tmp2 basicAt: tmp1 + 1 put: arg1.  1 to: self class instSize do: [:arg2 |  tmp2 instVarAt: arg2 put: (self instVarAt: arg2) ].  ^tmp2privRefreshWith: arg1  arg1 isCompiledMethod ifFalse: [ self error: 'method can only be set to aCompiledMethod' ].  method := arg1.  [ closureOrNil == nil ] assert.  self privRefreshname  ^name ifNil: [ super name ]sourceCodeTemplate  ^'messageSelectorAndArgumentNames	"comment stating purpose of class-side message"	"scope: class-variables  &  class-instance-variables"					| temporary variable names |	statements'jsonOn: arg1  arg1 dateAndTime: selfpcPreviousTo: arg1  | tmp1 tmp2 tmp3 |  arg1 > self endPC ifTrue: [ ^self endPC ].  tmp1 := InstructionStream on: self.  tmp2 := InstructionClient new.  [ tmp1 pc < arg1 ] whileTrue: [ tmp3 := tmp1 pc.        tmp1 interpretNextInstructionFor: tmp2 ].  ^tmp3addSelector: arg1 withMethod: arg2  | tmp1 tmp2 |  tmp1 := self compiledMethodAt: arg1 ifAbsent: [ nil ].  tmp2 := tmp1 ifNotNil: [ tmp1 protocol ].  self addSelectorSilently: arg1 withMethod: arg2.  tmp1 ifNil: [ SystemAnnouncer uniqueInstance methodAdded: arg2 ] ifNotNil: [ SystemAnnouncer uniqueInstance methodChangedFrom: tmp1 to: arg2 oldProtocol: tmp2 ]testBehaviorClassClassDescriptionMetaclassHierarchy  self assert: Class superclass identicalTo: ClassDescription.  self assert: Metaclass superclass identicalTo: ClassDescription.  self assert: ClassDescription superclass identicalTo: Behavior.  self assert: Behavior superclass equals: Object.  self assert: Class class class identicalTo: Metaclass.  self assert: Metaclass class class identicalTo: Metaclass.  self assert: ClassDescription class class identicalTo: Metaclass.  self assert: Behavior class class identicalTo: Metaclassarguments: arg1  arguments := WeakArray withAll: arg1.  shouldBeNil := Array withAll: (arg1 collect: [:arg2 |  arg2 isNil ])superclass  ^superclasscomeFullyUpOnReload: arg1  ^selftestListAtCategoryNamed  | tmp1 |  tmp1 := self organization listAtCategoryNamed: 'empty'.  self assertEmpty: tmp1.  tmp1 := self organization listAtCategoryNamed: 'one'.  self assert: tmp1 size equals: 1.  self assert: tmp1 first equals: #oneromanDigits: arg1 for: arg2 on: arg3  | tmp1 |  tmp1 := self \\ (arg2 * 10) // arg2.  tmp1 = 9 ifTrue: [ ^arg3           nextPut: arg1 last;           nextPut: arg1 first ].  tmp1 = 4 ifTrue: [ ^arg3           nextPut: arg1 last;           nextPut: arg1 second ].  tmp1 > 4 ifTrue: [ arg3 nextPut: arg1 second ].  tmp1 \\ 5 timesRepeat: [ arg3 nextPut: arg1 last ]testInstVarNamedPut  | tmp1 |  tmp1 := ObjectMockForTest new.  self assert: (tmp1 instVarNamed: 'variable') isNil.  tmp1 instVarNamed: 'variable' put: 1.  self assert: (tmp1 instVarNamed: 'variable') equals: 1.  self shouldnt: [ tmp1 instVarNamed: 'variable' put: 1 ] raise: InstanceVariableNotFound.  self should: [ tmp1 instVarNamed: 'timoleon' put: 1 ] raise: InstanceVariableNotFoundvalueWithEnoughArguments: arg1  | tmp1 |  arg1 size == self numArgs ifTrue: [ ^self valueWithArguments: arg1 ].  tmp1 := Array new: self numArgs.  tmp1 replaceFrom: 1 to: (arg1 size min: tmp1 size) with: arg1 startingAt: 1.  ^self valueWithArguments: tmp1classBindingOf: arg1  ^self bindingOf: arg1withAtLeastNDigits: arg1  | tmp1 |  self size >= arg1 ifTrue: [ ^self ].  tmp1 := self class new: arg1.  tmp1 replaceFrom: 1 to: self size with: self startingAt: 1.  ^tmp1notify: arg1  Warning signal: arg1sharedPoolsString  ^String streamContents: [:arg1 |  self sharedPools do: [:arg2 |  arg1 nextPutAll: (self environment keyAtIdentityValue: arg2 ifAbsent: [ arg2 isObsolete ifTrue: [ arg2 name ] ifFalse: [ 'private' ] ]) ] separatedBy: [ arg1 space ] ]methods  self deprecated: 'Use #methodSelectors instead.' transformWith: '`@receiver methods' -> '`@receiver methodSelectors'.  ^self methodSelectorsbyteAt: arg1  < primitive: 60>  self bytesCount < arg1 ifTrue: [ ^0 ] ifFalse: [ ^super at: arg1 ]julianDayNumberUTC  ^julianDayNumbertestCopy  | tmp1 |  tmp1 := atPragma copy.  self deny: atPragma identicalTo: tmp1.  self assert: atPragma method identicalTo: tmp1 method.  self assert: atPragma selector identicalTo: tmp1 selector.  self assert: atPragma arguments identicalTo: tmp1 argumentssubscript: arg1  subscript := arg1testAsDos  | tmp1 |  self assert: '21 May 2012 3:02:44 pm' asDateAndTime asDosTimestamp equals: 16r40B57856.  tmp1 := DateAndTime current offset: DateAndTime localOffset + 2 hours.  self assert: tmp1 asDosTimestamp equals: tmp1 asLocal asDosTimestampchangeFromCategorySpecs: arg1  self internalChangeFromString: arg1subclass: arg1 uses: arg2 slots: arg3 classVariables: arg4 poolDictionaries: arg5 package: arg6  ^self subclass: arg1 uses: arg2 layout: self classLayout class slots: arg3 classVariables: arg4 poolDictionaries: arg5 category: arg6hasTemporaryVariableNamed: arg1  ^self tempNames includes: arg1testErrorWhenDayIsBeforeMonthStart  self should: [ DateAndTime year: 2004 month: 2 day: -1 ] raise: Error.  self should: [ DateAndTime year: 2004 month: 2 day: 0 ] raise: Error.  DateAndTime year: 2004 month: 2 day: 1isLarge  ^trueisEscape  ^char = $\minutes  ^self minutetestRaisedToInteger  self assert: (3.0s1 raisedToInteger: -1) scale equals: 1.  self assert: (3.0s1 raisedToInteger: -1) equals: 1 / 3.  self assert: (3.0s1 raisedToInteger: 0) scale equals: 1.  self assert: (3.0s1 raisedToInteger: 0) equals: 1.  self assert: (3.0s1 raisedToInteger: 1) scale equals: 1.  self assert: (3.0s1 raisedToInteger: 1) equals: 3.  self assert: (3.0s1 raisedToInteger: 2) scale equals: 1.  self assert: (3.0s1 raisedToInteger: 2) equals: 9asMargin  ^Margin fromNumber: selftestShallowCopy  self assert: nil shallowCopy isNilcompile: arg1  ^self compile: arg1 notifying: niltestMinusADuration  self assert: aTimespan - aDay equals: anOverlappingTimespan.  self assert: aDisjointTimespan - aWeek equals: aTimespanhash  < primitive: 171>  ^self primitiveFailedinitialize  mightBeASquare  ^falsestoreOn: arg1  self shouldBePrintedAsLiteral ifTrue: [ self printOn: arg1 ] ifFalse: [ arg1           nextPut: $(;           store: numerator;           nextPut: $/;           store: denominator;           nextPut: $s;           store: scale;           nextPut: $) ]isRealPrimitive  ^self isPrimitive and: [ self isQuick not ]tempNames  ^self sourceNodeExecuted scope allTempNamestestEmbeddingSourceCode: arg1  | tmp1 tmp2 |  tmp1 := CompiledMethodTrailer new.  tmp1 embeddedSourceCode: arg1.  tmp2 := tmp1 testEncoding.  self assert: (#(EmbeddedSource EmbeddedSourceWide) includes: tmp1 kind).  self assert: tmp2 sourceCode equals: arg1.  self assert: tmp2 endPC equals: 0isObsolete  ^self propertyAt: #obsolete ifAbsent: falseisExtensionProtocol  ^self name first = $*testBetweenAndDoDisjointWithSchedule  | tmp1 |  tmp1 := 0.  aSchedule between: (DateAndTime year: 2004 month: 4 day: 1) and: (DateAndTime year: 2004 month: 4 day: 30) do: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 0isDeprecated  ^self package isDeprecatedtestOR  self assert: false | true.  self deny: false | falsesetBaseline: arg1 withInMetacelloConfig: arg2  arg2 setBaseline: arg1 withBlock: selfallInstVarNamesEverywhere  ^self withAllSuperAndSubclasses flatCollectAsSet: [:arg1 |  arg1 instVarNames ]when: arg1 send: arg2 to: arg3 with: arg4  self when: arg1 evaluate: (WeakMessageSend receiver: arg3 selector: arg2 arguments: {arg4})parseVariableDigitMonth  month := self parse: 'month'testOffset  self assert: aDateAndTime offset equals: '0:00:00:00' asDuration.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1970-01-01T12:00:00+12:00' asDateAndTimeclassForScheduler  ^DelayBasicSchedulergpsExample1: arg1  | tmp1 tmp2 tmp3 |  tmp1 := [:arg2 :arg3 :arg4 |  | tmp4 |  tmp4 := 1.  arg4 first value: 0.  [ arg2 first value: tmp4.  arg4 first value: arg4 last value + arg3 last value.  tmp4 := tmp4 + 1.  tmp4 <= arg1 size ] whileTrue: [  ].  arg4 last value ].  ^tmp1 value: (Array with: [:arg5 |  tmp2 := arg5 ] with: [ tmp2 ]) value: (Array with: [:arg5 |  arg1 at: tmp2 put: arg5 ] with: [ arg1 at: tmp2 ]) value: (Array with: [:arg5 |  tmp3 := arg5 ] with: [ tmp3 ])testSeconds  self assert: (Time readFrom: '20:33:14.321-05:00' readStream) asDuration seconds equals: 14comment  ^self methodClass firstPrecodeCommentFor: self selectormethodDictionary  ^self methodDictcanBeRemoved  ^self isEmptyasRingDefinition  ^self instanceSide asRingDefinition classSideifNotNil: arg1  ^selfgtInspectorRawIn: arg1  ^arg1 custom: GTObjectVariablesBrowser neworigin  ^origindefaultReturnValue  ^niltestArithmetic  | tmp1 tmp2 tmp3 |  tmp1 := time addSeconds: 70.  self     assert: tmp1 hours equals: 4;     assert: tmp1 minutes equals: 3;     assert: tmp1 seconds equals: 57.  tmp2 := tmp1 addTime: (self timeClass fromSeconds: 60 * 60 * 5).  self     assert: tmp2 hours equals: 9;     assert: tmp2 minutes equals: 3;     assert: tmp2 seconds equals: 57.  tmp3 := tmp2 subtractTime: (self timeClass fromSeconds: 60 * 60 * 5 + 70).  self assert: tmp3 equals: timevalueSelector  ^#valueallSlots  ^self classLayout allVisibleSlotsdoubleResumeTest  [ self doSomething.  MyResumableTestError signal.  self doSomethingElse.  MyResumableTestError signal.  self doYetAnotherThing ] on: MyResumableTestError do: [:arg1 |  arg1 resume ]asWeek  ^Week starting: selfreciprocal  numerator abs = 1 ifTrue: [ ^denominator * numerator ].  ^self class numerator: denominator denominator: numeratorexistsProtocolNamed: arg1  ^self allProtocols anySatisfy: [:arg2 |  arg2 name = arg1 ]addToComposition: arg1  self setTraitComposition: self traitComposition + arg1copyWithout: arg1  | tmp1 tmp2 tmp3 |  tmp2 := self class basicNew: (tmp1 := self basicSize) - ((self includes: arg1) ifTrue: [ 1 ] ifFalse: [ 0 ]).  tmp3 := 0.  1 to: tmp1 do: [:arg2 |  (self basicAt: arg2) = arg1 ifTrue: [ tmp3 := 1 ] ifFalse: [ tmp2 basicAt: arg2 - tmp3 put: (self basicAt: arg2) shallowCopy ] ].  1 to: self class instSize do: [:arg2 |  tmp2 instVarAt: arg2 put: (self instVarAt: arg2) ].  ^tmp2printOn: arg1 format: arg2  BasicDatePrinter default printDate: self format: arg2 on: arg1normalize  ^selfaddObsoleteSubclass: arg1  | tmp1 |  tmp1 := self basicObsoleteSubclasses at: self ifAbsent: [ WeakArray new ].  (tmp1 includes: arg1) ifTrue: [ ^self ].  tmp1 := tmp1 copyWithout: nil.  tmp1 := tmp1 copyWith: arg1.  self basicObsoleteSubclasses at: self put: tmp1timesTwoPower: arg1  < primitive: 554>  arg1 < -29 ifTrue: [ ^self * (2.0 raisedToInteger: arg1) ].  arg1 < 0 ifTrue: [ ^self / (1 bitShift: 0 - arg1) asFloat ].  arg1 < 30 ifTrue: [ ^self * (1 bitShift: arg1) asFloat ].  ^self * (2.0 raisedToInteger: arg1)obsoleteSubclasses  self isMetaclassOfClassOrNil ifTrue: [ ^#() ].  ^self instanceSide obsoleteSubclasses collect: [:arg1 |  arg1 classSide ]simpleNoTimeoutTest  [ self doSomething ] valueWithin: 1 day onTimeout: [ self doSomethingElse ]bitShift: arg1  | tmp1 |  tmp1 := self bitShiftMagnitude: arg1.  ^((self negative and: [ arg1 negative ]) and: [ self anyBitOfMagnitudeFrom: 1 to: arg1 negated ]) ifTrue: [ tmp1 - 1 ] ifFalse: [ tmp1 ]printStringOfTree: arg1  ^String streamContents: [:arg2 |  self printStringOfTree: arg1 onStream: arg2 ]obsolete  bitAt: arg1  | tmp1 tmp2 tmp3 |  tmp1 := (arg1 - 1) // 8 + 1.  tmp1 > self bytesCount ifTrue: [ ^1 ].  tmp2 := (arg1 - 1) \\ 8 + 1.  tmp3 := 1.  [ tmp3 = tmp1 ifTrue: [ ^(self byteAt: tmp1) negated bitAt: tmp2 ].  (self byteAt: tmp3) = 0 ] whileTrue: [ tmp3 := tmp3 + 1 ].  ^1 - ((self byteAt: tmp1) bitAt: tmp2)index  ^indexlink: arg1 toAST: arg2  arg2 link: arg1metacelloSemanticIntegerLessThanSelf: arg1  ^self error: 'Invalid Metacello verson component - should be String or Integer.'testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 0.  self assert: aDateAndTime hour equals: aDateAndTime hoursprivateSetOrigin: arg1  origin := arg1previous  ^self class starting: self start - 1= arg1  < primitive: 110>  ^self == arg1upperBound: arg1  upperBound := arg1testSchedulesFIFO  | tmp1 tmp2 tmp3 |  tmp2 := tmp3 := false.  tmp1 := Semaphore new.  [ tmp1 wait.  tmp2 := true ] forkAt: Processor activeProcess priority + 10.  [ tmp1 wait.  tmp3 := true ] forkAt: Processor activeProcess priority + 20.  self deny: tmp2.  self deny: tmp3.  tmp1 signal.  self assert: tmp2.  tmp1 signal.  self assert: tmp3at: arg1 put: arg2  ^self basicAt: arg1 put: arg2totalSeconds  ^nanos = 0 ifTrue: [ seconds ] ifFalse: [ self asNanoSeconds / 1e9 ]sortsBefore: arg1  ^y = arg1 y ifTrue: [ x <= arg1 x ] ifFalse: [ y <= arg1 y ]cleanUp  readsRef: arg1  (self localReadsRef: arg1) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:arg2 |  arg2 readsRef: arg1 ]testMidnight  self assert: aDateAndTime midnight equals: aDateAndTimewaitProcessSuspend: arg1  self waitFor: [ arg1 isSuspended ]addExclusion: arg1  ^exclusions add: arg1greaseInteger  ^self truncatedtestRemoveClassSlot  | tmp1 tmp2 tmp3 |  tmp1 := testEnvironment at: #TUTU.  tmp2 := #X => InstanceVariableSlot.  tmp3 := #Y => InstanceVariableSlot.  tmp1 addClassSlot: tmp2.  self assert: tmp1 class instVarNames equals: #(#X).  tmp1 addClassSlot: tmp3.  self assert: tmp1 class instVarNames equals: #(#X #Y).  tmp1 removeClassSlot: tmp3.  self assert: tmp1 class instVarNames equals: #(#X).  tmp1 removeClassSlot: tmp2.  self assert: tmp1 class instVarNames equals: #()testBitXor  self assert: (2r1100 bitXor: 2r1010) equals: 2r0110indirectDeprecatedMethod  testFloorLog  self assert: (1 / 100 floorLog: 10) equals: -2.  self assert: ((2 raisedTo: Float emax + 11) / 3 floorLog: 10) = ((Float emax + 11) * 2 log - 3 log) floor description: 'Fraction>>log should not overflow'.  self assert: (3 / (2 raisedTo: Float precision - Float emin) floorLog: 10) = ((Float emin - Float precision) * 2 log + 3 log) floor description: 'Fraction>>log should not underflow'genStorePopInstVar: arg1  arg1 >= 0 ifTrue: [ arg1 < 8 ifTrue: [ stream nextPut: 96 + arg1.              ^self ].        arg1 < 64 ifTrue: [ stream                 nextPut: 130;                 nextPut: arg1.              ^self ] ].  self genStorePopInstVarLong: arg1split: arg1 indicesDo: arg2  | tmp1 |  tmp1 := 1.  arg1 withIndexDo: [:arg3 :arg4 |  (self value: arg3) ifTrue: [ arg2 value: tmp1 value: arg4 - 1.              tmp1 := arg4 + 1 ] ].  arg2 value: tmp1 value: arg1 sizetestSizeInMemoryOfByteObjects  self assert: 'a' sizeInMemory equals: (self paddedByteStringSize: 1).  self assert: 'abcd' sizeInMemory equals: (self paddedByteStringSize: 4).  self assert: '' sizeInMemory equals: (self paddedByteStringSize: 0).  self assert: 'abcde' sizeInMemory equals: (self paddedByteStringSize: 5).  self assert: 'abcdefghi' sizeInMemory equals: (self paddedByteStringSize: 9)value: arg1 value: arg2  ^receiver perform: selector with: arg1 with: arg2sqrt  < primitive: 555>  | tmp1 tmp2 tmp3 tmp4 |  self <= 0.0 ifTrue: [ self = 0.0 ifTrue: [ ^0.0 ] ifFalse: [ ^DomainError signal: 'sqrt undefined for number less than zero.' ] ].  tmp1 := self exponent // 2.  tmp2 := self timesTwoPower: 0 - tmp1.  tmp3 := tmp2 * Epsilon.  tmp3 := tmp3 * tmp3.  tmp4 := (self - (tmp2 * tmp2)) / (tmp2 * 2.0).  [ tmp4 * tmp4 > tmp3 ] whileTrue: [ tmp2 := tmp2 + tmp4.        tmp4 := (self - (tmp2 * tmp2)) / (tmp2 * 2.0) ].  ^tmp2registrationsCompareEqual: arg1  ^self = arg1hash  ^self identityHashdaysInMonth  ^self duration daysinitialize  super initialize.  semaphore := Semaphore forMutualExclusionsetBlessingInMetacelloVersion: arg1  arg1 setBlessing: selflink: arg1 toSlotNamed: arg2  self link: arg1 toSlot: (MetalinkTargetResolver slotNamed: arg2 for: self)isExplicitlyRequired  ^self isExplicitlyRequired: self markerOrNilensureReceiver  self receiver ifNil: [ ^false ].  self receiver class isObsolete ifTrue: [ ^false ].  (self receiver isBehavior and: [ self receiver isObsolete ]) ifTrue: [ ^false ].  ^truehasLiteralSuchThat: arg1  ^(arg1 value: self selector) or: [ arguments hasLiteralSuchThat: arg1 ]testYearDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 2004 day: 60 hour: 13 minute: 33 second: 0 offset: 2 hours)removeAll  | tmp1 |  tally = 0 ifTrue: [ ^self ].  tmp1 := self species newForCapacity: self basicSize.  self copyFrom: tmp1testYearMonthDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0)reflectivityDisabled  ^self hasPragmaNamed: #disableReflectivitydayMonthYearDo: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self julianDayNumber + 68569.  tmp2 := 4 * tmp1 // 146097.  tmp1 := tmp1 - ((146097 * tmp2 + 3) // 4).  tmp3 := 4000 * (tmp1 + 1) // 1461001.  tmp1 := tmp1 - (1461 * tmp3 // 4) + 31.  tmp4 := 80 * tmp1 // 2447.  tmp5 := tmp1 - (2447 * tmp4 // 80).  tmp1 := tmp4 // 11.  tmp6 := tmp4 + 2 - (12 * tmp1).  tmp7 := 100 * (tmp2 - 49) + tmp3 + tmp1.  ^arg1 value: tmp5 value: tmp6 value: tmp7numArgs: arg1  numArgs := arg1printOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self days abs.  tmp2 := self hours abs.  tmp3 := self minutes abs.  tmp4 := self seconds abs truncated.  tmp5 := self nanoSeconds abs.  self negative ifTrue: [ arg1 nextPut: $- ].  tmp1 printOn: arg1.  arg1 nextPut: $:.  tmp2 < 10 ifTrue: [ arg1 nextPut: $0 ].  tmp2 printOn: arg1.  arg1 nextPut: $:.  tmp3 < 10 ifTrue: [ arg1 nextPut: $0 ].  tmp3 printOn: arg1.  arg1 nextPut: $:.  tmp4 < 10 ifTrue: [ arg1 nextPut: $0 ].  tmp4 printOn: arg1.  tmp5 = 0 ifFalse: [ | tmp6 tmp7 |        arg1 nextPut: $..        tmp7 := tmp5 printString padLeftTo: 9 with: $0.        tmp6 := tmp7 findLast: [:arg2 |  arg2 asciiValue > $0 asciiValue ].        tmp7 from: 1 to: tmp6 do: [:arg2 |  arg1 nextPut: arg2 ] ]deprecatedMethod3  self deprecated: 'Example of a deprecated method with transform' transformWith: '`@receiver deprecatedMethod3' -> '`@receiver deprecatedMethod3'testResumableOuter  | tmp1 |  tmp1 := [ Notification signal.  4 ] on: Notification do: [:arg1 |  arg1 outer.        arg1 return: 5 ].  self assert: tmp1 equals: 5abstractBytecodeMessagesFrom: arg1 to: arg2 do: arg3  | tmp1 |  tmp1 := InstructionStream new method: self pc: arg1.  [ tmp1 pc <= arg2 ] whileTrue: [ [ tmp1 interpretNextInstructionFor: nil ] on: MessageNotUnderstood do: [:arg4 |  arg3 value: arg4 message ] ]testCreationFromBytes3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  Smalltalk vm wordSize = 4 ifFalse: [ ^self skip ].  tmp1 := SmallInteger maxVal.  tmp2 := (tmp1 - 1) printStringHex.  self assert: tmp2 size equals: 8.  tmp6 := Number readFrom: (tmp2 copyFrom: 1 to: 2) base: 16.  tmp5 := Number readFrom: (tmp2 copyFrom: 3 to: 4) base: 16.  tmp4 := Number readFrom: (tmp2 copyFrom: 5 to: 6) base: 16.  tmp3 := Number readFrom: (tmp2 copyFrom: 7 to: 8) base: 16.  tmp7 := Integer byte1: tmp3 byte2: tmp4 byte3: tmp5 byte4: tmp6.  self assert: tmp7 equals: tmp1 - 1.  self assert: tmp7 class equals: SmallIntegerexponent  < primitive: 553>  | tmp1 |  self >= 1.0 ifTrue: [ ^self floorLog: 2 ].  self > 0.0 ifTrue: [ tmp1 := (1.0 / self) exponent.        self = (1.0 / (1.0 timesTwoPower: tmp1)) ifTrue: [ ^tmp1 negated ] ifFalse: [ ^tmp1 negated - 1 ] ].  self = 0.0 ifTrue: [ ^-1 ].  ^self negated exponenttestSupplyAnswerUsingRegexMatchOfQuestion  (String includesSelector: #matchesRegex:) ifFalse: [ ^self ].  self should: [ true = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('.*Smalltalk\?' true)) ]cull: arg1 cull: arg2  ^selector numArgs < 2 ifTrue: [ self cull: arg1 ] ifFalse: [ self value: arg1 value: arg2 ]when: arg1 send: arg2 to: arg3  self when: arg1 evaluate: (WeakMessageSend receiver: arg3 selector: arg2)testMinus  self assert: aDateAndTime - aDateAndTime equals: '0:00:00:00' asDuration.  self assert: aDateAndTime - '0:00:00:00' asDuration equals: aDateAndTime.  self assert: aDateAndTime - aDuration equals: (DateAndTime year: 1979 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours)adaptToFraction: arg1 andCompare: arg2  ^self adaptToFraction: arg1 andSend: arg2asFileNameCompatibleString  | tmp1 |  tmp1 := String new writeStream.  self printYMDOn: tmp1.  tmp1 << '.'.  self printHMSWithDashesOn: tmp1.  ^tmp1 contentsvalue  ^valuedependents  ^self myDependents ifNil: [ #() ]skipBackBeforeJump  | tmp1 tmp2 tmp3 |  tmp1 := InstructionStream on: self method.  tmp2 := InstructionClient new.  [ tmp1 pc < pc ] whileTrue: [ tmp3 := tmp1 pc.        tmp1 interpretNextInstructionFor: tmp2 ].  tmp1 pc: tmp3.  (tmp1 willJumpIfTrue or: [ tmp1 willJumpIfFalse ]) ifFalse: [ self error: 'Where''s the jump??' ].  self jump: tmp3 - pctestAsTime  self assert: aDateAndTime asTime equals: Time midnightrandomCharacterAtOrAbove: arg1  ^self randomCharacterBetween: arg1 and: Unicode maxValuetearDown  RPackage organizer unregisterPackageNamed: self categoryNameForTemporaryClasses.  super tearDownhasAtLeastTheSamePropertiesAs: arg1  arg1 keysAndValuesDo: [:arg2 :arg3 |  (arg3 isKindOf: Pragma) ifFalse: [ (self includes: arg2 -> arg3) ifFalse: [ ^false ] ] ].  ^trueprintSeparatedBy: arg1 every: arg2 signed: arg3 on: arg4  ^self printSeparatedBy: arg1 every: arg2 signed: arg3 base: 10 on: arg4setMethod: arg1  method := arg1.  1 to: self basicSize do: [:arg2 |  | tmp1 |        (tmp1 := self basicAt: arg2) isVariableBinding ifFalse: [ tmp1 method: arg1 ] ]fuelAccept: arg1  ^self <= 4294967295 ifTrue: [ arg1 mapAndTraceByClusterName: self to: FLPositive32SmallIntegerCluster ] ifFalse: [ arg1 visitBytesObject: self ]findGlobalVariable: arg1 ifNone: arg2  | tmp1 |  tmp1 := OCLiteralVariable new.  tmp1 scope: self.  self classPool associationsDo: [:arg3 |  tmp1 assoc: arg3.        (arg1 value: tmp1) ifTrue: [ ^tmp1 ] ].  self sharedPools do: [:arg4 |  arg4 classPool associationsDo: [:arg3 |  tmp1 assoc: arg3.              (arg1 value: tmp1) ifTrue: [ ^tmp1 ] ] ].  self environment associationsDo: [:arg3 |  tmp1 assoc: arg3.        (arg1 value: tmp1) ifTrue: [ ^tmp1 ] ].  ^arg2 valuehaltIfNotTest  < debuggerCompleteToSender>  Halt ifNotTestintervalString  | tmp1 |  tmp1 := self asDuration.  ^String streamContents: [:arg1 |  tmp1 hours > 0 ifTrue: [ arg1                 print: tmp1 hours;                 nextPutAll: ' hours' ].        tmp1 minutes > 0 ifTrue: [ arg1                 space;                 print: tmp1 minutes;                 nextPutAll: ' minutes' ].        tmp1 seconds > 0 ifTrue: [ arg1                 space;                 print: tmp1 seconds;                 nextPutAll: ' seconds' ] ]testParsingYYYYPatternWithWrongNumberOrDigitsShouldFails  self assertReading: '02.11.3' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.11.13' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.11.113' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.11.10113' as: 'dd.mm.yyyy' raise: DateErrorlocalSize  ^self sizetestAsSmallerPowerOfTwo  self assert: (1 / 2) asSmallerPowerOfTwo equals: 1 / 2.  self assert: (Fraction numerator: 2 denominator: 4) asSmallerPowerOfTwo equals: 1 / 2.  self assert: (2 / 5) asSmallerPowerOfTwo equals: 1 / 4.  self assert: (Fraction numerator: 10 denominator: 25) asSmallerPowerOfTwo equals: 1 / 4.  self assert: (Fraction numerator: 2 denominator: 1) asSmallerPowerOfTwo equals: 2.  self assert: (Fraction numerator: 4 denominator: 2) asSmallerPowerOfTwo equals: 2.  self assert: (11 / 2) asSmallerPowerOfTwo equals: 4.  self assert: (Fraction numerator: 44 denominator: 8) asSmallerPowerOfTwo equals: 4.  self assert: (1 / (2 raisedTo: 80)) asSmallerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160)) asSmallerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (1 / ((2 raisedTo: 80) - 1)) asSmallerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160) - 1) asSmallerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: 1) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 160) denominator: (2 raisedTo: 80)) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) + 1 denominator: 1) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 160) + 1 denominator: (2 raisedTo: 80)) asSmallerPowerOfTwo equals: (2 raisedTo: 80).  self should: [ (Fraction numerator: 0 denominator: 1) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 negated denominator: 2) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 denominator: 2 negated) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 2 negated denominator: 4) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 2 denominator: 4 negated) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 negated denominator: (2 raisedTo: 80)) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 denominator: (2 raisedTo: 80) negated) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: (2 raisedTo: 80) negated denominator: (2 raisedTo: 160)) asSmallerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160) negated) asSmallerPowerOfTwo ] raise: DomainErrortempsAndValuesLimitedTo: arg1 indent: arg2  ^String streamContents: [:arg3 |  self tempNames do: [:arg4 |  arg2 timesRepeat: [ arg3 tab ].              arg3                 nextPutAll: arg4;                 nextPut: $:;                 space;                 tab.              arg3 nextPutAll: ((self tempNamed: arg4) printStringLimitedTo: (arg1 - 3 - arg4 size max: 1)) ] separatedBy: [ arg3 cr ] ]isSelfEvaluating  ^truegenSendSpecial: arg1 numArgs: arg2  self assert: (arg1 between: 1 and: Smalltalk specialSelectorSize).  self assert: arg2 = (Smalltalk specialNargsAt: arg1).  stream nextPut: arg1 + 95asFloat  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp1 := numerator abs.  tmp2 := denominator.  tmp8 := tmp1 highBitOfMagnitude.  tmp9 := tmp2 highBitOfMagnitude.  tmp7 := 1 + Float precision.  (tmp8 < tmp7 and: [ tmp9 < tmp7 ]) ifTrue: [ ^numerator asFloat / denominator asFloat ].  tmp4 := tmp8 - tmp9 - tmp7.  tmp4 >= 0 ifTrue: [ tmp2 := tmp2 bitShift: tmp4 ] ifFalse: [ tmp1 := tmp1 bitShift: tmp4 negated ].  tmp3 := tmp1 quo: tmp2.  tmp5 := tmp1 > (tmp3 * tmp2).  tmp10 := tmp3 highBit.  tmp6 := Float emin - (tmp4 + tmp10 - 1).  tmp6 > 0 ifTrue: [ tmp7 := tmp7 - tmp6 max: 1 ].  tmp10 > tmp7 ifTrue: [ tmp4 := tmp4 + tmp10 - tmp7.        tmp5 := tmp5 or: [ tmp3 anyBitOfMagnitudeFrom: 1 to: tmp10 - tmp7 ].        tmp3 := tmp3 bitShift: tmp7 - tmp10 ].  (tmp5 and: [ tmp3 odd ]) ifTrue: [ tmp3 := tmp3 + 1 ].  ^(self positive ifTrue: [ tmp3 asFloat ] ifFalse: [ tmp3 asFloat negated ]) timesTwoPower: tmp4testReciprocal  self     assert: (1 / 2) reciprocal equals: 2;     assert: (3 / 4) reciprocal equals: 4 / 3;     assert: (-1 / 3) reciprocal equals: -3;     assert: (-3 / 5) reciprocal equals: -5 / 3shouldBeSubstitutedByCleanCopy  ^self isCleanallSlots  ^#()repeatWithGCIf: arg1  | tmp1 |  tmp1 := self value.  (arg1 value: tmp1) ifTrue: [ Smalltalk garbageCollect.        tmp1 := self value ].  ^tmp1testMutateObjectInstVarUsingAtPut  | tmp1 |  tmp1 := Array new: 5.  tmp1 beReadOnlyObject.  self should: [ tmp1 at: 1 put: #test ] raise: ModificationForbidden.  [ tmp1 at: 1 put: #test ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first equals: #testgtInspectorSourceCodeIn: arg1  minutes  ^self asDuration minutestestDegreeSin  (4 / 3) degreeSin.  -361 / 3 to: 359 / 3 do: [:arg1 |  self assert: (arg1 degreeSin closeTo: arg1 degreesToRadians sin) ]testSuperclassOrderPreservingOrder  | tmp1 tmp2 |  tmp1 := {CharacterSet .   WideCharacterSet .   OrderedDictionary .   DependentsArray .   Bag .   SmallDictionary .   SequenceableCollection .   HashedCollection .   WeakRegistry .   Heap}.  tmp2 := Class superclassOrder: tmp1.  self assert: tmp2 equals: tmp1 asOrderedCollectiondefinitionForNautilus  ^self definitionbetween: arg1 and: arg2  ^self >= arg1 and: [ self <= arg2 ]testAsDateAndTime  self assert: aTimespan asDateAndTime equals: jan01dayOfWeekName  ^start dayOfWeekNametestAsHours  self assert: (Duration hours: 2) asHours equals: 2.  self assert: (Duration days: 1) asHours equals: 24.  self assert: (aDuration asHours closeTo: 26.0511)testNotNil  self deny: nil notNil> arg1  ^self asciiValue > arg1 asciiValuesourceNode  ^self method sourceNodeForPC: self startpc - 1propertyAt: arg1  ^self propertyAt: arg1 ifAbsent: [ nil ]asPoint  ^self @ self= arg1  ^arg1 isMessageSend and: [ self receiver == arg1 receiver and: [ selector == arg1 selector and: [ (Array withAll: arguments) = (Array withAll: arg1 arguments) ] ] ]forkAndWait  | tmp1 |  tmp1 := Semaphore new.  [ self ensure: [ tmp1 signal ] ] fork.  tmp1 waitprintYMDOn: arg1 withLeadingSpace: arg2  | tmp1 tmp2 tmp3 |  self dayMonthYearDo: [:arg3 :arg4 :arg5 |  tmp1 := arg5.        tmp2 := arg4.        tmp3 := arg3 ].  tmp1 negative ifTrue: [ arg1 nextPut: $- ] ifFalse: [ arg2 ifTrue: [ arg1 space ] ].  tmp1 abs printOn: arg1 base: 10 length: 4 padded: true.  arg1 nextPut: $-.  tmp2 printOn: arg1 base: 10 length: 2 padded: true.  arg1 nextPut: $-.  tmp3 printOn: arg1 base: 10 length: 2 padded: truenewValue  ^newValuedecodeExtendedKind  self shouldBeImplementedbrowse  ^Smalltalk tools browser openOnClass: self methodClass selector: self selectorchangeFromString: arg1  | tmp1 |  tmp1 := arg1 parseLiterals.  (tmp1 isEmpty and: [ self protocolOrganizer protocols isEmpty ]) ifTrue: [ ^self protocolOrganizer reset ].  ^self changeFromCategorySpecs: tmp1basicIdentityHash  < primitive: 171>  ^self primitiveFailedabstractBytecodeMessagesFrom: arg1 to: arg2  | tmp1 tmp2 |  tmp1 := InstructionStream new method: self pc: arg1.  tmp2 := OrderedCollection new.  [ tmp1 pc <= arg2 ] whileTrue: [ [ tmp1 interpretNextInstructionFor: nil ] on: MessageNotUnderstood do: [:arg3 |  tmp2 add: arg3 message ] ].  ^tmp2isLeapYear  ^Year isLeapYear: self yearceiling  self isIntegerRectangle ifTrue: [ ^self ].  ^origin ceiling corner: corner ceilingtestReadFromDefaultOffsetNotSpecified  self assert: (DateAndTime readFrom: '2016-07-03T21:16:16.708241' readStream defaultOffset: Duration zero) offset equals: Duration zerotestPlus  self assert: aDuration + 0 hours equals: aDuration.  self assert: aDuration + aDuration equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10)shouldTransform  self class activateTransformations ifFalse: [ ^false ].  (condition isNil or: [ condition cull: self ]) ifFalse: [ ^false ].  ^rule isNotNiladdMethod: arg1  self deprecated: 'Use #addMethodSelector: instead' transformWith: '`@receiver addMethod: `@arg' -> '`@receiver addMethodSelector: `@arg'.  ^self addMethodSelector: arg1value: arg1 value: arg2 value: arg3 value: arg4  < primitive: 205>  numArgs ~= 4 ifTrue: [ self numArgsError: 4 ].  ^self primitiveFailedstartUp  startUp  self resumeflipBy: arg1 centerAt: arg2  arg1 == #vertical ifTrue: [ ^x @ (arg2 y * 2 - y) ].  arg1 == #horizontal ifTrue: [ ^(arg2 x * 2 - x) @ y ].  self error: 'unrecognizable direction'testHandlingExceptionSetWithExclusion  | tmp1 |  tmp1 := false.  self should: [ [ ZeroDivide signalWithDividend: 1 ] on: (Error , ArithmeticError) - ZeroDivide do: [:arg1 |  tmp1 := true.              arg1 return ] ] raise: ZeroDivide.  self deny: tmp1asScriptResultStringInCalypso  ^self printStringdateAndTimes  | tmp1 |  tmp1 := OrderedCollection new.  self scheduleDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1 asArrayisOnOrBefore: arg1  ^(self equals: arg1) or: [ self isBefore: arg1 ]privRestartArgBlockTest  | tmp1 |  tmp1 := true.  self assert: 30 equals: ([:arg1 |  | tmp2 |        self assert: 10 equals: arg1.        self assert: nil identicalTo: tmp2.        tmp2 := arg1 + 20.        tmp1 ifTrue: [ tmp1 := false.              thisContext restart ].        tmp2 ] value: 10)absPrintExactlyOn: arg1 base: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 tmp16 tmp17 |  self isInfinite ifTrue: [ arg1 nextPutAll: 'Float infinity'.        ^self ].  tmp1 := arg2 asFloat.  tmp2 := self significandAsInteger.  tmp12 := tmp2 even.  tmp3 := self exponent - 52 max: MinValLogBase2.  tmp4 := (self exponent * tmp1 reciprocalLogBase2 - 1.0e-10) ceiling.  tmp3 >= 0 ifTrue: [ tmp5 := 1 << tmp3.        tmp2 ~= 16r10000000000000 ifTrue: [ tmp7 := tmp2 * tmp5 * 2.              tmp8 := 2.              tmp9 := tmp5 ] ifFalse: [ tmp6 := tmp5 * 2.              tmp7 := tmp2 * tmp6 * 2.              tmp8 := 4.              tmp9 := tmp6 ].        tmp10 := tmp5 ] ifFalse: [ tmp3 = MinValLogBase2 | (tmp2 ~= 16r10000000000000) ifTrue: [ tmp7 := tmp2 * 2.              tmp8 := (1 << tmp3 negated) * 2.              tmp9 := 1 ] ifFalse: [ tmp7 := tmp2 * 4.              tmp8 := (1 << (tmp3 negated + 1)) * 2.              tmp9 := 2 ].        tmp10 := 1 ].  tmp4 >= 0 ifTrue: [ tmp8 := tmp8 * (arg2 raisedToInteger: tmp4) ] ifFalse: [ tmp11 := arg2 raisedToInteger: tmp4 negated.        tmp7 := tmp7 * tmp11.        tmp9 := tmp9 * tmp11.        tmp10 := tmp10 * tmp11 ].  tmp7 + tmp9 > tmp8 | (tmp12 & (tmp7 + tmp9 = tmp8)) ifTrue: [ tmp4 := tmp4 + 1 ] ifFalse: [ tmp7 := tmp7 * arg2.        tmp9 := tmp9 * arg2.        tmp10 := tmp10 * arg2 ].  (tmp16 := tmp4 between: -3 and: 6) ifTrue: [ tmp17 := tmp4.        tmp4 <= 0 ifTrue: [ arg1 nextPutAll: ('0.000000' truncateTo: 2 - tmp4) ] ] ifFalse: [ tmp17 := 1 ].  [ tmp13 := tmp7 // tmp8.  tmp7 := tmp7 \\ tmp8.  (tmp14 := tmp7 < tmp10 | (tmp12 & (tmp7 = tmp10))) | (tmp15 := tmp7 + tmp9 > tmp8 | (tmp12 & (tmp7 + tmp9 = tmp8))) ] whileFalse: [ arg1 nextPut: (Character digitValue: tmp13).        tmp7 := tmp7 * arg2.        tmp9 := tmp9 * arg2.        tmp10 := tmp10 * arg2.        tmp17 := tmp17 - 1.        tmp17 = 0 ifTrue: [ arg1 nextPut: $. ] ].  tmp15 ifTrue: [ tmp14 not | (tmp14 & (tmp7 * 2 >= tmp8)) ifTrue: [ tmp13 := tmp13 + 1 ] ].  arg1 nextPut: (Character digitValue: tmp13).  tmp17 > 0 ifTrue: [ tmp17 - 1 to: 1 by: -1 do: [:arg3 |  arg1 nextPut: $0 ].        arg1 nextPutAll: '.0' ].  tmp16 ifFalse: [ arg1 nextPut: $e.        arg1 nextPutAll: (tmp4 - 1) printString ]isZero  ^x isZero and: [ y isZero ]definedSelectors  ^self package definedSelectorsForClass: self// arg1  arg1 isPoint ifTrue: [ ^(x // arg1 x) @ (y // arg1 y) ].  ^arg1 adaptToPoint: self andSend: #//onLineFrom: arg1 to: arg2 within: arg3  arg1 x < arg2 x ifTrue: [ (x < (arg1 x - arg3) or: [ x > (arg2 x + arg3) ]) ifTrue: [ ^false ] ] ifFalse: [ (x < (arg2 x - arg3) or: [ x > (arg1 x + arg3) ]) ifTrue: [ ^false ] ].  arg1 y < arg2 y ifTrue: [ (y < (arg1 y - arg3) or: [ y > (arg2 y + arg3) ]) ifTrue: [ ^false ] ] ifFalse: [ (y < (arg2 y - arg3) or: [ y > (arg1 y + arg3) ]) ifTrue: [ ^false ] ].  ^(self distanceTo: (self nearestPointAlongLineFrom: arg1 to: arg2)) <= arg3crLog: arg1  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver crLog: `@statements1' -> '`@receiver crTrace: `@statements1'.  self crTrace: arg1pushNewArrayOfSize: arg1  self push: (Array new: arg1)timeToRun  ^Duration milliSeconds: (Time millisecondsToRun: self)constructCannotReturnBlockInDeadFrame  ^[:arg1 |  ^arg1 ]do: arg1 with: arg2 when: arg3  | tmp1 tmp2 |  tmp1 := arg2.  tmp2 := self end.  [ tmp1 start <= tmp2 ] whileTrue: [ (arg3 value: tmp1) ifTrue: [ arg1 value: tmp1 ].        tmp1 := tmp1 next ]isRGUnresolvedValue  ^falseisExtendedInPackage: arg1  ^arg1 extendsClass: selfreset  self suspend.  timespans := nilprotocol: arg1  ^self methodClass organization classify: self selector under: arg1sendsSelector: arg1  ^self messages includes: arg1testMonthPrintOn  | tmp1 |  tmp1 := Month starting: DateAndTime new duration: 31 days.  self assert: (String streamContents: [:arg1 |  tmp1 printOn: arg1 ]) equals: 'January 1901'hasDynamicItems  ^falsetestParsingMPatternWithTwoDigitSucceeds  | tmp1 |  tmp1 := Date year: 2013 month: 11 day: 29.  self assertReading: '29.11.2013' as: 'dd.m.yyyy' equals: tmp1.  self assertReading: '11.2013.29' as: 'm.yyyy.dd' equals: tmp1.  self assertReading: '29.2013.11' as: 'dd.yyyy.m' equals: tmp1testPrinting  self     assert: time printString equals: '4:02:47 am';     assert: time intervalString equals: '4 hours 2 minutes 47 seconds';     assert: time print24 equals: '04:02:47';     assert: time printMinutes equals: '4:02 am';     assert: time hhmm24 equals: '0402'classToBeTested  ^MonthencodeOn: arg1  self printOn: arg1longPrintOn: arg1  self isQuick ifTrue: [ self isReturnSpecial ifTrue: [ ^arg1 nextPutAll: 'Quick return ' , (#('self' 'true' 'false' 'nil' '-1' '0' '1' '2') at: self primitive - 255) ].        ^arg1 nextPutAll: 'Quick return field ' , self returnField printString , ' (0-based)' ].  self isPrimitive ifTrue: [ self printPrimitiveOn: arg1 ].  self symbolicBytecodes do: [:arg2 |  arg2 printOn: arg1 ] separatedBy: [ arg1 cr ]testIfNilIfNotNil  < haltOrBreakpointForTesting>  self should: [ nil ifNil: [ self error ] ifNotNil: [  ] ] raise: ErrorsquaredDistanceTo: arg1  | tmp1 |  tmp1 := arg1 - self.  ^tmp1 dotProduct: tmp1adaptToCollection: arg1 andSend: arg2  ^arg1 collect: [:arg3 |  arg3 perform: arg2 with: self ]<= arg1  arg1 isInteger ifTrue: [ self negative == arg1 negative ifTrue: [ self negative ifTrue: [ ^(self bytesCompare: arg1) >= 0 ] ifFalse: [ ^(self bytesCompare: arg1) <= 0 ] ] ifFalse: [ ^self negative ] ].  ^arg1 adaptToInteger: self andCompare: #<=testJulianDayNumber  self assert: aDateAndTime equals: (DateAndTime julianDayNumber: 2415386).  self assert: aDateAndTime julianDayNumber equals: 2415386nonTrivial  ^self instVarNames notEmpty or: [ self hasMethods or: [ self hasTraitComposition ] ]setDebugOnOff  DebugMe := true.  DebugMe := falsetestReadFrom  self assert: aDuration equals: (Duration readFrom: '1:02:03:04.000000005' readStream)methodWithTranscript  self trace: 'something'classify: arg1 under: arg2 suppressIfDefault: arg3  | tmp1 tmp2 tmp3 tmp4 |  (arg2 = NullCategory or: [ arg2 == nil ]) ifTrue: [ tmp4 := Default ] ifFalse: [ tmp4 := arg2 asSymbol ].  (tmp1 := self categoryOfElement: arg1) = tmp4 ifTrue: [ ^self ].  tmp1 ~~ nil ifTrue: [ (arg3 and: [ tmp4 = Default ]) ifTrue: [ ^self ].        self basicRemoveElement: arg1 ].  (categoryArray indexOf: tmp4) = 0 ifTrue: [ self addCategory: tmp4 ].  tmp2 := categoryArray indexOf: tmp4.  tmp3 := tmp2 > 1 ifTrue: [ categoryStops at: tmp2 - 1 ] ifFalse: [ 0 ].  [ (tmp3 := tmp3 + 1) <= (categoryStops at: tmp2) and: [ arg1 >= (elementArray at: tmp3) ] ] whileTrue.  elementArray := elementArray copyReplaceFrom: tmp3 to: tmp3 - 1 with: (Array with: arg1).  tmp2 to: categoryArray size do: [:arg4 |  categoryStops at: arg4 put: (categoryStops at: arg4) + 1 ].  ((categoryArray includes: Default) and: [ (self listAtCategoryNamed: Default) size = 0 ]) ifTrue: [ self removeCategory: Default ].  self assertInvariantobject: arg1 instVarAt: arg2 put: arg3  < primitive: 74>  ^self object: arg1 basicAt: arg2 - (self objectClass: arg1) instSize put: arg3debuggerMap  ^self compilerClass debuggerMethodMapForMethod: selfnbCall: arg1  < ffiCalloutTranslator>  self deprecated: 'use ffiCall: instead'.  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     function: arg1 library: self ffiLibraryNameprintStringBase: arg1 nDigits: arg2  | tmp1 tmp2 tmp3 |  tmp3 := String new: arg2.  tmp1 := self.  arg2 to: 1 by: -1 do: [:arg3 |  tmp2 := tmp1 // arg1.        tmp3 byteAt: arg3 put: (Character digitValue: tmp1 - (tmp2 * arg1)).        tmp1 := tmp2 ].  ^tmp3merge: arg1  ^Rectangle origin: (origin min: arg1 origin) corner: (corner max: arg1 corner)gtInspectorItemsIn: arg1  testIsUppercase  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isUppercase: tmp2) equals: (tmp1 isUppercase: tmp2) ]testPoolUsers  | tmp1 |  tmp1 := ChronologyConstants poolUsers.  self assert: tmp1 asSet equals: {Date .         DateAndTime .         Duration .         Month .         Time .         TimeZone .         Week .         LocalTimeZone .         AbstractTimeZone} asSettestDayOfWeek  self assert: aDateAndTime dayOfWeek equals: 5.  self assert: aDateAndTime dayOfWeekAbbreviation equals: 'Thu'.  self assert: aDateAndTime dayOfWeekName equals: 'Thursday'testSqrtFloor  #(-1234567890123 -10 -5 -1) do: [:arg1 |  self should: [ arg1 sqrtFloor ] raise: Error ].  #(0 1 2 3 4 5 10 16 30 160479924 386234481 501619156 524723498 580855366 766098594 834165249 1020363860 1042083924 1049218924 1459774772895569 3050005981408238 4856589481837079 5650488387708463 7831037396100244) do: [:arg1 |  self assert: arg1 asFloat sqrt floor equals: arg1 sqrtFloor ]stepTimeIn: arg1  ^1000compiledMethodAt: arg1 ifPresent: arg2 ifAbsent: arg3  ^self methodDict at: arg1 ifPresent: arg2 ifAbsent: arg3criticNameOn: arg1  arg1 << self methodClass name << '>>#' << self selector << ' (' << self methodClass instanceSide category << ')'genTrap  stream nextPut: 217dragTransferTypeForMorph: arg1  ^nilpopTo: arg1  self == Processor activeProcess ifTrue: [ ^self error: 'The active process cannot pop contexts' ].  ^(self calleeOf: arg1) ifNil: [ arg1 ] ifNotNil: [:arg2 |  Processor activeProcess evaluate: [ self return: arg2 value: arg2 receiver ] onBehalfOf: self ]testAsNanoSeconds  self assert: aDateAndTime asNanoSeconds equals: 0 asDuration asNanoSecondssetTop: arg1 left: arg2 bottom: arg3 right: arg4  top := arg1.  left := arg2.  bottom := arg3.  right := arg4testNanoSecond  self assert: aTime nanoSecond equals: 0setUp  super setUp.  month := Month year: 1998 month: 7macRomanToUnicode  ^MacRomanTextConverter new unicodeToByte: selftestAllSlots  self assert: Context allSlots size equals: 6schedule: arg1  accessProtect critical: [ super schedule: arg1 ]asWeakMessageSend  ^WeakMessageSend receiver: receiver selector: selector arguments: arguments copyvalue: arg1  < primitive: 202>  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  self primitiveFailedtestEveryDo  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := 7 days.  aTimespan every: tmp2 do: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 13isIntegerRectangle  ^origin isIntegerPoint and: [ corner isIntegerPoint ]testFloatPrinting  self assert: (0.1 + 0.2) printString equals: '0.30000000000000004'.  self assert: (-0.1 - 0.2) printString equals: '-0.30000000000000004'.  self assert: 240 degreesToRadians cos equals: -0.5000000000000004.  self assert: 240 degreesToRadians cos abs equals: 0.5000000000000004isZero  ^0 = top and: [ 0 = left and: [ 0 = right and: [ 0 = bottom ] ] ]storeOn: arg1  arg1 nextPutAll: self nametestMetaclassPointOfCircularity  self assert: Metaclass class instanceCount equals: 1.  self assert: Metaclass class someInstance identicalTo: MetaclasstestMutateObjectInstVarUsingBasicAtPut  | tmp1 |  tmp1 := Array new: 5.  tmp1 beReadOnlyObject.  self should: [ tmp1 basicAt: 1 put: #test ] raise: ModificationForbidden.  [ tmp1 at: 1 put: #test ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first equals: #testbitString  ^(self bitStringLength to: 1 by: -1) collect: [:arg1 |  Character value: $0 charCode + (self bitAt: arg1) ] as: StringcontextOfSender  ^context senderglamourValueWithArgs: arg1  ^selfwhileTrue  self value ifTrue: [ self whileTrue ]hour12  ^(self hour24 - 1) \\ 12 + 1testAllLocalCallsOn  self assert: (Point allLocalCallsOn: #asPoint) notEmpty.  self assert: (Point allLocalCallsOn: #asPoint) size equals: 4.  self assert: ((Point allLocalCallsOn: #asPoint) includes: Point >> #roundDownTo:).  self assert: ((Point allLocalCallsOn: #asPoint) includes: Point >> #roundUpTo:).  self assert: ((Point allLocalCallsOn: #asPoint) includes: Point >> #roundTo:).  self assert: ((Point allLocalCallsOn: #asPoint) includes: Point >> #truncateTo:)cull: arg1 cull: arg2 cull: arg3  ^selector numArgs < 3 ifTrue: [ self cull: arg1 cull: arg2 ] ifFalse: [ self value: arg1 value: arg2 value: arg3 ]index  ^(self asMonth dayOfWeek + self dayOfMonth - 2) // 7 + 1timeZone  ^TimeZone offset: self offsetduration  | tmp1 tmp2 |  self isSuspended ifTrue: [ (tmp1 := self timespans) isEmpty ifTrue: [ tmp1 := {(Timespan starting: DateAndTime now duration: Duration zero)} ] ] ifFalse: [ tmp2 := self timespans last.        tmp1 := self timespans allButLast           add: (tmp2                 duration: DateAndTime now - tmp2 start;                 yourself);           yourself ].  ^(tmp1 collect: [:arg1 |  arg1 duration ]) sumimmediateSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4  ^self immediateSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: '' package: arg4testPointersTo  | tmp1 tmp2 |  tmp1 := Object new.  self assertEmpty: tmp1 pointersTo.  tmp2 := {tmp1 .   tmp1}.  self assert: tmp1 pointersTo asArray equals: {tmp2}memoizedUsing: arg1  ^[:arg2 |  arg1 at: arg2 ifAbsentPut: [ self value: arg2 ] ]testHasInstVarRef  | tmp1 |  tmp1 := self class compiledMethodAt: #readX.  self assert: tmp1 hasInstVarRef.  tmp1 := self class compiledMethodAt: #readXandY.  self assert: tmp1 hasInstVarRef.  tmp1 := self class compiledMethodAt: #writeX.  self assert: tmp1 hasInstVarRef.  tmp1 := self class compiledMethodAt: #writeXandY.  self assert: tmp1 hasInstVarRefjavascriptOn: arg1  self isNaN ifTrue: [ ^arg1 nextPutAll: 'NaN' ].  self isInfinite ifTrue: [ ^arg1 nextPutAll: (self positive ifTrue: [ 'Infinity' ] ifFalse: [ '-Infinity' ]) ].  super javascriptOn: arg1subclass: arg1 layout: arg2 slots: arg3 classVariables: arg4 poolDictionaries: arg5 category: arg6  self deprecated: 'use ... package: instead'.  ^self subclass: arg1 layout: arg2 slots: arg3 classVariables: arg4 poolDictionaries: arg5 package: arg6arcTan: arg1  ^self = 0.0 ifTrue: [ arg1 signBit = 0 ifTrue: [ 0 ] ifFalse: [ self signBit = 0 ifTrue: [ Pi ] ifFalse: [ Pi negated ] ] ] ifFalse: [ arg1 = 0.0 ifTrue: [ self > 0.0 ifTrue: [ Halfpi ] ifFalse: [ Halfpi negated ] ] ifFalse: [ arg1 > 0 ifTrue: [ (self / arg1) arcTan ] ifFalse: [ self > 0 ifTrue: [ (self / arg1) arcTan + Pi ] ifFalse: [ (self / arg1) arcTan - Pi ] ] ] ]fuelAccept: arg1  ^arg1 visitHookPrimitive: selfvalueWithPossibleArguments: arg1  | tmp1 |  arg1 size == self numArgs ifTrue: [ ^self valueWithArguments: arg1 ].  tmp1 := Array new: self numArgs.  tmp1 replaceFrom: 1 to: (arg1 size min: tmp1 size) with: arg1 startingAt: 1.  ^self valueWithArguments: tmp1testMillisecondsToGo  | tmp1 |  tmp1 := Delay forMilliseconds: 100.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: tmp1.  scheduler simulate_vmMilliseconds: 160.  self assert: tmp1 millisecondsToGo equals: 40gtInspectorPresentationsIn: arg1 inContext: arg2  | tmp1 |  tmp1 := Pragma allNamed: arg2 class extensionsPragma from: self class to: ProtoObject sortedUsing: [:arg3 :arg4 |  (arg3 argumentAt: 1) < (arg4 argumentAt: 1) ].  tmp1 := tmp1 select: [:arg5 |  arg2 shouldDisplayPresentationCreatedBy: arg5 method ].  self gtInspectorPresentationsFromPragmas: tmp1 In: arg1 inContext: arg2effectiveProcess  ^effectiveProcess ifNil: [ self ]definesClassVariableNamed: arg1  ^self classVarNames includes: arg1phlowValue: arg1 withEnoughArguments: arg2  ^self valueWithEnoughArguments: arg2allCallsOnIn: arg1  ^(arg1 allReferencesTo: (self environment associationAt: self instanceSide name)) , (arg1 allCallsOn: self instanceSide name)keysAndValuesDo: arg1  1 to: self basicSize do: [:arg2 |  | tmp1 |        (tmp1 := self basicAt: arg2) isVariableBinding ifTrue: [ arg1 value: tmp1 key value: tmp1 value ] ifFalse: [ arg1 value: tmp1 selector value: tmp1 ] ]initialize  super initialize.  exceptions := OrderedCollection newgenTrapIfNotInstanceOf: arg1  | tmp1 |  (arg1 < 0 or: [ arg1 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 65536 ].  (tmp1 := arg1) > 255 ifTrue: [ self genUnsignedSingleExtendA: tmp1 // 256.        tmp1 := tmp1 \\ 256 ].  stream     nextPut: 236;     nextPut: tmp1testcurrentYear  | tmp1 |  tmp1 := Year currentYear.  self assert: Date today asYear equals: tmp1classComment: arg1  ^self classComment: arg1 stamp: '<historical>'wantsChangeSetLogging  ^truetestBasicCheck2  | tmp1 |  tmp1 := testClass >> (testClass compile: 'testMethod').  self deny: (FloatReferencesRule new basicCheck: tmp1 ast)changeFromString: arg1  | tmp1 |  tmp1 := arg1 parseLiterals.  (tmp1 isEmpty and: [ elementArray isEmpty ]) ifTrue: [ ^self setDefaultList: Array new ].  ^self changeFromCategorySpecs: tmp1year  ^self dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg3 ]subclass: arg1  ^self subclass: arg1 instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: 'Unclassified'to: arg1  | tmp1 |  tmp1 := (arg1 isKindOf: Timespan) ifTrue: [ arg1 end ] ifFalse: [ arg1 asDateAndTime ].  ^Timespan starting: self start ending: tmp1setUp  | tmp1 |  super setUp.  tmp1 := (Object compiledMethodAt: #at:) penultimateLiteral at: #primitive:.  amState := AdditionalMethodState selector: #at: with: tmp1 copyprintWithCommasOn: arg1  ^self printSeparatedBy: $, every: 3 signed: false on: arg1mixedMethod  LocalRecursionStopper during: [ self assert: value equals: 0.        value := value + 1.        LocalRecursionStopper during: [ value := value + 1 ].        self assert: value equals: 1.        self mixedMethod.        self assert: value equals: 1 ].  LocalRecursionStopper during: [ self assert: value equals: 1.        ^2 ].  self assert: value equals: 1.  ^valuesend: arg1 super: arg2 numArgs: arg3  | tmp1 tmp2 |  tmp2 := Array new: arg3.  arg3 to: 1 by: -1 do: [:arg4 |  tmp2 at: arg4 put: self pop ].  tmp1 := self pop.  QuickStep == self ifTrue: [ QuickStep := nil.        ^self quickSend: arg1 to: tmp1 with: tmp2 super: arg2 ].  ^self send: arg1 to: tmp1 with: tmp2 super: arg2characterSet  ^self class characterSetproperties  ^nil -> niltestAsSeconds  self assert: aTime asSeconds equals: 45296testExecutionEnvironment  | tmp1 |  tmp1 := ExecutionEnvironmentStub new.  tmp1 beActiveDuring: [ self assert: CurrentExecutionEnvironment value equals: tmp1.        DefaultExecutionEnvironment beActiveDuring: [ self assert: CurrentExecutionEnvironment value equals: DefaultExecutionEnvironment instance ].        self assert: CurrentExecutionEnvironment value equals: tmp1 ]amountToTranslateWithin: arg1  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := 0.  self right > arg1 right ifTrue: [ tmp1 := arg1 right - self right ].  self bottom > arg1 bottom ifTrue: [ tmp2 := arg1 bottom - self bottom ].  self left + tmp1 < arg1 left ifTrue: [ tmp1 := arg1 left - self left ].  self top + tmp2 < arg1 top ifTrue: [ tmp2 := arg1 top - self top ].  ^tmp1 @ tmp2testRefersToLiteralsReturnsTrueWhenLiteralIsContainedInArrayOfLitterals  self assert: (self compiledMethod1 hasLiteralThorough: #add)level  < metaLinkOptions: #(+ optionDisabledLink)>  ^level ifNil: [ level := 0 ]testIsCurrencySymbol  self checkCorrespondanceOf: #isCurrencySymbol: and: #SctryEnterCritical: arg1 ifLocked: arg2  | tmp1 |  tmp1 := Processor activeProcess.  tmp1 == owner ifTrue: [ ^arg1 value ].  ^semaphore critical: [ owner := tmp1.        arg1 ensure: [ owner := nil ] ] ifLocked: arg2categoryOfElement: arg1  ^self categoryOfElement: arg1 ifAbsent: [ nil ]instVarIndexFor: arg1  ^self instVarIndexFor: arg1 ifAbsent: 0innerCompiledBlocksAnySatisfy: arg1  self innerCompiledBlocksDo: [:arg2 |  (arg1 value: arg2) ifTrue: [ ^true ] ].  ^falsetestPrintOn  self assert: (String streamContents: [:arg1 |  aDateAndTime printOn: arg1 ]) equals: '2004-02-29T13:33:00+02:00'.  self assert: (String streamContents: [:arg1 |  aTimeZone printOn: arg1 ]) equals: 'a TimeZone(UTC)'printDirectlyToDisplay  self asString displayAt: 0 @ 100method  ^methodisInfinite  ^self = Infinity or: [ self = NegativeInfinity ]nthRoot: arg1  | tmp1 |  tmp1 := (numerator nthRootTruncated: arg1) / (denominator nthRootTruncated: arg1).  (tmp1 raisedTo: arg1) = self ifTrue: [ ^tmp1 ].  ^(self abs ln / arg1) exp * self signfileOutMethod: arg1 on: arg2  arg1 == #Comment ifTrue: [ ^self inform: 'Sorry, cannot file out class comment in isolation.' ].  (self includesSelector: arg1) ifFalse: [ ^self error: 'Selector ' , arg1 asString , ' not found' ].  arg2     header;     timeStamp.  self printMethodChunk: arg1 on: arg2listAtCategoryNumber: arg1  ^(protocolOrganizer allProtocols at: arg1 ifAbsent: [ ^{} ]) methods asArraymethods: arg1  self deprecated: 'Use #methodSelectors: instead.' transformWith: '`@receiver methods: `@arg' -> '`@receiver methodSelectors: `@arg'.  ^self methodSelectors: arg1testMonotonicity  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := DateAndTime now.  tmp2 := DateAndTime now.  tmp3 := DateAndTime now.  tmp4 := DateAndTime now.  self     assert: tmp1 <= tmp2;     assert: tmp2 <= tmp3;     assert: tmp3 <= tmp4testPrintOn  self assert: (String streamContents: [:arg1 |  aTime printOn: arg1 ]) equals: '12:34:56 pm'comment  ^self instanceSide organization classComment ifEmpty: [ self classCommentBlank ]isJavascript  ^falsesignalAllInQueue: arg1  queuesMutex critical: [ arg1 removeAllSuchThat: [:arg2 |  arg2 signal.              true ] ]hasMethodReturn  ^closureOrNil hasMethodReturnwithRight: arg1  ^origin x @ origin y corner: (arg1 max: origin x) @ corner ytestDatesDo  | tmp1 |  tmp1 := OrderedCollection new.  7 to: 97 do: [:arg1 |  tmp1 addLast: (Date year: 2003 day: arg1) ].  tmp1 := tmp1 asArray.  self assert: aTimespan dates equals: tmp1isAnonymous  ^truecull: arg1 cull: arg2  ^numArgs < 2 ifTrue: [ self cull: arg1 ] ifFalse: [ self value: arg1 value: arg2 ]testAsDuration  self assert: aDateAndTime asDuration equals: 0 asDurationimmediateSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 package: arg6  ^self subclass: arg1 uses: arg2 layout: ImmediateLayout slots: arg3 asSlotCollection classVariablesNames: arg4 poolDictionaries: arg5 category: arg6asMonth  ^self asDateAndTime asMonthtestIsLetterModifier  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isLetterModifier: tmp2) equals: (tmp1 isLetterModifier: tmp2) ]resume: arg1  self isResumable ifFalse: [ IllegalResumeAttempt signal ].  self resumeUnchecked: arg1stonOn: arg1  arg1 writeObject: self listSingleton: self instanceSide name asSymbolpackage  ^RPackage organizer packageOf: selftempsAndValues  ^String streamContents: [:arg1 |  self tempNames do: [:arg2 |  arg1                 nextPutAll: arg2;                 nextPut: $:;                 space;                 tab.              self print: (self tempNamed: arg2) on: arg1 ] separatedBy: [ arg1 cr ] ]fullDisplayString  ^String streamContents: [:arg1 |  self displayStringOn: arg1 ]peekInstruction  | tmp1 tmp2 |  tmp1 := self pc.  tmp2 := self nextInstruction.  self pc: tmp1.  ^tmp2exp  < primitive: 559>  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self < 0.0 ifTrue: [ ^self negated exp reciprocal ].  self = 0.0 ifTrue: [ ^1 ].  self abs > MaxValLn ifTrue: [ self error: 'exp overflow' ].  tmp1 := E raisedToInteger: self truncated.  tmp2 := self fractionPart.  tmp2 = 0.0 ifTrue: [ ^tmp1 ].  tmp3 := 1.0 + tmp2.  tmp4 := tmp2 * tmp2 / 2.0.  tmp5 := 2.0.  [ tmp4 > Epsilon ] whileTrue: [ tmp3 := tmp3 + tmp4.        tmp5 := tmp5 + 1.0.        tmp4 := tmp4 * tmp2 / tmp5 ].  tmp3 := tmp3 + tmp4.  ^tmp1 * tmp3testDayOfYear  self assert: aDateAndTime dayOfYear equals: 1testSecond  self assert: aDateAndTime second equals: 0compilerClass  ^self methodClass ifNil: [ Smalltalk compilerClass ] ifNotNil: [:arg1 |  arg1 compilerClass ]whileFalse: arg1  self value ifFalse: [ arg1 value.        self whileFalse: arg1 ].  ^nilensureArguments  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg1 :arg2 |  arg1 ifNil: [ arg2 ifFalse: [ ^false ] ] ] ].  ^truecorner: arg1  ^Rectangle origin: self corner: arg1signalFromHandlerActionTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [ self doYetAnotherThing.        MyTestError signal ]removeAllMethodSelectors  ^methodSelectors removeAllabbreviation  ^self subclassResponsibilitycloseTo: arg1  ^[ self = arg1 ] ifError: [ false ]printStringRadix: arg1  | tmp1 |  arg1 = 10 ifTrue: [ tmp1 := self storeStringBase: arg1.        self negative ifTrue: [ ^'-10r' , (tmp1 copyFrom: 2 to: tmp1 size) ] ifFalse: [ ^'10r' , tmp1 ] ].  ^self storeStringBase: arg1testErrorCodeNotFound  | tmp1 tmp2 tmp3 |  self skip.  Smalltalk vm isRunningCog ifFalse: [ ^self ].  tmp2 := self veryBasicAt: 1.  tmp1 := Context sender: nil receiver: nil method: Object >> #at: arguments: #(10).  tmp3 := tmp1     push: nil;     push: 500;     doPrimitive: 117 method: self class >> #veryBasicAt: receiver: self args: #(999).  self assert: tmp3 isArray.  self assert: Context primitiveFailToken first identicalTo: tmp3 first.  self assert: tmp2 equals: tmp3 secondtestReadFromDateOnly  self assert: '2014-02-19' asDateAndTime translateToUTC printString equals: '2014-02-19T00:00:00+00:00'.  self assert: '2014-02-19Z' asDateAndTime printString equals: '2014-02-19T00:00:00+00:00'.  self assert: '2014-02-19T+07:00' asDateAndTime printString equals: '2014-02-19T00:00:00+07:00'.  self assert: '2014-02-19 -05:00' asDateAndTime printString equals: '2014-02-19T00:00:00-05:00'classThatDefinesInstVarNamed: arg1  ^self slotNamed: arg1 ifFound: [:arg2 |  arg2 definingClass ] ifNone: nilmetacelloSemanticStringLessThanSelf: arg1  ^self error: 'Invalid Metacello verson component - should be String or Integer.'highestPriority  ^quiescentProcessLists sizewindowIsClosing  gtInspectorASTIn: arg1  < gtInspectorPresentationOrder: 35>  (GTSimpleRBTreeBrowser new treeIn: arg1)     title: 'AST';     display: [:arg2 |  {arg2 ast} ]isPoint  ^falseasLargerPowerOfTwo  | tmp1 |  (numerator = 0 or: [ numerator sign ~= denominator sign ]) ifTrue: [ ^DomainError signal: 'Value outside (0 , infinity)' from: 0 ].  ^(tmp1 := denominator // numerator) > 0 ifTrue: [ Fraction numerator: 1 denominator: (1 bitShift: tmp1 highBit - 1) ] ifFalse: [ tmp1 := numerator // denominator.        (tmp1 isPowerOfTwo and: [ numerator \\ denominator = 0 ]) ifTrue: [ tmp1 ] ifFalse: [ 1 bitShift: tmp1 highBit ] ]methodStreamPosition  ^stream positionisEphemeronClass  ^self instSpec = 5compressTo: arg1  ^Rectangle origin: (origin roundUpTo: arg1) corner: (corner roundDownTo: arg1)swapReceiver: arg1  receiver := arg1testNameOfMonth  | tmp1 |  tmp1 := #(#January #February #March #April #May #June #July #August #September #October #November #December).  tmp1 withIndexDo: [:arg1 :arg2 |  self assert: (Month nameOfMonth: arg2) equals: arg1 ].  self should: [ Month nameOfMonth: 0 ] raise: self defaultTestError.  self should: [ Month nameOfMonth: 13 ] raise: self defaultTestError.  self should: [ Month nameOfMonth: #January ] raise: self defaultTestErrortestMultiProcessWaitOnSameDelay  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Delay forSeconds: 1.  tmp4 := false.  tmp2 := [ tmp1 wait ] forkAt: Processor activePriority + 1.  tmp3 := [ self should: [ tmp1 wait ] raise: Error.  tmp4 := true ] forkAt: Processor activePriority + 1.  tmp2 terminate.  tmp3 terminate.  self assert: tmp4sign  ^-1asEmailString  | tmp1 |  tmp1 := self asTime print24 first: 8.  ^'{1}, {2} {3} {4} {5} {6}' format: {self dayOfWeekAbbreviation .         self dayOfMonth asString .         self monthAbbreviation .         self year asString .         tmp1 .         self offset asEmailTimeOffsetString}isProvided: arg1  arg1 ifNil: [ ^true ].  ^(self isRequired: arg1) not and: [ (self isDisabled: arg1) not ]year  ^start yearselect: arg1 thenCollect: arg2  | tmp1 |  tmp1 := self class new.  self do: [:arg3 |  (arg1 value: arg3) ifTrue: [ tmp1 add: (arg2 value: arg3) ] ].  ^tmp1default  ^0testValueWithPossibleArgument  | tmp1 tmp2 tmp3 |  tmp1 := [ 1 ].  tmp2 := [:arg1 |  arg1 ].  tmp3 := [:arg2 :arg3 |  {arg2 .   arg3} ].  self assert: (tmp1 valueWithPossibleArgument: 1) equals: 1.  self assert: (tmp2 valueWithPossibleArgument: 1) equals: 1.  self assert: (tmp3 valueWithPossibleArgument: 1) equals: {1 .         nil}metacelloStringLessThanSelf: arg1  ^self error: 'Invalid Metacello verson component - should be String or Integer.'testMonth  self assert: aDateAndTime month equals: 1.  self assert: aDateAndTime monthAbbreviation equals: 'Jan'.  self assert: aDateAndTime monthName equals: 'January'.  self assert: aDateAndTime monthIndex equals: 1testRefersToLiteralsReturnsTrueWhenLiteralIsByteString  self assert: (self compiledMethod1 hasLiteralThorough: 'Pharo loves tests')suspend  suspendSemaphore := Semaphore new.  timingSemaphore signaltestSelector  Author useAuthor: 'TUTU_TEST' during: [ | tmp1 tmp2 |        tmp1 := self class >> #returnTrue.        self assert: tmp1 selector equals: #returnTrue.        Smalltalk removeClassNamed: #TUTU.        tmp2 := Object subclass: #TUTU instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self categoryNameForTemporaryClasses.        tmp2 compile: 'foo ^ 10'.        tmp1 := tmp2 >> #foo.        Smalltalk removeClassNamed: #TUTU.        self assert: tmp1 selector equals: #foo ]protocolsNames  ^protocols collect: #name as: ArraypvtSignal: arg1 list: arg2  < debuggerCompleteToSender>  | tmp1 |  self isActiveProcess ifFalse: [ ^self ].  arg1 signal.  tmp1 := Semaphore new.  [ self suspend.  suspendedContext := suspendedContext swapSender: nil.  arg2 class == Semaphore ifTrue: [ arg2 isSignaled ifTrue: [ arg2 wait.              self resume ] ifFalse: [ myList := arg2.              arg2 add: self ] ] ifFalse: [ self resume ] ] fork.  tmp1 waithash  ^self identityHashinstanceVariableNamesDo: arg1  | tmp1 |  (tmp1 := self superclass notNil ifTrue: [ self superclass instSize ] ifFalse: [ 0 ]) > 0 ifTrue: [ self superclass instanceVariableNamesDo: arg1 ].  1 to: self instSize - tmp1 do: [:arg2 |  arg1 value: (self instVarNames at: arg2) ]setUp  super setUp.  unicodeGenerator := UnicodeTestRNG currenttestPrintFormat  | tmp1 tmp2 |  tmp1 := #(1 2 3 $/ 1 1).  self assert: (january23rd2004 printFormat: tmp1) equals: '23/1/2004'.  tmp1 at: 4 put: $-.  tmp2 := january23rd2004 printFormat: tmp1.  self assert: tmp2 equals: '23-1-2004'.  tmp1 at: 5 put: 1.  self assert: ((tmp2 splitOn: $-) at: 2) equals: '1'.  tmp1 at: 5 put: 2.  tmp2 := january23rd2004 printFormat: tmp1.  self assert: ((tmp2 splitOn: $-) at: 2) equals: 'Jan'.  tmp1 at: 5 put: 3.  tmp2 := january23rd2004 printFormat: tmp1.  self assert: ((tmp2 splitOn: $-) at: 2) equals: 'January'.  tmp1 at: 5 put: 4.  tmp2 := january23rd2004 printFormat: tmp1.  self assert: ((tmp2 splitOn: $-) at: 2) equals: ''.  tmp1 at: 6 put: 1.  tmp2 := january23rd2004 printFormat: tmp1.  self assert: ((tmp2 splitOn: $-) at: 3) equals: '2004'.  tmp1 at: 6 put: 2.  tmp2 := january23rd2004 printFormat: tmp1.  self assert: ((tmp2 splitOn: $-) at: 3) equals: '04'.  tmp1 at: 6 put: 2.  tmp2 := january23rd2004 printFormat: tmp1.  self assert: ((tmp2 splitOn: $-) at: 3) equals: '04'.  tmp1 at: 6 put: 3.  tmp2 := january23rd2004 printFormat: tmp1.  self assert: ((tmp2 splitOn: $-) at: 3) equals: '04'.  self     assert: june2nd1973 mmddyyyy equals: '6/2/1973';     assert: june2nd1973 yyyymmdd equals: '1973-06-02';     assert: (june2nd1973 printFormat: #(3 1 2 $! 2 1 1)) equals: '1973!2!Jun';     assert: (june2nd1973 printFormat: #(1 2 3 0 1 1 2)) equals: '02061973';     assert: (june2nd1973 printFormat: #(2 1 3 0 1 1 2)) equals: '06021973';     assert: (june2nd1973 printFormat: #(3 2 1 0 1 1 2)) equals: '19730602';     assert: (june2nd1973 printFormat: #(1 2 3 0 1 1 1)) equals: '261973'setUp  super setUp.  aStopwatch := Stopwatch new.  aDelay := Delay forMilliseconds: 1testAsDuration  self assert: aTime asDuration equals: (Duration days: 0 hours: 12 minutes: 34 seconds: 56)keyword  self deprecated: 'Use #selector instead.' transformWith: '`@receiver keyword' -> '`@receiver selector'.  ^self selectortestLessThan  self assert: aDuration < (aDuration + 1 day).  self deny: aDuration < aDurationtearDown  class removeFromSystem.  super tearDownremoveLink: arg1  ^self removeLink: arg1 ifAbsent: [ self error: 'no such method!' ]testErrorWhenDayIsAfterMonthEnd  self should: [ DateAndTime year: 2004 month: 2 day: 30 ] raise: Error.  DateAndTime year: 2004 month: 2 day: 29testUnion  | tmp1 |  tmp1 := timespan union: timespan.  self     assert: tmp1 start equals: timespan start;     assert: tmp1 duration equals: timespan durationtestPrintHumanReadableOn  self testHumanReadablePrintString- arg1  < primitive: 542>  ^arg1 adaptToFloat: self andSend: #-shift  ^KMModifier shift + selftestBecomeForwardCopyIdentityHash  | tmp1 tmp2 tmp3 |  tmp1 := 'ab' copy.  tmp2 := 'cd' copy.  tmp3 := tmp1 identityHash.  tmp1 becomeForward: tmp2 copyHash: true.  self     assert: tmp1 identicalTo: tmp2;     assert: tmp1 identityHash equals: tmp3;     assert: tmp2 identityHash equals: tmp3testDayOfWeek  self assert: aTimespan dayOfWeek equals: 7.  self assert: aTimespan dayOfWeekName equals: 'Saturday'isFixed  ^self isVariable notenvironment  ^Smalltalk globalstestSecond  self assert: aDateAndTime second equals: 0testStoreOn  self assert: (String streamContents: [:arg1 |  january23rd2004 storeOn: arg1 ]) equals: '''23 January 2004'' asDate'testRefersToLiteralsReturnsFalseWhenLiteralNotIsInMethodPropertiesKey  [ self compiledMethod1 propertyAt: #Once put: true.  self deny: (self compiledMethod1 hasLiteralThorough: #Absent) ] ensure: [ self compiledMethod1 removeProperty: #Once ]lowestPriority  ^SystemRockBottomPriorityinterpretNextV3PlusClosureInstructionFor: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := self method.  tmp1 := tmp4 at: pc.  tmp2 := tmp1 // 16.  tmp3 := tmp1 \\ 16.  pc := pc + 1.  tmp2 < 8 ifTrue: [ tmp2 < 4 ifTrue: [ tmp2 < 2 ifTrue: [ tmp2 < 1 ifTrue: [ ^arg1 pushReceiverVariable: tmp3 ] ifFalse: [ ^arg1 pushTemporaryVariable: tmp3 ] ] ifFalse: [ tmp2 < 3 ifTrue: [ ^arg1 pushConstant: (tmp4 literalAt: tmp3 + 1) ] ifFalse: [ ^arg1 pushConstant: (tmp4 literalAt: tmp3 + 17) ] ] ] ifFalse: [ tmp2 < 6 ifTrue: [ tmp2 < 5 ifTrue: [ ^arg1 pushLiteralVariable: (tmp4 literalAt: tmp3 + 1) ] ifFalse: [ ^arg1 pushLiteralVariable: (tmp4 literalAt: tmp3 + 17) ] ] ifFalse: [ tmp2 < 7 ifTrue: [ tmp3 < 8 ifTrue: [ ^arg1 popIntoReceiverVariable: tmp3 ] ifFalse: [ ^arg1 popIntoTemporaryVariable: tmp3 - 8 ] ] ifFalse: [ tmp3 = 0 ifTrue: [ ^arg1 pushReceiver ].                          tmp3 < 8 ifTrue: [ ^arg1 pushConstant: (SpecialConstants at: tmp3) ].                          tmp3 = 8 ifTrue: [ ^arg1 methodReturnReceiver ].                          tmp3 < 12 ifTrue: [ ^arg1 methodReturnConstant: (SpecialConstants at: tmp3 - 8) ].                          tmp3 = 12 ifTrue: [ ^arg1 methodReturnTop ].                          tmp3 = 13 ifTrue: [ ^arg1 blockReturnTop ].                          tmp3 > 13 ifTrue: [ ^self unusedBytecode: arg1 at: pc - 1 ] ] ] ] ] ifFalse: [ tmp2 < 12 ifTrue: [ tmp2 < 10 ifTrue: [ tmp2 < 9 ifTrue: [ ^self interpretV3PlusClosureExtension: tmp3 in: tmp4 for: arg1 ] ifFalse: [ tmp3 < 8 ifTrue: [ ^arg1 jump: tmp3 + 1 ].                          ^arg1 jump: tmp3 - 8 + 1 if: false ] ] ifFalse: [ tmp2 < 11 ifTrue: [ tmp1 := tmp4 at: pc.                          pc := pc + 1.                          tmp3 < 8 ifTrue: [ ^arg1 jump: (tmp3 - 4) * 256 + tmp1 ].                          ^arg1 jump: (tmp3 bitAnd: 3) * 256 + tmp1 if: tmp3 < 12 ] ifFalse: [ ^arg1 send: (Smalltalk specialSelectorAt: tmp3 + 1) super: false numArgs: (Smalltalk specialNargsAt: tmp3 + 1) ] ] ] ifFalse: [ tmp2 = 12 ifTrue: [ ^arg1 send: (Smalltalk specialSelectorAt: tmp3 + 17) super: false numArgs: (Smalltalk specialNargsAt: tmp3 + 17) ] ifFalse: [ ^arg1 send: (tmp4 literalAt: tmp3 + 1) super: false numArgs: tmp2 - 13 ] ] ]basicObsoleteSubclasses  ^ObsoleteSubclassestestDoubleResume  self assertSuccess: (ExceptionTester new runTest: #doubleResumeTest)testTranscriptPrinting  self runSimulated: [ self methodWithTranscript ]sizeStoreInstVarLong: arg1  ^self sizeOpcodeSelector: #genStoreInstVarLong: withArguments: {arg1}endPC  ^closureOrNil ifNil: [ self method endPC ] ifNotNil: [ closureOrNil endPC ]byteAt: arg1 put: arg2  < primitive: 61>  ^super at: arg1 put: arg2testValueWithinTimingNestedInner  | tmp1 |  tmp1 := [ [ [ 5 seconds asDelay wait ] valueWithin: 100 milliSeconds onTimeout: [  ] ] valueWithin: 500 milliSeconds onTimeout: [  ] ] durationToRun.  self assert: tmp1 < 500 milliSeconds- arg1  ^self + arg1 negatedroundUpTo: arg1  | tmp1 |  tmp1 := arg1 asPoint.  ^(x roundUpTo: tmp1 x) @ (y roundUpTo: tmp1 y)hasSharedPools  ^self sharedPools notEmptyasContextWithSender: arg1  ^(Context newForMethod: outerContext method)     setSender: arg1 receiver: outerContext receiver method: outerContext method closure: self startpc: startpc;     privRefreshinstVarAt: arg1 put: arg2  arg1 = 3 ifTrue: [ self stackp: arg2.        ^arg2 ].  ^super instVarAt: arg1 put: arg2withTop: arg1  ^origin x @ (arg1 min: corner y) corner: corner x @ corner ystonContainSubObjects  ^falsebecome: arg1  {self} elementsExchangeIdentityWith: {arg1}testIsInitialQuote  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isInitialQuote: tmp2) equals: (tmp1 isInitialQuote: tmp2) ]argumentCount  ^selector numArgs - self arguments sizetestMetaclassSuperclass  self assert: Dictionary class superclass identicalTo: Dictionary superclass class.  self assert: OrderedCollection class superclass identicalTo: OrderedCollection superclass classgtIterator  self assert: (self numArgs between: 1 and: 2).  ^GTSpotterBlockIterator new     onDo: self;     yourselfbordersOn: arg1 along: arg2  ((arg2 = #right and: [ self left = arg1 right ]) or: [ arg2 = #left and: [ self right = arg1 left ] ]) ifTrue: [ ^(self top max: arg1 top) < (self bottom min: arg1 bottom) ].  ((arg2 = #bottom and: [ self top = arg1 bottom ]) or: [ arg2 = #top and: [ self bottom = arg1 top ] ]) ifTrue: [ ^(self left max: arg1 left) < (self right min: arg1 right) ].  ^falsesignalIn: arg1  signalContext := arg1.  signaler ifNil: [ signaler := self receiver ].  ^signalContext nextHandlerContext handleSignal: selfasMargin  ^Margin fromRectangle: selfsharing: arg1  | tmp1 |  tmp1 := self sharedPools.  self sharedPools: OrderedCollection new.  (arg1 substrings: ' ') do: [:arg2 |  self sharedPools add: (self environment at: arg2 asSymbol ifAbsent: [ (self confirm: 'The pool dictionary ' , arg2 , ' does not exist.' , '\Do you want it automatically created?' withCRs) ifTrue: [ self classInstaller make: [:arg3 |  arg3                                   superclass: SharedPool;                                   name: arg2;                                   category: self category ] ] ifFalse: [ ^self error: arg2 , ' does not exist' ] ]) ].  self sharedPools isEmpty ifTrue: [ self sharedPools: nil ].  tmp1 do: [:arg4 |  | tmp2 |        tmp2 := self sharedPools anySatisfy: [:arg5 |  arg5 == arg4 ].        tmp2 ifFalse: [ ^true ] ].  ^falsetestClassSide  self assert: Point classSide equals: Point class.  self assert: Point class classSide equals: Point classname  ^(self isEmpty and: [ protocolOrganizer protocols isEmpty ]) ifTrue: [ self class nullCategory ] ifFalse: [ name ]isOtherLetter  ^self characterSet isOtherLetter: selfsetFormat: arg1  format := arg1testOnForkErrorExecutesBlock  | tmp1 tmp2 |  tmp2 := Semaphore new.  tmp1 := nil.  [ 1 / 0 ] on: Exception fork: [ tmp1 := 2.        tmp2 signal ].  tmp2 wait.  self assert: tmp1 equals: 2allSuperclassesDo: arg1  continuationExample2: arg1  | tmp1 tmp2 tmp3 |  tmp1 := [:arg2 |  | tmp4 tmp5 |  tmp4 := 1.  tmp5 := [ | tmp6 |  tmp6 := arg2 at: tmp4.  tmp4 := tmp4 + 1.  Array with: tmp6 with: (tmp4 <= arg2 size ifTrue: [ tmp5 ] ifFalse: [ nil ]) ] ].  tmp2 := [:arg3 :arg4 |  | tmp5 |  tmp5 := [ | tmp6 |  tmp6 := arg3 value.  Array with: (arg4 value: tmp6 first) with: (tmp6 last notNil ifTrue: [ tmp5 ]) ].  tmp5 ].  tmp3 := [:arg3 |  | tmp7 |  tmp7 := OrderedCollection new.  [ | tmp8 |  tmp8 := arg3 value.  tmp7 add: tmp8 first.  tmp8 last notNil ] whileTrue: [  ].  tmp7 ].  ^tmp3 value: (tmp2 value: (tmp1 value: arg1) value: [:arg5 |  arg5 * arg5 ])tearDown  testingEnvironment removeKey: self globalName ifAbsent: [  ].  globalName := nil.  testClass := nil.  super tearDowntestAsYear  self assert: aDateAndTime asYear equals: (Year starting: '01-01-1980' asDate)spaceUsed  ^super spaceUsed + (self hasClassSide ifTrue: [ self classSide spaceUsed ] ifFalse: [ 0 ])when: arg1 send: arg2 to: arg3 withArguments: arg4  self when: arg1 evaluate: (WeakMessageSend receiver: arg3 selector: arg2 arguments: arg4)outOfRangeError: arg1 index: arg2 range: arg3 to: arg4  ^self error: thisContext sender method selector , ' ' , arg1 , ' index ' , arg2 printString , ' is out of range ' , arg3 printString , ' to ' , arg4 printStringrelease  explicitRequirement  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp3 := [ ^self error: 'Explicitly required method' ].  tmp5 := thisContext sender.  tmp1 := tmp5 method.  tmp1 isFromTrait ifFalse: tmp3.  tmp4 := tmp5 receiver.  tmp6 := tmp1 selector.  tmp2 := tmp5 arguments.  tmp4 class superclass withAllSuperclassesDo: [:arg1 |  arg1 compiledMethodAt: tmp6 ifPresent: [:arg2 |  (arg2 isProvided or: [ arg2 isFromTrait not ]) ifTrue: [ tmp5 return: (arg2 valueWithReceiver: tmp4 arguments: tmp2) ] ] ].  tmp3 valuetestBasicCheck3  | tmp1 |  testClass addClassVarNamed: #TestVar.  tmp1 := testClass >> (testClass compile: 'testMethod TestVar yourself').  self assert: (tmp1 externalProperties noneSatisfy: [:arg1 |  arg1 rule class = SendsDeprecatedMethodToGlobalRule ])testSchedulingSamePriorityFirstComeFirstServed  | tmp1 tmp2 tmp3 |  tmp1 := Semaphore new signal.  tmp2 := Semaphore new.  [ tmp1 wait.  tmp3 := 1.  tmp2 signal ] fork.  [ tmp1 wait.  tmp3 := 2.  tmp2 signal ] fork.  tmp2 wait.  self assert: tmp3 = 1 description: 'First scheduled process should run first'.  tmp1 signal.  tmp2 wait.  self assert: tmp3 = 2 description: 'Second scheduled process should run after'willStore  ^self method encoderClass isStoreAt: pc in: self methodtestReciprocal  self     assert: 1.0 reciprocal equals: 1.0;     assert: 2.0 reciprocal equals: 0.5;     assert: -1.0 reciprocal equals: -1.0;     assert: -2.0 reciprocal equals: -0.5.  self should: [ 0.0 reciprocal ] raise: ZeroDividepushArgs: arg1 from: arg2  closureOrNil ifNil: [ self error: 'context needs a closure!' ] ifNotNil: [ stackp ~= (closureOrNil numArgs + closureOrNil numCopiedValues) ifTrue: [ self error: 'stack pointer is incorrect!' ] ].  1 to: closureOrNil numArgs do: [:arg3 |  self at: arg3 put: (arg1 at: arg3) ].  sender := arg2veryDeepCopyWith: arg1  ^selftestFromSeconds  | tmp1 |  tmp1 := self timeClass fromSeconds: 14567.  self assert: tmp1 equals: timethirdByte  ^self method at: pc + 2value: arg1  self terminate: thisContext.  self restoreValues.  thisContext swapSender: values first.  ^arg1years  | tmp1 |  tmp1 := OrderedCollection new.  self yearsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1 asArraytestArgumentNamedIfNone  | tmp1 |  tmp1 := (self class >> #methodWithPragma) pragmas anyOne.  self assert: (tmp1 argumentNamed: #arg3 ifNone: [ false ]).  self deny: (tmp1 argumentNamed: #nonExisting ifNone: [ false ])asLayoutFrame  ^LayoutFrame new     leftFraction: self left;     rightFraction: self right;     topFraction: self top;     bottomFraction: self bottom;     yourselfrecompile: arg1 from: arg2  | tmp1 tmp2 |  tmp1 := arg2 compiledMethodAt: arg1.  tmp2 := self compiler     source: (arg2 sourceCodeAt: arg1);     class: self;     failBlock: [ ^self ];     compiledMethodTrailer: tmp1 trailer;     compile.  arg1 == tmp2 selector ifFalse: [ self error: 'selector changed!' ].  self addSelectorSilently: arg1 withMethod: tmp2interpretSistaV1ExtendedPush: arg1 for: arg2  arg1 = 0 ifTrue: [ ^arg2 pushActiveContext ].  arg1 = 1 ifTrue: [ ^arg2 pushActiveProcess ].  self error: 'undefined extended push'asRingDefinition  | tmp1 |  tmp1 := (RGClassDefinition named: self name)     category: self category;     superclassName: (self superclass ifNil: [ nil printString ] ifNotNil: [ self superclass name ]);     traitCompositionSource: self traitCompositionString;     addInstanceVariables: self instVarNames;     addClassVariables: self classVarNames;     addSharedPools: self sharedPoolNames;     comment: self organization classComment;     stamp: self organization commentStamp;     definitionSource: self oldDefinition;     package: self package asRingDefinition;     withMetaclass.  tmp1 classSide     traitCompositionSource: self classSide traitCompositionString;     definitionSource: self classSide oldDefinition;     addInstanceVariables: self classSide instVarNames.  ^tmp1complexRecursion  LocalRecursionStopper during: [ self complexRecursionFirstCall ]isDecimalDigit  ^self characterSet isDecimalDigit: selfhaltIf: arg1  < debuggerCompleteToSender>  Halt if: arg1testInexactNthRoot  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := 3.0s1.  tmp2 := tmp4 raisedTo: 1 / 3.  self assert: tmp2 isFloat.  self deny: tmp2 squared equals: 3.  tmp1 := 0.10s2.  tmp3 := tmp1 raisedTo: 1 / 5.  self assert: tmp3 isFloat.  self deny: tmp3 squared equals: tmp1banChecksForValidation  ^{self}method1  < pragma1: 123 foo: 'bar'>  | tmp1 |  tmp1 := Array new.  tmp1 at: 1 put: 'Pharo loves tests'.  #(#add #at: #remove) do: #printOn:testArgumentAt  | tmp1 |  tmp1 := (self class >> #methodWithPragma) pragmas anyOne.  self assert: (tmp1 argumentAt: 1) equals: #toto.  self assert: (tmp1 argumentAt: 2) equals: 2.  self assert: (tmp1 argumentAt: 3)newInstanceFrom: arg1 variable: arg2 size: arg3 map: arg4  | tmp1 |  arg2 ifTrue: [ tmp1 := self basicNew: arg1 basicSize ] ifFalse: [ tmp1 := self basicNew ].  1 to: arg3 do: [:arg5 |  (arg4 at: arg5) > 0 ifTrue: [ tmp1 instVarAt: arg5 put: (arg1 instVarAt: (arg4 at: arg5)) ] ].  arg2 ifTrue: [ 1 to: arg1 basicSize do: [:arg5 |  tmp1 basicAt: arg5 put: (arg1 basicAt: arg5) ] ].  ^tmp1gtInspectorBytecodeIn: arg1  < gtInspectorPresentationOrder: 30>  ^(GTBytecodeBrowser new treeIn: arg1) title: 'Bytecode'storeOn: arg1  arg1 nextPut: $(.  self class isVariable ifTrue: [ arg1           nextPutAll: '(' , self class name , ' basicNew: ';           store: self basicSize;           nextPutAll: ') ' ] ifFalse: [ arg1 nextPutAll: self class name , ' basicNew' ].  1 to: self class instSize do: [:arg2 |  arg1           nextPutAll: ' instVarAt: ';           store: arg2;           nextPutAll: ' put: ';           store: (self instVarAt: arg2);           nextPut: $; ].  1 to: self basicSize do: [:arg2 |  arg1           nextPutAll: ' basicAt: ';           store: arg2;           nextPutAll: ' put: ';           store: (self basicAt: arg2);           nextPut: $; ].  arg1 nextPutAll: ' yourself)'hasSharedPools  ^falsesideOf: arg1  | tmp1 |  tmp1 := (self crossProduct: arg1) sign.  ^{#right .   #center .   #left} at: tmp1 + 2lastIndexOfCategoryNumber: arg1  arg1 > categoryStops size ifTrue: [ ^nil ].  ^categoryStops at: arg1var1  ^var1snapshotCopy  ^self shallowCopyslotNamed: arg1  ^self classLayout resolveSlot: arg1 asSymbolname  ^'Access to a system class'instVarIndexFor: arg1 ifAbsent: arg2  ^self slotNamed: arg1 ifFound: [:arg3 |  arg3 isVirtual ifTrue: arg2 ifFalse: [ arg3 index ] ] ifNone: arg2resetPSValueAt: arg1  env ifNil: [ ^self ].  arg1 > env size ifTrue: [ ^self ].  env at: arg1 put: niltestPerformInSuperclassCanExecutelongMethodWithTemps  | tmp1 tmp2 tmp3 |  tmp1 := 33.  tmp2 := 666.  tmp3 := 42.  self assert: (self perform: #a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15: withArguments: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15) inSuperclass: self class) equals: 1isFraction  ^falseisLetter  ^self characterSet isLetter: selfcategoryNameForTemporaryClasses  ^'Dummy-Tests-Class'normalize  < primitive: 'primNormalizeNegative' module: 'LargeIntegers'>  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := tmp4 := self bytesCount.  [ tmp3 = 0 ifTrue: [ ^0 ].  (self byteAt: tmp3) = 0 ] whileTrue: [ tmp3 := tmp3 - 1 ].  tmp1 := SmallInteger minVal < -16r40000000 ifTrue: [ 8 ] ifFalse: [ 4 ].  tmp3 <= tmp1 ifTrue: [ tmp5 := SmallInteger minVal.        (tmp3 < tmp1 or: [ (self byteAt: tmp1) < tmp5 lastDigit ]) ifTrue: [ tmp2 := 0.              tmp3 to: 1 by: -1 do: [:arg1 |  tmp2 := tmp2 * 256 - (self byteAt: arg1) ].              ^tmp2 ].        1 to: tmp1 do: [:arg1 |  (self byteAt: arg1) = (tmp5 byteAt: arg1) ifFalse: [ tmp3 < tmp4 ifTrue: [ ^self growto: tmp3 ] ifFalse: [ ^self ] ] ].        ^tmp5 ].  tmp3 < tmp4 ifTrue: [ ^self growto: tmp3 ] ifFalse: [ ^self ]testOneArgumentWithGC  | tmp1 |  tmp1 := WeakMessageSend receiver: Array selector: #with: arguments: {Object new}.  Smalltalk garbageCollectMost.  self assert: tmp1 value isNiltestIsDigit  self checkCorrespondanceOf: #isDigit: and: #NdassignmentNodes  ^self methods flatCollect: [:arg1 |  arg1 assignmentNodes ]testStoreOnRoundTrip  | tmp1 |  tmp1 := String streamContents: [:arg1 |  nil storeOn: arg1 ].  self assert: (self class compiler evaluate: tmp1) isNilasLargerPowerOfTwo  ^self isPowerOfTwo ifTrue: [ self ] ifFalse: [ self > 0 ifTrue: [ 1 bitShift: self highBit ] ifFalse: [ DomainError signal: 'Value outside (0 , infinity)' from: 0 ] ]testCurrent  self deny: aDateAndTime equals: DateAndTime currentinitializeReadingFrom: arg1 pattern: arg2  inputStream := arg1.  pattern := arg2restoreFromSnapshot: arg1  self copyFrom: arg1sharedPoolOfVarNamed: arg1  ^self sharedPools detect: [:arg2 |  arg2 usesClassVarNamed: arg1 ] ifNone: [ self superclass ifNil: [ nil ] ifNotNil: [ self superclass sharedPoolOfVarNamed: arg1 ] ]testDelayWaitTimeoutCompleted  | tmp1 tmp2 tmp3 |  tmp1 := Semaphore new.  tmp2 := DelayWaitTimeout new setDelay: 100 forSemaphore: tmp1.  tmp1 signal.  tmp2 waitOnCompletion: [ tmp3 := #completed ] onTimeout: [ tmp3 := #timedOut ].  self assert: tmp3 equals: #completedisInitialQuote  ^self characterSet isInitialQuote: selfasUnicode  | tmp1 tmp2 tmp3 |  self leadingChar = 0 ifTrue: [ ^self asInteger ].  tmp2 := self characterSet.  tmp2 isCharset ifFalse: [ ^self charCode ].  tmp1 := tmp2 ucsTable.  tmp1 ifNil: [ ^65533 ].  tmp3 := tmp1 at: self charCode + 1.  tmp3 = -1 ifTrue: [ ^65533 ].  ^tmp3copy  ^self shallowCopy postCopylink: arg1 toSlot: arg2  self shouldNotImplementat: arg1 put: arg2  < primitive: 211>  arg1 isInteger ifTrue: [ self errorSubscriptBounds: arg1 ].  arg1 isNumber ifTrue: [ ^self at: arg1 asInteger put: arg2 ] ifFalse: [ self errorNonIntegerIndex ]logTestResult: arg1  | tmp1 |  tmp1 := self suiteLog size.  self suiteLog at: tmp1 put: (self suiteLog at: tmp1) , ' ' , arg1suspendFirstAt: arg1 ifNone: arg2  | tmp1 |  tmp1 := quiescentProcessLists at: arg1.  tmp1 isEmpty ifTrue: [ ^arg2 value ] ifFalse: [ ^tmp1 first suspend ]metacelloIntegerLessThanSelf: arg1  ^self error: 'Invalid Metacello verson component - should be String or Integer.'subclass: arg1 slots: arg2 classVariables: arg3 category: arg4  self deprecated: 'use ... package: instead'.  ^self subclass: arg1 slots: arg2 classVariables: arg3 package: arg4protocolsSorted  ^(self protocols collect: #name as: Array) sort copyWithFirst: allProtocol namesin  < primitive: 56>  | tmp1 tmp2 tmp3 tmp4 |  self < 0.0 ifTrue: [ ^0.0 - (0.0 - self) sin ].  self > Twopi ifTrue: [ ^(self \\ Twopi) sin ].  self > Pi ifTrue: [ ^0.0 - (self - Pi) sin ].  self > Halfpi ifTrue: [ ^(Pi - self) sin ].  tmp1 := tmp2 := self.  tmp3 := 0.0 - (self * self).  tmp4 := 2.0.  [ tmp2 > Epsilon ] whileTrue: [ tmp2 := tmp2 * tmp3 / (tmp4 * (tmp4 + 1.0)).        tmp4 := tmp4 + 2.0.        tmp1 := tmp1 + tmp2.        tmp2 := tmp2 * tmp3 / (tmp4 * (tmp4 + 1.0)).        tmp4 := tmp4 + 2.0.        tmp1 := tmp1 + tmp2 ].  ^tmp1asMilliSeconds  ^(seconds * NanosInSecond + nanos) // (10 raisedToInteger: 6)rounded  self fractionPart abs < 0.5 ifTrue: [ ^self truncated ] ifFalse: [ ^self truncated + self sign rounded ]usesClassVarNamed: arg1  ^self allClassVarNames includes: arg1includes: arg1  | tmp1 |  tmp1 := arg1 asDateAndTime.  self scheduleDo: [:arg2 |  arg2 = tmp1 ifTrue: [ ^true ] ].  ^falsemessageText  ^messageText ifNil: [ message ifNil: [ super messageText ] ifNotNil: [ message lookupClass == UndefinedObject ifTrue: [ 'receiver of "{1}" is nil' format: {message selector asString} ] ifFalse: [ message lookupClass printString , '>> #' , message selector asString ] ] ]removeClassSlot: arg1  ^self classInstaller update: self to: [:arg2 |  arg2           fillFor: self;           classSlots: (self class classLayout slots copyWithout: arg1) ]firstIndexOfCategoryNumber: arg1  arg1 < 1 ifTrue: [ ^nil ].  ^arg1 > 1 ifTrue: [ (categoryStops at: arg1 - 1) + 1 ] ifFalse: [ 1 ]mustBeBoolean  ^Boolean mustBeBooleanDeOptimize ifTrue: [ self mustBeBooleanDeOptimizeIn: thisContext sender ] ifFalse: [ self mustBeBooleanIn: thisContext sender ]category  ^self methodClass organization categoryOfElement: self selector= arg1  < primitive: 47>  arg1 isNumber ifFalse: [ ^false ].  ^arg1 adaptToFloat: self andCompare: #=runBasicTests  self basicTestSelectors do: [:arg1 |  self runTest: arg1 ]displayStringLimitedTo: arg1  ^self printStringLimitedTo: arg1 using: [:arg2 |  self displayStringOn: arg2 ]stepUntilSomethingOnStack  | tmp1 |  [ stackp = 0 ] whileTrue: [ self isDead ifTrue: [ ^self ].        tmp1 := self step.        tmp1 == self ifFalse: [ ^tmp1 ] ]isCharacter  ^falsesizeBranchPopTrue: arg1  ^self sizeOpcodeSelector: #genBranchPopTrue: withArguments: {arg1}testOrganization  | tmp1 |  tmp1 := ClassDescription organization.  self assert: (tmp1 isKindOf: ClassOrganization)className  ^self class name asStringtestNaN2  | tmp1 tmp2 |  tmp1 := Float nan copy.  tmp2 := Float nan copy.  self deny: tmp1 equals: tmp2.  self deny: tmp1 identicalTo: tmp2.  self deny: tmp1 equals: tmp1.  self assert: tmp1 identicalTo: tmp1.  self assert: tmp1 size equals: 2.  self assert: (tmp1 at: 2) equals: 0.  tmp1 at: 1 put: (tmp1 at: 1) + 999.  self assert: tmp1 isNaN.  self assert: tmp2 isNaN.  self deny: (tmp1 at: 1) equals: (tmp2 at: 1).  self deny: tmp1 equals: tmp2.  self deny: tmp1 identicalTo: tmp2.  self deny: tmp1 equals: tmp1.  self assert: tmp1 identicalTo: tmp1linkAt: arg1  ^self linkAt: arg1 ifAbsent: [ self errorSubscriptBounds: arg1 ]removeProperty: arg1  ^self removeProperty: arg1 ifAbsent: [ nil ]testPrintStringSecond  self assert: '-1199-01-05T20:33:14.321-05:00' asDateAndTime printString equals: '-1199-01-05T20:33:14.321-05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: '2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime printString equals: '2002-05-16T17:20:45-02:34'.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime printString equals: '2002-05-16T17:20:45+00:00'.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime printString equals: '1997-04-26T01:02:03+01:02:3'testStoreOn  | tmp1 |  tmp1 := -1.2.  self assert: (String streamContents: [:arg1 |  tmp1 storeOn: arg1 ]) equals: ' -1.2'.  tmp1 := 1.2.  self assert: (String streamContents: [:arg1 |  tmp1 storeOn: arg1 ]) equals: '1.2'asByteArrayOfSize: arg1  | tmp1 tmp2 |  arg1 < self bytesCount ifTrue: [ self error: 'number to large for byte array' ].  tmp1 := ByteArray new: arg1.  tmp2 := 1.  arg1 to: arg1 - self bytesCount + 1 by: -1 do: [:arg2 |  tmp1 at: arg2 put: (self byteAt: tmp2).        tmp2 := tmp2 + 1 ].  ^tmp1longStack  ^String streamContents: [:arg1 |  (self stackOfSize: 100) do: [:arg2 |  arg1                 print: arg2;                 cr ] ]simpleResumeTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselftrailer  ^CompiledMethodTrailer new method: selfpointersToExcept: arg1  | tmp1 tmp2 tmp3 |  Smalltalk garbageCollect.  tmp2 := OrderedCollection new.  SystemNavigation default allObjectsDo: [:arg2 |  (arg2 pointsTo: self) ifTrue: [ tmp2 add: arg2 ] ].  tmp3 := {thisContext .   thisContext sender .   thisContext sender sender .   arg1}.  tmp1 := thisContext.  ^(tmp2 removeAllSuchThat: [:arg3 |  arg3 == thisContext sender or: [ (tmp3 identityIncludes: arg3) or: [ arg1 identityIncludes: arg3 ] ] ]) asArrayvariableByteSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5  ^self variableByteSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5categoriesSorted  ^self protocolOrganizer protocolsSortedifNotNil: arg1  ^arg1 cull: selftestInCriticalWait  | tmp1 tmp2 |  tmp1 := Semaphore new.  tmp2 := [ tmp1 critical: [  ] ] fork.  Processor yield.  self assert: tmp2 suspendingList identicalTo: tmp1.  tmp2 terminate.  self assert: (tmp1 instVarNamed: #excessSignals) equals: 0aboveCenter  ^(self topLeft + self bottomRight) // (2 @ 3)shouldBePrintedAsLiteral  ^self isLiteraltestStringAsNumber  self assert: '123' asNumber equals: 123.  self assert: '-123' asNumber equals: -123.  self assert: '123.' asNumber equals: 123.  self assert: '-123.' asNumber equals: -123.  self assert: '123This is not to be read' asNumber equals: 123.  self assert: '123s could be confused with a ScaledDecimal' asNumber equals: 123.  self assert: '123e could be confused with a Float' asNumber equals: 123asWidget  ^selfprepareForNewProcess: arg1  self subclassResponsibilitysqrt  | tmp1 tmp2 |  tmp2 := numerator sqrt.  tmp1 := denominator sqrt.  (tmp2 isInfinite or: [ tmp1 isInfinite ]) ifTrue: [ ^self asFloat sqrt ].  ^tmp2 / tmp1scanFor: arg1  | tmp1 tmp2 tmp3 |  tmp3 := array size.  tmp2 := arg1 basicIdentityHash \\ tmp3 + 1.  tmp2 to: tmp3 do: [:arg2 |  ((tmp1 := self basicAt: arg2) isNil or: [ tmp1 == arg1 ]) ifTrue: [ ^arg2 ] ].  1 to: tmp2 - 1 do: [:arg2 |  ((tmp1 := self basicAt: arg2) isNil or: [ tmp1 == arg1 ]) ifTrue: [ ^arg2 ] ].  ^0isSelfEvaluating  ^trueisFinalQuote  ^self characterSet isFinalQuote: selfaddSeconds: arg1  ^self class seconds: self asSeconds + arg1spotterProcessorsFor: arg1  ^(((Pragma allNamed: #spotterOrder: from: self class to: Object) select: [:arg2 |  arg1 processorsFilter shouldEnableProcessorsCreateBy: arg2 method ]) sort: [:arg3 :arg4 |  (arg3 argumentAt: 1) < (arg4 argumentAt: 1) ]) do: [:arg2 |  | tmp1 |        tmp1 := arg1 processors size.        self spotterProcessorsFor: arg1 pragma: arg2.        arg1 configureProcessorsStartingAt: tmp1 + 1 with: (arg1 processorsFilter configurationBlockForProcessorsCreatedBy: arg2 method) ]testBasicCheck  | tmp1 |  tmp1 := testClass >> (testClass compile: 'testMethod BoxedFloat64').  self assert: (FloatReferencesRule new basicCheck: tmp1 ast)delaySemaphore  ^delaySemaphoreslots  ^#()testMethodsAccessingSlot  | tmp1 tmp2 |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  tmp1 := (Point methodsAccessingSlot: (Point slotNamed: #x)) size.  tmp2 := (Point whichSelectorsAccess: 'x') size.  self assert: tmp1 equals: tmp2classDefinitions  ^Array with: self asClassDefinitiontestNBitAndNNegatedEqualsN  | tmp1 |  1 to: 100 do: [:arg1 |  tmp1 := 1 bitShift: arg1.        self assert: (tmp1 bitAnd: tmp1 negated) equals: tmp1 ]dependencyChecker  ^(DependencyChecker ifNil: [ DADependencyChecker ]) newtraitCompositionString  ^'{}'testMutateByteArrayUsingFloatAtPut  < expectedFailure>  | tmp1 |  tmp1 := ByteArray new: 5.  tmp1 beReadOnlyObject.  self should: [ tmp1 floatAt: 1 put: 1.0 ] raise: ModificationForbidden.  [ tmp1 floatAt: 1 put: 1.0 ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first equals: 1.0handleFailingFailingBasicNew: arg1  < primitive: 71>  OutOfMemory signal.  ^self basicNew: arg1retryModification  fieldIndex notNil ifTrue: [ object perform: retrySelector with: fieldIndex with: newValue ] ifFalse: [ object perform: retrySelector with: newValue ].  self resumeUnchecked: newValuecontextStack  ^self stackOfSize: 100000testAsTime  self assert: aTimespan asTime equals: jan01 asTimevalue: arg1 value: arg2 value: arg3  < primitive: 207>  | tmp1 |  numArgs ~= 3 ifTrue: [ self numArgsError: 3 ].  false ifTrue: [ tmp1 := self asContextWithSender: thisContext sender.        tmp1 at: 1 put: arg1.        tmp1 at: 2 put: arg2.        tmp1 at: 3 put: arg3.        thisContext privSender: tmp1 ] ifFalse: [ self primitiveFailed ]target: arg1  target := arg1firstDayOfMonth  ^self asMonth start daysetUp  super setUp.  className := #TUTU.  testEnvironment := Smalltalk globals.  self deleteClass.  Object subclass: className instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self categoryNameForTemporaryClassesaddCategory: arg1 before: arg2  self addCategory: arg1pcInOuter  | tmp1 tmp2 tmp3 |  tmp1 := self outerCode.  tmp3 := InstructionStream on: tmp1.  tmp2 := tmp1 endPC.  [ tmp3 pc <= tmp2 ] whileTrue: [ (self encoderClass isCreateFullBlock: self code: tmp1 at: tmp3 pc) ifTrue: [ ^tmp3 pc ].        tmp3 pc: (tmp3 nextPc: (tmp1 at: tmp3 pc)) ].  self error: 'block not installed in outer code'addSharedPool: arg1  (self sharedPools includes: arg1) ifTrue: [ ^self error: 'This is already in my shared pool list' ].  self sharedPools == nil ifTrue: [ self sharedPools: (OrderedCollection with: arg1) ] ifFalse: [ self sharedPools add: arg1 ]signalAll  ^self signalAll: niltestZeroRaisedToInteger  self should: [ 0.0s1 raisedToInteger: -1 ] raise: Error.  self assert: (0.0s1 raisedToInteger: 0) equals: 1.  self assert: (0.0s1 raisedToInteger: 0) scale equals: 1.  self assert: (0.0s1 raisedToInteger: 1) equals: 0.  self assert: (0.0s1 raisedToInteger: 1) scale equals: 1.  self assert: (0.0s1 raisedToInteger: 2) equals: 0.  self assert: (0.0s1 raisedToInteger: 2) scale equals: 1instVarName  ^instVarNameensureReceiverAndArguments: arg1  arg1 ifNil: [ ^false ].  arg1 class isObsolete ifTrue: [ ^false ].  (arg1 isBehavior and: [ self receiver isObsolete ]) ifTrue: [ ^false ].  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg2 :arg3 |  arg2 ifNil: [ arg3 ifFalse: [ ^false ] ] ] ].  ^trueremoveSlot: arg1  ^self subclassResponsibilitycopy: arg1 from: arg2 classified: arg3  | tmp1 tmp2 |  tmp1 := arg2 sourceCodeAt: arg1.  tmp1 ifNotNil: [ arg3 ifNil: [ tmp2 := arg2 organization categoryOfElement: arg1 ] ifNotNil: [ tmp2 := arg3 ].        (self includesLocalSelector: arg1) ifTrue: [ tmp1 asString = (self sourceCodeAt: arg1) asString ifFalse: [ self error: self name , ' ' , arg1 , ' will be redefined if you proceed.' ] ].        self compile: tmp1 classified: tmp2 ]jump: arg1 if: arg2  | tmp1 |  tmp1 := self pop.  (tmp1 == true or: [ tmp1 == false ]) ifFalse: [ ^self send: #mustBeBoolean to: tmp1 with: {} super: false ].  (tmp1 eqv: arg2) ifTrue: [ self jump: arg1 ]supportsClosureOpcodes  ^trueepiceaBrowsersAsString  | tmp1 |  tmp1 := self class today subtractDate: self.  tmp1 < 2 ifTrue: [ ^String streamContents: [:arg1 |  arg1 nextPutAll: (tmp1 = 0 ifTrue: [ 'Today' ] ifFalse: [ 'Yesterday' ]) ] ].  (tmp1 between: 2 and: 7) ifTrue: [ ^tmp1 asString , ' days ago' ].  ^self asDate asStringisLiteral  ^trueflushCache  < primitive: 116>  testReadFromUTCOffset  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321Z' readStream) offset isZero.  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321+00' readStream) offset isZero.  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321+0000' readStream) offset isZero.  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321+00:00' readStream) offset isZerolink: arg1 toTemporaryNamed: arg2 inMethod: arg3 option: arg4  arg1 installOnTempVarNamed: arg2 inMethod: arg3 for: self option: arg4 instanceSpecific: self intanceSpecificMetaLinksAvailableisExtended  ^self extendingPackages isEmptyhash  (self isFinite and: [ self fractionPart = 0.0 ]) ifTrue: [ ^self truncated hash ].  ^((self basicAt: 1) bitAnd: 16r00FFFF00) + ((self basicAt: 2) bitAnd: 16r00FFFF00) bitShift: -8testYearDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1970 day: 1 hour: 0 minute: 0 second: 0)namedTempAt: arg1  ^self tempNamed: (self tempNames at: arg1)includesAnyOf: arg1  ^self includesAny: arg1testAsLargerPowerOfTwo  self should: [ (2 raisedTo: 80) negated asLargerPowerOfTwo ] raise: DomainError.  self should: [ -1 asLargerPowerOfTwo ] raise: DomainError.  self should: [ 0 asLargerPowerOfTwo ] raise: DomainError.  self assert: 1 asLargerPowerOfTwo equals: 1.  self assert: 2 asLargerPowerOfTwo equals: 2.  self assert: 3 asLargerPowerOfTwo equals: 4.  self assert: 4 asLargerPowerOfTwo equals: 4.  self assert: 5 asLargerPowerOfTwo equals: 8.  self assert: ((2 raisedTo: 80) + 1) asLargerPowerOfTwo equals: (2 raisedTo: 80 + 1).  self assert: (2 raisedTo: 80) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self assert: ((2 raisedTo: 80) - 1) asLargerPowerOfTwo equals: (2 raisedTo: 80)bytesCompare: arg1  < primitive: 'primDigitCompare' module: 'LargeIntegers'>  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self bytesCount.  (tmp2 := arg1 bytesCount) ~= tmp1 ifTrue: [ tmp2 > tmp1 ifTrue: [ ^-1 ] ifFalse: [ ^1 ] ].  [ tmp1 > 0 ] whileTrue: [ (tmp3 := arg1 byteAt: tmp1) ~= (tmp4 := self byteAt: tmp1) ifTrue: [ tmp3 < tmp4 ifTrue: [ ^1 ] ifFalse: [ ^-1 ] ].        tmp1 := tmp1 - 1 ].  ^0debug: arg1 title: arg2  ^self debug: arg1 title: arg2 full: falseactiveOuterContext  | tmp1 |  self isBlockContext ifFalse: [ ^self ].  self sender ifNil: [ ^nil ].  tmp1 := self outerContext.  ^self sender findContextSuchThat: [:arg1 |  arg1 = tmp1 ]testCharacterization  self assert: Float fmax successor equals: Float infinity.  self assert: Float infinity predecessor equals: Float fmax.  self assert: Float fmax negated predecessor equals: Float infinity negated.  self assert: Float infinity negated successor equals: Float fmax negated.  self assert: Float fmin predecessor equals: 0.0.  self assert: 0.0 successor equals: Float fmin.  self assert: Float fmin negated successor equals: 0.0.  self assert: 0.0 predecessor equals: Float fmin negated.  self assert: Float one + Float epsilon > Float one.  self assert: Float one + Float epsilon equals: Float one successor.  self assert: Float one + (Float epsilon / Float radix) equals: Float one.  self assert: Float fmax exponent equals: Float emax.  self assert: Float fminNormalized exponent equals: Float emin.  Float denormalized ifTrue: [ self assert: Float fminDenormalized exponent equals: Float emin + 1 - Float precision ].  self assert: (Float radix - Float epsilon) * (Float radix raisedTo: Float emax) equals: Float fmax.  self assert: Float epsilon * (Float radix raisedTo: Float emin) equals: Float fmin.  self assert: Float one predecessor successor equals: Float one.  self assert: Float one successor predecessor equals: Float one.  self assert: Float one negated predecessor successor equals: Float one negated.  self assert: Float one negated successor predecessor equals: Float one negated.  self assert: Float infinity successor equals: Float infinity.  self assert: Float infinity negated predecessor equals: Float infinity negated.  self assert: Float nan predecessor isNaN.  self assert: Float nan successor isNaN.  self assert: Float fmax hex equals: '7FEFFFFFFFFFFFFF'.  self assert: Float fminDenormalized hex equals: '0000000000000001'.  self assert: Float fminNormalized hex equals: '0010000000000000'.  self assert: 0.0 hex equals: '0000000000000000'.  self assert: Float negativeZero hex equals: '8000000000000000'.  self assert: Float one hex equals: '3FF0000000000000'.  self assert: Float infinity hex equals: '7FF0000000000000'.  self assert: Float infinity negated hex equals: 'FFF0000000000000'fuelAccept: arg1  ^arg1 visitHookPrimitive: selfmessages  | tmp1 |  tmp1 := self localMessages.  self innerCompiledBlocksDo: [:arg1 |  tmp1 := tmp1 , arg1 messages ].  ^tmp1sourceNode  ^self subclassResponsibilityjsonOn: arg1  arg1 nullallLiterals  | tmp1 tmp2 |  tmp1 := Array new: (tmp2 := self numLiterals).  1 to: tmp2 do: [:arg1 |  tmp1 at: arg1 put: (self objectAt: arg1 + 1) ].  ^tmp1printOn: arg1 showingDecimalPlaces: arg2  self printOn: arg1 base: 10.  arg2 <= 0 ifTrue: [ ^self ].  arg1 nextPut: $..  arg2 timesRepeat: [ arg1 nextPut: $0 ]randomCodePoint  ^self randomCodePointBetween: 0 and: Unicode maxValuesunitAnnounce: arg1 toResult: arg2  self resumetestPlus  self assert: aDateAndTime + '0:00:00:00' equals: aDateAndTime.  self assert: aDateAndTime + 0 equals: aDateAndTime.  self assert: aDateAndTime + aDuration equals: (DateAndTime year: 1980 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)package  ^self packageFromOrganizer: RPackage organizertestMutateByteStringyUsingAtPut  | tmp1 |  tmp1 := ByteString new: 5.  tmp1 beReadOnlyObject.  self should: [ tmp1 at: 1 put: $h ] raise: ModificationForbidden.  [ tmp1 at: 1 put: $h ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first equals: $hremoveSubclass: arg1  * arg1  | tmp1 tmp2 |  arg1 isFraction ifTrue: [ tmp1 := numerator gcd: arg1 denominator.        tmp2 := denominator gcd: arg1 numerator.        (tmp2 = denominator and: [ tmp1 = arg1 denominator ]) ifTrue: [ ^numerator // tmp1 * (arg1 numerator // tmp2) ].        ^Fraction numerator: numerator // tmp1 * (arg1 numerator // tmp2) denominator: denominator // tmp2 * (arg1 denominator // tmp1) ].  ^arg1 adaptToFraction: self andSend: #*ticks  ^Array with: 0 with: seconds with: nanosisLineSeparator  ^self characterSet isLineSeparator: selfasNumber  ^selftestPerformCanExecutelongMethodWithTemps  | tmp1 tmp2 tmp3 |  tmp1 := 33.  tmp2 := 666.  tmp3 := 42.  self assert: (self perform: #a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15: withArguments: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)) equals: 1.  self assert: (self class >> #testPerformCanExecutelongMethodWithTemps) frameSize equals: CompiledMethod smallFrameSize.  self assert: (self class >> #a1:a2:a3:a4:a5:a6:a7:a8:a9:a10:a11:a12:a13:a14:a15:) frameSize equals: CompiledMethod fullFrameSizetestIsSurrogateOther  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isSurrogateOther: tmp2) equals: (tmp1 isSurrogateOther: tmp2) ]isAbstract  | tmp1 |  tmp1 := self markerOrNil ifNil: [ ^false ].  ^tmp1 == self class subclassResponsibilityMarker or: [ tmp1 == self class explicitRequirementMarker ]dependenciesOf: arg1  ^#('Collections-Strings' Kernel 'AST-Core')asDate  ^Date todaynominallyUnsent: arg1  false ifTrue: [ self flag: #nominallyUnsent: ]schedule: arg1  arg1 delaySemaphore signalhasSourceCode  ^self subclassResponsibilitytestIsSpacingCombiningMark  self checkCorrespondanceOf: #isSpacingCombiningMark: and: #Mcx  ^xto: arg1  ^(self asciiValue to: arg1 asciiValue) collect: [:arg2 |  Character value: arg2 ]testClockPrecisionDuration  | tmp1 |  tmp1 := Timespan starting: Date today duration: DateAndTime clockPrecision.  self assert: tmp1 start equals: tmp1 endallSelectors  ^self allSelectorsBelow: niltestDigitAtPut  | tmp1 |  tmp1 := LargePositiveInteger new: 20.  1 to: 20 do: [:arg1 |  tmp1 byteAt: arg1 put: arg1 ].  self assert: 114605103402541699037609980192546360895434064385 equals: tmp1basicTestSelectors  ^#(#simpleEnsureTest #simpleEnsureTestWithNotification #simpleEnsureTestWithUparrow #simpleEnsureTestWithError #signalFromHandlerActionTest #resumableFallOffTheEndHandler #nonResumableFallOffTheEndHandler #doubleResumeTest #simpleTimeoutWithZeroDurationTest #simpleTimeoutTest simpleNoTimeoutTest)testDenormalizedPrintString  | tmp1 tmp2 |  tmp1 := LargePositiveInteger new: 4.  tmp1 basicAt: 2 put: 255.  self assert: tmp1 size equals: 4.  self assert: tmp1 printString equals: '65280'.  self assert: tmp1 normalize equals: 65280.  self assert: (tmp1 normalize isMemberOf: SmallInteger).  tmp2 := LargePositiveInteger new: 0.  self assert: tmp2 size equals: 0.  self assert: tmp2 printString equals: '0'.  self assert: tmp2 normalize equals: 0.  self assert: (tmp2 normalize isMemberOf: SmallInteger)stack  ^self stackOfSize: 9999name  ^'Sends a deprecated message to a known global'sizeJumpLong: arg1  ^self sizeOpcodeSelector: #genJumpLong: withArguments: {arg1}subclass: arg1 slots: arg2 classVariables: arg3 poolDictionaries: arg4 category: arg5  self deprecated: 'use ... package: instead'.  ^self subclass: arg1 slots: arg2 classVariables: arg3 poolDictionaries: arg4 package: arg5testLessThan  self assert: aTime < (Time readFrom: '12:34:57' readStream)gtInspectorSourceIn: arg1  < gtInspectorPresentationOrder: 30>  self method gtInspectorSourceIn: arg1negated  ^self class newFromNumber: super negated scale: scaletestMonthDurations  | tmp1 tmp2 tmp3 |  tmp1 := Duration month: #January.  tmp2 := Duration month: #February.  tmp3 := Duration month: #December.  self     assert: tmp1 equals: Year current months first duration;     assert: tmp2 equals: Year current months second duration;     assert: tmp3 equals: Year current months last durationreturn  self return: self defaultReturnValueisResumable  ^truetestErrorWithErrorHandler  self runSimulated: [ [ self methodWithError ] on: Error do: [:arg1 |   ] ]valueWithEnoughArguments: arg1  | tmp1 |  tmp1 := Array new: selector numArgs.  tmp1 replaceFrom: 1 to: (arguments size min: tmp1 size) with: arguments startingAt: 1.  tmp1 size > arguments size ifTrue: [ tmp1 replaceFrom: arguments size + 1 to: (arguments size + arg1 size min: tmp1 size) with: arg1 startingAt: 1 ].  ^receiver perform: selector withArguments: tmp1testBitMask  self assert: (2r11 allMask: 2r11).  self deny: (2r10 allMask: 2r11).  self deny: (2r01 allMask: 2r11).  self assert: (2r10 anyMask: 2r11).  self assert: (2r01 anyMask: 2r11).  self deny: (2r00 anyMask: 2r11)fileOutSharedPoolsOn: arg1  | tmp1 |  tmp1 := self sharedPools select: [:arg2 |  self shouldFileOutPool: (self environment keyAtIdentityValue: arg2) ].  tmp1 do: [:arg2 |  self fileOutPool: arg2 onFileStream: arg1 ]x106kbits  ^(15 to: 55 by: 4) inject: 9876543210 into: [:arg1 :arg2 |  (arg1 * arg1 << arg2) + arg2 ]- arg1  arg1 class = self class ifTrue: [ ^self asFraction - arg1 asFraction asScaledDecimal: (scale max: arg1 scale) ].  ^self coerce: self asFraction - arg1acceptSettings: arg1  ^arg1 visitObject: selfpackAsFloatToArity: arg1  | tmp1 |  tmp1 := self.  1 to: arg1 do: [:arg2 |  tmp1 := tmp1 pointerFloat ].  ^tmp1setTimestampInMetacelloConfig: arg1  arg1 setTimestampWithBlock: selfsizeStorePopInstVarLong: arg1  ^self sizeOpcodeSelector: #genStorePopInstVarLong: withArguments: {arg1}testYear  self assert: aDateAndTime year equals: 1980testHour12  self assert: aDateAndTime hour12 equals: 1low16Bits  ^value & 2r1111111111111111testIsCasedLetter  self aRandomSelectionOfCharactersDo: [:arg1 |  self deny: (Unicode isCasedLetter: arg1) ]ffiArgumentNames  ^self propertyValueAt: #ffiArgumentNames ifAbsent: [ self propertyValueAt: #ffiArgumentNames put: self argumentNames ]testNanoSecond  self assert: aDateAndTime nanoSecond equals: 0spotterForImplementorsFor: arg1  < spotterOrder: 10>  arg1 listProcessor     title: 'Implementors';     allCandidates: [ self implementors collect: #compiledMethod ];     filter: GTFilterSubstring;     keyBinding: $m commandheaderDescription  | tmp1 |  tmp1 := '' writeStream.  self header printOn: tmp1.  tmp1     cr;     nextPutAll: '"signFlag: '.  self signFlag printOn: tmp1.  tmp1 nextPutAll: ' ('.  self encoderClass name printOn: tmp1.  tmp1 nextPut: $).  tmp1     cr;     nextPutAll: 'primitive: '.  self primitive printOn: tmp1.  tmp1     cr;     nextPutAll: ' numArgs: '.  self numArgs printOn: tmp1.  tmp1     cr;     nextPutAll: ' numTemps: '.  self numTemps printOn: tmp1.  tmp1     cr;     nextPutAll: ' numLiterals: '.  self numLiterals printOn: tmp1.  tmp1     cr;     nextPutAll: ' frameSize: '.  self frameSize printOn: tmp1.  tmp1     nextPut: $";     cr.  ^tmp1 contentsadaptToFraction: arg1 andSend: arg2  ^(arg1 asScaledDecimal: scale) perform: arg2 with: selfobject: arg1 eqeq: arg2  < primitive: 110>  self primitiveFailedveryDeepCopyWith: arg1  roundDownTo: arg1  ^(self / arg1) floor * arg1testChangingStatus  aStopwatch activate.  self assert: aStopwatch isActive.  self assert: aStopwatch timespans size equals: 1.  aStopwatch suspend.  self assert: aStopwatch isSuspended.  self assert: aStopwatch timespans size equals: 1.  aStopwatch activate.  aStopwatch reActivate.  self assert: aStopwatch isActive.  self assert: aStopwatch timespans size equals: 3.  aStopwatch reset.  self assert: aStopwatch isSuspended.  self assert: aStopwatch timespans size equals: 0when: arg1 evaluate: arg2  | tmp1 |  tmp1 := self actionSequenceForEvent: arg1.  (tmp1 includes: arg2) ifTrue: [ ^self ].  self setActionSequence: (tmp1 copyWith: arg2) forEvent: arg1instanceSide  ^selfhour  ^self hour24waitUntil: arg1 maxMilliseconds: arg2  ^self waitUntil: arg1 for: nil maxMilliseconds: arg2distanceTo: arg1  | tmp1 tmp2 |  tmp1 := arg1 x - x.  tmp2 := arg1 y - y.  ^(tmp1 * tmp1 + (tmp2 * tmp2)) sqrtanyBitOfMagnitudeFrom: arg1 to: arg2  < primitive: 'primAnyBitFromTo' module: 'LargeIntegers'>  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  arg1 < 1 | (arg2 < 1) ifTrue: [ ^self error: 'out of range' ].  tmp1 := self abs.  tmp6 := arg2 min: tmp1 highBit.  arg1 > tmp6 ifTrue: [ ^false ].  tmp2 := (arg1 - 1) // 8 + 1.  tmp3 := (tmp6 - 1) // 8 + 1.  tmp4 := ((arg1 - 1) \\ 8) negated.  tmp5 := 7 - ((tmp6 - 1) \\ 8).  tmp2 = tmp3 ifTrue: [ | tmp7 tmp8 |        tmp8 := (255 bitShift: tmp4 negated) bitAnd: (255 bitShift: tmp5 negated).        tmp7 := tmp1 byteAt: tmp2.        ^(tmp7 bitAnd: tmp8) ~= 0 ].  ((tmp1 byteAt: tmp2) bitShift: tmp4) ~= 0 ifTrue: [ ^true ].  tmp2 + 1 to: tmp3 - 1 do: [:arg3 |  (tmp1 byteAt: arg3) ~= 0 ifTrue: [ ^true ] ].  (((tmp1 byteAt: tmp3) bitShift: tmp5) bitAnd: 255) ~= 0 ifTrue: [ ^true ].  ^falsedeactivated  whichSelectorsRead: arg1  ^self slotNamed: arg1 ifFound: [:arg2 |  self selectors select: [:arg3 |  arg2 isReadIn: self >> arg3 ] ] ifNone: [ #() ]fileOutOn: arg1 initializing: arg2  super fileOutOn: arg1.  (arg2 and: [ self includesSelector: #initialize ]) ifTrue: [ arg1 cr.        arg1 cr.        arg1 nextChunkPut: thisClass name , ' initialize'.        arg1 cr ]doesNotUnderstand: arg1  < debuggerCompleteToSender>  ^MessageNotUnderstood new     message: arg1;     receiver: self;     signalreturn: arg1  handlerContext return: arg1testDigitAtPut  | tmp1 |  tmp1 := LargeNegativeInteger new: 20.  1 to: 20 do: [:arg1 |  tmp1 byteAt: arg1 put: arg1 ].  self assert: -114605103402541699037609980192546360895434064385 equals: tmp1methodWithError  self error: 'my error'completeProcess: arg1 with: arg2  ^arg2 methodNode pragmaNamed: #debuggerCompleteToSender ifPresent: [ arg1 completeTo: arg2 sender ] ifAbsent: [ super completeProcess: arg1 with: arg2 ]setDefaultList: arg1  categoryArray := Array with: Default.  categoryStops := Array with: arg1 size.  elementArray := arg1 asArraycommentStamp: arg1  commentStamp := arg1arcCos  ^Halfpi - self arcSinsetKeyword: arg1  self deprecated: 'Use #selector: instead.' transformWith: '`@receiver setKeyword: `@arg' -> '`@receiver selector: `@arg'.  self selector: arg1home  ^homesourceNode  ^self compiledBlock sourceNodeInOutertestConvertFromFraction  | tmp1 |  tmp1 := 13 / 11 asScaledDecimal: 6.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: '1.181818s6' equals: tmp1 printString.  self assert: 6 equals: tmp1 scale.  tmp1 := -13 / 11 asScaledDecimal: 6.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: '-1.181818s6' equals: tmp1 printString.  self assert: 6 equals: tmp1 scalevariable  ^variableisTaggedWith: arg1  ^self tags includes: arg1testNewProcess  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := [ tmp1 := true ].  tmp3 := tmp2 newProcess.  self deny: tmp1.  self assert: (tmp3 isKindOf: Process).  self assert: tmp3 isSuspendedexplore  self deprecated: 'Please use #inspect instead' transformWith: '`@receiver explore' -> '`@receiver inspect'.  ^self inspectrationale  ^'You should not reference ' , (self systemClassNames joinUsing: Character space) , ' as they are there for system purpose and should not be referenced directly.'min: arg1  ^(x min: arg1 x) @ (y min: arg1 y)workDatesDo: arg1  self do: arg1 with: start asDate when: [:arg2 |  arg2 dayOfWeek < 6 ]isContext  ^falseremoveSelector: arg1  self methodDict removeKey: arg1 ifAbsent: [  ]genStorePopTemp: arg1  (arg1 < 0 or: [ arg1 > 63 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63 ].  arg1 < 8 ifTrue: [ stream nextPut: 208 + arg1.        ^self ].  stream     nextPut: 242;     nextPut: arg1monthName  ^start monthNamepackageFromOrganizer: arg1  ^arg1 packageOf: selfeveryDayAtSameTimes  | tmp1 |  tmp1 := (Duration days: 1) / self scheduleDuration.  ^tmp1 >= 1 and: [ tmp1 isInteger ]printOn: arg1  arg1     print: self methodClass;     nextPutAll: '>>';     print: self selectorisMorph  ^falsebrickValue: arg1  ^selfshouldFileOutPools  ^self confirm: 'FileOut selected sharedPools?'initialize  super initialize.  self resetbasicAt: arg1  < primitive: 38>  ^super basicAt: arg1reservedNames  ^#('self' 'thisContext' 'stack top')isThisEverCalled  ^self isThisEverCalled: thisContext sender printStringaddAndClassifySelector: arg1 withMethod: arg2 inProtocol: arg3  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self compiledMethodAt: arg1 ifAbsent: [ nil ].  tmp1 ifNotNil: [ tmp2 := tmp1 origin ].  self addSelectorSilently: arg1 withMethod: arg2.  tmp3 := self organization categoryOfElement: arg1.  SystemAnnouncer uniqueInstance suspendAllWhile: [ self organization classify: arg1 under: (arg3 = Protocol unclassified ifTrue: [ tmp3 ] ifFalse: [ arg3 ]) ].  tmp4 := self organization categoryOfElement: arg1.  self isAnonymous ifTrue: [ ^self ].  (tmp1 isNil or: [ tmp2 ~= arg2 origin ]) ifTrue: [ SystemAnnouncer uniqueInstance methodAdded: arg2 ] ifFalse: [ self notifyRepackage: arg1 method: arg2 oldProtocol: tmp3 newProtocol: tmp4.        SystemAnnouncer uniqueInstance methodChangedFrom: tmp1 to: arg2 oldProtocol: tmp3 ]cannotReturn: arg1 to: arg2  ^ContextCannotReturn result: arg1 to: arg2testMidnight  self assert: aDateAndTime midnight equals: '2004-02-29T00:00:00+02:00' asDateAndTimetestQuotient  | tmp1 tmp2 tmp3 |  tmp1 := 11.5 seconds.  tmp2 := tmp1 // 3.  self assert: tmp2 equals: (Duration seconds: 3 nanoSeconds: 833333333).  tmp3 := tmp1 // 3 seconds.  self assert: tmp3 equals: 3corners  ^Array with: self topLeft with: self bottomLeft with: self bottomRight with: self topRightremoveFromSystemUnlogged  ^self removeFromSystem: falserounded  ^Rectangle origin: origin rounded corner: corner roundedmetacelloSemanticVersionComponentLessThan: arg1  ^arg1 metacelloSemanticIntegerLessThanSelf: selftestInstVarNamed  | tmp1 |  tmp1 := ObjectMockForTest new.  self assert: (tmp1 instVarNamed: 'variable') isNil.  tmp1 variable: 1.  self assert: (tmp1 instVarNamed: 'variable') equals: 1.  self shouldnt: [ tmp1 instVarNamed: 'variable' ] raise: InstanceVariableNotFound.  self should: [ tmp1 instVarNamed: 'timoleon' ] raise: InstanceVariableNotFound.  self assert: ([ tmp1 instVarNamed: 'timoleon' ] on: InstanceVariableNotFound do: [:arg1 |  arg1 instVarName ]) equals: 'timoleon'subclasses  | tmp1 |  tmp1 := Array new writeStream.  self subclassesDo: [:arg1 |  tmp1 nextPut: arg1 ].  ^tmp1 contentsduringTestCompileSilently: arg1 classified: arg2  ^self duringTestCompileSilently: arg1 storeSource: true classified: arg2testHour  self assert: aTime hour equals: 12.  self assert: aTime hour12 equals: 12.  self assert: aTime hour24 equals: 12.  self assert: aTime hours equals: 12detentBy: arg1 atMultiplesOf: arg2 snap: arg3  | tmp1 tmp2 |  tmp1 := self roundTo: arg2.  (self roundTo: arg1) = tmp1 ifTrue: [ ^tmp1 ].  arg3 ifTrue: [ ^self ].  tmp2 := self < tmp1 ifTrue: [ tmp1 - (arg1 asFloat / 2) ] ifFalse: [ tmp1 + (arg1 asFloat / 2) ].  ^tmp1 + ((self - tmp2) * arg2 asFloat / (arg2 - arg1))notifyOfRemovedCategory: arg1  self hasSubject ifFalse: [ ^self ].  SystemAnnouncer uniqueInstance protocolRemoved: arg1 inClass: self subjecttestSupplyAnswerUsingTraditionalMatchOfQuestion  self should: [ true = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('*Smalltalk#' true)) ]printStringLimitedTo: arg1 using: arg2  | tmp1 |  tmp1 := String streamContents: arg2 limitedTo: arg1.  tmp1 size < arg1 ifTrue: [ ^tmp1 ].  ^tmp1 , '...etc...'pointsTo: arg1  ^(self instVarsInclude: arg1) or: [ ^self class == arg1 ]interpretJump  ^self method encoderClass interpretJumpIn: selfstandardMessageText  ^fieldIndex ifNil: [ self nonIndexedMessageText ] ifNotNil: [ self indexedMessageText ]sender  ^outerContext sendertestFirstDayOfMonth  self assert: aDateAndTime firstDayOfMonth equals: 1testAsMonth  self assert: aDateAndTime asMonth equals: ((Month year: 2004 month: 'February') translateTo: 2 hours)adaptToInteger: arg1 andCompare: arg2  ^self adaptToInteger: arg1 andSend: arg2odd  ^self even == falsetestIsLeapYear  | tmp1 tmp2 |  tmp1 := january23rd2004.  tmp2 := tmp1 + 365 days.  self assert: tmp1 isLeapYear equals: true.  self assert: tmp2 isLeapYear equals: falsetestIncludes  self assert: (aTimespan includes: jan01).  self deny: (aTimespan includes: jan08)category: arg1  | tmp1 |  tmp1 := self basicCategory.  arg1 isString ifTrue: [ self basicCategory: arg1 asSymbol.        self environment organization classify: self name under: self basicCategory ] ifFalse: [ self errorCategoryName ].  SystemAnnouncer uniqueInstance class: self recategorizedFrom: tmp1 to: self basicCategorycontextOfDeprecatedMethod  ^contextscaleFrom: arg1 to: arg2  ^(origin scaleFrom: arg1 to: arg2) corner: (corner scaleFrom: arg1 to: arg2)isRectangle  ^true- arg1  self addExclusion: arg1isReferenced  ^self environment allBehaviors anySatisfy: [:arg1 |  arg1 hasSelectorReferringTo: self binding ]bitXor: arg1  < primitive: 'primDigitBitXor' module: 'LargeIntegers'>  | tmp1 |  tmp1 := arg1 normalize.  ^self digitLogic: tmp1 op: #bitXor: length: (self bytesCount max: tmp1 bytesCount)gtInspectorHash  ^self hashwhileNotNil: arg1  ^[ self value notNil ] whileTrue: [ arg1 value ]encodeEmbeddedSourceQCompress  | tmp1 tmp2 tmp3 |  [ data isString ] assert.  tmp1 := self qCompress: data.  tmp2 := tmp1 position.  tmp3 := self encodeLengthField: tmp2.  tmp1 nextPutAll: tmp3.  tmp1 nextPut: self kindAsByte + tmp3 size - 1.  encodedData := tmp1 contentsround: arg1  ^(self asFraction round: arg1) asFloatisColor  ^falselogCr  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver logCr' -> '`@receiver traceCr'.  self traceCronLineFrom: arg1 to: arg2  ^self onLineFrom: arg1 to: arg2 within: 2lowerBound: arg1  lowerBound := arg1unschedule: arg1  readyToUnschedule wait.  delayToStop := arg1.  timingSemaphore signalinitialize  super initialize.  reachedDefaultHandler := falsesizeTrapIfNotInstanceOf: arg1  ^self sizeOpcodeSelector: #genTrapIfNotInstanceOf: withArguments: {arg1}ensureReceiver: arg1  arg1 ifNil: [ ^false ].  arg1 class isObsolete ifTrue: [ ^false ].  (arg1 isBehavior and: [ arg1 isObsolete ]) ifTrue: [ ^false ].  ^truetestRounding  self assert: (6 / 90 round: 2) equals: 7 / 100testSimpleRetryUsing  self assertSuccess: (ExceptionTester new runTest: #simpleRetryUsingTest)subclass: arg1 uses: arg2  ^self subclass: arg1 uses: arg2 instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'Unclassified'testFractionAsFloatWithUnderflow  | tmp1 |  tmp1 := Float emin - Float precision.  self assert: (2 raisedTo: tmp1) asFloat equals: 0.0.  self assert: (2 raisedTo: tmp1) negated asFloat equals: 0.0.  self assert: (2 raisedTo: tmp1) negated asFloat signBit = 1 description: 'a negative underflow should return a negative zero'asStringWithCommas  ^String streamContents: [:arg1 |  self printWithCommasOn: arg1 ]testIsInitialQuote  self checkCorrespondanceOf: #isInitialQuote: and: #PinowTick  self subclassResponsibilitytestYear  self assert: aDateAndTime year equals: 1970testDayOfYear  self assert: aDateAndTime dayOfYear equals: 1setUp  | tmp1 |  super setUp.  tmp1 := Object newAnonymousSubclass.  testingEnvironment at: self globalName put: tmp1 new.  tmp1 compile: self deprecatedMethodName , ' self deprecated: ''this method is deprecated'''.  tmp1 compile: self nonDeprecatedMethodName.  testClass := Object newAnonymousSubclassasContext  ^selfasBit  ^0onNextMonth  ^self addMonths: 1createDate  ^Date year: year month: month day: daytickAfterMilliseconds: arg1  self subclassResponsibilitytestAsUTC  self assert: aDateAndTime asUTC equals: aDateAndTimetestAsSeconds  self assert: aDuration asSeconds equals: 48780.  self assert: aDateAndTime asSeconds equals: 3255507180definitionWithoutSlots  ^String streamContents: [:arg1 |  arg1 print: self.        arg1           crtab;           nextPutAll: 'instanceVariableNames: ';           store: self instanceVariablesString ]elementSize  | tmp1 |  tmp1 := self instSpec.  tmp1 < 9 ifTrue: [ ^Smalltalk wordSize ].  tmp1 >= 16 ifTrue: [ ^1 ].  tmp1 >= 12 ifTrue: [ ^2 ].  tmp1 >= 10 ifTrue: [ ^4 ].  ^8inspect  ^Smalltalk tools inspector inspect: selfrem: arg1  < primitive: 20>  arg1 isInteger ifTrue: [ | tmp1 tmp2 |        tmp1 := self negative == arg1 negative == false.        tmp2 := (self digitDiv: arg1 neg: tmp1) at: 2.        ^tmp2 normalize ].  ^super rem: arg1testRounding  self assert: (10.1234 round: 2) equals: 10.12.  self assert: (10.1234 round: 0) equals: 10exceptionClass  ^self tempAt: 1gtDebuggerRawIn: arg1  (GTObjectVariablesBrowser new variablesIn: arg1)     title: 'Raw';     send: #valuetestNoon  self assert: aDateAndTime noon equals: '1901-01-01T12:00:00+00:00' asDateAndTimesubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5  ^self subclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5> arg1  < primitive: 4>  ^super > arg1spotterPreviewRawIn: arg1  < spotterPreview: 40>  arg1 table     title: [ self gtDisplayString ];     display: [:arg2 |  arg2 gtInspectorVariableValuePairs asSortedCollection asOrderedCollection yourself           addFirst: 'self' -> arg2;           yourself ];     column: 'Variable' evaluated: [:arg3 |  GTObjectPrinter asNonTruncatedTextFrom: arg3 key ] styled: [:arg4 |  arg4           textPosition: #rightCenter;           margin: #(0 15 0 0);           textColor: arg1 themer textLightColor;           height: 30 ];     column: 'Value' evaluated: [:arg3 |  GTObjectPrinter asTruncatedTextFrom: arg3 value ] styled: [:arg4 |  arg4           margin: #(0 0 0 15);           height: 30 ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'defaultAction  UIManager default warningDefaultAction: selfisMeta  ^self isClassSidecollect: arg1  | tmp1 tmp2 |  tmp2 := self class new.  tmp1 := firstLink.  [ tmp1 == nil ] whileFalse: [ tmp2 add: (arg1 value: tmp1 value).        tmp1 := tmp1 nextLink ].  ^tmp2= arg1  ^self == arg1listAtCategoryNumber: arg1  | tmp1 tmp2 |  (arg1 < 1 or: [ arg1 > categoryStops size ]) ifTrue: [ ^nil ].  tmp1 := self firstIndexOfCategoryNumber: arg1.  tmp2 := self lastIndexOfCategoryNumber: arg1.  ^elementArray copyFrom: tmp1 to: tmp2nextByte  ^self method at: pctestMultipleTimings  aStopwatch activate.  aDelay wait.  aStopwatch suspend.  aStopwatch activate.  aDelay wait.  aStopwatch suspend.  self assert: aStopwatch timespans size equals: 2.  self assert: aStopwatch timespans first asDateAndTime <= aStopwatch timespans last asDateAndTimegenPushCharacter: arg1  | tmp1 |  tmp1 := arg1 isInteger ifTrue: [ arg1 ] ifFalse: [ arg1 asInteger ].  (tmp1 < 0 or: [ tmp1 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'character' index: tmp1 range: 0 to: 65535 ].  tmp1 > 255 ifTrue: [ self genUnsignedSingleExtendB: (tmp1 bitShift: -8) ].  stream     nextPut: 233;     nextPut: (tmp1 bitAnd: 255)superclass: arg1  arg1 ifNil: [ self basicSuperclass: arg1.        Object flushCache.        ^self ].  ^self classInstaller update: self to: [:arg2 |  arg2           fillFor: self;           superclass: arg1 ]tearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  super tearDownrfIsEqual: arg1  < metaLinkOptions: #(+ optionDisabledLink)>  < primitive: 110>  self primitiveFailedisPoint  ^trueselector  ^selectortestFirstDayOfMonth  self assert: aDateAndTime firstDayOfMonth equals: 1isEmptyOrNil  ^truetestWithComplexRecursion  self should: [ self complexRecursion ] notTakeMoreThanMilliseconds: 3outer  | tmp1 |  self isResumable ifTrue: [ tmp1 := outerContext.        outerContext := thisContext contextTag ].  self passdeepCopy  ^self copytestIvalidReadFrom  self should: [ Fraction readFromString: '+3' ] raise: Error description: 'numerator cannot specify a plus sign'.  self should: [ Fraction readFromString: '-2/+3' ] raise: Error description: 'denominator cannot specify a plus sign'.  self should: [ Fraction readFromString: '(3/2)' ] raise: Error description: 'parenthesis are not allowed'.  self should: [ Fraction readFromString: ' 3/25' ] raise: Error description: 'leading spaces are not allowed before numerator'.  self should: [ Fraction readFromString: '22/ 3' ] raise: Error description: 'leading spaces are not allowed before denominator'.  self assert: (Fraction readFromString: '12345with some trailing characters') = 12345 description: 'non numeric trailing characters interrupt decoding'.  self assert: (Fraction readFromString: '1 / 2') = 1 description: 'A space behind numerator interrupt decoding'.  self assert: (Fraction readFromString: '22.0/3') = 22 description: 'decimal point interrupt decoding'.  self assert: (Fraction readFromString: '23s0/3') = 23 description: 'scale specification interrupt decoding'testAsMonthInYear  self assert: (Date asMonth: 9 inYear: 2018) asString equals: 'September 2018'value  ^selfanalogousCodeTo: arg1  ^self class == arg1 class and: [ self selector == arg1 selector and: [ arguments = arg1 arguments ] ]restoreLocalTimeZoneAfter: arg1  | tmp1 |  tmp1 := DateAndTime localTimeZone.  arg1 ensure: [ DateAndTime localTimeZone: tmp1 ]testEncodingNoTrailer  | tmp1 |  tmp1 := CompiledMethodTrailer new.  self assert: tmp1 kind identicalTo: #NoTrailer.  self assert: tmp1 size equals: 4.  tmp1 := tmp1 testEncoding.  self assert: tmp1 kind identicalTo: #NoTrailer.  self assert: tmp1 size equals: 4.  self assert: tmp1 endPC equals: 0basicAt: arg1 put: arg2  < primitive: 61>  arg1 isInteger ifTrue: [ self class isVariable ifTrue: [ (arg1 between: 1 and: self size) ifFalse: [ ^self errorSubscriptBounds: arg1 ] ] ifFalse: [ ^self errorNotIndexable ] ] ifFalse: [ ^arg1 isNumber ifTrue: [ self basicAt: arg1 asInteger put: arg2 ] ifFalse: [ self errorNonIntegerIndex ] ].  self isReadOnlyObject ifTrue: [ ^self modificationForbiddenFor: #basicAt:put: index: arg1 value: arg2 ].  self errorImproperStoreisFailToken: arg1  ^(self objectClass: arg1) == Array and: [ arg1 size = 2 and: [ (arg1 at: 1) == PrimitiveFailToken ] ]month  ^start monthassert: arg1 classAndValueEquals: arg2  self assert: arg1 class equals: arg2 class.  self assert: arg1 equals: arg2testMethodsReferencingClasses  | tmp1 tmp2 |  tmp1 := ((ClassTest methodsReferencingClasses: {(Smalltalk classNamed: #ExampleForTest12) .         (Smalltalk classNamed: #ExampleForTest1)}) sort: [:arg1 :arg2 |  arg1 name <= arg2 name ]) asArray.  tmp2 := {(ClassTest >> #referencingMethod1) .   (ClassTest >> #referencingMethod2) .   (ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.  self assert: tmp1 asSet equals: tmp2 asSetcanHandleSignal: arg1  ^falsebrickAlert  GLMAlertBrick alert: selfasEpiceaRingDefinition  | tmp1 |  tmp1 := self instanceSide asEpiceaRingDefinition.  ^tmp1 withMetaclass classSide     traitCompositionSource: self classSide traitCompositionString;     definitionSource: self classSide oldDefinition;     addInstanceVariables: self classSide instVarNames;     yourselfasStringOrText  ^self asStringtestFirstThursday  1800 to: 2000 do: [:arg1 |  | tmp1 |        tmp1 := (Year year: arg1) firstThursday.        self assert: tmp1 dayOfWeek equals: 5.        self assert: tmp1 year equals: arg1.        self assert: (tmp1 - 1 week) year equals: arg1 - 1 ]reverseDo: arg1  | tmp1 |  self basicSize to: 1 by: -1 do: [:arg2 |  (tmp1 := self basicAt: arg2) ifNotNil: [ arg1 value: tmp1 ] ]setTimestampInMetacelloVersion: arg1  arg1 setTimestamp: (arg1 project valueHolderSpec           value: self printString;           yourself)newDebugSessionNamed: arg1 startedAt: arg2  ^DebugSession named: arg1 on: self startedAt: arg2asApproximateFraction  ^self asApproximateFractionAtOrder: 0asHours  ^self asMinutes / 60.0testIntersectionWithSelf  self assert: (aTimespan intersection: aTimespan) equals: aTimespan.  self deny: (aTimespan intersection: anIncludedTimespan) equals: aTimespanwithoutListWrapper  ^selftestInitialStatus  self assert: aStopwatch isSuspended.  self deny: aStopwatch isActive.  self assert: aStopwatch duration equals: 0 secondsendPC  ^self blockCreationBytecodeMessage arguments last + startpc - 1sizeDup  ^self sizeOpcodeSelector: #genDup withArguments: #()testBasicProxyReadOnly  self alwaysReadOnlyObjects do: [:arg1 |  self assert: (MirrorPrimitives isObjectReadOnly: arg1) equals: true ]printOn: arg1  arg1 nextPutAll: self descriptionencodeEmbeddedSourceZip  self encodeUsingZipsubclass: arg1 uses: arg2 slots: arg3 classVariables: arg4 poolDictionaries: arg5 category: arg6  ^self subclass: arg1 uses: arg2 layout: self classLayout class slots: arg3 classVariables: arg4 poolDictionaries: arg5 category: arg6sizeReturnTopToCaller  ^self sizeOpcodeSelector: #genReturnTopToCaller withArguments: #()gcd: arg1  | tmp1 tmp2 |  tmp1 := self.  tmp2 := arg1.  [ tmp1 = 0 ] whileFalse: [ tmp1 := tmp2 \\ (tmp2 := tmp1) ].  ^tmp2 absremoveLast  | tmp1 tmp2 |  self emptyCheck.  tmp1 := lastLink.  firstLink == lastLink ifTrue: [ firstLink := nil.        lastLink := nil ] ifFalse: [ tmp2 := firstLink.        [ tmp2 nextLink == tmp1 ] whileFalse: [ tmp2 := tmp2 nextLink ].        tmp2 nextLink: nil.        lastLink := tmp2 ].  tmp1 nextLink: nil.  ^tmp1 valuetestYearMonthDay  self assert: aDateAndTime equals: (DateAndTime year: 1970 month: 1 day: 1)printOn: arg1  super printOn: arg1.  arg1     nextPutAll: ' top: ';     print: top;     nextPutAll: ' left: ';     print: left;     nextPutAll: ' bottom: ';     print: bottom;     nextPutAll: ' right: ';     print: rightspotterActDefault  ^self browseextendRectangle: arg1  ^Rectangle origin: arg1 origin corner: arg1 corner + (self width @ self height)testIsFinalQuote  self checkCorrespondanceOf: #isFinalQuote: and: #PftestAnalogousCodeTo  | tmp1 |  tmp1 := AdditionalMethodState new: 1.  tmp1 basicAt: 1 put: #traitSource -> TSortable.  self shouldnt: [ tmp1 analogousCodeTo: tmp1 ] raise: MessageNotUnderstoodpopIntoRemoteTemp: arg1 inVectorAt: arg2  (self at: arg2 + 1) at: arg1 + 1 put: self popspecies  ^ArraytestNot  self assert: false nottestTicksOffset  self assert: aDateAndTime equals: (aDateAndTime ticks: #(2444240 0 0) offset: DateAndTime localOffset)resignalAs: arg1  ^arg1 signalIn: signalContextnumberOfReservedLiterals  ^1resumptionTick  ^resumptionTicktestAsWeeks  | tmp1 tmp2 tmp3 |  tmp1 := Duration days: 7.  tmp2 := Duration weeks: 0.5.  tmp3 := Duration weeks: 0.25.  self     assert: 1 weeks equals: tmp1;     assert: 1.0 weeks equals: tmp1;     assert: 0.5 weeks equals: tmp2;     assert: (1 / 2) weeks equals: tmp2;     assert: (1 / 4) weeks equals: tmp3.  self assert: 1.4 weeks + 1.6 weeks equals: 3 weeksdefaultAction  ^UIManager default unhandledErrorDefaultAction: selftestDaysLeftInYear  self assert: aDateAndTime daysLeftInYear equals: 306isClass  ^truevalueAfterWaiting: arg1  ^[ arg1 wait.  self value ] forkAt: Processor userBackgroundPriority named: (String streamContents: [:arg2 |  arg2                 << 'After ';                 print: arg1;                 << ' do: ';                 print: self ])testTerminatedCriticalSectionShouldUnblockWaitingOne  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := Semaphore new.  tmp3 := self fork: [ mutex critical: [ tmp2 wait.              self error: 'should not happen' ] ].  self waitLastProcessLock.  self fork: [ mutex critical: [ tmp1 := true ] ].  self waitLastProcessLock.  tmp3 terminate.  self waitLastProcessTerminate.  self assert: tmp1negated  ^self class seconds: seconds negated nanoSeconds: nanos negatedtrace: arg1  Transcript show: arg1 asStringtestWaitTimeoutSecondsOnCompletionOnTimeout  self assert: (Semaphore new waitTimeoutSeconds: 0.05 onCompletion: [ #completed ] onTimeout: [ #timeout ]) identicalTo: #timeout.  self assert: (Semaphore new signal waitTimeoutSeconds: 0.05 onCompletion: [ #completed ] onTimeout: [ #timeout ]) identicalTo: #completedtestDegreeSinForExceptionalValues  self assert: Float nan degreeSin isNaN.  self assert: Float infinity degreeSin isNaN.  self assert: Float infinity negated degreeSin isNaNrenderOn: arg1  arg1 text: selfnanoSecond  ^self nanoSecondstestIntegerReadsOkFromString  self assert: (Integer readFrom: '123') equals: 123.  self assert: (Integer readFrom: '-123') equals: -123.  self assert: (Integer readFrom: 'a3' base: 16) equals: 163.  self assert: (Integer readFrom: '-a3' base: 16) equals: -163commonSuperclassWith: arg1  ^self allSuperclasses detect: [:arg2 |  arg1 allSuperclasses includes: arg2 ] ifNone: nilprimitive  | tmp1 |  ^(self header anyMask: 65536) ifTrue: [ (self at: (tmp1 := self initialPC) + 1) + ((self at: tmp1 + 2) bitShift: 8) ] ifFalse: [ 0 ]testNanoSecond  self assert: aDateAndTime nanoSecond equals: 0activeHome  | tmp1 |  self isBlockContext ifFalse: [ ^self ].  self sender ifNil: [ ^nil ].  tmp1 := self methodReturnContext.  ^self sender findContextSuchThat: [:arg1 |  arg1 = tmp1 ]testMinutes  self assert: aDateAndTime minutes equals: 0waitForUserSignalled: arg1 orExpired: arg2  | tmp1 |  tmp1 := self nowTick + (1 * 1000 * 1000).  arg2 ifNotNil: [ tmp1 := tmp1 min: arg2 resumptionTick ].  arg1 initSignals.  self primSignal: arg1 atUTCMicroseconds: tmp1.  arg1 wait& arg1  ^arg1testAddInstVarName  | tmp1 |  tmp1 := testEnvironment at: #TUTU.  tmp1 addInstVarNamed: 'x'.  self assert: tmp1 instVarNames equals: #('x').  tmp1 addInstVarNamed: 'y'.  self assert: tmp1 instVarNames equals: #('x' 'y')nthRoot: arg1  arg1 = 2 ifTrue: [ ^self sqrt ].  (arg1 isInteger not or: [ arg1 negative ]) ifTrue: [ ^ArithmeticError signal: 'nth root only defined for positive Integer n.' ].  ^self negative ifTrue: [ arg1 odd ifTrue: [ (self negated raisedTo: 1.0 / arg1) negated ] ifFalse: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ] ] ifFalse: [ self raisedTo: 1.0 / arg1 ]hasClassSide  ^self subclassResponsibilitytestIndexOfDay  | tmp1 |  tmp1 := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).  tmp1 withIndexDo: [:arg1 :arg2 |  self assert: (Week indexOfDay: arg1) equals: arg2 ].  self assert: (Week indexOfDay: 0) equals: 0.  self assert: (Week indexOfDay: 1) equals: 0.  self assert: (Week indexOfDay: 7) equals: 0.  self assert: (Week indexOfDay: 8) equals: 0.  self assert: (Week indexOfDay: #Sunnyday) equals: 0outerContext: arg1  outerContext := arg1testActiveHomeMethodContext  self     assert: aMethodContext activeHome identicalTo: aMethodContext;     assert: aMethodContext activeHome identicalTo: aMethodContext homecompile: arg1 classified: arg2  ^self compile: arg1 classified: arg2 notifying: nilstartUp  Warning signal: 'Delay scheduler is NOT RUNNING!'testIsClassSide  self deny: Point isClassSide.  self assert: Point class isClassSidegrid: arg1  | tmp1 tmp2 |  tmp1 := x + (arg1 x // 2) truncateTo: arg1 x.  tmp2 := y + (arg1 y // 2) truncateTo: arg1 y.  ^tmp1 @ tmp2greaseInteger  ^self charCodefirstComment  ^self comments ifEmpty: [ #() ] ifNotEmpty: [:arg1 |  arg1 first ]hours  ^self hourisStream  ^falsereadsField: arg1  self isReturnField ifTrue: [ ^self returnField = (arg1 - 1) ].  ^super readsField: arg1isPowerOfTwo  ^falsetestReferencedClasses  {(ExceptionTester -> {MyTestNotification .         Warning .         String .         MyResumableTestError .         OrderedCollection .         MyTestError}) .   (CollectionCombinator -> {Array}) .   (ExecutionEnvironmentStub -> {OrderedCollection})} do: [:arg1 |  self assert: arg1 key referencedClasses notEmpty.        self assert: (arg1 key referencedClasses asSet includesAll: arg1 value asSet) ]numArgs  ^closureOrNil ifNil: [ method numArgs ] ifNotNil: [ closureOrNil numArgs ]interpolateTo: arg1 at: arg2  ^self * (1 - arg2) + (arg1 * arg2)testHighBitOfMagnitude  | tmp1 |  tmp1 := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA) , {SmallInteger maxVal .         (SmallInteger maxVal + 1)}.  tmp1 := tmp1 , (tmp1 collect: [:arg1 |  arg1 raisedTo: 20 ]).  tmp1 do: [:arg2 |  | tmp2 tmp3 |        tmp2 := 0.        tmp3 := 1.        [ tmp3 > arg2 ] whileFalse: [ tmp2 := tmp2 + 1.              tmp3 := tmp3 bitShift: 1 ].        self assert: arg2 highBitOfMagnitude equals: tmp2.        self assert: arg2 negated highBitOfMagnitude equals: tmp2 ]testNegativeZeroAbs  self assert: Float negativeZero abs sign positive description: 'the absolute value of a negative zero is zero'fileOutInitializerOn: arg1  (self includesSelector: #initialize) ifTrue: [ arg1 cr.        arg1 nextChunkPut: self soleInstance name , ' initialize' ]pragmaDo: arg1  1 to: self basicSize do: [:arg2 |  | tmp1 |        tmp1 := self basicAt: arg2.        tmp1 isVariableBinding ifFalse: [ arg1 value: tmp1 ] ]asPolygonTransformedBy: arg1  ^{(arg1 transform: origin) .   (arg1 transformX: corner x Y: origin y) .   (arg1 transform: corner) .   (arg1 transformX: origin x Y: corner y)}home: arg1  home := arg1testHandlerFromAction  | tmp1 |  tmp1 := [ [ [ self error: 'trigger error' ] on: ZeroDivide do: [:arg1 |  'inner' ] ] on: Error do: [:arg1 |  3 / 0 ] ] on: ZeroDivide do: [:arg1 |  'outer' ].  self assert: 'outer' = tmp1 description: 'Incorrect handler'testNow  self deny: aDateAndTime equals: DateAndTime nowreferencingMethod1  ^ExampleForTest1isClass  ^truedaysInMonth  ^self asMonth daysInMonthisExtensionInPackage: arg1  ^arg1 includesExtensionSelector: self selector ofClass: self methodClassvariableWriteNodes  ^self methods flatCollect: [:arg1 |  arg1 variableWriteNodes ]copyTo: arg1  | tmp1 |  self == arg1 ifTrue: [ ^nil ].  tmp1 := self copy.  self sender ifNotNil: [ tmp1 privSender: (self sender copyTo: arg1) ].  ^tmp1initializeFrom: arg1  self traitComposition: self traitComposition copyTraitExpression.  self methodDict: self methodDict copy.  self basicOrganization: self organization copymethodReturnContext  ^self hometestHasSharedPools  self deny: Point hasSharedPools.  self assert: Date hasSharedPools.  self deny: Date class hasSharedPools.  self assert: RootClassPoolUser hasSharedPools.  self deny: SubclassPoolUser hasSharedPoolstestHour12  self assert: aDateAndTime hour12 equals: DateAndTime new hour12.  self assert: aDateAndTime hour12 equals: 12parseTwoDigitYear  year := self parse: 'year' expectedSize: 2doYetAnotherThing  self log: self doYetAnotherThingStringrewriterClass  ^self class environment at: #RBParseTreeRewriter ifAbsent: [ nil ]testValueWithinTimingRepeat  | tmp1 |  tmp1 := [ 3 timesRepeat: [ [ 500 milliSeconds asDelay wait ] valueWithin: 100 milliSeconds onTimeout: [  ] ] ] durationToRun.  self assert: tmp1 < 500 milliSecondstestIsPrime  self assert: 17 isPrime.  self assert: 78901 isPrime.  self assert: 104729 isPrime.  self assert: 15485863 isPrime.  self assert: 2038074743 isPrime.  self assert: 29996224275833 isPrime.  self deny: 561 isPrime.  self deny: 2821 isPrime.  self deny: 6601 isPrime.  self deny: 10585 isPrime.  self deny: 15841 isPrime.  self deny: 256 isPrime.  self deny: 29996224275831 isPrimeresumeUnchecked: arg1  | tmp1 |  outerContext ifNil: [ signalContext return: arg1 ] ifNotNil: [ tmp1 := outerContext.        outerContext := tmp1 tempAt: 1.        tmp1 return: arg1 ]testAsDate  self assert: aDateAndTime asDate equals: 'January 1, 1901' asDateffiCalloutIn: arg1  ^self calloutAPIClass inContext: arg1// arg1  < primitive: 32>  ^super // arg1threeWayCompareTo: arg1  ^self asBit threeWayCompareTo: arg1 asBitreading: arg1 pattern: arg2  ^(self dateParserClass readingFrom: arg2 readStream pattern: arg1) parseisRingResolved  ^trueveryDeepCopyWith: arg1  ^self shallowCopy= arg1  self species = arg1 species ifTrue: [ ^origin = arg1 origin and: [ corner = arg1 corner ] ] ifFalse: [ ^false ]hasSource  ^kind == #EmbeddedSource or: [ kind == #EmbeddedSourceQCompress or: [ kind == #EmbeddedSourceZip ] ]testGeneralInquiries  | tmp1 tmp2 |  self should: [ self timeClass timeWords ] raise: MessageNotUnderstood.  tmp1 := '2 June 1973' asDate.  time := '4:02:47 am' asTime.  tmp2 := self timeClass dateAndTimeFromSeconds: 2285280000 + 14567.  self assert: tmp2 equals: {tmp1 .         time}testDegreeCos  45.0 degreeCos.  self assert: (45.0 degreeCos squared - 0.5) abs <= Float epsilon.  self assert: (60.0 degreeCos - 0.5) abs <= Float epsilon.  self assert: (120.0 degreeCos + 0.5) abs <= Float epsilon.  -360.0 to: 360.0 do: [:arg1 |  self assert: (arg1 degreeCos closeTo: arg1 degreesToRadians cos) ].  -10.0 to: 10.0 do: [:arg2 |  self assert: (arg2 * 360 + 90) degreeCos equals: 0.        self assert: (arg2 * 360 - 90) degreeCos equals: 0.        self assert: (arg2 * 360 + 180) degreeCos + 1 equals: 0.        self assert: (arg2 * 360) degreeCos - 1 equals: 0 ]even  ^self \\ 2 = 0julianDayNumber  ^start julianDayNumberfork: arg1  | tmp1 |  tmp1 := arg1 forkNamed: testSelector.  forkedProcesses add: tmp1.  ^tmp1iconOrThumbnailOfSize: arg1  ^niltestIsQuick  | tmp1 |  tmp1 := self class compiledMethodAt: #returnTrue.  self assert: tmp1 isQuick.  tmp1 := self class compiledMethodAt: #returnPlusOne:.  self deny: tmp1 isQuick<= arg1  ^x <= arg1 x and: [ y <= arg1 y ]testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 13.  self assert: aDateAndTime hour equals: aDateAndTime hoursspotterSuperMethodsFor: arg1  < spotterOrder: 11>  arg1 listProcessor     title: 'Super instance methods';     allCandidates: [ self allMethods reject: [:arg2 |  arg2 methodClass = self ] ];     filter: GTFilterSubstringtempNames  ^self sourceNode temporaryNamesgenPushFullClosure: arg1 numCopied: arg2 receiverOnStack: arg3 outerContextNeeded: arg4  | tmp1 |  (arg2 < 0 or: [ arg2 > 64 ]) ifTrue: [ self outOfRangeError: 'num copied' index: arg2 range: 0 to: 64 ].  (arg1 < 0 or: [ arg1 > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 32768 ].  (tmp1 := arg1) > 255 ifTrue: [ self genUnsignedSingleExtendA: tmp1 // 256.        tmp1 := tmp1 \\ 256 ].  stream     nextPut: 249;     nextPut: tmp1;     nextPut: (arg3 asBit << 7) + (arg4 not asBit << 6) + arg2return: arg1 value: arg2  suspendedContext == arg1 ifTrue: [ ^Processor activeProcess evaluate: [ suspendedContext := arg1 return: arg2 from: arg1 ] onBehalfOf: self ].  self activateReturn: arg1 value: arg2.  ^self complete: arg1isFailedTest  ^self methodClass isTestCase and: [ self methodClass methodFailed: self selector ]testDoWith  | tmp1 |  tmp1 := 0.  aTimespan do: [:arg1 |  tmp1 := tmp1 + 1 ] with: (Timespan starting: jan01 duration: aDay).  self assert: tmp1 equals: 7selector  | tmp1 |  ^(tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 selector ] ifFalse: [ tmp1 ]simpleTimeoutWithZeroDurationTestResults  ^OrderedCollection new     add: self doSomethingElseString;     yourselfsameLiteralsAs: arg1  | tmp1 tmp2 tmp3 |  (tmp1 := self numLiterals) ~= arg1 numLiterals ifTrue: [ ^false ].  1 to: tmp1 - 1 do: [:arg2 |  tmp2 := self literalAt: arg2.        tmp3 := arg1 literalAt: arg2.        (tmp2 == tmp3 or: [ tmp2 literalEqual: tmp3 ]) ifFalse: [ (arg2 = 1 and: [ self isNamedPrimitive | self isExternalCallPrimitive ]) ifTrue: [ tmp2 isArray ifTrue: [ (tmp3 isArray and: [ tmp2 allButLast = tmp3 allButLast ]) ifFalse: [ ^false ] ] ifFalse: [ (tmp2 analogousCodeTo: tmp3) ifFalse: [ ^false ] ] ] ifFalse: [ arg2 = (tmp1 - 1) ifTrue: [ (tmp2 isSymbol and: [ tmp3 isSymbol ]) ifFalse: [ (self properties analogousCodeTo: arg1 properties) ifFalse: [ ^false ] ] ] ifFalse: [ ^false ] ] ] ].  tmp2 := self literalAt: tmp1.  tmp3 := arg1 literalAt: tmp1.  ^tmp2 class == tmp3 class and: [ tmp2 isVariableBinding ifTrue: [ tmp2 key = tmp3 key and: [ tmp2 value = tmp3 value ] ] ifFalse: [ tmp2 = tmp3 ] ]pushFullClosure: arg1 numCopied: arg2 receiverOnStack: arg3 ignoreOuterContext: arg4  | tmp1 tmp2 |  tmp1 := (1 to: arg2) collect: [:arg5 |  self pop ].  self push: (tmp2 := (FullBlockClosure new: arg2)           outerContext: (arg4 ifFalse: [ self ]);           receiver: (arg3 ifTrue: [ self pop ] ifFalse: [ receiver ]);           numArgs: arg1 numArgs;           compiledBlock: arg1;           yourself).  tmp1 size to: 1 by: -1 do: [:arg5 |  tmp2 at: tmp1 size - arg5 + 1 put: (tmp1 at: arg5) ]asSDLRect  ^SDL_Rect newX: origin x rounded y: origin y rounded w: (corner x - origin x) rounded h: (corner y - origin y) roundedclone  ^selftestSubclass  | tmp1 |  (testEnvironment includesKey: #SubclassExample) ifTrue: [ (testEnvironment at: #SubclassExample) removeFromSystem ].  self deny: (testEnvironment includesKey: #SubclassExample).  tmp1 := Object subclass: #SubclassExample.  self assert: (testEnvironment includesKey: #SubclassExample).  self assert: (testEnvironment at: #SubclassExample) identicalTo: tmp1.  self assert: tmp1 category equals: self unclassifiedCategory.  self assert: tmp1 instVarNames equals: #().  tmp1 removeFromSystemtestDisplayString  self assert: Object new displayString equals: 'an Object'testAccessing  self     assert: timespan start equals: (DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0);     assert: timespan duration equals: (Duration hours: 100);     assert: timespan month equals: 3;     assert: timespan monthName equals: 'March';     assert: timespan monthAbbreviation equals: 'Mar'pointer  ^self pointerDoubleprintSeparatedBy: arg1 every: arg2 signed: arg3 base: arg4 on: arg5  | tmp1 |  tmp1 := self abs printStringBase: arg4.  self signBit = 1 ifTrue: [ arg5 nextPut: $- ] ifFalse: [ arg3 ifTrue: [ arg5 nextPut: $+ ] ].  1 to: tmp1 size do: [:arg6 |  arg5 nextPut: (tmp1 at: arg6).        (arg6 < tmp1 size and: [ (arg6 - tmp1 size) \\ arg2 = 0 ]) ifTrue: [ arg5 nextPut: arg1 ] ]squared  ^self class newFromNumber: super squared scale: scaledefaultAction  Smalltalk signalLowSpacecompiledBlock  ^startpcspotterSubclassesFor: arg1  < spotterOrder: 50>  arg1 listProcessor     title: 'All subclasses';     allCandidates: [ self allSubclasses ];     itemIcon: #systemIcon;     filter: GTFilterSubstringraiseWarning  ^self class raiseWarningticks: arg1 offset: arg2  self setJdn: (arg1 at: 1) seconds: (arg1 at: 2) nano: (arg1 at: 3) offset: arg2testIntegerReadsNotOkFromStream  self should: [ Integer readFrom: 'a23' readStream ] raise: Error.  self should: [ Integer readFrom: '-a23' readStream ] raise: Error.  self should: [ Integer readFrom: 'a3' readStream base: 8 ] raise: Error.  self should: [ Integer readFrom: '-a3' readStream base: 8 ] raise: Errorcomment: arg1 stamp: arg2  self instanceSide classComment: arg1 stamp: arg2asKeyCombination  ^KMSingleKeyCombination from: self asCharacterwriteXandY  x := 33.  y := 66genSend: arg1 numArgs: arg2  arg2 < 0 ifTrue: [ ^self outOfRangeError: 'numArgs' index: arg2 range: 0 to: 31 ].  arg1 < 0 ifTrue: [ (arg1 negated between: 176 and: 207) ifFalse: [ ^self outOfRangeError: 'special selector code' index: arg1 negated range: 176 to: 207 ].        stream nextPut: arg1 negated.        ^self ].  (arg1 < 16 and: [ arg2 < 3 ]) ifTrue: [ stream nextPut: 208 + (arg2 * 16) + arg1.        ^self ].  (arg1 < 32 and: [ arg2 < 8 ]) ifTrue: [ stream           nextPut: 131;           nextPut: (arg2 bitShift: 5) + arg1.        ^self ].  (arg1 < 64 and: [ arg2 < 4 ]) ifTrue: [ stream           nextPut: 134;           nextPut: (arg2 bitShift: 6) + arg1.        ^self ].  (arg1 < 256 and: [ arg2 < 32 ]) ifTrue: [ stream           nextPut: 132;           nextPut: arg2;           nextPut: arg1.        ^self ].  arg2 >= 32 ifTrue: [ ^self outOfRangeError: 'numArgs' index: arg2 range: 0 to: 31 ].  arg1 >= 256 ifTrue: [ ^self outOfRangeError: 'selector literal index' index: arg1 range: 0 to: 255 ]instVarNamed: arg1 put: arg2  ^self class slotNamed: arg1 ifFound: [:arg3 |  arg3 write: arg2 to: self ] ifNone: [ InstanceVariableNotFound signalFor: arg1 asString ]subclass: arg1 uses: arg2 layout: arg3 slots: arg4 classVariables: arg5 poolDictionaries: arg6 category: arg7  ^self classInstaller make: [:arg8 |  arg8           name: arg1;           superclass: self;           slots: arg4;           layoutClass: arg3;           sharedVariables: arg5;           sharedPools: arg6;           traitComposition: arg2 asTraitComposition;           classTraitComposition: arg2 asTraitComposition classComposition;           category: arg7 ]sends: arg1  ^selector == arg1setPreLoadDoItInMetacelloSpec: arg1  arg1 setPreLoadDoIt: (arg1 project valueHolderSpec           value: self;           yourself)testReadFrom  self should: [ (ScaledDecimal readFrom: '5.3') isKindOf: ScaledDecimal ] description: 'Reading a ScaledDecimal should answer a ScaledDecimal'.  self should: [ ((ScaledDecimal readFrom: '5.3') asScaledDecimal: 1) = (53 / 10 asScaledDecimal: 1) ] description: 'ScaledDecimal readFrom: should not use Float intermediate because it would introduce round off errors'initialize  super initialize.  self initialize: 4096highBit  ^self subclassResponsibilitytestWaitAndWaitTimeoutTogether  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Semaphore new.  tmp3 := [ tmp1 wait.  tmp2 := #wait ] fork.  tmp4 := [ tmp1 waitTimeoutMSecs: 50.  tmp2 := #waitTimeout ] fork.  (Delay forMilliseconds: 100) wait.  tmp1 signal.  [ tmp3 isTerminated and: [ tmp4 isTerminated ] ] whileFalse: [ (Delay forMilliseconds: 100) wait ].  self assert: tmp2 equals: #waitprintStringBase: arg1 length: arg2 padded: arg3  ^String streamContents: [:arg4 |  self printOn: arg4 base: arg1 length: arg2 padded: arg3 ]bitShiftPoint: arg1  x := x bitShift: arg1.  y := y bitShift: arg1definesClassVariable: arg1  ^self classVariables includes: arg1printOn: arg1 base: arg2  self isNaN ifTrue: [ ^arg1 nextPutAll: 'Float nan' ].  self isInfinite ifTrue: [ arg1 nextPutAll: 'Float infinity'.        ^self sign = -1 ifTrue: [ arg1 nextPutAll: ' negated' ] ].  self > 0.0 ifTrue: [ FloatPrintPolicy absPrint: self on: arg1 base: arg2 ] ifFalse: [ self signBit = 1 ifTrue: [ arg1 nextPut: $- ].        self = 0.0 ifTrue: [ arg1 nextPutAll: '0.0' ] ifFalse: [ FloatPrintPolicy absPrint: self negated on: arg1 base: arg2 ] ]rfvalueNoContextSwitch  < primitive: 221>  < metaLinkOptions: #(+ optionDisabledLink)>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  self primitiveFailedtestTerminationDuringUnwind  | tmp1 tmp2 tmp3 |  tmp1 := tmp2 := false.  tmp3 := [ [  ] ensure: [ tmp1 := true.        Processor yield.        tmp2 := true ] ] fork.  self deny: tmp1.  Processor yield.  self assert: tmp1.  self deny: tmp2.  tmp3 terminate.  self assert: tmp2asSpotterCandidateLink  ^GTSpotterCandidateLink value: selfkeyAtIdentityValue: arg1 ifAbsent: arg2  1 to: self basicSize do: [:arg3 |  arg1 == (array at: arg3) ifTrue: [ (self basicAt: arg3) ifNotNil: [:arg4 |  ^arg4 ] ] ].  ^arg2 valueresume  self resume: self defaultResumeValueasFloatPoint  self isFloatPoint ifTrue: [ ^self ].  ^x asFloat @ y asFloathash  ^origin hash bitXor: corner hashtestSecondsRoundTrip  | tmp1 tmp2 |  tmp1 := DateAndTime fromSeconds: 0.  tmp2 := DateAndTime fromSeconds: tmp1 asSeconds.  self assert: tmp1 equals: tmp2areasOutside: arg1  (self intersects: arg1) ifFalse: [ ^Array with: self ].  ^Array new: 4 streamContents: [:arg2 |  | tmp1 tmp2 |        arg1 origin y > origin y ifTrue: [ arg2 nextPut: (origin corner: corner x @ (tmp1 := arg1 origin y)) ] ifFalse: [ tmp1 := origin y ].        arg1 corner y < corner y ifTrue: [ arg2 nextPut: (origin x @ (tmp2 := arg1 corner y) corner: corner) ] ifFalse: [ tmp2 := corner y ].        arg1 origin x > origin x ifTrue: [ arg2 nextPut: (origin x @ tmp1 corner: arg1 origin x @ tmp2) ].        arg1 corner x < corner x ifTrue: [ arg2 nextPut: (arg1 corner x @ tmp1 corner: corner x @ tmp2) ] ]protocolOrganizer  ^protocolOrganizernewCallbackWithSignature: arg1 block: arg2 library: arg3  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     newCallbackWithSignature: arg1 block: arg2 library: arg3gtInspectorPresentationsFromPragmas: arg1 In: arg2 inContext: arg3  arg1 do: [:arg4 |  arg4 methodSelector numArgs = 0 ifTrue: [ | tmp1 |              tmp1 := self perform: arg4 methodSelector.              tmp1 glmPresentation cull: arg2 cull: arg3 cull: self ].        arg4 methodSelector numArgs = 1 ifTrue: [ thisContext object: self perform: arg4 methodSelector withArguments: {arg2} inClass: self class ].        arg4 methodSelector numArgs = 2 ifTrue: [ thisContext object: self perform: arg4 methodSelector withArguments: {arg2 .                     arg3} inClass: self class ] ]testIsPrivateOther  self checkCorrespondanceOf: #isPrivateOther: and: #CotestFloorLog  self assert: (100 floorLog: 10) equals: 2.  self assert: ((2 raisedTo: Float emax + 3) floorLog: 10) = (2 log * (Float emax + 3)) floor description: 'Integer>>floorLog: should not overflow'pushActiveContext  self push: selfhex  ^self asInteger hexpcRangeContextIsActive: arg1  | tmp1 |  tmp1 := pc ifNil: [ self method endPC ].  tmp1 := arg1 ifTrue: [ tmp1 ] ifFalse: [ tmp1 - 1 ].  ^self method rangeForPC: tmp1collect: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self basicSize.  tmp2 := self species new: tmp1.  tmp3 := 0.  1 to: tmp1 do: [:arg2 |  (tmp4 := self basicAt: arg2) notNil ifTrue: [ tmp2 basicAt: (tmp3 := tmp3 + 1) put: (arg1 value: tmp4) ] ].  tmp5 := self species new: tmp3.  tmp5 basicReplaceFrom: 1 to: tmp3 with: tmp2 startingAt: 1.  ^tmp5intersect: arg1 withCollection: arg2  ^arg1 ifNotEmpty: [ (self intersectValueLink: arg1 firstLink withCollection: arg2) ifNil: [ LinkedList new ] ifNotNil: [:arg3 |  LinkedList with: arg3 ] ]isVariable  | tmp1 |  tmp1 := self instSpec.  ^tmp1 >= 2 and: [ tmp1 <= 4 or: [ tmp1 >= 9 ] ]forbiddenSelectorsForMethodFinder  ^#()tempNamed: arg1 put: arg2  | tmp1 tmp2 |  tmp1 := self sourceNodeExecuted scope.  tmp2 := tmp1 lookupVar: arg1.  ^tmp2 writeFromContext: self scope: tmp1 value: arg2initializeTicker: arg1 suspendedDelaysHeap: arg2  super initializeTicker: arg1 suspendedDelaysHeap: arg2.  accessProtect := Semaphore forMutualExclusiontestDay  self assert: aTimespan day equals: jan01 daysourceNodeExecutedForPC: arg1  ^self subclassResponsibilityclassVariablesString  ^String streamContents: [:arg1 |  self classVarNames do: [:arg2 |  arg1 nextPutAll: arg2 ] separatedBy: [ arg1 space ] ]testWithRecursion  self should: [ self recursion ] notTakeMoreThanMilliseconds: 3& arg1  ^self bitAnd: arg1initialize  super initialize.  activeMethods := OrderedCollection newusesLocalPoolVarNamed: arg1  ^self sharedPools anySatisfy: [:arg2 |  arg2 usesClassVarNamed: arg1 ]setR: arg1 degrees: arg2  | tmp1 |  tmp1 := arg2 asFloat degreesToRadians.  x := arg1 asFloat * tmp1 cos.  y := arg1 asFloat * tmp1 sinsizePushSpecialLiteral: arg1  ^self sizeOpcodeSelector: #genPushSpecialLiteral: withArguments: {arg1}fuelAccept: arg1  ^arg1 visitMetaclass: selftestTwoComplementBitLogicWithCarry  self assert: ((2 to: 80) allSatisfy: [:arg1 |  ((2 raisedTo: arg1) negated bitAnd: (2 raisedTo: arg1) negated - 1) = (2 raisedTo: arg1 + 1) negated ])acceptsLoggingOfCompilation  ^self instanceSide acceptsLoggingOfCompilationsubclass: arg1 uses: arg2 layout: arg3 slots: arg4 classVariables: arg5 category: arg6  ^self subclass: arg1 uses: arg2 layout: arg3 slots: arg4 classVariables: arg5 poolDictionaries: '' category: arg6noteAddedSelector: arg1 meta: arg2  interpolateTo: arg1 at: arg2  ^self * (1 - arg2) + (arg1 * arg2)testDay  self assert: aDateAndTime day equals: 60.  self deny: aDateAndTime day equals: 29argument  ^args at: 1split: arg1 indicesDo: arg2  | tmp1 tmp2 |  tmp1 := 1.  tmp2 := tmp1.  tmp1 := arg1 indexOf: self startingAt: tmp1.  [ tmp1 > 0 ] whileTrue: [ arg2 value: tmp2 value: tmp1 - 1.        tmp1 := tmp1 + 1.        tmp2 := tmp1.        tmp1 := arg1 indexOf: self startingAt: tmp1 ].  arg2 value: tmp2 value: arg1 sizeincludesSharedPoolNamed: arg1  ^self sharedPools anySatisfy: [:arg2 |  arg2 name = arg1 ]gtDebuggerDoItBindings  ^(self method isDoIt and: [ self receiver isNil ]) ifTrue: [ self method literals select: [:arg1 |  arg1 class = WorkspaceVariable ] ] ifFalse: [ #() ]asTrueFraction  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  self isInfinite ifTrue: [ self error: 'Cannot represent infinity as a fraction' ].  self isNaN ifTrue: [ self error: 'Cannot represent Not-a-Number as a fraction' ].  tmp1 := (self basicAt: 1) bitShift: -20.  tmp2 := (tmp1 bitAnd: 16r800) = 0.  tmp3 := tmp1 bitAnd: 16r7FF.  tmp6 := (((self basicAt: 1) bitAnd: 16rFFFFF) bitShift: 32) + (self basicAt: 2).  (tmp3 = 0 and: [ tmp6 = 0 ]) ifTrue: [ ^0 ].  tmp5 := tmp3 = 0 ifTrue: [ tmp6 bitShift: 1 ] ifFalse: [ tmp6 bitOr: 16r0010000000000000 ].  tmp7 := tmp2 ifTrue: [ tmp5 ] ifFalse: [ tmp5 negated ].  tmp4 := 16r3FF + 52 - tmp3.  tmp4 negative ifTrue: [ tmp8 := tmp7 bitShift: tmp4 negated ] ifFalse: [ tmp9 := tmp5 lowBit - 1.        tmp4 := tmp4 - tmp9.        tmp4 <= 0 ifTrue: [ tmp9 := tmp9 + tmp4.              tmp8 := tmp7 bitShift: tmp9 negated ] ifFalse: [ tmp8 := Fraction numerator: (tmp7 bitShift: tmp9 negated) denominator: (1 bitShift: tmp4) ] ].  ^tmp8testSchedule  self assert: aSchedule schedule size equals: 2.  self assert: aSchedule schedule first equals: 1 days.  self assert: aSchedule schedule second equals: 6 daysasDelay  ^Delay forDuration: selftestFloor  self assert: 1.0 floor equals: 1.  self assert: 1.1 floor equals: 1.  self assert: -2.0 floor equals: -2.  self assert: -2.1 floor equals: -3acceptSettings: arg1  ^arg1 visitClass: selflogMethodSource: arg1 forMethod: arg2 inCategory: arg3 withStamp: arg4  arg2 putSource: arg1 class: self category: arg3 withStamp: arg4 priorMethod: (self compiledMethodAt: arg2 selector ifAbsent: [  ])method  ^selftestSlotNames  self assert: Point slotNames equals: #(x y)testDynamicVariableBlockReturnValue  | tmp1 |  tmp1 := TestDynamicVariable value: 10 during: [ TestDynamicVariable value + 1 ].  self assert: tmp1 equals: 11testIntersectionWithIncluded  self assert: (aTimespan intersection: anIncludedTimespan) equals: anIncludedTimespantestYearsDo  | tmp1 |  tmp1 := Array with: (Year starting: (DateAndTime year: 2003 day: 7) duration: 365 days).  self assert: aTimespan years contents equals: tmp1 contentstestNew  self should: [ Context new: 5 ] raise: Error.  [ Context new: 5 ] ifError: [:arg1 |  arg1 = 'Error: Contexts must only be created with newForMethod:' ].  [ Context new ] ifError: [:arg1 |  arg1 = 'Error: Contexts must only be created with newForMethod:' ].  [ Context basicNew ] ifError: [:arg1 |  arg1 = 'Error: Contexts must only be created with newForMethod:' ]value: arg1 value: arg2  | tmp1 |  tmp1 := self receiver.  (self ensureReceiver: tmp1) ifFalse: [ ^nil ].  ^tmp1 perform: selector with: arg1 with: arg2sqrt  | tmp1 tmp2 tmp3 |  tmp1 := self asFloat.  tmp2 := tmp1 sqrt.  tmp2 isInfinite ifFalse: [ tmp3 := tmp2 truncated.        tmp3 squared = self ifTrue: [ ^tmp3 ] ].  tmp1 >= Float maxExactInteger asFloat squared ifTrue: [ tmp3 := self sqrtFloor.        tmp3 squared = self ifTrue: [ ^tmp3 ].        tmp3 := (self * 4) sqrtFloor.        ^(tmp3 // 2 + (tmp3 \\ 2)) asFloat ].  ^tmp2epoch  ^Date year: 1901 month: 1 day: 1testEnumerating  | tmp1 |  tmp1 := OrderedCollection new.  month weeksDo: [:arg1 |  tmp1 add: arg1 start ].  0 to: 4 do: [:arg2 |  tmp1 remove: (Week starting: ('29 June 1998' asDate addDays: arg2 * 7)) start ].  self assertEmpty: tmp1roundTo: arg1  ^self class nanoSeconds: (self asNanoSeconds roundTo: arg1 asNanoSeconds)combinesWith: arg1  | tmp1 |  codes ifNil: [ ^false ].  tmp1 := Compositions at: combined charCode ifAbsent: [ ^false ].  tmp1 at: arg1 charCode ifAbsent: [ ^false ].  ^truedeclareClassVariables: arg1  | tmp1 |  tmp1 := false.  (self classVariables reject: [:arg2 |  arg1 includes: arg2 ]) do: [:arg3 |  self removeClassVarNamed: arg3 name interactive: false ].  (arg1 reject: [:arg3 |  self classVariables includes: arg3 ]) do: [:arg3 |  (self innerBindingOf: arg3 key) ifNotNil: [ DuplicatedVariableError new                 variable: arg3 name;                 signal: arg3 name , ' is defined elsewhere'.              tmp1 := true ] ].  arg1 notEmpty ifTrue: [ self classPool: self classPool.        arg1 do: [:arg3 |  self classPool declareVariable: arg3 from: Undeclared ] ].  ^tmp1tearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  super tearDownat: arg1  ^self basicAt: arg1byteSizeOfInstance  < primitive: 181 error: ec>  self isVariable ifTrue: [ ^self byteSizeOfInstanceOfSize: 0 ].  self primitiveFailedgenReturnTop  stream nextPut: 124testIfNotNilIfNil  < haltOrBreakpointForTesting>  self should: [ nil ifNotNil: [  ] ifNil: [ self error ] ] raise: ErrorweakSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 package: arg5  ^self weakSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 category: arg5daysInYear  ^start daysInYeartestSeconds  self assert: aDateAndTime seconds equals: 0testmethodsAccessingPoolVariables  | tmp1 |  tmp1 := ChronologyConstants methodsAccessingPoolVariables.  self assert: (tmp1 includes: (Duration >> #asNanoSeconds) methodReference).  self deny: (tmp1 includes: (ClassTest >> #testSharedPoolOfVarNamed) methodReference)fileOutLocalMethodsInCategory: arg1 on: arg2  | tmp1 |  arg2 cr.  tmp1 := self selectorsToFileOutCategory: arg1.  tmp1 do: [:arg3 |  self printMethodChunk: arg3 on: arg2 ].  ^selfallProtocols  ^self protocolOrganizer allProtocolssubclasses  self isMetaclassOfClassOrNil ifTrue: [ ^#() ].  ^self instanceSide subclasses collect: [:arg1 |  arg1 classSide ]doNop  parseTree  ^self methodClass compiler     source: self sourceCode;     failBlock: [ ^self decompile ];     parsespotterPreviewCodeIn: arg1  < spotterPreview: 10>  arg1 pharoMethod     title: [ self name ];     display: #definition;     smalltalkClass: [ nil ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'callcc: arg1  ^Continuation currentDo: arg1testLessThan  self assert: aDateAndTime < (aDateAndTime + '1:00:00:00').  self assert: aDateAndTime + -1 < aDateAndTimetestRaisedToIntegerWithFloats  self     assert: (2.0 raisedToInteger: 0) equals: 1.0;     assert: (2.0 raisedToInteger: 1) equals: 2.0;     assert: (2.0 raisedToInteger: 4) equals: 16.0;     assert: (0.0 raisedToInteger: 0) equals: 1.0;     assert: (0.0 raisedToInteger: 2) equals: 0.0;     assert: (2.0 raisedToInteger: -1) equals: 0.5;     assert: (2.0 raisedToInteger: -4) equals: 0.0625.  self     assert: (-3.0 raisedTo: 0) equals: 1.0;     assert: (-3.0 raisedTo: 1) equals: -3.0;     assert: (-3.0 raisedTo: 2) equals: 9.0;     assert: (-3.0 raisedTo: 3) equals: -27.0;     assert: (-2.0 raisedTo: -2) equals: 0.25;     assert: (-2.0 raisedTo: -3) equals: -0.125.  self should: [ 0.0 raisedTo: -1 ] raise: ZeroDividetestCategories  | tmp1 |  tmp1 := self organization categories.  self assert: tmp1 notEmptycritical: arg1  ^[ self enter.  arg1 value ] ensure: [ self exit ]asSeconds  ^secondsmax  ^self x max: self ytestIsRootInEnvironment  self assert: ProtoObject isRootInEnvironment.  self deny: Object isRootInEnvironmentjavascriptOn: arg1  arg1 nextPutAll: 'new Date('.  #(year javascriptMonthIndex dayOfMonth hour minute second) do: [:arg2 |  arg1 javascript: (self perform: arg2) ] separatedBy: [ arg1 nextPut: $, ].  arg1 nextPut: $)testEmptyTemplate  | tmp1 |  tmp1 := LargeNegativeInteger new: 4.  self assert: tmp1 size equals: 4.  self assert: tmp1 printString equals: '-0'.  self assert: tmp1 normalize equals: 0testReentrantBlockOldEnvironmentWithBlockArguement  | tmp1 |  tmp1 := self constructFibonacciBlockWithBlockArgumentInDeadFrame.  self should: [ tmp1 value: 0 value: tmp1 ] raise: self classForTestResult error.  self assert: (tmp1 value: 1 value: tmp1) equals: 1.  self assert: (tmp1 value: 2 value: tmp1) equals: 1.  self assert: (tmp1 value: 3 value: tmp1) equals: 2.  self assert: (tmp1 value: 4 value: tmp1) equals: 3.  self assert: (tmp1 value: 5 value: tmp1) equals: 5.  self assert: (tmp1 value: 6 value: tmp1) equals: 8testSuppressInformUsingStringMatchOptions  self should: [ ([ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingMessages: #('Should not see this message or this test failed!')) isNil ].  self should: [ ([ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingMessages: #('not see this message')) isNil ].  self should: [ ([ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingMessages: #('*message*failed#')) isNil ]species  < primitive: 111>  ^self classtestDoWith  | tmp1 |  tmp1 := 0.  aTimespan do: [:arg1 |  tmp1 := tmp1 + 1 ] with: (Timespan starting: aDate duration: 7 days).  self assert: tmp1 equals: 13insertSender: arg1  | tmp1 |  tmp1 := arg1 bottomContext.  tmp1 privSender: self sender.  self privSender: arg1.  ^tmp1approvedSelectorsForMethodFinder  ^#(isNil)isEmptyCategoryNamed: arg1  ^(self protocolOrganizer protocolNamed: arg1) isEmptybasicOrganization  ^organizationhours  ^(seconds rem: SecondsInDay) quo: SecondsInHourprintOn: arg1  self printOn: arg1 base: 10asStringWithCommasSigned  ^String streamContents: [:arg1 |  self printWithCommasSignedOn: arg1 ]byteAt: arg1 put: arg2  self error: 'You can''t store in a SmallInteger'isWeak  ^self instSpec = 4beActiveDuring: arg1  CurrentExecutionEnvironment activate: self for: arg1gtInspectorIcon  ^niladdModelItemsToWindowMenu: arg1  second  ^self localSeconds \\ 60testNaN4  | tmp1 |  tmp1 := Dictionary new.  tmp1 at: Float nan put: #NaN.  self deny: (tmp1 includes: Float nan)montgomeryTimes: arg1 modulo: arg2 mInvModB: arg3  < primitive: 'primMontgomeryTimesModulo' module: 'LargeIntegers'>  ^niljsonOn: arg1  arg1 string: (String with: self)asSeconds  ^start asSecondssourceMatchesBytecodeAt: arg1  | tmp1 tmp2 |  tmp1 := self compiledMethodAt: arg1.  tmp2 := self compiler     source: (self sourceCodeAt: arg1);     class: self;     failBlock: [ ^false ];     compiledMethodTrailer: tmp1 trailer;     compile.  arg1 == tmp2 selector ifFalse: [ self error: 'selector changed!!' ].  ^tmp2 = tmp1testMiddleOf  self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) equals: (Timespan starting: '12-31-1900' asDate duration: 2 days)deprecatedMethod6  testIsLeapYear  self assert: aDateAndTime isLeapYearasInteger  < primitive: 171>  ^self primitiveFailedtestAsSeconds  self assert: (Duration nanoSeconds: 1000000000) asSeconds equals: 1.  self assert: (Duration seconds: 1) asSeconds equals: 1.  self assert: aDuration asSeconds equals: 93784.  self assert: 1 asSeconds equals: (Duration seconds: 1).  self assert: (1 / 2) asSeconds equals: (Duration milliSeconds: 500)genNop  stream nextPut: 95testIsOpenPunctuation  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isOpenPunctuation: tmp2) equals: (tmp1 isOpenPunctuation: tmp2) ]testIsAbstract  self deny: Behavior isAbstract.  self deny: Behavior class isAbstract.  self deny: ClassDescription isAbstract.  self deny: ClassDescription class isAbstract.  self deny: Class isAbstract.  self deny: Class class isAbstract.  self deny: Object isAbstract.  self deny: Object class isAbstracttestBecomeForwardIdentityHash  | tmp1 tmp2 tmp3 |  tmp1 := 'ab' copy.  tmp2 := 'cd' copy.  tmp3 := tmp1 identityHash.  tmp1 becomeForward: tmp2.  self     assert: tmp1 identityHash equals: tmp3;     assert: tmp2 identityHash equals: tmp3asYear  ^selfprimitiveErrorVariableName  self isPrimitive ifTrue: [ self pragmas do: [:arg1 |  | tmp1 tmp2 |              ((tmp1 := arg1 selector keywords) first = 'primitive:' and: [ (tmp2 := tmp1 indexOf: 'error:') > 0 ]) ifTrue: [ ^arg1 argumentAt: tmp2 ] ] ].  ^nilhandleProcessTerminationOfWaitingContext: arg1  ^arg1 method == (Semaphore compiledMethodAt: #critical:) ifTrue: [ arg1 home ] ifFalse: [ arg1 ]printShowingDecimalPlaces: arg1  ^String new: arg1 + 10 streamContents: [:arg2 |  self printOn: arg2 showingDecimalPlaces: arg1 ]isMonthPattern  ^char = $mabbreviation: arg1  abbreviation := arg1protocols  ^self organization categories copytestOr  self assert: (true or: [ 'alternativeBlock' ])fuelNew  ^self basicNewreleaseTo: arg1  | tmp1 tmp2 |  tmp1 := self.  [ tmp1 == nil or: [ tmp1 == arg1 ] ] whileFalse: [ tmp2 := tmp1 sender.        tmp1 singleRelease.        tmp1 := tmp2 ]run  | tmp1 |  tmp1 := Processor activeProcess.  [ tmp1 suspend.  self resume ] forkAt: Processor highestPriorityisFraction  ^falseveryDeepCopyWith: arg1  bytesCount  self subclassResponsibilityadaptToInteger: arg1 andSend: arg2  ^self subclassResponsibilityremove: arg1 uptoLast: arg2  ^arg2 ifNotEmpty: [ | tmp1 |        tmp1 := Continuation currentDo: [:arg3 |  self remove: arg1 uptoLastValueLink: arg2 firstLink continuation: arg3 ].        LinkedList with: tmp1 ]testSimpleEnsureTestWithNotification  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithNotification)testStartStop  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := Stopwatch new.  tmp2 := DateAndTime now.  (Delay forMilliseconds: 10) wait.  tmp1     activate;     activate.  (Delay forMilliseconds: 10) wait.  tmp3 := DateAndTime now.  self     deny: tmp1 isSuspended;     assert: tmp1 isActive;     assert: tmp1 timespans size equals: 1;     assert: tmp2 <= tmp1 start;     assert: tmp1 start <= tmp3.  (Delay forMilliseconds: 10) wait.  tmp4 := DateAndTime now.  (Delay forMilliseconds: 10) wait.  tmp1     suspend;     suspend.  (Delay forMilliseconds: 10) wait.  tmp5 := DateAndTime now.  self     assert: tmp1 isSuspended;     deny: tmp1 isActive;     assert: tmp1 timespans size equals: 1;     assert: (tmp1 end between: tmp4 and: tmp5);     assert: tmp4 <= tmp1 end;     assert: tmp1 end <= tmp5testPrintOn  self assert: (String streamContents: [:arg1 |  aTimespan printOn: arg1 ]) equals: 'a Timespan(2005-01-01T00:00:00+00:00D7:00:00:00)'printHMSOn: arg1  self printHMSOn: arg1 separatedBy: $:completeTo: arg1  self suspendedContext == arg1 ifTrue: [ ^arg1 ].  ^self complete: (self calleeOf: arg1)spotterTraitUsersFor: arg1  < spotterOrder: 20>  self isTrait ifFalse: [ ^self ].  arg1 listProcessor     title: 'Users';     allCandidates: [ self traitUsers asArray ];     itemIcon: #systemIcon;     filter: GTFilterSubstringrectangle: arg1  ^Rectangle point: self point: arg1test32bitConversion  #(16r0 16r80000000 16r1 16r12345 16r801FEDCB 16r7FFFFF 16r800000 16r468ACDEF 16rCABD1234 16r7F7FFFFF 16r7F800000 16rFF800000) do: [:arg1 |  self assert: (Float fromIEEE32Bit: arg1) asIEEE32BitWord equals: arg1 ]sortCategories  | tmp1 tmp2 tmp3 |  tmp1 := self categories select: [:arg1 |  (arg1 findString: 'private' startingAt: 1 caseSensitive: false) = 1 ].  tmp2 := self categories copyWithoutAll: tmp1.  tmp3 := tmp2 asSortedCollection asOrderedCollection     addAll: tmp1;     asArray.  self categories: tmp3willJumpIfFalse  ^self method encoderClass isBranchIfFalseAt: pc in: self methodtestPreviousByName  self assert: (january23rd2004 previous: #Friday) equals: '2004-01-16' asDatetestDoublePassOuter  self assertSuccess: (ExceptionTester new runTest: #doublePassOuterTest)testAsUTC  self assert: aDateAndTime asUTC equals: aDateAndTimespotterPreviewIn: arg1 inContext: arg2  | tmp1 |  tmp1 := Pragma allNamed: #spotterPreview: from: self class to: Object sortedUsing: [:arg3 :arg4 |  (arg3 argumentAt: 1) < (arg4 argumentAt: 1) ].  tmp1 do: [:arg5 |  (arg5 methodSelector findTokens: $:) size = 1 ifTrue: [ self perform: arg5 methodSelector with: arg1 ].        (arg5 methodSelector findTokens: $:) size = 2 ifTrue: [ self perform: arg5 selector with: arg1 with: arg2 ].        arg1 hasSubbricks ifTrue: [ ^self ] ]testBigReceiverInexactSqrt  | tmp1 tmp2 |  tmp1 := 100 factorial squared + 1.  self assert: tmp1 asFloat isInfinite.  tmp2 := tmp1 sqrt.  self assert: tmp2 isFloat.  self deny: tmp2 isInfinite.  self assert: tmp2 equals: 100 factorial asFloat.  self assert: (tmp2 successor asFraction squared - tmp1) abs >= (tmp2 asFraction squared - tmp1) abs.  self assert: (tmp2 predecessor asFraction squared - tmp1) abs >= (tmp2 asFraction squared - tmp1) abstestNanoSecond  self assert: aDateAndTime nanoSecond equals: 0parse: arg1 expectedSize: arg2  | tmp1 tmp2 |  tmp1 := inputStream next: arg2.  tmp2 := tmp1 asInteger.  (tmp2 isNil or: [ tmp1 size ~= arg2 ]) ifTrue: [ DateError signal: ' Expect a two digit ' , arg1 , ', got ' , tmp1 ].  ^tmp2r  ^(self dotProduct: self) sqrtallSuperclassesIncluding: arg1  | tmp1 |  self class == ProtoObject class ifTrue: [ ^OrderedCollection new ].  ^self superclass == arg1 ifTrue: [ OrderedCollection with: arg1 ] ifFalse: [ tmp1 := self superclass allSuperclassesIncluding: arg1.        tmp1 addFirst: self superclass.        tmp1 ]testSourceNodeOptimized  | tmp1 |  tmp1 := [:arg1 |  [ arg1 atEnd ] whileTrue: [ 1 + 2 ] ].  self assert: tmp1 sourceNode printString equals: 'RBBlockNode([ :ctx | [ ctx atEnd ] whileTrue: [ 1 + 2 ] ])'doesNotUnderstand: arg1  < debuggerCompleteToSender>  | tmp1 tmp2 tmp3 |  (tmp3 := self findUndeclaredVariableIn: thisContext sender sourceNodeExecuted) ifNil: [ ^super doesNotUnderstand: arg1 ].  (tmp1 := VariableNotDeclared new)     message: arg1;     variableNode: tmp3;     receiver: self.  tmp2 := tmp1 signal.  ^tmp1 reachedDefaultHandler ifTrue: [ arg1 sentTo: self ] ifFalse: [ tmp2 ]testLeftmost  | tmp1 |  tmp1 := #a ~~> nil ~~> nil ~~> (4 ~~> (Link new ~~> (1 ~~> nil ~~> nil))).  self assert: (self printStringOfTree: tmp1) equals: '(((#a)) 4 () (1))'.  self assert: (self leftmost: #isSymbol tree: tmp1) equals: #a.  self assert: (self leftmost: #isInteger tree: tmp1) equals: 4.  self assert: (self leftmost: [:arg1 |  arg1 = 1 ] tree: tmp1) equals: 1.  self assert: (self leftmost: #isNil tree: tmp1) equals: nil.  self assert: (self leftmost: [:arg1 |  arg1 = 5 ] tree: tmp1) equals: nilexampleStore  < sampleInstance>  instVar1 := 1.  instVar1 := 2.  ^thisContext copytestDegreeCosForExceptionalValues  self assert: Float nan degreeCos isNaN.  self assert: Float infinity degreeCos isNaN.  self assert: Float infinity negated degreeCos isNaNtestValueWithArguments  self shouldnt: [ aBlockContext valueWithArguments: #() ] raise: ArgumentsCountMismatch.  self should: [ aBlockContext valueWithArguments: #(1) ] raise: ArgumentsCountMismatch withExceptionDo: [:arg1 |  self assert: arg1 expectedArgumentsCount equals: 0.        self assert: arg1 calledArgumentsCount equals: 1 ].  self should: [ [:arg2 |  3 + 4 ] valueWithArguments: #(1 2) ] raise: ArgumentsCountMismatch withExceptionDo: [:arg1 |  self assert: arg1 expectedArgumentsCount equals: 1.        self assert: arg1 calledArgumentsCount equals: 2 ]assert: arg1 classAndValueEquals: arg2  self assert: arg1 class equals: arg2 class.  self assert: arg1 equals: arg2inspectInExternalWindow  ^GTInspector new openInExternalWindowOn: selftruncated  < primitive: 51>  (self isInfinite or: [ self isNaN ]) ifTrue: [ self error: 'Cannot truncate this number' ].  self abs < 2.0e16 ifTrue: [ | tmp1 tmp2 tmp3 tmp4 |        tmp1 := (SmallInteger maxVal bitShift: -1) + 1.        tmp2 := tmp1 asFloat.        tmp3 := self quo: tmp2.        tmp4 := self - (tmp3 asFloat * tmp2).        ^tmp3 * tmp1 + tmp4 truncated ] ifFalse: [ ^self asTrueFraction ]testprintSubclassesOnLevelFilterB  | tmp1 tmp2 tmp3 |  tmp1 := '	ExampleForTest1 #()		ExampleForTest12 #()'.  tmp2 := String new: tmp1 size.  tmp3 := ReadWriteStream on: tmp2.  ExampleForTest1 printSubclassesOn: tmp3 level: 1 filter: {ExampleForTest1 .         ExampleForTest12 .         ExampleForTest112}.  self assert: tmp2 equals: tmp1definitionForNautilus  self deprecated: 'Use #definition instead.' on: '2019-05-14' in: #Pharo8 transformWith: '`@receiver definitionForNautilus' -> '`@receiver definition'.  ^self definitiontestYearDay  self assert: aDateAndTime equals: (DateAndTime year: 1970 day: 1)isClass  ^falsefirstPrecodeCommentFor: arg1  | tmp1 |  (#(Comment Definition Hierarchy) includes: arg1) ifTrue: [ ^nil ].  tmp1 := self compiledMethodAt: arg1 asSymbol ifAbsent: [ ^nil ].  ^tmp1 ast firstPrecodeCommentprintOn: arg1  arg1 nextPutAll: 'a Year ('.  self start year printOn: arg1.  arg1 nextPutAll: ')'testIntersectionWithSeparate  self assert: (aTimespan intersection: aDisjointTimespan) isNil.  self deny: (aTimespan intersection: anOverlappingTimespan) isNil.  self assert: (aTimespan intersection: anIncludedTimespan) equals: anIncludedTimespantestByWeekNumberInCurrentYear  week := Week week: 2.  self assert: week year asYear equals: Year currenttestIfNotNilIfNil  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := ProtoObject new.  tmp2 := Object new.  tmp4 := false.  tmp5 := false.  tmp1 ifNotNil: [ tmp4 := true ] ifNil: [ tmp5 := true ].  self assert: tmp4 equals: true.  self assert: tmp5 equals: false.  tmp4 := false.  tmp5 := false.  tmp1 ifNotNil: [:arg1 |  tmp4 := true ] ifNil: [ tmp5 := true ].  self assert: tmp4 equals: true.  self assert: tmp5 equals: false.  tmp4 := false.  tmp5 := false.  self assert: (tmp1 ifNotNil: [:arg1 |  arg1 == tmp1 ] ifNil: [ false ]).  self assert: (tmp1 ifNotNil: [ tmp2 ] ifNil: [ false ]) identicalTo: tmp2.  self assert: (tmp1 ifNotNil: [:arg1 |  tmp2 ] ifNil: [ false ]) identicalTo: tmp2.  tmp4 := false.  tmp5 := false.  tmp3 := [ tmp4 := true ].  tmp1 ifNotNil: tmp3 ifNil: [ tmp5 := true ].  self assert: tmp4 equals: true.  self assert: tmp5 equals: false.  tmp4 := false.  tmp5 := false.  tmp3 := [:arg1 |  tmp4 := true ].  tmp1 ifNotNil: tmp3 ifNil: [ tmp5 := true ].  self assert: tmp4 equals: true.  self assert: tmp5 equals: false.  tmp3 := [:arg1 |  arg1 == tmp1 ].  self assert: (tmp1 ifNotNil: tmp3 ifNil: [ false ]).  tmp3 := [ tmp2 ].  self assert: (tmp1 ifNotNil: tmp3 ifNil: [ false ]) identicalTo: tmp2.  tmp3 := [:arg1 |  tmp2 ].  self assert: (tmp1 ifNotNil: tmp3 ifNil: [ false ]) identicalTo: tmp2removeElement: arg1  | tmp1 |  tmp1 := self categoryOfElement: arg1.  self protocolOrganizer removeMethod: arg1.  self notifyOfChangedSelector: arg1 from: tmp1 to: (self categoryOfElement: arg1)sideNearestTo: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := arg1 x - self left.  tmp2 := self right - arg1 x.  tmp3 := arg1 y - self top.  tmp4 := self bottom - arg1 y.  tmp5 := tmp1.  tmp6 := #left.  tmp2 < tmp5 ifTrue: [ tmp5 := tmp2.        tmp6 := #right ].  tmp3 < tmp5 ifTrue: [ tmp5 := tmp3.        tmp6 := #top ].  tmp4 < tmp5 ifTrue: [ tmp5 := tmp4.        tmp6 := #bottom ].  ^tmp6isSpecLayout  ^falsetestLessThan  self assert: aTimespan < aDisjointTimespan.  self deny: anIncludedTimespan < aTimespanprivateSetCorner: arg1  corner := arg1toFinalizeSend: arg1 to: arg2 with: arg3  self == arg2 ifTrue: [ self error: 'I cannot finalize myself' ].  self == arg3 ifTrue: [ self error: 'I cannot finalize myself' ].  ^self finalizationRegistry add: self executor: (ObjectFinalizer new receiver: arg2 selector: arg1 argument: arg3)genPushClosureCopyNumCopiedValues: arg1 numArgs: arg2 jumpSize: arg3  | tmp1 tmp2 tmp3 tmp4 |  (arg3 < 0 or: [ arg3 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'block size' index: arg3 range: 0 to: 65535 ].  (arg1 < 0 or: [ arg1 > 127 ]) ifTrue: [ ^self outOfRangeError: 'num copied' index: arg1 range: 0 to: 127 ].  (arg2 < 0 or: [ arg2 > 127 ]) ifTrue: [ ^self outOfRangeError: 'num args' index: arg2 range: 0 to: 127 ].  tmp4 := tmp1 := 0.  (tmp3 := arg2) > 7 ifTrue: [ tmp4 := arg2 // 8.        tmp3 := tmp3 \\ 8 ].  (tmp2 := arg1) > 7 ifTrue: [ tmp4 := tmp4 + (arg1 // 8 * 16).        tmp2 := tmp2 \\ 8 ].  tmp4 ~= 0 ifTrue: [ self genUnsignedSingleExtendA: tmp4.        tmp1 := 1 ].  arg3 > 255 ifTrue: [ tmp1 := tmp1 + 1.        self genUnsignedSingleExtendB: arg3 // 256 ].  stream     nextPut: 250;     nextPut: (tmp1 bitShift: 6) + (tmp2 bitShift: 3) + tmp3;     nextPut: (arg3 bitAnd: 16rFF)testByteAt  | tmp1 |  tmp1 := -114605103402541699037609980192546360895434064385.  1 to: 20 do: [:arg1 |  | tmp2 |        tmp2 := tmp1 byteAt: arg1.        self assert: arg1 equals: tmp2 ]basicIdentityHash  < primitive: 75>  self primitiveFailedclearFlag  self objectAt: 1 put: (self header bitAnd: (1 << 29) bitInvert)storeOn: arg1 base: arg2 length: arg3 padded: arg4  | tmp1 |  tmp1 := self negative ifTrue: [ '-' ] ifFalse: [ String new ].  arg2 = 10 ifFalse: [ tmp1 := tmp1 , arg2 printString , 'r' ].  self print: (self abs printStringBase: arg2) on: arg1 prefix: tmp1 length: arg3 padded: arg4simulate_vmMilliseconds: arg1  ticker simulate_vmMilliseconds: arg1testCullCullCullCull  [  ] cull: 1 cull: 2 cull: 3 cull: 4.  [:arg1 |   ] cull: 1 cull: 2 cull: 3 cull: 4.  [:arg1 :arg2 |   ] cull: 1 cull: 2 cull: 3 cull: 4.  [:arg1 :arg2 :arg3 |   ] cull: 1 cull: 2 cull: 3 cull: 4.  [:arg1 :arg2 :arg3 :arg4 |   ] cull: 1 cull: 2 cull: 3 cull: 4.  self should: [ [:arg1 :arg2 :arg3 :arg4 :arg5 |   ] cull: 1 cull: 2 cull: 3 cull: 4 ] raise: Error.  self assert: ([ 0 ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 0.  self assert: ([:arg1 |  arg1 ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 1.  self assert: ([:arg1 :arg2 |  arg2 ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 2.  self assert: ([:arg1 :arg2 :arg3 |  arg3 ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 3.  self assert: ([:arg1 :arg2 :arg3 :arg4 |  arg4 ] cull: 1 cull: 2 cull: 3 cull: 4) equals: 4cleanup  self checkOwnerProcess.  self critical: [ self privateCleanup ]testMutateObjectLastInstVarWithManyVars  | tmp1 tmp2 |  tmp1 := WriteBarrierStub new.  tmp1 beReadOnlyObject.  tmp2 := [ tmp1 var10: #test ] on: ModificationForbidden do: [:arg1 |  arg1 ].  self assert: tmp2 fieldIndex equals: 10rfMinus: arg1  < metaLinkOptions: #(+ optionDisabledLink)>  < primitive: 2>  ^super - arg1removeFromChanges  self class environment at: #ChangeSet ifPresent: [:arg1 |  arg1 current removeClassAndMetaClassChanges: self ]packAsDoubleToArity: arg1  | tmp1 |  tmp1 := self.  1 to: arg1 do: [:arg2 |  tmp1 := tmp1 pointerDouble ].  ^tmp1isSuspended  ^myList isNil or: [ myList isEmpty ]messageText  ^String streamContents: [:arg1 |  self shouldTransform ifTrue: [ arg1 nextPutAll: 'Automatic deprecation code rewrite: ' ].        arg1           nextPutAll: 'The method ';           nextPutAll: self deprecatedMethodName;           nextPutAll: ' called from ';           nextPutAll: self sendingMethodName;           nextPutAll: ' has been deprecated. ';           nextPutAll: explanationString ]testPositive  self assert: (Duration nanoSeconds: 0) positive.  self assert: aDuration positive.  self deny: aDuration negated positive/ arg1  | tmp1 |  arg1 isInteger ifTrue: [ tmp1 := self digitDiv: arg1 neg: self negative ~~ arg1 negative.        (tmp1 at: 2) = 0 ifTrue: [ ^(tmp1 at: 1) normalize ] ifFalse: [ ^(Fraction numerator: self denominator: arg1) reduced ] ].  ^arg1 adaptToInteger: self andSend: #/closeTo: arg1 precision: arg2  arg1 isNumber ifFalse: [ ^[ self = arg1 ] ifError: [ false ] ].  self = 0.0 ifTrue: [ ^arg1 abs < arg2 ].  arg1 = 0 ifTrue: [ ^self abs < arg2 ].  ^self = arg1 asFloat or: [ (self - arg1) abs / (self abs max: arg1 abs) < arg2 ]hasSourcePointer  ^self trailer hasSourcePointertestHandlingWithSeveralExclusionsAndExceptionSetsHandling  | tmp1 tmp2 |  tmp1 := false.  tmp2 := [ ZeroDivide signalWithDividend: 1.  2 ] on: Error - MessageNotUnderstood - Warning do: [:arg1 |  tmp1 := true.        arg1 return ].  self     assert: tmp1;     assert: tmp2 isNil.  tmp1 := false.  tmp2 := [ ZeroDivide signalWithDividend: 1.  2 ] on: Error - (MessageNotUnderstood , Warning) do: [:arg1 |  tmp1 := true.        arg1 return ].  self     assert: tmp1;     assert: tmp2 isNiltestCeiling  self assert: 2 ceiling equals: 2.  self assert: -2 ceiling equals: -2.  self assert: 2.1 ceiling equals: 3.  self assert: -2.1 ceiling equals: -2gtInspectorVariableNodesIn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GTInspector indexableDisplayLimit.  tmp2 := 1.  tmp3 := self basicSize.  tmp4 := tmp1 min: tmp3.  tmp5 := tmp1 max: tmp3 - tmp1.  tmp2 to: tmp4 do: [:arg2 |  arg1 add: (GTInspectorIndexedNode hostObject: self index: arg2) ].  tmp5 + 1 to: tmp3 do: [:arg2 |  arg1 add: (GTInspectorIndexedNode hostObject: self index: arg2) ].  arg1 addAll: (self class allSlots collect: [:arg3 |  GTInspectorSlotNode hostObject: self slot: arg3 ])testIsOtherNumber  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isOtherNumber: tmp2) equals: (tmp1 isOtherNumber: tmp2) ]pc  ^pchumanReadableSIByteSize  ^String streamContents: [:arg1 |  self humanReadableSIByteSizeOn: arg1 ]isValueHolder  ^falseallSelectorsBelow: arg1  | tmp1 |  tmp1 := IdentitySet new.  self withAllSuperclassesDo: [:arg2 |  arg2 = arg1 ifTrue: [ ^tmp1 ] ifFalse: [ arg2 selectorsDo: [:arg3 |  tmp1 add: arg3 ] ] ].  ^tmp1variableWordSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 category: arg4  ^self variableWordSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4adaptToNumber: arg1 andSend: arg2  ^arg1 @ arg1 perform: arg2 with: selftestAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)metaLinkOptions  ^{(#methodDict -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}genCallPrimitive: arg1  (arg1 < 1 or: [ arg1 > 65535 ]) ifTrue: [ self outOfRangeError: 'primitive index' index: arg1 range: 1 to: 65535 ].  stream     nextPut: 248;     nextPut: (arg1 bitAnd: 255);     nextPut: (arg1 bitShift: -8)printOn: arg1  arg1 nextPut: $(.  x printOn: arg1.  arg1 nextPut: $@.  (y notNil and: [ y negative ]) ifTrue: [ arg1 space ].  y printOn: arg1.  arg1 nextPut: $)testWeeks  self assert: (Duration weeks: 1) days equals: 7isOverriding  ^(self origin superclass ifNotNil: [:arg1 |  arg1 lookupSelector: self selector ]) notNilasMessageSend  ^MessageSend receiver: self receiver selector: selector arguments: (Array withAll: self arguments)asDosTimestamp  ^start asDosTimestampjulianDayNumber  ^julianDayNumber + self julianDayOffsetuppercase  ^self asUppercaseisMemberOf: arg1  ^self class == arg1testDayNames  self assert: Week dayNames equals: #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday)testSeconds  self assert: aDateAndTime seconds equals: 0hasTemporaryVariableNamed: arg1  ^self tempNames includes: arg1milliseconds  ^nanos quo: NanosInMillisecondbasicIdentityHash  < primitive: 171>  ^self primitiveFailedstonOn: arg1  self class isVariable ifTrue: [ arg1 error: 'custom #stonOn: implementation needed for variable/indexable class' ] ifFalse: [ arg1 writeObject: self ]testParsingYPatternWithFiveDigits  self assertReading: '2.11.10000' as: 'd.mm.y' equals: (Date year: 10000 month: 11 day: 2)testReturnsAsManyWaitsAsSignalsReceived  | tmp1 tmp2 tmp3 |  tmp2 := tmp3 := false.  tmp1 := Semaphore new.  [ tmp1 wait.  tmp2 := true.  tmp1 wait.  tmp3 := true ] fork.  Processor yield.  self deny: tmp2.  tmp1 signal.  Processor yield.  self assert: tmp2.  self deny: tmp3.  tmp1 signal.  Processor yield.  self assert: tmp3testIfNil  | tmp1 tmp2 tmp3 |  tmp3 := false.  tmp1 := ProtoObject new.  tmp1 ifNil: [ tmp3 := true ].  self assert: (tmp1 ifNil: [ nil ]) identicalTo: tmp1.  self assert: tmp3 equals: false.  tmp3 := false.  tmp2 := [ tmp3 := true ].  tmp1 ifNil: tmp2.  tmp2 := [ nil ].  self assert: (tmp1 ifNil: tmp2) identicalTo: tmp1.  self assert: tmp3 equals: falsetestSqrt  self assert: (SmallInteger maxVal + 1) sqrt equals: (SmallInteger maxVal + 1) asFloat sqrtsizePushThisContext  ^self sizeOpcodeSelector: #genPushThisContext withArguments: #()gtInspectorVariableNodesIn: arg1  arg1 addAll: (self literals collectWithIndex: [:arg2 :arg3 |  GTInspectorDynamicNode hostObject: self label: 'literal' , arg3 asString value: arg2 ]).  self initialPC to: self size do: [:arg4 |  arg1 add: (GTInspectorDynamicNode hostObject: self label: 'bc ' , arg4 asString value: (self at: arg4)) ]sender  ^senderwarningTest  self log: 'About to signal warning.'.  Warning signal: 'Ouch'.  self log: 'Warning signal handled and resumed.'testNormalize  self assert: SmallInteger maxVal + 1 - 1 identicalTo: SmallInteger maxVal.  self assert: SmallInteger maxVal + 3 - 6 identicalTo: SmallInteger maxVal - 3.  self should: SmallInteger minVal - 1 + 1 == SmallInteger minVal.  self assert: SmallInteger minVal - 3 + 6 identicalTo: SmallInteger minVal + 3argumentNames  ^self sourceNode argumentNamestransform  | tmp1 tmp2 tmp3 |  self shouldTransform ifFalse: [ ^self signal ].  self rewriterClass ifNil: [ ^self signal ].  tmp3 := self contextOfSender method.  tmp3 isDoIt ifTrue: [ ^self ].  tmp1 := self contextOfSender sourceNodeExecuted.  RecursionStopper during: [ tmp2 := self rewriterClass new replace: rule key with: rule value.        (tmp2 executeTree: tmp1) ifFalse: [ ^self signal ].        tmp1 replaceWith: tmp2 tree.        Author useAuthor: 'AutoDeprecationRefactoring' during: [ tmp3 origin compile: tmp3 ast formattedCode classified: tmp3 protocol ].        Log ifNotNil: [:arg1 |  arg1 add: self ].        self logTranscript ]valueSupplyingAnswers: arg1  ^self on: ProvideAnswerNotification do: [:arg2 |  | tmp1 |        tmp1 := arg2 messageText withSeparatorsCompacted.        arg1 detect: [:arg3 |  tmp1 = arg3 first or: [ (tmp1 includesSubstring: arg3 first caseSensitive: false) or: [ (arg3 first match: tmp1) or: [ (String includesSelector: #matchesRegex:) and: [ [ tmp1 matchesRegex: arg3 first ] on: Error do: [:arg4 |  false ] ] ] ] ] ] ifFound: [:arg5 |  arg2 resume: arg5 second ] ifNone: [ | tmp2 |              tmp2 := ProvideAnswerNotification signal: arg2 messageText.              tmp2 ifNil: [ arg2 resume ] ifNotNil: [ arg2 resume: tmp2 ] ] ]isSelfEvaluating  ^self class == RectangledoublePassOuterTest  [ [ [ self doSomething.  MyTestNotification signal.  self doSomethingExceptional ] on: MyTestNotification do: [:arg1 |  arg1 pass.        self doSomethingExceptional ] ] on: MyTestNotification do: [:arg1 |  arg1 outer.        self doSomethingElse ] ] on: MyTestNotification do: [:arg1 |  self doYetAnotherThing.        arg1 resume ]isPassedTest  ^self methodClass isTestCase and: [ self methodClass methodPassed: self selector ]| arg1  ^self bitOr: arg1initialize: arg1  references := IdentityDictionary new: arg1subclass: arg1 uses: arg2 slots: arg3 classVariables: arg4 category: arg5  ^self subclass: arg1 uses: arg2 layout: self classLayout class slots: arg3 classVariables: arg4 poolDictionaries: '' category: arg5testDayMonthYearDo  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg3 ]) equals: 2004.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg2 ]) equals: 2.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg1 ]) equals: 29drawReverseFrame: arg1  Display border: arg1 width: 2 rule: Form reverse fillColor: Color graycloseTo: arg1  arg1 isFloat ifTrue: [ ^arg1 closeTo: self asFloat ].  ^[ self = arg1 ] ifError: [ false ]sizePushLiteral: arg1  ^self sizeOpcodeSelector: #genPushLiteral: withArguments: {arg1}tearDown  Week startDay: restoredStartDay.  DateAndTime localTimeZone: restoredTimeZone.  super tearDowntestFirstDayOfMonth  self deny: aDateAndTime firstDayOfMonth equals: 1.  self assert: aDateAndTime firstDayOfMonth equals: 32ffiCall: arg1 library: arg2 options: arg3  < ffiCalloutTranslator>  | tmp1 |  tmp1 := arg2 asFFILibrary.  ^(tmp1 calloutAPIClass inUFFIContext: thisContext)     convention: self ffiCallingConvention;     options: tmp1 options , arg3;     function: arg1 library: tmp1possibleVariablesFor: arg1 continuedFrom: arg2  ^self instanceSide possibleVariablesFor: arg1 continuedFrom: arg2hasSubclasses  ^self subclasses isNotEmptysafeArcCos  (self between: -1.0 and: 1.0) ifTrue: [ ^self arcCos ] ifFalse: [ ^self sign arcCos ]testSecondsAcrossTimeZones  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := '1/15/2012 0000+00:00' asDateAndTime.  tmp4 := TimeZone abbreviated: 'UTC'.  self useTimeZone: 'PDT' during: [:arg1 |  tmp2 := tmp1 asSeconds.        DateAndTime localTimeZone: tmp4.        tmp3 := DateAndTime fromSeconds: tmp2.        self assert: tmp1 equals: tmp3 ]assertSuccess: arg1  self should: [ arg1 suiteLog first endsWith: 'succeeded' ]gtFilter  ^GTFilterBlock gtFiltertestPrintOn  self assert: (String streamContents: [:arg1 |  aDateAndTime printOn: arg1 ]) equals: '1901-01-01T00:00:00+00:00'.  self assert: (String streamContents: [:arg1 |  aTimeZone printOn: arg1 ]) equals: 'a TimeZone(ETZ)'testBecome  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 'ab' copy.  tmp2 := 'cd' copy.  tmp3 := tmp1.  tmp4 := tmp2.  tmp1 become: tmp2.  self     assert: tmp1 equals: 'cd';     assert: tmp2 equals: 'ab';     assert: tmp3 equals: 'cd';     assert: tmp4 equals: 'ab'testForkAtHigherPriority  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := [ tmp1 := true ].  tmp3 := tmp2 forkAt: Processor activeProcess priority + 1.  self assert: tmp1weakSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 category: arg5  ^self weakSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: '' category: arg5// arg1  ^arg1 isNumber ifTrue: [ self class nanoSeconds: (self asNanoSeconds // arg1) asInteger ] ifFalse: [ self asNanoSeconds // arg1 asDuration asNanoSeconds ]fuelAccept: arg1  ^self class == Rectangle ifTrue: [ arg1 visitRectangle: self ] ifFalse: [ super fuelAccept: arg1 ]isString  ^falsetestWaitTimeDuration  self assert: (Semaphore new wait: 50 milliSeconds) identicalTo: true.  self assert: (Semaphore new signal wait: 50 milliSeconds) identicalTo: falseextent  ^corner - originspotterActDefault: arg1  arg1 exit.  self spotterActDefaultserializeOn: arg1  arg1 encodeUint32: self asIntegertestNoon  self assert: aDateAndTime noon equals: '1980-01-01T12:00:00+00:00' asDateAndTimetestPrintOnBaseShowRadix  self assert: (String streamContents: [:arg1 |  123 printOn: arg1 base: 10 showRadix: false ]) equals: '123'.  self assert: (String streamContents: [:arg1 |  123 printOn: arg1 base: 10 showRadix: true ]) equals: '10r123'.  self assert: (String streamContents: [:arg1 |  123 printOn: arg1 base: 8 showRadix: false ]) equals: '173'.  self assert: (String streamContents: [:arg1 |  123 printOn: arg1 base: 8 showRadix: true ]) equals: '8r173'right  ^corner xvalueAt: arg1  | tmp1 tmp2 tmp3 |  tmp1 := Processor activeProcess.  tmp3 := tmp1 priority.  tmp1 priority: arg1.  tmp2 := self ensure: [ tmp1 priority: tmp3 ].  arg1 > tmp3 ifTrue: [ Processor yield ].  ^tmp2setSourcePointer: arg1  | tmp1 tmp2 |  tmp1 := CompiledMethodTrailer new sourcePointer: arg1.  tmp2 := self copyWithTrailerBytes: tmp1.  (self trailer class == tmp1 class and: [ self size = tmp2 size ]) ifTrue: [ | tmp3 |        tmp3 := self endPC + 1.        self replaceFrom: tmp3 to: self size with: tmp2 startingAt: tmp3 ] ifFalse: [ self becomeForward: tmp2 ].  ^selfdefaultAction  UIManager default systemNotificationDefaultAction: selflink: arg1 toClassVariable: arg2  self shouldNotImplementtestTempNamedPut  | tmp1 |  tmp1 := 1.  self assert: (thisContext tempNamed: 'oneTemp') equals: tmp1.  thisContext tempNamed: 'oneTemp' put: 2.  self assert: (thisContext tempNamed: 'oneTemp') equals: 2withArgs: arg1 executeMethod: arg2  < primitive: 188>  self primitiveFailedtestConverting  self assert: month asDate equals: '1 July 1998' asDatetestSubclasses  SystemNavigation new allClassesDo: [:arg1 |  self assert: (arg1 superclass isNil or: [ arg1 superclass subclasses includes: arg1 ]) description: arg1 name , ' is not in ' , (arg1 superclass ifNotNil: [:arg2 |  arg2 name ] ifNil: [ 'nil' ]) , '''s subclasses' ]nextObject  self shouldNotImplementasSeconds  ^secondsasYear  ^Year year: selfcanDiscardEdits  self dependents do: [:arg1 |  arg1 canDiscardEdits ifFalse: [ ^false ] ] without: self.  ^trueminutes  ^Duration minutes: selftimingPrioritySignalExpired  beingWaitedOn := false.  process suspendingList == delaySemaphore ifTrue: [ expired := true.        process           suspend;           resume ]nowTick  < primitive: 240>  self primitiveFailedshortStack  ^String streamContents: [:arg1 |  (self stackOfSize: 10) do: [:arg2 |  arg1                 print: arg2;                 cr ] ]meta  ^KMModifier meta + selftestByWeekNumber  week := Week year: 2013 week: 1.  self assert: week start equals: (DateAndTime year: 2012 month: 12 day: 31).  self assert: week start dayOfWeek equals: 2.  week := Week year: 2013 week: 32.  self assert: week start equals: (DateAndTime year: 2013 month: 8 day: 5).  self assert: week start dayOfWeek equals: 2.  week := Week year: 2013 week: 52.  self assert: week start equals: (DateAndTime year: 2013 month: 12 day: 23).  self assert: week start dayOfWeek equals: 2.  week := Week year: 2014 week: 1.  self assert: week start equals: (DateAndTime year: 2013 month: 12 day: 30).  self assert: week start dayOfWeek equals: 2deepCopy  ^x deepCopy @ y deepCopytestMinute  self assert: aDateAndTime minute equals: 0testNoon  self assert: aDateAndTime noon equals: '2004-02-29T12:00:00+02:00' asDateAndTimetestAsSeconds  self assert: aDateAndTime asSeconds equals: 2492985600testHeapForwards  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Delay forMilliseconds: 1.  tmp2 := Delay forMilliseconds: 2.  tmp3 := Delay forMilliseconds: 3.  tmp4 := Delay forMilliseconds: 4.  scheduler schedule: tmp1.  scheduler schedule: tmp2.  scheduler schedule: tmp3.  scheduler schedule: tmp4.  self assert: suspendedDelaysHeap removeFirstOrNil equals: tmp2.  self assert: suspendedDelaysHeap removeFirstOrNil equals: tmp3.  self assert: suspendedDelaysHeap removeFirstOrNil equals: tmp4.  self assert: suspendedDelaysHeap removeFirstOrNil equals: nilvalueWithArguments: arg1  < primitive: 208>  | tmp1 |  numArgs ~= arg1 size ifTrue: [ self numArgsError: arg1 size ].  false ifTrue: [ tmp1 := self asContextWithSender: thisContext sender.        1 to: numArgs do: [:arg2 |  tmp1 at: arg2 put: (arg1 at: arg2) ].        thisContext privSender: tmp1 ] ifFalse: [ self primitiveFailed ]at: arg1 put: arg2  ^self at: arg1 putLink: (self linkOf: arg2 ifAbsent: [ arg2 asLink ])testSourceNodeExecuted  | tmp1 |  tmp1 := thisContext sender sender sourceNodeExecuted.  self assert: tmp1 selector equals: #performTestreceiver  ^receivertestIncludes  self assert: (aSchedule includes: (DateAndTime year: 2003 month: 6 day: 15 hour: 20 minute: 30 second: 0 offset: 0 hours))testDaysInYear  self assert: (Year daysInYear: 2000) equals: 366.  self assert: (Year daysInYear: 2001) equals: 365.  self assert: (Year daysInYear: 2004) equals: 366.  self assert: (Year daysInYear: 2100) equals: 365.  self assert: (Year daysInYear: 2003) equals: 365name  ^name ifNil: [ self hash asString forceTo: 10 paddingStartWith: $  ]valueWithPossibleArguments: arg1  ^self valueWithEnoughArguments: arg1rem: arg1  ^self - ((self quo: arg1) * arg1)quadrantOf: arg1  ^x <= arg1 x ifTrue: [ y < arg1 y ifTrue: [ 1 ] ifFalse: [ 4 ] ] ifFalse: [ y <= arg1 y ifTrue: [ 2 ] ifFalse: [ 3 ] ]removeSelector: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self compiledMethodAt: arg1 ifAbsent: [ ^nil ].  tmp3 := tmp1 origin.  tmp2 := self whichCategoryIncludesSelector: arg1.  self organization removeElement: arg1.  super removeSelector: arg1.  SystemAnnouncer uniqueInstance methodRemoved: tmp1 protocol: tmp2 origin: tmp3abs  genBranchPopFalseLong: arg1  | tmp1 |  (arg1 < 0 or: [ arg1 > 32767 ]) ifTrue: [ ^self outOfRangeError: 'distance' index: arg1 range: 0 to: 32767 ].  tmp1 := (arg1 < 0 or: [ arg1 > 255 ]) ifTrue: [ self genUnsignedSingleExtendB: (arg1 bitShift: -8).        arg1 bitAnd: 255 ] ifFalse: [ arg1 ].  stream     nextPut: 239;     nextPut: tmp1addSubclass: arg1  testCompiledMethodAsString  thisContext method asStringremoveProtocolIfEmpty: arg1  (self protocolNamed: arg1) ifNotNil: [:arg2 |  (arg2 isEmpty and: [ arg2 canBeRemoved ]) ifTrue: [ self removeProtocol: arg2 ] ]currentHand  ^ActiveHand ifNil: [ self currentWorld primaryHand ]pointerFloat  ^(ByteArray new: FFIFloat32 externalTypeSize)     floatAt: 1 put: self;     yourselfclassifyAll: arg1 under: arg2  arg1 do: [:arg3 |  self classify: arg3 under: arg2 ]compiledBlock: arg1  startpc := arg1centeredBeneath: arg1  ^self align: self topCenter with: arg1 bottomCenterexitAndWaitInQueue: arg1 maxMilliseconds: arg2  | tmp1 tmp2 |  tmp1 := queuesMutex critical: [ arg1 addLast: Semaphore new ].  self exit.  arg2 ifNil: [ tmp1 wait ] ifNotNil: [ tmp2 := MonitorDelay signalLock: tmp1 afterMSecs: arg2 inMonitor: self queue: arg1.        tmp1 wait.        tmp2 unschedule ].  self entertestIsModifierSymbol  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isModifierSymbol: tmp2) equals: (tmp1 isModifierSymbol: tmp2) ]debug: arg1  self schedulingProcess == Delay schedulingProcess ifTrue: [ ^self ].  debug := arg1testInstSize  self assert: Object instSize equals: 0.  self assert: Point instSize equals: 2.  self assert: Metaclass instSize equals: 6testIsDigit  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isDigit: tmp2) equals: (tmp1 isDigit: tmp2) ]readMe  translatedAndSquishedToBeWithin: arg1  ^(self translatedToBeWithin: arg1) squishedWithin: arg1removeKey: arg1  ^self removeKey: arg1 ifAbsent: [ self error: 'Property not found' ]testIsUsed  self assert: Object isUsed.  self assert: Object class isUsedtestSemaphoreNoTimeout  | tmp1 tmp2 |  tmp1 := Semaphore new.  [ | tmp3 |  tmp2 := [ tmp3 := Delay timeoutSemaphore: tmp1 afterMSecs: 1000.  tmp1 wait ] newProcess.  tmp2 priority: Processor highIOPriority.  tmp2 resume.  tmp3 unschedule.  self deny: tmp2 isTerminated ] ensure: [ tmp1 signal ].  self assert: tmp2 isTerminatedremoveMethod: arg1  self deprecated: 'Use #removeMethodSelector: instead' transformWith: '`@receiver removeMethod: `@arg' -> '`@receiver removeMethodSelector: `@arg'.  ^self removeMethodSelector: arg1negative  ^falsegtDebuggerRetrieveVariableValuePairs  | tmp1 |  tmp1 := SortedCollection sortBlock: [:arg1 :arg2 |  arg1 key < arg2 key ].  tmp1 addAll: (self receiver class allSlots collect: [:arg3 |  GTInspectorSlotNode hostObject: self receiver slot: arg3 ]).  tmp1 addAll: self gtInspectorTempNodes.  tmp1 addAll: (self gtDebuggerDoItBindings collect: [:arg4 |  (GTInspectorDynamicNode hostObject: self label: arg4 key value: arg4 value)                 variableTag: 'temp';                 yourself ]).  ^tmp1 asOrderedCollection     addFirst: (GTInspectorSelfNode hostObject: self receiver);     addLast: (GTInspectorDynamicNode hostObject: self label: 'thisContext' value: self);     addLast: (GTInspectorDynamicNode hostObject: self label: 'stack top' value: (self stackPtr > 0 ifTrue: [ self top ]));     yourselfclassesThatImplementAllOf: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  arg1 do: [:arg2 |  (self includesSelector: arg2) ifTrue: [ tmp1 add: arg2 ] ].  tmp1 isEmpty ifTrue: [ ^self subclasses inject: Array new into: [:arg3 :arg4 |  arg3 , (arg4 classesThatImplementAllOf: arg1) ] ] ifFalse: [ tmp2 := arg1 copyWithoutAll: tmp1.        tmp2 isEmpty ifTrue: [ ^Array with: self ].        ^self subclasses inject: Array new into: [:arg3 :arg4 |  arg3 , (arg4 classesThatImplementAllOf: tmp2) ] ]fromRectangle: arg1  self setTop: arg1 top left: arg1 left bottom: arg1 bottom right: arg1 rightinsetOriginBy: arg1 cornerBy: arg2  ^Rectangle origin: origin + arg1 corner: corner - arg2testFirstWeekdayOfMonthYear  self assert: (Date firstWeekdayOfMonth: 'January' year: 2004) equals: 5min  ^self x min: self yisHeap  ^falsetestParsingPatternWithTrailingCharacterFails  self assertReading: '04.02.2013trailing' as: 'd.m.y' raise: DateErrororganizedClass  ^organizedClassmetaLevelScope  ^self isInstanceSide ifTrue: [ ClyInstanceSideScope ] ifFalse: [ ClyClassSideScope ]setTimestampInMetacelloVersion: arg1  arg1 setTimestamp: selfrename: arg1  self name: arg1settingStoreOn: arg1  ^self storeOn: arg1ceiling  self isIntegerPoint ifTrue: [ ^self ].  ^x ceiling @ y ceilingtestParsingYYPatternWithWrongNumberOrDigitsShouldFails  self assertReading: '02.11.3' as: 'dd.mm.yy' raise: DateError.  self assertReading: '02.11.113' as: 'dd.mm.yy' raise: DateErrortestIsLetterNumber  self checkCorrespondanceOf: #isLetterNumber: and: #NlsetDelay: arg1 forSemaphore: arg2  millisecondDelayDuration := arg1 asInteger.  millisecondDelayDuration < 0 ifTrue: [ self error: 'delay times cannot be negative' ].  delaySemaphore := arg2.  beingWaitedOn := falsecleanUp: arg1  ^self cleanUpisActive: arg1  < metaLinkOptions: #(+ optionDisabledLink)>  ^level = arg1 or: [ level == nil ]asSmallAngleDegrees  | tmp1 |  tmp1 := self \\ 360.  tmp1 > 180 ifTrue: [ tmp1 := tmp1 - 360 ].  ^tmp1testNoon  self assert: aDateAndTime noon equals: '1970-01-01T12:00:00+00:00' asDateAndTimetestErrorCodeNotFoundIndexed  | tmp1 tmp2 tmp3 |  Smalltalk vm isRunningCog ifFalse: [ ^self ].  tmp2 := self indexedBasicAt: 100.  tmp1 := Context sender: nil receiver: nil method: Object >> #at: arguments: #(10).  tmp3 := tmp1     push: nil;     push: 500;     doPrimitive: 60 method: self class >> #indexedBasicAt: receiver: self args: #(100).  self assert: tmp3 isArray.  self assert: tmp3 size equals: 2.  self assert: Context primitiveFailToken first identicalTo: tmp3 first.  self assert: tmp2 equals: tmp3 secondraisedToInteger: arg1 modulo: arg2  arg1 = 0 ifTrue: [ ^1 ].  arg1 even ifTrue: [ ^(self raisedToInteger: arg1 // 2 modulo: arg2) squared \\ arg2 ] ifFalse: [ ^self * (self raisedToInteger: arg1 - 1 modulo: arg2) \\ arg2 ]variableByteSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 category: arg5  ^self variableByteSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: '' category: arg5= arg1  ^self subclassResponsibilityaddSelectorTo: arg1  | tmp1 |  (tmp1 := self selectorToSendOrSelf) == self ifFalse: [ arg1 add: tmp1 ]evaluate: arg1 onBehalfOf: arg2  | tmp1 |  tmp1 := effectiveProcess.  effectiveProcess := arg2.  ^arg1 ensure: [ effectiveProcess := tmp1 ]isText  ^falseodd  ^(self bitAnd: 1) = 1irPrimitive  | tmp1 tmp2 |  tmp1 := IRPrimitive new num: (tmp2 := self primitive).  (tmp2 = 117 or: [ tmp2 = 120 ]) ifTrue: [ tmp1 spec: (self literalAt: 1) ].  ^tmp1unload  method: arg1 pc: arg2  sender := arg1.  pc := arg2isDoIt  ^falsetestExactNthRoot  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 8.0s1.  tmp4 := tmp1 raisedTo: 1 / 3.  self assert: tmp4 equals: 2.  self assert: (tmp4 class = tmp1 class and: [ tmp4 scale = tmp1 scale ]).  tmp2 := 0.001s3.  tmp3 := tmp2 raisedTo: 1 / 3.  self assert: tmp3 * 10 equals: 1.  self assert: (tmp3 class = tmp2 class and: [ tmp3 scale = tmp2 scale ])privHandlerContext  ^handlerContextreciprocal  ^self class newFromNumber: super reciprocal scale: scaletestRounded  self assert: 0 rounded equals: 0.  self assert: 1 rounded equals: 1.  self assert: (1 / 2) rounded equals: 1.  self assert: (1 / 2 - Float epsilon) rounded equals: 0charCode  ^self asInteger bitAnd: 4194303notEmpty  ^self basicSize > 0months  | tmp1 |  tmp1 := OrderedCollection new: 12.  self monthsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1 asArray>= arg1  < primitive: 6>  ^super >= arg1testOffset  | tmp1 tmp2 |  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 1 hours.  tmp2 := tmp1 offset: 1 hour.  self assert: tmp1 equals: tmp2.  self assert: tmp1 localSeconds equals: tmp2 localSeconds.  tmp2 := tmp1 offset: -1 hour.  self assert: tmp1 equals: tmp2.  self deny: tmp1 localSeconds identicalTo: tmp2 localSeconds.  tmp2 := tmp1 offset: -2 hour.  self assert: tmp1 equals: tmp2.  self deny: tmp1 localSeconds identicalTo: tmp2 localSecondsusesUndeclares  (UndeclaredVariable inheritsFrom: LiteralVariable) ifTrue: [ self literalsDo: [:arg1 |  arg1 class == UndeclaredVariable ifTrue: [ ^true ].              (arg1 isBlock not and: [ arg1 value isBehavior and: [ arg1 value isObsolete ] ]) ifTrue: [ ^true ] ] ] ifFalse: [ self literalsDo: [:arg1 |  (arg1 class == Association and: [ arg1 key notNil and: [ (arg1 value isKindOf: Slot) not ] ]) ifTrue: [ ^true ] ] ].  ^falsebeWritableObject  ^self setIsReadOnlyObject: falsehashMultiply  < primitive: 159>  | tmp1 |  tmp1 := self bitAnd: 16383.  ^16r260D * tmp1 + ((16r260D * (self bitShift: -14) + (16r0065 * tmp1) bitAnd: 16383) * 16384) bitAnd: 16r0FFFFFFFname: arg1  name := arg1 asSymboloffset: arg1  offset := arg1removeProperty: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := self propertyAt: arg1 ifAbsent: [ ^arg2 value ].  self penultimateLiteral: (self penultimateLiteral copyWithout: (Association key: arg1 value: tmp1)).  ^tmp1spotterClassInstanceVariablesFor: arg1  < spotterOrder: 25>  self isTrait ifTrue: [ ^self ].  arg1 listProcessor     title: 'Class instance variables';     allCandidates: [ self class classLayout allSlots ];     itemName: [:arg2 |  arg2 name asString ];     filter: GTFilterSubstringmethodSelector  ^method selectortestHasLiteralSuchThat  self deny: (Object >> #yourself hasLiteralSuchThat: [:arg1 |  arg1 == #yourself ]).  self assert: (Object >> #halt hasLiteralSuchThat: [:arg1 |  arg1 == #now ])testHash  self assert: aDateAndTime hash equals: DateAndTime new hashtestReadTimeZoneOffsetRFC822  self assert: (DateAndTime readTimezoneOffsetFrom: '+0530' readStream) printString equals: '0:05:30:00'testHeapBackwards  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Delay forMilliseconds: 1.  tmp2 := Delay forMilliseconds: 2.  tmp3 := Delay forMilliseconds: 3.  tmp4 := Delay forMilliseconds: 4.  scheduler schedule: tmp4.  scheduler schedule: tmp3.  scheduler schedule: tmp2.  scheduler schedule: tmp1.  self assert: suspendedDelaysHeap removeFirstOrNil equals: tmp2.  self assert: suspendedDelaysHeap removeFirstOrNil equals: tmp3.  self assert: suspendedDelaysHeap removeFirstOrNil equals: tmp4.  self assert: suspendedDelaysHeap removeFirstOrNil equals: nilprintOn: arg1  arg1 nextPut: $(.  numerator printOn: arg1.  arg1 nextPut: $/.  denominator printOn: arg1.  arg1 nextPut: $)brickValue: arg1 withEnoughArguments: arg2  ^arg1testTicksOffset  self assert: aDateAndTime equals: (aDateAndTime ticks: #(2453065 48780 0) offset: DateAndTime localOffset)sendsAnySelectorOf: arg1  (self localSendsAnySelectorOf: arg1) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:arg2 |  arg2 sendsAnySelectorOf: arg1 ]printHexByteOn: arg1  (self between: 0 and: 255) ifTrue: [ | tmp1 tmp2 tmp3 |        tmp1 := self bitShift: -4.        tmp2 := self bitAnd: 15.        tmp3 := '0123456789ABCDEF'.        arg1           nextPut: (tmp3 at: tmp1 + 1);           nextPut: (tmp3 at: tmp2 + 1) ] ifFalse: [ self error: 'byte value between 0 and 255 expected' ]leftmost: arg1 tree: arg2 continuation: arg3  ^(arg2 isNotNil and: [ arg2 isMemberOf: ValueLink ]) ifTrue: [ | tmp1 |        tmp1 := arg2 value.        (tmp1 isKindOf: Link) ifTrue: [ self leftmost: arg1 tree: tmp1 continuation: arg3 ] ifFalse: [ (arg1 value: tmp1) ifTrue: [ arg3 value: tmp1 ] ].        self leftmost: arg1 tree: arg2 nextLink continuation: arg3 ] ifFalse: [ nil ]testWholeMilliseconds  self assert: 0 seconds wholeMilliseconds equals: 0.  self assert: 1 second wholeMilliseconds equals: 0.  self assert: 1002003004 nanoSeconds wholeMilliseconds equals: 2first  ^self firstLink valuesignalLock: arg1 inQueue: arg2  queuesMutex critical: [ arg1 signal.        arg2 remove: arg1 ifAbsent: [  ] ]addSelector: arg1 withMethod: arg2 notifying: arg3  self deprecated: 'Please use #addSelector:withMethod: instead' transformWith: '`@receiver addSelector: `@statements1 withMethod: `@statements2 notifying: `@statements3' -> '`@receiver addSelector: `@statements1 withMethod: `@statements2'.  ^self addSelector: arg1 withMethod: arg2meridianAbbreviation  ^self asTime meridianAbbreviationtraceCr: arg1  self trace: arg1.  Transcript crprintFrequenceOn: arg1  self frequency printOn: arg1 showingDecimalPlaces: 3.  arg1 << ' per second'ticks  | tmp1 |  tmp1 := self days.  ^Array with: tmp1 with: seconds - (tmp1 * SecondsInDay) with: nanosslotsNeedFullDefinition  ^self slots anySatisfy: [:arg1 |  arg1 needsFullDefinition ]timingPrioritySignalExpired  beingWaitedOn := false.  delaySemaphore signalsin  ^self asFloat sincopyFrom: arg1  commentRemoteString := arg1 commentRemoteString.  commentStamp := arg1 commentStamp.  arg1 protocols do: [:arg2 |  arg2 methodSelectors do: [:arg3 |  protocolOrganizer classify: arg3 inProtocolNamed: arg2 name ] ]receiver  ^receiverencodeOn: arg1  arg1 print: self greaseStringprintOn: arg1 showingDecimalPlaces: arg2  | tmp1 tmp2 tmp3 |  arg2 <= 0 ifTrue: [ ^self rounded printOn: arg1 ].  tmp1 := 10 raisedToInteger: arg2.  tmp2 := self roundTo: tmp1 reciprocal.  tmp2 negative ifTrue: [ arg1 nextPut: $- ].  tmp2 := tmp2 abs.  tmp2 integerPart truncated printOn: arg1.  arg1 nextPut: $..  tmp3 := (tmp2 fractionPart * tmp1) truncated.  tmp3 printOn: arg1 base: 10 length: arg2 padded: trueschedule: arg1  < haltOrBreakpointForTesting>  debug ifTrue: [ self halt ].  arg1 beingWaitedOn ifTrue: [ ^self error: 'This Delay has already been scheduled.' ].  delayToStart := arg1.  timingSemaphore signal.  debug ifTrue: [ self halt ]shallowCopy  ^self - 0.0propertyAt: arg1 ifAbsentPut: arg2  ^self propertyAt: arg1 ifAbsent: [ self propertyAt: arg1 put: arg2 value ]selectorsInProtocol: arg1  | tmp1 |  tmp1 := Set withAll: (self organization listAtCategoryNamed: arg1).  ^tmp1 asArray sorttestRounded  self assert: (1999 / 1000s2) printString equals: '2.00s2'.  self assert: (-1999 / 1000s2) printString equals: '-2.00s2'indexedBasicAt: arg1  < primitive: 60 error: code>  ^codeifNil: arg1 ifNotNil: arg2  ^arg1 valueffiCall: arg1  < ffiCalloutTranslator>  self ffiCall: arg1 library: self ffiLibrarycopyStack  ^self copyTo: nilifFalse: arg1 ifTrue: arg2  ^arg2 valueprotocolOfElement: arg1  ^self categoryOfElement: arg1canBeRenamed  ^falsedateClass  ^DatenumArgs  ^(self header bitShift: -24) bitAnd: 16r0FtestAsDuration  self assert: aDateAndTime asDuration equals: 0 asDurationtestMinute  self assert: aDateAndTime minute equals: 33testSimpleResignalAs  self assertSuccess: (ExceptionTester new runTest: #simpleResignalAsTest)extendBy: arg1  ^arg1 asMargin extendRectangle: selfglamourValueWithArgs: arg1  self selector isUnary ifTrue: [ ^self value ].  self selector numArgs = arg1 size ifTrue: [ ^self valueWithArguments: arg1 ].  self selector numArgs > arg1 size ifTrue: [ ^self valueWithArguments: arg1 , (Array new: self selector numArgs - arg1 size) ].  ^self valueWithArguments: (arg1 copyFrom: 1 to: self selector numArgs)testYearMonthDayHourMinuteSecondNanosSecondOffset  self assert: aDateAndTime equals: (DateAndTime year: 1970 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours).  self assert: (DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours) + (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) equals: (DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)startpc  ^startpcactivate  self isSuspended ifTrue: [ self timespans add: (Timespan starting: DateAndTime now duration: Duration zero).        self state: #active ]allSelectorsToTestInMethodFinderWithArity: arg1  ^self allSelectorsToTestInMethodFinder select: [:arg2 |  arg2 numArgs = arg1 ]innerCompiledBlocksDo: arg1  1 to: self numLiterals - 1 do: [:arg2 |  | tmp1 |        tmp1 := self objectAt: arg2 + 1.        (tmp1 isMemberOf: CompiledBlock) ifTrue: [ arg1 value: tmp1 ] ]testObject: arg1 initialState: arg2 tuples: arg3  self testObject: arg1 initialState: arg2 tuples: arg3 setReadOnlyBlock: [:arg4 |  arg1 setIsReadOnlyObject: arg4 ]gtInspectorActions  | tmp1 |  tmp1 := (Pragma allNamed: #gtInspectorAction from: self class to: ProtoObject) collect: [:arg1 |  thisContext object: self perform: arg1 methodSelector withArguments: #() inClass: self class ].  ^tmp1 asSortedCollection: [:arg2 :arg3 |  | tmp2 tmp3 |        tmp2 := arg2 isCategorized ifTrue: [ arg2 category , arg2 title ] ifFalse: [ arg2 title ].        tmp3 := arg3 isCategorized ifTrue: [ arg3 category , arg3 title ] ifFalse: [ arg3 title ].        tmp2 < tmp3 ]default  ^defaultstoreOn: arg1  arg1 nextPut: $(.  self printOn: arg1.  arg1 nextPut: $)printString  ^self printStringLimitedTo: 50000gtInspectorSourceIn: arg1  < gtInspectorPresentationOrder: 30>  (self method gtInspectorSourceIn: arg1)     doItReceiver: [ self receiver ];     doItContext: [ self ]testAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)testSupplyAnswerOfFillInTheBlankUsingDefaultAnswer  self should: [ 'red' = ([ UIManager default request: 'Your favorite color?' initialAnswer: 'red' ] valueSupplyingAnswer: #('Your favorite color?' #default)) ]valueWithExit  self value: [ ^nil ]testAllSharedPools  self assert: Point allSharedPools equals: OrderedCollection new.  self assert: Date sharedPools first equals: ChronologyConstants.  self assert: Date sharedPools size equals: 1.  self assert: RootClassPoolUser sharedPools size equals: 1.  self assert: ClassMultiplePoolUser sharedPools size equals: 2.  self assertEmpty: SubclassPoolUser sharedPoolsdoSomethingString  ^'Do something.'findSimilarSender  ^self sender findContextSuchThat: [:arg1 |  arg1 method == method ]shift  ^KMModifier shift + selffollowingByte  ^self method at: pc + 1genStoreRemoteTemp: arg1 inVectorAt: arg2  (arg1 < 0 or: [ arg1 >= 256 ]) ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: arg1 range: 0 to: 255 ].  (arg2 < 0 or: [ arg2 >= 128 ]) ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: arg2 range: 0 to: 127 ].  stream     nextPut: 252;     nextPut: arg1;     nextPut: arg2name: arg1  name := arg1ln  ^self asFloat lnselector: arg1  | tmp1 tmp2 |  Symbol internSelector: arg1.  (tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 selector: arg1 ] ifFalse: [ (tmp2 := self numLiterals) < 2 ifTrue: [ self error: 'insufficient literals to hold selector' ].        self literalAt: tmp2 - 1 put: arg1 ]assert: arg1 description: arg2  < debuggerCompleteToSender>  arg1 value ifFalse: [ AssertionFailure signal: arg2 value ]addSelector: arg1 withMethod: arg2  ^self addSelectorSilently: arg1 withMethod: arg2subscript  ^subscriptisSpecContainer  ^false< arg1  < primitive: 23>  ^super < arg1signaler  ^signaler\\ arg1  < primitive: 11>  ^super \\ arg1gtDebuggerRawIn: arg1  < gtDebuggerPresentationOrder: 15>  (GTProtoObjectVariablesBrowser new variablesIn: arg1)     title: 'Raw';     send: #valueversion: arg1  versionString := arg1completeProcess: arg1 with: arg2  ^self signalerContexttestNonResumableFallOffTheEndHandler  self assertSuccess: (ExceptionTester new runTest: #nonResumableFallOffTheEndHandler)valuesDo: arg1  tally = 0 ifTrue: [ ^self ].  1 to: self basicSize do: [:arg2 |  (array at: arg2) ifNotNil: [:arg3 |  arg1 value: arg3 ] ]testLowBit  | tmp1 |  self assert: 2r1011 lowBit equals: 1.  self assert: 2r1010 lowBit equals: 2.  self assert: 2r000000 lowBit equals: 0.  tmp1 := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA) , {SmallInteger maxVal .         (SmallInteger maxVal + 1)}.  tmp1 := tmp1 , (tmp1 collect: [:arg1 |  arg1 raisedTo: 20 ]).  tmp1 do: [:arg2 |  | tmp2 |        tmp2 := (arg2 respondsTo: #bitAt:) ifTrue: [ (1 to: arg2 highBit) detect: [:arg3 |  (arg2 bitAt: arg3) ~= 0 ] ifNone: [ 0 ] ] ifFalse: [ (1 to: arg2 highBit) detect: [:arg3 |  (arg2 bitAnd: (1 bitShift: arg3 - 1)) ~= 0 ] ifNone: [ 0 ] ].        self assert: arg2 lowBit equals: tmp2.        self assert: arg2 negated lowBit equals: tmp2 ]testInstanceSide  self assert: Point instanceSide equals: Point.  self assert: Point class instanceSide equals: PointtestAsNumberWithoutDecimalPoint2  | tmp1 |  tmp1 := '123s2' asNumber.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: tmp1 scale equals: 2.  self assert: '123.00s2' equals: tmp1 printStringasMargin  ^selfisSelfEvaluating  ^self class == PointtestRaisedTo  self should: [ 0 raisedTo: -1 ] raise: ZeroDivide.  self should: [ 0 raisedTo: -1.0 ] raise: ZeroDividecreateMethod: arg1 class: arg2 header: arg3  | tmp1 |  encodedData ifNil: [ self encode ].  tmp1 := arg2 newMethod: arg1 + size header: arg3.  1 to: size do: [:arg4 |  tmp1 at: tmp1 size - size + arg4 put: (encodedData at: arg4) ].  ^tmp1standardMessageText  ^String streamContents: [:arg1 |  arg1 print: self selector.        arg1 << ' is not yet implemented in '.        arg1 print: self signaler class ]vmSimNextWakeupMilliseconds  ^vmSimNextWakeupTick / 1000testMemoizedLRUCache  | tmp1 tmp2 tmp3 |  tmp1 := LRUCache new maximumWeight: 3.  tmp2 := 0.  tmp2 := [:arg1 |  arg1 = 1 ifTrue: [ 1 ] ifFalse: [ (tmp2 value: arg1 - 1) * arg1 ] ] memoizedUsing: tmp1.  tmp3 := (1 to: 5) collect: tmp2.  self assert: tmp3 equals: #(1 2 6 24 120).  self assert: tmp1 testSupportGetCachedAssociations equals: {(3 -> 6) .         (4 -> 24) .         (5 -> 120)}postCopy  1 to: self basicSize do: [:arg1 |  self basicAt: arg1 put: (self basicAt: arg1) shallowCopy ]reentrant  ^selfoldDefinition  | tmp1 |  tmp1 := (String new: 800) writeStream.  superclass ifNil: [ tmp1 nextPutAll: 'ProtoObject' ] ifNotNil: [ tmp1 nextPutAll: superclass name ].  tmp1     nextPutAll: self kindOfSubclass;     store: self name.  self hasTraitComposition ifTrue: [ tmp1           cr;           tab;           nextPutAll: 'uses: ';           nextPutAll: self traitCompositionString ].  tmp1     cr;     tab;     nextPutAll: 'instanceVariableNames: ';     store: self instanceVariablesString.  tmp1     cr;     tab;     nextPutAll: 'classVariableNames: ';     store: self classVariablesString.  tmp1     cr;     tab;     nextPutAll: 'poolDictionaries: ';     store: self sharedPoolsString.  tmp1     cr;     tab;     nextPutAll: 'category: ';     store: self category asString.  superclass ifNil: [ tmp1           nextPutAll: '.';           cr.        tmp1 nextPutAll: self name.        tmp1           space;           nextPutAll: 'superclass: nil' ].  ^tmp1 contentscriticTheNonMetaclassClass  ^selfsend: arg1 to: arg2 with: arg3 super: arg4  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg4 ifTrue: [ (self method literalAt: self method numLiterals) value superclass ] ifFalse: [ self objectClass: arg2 ].  tmp2 := tmp1 lookupSelector: arg1.  tmp2 == nil ifTrue: [ ^self send: #doesNotUnderstand: to: arg2 with: (Array with: (Message selector: arg1 arguments: arg3)) super: arg4 ].  tmp2 isCompiledMethod ifFalse: [ ^self send: #run:with:in: to: tmp2 with: (Array with: arg1 with: arg3 with: arg2) super: arg4 ].  tmp3 := self tryPrimitiveFor: tmp2 receiver: arg2 args: arg3.  (self isFailToken: tmp3) ifFalse: [ ^tmp3 ].  (arg1 == #doesNotUnderstand: and: [ (tmp1 canUnderstand: #doesNotUnderstand:) not ]) ifTrue: [ ^self error: 'Simulated message ' , (arg3 at: 1) selector , ' not understood' ].  tmp4 := self activateMethod: tmp2 withArgs: arg3 receiver: arg2 class: tmp1.  (tmp4 method at: tmp4 pc) = 129 ifTrue: [ tmp4 at: tmp4 stackPtr put: tmp3 last ].  ^tmp4addModelYellowButtonMenuItemsTo: arg1 forMorph: arg2 hand: arg3  Morph cmdGesturesEnabled ifTrue: [ arg1 add: 'inspect model' target: self selector: #inspect ].  ^arg1at: arg1 ifAbsent: arg2  1 to: self basicSize do: [:arg3 |  | tmp1 |        (tmp1 := self basicAt: arg3) key == arg1 ifTrue: [ ^tmp1 isVariableBinding ifTrue: [ tmp1 value ] ifFalse: [ tmp1 ] ] ].  ^arg2 valuegenCallPrimitive: arg1  (arg1 < 1 or: [ arg1 > 65535 ]) ifTrue: [ self outOfRangeError: 'primitive index' index: arg1 range: 1 to: 65535 ].  stream     nextPut: 139;     nextPut: (arg1 bitAnd: 255);     nextPut: (arg1 bitShift: -8)genStoreLiteralVar: arg1  (arg1 < 0 or: [ arg1 > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 32768 ].  arg1 > 255 ifTrue: [ self genUnsignedSingleExtendA: arg1 // 256 ].  stream     nextPut: 244;     nextPut: arg1 \\ 256primSignal: arg1 atUTCMicroseconds: arg2  < primitive: 242>  ^self primitiveFailedtestDayMonthYearDo  january23rd2004 dayMonthYearDo: [:arg1 :arg2 :arg3 |  self assert: arg1 equals: 23.        self assert: arg2 equals: 1.        self assert: arg3 equals: 2004 ]printOn: arg1 base: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  (self bytesCount = 0 or: [ (self byteAt: self bytesCount) = 0 ]) ifTrue: [ ^self normalize printOn: arg1 base: arg2 ].  tmp5 := arg2 = 10 ifTrue: [ ((self highBit - 1) * 1233 >> 12) + 1 ] ifFalse: [ self highBit quo: arg2 highBit ].  tmp1 := 1 bitShift: tmp5 highBit - 2.  tmp1 <= 1 ifTrue: [ ^self printOn: arg1 base: arg2 nDigits: (self numberOfDigitsInBase: arg2) ].  tmp2 := arg2 raisedToInteger: tmp1.  tmp3 := self quo: tmp2.  tmp4 := self - (tmp3 * tmp2).  tmp3 printOn: arg1 base: arg2.  tmp4 printOn: arg1 base: arg2 nDigits: tmp1asMonth  ^selfsourceNode  ^self sourceNodeInOuteractivateMethod: arg1 withArgs: arg2 receiver: arg3 class: arg4  ^Context sender: self receiver: arg3 method: arg1 arguments: arg2timeClass  ^Timedefinition  (self slotsNeedFullDefinition or: [ Slot showSlotClassDefinition ]) ifTrue: [ ^self definitionWithSlots ].  ^self definitionWithoutSlotsdebug  Processor activeProcess debug: self signalerContext title: self descriptionat: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := self findElementOrNil: arg1.  (self basicAt: tmp1) ifNil: [ ^arg2 value ].  ^array at: tmp1suspendedContext  ^suspendedContextsubclass: arg1 uses: arg2 slots: arg3 classVariables: arg4 package: arg5  ^self subclass: arg1 uses: arg2 layout: self classLayout class slots: arg3 classVariables: arg4 poolDictionaries: '' category: arg5isValidTraitName: arg1  arg1 ifNil: [ ^false ].  ^arg1 isValidGlobalNameisOnOrAfter: arg1  ^(self equals: arg1) or: [ self isAfter: arg1 ]propertyValueAt: arg1  ^self propertyAt: arg1currentWorld  ^UIManager default currentWorldsize  < primitive: 212>  ^self primitiveFailleft: arg1  ^arg1 @ origin y corner: cornerreciprocal  ^x reciprocal @ y reciprocalgenBranchPopTrueLong: arg1  | tmp1 |  (arg1 < 0 or: [ arg1 > 32767 ]) ifTrue: [ ^self outOfRangeError: 'distance' index: arg1 range: 0 to: 32767 ].  (arg1 > 0 and: [ arg1 < 9 ]) ifTrue: [ stream nextPut: 183 + arg1.        ^self ].  tmp1 := (arg1 < 0 or: [ arg1 > 255 ]) ifTrue: [ self genUnsignedSingleExtendB: (arg1 bitShift: -8).        arg1 bitAnd: 255 ] ifFalse: [ arg1 ].  stream     nextPut: 238;     nextPut: tmp1gtInspectorEProportiesIn: arg1  < gtInspectorPresentationOrder: 20>  | tmp1 tmp2 |  ReSettings inspectorPluggin ifFalse: [ ^self ].  tmp2 := [ tmp1 ifNil: [ tmp1 := self externalProperties ] ].  arg1 list     when: [ tmp2 value notEmpty ];     title: [ tmp2 value size asString , (' property' asPluralBasedOn: tmp2 value) ];     titleIcon: [ CircleMorph new           extent: 16 @ 16;           borderWidth: 0;           color: Color red darker darker;           addMorphCentered: (tmp2 value size asStringMorph                 color: Color white;                 emphasis: 1;                 yourself);           iconOrThumbnail ];     display: [ tmp2 value ];     icon: #icon;     format: #titlenumerator  ^numeratornewRectFrom: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := self currentWorld activeHand.  tmp3 := tmp4 := tmp5 anyButtonPressed.  tmp1 := self.  self drawReverseFrame: tmp1.  tmp5 captureEventsWhile: [:arg2 |  arg2 isMouse ifTrue: [ tmp4 := arg2 anyButtonPressed.              tmp2 := arg1 value: tmp1 value: arg2 cursorPoint.              tmp2 = tmp1 ifFalse: [ self drawReverseFrame: tmp1.                    self drawReverseFrame: tmp2.                    tmp1 := tmp2 ].              tmp4 = tmp3 ] ifFalse: [ true ] ].  self drawReverseFrame: tmp1.  tmp5     newMouseFocus: nil;     showTemporaryCursor: nil.  ^tmp1return: arg1  sender ifNil: [ ^self cannotReturn: arg1 to: sender ].  sender resume: arg1variableWordSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5  ^self classInstaller make: [:arg6 |  arg6           superclass: self;           name: arg1;           layoutClass: WordLayout;           slots: arg2 asSlotCollection;           sharedVariablesFromString: arg3;           sharedPools: arg4;           category: arg5;           environment: self environment ]stopTimerEventLoop  runTimerEventLoop := false.  timingSemaphore signal.  timerEventLoop isTerminated ifFalse: [ debug ifFalse: [ self error: 'Expected timing priority event loop terminated already' ].        timerEventLoop terminate ].  timerEventLoop := niltestValueWithExitBreak  | tmp1 |  [:arg1 |  1 to: 10 do: [:arg2 |  tmp1 := arg2.        arg2 = 4 ifTrue: [ arg1 value ] ] ] valueWithExit.  self assert: tmp1 equals: 4ast  ^ASTCache at: selftallyCPUUsageFor: arg1 every: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := IdentityBag new: 200.  tmp3 := Delay forMilliseconds: arg2 truncated.  tmp4 := Delay forSeconds: arg1.  tmp4 schedule.  tmp2 := Semaphore new.  [ [ tmp4 isExpired ] whileFalse: [ tmp3 wait.        tmp1 add: Processor nextReadyProcess ].  tmp2 signal ] forkAt: self highestPriority.  ^[ tmp2 wait.  tmp1 ]lookupClass: arg1  lookupClass := arg1messageText  ^messageText ifNil: [ messageText := self standardMessageText ]singleRelease  stackp ifNotNil: [ 1 to: stackp do: [:arg1 |  self at: arg1 put: nil ] ].  sender := nil.  pc := niltestParsingMMPatternWithIncorrectMonthFails  self assertReading: '02.00.2013' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.13.2013' as: 'dd.mm.yyyy' raise: DateErrordigitAt: arg1 put: arg2  self deprecated: 'Please use #byteAt:put: instead' transformWith: '`@receiver digitAt: `@statements1 put: `@statements2' -> '`@receiver byteAt: `@statements1 put: `@statements2'.  ^self byteAt: arg1 put: arg2hasMethods  ^super hasMethods or: [ self classSide hasMethods ]shouldNotImplementMethod  ^self shouldNotImplementprintSystemPath  ^self calypsoEnvironmentType printSystemPathTo: selfbottom  ^corner yclassComment: arg1 stamp: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp4 := self organization classComment.  tmp5 := self organization commentStamp.  arg1 string = tmp4 string ifTrue: [ ^self ].  arg1 isRemoteString ifTrue: [ SystemAnnouncer uniqueInstance class: self oldComment: tmp4 newComment: arg1 string oldStamp: tmp5 newStamp: arg2.        ^self organization classComment: arg1 stamp: arg2 ].  tmp3 := self organization commentRemoteString.  tmp1 := tmp3 ifNil: [ 0 ] ifNotNil: [ tmp3 sourcePointer ].  tmp6 := String streamContents: [:arg3 |  arg3           cr;           nextPut: $!.        tmp2 := String streamContents: [:arg4 |  arg4                 nextPutAll: self name;                 nextPutAll: ' commentStamp: '.              arg2 storeOn: arg4.              arg4                 nextPutAll: ' prior: ';                 nextPutAll: tmp1 printString ].        arg3           nextChunkPut: tmp2;           cr ].  SourceFiles writeSource: arg1 preamble: tmp6 onSuccess: [:arg5 |  self organization classComment: (SourceFiles remoteStringAt: arg5) stamp: arg2 ] onFail: [  ].  SystemAnnouncer uniqueInstance class: self oldComment: tmp4 newComment: arg1 oldStamp: tmp5 newStamp: arg2testAddSeconds  self assert: (aTime addSeconds: 1) equals: (Time readFrom: '12:34:57' readStream).  self assert: (aTime addSeconds: 60) equals: (Time readFrom: '12:35:56' readStream).  self assert: (aTime addSeconds: 3600) equals: (Time readFrom: '13:34:56' readStream).  self assert: (aTime addSeconds: 24 * 60 * 60) equals: (Time readFrom: '12:34:56' readStream)suspendedContext: arg1  suspendedContext := arg1testScaleExtension  #(#* #+ #- #/) do: [:arg1 |  self assert: (2.5s1 perform: arg1 with: 1.000s3) scale equals: 3.        self assert: (3.5000s4 perform: arg1 with: 1.0s1) scale equals: 4 ]referencingMethod3  ^selftestPrint24withNanos  self assert: '12:34:56.1' asTime print24 equals: '12:34:56'testIsProbablyPrime  #(-100 -5 -3 -2 -1 0 1) do: [:arg1 |  self deny: arg1 isProbablyPrime ].  #(17 78901 104729 15485863 2038074743 29996224275833) do: [:arg1 |  self assert: arg1 isProbablyPrime ].  #(561 2821 6601 10585 15841 256 29996224275831) do: [:arg1 |  self deny: arg1 isProbablyPrime ]removeSavedTemp: arg1  self savedTemps ifNotNil: [:arg2 |  arg2 remove: arg1.        arg2 ifEmpty: [ self removeProperty: #savedTemps ] ]command  ^KMModifier command + selfveryDeepCopyWith: arg1  interpretNextInstructionFor: arg1  ^self method encoderClass interpretNextInstructionFor: arg1 in: selfvariableNode: arg1  variableNode := arg1month  ^self dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg2 ]traverseWithMemory: arg1 seen: arg2  arg1 accumulate: self.  arg2 add: self.  self traversableInstVarIndexes do: [:arg3 |  arg1 traverse: self value: (self instVarAt: arg3) seen: arg2 ].  self traversableIndexableVarIndexes do: [:arg3 |  arg1 traverse: self value: (self basicAt: arg3) seen: arg2 ]selectorsToBeIgnored  | tmp1 tmp2 tmp3 |  tmp1 := #().  tmp2 := #().  tmp3 := #(#< #= #new #next #previous #printOn: #printOn:format: #storeOn: #fromString:).  ^super selectorsToBeIgnored , tmp1 , tmp2 , tmp3asMinimalRepresentation  ^selftestComparing  | tmp1 tmp2 tmp3 |  tmp1 := june2nd1973 asString asDate.  tmp2 := june2nd1973 + 1 day.  tmp3 := june2nd1973 - 1 day.  self     assert: june2nd1973 equals: tmp1;     assert: june2nd1973 equals: june2nd1973 copy;     assert: june2nd1973 hash equals: tmp1 hash.  self     assert: june2nd1973 < tmp2;     assert: june2nd1973 > tmp3attemptToAssign: arg1 withIndex: arg2  self modificationForbiddenFor: #instVarAt:put: index: arg2 value: arg1.  thisContext sender jumphour24  ^(seconds rem: SecondsInDay) quo: SecondsInHourmethodReference  | tmp1 tmp2 |  tmp1 := self methodClass ifNil: [ ^nil ].  tmp2 := self selector ifNil: [ ^nil ].  ^(RGMethodDefinition realClass: tmp1 selector: tmp2)     package: self package asRingDefinition;     yourselftestArcTan  self assert: ((100 arcTan: 100) closeTo: Float pi / 4).  self assert: ((-100 arcTan: 100) closeTo: Float pi / -4).  self assert: ((100 arcTan: -100) closeTo: Float pi * 3 / 4).  self assert: ((-100 arcTan: -100) closeTo: Float pi * -3 / 4).  self assert: ((0 arcTan: 100) closeTo: 0).  self assert: ((0 arcTan: -100) closeTo: Float pi).  self assert: ((100 arcTan: 0) closeTo: Float pi / 2).  self assert: ((-100 arcTan: 0) closeTo: Float pi / -2).  self assert: ((Float negativeZero arcTan: 100) closeTo: 0).  self assert: ((Float negativeZero arcTan: -100) closeTo: Float pi * -1).  self assert: (0 arcTan: 0) equals: 0.  self assert: (Float negativeZero arcTan: 0) equals: 0.  self assert: ((0 arcTan: Float negativeZero) closeTo: Float pi).  self assert: ((Float negativeZero arcTan: Float negativeZero) closeTo: Float pi negated)constructFibonacciBlockInDeadFrame  | tmp1 |  tmp1 := [:arg1 |  arg1 <= 0 ifTrue: [ self error: 'not a natural number' ].  arg1 <= 2 ifTrue: [ 1 ] ifFalse: [ (tmp1 value: arg1 - 1) + (tmp1 value: arg1 - 2) ] ].  ^tmp1testReadFrom  | tmp1 tmp2 |  tmp1 := '4:02:47 am'.  tmp2 := self timeClass readFrom: tmp1 readStream.  self assert: time printString equals: tmp2 printStringtestTruncated  self assert: (3 / 2) truncated equals: 1.  self assert: (-3 / 2) truncated equals: -1setUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  aDateAndTime := DateAndTime     localTimeZone: TimeZone default;     epoch.  aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'Epoch Test Time Zone' abbreviation: 'ETZ'.  aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5sizeStorePopTemp: arg1  ^self sizeOpcodeSelector: #genStorePopTemp: withArguments: {arg1}restartTimerEventLoop  self stopTimerEventLoop.  self startTimerEventLooptranslatedToBeWithin: arg1  ^self translateBy: (self amountToTranslateWithin: arg1)testNotSymmetricWithString  | tmp1 tmp2 |  tmp1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  tmp2 := '0001-01-02T02:03:04.000000005+06:00'.  self deny: tmp1 equals: tmp2.  self deny: tmp2 equals: tmp1testPrintOn  self assert: (String streamContents: [:arg1 |  aDateAndTime printOn: arg1 ]) equals: '1980-01-01T00:00:00+00:00'.  self assert: (String streamContents: [:arg1 |  aTimeZone printOn: arg1 ]) equals: 'a TimeZone(DTZ)'testIsCurrencySymbol  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isCurrencySymbol: tmp2) equals: (tmp1 isCurrencySymbol: tmp2) ]testAsDate  self assert: aTimespan asDate equals: jan01 asDateasDuration  ^self durationtop: arg1  ^origin x @ arg1 corner: cornerisZero  ^self = 0.0isEqualRegardlessTrailerTo: arg1  ^(self copyWithTrailerBytes: CompiledMethodTrailer empty) = (arg1 copyWithTrailerBytes: CompiledMethodTrailer empty)jsonOn: arg1  self error: 'Override #jsonOn: to make the receiver serializeable as JSON'methodDictionary: arg1  self methodDict: arg1includesAllOf: arg1  self deprecated: 'Please use #includesAll: instead' transformWith: '`@receiver includesAllOf: `@statements' -> '`@receiver includesAll: `@statements'.  ^self includesAll: arg1gtInspectorVariableNodesIn: arg1  arg1     add: (GTInspectorDynamicNode hostObject: self label: '1' value: (self at: 1));     add: (GTInspectorDynamicNode hostObject: self label: '2' value: (self at: 2))compileAllFrom: arg1  arg1 localSelectors do: [:arg2 |  self recompile: arg2 from: arg1 ]waitWhile: arg1 for: arg2  ^self waitWhile: arg1 for: arg2 maxMilliseconds: nilvariableWordSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4  ^self variableWordSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: '' package: arg4becomeUncompact  stonOn: arg1  arg1 writeNulltestHandlingWithExclusion  | tmp1 |  tmp1 := false.  self should: [ [ ZeroDivide signalWithDividend: 1 ] on: Error - ZeroDivide do: [:arg1 |  tmp1 := true.              arg1 return ] ] raise: ZeroDivide.  self deny: tmp1log  ^DomainError signal: 'log is only defined for x > 0' from: 0testAsNanoSeconds  self assert: aTime asNanoSeconds equals: 45296000000000testNext  self assert: aTimespan next equals: (Timespan starting: (DateAndTime year: 2005 month: 3 day: 26 hour: 0 minute: 0 second: 0) duration: aDuration)value: arg1  < primitive: 207>  | tmp1 |  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  false ifTrue: [ tmp1 := self asContextWithSender: thisContext sender.        tmp1 at: 1 put: arg1.        thisContext privSender: tmp1 ] ifFalse: [ self primitiveFailed ]packageFromOrganizer: arg1  | tmp1 |  self flag: 'TODO: use anRPackageOrganizer, or better delegate to anRPackageOrganizer'.  tmp1 := self originMethod selector.  ^self origin packages detect: [:arg2 |  self origin isMeta ifFalse: [ arg2 includesSelector: tmp1 ofClassName: self origin instanceSide originalName ] ifTrue: [ arg2 includesSelector: tmp1 ofMetaclassName: self origin instanceSide originalName ] ] ifNone: [ nil ]printOn: arg1  self isSelfEvaluating ifFalse: [ ^super printOn: arg1 ].  arg1 nextPutAll: #Processorchanged: arg1 with: arg2  self dependents do: [:arg3 |  arg3 update: arg1 with: arg2 ]testYearDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1980 day: 1 hour: 0 minute: 0 second: 0)swap: arg1 with: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  ((self validIndex: arg1) and: [ self validIndex: arg2 ]) ifFalse: [ ^self errorOutOfBounds ].  arg1 = arg2 ifTrue: [ ^self ].  tmp1 := arg1 min: arg2.  tmp2 := arg2 max: arg1.  tmp3 := tmp1 = 1 ifFalse: [ self linkAt: tmp1 - 1 ].  tmp5 := tmp3 ifNotNil: [ tmp3 nextLink ] ifNil: [ self linkAt: tmp1 ].  tmp7 := tmp5 nextLink.  tmp4 := self linkAt: tmp2 - 1.  tmp6 := tmp4 nextLink.  tmp8 := tmp6 nextLink.  tmp5 = firstLink ifTrue: [ firstLink := tmp6 ] ifFalse: [ tmp3 nextLink: tmp6 ].  tmp6 = lastLink ifTrue: [ lastLink := tmp5 ] ifFalse: [  ].  tmp9 := tmp5 nextLink = tmp6 ifTrue: [ tmp5 ] ifFalse: [ tmp4 nextLink: tmp5.        tmp7 ].  tmp5 nextLink: tmp8.  tmp6 nextLink: tmp9doWhileTrue: arg1  | tmp1 |  [ tmp1 := self value.  arg1 value ] whileTrue.  ^tmp1rFwithArgs: arg1 executeMethod: arg2  < disableReflectivity>  < primitive: 188>  self primitiveFailedspotterCompositionFor: arg1  < spotterOrder: 25>  arg1 listProcessor     title: 'Composing traits';     allCandidates: [ self allTraits ];     itemIcon: #systemIcon;     filter: GTFilterSubstringisClosePunctuation  ^self characterSet isClosePunctuation: selfcodePoint  ^self asciiValuehasMetaLinks  self reflectiveMethod ifNil: [ ^false ].  ^self reflectiveMethod hasMetaLinksblockCreationBytecodeMessage  ^self method encoderClass blockCreationBytecodeMessageAt: startpc method: self methodaddDependent: arg1  self error: 'Nil should not have dependents'secondByte  ^self method at: pc + 1someObject  < primitive: 138>  self primitiveFailedparseYear  self isFourDigitYearPattern ifTrue: [ ^self parseFourDigitYear ].  self isTwoDigitYearPattern ifTrue: [ ^self parseTwoDigitYear ].  self parseVariableDigitYearerrorSubscriptBounds: arg1  SubscriptOutOfBounds signalFor: arg1testUnionWithOverlapping  self assert: (aTimespan union: anOverlappingTimespan) equals: (Timespan starting: dec31 duration: 8 days)sizeSendSuper: arg1 numArgs: arg2  ^self sizeOpcodeSelector: #genSendSuper:numArgs: withArguments: {arg1 .         arg2}testWeekPrintOn  | tmp1 tmp2 tmp3 |  tmp1 := Week starting: (DateAndTime year: 1900 month: 12 day: 31).  tmp2 := 'a Week starting: 1900-12-30T00:00:00+00:00'.  tmp3 := String new writeStream.  tmp1 printOn: tmp3.  self assert: tmp3 contents equals: tmp2testSecondsNanoSeconds  self assert: (Duration seconds: 0 nanoSeconds: 5) equals: (Duration nanoSeconds: 5).  self assert: (aDuration seconds: 0 nanoSeconds: 1) equals: (Duration nanoSeconds: 1)selector  ^selectordecodeSourcePointer  | tmp1 |  size := 4.  tmp1 := method size.  data := ((((method at: tmp1) - 251 << 8) + (method at: tmp1 - 1) << 8) + (method at: tmp1 - 2) << 8) + (method at: tmp1 - 3)includesSelector: arg1  ^protocols anySatisfy: [:arg2 |  arg2 includesSelector: arg1 ]testStart  self assert: aTimespan start equals: jan01.  aTimespan start: jan08.  self assert: aTimespan start equals: jan08methodNode  ^self subclassResponsibilityon: arg1 fork: arg2 return: arg3  ^self on: arg1 do: [:arg4 |  | tmp1 tmp2 tmp3 tmp4 |        tmp1 := thisContext.        tmp4 := tmp1 home.        [ tmp1 sender == tmp4 ] whileFalse: [ tmp1 := tmp1 sender.              tmp1 ifNil: [ ^arg2 cull: arg4 ] ].        tmp3 := [ Processor terminateActive ] asContext.        tmp1 privSender: tmp3.        tmp2 := [ arg2 cull: arg4 ] asContext.        tmp2 privSender: thisContext sender.        (Process forContext: tmp2 priority: Processor activePriority) resume.        thisContext privSender: tmp4.        arg3 cull: arg1 ]renameCategory: arg1 toBe: arg2  self silentlyRenameCategory: arg1 toBe: arg2.  self notifyOfChangedCategoryFrom: arg1 to: arg2.  (self protocolOrganizer protocolNamed: arg2) methodSelectors do: [:arg3 |  self notifyOfChangedSelector: arg3 from: arg1 to: arg2 ]sqrt  | tmp1 |  self mightBeASquare ifFalse: [ tmp1 := self asFloat.        tmp1 isFinite ifTrue: [ ^self asFloat sqrt ] ].  ^super sqrtwriteX  x := 33stepToCallee  Processor activeProcess evaluate: [ | tmp1 |        tmp1 := suspendedContext.        [ tmp1 == suspendedContext ] whileTrue: [ suspendedContext := suspendedContext step ] ] onBehalfOf: self.  ^suspendedContextsymbolic  ^self longPrintStringtestWeeksDo  | tmp1 tmp2 |  tmp1 := aTimespan weeks.  self assert: tmp1 size equals: (aDuration days / 7.0) ceiling + 1.  tmp2 := OrderedCollection new.  tmp2     addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 19) duration: 7 days);     addLast: (Week starting: (DateAndTime year: 2004 month: 12 day: 26) duration: 7 days).  2 to: 79 by: 7 do: [:arg1 |  tmp2 addLast: (Week starting: (DateAndTime year: 2005 day: arg1) duration: 7 days) ].  tmp2 := tmp2 asArray.  self assert: aTimespan weeks equals: tmp2simpleEnsureTestWithUparrow  [ self doSomething.  true ifTrue: [ ^nil ].  self doSomethingElse ] ensure: [ self doYetAnotherThing ]testBetweenAndDoIncludedInSchedule  | tmp1 |  tmp1 := 0.  aSchedule between: (DateAndTime year: 2003 month: 4 day: 1) and: (DateAndTime year: 2003 month: 4 day: 30) do: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 8checkClass: arg1  (self basicCheckClass: arg1) ifNotEmpty: [:arg2 |  Warning new           messageText: 'VeryDeepCopy out of sync in some classes. Some classes contain veryDeepCopyWith: or veryDeepInner: methods that are not in sync with their instance variables. Check the exception #tag for a list of them';           tag: arg2;           signal ]testLiteralsDoesNotContainMethodClass  self deny: (self compiledMethod1 hasLiteralThorough: (self class environment associationAt: self class name asSymbol))printDate: arg1 format: arg2 on: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  arg1 dayMonthYearDo: [:arg4 :arg5 :arg6 |  tmp1 := arg4.        tmp2 := arg5.        tmp3 := arg6 ].  tmp4 := arg2 size > 6 and: [ (arg2 at: 7) > 1 ].  1 to: 3 do: [:arg7 |  tmp5 := arg2 at: arg7.        tmp5 = 1 ifTrue: [ tmp4 ifTrue: [ tmp1 printOn: arg3 base: 10 length: 2 padded: true ] ifFalse: [ tmp1 printOn: arg3 ] ].        tmp5 = 2 ifTrue: [ tmp6 := arg2 at: 5.              tmp6 = 1 ifTrue: [ tmp4 ifTrue: [ tmp2 printOn: arg3 base: 10 length: 2 padded: true ] ifFalse: [ tmp2 printOn: arg3 ] ].              tmp6 = 2 ifTrue: [ (Month nameOfMonth: tmp2) from: 1 to: 3 do: [:arg8 |  arg3 nextPut: arg8 ] ].              tmp6 = 3 ifTrue: [ arg3 nextPutAll: (Month nameOfMonth: tmp2) ] ].        tmp5 = 3 ifTrue: [ (arg2 at: 6) = 1 ifTrue: [ tmp3 printOn: arg3 base: 10 length: 4 padded: true ] ifFalse: [ tmp3 \\ 100 printOn: arg3 base: 10 length: 2 padded: true ] ].        arg7 < 3 ifTrue: [ (arg2 at: 4) ~= 0 ifTrue: [ arg3 nextPut: (arg2 at: 4) asCharacter ] ] ]humanReadablePrintString  ^String streamContents: [:arg1 |  self printHumanReadableOn: arg1 ]drTestsBrowse  Smalltalk tools browser openOnClass: self methodClass selector: self selectortestCeiling  self assert: (3 / 2) ceiling equals: 2.  self assert: (-3 / 2) ceiling equals: -1shutDown  versionString  ^versionString ifNil: [ 'unknown' ]asHexDigit  ^'0123456789ABCDEF' at: self + 1genPushInstVarLong: arg1  (arg1 < 0 or: [ arg1 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 65535 ].  arg1 > 255 ifTrue: [ self genUnsignedSingleExtendA: arg1 // 256 ].  stream     nextPut: 226;     nextPut: arg1 \\ 256valueWithArguments: arg1  ^receiver perform: selector withArguments: (self collectArguments: arg1)basicSize  < primitive: 212>  ^self primitiveFailsourceNodeExecutedForPC: arg1  | tmp1 |  tmp1 := self outerCode sourceNodeExecutedForPC: self pcInOuter.  ^tmp1 sourceNodeExecutedForPC: arg1testBecomeForward  | tmp1 tmp2 tmp3 |  tmp1 := 0 @ 0.  tmp2 := tmp1.  tmp3 := 100 @ 100.  tmp1 becomeForward: tmp3.  self assert: tmp2 equals: 100 @ 100.  self assert: tmp3 identicalTo: tmp2.  self assert: tmp1 equals: 100 @ 100outerMostContext  ^self outerContext ifNil: [ self ] ifNotNil: [ self outerContext ]testDuration  self assert: aTime duration equals: 0 secondstestSetIsReadOnlyFailure  self alwaysWritableObjects do: [:arg1 |  self testObject: arg1 initialState: false tuples: #(#(true false false) #(false false false)) ]taskbarIcon  ^self class taskbarIconhandles: arg1  ^(super handles: arg1) and: [ exclusions noneSatisfy: [:arg2 |  arg2 handles: arg1 ] ]includesAny: arg1  ^arg1 anySatisfy: [:arg2 |  self includes: arg2 ]isDigit  ^self characterSet isDigit: selfgtInspectorDetailsIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 table     title: 'Details';     display: [ {('human readable' -> self humanReadablePrintString) .         ('days' -> self days) .         ('hours' -> self hours) .         ('minutes' -> self minutes) .         ('seconds' -> self seconds) .         ('nanoseconds' -> self nanoSeconds)} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valuelogTest: arg1  self suiteLog add: arg1printPaddedWith: arg1 to: arg2 base: arg3  | tmp1 tmp2 tmp3 |  tmp1 := (String new: 10) writeStream.  self printOn: tmp1 base: arg3 showRadix: false.  tmp3 := tmp1 contents.  tmp2 := arg2 - tmp3 size.  tmp2 > 0 ifFalse: [ ^tmp3 ].  ^((String new: tmp2)     atAllPut: arg1;     yourself) , tmp3selectorsToBeIgnored  | tmp1 tmp2 tmp3 |  tmp1 := #().  tmp2 := #(#printOn:).  tmp3 := #(#next).  ^super selectorsToBeIgnored , tmp1 , tmp2 , tmp3associationsDo: arg1  tally = 0 ifTrue: [ ^self ].  1 to: self basicSize do: [:arg2 |  (self basicAt: arg2) ifNotNil: [:arg3 |  arg1 value: (Association key: arg3 value: (array at: arg2)) ] ]traitSource  ^self propertyAt: #traitSourceisSurrogateOther  ^self characterSet isSurrogateOther: selfvalueNoContextSwitch: arg1  < primitive: 222>  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  self primitiveFailedtestNameOfDay  | tmp1 |  tmp1 := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).  tmp1 withIndexDo: [:arg1 :arg2 |  self assert: (Week nameOfDay: arg2) equals: arg1 ].  self should: [ Week nameOfDay: 0 ] raise: self defaultTestError.  self should: [ Week nameOfDay: 8 ] raise: self defaultTestError.  self should: [ Week nameOfDay: #Sunday ] raise: self defaultTestErrortestMinutes  self assert: aDateAndTime minutes equals: 33comment: arg1  self instanceSide classComment: arg1testMixedMethod  | tmp1 |  self should: [ tmp1 := self mixedMethod ] notTakeMoreThanMilliseconds: 3.  self assert: tmp1 equals: 2reciprocal  ^1.0 / selfmethodSelectors  ^self protocolOrganizer allMethodSelectorsfileOutOn: arg1  ^self fileOutOn: arg1 initializing: truebottom  ^bottomwhileNil: arg1  ^[ self value isNil ] whileTrue: [ arg1 value ]blockReturnTop  [ closureOrNil isClosure ] assert.  ^self return: self pop from: selficonNamed: arg1  ^Smalltalk ui icons iconNamed: arg1to: arg1 by: arg2 do: arg3  ^(self to: arg1 by: arg2) scheduleDo: arg3roundTo: arg1  | tmp1 |  tmp1 := arg1 asPoint.  ^(x roundTo: tmp1 x) @ (y roundTo: tmp1 y)testNegative  self deny: aDuration negative.  self assert: aDuration negated negativetestExample1  self assert: (self example1: 5) equals: 5 factorialauthors  ^self methods , self classSide methods collect: [:arg1 |  arg1 author ] as: BaglinkAt: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := 0.  self linksDo: [:arg3 |  (tmp1 := tmp1 + 1) = arg1 ifTrue: [ ^arg3 ] ].  ^arg2 valuereadsField: arg1  | tmp1 tmp2 |  tmp1 := arg1 - 1.  ((tmp2 := InstructionStream on: self) scanFor: (self encoderClass instVarReadScanBlockFor: tmp1 using: tmp2)) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:arg2 |  arg2 readsField: arg1 ]asFloat  ^selfprintOn: arg1  arg1 nextPutAll: 'nil'genPop  stream nextPut: 216usesSecondaryBytecodeSet  ^self header < 0boundingBox  ^selfstonOn: arg1  arg1 writeObject: self listSingleton: (String streamContents: [:arg2 |  self print24: true showSeconds: true on: arg2 ])addClassVariable: arg1  | tmp1 tmp2 |  tmp2 := self copyForAnnouncement.  tmp1 := arg1 name asSymbol.  self withAllSubclasses do: [:arg2 |  (arg2 bindingOf: tmp1) ifNotNil: [ ^self error: tmp1 asString , ' is already used as a variable name in class ' , arg2 name ] ].  (self classPool includesKey: tmp1) ifFalse: [ self classPool declareVariable: arg1 from: Undeclared.        SystemAnnouncer uniqueInstance           classDefinitionChangedFrom: tmp2 to: self;           classModificationAppliedTo: self ]encodeLengthField: arg1  | tmp1 tmp2 |  [ arg1 > 0 ] assert.  tmp2 := arg1.  tmp1 := ByteArray streamContents: [:arg2 |  [ tmp2 > 0 ] whileTrue: [ arg2 nextPut: (tmp2 bitAnd: 255).              tmp2 := tmp2 >> 8 ] ].  [ tmp1 size <= 4 ] assert.  ^tmp1returnTrue  ^trueabsPrintInexactlyOn: arg1 base: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 |  self isInfinite ifTrue: [ arg1 nextPutAll: 'Float infinity'.        ^self ].  tmp1 := 50.  tmp2 := arg2 asFloat.  tmp3 := self exponent.  tmp4 := (tmp3 * tmp2 reciprocalLogBase2 - 1.0e-10) ceiling.  tmp3 >= 0 ifTrue: [ tmp5 := self.        tmp6 := 1.0.        tmp7 := 1.0 timesTwoPower: tmp3 - tmp1.        tmp8 := self significand ~= 1.0 ifTrue: [ tmp7 ] ifFalse: [ tmp7 / 2.0 ] ] ifFalse: [ tmp5 := self timesTwoPower: tmp1.        tmp6 := 1.0 timesTwoPower: tmp1.        tmp8 := 1.0 timesTwoPower: (tmp3 max: -1024).        tmp7 := tmp3 = MinValLogBase2 | (self significand ~= 1.0) ifTrue: [ tmp8 ] ifFalse: [ tmp8 * 2.0 ] ].  tmp4 >= 0 ifTrue: [ tmp6 := tmp6 * (tmp2 raisedToInteger: tmp4).        tmp3 = 1023 ifTrue: [ tmp5 := tmp5 / tmp2.              tmp6 := tmp6 / tmp2.              tmp7 := tmp7 / tmp2.              tmp8 := tmp8 / tmp2 ] ] ifFalse: [ tmp3 < -1023 ifTrue: [ tmp10 := (53 * tmp2 reciprocalLogBase2 - 1.0e-10) ceiling.              tmp9 := tmp2 raisedToInteger: tmp10.              tmp5 := tmp5 * tmp9.              tmp7 := tmp7 * tmp9.              tmp8 := tmp8 * tmp9.              tmp9 := tmp2 raisedToInteger: (tmp4 + tmp10) negated ] ifFalse: [ tmp9 := tmp2 raisedToInteger: tmp4 negated ].        tmp6 := tmp6 / tmp9 ].  tmp5 + tmp7 >= tmp6 ifTrue: [ tmp4 := tmp4 + 1 ] ifFalse: [ tmp6 := tmp6 / tmp2 ].  (tmp13 := tmp4 between: -3 and: 6) ifTrue: [ tmp14 := tmp4.        tmp4 <= 0 ifTrue: [ arg1 nextPutAll: ('0.000000' truncateTo: 2 - tmp4) ] ] ifFalse: [ tmp14 := 1 ].  [ tmp10 := (tmp5 / tmp6) truncated.  tmp5 := tmp5 - (tmp10 * tmp6).  (tmp11 := tmp5 <= tmp8) | (tmp12 := tmp5 + tmp7 >= tmp6) ] whileFalse: [ arg1 nextPut: (Character digitValue: tmp10).        tmp5 := tmp5 * tmp2.        tmp7 := tmp7 * tmp2.        tmp8 := tmp8 * tmp2.        tmp14 := tmp14 - 1.        tmp14 = 0 ifTrue: [ arg1 nextPut: $. ] ].  tmp12 ifTrue: [ tmp11 not | (tmp11 & (tmp5 * 2.0 >= tmp6)) ifTrue: [ tmp10 := tmp10 + 1 ] ].  arg1 nextPut: (Character digitValue: tmp10).  tmp14 > 0 ifTrue: [ tmp14 - 1 to: 1 by: -1 do: [:arg3 |  arg1 nextPut: $0 ].        arg1 nextPutAll: '.0' ].  tmp13 ifFalse: [ arg1 nextPut: $e.        arg1 nextPutAll: (tmp4 - 1) printString ]testIfFalse  self assert: (true ifFalse: [ 'alternativeBlock' ]) isNilisBlock  ^truenewAnonymousSubclass  ^self instanceSide newAnonymousSubclass classsizeStorePopInstVar: arg1  ^self sizeOpcodeSelector: #genStorePopInstVar: withArguments: {arg1}error: arg1  ^Error new signal: arg1stonOn: arg1  arg1 writeObject: self listSingleton: (String streamContents: [:arg2 |  self printOn: arg2 withLeadingSpace: false ])middleOf: arg1  | tmp1 |  tmp1 := arg1 asDuration.  ^Timespan starting: self - (tmp1 / 2) duration: tmp1testAccessing  self     assert: june2nd1973 day equals: 153;     assert: june2nd1973 julianDayNumber equals: 2441836;     assert: june2nd1973 monthIndex equals: 6;     assert: june2nd1973 monthName equals: #June;     assert: june2nd1973 weekday equals: #Saturday;     assert: june2nd1973 weekdayIndex equals: 7;     assert: june2nd1973 year equals: 1973remove: arg1 uptoLastValueLink: arg2 continuation: arg3  ^arg2 ifNotNil: [ | tmp1 tmp2 |        tmp1 := arg2 value.        tmp2 := self remove: arg1 uptoLastValueLink: arg2 nextLink continuation: arg3.        arg1 = tmp1 ifTrue: [ arg3 value: tmp2 ] ifFalse: [ tmp1 ~~> tmp2 ] ]addInstVarNamed: arg1  | tmp1 |  tmp1 := String streamContents: [:arg2 |  self instVarNames do: [:arg3 |  arg2                 nextPutAll: arg3;                 space ].        arg2 nextPutAll: arg1 ].  self instanceVariableNames: tmp1asRingDefinition  ^selfisSpacingCombiningMark  ^self characterSet isSpacingCombiningMark: selftestStoppedSchedulerExpiresRemainingDelays  | tmp1 tmp2 tmp3 |  tmp1 := Delay new setDelay: 9 forSemaphore: Semaphore new.  tmp2 := Delay new setDelay: 99 forSemaphore: Semaphore new.  tmp3 := Delay new setDelay: 999 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  scheduler schedule: tmp1.  scheduler schedule: tmp2.  scheduler schedule: tmp3.  self assert: tmp2 beingWaitedOn.  self assert: tmp1 beingWaitedOn.  self assert: tmp3 beingWaitedOn.  scheduler simulate_vmMilliseconds: 25.  self assert: tmp1 isExpired.  self deny: tmp2 isExpired.  self deny: tmp3 isExpired.  scheduler stopTimerEventLoop.  self assert: tmp2 isExpired.  self assert: tmp3 isExpiredpositive  ^trueclear  kind := #NoTrailer.  size := 4.  data := encodedData := method := nilgetPreambleFrom: arg1 at: arg2  ^SourceFiles getPreambleFrom: arg1 at: arg2exception  ^exceptionaddAllMethodsFrom: arg1  arg1 methodSelectors do: [:arg2 |  self addMethodSelector: arg2 ]defaultLabel  ^super defaultLabel , ': ' , self printStringinnerBindingOf: arg1  ^self instanceSide innerBindingOf: arg1removeSubclass: arg1  shiftLevelUp  < metaLinkOptions: #(+ optionDisabledLink)>  level ifNil: [ level := 0 ].  level := level rfPlus: 1testDateTimeDenotation1  | tmp1 tmp2 tmp3 |  tmp1 := DateAndTime year: 2004 month: 11 day: 2 hour: 14 minute: 0 second: 0 offset: 0 hours.  tmp2 := tmp1 offset: -5 hours.  tmp3 := '2004-11-02T09:00:00-05:00' asDateAndTime.  self assert: tmp2 equals: tmp3isNotNil  ^falseprintMinutes  ^String new: 8 streamContents: [:arg1 |  self print24: false showSeconds: false on: arg1 ]testAsStringWithCommas  self assert: 123456789 asStringWithCommas equals: '123,456,789'.  self assert: -123456789 asStringWithCommas equals: '-123,456,789'insetBy: arg1  ^arg1 asMargin insetRectangle: selfpsValueAt: arg1  env ifNil: [ ^nil ].  ^env at: arg1 ifAbsent: niltestBitShift  1 to: 257 do: [:arg1 |  self should: [ ((arg1 bitShift: arg1) bitShift: 0 - arg1) == arg1 ] ]isTwoDigitDayPattern  ^patternStream peekFor: $dtearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  super tearDowninitializeWith: arg1 stackPtr: arg2 method: arg3 receiver: arg4 sender: arg5  pc := arg1.  stackp := arg2.  method := arg3.  receiver := arg4.  sender := arg5basicIdentityHash  < primitive: 175>  self primitiveFailedprintString  ^String streamContents: [:arg1 |  self printOn: arg1 base: 10 ]printDateAndTime: arg1 withLeadingSpace: arg2 on: arg3  self printYMD: arg1 withLeadingSpace: arg2 on: arg3.  arg3 nextPut: $T.  self printHMS: arg1 separatedBy: $: on: arg3.  arg1 nanoSecond ~= 0 ifTrue: [ | tmp1 tmp2 |        tmp1 := arg1 nanoSecond.        tmp2 := 9.        [ tmp1 \\ 10 = 0 ] whileTrue: [ tmp1 := tmp1 / 10.              tmp2 := tmp2 - 1 ].        arg3 nextPut: $..        tmp1 printOn: arg3 base: 10 length: tmp2 padded: true ].  arg3 nextPut: (arg1 offset positive ifTrue: [ $+ ] ifFalse: [ $- ]).  arg1 offset hours abs printOn: arg3 base: 10 length: 2 padded: true.  arg3 nextPut: $:.  arg1 offset minutes abs printOn: arg3 base: 10 length: 2 padded: true.  arg1 offset seconds = 0 ifFalse: [ arg3           nextPut: $:;           print: arg1 offset seconds abs truncated ]untagFrom: arg1  | tmp1 tmp2 |  tmp1 := self package.  tmp2 := tmp1 classTagForClass: self.  tmp2 ifNil: [ ^#() ].  tmp2 isRoot ifTrue: [ ^#() ].  tmp2 name = arg1 ifFalse: [ ^self ].  tmp2 removeClass: self.  tmp1 addClass: selftestHugeIntegerCloseTo  self deny: (1.0 closeTo: 200 factorial).  self deny: (200 factorial closeTo: 1.0).  self assert: (Float infinity closeTo: 200 factorial) equals: (200 factorial closeTo: Float infinity)withMethodsReferTo: arg1 do: arg2  | tmp1 |  tmp1 := Smalltalk specialSelectorIndexOrNil: arg1.  self selectorsAndMethodsDo: [:arg3 :arg4 |  ((arg4 hasLiteral: arg1) or: [ tmp1 notNil and: [ arg4 scanFor: arg4 encoderClass firstSpecialSelectorByte + tmp1 ] ]) ifTrue: [ arg2 value: arg4 ] ]copy  ^selfpropertyAt: arg1 ifAbsent: arg2  | tmp1 |  ^(tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 propertyAt: arg1 ifAbsent: arg2 ] ifFalse: [ arg2 value ]mcWorkingCopy  MCWorkingCopy managersForClass: self methodClass selector: self selector do: [:arg1 |  ^arg1 ]asDraggableMorph  ^self asStringMorphclassPool  ^classPool ifNil: [ classPool := Dictionary new ]testTo  self assert: (aDateAndTime to: aDateAndTime) equals: ((DateAndTime year: 1980 month: 1 day: 1) to: (DateAndTime year: 1980 month: 1 day: 1))classify: arg1 under: arg2  self classify: arg1 under: arg2 suppressIfDefault: true<= arg1  arg1 class = self class ifTrue: [ ^self asFraction <= arg1 asFraction ].  ^self asFraction <= arg1hasLiteralSuchThat: arg1  ^falsecalypsoEnvironmentType  ^ClyClasstestYesterday  self deny: aDateAndTime equals: DateAndTime yesterdayobject  ^objecttestPrintString  self assert: Object new printString equals: 'an Object'return  self return: self receiverisValid  ^trueprintOn: arg1  arg1 nextPutAll: ((self method hasSourceCode or: [ self class environment includesKey: #FBDDecompiler ]) ifTrue: [ self sourceNode formattedCode ] ifFalse: [ 'aBlockClosure(no source code or decompiler available)' ])breakDependents  self myDependents: nilasWeek  ^self asDateAndTime asWeekschedule: arg1  arg1 beingWaitedOn ifTrue: [ ^self error: 'This Delay has already been scheduled.' ].  readyToSchedule wait.  delayToStart := arg1.  timingSemaphore signalisPowerOfTwo  ^numerator = 1 and: [ denominator isPowerOfTwo ]subtractDate: arg1  ^(self start - arg1 asDateAndTime) daystest32bitGradualUnderflow  | tmp1 tmp2 tmp3 |  tmp1 := 2r0.11111111111111111111111e-126 asIEEE32BitWord.  tmp3 := 0.  tmp2 := tmp3 bitOr: 2r11111111111111111111111.  self assert: tmp2 equals: tmp1.  tmp1 := 2r0.00000000000000000000001e-126 asIEEE32BitWord.  tmp2 := tmp3 bitOr: 2r1.  self assert: tmp2 equals: tmp1.  tmp1 := 2r0.000000000000000000000011e-126 asIEEE32BitWord.  tmp2 := tmp3 bitOr: 2r10.  self assert: tmp2 equals: tmp1.  tmp1 := 2r0.000000000000000000000101e-126 asIEEE32BitWord.  tmp2 := tmp3 bitOr: 2r10.  self assert: tmp2 equals: tmp1.  tmp1 := 2r0.0000000000000000000001011e-126 asIEEE32BitWord.  tmp2 := tmp3 bitOr: 2r11.  self assert: tmp2 equals: tmp1crTrace: arg1  Transcript cr.  self trace: arg1growto: arg1  ^self copyto: (self species new: arg1)push: arg1  self stackp: stackp + 1.  self at: stackp put: arg1testReadFromNoOffset  self assert: (DateAndTime readFrom: '2010-01-05T20:33:14.321' readStream) offset equals: DateAndTime localOffsetisCurrencySymbol  ^self characterSet isCurrencySymbol: selfpreviousPcWithCorrectMapping  | tmp1 |  tmp1 := self isDead ifTrue: [ self startpc ] ifFalse: [ self previousPc ifNil: [ self startpc ] ].  [ self isPushLiteralNil: tmp1 ] whileTrue: [ tmp1 := tmp1 + 1 ].  [ self isPushTemp: tmp1 ] whileTrue: [ tmp1 := tmp1 + 1 ].  (self isBlockReturn: tmp1) ifTrue: [ tmp1 := tmp1 - 1 ].  ^tmp1runSimulated: arg1 contextAtEachStep: arg2  | tmp1 tmp2 tmp3 |  arg1 hasMethodReturn ifTrue: [ self error: 'simulation of blocks with ^ can run loose' ].  tmp1 := [ arg1 on: Exception do: [:arg3 |  SimulationExceptionWrapper signalForException: arg3 ] ] asContext.  tmp2 := Context sender: nil receiver: self home receiver method: self home method arguments: self home arguments.  tmp1 pushArgs: Array new from: tmp2.  [ tmp1 == tmp2 ] whileFalse: [ arg2 value: tmp1.        tmp1 := tmp1 step ].  tmp3 := tmp2 pop.  tmp3 class == SimulationExceptionWrapper ifTrue: [ ^tmp3 exception signal ].  ^tmp3lowIOPriority  ^LowIOPrioritynonResumableFallOffTheEndHandlerResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingExceptionalString;     add: self doYetAnotherThingString;     yourselftestPharoEpoch  self useNonUtcTimeZoneDuring: [ | tmp1 |        tmp1 := '1901-01-01T00:00:00' asDateAndTime.        self deny: DateAndTime epoch equals: tmp1.        self deny: ((DateAndTime fromSeconds: 0) offset: 0) equals: tmp1 ].  self useTimeZone: 'UTC' during: [ | tmp1 |        tmp1 := '1901-01-01T00:00:00' asDateAndTime.        self assert: DateAndTime epoch equals: tmp1.        self assert: ((DateAndTime fromSeconds: 0) offset: 0) equals: tmp1 ].  self assert: DateAndTime epoch equals: '1901-01-01T00:00:00+00:00' asDateAndTime.  self assert: ((DateAndTime fromSeconds: 0) offset: 0) equals: '1901-01-01T00:00:00+00:00' asDateAndTimecontextTag  ^selfisCompiledBlock  ^trueduration  ^Duration zeroprintStringPadded: arg1  ^self printStringLength: arg1 padded: truetestSecondsSinceMidnightLocalTime  | tmp1 |  tmp1 := DateAndTime year: 1000 day: 100 hour: 0 minute: 0 second: 56 offset: 0 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 56.  tmp1 := DateAndTime year: 1000 day: 100 hour: 0 minute: 1 second: 56 offset: 0 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 60 + 56.  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 0 second: 56 offset: 0 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 3600 + 56.  tmp1 := DateAndTime year: 1000 day: 100 hour: 0 minute: 0 second: 56 offset: 1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 56.  tmp1 := DateAndTime year: 1000 day: 100 hour: 0 minute: 1 second: 56 offset: 1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 60 + 56.  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 0 second: 56 offset: 1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 3600 + 56.  tmp1 := DateAndTime year: 1000 day: 100 hour: 0 minute: 0 second: 56 offset: -1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 56.  tmp1 := DateAndTime year: 1001 day: 101 hour: 0 minute: 1 second: 56 offset: -1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 60 + 56.  tmp1 := DateAndTime year: 1002 day: 102 hour: 1 minute: 0 second: 56 offset: -1 hours.  self assert: tmp1 secondsSinceMidnightLocalTime equals: 3600 + 56initialize  default := ExactFloatPrintPolicy newastForStylingInCalypso  ^self aststringForFileOut  ^self protocolOrganizer stringForFileOuttestToday  self deny: aDateAndTime equals: DateAndTime todayextendingPackages  ^RPackage organizer extendingPackagesOf: selfseasideUrl  ^selfmethodDict  ^methodDict ifNil: [ MethodDictionary new ]isOpenPunctuation  ^self characterSet isOpenPunctuation: selftestMinutes  self assert: aDateAndTime minutes equals: 0testNaNisLiteral  self deny: Float nan isLiteral description: 'there is no literal representation of NaN'failPrimitiveWith: arg1  self skipCallPrimitive.  ((self isPrimFailToken: arg1) and: [ method encoderClass isStoreAt: pc in: method ]) ifTrue: [ self at: stackp put: arg1 last ]testNameOfDay  | tmp1 tmp2 |  tmp2 := self dateClass nameOfDay: 1.  self assert: tmp2 equals: #Sunday.  tmp1 := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).  (1 to: 7) do: [:arg1 |  | tmp3 |        tmp3 := self dateClass nameOfDay: arg1.        self assert: tmp3 equals: (tmp1 at: arg1) ]testLessThan  self assert: aDateAndTime < (aDateAndTime + '1:00:00:00').  self assert: aDateAndTime + -1 < aDateAndTimegenPushRemoteTemp: arg1 inVectorAt: arg2  (arg1 >= 0 and: [ arg1 < 256 and: [ arg2 >= 0 and: [ arg2 < 256 ] ] ]) ifTrue: [ stream           nextPut: 140;           nextPut: arg1;           nextPut: arg2.        ^self ].  arg1 >= 256 ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: arg1 range: 0 to: 255 ].  arg2 >= 256 ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: arg2 range: 0 to: 255 ]notifyOfAddedCategory: arg1  self hasSubject ifFalse: [ ^self ].  SystemAnnouncer uniqueInstance protocolAdded: arg1 inClass: self subjecttestNewProcessWith  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := false.  tmp2 := [:arg1 :arg2 |  tmp5 := arg1.  tmp6 := arg2.  tmp1 := true ].  tmp4 := #(1 2).  tmp3 := tmp2 newProcessWith: tmp4.  self deny: tmp1.  self assert: (tmp3 isKindOf: Process).  self assert: tmp3 isSuspended.  tmp3 resume.  [ tmp3 isTerminated ] whileFalse: [ Processor yield ].  self assert: {tmp5 .         tmp6} equals: tmp4testInclusion  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := timespan start.  tmp2 := timespan start + (timespan duration / 2).  tmp3 := timespan end.  tmp4 := timespan start + timespan duration.  self     assert: (timespan includes: tmp1);     assert: (timespan includes: tmp2);     assert: (timespan includes: tmp3)numberOfReservedLiterals  ^2signal: arg1  self messageText: arg1.  ^self signalhigh16Bits  ^value >> 16simpleResignalAsTest  [ self doSomething.  MyTestNotification signal.  self doSomethingElse ] on: MyTestNotification do: [:arg1 |  arg1 resignalAs: MyTestError new ]setTimestampInMetacelloConfig: arg1  arg1 setTimestampWithString: self printStringterminate  | tmp1 tmp2 tmp3 |  terminating := self isTerminating ifTrue: [ ^ProcessAlreadyTerminating signal ] ifFalse: [ true ].  self isActiveProcess ifTrue: [ tmp1 := thisContext.        [ tmp1 := tmp1 findNextUnwindContextUpTo: nil.        tmp1 isNil ] whileFalse: [ (tmp1 tempAt: 2) ifNil: [ tmp1 tempAt: 2 put: nil.                    tmp2 := tmp1 tempAt: 1.                    thisContext terminateTo: tmp1.                    tmp2 value ] ].        thisContext terminateTo: nil.        self suspend ] ifFalse: [ tmp3 := self suspend.        suspendedContext ifNotNil: [ suspendedContext := tmp3 handleProcessTerminationOfWaitingContext: suspendedContext.              (suspendedContext findNextUnwindContextUpTo: nil) ifNotNil: [:arg1 |  (suspendedContext findContextSuchThat: [:arg2 |  arg2 closure == (arg1 tempAt: 1) ]) ifNotNil: [:arg3 |  suspendedContext runUntilErrorOrReturnFrom: arg3 ] ].              tmp1 := self popTo: suspendedContext bottomContext.              [ tmp1 == suspendedContext bottomContext ] whileFalse: [ | tmp4 |                    tmp4 := tmp1 copyStack.                    [ UnwindError signalIn: tmp4 ] forkNamed: 'Unwind error during termination'.                    tmp1 terminateTo: tmp1 sender.                    tmp1 := self popTo: suspendedContext bottomContext ].              (suspendedContext notNil and: [ suspendedContext isBottomContext ]) ifTrue: [ suspendedContext pc: nil ] ] ]testArray  self assertCode: '#(1 2 3)' print: '#(1 2 3)'.  self assertCode: '{1 . 2 . 3}' print: '#(1 2 3)'.  self assertCode: '{1 + 0 . 2 . 3}' print: '#(1 2 3)'.  self assertCode: '{1 + 0 . 1 @ 2 . 3}' print: '{1. (1@2). 3}'.  self assertCode: '{2@3}' print: '{(2@3)}'.  self assertCode: '{Object new}' print: 'an Array(an Object)'.  self assertCode: '{Rectangle new . Object new}' print: 'an Array(nil corner: nil an Object)'.  self assertCode: '{10@10 corner: 20@20 . 100@100 corner: 200@200}' print: '{(10@10) corner: (20@20). (100@100) corner: (200@200)}'decompile  ^Smalltalk globals at: #FBDDecompiler ifPresent: [:arg1 |  arg1 new decompile: self ] ifAbsent: [ RBParser parseMethod: self selector asMethodPreamble , '	self noSourceAvailable' ]classDepth  self superclass ifNil: [ ^1 ].  ^self superclass classDepth + 1testIsFormatOther  self checkCorrespondanceOf: #isFormatOther: and: #CfisMethodProperties  ^trueprint: arg1 on: arg2  arg2 nextPut: selftestSimpleRetry  self assertSuccess: (ExceptionTester new runTest: #simpleRetryTest)isMethodProperties  ^falsetestAsNanoSeconds  self assert: aDateAndTime asNanoSeconds equals: aDuration asNanoSeconds.  self assert: aDateAndTime asNanoSeconds equals: 48780000000000sizePushRemoteTemp: arg1 inVectorAt: arg2  ^self sizeOpcodeSelector: #genPushRemoteTemp:inVectorAt: withArguments: {arg1 .         arg2}testCannotReturn  | tmp1 |  tmp1 := self constructCannotReturnBlockInDeadFrame.  self should: [ tmp1 value: 1 ] raise: ExceptionparseMonth  self isTwoDigitMonthPattern ifTrue: [ ^self parseTwoDigitMonth ].  self parseVariableDigitMonthtraversableInstVarIndexes  ^1 to: self class instSizeprintOn: arg1  self print24: false showSeconds: (self seconds ~= 0 or: [ self nanoSecond ~= 0 ]) on: arg1longPrintStringLimitedTo: arg1  | tmp1 |  tmp1 := String streamContents: [:arg2 |  self longPrintOn: arg2 limitedTo: arg1 indent: 0 ].  ^tmp1 isEmpty ifTrue: [ self printString , String cr ] ifFalse: [ tmp1 ]testToday  self deny: aDateAndTime equals: DateAndTime todayremoveActionsWithReceiver: arg1 forEvent: arg2  self removeActionsSatisfying: [:arg3 |  arg3 receiver == arg1 ] forEvent: arg2perform: arg1 with: arg2 with: arg3 with: arg4  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: arg1 withArguments: {arg2 .         arg3 .         arg4}clone  < primitive: 148 error: ec>  | tmp1 tmp2 |  ec == #'insufficient object memory' ifFalse: [ ^self primitiveFailed ].  tmp2 := (tmp1 := self class) isVariable ifTrue: [ tmp1 isCompiledMethodClass ifTrue: [ tmp1 newMethod: self basicSize - self initialPC + 1 header: self header ] ifFalse: [ tmp1 basicNew: self basicSize ] ] ifFalse: [ tmp1 basicNew ].  ^tmp2 copyFrom: selfclassToBeTested  ^self timeClassisTestMethod  self numArgs isZero ifFalse: [ ^false ].  ((self selector beginsWith: 'test') or: [ self selector beginsWith: 'should' ]) ifFalse: [ ^false ].  self methodClass isTestCase ifFalse: [ ^false ].  ^truetestallMethodsReadingSlot  | tmp1 |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  tmp1 := LookupKey allMethodsReadingSlot: (LookupKey slotNamed: #key).  self assert: (tmp1 includes: Ephemeron >> #mourn)testLessThan  self assert: aDateAndTime < (aDateAndTime + '1:00:00:00').  self assert: aDateAndTime + -1 < aDateAndTimepragmas  | tmp1 |  tmp1 := WriteStream on: (Array new: self basicSize).  1 to: self basicSize do: [:arg1 |  | tmp2 |        (tmp2 := self basicAt: arg1) isVariableBinding ifFalse: [ tmp1 nextPut: tmp2 ] ].  ^tmp1 contentsgenJump: arg1  (arg1 > 0 and: [ arg1 < 9 ]) ifTrue: [ stream nextPut: 175 + arg1.        ^self ].  ^self genJumpLong: arg1valueUnpreemptively  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Processor activeProcess.  tmp2 := tmp1 priority.  tmp1 priority: Processor highestPriority.  tmp3 := self ensure: [ tmp1 priority: tmp2 ].  tmp4 := Semaphore new.  [ tmp4 signal ] fork.  tmp4 wait.  ^tmp3addObsoleteSubclass: arg1  simpleRetryUsingTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:arg1 |  arg1 retryUsing: [ self doYetAnotherThing ] ]fromNumber: arg1  self setTop: arg1 left: arg1 bottom: arg1 right: arg1protocolOrganizer: arg1  protocolOrganizer := arg1initializeParsing  invalidPattern := false.  patternStream := pattern readStreamtestIsLowercase  self checkCorrespondanceOf: #isLowercase: and: #LlliteralStrings  | tmp1 |  tmp1 := OrderedCollection new: self numLiterals.  self literalsDo: [:arg1 |  arg1 isVariableBinding ifTrue: [ tmp1 addLast: arg1 key ] ifFalse: [ arg1 isSymbol ifTrue: [ tmp1 addAll: arg1 keywords ] ifFalse: [ tmp1 addLast: arg1 printString ] ] ].  ^tmp1tagWith: arg1  | tmp1 tmp2 |  tmp1 := self package.  tmp2 := tmp1 addClassTag: arg1.  tmp2 addClass: selfreformat  self methodClass compile: self ast formattedCode classified: self categorydependentClasses  | tmp1 |  tmp1 := Set new.  self superclass ifNotNil: [ tmp1 add: self superclass ].  self methods , self classSide methods do: [:arg1 |  arg1 literalsDo: [:arg2 |  ((((arg2 isVariableBinding and: [ arg2 value notNil ]) and: [ arg2 value isBehavior ]) and: [ arg1 category notEmpty ]) and: [ arg1 category first ~= $* ]) ifTrue: [ tmp1 add: arg2 value ] ] ].  ^tmp1 asArrayisTwoDigitYearPattern  ^patternStream peekFor: $yuses: arg1 slots: arg2  | tmp1 |  tmp1 := self instanceSide.  tmp1 := tmp1 classInstaller update: tmp1 to: [:arg3 |  arg3           fillFor: tmp1;           classTraitComposition: arg1 asTraitComposition;           classSlots: arg2 ].  ^tmp1 classSidelistAtCategoryNamed: arg1  | tmp1 |  tmp1 := categoryArray indexOf: arg1 ifAbsent: [ ^Array new ].  ^self listAtCategoryNumber: tmp1compile: arg1 notifying: arg2  ^self compile: arg1 classified: Protocol unclassified notifying: arg2methodsReferencingClasses: arg1  ^self methods select: [:arg2 |  arg2 referencedClasses includesAny: arg1 ]classForTicker  ^DelayMicrosecondTickerSimulationremoveSlot: arg1  (self classLayout slots includes: arg1) ifFalse: [ self error: arg1 name , ' is not one of my slots' ].  ^self classInstaller update: self to: [:arg2 |  arg2           fillFor: self;           slots: (self classLayout slots copyWithout: arg1) ]treeNodeHead  ^selfisLowercase  ^self characterSet isLowercase: selfcomment  commentRemoteString ifNil: [ ^'' ].  ^commentRemoteString string ifNil: [ '' ]asCollectionElement  removeProtocol: arg1  | tmp1 |  tmp1 := self protocolOrganizer allProtocolsNames copy.  self protocolOrganizer removeProtocol: arg1.  self notifyOfRemovedCategory: arg1 name.  self notifyOfChangedCategoriesFrom: tmp1 to: self protocolOrganizer allProtocolsNamesasRingMinimalDefinitionIn: arg1  ^RGMetaclass named: self name parent: arg1hasAbstractMethods  ^super hasAbstractMethods or: [ self classSide hasAbstractMethods ]testFromDateAndTime  | tmp1 |  tmp1 := DosTimestamp fromDateAndTime: '21 May 2012 3:02:44 pm' asDateAndTime.  self assert: tmp1 value equals: 16r40B57856asNonFractionalPoint  (x isFraction or: [ y isFraction ]) ifTrue: [ ^x asFloat @ y asFloat ]testLiteralsDoesNotContainMethodName  self deny: (self compiledMethod1 hasLiteralThorough: #method1)cull: arg1 cull: arg2 cull: arg3  ^numArgs < 3 ifTrue: [ self cull: arg1 cull: arg2 ] ifFalse: [ self value: arg1 value: arg2 value: arg3 ]duringTestCompileSilently: arg1  ^self duringTestCompileSilently: arg1 storeSource: truehasInstVarNamed: arg1  ^self instVarNames includes: arg1testOneCanProceedWhenIntroducingClasseVariablesBeginingWithLowerCaseCharacters  | tmp1 |  [ tmp1 := classFactory newSubclassOf: classFactory defaultSuperclass instanceVariableNames: 'a BVarName' classVariableNames: '' ] on: Exception do: [:arg1 |  arg1 resume ].  self assert: (testingEnvironment keys includes: tmp1 name)retrySelector: arg1  retrySelector := arg1classUnderTest  ^AsciiCharsetfactorial  self = 0 ifTrue: [ ^1 ].  self > 0 ifTrue: [ ^self * (self - 1) factorial ].  self error: 'Not valid for negative integers'noon  ^self dayMonthYearDo: [:arg1 :arg2 :arg3 |  self class year: arg3 month: arg2 day: arg1 hour: 12 minute: 0 second: 0 offset: offset ]setLeft: arg1 right: arg2 top: arg3 bottom: arg4  origin := (arg1 min: arg2) @ (arg3 min: arg4).  corner := (arg1 max: arg2) @ (arg3 max: arg4)absPrint: arg1 on: arg2 base: arg3  ^arg1 absPrintInexactlyOn: arg2 base: arg3activePriority  ^activeProcess effectiveProcess priorityrfvalue  < primitive: 207>  < metaLinkOptions: #(+ optionDisabledLink)>  | tmp1 |  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  false ifTrue: [ tmp1 := self asContextWithSender: thisContext sender.        thisContext privSender: tmp1 ] ifFalse: [ self primitiveFailed ]willCreateBlock  ^self method encoderClass isCreateBlockAt: pc in: self methodbrowserPrintString  ^self browserPrintStringWith: suspendedContextbasicSuperclass: arg1  superclass := arg1pushClosureCopyNumCopiedValues: arg1 numArgs: arg2 blockSize: arg3  | tmp1 |  arg1 > 0 ifTrue: [ tmp1 := Array new: arg1.        arg1 to: 1 by: -1 do: [:arg4 |  tmp1 at: arg4 put: self pop ] ] ifFalse: [ tmp1 := nil ].  self push: (BlockClosure outerContext: self startpc: pc numArgs: arg2 copiedValues: tmp1).  self jump: arg3update: arg1 with: arg2  ^self update: arg1testFromDos  | tmp1 |  tmp1 := DateAndTime fromDosTimestamp: 16r40B57856.  self assert: tmp1 equals: '21 May 2012 3:02:44 pm' asDateAndTime.  self assert: tmp1 offset equals: DateAndTime localOffsettestMultiSchedule  | tmp1 tmp2 |  tmp1 := Delay forSeconds: 1000.  scheduler schedule: tmp1.  self assert: tmp1 beingWaitedOn.  self should: [ scheduler schedule: tmp1 ] raise: Error.  [ tmp2 := Delay forMilliseconds: 1000.  scheduler schedule: tmp2 ] forkAt: Processor activePriority + 1.  self assert: tmp2 beingWaitedOntestInjectingExceptionHandlerIntoRunningProcess  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  DefaultExecutionEnvironment beActive.  tmp1 := Error new messageText: 'test error'.  tmp4 := Semaphore new.  tmp5 := false.  tmp6 := true.  tmp3 := [ tmp5 := true.  tmp4 wait.  tmp1 signal.  tmp6 := false ] newProcess.  tmp3 resume.  [ tmp5 ] whileFalse: [ Processor yield ].  tmp3 on: Error do: [:arg1 |  tmp2 := arg1 ].  tmp4 signal.  [ tmp3 isTerminated ] whileFalse: [ Processor yield ].  self assert: tmp2 identicalTo: tmp1.  self assert: tmp6setNamedPrimitiveInformationFrom: arg1 toMethod: arg2  | tmp1 |  tmp1 := arg2 literalAt: 1.  tmp1 replaceFrom: 1 to: tmp1 size with: (arg1 literalAt: 1) startingAt: 1testMinimumNegativeIntegerArithmetic  #(32 64) do: [:arg1 |  | tmp1 tmp2 |        tmp1 := 1 << (arg1 - 1).        tmp2 := tmp1 negated.        self assert: tmp2 >> 3 equals: (tmp2 bitInvert >> 3) bitInvert.        self assert: tmp2 + 1 equals: (tmp1 - 1) negated.        self assert: tmp2 - -1 equals: (tmp1 - 1) negated.        self assert: tmp2 // -1 equals: tmp1.        self assert: tmp2 \\ -1 equals: 0.        self assert: (tmp2 rem: -1) equals: 0.        self assert: (tmp2 quo: -1) equals: tmp1.        self assert: tmp2 * -1 equals: tmp1.        self assert: tmp2 / -1 equals: tmp1 ]testNewDayMonthYear  self assert: (Date year: 2004 month: 1 day: 23) equals: january23rd2004testPercent  self assert: 20 / 40 equals: 50 percentmethodNode  ^self parseTreetestAsMonth  self assert: aDateAndTime asMonth equals: (Month year: 1901 month: 'January')testNanoSeconds  self assert: aDuration nanoSeconds equals: 5.  self assert: (Duration nanoSeconds: 5) nanoSeconds equals: 5cannotReturn: arg1  closureOrNil ifNotNil: [ ^BlockCannotReturn result: arg1 from: self home ].  Processor activeProcess debug: thisContext title: 'computation has been terminated'displayStringOn: arg1  self printOn: arg1wholeNanoseconds  ^nanos rem: 1e3valueSuppressingMessages: arg1 supplyingAnswers: arg2  ^self valueSupplyingAnswers: arg2 , (arg1 collect: [:arg3 |  {arg3 .                     true} ])getName  ^nametestAsWeek  self assert: aDateAndTime asWeek equals: (Week starting: '12-31-1979' asDate)runTestsBy: arg1  self subclassResponsibilitytestDegreeSin  45 degreeSin.  self assert: (45 degreeSin squared - (1 / 2)) abs <= Float epsilon.  self assert: (30 degreeSin - (1 / 2)) abs <= Float epsilon.  self assert: (-30 degreeSin + (1 / 2)) abs <= Float epsilon.  -360 to: 360 do: [:arg1 |  self assert: (arg1 degreeSin closeTo: arg1 degreesToRadians sin) ].  -10 to: 10 do: [:arg2 |  self assert: (arg2 * 360 + 90) degreeSin - 1 equals: 0.        self assert: (arg2 * 360 - 90) degreeSin + 1 equals: 0.        self assert: (arg2 * 360 + 180) degreeSin equals: 0.        self assert: (arg2 * 360) degreeSin equals: 0 ]testEquals  | tmp1 tmp2 |  tmp1 := january23rd2004 translateTo: -8 hours.  tmp2 := january23rd2004 translateTo: 10 hours.  self     assert: (january23rd2004 equals: tmp1);     assert: (january23rd2004 equals: tmp2);     assert: (tmp1 equals: tmp2);     assert: (january23rd2004 equals: june2nd1973) notdoubleResumeTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingElseString;     add: self doYetAnotherThingString;     yourselfwillBlockReturn  ^self method encoderClass isBlockReturnAt: pc in: self methodtestSimpleResume  self assertSuccess: (ExceptionTester new runTest: #simpleResumeTest)referencedClasses  ^self methods flatCollectAsSet: #referencedClassesstamp  ^self timeStamp> arg1  < primitive: 544>  ^arg1 adaptToFloat: self andCompare: #>localMessages  | tmp1 tmp2 |  tmp2 := IdentitySet new.  tmp1 := InstructionStream on: self.  tmp1 scanFor: [:arg1 |  tmp1 addSelectorTo: tmp2.        false ].  ^tmp2testIsOtherLetter  self checkCorrespondanceOf: #isOtherLetter: and: #LowaitFor: arg1  [ 10 milliSeconds wait.  arg1 value ] whileFalsesupportsClosureOpcodes  ^falseasFloat  ^super asFloat negatedparseTwoDigitDay  day := self parse: 'day' expectedSize: 2dates  | tmp1 |  tmp1 := OrderedCollection new.  self datesDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1 asArrayfork  ^self newProcess resumeprintStringHex  ^self asInteger printStringBase: 16reBanName  ^self name , ' (Class)'testSimpleEnsureTestWithError  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithError)expanded  ^Rectangle origin: origin floor corner: corner ceilingtransposed  ^y @ xmonthName  ^Month nameOfMonth: self monthcorner  ^cornertestMethodContext  self assert: aMethodContext home notNil.  self assert: aMethodContext receiver notNil.  self assert: (aMethodContext method isKindOf: CompiledMethod)testReadFrom  | tmp1 |  tmp1 := Month readFrom: 'July 1998' readStream.  self assert: tmp1 equals: monthprintOn: arg1  arg1 nextPutAll: 'a descendent of '.  self superclass printOn: arg1setUp  super setUp.  testClass := Object newAnonymousSubclasstestIntegerAsFloat  self deny: 16r1FFFFFFFFFFFF0801 asFloat equals: 16r1FFFFFFFFFFFF0800 asFloat.  self deny: 16r1FFFFFFFFFFFF0802 asFloat equals: 16r1FFFFFFFFFFFF0800 asFloat.  self assert: 16r1FFFFFFFFFFF1F800 asFloat equals: 16r1FFFFFFFFFFF20000 asFloat.  self assert: 16r1FFFFFFFFFFFF0800 asFloat equals: 16r1FFFFFFFFFFFF0000 asFloatstepToSendOrReturn  | tmp1 |  [ self isDead or: [ self willSend or: [ self willReturn or: [ self willStore or: [ self willCreateBlock ] ] ] ] ] whileFalse: [ tmp1 := self step.        tmp1 == self ifFalse: [ ^tmp1 ] ]new  thisClass class ~~ self ifTrue: [ ^thisClass := self basicNew ] ifFalse: [ self error: 'A Metaclass should only have one instance!' ]closeTo: arg1 precision: arg2  arg1 isFloat ifTrue: [ ^arg1 closeTo: self asFloat precision: arg2 ].  ^[ self = arg1 ] ifError: [ false ]basicSize  < primitive: 62>  ^0visibleMethods  ^self methodsselector  ^self subclassResponsibilitytestMiddleOf  self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) equals: (Timespan starting: '12-31-1969' asDate duration: 2 days)fuelAccept: arg1  ^arg1 visitClass: selfban: arg1  ReSystemAnnouncer uniqueInstance notifyCritique: arg1 of: arg1 sourceAnchor entity bannedOn: self.  (TheManifestBuilder of: self) banRule: arg1 rule for: selfstandardMessageText  ^String streamContents: [:arg1 |  arg1 print: self selector.        arg1 << ' should have been implemented in '.        arg1 print: self signaler class ]testAllSelectors  self assert: ProtoObject allSelectors asSet equals: ProtoObject selectors asSet.  self assert: Object allSelectors asSet equals: (Object selectors asSet union: ProtoObject selectors).  self assert: (Object allSelectorsBelow: ProtoObject) asSet equals: Object selectors asSetdaysInYear  ^self asYear daysInYeararcTan  ^self asFloat arcTanstart  ^startactionSequenceForEvent: arg1  ^(self actionMap at: arg1 asSymbol ifAbsent: [ ^WeakActionSequence new ]) asActionSequencehighBitOfMagnitude  self < 0 ifTrue: [ ^self negated highBitOfMagnitude ].  ^self highBitOfPositiveReceivermethodsInProtocol: arg1  ^(self organization listAtCategoryNamed: arg1) collect: [:arg2 |  self compiledMethodAt: arg2 ]asNanoSeconds  ^self asDuration asNanoSecondsgtInspectorSourceCodeIn: arg1  < gtInspectorPresentationOrder: 40>  ^(self sourceNode gtInspectorSourceCodeIn: arg1)     doItReceiver: [ self receiver ];     doItContext: [ self outerContext ]interpret  | tmp1 |  tmp1 := self method endPC.  [ pc > tmp1 ] whileFalse: [ self interpretNextInstructionFor: self ]= arg1  < primitive: 7>  ^super = arg1testUtcOffset  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1970-01-01T12:00:00+12:00' asDateAndTimecompact  | tmp1 |  tmp1 := self compactWithoutBecome.  tmp1 capacity = self capacity ifTrue: [ self copyFrom: tmp1 ] ifFalse: [ self becomeForward: tmp1 ]isAliasSelector: arg1  ^falsetestParsingPatternWithExtraCharacter  self assertReading: 'a4.2.2345' as: 'ad.m.y' equals: (Date year: 2345 month: 2 day: 4).  self assertReading: '4.2.2345' as: 'ad.m.y' raise: DateError.  self assertReading: 'a4.2.2345' as: 'd.m.y' raise: DateErrorprintHumanReadableOn: arg1  | tmp1 tmp2 |  tmp1 := false.  self negative ifTrue: [ arg1 << '- '.        ^self abs printHumanReadableOn: arg1 ].  #(#(days 'day') #(hours 'hour') #(minutes 'minute') #(seconds 'second') #(wholeMilliseconds 'millisecond') #(wholeMicroseconds 'microsecond') #(wholeNanoseconds 'nanosecond')) do: [:arg2 |  tmp2 := (self perform: arg2 first) truncated.        tmp2 > 0 ifTrue: [ tmp1 ifTrue: [ arg1 space ].              tmp2 printWithCommasOn: arg1.              arg1                 space;                 << (arg2 second asPluralBasedOn: tmp2).              tmp1 := true ] ].  tmp1 ifFalse: [ arg1 << '0 seconds' ]messageText: arg1  messageText := arg1radix: arg1  ^self printStringBase: arg1highIOPriority  ^HighIOPriorityrfeffectiveProcess  < metaLinkOptions: #(+ optionDisabledLink)>  ^effectiveProcess ifNil: [ self ]testDigitLength  | tmp1 |  tmp1 := -114605103402541699037609980192546360895434064385.  self assert: 20 equals: tmp1 bytesCounttestSeconds  self assert: aDateAndTime seconds equals: 0removeClassVarNamed: arg1  self removeClassVarNamed: arg1 interactive: falsenoMask: arg1  ^0 = (self bitAnd: arg1)selectorsToFileOutCategory: arg1  ^self organization listAtCategoryNamed: arg1storeString  ^String streamContents: [:arg1 |  self storeOn: arg1 ]soleInstance  ^thisClassspotterUsedTraitsFor: arg1  < spotterOrder: 60>  arg1 listProcessor     title: 'Uses Traits';     allCandidates: [ self traits asArray ];     itemIcon: #systemIcon;     filter: GTFilterSubstringnanoSecond  ^nanostestIsMathSymbol  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isMathSymbol: tmp2) equals: (tmp1 isMathSymbol: tmp2) ]assertWellMaterializedInto: arg1 in: arg2  arg2 assert: self ~~ arg1.  arg2 assert: self class == arg1 class.  arg2 assert: self tempNames = arg1 tempNames.  arg2 assert: pc = arg1 pc.  arg2 assert: stackp = arg1 stackPtr.  closureOrNil ifNil: [ arg2 assert: arg1 closure isNil ] ifNotNil: [ closureOrNil assertWellMaterializedInto: arg1 closure in: arg2 ].  arg2 assert: receiver = arg1 receiver.  arg2 assert: (method isEqualRegardlessTrailerTo: arg1 method).  sender ifNil: [ arg2 assert: arg1 sender isNil ] ifNotNil: [ sender assertWellMaterializedInto: arg1 sender in: arg2 ]debugStack: arg1 on: arg2  (self stackOfSize: arg1) do: [:arg3 |  arg3 printDebugOn: arg2.        arg2 cr ]wholeMilliseconds  ^nanos quo: 1e6testMethodTemps  | tmp1 tmp2 |  tmp1 := 0.  tmp1 := tmp1 + (self callcc: [:arg1 |  tmp2 := arg1.              1 ]).  self assert: tmp1 ~= 3.  tmp1 = 2 ifFalse: [ tmp2 value: 2 ]testAfterCriticalWait  | tmp1 tmp2 |  tmp1 := Semaphore new.  tmp2 := [ tmp1 critical: [  ] ] forkAt: Processor activePriority - 1.  [ tmp2 suspendingList == tmp1 ] whileFalse: [ (Delay forMilliseconds: 10) wait ].  tmp1 signal.  tmp2 terminate.  self assert: (tmp1 instVarNamed: #excessSignals) equals: 1doWhileFalse: arg1  | tmp1 |  [ tmp1 := self value.  arg1 value ] whileFalse.  ^tmp1testNew  self assert: Timespan new equals: (Timespan starting: '01-01-1901' asDate)testPrintOn  self assert: (String streamContents: [:arg1 |  aDuration printOn: arg1 ]) equals: '1:02:03:04.000000005'isPushTemp: arg1  ^self method encoderClass isPushTempAt: arg1 in: methodprintMSOn: arg1  self minute printOn: arg1 base: 10 length: 2 padded: true.  arg1 nextPut: $:.  self second printOn: arg1 base: 10 length: 2 padded: truephlowValue: arg1 withEnoughArguments: arg2  ^selfcopyWith: arg1  ^self copy     add: arg1;     yourselftestYear  self assert: aDateAndTime year equals: 2004storeOn: arg1  arg1 nextPutAll: 'nil'categories  ^self protocolOrganizer protocolsNamesbasicCheck: arg1  | tmp1 |  arg1 isMessage ifFalse: [ ^false ].  tmp1 := arg1 receiver.  tmp1 isVariable ifFalse: [ ^false ].  tmp1 isGlobal ifFalse: [ ^false ].  (self check: arg1 selector forDeprecationIn: tmp1 name) ifFalse: [ ^false ].  ^truecommentStamp: arg1  self organization commentStamp: arg1setUp  super setUp.  aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5testAsNanoSeconds  self assert: aDateAndTime asNanoSeconds equals: 0 asDuration asNanoSecondsgenStoreInstVarLong: arg1  self genStorePopInstVarLong: arg1.  self genPushInstVarLong: arg1analogousCodeTo: arg1  | tmp1 |  self class == arg1 class ifFalse: [ ^false ].  (tmp1 := self basicSize) = arg1 basicSize ifFalse: [ ^false ].  1 to: tmp1 do: [:arg2 |  ((self basicAt: arg2) analogousCodeTo: (arg1 basicAt: arg2)) ifFalse: [ ^false ] ].  ^trueincludesMethod: arg1  ^self methodDict identityIncludes: arg1lcm: arg1  ^self // (self gcd: arg1) * arg1daysInMonth  ^start daysInMonthroundDownTo: arg1  | tmp1 |  tmp1 := arg1 asPoint.  ^(x roundDownTo: tmp1 x) @ (y roundDownTo: tmp1 y)isDoneParsing  ^patternStream atEnd or: [ inputStream atEnd or: [ invalidPattern ] ]sourceCodeTemplate  ^'messageSelectorAndArgumentNames	"comment stating purpose of instance-side message"	"scope: class-variables  &  instance-variables"					| temporary variable names |	statements'methodsTaggedWith: arg1  ^self localMethods select: [:arg2 |  arg2 isTaggedWith: arg1 ]testEnvironment  ^testEnvironmentgetProtocolNamed: arg1 ifNone: arg2  ^protocols detect: [:arg3 |  arg3 name = arg1 ] ifNone: arg2asDosTimestamp  ^(DosTimestamp fromDateAndTime: self) valuestoreOn: arg1  | tmp1 |  self shouldBePrintedAsLiteral ifTrue: [ arg1           nextPut: $$;           nextPut: self ] ifFalse: [ tmp1 := self class constantNameFor: self.        tmp1 notNil ifTrue: [ arg1                 nextPutAll: self class name;                 space;                 nextPutAll: tmp1 ] ifFalse: [ arg1                 nextPut: $(;                 nextPutAll: self class name;                 nextPutAll: ' value: ';                 print: self asInteger;                 nextPut: $) ] ]isBlockContext  ^closureOrNil isClosureasDateAndTime  ^startisLiteral  ^falseexample2  < sampleInstance>  | tmp1 |  tmp1 := 1.  1 < 2 ifTrue: [ tmp1 ifNotNil: [ tmp1 := 'hallo' ] ].  ^tmp1setSubject: arg1  organizedClass := arg1second  ^self secondsgtInspectorInterestingObject  ^selfnegated  ^(0 - x) @ (0 - y)value  < primitive: 201>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  ^self primitiveFailedenclosedSetElement  self deprecated: 'Use #enclosedElement instead' transformWith: '`@receiver enclosedSetElement' -> '`@receiver enclosedElement'.  ^self enclosedElementtryPrimitive: arg1 withArgs: arg2  < primitive: 118 error: code>  ^Context primitiveFailTokenFor: coderemoveActionsForEvent: arg1  | tmp1 |  tmp1 := self actionMap.  tmp1 removeKey: arg1 asSymbol ifAbsent: [  ].  tmp1 isEmpty ifTrue: [ self releaseActionMap ]modificationForbiddenFor: arg1 value: arg2  ^self modificationForbiddenFor: arg1 index: nil value: arg2propertyAt: arg1 ifAbsent: arg2  1 to: self basicSize do: [:arg3 |  | tmp1 |        tmp1 := self basicAt: arg3.        (tmp1 isVariableBinding and: [ tmp1 key == arg1 ]) ifTrue: [ ^tmp1 value ] ].  ^arg2 valuegenStoreRemoteTemp: arg1 inVectorAt: arg2  (arg1 >= 0 and: [ arg1 < 256 and: [ arg2 >= 0 and: [ arg2 < 256 ] ] ]) ifTrue: [ stream           nextPut: 141;           nextPut: arg1;           nextPut: arg2.        ^self ].  arg1 >= 256 ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: arg1 range: 0 to: 255 ].  arg2 >= 256 ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: arg2 range: 0 to: 255 ]asEpiceaRingDefinition  ^(RGMethodDefinition named: self selector)     parentName: self methodClass name;     isMetaSide: self methodClass isMeta;     protocol: self category;     sourceCode: self sourceCode;     stamp: self timeStamp;     package: (self package ifNotNil: [:arg1 |  arg1 name ]);     yourselfaddMethodSelector: arg1  ^methodSelectors add: arg1canonicalArgumentName  ^'aClass'copyAllCategoriesFrom: arg1  arg1 organization categories do: [:arg2 |  self copyCategory: arg2 from: arg1 ]standardMessageText  ^String streamContents: [:arg1 |  arg1 print: self selector.        arg1 << ' should not have been implemented in '.        arg1 print: self signaler class ]parseTwoDigitMonth  month := self parse: 'month' expectedSize: 2testDay  self assert: aDateAndTime day equals: DateAndTime new dayremoveMethod: arg1  (self protocolsOfSelector: arg1) do: [:arg2 |  arg2 removeMethodSelector: arg1 ]allClassVariables  ^self withAllSuperclasses flatCollect: [:arg1 |  arg1 classVariables ]keysDo: arg1  tally = 0 ifTrue: [ ^self ].  1 to: self basicSize do: [:arg2 |  (self basicAt: arg2) ifNotNil: [:arg3 |  arg1 value: arg3 ] ]asRingMinimalDefinitionIn: arg1  self error: 'For Protocol you need to use #asRingMinimalDefinitionIn:parent: because parent class cannot be resolved automatically'/ arg1  < primitive: 550>  arg1 = 0.0 ifTrue: [ ^ZeroDivide signalWithDividend: self ].  ^arg1 adaptToFloat: self andSend: #/setBlessingInMetacelloConfig: arg1  arg1 setBlessingWithBlock: selftestIsInstalled  | tmp1 tmp2 |  tmp1 := self class >> #returnTrue.  self assert: tmp1 isInstalled.  Smalltalk removeClassNamed: #TUTU.  tmp2 := Object subclass: #TUTU instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self categoryNameForTemporaryClasses.  tmp2 compile: 'foo ^ 10'.  tmp1 := tmp2 >> #foo.  tmp2 removeSelector: #foo.  self deny: tmp1 isInstalled.  Smalltalk removeClassNamed: #TUTUvalueSuppressingAllMessages  ^self valueSuppressingMessages: #('*')protocolOrganizer  ^protocolOrganizer= arg1  < primitive: 547>  arg1 isNumber ifFalse: [ ^false ].  ^arg1 adaptToFloat: self andCompare: #=hasClassVariable: arg1  ^self classVariables identityIncludes: arg1simpleReturnTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     yourselftestNoArguments  | tmp1 tmp2 |  tmp1 := [:arg1 |  1 + 2 ].  tmp2 := [:arg2 :arg3 |  1 + 2 ].  [ 10 timesRepeat: tmp1 ] ifError: [:arg4 |  self deny: arg4 equals: 'This block requires 1 arguments.' ].  [ 10 timesRepeat: tmp2 ] ifError: [:arg4 |  self deny: arg4 equals: 'This block requires 2 arguments.' ]removeSelectorSilently: arg1  ^SystemAnnouncer uniqueInstance suspendAllWhile: [ self removeSelector: arg1 ]packToArity: arg1  self error: 'Use #rollAsFloatArity: or #rollAsDoubleArity:'testSchedulerTermination  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := false.  tmp2 := Semaphore new.  tmp4 := Semaphore new.  tmp1 := [ tmp2 signal.  tmp4 wait.  tmp3 := true ] forkAt: Processor activeProcess priority.  tmp2 wait.  tmp1 terminate.  tmp4 signal.  Processor yield.  self assert: tmp3 notorDefaultForUnresolved  ^selfremoveLink: arg1  self reflectiveMethod ifNotNil: [:arg2 |  arg2 removeLink: arg1 ]schedulerSignalWaitingProcess  beingWaitedOn := false.  process suspendingList == delaySemaphore ifTrue: [ expired := true.        process           suspend;           resume ]pcRange  ^self sourceNodeExecuted debugHighlightRangetestProxyObject: arg1 initialState: arg2 tuples: arg3  self testObject: arg1 initialState: arg2 tuples: arg3 setReadOnlyBlock: [:arg4 |  MirrorPrimitives makeObject: arg1 readOnly: arg4 ]methodProperties  ^self method propertiestypeOfClass  ^#normal- arg1  ^ExceptionSetWithExclusions new     add: self;     addExclusion: arg1;     yourselfpredecessor  | tmp1 |  self isFinite ifFalse: [ (self isNaN or: [ self negative ]) ifTrue: [ ^self ].        ^Float fmax ].  self = 0.0 ifTrue: [ ^Float fmin negated ].  tmp1 := self ulp.  ^self - (0.5 * tmp1) = self ifTrue: [ self - tmp1 ] ifFalse: [ self - (0.5 * tmp1) ]nextPut: arg1  position := position + 1testLargeShift  | tmp1 |  tmp1 := #('101101011101001100110111110110011101101101000001110110011' '1101101001100010011001101110100000111011011010100011101100' '101101101011110011001100110011011101011001111000100011101000' '10101101101000101001111111111100101101011001011000100011100000' '1000101010101001111011101010111001011111110011110001000110000000' '1100101010101000010011101000110010111110110011110000000000000001').  tmp1 := tmp1 , (tmp1 collect: [:arg1 |  '1' , arg1 reversed ]).  tmp1 := tmp1 , (tmp1 collect: [:arg1 |  arg1 , arg1 ]).  tmp1 do: [:arg2 |  | tmp2 tmp3 tmp4 |        tmp2 := Integer readFrom: arg2 readStream base: 2.        0 to: arg2 size - 1 do: [:arg3 |  tmp3 := (tmp2 bitShift: arg3) printStringBase: 2.              tmp4 := (tmp2 bitShift: 0 - arg3) printStringBase: 2.              self assert: tmp3 equals: arg2 , (String new: arg3 withAll: $0).              self assert: tmp4 equals: (arg2 copyFrom: 1 to: arg2 size - arg3) ] ]asExternalTypeOn: arg1  ^FFIConst value: self asBitisBefore: arg1  | tmp1 |  tmp1 := arg1 asDate.  ^self year < tmp1 year or: [ self year = tmp1 year and: [ self monthIndex < tmp1 monthIndex or: [ self monthIndex = tmp1 monthIndex and: [ self dayOfMonth < tmp1 dayOfMonth ] ] ] ]withAllSuperclassesDo: arg1  arg1 value: self.  self superclass == nil ifFalse: [ self superclass withAllSuperclassesDo: arg1 ]asUnixTime  ^((self offset: Duration zero) - self class unixEpoch) asSecondsfuelSet: arg1 nanoSecond: arg2 seconds: arg3 offset: arg4  self setJdn: arg1 seconds: arg3 nano: arg2 offset: arg4sizeReturnTop  ^self sizeOpcodeSelector: #genReturnTop withArguments: #()height  ^self bottom + self topgenReturnTopToCaller  stream nextPut: 125sourceNode  ^self sourceNodeExecuted enclosingMethodOrBlockNodetestCoercion  #(#* #+ #- #/) do: [:arg1 |  self assert: (1.0s1 perform: arg1 with: 2) class equals: ScaledDecimal.        self assert: (1.0s1 perform: arg1 with: 1 / 2) class equals: ScaledDecimal.        self deny: (1.0s1 perform: arg1 with: 1.0) class equals: ScaledDecimal.        self assert: (1 perform: arg1 with: 2.0s1) class equals: ScaledDecimal.        self assert: (1 / 2 perform: arg1 with: 2.0s1) class equals: ScaledDecimal.        self deny: (1.0 perform: arg1 with: 1.0s1) class equals: ScaledDecimal ]copyWith: arg1  | tmp1 tmp2 |  tmp1 := self class new: self size + 1.  tmp2 := 0.  self do: [:arg2 |  tmp1 basicAt: (tmp2 := tmp2 + 1) put: arg2 ].  tmp1 basicAt: (tmp2 := tmp2 + 1) put: arg1.  ^tmp1ifNil: arg1  ^selfwaitProcessTermination: arg1  self waitFor: [ arg1 isTerminated ]canBeGlobalVarInitial  ^self characterSet canBeGlobalVarInitial: selftestFork  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := Semaphore new.  tmp1 := false.  tmp2 := [ tmp1 := true.  tmp4 signal ].  tmp3 := tmp2 fork.  self deny: tmp1.  self assert: (tmp3 isKindOf: Process).  tmp4 wait.  self assert: tmp1gtDisplayOn: arg1  self printOn: arg1categoryOfElement: arg1  | tmp1 |  tmp1 := self numberOfCategoryOfElement: arg1.  ^tmp1 = 0 ifTrue: [ nil ] ifFalse: [ categoryArray at: tmp1 ]value: arg1  ^receiver perform: selector with: arg1simpleRetryUsingTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     yourselfnotifyUserOfCommand: arg1  self passwritesField: arg1  self isQuick ifTrue: [ ^false ].  ^super writesField: arg1checkLocal: arg1  self assert: TestLocalVariable value equals: arg1outerCode  ^self literalAt: self numLiteralsdefaultAction  < reflective: #unhandledErrorDefaultAction:message:>  ^UIManager default unhandledErrorDefaultAction: self exceptionasShortcut  ^self asKeyCombinationreceiver: arg1  self at: 1 put: arg1classVariablesNeedFullDefinition  ^self classVariables anySatisfy: [:arg1 |  arg1 needsFullDefinition ]testIsOtherSymbol  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isOtherSymbol: tmp2) equals: (tmp1 isOtherSymbol: tmp2) ]includesProperty: arg1  1 to: self basicSize do: [:arg2 |  | tmp1 |        tmp1 := self basicAt: arg2.        (tmp1 isVariableBinding and: [ tmp1 key == arg1 ]) ifTrue: [ ^true ] ].  ^falsetranslateToUTC  ^self translateTo: 0nextInstance  self shouldNotImplementelapsedTime  ^elapsedTimecopySameFrom: arg1  | tmp1 tmp2 |  tmp1 := self class allInstVarNames.  tmp2 := arg1 class allInstVarNames.  tmp1 doWithIndex: [:arg2 :arg3 |  | tmp3 |        (tmp3 := tmp2 indexOf: arg2) > 0 ifTrue: [ self instVarAt: arg3 put: (arg1 instVarAt: tmp3) ] ].  1 to: (self basicSize min: arg1 basicSize) do: [:arg4 |  self basicAt: arg4 put: (arg1 basicAt: arg4) ]selectorsToBeIgnored  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := #().  tmp2 := #(#print24:on: #print24:showSeconds:on:).  tmp3 := #(#< #= #new #printOn: #storeOn:).  tmp4 := #(#primMillisecondClock #primSecondsClock #primUTCSecondsClock #primUTCMicrosecondsClock #primUTCMillisecondsClock).  tmp5 := #(#millisecondClockValue #milliseconds:since: #millisecondsSince:).  tmp6 := #(#benchmarkMillisecondClock #benchmarkPrimitiveResponseDelay).  ^super selectorsToBeIgnored , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6ticks  ^Array with: julianDayNumber with: seconds with: nanosaddSelectorSilently: arg1 withMethod: arg2  self methodDict at: arg1 put: arg2.  arg2 methodClass: self.  arg2 selector: arg1expectedArgumentsCount  ^expectedArgumentsCountwithHeight: arg1  ^origin corner: corner x @ (origin y + arg1)asDate  ^start asDateprintOn: arg1  arg1     print: self asDateAndTime;     nextPutAll: ' (';     print: self value;     nextPut: $)ifTrue: arg1 ifFalse: arg2  ^arg1 valueisSymbol  ^falseremoveEmptyCategories  | tmp1 tmp2 |  tmp1 := self protocolOrganizer allProtocolsNames copy.  tmp2 := self protocolOrganizer removeEmptyProtocols.  tmp2 do: [:arg1 |  self notifyOfRemovedCategory: arg1 name ].  self notifyOfChangedCategoriesFrom: tmp1 to: self protocolOrganizer allProtocolsNamestestBasicNew  self should: [ SmallInteger basicNew ] raise: self defaultTestErrorsystemBackgroundPriority  ^SystemBackgroundPrioritywaitOnCompletion: arg1 onTimeout: arg2  ^self wait ifTrue: [ arg2 value ] ifFalse: [ arg1 value ]testNaN3  | tmp1 tmp2 tmp3 |  tmp1 := Set new.  tmp1 add: (tmp2 := Float nan).  self deny: (tmp1 includes: tmp2).  tmp3 := IdentitySet new.  tmp3 add: (tmp2 := Float nan).  self assert: (tmp3 includes: tmp2)environment  ^environment ifNil: [ super environment ]genPushIntegerLong: arg1  (arg1 < -32768 or: [ arg1 > 32767 ]) ifTrue: [ ^self outOfRangeError: 'integer' index: arg1 range: -32768 to: 32767 ].  self genSignedSingleExtendB: (arg1 bitShift: -8).  stream     nextPut: 232;     nextPut: (arg1 bitAnd: 255)object  ^object\\\ arg1  ^self \\ arg1printHMSOn: arg1 separatedBy: arg2  BasicDatePrinter default printHMS: self separatedBy: arg2 on: arg1isPointers  ^self isBits notisIntegerPoint  ^x isInteger and: [ y isInteger ]benchmark  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := 8190.  1 to: self do: [:arg1 |  tmp5 := 0.        tmp2 := (Array new: tmp1) atAllPut: true.        1 to: tmp1 do: [:arg2 |  (tmp2 at: arg2) ifTrue: [ tmp3 := arg2 + 1.                    tmp4 := arg2 + tmp3.                    [ tmp4 <= tmp1 ] whileTrue: [ tmp2 at: tmp4 put: false.                          tmp4 := tmp4 + tmp3 ].                    tmp5 := tmp5 + 1 ] ] ].  ^tmp5sourceNodeForPC: arg1  ^self sourceNode sourceNodeForPC: arg1selector: arg1  selector := arg1arcTan  < primitive: 57>  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self < 0.0 ifTrue: [ ^0.0 - (0.0 - self) arcTan ].  tmp1 := self * Halfpi / (self + 1.0).  tmp2 := Halfpi * Epsilon.  tmp3 := tmp1.  [ tmp3 * tmp3 > tmp2 ] whileTrue: [ tmp4 := tmp1 sin.        tmp5 := tmp1 cos.        tmp3 := tmp4 * tmp5 - (self * tmp5 * tmp5).        tmp1 := tmp1 - tmp3 ].  ^tmp1testSuperclass  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := [:arg1 |  arg1 ifNotNil: [ tmp1 add: arg1.        tmp2 value: arg1 superclass ] ].  tmp2 value: OrderedCollection.  self assert: OrderedCollection allSuperclasses equals: tmp1 allButFirst.  self assert: OrderedCollection withAllSuperclasses equals: tmp1genStorePopInstVarLong: arg1  (arg1 >= 0 and: [ arg1 < 256 ]) ifTrue: [ stream           nextPut: 132;           nextPut: 192;           nextPut: arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255properties  | tmp1 |  tmp1 := WriteStream on: (Array new: self basicSize * 2).  1 to: self basicSize do: [:arg1 |  | tmp2 |        (tmp2 := self basicAt: arg1) isVariableBinding ifTrue: [ tmp1                 nextPut: tmp2 key;                 nextPut: tmp2 value ] ].  ^IdentityDictionary newFromPairs: tmp1 contentsdefaultAction  self subclassResponsibilitytestTomorrow  self assert: Date tomorrow equals: Date today + 1 day* arg1  < primitive: 49>  ^arg1 adaptToFloat: self andSend: #*testTotalSeconds  self assert: 0 seconds totalSeconds equals: 0.  self assert: 1 second totalSeconds equals: 1.  self assert: 100 second totalSeconds equals: 100.  self assert: 500 milliSeconds totalSeconds equals: 1 / 2.  self assert: 1500 milliSeconds totalSeconds equals: 3 / 2.  self assert: 2500 milliSeconds totalSeconds equals: 5 / 2.  self assert: 1 second negated totalSeconds equals: -1hash  | tmp1 tmp2 tmp3 |  tmp1 := self initialPC.  tmp2 := self endPC.  tmp3 := self species hash + self header + tmp1 + tmp2 + self methodClass hash bitAnd: 16rFFFFFFF.  tmp1 to: tmp2 by: ((tmp2 - tmp1) // 20 max: 1) do: [:arg1 |  tmp3 := tmp3 + (self at: arg1) ].  ^tmp3method  ^self outerCode methodtestIsInteger  self assert: 0 isIntegerallMask: arg1  ^arg1 = (self bitAnd: arg1)digitLength  self deprecated: 'Use #bytesCount instead.' transformWith: '`@receiver digitLength' -> '`@receiver bytesCount'.  ^self bytesCountspotterPreviewIn: arg1  < spotterPreview: 10>  self method spotterPreviewCodeIn: arg1readSlot: arg1  ^arg1 read: selfdeltaToEnsureInOrCentered: arg1 extra: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := tmp2 := 0.  tmp3 := ((arg1 width - self width) * arg2) truncated.  tmp4 := ((arg1 height - self height) * arg2) truncated.  self left < arg1 left ifTrue: [ tmp1 := self left - arg1 left - tmp3 ] ifFalse: [ self right > arg1 right ifTrue: [ tmp1 := self right - arg1 right + tmp3 ] ].  self top < arg1 top ifTrue: [ tmp2 := self top - arg1 top - tmp4 ] ifFalse: [ self bottom > arg1 bottom ifTrue: [ tmp2 := self bottom - arg1 bottom + tmp4 ] ].  ^tmp1 @ tmp2postCopy  ^selfintersectAll: arg1  ^arg1 ifNotEmpty: [ self intersect: arg1 first withAll: arg1 allButFirst ]fuelValueWithoutNotifications  SystemAnnouncer uniqueInstance suspendAllWhile: selfdeepCopy  cos  ^(self + Halfpi) sintestHash  self assert: 2 = 2.0 ==> (2 hash = 2.0 hash).  self assert: 1 / 2 = 0.5 ==> ((1 / 2) hash = 0.5 hash).  Float nan hash.  Float infinity hashcompile: arg1 classified: arg2 notifying: arg3  | tmp1 |  tmp1 := self acceptsLoggingOfCompilation ifTrue: [ Author changeStamp ] ifFalse: [ nil ].  ^self compile: arg1 classified: arg2 withStamp: tmp1 notifying: arg3wait  ^self waitMaxMilliseconds: niltheta  | tmp1 tmp2 |  ^x = 0 ifTrue: [ y >= 0 ifTrue: [ 1.570796326794897 ] ifFalse: [ 4.71238898038469 ] ] ifFalse: [ tmp1 := y asFloat / x asFloat.        tmp2 := tmp1 arcTan.        x >= 0 ifTrue: [ y >= 0 ifTrue: [ tmp2 ] ifFalse: [ 6.283185307179586 + tmp2 ] ] ifFalse: [ 3.141592653589793 + tmp2 ] ]isSelfEvaluating  ^self methodClass notNil and: [ self isDoIt not ]critical: arg1 ifLocked: arg2  excessSignals == 0 ifTrue: [ ^arg2 value ].  ^self critical: arg1testRefersToLiteralsReturnsTrueWhenLiteralIsInMethodPropertiesKey  [ self compiledMethod1 propertyAt: #Once put: true.  self assert: (self compiledMethod1 hasLiteralThorough: #Once) ] ensure: [ self compiledMethod1 removeProperty: #Once ]keyAtValue: arg1 ifAbsent: arg2  1 to: self basicSize do: [:arg3 |  arg1 = (array at: arg3) ifTrue: [ (self basicAt: arg3) ifNotNil: [:arg4 |  ^arg4 ] ] ].  ^arg2 valuetestNonActiveBlockContextActiveHome  nonActiveBlockContext := self class returnNonActiveContextOfBlock.  self assert: nonActiveBlockContext activeHome isNiltestIsTerminatingForcedTerminationWithoutRunning  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := false.  tmp3 := false.  tmp1 := [ tmp3 := true.  [ Semaphore new wait ] ensure: [ tmp4 := Processor activeProcess.        tmp2 := true ] ] newProcess.  tmp1 priority: Processor systemBackgroundPriority.  self assert: tmp1 isSuspended.  self deny: tmp1 isTerminating.  self deny: tmp1 isTerminated.  self deny: tmp3.  self deny: tmp2.  tmp1 resume.  self deny: tmp1 isSuspended.  self deny: tmp1 isTerminating.  self deny: tmp1 isTerminated.  self deny: tmp2.  tmp1 terminate.  self assert: tmp1 isSuspended.  self assert: tmp1 isTerminating.  self assert: tmp1 isTerminated.  self deny: tmp3.  self deny: tmp2.  self deny: tmp4 identicalTo: tmp1+ arg1  < primitive: 541>  ^arg1 adaptToFloat: self andSend: #+adhereTo: arg1  (arg1 containsPoint: self) ifTrue: [ ^self ].  ^((x max: arg1 left) min: arg1 right) @ ((y max: arg1 top) min: arg1 bottom)next  ^generator nextmethodDict: arg1  methodDict := arg1verifyJumpWithSelector: arg1  | tmp1 tmp2 tmp3 |  tmp1 := SimulationMock new.  tmp2 := (tmp1 perform: arg1) stackPtr.  tmp1 beReadOnlyObject.  [ tmp3 := (tmp1 perform: arg1) stackPtr ] on: ModificationForbidden do: [:arg2 |  arg2 resumeUnchecked: nil ].  self assert: tmp2 equals: tmp3setNumerator: arg1 denominator: arg2  arg2 = 0 ifTrue: [ ^(ZeroDivide dividend: arg1) signal ] ifFalse: [ numerator := arg1 asInteger.        denominator := arg2 asInteger abs.        arg2 < 0 ifTrue: [ numerator := numerator negated ] ]doSomethingExceptionalString  ^'Do something exceptional.'myDependents: arg1  arg1 ifNil: [ DependentsFields removeKey: self ifAbsent: [  ] ] ifNotNil: [ DependentsFields at: self put: arg1 ]step  ^Processor activeProcess evaluate: [ suspendedContext := suspendedContext step ] onBehalfOf: selfnumberOfInstanceVariables  self deprecated: 'Use #instSize or `slots size` instead.' transformWith: '`@receiver numberOfInstanceVariables' -> '`@receiver instSize'.  ^self instSizelinkOf: arg1 ifAbsent: arg2  self linksDo: [:arg3 |  arg3 value = arg1 ifTrue: [ ^arg3 ] ].  ^arg2 valuecanHandleSignal: arg1  ^(self exceptionClass handles: arg1) or: [ self nextHandlerContext canHandleSignal: arg1 ]postCopy  | tmp1 |  (tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ self penultimateLiteral: (tmp1 copy                 method: self;                 yourself).        self penultimateLiteral pragmas do: [:arg1 |  arg1 method: self ] ]clearLog  log := nilobject: arg1 perform: arg2 withArguments: arg3 inClass: arg4  < primitive: 100 error: error>  arg2 isSymbol ifFalse: [ ^self error: 'selector argument must be a Symbol' ].  (arg3 isMemberOf: Array) ifFalse: [ ^self error: 'argArray must be an Array' ].  arg2 numArgs = arg3 size ifFalse: [ ^self error: 'incorrect number of arguments' ].  ((self objectClass: arg1) includesBehavior: arg4) ifFalse: [ ^self error: 'lookupClass is not in anObject''s inheritance chain' ].  self primitiveFailedtestZeroSignificandAsInteger  self assert: 0.0 significandAsInteger equals: 0asHTMLString  #($< '&lt;' $> '&gt;' $& '&amp;') pairsDo: [:arg1 :arg2 |  self = arg1 ifTrue: [ ^arg2 ] ].  ^String with: self, arg1  self add: arg1unclassifiedCategory  ^#UnclassifiedfirstCommentAt: arg1  self deprecated: 'use #firstComment on the method instead' transformWith: '`@receiver commentsAt: `@argument' -> '(`@receiver compiledMethodAt: `@argument) firstComment'.  ^(self compiledMethodAt: arg1) firstCommenthasMethods  ^self methodDict notEmptyremoveFromSystem  self removeFromSystem: trueinitializeTicker: arg1 suspendedDelaysHeap: arg2  super initializeTicker: arg1 suspendedDelaysHeap: arg2.  readyToSchedule := Semaphore new signal.  readyToUnschedule := Semaphore new signaltestBecomeHash  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := 'ab' copy.  tmp2 := 'cd' copy.  tmp3 := tmp1.  tmp4 := tmp2.  tmp5 := tmp1 hash.  tmp6 := tmp2 hash.  tmp1 become: tmp2.  self     assert: tmp1 hash equals: tmp6;     assert: tmp2 hash equals: tmp5;     assert: tmp3 hash equals: tmp6;     assert: tmp4 hash equals: tmp5deprecatedMethod7  decimalDigitLength  ^self < 10000 ifTrue: [ self < 100 ifTrue: [ self < 10 ifTrue: [ 1 ] ifFalse: [ 2 ] ] ifFalse: [ self < 1000 ifTrue: [ 3 ] ifFalse: [ 4 ] ] ] ifFalse: [ self < 100000000 ifTrue: [ self < 1000000 ifTrue: [ self < 100000 ifTrue: [ 5 ] ifFalse: [ 6 ] ] ifFalse: [ self < 10000000 ifTrue: [ 7 ] ifFalse: [ 8 ] ] ] ifFalse: [ self < 1000000000000 ifTrue: [ self < 10000000000 ifTrue: [ self < 1000000000 ifTrue: [ 9 ] ifFalse: [ 10 ] ] ifFalse: [ self < 100000000000 ifTrue: [ 11 ] ifFalse: [ 12 ] ] ] ifFalse: [ self < 10000000000000000 ifTrue: [ self < 100000000000000 ifTrue: [ self < 10000000000000 ifTrue: [ 13 ] ifFalse: [ 14 ] ] ifFalse: [ self < 1000000000000000 ifTrue: [ 15 ] ifFalse: [ 16 ] ] ] ifFalse: [ self < 1000000000000000000 ifTrue: [ self < 100000000000000000 ifTrue: [ 17 ] ifFalse: [ 18 ] ] ifFalse: [ self < 10000000000000000000 ifTrue: [ 19 ] ifFalse: [ 20 ] ] ] ] ] ]spotterActDefault  ^self browsetestFlag  ProtoObject new flag: #hallokeysAndValuesDo: arg1  tally = 0 ifTrue: [ ^self ].  1 to: self basicSize do: [:arg2 |  (self basicAt: arg2) ifNotNil: [:arg3 |  arg1 value: arg3 value: (array at: arg2) ] ]stonOn: arg1  arg1 writeFloat: self asFloattestCollectArguments  | tmp1 tmp2 tmp3 |  tmp2 := OrderedCollection new.  tmp3 := Color green.  tmp1 := WeakMessageSend receiver: tmp2 selector: #add: arguments: {Color black}.  tmp1 valueWithArguments: {}.  self assertCollection: tmp2 asArray equals: {Color black}.  tmp1 valueWithArguments: {#a .         (WeakArray with: tmp3)}.  self assertCollection: tmp2 asArray equals: {Color black .         #a}.  tmp1 valueWithArguments: (WeakArray with: tmp3).  self assertCollection: tmp2 asArray equals: {Color black .         #a .         Color green}< arg1  < primitive: 543>  ^arg1 adaptToFloat: self andCompare: #<isFloat  ^falsejsonOn: arg1  arg1 boolean: selffloorLog: arg1  ^(self log: arg1) floorallProtocolsNames  ^self allProtocols collect: #namefuelIgnoredInstanceVariableNames  ^#()testFloatPrintPolicy  | tmp1 |  tmp1 := FloatPrintPolicy value: InexactFloatPrintPolicy new during: [ Float pi printString ].  self assert: (tmp1 beginsWith: '3.14159').  tmp1 := FloatPrintPolicy value: ExactFloatPrintPolicy new during: [ Float pi printString ].  self assert: (tmp1 beginsWith: '3.14159')localReadsRef: arg1  | tmp1 tmp2 |  (tmp1 := self indexOfLiteral: arg1) = 0 ifTrue: [ ^false ].  tmp1 := tmp1 - 1.  ^(tmp2 := InstructionStream on: self) scanFor: (self encoderClass bindingReadScanBlockFor: tmp1 using: tmp2)testAsWeek  | tmp1 tmp2 tmp3 |  tmp1 := Duration days: 7.  tmp2 := Duration weeks: 0.5.  tmp3 := Duration weeks: 0.25.  self     assert: 1 week equals: tmp1;     assert: 1.0 week equals: tmp1;     assert: 0.5 week equals: tmp2;     assert: (1 / 2) week equals: tmp2;     assert: (1 / 4) week equals: tmp3.  self assert: 0.4 week + 0.6 week equals: 1 weekbasicAt: arg1  < primitive: 60>  arg1 isInteger ifTrue: [ self errorSubscriptBounds: arg1 ].  arg1 isNumber ifTrue: [ ^self basicAt: arg1 asInteger ] ifFalse: [ self errorNonIntegerIndex ]sourceCodeAt: arg1 ifAbsent: arg2  ^(self compiledMethodAt: arg1 ifAbsent: [ ^arg2 value ]) sourceCodeselector: arg1  selector := arg1emptyMethodDictionary  ^MethodDictionary newouterCode: arg1  ^self literalAt: self numLiterals put: arg1superclass: arg1  superclass := arg1systemIcon  ^self iconNamed: self systemIconNamedigitAdd: arg1  < primitive: 'primDigitAdd' module: 'LargeIntegers'>  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := 0.  (tmp1 := self bytesCount) < (tmp2 := arg1 bytesCount) ifTrue: [ tmp1 := tmp2 ].  tmp4 := Integer new: tmp1 neg: self negative.  1 to: tmp1 do: [:arg2 |  tmp3 := (tmp3 bitShift: -8) + (self byteAt: arg2) + (arg1 byteAt: arg2).        tmp4 byteAt: arg2 put: (tmp3 bitAnd: 255) ].  tmp3 > 255 ifTrue: [ tmp4 := tmp4 growby: 1.        tmp4 at: tmp4 bytesCount put: (tmp3 bitShift: -8) ].  ^tmp4isYearPattern  ^char = $yat: arg1 ifPresent: arg2  ^(array at: (self findElementOrNil: arg1)) ifNotNil: [:arg3 |  arg2 cull: arg3 ]testInstanceCreationFromADateAndATime  | tmp1 tmp2 tmp3 |  tmp1 := Date today.  tmp2 := Time now.  tmp3 := DateAndTime date: tmp1 time: tmp2.  self assert: tmp3 asDate equals: tmp1.  self assert: tmp3 asTime equals: tmp2name  ^self monthNameobjectAt: arg1 put: arg2  < primitive: 69>  self primitiveFailedtestBecomeForwardDontCopyIdentityHash  | tmp1 tmp2 tmp3 |  tmp1 := 'ab' copy.  tmp2 := 'cd' copy.  tmp3 := tmp2 identityHash.  tmp1 becomeForward: tmp2 copyHash: false.  self     assert: tmp1 identicalTo: tmp2;     assert: tmp1 identityHash equals: tmp3;     assert: tmp2 identityHash equals: tmp3findOriginMethodOf: arg1  ^arg1- arg1  arg1 isInteger ifTrue: [ self negative == arg1 negative ifTrue: [ ^self digitSubtract: arg1 ] ifFalse: [ ^(self digitAdd: arg1) normalize ] ].  arg1 isFraction ifTrue: [ ^Fraction numerator: self * arg1 denominator - arg1 numerator denominator: arg1 denominator ].  ^arg1 adaptToInteger: self andSend: #-wait  < primitive: 86>  self primitiveFailedexecutor  ^self shallowCopy actAsExecutortestHash  self assert: atPragma hash equals: atPragma hash.  self assert: atPragma hash equals: anotherAtPragma hash.  self assert: anotherAtPragma hash equals: atPragma hash.  self assert: atPragma hash equals: anotherAtPragma hash.  self assert: anotherAtPragma hash equals: yetAnotherAtPragma hash.  self assert: yetAnotherAtPragma hash equals: atPragma hashcopyWithTrailerBytes: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := self initialPC.  tmp2 := self endPC.  tmp1 := arg1 createMethod: tmp2 - tmp3 + 1 class: self class header: self header.  1 to: self numLiterals do: [:arg2 |  tmp1 literalAt: arg2 put: (self literalAt: arg2) ].  (tmp4 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 penultimateLiteral: (tmp4 copy                 setMethod: tmp1;                 yourself) ].  tmp3 to: tmp2 do: [:arg2 |  tmp1 at: arg2 put: (self at: arg2) ].  ^tmp1localSlots  ^self slots select: [:arg1 |  arg1 isLocal ]\\ arg1  ^arg1 isNumber ifTrue: [ self class nanoSeconds: self asNanoSeconds \\ arg1 ] ifFalse: [ self - (arg1 * (self // arg1)) ]testExample2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp4 := (1 to: 1000) asOrderedCollection.  tmp5 := OrderedCollection new.  tmp6 := 0.  tmp7 := false.  tmp8 := 0.  tmp3 := Monitor new.  tmp1 := [ tmp3 critical: [ tmp8 := tmp8 + 1 ].  [ tmp3 critical: [ tmp3 waitUntil: [ tmp6 \\ 5 = 0 ].        tmp7 or: [ tmp5 add: (tmp6 := tmp6 + 1) ].        tmp7 := tmp6 >= tmp4 size.        tmp3 signal ].  tmp7 ] whileFalse.  tmp3 critical: [ tmp8 := tmp8 - 1.        tmp3 signal: #finish ] ].  tmp2 := [ tmp3 critical: [ tmp8 := tmp8 + 1 ].  [ tmp3 critical: [ tmp3 waitWhile: [ tmp6 \\ 5 = 0 ].        tmp7 or: [ tmp5 add: (tmp6 := tmp6 + 1) ].        tmp7 := tmp6 >= tmp4 size.        tmp3 signal ].  tmp7 ] whileFalse.  tmp3 critical: [ tmp8 := tmp8 - 1.        tmp3 signal: #finish ] ].  tmp1 forkAt: Processor userBackgroundPriority.  tmp2 forkAt: Processor userBackgroundPriority.  tmp3 critical: [ tmp3 waitUntil: [ tmp8 = 0 & tmp7 ] for: #finish ].  self assert: tmp4 equals: tmp5valueWithInterval: arg1  ^[ [ self value.  arg1 wait ] repeat ] forkAt: Processor userBackgroundPriority named: (String streamContents: [:arg2 |  arg2                 << 'every ';                 print: arg1;                 << ' do: ';                 print: self ])representsSimpleAnnotationUser: arg1  ^self isKindOf: arg1testJulianDayNumber  self assert: aDateAndTime equals: (DateAndTime julianDayNumber: 2444240).  self assert: aDateAndTime julianDayNumber equals: 2444240gtInspectorCharacterIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 table     title: 'Character';     display: [ {('self' -> self) .         ('codepoint' -> self codePoint) .         ('unicode' -> (String streamContents: [:arg2 |  arg2 << 'U+'.                    self codePoint printOn: arg2 base: 16 nDigits: 4 ]))} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: [:arg3 |  arg3 value printString ];     send: #valueisClassOrTrait  ^trueasSpecLayoutFrame  ^SpecLayoutFrame new     leftFraction: self left;     rightFraction: self right;     topFraction: self top;     bottomFraction: self bottom;     yourselfequals: arg1  ^self year = arg1 year and: [ self monthIndex = arg1 monthIndex and: [ self dayOfMonth = arg1 dayOfMonth ] ]translateToUTC  ^self translateTo: 0 asDurationinspectWithLabel: arg1  ^Smalltalk tools inspector inspect: self label: arg1to: arg1 by: arg2  ^(Schedule starting: self ending: arg1 asDateAndTime)     schedule: (Array with: arg2 asDuration);     yourselflink: arg1 toTemporary: arg2  self flag: 'Not sure what it should do. The tests are not passing for this... See method testLinkClassToTempVarNamed'.  arg2 link: arg1closeTo: arg1  ^(x closeTo: arg1 x) and: [ y closeTo: arg1 y ]digitAt: arg1  self deprecated: 'Please use byteAt: instead.' transformWith: '`@receiver digitAt: `@statements1' -> '`@receiver byteAt: `@statements1'.  ^self byteAt: arg1debugWithTitle: arg1  | tmp1 |  tmp1 := self isActiveProcess ifTrue: [ thisContext ] ifFalse: [ self suspendedContext ].  ^self debug: tmp1 title: arg1 full: trueauthor  self timeStamp ifNotEmpty: [:arg1 |  | tmp1 |        tmp1 := arg1 substrings first.        tmp1 first isLetter ifTrue: [ ^tmp1 ] ].  ^''testReciprocalModulo  | tmp1 tmp2 |  tmp1 := 1 bitShift: 48.  tmp2 := Random seed: 46912151.  4691 timesRepeat: [ | tmp3 tmp4 tmp5 tmp6 |        tmp3 := (tmp2 nextInt: tmp1) + 1.        tmp4 := (tmp2 nextInt: tmp1) + 1.        tmp3 > tmp4 ifTrue: [ tmp6 := tmp3.              tmp3 := tmp4.              tmp4 := tmp6 ].        (tmp3 gcd: tmp4) = 1 ifTrue: [ tmp5 := tmp3 reciprocalModulo: tmp4.              self assert: tmp3 * tmp5 \\ tmp4 equals: 1 ] ifFalse: [ self should: [ tmp3 reciprocalModulo: tmp4 ] raise: Error ] ]subclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 category: arg5  ^self subclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: '' category: arg5sizeStoreTemp: arg1  ^self sizeOpcodeSelector: #genStoreTemp: withArguments: {arg1}rounded  ^(self + (self sign / 2)) truncatedtestBasicCheck2  | tmp1 |  tmp1 := testClass >> (testClass compile: 'testMethod ').  self assert: (tmp1 externalProperties noneSatisfy: [:arg1 |  arg1 rule class = SendsDeprecatedMethodToGlobalRule ])popIntoReceiverVariable: arg1  self object: self receiver instVarAt: arg1 + 1 put: self popunwindComplete  ^self tempAt: 2testIndexOfMonth  | tmp1 |  tmp1 := #(#January #February #March #April #May #June #July #August #September #October #November #December).  tmp1 withIndexDo: [:arg1 :arg2 |  self assert: (Month indexOfMonth: arg1) equals: arg2 ].  self should: [ Month indexOfMonth: 1 ] raise: self defaultTestError.  self should: [ Month indexOfMonth: #Marsh ] raise: self defaultTestError.  self should: [ Month indexOfMonth: #UnexistingMonth ] raise: self defaultTestErrorreceiver  ^self at: 1categories  categoryArray ifNil: [ ^nil ].  (categoryArray size = 1 and: [ categoryArray first = Default & elementArray isEmpty ]) ifTrue: [ ^Array with: NullCategory ].  ^categoryArrayvalue  < primitive: 207>  | tmp1 |  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  false ifTrue: [ tmp1 := self asContextWithSender: thisContext sender.        thisContext privSender: tmp1 ] ifFalse: [ self primitiveFailed ]waitUntil: arg1  ^self waitUntil: arg1 for: nil/ arg1  < primitive: 50>  arg1 = 0.0 ifTrue: [ ^ZeroDivide signalWithDividend: self ].  ^arg1 adaptToFloat: self andSend: #/notifyOfChangedCategoriesFrom: arg1 to: arg2  (self hasSubject and: [ arg1 ~= arg2 ]) ifTrue: [ SystemAnnouncer uniqueInstance classReorganized: self subject ]waitMaxMilliseconds: arg1  ^self waitFor: nil maxMilliseconds: arg1testIntersectWith  self assert: (self intersect: (LinkedList with: #apple with: #banana with: #avocado) withCollection: (LinkedList with: 1 with: 2 with: #apple)) equals: (LinkedList with: #apple).  self assert: (self intersect: ((1 to: 10) as: LinkedList) withCollection: (9 to: 20)) equals: (9 to: 10).  self assert: (self intersect: ((1 to: 10) as: LinkedList) withCollection: (11 to: 20)) equals: {}stonContainSubObjects  ^false<< arg1  arg1 < 0 ifTrue: [ self error: 'negative arg' ].  ^self bitShift: arg1actAsExecutor  self breakDependentsprintOn: arg1 withLeadingSpace: arg2  BasicDatePrinter default printDateAndTime: self withLeadingSpace: arg2 on: arg1methodReturnReceiver  ^self return: self receiver from: self methodReturnContexthasBreakpoint  ^Breakpoint isInstalledIn: selflogTranscript  self showWarning ifTrue: [ DeprecationPerformedNotification signal: self messageText ]criticalReleasingOnError: arg1  | tmp1 tmp2 |  tmp2 := false.  [ tmp2 := true.  self wait.  tmp1 := arg1 on: Exception do: [:arg2 |  tmp2 ifTrue: [ self signal ].        tmp2 := false.        arg2 pass ] ] ensure: [ tmp2 ifTrue: [ self signal ] ].  ^tmp1localMethodNamed: arg1 ifAbsent: arg2  ^self compiledMethodAt: arg1 ifAbsent: arg2basicReplaceFrom: arg1 to: arg2 with: arg3 startingAt: arg4  < primitive: 105>  arg1 to: arg2 do: [:arg5 |  self basicAt: arg5 put: (arg3 basicAt: arg4 - arg1 + arg5) ]testSecond  self assert: aTime second equals: 56.  self assert: aTime seconds equals: 56memoized  ^self memoizedUsing: Dictionary newclassForScheduler  ^DelayMutexSchedulerscale  ^scaledestroyTwin  self reflectiveMethod: nilheight  ^corner y - origin yreplaceFrom: arg1 to: arg2 with: arg3 startingAt: arg4  < primitive: 105>  ^super replaceFrom: arg1 to: arg2 with: arg3 startingAt: arg4glamourValue: arg1  | tmp1 |  tmp1 := arg1 asGlamorousArray.  ^self glamourValueWithArgs: tmp1cleanCopy  ^self class sender: nil receiver: receiver method: method arguments: #()hash  ^(julianDayNumber hashMultiply bitXor: seconds) bitXor: nanossqrt  self subclassResponsibilityasSeconds  ^Duration milliSeconds: self * 1000equivalentTo: arg1  ^self = arg1 or: [ self class == arg1 class and: [ self numArgs = arg1 numArgs and: [ self numLiterals = arg1 numLiterals and: [ self methodNode = arg1 methodNode ] ] ] ]linkOf: arg1  ^self linkOf: arg1 ifAbsent: [ self error: 'No such element' ]unicodeToMacRoman  ^MacRomanTextConverter new byteToUnicode: selfinstVarNames  | tmp1 tmp2 |  tmp1 := self instSize.  tmp2 := self superclass == nil ifTrue: [ 0 ] ifFalse: [ self superclass instSize ].  tmp1 = tmp2 ifTrue: [ ^#() ].  ^(tmp2 + 1 to: tmp1) collect: [:arg1 |  'inst' , arg1 printString ]printOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     print: start;     nextPut: $D;     print: duration;     nextPut: $)jsonOn: arg1  self - self = 0.0 ifTrue: [ arg1 number: self ] ifFalse: [ arg1 null ]phlowValue: arg1 withEnoughArguments: arg2  ^arg1 withArgs: arg2 executeMethod: selfhasProperties  ^self penultimateLiteral isMethodPropertiesasBrick  ^GLMMorphBrick on: self asMorphrunAllTests  self     runBasicTests;     runBasicANSISignaledExceptionTestsisEmpty  ^self basicSize = 0fileOut  | tmp1 |  tmp1 := (String new: 100) writeStream.  tmp1     header;     timeStamp.  self hasSharedPools ifTrue: [ self shouldFileOutPools ifTrue: [ self fileOutSharedPoolsOn: tmp1 ] ].  self fileOutOn: tmp1.  CodeExporter writeSourceCodeFrom: tmp1 baseName: self name isSt: trueprivateCleanup  queuesMutex critical: [ defaultQueue isEmpty ifTrue: [ defaultQueue := nil ].        queueDict ifNotNil: [ queueDict copy keysAndValuesDo: [:arg1 :arg2 |  arg2 isEmpty ifTrue: [ queueDict removeKey: arg1 ] ].              queueDict isEmpty ifTrue: [ queueDict := nil ] ] ]schedule  self class scheduler schedule: selfreformatAll  self methods do: [:arg1 |  arg1 reformat ]unpin  self unpinInMemoryabbreviation  ^String streamContents: [:arg1 |  arg1           nextPutAll: 'LT';           print: self offset hours;           nextPut: $:.        arg1 nextPutAll: (self offset minutes printPaddedWith: $0 to: 2) ]bootstrapPackages  ^#(#'AST-Core' #'Announcements-Core' #CodeExport #CodeImport #CodeImportCommandLineHandlers #Collections #Compression #'FileSystem-Core' #'FileSystem-Disk' #Files #Jobs #Kernel #Monticello #'Multilingual-Encodings' #'Multilingual-Languages' #'Multilingual-TextConversion' #'Network-UUID' #'OpalCompiler-Core' #'Random-Core' #'RPackage-Core' #'Ring-Definitions-Containers' #'Ring-Definitions-Core' #'Ring-Definitions-Monticello' #'Ring-OldChunkImporter' #'Slot-Core' #'System-Announcements' #'System-BasicCommandLineHandler' #'System-Changes' #'System-CommandLine' #'System-CommandLineHandler' #'System-Finalization' #'System-Hashing' #'System-Localization' #'System-Model' #'System-Platforms' #'System-SessionManager' #'System-Sources' #'System-Support' #Traits #'Transcript-Core' #UIManager #'Collections-Abstract' #'Collections-Arithmetic' #'Collections-Native' #'Collections-Sequenceable' #'Collections-Stack' #'Collections-Streams' #'Collections-Strings' #'Collections-Support' #'Collections-Unordered' #'Collections-Weak' #'Zinc-Character-Encoding-Core' #'Zinc-Resource-Meta-Core' #'PharoBootstrap-Initialization' #'Transcript-NonInteractive')ceiling  | tmp1 |  tmp1 := self truncated.  self <= 0 ifTrue: [ ^tmp1 ].  ^self = tmp1 ifTrue: [ tmp1 ] ifFalse: [ tmp1 + 1 ]new: arg1  ^(self basicNew: arg1) initializeasMorph  ^self asStringMorphnanoSeconds  ^Duration nanoSeconds: selfblockNodes  ^self methods flatCollect: [:arg1 |  arg1 blockNodes ]decodeClearedTrailer  self decodeLengthFielddeprecated: arg1 on: arg2 in: arg3 transformWith: arg4 when: arg5  Deprecation new     context: thisContext sender;     explanation: arg1;     date: arg2;     version: arg3;     rule: arg4;     condition: arg5;     transformasFloat  < primitive: 40>  self primitiveFailedstonOn: arg1  arg1 writeObject: self streamShortList: [:arg2 |  arg2           add: x;           add: y ]valueWithArguments: arg1  arg1 size = 1 ifFalse: [ ^self error: 'continuations can only be resumed with one argument' ].  self value: arg1 firststepTime  ^1000stepToHome: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp3 := thisContext.  tmp2 := self step.  tmp2 = self ifFalse: [ tmp4 := nil.        tmp6 := arg1 insertSender: (Context contextOn: UnhandledError do: [:arg2 |  tmp4 ifNil: [ tmp4 := arg2 exception.                          tmp5 := thisContext.                          arg2 resumeUnchecked: tmp3 jump ] ifNotNil: [ arg2 pass ] ]) ].  tmp1 := arg1 home.  tmp1 == tmp2 home ifTrue: [ ^{tmp2 .         nil} ].  [ tmp2 := tmp2 step.  tmp4 ifNotNil: [ tmp6 ifNotNil: [ arg1 terminateTo: tmp6 sender ].        ^{tmp2 .         tmp4} ].  tmp1 == tmp2 home ] whileFalse: [ tmp1 isDead ifTrue: [ ^{tmp2 .               nil} ] ].  tmp6 ifNotNil: [ arg1 terminateTo: tmp6 sender ].  ^{tmp2 .   nil}add: arg1  ^self at: arg1 key put: arg1 valueclassSymbol  ^self variableNode namecombined  ^combinedtestVeryDeepCopyWith  self assert: (nil veryDeepCopyWith: nil) isNiltestHandlerContext  | tmp1 |  tmp1 := [ [ [ MyResumableTestError signal ] on: MyTestError do: [ 'handler 2' ] ] on: MyResumableTestError do: [ MyTestError signal ] ] on: MyTestError do: [ 'handler 1' ].  self assert: 'handler 1' = tmp1 description: 'Incorrect handler'signal  < primitive: 85>  self primitiveFailedanyActive  ^activeDelay notNilisSelfEvaluating  ^truepackToArity: arg1  ^selfhasActionsWithReceiver: arg1  ^self actionMap keys anySatisfy: [:arg2 |  (self actionSequenceForEvent: arg2) anySatisfy: [:arg3 |  arg3 receiver == arg1 ] ]sizeStorePopLiteralVar: arg1  ^self sizeOpcodeSelector: #genStorePopLiteralVar: withArguments: {arg1}eqv: arg1  ^self == arg1testParsingMPatternWithSingleDigitSucceeds  | tmp1 |  tmp1 := Date year: 2013 month: 2 day: 11.  self assertReading: '11.2.2013' as: 'dd.m.yyyy' equals: tmp1.  self assertReading: '2.2013.11' as: 'm.yyyy.dd' equals: tmp1.  self assertReading: '11.2013.2' as: 'dd.yyyy.m' equals: tmp1dragPassengersFor: arg1 inMorph: arg2  ^{arg1}whichClassDefinesClassVar: arg1  Symbol hasInterned: arg1 ifTrue: [:arg2 |  ^self whichSuperclassSatisfies: [:arg3 |  arg3 classVarNames anySatisfy: [:arg4 |  arg4 = arg2 ] ] ].  ^#()messageText  ^String streamContents: [:arg1 |  originName putOn: arg1.        arg1 nextPutAll: ' ('.        undeclaredName putOn: arg1.        arg1 nextPutAll: ' is Undeclared)' ]critical: arg1 ifCurtailed: arg2  ^self critical: [ arg1 ifCurtailed: arg2 ]asHistoricalRingDefinition  | tmp1 |  tmp1 := (RGMethodDefinition named: self selector)     parentName: self methodClass name;     isMetaSide: self methodClass isMeta.  self sourcePointer isZero ifTrue: [ tmp1           protocol: self category;           sourceCode: self sourceCode;           stamp: self timeStamp ] ifFalse: [ tmp1 sourcePointer: self sourcePointer ].  tmp1 asHistorical.  ^tmp1generateDelayProcesses: arg1 priority: arg2 maxDuration: arg3 fromSeed: arg4  | tmp1 tmp2 tmp3 |  tmp1 := Random seed: arg4.  tmp2 := Array new: 1000.  1 to: tmp2 size do: [:arg5 |  tmp2 at: arg5 put: (tmp1 nextInt: arg3) ].  tmp3 := 0.  ^(1 to: arg1) collect: [:arg6 |  [ [ | tmp4 |        tmp3 := (tmp3 rem: tmp2 size) + 1.        tmp4 := Delay forMilliseconds: (tmp2 at: tmp3).        EnterCount := EnterCount + 1.        tmp4 wait.        ExitCount := ExitCount + 1.        Running ] whileTrue ] newProcess priority: arg2 ]largeIdentityHash  ^self identityHashasScaledDecimal  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := denominator lowBit - 1.  tmp3 := denominator bitShift: tmp1 negated.  tmp2 := 0.  [ tmp3 = 1 ] whileFalse: [ tmp4 := tmp3 // 5.        tmp3 - (5 * tmp4) = 0 ifFalse: [ ^super asScaledDecimal ].        tmp3 := tmp4.        tmp2 := tmp2 + 1 ].  ^self asScaledDecimal: (tmp1 max: tmp2)metaLinkOptions  ^{(#scanFor: -> #(+ optionCompileOnLinkInstallation)) .   (#at:put: -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}radiansToDegrees  ^self asFloat radiansToDegreesveryDeepCopyWith: arg1  ^selffindUndeclaredVariableIn: arg1  arg1 nodesDo: [:arg2 |  (arg2 isVariable and: [ arg2 isUndeclared ]) ifTrue: [ ^arg2 ] ].  ^nilclassBinding  ^self literalAt: self numLiteralsallCallsOn: arg1  ^self withAllSubclasses flatCollect: [:arg2 |  arg2 thoroughWhichMethodsReferTo: arg1 ]simpleEnsureTestWithNotificationResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingElseString;     add: self doYetAnotherThingString;     yourselfasDuration  ^Duration seconds: self secondsSinceMidnightLocalTime nanoSeconds: nanosencodeNoTrailer  size := 4.  encodedData := #[0 0 0 0]testDuration  self assert: aTimespan duration equals: aWeek.  aTimespan duration: aDay.  self assert: aTimespan duration equals: aDaytestShiftOneLeftThenRight  1 to: 100 do: [:arg1 |  self assert: ((1 bitShift: arg1) bitShift: arg1 negated) equals: 1 ]primitive  ^0asValueHolder  ^NewValueHolder value: selfzapOrganization  self organization: nil.  self isClassSide ifFalse: [ self classSide zapOrganization ]rfactiveProcess  < metaLinkOptions: #(+ optionDisabledLink)>  ^activeProcess rfeffectiveProcessnumTemps  ^self numCopiedValues + self numArgs + self numLocalTempsraisedTo: arg1  arg1 isInteger ifTrue: [ ^self raisedToInteger: arg1 ].  arg1 isFraction ifTrue: [ ^self raisedToFraction: arg1 ].  self < 0 ifTrue: [ ^ArithmeticError signal: 'Negative numbers can''t be raised to float powers.' ].  0 = arg1 ifTrue: [ ^self class one ].  1 = arg1 ifTrue: [ ^self ].  0 = self ifTrue: [ arg1 < 0 ifTrue: [ ^(ZeroDivide dividend: 1) signal ] ifFalse: [ ^self ] ].  ^(arg1 * self ln) exptestAddDays  self assert: (january23rd2004 addDays: 0) equals: '2004-01-23' asDate.  self assert: (january23rd2004 addDays: 31) equals: '2004-02-23' asDate.  self assert: (january23rd2004 addDays: 366) equals: '2005-01-23' asDatetestFractionPrinting  self assert: (353 / 359) printString equals: '(353/359)'.  self assert: (2 / 3 printStringBase: 2) equals: '(10/11)'.  self assert: (2 / 3 storeStringBase: 2) equals: '(2r10/2r11)'.  self assert: (5 / 7 printStringBase: 3) equals: '(12/21)'.  self assert: (5 / 7 storeStringBase: 3) equals: '(3r12/3r21)'.  self assert: (11 / 13 printStringBase: 4) equals: '(23/31)'.  self assert: (11 / 13 storeStringBase: 4) equals: '(4r23/4r31)'.  self assert: (17 / 19 printStringBase: 5) equals: '(32/34)'.  self assert: (17 / 19 storeStringBase: 5) equals: '(5r32/5r34)'.  self assert: (23 / 29 printStringBase: 6) equals: '(35/45)'.  self assert: (23 / 29 storeStringBase: 6) equals: '(6r35/6r45)'.  self assert: (31 / 37 printStringBase: 7) equals: '(43/52)'.  self assert: (31 / 37 storeStringBase: 7) equals: '(7r43/7r52)'.  self assert: (41 / 43 printStringBase: 8) equals: '(51/53)'.  self assert: (41 / 43 storeStringBase: 8) equals: '(8r51/8r53)'.  self assert: (47 / 53 printStringBase: 9) equals: '(52/58)'.  self assert: (47 / 53 storeStringBase: 9) equals: '(9r52/9r58)'.  self assert: (59 / 61 printStringBase: 10) equals: '(59/61)'.  self assert: (59 / 61 storeStringBase: 10) equals: '(59/61)'.  self assert: (67 / 71 printStringBase: 11) equals: '(61/65)'.  self assert: (67 / 71 storeStringBase: 11) equals: '(11r61/11r65)'.  self assert: (73 / 79 printStringBase: 12) equals: '(61/67)'.  self assert: (73 / 79 storeStringBase: 12) equals: '(12r61/12r67)'.  self assert: (83 / 89 printStringBase: 13) equals: '(65/6B)'.  self assert: (83 / 89 storeStringBase: 13) equals: '(13r65/13r6B)'.  self assert: (97 / 101 printStringBase: 14) equals: '(6D/73)'.  self assert: (97 / 101 storeStringBase: 14) equals: '(14r6D/14r73)'.  self assert: (103 / 107 printStringBase: 15) equals: '(6D/72)'.  self assert: (103 / 107 storeStringBase: 15) equals: '(15r6D/15r72)'.  self assert: (109 / 113 printStringBase: 16) equals: '(6D/71)'.  self assert: (109 / 113 storeStringBase: 16) equals: '(16r6D/16r71)'.  self assert: (127 / 131 printStringBase: 17) equals: '(78/7C)'.  self assert: (127 / 131 storeStringBase: 17) equals: '(17r78/17r7C)'.  self assert: (137 / 139 printStringBase: 18) equals: '(7B/7D)'.  self assert: (137 / 139 storeStringBase: 18) equals: '(18r7B/18r7D)'.  self assert: (149 / 151 printStringBase: 19) equals: '(7G/7I)'.  self assert: (149 / 151 storeStringBase: 19) equals: '(19r7G/19r7I)'.  self assert: (157 / 163 printStringBase: 20) equals: '(7H/83)'.  self assert: (157 / 163 storeStringBase: 20) equals: '(20r7H/20r83)'.  self assert: (167 / 173 printStringBase: 21) equals: '(7K/85)'.  self assert: (167 / 173 storeStringBase: 21) equals: '(21r7K/21r85)'.  self assert: (179 / 181 printStringBase: 22) equals: '(83/85)'.  self assert: (179 / 181 storeStringBase: 22) equals: '(22r83/22r85)'.  self assert: (191 / 193 printStringBase: 23) equals: '(87/89)'.  self assert: (191 / 193 storeStringBase: 23) equals: '(23r87/23r89)'.  self assert: (197 / 199 printStringBase: 24) equals: '(85/87)'.  self assert: (197 / 199 storeStringBase: 24) equals: '(24r85/24r87)'.  self assert: (211 / 223 printStringBase: 25) equals: '(8B/8N)'.  self assert: (211 / 223 storeStringBase: 25) equals: '(25r8B/25r8N)'.  self assert: (227 / 229 printStringBase: 26) equals: '(8J/8L)'.  self assert: (227 / 229 storeStringBase: 26) equals: '(26r8J/26r8L)'.  self assert: (233 / 239 printStringBase: 27) equals: '(8H/8N)'.  self assert: (233 / 239 storeStringBase: 27) equals: '(27r8H/27r8N)'.  self assert: (241 / 251 printStringBase: 28) equals: '(8H/8R)'.  self assert: (241 / 251 storeStringBase: 28) equals: '(28r8H/28r8R)'.  self assert: (257 / 263 printStringBase: 29) equals: '(8P/92)'.  self assert: (257 / 263 storeStringBase: 29) equals: '(29r8P/29r92)'.  self assert: (269 / 271 printStringBase: 30) equals: '(8T/91)'.  self assert: (269 / 271 storeStringBase: 30) equals: '(30r8T/30r91)'.  self assert: (277 / 281 printStringBase: 31) equals: '(8T/92)'.  self assert: (277 / 281 storeStringBase: 31) equals: '(31r8T/31r92)'.  self assert: (283 / 293 printStringBase: 32) equals: '(8R/95)'.  self assert: (283 / 293 storeStringBase: 32) equals: '(32r8R/32r95)'.  self assert: (307 / 311 printStringBase: 33) equals: '(9A/9E)'.  self assert: (307 / 311 storeStringBase: 33) equals: '(33r9A/33r9E)'.  self assert: (313 / 317 printStringBase: 34) equals: '(97/9B)'.  self assert: (313 / 317 storeStringBase: 34) equals: '(34r97/34r9B)'.  self assert: (331 / 337 printStringBase: 35) equals: '(9G/9M)'.  self assert: (331 / 337 storeStringBase: 35) equals: '(35r9G/35r9M)'.  self assert: (347 / 349 printStringBase: 36) equals: '(9N/9P)'.  self assert: (347 / 349 storeStringBase: 36) equals: '(36r9N/36r9P)'.  self assert: (-2 / 3 printStringBase: 2) equals: '(-10/11)'.  self assert: (-2 / 3 storeStringBase: 2) equals: '(-2r10/2r11)'.  self assert: (5 / -7 printStringBase: 3) equals: '(-12/21)'.  self assert: (5 / -7 storeStringBase: 3) equals: '(-3r12/3r21)'guarded  self max: 1 @ 1fromSpec: arg1  arg1 do: [:arg2 |  | tmp1 tmp2 |        tmp1 := arg2 first asSymbol.        tmp2 := arg2 allButFirst asSet.        self addProtocol: (Protocol name: tmp1 methodSelectors: tmp2) ]sizePop  ^self sizeOpcodeSelector: #genPop withArguments: #()testAsDay  | tmp1 tmp2 tmp3 |  tmp1 := Duration minutes: 60 * 24.  tmp2 := Duration minutes: 60 * 12.  tmp3 := Duration minutes: 60 * 6.  self     assert: 1 day equals: tmp1;     assert: 1.0 day equals: tmp1;     assert: 0.5 day equals: tmp2;     assert: (1 / 2) day equals: tmp2;     assert: (1 / 4) day equals: tmp3.  self assert: 0.4 day + 0.6 day equals: 1 daymessageText  ^messageText ifNil: [ messageText := self standardMessageText ]waitForUserSignalled: arg1 orExpired: arg2  | tmp1 |  tmp1 := 0.  arg2 ifNotNil: [ tmp1 := tmp1 min: arg2 resumptionTick ].  arg1 initSignals.  self primSignal: arg1 atUTCMicroseconds: tmp1.  arg1 waitvalue: arg1 value: arg2 value: arg3  ^receiver perform: selector with: arg1 with: arg2 with: arg3testDaysOfWeekAreConsistent  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := (aSchedule dateAndTimes collect: [:arg1 |  arg1 dayOfWeek ]) asSet.  tmp3 := DateAndTime year: 2003 month: 1 day: 5 hour: 20 minute: 30.  tmp4 := DateAndTime year: 2003 month: 6 day: 4 hour: 20 minute: 30.  tmp2 := OrderedCollection new.  aSchedule between: tmp3 and: tmp4 do: [:arg2 |  tmp2 add: arg2 dayOfWeek ].  self assert: tmp1 equals: tmp2 asSetisSpAnnouncingObject  ^falseliteralAt: arg1 put: arg2  ^self objectAt: arg1 + 1 put: arg2on: arg1 do: arg2  | tmp1 tmp2 tmp3 |  tmp1 := self isActiveProcess ifTrue: [ thisContext ] ifFalse: [ self suspendedContext ].  tmp2 := tmp1 bottomContext.  tmp3 := [ [ tmp2 insertSender: thisContext.  tmp1 jump ] on: arg1 do: arg2.  Processor terminateActive ] asContext.  self isActiveProcess ifTrue: [ tmp3 jump ] ifFalse: [ self install: tmp3 ]previousPc  ^self method pcPreviousTo: pcstoreIntoReceiverVariable: arg1  self object: self receiver instVarAt: arg1 + 1 put: self topclassInstaller  ^self isAnonymous ifTrue: [ Smalltalk anonymousClassInstaller ] ifFalse: [ Smalltalk classInstaller ]putCommentOnFile: arg1 forClass: arg2  | tmp1 |  self classComment isEmptyOrNil ifTrue: [ ^self ].  arg1     cr;     nextPut: $!.  tmp1 := String streamContents: [:arg3 |  arg3           nextPutAll: arg2 name;           nextPutAll: ' commentStamp: '.        commentStamp ifNil: [ commentStamp := '<historical>' ].        commentStamp storeOn: arg3.        arg3           nextPutAll: ' prior: ';           nextPutAll: '0' ].  arg1 nextChunkPut: tmp1.  arg2 organization fileOutCommentOn: arg1.  arg1 cr- arg1  ^(arg1 respondsTo: #asDateAndTime) ifTrue: [ | tmp1 |        tmp1 := arg1 asDateAndTime.        Duration seconds: SecondsInDay * (julianDayNumber - tmp1 julianDayNumberUTC) + (seconds - tmp1 secondsSinceMidnightUTC) nanoSeconds: nanos - tmp1 nanoSecond ] ifFalse: [ self + arg1 negated ]primitiveFailed  self primitiveFailed: thisContext sender selectorusers  ^#()testCopyWithTrailerBytes  < pragma: #pragma>  | tmp1 tmp2 |  tmp1 := thisContext method.  self assert: tmp1 pragmas notEmpty.  tmp2 := tmp1 copyWithTrailerBytes: tmp1 trailer.  self assert: (tmp1 equivalentTo: tmp2).  self deny: tmp1 identicalTo: tmp2.  self assert: tmp1 symbolic equals: tmp2 symbolic.  self assert: tmp1 ~~ tmp2.  self assert: tmp2 penultimateLiteral method identicalTo: tmp2.  self assert: tmp1 penultimateLiteral method identicalTo: tmp1.  tmp1 pragmas do: [:arg1 |  self assert: arg1 method identicalTo: tmp1 ].  tmp2 pragmas do: [:arg1 |  self assert: arg1 method identicalTo: tmp2 ]-> arg1  ^Association key: self value: arg1expectedArgumentsCount: arg1  expectedArgumentsCount := arg1genPushNClosureTemps: arg1  arg1 timesRepeat: [ self genPushSpecialLiteral: nil ]newRectButtonPressedDo: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := self currentWorld activeHand.  tmp3 := tmp4 anyButtonPressed.  tmp1 := self.  self drawReverseFrame: tmp1.  tmp4 captureEventsWhile: [:arg2 |  arg2 isMouse ifTrue: [ tmp3 := arg2 anyButtonPressed.              tmp2 := arg1 value: tmp1 value: arg2 cursorPoint.              tmp2 = tmp1 ifFalse: [ self drawReverseFrame: tmp1.                    self drawReverseFrame: tmp2.                    tmp1 := tmp2 ].              tmp3 ] ifFalse: [ true ] ].  self drawReverseFrame: tmp1.  self currentWorld activeHand     newMouseFocus: nil;     showTemporaryCursor: nil.  ^tmp1metaLinkOptions  ^{(#selector -> #(+ optionCompileOnLinkInstallation)) .   (#isMethodProperties -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}compressed  ^Rectangle origin: origin ceiling corner: corner floorreadFromString: arg1  ^self readFrom: arg1 readStreamcompiler  ^self methodClass compilertestDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 1testMultiply  self assert: aDuration * 2 equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10)interpretV3ClosuresExtension: arg1 in: arg2 for: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  arg1 <= 6 ifTrue: [ tmp3 := arg2 at: pc.        pc := pc + 1.        arg1 <= 2 ifTrue: [ tmp1 := tmp3 // 64.              tmp2 := tmp3 \\ 64.              arg1 = 0 ifTrue: [ tmp1 = 0 ifTrue: [ ^arg3 pushReceiverVariable: tmp2 ].                    tmp1 = 1 ifTrue: [ ^arg3 pushTemporaryVariable: tmp2 ].                    tmp1 = 2 ifTrue: [ ^arg3 pushConstant: (arg2 literalAt: tmp2 + 1) ].                    tmp1 = 3 ifTrue: [ ^arg3 pushLiteralVariable: (arg2 literalAt: tmp2 + 1) ] ].              arg1 = 1 ifTrue: [ tmp1 = 0 ifTrue: [ ^arg3 storeIntoReceiverVariable: tmp2 ].                    tmp1 = 1 ifTrue: [ ^arg3 storeIntoTemporaryVariable: tmp2 ].                    tmp1 = 2 ifTrue: [ self error: 'illegalStore' ].                    tmp1 = 3 ifTrue: [ ^arg3 storeIntoLiteralVariable: (arg2 literalAt: tmp2 + 1) ] ].              arg1 = 2 ifTrue: [ tmp1 = 0 ifTrue: [ ^arg3 popIntoReceiverVariable: tmp2 ].                    tmp1 = 1 ifTrue: [ ^arg3 popIntoTemporaryVariable: tmp2 ].                    tmp1 = 2 ifTrue: [ self error: 'illegalStore' ].                    tmp1 = 3 ifTrue: [ ^arg3 popIntoLiteralVariable: (arg2 literalAt: tmp2 + 1) ] ] ].        arg1 = 3 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp3 \\ 32 + 1) super: false numArgs: tmp3 // 32 ].        arg1 = 4 ifTrue: [ tmp4 := arg2 at: pc.              pc := pc + 1.              tmp1 := tmp3 // 32.              tmp1 = 0 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp4 + 1) super: false numArgs: tmp3 \\ 32 ].              tmp1 = 1 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp4 + 1) super: true numArgs: tmp3 \\ 32 ].              tmp1 = 2 ifTrue: [ ^arg3 pushReceiverVariable: tmp4 ].              tmp1 = 3 ifTrue: [ ^arg3 pushConstant: (arg2 literalAt: tmp4 + 1) ].              tmp1 = 4 ifTrue: [ ^arg3 pushLiteralVariable: (arg2 literalAt: tmp4 + 1) ].              tmp1 = 5 ifTrue: [ ^arg3 storeIntoReceiverVariable: tmp4 ].              tmp1 = 6 ifTrue: [ ^arg3 popIntoReceiverVariable: tmp4 ].              tmp1 = 7 ifTrue: [ ^arg3 storeIntoLiteralVariable: (arg2 literalAt: tmp4 + 1) ] ].        arg1 = 5 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp3 \\ 32 + 1) super: true numArgs: tmp3 // 32 ].        arg1 = 6 ifTrue: [ ^arg3 send: (arg2 literalAt: tmp3 \\ 64 + 1) super: false numArgs: tmp3 // 64 ] ].  arg1 = 7 ifTrue: [ ^arg3 doPop ].  arg1 = 8 ifTrue: [ ^arg3 doDup ].  arg1 = 9 ifTrue: [ ^arg3 pushActiveContext ].  tmp3 := arg2 at: pc.  pc := pc + 1.  arg1 = 10 ifTrue: [ ^tmp3 < 128 ifTrue: [ arg3 pushNewArrayOfSize: tmp3 ] ifFalse: [ arg3 pushConsArrayWithElements: tmp3 - 128 ] ].  tmp4 := arg2 at: pc.  pc := pc + 1.  arg1 = 11 ifTrue: [ ^arg3 callPrimitive: tmp3 + (tmp4 bitShift: 8) ].  arg1 = 12 ifTrue: [ ^arg3 pushRemoteTemp: tmp3 inVectorAt: tmp4 ].  arg1 = 13 ifTrue: [ ^arg3 storeIntoRemoteTemp: tmp3 inVectorAt: tmp4 ].  arg1 = 14 ifTrue: [ ^arg3 popIntoRemoteTemp: tmp3 inVectorAt: tmp4 ].  tmp5 := arg2 at: pc.  pc := pc + 1.  ^arg3 pushClosureCopyNumCopiedValues: (tmp3 bitShift: -4) numArgs: (tmp3 bitAnd: 16rF) blockSize: tmp4 * 256 + tmp5terminate: arg1  | tmp1 |  tmp1 := arg1.  [ tmp1 notNil ] whileTrue: [ tmp1 := tmp1 swapSender: nil ]gtInspectorMetaIn: arg1  < gtInspectorPresentationOrder: 1000>  < gtInspectorTag: #basic>  ^arg1 custom: (GTSimpleMethodsBrowser new startOn: self)asStringMorph  ^self asString asStringMorphisZero  ^seconds = 0 and: [ nanos = 0 ]testExactRaisedTo  self assert: (4 raisedTo: 1 / 2) classAndValueEquals: 2.  self assert: (9 raisedTo: 1 / 2) classAndValueEquals: 3.  self assert: (9 raisedTo: -1 / 2) classAndValueEquals: 1 / 3.  self assert: (-1 raisedTo: 1 / 3) classAndValueEquals: -1.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:arg1 |  self assert: (arg1 squared raisedTo: 1 / 2) classAndValueEquals: arg1.        self assert: (arg1 negated squared raisedTo: 1 / 2) classAndValueEquals: arg1 ].  self assert: (8 raisedTo: 1 / 3) classAndValueEquals: 2.  self assert: (27 raisedTo: 1 / 3) classAndValueEquals: 3.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:arg1 |  self assert: ((arg1 raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: arg1.        self assert: ((arg1 negated raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: arg1 negated ].  self assert: (4 raisedTo: 3 / 2) classAndValueEquals: 8.  self assert: (8 raisedTo: 2 / 3) classAndValueEquals: 4.  self assert: (8 raisedTo: -2 / 3) classAndValueEquals: 1 / 4.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:arg1 |  self assert: ((arg1 raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: arg1 * arg1.        self assert: ((arg1 raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: arg1 * arg1 * arg1.        self assert: ((arg1 negated raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: arg1 * arg1.        self assert: ((arg1 negated raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: arg1 * arg1 * arg1 ].  self assert: (32 raisedTo: 3 / 5) classAndValueEquals: 8.  self assert: (8 raisedTo: 5 / 3) classAndValueEquals: 32.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:arg1 |  self assert: ((arg1 raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: arg1 * arg1 * arg1.        self assert: ((arg1 raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: arg1 * arg1 * arg1 * arg1 * arg1.        self assert: ((arg1 negated raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: (arg1 * arg1 * arg1) negated.        self assert: ((arg1 negated raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: (arg1 * arg1 * arg1 * arg1 * arg1) negated.        self assert: ((arg1 raisedTo: -5) raisedTo: 3 / 5) classAndValueEquals: 1 / (arg1 * arg1 * arg1).        self assert: ((arg1 raisedTo: -3) raisedTo: 5 / 3) classAndValueEquals: 1 / (arg1 * arg1 * arg1 * arg1 * arg1).        self assert: ((arg1 negated raisedTo: -5) raisedTo: 3 / 5) classAndValueEquals: -1 / (arg1 * arg1 * arg1).        self assert: ((arg1 negated raisedTo: -3) raisedTo: 5 / 3) classAndValueEquals: -1 / (arg1 * arg1 * arg1 * arg1 * arg1).        self assert: ((arg1 raisedTo: 5) raisedTo: -3 / 5) classAndValueEquals: 1 / (arg1 * arg1 * arg1).        self assert: ((arg1 raisedTo: 3) raisedTo: -5 / 3) classAndValueEquals: 1 / (arg1 * arg1 * arg1 * arg1 * arg1).        self assert: ((arg1 negated raisedTo: 5) raisedTo: -3 / 5) classAndValueEquals: -1 / (arg1 * arg1 * arg1).        self assert: ((arg1 negated raisedTo: 3) raisedTo: -5 / 3) classAndValueEquals: -1 / (arg1 * arg1 * arg1 * arg1 * arg1).        self assert: ((arg1 raisedTo: 3) + 1 raisedTo: 5 / 3) isFloat.        self assert: ((arg1 negated raisedTo: 3) - 1 raisedTo: 5 / 3) isFloat ]temporaryVariableNamed: arg1  (self hasTemporaryVariableNamed: arg1) ifFalse: [ ^nil ].  ^TemporaryVariable name: arg1 context: selfbindingOf: arg1  | tmp1 |  tmp1 := arg1 asSymbol.  ^(self innerBindingOf: tmp1) ifNil: [ self environment bindingOf: tmp1 ]testHash  self assert: aDuration hash equals: (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) hashremove: arg1 oneStarWithTry: arg2  ^Continuation try: [:arg3 |  self remove: arg1 oneStarWithTry: arg2 continuation: arg3 ] otherwise: [ arg2 ]addClassVarNamed: arg1  self addClassVariable: arg1 asSymbol => ClassVariabletestMixedMethod  | tmp1 |  self should: [ tmp1 := self mixedMethod ] notTakeMoreThanMilliseconds: 3.  self assert: tmp1 equals: 2ifTrue: arg1 ifFalse: arg2  self subclassResponsibilitywillStorePop  ^self method encoderClass isStorePopAt: pc in: self methodtestActiveBlockContextHomeAndActiveHome  [ self assert: thisContext home identicalTo: thisContext activeHome ] valuetestExactSqrt  self assert: 4 sqrt classAndValueEquals: 2.  self assert: 9 sqrt classAndValueEquals: 3.  self assert: Float maxExactInteger squared sqrt classAndValueEquals: Float maxExactInteger.  self assert: (Float maxExactInteger + 1) squared sqrt classAndValueEquals: Float maxExactInteger + 1.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) do: [:arg1 |  self assert: arg1 squared sqrt classAndValueEquals: arg1 ]associationAt: arg1 ifAbsent: arg2  ^(array at: (self scanFor: arg1)) ifNil: [ arg2 value ] ifNotNil: [:arg3 |  arg1 -> arg3 ]setUp  super setUp.  aBlockContext := [ 100 @ 100 corner: 200 @ 200 ].  contextOfaBlockContext := thisContextadaptToFraction: arg1 andSend: arg2  ^self adaptToNumber: arg1 andSend: arg2variable: arg1  variable := arg1testDaysLeftInYear  self assert: aDateAndTime daysLeftInYear equals: 364isAfter: arg1  | tmp1 |  tmp1 := arg1 asDate.  ^self year > tmp1 year or: [ self year = tmp1 year and: [ self monthIndex > tmp1 monthIndex or: [ self monthIndex = tmp1 monthIndex and: [ self dayOfMonth > tmp1 dayOfMonth ] ] ] ]enter  self isOwnerProcess ifTrue: [ nestingLevel := nestingLevel + 1 ] ifFalse: [ mutex wait.        ownerProcess := Processor activeProcess.        nestingLevel := 1 ]protocolNamed: arg1  ^self protocolOrganizer protocolNamed: arg1 ifAbsent: [ nil ]deprecated: arg1 on: arg2 in: arg3  Deprecation new     context: thisContext sender;     explanation: arg1;     date: arg2;     version: arg3;     signaltestMaxVal  Smalltalk vm wordSize = 4 ifTrue: [ self assert: SmallInteger maxVal equals: 16r3FFFFFFF ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: SmallInteger maxVal equals: 16rFFFFFFFFFFFFFFF ]schedule  ^schedulenegated  ^0 - selfdebugStackOn: arg1  ^self debugStack: 100 on: arg1<= arg1  < primitive: 25>  ^super <= arg1isResumable  ^truetranslateBy: arg1  ^(arg1 x + x) @ (arg1 y + y)as: arg1  arg1 == self class ifTrue: [ ^self ].  ^arg1 newFrom: selfremoveAllObsoleteSubclasses  self basicObsoleteSubclasses removeKey: self ifAbsent: [  ]rounded  self isIntegerPoint ifTrue: [ ^self ].  ^x rounded @ y roundedreadNextChar  char := patternStream nexttestIsLetterNumber  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isLetterNumber: tmp2) equals: (tmp1 isLetterNumber: tmp2) ]uses: arg1 instanceVariableNames: arg2  ^self uses: arg1 slots: arg2 asSlotCollectiontestEnvironment: arg1  testEnvironment := arg1dependenciesOf: arg1  ^#(Foo Bar)// arg1  | tmp1 |  arg1 = 0 ifTrue: [ ^(ZeroDivide dividend: self) signal ].  self = 0 ifTrue: [ ^0 ].  tmp1 := self quo: arg1.  (tmp1 negative ifTrue: [ tmp1 * arg1 ~= self ] ifFalse: [ tmp1 = 0 and: [ self negative ~= arg1 negative ] ]) ifTrue: [ ^tmp1 - 1 ] ifFalse: [ ^tmp1 ]testMonotonicity  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := DateAndTime now.  tmp2 := DateAndTime now.  (Delay forMilliseconds: 1000) wait.  tmp3 := DateAndTime now.  tmp4 := DateAndTime now.  self     assert: tmp1 <= tmp2;     assert: tmp2 < tmp3;     assert: tmp3 <= tmp4isPool  ^falseasTime  ^selftestUnionWithSelf  self assert: (aTimespan union: aTimespan) equals: aTimespanisUndefined  ^self instanceSide inheritsFrom: UndefinedClasstestMinutes  self assert: aDuration minutes equals: 3.  self assert: (Duration minutes: 3) minutes equals: 3genBranchPopFalse: arg1  (arg1 > 0 and: [ arg1 < 9 ]) ifTrue: [ stream nextPut: 191 + arg1.        ^self ].  ^self genBranchPopFalseLong: arg1testNext  | tmp1 |  tmp1 := june2nd1973 next.  self assert: tmp1 equals: '3 June, 1973' asDatetimesRepeat: arg1  | tmp1 |  tmp1 := 1.  [ tmp1 <= self ] whileTrue: [ arg1 value.        tmp1 := tmp1 + 1 ]testFromSeconds  self assert: aDateAndTime equals: (DateAndTime fromSeconds: 2177452800)testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 0.  self assert: aDateAndTime hour equals: aDateAndTime hoursintersect: arg1  ^self intersect: arg1 ifNone: [ 0 @ 0 extent: 0 @ 0 ]tryPrimitiveFor: arg1 receiver: arg2 args: arg3  | tmp1 |  (tmp1 := arg1 primitive) = 0 ifTrue: [ ^self class primitiveFailToken ].  ^self doPrimitive: tmp1 method: arg1 receiver: arg2 args: arg3subclass: arg1 uses: arg2 layout: arg3 slots: arg4 classVariables: arg5 poolDictionaries: arg6 package: arg7  ^self classInstaller make: [:arg8 |  arg8           name: arg1;           superclass: self;           slots: arg4;           layoutClass: arg3;           sharedVariables: arg5;           sharedPools: arg6;           traitComposition: arg2 asTraitComposition;           classTraitComposition: arg2 asTraitComposition classComposition;           category: arg7 ]timeZoneName  ^self timeZone nametestclassVarNames  self assert: (Object classVarNames includes: #DependentsFields).  self assert: Object classVarNames equals: Object class classVarNamesexplanationString  ^explanationStringsignal  ^self signal: nilwhichMethodsReferTo: arg1  ^self methods select: [:arg2 |  arg2 hasLiteral: arg1 ]translateBy: arg1  ^Rectangle origin: origin + arg1 corner: corner + arg1positive  ^seconds = 0 ifTrue: [ nanos positive ] ifFalse: [ seconds positive ]= arg1  arg1 isNumber ifFalse: [ ^false ].  arg1 isInteger ifTrue: [ arg1 negative == self negative ifTrue: [ ^(self bytesCompare: arg1) = 0 ] ifFalse: [ ^false ] ].  ^arg1 adaptToInteger: self andCompare: #=wantsStepsIn: arg1  ^self wantsStepsperform: arg1 withArguments: arg2  < reflective: #object:performMessageWithArgs:>  < primitive: 84>  ^self perform: arg1 withArguments: arg2 inSuperclass: self class* arg1  < primitive: 9>  ^super * arg1next  ^self class starting: start + duration duration: durationdayOfMonth  ^self dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg1 ]analogousCodeTo: arg1  ^self class == arg1 class and: [ selector == arg1 selector and: [ args = arg1 arguments and: [ lookupClass == arg1 lookupClass ] ] ]testHasSlot  self assert: (Context hasSlot: (Context slotNamed: #sender)).  self deny: (Context definesSlot: (Context slotNamed: #sender))testHasPoolVarNamed  self assert: (Date usesLocalPoolVarNamed: 'DayNames').  self deny: (Date class usesLocalPoolVarNamed: 'DayNames').  self assert: (RootClassPoolUser usesLocalPoolVarNamed: 'Author').  self deny: (SubclassPoolUser usesLocalPoolVarNamed: 'Author')start  ^self timespans first starttestInexactSqrt  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := 3.0s1.  tmp2 := tmp4 sqrt.  self assert: tmp2 isFloat.  self deny: tmp2 squared equals: 3.  tmp1 := 0.10s2.  tmp3 := tmp1 sqrt.  self assert: tmp3 isFloat.  self deny: tmp3 squared equals: tmp1testDenormalizedPrintString  | tmp1 tmp2 |  tmp1 := LargeNegativeInteger new: 4.  tmp1 basicAt: 2 put: 255.  self assert: tmp1 size equals: 4.  self assert: tmp1 printString equals: '-65280'.  self assert: tmp1 normalize equals: -65280.  self assert: (tmp1 normalize isMemberOf: SmallInteger).  tmp2 := LargeNegativeInteger new: 0.  self assert: tmp2 size equals: 0.  self assert: tmp2 printString equals: '-0'.  self assert: tmp2 normalize equals: 0.  self assert: (tmp2 normalize isMemberOf: SmallInteger)storeStringHex  ^self storeStringBase: 16modificationForbiddenFor: arg1 index: arg2 value: arg3  ^(ModificationForbidden for: self at: arg2 with: arg3 retrySelector: arg1) signaltestHhmm24  self assert: aTime hhmm24 equals: '1234'gtDebuggerEvaluatorIn: arg1  < gtDebuggerPresentationOrder: 10>  (GTProtoObjectVariablesBrowser new evaluatorIn: arg1) title: 'Evaluator'mourn  exampleClosure  < sampleInstance>  instVar1 := 1.  [ 2 ] value.  ^thisContext copytestDayOfWeek  self assert: aDateAndTime dayOfWeek equals: 3.  self assert: aDateAndTime dayOfWeekAbbreviation equals: 'Tue'.  self assert: aDateAndTime dayOfWeekName equals: 'Tuesday'exceptionHandlerBlock  ^self tempAt: 2testAsWeek  self assert: aDateAndTime asWeek equals: (Week starting: '12-31-1969' asDate)isAbstract  ^super isAbstract or: [ self classSide isAbstract ]decodeNoTrailer  size := 4debuggerMap  ^self method debuggerMapshutDown  quickSend: arg1 to: arg2 with: arg3 super: arg4  | tmp1 tmp2 tmp3 |  tmp2 := self.  tmp1 := arg4 ifTrue: [ (self method literalAt: self method numLiterals) value superclass ] ifFalse: [ self objectClass: arg2 ].  [ | tmp4 |  tmp4 := thisContext sender swapSender: self.  tmp3 := self object: arg2 perform: arg1 withArguments: arg3 inClass: tmp1.  thisContext sender swapSender: tmp4 ] ifCurtailed: [ tmp2 := thisContext sender receiver.        tmp2 jump: -1.        tmp2 nextByte = 16r7C ifTrue: [ tmp2 push: (thisContext sender tempAt: 1) ].        thisContext swapSender: thisContext home sender.        tmp2 ].  tmp2 push: tmp3.  ^tmp2testPlus  self assert: aDateAndTime + '0:00:00:00' equals: aDateAndTime.  self assert: aDateAndTime + 0 equals: aDateAndTime.  self assert: aDateAndTime + aDuration equals: (DateAndTime year: 1970 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)name  ^thisClass ifNil: [ 'a Metaclass' ] ifNotNil: [ thisClass name asString , ' class' ]testMethodsWritingSlot  | tmp1 tmp2 |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  tmp1 := (Point methodsWritingSlot: (Point slotNamed: #x)) size.  tmp2 := (Point whichSelectorsStoreInto: 'x') size.  self assert: tmp1 equals: tmp2add: arg1 beforeLink: arg2  | tmp1 |  firstLink == arg2 ifTrue: [ ^self addFirst: arg1 ].  tmp1 := firstLink.  [ tmp1 == nil ] whileFalse: [ tmp1 nextLink == arg2 ifTrue: [ | tmp2 |              tmp2 := arg1 asLink.              tmp2 nextLink: tmp1 nextLink.              tmp1 nextLink: tmp2.              ^tmp2 ].        tmp1 := tmp1 nextLink ].  ^self errorNotFound: arg2setUp  super setUp.  aDate := DateAndTime year: 2004 month: 12 day: 25 hour: 0 minute: 0 second: 0.  aDuration := Duration days: 91 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.  aTimespan := Timespan starting: aDate duration: aDurationln  | tmp1 tmp2 |  tmp1 := super ln.  tmp1 isFinite ifTrue: [ ^tmp1 ].  tmp2 := self highBit.  ^2 ln * tmp2 + (self / (1 << tmp2)) asFloat lntestDaysLeftInYear  self assert: aDateAndTime daysLeftInYear equals: 364bitOr: arg1  < primitive: 'primDigitBitOr' module: 'LargeIntegers'>  | tmp1 |  tmp1 := arg1 normalize.  ^self digitLogic: tmp1 op: #bitOr: length: (self bytesCount max: tmp1 bytesCount)> arg1  arg1 isFraction ifTrue: [ ^numerator * arg1 denominator > (arg1 numerator * denominator) ].  ^arg1 adaptToFraction: self andCompare: #>localHasInstVarRef  | tmp1 tmp2 tmp3 |  tmp1 := InstructionStream on: self.  tmp3 := InstVarRefLocator new.  tmp2 := self endPC.  [ tmp1 pc <= tmp2 ] whileTrue: [ (tmp3 interpretNextInstructionUsing: tmp1) ifTrue: [ ^true ] ].  ^falsecomment  deepCopy  compilerClass  ^self instanceSide classSideCompilerClassclassBuilder  ^self classInstaller new buildersimpleOuterTest  [ [ self doSomething.  MyTestNotification signal.  self doSomethingExceptional ] on: MyTestNotification do: [:arg1 |  arg1 outer.        self doSomethingElse ] ] on: MyTestNotification do: [:arg1 |  self doYetAnotherThing.        arg1 resume ]removeProtocolNamed: arg1  | tmp1 |  tmp1 := self protocolNamed: arg1.  ^self removeProtocol: tmp1iterationsBeforeTimeout: arg1  iterationsBeforeTimeout := arg1duration  ^Duration zeroprimSignal: arg1 atMilliseconds: arg2  < primitive: 136>  ^self primitiveFailedtestClosureRestart  self should: [ self privRestartBlockTest ] notTakeMoreThan: 0.1 second.  self should: [ self privRestartArgBlockTest ] notTakeMoreThan: 0.1 secondasTraitComposition  ^TaCompositionElement for: selfaddProtocol: arg1  ^protocols add: arg1rightRotated  ^y negated @ xcritical: arg1  | tmp1 |  tmp1 := Processor activeProcess.  tmp1 == owner ifTrue: [ ^arg1 value ].  ^semaphore critical: [ owner := tmp1.        arg1 ensure: [ owner := nil ] ]initialize  super initialize.  protocolOrganizer := ProtocolOrganizer newtestWaitTimeoutMSecs  self assert: (Semaphore new waitTimeoutMSecs: 50) identicalTo: true.  self assert: (Semaphore new signal waitTimeoutMSecs: 50) identicalTo: falseliteralEqual: arg1  ^(super literalEqual: arg1) and: [ self scale = arg1 scale ]isClassOrTrait  ^self isClass or: [ self isTrait ]testIsLetter  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isLetter: tmp2) equals: (tmp1 isLetter: tmp2) ]compiler  ^self class compilerClass new class: selftestSetUp  self assert: aBlockContext home equals: contextOfaBlockContext.  self assert: aBlockContext receiver equals: self.  self assert: (aBlockContext method isNil or: [ aBlockContext method isKindOf: CompiledCode ])testRaisedToErrorConditions  self should: [ -1 / 16 raisedTo: 1 / 4 ] raise: ArithmeticError.  self should: [ (((1 << 1024) + 1) / ((1 << 1024) + 3)) negated raisedTo: 1 / 4 ] raise: ArithmeticErrorlink: arg1 toSlot: arg2  arg2 link: arg1seconds: arg1  seconds := arg1.  nanos := 0meta  ^KMModifier meta + selfbottom: arg1  ^origin corner: corner x @ arg1printSubclassesOn: arg1 level: arg2 filter: arg3  | tmp1 |  arg3 ifNotNil: [ (arg3 includes: self) ifFalse: [ ^self ] ].  arg1 crtab: arg2.  arg1 nextPutAll: self name.  arg1     space;     print: self instVarNames.  self == Class ifTrue: [ arg1           crtab: arg2 + 1;           nextPutAll: '[ ... all the Metaclasses ... ]'.        ^self ].  tmp1 := self subclasses asSortedCollection: [:arg4 :arg5 |  arg4 name <= arg5 name ].  tmp1 do: [:arg6 |  arg6 printSubclassesOn: arg1 level: arg2 + 1 filter: arg3 ]sizeStoreRemoteTemp: arg1 inVectorAt: arg2  ^self sizeOpcodeSelector: #genStoreRemoteTemp:inVectorAt: withArguments: {arg1 .         arg2}pop  | tmp1 |  tmp1 := self at: stackp.  self stackp: stackp - 1.  ^tmp1asMethodConstant  | tmp1 tmp2 tmp3 |  tmp1 := self value.  tmp2 := thisContext sender sourceNodeExecuted.  tmp3 := MetaLink new     metaObject: tmp1;     control: #instead.  tmp2 link: tmp3.  ^tmp1testEmptyTemplate  | tmp1 |  tmp1 := LargePositiveInteger new: 4.  self assert: tmp1 size equals: 4.  self assert: tmp1 printString equals: '0'.  self assert: tmp1 normalize equals: 0testFloor  self assert: (3 / 2) floor equals: 1.  self assert: (-3 / 2) floor equals: -2removeSlot: arg1  ^self instanceSide removeClassSlot: arg1/ arg1  arg1 class = self class ifTrue: [ ^self asFraction / arg1 asFraction asScaledDecimal: (scale max: arg1 scale) ].  ^self coerce: self asFraction / arg1timeToRunWithoutGC  ^Smalltalk vm totalGCTime + self timeToRun asMilliSeconds - Smalltalk vm totalGCTimeintegerPart  ^self truncatedtop  ^topisConcatenatedHtmlAttributeValue  ^falseascending  ^self asSortFunctionisFraction  ^truetestDigitSum  self assert: 1234 digitSum equals: 10adaptToPoint: arg1 andSend: arg2  ^arg1 perform: arg2 with: self @ self>> arg1  ^self compiledMethodAt: arg1pluralize: arg1 with: arg2  ^self printString , ' ' , (self abs = 1 ifTrue: [ arg1 ] ifFalse: [ arg2 ])literalsDo: arg1  1 to: self numLiterals do: [:arg2 |  arg1 value: (self objectAt: arg2 + 1) ]second  ^seconds rem: SecondsInMinuteisOtherSymbol  ^self characterSet isOtherSymbol: selftestIncludesMethod  self assert: (Object includesMethod: Object >> #halt).  self deny: (Class includesMethod: Object >> #halt).  self assert: (Point includesMethod: Point >> #x).  self deny: (LookupKey includesMethod: Point >> #x)wantsDroppedMorph: arg1 event: arg2 inMorph: arg3  ^falseoffset  ^start offsetsuspend  < primitive: 88>  | tmp1 |  myList ifNil: [ ^nil ].  tmp1 := myList.  myList := nil.  tmp1 remove: self ifAbsent: [  ].  ^tmp1systemIconName  ^#classIconround: arg1  ^selftestYearMonthDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 2004 month: 2 day: 29 hour: 13 minute: 33 second: 0 offset: 2 hours)asInteger  ^self truncatedwritesField: arg1  | tmp1 tmp2 |  tmp1 := arg1 - 1.  ((tmp2 := InstructionStream on: self) scanFor: (self encoderClass instVarWriteScanBlockFor: tmp1 using: tmp2)) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:arg2 |  arg2 writesField: arg1 ]initialize  super initialize.  self basicSuperclass: Object.  self methodDict: self emptyMethodDictionary.  self setFormat: Object formattestPrintShowingDecimalPlaces  self assert: (111.2 printShowingDecimalPlaces: 2) equals: '111.20'.  self assert: (111.2 printShowingDecimalPlaces: 0) equals: '111'.  self assert: (111 printShowingDecimalPlaces: 0) equals: '111'.  self assert: (111111111111111 printShowingDecimalPlaces: 2) equals: '111111111111111.00'.  self assert: (10 printShowingDecimalPlaces: 20) equals: '10.00000000000000000000'.  self assert: (0.98 printShowingDecimalPlaces: 2) equals: '0.98'.  self assert: (-0.98 printShowingDecimalPlaces: 2) equals: '-0.98'.  self assert: (2.567 printShowingDecimalPlaces: 2) equals: '2.57'.  self assert: (-2.567 printShowingDecimalPlaces: 2) equals: '-2.57'.  self assert: (0.01 printShowingDecimalPlaces: 2) equals: '0.01'.  self assert: (-0.001 printShowingDecimalPlaces: 2) equals: '0.00'tan  ^self sin / self cossetUp  super setUp.  classFactory := ClassFactoryForTestCase newgreaseDeprecatedApi: arg1 details: arg2  GRDeprecatedApiNotification new     details: arg2;     signal: arg1dayOfYear  ^start dayOfYearmarkAsRingResolved  asTextMorph  ^TextMorph new contentsAsIs: self asStringOrTexttimesTwoPower: arg1  < primitive: 54>  arg1 < -29 ifTrue: [ ^self * (2.0 raisedToInteger: arg1) ].  arg1 < 0 ifTrue: [ ^self / (1 bitShift: 0 - arg1) asFloat ].  arg1 < 30 ifTrue: [ ^self * (1 bitShift: arg1) asFloat ].  ^self * (2.0 raisedToInteger: arg1)shortDebugStack  ^String streamContents: [:arg1 |  self debugStack: 10 on: arg1 ]definitionWithoutSlots  | tmp1 tmp2 |  tmp1 := self sharedPoolsString.  tmp2 := (String new: 800) writeStream.  superclass ifNotNil: [ tmp2 nextPutAll: superclass name ] ifNil: [ tmp2 nextPutAll: 'ProtoObject' ].  tmp2     nextPutAll: self kindOfSubclass;     store: self name.  self hasTraitComposition ifTrue: [ tmp2           crtab;           nextPutAll: 'uses: ';           nextPutAll: self traitCompositionString ].  tmp2     crtab;     nextPutAll: 'instanceVariableNames: ';     store: self instanceVariablesString.  tmp2     crtab;     nextPutAll: 'classVariableNames: ';     store: self classVariablesString.  tmp1 = '' ifFalse: [ tmp2           crtab;           nextPutAll: 'poolDictionaries: ';           store: tmp1 ].  tmp2     crtab;     nextPutAll: 'package: ';     store: self category asString.  superclass ifNil: [ tmp2           nextPutAll: '.';           cr.        tmp2 nextPutAll: self name.        tmp2           space;           nextPutAll: 'superclass: nil' ].  ^tmp2 contentstestSetIsReadOnlyImmediate  self alwaysReadOnlyObjects do: [:arg1 |  self testObject: arg1 initialState: true tuples: #(#(true true true) #(false true true)) ]testSupplyAnswerThroughNestedBlocks  self should: [ true = ([ [ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('Blub' false) ] valueSupplyingAnswer: #('Smalltalk' true)) ]valueSuppressingMessages: arg1  ^self valueSuppressingMessages: arg1 supplyingAnswers: #()testallMethodsWritingSlot  | tmp1 |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  tmp1 := LookupKey allMethodsWritingSlot: (LookupKey slotNamed: #key).  self assert: (tmp1 includes: Association >> #key:value:)exception: arg1  exception := arg1calypsoEnvironmentType  ^self classtemporaryVariables  ^self tempNames collect: [:arg1 |  TemporaryVariable new name: arg1 ]setValue: arg1  self error: 'Characters are immutable'isOtherPunctuation  ^self characterSet isOtherPunctuation: selfincludesBehavior: arg1  self isTrait ifTrue: [ ^false ].  ^self == arg1 or: [ self inheritsFrom: arg1 ]superclass: arg1 withLayoutType: arg2 slots: arg3  | tmp1 tmp2 tmp3 |  tmp1 := arg1 ifNil: [ EmptyLayout instance ] ifNotNil: [ arg1 classLayout ].  tmp2 := tmp1 slotScope extend: arg3.  tmp3 := arg2 extending: tmp1 scope: tmp2 host: self.  tmp3 checkSanity.  self superclass: arg1 layout: tmp3binding  ^self methodDict ifEmpty: [ LiteralVariable key: nil value: self ] ifNotEmpty: [:arg1 |  arg1 anyOne classBinding ]silentlyRenameCategory: arg1 toBe: arg2  self protocolOrganizer renameProtocol: arg1 into: arg2testOnForkErrorTakesLessThanOneSecond  | tmp1 tmp2 |  self     flag: 'This test is too brittle, failing often on Windows CI';     skip.  self flag: 'The following line makes the test pass under headless linux. Everywhere else this test works'.  Smalltalk os isUnix ifTrue: [ 1 milliSecond wait ].  tmp1 := Semaphore new.  [ 1 / 0 ] on: Exception fork: [ tmp1 signal ].  tmp2 := tmp1 waitTimeoutSeconds: 1.  self assert: tmp2 identicalTo: falsetestCopy  self assert: 2.0 copy equals: 2.0.  self assert: -0.5 copy equals: -0.5.  self assert: Float nan copy isNaN.  self assert: Float infinity copy equals: Float infinity.  self assert: Float infinity negated copy equals: Float infinity negated.  self assert: 0.0 copy hex equals: 0.0 hex.  self assert: Float negativeZero copy hex equals: Float negativeZero hexasCollectionElement  ^CollectionElement withNilnumerator  ^selfwaitFor: arg1 maxSeconds: arg2  ^self waitFor: arg1 maxMilliseconds: (arg2 * 1000) asIntegerlowBit  | tmp1 tmp2 tmp3 |  tmp1 := self.  tmp1 = 0 ifTrue: [ ^0 ].  tmp2 := 0.  [ (tmp3 := tmp1 bitAnd: 16rFF) = 0 ] whileTrue: [ tmp2 := tmp2 + 8.        tmp1 := tmp1 bitShift: -8 ].  ^tmp2 + (#[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1] at: tmp3)removeFromSystem: arg1  | tmp1 |  self release.  self unload.  self superclass ifNotNil: [ self superclass addObsoleteSubclass: self ].  tmp1 := self category.  self isReferenced ifTrue: [ Undeclared declare: self name asSymbol from: Smalltalk globals ].  self environment forgetClass: self logged: arg1.  self obsolete.  arg1 ifTrue: [ SystemAnnouncer uniqueInstance classRemoved: self fromCategory: tmp1 ]testPrintLimitedString  | tmp1 |  tmp1 := Object new printStringLimitedTo: 4.  self assert: tmp1 equals: 'an O...etc...'testTimeoutWithZeroDuration  self assertSuccess: (ExceptionTester new runTest: #simpleTimeoutWithZeroDurationTest)simpleResumeTest  [ | tmp1 |  self doSomething.  tmp1 := MyResumableTestError signal.  tmp1 = 3 ifTrue: [ self doSomethingElse ].  tmp1 := MyResumableTestError signal.  tmp1 = 3 ifTrue: [ self doSomethingElse ] ] on: MyResumableTestError do: [:arg1 |  self doYetAnotherThing.        arg1 resume: 3 ]simpleTimeoutTest  | tmp1 |  [ 1 to: 1000000 do: [:arg1 |  tmp1 := arg1.        self doSomething ] ] valueWithin: 50 milliSeconds onTimeout: [ self iterationsBeforeTimeout: tmp1.        self doSomethingElse ]isDead  ^pc isNilsetDelay: arg1 forSemaphore: arg2  super setDelay: arg1 forSemaphore: arg2.  process := Processor activeProcess.  expired := falsetestFromSeconds  self assert: aDateAndTime equals: (DateAndTime fromSeconds: 2492985600)basicCheck: arg1  (self bootstrapPackages includes: arg1 packageName) ifFalse: [ ^false ].  ^self newExternalDependencyExistFor: arg1storeOn: arg1  arg1 nextPut: $(.  self printOn: arg1.  arg1 nextPut: $)testIsOtherNumber  self checkCorrespondanceOf: #isOtherNumber: and: #NoincludesSelector: arg1  ^methodSelectors includes: arg1asAlien  ^0step: arg1  ^Processor activeProcess evaluate: [ self suspendedContext == arg1 ifTrue: [ suspendedContext := suspendedContext step ] ifFalse: [ self complete: (self calleeOf: arg1) ] ] onBehalfOf: selfselectorsToBeIgnored  | tmp1 |  tmp1 := #(#printOn:).  ^super selectorsToBeIgnored , tmp1renameCategory: arg1 toBe: arg2  | tmp1 tmp2 tmp3 |  tmp2 := arg1 asSymbol.  tmp3 := arg2 asSymbol.  (categoryArray indexOf: tmp3) > 0 ifTrue: [ ^self ].  (tmp1 := categoryArray indexOf: tmp2) = 0 ifTrue: [ ^self ].  categoryArray := categoryArray copy.  categoryArray at: tmp1 put: tmp3addClassSlot: arg1  ^self classInstaller update: self to: [:arg2 |  arg2           fillFor: self;           classSlots: (self class classLayout slots copyWith: arg1) ]renderOn: arg1  self value: arg1testLargeSqrtFloor  | tmp1 tmp2 |  tmp1 := (SmallInteger maxVal << 100) + 1 << 100.  tmp2 := tmp1 sqrtFloor.  self assert: tmp2 squared <= tmp1.  self assert: (tmp2 + 1) squared > tmp1critiques  < eProperty>  ^ReCriticEngine critiquesOf: selfisShortcutDeclaration  ^self pragmas anySatisfy: [:arg1 |  arg1 selector = #shortcut ]printStringLength: arg1 padded: arg2  ^self printStringBase: 10 length: arg1 padded: arg2javascriptOn: arg1  (String with: self) javascriptOn: arg1testSign  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp5 := {2 .   2.5 .   Float infinity}.  tmp4 := {-3 .   -3.25 .   Float infinity negated}.  tmp6 := 0.0.  tmp2 := Float negativeZero.  tmp3 := tmp5 copyWith: tmp6.  tmp1 := tmp4 copyWith: tmp2.  tmp5 do: [:arg1 |  self assert: arg1 sign equals: 1 ].  tmp4 do: [:arg2 |  self assert: arg2 sign equals: -1 ].  self assert: tmp6 sign equals: 0.  self assert: tmp2 sign equals: 0.  tmp3 do: [:arg3 |  tmp3 do: [:arg1 |  self assert: (arg1 sign: arg3) equals: arg1 ].        tmp1 do: [:arg2 |  self assert: (arg2 sign: arg3) equals: arg2 negated ].        self assert: (tmp6 sign: arg3) sign equals: 0.        self assert: (tmp2 sign: arg3) sign equals: 0.        self assert: (tmp6 sign: arg3) signBit equals: 0.        self assert: (tmp2 sign: arg3) signBit equals: 0 ].  tmp1 do: [:arg4 |  tmp3 do: [:arg1 |  self assert: (arg1 sign: arg4) equals: arg1 negated ].        tmp1 do: [:arg2 |  self assert: (arg2 sign: arg4) equals: arg2 ].        self assert: (tmp6 sign: arg4) sign equals: 0.        self assert: (tmp2 sign: arg4) sign equals: 0.        self assert: (tmp6 sign: arg4) signBit equals: 1.        self assert: (tmp2 sign: arg4) signBit equals: 1 ]storeOn: arg1  arg1     print: self printString;     nextPutAll: ' asTime'gtInspectorVariableNodesIn: arg1  | tmp1 |  tmp1 := self gtInspectorTempNodes sort: [:arg2 :arg3 |  arg2 key < arg3 key ].  arg1 addAll: tmp1.  super gtInspectorVariableNodesIn: arg1testOffset  self assert: aDateAndTime offset equals: '0:00:00:00' asDuration.  self assert: (aDateAndTime offset: '-0:12:00:00') equals: '1979-12-31T12:00:00-12:00' asDateAndTime.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1980-01-01T12:00:00+12:00' asDateAndTimesetAuthorInMetacelloVersion: arg1  arg1 setAuthor: selfsourceNodeForPC: arg1  ^self subclassResponsibilitymethodsAccessingSlot: arg1  ^self methods select: [:arg2 |  arg2 accessesSlot: arg1 ]bitShiftMagnitude: arg1  < primitive: 'primDigitBitShiftMagnitude' module: 'LargeIntegers'>  | tmp1 |  arg1 >= 0 ifTrue: [ ^self digitLshift: arg1 ].  tmp1 := 0 - arg1.  ^(self digitRshift: (tmp1 bitAnd: 7) bytes: (tmp1 bitShift: -3) lookfirst: self bytesCount) normalizeexplanation: arg1  explanationString := arg1testAsDuration  self assert: aDateAndTime asDuration equals: 0 asDurationtestInquiries  self     assert: june2nd1973 dayOfMonth equals: 2;     assert: june2nd1973 dayOfYear equals: 153;     assert: june2nd1973 daysInMonth equals: 30;     assert: june2nd1973 daysInYear equals: 365;     assert: june2nd1973 daysLeftInYear equals: 365 - 153;     assert: june2nd1973 firstDayOfMonth equals: 152simpleEnsureTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingElseString;     add: self doYetAnotherThingString;     yourselfisMeta  ^trueisLiteral  ^self isFinitenegated  ^(self copyto: (LargeNegativeInteger new: self bytesCount)) normalizeremoveSelf  | tmp1 |  tmp1 := receiver.  receiver := nil.  ^tmp1hasSubject  ^organizedClass notNilgenerator  ^generatorstepAt: arg1 in: arg2  ^self stepIn: arg2testMutateWideSymbolUsingPrivateAtPut  | tmp1 |  [ tmp1 := ('hello' , (Character codePoint: 8002) asString) asSymbol.  tmp1 beReadOnlyObject.  self should: [ tmp1 privateAt: 1 put: 65 ] raise: ModificationForbidden ] ensure: [ tmp1 beWritableObject ].  self assert: tmp1 first equals: $hdayMonthYearDo: arg1  ^start dayMonthYearDo: arg1allCategories  ^self protocolOrganizer allProtocolsNamesclassVarNames  ^self classPool keys sortparseIfError: arg1  self initializeParsing.  [ self isDoneParsing ] whileFalse: [ self parseNextPattern ].  self isInvalidPattern ifTrue: arg1.  self convertTwoDigitsYear.  (inputStream atEnd and: [ patternStream atEnd ]) ifFalse: [ DateError signal: 'Input doesn''t match given pattern.' ].  ^self createDateallSelectorsAbove  ^self allSelectorsAboveUntil: ProtoObjectheaderSize  ^8collatedBy: arg1  self numArgs = 1 ifTrue: [ ^PropertySortFunction property: self collatedWith: arg1 asSortFunction ].  self error: 'Cant be converted to sort function. It should hava one arg'traceCrTab: arg1  self trace: arg1.  Transcript     cr;     tabveryDeepCopy  | tmp1 tmp2 |  tmp1 := DeepCopier new initialize: 4096.  tmp2 := self veryDeepCopyWith: tmp1.  tmp1 references associationsDo: [:arg1 |  arg1 value veryDeepFixupWith: tmp1 ].  tmp1 fixDependents.  ^tmp2testOffset  self assert: aDateAndTime offset equals: '0:02:00:00' asDuration.  self assert: (aDateAndTime offset: '-0:12:00:00') equals: '2004-02-28T23:33:00-12:00' asDateAndTime.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '2004-02-29T23:33:00+12:00' asDateAndTimemoveMethodsFrom: arg1 to: arg2  | tmp1 tmp2 |  tmp1 := self protocolNamed: arg1.  tmp2 := self protocolNamed: arg2.  tmp2 addAllMethodsFrom: tmp1.  tmp1 removeAllMethodSelectors.  ^tmp2reBanName  ^self name , ' (Method)'findNextUnwindContextUpTo: arg1  < primitive: 195>  | tmp1 |  tmp1 := self.  [ (tmp1 := tmp1 sender) == nil or: [ tmp1 == arg1 ] ] whileFalse: [ tmp1 isUnwindContext ifTrue: [ ^tmp1 ] ].  ^nilmethodNode  ^self method methodNodescanFor: arg1  ^(InstructionStream on: self) scanFor: [:arg2 |  arg2 = arg1 ]testExecutionCriticalSection  | tmp1 |  tmp1 := mutex critical: [ #result ].  self assert: tmp1 equals: #resultrestoreResumptionTimes: arg1  | tmp1 |  tmp1 := self nowTick.  arg1 do: [:arg2 |  arg2 ifNotNil: [ arg2 resumptionTickAdjustFrom: 0 to: tmp1 ] ]highBitOfMagnitude  | tmp1 tmp2 |  tmp1 := self bytesCount.  [ (tmp2 := self byteAt: tmp1) = 0 ] whileTrue: [ (tmp1 := tmp1 - 1) = 0 ifTrue: [ ^0 ] ].  ^tmp2 highBitOfPositiveReceiver + (8 * (tmp1 - 1))glmCritiqueSourceIn: arg1  ^self gtInspectorSourceIn: arg1allAreasOutsideList: arg1 do: arg2  ^self allAreasOutsideList: arg1 startingAt: 1 do: arg2isDashPunctuation  ^self characterSet isDashPunctuation: selftestSchedulingHigherPriorityServedFirst  | tmp1 tmp2 tmp3 |  tmp1 := Semaphore new signal.  tmp2 := Semaphore new.  [ tmp1 wait.  tmp3 := 11.  tmp2 signal ] forkAt: 11.  [ tmp1 wait.  tmp3 := 12.  tmp2 signal ] forkAt: 12.  tmp2 wait.  self assert: tmp3 = 12 description: 'Second scheduled but higher priority should run first'.  tmp1 signal.  tmp2 wait.  self assert: tmp3 = 11 description: 'First scheduled but lower priority should run after'isReceiverOrAnyArgumentGarbage  ^self isReceiverGarbage or: [ self isAnyArgumentGarbage ]calypsoEnvironmentType  ^ClyMethod< arg1  arg1 isInteger ifTrue: [ self negative == arg1 negative ifTrue: [ self negative ifTrue: [ ^(self bytesCompare: arg1) > 0 ] ifFalse: [ ^(self bytesCompare: arg1) < 0 ] ] ifFalse: [ ^self negative ] ].  ^arg1 adaptToInteger: self andCompare: #<variableWordSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 package: arg6  ^self subclass: arg1 uses: arg2 layout: WordLayout slots: arg3 asSlotCollection classVariablesNames: arg4 poolDictionaries: arg5 category: arg6category  ^self instanceSide categoryargumentNames  ^self propertyAt: #argumentNames ifAbsent: [ self ast argumentNames ]adaptToFloat: arg1 andSend: arg2  ^self adaptToNumber: arg1 andSend: arg2properties  | tmp1 |  ^(tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 ] ifFalse: [ self class methodPropertiesClass forMethod: self selector: tmp1 ]ffiCall: arg1 module: arg2 options: arg3  < ffiCalloutTranslator>  self ffiCall: arg1 library: arg2 options: arg3signBit  ^(self at: 1) bitShift: -31selectorToSendOrSelf  ^self method encoderClass selectorToSendOrItselfFor: self in: self method at: pctest32bitRoundingMode  | tmp1 tmp2 tmp3 |  tmp1 := 2r1.0000000000000000000000111e25 asIEEE32BitWord.  tmp3 := 25 + 127 bitShift: 23.  tmp2 := tmp3 bitOr: 2r10.  self assert: tmp2 equals: tmp1.  tmp1 := 2r1.0000000000000000000000110e25 asIEEE32BitWord.  tmp2 := tmp3 bitOr: 2r10.  self assert: tmp2 equals: tmp1.  tmp1 := 2r1.0000000000000000000000010e25 asIEEE32BitWord.  tmp2 := tmp3 bitOr: 2r0.  self assert: tmp2 equals: tmp1.  tmp1 := 2r1.0000000000000000000000011e25 asIEEE32BitWord.  tmp2 := tmp3 bitOr: 2r1.  self assert: tmp2 equals: tmp1extent: arg1  ^Rectangle origin: self extent: arg1subclasses  ^subclasses ifNil: [ #() ] ifNotNil: [ subclasses copy ]gtDisplayOn: arg1  ^self printOn: arg1cull: arg1  < debuggerCompleteToSender>  ^numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: arg1 ]propertyValueAt: arg1 put: arg2  ^self propertyAt: arg1 put: arg2decimalDigitLength  ^self numberOfDigitsInBase: 10isProvided  ^self isProvided: self markerOrNilduration: arg1  duration := arg1pragmaAt: arg1  | tmp1 |  ^(tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 at: arg1 ifAbsent: [ nil ] ] ifFalse: [ nil ]testAsSeconds  | tmp1 tmp2 tmp3 tmp4 |  self useTimeZone: 'UTC' during: [ tmp2 := Date readFrom: '01-23-2004' readStream.        tmp1 := (tmp2 start - DateAndTime epoch) asSeconds.        self assert: tmp2 asSeconds equals: tmp1.        self assert: (Date fromSeconds: tmp2 asSeconds) equals: tmp2 ].  self useTimeZone: 'EDT' during: [ tmp3 := Date readFrom: '01-23-2004' readStream.        tmp1 := (tmp3 start - DateAndTime epoch) asSeconds.        self assert: tmp3 asSeconds equals: tmp1.        self assert: (Date fromSeconds: tmp3 asSeconds) equals: tmp3 ].  self useTimeZone: 'PST' during: [ tmp4 := Date readFrom: '01-23-2004' readStream.        tmp1 := (tmp4 start - DateAndTime epoch) asSeconds.        self assert: tmp4 asSeconds equals: tmp1.        self assert: (Date fromSeconds: tmp4 asSeconds) equals: tmp4 ].  self assert: tmp2 asSeconds equals: tmp3 asSeconds - (4 * 3600).  self assert: tmp2 asSeconds equals: tmp4 asSeconds - (8 * 3600)isNumber  ^falsesimulate_vmMilliseconds: arg1  vmSimNextWakeupTick ~= 0 ifTrue: [ vmSimNow := arg1 * 1000.        vmSimNow >= vmSimNextWakeupTick ifTrue: [ vmSimNextWakeupTick := 0.              vmSimTheTimerSemaphore signal ] ]paddedByteStringSize: arg1  | tmp1 |  tmp1 := self headerSize + (arg1 = 0 ifTrue: [ 1 ] ifFalse: [ arg1 ]).  ^self align64Bits: tmp1threadSafe  | tmp1 |  RecursionStopper during: [ self assert: fork isNil.        tmp1 := Semaphore new.        fork := [ self threadSafe.        tmp1 signal ] fork.        tmp1 wait.        self assert: fork isTerminated.        fork := nil ]testIsParagraphSeparator  self checkCorrespondanceOf: #isParagraphSeparator: and: #ZpclassSide  ^self subclassResponsibilitycopyFrom: arg1  < primitive: 168>  | tmp1 tmp2 |  tmp1 := self class allInstVarNames.  tmp2 := arg1 class allInstVarNames.  1 to: (tmp1 size min: tmp2 size) do: [:arg2 |  (tmp1 at: arg2) = (tmp2 at: arg2) ifTrue: [ self instVarAt: arg2 put: (arg1 instVarAt: arg2) ] ].  self class isVariable & arg1 class isVariable ifTrue: [ 1 to: (self basicSize min: arg1 basicSize) do: [:arg2 |  self basicAt: arg2 put: (arg1 basicAt: arg2) ] ]asAthensShapeOn: arg1  ^selfcopyForSaving  ^self shallowCopy postCopyfourNeighbors  ^Array with: self + (1 @ 0) with: self + (0 @ 1) with: self + (-1 @ 0) with: self + (0 @ -1)storeOn: arg1 base: arg2  self isFinite ifTrue: [ self signBit = 1 ifTrue: [ arg1 nextPutAll: ' -' ].        arg2 = 10 ifFalse: [ arg1                 print: arg2;                 nextPut: $r ].        self = 0.0 ifTrue: [ arg1 nextPutAll: '0.0' ] ifFalse: [ self abs absPrintExactlyOn: arg1 base: arg2 ] ] ifFalse: [ self isNaN ifTrue: [ arg1 nextPutAll: 'Float nan' ] ifFalse: [ self > 0.0 ifTrue: [ arg1 nextPutAll: 'Float infinity' ] ifFalse: [ arg1 nextPutAll: 'Float infinity negated' ] ] ]deprecated: arg1 transformWith: arg2 when: arg3  Deprecation new     context: thisContext sender;     explanation: arg1;     rule: arg2;     condition: arg3;     transformoffset: arg1  ^self class basicNew     ticks: self ticks offset: arg1 asDuration;     yourself+ arg1  < primitive: 41>  ^arg1 adaptToFloat: self andSend: #+isLocalSelector: arg1  ^self methodDict includesKey: arg1perform: arg1 orSendTo: arg2  ^(self respondsTo: arg1) ifTrue: [ self perform: arg1 ] ifFalse: [ arg2 perform: arg1 ]testBetweenAndDoOverlappingSchedule  | tmp1 |  tmp1 := 0.  aSchedule between: (DateAndTime year: 2002 month: 12 day: 1) and: (DateAndTime year: 2003 month: 1 day: 31) do: [:arg1 |  tmp1 := tmp1 + 1 ].  self assert: tmp1 equals: 8receiver: arg1  receiver := arg1ffiLibraryName  self flag: 'HACK: avoid direct subclassResponsibility to not break RB test cases..'.  ^SubclassResponsibility signalFor: thisContext selectorprotocolNamed: arg1 ifAbsent: arg2  ^self allProtocols detect: [:arg3 |  arg3 name = arg1 ] ifNone: arg2categoryOfElement: arg1 ifAbsent: arg2  ^(self protocolOrganizer protocolsOfSelector: arg1) ifEmpty: [ (organizedClass includesSelector: arg1) ifTrue: [ Protocol unclassified ] ifFalse: arg2 ] ifNotEmpty: [:arg3 |  arg3 first name ]genStorePopInstVar: arg1  (arg1 < 0 or: [ arg1 > 7 ]) ifTrue: [ ^self genStorePopInstVarLong: arg1 ].  stream nextPut: 200 + arg1variableSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 category: arg5  ^self variableSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: '' category: arg5testOneCanProceedWhenIntroducingCapitalizedInstanceVariables  | tmp1 |  [ tmp1 := classFactory newSubclassOf: classFactory defaultSuperclass instanceVariableNames: 'X Y' classVariableNames: '' ] on: Exception do: [:arg1 |  arg1 resume ].  self assert: (testingEnvironment keys includes: tmp1 name)hasSourceCode  ^self method hasSourceCodeasTimeUTC  ^Time seconds: self secondsSinceMidnightUTC nanoSeconds: nanosstoreIntoRemoteTemp: arg1 inVectorAt: arg2  (self at: arg2 + 1) at: arg1 + 1 put: self topinterpolateTo: arg1 at: arg2  ^(self origin interpolateTo: arg1 origin at: arg2) corner: (self corner interpolateTo: arg1 corner at: arg2)printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  self isEmpty ifTrue: [ arg1 << ' empty' ] ifFalse: [ iterations printWithCommasOn: arg1.        arg1           space;           << ('iteration' asPluralBasedOn: iterations).        arg1 << ' in '.        elapsedTime printHumanReadableOn: arg1.        arg1 << '. '.        self printFrequenceOn: arg1 ].  arg1 nextPut: $)variableByteSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4  ^self variableByteSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: '' package: arg4testWritesSlot  ({(Point >> #x) .   (Point >> #setX:setY:)} allSatisfy: #hasSourceCode) ifFalse: [ ^self ].  self deny: (Point >> #x writesSlot: (Point slotNamed: #x)).  self deny: (Point >> #x writesSlot: (Point slotNamed: #y)).  self assert: (Point >> #setX:setY: writesSlot: (Point slotNamed: #y)).  self assert: (Point >> #setX:setY: writesSlot: (Point slotNamed: #x))browse  ^Smalltalk tools browser openOnClass: selfdeepCopy  ^selfto: arg1  to := arg1constructSharedClosureEnvironmentInDeadFrame  | tmp1 tmp2 |  tmp2 := 10.  tmp1 := Array new: 2.  tmp1 at: 1 put: [:arg1 |  tmp2 := arg1 ].  tmp1 at: 2 put: [ tmp2 ].  ^tmp1testReadFromFoolProofExtension  self assert: (DateAndTime fuzzyReadFrom: '2008' readStream) printString equals: '2008-01-01T00:00:00+00:00'.  self assert: (DateAndTime fuzzyReadFrom: '2008-08' readStream) printString equals: '2008-08-01T00:00:00+00:00'.  self assert: (DateAndTime fuzzyReadFrom: '2006-08-28' readStream) printString equals: '2006-08-28T00:00:00+00:00'.  self assert: (DateAndTime fuzzyReadFrom: '2006-08-28T00:00:00.123456789' readStream) printString equals: '2006-08-28T00:00:00.123456789+00:00'.  self assert: (DateAndTime fuzzyReadFrom: '2006-08-28T00:00:00.123456789000' readStream) printString equals: '2006-08-28T00:00:00.123456789+00:00'swap: arg1 with: arg2  | tmp1 |  tmp1 := self basicAt: arg1.  self basicAt: arg1 put: (self basicAt: arg2).  self basicAt: arg2 put: tmp1.  array swap: arg1 with: arg2testMin  | tmp1 tmp2 |  self assert: (2 min: 3) equals: 2.  tmp1 := Float fmax asInteger + 1.  self assert: (Float fmax min: tmp1) equals: Float fmax.  tmp2 := 0.33333333333333333333333333333333333333333.  self assert: (1 / 3 min: tmp2) equals: tmp2asTime  ^start asTimedefaultAction  UnhandledError signalForException: selftestEmbeddingSourceCodeBig  self testEmbeddingSourceCode: (String loremIpsum: 30000)fuelAccept: arg1  ^arg1 visitHookPrimitive: selfparse  ^self parseIfError: [ DateError signal ]testBinding  self assert: Object binding value equals: Object.  self assert: Object binding key equals: #Object.  self assert: Object class binding value equals: Object class.  self assert: Object class binding key isNilisVariableBinding  ^false== arg1  < primitive: 110>  self primitiveFailedsimpleOuterTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselfdurationToRun  ^self timeToRuntickAfterMilliseconds: arg1  ^self nowTick + arg1spotterReferenceFor: arg1  < spotterOrder: 30>  arg1 listProcessor     title: 'References';     allCandidates: [ (SystemNavigation default allReferencesTo: self binding) collect: #compiledMethod ];     itemName: [:arg2 |  arg2 gtDisplayString ];     filter: GTFilterSubstringiterations  ^iterationstestIsDashPunctuation  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isDashPunctuation: tmp2) equals: (tmp1 isDashPunctuation: tmp2) ]interpretNext3ByteSistaV1Instruction: arg1 for: arg2 extA: arg3 extB: arg4 startPC: arg5  | tmp1 tmp2 tmp3 |  tmp1 := self method.  tmp2 := tmp1 at: pc.  tmp3 := tmp1 at: pc + 1.  pc := pc + 2.  arg1 = 248 ifTrue: [ ^arg2 callPrimitive: tmp2 + (tmp3 bitShift: 8) ].  arg1 = 250 ifTrue: [ ^arg2 pushClosureCopyNumCopiedValues: ((tmp2 bitShift: -3) bitAnd: 7) + (arg3 // 16 bitShift: 3) numArgs: (tmp2 bitAnd: 7) + (arg3 \\ 16 bitShift: 3) blockSize: tmp3 + (arg4 bitShift: 8) ].  arg1 = 251 ifTrue: [ ^arg2 pushRemoteTemp: tmp2 inVectorAt: tmp3 ].  arg1 = 252 ifTrue: [ ^arg2 storeIntoRemoteTemp: tmp2 inVectorAt: tmp3 ].  arg1 = 253 ifTrue: [ ^arg2 popIntoRemoteTemp: tmp2 inVectorAt: tmp3 ].  arg1 = 254 ifTrue: [ ^arg2 jumpOrPopIfNotInstanceOf: (tmp1 literalAt: (arg3 bitShift: 8) + tmp2 + 1) distance: (arg4 bitShift: 8) + tmp3 ].  arg1 = 249 ifTrue: [ ^arg2 pushFullClosure: (tmp1 literalAt: (arg3 bitShift: 8) + tmp2 + 1) numCopied: (tmp3 bitAnd: 16r3F) receiverOnStack: (tmp3 bitAt: 7) = 1 ignoreOuterContext: (tmp3 bitAt: 8) = 1 ].  ^self unusedBytecode: arg2 at: arg5>= arg1  < primitive: 546>  ^arg1 adaptToFloat: self andCompare: #>=isRootInEnvironment  ^self superclass isNiltestIsSelfEvaluating  self assert: Processor printString equals: 'Processor'testError  self should: [ self runSimulated: [ self methodWithError ] ] raise: ErrorlastDigit  ^self byteAt: self bytesCountisDoIt  ^self selector isDoItvariableNodes  ^self ast variableNodesvalueWithPossibleArgument: arg1  | tmp1 |  numArgs = 0 ifTrue: [ ^self value ].  numArgs = 1 ifTrue: [ ^self value: arg1 ].  tmp1 := Array new: numArgs.  tmp1 at: 1 put: arg1.  ^self valueWithArguments: tmp1testDynamicVariableRemovedAfterUse  TestDynamicVariable value: 3 during: [  ].  self assert: (Processor activeProcess psValueAt: TestDynamicVariable soleInstance index) equals: nilasPoint  ^selftaskbarLabel  ^self class taskbarLabelassignmentNodes  ^self ast assignmentNodescopy  ^selftestFirstDayOfMonth  self assert: aTimespan firstDayOfMonth equals: 1.  self assert: aDisjointTimespan firstDayOfMonth equals: 1sortCategories  inspector  ^Smalltalk tools inspector inspector: selfend  ^self timespans last nextallSubInstancesDo: arg1  self allInstancesDo: arg1.  self allSubclassesDo: [:arg2 |  arg2 allInstancesDo: arg1 ]testCullCull  [  ] cull: 1 cull: 2.  [:arg1 |   ] cull: 1 cull: 2.  [:arg1 :arg2 |   ] cull: 1 cull: 2.  self should: [ [:arg1 :arg2 :arg3 |   ] cull: 1 cull: 2 ] raise: Error.  self should: [ [:arg1 :arg2 :arg3 :arg4 |   ] cull: 1 cull: 2 ] raise: Error.  self should: [ [:arg1 :arg2 :arg3 :arg4 :arg5 |   ] cull: 1 cull: 2 ] raise: Error.  self assert: ([ 0 ] cull: 1 cull: 2) equals: 0.  self assert: ([:arg1 |  arg1 ] cull: 1 cull: 2) equals: 1.  self assert: ([:arg1 :arg2 |  arg2 ] cull: 1 cull: 2) equals: 2testHasAbstractMethods  self deny: Object hasAbstractMethods.  self deny: Object class hasAbstractMethods.  self assert: Behavior hasAbstractMethods.  self deny: Behavior class hasAbstractMethods.  self assert: ObjectLayout hasAbstractMethods.  self assert: ObjectLayout class hasAbstractMethodsstepToSendOrReturn  ^Processor activeProcess evaluate: [ suspendedContext := suspendedContext stepToSendOrReturn ] onBehalfOf: selfallMethodsAccessingSlot: arg1  ^self withAllSubclasses flatCollect: [:arg2 |  arg2 methodsAccessingSlot: arg1 ]refersToLiteral: arg1  ^self hasLiteralThorough: arg1testPrintOn  self assert: (String streamContents: [:arg1 |  january23rd2004 printOn: arg1 ]) equals: '23 January 2004'testCrossSumBase  self assert: ((-20 to: 20) collect: [:arg1 |  arg1 crossSumBase: 10 ]) asArray equals: #(2 10 9 8 7 6 5 4 3 2 1 9 8 7 6 5 4 3 2 1 0 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 10 2).  self assert: ((-20 to: 20) collect: [:arg1 |  arg1 crossSumBase: 2 ]) asArray equals: #(2 3 2 2 1 4 3 3 2 3 2 2 1 3 2 2 1 2 1 1 0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2).  self should: [ 10 crossSumBase: 1 ] raise: AssertionFailurecalledArgumentsCount  ^calledArgumentsCountenclosedElement  timePerExecution  ^self periodimmediateSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5  ^self classInstaller make: [:arg6 |  arg6           superclass: self;           name: arg1;           layoutClass: ImmediateLayout;           slots: arg2 asSlotCollection;           sharedVariablesFromString: arg3;           sharedPools: arg4;           category: arg5;           environment: self environment ]testIsDecimalDigit  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isDecimalDigit: tmp2) equals: (tmp1 isDecimalDigit: tmp2) ]hasInstVarRef  ^self method hasInstVarRefmethods  ^self methodDict valuesclosure  ^closureOrNilisMessageSend  ^falsetestMaxExactInteger  self assert: Float maxExactInteger asFloat truncated equals: Float maxExactInteger.  0 to: 10000 do: [:arg1 |  self assert: (Float maxExactInteger - arg1) asFloat truncated equals: Float maxExactInteger - arg1 ].  self deny: (Float maxExactInteger + 1) asFloat truncated equals: Float maxExactInteger + 1sourceNodeInOuter  ^self outerCode sourceNodeForPC: self pcInOuternegative  ^trueasString  ^String with: selffindNextHandlerContext  | tmp1 |  tmp1 := self findNextHandlerOrSignalingContext.  tmp1 ifNil: [ ^nil ].  tmp1 isHandlerContext ifTrue: [ ^tmp1 ].  ^tmp1 exception privHandlerContext nextHandlerContexttestWritesField  | tmp1 |  tmp1 := self class compiledMethodAt: #writeX.  self assert: (tmp1 writesField: 4).  tmp1 := self class compiledMethodAt: #writeXandY.  self assert: (tmp1 writesField: 4).  tmp1 := self class compiledMethodAt: #writeXandY.  self assert: (tmp1 writesField: 5).  tmp1 := self class compiledMethodAt: #readX.  self deny: (tmp1 writesField: 4).  tmp1 := self class compiledMethodAt: #readXandY.  self deny: (tmp1 writesField: 4).  tmp1 := self class compiledMethodAt: #readXandY.  self deny: (tmp1 writesField: 5)asShortcut  ^self asKeyCombinationoriginName  ^originNamegenReturnSpecialLiteral: arg1  | tmp1 |  tmp1 := #(true false nil) indexOf: arg1 ifAbsent: 0.  tmp1 = 0 ifTrue: [ ^self error: 'return special literal: ' , arg1 printString , ' is not one of true false nil' ].  stream nextPut: 88 + tmp1testAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)inspectorFields  | tmp1 |  tmp1 := WriteStream on: Array new.  self class allInstVarNames keysAndValuesDo: [:arg1 :arg2 |  tmp1 nextPut: arg2 -> (self instVarAt: arg1) ].  self class isVariable ifTrue: [ 1 to: self basicSize do: [:arg1 |  tmp1 nextPut: arg1 -> (self basicAt: arg1) ] ].  ^tmp1 contentscomplete: arg1  | tmp1 tmp2 |  tmp1 := suspendedContext.  suspendedContext := nil.  tmp2 := Processor activeProcess evaluate: [ tmp1 runUntilErrorOrReturnFrom: arg1 ] onBehalfOf: self.  suspendedContext := tmp2 first.  ^tmp2 second ifNil: [ suspendedContext ] ifNotNil: [:arg2 |  arg2 completeProcess: self with: arg1 ]signal  < debuggerCompleteToSender>  signalContext := thisContext contextTag.  signaler ifNil: [ signaler := self receiver ].  ^signalContext nextHandlerContext handleSignal: selfdoYetAnotherThingString  ^'Do yet another thing.'encodeUndefined  self error: 'use of an undefined kind of trailer encoding'tempAt: arg1 put: arg2  < primitive: 211>  ^self at: arg1 put: arg2setProject: arg1 withInMetacelloConfig: arg2  arg2 setProject: arg1 withString: selfallMethods  self deprecated: 'Use #allMethodSelectors instead' transformWith: '`@receiver allMethods' -> '`@receiver allMethodSelectors'.  ^self allMethodSelectorsinitializeFromContext: arg1  | tmp1 tmp2 |  tmp1 := WriteStream on: (Array new: 20).  tmp2 := arg1.  [ tmp2 notNil ] whileTrue: [ tmp1 nextPut: tmp2.        1 to: tmp2 class instSize do: [:arg2 |  tmp1 nextPut: (tmp2 instVarAt: arg2) ].        1 to: tmp2 size do: [:arg2 |  tmp1 nextPut: (tmp2 at: arg2) ].        tmp2 := tmp2 sender ].  values := tmp1 contentsisRectangle  ^falsebasicRemoveElement: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 1.  tmp2 := 0.  tmp3 := 0.  tmp4 := (Array new: elementArray size) writeStream.  [ (tmp2 := tmp2 + 1) <= elementArray size ] whileTrue: [ [ tmp2 > (categoryStops at: tmp1) ] whileTrue: [ categoryStops at: tmp1 put: tmp3.              tmp1 := tmp1 + 1 ].        (elementArray at: tmp2) = arg1 ifFalse: [ tmp3 := tmp3 + 1.              tmp4 nextPut: (elementArray at: tmp2) ] ].  [ tmp1 <= categoryStops size ] whileTrue: [ categoryStops at: tmp1 put: tmp3.        tmp1 := tmp1 + 1 ].  elementArray := tmp4 contents.  self assertInvariantmethod  ^self compiledBlockhasTemporaryVariableNamed: arg1  ^self tempNames includes: arg1arcSin  ^self asFloat arcSinprintObject: arg1 on: arg2  [ arg1 printOn: arg2 ] on: Exception do: [:arg3 |  arg2 << '<cannot print object>' ]testMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'AM'classAndMethodFor: arg1 do: arg2 ifAbsent: arg3  self withAllSuperclassesDo: [:arg4 |  | tmp1 |        tmp1 := arg4 compiledMethodAt: arg1 ifAbsent: [ nil ].        tmp1 ifNotNil: [ ^arg2 value: arg4 value: tmp1 ] ].  ^arg3 valuesourceCodeAt: arg1  ^(self compiledMethodAt: arg1) sourceCodejavascriptOn: arg1  arg1 nextPutAll: 'null'testInjectingExceptionHandlerIntoProcessWithArg  | tmp1 tmp2 tmp3 tmp4 tmp5 |  DefaultExecutionEnvironment beActive.  tmp1 := Error new messageText: 'test error'.  tmp4 := true.  tmp3 := [:arg1 |  tmp5 := arg1.  tmp1 signal.  tmp4 := false ] newProcessWith: #(#arg).  tmp3 on: Error do: [:arg2 |  tmp2 := arg2 ].  tmp3 resume.  [ tmp3 isTerminated ] whileFalse: [ Processor yield ].  self assert: tmp2 identicalTo: tmp1.  self assert: tmp4.  self assert: tmp5 equals: #argasciiValue  < primitive: 171>  ^self primitiveFailedstoreStringBase: arg1  ^String streamContents: [:arg2 |  self storeOn: arg2 base: arg1 ]schedulingProcess  ^timerEventLoopclassAnnotations  ^ClassAnnotation findAllAnnotationsFor: selfmetacelloVersionComponentLessThan: arg1  ^arg1 metacelloIntegerLessThanSelf: selfcheckOwnerProcess  self isOwnerProcess ifFalse: [ self error: 'Monitor access violation' ]accessesSlot: arg1  ^arg1 isAccessedIn: selfmessage: arg1  message := arg1testAsDelay  self deny: aDuration asDelay equals: aDurationfloor  self isIntegerPoint ifTrue: [ ^self ].  ^x floor @ y floorprintSeparateDateAndTimeOn: arg1  arg1     print: self asDate;     space;     print: self asTimesetName: arg1  name := arg1complexRecursionLastCall  self complexRecursionsizePushFullClosure: arg1 numCopied: arg2  ^self sizeOpcodeSelector: #genPushFullClosure:numCopied: withArguments: {arg1 .         arg2}value: arg1 value: arg2  < primitive: 203>  numArgs ~= 2 ifTrue: [ self numArgsError: 2 ].  ^self primitiveFailedtestPrintSeparatedByEverySignedOn  | tmp1 |  tmp1 := [:arg1 :arg2 |  String streamContents: [:arg3 |  arg1 printSeparatedBy: $. every: 3 signed: arg2 on: arg3 ] ].  self assert: (tmp1 value: 123456789 value: false) equals: '123.456.789'.  self assert: (tmp1 value: -123456789 value: false) equals: '-123.456.789'.  self assert: (tmp1 value: 123456789 value: true) equals: '+123.456.789'.  self assert: (tmp1 value: -123456789 value: true) equals: '-123.456.789'testIntersectionWithDisjoint  self assert: (aTimespan intersection: aDisjointTimespan) isNilasFunction: arg1  ^JSFunction new     add: self;     arguments: arg1readX  | tmp1 |  tmp1 := x.  ^tmp1withAllSuperAndSubclassesDo: arg1  self allSuperclassesDo: arg1.  arg1 value: self.  self allSubclassesDo: arg1isResumable  ^falsecommand  ^KMModifier command + selfbetween: arg1 and: arg2 do: arg3  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := self end min: arg2.  tmp1 := self start.  tmp4 := arg1 asDate.  (tmp4 > tmp1 asDate and: [ self everyDayAtSameTimes ]) ifTrue: [ tmp1 := DateAndTime date: tmp4 time: tmp1 asTime ].  tmp3 := 1.  [ tmp1 < arg1 ] whileTrue: [ tmp1 := tmp1 + (schedule at: tmp3).        tmp3 := tmp3 + 1.        tmp3 > schedule size ifTrue: [ tmp3 := 1 ] ].  [ tmp1 <= tmp2 ] whileTrue: [ arg3 value: tmp1.        tmp1 := tmp1 + (schedule at: tmp3).        tmp3 := tmp3 + 1.        tmp3 > schedule size ifTrue: [ tmp3 := 1 ] ]perform: arg1 withArguments: arg2 inSuperclass: arg3  < reflective: #object:performMessageInSuperclass:>  < primitive: 100>  arg1 isSymbol ifFalse: [ ^self error: 'selector argument must be a Symbol' ].  arg1 numArgs = arg2 size ifFalse: [ ^self error: 'incorrect number of arguments' ].  (self class includesBehavior: arg3) ifFalse: [ ^self error: 'lookupClass is not in my inheritance chain' ].  self primitiveFailedisSafeForHTTP  ^self charCode < 128 and: [ self isAlphaNumeric or: [ '.-_' includes: (Character value: self charCode) ] ]and: arg1  ^selftestTimeZoneEquivalence2  | tmp1 tmp2 |  tmp1 := DateAndTime year: 2004 month: 5 day: 24 hour: 22 minute: 40.  tmp2 := tmp1 offset: 3 hours.  self assert: (tmp1 - tmp2) asSeconds equals: 0.  self assert: tmp1 equals: tmp2millisecondsUntilResumptionTime: arg1  ^(arg1 - Time microsecondClockValue) // 1000testOR  self assert: true | true.  self assert: true | falsehandleSignal: arg1  ^arg1 resumeUnchecked: arg1 defaultActionserializeToFileNamed: arg1  ^FLSerializer serialize: self toFileNamed: arg1round: arg1  ^self roundTo: (10 raisedTo: arg1 negated)installLink: arg1  self reflectiveMethod ifNil: [ self createTwin ].  self reflectiveMethod increaseLinkCount.  (arg1 optionCompileOnLinkInstallation or: [ self isRealPrimitive ]) ifTrue: [ self reflectiveMethod compileAndInstallCompiledMethod ] ifFalse: [ self invalidate ].  arg1 announceChangeisReturnSelf  ^self primitive = 256= arg1  arg1 isNumber ifFalse: [ ^false ].  arg1 isFraction ifTrue: [ numerator = 0 ifTrue: [ ^arg1 numerator = 0 ].        ^numerator * arg1 denominator = (arg1 numerator * denominator) ].  ^arg1 adaptToFraction: self andCompare: #=testStoring  self     assert: time storeString equals: '''4:02:47 am'' asTime';     assert: time equals: '4:02:47 am' asTimetestHasSlotNamed  self assert: (Context hasSlotNamed: #sender).  self assert: (Context hasSlotNamed: #method)asSmallerPowerOfTwo  | tmp1 |  (numerator = 0 or: [ numerator sign ~= denominator sign ]) ifTrue: [ ^DomainError signal: 'Value outside (0 , infinity)' from: 0 ].  ^(tmp1 := denominator // numerator) > 0 ifTrue: [ (tmp1 isPowerOfTwo and: [ denominator \\ numerator = 0 ]) ifTrue: [ Fraction numerator: 1 denominator: tmp1 ] ifFalse: [ Fraction numerator: 1 denominator: (1 bitShift: tmp1 highBit) ] ] ifFalse: [ 1 bitShift: (numerator // denominator) highBit - 1 ]testPoolVariableAccessibleInSubclassOfClassUser  PoolDefiner initialize.  SubclassPoolUser compileAll.  self assert: SubclassPoolUser gloups equals: 42.  self assert: SubclassPoolUser author equals: 'Ducasse'printOn: arg1  super printOn: arg1.  arg1     nextPutAll: '(';     print: millisecondDelayDuration;     nextPutAll: ' msecs'.  beingWaitedOn ifTrue: [ arg1           nextPutAll: '; ';           print: self millisecondsToGo;           nextPutAll: ' msecs remaining' ].  arg1 nextPutAll: ')'gtInspectorVariableValuePairs  | tmp1 |  tmp1 := OrderedCollection new.  self gtInspectorVariableNodesIn: tmp1.  ^tmp1 collect: [:arg1 |  arg1 key -> arg1 value ]testMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'AM'testToBy  self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) equals: (DateAndTime new to: DateAndTime new + 10 days by: 5 days)unreferencedInstanceVariables  ^self slots reject: [:arg1 |  arg1 isReferenced ]isDayPattern  ^char = $dtestDosEpoch  self useNonUtcTimeZoneDuring: [ | tmp1 |        tmp1 := '1 January 1980 00:00' asDateAndTime.        self deny: DateAndTime dosEpoch equals: tmp1 ].  self useTimeZone: 'UTC' during: [ | tmp1 |        tmp1 := '1 January 1980 00:00' asDateAndTime.        self assert: DateAndTime dosEpoch equals: tmp1 ].  self assert: DateAndTime dosEpoch equals: '1980-01-01T00:00:00+00:00' asDateAndTimeisConnectorPunctuation  ^self characterSet isConnectorPunctuation: selfsourceNodeExecuted  ^method sourceNodeExecutedForPC: self executedPCtestIntegerHex  | tmp1 |  tmp1 := 15 asInteger hex.  self assert: tmp1 equals: '16rF'.  tmp1 := 0 asInteger hex.  self assert: tmp1 equals: '16r0'.  tmp1 := 255 asInteger hex.  self assert: tmp1 equals: '16rFF'.  tmp1 := 90 asInteger hex.  self assert: tmp1 equals: '16r5A'testMutateByteStringyUsingByteAtPut  | tmp1 |  tmp1 := ByteString new: 5.  tmp1 beReadOnlyObject.  self should: [ tmp1 byteAt: 1 put: 100 ] raise: ModificationForbidden.  [ tmp1 byteAt: 1 put: 100 ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first asciiValue equals: 100isEmptyCategoryNamed: arg1  | tmp1 |  tmp1 := categoryArray indexOf: arg1 ifAbsent: [ ^false ].  ^self isEmptyCategoryNumber: tmp1needsFrameSize: arg1  self numTemps + arg1 > LargeFrame ifTrue: [ ^self error: 'Cannot compile -- stack including temps is too deep' ].  self setFrameBit: (self numTemps + arg1 > SmallFrame or: [ self primitive = 84 ])storeOn: arg1  self printOn: arg1asStringYMDHM  ^String streamContents: [:arg1 |  self printYMDOn: arg1.        arg1 nextPut: Character space.        self hour printOn: arg1 base: 10 length: 2 padded: true.        arg1 nextPut: $:.        self minute printOn: arg1 base: 10 length: 2 padded: true ]sizePushLiteralVar: arg1  ^self sizeOpcodeSelector: #genPushLiteralVar: withArguments: {arg1}actionMap  ^EventManager actionMapFor: selfremoveActionsSatisfying: arg1  self actionMap keysDo: [:arg2 |  self removeActionsSatisfying: arg1 forEvent: arg2 ]waitUntil: arg1 maxSeconds: arg2  ^self waitUntil: arg1 maxMilliseconds: (arg2 * 1000) asIntegertestPoolVariableAccessibleInClassUser  PoolDefiner initialize.  RootClassPoolUser compileAll.  self assert: RootClassPoolUser gloups equals: 42.  self assert: RootClassPoolUser author equals: 'Ducasse'header  ^self objectAt: 1isInstalled  self methodClass ifNotNil: [:arg1 |  self selector ifNotNil: [:arg2 |  ^self == (arg1 compiledMethodAt: arg2 ifAbsent: [  ]) ] ].  ^falseadaptToInteger: arg1 andSend: arg2  ^arg1 asFloat perform: arg2 with: selfrecursion  RecursionStopper during: [ self recursion ]rfEnsure: arg1  < primitive: 198>  < metaLinkOptions: #(+ optionDisabledLink)>  | tmp1 tmp2 |  tmp1 := self rfvalueNoContextSwitch.  tmp2 ifNil: [ tmp2 := true.        arg1 rfvalue ].  ^tmp1organization: arg1  arg1 ifNotNil: [ arg1 setSubject: self ].  self basicOrganization: arg1isInvalidPattern  ^year isNil or: [ month isNil or: [ day isNil or: [ invalidPattern ] ] ]testObjectAllSubclasses  | tmp1 |  tmp1 := Object allSubclasses size.  self assert: tmp1 equals: (Object allSubclasses select: [:arg1 |  (arg1 class isKindOf: Metaclass) or: [ arg1 isKindOf: Metaclass ] ]) sizeisBinarySelector  ^self selector allSatisfy: [:arg1 |  arg1 isSpecial ]testNotTheSame  | tmp1 tmp2 |  tmp1 := ProtoObject new.  tmp2 := ProtoObject new.  self assert: tmp1 ~~ tmp2.  self deny: tmp1 ~~ tmp1hasLiteral: arg1  2 to: self numLiterals - 1 do: [:arg2 |  | tmp1 |        ((tmp1 := self objectAt: arg2) literalEqual: arg1) ifTrue: [ ^true ].        (tmp1 isMemberOf: CompiledBlock) ifTrue: [ (tmp1 hasLiteral: arg1) ifTrue: [ ^true ] ] ].  ^falseisInterval  ^falsetree: arg1  | tmp1 |  tmp1 := Continuation currentDo: [:arg2 |  leave := arg2.        self waddle: arg1.        leave value: nil ].  ^tmp1 isSymbol ifTrue: [ self T: tmp1 ] ifFalse: [ false ]setUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  aDateAndTime := DateAndTime     localTimeZone: TimeZone default;     unixEpoch.  aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'Unix Epoch Test Time Zone' abbreviation: 'UTZ'.  aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5asWords  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  self = 0 ifTrue: [ ^'zero' ].  tmp1 := #('' ' thousand' ' million' ' billion' ' trillion' ' quadrillion' ' quintillion' ' sextillion' ' septillion' ' octillion' ' nonillion' ' decillion' ' undecillion' ' duodecillion' ' tredecillion' ' quattuordecillion' ' quindecillion' ' sexdecillion' ' septendecillion' ' octodecillion' ' novemdecillion' ' vigintillion').  tmp4 := self.  tmp2 := ''.  self < 0 ifTrue: [ tmp2 := 'negative '.        tmp4 := tmp4 negated ].  tmp5 := String new.  tmp6 := 1.  [ tmp4 > 0 ] whileTrue: [ tmp3 := (tmp4 \\ 1000) threeDigitName.        tmp4 := tmp4 // 1000.        tmp3 isEmpty ifFalse: [ tmp5 isEmpty ifFalse: [ tmp5 := ', ' , tmp5 ].              tmp5 := tmp3 , (tmp1 at: tmp6) , tmp5 ].        tmp6 := tmp6 + 1 ].  ^tmp2 , tmp5growby: arg1  ^self growto: self bytesCount + arg1fuelAccept: arg1  ^self >= -4294967295 ifTrue: [ arg1 mapAndTraceByClusterName: self to: FLNegative32SmallIntegerCluster ] ifFalse: [ arg1 visitBytesObject: self ]isPrivateOther  ^self characterSet isPrivateOther: selfselectors  ^self methodDict keystestSourceNodeOptimizedBlock  | tmp1 tmp2 |  tmp2 := Smalltalk compiler     class: Object;     compile: 'test 1 to: 1 do: [ :i | ^ thisContext sourceNode ]'.  tmp1 := tmp2 valueWithReceiver: nil arguments: #().  self assert: tmp1 isBlockmmddyyyy  ^self printFormat: #(2 1 3 $/ 1 1)epoch  ^self class epochtestAND  self assert: true & true.  self deny: true & falseisSpecialLiteralForPush: arg1  ^arg1 == false or: [ arg1 == true or: [ arg1 isNil or: [ arg1 isInteger and: [ arg1 between: -1 and: 2 ] ] ] ]removeProperty: arg1  | tmp1 |  tmp1 := self propertyAt: arg1 ifAbsent: [ ^nil ].  self penultimateLiteral: (self penultimateLiteral copyWithout: (Association key: arg1 value: tmp1)).  ^tmp1handles: arg1  ^exceptions anySatisfy: [:arg2 |  arg2 handles: arg1 ]waitWhile: arg1 for: arg2 maxSeconds: arg3  ^self waitWhile: arg1 for: arg2 maxMilliseconds: (arg3 * 1000) asIntegerprotocols  ^protocols asArrayhaltOnce  < debuggerCompleteToSender>  Halt oncetestWaitTimeDurationWithCompletionAndTimeoutBlocks  self assert: (Semaphore new wait: 50 milliSeconds onCompletion: [ #completed ] onTimeout: [ #timeout ]) identicalTo: #timeout.  self assert: (Semaphore new signal wait: 50 milliSeconds onCompletion: [ #completed ] onTimeout: [ #timeout ]) identicalTo: #completedlogExit  self traceCr: 'Exited ' , thisContext sender printStringfileOutOn: arg1  arg1 nextChunkPut: self definition.  self organization putCommentOnFile: arg1 forClass: self.  self organization categories do: [:arg2 |  self fileOutLocalMethodsInCategory: arg2 on: arg1 ]testAddMonths  self assert: (january23rd2004 addMonths: 0) equals: '2004-01-23' asDate.  self assert: (january23rd2004 addMonths: 1) equals: '2004-02-23' asDate.  self assert: (january23rd2004 addMonths: 12) equals: '2005-01-23' asDateasRingDefinition  ^self asActiveRingDefinitiontestTruncated  self assert: 1.0 truncated equals: 1.  self assert: 1.1 truncated equals: 1.  self assert: -2.0 truncated equals: -2.  self assert: -2.1 truncated equals: -2print: arg1 on: arg2 prefix: arg3 length: arg4 padded: arg5  | tmp1 |  tmp1 := arg4 - arg1 size - arg3 size.  tmp1 > 0 ifTrue: [ arg5 ifTrue: [ arg2                 nextPutAll: arg3;                 nextPutAll: (String new: tmp1 withAll: $0) ] ifFalse: [ arg2                 nextPutAll: (String new: tmp1 withAll: Character space);                 nextPutAll: arg3 ] ] ifFalse: [ arg2 nextPutAll: arg3 ].  arg2 nextPutAll: arg1tearDown  fork ifNotNil: [ fork terminate.        fork := nil ].  super tearDownretryWithGC: arg1 until: arg2  | tmp1 |  tmp1 := arg1 value.  (arg2 value: tmp1) ifTrue: [ ^tmp1 ].  Smalltalk garbageCollectMost.  tmp1 := arg1 value.  (arg2 value: tmp1) ifTrue: [ ^tmp1 ].  Smalltalk garbageCollect.  ^arg1 valuetestTo  self assert: (anIncludedTimespan to: jan08) equals: aTimespanprepareForSimulationWith: arg1  | tmp1 |  tmp1 := ((self header bitAnd: 2r01110000000000111111111111111111) bitOr: (arg1 bitShift: 24)) bitOr: (arg1 + 1 bitShift: 18).  tmp1 := tmp1 + (self class headerFlagForEncoder: self encoderClass).  self objectAt: 1 put: tmp1.  self encoderClass prepareMethod: self forSimulationWith: arg1testArgumentNamed  | tmp1 |  tmp1 := (self class >> #methodWithPragma) pragmas anyOne.  self assert: (tmp1 argumentNamed: #testPragmaArg1) equals: #toto.  self assert: (tmp1 argumentNamed: #arg2) equals: 2.  self assert: (tmp1 argumentNamed: #arg3).  self should: [ tmp1 argumentNamed: #nonExisting ] raise: ErrortestLog  self assert: (100 log closeTo: 2).  self assert: ((2 raisedTo: Float emax + 3) log closeTo: 2 log * (Float emax + 3)) description: 'Integer>>log should not overflow'testDaysLeftInYear  self assert: aDateAndTime daysLeftInYear equals: 365testNegated  self assert: aDuration + aDuration negated equals: (Duration seconds: 0)spotterForSendersFor: arg1  < spotterOrder: 10>  self method spotterForSendersFor: arg1validIndex: arg1  ^arg1 > 0 and: [ arg1 <= self size ]testToBy  self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) equals: ((DateAndTime year: 1980 month: 1 day: 1) to: (DateAndTime year: 1980 month: 1 day: 1) + 10 days by: 5 days)testallClassVariables  self assert: SmalltalkImage allClassVariables last name equals: #DependentsFieldsinstancesSizeInMemory  | tmp1 |  tmp1 := 0.  self allInstancesDo: [:arg1 |  tmp1 := tmp1 + arg1 sizeInMemory ].  ^tmp1subclass: arg1 slots: arg2 classVariables: arg3 poolDictionaries: arg4 package: arg5  ^self classInstaller make: [:arg6 |  arg6           name: arg1;           superclass: self;           slots: arg2;           sharedVariables: arg3;           sharedPools: arg4;           category: arg5 ]tearDown  self deleteClass.  {self unclassifiedCategory .   self categoryNameForTemporaryClasses} do: [:arg1 |  RPackage organizer unregisterPackageNamed: arg1 ].  super tearDownmustBeBooleanCompileExpression: arg1 andCache: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := arg1 pc - 1.  tmp1 := arg1 sourceNode sourceNodeForPC: tmp3.  RBParseTreeRewriter new     replace: '^ ``@value' with: 'ThisContext home return: ``@value';     executeTree: tmp1.  tmp2 := tmp1 copy asDoitForContext: arg1.  tmp2 compilationContext: tmp1 methodNode compilationContext copy.  tmp2 compilationContext compilerOptions: #(- optionInlineIf optionInlineAndOr optionInlineWhile).  OCASTSemanticCleaner clean: tmp2.  tmp4 := tmp2 generate.  tmp5 := tmp1 irInstruction nextBytecodeOffsetAfterJump.  tmp4 propertyAt: #mustBeBooleanJump put: tmp5.  arg2 at: tmp3 put: tmp4.  ^tmp4recompile: arg1  ^self recompile: arg1 from: selffractionPart  ^self - self integerParttestSourceNodeExecutedWhenContextIsJustAtStartpc  | tmp1 tmp2 |  tmp2 := Context sender: thisContext receiver: self method: self class >> testSelector arguments: #().  tmp1 := tmp2 sourceNodeExecuted.  self assert: tmp1 equals: (self class >> testSelector) ast sendNodes first receiverreturn: arg1 through: arg2  sender ifNil: [ self cannotReturn: arg1 to: sender ].  sender resume: arg1 through: arg2signBit  ^1print24: arg1 on: arg2  | tmp1 tmp2 tmp3 |  tmp1 := self hour.  tmp2 := self minute.  tmp3 := self second.  arg1 ifTrue: [ tmp1 < 10 ifTrue: [ arg2 nextPut: $0 ].        tmp1 printOn: arg2 ] ifFalse: [ tmp1 > 12 ifTrue: [ tmp1 - 12 printOn: arg2 ] ifFalse: [ tmp1 < 1 ifTrue: [ 12 printOn: arg2 ] ifFalse: [ tmp1 printOn: arg2 ] ] ].  arg2 nextPutAll: (tmp2 < 10 ifTrue: [ ':0' ] ifFalse: [ ':' ]).  tmp2 printOn: arg2.  arg2 nextPutAll: (tmp3 < 10 ifTrue: [ ':0' ] ifFalse: [ ':' ]).  tmp3 printOn: arg2.  arg1 ifFalse: [ arg2 nextPutAll: (tmp1 < 12 ifTrue: [ ' am' ] ifFalse: [ ' pm' ]) ]becomeForward: arg1  {self} elementsForwardIdentityTo: {arg1}ifTrue: arg1  ^nil= arg1  ^self class == arg1 class and: [ context = arg1 context and: [ context ifNil: [ explanationString = arg1 explanationString ] ifNotNil: [ true ] ] ]printOn: arg1 showingDecimalPlaces: arg2  | tmp1 tmp2 tmp3 |  arg2 <= 0 ifTrue: [ self rounded printOn: arg1 ] ifFalse: [ tmp3 := 10 raisedToInteger: arg2.        tmp2 := numerator abs quo: denominator.        tmp1 := (numerator abs - (tmp2 * denominator)) * tmp3 * 2 + denominator quo: denominator * 2.        tmp1 = tmp3 ifTrue: [ tmp2 := tmp2 + 1.              tmp1 := 0 ].        (numerator negative and: [ tmp2 > 0 or: [ tmp1 > 0 ] ]) ifTrue: [ arg1 nextPut: $- ].        tmp2 printOn: arg1.        arg1 nextPut: $..        tmp1 printOn: arg1 base: 10 length: arg2 padded: true ]calleeOf: arg1  suspendedContext == arg1 ifTrue: [ ^nil ].  ^(suspendedContext findContextSuchThat: [:arg2 |  arg2 sender == arg1 ]) ifNil: [ self error: 'aContext not in process chain' ]isClosure  ^falseveryDeepCopyWith: arg1  ^selfisRingFullyResolved  ^truetraitConflict  self error: 'A class or trait does not properly resolve a conflict between multiple traits it uses.'sameLiteralsAs: arg1  | tmp1 tmp2 tmp3 |  (tmp1 := self numLiterals) ~= arg1 numLiterals ifTrue: [ ^false ].  1 to: tmp1 - 1 do: [:arg2 |  tmp2 := self literalAt: arg2.        tmp3 := arg1 literalAt: arg2.        (tmp2 == tmp3 or: [ tmp2 literalEqual: tmp3 ]) ifFalse: [ ^false ] ].  ^truepopTo: arg1 value: arg2  self == Processor activeProcess ifTrue: [ ^self error: 'The active process cannot pop contexts' ].  ^(self calleeOf: arg1) ifNil: [ arg1 ] ifNotNil: [:arg3 |  Processor activeProcess evaluate: [ self return: arg3 value: arg2 ] onBehalfOf: self ]linksDo: arg1  | tmp1 |  tmp1 := firstLink.  [ tmp1 == nil ] whileFalse: [ arg1 value: tmp1.        tmp1 := tmp1 nextLink ]<= arg1  < primitive: 5>  ^super <= arg1decodeLengthField  | tmp1 tmp2 tmp3 |  tmp2 := method size.  tmp1 := ((method at: tmp2) bitAnd: 3) + 1.  tmp3 := 0.  1 to: tmp1 do: [:arg1 |  tmp3 := (tmp3 << 8) + (method at: tmp2 - arg1) ].  size := 1 + tmp1 + tmp3.  ^tmp3assertSqrtCorrectlyRoundedForExponent: arg1  {1.5 .   1.25 squared .   2.0 predecessor} do: [:arg2 |  | tmp1 tmp2 tmp3 tmp4 |        tmp1 := arg2 timesTwoPower: arg1.        tmp2 := tmp1 asInteger + (tmp1 ulp asInteger / 2).        tmp4 := tmp2 squared - 1.        tmp3 := tmp2 squared + 1.        self assert: tmp2 squared sqrt equals: tmp2.        self assert: tmp2 squared sqrt isInteger.        self assert: tmp4 sqrt equals: tmp1.        self assert: tmp4 sqrt isFloat.        self assert: tmp3 sqrt equals: tmp1 successor.        self assert: tmp3 sqrt isFloat.        tmp2 := tmp1 asInteger - (tmp1 ulp asInteger / 2).        tmp4 := tmp2 squared - 1.        tmp3 := tmp2 squared + 1.        self assert: tmp2 squared sqrt equals: tmp2.        self assert: tmp2 squared sqrt isInteger.        self assert: tmp4 sqrt equals: tmp1 predecessor.        self assert: tmp4 sqrt isFloat.        self assert: tmp3 sqrt equals: tmp1.        self assert: tmp3 sqrt isFloat ]packToArity: arg1  | tmp1 |  tmp1 := self.  1 to: arg1 do: [:arg2 |  tmp1 := tmp1 pointer ].  ^tmp1genPushNewArray: arg1  (arg1 < 0 or: [ arg1 > 127 ]) ifTrue: [ ^self outOfRangeError: 'numElements' index: arg1 range: 0 to: 127 ].  stream     nextPut: 138;     nextPut: arg1isRequired: arg1  arg1 ifNil: [ ^false ].  (self isExplicitlyRequired: arg1) ifTrue: [ ^true ].  (self isSubclassResponsibility: arg1) ifTrue: [ ^true ].  ^falsetestAllReferencesTo  | tmp1 |  tmp1 := SystemNavigation new allReferencesTo: Point binding.  tmp1 do: [:arg1 |  self assert: (arg1 compiledMethod hasLiteral: Point binding) ].  self assert: (tmp1 anySatisfy: [:arg1 |  arg1 actualClass = self class and: [ arg1 selector = #testAllReferencesTo ] ]).  tmp1 := SystemNavigation new allReferencesTo: #printOn:.  tmp1 do: [:arg1 |  self assert: (arg1 compiledMethod hasLiteralThorough: #printOn:) ].  self assert: (tmp1 anySatisfy: [:arg1 |  arg1 actualClass = self class and: [ arg1 selector = #testAllReferencesTo ] ]).  tmp1 := SystemNavigation new allReferencesTo: #+.  tmp1 do: [:arg1 |  self assert: ((arg1 compiledMethod sendsSelector: #+) or: [ arg1 compiledMethod hasLiteralThorough: #+ ]) ].  self assert: (tmp1 anySatisfy: [:arg1 |  arg1 actualClass = self class and: [ arg1 selector = #testAllReferencesTo ] ])hasClassSide  ^self classSide notNiltestAsLargerPowerOfTwo  self assert: (1 / 2) asLargerPowerOfTwo equals: 1 / 2.  self assert: (Fraction numerator: 2 denominator: 4) asLargerPowerOfTwo equals: 1 / 2.  self assert: (2 / 5) asLargerPowerOfTwo equals: 1 / 2.  self assert: (Fraction numerator: 10 denominator: 25) asLargerPowerOfTwo equals: 1 / 2.  self assert: (Fraction numerator: 2 denominator: 1) asLargerPowerOfTwo equals: 2.  self assert: (Fraction numerator: 4 denominator: 2) asLargerPowerOfTwo equals: 2.  self assert: (3 / 2) asLargerPowerOfTwo equals: 2.  self assert: (Fraction numerator: 12 denominator: 8) asLargerPowerOfTwo equals: 2.  self assert: (1 / (2 raisedTo: 80)) asLargerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160)) asLargerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (1 / ((2 raisedTo: 80) + 1)) asLargerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160) + 1) asLargerPowerOfTwo equals: 1 / (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) denominator: 1) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 160) denominator: (2 raisedTo: 80)) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 80) - 1 denominator: 1) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self assert: (Fraction numerator: (2 raisedTo: 160) - 1 denominator: (2 raisedTo: 80)) asLargerPowerOfTwo equals: (2 raisedTo: 80).  self should: [ (Fraction numerator: 0 denominator: 1) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 negated denominator: 2) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 denominator: 2 negated) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 2 negated denominator: 4) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 2 denominator: 4 negated) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 negated denominator: (2 raisedTo: 80)) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: 1 denominator: (2 raisedTo: 80) negated) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: (2 raisedTo: 80) negated denominator: (2 raisedTo: 160)) asLargerPowerOfTwo ] raise: DomainError.  self should: [ (Fraction numerator: (2 raisedTo: 80) denominator: (2 raisedTo: 160) negated) asLargerPowerOfTwo ] raise: DomainErrortestLiterals  self assertEmpty: (Object >> #yourself) literals.  self assert: (Object >> #yourself) allLiterals size equals: 2.  self deny: (Object >> #yourself hasLiteral: #yourself)tearDown  scheduler debug: false.  super tearDownextensionSelectors  ^self extendingPackages flatCollect: [:arg1 |  arg1 extensionSelectorsForClass: self ]literalEqual: arg1  ^(super literalEqual: arg1) and: [ self isZero not or: [ self signBit = arg1 signBit ] ]waitMaxSeconds: arg1  ^self waitMaxMilliseconds: (arg1 * 1000) asIntegerrehash  | tmp1 |  tmp1 := self species newForCapacity: self basicSize.  1 to: self basicSize do: [:arg1 |  (self basicAt: arg1) ifNotNil: [:arg2 |  tmp1 at: arg2 put: (array at: arg1) ] ].  self copyFrom: tmp1isResumable  ^truegenPushTemp: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63 ].  arg1 < 16 ifTrue: [ stream nextPut: 16 + arg1.        ^self ].  arg1 < 64 ifTrue: [ stream           nextPut: 128;           nextPut: 64 + arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63testSubclassInstVar  | tmp1 |  SystemNavigation new allClassesDo: [:arg1 |  tmp1 := arg1 subclasses.        self assert: tmp1 isNil not.        tmp1 do: [:arg2 |  self assert: (tmp1 occurrencesOf: arg2) equals: 1.              self assert: arg2 superclass identicalTo: arg1 ] ]asMonth  ^Month starting: selfgtInspectorIntegerIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 table     title: 'Integer';     display: [ | tmp1 |        tmp1 := {('decimal' -> self printString) .         ('hex' -> self printStringHex) .         ('octal' -> (self printStringBase: 8)) .         ('binary' -> (self printStringBase: 2))} asOrderedCollection.        (self between: 0 and: 16r10FFFF) ifTrue: [ tmp1 add: 'character' -> self asCharacter ].        tmp1 ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: [:arg2 |  arg2 value printString ];     send: #valuetestDuration  self assert: january23rd2004 duration equals: 24 hoursclassForScheduler  ^DelaySemaphoreSchedulerright  ^righttestAnd  self assert: (true and: [ 'alternativeBlock' ]) equals: 'alternativeBlock'isUsed  ^self isReferencedtestHandlingWhenThereIsSomeExclusionButDontApplies  | tmp1 tmp2 |  tmp1 := false.  tmp2 := [ ZeroDivide signalWithDividend: 1.  2 ] on: Error - MessageNotUnderstood do: [:arg1 |  tmp1 := true.        arg1 return ].  self     assert: tmp1;     assert: tmp2 isNilsharedPoolOfVarNamed: arg1  ^nildoubleOuterPassTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselfdividend  ^dividendtestAllMethodCategoriesIntegratedThrough  self assert: ((CompiledMethod selectorsInProtocol: 'testing') includes: #isAbstract).  CompiledMethod allProtocolsUpTo: Object.  self assert: ((CompiledMethod selectorsInProtocol: 'testing') includes: #isAbstract)asCharacter  < primitive: 170>  ^self primitiveFailedhasSelectorReferringTo: arg1  ^self methods anySatisfy: [:arg2 |  arg2 hasLiteral: arg1 ]populateCBMenu: arg1  super populateCBMenu: arg1.  arg1 add: 'References to...' target: SystemNavigation new selector: #browseAllCallsOnClass: argument: selfrounded  ^self species basicNew ticks: {julianDayNumber .         (nanos * 2 >= NanosInSecond ifTrue: [ seconds + 1 ] ifFalse: [ seconds ]) .         0} offset: offsettestLocalVariable  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Semaphore new.  tmp2 := Semaphore new.  tmp3 := tmp4 := false.  [ self checkLocal: 0.  TestLocalVariable value: 1.  self checkLocal: 1.  (Delay forMilliseconds: 30) wait.  self checkLocal: 1.  TestLocalVariable value: 2.  self checkLocal: 2.  tmp3 := true.  tmp1 signal ] fork.  [ (Delay forMilliseconds: 30) wait.  self checkLocal: 0.  TestLocalVariable value: 3.  self checkLocal: 3.  (Delay forMilliseconds: 30) wait.  self checkLocal: 3.  TestLocalVariable value: 4.  self checkLocal: 4.  tmp4 := true.  tmp2 signal ] fork.  tmp1 waitTimeoutMSecs: 5000.  tmp2 waitTimeoutMSecs: 5000.  self assert: tmp3.  self assert: tmp4severity  ^#errortestReset  | tmp1 |  tmp1 := Stopwatch new.  tmp1 activate.  tmp1 reset.  self     assert: tmp1 isSuspended;     assertEmpty: tmp1 timespansfallbackMenuOn: arg1  testReadFromBogus  self should: [ Duration readFrom: '+0:01:02' readStream ] raise: ErrorisDisabled: arg1  ^arg1 == self class disabledMarkerwhichSelectorsAccess: arg1  ^self slotNamed: arg1 ifFound: [:arg2 |  self selectors select: [:arg3 |  arg2 isAccessedIn: self >> arg3 ] ] ifNone: [ #() ]>> arg1  arg1 < 0 ifTrue: [ self error: 'negative arg' ].  ^self bitShift: 0 - arg1key  ^self selectortestUnionWithSeparate  self assert: (anOverlappingTimespan union: aDisjointTimespan) equals: (Timespan starting: anOverlappingTimespan start ending: aDisjointTimespan end + DateAndTime clockPrecision)hasSourceCode  | tmp1 tmp2 |  tmp1 := self trailer.  tmp1 sourceCode ifNotNil: [:arg1 |  ^true ].  tmp1 hasSourcePointer ifFalse: [ ^false ].  tmp2 := [ self getSourceFromFile ] on: Error do: [:arg2 |  arg2 return: nil ].  tmp2 isEmptyOrNil ifTrue: [ ^false ].  ^truetestAddClassSlot  | tmp1 tmp2 tmp3 |  tmp1 := testEnvironment at: #TUTU.  tmp2 := #X => InstanceVariableSlot.  tmp3 := #Y => InstanceVariableSlot.  tmp1 addClassSlot: tmp2.  self assert: tmp1 class instVarNames equals: #(#X).  tmp1 addClassSlot: tmp3.  self assert: tmp1 class instVarNames equals: #(#X #Y)classThatDefinesInstanceVariable: arg1  self deprecated: 'use #classThatDefinesInstVarNamed:' transformWith: '`@receiver classThatDefinesInstanceVariable: `@statement' -> '`@receiver classThatDefinesInstVarNamed: `@statement'.  ^self classThatDefinesInstVarNamed: arg1testTicks  self assert: aDateAndTime ticks equals: (DateAndTime julianDayNumber: 2415386) ticks.  self assert: aDateAndTime ticks equals: #(2415386 0 0)shiftLevelDown  < metaLinkOptions: #(+ optionDisabledLink)>  level ifNil: [ level := 0 ].  (level rfIsEqual: 0) ifTrue: [ ^level ].  (level rfIsEqual: 1) ifTrue: [ ^level := 0 ].  level := level rfMinus: 1wantsSteps  ^falsegreaseInteger  ^selforganization  self basicOrganization ifNil: [ self basicOrganization: (self isTrait ifTrue: [ ClassOrganization new ] ifFalse: [ ClassOrganization forClass: self ]) ].  ^self basicOrganization setSubject: selftearDown  forkedProcesses do: #terminate.  super tearDownactions  ^super actions copyWith: (RePropertyAction new           icon: (self iconNamed: #smallWindow);           description: 'Open dependency analyzer';           action: [:arg1 :arg2 |  self openDependencyAnalyzerOn: arg2 ];           yourself)print: arg1 on: arg2  | tmp1 |  (arg1 class canUnderstand: #printOn:) ifTrue: [ ^arg1 printOn: arg2 ].  tmp1 := arg1 class name.  arg2     nextPutAll: (tmp1 first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);     nextPutAll: tmp1testCloseTo  self deny: (Float nan closeTo: Float nan) description: 'NaN isn''t close to anything'.  self deny: (Float nan closeTo: 1.0) description: 'NaN isn''t close to anything'.  self deny: (1.0 closeTo: Float nan) description: 'NaN isn''t close to anything'.  self deny: (-1.0 closeTo: 1.0).  self deny: (1.0 closeTo: Float infinity).  self assert: (Float infinity closeTo: Float infinity) description: 'since they are =, they also are closeTo:'.  self assert: (1.0 / 3.0 closeTo: 1 / 3).  self assert: (1.0e-8 closeTo: 0).  self assert: (0 closeTo: 1.0e-8).  self assert: (1 + 1.0e-8 closeTo: 1.0).  self assert: (1000000001.0 closeTo: 1000000000.0).  self deny: (1000000001 closeTo: 1000000000) description: 'exact representation are considered closeTo: only if equal'testRuleDoesNotFailIfAppliedOnNonBootstrapPackage  | tmp1 tmp2 |  tmp1 := PharoBootstrapRule new.  tmp1 class classVarNamed: 'DependencyChecker' put: PharoBootstrapAnalyzerStubWithNoNewDependency.  tmp2 := tmp1 check: (RPackage named: #P1).  self assertEmpty: tmp2addLast: arg1  | tmp1 |  tmp1 := arg1 asLink.  self isEmpty ifTrue: [ firstLink := tmp1 ] ifFalse: [ lastLink nextLink: tmp1 ].  lastLink := tmp1.  ^tmp1removeLink: arg1 ifAbsent: arg2  | tmp1 |  arg1 == firstLink ifTrue: [ firstLink := arg1 nextLink.        arg1 == lastLink ifTrue: [ lastLink := nil ] ] ifFalse: [ tmp1 := firstLink.        [ tmp1 == nil ifTrue: [ ^arg2 value ].        tmp1 nextLink == arg1 ] whileFalse: [ tmp1 := tmp1 nextLink ].        tmp1 nextLink: arg1 nextLink.        arg1 == lastLink ifTrue: [ lastLink := tmp1 ] ].  ^arg1largeIdentityHash  | tmp1 tmp2 |  self >= 0 ifTrue: [ tmp1 := self.        tmp2 := 0 ] ifFalse: [ tmp1 := 0 - self.        tmp2 := 4095 ].  [ tmp2 := tmp2 bitXor: (tmp1 bitAnd: 4095).  (tmp1 := tmp1 bitShift: -12) = 0 ] whileFalse.  ^FLLargeIdentityHashedCollection permuteHash: tmp2 + 1testOr  self assert: (false or: [ 'alternativeBlock' ]) equals: 'alternativeBlock'gtInspectorFloatIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 table     title: 'Float';     display: [ (self respondsTo: #binaryLiteralString) ifTrue: [ {('binary' -> self binaryLiteralString) .               ('significand' -> self significand) .               ('exponent' -> self exponent)} ] ifFalse: [ {('significand' -> self significand) .               ('exponent' -> self exponent)} ] ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valuemilliSeconds  ^Duration milliSeconds: selftestCompile  | tmp1 |  tmp1 := Behavior new.  tmp1 compile: 'thisIsATest ^2'.  tmp1 new thisIsATestswapSender: arg1  | tmp1 |  tmp1 := sender.  sender := arg1.  ^tmp1< arg1  < primitive: 43>  ^arg1 adaptToFloat: self andCompare: #<valueOrNil  ^Processor activeProcess psValueAt: indexwriteStream  ^WriteStream on: selfclassSide  ^self classffiBindingOf: arg1  ^self bindingOf: arg1parse: arg1  ^Integer readFrom: inputStream ifFail: [ DateError signal: 'Expecting a ' , arg1 ]testPrintString  | tmp1 |  tmp1 := 13 / 11 asScaledDecimal: 6.  self assert: '1.181818s6' equals: tmp1 printString.  tmp1 := 13 / 11 asScaledDecimal: 5.  self assert: '1.18182s5' equals: tmp1 printString.  tmp1 := 13 / 11 asScaledDecimal: 5.  self deny: '1.18181s5' equals: tmp1 printStringobject: arg1 basicAt: arg2 put: arg3  < primitive: 61>  arg2 isInteger ifTrue: [ (arg2 >= 1 and: [ arg2 <= (self objectSize: arg1) ]) ifFalse: [ self errorSubscriptBounds: arg2 ] ].  arg2 isNumber ifTrue: [ ^self object: arg1 basicAt: arg2 asInteger put: arg3 ] ifFalse: [ self errorNonIntegerIndex ].  arg1 isReadOnlyObject ifTrue: [ ^(ModificationForbidden new           object: arg1;           fieldIndex: arg2;           newValue: arg3;           retrySelector: #basicAt:put:) signal ].  self errorImproperStoretestNew  self should: [ Boolean new ] raise: self defaultTestErrortestBitAt  | tmp1 tmp2 |  self assert: (2r10 bitAt: 1) equals: 0.  self assert: (2r10 bitAt: 2) equals: 1.  self assert: ((1 to: 100) allSatisfy: [:arg1 |  (0 bitAt: arg1) = 0 ]) description: 'all bits of zero are set to zero'.  self assert: ((1 to: 100) allSatisfy: [:arg1 |  (-1 bitAt: arg1) = 1 ]) description: 'In two complements, all bits of -1 are set to 1'.  tmp1 := #('2r10010011' '2r11100100' '2r10000000' '2r0000101011011001' '2r1000101011011001' '2r0101010101011000' '2r0010011110110010' '2r0010011000000000' '2r00100111101100101000101011011001' '2r01110010011110110010100110101101' '2r10101011101011001010000010110110' '2r10101000000000000000000000000000' '2r0010101110101001110010100000101101100010011110110010100010101100' '2r1010101110101100101000001011011000100111101100101000101011011001' '2r1010101110101000000000000000000000000000000000000000000000000000').  tmp1 do: [:arg2 |  | tmp3 |        tmp3 := Number readFrom: arg2.        tmp2 := (arg2 size - 2 to: 1 by: -1) inject: '2r' into: [:arg3 :arg1 |  arg3 copyWith: (Character digitValue: (tmp3 bitAt: arg1)) ].        self assert: tmp2 equals: arg2 ].  tmp1 do: [:arg2 |  | tmp4 |        tmp4 := -1 - (Number readFrom: arg2).        tmp2 := (arg2 size - 2 to: 1 by: -1) inject: '2r' into: [:arg3 :arg1 |  arg3 copyWith: (Character digitValue: 1 - (tmp4 bitAt: arg1)) ].        self assert: tmp2 = arg2 description: '-1-x is similar to a bitInvert operation in two complement' ]sizePushNewArray: arg1  ^self sizeOpcodeSelector: #genPushNewArray: withArguments: {arg1}<= arg1  ^(self > arg1) notremoveMethodTag: arg1  self organization removeCategory: arg1genStorePopRemoteTemp: arg1 inVectorAt: arg2  (arg1 < 0 or: [ arg1 >= 256 ]) ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: arg1 range: 0 to: 255 ].  (arg2 < 0 or: [ arg2 >= 128 ]) ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: arg2 range: 0 to: 127 ].  stream     nextPut: 253;     nextPut: arg1;     nextPut: arg2copyWithout: arg1  | tmp1 |  tmp1 := self class new.  self do: [:arg2 |  arg2 = arg1 ifFalse: [ tmp1 add: arg2 ] ].  ^tmp1testAsTimeUTC  | tmp1 |  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 0 asDuration.  self assert: tmp1 asTimeUTC equals: (Time hour: 1 minute: 2 second: 3).  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: -5 hours.  self assert: tmp1 asTimeUTC equals: (Time hour: 6 minute: 2 second: 3).  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 5 hours.  self assert: tmp1 asTimeUTC equals: (Time hour: 24 + 1 - 5 minute: 2 second: 3)findContextMatchingPredicate: arg1  ^self findContextSuchThat: [:arg2 |  arg1 matches: arg2 ]testSimpleAccessors  | tmp1 |  tmp1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self     assert: tmp1 hours equals: tmp1 hours;     assert: tmp1 minutes equals: tmp1 minute;     assert: tmp1 seconds equals: tmp1 seconderrorNonIntegerIndex  self error: 'only integers should be used as indices'restoreLocalTimeZoneAfter: arg1  | tmp1 |  tmp1 := DateAndTime localTimeZone.  arg1 ensure: [ DateAndTime localTimeZone: tmp1 ]testYear  self assert: aDateAndTime year equals: 1901testActivateReturnValue  self assert: ((aSender activateReturn: aMethodContext value: #()) isKindOf: Context).  self assert: (aSender activateReturn: aMethodContext value: #()) receiver equals: aMethodContextcrossSumBase: arg1  | tmp1 |  [ arg1 isInteger and: [ arg1 >= 2 ] ] assert.  self < 0 ifTrue: [ ^self negated crossSumBase: arg1 ].  self < arg1 ifTrue: [ ^self ].  tmp1 := self \\ arg1 + (self // arg1 crossSumBase: arg1).  [ tmp1 \\ (arg1 - 1) = 0 = (self \\ (arg1 - 1) = 0) ] assert.  ^tmp1testIsOtherPunctuation  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isOtherPunctuation: tmp2) equals: (tmp1 isOtherPunctuation: tmp2) ]populateCBMenu: arg1  arg1 add: 'Browse' target: self selector: #browsemethod  ^methodincludes: arg1  1 to: self basicSize do: [:arg2 |  (self basicAt: arg2) = arg1 ifTrue: [ ^true ] ].  ^falsesizeStorePopRemoteTemp: arg1 inVectorAt: arg2  ^self sizeOpcodeSelector: #genStorePopRemoteTemp:inVectorAt: withArguments: {arg1 .         arg2}notYetImplemented  NotYetImplemented signalFor: thisContext sender selectorasSmallerPowerOfTwo  ^self isPowerOfTwo ifTrue: [ self ] ifFalse: [ self > 0 ifTrue: [ 1 bitShift: self highBit - 1 ] ifFalse: [ DomainError signal: 'Value outside (0 , infinity)' from: 0 ] ]criticTheNonMetaclassClass  ^self instanceSide+ arg1  ^self class nanoSeconds: self asNanoSeconds + arg1 asNanoSecondsprintOn: arg1  super printOn: arg1.  arg1 nextPutAll: ' in '.  suspendedContext printOn: arg1testPrintPaddedWith  self assert: (123 printPaddedWith: $0 to: 10 base: 2) equals: '0001111011'.  self assert: (123 printPaddedWith: $0 to: 10 base: 8) equals: '0000000173'.  self assert: (123 printPaddedWith: $0 to: 10 base: 10) equals: '0000000123'.  self assert: (123 printPaddedWith: $0 to: 10 base: 16) equals: '000000007B'suspendFirstAt: arg1  ^self suspendFirstAt: arg1 ifNone: [ self error: 'No Process to suspend' ]flushCache  < primitive: 89>  self primitiveFailedresumptionTickAdjustFrom: arg1 to: arg2  resumptionTick := resumptionTick - arg1 + arg2defaultResumeValue  ^niltestConverting  self assert: time asSeconds equals: 14567raisedToInteger: arg1  | tmp1 tmp2 |  arg1 negative ifTrue: [ ^(self raisedToInteger: arg1 negated) reciprocal ].  tmp1 := 1 bitShift: arg1 highBit - 1.  tmp2 := self class one.  [ (arg1 bitAnd: tmp1) = 0 ifFalse: [ tmp2 := tmp2 * self ].  tmp1 := tmp1 bitShift: -1.  tmp1 > 0 ] whileTrue: [ tmp2 := tmp2 * tmp2 ].  ^tmp2+ arg1  arg1 class = self class ifTrue: [ ^self asFraction + arg1 asFraction asScaledDecimal: (scale max: arg1 scale) ].  ^self coerce: self asFraction + arg1ffiLibrary  ^self ffiLibraryName asFFILibrarybitAnd: arg1  < primitive: 'primDigitBitAnd' module: 'LargeIntegers'>  | tmp1 |  tmp1 := arg1 normalize.  ^self digitLogic: tmp1 op: #bitAnd: length: (self bytesCount max: tmp1 bytesCount)classSideCompilerClass  ^Smalltalk compilerClasstestPrintShowingDecimalPlaces2  self assert: (5000000000000001.0 printShowingDecimalPlaces: 0) equals: '5000000000000001'.  self assert: (50000000000001.25 printShowingDecimalPlaces: 2) equals: '50000000000001.25'.  1.0e306 printShowingDecimalPlaces: 3nthRoot: arg1  | tmp1 |  tmp1 := self asFraction nthRoot: arg1.  ^tmp1 isFloat ifTrue: [ tmp1 ] ifFalse: [ tmp1 asScaledDecimal: scale ]doubleOuterPassTest  [ [ [ self doSomething.  MyTestNotification signal.  self doSomethingExceptional ] on: MyTestNotification do: [:arg1 |  arg1 outer.        self doSomethingElse ] ] on: MyTestNotification do: [:arg1 |  arg1 pass.        self doSomethingExceptional ] ] on: MyTestNotification do: [:arg1 |  self doYetAnotherThing.        arg1 resume ]testPreviousNext  | tmp1 tmp2 |  tmp1 := month next.  tmp2 := month previous.  self     assert: tmp1 year equals: 1998;     assert: tmp1 index equals: 8;     assert: tmp2 year equals: 1998;     assert: tmp2 index equals: 6value: arg1 during: arg2  | tmp1 tmp2 |  tmp1 := Processor activeProcess.  tmp2 := tmp1 psValueAt: index.  ^[ tmp1 psValueAt: index put: arg1.  arg2 value ] ensure: [ tmp1 psValueAt: index put: tmp2 ]first  self do: [:arg1 |  ^arg1 ].  self error: 'this collection is empty'numberOfMethods  | tmp1 |  tmp1 := self localMethods size.  ^self isMeta ifTrue: [ tmp1 ] ifFalse: [ tmp1 + self classSide numberOfMethods ]addCategory: arg1  ^self addCategory: arg1 before: niltestTallyInstructions  | tmp1 |  tmp1 := aBlockContext method encoderClass = EncoderForSistaV1 ifTrue: [ 26 ] ifFalse: [ 27 ].  self assert: (Context tallyInstructions: aBlockContext) size equals: tmp1serializeOn: arg1  useNonUtcTimeZoneDuring: arg1  self useTimeZone: 'EDT' during: arg1tinyBenchmarks  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := 1.  [ tmp1 := Time millisecondsToRun: [ tmp4 benchmark ].  tmp1 < 1000 ] whileTrue: [ tmp4 := tmp4 * 2 ].  tmp5 := 28.  [ tmp2 := Time millisecondsToRun: [ tmp3 := tmp5 benchFib ].  tmp2 < 1000 ] whileTrue: [ tmp5 := tmp5 + 1 ].  ^(tmp4 * 500000 * 1000 // tmp1) printString , ' bytecodes/sec; ' , (tmp3 * 1000 // tmp2) printString , ' sends/sec'top  ^self at: stackpdecodeUndefined  self error: 'undefined method encoding'pass  handlerContext nextHandlerContext handleSignal: selfvariableWriteNodes  ^self ast variableWriteNodestestHumanReadablePrintString  self assert: 0 seconds humanReadablePrintString equals: '0 seconds'.  self assert: 1 second humanReadablePrintString equals: '1 second'.  self assert: 1 second negated humanReadablePrintString equals: '- 1 second'.  self assert: 1002003004 nanoSeconds humanReadablePrintString equals: '1 second 2 milliseconds 3 microseconds 4 nanoseconds'.  self assert: (Duration days: 1 hours: 1 minutes: 1 seconds: 1) humanReadablePrintString equals: '1 day 1 hour 1 minute 1 second'.  self assert: (Duration days: 2 hours: 4 minutes: 8 seconds: 16) humanReadablePrintString equals: '2 days 4 hours 8 minutes 16 seconds'.  self shouldnt: [ 17.6782 years humanReadablePrintString ] raise: MessageNotUnderstoodenvironment  ^self class environmentisCompact  ^falseinstVarName: arg1  instVarName := arg1testSetIsReadOnlySuccess  self maybeReadOnlyObjects do: [:arg1 |  self testObject: arg1 initialState: false tuples: #(#(true false true) #(false true false)) ]variableWordSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5  ^self variableWordSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5parseSameChar  inputStream next = char ifFalse: [ invalidPattern := true ]object: arg1 basicAt: arg2  < primitive: 60>  arg2 isInteger ifTrue: [ self errorSubscriptBounds: arg2 ].  arg2 isNumber ifTrue: [ ^self object: arg1 basicAt: arg2 asInteger ] ifFalse: [ self errorNonIntegerIndex ]testFromSeconds  | tmp1 |  tmp1 := self dateClass fromSeconds: june2nd1973 asSeconds.  self assert: tmp1 equals: june2nd1973deprecatedMethod  self deprecated: 'I am deprecated for tests'ifFalse: arg1  self subclassResponsibilitygpsExample2: arg1  | tmp1 tmp2 tmp3 |  tmp1 := [:arg2 :arg3 :arg4 |  | tmp4 |  tmp4 := 0.  arg3 first value: 1.  [ arg3 last value <= arg4 last value ] whileTrue: [ tmp4 := tmp4 + arg2 last value.        arg3 first value: arg3 last value + 1 ].  tmp4 ].  ^tmp1 value: (Array with: [:arg5 |  self error: 'can not assign to procedure' ] with: [ tmp1 value: (Array with: [:arg5 |  (arg1 at: tmp2) at: tmp3 put: arg5 ] with: [ (arg1 at: tmp2) at: tmp3 ]) value: (Array with: [:arg5 |  tmp3 := arg5 ] with: [ tmp3 ]) value: (Array with: [:arg5 |  self error: 'can not assign to constant' ] with: [ arg1 size ]) ]) value: (Array with: [:arg5 |  tmp2 := arg5 ] with: [ tmp2 ]) value: (Array with: [:arg5 |  self error: 'can not assign to constant' ] with: [ arg1 size ])testValueWithPossibleArgs  | tmp1 tmp2 tmp3 |  tmp1 := [ 1 ].  tmp2 := [:arg1 |  arg1 ].  tmp3 := [:arg2 :arg3 |  {arg2 .   arg3} ].  self assert: (tmp1 valueWithPossibleArgs: #()) equals: 1.  self assert: (tmp1 valueWithPossibleArgs: #(1)) equals: 1.  self assert: (tmp2 valueWithPossibleArgs: #()) isNil.  self assert: (tmp2 valueWithPossibleArgs: #(1)) equals: 1.  self assert: (tmp2 valueWithPossibleArgs: #(1 2)) equals: 1.  self assert: (tmp3 valueWithPossibleArgs: #()) equals: {nil .         nil}.  self assert: (tmp3 valueWithPossibleArgs: #(1)) equals: {1 .         nil}.  self assert: (tmp3 valueWithPossibleArgs: #(1 2)) equals: #(1 2).  self assert: (tmp3 valueWithPossibleArgs: #(1 2 3)) equals: #(1 2)basicPharoToIso  | tmp1 |  self asInteger < 128 ifTrue: [ ^self ].  self asInteger > 255 ifTrue: [ ^self ].  tmp1 := #(196 197 199 201 209 214 220 225 224 226 228 227 229 231 233 232 234 235 237 236 238 239 241 243 242 244 246 245 250 249 251 252 134 176 162 163 167 149 182 223 174 169 153 180 168 128 198 216 129 177 138 141 165 181 142 143 144 154 157 170 186 158 230 248 191 161 172 166 131 173 178 171 187 133 160 192 195 213 140 156 150 151 147 148 145 146 247 179 253 159 185 164 139 155 188 189 135 183 130 132 137 194 202 193 203 200 205 206 207 204 211 212 190 210 218 219 217 208 136 152 175 215 221 222 184 240 254 255 256) at: self asciiValue - 127.  ^Character value: tmp1simpleReturnTest  | tmp1 |  tmp1 := [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:arg1 |  arg1 return: 3 ].  tmp1 = 3 ifTrue: [ self doYetAnotherThing ]simpleEnsureTestWithError  [ self doSomething.  MyTestError signal.  self doSomethingElse ] ensure: [ self doYetAnotherThing ]invalidate  | tmp1 |  self reflectivityDisabled ifTrue: [ ^self ].  tmp1 := self reflectiveMethod.  tmp1 ifNil: [ ^self ].  (self isRealPrimitive or: (tmp1 ast metaLinkOptionsFromClassAndMethod includes: #optionCompileOnLinkInstallation)) ifTrue: [ tmp1 compileAndInstallCompiledMethod ] ifFalse: [ tmp1 installReflectiveMethod ]waitUntil: arg1 for: arg2 maxMilliseconds: arg3  ^self waitWhile: [ arg1 value not ] for: arg2 maxMilliseconds: arg3testNew  self should: [ Number new ] raise: self defaultTestErrorprintStringLength: arg1  ^self printStringLength: arg1 padded: falsetestStoreOn  self assert: (String streamContents: [:arg1 |  aTime storeOn: arg1 ]) equals: '''12:34:56 pm'' asTime'integerPart  ^self - self fractionPartsetSignFlag  self signFlag ifFalse: [ self objectAt: 1 put: self header + SmallInteger minVal ]completeStep: arg1  | tmp1 |  self suspendedContext == arg1 ifFalse: [ ^self complete: (self calleeOf: arg1) ].  tmp1 := self step.  tmp1 == arg1 ifTrue: [ ^tmp1 ].  arg1 isDead ifTrue: [ ^self suspendedContext ].  ^self complete: tmp1testSimpleReturn  self assertSuccess: (ExceptionTester new runTest: #simpleReturnTest)allTraits  ^#()lookupClass  ^lookupClassmin: arg1 max: arg2  ^(self min: arg1) max: arg2testReadFromDefaultOffsetSpecified  self assert: (DateAndTime readFrom: '2016-07-03T21:16:16.708241+02:00' readStream defaultOffset: Duration zero) offset equals: (Duration hours: 2)testTallyMethods  self assert: (Context tallyMethods: aBlockContext) size equals: 7asAlien  ^0allSelectorsWithout: arg1  | tmp1 |  tmp1 := IdentitySet new.  self withAllSuperclassesDo: [:arg2 |  (arg1 includes: arg2) ifFalse: [ tmp1 addAll: arg2 selectors ] ].  ^tmp1compiledMethod1  ^self class >> #method1unschedule: arg1  accessProtect critical: [ super unschedule: arg1 ]classLayout: arg1  layout := arg1testCanPerform  | tmp1 tmp2 |  tmp1 := Object subclass: 'MySuperclass' instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: self class category.  tmp1 compile: 'method1 ^self subclassResponsibility'.  tmp1 compile: 'method2 ^123'.  self deny: (tmp1 canPerform: #method1).  self assert: (tmp1 canPerform: #method2).  self deny: (tmp1 canPerform: #method3).  tmp2 := tmp1 subclass: 'MySubclass' instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self class category.  tmp2 compile: 'method1 ^ 3'.  tmp2 compile: 'method3 ^5'.  self assert: (tmp2 canPerform: #method1).  self assert: (tmp2 canPerform: #method3).  tmp2 removeFromSystem.  tmp1 removeFromSystemtestRefersToLiteralsReturnsTrueWhenLiteralIsInPragmaArguments  self assert: (self compiledMethod1 hasLiteralThorough: 'bar').  self assert: (self compiledMethod1 hasLiteralThorough: 123)isNotNil  ^truepragmas  ^self subclassResponsibilityarea  | tmp1 |  (tmp1 := self width) <= 0 ifTrue: [ ^0 ].  ^tmp1 * self height max: 0testNonCharacterPositive  | tmp1 |  tmp1 := (16rFDD0 to: 16rFDEF) asSet.  tmp1 addAll: (16r0FFFE to: 16r10FFFE by: 16r10000).  tmp1 addAll: (16r0FFFF to: 16r10FFFF by: 16r10000).  self assert: tmp1 size equals: 66.  tmp1 do: [:arg1 |  self assert: (Unicode isNonCharacter: (Character codePoint: arg1)) ]whichSelectorsAssign: arg1  self deprecated: 'Please use #whichSelectorsStoreInto: instead' transformWith: '`@receiver whichSelectorsAssign: `@statements' -> '`@receiver whichSelectorsStoreInto: `@statements'.  ^self whichSelectorsStoreInto: arg1removeCategory: arg1  (self protocolOrganizer hasProtocolNamed: arg1) ifFalse: [ ^self ].  self removeProtocol: (self protocolNamed: arg1)selectSubclasses: arg1  | tmp1 |  tmp1 := Set new.  self allSubclasses do: [:arg2 |  (arg1 value: arg2) ifTrue: [ tmp1 add: arg2 ] ].  ^tmp1= arg1  ^self value = arg1 valueallSelectorsToTestInMethodFinder  ^(self approvedSelectorsForMethodFinder union: self superclass allSelectorsToTestInMethodFinder) difference: self forbiddenSelectorsForMethodFinder asSetisReadOnlyObject  < primitive: 163 error: ec>  ^self class isImmediateClassnegated  ^Fraction numerator: numerator negated denominator: denominatorsign  self > 0 ifTrue: [ ^1 ].  self < 0 ifTrue: [ ^-1 ].  ^0default  ^niltestPrintStringHex  self assert: 0 printStringHex equals: '0'.  self assert: 12 printStringHex equals: 'C'.  self assert: 1234 printStringHex equals: '4D2'setPackage: arg1 withInMetacelloConfig: arg2  arg2 setPackage: arg1 withBlock: selfisPrimitive  ^self primitive > 0testDay  self assert: aDateAndTime day equals: DateAndTime new daytestBitClear  self assert: (2r1111 bitClear: 2r1000) equals: 2r0111.  self assert: (2r1111 bitClear: 2r0100) equals: 2r1011.  self assert: (2r1111 bitClear: 2r0010) equals: 2r1101.  self assert: (2r1111 bitClear: 2r0001) equals: 2r1110testFindContextSuchThat  self assert: (aMethodContext findContextSuchThat: [:arg1 |  true ]) printString equals: aMethodContext printString.  self assert: (aMethodContext hasContext: aMethodContext)testDaysInYear  self assert: (Date daysInYear: 2000) equals: 366.  self assert: (Date daysInYear: 2008) equals: 366.  self assert: (Date daysInYear: 2100) equals: 365testAsUTC  self assert: aDateAndTime asUTC equals: aDateAndTimehighBit  ^self shouldNotImplementtestRefersToLiteralsReturnsTrueWhenLiteralIsInMethodPropertiesValue  [ self compiledMethod1 propertyAt: #Once put: '123'.  self assert: (self compiledMethod1 hasLiteralThorough: '123') ] ensure: [ self compiledMethod1 removeProperty: #Once ]intersectWithCCAllWithCC: arg1  ^arg1 ifNotEmpty: [ Continuation currentDo: [:arg2 |  self intersectWithCC: arg1 first withAll: arg1 allButFirst continuation: arg2 ] ]testHour12  self assert: aDateAndTime hour12 equals: DateAndTime new hour12.  self assert: aDateAndTime hour12 equals: 12unpinInMemory  ^self setPinnedInMemory: falsebanChecksForValidation  ^{self .   self methodClass}testSecond  self assert: aDateAndTime second equals: 0testIntersectionWithOverlapping  self assert: (aTimespan intersection: anOverlappingTimespan) equals: (Timespan starting: jan01 duration: (Duration days: 6))isNumber  ^trueclassToBeTested  ^StopwatchcompiledMethodAt: arg1 ifAbsent: arg2  ^self methodDict at: arg1 ifAbsent: arg2hash  ^self bytesCount <= 8 ifTrue: [ self ] ifFalse: [ ByteArray hashBytes: self startingWith: self species hash ]offset  self subclassResponsibilitytestIsLeapYear  self assert: aDateAndTime isLeapYeartestAsDate  self assert: january23rd2004 asDate equals: january23rd2004setPinnedInMemory: arg1  < primitive: 184 error: ec>  ^self primitiveFailedinstall: arg1  self == Processor activeProcess ifTrue: [ ^self error: 'The active process cannot install contexts' ].  suspendedContext := arg1sizePushTemp: arg1  ^self sizeOpcodeSelector: #genPushTemp: withArguments: {arg1}do: arg1  | tmp1 |  tmp1 := firstLink.  [ tmp1 == nil ] whileFalse: [ arg1 value: tmp1 value.        tmp1 := tmp1 nextLink ]restartWithNewReceiver: arg1  self     swapReceiver: arg1;     restarttestDisplayStringLimitedString  | tmp1 |  tmp1 := Object new displayStringLimitedTo: 4.  self assert: tmp1 equals: 'an O...etc...'arcSin  (self < -1.0 or: [ self > 1.0 ]) ifTrue: [ ^DomainError signal: 'Value out of range' from: -1 to: 1 ].  (self = -1.0 or: [ self = 1.0 ]) ifTrue: [ ^Halfpi * self ] ifFalse: [ ^(self / (1.0 - (self * self)) sqrt) arcTan ]isCompletionCharacter  ^self isAlphaNumeric or: [ self = $: ]classBinding: arg1  ^self literalAt: self numLiterals put: arg1testDays  self assert: aDuration days equals: 1.  self assert: (Duration days: 1) days equals: 1descending  ^self asSortFunction reversedcopyWithSource: arg1  ^self copyWithTrailerBytes: (CompiledMethodTrailer new sourceCode: arg1)on: arg1 fork: arg2  ^self on: arg1 do: [:arg3 |  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |        tmp2 := thisContext.        tmp6 := tmp2 home.        [ tmp2 sender == tmp6 ] whileFalse: [ tmp2 := tmp2 sender.              tmp2 ifNil: [ ^arg2 cull: arg3 ] ].        tmp5 := [ Processor terminateActive ] asContext.        tmp2 privSender: tmp5.        tmp4 := [ arg2 cull: arg3 ] asContext.        tmp4 privSender: thisContext sender.        (Process forContext: tmp4 priority: Processor activePriority) resume.        thisContext privSender: tmp6.        nil ]message  ^messagegenPushNewArray: arg1  (arg1 < 0 or: [ arg1 > 127 ]) ifTrue: [ ^self outOfRangeError: 'size' index: arg1 range: 0 to: 127 ].  stream     nextPut: 231;     nextPut: arg1gtInspectorInstancesOn: arg1  < gtInspectorPresentationOrder: 40>  ^arg1 table     title: [ 'Instances' translated ];     display: [ self allInstances ];     column: 'Hash' evaluated: [:arg2 |  arg2 hash asString ];     column: 'Object' evaluated: [:arg2 |  arg2 printString ]asWeek  ^start asWeekusingMethods  self isAnonymous ifTrue: [ ^#() ].  ^self binding usingMethodsgreaseString  | tmp1 |  tmp1 := GRSignPrinter new , (GRNumberPrinter new precision: self scale).  ^tmp1 print: selfselfMessages  ^self ast selfMessagesserializeOn: arg1  start serializeOn: arg1- arg1  arg1 isInteger ifTrue: [ ^Fraction numerator: numerator - (denominator * arg1) denominator: denominator ].  arg1 isFraction ifTrue: [ ^self + arg1 negated ].  ^arg1 adaptToFraction: self andSend: #-withSideOrCorner: arg1 setToPoint: arg2 minExtent: arg3  ^self withSideOrCorner: arg1 setToPoint: arg2 minExtent: arg3 limit: ((#(left top) includes: arg1) ifTrue: [ SmallInteger minVal ] ifFalse: [ SmallInteger maxVal ])isBlockReturn: arg1  ^method encoderClass isBlockReturnAt: arg1 in: methodgenUnsignedMultipleExtendA: arg1  arg1 > 255 ifTrue: [ self genUnsignedMultipleExtendA: arg1 // 256 ].  stream     nextPut: 224;     nextPut: arg1 \\ 256intersect: arg1 withCollection: arg2 continuation: arg3  ^arg2 ifEmpty: [ arg3 value: arg2 ] ifNotEmpty: [ self intersect: arg1 withCollection: arg2 ]newInstanceFrom: arg1 variable: arg2 size: arg3  | tmp1 tmp2 |  arg2 ifTrue: [ tmp1 := self basicNew: arg1 basicSize ] ifFalse: [ tmp1 := self basicNew ].  self allSlots do: [:arg4 |  arg1 class slotNamed: arg4 name ifFound: [:arg5 |  arg4 wantsInitialization ifTrue: [ self initializeSlots: tmp1 ].              tmp2 := arg5 read: arg1.              arg4 write: tmp2 to: tmp1 ] ].  arg2 ifTrue: [ 1 to: arg1 basicSize do: [:arg6 |  tmp1 basicAt: arg6 put: (arg1 basicAt: arg6) ] ].  ^tmp1testThreeWayCompareTo  self assert: ($b threeWayCompareTo: $a) equals: 1.  self assert: ($a threeWayCompareTo: $b) equals: -1.  self assert: ($b threeWayCompareTo: $b) equals: 0arguments: arg1  arguments := arg1cleanUpCategoriesForClass: arg1  self allMethodSelectors do: [:arg2 |  (arg1 includesSelector: arg2) ifFalse: [ self removeElement: arg2 ] ]leftRotated  ^y @ x negatedreduced  | tmp1 tmp2 tmp3 |  numerator = 0 ifTrue: [ ^0 ].  tmp1 := numerator gcd: denominator.  tmp2 := numerator // tmp1.  tmp3 := denominator // tmp1.  tmp3 = 1 ifTrue: [ ^tmp2 ].  ^Fraction numerator: tmp2 denominator: tmp3testAsMinutes  self assert: (Duration seconds: 60) asMinutes equals: 1.  self assert: (Duration hours: 1) asMinutes equals: 60.  self assert: (aDuration asMinutes closeTo: 1563.0666).  self assert: ((Duration milliSeconds: 100) asMinutes closeTo: 1 / 600)asOrderedCollection  ^OrderedCollection with: selfname  ^namedecompileIR  ^IRBytecodeDecompiler new decompile: selftestPrint24OnWithPM  self assert: (String streamContents: [:arg1 |  aTime print24: false on: arg1 ]) equals: '12:34:56 pm'seconds  ^self secondisTrait  ^falsetestLookupSymbol  | tmp1 |  tmp1 := 2.  instVarForTestLookupSymbol := 3.  classVarForTestLookupSymbol := 4.  self assert: (thisContext lookupSymbol: #localVar) equals: 2.  self assert: (thisContext lookupSymbol: #instVarForTestLookupSymbol) equals: 3.  self assert: (thisContext lookupSymbol: #classVarForTestLookupSymbol) equals: 4.  self assert: (thisContext lookupSymbol: #Smalltalk) equals: Smalltalkstackp: arg1  < primitive: 76>  self error: 'stackp store failure'testInstructions  Object methods do: [:arg1 |  | tmp1 tmp2 tmp3 |        tmp1 := InstructionStream on: arg1.        tmp2 := InstVarRefLocator new.        tmp3 := tmp1 method endPC.        [ tmp1 pc <= tmp3 ] whileTrue: [ tmp2 interpretNextInstructionUsing: tmp1 ] ]testBasicCheck  | tmp1 |  tmp1 := testSubclass >> (testSubclass compile: self methodName).  self assert: (OverridesDeprecatedMethodRule new check: tmp1) isNotEmptyallInstVarNames  ^self superclass ifNil: [ self instVarNames ] ifNotNil: [:arg1 |  arg1 allInstVarNames , self instVarNames ]testOffset  | tmp1 tmp2 |  tmp1 := DateAndTime fromString: '2018/01/01T00:00:00+10'.  tmp2 := Week starting: tmp1 duration: 0.  self assert: tmp2 asDateAndTime offset equals: tmp1 offsetasRingMinimalCommentDefinitionIn: arg1  ^arg1 backend definitionFor: ('classComment:' , self name) asSymbol ifAbsentRegister: [ RGComment parent: (self asRingMinimalDefinitionIn: arg1) ]testDaysInYear  self assert: aDateAndTime daysInYear equals: 366copyForAnnouncement  | tmp1 |  tmp1 := self class copy new     basicSuperclass: superclass;     methodDict: self methodDict copy;     setFormat: format;     setName: name;     organization: self organization copy;     classPool: classPool copy;     sharedPools: sharedPools copy.  self class instSize + 1 to: self class instSize do: [:arg1 |  tmp1 instVarAt: arg1 put: (self instVarAt: arg1) ].  tmp1 classLayout: (layout copy host: tmp1).  ^tmp1* arg1  arg1 isPoint ifTrue: [ ^(x * arg1 x) @ (y * arg1 y) ].  ^arg1 adaptToPoint: self andSend: #*definition  ^self sourceCodepositive  ^falsesquishedWithin: arg1  ^origin corner: (corner min: arg1 bottomRight)isMeta  < metaLinkOptions: #(+ optionDisabledLink)>  level ifNil: [ level := 0 ].  ^level ~= 0nowTick  < primitive: 135>  ^0queueFor: arg1  arg1 ifNil: [ ^self defaultQueue ].  ^self queueDict at: arg1 ifAbsentPut: [ OrderedCollection new ]sqrtFloor  | tmp1 tmp2 tmp3 |  tmp1 := 1 bitShift: (self highBit + 1) // 2.  [ tmp2 := tmp1 * tmp1.  tmp3 := (tmp2 - self) // (tmp1 bitShift: 1).  tmp3 = 0 ] whileFalse: [ tmp1 := tmp1 - tmp3 ].  tmp2 = self ifFalse: [ tmp1 := tmp1 - 1 ].  ^tmp1hasPragmaNamed: arg1  ^falsepenultimateLiteral  ^self subclassResponsibilitymonth  ^self asMonthtestMethodClass  | tmp1 tmp2 |  tmp1 := self class >> #returnTrue.  self assert: tmp1 selector equals: #returnTrue.  Smalltalk removeClassNamed: #TUTU.  tmp2 := Object subclass: #TUTU instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self categoryNameForTemporaryClasses.  tmp2 compile: 'foo ^ 10'.  tmp1 := tmp2 >> #foo.  Smalltalk removeClassNamed: #TUTU.  self assert: tmp1 methodClass equals: tmp2raisedToFraction: arg1  self isZero ifTrue: [ arg1 negative ifTrue: [ ^(ZeroDivide dividend: 1) signal ].        ^self ].  self negative ifFalse: [ ^(self ln * arg1) exp ].  arg1 denominator even ifTrue: [ ^ArithmeticError signal: 'nth root only defined for positive Integer n.' ].  ^(self negated ln * arg1) exp negatedrenderOn: arg1  center  ^(self topLeft + self bottomRight) // 2degreesToRadians  ^self * RadiansPerDegreetruncated  ^numerator quo: denominatorcrTrace  self crTrace: selfaddTime: arg1  ^self class seconds: self asSeconds + arg1 asSecondsprevious  ^self class year: self year - 1gtDebuggerSUnitPrint  ^String streamContents: [:arg1 |  self printSeparateDateAndTimeOn: arg1 ]spotterSelectFor: arg1  localSendsAnySelectorOf: arg1  self literalsDo: [:arg2 |  (arg2 isSymbol and: [ arg1 includes: arg2 ]) ifTrue: [ ^self messages includesAny: arg1 ] ].  ^falsetestStoreOnRoundTrip  self assert: (self class compiler evaluate: Float halfPi storeString) equals: Float halfPi.  self assert: (self class compiler evaluate: Float halfPi negated storeString) equals: Float halfPi negated.  self assert: (self class compiler evaluate: Float infinity storeString) equals: Float infinity.  self assert: (self class compiler evaluate: Float infinity negated storeString) equals: Float infinity negated.  self assert: (self class compiler evaluate: Float nan storeString) isNaNtestReadFromManyDigits  | tmp1 tmp2 |  tmp1 := '1' , (String new: 321 withAll: $0) , '.0e-321'.  tmp2 := '0.' , (String new: 320 withAll: $0) , '1e321'.  self assert: (Number readFrom: tmp1) equals: 1.  self assert: (Number readFrom: tmp2) equals: 1asOrderedCollection  ^OrderedCollection with: selfasGlamorousMultiValue  ^GLMMultiValue with: selfmetaLinkOptions  ^{(#isNil -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}notifyRepackage: arg1 method: arg2 oldProtocol: arg3 newProtocol: arg4  | tmp1 tmp2 |  arg4 = arg3 ifTrue: [ ^self ].  self class environment at: #RPackage ifPresent: [:arg5 |  tmp2 := arg5 organizer packageForProtocol: arg4 inClass: self.        tmp1 := arg5 organizer packageForProtocol: arg3 inClass: self.        tmp2 = tmp1 ifFalse: [ SystemAnnouncer uniqueInstance methodRepackaged: arg2 from: tmp1 to: tmp2 ] ].  SystemAnnouncer uniqueInstance methodRecategorized: arg2 oldProtocol: arg3every: arg1 do: arg2  | tmp1 tmp2 |  tmp1 := self start.  tmp2 := self end.  [ tmp1 <= tmp2 ] whileTrue: [ arg2 value: tmp1.        tmp1 := tmp1 + arg1 ]ephemeronSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5  ^self ephemeronSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5testOnForkErrorOnSeparateProcess  | tmp1 tmp2 tmp3 |  tmp3 := Semaphore new.  tmp1 := [ 1 / 0 ] on: Exception fork: [ tmp2 := Processor activeProcess.        tmp3 signal ].  tmp3 wait.  self assert: tmp2 ~~ Processor activeProcesstestDefaultParsingSucceeds  | tmp1 |  tmp1 := Date year: 2013 month: 11 day: 29.  self assertReading: '29.11.2013' as: 'dd.mm.yyyy' equals: tmp1.  self assertReading: '29.11.2013' as: 'd.m.y' equals: tmp1.  self assertReading: '29.11.13' as: 'd.m.y' equals: tmp1testArithmeticAcrossDateBoundary  | tmp1 tmp2 |  tmp1 := '2004-01-07T11:55:00+00:00' asDateAndTime.  tmp2 := tmp1 - (42900 + 1) seconds.  self assert: tmp2 equals: '2004-01-06T23:59:59+00:00' asDateAndTimetestIndexOfMonth  self assert: (Date indexOfMonth: #January) equals: 1.  self assert: (Date indexOfMonth: #December) equals: 12.  self should: [ Date indexOfMonth: #NonExistantMonth ] raise: Errorschedule: arg1  schedule := arg1to: arg1 do: arg2  | tmp1 |  tmp1 := self.  [ tmp1 <= arg1 ] whileTrue: [ arg2 value: tmp1.        tmp1 := tmp1 + 1 ]sizePushFullClosure: arg1 numCopied: arg2 receiverOnStack: arg3 ignoreOuterContext: arg4  ^self sizeOpcodeSelector: #genPushFullClosure:numCopied:receiverOnStack:ignoreOuterContext: withArguments: {arg1 .         arg2 .         arg3 .         arg4}asColorOfDepth: arg1  ^Color colorFromPixelValue: self depth: arg1testallMethodsAccessingSlot  | tmp1 |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  tmp1 := LookupKey allMethodsAccessingSlot: (LookupKey slotNamed: #key).  self assert: (tmp1 includes: Association >> #key:value:)subclassInstVarNames  ^self allSubclasses flatCollectAsSet: [:arg1 |  arg1 instVarNames ]isKindOf: arg1  ^self class == arg1 or: [ self class inheritsFrom: arg1 ]timeProfile  ^Smalltalk tools timeProfiler onBlock: selfremoveFromSystem  ^self methodClass removeSelector: self selectortestIsSpaceSeparator  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isSpaceSeparator: tmp2) equals: (tmp1 isSpaceSeparator: tmp2) ]testSizeInMemorySmallIntegers  self assert: SmallInteger minVal sizeInMemory isZero.  self assert: 0 sizeInMemory isZero.  self assert: SmallInteger maxVal sizeInMemory isZero.  self assert: (SmallInteger minVal - 1) sizeInMemory > 0.  self assert: (SmallInteger maxVal + 1) sizeInMemory > 0asString  ^self printStringsetUp  super setUp.  class := Object subclass: #ClassForTests instanceVariableNames: '' classVariableNames: '' category: 'ClassOrganizer-Tests'.  organization := ClassOrganization forClass: class.  organization addCategory: 'empty'.  organization addCategory: 'one'.  organization classify: #one under: 'one' suppressIfDefault: truereciprocalLogBase2  ^self = 10.0 ifTrue: [ Ln2 / Ln10 ] ifFalse: [ Ln2 / self ln ]removeAllSuchThat: arg1  self do: [:arg2 |  (arg1 value: arg2) ifTrue: [ self remove: arg2 ] ]runUntilErrorOrReturnFrom: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := thisContext.  tmp1 := nil.  tmp2 := arg1 insertSender: (Context contextOn: Error , Halt do: [:arg2 |  tmp1 ifNil: [ tmp1 := arg2.                    tmp4 := thisContext.                    arg2 resumeUnchecked: tmp3 jump ] ifNotNil: [ arg2 pass ] ]).  tmp2 := tmp2 insertSender: (Context contextEnsure: [ tmp1 ifNil: [ tmp4 := thisContext.                    tmp3 jump ] ]).  self jump.  ^tmp1 ifNil: [ [ tmp2 isDead or: [ tmp4 isNil ] ] whileFalse: [ tmp4 := tmp4 stepToCallee ].        {tmp4 .         nil} ] ifNotNil: [ arg1 terminateTo: tmp2 sender.        {tmp4 .         tmp1} ]pragmas  ^#()waitWhile: arg1 inQueue: arg2 maxMilliseconds: arg3  [ arg1 value ] whileTrue: [ self exitAndWaitInQueue: arg2 maxMilliseconds: arg3 ]testIfTrue  self assert: (false ifTrue: [ 'alternativeBlock' ]) isNiltestOneArgument  | tmp1 |  tmp1 := OrderedCollection new.  tmp1 add: 'hello'.  [ tmp1 do: [ 1 + 2 ] ] ifError: [:arg1 |  self deny: arg1 equals: 'This block requires 0 arguments.' ].  [ tmp1 do: [:arg2 :arg3 |  1 + 2 ] ] ifError: [:arg1 |  self deny: arg1 equals: 'This block requires 2 arguments.' ]isObsolete  ^self soleInstance == nil or: [ self soleInstance classSide ~~ self or: [ self soleInstance isObsolete ] ]shutDown: arg1  ^self shutDowncull: arg1  ^selector numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: arg1 ]testDegreeCos  (4 / 3) degreeCos.  -361 / 3 to: 359 / 3 do: [:arg1 |  self assert: (arg1 degreeCos closeTo: arg1 degreesToRadians cos) ]asHelpTopic  ^SystemReference forClass: selfisTestMethod  ^falsesizeStoreLiteralVar: arg1  ^self sizeOpcodeSelector: #genStoreLiteralVar: withArguments: {arg1}variableWordSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 package: arg5  ^self variableWordSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: '' package: arg5initializeSlots: arg1  self classLayout initializeInstance: arg1quo: arg1  ^(self / arg1) truncatedshallowCopy  tearDown  testClass := nil.  super tearDownbearingToPoint: arg1  | tmp1 tmp2 |  tmp1 := arg1 x - x.  tmp2 := arg1 y - y.  tmp1 abs < 0.001 ifTrue: [ ^tmp2 > 0 ifTrue: [ 180 ] ifFalse: [ 0 ] ].  ^((tmp1 >= 0 ifTrue: [ 90 ] ifFalse: [ 270 ]) - (tmp2 / tmp1) arcTan negated radiansToDegrees) roundedallProtocolsUpTo: arg1  | tmp1 tmp2 tmp3 |  tmp1 := OrderedCollection new.  tmp3 := [:arg2 :arg3 |  arg2 asLowercase <= arg3 asLowercase ].  (self allSuperclassesIncluding: arg1) do: [:arg4 |  tmp1 addAll: arg4 organization categories ].  tmp1 remove: 'no messages' ifAbsent: [  ].  tmp2 := self organization categories sorted: tmp3.  ^tmp2 , ((tmp1 asSet removeAllSuchThat: [:arg5 |  tmp2 includes: arg5 ]) sorted: tmp3)embeddedSourceCode  ^dataclassAnnotationsDo: arg1  ^(ClassAnnotation findAllAnnotationsFor: self) do: arg1basicANSISignaledExceptionTestSelectors  ^#(simpleIsNestedTest simpleOuterTest doubleOuterTest doubleOuterPassTest doublePassOuterTest simplePassTest simpleResignalAsTest simpleResumeTest simpleRetryTest simpleRetryUsingTest simpleReturnTest)* arg1  < primitive: 549>  ^arg1 adaptToFloat: self andSend: #*testConvertFromIntegerWithScale  | tmp1 |  tmp1 := 13 asScaledDecimal: 6.  self assert: 6 equals: tmp1 scale.  self assert: '13.000000s6' equals: tmp1 printString.  tmp1 := -13 asScaledDecimal: 4.  self assert: 4 equals: tmp1 scale.  self assert: '-13.0000s4' equals: tmp1 printString.  tmp1 := 130000000013 asScaledDecimal: 3.  self assert: 3 equals: tmp1 scale.  self assert: '130000000013.000s3' equals: tmp1 printString.  tmp1 := -130000000013 asScaledDecimal: 1.  self assert: 1 equals: tmp1 scale.  self assert: '-130000000013.0s1' equals: tmp1 printStringdecodeVarLengthSourcePointer  | tmp1 tmp2 |  tmp1 := method size - 1.  tmp2 := data := 0.  [ | tmp3 |  tmp3 := method at: tmp1.  data := ((tmp3 bitAnd: 16r7F) << tmp2) + data.  tmp1 := tmp1 - 1.  tmp2 := tmp2 + 7.  tmp3 > 127 ] whileTrue.  size := method size - tmp1isExtension  ^self origin package ~= self packagetestDayOfWeek  self assert: aDateAndTime dayOfWeek equals: 1.  self assert: aDateAndTime dayOfWeekAbbreviation equals: 'Sun'.  self assert: aDateAndTime dayOfWeekName equals: 'Sunday'tearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  super tearDowncollectArguments: arg1  | tmp1 |  tmp1 := self arguments.  ^arg1 size = tmp1 size ifTrue: [ arg1 ] ifFalse: [ (tmp1 isEmpty ifTrue: [ tmp1 := Array new: selector numArgs ] ifFalse: [ tmp1 copy ]) replaceFrom: 1 to: (arg1 size min: tmp1 size) with: arg1 startingAt: 1 ]isAnnouncingObject  ^falsedragPassengerFor: arg1 inMorph: arg2  ^arg1hash  ^self subclassResponsibilitysimulateValueWithArguments: arg1 caller: arg2  | tmp1 |  tmp1 := (Context newForMethod: self compiledBlock) setSender: arg2 receiver: receiver method: self compiledBlock closure: self startpc: self compiledBlock initialPC.  ((tmp1 objectClass: arg1) ~~ Array or: [ numArgs ~= arg1 size ]) ifTrue: [ ^Context primitiveFailTokenFor: nil ].  tmp1 stackp: self compiledBlock numTemps.  1 to: numArgs do: [:arg3 |  tmp1 at: arg3 put: (arg1 at: arg3) ].  1 to: self basicSize do: [:arg3 |  tmp1 at: arg3 + numArgs put: (self at: arg3) ].  ^tmp1testIntegerDivision  self assert: aDuration // aDuration equals: 1.  self assert: aDuration // 2 equals: aDuration / 2testUnionWithIncluded  self assert: (aTimespan union: anIncludedTimespan) equals: aTimespantestOffset  | tmp1 tmp2 |  tmp1 := DateAndTime fromString: '2018/01/01T00:00:00+10'.  tmp2 := Month starting: tmp1 duration: 0.  self assert: tmp2 asDateAndTime offset equals: tmp1 offsetgenPushRemoteTemp: arg1 inVectorAt: arg2  (arg1 < 0 or: [ arg1 >= 256 ]) ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: arg1 range: 0 to: 255 ].  (arg2 < 0 or: [ arg2 >= 128 ]) ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: arg2 range: 0 to: 127 ].  stream     nextPut: 251;     nextPut: arg1;     nextPut: arg2to: arg1 by: arg2 do: arg3  | tmp1 |  tmp1 := self.  arg2 = 0 ifTrue: [ self error: 'step must be non-zero' ].  arg2 < 0 ifTrue: [ [ arg1 <= tmp1 ] whileTrue: [ arg3 value: tmp1.              tmp1 := tmp1 + arg2 ] ] ifFalse: [ [ arg1 >= tmp1 ] whileTrue: [ arg3 value: tmp1.              tmp1 := tmp1 + arg2 ] ]halt: arg1  < debuggerCompleteToSender>  Halt now: arg1ifTrue: arg1 ifFalse: arg2  ^arg2 valuehasSelector: arg1  ^self hasSelector: arg1 specialSelectorIndex: (Smalltalk specialSelectorIndexOrNil: arg1)isLetterNumber  ^self characterSet isLetterNumber: selfvalue: arg1  | tmp1 |  tmp1 := self receiver.  (self ensureReceiver: tmp1) ifFalse: [ ^nil ].  ^tmp1 perform: selector with: arg1truncated  example1  < sampleInstance>  | tmp1 |  1 < 2 ifTrue: [ tt ifNotNil: [ tmp1 := 'hallo' ] ].  ^tmp1< arg1  ^x < arg1 x and: [ y < arg1 y ]intersect: arg1 withAll: arg2  ^arg2 ifEmpty: [ arg1 ] ifNotEmpty: [ self intersect: arg1 withCollection: (self intersect: arg2 first withAll: arg2 allButFirst) ]exception  ^self tempAt: 1isLocalAliasSelector: arg1  ^falserestart  | tmp1 tmp2 |  self isDead ifTrue: [ self cannotReturn: nil to: self ].  self privRefresh.  tmp1 := thisContext.  [ tmp1 := tmp1 findNextUnwindContextUpTo: self.  tmp1 isNil ] whileFalse: [ tmp1 unwindComplete ifNil: [ tmp1 unwindComplete: true.              tmp2 := tmp1 unwindBlock.              thisContext terminateTo: tmp1.              tmp2 value ] ].  thisContext terminateTo: self.  self jumpisMathSymbol  ^self characterSet isMathSymbol: selfstandardMessageText  ^String streamContents: [:arg1 |  arg1 nextPutAll: self instVarName.        arg1 nextPutAll: ' not found in '.        arg1 print: self signaler ]asScaledDecimal: arg1  ^ScaledDecimal newFromNumber: self scale: arg1testYearsDo  | tmp1 |  tmp1 := Array with: (Year year: 2004) with: (Year year: 2005).  self assert: aTimespan years equals: tmp1testIsControlOther  self checkCorrespondanceOf: #isControlOther: and: #CcbottomLeft  ^origin x @ corner yprintStringOfTree: arg1 onStream: arg2  arg2 nextPut: $(.  (arg1 isMemberOf: Link) ifFalse: [ | tmp1 |        tmp1 := arg1.        [ | tmp2 |        tmp2 := tmp1 value.        (tmp2 isKindOf: Link) ifTrue: [ self printStringOfTree: tmp2 onStream: arg2 ] ifFalse: [ tmp2 printOn: arg2 ].        tmp1 nextLink ifNotNil: [ arg2 nextPut: Character space ].        tmp1 := tmp1 nextLink.        tmp1 isMemberOf: ValueLink ] whileTrue.        tmp1 ifNotNil: [ arg2                 nextPut: $.;                 nextPut: Character space.              tmp1 printOn: arg2 ] ].  arg2 nextPut: $)remove: arg1 oneStar: arg2 sentinel: arg3 continuation: arg4  ^arg2 ifNil: [ arg4 value: arg3 ] ifNotNil: [ | tmp1 tmp2 tmp3 |        tmp1 := arg2 value.        tmp2 := arg2 nextLink.        tmp3 := [ | tmp4 |        tmp4 := self remove: arg1 oneStar: tmp2 sentinel: arg3 continuation: arg4.        tmp1 ~~> tmp4 ].        (tmp1 isMemberOf: ValueLink) ifTrue: [ | tmp5 |              tmp5 := Continuation currentDo: [:arg5 |  self remove: arg1 oneStar: tmp1 sentinel: arg3 continuation: arg5 ].              tmp5 = arg3 ifTrue: tmp3 ifFalse: [ tmp5 ~~> tmp2 ] ] ifFalse: [ arg1 = tmp1 ifTrue: [ tmp2 ] ifFalse: tmp3 ] ]propertyKeysAndValuesDo: arg1  | tmp1 |  (tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 propertyKeysAndValuesDo: arg1 ]stonShouldWriteNilInstVars  ^falsealign64Bits: arg1  arg1 % 8 = 0 ifTrue: [ ^arg1 ] ifFalse: [ ^arg1 + 8 - (arg1 % 8) ]unusedBytecode  ^self respondsToUnknownBytecodeprintAsConstantQueryItem  ^self printStringhasBindingOf: arg1  ^falseisImmediateClass  ^self instSpec = 7testMethodsReferencingClass  self assert: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest111)) equals: {(ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.  self assert: ((ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest1)) sort: [:arg1 :arg2 |  arg1 name <= arg2 name ]) asArray equals: {(ClassTest >> #referencingMethod1) .         (ClassTest >> #referencingMethod2) .         (ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.  self assertEmpty: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #BehaviorTest))name  ^self printStringscanSchedule: arg1 startingAt: arg2  arg2 to: 1 by: -1 do: [:arg3 |  | tmp1 |        tmp1 := quiescentProcessLists at: arg3.        tmp1 do: [:arg4 |  arg1 value: arg4 ] ]size  | tmp1 |  tmp1 := 0.  self do: [:arg1 |  tmp1 := tmp1 + 1 ].  ^tmp1~~> arg1  ^ValueLink basicNew     value: self;     nextLink: arg1;     yourselfmetacelloStringLessThanSelf: arg1  ^truehashMultiply  ^(self bitAnd: 16rFFFFFFF) hashMultiplyresumeProcess: arg1  | tmp1 |  tmp1 := self remove: arg1 ifAbsent: [ nil ].  tmp1 ifNotNil: [ tmp1 resume ]testTwoArguments  | tmp1 |  tmp1 := WeakMessageSend receiver: Array selector: #with:with: arguments: {1 .         2}.  Smalltalk garbageCollectMost.  self assert: tmp1 value equals: {1 .         2}complexRecursionFirstCall  LocalRecursionStopper during: [ self complexRecursionLastCall ]testMinute  self assert: aDateAndTime minute equals: 0consumeAllSignals  excessSignals := 0testIsPrivateOther  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isPrivateOther: tmp2) equals: (tmp1 isPrivateOther: tmp2) ]phlowValue: arg1 withEnoughArguments: arg2  ^arg2 firsttestIsSpacingCombiningMark  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isSpacingCombiningMark: tmp2) equals: (tmp1 isSpacingCombiningMark: tmp2) ]spotterSuperClassMethodsFor: arg1  < spotterOrder: 16>  | tmp1 |  tmp1 := self class withAllSuperclasses select: #isMeta.  arg1 listProcessor     title: 'Super class methods';     allCandidates: [ self classSide allMethods select: [:arg2 |  (arg2 methodClass = self classSide) not & (tmp1 includes: arg2 methodClass) ] ];     filter: GTFilterSubstringtestRomanPrinting  self assert: 0 printStringRoman equals: ''.  self assert: 1 printStringRoman equals: 'I'.  self assert: 2 printStringRoman equals: 'II'.  self assert: 3 printStringRoman equals: 'III'.  self assert: 4 printStringRoman equals: 'IV'.  self assert: 5 printStringRoman equals: 'V'.  self assert: 6 printStringRoman equals: 'VI'.  self assert: 7 printStringRoman equals: 'VII'.  self assert: 8 printStringRoman equals: 'VIII'.  self assert: 9 printStringRoman equals: 'IX'.  self assert: 10 printStringRoman equals: 'X'.  self assert: 23 printStringRoman equals: 'XXIII'.  self assert: 36 printStringRoman equals: 'XXXVI'.  self assert: 49 printStringRoman equals: 'XLIX'.  self assert: 62 printStringRoman equals: 'LXII'.  self assert: 75 printStringRoman equals: 'LXXV'.  self assert: 88 printStringRoman equals: 'LXXXVIII'.  self assert: 99 printStringRoman equals: 'XCIX'.  self assert: 100 printStringRoman equals: 'C'.  self assert: 101 printStringRoman equals: 'CI'.  self assert: 196 printStringRoman equals: 'CXCVI'.  self assert: 197 printStringRoman equals: 'CXCVII'.  self assert: 198 printStringRoman equals: 'CXCVIII'.  self assert: 293 printStringRoman equals: 'CCXCIII'.  self assert: 294 printStringRoman equals: 'CCXCIV'.  self assert: 295 printStringRoman equals: 'CCXCV'.  self assert: 390 printStringRoman equals: 'CCCXC'.  self assert: 391 printStringRoman equals: 'CCCXCI'.  self assert: 392 printStringRoman equals: 'CCCXCII'.  self assert: 487 printStringRoman equals: 'CDLXXXVII'.  self assert: 488 printStringRoman equals: 'CDLXXXVIII'.  self assert: 489 printStringRoman equals: 'CDLXXXIX'.  self assert: 584 printStringRoman equals: 'DLXXXIV'.  self assert: 585 printStringRoman equals: 'DLXXXV'.  self assert: 586 printStringRoman equals: 'DLXXXVI'.  self assert: 681 printStringRoman equals: 'DCLXXXI'.  self assert: 682 printStringRoman equals: 'DCLXXXII'.  self assert: 683 printStringRoman equals: 'DCLXXXIII'.  self assert: 778 printStringRoman equals: 'DCCLXXVIII'.  self assert: 779 printStringRoman equals: 'DCCLXXIX'.  self assert: 780 printStringRoman equals: 'DCCLXXX'.  self assert: 875 printStringRoman equals: 'DCCCLXXV'.  self assert: 876 printStringRoman equals: 'DCCCLXXVI'.  self assert: 877 printStringRoman equals: 'DCCCLXXVII'.  self assert: 972 printStringRoman equals: 'CMLXXII'.  self assert: 973 printStringRoman equals: 'CMLXXIII'.  self assert: 974 printStringRoman equals: 'CMLXXIV'.  self assert: 1069 printStringRoman equals: 'MLXIX'.  self assert: 1070 printStringRoman equals: 'MLXX'.  self assert: 1071 printStringRoman equals: 'MLXXI'.  self assert: 1166 printStringRoman equals: 'MCLXVI'.  self assert: 1167 printStringRoman equals: 'MCLXVII'.  self assert: 1168 printStringRoman equals: 'MCLXVIII'.  self assert: 1263 printStringRoman equals: 'MCCLXIII'.  self assert: 1264 printStringRoman equals: 'MCCLXIV'.  self assert: 1265 printStringRoman equals: 'MCCLXV'.  self assert: 1360 printStringRoman equals: 'MCCCLX'.  self assert: 1361 printStringRoman equals: 'MCCCLXI'.  self assert: 1362 printStringRoman equals: 'MCCCLXII'.  self assert: 1457 printStringRoman equals: 'MCDLVII'.  self assert: 1458 printStringRoman equals: 'MCDLVIII'.  self assert: 1459 printStringRoman equals: 'MCDLIX'.  self assert: 1554 printStringRoman equals: 'MDLIV'.  self assert: 1555 printStringRoman equals: 'MDLV'.  self assert: 1556 printStringRoman equals: 'MDLVI'.  self assert: 1651 printStringRoman equals: 'MDCLI'.  self assert: 1652 printStringRoman equals: 'MDCLII'.  self assert: 1653 printStringRoman equals: 'MDCLIII'.  self assert: 1748 printStringRoman equals: 'MDCCXLVIII'.  self assert: 1749 printStringRoman equals: 'MDCCXLIX'.  self assert: 1750 printStringRoman equals: 'MDCCL'.  self assert: 1845 printStringRoman equals: 'MDCCCXLV'.  self assert: 1846 printStringRoman equals: 'MDCCCXLVI'.  self assert: 1847 printStringRoman equals: 'MDCCCXLVII'.  self assert: 1942 printStringRoman equals: 'MCMXLII'.  self assert: 1943 printStringRoman equals: 'MCMXLIII'.  self assert: 1944 printStringRoman equals: 'MCMXLIV'.  self assert: 2004 printStringRoman equals: 'MMIV'.  self assert: -1 printStringRoman equals: '-I'.  self assert: -2 printStringRoman equals: '-II'.  self assert: -3 printStringRoman equals: '-III'.  self assert: -4 printStringRoman equals: '-IV'.  self assert: -5 printStringRoman equals: '-V'.  self assert: -6 printStringRoman equals: '-VI'.  self assert: -7 printStringRoman equals: '-VII'.  self assert: -8 printStringRoman equals: '-VIII'.  self assert: -9 printStringRoman equals: '-IX'.  self assert: -10 printStringRoman equals: '-X'asPassiveRingDefinition  ^RGMethodDefinition new     name: self selector;     parentName: self methodClass name;     isMetaSide: self methodClass isMeta;     protocol: self category;     sourceCode: self sourceCode;     stamp: self timeStamp;     asPassive< arg1  arg1 isFraction ifTrue: [ ^numerator * arg1 denominator < (arg1 numerator * denominator) ].  ^arg1 adaptToFraction: self andCompare: #<obsoleteSubclasses  | tmp1 |  tmp1 := self basicObsoleteSubclasses at: self ifAbsent: [ ^#() ].  ^tmp1 copyWithout: niltestDaysInYear  self assert: aDateAndTime daysInYear equals: 366gtInspectorDetailsIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 table     title: 'Details';     display: [ {('iso' -> self print24) .         ('hours' -> self hours) .         ('minutes' -> self minutes) .         ('seconds' -> self seconds) .         ('nanoseconds' -> self nanoSecond) .         ('meridian' -> self meridianAbbreviation)} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valuemetacelloSemanticVersionComponentLessThan: arg1  ^self error: 'Invalid Metacello verson component - should be String or Integer.'removeProtocol: arg1  | tmp1 |  tmp1 := arg1 asSymbol.  (self organization listAtCategoryNamed: tmp1) do: [:arg2 |  self removeSelector: arg2 ].  self organization removeCategory: tmp1testCannotReturn  | tmp1 tmp2 |  tmp2 := [ tmp1 := thisContext ] fork.  [ tmp2 isTerminated ] whileFalse: [ 10 milliSeconds wait ].  [ tmp1 resume: #result.  self assert: false description: 'ContextCannotReturn should be signaled' ] on: ContextCannotReturn do: [:arg1 |  self assert: arg1 result equals: #result.        self assert: arg1 target equals: tmp1 ]testPrintShowingDecimalPlaces3  self assert: (1.009 printShowingDecimalPlaces: 3) equals: '1.009'.  self assert: (35.900 printShowingDecimalPlaces: 3) equals: '35.900'.  self assert: (-0.097 printShowingDecimalPlaces: 3) equals: '-0.097'testBlockTemps  | tmp1 |  #(1 2 3) do: [:arg1 |  | tmp2 |        tmp2 := arg1.        tmp ifNil: [ tmp2 := self callcc: [:arg2 |  tmp := arg2.                    [:arg3 |   ] ] ].        tmp2 value: tmp2.        tmp2 := 17 ].  tmp1 := self callcc: [:arg2 |  tmp value: arg2.        42 ].  self assert: tmp1 equals: 1scheduleDo: arg1  self between: self start and: self end do: arg1gtConstructDebuggerInspectorIn: arg1 for: arg2  ^arg1 custom: (GTDebuggerInspector new           debugger: arg2;           startOn: self)standardMessageText  ^String streamContents: [:arg1 |  self subscript ifNil: [ arg1 << 'subscript' ] ifNotNil: [ arg1 print: self subscript ].        (self lowerBound notNil and: [ self upperBound notNil ]) ifTrue: [ arg1 << ' is not between '.              arg1 print: self lowerBound.              arg1 << ' and '.              arg1 print: self upperBound ] ]alt  ^KMModifier alt + selfbase  ^codes firstopenDependencyAnalyzerOn: arg1  ^(DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: {arg1 packageName}) opentestTerminatingBlockedCriticalWhichWasSignalledButNotResumedYet  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := false.  tmp3 := false.  tmp4 := Semaphore new.  self fork: [ mutex critical: [ tmp4 wait.              tmp2 := true ] ] at: Processor activeProcess priority + 1.  self waitLastProcessLock.  tmp1 := self fork: [ mutex critical: [ self error: 'should not happen' ] ] at: Processor activeProcess priority - 1.  self waitLastProcessLock.  self deny: tmp2.  tmp4 signal.  self assert: tmp2.  tmp1 terminate.  self fork: [ mutex critical: [ tmp3 := true ] ].  self waitLastProcessTerminate.  self assert: tmp3 description: 'consequent last critical should be executed'numberOfDigits  ^self numberOfDigitsInBase: 10decodeEmbeddedSourceWide  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self decodeLengthField.  tmp2 := method size - self size + 1.  tmp3 := method size - self size + tmp1.  tmp4 := tmp3 - tmp2 + 1.  tmp5 := (ByteArray new: tmp4) replaceFrom: 1 to: tmp4 with: method startingAt: tmp2.  data := tmp5 utf8DecodedasScaledDecimal  #Numeric.  ^self asScaledDecimal: 8testReadFrom  self assert: (Fraction readFromString: '3') = 3 description: 'denominator is optional'.  self assert: (Fraction readFromString: '2/3') = (2 / 3) description: 'fraction and denominator must follow numerator'.  self assert: (Fraction readFromString: '-2/3') = (-2 / 3) description: 'numerator can specify a minus sign'.  self assert: (Fraction readFromString: '2/-5') = (-2 / 5) description: 'denominator can specify a minus sign'.  self assert: (Fraction readFromString: '-3/-7') = (3 / 7) description: 'numerator and denominator can both specify a minus sign'.  self assert: (Fraction readFromString: '2e3/3') = (2000 / 3) description: 'numerator can specify an exponent'.  self assert: (Fraction readFromString: '3/1e4') = (3 / 10000) description: 'denominator can specify an exponent'.  self assert: (Fraction readFromString: '16rA0/3') = (160 / 3) description: 'numerator can specify a radix'.  self assert: (Fraction readFromString: '1/3r22') = (1 / 8) description: 'denominator can specify a radix'testMutateObjectClass  | tmp1 |  tmp1 := WriteBarrierStub new.  tmp1 beReadOnlyObject.  self should: [ tmp1 primitiveChangeClassTo: WriteBarrierAnotherStub new ] raise: ModificationForbidden.  [ tmp1 primitiveChangeClassTo: WriteBarrierAnotherStub new ] on: ModificationForbidden do: [:arg1 |  arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 class equals: WriteBarrierAnotherStubclassVarNamed: arg1  ^self readClassVariableNamed: arg1settingFixedDomainValueNodeFrom: arg1  ^arg1 fixedDomainValueNodeForObject: selfmethod  ^methodjavascriptMonthIndex  ^self monthIndex - 1testNNegatedEqualsNComplementedPlusOne  | tmp1 |  1 to: 100 do: [:arg1 |  tmp1 := 1 bitShift: arg1.        self assert: tmp1 negated equals: (tmp1 bitXor: -1) + 1 ]originName: arg1  originName := arg1testIsAbstract  self assert: (self class >> #abstractMethod) isAbstract.  self deny: (self class >> #nonAbstractMethod) isAbstract.  self deny: (self class >> #shouldNotImplementMethod) isAbstractpushClosureTemps: arg1  arg1 timesRepeat: [ self push: nil ]willJustPop  ^self method encoderClass isJustPopAt: pc in: self methodtestReadTimeWithOtherCharactersAfter  self assert: (DateAndTime readFrom: '2016-02-03 19:23:48 +0131 By: Esteban Lorenzano <estebanlm@gmail.com> Jenkins build #547' readStream) printString equals: '2016-02-03T19:23:48+01:31'writesSlot: arg1  ^arg1 isWrittenIn: selfhighBitOfPositiveReceiver  | tmp1 tmp2 |  tmp1 := self.  tmp2 := 0.  [ tmp1 < 65536 ] whileFalse: [ tmp1 := tmp1 bitShift: -16.        tmp2 := tmp2 + 16 ].  tmp1 < 256 ifFalse: [ tmp1 := tmp1 bitShift: -8.        tmp2 := tmp2 + 8 ].  ^tmp2 + (#[0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8] at: tmp1 + 1)allLocalCallsOn: arg1  ^self instanceSide withAllSuperAndSubclasses flatCollect: [:arg2 |  (arg2 thoroughWhichMethodsReferTo: arg1) , (arg2 class thoroughWhichMethodsReferTo: arg1) ]digitAt: arg1 base: arg2  ^self // (arg2 raisedToInteger: arg1 - 1) \\ arg2constructFibonacciBlockWithBlockArgumentInDeadFrame  ^[:arg1 :arg2 |  arg1 <= 0 ifTrue: [ self error: 'not a natural number' ].  arg1 <= 2 ifTrue: [ 1 ] ifFalse: [ (arg2 value: arg1 - 1 value: arg2) + (arg2 value: arg1 - 2 value: arg2) ] ]testSubtractTime  self assert: (aTime subtractTime: aTime) equals: (Time readFrom: '00:00:00' readStream)absPrint: arg1 on: arg2 base: arg3  ^arg1 absPrintExactlyOn: arg2 base: arg3nonResumableFallOffTheEndHandler  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:arg1 |  self doSomethingExceptional ].  self doYetAnotherThingpointer  ^(ByteArray new: FFIExternalType pointerSize)     unsignedLongAt: 1 put: self;     yourselfspecies  ^Timespan+ arg1  self subclassResponsibilitytestExactSqrt  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 4.0s1.  tmp4 := tmp1 sqrt.  self assert: tmp4 equals: 2.  self assert: (tmp4 class = tmp1 class and: [ tmp4 scale = tmp1 scale ]).  tmp2 := 0.01s2.  tmp3 := tmp2 sqrt.  self assert: tmp3 * 10 equals: 1.  self assert: (tmp3 class = tmp2 class and: [ tmp3 scale = tmp2 scale ])atRandom  self = 0 ifTrue: [ ^0 ].  self < 0 ifTrue: [ ^self negated atRandom negated ].  ^self atRandom: SharedRandom globalGeneratorfromPoint: arg1  self setTop: arg1 y left: arg1 x bottom: arg1 y right: arg1 xtestModulo  | tmp1 tmp2 tmp3 |  tmp1 := 11.5 seconds.  tmp2 := tmp1 \\ 3.  self assert: tmp2 equals: (Duration nanoSeconds: 1).  tmp3 := tmp1 \\ 3 seconds.  self assert: tmp3 equals: (Duration seconds: 2 nanoSeconds: 500000000).  self assert: aDuration \\ aDuration equals: (Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: aDuration \\ 2 equals: (Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 1)classForTicker  ^DelayMillisecondTickerSimulationwritesRef: arg1  (self localWritesRef: arg1) ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:arg2 |  arg2 writesRef: arg1 ]jump: arg1  pc := pc + arg1testIsAbstract  self assert: Integer isAbstracttestGoodSimulation  self runSimulated: [ 1 + 2 ]theMetaClass  self deprecated: 'Please use #classSide instead' transformWith: '`@receiver theMetaClass' -> '`@receiver classSide'.  ^self classSidegenPushInstVarLong: arg1  (arg1 >= 0 and: [ arg1 < 256 ]) ifTrue: [ stream           nextPut: 132;           nextPut: 64;           nextPut: arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255classPool  ^self instanceSide classPoolcompiler  ^self instanceSide classSideCompilerclassVariables  ^self instanceSide ifNil: [ #() ] ifNotNil: [:arg1 |  arg1 classVariables ]simpleAdd: arg1  | tmp1 tmp2 |  codes ifNil: [ codes := Array with: arg1.        combined := arg1.        ^true ].  tmp1 := Compositions at: combined charCode ifAbsent: [ ^false ].  tmp2 := tmp1 at: arg1 charCode ifAbsent: [ ^false ].  combined := Character leadingChar: self base leadingChar code: tmp2.  codes at: 1 put: combined.  ^trueeven  ^(self bitAnd: 1) = 0testMinus  self assert: aDuration - aDuration equals: (Duration seconds: 0).  self assert: aDuration - (Duration days: -1 hours: -2 minutes: -3 seconds: -4 nanoSeconds: -5) equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10).  self assert: aDuration - (Duration days: 0 hours: 1 minutes: 2 seconds: 3 nanoSeconds: 4) equals: (Duration days: 1 hours: 1 minutes: 1 seconds: 1 nanoSeconds: 1).  self assert: aDuration - (Duration days: 0 hours: 3 minutes: 0 seconds: 5 nanoSeconds: 0) equals: (Duration days: 0 hours: 23 minutes: 2 seconds: 59 nanoSeconds: 5)topCenter  ^self center x @ self toptestFromDays  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := self dateClass fromDays: 0.  self assert: tmp2 equals: (self epoch translateTo: 0).  tmp3 := self dateClass fromDays: (june2nd1973 - self epoch) asDays.  self assert: tmp3 equals: (june2nd1973 translateTo: 0).  tmp1 := '18 March 1627' asDate.  tmp4 := self dateClass fromDays: (tmp1 - self epoch) asDays.  self assert: tmp4 equals: (tmp1 translateTo: 0).  tmp5 := self dateClass fromDays: 103 * 365 + 22 + 25.  self assert: tmp5 equals: (january23rd2004 translateTo: 0)cull: arg1  ^selector numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: arg1 ]gtInspectorSourceIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 pharoMethod     title: 'Source';     smalltalkClass: [ self methodClass ];     display: [ self sourceCode ];     act: [ self browse ] icon: GLMUIThemeExtraIcons glamorousBrowse entitled: 'Browse'testRefersToLiteralsReturnsTrueWhenLiteralIsInMethodPropertiesValueArray  [ self compiledMethod1 propertyAt: #Once put: #(1 2 3).  self assert: (self compiledMethod1 hasLiteralThorough: 1) ] ensure: [ self compiledMethod1 removeProperty: #Once ]sizeStoreInstVar: arg1  ^self sizeOpcodeSelector: #genStoreInstVar: withArguments: {arg1}testsourceCodeTemplateFor  self assert: (Object sourceCodeTemplate includesSubstring: 'instance-side message').  self assert: (Object class sourceCodeTemplate includesSubstring: 'class-side message')argument: arg1  args at: 1 put: arg1printOn: arg1  | tmp1 |  tmp1 := self class name.  arg1     nextPutAll: (tmp1 first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);     nextPutAll: tmp1followingBytecode  ^self method at: self followingPcisResumable  ^truestopTimerEventLoop  isCompiledBlock  ^falsetestAsUnixTimeIndependentOfTimezone  | tmp1 tmp2 |  tmp2 := DateAndTime current offset: Duration zero.  tmp1 := tmp2 offset: (Duration hours: 1).  self assert: tmp1 asUnixTime equals: tmp2 asUnixTimeisDefinedInPackage: arg1  ^arg1 includesClass: selftestCreationFromBytes2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  Smalltalk vm wordSize = 4 ifFalse: [ ^self skip ].  tmp1 := SmallInteger maxVal.  tmp2 := (tmp1 + 1) printStringHex.  self assert: tmp2 size equals: 8.  tmp6 := Number readFrom: (tmp2 copyFrom: 1 to: 2) base: 16.  tmp5 := Number readFrom: (tmp2 copyFrom: 3 to: 4) base: 16.  tmp4 := Number readFrom: (tmp2 copyFrom: 5 to: 6) base: 16.  tmp3 := Number readFrom: (tmp2 copyFrom: 7 to: 8) base: 16.  tmp7 := Integer byte1: tmp3 byte2: tmp4 byte3: tmp5 byte4: tmp6.  self assert: tmp7 equals: tmp1 + 1.  self deny: tmp7 class equals: SmallIntegerbinding  ^LiteralVariable key: nil value: selfvar1  ^var1testDateTime  self assert: aDateAndTime equals: (DateAndTime date: '01-01-1980' asDate time: '00:00:00' asTime)printOn: arg1  arg1 nextPutAll: self namehash  ^(context ifNil: [ explanationString ]) hashisUnwindContext  ^method primitive = 198classToBeTested  ^WeekbitShift: arg1  < primitive: 17>  self >= 0 ifTrue: [ ^super bitShift: arg1 ].  ^arg1 >= 0 ifTrue: [ (self negated bitShift: arg1) negated ] ifFalse: [ (self bitInvert bitShift: arg1) bitInvert ]millisecondsUntilTick: arg1  self subclassResponsibilityhasInstVarRef  self localHasInstVarRef ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:arg1 |  arg1 hasInstVarRef ]shouldNotImplement  ShouldNotImplement signalFor: thisContext sender selectortestIsPowerOfTwo  self deny: (1 / (2 raisedTo: 80) negated) isPowerOfTwo.  self deny: (1 negated / (2 raisedTo: 80)) isPowerOfTwo.  self deny: ((2 raisedTo: 80) negated / 3) isPowerOfTwo.  self deny: ((2 raisedTo: 80) / 4 negated) isPowerOfTwo.  self assert: (1 / 2) isPowerOfTwo.  self assert: (1 / (2 raisedTo: 80)) isPowerOfTwo.  self assert: (1 negated / (2 raisedTo: 80) negated) isPowerOfTwo.  self deny: ((2 raisedTo: 80) / 3) isPowerOfTwo.  self assert: ((2 raisedTo: 80) / 4) isPowerOfTwotestDynamicVariable  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Semaphore new.  tmp2 := Semaphore new.  tmp3 := tmp4 := false.  [ TestDynamicVariable value: 1 during: [ self checkDynamic: 1.        (Delay forMilliseconds: 30) wait.        self checkDynamic: 1.        TestDynamicVariable value: 3 during: [ (Delay forMilliseconds: 30) wait.              self checkDynamic: 3 ].        self checkDynamic: 1 ].  self checkDynamic: nil.  tmp3 := true.  tmp1 signal ] fork.  [ TestDynamicVariable value: 2 during: [ self checkDynamic: 2.        (Delay forMilliseconds: 30) wait.        self checkDynamic: 2 ].  self checkDynamic: nil.  tmp4 := true.  tmp2 signal ] fork.  tmp1 waitTimeoutSeconds: 2.  tmp2 waitTimeoutSeconds: 2.  self assert: tmp3.  self assert: tmp4renameSilently: arg1  [ self rename: arg1 ] fuelValueWithoutNotificationsallSharedPools  ^self superclass allSharedPoolsln  < primitive: 558>  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  self <= 0.0 ifTrue: [ ^DomainError signal: 'ln is only defined for x > 0' from: 0 ].  tmp1 := self exponent.  tmp2 := Ln2 * tmp1.  tmp3 := self timesTwoPower: 0 - tmp1.  tmp4 := tmp3 - 1.0.  tmp5 := 1.0.  tmp6 := tmp7 := tmp8 := tmp4.  tmp4 := tmp4 negated.  tmp9 := Epsilon * (tmp2 abs + 1.0).  [ tmp7 > tmp9 ] whileTrue: [ tmp5 := tmp5 + 1.0.        tmp6 := tmp6 * tmp4.        tmp7 := tmp6 / tmp5.        tmp8 := tmp8 + tmp7.        tmp5 := tmp5 + 1.0.        tmp6 := tmp6 * tmp4.        tmp7 := tmp6 / tmp5.        tmp8 := tmp8 + tmp7 ].  ^tmp2 + tmp8wait  [ self schedule.  beingWaitedOn ifTrue: [ delaySemaphore wait ] ifFalse: [ expired := true ] ] ensure: [ self unschedule ].  ^self isExpiredwithAllSubAndSuperclassesDo: arg1  self withAllSubclassesDo: arg1.  self allSuperclassesDo: arg1testMetaclassNumberOfInstances  self assert: Dictionary class allInstances size equals: 1.  self assert: OrderedCollection class allInstances size equals: 1initialize  super initialize.  self seconds: 0 nanoSeconds: 0ensureProperties  ^ClassProperties at: self ifAbsentPut: WeakKeyDictionary newprimeFactors  ^Array streamContents: [:arg1 |  self primeFactorsOn: arg1 ]printSubclassesOn: arg1 level: arg2  self printSubclassesOn: arg1 level: arg2 filter: nilcompilerClass  ^Smalltalk compilerClassfileOutCategory: arg1  | tmp1 |  tmp1 := (String new: 1000) writeStream.  tmp1     header;     timeStamp.  self fileOutCategory: arg1 on: tmp1.  tmp1 trailer.  ^CodeExporter writeSourceCodeFrom: tmp1 baseName: self name , '-' , arg1 isSt: truearguments: arg1  arguments := arg1testValueWithinTimingBasic  | tmp1 |  tmp1 := [ [ 1000 milliSeconds asDelay wait ] valueWithin: 100 milliSeconds onTimeout: [  ] ] durationToRun.  self assert: tmp1 < 1000 milliSecondstestMutateObjectInstVarShouldCatchRightFailure  | tmp1 tmp2 |  tmp1 := MessageSend new.  tmp1 beReadOnlyObject.  tmp2 := [ tmp1 receiver: #test ] on: ModificationForbidden do: [:arg1 |  arg1 ].  self assert: tmp2 object identicalTo: tmp1.  self assert: tmp2 newValue equals: #test.  self assert: tmp2 fieldIndex equals: 1var10  ^var10protocol  ^self categorytarget  ^target| arg1  ^selfprintOn: arg1  self printOn: arg1 showingDecimalPlaces: scale.  arg1     nextPut: $s;     print: scaleasFraction  ^denominator = 1 ifTrue: [ numerator ] ifFalse: [ Fraction numerator: numerator denominator: denominator ]testCannotReturn  | tmp1 tmp2 |  tmp2 := [ tmp1 := self blockWithNonLocalReturn: #result ] fork.  [ tmp2 isTerminated ] whileFalse: [ 10 milliSeconds wait ].  [ tmp1 value.  self assert: false description: 'BlockCannotReturn should be signaled' ] on: BlockCannotReturn do: [:arg1 |  self assert: arg1 result equals: #result.        self assert: arg1 home equals: tmp1 home ]initialize  self cleartestIsLeapYear  self deny: aDateAndTime isLeapYearvalue: arg1 value: arg2 value: arg3  < primitive: 204>  numArgs ~= 3 ifTrue: [ self numArgsError: 3 ].  ^self primitiveFailed& arg1  ^selftestIfNilIfNotNil  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 |  tmp4 := false.  tmp5 := false.  tmp6 := false.  tmp7 := false.  tmp9 := false.  tmp8 := false.  tmp11 := false.  tmp10 := false.  tmp1 := ProtoObject new.  tmp2 := Object new.  tmp1 ifNil: [ tmp4 := true ] ifNotNil: [ tmp5 := true ].  self assert: tmp4 equals: false.  self assert: tmp5 equals: true.  tmp1 ifNil: [ tmp6 := true ] ifNotNil: [:arg1 |  tmp7 := true ].  self assert: tmp6 equals: false.  self assert: tmp7 equals: true.  self assert: (tmp1 ifNil: [ false ] ifNotNil: [:arg1 |  arg1 == tmp1 ]).  self assert: (tmp1 ifNil: [ nil ] ifNotNil: [ tmp2 ]) identicalTo: tmp2.  self assert: (tmp1 ifNil: [ nil ] ifNotNil: [:arg1 |  tmp2 ]) identicalTo: tmp2.  tmp3 := [ tmp8 := true ].  tmp1 ifNil: [ tmp9 := true ] ifNotNil: tmp3.  self assert: tmp9 equals: false.  self assert: tmp8 equals: true.  tmp3 := [:arg1 |  tmp10 := true ].  tmp1 ifNil: [ tmp11 := true ] ifNotNil: tmp3.  self assert: tmp11 equals: false.  self assert: tmp10 equals: true.  tmp3 := [:arg1 |  arg1 == tmp1 ].  self assert: (tmp1 ifNil: [ false ] ifNotNil: tmp3).  tmp3 := [ tmp2 ].  self assert: (tmp1 ifNil: [ nil ] ifNotNil: tmp3) equals: tmp2.  tmp3 := [:arg1 |  tmp2 ].  self assert: (tmp1 ifNil: [ nil ] ifNotNil: tmp3) equals: tmp2tokenish  ^self isLetter or: [ self isDigit or: [ self = $_ or: [ self = $: ] ] ]** arg1  ^self raisedTo: arg1testParsingMPatternWithIncorrectMonthFails  self assertReading: '1.0.2013' as: 'dd.m.yyyy' raise: DateError.  self assertReading: '22.13.2013' as: 'dd.m.yyyy' raise: DateErrorperform: arg1  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: arg1 withArguments: (Array new: 0)isContext  ^trueencodeClearedTrailer  self clear.  kind := #NoTrailer.  ^self encodeprimitiveChangeClassTo: arg1  < primitive: 115>  self isReadOnlyObject ifTrue: [ ^self modificationForbiddenFor: #primitiveChangeClassTo: value: arg1 ].  self primitiveFailedcloseTo: arg1  ^self closeTo: arg1 precision: 0.0001isEpiceaInterestingJobOwner  ^false>= arg1  ^x >= arg1 x and: [ y >= arg1 y ]testNthRoot  1 << 2000 nthRoot: 100.  self assert: (1 << 2000 nthRoot: 100) equals: 1 << 20abs  self <= 0.0 ifTrue: [ ^0.0 - self ] ifFalse: [ ^self ]negated  ^-1.0 * selfend  ^self duration asNanoSeconds = 0 ifTrue: [ self start ] ifFalse: [ self next start - DateAndTime clockPrecision ]classToBeTested  ^TimespandecodeEmbeddedSource  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self decodeLengthField.  tmp2 := method size - self size + 1.  tmp3 := method size - self size + tmp1.  tmp4 := tmp3 - tmp2 + 1.  tmp5 := (ByteArray new: tmp4) replaceFrom: 1 to: tmp4 with: method startingAt: tmp2.  data := tmp5 asStringlog  | tmp1 tmp2 |  tmp1 := super log.  tmp1 isFinite ifTrue: [ ^tmp1 ].  tmp2 := self highBit.  ^2 log * tmp2 + (self / (1 << tmp2)) asFloat logdayOfWeekName  ^Week nameOfDay: self dayOfWeektestDaysInYear  self assert: aDateAndTime daysInYear equals: 365value: arg1 value: arg2 value: arg3 value: arg4  < primitive: 207>  | tmp1 |  numArgs ~= 4 ifTrue: [ self numArgsError: 4 ].  false ifTrue: [ tmp1 := self asContextWithSender: thisContext sender.        tmp1 at: 1 put: arg1.        tmp1 at: 2 put: arg2.        tmp1 at: 3 put: arg3.        tmp1 at: 4 put: arg4.        thisContext privSender: tmp1 ] ifFalse: [ self primitiveFailed ]nanoSecond  ^nanostestIntersectAll  self assert: (self intersectAll: {(LinkedList with: 3 with: #mangos with: #and) .               (LinkedList with: 3 with: #kiwis with: #and) .               (LinkedList with: 3 with: #hamburges)}) equals: {3}.  self assert: (self intersectAll: {(LinkedList with: 3 with: #steaks with: #and) .               (LinkedList with: #no with: #food with: #and) .               (LinkedList with: #three with: #baked with: #potatoes) .               (LinkedList with: 3 with: #diet with: #hamburges)}) equals: {}.  self assert: (self intersectAll: {(LinkedList with: 3 with: #steaks with: #and) .               LinkedList new .               (LinkedList with: #three with: #baked with: #potatoes) .               (LinkedList with: 3 with: #diet with: #hamburges)}) equals: {}.  self assert: (self intersectAllWithCC: {(LinkedList with: 3 with: #steaks with: #and) .               LinkedList new .               (LinkedList with: #three with: #baked with: #potatoes) .               (LinkedList with: 3 with: #diet with: #hamburges)}) equals: {}.  self assert: (self intersectWithCCAllWithCC: {(LinkedList with: 3 with: #steaks with: #and) .               (LinkedList with: #no with: #food with: #and) .               (LinkedList with: #three with: #baked with: #potatoes) .               (LinkedList with: 3 with: #diet with: #hamburges)}) equals: {}testIntegerPart  self     assert: 2 integerPart equals: 2;     assert: (1 / 2) integerPart equals: 0;     assert: (4 / 3) integerPart equals: 1;     assert: 2.0 integerPart equals: 2.0;     assert: 0.5 integerPart equals: 0.0;     assert: 2.5 integerPart equals: 2.0default  ^DefaultExecutionEnvironment instancetestJump  #(exampleClosure exampleSend exampleStore) do: [:arg1 |  self verifyJumpWithSelector: arg1 ]decimalDigitAt: arg1  ^self digitAt: arg1 base: 10testPrinting  self assert: month printString equals: 'July 1998'testSetOfFloat  | tmp1 tmp2 |  tmp1 := (Set new: 3)     add: 3;     add: 3.0;     size.  tmp2 := (Set new: 4)     add: 3;     add: 3.0;     size.  self assert: tmp1 = tmp2 description: 'The size of a Set should not depend on its capacity.'variableByteSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5  | tmp1 tmp2 |  tmp1 := self environment at: arg1 ifAbsent: [ nil ].  tmp2 := (tmp1 notNil and: [ tmp1 classLayout class == CompiledMethodLayout ]) ifTrue: [ CompiledMethodLayout ] ifFalse: [ ByteLayout ].  ^self classInstaller make: [:arg6 |  arg6           superclass: self;           name: arg1;           layoutClass: tmp2;           slots: arg2 asSlotCollection;           sharedVariablesFromString: arg3;           sharedPools: arg4;           category: arg5;           environment: self environment ]deleteClass  | tmp1 |  tmp1 := testEnvironment at: className ifAbsent: [ ^self ].  testingEnvironment at: #ChangeSet ifPresent: [ tmp1 removeFromChanges ].  tmp1 removeFromSystemUnloggedtestNew  self should: [ False new ] raise: self defaultTestErrorencoderClass  ^self signFlag ifTrue: [ SecondaryBytecodeSetEncoderClass ] ifFalse: [ PrimaryBytecodeSetEncoderClass ]isAnyArgumentGarbage  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg1 :arg2 |  (arg2 not and: [ arg1 isNil ]) ifTrue: [ ^true ] ] ].  ^falsehome  ^outerContext hometestAs  | tmp1 tmp2 |  tmp1 := {1 .   2 .   3}.  tmp2 := tmp1 as: OrderedCollection.  self assert: tmp2 equals: (OrderedCollection with: 1 with: 2 with: 3).  self deny: tmp1 identicalTo: tmp2.  tmp2 := tmp1 as: Array.  self assert: tmp1 identicalTo: tmp2aRandomSelectionOfCharactersDo: arg1  self aRandomSelectionOfCodePointsDo: [:arg2 |  arg1 value: (Character codePoint: arg2) ]fileOut  ^self origin fileOutMethod: self selectorasYear  ^start asYearrenderGlamorouslyOn: arg1  ^arg1 renderObject: selftestIsConnectorPunctuation  self checkCorrespondanceOf: #isConnectorPunctuation: and: #PctestIsOnOrBefore  | tmp1 tmp2 |  tmp1 := january23rd2004 translateTo: -8.  tmp2 := january23rd2004 translateTo: 10.  self     assert: (tmp1 isOnOrBefore: tmp2);     assert: (june2nd1973 isOnOrBefore: january23rd2004);     assert: (june2nd1973 isOnOrBefore: june2nd1973);     assert: (january23rd2004 isOnOrBefore: june2nd1973) notgenBranchPopFalse: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'distance' index: arg1 range: 0 to: 1023 ].  (arg1 > 0 and: [ arg1 < 9 ]) ifTrue: [ stream nextPut: 152 + arg1 - 1.        ^self ].  arg1 < 1024 ifTrue: [ stream           nextPut: 172 + (arg1 bitShift: -8);           nextPut: (arg1 + 1024) \\ 256.        ^self ].  ^self outOfRangeError: 'distance' index: arg1 range: 0 to: 1023bitAt: arg1  ^(self bitShift: 1 - arg1) bitAnd: 1ln  ^DomainError signal: 'ln is only defined for x > 0' from: 0>= arg1  arg1 isFraction ifTrue: [ ^numerator * arg1 denominator >= (arg1 numerator * denominator) ].  ^arg1 adaptToFraction: self andCompare: #>=hasMethodReturn  | tmp1 tmp2 |  tmp1 := InstructionStream new method: outerContext method pc: startpc.  tmp2 := self endPC.  tmp1 scanFor: [:arg1 |  (outerContext method encoderClass methodReturnBytecodes includes: arg1) or: [ tmp1 pc > tmp2 ] ].  ^tmp1 pc <= tmp2waitInQueue: arg1 maxMilliseconds: arg2  self exitAndWaitInQueue: arg1 maxMilliseconds: arg2printLowercaseHexByteOn: arg1  (self between: 0 and: 255) ifTrue: [ | tmp1 tmp2 tmp3 |        tmp1 := self bitShift: -4.        tmp2 := self bitAnd: 15.        tmp3 := '0123456789abcdef'.        arg1           nextPut: (tmp3 at: tmp1 + 1);           nextPut: (tmp3 at: tmp2 + 1) ] ifFalse: [ self error: 'byte value between 0 and 255 expected' ]testIsLineSeparator  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isLineSeparator: tmp2) equals: (tmp1 isLineSeparator: tmp2) ]genPushInstVar: arg1  (arg1 between: 0 and: 15) ifTrue: [ stream nextPut: 0 + arg1.        ^self ].  self genPushInstVarLong: arg1methodClass  ^self classBinding valuestoreAt: arg1 inTempFrame: arg2  ^arg2 tempAt: arg1 put: selfalignedTo: arg1  ^(self + arg1 - 1) // arg1 * arg1isTwoDigitMonthPattern  ^patternStream peekFor: $mtestYesterday  self deny: aDateAndTime equals: DateAndTime yesterday+ arg1  ^self species starting: self start + arg1 duration: self durationdayOfMonth  ^start dayOfMonthcull: arg1 cull: arg2 cull: arg3  ^selector numArgs < 3 ifTrue: [ self cull: arg1 cull: arg2 ] ifFalse: [ self value: arg1 value: arg2 value: arg3 ]testMultiSchedule  | tmp1 |  tmp1 := Delay forSeconds: 1.  tmp1 schedule.  self should: [ tmp1 schedule ] raise: ErrorprintOn: arg1  arg1 nextPutAll: 'true'>= arg1  arg1 class = self class ifTrue: [ ^self asFraction >= arg1 asFraction ].  ^self asFraction >= arg1testBecomeForward  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 'ab' copy.  tmp2 := 'cd' copy.  tmp3 := tmp1.  tmp4 := tmp2.  tmp1 becomeForward: tmp2.  self     assert: tmp1 equals: 'cd';     assert: tmp2 equals: 'cd';     assert: tmp3 equals: 'cd';     assert: tmp4 equals: 'cd'testTransitive  | tmp1 tmp2 tmp3 |  tmp1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  tmp2 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  tmp3 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self assert: (tmp1 = tmp2 & (tmp2 = tmp3)) ==> (tmp1 = tmp3)testReadFrom  | tmp1 tmp2 tmp3 |  tmp1 := '123s could be confused with a ScaledDecimal' readStream.  tmp2 := Integer readFrom: tmp1.  self assert: tmp2 equals: 123.  tmp3 := tmp1 upToEnd.  self assert: 's could be confused with a ScaledDecimal' equals: tmp3.  tmp1 := '123.s could be confused with a ScaledDecimal' readStream.  tmp2 := Integer readFrom: tmp1.  self assert: tmp2 equals: 123.  tmp3 := tmp1 upToEnd.  self assert: '.s could be confused with a ScaledDecimal' equals: tmp3testPrintStringBase  2 to: 32 do: [:arg1 |  1 to: 1000 // arg1 do: [:arg2 |  | tmp1 |              tmp1 := arg1 raisedTo: arg2.              self assert: (tmp1 - 1 printStringBase: arg1) equals: (String new: arg2 withAll: (Character digitValue: arg1 - 1)).              self assert: (tmp1 printStringBase: arg1) equals: '1' , (String new: arg2 withAll: $0).              self assert: (tmp1 negated + 1 printStringBase: arg1) equals: '-' , (String new: arg2 withAll: (Character digitValue: arg1 - 1)).              self assert: (tmp1 negated printStringBase: arg1) equals: '-1' , (String new: arg2 withAll: $0) ] ]runBackendLoopAtTimingPriority  < haltOrBreakpointForTesting>  [ [ runTimerEventLoop ] whileTrue: [ | tmp1 |        ticker waitForUserSignalled: timingSemaphore orExpired: activeDelay.        debug ifTrue: [ self halt ].        suspendSemaphore ifNotNil: [ self suspendAtTimingPriority ].        delayToStart ifNotNil: [ self scheduleAtTimingPriority ].        delayToStop ifNotNil: [ self unscheduleAtTimingPriority ].        tmp1 := ticker nowTick.        [ activeDelay notNil and: [ tmp1 >= activeDelay resumptionTick ] ] whileTrue: [ activeDelay timingPrioritySignalExpired.              activeDelay := suspendedDelays removeFirstOrNil ] ] ] ensure: [ debug ifTrue: [ self halt ].        [ activeDelay notNil ] whileTrue: [ activeDelay timingPrioritySignalExpired.              activeDelay := suspendedDelays removeFirstOrNil ] ]withAllSuperclasses  ^self allSuperclasses     addFirst: self;     yourselfblockReturnConstant: arg1  self assert: closureOrNil isClosure.  ^self return: arg1 from: selfsendTo: arg1  ^arg1 perform: self selector withArguments: self argumentsulp  | tmp1 |  self isFinite ifFalse: [ self isNaN ifTrue: [ ^self ].        ^Float infinity ].  self = 0.0 ifTrue: [ ^Float fmin ].  tmp1 := self exponent.  ^tmp1 < self class emin ifTrue: [ Float fminDenormalized ] ifFalse: [ Float epsilon timesTwoPower: tmp1 ]fileOutInitializerOn: arg1  ^self class fileOutInitializerOn: arg1copySignTo: arg1  ^self signBit = 0 ifTrue: [ arg1 abs ] ifFalse: [ arg1 abs negated ]unpackFromArity: arg1  self = 0 ifFalse: [ self error: 'Should not arrive here. FFI bad code.' ].  ^selfvariableWordSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 category: arg5  ^self variableWordSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 package: arg5startpc  ^closureOrNil ifNil: [ self method initialPC ] ifNotNil: [ closureOrNil startpc ]instVarMappingFrom: arg1  | tmp1 |  tmp1 := arg1 allInstVarNames.  ^self allInstVarNames collect: [:arg2 |  tmp1 indexOf: arg2 ]testBitAnd  self assert: (2r1100 bitAnd: 2r1010) equals: 2r1000.  self assert: 2r1100 & 2r1010 equals: 2r1000.  self assert: (-2 bitAnd: 16rFFFFFFFF) equals: 16rFFFFFFFE.  self assert: -2 & 16rFFFFFFFF equals: 16rFFFFFFFEprintOn: arg1  arg1 << 'compiledBlock'testCopy  | tmp1 |  tmp1 := amState copy.  self deny: amState identicalTo: tmp1.  self assert: amState method identicalTo: tmp1 method.  self assert: amState selector identicalTo: tmp1 selector.  self assert: amState pragmas equals: tmp1 pragmas.  self assert: amState properties equals: tmp1 properties.  amState pragmas withIndexDo: [:arg1 :arg2 |  self deny: arg1 identicalTo: (tmp1 pragmas at: arg2) ]isNil  ^truetestZero  self assert: Duration zero equals: (Duration seconds: 0)testTimeZoneEquivalence  | tmp1 tmp2 tmp3 |  tmp1 := '2004-11-02T14:00:00+00:00' asDateAndTime.  tmp2 := '2004-11-02T09:00:00-05:00' asDateAndTime.  tmp3 := tmp1 - tmp2.  self assert: tmp3 asSeconds equals: 0.  self assert: tmp1 equals: tmp2ln  < primitive: 58>  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  self <= 0.0 ifTrue: [ ^DomainError signal: 'ln is only defined for x > 0' from: 0 ].  tmp1 := self exponent.  tmp2 := Ln2 * tmp1.  tmp3 := self timesTwoPower: 0 - tmp1.  tmp4 := tmp3 - 1.0.  tmp5 := 1.0.  tmp6 := tmp7 := tmp8 := tmp4.  tmp4 := tmp4 negated.  tmp9 := Epsilon * (tmp2 abs + 1.0).  [ tmp7 > tmp9 ] whileTrue: [ tmp5 := tmp5 + 1.0.        tmp6 := tmp6 * tmp4.        tmp7 := tmp6 / tmp5.        tmp8 := tmp8 + tmp7.        tmp5 := tmp5 + 1.0.        tmp6 := tmp6 * tmp4.        tmp7 := tmp6 / tmp5.        tmp8 := tmp8 + tmp7 ].  ^tmp2 + tmp8spaceUsed  | tmp1 |  tmp1 := 0.  self methodsDo: [:arg1 |  tmp1 := tmp1 + 16.        tmp1 := tmp1 + (arg1 size + 6).        arg1 literalsDo: [:arg2 |  (arg2 isMemberOf: Array) ifTrue: [ tmp1 := tmp1 + ((arg2 size + 1) * 4) ].              (arg2 isMemberOf: Float) ifTrue: [ tmp1 := tmp1 + 12 ].              (arg2 isMemberOf: ByteString) ifTrue: [ tmp1 := tmp1 + (arg2 size + 6) ].              (arg2 isMemberOf: LargeNegativeInteger) ifTrue: [ tmp1 := tmp1 + ((arg2 size + 1) * 4) ].              (arg2 isMemberOf: LargePositiveInteger) ifTrue: [ tmp1 := tmp1 + ((arg2 size + 1) * 4) ] ] ].  ^tmp1expandTo: arg1  ^Rectangle origin: (origin roundDownTo: arg1) corner: (corner roundUpTo: arg1)allSharedPools  ^OrderedCollection newnumArgs  ^self arguments sizesetUp  super setUp.  restoredStartDay := Week startDay.  restoredTimeZone := DateAndTime localTimeZone.  Week startDay: #Sunday.  DateAndTime localTimeZone: (TimeZone timeZones detect: [:arg1 |  arg1 abbreviation = 'GMT' ])testCommonSuperclassWith  self assert: (OrderedCollection commonSuperclassWith: Array) equals: SequenceableCollection.  self assert: (OrderedCollection commonSuperclassWith: OrderedCollection) equals: SequenceableCollection.  self assert: (ProtoObject commonSuperclassWith: Object) equals: niltestReplaceFromToWithStartingAt  | tmp1 tmp2 |  tmp1 := LargeNegativeInteger new: 20.  1 to: 20 do: [:arg1 |  tmp1 byteAt: arg1 put: arg1 ].  tmp2 := LargeNegativeInteger new: 7.  1 to: 7 do: [:arg1 |  tmp2 byteAt: arg1 put: 11 - arg1 ].  tmp1 replaceFrom: 6 to: 10 with: tmp2 startingAt: 2.  (1 to: 5) , (11 to: 20) do: [:arg2 |  | tmp3 |        tmp3 := tmp1 byteAt: arg2.        self assert: arg2 equals: tmp3 ].  6 to: 10 do: [:arg2 |  | tmp3 tmp4 |        tmp3 := tmp1 byteAt: arg2.        tmp4 := tmp2 byteAt: arg2 - 4.        self assert: tmp4 equals: tmp3 ]truncated  (origin x isInteger and: [ origin y isInteger and: [ corner x isInteger and: [ corner y isInteger ] ] ]) ifTrue: [ ^self ].  ^Rectangle origin: origin truncated corner: corner truncatedtestYearMonthDay  self assert: aDateAndTime equals: (DateAndTime year: 1901 month: 1 day: 1)basicNew: arg1  < primitive: 71 error: ec>  ec == #'insufficient object memory' ifTrue: [ ^self handleFailingBasicNew: arg1 ].  self isVariable ifFalse: [ self error: self printString , ' cannot have variable sized instances' ].  self primitiveFailedcategory  | tmp1 |  self basicCategory ifNotNil: [:arg1 |  ((self environment organization listAtCategoryNamed: arg1) includes: self name) ifTrue: [ ^arg1 ] ].  tmp1 := (self environment organization categoryOfElement: self name) ifNil: [ #Unclassified ] ifNotNil: [:arg2 |  arg2 ].  self basicCategory: tmp1.  ^tmp1classSide  ^selfremoveSharedPool: arg1  | tmp1 tmp2 tmp3 |  (self sharedPools includes: arg1) ifFalse: [ ^self error: 'the dictionary is not in my pool' ].  (self selectSuperclasses: [:arg2 |  arg2 sharedPools includes: arg1 ]) isEmpty ifFalse: [ self sharedPools remove: arg1.        self sharedPools isEmpty ifTrue: [ self sharedPools: nil ].        ^self ].  tmp2 := self subclasses asOrderedCollection.  tmp1 := Set new.  [ tmp2 isEmpty ] whileFalse: [ tmp3 := tmp2 removeFirst.        (tmp3 sharedPools includes: arg1) ifFalse: [ tmp1 add: tmp3.              tmp2 addAll: tmp3 subclasses ] ].  tmp1 add: self.  tmp1 do: [:arg3 |  arg1 associationsDo: [:arg4 |  (arg3 whichSelectorsReferTo: arg4) isEmpty ifFalse: [ ^self error: arg4 key , ' is still used in code of class ' , arg3 name ] ] ].  self sharedPools remove: arg1.  self sharedPools isEmpty ifTrue: [ self sharedPools: nil ]genStoreInstVar: arg1  (arg1 < 0 or: [ arg1 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 65535 ].  arg1 > 255 ifTrue: [ self genUnsignedSingleExtendA: arg1 // 256 ].  stream     nextPut: 243;     nextPut: arg1 \\ 256freeze  self freezeUpTo: thisContextisSignaled  ^excessSignals > 0arcTan  < primitive: 557>  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self < 0.0 ifTrue: [ ^0.0 - (0.0 - self) arcTan ].  tmp1 := self * Halfpi / (self + 1.0).  tmp2 := Halfpi * Epsilon.  tmp3 := tmp1.  [ tmp3 * tmp3 > tmp2 ] whileTrue: [ tmp4 := tmp1 sin.        tmp5 := tmp1 cos.        tmp3 := tmp4 * tmp5 - (self * tmp5 * tmp5).        tmp1 := tmp1 - tmp3 ].  ^tmp1gtDebuggerSUnitPrint  ^self printStringisProbablyPrimeWithK: arg1 andQ: arg2 randomIndex: arg3  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := ((self - 2) * arg3) asInteger + 1.  tmp2 := 0.  tmp3 := tmp1 raisedTo: arg2 modulo: self.  tmp4 := self - 1.  [ tmp3 = 1 ifTrue: [ ^tmp2 = 0 ].  tmp3 = tmp4 ifTrue: [ ^true ].  (tmp2 := tmp2 + 1) < arg1 ] whileTrue: [ tmp3 := tmp3 squared \\ self ].  ^falseprintOn: arg1  ^self printOn: arg1 withLeadingSpace: falsetestAsNanoSeconds  self assert: aDateAndTime asNanoSeconds equals: 0 asDuration asNanoSecondslocalWritesRef: arg1  | tmp1 tmp2 |  (tmp1 := self indexOfLiteral: arg1) = 0 ifTrue: [ ^false ].  tmp1 := tmp1 - 1.  ^(tmp2 := InstructionStream on: self) scanFor: (self encoderClass bindingWriteScanBlockFor: tmp1 using: tmp2)findOriginClassOf: arg1  ^selfwaitForUserSignalled: arg1 orExpired: arg2  | tmp1 |  tmp1 := self nowTick + (1 * 1000).  arg2 ifNotNil: [ tmp1 := tmp1 min: arg2 resumptionTick ].  arg1 initSignals.  self primSignal: arg1 atMilliseconds: tmp1.  arg1 wait>= arg1  < primitive: 46>  ^arg1 adaptToFloat: self andCompare: #>=subclassesDo: arg1  self isMetaclassOfClassOrNil ifTrue: [ ^self ].  self instanceSide subclasses do: [:arg2 |  arg1 value: arg2 classSide ]spotterInstanceVariablesFor: arg1  < spotterOrder: 20>  self isTrait ifTrue: [ ^self ].  arg1 listProcessor     title: 'Instance variables';     allCandidates: [ self classLayout allSlots ];     itemName: [:arg2 |  arg2 name asString ];     filter: GTFilterSubstringisAnonymous  ^self soleInstance isAnonymousmeridianAbbreviation  ^self hour < 12 ifTrue: [ 'AM' ] ifFalse: [ 'PM' ]instVarAt: arg1 put: arg2  < primitive: 174 error: ec>  (arg1 isInteger and: [ arg1 between: 1 and: self class instSize + self basicSize ]) ifFalse: [ ^self errorSubscriptBounds: arg1 ].  self isReadOnlyObject ifTrue: [ ^self modificationForbiddenFor: #instVarAt:put: index: arg1 value: arg2 ]testSupplySpecificAnswerToQuestion  self should: [ false = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('You like Smalltalk?' false)) ]resumableFallOffTheEndHandler  [ self doSomething.  MyTestNotification signal.  self doSomethingElse ] on: MyTestNotification do: [:arg1 |  self doSomethingExceptional ].  self doYetAnotherThingensureRingDefinitionIn: arg1  | tmp1 |  tmp1 := self methodClass ensureRingDefinitionIn: arg1.  ^tmp1 methods detect: [:arg2 |  arg2 selector = self selector ] ifNone: [ | tmp2 |        tmp2 := self asRingMinimalDefinitionIn: arg1.        tmp1 addLocalMethod: tmp2.        tmp2 ]priority: arg1  (arg1 between: Processor lowestPriority and: Processor highestPriority) ifTrue: [ priority := arg1 ] ifFalse: [ self error: 'Invalid priority: ' , arg1 printString ]testIfTrue  self assert: (true ifTrue: [ 'alternativeBlock' ]) equals: 'alternativeBlock'metacelloIntegerLessThanSelf: arg1  ^arg1 < selfleft  ^origin xsimulate_vmMilliseconds: arg1  vmSimNextWakeupTick ~= 0 ifTrue: [ vmSimNow := arg1.        vmSimNow >= vmSimNextWakeupTick ifTrue: [ vmSimNextWakeupTick := 0.              vmSimTheTimerSemaphore signal ] ]isSubclassResponsibility  ^self isSubclassResponsibility: self markerOrNiltestSimplePass  self assertSuccess: (ExceptionTester new runTest: #simplePassTest)testFromString  | tmp1 |  tmp1 := self dateClass fromString: '06.02.1973'.  self assert: tmp1 equals: june2nd1973.  tmp1 := self dateClass fromString: '06-02-1973'.  self assert: tmp1 equals: june2nd1973.  tmp1 := self dateClass fromString: '06/02/1973'.  self assert: tmp1 equals: june2nd1973asCharacter  ^selfasFixedTimeZone  ^TimeZone offset: self offset name: 'Fixed Local Time' abbreviation: self abbreviationwaitLastProcessSuspend  self waitProcessSuspend: forkedProcesses lastliterals  | tmp1 tmp2 |  tmp1 := Array new: (tmp2 := self numLiterals - self numberOfReservedLiterals).  1 to: tmp2 do: [:arg1 |  tmp1 at: arg1 put: (self objectAt: arg1 + 1) ].  ^tmp1testRefersToLiteralsReturnsTrueWhenLiteralIsArrayOfLiterals  self assert: (self compiledMethod1 hasLiteralThorough: #(#add #at: #remove))printStringLimitedTo: arg1  ^self printStringLimitedTo: arg1 using: [:arg2 |  self printOn: arg2 ]printYMD: arg1 withLeadingSpace: arg2 on: arg3  | tmp1 tmp2 tmp3 |  arg1 dayMonthYearDo: [:arg4 :arg5 :arg6 |  tmp1 := arg6.        tmp2 := arg5.        tmp3 := arg4 ].  tmp1 negative ifTrue: [ arg3 nextPut: $- ] ifFalse: [ arg2 ifTrue: [ arg3 space ] ].  tmp1 abs printOn: arg3 base: 10 length: 4 padded: true.  arg3 nextPut: $-.  tmp2 printOn: arg3 base: 10 length: 2 padded: true.  arg3 nextPut: $-.  tmp3 printOn: arg3 base: 10 length: 2 padded: truereformatAll  super reformatAll.  self classSide reformatAllgtConstructDebuggerInspectorIn: arg1 for: arg2  ^arg1 custom: ((GTDebuggerInspector new           debugger: arg2;           notifyPaneRemoved: true;           showFirst: [:arg3 |  arg3 custom: (arg2 class variablesBrowserClass new                       debugger: arg2;                       startOn: self;                       restoreSettings;                       yourself) ];           yourself) startOn: self)milliSecond  ^self milliSecondsmidnight  self dayMonthYearDo: [:arg1 :arg2 :arg3 |  ^self class basicYear: arg3 month: arg2 day: arg1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: offset ]to  ^tochangeFromCategorySpecs: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp6 := elementArray asSet.  tmp1 := Array new: arg1 size.  tmp2 := Array new: arg1 size.  tmp5 := 0.  tmp7 := (Array new: 16) writeStream.  1 to: arg1 size do: [:arg2 |  | tmp8 tmp9 |        tmp9 := arg1 at: arg2.        tmp1 at: arg2 put: tmp9 first asSymbol.        tmp8 := tmp9 allButFirst collect: [:arg3 |  arg3 isSymbol ifTrue: [ arg3 ] ifFalse: [ arg3 printString asSymbol ] ].        tmp8 asSortedCollection do: [:arg4 |  (tmp6 remove: arg4 ifAbsent: [ nil ]) notNil ifTrue: [ tmp7 nextPut: arg4.                    tmp5 := tmp5 + 1 ] ].        tmp2 at: arg2 put: tmp5 ].  tmp6 := tmp6 collect: [:arg4 |  Array with: (self categoryOfElement: arg4) with: arg4 ].  tmp7 := tmp7 contents.  categoryArray := tmp1.  (tmp4 := categoryArray asSet) size = categoryArray size ifFalse: [ tmp3 := categoryArray asOrderedCollection.        tmp3 removeAll: categoryArray asSet.        tmp3 do: [:arg5 |  | tmp10 tmp11 |              tmp10 := arg5.              tmp11 := categoryArray indexOf: tmp10.              [ tmp10 := (tmp10 , ' #2') asSymbol.              tmp4 includes: tmp10 ] whileTrue.              tmp4 add: tmp10.              categoryArray at: tmp11 put: tmp10 ] ].  categoryStops := tmp2.  elementArray := tmp7.  tmp6 do: [:arg6 |  self classify: arg6 last under: arg6 first ]testYearMonth  self assert: (DateAndTime year: 2018 month: 9) asDate asString equals: '1 September 2018'testYearMonthDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1970 month: 1 day: 1 hour: 0 minute: 0 second: 0)subclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5  Warning signal: 'Attempt to create ' , arg1 , ' as a subclass of nil.  Possibly a class is being loaded before its superclass.'.  ^Object subclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5testOneMWordAllocation  | tmp1 tmp2 tmp3 |  tmp3 := false.  tmp1 := 1024 * 1024.  tmp2 := [ Array new: tmp1 ] on: OutOfMemory do: [:arg1 |  tmp3 := true ].  self assert: (tmp3 or: [ tmp2 size = tmp1 ])testStringAsNumber  | tmp1 |  tmp1 := '10r-12.3456' asNumber.  self assert: -12.3456 equals: tmp1.  tmp1 := '10r-12.3456e2' asNumber.  self assert: -1234.56 equals: tmp1.  tmp1 := '10r-12.3456d2' asNumber.  self assert: -1234.56 equals: tmp1.  tmp1 := '10r-12.3456q2' asNumber.  self assert: -1234.56 equals: tmp1.  tmp1 := '-12.3456q2' asNumber.  self assert: -1234.56 equals: tmp1.  tmp1 := '12.3456q2' asNumber.  self assert: 1234.56 equals: tmp1printOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     print: selector;     nextPutAll: ' -> ';     print: self receiver;     nextPut: $)testLiteralEqual  self deny: (0.0 literalEqual: 0.0 negated).  self deny: (-0.0 literalEqual: -0.0 negated).  self deny: (0.0 literalEqual: -0.0)T: arg1  | tmp1 |  tmp1 := self getNext: arg1.  ^tmp1 isNotNil ifTrue: [ tmp1 = arg1 or: [ self T: tmp1 ] ] ifFalse: [ false ]testFloatRounded  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := 5000000000000001.  tmp1 := tmp3 asFloat.  tmp2 := (5 asFloat squared squared squared squared timesTwoPower: 15) + 1.  self assert: tmp1 equals: tmp2.  self assert: tmp1 asTrueFraction equals: tmp3.  self assert: tmp1 rounded equals: tmp1 asTrueFraction rounded.  self assert: tmp1 negated rounded equals: tmp1 negated asTrueFraction rounded.  tmp4 := Random new.  10000 timesRepeat: [ tmp1 := tmp4 next * 1.9999e16 + 1.0e12.        self assert: tmp1 rounded equals: tmp1 asTrueFraction rounded.        self assert: tmp1 negated rounded equals: tmp1 negated asTrueFraction rounded ]testAsMonth  self assert: aDateAndTime asMonth equals: (Month year: 1980 month: 'January')bytesCount  < primitive: 62>  self primitiveFailedsourceCode  kind == #EmbeddedSource ifTrue: [ ^data ].  kind == #EmbeddedSourceWide ifTrue: [ ^data ].  kind == #EmbeddedSourceQCompress ifTrue: [ ^data ].  kind == #EmbeddedSourceZip ifTrue: [ ^data ].  ^niltestAsTime  | tmp1 |  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 0 asDuration.  self assert: tmp1 asTime equals: (Time hour: 1 minute: 2 second: 3).  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: 5 hours.  self assert: tmp1 asTime equals: (Time hour: 1 minute: 2 second: 3).  tmp1 := DateAndTime year: 1000 day: 100 hour: 1 minute: 2 second: 3 offset: -5 hours.  self assert: tmp1 asTime equals: (Time hour: 1 minute: 2 second: 3)hasSourcePointer  ^kind == #SourcePointer or: [ kind == #VarLengthSourcePointer ]criticalError  Processor activeProcess terminatetestRemoveNonExistingProtocol  self organization removeCategory: 'non-existent'assert: arg1  < debuggerCompleteToSender>  self assert: arg1 description: 'Assertion failed'ifTrue: arg1  ^arg1 valuegenReturnReceiver  stream nextPut: 120deprecatedMethodName  ^'deprecatedMethod'testIsParagraphSeparator  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isParagraphSeparator: tmp2) equals: (tmp1 isParagraphSeparator: tmp2) ]hasProtocolNamed: arg1  ^self allProtocols anySatisfy: [:arg2 |  arg2 name = arg1 ]sourcePointer  ^self subclassResponsibilityasResultForDrTest  ^DTTestLeaf content: selfasLink  ^ValueLink value: selfbasicIdentityHash  ^selfpostCopy  super postCopy.  self methodDict: self methodDict copyraisedToFraction: arg1  | tmp1 |  tmp1 := (self numerator nthRootTruncated: arg1 denominator) / (self denominator nthRootTruncated: arg1 denominator).  (tmp1 raisedToInteger: arg1 denominator) = self ifTrue: [ ^tmp1 raisedToInteger: arg1 numerator ].  ^super raisedToFraction: arg1simpleTimeoutWithZeroDurationTest  [ self doSomething ] valueWithin: 0 seconds onTimeout: [ self doSomethingElse ]raiseWarningsIfAny: arg1  arg1 ifNotEmpty: [ Warning new           messageText: 'VeryDeepCopy out of sync in some classes. Some classes contain veryDeepCopyWith: or veryDeepInner: methods that are not in sync with their instance variables. Check the exception #tag for a list of them';           tag: arg1;           signal ]ifError: arg1  ^self on: Error do: [:arg2 |  arg1 cull: arg2 description cull: arg2 receiver ]encodeVarLengthSourcePointer  [ data >= 0 ] assert.  encodedData := data = 0 ifTrue: [ #[0] ] ifFalse: [ ByteArray streamContents: [:arg1 |  | tmp1 |              tmp1 := data.              [ tmp1 > 0 ] whileTrue: [ tmp1 > 127 ifTrue: [ arg1 nextPut: 128 + (tmp1 bitAnd: 16r7F) ] ifFalse: [ arg1 nextPut: tmp1 ].                    tmp1 := tmp1 >> 7 ] ] ].  encodedData := encodedData reversed copyWith: self kindAsBytetestIsZero  self assert: 0.0 isZero.  self deny: 0.1 isZerowriteClassVariableNamed: arg1 value: arg2  (self classVariableNamed: arg1) write: arg2byteAt: arg1  arg1 = 1 ifTrue: [ ^self < 0 ifTrue: [ -256 - self bitAnd: 255 ] ifFalse: [ self bitAnd: 255 ] ].  ^self < 0 ifTrue: [ (-256 - self bitShift: -8) + 1 byteAt: arg1 - 1 ] ifFalse: [ (self bitShift: 8 - (arg1 bitShift: 3)) bitAnd: 255 ]> arg1  < primitive: 24>  ^super > arg1forkedProcesses: arg1  forkedProcesses := arg1+ arg1  arg1 isPoint ifTrue: [ ^(x + arg1 x) @ (y + arg1 y) ].  ^arg1 adaptToPoint: self andSend: #+testAsDateAndTime  | tmp1 tmp2 |  #('-1199-01-05T20:33:14.321-05:00' '2002-05-16T17:20:45.1+01:01' '2002-05-16T17:20:45.02+01:01' '2002-05-16T17:20:45.003+01:01' '2002-05-16T17:20:45.0004+01:01' '2002-05-16T17:20:45+01:57' '2002-05-16T17:20:45.000006+01:01' '2002-05-16T17:20:45.0000007+01:01' '2002-05-16T17:20:45.00000008-01:01' '2002-05-16T17:20:45.000000009+01:01' '2002-05-16T17:20:45+00:00' '2002-05-16T17:20:45-02:34' '1997-04-26T01:02:03+01:02:3') do: [:arg1 |  self assert: arg1 asDateAndTime printString equals: arg1 ].  tmp1 := DateAndTime localOffset.  tmp2 := String streamContents: [:arg2 |  arg2 nextPut: (tmp1 positive ifTrue: [ $+ ] ifFalse: [ $- ]).        tmp1 hours abs printOn: arg2 base: 10 length: 2 padded: true.        arg2 nextPut: $:.        tmp1 minutes abs printOn: arg2 base: 10 length: 2 padded: true.        tmp1 seconds = 0 ifFalse: [ arg2                 nextPut: $:;                 print: tmp1 seconds rounded abs ] ].  #('2002-05-16T17:20:45.00005' '2002-05-16T17:20:00' '2002-05-16T17:20:45') do: [:arg1 |  self assert: arg1 asDateAndTime printString equals: arg1 , tmp2 ]showWarning  ^self class showWarningisExpired  ^delaySemaphore isSignaledslotNames  ^self slots collect: [:arg1 |  arg1 name ]finalize  interpretSistaV1Jump  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self method.  tmp4 := 0.  tmp3 := pc.  [ tmp2 := self method at: tmp3.  tmp3 := tmp3 + 1.  tmp2 = 225 ] whileTrue: [ | tmp5 |        tmp5 := self method at: tmp3.        tmp3 := tmp3 + 1.        tmp4 := (tmp4 = 0 and: [ tmp5 > 127 ]) ifTrue: [ tmp5 - 256 ] ifFalse: [ (tmp4 bitShift: 8) + tmp5 ] ].  (tmp2 between: 176 and: 183) ifTrue: [ pc := tmp3.        ^tmp2 - 191 ].  tmp2 = 237 ifTrue: [ tmp2 := tmp1 at: tmp3.        pc := tmp3 + 1.        ^(tmp4 bitShift: 8) + tmp2 ].  ^nilfromSton: arg1  self class isVariable ifTrue: [ arg1 error: 'custom #fromSton: implementation needed for variable/indexable class' ] ifFalse: [ arg1 parseNamedInstVarsFor: self ]nbCall: arg1 options: arg2  < ffiCalloutTranslator>  self deprecated: 'use ffiCall:options: instead'.  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     options: arg2;     function: arg1 library: self ffiLibraryNametruncateTo: arg1  ^Rectangle origin: (origin truncateTo: arg1) corner: (corner truncateTo: arg1)testReplaceFromToWithStartingAt  | tmp1 tmp2 |  tmp1 := LargePositiveInteger new: 20.  1 to: 20 do: [:arg1 |  tmp1 byteAt: arg1 put: arg1 ].  tmp2 := LargePositiveInteger new: 7.  1 to: 7 do: [:arg1 |  tmp2 byteAt: arg1 put: 11 - arg1 ].  tmp1 replaceFrom: 6 to: 10 with: tmp2 startingAt: 2.  (1 to: 5) , (11 to: 20) do: [:arg2 |  | tmp3 |        tmp3 := tmp1 byteAt: arg2.        self assert: arg2 equals: tmp3 ].  6 to: 10 do: [:arg2 |  | tmp3 tmp4 |        tmp3 := tmp1 byteAt: arg2.        tmp4 := tmp2 byteAt: arg2 - 4.        self assert: tmp4 equals: tmp3 ]name  ^namewaitFor: arg1  ^self waitFor: arg1 maxMilliseconds: nilgtSpotterCodePreviewIn: arg1  < spotterPreview: 10>  ^self sourceNode gtSpotterCodePreviewIn: arg1log: arg1  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver log: `@statements1' -> '`@receiver trace: `@statements1'.  self trace: arg1testAsMilliSecond  self     assert: 1 milliSecond equals: (1 / 1000) second;     assert: (1 / 2) milliSecond equals: (1 / 2000) second;     assert: 0.5 milliSecond equals: (1 / 2000) second;     assert: 500 milliSecond equals: (1 / 2) secondweekday  ^self dayOfWeekNamestonOn: arg1  | tmp1 |  tmp1 := self offset isZero ifTrue: [ String new: 11 streamContents: [:arg2 |  self printOn: arg2 format: #(3 2 1 $- 1 1 2).              arg2 nextPut: $Z ] ] ifFalse: [ String new: 32 streamContents: [:arg2 |  self printOn: arg2 format: #(3 2 1 $- 1 1 2).              arg2 nextPut: (self offset positive ifTrue: [ $+ ] ifFalse: [ $- ]).              self offset hours abs printOn: arg2 base: 10 length: 2 padded: true.              arg2 nextPut: $:.              self offset minutes abs printOn: arg2 base: 10 length: 2 padded: true.              self offset seconds = 0 ifFalse: [ arg2                       nextPut: $:;                       print: self offset seconds abs truncated ] ] ].  arg1 writeObject: self listSingleton: tmp1testTimeZone  self assert: aDateAndTime timeZoneName equals: 'Universal Time'.  self assert: aDateAndTime timeZoneAbbreviation equals: 'UTC'weakSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5  ^self weakSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5argumentCount  ^numArgsreceiver  ^self signalerContext receiverabs  ^self class seconds: seconds abs nanoSeconds: nanos absasKeyCombination  | tmp1 |  self asLowercase = self ifTrue: [ ^KMSingleKeyCombination from: self ].  tmp1 := KMSingleKeyCombination from: self asLowercase.  ^KMModifiedKeyCombination modifier: KMModifier shift character: tmp1callChainAnySatisfy: arg1  (arg1 value: self) ifTrue: [ ^true ].  self sender ifNil: [ ^false ].  ^self sender callChainAnySatisfy: arg1writeSlotNamed: arg1 value: arg2  ^(self class slotNamed: arg1) write: arg2 to: selfsetProject: arg1 withInMetacelloConfig: arg2  arg2 setProject: arg1 withBlock: selfisClean  self numCopiedValues > 0 ifTrue: [ ^false ].  self abstractBytecodeMessagesDo: [:arg1 |  (#(pushReceiver pushReceiverVariable: popIntoReceiverVariable: storeIntoReceiverVariable: methodReturnConstant: methodReturnReceiver methodReturnTop) includes: arg1 selector) ifTrue: [ ^false ] ].  ^trueremove: arg1 ifAbsent: arg2  (quiescentProcessLists at: arg1 priority) remove: arg1 ifAbsent: arg2.  ^arg1selectorsToBeIgnored  | tmp1 |  tmp1 := #(#printOn:).  ^super selectorsToBeIgnored , tmp1testEnumerating  | tmp1 |  tmp1 := OrderedCollection new.  0 to: 6 do: [:arg1 |  tmp1 add: ('28 June 1998' asDate addDays: arg1) ].  week datesDo: [:arg2 |  tmp1 remove: arg2 ].  self assertEmpty: tmp1< arg1  arg1 class = self class ifTrue: [ ^self asFraction < arg1 asFraction ].  ^self asFraction < arg1subclass: arg1 uses: arg2 layout: arg3 slots: arg4 classVariablesNames: arg5 poolDictionaries: arg6 category: arg7  ^self classInstaller make: [:arg8 |  arg8           name: arg1;           superclass: self;           slots: arg4;           layoutClass: arg3;           sharedVariablesFromString: arg5;           sharedPools: arg6;           traitComposition: arg2 asTraitComposition;           classTraitComposition: arg2 asTraitComposition classComposition;           category: arg7 ]checkCorrespondanceOf: arg1 and: arg2  | tmp1 tmp2 tmp3 |  tmp1 := Unicode classPool at: arg2.  self aRandomSelectionOfCodePointsDo: [:arg3 |  tmp2 := Unicode perform: arg1 with: (Character codePoint: arg3).        tmp3 := self unicodeCategoryTableLookup: arg3.        tmp2 = (tmp3 = tmp1) ifFalse: [ self assert: tmp2 = (tmp3 = tmp1) description: arg1 asString , 'and category ' , arg2 asString , 'disagree at U+' , arg3 asHexString ] ]testAsNumberWithRadix  | tmp1 |  tmp1 := '10r-22.2s5' asNumber.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: tmp1 scale equals: 5.  self assert: '-22.20000s5' equals: tmp1 printStringprintOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     nextPutAll: self abbreviation;     nextPut: $)includesMethodsAffectedBy: arg1  ^arg1 affectsMethodsDefinedInClass: selftestEqual  self assert: january23rd2004 equals: 'January 23, 2004' asDateeightNeighbors  ^{(self + (1 @ 0)) .   (self + (1 @ 1)) .   (self + (0 @ 1)) .   (self + (-1 @ 1)) .   (self + (-1 @ 0)) .   (self + (-1 @ -1)) .   (self + (0 @ -1)) .   (self + (1 @ -1))}milliseconds  ^self milliSecondstestMinus  self assert: aDateAndTime - aDateAndTime equals: '0:00:00:00' asDuration.  self assert: aDateAndTime - '0:00:00:00' asDuration equals: aDateAndTime.  self assert: aDateAndTime - aDuration equals: (DateAndTime year: 1969 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours)isMeta  ^falsetemporaryVariables  ^self tempNames collect: [:arg1 |  TemporaryVariable new name: arg1 ]nthRootRounded: arg1  | tmp1 |  self = 0 ifTrue: [ ^0 ].  self negative ifTrue: [ arg1 even ifTrue: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ].        ^(self negated nthRootRounded: arg1) negated ].  tmp1 := self nthRootTruncated: arg1.  ^self * 2 > ((tmp1 + 1 raisedTo: arg1) + (tmp1 raisedTo: arg1)) ifTrue: [ tmp1 + 1 ] ifFalse: [ tmp1 ]asJavascript  ^String streamContents: [:arg1 |  self javascriptOn: arg1 ]deprecated: arg1 on: arg2 in: arg3 transformWith: arg4  Deprecation new     context: thisContext sender;     explanation: arg1;     date: arg2;     version: arg3;     rule: arg4;     transformtestFractionPart  self     assert: 2 fractionPart equals: 0;     assert: (1 / 2) fractionPart equals: 1 / 2;     assert: (4 / 3) fractionPart equals: 1 / 3;     assert: 2.0 fractionPart equals: 0.0;     assert: 0.5 fractionPart equals: 0.5;     assert: 2.5 fractionPart equals: 0.5testIsInstanceSide  self assert: Point isInstanceSide.  self deny: Point class isInstanceSidetestNew  self should: [ SmallInteger new ] raise: self defaultTestErrornextPc: arg1  ^pc + (self method encoderClass bytecodeSize: arg1)banLevelCandidates  ^{self} , self package banLevelCandidatesisThisEverCalled: arg1  self error: 'This is indeed called: ' , arg1 printStringtestOnForkErrorReturnsNil  | tmp1 tmp2 |  tmp2 := Semaphore new.  tmp1 := [ 1 / 0 ] on: Exception fork: [ tmp2 signal ].  tmp2 wait.  self assert: tmp1 isNilassertWellMaterializedInto: arg1 in: arg2  arg2 assert: self ~~ arg1.  arg2 assert: self class == arg1 class.  arg2 assert: numArgs = arg1 numArgs.  arg2 assert: startpc = arg1 startpc.  outerContext ifNil: [ self assert: arg1 outerContext isNil ] ifNotNil: [ self isClean ifTrue: [ self assert: (self method isEqualRegardlessTrailerTo: arg1 method).              self assert: arg1 outerContext sender isNil.              self assert: arg1 outerContext arguments isEmpty ] ifFalse: [ outerContext assertWellMaterializedInto: arg1 outerContext in: arg2 ] ]method: arg1  method := arg1executedPC  | tmp1 |  self isDead ifTrue: [ ^self startpc ].  tmp1 := self previousPc ifNil: [ self startpc ].  (self isReturnAt: tmp1) ifTrue: [ tmp1 := tmp1 + 1 ].  [ self isPushLiteralNil: tmp1 ] whileTrue: [ tmp1 := tmp1 + 1 ].  [ self isPushTemp: tmp1 ] whileTrue: [ tmp1 := tmp1 + 1 ].  (self isReturnAt: tmp1) ifTrue: [ tmp1 := tmp1 + 1 ].  ^tmp1hasContext: arg1  ^(self findContextSuchThat: [:arg2 |  arg2 == arg1 ]) notNilbenchFor: arg1  | tmp1 tmp2 tmp3 |  tmp1 := 0.  tmp2 := true.  [ arg1 wait.  tmp2 := false ] forkAt: Processor timingPriority - 1.  tmp3 := Time millisecondClockValue.  [ tmp2 ] whileTrue: [ self value.        tmp1 := tmp1 + 1 ].  ^BenchmarkResult new     iterations: tmp1;     elapsedTime: (Time millisecondsSince: tmp3) milliSeconds;     yourselfgtInspectorActionSpot  < gtInspectorAction>  ^GLMGenericAction new     action: [ GTSpotterMorph new           extent: ((self currentWorld width / 2.4) @ (self currentWorld height / 1.6)) asIntegerPoint;           doLayout;           spotterModel: (GTSpotter on: self);           openCenteredInWorld ];     icon: GLMUIThemeExtraIcons glamorousSearch;     condition: [ | tmp1 |        tmp1 := GTSpotter new newStep origin: self.        self spotterProcessorsFor: tmp1.        tmp1 processors notEmpty ];     title: 'Search'testDateTime  self assert: aDateAndTime equals: (DateAndTime date: '01-01-1901' asDate time: '00:00:00' asTime)<= arg1  < primitive: 545>  ^arg1 adaptToFloat: self andCompare: #<=signal: arg1  | tmp1 |  self checkOwnerProcess.  tmp1 := self queueFor: arg1.  tmp1 isEmpty ifTrue: [ tmp1 := self defaultQueue ].  self signalQueue: tmp1link: arg1 toClassVariable: arg2  arg2 link: arg1genPushInstVar: arg1  arg1 >= 0 ifTrue: [ arg1 < 16 ifTrue: [ stream nextPut: 0 + arg1.              ^self ].        arg1 < 64 ifTrue: [ stream                 nextPut: 128;                 nextPut: arg1.              ^self ] ].  self genPushInstVarLong: arg1transferFor: arg1 from: arg2  ^TransferMorph withPassenger: arg1 from: arg2log  ^self asFloat logtestHighBit  | tmp1 |  self assert: 2r1110 highBit equals: 4.  self assert: 2r0110 highBit equals: 3.  self assert: 2r0000 highBit equals: 0.  tmp1 := (0 to: 1024) asArray , #(16rFDFD 16rFFFF 16r1000 16r1000000 16r1000001 16r70000000 16r7AFAFAFA) , {SmallInteger maxVal .         (SmallInteger maxVal + 1)}.  tmp1 := tmp1 , (tmp1 collect: [:arg1 |  arg1 raisedTo: 20 ]).  tmp1 do: [:arg2 |  | tmp2 tmp3 |        tmp2 := 0.        tmp3 := 1.        [ tmp3 > arg2 ] whileFalse: [ tmp2 := tmp2 + 1.              tmp3 := tmp3 bitShift: 1 ].        self assert: arg2 highBit equals: tmp2 ]testIfFalseIfTrue  self assert: (true ifFalse: [ 'falseAlternativeBlock' ] ifTrue: [ 'trueAlternativeBlock' ]) equals: 'trueAlternativeBlock'var10: arg1  var10 := arg1asSortFunction  self numArgs = 1 ifTrue: [ ^PropertySortFunction property: self ].  self numArgs = 2 ifTrue: [ ^CollatorBlockFunction usingBlock: self ].  self error: 'Cant be converted to sort function. It should has one or two args'copyStack  ^self copy install: suspendedContext copyStackdebug  Processor activeProcess debug: self signalerContext title: self smartDescriptionpenultimateLiteral: arg1  | tmp1 |  (tmp1 := self numLiterals - 1) > 0 ifTrue: [ self literalAt: tmp1 put: arg1 ] ifFalse: [ self error: 'insufficient literals' ]testDoWithWhen  | tmp1 |  tmp1 := 0.  aTimespan do: [:arg1 |  tmp1 := tmp1 + 1 ] with: (Timespan starting: aDate duration: 7 days) when: [:arg1 |  tmp1 < 5 ].  self assert: tmp1 equals: 5pointsTo: arg1  ^falsedays  ^Duration days: selflastLink  self emptyCheck.  ^lastLinkgtInspectorCommentIn: arg1  < gtInspectorPresentationOrder: 20>  arg1 text     title: 'Comment';     display: [ self comment ];     act: [:arg2 |  self comment: arg2 text stamp: Author changeStamp ] icon: GLMUIThemeExtraIcons glamorousAccept on: $s entitled: 'Accept'seasidePossibleCauses  ^#()testString  ^'This is only a test.'schedulerSignalWaitingProcess  beingWaitedOn := false.  monitor signalLock: delaySemaphore inQueue: queuestonContainSubObjects  ^falsetestIsSurrogateOther  self checkCorrespondanceOf: #isSurrogateOther: and: #CstestPointersToCycle  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Object new.  tmp2 := {tmp1 .   tmp1}.  tmp3 := {tmp1 .   tmp2}.  tmp4 := tmp1 pointersTo asArray.  self assert: tmp4 size equals: 2.  self assert: (tmp4 includesAll: {tmp2 .               tmp3})bitAnd: arg1  < primitive: 14>  self >= 0 ifTrue: [ ^arg1 bitAnd: self ].  ^(self bitInvert bitOr: arg1 bitInvert) bitInvertdoublePassOuterTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselfputSource: arg1 class: arg2 category: arg3 withStamp: arg4 priorMethod: arg5  ^self putSource: arg1 withPreamble: [:arg6 |  arg2 printCategoryChunk: arg3 on: arg6 withStamp: arg4 priorMethod: arg5.        arg6 cr ]isMetaclassOfClassOrNil  ^self instanceSide ifNil: [ true ] ifNotNil: [:arg1 |  arg1 == Class ]systemNavigation  ^SystemNavigation newasDate  ^selfcompressSourceCode: arg1  | tmp1 |  self clear.  kind := #EmbeddedSourceQCompress.  data := arg1 asString.  self encode.  tmp1 := encodedData.  kind := #EmbeddedSourceZip.  self encode.  encodedData size > tmp1 size ifTrue: [ encodedData := tmp1.        kind := #EmbeddedSourceQCompress.        size := encodedData size ]testFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1901-01-01T00:00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1901-01-01T00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1901-01-01T00:00:00+00:00')deprecatedMethodName  ^self contextOfDeprecatedMethod method printStringfileOutMethod: arg1  | tmp1 |  tmp1 := (String new: 1000) writeStream.  self fileOutMethod: arg1 on: tmp1.  CodeExporter writeSourceCodeFrom: tmp1 baseName: self name , '-' , (arg1 copyReplaceAll: ':' with: '') isSt: truepragmas  | tmp1 |  ^(tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 pragmas ] ifFalse: [ #() ]testAsTime  self assert: aDateAndTime asTime equals: Time midnightprimitiveResume  < primitive: 87>  self primitiveFailedtearDown  Week startDay: restoredStartDay.  week := nil.  super tearDownhasSelector: arg1 specialSelectorIndex: arg2  (self hasLiteralThorough: arg1) ifTrue: [ ^true ].  ^arg2 ifNil: [ false ] ifNotNil: [ self scanFor: self encoderClass firstSpecialSelectorByte + arg2 ]hour  ^self hourstestSizeInMemoryNormalClasses  self assert: Date today sizeInMemory equals: (self align64Bits: 2 * Smalltalk wordSize + self headerSize).  self assert: TestCase new sizeInMemory equals: (self align64Bits: 2 * Smalltalk wordSize + self headerSize)parseTreeFor: arg1  ^(self compiledMethodAt: arg1) parseTreetestFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1970-01-01T00:00:00+00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1970-01-01T00:00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1970-01-01T00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1970-01-01T00:00:00+00:00')bitAt: arg1 put: arg2  | tmp1 |  tmp1 := self bitAt: arg1.  tmp1 = arg2 ifTrue: [ ^self ].  0 = arg2 ifTrue: [ ^self bitAnd: (1 bitShift: arg1 - 1) bitInvert ].  1 = arg2 ifTrue: [ ^self bitOr: (1 bitShift: arg1 - 1) ].  self error: 'bit value should be 0 or 1'< arg1  ^self subclassResponsibilitytestNoArguments  | tmp1 |  tmp1 := WeakMessageSend receiver: true selector: #yourself.  self assert: tmp1 valueprintOn: arg1 base: arg2 showRadix: arg3  | tmp1 tmp2 |  tmp1 := self printStringRadix: arg2.  arg3 ifTrue: [ ^arg1 nextPutAll: tmp1 ].  tmp2 := (tmp1 indexOf: $r ifAbsent: [ self error: 'radix indicator not found.' ]) + 1.  self negative ifTrue: [ arg1 nextPut: $- ].  arg1 nextPutAll: (tmp1 copyFrom: tmp2 to: tmp1 size)floor  isUsed  ^self hasSubclasses ifFalse: [ super isUsed ] ifTrue: [ true ]testOrdersMetaClassAfterItsClassInstance  | tmp1 |  tmp1 := Class superclassOrder: (OrderedCollection with: Boolean class with: True with: Boolean with: True class).  self assert: (tmp1 indexOf: Boolean) < (tmp1 indexOf: Boolean class).  self assert: (tmp1 indexOf: True) < (tmp1 indexOf: True class).  self assert: (tmp1 indexOf: Boolean class) < (tmp1 indexOf: True class).  self assert: (tmp1 indexOf: Boolean) < (tmp1 indexOf: True)testReadSlot  self assert: (5 @ 3 readSlot: (Point slotNamed: #x)) equals: 5jump  | tmp1 |  thisContext sender push: nil.  stackp = 0 ifTrue: [ self stepUntilSomethingOnStack ].  stackp = 0 ifTrue: [ self push: nil ].  tmp1 := self pop.  thisContext privSender: self.  ^tmp1sourcePointer: arg1  self clear.  data := arg1.  kind := (arg1 between: 16r1000000 and: 16r4FFFFFF) ifTrue: [ #SourcePointer ] ifFalse: [ #VarLengthSourcePointer ]bench: arg1  | tmp1 |  self assert: (arg1 inheritsFrom: DelayNullScheduler).  tmp1 := Delay delaySchedulerClass.  [ Delay delaySchedulerClass: arg1.  self bench ] ensure: [ Delay delaySchedulerClass: tmp1 ]testSubclassArithmetic  | tmp1 |  tmp1 := {Year currentYear .   Month current .   (Week starting: DateAndTime now) .   Date today .   (Timespan starting: DateAndTime now duration: 1 hour)}.  tmp1 do: [:arg1 |  self assert: arg1 + aDay - arg1 equals: aDay.        self assert: arg1 - aDay - arg1 equals: aDay negated.        tmp1 do: [:arg2 |  self assert: (arg1 intersection: arg2) equals: (arg2 intersection: arg1) ] ].  self assert: (tmp1 first intersection: tmp1 second) equals: tmp1 second.  self assert: (tmp1 first intersection: tmp1 fourth) equals: tmp1 fourth.  self assert: (tmp1 second intersection: tmp1 fourth) equals: tmp1 fourthisPrimitiveError  ^falsetestAsTime  self assert: aTime asTime equals: aTimetestRuleDoesNotFailIfNoNewExternalDependency  | tmp1 tmp2 |  tmp1 := PharoBootstrapRule new.  tmp1 class classVarNamed: 'DependencyChecker' put: PharoBootstrapAnalyzerStubWithNoNewDependency.  tmp2 := tmp1 check: (RPackage named: #Kernel).  self assertEmpty: tmp2testAsDate  self assert: aTime asDate equals: Date currentstoreOn: arg1  arg1     nextPut: $(;     nextPutAll: self class name;     nextPutAll: ' selector: ';     store: selector;     nextPutAll: ' arguments: ';     store: args;     nextPut: $)willJump  ^self method encoderClass isJumpAt: pc in: self methodhandleFailingBasicNew  < primitive: 70>  Smalltalk garbageCollect < 1048576 ifTrue: [ Smalltalk growMemoryByAtLeast: 1048576 ].  ^self handleFailingFailingBasicNewremoveKey: arg1 ifAbsent: arg2  | tmp1 tmp2 |  tmp1 := self copy.  tmp2 := tmp1 removeDangerouslyKey: arg1 ifAbsent: [ ^arg2 value ].  self copyFrom: tmp1.  arg1 flushCache.  ^tmp2testIncludesKey  self assert: (ChronologyConstants includesKey: #DayNames).  self deny: (ChronologyConstants includesKey: #DependentsFields)waitForUserSignalled: arg1 orExpired: arg2  self subclassResponsibility/ arg1  < primitive: 30>  ^super / arg1slidingLeftRightRaisedTo: arg1 modulo: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp3 := arg1 highBit.  tmp4 := (tmp3 highBit - 1 >> 1 min: 16) max: 1.  tmp6 := Array new: 1 << tmp4.  tmp6 at: 1 put: (tmp1 := self).  tmp7 := self * self \\ arg2.  2 to: tmp6 size do: [:arg3 |  tmp1 := tmp6 at: arg3 put: tmp1 * tmp7 \\ arg2 ].  tmp1 := 1.  [ tmp3 > 0 ] whileTrue: [ tmp1 := tmp1 * tmp1 \\ arg2.        (arg1 bitAt: tmp3) = 0 ifFalse: [ tmp2 := tmp3 - tmp4 max: 1.              [ tmp2 < tmp3 and: [ (arg1 bitAt: tmp2) = 0 ] ] whileTrue: [ tmp2 := tmp2 + 1 ].              tmp5 := 0.              [ tmp3 > tmp2 ] whileTrue: [ tmp1 := tmp1 * tmp1 \\ arg2.                    tmp5 := (tmp5 << 1) + (arg1 bitAt: tmp3).                    tmp3 := tmp3 - 1 ].              tmp1 := tmp1 * (tmp6 at: tmp5 + 1) \\ arg2 ].        tmp3 := tmp3 - 1 ].  ^tmp1printShowingDecimalPlaces: arg1  ^self asTrueFraction printShowingDecimalPlaces: arg1allMethodSelectors  ^elementArray sortedclassForTicker  ^DelayMillisecondTickerSimulationnewValue: arg1  newValue := arg1isInheritable  ^self class isInheritabletestSignalFromHandlerActionTest  self assertSuccess: (ExceptionTester new runTest: #signalFromHandlerActionTest)crossProduct: arg1  ^x * arg1 y - (y * arg1 x)immediateSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 package: arg5  ^self immediateSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: '' package: arg5testRaisedToInteger  self     assert: (2 raisedToInteger: 0) equals: 1;     assert: (2 raisedToInteger: 1) equals: 2;     assert: (2 raisedToInteger: 4) equals: 16;     assert: (0 raisedToInteger: 0) equals: 1;     assert: (0 raisedToInteger: 2) equals: 0;     assert: (2 raisedToInteger: -1) equals: 1 / 2;     assert: (2 raisedToInteger: -4) equals: 1 / 16.  self     assert: (-3 raisedTo: 0) equals: 1;     assert: (-3 raisedTo: 1) equals: -3;     assert: (-3 raisedTo: 2) equals: 9;     assert: (-3 raisedTo: 3) equals: -27;     assert: (-3 raisedTo: -2) equals: 1 / 9;     assert: (-3 raisedTo: -3) equals: -1 / 27.  self should: [ 0 raisedTo: -1 ] raise: ZeroDividetestAllSelectorsAboveUntil  | tmp1 |  tmp1 := Date allSelectorsAboveUntil: Object.  self deny: (tmp1 includes: #mmddyyyy).  self deny: (tmp1 includes: #weekday).  self assert: (tmp1 includes: #at:).  self deny: (tmp1 includes: #cannotInterpret:)setDescriptionInMetacelloConfig: arg1  arg1 setDescriptionWithBlock: selfpropertyAt: arg1 ifAbsent: arg2  ^arg2 valueisBits  ^self instSpec >= 7testWholeMicroseconds  self assert: 0 seconds wholeMicroseconds equals: 0.  self assert: 1 second wholeMicroseconds equals: 0.  self assert: 1002003004 nanoSeconds wholeMicroseconds equals: 3addMonths: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self year + ((arg1 + self monthIndex - 1) // 12).  tmp2 := (self monthIndex + arg1 - 1) \\ 12 + 1.  tmp3 := Month daysInMonth: tmp2 forYear: tmp1.  tmp4 := self dayOfMonth min: tmp3.  ^Date year: tmp1 month: tmp2 day: tmp4testMinusADateAndTime  self assert: aTimespan - dec31 equals: aDay.  self assert: aDisjointTimespan - jan01 equals: aWeeksharedPoolNames  ^self sharedPools collect: [:arg1 |  arg1 isObsolete ifTrue: [ arg1 name ] ifFalse: [ self environment keyAtIdentityValue: arg1 ] ]onPreviousMonth  ^self addMonths: -1containsHalt  ^self sendsAnySelectorOf: #(halt halt: haltIf: haltIfNil haltOnCount: haltOnce)pushActiveProcess  self push: Processor activeProcesstestAsMinute  | tmp1 tmp2 tmp3 |  tmp1 := Duration seconds: 60.  tmp2 := Duration seconds: 30.  tmp3 := Duration seconds: 15.  self     assert: 1 minute equals: tmp1;     assert: 1.0 minute equals: tmp1;     assert: 0.5 minute equals: tmp2;     assert: (1 / 2) minute equals: tmp2;     assert: (1 / 4) minute equals: tmp3.  self assert: 0.4 minute + 0.6 minute equals: 1 minutetestDayOfWeek  | tmp1 tmp2 |  tmp2 := self dateClass dayOfWeek: #Sunday.  self assert: tmp2 equals: 1.  tmp1 := #(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday).  tmp1 doWithIndex: [:arg1 :arg2 |  | tmp3 |        tmp3 := self dateClass dayOfWeek: arg1.        self assert: tmp3 equals: arg2 ]testDaysInMonth  self assert: aTimespan daysInMonth equals: 31add: arg1 before: arg2  | tmp1 |  tmp1 := self linkAt: (self indexOf: arg2).  ^self add: arg1 beforeLink: tmp1tearDown  PharoBootstrapRule classVarNamed: 'DependencyChecker' put: checkerBackup.  super tearDowngtInspectorBytesIn: arg1  < gtInspectorPresentationOrder: 30>  isSpecial  ^self class specialCharacters includes: selftestDayOfYear  self assert: aTimespan dayOfYear equals: 1shallowCopy  ^selfasDuration  ^Duration seconds: self asIntegerclassToBeTested  ^DateAndTime<= arg1  arg1 isFraction ifTrue: [ ^numerator * arg1 denominator <= (arg1 numerator * denominator) ].  ^arg1 adaptToFraction: self andCompare: #<=perform: arg1 with: arg2 with: arg3  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: arg1 withArguments: (Array with: arg2 with: arg3)testReadFromSpaceBeforeOffset  self assert: '2012-07-26 16:38:48 +0200' asDateAndTime offset equals: 2 hour.  self assert: '2012-07-26 16:38:48 +02' asDateAndTime offset equals: 2 hourbeReadOnlyObject  ^self setIsReadOnlyObject: trueisSpecialLiteralForPush: arg1  ^arg1 == false or: [ arg1 == true or: [ arg1 == nil or: [ (arg1 isInteger and: [ arg1 between: -32768 and: 32767 ]) or: [ arg1 isCharacter and: [ arg1 asInteger between: 0 and: 65535 ] ] ] ] ]treeNodeTail  ^nilcontrol  ^KMModifier ctrl + selfallAreasOutsideList: arg1 startingAt: arg2 do: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := arg2.  [ tmp4 <= arg1 size ifFalse: [ ^arg3 value: self ].  tmp3 := arg1 at: tmp4.  origin <= tmp3 corner and: [ tmp3 origin <= corner ] ] whileFalse: [ tmp4 := tmp4 + 1 ].  tmp3 origin y > origin y ifTrue: [ tmp5 := origin corner: corner x @ (tmp1 := tmp3 origin y).        tmp5 allAreasOutsideList: arg1 startingAt: tmp4 + 1 do: arg3 ] ifFalse: [ tmp1 := origin y ].  tmp3 corner y < corner y ifTrue: [ tmp5 := origin x @ (tmp2 := tmp3 corner y) corner: corner.        tmp5 allAreasOutsideList: arg1 startingAt: tmp4 + 1 do: arg3 ] ifFalse: [ tmp2 := corner y ].  tmp3 origin x > origin x ifTrue: [ tmp5 := origin x @ tmp1 corner: tmp3 origin x @ tmp2.        tmp5 allAreasOutsideList: arg1 startingAt: tmp4 + 1 do: arg3 ].  tmp3 corner x < corner x ifTrue: [ tmp5 := tmp3 corner x @ tmp1 corner: corner x @ tmp2.        tmp5 allAreasOutsideList: arg1 startingAt: tmp4 + 1 do: arg3 ]metaLinkOptions  ^{(#penultimateLiteral -> #(+ optionCompileOnLinkInstallation)) .   (#selector -> #(+ optionCompileOnLinkInstallation)) .   (#objectAt: -> #(+ optionCompileOnLinkInstallation)) .   (#header -> #(+ optionCompileOnLinkInstallation)) .   (#numLiterals -> #(+ optionCompileOnLinkInstallation)) .   (#literalAt: -> #(+ optionCompileOnLinkInstallation)) .   (#metaLinkOptions -> #(+ optionCompileOnLinkInstallation))}testSetIsReadOnlySuccessProxy  self maybeReadOnlyObjects do: [:arg1 |  self testProxyObject: arg1 initialState: false tuples: #(#(true false true) #(false true false)) ]numCopiedValues  < primitive: 62>  ^self basicSizeat: arg1  < primitive: 210>  arg1 isInteger ifTrue: [ self errorSubscriptBounds: arg1 ].  arg1 isNumber ifTrue: [ ^self at: arg1 asInteger ] ifFalse: [ self errorNonIntegerIndex ]defaultAction  UnhandledError signalForException: selftestDaysInMonth  self assert: aDateAndTime daysInMonth equals: 31wantsVisualFeedback  ^true- arg1  arg1 isPoint ifTrue: [ ^(x - arg1 x) @ (y - arg1 y) ].  ^arg1 adaptToPoint: self andSend: #-methodsWritingSlot: arg1  ^self methods select: [:arg2 |  arg2 writesSlot: arg1 ]asMargin  ^Margin fromPoint: selfdoSomething  self log: self doSomethingStringtestNew  | tmp1 tmp2 |  tmp1 := self dateClass new.  tmp2 := self epoch.  tmp1 offset negative ifTrue: [ tmp2 := tmp2 - 1 day ].  self assert: tmp1 equals: tmp2printDetails: arg1  | tmp1 tmp2 |  self printOn: arg1.  arg1 cr.  arg1     tab;     nextPutAll: 'Receiver: '.  tmp1 := '<<error during printing>>'.  arg1 nextPutAll: ([ receiver printStringLimitedTo: 90 ] ifError: [ tmp1 ]).  arg1     cr;     tab;     nextPutAll: 'Arguments and temporary variables: ';     cr.  tmp2 := [ (self tempsAndValuesLimitedTo: 80 indent: 2) padRightTo: 1 with: $x ] ifError: [ tmp1 ].  arg1 nextPutAll: tmp2 allButLast.  arg1     cr;     tab;     nextPutAll: 'Receiver''s instance variables: ';     cr.  receiver class allInstVarNames isEmpty ifTrue: [ arg1 nextPutAll: ([ receiver printStringLimitedTo: 90 ] ifError: [ tmp1 ]) ] ifFalse: [ [ receiver longPrintOn: arg1 limitedTo: 80 indent: 2 ] ifError: [ arg1 nextPutAll: tmp1 ] ].  arg1 crisCharacter  ^trueaddInstVarNamed: arg1  arg1 substrings do: [:arg2 |  self addSlot: (InstanceVariableSlot named: arg2 asSymbol) ]testRaisedTo  self should: [ -1.23 raisedTo: 1 / 4 ] raise: ArithmeticErrorsmartDescription  message ifNil: [ ^self description ].  message lookupClass == UndefinedObject ifTrue: [ ^message selector printString , ' was sent to nil' ].  ^'Instance of ' , message lookupClass printString , ' did not understand ' , message selector printStringtestBehaviornewnewShouldNotCrash  Behavior new newgtInspectorDetailsIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 table     title: 'Details';     display: [ {('iso' -> self printString) .         ('utc' -> self asUTC) .         ('year' -> self year) .         ('month' -> self monthIndex) .         ('month name' -> self monthName) .         ('day of month' -> self dayOfMonth) .         ('day of week' -> self dayOfWeekName) .         ('day of year' -> self dayOfYear) .         ('hours' -> self hours) .         ('minutes' -> self minutes) .         ('seconds' -> self seconds) .         ('nanoseconds' -> self nanoSecond) .         ('meridian' -> self meridianAbbreviation) .         ('offset' -> self offset) .         ('date' -> self asDate) .         ('time' -> self asTime)} ];     column: 'Key' evaluated: #key;     column: 'Value' evaluated: #value;     send: #valueprivHandlerContext: arg1  handlerContext := arg1findNextHandlerOrSignalingContext  < primitive: 197>  | tmp1 |  tmp1 := self.  [ tmp1 isHandlerOrSignalingContext ifTrue: [ ^tmp1 ].  (tmp1 := tmp1 sender) == nil ] whileFalse.  ^niltestSqrt  self should: [ (SmallInteger minVal - 1) sqrt ] raise: DomainErrorvalueWithEnoughArguments: arg1  | tmp1 tmp2 |  tmp2 := self receiver.  (self ensureReceiverAndArguments: tmp2) ifFalse: [ ^nil ].  tmp1 := Array new: selector numArgs.  tmp1 replaceFrom: 1 to: (arguments size min: tmp1 size) with: arguments startingAt: 1.  tmp1 size > arguments size ifTrue: [ tmp1 replaceFrom: arguments size + 1 to: (arguments size + arg1 size min: tmp1 size) with: arg1 startingAt: 1 ].  ^tmp2 perform: selector withArguments: tmp1tempNamed: arg1  | tmp1 tmp2 |  tmp1 := self sourceNodeExecuted scope.  tmp2 := tmp1 lookupVar: arg1.  ^tmp2 readFromContext: self scope: tmp1temporaryVariableNamed: arg1  (self hasTemporaryVariableNamed: arg1) ifFalse: [ ^nil ].  ^TemporaryVariable name: arg1 method: selfdepthBelow: arg1  | tmp1 tmp2 |  tmp1 := self.  tmp2 := 0.  [ tmp1 == arg1 or: [ tmp1 == nil ] ] whileFalse: [ tmp1 := tmp1 sender.        tmp2 := tmp2 + 1 ].  ^tmp2testTwoComplementRightShift  | tmp1 tmp2 |  tmp2 := 2 << 16.  tmp1 := 2 << 32.  self assert: (tmp2 negated bitShift: -1) ~= ((tmp2 + 1) negated bitShift: -1) identicalTo: (tmp1 negated bitShift: -1) ~= ((tmp1 + 1) negated bitShift: -1).  self assert: (tmp2 bitShift: -1) ~= (tmp2 + 1 bitShift: -1) identicalTo: (tmp1 bitShift: -1) ~= (tmp1 + 1 bitShift: -1)allClassVarNames  ^self superclass ifNil: [ self classVarNames ] ifNotNil: [:arg1 |  arg1 allClassVarNames , self classVarNames ]firstDayOfMonth  ^start firstDayOfMonthshallowCopy  ^selfcopyAll: arg1 from: arg2  self copyAll: arg1 from: arg2 classified: niljsonOn: arg1  arg1 number: selfouterContext  ^closureOrNil ifNotNil: [ closureOrNil outerContext ]from: arg1  from := arg1abs  ^self negatedhaltFromCount: arg1  < debuggerCompleteToSender>  Halt fromCount: arg1release  self releaseTo: nilembeddSourceInTrailer  self trailer hasSourcePointer ifTrue: [ ^self becomeForward: (self copyWithSource: self sourceCode) ]ifFalse: arg1  ^nilforkAt: arg1 named: arg2  | tmp1 |  tmp1 := self newProcess.  tmp1 priority: arg1.  tmp1 name: arg2.  ^tmp1 resumeto: arg1  ^self asDateAndTime to: arg1isColorForm  ^falsemethodNamed: arg1  ^self methodDict at: arg1testAsNumberNegatedWithoutDecimalPoint2  | tmp1 |  tmp1 := '-123s2' asNumber.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: tmp1 scale equals: 2.  self assert: '-123.00s2' equals: tmp1 printStringasMinimalRepresentation  ^selfprintBinaryLiteralOn: arg1  | tmp1 tmp2 tmp3 |  tmp1 := (self basicAt: 1) bitShift: -31.  tmp2 := ((self basicAt: 1) bitShift: -20) bitAnd: 2r11111111111.  tmp3 := (((self basicAt: 1) bitAnd: 2r11111111111111111111) bitShift: 32) bitOr: (self basicAt: 2).  tmp2 = 2047 ifTrue: [ tmp3 = 0 ifTrue: [ arg1 nextPutAll: 'Float infinity'.              tmp1 = 1 ifTrue: [ arg1 nextPutAll: ' negated' ] ] ifFalse: [ arg1 nextPutAll: 'Float nan' ].        ^self ].  tmp1 = 1 ifTrue: [ arg1 nextPut: $- ].  tmp2 = 0 ifTrue: [ tmp3 = 0 ifTrue: [ arg1 nextPutAll: '0.0' ] ifFalse: [ arg1 nextPutAll: '2r0.'.              tmp3 printOn: arg1 base: 2 length: Float precision - 1 padded: true.              arg1 nextPutAll: 'e-1022' ].        ^self ].  arg1 nextPutAll: '2r1.'.  tmp3 printOn: arg1 base: 2 length: Float precision - 1 padded: true.  arg1 nextPut: $e.  tmp2 - 1023 printOn: arg1 base: 10deprecatedMethod2  self deprecated: 'example of a deprecated method' on: 'date' in: 'someversion'sendsToSuper  self localSendsToSuper ifTrue: [ ^true ].  ^self innerCompiledBlocksAnySatisfy: [:arg1 |  arg1 sendsToSuper ]testAsYear  self assert: aDateAndTime asYear equals: (Year starting: '01-01-1901' asDate)priority  ^prioritygtInspectorHash  ^self identityHashclassToBeTested  ^YeartestdaysInMonth  self assert: ((Year year: 2018) daysInMonth: 1) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 2) equals: 28.  self assert: ((Year year: 2016) daysInMonth: 2) equals: 29.  self assert: ((Year year: 2018) daysInMonth: 3) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 4) equals: 30.  self assert: ((Year year: 2018) daysInMonth: 5) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 6) equals: 30.  self assert: ((Year year: 2018) daysInMonth: 7) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 8) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 9) equals: 30.  self assert: ((Year year: 2018) daysInMonth: 10) equals: 31.  self assert: ((Year year: 2018) daysInMonth: 11) equals: 30.  self assert: ((Year year: 2018) daysInMonth: 12) equals: 31add: arg1  ^exceptions add: arg1primSignal: arg1 atMilliseconds: arg2  (arg1 isKindOf: Semaphore) ifTrue: [ vmSimTheTimerSemaphore := arg1.        vmSimNextWakeupTick := arg2 ].  arg1 = nil ifTrue: [ vmSimTheTimerSemaphore := nil.        vmSimNextWakeupTick := 0 ]testSetIsReadOnlyImmediateProxy  self alwaysReadOnlyObjects do: [:arg1 |  self testProxyObject: arg1 initialState: true tuples: #(#(true true true) #(false true true)) ]setSelector: arg1 arguments: arg2  selector := arg1.  args := arg2shortPrintString  self isEmpty ifTrue: [ ^self printString ].  ^String streamContents: [:arg1 |  self printFrequenceOn: arg1 ]startTimerEventLoop  isDisabledSelector: arg1  ^self classAndMethodFor: arg1 do: [:arg2 :arg3 |  arg3 isDisabled ] ifAbsent: [ false ]fractionPart  < primitive: 552>  ^self - self truncated asFloatisTestCase  ^falsemethod: arg1  | tmp1 |  data := size := nil.  method := arg1.  tmp1 := method at: method size.  kind := self class trailerKinds at: 1 + (tmp1 >> 2).  kind == #SourcePointer ifTrue: [ ^self decodeSourcePointer ].  kind == #VarLengthSourcePointer ifTrue: [ ^self decodeVarLengthSourcePointer ].  kind == #EmbeddedSource ifTrue: [ ^self decodeEmbeddedSource ].  kind == #NoTrailer ifTrue: [ ^self decodeNoTrailer ].  self perform: ('decode' , kind) asSymboltestMethods  self assert: Object methods equals: Object methodDict valuesfieldIndex: arg1  fieldIndex := arg1tan  ^self asFloat tantestFractionAsFloat  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := Random new seed: 1234567.  tmp2 := (2 raisedTo: 54) - 1.  200 timesRepeat: [ tmp3 := ((tmp1 nextInt: tmp2) * (tmp1 nextInt: tmp2) + 1) / ((tmp1 nextInt: tmp2) * (tmp1 nextInt: tmp2) + 1).        tmp4 := (tmp3 - tmp3 asFloat asTrueFraction) * tmp3 reciprocal * (1 bitShift: 52).        self assert: tmp4 < (1 / 2) ].  tmp5 := #(16r10000000000000 16r1FFFFFFFFFFFFF 1 2 16r20000000000000 16r20000000000001 16r3FFFFFFFFFFFFF 16r3FFFFFFFFFFFFE 16r3FFFFFFFFFFFFD).  tmp5 do: [:arg1 |  tmp5 do: [:arg2 |  tmp3 := Fraction numerator: arg1 denominator: arg2.              tmp4 := (tmp3 - tmp3 asFloat asTrueFraction) * tmp3 reciprocal * (1 bitShift: 52).              self assert: tmp4 <= (1 / 2) ] ]isInsideCircle: arg1 with: arg2 with: arg3  ^(arg1 dotProduct: arg1) * (arg2 triangleArea: arg3 with: self) - ((arg2 dotProduct: arg2) * (arg1 triangleArea: arg3 with: self)) + ((arg3 dotProduct: arg3) * (arg1 triangleArea: arg2 with: self)) - ((self dotProduct: self) * (arg1 triangleArea: arg2 with: arg3)) > 0.0value: arg1 value: arg2  < primitive: 207>  | tmp1 |  numArgs ~= 2 ifTrue: [ self numArgsError: 2 ].  false ifTrue: [ tmp1 := self asContextWithSender: thisContext sender.        tmp1 at: 1 put: arg1.        tmp1 at: 2 put: arg2.        thisContext privSender: tmp1 ] ifFalse: [ self primitiveFailed ]scheduleAtTimingPriority  readyToSchedule signal.  super scheduleAtTimingPrioritybasicAddSelector: arg1 withMethod: arg2  self deprecated: 'Please use #addSelectorSilently:withMethod: instead' transformWith: '`@receiver basicAddSelector: `@statements1 withMethod: `@statements2' -> '`@receiver addSelectorSilently: `@statements1 withMethod: `@statements2'.  self addSelectorSilently: arg1 withMethod: arg2unplug  classPool: arg1  classPool := arg1testComparing  | tmp1 tmp2 tmp3 |  tmp1 := Duration seconds: 10 nanoSeconds: 1.  tmp2 := Duration seconds: 10 nanoSeconds: 1.  tmp3 := Duration seconds: 10 nanoSeconds: 2.  self     assert: tmp1 equals: tmp1;     assert: tmp1 equals: tmp2;     deny: tmp1 equals: tmp3;     assert: tmp1 < tmp3testAbs  self assert: aDuration abs equals: aDuration.  self assert: (Duration nanoSeconds: -5) abs equals: (Duration nanoSeconds: 5)valueWithPossibleArgs: arg1  ^numArgs = 0 ifTrue: [ self value ] ifFalse: [ self valueWithArguments: (numArgs = arg1 size ifTrue: [ arg1 ] ifFalse: [ numArgs > arg1 size ifTrue: [ arg1 , (Array new: numArgs - arg1 size) ] ifFalse: [ arg1 copyFrom: 1 to: numArgs ] ]) ]includes: arg1  ^(arg1 isKindOf: Timespan) ifTrue: [ (self includes: arg1 start) and: [ self includes: arg1 end ] ] ifFalse: [ arg1 asDateAndTime between: start and: self end ]bitInvert32  ^self bitXor: 16rFFFFFFFFresume: arg1 through: arg2  | tmp1 tmp2 |  self isDead ifTrue: [ self cannotReturn: arg1 to: self ].  tmp1 := arg2.  [ tmp1 isNil ] whileFalse: [ tmp1 unwindComplete ifNil: [ tmp1 unwindComplete: true.              tmp2 := tmp1 unwindBlock.              thisContext terminateTo: tmp1.              tmp2 value ].        tmp1 := tmp1 findNextUnwindContextUpTo: self ].  thisContext terminateTo: self.  ^arg1testWriteSlotValue  | tmp1 |  tmp1 := 5 @ 6.  self assert: (tmp1 writeSlot: (Point slotNamed: #x) value: 7) equals: 7.  self assert: tmp1 equals: 7 @ 6minute  ^(seconds rem: SecondsInHour) quo: SecondsInMinutedegreesToRadians  ^self asFloat degreesToRadianstestEpoch  self assert: aDateAndTime equals: '1970-01-01T00:00:00+00:00' asDateAndTimeadoptInstance: arg1 from: arg2  thisClass class == self ifTrue: [ ^self error: 'Metaclasses have only one instance' ].  arg2 isMeta ifFalse: [ ^self error: 'Argument must be Metaclass' ].  arg1 class == arg2 ifFalse: [ ^self error: 'Not the class of argument' ].  ^thisClass := self newInstanceFrom: arg1 variable: self isVariable size: self instSize map: (self instVarMappingFrom: arg2)stonPostReferenceResolution  = arg1  ^self species = arg1 species ifTrue: [ x = arg1 x and: [ y = arg1 y ] ] ifFalse: [ false ]storeOn: arg1  self < 0 ifTrue: [ arg1 space ].  super storeOn: arg1testReadFromWithNanos  #('4:02:47.5 am' '4:02:55.521 pm') do: [:arg1 |  | tmp1 |        tmp1 := self timeClass readFrom: arg1 readStream.        self assert: tmp1 printString equals: arg1 ]instanceVariableWriteNodes  ^self methods flatCollect: [:arg1 |  arg1 instanceVariableWriteNodes ]bitXor: arg1  < primitive: 16>  self >= 0 ifTrue: [ ^arg1 bitXor: self ].  ^arg1 < 0 ifTrue: [ self bitInvert bitXor: arg1 bitInvert ] ifFalse: [ (self bitInvert bitXor: arg1) bitInvert ]recompile  self compileAllatEnd  ^pc > self method endPCisLocalMethodsProtocol: arg1  arg1 methodSelectors ifEmpty: [ ^true ].  ^arg1 methodSelectors anySatisfy: [:arg2 |  self isLocalSelector: arg2 ]years  ^Duration years: selftestAsBit  self assert: false asBit equals: 0classInstaller  ^Smalltalk classInstallerremoveProtocol: arg1  arg1 canBeRemoved ifFalse: [ arg1 isVirtualProtocol ifTrue: [ ^self ].        ProtocolRemovalException signal ].  ^protocols remove: arg1 ifAbsent: [  ]split: arg1  | tmp1 |  tmp1 := OrderedCollection new: (arg1 size / 2) asInteger.  self split: arg1 do: [:arg2 |  tmp1 add: arg2 ].  ^tmp1methodNode  ^self outerCode methodNodesetSender: arg1 receiver: arg2 method: arg3 closure: arg4 startpc: arg5  sender := arg1.  receiver := arg2.  method := arg3.  closureOrNil := arg4.  pc := arg5.  stackp := 0isSpecAdapter  ^falsestart: arg1  start := arg1 asDateAndTimeisActiveProcess  ^self == Processor activeProcessreplaceFrom: arg1 to: arg2 with: arg3 startingAt: arg4  | tmp1 |  tmp1 := arg4.  arg1 to: arg2 do: [:arg5 |  self byteAt: arg5 put: (arg3 byteAt: tmp1).        tmp1 := tmp1 + 1 ]genSend: arg1 numArgs: arg2  | tmp1 tmp2 |  (arg1 < 0 or: [ arg1 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'selectorLiteralIndex' index: arg1 range: 0 to: 65535 ].  (arg2 < 0 or: [ arg2 > 31 ]) ifTrue: [ ^self outOfRangeError: 'numArgs' index: arg2 range: 0 to: 31 ].  (arg1 < 16 and: [ arg2 < 3 ]) ifTrue: [ stream nextPut: 128 + (arg2 * 16) + arg1.        ^self ].  (tmp1 := arg1) > 31 ifTrue: [ self genUnsignedSingleExtendA: tmp1 // 32.        tmp1 := tmp1 \\ 32 ].  (tmp2 := arg2) > 7 ifTrue: [ self genUnsignedSingleExtendB: tmp2 // 8.        tmp2 := tmp2 \\ 8 ].  stream     nextPut: 234;     nextPut: tmp2 + (tmp1 * 8)seasidePossibleCauses  | tmp1 |  self receiver isNil ifFalse: [ ^#('you sent a message this type of object doesn''t understand') ].  tmp1 := #('the receiver of the message is nil' 'a class extension hasn''t been loaded correctly' 'you sent the wrong message') asOrderedCollection.  self message selector = #contents ifTrue: [ tmp1 addFirst: 'you forgot to send "super initialize" in a initialize method of a component or task' ].  ^tmp1digitRshift: arg1 bytes: arg2 lookfirst: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp1 := 0 - arg1.  tmp2 := 0.  tmp4 := tmp1 + 8.  tmp8 := arg3.  tmp5 := 255 bitShift: 0 - tmp4.  tmp6 := self byteAt: tmp8.  [ ((tmp6 bitShift: tmp1) bitOr: tmp2) = 0 and: [ tmp8 ~= 1 ] ] whileTrue: [ tmp2 := tmp6 bitShift: tmp4.        tmp8 := tmp8 - 1.        tmp6 := self byteAt: tmp8 ].  tmp8 <= arg2 ifTrue: [ ^Integer new: 0 neg: self negative ].  tmp3 := Integer new: tmp8 - arg2 neg: self negative.  tmp7 := tmp8.  tmp2 := (self byteAt: arg2 + 1) bitShift: tmp1.  arg2 + 1 to: tmp7 do: [:arg4 |  tmp6 := self byteAt: arg4 + 1.        tmp3 byteAt: arg4 - arg2 put: (((tmp6 bitAnd: tmp5) bitShift: tmp4) bitOr: tmp2).        tmp2 := tmp6 bitShift: tmp1 ].  ^tmp3sourceCode  ^self subclassResponsibilityisValid  ^truedegreeCos  ^(90 - ((180 + self) \\ 360 - 180) abs) degreesToRadians sinencompass: arg1  ^Rectangle origin: (origin min: arg1) corner: (corner max: arg1)printWithCommasSignedOn: arg1  ^self printSeparatedBy: $, every: 3 signed: true on: arg1checkDeep  < script: 'DeepCopier new checkDeep'>  Warning signal: (String streamContents: [:arg1 |  arg1 nextPutAll: 'Instance variables shared with the original object when it is copied'.              (self systemNavigation allClassesImplementing: #veryDeepInner:) do: [:arg2 |  | tmp1 |                    (tmp1 := arg2 instVarNames size) > 0 ifTrue: [ arg2 instSize - tmp1 + 1 to: arg2 instSize do: [:arg3 |  ((arg2 compiledMethodAt: #veryDeepInner:) writesField: arg3) ifFalse: [ arg1                                         cr;                                         tab.                                      arg2 name printOn: arg1.                                      arg1 space.                                      (arg2 allInstVarNames at: arg3) printOn: arg1 ] ] ] ] ])hasActionForEvent: arg1  ^(self actionForEvent: arg1) notNiltestEpoch  self assert: aDateAndTime equals: '1901-01-01T00:00:00+00:00' asDateAndTimetestAsYears  self     assert: 2 years days equals: 730;     assert: 0.5 year asHours equals: 364 / 2 * 24 + 12duration  ^durationsendTo: arg1  ^arg1 perform: selector withArguments: argstestPrevious  self assert: aTimespan equals: aDisjointTimespan previous.  self assert: aTimespan next previous equals: aTimespanoriginMethod  ^self methodClass findOriginMethodOf: selfsetDelay: arg1  millisecondDelayDuration := arg1 asIntegertestToBy  self assert: (aDateAndTime to: aDateAndTime + 10 days by: 5 days) equals: ((DateAndTime year: 1970 month: 1 day: 1) to: (DateAndTime year: 1970 month: 1 day: 1) + 10 days by: 5 days)fuelAccept: arg1  ^arg1 visitSmallInteger: selftestPlus  self assert: aDateAndTime + '0:00:00:00' equals: aDateAndTime.  self assert: aDateAndTime + 0 equals: aDateAndTime.  self assert: aDateAndTime + aDuration equals: (DateAndTime year: 1901 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)testAsSecond  | tmp1 tmp2 tmp3 |  tmp1 := Duration seconds: 1.  tmp2 := Duration seconds: 0.5.  tmp3 := Duration seconds: 0.25.  self     assert: 1 second equals: tmp1;     assert: 1.0 second equals: tmp1;     assert: 0.5 second equals: tmp2;     assert: (1 / 2) second equals: tmp2;     assert: (1 / 4) second equals: tmp3.  self assert: 0.4 second + 0.6 second equals: 1 seconddigitCompare: arg1  self deprecated: 'Please use bytesCompare: instead.' transformWith: '`@receiver digitCompare: `@statements1' -> '`@receiver bytesCompare: `@statements1'.  ^self bytesCompare: arg1testIsNotAbstract  self deny: SmallInteger isAbstractasActiveRingDefinition  ^RGMethodDefinition new     name: self selector;     parentName: self methodClass name;     isMetaSide: self methodClass isMeta;     asActivekind  ^kindtestDifferentBases  self assert: 2r10 equals: 2.  self assert: 3r210 equals: 21.  self assert: 4r3210 equals: 228.  self assert: 5r43210 equals: 2930.  self assert: 6r543210 equals: 44790.  self assert: 7r6543210 equals: 800667.  self assert: 8r76543210 equals: 16434824.  self assert: 9r876543210 equals: 381367044.  self assert: 10r9876543210 equals: 9876543210.  self assert: 11rA9876543210 equals: 282458553905.  self assert: 12rBA9876543210 equals: 8842413667692.  self assert: 13rCBA9876543210 equals: 300771807240918.  self assert: 14rDCBA9876543210 equals: 11046255305880158.  self assert: 15rEDCBA9876543210 equals: 435659737878916215.  self assert: 16rFEDCBA9876543210 equals: 18364758544493064720.  self assert: 17rGFEDCBA9876543210 equals: 824008854613343261192.  self assert: 18rHGFEDCBA9876543210 equals: 39210261334551566857170.  self assert: 19rIHGFEDCBA9876543210 equals: 1972313422155189164466189.  self assert: 20rJIHGFEDCBA9876543210 equals: 104567135734072022160664820.  self assert: 21rKJIHGFEDCBA9876543210 equals: 5827980550840017565077671610.  self assert: 22rLKJIHGFEDCBA9876543210 equals: 340653664490377789692799452102.  self assert: 23rMLKJIHGFEDCBA9876543210 equals: 20837326537038308910317109288851.  self assert: 24rNMLKJIHGFEDCBA9876543210 equals: 1331214537196502869015340298036888.  self assert: 25rONMLKJIHGFEDCBA9876543210 equals: 88663644327703473714387251271141900.  self assert: 26rPONMLKJIHGFEDCBA9876543210 equals: 6146269788878825859099399609538763450.  self assert: 27rQPONMLKJIHGFEDCBA9876543210 equals: 442770531899482980347734468443677777577.  self assert: 28rRQPONMLKJIHGFEDCBA9876543210 equals: 33100056003358651440264672384704297711484.  self assert: 29rSRQPONMLKJIHGFEDCBA9876543210 equals: 2564411043271974895869785066497940850811934.  self assert: 30rTSRQPONMLKJIHGFEDCBA9876543210 equals: 205646315052919334126040428061831153388822830.  self assert: 31rUTSRQPONMLKJIHGFEDCBA9876543210 equals: 17050208381689099029767742314582582184093573615.  self assert: 32rVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 1459980823972598128486511383358617792788444579872.  self assert: 33rWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 128983956064237823710866404905431464703849549412368.  self assert: 34rXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 11745843093701610854378775891116314824081102660800418.  self assert: 35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 1101553773143634726491620528194292510495517905608180485.  self assert: 36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: 106300512100105327644605138221229898724869759421181854980.  self assert: -2r10 equals: -2.  self assert: -3r210 equals: -21.  self assert: -4r3210 equals: -228.  self assert: -5r43210 equals: -2930.  self assert: -6r543210 equals: -44790.  self assert: -7r6543210 equals: -800667.  self assert: -8r76543210 equals: -16434824.  self assert: -9r876543210 equals: -381367044.  self assert: -10r9876543210 equals: -9876543210.  self assert: -11rA9876543210 equals: -282458553905.  self assert: -12rBA9876543210 equals: -8842413667692.  self assert: -13rCBA9876543210 equals: -300771807240918.  self assert: -14rDCBA9876543210 equals: -11046255305880158.  self assert: -15rEDCBA9876543210 equals: -435659737878916215.  self assert: -16rFEDCBA9876543210 equals: -18364758544493064720.  self assert: -17rGFEDCBA9876543210 equals: -824008854613343261192.  self assert: -18rHGFEDCBA9876543210 equals: -39210261334551566857170.  self assert: -19rIHGFEDCBA9876543210 equals: -1972313422155189164466189.  self assert: -20rJIHGFEDCBA9876543210 equals: -104567135734072022160664820.  self assert: -21rKJIHGFEDCBA9876543210 equals: -5827980550840017565077671610.  self assert: -22rLKJIHGFEDCBA9876543210 equals: -340653664490377789692799452102.  self assert: -23rMLKJIHGFEDCBA9876543210 equals: -20837326537038308910317109288851.  self assert: -24rNMLKJIHGFEDCBA9876543210 equals: -1331214537196502869015340298036888.  self assert: -25rONMLKJIHGFEDCBA9876543210 equals: -88663644327703473714387251271141900.  self assert: -26rPONMLKJIHGFEDCBA9876543210 equals: -6146269788878825859099399609538763450.  self assert: -27rQPONMLKJIHGFEDCBA9876543210 equals: -442770531899482980347734468443677777577.  self assert: -28rRQPONMLKJIHGFEDCBA9876543210 equals: -33100056003358651440264672384704297711484.  self assert: -29rSRQPONMLKJIHGFEDCBA9876543210 equals: -2564411043271974895869785066497940850811934.  self assert: -30rTSRQPONMLKJIHGFEDCBA9876543210 equals: -205646315052919334126040428061831153388822830.  self assert: -31rUTSRQPONMLKJIHGFEDCBA9876543210 equals: -17050208381689099029767742314582582184093573615.  self assert: -32rVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -1459980823972598128486511383358617792788444579872.  self assert: -33rWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -128983956064237823710866404905431464703849549412368.  self assert: -34rXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -11745843093701610854378775891116314824081102660800418.  self assert: -35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -1101553773143634726491620528194292510495517905608180485.  self assert: -36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210 equals: -106300512100105327644605138221229898724869759421181854980allSubclasses  | tmp1 tmp2 |  tmp1 := OrderedCollection withAll: self subclasses.  tmp2 := 1.  [ tmp2 > tmp1 size ] whileFalse: [ tmp1 addAll: (tmp1 at: tmp2) subclasses.        tmp2 := tmp2 + 1 ].  ^tmp1isPushLiteralNil: arg1  ^(self method at: arg1) = method encoderClass pushNilBytein: arg1  ^arg1 value: selfensure: arg1  < primitive: 198>  | tmp1 tmp2 |  tmp2 := self valueNoContextSwitch.  tmp1 ifNil: [ tmp1 := true.        arg1 value ].  ^tmp2at: arg1  ^self at: arg1 ifAbsent: [ self error: 'not found' ]sign  ^1hasLiteralSuchThat: arg1  (self penultimateLiteral isMethodProperties and: [ self penultimateLiteral hasLiteralSuchThat: arg1 ]) ifTrue: [ ^true ].  2 to: self numLiterals - 1 do: [:arg2 |  | tmp1 |        tmp1 := self objectAt: arg2.        ((arg1 value: tmp1) or: [ tmp1 isArray and: [ tmp1 hasLiteralSuchThat: arg1 ] ]) ifTrue: [ ^true ].        (tmp1 isMemberOf: CompiledBlock) ifTrue: [ (tmp1 hasLiteralSuchThat: arg1) ifTrue: [ ^true ] ] ].  ^falseinstallValue: arg1 intoForked: arg2 from: arg3  arg2 psValueAt: index put: arg1longPrintOn: arg1 limitedTo: arg2 indent: arg3  self class allInstVarNames doWithIndex: [:arg4 :arg5 |  arg3 timesRepeat: [ arg1 tab ].        arg1           nextPutAll: arg4;           nextPut: $:;           space;           tab;           nextPutAll: ((self instVarAt: arg5) printStringLimitedTo: (arg2 - 3 - arg4 size max: 1));           cr ]testMidnight  self assert: aDateAndTime midnight equals: aDateAndTimepushConsArrayWithElements: arg1  | tmp1 |  tmp1 := Array new: arg1.  arg1 to: 1 by: -1 do: [:arg2 |  tmp1 at: arg2 put: self pop ].  self push: tmp1setPostLoadDoItInMetacelloSpec: arg1  arg1 setPostLoadDoIt: (arg1 project valueHolderSpec           value: self;           yourself)isTerminating  ^terminating ifNil: [ false ]notifyOfRecategorizedSelector: arg1 from: arg2 to: arg3  (self compiledMethodAt: arg1 ifAbsent: [ nil ]) ifNotNil: [:arg4 |  SystemAnnouncer uniqueInstance methodRecategorized: arg4 oldProtocol: arg2 ]valueWithArguments: arg1  < primitive: 206>  | tmp1 tmp2 |  numArgs ~= arg1 size ifTrue: [ self numArgsError: arg1 size ].  tmp1 := self asContextWithSender: thisContext sender.  tmp2 := self numCopiedValues.  tmp1 stackp: tmp2 + numArgs.  1 to: numArgs do: [:arg2 |  tmp1 at: arg2 put: (arg1 at: arg2) ].  1 to: tmp2 do: [:arg2 |  tmp1 at: arg2 + numArgs put: (self at: arg2) ].  thisContext privSender: tmp1metacelloRegistrationHash  ^self hashtestComparisonWhenPrimitiveFails  self deny: 0.5 < (1 / 4).  self deny: 0.5 < (1 / 2).  self assert: 0.5 < (3 / 4).  self deny: 0.5 <= (1 / 4).  self assert: 0.5 <= (1 / 2).  self assert: 0.5 <= (3 / 4).  self assert: 0.5 > (1 / 4).  self deny: 0.5 > (1 / 2).  self deny: 0.5 > (3 / 4).  self assert: 0.5 >= (1 / 4).  self assert: 0.5 >= (1 / 2).  self deny: 0.5 >= (3 / 4).  self deny: 0.5 equals: 1 / 4.  self assert: 0.5 equals: 1 / 2.  self deny: 0.5 equals: 3 / 4.  self assert: 0.5 ~= (1 / 4).  self deny: 0.5 ~= (1 / 2).  self assert: 0.5 ~= (3 / 4)daysInYear  ^self duration daysdefinitionWithSlots  ^String streamContents: [:arg1 |  arg1 print: self.        arg1           crtab;           nextPutAll: 'slots: ';           nextPutAll: self slotDefinitionString ]digitLogic: arg1 op: arg2 length: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 |  tmp3 := self negative.  tmp4 := arg1 negative.  tmp5 := ((tmp3 ifTrue: [ -1 ] ifFalse: [ 0 ]) perform: arg2 with: (tmp4 ifTrue: [ -1 ] ifFalse: [ 0 ])) < 0.  tmp2 := Integer new: arg3 neg: tmp5.  tmp8 := tmp6 := tmp7 := true.  tmp1 := 0.  [ (tmp1 := tmp1 + 1) <= arg3 or: [ tmp5 and: [ tmp8 and: [ tmp2 := tmp2 growby: 1.                    true ] ] ] ] whileTrue: [ tmp9 := self byteAt: tmp1.        tmp3 ifTrue: [ tmp9 := tmp6 ifTrue: [ tmp9 = 0 ifTrue: [ 0 ] ifFalse: [ tmp6 := false.                          256 - tmp9 ] ] ifFalse: [ 255 - tmp9 ] ].        tmp10 := arg1 byteAt: tmp1.        tmp4 ifTrue: [ tmp10 := tmp7 ifTrue: [ tmp10 = 0 ifTrue: [ 0 ] ifFalse: [ tmp7 := false.                          256 - tmp10 ] ] ifFalse: [ 255 - tmp10 ] ].        tmp11 := tmp9 perform: arg2 with: tmp10.        tmp2 byteAt: tmp1 put: (tmp5 ifTrue: [ tmp8 ifTrue: [ tmp11 = 0 ifTrue: [ 0 ] ifFalse: [ tmp8 := false.                                256 - tmp11 ] ] ifFalse: [ 255 - tmp11 ] ] ifFalse: [ tmp11 ]) ].  ^tmp2 normalizeintersect: arg1 ifNone: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  (self intersects: arg1) ifFalse: [ ^arg2 value ].  tmp1 := arg1 origin.  tmp2 := tmp1 x max: origin x.  tmp4 := tmp1 y max: origin y.  tmp1 := arg1 corner.  tmp3 := tmp1 x min: corner x.  tmp5 := tmp1 y min: corner y.  ^Rectangle origin: tmp2 @ tmp4 corner: tmp3 @ tmp5testAsSeconds  self assert: aDateAndTime asSeconds equals: 0 asDuration asSecondsifFalse: arg1 ifTrue: arg2  ^arg1 valuegenPushReceiver  stream nextPut: 112printHMS: arg1 separatedBy: arg2 on: arg3  arg1 hour printOn: arg3 base: 10 length: 2 padded: true.  arg3 nextPut: arg2.  arg1 minute printOn: arg3 base: 10 length: 2 padded: true.  arg3 nextPut: arg2.  arg1 second printOn: arg3 base: 10 length: 2 padded: truetheNonMetaClass  self deprecated: 'Please use #instanceSide instead' transformWith: '`@receiver theNonMetaClass' -> '`@receiver instanceSide'.  ^self instanceSidetestclassThatDefinesInstVarNamed  self assert: (Point classThatDefinesInstVarNamed: 'x') equals: Point.  self assert: (Class classThatDefinesInstVarNamed: 'methodDict') equals: Behavior.  self assert: (Point classThatDefinesInstVarNamed: 'methodDict') equals: nilsetUp  super setUp.  restoredStartDay := Week startDay.  Week startDay: #Sunday.  week := Week starting: '4 July 1998' asDatetestIsLetter  | tmp1 tmp2 tmp3 |  tmp1 := #(Ll Lm Lo Lt Lu) collect: [:arg1 |  Unicode classPool at: arg1 ].  self aRandomSelectionOfCodePointsDo: [:arg2 |  tmp2 := Unicode isLetter: (Character codePoint: arg2).        tmp3 := self unicodeCategoryTableLookup: arg2.        self assert: tmp2 equals: (tmp1 includes: tmp3) ]doPrimitive: arg1 method: arg2 receiver: arg3 args: arg4  | tmp1 |  ((arg1 between: 201 and: 222) and: [ (self objectClass: arg3) includesBehavior: BlockClosure ]) ifTrue: [ ((arg1 between: 201 and: 205) or: [ arg1 between: 221 and: 222 ]) ifTrue: [ ^arg3 simulateValueWithArguments: arg4 caller: self ].        arg1 = 206 ifTrue: [ ^arg3 simulateValueWithArguments: arg4 first caller: self ] ].  ((arg1 between: 207 and: 209) and: [ (self objectClass: arg3) includesBehavior: FullBlockClosure ]) ifTrue: [ ^arg1 = 208 ifTrue: [ arg3 simulateValueWithArguments: arg4 first caller: self ] ifFalse: [ arg3 simulateValueWithArguments: arg4 caller: self ] ].  arg1 = 83 ifTrue: [ ^self send: arg4 first to: arg3 with: arg4 allButFirst super: false ].  arg1 = 84 ifTrue: [ ^self send: arg4 first to: arg3 with: (arg4 at: 2) lookupIn: (self objectClass: arg3) ].  arg1 = 100 ifTrue: [ arg4 size = 3 ifTrue: [ ^self send: arg4 first to: arg3 with: (arg4 at: 2) lookupIn: (arg4 at: 3) ] ifFalse: [ ^self send: (arg4 at: 2) to: (arg4 at: 1) with: (arg4 at: 3) lookupIn: (arg4 at: 4) ] ].  (arg1 = 186 or: [ arg1 = 187 ]) ifTrue: [ | tmp2 tmp3 |        tmp2 := Processor activeProcess.        tmp3 := tmp2 effectiveProcess.        tmp1 := arg1 = 186 ifTrue: [ arg3 primitiveEnterCriticalSectionOnBehalfOf: tmp3 ] ifFalse: [ arg3 primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: tmp3 ].        ^(self isPrimFailToken: tmp1) ifTrue: [ tmp1 ] ifFalse: [ self push: tmp1 ] ].  arg1 = 188 ifTrue: [ arg4 size = 2 ifTrue: [ ^Context sender: self receiver: arg3 method: (arg4 at: 2) arguments: (arg4 at: 1) ] ifFalse: [ ^Context sender: self receiver: (arg4 at: 1) method: (arg4 at: 3) arguments: (arg4 at: 2) ] ].  (arg1 = 200 and: [ self == arg3 ]) ifTrue: [ ^self push: (BlockClosure outerContext: arg3 startpc: pc + 2 numArgs: arg4 first copiedValues: arg4 last) ].  arg1 = 118 ifTrue: [ (arg4 size = 2 and: [ arg4 first isInteger and: [ (self objectClass: arg4 last) == Array ] ]) ifFalse: [ ^Context primitiveFailTokenFor: nil ].        ^self doPrimitive: arg4 first method: arg2 receiver: arg3 args: arg4 last ].  tmp1 := arg1 = 120 ifTrue: [ (arg2 literalAt: 1) tryInvokeWithArguments: arg4 ] ifFalse: [ arg1 = 117 ifTrue: [ self tryNamedPrimitiveIn: arg2 for: arg3 withArgs: arg4 ] ifFalse: [ arg3 tryPrimitive: arg1 withArgs: arg4 ] ].  ^(self isPrimFailToken: tmp1) ifTrue: [ tmp1 ] ifFalse: [ self push: tmp1 ]log  ^self ln / Ln10hash  ^(x hash hashMultiply + y hash) hashMultiplywaitUntil: arg1 for: arg2  ^self waitUntil: arg1 for: arg2 maxMilliseconds: niltestMutateWideStringUsingAtPut  | tmp1 |  tmp1 := 'hello' asWideString.  tmp1 beReadOnlyObject.  self should: [ tmp1 at: 1 put: $q ] raise: ModificationForbidden.  [ tmp1 at: 1 put: $q ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first equals: $qtestAsMonth  self assert: aTimespan asMonth equals: jan01 asMonthspotterMethodClassFor: arg1  < spotterOrder: 50>  arg1 listProcessor     allCandidates: [ {self methodClass} ];     title: 'Class';     filter: GTFilterSubstring;     itemIcon: #systemIcontestParsingYPatternWithTwoDigitsReturnsASecondMillenaryYear  self assertReading: '2.11.13' as: 'd.mm.y' equals: (Date year: 2013 month: 11 day: 2)remove: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := self linkOf: arg1 ifAbsent: [ ^arg2 value ].  self removeLink: tmp1 ifAbsent: [ ^arg2 value ].  ^arg1numTemps  ^closureOrNil ifNil: [ method numTemps ] ifNotNil: [ closureOrNil numTemps ]add: arg1  | tmp1 tmp2 |  codes ifNil: [ codes := Array with: arg1.        combined := arg1.        ^true ].  tmp1 := Compositions at: combined charCode ifAbsent: [ ^false ].  tmp2 := tmp1 at: arg1 charCode ifAbsent: [ ^false ].  codes := codes copyWith: arg1.  combined := Character leadingChar: self base leadingChar code: tmp2.  ^truespotterForSendersFor: arg1  < spotterOrder: 11>  arg1 listProcessor     title: 'Senders';     allCandidates: [ self senders collect: #compiledMethod ];     filter: GTFilterSubstring;     keyBinding: $n commandisDeprecated  self methodClass isDeprecated ifTrue: [ ^true ].  (self sendsAnySelectorOf: #(#deprecated: #deprecated:on:in: #deprecated:on:in:transformWith: #deprecated:transformWith:)) ifTrue: [ ^true ].  $- split: self protocol asString do: [:arg1 |  arg1 withBlanksCondensed = 'deprecated' ifTrue: [ ^true ] ].  ^falsereorganize  ^self organizationpostCopy  | tmp1 |  super postCopy.  firstLink ifNotNil: [ tmp1 := firstLink := firstLink copy.        [ tmp1 nextLink isNil ] whileFalse: [ tmp1 nextLink: (tmp1 := tmp1 nextLink copy) ].        lastLink := tmp1 ]adaptToFraction: arg1 andSend: arg2  ^self subclassResponsibilityisLetterModifier  ^self characterSet isLetterModifier: selfisDictionary  ^falsedaysInMonth  ^Date daysInMonthvalue  arguments ifNil: [ ^receiver perform: selector ].  ^receiver perform: selector withArguments: (self collectArguments: arguments)errorNotIndexable  self error: ('Instances of {1} are not indexable' format: {self class name})commentStamp  ^commentStampallMethodSelectors  ^self protocols flatCollect: [:arg1 |  arg1 methodSelectors ]deprecationRefactorings  ^#()populateCBMenu: arg1  super populateCBMenu: arg1.  arg1     add: 'Implementors of...' target: SystemNavigation new selector: #browseAllImplementorsOf: argument: self selector;     add: 'Senders of...' target: SystemNavigation new selector: #browseAllSendersOf: argument: self selectorprint24  ^String new: 8 streamContents: [:arg1 |  self print24: true on: arg1 ]traceCr  self traceCr: selfwithSideOrCorner: arg1 setToPoint: arg2  ^self withSideOrCorner: arg1 setToPoint: arg2 minExtent: 0 @ 0testParsingDPatternWithSingleDigitSucceeds  self assertReading: '2.11.2013' as: 'd.mm.yyyy' equals: (Date year: 2013 month: 11 day: 2)significandAsInteger  self isFinite ifTrue: [ ^(self timesTwoPower: self class precision - 1 - (self exponent max: self class emin)) truncated abs ].  ^(((self basicAt: 1) bitAnd: 16r000FFFFF) bitShift: 32) bitOr: (self basicAt: 2)defaultLabel  ^self class nameinitialize  super initialize.  exclusions := OrderedCollection newminutes  ^(seconds rem: SecondsInHour) quo: SecondsInMinutetestReentrant  | tmp1 |  tmp1 := self callcc: [:arg1 |  arg1 -> 0 ].  tmp1 value: tmp1 value + 1.  self assert: tmp1 value ~= 5.  tmp1 value = 4 ifFalse: [ tmp1 key value: tmp1 ]addFirst: arg1  | tmp1 |  tmp1 := arg1 asLink.  self isEmpty ifTrue: [ lastLink := tmp1 ].  tmp1 nextLink: firstLink.  firstLink := tmp1.  ^tmp1to: arg1 intersects: arg2 to: arg3  | tmp1 tmp2 tmp3 |  tmp1 := self.  (((tmp1 = arg2 or: [ arg1 = arg3 ]) or: [ tmp1 = arg3 ]) or: [ arg2 = arg1 ]) ifTrue: [ ^true ].  tmp2 := tmp1 to: arg1 sideOf: arg2.  tmp3 := tmp1 to: arg1 sideOf: arg3.  tmp2 = tmp3 ifTrue: [ ^false ].  tmp2 := arg2 to: arg3 sideOf: tmp1.  tmp3 := arg2 to: arg3 sideOf: arg1.  tmp2 = tmp3 ifTrue: [ ^false ].  ^truefullName  ^self nameprivSender: arg1  sender := arg1hash  ^self value hashcaseError  self error: 'Case not found (' , self printString , '), and no otherwise clause'>>> arg1  ^self -> arg1intersectValueLink: arg1 withCollection: arg2  ^arg1 ifNotNil: [ | tmp1 tmp2 |        tmp1 := arg1 value.        tmp2 := self intersectValueLink: arg1 nextLink withCollection: arg2.        (arg2 includes: tmp1) ifTrue: [ tmp1 ~~> tmp2 ] ifFalse: [ tmp2 ] ]raisedToInteger: arg1  arg1 = 0 ifTrue: [ ^1 ].  arg1 < 0 ifTrue: [ ^self reciprocal raisedToInteger: arg1 negated ].  ^Fraction numerator: (numerator raisedToInteger: arg1) denominator: (denominator raisedToInteger: arg1)testOffset  | tmp1 tmp2 |  tmp1 := DateAndTime fromString: '2018/01/01T00:00:00+10'.  tmp2 := Year starting: tmp1 duration: 0.  self assert: tmp2 asDateAndTime offset equals: tmp1 offsetscaleBy: arg1  ^Rectangle origin: origin * arg1 corner: corner * arg1listAtProtocolNamed: arg1  ^self listAtCategoryNamed: arg1isRemoteString  ^falsesendNodes  ^self ast sendNodesisNested  ^handlerContext nextHandlerContext canHandleSignal: selfquickStep  self willSend ifTrue: [ QuickStep := self ].  ^self stepsentTo: arg1  ^lookupClass ifNil: [ arg1 perform: selector withArguments: args ] ifNotNil: [ arg1 perform: selector withArguments: args inSuperclass: lookupClass ]isWide  ^self width > self heightasBit  self subclassResponsibilitystandardMessageText  ^String streamContents: [:arg1 |  arg1 << 'for '.        arg1 print: self selector.        arg1 << ' in '.        arg1 print: self signaler class ]iterations: arg1  iterations := arg1flag: arg1  methodSelectors  ^methodSelectors* arg1  < primitive: 29>  ^super * arg1asLiteralNode  ^RBLiteralNode value: selftestJulianDayNumber  self assert: (january23rd2004 translateTo: 0) equals: (Date julianDayNumber: (4713 + 2004) * 365 + 1323 offset: 0 hour)testFromSeconds  self assert: aDateAndTime equals: (DateAndTime fromSeconds: 0)createActionMap  ^IdentityDictionary newgenStorePopTemp: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63 ].  arg1 < 8 ifTrue: [ stream nextPut: 104 + arg1.        ^self ].  arg1 < 64 ifTrue: [ stream           nextPut: 130;           nextPut: 64 + arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63flag  ^((self header bitShift: -29) bitAnd: 1) = 1setNumerator: arg1 denominator: arg2 scale: arg3  self setNumerator: arg1 denominator: arg2.  scale := arg3testYesterday  self assert: Date yesterday equals: Date today - 1 daystonContainSubObjects  ^truetestIndexOfDay  self assert: (Week indexOfDay: 'Friday') equals: 6raisedTo: arg1  ^self coerce: (super raisedTo: arg1)parseVariableDigitYear  year := self parse: 'year'testStoreBase16  self assert: (20.0 storeStringBase: 16) = '16r14.0' description: 'the radix prefix should not be omitted, except in base 10'pin  self pinInMemorytestBasicWritable  self alwaysWritableObjects , self maybeReadOnlyObjects do: [:arg1 |  self assert: arg1 isReadOnlyObject equals: false ]subclassDefinerClass  ^Smalltalk compilerClasstestForSeconds  | tmp1 |  tmp1 := Delay forSeconds: 1.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: tmp1.  scheduler simulate_vmMilliseconds: 1099.  self deny: tmp1 isExpired.  scheduler simulate_vmMilliseconds: 1100.  self assert: tmp1 isExpiredinsetRectangle: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 left + self left.  tmp2 := left max: arg1 right - self right.  tmp3 := arg1 top + self top.  tmp4 := top max: arg1 bottom - self bottom.  ^Rectangle left: tmp1 right: tmp2 top: tmp3 bottom: tmp4update: arg1  ^selfwait  self asDelay waitbackgroundProcess  ^BackgroundProcesscheck: arg1 forCritiquesDo: arg2 ifNone: arg3  | tmp1 |  tmp1 := false.  arg1 nodesDo: [:arg4 |  (arg4 isVariable and: [ arg4 binding ifNil: [ arg4 doSemanticAnalysis ].              arg4 isGlobal and: [ self systemClassNames includes: arg4 name ] ]) ifTrue: [ tmp1 := true.              arg2 cull: (ReTrivialCritique withAnchor: (ReIntervalSourceAnchor entity: arg1 interval: arg4 sourceInterval) by: self) ] ].  tmp1 ifFalse: arg3testDoesNotActivateForDeprecatedMethods  | tmp1 |  tmp1 := testSubclass >> (testSubclass compile: self methodName , ' self deprecated: ''Add another explanation message''').  self assertEmpty: (OverridesDeprecatedMethodRule new check: tmp1)testRoundTo  self assert: (5 minutes + 37 seconds roundTo: 2 minutes) equals: 6 minutes.  self assert: (aDuration roundTo: (Duration days: 1)) equals: (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: (aDuration roundTo: (Duration hours: 1)) equals: (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: (aDuration roundTo: (Duration minutes: 1)) equals: (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0)testMutualExclusion  | tmp1 tmp2 |  tmp2 := OrderedCollection new.  tmp1 := Semaphore forMutualExclusion.  [ tmp2 add: #startProcess1.  tmp1 critical: [ tmp2 add: #startCritical1.        [ tmp2 includes: #startProcess2 ] whileFalse: [ Processor yield ].        tmp2 add: #endCritical1 ] ] fork.  [ [ tmp2 includes: #startProcess1 ] whileFalse: [ Processor yield ].  tmp2 add: #startProcess2.  tmp1 critical: [ tmp2 add: #startCritical2.        Processor yield.        tmp2 add: #endCritical2 ] ] fork.  [ tmp2 size = 6 ] whileFalse: [ Processor yield ].  self assert: (tmp2 hasEqualElements: #(startProcess1 startCritical1 startProcess2 endCritical1 startCritical2 endCritical2))round: arg1  < expr: 10.12345 round: 2 result: 10.12>  < expr: 10.199999999 round: 2 result: 10.2>  ^self subclassResponsibilitybitStringLength  ^self class maxVal highBit + 1pinInMemory  ^self setPinnedInMemory: true> arg1  ^arg1 < selfchanged: arg1  self dependents do: [:arg2 |  arg2 update: arg1 ]selector  ^self outerCode selectortestAsNumberWithExtendedScale  | tmp1 |  tmp1 := '123s2' asNumber.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: tmp1 scale equals: 2.  self assert: '123.00s2' equals: tmp1 printStringanyMask: arg1  ^0 ~= (self bitAnd: arg1)testInjectingExceptionHandlerIntoNotRunningProcess  | tmp1 tmp2 tmp3 tmp4 |  DefaultExecutionEnvironment beActive.  tmp1 := Error new messageText: 'test error'.  tmp4 := true.  tmp3 := [ tmp1 signal.  tmp4 := false ] newProcess.  tmp3 on: Error do: [:arg1 |  tmp2 := arg1 ].  tmp3 resume.  [ tmp3 isTerminated ] whileFalse: [ Processor yield ].  self assert: tmp2 identicalTo: tmp1.  self assert: tmp4testWriteSlotNamedValue  | tmp1 |  tmp1 := 5 @ 6.  self assert: (tmp1 writeSlotNamed: #x value: 7) equals: 7.  self assert: tmp1 equals: 7 @ 6monthAbbreviation  ^start monthAbbreviationisSelfEvaluating  ^self isLiteralselectorsToBeIgnored  | tmp1 tmp2 tmp3 |  tmp1 := #().  tmp2 := #(#printOn:).  tmp3 := #(#next #do:).  ^super selectorsToBeIgnored , tmp1 , tmp2 , tmp3= arg1  ^self species = arg1 species and: [ self start = arg1 start and: [ self duration = arg1 duration ] ]linesOfCode  | tmp1 |  tmp1 := self localMethods inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 linesOfCode ].  ^self isMeta ifTrue: [ tmp1 ] ifFalse: [ tmp1 + self classSide linesOfCode ]isTransferable  ^falsetestTicks  self assert: aDateAndTime ticks equals: (DateAndTime julianDayNumber: 2444240) ticks.  self assert: aDateAndTime ticks equals: #(2444240 0 0)methodWithPragma  < testPragmaArg1: #toto arg2: 2 arg3: true>  ast  ^self subclassResponsibilitylink: arg1 toClassVariableNamed: arg2  self link: arg1 toClassVariable: (MetalinkTargetResolver classVariableNamed: arg2 for: self)classToBeTested  ^self dateClasstestTwoInARow  | tmp1 tmp2 |  tmp1 := #solid ~~> (#food ~~> nil ~~> (Link new ~~> nil)) ~~> (#food ~~> nil ~~> nil ~~> nil ~~> nil).  tmp2 := #solid ~~> (#food ~~> nil ~~> (#marmellade ~~> nil)) ~~> (#food ~~> nil ~~> nil ~~> nil ~~> nil).  self assert: (self printStringOfTree: tmp1) equals: '((#solid (#food) ()) (((#food))))'.  self assert: (TwoInARowStar new tree: tmp1) equals: true.  self assert: (self printStringOfTree: tmp2) equals: '((#solid (#food) #marmellade) (((#food))))'.  self assert: (TwoInARowStar new tree: tmp2) equals: falseweeks  ^Duration weeks: selftestIsLeapYear  self deny: aDateAndTime isLeapYearbasicAt: arg1 put: arg2  < primitive: 39>  ^super basicAt: arg1 put: arg2trace  self trace: selftestRemoveCategory  self assert: self organization categories size equals: 2.  self should: [ self organization removeCategory: 'one' ] raise: Error.  self organization removeCategory: 'empty'.  self assert: self organization categories size equals: 1.  self assert: self organization categories first equals: 'one'roundTo: arg1  ^(self / arg1) rounded * arg1subclass: arg1 uses: arg2 layout: arg3 slots: arg4 classVariables: arg5 package: arg6  ^self subclass: arg1 uses: arg2 layout: arg3 slots: arg4 classVariables: arg5 poolDictionaries: '' category: arg6testResumableFallOffTheEndHandler  self assertSuccess: (ExceptionTester new runTest: #resumableFallOffTheEndHandler)atRandom: arg1  ^arg1 nextInt: selftestAsBit  self assert: true asBit equals: 1storeOn: arg1 base: arg2  ^self subclassResponsibilitytestInstructions  | tmp1 |  tmp1 := InstructionClient new.  Object methods do: [:arg1 |  | tmp2 |        tmp2 := InstructionStream on: arg1.        [ tmp2 pc <= arg1 endPC ] whileTrue: [ tmp2 interpretNextInstructionFor: tmp1 ] ]queueDict  ^queueDict ifNil: [ queueDict := IdentityDictionary new ]asSendTo: arg1  ^MessageSend message: self to: arg1testWhichSelectorsAccess  self assert: ((Point whichSelectorsAccess: 'x') includes: #x).  self deny: ((Point whichSelectorsAccess: 'y') includes: #x)asMetacelloVersionNumber  ^MetacelloVersionNumber fromString: ''testPrintOn  | tmp1 |  tmp1 := String streamContents: [:arg1 |  nil printOn: arg1 ].  self assert: tmp1 equals: 'nil'testSetUp  self deny: aMethodContext isDead.  self assert: aMethodContext home equals: aMethodContext.  self assert: aMethodContext receiver equals: aReceiver.  self assert: (aMethodContext method isKindOf: CompiledMethod).  self assert: aMethodContext method equals: aCompiledMethod.  self assert: aMethodContext client printString equals: 'ContextTest>>#testSetUp'= arg1  self == arg1 ifTrue: [ ^true ].  self species == arg1 species ifFalse: [ ^false ].  self method = arg1 method ifFalse: [ ^false ].  self method selector = arg1 method selector ifFalse: [ ^false ].  self selector = arg1 selector ifFalse: [ ^false ].  self arguments = arg1 arguments ifFalse: [ ^false ].  ^truedegreeCos  self isFinite ifTrue: [ ^super degreeCos ].  ^self degreesToRadians cosvariableSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5  ^self variableSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5testTerminatingBlockedCriticalSectionShouldNotUnblockAnotherWaitingSection  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := false.  tmp1 := Semaphore new.  tmp4 := false.  self fork: [ mutex critical: [ tmp1 wait.              tmp2 := tmp4 not ] ].  self waitLastProcessLock.  tmp3 := self fork: [ mutex critical: [ self error: 'should not happen' ] ].  self waitLastProcessLock.  self fork: [ mutex critical: [ tmp4 := true ] ].  self waitLastProcessLock.  tmp3 terminate.  self waitLastProcessLock.  tmp1 signal.  self waitLastProcessTerminate.  self assert: tmp2.  self assert: tmp4testTerminateActive  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := tmp3 := tmp1 := false.  tmp4 := [ tmp2 := true.  Processor activeProcess terminate.  tmp1 := true ] fork.  tmp5 := [ tmp3 := true.  Processor terminateActive.  tmp1 := true ] fork.  [ tmp4 isTerminated & tmp5 isTerminated ] whileFalse: [ Processor yield ].  self assert: tmp2.  self assert: tmp3.  self deny: tmp1allInstancesDo: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self allInstancesOrNil.  tmp1 ifNotNil: [ tmp1 do: arg1.        ^self ].  tmp2 := self someInstance.  [ tmp2 == nil ] whileFalse: [ tmp3 := tmp2 nextInstance.        arg1 value: tmp2.        tmp2 := tmp3 ]testInfinityCloseTo  self deny: (Float infinity closeTo: Float infinity negated).  self deny: (Float infinity negated closeTo: Float infinity)abs  self < 0 ifTrue: [ ^self negated ] ifFalse: [ ^self ]ifNil: arg1 ifNotNil: arg2  ^arg2 cull: selfinnerCorners  | tmp1 |  tmp1 := self topLeft corner: self bottomRight - (1 @ 1).  ^Array with: tmp1 topLeft with: tmp1 bottomLeft with: tmp1 bottomRight with: tmp1 topRightendPC  method ifNil: [ self error: 'Cannot determine the endPC without compiled method' ].  ^method size - sizetestAddTime  self assert: (aTime addTime: aTime) equals: (Time readFrom: '01:09:52' readStream)gtInspectorHeaderIn: arg1  < gtInspectorPresentationOrder: 40>  arg1 text     title: 'Header';     display: [ self headerDescription ]sunitExitWith: arg1  self return: arg1asLocalStringYMDHM  ^self asLocal asStringYMDHMxor: arg1  self subclassResponsibilitytagsForMethods  | tmp1 |  tmp1 := self organization protocols reject: [:arg1 |  arg1 name = Protocol unclassified | arg1 isExtensionProtocol ].  ^tmp1 select: [:arg1 |  self isLocalMethodsProtocol: arg1 ] thenCollect: #name~= arg1  < primitive: 548>  ^super ~= arg1asJson  ^WAJsonCanvas builder render: [:arg1 |  self jsonOn: arg1 ]kindAsByte  | tmp1 |  tmp1 := self class trailerKinds indexOf: kind.  [ tmp1 ~~ 0 ] assert.  ^tmp1 - 1 << 2allMethodsWritingSlot: arg1  ^self withAllSubclasses flatCollect: [:arg2 |  arg2 methodsWritingSlot: arg1 ]testMethodsReadingSlot  | tmp1 tmp2 |  (Point >> #x) hasSourceCode ifFalse: [ ^self ].  tmp1 := (Point methodsReadingSlot: (Point slotNamed: #x)) size.  tmp2 := (Point whichSelectorsRead: 'x') size.  self assert: tmp1 equals: tmp2nextWakeUpTime  ^activeDelay ifNil: [ 0 ] ifNotNil: [:arg1 |  arg1 resumptionTick ]addSlot: arg1  ^self classInstaller update: self to: [:arg2 |  arg2           fillFor: self;           slots: (self localSlots copyWith: arg1) ]testLog  self assert: ((1 / 100) log closeTo: -2).  self assert: (((2 raisedTo: Float emax + 11) / 3) log closeTo: (Float emax + 11) * 2 log - 3 log) description: 'Fraction>>log should not overflow'.  self assert: ((3 / (2 raisedTo: Float precision - Float emin)) log closeTo: (Float emin - Float precision) * 2 log + 3 log) description: 'Fraction>>log should not underflow'printOn: arg1 base: arg2 length: arg3 padded: arg4  | tmp1 |  tmp1 := self negative ifTrue: [ '-' ] ifFalse: [ '' ].  self print: (self abs printStringBase: arg2) on: arg1 prefix: tmp1 length: arg3 padded: arg4genStoreTemp: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63 ].  arg1 < 64 ifTrue: [ stream           nextPut: 129;           nextPut: 64 + arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63genStoreTemp: arg1  (arg1 < 0 or: [ arg1 > 63 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 63 ].  stream     nextPut: 245;     nextPut: arg1dividend: arg1  dividend := arg1isResumable  ^trueinsideTriangle: arg1 with: arg2 with: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self.  tmp2 := (arg2 x - arg1 x) * (arg3 y - arg1 y) - ((arg3 x - arg1 x) * (arg2 y - arg1 y)).  tmp2 isZero ifTrue: [ ^false ].  tmp2 := 1.0 / tmp2.  tmp3 := ((arg2 x - tmp1 x) * (arg3 y - tmp1 y) - ((arg3 x - tmp1 x) * (arg2 y - tmp1 y))) * tmp2.  tmp4 := ((arg3 x - tmp1 x) * (arg1 y - tmp1 y) - ((arg1 x - tmp1 x) * (arg3 y - tmp1 y))) * tmp2.  tmp5 := ((arg1 x - tmp1 x) * (arg2 y - tmp1 y) - ((arg2 x - tmp1 x) * (arg1 y - tmp1 y))) * tmp2.  tmp3 < 0.0 ifTrue: [ ^false ].  tmp4 < 0.0 ifTrue: [ ^false ].  tmp5 < 0.0 ifTrue: [ ^false ].  ^truegenReturnSpecialLiteral: arg1  | tmp1 |  tmp1 := #(true false nil) indexOf: arg1 ifAbsent: 0.  tmp1 = 0 ifTrue: [ ^self error: 'return special literal: ' , arg1 printString , ' is not one of true false nil' ].  stream nextPut: 120 + tmp1firstLink  self emptyCheck.  ^firstLinktestContinuationExample2  | tmp1 |  tmp1 := (1 to: 20) asOrderedCollection.  self assert: (self continuationExample2: tmp1) equals: (tmp1 collect: [:arg1 |  arg1 * arg1 ])indexedMessageText  ^String streamContents: [:arg1 |  arg1 << ' '.        self printObject: object on: arg1.        arg1 << ' is read-only, hence its field '.        fieldIndex printOn: arg1.        arg1 << ' cannot be modified with '.        self printObject: newValue on: arg1 ]testPlus  self assert: aTimespan + aWeek equals: aDisjointTimespan.  self assert: anOverlappingTimespan + aDay equals: aTimespanadaptToFraction: arg1 andSend: arg2  ^arg1 perform: arg2 with: (Fraction numerator: self denominator: 1)gtInspectorActionBrowse  < gtInspectorAction>  ^GLMGenericAction new     action: [ Smalltalk tools browser openOnClass: self class ];     icon: GLMUIThemeExtraIcons glamorousBrowse;     title: 'Browse'return: arg1 from: arg2  | tmp1 tmp2 |  arg2 isDead ifTrue: [ ^self send: #cannotReturn: to: self with: {arg1} super: false ].  tmp1 := arg2 sender.  tmp2 := self findNextUnwindContextUpTo: tmp1.  tmp2 ifNotNil: [ ^self send: #aboutToReturn:through: to: self with: {arg1 .               tmp2} super: false ].  self releaseTo: tmp1.  tmp1 ifNotNil: [ tmp1 push: arg1 ].  ^tmp1asLowercase  ^self characterSet toLowercase: selfsignalQueue: arg1  queuesMutex critical: [ arg1 isEmpty ifFalse: [ arg1 removeFirst signal ] ]addSelectorSilently: arg1 withMethod: arg2  super addSelectorSilently: arg1 withMethod: arg2.  self instanceSide noteAddedSelector: arg1 meta: self isMetaperform: arg1 with: arg2  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: arg1 withArguments: (Array with: arg2)timingPriorityUnschedule  beingWaitedOn := falsepushConstant: arg1  self push: arg1classToBeTested  ^Durationctrl  ^KMModifier ctrl + self/ arg1  < primitive: 10>  arg1 isZero ifTrue: [ ^(ZeroDivide dividend: self) signal ].  ^(arg1 isMemberOf: SmallInteger) ifTrue: [ (Fraction numerator: self denominator: arg1) reduced ] ifFalse: [ super / arg1 ]testNthRootErrorConditions  self should: [ -2 nthRoot: 1 / 4 ] raise: ArithmeticError.  self should: [ -2 nthRoot: 1.24 ] raise: ArithmeticErrorwantsChangeSetLogging  ^self instanceSide wantsChangeSetLoggingisInstanceSide  ^self isClassSide notobject: arg1 instVarAt: arg2  < primitive: 73>  ^self object: arg1 basicAt: arg2 - (self objectClass: arg1) instSizeisAnonymous  ^self getName isNiltestBitShift  self assert: 2r11 << 2 equals: 2r1100.  self assert: (2r11 bitShift: 2) equals: 2r1100.  self assert: 2r1011 >> 2 equals: 2r10.  self assert: (2r1011 bitShift: -2) equals: 2r10methodsDo: arg1  ^self methodDict valuesDo: arg1gcd: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 |  tmp1 := SmallInteger maxVal highBit.  tmp2 := self abs max: (tmp3 := arg1 abs).  tmp3 := self abs min: tmp3.  [ tmp3 class == SmallInteger ] whileFalse: [ (tmp5 := tmp2 bitShift: (tmp4 := tmp1 - tmp2 highBit)) class == SmallInteger ifFalse: [ tmp4 := tmp4 - 1.              tmp5 := tmp5 bitShift: -1 ].        tmp6 := tmp3 bitShift: tmp4.        tmp7 := 1.        tmp8 := 0.        tmp9 := 0.        tmp10 := 1.        [ (tmp11 := tmp6 + tmp10) ~= 0 and: [ (tmp12 := tmp6 + tmp9) ~= 0 and: [ (tmp13 := (tmp5 + tmp7) // tmp12) = ((tmp5 + tmp8) // tmp11) ] ] ] whileTrue: [ tmp9 := tmp7 - (tmp13 * (tmp7 := tmp9)).              tmp10 := tmp8 - (tmp13 * (tmp8 := tmp10)).              tmp6 := tmp5 - (tmp13 * (tmp5 := tmp6)) ].        tmp8 = 0 ifTrue: [ tmp3 := tmp2 rem: (tmp2 := tmp3) ] ifFalse: [ tmp14 := tmp2 * tmp7 + (tmp3 * tmp8).              tmp3 := tmp2 * tmp9 + (tmp3 * tmp10).              tmp2 := tmp14 ] ].  ^tmp3 gcd: tmp2wait: arg1  | tmp1 |  tmp1 := DelayWaitTimeout new setDelay: arg1 asMilliSeconds forSemaphore: self.  ^tmp1 waitstoreOn: arg1 base: arg2  | tmp1 |  tmp1 := self negative ifTrue: [ arg1 nextPut: $-.        self negated ] ifFalse: [ self ].  arg2 = 10 ifFalse: [ arg1           nextPutAll: arg2 printString;           nextPut: $r ].  arg1 nextPutAll: (tmp1 printStringBase: arg2)rfvalueNoContextSwitch  < primitive: 209>  < metaLinkOptions: #(+ optionDisabledLink)>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  self primitiveFailedvariableNode  ^variableNodeisActive  ^self state = #activeprintCategoryChunk: arg1 on: arg2 withStamp: arg3 priorMethod: arg4  arg2     cr;     nextPut: $!.  arg2 nextChunkPut: (String streamContents: [:arg5 |  arg5                 nextPutAll: self name;                 nextPutAll: ' methodsFor: ';                 print: arg1 asString.              (arg3 ~~ nil and: [ arg3 size > 0 or: [ arg4 ~~ nil ] ]) ifTrue: [ arg5                       nextPutAll: ' stamp: ';                       print: arg3 ].              arg4 ~~ nil ifTrue: [ arg5                       nextPutAll: ' prior: ';                       print: arg4 sourcePointer ] ])isResumable  ^truegtInspectorIcon  ^self iconOrThumbnailOfSize: 16testNoTimeout  self assertSuccess: (ExceptionTester new runTest: #simpleNoTimeoutTest)timeZoneAbbreviation  ^self timeZone abbreviationisOwnerProcess  ^Processor activeProcess == ownerProcessincludesLocalSelector: arg1  ^self includesSelector: arg1testAsDateAndTime  self assert: aDateAndTime asDateAndTime equals: aDateAndTimeisAlphaNumeric  ^self isLetter or: [ self isDigit ]outerContext: arg1 startpc: arg2 numArgs: arg3 copiedValues: arg4  outerContext := arg1.  startpc := arg2.  numArgs := arg3.  1 to: self numCopiedValues do: [:arg5 |  self at: arg5 put: (arg4 at: arg5) ]removeAll  firstLink := lastLink := niltestSubclassInstanceVariableNames  | tmp1 |  (testEnvironment includesKey: #SubclassExample) ifTrue: [ (testEnvironment at: #SubclassExample) removeFromSystem ].  self deny: (testEnvironment includesKey: #SubclassExample).  tmp1 := Object subclass: #SubclassExample instanceVariableNames: 'x y'.  self assert: (testEnvironment includesKey: #SubclassExample).  self assert: (testEnvironment at: #SubclassExample) identicalTo: tmp1.  self assert: tmp1 category equals: self unclassifiedCategory.  self assert: tmp1 instVarNames equals: #('x' 'y').  tmp1 removeFromSystemnotNil  ^falseresumableFallOffTheEndHandlerResults  ^OrderedCollection new     add: self doSomethingString;     add: self doSomethingExceptionalString;     add: self doYetAnotherThingString;     yourselfunschedule  self class scheduler unschedule: selfnumTemps  ^self compiledBlock numTempsdotProduct: arg1  ^x * arg1 x + (y * arg1 y)< arg1  ^self asciiValue < arg1 asciiValuedefinesSlot: arg1  ^self slots identityIncludes: arg1isEnclosingMark  ^self characterSet isEnclosingMark: selftestMax  | tmp1 |  self assert: (2 max: 3) equals: 3.  tmp1 := Float fmax asInteger + 1.  self assert: (Float fmax max: tmp1) equals: tmp1.  self assert: (1 / 3 max: 0.33333333333333333333333333333333333333333) equals: 1 / 3isMessageSend  ^truenanoSeconds  ^nanostestOrdersACollectionOfClassesBySuperclass  | tmp1 |  tmp1 := Class superclassOrder: (OrderedCollection with: ExampleForTest11 class with: ExampleForTest111 class with: ExampleForTest12 class with: ExampleForTest1 class with: ExampleForTest12 class with: ExampleForTest112 class).  self assert: (tmp1 indexOf: ExampleForTest1 class) < (tmp1 indexOf: ExampleForTest11 class).  self assert: (tmp1 indexOf: ExampleForTest11 class) < (tmp1 indexOf: ExampleForTest111 class).  self assert: (tmp1 indexOf: ExampleForTest11 class) < (tmp1 indexOf: ExampleForTest112 class).  self assert: (tmp1 indexOf: ExampleForTest1 class) < (tmp1 indexOf: ExampleForTest12 class)doSomethingExceptional  self log: self doSomethingExceptionalStringtestSizeInMemoryCompactClasses  self skip.  self assert: (Association key: 'aKey' value: 23) sizeInMemory equals: 12.  self assert: Rectangle new sizeInMemory equals: 12+ arg1  | tmp1 |  tmp1 := arg1 asDuration ticks.  ^self class basicNew     setJdn: julianDayNumber + tmp1 first seconds: seconds + tmp1 second nano: nanos + tmp1 third offset: self offset;     yourselfgenStorePopLiteralVar: arg1  (arg1 < 0 or: [ arg1 > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 32768 ].  arg1 > 255 ifTrue: [ self genUnsignedSingleExtendA: arg1 // 256 ].  stream     nextPut: 241;     nextPut: arg1 \\ 256initializeClass: arg1  self initialize.  organizedClass := arg1.  organizedClass selectors do: [:arg2 |  self classify: arg2 under: Protocol unclassified ]phlowValue: arg1  ^self cull: arg1containsPoint: arg1  ^origin <= arg1 and: [ arg1 < corner ]ownCategories  | tmp1 |  tmp1 := self subject traits inject: Set new into: [:arg1 :arg2 |  arg1 addAll: (arg2 organization protocolOrganizer protocols reject: [:arg3 |  self subject methods anySatisfy: [:arg4 |  arg4 origin = self subject and: [ arg4 protocol = arg3 name ] ] ]).        arg1 ].  ^((self protocolOrganizer protocols collect: #name) copyWithoutAll: (tmp1 collect: #name)) asArraygenPop  stream nextPut: 135testMeridianAbbreviation  self assert: aTime meridianAbbreviation equals: 'PM'testDuration  self assert: aDateAndTime duration equals: 0 asDurationspecies  ^TimespantestIncludesAny  self deny: (aTimespan includesAnyOf: (Bag with: dec31)).  self assert: (aTimespan includesAnyOf: (Bag with: jan01 with: jan08))bindingOf: arg1  ^self superclass bindingOf: arg1privRefresh  closureOrNil ifNotNil: [ pc := closureOrNil startpc.        self stackp: closureOrNil numArgs + closureOrNil numCopiedValues.        1 to: closureOrNil numCopiedValues do: [:arg1 |  self tempAt: closureOrNil numArgs + arg1 put: (closureOrNil at: arg1) ] ] ifNil: [ pc := method initialPC.        self stackp: method numTemps.        method numArgs + 1 to: method numTemps do: [:arg1 |  self tempAt: arg1 put: nil ] ]popIntoTemporaryVariable: arg1  self at: arg1 + 1 put: self popmightBeASquare  self subclassResponsibilitylongPrintOn: arg1  arg1     nextPutAll: '<<too complex to show>>';     crtestAsHour  | tmp1 tmp2 tmp3 |  tmp1 := Duration minutes: 60.  tmp2 := Duration minutes: 30.  tmp3 := Duration minutes: 15.  self     assert: 1 hour equals: tmp1;     assert: 1.0 hour equals: tmp1;     assert: 0.5 hour equals: tmp2;     assert: (1 / 2) hour equals: tmp2;     assert: (1 / 4) hour equals: tmp3adoptInstance: arg1  < primitive: 160 error: ec>  arg1 primitiveChangeClassTo: self basicNew.  ^selftestToByDo  asDuration  ^selfforArrays: arg1 processWith: arg2  collectionOfArrays := arg1.  resultProcessingBlock := arg2.  buffer := Array new: arg1 size.  self combineFromIdx: 1testDuration  self assert: aDateAndTime duration equals: 0 asDuration* arg1  arg1 class = self class ifTrue: [ ^self asFraction * arg1 asFraction asScaledDecimal: (scale max: arg1 scale) ].  ^self coerce: self asFraction * arg1methodSelector  ^self method selectorsourcePointer  kind == #NativeCodeTrailer ifTrue: [ ^data at: 3 ].  ^(kind == #SourcePointer or: [ kind == #VarLengthSourcePointer ]) ifTrue: [ data ] ifFalse: [ 0 ]receiver  ^receiverserializeOn: arg1  arg1     encodeUint32: (self at: 1);     encodeUint32: (self at: 2)testIsClosePunctuation  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isClosePunctuation: tmp2) equals: (tmp1 isClosePunctuation: tmp2) ]leftmost: arg1 tree: arg2  ^self callcc: [:arg3 |  self leftmost: arg1 tree: arg2 continuation: arg3 ]referencingMethod2  ^{ExampleForTest12 .   ExampleForTest1}testDefinesSlotNamed  self assert: (Point definesSlotNamed: #x).  self deny: (Point definesSlotNamed: #z).  self assert: (Context definesSlotNamed: #stackp).  self deny: (Context definesSlotNamed: #sender)adaptToFraction: arg1 andCompare: arg2  self isFinite ifFalse: [ arg2 == #= ifTrue: [ ^false ].        arg2 == #~= ifTrue: [ ^true ].        self isNaN ifTrue: [ ^false ].        (arg2 = #< or: [ arg2 = #<= ]) ifTrue: [ ^self positive ].        (arg2 = #> or: [ arg2 = #>= ]) ifTrue: [ ^self positive not ].        ^self error: 'unknow comparison selector' ].  arg2 == #= ifTrue: [ arg1 denominator isPowerOfTwo ifFalse: [ ^false ] ].  arg2 == #~= ifTrue: [ arg1 denominator isPowerOfTwo ifFalse: [ ^true ] ].  ^arg1 perform: arg2 with: self asTrueFractiontestMinutes  self assert: aDateAndTime minutes equals: 0manifestBuilderForRuleChecker: arg1  ^arg1 manifestBuilderOfClass: selfsourceNodeForPC: arg1  | tmp1 |  tmp1 := self outerCode sourceNodeForPC: self pcInOuter.  ^tmp1 sourceNodeForPC: arg1prepareForNewProcess: arg1  ifFalse: arg1 ifTrue: arg2  self subclassResponsibilityisReturnAt: arg1  ^method encoderClass isReturnAt: arg1 in: methodassertWithDescription: arg1  | tmp1 |  self value ifTrue: [ ^self ].  tmp1 := arg1 value.  AssertionFailure signal: tmp1floorLog: arg1  (arg1 = 2 and: [ self > 0.0 ]) ifTrue: [ ^self exponent ].  ^(self log: arg1) floorcommentsAt: arg1  self deprecated: 'use #comments on the method instead' transformWith: '`@receiver commentsAt: `@argument' -> '(`@receiver compiledMethodAt: `@argument) comments'.  ^(self compiledMethodAt: arg1) commentsisVirtualProtocol  ^truename: arg1  name := arg1on: arg1 do: arg2  < primitive: 199>  ^self valuetestCanUnderstand  | tmp1 tmp2 |  tmp1 := Object subclass: 'MySuperclass' instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: self class category.  tmp1 compile: 'method1 ^self subclassResponsibility'.  tmp1 compile: 'method2 ^123'.  self assert: (tmp1 canUnderstand: #method1).  self assert: (tmp1 canUnderstand: #method2).  self deny: (tmp1 canUnderstand: #method3).  tmp2 := tmp1 subclass: 'MySubclass' instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: self class category.  tmp2 compile: 'method1 ^ 3'.  tmp2 compile: 'method3 ^5'.  self assert: (tmp2 canUnderstand: #method1).  self assert: (tmp2 canUnderstand: #method3).  tmp2 removeFromSystem.  tmp1 removeFromSystemtestReadFromWithError  self should: [ Integer readFrom: 'invalid' ] raise: ErrorhighBit  ^self highBitOfMagnitudelog: arg1  self log add: arg1testTommorrow  self assert: DateAndTime today + 24 hours equals: DateAndTime tomorrow.  self deny: aDateAndTime equals: DateAndTime tomorrowangle  ^self y arcTan: self xtestValueWithinNonLocalReturnFixSimply  self valueWithinNonLocalReturn.  (Delay forMilliseconds: 50) waitsetUp  super setUp.  forkedProcesses := OrderedCollection new.  mutex := Mutex newgenDup  stream nextPut: 136species  ^TimespanasDateAndTime  ^DateAndTime date: self date time: self timebindAndJuggle: arg1  ReparseAfterSourceEditing signaltestParsingYYPatternReturnsASecondMillenaryYear  self assertReading: '2.11.13' as: 'd.mm.yy' equals: (Date year: 2013 month: 11 day: 2)isEmpty  ^kind == #NoTrailer or: [ kind == #ClearedTrailer ]classVariables  ^self classPool associationstestBasicPrinting  | tmp1 |  tmp1 := BasicDatePrinter new.  self assert: (String streamContents: [:arg1 |  tmp1 printDate: january23rd2004 format: #() on: arg1 ]) equals: '2004-01-23'.  self assert: (String streamContents: [:arg1 |  tmp1 printDate: june2nd1973 format: #() on: arg1 ]) equals: '1973-06-02'reachedDefaultHandler  ^reachedDefaultHandlerprintArgumentsCount: arg1  ^arg1 printString , ' argument' , (arg1 = 1 ifTrue: [ '' ] ifFalse: [ 's' ])reduce  (self closeTo: self rounded) ifTrue: [ ^self rounded ]metacelloVersionComponentLessThan: arg1  ^self error: 'Invalid Metacello verson component - should be String or Integer.'offset  ^offsetunwindComplete: arg1  self tempAt: 2 put: arg1raisedToFraction: arg1  | tmp1 |  tmp1 := self nthRootTruncated: arg1 denominator.  (tmp1 raisedToInteger: arg1 denominator) = self ifTrue: [ ^tmp1 raisedToInteger: arg1 numerator ].  ^super raisedToFraction: arg1weakSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 category: arg6  ^self subclass: arg1 uses: arg2 layout: WeakLayout slots: arg3 asSlotCollection classVariablesNames: arg4 poolDictionaries: arg5 category: arg6isPrime  self <= 1 ifTrue: [ ^false ].  self even ifTrue: [ ^self = 2 ].  3 to: self sqrtFloor by: 2 do: [:arg1 |  self \\ arg1 = 0 ifTrue: [ ^false ] ].  ^trueinstVarAt: arg1  < primitive: 173 error: ec>  self primitiveFailedtestSubstracting02  | tmp1 |  tmp1 := '2004-01-07T11:55:00+00:00' asDateAndTime.  self assert: tmp1 - '2004-01-07T1:00:00+00:00' equals: (Duration fromString: '0:10:55:00')nearestPointOnLineFrom: arg1 to: arg2  ^(self nearestPointAlongLineFrom: arg1 to: arg2) adhereTo: (arg1 rectangle: arg2)testExample2  | tmp1 |  tmp1 := self class compiledMethodAt: #example2.  self deny: (self hasInstVarRef: tmp1)spotterRePropertiesFor: arg1  < spotterOrder: 0>  ReSettings spotterPlugin ifFalse: [ ^self ].  arg1 listProcessor     title: 'Renraku Properties';     items: [ self externalProperties asArray ];     itemName: #title;     itemIcon: #icon;     filter: GTFilterSubstringnegated  ^self copyto: (LargePositiveInteger new: self bytesCount)selectorsToBeIgnored  | tmp1 |  tmp1 := #(#printOn: #state:).  ^super selectorsToBeIgnored , tmp1shallowCopy  isEmpty  iterations isNil | elapsedTime isNil ifTrue: [ ^true ].  iterations isZero | elapsedTime isZero ifTrue: [ ^true ].  ^falsesetUp  super setUp.  atPragma := Pragma for: (Object methodDict at: #at:) selector: #primitive: arguments: (Array with: 60).  anotherAtPragma := Pragma for: (Object methodDict at: #at:) selector: #primitive: arguments: (Array with: 60).  yetAnotherAtPragma := Pragma for: (Object methodDict at: #at:) selector: #primitive: arguments: (Array with: 60).  atPutPragma := Pragma for: (Object methodDict at: #at:) selector: #primitive: arguments: (Array with: 61)even  ^((self byteAt: 1) bitAnd: 1) = 0testBeBetweenAnd  self assert: (10 beBetween: 5 and: 20) equals: 10.  self assert: (10 beBetween: 20 and: 5) equals: 10.  self assert: (5 beBetween: 5 and: 20) equals: 5.  self assert: (5 beBetween: 20 and: 5) equals: 5.  self assert: (20 beBetween: 5 and: 20) equals: 20.  self assert: (20 beBetween: 20 and: 5) equals: 20.  self assert: (1 beBetween: 5 and: 20) equals: 5.  self assert: (1 beBetween: 20 and: 5) equals: 5.  self assert: (30 beBetween: 5 and: 20) equals: 20.  self assert: (30 beBetween: 20 and: 5) equals: 20putOn: arg1  arg1 nextPut: selfhours  ^Duration hours: selftestOneArgument  | tmp1 |  tmp1 := WeakMessageSend receiver: Array selector: #with: argument: 1.  Smalltalk garbageCollectMost.  self assert: tmp1 value equals: {1}fileOutCommentOn: arg1  self classComment ifNil: [ ^self ].  arg1     cr;     nextChunkPut: self classComment stringvariableByteSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 category: arg4  ^self variableByteSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4methodsReferencingClass: arg1  ^self methodsReferencingClasses: {arg1}simpleRetryTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingString;     add: self doSomethingElseString;     yourselfallInstancesOrNil  < primitive: 177>  ^nilspotterMethodsFor: arg1  < spotterOrder: 10>  arg1 listProcessor     title: 'Instance methods';     allCandidates: [ self methods ];     itemName: [:arg2 |  arg2 selector ];     filter: GTFilterSubstringtestBounds  self should: [ Delay forMilliseconds: -1 ] raise: Error.  Delay forMilliseconds: SmallInteger maxVal // 2 + 1.  Delay forMilliseconds: SmallInteger maxVal + 1.  (Delay forMilliseconds: Float pi) waitproperties: arg1  self literalAt: self numLiterals - 1 put: (arg1 isEmpty ifTrue: [ arg1 selector ] ifFalse: [ arg1                 setMethod: self;                 yourself ])datesDo: arg1  self do: arg1 with: start asDategtListFilter  ^GTFilterSubstring newcull: arg1 cull: arg2  ^selector numArgs < 2 ifTrue: [ self cull: arg1 ] ifFalse: [ self value: arg1 value: arg2 ]hasLiteralThorough: arg1  (self penultimateLiteral isMethodProperties and: [ self penultimateLiteral hasLiteralThorough: arg1 ]) ifTrue: [ ^true ].  2 to: self numLiterals - 1 do: [:arg2 |  | tmp1 |        (((tmp1 := self objectAt: arg2) literalEqual: arg1) or: [ tmp1 isArray and: [ tmp1 hasLiteral: arg1 ] ]) ifTrue: [ ^true ].        (tmp1 isMemberOf: CompiledBlock) ifTrue: [ (tmp1 hasLiteralThorough: arg1) ifTrue: [ ^true ] ] ].  ^falselocalSeconds  ^seconds + self offset asSecondsisWords  ^self isBytes notspotterActDefault  ^self inspectisExternalType  ^falsespotterSuperclassesFor: arg1  < spotterOrder: 40>  arg1 listProcessor     title: 'All superclasses';     allCandidates: [ self allSuperclasses ];     itemIcon: #systemIcon;     filter: GTFilterSubstringtestYearMonthDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1980 month: 1 day: 1 hour: 0 minute: 0 second: 0)allMethodSelectors  ^protocolOrganizer allMethodSelectorstestAsDateAndTime  self assert: aDateAndTime asDateAndTime equals: aDateAndTimesecondFromBottom  self sender ifNil: [ ^nil ].  ^self findContextSuchThat: [:arg1 |  arg1 sender sender isNil ]fractionPart  < primitive: 52>  ^self - self truncated asFloat// arg1  ^(self / arg1) floortestParsingDPatternWithTwoDigitSucceeds  self assertReading: '29.11.2013' as: 'd.mm.yyyy' equals: (Date year: 2013 month: 11 day: 29)genPushInteger: arg1  arg1 = 0 ifTrue: [ stream nextPut: 80.        ^self ].  arg1 = 1 ifTrue: [ stream nextPut: 81.        ^self ].  (arg1 < 0 or: [ arg1 > 255 ]) ifTrue: [ ^self genPushIntegerLong: arg1 ].  stream     nextPut: 232;     nextPut: (arg1 bitAnd: 255)isStonReference  ^falseprimitiveError: arg1  UIManager default onPrimitiveError: arg1testNthRootTruncated  < timeout: 5>  | tmp1 tmp2 |  tmp1 := 1 << 2000.  self assert: (tmp1 nthRootTruncated: 100) equals: 1 << 20.  self assert: (tmp1 + 1 nthRootTruncated: 100) equals: 1 << 20.  self assert: (tmp1 - 1 nthRootTruncated: 100) equals: (1 << 20) - 1.  tmp2 := -3 raisedTo: 255.  self assert: (tmp2 nthRootTruncated: 17) equals: (-3 raisedTo: 15).  self assert: (tmp2 + 11 nthRootTruncated: 17) equals: (-3 raisedTo: 15) + 1.  self assert: (tmp2 - 11 nthRootTruncated: 17) equals: (-3 raisedTo: 15).  2 to: 10 do: [:arg1 |  1 to: 10000 do: [:arg2 |  | tmp3 |              tmp3 := arg2 nthRootTruncated: arg1.              self assert: (tmp3 raisedTo: arg1) <= arg2.              self assert: (tmp3 + 1 raisedTo: arg1) > arg2 ] ]testPrintOn  self assert: (String streamContents: [:arg1 |  aStopwatch printOn: arg1 ]) equals: 'a Stopwatch(suspended:0:00:00:00)'montgomeryDigitBase  ^1 << self montgomeryDigitLengthtestCompareWithIfLesserIfEqualIfGreater  self assert: ($b compareWith: $a ifLesser: [ 1 ] ifEqual: [ 2 ] ifGreater: [ 3 ]) equals: 3.  self assert: ($a compareWith: $b ifLesser: [ 1 ] ifEqual: [ 2 ] ifGreater: [ 3 ]) equals: 1.  self assert: ($b compareWith: $b ifLesser: [ 1 ] ifEqual: [ 2 ] ifGreater: [ 3 ]) equals: 2assertReading: arg1 as: arg2 equals: arg3  self assert: (self reading: arg2 pattern: arg1) equals: arg3sunitAnnounce: arg1 toResult: arg2  arg2 addFailure: arg1allTempNames  ^#()top  ^origin yasFilter  ^BlockFilter forBlock: selftestIfFalse  self assert: (false ifFalse: [ 'alternativeBlock' ]) equals: 'alternativeBlock'undeclaredName: arg1  undeclaredName := arg1name  ^'Illegal dependency of Bootstrap Layer'mcWorkingCopy  MCWorkingCopy managersForClass: self do: [:arg1 |  ^arg1 ]shouldBePrintedAsLiteral  ^self asInteger between: 33 and: 255asDate  ^Date starting: selfroundUpTo: arg1  ^(self / arg1) ceiling * arg1externalCallFailed  | tmp1 |  tmp1 := ExternalFunction getLastError.  ^self error: (ExternalFunction errorMessageFor: tmp1)testDivide  self assert: 1.5 / 2.0 equals: 0.75.  self assert: 2.0 / 1 equals: 2.0.  self should: [ 2.0 / 0 ] raise: ZeroDivide.  self should: [ 2.0 / 0.0 ] raise: ZeroDivide.  self should: [ 1.2 / Float negativeZero ] raise: ZeroDivide.  self should: [ 1.2 / (1.3 - 1.3) ] raise: ZeroDivideisLeapYear  ^start isLeapYearunusedBytecode: arg1 at: arg2  ^arg1 unusedBytecodesubject  ^organizedClasstestIsTitlecaseLetter  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isTitlecaseLetter: tmp2) equals: (tmp1 isTitlecaseLetter: tmp2) ]testSizeInMemoryLargeInstances  self     assert: Smalltalk allClasses sizeInMemory equals: (self align64Bits: self headerSize + (3 * Smalltalk wordSize));     assert: Smalltalk allClasses asArray sizeInMemory equals: (self align64Bits: self headerSize + (Smalltalk allClasses asArray size * Smalltalk wordSize) + self headerSize)genReturnTop  stream nextPut: 92dayOfWeek  ^(self julianDayNumber + 1 rem: 7) + 1initialize  super initialize.  mutex := Semaphore forMutualExclusion.  queuesMutex := Semaphore forMutualExclusion.  nestingLevel := 0errorImproperStore  self error: 'Improper store into indexable object'testNext  self assert: aTimespan next equals: (Timespan starting: (DateAndTime year: 2003 month: 4 day: 8 hour: 0 minute: 0 second: 0) duration: aDuration)asEpiceaRingDefinition  | tmp1 |  tmp1 := (RGClassDefinition named: self name)     category: self category;     superclassName: self superclass asString;     traitCompositionSource: self traitCompositionString;     addInstanceVariables: self instVarNames;     addClassVariables: self classVarNames;     addSharedPools: self sharedPoolNames;     comment: self organization classComment;     stamp: self organization commentStamp;     definitionSource: self oldDefinition;     package: (EpPlatform current packageNameFor: self);     withMetaclass.  tmp1 classSide     traitCompositionSource: self classSide traitCompositionString;     definitionSource: self classSide oldDefinition;     addInstanceVariables: self classSide instVarNames.  ^tmp1nowTick  ^vmSimNowtestUnixEpoch  self assert: DateAndTime unixEpoch equals: '1 January 1970 00:00+00:00' asDateAndTimeclassBuilder  ^self classInstaller new builderactivated  variable: arg1  variable := arg1testDivide  self assert: 2 / 1 equals: 2.  self assert: (3 / 2) isFraction.  self assert: 4 / 2 equals: 2.  self should: [ 1 / 0 ] raise: ZeroDividenegative  ^numerator negativetestEqualityInstanceSideMethod  | tmp1 tmp2 |  tmp1 := TestCase compiler compile: 'aMethod'.  tmp2 := TestCase compiler compile: 'aMethod'.  self assert: (tmp1 literalAt: tmp1 numLiterals) identicalTo: (tmp2 literalAt: tmp2 numLiterals).  self assert: tmp1 equals: tmp2addSlot: arg1  ^self subclassResponsibilityenvironment: arg1  environment := arg1initialPC  ^(self numLiterals + 1) * Smalltalk wordSize + 1stringForFileOut  ^String streamContents: [:arg1 |  self protocols do: [:arg2 |  arg1                 nextPut: $(;                 nextPutAll: arg2 name printString.              arg2 methodSelectors do: [:arg3 |  arg1                       space;                       nextPutAll: arg3 ].              arg1                 nextPut: $);                 cr ] ]seconds  ^self secondidentityHash  ^self basicIdentityHashreset  protocols := IdentitySet new.  allProtocol := AllProtocol protocolOrganizer: selflogCrTab: arg1  self deprecated: 'Please use trace* methods instead.' transformWith: '`@receiver logCrTab: `@statements1' -> '`@receiver traceCrTab: `@statements1'.  self traceCrTab: arg1testJulianDayNumber  self assert: aDateAndTime equals: (DateAndTime julianDayNumber: 2440588).  self assert: aDateAndTime julianDayNumber equals: 2440588montgomeryDigitMax  ^(1 << self montgomeryDigitLength) - 1haltIfNil  testToday  self deny: aDateAndTime equals: DateAndTime today/ arg1  arg1 isPoint ifTrue: [ ^(x / arg1 x) @ (y / arg1 y) ].  ^arg1 adaptToPoint: self andSend: #/testEncodingZeroSourcePointer  | tmp1 |  tmp1 := CompiledMethodTrailer new.  self assert: (tmp1 sourcePointer: 0) testEncoding sourcePointer equals: 0standardMessageText  ^String streamContents: [:arg1 |  arg1 print: self signaler class.        arg1 << ' had the subclass responsibility to implement '.        arg1 print: self selector ]testStoreOn  | tmp1 |  tmp1 := 42.  self assert: (String streamContents: [:arg1 |  tmp1 storeOn: arg1 ]) equals: '42'.  tmp1 := -42.  self assert: (String streamContents: [:arg1 |  tmp1 storeOn: arg1 ]) equals: ' -42'testTimeZone  aDateAndTime := '2004-02-29T13:33:00+00:00' asDateAndTime.  self assert: aDateAndTime timeZone name equals: 'Universal Time'.  self assert: aDateAndTime timeZone abbreviation equals: 'UTC'testWeeksDo  | tmp1 |  tmp1 := OrderedCollection new.  7 to: 98 by: 7 do: [:arg1 |  tmp1 addLast: (Week starting: (DateAndTime year: 2003 day: arg1) duration: 7 days) ].  tmp1 := tmp1 asArray.  self assert: aTimespan weeks equals: tmp1abbreviation  ^abbreviationtestWithRecursion  self should: [ self recursion ] notTakeMoreThanMilliseconds: 3haltIfTest  < debuggerCompleteToSender>  Halt ifTestasDuration  ^Duration seconds: seconds nanoSeconds: nanosasSeconds  ^Duration seconds: selftestAddSlotAnonymous  | tmp1 |  tmp1 := Object newAnonymousSubclass.  self assert: tmp1 getName isNil.  tmp1 := tmp1 addSlot: #x => InstanceVariableSlot.  self assert: tmp1 instVarNames equals: #('x').  self assert: tmp1 getName isNil.  tmp1 := tmp1 addSlot: #y => InstanceVariableSlot.  self assert: tmp1 getName isNil.  self assert: tmp1 instVarNames equals: #('x' 'y')testAsWeek  self assert: aDateAndTime asWeek equals: ((Week starting: '02-29-2004' asDate) translateTo: 2 hours)asFraction  ^selfat: arg1 put: arg2  | tmp1 |  tmp1 := self findElementOrNil: arg1.  (self basicAt: tmp1) ifNil: [ tally := tally + 1.        self basicAt: tmp1 put: arg1 ].  array at: tmp1 put: arg2.  arg1 flushCache.  self fullCheck.  ^arg2testArithmetic  | tmp1 |  tmp1 := june2nd1973 addDays: 32.  self     assert: (tmp1 subtractDate: june2nd1973) equals: 32;     assert: (june2nd1973 subtractDate: tmp1) equals: -32;     assert: (tmp1 subtractDays: 32) equals: june2nd1973subclasses: arg1  subclasses := arg1testRuleFailsIfAnyNewExternalDependencyFound  | tmp1 tmp2 tmp3 |  tmp1 := PharoBootstrapRule new.  tmp1 class classVarNamed: 'DependencyChecker' put: PharoBootstrapAnalyzerStubWithNewDependency.  tmp2 := RPackage named: #Kernel.  tmp3 := tmp1 check: tmp2.  self assert: tmp3 size equals: 1.  self assert: tmp3 anyOne sourceAnchor entity equals: tmp2actionForEvent: arg1  | tmp1 |  tmp1 := self actionMap at: arg1 asSymbol ifAbsent: [ ^nil ].  ^tmp1 asMinimalRepresentationprintOn: arg1 base: arg2 nDigits: arg3  self printOn: arg1 base: arg2 length: arg3 padded: trueallUnsentMessages  ^SystemNavigation new allUnsentMessagesIn: self selectorsgrow  | tmp1 |  tmp1 := self species newForCapacity: self basicSize * 2.  1 to: self basicSize do: [:arg1 |  (self basicAt: arg1) ifNotNil: [:arg2 |  tmp1 at: arg2 put: (array at: arg1) ] ].  self becomeForward: tmp1overriddenMethods  | tmp1 |  tmp1 := self selector.  ^self methodClass allSuperclasses select: [:arg1 |  arg1 includesSelector: tmp1 ] thenCollect: [:arg1 |  arg1 compiledMethodAt: tmp1 ]elapsedTime: arg1  elapsedTime := arg1isClosure  ^trueprivRestartBlockArgsNoRemoteTempsTest  self assert: 30 equals: ([:arg1 :arg2 |  | tmp1 |        self assert: 10 equals: arg1.        self assert: nil identicalTo: tmp1.        tmp1 := arg1 + 20.        arg2 ifTrue: [ thisContext tempAt: 2 put: false.              thisContext restart ].        tmp1 ] value: 10 value: true)simpleTimeoutTestResults  | tmp1 |  tmp1 := OrderedCollection new: self iterationsBeforeTimeout.  self iterationsBeforeTimeout timesRepeat: [ tmp1 add: self doSomethingString ].  tmp1 add: self doSomethingElseString.  ^tmp1possibleVariablesFor: arg1 continuedFrom: arg2  | tmp1 |  tmp1 := arg1 correctAgainstDictionary: self classPool continuedFrom: arg2.  self sharedPools do: [:arg3 |  tmp1 := arg1 correctAgainstDictionary: arg3 classPool continuedFrom: tmp1 ].  self superclass == nil ifTrue: [ ^arg1 correctAgainstDictionary: self environment continuedFrom: tmp1 ] ifFalse: [ ^self superclass possibleVariablesFor: arg1 continuedFrom: tmp1 ]ifTrue: arg1  self subclassResponsibilitytestDayMonthYearDo  | tmp1 |  tmp1 := 0.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  tmp1 := tmp1 + 1 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg3 ]) equals: 1980.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg2 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg1 ]) equals: 1testAsYear  self assert: aDateAndTime asYear equals: ((Year starting: '02-29-2004' asDate) translateTo: 2 hours).  self assert: aDateAndTime asYear equals: ((Year starting: '01-01-2004' asDate) translateTo: 2 hours)setPoint: arg1 point: arg2  origin := (arg1 x min: arg2 x) @ (arg1 y min: arg2 y).  corner := (arg1 x max: arg2 x) @ (arg1 y max: arg2 y)testRemoveProperty  self class propertyAt: #testKeySelector put: 1.  self class removeProperty: #testKeySelector.  self assert: (self class propertyAt: #testKeySelector) equals: niltestOne  self     assert: Integer one equals: 1;     assert: Float one equals: 1.0;     assert: Fraction one equals: 1testBigReceiverInexactNthRoot  | tmp1 tmp2 |  tmp1 := (100 factorial raisedTo: 3) + 1.  self assert: tmp1 asFloat isInfinite.  tmp2 := tmp1 nthRoot: 3.  self assert: tmp2 isFloat.  self deny: tmp2 isInfinite.  self assert: tmp2 equals: 100 factorial asFloat.  self assert: 100 factorial asFloat equals: (100 factorial + 1) asFloatasAnnotationContext  ^SimpleAnnotationContext of: selfsourceNode  ^self astallSubclassesWithLevelDo: arg1 startingLevel: arg2  | tmp1 |  arg1 value: self value: arg2.  self == Class ifTrue: [ ^self ].  tmp1 := SortedCollection new.  self subclassesDo: [:arg3 |  tmp1 add: arg3 name ].  tmp1 do: [:arg4 |  (self environment at: arg4) allSubclassesWithLevelDo: arg1 startingLevel: arg2 + 1 ]fileOutOn: arg1  ^self fileOutOn: arg1 initializing: trueisOctetCharacter  ^self asInteger < 256testTommorrow  self assert: DateAndTime today + 24 hours equals: DateAndTime tomorrow.  self deny: aDateAndTime equals: DateAndTime tomorrowsignBit  self < 0 ifTrue: [ ^1 ].  ^0printOn: arg1 base: arg2  arg2 = 10 ifFalse: [ self error: 'ScaledDecimals should be printed only in base 10' ].  self printOn: arg1millisecondsUntilTick: arg1  ^arg1 - self nowTick max: 0basicCategory: arg1  category := arg1testMinVal  Smalltalk vm wordSize = 4 ifTrue: [ self assert: SmallInteger minVal equals: -16r40000000 ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: SmallInteger minVal equals: -16r1000000000000000 ]asDoubleLink  ^DoubleLink value: selftestIsOtherPunctuation  self checkCorrespondanceOf: #isOtherPunctuation: and: #PotruncateTo: arg1  ^(self quo: arg1) * arg1isDefined  ^self isUndefined notunwindBlock  ^self tempAt: 1testPreviousInLeapYear  | tmp1 |  tmp1 := Year year: 2008.  self assert: tmp1 isLeapYear.  self assert: (Year year: tmp1 year - 1) equals: tmp1 previoustestPreviousNext  self     assert: week next equals: (Week starting: '6 July 1998' asDate);     assert: week previous equals: (Week starting: '22 June 1998' asDate)weakSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4  ^self weakSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: '' package: arg4allInstances  < primitive: 177>  | tmp1 tmp2 tmp3 |  tmp2 := WriteStream on: (Array new: 64).  tmp1 := self someInstance.  [ tmp1 == nil ] whileFalse: [ tmp3 := tmp1 nextInstance.        (tmp1 == tmp2 or: [ tmp1 == tmp2 originalContents ]) ifFalse: [ tmp2 nextPut: tmp1 ].        tmp1 := tmp3 ].  ^tmp2 contentsasFloat  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := self highBitOfMagnitude - Float precision.  tmp3 > 7 ifTrue: [ tmp1 := self bitShiftMagnitude: 7 - tmp3.        tmp2 := tmp3 - 7.        ((tmp1 byteAt: 1) = 2r01000000 and: [ self anyBitOfMagnitudeFrom: 1 to: tmp2 ]) ifTrue: [ tmp1 := tmp1 + 1 ] ] ifFalse: [ tmp1 := self.        tmp2 := 0 ].  tmp4 := (tmp1 byteAt: (tmp5 := tmp1 bytesCount)) asFloat.  [ (tmp5 := tmp5 - 1) > 0 ] whileTrue: [ tmp4 := 256.0 * tmp4 + (tmp1 byteAt: tmp5) asFloat ].  ^tmp4 timesTwoPower: tmp2terminateTo: arg1  < primitive: 196>  | tmp1 tmp2 |  (self hasSender: arg1) ifTrue: [ tmp1 := sender.        [ tmp1 == arg1 ] whileFalse: [ tmp2 := tmp1 sender.              tmp1 terminate.              tmp1 := tmp2 ] ].  sender := arg1brickValue: arg1 withEnoughArguments: arg2  ^arg1 withArgs: arg2 executeMethod: selfcaseOf: arg1  ^self caseOf: arg1 otherwise: [ self caseError ]testUnwindFromForeignProcess  | tmp1 tmp2 |  tmp1 := Semaphore forMutualExclusion.  self assert: tmp1 isSignaled.  tmp2 := [ tmp1 critical: [ self deny: tmp1 isSignaled.        tmp1 wait ] ] forkAt: Processor userInterruptPriority.  self deny: tmp1 isSignaled.  tmp2 terminate.  self assert: tmp1 isSignaledbeBetween: arg1 and: arg2  ^arg1 <= arg2 ifTrue: [ (self min: arg2) max: arg1 ] ifFalse: [ (self min: arg1) max: arg2 ]testIsNil  self assert: nil isNilmatchesQueryBrowserFilter: arg1  ^self calypsoEnvironmentType match: self forQueryBrowserFilter: arg1crLog  self deprecated: 'Please use #crTrace instead' transformWith: '`@receiver crLog' -> '`@receiver crTrace'.  self crTracetestSeconds  self assert: aDuration seconds equals: 4.  self assert: (Duration nanoSeconds: 2) seconds equals: 0.  self assert: (Duration seconds: 2) seconds equals: 2.  self assert: (Duration days: 1 hours: 2 minutes: 3 seconds: 4) seconds equals: 4.  self deny: (Duration days: 1 hours: 2 minutes: 3 seconds: 4) seconds equals: 1 * 24 * 60 * 60 + (2 * 60 * 60) + (3 * 60) + 4fileOutChangedMessages: arg1 on: arg2  | tmp1 |  (tmp1 := self organization) categories do: [:arg3 |  | tmp2 |        tmp2 := (tmp1 listAtCategoryNamed: arg3) select: [:arg4 |  arg1 includes: arg4 ].        tmp2 do: [:arg4 |  self printMethodChunk: arg4 on: arg2 ] ]waitWhile: arg1 maxMilliseconds: arg2  ^self waitWhile: arg1 for: nil maxMilliseconds: arg2waddle: arg1  ^(arg1 isNotNil and: [ arg1 isMemberOf: ValueLink ]) ifTrue: [ | tmp1 tmp2 |        tmp1 := arg1 value.        tmp2 := arg1 nextLink.        (tmp1 isKindOf: Link) ifTrue: [ self waddle: tmp1 ] ifFalse: [ Continuation currentDo: [:arg2 |  fill := arg2.                    leave value: tmp1 ] ].        self waddle: tmp2 ]hasModelYellowButtonMenuItems  ^Morph cmdGesturesEnabledstonOn: arg1  arg1 writeFraction: selfcritical: arg1 ifError: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := false.  self critical: [ tmp1 := arg1 ifError: [:arg3 :arg4 |  tmp2 := true.              tmp3 := arg3.              tmp4 := arg4 ] ].  tmp2 ifTrue: [ ^arg2 cull: tmp3 cull: tmp4 ].  ^tmp1testParsingYPatternWithSingleDigitReturnsASecondMillenaryYear  self assertReading: '2.11.3' as: 'd.mm.y' equals: (Date year: 2003 month: 11 day: 2)javascriptOn: arg1  arg1 nextPutAll: 'new Date('.  #(year javascriptMonthIndex dayOfMonth) do: [:arg2 |  arg1 javascript: (self perform: arg2) ] separatedBy: [ arg1 nextPut: $, ].  arg1 nextPut: $)isPowerOfTwo  ^self ~= 0 and: [ (self bitAnd: self - 1) = 0 ]exp  < primitive: 59>  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self < 0.0 ifTrue: [ ^self negated exp reciprocal ].  self = 0.0 ifTrue: [ ^1 ].  self abs > MaxValLn ifTrue: [ self error: 'exp overflow' ].  tmp1 := E raisedToInteger: self truncated.  tmp2 := self fractionPart.  tmp2 = 0.0 ifTrue: [ ^tmp1 ].  tmp3 := 1.0 + tmp2.  tmp4 := tmp2 * tmp2 / 2.0.  tmp5 := 2.0.  [ tmp4 > Epsilon ] whileTrue: [ tmp3 := tmp3 + tmp4.        tmp5 := tmp5 + 1.0.        tmp4 := tmp4 * tmp2 / tmp5 ].  tmp3 := tmp3 + tmp4.  ^tmp1 * tmp3testInheritingExecutionEnvironment  | tmp1 tmp2 |  tmp1 := ExecutionEnvironmentStub new.  tmp1 beActiveDuring: [ tmp2 := [ self assert: CurrentExecutionEnvironment value equals: tmp1 ] fork ].  self assert: tmp1 forkedProcesses anyOne equals: tmp2compactWithoutBecome  | tmp1 |  tmp1 := self species new: self size.  1 to: self basicSize do: [:arg1 |  (self basicAt: arg1) ifNotNil: [:arg2 |  tmp1 at: arg2 put: (array at: arg1) ] ].  ^tmp1\\ arg1  ^self - (self // arg1 * arg1)testParsingDDPatternWithIncorrectDaysFails  self assertReading: '02.00.2013' as: 'dd.mm.yyyy' raise: DateError.  self assertReading: '02.13.2013' as: 'dd.mm.yyyy' raise: DateErrorvariableSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 category: arg6  ^self subclass: arg1 uses: arg2 layout: VariableLayout slots: arg3 asSlotCollection classVariablesNames: arg4 poolDictionaries: arg5 category: arg6localAt: arg1  ^self at: arg1triangleArea: arg1 with: arg2  ^(arg1 x - self x) * (arg2 y - self y) - ((arg1 y - self y) * (arg2 x - self x))testDay  self assert: aDateAndTime day equals: DateAndTime new daytestDaysInMonth  self assert: aDateAndTime daysInMonth equals: 29terminate  sender := nil.  pc := nilclassAnnotationAt: arg1  ^self classAnnotations detect: [:arg2 |  arg2 declarationSelector = arg1 ]isFloatPoint  ^x isFloat and: [ y isFloat ]fuelAccept: arg1  ^arg1 visitHookPrimitive: selfrotateBy: arg1 about: arg2  | tmp1 tmp2 tmp3 |  tmp1 := self - arg2.  tmp2 := tmp1 r.  tmp3 := arg1 asFloat - tmp1 theta.  ^(arg2 x asFloat + (tmp2 * tmp3 cos)) @ (arg2 y asFloat - (tmp2 * tmp3 sin))raisedToInteger: arg1  ^self class newFromNumber: (super raisedToInteger: arg1) scale: scalepaintFillsUsing: arg1 on: arg2  ^arg1 athensFillRectangle: self on: arg2as31BitSmallInt  self highBit = 31 ifFalse: [ self error: 'more than 31 bits can not fit in a SmallInteger' ].  ^self - 16r80000000hasProperty: arg1  self propertyAt: arg1 ifAbsent: [ ^false ].  ^truesystemClassNames  ^#(BoxedFloat64 SmallFloat64)ifNotNil: arg1 ifNil: arg2  ^arg1 cull: selftestDaysInMonth  self assert: (Month daysInMonth: 2 forYear: 2000) equals: 29.  self assert: (Month daysInMonth: 2 forYear: 2001) equals: 28.  self assert: (Month daysInMonth: 2 forYear: 2004) equals: 29.  self assert: (Month daysInMonth: 2 forYear: 2100) equals: 28.  self assert: (Month daysInMonth: 'January' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'February' forYear: 2003) equals: 28.  self assert: (Month daysInMonth: 'March' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'April' forYear: 2003) equals: 30.  self assert: (Month daysInMonth: 'May' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'June' forYear: 2003) equals: 30.  self assert: (Month daysInMonth: 'July' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'August' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'September' forYear: 2003) equals: 30.  self assert: (Month daysInMonth: 'October' forYear: 2003) equals: 31.  self assert: (Month daysInMonth: 'November' forYear: 2003) equals: 30.  self assert: (Month daysInMonth: 'December' forYear: 2003) equals: 31hour  ^self hour24initializeBasicMethods  testMonthsDo  | tmp1 |  tmp1 := Array with: (Month starting: (DateAndTime year: 2004 day: 355) duration: 31 days) with: (Month starting: (DateAndTime year: 2005 day: 1) duration: 31 days) with: (Month starting: (DateAndTime year: 2005 day: 32) duration: 29 days) with: (Month starting: (DateAndTime year: 2005 day: 61) duration: 31 days).  self assert: aTimespan months equals: tmp1hash  ^receiver hash bitXor: selector hashlongPrintString  | tmp1 |  tmp1 := String streamContents: [:arg1 |  self longPrintOn: arg1 ].  ^tmp1 isEmpty ifTrue: [ self printString , String cr ] ifFalse: [ tmp1 ]allMethods  ^self allSelectors asArray collect: [:arg1 |  self lookupSelector: arg1 ]phlowValue: arg1 value: arg2  ^arg1instVarsInclude: arg1  < primitive: 132>  1 to: self class instSize do: [:arg2 |  (self instVarAt: arg2) == arg1 ifTrue: [ ^true ] ].  1 to: self basicSize do: [:arg2 |  (self basicAt: arg2) == arg1 ifTrue: [ ^true ] ].  ^falsetestOrigin  | tmp1 tmp2 |  tmp1 := Behavior >> #name.  tmp2 := Behavior >> #adoptInstance:.  self assert: tmp1 origin identicalTo: tmp1 originMethod methodClass.  self assert: tmp2 origin identicalTo: tmp2 originMethod methodClasstestPrimesUpTo  | tmp1 tmp2 |  tmp1 := Integer primesUpTo: 100.  self assert: tmp1 equals: #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97).  tmp1 := Integer primesUpTo: 5.  self assert: tmp1 equals: #(2 3).  tmp2 := 5.  self deny: (Integer primesUpTo: tmp2) last equals: tmp2.  self assert: (Integer primesUpTo: tmp2 + 1) last equals: tmp2testIsNil  self deny: ProtoObject new isNiltestPrintString  | tmp1 tmp2 |  tmp1 := DateAndTime year: 2004 month: 11 day: 2 hour: 14 minute: 3 second: 5 nanoSecond: 12345 offset: (Duration seconds: 5 * 3600).  self assert: tmp1 printString equals: '2004-11-02T14:03:05.000012345+05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: ' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime printString equals: '2002-05-16T17:20:45+00:00'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime printString equals: '2002-05-16T17:20:45-02:34'.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime printString equals: '2002-05-16T17:20:45+00:00'.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime printString equals: '1997-04-26T01:02:03+01:02:3'.  tmp2 := '2002-05-16T17:20' asDateAndTime.  self assert: (('2002-05-16T17:20:00*' match: tmp2 printString) and: [ tmp2 offset = DateAndTime localOffset ])hash  | tmp1 tmp2 tmp3 |  tmp1 := self initialPC.  tmp2 := self endPC.  tmp3 := self species hash + self header + tmp1 + tmp2.  tmp1 to: tmp2 by: ((tmp2 - tmp1) // 20 max: 1) do: [:arg1 |  tmp3 := tmp3 + (self at: arg1) ].  ^tmp3testReadFromWithError  | tmp1 |  tmp1 := 'invalid'.  self should: [ self timeClass readFrom: tmp1 readStream ] raise: Error.  tmp1 := '0:invalid'.  self should: [ self timeClass readFrom: tmp1 readStream ] raise: Errory  ^ygenBranchPopTrue: arg1  (arg1 > 0 and: [ arg1 < 9 ]) ifTrue: [ stream nextPut: 183 + arg1.        ^self ].  ^self genBranchPopTrueLong: arg1testMutateWideStringUsingWordAtPut  | tmp1 |  tmp1 := 'hello' asWideString.  tmp1 beReadOnlyObject.  self should: [ tmp1 wordAt: 1 put: 65536 ] raise: ModificationForbidden.  [ tmp1 wordAt: 1 put: 65536 ] on: ModificationForbidden do: [:arg1 |  self assert: arg1 fieldIndex equals: 1.        arg1 object beWritableObject.        arg1 retryModification ].  self assert: tmp1 first asciiValue equals: 65536phlowValue: arg1  ^selfnextObject  < primitive: 139>  self primitiveFailedspotterClassMethodsFor: arg1  < spotterOrder: 15>  arg1 listProcessor     title: 'Class methods';     allCandidates: [ self classSide methods ];     itemName: [:arg2 |  arg2 selector ];     filter: GTFilterSubstringpluralize: arg1  ^self pluralize: arg1 with: (GRInflector pluralize: arg1)simplePassTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:arg1 |  self doYetAnotherThing.        arg1 pass ]asRingDefinitionWithMethods: arg1 withSuperclasses: arg2 withSubclasses: arg3 withPackages: arg4  | tmp1 tmp2 tmp3 |  tmp2 := RGSlice named: #fromImage.  arg4 ifTrue: [ tmp3 := tmp2 loadPackagesFromImage ].  tmp1 := self asRingDefinitionWithMethods: arg1 withSuperclasses: arg2 withSubclasses: arg3 withPackageKeys: tmp3 in: tmp2.  tmp2 cleanEmptyPackages.  tmp2 loadTraitUsers.  ^tmp1testEmbeddingCompressedSourceCode  | tmp1 tmp2 tmp3 |  tmp1 := CompiledMethodTrailer new.  tmp3 := 'foo'.  tmp1 compressSourceCode: tmp3.  tmp2 := tmp1 testEncoding.  self assert: tmp1 kind identicalTo: #EmbeddedSourceQCompress.  self assert: tmp2 sourceCode equals: tmp3.  self assert: tmp2 endPC equals: 0.  tmp3 := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: newTrailer sourceCode equals: code.'.  tmp1 compressSourceCode: tmp3.  self assert: tmp1 kind identicalTo: #EmbeddedSourceZip.  tmp2 := tmp1 testEncoding.  self assert: tmp2 sourceCode equals: tmp3.  self assert: tmp2 endPC equals: 0testAllSelectorsAbove  | tmp1 |  tmp1 := Date allSelectorsAbove.  self deny: (tmp1 includes: #mmddyyyy).  self deny: (tmp1 includes: #weekday).  self assert: (tmp1 includes: #at:).  self assert: (tmp1 includes: #cannotInterpret:)methodClass  ^self method methodClass ifNil: [ self receiver class ]rename: arg1  | tmp1 tmp2 |  (tmp2 := arg1 asSymbol) = (tmp1 := self name) ifTrue: [ ^self ].  (self environment includesKey: tmp2) ifTrue: [ ^self error: tmp2 , ' already exists' ].  self setName: tmp2.  self environment renameClass: self from: tmp1.  (Undeclared includesKey: tmp2) ifTrue: [ self inform: 'There are references to, ' , arg1 printString , 'from Undeclared. Check them after this change.' ]longPrintOn: arg1  | tmp1 |  super printOn: arg1.  arg1 cr.  tmp1 := self suspendedContext.  [ tmp1 isNil ] whileFalse: [ arg1 space.        tmp1 printOn: arg1.        arg1 cr.        tmp1 := tmp1 sender ]reciprocalFloorLog: arg1  | tmp1 tmp2 tmp3 |  tmp1 := 0.  tmp2 := 1.0.  [ (tmp3 := arg1 / (self * tmp2)) isInfinite ] whileTrue: [ tmp2 := tmp2 * arg1.        tmp1 := tmp1 + 1 ].  ^((tmp3 floorLog: arg1) + tmp1) negated/ arg1  self subclassResponsibilitytemporaryVariables  ^self tempNames collect: [:arg1 |  TemporaryVariable new name: arg1 ]testcurrentYearNumber  | tmp1 |  tmp1 := Year currentYearNumber.  self assert: Date today year equals: tmp1fuelAccept: arg1  ^arg1 visitCompiledMethod: selfprimOffset  < primitive: 'primitiveTimezoneOffset' module: 'LocalePlugin'>  ^0testMonthsDo  | tmp1 |  tmp1 := Array with: (Month starting: (DateAndTime year: 2003 day: 1) duration: 31 days) with: (Month starting: (DateAndTime year: 2003 day: 32) duration: 28 days) with: (Month starting: (DateAndTime year: 2003 day: 60) duration: 31 days) with: (Month starting: (DateAndTime year: 2003 day: 91) duration: 30 days).  self assert: aTimespan months equals: tmp1testTimeZone  self assert: aDateAndTime timeZoneName equals: 'Universal Time'.  self assert: aDateAndTime timeZoneAbbreviation equals: 'UTC'testPropertyValueAtPut  | tmp1 |  tmp1 := Date today.  self class propertyAt: #testKeySelector put: tmp1.  self assert: (self class propertyAt: #testKeySelector) equals: tmp1.  self class removeProperty: #testKeySelectornot  ^falseremoveSubclass: arg1  self subclasses == nil ifFalse: [ self subclasses: (self subclasses copyWithout: arg1).        self subclasses isEmpty ifTrue: [ self subclasses: nil ] ]yield  < primitive: 167>  | tmp1 |  tmp1 := Semaphore new.  [ tmp1 signal ] fork.  tmp1 waitisResumable  ^trueinternalChangeFromString: arg1  protocolOrganizer := ProtocolOrganizer fromSpec: arg1home  ^outerContext ifNotNil: [ outerContext home ]asDays  ^self asHours / 24absPrintOn: arg1 base: arg2 digitCount: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  self isInfinite ifTrue: [ ^arg1 nextPutAll: 'Infinity' ].  tmp5 := arg2 asFloat.  tmp3 := self floorLog: tmp5.  tmp6 := 1.0.  tmp7 := 0.  [ (tmp2 := tmp5 raisedTo: tmp3 + tmp7) = 0 ] whileTrue: [ tmp6 := tmp6 * tmp5.        tmp7 := tmp7 + 1 ].  tmp2 := self * tmp6 / tmp2.  tmp1 := tmp5 raisedTo: 1 - arg3.  tmp2 := 0.5 * tmp1 + tmp2.  tmp2 >= tmp5 ifTrue: [ tmp2 := tmp2 / tmp5.        tmp3 := tmp3 + 1 ].  (tmp3 < 6 and: [ tmp3 > -4 ]) ifTrue: [ tmp4 := 0.        tmp3 < 0 ifTrue: [ 1 to: 1 - tmp3 do: [:arg4 |  arg1 nextPut: ('0.0000' at: arg4) ] ] ] ifFalse: [ tmp4 := tmp3.        tmp3 := 0 ].  [ tmp2 >= tmp1 ] whileTrue: [ tmp8 := tmp2 asInteger.        arg1 nextPut: (Character digitValue: tmp8).        tmp2 := (tmp2 - tmp8 asFloat) * tmp5.        tmp1 := tmp1 * tmp5.        tmp3 := tmp3 - 1.        tmp3 = -1 ifTrue: [ arg1 nextPut: $. ] ].  [ tmp3 >= -1 ] whileTrue: [ arg1 nextPut: $0.        tmp3 := tmp3 - 1.        tmp3 = -1 ifTrue: [ arg1 nextPut: $. ] ].  tmp4 ~= 0 ifTrue: [ arg1 nextPut: $e.        tmp4 printOn: arg1 ]sourceCode: arg1  ^self embeddedSourceCode: arg1bottomContext  ^self findContextSuchThat: [:arg1 |  arg1 sender isNil ]removePropertiesIfEmpty  ^ClassProperties at: self ifPresent: [:arg1 |  arg1 ifEmpty: [ ClassProperties removeKey: self ] ]testParsingDPatternWithIncorrectDayFails  self assertReading: '0.11.2013' as: 'd.mm.yyyy' raise: DateError.  self assertReading: '32.2013.29' as: 'd.mm.yyyy' raise: DateErrornotNil  ^truetruncated  ^self species basicNew ticks: {julianDayNumber .         seconds .         0} offset: offsetisProbablyPrime  | tmp1 tmp2 tmp3 |  self <= 1 ifTrue: [ ^false ].  self even ifTrue: [ ^self = 2 ].  tmp2 := self bitShift: -1.  tmp1 := tmp2 lowBit.  tmp2 := tmp2 bitShift: 1 - tmp1.  tmp3 := #(0.816980664067427 0.9940209812456839 0.5106317962103671 0.18859890764048273 0.7818407135931034 0.39687335928756434 0.25054954609393587 0.9862212007801148 0.41972151138806785 0.25944189925652084 0.44000080434605515 0.09351864414919105 0.7678522154539136 0.292185133924794 0.7555458740124227 0.4595045267881381 0.8925817282370206 0.621106479606175 0.9366027409846908 0.48226772969694237 0.47373301651036975 0.030808489784043512 0.7982878004192784 0.8230616468112272 0.19709795629470514).  tmp3 do: [:arg1 |  (self isProbablyPrimeWithK: tmp1 andQ: tmp2 randomIndex: arg1) ifFalse: [ ^false ] ].  ^trueasClassDefinition  self needsSlotClassDefinition ifFalse: [ ^MCClassDefinition name: self name superclassName: (self superclass ifNil: [ nil asString ] ifNotNil: [ self superclass name ]) traitComposition: self traitCompositionString classTraitComposition: self class traitCompositionString category: self category instVarNames: (self localSlots collect: #name) classVarNames: self classVarNames poolDictionaryNames: self sharedPoolNames classInstVarNames: (self class localSlots collect: #name) type: self typeOfClass comment: self organization classComment asString commentStamp: self organization commentStamp ].  ^MCClassDefinition name: self name superclassName: (self superclass ifNil: [ nil asString ] ifNotNil: [ self superclass name ]) traitComposition: self traitCompositionString classTraitComposition: self class traitCompositionString category: self category instVarNames: (self localSlots collect: #definitionString) classVarNames: (self classVariables collect: #definitionString) poolDictionaryNames: self sharedPoolNames classInstVarNames: (self class localSlots collect: #definitionString) type: self typeOfClass comment: self organization classComment asString commentStamp: self organization commentStamparguments  | tmp1 tmp2 |  tmp2 := self method numArgs.  tmp1 := Array new: tmp2.  1 to: tmp2 do: [:arg1 |  tmp1 at: arg1 put: (self tempAt: arg1) ].  ^tmp1isReceiverGarbage  ^self receiver isNil= arg1  self == arg1 ifTrue: [ ^true ].  self species = arg1 species ifFalse: [ ^false ].  ^self hasEqualTicks: arg1ctrl  ^KMModifier ctrl + selfasCalypsoBrowserItem  ^self calypsoEnvironmentType convertToCalypsoBrowserItem: selfbaseClass  self deprecated: 'Please use #instanceSide instead' transformWith: '`@receiver baseClass' -> '`@receiver instanceSide'.  ^self instanceSidetestNew  self assert: self timeClass new asSeconds equals: 0assertInvariant  [ elementArray size = categoryStops last ] asserttestSupplySameAnswerToAllQuestions  self should: [ true = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: true) ].  self should: [ #(true true) = ([ {(self confirm: 'One') .               (self confirm: 'Two')} ] valueSupplyingAnswer: true) ]asExternalTypeOn: arg1  ^FFIConst value: self type: (arg1 resolveType: #int32)gtInspectorDefinitionIn: arg1  < gtInspectorPresentationOrder: 15>  arg1 pharoScript     title: 'Definition';     display: [ self definition ]monthsDo: arg1  self do: arg1 with: start asMonthtestTo  self assert: (aDateAndTime to: aDateAndTime) equals: (DateAndTime new to: DateAndTime new)julianDayNumberUTC  ^start julianDayNumberUTCprintOn: arg1  arg1     nextPutAll: self class name;     nextPut: $(.  selector printOn: arg1.  arg1 nextPutAll: ' -> '.  receiver printOn: arg1.  arg1 nextPut: $)testPrintStringNanos  self assert: (Time hour: 15 minute: 15 second: 15 nanoSecond: 150 * 1000000) printString equals: '3:15:15.15 pm'asUnicodeChar  ^Unicode charFromUnicode: self asUnicodelink: arg1 toSlotNamed: arg2 option: arg3  arg1 installOnSlotNamed: arg2 for: self option: arg3 instanceSpecific: self intanceSpecificMetaLinksAvailabletestDegreeCos  45 degreeCos.  self assert: (45 degreeCos squared - (1 / 2)) abs <= Float epsilon.  self assert: (60 degreeCos - (1 / 2)) abs <= Float epsilon.  self assert: (120 degreeCos + (1 / 2)) abs <= Float epsilon.  -360 to: 360 do: [:arg1 |  self assert: (arg1 degreeCos closeTo: arg1 degreesToRadians cos) ].  -10 to: 10 do: [:arg2 |  self assert: (arg2 * 360 + 90) degreeCos equals: 0.        self assert: (arg2 * 360 - 90) degreeCos equals: 0.        self assert: (arg2 * 360 + 180) degreeCos + 1 equals: 0.        self assert: (arg2 * 360) degreeCos - 1 equals: 0 ]asByteArray  | tmp1 |  tmp1 := ByteArray new writeStream.  self bytesCount to: 1 by: -1 do: [:arg1 |  tmp1 nextPut: (self byteAt: arg1) ].  ^tmp1 contentsgenSendSpecial: arg1 numArgs: arg2  self assert: (arg1 between: 1 and: Smalltalk specialSelectorSize).  self assert: arg2 = (Smalltalk specialNargsAt: arg1).  stream nextPut: arg1 + 175testParsingDDPatternWithSingleDigitFails  self assertReading: '4.02.2345' as: 'dd.mm.yyyy' raise: DateErrordescription  ^String streamContents: [:arg1 |  | tmp1 |        arg1 << self class name.        (tmp1 := self messageText) isEmptyOrNil ifFalse: [ arg1 << ': ' << tmp1 ] ]asLocal  ^self offset = self class localOffset ifTrue: [ self ] ifFalse: [ self offset: self class localOffset ]phlowValue: arg1 value: arg2  ^selftemporaryVariableNamed: arg1  (self hasTemporaryVariableNamed: arg1) ifFalse: [ ^nil ].  ^TemporaryVariable name: arg1 block: selfwait  self schedule.  [ delaySemaphore wait ] ifCurtailed: [ self unschedule ]testNthRootExactness  | tmp1 tmp2 |  tmp2 := (2 to: 100) collect: [:arg1 |  arg1 raisedTo: 66 ].  tmp1 := tmp2 reject: [:arg2 |  (arg2 nthRoot: 6) isInteger ].  self assert: tmp1 isEmpty description: 'Failed to find the exact 6th root of these numbers'complexContents  ^selfhasArguments  ^args notEmptyrealClass  ^self methodClasstestIsSpaceSeparator  self checkCorrespondanceOf: #isSpaceSeparator: and: #ZssendingMethodName  ^self contextOfSender method printString| arg1  self subclassResponsibilitytestEncoding  encodedData ifNil: [ self encode ].  ^CompiledMethodTrailer new method: encodedDatanewProcessWith: arg1  < primitive: 19>  ^Process forContext: [ self valueWithArguments: arg1.        Processor terminateActive ] asContext priority: Processor activePriorityidentityHash  ^self hashMultiplyhumanReadableSIByteSizeOn: arg1  | tmp1 tmp2 |  tmp2 := 1000.  self < tmp2 ifTrue: [ ^arg1           print: self;           space;           nextPut: $B ].  tmp1 := (self log / tmp2 log) asInteger.  self / (tmp2 ** tmp1) printOn: arg1 showingDecimalPlaces: 2.  arg1     space;     nextPut: ('kMGTPE' at: tmp1);     nextPut: $BencodeEmbeddedSource  | tmp1 tmp2 tmp3 |  tmp1 := data size.  tmp2 := WriteStream on: (ByteArray new: tmp1).  tmp3 := self encodeLengthField: tmp1.  tmp2     nextPutAll: data asByteArray;     nextPutAll: tmp3;     nextPut: self kindAsByte + tmp3 size - 1.  encodedData := tmp2 contentsast  ^self sourceNodeInOuterreadClassVariableNamed: arg1  ^(self classVariableNamed: arg1) readsetUp  super setUp.  value := 0stonContainSubObjects  ^falsecopyAll: arg1 from: arg2 classified: arg3  arg1 do: [:arg4 |  (arg2 includesLocalSelector: arg4) ifTrue: [ self copy: arg4 from: arg2 classified: arg3 ] ]quo: arg1  < primitive: 13>  arg1 = 0 ifTrue: [ ^(ZeroDivide dividend: self) signal ].  (arg1 isMemberOf: SmallInteger) ifFalse: [ ^super quo: arg1 ].  (arg1 = -1 and: [ self = self class minVal ]) ifTrue: [ ^self negated ].  self primitiveFailedstoreStringBase: arg1 length: arg2 padded: arg3  ^String streamContents: [:arg4 |  self storeOn: arg4 base: arg1 length: arg2 padded: arg3 ]asInteger  ^selftagsForAllMethods  | tmp1 |  tmp1 := self organization protocols reject: [:arg1 |  arg1 name = Protocol unclassified | arg1 isExtensionProtocol ].  ^tmp1 select: [:arg2 |  arg2 methodSelectors ifEmpty: [ true ] ifNotEmpty: [:arg3 |  arg3 anySatisfy: [:arg4 |  self selectors includes: arg4 ] ] ] thenCollect: #nameisRequired  ^self isRequired: self markerOrNilscaleTo: arg1  | tmp1 tmp2 tmp3 |  tmp1 := 3.0 reciprocal.  tmp2 := arg1 x / self x asFloat.  tmp3 := arg1 y / self y asFloat.  tmp2 = tmp3 ifTrue: [ ^tmp2 @ tmp3 ].  ^tmp2 < tmp3 ifTrue: [ tmp2 @ (tmp2 max: tmp3 * tmp1) ] ifFalse: [ (tmp3 max: tmp2 * tmp1) @ tmp3 ]testIsOtherLetter  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isOtherLetter: tmp2) equals: (tmp1 isOtherLetter: tmp2) ]testBenchFor  | tmp1 tmp2 tmp3 |  tmp2 := 500 milliSeconds.  tmp1 := [ 100 factorial ] benchFor: tmp2.  self deny: tmp1 isEmpty.  self assert: tmp1 elapsedTime >= tmp2.  tmp3 := 10.  self assert: tmp1 iterations > tmp3.  self assert: tmp1 period < (tmp2 / tmp3)testDigitSumOnNegative  self assert: -1234 digitSum equals: 10readXandY  ^x + ytestTerminationShouldProceedAllEnsureBlocksIfSomeWasFailed  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := Error new messageText: 'signalled inside ensure'.  tmp1 := false.  tmp5 := false.  tmp2 := [ [ [ tmp5 := true.  10 seconds wait ] ensure: [ tmp3 signal ] ] ensure: [ tmp1 := true ] ] fork.  [ tmp5 ] whileFalse: [ Processor yield ].  tmp2 terminate.  Processor yield.  self assert: tmp1.  tmp4 := TestExecutionEnvironment currentFailures.  self assert: tmp4 size equals: 2.  self assert: tmp4 first equals: tmp3.  self assert: tmp4 last class equals: UnwindError.  self assert: tmp4 last signalerContext exception equals: tmp3.  TestExecutionEnvironment resetFailurestestSimpleCommunication  | tmp1 tmp2 tmp3 |  tmp2 := tmp3 := false.  tmp1 := Semaphore new.  [ tmp2 := true.  tmp1 wait.  tmp3 := true ] fork.  Processor yield.  self assert: tmp2.  self deny: tmp3.  tmp1 signal.  Processor yield.  self assert: tmp3genPushSpecialLiteral: arg1  | tmp1 |  arg1 isInteger ifTrue: [ arg1 == 0 ifTrue: [ stream nextPut: 80.              ^self ].        arg1 == 1 ifTrue: [ stream nextPut: 81.              ^self ].        ^self genPushInteger: arg1 ].  tmp1 := #(true false nil) indexOf: arg1 ifAbsent: [ ^self error: 'push special literal: ' , arg1 printString , ' is not one of true false nil' ].  stream nextPut: 76 + tmp1adaptToFloat: arg1 andSend: arg2  ^arg1 perform: arg2 with: self asFloatname  ^'Local Time'runBasicANSISignaledExceptionTests  self basicANSISignaledExceptionTestSelectors do: [:arg1 |  self runTest: arg1 ]realClass  ^selfshouldBeImplemented  ShouldBeImplemented signalFor: thisContext sender selectorx23kbits  ^(11 to: 44 by: 4) inject: 1234567890 into: [:arg1 :arg2 |  (arg1 * arg1 << arg2) + arg2 ]testIsDashPunctuation  self checkCorrespondanceOf: #isDashPunctuation: and: #PddefinesSlotNamed: arg1  ^self slotNames includes: arg1parseNextPattern  self readNextChar.  self isEscape ifTrue: [ ^self parseEscapePattern ].  self isYearPattern ifTrue: [ ^self parseYear ].  self isMonthPattern ifTrue: [ ^self parseMonth ].  self isDayPattern ifTrue: [ ^self parseDay ].  self parseSameCharpushReceiver  self push: self receivertestInjectingMultipleExceptionHandlersIntoNotRunningProcess  | tmp1 tmp2 tmp3 tmp4 |  DefaultExecutionEnvironment beActive.  tmp4 := tmp3 := false.  tmp2 := [ tmp1 signal ] newProcess.  tmp2 on: ZeroDivide do: [:arg1 |  tmp4 := true ].  tmp2 on: Error do: [:arg1 |  tmp3 := true ].  tmp1 := ZeroDivide new.  tmp2 resume.  [ tmp2 isTerminated ] whileFalse: [ Processor yield ].  self assert: tmp4.  self deny: tmp3.  tmp4 := tmp3 := false.  tmp2 := [ tmp1 signal ] newProcess.  tmp2 on: ZeroDivide do: [:arg1 |  tmp4 := true ].  tmp2 on: Error do: [:arg1 |  tmp3 := true ].  tmp1 := Error new.  tmp2 resume.  [ tmp2 isTerminated ] whileFalse: [ Processor yield ].  self deny: tmp4.  self assert: tmp3testPositiveIntegerPrinting  self assert: 0 printString equals: '0'.  self assert: 0 printStringHex equals: '0'.  self assert: 0 storeStringHex equals: '16r0'.  self assert: (2 printStringBase: 2) equals: '10'.  self assert: (2 radix: 2) equals: '10'.  self assert: 2 printStringHex equals: '2'.  self assert: (2 storeStringBase: 2) equals: '2r10'.  self assert: 2 storeStringHex equals: '16r2'.  self assert: (21 printStringBase: 3) equals: '210'.  self assert: (21 radix: 3) equals: '210'.  self assert: 21 printStringHex equals: '15'.  self assert: (21 storeStringBase: 3) equals: '3r210'.  self assert: 21 storeStringHex equals: '16r15'.  self assert: (228 printStringBase: 4) equals: '3210'.  self assert: (228 radix: 4) equals: '3210'.  self assert: 228 printStringHex equals: 'E4'.  self assert: (228 storeStringBase: 4) equals: '4r3210'.  self assert: 228 storeStringHex equals: '16rE4'.  self assert: (2930 printStringBase: 5) equals: '43210'.  self assert: (2930 radix: 5) equals: '43210'.  self assert: 2930 printStringHex equals: 'B72'.  self assert: (2930 storeStringBase: 5) equals: '5r43210'.  self assert: 2930 storeStringHex equals: '16rB72'.  self assert: (44790 printStringBase: 6) equals: '543210'.  self assert: (44790 radix: 6) equals: '543210'.  self assert: 44790 printStringHex equals: 'AEF6'.  self assert: (44790 storeStringBase: 6) equals: '6r543210'.  self assert: 44790 storeStringHex equals: '16rAEF6'.  self assert: (800667 printStringBase: 7) equals: '6543210'.  self assert: (800667 radix: 7) equals: '6543210'.  self assert: 800667 printStringHex equals: 'C379B'.  self assert: (800667 storeStringBase: 7) equals: '7r6543210'.  self assert: 800667 storeStringHex equals: '16rC379B'.  self assert: (16434824 printStringBase: 8) equals: '76543210'.  self assert: (16434824 radix: 8) equals: '76543210'.  self assert: 16434824 printStringHex equals: 'FAC688'.  self assert: (16434824 storeStringBase: 8) equals: '8r76543210'.  self assert: 16434824 storeStringHex equals: '16rFAC688'.  self assert: (381367044 printStringBase: 9) equals: '876543210'.  self assert: (381367044 radix: 9) equals: '876543210'.  self assert: 381367044 printStringHex equals: '16BB3304'.  self assert: (381367044 storeStringBase: 9) equals: '9r876543210'.  self assert: 381367044 storeStringHex equals: '16r16BB3304'.  self assert: (9876543210 printStringBase: 10) equals: '9876543210'.  self assert: (9876543210 radix: 10) equals: '9876543210'.  self assert: 9876543210 printStringHex equals: '24CB016EA'.  self assert: (9876543210 storeStringBase: 10) equals: '9876543210'.  self assert: 9876543210 storeStringHex equals: '16r24CB016EA'.  self assert: (282458553905 printStringBase: 11) equals: 'A9876543210'.  self assert: (282458553905 radix: 11) equals: 'A9876543210'.  self assert: 282458553905 printStringHex equals: '41C3D77E31'.  self assert: (282458553905 storeStringBase: 11) equals: '11rA9876543210'.  self assert: 282458553905 storeStringHex equals: '16r41C3D77E31'.  self assert: (8842413667692 printStringBase: 12) equals: 'BA9876543210'.  self assert: (8842413667692 radix: 12) equals: 'BA9876543210'.  self assert: 8842413667692 printStringHex equals: '80AC8ECF56C'.  self assert: (8842413667692 storeStringBase: 12) equals: '12rBA9876543210'.  self assert: 8842413667692 storeStringHex equals: '16r80AC8ECF56C'.  self assert: (300771807240918 printStringBase: 13) equals: 'CBA9876543210'.  self assert: (300771807240918 radix: 13) equals: 'CBA9876543210'.  self assert: 300771807240918 printStringHex equals: '1118CE4BAA2D6'.  self assert: (300771807240918 storeStringBase: 13) equals: '13rCBA9876543210'.  self assert: 300771807240918 storeStringHex equals: '16r1118CE4BAA2D6'.  self assert: (11046255305880158 printStringBase: 14) equals: 'DCBA9876543210'.  self assert: (11046255305880158 radix: 14) equals: 'DCBA9876543210'.  self assert: 11046255305880158 printStringHex equals: '273E82BB9AF25E'.  self assert: (11046255305880158 storeStringBase: 14) equals: '14rDCBA9876543210'.  self assert: 11046255305880158 storeStringHex equals: '16r273E82BB9AF25E'.  self assert: (435659737878916215 printStringBase: 15) equals: 'EDCBA9876543210'.  self assert: (435659737878916215 radix: 15) equals: 'EDCBA9876543210'.  self assert: 435659737878916215 printStringHex equals: '60BC6392F366C77'.  self assert: (435659737878916215 storeStringBase: 15) equals: '15rEDCBA9876543210'.  self assert: 435659737878916215 storeStringHex equals: '16r60BC6392F366C77'.  self assert: (18364758544493064720 printStringBase: 16) equals: 'FEDCBA9876543210'.  self assert: (18364758544493064720 radix: 16) equals: 'FEDCBA9876543210'.  self assert: 18364758544493064720 printStringHex equals: 'FEDCBA9876543210'.  self assert: (18364758544493064720 storeStringBase: 16) equals: '16rFEDCBA9876543210'.  self assert: 18364758544493064720 storeStringHex equals: '16rFEDCBA9876543210'.  self assert: (824008854613343261192 printStringBase: 17) equals: 'GFEDCBA9876543210'.  self assert: (824008854613343261192 radix: 17) equals: 'GFEDCBA9876543210'.  self assert: 824008854613343261192 printStringHex equals: '2CAB6B877C1CD2D208'.  self assert: (824008854613343261192 storeStringBase: 17) equals: '17rGFEDCBA9876543210'.  self assert: 824008854613343261192 storeStringHex equals: '16r2CAB6B877C1CD2D208'.  self assert: (39210261334551566857170 printStringBase: 18) equals: 'HGFEDCBA9876543210'.  self assert: (39210261334551566857170 radix: 18) equals: 'HGFEDCBA9876543210'.  self assert: 39210261334551566857170 printStringHex equals: '84D97AFCAE81415B3D2'.  self assert: (39210261334551566857170 storeStringBase: 18) equals: '18rHGFEDCBA9876543210'.  self assert: 39210261334551566857170 storeStringHex equals: '16r84D97AFCAE81415B3D2'.  self assert: (1972313422155189164466189 printStringBase: 19) equals: 'IHGFEDCBA9876543210'.  self assert: (1972313422155189164466189 radix: 19) equals: 'IHGFEDCBA9876543210'.  self assert: 1972313422155189164466189 printStringHex equals: '1A1A75329C5C6FC00600D'.  self assert: (1972313422155189164466189 storeStringBase: 19) equals: '19rIHGFEDCBA9876543210'.  self assert: 1972313422155189164466189 storeStringHex equals: '16r1A1A75329C5C6FC00600D'.  self assert: (104567135734072022160664820 printStringBase: 20) equals: 'JIHGFEDCBA9876543210'.  self assert: (104567135734072022160664820 radix: 20) equals: 'JIHGFEDCBA9876543210'.  self assert: 104567135734072022160664820 printStringHex equals: '567EF3C9636D242A8C68F4'.  self assert: (104567135734072022160664820 storeStringBase: 20) equals: '20rJIHGFEDCBA9876543210'.  self assert: 104567135734072022160664820 storeStringHex equals: '16r567EF3C9636D242A8C68F4'.  self assert: (5827980550840017565077671610 printStringBase: 21) equals: 'KJIHGFEDCBA9876543210'.  self assert: (5827980550840017565077671610 radix: 21) equals: 'KJIHGFEDCBA9876543210'.  self assert: 5827980550840017565077671610 printStringHex equals: '12D4CAE2B8A09BCFDBE30EBA'.  self assert: (5827980550840017565077671610 storeStringBase: 21) equals: '21rKJIHGFEDCBA9876543210'.  self assert: 5827980550840017565077671610 storeStringHex equals: '16r12D4CAE2B8A09BCFDBE30EBA'.  self assert: (340653664490377789692799452102 printStringBase: 22) equals: 'LKJIHGFEDCBA9876543210'.  self assert: (340653664490377789692799452102 radix: 22) equals: 'LKJIHGFEDCBA9876543210'.  self assert: 340653664490377789692799452102 printStringHex equals: '44CB61B5B47E1A5D8F88583C6'.  self assert: (340653664490377789692799452102 storeStringBase: 22) equals: '22rLKJIHGFEDCBA9876543210'.  self assert: 340653664490377789692799452102 storeStringHex equals: '16r44CB61B5B47E1A5D8F88583C6'.  self assert: (20837326537038308910317109288851 printStringBase: 23) equals: 'MLKJIHGFEDCBA9876543210'.  self assert: (20837326537038308910317109288851 radix: 23) equals: 'MLKJIHGFEDCBA9876543210'.  self assert: 20837326537038308910317109288851 printStringHex equals: '1070108876456E0EF115B389F93'.  self assert: (20837326537038308910317109288851 storeStringBase: 23) equals: '23rMLKJIHGFEDCBA9876543210'.  self assert: 20837326537038308910317109288851 storeStringHex equals: '16r1070108876456E0EF115B389F93'.  self assert: (1331214537196502869015340298036888 printStringBase: 24) equals: 'NMLKJIHGFEDCBA9876543210'.  self assert: (1331214537196502869015340298036888 radix: 24) equals: 'NMLKJIHGFEDCBA9876543210'.  self assert: 1331214537196502869015340298036888 printStringHex equals: '41A24A285154B026B6ED206C6698'.  self assert: (1331214537196502869015340298036888 storeStringBase: 24) equals: '24rNMLKJIHGFEDCBA9876543210'.  self assert: 1331214537196502869015340298036888 storeStringHex equals: '16r41A24A285154B026B6ED206C6698'.  self assert: (88663644327703473714387251271141900 printStringBase: 25) equals: 'ONMLKJIHGFEDCBA9876543210'.  self assert: (88663644327703473714387251271141900 radix: 25) equals: 'ONMLKJIHGFEDCBA9876543210'.  self assert: 88663644327703473714387251271141900 printStringHex equals: '111374860A2C6CEBE5999630398A0C'.  self assert: (88663644327703473714387251271141900 storeStringBase: 25) equals: '25rONMLKJIHGFEDCBA9876543210'.  self assert: 88663644327703473714387251271141900 storeStringHex equals: '16r111374860A2C6CEBE5999630398A0C'.  self assert: (6146269788878825859099399609538763450 printStringBase: 26) equals: 'PONMLKJIHGFEDCBA9876543210'.  self assert: (6146269788878825859099399609538763450 radix: 26) equals: 'PONMLKJIHGFEDCBA9876543210'.  self assert: 6146269788878825859099399609538763450 printStringHex equals: '49FBA7F30B0F48BD14E6A99BD8ADABA'.  self assert: (6146269788878825859099399609538763450 storeStringBase: 26) equals: '26rPONMLKJIHGFEDCBA9876543210'.  self assert: 6146269788878825859099399609538763450 storeStringHex equals: '16r49FBA7F30B0F48BD14E6A99BD8ADABA'.  self assert: (442770531899482980347734468443677777577 printStringBase: 27) equals: 'QPONMLKJIHGFEDCBA9876543210'.  self assert: (442770531899482980347734468443677777577 radix: 27) equals: 'QPONMLKJIHGFEDCBA9876543210'.  self assert: 442770531899482980347734468443677777577 printStringHex equals: '14D1A80A997343640C1145A073731DEA9'.  self assert: (442770531899482980347734468443677777577 storeStringBase: 27) equals: '27rQPONMLKJIHGFEDCBA9876543210'.  self assert: 442770531899482980347734468443677777577 storeStringHex equals: '16r14D1A80A997343640C1145A073731DEA9'.  self assert: (33100056003358651440264672384704297711484 printStringBase: 28) equals: 'RQPONMLKJIHGFEDCBA9876543210'.  self assert: (33100056003358651440264672384704297711484 radix: 28) equals: 'RQPONMLKJIHGFEDCBA9876543210'.  self assert: 33100056003358651440264672384704297711484 printStringHex equals: '6145B6E6DACFA25D0E936F51D25932377C'.  self assert: (33100056003358651440264672384704297711484 storeStringBase: 28) equals: '28rRQPONMLKJIHGFEDCBA9876543210'.  self assert: 33100056003358651440264672384704297711484 storeStringHex equals: '16r6145B6E6DACFA25D0E936F51D25932377C'.  self assert: (2564411043271974895869785066497940850811934 printStringBase: 29) equals: 'SRQPONMLKJIHGFEDCBA9876543210'.  self assert: (2564411043271974895869785066497940850811934 radix: 29) equals: 'SRQPONMLKJIHGFEDCBA9876543210'.  self assert: 2564411043271974895869785066497940850811934 printStringHex equals: '1D702071CBA4A1597D4DD37E95EFAC79241E'.  self assert: (2564411043271974895869785066497940850811934 storeStringBase: 29) equals: '29rSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 2564411043271974895869785066497940850811934 storeStringHex equals: '16r1D702071CBA4A1597D4DD37E95EFAC79241E'.  self assert: (205646315052919334126040428061831153388822830 printStringBase: 30) equals: 'TSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (205646315052919334126040428061831153388822830 radix: 30) equals: 'TSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 205646315052919334126040428061831153388822830 printStringHex equals: '938B4343B54B550989989D02998718FFB212E'.  self assert: (205646315052919334126040428061831153388822830 storeStringBase: 30) equals: '30rTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 205646315052919334126040428061831153388822830 storeStringHex equals: '16r938B4343B54B550989989D02998718FFB212E'.  self assert: (17050208381689099029767742314582582184093573615 printStringBase: 31) equals: 'UTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (17050208381689099029767742314582582184093573615 radix: 31) equals: 'UTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 17050208381689099029767742314582582184093573615 printStringHex equals: '2FC8ECB1521BA16D24A69E976D53873E2C661EF'.  self assert: (17050208381689099029767742314582582184093573615 storeStringBase: 31) equals: '31rUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 17050208381689099029767742314582582184093573615 storeStringHex equals: '16r2FC8ECB1521BA16D24A69E976D53873E2C661EF'.  self assert: (1459980823972598128486511383358617792788444579872 printStringBase: 32) equals: 'VUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (1459980823972598128486511383358617792788444579872 radix: 32) equals: 'VUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 1459980823972598128486511383358617792788444579872 printStringHex equals: 'FFBBCDEB38BDAB49CA307B9AC5A928398A418820'.  self assert: (1459980823972598128486511383358617792788444579872 storeStringBase: 32) equals: '32rVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 1459980823972598128486511383358617792788444579872 storeStringHex equals: '16rFFBBCDEB38BDAB49CA307B9AC5A928398A418820'.  self assert: (128983956064237823710866404905431464703849549412368 printStringBase: 33) equals: 'WVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (128983956064237823710866404905431464703849549412368 radix: 33) equals: 'WVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 128983956064237823710866404905431464703849549412368 printStringHex equals: '584120A0328DE272AB055A8AA003CE4A559F223810'.  self assert: (128983956064237823710866404905431464703849549412368 storeStringBase: 33) equals: '33rWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 128983956064237823710866404905431464703849549412368 storeStringHex equals: '16r584120A0328DE272AB055A8AA003CE4A559F223810'.  self assert: (11745843093701610854378775891116314824081102660800418 printStringBase: 34) equals: 'XWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (11745843093701610854378775891116314824081102660800418 radix: 34) equals: 'XWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 11745843093701610854378775891116314824081102660800418 printStringHex equals: '1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.  self assert: (11745843093701610854378775891116314824081102660800418 storeStringBase: 34) equals: '34rXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 11745843093701610854378775891116314824081102660800418 storeStringHex equals: '16r1F64D4FC76000F7B92CF0CD5D0F350139AB9F25D8FA2'.  self assert: (1101553773143634726491620528194292510495517905608180485 printStringBase: 35) equals: 'YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (1101553773143634726491620528194292510495517905608180485 radix: 35) equals: 'YXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 1101553773143634726491620528194292510495517905608180485 printStringHex equals: 'B8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.  self assert: (1101553773143634726491620528194292510495517905608180485 storeStringBase: 35) equals: '35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 1101553773143634726491620528194292510495517905608180485 storeStringHex equals: '16rB8031AD55AD1FAA89E07A271CA1ED2F420415D1570305'.  self assert: (106300512100105327644605138221229898724869759421181854980 printStringBase: 36) equals: 'ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: (106300512100105327644605138221229898724869759421181854980 radix: 36) equals: 'ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 106300512100105327644605138221229898724869759421181854980 printStringHex equals: '455D441E55A37239AB4C303189576071AF5578FFCA80504'.  self assert: (106300512100105327644605138221229898724869759421181854980 storeStringBase: 36) equals: '36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210'.  self assert: 106300512100105327644605138221229898724869759421181854980 storeStringHex equals: '16r455D441E55A37239AB4C303189576071AF5578FFCA80504'stream: arg1  stream := arg1randomCharacter  ^self randomCharacterBetween: 0 and: Unicode maxValueifCurtailed: arg1  < primitive: 198>  | tmp1 tmp2 |  tmp2 := self valueNoContextSwitch.  tmp1 := true.  ^tmp2take: arg1  | tmp1 tmp2 |  arg1 < 0 ifTrue: [ ^0 ].  arg1 > self ifTrue: [ ^0 ].  tmp1 := 1.  self to: (arg1 max: self - arg1) + 1 by: -1 do: [:arg2 |  tmp1 := tmp1 * arg2 ].  tmp2 := 1.  1 to: (arg1 min: self - arg1) do: [:arg2 |  tmp2 := tmp2 * arg2 ].  ^tmp1 // tmp2* arg1  arg1 isInteger ifTrue: [ ^self digitMultiply: arg1 neg: self negative ~~ arg1 negative ].  ^arg1 adaptToInteger: self andSend: #*encodeUsingZip  | tmp1 tmp2 tmp3 tmp4 |  [ data isString ] assert.  tmp1 := data convertToEncoding: 'utf8'.  tmp2 := (ZipWriteStream on: (ByteArray new: tmp1 size))     nextPutAll: tmp1 asByteArray;     close;     encodedStream.  tmp3 := tmp2 position.  tmp4 := self encodeLengthField: tmp3.  tmp2 nextPutAll: tmp4.  tmp2 nextPut: self kindAsByte + tmp4 size - 1.  encodedData := tmp2 contentstestIntegerPadding  self assert: (1 printStringBase: 10 length: 0 padded: false) equals: '1'.  self assert: (1 printStringBase: 10 length: 1 padded: false) equals: '1'.  self assert: (1 printStringBase: 10 length: 2 padded: false) equals: ' 1'.  self assert: (1024 printStringBase: 10 length: 19 padded: false) equals: '               1024'.  self assert: (1024 printStringBase: 10 length: -1 padded: false) equals: '1024'.  self assert: (1024 printStringBase: 10 length: 5 padded: false) equals: ' 1024'.  self assert: (-1024 printStringBase: 10 length: 5 padded: false) equals: '-1024'.  self assert: (-1024 printStringBase: 10 length: 19 padded: false) equals: '              -1024'.  self assert: (1 printStringBase: 10 length: 0 padded: true) equals: '1'.  self assert: (1 printStringBase: 10 length: 1 padded: true) equals: '1'.  self assert: (1 printStringBase: 10 length: 2 padded: true) equals: '01'.  self assert: (1024 printStringBase: 10 length: 19 padded: true) equals: '0000000000000001024'.  self assert: (1024 printStringBase: 10 length: -1 padded: true) equals: '1024'.  self assert: (1024 printStringBase: 10 length: 5 padded: true) equals: '01024'.  self assert: (-1024 printStringBase: 10 length: 5 padded: true) equals: '-1024'.  self assert: (-1024 printStringBase: 10 length: 19 padded: true) equals: '-000000000000001024'.  self assert: (1 printStringBase: 16 length: 0 padded: false) equals: '1'.  self assert: (1 printStringBase: 16 length: 1 padded: false) equals: '1'.  self assert: (1 printStringBase: 16 length: 2 padded: false) equals: ' 1'.  self assert: (2047 printStringBase: 16 length: 19 padded: false) equals: '                7FF'.  self assert: (2047 printStringBase: 16 length: -1 padded: false) equals: '7FF'.  self assert: (2047 printStringBase: 16 length: 4 padded: false) equals: ' 7FF'.  self assert: (-2047 printStringBase: 16 length: 4 padded: false) equals: '-7FF'.  self assert: (-2047 printStringBase: 16 length: 19 padded: false) equals: '               -7FF'.  self assert: (1 printStringBase: 16 length: 0 padded: true) equals: '1'.  self assert: (1 printStringBase: 16 length: 1 padded: true) equals: '1'.  self assert: (1 printStringBase: 16 length: 2 padded: true) equals: '01'.  self assert: (2047 printStringBase: 16 length: 19 padded: true) equals: '00000000000000007FF'.  self assert: (2047 printStringBase: 16 length: -1 padded: true) equals: '7FF'.  self assert: (2047 printStringBase: 16 length: 4 padded: true) equals: '07FF'.  self assert: (-2047 printStringBase: 16 length: 4 padded: true) equals: '-7FF'.  self assert: (-2047 printStringBase: 16 length: 19 padded: true) equals: '-0000000000000007FF'.  self assert: (1 storeStringBase: 10 length: 0 padded: false) equals: '1'.  self assert: (1 storeStringBase: 10 length: 1 padded: false) equals: '1'.  self assert: (1 storeStringBase: 10 length: 2 padded: false) equals: ' 1'.  self assert: (1024 storeStringBase: 10 length: 19 padded: false) equals: '               1024'.  self assert: (1024 storeStringBase: 10 length: -1 padded: false) equals: '1024'.  self assert: (1024 storeStringBase: 10 length: 5 padded: false) equals: ' 1024'.  self assert: (-1024 storeStringBase: 10 length: 5 padded: false) equals: '-1024'.  self assert: (-1024 storeStringBase: 10 length: 19 padded: false) equals: '              -1024'.  self assert: (1 storeStringBase: 10 length: 0 padded: true) equals: '1'.  self assert: (1 storeStringBase: 10 length: 1 padded: true) equals: '1'.  self assert: (1 storeStringBase: 10 length: 2 padded: true) equals: '01'.  self assert: (1024 storeStringBase: 10 length: 19 padded: true) equals: '0000000000000001024'.  self assert: (1024 storeStringBase: 10 length: -1 padded: true) equals: '1024'.  self assert: (1024 storeStringBase: 10 length: 5 padded: true) equals: '01024'.  self assert: (-1024 storeStringBase: 10 length: 5 padded: true) equals: '-1024'.  self assert: (-1024 storeStringBase: 10 length: 19 padded: true) equals: '-000000000000001024'.  self assert: (1 storeStringBase: 16 length: 0 padded: false) equals: '16r1'.  self assert: (1 storeStringBase: 16 length: 4 padded: false) equals: '16r1'.  self assert: (1 storeStringBase: 16 length: 5 padded: false) equals: ' 16r1'.  self assert: (2047 storeStringBase: 16 length: 19 padded: false) equals: '             16r7FF'.  self assert: (2047 storeStringBase: 16 length: -1 padded: false) equals: '16r7FF'.  self assert: (2047 storeStringBase: 16 length: 7 padded: false) equals: ' 16r7FF'.  self assert: (-2047 storeStringBase: 16 length: 7 padded: false) equals: '-16r7FF'.  self assert: (-2047 storeStringBase: 16 length: 19 padded: false) equals: '            -16r7FF'.  self assert: (1 storeStringBase: 16 length: 0 padded: true) equals: '16r1'.  self assert: (1 storeStringBase: 16 length: 4 padded: true) equals: '16r1'.  self assert: (1 storeStringBase: 16 length: 5 padded: true) equals: '16r01'.  self assert: (2047 storeStringBase: 16 length: 19 padded: true) equals: '16r00000000000007FF'.  self assert: (2047 storeStringBase: 16 length: -1 padded: true) equals: '16r7FF'.  self assert: (2047 storeStringBase: 16 length: 7 padded: true) equals: '16r07FF'.  self assert: (-2047 storeStringBase: 16 length: 7 padded: true) equals: '-16r7FF'.  self assert: (-2047 storeStringBase: 16 length: 19 padded: true) equals: '-16r0000000000007FF'setMethod: arg1  self deprecated: 'Use #method: instead.' transformWith: '`@receiver setMethod: `@arg' -> '`@receiver method: `@arg'.  self method: arg1intersect: arg1 withAll: arg2 continuation: arg3  ^arg1 ifEmpty: [ arg3 value: arg1 ] ifNotEmpty: [ arg2 ifEmpty: [ arg1 ] ifNotEmpty: [ self intersect: arg1 withCollection: (self intersect: arg2 first withAll: arg2 allButFirst continuation: arg3) ] ]~= arg1  ^self = arg1 == falseremoveEmptyProtocols  | tmp1 |  tmp1 := protocols select: [:arg1 |  arg1 isEmpty and: [ arg1 canBeRemoved ] ].  tmp1 do: [:arg2 |  self removeProtocol: arg2 ].  ^tmp1bindingOf: arg1  ^nilunwindTo: arg1  | tmp1 tmp2 |  tmp1 := self.  [ (tmp1 := tmp1 findNextUnwindContextUpTo: arg1) isNil ] whileFalse: [ tmp1 unwindComplete ifNil: [ tmp1 unwindComplete: true.              tmp2 := tmp1 unwindBlock.              tmp2 value ] ]setUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  aDateAndTime := DateAndTime     localTimeZone: TimeZone default;     dosEpoch.  aTimeZone := TimeZone offset: (Duration minutes: 135) name: 'DOS Epoch Test Time Zone' abbreviation: 'DTZ'.  aDuration := Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5format  ^formathandleProcessTerminationOfWaitingContext: arg1  ^arg1pointAtSideOrCorner: arg1  ^self perform: (#(topLeft topCenter topRight rightCenter bottomRight bottomCenter bottomLeft leftCenter) at: (#(topLeft top topRight right bottomRight bottom bottomLeft left) indexOf: arg1))testXor  self assert: (false xor: true) equals: true.  self assert: (false xor: false) equals: false.  self assert: (false xor: [ true ]) equals: true.  self assert: (false xor: [ false ]) equals: falseasUTC  ^offset isZero ifTrue: [ self ] ifFalse: [ self offset: 0 ]significand  ^self timesTwoPower: self exponent negatedtestBasicCheck1  | tmp1 |  tmp1 := testSubclass >> (testSubclass compile: self methodName , '1').  self assertEmpty: (OverridesDeprecatedMethodRule new check: tmp1)gtInspectorMethodsIn: arg1  < gtInspectorPresentationOrder: 20>  arg1 list     title: 'Methods';     display: [ (self methods collect: #asRingDefinition) sorted: [:arg2 :arg3 |  arg2 selector < arg3 selector ] ];     format: #selector;     tags: [:arg4 |  {arg4 methodClass name} ]testInheritableVariable  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Semaphore new.  tmp2 := Semaphore new.  TestInheritableVariable enable.  [ TestInheritableVariable value: #inheritedVar.  tmp3 := TestInheritableVariable value.  [ tmp4 := TestInheritableVariable value.  tmp2 signal ] fork.  tmp1 signal ] fork.  tmp1 waitTimeoutSeconds: 2.  tmp2 waitTimeoutSeconds: 2.  TestInheritableVariable disable.  self assert: tmp3 equals: #inheritedVar.  self assert: tmp4 equals: #inheritedVarcalloutAPIClass  ^self ffiLibrary calloutAPIClasscanUnderstand: arg1  ^self classAndMethodFor: arg1 do: [:arg2 :arg3 |  true ] ifAbsent: [ false ]asBit  ^1testAsSeconds  self assert: aDateAndTime asSeconds equals: 2177452800testDelayWaitTimeoutTimedOut  | tmp1 tmp2 tmp3 |  tmp1 := Semaphore new.  tmp2 := DelayWaitTimeout new setDelay: 100 forSemaphore: tmp1.  tmp2 waitOnCompletion: [ tmp3 := #completed ] onTimeout: [ tmp3 := #timedOut ].  self assert: tmp3 equals: #timedOutnumArgsError: arg1  ArgumentsCountMismatch signalExpectedArgumentsCount: numArgs calledArgumentsCount: arg1removeAction: arg1 forEvent: arg2  self removeActionsSatisfying: [:arg3 |  arg3 = arg1 ] forEvent: arg2testMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'PM'testPrintOnFormat  self assert: (String streamContents: [:arg1 |  january23rd2004 printOn: arg1 format: #(3 2 1 $* 2 2) ]) equals: '04*Jan*23'originalName  ^((self isObsolete and: [ self name beginsWith: 'AnObsolete' ]) ifTrue: [ self name copyFrom: 'AnObsolete' size + 1 to: self name size ] ifFalse: [ self name ]) asSymbolbottomCenter  ^self center x @ self bottomresult: arg1  result := arg1\\ arg1  < primitive: 31>  arg1 isInteger ifTrue: [ | tmp1 tmp2 tmp3 tmp4 |        tmp1 := self negative == arg1 negative == false.        tmp2 := self digitDiv: arg1 neg: tmp1.        tmp3 := tmp2 first normalize.        tmp4 := tmp2 last normalize.        ^(tmp3 negative ifTrue: [ tmp4 isZero not ] ifFalse: [ tmp3 isZero and: [ tmp1 ] ]) ifTrue: [ tmp4 + arg1 ] ifFalse: [ tmp4 ] ].  ^super \\ arg1testNonCharacterNegative  self aRandomSelectionOfCharactersDo: [:arg1 |  self deny: (Unicode isNonCharacter: arg1) ]streamToMethod: arg1  stream := WriteStream with: arg1.  stream position: arg1 initialPC - 1testFromString  | tmp1 tmp2 |  tmp1 := DateAndTime fromString: '-1199-01-05T20:33:14.321-05:00'.  self assert: tmp1 printString equals: '-1199-01-05T20:33:14.321-05:00'.  tmp2 := DateAndTime fromString: '-1199-01-05T20:33:14.321'.  self assert: tmp2 offset equals: DateAndTime localOffsetincludesSelector: arg1  ^self methodDict includesKey: arg1testAsNumber  | tmp1 |  tmp1 := '1.40s2' asNumber.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: tmp1 scale equals: 2.  self assert: '1.40s2' equals: tmp1 printStringtestIfTrueIfFalse  self assert: (true ifTrue: [ 'trueAlternativeBlock' ] ifFalse: [ 'falseAlternativeBlock' ]) equals: 'trueAlternativeBlock'isBottomContext  ^sender isNilmessage  ^Message selector: self selector arguments: self argumentsbanLevelCandidates  ^{self} , self methodClass banLevelCandidatesreleaseActionMap  EventManager releaseActionMapFor: selfmonthIndex  ^self monthtestAsDateAndTime  | tmp1 |  tmp1 := DosTimestamp on: 16r40B57856.  self assert: tmp1 asDateAndTime equals: '21 May 2012 3:02:44 pm' asDateAndTimerotateBy: arg1 centerAt: arg2  ^(origin rotateBy: arg1 centerAt: arg2) rectangle: (corner rotateBy: arg1 centerAt: arg2)day  ^self dayOfYearnextInstance  < primitive: 78>  ^niltestIntegerReadsOkFromStream  self assert: (Integer readFrom: '123' readStream) equals: 123.  self assert: (Integer readFrom: '-123' readStream) equals: -123.  self assert: (Integer readFrom: 'a3' readStream base: 16) equals: 163.  self assert: (Integer readFrom: '-a3' readStream base: 16) equals: -163.  self assert: (Integer readFrom: '3a' readStream base: 10) equals: 3getSourceReplacingSelectorWith: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp3 := self sourceCode.  tmp3 ifNil: [ ^nil ].  tmp5 := self selector.  tmp5 = arg1 ifTrue: [ ^tmp3 ].  tmp1 := tmp5 keywords.  tmp2 := (arg1 ifNil: [ self defaultSelector ]) keywords.  [ tmp1 size = tmp2 size ] assert.  tmp4 := tmp3.  tmp6 := 1.  tmp1 with: tmp2 do: [:arg2 :arg3 |  | tmp7 |        tmp7 := tmp4 findString: arg2 startingAt: tmp6.        tmp4 := tmp4 copyReplaceFrom: tmp7 to: tmp7 + arg2 size - 1 with: arg3.        tmp6 := tmp7 + arg3 size ].  ^tmp4compareWith: arg1 ifLesser: arg2 ifEqual: arg3 ifGreater: arg4  ^self < arg1 ifTrue: arg2 ifFalse: [ self = arg1 ifTrue: arg3 ifFalse: arg4 ]not  ^truetestBasicCheck  | tmp1 |  tmp1 := testClass >> (testClass compile: 'testMethod ' , self globalName , ' ' , self deprecatedMethodName).  self assert: (tmp1 externalProperties anySatisfy: [:arg1 |  arg1 rule class = SendsDeprecatedMethodToGlobalRule ])duplicateClassWithNewName: arg1  | tmp1 tmp2 |  tmp1 := arg1 asSymbol.  tmp1 = self name ifTrue: [ ^self ].  (self environment includesKey: tmp1) ifTrue: [ ^self error: tmp1 , ' already exists' ].  tmp2 := self classInstaller make: [:arg2 |  arg2           fillFor: self;           name: tmp1 ].  tmp2 copyAllCategoriesFrom: self.  tmp2 class copyAllCategoriesFrom: self class.  ^tmp2link: arg1 toTemporary: arg2  self shouldNotImplementselector: arg1  selector := arg1becomeForward: arg1 copyHash: arg2  {self} elementsForwardIdentityTo: {arg1} copyHash: arg2testReciprocalModulo  1 to: 512 do: [:arg1 |  arg1 + 1 to: 512 do: [:arg2 |  | tmp1 |              (arg1 gcd: arg2) = 1 ifTrue: [ tmp1 := arg1 reciprocalModulo: arg2.                    self assert: arg1 * tmp1 \\ arg2 equals: 1 ] ifFalse: [ self should: [ arg1 reciprocalModulo: arg2 ] raise: Error ] ] ]isExplicitlyRequired: arg1  ^arg1 == self class explicitRequirementMarkerserializeOn: arg1  arg1     encodeUint24: self asSeconds;     encodeUint32: self nanoSecondpointsOnlyWeaklyTo: arg1  self class isWeak ifFalse: [ ^false ].  1 to: self class instSize do: [:arg2 |  (self instVarAt: arg2) == arg1 ifTrue: [ ^false ] ].  ^truegenStorePopLiteralVar: arg1  arg1 < 0 ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255 ].  arg1 < 64 ifTrue: [ stream           nextPut: 130;           nextPut: 192 + arg1.        ^self ].  arg1 < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 224;           nextPut: arg1.        self genPop.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255lowerBound  ^lowerBoundtestSendsSelector  self assert: (CompiledCode >> #sendsSelector: sendsSelector: #includes:).  self deny: (CompiledCode >> #sendsSelector: sendsSelector: #doBreakfastForMe)gtPlaygroundHumanReadableString  self < 1 minute ifTrue: [ ^'just now' ].  self < 2 minutes ifTrue: [ ^'1 minute ago' ].  self < 1 hour ifTrue: [ ^self minutes asString , ' minutes ago' ].  self < 1 day ifTrue: [ ^self hours asString , ' hours ago' ].  self < 1 year ifTrue: [ ^self days asString , ' days ago' ].  ^self printStringsimpleEnsureTest  [ self doSomething.  self doSomethingElse ] ensure: [ self doYetAnotherThing ]compile: arg1 notifying: arg2  | tmp1 |  tmp1 := self compiler     source: arg1;     requestor: arg2;     failBlock: [ ^nil ];     compile.  tmp1 putSource: arg1 withPreamble: [:arg3 |  arg3           cr;           nextPut: $!;           nextChunkPut: 'Behavior method';           cr ].  self addSelector: tmp1 selector withMethod: tmp1.  ^tmp1 selectorencodeEmbeddedSourceWide  | tmp1 tmp2 tmp3 tmp4 |  [ data isString ] assert.  tmp4 := data utf8Encoded.  tmp1 := WriteStream on: (ByteArray new: tmp4 size).  tmp2 := tmp4 size.  tmp3 := self encodeLengthField: tmp2.  tmp1 nextPutAll: tmp4 asByteArray.  tmp1 nextPutAll: tmp3.  tmp1 nextPut: self kindAsByte + tmp3 size - 1.  encodedData := tmp1 contentsdate: arg1  deprecationDate := arg1extensionProtocols  ^self protocolOrganizer extensionProtocolsdecodeEmbeddedSourceQCompress  | tmp1 tmp2 tmp3 |  tmp1 := self decodeLengthField.  tmp3 := ReadStream on: method from: method size - size + 1 to: method size - size + tmp1.  tmp2 := String streamContents: [:arg1 |  | tmp4 tmp5 tmp6 tmp7 |        tmp7 := 'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'.        tmp6 := true.        tmp4 := [ tmp6 ifTrue: [ tmp6 := false.              tmp3 peek ifNil: [ 0 ] ifNotNil: [:arg2 |  arg2 // 16 ] ] ifFalse: [ tmp6 := true.              tmp3 next ifNil: [ 0 ] ifNotNil: [:arg2 |  arg2 \\ 16 ] ] ].        [ tmp3 atEnd ] whileFalse: [ (tmp5 := tmp4 value) = 0 ifTrue: [ tmp3 atEnd ifFalse: [ arg1 nextPut: (Character value: tmp4 value * 16 + tmp4 value) ] ] ifFalse: [ tmp5 <= 11 ifTrue: [ arg1 nextPut: (tmp7 at: tmp5) ] ifFalse: [ arg1 nextPut: (tmp7 at: (tmp5 - 12) * 16 + tmp4 value) ] ] ] ].  data := tmp2 convertFromEncoding: 'utf8'usesPoolVarNamed: arg1  ^falsesetJdn: arg1 seconds: arg2 nano: arg3 offset: arg4  julianDayNumber := arg1.  seconds := arg2.  nanos := arg3.  offset := arg4.  self normalizeSecondsAndNanosisBehavior  ^truetestComparison  | tmp1 tmp2 |  tmp1 := Float class >> #nan.  tmp2 := thisContext method.  self assert: tmp1 equals: tmp1.  self assert: tmp2 equals: tmp2.  self deny: tmp1 equals: tmp2.  self deny: tmp2 equals: tmp1.  Object methods do: [:arg1 |  self deny: tmp1 equals: arg1.        self deny: arg1 equals: tmp1.        self deny: tmp2 equals: arg1.        self deny: arg1 equals: tmp2 ]genPushClosureCopyNumCopiedValues: arg1 numArgs: arg2 jumpSize: arg3  (arg3 < 0 or: [ arg3 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'block size' index: arg3 range: 0 to: 65535 ].  (arg1 < 0 or: [ arg1 > 15 ]) ifTrue: [ ^self outOfRangeError: 'num copied' index: arg1 range: 0 to: 15 ].  (arg2 < 0 or: [ arg2 > 15 ]) ifTrue: [ ^self outOfRangeError: 'num args' index: arg2 range: 0 to: 15 ].  stream     nextPut: 143;     nextPut: arg2 + (arg1 bitShift: 4);     nextPut: (arg3 bitShift: -8);     nextPut: (arg3 bitAnd: 16rFF)hex  ^self storeStringBase: 16interpretSistaV1JumpIfCond  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self method.  tmp4 := 0.  tmp3 := pc.  [ tmp2 := self method at: tmp3.  tmp3 := tmp3 + 1.  tmp2 = 225 ] whileTrue: [ | tmp5 |        tmp5 := self method at: tmp3.        tmp3 := tmp3 + 1.        tmp4 := (tmp4 = 0 and: [ tmp5 > 127 ]) ifTrue: [ tmp5 - 256 ] ifFalse: [ (tmp4 bitShift: 8) + tmp5 ] ].  (tmp2 between: 184 and: 199) ifTrue: [ pc := tmp3.        ^(tmp2 bitAnd: 7) + 1 ].  (tmp2 between: 238 and: 239) ifTrue: [ tmp2 := tmp1 at: tmp3.        pc := tmp3 + 1.        ^(tmp4 bitShift: 8) + tmp2 ].  ^nilvariableReadNodes  ^self methods flatCollect: [:arg1 |  arg1 variableReadNodes ]testValueWithExitContinue  | tmp1 tmp2 |  tmp1 := 0.  1 to: 10 do: [:arg1 |  [:arg2 |  arg1 = 4 ifTrue: [ arg2 value ].        tmp1 := tmp1 + 1.        tmp2 := arg1 ] valueWithExit ].  self assert: tmp1 equals: 9.  self assert: tmp2 equals: 10forkAt: arg1  ^self newProcess     priority: arg1;     resumetestTwoRecursiveCriticalsShouldNotWaitEachOther  | tmp1 |  tmp1 := false.  self fork: [ mutex critical: [ mutex critical: [ tmp1 := true ] ] ].  self waitLastProcessTerminate.  self assert: tmp1testOneRaisedToInteger  self assert: (1.0s1 raisedToInteger: -1) scale equals: 1.  self assert: (1.0s1 raisedToInteger: -1) equals: 1.  self assert: (1.0s1 raisedToInteger: 0) scale equals: 1.  self assert: (1.0s1 raisedToInteger: 0) equals: 1.  self assert: (1.0s1 raisedToInteger: 1) scale equals: 1.  self assert: (1.0s1 raisedToInteger: 1) equals: 1.  self assert: (1.0s1 raisedToInteger: 2) scale equals: 1.  self assert: (1.0s1 raisedToInteger: 2) equals: 1valueWithReceiver: arg1 arguments: arg2  ^arg1 withArgs: arg2 executeMethod: selfwaitTimeoutSeconds: arg1  ^self waitTimeoutMSecs: arg1 * 1000deprecatedMethod  self deprecated: 'example of a deprecated method'scaledByDisplayScaleFactor  ^self * self currentWorld displayScaleFactorstartTimerEventLoopPriority: arg1  timerEventLoop ifNotNil: [ self error: 'Timer event loop has already been started.' ].  runTimerEventLoop := true.  timerEventLoop := [ self runBackendLoopAtTimingPriority ] newProcess.  timerEventLoop     name: self className , '(' , ticker className , ')';     priority: arg1.  timerEventLoop resumeclearSignFlag  self signFlag ifTrue: [ self objectAt: 1 put: self header - SmallInteger minVal ]testToByDo  daysInMonth: arg1  ^(DateAndTime year: self year month: arg1 day: 1) asMonth daysInMonthlistAtCategoryNamed: arg1  ^(self protocolOrganizer methodsInProtocolNamed: arg1) asArraycompressedSourceCode  kind == #EmbeddedSourceQCompress ifTrue: [ ^data ].  kind == #EmbeddedSourceZip ifTrue: [ ^data ].  ^nilstopMethod: arg1 during: arg2  (activeMethods includes: arg1) ifTrue: [ ^self ].  activeMethods add: arg1.  arg2 ensure: [ activeMethods remove: arg1 ]from  ^frombyteSizeOfInstanceOfSize: arg1  < primitive: 181 error: ec>  self isVariable ifTrue: [ (arg1 isInteger and: [ arg1 >= 16r1000000 ]) ifTrue: [ ^2 * (self byteSizeOfInstanceOfSize: (arg1 + 1) // 2) - (self byteSizeOfInstanceOfSize: 0) ] ] ifFalse: [ arg1 = 0 ifTrue: [ ^self byteSizeOfInstance ] ].  self primitiveFailedreciprocal  ^1 / self// arg1  < primitive: 12>  ^super // arg1testDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 29negative  ^self < 0testCritical  | tmp1 |  tmp1 := Semaphore forMutualExclusion.  [ tmp1 critical: [ self criticalError ] ] forkAt: Processor userInterruptPriority.  self assert: tmp1 isSignaledtestMutateObjectFirstInstVarWithManyVars  | tmp1 tmp2 |  tmp1 := WriteBarrierStub new.  tmp1 beReadOnlyObject.  tmp2 := [ tmp1 var1: #test ] on: ModificationForbidden do: [:arg1 |  arg1 ].  self assert: tmp2 fieldIndex equals: 1freezeUpTo: arg1  signalContext := signalContext copyTo: arg1sourceNodeExecutedForPC: arg1  ^self sourceNode sourceNodeExecutedForPC: arg1gtBytecodeDebuggerRetrieveContextValues  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := OrderedCollection new.  tmp2 := OrderedCollection new.  tmp4 := self tempNames.  self stackPtr to: 1 by: -1 do: [:arg1 |  | tmp5 |        tmp1 add: (arg1 <= tmp4 size ifTrue: [ tmp2 add: (tmp4 at: arg1).                    tmp5 := GTInspectorContextNamedTempNode hostObject: self tempName: (tmp4 at: arg1) tempIndex: arg1.                    GTInspectorWrapperNode hostObject: tmp5 label: (arg1 - 1) asString , ' [' , (tmp4 at: arg1) , ']' ] ifFalse: [ tmp5 := GTInspectorContextIndexedTempNode hostObject: self tempIndex: arg1.                    GTInspectorWrapperNode hostObject: tmp5 label: (arg1 - 1) asString ]) ].  (tmp4 copy asOrderedCollection     removeAll: tmp2;     yourself) ifNotEmpty: [:arg2 |  arg2 do: [:arg3 |  GTInspectorDynamicNode hostObject: self label: '- [' , arg3 , ']' value: nil ] ].  tmp1 addAll: (self gtDebuggerDoItBindings collect: [:arg4 |  (GTInspectorDynamicNode hostObject: self label: arg4 key value: arg4 value)                 variableTag: 'temp';                 yourself ]).  tmp3 := self receiver class allSlots size.  tmp1 addAll: (self receiver class allSlots reverse collect: [:arg5 |  | tmp6 |              tmp6 := GTInspectorSlotNode hostObject: self receiver slot: arg5.              GTInspectorWrapperNode hostObject: tmp6 label: 'rcv' , (tmp3 := tmp3 - 1) asString , ' [' , arg5 name , ']' ]).  ^tmp1 asOrderedCollection     addFirst: (GTInspectorSelfNode hostObject: self receiver);     addLast: (GTInspectorDynamicNode hostObject: self label: 'thisContext' value: self);     yourselfspotterProcessorsFor: arg1 pragma: arg2  [ | tmp1 tmp2 |  tmp1 := arg1 processors size.  self perform: arg2 methodSelector with: arg1.  tmp2 := arg1 processors size - tmp1.  (arg1 processors last: tmp2) do: [:arg3 |  arg3 order: (arg2 argumentAt: 1) ] ] on: Error do: [:arg4 |  arg1 exceptionHandler handleException: arg4 do: [ ('[Spotter] Exception while collecting processors for <' , self class name , '>: ' , arg4 asString) traceCr ] ]testXor  self assert: (true xor: true) equals: false.  self assert: (true xor: false) equals: true.  self assert: (true xor: [ true ]) equals: false.  self assert: (true xor: [ false ]) equals: truemethod  ^outerContext methodtestNumberOfMethods  self assert: Point numberOfMethods equals: Point localMethods size + Point class localMethods sizesuperMessages  ^self ast superMessagesunscheduleAtTimingPriority  readyToUnschedule signal.  super unscheduleAtTimingPrioritybaseLocalMethods  ^self instanceSide methodDictcritical: arg1  ^self pvtCritical: arg1 startingAt: 1subclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 package: arg5  ^self subclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 category: arg5testIfTrueIfFalse  self assert: (false ifTrue: [ 'trueAlternativeBlock' ] ifFalse: [ 'falseAlternativeBlock' ]) equals: 'falseAlternativeBlock'testDayMonthYearDo  | tmp1 |  tmp1 := 0.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  tmp1 := tmp1 + 1 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg3 ]) equals: 1901.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg2 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg1 ]) equals: 1penultimateLiteral  ^nilspotterPackageFor: arg1  < spotterOrder: 50>  arg1 listProcessor     title: 'Package';     allCandidates: [ {self package} ];     itemName: [:arg2 |  arg2 packageName ];     itemIcon: #systemIcon;     filter: GTFilterSubstringtestDateAndTimes  | tmp1 |  self assert: aSchedule dateAndTimes size equals: 104.  self assert: aSchedule dateAndTimes first equals: firstEvent.  tmp1 := true.  aSchedule dateAndTimes do: [:arg1 |  (arg1 dayOfWeekName = 'Saturday' or: [ arg1 dayOfWeekName = 'Sunday' ]) ifFalse: [ ^false ] ].  self assert: tmp1simpleIsNestedTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: self doSomethingElseString;     yourselfallSuperclasses  | tmp1 |  ^self superclass == nil ifTrue: [ OrderedCollection new ] ifFalse: [ tmp1 := self superclass allSuperclasses.        tmp1 addFirst: self superclass.        tmp1 ]highestPriority: arg1  | tmp1 |  (quiescentProcessLists size > arg1 and: [ self anyProcessesAbove: arg1 ]) ifTrue: [ self error: 'There are processes with priority higher than ' , arg1 printString ].  tmp1 := Array new: arg1.  1 to: (quiescentProcessLists size min: tmp1 size) do: [:arg2 |  tmp1 at: arg2 put: (quiescentProcessLists at: arg2) ].  quiescentProcessLists size to: tmp1 size do: [:arg2 |  tmp1 at: arg2 put: ProcessList new ].  quiescentProcessLists := tmp1simulatePrimitive: arg1 in: arg2 receiver: arg3 arguments: arg4  | tmp1 tmp2 |  tmp1 := arg1 = 117 ifTrue: [ | tmp3 |        tmp3 := arg2 literalAt: 1.        {tmp3 second .         tmp3 first} ] ifFalse: [ arg1 ].  tmp2 := self class specialPrimitiveSimulators at: tmp1 ifAbsent: [ ^arg1 = 117 ifTrue: [ self withoutPrimitiveTryNamedPrimitiveIn: arg2 for: arg3 withArgs: arg4 ] ifFalse: [ arg3 tryPrimitive: arg1 withArgs: arg4 ] ].  ^tmp2 simulatePrimitiveFor: arg2 receiver: arg3 arguments: arg4 context: selfmillisecondsToGo  ^ticker millisecondsUntilTick: resumptionTicktestInjectingExceptionHandlerFromProcessItself  | tmp1 tmp2 tmp3 tmp4 |  DefaultExecutionEnvironment beActive.  tmp1 := Error new messageText: 'test error'.  tmp4 := true.  tmp3 := [ Processor activeProcess on: Error do: [:arg1 |  tmp2 := arg1 ].  tmp1 signal.  tmp4 := false ] fork.  [ tmp3 isTerminated ] whileFalse: [ Processor yield ].  self assert: tmp2 identicalTo: tmp1.  self assert: tmp4isManifest  ^falsestoreOn: arg1  | tmp1 |  arg1 nextPutAll: '(('.  arg1 nextPutAll: self class name.  arg1 nextPutAll: ' newMethod: '.  arg1 store: self size - self initialPC + 1.  arg1 nextPutAll: ' header: '.  arg1 store: self header.  arg1 nextPut: $).  tmp1 := self storeElementsFrom: self initialPC to: self endPC on: arg1.  1 to: self numLiterals do: [:arg2 |  tmp1 ifTrue: [ tmp1 := false ] ifFalse: [ arg1 nextPut: $; ].        arg1 nextPutAll: ' literalAt: '.        arg1 store: arg2.        arg1 nextPutAll: ' put: '.        arg1 store: (self literalAt: arg2) ].  tmp1 ifFalse: [ arg1 nextPutAll: '; yourself' ].  arg1 nextPut: $)asPresenter  ^self asString asPresenterselector  ^selectorfuelAccept: arg1  ^arg1 visitHookPrimitive: selfnbCall: arg1 module: arg2  < ffiCalloutTranslator>  self deprecated: 'use ffiCall:module: instead'.  ^(self ffiCalloutIn: thisContext sender)     convention: self ffiCallingConvention;     function: arg1 library: arg2asMinimalRepresentation  self isReceiverOrAnyArgumentGarbage ifTrue: [ ^nil ] ifFalse: [ ^self ]days  ^seconds quo: SecondsInDaymethodReturnConstant: arg1  ^self return: arg1 from: self methodReturnContextasYear  ^Year starting: selflink: arg1 toAST: arg2  arg2 link: arg1 forObject: selfencodeOn: arg1  testObjectFormatInstSize  | tmp1 tmp2 |  tmp2 := SystemNavigation default allBehaviors reject: [:arg1 |  arg1 instSize = (arg1 allSlots reject: #isVirtual) size ].  self assertCollection: tmp2 hasSameElements: {}.  tmp1 := SystemNavigation default allBehaviors select: [:arg1 |  arg1 isTrait not and: [ arg1 instSpec = 0 ] ].  tmp2 := tmp1 reject: [:arg2 |  arg2 instVarNames isEmpty or: [ arg2 isVariable not ] ].  self assertCollection: tmp2 hasSameElements: {}printHMSWithDashesOn: arg1  self printHMSOn: arg1 separatedBy: $-numLiterals  ^self header bitAnd: 16r7FFFat: arg1 put: arg2  self shouldNotImplementsize  ^sizestonProcessSubObjects: arg1  1 to: self class instSize do: [:arg2 |  self instVarAt: arg2 put: (arg1 value: (self instVarAt: arg2)) ].  (self class isVariable and: [ self class isBytes not ]) ifTrue: [ 1 to: self basicSize do: [:arg2 |  self basicAt: arg2 put: (arg1 value: (self basicAt: arg2)) ] ]waitForProcessTermination: arg1  arg1 priority: Processor activePriority + 1.  [ arg1 isTerminated ] whileFalse: [ Processor yield ]spotterForMessagesFor: arg1  < spotterOrder: 12>  arg1 listProcessor     title: 'Messages';     allCandidates: [ self messages asSortedCollection collect: [:arg2 |  GTSelector new name: arg2 ] ];     filter: GTFilterSubstringshouldNotBeRedefined  ^(Smalltalk specialObjectsArray identityIndexOf: self ifAbsent: [ (self isKindOf: self) ifTrue: [ 1 ] ifFalse: [ 0 ] ]) ~= 0usesPoolVarNamed: arg1  ^self allSharedPools anySatisfy: [:arg2 |  arg2 usesClassVarNamed: arg1 ]pointer  self error: 'You cannot get a pointer to me.'shutDown  self suspenddragTransferType  ^nilfourthByte  ^self method at: pc + 3isBehavior  ^falsequickMerge: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  arg1 ifNil: [ ^self ].  tmp1 := true.  tmp2 := arg1 topLeft.  tmp3 := arg1 bottomRight.  tmp4 := tmp2 x < origin x ifTrue: [ tmp1 := false.        tmp2 x ] ifFalse: [ origin x ].  tmp5 := tmp3 x > corner x ifTrue: [ tmp1 := false.        tmp3 x ] ifFalse: [ corner x ].  tmp6 := tmp2 y < origin y ifTrue: [ tmp1 := false.        tmp2 y ] ifFalse: [ origin y ].  tmp7 := tmp3 y > corner y ifTrue: [ tmp1 := false.        tmp3 y ] ifFalse: [ corner y ].  tmp1 ifTrue: [ ^self ] ifFalse: [ ^Rectangle origin: tmp4 @ tmp6 corner: tmp5 @ tmp7 ]runSimulated: arg1  thisContext runSimulated: arg1 contextAtEachStep: [:arg2 |   ]mustBeBooleanDeOptimizeIn: arg1  | tmp1 tmp2 tmp3 |  tmp2 := arg1 method propertyAt: #mustBeBooleanCache ifAbsentPut: [ IdentityDictionary new ].  tmp3 := tmp2 at: arg1 pc - 1 ifAbsent: [ self mustBeBooleanCompileExpression: arg1 andCache: tmp2 ].  tmp1 := arg1 receiver withArgs: {arg1} executeMethod: tmp3.  arg1 pc: (tmp3 propertyAt: #mustBeBooleanJump).  ^tmp1genUnsignedSingleExtendA: arg1  (arg1 between: 0 and: 255) ifFalse: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255 ].  stream     nextPut: 224;     nextPut: arg1min: arg1  self < arg1 ifTrue: [ ^self ] ifFalse: [ ^arg1 ]lookupSymbol: arg1  | tmp1 |  tmp1 := self sourceNodeExecuted scope lookupVar: arg1.  tmp1 isTemp ifTrue: [ ^self tempNamed: arg1 ].  tmp1 isInstance ifTrue: [ ^self receiver instVarNamed: arg1 ].  tmp1 isGlobal ifTrue: [ ^tmp1 assoc value ].  ^niltestMonth  self assert: aDateAndTime month equals: 1.  self assert: aDateAndTime monthAbbreviation equals: 'Jan'.  self assert: aDateAndTime monthName equals: 'January'.  self assert: aDateAndTime monthIndex equals: 1testprintSubclassesOnLevelFilterA  | tmp1 tmp2 tmp3 |  tmp1 := '	ExampleForTest1 #()		ExampleForTest11 #()			ExampleForTest112 #()'.  tmp2 := String new: tmp1 size.  tmp3 := ReadWriteStream on: tmp2.  ExampleForTest1 printSubclassesOn: tmp3 level: 1 filter: {ExampleForTest1 .         ExampleForTest11 .         ExampleForTest112}.  self assert: tmp2 equals: tmp1rightCenter  ^self right @ self center ytestDateTimeDenotation2  | tmp1 tmp2 tmp3 |  tmp1 := DateAndTime year: 2004 month: 11 day: 30 hour: 23 minute: 30 second: 0 offset: 0 hours.  tmp2 := tmp1 offset: 3 hours.  tmp3 := '2004-12-01T02:30:00+03:00' asDateAndTime.  self assert: tmp2 equals: tmp3noteCompilationOf: arg1 meta: arg2  reflectiveMethod: arg1  self propertyAt: #reflectiveMethod put: arg1highBit  self < 0 ifTrue: [ ^self error: 'highBit is not defined for negative integers' ].  ^self highBitOfPositiveReceiverasSmallPositiveDegrees  ^self \\ 360labelForSelector: arg1  ^arg1 asCapitalizedPhrasetestExample2  self assert: (self example2: 5) equals: (1 to: 5) asOrderedCollectiontestIfNotNil  nil ifNotNil: [ self fail: 'should not get here' ]isRingFullyUnresolved  ^falsefuelAccept: arg1  self class isFixed ifTrue: [ ^arg1 visitFixedObject: self ].  self class isWeak ifTrue: [ ^arg1 visitWeakObject: self ].  self class isPointers ifTrue: [ ^arg1 visitVariableObject: self ].  self class isBytes ifTrue: [ ^arg1 visitBytesObject: self ].  self class isWords ifTrue: [ ^arg1 visitWordsObject: self ].  self error: 'Something is wrong!'adaptToFloat: arg1 andCompare: arg2  arg1 isFinite ifFalse: [ arg2 == #= ifTrue: [ ^false ].        arg2 == #~= ifTrue: [ ^true ].        arg1 isNaN ifTrue: [ ^false ].        (arg2 = #< or: [ arg2 = #<= ]) ifTrue: [ ^arg1 positive not ].        (arg2 = #> or: [ arg2 = #>= ]) ifTrue: [ ^arg1 positive ].        ^self error: 'unknow comparison selector' ].  ^arg1 asTrueFraction perform: arg2 with: selftestSignalWithTag  | tmp1 |  tmp1 := Object new.  [ DomainError signal: 'aMessage' withTag: tmp1.  self fail: 'The exception was not signaled' ] on: DomainError do: [:arg1 |  self assert: arg1 messageText equals: 'aMessage'.        self assert: arg1 tag equals: tmp1 ]testDigitLength  | tmp1 |  tmp1 := 114605103402541699037609980192546360895434064385.  self assert: 20 equals: tmp1 bytesCountdeepCopy  ^self shallowCopytestMemoizedDictionary  | tmp1 tmp2 tmp3 |  tmp1 := Dictionary new.  tmp2 := 0.  tmp2 := [:arg1 |  arg1 = 1 ifTrue: [ 1 ] ifFalse: [ (tmp2 value: arg1 - 1) * arg1 ] ] memoizedUsing: tmp1.  tmp3 := (1 to: 5) collect: tmp2.  self assert: tmp3 equals: #(1 2 6 24 120).  self assert: tmp1 associations equals: {(1 -> 1) .         (2 -> 2) .         (3 -> 6) .         (4 -> 24) .         (5 -> 120)}whileFalse  self value ifFalse: [ self whileFalse ]finalizationRegistry  ^WeakRegistry defaultfuelAccept: arg1  ^arg1 visitHookPrimitive: selfvalueNoContextSwitch  < primitive: 221>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  self primitiveFailednonObsoleteClass  | tmp1 |  tmp1 := self name.  [ tmp1 beginsWith: 'AnObsolete' ] whileTrue: [ tmp1 := tmp1 copyFrom: 'AnObsolete' size + 1 to: tmp1 size ].  ^self environment at: tmp1 asSymbolhour24  ^self localSeconds // SecondsInHour \\ 24ephemeronSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5  ^self classInstaller make: [:arg6 |  arg6           superclass: self;           name: arg1;           layoutClass: EphemeronLayout;           slots: arg2 asSlotCollection;           sharedVariablesFromString: arg3;           sharedPools: arg4;           category: arg5;           environment: self environment ]asApproximateFractionAtOrder: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  tmp1 := self asInteger.  tmp2 := 1.  tmp3 := 1.  tmp4 := 0.  tmp5 := tmp1.  tmp6 := self fractionPart.  tmp9 := arg1 = 0 ifTrue: [ -1 ] ifFalse: [ arg1 ].  [ tmp6 = 0 or: [ tmp9 = 0 ] ] whileFalse: [ tmp9 := tmp9 - 1.        tmp7 := 1.0 / tmp6.        tmp5 := tmp7 asInteger.        tmp6 := tmp7 fractionPart.        tmp8 := tmp3.        tmp3 := tmp1.        tmp1 := tmp1 * tmp5 + tmp8.        tmp8 := tmp4.        tmp4 := tmp2.        tmp2 := tmp5 * tmp2 + tmp8.        10000000000.0 < tmp2 ifTrue: [ tmp3 = 0.0 ifTrue: [ ^Fraction numerator: tmp1 denominator: tmp2 ].              ^Fraction numerator: tmp3 denominator: tmp4 ] ].  tmp2 = 1 ifTrue: [ ^tmp1 ] ifFalse: [ ^Fraction numerator: tmp1 denominator: tmp2 ]testTicks  self assert: aTime ticks equals: #(0 45296 0).  self assert: aTime equals: (Time new ticks: #(0 45296 0))printOn: arg1  arg1 nextPutAll: 'a Week starting: '.  self start printOn: arg1testEqual  self assert: atPragma equals: atPragma.  self assert: atPragma equals: anotherAtPragma.  self assert: anotherAtPragma equals: atPragma.  self assert: atPragma equals: anotherAtPragma.  self assert: anotherAtPragma equals: yetAnotherAtPragma.  self assert: yetAnotherAtPragma equals: atPragma.  self deny: atPragma equals: atPutPragmacontinuationExample3: arg1  | tmp1 tmp2 tmp3 |  tmp1 := [:arg2 |  | tmp4 tmp5 |  tmp4 := 1.  tmp5 := [ | tmp6 |  tmp6 := arg2 at: tmp4.  tmp4 := tmp4 + 1.  Array with: tmp6 with: (tmp4 <= arg2 size ifTrue: [ tmp5 ] ifFalse: [ nil ]) ] ].  tmp2 := [:arg3 :arg4 |  | tmp5 |  tmp5 := [ | tmp6 |  tmp6 := arg3 value.  Array with: (arg4 value: tmp6 first) with: (tmp6 last notNil ifTrue: [ tmp5 ]) ].  tmp5 ].  tmp3 := [:arg3 |  | tmp7 |  tmp7 := OrderedCollection new.  [ | tmp8 |  tmp8 := arg3 value.  tmp7 add: tmp8 first.  tmp8 last notNil ] whileTrue: [  ].  tmp7 ].  ^tmp3 value: (tmp2 value: (tmp2 value: (tmp1 value: arg1) value: [:arg5 |  arg5 * arg5 ]) value: [:arg5 |  arg5 - 10 ])smartDescription  message ifNil: [ ^self description ].  ^self classSymbol printString , ' is missing, and does not understand ' , message selector printStringstate: arg1  state := arg1isLiteral  ^trueselectorsToBeIgnored  | tmp1 |  tmp1 := #(#printOn:).  ^super selectorsToBeIgnored , tmp1testHex  self assert: 0 hex equals: '16r0'.  self assert: 12 hex equals: '16rC'.  self assert: 1234 hex equals: '16r4D2'propertyAt: arg1 put: arg2  ^self ensureProperties at: arg1 ifAbsentPut: arg2gtInspectorPreviewIn: arg1  < gtInspectorPresentationOrder: 30>  arg1 morph     title: 'Calendar';     morph: [ CalendarMorph on: self ]sign: arg1  ^arg1 copySignTo: selfchanged  self changed: selfveryDeepCopyWith: arg1  waitingProcessesAt: arg1  ^quiescentProcessLists at: arg1gtDebuggerEvaluatorIn: arg1  (GTObjectVariablesBrowser new evaluatorIn: arg1) title: 'Evaluator'size  ^self count: [:arg1 |  true ]weakSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5  ^self classInstaller make: [:arg6 |  arg6           superclass: self;           name: arg1;           layoutClass: WeakLayout;           slots: arg2 asSlotCollection;           sharedVariablesFromString: arg3;           sharedPools: arg4;           category: arg5;           environment: self environment ]intanceSpecificMetaLinksAvailable  ^falsegtFilter  ^selfpropertyValueAt: arg1  ^self propertyAt: arg1link: arg1 toNodes: arg2  arg2 do: [:arg3 |  self link: arg1 toAST: arg3 ]testNegativeZeroSign  self assert: Float negativeZero sign equals: 0.  self assert: Float negativeZero signBit equals: 1codeForNoSource  Smalltalk hasCompiler ifFalse: [ ^nil ].  ^(self compiler decompileMethod: self) formattedCodecriticClass  ^selfveryDeepFixupWith: arg1  simulateValueWithArguments: arg1 caller: arg2  | tmp1 tmp2 |  tmp1 := (Context newForMethod: outerContext method) setSender: arg2 receiver: outerContext receiver method: outerContext method closure: self startpc: startpc.  ((tmp1 objectClass: arg1) ~~ Array or: [ numArgs ~= arg1 size ]) ifTrue: [ ^Context primitiveFailTokenFor: nil ].  tmp2 := self basicSize.  tmp1 stackp: tmp2 + numArgs.  1 to: numArgs do: [:arg3 |  tmp1 at: arg3 put: (arg1 at: arg3) ].  1 to: tmp2 do: [:arg3 |  tmp1 at: arg3 + numArgs put: (self at: arg3) ].  ^tmp1messageText  ^messageText ifNil: [ String empty ]select: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self basicSize.  tmp2 := self species new: tmp1.  tmp3 := 0.  1 to: tmp1 do: [:arg2 |  (self basicAt: arg2) ifNotNil: [:arg3 |  (arg1 value: arg3) ifTrue: [ tmp2 basicAt: (tmp3 := tmp3 + 1) put: arg3 ] ] ].  tmp4 := self species new: tmp3.  tmp4 basicReplaceFrom: 1 to: tmp3 with: tmp2 startingAt: 1.  ^tmp4encodeOn: arg1  | tmp1 |  tmp1 := GRSignPrinter new , (GRNumberPrinter new precision: self scale).  tmp1 print: self on: arg1testTicksOffset  self assert: aDateAndTime equals: (aDateAndTime ticks: #(2415386 0 0) offset: DateAndTime localOffset)allProtocols  ^{allProtocol} , protocols asArrayisSelfEvaluating  ^self == ProcessortestDayMonthYearDo  | tmp1 |  tmp1 := 0.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  tmp1 := tmp1 + 1 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg3 ]) equals: 1970.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg2 ]) equals: 1.  self assert: (aDateAndTime dayMonthYearDo: [:arg1 :arg2 :arg3 |  arg1 ]) equals: 1- arg1  < primitive: 22>  ^super - arg1truncated  self isIntegerPoint ifTrue: [ ^self ].  ^x truncated @ y truncatedsetDescriptionInMetacelloVersion: arg1  arg1 setDescription: selfprintString  | tmp1 tmp2 tmp3 tmp4 |  self = 0 ifTrue: [ ^'0' ].  self < 0 ifTrue: [ ^'-' , self negated printString ].  tmp4 := self decimalDigitLength.  tmp3 := String new: tmp4.  tmp1 := self.  tmp4 to: 1 by: -1 do: [:arg1 |  tmp2 := tmp1 // 10.        tmp3 byteAt: arg1 put: 48 + (tmp1 - (tmp2 * 10)).        tmp1 := tmp2 ].  ^tmp3compiledMethod  ^selfcompileAll  ^self compileAllFrom: selfcaseOf: arg1 otherwise: arg2  arg1 associationsDo: [:arg3 |  arg3 key value = self ifTrue: [ ^arg3 value value ] ].  ^arg2 valuetestPrintMinutes  self assert: aTime printMinutes equals: '12:34 pm'testAddCategory  self organization addCategory: 'test-protocol'.  self assert: (self organization categories includes: 'test-protocol')\\\ arg1  ^(self digitDiv: arg1 neg: false) secondrespondsTo: arg1  ^self class canUnderstand: arg1isInfinite  ^falseargumentNames  ^self propertyAt: #argumentNames ifAbsent: [ super argumentNames ]flipBy: arg1 centerAt: arg2  ^(origin flipBy: arg1 centerAt: arg2) rectangle: (corner flipBy: arg1 centerAt: arg2)testDaysInYear  self assert: aTimespan daysInYear equals: 365isSystemWindow  ^falsepsValueAt: arg1 put: arg2  env ifNil: [ env := WeakArray new: PSKeys size ].  env size < PSKeys size ifTrue: [ env := env grownBy: PSKeys size - env size ].  ^env at: arg1 put: arg2testUnionWithDisjoint  self assert: (aTimespan union: aDisjointTimespan) equals: (Timespan starting: jan01 duration: 14 days)basicCheckClass: arg1  | tmp1 |  tmp1 := Set new.  (arg1 includesSelector: #veryDeepInner:) ifTrue: [ | tmp2 |        tmp2 := arg1 >> #veryDeepInner:.        (self doesMethod: #veryDeepInner: writeAllInstanceVariablesOfClass: arg1) ifFalse: [ tmp1 add: tmp2 ] ].  (arg1 includesSelector: #veryDeepCopyWith:) ifTrue: [ | tmp3 |        tmp3 := arg1 >> #veryDeepCopyWith:.        tmp3 size > 20 & (tmp3 literals includes: #veryDeepCopyWith:) not ifTrue: [ (self doesMethod: #veryDeepCopyWith: writeAllInstanceVariablesOfClass: arg1) ifFalse: [ tmp1 add: tmp3 ] ] ].  ^tmp1asMinimalDecimalFraction  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 tmp16 tmp17 tmp18 |  self isFinite ifFalse: [ self error: 'Only finite Float can be converted to a Fraction' ].  self = 0.0 ifTrue: [ ^0 ].  self < 0.0 ifTrue: [ ^self negated asMinimalDecimalFraction negated ].  tmp18 := 0.  tmp17 := 0.  tmp1 := self significandAsInteger.  tmp9 := tmp1 even.  tmp2 := self exponent - 52 max: MinValLogBase2.  tmp3 := (self exponent * 10 asFloat reciprocalLogBase2 - 1.0e-10) ceiling.  tmp2 >= 0 ifTrue: [ tmp1 ~= 16r10000000000000 ifTrue: [ tmp4 := tmp1 bitShift: 1 + tmp2.              tmp5 := 2.              tmp6 := tmp7 := 1 bitShift: tmp2 ] ifFalse: [ tmp4 := tmp1 bitShift: 2 + tmp2.              tmp5 := 4.              tmp6 := 2 * (tmp7 := 1 bitShift: tmp2) ] ] ifFalse: [ (tmp2 = MinValLogBase2 or: [ tmp1 ~= 16r10000000000000 ]) ifTrue: [ tmp4 := tmp1 bitShift: 1.              tmp5 := 1 bitShift: 1 - tmp2.              tmp6 := tmp7 := 1 ] ifFalse: [ tmp4 := tmp1 bitShift: 2.              tmp5 := 1 bitShift: 2 - tmp2.              tmp6 := 2.              tmp7 := 1 ] ].  tmp3 >= 0 ifTrue: [ tmp5 := tmp5 * (10 raisedToInteger: tmp3) ] ifFalse: [ tmp8 := 10 raisedToInteger: tmp3 negated.        tmp4 := tmp4 * tmp8.        tmp6 := tmp6 * tmp8.        tmp7 := tmp7 * tmp8 ].  ((tmp4 + tmp6 < tmp5) not and: [ tmp9 or: [ tmp4 + tmp6 > tmp5 ] ]) ifTrue: [ tmp3 := tmp3 + 1 ] ifFalse: [ tmp4 := tmp4 * 10.        tmp6 := tmp6 * 10.        tmp7 := tmp7 * 10 ].  (tmp13 := tmp3 between: -3 and: 6) ifTrue: [ tmp14 := tmp3.        tmp3 <= 0 ifTrue: [ tmp17 := 10 raisedTo: tmp3 negated ] ] ifFalse: [ tmp14 := 1 ].  tmp15 := 1 - tmp5 lowBit.  tmp16 := tmp5 bitShift: tmp15.  [ tmp10 := (tmp4 bitShift: tmp15) // tmp16.  tmp4 := tmp4 - (tmp10 * tmp5).  (tmp11 := (tmp4 > tmp7) not and: [ tmp9 or: [ tmp4 < tmp7 ] ]) | (tmp12 := (tmp4 + tmp6 < tmp5) not and: [ tmp9 or: [ tmp4 + tmp6 > tmp5 ] ]) ] whileFalse: [ tmp18 := 10 * tmp18 + tmp10.        tmp17 := 10 * tmp17.        tmp4 := tmp4 * 10.        tmp6 := tmp6 * 10.        tmp7 := tmp7 * 10.        tmp14 := tmp14 - 1.        tmp14 = 0 ifTrue: [ tmp17 := 1 ] ].  tmp12 ifTrue: [ (tmp11 not or: [ tmp4 * 2 >= tmp5 ]) ifTrue: [ tmp10 := tmp10 + 1 ] ].  tmp18 := 10 * tmp18 + tmp10.  tmp17 := 10 * tmp17.  tmp14 > 0 ifTrue: [ tmp18 := (10 raisedTo: tmp14 - 1) * tmp18 ].  tmp13 ifFalse: [ tmp3 - 1 > 0 ifTrue: [ tmp18 := (10 raisedTo: tmp3 - 1) * tmp18 ] ifFalse: [ tmp17 := (10 raisedTo: 1 - tmp3) * (tmp17 max: 1) ] ].  tmp17 < 2 ifTrue: [ ^tmp18 ].  ^tmp18 / tmp17testRNG  | tmp1 tmp2 |  tmp1 := (1 to: 100) collect: [:arg1 |  unicodeGenerator randomCharacter ].  tmp2 := tmp1 asSet size.  self assert: tmp2 = 100 description: (100 - tmp2) asString , ' duplicates'benchFib  ^self < 2 ifTrue: [ 1 ] ifFalse: [ (self - 1) benchFib + (self - 2) benchFib + 1 ]testEmbeddingSourceCodeWide  self testEmbeddingSourceCode: 'doit ^''Под южно дърво, цъфтящо в синьо, бягаше малко пухкаво зайче.'' 'testExample1  | tmp1 |  tmp1 := self class compiledMethodAt: #example1.  self assert: (self hasInstVarRef: tmp1)gtDisplayOn: arg1  arg1     print: self methodClass;     nextPutAll: '>>';     store: self selectorhasComment  ^self instanceSide organization hasCommentisLarge  ^falseprotocolsOfSelector: arg1  ^(self protocols select: [:arg2 |  arg2 includesSelector: arg1 ]) asArrayscheduleDuration  ^schedule sumfileOutOn: arg1 initializing: arg2  SystemNotification signal: self name.  super fileOutOn: arg1.  self class nonTrivial ifTrue: [ arg1           cr;           nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!';           cr;           cr.        self class fileOutOn: arg1 initializing: arg2 ]testIsTerminatingForcedTermination  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp2 := false.  tmp3 := false.  tmp6 := Semaphore new.  tmp6 signal.  tmp1 := [ tmp3 := true.  [ tmp6     wait;     wait ] ensure: [ tmp4 := Processor activeProcess.        tmp5 value.        tmp2 := true ] ] newProcess.  tmp1 priority: Processor activePriority - 1.  self assert: tmp1 isSuspended.  self deny: tmp1 isTerminating.  self deny: tmp1 isTerminated.  self deny: tmp3.  self deny: tmp2.  tmp1 resume.  [ tmp6 isSignaled ] whileTrue: [ 50 milliSeconds asDelay wait ].  self deny: tmp1 isSuspended.  self deny: tmp1 isTerminating.  self deny: tmp1 isTerminated.  self assert: tmp3.  self deny: tmp2.  self deny: tmp4 identicalTo: tmp1.  tmp6 signal.  tmp1 terminate.  tmp5 := [ self assert: tmp1 isSuspended.  self assert: tmp1 isTerminating.  self deny: tmp1 isTerminated.  self assert: tmp3.  self deny: tmp2.  self assert: tmp4 identicalTo: tmp1 ].  [ tmp1 isTerminated ] whileFalse: [ 50 milliSeconds asDelay wait ].  self assert: tmp1 isSuspended.  self assert: tmp1 isTerminating.  self assert: tmp1 isTerminated.  self assert: tmp3.  self assert: tmp2.  self assert: tmp4 identicalTo: tmp1fuelPointsTo: arg1  < primitive: 132>  hasMethodReturn  ^(InstructionStream on: self) scanFor: [:arg1 |  self encoderClass methodReturnBytecodes includes: arg1 ]asJob  ^Job block: selfprintOn: arg1  super printOn: arg1.  arg1     nextPutAll: '(';     nextPutAll: self identityHash printString;     nextPutAll: ') on ';     nextPutAll: ticker classNameasActionSequence  ^WeakActionSequence with: selfsetTraitComposition: arg1  ^self uses: arg1 slots: self slotsstringForFileOut  ^String streamContents: [:arg1 |  | tmp1 |        tmp1 := 1.        1 to: categoryArray size do: [:arg2 |  arg1 nextPut: $(.              (categoryArray at: arg2) asString printOn: arg1.              [ tmp1 <= (categoryStops at: arg2) ] whileTrue: [ arg1                       space;                       nextPutAll: (elementArray at: tmp1).                    tmp1 := tmp1 + 1 ].              arg1                 nextPut: $);                 cr ] ]testEqual  self assert: aTime equals: (Time readFrom: '12:34:56' readStream).  self assert: aTime equals: (Time readFrom: '12:34:56.00' readStream).  self assert: aTime equals: (Time readFrom: '12:34:56.0000' readStream)numberOfDigitsInBase: arg1  | tmp1 tmp2 tmp3 |  self negative ifTrue: [ ^self negated numberOfDigitsInBase: arg1 ].  self < arg1 ifTrue: [ ^1 ].  arg1 isPowerOfTwo ifTrue: [ ^self highBit + arg1 highBit - 2 quo: arg1 highBit - 1 ].  tmp2 := self.  tmp3 := 0.  [ tmp1 := arg1 = 10 ifTrue: [ ((tmp2 highBit - 1) * 1233 >> 12) + 1 ] ifFalse: [ tmp2 highBit quo: arg1 highBit ].  tmp3 := tmp3 + tmp1.  (tmp2 := tmp2 quo: (arg1 raisedToInteger: tmp1)) < arg1 ] whileFalse.  ^tmp2 = 0 ifTrue: [ tmp3 ] ifFalse: [ tmp3 + 1 ]handleSignal: arg1  < debuggerCompleteToSender>  (self exceptionClass handles: arg1) ifFalse: [ ^self nextHandlerContext handleSignal: arg1 ].  self evaluateSignal: arg1isUsed  ^trueprint: arg1 on: arg2  asIEEE32BitWord  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  self = 0.0 ifTrue: [ ^self basicAt: 1 ].  tmp1 := self basicAt: 1.  tmp2 := self basicAt: 2.  tmp3 := tmp1 bitAnd: 16r80000000.  tmp5 := ((tmp1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.  tmp4 := (tmp2 bitShift: -29) + ((tmp1 bitAnd: 16rFFFFF) bitShift: 3).  tmp7 := tmp2 bitAnd: 16r1FFFFFFF.  tmp5 < -24 ifTrue: [ ^tmp3 ].  tmp5 <= 0 ifTrue: [ tmp8 := 1 bitShift: tmp5 negated.        tmp4 := tmp4 bitOr: 16r800000.        tmp9 := (tmp4 bitAnd: tmp8) isZero not and: [ tmp7 isZero not or: [ (tmp4 bitAnd: tmp8 - 1) isZero not or: [ (tmp4 bitAnd: tmp8 * 2) isZero not ] ] ].        tmp4 := tmp4 bitShift: tmp5 - 1 ] ifFalse: [ tmp9 := (tmp7 bitAnd: 16r10000000) isZero not and: [ (tmp4 bitAnd: 16r1) isZero not or: [ (tmp7 bitAnd: 16r0FFFFFFF) isZero not ] ] ].  tmp9 ifTrue: [ tmp4 := tmp4 + 1.        tmp4 > 16r7FFFFF ifTrue: [ tmp4 := 0.              tmp5 := tmp5 + 1 ] ].  tmp5 > 254 ifTrue: [ tmp5 := 255.        self isNaN ifTrue: [ tmp4 isZero ifTrue: [ tmp4 := 1 ] ] ifFalse: [ tmp4 := 0 ] ].  tmp6 := (tmp3 bitOr: ((tmp5 max: 0) bitShift: 23)) bitOr: tmp4.  ^tmp6propertyKeysAndValuesDo: arg1  1 to: self basicSize do: [:arg2 |  | tmp1 |        (tmp1 := self basicAt: arg2) isVariableBinding ifTrue: [ arg1 value: tmp1 key value: tmp1 value ] ]message  ^Message selector: selector arguments: argumentscallPrimitive: arg1  | tmp1 |  tmp1 := receiver tryPrimitive: arg1 withArgs: self arguments.  arg1 >= (1 << 15) ifTrue: [ ^self push: tmp1 ].  (self isFailToken: tmp1) ifTrue: [ ^self ].  self push: tmp1.  self methodReturnTopas31BitSmallInt  ^selfsubclassesDo: arg1  ^Class subclassesDo: [:arg2 |  arg2 isMeta ifTrue: [ arg1 value: arg2 soleInstance ] ]pvtCritical: arg1 startingAt: arg2  | tmp1 |  arg2 > array size ifTrue: [ ^arg1 value ].  tmp1 := array at: arg2.  ^tmp1 critical: [ self pvtCritical: arg1 startingAt: arg2 + 1 ]testNonResumableOuter  self should: [ [ Error signal.        4 ] on: Error do: [:arg1 |  arg1 outer.              arg1 return: 5 ] ] raise: ErrorinitSignals  excessSignals := 0isNaN  ^self ~= selfintanceSpecificMetaLinksAvailable  ^truebaseComposition  ^TaEmptyComposition newdeprecatedMethod5  addSubclass: arg1  arg1 superclass ~~ self ifTrue: [ ^self error: arg1 name , ' is not my subclass' ].  subclasses ifNil: [ self subclasses: (Array with: arg1).        ^self ].  self subclasses do: [:arg2 |  arg2 == arg1 ifTrue: [ ^self ] ].  self subclasses: (subclasses copyWith: arg1)decodeZip  | tmp1 tmp2 |  tmp1 := self decodeLengthField.  tmp2 := ByteArray new: tmp1.  1 to: tmp1 do: [:arg1 |  tmp2 at: arg1 put: (method at: method size - size + arg1) ].  data := (ZipReadStream on: tmp2) contents asString convertFromEncoding: 'utf8'method  ^self subclassResponsibility