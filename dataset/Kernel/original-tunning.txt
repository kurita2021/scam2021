ffiInstVarArgument: argName generator: generator  (self allInstVarNames includes: argName) ifFalse: [ ^nil ].  ^FFIInstVarArgument new     argName: argName;     yourselfsetAuthorInMetacelloConfig: aMetacelloConfig  aMetacelloConfig setAuthorWithBlock: selfln  | res |  self <= 0 ifTrue: [ ^DomainError signal: 'ln is only defined for x > 0' from: 0 ].  numerator < denominator ifTrue: [ ^self reciprocal ln negated ].  res := super ln.  res isFinite ifTrue: [ ^res ].  ^numerator ln - denominator lniceSemanticVersion  ^IceSemanticVersion major: self asInteger minor: 0 patch: 0~= aNumber  < primitive: 8>  ^super ~= aNumberhasComment  ^self commentRemoteString isNotNiltestReflexive  | t |  t := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self assert: t equals: tnumLocalTemps  ^self method encoderClass numLocalTempsForBlockAt: startpc in: outerContext methodprintFormat: formatArray  ^String new: 16 streamContents: [:aStream |  self printOn: aStream format: formatArray ]sqrt  ^DomainError signal: 'sqrt undefined for number less than zero.'greaseString  ^String streamContents: [:stream |  x printOn: stream.        stream nextPut: $@.        (y notNil and: [ y negative ]) ifTrue: [ stream space ].        y printOn: stream ]compiler  ^self compilerClass new     environment: self environment;     class: selftestYesterday  self deny: aDateAndTime equals: DateAndTime yesterdaytestAsDate  self assert: aDateAndTime asDate equals: 'January 1, 1970' asDateobject: anObject  object := anObjectwholeMicroseconds  ^(nanos rem: 1e6) quo: 1e3monthAbbreviation  ^self monthName copyFrom: 1 to: 3stonName  ^#ClassincludesAll: aCollection  ^aCollection allSatisfy: [:elem |  self includes: elem ]activeProcess  ^activeProcess effectiveProcesssetUp  super setUp.  aDate := DateAndTime year: 2003 month: 01 day: 07 hour: 0 minute: 0 second: 0.  aDuration := Duration days: 91 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.  aTimespan := Timespan starting: aDate duration: aDurationtestMetaclass  self assert: OrderedCollection class class identicalTo: Metaclass.  self assert: Dictionary class class identicalTo: Metaclass.  self assert: Object class class identicalTo: MetaclasstestPrintOn  self assert: [ 1 + 2 ] printString equals: '[ 1 + 2 ]'testStoreOn  | stream |  aDuration storeOn: (stream := (String new: 20) writeStream).  self assert: stream contents equals: '(Duration seconds: 93784 nanoSeconds: 5)'removeInstVarNamed: aString  ^self removeSlot: (self slotNamed: aString)exit  nestingLevel := nestingLevel - 1.  nestingLevel < 1 ifTrue: [ ownerProcess := nil.        mutex signal ]hasEqualTicks: aDateAndTime  ^self julianDayNumberUTC = aDateAndTime julianDayNumberUTC and: [ seconds = aDateAndTime secondsSinceMidnightUTC and: [ nanos = aDateAndTime nanoSecond ] ]findSecondToOldestSimilarSender  | secondContext context lastContext |  secondContext := self.  context := self.  [ lastContext := context findSimilarSender.  lastContext isNil ] whileFalse: [ secondContext := context.        context := lastContext ].  ^secondContexttestFloorLog2  | aBitLess aBitMore |  aBitMore := 1 + Float epsilon.  aBitLess := 1 - Float epsilon.  Float emin + 1 to: Float emax - 1 do: [:exp |  | exactPowerOfTwo |        exactPowerOfTwo := 1.0 timesTwoPower: exp.        self assert: (exactPowerOfTwo floorLog: 2) equals: exp.        self assert: (exactPowerOfTwo * aBitMore floorLog: 2) equals: exp.        self assert: (exactPowerOfTwo * aBitLess floorLog: 2) equals: exp - 1 ]topRight  ^corner x @ origin ytestIfFalseIfTrue  self assert: (false ifFalse: [ 'falseAlternativeBlock' ] ifTrue: [ 'trueAlternativeBlock' ]) equals: 'falseAlternativeBlock'executionsPerSecond  ^self frequencytestGpsExample1  | result array |  array := (1 to: 100) asArray.  result := array inject: 0 into: [:sum :val |  sum + val ].  self assert: (self gpsExample1: array) equals: resulttestMinMax  self assert: (10 min: 20 max: 12) equals: 12.  self assert: (13 min: 20 max: 12) equals: 13.  self assert: (12 min: 20 max: 12) equals: 12.  self assert: (100 min: 20 max: 12) equals: 20.  self assert: (42 min: 50 max: 40) equals: 42.  self assert: (42 min: 50 max: 45) equals: 45.  self assert: (42 min: 40 max: 30) equals: 40highBitOfMagnitude  ^self subclassResponsibilityparseFourDigitYear  year := self parse: 'year' expectedSize: 4withArgumentsDo: aBlock  ^aBlock valueWithArguments: self argumentsabs  ^x abs @ y absaddSlot: aClassSlot  ^self instanceSide addClassSlot: aClassSlotmixedMethod  RecursionStopper during: [ self assert: value equals: 0.        value := value + 1.        RecursionStopper during: [ value := value + 1 ].        self assert: value equals: 1.        self mixedMethod.        self assert: value equals: 1 ].  RecursionStopper during: [ self assert: value equals: 1.        ^2 ].  self assert: value equals: 1.  ^valueneedsSlotClassDefinition  ^self slotsNeedFullDefinition or: [ self class slotsNeedFullDefinition or: [ self classVariablesNeedFullDefinition ] ]numArgs  ^numArgsat: anIndex  | basicSize counter dep |  anIndex > 0 ifTrue: [ basicSize := self basicSize.        anIndex <= basicSize ifTrue: [ counter := 0.              1 to: basicSize do: [:i |  (dep := self basicAt: i) == nil ifFalse: [ (counter := counter + 1) = anIndex ifTrue: [ ^dep ] ] ] ] ].  self error: 'access with an index out of bounds'isNamedPrimitive  ^self primitive = 117beingWaitedOn  ^beingWaitedOninstanceCount  | count |  count := 0.  self allInstancesDo: [:x |  count := count + 1 ].  ^counthexDigitValue  | codePoint |  ^((codePoint := self asInteger) between: 0 and: 127) ifTrue: [ #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 0 1 2 3 4 5 6 7 8 9 nil nil nil nil nil nil nil 10 11 12 13 14 15 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 10 11 12 13 14 15 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil) at: codePoint + 1 ] ifFalse: [ nil ]testDaysLeftInYear  self assert: aTimespan daysLeftInYear equals: 364testEnd  self assert: aTimespan end + (Duration nanoSeconds: 1) equals: aDisjointTimespan start.  self assert: aTimespan end equals: (DateAndTime year: 2005 month: 1 day: 7 hour: 23 minute: 59 second: 59 nanoSecond: 999999999 offset: 0 hours)willReturn  ^self method encoderClass isReturnAt: pc in: self methodisCasedLetter  ^self characterSet isCasedLetter: selfelementCategoryDict  | dict firstIndex lastIndex |  elementArray ifNil: [ ^nil ].  dict := Dictionary new: elementArray size.  1 to: categoryStops size do: [:cat |  firstIndex := self firstIndexOfCategoryNumber: cat.        lastIndex := self lastIndexOfCategoryNumber: cat.        firstIndex to: lastIndex do: [:el |  dict at: (elementArray at: el) put: (categoryArray at: cat) ] ].  ^dictsetX: xValue setY: yValue  x := xValue.  y := yValueand: alternativeBlock  self subclassResponsibilitytestAccessing  self     assert: time hours equals: 4;     assert: time minutes equals: 2;     assert: time seconds equals: 47;     assert: time asSeconds equals: 14567classVarNames  ^#()printStringBase: b  self < 0 ifTrue: [ ^'-' , (self negated printStringBase: b) ].  self < b ifTrue: [ ^String with: (Character digitValue: self) ].  ^self printStringBase: b nDigits: (self numberOfDigitsInBase: b)testContinuationExample3  | array |  array := (1 to: 20) asOrderedCollection.  self assert: (self continuationExample3: array) equals: (array collect: [:x |  x * x - 10 ])errorReportOn: stream  | stackDepth aContext |  stream     print: Date today;     space;     print: Time now;     cr.  stream cr.  stream     nextPutAll: 'VM: ';     nextPutAll: Smalltalk os name asString;     nextPutAll: ' - ';     nextPutAll: Smalltalk os subtype asString;     nextPutAll: ' - ';     nextPutAll: Smalltalk os version asString;     nextPutAll: ' - ';     nextPutAll: Smalltalk vm version asString;     cr.  stream     nextPutAll: 'Image: ';     nextPutAll: SystemVersion current version asString;     nextPutAll: ' [';     nextPutAll: Smalltalk lastUpdateString asString;     nextPutAll: ']';     cr.  stream cr.  stackDepth := 0.  aContext := self.  [ aContext notNil and: [ (stackDepth := stackDepth + 1) < 40 ] ] whileTrue: [ aContext printDetails: stream.        stream cr.        aContext := aContext sender ].  stream     cr;     nextPutAll: '--- The full stack ---';     cr.  aContext := self.  stackDepth := 0.  [ aContext == nil ] whileFalse: [ stackDepth := stackDepth + 1.        stackDepth = 40 ifTrue: [ stream                 nextPutAll: ' - - - - - - - - - - - - - - -  			- - - - - - - - - - - - - - - - - -';                 cr ].        stream           print: aContext;           cr.        stackDepth > 200 ifTrue: [ stream nextPutAll: '-- and more not shown --'.              ^self ].        aContext := aContext sender ]initialize  super initialize.  forkedProcesses := OrderedCollection newisSelfEvaluating  ^self isObsolete notasFraction  ^selftestIsEmptyOrNil  self assert: nil isEmptyOrNilinitialize  super initialize.  vmSimTheTimerSemaphore := Semaphore new.  vmSimNow := 0variableWordSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory  ^self variableWordSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategoryasDateAndTime  ^DateAndTime today + selftestOneOverTwo  | benchmarkResult |  benchmarkResult := BenchmarkResult new.  benchmarkResult iterations: 1.  benchmarkResult elapsedTime: 2 second.  self deny: benchmarkResult isEmpty.  self assert: benchmarkResult iterations equals: 1.  self assert: benchmarkResult elapsedTime equals: 2 second.  self assert: benchmarkResult frequency equals: 0.5.  self assert: benchmarkResult executionsPerSecond equals: 0.5.  self assert: benchmarkResult period equals: 2 second.  self assert: benchmarkResult timePerExecution equals: 2 second.  self assert: benchmarkResult shortPrintString equals: '0.500 per second'.  self deny: benchmarkResult printString isEmptyprintYMDOn: aStream  ^self printYMDOn: aStream withLeadingSpace: falserfvalue  < primitive: 201>  < metaLinkOptions: #(+ optionDisabledLink)>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  ^self primitiveFailedprintOn: aStream base: base  aStream nextPut: $(.  numerator printOn: aStream base: base.  aStream nextPut: $/.  denominator printOn: aStream base: base.  aStream nextPut: $)inform: aString  aString isEmptyOrNil ifFalse: [ UIManager default inform: aString ]extensionProtocols  ^self protocols select: #isExtensionProtocolsendNodes  ^self methods flatCollect: [:each |  each sendNodes ]testDegreeSin  45.0 degreeSin.  self assert: (45.0 degreeSin squared - 0.5) abs <= Float epsilon.  self assert: (30.0 degreeSin - 0.5) abs <= Float epsilon.  self assert: (-30.0 degreeSin + 0.5) abs <= Float epsilon.  -360.0 to: 360.0 do: [:i |  self assert: (i degreeSin closeTo: i degreesToRadians sin) ].  -10.0 to: 10.0 do: [:k |  self assert: (k * 360 + 90) degreeSin - 1 equals: 0.        self assert: (k * 360 - 90) degreeSin + 1 equals: 0.        self assert: (k * 360 + 180) degreeSin equals: 0.        self assert: (k * 360) degreeSin equals: 0 ]floatCenter  ^(self topLeft + self bottomRight) / 2.0resume  self resume: nilsimpleEnsureTestWithUparrowResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     yourselfallCallsOn  self isAnonymous ifTrue: [ ^#() ].  ^self usingMethods , self name asSymbol sendersisReturnField  ^self primitive between: 264 and: 519- aNumber  < primitive: 2>  ^super - aNumbercomments  ^self ast allChildren flatCollect: [:el |  el comments collect: [:c |  c contents ] ]allUnreferencedClassVariables  ^self allClassVariables reject: #isReferencedtestSimple  | benchmarkResult |  benchmarkResult := BenchmarkResult new.  benchmarkResult iterations: 100.  benchmarkResult elapsedTime: 4 seconds.  self deny: benchmarkResult isEmpty.  self assert: benchmarkResult iterations equals: 100.  self assert: benchmarkResult elapsedTime equals: 4 seconds.  self assert: benchmarkResult frequency equals: 25.  self assert: benchmarkResult executionsPerSecond equals: 25.  self assert: benchmarkResult period equals: 40 milliSeconds.  self assert: benchmarkResult timePerExecution equals: 40 milliSeconds.  self assert: benchmarkResult shortPrintString equals: '25.000 per second'.  self deny: benchmarkResult printString isEmptytestReentrantBlock  | fib |  fib := [:val |  val <= 0 ifTrue: [ self error: 'not a natural number' ].  val <= 2 ifTrue: [ 1 ] ifFalse: [ (fib value: val - 1) + (fib value: val - 2) ] ].  self should: [ fib value: 0 ] raise: self classForTestResult error.  self assert: (fib value: 1) equals: 1.  self assert: (fib value: 2) equals: 1.  self assert: (fib value: 3) equals: 2.  self assert: (fib value: 4) equals: 3.  self assert: (fib value: 5) equals: 5.  self assert: (fib value: 6) equals: 8expandBy: delta  ^delta asMargin expandRectangle: selfpushTemporaryVariable: offset  self push: (self at: offset + 1)testEmbeddingSourceCode  self testEmbeddingSourceCode: 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: newTrailer sourceCode equals: code.'.  self testEmbeddingSourceCode: (String loremIpsum: 30000)lowBit  | index |  self = 0 ifTrue: [ ^0 ].  index := 1.  [ (self byteAt: index) = 0 ] whileTrue: [ index := index + 1 ].  ^(self byteAt: index) lowBit + (8 * (index - 1))asText  ^self asString asTextremoveCategory: cat  | index lastStop |  index := categoryArray indexOf: cat ifAbsent: [ ^self ].  lastStop := index = 1 ifTrue: [ 0 ] ifFalse: [ categoryStops at: index - 1 ].  (categoryStops at: index) - lastStop > 0 ifTrue: [ ^self error: 'cannot remove non-empty category ' , cat ].  categoryArray := categoryArray copyReplaceFrom: index to: index with: Array new.  categoryStops := categoryStops copyReplaceFrom: index to: index with: Array new.  categoryArray isEmpty ifTrue: [ categoryArray := Array with: Default.        categoryStops := Array with: 0 ]testComparison  | a b c |  a := 16r1FFFFFFFFFFFFF1.  b := 16r1FFFFFFFFFFFFF3.  c := a asFloat.  self assert: (a = c & (b = c)) ==> (a = b).  self assert: 16r1FFFFFFFFFFFFF equals: 16r1FFFFFFFFFFFFF asFloat.  self assert: 16r1FFFFFFFFFFFFF equals: 16r1FFFFFFFFFFFFF asFloat asInteger.  self assert: ((1 bitShift: 54) + 1) / (1 bitShift: 54) > 1.  self assert: ((1 bitShift: 54) + 1) / (1 bitShift: 54) > 1.0.  self assert: ((1 bitShift: 54) - 1) / (1 bitShift: 54) < 1.  self assert: ((1 bitShift: 54) - 1) / (1 bitShift: 54) < 1.0.  1 to: 100 do: [:i |  i isPowerOfTwo ifTrue: [ self assert: 1 / i equals: (1 / i) asFloat ] ifFalse: [ self deny: 1 / i equals: (1 / i) asFloat ] ].  a := (11 raisedTo: 400) / 2.  b := (13 raisedTo: 400) / 2.  c := a asFloat.  self assert: (a = c & (b = c)) ==> (a = b).  self assert: a < Float infinity.  self assert: a > Float infinity negated.  self deny: 1 / (11 raisedTo: 400) equals: 0.  self deny: 1 / (11 raisedTo: 400) equals: 0.0.  self assert: ((Set new: 3)           add: 3;           add: 3.0;           size) equals: ((Set new: 4)           add: 3;           add: 3.0;           size)testEmpty  | benchmarkResult |  benchmarkResult := BenchmarkResult new.  self assert: benchmarkResult isEmpty.  self assert: benchmarkResult iterations isNil.  self assert: benchmarkResult elapsedTime isNil.  self deny: benchmarkResult shortPrintString isEmpty.  self deny: benchmarkResult printString isEmpty>= aNumber  aNumber isInteger ifTrue: [ self negative == aNumber negative ifTrue: [ self negative ifTrue: [ ^(self bytesCompare: aNumber) <= 0 ] ifFalse: [ ^(self bytesCompare: aNumber) >= 0 ] ] ifFalse: [ ^aNumber negative ] ].  ^aNumber adaptToInteger: self andCompare: #>=> aPoint  ^x > aPoint x and: [ y > aPoint y ]width  ^self right + self leftclassToBeTested  ^CompiledMethodstepToCallee  | context |  context := self.  [ (context := context step) == self ] whileTrue.  ^contextsetIsReadOnlyObject: aBoolean  < primitive: 164 error: ec>  ^self primitiveFailedsqrt  < primitive: 55>  | exp guess eps delta |  self <= 0.0 ifTrue: [ self = 0.0 ifTrue: [ ^0.0 ] ifFalse: [ ^DomainError signal: 'sqrt undefined for number less than zero.' ] ].  exp := self exponent // 2.  guess := self timesTwoPower: 0 - exp.  eps := guess * Epsilon.  eps := eps * eps.  delta := (self - (guess * guess)) / (guess * 2.0).  [ delta * delta > eps ] whileTrue: [ guess := guess + delta.        delta := (self - (guess * guess)) / (guess * 2.0) ].  ^guessgreaseString  ^self asStringcompiledMethodAt: selector  ^self methodDict at: selectorweekdayIndex  ^self dayOfWeekangleWith: aPoint  | ar ap |  ar := self angle.  ap := aPoint angle.  ^ap >= ar ifTrue: [ ap - ar ] ifFalse: [ Float pi * 2 - ar + ap ]immediateSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat  ^self immediateSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: catisFromTrait  ^self origin isTrait and: [ self origin ~= self methodClass ]removeClassVarNamed: aString interactive: interactive  | aSymbol varUserClass |  aSymbol := aString asSymbol.  (self classPool includesKey: aSymbol) ifFalse: [ ^self error: aString , ' is not a class variable' ].  varUserClass := self anyUserOfClassVarNamed: aSymbol.  varUserClass notNil & interactive ifTrue: [ (self confirm: (aString , ' is still used in code of class ' , varUserClass name , '.\Is it okay to move it to Undeclared?') withCRs) ifFalse: [ ^self ] ].  varUserClass ifNotNil: [ NewUndeclaredWarning signal: aString in: self name.        Undeclared declare: aSymbol from: self classPool ] ifNil: [ self classPool removeKey: aSymbol ].  self classPool isEmpty ifTrue: [ self classPool: nil ].  SystemAnnouncer uniqueInstance classModificationAppliedTo: self= anObject  ^anObject species == self species and: [ receiver == anObject receiver and: [ selector == anObject selector and: [ arguments = anObject arguments ] ] ]newAnonymousSubclass  ^Smalltalk anonymousClassInstaller make: [:builder |  builder           superclass: self;           layoutClass: self classLayout class ]nearestPointAlongLineFrom: p1 to: p2  | x21 y21 t x1 y1 |  p1 x = p2 x ifTrue: [ ^p1 x @ y ].  p1 y = p2 y ifTrue: [ ^x @ p1 y ].  x1 := p1 x asFloat.  y1 := p1 y asFloat.  x21 := p2 x asFloat - x1.  y21 := p2 y asFloat - y1.  t := ((y asFloat - y1) / x21 + ((x asFloat - x1) / y21)) / (x21 / y21 + (y21 / x21)).  ^(x1 + (t * x21)) @ (y1 + (t * y21))asRingMinimalDefinitionIn: anRGEnvironment  ^anRGEnvironment backend definitionFor: self ifAbsentRegister: [ RGClass named: self name asSymbol parent: anRGEnvironment ]testYearDay  self assert: aDateAndTime equals: (DateAndTime year: 1980 day: 1)tag  ^tag ifNil: [ self messageText ] ifNotNil: [ tag ]activateReturn: aContext value: value  ^self activateMethod: Context theReturnMethod withArgs: {value} receiver: aContext class: aContext classglmCritiqueSourceIn: composite  rotateBy: direction centerAt: c  | offset |  offset := self - c.  direction == #right ifTrue: [ ^offset y negated @ offset x + c ].  direction == #left ifTrue: [ ^offset y @ offset x negated + c ].  direction == #pi ifTrue: [ ^c - offset ].  self error: 'unrecognizable direction'= aNumber  aNumber class = self class ifTrue: [ ^self asFraction = aNumber asFraction ].  ^self asFraction = aNumbercategoryNameForTemporaryClasses  ^'Dummy-Tests-Class'fuelAfterMaterialization  testDayOfMonth  self assert: aTimespan dayOfMonth equals: 1testBlockEscape  | x |  tmp := 0.  x := [ tmp := tmp + 1.  tmp2 value ].  self callcc: [:cc |  tmp2 := cc.        x value ].  tmp2 := [  ].  x value.  self assert: tmp equals: 2testCriticalIfError  | lock |  lock := Semaphore forMutualExclusion.  [ lock critical: [ self criticalError ifError: [  ] ] ] forkAt: Processor userInterruptPriority.  self assert: lock isSignaledhasSender: context  | senderContext |  self == context ifTrue: [ ^false ].  senderContext := sender.  [ senderContext == nil ] whileFalse: [ senderContext == context ifTrue: [ ^true ].        senderContext := senderContext sender ].  ^falseasMilliseconds  ^self asMilliSecondscommentRemoteString  ^commentRemoteStringtestAsDate  self assert: aDateAndTime asDate equals: 'January 1, 1980' asDatepropertyAt: propName  | propertiesOrSelector |  ^(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifTrue: [ propertiesOrSelector propertyAt: propName ifAbsent: [ nil ] ] ifFalse: [ nil ]fuelPrepare  self isNamedPrimitive ifTrue: [ self literals first at: 4 put: 0 ]tearDown  fork ifNotNil: [ fork terminate.        fork := nil ].  super tearDowntestPrint24  self assert: aTime print24 equals: '12:34:56'testAsWeek  self assert: aTime asWeek equals: (DateAndTime current midnight + aTime) asWeeksizeInMemory  self class isImmediateClass ifTrue: [ ^0 ].  ^self class isVariable ifTrue: [ self class byteSizeOfInstanceOfSize: self basicSize ] ifFalse: [ self class byteSizeOfInstance ]last  self reverseDo: [:dep |  ^dep ].  self error: 'this collection is empty'phlowValue: anObject value: otherObject  ^self cull: anObject cull: otherObjecttestSupplyAnswerUsingOnlySubstringOfQuestion  self should: [ false = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('like' false)) ]> aNumber  < primitive: 44>  ^aNumber adaptToFloat: self andCompare: #>testSimpleEnsure  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTest)slotDefinitionString  ^String streamContents: [:str |  | useFull |        str nextPutAll: '{ '.        self localSlots do: [:slot |  str nextPutAll: slot definitionString.              useFull := slot needsFullDefinition ] separatedBy: [ str nextPutAll: '. '.              useFull ifTrue: [ str                       cr;                       tab;                       tab;                       tab;                       tab ] ].        str nextPutAll: ' }' ]testLiteral  | sd |  sd := 1.40s2.  self assert: ScaledDecimal identicalTo: sd class.  self assert: sd scale equals: 2.  self assert: '1.40s2' equals: sd printStringabstractBytecodeMessagesDo: aBlock  self method abstractBytecodeMessagesFrom: startpc to: self endPC do: aBlocktestDoubleOuterPass  self assertSuccess: (ExceptionTester new runTest: #doubleOuterPassTest)offset: anOffset  ^self class starting: (self start offset: anOffset) duration: self durationstonContainSubObjects  ^falserestartTopWith: method  method isQuick ifTrue: [ self popTo: suspendedContext sender ] ifFalse: [ suspendedContext privRefreshWith: method ]addInstVarNamed: aString  self subclassResponsibilityargumentNamed: aSymbol ifNone: aBlockClosure  ^self argumentAt: (self selector keywords indexOf: aSymbol asMutator ifAbsent: [ ^aBlockClosure value ])withThorougMethodsReferTo: aLiteral do: aBlock  | specialIndex |  specialIndex := Smalltalk specialSelectorIndexOrNil: aLiteral.  self selectorsAndMethodsDo: [:selector :method |  (method hasSelector: aLiteral specialSelectorIndex: specialIndex) ifTrue: [ aBlock value: method ] ]classify: selector under: aProtocolName suppressIfDefault: aBoolean  | oldCategory forceNotify oldProtocols |  forceNotify := (self protocolOrganizer includesSelector: selector) not.  oldCategory := self categoryOfElement: selector.  (forceNotify or: [ oldCategory ~= aProtocolName or: [ aBoolean not or: [ aProtocolName ~= Protocol unclassified ] ] ]) ifFalse: [ ^self ].  oldProtocols := self protocolOrganizer protocolsOfSelector: selector.  self protocolOrganizer classify: selector inProtocolNamed: aProtocolName.  aBoolean ifTrue: [ (oldProtocols select: #canBeRemoved) do: [:e |  self removeProtocol: e ] ].  oldCategory ifNotNil: [ self notifyOfChangedSelector: selector from: oldCategory to: aProtocolName ]asNanoSeconds  ^seconds * NanosInSecond + nanostearDown  classFactory cleanUp.  super tearDown% aNumber  ^self \\ aNumberasFullRingDefinition  | rgClass rgSuper rgSub rgMethod packageKeys |  rgClass := self asRingDefinition.  rgClass package: (RGContainer packageOfClass: rgClass).  self superclass notNil ifTrue: [ rgSuper := self superclass asRingDefinition.        rgClass superclass: rgSuper ] ifFalse: [ self isTrait ifTrue: [ rgSuper := Trait asRingDefinition.              rgClass superclass: rgSuper ] ].  self subclasses do: [:each |  rgSub := each asRingDefinition.        rgSub superclass: rgClass ].  packageKeys := RGContainer packageKeys.  self methodsDo: [:mth |  rgMethod := mth asActiveRingDefinition.        rgClass addMethod: rgMethod.        rgMethod package: (RGContainer packageOfMethod: rgMethod using: packageKeys) ].  self classSide methodsDo: [:mth |  rgMethod := mth asActiveRingDefinition.        rgClass classSide addMethod: rgMethod.        rgMethod package: (RGContainer packageOfMethod: rgMethod using: packageKeys) ].  ^rgClassprintOn: aStream base: b nDigits: n  self subclassResponsibilityisSubclassResponsibility: marker  ^marker == self class subclassResponsibilityMarkerencodeSourcePointer  encodedData := ByteArray new: 4.  encodedData at: 4 put: (data >> 24) + 251.  1 to: 3 do: [:i |  encodedData at: 4 - i put: ((data bitShift: (i - 3) * 8) bitAnd: 16rFF) ]reduce  ^selfwaitLastProcessTerminate  self waitProcessTermination: forkedProcesses lastresume: value  self resume: value through: (thisContext findNextUnwindContextUpTo: self)definition  (self needsSlotClassDefinition or: [ Slot showSlotClassDefinition ]) ifTrue: [ ^self definitionWithSlots ].  ^self definitionWithoutSlotsallSelectorsToTestInMethodFinder  ^#()setUp  super setUp.  june2nd1973 := self dateClass year: 1973 day: 153.  january23rd2004 := Date readFrom: '01-23-2004' readStream.  aTime := Time readFrom: '12:34:56 pm' readStreamveryDeepInner: deepCopier  classLayout  ^layout ifNil: [ | superLayout scope |        superLayout := superclass ifNil: [ FixedLayout new slotScope: LayoutEmptyScope instance ] ifNotNil: [:sl |  sl classLayout ].        scope := superLayout slotScope extend.        layout := superLayout class extending: superLayout scope: scope host: self ]add: aLinkOrObject afterLink: otherLink  | savedLink aLink |  lastLink == otherLink ifTrue: [ ^self addLast: aLinkOrObject ].  savedLink := otherLink nextLink.  aLink := aLinkOrObject asLink.  otherLink nextLink: aLink.  aLink nextLink: savedLink.  ^aLinktestNewSubclass  | cls |  cls := Point newSubclass.  self assert: cls isBehavior.  self assert: cls superclass identicalTo: Point.  self assert: (Point allSubclasses includes: cls).  self assert: cls instVarNames equals: #().  self assert: cls category equals: self unclassifiedCategory.  self assert: cls classVarNames equals: #().  cls removeFromSystemvalue  self value: niltimingPrioritySignalExpired  beingWaitedOn := false.  monitor signalLock: delaySemaphore inQueue: queuevariableByteSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory  | oldClassOrNil actualLayoutClass |  oldClassOrNil := self environment at: aName ifAbsent: [ nil ].  actualLayoutClass := (oldClassOrNil notNil and: [ oldClassOrNil classLayout class == CompiledMethodLayout ]) ifTrue: [ CompiledMethodLayout ] ifFalse: [ ByteLayout ].  ^self subclass: aName uses: aTraitComposition layout: actualLayoutClass slots: someInstanceVariableNames asSlotCollection classVariablesNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategorysubclassDefinerClass  ^self class subclassDefinerClassconvertTwoDigitsYear  (year between: 0 and: 99) ifTrue: [ year := self currentMillenium + year ]interpretV3PlusClosureJumpIfCond  | byte |  byte := self method at: pc.  (byte between: 152 and: 159) ifTrue: [ pc := pc + 1.        ^byte - 151 ].  (byte between: 168 and: 175) ifTrue: [ pc := pc + 2.        ^(byte bitAnd: 3) * 256 + (self method at: pc - 1) ].  ^nilsetFrameBit: boolean  | largeFrameBit newHeader |  largeFrameBit := 16r20000.  newHeader := self header bitAnd: largeFrameBit bitInvert.  boolean ifTrue: [ newHeader := newHeader + largeFrameBit ].  self objectAt: 1 put: newHeadertestExactRaisedTo  | f |  self assert: (4 / 9 raisedTo: 1 / 2) classAndValueEquals: 2 / 3.  self assert: (9 / 4 raisedTo: 1 / 2) classAndValueEquals: 3 / 2.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:a :b |  f := a / b.        self assert: (f squared raisedTo: 1 / 2) classAndValueEquals: f.        self assert: (f negated squared raisedTo: 1 / 2) classAndValueEquals: f.        f := b / a.        self assert: (f squared raisedTo: 1 / 2) classAndValueEquals: f.        self assert: (f negated squared raisedTo: 1 / 2) classAndValueEquals: f ].  self assert: (8 / 27 raisedTo: 1 / 3) classAndValueEquals: 2 / 3.  self assert: (27 / 8 raisedTo: 1 / 3) classAndValueEquals: 3 / 2.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:a :b |  f := a / b.        self assert: ((f raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: f.        self assert: ((f negated raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: f negated.        f := b / a.        self assert: ((f raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: f.        self assert: ((f negated raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: f negated ].  self assert: (4 / 9 raisedTo: 3 / 2) classAndValueEquals: 8 / 27.  self assert: (8 / 27 raisedTo: 2 / 3) classAndValueEquals: 4 / 9.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:a :b |  f := a / b.        self assert: ((f raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: f * f.        self assert: ((f raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: f * f * f.        self assert: ((f negated raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: f * f.        self assert: ((f negated raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: f * f * f.        f := b / a.        self assert: ((f raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: f * f.        self assert: ((f raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: f * f * f.        self assert: ((f negated raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: f * f.        self assert: ((f negated raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: f * f * f ].  self assert: (32 / 243 raisedTo: 3 / 5) classAndValueEquals: 8 / 27.  self assert: (8 / 27 raisedTo: 5 / 3) classAndValueEquals: 32 / 243.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:a :b |  f := a / b.        self assert: ((f raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: f * f * f.        self assert: ((f raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: f * f * f * f * f.        self assert: ((f negated raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: (f * f * f) negated.        self assert: ((f negated raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: (f * f * f * f * f) negated.        self assert: ((f raisedTo: -5) raisedTo: 3 / 5) classAndValueEquals: 1 / (f * f * f).        self assert: ((f raisedTo: -3) raisedTo: 5 / 3) classAndValueEquals: 1 / (f * f * f * f * f).        self assert: ((f negated raisedTo: -5) raisedTo: 3 / 5) classAndValueEquals: -1 / (f * f * f).        self assert: ((f negated raisedTo: -3) raisedTo: 5 / 3) classAndValueEquals: -1 / (f * f * f * f * f).        self assert: ((f raisedTo: 5) raisedTo: -3 / 5) classAndValueEquals: 1 / (f * f * f).        self assert: ((f raisedTo: 3) raisedTo: -5 / 3) classAndValueEquals: 1 / (f * f * f * f * f).        self assert: ((f negated raisedTo: 5) raisedTo: -3 / 5) classAndValueEquals: -1 / (f * f * f).        self assert: ((f negated raisedTo: 3) raisedTo: -5 / 3) classAndValueEquals: -1 / (f * f * f * f * f).        self assert: ((f raisedTo: 3) + 1 raisedTo: 5 / 3) isFloat.        self assert: ((f negated raisedTo: 3) - 1 raisedTo: 5 / 3) isFloat.        f := b / a.        self assert: ((f raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: f * f * f.        self assert: ((f raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: f * f * f * f * f.        self assert: ((f negated raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: (f * f * f) negated.        self assert: ((f negated raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: (f * f * f * f * f) negated.        self assert: ((f raisedTo: 3) + 1 raisedTo: 5 / 3) isFloat.        self assert: ((f negated raisedTo: 3) - 1 raisedTo: 5 / 3) isFloat ]printHierarchy  | aStream index |  index := 0.  aStream := (String new: 16) writeStream.  self allSuperclasses reverseDo: [:aClass |  aStream crtab: index.        index := index + 1.        aStream nextPutAll: aClass name.        aStream space.        aStream print: aClass instVarNames ].  aStream cr.  self printSubclassesOn: aStream level: index.  ^aStream contentshandleFailingFailingBasicNew  < primitive: 70>  OutOfMemory signal.  ^self basicNewprintDate: aDate format: formatArray on: aStream  self printYMD: aDate withLeadingSpace: false on: aStreamrunTestsBy: aBlock  TestExecutionEnvironment new beActiveDuring: aBlockisReturnSpecial  ^self primitive between: 256 and: 263printPrimitiveOn: aStream  | primDecl |  self isPrimitive ifFalse: [ ^self ].  self isExternalCallPrimitive ifTrue: [ ^aStream           print: (self literalAt: 1);           cr ].  aStream nextPutAll: '<primitive: '.  self isNamedPrimitive ifTrue: [ primDecl := self literalAt: 1.        (primDecl at: 2) asString printOn: aStream.        (primDecl at: 1) ifNotNil: [:moduleName |  aStream nextPutAll: ' module: '.              moduleName asString printOn: aStream ] ] ifFalse: [ aStream print: self primitive ].  self primitiveErrorVariableName ifNotNil: [:primitiveErrorVariableName |  aStream           nextPutAll: ' error: ';           nextPutAll: primitiveErrorVariableName ].  aStream     nextPut: $>;     crvariableSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat  ^self classInstaller make: [:builder |  builder           superclass: self;           name: t;           layoutClass: VariableLayout;           slots: f asSlotCollection;           sharedVariablesFromString: d;           sharedPools: s;           category: cat;           environment: self environment ]valueWithin: aDuration onTimeout: timeoutBlock  < debuggerCompleteToSender>  | theProcess delay watchdog tag |  aDuration <= Duration zero ifTrue: [ ^timeoutBlock value ].  theProcess := Processor activeProcess.  delay := aDuration asDelay.  tag := self.  watchdog := [ delay wait.  theProcess ifNotNil: [ theProcess signalException: (TimedOut new tag: tag) ] ] newProcess.  watchdog priority: Processor timingPriority - 1.  ^[ watchdog resume.  self ensure: [ theProcess := nil.        delay delaySemaphore signal ] ] on: TimedOut do: [:e |  e tag == tag ifTrue: [ timeoutBlock value ] ifFalse: [ e pass ] ]at: index  < primitive: 60>  index isInteger ifTrue: [ self class isVariable ifTrue: [ self errorSubscriptBounds: index ] ifFalse: [ self errorNotIndexable ] ].  index isNumber ifTrue: [ ^self at: index asInteger ] ifFalse: [ self errorNonIntegerIndex ]jsonOn: aRenderer  aRenderer scaledDecimal: selffuelAccept: aGeneralMapper  ^aGeneralMapper visitMethodContext: selftestAND  self deny: false & true.  self deny: false & falseprintOn: aStream  aStream nextPut: $<.  self selector precedence = 1 ifTrue: [ aStream nextPutAll: self selector ] ifFalse: [ self selector keywords with: self arguments do: [:key :arg |  aStream                 nextPutAll: key;                 space;                 print: arg;                 space ].        aStream skip: -1 ].  aStream nextPut: $>hasLiteralThorough: literal  1 to: self basicSize do: [:i |  | propertyOrPragma |        propertyOrPragma := self basicAt: i.        (propertyOrPragma isVariableBinding ifTrue: [ propertyOrPragma key == literal or: [ propertyOrPragma value == literal or: [ propertyOrPragma value isArray and: [ propertyOrPragma value hasLiteral: literal ] ] ] ] ifFalse: [ propertyOrPragma hasLiteral: literal ]) ifTrue: [ ^true ] ].  ^falseglobalName  ^globalName ifNil: [ [ globalName := ('TestGlobal' , 1e10 atRandom asString) asSymbol ] doWhileTrue: [ testingEnvironment includesKey: globalName ] ]returnPlusOne: anInteger  ^anInteger + 1testMinus  self assert: aDateAndTime - aDateAndTime equals: '0:00:00:00' asDuration.  self assert: aDateAndTime - '0:00:00:00' asDuration equals: aDateAndTime.  self assert: aDateAndTime - aDuration equals: (DateAndTime year: 1900 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours)testIsUppercase  self checkCorrespondanceOf: #isUppercase: and: #LutestPrintString  self assert: 1 printString equals: '1'.  self assert: -1 printString equals: '-1'.  Smalltalk vm wordSize = 4 ifTrue: [ self assert: SmallInteger minVal printString equals: '-1073741824'.        self assert: SmallInteger maxVal printString equals: '1073741823' ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: SmallInteger minVal printString equals: '-1152921504606846976'.        self assert: SmallInteger maxVal printString equals: '1152921504606846975' ].  self assert: 12345 printString equals: '12345'.  self assert: -54321 printString equals: '-54321'.  self assert: 0 decimalDigitLength equals: 1.  self assert: 4 decimalDigitLength equals: 1.  self assert: 12 decimalDigitLength equals: 2.  self assert: 123 decimalDigitLength equals: 3.  self assert: 1234 decimalDigitLength equals: 4.  self assert: 56789 decimalDigitLength equals: 5.  self assert: 657483 decimalDigitLength equals: 6.  self assert: 6571483 decimalDigitLength equals: 7.  self assert: 65174383 decimalDigitLength equals: 8.  self assert: 625744831 decimalDigitLength equals: 9.  self assert: 1000001111 decimalDigitLength equals: 10.  Smalltalk vm wordSize = 4 ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 10 ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 19 ]testInstanceCreation  | t |  t := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self     assert: t julianDayNumber equals: 1721427;     assert: t offset equals: 6 hours;     assert: t hour equals: 2;     assert: t minute equals: 3;     assert: t second equals: 4;     assert: t nanoSecond equals: 5interpretNext2ByteSistaV1Instruction: bytecode for: client extA: extA extB: extB startPC: startPC  | byte method |  method := self method.  byte := self method at: pc.  pc := pc + 1.  bytecode < 234 ifTrue: [ bytecode < 231 ifTrue: [ bytecode < 229 ifTrue: [ | literal |                    bytecode = 226 ifTrue: [ ^client pushReceiverVariable: (extA bitShift: 8) + byte ].                    literal := method literalAt: (extA bitShift: 8) + byte + 1.                    bytecode = 227 ifTrue: [ ^client pushLiteralVariable: literal ].                    ^client pushConstant: literal ].              bytecode = 229 ifTrue: [ ^client pushTemporaryVariable: byte ].              ^client pushClosureTemps: byte ].        bytecode = 231 ifTrue: [ ^byte < 128 ifTrue: [ client pushNewArrayOfSize: byte ] ifFalse: [ client pushConsArrayWithElements: byte - 128 ] ].        bytecode = 232 ifTrue: [ ^client pushConstant: (extB bitShift: 8) + byte ].        ^client pushConstant: (Character value: (extB bitShift: 8) + byte) ].  bytecode < 240 ifTrue: [ bytecode < 236 ifTrue: [ ^client send: (method literalAt: (extA bitShift: 5) + (byte // 8) + 1) super: bytecode = 235 numArgs: (extB bitShift: 3) + (byte \\ 8) ].        bytecode = 236 ifTrue: [ ^client trapIfNotInstanceOf: (method literalAt: (extA bitShift: 8) + byte + 1) ].        bytecode = 237 ifTrue: [ ^client jump: (extB bitShift: 8) + byte ].        ^client jump: (extB bitShift: 8) + byte if: bytecode = 238 ].  bytecode < 243 ifTrue: [ bytecode = 240 ifTrue: [ ^client popIntoReceiverVariable: (extA bitShift: 8) + byte ].        bytecode = 241 ifTrue: [ ^client popIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1) ].        ^client popIntoTemporaryVariable: byte ].  bytecode = 243 ifTrue: [ ^client storeIntoReceiverVariable: (extA bitShift: 8) + byte ].  bytecode = 244 ifTrue: [ ^client storeIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1) ].  bytecode = 245 ifTrue: [ ^client storeIntoTemporaryVariable: byte ].  ^self unusedBytecode: client at: startPCgenPushThisContext  stream nextPut: 137veryBasicAt: index  < primitive: 'dooo' module: 'bar' error: code>  ^codewaitFor: aSymbolOrNil maxMilliseconds: anIntegerOrNil  self checkOwnerProcess.  self waitInQueue: (self queueFor: aSymbolOrNil) maxMilliseconds: anIntegerOrNilbrowserPrintStringWith: anObject  | stream |  stream := (String new: 100) writeStream.  stream nextPut: $(.  priority printOn: stream.  self isSuspended ifTrue: [ stream nextPut: $s ].  stream nextPutAll: ') '.  stream nextPutAll: self name.  stream nextPut: $:.  stream space.  stream nextPutAll: anObject asString.  ^stream contentstestDateTime  self assert: aDateAndTime equals: (DateAndTime date: '01-01-1970' asDate time: '00:00:00' asTime)printPaddedWith: aCharacter to: aNumber  | aStream digits fPadding fLen iPadding iLen curLen periodIndex |  #Numeric.  aStream := (String new: 10) writeStream.  self printOn: aStream.  digits := aStream contents.  periodIndex := digits indexOf: $..  curLen := periodIndex - 1.  iLen := aNumber integerPart.  curLen < iLen ifTrue: [ iPadding := (String new: (iLen - curLen) asInteger)           atAllPut: aCharacter;           yourself ] ifFalse: [ iPadding := '' ].  curLen := digits size - periodIndex.  fLen := (aNumber asString copyAfterLast: $.) ifNotEmpty: [:s |  s asInteger ] ifEmpty: [ 0 ].  curLen < fLen ifTrue: [ fPadding := (String new: fLen - curLen)           atAllPut: aCharacter;           yourself ] ifFalse: [ fPadding := '' ].  ^iPadding , digits , fPaddingisSelfEvaluating  ^self isLiteralhaltOnCount: anInteger  < debuggerCompleteToSender>  Halt onCount: anIntegersetUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  DateAndTime localTimeZone: TimeZone default.  time := self timeClass fromSeconds: 14567.  aTime := Time readFrom: '12:34:56 pm' readStreaminspectorClass  ^EyeInspectortestPrint24On  self assert: (String streamContents: [:str |  aTime print24: true on: str ]) equals: '12:34:56'simpleEnsureTestWithErrorResults  ^OrderedCollection new     add: self doSomethingString;     add: 'Unhandled Exception';     add: self doYetAnotherThingString;     yourselftestMixedSignDigitLogic  self assert: (-2 bitAnd: 16rFFFFFFFF) equals: 16rFFFFFFFEarguments  ^argumentshash  | hash |  hash := self method hash bitXor: self selector hash.  1 to: self basicSize do: [:index |  hash := hash bitXor: (self basicAt: index) hash ].  ^hashsupportsClosureOpcodes  ^truerandomCodePointAtOrAbove: lower  ^self randomCodePointBetween: lower and: Unicode maxValuetestIsTerminatingNormalTermination  | sem process unwound started terminator |  sem := Semaphore new.  unwound := false.  started := false.  process := [ started := true.  [ sem wait ] ensure: [ terminator := Processor activeProcess.        unwound := true ] ] fork.  self deny: process isSuspended.  self deny: process isTerminating.  self deny: process isTerminated.  self deny: started.  self deny: unwound.  sem signal.  self waitForProcessTermination: process.  self assert: process isSuspended.  self assert: process isTerminating.  self assert: process isTerminated.  self assert: started.  self assert: unwound.  self assert: terminator identicalTo: processasAlphaImageMorph  ^self asMorphhandleLGitReturnCode  ^selftestMilliSeconds  #(#(5 0 5000000) #(1005 1 5000000) #(-5 0 -5000000) #(-1005 -1 -5000000) #(1234567 1234 567000000) #(-1234567 -1234 -567000000)) do: [:each |  | duration |        duration := Duration milliSeconds: each first.        self assert: duration asSeconds equals: each second.        self assert: duration nanoSeconds equals: each third ]setUp  super setUp.  testClass := Object newAnonymousSubclass.  testSubclass := testClass newAnonymousSubclass.  testClass compile: self methodName , ' self deprecated: ''method is deprecated'''testNthRoot  self assert: ((-2 raisedTo: 35) / (3 raisedTo: 20) raisedTo: 1 / 5) equals: (-2 raisedTo: 7) / (3 raisedTo: 4).  self assert: (1 / (1 << 2000) raisedTo: 1 / 100) equals: 1 / (1 << 20)testIsModifierSymbol  self checkCorrespondanceOf: #isModifierSymbol: and: #SkuserInterruptPriority  ^UserInterruptPriorityexponent  < primitive: 53>  | positive |  self >= 1.0 ifTrue: [ ^self floorLog: 2 ].  self > 0.0 ifTrue: [ positive := (1.0 / self) exponent.        self = (1.0 / (1.0 timesTwoPower: positive)) ifTrue: [ ^positive negated ] ifFalse: [ ^positive negated - 1 ] ].  self = 0.0 ifTrue: [ ^-1 ].  ^self negated exponentisDead  ^falsecleanCopy  ^self shallowCopy     cleanOuterContext;     yourselfisResumable  ^falsetrialConcurrent: numberConcurrentDelays priority: priority maxDuration: maxDuration fromSeed: seed  | delayProcesses |  delayProcesses := self generateDelayProcesses: numberConcurrentDelays priority: priority maxDuration: maxDuration fromSeed: seed.  Running := false.  [ Running := true.  delayProcesses do: [:process |  process resume ].  (Delay forSeconds: 1) wait ] ensure: [ Running := false ].  (Delay forSeconds: 1) wait.  delayProcesses do: [:process |  process terminate ].  Smalltalk garbageCollect.  Smalltalk garbageCollect.  Smalltalk garbageCollectmethodClass  self subclassResponsibilityname  ^'a subclass of ' , self superclass nameat: index put: value  < primitive: 61>  index isInteger ifTrue: [ self class isVariable ifTrue: [ (index between: 1 and: self size) ifFalse: [ ^self errorSubscriptBounds: index ] ] ifFalse: [ ^self errorNotIndexable ] ] ifFalse: [ ^index isNumber ifTrue: [ self at: index asInteger put: value ] ifFalse: [ self errorNonIntegerIndex ] ].  self isReadOnlyObject ifTrue: [ ^self modificationForbiddenFor: #at:put: index: index value: value ].  self errorImproperStoresin  < primitive: 556>  | sum delta self2 i |  self < 0.0 ifTrue: [ ^0.0 - (0.0 - self) sin ].  self > Twopi ifTrue: [ ^(self \\ Twopi) sin ].  self > Pi ifTrue: [ ^0.0 - (self - Pi) sin ].  self > Halfpi ifTrue: [ ^(Pi - self) sin ].  sum := delta := self.  self2 := 0.0 - (self * self).  i := 2.0.  [ delta > Epsilon ] whileTrue: [ delta := delta * self2 / (i * (i + 1.0)).        i := i + 2.0.        sum := sum + delta.        delta := delta * self2 / (i * (i + 1.0)).        i := i + 2.0.        sum := sum + delta ].  ^sumsubclass: t instanceVariableNames: ins  ^self subclass: t instanceVariableNames: ins classVariableNames: '' poolDictionaries: '' package: 'Unclassified'adaptToFraction: rcvr andSend: selector  ^rcvr asFloat perform: selector with: selftestNew  self should: [ True new ] raise: self defaultTestErrorisLiteral  ^denominator = 1 or: [ (10 raisedTo: scale) \\ denominator = 0 ]to: stop by: step  ^Interval from: self to: stop by: stepgenCallMappedInlinedPrimitive: primIndex  (primIndex < 0 or: [ primIndex > 255 ]) ifTrue: [ self outOfRangeError: 'primitive index' index: primIndex range: 1 to: 32767 ].  stream     nextPut: 236;     nextPut: primIndexsetSelector: aSymbol  selector := aSymbolgenStoreInstVarLong: instVarIndex  (instVarIndex >= 0 and: [ instVarIndex < 256 ]) ifTrue: [ stream           nextPut: 132;           nextPut: 160;           nextPut: instVarIndex.        ^self ].  ^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255setArguments: anArray  self deprecated: 'Use #arguments: instead.' transformWith: '`@receiver setArguments: `@arg' -> '`@receiver arguments: `@arg'.  self arguments: anArraytestReadTimeZoneOffsetRFC822WithOtherCharactersAfter  self assert: (DateAndTime readTimezoneOffsetFrom: '+0530 CommiterName' readStream) printString equals: '0:05:30:00'hash  ^start hash + duration hashisRGObject  ^false| aBoolean  ^aBooleanisDefinedInPackage: anRPackage  ^anRPackage includesDefinedSelector: self selector ofClass: self methodClass~= aNumber  < primitive: 48>  ^super ~= aNumbersignalAll: aSymbolOrNil  | queue |  self checkOwnerProcess.  queue := self queueFor: aSymbolOrNil.  self signalAllInQueue: self defaultQueue.  queue ~~ self defaultQueue ifTrue: [ self signalAllInQueue: queue ]respondsToUnknownBytecode  | unknownBytecode |  unknownBytecode := self method at: self pc.  self error: 'VM cannot run unknown bytecode ' , unknownBytecode printStringor: alternativeBlock  ^self~~ anObject  < primitive: 169>  self == anObject ifTrue: [ ^false ] ifFalse: [ ^true ]hash  ^seconds bitXor: nanostestValueWithinNonLocalReturnFixReal  | startTime |  self valueWithinNonLocalReturn.  startTime := Time millisecondClockValue.  [ [  ] repeat ] valueWithin: 100 milliSeconds onTimeout: [ | deltaTime |        deltaTime := Time millisecondClockValue - startTime.        self deny: deltaTime < 90 ]testOne  | benchmarkResult |  benchmarkResult := BenchmarkResult new.  benchmarkResult iterations: 1.  benchmarkResult elapsedTime: 1 second.  self deny: benchmarkResult isEmpty.  self assert: benchmarkResult iterations equals: 1.  self assert: benchmarkResult elapsedTime equals: 1 second.  self assert: benchmarkResult frequency equals: 1.  self assert: benchmarkResult executionsPerSecond equals: 1.  self assert: benchmarkResult period equals: 1 second.  self assert: benchmarkResult timePerExecution equals: 1 second.  self deny: benchmarkResult shortPrintString isEmpty.  self deny: benchmarkResult printString isEmptytestSimpleOuter  self assertSuccess: (ExceptionTester new runTest: #simpleOuterTest)instanceVariableNames: instVarString  ^self slots: instVarString asSlotCollectionisFloat  ^truetestMiddleOf  self assert: (aDateAndTime middleOf: aDuration) equals: (Timespan starting: (DateAndTime year: 2004 month: 2 day: 29 hour: 6 minute: 46 second: 30 offset: 2 hours) duration: (Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0))offset  ^self primOffset minutestestNew  | sw |  sw := Stopwatch new.  self     assert: sw isSuspended;     assert: sw state equals: #suspended;     deny: sw isActive;     assertEmpty: sw timespanshashMultiply  < primitive: 159>  ^(self bitAnd: 16rFFFFFFF) hashMultiplycalledArgumentsCount: anObject  calledArgumentsCount := anObjectterminateProcess  self isEmpty ifFalse: [ self removeFirst terminate ]removeKey: aKey ifAbsent: aBlock  1 to: self basicSize do: [:i |  | propertyOrPragma |        propertyOrPragma := self basicAt: i.        (propertyOrPragma isVariableBinding ifTrue: [ propertyOrPragma key ] ifFalse: [ propertyOrPragma selector ]) == aKey ifTrue: [ ^method removeProperty: aKey ] ].  ^aBlock valuetestCurrent  self deny: aDateAndTime equals: DateAndTime currentallSuperclassesDo: aBlock  self superclass == nil ifFalse: [ aBlock value: self superclass.        self superclass allSuperclassesDo: aBlock ]primitiveFailed: selector  PrimitiveFailed signalFor: selectorrearmOneShot  self class environment at: #OneShotArmed put: trueisArray  ^falseinitializeTicker: aDelayTicker suspendedDelaysHeap: aHeap  ticker := aDelayTicker.  suspendedDelays := aHeap.  timingSemaphore := Semaphore new.  debug := falseprintStringBase: base  ^String streamContents: [:strm |  self printOn: strm base: base ]check: aSelector forDeprecationIn: aGlobalName  ^(Smalltalk globals at: aGlobalName ifAbsent: [ ^false ]) class classAndMethodFor: aSelector do: [:class :method |  method isDeprecated ] ifAbsent: [ false ]testCull  [  ] cull: 1.  [:x |   ] cull: 1.  self should: [ [:x :y |   ] cull: 1 ] raise: Error.  self should: [ [:x :y :z |   ] cull: 1 ] raise: Error.  self should: [ [:x :y :z :a |   ] cull: 1 ] raise: Error.  self should: [ [:x :y :z :a :b |   ] cull: 1 ] raise: Error.  self assert: ([ 0 ] cull: 1) equals: 0.  self assert: ([:x |  x ] cull: 1) equals: 1ffiCall: fnSpec options: callOptions  < ffiCalloutTranslator>  self ffiCall: fnSpec library: self ffiLibrary libraryName options: callOptionssizeReturnSpecialLiteral: specialLiteral  ^self sizeOpcodeSelector: #genReturnSpecialLiteral: withArguments: {specialLiteral}canBeRenamed  ^trueobjectClass: aReceiver  < primitive: 111>  self primitiveFailedhhmm24  ^String new: 4 streamContents: [:aStream |  self hour printOn: aStream base: 10 length: 2 padded: true.        self minute printOn: aStream base: 10 length: 2 padded: true ]whichSelectorsReferTo: literal  ^(self whichMethodsReferTo: literal) collect: [:method |  method selector ]+ anInteger  < primitive: 21>  ^super + anIntegerinterpretJumpIfCond  ^self method encoderClass interpretJumpIfCondIn: selfdayOfWeekAbbreviation  ^self dayOfWeekName copyFrom: 1 to: 3tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments  < primitive: 218 error: errorCode>  errorCode ifNotNil: [ errorCode isInteger ifTrue: [ errorCode = -1 ifTrue: [ errorCode := nil ] ifFalse: [ self primitiveFailed ] ].        ^self class primitiveFailTokenFor: errorCode ].  ^self withoutPrimitiveTryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: argumentsisHandlerContext  ^self isHandlerOrSignalingContext and: [ self selector == #on:do: ]tags  | packageTag |  packageTag := self package classTagForClass: self.  packageTag ifNil: [ ^#() ].  packageTag isRoot ifTrue: [ ^#() ].  ^{packageTag name}slotNamed: aName ifFound: foundBlock ifNone: exceptionBlock  ^self classLayout resolveSlot: aName asSymbol ifFound: foundBlock ifNone: exceptionBlockselectorsInCategory: aName  | aColl |  aColl := Set withAll: (self organization listAtCategoryNamed: aName).  ^aColl asArray sortsourceCode  ^self outerCode sourceCodevar1: anObject  var1 := anObjecttestWaitMaxMilliseconds  | monitor |  monitor := Monitor new.  monitor critical: [ monitor waitMaxMilliseconds: 10 ]withWidth: width  ^origin corner: (origin x + width) @ corner yreceiver: obj  receiver := objdoOnlyOnce: aBlock  (self class environment at: #OneShotArmed ifAbsent: [ true ]) ifTrue: [ self class environment at: #OneShotArmed put: false.        aBlock value ]fuelNew: sizeRequested  ^self basicNew: sizeRequestedtestBecome  | pt1 pt2 pt3 |  pt1 := 0 @ 0.  pt2 := pt1.  pt3 := 100 @ 100.  pt1 become: pt3.  self assert: pt2 equals: 100 @ 100.  self assert: pt3 equals: 0 @ 0.  self assert: pt1 equals: 100 @ 100initialize  super initialize.  terminating := falsetestTommorrow  self assert: DateAndTime today + 24 hours equals: DateAndTime tomorrow.  self deny: aDateAndTime equals: DateAndTime tomorrowtimeStamp  ^SourceFiles timeStampAt: self sourcePointerasNanoSeconds  ^self asDuration asNanoSecondsthoroughWhichSelectorsReferTo: literal  ^(self thoroughWhichMethodsReferTo: literal) collect: [:method |  method selector ]testIsFormatOther  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isFormatOther: ch) equals: (charset isFormatOther: ch) ]allUnreferencedInstanceVariables  ^self allSlots reject: [:slot |  slot isReferenced ]actionsDo: aBlock  self actionMap do: aBlockhasLiteral: aLiteral  ^self selector == aLiteral or: [ arguments hasLiteral: aLiteral ]testReturn  aMethodContext := Context sender: thisContext receiver: aReceiver method: aCompiledMethod arguments: #().  self assert: (aMethodContext return: 5) equals: 5testReadsSlot  ({(Point >> #x) .   (Point >> #setX:setY:)} allSatisfy: #hasSourceCode) ifFalse: [ ^self ].  self assert: (Point >> #x readsSlot: (Point slotNamed: #x)).  self deny: (Point >> #x readsSlot: (Point slotNamed: #y)).  self deny: (Point >> #setX:setY: readsSlot: (Point slotNamed: #y))tearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  timespan := nil.  super tearDownor: alternativeBlock  self subclassResponsibilitytestInstanceCreation  | m1 m2 |  m1 := Month starting: '4 July 1998' asDate.  m2 := Month year: 1998 month: #July.  self     assert: month equals: m1;     assert: month equals: m2phlowValue: anObject  ^anObjectveryDeepCopyWith: deepCopier  isSuspended  ^self state = #suspendedisTaggedWith: aSymbol  ^self protocol == aSymbolclassCommentBlank  | stream |  stream := (String new: 100) writeStream.  stream nextPutAll: 'Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.'.  self instVarNames size > 0 ifTrue: [ stream           cr;           cr;           nextPutAll: '    Instance Variables' ].  self instVarNames asSortedCollection do: [:each |  stream           cr;           tab;           nextPutAll: each;           nextPut: $:;           tab;           tab;           nextPutAll: '<Object>' ].  stream cr.  stream     cr;     cr;     nextPutAll: '    Implementation Points'.  ^stream contentscontrol  ^KMModifier control + selfrfPlus: aNumber  < metaLinkOptions: #(+ optionDisabledLink)>  < primitive: 1>  ^super + aNumberbrowseHierarchy  self systemNavigation browseHierarchy: selfhasDynamicItems  ^self numArgs ~= 0sourcePointer  ^self trailer sourcePointergenSignedSingleExtendB: extendedIndex  (extendedIndex between: -128 and: 127) ifFalse: [ ^self outOfRangeError: 'index' index: extendedIndex range: -128 to: 127 ].  stream     nextPut: 225;     nextPut: (extendedIndex >= 0 ifTrue: [ extendedIndex ] ifFalse: [ extendedIndex + 256 ])testCurrent  self assert: (Timespan starting: DateAndTime current) <= Timespan current.  self assert: Timespan current <= (Timespan starting: DateAndTime current)testAccessesSlot  ({(Point >> #x) .   (Point >> #setX:setY:)} allSatisfy: #hasSourceCode) ifFalse: [ ^self ].  self assert: (Point >> #x accessesSlot: (Point slotNamed: #x)).  self deny: (Point >> #x accessesSlot: (Point slotNamed: #y)).  self assert: (Point >> #setX:setY: accessesSlot: (Point slotNamed: #y))waitWhile: aBlock for: aSymbolOrNil maxMilliseconds: anIntegerOrNil  self checkOwnerProcess.  self waitWhile: aBlock inQueue: (self queueFor: aSymbolOrNil) maxMilliseconds: anIntegerOrNilsquared  ^self * selfremoveActionsSatisfying: aOneArgBlock forEvent: anEventSelector  self setActionSequence: ((self actionSequenceForEvent: anEventSelector) reject: [:anAction |  aOneArgBlock value: anAction ]) forEvent: anEventSelectorstoreBinaryOn: aStream  self asInteger < 256 ifTrue: [ aStream basicNextPut: self asInteger ] ifFalse: [ aStream nextInt32Put: self asInteger ]popIntoLiteralVariable: value  value value: self popasIntegerPoint  self isIntegerPoint ifTrue: [ ^self ].  ^x asInteger @ y asIntegercurrentEvent  ^ActiveEvent ifNil: [ self currentHand lastEvent ]classToBeTested  ^ScheduleisFraction  ^truetestHandlingWithSeveralExclusions  | wasHandled |  wasHandled := false.  self should: [ [ ZeroDivide signalWithDividend: 1 ] on: Error - Warning - ZeroDivide do: [:exception |  wasHandled := true.              exception return ] ] raise: ZeroDivide.  self deny: wasHandled.  self should: [ [ ZeroDivide signalWithDividend: 1 ] on: Error - (Warning , ZeroDivide) do: [:exception |  wasHandled := true.              exception return ] ] raise: ZeroDivide.  self deny: wasHandledresult  ^resultvalue: anObject1 value: anObject2 value: anObject3  | strongReceiver |  strongReceiver := self receiver.  (self ensureReceiver: strongReceiver) ifFalse: [ ^nil ].  ^strongReceiver perform: selector with: anObject1 with: anObject2 with: anObject3testConvertFromNonDecimalFraction  | defaultNumberOfDecimals |  defaultNumberOfDecimals := (1 / 3) asScaledDecimal scale.  #(6 7 9 11 12 13 14 17 18 19 21 22 23 24) do: [:den |  | sd sd2 |        sd := (1 / den) asScaledDecimal.        self assert: sd scale equals: defaultNumberOfDecimals.        sd2 := ScaledDecimal readFrom: sd printString.        self deny: sd equals: sd2 ]testAsDuration  self assert: aDuration asDuration equals: aDuration< comparand  ^self start < comparandprintOn: stream base: base  self printOn: stream base: base length: 0 padded: falseselectSuperclasses: aBlock  | aSet |  aSet := Set new.  self allSuperclasses do: [:aSuperclass |  (aBlock value: aSuperclass) ifTrue: [ aSet add: aSuperclass ] ].  ^aSetkindOfSubclass  ^self isVariable ifTrue: [ self isBits ifTrue: [ self isBytes ifTrue: [ ' variableByteSubclass: ' ] ifFalse: [ ' variableWordSubclass: ' ] ] ifFalse: [ self isWeak ifTrue: [ ' weakSubclass: ' ] ifFalse: [ ' variableSubclass: ' ] ] ] ifFalse: [ self isImmediateClass ifTrue: [ ' immediateSubclass: ' ] ifFalse: [ self isEphemeronClass ifTrue: [ ' ephemeronSubclass: ' ] ifFalse: [ ' subclass: ' ] ] ]fuelReplacement  ^selfforPoint: aPoint closestSideDistLen: sideDistLenBlock  | side |  side := self sideNearestTo: aPoint.  side == #right ifTrue: [ ^sideDistLenBlock value: side value: (self right - aPoint x) abs value: ((aPoint y between: self top and: self bottom) ifTrue: [ self height ] ifFalse: [ 0 ]) ].  side == #left ifTrue: [ ^sideDistLenBlock value: side value: (self left - aPoint x) abs value: ((aPoint y between: self top and: self bottom) ifTrue: [ self height ] ifFalse: [ 0 ]) ].  side == #bottom ifTrue: [ ^sideDistLenBlock value: side value: (self bottom - aPoint y) abs value: ((aPoint x between: self left and: self right) ifTrue: [ self width ] ifFalse: [ 0 ]) ].  side == #top ifTrue: [ ^sideDistLenBlock value: side value: (self top - aPoint y) abs value: ((aPoint x between: self left and: self right) ifTrue: [ self width ] ifFalse: [ 0 ]) ]testDependencies  self assert: (ClassTest dependentClasses includes: ClassTest superclass).  self assert: (ClassTest dependentClasses includes: Date)testExample1  | producer1 producer2 monitor goal work counter goalReached finished |  goal := (1 to: 1000) asOrderedCollection.  work := OrderedCollection new.  counter := 0.  goalReached := false.  finished := Semaphore new.  monitor := Monitor new.  producer1 := [ [ monitor critical: [ monitor waitUntil: [ counter \\ 5 = 0 ].        goalReached or: [ work add: (counter := counter + 1) ].        goalReached := counter >= goal size.        monitor signal ].  goalReached ] whileFalse.  finished signal ].  producer2 := [ [ monitor critical: [ monitor waitWhile: [ counter \\ 5 = 0 ].        goalReached or: [ work add: (counter := counter + 1) ].        goalReached := counter >= goal size.        monitor signal ].  goalReached ] whileFalse.  finished signal ].  producer1 forkAt: Processor userBackgroundPriority.  producer2 forkAt: Processor userBackgroundPriority.  finished     wait;     wait.  self assert: goal equals: worktestReadFrom  self assert: 1.0e-14 equals: (Number readFrom: '1.0e-14').  self assert: 16r4000000 equals: (Number readFrom: '2r1e26').  self should: [ Number readFrom: 'foo' ] raise: ErrorwhichSelectorsStoreInto: instVarName  ^self slotNamed: instVarName ifFound: [:slot |  self selectors select: [:sel |  slot isWrittenIn: self >> sel ] ] ifNone: [ #() ]testclassVariables  self assert: Object classVariables first name equals: #DependentsFields.  self assert: Object classVariables equals: Object class classVariablesproperties  ^self subclassResponsibilityrounded  allProtocolsNames  ^self allProtocols collect: #namebasicInspect  ^Smalltalk tools basicInspector inspect: selfsubclassesDo: aBlock  self subclasses do: aBlockmyDependents  ^DependentsFields at: self ifAbsent: [  ]testStartDay  Week startDay: 'Wednesday'.  self assert: Week startDay equals: 'Wednesday'.  Week startDay: 'Thursday'.  self assert: Week startDay equals: 'Thursday'+ aNumber  | n d d1 d2 |  aNumber isInteger ifTrue: [ ^Fraction numerator: numerator + (denominator * aNumber) denominator: denominator ].  aNumber isFraction ifTrue: [ d := denominator gcd: aNumber denominator.        n := numerator * (d1 := aNumber denominator // d) + (aNumber numerator * (d2 := denominator // d)).        d1 := d1 * d2.        n := n // (d2 := n gcd: d).        (d := d1 * (d // d2)) = 1 ifTrue: [ ^n ].        ^Fraction numerator: n denominator: d ].  ^aNumber adaptToFraction: self andSend: #+testAsDateAndTime  self assert: aDateAndTime asDateAndTime equals: aDateAndTimetestOneMBAllocation  | sz array failed |  failed := false.  sz := 1024 * 1024.  array := [ ByteArray new: sz ] on: OutOfMemory do: [:ex |  failed := true ].  self assert: (failed or: [ array size = sz ])testFractionAsFloat2  self assert: ((1 << 52) + 0 + (1 / 4)) asFloat asTrueFraction equals: (1 << 52) + 0.  self assert: ((1 << 52) + 0 + (1 / 2)) asFloat asTrueFraction equals: (1 << 52) + 0.  self assert: ((1 << 52) + 0 + (3 / 4)) asFloat asTrueFraction equals: (1 << 52) + 1.  self assert: ((1 << 52) + 1 + (1 / 4)) asFloat asTrueFraction equals: (1 << 52) + 1.  self assert: ((1 << 52) + 1 + (1 / 2)) asFloat asTrueFraction equals: (1 << 52) + 2.  self assert: ((1 << 52) + 1 + (3 / 4)) asFloat asTrueFraction equals: (1 << 52) + 2testYearDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1901 day: 1 hour: 0 minute: 0 second: 0)exception  ^exception* aNumber  self subclassResponsibility= aCompiledMethod  self == aCompiledMethod ifTrue: [ ^true ].  self class = aCompiledMethod class ifFalse: [ ^false ].  self size = aCompiledMethod size ifFalse: [ ^false ].  self header = aCompiledMethod header ifFalse: [ ^false ].  self initialPC to: self endPC do: [:i |  (self at: i) = (aCompiledMethod at: i) ifFalse: [ ^false ] ].  (self sameLiteralsAs: aCompiledMethod) ifFalse: [ ^false ].  ^truetestTempNamed  | oneTemp context |  oneTemp := 1.  self assert: (thisContext tempNamed: 'oneTemp') equals: oneTemp.  context := self class contextWithTempForTesting.  self assert: (context tempNamed: 'string') equals: 'test'outerContext  ^outerContextsameAs: aCharacter  ^self asLowercase = aCharacter asLowercasetestNonResumablePass  self should: [ [ Error signal.        4 ] on: Error do: [:ex |  ex pass.              ex return: 5 ] ] raise: ErrorstepToHome: aContext  | ctxt pair error |  ctxt := suspendedContext.  suspendedContext := nil.  pair := Processor activeProcess evaluate: [ ctxt stepToHome: aContext ] onBehalfOf: self.  suspendedContext := pair first.  error := pair second.  error ifNotNil: [ ^suspendedContext := error signalerContext ].  ^suspendedContextisEmpty  ^self methodSelectors isEmptytestAsTime  self assert: aDateAndTime asTime equals: Time midnightisClassSide  ^self == self classSideabstractBytecodeMessagesDo: aBlock  self abstractBytecodeMessagesFrom: self initialPC to: self endPC do: aBlockstate  ^state ifNil: [ state := #suspended ]isVirtualProtocol  ^falsesign  ^x sign @ y signpackageOrganizer  ^RPackage organizerisBytes  ^self instSpec >= 16subclassResponsibility  SubclassResponsibility signalFor: thisContext sender selectorasEmailTimeOffsetString  ^String streamContents: [:str |  str           nextPut: (self positive ifTrue: [ $+ ] ifFalse: [ $- ]);           nextPutAll: self hours abs asTwoCharacterString;           nextPutAll: self minutes asTwoCharacterString ]instanceVariableReadNodes  ^self ast instanceVariableReadNodesnew  ^self basicNew initializetestSubtractDays  self assert: (january23rd2004 subtractDays: 0) equals: '2004-01-23' asDate.  self assert: (january23rd2004 subtractDays: 30) equals: '2003-12-24' asDatetestComparing  | t1 t2 t3 |  t1 := self timeClass fromSeconds: 14567.  t2 := self timeClass fromSeconds: 5000.  t3 := self timeClass fromSeconds: 80000.  self     assert: time equals: t1;     assert: time hash equals: t1 hash;     assert: time equals: time copy.  self     deny: t1 < t2;     assert: t1 < t3serialiseOn: aStream  aStream nextPut: self.  1 to: self class instSize do: [:index |  aStream nextPut: (self instVarAt: index) ].  1 to: self localSize do: [:index |  aStream nextPut: (self localAt: index) ]testBitString  Smalltalk vm wordSize = 4 ifTrue: [ self assert: 2 bitString equals: '0000000000000000000000000000010'.        self assert: -1 bitString equals: '1111111111111111111111111111111'.        self assert: -2 bitString equals: '1111111111111111111111111111110'.        self assert: 2 bitStringLength equals: 31 ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: 2 bitString equals: '0000000000000000000000000000000000000000000000000000000000010'.        self assert: -1 bitString equals: '1111111111111111111111111111111111111111111111111111111111111'.        self assert: -2 bitString equals: '1111111111111111111111111111111111111111111111111111111111110'.        self assert: 2 bitStringLength equals: 61 ].  self assert: 2 bitStringLength equals: SmallInteger maxVal highBit + 1useTimeZone: abbreviation during: aBlock  | timeZone |  timeZone := TimeZone abbreviated: abbreviation.  self restoreLocalTimeZoneAfter: [ DateAndTime localTimeZone: timeZone.        aBlock cull: timeZone ]testFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1980-01-01T00:00:00+00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1980-01-01T00:00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1980-01-01T00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1980-01-01T00:00:00+00:00')subclass: subclassName uses: aTraitComposition layout: aLayout slots: someSlots classVariablesNames: someClassVariablesNames poolDictionaries: somePoolDictionaries package: aCategory  ^self classInstaller make: [:builder |  builder           name: subclassName;           superclass: self;           slots: someSlots;           layoutClass: aLayout;           sharedVariablesFromString: someClassVariablesNames;           sharedPools: somePoolDictionaries;           traitComposition: aTraitComposition asTraitComposition;           classTraitComposition: aTraitComposition asTraitComposition classComposition;           category: aCategory ]hour12  ^(self hour24 - 1) \\ 12 + 1left  ^leftshallowCopy  < primitive: 148>  | class newObject index |  class := self class.  class isVariable ifTrue: [ index := self basicSize.        newObject := class basicNew: index.        [ index > 0 ] whileTrue: [ newObject basicAt: index put: (self basicAt: index).              index := index - 1 ] ] ifFalse: [ newObject := class basicNew ].  index := class instSize.  [ index > 0 ] whileTrue: [ newObject instVarAt: index put: (self instVarAt: index).        index := index - 1 ].  ^newObjectadaptToInteger: rcvr andSend: selector  ^self adaptToNumber: rcvr andSend: selectordefinitionForSpotter  | str |  str := WriteStream on: String new.  str nextPutAll: self definition.  str     cr;     cr.  str nextPut: $".  str nextPutAll: 'Hierarchy: '.  str nextPutAll: ($> join: self allSuperclasses reversed).  str     cr;     cr.  self hasComment ifTrue: [ str nextPutAll: self comment ].  str nextPut: $".  ^str contentsnot  self subclassResponsibilityprintString  ^self printStringBase: 10unscheduleAtTimingPriority  delayToStop beingWaitedOn ifFalse: [ ^self ].  activeDelay == delayToStop ifTrue: [ activeDelay := suspendedDelays removeFirstOrNil ] ifFalse: [ suspendedDelays remove: delayToStop ifAbsent: [  ] ].  delayToStop timingPriorityUnschedule.  delayToStop := nilmillisecondsUntilTick: microsecondsTick  ^(microsecondsTick - self nowTick max: 0) / 1000seconds: secondCount nanoSeconds: nanoCount  seconds := secondCount.  nanos := nanoCount rounded.  [ nanos < 0 and: [ seconds > 0 ] ] whileTrue: [ seconds := seconds - 1.        nanos := nanos + NanosInSecond ].  [ seconds < 0 and: [ nanos > 0 ] ] whileTrue: [ seconds := seconds + 1.        nanos := nanos - NanosInSecond ]year  ^self yearsnegative  ^self positive notx92kbits  ^(11 to: 51 by: 4) inject: 1357924680 into: [:big :bits |  (big * big << bits) + bits ]testOneGWordAllocation  | sz array failed |  self timeLimit: 1 minute.  failed := false.  sz := 1024 * 1024 * 1024.  array := [ Array new: sz ] on: OutOfMemory do: [:ex |  failed := true ].  self assert: (failed or: [ array size = sz ])shortDebugStackOn: aStream  ^self debugStack: 30 on: aStreamtestReadFromSecond  self assert: '-1199-01-05T20:33:14.321-05:00' asDateAndTime printString equals: '-1199-01-05T20:33:14.321-05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: ' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: ' 2002-05-16T17:20' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:00+00:00'.  self assert: '2002-05-16T17:20:45' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:45+00:00'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime printString equals: '2002-05-16T17:20:45-02:34'.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime printString equals: '2002-05-16T17:20:45+00:00'.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime printString equals: '1997-04-26T01:02:03+01:02:3'subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition package: aCategorySymbol  ^self subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition poolDictionaries: '' package: aCategorySymboloctantOf: otherPoint  | quad moreHoriz |  (x = otherPoint x and: [ y > otherPoint y ]) ifTrue: [ ^6 ].  (y = otherPoint y and: [ x < otherPoint x ]) ifTrue: [ ^8 ].  quad := self quadrantOf: otherPoint.  moreHoriz := (x - otherPoint x) abs >= (y - otherPoint y) abs.  ^(quad even eqv: moreHoriz) ifTrue: [ quad * 2 ] ifFalse: [ quad * 2 - 1 ]referencedClasses  ^self literals select: [:l |  l value isClass ] thenCollect: [:v |  v value ]selector  ^selectortestObjects  self assert: 10 isSelfEvaluating.  self assert: $a isSelfEvaluating.  self assert: 3.14157 isSelfEvaluating.  self assert: #(1 2 3) isSelfEvaluating.  self assert: #abc isSelfEvaluating.  self assert: 'abc' isSelfEvaluating.  self assert: Object isSelfEvaluating.  self assert: Object new isSelfEvaluating not.  self assert: {Float infinity .         Float nan .         Float infinity negated} isSelfEvaluating.  self assert: (Array with: 10) isSelfEvaluating.  self assert: (Array with: Object new) isSelfEvaluating not.  self assert: true isSelfEvaluating.  self assert: false isSelfEvaluating.  self assert: nil isSelfEvaluating.  self assert: (1 to: 10) isSelfEvaluating.  self assert: (1 -> 2) isSelfEvaluating.  self assert: Color red isSelfEvaluatingselectorsAndMethodsDo: selectorAndMethodBlock  ^self methodDict keysAndValuesDo: selectorAndMethodBlocktestDayOfYear  self assert: aDateAndTime dayOfYear equals: 1testDoWithWhen  | count |  count := 0.  aTimespan do: [:each |  count := count + 1 ] with: (Timespan starting: jan01 duration: aDay) when: [:each |  count < 5 ].  self assert: count equals: 5doesMethod: aSelector writeAllInstanceVariablesOfClass: aClass  | lastFieldIndex method hasNoInstanceVariables |  hasNoInstanceVariables := aClass instSize = 0.  lastFieldIndex := aClass instSize.  method := aClass compiledMethodAt: aSelector.  ^hasNoInstanceVariables or: [ method writesField: lastFieldIndex ]postCopy  super postCopy.  self classLayout: (layout copy host: self).  thisClass := nilfuelAccept: aGeneralMapper  ^aGeneralMapper visitPoint: selfbench  | sampleSetSeeds trialOfNumberConcurrent completed |  sampleSetSeeds := #(42).  trialOfNumberConcurrent := #(1000 2000 3000 4000 5000 6000 7000 8000 9000 10000).  completed := Semaphore new.  self crTrace: String cr , 'Benchmarking ' , Delay delaySchedulerClass printString.  [ trialOfNumberConcurrent do: [:numberConcurrent |  self crTrace: '#ConcurrentDelays: ' , numberConcurrent printString , String space.        EnterCount := ExitCount := 0.        sampleSetSeeds do: [:seed |  self trace: '.'.              self trialConcurrent: numberConcurrent priority: Processor userSchedulingPriority + 1 maxDuration: 50 fromSeed: seed ].        self trace: String space.        self trace: 'EnterCount: ' , (EnterCount // sampleSetSeeds size) printString , String space.        self trace: 'ExitCount: ' , (ExitCount // sampleSetSeeds size) printString.        self currentWorld doOneCycle ].  completed signal ] forkAt: Processor userSchedulingPriority + 2.  completed waititerationsBeforeTimeout  ^iterationsBeforeTimeoutcopyCategory: cat from: class  self copyCategory: cat from: class classified: catsetUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  DateAndTime localTimeZone: TimeZone default.  timespan := Timespan starting: (DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0) duration: (Duration hours: 100).  dec31 := DateAndTime year: 2004 month: 12 day: 31 hour: 0 minute: 0 second: 0.  jan01 := DateAndTime year: 2005 month: 1 day: 1 hour: 0 minute: 0 second: 0.  jan08 := DateAndTime year: 2005 month: 1 day: 8 hour: 0 minute: 0 second: 0.  aDay := Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.  aWeek := Duration days: 7 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.  aTimespan := Timespan starting: jan01 duration: aWeek.  anOverlappingTimespan := Timespan starting: dec31 duration: aWeek.  anIncludedTimespan := Timespan starting: jan01 duration: aDay.  aDisjointTimespan := Timespan starting: jan08 duration: aWeekto: end sideOf: otherPoint  ^end - self sideOf: otherPoint - selftestYearDay  self assert: aDateAndTime equals: (DateAndTime year: 1901 day: 1)superclass: aClass methodDictionary: mDict format: fmt  super superclass: aClass methodDictionary: mDict format: fmt.  self subclasses: nilpropertyValueAt: aKey ifAbsent: aBlock  ^self propertyAt: aKey ifAbsent: aBlockdenominator  ^denominatorsunitAnnounce: aTestCase toResult: aTestResult  aTestResult addError: aTestCasebrickValue: aBrick  ^self cull: aBrickremove: anObj oneStar: aTree  | newTree sentinel |  sentinel := #absent.  newTree := self callcc: [:oh |  self remove: anObj oneStar: aTree sentinel: sentinel continuation: oh ].  ^newTree = sentinel ifTrue: [ aTree ] ifFalse: [ newTree ]topLeft  ^originsubclass: aSubclassSymbol instanceVariableNames: instVarNameList classVariableNames: classVarNames package: aPackageSymbol  ^self subclass: aSubclassSymbol instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: aPackageSymboluserSchedulingPriority  ^UserSchedulingPriorityx13kbits  ^(15 to: 44 by: 4) inject: 9753102468 into: [:big :bits |  (big * big << bits) + bits ]intersection: aTimespan  | aBegin anEnd |  aBegin := self start max: aTimespan start.  anEnd := self start + self duration min: aTimespan start + aTimespan duration.  anEnd <= aBegin ifTrue: [ ^nil ].  ^self species starting: aBegin ending: anEnd< comparand  | other |  other := comparand asDateAndTime.  ^julianDayNumber = other julianDayNumberUTC ifTrue: [ seconds = other secondsSinceMidnightUTC ifTrue: [ nanos < other nanoSecond ] ifFalse: [ seconds < other secondsSinceMidnightUTC ] ] ifFalse: [ julianDayNumber < other julianDayNumberUTC ]adjustTo: newRect along: side  side = #left ifTrue: [ ^self withRight: newRect left ].  side = #right ifTrue: [ ^self withLeft: newRect right ].  side = #top ifTrue: [ ^self withBottom: newRect top ].  side = #bottom ifTrue: [ ^self withTop: newRect bottom ]log: aNumber  ^self ln / aNumber lnbinaryLiteralString  ^String streamContents: [:stream |  self printBinaryLiteralOn: stream ]containsRect: aRect  ^aRect origin >= origin and: [ aRect corner <= corner ]forkNamed: aString  ^self newProcess     name: aString;     resumestonOn: stonWriter  stonWriter writeInteger: selffirstByte  ^self method at: pclocalSelectors  ^methodDict keyspointerDouble  ^(ByteArray new: FFIFloat64 externalTypeSize)     doubleAt: 1 put: self;     yourselftimingPriority  ^TimingPriorityclosureCopy: numArgs copiedValues: anArray  < primitive: 200>  ^BlockClosure outerContext: self startpc: pc + 2 numArgs: numArgs copiedValues: anArraytestNormalizeNanoSeconds  | d t1 t2 |  t1 := '2004-01-07T11:55:01+00:00' asDateAndTime.  t2 := '2004-01-07T11:55:00.9+00:00' asDateAndTime.  d := t1 - t2.  self assert: d nanoSeconds > 0.  self assert: d seconds equals: 0.  self assert: d nanoSeconds equals: 100000000.  self assert: d asString equals: '0:00:00:00.1'.  self assert: (Duration seconds: 1 nanoSeconds: 100000000) printString equals: '0:00:00:01.1'.  self assert: (Duration seconds: -1 nanoSeconds: -100000000) printString equals: '-0:00:00:01.1'.  self assert: (Duration seconds: 1 nanoSeconds: -100000000) printString equals: '0:00:00:00.9'.  self assert: (Duration seconds: -1 nanoSeconds: 100000000) printString equals: '-0:00:00:00.9'gtInspectorIrIn: composite  < gtInspectorPresentationOrder: 35>  composite text     title: 'Ir';     display: [:anObject |  | string |        string := anObject ir longPrintString.        string copyFrom: 2 to: string size ]bitInvert  ^-1 - selfname: aString  self error: 'You cannot change my name'willSend  ^self method encoderClass isSendAt: pc in: self methodisResumable  ^truegtDebuggerPresentationsIn: composite inContext: aGTInspector  | pragmas |  pragmas := (Pragma allNamed: #gtDebuggerPresentationOrder: from: self class to: ProtoObject) asOrderedCollection.  pragmas addAll: ((Pragma allNamed: aGTInspector class extensionsPragma from: self class to: ProtoObject) reject: [:pragma |  pragma method selector = #gtInspectorRawIn: ]).  pragmas := pragmas sorted: [:x :y |  (x argumentAt: 1) < (y argumentAt: 1) ].  self gtInspectorPresentationsFromPragmas: pragmas In: composite inContext: aGTInspectorgenSendDirectedSuper: selectorLiteralIndex numArgs: nArgs  | extendedIndex |  (selectorLiteralIndex < 0 or: [ selectorLiteralIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535 ].  (nArgs < 0 or: [ nArgs > 31 ]) ifTrue: [ ^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 ].  (extendedIndex := selectorLiteralIndex) > 31 ifTrue: [ self genUnsignedSingleExtendA: extendedIndex // 32.        extendedIndex := extendedIndex \\ 32 ].  self genUnsignedSingleExtendB: nArgs // 8 + 64.  stream     nextPut: 235;     nextPut: nArgs \\ 8 + (extendedIndex * 8)reflectedAbout: aPoint  ^(self - aPoint) negated + aPointarcCos  ^self asFloat arcCosreceiver  ^outerContext receiverinstanceVariableReadNodes  ^self methods flatCollect: [:each |  each instanceVariableReadNodes ]testIsLowercase  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isLowercase: ch) equals: (charset isLowercase: ch) ]<= aNumber  < primitive: 45>  ^aNumber adaptToFloat: self andCompare: #<=testPrintOn  self assert: (String streamContents: [:stream |  true printOn: stream ]) equals: 'true'testSeconds  self assert: aDateAndTime seconds equals: 0signalFromHandlerActionTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: 'Unhandled Exception';     yourselfgenReturnTopToCaller  stream nextPut: 94testIsFinalQuote  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isFinalQuote: ch) equals: (charset isFinalQuote: ch) ]fuelAccept: aGeneralMapper  ^aGeneralMapper visitHookPrimitive: selfmethodsInProtocolNamed: aName  aName = AllProtocol defaultName ifTrue: [ ^self allMethodSelectors ].  ^(self protocolNamed: aName) methodSelectorshex  ^String streamContents: [:strm |  | word nibble |        1 to: 2 do: [:i |  word := self at: i.              1 to: 8 do: [:s |  nibble := (word bitShift: (-8 + s) * 4) bitAnd: 16rF.                    strm nextPut: ('0123456789ABCDEF' at: nibble + 1) ] ] ]basicCheck: anEntity  self check: anEntity forCritiquesDo: [ ^true ] ifNone: [ ^false ]perform: selector withEnoughArguments: anArray  | numArgs args |  numArgs := selector numArgs.  anArray size == numArgs ifTrue: [ ^self perform: selector withArguments: anArray asArray ].  args := Array new: numArgs.  args replaceFrom: 1 to: (anArray size min: args size) with: anArray startingAt: 1.  ^self perform: selector withArguments: argstestIsOnOrAfter  | tzm8 tzp10 |  tzm8 := january23rd2004 translateTo: -8 hours.  tzp10 := january23rd2004 translateTo: 10 hours.  self     assert: (tzp10 isOnOrAfter: tzm8);     assert: (june2nd1973 isOnOrAfter: january23rd2004) not;     assert: (june2nd1973 isOnOrAfter: june2nd1973);     assert: (january23rd2004 isOnOrAfter: june2nd1973)strictlyPositive  ^truetestTimeZone  self assert: aDateAndTime timeZoneName equals: 'Universal Time'.  self assert: aDateAndTime timeZoneAbbreviation equals: 'UTC'testIsTitlecaseLetter  self checkCorrespondanceOf: #isTitlecaseLetter: and: #Ltcompile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource  | method selector |  method := self compiler     source: text;     requestor: requestor;     failBlock: [ ^nil ];     compile.  selector := method selector.  logSource ifTrue: [ self logMethodSource: (requestor ifNotNil: [:r |  r text ] ifNil: [ text ]) forMethod: method inCategory: category withStamp: changeStamp ].  self addAndClassifySelector: selector withMethod: method inProtocol: category.  self instanceSide noteCompilationOfMethod: method meta: self isClassSide.  ^selectorinstanceSide  ^self subclassResponsibilitytestObject: object initialState: initialState tuples: tuples setReadOnlyBlock: setImmutabilityBlock  self assert: object isReadOnlyObject equals: initialState.  tuples do: [:tuple |  | stateToSet expectedResult expectedNewState |        stateToSet := tuple first.        expectedResult := tuple second.        expectedNewState := tuple last.        [ self assert: (setImmutabilityBlock value: stateToSet) equals: expectedResult ] on: PrimitiveFailed do: [ self assert: (self alwaysReadOnlyObjects , self alwaysWritableObjects includes: object) ].        self assert: object isReadOnlyObject equals: expectedNewState ]displayString  ^self displayStringLimitedTo: 50000period  ^elapsedTime / iterationsadaptToInteger: rcvr andSend: selector  ^(rcvr asScaledDecimal: scale) perform: selector with: selfwhichSuperclassSatisfies: aBlock  (aBlock value: self) ifTrue: [ ^self ].  ^self superclass ifNotNil: [ self superclass whichSuperclassSatisfies: aBlock ]printMethodChunk: selector on: outStream  | preamble method |  preamble := self name , ' methodsFor: ' , (self organization categoryOfElement: selector) asString printString.  method := self methodDict at: selector ifAbsent: [ outStream           nextPutAll: selector;           cr.        outStream           tab;           nextPutAll: '** ERROR!  THIS SCRIPT IS MISSING ** ';           cr;           cr.        outStream nextPutAll: '  '.        ^outStream ].  outStream     cr;     nextChunkPut: ''.  outStream nextChunkPut: (String streamContents: [:strm |  strm nextPutAll: preamble.              method stamp ifNotEmpty: [:stamp |  strm                       nextPutAll: ' stamp: ';                       print: stamp ] ]).  outStream cr.  outStream     nextChunkPut: method sourceCode;     nextChunkPut: ' ';     cr.  ^outStreamadditionalInspectorClasses  ^{}tempAt: index  < primitive: 210>  ^self at: indexwidth  ^corner x - origin xvariableSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat  ^self variableSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat= comparand  ^self == comparand ifTrue: [ true ] ifFalse: [ self species = comparand species ifTrue: [ self asNanoSeconds = comparand asNanoSeconds ] ifFalse: [ false ] ]signalReallyAll  self checkOwnerProcess.  self signalAll.  self queueDict valuesDo: [:queue |  self signalAllInQueue: queue ]var10: anObject  var10 := anObjectevaluateSignal: exception  < primitive: 199>  < debuggerCompleteToSender>  | value |  exception privHandlerContext: self contextTag.  value := self exceptionHandlerBlock cull: exception.  self return: valuetestSecond  self assert: aDateAndTime second equals: 0firstThursday  ^self start + (5 - self start dayOfWeek + 7 rem: 7) daysprintOn: aStream  super printOn: aStream.  aStream     space;     nextPut: $(;     print: self identityHash;     nextPut: $)nonIndexedMessageText  ^String streamContents: [:s |  s << ' '.        self printObject: object on: s.        s << ' is read-only, hence its selector '.        s << retrySelector.        s << ' cannot be executed with '.        self printObject: newValue on: s ]unschedule: aDelay  testValueWithReceiverArguments  | method value |  method := self class compiledMethodAt: #returnTrue.  value := method valueWithReceiver: nil arguments: #().  self assert: value equals: true.  method := self class compiledMethodAt: #returnPlusOne:.  value := method valueWithReceiver: nil arguments: #(1).  self assert: value equals: 2errorCategoryName  self error: 'Category name must be a String'hasTraitComposition  ^falsegtInspectorAllReferencesOutsideIn: composite  < gtInspectorPresentationOrder: 20>  composite list     title: 'All Ref Outside';     display: [ ((SystemNavigation default allReferencesTo: self binding) reject: [:method |  method package name == self package name ]) sorted: [:x :y |  x name < y name ] ];     format: #name;     tags: [:each |  {each package name} ]xor: alternativeBlock  ^alternativeBlock valuedoubleOuterTest  [ [ [ self doSomething.  MyTestNotification signal.  self doSomethingExceptional ] on: MyTestNotification do: [:ex |  ex outer.        self doSomethingExceptional ] ] on: MyTestNotification do: [:ex |  ex outer.        self doSomethingElse ] ] on: MyTestNotification do: [:ex |  self doYetAnotherThing.        ex resume ]perform: aSymbol with: firstObject with: secondObject with: thirdObject with: fourthObject  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: aSymbol withArguments: (Array with: firstObject with: secondObject with: thirdObject with: fourthObject)testReActivate  | sw |  sw := Stopwatch new.  sw     activate;     suspend;     reActivate.  self assert: sw isActivetestTruncateTo  self assert: (5 minutes + 37 seconds truncateTo: 2 minutes) equals: 4 minutes.  self assert: (aDuration truncateTo: (Duration days: 1)) equals: (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: (aDuration truncateTo: (Duration hours: 1)) equals: (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: (aDuration truncateTo: (Duration minutes: 1)) equals: (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0)nthRootTruncated: aPositiveInteger  | guess guessToTheNthMinusOne delta |  self = 0 ifTrue: [ ^0 ].  self negative ifTrue: [ aPositiveInteger even ifTrue: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ].        ^(self negated nthRootTruncated: aPositiveInteger) negated ].  guess := 1 bitShift: (self highBitOfMagnitude + aPositiveInteger - 1) // aPositiveInteger.  [ guessToTheNthMinusOne := guess raisedTo: aPositiveInteger - 1.  delta := (guess * guessToTheNthMinusOne - self) // (guessToTheNthMinusOne * aPositiveInteger).  delta = 0 ] whileFalse: [ guess := guess - delta ].  ((guess := guess - 1) raisedTo: aPositiveInteger) > self ifTrue: [ guess := guess - 1 ].  ^guesspenultimateLiteral  | pIndex |  ^(pIndex := self numLiterals - 1) > 0 ifTrue: [ self literalAt: pIndex ] ifFalse: [ nil ]testAddSlot  | tutu |  tutu := testEnvironment at: #TUTU.  tutu addSlot: #x => InstanceVariableSlot.  self assert: tutu instVarNames equals: #('x').  self assert: tutu name equals: #TUTU.  tutu addSlot: #y => InstanceVariableSlot.  self assert: tutu instVarNames equals: #('x' 'y')link: aMetaLink toClassVariableNamed: aClassVariableName  self link: aMetaLink toClassVariableNamed: aClassVariableName option: #allsharedPoolsDo: aBlockClosure  self hasSharedPools ifFalse: [ ^self ].  self sharedPools do: aBlockClosurenthRoot: aPositiveInteger  self subclassResponsibilitytestSharedPoolOfVarNamed  self assert: (Date sharedPoolOfVarNamed: 'DayNames') equals: ChronologyConstants.  self assert: (Date class sharedPoolOfVarNamed: 'DayNames') isNil.  self assert: (RootClassPoolUser sharedPoolOfVarNamed: 'Author') equals: PoolDefiner.  self assert: (RootClassPoolUser sharedPoolOfVarNamed: 'Gloups') equals: PoolDefiner.  self assert: (SubclassPoolUser sharedPoolOfVarNamed: 'Author') equals: PoolDefiner.  self assert: (ClassMultiplePoolUser sharedPoolOfVarNamed: 'Author') equals: PoolDefiner.  self assert: (ClassMultiplePoolUser sharedPoolOfVarNamed: 'VariableInPoolDefiner2') equals: PoolDefiner2.  self assert: (ClassMultiplePoolUser sharedPoolOfVarNamed: 'Gloups') equals: PoolDefinercontext: aContext  context := aContextmethodWithError  MyTestError signal: self testStringspotterForBytecodesFor: aStep  < spotterOrder: 15>  aStep listProcessor     title: 'Bytecode';     allCandidates: [ self symbolicBytecodes ];     itemName: #printString;     filter: GTFilterSubstringdoSomethingElseString  ^'Do something else.'genReturnReceiver  stream nextPut: 88asMonth  ^start asMonthgenPushLiteralVar: literalIndex  | extendedIndex |  (literalIndex < 0 or: [ literalIndex > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 32768 ].  literalIndex < 16 ifTrue: [ stream nextPut: 16 + literalIndex.        ^self ].  (extendedIndex := literalIndex) > 255 ifTrue: [ self genUnsignedSingleExtendA: extendedIndex // 256.        extendedIndex := extendedIndex \\ 256 ].  stream     nextPut: 227;     nextPut: extendedIndexcopyCategory: cat from: aClass classified: newCat  self copyAll: (aClass organization listAtCategoryNamed: cat) from: aClass classified: newCatglmCritiqueSourceIn: composite  ^composite pharoScript     title: 'Source';     display: [ self definition ];     act: [ self browse ] icon: GLMUIThemeExtraIcons glamorousBrowse entitled: 'Browse'mightBeASquare  | lsb |  lsb := self byteAt: 1.  ^(lsb = 0 and: [ self lowBit odd ]) or: [ lsb = 16r40 or: [ (lsb bitAnd: 16r7) = 1 or: [ (lsb bitAnd: 16r1F) = 4 or: [ (lsb bitAnd: 16r7F) = 16 ] ] ] ]maybeReadOnlyObjects  ^{{1 .   2 .   3} asByteArray .   {1 .   2 .   3} .   (MessageSend receiver: 1 selector: #+ argument: 2)}truncated  < primitive: 551>  (self isInfinite or: [ self isNaN ]) ifTrue: [ self error: 'Cannot truncate this number' ].  self abs < 2.0e16 ifTrue: [ | di df q r |        di := (SmallInteger maxVal bitShift: -1) + 1.        df := di asFloat.        q := self quo: df.        r := self - (q asFloat * df).        ^q * di + r truncated ] ifFalse: [ ^self asTrueFraction ]testThreadSafe  self should: [ self threadSafe ] notTakeMoreThanMilliseconds: 10.  self assert: fork isNiltestInquiries  self     assert: month index equals: 7;     assert: month name equals: #July;     assert: month duration equals: 31 daystestZeroRaisedToNegativePower  self should: [ 0.0 raisedTo: -1 ] raise: ZeroDivide.  self should: [ 0.0 raisedTo: -1.0 ] raise: ZeroDividequickMergePoint: aPoint  | useRcvr minX maxX minY maxY |  useRcvr := true.  minX := aPoint x < origin x ifTrue: [ useRcvr := false.        aPoint x ] ifFalse: [ origin x ].  maxX := aPoint x >= corner x ifTrue: [ useRcvr := false.        aPoint x + 1 ] ifFalse: [ corner x ].  minY := aPoint y < origin y ifTrue: [ useRcvr := false.        aPoint y ] ifFalse: [ origin y ].  maxY := aPoint y >= corner y ifTrue: [ useRcvr := false.        aPoint y + 1 ] ifFalse: [ corner y ].  ^useRcvr ifTrue: [ self ] ifFalse: [ minX @ minY corner: maxX @ maxY ]spotterForBytecodesFor: aStep  < spotterOrder: 15>  self method spotterForBytecodesFor: aStepbasicAt: index  < primitive: 210>  index isInteger ifTrue: [ self errorSubscriptBounds: index ].  index isNumber ifTrue: [ ^self at: index asInteger ] ifFalse: [ self errorNonIntegerIndex ]asContextWithSender: aContext  ^(Context newForMethod: self compiledBlock)     setSender: aContext receiver: self receiver method: self compiledBlock closure: self startpc: self startpc;     privRefreshclassVariableDefinitionString  ^String streamContents: [:str |  | fullDef |        str nextPutAll: '{ '.        self classVariables do: [:global |  str nextPutAll: global definitionString.              fullDef := global needsFullDefinition ] separatedBy: [ str nextPutAll: '. '.              fullDef ifTrue: [ str                       cr;                       tab;                       tab;                       tab;                       tab ] ].        str nextPutAll: ' }' ]receiver  ^receivertestAsNumberNegatedWithoutDecimalPoint  | sd |  sd := '-123s0' asNumber.  self assert: ScaledDecimal identicalTo: sd class.  self assert: sd scale equals: 0.  self assert: '-123s0' equals: sd printStringsharedPools  ^OrderedCollection newsuperclass: aSuperclass layout: aLayout  layout := aLayout.  self superclass: aSuperclass methodDictionary: self emptyMethodDictionary format: aLayout formataddSubclass: aClass  testIsDeprecated  | deprecatedSelectors |  deprecatedSelectors := #(deprecatedMethod deprecatedMethod2 deprecatedMethod3 deprecatedMethod4 deprecatedMethod5 deprecatedMethod6 deprecatedMethod7).  self class selectorsDo: [:each |  (deprecatedSelectors includes: each) ifTrue: [ self assert: (self class >> each) isDeprecated ] ifFalse: [ self deny: (self class >> each) isDeprecated ] ].  DeprecatedClassForTest selectorsDo: [:each |  self assert: (DeprecatedClassForTest >> each) isDeprecated ]strictlyPositive  ^falsewaitLastProcessLock  self waitProcessLock: forkedProcesses laststonOn: stonWriter  stonWriter writeObject: self listSingleton: self name asSymboltestMutateVariableObject  | guineaPigs |  guineaPigs := {#[1 2 3] .   #(1 2 3)}.  guineaPigs do: [:guineaPig |  guineaPig beReadOnlyObject.        [ guineaPig at: 1 put: 4 ] on: ModificationForbidden do: [  ].        guineaPig           beWritableObject;           at: 2 put: 5;           beReadOnlyObject.        [ guineaPig at: 3 put: 6 ] on: ModificationForbidden do: [  ].        self assert: guineaPig first equals: 1.        self assert: guineaPig second equals: 5.        self assert: guineaPig third equals: 3 ]client  ^sender receiverintersects: aRectangle  | rOrigin rCorner |  rOrigin := aRectangle origin.  rCorner := aRectangle corner.  rCorner x <= origin x ifTrue: [ ^false ].  rCorner y <= origin y ifTrue: [ ^false ].  rOrigin x >= corner x ifTrue: [ ^false ].  rOrigin y >= corner y ifTrue: [ ^false ].  ^truetranslateTo: aTimeZone  ^self class starting: (start translateTo: aTimeZone)to: anEnd  ^Timespan starting: self ending: anEnd asDateAndTimetearDown  testClass := nil.  testSubclass := nil.  super tearDownisLiteral  ^truemethod  ^sendersimpleNoTimeoutTestResults  ^OrderedCollection new     add: self doSomethingString;     yourselfinstSize  ^format bitAnd: 16rFFFFtestNonActiveBlockContextHome  nonActiveBlockContext := self class returnNonActiveContextOfBlock.  self assert: nonActiveBlockContext home isNotNiltestContinuedFractions  self assert: (Float pi asApproximateFractionAtOrder: 1) equals: 22 / 7.  self assert: (Float pi asApproximateFractionAtOrder: 3) equals: 355 / 113genPushLiteral: literalIndex  | extendedIndex |  (literalIndex < 0 or: [ literalIndex > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 32768 ].  literalIndex < 32 ifTrue: [ stream nextPut: 32 + literalIndex.        ^self ].  (extendedIndex := literalIndex) > 255 ifTrue: [ self genUnsignedSingleExtendA: extendedIndex // 256.        extendedIndex := extendedIndex \\ 256 ].  stream     nextPut: 228;     nextPut: extendedIndextestNewDayYear  self assert: (Date year: 2004 day: 23) equals: january23rd2004haltIfNil  < debuggerCompleteToSender>  Halt nowunschedule: aDelay  < haltOrBreakpointForTesting>  debug ifTrue: [ self halt ].  delayToStop := aDelay.  timingSemaphore signal.  debug ifTrue: [ self halt ]testDayOfWeek  self assert: aDateAndTime dayOfWeek equals: 3.  self assert: aDateAndTime dayOfWeekAbbreviation equals: 'Tue'.  self assert: aDateAndTime dayOfWeekName equals: 'Tuesday'thoroughHasSelectorReferringTo: literal  | specialIndex |  specialIndex := Smalltalk specialSelectorIndexOrNil: literal.  ^self methods anySatisfy: [:method |  method hasSelector: literal specialSelectorIndex: specialIndex ]isEqualRegardlessMethodsTrailerTo: aMethodDictionary  self == aMethodDictionary ifTrue: [ ^true ].  aMethodDictionary isDictionary ifFalse: [ ^false ].  self size = aMethodDictionary size ifFalse: [ ^false ].  self associationsDo: [:assoc |  ((aMethodDictionary at: assoc key ifAbsent: [ ^false ]) isEqualRegardlessTrailerTo: assoc value) ifFalse: [ ^false ] ].  ^truetestNew  squared  ^Fraction numerator: numerator squared denominator: denominator squarednextHandlerContext  ^self sender findNextHandlerContextsuitableRulesFrom: aReRuleManager  ^aReRuleManager methodRulesstartpc  ^self compiledBlock initialPCsuspendAtTimingPriority  < haltOrBreakpointForTesting>  debug ifTrue: [ self halt ].  ticker saveResumptionTimes: suspendedDelays asArray , {activeDelay}.  suspendSemaphore wait.  debug ifTrue: [ self halt ].  ticker restoreResumptionTimes: suspendedDelays asArray , {activeDelay}.  suspendSemaphore := nilobjectSize: anObject  < primitive: 62>  ^0< aNumber  < primitive: 3>  ^super < aNumbertestReadFromMillisecond  self assert: (Duration readFrom: '0:00:00:00.001 ' readStream) nanoSeconds equals: 1000000writeSlot: aSlot value: anObject  ^aSlot write: anObject to: selfspotterForImplementorsFor: aStep  < spotterOrder: 10>  self method spotterForImplementorsFor: aStepcut: aContext  | context callee |  context := self.  [ context == aContext ] whileFalse: [ callee := context.        context := context sender.        context ifNil: [ aContext ifNotNil: [ self error: 'aContext not a sender' ] ] ].  callee privSender: nilslots: slotCollection  | theClass |  theClass := self instanceSide.  theClass := theClass classInstaller update: theClass to: [:builder |  builder           fillFor: theClass;           classSlots: slotCollection ].  ^theClass classSideday  ^self daysdaysLeftInYear  ^self daysInYear - self dayOfYearnestedLoopsExample: arrays  | result sizeOfResult streams block |  sizeOfResult := arrays inject: 1 into: [:prod :array |  prod * array size ].  streams := arrays collect: [:a |  a readStream ].  result := OrderedCollection new: sizeOfResult.  block := [:r :tupel :allStreams |  | innerBlock |  innerBlock := [:myIdx |  [ myIdx = allStreams size ifTrue: [ 1 to: allStreams size do: [:i |  tupel at: i put: (allStreams at: i) peek ].        r addLast: tupel shallowCopy ] ifFalse: [ innerBlock value: myIdx + 1 ].  (allStreams at: myIdx) next.  (allStreams at: myIdx) atEnd ] whileFalse: [  ].  (allStreams at: myIdx) reset ].  innerBlock value: 1.  r ].  block value: result value: (Array new: streams size) value: streams.  ^resultremoveFirst  | oldLink |  self emptyCheck.  oldLink := firstLink.  firstLink == lastLink ifTrue: [ firstLink := nil.        lastLink := nil ] ifFalse: [ firstLink := oldLink nextLink ].  oldLink nextLink: nil.  ^oldLink valuetestInfinity1  | i1 i2 |  i1 := 10000 exp.  i2 := 1000000000 exp.  self assert: i1 isInfinite & i2 isInfinite & (i1 = i2)isCollection  ^falsewaitProcessLock: aProcess  self waitFor: [ aProcess suspendingList notEmpty ]selector  ^self method selector ifNil: [ self method defaultSelector ]printOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: self state;     nextPut: $:;     print: self duration;     nextPut: $)asCharacterDigit  ^Character digitValue: selfsaveResumptionTimes: delaysOrNils  | oldBaseTick |  oldBaseTick := self nowTick.  delaysOrNils do: [:delay |  delay ifNotNil: [ delay resumptionTickAdjustFrom: oldBaseTick to: 0 ] ]testRefersToLiteralsReturnsTrueWhenLiteralIsByteSymbol  self assert: (self compiledMethod1 hasLiteralThorough: #printOn:)adaptToFloat: rcvr andCompare: selector  ^self adaptToFloat: rcvr andSend: selectortestToByDo  | schedule |  schedule := aDateAndTime to: aDateAndTime + 10 days by: 5 days do: [:i |   ].  self     assert: schedule notNil;     assert: schedule duration equals: 10 daystestIsMathSymbol  self checkCorrespondanceOf: #isMathSymbol: and: #SmclassUnderTest  ^Latin1ifFalse: alternativeBlock  ^alternativeBlock valueprintOn: aStream  origin printOn: aStream.  aStream nextPutAll: ' corner: '.  corner printOn: aStreamtestStoring  | expected actual |  expected := '''2 June 1973'' asDate'.  actual := june2nd1973 storeString.  self     assert: actual equals: expected;     assert: (Smalltalk compiler evaluate: expected) equals: june2nd1973primSignal: sempahore atUTCMicroseconds: nextTick  (sempahore isKindOf: Semaphore) ifTrue: [ vmSimTheTimerSemaphore := sempahore.        vmSimNextWakeupTick := nextTick ].  sempahore = nil ifTrue: [ vmSimTheTimerSemaphore := nil.        vmSimNextWakeupTick := 0 ]setUp  super setUp.  generator := Random seed: 14159265ticks: anArray  seconds := anArray at: 2.  nanos := anArray at: 3compileAllFrom: oldClass  super compileAllFrom: oldClass.  self classSide compileAllFrom: oldClass classSideendPC  ^self trailer endPCisCompiledMethod  ^truenextReadyProcess  quiescentProcessLists reverseDo: [:list |  list isEmpty ifFalse: [ | proc |              proc := list first.              proc suspendedContext ifNotNil: [ ^proc ] ] ].  ^nilarguments  ^argsisInteger  ^truesetActionSequence: actionSequence forEvent: anEventSelector  | action |  action := actionSequence asMinimalRepresentation.  action ifNil: [ self removeActionsForEvent: anEventSelector ] ifNotNil: [ self updateableActionMap at: anEventSelector asSymbol put: action ]testNaN1  self assert: Float nan identicalTo: Float nan.  self deny: Float nan equals: Float nanbrowseHierarchy  self systemNavigation browseHierarchy: self classduringTestCompileSilently: code storeSource: storeSource classified: aCategory  ^FLPlatform current useAuthor: 'TestsAuthor' during: [ [ self compile: code classified: (aCategory ifNil: [ '' ]) withStamp: nil notifying: nil logSource: storeSource ] fuelValueWithoutNotifications ]genPushSpecialLiteral: aLiteral  self subclassResponsibilityfrequency  ^iterations / elapsedTime totalSecondsgtIterator  ^Error signal: 'This is not a spotter iterator'floor  self isIntegerRectangle ifTrue: [ ^self ].  ^origin floor corner: corner floorasCharacter  ^Character value: self@ y  < primitive: 18>  ^Point x: self y: ywhileTrue: aBlock  self value ifTrue: [ aBlock value.        self whileTrue: aBlock ].  ^nilweek  ^self weekstestAsNumberWithSuperfluousDecimalPoint  | sd |  sd := '123.s2' asNumber.  self deny: ScaledDecimal == sd class description: 'It used to, but this syntax is not valid Smalltalk'monthIndex  ^self month==> aBlock  ^self not or: [ aBlock value ]removeAllMethods  self deprecated: 'Use #removeAllMethodSelectors instead' transformWith: '`@receiver removeAllMethods' -> '`@receiver removeAllMethodSelectors'.  ^self removeAllMethodSelectorsmillisecondDelayDuration  ^millisecondDelayDuration> aNumber  aNumber isInteger ifTrue: [ self negative == aNumber negative ifTrue: [ self negative ifTrue: [ ^(self bytesCompare: aNumber) < 0 ] ifFalse: [ ^(self bytesCompare: aNumber) > 0 ] ] ifFalse: [ ^aNumber negative ] ].  ^aNumber adaptToInteger: self andCompare: #>numArgs  ^arguments sizeat: aKey ifAbsentPut: aBlock  1 to: self basicSize do: [:i |  | propertyOrPragma |        (propertyOrPragma := self basicAt: i) key == aKey ifTrue: [ ^propertyOrPragma isVariableBinding ifTrue: [ propertyOrPragma value ] ifFalse: [ propertyOrPragma ] ] ].  ^method propertyAt: aKey put: aBlock valuejoin: aSequenceableCollection  ^(Array with: self) join: aSequenceableCollectionselectorsWithExplicitOrigin  ^self traitComposition selectors , self localSelectorstestTwoCriticalsShouldWaitEachOther  | lastCriticalExecuted firstCriticalExecutedFirst semaphoreToHoldMutex |  lastCriticalExecuted := false.  firstCriticalExecutedFirst := false.  semaphoreToHoldMutex := Semaphore new.  self fork: [ mutex critical: [ semaphoreToHoldMutex wait.              firstCriticalExecutedFirst := lastCriticalExecuted not ] ].  self waitLastProcessLock.  self fork: [ mutex critical: [ lastCriticalExecuted := true ] ].  self waitLastProcessLock.  semaphoreToHoldMutex signal.  self waitLastProcessTerminate.  self assert: lastCriticalExecuted.  self assert: firstCriticalExecutedFirstinstVarNamed: aString  ^self class slotNamed: aString ifFound: [:slot |  slot read: self ] ifNone: [ InstanceVariableNotFound signalFor: aString asString ]superclass: aClass methodDictionary: mDict format: fmt  self basicSuperclass: aClass.  self setFormat: fmt.  self methodDict: mDicttraits  ^#()denominator  ^1genStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex  (tempIndex >= 0 and: [ tempIndex < 256 and: [ tempVectorIndex >= 0 and: [ tempVectorIndex < 256 ] ] ]) ifTrue: [ stream           nextPut: 142;           nextPut: tempIndex;           nextPut: tempVectorIndex.        ^self ].  tempIndex >= 256 ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255 ].  tempVectorIndex >= 256 ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255 ]isFinite  ^self - self = 0.0endPC  ^self compiledBlock endPCnumberOfReservedLiterals  ^self subclassResponsibilitypointNearestTo: aPoint  | side |  (self containsPoint: aPoint) ifTrue: [ side := self sideNearestTo: aPoint.        side == #right ifTrue: [ ^self right @ aPoint y ].        side == #left ifTrue: [ ^self left @ aPoint y ].        side == #bottom ifTrue: [ ^aPoint x @ self bottom ].        side == #top ifTrue: [ ^aPoint x @ self top ] ] ifFalse: [ ^aPoint adhereTo: self ]isForm  ^falsetestAndSingleBitWithMinusOne  1 to: 100 do: [:i |  self assert: ((1 bitShift: i) bitAnd: -1) equals: (1 bitShift: i) ]roundTo: grid  ^Rectangle origin: (origin roundTo: grid) corner: (corner roundTo: grid)isTerminated  self isActiveProcess ifTrue: [ ^false ].  ^suspendedContext isNil or: [ suspendedContext isBottomContext and: [ suspendedContext isDead or: [ suspendedContext pc > suspendedContext startpc ] ] ]asBeaconSignal  ^WrapperSignal on: selftestStarting  | aDateAndTime anyTime |  anyTime := '13:12' asTime.  aDateAndTime := DateAndTime date: january23rd2004 time: anyTime.  self assert: (Date starting: aDateAndTime) equals: january23rd2004copyTwoLevel  | newObject class index |  class := self class.  newObject := self shallowCopy.  newObject == self ifTrue: [ ^self ].  class isVariable ifTrue: [ index := self basicSize.        [ index > 0 ] whileTrue: [ newObject basicAt: index put: (self basicAt: index) shallowCopy.              index := index - 1 ] ].  index := class instSize.  [ index > 0 ] whileTrue: [ newObject instVarAt: index put: (self instVarAt: index) shallowCopy.        index := index - 1 ].  ^newObjectcleanOuterContext  outerContext := outerContext cleanCopyasRingMinimalDefinitionIn: anRGEnvironment  ^anRGEnvironment backend definitionFor: self ifAbsentRegister: [ RGMethod named: self selector asSymbol parent: (self methodClass asRingMinimalDefinitionIn: anRGEnvironment) ]