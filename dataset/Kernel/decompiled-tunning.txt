ffiInstVarArgument: arg1 generator: arg2  (self allInstVarNames includes: arg1) ifFalse: [ ^nil ].  ^FFIInstVarArgument new     argName: arg1;     yourselfsetAuthorInMetacelloConfig: arg1  arg1 setAuthorWithBlock: selfln  | tmp1 |  self <= 0 ifTrue: [ ^DomainError signal: 'ln is only defined for x > 0' from: 0 ].  numerator < denominator ifTrue: [ ^self reciprocal ln negated ].  tmp1 := super ln.  tmp1 isFinite ifTrue: [ ^tmp1 ].  ^numerator ln - denominator lniceSemanticVersion  ^IceSemanticVersion major: self asInteger minor: 0 patch: 0~= arg1  < primitive: 8>  ^super ~= arg1hasComment  ^self commentRemoteString isNotNiltestReflexive  | tmp1 |  tmp1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self assert: tmp1 equals: tmp1numLocalTemps  ^self method encoderClass numLocalTempsForBlockAt: startpc in: outerContext methodprintFormat: arg1  ^String new: 16 streamContents: [:arg2 |  self printOn: arg2 format: arg1 ]sqrt  ^DomainError signal: 'sqrt undefined for number less than zero.'greaseString  ^String streamContents: [:arg1 |  x printOn: arg1.        arg1 nextPut: $@.        (y notNil and: [ y negative ]) ifTrue: [ arg1 space ].        y printOn: arg1 ]compiler  ^self compilerClass new     environment: self environment;     class: selftestYesterday  self deny: aDateAndTime equals: DateAndTime yesterdaytestAsDate  self assert: aDateAndTime asDate equals: 'January 1, 1970' asDateobject: arg1  object := arg1wholeMicroseconds  ^(nanos rem: 1e6) quo: 1e3monthAbbreviation  ^self monthName copyFrom: 1 to: 3stonName  ^#ClassincludesAll: arg1  ^arg1 allSatisfy: [:arg2 |  self includes: arg2 ]activeProcess  ^activeProcess effectiveProcesssetUp  super setUp.  aDate := DateAndTime year: 2003 month: 01 day: 07 hour: 0 minute: 0 second: 0.  aDuration := Duration days: 91 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.  aTimespan := Timespan starting: aDate duration: aDurationtestMetaclass  self assert: OrderedCollection class class identicalTo: Metaclass.  self assert: Dictionary class class identicalTo: Metaclass.  self assert: Object class class identicalTo: MetaclasstestPrintOn  self assert: [ 1 + 2 ] printString equals: '[ 1 + 2 ]'testStoreOn  | tmp1 |  aDuration storeOn: (tmp1 := (String new: 20) writeStream).  self assert: tmp1 contents equals: '(Duration seconds: 93784 nanoSeconds: 5)'removeInstVarNamed: arg1  ^self removeSlot: (self slotNamed: arg1)exit  nestingLevel := nestingLevel - 1.  nestingLevel < 1 ifTrue: [ ownerProcess := nil.        mutex signal ]hasEqualTicks: arg1  ^self julianDayNumberUTC = arg1 julianDayNumberUTC and: [ seconds = arg1 secondsSinceMidnightUTC and: [ nanos = arg1 nanoSecond ] ]findSecondToOldestSimilarSender  | tmp1 tmp2 tmp3 |  tmp1 := self.  tmp2 := self.  [ tmp3 := tmp2 findSimilarSender.  tmp3 isNil ] whileFalse: [ tmp1 := tmp2.        tmp2 := tmp3 ].  ^tmp1testFloorLog2  | tmp1 tmp2 |  tmp2 := 1 + Float epsilon.  tmp1 := 1 - Float epsilon.  Float emin + 1 to: Float emax - 1 do: [:arg1 |  | tmp3 |        tmp3 := 1.0 timesTwoPower: arg1.        self assert: (tmp3 floorLog: 2) equals: arg1.        self assert: (tmp3 * tmp2 floorLog: 2) equals: arg1.        self assert: (tmp3 * tmp1 floorLog: 2) equals: arg1 - 1 ]topRight  ^corner x @ origin ytestIfFalseIfTrue  self assert: (false ifFalse: [ 'falseAlternativeBlock' ] ifTrue: [ 'trueAlternativeBlock' ]) equals: 'falseAlternativeBlock'executionsPerSecond  ^self frequencytestGpsExample1  | tmp1 tmp2 |  tmp2 := (1 to: 100) asArray.  tmp1 := tmp2 inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 ].  self assert: (self gpsExample1: tmp2) equals: tmp1testMinMax  self assert: (10 min: 20 max: 12) equals: 12.  self assert: (13 min: 20 max: 12) equals: 13.  self assert: (12 min: 20 max: 12) equals: 12.  self assert: (100 min: 20 max: 12) equals: 20.  self assert: (42 min: 50 max: 40) equals: 42.  self assert: (42 min: 50 max: 45) equals: 45.  self assert: (42 min: 40 max: 30) equals: 40highBitOfMagnitude  ^self subclassResponsibilityparseFourDigitYear  year := self parse: 'year' expectedSize: 4withArgumentsDo: arg1  ^arg1 valueWithArguments: self argumentsabs  ^x abs @ y absaddSlot: arg1  ^self instanceSide addClassSlot: arg1mixedMethod  RecursionStopper during: [ self assert: value equals: 0.        value := value + 1.        RecursionStopper during: [ value := value + 1 ].        self assert: value equals: 1.        self mixedMethod.        self assert: value equals: 1 ].  RecursionStopper during: [ self assert: value equals: 1.        ^2 ].  self assert: value equals: 1.  ^valueneedsSlotClassDefinition  ^self slotsNeedFullDefinition or: [ self class slotsNeedFullDefinition or: [ self classVariablesNeedFullDefinition ] ]numArgs  ^numArgsat: arg1  | tmp1 tmp2 tmp3 |  arg1 > 0 ifTrue: [ tmp1 := self basicSize.        arg1 <= tmp1 ifTrue: [ tmp2 := 0.              1 to: tmp1 do: [:arg2 |  (tmp3 := self basicAt: arg2) == nil ifFalse: [ (tmp2 := tmp2 + 1) = arg1 ifTrue: [ ^tmp3 ] ] ] ] ].  self error: 'access with an index out of bounds'isNamedPrimitive  ^self primitive = 117beingWaitedOn  ^beingWaitedOninstanceCount  | tmp1 |  tmp1 := 0.  self allInstancesDo: [:arg1 |  tmp1 := tmp1 + 1 ].  ^tmp1hexDigitValue  | tmp1 |  ^((tmp1 := self asInteger) between: 0 and: 127) ifTrue: [ #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 0 1 2 3 4 5 6 7 8 9 nil nil nil nil nil nil nil 10 11 12 13 14 15 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 10 11 12 13 14 15 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil) at: tmp1 + 1 ] ifFalse: [ nil ]testDaysLeftInYear  self assert: aTimespan daysLeftInYear equals: 364testEnd  self assert: aTimespan end + (Duration nanoSeconds: 1) equals: aDisjointTimespan start.  self assert: aTimespan end equals: (DateAndTime year: 2005 month: 1 day: 7 hour: 23 minute: 59 second: 59 nanoSecond: 999999999 offset: 0 hours)willReturn  ^self method encoderClass isReturnAt: pc in: self methodisCasedLetter  ^self characterSet isCasedLetter: selfelementCategoryDict  | tmp1 tmp2 tmp3 |  elementArray ifNil: [ ^nil ].  tmp1 := Dictionary new: elementArray size.  1 to: categoryStops size do: [:arg1 |  tmp2 := self firstIndexOfCategoryNumber: arg1.        tmp3 := self lastIndexOfCategoryNumber: arg1.        tmp2 to: tmp3 do: [:arg2 |  tmp1 at: (elementArray at: arg2) put: (categoryArray at: arg1) ] ].  ^tmp1setX: arg1 setY: arg2  x := arg1.  y := arg2and: arg1  self subclassResponsibilitytestAccessing  self     assert: time hours equals: 4;     assert: time minutes equals: 2;     assert: time seconds equals: 47;     assert: time asSeconds equals: 14567classVarNames  ^#()printStringBase: arg1  self < 0 ifTrue: [ ^'-' , (self negated printStringBase: arg1) ].  self < arg1 ifTrue: [ ^String with: (Character digitValue: self) ].  ^self printStringBase: arg1 nDigits: (self numberOfDigitsInBase: arg1)testContinuationExample3  | tmp1 |  tmp1 := (1 to: 20) asOrderedCollection.  self assert: (self continuationExample3: tmp1) equals: (tmp1 collect: [:arg1 |  arg1 * arg1 - 10 ])errorReportOn: arg1  | tmp1 tmp2 |  arg1     print: Date today;     space;     print: Time now;     cr.  arg1 cr.  arg1     nextPutAll: 'VM: ';     nextPutAll: Smalltalk os name asString;     nextPutAll: ' - ';     nextPutAll: Smalltalk os subtype asString;     nextPutAll: ' - ';     nextPutAll: Smalltalk os version asString;     nextPutAll: ' - ';     nextPutAll: Smalltalk vm version asString;     cr.  arg1     nextPutAll: 'Image: ';     nextPutAll: SystemVersion current version asString;     nextPutAll: ' [';     nextPutAll: Smalltalk lastUpdateString asString;     nextPutAll: ']';     cr.  arg1 cr.  tmp1 := 0.  tmp2 := self.  [ tmp2 notNil and: [ (tmp1 := tmp1 + 1) < 40 ] ] whileTrue: [ tmp2 printDetails: arg1.        arg1 cr.        tmp2 := tmp2 sender ].  arg1     cr;     nextPutAll: '--- The full stack ---';     cr.  tmp2 := self.  tmp1 := 0.  [ tmp2 == nil ] whileFalse: [ tmp1 := tmp1 + 1.        tmp1 = 40 ifTrue: [ arg1                 nextPutAll: ' - - - - - - - - - - - - - - -  			- - - - - - - - - - - - - - - - - -';                 cr ].        arg1           print: tmp2;           cr.        tmp1 > 200 ifTrue: [ arg1 nextPutAll: '-- and more not shown --'.              ^self ].        tmp2 := tmp2 sender ]initialize  super initialize.  forkedProcesses := OrderedCollection newisSelfEvaluating  ^self isObsolete notasFraction  ^selftestIsEmptyOrNil  self assert: nil isEmptyOrNilinitialize  super initialize.  vmSimTheTimerSemaphore := Semaphore new.  vmSimNow := 0variableWordSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 category: arg6  ^self variableWordSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 package: arg6asDateAndTime  ^DateAndTime today + selftestOneOverTwo  | tmp1 |  tmp1 := BenchmarkResult new.  tmp1 iterations: 1.  tmp1 elapsedTime: 2 second.  self deny: tmp1 isEmpty.  self assert: tmp1 iterations equals: 1.  self assert: tmp1 elapsedTime equals: 2 second.  self assert: tmp1 frequency equals: 0.5.  self assert: tmp1 executionsPerSecond equals: 0.5.  self assert: tmp1 period equals: 2 second.  self assert: tmp1 timePerExecution equals: 2 second.  self assert: tmp1 shortPrintString equals: '0.500 per second'.  self deny: tmp1 printString isEmptyprintYMDOn: arg1  ^self printYMDOn: arg1 withLeadingSpace: falserfvalue  < primitive: 201>  < metaLinkOptions: #(+ optionDisabledLink)>  numArgs ~= 0 ifTrue: [ self numArgsError: 0 ].  ^self primitiveFailedprintOn: arg1 base: arg2  arg1 nextPut: $(.  numerator printOn: arg1 base: arg2.  arg1 nextPut: $/.  denominator printOn: arg1 base: arg2.  arg1 nextPut: $)inform: arg1  arg1 isEmptyOrNil ifFalse: [ UIManager default inform: arg1 ]extensionProtocols  ^self protocols select: #isExtensionProtocolsendNodes  ^self methods flatCollect: [:arg1 |  arg1 sendNodes ]testDegreeSin  45.0 degreeSin.  self assert: (45.0 degreeSin squared - 0.5) abs <= Float epsilon.  self assert: (30.0 degreeSin - 0.5) abs <= Float epsilon.  self assert: (-30.0 degreeSin + 0.5) abs <= Float epsilon.  -360.0 to: 360.0 do: [:arg1 |  self assert: (arg1 degreeSin closeTo: arg1 degreesToRadians sin) ].  -10.0 to: 10.0 do: [:arg2 |  self assert: (arg2 * 360 + 90) degreeSin - 1 equals: 0.        self assert: (arg2 * 360 - 90) degreeSin + 1 equals: 0.        self assert: (arg2 * 360 + 180) degreeSin equals: 0.        self assert: (arg2 * 360) degreeSin equals: 0 ]floatCenter  ^(self topLeft + self bottomRight) / 2.0resume  self resume: nilsimpleEnsureTestWithUparrowResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     yourselfallCallsOn  self isAnonymous ifTrue: [ ^#() ].  ^self usingMethods , self name asSymbol sendersisReturnField  ^self primitive between: 264 and: 519- arg1  < primitive: 2>  ^super - arg1comments  ^self ast allChildren flatCollect: [:arg1 |  arg1 comments collect: [:arg2 |  arg2 contents ] ]allUnreferencedClassVariables  ^self allClassVariables reject: #isReferencedtestSimple  | tmp1 |  tmp1 := BenchmarkResult new.  tmp1 iterations: 100.  tmp1 elapsedTime: 4 seconds.  self deny: tmp1 isEmpty.  self assert: tmp1 iterations equals: 100.  self assert: tmp1 elapsedTime equals: 4 seconds.  self assert: tmp1 frequency equals: 25.  self assert: tmp1 executionsPerSecond equals: 25.  self assert: tmp1 period equals: 40 milliSeconds.  self assert: tmp1 timePerExecution equals: 40 milliSeconds.  self assert: tmp1 shortPrintString equals: '25.000 per second'.  self deny: tmp1 printString isEmptytestReentrantBlock  | tmp1 |  tmp1 := [:arg1 |  arg1 <= 0 ifTrue: [ self error: 'not a natural number' ].  arg1 <= 2 ifTrue: [ 1 ] ifFalse: [ (tmp1 value: arg1 - 1) + (tmp1 value: arg1 - 2) ] ].  self should: [ tmp1 value: 0 ] raise: self classForTestResult error.  self assert: (tmp1 value: 1) equals: 1.  self assert: (tmp1 value: 2) equals: 1.  self assert: (tmp1 value: 3) equals: 2.  self assert: (tmp1 value: 4) equals: 3.  self assert: (tmp1 value: 5) equals: 5.  self assert: (tmp1 value: 6) equals: 8expandBy: arg1  ^arg1 asMargin expandRectangle: selfpushTemporaryVariable: arg1  self push: (self at: arg1 + 1)testEmbeddingSourceCode  self testEmbeddingSourceCode: 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: newTrailer sourceCode equals: code.'.  self testEmbeddingSourceCode: (String loremIpsum: 30000)lowBit  | tmp1 |  self = 0 ifTrue: [ ^0 ].  tmp1 := 1.  [ (self byteAt: tmp1) = 0 ] whileTrue: [ tmp1 := tmp1 + 1 ].  ^(self byteAt: tmp1) lowBit + (8 * (tmp1 - 1))asText  ^self asString asTextremoveCategory: arg1  | tmp1 tmp2 |  tmp1 := categoryArray indexOf: arg1 ifAbsent: [ ^self ].  tmp2 := tmp1 = 1 ifTrue: [ 0 ] ifFalse: [ categoryStops at: tmp1 - 1 ].  (categoryStops at: tmp1) - tmp2 > 0 ifTrue: [ ^self error: 'cannot remove non-empty category ' , arg1 ].  categoryArray := categoryArray copyReplaceFrom: tmp1 to: tmp1 with: Array new.  categoryStops := categoryStops copyReplaceFrom: tmp1 to: tmp1 with: Array new.  categoryArray isEmpty ifTrue: [ categoryArray := Array with: Default.        categoryStops := Array with: 0 ]testComparison  | tmp1 tmp2 tmp3 |  tmp1 := 16r1FFFFFFFFFFFFF1.  tmp2 := 16r1FFFFFFFFFFFFF3.  tmp3 := tmp1 asFloat.  self assert: (tmp1 = tmp3 & (tmp2 = tmp3)) ==> (tmp1 = tmp2).  self assert: 16r1FFFFFFFFFFFFF equals: 16r1FFFFFFFFFFFFF asFloat.  self assert: 16r1FFFFFFFFFFFFF equals: 16r1FFFFFFFFFFFFF asFloat asInteger.  self assert: ((1 bitShift: 54) + 1) / (1 bitShift: 54) > 1.  self assert: ((1 bitShift: 54) + 1) / (1 bitShift: 54) > 1.0.  self assert: ((1 bitShift: 54) - 1) / (1 bitShift: 54) < 1.  self assert: ((1 bitShift: 54) - 1) / (1 bitShift: 54) < 1.0.  1 to: 100 do: [:arg1 |  arg1 isPowerOfTwo ifTrue: [ self assert: 1 / arg1 equals: (1 / arg1) asFloat ] ifFalse: [ self deny: 1 / arg1 equals: (1 / arg1) asFloat ] ].  tmp1 := (11 raisedTo: 400) / 2.  tmp2 := (13 raisedTo: 400) / 2.  tmp3 := tmp1 asFloat.  self assert: (tmp1 = tmp3 & (tmp2 = tmp3)) ==> (tmp1 = tmp2).  self assert: tmp1 < Float infinity.  self assert: tmp1 > Float infinity negated.  self deny: 1 / (11 raisedTo: 400) equals: 0.  self deny: 1 / (11 raisedTo: 400) equals: 0.0.  self assert: ((Set new: 3)           add: 3;           add: 3.0;           size) equals: ((Set new: 4)           add: 3;           add: 3.0;           size)testEmpty  | tmp1 |  tmp1 := BenchmarkResult new.  self assert: tmp1 isEmpty.  self assert: tmp1 iterations isNil.  self assert: tmp1 elapsedTime isNil.  self deny: tmp1 shortPrintString isEmpty.  self deny: tmp1 printString isEmpty>= arg1  arg1 isInteger ifTrue: [ self negative == arg1 negative ifTrue: [ self negative ifTrue: [ ^(self bytesCompare: arg1) <= 0 ] ifFalse: [ ^(self bytesCompare: arg1) >= 0 ] ] ifFalse: [ ^arg1 negative ] ].  ^arg1 adaptToInteger: self andCompare: #>=> arg1  ^x > arg1 x and: [ y > arg1 y ]width  ^self right + self leftclassToBeTested  ^CompiledMethodstepToCallee  | tmp1 |  tmp1 := self.  [ (tmp1 := tmp1 step) == self ] whileTrue.  ^tmp1setIsReadOnlyObject: arg1  < primitive: 164 error: ec>  ^self primitiveFailedsqrt  < primitive: 55>  | tmp1 tmp2 tmp3 tmp4 |  self <= 0.0 ifTrue: [ self = 0.0 ifTrue: [ ^0.0 ] ifFalse: [ ^DomainError signal: 'sqrt undefined for number less than zero.' ] ].  tmp1 := self exponent // 2.  tmp2 := self timesTwoPower: 0 - tmp1.  tmp3 := tmp2 * Epsilon.  tmp3 := tmp3 * tmp3.  tmp4 := (self - (tmp2 * tmp2)) / (tmp2 * 2.0).  [ tmp4 * tmp4 > tmp3 ] whileTrue: [ tmp2 := tmp2 + tmp4.        tmp4 := (self - (tmp2 * tmp2)) / (tmp2 * 2.0) ].  ^tmp2greaseString  ^self asStringcompiledMethodAt: arg1  ^self methodDict at: arg1weekdayIndex  ^self dayOfWeekangleWith: arg1  | tmp1 tmp2 |  tmp1 := self angle.  tmp2 := arg1 angle.  ^tmp2 >= tmp1 ifTrue: [ tmp2 - tmp1 ] ifFalse: [ Float pi * 2 - tmp1 + tmp2 ]immediateSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 category: arg5  ^self immediateSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5isFromTrait  ^self origin isTrait and: [ self origin ~= self methodClass ]removeClassVarNamed: arg1 interactive: arg2  | tmp1 tmp2 |  tmp1 := arg1 asSymbol.  (self classPool includesKey: tmp1) ifFalse: [ ^self error: arg1 , ' is not a class variable' ].  tmp2 := self anyUserOfClassVarNamed: tmp1.  tmp2 notNil & arg2 ifTrue: [ (self confirm: (arg1 , ' is still used in code of class ' , tmp2 name , '.\Is it okay to move it to Undeclared?') withCRs) ifFalse: [ ^self ] ].  tmp2 ifNotNil: [ NewUndeclaredWarning signal: arg1 in: self name.        Undeclared declare: tmp1 from: self classPool ] ifNil: [ self classPool removeKey: tmp1 ].  self classPool isEmpty ifTrue: [ self classPool: nil ].  SystemAnnouncer uniqueInstance classModificationAppliedTo: self= arg1  ^arg1 species == self species and: [ receiver == arg1 receiver and: [ selector == arg1 selector and: [ arguments = arg1 arguments ] ] ]newAnonymousSubclass  ^Smalltalk anonymousClassInstaller make: [:arg1 |  arg1           superclass: self;           layoutClass: self classLayout class ]nearestPointAlongLineFrom: arg1 to: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  arg1 x = arg2 x ifTrue: [ ^arg1 x @ y ].  arg1 y = arg2 y ifTrue: [ ^x @ arg1 y ].  tmp4 := arg1 x asFloat.  tmp5 := arg1 y asFloat.  tmp1 := arg2 x asFloat - tmp4.  tmp2 := arg2 y asFloat - tmp5.  tmp3 := ((y asFloat - tmp5) / tmp1 + ((x asFloat - tmp4) / tmp2)) / (tmp1 / tmp2 + (tmp2 / tmp1)).  ^(tmp4 + (tmp3 * tmp1)) @ (tmp5 + (tmp3 * tmp2))asRingMinimalDefinitionIn: arg1  ^arg1 backend definitionFor: self ifAbsentRegister: [ RGClass named: self name asSymbol parent: arg1 ]testYearDay  self assert: aDateAndTime equals: (DateAndTime year: 1980 day: 1)tag  ^tag ifNil: [ self messageText ] ifNotNil: [ tag ]activateReturn: arg1 value: arg2  ^self activateMethod: Context theReturnMethod withArgs: {arg2} receiver: arg1 class: arg1 classglmCritiqueSourceIn: arg1  rotateBy: arg1 centerAt: arg2  | tmp1 |  tmp1 := self - arg2.  arg1 == #right ifTrue: [ ^tmp1 y negated @ tmp1 x + arg2 ].  arg1 == #left ifTrue: [ ^tmp1 y @ tmp1 x negated + arg2 ].  arg1 == #pi ifTrue: [ ^arg2 - tmp1 ].  self error: 'unrecognizable direction'= arg1  arg1 class = self class ifTrue: [ ^self asFraction = arg1 asFraction ].  ^self asFraction = arg1categoryNameForTemporaryClasses  ^'Dummy-Tests-Class'fuelAfterMaterialization  testDayOfMonth  self assert: aTimespan dayOfMonth equals: 1testBlockEscape  | tmp1 |  tmp := 0.  tmp1 := [ tmp := tmp + 1.  tmp2 value ].  self callcc: [:arg1 |  tmp2 := arg1.        tmp1 value ].  tmp2 := [  ].  tmp1 value.  self assert: tmp equals: 2testCriticalIfError  | tmp1 |  tmp1 := Semaphore forMutualExclusion.  [ tmp1 critical: [ self criticalError ifError: [  ] ] ] forkAt: Processor userInterruptPriority.  self assert: tmp1 isSignaledhasSender: arg1  | tmp1 |  self == arg1 ifTrue: [ ^false ].  tmp1 := sender.  [ tmp1 == nil ] whileFalse: [ tmp1 == arg1 ifTrue: [ ^true ].        tmp1 := tmp1 sender ].  ^falseasMilliseconds  ^self asMilliSecondscommentRemoteString  ^commentRemoteStringtestAsDate  self assert: aDateAndTime asDate equals: 'January 1, 1980' asDatepropertyAt: arg1  | tmp1 |  ^(tmp1 := self penultimateLiteral) isMethodProperties ifTrue: [ tmp1 propertyAt: arg1 ifAbsent: [ nil ] ] ifFalse: [ nil ]fuelPrepare  self isNamedPrimitive ifTrue: [ self literals first at: 4 put: 0 ]tearDown  fork ifNotNil: [ fork terminate.        fork := nil ].  super tearDowntestPrint24  self assert: aTime print24 equals: '12:34:56'testAsWeek  self assert: aTime asWeek equals: (DateAndTime current midnight + aTime) asWeeksizeInMemory  self class isImmediateClass ifTrue: [ ^0 ].  ^self class isVariable ifTrue: [ self class byteSizeOfInstanceOfSize: self basicSize ] ifFalse: [ self class byteSizeOfInstance ]last  self reverseDo: [:arg1 |  ^arg1 ].  self error: 'this collection is empty'phlowValue: arg1 value: arg2  ^self cull: arg1 cull: arg2testSupplyAnswerUsingOnlySubstringOfQuestion  self should: [ false = ([ self confirm: 'You like Smalltalk?' ] valueSupplyingAnswer: #('like' false)) ]> arg1  < primitive: 44>  ^arg1 adaptToFloat: self andCompare: #>testSimpleEnsure  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTest)slotDefinitionString  ^String streamContents: [:arg1 |  | tmp1 |        arg1 nextPutAll: '{ '.        self localSlots do: [:arg2 |  arg1 nextPutAll: arg2 definitionString.              tmp1 := arg2 needsFullDefinition ] separatedBy: [ arg1 nextPutAll: '. '.              tmp1 ifTrue: [ arg1                       cr;                       tab;                       tab;                       tab;                       tab ] ].        arg1 nextPutAll: ' }' ]testLiteral  | tmp1 |  tmp1 := 1.40s2.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: tmp1 scale equals: 2.  self assert: '1.40s2' equals: tmp1 printStringabstractBytecodeMessagesDo: arg1  self method abstractBytecodeMessagesFrom: startpc to: self endPC do: arg1testDoubleOuterPass  self assertSuccess: (ExceptionTester new runTest: #doubleOuterPassTest)offset: arg1  ^self class starting: (self start offset: arg1) duration: self durationstonContainSubObjects  ^falserestartTopWith: arg1  arg1 isQuick ifTrue: [ self popTo: suspendedContext sender ] ifFalse: [ suspendedContext privRefreshWith: arg1 ]addInstVarNamed: arg1  self subclassResponsibilityargumentNamed: arg1 ifNone: arg2  ^self argumentAt: (self selector keywords indexOf: arg1 asMutator ifAbsent: [ ^arg2 value ])withThorougMethodsReferTo: arg1 do: arg2  | tmp1 |  tmp1 := Smalltalk specialSelectorIndexOrNil: arg1.  self selectorsAndMethodsDo: [:arg3 :arg4 |  (arg4 hasSelector: arg1 specialSelectorIndex: tmp1) ifTrue: [ arg2 value: arg4 ] ]classify: arg1 under: arg2 suppressIfDefault: arg3  | tmp1 tmp2 tmp3 |  tmp2 := (self protocolOrganizer includesSelector: arg1) not.  tmp1 := self categoryOfElement: arg1.  (tmp2 or: [ tmp1 ~= arg2 or: [ arg3 not or: [ arg2 ~= Protocol unclassified ] ] ]) ifFalse: [ ^self ].  tmp3 := self protocolOrganizer protocolsOfSelector: arg1.  self protocolOrganizer classify: arg1 inProtocolNamed: arg2.  arg3 ifTrue: [ (tmp3 select: #canBeRemoved) do: [:arg4 |  self removeProtocol: arg4 ] ].  tmp1 ifNotNil: [ self notifyOfChangedSelector: arg1 from: tmp1 to: arg2 ]asNanoSeconds  ^seconds * NanosInSecond + nanostearDown  classFactory cleanUp.  super tearDown% arg1  ^self \\ arg1asFullRingDefinition  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self asRingDefinition.  tmp1 package: (RGContainer packageOfClass: tmp1).  self superclass notNil ifTrue: [ tmp2 := self superclass asRingDefinition.        tmp1 superclass: tmp2 ] ifFalse: [ self isTrait ifTrue: [ tmp2 := Trait asRingDefinition.              tmp1 superclass: tmp2 ] ].  self subclasses do: [:arg1 |  tmp3 := arg1 asRingDefinition.        tmp3 superclass: tmp1 ].  tmp5 := RGContainer packageKeys.  self methodsDo: [:arg2 |  tmp4 := arg2 asActiveRingDefinition.        tmp1 addMethod: tmp4.        tmp4 package: (RGContainer packageOfMethod: tmp4 using: tmp5) ].  self classSide methodsDo: [:arg2 |  tmp4 := arg2 asActiveRingDefinition.        tmp1 classSide addMethod: tmp4.        tmp4 package: (RGContainer packageOfMethod: tmp4 using: tmp5) ].  ^tmp1printOn: arg1 base: arg2 nDigits: arg3  self subclassResponsibilityisSubclassResponsibility: arg1  ^arg1 == self class subclassResponsibilityMarkerencodeSourcePointer  encodedData := ByteArray new: 4.  encodedData at: 4 put: (data >> 24) + 251.  1 to: 3 do: [:arg1 |  encodedData at: 4 - arg1 put: ((data bitShift: (arg1 - 3) * 8) bitAnd: 16rFF) ]reduce  ^selfwaitLastProcessTerminate  self waitProcessTermination: forkedProcesses lastresume: arg1  self resume: arg1 through: (thisContext findNextUnwindContextUpTo: self)definition  (self needsSlotClassDefinition or: [ Slot showSlotClassDefinition ]) ifTrue: [ ^self definitionWithSlots ].  ^self definitionWithoutSlotsallSelectorsToTestInMethodFinder  ^#()setUp  super setUp.  june2nd1973 := self dateClass year: 1973 day: 153.  january23rd2004 := Date readFrom: '01-23-2004' readStream.  aTime := Time readFrom: '12:34:56 pm' readStreamveryDeepInner: arg1  classLayout  ^layout ifNil: [ | tmp1 tmp2 |        tmp1 := superclass ifNil: [ FixedLayout new slotScope: LayoutEmptyScope instance ] ifNotNil: [:arg1 |  arg1 classLayout ].        tmp2 := tmp1 slotScope extend.        layout := tmp1 class extending: tmp1 scope: tmp2 host: self ]add: arg1 afterLink: arg2  | tmp1 tmp2 |  lastLink == arg2 ifTrue: [ ^self addLast: arg1 ].  tmp1 := arg2 nextLink.  tmp2 := arg1 asLink.  arg2 nextLink: tmp2.  tmp2 nextLink: tmp1.  ^tmp2testNewSubclass  | tmp1 |  tmp1 := Point newSubclass.  self assert: tmp1 isBehavior.  self assert: tmp1 superclass identicalTo: Point.  self assert: (Point allSubclasses includes: tmp1).  self assert: tmp1 instVarNames equals: #().  self assert: tmp1 category equals: self unclassifiedCategory.  self assert: tmp1 classVarNames equals: #().  tmp1 removeFromSystemvalue  self value: niltimingPrioritySignalExpired  beingWaitedOn := false.  monitor signalLock: delaySemaphore inQueue: queuevariableByteSubclass: arg1 uses: arg2 instanceVariableNames: arg3 classVariableNames: arg4 poolDictionaries: arg5 category: arg6  | tmp1 tmp2 |  tmp1 := self environment at: arg1 ifAbsent: [ nil ].  tmp2 := (tmp1 notNil and: [ tmp1 classLayout class == CompiledMethodLayout ]) ifTrue: [ CompiledMethodLayout ] ifFalse: [ ByteLayout ].  ^self subclass: arg1 uses: arg2 layout: tmp2 slots: arg3 asSlotCollection classVariablesNames: arg4 poolDictionaries: arg5 category: arg6subclassDefinerClass  ^self class subclassDefinerClassconvertTwoDigitsYear  (year between: 0 and: 99) ifTrue: [ year := self currentMillenium + year ]interpretV3PlusClosureJumpIfCond  | tmp1 |  tmp1 := self method at: pc.  (tmp1 between: 152 and: 159) ifTrue: [ pc := pc + 1.        ^tmp1 - 151 ].  (tmp1 between: 168 and: 175) ifTrue: [ pc := pc + 2.        ^(tmp1 bitAnd: 3) * 256 + (self method at: pc - 1) ].  ^nilsetFrameBit: arg1  | tmp1 tmp2 |  tmp1 := 16r20000.  tmp2 := self header bitAnd: tmp1 bitInvert.  arg1 ifTrue: [ tmp2 := tmp2 + tmp1 ].  self objectAt: 1 put: tmp2testExactRaisedTo  | tmp1 |  self assert: (4 / 9 raisedTo: 1 / 2) classAndValueEquals: 2 / 3.  self assert: (9 / 4 raisedTo: 1 / 2) classAndValueEquals: 3 / 2.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:arg1 :arg2 |  tmp1 := arg1 / arg2.        self assert: (tmp1 squared raisedTo: 1 / 2) classAndValueEquals: tmp1.        self assert: (tmp1 negated squared raisedTo: 1 / 2) classAndValueEquals: tmp1.        tmp1 := arg2 / arg1.        self assert: (tmp1 squared raisedTo: 1 / 2) classAndValueEquals: tmp1.        self assert: (tmp1 negated squared raisedTo: 1 / 2) classAndValueEquals: tmp1 ].  self assert: (8 / 27 raisedTo: 1 / 3) classAndValueEquals: 2 / 3.  self assert: (27 / 8 raisedTo: 1 / 3) classAndValueEquals: 3 / 2.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:arg1 :arg2 |  tmp1 := arg1 / arg2.        self assert: ((tmp1 raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: tmp1.        self assert: ((tmp1 negated raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: tmp1 negated.        tmp1 := arg2 / arg1.        self assert: ((tmp1 raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: tmp1.        self assert: ((tmp1 negated raisedTo: 3) raisedTo: 1 / 3) classAndValueEquals: tmp1 negated ].  self assert: (4 / 9 raisedTo: 3 / 2) classAndValueEquals: 8 / 27.  self assert: (8 / 27 raisedTo: 2 / 3) classAndValueEquals: 4 / 9.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:arg1 :arg2 |  tmp1 := arg1 / arg2.        self assert: ((tmp1 raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: tmp1 * tmp1.        self assert: ((tmp1 raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: tmp1 * tmp1 * tmp1.        self assert: ((tmp1 negated raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: tmp1 * tmp1.        self assert: ((tmp1 negated raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: tmp1 * tmp1 * tmp1.        tmp1 := arg2 / arg1.        self assert: ((tmp1 raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: tmp1 * tmp1.        self assert: ((tmp1 raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: tmp1 * tmp1 * tmp1.        self assert: ((tmp1 negated raisedTo: 3) raisedTo: 2 / 3) classAndValueEquals: tmp1 * tmp1.        self assert: ((tmp1 negated raisedTo: 2) raisedTo: 3 / 2) classAndValueEquals: tmp1 * tmp1 * tmp1 ].  self assert: (32 / 243 raisedTo: 3 / 5) classAndValueEquals: 8 / 27.  self assert: (8 / 27 raisedTo: 5 / 3) classAndValueEquals: 32 / 243.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:arg1 :arg2 |  tmp1 := arg1 / arg2.        self assert: ((tmp1 raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: tmp1 * tmp1 * tmp1.        self assert: ((tmp1 raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: tmp1 * tmp1 * tmp1 * tmp1 * tmp1.        self assert: ((tmp1 negated raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: (tmp1 * tmp1 * tmp1) negated.        self assert: ((tmp1 negated raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: (tmp1 * tmp1 * tmp1 * tmp1 * tmp1) negated.        self assert: ((tmp1 raisedTo: -5) raisedTo: 3 / 5) classAndValueEquals: 1 / (tmp1 * tmp1 * tmp1).        self assert: ((tmp1 raisedTo: -3) raisedTo: 5 / 3) classAndValueEquals: 1 / (tmp1 * tmp1 * tmp1 * tmp1 * tmp1).        self assert: ((tmp1 negated raisedTo: -5) raisedTo: 3 / 5) classAndValueEquals: -1 / (tmp1 * tmp1 * tmp1).        self assert: ((tmp1 negated raisedTo: -3) raisedTo: 5 / 3) classAndValueEquals: -1 / (tmp1 * tmp1 * tmp1 * tmp1 * tmp1).        self assert: ((tmp1 raisedTo: 5) raisedTo: -3 / 5) classAndValueEquals: 1 / (tmp1 * tmp1 * tmp1).        self assert: ((tmp1 raisedTo: 3) raisedTo: -5 / 3) classAndValueEquals: 1 / (tmp1 * tmp1 * tmp1 * tmp1 * tmp1).        self assert: ((tmp1 negated raisedTo: 5) raisedTo: -3 / 5) classAndValueEquals: -1 / (tmp1 * tmp1 * tmp1).        self assert: ((tmp1 negated raisedTo: 3) raisedTo: -5 / 3) classAndValueEquals: -1 / (tmp1 * tmp1 * tmp1 * tmp1 * tmp1).        self assert: ((tmp1 raisedTo: 3) + 1 raisedTo: 5 / 3) isFloat.        self assert: ((tmp1 negated raisedTo: 3) - 1 raisedTo: 5 / 3) isFloat.        tmp1 := arg2 / arg1.        self assert: ((tmp1 raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: tmp1 * tmp1 * tmp1.        self assert: ((tmp1 raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: tmp1 * tmp1 * tmp1 * tmp1 * tmp1.        self assert: ((tmp1 negated raisedTo: 5) raisedTo: 3 / 5) classAndValueEquals: (tmp1 * tmp1 * tmp1) negated.        self assert: ((tmp1 negated raisedTo: 3) raisedTo: 5 / 3) classAndValueEquals: (tmp1 * tmp1 * tmp1 * tmp1 * tmp1) negated.        self assert: ((tmp1 raisedTo: 3) + 1 raisedTo: 5 / 3) isFloat.        self assert: ((tmp1 negated raisedTo: 3) - 1 raisedTo: 5 / 3) isFloat ]printHierarchy  | tmp1 tmp2 |  tmp2 := 0.  tmp1 := (String new: 16) writeStream.  self allSuperclasses reverseDo: [:arg1 |  tmp1 crtab: tmp2.        tmp2 := tmp2 + 1.        tmp1 nextPutAll: arg1 name.        tmp1 space.        tmp1 print: arg1 instVarNames ].  tmp1 cr.  self printSubclassesOn: tmp1 level: tmp2.  ^tmp1 contentshandleFailingFailingBasicNew  < primitive: 70>  OutOfMemory signal.  ^self basicNewprintDate: arg1 format: arg2 on: arg3  self printYMD: arg1 withLeadingSpace: false on: arg3runTestsBy: arg1  TestExecutionEnvironment new beActiveDuring: arg1isReturnSpecial  ^self primitive between: 256 and: 263printPrimitiveOn: arg1  | tmp1 |  self isPrimitive ifFalse: [ ^self ].  self isExternalCallPrimitive ifTrue: [ ^arg1           print: (self literalAt: 1);           cr ].  arg1 nextPutAll: '<primitive: '.  self isNamedPrimitive ifTrue: [ tmp1 := self literalAt: 1.        (tmp1 at: 2) asString printOn: arg1.        (tmp1 at: 1) ifNotNil: [:arg2 |  arg1 nextPutAll: ' module: '.              arg2 asString printOn: arg1 ] ] ifFalse: [ arg1 print: self primitive ].  self primitiveErrorVariableName ifNotNil: [:arg3 |  arg1           nextPutAll: ' error: ';           nextPutAll: arg3 ].  arg1     nextPut: $>;     crvariableSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: arg4 package: arg5  ^self classInstaller make: [:arg6 |  arg6           superclass: self;           name: arg1;           layoutClass: VariableLayout;           slots: arg2 asSlotCollection;           sharedVariablesFromString: arg3;           sharedPools: arg4;           category: arg5;           environment: self environment ]valueWithin: arg1 onTimeout: arg2  < debuggerCompleteToSender>  | tmp1 tmp2 tmp3 tmp4 |  arg1 <= Duration zero ifTrue: [ ^arg2 value ].  tmp1 := Processor activeProcess.  tmp2 := arg1 asDelay.  tmp4 := self.  tmp3 := [ tmp2 wait.  tmp1 ifNotNil: [ tmp1 signalException: (TimedOut new tag: tmp4) ] ] newProcess.  tmp3 priority: Processor timingPriority - 1.  ^[ tmp3 resume.  self ensure: [ tmp1 := nil.        tmp2 delaySemaphore signal ] ] on: TimedOut do: [:arg3 |  arg3 tag == tmp4 ifTrue: [ arg2 value ] ifFalse: [ arg3 pass ] ]at: arg1  < primitive: 60>  arg1 isInteger ifTrue: [ self class isVariable ifTrue: [ self errorSubscriptBounds: arg1 ] ifFalse: [ self errorNotIndexable ] ].  arg1 isNumber ifTrue: [ ^self at: arg1 asInteger ] ifFalse: [ self errorNonIntegerIndex ]jsonOn: arg1  arg1 scaledDecimal: selffuelAccept: arg1  ^arg1 visitMethodContext: selftestAND  self deny: false & true.  self deny: false & falseprintOn: arg1  arg1 nextPut: $<.  self selector precedence = 1 ifTrue: [ arg1 nextPutAll: self selector ] ifFalse: [ self selector keywords with: self arguments do: [:arg2 :arg3 |  arg1                 nextPutAll: arg2;                 space;                 print: arg3;                 space ].        arg1 skip: -1 ].  arg1 nextPut: $>hasLiteralThorough: arg1  1 to: self basicSize do: [:arg2 |  | tmp1 |        tmp1 := self basicAt: arg2.        (tmp1 isVariableBinding ifTrue: [ tmp1 key == arg1 or: [ tmp1 value == arg1 or: [ tmp1 value isArray and: [ tmp1 value hasLiteral: arg1 ] ] ] ] ifFalse: [ tmp1 hasLiteral: arg1 ]) ifTrue: [ ^true ] ].  ^falseglobalName  ^globalName ifNil: [ [ globalName := ('TestGlobal' , 1e10 atRandom asString) asSymbol ] doWhileTrue: [ testingEnvironment includesKey: globalName ] ]returnPlusOne: arg1  ^arg1 + 1testMinus  self assert: aDateAndTime - aDateAndTime equals: '0:00:00:00' asDuration.  self assert: aDateAndTime - '0:00:00:00' asDuration equals: aDateAndTime.  self assert: aDateAndTime - aDuration equals: (DateAndTime year: 1900 month: 12 day: 30 hour: 21 minute: 56 second: 55 nanoSecond: 999999995 offset: 0 hours)testIsUppercase  self checkCorrespondanceOf: #isUppercase: and: #LutestPrintString  self assert: 1 printString equals: '1'.  self assert: -1 printString equals: '-1'.  Smalltalk vm wordSize = 4 ifTrue: [ self assert: SmallInteger minVal printString equals: '-1073741824'.        self assert: SmallInteger maxVal printString equals: '1073741823' ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: SmallInteger minVal printString equals: '-1152921504606846976'.        self assert: SmallInteger maxVal printString equals: '1152921504606846975' ].  self assert: 12345 printString equals: '12345'.  self assert: -54321 printString equals: '-54321'.  self assert: 0 decimalDigitLength equals: 1.  self assert: 4 decimalDigitLength equals: 1.  self assert: 12 decimalDigitLength equals: 2.  self assert: 123 decimalDigitLength equals: 3.  self assert: 1234 decimalDigitLength equals: 4.  self assert: 56789 decimalDigitLength equals: 5.  self assert: 657483 decimalDigitLength equals: 6.  self assert: 6571483 decimalDigitLength equals: 7.  self assert: 65174383 decimalDigitLength equals: 8.  self assert: 625744831 decimalDigitLength equals: 9.  self assert: 1000001111 decimalDigitLength equals: 10.  Smalltalk vm wordSize = 4 ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 10 ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 19 ]testInstanceCreation  | tmp1 |  tmp1 := DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 6 hours.  self     assert: tmp1 julianDayNumber equals: 1721427;     assert: tmp1 offset equals: 6 hours;     assert: tmp1 hour equals: 2;     assert: tmp1 minute equals: 3;     assert: tmp1 second equals: 4;     assert: tmp1 nanoSecond equals: 5interpretNext2ByteSistaV1Instruction: arg1 for: arg2 extA: arg3 extB: arg4 startPC: arg5  | tmp1 tmp2 |  tmp2 := self method.  tmp1 := self method at: pc.  pc := pc + 1.  arg1 < 234 ifTrue: [ arg1 < 231 ifTrue: [ arg1 < 229 ifTrue: [ | tmp3 |                    arg1 = 226 ifTrue: [ ^arg2 pushReceiverVariable: (arg3 bitShift: 8) + tmp1 ].                    tmp3 := tmp2 literalAt: (arg3 bitShift: 8) + tmp1 + 1.                    arg1 = 227 ifTrue: [ ^arg2 pushLiteralVariable: tmp3 ].                    ^arg2 pushConstant: tmp3 ].              arg1 = 229 ifTrue: [ ^arg2 pushTemporaryVariable: tmp1 ].              ^arg2 pushClosureTemps: tmp1 ].        arg1 = 231 ifTrue: [ ^tmp1 < 128 ifTrue: [ arg2 pushNewArrayOfSize: tmp1 ] ifFalse: [ arg2 pushConsArrayWithElements: tmp1 - 128 ] ].        arg1 = 232 ifTrue: [ ^arg2 pushConstant: (arg4 bitShift: 8) + tmp1 ].        ^arg2 pushConstant: (Character value: (arg4 bitShift: 8) + tmp1) ].  arg1 < 240 ifTrue: [ arg1 < 236 ifTrue: [ ^arg2 send: (tmp2 literalAt: (arg3 bitShift: 5) + (tmp1 // 8) + 1) super: arg1 = 235 numArgs: (arg4 bitShift: 3) + (tmp1 \\ 8) ].        arg1 = 236 ifTrue: [ ^arg2 trapIfNotInstanceOf: (tmp2 literalAt: (arg3 bitShift: 8) + tmp1 + 1) ].        arg1 = 237 ifTrue: [ ^arg2 jump: (arg4 bitShift: 8) + tmp1 ].        ^arg2 jump: (arg4 bitShift: 8) + tmp1 if: arg1 = 238 ].  arg1 < 243 ifTrue: [ arg1 = 240 ifTrue: [ ^arg2 popIntoReceiverVariable: (arg3 bitShift: 8) + tmp1 ].        arg1 = 241 ifTrue: [ ^arg2 popIntoLiteralVariable: (tmp2 literalAt: (arg3 bitShift: 8) + tmp1 + 1) ].        ^arg2 popIntoTemporaryVariable: tmp1 ].  arg1 = 243 ifTrue: [ ^arg2 storeIntoReceiverVariable: (arg3 bitShift: 8) + tmp1 ].  arg1 = 244 ifTrue: [ ^arg2 storeIntoLiteralVariable: (tmp2 literalAt: (arg3 bitShift: 8) + tmp1 + 1) ].  arg1 = 245 ifTrue: [ ^arg2 storeIntoTemporaryVariable: tmp1 ].  ^self unusedBytecode: arg2 at: arg5genPushThisContext  stream nextPut: 137veryBasicAt: arg1  < primitive: 'dooo' module: 'bar' error: code>  ^codewaitFor: arg1 maxMilliseconds: arg2  self checkOwnerProcess.  self waitInQueue: (self queueFor: arg1) maxMilliseconds: arg2browserPrintStringWith: arg1  | tmp1 |  tmp1 := (String new: 100) writeStream.  tmp1 nextPut: $(.  priority printOn: tmp1.  self isSuspended ifTrue: [ tmp1 nextPut: $s ].  tmp1 nextPutAll: ') '.  tmp1 nextPutAll: self name.  tmp1 nextPut: $:.  tmp1 space.  tmp1 nextPutAll: arg1 asString.  ^tmp1 contentstestDateTime  self assert: aDateAndTime equals: (DateAndTime date: '01-01-1970' asDate time: '00:00:00' asTime)printPaddedWith: arg1 to: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  #Numeric.  tmp1 := (String new: 10) writeStream.  self printOn: tmp1.  tmp2 := tmp1 contents.  tmp8 := tmp2 indexOf: $..  tmp7 := tmp8 - 1.  tmp6 := arg2 integerPart.  tmp7 < tmp6 ifTrue: [ tmp5 := (String new: (tmp6 - tmp7) asInteger)           atAllPut: arg1;           yourself ] ifFalse: [ tmp5 := '' ].  tmp7 := tmp2 size - tmp8.  tmp4 := (arg2 asString copyAfterLast: $.) ifNotEmpty: [:arg3 |  arg3 asInteger ] ifEmpty: [ 0 ].  tmp7 < tmp4 ifTrue: [ tmp3 := (String new: tmp4 - tmp7)           atAllPut: arg1;           yourself ] ifFalse: [ tmp3 := '' ].  ^tmp5 , tmp2 , tmp3isSelfEvaluating  ^self isLiteralhaltOnCount: arg1  < debuggerCompleteToSender>  Halt onCount: arg1setUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  DateAndTime localTimeZone: TimeZone default.  time := self timeClass fromSeconds: 14567.  aTime := Time readFrom: '12:34:56 pm' readStreaminspectorClass  ^EyeInspectortestPrint24On  self assert: (String streamContents: [:arg1 |  aTime print24: true on: arg1 ]) equals: '12:34:56'simpleEnsureTestWithErrorResults  ^OrderedCollection new     add: self doSomethingString;     add: 'Unhandled Exception';     add: self doYetAnotherThingString;     yourselftestMixedSignDigitLogic  self assert: (-2 bitAnd: 16rFFFFFFFF) equals: 16rFFFFFFFEarguments  ^argumentshash  | tmp1 |  tmp1 := self method hash bitXor: self selector hash.  1 to: self basicSize do: [:arg1 |  tmp1 := tmp1 bitXor: (self basicAt: arg1) hash ].  ^tmp1supportsClosureOpcodes  ^truerandomCodePointAtOrAbove: arg1  ^self randomCodePointBetween: arg1 and: Unicode maxValuetestIsTerminatingNormalTermination  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := Semaphore new.  tmp3 := false.  tmp4 := false.  tmp2 := [ tmp4 := true.  [ tmp1 wait ] ensure: [ tmp5 := Processor activeProcess.        tmp3 := true ] ] fork.  self deny: tmp2 isSuspended.  self deny: tmp2 isTerminating.  self deny: tmp2 isTerminated.  self deny: tmp4.  self deny: tmp3.  tmp1 signal.  self waitForProcessTermination: tmp2.  self assert: tmp2 isSuspended.  self assert: tmp2 isTerminating.  self assert: tmp2 isTerminated.  self assert: tmp4.  self assert: tmp3.  self assert: tmp5 identicalTo: tmp2asAlphaImageMorph  ^self asMorphhandleLGitReturnCode  ^selftestMilliSeconds  #(#(5 0 5000000) #(1005 1 5000000) #(-5 0 -5000000) #(-1005 -1 -5000000) #(1234567 1234 567000000) #(-1234567 -1234 -567000000)) do: [:arg1 |  | tmp1 |        tmp1 := Duration milliSeconds: arg1 first.        self assert: tmp1 asSeconds equals: arg1 second.        self assert: tmp1 nanoSeconds equals: arg1 third ]setUp  super setUp.  testClass := Object newAnonymousSubclass.  testSubclass := testClass newAnonymousSubclass.  testClass compile: self methodName , ' self deprecated: ''method is deprecated'''testNthRoot  self assert: ((-2 raisedTo: 35) / (3 raisedTo: 20) raisedTo: 1 / 5) equals: (-2 raisedTo: 7) / (3 raisedTo: 4).  self assert: (1 / (1 << 2000) raisedTo: 1 / 100) equals: 1 / (1 << 20)testIsModifierSymbol  self checkCorrespondanceOf: #isModifierSymbol: and: #SkuserInterruptPriority  ^UserInterruptPriorityexponent  < primitive: 53>  | tmp1 |  self >= 1.0 ifTrue: [ ^self floorLog: 2 ].  self > 0.0 ifTrue: [ tmp1 := (1.0 / self) exponent.        self = (1.0 / (1.0 timesTwoPower: tmp1)) ifTrue: [ ^tmp1 negated ] ifFalse: [ ^tmp1 negated - 1 ] ].  self = 0.0 ifTrue: [ ^-1 ].  ^self negated exponentisDead  ^falsecleanCopy  ^self shallowCopy     cleanOuterContext;     yourselfisResumable  ^falsetrialConcurrent: arg1 priority: arg2 maxDuration: arg3 fromSeed: arg4  | tmp1 |  tmp1 := self generateDelayProcesses: arg1 priority: arg2 maxDuration: arg3 fromSeed: arg4.  Running := false.  [ Running := true.  tmp1 do: [:arg5 |  arg5 resume ].  (Delay forSeconds: 1) wait ] ensure: [ Running := false ].  (Delay forSeconds: 1) wait.  tmp1 do: [:arg5 |  arg5 terminate ].  Smalltalk garbageCollect.  Smalltalk garbageCollect.  Smalltalk garbageCollectmethodClass  self subclassResponsibilityname  ^'a subclass of ' , self superclass nameat: arg1 put: arg2  < primitive: 61>  arg1 isInteger ifTrue: [ self class isVariable ifTrue: [ (arg1 between: 1 and: self size) ifFalse: [ ^self errorSubscriptBounds: arg1 ] ] ifFalse: [ ^self errorNotIndexable ] ] ifFalse: [ ^arg1 isNumber ifTrue: [ self at: arg1 asInteger put: arg2 ] ifFalse: [ self errorNonIntegerIndex ] ].  self isReadOnlyObject ifTrue: [ ^self modificationForbiddenFor: #at:put: index: arg1 value: arg2 ].  self errorImproperStoresin  < primitive: 556>  | tmp1 tmp2 tmp3 tmp4 |  self < 0.0 ifTrue: [ ^0.0 - (0.0 - self) sin ].  self > Twopi ifTrue: [ ^(self \\ Twopi) sin ].  self > Pi ifTrue: [ ^0.0 - (self - Pi) sin ].  self > Halfpi ifTrue: [ ^(Pi - self) sin ].  tmp1 := tmp2 := self.  tmp3 := 0.0 - (self * self).  tmp4 := 2.0.  [ tmp2 > Epsilon ] whileTrue: [ tmp2 := tmp2 * tmp3 / (tmp4 * (tmp4 + 1.0)).        tmp4 := tmp4 + 2.0.        tmp1 := tmp1 + tmp2.        tmp2 := tmp2 * tmp3 / (tmp4 * (tmp4 + 1.0)).        tmp4 := tmp4 + 2.0.        tmp1 := tmp1 + tmp2 ].  ^tmp1subclass: arg1 instanceVariableNames: arg2  ^self subclass: arg1 instanceVariableNames: arg2 classVariableNames: '' poolDictionaries: '' package: 'Unclassified'adaptToFraction: arg1 andSend: arg2  ^arg1 asFloat perform: arg2 with: selftestNew  self should: [ True new ] raise: self defaultTestErrorisLiteral  ^denominator = 1 or: [ (10 raisedTo: scale) \\ denominator = 0 ]to: arg1 by: arg2  ^Interval from: self to: arg1 by: arg2genCallMappedInlinedPrimitive: arg1  (arg1 < 0 or: [ arg1 > 255 ]) ifTrue: [ self outOfRangeError: 'primitive index' index: arg1 range: 1 to: 32767 ].  stream     nextPut: 236;     nextPut: arg1setSelector: arg1  selector := arg1genStoreInstVarLong: arg1  (arg1 >= 0 and: [ arg1 < 256 ]) ifTrue: [ stream           nextPut: 132;           nextPut: 160;           nextPut: arg1.        ^self ].  ^self outOfRangeError: 'index' index: arg1 range: 0 to: 255setArguments: arg1  self deprecated: 'Use #arguments: instead.' transformWith: '`@receiver setArguments: `@arg' -> '`@receiver arguments: `@arg'.  self arguments: arg1testReadTimeZoneOffsetRFC822WithOtherCharactersAfter  self assert: (DateAndTime readTimezoneOffsetFrom: '+0530 CommiterName' readStream) printString equals: '0:05:30:00'hash  ^start hash + duration hashisRGObject  ^false| arg1  ^arg1isDefinedInPackage: arg1  ^arg1 includesDefinedSelector: self selector ofClass: self methodClass~= arg1  < primitive: 48>  ^super ~= arg1signalAll: arg1  | tmp1 |  self checkOwnerProcess.  tmp1 := self queueFor: arg1.  self signalAllInQueue: self defaultQueue.  tmp1 ~~ self defaultQueue ifTrue: [ self signalAllInQueue: tmp1 ]respondsToUnknownBytecode  | tmp1 |  tmp1 := self method at: self pc.  self error: 'VM cannot run unknown bytecode ' , tmp1 printStringor: arg1  ^self~~ arg1  < primitive: 169>  self == arg1 ifTrue: [ ^false ] ifFalse: [ ^true ]hash  ^seconds bitXor: nanostestValueWithinNonLocalReturnFixReal  | tmp1 |  self valueWithinNonLocalReturn.  tmp1 := Time millisecondClockValue.  [ [  ] repeat ] valueWithin: 100 milliSeconds onTimeout: [ | tmp2 |        tmp2 := Time millisecondClockValue - tmp1.        self deny: tmp2 < 90 ]testOne  | tmp1 |  tmp1 := BenchmarkResult new.  tmp1 iterations: 1.  tmp1 elapsedTime: 1 second.  self deny: tmp1 isEmpty.  self assert: tmp1 iterations equals: 1.  self assert: tmp1 elapsedTime equals: 1 second.  self assert: tmp1 frequency equals: 1.  self assert: tmp1 executionsPerSecond equals: 1.  self assert: tmp1 period equals: 1 second.  self assert: tmp1 timePerExecution equals: 1 second.  self deny: tmp1 shortPrintString isEmpty.  self deny: tmp1 printString isEmptytestSimpleOuter  self assertSuccess: (ExceptionTester new runTest: #simpleOuterTest)instanceVariableNames: arg1  ^self slots: arg1 asSlotCollectionisFloat  ^truetestMiddleOf  self assert: (aDateAndTime middleOf: aDuration) equals: (Timespan starting: (DateAndTime year: 2004 month: 2 day: 29 hour: 6 minute: 46 second: 30 offset: 2 hours) duration: (Duration days: 0 hours: 13 minutes: 33 seconds: 0 nanoSeconds: 0))offset  ^self primOffset minutestestNew  | tmp1 |  tmp1 := Stopwatch new.  self     assert: tmp1 isSuspended;     assert: tmp1 state equals: #suspended;     deny: tmp1 isActive;     assertEmpty: tmp1 timespanshashMultiply  < primitive: 159>  ^(self bitAnd: 16rFFFFFFF) hashMultiplycalledArgumentsCount: arg1  calledArgumentsCount := arg1terminateProcess  self isEmpty ifFalse: [ self removeFirst terminate ]removeKey: arg1 ifAbsent: arg2  1 to: self basicSize do: [:arg3 |  | tmp1 |        tmp1 := self basicAt: arg3.        (tmp1 isVariableBinding ifTrue: [ tmp1 key ] ifFalse: [ tmp1 selector ]) == arg1 ifTrue: [ ^method removeProperty: arg1 ] ].  ^arg2 valuetestCurrent  self deny: aDateAndTime equals: DateAndTime currentallSuperclassesDo: arg1  self superclass == nil ifFalse: [ arg1 value: self superclass.        self superclass allSuperclassesDo: arg1 ]primitiveFailed: arg1  PrimitiveFailed signalFor: arg1rearmOneShot  self class environment at: #OneShotArmed put: trueisArray  ^falseinitializeTicker: arg1 suspendedDelaysHeap: arg2  ticker := arg1.  suspendedDelays := arg2.  timingSemaphore := Semaphore new.  debug := falseprintStringBase: arg1  ^String streamContents: [:arg2 |  self printOn: arg2 base: arg1 ]check: arg1 forDeprecationIn: arg2  ^(Smalltalk globals at: arg2 ifAbsent: [ ^false ]) class classAndMethodFor: arg1 do: [:arg3 :arg4 |  arg4 isDeprecated ] ifAbsent: [ false ]testCull  [  ] cull: 1.  [:arg1 |   ] cull: 1.  self should: [ [:arg1 :arg2 |   ] cull: 1 ] raise: Error.  self should: [ [:arg1 :arg2 :arg3 |   ] cull: 1 ] raise: Error.  self should: [ [:arg1 :arg2 :arg3 :arg4 |   ] cull: 1 ] raise: Error.  self should: [ [:arg1 :arg2 :arg3 :arg4 :arg5 |   ] cull: 1 ] raise: Error.  self assert: ([ 0 ] cull: 1) equals: 0.  self assert: ([:arg1 |  arg1 ] cull: 1) equals: 1ffiCall: arg1 options: arg2  < ffiCalloutTranslator>  self ffiCall: arg1 library: self ffiLibrary libraryName options: arg2sizeReturnSpecialLiteral: arg1  ^self sizeOpcodeSelector: #genReturnSpecialLiteral: withArguments: {arg1}canBeRenamed  ^trueobjectClass: arg1  < primitive: 111>  self primitiveFailedhhmm24  ^String new: 4 streamContents: [:arg1 |  self hour printOn: arg1 base: 10 length: 2 padded: true.        self minute printOn: arg1 base: 10 length: 2 padded: true ]whichSelectorsReferTo: arg1  ^(self whichMethodsReferTo: arg1) collect: [:arg2 |  arg2 selector ]+ arg1  < primitive: 21>  ^super + arg1interpretJumpIfCond  ^self method encoderClass interpretJumpIfCondIn: selfdayOfWeekAbbreviation  ^self dayOfWeekName copyFrom: 1 to: 3tryNamedPrimitiveIn: arg1 for: arg2 withArgs: arg3  < primitive: 218 error: errorCode>  errorCode ifNotNil: [ errorCode isInteger ifTrue: [ errorCode = -1 ifTrue: [ errorCode := nil ] ifFalse: [ self primitiveFailed ] ].        ^self class primitiveFailTokenFor: errorCode ].  ^self withoutPrimitiveTryNamedPrimitiveIn: arg1 for: arg2 withArgs: arg3isHandlerContext  ^self isHandlerOrSignalingContext and: [ self selector == #on:do: ]tags  | tmp1 |  tmp1 := self package classTagForClass: self.  tmp1 ifNil: [ ^#() ].  tmp1 isRoot ifTrue: [ ^#() ].  ^{tmp1 name}slotNamed: arg1 ifFound: arg2 ifNone: arg3  ^self classLayout resolveSlot: arg1 asSymbol ifFound: arg2 ifNone: arg3selectorsInCategory: arg1  | tmp1 |  tmp1 := Set withAll: (self organization listAtCategoryNamed: arg1).  ^tmp1 asArray sortsourceCode  ^self outerCode sourceCodevar1: arg1  var1 := arg1testWaitMaxMilliseconds  | tmp1 |  tmp1 := Monitor new.  tmp1 critical: [ tmp1 waitMaxMilliseconds: 10 ]withWidth: arg1  ^origin corner: (origin x + arg1) @ corner yreceiver: arg1  receiver := arg1doOnlyOnce: arg1  (self class environment at: #OneShotArmed ifAbsent: [ true ]) ifTrue: [ self class environment at: #OneShotArmed put: false.        arg1 value ]fuelNew: arg1  ^self basicNew: arg1testBecome  | tmp1 tmp2 tmp3 |  tmp1 := 0 @ 0.  tmp2 := tmp1.  tmp3 := 100 @ 100.  tmp1 become: tmp3.  self assert: tmp2 equals: 100 @ 100.  self assert: tmp3 equals: 0 @ 0.  self assert: tmp1 equals: 100 @ 100initialize  super initialize.  terminating := falsetestTommorrow  self assert: DateAndTime today + 24 hours equals: DateAndTime tomorrow.  self deny: aDateAndTime equals: DateAndTime tomorrowtimeStamp  ^SourceFiles timeStampAt: self sourcePointerasNanoSeconds  ^self asDuration asNanoSecondsthoroughWhichSelectorsReferTo: arg1  ^(self thoroughWhichMethodsReferTo: arg1) collect: [:arg2 |  arg2 selector ]testIsFormatOther  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isFormatOther: tmp2) equals: (tmp1 isFormatOther: tmp2) ]allUnreferencedInstanceVariables  ^self allSlots reject: [:arg1 |  arg1 isReferenced ]actionsDo: arg1  self actionMap do: arg1hasLiteral: arg1  ^self selector == arg1 or: [ arguments hasLiteral: arg1 ]testReturn  aMethodContext := Context sender: thisContext receiver: aReceiver method: aCompiledMethod arguments: #().  self assert: (aMethodContext return: 5) equals: 5testReadsSlot  ({(Point >> #x) .   (Point >> #setX:setY:)} allSatisfy: #hasSourceCode) ifFalse: [ ^self ].  self assert: (Point >> #x readsSlot: (Point slotNamed: #x)).  self deny: (Point >> #x readsSlot: (Point slotNamed: #y)).  self deny: (Point >> #setX:setY: readsSlot: (Point slotNamed: #y))tearDown  DateAndTime localTimeZone: localTimeZoneToRestore.  timespan := nil.  super tearDownor: arg1  self subclassResponsibilitytestInstanceCreation  | tmp1 tmp2 |  tmp1 := Month starting: '4 July 1998' asDate.  tmp2 := Month year: 1998 month: #July.  self     assert: month equals: tmp1;     assert: month equals: tmp2phlowValue: arg1  ^arg1veryDeepCopyWith: arg1  isSuspended  ^self state = #suspendedisTaggedWith: arg1  ^self protocol == arg1classCommentBlank  | tmp1 |  tmp1 := (String new: 100) writeStream.  tmp1 nextPutAll: 'Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.'.  self instVarNames size > 0 ifTrue: [ tmp1           cr;           cr;           nextPutAll: '    Instance Variables' ].  self instVarNames asSortedCollection do: [:arg1 |  tmp1           cr;           tab;           nextPutAll: arg1;           nextPut: $:;           tab;           tab;           nextPutAll: '<Object>' ].  tmp1 cr.  tmp1     cr;     cr;     nextPutAll: '    Implementation Points'.  ^tmp1 contentscontrol  ^KMModifier control + selfrfPlus: arg1  < metaLinkOptions: #(+ optionDisabledLink)>  < primitive: 1>  ^super + arg1browseHierarchy  self systemNavigation browseHierarchy: selfhasDynamicItems  ^self numArgs ~= 0sourcePointer  ^self trailer sourcePointergenSignedSingleExtendB: arg1  (arg1 between: -128 and: 127) ifFalse: [ ^self outOfRangeError: 'index' index: arg1 range: -128 to: 127 ].  stream     nextPut: 225;     nextPut: (arg1 >= 0 ifTrue: [ arg1 ] ifFalse: [ arg1 + 256 ])testCurrent  self assert: (Timespan starting: DateAndTime current) <= Timespan current.  self assert: Timespan current <= (Timespan starting: DateAndTime current)testAccessesSlot  ({(Point >> #x) .   (Point >> #setX:setY:)} allSatisfy: #hasSourceCode) ifFalse: [ ^self ].  self assert: (Point >> #x accessesSlot: (Point slotNamed: #x)).  self deny: (Point >> #x accessesSlot: (Point slotNamed: #y)).  self assert: (Point >> #setX:setY: accessesSlot: (Point slotNamed: #y))waitWhile: arg1 for: arg2 maxMilliseconds: arg3  self checkOwnerProcess.  self waitWhile: arg1 inQueue: (self queueFor: arg2) maxMilliseconds: arg3squared  ^self * selfremoveActionsSatisfying: arg1 forEvent: arg2  self setActionSequence: ((self actionSequenceForEvent: arg2) reject: [:arg3 |  arg1 value: arg3 ]) forEvent: arg2storeBinaryOn: arg1  self asInteger < 256 ifTrue: [ arg1 basicNextPut: self asInteger ] ifFalse: [ arg1 nextInt32Put: self asInteger ]popIntoLiteralVariable: arg1  arg1 value: self popasIntegerPoint  self isIntegerPoint ifTrue: [ ^self ].  ^x asInteger @ y asIntegercurrentEvent  ^ActiveEvent ifNil: [ self currentHand lastEvent ]classToBeTested  ^ScheduleisFraction  ^truetestHandlingWithSeveralExclusions  | tmp1 |  tmp1 := false.  self should: [ [ ZeroDivide signalWithDividend: 1 ] on: Error - Warning - ZeroDivide do: [:arg1 |  tmp1 := true.              arg1 return ] ] raise: ZeroDivide.  self deny: tmp1.  self should: [ [ ZeroDivide signalWithDividend: 1 ] on: Error - (Warning , ZeroDivide) do: [:arg1 |  tmp1 := true.              arg1 return ] ] raise: ZeroDivide.  self deny: tmp1result  ^resultvalue: arg1 value: arg2 value: arg3  | tmp1 |  tmp1 := self receiver.  (self ensureReceiver: tmp1) ifFalse: [ ^nil ].  ^tmp1 perform: selector with: arg1 with: arg2 with: arg3testConvertFromNonDecimalFraction  | tmp1 |  tmp1 := (1 / 3) asScaledDecimal scale.  #(6 7 9 11 12 13 14 17 18 19 21 22 23 24) do: [:arg1 |  | tmp2 tmp3 |        tmp2 := (1 / arg1) asScaledDecimal.        self assert: tmp2 scale equals: tmp1.        tmp3 := ScaledDecimal readFrom: tmp2 printString.        self deny: tmp2 equals: tmp3 ]testAsDuration  self assert: aDuration asDuration equals: aDuration< arg1  ^self start < arg1printOn: arg1 base: arg2  self printOn: arg1 base: arg2 length: 0 padded: falseselectSuperclasses: arg1  | tmp1 |  tmp1 := Set new.  self allSuperclasses do: [:arg2 |  (arg1 value: arg2) ifTrue: [ tmp1 add: arg2 ] ].  ^tmp1kindOfSubclass  ^self isVariable ifTrue: [ self isBits ifTrue: [ self isBytes ifTrue: [ ' variableByteSubclass: ' ] ifFalse: [ ' variableWordSubclass: ' ] ] ifFalse: [ self isWeak ifTrue: [ ' weakSubclass: ' ] ifFalse: [ ' variableSubclass: ' ] ] ] ifFalse: [ self isImmediateClass ifTrue: [ ' immediateSubclass: ' ] ifFalse: [ self isEphemeronClass ifTrue: [ ' ephemeronSubclass: ' ] ifFalse: [ ' subclass: ' ] ] ]fuelReplacement  ^selfforPoint: arg1 closestSideDistLen: arg2  | tmp1 |  tmp1 := self sideNearestTo: arg1.  tmp1 == #right ifTrue: [ ^arg2 value: tmp1 value: (self right - arg1 x) abs value: ((arg1 y between: self top and: self bottom) ifTrue: [ self height ] ifFalse: [ 0 ]) ].  tmp1 == #left ifTrue: [ ^arg2 value: tmp1 value: (self left - arg1 x) abs value: ((arg1 y between: self top and: self bottom) ifTrue: [ self height ] ifFalse: [ 0 ]) ].  tmp1 == #bottom ifTrue: [ ^arg2 value: tmp1 value: (self bottom - arg1 y) abs value: ((arg1 x between: self left and: self right) ifTrue: [ self width ] ifFalse: [ 0 ]) ].  tmp1 == #top ifTrue: [ ^arg2 value: tmp1 value: (self top - arg1 y) abs value: ((arg1 x between: self left and: self right) ifTrue: [ self width ] ifFalse: [ 0 ]) ]testDependencies  self assert: (ClassTest dependentClasses includes: ClassTest superclass).  self assert: (ClassTest dependentClasses includes: Date)testExample1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp4 := (1 to: 1000) asOrderedCollection.  tmp5 := OrderedCollection new.  tmp6 := 0.  tmp7 := false.  tmp8 := Semaphore new.  tmp3 := Monitor new.  tmp1 := [ [ tmp3 critical: [ tmp3 waitUntil: [ tmp6 \\ 5 = 0 ].        tmp7 or: [ tmp5 add: (tmp6 := tmp6 + 1) ].        tmp7 := tmp6 >= tmp4 size.        tmp3 signal ].  tmp7 ] whileFalse.  tmp8 signal ].  tmp2 := [ [ tmp3 critical: [ tmp3 waitWhile: [ tmp6 \\ 5 = 0 ].        tmp7 or: [ tmp5 add: (tmp6 := tmp6 + 1) ].        tmp7 := tmp6 >= tmp4 size.        tmp3 signal ].  tmp7 ] whileFalse.  tmp8 signal ].  tmp1 forkAt: Processor userBackgroundPriority.  tmp2 forkAt: Processor userBackgroundPriority.  tmp8     wait;     wait.  self assert: tmp4 equals: tmp5testReadFrom  self assert: 1.0e-14 equals: (Number readFrom: '1.0e-14').  self assert: 16r4000000 equals: (Number readFrom: '2r1e26').  self should: [ Number readFrom: 'foo' ] raise: ErrorwhichSelectorsStoreInto: arg1  ^self slotNamed: arg1 ifFound: [:arg2 |  self selectors select: [:arg3 |  arg2 isWrittenIn: self >> arg3 ] ] ifNone: [ #() ]testclassVariables  self assert: Object classVariables first name equals: #DependentsFields.  self assert: Object classVariables equals: Object class classVariablesproperties  ^self subclassResponsibilityrounded  allProtocolsNames  ^self allProtocols collect: #namebasicInspect  ^Smalltalk tools basicInspector inspect: selfsubclassesDo: arg1  self subclasses do: arg1myDependents  ^DependentsFields at: self ifAbsent: [  ]testStartDay  Week startDay: 'Wednesday'.  self assert: Week startDay equals: 'Wednesday'.  Week startDay: 'Thursday'.  self assert: Week startDay equals: 'Thursday'+ arg1  | tmp1 tmp2 tmp3 tmp4 |  arg1 isInteger ifTrue: [ ^Fraction numerator: numerator + (denominator * arg1) denominator: denominator ].  arg1 isFraction ifTrue: [ tmp2 := denominator gcd: arg1 denominator.        tmp1 := numerator * (tmp3 := arg1 denominator // tmp2) + (arg1 numerator * (tmp4 := denominator // tmp2)).        tmp3 := tmp3 * tmp4.        tmp1 := tmp1 // (tmp4 := tmp1 gcd: tmp2).        (tmp2 := tmp3 * (tmp2 // tmp4)) = 1 ifTrue: [ ^tmp1 ].        ^Fraction numerator: tmp1 denominator: tmp2 ].  ^arg1 adaptToFraction: self andSend: #+testAsDateAndTime  self assert: aDateAndTime asDateAndTime equals: aDateAndTimetestOneMBAllocation  | tmp1 tmp2 tmp3 |  tmp3 := false.  tmp1 := 1024 * 1024.  tmp2 := [ ByteArray new: tmp1 ] on: OutOfMemory do: [:arg1 |  tmp3 := true ].  self assert: (tmp3 or: [ tmp2 size = tmp1 ])testFractionAsFloat2  self assert: ((1 << 52) + 0 + (1 / 4)) asFloat asTrueFraction equals: (1 << 52) + 0.  self assert: ((1 << 52) + 0 + (1 / 2)) asFloat asTrueFraction equals: (1 << 52) + 0.  self assert: ((1 << 52) + 0 + (3 / 4)) asFloat asTrueFraction equals: (1 << 52) + 1.  self assert: ((1 << 52) + 1 + (1 / 4)) asFloat asTrueFraction equals: (1 << 52) + 1.  self assert: ((1 << 52) + 1 + (1 / 2)) asFloat asTrueFraction equals: (1 << 52) + 2.  self assert: ((1 << 52) + 1 + (3 / 4)) asFloat asTrueFraction equals: (1 << 52) + 2testYearDayHourMinuteSecond  self assert: aDateAndTime equals: (DateAndTime year: 1901 day: 1 hour: 0 minute: 0 second: 0)exception  ^exception* arg1  self subclassResponsibility= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  self size = arg1 size ifFalse: [ ^false ].  self header = arg1 header ifFalse: [ ^false ].  self initialPC to: self endPC do: [:arg2 |  (self at: arg2) = (arg1 at: arg2) ifFalse: [ ^false ] ].  (self sameLiteralsAs: arg1) ifFalse: [ ^false ].  ^truetestTempNamed  | tmp1 tmp2 |  tmp1 := 1.  self assert: (thisContext tempNamed: 'oneTemp') equals: tmp1.  tmp2 := self class contextWithTempForTesting.  self assert: (tmp2 tempNamed: 'string') equals: 'test'outerContext  ^outerContextsameAs: arg1  ^self asLowercase = arg1 asLowercasetestNonResumablePass  self should: [ [ Error signal.        4 ] on: Error do: [:arg1 |  arg1 pass.              arg1 return: 5 ] ] raise: ErrorstepToHome: arg1  | tmp1 tmp2 tmp3 |  tmp1 := suspendedContext.  suspendedContext := nil.  tmp2 := Processor activeProcess evaluate: [ tmp1 stepToHome: arg1 ] onBehalfOf: self.  suspendedContext := tmp2 first.  tmp3 := tmp2 second.  tmp3 ifNotNil: [ ^suspendedContext := tmp3 signalerContext ].  ^suspendedContextisEmpty  ^self methodSelectors isEmptytestAsTime  self assert: aDateAndTime asTime equals: Time midnightisClassSide  ^self == self classSideabstractBytecodeMessagesDo: arg1  self abstractBytecodeMessagesFrom: self initialPC to: self endPC do: arg1state  ^state ifNil: [ state := #suspended ]isVirtualProtocol  ^falsesign  ^x sign @ y signpackageOrganizer  ^RPackage organizerisBytes  ^self instSpec >= 16subclassResponsibility  SubclassResponsibility signalFor: thisContext sender selectorasEmailTimeOffsetString  ^String streamContents: [:arg1 |  arg1           nextPut: (self positive ifTrue: [ $+ ] ifFalse: [ $- ]);           nextPutAll: self hours abs asTwoCharacterString;           nextPutAll: self minutes asTwoCharacterString ]instanceVariableReadNodes  ^self ast instanceVariableReadNodesnew  ^self basicNew initializetestSubtractDays  self assert: (january23rd2004 subtractDays: 0) equals: '2004-01-23' asDate.  self assert: (january23rd2004 subtractDays: 30) equals: '2003-12-24' asDatetestComparing  | tmp1 tmp2 tmp3 |  tmp1 := self timeClass fromSeconds: 14567.  tmp2 := self timeClass fromSeconds: 5000.  tmp3 := self timeClass fromSeconds: 80000.  self     assert: time equals: tmp1;     assert: time hash equals: tmp1 hash;     assert: time equals: time copy.  self     deny: tmp1 < tmp2;     assert: tmp1 < tmp3serialiseOn: arg1  arg1 nextPut: self.  1 to: self class instSize do: [:arg2 |  arg1 nextPut: (self instVarAt: arg2) ].  1 to: self localSize do: [:arg2 |  arg1 nextPut: (self localAt: arg2) ]testBitString  Smalltalk vm wordSize = 4 ifTrue: [ self assert: 2 bitString equals: '0000000000000000000000000000010'.        self assert: -1 bitString equals: '1111111111111111111111111111111'.        self assert: -2 bitString equals: '1111111111111111111111111111110'.        self assert: 2 bitStringLength equals: 31 ].  Smalltalk vm wordSize = 8 ifTrue: [ self assert: 2 bitString equals: '0000000000000000000000000000000000000000000000000000000000010'.        self assert: -1 bitString equals: '1111111111111111111111111111111111111111111111111111111111111'.        self assert: -2 bitString equals: '1111111111111111111111111111111111111111111111111111111111110'.        self assert: 2 bitStringLength equals: 61 ].  self assert: 2 bitStringLength equals: SmallInteger maxVal highBit + 1useTimeZone: arg1 during: arg2  | tmp1 |  tmp1 := TimeZone abbreviated: arg1.  self restoreLocalTimeZoneAfter: [ DateAndTime localTimeZone: tmp1.        arg2 cull: tmp1 ]testFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1980-01-01T00:00:00+00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1980-01-01T00:00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1980-01-01T00:00').  self assert: aDateAndTime equals: (DateAndTime fromString: ' 1980-01-01T00:00:00+00:00')subclass: arg1 uses: arg2 layout: arg3 slots: arg4 classVariablesNames: arg5 poolDictionaries: arg6 package: arg7  ^self classInstaller make: [:arg8 |  arg8           name: arg1;           superclass: self;           slots: arg4;           layoutClass: arg3;           sharedVariablesFromString: arg5;           sharedPools: arg6;           traitComposition: arg2 asTraitComposition;           classTraitComposition: arg2 asTraitComposition classComposition;           category: arg7 ]hour12  ^(self hour24 - 1) \\ 12 + 1left  ^leftshallowCopy  < primitive: 148>  | tmp1 tmp2 tmp3 |  tmp1 := self class.  tmp1 isVariable ifTrue: [ tmp3 := self basicSize.        tmp2 := tmp1 basicNew: tmp3.        [ tmp3 > 0 ] whileTrue: [ tmp2 basicAt: tmp3 put: (self basicAt: tmp3).              tmp3 := tmp3 - 1 ] ] ifFalse: [ tmp2 := tmp1 basicNew ].  tmp3 := tmp1 instSize.  [ tmp3 > 0 ] whileTrue: [ tmp2 instVarAt: tmp3 put: (self instVarAt: tmp3).        tmp3 := tmp3 - 1 ].  ^tmp2adaptToInteger: arg1 andSend: arg2  ^self adaptToNumber: arg1 andSend: arg2definitionForSpotter  | tmp1 |  tmp1 := WriteStream on: String new.  tmp1 nextPutAll: self definition.  tmp1     cr;     cr.  tmp1 nextPut: $".  tmp1 nextPutAll: 'Hierarchy: '.  tmp1 nextPutAll: ($> join: self allSuperclasses reversed).  tmp1     cr;     cr.  self hasComment ifTrue: [ tmp1 nextPutAll: self comment ].  tmp1 nextPut: $".  ^tmp1 contentsnot  self subclassResponsibilityprintString  ^self printStringBase: 10unscheduleAtTimingPriority  delayToStop beingWaitedOn ifFalse: [ ^self ].  activeDelay == delayToStop ifTrue: [ activeDelay := suspendedDelays removeFirstOrNil ] ifFalse: [ suspendedDelays remove: delayToStop ifAbsent: [  ] ].  delayToStop timingPriorityUnschedule.  delayToStop := nilmillisecondsUntilTick: arg1  ^(arg1 - self nowTick max: 0) / 1000seconds: arg1 nanoSeconds: arg2  seconds := arg1.  nanos := arg2 rounded.  [ nanos < 0 and: [ seconds > 0 ] ] whileTrue: [ seconds := seconds - 1.        nanos := nanos + NanosInSecond ].  [ seconds < 0 and: [ nanos > 0 ] ] whileTrue: [ seconds := seconds + 1.        nanos := nanos - NanosInSecond ]year  ^self yearsnegative  ^self positive notx92kbits  ^(11 to: 51 by: 4) inject: 1357924680 into: [:arg1 :arg2 |  (arg1 * arg1 << arg2) + arg2 ]testOneGWordAllocation  | tmp1 tmp2 tmp3 |  self timeLimit: 1 minute.  tmp3 := false.  tmp1 := 1024 * 1024 * 1024.  tmp2 := [ Array new: tmp1 ] on: OutOfMemory do: [:arg1 |  tmp3 := true ].  self assert: (tmp3 or: [ tmp2 size = tmp1 ])shortDebugStackOn: arg1  ^self debugStack: 30 on: arg1testReadFromSecond  self assert: '-1199-01-05T20:33:14.321-05:00' asDateAndTime printString equals: '-1199-01-05T20:33:14.321-05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: ' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: ' 2002-05-16T17:20' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:00+00:00'.  self assert: '2002-05-16T17:20:45' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:45+00:00'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime printString equals: '2002-05-16T17:20:45-02:34'.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime printString equals: '2002-05-16T17:20:45+00:00'.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime printString equals: '1997-04-26T01:02:03+01:02:3'subclass: arg1 layout: arg2 slots: arg3 classVariables: arg4 package: arg5  ^self subclass: arg1 layout: arg2 slots: arg3 classVariables: arg4 poolDictionaries: '' package: arg5octantOf: arg1  | tmp1 tmp2 |  (x = arg1 x and: [ y > arg1 y ]) ifTrue: [ ^6 ].  (y = arg1 y and: [ x < arg1 x ]) ifTrue: [ ^8 ].  tmp1 := self quadrantOf: arg1.  tmp2 := (x - arg1 x) abs >= (y - arg1 y) abs.  ^(tmp1 even eqv: tmp2) ifTrue: [ tmp1 * 2 ] ifFalse: [ tmp1 * 2 - 1 ]referencedClasses  ^self literals select: [:arg1 |  arg1 value isClass ] thenCollect: [:arg2 |  arg2 value ]selector  ^selectortestObjects  self assert: 10 isSelfEvaluating.  self assert: $a isSelfEvaluating.  self assert: 3.14157 isSelfEvaluating.  self assert: #(1 2 3) isSelfEvaluating.  self assert: #abc isSelfEvaluating.  self assert: 'abc' isSelfEvaluating.  self assert: Object isSelfEvaluating.  self assert: Object new isSelfEvaluating not.  self assert: {Float infinity .         Float nan .         Float infinity negated} isSelfEvaluating.  self assert: (Array with: 10) isSelfEvaluating.  self assert: (Array with: Object new) isSelfEvaluating not.  self assert: true isSelfEvaluating.  self assert: false isSelfEvaluating.  self assert: nil isSelfEvaluating.  self assert: (1 to: 10) isSelfEvaluating.  self assert: (1 -> 2) isSelfEvaluating.  self assert: Color red isSelfEvaluatingselectorsAndMethodsDo: arg1  ^self methodDict keysAndValuesDo: arg1testDayOfYear  self assert: aDateAndTime dayOfYear equals: 1testDoWithWhen  | tmp1 |  tmp1 := 0.  aTimespan do: [:arg1 |  tmp1 := tmp1 + 1 ] with: (Timespan starting: jan01 duration: aDay) when: [:arg1 |  tmp1 < 5 ].  self assert: tmp1 equals: 5doesMethod: arg1 writeAllInstanceVariablesOfClass: arg2  | tmp1 tmp2 tmp3 |  tmp3 := arg2 instSize = 0.  tmp1 := arg2 instSize.  tmp2 := arg2 compiledMethodAt: arg1.  ^tmp3 or: [ tmp2 writesField: tmp1 ]postCopy  super postCopy.  self classLayout: (layout copy host: self).  thisClass := nilfuelAccept: arg1  ^arg1 visitPoint: selfbench  | tmp1 tmp2 tmp3 |  tmp1 := #(42).  tmp2 := #(1000 2000 3000 4000 5000 6000 7000 8000 9000 10000).  tmp3 := Semaphore new.  self crTrace: String cr , 'Benchmarking ' , Delay delaySchedulerClass printString.  [ tmp2 do: [:arg1 |  self crTrace: '#ConcurrentDelays: ' , arg1 printString , String space.        EnterCount := ExitCount := 0.        tmp1 do: [:arg2 |  self trace: '.'.              self trialConcurrent: arg1 priority: Processor userSchedulingPriority + 1 maxDuration: 50 fromSeed: arg2 ].        self trace: String space.        self trace: 'EnterCount: ' , (EnterCount // tmp1 size) printString , String space.        self trace: 'ExitCount: ' , (ExitCount // tmp1 size) printString.        self currentWorld doOneCycle ].  tmp3 signal ] forkAt: Processor userSchedulingPriority + 2.  tmp3 waititerationsBeforeTimeout  ^iterationsBeforeTimeoutcopyCategory: arg1 from: arg2  self copyCategory: arg1 from: arg2 classified: arg1setUp  super setUp.  localTimeZoneToRestore := DateAndTime localTimeZone.  DateAndTime localTimeZone: TimeZone default.  timespan := Timespan starting: (DateAndTime year: 2003 month: 03 day: 22 hour: 12 minute: 0 second: 0) duration: (Duration hours: 100).  dec31 := DateAndTime year: 2004 month: 12 day: 31 hour: 0 minute: 0 second: 0.  jan01 := DateAndTime year: 2005 month: 1 day: 1 hour: 0 minute: 0 second: 0.  jan08 := DateAndTime year: 2005 month: 1 day: 8 hour: 0 minute: 0 second: 0.  aDay := Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.  aWeek := Duration days: 7 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0.  aTimespan := Timespan starting: jan01 duration: aWeek.  anOverlappingTimespan := Timespan starting: dec31 duration: aWeek.  anIncludedTimespan := Timespan starting: jan01 duration: aDay.  aDisjointTimespan := Timespan starting: jan08 duration: aWeekto: arg1 sideOf: arg2  ^arg1 - self sideOf: arg2 - selftestYearDay  self assert: aDateAndTime equals: (DateAndTime year: 1901 day: 1)superclass: arg1 methodDictionary: arg2 format: arg3  super superclass: arg1 methodDictionary: arg2 format: arg3.  self subclasses: nilpropertyValueAt: arg1 ifAbsent: arg2  ^self propertyAt: arg1 ifAbsent: arg2denominator  ^denominatorsunitAnnounce: arg1 toResult: arg2  arg2 addError: arg1brickValue: arg1  ^self cull: arg1remove: arg1 oneStar: arg2  | tmp1 tmp2 |  tmp2 := #absent.  tmp1 := self callcc: [:arg3 |  self remove: arg1 oneStar: arg2 sentinel: tmp2 continuation: arg3 ].  ^tmp1 = tmp2 ifTrue: [ arg2 ] ifFalse: [ tmp1 ]topLeft  ^originsubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4  ^self subclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 poolDictionaries: '' package: arg4userSchedulingPriority  ^UserSchedulingPriorityx13kbits  ^(15 to: 44 by: 4) inject: 9753102468 into: [:arg1 :arg2 |  (arg1 * arg1 << arg2) + arg2 ]intersection: arg1  | tmp1 tmp2 |  tmp1 := self start max: arg1 start.  tmp2 := self start + self duration min: arg1 start + arg1 duration.  tmp2 <= tmp1 ifTrue: [ ^nil ].  ^self species starting: tmp1 ending: tmp2< arg1  | tmp1 |  tmp1 := arg1 asDateAndTime.  ^julianDayNumber = tmp1 julianDayNumberUTC ifTrue: [ seconds = tmp1 secondsSinceMidnightUTC ifTrue: [ nanos < tmp1 nanoSecond ] ifFalse: [ seconds < tmp1 secondsSinceMidnightUTC ] ] ifFalse: [ julianDayNumber < tmp1 julianDayNumberUTC ]adjustTo: arg1 along: arg2  arg2 = #left ifTrue: [ ^self withRight: arg1 left ].  arg2 = #right ifTrue: [ ^self withLeft: arg1 right ].  arg2 = #top ifTrue: [ ^self withBottom: arg1 top ].  arg2 = #bottom ifTrue: [ ^self withTop: arg1 bottom ]log: arg1  ^self ln / arg1 lnbinaryLiteralString  ^String streamContents: [:arg1 |  self printBinaryLiteralOn: arg1 ]containsRect: arg1  ^arg1 origin >= origin and: [ arg1 corner <= corner ]forkNamed: arg1  ^self newProcess     name: arg1;     resumestonOn: arg1  arg1 writeInteger: selffirstByte  ^self method at: pclocalSelectors  ^methodDict keyspointerDouble  ^(ByteArray new: FFIFloat64 externalTypeSize)     doubleAt: 1 put: self;     yourselftimingPriority  ^TimingPriorityclosureCopy: arg1 copiedValues: arg2  < primitive: 200>  ^BlockClosure outerContext: self startpc: pc + 2 numArgs: arg1 copiedValues: arg2testNormalizeNanoSeconds  | tmp1 tmp2 tmp3 |  tmp2 := '2004-01-07T11:55:01+00:00' asDateAndTime.  tmp3 := '2004-01-07T11:55:00.9+00:00' asDateAndTime.  tmp1 := tmp2 - tmp3.  self assert: tmp1 nanoSeconds > 0.  self assert: tmp1 seconds equals: 0.  self assert: tmp1 nanoSeconds equals: 100000000.  self assert: tmp1 asString equals: '0:00:00:00.1'.  self assert: (Duration seconds: 1 nanoSeconds: 100000000) printString equals: '0:00:00:01.1'.  self assert: (Duration seconds: -1 nanoSeconds: -100000000) printString equals: '-0:00:00:01.1'.  self assert: (Duration seconds: 1 nanoSeconds: -100000000) printString equals: '0:00:00:00.9'.  self assert: (Duration seconds: -1 nanoSeconds: 100000000) printString equals: '-0:00:00:00.9'gtInspectorIrIn: arg1  < gtInspectorPresentationOrder: 35>  arg1 text     title: 'Ir';     display: [:arg2 |  | tmp1 |        tmp1 := arg2 ir longPrintString.        tmp1 copyFrom: 2 to: tmp1 size ]bitInvert  ^-1 - selfname: arg1  self error: 'You cannot change my name'willSend  ^self method encoderClass isSendAt: pc in: self methodisResumable  ^truegtDebuggerPresentationsIn: arg1 inContext: arg2  | tmp1 |  tmp1 := (Pragma allNamed: #gtDebuggerPresentationOrder: from: self class to: ProtoObject) asOrderedCollection.  tmp1 addAll: ((Pragma allNamed: arg2 class extensionsPragma from: self class to: ProtoObject) reject: [:arg3 |  arg3 method selector = #gtInspectorRawIn: ]).  tmp1 := tmp1 sorted: [:arg4 :arg5 |  (arg4 argumentAt: 1) < (arg5 argumentAt: 1) ].  self gtInspectorPresentationsFromPragmas: tmp1 In: arg1 inContext: arg2genSendDirectedSuper: arg1 numArgs: arg2  | tmp1 |  (arg1 < 0 or: [ arg1 > 65535 ]) ifTrue: [ ^self outOfRangeError: 'selectorLiteralIndex' index: arg1 range: 0 to: 65535 ].  (arg2 < 0 or: [ arg2 > 31 ]) ifTrue: [ ^self outOfRangeError: 'numArgs' index: arg2 range: 0 to: 31 ].  (tmp1 := arg1) > 31 ifTrue: [ self genUnsignedSingleExtendA: tmp1 // 32.        tmp1 := tmp1 \\ 32 ].  self genUnsignedSingleExtendB: arg2 // 8 + 64.  stream     nextPut: 235;     nextPut: arg2 \\ 8 + (tmp1 * 8)reflectedAbout: arg1  ^(self - arg1) negated + arg1arcCos  ^self asFloat arcCosreceiver  ^outerContext receiverinstanceVariableReadNodes  ^self methods flatCollect: [:arg1 |  arg1 instanceVariableReadNodes ]testIsLowercase  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isLowercase: tmp2) equals: (tmp1 isLowercase: tmp2) ]<= arg1  < primitive: 45>  ^arg1 adaptToFloat: self andCompare: #<=testPrintOn  self assert: (String streamContents: [:arg1 |  true printOn: arg1 ]) equals: 'true'testSeconds  self assert: aDateAndTime seconds equals: 0signalFromHandlerActionTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: 'Unhandled Exception';     yourselfgenReturnTopToCaller  stream nextPut: 94testIsFinalQuote  | tmp1 |  tmp1 := self classUnderTest.  0 to: tmp1 maxValue do: [:arg1 |  | tmp2 |        tmp2 := Character value: arg1.        self assert: (Unicode isFinalQuote: tmp2) equals: (tmp1 isFinalQuote: tmp2) ]fuelAccept: arg1  ^arg1 visitHookPrimitive: selfmethodsInProtocolNamed: arg1  arg1 = AllProtocol defaultName ifTrue: [ ^self allMethodSelectors ].  ^(self protocolNamed: arg1) methodSelectorshex  ^String streamContents: [:arg1 |  | tmp1 tmp2 |        1 to: 2 do: [:arg2 |  tmp1 := self at: arg2.              1 to: 8 do: [:arg3 |  tmp2 := (tmp1 bitShift: (-8 + arg3) * 4) bitAnd: 16rF.                    arg1 nextPut: ('0123456789ABCDEF' at: tmp2 + 1) ] ] ]basicCheck: arg1  self check: arg1 forCritiquesDo: [ ^true ] ifNone: [ ^false ]perform: arg1 withEnoughArguments: arg2  | tmp1 tmp2 |  tmp1 := arg1 numArgs.  arg2 size == tmp1 ifTrue: [ ^self perform: arg1 withArguments: arg2 asArray ].  tmp2 := Array new: tmp1.  tmp2 replaceFrom: 1 to: (arg2 size min: tmp2 size) with: arg2 startingAt: 1.  ^self perform: arg1 withArguments: tmp2testIsOnOrAfter  | tmp1 tmp2 |  tmp1 := january23rd2004 translateTo: -8 hours.  tmp2 := january23rd2004 translateTo: 10 hours.  self     assert: (tmp2 isOnOrAfter: tmp1);     assert: (june2nd1973 isOnOrAfter: january23rd2004) not;     assert: (june2nd1973 isOnOrAfter: june2nd1973);     assert: (january23rd2004 isOnOrAfter: june2nd1973)strictlyPositive  ^truetestTimeZone  self assert: aDateAndTime timeZoneName equals: 'Universal Time'.  self assert: aDateAndTime timeZoneAbbreviation equals: 'UTC'testIsTitlecaseLetter  self checkCorrespondanceOf: #isTitlecaseLetter: and: #Ltcompile: arg1 classified: arg2 withStamp: arg3 notifying: arg4 logSource: arg5  | tmp1 tmp2 |  tmp1 := self compiler     source: arg1;     requestor: arg4;     failBlock: [ ^nil ];     compile.  tmp2 := tmp1 selector.  arg5 ifTrue: [ self logMethodSource: (arg4 ifNotNil: [:arg6 |  arg6 text ] ifNil: [ arg1 ]) forMethod: tmp1 inCategory: arg2 withStamp: arg3 ].  self addAndClassifySelector: tmp2 withMethod: tmp1 inProtocol: arg2.  self instanceSide noteCompilationOfMethod: tmp1 meta: self isClassSide.  ^tmp2instanceSide  ^self subclassResponsibilitytestObject: arg1 initialState: arg2 tuples: arg3 setReadOnlyBlock: arg4  self assert: arg1 isReadOnlyObject equals: arg2.  arg3 do: [:arg5 |  | tmp1 tmp2 tmp3 |        tmp1 := arg5 first.        tmp2 := arg5 second.        tmp3 := arg5 last.        [ self assert: (arg4 value: tmp1) equals: tmp2 ] on: PrimitiveFailed do: [ self assert: (self alwaysReadOnlyObjects , self alwaysWritableObjects includes: arg1) ].        self assert: arg1 isReadOnlyObject equals: tmp3 ]displayString  ^self displayStringLimitedTo: 50000period  ^elapsedTime / iterationsadaptToInteger: arg1 andSend: arg2  ^(arg1 asScaledDecimal: scale) perform: arg2 with: selfwhichSuperclassSatisfies: arg1  (arg1 value: self) ifTrue: [ ^self ].  ^self superclass ifNotNil: [ self superclass whichSuperclassSatisfies: arg1 ]printMethodChunk: arg1 on: arg2  | tmp1 tmp2 |  tmp1 := self name , ' methodsFor: ' , (self organization categoryOfElement: arg1) asString printString.  tmp2 := self methodDict at: arg1 ifAbsent: [ arg2           nextPutAll: arg1;           cr.        arg2           tab;           nextPutAll: '** ERROR!  THIS SCRIPT IS MISSING ** ';           cr;           cr.        arg2 nextPutAll: '  '.        ^arg2 ].  arg2     cr;     nextChunkPut: ''.  arg2 nextChunkPut: (String streamContents: [:arg3 |  arg3 nextPutAll: tmp1.              tmp2 stamp ifNotEmpty: [:arg4 |  arg3                       nextPutAll: ' stamp: ';                       print: arg4 ] ]).  arg2 cr.  arg2     nextChunkPut: tmp2 sourceCode;     nextChunkPut: ' ';     cr.  ^arg2additionalInspectorClasses  ^{}tempAt: arg1  < primitive: 210>  ^self at: arg1width  ^corner x - origin xvariableSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 category: arg4  ^self variableSubclass: arg1 instanceVariableNames: arg2 classVariableNames: arg3 package: arg4= arg1  ^self == arg1 ifTrue: [ true ] ifFalse: [ self species = arg1 species ifTrue: [ self asNanoSeconds = arg1 asNanoSeconds ] ifFalse: [ false ] ]signalReallyAll  self checkOwnerProcess.  self signalAll.  self queueDict valuesDo: [:arg1 |  self signalAllInQueue: arg1 ]var10: arg1  var10 := arg1evaluateSignal: arg1  < primitive: 199>  < debuggerCompleteToSender>  | tmp1 |  arg1 privHandlerContext: self contextTag.  tmp1 := self exceptionHandlerBlock cull: arg1.  self return: tmp1testSecond  self assert: aDateAndTime second equals: 0firstThursday  ^self start + (5 - self start dayOfWeek + 7 rem: 7) daysprintOn: arg1  super printOn: arg1.  arg1     space;     nextPut: $(;     print: self identityHash;     nextPut: $)nonIndexedMessageText  ^String streamContents: [:arg1 |  arg1 << ' '.        self printObject: object on: arg1.        arg1 << ' is read-only, hence its selector '.        arg1 << retrySelector.        arg1 << ' cannot be executed with '.        self printObject: newValue on: arg1 ]unschedule: arg1  testValueWithReceiverArguments  | tmp1 tmp2 |  tmp1 := self class compiledMethodAt: #returnTrue.  tmp2 := tmp1 valueWithReceiver: nil arguments: #().  self assert: tmp2 equals: true.  tmp1 := self class compiledMethodAt: #returnPlusOne:.  tmp2 := tmp1 valueWithReceiver: nil arguments: #(1).  self assert: tmp2 equals: 2errorCategoryName  self error: 'Category name must be a String'hasTraitComposition  ^falsegtInspectorAllReferencesOutsideIn: arg1  < gtInspectorPresentationOrder: 20>  arg1 list     title: 'All Ref Outside';     display: [ ((SystemNavigation default allReferencesTo: self binding) reject: [:arg2 |  arg2 package name == self package name ]) sorted: [:arg3 :arg4 |  arg3 name < arg4 name ] ];     format: #name;     tags: [:arg5 |  {arg5 package name} ]xor: arg1  ^arg1 valuedoubleOuterTest  [ [ [ self doSomething.  MyTestNotification signal.  self doSomethingExceptional ] on: MyTestNotification do: [:arg1 |  arg1 outer.        self doSomethingExceptional ] ] on: MyTestNotification do: [:arg1 |  arg1 outer.        self doSomethingElse ] ] on: MyTestNotification do: [:arg1 |  self doYetAnotherThing.        arg1 resume ]perform: arg1 with: arg2 with: arg3 with: arg4 with: arg5  < reflective: #object:performMessageWith:>  < primitive: 83>  ^self perform: arg1 withArguments: (Array with: arg2 with: arg3 with: arg4 with: arg5)testReActivate  | tmp1 |  tmp1 := Stopwatch new.  tmp1     activate;     suspend;     reActivate.  self assert: tmp1 isActivetestTruncateTo  self assert: (5 minutes + 37 seconds truncateTo: 2 minutes) equals: 4 minutes.  self assert: (aDuration truncateTo: (Duration days: 1)) equals: (Duration days: 1 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: (aDuration truncateTo: (Duration hours: 1)) equals: (Duration days: 1 hours: 2 minutes: 0 seconds: 0 nanoSeconds: 0).  self assert: (aDuration truncateTo: (Duration minutes: 1)) equals: (Duration days: 1 hours: 2 minutes: 3 seconds: 0 nanoSeconds: 0)nthRootTruncated: arg1  | tmp1 tmp2 tmp3 |  self = 0 ifTrue: [ ^0 ].  self negative ifTrue: [ arg1 even ifTrue: [ ArithmeticError signal: 'Negative numbers don''t have even roots.' ].        ^(self negated nthRootTruncated: arg1) negated ].  tmp1 := 1 bitShift: (self highBitOfMagnitude + arg1 - 1) // arg1.  [ tmp2 := tmp1 raisedTo: arg1 - 1.  tmp3 := (tmp1 * tmp2 - self) // (tmp2 * arg1).  tmp3 = 0 ] whileFalse: [ tmp1 := tmp1 - tmp3 ].  ((tmp1 := tmp1 - 1) raisedTo: arg1) > self ifTrue: [ tmp1 := tmp1 - 1 ].  ^tmp1penultimateLiteral  | tmp1 |  ^(tmp1 := self numLiterals - 1) > 0 ifTrue: [ self literalAt: tmp1 ] ifFalse: [ nil ]testAddSlot  | tmp1 |  tmp1 := testEnvironment at: #TUTU.  tmp1 addSlot: #x => InstanceVariableSlot.  self assert: tmp1 instVarNames equals: #('x').  self assert: tmp1 name equals: #TUTU.  tmp1 addSlot: #y => InstanceVariableSlot.  self assert: tmp1 instVarNames equals: #('x' 'y')link: arg1 toClassVariableNamed: arg2  self link: arg1 toClassVariableNamed: arg2 option: #allsharedPoolsDo: arg1  self hasSharedPools ifFalse: [ ^self ].  self sharedPools do: arg1nthRoot: arg1  self subclassResponsibilitytestSharedPoolOfVarNamed  self assert: (Date sharedPoolOfVarNamed: 'DayNames') equals: ChronologyConstants.  self assert: (Date class sharedPoolOfVarNamed: 'DayNames') isNil.  self assert: (RootClassPoolUser sharedPoolOfVarNamed: 'Author') equals: PoolDefiner.  self assert: (RootClassPoolUser sharedPoolOfVarNamed: 'Gloups') equals: PoolDefiner.  self assert: (SubclassPoolUser sharedPoolOfVarNamed: 'Author') equals: PoolDefiner.  self assert: (ClassMultiplePoolUser sharedPoolOfVarNamed: 'Author') equals: PoolDefiner.  self assert: (ClassMultiplePoolUser sharedPoolOfVarNamed: 'VariableInPoolDefiner2') equals: PoolDefiner2.  self assert: (ClassMultiplePoolUser sharedPoolOfVarNamed: 'Gloups') equals: PoolDefinercontext: arg1  context := arg1methodWithError  MyTestError signal: self testStringspotterForBytecodesFor: arg1  < spotterOrder: 15>  arg1 listProcessor     title: 'Bytecode';     allCandidates: [ self symbolicBytecodes ];     itemName: #printString;     filter: GTFilterSubstringdoSomethingElseString  ^'Do something else.'genReturnReceiver  stream nextPut: 88asMonth  ^start asMonthgenPushLiteralVar: arg1  | tmp1 |  (arg1 < 0 or: [ arg1 > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 32768 ].  arg1 < 16 ifTrue: [ stream nextPut: 16 + arg1.        ^self ].  (tmp1 := arg1) > 255 ifTrue: [ self genUnsignedSingleExtendA: tmp1 // 256.        tmp1 := tmp1 \\ 256 ].  stream     nextPut: 227;     nextPut: tmp1copyCategory: arg1 from: arg2 classified: arg3  self copyAll: (arg2 organization listAtCategoryNamed: arg1) from: arg2 classified: arg3glmCritiqueSourceIn: arg1  ^arg1 pharoScript     title: 'Source';     display: [ self definition ];     act: [ self browse ] icon: GLMUIThemeExtraIcons glamorousBrowse entitled: 'Browse'mightBeASquare  | tmp1 |  tmp1 := self byteAt: 1.  ^(tmp1 = 0 and: [ self lowBit odd ]) or: [ tmp1 = 16r40 or: [ (tmp1 bitAnd: 16r7) = 1 or: [ (tmp1 bitAnd: 16r1F) = 4 or: [ (tmp1 bitAnd: 16r7F) = 16 ] ] ] ]maybeReadOnlyObjects  ^{{1 .   2 .   3} asByteArray .   {1 .   2 .   3} .   (MessageSend receiver: 1 selector: #+ argument: 2)}truncated  < primitive: 551>  (self isInfinite or: [ self isNaN ]) ifTrue: [ self error: 'Cannot truncate this number' ].  self abs < 2.0e16 ifTrue: [ | tmp1 tmp2 tmp3 tmp4 |        tmp1 := (SmallInteger maxVal bitShift: -1) + 1.        tmp2 := tmp1 asFloat.        tmp3 := self quo: tmp2.        tmp4 := self - (tmp3 asFloat * tmp2).        ^tmp3 * tmp1 + tmp4 truncated ] ifFalse: [ ^self asTrueFraction ]testThreadSafe  self should: [ self threadSafe ] notTakeMoreThanMilliseconds: 10.  self assert: fork isNiltestInquiries  self     assert: month index equals: 7;     assert: month name equals: #July;     assert: month duration equals: 31 daystestZeroRaisedToNegativePower  self should: [ 0.0 raisedTo: -1 ] raise: ZeroDivide.  self should: [ 0.0 raisedTo: -1.0 ] raise: ZeroDividequickMergePoint: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := true.  tmp2 := arg1 x < origin x ifTrue: [ tmp1 := false.        arg1 x ] ifFalse: [ origin x ].  tmp3 := arg1 x >= corner x ifTrue: [ tmp1 := false.        arg1 x + 1 ] ifFalse: [ corner x ].  tmp4 := arg1 y < origin y ifTrue: [ tmp1 := false.        arg1 y ] ifFalse: [ origin y ].  tmp5 := arg1 y >= corner y ifTrue: [ tmp1 := false.        arg1 y + 1 ] ifFalse: [ corner y ].  ^tmp1 ifTrue: [ self ] ifFalse: [ tmp2 @ tmp4 corner: tmp3 @ tmp5 ]spotterForBytecodesFor: arg1  < spotterOrder: 15>  self method spotterForBytecodesFor: arg1basicAt: arg1  < primitive: 210>  arg1 isInteger ifTrue: [ self errorSubscriptBounds: arg1 ].  arg1 isNumber ifTrue: [ ^self at: arg1 asInteger ] ifFalse: [ self errorNonIntegerIndex ]asContextWithSender: arg1  ^(Context newForMethod: self compiledBlock)     setSender: arg1 receiver: self receiver method: self compiledBlock closure: self startpc: self startpc;     privRefreshclassVariableDefinitionString  ^String streamContents: [:arg1 |  | tmp1 |        arg1 nextPutAll: '{ '.        self classVariables do: [:arg2 |  arg1 nextPutAll: arg2 definitionString.              tmp1 := arg2 needsFullDefinition ] separatedBy: [ arg1 nextPutAll: '. '.              tmp1 ifTrue: [ arg1                       cr;                       tab;                       tab;                       tab;                       tab ] ].        arg1 nextPutAll: ' }' ]receiver  ^receivertestAsNumberNegatedWithoutDecimalPoint  | tmp1 |  tmp1 := '-123s0' asNumber.  self assert: ScaledDecimal identicalTo: tmp1 class.  self assert: tmp1 scale equals: 0.  self assert: '-123s0' equals: tmp1 printStringsharedPools  ^OrderedCollection newsuperclass: arg1 layout: arg2  layout := arg2.  self superclass: arg1 methodDictionary: self emptyMethodDictionary format: arg2 formataddSubclass: arg1  testIsDeprecated  | tmp1 |  tmp1 := #(deprecatedMethod deprecatedMethod2 deprecatedMethod3 deprecatedMethod4 deprecatedMethod5 deprecatedMethod6 deprecatedMethod7).  self class selectorsDo: [:arg1 |  (tmp1 includes: arg1) ifTrue: [ self assert: (self class >> arg1) isDeprecated ] ifFalse: [ self deny: (self class >> arg1) isDeprecated ] ].  DeprecatedClassForTest selectorsDo: [:arg1 |  self assert: (DeprecatedClassForTest >> arg1) isDeprecated ]strictlyPositive  ^falsewaitLastProcessLock  self waitProcessLock: forkedProcesses laststonOn: arg1  arg1 writeObject: self listSingleton: self name asSymboltestMutateVariableObject  | tmp1 |  tmp1 := {#[1 2 3] .   #(1 2 3)}.  tmp1 do: [:arg1 |  arg1 beReadOnlyObject.        [ arg1 at: 1 put: 4 ] on: ModificationForbidden do: [  ].        arg1           beWritableObject;           at: 2 put: 5;           beReadOnlyObject.        [ arg1 at: 3 put: 6 ] on: ModificationForbidden do: [  ].        self assert: arg1 first equals: 1.        self assert: arg1 second equals: 5.        self assert: arg1 third equals: 3 ]client  ^sender receiverintersects: arg1  | tmp1 tmp2 |  tmp1 := arg1 origin.  tmp2 := arg1 corner.  tmp2 x <= origin x ifTrue: [ ^false ].  tmp2 y <= origin y ifTrue: [ ^false ].  tmp1 x >= corner x ifTrue: [ ^false ].  tmp1 y >= corner y ifTrue: [ ^false ].  ^truetranslateTo: arg1  ^self class starting: (start translateTo: arg1)to: arg1  ^Timespan starting: self ending: arg1 asDateAndTimetearDown  testClass := nil.  testSubclass := nil.  super tearDownisLiteral  ^truemethod  ^sendersimpleNoTimeoutTestResults  ^OrderedCollection new     add: self doSomethingString;     yourselfinstSize  ^format bitAnd: 16rFFFFtestNonActiveBlockContextHome  nonActiveBlockContext := self class returnNonActiveContextOfBlock.  self assert: nonActiveBlockContext home isNotNiltestContinuedFractions  self assert: (Float pi asApproximateFractionAtOrder: 1) equals: 22 / 7.  self assert: (Float pi asApproximateFractionAtOrder: 3) equals: 355 / 113genPushLiteral: arg1  | tmp1 |  (arg1 < 0 or: [ arg1 > 32768 ]) ifTrue: [ ^self outOfRangeError: 'index' index: arg1 range: 0 to: 32768 ].  arg1 < 32 ifTrue: [ stream nextPut: 32 + arg1.        ^self ].  (tmp1 := arg1) > 255 ifTrue: [ self genUnsignedSingleExtendA: tmp1 // 256.        tmp1 := tmp1 \\ 256 ].  stream     nextPut: 228;     nextPut: tmp1testNewDayYear  self assert: (Date year: 2004 day: 23) equals: january23rd2004haltIfNil  < debuggerCompleteToSender>  Halt nowunschedule: arg1  < haltOrBreakpointForTesting>  debug ifTrue: [ self halt ].  delayToStop := arg1.  timingSemaphore signal.  debug ifTrue: [ self halt ]testDayOfWeek  self assert: aDateAndTime dayOfWeek equals: 3.  self assert: aDateAndTime dayOfWeekAbbreviation equals: 'Tue'.  self assert: aDateAndTime dayOfWeekName equals: 'Tuesday'thoroughHasSelectorReferringTo: arg1  | tmp1 |  tmp1 := Smalltalk specialSelectorIndexOrNil: arg1.  ^self methods anySatisfy: [:arg2 |  arg2 hasSelector: arg1 specialSelectorIndex: tmp1 ]isEqualRegardlessMethodsTrailerTo: arg1  self == arg1 ifTrue: [ ^true ].  arg1 isDictionary ifFalse: [ ^false ].  self size = arg1 size ifFalse: [ ^false ].  self associationsDo: [:arg2 |  ((arg1 at: arg2 key ifAbsent: [ ^false ]) isEqualRegardlessTrailerTo: arg2 value) ifFalse: [ ^false ] ].  ^truetestNew  squared  ^Fraction numerator: numerator squared denominator: denominator squarednextHandlerContext  ^self sender findNextHandlerContextsuitableRulesFrom: arg1  ^arg1 methodRulesstartpc  ^self compiledBlock initialPCsuspendAtTimingPriority  < haltOrBreakpointForTesting>  debug ifTrue: [ self halt ].  ticker saveResumptionTimes: suspendedDelays asArray , {activeDelay}.  suspendSemaphore wait.  debug ifTrue: [ self halt ].  ticker restoreResumptionTimes: suspendedDelays asArray , {activeDelay}.  suspendSemaphore := nilobjectSize: arg1  < primitive: 62>  ^0< arg1  < primitive: 3>  ^super < arg1testReadFromMillisecond  self assert: (Duration readFrom: '0:00:00:00.001 ' readStream) nanoSeconds equals: 1000000writeSlot: arg1 value: arg2  ^arg1 write: arg2 to: selfspotterForImplementorsFor: arg1  < spotterOrder: 10>  self method spotterForImplementorsFor: arg1cut: arg1  | tmp1 tmp2 |  tmp1 := self.  [ tmp1 == arg1 ] whileFalse: [ tmp2 := tmp1.        tmp1 := tmp1 sender.        tmp1 ifNil: [ arg1 ifNotNil: [ self error: 'aContext not a sender' ] ] ].  tmp2 privSender: nilslots: arg1  | tmp1 |  tmp1 := self instanceSide.  tmp1 := tmp1 classInstaller update: tmp1 to: [:arg2 |  arg2           fillFor: tmp1;           classSlots: arg1 ].  ^tmp1 classSideday  ^self daysdaysLeftInYear  ^self daysInYear - self dayOfYearnestedLoopsExample: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 inject: 1 into: [:arg2 :arg3 |  arg2 * arg3 size ].  tmp3 := arg1 collect: [:arg4 |  arg4 readStream ].  tmp1 := OrderedCollection new: tmp2.  tmp4 := [:arg5 :arg6 :arg7 |  | tmp5 |  tmp5 := [:arg8 |  [ arg8 = arg7 size ifTrue: [ 1 to: arg7 size do: [:arg9 |  arg6 at: arg9 put: (arg7 at: arg9) peek ].        arg5 addLast: arg6 shallowCopy ] ifFalse: [ tmp5 value: arg8 + 1 ].  (arg7 at: arg8) next.  (arg7 at: arg8) atEnd ] whileFalse: [  ].  (arg7 at: arg8) reset ].  tmp5 value: 1.  arg5 ].  tmp4 value: tmp1 value: (Array new: tmp3 size) value: tmp3.  ^tmp1removeFirst  | tmp1 |  self emptyCheck.  tmp1 := firstLink.  firstLink == lastLink ifTrue: [ firstLink := nil.        lastLink := nil ] ifFalse: [ firstLink := tmp1 nextLink ].  tmp1 nextLink: nil.  ^tmp1 valuetestInfinity1  | tmp1 tmp2 |  tmp1 := 10000 exp.  tmp2 := 1000000000 exp.  self assert: tmp1 isInfinite & tmp2 isInfinite & (tmp1 = tmp2)isCollection  ^falsewaitProcessLock: arg1  self waitFor: [ arg1 suspendingList notEmpty ]selector  ^self method selector ifNil: [ self method defaultSelector ]printOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     nextPutAll: self state;     nextPut: $:;     print: self duration;     nextPut: $)asCharacterDigit  ^Character digitValue: selfsaveResumptionTimes: arg1  | tmp1 |  tmp1 := self nowTick.  arg1 do: [:arg2 |  arg2 ifNotNil: [ arg2 resumptionTickAdjustFrom: tmp1 to: 0 ] ]testRefersToLiteralsReturnsTrueWhenLiteralIsByteSymbol  self assert: (self compiledMethod1 hasLiteralThorough: #printOn:)adaptToFloat: arg1 andCompare: arg2  ^self adaptToFloat: arg1 andSend: arg2testToByDo  | tmp1 |  tmp1 := aDateAndTime to: aDateAndTime + 10 days by: 5 days do: [:arg1 |   ].  self     assert: tmp1 notNil;     assert: tmp1 duration equals: 10 daystestIsMathSymbol  self checkCorrespondanceOf: #isMathSymbol: and: #SmclassUnderTest  ^Latin1ifFalse: arg1  ^arg1 valueprintOn: arg1  origin printOn: arg1.  arg1 nextPutAll: ' corner: '.  corner printOn: arg1testStoring  | tmp1 tmp2 |  tmp1 := '''2 June 1973'' asDate'.  tmp2 := june2nd1973 storeString.  self     assert: tmp2 equals: tmp1;     assert: (Smalltalk compiler evaluate: tmp1) equals: june2nd1973primSignal: arg1 atUTCMicroseconds: arg2  (arg1 isKindOf: Semaphore) ifTrue: [ vmSimTheTimerSemaphore := arg1.        vmSimNextWakeupTick := arg2 ].  arg1 = nil ifTrue: [ vmSimTheTimerSemaphore := nil.        vmSimNextWakeupTick := 0 ]setUp  super setUp.  generator := Random seed: 14159265ticks: arg1  seconds := arg1 at: 2.  nanos := arg1 at: 3compileAllFrom: arg1  super compileAllFrom: arg1.  self classSide compileAllFrom: arg1 classSideendPC  ^self trailer endPCisCompiledMethod  ^truenextReadyProcess  quiescentProcessLists reverseDo: [:arg1 |  arg1 isEmpty ifFalse: [ | tmp1 |              tmp1 := arg1 first.              tmp1 suspendedContext ifNotNil: [ ^tmp1 ] ] ].  ^nilarguments  ^argsisInteger  ^truesetActionSequence: arg1 forEvent: arg2  | tmp1 |  tmp1 := arg1 asMinimalRepresentation.  tmp1 ifNil: [ self removeActionsForEvent: arg2 ] ifNotNil: [ self updateableActionMap at: arg2 asSymbol put: tmp1 ]testNaN1  self assert: Float nan identicalTo: Float nan.  self deny: Float nan equals: Float nanbrowseHierarchy  self systemNavigation browseHierarchy: self classduringTestCompileSilently: arg1 storeSource: arg2 classified: arg3  ^FLPlatform current useAuthor: 'TestsAuthor' during: [ [ self compile: arg1 classified: (arg3 ifNil: [ '' ]) withStamp: nil notifying: nil logSource: arg2 ] fuelValueWithoutNotifications ]genPushSpecialLiteral: arg1  self subclassResponsibilityfrequency  ^iterations / elapsedTime totalSecondsgtIterator  ^Error signal: 'This is not a spotter iterator'floor  self isIntegerRectangle ifTrue: [ ^self ].  ^origin floor corner: corner floorasCharacter  ^Character value: self@ arg1  < primitive: 18>  ^Point x: self y: arg1whileTrue: arg1  self value ifTrue: [ arg1 value.        self whileTrue: arg1 ].  ^nilweek  ^self weekstestAsNumberWithSuperfluousDecimalPoint  | tmp1 |  tmp1 := '123.s2' asNumber.  self deny: ScaledDecimal == tmp1 class description: 'It used to, but this syntax is not valid Smalltalk'monthIndex  ^self month==> arg1  ^self not or: [ arg1 value ]removeAllMethods  self deprecated: 'Use #removeAllMethodSelectors instead' transformWith: '`@receiver removeAllMethods' -> '`@receiver removeAllMethodSelectors'.  ^self removeAllMethodSelectorsmillisecondDelayDuration  ^millisecondDelayDuration> arg1  arg1 isInteger ifTrue: [ self negative == arg1 negative ifTrue: [ self negative ifTrue: [ ^(self bytesCompare: arg1) < 0 ] ifFalse: [ ^(self bytesCompare: arg1) > 0 ] ] ifFalse: [ ^arg1 negative ] ].  ^arg1 adaptToInteger: self andCompare: #>numArgs  ^arguments sizeat: arg1 ifAbsentPut: arg2  1 to: self basicSize do: [:arg3 |  | tmp1 |        (tmp1 := self basicAt: arg3) key == arg1 ifTrue: [ ^tmp1 isVariableBinding ifTrue: [ tmp1 value ] ifFalse: [ tmp1 ] ] ].  ^method propertyAt: arg1 put: arg2 valuejoin: arg1  ^(Array with: self) join: arg1selectorsWithExplicitOrigin  ^self traitComposition selectors , self localSelectorstestTwoCriticalsShouldWaitEachOther  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := false.  tmp3 := Semaphore new.  self fork: [ mutex critical: [ tmp3 wait.              tmp2 := tmp1 not ] ].  self waitLastProcessLock.  self fork: [ mutex critical: [ tmp1 := true ] ].  self waitLastProcessLock.  tmp3 signal.  self waitLastProcessTerminate.  self assert: tmp1.  self assert: tmp2instVarNamed: arg1  ^self class slotNamed: arg1 ifFound: [:arg2 |  arg2 read: self ] ifNone: [ InstanceVariableNotFound signalFor: arg1 asString ]superclass: arg1 methodDictionary: arg2 format: arg3  self basicSuperclass: arg1.  self setFormat: arg3.  self methodDict: arg2traits  ^#()denominator  ^1genStorePopRemoteTemp: arg1 inVectorAt: arg2  (arg1 >= 0 and: [ arg1 < 256 and: [ arg2 >= 0 and: [ arg2 < 256 ] ] ]) ifTrue: [ stream           nextPut: 142;           nextPut: arg1;           nextPut: arg2.        ^self ].  arg1 >= 256 ifTrue: [ ^self outOfRangeError: 'remoteTempIndex' index: arg1 range: 0 to: 255 ].  arg2 >= 256 ifTrue: [ ^self outOfRangeError: 'tempVectorIndex' index: arg2 range: 0 to: 255 ]isFinite  ^self - self = 0.0endPC  ^self compiledBlock endPCnumberOfReservedLiterals  ^self subclassResponsibilitypointNearestTo: arg1  | tmp1 |  (self containsPoint: arg1) ifTrue: [ tmp1 := self sideNearestTo: arg1.        tmp1 == #right ifTrue: [ ^self right @ arg1 y ].        tmp1 == #left ifTrue: [ ^self left @ arg1 y ].        tmp1 == #bottom ifTrue: [ ^arg1 x @ self bottom ].        tmp1 == #top ifTrue: [ ^arg1 x @ self top ] ] ifFalse: [ ^arg1 adhereTo: self ]isForm  ^falsetestAndSingleBitWithMinusOne  1 to: 100 do: [:arg1 |  self assert: ((1 bitShift: arg1) bitAnd: -1) equals: (1 bitShift: arg1) ]roundTo: arg1  ^Rectangle origin: (origin roundTo: arg1) corner: (corner roundTo: arg1)isTerminated  self isActiveProcess ifTrue: [ ^false ].  ^suspendedContext isNil or: [ suspendedContext isBottomContext and: [ suspendedContext isDead or: [ suspendedContext pc > suspendedContext startpc ] ] ]asBeaconSignal  ^WrapperSignal on: selftestStarting  | tmp1 tmp2 |  tmp2 := '13:12' asTime.  tmp1 := DateAndTime date: january23rd2004 time: tmp2.  self assert: (Date starting: tmp1) equals: january23rd2004copyTwoLevel  | tmp1 tmp2 tmp3 |  tmp2 := self class.  tmp1 := self shallowCopy.  tmp1 == self ifTrue: [ ^self ].  tmp2 isVariable ifTrue: [ tmp3 := self basicSize.        [ tmp3 > 0 ] whileTrue: [ tmp1 basicAt: tmp3 put: (self basicAt: tmp3) shallowCopy.              tmp3 := tmp3 - 1 ] ].  tmp3 := tmp2 instSize.  [ tmp3 > 0 ] whileTrue: [ tmp1 instVarAt: tmp3 put: (self instVarAt: tmp3) shallowCopy.        tmp3 := tmp3 - 1 ].  ^tmp1cleanOuterContext  outerContext := outerContext cleanCopyasRingMinimalDefinitionIn: arg1  ^arg1 backend definitionFor: self ifAbsentRegister: [ RGMethod named: self selector asSymbol parent: (self methodClass asRingMinimalDefinitionIn: arg1) ]