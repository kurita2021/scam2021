basisObjects: aCollection  basisObjects := aCollection asSet-=JUAMPI=-isImplementedByClass: aClass  ^aClass instanceSide includesBehavior: self implementorClass instanceSide-=JUAMPI=-testComparisonWithAnotherKindOfResult  self deny: queryResult equals: ClyQueryResult new-=JUAMPI=-selectsMethod: aMethod  ^aMethod isExtension and: [ aMethod package = package ]-=JUAMPI=-ownerTool: anObject  ownerTool := anObject.  self build-=JUAMPI=-initialize  super initialize.  projectManagers := OrderedCollection new-=JUAMPI=-testHasEmptyBasisObjects  scope := self createSampleScope.  self assert: scope basisObjects isEmpty-=JUAMPI=-specialSelectorIndexes  ^specialSelectorIndexes ifNil: [ specialSelectorIndexes := selectors collect: [:each |  Smalltalk specialSelectorIndexOrNil: each ] ]-=JUAMPI=-isSlow  ^false-=JUAMPI=-focusActiveTab  tabManager focusActiveTab-=JUAMPI=-testCaseResults: anObject  testCaseResults := anObject-=JUAMPI=-allNavigationScopes  | classLocalScope |  classLocalScope := self classSelection asItemsScope: ClyBothMetaLevelClassScope.  ^super allNavigationScopes , {(self packageSelection asItemsScope: ClyPackageScope) .         classLocalScope asFullHierarchyScope .         classLocalScope}-=JUAMPI=-itemsStartingAt: startIndex count: size  ^#()-=JUAMPI=-isAffectedByChangedMethod: aMethod  ^self selectsMethod: aMethod-=JUAMPI=-buildResult: aQueryResult  | filteredMethods |  filteredMethods := OrderedCollection new.  scope methodsDo: [:each |  (self selectsMethod: each) ifTrue: [ filteredMethods add: each ] ].  aQueryResult fillWith: filteredMethods-=JUAMPI=-rebuildIfNeeded  self protectAccessWhile: [ needsRebuild ifTrue: [ needsRebuild := false.              self rebuild ] ]-=JUAMPI=-createQuery  ^ClyDeprecatedMethodsQuery from: ClyClassScope of: Object in: environment-=JUAMPI=-testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self deny: query checkEmptyResult-=JUAMPI=-changeStateOf: aQueryView by: aBlock  | newTools |  self changeStateBy: [ aBlock value.        aQueryView changesWasInitiatedByUser ifTrue: [ newTools := OrderedCollection new.              tabManager buildToolsOn: newTools for: aQueryView createSelectionContext.              tabManager desiredSelection: (newTools collect: #class) ] ]-=JUAMPI=-withResult: aQueryResult  | copy |  copy := self copy.  copy requiredResult: aQueryResult.  ^copy-=JUAMPI=-packagesDo: aBlock  basisObjects do: aBlock-=JUAMPI=-execute  browser switchScopeTo: queryScope-=JUAMPI=-update  | unacceptedText newText |  super update.  newText := self editingText.  self pendingText asString = newText ifTrue: [ self applyDecorations.        ^self ].  self hasUnacceptedEdits ifTrue: [ unacceptedText := self pendingText copy ].  textModel setInitialText: newText.  unacceptedText ifNil: [ ^self textUpdated ].  self pendingText: unacceptedText.  textMorph hasEditingConflicts: true.  textMorph changed-=JUAMPI=-environment  ^environment-=JUAMPI=-defaultMenuItemName  self hasTestResult ifFalse: [ ^'Run failed' ].  ^'Run failed (' , self testResult brokenCount asString , ')'-=JUAMPI=-findItemsWith: actualObjects  | result |  self protectItemsWhile: [ result := actualObjects collect: [:eachObject |  items detect: [:item |  item representsObjectEqualTo: eachObject ] ifNone: nil ].        result select: #notNil thenDo: [:each |  each prepareIn: environment ].        ^result ]-=JUAMPI=-metalinkManagerClass  ^ExecutionCounter-=JUAMPI=-dataSource: anObject  dataSource := anObject-=JUAMPI=-scopeClass  ^ClySuperclassScope-=JUAMPI=-selectedMethodItems  ^self selectedItemsOfType: ClyMethod-=JUAMPI=-icon  ^icon-=JUAMPI=-prepareNewResult  ^asyncResult prepareNewFor: self actualQuery in: self environment-=JUAMPI=-extensionMethodFromRoot1Trait  -=JUAMPI=-setUp  super setUp.  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new-=JUAMPI=-findItemsSameAsFilter  | filterString |  filterString := table filterString asLowercase.  ^self dataSource findItemsWhere: [:each |  each name asLowercase = filterString ]-=JUAMPI=-forceRebuild  self forceLazyRebuild.  self notifyObservers-=JUAMPI=-browserTool: anObject  browserTool := anObject-=JUAMPI=-rawItemsDo: aBlock  actualResult rawItemsDo: aBlock-=JUAMPI=-decorateBrowserItem: anItem ofMethod: aMethod  aMethod usesUndeclares ifTrue: [ anItem markWith: ClyUndeclaresUserTag ]-=JUAMPI=-testComparison  self assert: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring').  self assert: (ClyMethodSourcesQuery withString: 'test substring') hash equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring') hash.  self deny: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'another substring')-=JUAMPI=-testConvertingToInheritingScopeShouldAddTraitUsers  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asInheritingScope.  self assert: (convertedScope representsScope: ClyTraitUserScope)-=JUAMPI=-showsFlatResult  ^(systemQuery retrievesItemsAs: ClyHierarchicalSystemItems) not-=JUAMPI=-multipleScopeSample  | newScope |  newScope := super multipleScopeSample.  newScope relationScopeClasses: {ClySuperclassScope}.  ^newScope-=JUAMPI=-containerForChildren  ^SortedCollection sortBlock: sortFunction-=JUAMPI=-= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^definingClass = anObject definingClass-=JUAMPI=-isSameAs: anotherSelection  self size = anotherSelection size ifFalse: [ ^false ].  items with: anotherSelection items do: [:myItem :anotherItem |  myItem actualObject == anotherItem actualObject ifFalse: [ ^false ] ].  ^true-=JUAMPI=-browser: anObject  browser := anObject-=JUAMPI=-isResult: aQueryResult affectedBy: aSystemAnnouncement  aSystemAnnouncement affectsCritiques ifFalse: [ ^false ].  aQueryResult forceLazyRebuild.  ^false-=JUAMPI=-createQuery  ^ClyLongQueryExample from: ClyScopeExample of: String in: environment-=JUAMPI=-testNotEmptyFromEmptyMethodScope  query scope: (ClyMethodScope emptyIn: environment).  self deny: query checkEmptyResult-=JUAMPI=-accumulateTestMethod: aMethod  | testSelector result inheritingScope |  testSelector := aMethod selector.  inheritingScope := (ClyClassScope of: aMethod methodClass) withInheritingScope.  inheritingScope classesDo: [:concreteTestCase |  (concreteTestCase isTestCase and: [ concreteTestCase isAbstract not ]) ifTrue: [ self accumulateTest: testSelector of: concreteTestCase.              result := testCaseResults at: concreteTestCase ifAbsentPut: [ ClyTestResultProperty new ].              result accumulateTest: testSelector of: concreteTestCase ] ]-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (Object >> #printString)}.  self assert: foundSelectors equals: #(abstractMethod1 abstractMethod2)-=JUAMPI=-build  | goButton contextLabel |  contextLabel := ownerTool printContext.  contextLabel ifEmpty: [ ^self ].  self addMorphBack: (self iconNamed: #uncommentedClass) asMorph.  self addMorphBack: contextLabel asMorph.  goButton := IconicButton new     target: self;     actionSelector: #restoreBrowserState;     arguments: {};     labelGraphic: (self iconNamed: #forward);     color: Color transparent;     helpText: 'Move browser to ' , contextLabel;     borderWidth: 0.  self addMorphBack: goButton-=JUAMPI=-menuItemNameFor: aCommand  ^menuItemName ifNil: [ aCommand defaultToolbarItemName ]-=JUAMPI=-position: anObject  position := anObject-=JUAMPI=-enableFilterUsing: aStringPattern  self enableFilter: ClyItemNameFilter using: aStringPattern-=JUAMPI=-selectsMethod: aMethod  ^scope inheritanceAnalyzer isMethodOverriding: aMethod-=JUAMPI=-groupProviderClass  ^ClyFlagMethodGroupProvider-=JUAMPI=-buildExtensionCheckBoxButton  extensionCheckbox := self theme newCheckboxIn: self for: self getSelected: #isExtensionActive setSelected: #toggleExtension getEnabled: nil label: 'extension' help: 'toggle check box to choose/reset package of method'.  extensionCheckbox     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap-=JUAMPI=-reference1OfClass  ^ClyClassReferencesQueryTest-=JUAMPI=-runBuildProcess  buildProcess := [ self buildActualResult ] newProcess.  buildProcess     name: 'Build result of ' , buildingQuery printString;     priority: Processor userBackgroundPriority.  buildProcess resume-=JUAMPI=-classesSize  ^classQuery execute size-=JUAMPI=-isClassTagSelected  | groups |  groups := tool classGroupSelection.  groups isEmpty ifTrue: [ ^false ].  ^groups lastSelectedItem type isBasedOnClassTag-=JUAMPI=-execute  sourceNode nodesWithLinks do: [:each |  self metalinkManagerClass removeFrom: each ]-=JUAMPI=-rebuildAllTools  tabManager updateTools.  self rebuildToolbar-=JUAMPI=-buildResult: aQueryResult  | critiques methods |  critiques := critiqueQuery execute.  methods := critiques items collect: [:each |  each sourceAnchor entity ] as: IdentitySet.  aQueryResult fillWith: methods-=JUAMPI=-attachToSystem  -=JUAMPI=-wantsStayInDifferentContext  self isBuilt ifFalse: [ ^false ].  self hasUnacceptedEdits ifTrue: [ ^true ].  self isTabSelected & self isExtraSelectionRequested ifTrue: [ ^true ].  self belongsToRemovedBrowserContext ifTrue: [ ^false ].  ^isManagedByUser-=JUAMPI=-openFor: anItemObserver  self moveToStart.  itemObserver := anItemObserver.  queryResult subscribe: itemObserver-=JUAMPI=-buildIsDone  self notifyObservers.  environment systemChanged: (ClyAsyncQueryIsDone with: self)-=JUAMPI=-changesCancelled  textMorph hasUnacceptedEdits: false.  self textUpdated-=JUAMPI=-testPrepareResultForExecutionWhenItIsSemiAsync  | preparedResult |  preparedResult := query semiAsync prepareNewResult.  self assert: preparedResult class equals: ClySemiAsyncQueryResult.  self assert: preparedResult buildingQuery identicalTo: query actualQuery.  self assert: preparedResult environment identicalTo: environment.  self assert: preparedResult isProtected-=JUAMPI=-initialize  super initialize.  fullIndentation := false.  self cellInset: 2 @ 0-=JUAMPI=-isCommandAvailable: aCommand  ^aCommand canBeExecutedInTool: self-=JUAMPI=-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red.  anItemCellMorph definitionIcon: #smallDebug-=JUAMPI=-itemOfThisTestMethod  ^ClyBrowserItem with: self class >> testSelector-=JUAMPI=-browser  ^tool browser-=JUAMPI=-methodFromTraitChild2  -=JUAMPI=-filterField  ^table filterField-=JUAMPI=-testNotAffectedByChangeOfSubclassMethodWhichNotOverridesSuperclass  self deny: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)-=JUAMPI=-itemsChanged  dirty ifTrue: [ ^self ].  dirty := true.  self scheduleUpdate-=JUAMPI=-testNotSelectsMethodWhichHasNoUndeclares  self deny: (query selectsMethod: Object >> #printString)-=JUAMPI=-createInheritingScopeFrom: aClassScope  | scope |  scope := annotatedClass createInheritingScopeFrom: aClassScope.  scope name: ClyClassScope inheritingScopeName.  ^scope-=JUAMPI=-increasedByClassesFrom: aClassScope  ^self withExtraBasisObjects: aClassScope collectAllClasses-=JUAMPI=-testFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 3.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector).  self assert: (resultItems identityIncludes: self class superclass >> self targetSelector)-=JUAMPI=-close  queryResult unsubscribe: itemObserver.  itemObserver := nil.  ^ClyClosedBrowserCursor instance-=JUAMPI=-testCompareTwoMethods  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object >> #size value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  methodQuery printOn: aStream.  aStream nextPut: $)-=JUAMPI=-checkEmptyResult  ^self installedMethods isEmpty-=JUAMPI=-buildItemsPerClassFrom: systemObjects  | itemsPerClass item localItems |  itemsPerClass := IdentityDictionary new.  systemObjects do: [:each |  item := each asCalypsoBrowserItem.        localItems := itemsPerClass at: item systemDefinitionClass ifAbsentPut: [ self containerForItemsOfClass ].        localItems add: item ].  ^itemsPerClass-=JUAMPI=-actualObject: anObject  actualObject := anObject.  type := anObject calypsoEnvironmentType-=JUAMPI=-testIsAffectedByChangeOfAbstractMethodWhichIsImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #abstractMethod1)-=JUAMPI=-editingMethod: aMethod  editingMethod := aMethod-=JUAMPI=-isActive  ^ownerTool extendingPackage notNil-=JUAMPI=-testFillingWithTwoEqualVarsOfDifferentSubclassesAndOneVarOfSuperclass  queryResult fillWith: {(ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN2OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN1OfClass1FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar2 #subclassSameVar #subclassSameVar)-=JUAMPI=-testCreationUnifiedInstance  scope := self createSampleScope.  self assert: scope asUnifiedInstance identicalTo: scope-=JUAMPI=-localMethod  -=JUAMPI=-isBasedOnEmptyBasis  ^self basisSize = 0-=JUAMPI=-cleanGarbageInCache  accessGuard critical: [ queryCache clyCleanGarbage ]-=JUAMPI=-subscribe: anObject  announcer ifNil: [ announcer := Announcer new ].  announcer when: ClyEnvironmentChanged send: #itemsChanged to: anObject-=JUAMPI=-browser: anObject  browser := anObject-=JUAMPI=-testCreationFromTwoSameQueriesOfSameScopeButWithDifferentParameter  | subquery1 subquery2 |  subquery1 := self subqueryFromScopeOf: Array.  subquery1 scope extraParameter: #testParameter.  subquery2 := self subqueryFromScopeOf: Array.  subquery2 scope extraParameter: #testParameter2.  query := subquery1 , subquery2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {subquery1 .         subquery2} asSet.  self assert: query requiredResult identicalTo: subquery1 requiredResult-=JUAMPI=-size  ^self protectItemsWhile: [ items size ]-=JUAMPI=-testRetrievesMethodQuery  self snapshotState.  self assert: navigationState systemQuery equals: browser systemQuery-=JUAMPI=-hash  ^sortFunction hash bitXor: inverse hash-=JUAMPI=-name  ^name-=JUAMPI=-testItemsInitializationShouldNotResetExistingItems  queryResult items: #(items).  queryResult initializeItems.  self assert: queryResult items equals: #(items)-=JUAMPI=-printContext  ^super printContext , ' / ' , editingClass name-=JUAMPI=-testMethodsEnumerationWhenBothMetaLevels  scope := ClyTraitUserScope of: ClyTraitRoot1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyTraitChild1 localMethods).  self assert: (result includesAll: ClyTraitChild1 classSide localMethods).  self assert: (result includesAll: ClyClassWithTraits localMethods).  self assert: (result includesAll: ClyClassWithTraits classSide localMethods).  self deny: (result includesAll: ClyTraitRoot1 localMethods).  self deny: (result includesAll: ClyTraitRoot1 classSide localMethods)-=JUAMPI=-setUpActiveScope  systemQuery isBoundToEnvironment ifFalse: [ systemQuery := systemQuery withScope: self systemScope ].  (queryScopes includes: systemQuery scope) ifFalse: [ queryScopes add: systemQuery scope ].  activeScope := systemQuery scope-=JUAMPI=-scopeNames  ^self scopes collect: [:each |  each description capitalized ]-=JUAMPI=-toolWasRemoved  -=JUAMPI=-defaultMenuItemName  ^'Jump to test class'-=JUAMPI=-defaultNavigationScope  ^self isScopedModeEnabled ifFalse: [ super defaultNavigationScope ] ifTrue: [ packageView query scope ]-=JUAMPI=-isAboutSelectedItem: aDataSourceItem  (selectedItems anySatisfy: [:each |  each actualObject == aDataSourceItem actualObject ]) ifTrue: [ ^true ].  (selectedItems anySatisfy: [:each |  each name = aDataSourceItem name ]) ifFalse: [ ^false ].  ^selectedItems anySatisfy: [:each |  each isEqualTo: aDataSourceItem ]-=JUAMPI=-checkEmptyResult  ^critiqueQuery hasEmptyResult-=JUAMPI=-tools: anObject  tools := anObject-=JUAMPI=-hasEmptyResult  ^scope isQueryEmpty: self-=JUAMPI=-singleBasisSample  ^ClyClass1FromP1 package-=JUAMPI=-toggle  textMorph lineNumbersRuler ifNil: [ textMorph withLineNumbers ] ifNotNil: [ textMorph withoutLineNumbers ].  self updateLabel-=JUAMPI=-ensureVisibleLastItem  rootDataSource table ensureVisibleFirstSelection-=JUAMPI=-forceRebuild  actualResult forceRebuild-=JUAMPI=-fillStatusBar  self belongsToCurrentBrowserContext ifFalse: [ statusBar addContextItem: (ClyToolContextNavigatorMorph for: self) ]-=JUAMPI=-hash  ^super hash bitXor: variableQuery hash-=JUAMPI=-testMoveToItemWhichSatisfiesConditionWhenItNotExistsInCache  | found |  cursor cleanCache.  found := cursor moveToItemWhich: [:each |  each actualObject = Object ].  self assert: found.  self assert: cursor position equals: 2.  self assert: cursor currentItem actualObject equals: Object-=JUAMPI=-testVariableNamedThisContext_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'ThisContext') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext lookupSymbol: #ThisContext)]')-=JUAMPI=-testNotSelectsMethodWithoutWatchpoint  self deny: (query selectsMethod: self class >> #methodWithoutWatchpoint)-=JUAMPI=-execute  | class |  class := browser searchDialog requestSingleObject: 'Choose class' from: ClyAllClassesQuery sorted.  browser selectClass: class-=JUAMPI=-decorateBrowserItem: anItem ofPackage: aPackage  -=JUAMPI=-testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> #method1).  self assert: (resultItems identityIncludes: self class >> #method2)-=JUAMPI=-bindTo: aScope in: aNavigationEnvironment  aScope bindTo: aNavigationEnvironment.  self scope: aScope-=JUAMPI=-activationPriority  ^-100-=JUAMPI=-method1  -=JUAMPI=-metaLevelScope: anObject  metaLevelScope := anObject-=JUAMPI=-createBlockFromPattern  (pattern value endsWith: ']') ifFalse: [ badScript := true.        ^self ].  [ scriptBlock := self class compiler evaluate: pattern value ] on: Exception do: [:err |  badScript := true ]-=JUAMPI=-build  self addMorphBack: label-=JUAMPI=-metadata  ^metadata ifNil: [ self collectMetadata.        metadata ]-=JUAMPI=-updateTabsWith: newTools  | toRemove toInstall |  toRemove := OrderedCollection withAll: tools.  toInstall := OrderedCollection new.  newTools do: [:new |  tools detect: [:existing |  existing isSimilarTo: new ] ifFound: [:existing |  toRemove remove: existing ] ifNone: [ toInstall add: new ] ].  toRemove do: [:each |  each wantsStayInDifferentContext ifFalse: [ each removeFromBrowser ] ].  tools do: [:each |  each browserContextWasChanged ].  toInstall do: [:each |  self addTool: each ]-=JUAMPI=-isSameAsCurrent: anObject  isSameAsCurrent := anObject-=JUAMPI=-adoptLocalScopeClassTo: aLocalScopeClass  localScopeClass := aLocalScopeClass-=JUAMPI=-createQueryResult  ^ClyClassBindings new-=JUAMPI=-requestSingleObject: dialogTitle from: aQuery inScope: aScope  aScope bindTo: browser navigationEnvironment.  ^self requestSingleObject: dialogTitle from: (aScope adoptQuery: aQuery)-=JUAMPI=-testBasedOnMultipleBasis  scope := self multipleScopeSample.  self assert: scope isBasedOnMultipleBasis.  scope := self singleScopeSample.  self deny: scope isBasedOnMultipleBasis.  scope := self emptyScopeSample.  self deny: scope isBasedOnMultipleBasis-=JUAMPI=-defaultMenuIconName  ^#trait-=JUAMPI=-critique  ^critique-=JUAMPI=-affectsMethods  ^true-=JUAMPI=-execute  UIManager default debugProcess: Processor activeProcess context: critique stack label: critique message fullView: true-=JUAMPI=-testMethodsEnumeration  | expected |  scope := ClyClassScope of: ClyClass1FromP1.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArray-=JUAMPI=-changeStateBy: aBlock  aBlock value-=JUAMPI=-execute  script executeOn: targetClass-=JUAMPI=-initialize  super initialize.  basisObjects := #()-=JUAMPI=-findItemsSimilarTo: dataSourceItems  | myItems childItems |  myItems := super findItemsSimilarTo: dataSourceItems.  myItems size == dataSourceItems size ifTrue: [ ^myItems ].  childItems := expandedItems flatCollect: [:each |  each childrenDataSource findItemsSimilarTo: dataSourceItems ].  ^myItems , childItems-=JUAMPI=-packagesDo: aBlock  self system packages do: aBlock-=JUAMPI=-prepareExecutionInDropContext: aToolContext  super prepareExecutionInDropContext: aToolContext.  package := aToolContext lastSelectedPackage-=JUAMPI=-targetClass  ^targetClass-=JUAMPI=-conditionBlock: anObject  conditionBlock := anObject-=JUAMPI=-prepareInitialState  -=JUAMPI=-basisObjects: aCollection  super basisObjects: (self prepareBasisFrom: aCollection)-=JUAMPI=-decorateOwnBrowserItem: myItem  super decorateOwnBrowserItem: myItem.  classQuery decorateItemGroup: myItem.  subgroupsQuery decorateItemGroup: myItem-=JUAMPI=-defaultMenuItemName  ^'Writers'-=JUAMPI=-allowsDifferentActivationPriority  ^true-=JUAMPI=-testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  < expectedFailure>  super testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject-=JUAMPI=-readerOfVar1  ^writtenVar1-=JUAMPI=-selectedPackageItems  ^tool packageSelection items-=JUAMPI=-selectsMethod: aMethod  | plugin |  plugin := self environment getPlugin: ClyReflectiveEnvironmentPlugin.  ^plugin doesMethodHasWatchpoint: aMethod-=JUAMPI=-representsConcreteQuery  ^true-=JUAMPI=-findItemsSimilarTo: sampleBrowserItems  ^cache findItemsWith: (sampleBrowserItems collect: #actualObject) forAbsentDo: [ ^queryResult findItemsSimilarTo: sampleBrowserItems ]-=JUAMPI=-fillWith: classes  | definedClasses extensions |  definedClasses := IdentitySet withAll: classes.  extensions := OrderedCollection new.  classes do: [:each |  (self isQueryScopeDefinesClass: each) ifFalse: [ definedClasses remove: each.              extensions add: each ] ].  items := self buildItemsFrom: definedClasses.  items addAll: (self buildExtensionItemsFrom: extensions)-=JUAMPI=-methodGroupType  ^ClyVariable-=JUAMPI=-isCommandAvailable: aCommand  ^aCommand canBeExecutedInCodeMethodEditor: self-=JUAMPI=-defaultMenuIconName  ^#smallRedo-=JUAMPI=-superclassVar1WriterMethod  instanceSideVar1 := #subclassVar1Value-=JUAMPI=-extraBasisSample  ^ClySubclassMOfClass1FromP2 package-=JUAMPI=-testConvertingToSomeHierarchyScope  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asScope: ClySubclassScope.  self assert: convertedScope class equals: ClySubclassScope.  self assert: convertedScope localScopeClass equals: scope localScopeClass.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environment-=JUAMPI=-defaultItems  ^SortedCollection sortBlock: sortFunction-=JUAMPI=-direction: anObject  direction := anObject-=JUAMPI=-isParentExpanded  parentItem ifNil: [ ^true ].  ^parentItem isExpanded-=JUAMPI=-testIsExecutedFromConcreteScopeClass  self assert: (query isExecutedFromScope: query scope class).  self assert: (query isExecutedFromScope: query scope class superclass).  self deny: (query isExecutedFromScope: ClyScopeExample2)-=JUAMPI=-testConvertingAsRestrictedByAnotherScope2  | convertedScope restrictedScope |  scope := self singleScopeSample.  restrictedScope := self multipleScopeSample.  convertedScope := scope restrictedBy: restrictedScope.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects equals: restrictedScope basisObjects-=JUAMPI=-classSampleWhichHasGroup  ^ClySubclassN1OfClass1FromP1-=JUAMPI=-hash  ^super hash bitXor: pattern hash-=JUAMPI=-start  ^start-=JUAMPI=-isMultipleSelected  ^items size > 1-=JUAMPI=-showVariableNamed: aString  tool selectVariableNamed: aString-=JUAMPI=-includesClass: aClass  self classesDo: [:each |  each = aClass ifTrue: [ ^true ] ].  ^false-=JUAMPI=-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  | icon |  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  icon := anItemCellMorph definitionIcon: #flagIcon.  icon setBalloonText: 'There are methods with flag'-=JUAMPI=-printContext  ^''-=JUAMPI=-description  ^'all method groups'-=JUAMPI=-decorateResultMethodEditor: aMethodEditor  criteriaString ifNil: [ ^self ].  aMethodEditor selectStringAsInMessageBrowser: criteriaString-=JUAMPI=-execute  browser switchToVariables-=JUAMPI=-variableQuery: aVariableQuery  variableQuery := aVariableQuery-=JUAMPI=-createBrowser  ^ClyFullBrowser new-=JUAMPI=-description  ^'Do not supported currently'-=JUAMPI=-queryScope: anObject  queryScope := anObject-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  testItems := aToolContext selectedItems select: [:each |  each hasProperty: ClyTestResultProperty ]-=JUAMPI=-initialize  super initialize.  undoExecuting := false.  redoExecuting := false.  waitingNewState := true.  undoList := OrderedCollection new.  redoList := OrderedCollection new-=JUAMPI=-createQuery  ^ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: #basisObject in: environment-=JUAMPI=-defaultMenuItemName  ^'Run script'-=JUAMPI=-defaultMenuItemName  ^'Move to package'-=JUAMPI=-activeWindow  self tabGroup pages size = 0 ifTrue: [ ^nil ].  self tabGroup selectedPageIndex <= 0 ifTrue: [ ^nil ].  ^self tabGroup pages at: self tabGroup selectedPageIndex-=JUAMPI=-initialize  super initialize.  methodTags := #()-=JUAMPI=-testCheckIfEmpty  self installCounterInto: #methodWithCounter.  query scope: (ClyMethodScope of: self class >> #methodWithCounter in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-=JUAMPI=-littleHierarchyMaxSize: anObject  littleHierarchyMaxSize := anObject-=JUAMPI=-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red-=JUAMPI=-affectedPackage: anObject  affectedPackage := anObject-=JUAMPI=-execute  browser switchToProjects-=JUAMPI=-execute  | queries fullQuery |  queries := methodGroups collect: [:each |  each methodQuery ].  fullQuery := ClyQuery unionFrom: queries.  browser spawnQueryBrowserOn: fullQuery-=JUAMPI=-initialize  super initialize.  collapsedItems := SortedCollection sortBlock: [:a :b |  a position < b position ]-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  browser := aToolContext browser-=JUAMPI=-isPrepared  ^isPrepared-=JUAMPI=-defaultMenuItemName  ^'Add breakpoint condition..'-=JUAMPI=-testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  < expectedFailure>  super testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects-=JUAMPI=-hierarchy  ^hierarchy-=JUAMPI=-allItems  ^self prepareItems: actualResult allItems-=JUAMPI=-decorateBrowserItem: anItem ofPackage: aPackage  aPackage isDeprecated ifTrue: [ anItem markWith: ClyDeprecatedItemTag ]-=JUAMPI=-query: aQuery  ^ClyUnknownQueryResult instance-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  classQuery printOn: aStream.  aStream nextPut: $)-=JUAMPI=-methodWithoutCritiques  ^ClyClassWithProblemMethods >> #methodWithoutCritiques-=JUAMPI=-findTestedClassCoveredBy: aTestClass ifAbsent: absentBlock  | className |  className := aTestClass instanceSide name.  (className endsWith: 'Tests') ifTrue: [ ^environment system classNamed: (className allButLast: 5) asSymbol ifAbsent: absentBlock ].  (className endsWith: 'Test') ifTrue: [ ^environment system classNamed: (className allButLast: 4) asSymbol ifAbsent: absentBlock ].  ^absentBlock value-=JUAMPI=-newName  ^newName-=JUAMPI=-prepareIn: aNavigationEnvironment  isPrepared ifTrue: [ ^self ].  aNavigationEnvironment pluginsDo: [:each |  self decorateBy: each ].  isPrepared := true-=JUAMPI=-tableCellIcon  ^Smalltalk ui iconNamed: #halt-=JUAMPI=-restoreBrowserState  self browser selectObject: self lastSelectedObject-=JUAMPI=-testConvertingAsRestrictedByAnotherScope  | convertedQuery restrictedScope |  restrictedScope := ClyScopeExample2 of: #restrictedBasis.  convertedQuery := query restrictedByScope: restrictedScope.  self assert: convertedQuery class equals: query class.  self assert: convertedQuery requiredResult identicalTo: query requiredResult.  self assert: (convertedQuery subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (convertedQuery subqueries collect: #scope) equals: (query subqueries collect: [:each |  each scope withNewBasisObjects: #(restrictedBasis) ])-=JUAMPI=-normalizeSelectorForComparison: aString  | selectorString selectorStringSize normalizedSelectorString normalizedSelectorStringSize |  selectorString := aString asString.  selectorStringSize := aString size.  normalizedSelectorString := selectorString class new: selectorStringSize.  normalizedSelectorStringSize := 0.  1 to: selectorStringSize do: [:i |  | nextChar |        (nextChar := selectorString at: i) == $: ifFalse: [ normalizedSelectorString at: (normalizedSelectorStringSize := normalizedSelectorStringSize + 1) put: nextChar ] ].  ^(normalizedSelectorStringSize < selectorStringSize ifTrue: [ normalizedSelectorString first: normalizedSelectorStringSize ] ifFalse: [ selectorString ]) asLowercase-=JUAMPI=-defaultMenuItemName  ^'Show in method browser'-=JUAMPI=-selectsMethod: aMethod  ^aMethod isExtension-=JUAMPI=-toggleFullWindowTabs  | tabMorph |  tabMorph := tabManager tabMorph.  (submorphs includes: tabMorph) ifFalse: [ self addMorph: tabMorph fullFrame: LayoutFrame identity ] ifTrue: [ toolPanel addMorphBack: tabMorph ]-=JUAMPI=-methodGroups  ^methodGroups-=JUAMPI=-prepareExecutionInDropContext: aToolContext  | selectedClasses |  super prepareExecutionInDropContext: aToolContext.  methodGroup := aToolContext lastSelectedMethodGroup.  selectedClasses := aToolContext selectedClasses.  selectedClasses := selectedClasses collect: [:each |  aToolContext currentMetaLevelOf: each ].  targetClass := selectedClasses size > 1 ifTrue: [ aToolContext requestSingleClass: 'In what class you want to move method?' from: selectedClasses ] ifFalse: [ selectedClasses last ]-=JUAMPI=-decorateMethodEditor: aMethodEditor  methodView query decorateResultMethodEditor: aMethodEditor-=JUAMPI=-methodWithoutBreakpoints  -=JUAMPI=-testCreationWithSingleSubqueryButAnotherResult  | subquery |  subquery := self subqueryFromScopeOf: Array.  query := ClyUnionQuery with: {subquery} as: #specialResult.  self assert: query class equals: subquery class.  self assert: query scope equals: subquery scope.  self assert: query requiredResult equals: #specialResult.  self deny: subquery requiredResult equals: #specialResult-=JUAMPI=-addNewCommentForTestClass: aClass basedOn: baseClass  aClass comment: (String streamContents: [:stream |  | name |              name := aClass name.              name first isVowel ifTrue: [ stream nextPutAll: 'An ' ] ifFalse: [ stream nextPutAll: 'A ' ].              stream                 nextPutAll: name;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: baseClass name ])-=JUAMPI=-testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self deny: query isExecutedFromSingleScope-=JUAMPI=-testClass  ^testClass-=JUAMPI=-createTableCellButtonWith: anIcon using: aCommandActivator  | button |  button := super createTableCellButtonWith: anIcon using: aCommandActivator.  sourceNode hasExecutionCounter ifTrue: [ ClyDynamicBallonTooltip from: [ self tableDescription ] installInto: button ].  ^button-=JUAMPI=-execute  browser spawnQueryBrowserOn: (ClyVariableReferencesQuery ofAny: variables)-=JUAMPI=-testCreationFromAnotherCompositeQueryAndSimilarQuery  | subquery1 subquery2 subquery3 |  subquery1 := self subqueryFromScopeOf: Array.  subquery2 := self subqueryFromScope: ClyScopeExample2 of: String.  subquery3 := self subqueryFromScopeOf: Object.  query := subquery1 , subquery2 , subquery3.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {(self subqueryFromScope: (ClyScopeExample ofAll: {Array .                     Object})) .         subquery2} asSet.  self assert: query requiredResult equals: subquery1 requiredResult-=JUAMPI=-requestSingleClass: queryTitle  ^tool searchDialog requestSingleObject: queryTitle from: ClyAllClassesQuery sorted-=JUAMPI=-hash  ^super hash bitXor: hierarchy hash-=JUAMPI=-packageScopeOfSelectedItems  | packages |  packages := self selection items collect: [:methodItem |  methodItem systemDefinition definingPackage ].  ^ClyPackageScope ofAll: packages in: navigationEnvironment-=JUAMPI=-buildsDefaultResult  ^self retrievesItemsAs: self defaultResult class-=JUAMPI=-isMethodSelected  ^false-=JUAMPI=-copyForBrowserStateSnapshotOf: rootDataSourceSnapshot  | copy ownerDataSourceSnapshot |  ownerDataSourceSnapshot := rootDataSourceSnapshot findDataSourceSameAs: ownerDataSource ifNone: [ self error: 'should not happen' ].  copy := self copy.  copy ownerDataSource: ownerDataSourceSnapshot.  childrenDataSource ifNotNil: [ copy childrenDataSource: childrenDataSource copyForBrowserStateSnapshot ].  ^copy-=JUAMPI=-shouldSkipCurrentDesiredSelection  ^shouldSkipCurrentDesiredSelection-=JUAMPI=-testResult  ^testResult-=JUAMPI=-defaultMenuItemName  ^'Inspect'-=JUAMPI=-ownerTool  ^ownerTool-=JUAMPI=-simpleNameForSpotterMenu  ^'Variables'-=JUAMPI=-fillWith: packages  | group |  packages do: [:each |  group := ClyExternalPackageMethodGroup withMethodsFrom: self scope packagedIn: each.        items add: group ]-=JUAMPI=-canDetectAffectOnClassesBy: aSystemAnnouncement  ^(aSystemAnnouncement isKindOf: ClassAnnouncement) not-=JUAMPI=-defaultMenuIconName  ^#glamorousBrowse-=JUAMPI=-isAssignmentSelected  | node |  node := self selectedSourceNode.  [ node notNil ] whileTrue: [ node isAssignment ifTrue: [ ^true ].        node := node parent ].  ^false-=JUAMPI=-setUp  super setUp.  environment := nil-=JUAMPI=-extendClassScopeForMethods: aClassScope  | resultScope |  resultScope := aClassScope.  (ClyMethodVisibilityLevel allAvailableFor: self classSelection items) ifNotEmpty: [:levels |  resultScope := levels anyOne extendClassScope: resultScope ].  ^resultScope-=JUAMPI=-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-=JUAMPI=-testClassEnumerationOverClassWhenBothMetaLevelsAreLocalScope  | expected |  scope := ClySubclassScope of: Class localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:each |  result add: each ].  expected := Class subclasses select: #isInstanceSide.  expected := expected flatCollect: [:each |  {each instanceSide .         each classSide} ].  self assert: result asSet equals: expected asSet-=JUAMPI=-critique: anObject  critique := anObject-=JUAMPI=-testComparisonToSimilarQueryButWithDifferentTag  | query2 |  query tag: #tag1.  query2 := self createQuery.  query2 tag: #anotherTag.  self deny: query equals: query2-=JUAMPI=-open  | query methods comments |  methods := messages select: [:each |  (each isRingObject and: [ each isMethod ]) or: [ each isCompiledMethod ] ] thenCollect: [:each |  each compiledMethod ].  comments := messages select: [:each |  each isRingObject and: [ each isComment ] ] thenCollect: [:each |  ClyClassComment of: each parent realClass ].  query := ClyOldMessageBrowserQuery named: title with: methods asOrderedCollection , comments.  query     criteriaString: autoSelect;     criteriaBlock: refreshingBlock.  openedBrowser := ClyQueryBrowser openOn: query-=JUAMPI=-isSelectedItemHasWatchpoint  ^selectedSourceNode hasWatchpoint-=JUAMPI=-includesMethod: aMethod  self asyncQueryResult isBuilt ifFalse: [ ^false ].  ^super includesMethod: aMethod-=JUAMPI=-attachToSystem  browser system when: (ClyMethodChange of: self editingMethod) send: #triggerUpdate to: self-=JUAMPI=-referenceOfNumberClassByNameSymbol  ^#Number-=JUAMPI=-update  leftMethod := leftMethod origin localMethodNamed: leftMethod selector ifAbsent: [ ^self ].  rightMethod := rightMethod origin localMethodNamed: rightMethod selector ifAbsent: [ ^self ].  super update.  diffMorph from: leftMethod sourceCode to: rightMethod sourceCode-=JUAMPI=-printDefinition  ^definingPackageItem name-=JUAMPI=-methodTags  ^methodTags-=JUAMPI=-scopeWithCritiques  ^ClyMethodScope of: self methodWithCritiques in: environment-=JUAMPI=-setUp  super setUp.  browser prepareInitialState-=JUAMPI=-isClassVariable  ^true-=JUAMPI=-browserPlugins  ^browserPlugins-=JUAMPI=-isEmpty  ^self itemCursor itemCount = 0-=JUAMPI=-isQueryEmpty: aQuery  self isBasedOnEmptyBasis ifTrue: [ ^true ].  aQuery ensureScope: self.  ^environment isQueryEmpty: aQuery-=JUAMPI=-supeclassWriterOfVar1  writtenVar1 := #superclassValue-=JUAMPI=-testConvertingToInheritedScope  | convertedScope |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope asInheritedScope.  self assert: (convertedScope representsScope: ClySuperclassScope).  self assert: convertedScope localScopeClass equals: ClyInstanceSideScope.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environment.  self assert: convertedScope name equals: ClyClassScope inheritedScopeName-=JUAMPI=-selectMethodGroupNamed: tagName  self changeStateBy: [ self methodGroupSelection selectItemsWhere: [:each |  each name = tagName ] ]-=JUAMPI=-testDecoratingMethodWithExecutionCounter  | plugin method methodItem |  plugin := ClyReflectiveEnvironmentPlugin new.  self installWatchpointInto: #methodWithWatchpoint.  method := self class >> #methodWithWatchpoint.  methodItem := method asCalypsoBrowserItem.  plugin decorateBrowserItem: methodItem ofMethod: method.  self assert: (methodItem isMarkedWith: ClyMethodWithWatchpointTag)-=JUAMPI=-subgroupsQuery: anObject  subgroupsQuery := anObject-=JUAMPI=-testForceLazyRebuild  self assert: queryResult items notNil.  queryResult forceLazyRebuild.  self assert: queryResult needsRebuild-=JUAMPI=-createQuery  ^ClyUntaggedClassesQuery from: (ClyClassScope of: Object in: environment)-=JUAMPI=-addContextItem: aMorph  contextBar addMorphBack: aMorph.  ^aMorph-=JUAMPI=-restoreTableSelectionSilently: silentSelection  | selectionIndexes |  items := items reject: [:each |  each isRemoved ].  selectionIndexes := items collect: #globalPosition.  self setUpSelectedRows: selectionIndexes in: rootDataSource table silently: silentSelection-=JUAMPI=-includesVariablesAffectedBy: aSystemAnnouncement  self classesDo: [:class |  (aSystemAnnouncement affectsVariablesOf: class) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-createQuery  ^ClyMethodWatchpointsQuery from: ClyClassScope of: self class in: environment-=JUAMPI=-collapsedButton  ^IconicButton new     target: item;     actionSelector: #expand;     arguments: {};     labelGraphic: self theme treeUnexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-=JUAMPI=-senderOfIfTrue  ^2 * 2 = 4 ifTrue: [ 100 ]-=JUAMPI=-hash  ^super hash bitXor: baseQueryResult hash-=JUAMPI=-affectsMethodsDefinedInClass: aClass  ^(aClass includesLocalSelector: self overriddenMethod selector) and: [ aClass inheritsFrom: self overriddenMethod origin ]-=JUAMPI=-context  ^context-=JUAMPI=-retrievesItem: aVariable  ^aVariable isKindOf: ClyInstanceVariable-=JUAMPI=-testFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}-=JUAMPI=-packageOrganizer  ^packageOrganizer-=JUAMPI=-itemsChanged  navigationStarted ifTrue: [ ^self ].  navigationStarted := true.  [ self rebuildToolsForChangedEnvironment ] ensure: [ navigationStarted := false ]-=JUAMPI=-actualObject: anObject  ^browserItem actualObject: anObject-=JUAMPI=-withInheritedScope  | fullScope |  fullScope := self , self asInheritedScope.  fullScope name: self class hierarchyScopeName.  ^fullScope-=JUAMPI=-deprecatedMethod2  self deprecated: 'it is deprecated method for testing deprecation analyzis'-=JUAMPI=-testConvertingToInterestingClassScope  | convertedScope |  scope := ClyMultipleClassRelationScope of: {String} merging: {ClySuperclassScope .         ClySubclassScope}.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope asInterestingClassScope.  self deny: convertedScope identicalTo: scope.  self assert: convertedScope class equals: ClyMultipleClassRelationScope.  self assert: convertedScope relationScopeClasses equals: {ClyInterestingSuperclassScope .         ClySubclassScope}.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope localScopeClass equals: scope localScopeClass.  self assert: convertedScope environment equals: scope environment-=JUAMPI=-testExecution  | scope mainQuery |  scope := ClyScopeExample ofAll: {self class superclass .         self class} in: environment.  mainQuery := ClyQueryExampleReturningScopeBasis from: scope.  query subqueries: {mainQuery}.  self executeQuery.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self class-=JUAMPI=-groupProviderClass  ^ClyExtendedClassGroupProvider-=JUAMPI=-isResult: aQueryResult affectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsClassExtension and: [ scope includesMethodsAffectedBy: aSystemAnnouncement ]-=JUAMPI=-ownerDataSource  ^ownerDataSource-=JUAMPI=-buildResult: aQueryResult  | result |  result := OrderedCollection new.  self analyzedObjectsDo: [:each |  result addAll: each critiques ].  aQueryResult fillWith: result-=JUAMPI=-execute  browser navigateBack-=JUAMPI=-execute  browser spawnQueryBrowserOn: (ClyClassReferencesQuery toAny: classes)-=JUAMPI=-isExecutedFromSingleScope  ^scope isBasedOnSingleBasis-=JUAMPI=-testNotBasedOnSingleBasisWhenSingleSubscopeIsNot  | subscope |  subscope := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {subscope}.  self deny: scope isBasedOnSingleBasis-=JUAMPI=-detachFromTextMorph  -=JUAMPI=-description  ^'Method watchpoints'-=JUAMPI=-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-=JUAMPI=-defaultIconName  ^#scriptManagerIcon-=JUAMPI=-name: anObject  name := anObject-=JUAMPI=-withoutBasisObject: existingBasisObject  ^self withNewBasisObjects: (basisObjects copyWithout: existingBasisObject)-=JUAMPI=-testSelectedChildInExpandedItemWithRetrievedExpandedDataSource  | selectedItem retrievedSelectedItem |  self selectedItem expand.  selectedItem := self selectedItem childrenDataSource elementAt: 1.  queryView selection selectItems: {selectedItem}.  self snapshotState.  retrievedSelectedItem := navigationState selection items first.  self assert: retrievedSelectedItem ownerDataSource equals: navigationState dataSource expandedItems first childrenDataSource-=JUAMPI=-searchText: aString  | found |  found := self itemCursor moveToItemWhich: [:each |  each name asLowercase beginsWith: aString asLowercase ].  ^found ifFalse: [ #() ] ifTrue: [ {self itemCursor position} ]-=JUAMPI=-createQuery  ^ClyPackageExtensionMethodsQuery of: ClyClass1FromP1 package from: (ClyClassScope of: ClyClass1FromP1 in: environment)-=JUAMPI=-priority  ^0-=JUAMPI=-extraBasisSample  ^ClyClass2FromP1-=JUAMPI=-addNewCommentForTestClass: aClass basedOn: baseClass  aClass comment: (String streamContents: [:stream |  | name |              name := aClass name.              name first isVowel ifTrue: [ stream nextPutAll: 'An ' ] ifFalse: [ stream nextPutAll: 'A ' ].              stream                 nextPutAll: name;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: baseClass name ])-=JUAMPI=-scope: aScope  super scope: aScope.  critiqueQuery scope: aScope-=JUAMPI=-isCaseSensitive  ^isCaseSensitive-=JUAMPI=-windowIsClosing  tools do: [:each |  each cleanAfterRemove ]-=JUAMPI=-applyTo: aBrowser  aBrowser changeStateBy: [ self restoreStateOf: aBrowser.        self restoreNavigationStateOf: aBrowser.        aBrowser tabManager restoreBrowserState: self ]-=JUAMPI=-classSampleWhichHasGroup  ^ClyClass1FromP1-=JUAMPI=-testConvertingWithExtraBasisObjectIfItIsAlreadyBasis  | convertedScope |  scope := self createSampleScope.  convertedScope := scope withExtraBasisObject: scope basisObjects anyOne.  self assert: convertedScope basisObjects equals: scope basisObjects-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithDeprecatedMethods >> #deprecatedMethod1) .         (ClyClassWithDeprecatedMethods >> #deprecatedMethod2) .         (ClyClassWithDeprecatedMethods >> #notDeprecatedMethod)}.  self assert: foundSelectors sorted asArray equals: #(deprecatedMethod1 deprecatedMethod2)-=JUAMPI=-testMatchesAnyStringWhenItIsBadRegex  | pattern |  pattern := ClyRegexPattern with: '!*'.  self assert: (pattern matches: 'any string')-=JUAMPI=-systemScope  ^systemScope ifNil: [ systemScope := navigationEnvironment systemScope ]-=JUAMPI=-closeDataSource  table initialDataSource ifNil: [ ^self dataSource close ].  table cleanupFilter.  table initialDataSource close-=JUAMPI=-doItContext  ^nil-=JUAMPI=-testExpectedMethodShouldIncludeExpectedString  self assert: ((self class >> #methodWithExpectedStringInSources) sourceCode includesSubstring: self expectedSourceCodeSubstring caseSensitive: false)-=JUAMPI=-chooseClassesForNewMethod: aMethod  | methodClass selectedClasses |  methodClass := aMethod origin.  selectedClasses := self chooseClassesForNewMethod.  selectedClasses := selectedClasses copyWithout: methodClass.  ^selectedClasses , {methodClass}-=JUAMPI=-findItemsSimilarTo: dataSourceItems  | foundItems relatedItems |  relatedItems := dataSourceItems select: [:each |  self isBasedOnQueryOf: each type ] thenCollect: [:each |  each browserItem ].  foundItems := self itemCursor findItemsSimilarTo: relatedItems.  ^foundItems collect: [:each |  self createElementWith: each ]-=JUAMPI=-pluginsDo: aBlock  ^plugins do: aBlock-=JUAMPI=-isActiveInContext: aBrowserContext  ^(super isActiveInContext: aBrowserContext) and: [ self toolClass shouldBeActivatedInContext: aBrowserContext ]-=JUAMPI=-selection: anObject  selection := anObject-=JUAMPI=-testExpandedItemWithRetrievedOwnerDataSource  | expandedItem |  self selectedItem expand.  self snapshotState.  expandedItem := navigationState dataSource expandedItems first.  self assert: expandedItem ownerDataSource equals: navigationState dataSource-=JUAMPI=-collectMetadataOf: aQueryResult by: anEnvironmentPlugin  anEnvironmentPlugin collectMetadataOfClasses: aQueryResult-=JUAMPI=-testFromClassScope  self queryFromScope: ClyClassScope ofAll: {self class .         self class superclass}.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: (ClyClassComment of: self class)-=JUAMPI=-description  ^'writers of ' , self printVariables-=JUAMPI=-testAscendingDifferentPackage  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: Object >> #printString value: Number >> #printString).  self assert: (function value: Number >> #printString value: Object >> #printString).  self assert: (function value: Object >> #printOn: value: Object >> #printString)-=JUAMPI=-lastSelectedSourceNode  ^self selectedSourceNode-=JUAMPI=-isResult: aQueryResult affectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsClasses or: [ aSystemAnnouncement canAffectResultOfMethodQuery: self ]-=JUAMPI=-lastSelectedClassGroup  ^self lastSelectedObject-=JUAMPI=-testSelectsDeprecatedMethod  self assert: (query selectsMethod: ClyClassWithDeprecatedMethods >> #deprecatedMethod1)-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: value;     nextPut: $)-=JUAMPI=-createUpdateWithItemsStartingAt: startPosition count: cacheSize  | itemCache |  itemCache := ClyBrowserQueryCache filledBy: self startingAt: startPosition size: cacheSize.  ^ClyBrowserQueryUpdate of: self withItems: itemCache-=JUAMPI=-defaultPackageFilter  ^DefaultPackageFilter ifNil: [ DefaultPackageFilter := ClyTableFilterFactory of: ClyItemNameFilter using: ClyRegexPattern new ]-=JUAMPI=-decorateBrowserItem: anItem ofMethodGroup: aMethodGroup  -=JUAMPI=-metaLevelsOf: aClass do: aBlock  self class metaLevelsOf: aClass do: aBlock-=JUAMPI=-testCheckIfEmpty  self installWatchpointInto: #methodWithWatchpoint.  query scope: (ClyMethodScope of: self class >> #methodWithWatchpoint in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-=JUAMPI=-testIsExecutedFromEmptyScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self deny: query isExecutedFromEmptyScope.  query scope: (ClyScopeExample emptyIn: environment).  self assert: query isExecutedFromEmptyScope-=JUAMPI=-buildResult: aQueryResult  | filteredClasses |  filteredClasses := Set new.  scope classesDo: [:each |  (self selectsClass: each) ifTrue: [ filteredClasses add: each ] ].  aQueryResult fillWith: filteredClasses-=JUAMPI=-createQueryResult  ^ClyMethodVisibilityGroups withHierarchy: ClySubclassHierarchy new-=JUAMPI=-methodGroupView  ^methodGroupView-=JUAMPI=-classCommentsContainingIt  | query |  self lineSelectAndEmptyCheck: [ ^self ].  query := ClyClassCommentsQuery withString: self selection string.  self browser spawnQueryBrowserOn: query-=JUAMPI=-initialize  super initialize.  cacheGuard := Mutex new.  littleHierarchyMaxSize := 10-=JUAMPI=-isComplexRefactoring  ^true-=JUAMPI=-containerForItemsOfClass  ^SortedCollection sortBlock: ClySortSystemItemFunction ascending forBrowserItems-=JUAMPI=-announceChangesOf: aQueryResult  self subclassResponsibility-=JUAMPI=-isEditableGroup  ^self class isEditableGroup-=JUAMPI=-browser  ^item browser-=JUAMPI=-isNavigationPanelFocused  ^navigationViews anySatisfy: [:each |  each hasKeyboardFocus ]-=JUAMPI=-defineTrait: defString notifying: aController startingFrom: aClass  | defTokens keywdIx oldTrait newTraitName trait |  aClass isTrait ifTrue: [ oldTrait := aClass ].  defTokens := defString findTokens: Character separators.  keywdIx := defTokens findFirst: [:x |  x = 'category' ].  keywdIx := defTokens findFirst: [:x |  x = 'named:' ].  newTraitName := (defTokens at: keywdIx + 1) copyWithoutAll: '#()'.  ((oldTrait isNil or: [ oldTrait instanceSide name asString ~= newTraitName ]) and: [ self includesClassNamed: newTraitName asSymbol ]) ifTrue: [ (self confirm: ((newTraitName , ' is an existing class/trait in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newTraitName size)) ifFalse: [ ^nil ] ].  trait := self defaultClassCompiler     source: defString;     requestor: aController;     logged: true;     evaluate.  ^trait isTrait ifTrue: [ trait ] ifFalse: [ nil ]-=JUAMPI=-requiredQueryResult  ^systemQuery ifNil: [ self class defaultQueryResult ] ifNotNil: [ systemQuery requiredResult ]-=JUAMPI=-selectItemsWhere: conditionBlock  | newItems |  newItems := rootDataSource findItemsWhere: conditionBlock.  self selectItems: newItems-=JUAMPI=-createPackageNamed: packageName  ^packageOrganizer createPackageNamed: packageName-=JUAMPI=-itemsStartingWhere: conditionBlock count: size  ^self prepareItems: (actualResult itemsStartingWhere: conditionBlock count: size)-=JUAMPI=-testClassEnumerationOverMetaclassWhenClassSideIsLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassSideScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {Object class .         ProtoObject class} asSet-=JUAMPI=-notifyChanges  announcer announce: ClyEnvironmentChanged-=JUAMPI=-testFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reference1OfVar1) .         (self class >> #referenceOfAnotherVar)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfVar1-=JUAMPI=-execute  browser switchFocusToPreviousPane-=JUAMPI=-testFillingWithThreeClasVarsOfSuperclassAndSubclass  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #SubclassClassVar definedIn: ClySubclassLOfClass2FromP1) .         (ClyClassVariable named: #ClassVar2 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#ClassVar1 #ClassVar2 #SubclassClassVar)-=JUAMPI=-testClassEnumerationOverClassWhenInstanceSideIsLocalScope  | expected |  scope := ClySubclassScope of: Class localScope: ClyInstanceSideScope.  scope classesDo: [:each |  result add: each ].  expected := Class subclasses select: #isInstanceSide.  self assert: result asSet equals: expected asSet-=JUAMPI=-packages: anObject  packages := anObject-=JUAMPI=-collectMethodGroupProviders  ^{ClyUndeclaredMethodGroupProvider new}-=JUAMPI=-affectsMethodsTaggedWith: tagName  overriddenSuperclass withAllSubclassesDo: [:each |  (each tagsForMethods includes: tagName) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-unionWith: typedQueries as: aQueryResult  ^ClyQuery unionFrom: typedQueries , subqueries as: aQueryResult-=JUAMPI=-execute  browser navigateForward-=JUAMPI=-isSimilarTo: anotherBrowserContext  self class = anotherBrowserContext class ifFalse: [ ^false ].  selectedItems size = anotherBrowserContext selectedItems size ifFalse: [ ^false ].  ^selectedItems allSatisfy: [:each |  anotherBrowserContext isAboutSelectedItem: each ]-=JUAMPI=-queryClass  ^ClyVariableWritersQuery-=JUAMPI=-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  subqueries do: [:each |  each decorateMethodGroupTableCell: anItemCellMorph of: groupItem ]-=JUAMPI=-isRemoved  ^browserItem isNil or: [ ownerDataSource isParentRemoved or: [ ownerDataSource isParentCollapsed ] ]-=JUAMPI=-testConvertingToNewBasis  scope := self createSampleScope.  self assert: (scope withNewBasisObjects: #(newBasis)) identicalTo: scope.  self assert: scope basisObjects isEmpty-=JUAMPI=-adoptQuery: aQuery  ^aQuery-=JUAMPI=-withMetaLevel: aMetaLevelScopeClass  self subclassResponsibility-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWhichInheritsAbstractClass >> #abstractMethod1) .         (ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod) .         (ClyClassWhichInheritsAbstractClass >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 #overriddenMethod)-=JUAMPI=-checkEmptyResult  scope methodsDo: [:each |  (self selectsMethod: each) ifTrue: [ ^false ] ].  ^true-=JUAMPI=-testBuildShouldSetUpItemsFromActualResultWhenTheyReady  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self deny: (queryResult hasMetaProperty: ClyBackgroundProcessingTag).  self assert: queryResult items identicalTo: queryResult actualResult items.  self assert: queryResult items asSet equals: query scope basisObjects-=JUAMPI=-displayBlock  ^displayBlock-=JUAMPI=-buildingQuery  ^buildingQuery-=JUAMPI=-decorateBrowserItem: anItem ofClass: aClass  -=JUAMPI=-description  ^'go backward in the navigation history'-=JUAMPI=-label  ^label-=JUAMPI=-includesMethod: aMethod  ^true-=JUAMPI=-removeWithMethods  self methods do: [:each |  each removeFromSystem ]-=JUAMPI=-toggle  | formatter isDirty |  formatter := RBProgramNode formatterClass.  formatter formatAsYouReadPolicy ifTrue: [ formatter formatAsYouReadPolicy: false.        textMorph model canDiscardEdits ifTrue: [ textMorph model cancelEdits ] ] ifFalse: [ formatter formatAsYouReadPolicy: true.        isDirty := textMorph hasUnacceptedEdits.        textMorph model formatSourceCodeInView.        isDirty ifFalse: [ textMorph model clearUserEdits ] ]-=JUAMPI=-switchToVariables  | classScope |  self changeMethodGroupQueryBy: [ classScope := self classScopeForMethods.        ClyAllVariablesQuery from: classScope , classScope asInheritedScope as: ClyGroupedInstanceVariables withDefaultHierarchy ]-=JUAMPI=-meaningfullObjectToAssert: resultItem  ^resultItem actualObject-=JUAMPI=-activationPriority  ^0-=JUAMPI=-executesQuery: aTypedQueryClass  ^self isKindOf: aTypedQueryClass-=JUAMPI=-bindingOf: aSymbol  ^environment bindingOf: aSymbol-=JUAMPI=-oneTwo: anObject  self two: anObject-=JUAMPI=-whenEscapeKeyPressedDo: aBlock  table bindKeyCombination: Character escape asShortcut toAction: aBlock-=JUAMPI=-testIsAffectedByChangeOfNotAbstractMethodWhichImplementsAbstractOne  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)-=JUAMPI=-itemsStartingAt: startIndex count: size  | result |  result := super itemsStartingAt: startIndex count: size.  result do: [:each |  each prepareIn: environment ].  ^result-=JUAMPI=-groupProviderClass  ^ClyUndeclaredMethodGroupProvider-=JUAMPI=-testGettingItemsStartingWhereConditionIsValid  | actual |  queryResult fillWith: #(1 2 3 4 5 6).  actual := queryResult itemsStartingWhere: [:each |  each > 3 ] count: 2.  self assert: actual asArray equals: #(4 5)-=JUAMPI=-itemAt: rowIndex  ^self dataSource elementAt: rowIndex-=JUAMPI=-testGettingSingletonInstanceFromScratch  ClyUnknownQuery reset.  self assert: ClyUnknownQuery instance identicalTo: ClyUnknownQuery instance-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-initialize  super initialize.  excludesHaltsForTesting := true-=JUAMPI=-childrenItems  ^childrenDataSource allElements-=JUAMPI=-redoNavigationOf: aBrowser  redoList ifEmpty: [ ^self ].  self executeRedoBy: [ self restoreNavigationState: redoList removeLast of: aBrowser ]-=JUAMPI=-openBrowserCursorFor: anItemObserver  | cursor |  cursor := ClyBrowserQueryCursor for: self adoptForBrowser.  cursor openFor: anItemObserver.  ^cursor-=JUAMPI=-requestMultipleObjects: dialogTitle from: aQuery  self openOn: aQuery withTitle: dialogTitle thenDo: [ itemsView selection isEmpty ifTrue: [ ^self findObjectsSameAsFilter ].        ^itemsView selection actualObjects ]-=JUAMPI=-superclassSenderOfMessage1  self clyReferencedMessage1-=JUAMPI=-defaultMenuItemName  ^'Convert to extension'-=JUAMPI=-isModeActive  ^activator isCommandAppliedToBrowser-=JUAMPI=-isParentCollapsed  ^self isParentExpanded not-=JUAMPI=-isActive  ^isActive-=JUAMPI=-relationScopeClasses  ^relationScopeClasses-=JUAMPI=-testExecutesConcreteQueryClass  self assert: (query executesQuery: query class).  self assert: (query executesQuery: query class superclass).  self deny: (query executesQuery: ClyQueryExampleReturningScopeBasis2)-=JUAMPI=-defaultMenuItemName  ^menuItemName-=JUAMPI=-cellColumn: column row: rowIndex  | item |  item := self elementAt: rowIndex.  ^column createCellFor: item in: queryView-=JUAMPI=-useFullIndentation  fullIndentation := true-=JUAMPI=-metadata  ^actualResult metadata-=JUAMPI=-execute  (DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: {analyzedObject packageName}) open-=JUAMPI=-testFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(reader1OfVar1 reader2OfVar1)-=JUAMPI=-selectedTextInterval  ^tool selectedTextInterval-=JUAMPI=-checkClassIsAbstract: aClass  aClass withAllSuperclassesDo: [:eachClass |  eachClass methodsDo: [:eachMethod |  (eachMethod isAbstract and: [ (aClass lookupSelector: eachMethod selector) isAbstract ]) ifTrue: [ ^true ] ] ].  ^false-=JUAMPI=-initialize  super initialize.  properties := OrderedCollection new-=JUAMPI=-implementorClass  ^implementorMethod origin-=JUAMPI=-updateExpandingItems  self updateItems: collapsedItems.  collapsedItems := collapsedItems reject: [:each |  each isRemoved ]-=JUAMPI=-testFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot2 .         3 .         ClyTraitRoot2 .         2}-=JUAMPI=-restrictedByScope: aScope  ^self withScope: (scope restrictedBy: aScope)-=JUAMPI=-tableCellIcon  ^Smalltalk ui iconNamed: #haloView-=JUAMPI=-createQuery  ^ClyMethodSourcesQuery withString: self expectedSourceCodeSubstring from: (ClyClassScope of: self class in: environment)-=JUAMPI=-testNotFoundAfterRename  | classOrTrait |  classOrTrait := self newClassOrTrait.  self serialize: classOrTrait.  classOrTrait renameSilently: (classOrTrait name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-=JUAMPI=-useDoIt  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: false.  theCompiledMethod := theClass methodNamed: #m.  theClass methodDict at: #DoIt put: theCompiledMethod-=JUAMPI=-useMemoryStream  streamFactory := FLMultiByteStreamStrategy new-=JUAMPI=-testAssociationWithWeakFinalizationList  | weak association materializedAssociation object list |  object := Object new.  list := WeakFinalizationList new.  weak := WeakFinalizerItem new list: list object: object executor: nil.  association := Association key: #foo value: weak.  materializedAssociation := self resultOfSerializeAndMaterialize: association.  self assert: materializedAssociation value executor isNil.  self assert: materializedAssociation value list isNil not.  self assert: materializedAssociation value object isNil.  self assert: materializedAssociation key equals: #foo-=JUAMPI=-headerStep  encoder encodeYourself.  encoder encodePositiveInteger: clusters size-=JUAMPI=-signature: anObject  signature := anObject-=JUAMPI=-grow  | newArray |  newArray := Array new: array size * 2.  newArray replaceFrom: 1 to: array size with: array startingAt: 1.  array := newArray-=JUAMPI=-testGZip  | materialized |  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:aFileStream |  | gzip |        gzip := GZipWriteStream on: aFileStream.        FLSerializer newDefault serialize: 123 on: gzip.        gzip finish ].  materialized := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:aFileStream |  | gzip |        gzip := GZipReadStream on: aFileStream.        (FLMaterializer newDefault materializeFrom: gzip) root ].  self assert: materialized equals: 123-=JUAMPI=-testCyclicLinks  | a b c materializedA |  a := Link new.  b := Link new.  c := Link new.  a nextLink: b.  b nextLink: c.  c nextLink: a.  materializedA := self resultOfSerializeAndMaterialize: a.  self assert: materializedA nextLink nextLink nextLink identicalTo: materializedA.  self deny: materializedA nextLink identicalTo: materializedA.  self deny: materializedA nextLink nextLink identicalTo: materializedA-=JUAMPI=-writeStreamDo: aValuable  targetStrategy writeStreamDo: [:aStream |  ^GZipWriteStream with: aStream do: aValuable ]-=JUAMPI=-addPreMaterializationAction: aCleanBlockClosure  aCleanBlockClosure isClean ifFalse: [ self error: 'Pre materializaton actions have to be clean closures. For more details see method BlocKClosure >> #isClean' ].  preMaterializationActions add: aCleanBlockClosure-=JUAMPI=-clusterSerializeStepWith: aSerialization  -=JUAMPI=-objects  ^objects-=JUAMPI=-testNotFoundAfterRename  | classOrTrait |  classOrTrait := self newClassOrTrait.  self serialize: classOrTrait.  classOrTrait renameSilently: (classOrTrait name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-=JUAMPI=-fileNamed: aFilename readStreamDo: aBlock  ^((Smalltalk at: #File) named: aFilename) readStreamDo: [:stream |  aBlock value: stream ]-=JUAMPI=-classVariableForTesting: anObject  ClassVariableForTesting := anObject-=JUAMPI=-testDontConsiderCustomGlobal  | aPerson globalName |  aPerson := FLPerson new.  globalName := #FLGlobalVariableForTesting.  [ testingEnvironment at: globalName put: aPerson.  self deny: (self resultOfSerializeAndMaterialize: aPerson) identicalTo: aPerson ] ensure: [ testingEnvironment removeKey: globalName ]-=JUAMPI=-encodeWeakReferenceTo: anObject  indexStream nextIndexPut: (objectsIndexes at: anObject ifAbsent: [ objectsIndexes at: nil ])-=JUAMPI=-testSubstituteCharacterInPresenceOfSomeCharacter  self testSubstitute: Character inPresenceOf: $c-=JUAMPI=-run  self analysisStep.  self headerStep.  self instancesStep.  (Delay forMilliseconds: 100) wait.  self referencesStep.  self trailerStep-=JUAMPI=-postCopy  super postCopy.  array := array copy.  1 to: 4096 do: [:index |  (array at: index) ifNotNil: [:list |  array at: index put: list copy ] ]-=JUAMPI=-testLotsOfNils  self assertSerializationEqualityOf: (Array new: 1 << 16)-=JUAMPI=-encodeUint16: aSmallInteger  stream nextPut: (aSmallInteger bitShift: -8).  stream nextPut: (aSmallInteger bitAnd: 255)-=JUAMPI=-testExecuteAfterMaterialization  | anObject result aClass |  aClass := self newClass     addInstVarNamed: 'a';     duringTestCompileSilently: 'fuelAfterMaterialization a := #A';     yourself.  anObject := aClass new.  result := self resultOfSerializeAndMaterialize: anObject.  self assert: #A equals: (result instVarNamed: 'a')-=JUAMPI=-id  ^#fuelOutStack-=JUAMPI=-materializeInstanceWith: aDecoder  ^theClass new: aDecoder nextEncodedPositiveInteger-=JUAMPI=-encodeInt24: aSmallInteger  | pos |  pos := aSmallInteger < 0 ifTrue: [ (0 - aSmallInteger bitXor: 16rFFFFFF) + 1 ] ifFalse: [ aSmallInteger ].  1 to: 3 do: [:i |  stream nextPut: (pos byteAt: 4 - i) ]-=JUAMPI=-useAuthor: aString during: aBlock  (Smalltalk at: #Author) useAuthor: aString during: aBlock-=JUAMPI=-variablePartReferencesOf: anObject do: aBlock  1 to: anObject basicSize do: [:index |  aBlock value: (anObject basicAt: index) ]-=JUAMPI=-newTraitNamed: traitName inCategory: aCategory  ^self classFactory newTraitNamed: traitName asSymbol uses: Array new tag: aCategory asSymbol-=JUAMPI=-reference  ^reference-=JUAMPI=-materializeInstanceWith: aDecoder  ^(self materializeGlobalAssociationFrom: aDecoder) value-=JUAMPI=-testPreMaterializationActions  | aClass |  aClass := self newSubclassNamed: #FuelPreMaterializationTestClassToBeDeleted of: Object instanceVariableNames: '' classVariableNames: 'TestClassVariable TestClassVariable2'.  aClass class     duringTestCompileSilently: 'postLoadMethod  TestClassVariable := 1';     duringTestCompileSilently: 'postLoadMethod2  TestClassVariable := 2';     duringTestCompileSilently: 'classVariable  ^TestClassVariable '.  aClass perform: #postLoadMethod.  self assert: (aClass perform: #classVariable) equals: 1.  self serializer addPreMaterializationAction: [ (Smalltalk at: #FuelPreMaterializationTestClassToBeDeleted) perform: #postLoadMethod2 ].  self serialize: aClass.  self assert: (aClass perform: #classVariable) equals: 1.  self materialized.  self assert: (aClass perform: #classVariable) equals: 2-=JUAMPI=-at: key  | hash |  (keys at: (hash := key largeIdentityHash \\ 4096 + 1)) ifNotNil: [:keyList |  1 to: (tallies at: hash) do: [:index |  (keyList at: index) == key ifTrue: [ ^(values at: hash) at: index ] ] ].  self errorKeyNotFound: key-=JUAMPI=-materializeReferencesVariablePartOf: anObject with: aDecoder  1 to: anObject basicSize do: [:index |  anObject basicAt: index put: aDecoder nextEncodedReference ]-=JUAMPI=-objects  ^decoder objects-=JUAMPI=-selector: aSymbol  selector := aSymbol-=JUAMPI=-globalEnvironment: aDictionary  globalEnvironment := aDictionary-=JUAMPI=-serializeStack  | date fileName |  date := DateAndTime now.  fileName := String streamContents: [:s |  s           << 'Debugger-Stack-';           << self interruptedContext receiver class instanceSide name;           << '-'.        date printYMDOn: s.        s           << '-';           print: date hour24;           print: date minute;           print: date second;           << '.fuel' ].  self class serializeTestFailureContext: self interruptedContext copyStack toFileNamed: fileName-=JUAMPI=-objects  ^#()-=JUAMPI=-testSetElement  self assertSerializationEqualityOf: (CollectionElement with: 3)-=JUAMPI=-substitutionsBucket  ^substitutionsBucket-=JUAMPI=-testMemoryStream  | anArray materializedString |  anArray := FLSerializer serializeToByteArray: 'stringToSerialize'.  materializedString := FLMaterializer materializeFromByteArray: anArray.  self assert: materializedString equals: 'stringToSerialize'-=JUAMPI=-encodeSignatureWith: anEncoder  anEncoder encodeBytes: self signature asByteArray-=JUAMPI=-testMethodPreservesIdentity  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: classOrTrait >> #you-=JUAMPI=-right  ^right-=JUAMPI=-testClassSideObsolete  | classOrTrait |  classOrTrait := self newClassOrTrait.  self removeFromSystem: classOrTrait.  self should: [ self serialize: classOrTrait ] raise: FLObsolete whoseDescriptionIncludes: classOrTrait name description: 'Should raise an error when serializing as global an obsolete class or trait.'-=JUAMPI=-clustersSortedByAmountOfObjects  ^self clusters sorted: [:a :b |  a objects size > b objects size ]-=JUAMPI=-nextWordsPut: aWordObject  | byteSize |  byteSize := aWordObject basicSize * 4.  byteSize > buffer size ifTrue: [ self sizeBuffer: 1 << byteSize highBit ].  ((position bitAnd: 3) = 0 and: [ byteSize < self bufferFreeSize ]) ifFalse: [ self flushBuffer ].  self copyWordObjectToBuffer: aWordObject.  position := position + byteSize-=JUAMPI=-testSortedCollection  | aSortBlock aSortedCollection materialized |  aSortBlock := [:a :b |  a >= b ].  aSortedCollection := SortedCollection sortBlock: aSortBlock.  materialized := self resultOfSerializeAndMaterialize: aSortedCollection.  self assert: aSortedCollection sortBlock ~~ materialized sortBlock.  materialized addAll: #(2 1 3).  aSortedCollection addAll: #(2 1 3).  self assert: aSortedCollection asArray equals: materialized asArray-=JUAMPI=-afterMaterializationStep  clusters do: [:aCluster |  aCluster afterMaterializationStepWith: decoder ]-=JUAMPI=-mapAndTraceByClusterName: anObject to: aClusterClass  (self clusterKeyedByClusterName: aClusterClass) add: anObject traceWith: analysis-=JUAMPI=-serializeGlobalClass: aClass on: anEncoder  aClass isObsolete ifTrue: [ FLObsolete signalWithName: aClass name ].  anEncoder encodeString: aClass name-=JUAMPI=-additionalObjectAt: key  ^additionalObjects at: key-=JUAMPI=-materializeReferencesOf: aRectangle with: aDecoder  aRectangle fuelSetOrigin: aDecoder nextEncodedReference @ aDecoder nextEncodedReference corner: aDecoder nextEncodedReference @ aDecoder nextEncodedReference-=JUAMPI=-materializeInstanceWith: aDecoder  ^theClass newFromFrameSize: aDecoder nextEncodedByte-=JUAMPI=-globalMappers  ^globalMappersFactory value-=JUAMPI=-variableReferences  ^variableReferences ifNil: [ variableReferences := FLLargeIdentityDictionary new ]-=JUAMPI=-isSource: aBoolean  isSource := aBoolean-=JUAMPI=-migrateClassNamed: aSymbol toClass: aClass variables: aDictionary  migrations at: aSymbol put: (FLMigration fromClassNamed: aSymbol toClass: aClass variables: aDictionary)-=JUAMPI=-analyzer  ^analyzer ifNil: [ analyzer := self defaultAnalyzer ]-=JUAMPI=-initializeAnalyzing  super initializeAnalyzing.  globalSends := IdentityDictionary new-=JUAMPI=-referencesOf: aRectangle do: aBlock  aBlock value: aRectangle origin x.  aBlock value: aRectangle origin y.  aBlock value: aRectangle corner x.  aBlock value: aRectangle corner y-=JUAMPI=-variablesMappingFor: aClass  | variables |  variables := FLVariablesMapping materializing: aClass from: self.  migrations select: [:m |  m targetClass == aClass or: [ aClass inheritsFrom: m targetClass ] ] thenDo: [:m |  m applyTo: variables ].  ^variables-=JUAMPI=-serializeInstance: anInteger with: anEncoder  anEncoder encodeUint32: anInteger abs-=JUAMPI=-imageName  ^Smalltalk image shortImageName-=JUAMPI=-executePostMaterializationActions  postMaterializationActions do: [:each |  each cull: materialization ]-=JUAMPI=-addHacks  self class addHacks-=JUAMPI=-testClassSideMethodPreservesIdentity  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait classSide duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: classOrTrait classSide >> #you-=JUAMPI=-serializeInstance: aClass with: anEncoder  self serializeGlobalClass: aClass on: anEncoder-=JUAMPI=-encodeClusterClass: aClusterClass  self encodeString: aClusterClass name-=JUAMPI=-setUp  super setUp.  self useGzipInMemoryStream-=JUAMPI=-printNameOn: aStream  super printNameOn: aStream.  aStream nextPut: $[.  theClass printOn: aStream.  aStream nextPut: $]-=JUAMPI=-testJustMaterializeHeader  self serializer at: #test putAdditionalObject: 'test'.  self serializer at: 42 putAdditionalObject: 68.  self serialize: 'foo'.  self assert: (self materializationHeader additionalObjectAt: #test) equals: 'test'.  self assert: (self materializationHeader additionalObjectAt: 42) equals: 68-=JUAMPI=-renamedMethodCopyOf: aMethod selector: aSymbol  | newMethod |  newMethod := aMethod ast selector: aSymbol yourself.  ^newMethod compiledMethod-=JUAMPI=-materialized  ^self materialization root-=JUAMPI=-referencesOf: anObject do: aBlock  aBlock value: anObject size.  anObject keysAndValuesDo: [:key :value |  aBlock value: key.        aBlock value: value ]-=JUAMPI=-clusterMaterializeStepWith: aMaterialization  super clusterMaterializeStepWith: aMaterialization.  variablesMapping := aMaterialization decoder variablesMappingFor: theClass-=JUAMPI=-defaultOrder  ^125-=JUAMPI=-registerBehavior: aBehavior  aBehavior isTrait ifTrue: [ self classFactory createdTraits add: aBehavior ] ifFalse: [ self classFactory createdClasses add: aBehavior ]-=JUAMPI=-traitNamePrefix  ^'FLTraitForTesting'-=JUAMPI=-materializePostInstancesStepWith: aDecoder  -=JUAMPI=-readStreamDo: aValuable  ^aValuable value: inMemoryStream contents readStream-=JUAMPI=-encodeUint64: aSmallInteger  stream     nextPut: (aSmallInteger bitShift: -56);     nextPut: ((aSmallInteger bitShift: -48) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -40) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -32) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -24) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -16) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -8) bitAnd: 255);     nextPut: (aSmallInteger bitAnd: 255)-=JUAMPI=-testBlockClosureChangeDifferentBytecodes  | aClass aClosure |  aClass := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]';     yourself.  aClosure := aClass new perform: #methodWithClosure.  self serialize: aClosure.  aClass duringTestCompileSilently: 'methodWithClosure  ^ 42'.  self should: [ self materialized ] raise: FLMethodChanged-=JUAMPI=-foundationBrick  ^(self owner isKindOf: GLMFoundationBrick) ifTrue: [ self owner ] ifFalse: [ self ]-=JUAMPI=-renderBorder: aBrick on: aCanvas  aCanvas drawPolygon: aBrick area vertices color: Color transparent borderWidth: aBrick border widthTop borderColor: aBrick border colorTop-=JUAMPI=-click: evt  | result |  result := super click: evt.  result ifTrue: [ self closePopup ].  ^result-=JUAMPI=-selectedLabel  ^selectedLabel-=JUAMPI=-stepAt: millisecondClockValue  hasInitialStep ifFalse: [ hasInitialStep := true.        ^self ].  super stepAt: millisecondClockValue-=JUAMPI=-submorphAfter  ^self subbrickAfter-=JUAMPI=-value  ^value-=JUAMPI=-enableFilterWithAction: aBlock  self enableFilter.  self parameters at: 'actionBlock' put: aBlock-=JUAMPI=-pane  ^pane ifNil: [ pane := (GLMPane named: 'root' in: GLMNoBrowser new)           addPresentationSilently: self;           yourself ]-=JUAMPI=-updateWidthPercentage  self subbricks ifEmpty: [ ^self ].  self subbricks do: [:each |  each hSpaceFill: 100 / self subbricksCount ]-=JUAMPI=-testEmptyList  window := GLMScrollListBrick exampleEmptyCollection.  self assert: window isSystemWindow-=JUAMPI=-defaultWaitDuration  ^500 milliSecond-=JUAMPI=-announce: anAnnouncement  self logger logAnnouncement: anAnnouncement from: self.  super announce: anAnnouncement-=JUAMPI=-isFocused  ^focused-=JUAMPI=-resetChildrenContent  elements := self calculateElements.  self resetDataCache-=JUAMPI=-bar  ^bar-=JUAMPI=-firstSubbrick  ^self subbricks first-=JUAMPI=-drawingBounds: aBrick  | aRectangle anOffset |  aRectangle := aBrick brickBounds.  anOffset := aBrick shadowOffset.  ^aBrick shadowWidth isZero ifTrue: [ aRectangle ] ifFalse: [ aRectangle quickMerge: ((aRectangle expandBy: aBrick shadowWidth) translateBy: anOffset) ]-=JUAMPI=-shouldValidate  ^shouldValidate ifNil: [ shouldValidate := false ]-=JUAMPI=-basicElements  ^self glamourPresentation displayValue-=JUAMPI=-cancel  self borderColor: self themer color alizarin.  self beNormal-=JUAMPI=-mouseDown: evt  startDragX := evt position x - self globalBounds left.  startResizingWidth := self width.  isRightResizing := self isRightResizingZone: evt.  isRightResizing ifFalse: [ isLeftResizing := self isLeftResizingZone: evt ] ifTrue: [ isLeftResizing := false ].  isResizing := isLeftResizing or: isRightResizing.  super mouseDown: evt-=JUAMPI=-rubricBackgroundColor  ^self valueOfProperty: #brickRubricBackgroundColor ifAbsent: [ self themer rubricBackgroundColor ]-=JUAMPI=-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderRubricTextPresentation: self-=JUAMPI=-newBand  ^super newBand height: [:bandBrick |  bandBrick subbricks isEmpty ifTrue: [ 0 ] ifFalse: [ bandBrick lastSubbrick brickBounds bottom ] ]-=JUAMPI=-doesNotUnderstand: aMessage  ^self rubric perform: aMessage selector withArguments: aMessage arguments-=JUAMPI=-compositeMorph  ^window submorphs last submorphs last submorphs last-=JUAMPI=-replaceFrom: start to: stop with: aText  self okToStyle ifFalse: [ ^next replaceFrom: start to: stop with: aText ].  self disableDrawingWhile: [ aText addAttribute: self defaultFontChange.        text ifNil: [ text := self text ].        text replaceFrom: start to: stop with: (self styler format: aText).        self style: text.        next text: text.        self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop - start + 1).        self textArea paragraphWasComposedFrom: start to: start + aText size - 1.        self textArea paragraphReplacedTextFrom: start to: stop with: aText ]-=JUAMPI=-installEntity  self textBrick setTextWith: (self displayLogic phlowValue: self entity).  self textBrick selectionInterval: (self selectionInterval phlowValue: self entity)-=JUAMPI=-resetInput  self updateRoots-=JUAMPI=-render: aBrowser  ^self subclassResponsibility-=JUAMPI=-onDoubleClick  self announcer announce: (GLMTreeMorphStrongSelectionChanged new strongSelectionValue: (self selection ifNotNil: [ self selection selectedItemOrItemsOrNil ]))-=JUAMPI=-isButton  ^self hasIcon-=JUAMPI=-defaultBrowser  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  browser transmit     to: #one;     from: #two;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  ^browser-=JUAMPI=-initialize  super initialize.  isSyncronous := false-=JUAMPI=-testLeftFloatingMySelfDependencyWithMargin  | root floating margin brick |  margin := 10.  floating := #left.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick marginLeft: margin.  brick layout floating: floating.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (margin @ 0 extent: self staticSmallExtent)-=JUAMPI=-floatingMethodFor: aSymbol  ^('layoutFloating' , aSymbol capitalized , ':in:') asSymbol-=JUAMPI=-testPaneCreation  | browser |  browser := GLMFinder new.  browser addPresentation: (GLMPresentation new title: 'presentation1').  self assert: browser panes isEmpty.  (browser pane port: #entity) value: #value1.  self assert: browser panes size equals: 1.  self assert: browser panes first browser identicalTo: browser.  self assert: (browser panes first port: #entity) value equals: #value1.  self assert: browser panes first presentations size equals: 1.  self assert: browser panes first presentations first title equals: 'presentation1'.  self assert: browser panes first presentations first ~~ browser transmission transmissionStrategy presentations first.  (browser panes first port: #selection) value: #value2.  self assert: browser panes size equals: 2.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value2.  self assert: browser panes last presentations first title equals: 'presentation1'.  self assert: browser panes last presentations first ~~ browser transmission transmissionStrategy presentations first.  self assert: browser panes last presentations first ~~ browser panes first presentations first.  (browser panes last port: #selection) value: #value3.  self assert: browser panes size equals: 3.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value3.  (browser panes first port: #selection) value: #value4.  self assert: browser panes size equals: 2.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value4.  (browser pane port: #entity) value: #value5.  self assert: browser panes size equals: 1.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value5-=JUAMPI=-state  ^#vState-=JUAMPI=-onThemerChanged  self updateStyle-=JUAMPI=-markClean: aBrick  ^self subclassResponsibility-=JUAMPI=-addAllBricks: aCollection  self brickRoot addAllBricks: aCollection-=JUAMPI=-copyAccordingToPaneMapping: newPanesMapping inNewBrowser: anotherBrowser  ^self copy presentation: anotherBrowser-=JUAMPI=-customDependencies: aBrick  ^aBrick layout heightDependencies-=JUAMPI=-dimension: anObject  dimension := anObject-=JUAMPI=-prioritySortedSubbricks: aBrick  | sorted |  sorted := OrderedCollection newFrom: aBrick subbricks.  sorted sort: [:first :second |  (self isDependsOnParent: first) ifFalse: [ true ] ifTrue: [ (self isDependsOnParent: second) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: first) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: second) ifFalse: [ true ] ifTrue: [ (self hasMinDimensionRestriction: first) ifFalse: [ false ] ifTrue: [ true ] ] ] ] ] ].  ^sorted-=JUAMPI=-sorted: aBlock  sortBlock := aBlock-=JUAMPI=-testTrasmissions  self assert: copiedBrowser transmissions size equals: 2.  self assert: copiedBrowser transmissions first ~~ browser transmissions first.  self assert: copiedBrowser transmissions last ~~ browser transmissions last.  self assert: (copiedBrowser transmissions first destination pane browser isKindOf: GLMNoBrowser).  self assert: copiedBrowser transmissions last destination pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions first origins first pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions last origins first pane browser identicalTo: copiedBrowser-=JUAMPI=-text  ^(self pane port: #text) value ifNil: [ self textBlock value ] ifNotNil: [ (self pane port: #text) value ]-=JUAMPI=-scrollToPane: anIndex smooth: isSmooth  self scrollTo: (pagerModel convertIndexToValue: anIndex) smooth: isSmooth-=JUAMPI=-testWithDisplay  < expectedFailure>  | browser dynamic stacker text textMorph |  browser := GLMTabulator new     column: #stacker;     yourself.  browser transmit     to: #stacker;     andShow: [:c |  c dynamic display: [:number |  | st |              st := GLMStacker new.              st aPane: #all.              st transmit                 to: #all;                 andShow: [:a |  a text display: [ 'All ' , number asString ] ].              st ] ].  window := browser openOn: 10.  dynamic := browser panes first presentations first.  stacker := dynamic cachedPresentation first.  self assert: stacker panes first presentations size equals: 1.  text := stacker panes first presentations first.  textMorph := self findWherePresentationIs: text in: window.  self assert: textMorph text asString equals: 'All 10'-=JUAMPI=-hShrinkWrap  super hShrinkWrap.  self labelBrick hShrinkWrap.  self editBrick hShrinkWrap-=JUAMPI=-shouldFilterByTag: aTag  ^self tagsToFilterBy includes: aTag-=JUAMPI=-transmission  ^transmission ifNil: [ transmission := GLMTransmission new ensureReplacePresentationsStrategy.        transmission ]-=JUAMPI=-isOnMyself  ^true-=JUAMPI=-beCentered  isCentered := true.  self isVFilling ifTrue: [ self rubric forceHeight: [ self height - self vPadding ] ]-=JUAMPI=-testTo  browser transmit to: #one.  self assert: browser transmissions first destination pane equals: browser panes first.  self assert: browser transmissions first destination name equals: GLMPortIdentifier defaultTargetPortName-=JUAMPI=-settingsButtonBrick: anObject  settingsButtonBrick := anObject.  self settingsButtonBrick     text: self settingsButtonLabel;     hShrinkWrap;     vAlign: #center;     margin: 10;     when: #onClicked do: [ self openSettingsBrowser ].  self addBrickBack: self settingsButtonBrick-=JUAMPI=-unregisterFromAllAnnouncements  updateActions do: [:each |  each unregisterFromAllAnnouncements ]-=JUAMPI=-resetDataCache  dataCache := nil-=JUAMPI=-hintText  ^hintText ifNil: [ hintText := 'Need help?' ]-=JUAMPI=-actOnPresentationUpdated: ann  self setLabelOf: window for: ann presentation-=JUAMPI=-testShortcutFromKeymap  | action modifier |  modifier := Smalltalk os defaultModifier.  action := GLMAction new.  action keymap: modifier + $i asShortcut.  self assert: action keymap equals: modifier + $i asShortcut.  action keymap: modifier + $i shift.  self assert: action keymap equals: modifier + $i shift.  action keymap: nil.  self assertEmpty: action shortcutAsString-=JUAMPI=-removeProperty: aSymbol  super removeProperty: aSymbol-=JUAMPI=-testPortsInmmutability  < expectedFailure>  | aPane ports |  aPane := GLMPane in: 1.  self assertEmpty: aPane ports.  ports := aPane ports.  ports add: 1.  self assert: ports size equals: 1.  self assertEmpty: aPane ports-=JUAMPI=-addAllBricks: aCollection  | bricks |  bricks := self privateAddAllBricks: aCollection.  bricks do: [:b |  self privatePrepareBrickAfterAdding: b ].  self doLayoutForce.  ^aCollection-=JUAMPI=-minWidth  ^minWidth ifNil: [ minWidth := 0 ]-=JUAMPI=-testSelectionAvailableWhenNoSelectionDisabled  | presentation |  presentation := GLMPresentation new.  presentation selection: 1.  self assert: presentation selection equals: 1.  self assert: presentation rawSelection equals: 1-=JUAMPI=-paddingLeft: anInteger  self padding at: Left put: anInteger.  self updateCache-=JUAMPI=-list: anObject  list := anObject-=JUAMPI=-addContentsMorph  self contentsMorph: GLMMorphic emptyMorph.  self contentsMorph     layoutFrame: (LayoutFrame identity           leftOffset: 10;           topOffset: 10;           rightOffset: -10;           bottomOffset: -10);     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorphBack: self contentsMorph-=JUAMPI=-updateTabs  | selectedTab |  self removeAllBricks.  self tabs ifEmpty: [ ^self ].  selectedTab := self selectedTab.  self tabs do: [:t |  t selected: t == selectedTab.        t hSpaceFill: (100 / self tabs size) asFloat ].  self addAllBricks: self tabs-=JUAMPI=-textLightColor  ^Color gray-=JUAMPI=-verticallyStackedArrangement  ^self stackedVerticallyArrangement-=JUAMPI=-updateState: aRectangle  self brickBounds width = aRectangle width ifFalse: [ self markWidthDirty ].  self brickBounds height = aRectangle height ifFalse: [ self markHeightDirty ]-=JUAMPI=-testBundleStrategy  | pane1 pane2 transmission presentation |  pane1 := GLMPane named: 'pane1'.  pane2 := GLMPane named: 'pane2'.  transmission := GLMTransmission new.  transmission ensureReplacePresentationsStrategy.  transmission addActiveOrigin: (pane1 port: #port1).  transmission destination: (pane2 port: #port2).  transmission addPresentation: GLMPresentation new.  (pane1 port: #port1) value: 1.  transmission transmit.  self assert: pane2 presentations size equals: 1.  presentation := pane2 presentations first.  (pane1 port: #port1) value: 2.  transmission transmit.  self assert: pane2 presentations first rootPrototype equals: presentation rootPrototype.  self assert: pane2 presentations first ~~ presentation-=JUAMPI=-dataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]-=JUAMPI=-zIndex  ^self layout zIndex brickValue: self-=JUAMPI=-children  ^children ifNil: [ children := OrderedCollection new ]-=JUAMPI=-shortcut  ^self keymap ifNotNil: [ self keymap currentCharacter ]-=JUAMPI=-cell  ^cell-=JUAMPI=-popupEditorShadowThemer  ^self registerModule: [ GLMBrickPopupEditShadowThemer new ] to: self named: #popupThemer-=JUAMPI=-textBrick: aBrick  textBrick := aBrick.  self textBrick wrapped: true.  self textBrick layoutProperties     vSpaceFill;     hSpaceFill.  self addBrickBack: self textBrick-=JUAMPI=-leftoverScrollRange  ^(self totalScrollRange - self innerBounds width roundTo: self scrollDeltaWidth) max: 0-=JUAMPI=-renderPager: aBrowser  ^aBrowser hasFixedSizePanes ifTrue: [ GLMMorphicPagerRenderer render: aBrowser from: self ] ifFalse: [  ]-=JUAMPI=-resetContentsRecursively  self resetContents.  self allContents do: [:each |  each resetContentsRecursively ]-=JUAMPI=-profileSelection  self announce: GLMProfileSelection-=JUAMPI=-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderRubricHighlightedTextPresentation: self-=JUAMPI=-newTextBrick  ^GLMRubEditingAreaBrick new-=JUAMPI=-destination: aPort  destination := aPort-=JUAMPI=-scrollToBottom  self band hasSubbricks ifFalse: [ ^self ].  self scrollTo: self band lastSubbrick-=JUAMPI=-widthLeft: anInteger  self width at: Left put: anInteger-=JUAMPI=-hintBrick: anObject  hintBrick := anObject.  self hintBrick textColor: self themer popupThemer textColor.  self contentBrick addBrickBack: self hintBrick-=JUAMPI=-newHeaderMorph  ^(self theme newRowIn: self theme for: {self tabSelectorMorph .         self toolbarMorph})     cellInset: 0;     cellPositioning: #bottomCenter;     borderWidth: 0-=JUAMPI=-scrollpane: anObject  scrollpane := anObject-=JUAMPI=-actOnPaneRemoved: ann  container popPane-=JUAMPI=-showAt: aPoint  self     openInWorld;     align: aPoint-=JUAMPI=-createSimplePaneMorph  ^Morph new-=JUAMPI=-evaluateSelection  self evaluateSelectionAndDo: [:result |  result ]-=JUAMPI=-modifiedBlock  ^modifiedBlock-=JUAMPI=-when: anAnnouncementClass send: selector to: target  self announcer when: anAnnouncementClass send: selector to: target-=JUAMPI=-resetDataCache  dataCache := nil-=JUAMPI=-rowMorphFor: aNodeMorph  | rowMorph cont |  rowMorph := aNodeMorph rowMorphForColumn: glamourColumn.  rowMorph ifNotNil: [ rowMorph borderWidth: 0 ] ifNil: [ rowMorph := self defaultRowMorph ].  cont := Morph new     color: Color transparent;     layoutPolicy: RowLayout new;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: container columnInset @ container rowInset;     yourself.  cont addMorph: rowMorph.  self isFirstColumn ifTrue: [ | icon |        icon := container iconBlock value: aNodeMorph.        icon ifNotNil: [ cont addMorph: icon asMorph ].        cont layoutInset: 0 @ container rowInset ].  ^cont-=JUAMPI=-paste  self announce: (GLMTextEditorRequest for: #paste)-=JUAMPI=-width: anInteger  self brickBounds: (self brickBounds withWidth: anInteger)-=JUAMPI=-calculateScrollbarHeight  | bandHeight firstIndex lastIndex |  bandHeight := self approximateBandHeight.  bandHeight = 0 ifTrue: [ ^0 ].  self scrollPane isFullyVisible ifTrue: [ ^0 ].  firstIndex := self scrollPane getIndex: self scrollPane band firstSubbrick.  lastIndex := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((lastIndex - firstIndex + 1) / self scrollPane model count * self height) ceiling-=JUAMPI=-outOfWorld: aWorld  super outOfWorld: aWorld.  self brickRoot onRemovedFrom: self-=JUAMPI=-hasBindingOf: aSymbol  ^self variableBindings includesKey: aSymbol-=JUAMPI=-newTreeMorph  ^GLMPaginatedMorphTreeMorph new-=JUAMPI=-isForScripting  ^isForScripting ifNil: [ false ]-=JUAMPI=-valueFor: anElement withIndex: anInteger in: aGlamourColumn  ^self cacheAt: aGlamourColumn title for: anElement ifAbsentPut: [ self glamourPresentation column: aGlamourColumn valueFor: (self glamourPresentation isWithElementIndex ifTrue: [ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ] ifFalse: [ anElement ]) ]-=JUAMPI=-render: aPresentation  | container |  container := super render: aPresentation.  aPresentation shouldAllExpand ifTrue: [ treeMorph expandAll ].  aPresentation shouldRootsExpand ifTrue: [ treeMorph expandRoots ].  aPresentation shouldExpandToLevel ifTrue: [ treeMorph expandAllTo: aPresentation expandLevel ].  ^container-=JUAMPI=-iconBrick  ^iconBrick-=JUAMPI=-onOpened  super onOpened.  self textEditBrick     takeKeyboardFocus;     selectAll-=JUAMPI=-custom: aPresentation  ^self add: aPresentation-=JUAMPI=-actOnTextEditorRequest: ann  ann action value: textMorph textArea editor-=JUAMPI=-initialize  super initialize.  self     useHorizontalLinearLayout;     hShrinkWrap-=JUAMPI=-hShrinkWrap  self layout hShrinkWrap-=JUAMPI=-testFreshBrickIsDirty  self assertBrickDirty: GLMBrick new-=JUAMPI=-shadowColor: aColor  < brickBuilderProperty: #'Look&Feel' name: 'Shadow Color' as: #brickBuilderEvaluate getter: #shadowColor model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickShadowColor toValue: aColor-=JUAMPI=-openInBrickWindowLabeled: aLabel  ^self class environment at: #GLMSystemWindowBrick ifPresent: [:glmSystemWindowBrick |  glmSystemWindowBrick new           label: aLabel;           color: Color transparent;           addBrickBack: (GLMBrick new vSpaceFill                 hSpaceFill;                 addBrickBack: self;                 yourself);           extent: 400 @ 400 * self currentWorld displayScaleFactor;           openCenteredInWorld ] ifAbsent: [ self asMorph openInWindow ]-=JUAMPI=-normalizeWidth: anInteger of: aBrick  ^(anInteger max: (aBrick layout minWidth brickValue: aBrick)) min: (aBrick layout maxWidth brickValue: aBrick)-=JUAMPI=-postCopy  port := port copy-=JUAMPI=-resolveOriginPort: aPortReference  ^self resolvePort: aPortReference asGlamourOriginIdentifier defaultPortName: #selection-=JUAMPI=-testMarkerOneStaticHeight  | brick |  brick := self newBrickWithStaticExtent.  self markFullyClean: brick.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty-=JUAMPI=-sendToOutside: aPortName from: anOriginPortReference  self sendTo: #outer -> aPortName from: anOriginPortReference-=JUAMPI=-calculateScrollbarTopOffset  | bandHeight firstIndex lastIndex |  bandHeight := self approximateBandHeight.  bandHeight = 0 ifTrue: [ ^0 ].  firstIndex := self scrollPane getIndex: self scrollPane band firstSubbrick.  lastIndex := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((firstIndex - 1) / self scrollPane model count * self height) floor-=JUAMPI=-mouseLeave: evt  super mouseLeave: evt.  ^self deselect: evt-=JUAMPI=-approximateWidth  ^self label approximateWidth + self hMargin + self hPadding-=JUAMPI=-icon  ^nil-=JUAMPI=-noActions  actions := nil.  dynamicActionsBlock := nil-=JUAMPI=-updateCache  | left top right bottom |  left := self brickBounds origin x.  top := self brickBounds origin y.  right := self brickBounds corner x.  bottom := self brickBounds corner y.  innerBounds := (left + self paddingLeft) @ (top + self paddingTop) corner: (right - self paddingRight) @ (bottom - self paddingBottom).  outerBounds := (left - self marginLeft) @ (top - self marginTop) corner: (right + self marginRight) @ (bottom + self marginBottom)-=JUAMPI=-interval  ^self start to: self end-=JUAMPI=-glamourPresentation: aGlamourPresentation  glamourPresentation := aGlamourPresentation-=JUAMPI=-color: aSymbolOrColor  color := aSymbolOrColor-=JUAMPI=-alizarin  ^Color brickColorRegistry at: #brickAlizarin ifAbsentPut: [ Color r: 231 g: 76 b: 60 range: 255 ]-=JUAMPI=-west  direction := West-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  ports printOn: aStream.  aStream nextPut: $)-=JUAMPI=-portSymbol  ^portSymbol-=JUAMPI=-tabLabelThemer  ^self registerModule: GLMBrickTabLabelDarkThemer new-=JUAMPI=-testReferences  | browser pane1 |  browser := GLMExplicitBrowser new.  pane1 := browser addNewPaneNamed: #pane1.  self assert: (browser resolveOriginPort: #pane1) identicalTo: (pane1 port: #selection).  self assert: (browser resolveOriginPort: #pane1 -> #foo) identicalTo: (pane1 port: #foo).  self assert: (browser resolveDestinationPort: #pane1) identicalTo: (pane1 port: #entity).  self assert: (browser resolveDestinationPort: #pane1 -> #foo) identicalTo: (pane1 port: #foo).  self assert: ((browser resolveOriginPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveOriginPort: #outer) presentation identicalTo: browser.  self assert: (browser resolveOriginPort: #outer) name equals: #selection.  self assert: ((browser resolveOriginPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveOriginPort: #outer -> #foo) presentation identicalTo: browser.  self assert: (browser resolveOriginPort: #outer -> #foo) name equals: #foo.  self assert: ((browser resolveDestinationPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveDestinationPort: #outer) presentation identicalTo: browser.  self assert: (browser resolveDestinationPort: #outer) name equals: #entity.  self assert: ((browser resolveDestinationPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveDestinationPort: #outer -> #foo) presentation identicalTo: browser.  self assert: (browser resolveDestinationPort: #outer -> #foo) name equals: #foo-=JUAMPI=-first  ^self presentations first-=JUAMPI=-testSuspendAllWhile  | announcement instance |  announcer when: GLMTestAnnouncement do: [:ann |  announcement := ann ].  announcement := nil.  instance := announcer announce: GLMTestAnnouncement.  self assert: announcement equals: instance.  announcement := nil.  announcer suspendAllWhile: [ instance := announcer announce: GLMTestAnnouncement ].  self assert: announcement isNil-=JUAMPI=-isHSpaceFill  ^self hState isOnParent-=JUAMPI=-isLeftResizingZone: evt  ^(self globalBounds withWidth: resizingZoneWidth) containsPoint: evt position-=JUAMPI=-toString: anObject  ^self glamourPresentation hasFilterBlock ifTrue: [ anObject ] ifFalse: [ super toString: anObject ]-=JUAMPI=-testNoSelection  | browser treeMorph treeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree noSelection ].  window := browser openOn: ($a to: $d).  treeMorph := window submorphs last submorphs first submorphs first submorphs first submorphs first.  treeNodeMorph := treeMorph scroller submorphs first.  self send: treeMorph mouseUpOnItem: treeNodeMorph.  self assert: browser panes size equals: 1-=JUAMPI=-scrollingDelay: anInteger  scrollingDelay := anInteger-=JUAMPI=-allowDropOnItem: aBlock  allowDropOnItemBlock := aBlock-=JUAMPI=-useExplicitNotNil  implicitNotNil := false-=JUAMPI=-testEquality  self assert: (copiedBrowser = browser) not-=JUAMPI=-check  self isChecked ifFalse: [ isChecked := true.        self announce: #onChecked.        self changed ]-=JUAMPI=-actOnVariableBindingsUpdated: ann  textModel variableBindings: nil.  self addVariableBindingsOn: textModel from: ann presentation.  textModel changed: #text.  self flag: 'update just the style here'-=JUAMPI=-totalPaneWidth  ^self innerBounds width - ((self sizing - 1) * self separatorWidth)-=JUAMPI=-dynamicActionsOnSelection  (selectionDynamicActionsBlock isNil or: [ self selectedText isNil ]) ifTrue: [ ^OrderedCollection new ].  ^selectionDynamicActionsBlock glamourValue: self-=JUAMPI=-onCompleted: aBlock  callback := aBlock-=JUAMPI=-updateWidth: aBrick  aBrick isWidthClean ifTrue: [ Exception signal: 'Clean width can''t be updated!' ].  aBrick layout hState updateWidth: aBrick on: self-=JUAMPI=-pane  ^pane-=JUAMPI=-testPresentationTransformation  | dynamic |  dynamic := GLMDynamicPresentation new.  dynamic entity: 42.  dynamic presentationTransformation: [:some :entity |  (1 to: entity) do: [:each |  some text title: each asString ] ].  self assert: dynamic currentPresentation presentations size equals: 42.  self assert: dynamic currentPresentation pane identicalTo: dynamic pane-=JUAMPI=-setUp  super setUp.  pagerModel := GLMPagerModel new scrollingDelay: 0.  pagerModel defaultNumberOfVisiblePages: 2-=JUAMPI=-testMarkerOneChildrenWidth  | brick |  brick := self newBrickWithFullDependsOnChildren.  self markFullyClean: brick.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean-=JUAMPI=-synchronizeScrollTo: aValue  pagerModel synchronizeScrollTo: aValue-=JUAMPI=-privateHeight: anObject  self layout height: anObject-=JUAMPI=-testPresentations  | expander |  expander := GLMExpander new.  expander show: [:a |  a text ].  expander startOn: #(#a #b #c).  self assert: expander panes size equals: 3.  self assert: expander panes first presentations entity value equals: #a.  self assert: expander panes first presentations size equals: 1.  self assert: (expander panes first presentations first isKindOf: GLMRubricTextPresentation)-=JUAMPI=-defaultScrollButtonStyleFor: aButton  aButton checkedIcon: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  aButton checkedFocusedIcon: GLMUIThemeExtraIcons glamorousGrayCircle.  aButton normalImage: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  aButton selectedImage: GLMUIThemeExtraIcons glamorousGrayCircle.  aButton checkedImage: aButton checkedIcon-=JUAMPI=-glamourPresentation: anObject  glamourPresentation := anObject-=JUAMPI=-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderFastTreePresentation: self-=JUAMPI=-rubricTextFontSize  ^self valueOfProperty: #brickRubricTextFontSize ifAbsent: [ self themer rubricTextFontSize ]-=JUAMPI=-doesNotUnderstand: aMessage  ^self brickRoot perform: aMessage selector withArguments: aMessage arguments-=JUAMPI=-debugSelection  self announce: GLMDebugSelection-=JUAMPI=-childrenValueOf: anObject atLevel: anInteger  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection new-=JUAMPI=-update  super update-=JUAMPI=-padding  ^self wrappedBounds padding-=JUAMPI=-sortByColumn: aGlamourColumn  columnToSortBy := columnToSortBy == aGlamourColumn ifTrue: [ nil ] ifFalse: [ aGlamourColumn ].  elements := self elementsSorted.  self glamourPresentation changed-=JUAMPI=-allowItemDragBlock  ^allowItemDragBlock-=JUAMPI=-addBrick: aBrick after: otherBrick  | result |  result := self privateAddBrick: aBrick asBrick after: otherBrick.  self privatePrepareBrickAfterAdding: result.  self doLayoutForce.  ^aBrick-=JUAMPI=-testShortcutAsString  | action modifier |  modifier := Smalltalk os menuShortcutModifierString.  action := GLMAction new.  action shortcut: $i.  self assert: action shortcutAsString equals: modifier , '+i'.  action shortcut: $I.  self assert: action shortcutAsString equals: modifier , '+shift+i'.  action shortcut: nil.  self assertEmpty: action shortcutAsString-=JUAMPI=-roots  roots ifNil: [ self roots: self glamourExpander panes ].  ^roots-=JUAMPI=-add: newObject before: oldObject  collection add: newObject before: oldObject.  self announce: GLMItemAdded-=JUAMPI=-actOnPresentationToolbarUpdated: ann  | dock |  self setLabelOf: window for: ann presentation.  dock := self renderToolbarForPresentation: ann presentation inMorph: window.  dock hResizing: #shrinkWrap.  window toolbarBox: dock-=JUAMPI=-paneCount  ^paneCount-=JUAMPI=-fromOutside: aPortName  ^self fromOutsidePort: aPortName-=JUAMPI=-backgroundColor  ^self theme backgroundColor-=JUAMPI=-measureOpeningTime  | browser numberOfOpenings time |  numberOfOpenings := 15.  browser := self defaultBrowser.  time := Time millisecondsToRun: [ numberOfOpenings timesRepeat: [ (browser openOn: 10) delete ] ].  ^{numberOfOpenings .   time}-=JUAMPI=-bounds  ^bounds-=JUAMPI=-click: evt  super click: evt.  ^true-=JUAMPI=-firstVisiblePageIndex  ^firstVisiblePageIndex-=JUAMPI=-outerBoundsInParent  ^self owner ifNotNil: [ self wrappedBounds outerBounds translateBy: self owner brickBounds origin ] ifNil: [ self wrappedBounds outerBounds ]-=JUAMPI=-newBrickWithStaticExtent  ^GLMBrick new     height: self staticHeight;     width: self staticWidth;     color: Color random;     yourself-=JUAMPI=-addItemMorph: aMorph after: anotherMorph  self addBrickBackNoLayout: aMorph.  self setBoundsOf: aMorph after: anotherMorph.  (self isPartiallyVisible: aMorph) ifFalse: [ self removeBrickNoLayout: aMorph.        ^nil ].  ^aMorph-=JUAMPI=-isDoubleClickEnabled  ^isDoubleClickEnabled ifNil: [ isDoubleClickEnabled := false ]-=JUAMPI=-addTransmission: aTransmission  aTransmission browser: self.  ^self transmissions addLast: aTransmission-=JUAMPI=-layoutMorphs: aBoolean  shouldLayoutMorphs := aBoolean-=JUAMPI=-hasUnacceptedEdits  ^hasUnacceptedEdits ifNil: [ hasUnacceptedEdits := false ]-=JUAMPI=-* aNumber  < return: #Point>  ^aNumber negated @ 0-=JUAMPI=-testMarkerOneParentWidth  | brick |  brick := self newBrickWithFullFill.  self markFullyClean: brick.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean-=JUAMPI=-renderMorphPresentation: aMorphPresentation  ^GLMMorphicMorphRenderer render: aMorphPresentation from: self-=JUAMPI=-isCollection  ^true-=JUAMPI=-registerEventsForPresentation: aPresentation  super registerEventsForPresentation: aPresentation.  aPresentation when: GLMVariableBindingsChanged send: #actOnVariableBindingsUpdated: to: self.  aPresentation when: GLMEvaluateSelection send: #actOnEvaluateSelection: to: self.  aPresentation when: GLMCompileText send: #actOnCompileText: to: self.  aPresentation when: GLMDebugSelection send: #debugSelection to: self.  aPresentation when: GLMProfileSelection send: #profileSelection to: self.  aPresentation when: GLMPrintSelection send: #evaluateAndPrintSelection to: self-=JUAMPI=-selectedBorderStyleFor: aBrick  ^self theme tabLabelSelectedBorderStyleFor: aBrick-=JUAMPI=-compileTextIn: aContext from: aSession andDo: aBlock  self announce: (GLMCompileText new           presentation: self;           context: aContext;           session: aSession;           action: aBlock)-=JUAMPI=-sortByColumn: aGlamourColumn  columnToSortBy := columnToSortBy == aGlamourColumn ifTrue: [ nil ] ifFalse: [ aGlamourColumn ].  columnToSortBy ifNotNil: [ self rootItem children: (self rootItem children sorted: self sortBlock) ] ifNil: [ self rootItem data: self basicRoots ].  self glamourPresentation changed-=JUAMPI=-onRemovedFrom: aBrick  -=JUAMPI=-registerModule: aModule  ^self registerModule: aModule to: self named: thisContext sender selector-=JUAMPI=-acceptDroppingMorph: transferMorph event: evt inMorph: listMorph  | targetItem |  targetItem := (listMorph scrollerSubMorphFromPoint: evt position) complexContents item.  ^self glamourPresentation accept: transferMorph passenger droppedOnItem: targetItem-=JUAMPI=-composite: anObject  composite := anObject-=JUAMPI=-shouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]-=JUAMPI=-delete  super delete.  isOpen := false-=JUAMPI=-testCompositeInTheParentPane  | browser |  browser := GLMBrowser new.  self assert: (browser pane presentations isKindOf: GLMCompositePresentation).  self assert: browser pane presentations size equals: 1.  self assert: browser pane presentations first equals: browser-=JUAMPI=-isHeightClean  ^self brick wrappedBounds isHeightClean-=JUAMPI=-wrapped  ^wrapped ifNil: [ wrapped := true ]-=JUAMPI=-percent  ^percent-=JUAMPI=-testMultipleSelectionWithChange  | browser firstTreeMorph secondTreeMorph treeNodeMorph lastTreeNodeMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list           beMultiple;           display: [:x |  x - 2 to: x ] ].  window := browser openOn: 4.  firstTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  treeNodeMorph := firstTreeMorph scroller submorphs first.  lastTreeNodeMorph := firstTreeMorph scroller submorphs last.  self send: firstTreeMorph mouseUpOnItem: treeNodeMorph.  self send: firstTreeMorph mouseUpWithShift: true onItem: lastTreeNodeMorph.  self assert: (firstTreeMorph model selection selectedNodePathList collect: [:each |  each first item ]) asOrderedCollection equals: #(2 3 4) asOrderedCollection.  (browser pane port: #entity) value: 42.  secondTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  treeNodeMorph := secondTreeMorph scroller submorphs first.  lastTreeNodeMorph := secondTreeMorph scroller submorphs second.  self send: secondTreeMorph mouseUpOnItem: treeNodeMorph.  self send: secondTreeMorph mouseUpWithShift: true onItem: lastTreeNodeMorph.  self assert: (secondTreeMorph model selection selectedNodePathList collect: [:each |  each first item ]) asOrderedCollection equals: #(40 41) asOrderedCollection-=JUAMPI=-id: anObject  id := anObject-=JUAMPI=-specificTableMorphInitializiation  | presentation |  presentation := tableModel glamourPresentation.  tableMorph rowHeight: presentation rowHeight.  presentation isSearchable ifTrue: [ tableMorph enableSearch ].  presentation isFilterable ifTrue: [ presentation needActionButton ifTrue: [ tableMorph enableFilterWithAction: presentation actionBlock named: presentation actionName ] ifFalse: [ presentation hasFilterBlock ifTrue: [ tableMorph enableFilter: (GLMFilterBlock block: presentation filterBlock) ] ifFalse: [ tableMorph enableFilter ] ] ].  (presentation isFilterable or: [ presentation isSearchable ]) ifFalse: [ tableMorph disableFunction ] ifTrue: [ tableMorph explicitFunction ]-=JUAMPI=-spotterThemer  ^self registerModule: GTSpotterWidgetThemer new to: GTSpotterBrickThemer new-=JUAMPI=-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-=JUAMPI=-invalidateLayout  ^self brick invalidateLayout-=JUAMPI=-addLazyPage: aBlock label: aStringOrMorph toolbar: aToolbar  self addLazyPage: aBlock label: aStringOrMorph toolbar: aToolbar collapsable: false-=JUAMPI=-isMenu  ^self hasTitle and: [ self hasIcon not ]-=JUAMPI=-render: aPane  paneMorph := GLMMorphic containerMorph.  aPane when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationsChanged: to: self.  self renderMorphFor: aPane.  ^paneMorph-=JUAMPI=-addRow: aBlockOrSymbol  | newRow cell |  cell := aBlockOrSymbol isSymbol ifTrue: [ self browser addNewPaneNamed: aBlockOrSymbol.        GLMCustomRow new           id: aBlockOrSymbol;           browser: self browser ] ifFalse: [ newRow := GLMCustomRow new browser: self browser.        aBlockOrSymbol value: newRow.        newRow ].  self children addLast: cell.  ^cell-=JUAMPI=-privateStyle: aText  | styledText |  aText makeAllColor: Color red.  styledText := self parser parse: aText asString onError: [  ].  (styledText notNil and: [ styledText ~~ aText ]) ifTrue: [ self flag: 'change only the runs array of the original text.'.        aText setString: aText string setRunsChecking: styledText runs ]-=JUAMPI=-newPane  ^newPane-=JUAMPI=-initializeTextMorph  textMorph := RubScrolledTextMorph new.  textMorph     beReadOnly;     beWrapped;     textFont: self theme textFont;     textColor: self theme textColor;     backgroundColor: self theme errorPopperBackgroundColor.  self     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: textMorph fullFrame: LayoutFrame identity-=JUAMPI=-allowItemDrag: aBlock  allowItemDragBlock := aBlock-=JUAMPI=-privateScrollPosition: anInteger  scrollPosition := anInteger.  self announcer announce: GLMBrickScrollPositionChanged new-=JUAMPI=-relabelTab: aTab with: aStringOrBrick  aTab label: aStringOrBrick.  self updateTabs-=JUAMPI=-newVerticalScrollbar  ^GLMScrollbarBrick new-=JUAMPI=-shouldBeDisplayedByText  self containerTree shouldFilterByTextInput ifFalse: [ ^true ].  self withContentsDo: [:node |  self flag: 'this should be delegated to the presentation		and glamourValue should be used to include the entity ports'.        (self containerTree glamourPresentation filterStrategy value: self containerTree inputText asString value: node item) == true ifTrue: [ ^true ] ].  ^false-=JUAMPI=-isOnParent  ^false-=JUAMPI=-asyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]-=JUAMPI=-isVShrinking  ^vResizing = #shrinkWrap-=JUAMPI=-addBrickBackNoLayout: aBrick before: anotherBrick  self band doNotLayoutDuring: [ self band addBrick: aBrick before: anotherBrick ].  ^aBrick-=JUAMPI=-renderCustomColumn: aCell ofPane: aPane inUI: aMorph inBrowser: aBrowser  | pane totalSpans totalSizes currentSpanPosition currentOffset |  totalSpans := aCell children inject: 0 into: [:sum :each |  sum + each span ].  totalSizes := aCell children inject: 0 into: [:sum :each |  sum + each size ].  currentSpanPosition := 0.  currentOffset := 0.  aCell children keysAndValuesDo: [:index :each |  each hasId ifTrue: [ pane := self renderObject: (aBrowser paneNamed: each id) ] ifFalse: [ pane := GLMMorphic containerMorph.              self renderCustomRow: each ofPane: aPane inUI: pane inBrowser: aBrowser.              pane addPaneSplitters ].        pane layoutFrame: (LayoutFrame new                 topFraction: currentSpanPosition / totalSpans offset: currentOffset - (totalSizes * currentSpanPosition / totalSpans) rounded + self margin;                 leftFraction: 0 offset: 0;                 bottomFraction: (currentSpanPosition + each span) / totalSpans offset: currentOffset + each size - (totalSizes * (currentSpanPosition + each span) / totalSpans) rounded - self margin;                 rightFraction: 1 offset: 0;                 yourself).        aMorph addMorphBack: pane.        currentSpanPosition := currentSpanPosition + each span.        currentOffset := currentOffset + each size ].  aCell children last size > 0 ifTrue: [ (aMorph submorphs atLast: 2) layoutFrame bottomOffset: (aMorph submorphs atLast: 2) layoutFrame bottomOffset - currentOffset.        aMorph submorphs last layoutFrame topOffset: aMorph submorphs last layoutFrame topOffset - currentOffset.        aMorph submorphs last layoutFrame bottomOffset: aMorph submorphs last layoutFrame bottomOffset - currentOffset ].  aMorph addPaneSplitters-=JUAMPI=-testFillBrickInsideStatic  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullFill.  brick brickApi layout hState isOnParent.  brick brickApi layout vState isOnParent.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: brick extent equals: root extent-=JUAMPI=-press  super press.  self closePopup-=JUAMPI=-modelFor: aPresentation  | highlightContext |  highlightContext := aPresentation highlightSmalltalkContext.  ^GLMRubricSmalltalkTextModel new     glamourPresentation: aPresentation;     highlightSmalltalk: highlightContext notNil;     highlightSmalltalkContext: highlightContext;     yourself-=JUAMPI=-complete: anObject callback: aBlock  process ifNil: [ ^self terminate ].  process isTerminated ifFalse: [ ^self ].  callback = aBlock ifFalse: [ ^self terminate ].  callback ifNotNil: [ callback cull: anObject ].  process := nil-=JUAMPI=-glmSubscriptions  ^registry subscriptions-=JUAMPI=-updatePanes  self basicUpdateSizing.  self layoutPanes.  self hideOrShowScrollBar.  self setScrollDeltas.  self scrollToRight-=JUAMPI=-verticalScrollbar  ^verticalScrollbar-=JUAMPI=-rowMorphForItem: anItem  | rowElements |  rowElements := OrderedCollection new.  anItem depth timesRepeat: [ rowElements add: self class emptyMorph ].  rowElements add: (self buttonFor: anItem).  (self iconFor: anItem data) ifNotNil: [:icon |  rowElements add: icon asMorph ].  rowElements     add: (self formatedDisplayValueOf: anItem data) asMorph asReadOnlyMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: anItem data).  ^Smalltalk ui theme newRowIn: self currentWorld for: rowElements-=JUAMPI=-bindingsStrategy: aBlock  bindingsStrategy := aBlock-=JUAMPI=-postCopy  super postCopy.  presentations ifNotNil: [:arg |  presentations := presentations collect: [:each |  each copy ] ].  arrangement ifNotNil: [:arg |  arrangement := arrangement copy.        arrangement composite: self ]-=JUAMPI=-text: aTextOrString  text := aTextOrString.  self glamourPresentation ifNotNil: [:presentation |  presentation text: text ]-=JUAMPI=-click: anEvent  super click: anEvent.  self announcer announce: (GLMPagerButtonClicked new buttonModel: self)-=JUAMPI=-measureSelectionTimeForSize: size  | browser numberOfSelections time port window |  numberOfSelections := 15.  browser := self defaultBrowser.  window := browser openOn: size.  port := browser panes first ports second.  time := Time millisecondsToRun: [ size - numberOfSelections to: size do: [:i |  port value: i ] ].  window delete.  ^{size .   time}-=JUAMPI=-computeTagsFilterFor: aGlamourValue  ^self computeTagsFor: aGlamourValue from: self tagsFilterBlock-=JUAMPI=-textColor: aColor  < brickBuilderProperty: #Text name: 'Text color' as: #brickBuilderEvaluate getter: #textColor model: #GLMUIBuilderTextFieldProperty>  self label textColor: aColor.  self dotsBrick textColor: aColor-=JUAMPI=-cellColumn: column row: rowIndex  | element cell |  element := self elementAt: rowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForElement: element);     yourself.  ^cell-=JUAMPI=-sortBlock: aBlock  sortBlock := aBlock-=JUAMPI=-testBrickDependsOnChildrenOneStatic  | root brick |  root := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self assert: root brickApi layout hState isOnChildren.  self assert: root brickApi layout vState isOnChildren.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: brick extent-=JUAMPI=-headerFor: anObject in: aCollapsable  | header |  header := GLMBrick new.  header     hSpaceFill;     vShrinkWrap.  header addBrickBack: (anObject isVariableBinding ifTrue: [ anObject key asBrick ] ifFalse: [ anObject asBrick ]) hSpaceFill.  (self hasChildren: anObject) ifTrue: [ header addBrickFirst: (self newToggleButtonFor: aCollapsable) ].  ^header-=JUAMPI=-act: aBlock on: aCharacter  self addAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           yourself)-=JUAMPI=-remove: anObject  collection remove: anObject.  self announce: GLMItemRemoved-=JUAMPI=-separatorAfter  ^separatorAfter ifNil: [ false ]-=JUAMPI=-paneMargin  self flag: 'fix support of margin'.  ^0-=JUAMPI=-property  ^property-=JUAMPI=-testUnregisterFromAnnouncementsWhenUpdating  | composite announcingCollection numberOfExecutions |  numberOfExecutions := 0.  announcingCollection := GLMAnnouncingCollection new.  composite := GLMCompositePresentation new with: [:a |  a text           updateOn: GLMItemAdded from: [ announcingCollection ];           display: [ numberOfExecutions := numberOfExecutions + 1 ] ].  window := composite openOn: announcingCollection.  1 to: 3 do: [:each |  announcingCollection add: each ].  self assert: numberOfExecutions equals: 4-=JUAMPI=-onLayouted  self doNotUpdateDuring: [ self update ]-=JUAMPI=-rowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValue-=JUAMPI=-lazyPageMorphCreation: anObject  lazyPageMorphCreation := anObject-=JUAMPI=-loremIpsum  ^String loremIpsum: 81233-=JUAMPI=-updatePreview: anIndex  self announcer announce: (GLMPagerPreviewUpdate new pageIndex: anIndex)-=JUAMPI=-transformation  ^transformation ifNil: [ transformation := [:x |  x ] ]-=JUAMPI=-onMyselfDo: aBlock  ^self on: #isOnMyself do: aBlock ifAbsent: [ GLMBrickLayoutMyselfState new ]-=JUAMPI=-findSatisfying: aBlock in: aMorph  aMorph allMorphsDo: [:each |  (aBlock value: each) ifTrue: [ ^each ] ].  self fail-=JUAMPI=-paddingLeft  ^self wrappedBounds paddingLeft-=JUAMPI=-withIndexDo: aBlock  ^collection withIndexDo: aBlock-=JUAMPI=-asGlamourTargetIdentifier  self portName ifNil: [ self portName: self class defaultTargetPortName ].  ^self-=JUAMPI=-arrangement: anArrangement  anArrangement composite: self.  ^arrangement := anArrangement-=JUAMPI=-entity  ^entity-=JUAMPI=-minimumPageNumberForScrollbar  ^minimumPageNumberForScrollbar-=JUAMPI=-assertHeightDirty: aBrick  self assert: aBrick wrappedBounds heightState equals: #dirty.  self assert: aBrick wrappedBounds isHeightDirty.  self assert: aBrick wrappedBounds isHeightClean not-=JUAMPI=-isHorizontal: anObject  isHorizontal := anObject-=JUAMPI=-registerModule: aModule to: aThemer  ^self registerModule: aModule to: aThemer named: thisContext sender selector-=JUAMPI=-toWatcher  ^self destination: (self browser watcherPane port: #entity)-=JUAMPI=-populate: aPortSymbol iconName: aSymbol on: aCharacter entitled: aString with: aBlock  self populate: aPortSymbol icon: (self iconNamed: aSymbol) on: aCharacter entitled: aString with: aBlock-=JUAMPI=-presentations: anObject  presentations := anObject-=JUAMPI=-menuColumn: column row: rowIndex  | menu subMenus targetMenuMorph subMenu |  menu := UIManager default newMenuIn: self table for: self.  subMenus := Dictionary new.  self allMenuActions do: [:action |  targetMenuMorph := action category notNil ifTrue: [ subMenus at: action category ifAbsentPut: [ subMenu := MenuMorph new.                    menu add: action category subMenu: subMenu.                    subMenu ] ] ifFalse: [ menu ].        (targetMenuMorph add: action title target: self selector: #executeMenuAction: argument: action)           icon: action icon;           balloonText: action help;           enabled: (action isEnabledOn: self glamourPresentation);           keyText: (action hasShortcut ifTrue: [ action shortcutAsString ] ifFalse: [ nil ]) ].  ^menu-=JUAMPI=-cellColumn: aColumn row: aRowIndex  | item cell |  item := self elementAt: aRowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForColumn: aColumn item: item withIndex: aRowIndex);     yourself.  ^cell-=JUAMPI=-testCodeExecutionWithBindings  | composite textMorph result |  composite := GLMCompositePresentation new.  composite pharoScript.  window := composite openOn: 'a:=1'.  result := nil.  textMorph := self find: RubScrolledTextMorph in: window.  textMorph textArea editor evaluateSelectionAndDo: [:r |  result := r ].  self assert: result equals: 1-=JUAMPI=-rightAngle: aDirection  ^aDirection = GLMNorthDirection uniqueInstance-=JUAMPI=-stylerStyled: styledCopyOfText  next ifNil: [ ^self ].  text runs: styledCopyOfText runs.  (self textArea scrollPane ifNil: [ self textArea ]) changed-=JUAMPI=-onDraw: aCanvas  self renderer render: self on: aCanvas-=JUAMPI=-render: aPresentation  textModel := self textModelFor: aPresentation.  textMorph := self textMorphForModel: textModel.  textModel text: textMorph text.  textMorph setSelection: textModel selection.  self installActionsOnModel: textModel fromPresentation: aPresentation.  self installKeystrokeActionsOnMorph: textMorph textMorph fromPresentation: aPresentation.  textMorph announcer when: GLMSelectedTextChanged do: [:ann |  aPresentation announcer suspendAllWhile: [ aPresentation selectionInterval: ann interval.              aPresentation selectedText: ann selectedText ] ].  textMorph announcer when: GLMTextChanged do: [:ann |  aPresentation suspendAllWhile: [ aPresentation text: ann text ] ].  self registerEventsForPresentation: aPresentation.  ^textMorph-=JUAMPI=-open: aPopupBrick with: aRectangle  ^aPopupBrick openAbove: aRectangle-=JUAMPI=-isWidthClean  ^self brick wrappedBounds isWidthClean-=JUAMPI=-buttonBorderColor  ^Color lightGray-=JUAMPI=-presentation  presentation ifNil: [ | morph |        morph := GLMMorphicRenderer new render: self glmPres.        morph hResizing: #spaceFill.        morph vResizing: #spaceFill.        presentation := MorphicGenericAdapter morph: morph ].  ^presentation-=JUAMPI=-selectedIndex  ^selectedIndex ifNil: [ selectedIndex := 0 ]-=JUAMPI=-selectionIndex: anInteger  selectionIndex := anInteger-=JUAMPI=-onButtonDeselected  GLMPagerPanePreviewMorph uniqueInstance hideFromWorld-=JUAMPI=-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-=JUAMPI=-onLostFocus  self isCancelOnFocusLost & self isEditMode ifTrue: [ self cancel ].  self isEditMode ifTrue: [ self animateToEditNotFocused ] ifFalse: [ self animateToNormal ]-=JUAMPI=-watcherPane  ^watcherPane ifNil: [ watcherPane := GLMPane named: #_watcher ]-=JUAMPI=-privateRemoveOutWorld: aBrick  aBrick outOfWorld: aBrick world-=JUAMPI=-actionSelector  ^#morphicActOn:-=JUAMPI=-border  ^self valueOfProperty: #brickBorder ifAbsentPut: [ GLMBrickBorder new ]-=JUAMPI=-variableBindings  ^(variableBindingsBlock glamourValue: self entity) ifNil: [ OrderedCollection new ]-=JUAMPI=-testAccordion  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a accordionArrangement.        a list title: 'List'.        a text title: 'Text' ].  window := browser openOn: 42.  self assert: self compositePanel submorphs notEmpty.  self assert: self compositePanel submorphs size equals: 2.  self assert: self compositePanel submorphs first class equals: ExpanderMorph.  self assert: self compositePanel submorphs last class equals: ExpanderMorph-=JUAMPI=-clear  arrangement := nil.  presentations := nil-=JUAMPI=-testPanes  self assert: copiedBrowser panes size equals: 2.  self assert: copiedBrowser panes first ~~ browser panes first.  self assert: copiedBrowser panes last ~~ browser panes last.  self assert: copiedBrowser panes first browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes last browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes first ports size equals: 1.  self assert: copiedBrowser panes first ports first name equals: #selection.  self assert: copiedBrowser panes first ports first pane identicalTo: copiedBrowser panes first.  self assert: copiedBrowser panes last ports size equals: 2.  self assert: copiedBrowser panes last ports first name equals: #selection.  self assert: copiedBrowser panes last ports last name equals: #entity-=JUAMPI=-addBrick: aBrick before: otherBrick  | result |  result := self privateAddBrick: aBrick asBrick before: otherBrick.  self privatePrepareBrickAfterAdding: result.  self doLayoutForce.  ^aBrick-=JUAMPI=-glmAnimateValue: aValue duration: anInteger  self glmAnimateValue: aValue duration: anInteger callback: nil-=JUAMPI=-layoutSubbricks  self layoutPolicy layout: self brickApi in: self innerBounds-=JUAMPI=-actionThemer  ^GLMActionBrickThemer new-=JUAMPI=-textEditBrick  ^textEditBrick-=JUAMPI=-renderFastTreePresentation: aPresentation  ^GLMMorphicFastTreeRenderer render: aPresentation from: self-=JUAMPI=-separatorWidth  ^20-=JUAMPI=-columns: aCollection  columns := aCollection-=JUAMPI=-animateToEditNotFocused  self borderAnimation     from: self borderColor first;     to: self themer normalBorderColor;     animate: self-=JUAMPI=-column: aBlockOrString evaluated: aBlock modified: aModifiedBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           modifiedBlock: aModifiedBlock)-=JUAMPI=-defaultSelectionActions  ^self executionSelectionActions-=JUAMPI=-leftShadowOf: aBrick on: aCanvas  | gradient width origin offset |  width := aBrick shadowWidth.  offset := width negated @ width / 2.0.  origin := aBrick brickBounds topLeft + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin - offset + ((width / 2.0) @ 0);     direction: (width @ 0) negated;     yourself.  aCanvas fillRectangle: (origin extent: width @ (aBrick height - width)) fillStyle: gradient-=JUAMPI=-changed  self world ifNil: [ ^self ].  ^fullBounds ifNil: [ self invalidRect: self bounds ] ifNotNil: [ self invalidRect: fullBounds ]-=JUAMPI=-testMarkerOneChildrenInStaticWidth  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullDependsOnChildren.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightClean-=JUAMPI=-announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]-=JUAMPI=-popup: aPopupBrick event: anEvent  < return: #Boolean>  ^anEvent type == #keystroke and: [ anEvent keyCharacter = Character escape ]-=JUAMPI=-shouldDisplayPresentationCreatedBy: aCollection  ^true-=JUAMPI=-scrollBarColor  ^self valueOfProperty: #brickScrollbarColor ifAbsent: [ self themer scrollbarColor ]-=JUAMPI=-tabWidth  ^tabWidth ifNil: [ TextStyle default rubTabWidth ]-=JUAMPI=-actualPageMorph: anObject  actualPageMorph := anObject-=JUAMPI=-subbrickBefore  | link |  link := self brickDoubleLink.  link ifNil: [ ^nil ].  link previousLink ifNil: [ ^nil ].  ^link previousLink value-=JUAMPI=-renderFastListPresentation: aPresentation  ^GLMMorphicFastListRenderer render: aPresentation from: self-=JUAMPI=-scrollDown: anInteger  self band translateY: anInteger negated.  self isBottomOverscrolled ifTrue: [ self moveBandBottom ]-=JUAMPI=-tearDown  window ifNotNil: [ window delete ].  super tearDown-=JUAMPI=-variableBindings: aBlock  ^variableBindingsBlock := aBlock-=JUAMPI=-colorRight  ^self color at: Right-=JUAMPI=-testUnregisterAnnouncementsWhenRemovingPane  | announcer presentation browser pane |  announcer := Announcer new.  browser := GLMBrowser new.  pane := GLMPane new.  presentation := GLMPresentation new.  pane addPresentation: presentation.  browser addPane: pane.  presentation updateOn: GLMTestAnnouncement from: [ announcer ].  presentation registerAnnouncements.  self assert: announcer numberOfSubscriptions equals: 1.  browser removePane: pane.  self assert: announcer numberOfSubscriptions equals: 0-=JUAMPI=-vMargin  ^self marginTop + self marginBottom-=JUAMPI=-addActiveOrigin: aPort  ^self originReferences add: (GLMOriginPortReference new           port: aPort;           beActive;           yourself)-=JUAMPI=-glamourPresentation  ^glamourPresentation-=JUAMPI=-testFinder  | finder |  finder := GLMFinder new.  finder show: [:a |  a title: 'something'.        a stackedArrangement.        a list.        a text ].  self assert: finder transmission transmissionStrategy presentations size equals: 2.  finder startOn: (1 to: 42).  self assert: finder panes first presentations size equals: 2.  self assert: (finder panes first presentations arrangement isKindOf: GLMStackedVerticallyArrangement).  window := finder open.  self find: LazyTabGroupMorph in: window-=JUAMPI=-presentations  ^self pane presentations-=JUAMPI=-removeTabIndex: anInteger  self tabs removeAt: anInteger.  self selectedIndex: 0.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ]-=JUAMPI=-font: aLogicalFont  self label font: aLogicalFont.  self dotsBrick font: aLogicalFont-=JUAMPI=-selectToLeft  self selectedPageIndex: self selectedPageIndex - 1-=JUAMPI=-glamourPresentation  ^glamourPresentation-=JUAMPI=-openInBrickWindow  ^self openInBrickWindowLabeled: self-=JUAMPI=-sizeLogic: aBlockWithNoParameters  countLogic := aBlockWithNoParameters-=JUAMPI=-initialize  super initialize.  self on: #keyStroke send: #handleKeyStroke: to: self.  hasInitialStep := false-=JUAMPI=-textModelFor: aPresentation  ^GLMTextModel new     text: aPresentation formatedDisplayValue;     glamourPresentation: aPresentation-=JUAMPI=-testAccordionWithTitle  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a accordionArrangement.        a title: 'title'.        a list.        a text ].  window := browser openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: ExpanderMorph-=JUAMPI=-gtActionsIn: composite  < gtInspectorPresentationOrder: 50>  composite list     title: 'Actions';     display: [ self actions ];     format: [:each |  each gtDisplayString ]-=JUAMPI=-column: aBlockOrString evaluated: aBlock width: aNumber tags: anObject sortedBy: aSortingBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           width: aNumber;           tags: anObject;           sortBlock: aSortingBlock yourself)-=JUAMPI=-origin: aPoint length: aLength breadth: aBreadth  ^aPoint extent: aLength @ aBreadth-=JUAMPI=-from: anObject  fromLogic := anObject-=JUAMPI=-hAlign  ^self layout hAlign-=JUAMPI=-helpMessage  ^helpMessage ifNil: [ helpMessage := 'Search Input' ]-=JUAMPI=-newSliderBrick  ^GLMPagerScrollSlidingBrick new-=JUAMPI=-isWidthDirty  ^self widthState = #dirty-=JUAMPI=-transformation  ^transformation-=JUAMPI=-render: aBrowser  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #shrinkWrap.  scrollPane := GeneralScrollPane new     changeScrollerTableLayout;     scrollTarget: container;     yourself.  self registerAnnouncementsFor: aBrowser.  aBrowser panes do: [:each |  self addMorphFromObject: each toContainer: container ].  ^scrollPane-=JUAMPI=-modules  ^modules ifNil: [ modules := Dictionary new ]-=JUAMPI=-glamourAction: anObject  glamourAction := anObject-=JUAMPI=-transformation: anObject  transformation := anObject-=JUAMPI=-testInnerTransmissions  | browser1 browser2 presentation innerBrowser |  browser1 := GLMExplicitBrowser new.  browser2 := GLMExplicitBrowser new.  presentation := GLMPresentation new.  browser1 addNewPane name: 'pane1'.  browser2 addNewPane name: 'innerpane 1'.  browser1 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser1;                 name: #entity;                 yourself);           destination: (browser1 panes first port: #entity);           addPresentation: browser2;           yourself).  browser2 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser2;                 name: #entity;                 yourself);           destination: (browser2 panes first port: #entity);           addPresentation: presentation;           yourself).  (browser1 pane port: #entity) value: 42.  innerBrowser := browser1 panes first presentations first.  self assert: innerBrowser transmissions size equals: 1.  self assert: (innerBrowser transmissions first origins first isKindOf: GLMPresentationBoundPort).  self assert: innerBrowser transmissions first origins first pane identicalTo: browser1 panes first-=JUAMPI=-hasMinHeight  ^(self minHeight isNumber ifTrue: [ self minHeight <= 0 ] ifFalse: [ false ]) not-=JUAMPI=-action  ^action-=JUAMPI=-vPadding  ^self paddingTop + self paddingBottom-=JUAMPI=-isEntityPort  ^self name = #entity-=JUAMPI=-when: anAnnouncementClass send: selector to: target  self announcer when: anAnnouncementClass send: selector to: target-=JUAMPI=-toggleFilteringByTag: aTag  (self shouldFilterByTag: aTag) ifTrue: [ self tagsToFilterBy remove: aTag ] ifFalse: [ self tagsToFilterBy add: aTag ].  self resetChildrenContent.  self tableRefresh-=JUAMPI=-printSelection  self announce: GLMPrintSelection-=JUAMPI=-actOnPaneReplaced: ann  container brickRoot popAndReplacePane: (self renderObject: ann newPane)-=JUAMPI=-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderFastTablePresentation: self-=JUAMPI=-selectedClassOrMetaClass  ^self highlightSmalltalkContext-=JUAMPI=-addPresentations: aCollection  self notingPresentationChangeDo: [ aCollection do: [:each |  self addPresentationSilently: each ] ]-=JUAMPI=-category  ^category-=JUAMPI=-testFullAlignCenterShrinkWrapInSpaceFill  | root brick1 brick2 brick3 increment |  increment := 10.  root := self newBrickWithStaticExtent.  brick1 := self newBrickWithFullFill.  brick2 := self newBrickWithFullDependsOnChildren.  brick3 := self newBrickWithSmallStaticExtent.  brick2     vAlign: #center;     hAlign: #center.  root addBrickBack: brick1.  brick1 addBrickBack: brick2.  brick2 addBrickBack: brick3.  self assertAllSubbricksAreClean: root.  self assert: brick2 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 extent: self staticSmallExtent) ceiling.  brick3     height: brick3 height + increment;     width: brick3 width + increment.  self assertAllSubbricksAreClean: root.  self assert: brick2 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 - (increment / 2) extent: self staticSmallExtent + increment) ceiling-=JUAMPI=-icon  ^icon ifNil: [ icon := [ nil ] ]-=JUAMPI=-acceptsSelection: aBoolean  acceptsSelection := aBoolean-=JUAMPI=-filterBlock: anObject  filterBlock := anObject-=JUAMPI=-color  ^self valueOfProperty: #brickBackgroundColor ifAbsent: [ self themer backgroundColor ]-=JUAMPI=-testStartingPreservesItself  | composite finder |  composite := GLMCompositePresentation new.  finder := composite finder.  composite startOn: 42.  self assert: composite pane presentations equals: composite.  self assert: composite first identicalTo: finder-=JUAMPI=-presentation  ^presentation-=JUAMPI=-layoutPolicy  ^self brick layoutPolicy-=JUAMPI=-addRow: aBlockOrSymbol size: anInteger  ^(self addRow: aBlockOrSymbol)     size: anInteger;     span: 0-=JUAMPI=-buttonForTag: each filter: filter  ^(GLMMorphic togglingButtonLabelled: each pressed: (self shouldFilterByTag: filter) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: filter);     yourself-=JUAMPI=-collapse  self contentBrick ifNil: [ ^self ].  self isExpanded ifTrue: [ self removeBrick: self contentBrick ]-=JUAMPI=-bindingsStrategy  ^bindingsStrategy ifNil: [ bindingsStrategy := self defaultBindingsStrategy ]-=JUAMPI=-testGlamourValueWithArgs  self assert: ([ #foo ] glamourValueWithArgs: #(1 2)) equals: #foo.  self assert: ([:first |  Array with: first ] glamourValueWithArgs: #(1 2)) equals: #(1).  self assert: ([:first :second |  Array with: first with: second ] glamourValueWithArgs: #(1 2)) equals: #(1 2).  self assert: ([:first :second :third |  Array with: first with: second with: third ] glamourValueWithArgs: #(1 2)) equals: #(1 2 nil).  self assert: (#yourself glamourValueWithArgs: #(1 2)) equals: 1.  self assert: (#yourself glamourValueWithArgs: #()) equals: nil-=JUAMPI=-markWidthClean  ^self brick wrappedBounds markWidthClean-=JUAMPI=-isVFilling  ^vResizing = #spaceFill-=JUAMPI=-browser  browser ifNil: [ ^GLMNoBrowser new ].  ^browser-=JUAMPI=-vState  ^GLMBrickLayoutDummState new-=JUAMPI=-testCachedPresentation  | dynamic currentPresentation |  dynamic := GLMDynamicPresentation new.  dynamic entity: 42.  dynamic transformation: [:entity |  GLMRubricTextPresentation new ].  currentPresentation := dynamic currentPresentation.  self assert: dynamic cachedPresentation identicalTo: currentPresentation-=JUAMPI=-buttonsBrick: aBrick  buttonsBrick := aBrick.  self buttonsBrick pagerModel: pagerModel.  self buttonsBrick     hShrinkWrap;     vShrinkWrap.  self addBrickBack: self buttonsBrick-=JUAMPI=-act  self subclassResponsibility-=JUAMPI=-beEdit  self isEditMode ifTrue: [ ^self ].  self editBrick updateTextWith: self labelBrick text.  self editBrick moveCursorToIndex: self labelBrick text size + 1.  self addBrickFirst: self editBrick.  self removeBrick: self labelBrick.  self borderColor: (self themer focusedBorderColor alpha: 0).  self editBrick rubric takeKeyboardFocus.  self announce: #onEditMode-=JUAMPI=-maxWidth: anObject  self layout maxWidth: anObject-=JUAMPI=-backgroundColor  ^Color transparent-=JUAMPI=-maxHeight: anObject  maxHeight := anObject-=JUAMPI=-sendOneOrMultiple  self sendOneOrMultipleAs: Array-=JUAMPI=-testJumpstartTransmission  | browser presentation |  browser := GLMExplicitBrowser new.  presentation := GLMPresentation new.  browser addNewPane.  browser addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (browser pane port: #entity);           destination: (browser panes first port: #entity);           addPresentation: presentation;           yourself).  self assert: (browser panes first port: #entity) value isNil.  self assertEmpty: browser panes first presentations.  (browser pane port: #entity) value: #foo.  self assert: (browser panes first port: #entity) value equals: #foo.  self assert: browser panes first presentations size equals: 1.  self assert: browser panes first presentations first rootPrototype equals: presentation-=JUAMPI=-markDirtyCustomDependency: aBrick inContext: aContextBrick  aBrick isBrick not | (aBrick = aContextBrick) ifTrue: [ ^self ].  (self hasCustomDependencies: aBrick) ifTrue: [ self markDirty: aBrick.        aBrick subbricks do: [:each |  each isBrick ifTrue: [ self markDirty: each.                    self markDirtyAround: each inContext: aBrick ] ].        (self customDependencies: aBrick) do: [:each |  | brick |              [ brick := (each brickValue: aBrick) brickApi ] on: Exception do: [ brick := nil ].              brick ifNotNil: [ (brick = aContextBrick) not & (brick = aBrick) not & brick isBrick ifTrue: [ (self isClean: brick) ifTrue: [ self markDirty: brick.                                self markDirtyAround: brick inContext: aBrick ] ] ] ] ]-=JUAMPI=-onChangeOfPort: aPortName act: aBlock  self portChangeActions add: (GLMPortChangeAction new           portName: aPortName;           action: aBlock)-=JUAMPI=-setFocused  focused ifFalse: [ self checkedImage: checkedFocusedIcon.        self check.        focused := true ]-=JUAMPI=-value: anObject in: aContext  (self validate: anObject) ifFalse: [ ^self ].  self port value: anObject in: aContext-=JUAMPI=-notingPresentationChangeDo: aBlock  aBlock value-=JUAMPI=-glamourExpander  ^glamourExpander-=JUAMPI=-testIsRendered  self assert: tabs pages first isRendered not.  tabs selectedPageIndex: 1.  self assert: tabs pages first isRendered.  self assert: tabs pages second isRendered not-=JUAMPI=-column: aBlockOrSymbol  ^self addColumn: aBlockOrSymbol-=JUAMPI=-dragResizingLeft: anEvent  | left right |  right := self brickBounds right.  left := anEvent position x - self owner globalBounds left - startDragX.  left := (left max: 0) min: right - self pagerModel circleButtonSize.  self setPosition: left @ right-=JUAMPI=-checkBrick: anObject  checkBrick := anObject.  self box     borderColor: self themer checkboxBorderColor;     borderWidth: self themer checkboxBorderWidth;     vAlign: #center;     checkedImage: self themer checkboxCheckedImage;     width: self themer checkboxWidth;     height: self themer checkboxHeight.  self addBrickFirst: self box-=JUAMPI=-newDataSource: anObject  newDataSource := anObject-=JUAMPI=-shoutAboutToStyle: aPluggableShoutMorph  self highlightSmalltalk ifFalse: [ ^false ].  self highlightSmalltalkContext ifNotNil: [:classOrMetaClass |  aPluggableShoutMorph classOrMetaClass: classOrMetaClass ].  ^true-=JUAMPI=-shouldUseCache  ^self glamourPresentation shouldUseCache-=JUAMPI=-step  | newText |  newText := self textLogic value asString.  self text = newText ifTrue: [ ^self ].  self text: newText.  self doLayoutForce-=JUAMPI=-updateInsetAndSpacing  self triggerBrick margin: {self inset top .         self inset right .         0 .         self inset left}.  self contentBrick margin: {self spacing .         self inset right .         self inset bottom .         self inset left}-=JUAMPI=-computeWidth  ^self pagerModel ifNil: [ 0 ] ifNotNil: [:m |  m circleButtonSize * m actualNumberOfVisiblePages ]-=JUAMPI=-invalidateMorphBounds: isForce  | origin corner newBounds |  isLayouting & isForce not ifTrue: [ ^self ].  origin := self paddingLeft @ self paddingTop.  corner := self paddingRight @ self paddingBottom.  newBounds := self globalBounds.  newBounds := newBounds origin + origin corner: newBounds corner - corner.  self morph bounds: newBounds-=JUAMPI=-in: aTableBrick  table := aTableBrick.  self initializeColumns-=JUAMPI=-popAndReplacePane: aMorph  transform removeMorph: transform lastSubmorph.  transform submorphs isEmpty ifFalse: [ transform removeMorph: transform lastSubmorph ].  paneCount := paneCount - 1.  aMorph     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0.  transform hasSubmorphs ifTrue: [ transform addMorphBack: self separator ].  transform addMorphBack: (aMorph adoptPaneColor: self paneColor).  paneCount := paneCount + 1.  self updatePanes-=JUAMPI=-morph: aBlock  morphBuilder := aBlock-=JUAMPI=-isHeightCustom  ^self vState isOnMyself-=JUAMPI=-addDefaultStatusbarTransmissionFrom: aPane  | defaultTransmission |  defaultTransmission := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (aPane port: #status);     destination: (self statusbarPane port: #entity);     addPresentation: self statusbarPresentation;     yourself.  self addTransmission: defaultTransmission-=JUAMPI=-setProperty: aSymbol toValue: anObject  super setProperty: aSymbol toValue: anObject-=JUAMPI=-scrollToPane: pageIndex callback: aBlock  self scrollTo: (self convertIndexToValue: pageIndex) smooth: true callback: aBlock-=JUAMPI=-breadcrumbItemTriangleStyleFor: aBrick  aBrick     height: self breadcrumbTriangleHeight;     hSpaceFill-=JUAMPI=-stream  ^stream-=JUAMPI=-setAmountVisible: visible all: all  self amountBrick text: visible asString , '/' , all asString.  self amountBrick wrappedBounds markWidthDirty.  self amountBrick doLayout.  self doLayoutForce-=JUAMPI=-debugger  ^debugger-=JUAMPI=-gtInspectorContentIn: composite  < gtInspectorPresentationOrder: 0>  composite pharoScript     title: 'Content';     display: #content;     installDefaultSelectionActions-=JUAMPI=-prepareProcessorInContext: aContext  super prepareProcessorInContext: aContext.  self hasDynamicItems ifTrue: [ allCandidates := nil ]-=JUAMPI=-decreaseZindex: aBrick  aBrick layoutProperties zIndex: 1-=JUAMPI=-implementors: aSelector  ^self implementors: aSelector inPackages: self defaultPackages-=JUAMPI=-content: aString  content := aString asString-=JUAMPI=-errorMessage  ^'error obtaining value'-=JUAMPI=-defaultOrder  ^220-=JUAMPI=-setTitleAndEnsureInStash: aString  self title: aString.  self ensureStashPersistency.  self save-=JUAMPI=-showFirst: aBlock  self browser showFirst: aBlock-=JUAMPI=-methodActionsFor: aMethod  ^aMethod selector isUnary ifTrue: [ Array with: self evaluationAction ] ifFalse: [ #() ]-=JUAMPI=-debugAction: aDebugAction  debugActionHolder value: aDebugAction-=JUAMPI=-initialize  super initialize.  self headerBrick: self newHeaderBrick-=JUAMPI=-testFailingDate  | aDateAndTime |  aDateAndTime := DateAndTime     localTimeZone: TimeZone default;     dosEpoch.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1 January 1980 1:00 pm' asDateAndTime-=JUAMPI=-basicFilterInContext: aSpotterContext  self prepareProcessorInContext: aSpotterContext.  (self shouldFilterInContext: aSpotterContext) ifTrue: [ allFilteredCandidates := self doFilterInContext: aSpotterContext ].  aSpotterContext stream performSymbol: #onAmountChanged:in: withArguments: {self allFilteredCandidates size .         self}-=JUAMPI=-matchContext: aContext  self subclassResponsibility-=JUAMPI=-selectedItemBrick  ^selectedItemBrick-=JUAMPI=-notifyPaneRemoved  ^notifyPaneRemoved ifNil: [ false ]-=JUAMPI=-previewWidthPercent  ^40-=JUAMPI=-context: anObject  context := anObject-=JUAMPI=-handleException: anException  ^self handleException: anException do: [ ('[Spotter] Exception: ' , anException asString) traceCr ]-=JUAMPI=-previousStep  < return: #GTSpotterStep>  self assert: self hasPreviousStep.  ^self spotter steps at: (self spotter steps indexOf: self) - 1-=JUAMPI=-onChildrenLayouted  super onChildrenLayouted.  self band translateXTo: (self band data ifNil: [ 0 ]).  self scrollToTheLastOne-=JUAMPI=-addPage: aPage  self pages addFirst: aPage-=JUAMPI=-fileName  ^self page creationTimeForFileName , '.' , GTPlayPage fileExtension-=JUAMPI=-size  ^size ifNil: [ size := 0 ]-=JUAMPI=-assertDebuggerClosing  debugger close.  self assert: window model equals: nil.  self assert: debugger session interruptedContext equals: nil.  self assert: debugger session interruptedProcess equals: nil-=JUAMPI=-pages  ^pages ifNil: [ pages := self defaultPages ]-=JUAMPI=-onCandidateSelected: ann  self updatePreviewWith: ann selected-=JUAMPI=-detachSession  self flag: 'why silent value?'.  (self browser pane port: #entity) silentValue: nil-=JUAMPI=-index: anInteger  index := anInteger-=JUAMPI=-isInteresting  ^self contentString trimBoth isEmpty not-=JUAMPI=-testBasic  | def cls |  cls := self class.  def := cls definitionForSpotter.  self assert: (def beginsWith: cls definition)-=JUAMPI=-defaultKeymap  ^PharoShortcuts current cancelShortcut-=JUAMPI=-id  ^#gtWhereIs-=JUAMPI=-candidateLinks: anObject  candidateLinks := anObject-=JUAMPI=-originalSession: aDebugSession  originalSession := aDebugSession-=JUAMPI=-denySearch: aString  self basicSearch: aString.  self assert: previousContext identicalTo: currentContext.  self assert: previousContext identicalTo: spotter currentStep context.  self assert: (previousContext matches: aString)-=JUAMPI=-prepareFilterInContext: aSpotterContext  super prepareFilterInContext: aSpotterContext.  self regex: (caseSensitive ifTrue: [ self query asRegex ] ifFalse: [ self query asRegexIgnoringCase ])-=JUAMPI=-allPragmasWithTag  ^PragmaCollector allSystemPragmas select: [:pragma |  pragma key == self tagPragmaKey ]-=JUAMPI=-from: anAnnouncement  debugActionExecutedAnnouncement := anAnnouncement-=JUAMPI=-setTitle: aString  self withWindowDo: [:w |  w title: aString ]-=JUAMPI=-borderColor  ^Smalltalk ui theme borderColor-=JUAMPI=-notifyDiveInCategory: aProcessor for: anEventType  self announce: (GTSpotterDiveInCategory new           category: aProcessor;           eventType: anEventType)-=JUAMPI=-itemsLimit: anInteger  candidatesLimit := anInteger-=JUAMPI=-candidateLinks  ^candidateLinks-=JUAMPI=-newPreviewBrick  ^GTSpotterPreviewBrick new-=JUAMPI=-history: aWeakCollection  history := aWeakCollection-=JUAMPI=-key  ^self subclassResponsibility-=JUAMPI=-order: aNumber  order := aNumber-=JUAMPI=-defaultOrder  ^30-=JUAMPI=-shouldEnableProcessorsCreateBy: aMethod  ^true-=JUAMPI=-helpButton: aBrick  | tree item |  helpButton ifNotNil: [ self removeBrick: helpButton ].  helpButton := aBrick.  self themer spotterThemer helpButtonWidgetStyleFor: helpButton.  self themer spotterThemer helpButtonStyleFor: helpButton.  helpButton     hintTitle: 'Spotter help';     action: [ self spotterModel exitDueTo: #actionButton.        tree := HelpBrowser open instVarNamed: #treeMorph.        item := tree allItems detect: [:each |  each complexContents item key = GTSpotterHelp key ].        tree selection: item ].  self addBrickBack: helpButton-=JUAMPI=-newHelpButton  ^GLMHintableActionButtonBrick new-=JUAMPI=-matchSubstrings  self filter: GTFilterSubstrings-=JUAMPI=-notifyPaneRemoved: anObject  notifyPaneRemoved := anObject-=JUAMPI=-installDebuggingActionsFor: aPresentation  self installActionsForRootPragmas: self debuggingActionsPragmas in: aPresentation-=JUAMPI=-onSearchFinished  self spotterModel currentStep candidates isEmpty ifTrue: [ self updatePreviewWithEmpty ]-=JUAMPI=-select  super select.  self showActionbar-=JUAMPI=-spotterModel  ^spotterModel-=JUAMPI=-requestNextCategoryStepWith: aProcessorLink for: anEventType  | collection |  collection := aProcessorLink processor allFilteredCandidates collect: [:each |  each asSpotterCandidateLink renderingProcessor: aProcessorLink ].  self requestNextStepWith: collection for: anEventType-=JUAMPI=-childrenNodesFor: aVariablesBrowser  ^self hostObject childrenNodesFor: aVariablesBrowser-=JUAMPI=-pragmas: aSelector  ^self pragmas: aSelector inPackages: self defaultPackages-=JUAMPI=-inspectInstances  self currentClassOrMetaClass ifNotNil: [:aClass |  aClass instanceSide inspectAllInstances ]-=JUAMPI=-selectPreviousCategory  | currentCategory previousCategory |  self selected ifNil: [ ^self ].  currentCategory := self candidates getProcessorLinkByCandidateLink: self selected.  previousCategory := self candidates previousProcessorLinkOf: currentCategory.  self select: previousCategory headLink-=JUAMPI=-compose  self pager     minimumPageNumberForScrollbar: 2;     show: [:a :each |  a dynamic display: [:x |  (GLMCompositePresentation new with: [:aComposite |  each gtDebuggerPresentationsIn: aComposite inContext: self.                    self attachExtraBehaviourToPresentationsIn: aComposite.                    aComposite ]) startOn: x ] ].  self first when: GLMPaneAdded send: #actOnPaneAdded: to: self.  self first when: GLMPaneRemoved send: #actOnPaneRemoved: to: self-=JUAMPI=-onStepPopped  self pop-=JUAMPI=-matcher  ^matcher-=JUAMPI=-printArray: anArray  | limitedString limit |  limit := 50000.  limitedString := String streamContents: [:aStream |  anArray gtInspectorFastPrintOn: aStream ] limitedTo: limit.  limitedString size < limit ifTrue: [ ^limitedString ].  ^limitedString , '...etc...'-=JUAMPI=-testTestInfinitDebugger  < expectedFailure>  | preWindow debugButton debugWindow overButton process |  process := [ TestClassForTestingDebuggerTest debug: #bla ] forkAt: 41.  1000 milliSecond asDelay wait.  self currentWorld doOneCycle.  preWindow := (self currentWorld allMorphs select: [:e |  (e isKindOf: SystemWindow) and: [ e label beginsWith: 'Instance of ' ] ]) first.  debugButton := (preWindow allMorphs select: [:e |  (e isKindOf: PluggableButtonMorph) and: [ e label = 'Debug' ] ]) first.  debugButton performAction.  preWindow := nil.  debugButton := nil.  100 milliSecond asDelay wait.  self currentWorld doOneCycle.  debugWindow := (self currentWorld allMorphs select: [:e |  (e isKindOf: SystemWindow) and: [ e label beginsWith: 'Instance of Test' ] ]) first.  overButton := (debugWindow allMorphs select: [:e |  (e isKindOf: GLMPluggableButtonMorph) and: [ e label = 'Over' ] ]) first.  overButton performAction.  100 milliSecond asDelay wait.  self currentWorld doOneCycle.  process terminate.  debugWindow close-=JUAMPI=-newCompositeBrick  ^GLMCompositeBrick new-=JUAMPI=-itemsLimit  ^candidatesLimit ifNil: [ self defaultItemsLimit ]-=JUAMPI=-printStackMethodColumnForContext: aContext  | outer selector |  outer := aContext outerMostContext.  ^String streamContents: [:aStream |  selector := outer selector ifNil: [ outer method defaultSelector ].        aStream nextPutAll: selector ]-=JUAMPI=-theme  ^Smalltalk ui theme-=JUAMPI=-rawValue: anObject  value := anObject-=JUAMPI=-filteredItems: aCollection  filteredItems := aCollection-=JUAMPI=-basicContinueFilterInContext: aSpotterContext  (self shouldFilterInContext: aSpotterContext) ifTrue: [ self doContinueFilterInContext: aSpotterContext ].  aSpotterContext stream performSymbol: #onAmountChanged:in: withArguments: {self allFilteredCandidates size .         self}-=JUAMPI=-dropDownBrick: aBrick  dropDownBrick ifNotNil: [ self removeBrick: dropDownBrick ].  dropDownBrick := aBrick asBrick.  dropDownBrick morph pagerModel: self spotterModel pagerModel.  self themer spotterThemer dropDownPaneStyleFor: dropDownBrick.  self addBrickBack: dropDownBrick-=JUAMPI=-debuggerTransmissionsIn: browser  browser transmit     fromOutsideEntityPort;     to: #stack;     andShow: [:composite |  self stackIn: composite ].  browser transmit     from: #stack port: #entity;     to: #stack port: #selection;     when: [:session |  session notNil ];     transformed: [:session |  self contextToSelectFrom: session ].  browser transmit     from: #stack port: #selection;     to: #stack port: #action;     transformed: [:context |  self selectionChanged: context ].  self transmitFromStackToCodeIn: browser.  browser transmit     from: #stack port: #selection;     to: #inspector;     andShow: [:composite |  self inspectorIn: composite ]-=JUAMPI=-defaultOrder  ^10-=JUAMPI=-snippetAt: anObject put: aString  ^self snippets at: anObject put: aString-=JUAMPI=-assertionContext  ^assertionContext-=JUAMPI=-applyFilterWithQuery  super applyFilterWithQuery.  self filteredItems: (self filteredItems reject: [:each |  each isFromTrait ])-=JUAMPI=-renderLeftTriangle: aBrick on: aCanvas  | a b c width height |  width := aBrick brickBounds width.  height := aBrick brickBounds height.  a := aBrick brickBounds topRight + (0 @ (height / 2 - width max: 0)).  b := aBrick brickBounds topRight + (0 @ (height / 2 + width min: height)).  c := aBrick brickBounds topLeft + (0 @ (height / 2)).  self renderTriangle: aBrick on: aCanvas with: {a asIntegerPoint .         b asIntegerPoint .         c asIntegerPoint}-=JUAMPI=-isPartiallyVisibleAbove: aBrick  ^(self isFullyVisible: aBrick) not & (self isAbove: aBrick)-=JUAMPI=-defaultPagerModel  ^GLMPagerModel new-=JUAMPI=-spotterPreviewCodeIn: aComposite  < spotterPreview: 10>  aComposite pharoMethod     title: 'Preview';     display: #content;     smalltalkClass: [ nil ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'-=JUAMPI=-browseClassVarRefs  | cls |  cls := self currentClass.  (cls notNil and: [ cls isTrait not ]) ifTrue: [ self systemNavigation browseClassVarRefs: cls ]-=JUAMPI=-close  self withWindowDo: #close-=JUAMPI=-query  ^query-=JUAMPI=-filter: aGTFilter item: aGTSpotterIterator  self filter: aGTFilter.  self items: aGTSpotterIterator gtIterator-=JUAMPI=-rawValue  ^self hostObject tempNamed: tempName-=JUAMPI=-errorMessage  ^self hostObject errorMessage-=JUAMPI=-variableNodesFor: anObject  | variableNodes |  variableNodes := OrderedCollection new: anObject class allSlots size.  variableNodes add: (GTInspectorSelfNode hostObject: anObject).  self basicVariableNodesFor: anObject in: variableNodes.  ^variableNodes-=JUAMPI=-configurationBlockForProcessorsCreatedBy: aMethod  ^configurationBlocks at: aMethod printString ifAbsent: [ self nullConfigurationBlock ]-=JUAMPI=-buildVariablesFromContext: aContext  ^aContext gtBytecodeDebuggerRetrieveContextValues-=JUAMPI=-nullConfigurationBlock  ^[:processor |   ]-=JUAMPI=-select: aBlock as: aCollectionClass  | collection |  collection := self newAs: aCollectionClass.  self do: [:each |  (aBlock value: each) ifTrue: [ collection add: each ] ].  ^collection-=JUAMPI=-initialize  super initialize.  self needsUpdate: false.  self needsValidation: false-=JUAMPI=-debuggerToTest  ^GTBytecodeDebugger-=JUAMPI=-shouldRefresh  | newCache result |  newCache := self generateCacheFor: self entity.  result := cachedHashes ~= newCache.  cachedHashes := newCache.  ^result-=JUAMPI=-defaultLabel  ^'Browse'-=JUAMPI=-spotterForPackagesFor: aStep  < spotterOrder: 20>  aStep listProcessor     allCandidates: [ RPackageOrganizer default packages ];     title: 'Packages';     itemName: [:package |  package name ];     itemIcon: [ Smalltalk ui icons iconNamed: #packageIcon ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: false-=JUAMPI=-hintRevealStyleFor: aBrick  aBrick ifNil: [ ^self ].  (aBrick valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifTrue: [ ^self ].  aBrick setProperty: #brickSpotterBackupColor toValue: aBrick color.  aBrick setProperty: #brickSpotterBackupBorder toValue: aBrick border.  aBrick setProperty: #brickSpotterIsReveal toValue: true.  aBrick color: self themer popupHelpThemer backgroundColor.  aBrick border: GLMBrickBorder new.  aBrick borderColor: (self themer popupHelpThemer borderColor alpha: 0.6).  aBrick borderWidth: self themer popupHelpThemer borderWidth.  aBrick changed-=JUAMPI=-bytecodeIn: aComposite forContext: aContext  (self methodBytecodeWidgetIn: aComposite forContext: aContext)     initialize: [:bytecodePresentation |  bytecodePresentation selection: (self session symbolicBytecodeForCurrentPCFrom: self currentContext) ];     with: [:bytecode |  self installActionsForRootPragmas: self bytecodeActionsPragmas in: bytecode ]-=JUAMPI=-asTruncatedTextFrom: anObject  ^self class asTruncatedTextFrom: anObject-=JUAMPI=-methodCodeIn: composite forContext: aContext  (self methodCodeWidgetIn: composite forContext: aContext)     initialize: [:code |  code selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ];     with: [:code |  self installCodeActionsFor: code ]-=JUAMPI=-withItemsLimit: aLimit do: aBlock  | previousCandidatesLimit |  previousCandidatesLimit := candidatesLimit.  ^[ candidatesLimit := aLimit.  aBlock value ] ensure: [ candidatesLimit := previousCandidatesLimit ]-=JUAMPI=-searchFieldTextColor  ^Color white slightlyDarker-=JUAMPI=-testMock  self assert: spotter class equals: GTMockSpotter.  self assert: spotter newStep class equals: GTMockSpotterStep.  self assert: spotter newStep asyncTask class equals: GTMockSpotterTask-=JUAMPI=-onThemerChanged  super onThemerChanged.  self themer spotterThemer itemActionbarStyleFor: self.  self subbricks do: [:aBrick |  self themer spotterThemer itemActionButtonWidgetStyleFor: aBrick ]-=JUAMPI=-label  ^'[' , self key , ']'-=JUAMPI=-privateAddIntoWorld: aBrick  super privateAddIntoWorld: aBrick.  self setAmountVisible: self subbricksCount all: '...'-=JUAMPI=-subclassesOf: aClass inPackage: aPackageName  ^(RPackageOrganizer default packages detect: [:each |  each packageName = aPackageName ] ifNone: [ ^#() ]) classes intersection: aClass withAllSubclasses-=JUAMPI=-interruptedProcess  ^self session interruptedProcess-=JUAMPI=-reset  items := nil-=JUAMPI=-initialize  super initialize.  self band: self newBand-=JUAMPI=-size  ^self items size-=JUAMPI=-processors  ^categories ifNil: [ categories := DoubleLinkedList new ]-=JUAMPI=-bytecodeActionsPragmas  ^#(bytecodeCodeDebuggingAction)-=JUAMPI=-spotterForFilesFor: aStep  < spotterOrder: 40>  self flag: #specialFilter.  aStep listProcessor     title: 'Files';     itemIcon: [ GLMUIThemeExtraIcons glamorousBrowse ];     itemFilterName: [:reference |  reference basename ];     filter: GTFilterFileReference item: [:filter :context |  self fileReferencesBy: #files inContext: context usingFilter: filter ];     wantsToDisplayOnEmptyQuery: false-=JUAMPI=-band  ^band-=JUAMPI=-printStackClassColumnForContext: aContext  | outer class methodClass |  outer := aContext outerMostContext.  ^String streamContents: [:aStream |  class := outer receiver class.        aStream nextPutAll: class name.        methodClass := outer methodClass.        methodClass == class ifFalse: [ aStream                 nextPut: $(;                 nextPutAll: methodClass name;                 nextPut: $) ] ]-=JUAMPI=-fileDirectory  ^GTPlayBook stashDirectory-=JUAMPI=-nextProcessorLinkOf: aProcessorLink  | current |  aProcessorLink ifNil: [ ^aProcessorLink ].  current := aProcessorLink nextLink.  current ifNil: [ current := self processors head ].  [ current = aProcessorLink ] whileFalse: [ current isEmpty ifFalse: [ ^current ].        current := current nextLink.        current ifNil: [ current := self processors head ] ].  ^aProcessorLink-=JUAMPI=-itemNameFor: anObject  ^itemNameBlock ifNil: [ super itemNameFor: anObject ] ifNotNil: [ itemNameBlock cull: anObject ]-=JUAMPI=-defaultTag: aSymbol  defaultTag := aSymbol-=JUAMPI=-terminateProcessors  self steps do: [:each |  each terminateProcessors ]-=JUAMPI=-creationTime: anObject  creationTime := anObject-=JUAMPI=-scrollToTheLastOne  | leftDelta rightDelta delta |  self items isEmpty ifTrue: [ ^self ].  rightDelta := self globalBounds right - self band globalBounds right.  leftDelta := self globalBounds left - self band globalBounds left.  (leftDelta = 0 and: [ self items size <= self maxNumberOfSteps ]) ifTrue: [ ^self ].  delta := self items size <= self maxNumberOfSteps ifTrue: [ leftDelta ] ifFalse: [ rightDelta ].  delta := self band brickBounds left + delta - self band data.  self glmAnimateBrickBounds: delta duration: 400 callback: nil-=JUAMPI=-evaluatorIn: composite  ^composite pharoScript     doItReceiver: [:object |  object ];     smalltalkClass: [:object |  object class ];     display: [:object |  String streamContents: [:stream |  stream                 nextPutAll: (self printStringOf: object);                 cr;                 nextPutAll: (GTSnippets snippetAt: object class) ] ];     onChangeOfPort: #text act: [:textPresentation :object |  GTSnippets snippetAt: object class put: (self stringWithoutInitialCommentFrom: textPresentation text asString).        textPresentation clearUserEdits ];     installDefaultSelectionActions-=JUAMPI=-bytecodePresentation  ^self bytecodePane presentations first-=JUAMPI=-innerBorderWidth  ^1-=JUAMPI=-exceptionHandler  self flag: 'Bloc -> overrides doesNotUnderstand discarding the current exception context'.  ^GTCurrentSpotterExceptionHandler value ifNil: [ self step exceptionHandler ]-=JUAMPI=-applyFilterWithQuery  | allItemsPrepocessed allItemsPrepocessedAndSorted alikeMatches otherMatches upper lower |  alikeMatches := OrderedCollection new.  otherMatches := OrderedCollection new.  allItemsPrepocessed := OrderedCollection streamContents: [:allItems |  lower := lowerThreshold * query size.        self allItemsDo: [:each |  | weight |              (weight := (self itemFilterNameFor: each) alike: query) > lower ifTrue: [ allItems nextPut: (Array with: weight with: each) ] ] ].  allItemsPrepocessedAndSorted := allItemsPrepocessed asSortedCollection: [:a :b |  a first > b first ].  upper := allItemsPrepocessed isEmpty ifTrue: [ upperThreshold ] ifFalse: [ (allItemsPrepocessedAndSorted collect: [:each |  each first ]) median ].  allItemsPrepocessedAndSorted do: [:each |  each first >= upper ifTrue: [ alikeMatches add: each last.              alikeMatches size > self itemsLimit ifFalse: [ self addItem: each ] ] ifFalse: [ otherMatches add: each last ] ].  alikeMatches size < self itemsLimit ifTrue: [ (otherMatches first: (self itemsLimit - alikeMatches size min: otherMatches size)) do: [:each |  self addItem: each ] ].  self filteredItems: alikeMatches , otherMatches-=JUAMPI=-hasQuery  ^self query isEmptyOrNil not-=JUAMPI=-newTriangleBrick  ^GLMHintableActionButtonBrick new-=JUAMPI=-streamed: anObject  streamed := anObject-=JUAMPI=-rawValue  ^self subclassResponsibility-=JUAMPI=-variableTag  ^'temp'-=JUAMPI=-applyFilter  ^self filteredItems-=JUAMPI=-itemHoveredBackgroundColor  ^self itemSelectedBackgroundColor alpha: 0.35-=JUAMPI=-initialize  super initialize.  self needsUpdate: false-=JUAMPI=-hintHideStyleFor: aBrick  aBrick ifNil: [ ^self ].  (aBrick valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifFalse: [ ^self ].  aBrick setProperty: #brickSpotterIsReveal toValue: false.  (aBrick hasProperty: #brickSpotterBackupColor) ifTrue: [ aBrick color: (aBrick valueOfProperty: #brickSpotterBackupColor) ].  (aBrick hasProperty: #brickSpotterBackupBorder) ifTrue: [ aBrick border: (aBrick valueOfProperty: #brickSpotterBackupBorder) ].  aBrick changed-=JUAMPI=-applyFilterInContext: aSpotterContext error: exception  super applyFilterInContext: aSpotterContext error: exception.  ^(GTFilterSubstrings new     caseSensitive: self caseSensitive;     yourself) value: aSpotterContext-=JUAMPI=-getText  ^self text-=JUAMPI=-initialize  super initialize.  processorsFilter := GTSpotterSettingsProcessorFilter new-=JUAMPI=-testDeploymentExceptionHandlerMock2  self assertResetExceptions.  self shouldntRaise: MessageNotUnderstood process: 'abc' origin: GTSpotterExceptionMock2 new.  self assertException: MessageNotUnderstood.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock2 new.  self assertException: MessageNotUnderstood-=JUAMPI=-exceptionHandler  ^exceptionHandler ifNil: [ exceptionHandler := self defaultExceptionHandler ]-=JUAMPI=-defaultLabel  ^'Profile it'-=JUAMPI=-addItems: aCollection  self context streamed addAll: aCollection.  self context addItems: aCollection-=JUAMPI=-addItem: anObject  self stream addObject: anObject inProcessor: self processor-=JUAMPI=-spotterUsersFor: aStep  < spotterOrder: 50>  ^aStep listProcessor     title: 'Users';     filter: GTFilterSubstring item: [:filter :context |  self users do: [:sender |  filter value: sender ] ]-=JUAMPI=-debugger  ^debugger-=JUAMPI=-currentStep: aStepModel  currentStep := aStepModel.  self notifyCurrentStepChanged-=JUAMPI=-formatStackExtraColumnForContext: aContext  ^Text string: (self printStackExtraColumnForContext: aContext) attributes: (self textAttributesForStackEntry: aContext)-=JUAMPI=-history  ^history ifNil: [ self class history ]-=JUAMPI=-testAddThreeCandidateA1A2A3Shuffled  | link11 link12 link13 link21 link22 link23 link31 link32 link33 category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link31 := candidates addCandidate: 31 in: GTSpotterA3.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link32 := candidates addCandidate: 32 in: GTSpotterA3.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  link33 := candidates addCandidate: 33 in: GTSpotterA3.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: link11 nextLink equals: link12.  self assert: link11 previousLink equals: link33.  self assert: link12 nextLink equals: link13.  self assert: link12 previousLink equals: link11.  self assert: link13 nextLink equals: link21.  self assert: link13 previousLink equals: link12.  self assert: link21 nextLink equals: link22.  self assert: link21 previousLink equals: link13.  self assert: link22 nextLink equals: link23.  self assert: link22 previousLink equals: link21.  self assert: link23 nextLink equals: link31.  self assert: link23 previousLink equals: link22.  self assert: link31 nextLink equals: link32.  self assert: link31 previousLink equals: link23.  self assert: link32 nextLink equals: link33.  self assert: link32 previousLink equals: link31.  self assert: link33 nextLink equals: link11.  self assert: link33 previousLink equals: link32.  self assert: candidates head equals: link11.  self assert: candidates tail equals: link33.  self assert: category1 headLink equals: link11.  self assert: category1 tailLink equals: link13.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link23.  self assert: category3 headLink equals: link31.  self assert: category3 tailLink equals: link33-=JUAMPI=-onAddedSelector: anObject  onAddedSelector := anObject-=JUAMPI=-itemIconMaxWidth  ^50-=JUAMPI=-forDebugger: aDebugger  debugger := aDebugger.  newContext := aDebugger currentContext-=JUAMPI=-stepModel  ^stepModel-=JUAMPI=-testArrayPairsOverLimit  | limit pairs |  limit := 2 * GTInspector indexableDisplayLimit + 1.  pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.  self assert: pairs size equals: 2 * GTInspector indexableDisplayLimit.  (pairs collect: #key) allSatisfy: [:e |  (pairs at: e) = e ].  self assert: (pairs collect: #key) equals: ((1 to: GTInspector indexableDisplayLimit) asOrderedCollection           addAll: (limit - GTInspector indexableDisplayLimit + 1 to: limit) asOrderedCollection;           yourself)-=JUAMPI=-handlesMouseDown: evt  ^true-=JUAMPI=-diveInCategory  ^self diveInCategoryDueTo: #unknown-=JUAMPI=-borderColor: aColor  borderColor := aColor-=JUAMPI=-printSignature: aSignature  ^aSignature first name , '>>' , aSignature second asString-=JUAMPI=-after: afterBlock do: doBlock ifTrue: conditionBlock  | value |  value := conditionBlock brickValue: self.  afterBlock brickValue: self.  value ifTrue: [ doBlock brickValue: value ]-=JUAMPI=-itemNormalStyleFor: aBrick  aBrick     height: [ self itemHeight ];     hSpaceFill-=JUAMPI=-title  ^title ifNil: [ 'Page' ]-=JUAMPI=-objects  ^objects-=JUAMPI=-stepModel: anObject  stepModel := anObject.  self stepModel spotter announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self stepModel spotter announcer when: GTSpotterHideHints send: #onHideHints to: self.  self     addActActionButton;     addDiveInActionButton-=JUAMPI=-defaultStreamed  ^true-=JUAMPI=-buildCategoryBrick: aProcessor  < return: #GTSpotterCategoryBrick>  | titleBrick categoryBrick |  titleBrick := self newTitleBrick on: self stepModel category: aProcessor.  self themer spotterThemer categoryTitleStyleFor: titleBrick.  categoryBrick := self newCategoryBrick on: self stepModel category: aProcessor.  self themer spotterThemer categoryStyleFor: categoryBrick.  categoryBrick titleBrick: titleBrick.  ^categoryBrick-=JUAMPI=-format  ^format-=JUAMPI=-load  self repository workingCopy loadPackageNamed: self name-=JUAMPI=-obtainAvailableRemotes  | remotes |  remotes := self repository remotes.  (remotes includes: self baseRemote) ifFalse: [ remotes := remotes copyWith: self baseRemote ].  ^remotes-=JUAMPI=-mergeBaseBetween: aCommitId and: anotherCommitId  self handleLibgitError: [ ^(self repositoryHandle mergeBaseBetween: (LGitId fromHexString: aCommitId) and: (LGitId fromHexString: anotherCommitId)) hexString ]-=JUAMPI=-timeStamp  ^self datetime-=JUAMPI=-baseLabel  ^'No PR selected'-=JUAMPI=-projectName  ^projectName-=JUAMPI=-isFastForward  ^self headCommit isAncestorOf: mergeCommit-=JUAMPI=-basicExecute  self fetchAllRemotes.  (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec-=JUAMPI=-sortingStrategyFirst: aSymbol  self sortingStrategy first: aSymbol-=JUAMPI=-initializeChangeList  | dataSource |  dataSource := self newChangeTreeDataSource.  changeList widget dataSource: dataSource.  dataSource expandAll-=JUAMPI=-changesFromCommit: anIceNoCommit  ^anIceNoCommit changesFromNoCommit: self-=JUAMPI=-remoteFileReferenceInPath: anUndefinedObject  -=JUAMPI=-issueLabel: anObject  issueLabel := anObject-=JUAMPI=-initializeWidgets  self initializeProjectLocation.  self initializeSpacePanel-=JUAMPI=-workingCopy  ^repository workingCopy-=JUAMPI=-createCommandContextForSelection: selectedItems  ^self newContextWithSelection: selectedItems-=JUAMPI=-fetchFrom: aRemote  aRemote fetch-=JUAMPI=-position: anObject  position := anObject-=JUAMPI=-allBranchModels  ^self entity allBranches collect: [:each |  (IceTipBranchModel repositoryModel: self on: each) beCached ]-=JUAMPI=-tags  ^self commit tags-=JUAMPI=-datetime  ^datetime-=JUAMPI=-repositoryName  ^self repositoryModel name-=JUAMPI=-customError: aDictionary  ^aDictionary at: #message-=JUAMPI=-removeFrom: aStore  aStore removeSSHCredential: self-=JUAMPI=-packageModels  ^self sortingStrategy sort: (self repositoryModel entity workingCopy packages collect: [:each |  (IceTipPackageModel repositoryModel: self repositoryModel on: each) beCached ])-=JUAMPI=-remote: anObject  remote := anObject-=JUAMPI=-privateKey: anObject  privateKey := anObject.  self storeIfDefault-=JUAMPI=-fileNameForMethod: aMethod  | path |  path := OrderedCollection new.  self repository subdirectory ifNotEmpty: [:subDir |  path add: subDir ].  path add: (self tonelPackageName: aMethod package).  path add: (self tonelMethodClassOrTraitName: aMethod).  ^String streamContents: [:stream |  path asStringOn: stream delimiter: '/' ]-=JUAMPI=-longStatus  (entity isMissing and: [ entity location isNil ]) ifTrue: [ ^'Iceberg does not find a git repository. Please clone the repository or change the repository location to an existing Git repository' ].  entity isMissing ifTrue: [ ^'Iceberg does not find a git repository at {1}. Please clone the repository again or change the repository location to an existing Git repository' format: {entity location} ].  entity workingCopy workingCopyState isUnknownCommitState ifTrue: [ ^'This image has a loaded version of the code from commit {1}, but Iceberg does not find the commit in your local Git repository. You may fetch the correct commit from a remote repository or discard the code of your image and load the version that is in the repository.' format: {entity workingCopy referenceCommit shortId} ].  entity workingCopy isDetached ifTrue: [ ^'The loaded code in the image starts from commit {1}. This commit does not correspond with the commit in the head of the current branch of the repository (Commit {2}). You need to synchronize them to continue. You need to discard your image changes or change the HEAD of the repository to point to the commit.' format: {entity workingCopy referenceCommit shortId .               entity headCommit shortId} ].  entity head isDetached ifTrue: [ ^'The repository and the image are in the same commit {1}. However, the commit is not in an active branch. It is not possible to commit in a Git detached HEAD state. Create a new branch (by checkouting) or checkout an existing one.' format: {entity headCommit shortId} ].  entity workingCopy project isUnborn ifTrue: [ ^'Cannot find a project (meta-data and source directory) in your repository. Please edit your repository meta-data to indicate the source code directory or change the location to a valid iceberg repository' ].  ^'Your repository seems ok. Please report a ticket in Iceberg''s issue tracker. If you can, please send us a backup of your image in this state for debugging.'-=JUAMPI=-keysDo: aBlockClosure  childrenDictionary keysDo: aBlockClosure-=JUAMPI=-issueLabel  ^issueLabel-=JUAMPI=-execute  self packageModel remove-=JUAMPI=-headCommit  ^self head commit-=JUAMPI=-push  -=JUAMPI=-snapshotFor: package  ^(self versionFor: package) snapshot-=JUAMPI=-asBornProperties  ^IceRepositoryProperties fromDictionary: properties commitish: commitish-=JUAMPI=-selectedChange  ^(self selectedChangeWrapper ifNil: [ ^nil ]) item value-=JUAMPI=-request: anObject  request := anObject-=JUAMPI=-diffToReferenceCommit  ^self diffTo: self referenceCommit-=JUAMPI=-url  ^url-=JUAMPI=-selectRemoteNamed: aString  remoteList setSelectedItem: (self model remoteModels detect: [:each |  each name = aString ])-=JUAMPI=-table: aTable  super table: aTable.  self addBindingsToTable-=JUAMPI=-selectNextConflict  | next |  next := self nextConflict ifNil: [ ^self ].  self changed: {#openPath} , next item path segments-=JUAMPI=-item  ^self packageModel-=JUAMPI=-descriptionWithDecoration  ^self name asText-=JUAMPI=-isLocal  ^self entity isLocal-=JUAMPI=-cellColumn: column row: rowIndex  ^self newCellFor: (self elementAt: rowIndex)-=JUAMPI=-refreshWhenRepository: ann  (ann repository isNil or: [ self model repositoryModel isModelOf: ann repository ]) ifFalse: [ ^self ].  self model reset.  self refresh-=JUAMPI=-visitPackage: anIcePackageDefinition  | mcPackage snapshot patcher version |  mcPackage := MCPackage named: anIcePackageDefinition name.  snapshot := [ diff targetVersion snapshotFor: anIcePackageDefinition ] on: NotFound do: [ MCSnapshot empty ].  patcher := MCPatcher snapshot: snapshot.  currentNode accept: (IceMCSnapshotPatchVisitor new           patcher: patcher;           yourself).  version := MCVersion new setPackage: mcPackage info: (IceMCVersionInfo package: mcPackage message: 'Internal...') snapshot: patcher patchedSnapshot dependencies: #().  index storeVersion: version-=JUAMPI=-child  ^IceGitChange on: (RelativePath withAll: self path segments allButFirst) pathString-=JUAMPI=-defaultMenuItemName  ^'Open on github'-=JUAMPI=-versionsFor: package  ^self commit versionsFor: package-=JUAMPI=-newContextWithSelection: anObject  ^self newContext     item: anObject;     yourself-=JUAMPI=-refreshDirtyPackages  self markAsCleanPackagesNotInDiff: self repository workingCopyDiff-=JUAMPI=-remotes  self handleLibgitError: [ | gitRemotes |        self isValid ifFalse: [ ^#() ].        gitRemotes := self repositoryHandle allRemotes.        ^gitRemotes collect: [:each |  (IceGitRemote name: each remoteName url: each url)                 localRepository: self;                 yourself ] ]-=JUAMPI=-commit  ^self-=JUAMPI=-isClassDefinition  ^false-=JUAMPI=-execute  self subclassResponsibility-=JUAMPI=-repositoryList  ^repositoryList-=JUAMPI=-mergeWithBranch: aBranch  self subclassResponsibility-=JUAMPI=-entryName  ^entryName-=JUAMPI=-response  ^response-=JUAMPI=-actualClass  ^self contextClass-=JUAMPI=-value  ^list includes: item-=JUAMPI=-typeList: anObject  typeList := anObject-=JUAMPI=-repository  ^commitish repository-=JUAMPI=-packages  tree isEmpty ifTrue: [ ^#() ].  ^self codeSubdirectoryNode children-=JUAMPI=-select: aBlockClosure  ^self-=JUAMPI=-basicNewRemoteBranchNamed: aString  ^IceGitRemoteBranch named: aString inRepository: self-=JUAMPI=-gitRef  ^((repository location / '.git' / 'HEAD') contents withoutPrefix: 'ref: ') trimBoth-=JUAMPI=-initializeWidgets  super initializeWidgets.  repositoryList := self newIceTable.  repositoryList widget onAnnouncement: FTStrongSelectionChanged send: #repositoryStrongSelection: to: self.  self initializeRepositoryList.  self focusOrder add: repositoryList-=JUAMPI=-push  self branch push-=JUAMPI=-optionsList  ^optionsList-=JUAMPI=-nameLabel: anObject  nameLabel := anObject-=JUAMPI=-id: anObject  id := anObject-=JUAMPI=-invalidError: aDictionary  ^'Invalid field: ' , (aDictionary at: #field)-=JUAMPI=-children  ^#()-=JUAMPI=-classIsMeta: anObject  classIsMeta := anObject-=JUAMPI=-changesFromCommit: anIceNoCommit  self assert: anIceNoCommit isNoCommit.  ^#()-=JUAMPI=-sourceDirectory  ^self repository project sourceDirectory-=JUAMPI=-packageNameFromPackageDirectory  ^iceVersion packageName-=JUAMPI=-toText: anObject  toText := anObject-=JUAMPI=-tags  self subclassResponsibility-=JUAMPI=-contextClass  ^IceTipBranchContext-=JUAMPI=-fetchPullRequests  ^(IceGitHubAPI new getPullRequests: self remote owner project: self remote projectName) all collect: [:each |  (IceGitHubPullRequest fromJSON: each)           repository: self repository entity;           yourself ]-=JUAMPI=-messageText  ^'There is no version for package: {1} in  commit {2}' format: {self version packageName .         self version commit id}-=JUAMPI=-shortName  ^self name copyAfter: $/-=JUAMPI=-remoteUrl: anObject  remoteUrl := anObject-=JUAMPI=-visitNonConflictingOperation: anIceNonConflictingOperation  anIceNonConflictingOperation chosenOperation accept: self-=JUAMPI=-withoutNewBranch  types := self allTypes reject: #isNewBranch.  typeList widget dataSource elements: types.  typeList widget refresh-=JUAMPI=-hasSingleCommit  ^self workingCopyState isSingleCommitState-=JUAMPI=-repositoryProperties  ^properties-=JUAMPI=-repository  ^repository-=JUAMPI=-initialize  super initialize.  childrenDictionary := Dictionary new-=JUAMPI=-mergeThen: aBlock  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Merging branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self entity merge ]-=JUAMPI=-includesPackageNamed: aName  ^false-=JUAMPI=-acceptError: anObject  anObject visitShouldCommitBeforePullError: self-=JUAMPI=-reset  UIManager default informUser: 'Refreshing changes' during: [ self resetDiff.        self diff ]-=JUAMPI=-initializeExistingTagsList  existingTagsList := self newList.  existingTagsList     items: commitishToTag tagModels;     displayBlock: #name;     sortingBlock: #name descending-=JUAMPI=-canBrowseReferences  ^self canBeBrowsed-=JUAMPI=-help  ^self commandClass defaultHelp-=JUAMPI=-printOn: aStream  aStream     nextPutAll: self class name;     nextPutAll: '(';     nextPutAll: self name;     nextPutAll: ')'-=JUAMPI=-package  ^package-=JUAMPI=-model: anObject  model := anObject.  self allTypes do: [:each |  each model: anObject ]-=JUAMPI=-mergeIntoWorkingCopy  self repository     ensureBranch: self branchName;     checkoutBranch: self branchName.  self branch merge-=JUAMPI=-visitAuthenticationError: anError  UIManager default alert: anError messageText title: 'Iceberg authentication Error'-=JUAMPI=-initializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: ((self iconNamed: #error) scaledToSize: 32 @ 32) asMorph.  errorLabel := self newIceReadOnlyText.  errorLabel widget contentsWrapped: exception messageText.  errorLabel widget     hResizing: #spaceFill;     vResizing: #spaceFill-=JUAMPI=-createCheckboxFor: anObject  ^CheckboxMorph on: (IceGitHubSelectItem list: selectedItems item: anObject) selected: #value changeSelected: #value:-=JUAMPI=-subscribeToAnnouncements  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: self-=JUAMPI=-ensureDefaultProperties  properties at: #format ifAbsentPut: [ self writerClass id ]-=JUAMPI=-labelFor: aCommitModel  ^'HEAD to {1}' format: {(aCommitModel ifNotNil: #shortId)}-=JUAMPI=-changeList: anObject  changeList := anObject-=JUAMPI=-checkoutWithStrategy: aCheckoutStrategy  repository checkout: (aCheckoutStrategy commitish: self)-=JUAMPI=-hash  ^self commit hash-=JUAMPI=-contentsWithValidationDo: aBlock  ^(self responseWithValidationDo: aBlock) contents-=JUAMPI=-icon  ^self iconNamed: #changeRemove-=JUAMPI=-nextNodeSuchThat: conditionBlock ifNone: noneBlock  self children do: [:each |  (conditionBlock value: each) ifTrue: [ ^each ].        each nextNodeSuchThat: conditionBlock ifFound: [:found |  ^found ] ].  ^self parent nextChildNodeStartingFrom: self suchThat: conditionBlock ifNone: noneBlock-=JUAMPI=-selectRemoteModel  ^selectRemoteModel ifNil: [ selectRemoteModel := IceTipRemoteActionModel repositoryModel: self model on: self model entity ]-=JUAMPI=-contents  ^self basicAt: 1-=JUAMPI=-basicExecute  IceTipRegisterRepositoryDialog new     beForCloneOfRepository: self repositoryModel entity;     onAccept: [ Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity) ];     openDialogWithSpec-=JUAMPI=-onSuccessAnnounce: aValuable  successAnnounceBlock := aValuable-=JUAMPI=-repository  ^repository-=JUAMPI=-fileUtils  ^IceLibgitFiletreeFileUtils-=JUAMPI=-comment  ^self entity comment-=JUAMPI=-mergeWithLeftRemoval: anIceRemoval  ^IceConflictingOperation left: anIceRemoval right: self-=JUAMPI=-keys  ^childrenDictionary keys-=JUAMPI=-definition  ^operation definition-=JUAMPI=-onAccept: aBlock  acceptBlock := aBlock-=JUAMPI=-sourceCode: aString  sourceCode := aString-=JUAMPI=-hasAnyNonConflictConflicts  ^self model mergeTree anySatisfy: [:conflict |  conflict isConflict and: [ conflict isResolved ] ]-=JUAMPI=-model  ^model-=JUAMPI=-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing remote {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self repositoryModel entity removeRemote: self entity ]-=JUAMPI=-credentials: aPlainTextCredential  credential := aPlainTextCredential.  self usernameInput text: credential username.  self passwordInput text: credential password-=JUAMPI=-writerClass  ^self commit writerClass-=JUAMPI=-badgeSelector: aSymbol  badgeSelector := aSymbol-=JUAMPI=-free  (handle isNil or: [ handle isNull ]) ifFalse: [ handle free.        handle := nil ]-=JUAMPI=-referencesSameRemoteLocationAs: aRemote  ^(super referencesSameRemoteLocationAs: aRemote) or: [ (self url withoutSuffix: '.git') sameAs: (aRemote httpsUrl withoutSuffix: '.git') ]-=JUAMPI=-readProjectFromCommitish: aCommitish  self subclassResponsibility-=JUAMPI=-cellColumn: column row: rowIndex  | item |  item := self elementAt: rowIndex.  ^item depth = 0 ifTrue: [ self newRootCellFor: item ] ifFalse: [ self newCellFor: item ]-=JUAMPI=-execute  item copyCommitIDToClipboard-=JUAMPI=-upstreamForBranch: aBranch backend: backend  ^backend lookupBranchNamed: aBranch name inRemote: self remoteName-=JUAMPI=-hash  ^self name hash-=JUAMPI=-contextClass  ^leftOperation contextClass-=JUAMPI=-basepathOf: aPath  self subclassResponsibility-=JUAMPI=-initializeBlock  self signature: self class fnSpec block: self block-=JUAMPI=-repositoryModel: anObject  repositoryModel := anObject-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  item := aToolContext item-=JUAMPI=-menuSelectionContext  ^self tool newContext-=JUAMPI=-initializePresenter  super initializePresenter.  self commits widget onAnnouncement: FTSelectionChanged send: #uptadeSelectedCommit: to: self.  mergeButton action: [ self mergePullRequestIntoImage ].  acceptButton action: [ self acceptPullRequest ].  rejectButton action: [ self rejectPullRequest ]-=JUAMPI=-version: aVersion  version := aVersion-=JUAMPI=-description  ^self class description-=JUAMPI=-diff  ^diff-=JUAMPI=-statusPanel  ^statusPanel-=JUAMPI=-initializeEntity: anObject  entity := anObject.  self initialize-=JUAMPI=-validateCanCommit  self isDetached ifTrue: [ IceWorkingCopyDesyncronized signal ]-=JUAMPI=-fromCommit: aCommit package: aPackage  commit := aCommit.  package := aPackage.  date := commit datetime asDate.  time := commit datetime asTime.  name := '{1}-{2}.{3}' format: {package name .         commit compatibleUsername .         commit datetime asUnixTime}.  id := self class uuidFromCommit: aCommit package: aPackage.  message := commit comment.  author := commit compatibleUsername-=JUAMPI=-location: aReferenceOrString  ^self projectLocation location: aReferenceOrString-=JUAMPI=-commitModels  | commits |  commits := OrderedCollection new.  self entity commitsDo: [:each |  commits add: (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ].  ^commits-=JUAMPI=-repositoryName  ^self repository name-=JUAMPI=-actionPanel  ^actionPanel-=JUAMPI=-tagNameInputText  ^tagNameInputText-=JUAMPI=-name  ^name-=JUAMPI=-initializeDialogWindow: aWindow  super initializeDialogWindow: aWindow.  acceptButton     disable;     label: 'Add'-=JUAMPI=-leftContents  ^definition contents-=JUAMPI=-execute  self withErrorHandlingDo: [ self basicExecute.        self finishSuccess ]-=JUAMPI=-newCredentialsDataSource  ^IceTipDataSource new     tool: self;     elements: self model allCredentials;     yourself-=JUAMPI=-password: anObject  password := anObject-=JUAMPI=-toLabel  ^toLabel-=JUAMPI=-item  ^item-=JUAMPI=-visitRemoval: anIceRemoval  anIceRemoval definition removeFromPatcher: patcher.  self visitChildrenOf: currentNode-=JUAMPI=-projectVersion  ^projectVersion-=JUAMPI=-validateAlreadyPresentAndNotGit  (self remoteToUse isNil and: [ self location notNil and: [ self location exists and: [ (self class isGitRoot: self location) not ] ] ]) ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: {self location fullName}) ]-=JUAMPI=-initializeWidgets  super initializeWidgets.  commitList := self newIceTable.  commitTabPanel := self newTabManager.  self initializeCommitList.  self initializeCommitPanel.  commitList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self focusOrder     add: commitList;     add: commitTabPanel.  self refresh-=JUAMPI=-refresh  self model reset.  self resetDiffContents.  changeList widget     in: [:this |  this basicSelectIndexes: #().        this dataSource           rootForItems: self model treeRoots;           selectAll;           expandAll ];     refresh-=JUAMPI=-merge: changeTree into: currentTree  ^changeTree collectWithPath: [:operation :path |  currentTree resolve: path ifPresent: [:currentOperation |  operation mergeWithOperation: currentOperation ] ifAbsent: [ IceNonConflictingOperation operation: operation ] ]-=JUAMPI=-execute  store removeCredential: credential.  tool refresh-=JUAMPI=-isParentOf: aCommit  ^self newCommitWalk includesCommit: aCommit-=JUAMPI=-open  self openNonModal modalRelativeTo: World.  ^self credentials-=JUAMPI=-title: aString  title := aString-=JUAMPI=-currentCommitishLabel  ^currentCommitishLabel-=JUAMPI=-refresh  commitButton help: ('Commit your changes to {1}' format: {self repositoryName}).  pushCheckbox label: ('Push changes to {1}' format: {self repositoryRemoteName})-=JUAMPI=-sshCredentials  ^IceCredentialStore current sshCredentialForHostname: remote host-=JUAMPI=-= aBranch  ^self fullname = aBranch fullname-=JUAMPI=-ancestors  ^self commit ancestors-=JUAMPI=-packageNameText  ^packageNameText-=JUAMPI=-announcer  ^announcer ifNotNil: #contents-=JUAMPI=-initialExtent  ^(500 @ (self class inputTextHeight * 5 + self class buttonHeight + 50)) scaledByDisplayScaleFactor-=JUAMPI=-icon  self subclassResponsibility-=JUAMPI=-peelTag: anIceTag  self subclassResponsibility-=JUAMPI=-contents  ^self isBinary ifTrue: [ String streamContents: [:stream |  contents hexDumpOn: stream max: Float infinity ] ] ifFalse: [ contents utf8Decoded ]-=JUAMPI=-writeMethodProperties: classMethodDefinitions  self shouldNotImplement-=JUAMPI=-credential  ^credential-=JUAMPI=-remove  repository workingCopy basicRemovePackage: self-=JUAMPI=-projectNameLabel  ^projectNameLabel-=JUAMPI=-initializeWidgets  super initializeWidgets.  packageList := self newIceTable.  statusBar := self instantiate: IceTipStatusBar.  self initializePackageList.  self initializeStatusBar.  self focusOrder add: packageList-=JUAMPI=-checkoutOn: anIceWorkingCopy  anIceWorkingCopy loadPackagesNamed: committish packageNames fromCommit: committish commit.  self repository setHead: committish.  anIceWorkingCopy referenceCommit: committish commit.  anIceWorkingCopy markAllPackagesAsClean-=JUAMPI=-outgoingCommits  ^self entity outgoingCommits-=JUAMPI=-isConflict  ^true-=JUAMPI=-description  ^self name-=JUAMPI=-mergeInto: anIceClassNode  -=JUAMPI=-previewCheckout  < noCache>  (IceTipCheckoutPreviewBrowser onBranch: self) openWithSpec-=JUAMPI=-oldNode: aNode  oldNode := aNode-=JUAMPI=-resolve: aRelativePath ifAbsent: aBlock  ^self resolve: aRelativePath ifPresent: [:each |  each ] ifAbsent: aBlock-=JUAMPI=-hash  ^self item hash-=JUAMPI=-commit: anIceCommit  commit := anIceCommit-=JUAMPI=-selectedBranch  | index |  index := self branchesList widget selectedIndex.  ^index ~= 0 ifTrue: [ self branchesList widget dataSource elementAt: index ] ifFalse: [ nil ]-=JUAMPI=-initializePullRequestsTable  pullRequests widget     beResizable;     addColumn: (IceTipTableColumn new           id: '#';           action: [:pullRequest |  pullRequest number asString ];           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'State';           action: #state;           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 120 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Title';           action: #title;           yourself);     dataSource: self newPullRequestsDataSource-=JUAMPI=-datetime  ^self commit datetime-=JUAMPI=-copyToClipboardId: id  Clipboard clipboardText: id informing: ('Commitish ID copied to clipboard ({1})' format: {id})-=JUAMPI=-contents  ^contents-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  (self repositoryModel isNotNil and: [ self repositoryModel isMissing not ]) ifTrue: [ self badge: self repositoryModel numberOfIncomingCommits ]-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  selectedCommitish := aToolContext item.  selectedBranch := aToolContext selectedBranch-=JUAMPI=-tonelClassExtension: aClass  aClass isTrait ifTrue: [ ^'.trait' ].  ^'.class'-=JUAMPI=-isOkEnabled  ^self username isNotEmpty and: [ self password isNotEmpty ]-=JUAMPI=-onAccept: aBlock  acceptBlock := aBlock-=JUAMPI=-remoteName  ^self remote name , '/' , self entity branch name-=JUAMPI=-commitWithMessage: message  ^self workingCopy commitWithMessage: message-=JUAMPI=-logClass  ^IceLog allSubclasses detect: [:each |  each isAvailableFor: self ]-=JUAMPI=-protocolDropList: anObject  protocolDropList := anObject-=JUAMPI=-commits  ^commits-=JUAMPI=-diffToWorkingCopy  ^self diffTo: self repository workingCopy-=JUAMPI=-validateChangeListNotEmpty  items ifEmpty: [ IceNothingToCommit signal ]-=JUAMPI=-version: aString  version := aString-=JUAMPI=-isRemoval  ^false-=JUAMPI=-hasAnyNonIncomingConflicts  ^self model mergeTree anySatisfy: [:conflict |  conflict isConflict and: [ conflict isResolved not or: [ conflict isLeftChosen ] ] ]-=JUAMPI=-forceCalculateDirtyPackages  | diff |  diff := IceDiff new     sourceVersion: self;     targetVersion: self referenceCommit;     buildFull.  self loadedPackages do: [:each |  each beDirty: (diff includesPackageNamed: each name) ]-=JUAMPI=-initialize  super initialize.  categories := #()-=JUAMPI=-workingCopy  ^self repository workingCopy-=JUAMPI=-nextNodeSuchThat: conditionBlock ifFound: foundBlock  self children do: [:each |  (conditionBlock value: each) ifTrue: [ ^foundBlock value: each ].        each nextNodeSuchThat: conditionBlock ifFound: [:found |  ^foundBlock value: found ] ]-=JUAMPI=-mergeWithOperation: anOperation  ^anOperation mergeWithLeftAddition: self-=JUAMPI=-extent  ^self subclassResponsibility-=JUAMPI=-title  ^'New tag of ' , commitishToTag name-=JUAMPI=-matches: aPackageModel  ^aPackageModel name asLowercase includesSubstring: self pattern asLowercase-=JUAMPI=-commitModels  | commits |  commits := OrderedCollection new.  self entity commitsDo: [:each |  commits add: (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ].  ^commits-=JUAMPI=-selectionChanged: ann  | element |  (ann newSelectedIndexes reject: [:each |  each = 0 ]) ifNotEmpty: [:indexes |  element := changeList widget dataSource realElementAt: indexes first.        self diffContentsLeft: element value rightContents right: element value leftContents ] ifEmpty: [ self resetDiffContents ]-=JUAMPI=-initializeMajor: majorNumber minor: minorNumber patch: patchNumber  major := majorNumber.  minor := minorNumber.  patch := patchNumber-=JUAMPI=-details  ^details-=JUAMPI=-inverse  ^IceModification left: self rightDefinition right: self leftDefinition-=JUAMPI=-doesNotUnderstand: aMessage  aMessage selector isUnary ifTrue: [ cache at: aMessage selector ifPresent: [:value |  ^value ].        (self realObject class lookupSelector: aMessage selector) ifNotNil: [:method |  (method hasPragmaNamed: #noCache) ifFalse: [ ^cache at: aMessage selector put: (self forwardMessage: aMessage) ] ] ].  ^self forwardMessage: aMessage-=JUAMPI=-url  ^url-=JUAMPI=-fetch  [ ^self remote fetch ] ensure: [ fetched := true ]-=JUAMPI=-repository  ^iceCommit repository-=JUAMPI=-doCommit: aCollection message: aString pushing: aBoolean  self model commit: (IceTipCommitAction new           diff: self model workingCopyDiff;           items: aCollection;           message: aString;           yourself) then: [ self verifyNeedsRefreshOrClose.        aBoolean ifTrue: [ (IceTipPushAction new repository: self model entity) execute ] ]-=JUAMPI=-isRepositoryDetached  ^self repositoryModel isNil or: [ self repositoryModel isDetached ]-=JUAMPI=-hash  ^commitish hash-=JUAMPI=-writerClass  ^self properties writerClass-=JUAMPI=-displayString  ^self entity name-=JUAMPI=-textForMergeable: mergeable  mergeable = true ifTrue: [ ^'Yes' ].  mergeable = false ifTrue: [ ^'There are conflicts' ].  ^mergeable asString-=JUAMPI=-ensureSourceCodeParentNodeIn: aNode  ^self ensureDirectoryAtPath: diff repository subdirectoryPath segments inNode: aNode-=JUAMPI=-visitNoRemote: anError  UIManager default alert: 'There are no remotes defined for this repository. Add one before continue.' title: 'Remote action failed'-=JUAMPI=-checkoutStrategy  ^checkoutStrategy-=JUAMPI=-execute  | repo cloneOptions checkoutOptions callbacks |  location exists ifTrue: [ IceCloneLocationAlreadyExists signalFor: location ].  [ location ensureCreateDirectory.  repo := LGitRepository on: location.  cloneOptions := LGitCloneOptions withCredentialsProvider: (IceCredentialsProvider defaultForRemoteUrl: url).  checkoutOptions := cloneOptions checkoutOptions.  callbacks := cloneOptions fetchOptions callbacks.  callbacks transferProgress: IceGitTransferProgress new.  checkoutOptions checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force.  checkoutOptions progressCallback: IceGitCheckoutProgress new.  repo clone: url options: cloneOptions.  (LGitRemote of: repo named: 'origin')     lookup;     setUrl: url ] on: LGitCallReturnHandler , IceWrongUrl do: [:error |  location exists ifTrue: [ location ensureDeleteAll ].        error acceptError: (IceLibgitErrorVisitor onContext: self) ]-=JUAMPI=-branchName: aString  branchName := aString-=JUAMPI=-execute  | selection |  selection := UIManager default request: 'Please provide the name of the new branch to be created' initialAnswer: '' title: 'Create new branch'.  selection isEmptyOrNil ifTrue: [ ^self ].  self repository createBranch: selection.  self beSuccess-=JUAMPI=-username: anObject  username := anObject-=JUAMPI=-iceVersion  ^commit versionFor: package-=JUAMPI=-location: aReferenceOrString  | ref |  ref := aReferenceOrString asFileReference.  keptLocation ifNotNil: [ | newRef |        newRef := (self location pathString copyReplaceAll: keptLocation pathString with: ref pathString) asFileReference.        keptLocation := ref.        ref := newRef ].  self basicLocation: ref-=JUAMPI=-username: aUsername project: aProject  path := aUsername , '/' , aProject-=JUAMPI=-choosen: anObject  choosen := anObject-=JUAMPI=-handlesMouseDown: evt  ^false-=JUAMPI=-isNewBranch  ^false-=JUAMPI=-model  ^model-=JUAMPI=-baseLabel  ^baseLabel-=JUAMPI=-showFilterFieldFromKeystrokeEvent: anEvent  | text |  text := anEvent keyCharacter asString.  self textField takeKeyboardFocus.  self textField text: self textField text , text.  self flag: #hack.  self textField textArea cursorEnd: anEvent-=JUAMPI=-isExtensionDefinition  ^true-=JUAMPI=-title  ^model isCurrent ifTrue: [ 'Current Iceberg credentials' ] ifFalse: [ 'Credentials of ' , model printString ]-=JUAMPI=-cancelAction  -=JUAMPI=-basicUrl: aString  url := aString-=JUAMPI=-package  ^package-=JUAMPI=-visitRemoval: anIceRemoval  anIceRemoval definition removeFrom: self-=JUAMPI=-publicKeyInput  ^publicKeyInput-=JUAMPI=-okAction  credentialStore storeCredential: self credentials forHostname: self host.  tool refresh-=JUAMPI=-initializeSourceDirectory  subdirectoryLabel := self newLabel label: 'Source directory'.  subdirectoryInputText := self newTextInput     ghostText: 'e.g., src';     autoAccept: true.  subdirectoryInputText text: self defaultSubdirectory-=JUAMPI=-packageName  ^package-=JUAMPI=-printOn: aStream  aStream nextPutAll: version asString-=JUAMPI=-isModified  ^self entity isModified-=JUAMPI=-remoteModels  ^self entity remotes collect: [:each |  (IceTipRemoteModel repositoryModel: self on: each) beCached ]-=JUAMPI=-hasLocalBraches  ^self localBranches isNotEmpty-=JUAMPI=-changesFromCommit: anIceCommit  ^(self modifiedPackages collect: [:each |  IceImageChange package: each ]) asArray , (self referenceCommit changesFromCommit: anIceCommit) asArray-=JUAMPI=-selectionHasActualClass  ^self selectedChangeWrapper ifNil: [ false ] ifNotNil: [:w |  w item value contextClass notNil ]-=JUAMPI=-showEmptyTab  emptyTab ifNil: [ emptyTab := self newEmptyTab ].  self removeAllCommitPanelTabs.  commitTabPanel addTab: emptyTab-=JUAMPI=-textField  ^textField-=JUAMPI=-versionLike: selectBlock ifNone: ifNoneBlock  ^self repository branch versionsFor: self detect: selectBlock ifNone: ifNoneBlock-=JUAMPI=-diff: anIceDiff  diff := anIceDiff-=JUAMPI=-includes: aRelativePath  ^modifiedFilePaths includes: aRelativePath-=JUAMPI=-initialize  super initialize.  isAnonymous := false-=JUAMPI=-isRemoval  ^true-=JUAMPI=-commit: anIceGitCommit  repository handleLibgitError: [ | localBranch gitcommit |        localBranch := self repositoryHandle lookupLocalBranch: self name.        gitcommit := self repositoryHandle revparse: anIceGitCommit id.        localBranch setTargetId: gitcommit id.        self = repository head ifTrue: [ self repositoryHandle checkout_treeish: gitcommit opts: (LGitCheckoutOptions defaults                       checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;                       yourself) ] ]-=JUAMPI=-isMerged  ^mergeTree allSatisfy: [:operation |  operation isConflict not or: [ operation isResolved ] ]-=JUAMPI=-tree  ^self mergeTree-=JUAMPI=-definition  ^definition-=JUAMPI=-remoteBranchNamed: aString  ^self remoteBranchNamed: aString ifPresent: [:branch |  ^branch ] ifAbsent: [ IceBranchNotFound new           branchName: aString;           signal ]-=JUAMPI=-add: item  self selectedItems add: item.  self onSelectionChangedBlock ifNotNil: [:block |  block cull: item cull: true ]-=JUAMPI=-versionFor: anIcePackage  ^self commit versionFor: anIcePackage-=JUAMPI=-authorLabel  ^authorLabel-=JUAMPI=-execute  item ifNil: [ ^self ].  item entity inspect-=JUAMPI=-contextClass  ^IceTipCommitContext-=JUAMPI=-execute  self withErrorHandlingDo: [ self validateRemotesPresent.        (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec ]-=JUAMPI=-remotes  ^entity remotes-=JUAMPI=-fetch  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Fetching incoming commits of {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity fetch ]-=JUAMPI=-actionPanel  ^actionPanel-=JUAMPI=-execute  browser accept-=JUAMPI=-addShortcutsTo: aWidget  self enableCommanderShortcutsIn: aWidget-=JUAMPI=-commitModels  ^(self entity branch incomingCommitsFrom: self remote) collect: [:each |  (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ]-=JUAMPI=-isRootDefinition  ^true-=JUAMPI=-mouseEnter: evt  self flag: #bad.  ^self eventHandler ifNotNil: [ self eventHandler mouseEnter: evt fromMorph: self ]-=JUAMPI=-definition  ^definition-=JUAMPI=-badge: aNumber  badge := aNumber = 0 ifTrue: [ nil ] ifFalse: [ aNumber ]-=JUAMPI=-repositoryWillBeCreated: aRepository  -=JUAMPI=-onClick: aBlock  onClickBlock := aBlock-=JUAMPI=-icon  ^item value icon-=JUAMPI=-repoPath  ^self repository subdirectory-=JUAMPI=-initialize  super initialize.  name := ''-=JUAMPI=-subscribeToAnnouncements  self announcer when: IceTipDiffRefreshed send: #refreshWhenRepository: to: self-=JUAMPI=-copyWithOnly: aCollection  | treeCopy selectedOperations |  selectedOperations := aCollection collect: #value.  treeCopy := tree select: [:node |  selectedOperations includes: node ].  ^self class new     sourceVersion: source;     targetVersion: target;     diffTree: treeCopy;     yourself-=JUAMPI=-execute  UIManager default informUser: 'Refreshing pull request list' during: [ tool refreshPullRequests ]-=JUAMPI=-uptadeSelectedCommit: anEvent  self diff selectedModel: (anEvent newSelectedRowIndexes ifNotEmpty: [:indexes |  self commits widget dataSource elementAt: indexes first ] ifEmpty: [ nil ])-=JUAMPI=-announcer  ^announcer ifNotNil: #contents-=JUAMPI=-validateMessageNotEmpty  self message ifEmpty: [ IceNoCommitMessage signal ]-=JUAMPI=-execute  UIManager default informUser: 'Reverting change...' during: [ self repositoryModel entity workingCopy discardChanges: item ].  self announcer announce: (IceTipDiffEntryRemoved entry: item).  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)-=JUAMPI=-removeFrom: aPatcher  aPatcher removeClass: self-=JUAMPI=-parent  ^parent-=JUAMPI=-accept  ^self doCommit-=JUAMPI=-snapshotFor: anIceSavedPackage  ^MCSnapshot empty-=JUAMPI=-tagNameLabel  ^tagNameLabel-=JUAMPI=-accept: aVisitor  ^aVisitor visitMethodNode: self-=JUAMPI=-isWorkingCopy  ^false-=JUAMPI=-remoteName: aString  remoteName := aString-=JUAMPI=-iconNamed: aSymbol  ^self class iconNamed: aSymbol-=JUAMPI=-mergeWith: anotherNode onLeft: leftBlock onRight: rightBlock onMerge: mergeBlock  ^anotherNode collect: rightBlock-=JUAMPI=-visitTreeNode: anIceNode  self withNode: anIceNode do: [ anIceNode value accept: self ]-=JUAMPI=-commit  ^self entity-=JUAMPI=-rootItem: anItem  super rootItem: anItem.  self addSourceToRootItem-=JUAMPI=-nameInput  ^nameInput-=JUAMPI=-createBranch: aString inCommit: anIceGitCommit  self handleLibgitError: [ (self repositoryHandle isUnborn and: [ anIceGitCommit isNoCommit ]) ifTrue: [ ^self createBranch: aString ].        self repositoryHandle createBranch: aString targetId: (LGitId fromHexString: anIceGitCommit gitRef) force: false.        ^(self branchNamed: aString)           switch;           yourself ]-=JUAMPI=-incomingCommits  ^#()-=JUAMPI=-mergeWithMasterCheckbox: anObject  mergeWithMasterCheckbox := anObject-=JUAMPI=-iconNamed: aSymbol  ^Smalltalk ui icons iconNamed: aSymbol-=JUAMPI=-execute  ^IceGitHubRemoveBranchesAction new     repository: self repository;     remote: self remote;     execute-=JUAMPI=-removeFromPatcher: aMCPatcher  self subclassResponsibility-=JUAMPI=-version: anObject  version := anObject-=JUAMPI=-backend: anObject  backend := anObject-=JUAMPI=-title: anObject  title := anObject-=JUAMPI=-iconForMergeable: mergeable  mergeable = true ifTrue: [ ^self iconNamed: #smallOk ].  ^self iconNamed: #smallCancel-=JUAMPI=-checkForRegistryConflicts  self subclassResponsibility-=JUAMPI=-newRootCellFor: item  | cell |  cell := IceTipOutlineHeaderCellMorph dataSource: self item: item.  (self iconFor: item data) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ].  cell addMorphBack: (self toString: item data) asMorph asReadOnlyMorph.  cell addMorphBack: (AlignmentMorph newSpacer: Color transparent).  cell addMorphBack: item children size asMorph asReadOnlyMorph.  cell addMorphBack: (Morph newBounds: (0 @ 0 corner: 20 @ 0) color: Color transparent) asReadOnlyMorph.  ^cell-=JUAMPI=-doAccept  self validate.  commitishToTag createTag: self tagName thenDo: [:newBranch |  callback ifNotNil: [ callback value: newBranch ] ]-=JUAMPI=-initializeCommitsTable  | textStylingBlock |  textStylingBlock := [:string :commit |  commit isMerged ifTrue: [ string asText ] ifFalse: [ string asText allBold ] ].  commits widget     beResizable;     addColumn: (IceTipTableColumn id: 'Date & time' action: [:commit |  textStylingBlock value: commit datetime asLocalStringYMDHM value: commit ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Id' action: [:commit |  textStylingBlock value: commit shortId value: commit ] width: 50 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Author' action: [:commit |  textStylingBlock value: commit author value: commit ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Comment' action: [:commit |  textStylingBlock value: commit comment value: commit ] width: 300 * World displayScaleFactor);     dataSource: self newCommitsDataSource;     selectRowIndex: 1-=JUAMPI=-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing branch {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity delete ]-=JUAMPI=-visitRemoval: anIceRemoval  anIceRemoval definition removeFrom: self.  self visitChildrenOf: currentNode-=JUAMPI=-nextChildNodeStartingFrom: anIceNode suchThat: conditionBlock ifNone: noneBlock  | aCollection |  aCollection := self children.  (aCollection indexOf: anIceNode) + 1 to: aCollection size do: [:index |  | item |        item := aCollection at: index.        (conditionBlock value: item) ifTrue: [ ^item ].        item nextNodeSuchThat: conditionBlock ifFound: [:found |  ^found ] ].  self parent ifNil: [ ^noneBlock value ].  ^self parent nextChildNodeStartingFrom: self suchThat: conditionBlock ifNone: noneBlock-=JUAMPI=-checkout: aCheckoutStrategy  aCheckoutStrategy committish: self.  ^repository checkout: aCheckoutStrategy-=JUAMPI=-actionPanel: anObject  actionPanel := anObject-=JUAMPI=-contents  ^''-=JUAMPI=-addRemoteNamed: aName url: anUrl  IceTipStandardAction new     repository: self entity;     message: 'Adding remote';     onSuccessRepositoryModified;     execute: [ | remote |        remote := IceGitRemote name: aName url: anUrl.        self entity addRemote: remote.        remote fetch ]-=JUAMPI=-publicKey  ^publicKey ifNil: [ publicKey := self class defaultPublicKey ]-=JUAMPI=-referencesSameRemoteLocationAs: aRemote  ^(super referencesSameRemoteLocationAs: aRemote) or: [ self httpsUrl = aRemote httpsUrl ]-=JUAMPI=-properties  ^properties ifNil: [ properties := Dictionary new ]-=JUAMPI=-cellColumn: column row: rowIndex  ^FTCellMorph new     addMorphBack: ((self elementAt: rowIndex) at: column id) asStringMorph;     yourself-=JUAMPI=-hasUnknownCommit  ^self workingCopyState isUnknownCommitState-=JUAMPI=-mergeWithLeftModification: anIceModification  ^IceConflictingOperation left: anIceModification right: self-=JUAMPI=-readContextParametersFromModel: aModel  self repositoryModel: aModel repositoryModel-=JUAMPI=-codeDirectory  self repositoryDirectory exists ifTrue: [ ^self basicCodeDirectory ] ifFalse: [ IceLocalRepositoryMissing signalFor: self ]-=JUAMPI=-addLabel: aString value: anObject  items at: aString put: anObject.  self refresh-=JUAMPI=-initializeWithJSON: aDictionary  json := aDictionary.  self initialize-=JUAMPI=-title  ^'Pull {1}/{2} from {3}' format: {self model repositoryName .         self model branchName .         self model remoteName}-=JUAMPI=-hasTagNamed: aString  self subclassResponsibility-=JUAMPI=-okAction  self credentials     username: self username;     password: self password.  credentialStore storeCredential: self credentials.  tool refresh-=JUAMPI=-packageNameFromPackageDirectory  ^iceVersion packageName-=JUAMPI=-pullFrom: aRemote  | remoteBranch |  repository fetch.  remoteBranch := aRemote remoteBranchNamed: self name ifAbsent: [ ^self ].  repository createBranch: self name inCommit: remoteBranch commit-=JUAMPI=-isNoCommit  ^true-=JUAMPI=-createRepository: aRepositorySpec  (self canHandleType: aRepositorySpec type) ifTrue: [ ^Iceberg mcRepositoryFor: aRepositorySpec description ].  ^super createRepository: aRepositorySpec-=JUAMPI=-writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock  | directory |  directory := self directoryForDirectoryNamed: directoryNameOrPath.  self fileUtils writeStreamFor: fileName , ext in: directory do: [:fs |  self setFileStream: fs.        visitBlock value ]-=JUAMPI=-max: anInteger  max := anInteger-=JUAMPI=-isRightChosen  ^chosen = operation inverse-=JUAMPI=-shortDescriptionWithDecoration  ^self addDecorationTo: (self entity isRemote ifTrue: [ self name copyAfter: $/ ] ifFalse: [ self name ])-=JUAMPI=-initializeCommitPanel  commitTabPanel     addTab: (infoTab := self newInfoTab);     addTab: (diffTab := self newDiffTab           label: 'Diff from ancestor';           whenTabSelected: [ self refreshDiff ];           yourself)-=JUAMPI=-iceCommitFrom: aLGitCommit  ^self repository iceCommitFrom: aLGitCommit-=JUAMPI=-printOn: aStream  aStream     print: self class;     nextPut: $(;     nextPutAll: self package name.  aStream nextPut: $)-=JUAMPI=-passphrase  ^passphraseInput text-=JUAMPI=-block  ^[:path :completed :total :payload |  job ensureStarted.  job min: 0.  job max: total.  job current: completed.  job title: ('Checking out... ({1}/{2})' format: {completed .               total}).  job changed ]-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  tool := aToolContext tool-=JUAMPI=-radiansToDegrees  ^self / RadiansPerDegree-=JUAMPI=-withoutPrimitiveTryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments  | theMethod |  arguments size > 8 ifTrue: [ ^self class primitiveFailToken ].  theMethod := self class tryNamedPrimitiveTemplateMethod.  theMethod prepareForSimulationWith: arguments size.  theMethod == nil ifTrue: [ ^self class primitiveFailToken ].  self setNamedPrimitiveInformationFrom: aCompiledMethod toMethod: theMethod.  theMethod flushCache.  ^theMethod valueWithReceiver: aReceiver arguments: arguments-=JUAMPI=-forceNewFrom: anArray  | object max |  object := self new.  max := self instSize.  anArray doWithIndex: [:each :index |  index > max ifFalse: [ object instVarAt: index put: each ] ].  ^object-=JUAMPI=-ir  ^self ast ir-=JUAMPI=-defaultAction  Log ifNotNil: [:log |  log add: self ].  self logTranscript.  self raiseWarning ifTrue: [ super defaultAction ]-=JUAMPI=-adaptToInteger: rcvr andCompare: selector  self isFinite ifFalse: [ selector == #= ifTrue: [ ^false ].        selector == #~= ifTrue: [ ^true ].        self isNaN ifTrue: [ ^false ].        (selector = #< or: [ selector = #<= ]) ifTrue: [ ^self positive ].        (selector = #> or: [ selector = #>= ]) ifTrue: [ ^self positive not ].        ^self error: 'unknow comparison selector' ].  selector == #= ifTrue: [ self fractionPart = 0.0 ifFalse: [ ^false ] ].  selector == #~= ifTrue: [ self fractionPart = 0.0 ifFalse: [ ^true ] ].  ^rcvr perform: selector with: self asTrueFraction-=JUAMPI=-nthRoot: aPositiveInteger  | guess p |  guess := self nthRootRounded: aPositiveInteger.  (guess raisedTo: aPositiveInteger) = self ifTrue: [ ^guess ].  p := Float precision - guess highBitOfMagnitude.  p < 0 ifTrue: [ ^guess asFloat ].  guess := self << (p * aPositiveInteger) nthRootRounded: aPositiveInteger.  ^(guess / (1 << p)) asFloat-=JUAMPI=-numArgs  ^1-=JUAMPI=-storeIntoLiteralVariable: value  value value: self top-=JUAMPI=-suiteLog  suiteLog == nil ifTrue: [ suiteLog := OrderedCollection new ].  ^suiteLog-=JUAMPI=-startUp: resuming  ^self startUp-=JUAMPI=-testBasicCheck1  | testMethod |  testMethod := testClass >> (testClass compile: 'testMethod ' , self globalName , ' ' , self nonDeprecatedMethodName).  self assert: (testMethod externalProperties noneSatisfy: [:eprop |  eprop rule class = SendsDeprecatedMethodToGlobalRule ])-=JUAMPI=-testIntegerReadsNotOkFromString  self should: [ Integer readFrom: 'aaa' ] raise: Error.  self should: [ Integer readFrom: '-aaa' ] raise: Error.  self should: [ Integer readFrom: 'a3' base: 8 ] raise: Error-=JUAMPI=-doDup  self push: self top-=JUAMPI=-recursion  LocalRecursionStopper during: [ self recursion ]-=JUAMPI=-removeDependent: anObject  | dependents |  dependents := self dependents reject: [:each |  each == anObject ].  self myDependents: (dependents isEmpty ifFalse: [ dependents ]).  ^anObject-=JUAMPI=-readDataFrom: aDataStream size: varsOnDisk  | cntInstVars cntIndexedVars |  cntInstVars := self class instSize.  self class isVariable ifTrue: [ cntIndexedVars := varsOnDisk - cntInstVars.        cntIndexedVars < 0 ifTrue: [ self error: 'Class has changed too much.  Define a convertxxx method' ] ] ifFalse: [ cntIndexedVars := 0.        cntInstVars := varsOnDisk ].  aDataStream beginReference: self.  1 to: cntInstVars do: [:i |  self instVarAt: i put: aDataStream next ].  1 to: cntIndexedVars do: [:i |  self basicAt: i put: aDataStream next ].  ^self-=JUAMPI=-testNow  self deny: aDateAndTime equals: DateAndTime now-=JUAMPI=-testReadFrom  | s1 s2 s3 s4 s5 |  s1 := '2 June 1973' readStream.  s2 := '2-JUN-73' readStream.  s3 := 'June 2, 1973' readStream.  s4 := '6/2/73' readStream.  s5 := '2JUN73' readStream.  self     assert: (self dateClass readFrom: s1) equals: june2nd1973;     assert: (self dateClass readFrom: s2) equals: june2nd1973;     assert: (self dateClass readFrom: s3) equals: june2nd1973;     assert: (self dateClass readFrom: s4) equals: june2nd1973-=JUAMPI=-testSubtractDate  self assert: (january23rd2004 subtractDate: january23rd2004 previous) equals: 1.  self assert: (january23rd2004 subtractDate: january23rd2004) equals: 0.  self assert: (january23rd2004 subtractDate: january23rd2004 next) equals: -1-=JUAMPI=-weakSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategory  ^self weakSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory-=JUAMPI=-testMiddleOf  self assert: (aDateAndTime middleOf: '2:00:00:00' asDuration) equals: (Timespan starting: '12-31-1979' asDate duration: 2 days)-=JUAMPI=-halt  < debuggerCompleteToSender>  Halt now-=JUAMPI=-testSqrtErrorConditions  self should: [ (-1 / 4) sqrt ] raise: DomainError.  self should: [ (((1 << 1024) + 1) / ((1 << 1024) + 3)) negated sqrt ] raise: DomainError-=JUAMPI=-whichClassIncludesSelector: aSymbol  (self includesSelector: aSymbol) ifTrue: [ ^self ].  self superclass == nil ifTrue: [ ^nil ].  ^self superclass whichClassIncludesSelector: aSymbol-=JUAMPI=-pushLiteralVariable: value  self push: value value-=JUAMPI=-testBetweenAnd  self assert: (3 between: 0 and: 5).  self assert: (5.0 between: 5.0 and: 5.0).  self assert: (Date today between: Date today + 1 and: Date today + 3) not-=JUAMPI=-classVarNames  ^self instanceSide ifNil: [ #() ] ifNotNil: [:class |  class classVarNames ]-=JUAMPI=-nowTick  ^vmSimNow-=JUAMPI=-isPinnedInMemory  < primitive: 183 error: ec>  ^self primitiveFailed-=JUAMPI=-digitSubtract: arg  < primitive: 'primDigitSubtract' module: 'LargeIntegers'>  | smaller larger z sum sl al ng |  sl := self bytesCount.  al := arg bytesCount.  (sl = al ifTrue: [ [ (self byteAt: sl) = (arg byteAt: sl) and: [ sl > 1 ] ] whileTrue: [ sl := sl - 1 ].        al := sl.        (self byteAt: sl) < (arg byteAt: sl) ] ifFalse: [ sl < al ]) ifTrue: [ larger := arg.        smaller := self.        ng := self negative == false.        sl := al ] ifFalse: [ larger := self.        smaller := arg.        ng := self negative ].  sum := Integer new: sl neg: ng.  z := 0.  1 to: sl do: [:i |  z := z + (larger byteAt: i) - (smaller byteAt: i).        sum byteAt: i put: z - (z // 256 * 256).        z := z // 256 ].  ^sum normalize-=JUAMPI=-logEntry  self traceCr: 'Entered ' , thisContext sender printString-=JUAMPI=-asSpotterProcessorLink  ^GTSpotterProcessorLink value: self-=JUAMPI=-testNew  self assert: aDateAndTime equals: DateAndTime new-=JUAMPI=-testDuration  self assert: aDateAndTime duration equals: 0 asDuration-=JUAMPI=-prepareForNewProcess: aProcess  forkedProcesses add: aProcess-=JUAMPI=-testDayOfWeekWithUTC  | date |  date := DateAndTime julianDayNumber: 2456385 offset: (Duration hours: 2).  self assert: date dayOfWeek equals: 3-=JUAMPI=-raisedTo: n modulo: m  | a s mInv |  n = 0 ifTrue: [ ^1 ].  (self >= m or: [ self < 0 ]) ifTrue: [ ^self \\ m raisedTo: n modulo: m ].  n < 0 ifTrue: [ ^(self reciprocalModulo: m) raisedTo: n negated modulo: m ].  (n < 4096 or: [ m even ]) ifTrue: [ ^self slidingLeftRightRaisedTo: n modulo: m ].  mInv := self montgomeryDigitBase - ((m bitAnd: self montgomeryDigitMax) reciprocalModulo: self montgomeryDigitBase).  a := (1 bitShift: m montgomeryNumberOfDigits * m montgomeryDigitLength) \\ m.  (s := self montgomeryTimes: a * a \\ m modulo: m mInvModB: mInv) ifNil: [ ^self slidingLeftRightRaisedTo: n modulo: m ].  a := s montgomeryRaisedTo: n times: a modulo: m mInvModB: mInv.  ^a montgomeryTimes: 1 modulo: m mInvModB: mInv-=JUAMPI=-serializeOn: anEncoder  anEncoder     encodeUint32: self julianDayNumberUTC;     encodeUint32: self nanoSecond;     encodeInt24: self secondsSinceMidnightUTC;     encodeInt24: self offset asSeconds;     encodeInt32: self offset nanoSeconds-=JUAMPI=-testDigitAt  | lpi |  lpi := 114605103402541699037609980192546360895434064385.  1 to: 20 do: [:i |  | digit |        digit := lpi byteAt: i.        self assert: i equals: digit ]-=JUAMPI=-classSideCompiler  ^self classSideCompilerClass new     environment: self classSide environment;     class: self classSide-=JUAMPI=-testSqrtErrorConditions  self should: [ -1 sqrt ] raise: ArithmeticError-=JUAMPI=-waitUntil: aBlock for: aSymbolOrNil maxSeconds: aNumber  ^self waitUntil: aBlock for: aSymbolOrNil maxMilliseconds: (aNumber * 1000) asInteger-=JUAMPI=-hasSlotNamed: aString  ^self classLayout hasSlotNamed: aString-=JUAMPI=-deepCopy  -=JUAMPI=-testNoRecursion  RecursionStopper during: [ value := value + 1 ].  self assert: value equals: 1-=JUAMPI=-evaluate: aString  ^self compiler evaluate: aString-=JUAMPI=-testBasicReadOnly  self alwaysReadOnlyObjects do: [:each |  self assert: each isReadOnlyObject equals: true ]-=JUAMPI=-normalizeSecondsAndNanos  (NanosInSecond <= nanos or: [ nanos < 0 ]) ifTrue: [ seconds := seconds + (nanos // NanosInSecond).        nanos := nanos \\ NanosInSecond ].  (SecondsInDay <= seconds or: [ seconds < 0 ]) ifTrue: [ julianDayNumber := julianDayNumber + (seconds // SecondsInDay).        seconds := seconds \\ SecondsInDay ]-=JUAMPI=-valueNoContextSwitch: anArg  < primitive: 209>  numArgs ~= 1 ifTrue: [ self numArgsError: 1 ].  self primitiveFailed-=JUAMPI=-degreeSin  self isFinite ifTrue: [ ^super degreeSin ].  ^self degreesToRadians sin-=JUAMPI=-ban: aCritique  ReSystemAnnouncer uniqueInstance notifyCritique: aCritique of: aCritique sourceAnchor entity bannedOn: self.  (TheManifestBuilder of: self) banRule: aCritique rule for: self-=JUAMPI=-valueSupplyingAnswer: anObject  ^(anObject isCollection and: [ anObject isString not ]) ifTrue: [ self valueSupplyingAnswers: {anObject} ] ifFalse: [ self valueSupplyingAnswers: {{'*' .               anObject}} ]-=JUAMPI=-symbolicBytecodes  ^SymbolicBytecodeBuilder decode: self-=JUAMPI=-testDaysInYear  self assert: aDateAndTime daysInYear equals: 365-=JUAMPI=-testIsAfter  | tzm8 tzp10 |  tzm8 := january23rd2004 translateTo: -8 hours.  tzp10 := january23rd2004 translateTo: 10 hours.  self     assert: (tzp10 isAfter: tzm8) not;     assert: (january23rd2004 isAfter: june2nd1973);     assert: (june2nd1973 isAfter: june2nd1973) not-=JUAMPI=-doPop  self pop-=JUAMPI=-stepIn: aWindow  ^self step-=JUAMPI=-index: anInteger  index := anInteger-=JUAMPI=-directionToLineFrom: p1 to: p2  ^(p2 x - p1 x) * (self y - p1 y) - ((self x - p1 x) * (p2 y - p1 y))-=JUAMPI=-testBlockVars  | continuation |  tmp := 0.  tmp := (self callcc: [:cc |  continuation := cc.        0 ]) + tmp.  tmp2 ifNotNil: [ tmp2 value ] ifNil: [ #(1 2 3) do: [:i |  self callcc: [:cc |  tmp2 := cc.                    continuation value: i ] ] ].  self assert: tmp equals: 6-=JUAMPI=-ticker  ^ticker-=JUAMPI=-testResumablePass  | result |  result := [ Notification signal.  4 ] on: Notification do: [:ex |  ex pass.        ex return: 5 ].  self assert: result equals: 4-=JUAMPI=-leftCenter  ^self left @ self center y-=JUAMPI=-sizePushConsArray: numElements  ^self sizeOpcodeSelector: #genPushConsArray: withArguments: {numElements}-=JUAMPI=-hash  ^self receiver hash bitXor: selector hash-=JUAMPI=-newSubclass  | i className |  i := 1.  [ className := (self name , i printString) asSymbol.  self environment includesKey: className ] whileTrue: [ i := i + 1 ].  ^self subclass: className instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' package: 'Unclassified'-=JUAMPI=-withAll: mutexList  array := mutexList-=JUAMPI=-resume  suspendedContext ifNil: [ ^self primitiveFailed ].  ^self primitiveResume-=JUAMPI=-- aNumber  self subclassResponsibility-=JUAMPI=-spotterPreviewCodeIn: aComposite  < spotterPreview: 10>  aComposite pharoMethod     title: [ self gtDisplayString ];     display: [:compiledMethod |  ' ' , compiledMethod sourceCode ];     smalltalkClass: [ self methodClass ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'-=JUAMPI=-classForTicker  ^DelayMillisecondTickerSimulation-=JUAMPI=-addCategory: aString  | oldCategories |  (self protocolOrganizer hasProtocolNamed: aString) ifTrue: [ ^self ].  oldCategories := self categories copy.  self protocolOrganizer addProtocolNamed: aString.  self notifyOfAddedCategory: aString.  self notifyOfChangedCategoriesFrom: oldCategories to: self categories-=JUAMPI=-propertyAt: propName ifAbsent: aBlock  self properties ifNil: [ ^aBlock value ].  ^self properties at: propName ifAbsent: aBlock-=JUAMPI=-localSendsToSuper  ^self encoderClass sendsToSuperFor: self-=JUAMPI=-instVarNames  ^self slots collect: [:each |  each name ]-=JUAMPI=-testStoreOn  | integer |  integer := SmallInteger maxVal + 1.  self     assert: integer class equals: LargePositiveInteger;     assert: (String streamContents: [:s |  integer storeOn: s ]) equals: integer asString-=JUAMPI=-testShiftMinusOne1LeftThenRight  1 to: 100 do: [:i |  self assert: ((-1 bitShift: i) bitShift: i negated) equals: -1 ]-=JUAMPI=-+ aNumber  < primitive: 1>  ^super + aNumber-=JUAMPI=-variableSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategory  ^self variableSubclass: aName uses: aTraitComposition instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory-=JUAMPI=-subclass: aName uses: aTraitCompositionOrArray instanceVariableNames: someInstanceVariableNames classVariableNames: someClassVariableNames poolDictionaries: someSharedPoolNames package: aCategory  ^self subclass: aName uses: aTraitCompositionOrArray layout: self classLayout class slots: someInstanceVariableNames asSlotCollection classVariablesNames: someClassVariableNames poolDictionaries: someSharedPoolNames category: aCategory-=JUAMPI=-testStartStop  | error |  error := false.  [ scheduler stopTimerEventLoop ] on: Error do: [ error := true ].  self deny: error-=JUAMPI=-withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: limit  side = #top ifTrue: [ ^self withTop: (newPoint y min: corner y - minExtent y max: limit + minExtent y) ].  side = #bottom ifTrue: [ ^self withBottom: (newPoint y min: limit - minExtent y max: origin y + minExtent y) ].  side = #left ifTrue: [ ^self withLeft: (newPoint x min: corner x - minExtent x max: limit + minExtent x) ].  side = #right ifTrue: [ ^self withRight: (newPoint x min: limit - minExtent x max: origin x + minExtent x) ].  side = #topLeft ifTrue: [ ^(newPoint min: corner - minExtent) corner: self bottomRight ].  side = #bottomRight ifTrue: [ ^self topLeft corner: (newPoint max: origin + minExtent) ].  side = #bottomLeft ifTrue: [ ^self topRight rectangle: (newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y) ].  side = #topRight ifTrue: [ ^self bottomLeft rectangle: (newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y) ]-=JUAMPI=-hasInstVarRef: aMethod  | scanner end printer |  scanner := InstructionStream on: aMethod.  printer := InstVarRefLocator new.  end := scanner method endPC.  [ scanner pc <= end ] whileTrue: [ (printer interpretNextInstructionUsing: scanner) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-slotNamed: aName ifFound: foundBlock  ^self slotNamed: aName ifFound: foundBlock ifNone: [  ]-=JUAMPI=-combineFromIdx: myIdx  (collectionOfArrays at: myIdx) do: [:item |  buffer at: myIdx put: item.        myIdx = collectionOfArrays size ifTrue: [ resultProcessingBlock value: buffer shallowCopy ] ifFalse: [ self combineFromIdx: myIdx + 1 ] ]-=JUAMPI=-testIsClosePunctuation  self checkCorrespondanceOf: #isClosePunctuation: and: #Pe-=JUAMPI=-testPrintOn  self assert: (String streamContents: [:str |  aDateAndTime printOn: str ]) equals: '1970-01-01T00:00:00+00:00'.  self assert: (String streamContents: [:str |  aTimeZone printOn: str ]) equals: 'a TimeZone(UTZ)'-=JUAMPI=-handles: exception  ^false-=JUAMPI=-withAllSubclassesDo: aBlock  self withAllSubclasses do: aBlock-=JUAMPI=-propertyAt: aKey  ^self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]-=JUAMPI=-argumentAt: anInteger  ^self arguments at: anInteger-=JUAMPI=-testRetryingInstVarModification  | guineaPig |  guineaPig := MessageSend new.  guineaPig beReadOnlyObject.  [ guineaPig receiver: 1 ] on: ModificationForbidden do: [:err |  guineaPig beWritableObject.        err retryModification ].  self assert: guineaPig receiver equals: 1-=JUAMPI=-alt  ^KMModifier alt + self-=JUAMPI=-genJumpLong: distance  (distance between: -32768 and: 32767) ifFalse: [ ^self outOfRangeError: 'index' index: distance range: -32768 to: 32767 ].  (distance < 0 or: [ distance > 255 ]) ifTrue: [ self genSignedSingleExtendB: (distance bitShift: -8) ].  stream     nextPut: 237;     nextPut: (distance bitAnd: 255)-=JUAMPI=-isCollection  ^false-=JUAMPI=-parseDay  self isTwoDigitDayPattern ifTrue: [ ^self parseTwoDigitDay ].  self parseVariableDigitDay-=JUAMPI=-isExecutingBlock  ^self isBlockContext-=JUAMPI=-stonOn: stonWriter  stonWriter writeObject: self listSingleton: self asString-=JUAMPI=-blockNodes  ^self ast blockNodes-=JUAMPI=-allSelectorsAboveUntil: aRootClass  | coll |  coll := IdentitySet new.  (self allSuperclassesIncluding: aRootClass) do: [:aClass |  aClass selectorsDo: [:sel |  coll add: sel ] ].  ^coll-=JUAMPI=-senders  ^SystemNavigation default allSendersOf: self selector-=JUAMPI=-add: aLinkOrObject  ^self addLast: aLinkOrObject-=JUAMPI=-scaleFrom: rect1 to: rect2  ^rect2 topLeft + (((x - rect1 left) * rect2 width // rect1 width) @ ((y - rect1 top) * rect2 height // rect1 height))-=JUAMPI=-genJumpLong: distance  (distance >= -1024 and: [ distance < 1024 ]) ifTrue: [ stream           nextPut: 160 + (distance + 1024 bitShift: -8);           nextPut: (distance + 1024) \\ 256.        ^self ].  ^self outOfRangeError: 'distance' index: distance range: -1024 to: 1023-=JUAMPI=-testMutateByteArrayUsingDoubleAtPut  < expectedFailure>  | guineaPig |  guineaPig := ByteArray new: 8.  guineaPig beReadOnlyObject.  self should: [ guineaPig doubleAt: 1 put: (2 raisedTo: 65) asFloat ] raise: ModificationForbidden.  [ guineaPig doubleAt: 1 put: (2 raisedTo: 65) asFloat ] on: ModificationForbidden do: [:modification |  self assert: modification fieldIndex equals: 1.        modification object beWritableObject.        modification retryModification ].  self assert: guineaPig first equals: (2 raisedTo: 65) asFloat-=JUAMPI=-subclass: aSubclassSymbol instanceVariableNames: instVarNameList classVariableNames: classVarNames category: aCategorySymbol  ^self subclass: aSubclassSymbol instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: aCategorySymbol-=JUAMPI=-returnField  | prim |  prim := self primitive.  prim < 264 ifTrue: [ self error: 'only meaningful for quick-return' ] ifFalse: [ ^prim - 264 ]-=JUAMPI=-testPrint24OnWithoutSeconds  self assert: (String streamContents: [:str |  aTime print24: true showSeconds: true on: str ]) equals: '12:34:56'-=JUAMPI=-traitComposition  ^TaEmptyComposition new-=JUAMPI=-positive  ^self >= 0-=JUAMPI=-deprecated: anExplanationString  Deprecation new     context: thisContext sender;     explanation: anExplanationString;     signal-=JUAMPI=-valueSelector  self numArgs = 0 ifTrue: [ ^#value ].  ^(String streamContents: [:stream |  stream nextPutAll: 'value:'.        self numArgs - 1 timesRepeat: [ stream nextPutAll: 'value:' ] ]) asSymbol-=JUAMPI=-newExternalDependencyExistFor: aPackage  | dependencies newDependencies |  dependencies := self dependencyChecker dependenciesOf: aPackage packageName.  newDependencies := dependencies difference: self bootstrapPackages.  ^newDependencies notEmpty-=JUAMPI=-sizePushInstVarLong: instVarIndex  ^self sizeOpcodeSelector: #genPushInstVarLong: withArguments: {instVarIndex}-=JUAMPI=-drTestsBrowse  Smalltalk tools browser openOnClass: self-=JUAMPI=-testZeroDuration  | ts |  ts := Timespan starting: Date today duration: Duration zero.  self assert: ts start equals: ts end-=JUAMPI=-= aTime  ^[ self ticks = aTime ticks ] on: MessageNotUnderstood do: [ false ]-=JUAMPI=-isZero  ^origin isZero and: [ corner isZero ]-=JUAMPI=-hash  | tmp |  denominator isPowerOfTwo ifTrue: [ tmp := self asFloat.        tmp isFinite ifTrue: [ ^tmp hash ] ].  ^numerator hash bitXor: denominator hash-=JUAMPI=-bottomRight  ^corner-=JUAMPI=-signalException: anException  | oldList |  self isActiveProcess ifTrue: [ ^anException signal ].  myList ifNotNil: [ oldList := self suspend ].  suspendedContext := Context sender: suspendedContext receiver: self method: (self class lookupSelector: #pvtSignal:list:) arguments: (Array with: anException with: oldList).  oldList ifNotNil: [ self resume ]-=JUAMPI=-translateTo: anOffset  self dayMonthYearDo: [:day :month :year |  ^self class year: year month: month day: day hour: self hour minute: self minute second: self second nanoSecond: self nanoSecond offset: anOffset asDuration ]-=JUAMPI=-genStoreInstVar: instVarIndex  (instVarIndex >= 0 and: [ instVarIndex < 64 ]) ifTrue: [ stream           nextPut: 129;           nextPut: instVarIndex.        ^self ].  self genStoreInstVarLong: instVarIndex-=JUAMPI=-link: aMetaLink toSlotNamed: aSlotName  self link: aMetaLink toSlotNamed: aSlotName option: #all-=JUAMPI=-gtInspectorPragmasIn: composite  < gtInspectorPresentationOrder: 30>  composite tabulator     title: 'Pragmas';     when: [:x |  x pragmas notEmpty ];     with: [:t |  t           row: #pragmas;           row: #methods.        t transmit           to: #pragmas;           andShow: [:a |  a list                 title: 'Pragmas';                 display: [:method |  method pragmas ];                 when: [:x |  x pragmas notEmpty ] ].        t transmit           from: #pragmas;           to: #methods;           andShow: [:a |  a list                 title: 'Methods';                 display: [:pragma |  | methods |                    methods := OrderedCollection new.                    Object withAllSubclassesDo: [:each |  methods addAll: ((Pragma allNamed: pragma selector in: each) collect: #method) ].                    methods ];                 format: #selector ].        t transmit           toOutsidePort: #selection;           from: #methods port: #selection ];     startOn: self-=JUAMPI=-localMethods  ^self methods-=JUAMPI=-contextClass  ^self method methodClass-=JUAMPI=-asEnvironment  ^RBClassEnvironment class: self-=JUAMPI=-joinTo: stream  ^stream nextPut: self-=JUAMPI=-testReadTimeZoneOffsetISO822WithOtherCharactersAfter  self assert: (DateAndTime readTimezoneOffsetFrom: '+05:30 CommiterName' readStream) printString equals: '0:05:30:00'-=JUAMPI=-asFullRingDefinition  ^self instanceSide asFullRingDefinition classSide-=JUAMPI=-genPushConsArray: size  (size < 0 or: [ size > 127 ]) ifTrue: [ ^self outOfRangeError: 'size' index: size range: 0 to: 127 ].  stream     nextPut: 231;     nextPut: size + 128-=JUAMPI=-testIsZero  self assert: Duration zero isZero.  self assert: (Duration seconds: 0) isZero-=JUAMPI=-hasClassVarNamed: aString  ^self classVarNames includes: aString-=JUAMPI=-anyUserOfClassVarNamed: aSymbol  self withAllSubclasses do: [:subclass |  (Array with: subclass with: subclass class) do: [:classOrMeta |  (classOrMeta whichSelectorsReferTo: (self classPool associationAt: aSymbol)) ifNotEmpty: [ ^classOrMeta ] ] ].  ^nil-=JUAMPI=-fileOutPool: aPool onFileStream: aFileStream  | aPoolName |  (aPool isKindOf: SharedPool class) ifTrue: [ ^self notify: 'we do not fileout SharedPool type shared pools for now' ].  aPoolName := self environment keyAtIdentityValue: aPool.  SystemNotification signal: aPoolName.  aFileStream     nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!';     cr.  aFileStream     nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!';     cr.  aPool keys asSortedCollection do: [:aKey |  | aValue |        aValue := aPool at: aKey.        aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''' , ' put:  '.        (aValue isKindOf: Number) ifTrue: [ aValue printOn: aFileStream ] ifFalse: [ aFileStream nextPutAll: '('.              aValue printOn: aFileStream.              aFileStream nextPutAll: ')' ].        aFileStream           nextPutAll: '!';           cr ].  aFileStream cr-=JUAMPI=-testIsLineSeparator  self checkCorrespondanceOf: #isLineSeparator: and: #Zl-=JUAMPI=-gtInspectorRawIn: composite  < gtInspectorPresentationOrder: 10>  < gtInspectorTag: #basic>  ^composite custom: GTProtoObjectVariablesBrowser new-=JUAMPI=-encode  encodedData := nil.  self perform: ('encode' , kind) asSymbol.  [ encodedData notNil and: [ encodedData size > 0 ] ] assert.  size := encodedData size-=JUAMPI=-testCopy  < pragma: #pragma>  | method copy |  method := thisContext method.  self assert: method pragmas notEmpty.  copy := method copy.  self assert: (method equivalentTo: copy).  self assert: method header equals: copy header.  self assert: method equals: copy.  self assert: method ~~ copy.  self assert: copy penultimateLiteral method identicalTo: copy.  self assert: method penultimateLiteral method identicalTo: method.  method pragmas do: [:p |  self assert: p method identicalTo: method ].  copy pragmas do: [:p |  self assert: p method identicalTo: copy ]-=JUAMPI=-fuelAccept: aGeneralMapper  ^self shouldBeSubstitutedByCleanCopy ifTrue: [ aGeneralMapper visitSubstitution: self by: self cleanCopy onRecursionDo: [ aGeneralMapper visitVariableObject: self ] ] ifFalse: [ aGeneralMapper visitVariableObject: self ]-=JUAMPI=-waitWhile: aBlock maxSeconds: aNumber  ^self waitWhile: aBlock maxMilliseconds: (aNumber * 1000) asInteger-=JUAMPI=-simplePassTestResults  ^OrderedCollection new     add: self doSomethingString;     add: self doYetAnotherThingString;     add: 'Unhandled Exception';     yourself-=JUAMPI=-isErrorTest  ^self methodClass isTestCase and: [ self methodClass methodRaisedError: self selector ]-=JUAMPI=-sourceCode  | trailer |  trailer := self trailer.  trailer sourceCode ifNotNil: [:code |  ^code ].  trailer hasSourcePointer ifFalse: [ ^self codeForNoSource ].  ^self getSourceFromFile ifEmpty: [ self codeForNoSource ]-=JUAMPI=-nonAbstractMethod  ^4 + 5-=JUAMPI=-isAbstract  ^false-=JUAMPI=-method: aMethodNodeOrNil  method := aMethodNodeOrNil-=JUAMPI=-objectAt: index  < primitive: 68>  self primitiveFailed-=JUAMPI=-waitWhile: aBlock  ^self waitWhile: aBlock for: nil-=JUAMPI=-traversableInstVarIndexes  ^super traversableInstVarIndexes copyWithout: (self class allInstVarNames indexOf: 'sender')-=JUAMPI=-randomCharacterBetween: lower and: upper  ^Character codePoint: (self randomCodePointBetween: lower and: upper)-=JUAMPI=-printOn: stream  args isEmpty ifTrue: [ ^stream nextPutAll: selector ].  args with: selector keywords do: [:arg :word |  stream nextPutAll: word.        stream space.        arg printOn: stream.        stream space ].  stream skip: -1-=JUAMPI=-testWholeNanoseconds  self assert: 0 seconds wholeNanoseconds equals: 0.  self assert: 1 second wholeNanoseconds equals: 0.  self assert: 1002003004 nanoSeconds wholeNanoseconds equals: 4-=JUAMPI=-testYear  self assert: aTimespan year equals: 2005-=JUAMPI=-testFirstDayOfMonth  self assert: aDateAndTime firstDayOfMonth equals: 1-=JUAMPI=-testReadSlotNamed  self assert: (5 @ 3 readSlotNamed: #x) equals: 5-=JUAMPI=-isControlOther  ^self characterSet isControlOther: self-=JUAMPI=-isMorphicEvent  ^false-=JUAMPI=-deprecated: anExplanationString transformWith: aRule  Deprecation new     context: thisContext sender;     explanation: anExplanationString;     rule: aRule;     transform-=JUAMPI=-isFFIMethod  ^self hasProperty: #isFFIMethod-=JUAMPI=-variableSubclass: aClassName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self variableSubclass: aClassName uses: aTraitCompositionOrArray instanceVariableNames: instVarNameList classVariableNames: classVarNames category: cat-=JUAMPI=-runTest: aSelector  | actualResult expectedResult |  [ self     logTest: aSelector;     clearLog;     perform: aSelector ] on: MyTestError do: [:ex |  self log: 'Unhandled Exception'.        ex return: nil ].  actualResult := self log.  expectedResult := self perform: (aSelector , #Results) asSymbol.  actualResult = expectedResult ifTrue: [ self logTestResult: 'succeeded' ] ifFalse: [ self logTestResult: 'failed' ]-=JUAMPI=-adaptToInteger: rcvr andSend: selector  ^(Fraction numerator: rcvr denominator: 1) perform: selector with: self-=JUAMPI=-previous  ^self class starting: start - duration duration: duration-=JUAMPI=-asMicroseconds  ^(seconds * NanosInSecond + nanos) // (10 raisedToInteger: 3)-=JUAMPI=-object: anObject  object := anObject-=JUAMPI=-printOn: aStream  aStream nextPutAll: 'false'-=JUAMPI=-removeMethodSelector: aSymbol  ^methodSelectors remove: aSymbol-=JUAMPI=-testAsInteger  self assert: 0.5 asInteger equals: 0.  self assert: (1 / 2) asInteger equals: 0-=JUAMPI=-testSlots  self assert: Context slots size equals: 4-=JUAMPI=-pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex  self push: ((self at: tempVectorIndex + 1) at: remoteTempIndex + 1)-=JUAMPI=-group  ^'Bugs'-=JUAMPI=-isCompiledMethod  ^false-=JUAMPI=-do: aBlock  | dep |  1 to: self basicSize do: [:i |  (dep := self basicAt: i) ifNotNil: [ aBlock value: dep ] ]-=JUAMPI=-testAsYear  self assert: aTime asYear equals: (DateAndTime current midnight + aTime) asYear-=JUAMPI=-userBackgroundPriority  ^UserBackgroundPriority-=JUAMPI=-testNanoSecond  self     assert: (Duration nanoSeconds: 5) equals: 5 nanoSecond;     assert: 0.5 nanoSecond equals: (Duration nanoSeconds: 0.5);     assert: (1 / 2) nanoSecond equals: (Duration nanoSeconds: 0.5)-=JUAMPI=-value: anObject  Processor activeProcess psValueAt: index put: anObject-=JUAMPI=-instSpec  ^(self format bitShift: -16) bitAnd: 16r1F-=JUAMPI=-exp  ^self asFloat exp-=JUAMPI=-fixDependents  DependentsFields associationsDo: [:pair |  pair value do: [:dep |  (references at: dep ifAbsent: [ nil ]) ifNotNil: [:newDep |  | newModel |                    newModel := references at: pair key ifAbsent: [ pair key ].                    newModel addDependent: newDep ] ] ]-=JUAMPI=-metacelloSemanticIntegerLessThanSelf: anInteger  ^anInteger < self-=JUAMPI=-testNameOfMonth  self assert: (Date nameOfMonth: 1) equals: #January.  self assert: (Date nameOfMonth: 12) equals: #December.  self should: [ Date nameOfMonth: 0 ] raise: SubscriptOutOfBounds.  self should: [ Date nameOfMonth: 13 ] raise: SubscriptOutOfBounds-=JUAMPI=-testSimpleOneDelay  | delay |  delay := Delay new setDelay: 2 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: delay beingWaitedOn.  scheduler schedule: delay.  self assert: delay beingWaitedOn.  scheduler simulate_vmMilliseconds: 11.  self deny: delay isExpired.  scheduler simulate_vmMilliseconds: 12.  self assert: delay isExpired-=JUAMPI=-simpleResignalAsTestResults  ^OrderedCollection new     add: self doSomethingString;     add: 'Unhandled Exception';     yourself-=JUAMPI=-mustBeBooleanIn: context  | proceedValue |  context skipBackBeforeJump.  proceedValue := NonBooleanReceiver new     object: self;     signal: 'proceed for truth.'.  ^proceedValue ~~ false-=JUAMPI=-testSharedClosureEnvironment  | blockArray |  blockArray := self constructSharedClosureEnvironmentInDeadFrame.  self assert: (blockArray at: 2) value equals: 10.  self assert: ((blockArray at: 1) value: 5) equals: 5.  self assert: (blockArray at: 2) value equals: 5-=JUAMPI=-classComment: aString  self comment: aString-=JUAMPI=-references  ^references-=JUAMPI=-inheritsFrom: aClass  | aSuperclass |  aSuperclass := self superclass.  [ aSuperclass == nil ] whileFalse: [ aSuperclass == aClass ifTrue: [ ^true ].        aSuperclass := aSuperclass superclass ].  ^false-=JUAMPI=-stonContainSubObjects  ^false-=JUAMPI=-hasAbstractMethods  self methodsDo: [:each |  each isAbstract ifTrue: [ ^true ] ].  ^false-=JUAMPI=-classToBeTested  ^Float-=JUAMPI=-testBecomeForwardHash  | a b c hb |  a := 'ab' copy.  b := 'cd' copy.  c := a.  hb := b hash.  a becomeForward: b.  self     assert: a hash equals: hb;     assert: b hash equals: hb;     assert: c hash equals: hb-=JUAMPI=-veryDeepCopyWith: deepCopier  | class selfNumberOfInstanceVariables fieldOfSelf copyOfSelf currentClass hasVeryDeepInnerMethod currentNumberOfInstanceVariables |  deepCopier references at: self ifPresent: [:newer |  ^newer ].  class := self class.  class isMeta ifTrue: [ ^self ].  copyOfSelf := self shallowCopy.  deepCopier references at: self put: copyOfSelf.  (class isVariable and: [ class isPointers ]) ifTrue: [ self basicSize to: 1 by: -1 do: [:i |  fieldOfSelf := self basicAt: i.              copyOfSelf basicAt: i put: (deepCopier references at: fieldOfSelf ifAbsent: [ fieldOfSelf veryDeepCopyWith: deepCopier ]) ] ].  copyOfSelf veryDeepInner: deepCopier.  currentClass := class.  selfNumberOfInstanceVariables := class instSize.  [ selfNumberOfInstanceVariables == 0 ] whileFalse: [ hasVeryDeepInnerMethod := currentClass includesSelector: #veryDeepInner:.        currentNumberOfInstanceVariables := currentClass instSize - currentClass superclass instSize.        hasVeryDeepInnerMethod ifTrue: [ selfNumberOfInstanceVariables := selfNumberOfInstanceVariables - currentNumberOfInstanceVariables ] ifFalse: [ currentNumberOfInstanceVariables timesRepeat: [ fieldOfSelf := self instVarAt: selfNumberOfInstanceVariables.                    copyOfSelf instVarAt: selfNumberOfInstanceVariables put: (deepCopier references at: fieldOfSelf ifAbsent: [ fieldOfSelf veryDeepCopyWith: deepCopier ]).                    selfNumberOfInstanceVariables := selfNumberOfInstanceVariables - 1 ] ].        currentClass := currentClass superclass ].  ^copyOfSelf-=JUAMPI=-ensureRingDefinitionIn: anRGEnvironment  ^anRGEnvironment ask behaviors detect: [:each |  each name = self name ] ifNone: [ | behaviorModel |        behaviorModel := self asRingMinimalDefinitionIn: anRGEnvironment.        anRGEnvironment addBehavior: behaviorModel.        behaviorModel ]-=JUAMPI=-removeActionsWithReceiver: anObject  self actionMap copy keysDo: [:eachEventSelector |  self removeActionsSatisfying: [:anAction |  anAction receiver == anObject ] forEvent: eachEventSelector ]-=JUAMPI=-implementors  ^SystemNavigation default allImplementorsOf: self selector-=JUAMPI=-testIsConnectorPunctuation  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isConnectorPunctuation: ch) equals: (charset isConnectorPunctuation: ch) ]-=JUAMPI=-parseEscapePattern  inputStream next = patternStream next ifFalse: [ invalidPattern := true ]-=JUAMPI=-fileOutOrganizationOn: aFileStream  aFileStream     cr;     nextPut: $!.  aFileStream     nextChunkPut: self name , ' reorganize';     cr.  aFileStream     nextChunkPut: self organization stringForFileOut;     cr-=JUAMPI=-testYearMonthDay  self assert: aDateAndTime equals: (DateAndTime year: 1980 month: 1 day: 1)-=JUAMPI=-genDup  stream nextPut: 83-=JUAMPI=-addMethodTag: aSymbol  self organization addCategory: aSymbol-=JUAMPI=-simpleEnsureTestWithNotification  [ self doSomething.  self methodWithNotification.  self doSomethingElse ] ensure: [ self doYetAnotherThing ]-=JUAMPI=-link: aMetaLink toTemporaryNamed: aTempVarName inMethod: aMethodName  self link: aMetaLink toTemporaryNamed: aTempVarName inMethod: aMethodName option: #all-=JUAMPI=-isFourDigitYearPattern  ^patternStream nextMatchAll: 'yyy'-=JUAMPI=-= anObject  ^self == anObject-=JUAMPI=-metacelloSemanticStringLessThanSelf: aString  ^true-=JUAMPI=-weeks  | weeks |  weeks := OrderedCollection new.  self weeksDo: [:m |  weeks add: m ].  ^weeks asArray-=JUAMPI=-isZero  ^self = 0-=JUAMPI=-testRaisedToErrorConditions  self should: [ -2 raisedTo: 1 / 4 ] raise: ArithmeticError.  self should: [ -2 raisedTo: 1.24 ] raise: ArithmeticError-=JUAMPI=-day  ^self dayOfYear-=JUAMPI=-execute: projectSpecBlock against: aScriptExecutor  aScriptExecutor executeBlock: self do: projectSpecBlock-=JUAMPI=-testDayOfYear  self assert: aDateAndTime dayOfYear equals: 60-=JUAMPI=-genPushThisContext  stream nextPut: 82-=JUAMPI=-testStoreOn  | integer |  integer := SmallInteger minVal - 1.  self     assert: integer class equals: LargeNegativeInteger;     assert: (String streamContents: [:s |  integer storeOn: s ]) equals: ' ' , integer asString-=JUAMPI=-< comparand  ^self asNanoSeconds < comparand asNanoSeconds-=JUAMPI=-& aBoolean  self subclassResponsibility-=JUAMPI=-selector: aSymbol  selector := aSymbol-=JUAMPI=-storeOn: aStream  aStream     nextPut: $(;     nextPutAll: self className;     nextPutAll: ' seconds: ';     print: seconds;     nextPutAll: ' nanoSeconds: ';     print: nanos;     nextPut: $)-=JUAMPI=-isDisabled  ^self isDisabled: self markerOrNil-=JUAMPI=-testCurrent  self deny: aDateAndTime equals: DateAndTime current-=JUAMPI=-isConflict  ^self markerOrNil == self class conflictMarker-=JUAMPI=-asFloat  self subclassResponsibility-=JUAMPI=-isOverridden  | selector |  selector := self selector.  self methodClass allSubclassesDo: [:each |  (each includesSelector: selector) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-forkedProcesses  ^forkedProcesses-=JUAMPI=-environment  ^thisClass environment-=JUAMPI=-methodReturnTop  ^self return: self pop from: self methodReturnContext-=JUAMPI=-pc: anInteger  pc := anInteger-=JUAMPI=-tickAfterMilliseconds: milliseconds  ^self nowTick + (1000 * milliseconds)-=JUAMPI=-valueUninterruptably  ^self ifCurtailed: [ ^self ]-=JUAMPI=-testCanEscapeSpecialCharacters  self assertReading: '4d\2m\2345y' as: 'd\d\\m\m\\y\y' equals: (Date year: 2345 month: 2 day: 4)-=JUAMPI=-isQuick  ^self primitive between: 256 and: 519-=JUAMPI=-initializeValue: anInteger  value := anInteger.  ^self-=JUAMPI=-randomCodePointBetween: lower and: upper  | max span codePoint |  max := upper min: 16rE01EF.  span := max - lower + 1.  [ codePoint := (self generator next * span) floor + lower.  Unicode isNonCharacter: (Character codePoint: codePoint) ] whileTrue.  ^codePoint-=JUAMPI=-isDivisibleBy: aNumber  aNumber = 0 ifTrue: [ ^false ].  aNumber isInteger ifFalse: [ ^false ].  ^self \\ aNumber = 0-=JUAMPI=-testBitOr  self assert: 2r0101 | 2r1010 equals: 2r1111.  self assert: (2r0101 bitOr: 2r1010) equals: 2r1111-=JUAMPI=-javascriptOn: aStream  self printOn: aStream-=JUAMPI=-a1: a1 a2: a2 a3: a3 a4: a4 a5: a5 a6: a6 a7: a7 a8: a8 a9: a9 a10: a10 a11: a11 a12: a12 a13: a13 a14: a14 a15: a15  ^a1 + a2 - a2-=JUAMPI=-retry  handlerContext restart-=JUAMPI=-bench  | benchmarkResult |  benchmarkResult := self benchFor: 5 seconds.  ^benchmarkResult shortPrintString-=JUAMPI=-example1: anInteger  < sampleInstance>  | factorial |  factorial := [:x |  x = 1 ifTrue: [ 1 ] ifFalse: [ (factorial value: x - 1) * x ] ].  ^factorial value: anInteger-=JUAMPI=-receiver: anObject  receiver := anObject-=JUAMPI=-comment: aString  commentRemoteString := aString isRemoteString ifTrue: [ aString ] ifFalse: [ aString isEmptyOrNil ifTrue: [ nil ] ifFalse: [ SourceFiles remoteStringForNewString: aString ] ]-=JUAMPI=-valueWithinNonLocalReturn  [ ^self ] valueWithin: 20 milliSeconds onTimeout: [  ]-=JUAMPI=-+ aNumber  aNumber isInteger ifTrue: [ self negative == aNumber negative ifTrue: [ ^(self digitAdd: aNumber) normalize ] ifFalse: [ ^self digitSubtract: aNumber ] ].  aNumber isFraction ifTrue: [ ^Fraction numerator: self * aNumber denominator + aNumber numerator denominator: aNumber denominator ].  ^aNumber adaptToInteger: self andSend: #+-=JUAMPI=-suspend  | ts |  self isActive ifTrue: [ ts := self timespans last.        ts duration: DateAndTime now - ts start.        self state: #suspended ]-=JUAMPI=-sizeWithoutTrailer  ^self trailer endPC-=JUAMPI=-minute  ^self minutes-=JUAMPI=-isArrow  ^{Character arrowUp .   Character arrowDown .   Character arrowLeft .   Character arrowRight} includes: self-=JUAMPI=-spotterItemsFor: aStep  -=JUAMPI=-step  ^self interpretNextInstructionFor: self-=JUAMPI=-instanceSide  ^self soleInstance-=JUAMPI=-testPrevious  | previousDay |  previousDay := june2nd1973 previous.  self assert: previousDay equals: '1 June, 1973' asDate-=JUAMPI=-indexOf: anElement startingAt: start ifAbsent: exceptionBlock  | currentLink index |  currentLink := self linkAt: start ifAbsent: [ nil ].  index := start.  [ currentLink isNil ] whileFalse: [ currentLink value = anElement value ifTrue: [ ^index ].        currentLink := currentLink nextLink.        index := index + 1 ].  ^exceptionBlock value-=JUAMPI=-testCeiling  self assert: 1.0 ceiling equals: 1.  self assert: 1.1 ceiling equals: 2.  self assert: -2.0 ceiling equals: -2.  self assert: -2.1 ceiling equals: -2-=JUAMPI=-asFraction  ^self asTrueFraction-=JUAMPI=-inspectAllInstances  | all allSize prefix |  all := self allInstances.  (allSize := all size) isZero ifTrue: [ ^self inform: 'There are no instances of ' , self name ].  prefix := allSize = 1 ifTrue: [ 'The lone instance' ] ifFalse: [ 'The ' , allSize printString , ' instances' ].  all asArray inspectWithLabel: prefix , ' of ' , self name-=JUAMPI=-testReadFrom  self assert: '-1199-01-05T20:33:14.321-05:00' asDateAndTime printString equals: '-1199-01-05T20:33:14.321-05:00'.  self assert: '2002-05-16T17:20:45.1+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.1+01:01'.  self assert: ' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.02+01:01'.  self assert: '2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString equals: '2002-05-16T17:20:45.000000009+01:01'.  self assert: ' 2002-05-16T17:20' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:00+00:00'.  self assert: '2002-05-16T17:20:45' asDateAndTime translateToUTC printString equals: '2002-05-16T17:20:45+00:00'.  self assert: ' 2002-05-16T17:20:45+01:57' asDateAndTime printString equals: '2002-05-16T17:20:45+01:57'.  self assert: ' 2002-05-16T17:20:45-02:34' asDateAndTime equals: '2002-05-16T17:20:45-02:34' asDateAndTime.  self assert: '2002-05-16T17:20:45+00:00' asDateAndTime equals: '2002-05-16T17:20:45+00:00' asDateAndTime.  self assert: '1997-04-26T01:02:03+01:02:3' asDateAndTime equals: '1997-04-26T01:02:03+01:02:3' asDateAndTime-=JUAMPI=-rectanglesAt: y height: ht  y + ht > self bottom ifTrue: [ ^Array new ].  ^Array with: (origin x @ y corner: corner x @ (y + ht))-=JUAMPI=-testDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 1-=JUAMPI=-percent  ^self / 100-=JUAMPI=-testSimpleStoreCallCC  | x continuation |  continuation := self callcc: #yourself.  x := false.  continuation = true ifTrue: [ x := true ] ifFalse: [ continuation value: true.        self error: 'This message shouldn''t be sent, ever.' ].  self assert: x-=JUAMPI=-testDaysInMonth  self assert: aDateAndTime daysInMonth equals: 31-=JUAMPI=-testNaNCompare  | compareSelectors theNaN anotherNaN comparand brokenMethods warningMessage |  self skip.  compareSelectors := #(#< #<= #> #>= #=).  theNaN := Float nan.  anotherNaN := Float infinity - Float infinity.  comparand := {1 .   2.3 .   Float infinity .   (2 / 3) .   1.25s2 .   (2 raisedTo: 50)}.  comparand := comparand , (comparand collect: [:e |  e negated ]).  comparand := comparand , {theNaN .         anotherNaN}.  brokenMethods := Set new.  comparand do: [:comp |  compareSelectors do: [:op |  (theNaN perform: op with: comp) ifTrue: [ brokenMethods add: (theNaN class lookupSelector: op) ].              (comp perform: op with: theNaN) ifTrue: [ brokenMethods add: (comp class lookupSelector: op) ] ].        theNaN ~= comp ifFalse: [ brokenMethods add: (theNaN class lookupSelector: #~=) ].        comp ~= theNaN ifFalse: [ brokenMethods add: (comp class lookupSelector: #~=) ] ].  warningMessage := String streamContents: [:s |  s           nextPutAll: 'According to IEEE 754 comparing with a NaN should always return false, except ~= that should return true.';           cr.        s nextPutAll: 'All these methods failed to do so. They are either broken or call a broken one'.        brokenMethods do: [:e |  s                 cr;                 print: e methodClass;                 nextPutAll: '>>';                 print: e selector ] ].  brokenMethods := Set new.  comparand do: [:comp2 |  compareSelectors do: [:op2 |  self deny: (theNaN perform: op2 with: comp2) description: warningMessage.              self deny: (comp2 perform: op2 with: theNaN) description: warningMessage ].        self assert: theNaN ~= comp2 description: warningMessage.        self assert: comp2 ~= theNaN description: warningMessage ]-=JUAMPI=-deepCopy  | newObject class index |  class := self class.  class == Object ifTrue: [ ^self ].  class isVariable ifTrue: [ index := self basicSize.        newObject := class basicNew: index.        [ index > 0 ] whileTrue: [ newObject basicAt: index put: (self basicAt: index) deepCopy.              index := index - 1 ] ] ifFalse: [ newObject := class basicNew ].  index := class instSize.  [ index > 0 ] whileTrue: [ newObject instVarAt: index put: (self instVarAt: index) deepCopy.        index := index - 1 ].  ^newObject-=JUAMPI=-sqrt  self negative ifTrue: [ ^DomainError signal: 'sqrt undefined for number less than zero.' ].  ^super sqrt-=JUAMPI=-strictlyPositive  ^self > 0-=JUAMPI=-logExecution  self traceCr: 'Executing ' , thisContext sender printString-=JUAMPI=-deprecationDate  ^deprecationDate ifNil: [ 'unknown' ]-=JUAMPI=-compile: text classified: category withStamp: changeStamp notifying: requestor  ^self compile: text classified: category withStamp: changeStamp notifying: requestor logSource: self acceptsLoggingOfCompilation-=JUAMPI=-defaultAction  ^nil-=JUAMPI=-stackPtr  ^stackp-=JUAMPI=-testSecondsSinceMidnightLocalTimeNormalization  | dateAndTime |  dateAndTime := DateAndTime year: 1001 day: 101 hour: 0 minute: 1 second: 56 offset: 0 hours.  dateAndTime := dateAndTime offset: 1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 1 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 23 * 3600 + (1 * 60) + 56.  dateAndTime := DateAndTime year: 1001 day: 101 hour: 23 minute: 1 second: 56 offset: 0 hours.  dateAndTime := dateAndTime offset: 1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 0 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  dateAndTime := DateAndTime year: 1001 day: 101 hour: 0 minute: 1 second: 56 offset: 1 hours.  dateAndTime := dateAndTime offset: 2 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 1 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: 0 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 23 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  dateAndTime := DateAndTime year: 1001 day: 101 hour: 23 minute: 1 second: 56 offset: 1 hours.  dateAndTime := dateAndTime offset: 2 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 0 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: 0 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 22 * 3600 + (1 * 60) + 56.  dateAndTime := dateAndTime offset: -1 hours.  self assert: dateAndTime secondsSinceMidnightLocalTime equals: 21 * 3600 + (1 * 60) + 56-=JUAMPI=-timingPriorityScheduleTicker: aDelayTicker  beingWaitedOn ifTrue: [ ^false ].  beingWaitedOn := true.  ticker := aDelayTicker.  resumptionTick := ticker tickAfterMilliseconds: millisecondDelayDuration.  ^true-=JUAMPI=-testYearPrintOn  | aYear |  aYear := Year starting: DateAndTime new duration: 365 days.  self assert: (String streamContents: [:str |  aYear printOn: str ]) equals: 'a Year (1901)'-=JUAMPI=-allProtocol  ^allProtocol-=JUAMPI=-primeFactorsOn: aStream  self = 1 ifTrue: [ ^self ].  self even ifTrue: [ aStream nextPut: 2.        ^self / 2 primeFactorsOn: aStream ].  3 to: self sqrtFloor by: 2 do: [:each |  self \\ each = 0 ifTrue: [ aStream nextPut: each.              ^self / each primeFactorsOn: aStream ] ].  aStream nextPut: self-=JUAMPI=-basicOrganization: aClassOrg  organization := aClassOrg-=JUAMPI=-notifyOfChangedSelector: element from: oldCategory to: newCategory  (self hasSubject and: [ oldCategory ~= newCategory ]) ifTrue: [ self subject notifyOfRecategorizedSelector: element from: oldCategory to: newCategory ]-=JUAMPI=-testTranscriptPrintingWithOpenedTranscriptExists  self runSimulated: [ self methodWithTranscript ]-=JUAMPI=-testBinaryLiteralString  self assert: 0.0 binaryLiteralString equals: '0.0'.  self assert: 0.0 negated binaryLiteralString equals: '-0.0'.  self assert: Float infinity binaryLiteralString equals: 'Float infinity'.  self assert: Float infinity negated binaryLiteralString equals: 'Float infinity negated'.  self assert: Float nan binaryLiteralString equals: 'Float nan'.  self assert: Float fminDenormalized binaryLiteralString equals: '2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: Float fminNormalized binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: (Float fminNormalized - Float fminDenormalized) binaryLiteralString equals: '2r0.1111111111111111111111111111111111111111111111111111e-1022'.  self assert: Float epsilon binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-52'.  self assert: Float fmax binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: Float fminDenormalized negated binaryLiteralString equals: '-2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: Float fminNormalized negated binaryLiteralString equals: '-2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: 1.0 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e0'.  self assert: (1.0 + Float epsilon) binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000001e0'.  self assert: (1.0 - (Float epsilon / 2)) binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e-1'.  self assert: 2.0 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e1'.  self assert: 0.1 binaryLiteralString equals: '2r1.1001100110011001100110011001100110011001100110011010e-4'.  self assert: 0.2 binaryLiteralString equals: '2r1.1001100110011001100110011001100110011001100110011010e-3'.  self assert: 0.3 binaryLiteralString equals: '2r1.0011001100110011001100110011001100110011001100110011e-2'.  self assert: (0.1 + 0.2) binaryLiteralString equals: '2r1.0011001100110011001100110011001100110011001100110100e-2'.  self assert: 0.5 binaryLiteralString equals: '2r1.0000000000000000000000000000000000000000000000000000e-1'.  self assert: 2r0.0000000000000000000000000000000000000000000000000001e-1022 binaryLiteralString equals: '2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: 2r0.0101010101010101010101010101010101010101010101010101e-1022 binaryLiteralString equals: '2r0.0101010101010101010101010101010101010101010101010101e-1022'.  self assert: 2r0.1010101010101010101010101010101010101010101010101010e-1022 binaryLiteralString equals: '2r0.1010101010101010101010101010101010101010101010101010e-1022'.  self assert: 2r0.1111111111111111111111111111111111111111111111111111e-1022 binaryLiteralString equals: '2r0.1111111111111111111111111111111111111111111111111111e-1022'.  self assert: 2r1.0101010101010101010101010101010101010101010101010101e-3 binaryLiteralString equals: '2r1.0101010101010101010101010101010101010101010101010101e-3'.  self assert: 2r1.1010101010101010101010101010101010101010101010101010e3 binaryLiteralString equals: '2r1.1010101010101010101010101010101010101010101010101010e3'.  self assert: 2r1.1111111111111111111111111111111111111111111111111111e1023 binaryLiteralString equals: '2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: -2r0.0000000000000000000000000000000000000000000000000001e-1022 binaryLiteralString equals: '-2r0.0000000000000000000000000000000000000000000000000001e-1022'.  self assert: -2r1.0000000000000000000000000000000000000000000000000000e-1022 binaryLiteralString equals: '-2r1.0000000000000000000000000000000000000000000000000000e-1022'.  self assert: -2r1.1111111111111111111111111111111111111111111111111111e1023 binaryLiteralString equals: '-2r1.1111111111111111111111111111111111111111111111111111e1023'.  self assert: (Float fromIEEE64Bit: 2r0111111111110000000000000000000000000000000000000000000000000001) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r0111111111111111111111111111111111111111111111111111111111111111) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r1111111111110000000000000000000000000000000000000000000000000001) binaryLiteralString equals: 'Float nan'.  self assert: (Float fromIEEE64Bit: 2r1111111111111111111111111111111111111111111111111111111111111111) binaryLiteralString equals: 'Float nan'-=JUAMPI=-testNoRecursion  LocalRecursionStopper during: [ value := value + 1 ].  self assert: value equals: 1-=JUAMPI=-signaler: anObject  signaler := anObject-=JUAMPI=-testNumberOfDigits  2 to: 32 do: [:b |  1 to: 1000 // b do: [:n |  | bRaisedToN |              bRaisedToN := b raisedTo: n.              self assert: (bRaisedToN - 1 numberOfDigitsInBase: b) equals: n.              self assert: (bRaisedToN numberOfDigitsInBase: b) equals: n + 1.              self assert: (bRaisedToN + 1 numberOfDigitsInBase: b) equals: n + 1.              self assert: (bRaisedToN negated + 1 numberOfDigitsInBase: b) equals: n.              self assert: (bRaisedToN negated numberOfDigitsInBase: b) equals: n + 1.              self assert: (bRaisedToN negated - 1 numberOfDigitsInBase: b) equals: n + 1 ] ]-=JUAMPI=-methodSelectors: anObject  methodSelectors := anObject-=JUAMPI=-selector  ^selector-=JUAMPI=-isBlock  ^false-=JUAMPI=-genPushSpecialLiteral: aLiteral  | index |  index := #(true false nil -1 0 1 2) indexOf: aLiteral ifAbsent: 0.  index = 0 ifTrue: [ ^self error: 'push special literal: ' , aLiteral printString , ' is not one of true false nil -1 0 1 2' ].  stream nextPut: index + 112-=JUAMPI=-testallSuperclassesIncluding  | cls |  cls := ArrayedCollection allSuperclassesIncluding: Collection.  self deny: (cls includes: ArrayedCollection).  self deny: (cls includes: Object).  self assert: (cls includes: Collection).  self assert: (cls includes: SequenceableCollection)-=JUAMPI=-isUppercase  ^self characterSet isUppercase: self-=JUAMPI=-genPushConsArray: size  (size < 0 or: [ size > 127 ]) ifTrue: [ ^self outOfRangeError: 'numElements' index: size range: 0 to: 127 ].  stream     nextPut: 138;     nextPut: size + 128-=JUAMPI=-runTestCase: aTestCase  self subclassResponsibility-=JUAMPI=-sizePushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize  ^self sizeOpcodeSelector: #genPushClosureCopyNumCopiedValues:numArgs:jumpSize: withArguments: {numCopied .         numArgs .         jumpSize}-=JUAMPI=-asSetElement  self deprecated: 'Use #asCollectionElement instead' transformWith: '`@receiver asSetElement' -> '`@receiver asCollectionElement'.  ^self asCollectionElement-=JUAMPI=-testAsWeek  self assert: aDateAndTime asWeek equals: (Week starting: '12-31-1900' asDate)-=JUAMPI=-bitAt: anInteger  | digitIndex bitIndex |  digitIndex := (anInteger - 1) // 8 + 1.  digitIndex > self bytesCount ifTrue: [ ^0 ].  bitIndex := (anInteger - 1) \\ 8 + 1.  ^(self byteAt: digitIndex) bitAt: bitIndex-=JUAMPI=-getNext: previousObj  ^Continuation currentDo: [:here_again |  leave := here_again.        fill value: previousObj ]-=JUAMPI=-canPerform: selector  ^self classAndMethodFor: selector do: [:c :m |  m isProvided ] ifAbsent: [ false ]-=JUAMPI=-copy: sel from: class  self copy: sel from: class classified: nil-=JUAMPI=-testMmddyyyy  self assert: january23rd2004 mmddyyyy equals: '1/23/2004'-=JUAMPI=-aRandomSelectionOfCodePointsDo: aBlock  0 to: 255 do: [:cp |  aBlock value: cp ].  500 timesRepeat: [ aBlock value: (unicodeGenerator randomCodePointAtOrAbove: 256) ]-=JUAMPI=-testUsesPoolVarNamed  self assert: (Date usesPoolVarNamed: 'DayNames').  self deny: (Date class usesPoolVarNamed: 'DayNames').  self assert: (RootClassPoolUser usesPoolVarNamed: 'Author').  self assert: (SubclassPoolUser usesPoolVarNamed: 'Author')-=JUAMPI=-testDivide  self assert: aDuration / aDuration equals: 1.  self assert: aDuration / 2 equals: (Duration days: 0 hours: 13 minutes: 1 seconds: 32 nanoSeconds: 2).  self assert: aDuration / (1 / 2) equals: (Duration days: 2 hours: 4 minutes: 6 seconds: 8 nanoSeconds: 10)-=JUAMPI=-testYield  | lowerHasRun lowerPriority same1HasRun same2HasRun |  lowerHasRun := same1HasRun := same2HasRun := false.  lowerPriority := Processor activeProcess priority - 10 min: 10.  [ lowerHasRun := true ] forkAt: lowerPriority.  [ same1HasRun := true ] fork.  [ same2HasRun := true ] fork.  Processor yield.  self assert: same1HasRun.  self assert: same2HasRun.  self deny: lowerHasRun-=JUAMPI=-sizeSend: selectorLiteralIndex numArgs: nArgs  ^self sizeOpcodeSelector: #genSend:numArgs: withArguments: {selectorLiteralIndex .         nArgs}-=JUAMPI=-testSuspendForSnapshot  | delay |  delay := Delay new setDelay: 2 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: delay beingWaitedOn.  scheduler schedule: delay.  self assert: delay beingWaitedOn.  self assert: delay millisecondsToGo equals: 2.  scheduler shutDown.  self assert: delay millisecondsToGo equals: 0.  scheduler simulate_vmMilliseconds: 20.  self assert: delay millisecondsToGo equals: 0.  self deny: delay isExpired.  scheduler startUp.  self assert: delay millisecondsToGo equals: 2.  self deny: delay isExpired.  scheduler simulate_vmMilliseconds: 23.  self assert: delay isExpired-=JUAMPI=-asTime  ^Time seconds: self secondsSinceMidnightLocalTime nanoSeconds: nanos-=JUAMPI=-javascriptMonthIndex  ^self monthIndex - 1-=JUAMPI=-allSubclassesDo: aBlock  self subclassesDo: [:cl |  aBlock value: cl.        cl allSubclassesDo: aBlock ]-=JUAMPI=-testRefersToLiteralsReturnsTrueWhenLiteralIsGlobalVariable  self assert: (self compiledMethod1 hasLiteralThorough: (self class environment associationAt: #Array))-=JUAMPI=-ifNil: aBlock  ^aBlock value-=JUAMPI=-testYearMonthDayHourMinuteSecondNanosSecondOffset  self assert: aDateAndTime equals: (DateAndTime year: 1901 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours).  self assert: (DateAndTime year: 1 month: 1 day: 1 hour: 0 minute: 0 second: 0 nanoSecond: 0 offset: 0 hours) + (Duration days: 1 hours: 2 minutes: 3 seconds: 4 nanoSeconds: 5) equals: (DateAndTime year: 1 month: 1 day: 2 hour: 2 minute: 3 second: 4 nanoSecond: 5 offset: 0 hours)-=JUAMPI=-suspendingList  ^myList-=JUAMPI=-obsolete  self superclass removeSubclass: self.  super obsolete-=JUAMPI=-group  ^'Architectural'-=JUAMPI=-printPaddedWith: aCharacter to: anInteger  ^self printPaddedWith: aCharacter to: anInteger base: 10-=JUAMPI=-testInexactRaisedTo  self assert: (((1 << 1024) + 1) / ((1 << 1024) + 3) raisedTo: 1 / 3) equals: 1.0.  self assert: ((((1 << 1024) + 1) / ((1 << 1024) + 3)) negated raisedTo: 1 / 3) equals: -1.0-=JUAMPI=-collect: collectBlock thenSelect: selectBlock  | newCollection newElement |  newCollection := self class new.  self do: [:each |  newElement := collectBlock value: each.        (selectBlock value: newElement) ifTrue: [ newCollection add: newElement ] ].  ^newCollection-=JUAMPI=-primitive  ^self subclassResponsibility-=JUAMPI=-sizeBranchPopFalse: distance  ^self sizeOpcodeSelector: #genBranchPopFalse: withArguments: {distance}-=JUAMPI=-stonOn: stonWriter  stonWriter writeScaledDecimal: self-=JUAMPI=-lowercase  ^self asLowercase-=JUAMPI=-at: index  ^(self linkAt: index) value-=JUAMPI=-testMinute  self assert: aTime minute equals: 34.  self assert: aTime minutes equals: 34-=JUAMPI=-testMonth  self assert: aDateAndTime month equals: 1.  self assert: aDateAndTime monthAbbreviation equals: 'Jan'.  self assert: aDateAndTime monthName equals: 'January'.  self assert: aDateAndTime monthIndex equals: 1-=JUAMPI=-testHour  self assert: aDateAndTime hour equals: aDateAndTime hour24.  self assert: aDateAndTime hour equals: 0.  self assert: aDateAndTime hour equals: aDateAndTime hours-=JUAMPI=-testRounded  self assert: (4 / 5) rounded equals: 1.  self assert: (6 / 5) rounded equals: 1.  self assert: (-4 / 5) rounded equals: -1.  self assert: (-6 / 5) rounded equals: -1.  self assert: (3 / 2) rounded equals: 2.  self assert: (-3 / 2) rounded equals: -2-=JUAMPI=-tearDown  DateAndTime localTimeZone: restoredTimeZone.  super tearDown-=JUAMPI=-testReadTimeZoneOffsetISO  self assert: (DateAndTime readTimezoneOffsetFrom: '+05:30' readStream) printString equals: '0:05:30:00'-=JUAMPI=-uncategorizedSelectors  ^self selectorsInProtocol: Protocol unclassified-=JUAMPI=-asPowerOfTwo  ^self asSmallerPowerOfTwo-=JUAMPI=-testUtcOffset  self assert: (aDateAndTime offset: '0:02:00:00') equals: '2004-02-29T13:33:00+02:00' asDateAndTime-=JUAMPI=-tearDown  month := nil.  super tearDown-=JUAMPI=-removeEmptyCategories  | categoryIndex currentStop keptCategories keptStops |  keptCategories := (Array new: 16) writeStream.  keptStops := (Array new: 16) writeStream.  currentStop := categoryIndex := 0.  [ (categoryIndex := categoryIndex + 1) <= categoryArray size ] whileTrue: [ (categoryStops at: categoryIndex) > currentStop ifTrue: [ keptCategories nextPut: (categoryArray at: categoryIndex).              keptStops nextPut: (currentStop := categoryStops at: categoryIndex) ] ].  categoryArray := keptCategories contents.  categoryStops := keptStops contents.  categoryArray isEmpty ifTrue: [ categoryArray := Array with: Default.        categoryStops := Array with: 0 ]-=JUAMPI=-testComments  self assert: (CompiledMethodTest >> #testComments) comments first equals: 'I am the first comment to be found in this test'.  self assert: (CompiledMethodTest >> #testComments) comments second equals: 'And I am the second comment to be found in this test'.  self assert: (CompiledMethod >> #compiledMethod) comments isEmpty-=JUAMPI=-testGpsExample2  | result array |  array := #(#(1 2 3 4 5) #(6 7 8 9 10) #(11 12 13 14 15) #(16 17 18 19 20) #(21 22 23 24 25)).  result := array inject: 0 into: [:sum :subarray |  sum + (subarray inject: 0 into: [:s :elem |  s + elem ]) ].  self assert: (self gpsExample2: array) equals: result-=JUAMPI=-alwaysWritableObjects  ^{ContextInstance .   Processor .   Processor activeProcess}-=JUAMPI=-monthIndex  ^super month-=JUAMPI=-runCase  SystemAnnouncer uniqueInstance suspendAllWhile: [ super runCase ]-=JUAMPI=-testJulianDayNumber  self assert: aTimespan julianDayNumber equals: jan01 julianDayNumber-=JUAMPI=-asSpLayoutFrame  ^SpLayoutFrame new     leftFraction: self left;     rightFraction: self right;     topFraction: self top;     bottomFraction: self bottom;     yourself-=JUAMPI=-testSuppressInform  self should: [ [ nil inform: 'Should not see this message or this test failed!' ] valueSuppressingAllMessages isNil ]-=JUAMPI=-asMinutes  ^self asNanoSeconds / 60000000000.0-=JUAMPI=-value  | strongReceiver |  strongReceiver := self receiver.  ^arguments ifNil: [ (self ensureReceiver: strongReceiver) ifTrue: [ strongReceiver perform: selector ] ifFalse: [  ] ] ifNotNil: [ (self ensureReceiverAndArguments: strongReceiver) ifTrue: [ strongReceiver perform: selector withArguments: (Array withAll: arguments) ] ifFalse: [  ] ]-=JUAMPI=-scheduleAtTimingPriority  (delayToStart timingPriorityScheduleTicker: ticker) ifFalse: [ ^self ].  activeDelay ifNil: [ activeDelay := delayToStart ] ifNotNil: [ delayToStart resumptionTick < activeDelay resumptionTick ifTrue: [ suspendedDelays add: activeDelay.              activeDelay := delayToStart ] ifFalse: [ suspendedDelays add: delayToStart ] ].  delayToStart := nil-=JUAMPI=-testNext  self assert: aTimespan next equals: aDisjointTimespan-=JUAMPI=-setDelay: anInteger forSemaphore: aSemaphore monitor: aMonitor queue: anOrderedCollection  monitor := aMonitor.  queue := anOrderedCollection.  self setDelay: anInteger forSemaphore: aSemaphore-=JUAMPI=-tag: t  tag := t-=JUAMPI=-normalized  | r |  r := (x * x + (y * y)) sqrt.  ^(x / r) @ (y / r)-=JUAMPI=-testRounding  self assert: (5 round: 2) equals: 5-=JUAMPI=-readsSlot: aSlot  ^aSlot isReadIn: self-=JUAMPI=-\\ arg  arg isPoint ifTrue: [ ^(x \\ arg x) @ (y \\ arg y) ].  ^arg adaptToPoint: self andSend: #\\-=JUAMPI=-testSubstracting  | t |  t := '2004-01-07T11:55:00+00:00' asDateAndTime.  self assert: t - 5 equals: '2004-01-07T11:54:55+00:00' asDateAndTime-=JUAMPI=-privRestartBlockTest  | a firstTimeThrough |  firstTimeThrough := true.  a := 10.  self assert: 30 equals: [ | b |        self assert: 10 equals: a.        self assert: nil identicalTo: b.        b := a + 20.        firstTimeThrough ifTrue: [ firstTimeThrough := false.              thisContext restart ].        b ] value-=JUAMPI=-fileOutCategory: aSymbol on: aFileStream  | selectors |  aFileStream cr.  selectors := self selectorsToFileOutCategory: aSymbol.  selectors do: [:sel |  self printMethodChunk: sel on: aFileStream ].  ^self-=JUAMPI=-testCopySignTo  | negatives negz positives strictNegatives strictPositives zero |  strictPositives := {2 .   2.5 .   Float infinity}.  strictNegatives := {-3 .   -3.25 .   Float infinity negated}.  zero := 0.0.  negz := Float negativeZero.  positives := strictPositives copyWith: zero.  negatives := strictNegatives copyWith: negz.  positives do: [:aPositiveSign |  positives do: [:aPositive |  self assert: (aPositiveSign copySignTo: aPositive) equals: aPositive ].        negatives do: [:aNegative |  self assert: (aPositiveSign copySignTo: aNegative) equals: aNegative negated ].        self assert: (aPositiveSign copySignTo: zero) sign equals: 0.        self assert: (aPositiveSign copySignTo: negz) sign equals: 0 ].  negatives do: [:aNegativeSign |  positives do: [:aPositive |  self assert: (aNegativeSign copySignTo: aPositive) equals: aPositive negated ].        negatives do: [:aNegative |  self assert: (aNegativeSign copySignTo: aNegative) equals: aNegative ].        self assert: (aNegativeSign copySignTo: zero) sign equals: 0.        self assert: (aNegativeSign copySignTo: negz) sign equals: 0 ]-=JUAMPI=-testExactSqrt  | f |  self assert: (4 / 9) sqrt classAndValueEquals: 2 / 3.  #(1 5 29 135 1234 567890 123123123 456456456456 98765432109876543210987654321 987123987123987123987123987123987123987123987123) pairsDo: [:i :j |  f := i / j.        self assert: f squared sqrt classAndValueEquals: f.        f := j / i.        self assert: f squared sqrt classAndValueEquals: f ]-=JUAMPI=-compiledMethodAt: selector ifPresent: aBlock  ^self methodDict at: selector ifPresent: aBlock-=JUAMPI=-testIsPowerOfTwo  self deny: (2 raisedTo: 80) negated isPowerOfTwo.  self deny: -1 isPowerOfTwo.  self deny: 0 isPowerOfTwo.  self assert: 1 isPowerOfTwo.  self assert: 2 isPowerOfTwo.  self deny: 3 isPowerOfTwo.  self assert: 4 isPowerOfTwo.  self deny: 5 isPowerOfTwo.  self deny: ((2 raisedTo: 80) - 1) isPowerOfTwo.  self assert: (2 raisedTo: 80) isPowerOfTwo.  self deny: ((2 raisedTo: 80) + 1) isPowerOfTwo-=JUAMPI=-useTimeZone: abbreviation during: aBlock  | timeZone |  timeZone := TimeZone abbreviated: abbreviation.  self restoreLocalTimeZoneAfter: [ DateAndTime localTimeZone: timeZone.        aBlock cull: timeZone ]-=JUAMPI=-variableNodes  ^self methods flatCollect: [:each |  each variableNodes ]-=JUAMPI=-testFloatTruncated  | x y int r |  int := 10 raisedTo: 16.  x := int asFloat.  y := (5 raisedTo: 16) asFloat timesTwoPower: 16.  self assert: x equals: y.  self assert: x asInteger equals: int.  self assert: x asInteger equals: x asTrueFraction asInteger.  r := Random new.  10000 timesRepeat: [ x := r next * 1.9999e16 + 1.0e12.        self assert: x truncated equals: x asTrueFraction truncated ]-=JUAMPI=-testReceiverWithGC  | m |  m := WeakMessageSend receiver: Object new selector: #isNil.  Smalltalk garbageCollectMost.  self assert: m value isNil-=JUAMPI=-bytecodesHash  ^CRC crc16FromCollection: (ByteArray new: self size streamContents: [:stream |  self from: self initialPC to: self endPC do: [:byte |  stream nextPut: byte ] ])-=JUAMPI=-/ aNumber  aNumber isFraction ifTrue: [ ^self * aNumber reciprocal ].  ^aNumber adaptToFraction: self andSend: #/-=JUAMPI=-isExpired  ^expired-=JUAMPI=-fixCollisionsFrom: start  | key index |  index := start.  [ (key := self basicAt: (index := index \\ array size + 1)) == nil ] whileFalse: [ | newIndex |        (newIndex := self findElementOrNil: key) = index ifFalse: [ self swap: index with: newIndex ] ]-=JUAMPI=-classify: aSymbol inProtocolNamed: aProtocolName  | name protocol |  name := aProtocolName.  name = allProtocol name ifTrue: [ name := Protocol unclassified ].  (self protocolsOfSelector: aSymbol) do: [:p |  p removeMethodSelector: aSymbol ].  protocol := self getProtocolNamed: name ifNone: [ self addProtocolNamed: name ].  protocol addMethodSelector: aSymbol-=JUAMPI=-storeOn: aStream base: base  aStream nextPut: $(.  numerator storeOn: aStream base: base.  aStream nextPut: $/.  denominator storeOn: aStream base: base.  aStream nextPut: $)-=JUAMPI=-linesOfCode  | lines |  lines := 0.  self sourceCode lineIndicesDo: [:start :endWithoutDelimiters :end |  endWithoutDelimiters > start ifTrue: [ lines := lines + 1 ] ].  ^lines-=JUAMPI=-valueWithoutNotifications  ^SystemAnnouncer uniqueInstance suspendAllWhile: self-=JUAMPI=-restoreValues  | valueStream context |  valueStream := values readStream.  [ valueStream atEnd ] whileFalse: [ context := valueStream next.        1 to: context class instSize do: [:i |  context instVarAt: i put: valueStream next ].        1 to: context size do: [:i |  context at: i put: valueStream next ] ]-=JUAMPI=-testprintHierarchy  | expected result |  expected := 'ProtoObject #()	Object #()		ExampleForTest1 #()			ExampleForTest11 #()				ExampleForTest111 #()				ExampleForTest112 #()			ExampleForTest12 #()'.  result := ExampleForTest1 printHierarchy.  self assert: result equals: expected-=JUAMPI=-testInexactSqrt  self assert: (((1 << 1024) + 1) / ((1 << 1024) + 3)) sqrt equals: 1.0-=JUAMPI=-intersectAllWithCC: sets  ^sets ifNotEmpty: [ Continuation currentDo: [:cc |  self intersect: sets first withAll: sets allButFirst continuation: cc ] ]-=JUAMPI=-isFormatOther  ^self characterSet isFormatOther: self-=JUAMPI=-waitTimeoutMSecs: anInteger  | d |  d := DelayWaitTimeout new setDelay: (anInteger max: 0) forSemaphore: self.  ^d wait-=JUAMPI=-assertReading: aString as: aPattern raise: anErrorClass  self should: [ self reading: aPattern pattern: aString ] raise: anErrorClass-=JUAMPI=-tags  | protocol |  protocol := self protocol.  protocol ifNil: [ ^#() ].  protocol = Protocol unclassified ifTrue: [ ^#() ].  ^{protocol}-=JUAMPI=-binding  | binding |  binding := self environment associationAt: self name ifAbsent: [ LiteralVariable key: nil value: self ].  ^binding value == self ifTrue: [ binding ] ifFalse: [ LiteralVariable key: nil value: self ]-=JUAMPI=-arguments  ^arguments ifNil: [ Array new ]-=JUAMPI=-subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s package: cat  ^self classInstaller make: [:builder |  builder           superclass: self;           name: t;           layoutClass: self classLayout class;           slots: f asSlotCollection;           sharedVariablesFromString: d;           sharedPools: s;           category: cat;           environment: self environment ]-=JUAMPI=-definitionWithSlots  | stream poolString |  poolString := self sharedPoolsString.  stream := (String new: 800) writeStream.  superclass ifNotNil: [ stream nextPutAll: superclass name ] ifNil: [ stream nextPutAll: 'ProtoObject' ].  stream     nextPutAll: ' subclass: ';     store: self name.  self hasTraitComposition ifTrue: [ stream           crtab;           nextPutAll: 'uses: ';           nextPutAll: self traitCompositionString ].  (self classLayout isKindOf: FixedLayout) ifFalse: [ stream           crtab;           nextPutAll: 'layout: ';           nextPutAll: self classLayout class name ].  stream     crtab;     nextPutAll: 'slots: ';     nextPutAll: self slotDefinitionString.  stream     crtab;     nextPutAll: 'classVariables: ';     nextPutAll: self classVariableDefinitionString.  poolString = '' ifFalse: [ stream           crtab;           nextPutAll: 'poolDictionaries: ';           store: poolString ].  stream     crtab;     nextPutAll: 'package: ';     store: self category asString.  superclass ifNil: [ stream           nextPutAll: '.';           cr.        stream nextPutAll: self name.        stream           space;           nextPutAll: 'superclass: nil' ].  ^stream contents-=JUAMPI=-var10  ^var10-=JUAMPI=-adaptToCollection: rcvr andSend: selector  ^rcvr collect: [:element |  element perform: selector with: self ]-=JUAMPI=-stonContainSubObjects  ^false-=JUAMPI=-coerce: aNumber  aNumber class = self class ifTrue: [ ^self class newFromNumber: aNumber scale: (scale max: aNumber scale) ].  (aNumber isFraction or: [ aNumber isInteger ]) ifTrue: [ ^self class newFromNumber: aNumber scale: scale ].  ^aNumber-=JUAMPI=-testEven  self deny: 1073741825 even.  self assert: 1073741824 even-=JUAMPI=-testAsMonth  self assert: aDateAndTime asMonth equals: (Month year: 1970 month: 'January')-=JUAMPI=-testInfinity2  | i1 i2 |  i1 := 10000 exp.  i2 := 1000000000 exp.  i2 := 0 - i2.  self assert: i1 isInfinite & i2 isInfinite & i1 positive & i2 negative.  self deny: i1 equals: i2-=JUAMPI=-ensureReceiverAndArguments  self receiver ifNil: [ ^false ].  self receiver class isObsolete ifTrue: [ ^false ].  (self receiver isBehavior and: [ self receiver isObsolete ]) ifTrue: [ ^false ].  arguments ifNotNil: [ arguments with: shouldBeNil do: [:arg :flag |  arg ifNil: [ flag ifFalse: [ ^false ] ] ] ].  ^true-=JUAMPI=-selector: aSymbol  selector := aSymbol-=JUAMPI=-testIsLeapYear  self deny: aTimespan isLeapYear-=JUAMPI=-jsonOn: aRenderer  self numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: aRenderer ]-=JUAMPI=-testCompileAll  ClassTest compileAll-=JUAMPI=-testDurationLessThanMaxTicks  | delay |  delay := Delay new setDelay: 789 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: delay.  self assert: ticker vmSimNextWakeupMilliseconds equals: 100 + 789-=JUAMPI=-savedTemps  ^self propertyAt: #savedTemps ifAbsent: nil-=JUAMPI=-subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition category: aCategorySymbol  self deprecated: 'use ... package: instead'.  ^self subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition package: aCategorySymbol-=JUAMPI=-log  ^log ifNil: [ log := OrderedCollection new ]-=JUAMPI=-withBottom: y  ^origin x @ origin y corner: corner x @ (y max: origin y)-=JUAMPI=-weeksDo: aBlock  self do: aBlock with: self asWeek-=JUAMPI=-testprintSubclassesOnLevelFilterNil  | expected result stream |  expected := '	ExampleForTest1 #()		ExampleForTest11 #()			ExampleForTest111 #()			ExampleForTest112 #()		ExampleForTest12 #()'.  result := String new: expected size.  stream := ReadWriteStream on: result.  ExampleForTest1 printSubclassesOn: stream level: 1 filter: nil.  self assert: result equals: expected-=JUAMPI=-repeat  [ self value.  true ] whileTrue-=JUAMPI=-testAsMilliSeconds  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: (Duration seconds: 1) asMilliSeconds equals: 1000.  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: (Duration nanoSeconds: 1000000) asMilliSeconds equals: 1.  self assert: aDuration asMilliSeconds equals: 93784000.  self assert: (Duration milliSeconds: 3775) asSeconds equals: 3.  self assert: (Duration milliSeconds: 3775) nanoSeconds equals: 775000000.  self assert: (Duration milliSeconds: -3775) asSeconds equals: -3.  self assert: (Duration milliSeconds: -3775) nanoSeconds equals: -775000000-=JUAMPI=-terminateActive  activeProcess effectiveProcess terminate-=JUAMPI=-withLeft: x  ^(x min: corner x) @ origin y corner: corner x @ corner y-=JUAMPI=-simpleIsNestedTest  [ self doSomething.  MyTestError signal.  self doSomethingElse ] on: MyTestError do: [:exception |  exception isNested ifTrue: [ self doYetAnotherThing.              exception resignalAs: MyTestNotification new ] ]-=JUAMPI=-whichCategoryIncludesSelector: aSelector  (self includesSelector: aSelector) ifTrue: [ ^self organization categoryOfElement: aSelector ] ifFalse: [ ^nil ]-=JUAMPI=-testCreationFromBytes1  | maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |  Smalltalk vm wordSize = 4 ifFalse: [ ^self skip ].  maxSmallInt := SmallInteger maxVal.  hexString := maxSmallInt printStringHex.  self assert: hexString size equals: 8.  byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.  byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.  byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.  byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.  builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.  self assert: builtInteger equals: maxSmallInt.  self assert: builtInteger class equals: SmallInteger-=JUAMPI=-leadingChar  ^(self asInteger bitAnd: 1069547520) bitShift: -22-=JUAMPI=-bytecode  | start stop bytecode |  start := self initialPC.  stop := self endPC.  bytecode := ByteArray new: stop - start + 1.  start to: stop do: [:index |  bytecode byteAt: index - start + 1 put: (self byteAt: index) ].  ^bytecode-=JUAMPI=-exception  ^self-=JUAMPI=-applyDeprecation  self deprecationRefactorings do: #execute-=JUAMPI=-asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: packageKeys in: aRGSlice  | rgClass rgMethod rgSuper rgSub subs |  rgClass := self asRingDefinition.  aRGSlice loadClass: rgClass using: packageKeys.  methodsBoolean ifTrue: [ self methodsDo: [:mth |  rgMethod := mth asActiveRingDefinition.              aRGSlice loadMethod: rgMethod inClass: rgClass using: packageKeys ].        self classSide methodsDo: [:mth |  rgMethod := mth asActiveRingDefinition.              aRGSlice loadMethod: rgMethod inClass: rgClass classSide using: packageKeys ] ].  supersBoolean ifTrue: [ self superclass ifNotNil: [ rgSuper := aRGSlice classNamed: self superclass name.              rgSuper ifNil: [ rgSuper := self superclass asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: packageKeys in: aRGSlice ].              rgClass superclass: rgSuper ] ].  subsBoolean ifTrue: [ subs := self subclasses reject: [:sub |  sub isMeta ].        rgClass name = #Trait ifTrue: [ subs := aRGSlice environment allTraits ].        subs do: [:each |  rgSub := aRGSlice classNamed: each name.              rgSub ifNil: [ rgSub := each asRingDefinitionWithMethods: methodsBoolean withSuperclasses: supersBoolean withSubclasses: subsBoolean withPackageKeys: packageKeys in: aRGSlice ].              rgSub superclass: rgClass ] ].  ^rgClass-=JUAMPI=-sizeCallPrimitive: primitiveIndex  ^self sizeOpcodeSelector: #genCallPrimitive: withArguments: {primitiveIndex}-=JUAMPI=-testAsLocal  self assert: aDateAndTime asLocal equals: aDateAndTime.  self assert: aDateAndTime asLocal equals: (aDateAndTime offset: aDateAndTime class localOffset)-=JUAMPI=-testUtcOffset  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1980-01-01T12:00:00+12:00' asDateAndTime-=JUAMPI=-protocolNamed: aName  ^self protocolNamed: aName ifAbsent: [ Protocol empty ]-=JUAMPI=-floor  | truncation |  truncation := self truncated.  self >= 0 ifTrue: [ ^truncation ].  self = truncation ifTrue: [ ^truncation ] ifFalse: [ ^truncation - 1 ]-=JUAMPI=-contents  ^(self log inject: (String new: 80) writeStream into: [:result :item |  result           cr;           nextPutAll: item;           yourself ]) contents-=JUAMPI=-or: alternativeBlock  ^alternativeBlock value-=JUAMPI=-testAsDays  self assert: (Duration days: 2) asDays equals: 2.  self assert: (Duration weeks: 1) asDays equals: 7.  self assert: (aDuration asDays closeTo: 1.08546)-=JUAMPI=-testTicks  self assert: aDateAndTime ticks equals: (DateAndTime julianDayNumber: 2440588) ticks.  self assert: aDateAndTime ticks equals: #(2440588 0 0)-=JUAMPI=-digitLshift: shiftCount  | carry rShift mask len result digit byteShift bitShift highBit |  (highBit := self highBitOfMagnitude) = 0 ifTrue: [ ^0 ].  len := (highBit + shiftCount + 7) // 8.  result := Integer new: len neg: self negative.  byteShift := shiftCount // 8.  bitShift := shiftCount \\ 8.  bitShift = 0 ifTrue: [ ^result replaceFrom: byteShift + 1 to: len with: self startingAt: 1 ].  carry := 0.  rShift := bitShift - 8.  mask := 255 bitShift: 0 - bitShift.  1 to: byteShift do: [:i |  result byteAt: i put: 0 ].  1 to: len - byteShift do: [:i |  digit := self byteAt: i.        result byteAt: i + byteShift put: (((digit bitAnd: mask) bitShift: bitShift) bitOr: carry).        carry := digit bitShift: rShift ].  ^result-=JUAMPI=-selector  ^selector-=JUAMPI=-obsolete  self == Object ifTrue: [ ^self error: 'Object is NOT obsolete' ].  self setName: 'AnObsolete' , self name.  Object class instSize + 1 to: self classSide instSize do: [:i |  self instVarAt: i put: nil ].  self classPool: nil.  self sharedPools: nil.  self hasClassSide ifTrue: [ self classSide obsolete ].  self propertyAt: #obsolete put: true.  super obsolete-=JUAMPI=-degreeSin  ^(90 - self) degreeCos-=JUAMPI=-ffiCallingConvention  ^OSPlatform current ffiCallingConvention-=JUAMPI=-dayOfWeek  ^start dayOfWeek-=JUAMPI=-genBranchPopTrue: distance  distance < 0 ifTrue: [ ^self outOfRangeError: 'distance' index: distance range: 0 to: 1023 ].  distance < 1024 ifTrue: [ stream           nextPut: 168 + (distance bitShift: -8);           nextPut: (distance + 1024) \\ 256.        ^self ].  ^self outOfRangeError: 'distance' index: distance range: 0 to: 1023-=JUAMPI=-storeOn: aStream  self printOn: aStream-=JUAMPI=-testMutateIVObject  | guineaPig |  guineaPig := MessageSend new.  guineaPig beReadOnlyObject.  [ guineaPig receiver: 1 ] on: ModificationForbidden do: [:modification |   ].  guineaPig     beWritableObject;     selector: #+;     beReadOnlyObject.  [ guineaPig arguments: #(2) ] on: ModificationForbidden do: [:modification |   ].  self assert: guineaPig receiver isNil.  self assert: guineaPig arguments isNil.  self assert: guineaPig selector identicalTo: #+-=JUAMPI=-compileSilently: code  ^self compileSilently: code classified: 'not defined category' notifying: nil-=JUAMPI=-confirm: queryString  ^UIManager default confirm: queryString-=JUAMPI=-okToChange  ^true-=JUAMPI=-isSpaceSeparator  ^self characterSet isSpaceSeparator: self-=JUAMPI=-identityHash  ^self basicIdentityHash bitShift: 8-=JUAMPI=-compileSilently: code classified: category  ^self compileSilently: code classified: category notifying: nil-=JUAMPI=-blockWithNonLocalReturn: resultObject  ^[ ^resultObject ]-=JUAMPI=-lookupSelector: selector  | lookupClass |  lookupClass := self.  [ lookupClass == nil ] whileFalse: [ lookupClass methodDict at: selector ifPresent: [:method |  ^method ].        lookupClass := lookupClass superclass ].  ^nil-=JUAMPI=-testInquiries  self     assert: week start asDate equals: '28 June 1998' asDate;     assert: week end asDate equals: '4 July 1998' asDate;     assert: week index equals: 5;     assert: week duration equals: 7 days-=JUAMPI=-reflectiveMethod  ^self propertyAt: #reflectiveMethod ifAbsent: nil-=JUAMPI=-runTestCase: aTestCase  | testEnv |  testEnv := TestExecutionEnvironment new.  testEnv beActiveDuring: [ testEnv runTestCase: aTestCase ]-=JUAMPI=-isVowel  ^'AEIOU' includes: self asUppercase-=JUAMPI=-isResumable  ^false-=JUAMPI=-assert  self value ifFalse: [ AssertionFailure signal: 'Assertion failed' ]-=JUAMPI=-largeIdentityHash  ^self basicIdentityHash-=JUAMPI=-traversableIndexableVarIndexes  ^1 to: self basicSize-=JUAMPI=-slots  ^self classLayout visibleSlots-=JUAMPI=-isModifierSymbol  ^self characterSet isModifierSymbol: self-=JUAMPI=-setUp  super setUp.  aCompiledMethod := Rectangle methodDict at: #rightCenter.  aReceiver := 100 @ 100 corner: 200 @ 200.  aSender := thisContext.  aMethodContext := Context sender: aSender receiver: aReceiver method: aCompiledMethod arguments: #()-=JUAMPI=-isPinned  ^self isPinnedInMemory-=JUAMPI=-literalEqual: other  ^self class == other class and: [ self = other ]-=JUAMPI=-addProtocolNamed: aName  ^protocols add: (Protocol name: aName)-=JUAMPI=-intersectWithCC: aSet withAll: sets continuation: hop  ^aSet ifEmpty: [ hop value: aSet ] ifNotEmpty: [ sets ifEmpty: [ aSet ] ifNotEmpty: [ self intersect: aSet withCollection: (self intersectWithCC: sets first withAll: sets allButFirst continuation: hop) continuation: hop ] ]-=JUAMPI=-removeClassVariable: aGlobal  self removeClassVarNamed: aGlobal name-=JUAMPI=-copiedValueAt: i  < primitive: 60>  ^self basicAt: i-=JUAMPI=-spotterUsedSlotsFor: aStep  < spotterOrder: 70>  aStep listProcessor     title: 'Full Definition Slots';     allCandidates: [ self slots select: [:slot |  slot needsFullDefinition ] ];     itemName: [:item |  item definitionString ];     filter: GTFilterSubstring-=JUAMPI=-testSimpleTwoDelays  | delay1 delay2 |  delay1 := Delay new setDelay: 2 forSemaphore: Semaphore new.  delay2 := Delay new setDelay: 4 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 10.  self deny: delay1 beingWaitedOn.  self deny: delay2 beingWaitedOn.  scheduler schedule: delay1.  scheduler schedule: delay2.  self assert: delay1 beingWaitedOn.  self assert: delay2 beingWaitedOn.  scheduler simulate_vmMilliseconds: 11.  self deny: delay1 isExpired.  self deny: delay2 isExpired.  scheduler simulate_vmMilliseconds: 12.  self assert: delay1 isExpired.  self deny: delay2 isExpired.  scheduler simulate_vmMilliseconds: 13.  self deny: delay2 isExpired.  scheduler simulate_vmMilliseconds: 14.  self assert: delay2 isExpired-=JUAMPI=-testIfNotNil  | object returnValue block reached |  object := ProtoObject new.  returnValue := Object new.  reached := false.  object ifNotNil: [ reached := true ].  self assert: reached equals: true.  reached := false.  object ifNotNil: [:o |  reached := true ].  self assert: reached equals: true.  self assert: (object ifNotNil: [:o |  o == object ]).  self assert: (object ifNotNil: [ returnValue ]) identicalTo: returnValue.  self assert: (object ifNotNil: [:o |  returnValue ]) identicalTo: returnValue.  block := [ reached := true ].  object ifNotNil: block.  self assert: reached equals: true.  reached := false.  block := [:o |  reached := true ].  object ifNotNil: block.  self assert: reached equals: true.  block := [:o |  o == object ].  self assert: (object ifNotNil: block).  block := [ returnValue ].  self assert: (object ifNotNil: block) equals: returnValue.  block := [:o |  returnValue ].  self assert: (object ifNotNil: block) equals: returnValue-=JUAMPI=-isLiteral  ^true-=JUAMPI=-isSeparator  | in |  ^(in := self asInteger) == 32 or: [ in == 13 or: [ in == 9 or: [ in == 10 or: [ in == 12 ] ] ] ]-=JUAMPI=-defaultQueue  defaultQueue ifNil: [ defaultQueue := OrderedCollection new ].  ^defaultQueue-=JUAMPI=-testMidnight  self assert: aDateAndTime midnight equals: aDateAndTime-=JUAMPI=-asContext  ^self asContextWithSender: nil-=JUAMPI=-subclass: aSubclassSymbol layout: layoutClass slots: slotDefinition classVariables: classVarDefinition poolDictionaries: someSharedPoolNames package: aCategorySymbol  ^self classInstaller make: [:builder |  builder           name: aSubclassSymbol;           superclass: self;           layoutClass: layoutClass;           slots: slotDefinition;           sharedVariables: classVarDefinition;           sharedPools: someSharedPoolNames;           category: aCategorySymbol ]-=JUAMPI=-removeProperty: propName ifAbsent: aBlock  | property |  self properties ifNil: [ ^aBlock value ].  property := self properties removeKey: propName ifAbsent: aBlock.  self removePropertiesIfEmpty.  ^property-=JUAMPI=-isInteger  ^false-=JUAMPI=-printStringRoman  | stream integer |  stream := String new writeStream.  integer := self negative ifTrue: [ stream nextPut: $-.        self negated ] ifFalse: [ self ].  integer // 1000 timesRepeat: [ stream nextPut: $M ].  integer     romanDigits: 'MDC' for: 100 on: stream;     romanDigits: 'CLX' for: 10 on: stream;     romanDigits: 'XVI' for: 1 on: stream.  ^stream contents-=JUAMPI=-testAsYear  self assert: aDateAndTime asYear equals: (Year starting: '01-01-1970' asDate)-=JUAMPI=-primitiveFail  ^self primitiveFailed-=JUAMPI=-testMeridianAbbreviation  self assert: aDateAndTime meridianAbbreviation equals: 'AM'-=JUAMPI=-triggerEvent: anEventSelector withArguments: anArgumentList  ^(self actionForEvent: anEventSelector) valueWithArguments: anArgumentList-=JUAMPI=-updateableActionMap  ^EventManager updateableActionMapFor: self-=JUAMPI=-error  ^self error: 'Error!'-=JUAMPI=-bytesCount  | value length |  length := 1.  value := self.  value >= 0 ifTrue: [ [ value > 255 ] whileTrue: [ value := value bitShift: -8.              length := length + 1 ] ] ifFalse: [ [ value < -255 ] whileTrue: [ value := value bitShift: -8.              length := length + 1 ] ].  ^length-=JUAMPI=-asAlien  ^1-=JUAMPI=-innerBindingOf: aSymbol  (self classPool bindingOf: aSymbol) ifNotNil: [:binding |  ^binding ].  self sharedPools do: [:pool |  (pool bindingOf: aSymbol) ifNotNil: [:binding |  ^binding ] ].  self superclass ifNotNil: [:supercl |  ^supercl innerBindingOf: aSymbol ].  ^nil-=JUAMPI=-supermostPrecodeCommentFor: selector  | aSuper superComment |  (self == Behavior or: [ self superclass == nil or: [ (aSuper := self superclass whichClassIncludesSelector: selector) == nil ] ]) ifFalse: [ superComment := aSuper supermostPrecodeCommentFor: selector ].  ^superComment ifNil: [ self firstPrecodeCommentFor: selector ]-=JUAMPI=-expandRectangle: aRectangle  ^Rectangle left: aRectangle left - self left right: aRectangle right + self right top: aRectangle top - self top bottom: aRectangle bottom + self bottom-=JUAMPI=-valueWithArguments: aSequenceOfArguments  ^self-=JUAMPI=-cull: firstArg cull: secondArg cull: thirdArg cull: fourthArg  ^numArgs < 4 ifTrue: [ self cull: firstArg cull: secondArg cull: thirdArg ] ifFalse: [ self value: firstArg value: secondArg value: thirdArg value: fourthArg ]-=JUAMPI=-testAsYear  self     assert: 1 year days equals: 365;     assert: 0.5 year asHours equals: 364 / 2 * 24 + 12-=JUAMPI=-link: aMetaLink toClassVariableNamed: aClassVariableName option: option  aMetaLink installOnClassVarNamed: aClassVariableName for: self option: option instanceSpecific: self intanceSpecificMetaLinksAvailable-=JUAMPI=-basicNew  < primitive: 70 error: ec>  ec == #'insufficient object memory' ifTrue: [ ^self handleFailingBasicNew ].  self isVariable ifTrue: [ ^self basicNew: 0 ].  self primitiveFailed-=JUAMPI=-simpleRetryTest  | theMeaningOfLife |  theMeaningOfLife := nil.  [ self doSomething.  theMeaningOfLife == nil ifTrue: [ MyTestError signal ] ifFalse: [ self doSomethingElse ] ] on: MyTestError do: [:ex |  theMeaningOfLife := 42.        self doYetAnotherThing.        ex retry ]-=JUAMPI=-do: aBlock with: aFirstElement  self do: aBlock with: aFirstElement when: [:t |  true ]-=JUAMPI=-upperBound  ^upperBound-=JUAMPI=-isCompiledMethodClass  ^self instSpec >= 24-=JUAMPI=-superclass  ^superclass-=JUAMPI=-testIsPowerOfTwoM6873  self deny: ((1 to: 80) anySatisfy: [:n |  (2 raisedTo: n) negated isPowerOfTwo ]) description: 'A negative integer cannot be a power of two'-=JUAMPI=-asUppercase  ^self characterSet toUppercase: self-=JUAMPI=-modelWakeUpIn: aWindow  -=JUAMPI=-digitMultiply: arg neg: ng  < primitive: 'primDigitMultiplyNegative' module: 'LargeIntegers'>  | prod prodLen carry digit k ab |  (arg bytesCount = 1 and: [ (arg byteAt: 1) = 0 ]) ifTrue: [ ^0 ].  (self bytesCount = 1 and: [ (self byteAt: 1) = 0 ]) ifTrue: [ ^0 ].  prodLen := self bytesCount + arg bytesCount.  prod := Integer new: prodLen neg: ng.  1 to: self bytesCount do: [:i |  (digit := self byteAt: i) ~= 0 ifTrue: [ k := i.              carry := 0.              1 to: arg bytesCount do: [:j |  ab := (arg byteAt: j) * digit + carry + (prod byteAt: k).                    carry := ab bitShift: -8.                    prod byteAt: k put: (ab bitAnd: 255).                    k := k + 1 ].              prod byteAt: k put: carry ] ].  ^prod normalize-=JUAMPI=-testSimplestCallCC  | x |  x := self callcc: [:cc |  cc value: true ].  self assert: x-=JUAMPI=-printOn: aStream  aStream nextPutAll: self monthName , ' ' , self year printString-=JUAMPI=-collectArguments: anArgArray  | staticArgs |  staticArgs := self arguments.  ^anArgArray size = staticArgs size ifTrue: [ Array withAll: anArgArray ] ifFalse: [ (staticArgs isEmpty ifTrue: [ staticArgs := Array new: selector numArgs ] ifFalse: [ Array withAll: staticArgs ]) replaceFrom: 1 to: (anArgArray size min: staticArgs size) with: anArgArray startingAt: 1 ]-=JUAMPI=-stringForReadout  ^self rounded printString-=JUAMPI=-yyyymmdd  ^String new: 10 streamContents: [:aStream |  self printOn: aStream format: #(3 2 1 $- 1 1 2) ]-=JUAMPI=-< aTime  ^self asDuration < aTime asDuration-=JUAMPI=-protocols  ^self protocolOrganizer protocols-=JUAMPI=-testFromString  self assert: aDateAndTime equals: (DateAndTime fromString: ' 2004-02-29T13:33:00+02:00')-=JUAMPI=-testConvertFromFloat  | aFloat sd f2 diff |  aFloat := 11 / 13 asFloat.  sd := aFloat asScaledDecimal: 2.  self assert: 2 equals: sd scale.  self assert: '0.85s2' equals: sd printString.  self assert: '-0.85s2' equals: sd negated printString.  f2 := sd asFloat.  diff := f2 - aFloat.  self assert: diff abs < 1.0e-9-=JUAMPI=-signal  | pragma |  (context method hasPragmaNamed: #transform:to:) ifFalse: [ ^super signal ].  pragma := context method pragmaAt: #transform:to:.  self rule: pragma arguments first -> pragma arguments second.  self transform-=JUAMPI=-testRemoveOneStar  | tree1 tree2 |  tree1 := #Swedish ~~> (#rye ~~> nil) ~~> (#French ~~> (#mustard ~~> (#salad ~~> (#turkey ~~> nil)) ~~> nil) ~~> (#salad ~~> nil)).  tree2 := #pasta ~~> (#meat ~~> nil) ~~> (#pasta ~~> (#noodles ~~> (#meat ~~> (#sauce ~~> nil)) ~~> (#meat ~~> (#tomatoes ~~> nil)))).  self assert: (self printStringOfTree: tree1) equals: '((#Swedish #rye) (#French (#mustard #salad #turkey)) #salad)'.  self assert: (self printStringOfTree: tree2) equals: '((#pasta #meat) #pasta (#noodles #meat #sauce) #meat #tomatoes)'.  self assert: (self printStringOfTree: (self remove: #salad oneStar: tree1)) equals: '((#Swedish #rye) (#French (#mustard #turkey)) #salad)'.  self assert: (self printStringOfTree: (self remove: #salad oneStarWithTry: tree1)) equals: '((#Swedish #rye) (#French (#mustard #turkey)) #salad)'.  self assert: (self printStringOfTree: (self remove: #meat oneStar: tree2)) equals: '((#pasta) #pasta (#noodles #meat #sauce) #meat #tomatoes)'.  self assert: (self printStringOfTree: (self remove: #meat oneStarWithTry: tree2)) equals: '((#pasta) #pasta (#noodles #meat #sauce) #meat #tomatoes)'-=JUAMPI=-exampleSend  < sampleInstance>  instVar1 := 1.  self yourself.  ^thisContext copy-=JUAMPI=-okToClose  ^true-=JUAMPI=-testCreationWithOffsets  | dt1 dt2 |  dt1 := DateAndTime year: 2222 month: 1 day: 22 hour: 1 minute: 22 second: 33 offset: 0 hours.  dt2 := DateAndTime year: 2222 month: 1 day: 22 hour: 1 minute: 22 second: 33 offset: 2 hours.  self deny: dt1 equals: dt2.  self assert: dt1 year equals: dt2 year.  self assert: dt1 month equals: dt2 month.  self assert: dt1 day equals: dt2 day.  self assert: dt1 hours equals: dt2 hours.  self assert: dt1 minutes equals: dt2 minutes.  self assert: dt1 seconds equals: dt2 seconds-=JUAMPI=-testChangingShapeDoesNotPutNilInMethodsLastLiteralKey  | tutu |  tutu := testEnvironment at: #TUTU.  tutu compile: 'foo'.  self deny: (tutu >> #foo) allLiterals last key isNil.  tutu addInstVarNamed: 'x'.  self deny: (tutu >> #foo) allLiterals last key isNil-=JUAMPI=-adoptForNewCalypsoQuery  ^self-=JUAMPI=-propertyValueAt: propName ifAbsent: aBlock  ^self propertyAt: propName ifAbsent: aBlock-=JUAMPI=-exception: anError  exception := anError-=JUAMPI=-shallowCopy  -=JUAMPI=-testBenchFib  self assert: 0 benchFib equals: 1.  self assert: 1 benchFib equals: 1.  self assert: 2 benchFib equals: 3-=JUAMPI=-javascriptOn: aStream  aStream javascript: self asMilliseconds-=JUAMPI=-serializeOn: anEncoder  -=JUAMPI=-thoroughWhichMethodsReferTo: literal  | specialIndex |  specialIndex := Smalltalk specialSelectorIndexOrNil: literal.  ^self methods select: [:method |  method hasSelector: literal specialSelectorIndex: specialIndex ]-=JUAMPI=-superclass: aClass methodDictionary: mDict format: fmt  super superclass: aClass methodDictionary: mDict format: fmt.  self organization: nil-=JUAMPI=-isEpEvent  ^false-=JUAMPI=-ffiCall: fnSpec library: aLibrary  < ffiCalloutTranslator>  self ffiCall: fnSpec library: aLibrary options: #()-=JUAMPI=-asMilliSeconds  ^self asDuration asMilliSeconds-=JUAMPI=-asFullRingDefinition  | rgClass rgMethod |  rgClass := self realClass asRingDefinition.  rgMethod := self asActiveRingDefinition.  rgClass addMethod: rgMethod.  rgMethod package: (RGContainer packageOfMethod: rgMethod).  ^rgMethod-=JUAMPI=-fuelSetOrigin: originPoint corner: cornerPoint  origin := originPoint.  corner := cornerPoint-=JUAMPI=-postCopy  array := array copy-=JUAMPI=-testByteAt  | number |  number := 16rABCDEF.  self assert: (number byteAt: 1) equals: 16rEF.  self assert: (number byteAt: 2) equals: 16rCD.  self assert: (number byteAt: 3) equals: 16rAB-=JUAMPI=-fourDirections  ^Array with: self leftRotated with: self negated with: self rightRotated with: self-=JUAMPI=-isHealthy  1 to: self basicSize do: [:i |  | selector |        selector := self basicAt: i.        selector ifNotNil: [ (self scanFor: selector) == i ifFalse: [ ^false ] ] ].  ^true-=JUAMPI=-raisedToFraction: aFraction  | result |  result := self asFraction raisedToFraction: aFraction.  ^result isFloat ifTrue: [ result ] ifFalse: [ result asScaledDecimal: scale ]-=JUAMPI=-doSomethingElse  self log: self doSomethingElseString-=JUAMPI=-testIsNonspacingMark  self checkCorrespondanceOf: #isNonspacingMark: and: #Mn-=JUAMPI=-testUnwindFromActiveProcess  | sema process |  sema := Semaphore forMutualExclusion.  self assert: sema isSignaled.  process := [ sema critical: [ self deny: sema isSignaled.        Processor activeProcess terminate ] ] forkAt: Processor userInterruptPriority.  self assert: sema isSignaled-=JUAMPI=-name  ^'Overrides a deprecated method'-=JUAMPI=-inspectSubInstances  | all allSize prefix |  all := self allSubInstances.  (allSize := all size) isZero ifTrue: [ ^self inform: 'There are no instances of ' , self name , 'or any of its subclasses' ].  prefix := allSize = 1 ifTrue: [ 'The lone instance' ] ifFalse: [ 'The ' , allSize printString , ' instances' ].  all asArray inspectWithLabel: prefix , ' of ' , self name , ' & its subclasses'-=JUAMPI=-genStorePopInstVarLong: instVarIndex  (instVarIndex < 0 or: [ instVarIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535 ].  instVarIndex > 255 ifTrue: [ self genUnsignedSingleExtendA: instVarIndex // 256 ].  stream     nextPut: 240;     nextPut: instVarIndex \\ 256-=JUAMPI=-isValid  ^self isReceiverOrAnyArgumentGarbage not-=JUAMPI=-renderOn: aRenderer  self numArgs = 0 ifTrue: [ self value ] ifFalse: [ self value: aRenderer ]-=JUAMPI=-printOn: aStream  | name |  (self asInteger > 32 and: [ self asInteger ~= 127 ]) ifTrue: [ aStream           nextPut: $$;           nextPut: self ] ifFalse: [ name := self class constantNameFor: self.        aStream nextPutAll: self class name.        name notNil ifTrue: [ aStream                 space;                 nextPutAll: name ] ifFalse: [ aStream                 nextPutAll: ' value: ';                 print: self asInteger ] ]-=JUAMPI=-testSimpleEnsureTestWithUparrow  self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithUparrow)-=JUAMPI=-isOtherNumber  ^self characterSet isOtherNumber: self-=JUAMPI=-frameSize  (self header noMask: 16r20000) ifTrue: [ ^SmallFrame ] ifFalse: [ ^LargeFrame ]-=JUAMPI=-numberOfDigitsInBase: b  b = 10 ifFalse: [ ^super numberOfDigitsInBase: b ].  self < 0 ifTrue: [ ^self negated numberOfDigitsInBase: b ].  ^self decimalDigitLength-=JUAMPI=-scaledAndCenteredIn: aRect  ^self width / aRect width > (self height / aRect height) ifTrue: [ aRect left @ (aRect leftCenter y - (self height * (aRect width / self width) / 2)) corner: aRect right @ (aRect rightCenter y + (self height * (aRect width / self width) / 2)) ] ifFalse: [ (aRect topCenter x - (self width * (aRect height / self height) / 2)) @ aRect top corner: (aRect topCenter x + (self width * (aRect height / self height) / 2)) @ aRect bottom ]-=JUAMPI=-defaultAction  reachedDefaultHandler := true.  super defaultAction-=JUAMPI=-testAsDuration  self assert: aDateAndTime asDuration equals: aDuration-=JUAMPI=-testPrintOn  self assert: (String streamContents: [:stream |  false printOn: stream ]) equals: 'false'-=JUAMPI=-split: aSequenceableCollection do: aBlock  self split: aSequenceableCollection indicesDo: [:start :end |  aBlock value: (aSequenceableCollection copyFrom: start to: end) ]-=JUAMPI=->= anInteger  < primitive: 26>  ^super >= anInteger-=JUAMPI=-testOnFork  | result1 result2 |  result2 := nil.  result1 := [ 1 ] on: Exception fork: [ result2 := 2 ].  Processor yield.  self assert: result1 equals: 1.  self assert: result2 isNil-=JUAMPI=-hash  ^self ticks hash-=JUAMPI=-pushReceiverVariable: offset  self push: (self object: self receiver instVarAt: offset + 1)-=JUAMPI=-printStringHex  ^self printStringBase: 16-=JUAMPI=-max: aPoint  ^(x max: aPoint x) @ (y max: aPoint y)-=JUAMPI=-classComment: aString stamp: aStamp  self     comment: aString;     commentStamp: aStamp-=JUAMPI=-testDayOfMonth  self assert: aDateAndTime dayOfMonth equals: 1-=JUAMPI=-testIsNonspacingMark  | charset |  charset := self classUnderTest.  0 to: charset maxValue do: [:asciiValue |  | ch |        ch := Character value: asciiValue.        self assert: (Unicode isNonspacingMark: ch) equals: (charset isNonspacingMark: ch) ]-=JUAMPI=-storeOn: aStream  aStream     print: self printString;     nextPutAll: ' asDate'-=JUAMPI=-isNonspacingMark  ^self characterSet isNonspacingMark: self-=JUAMPI=-hasMultipleExecutors  ^false-=JUAMPI=-testBasicCheck1  | testMethod |  testMethod := testClass >> (testClass compile: 'testMethod SmallFloat64').  self assert: (FloatReferencesRule new basicCheck: testMethod ast)-=JUAMPI=-continuationExample1: aCollection  | streamCreator collector |  streamCreator := [:collection |  | i localBlock |  i := 1.  localBlock := [ | current |  current := collection at: i.  i := i + 1.  Array with: current with: (i <= collection size ifTrue: [ localBlock ] ifFalse: [ nil ]) ] ].  collector := [:valueWithContinuation |  | oc |  oc := OrderedCollection new.  [ | local |  local := valueWithContinuation value.  oc add: local first.  local last notNil ] whileTrue: [  ].  oc ].  ^collector value: (streamCreator value: aCollection)-=JUAMPI=-testBasicProxyWritable  self alwaysWritableObjects , self maybeReadOnlyObjects do: [:each |  self assert: (MirrorPrimitives isObjectReadOnly: each) equals: false ]-=JUAMPI=-isHandlerOrSignalingContext  ^method primitive = 199-=JUAMPI=-testNanoConstructor  | timeFromString timeFromNano timeFromNanoSecond |  timeFromString := Time fromString: '01:23:45.67809'.  timeFromNano := Time hour: 1 minute: 23 second: 45 nano: 67809.  timeFromNanoSecond := Time hour: 1 minute: 23 second: 45 nanoSecond: 67809.  self     assert: timeFromString equals: timeFromNano;     deny: timeFromNano equals: timeFromNanoSecond.  timeFromString := Time fromString: '01:23:45.0'.  timeFromNano := Time hour: 1 minute: 23 second: 45 nano: 0.  self assert: timeFromString equals: timeFromNano.  timeFromString := Time fromString: '01:23:45.1234567890'.  timeFromNano := Time hour: 1 minute: 23 second: 45 nano: 1234567890.  self assert: timeFromString equals: timeFromNano-=JUAMPI=-montgomeryRaisedTo: n times: y modulo: m mInvModB: mInv  | pow j k w index oddPowersOfSelf square |  k := n highBit.  w := (k highBit - 1 >> 1 min: 16) max: 1.  oddPowersOfSelf := Array new: 1 << w.  oddPowersOfSelf at: 1 put: (pow := self).  square := self montgomeryTimes: self modulo: m mInvModB: mInv.  2 to: oddPowersOfSelf size do: [:i |  pow := oddPowersOfSelf at: i put: (pow montgomeryTimes: square modulo: m mInvModB: mInv) ].  pow := y.  [ k > 0 ] whileTrue: [ pow := pow montgomeryTimes: pow modulo: m mInvModB: mInv.        (n bitAt: k) = 0 ifFalse: [ j := k - w max: 1.              [ j < k and: [ (n bitAt: j) = 0 ] ] whileTrue: [ j := j + 1 ].              index := 0.              [ k > j ] whileTrue: [ pow := pow montgomeryTimes: pow modulo: m mInvModB: mInv.                    index := (index << 1) + (n bitAt: k).                    k := k - 1 ].              pow := pow montgomeryTimes: (oddPowersOfSelf at: index + 1) modulo: m mInvModB: mInv ].        k := k - 1 ].  ^pow-=JUAMPI=-asScaledDecimal  ^ScaledDecimal newFromNumber: self scale: 0-=JUAMPI=-sampleMessageWithFirstArgument: firstArgument andInterleavedCommentBeforeSecondArgument: secondArgument  | thisIsAnUnusedTemp |  thisIsAnUnusedTemp := self.  ^thisIsAnUnusedTemp-=JUAMPI=-initialize  super initialize.  vmSimTheTimerSemaphore := Semaphore new.  vmSimNow := 0-=JUAMPI=-copyto: x  | stop |  stop := self bytesCount min: x bytesCount.  ^x replaceFrom: 1 to: stop with: self startingAt: 1-=JUAMPI=-hash  ^self-=JUAMPI=-checkAllClasses  | warnings |  warnings := (self systemNavigation allClassesImplementing: #veryDeepInner:) , (self systemNavigation allClassesImplementing: #veryDeepCopyWith:) flatCollect: [:aClass |  self basicCheckClass: aClass ].  self raiseWarningsIfAny: warnings-=JUAMPI=-truncateTo: grid  | gridPoint |  gridPoint := grid asPoint.  ^(x truncateTo: gridPoint x) @ (y truncateTo: gridPoint y)-=JUAMPI=-testDurationMoreThanMaxTicks  | delay |  delay := Delay new setDelay: 1234 forSemaphore: Semaphore new.  scheduler simulate_vmMilliseconds: 100.  scheduler schedule: delay.  self assert: ticker vmSimNextWakeupMilliseconds equals: 100 + 1000-=JUAMPI=-testFromString  self assert: aDuration equals: (Duration fromString: '1:02:03:04.000000005')-=JUAMPI=-deepCopy  ^self-=JUAMPI=-doesNotUnderstand: aMessage  < debuggerCompleteToSender>  | exception resumeValue |  (exception := MessageNotUnderstood new)     message: aMessage;     receiver: self.  resumeValue := exception signal.  ^exception reachedDefaultHandler ifTrue: [ aMessage sentTo: self ] ifFalse: [ resumeValue ]-=JUAMPI=-testRunSimulated  self assert: (Context runSimulated: aBlockContext) class equals: Rectangle-=JUAMPI=-ephemeronSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames package: cat  ^self ephemeronSubclass: className instanceVariableNames: instVarNameList classVariableNames: classVarNames poolDictionaries: '' package: cat-=JUAMPI=-testTimesAreLocal  | remoteDateAndTime remoteTimestamp localTimestamp |  remoteDateAndTime := DateAndTime current offset: DateAndTime localOffset + 2 hours.  remoteTimestamp := DosTimestamp fromDateAndTime: remoteDateAndTime.  localTimestamp := DosTimestamp fromDateAndTime: remoteDateAndTime asLocal.  self assert: remoteTimestamp equals: localTimestamp-=JUAMPI=-testMetaclassName  self assert: Dictionary class name equals: 'Dictionary class'.  self assert: OrderedCollection class name equals: 'OrderedCollection class'-=JUAMPI=-isExternalCallPrimitive  ^self primitive = 120-=JUAMPI=-testErrorToken  | token1 token2 |  token1 := Context primitiveFailToken.  token2 := Context primitiveFailTokenFor: 100.  self assert: token1 first identicalTo: token2 first.  self assert: token1 second isNil.  self assert: token2 second equals: 100-=JUAMPI=-setUp  super setUp.  value := 0-=JUAMPI=-saveTemp: aTemp  self savedTemps ifNil: [ self propertyAt: #savedTemps put: Set new ].  self savedTemps add: aTemp-=JUAMPI=-align: aPoint1 with: aPoint2  ^self translateBy: aPoint2 - aPoint1-=JUAMPI=-select: aBlock  | newCollection |  newCollection := self class new.  self do: [:each |  (aBlock value: each) ifTrue: [ newCollection add: each ] ].  ^newCollection-=JUAMPI=-testBecomeIdentityHash  | a b c d |  a := 'ab' copy.  b := 'cd' copy.  c := a.  d := b.  a become: b.  self     assert: a identityHash equals: c identityHash;     assert: b identityHash equals: d identityHash;     deny: a identityHash equals: b identityHash-=JUAMPI=-testNumberConvenienceMethods  self     assert: 1 week equals: (Duration days: 7);     assert: -1 week equals: (Duration days: -7);     assert: 1 day equals: (Duration days: 1);     assert: -1 day equals: (Duration days: -1);     assert: 1 hours equals: (Duration hours: 1);     assert: -1 hour equals: (Duration hours: -1);     assert: 1 minute equals: (Duration seconds: 60);     assert: -1 minute equals: (Duration seconds: -60);     assert: 1 second equals: (Duration seconds: 1);     assert: -1 second equals: (Duration seconds: -1);     assert: 1 milliSecond equals: (Duration milliSeconds: 1);     assert: -1 milliSecond equals: (Duration milliSeconds: -1);     assert: 1 nanoSecond equals: (Duration nanoSeconds: 1);     assert: -1 nanoSecond equals: (Duration nanoSeconds: -1)-=JUAMPI=-ifNotNil: ifNotNilBlock ifNil: nilBlock  ^nilBlock value-=JUAMPI=-brickValue: anObject withEnoughArguments: aCollection  ^self valueWithEnoughArguments: {anObject} , aCollection-=JUAMPI=-addCategory: newName before: aCategory  ^self organization addCategory: newName before: aCategory-=JUAMPI=-isPrimFailToken: anObject  ^(self objectClass: anObject) == Array and: [ anObject size = 2 and: [ anObject first == PrimitiveFailToken ] ]-=JUAMPI=-critiques  < eProperty>  | critiques |  critiques := ReCriticEngine critiquesOf: self.  critiques := critiques , (ReCriticEngine nodeCritiquesOf: self).  ^critiques-=JUAMPI=-at: aKey ifPresent: aBlock  ^aBlock value: (self at: aKey ifAbsent: [ ^self ])-=JUAMPI=-genPushLiteralVar: literalIndex  literalIndex < 0 ifTrue: [ ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255 ].  literalIndex < 32 ifTrue: [ stream nextPut: 64 + literalIndex.        ^self ].  literalIndex < 64 ifTrue: [ stream           nextPut: 128;           nextPut: 192 + literalIndex.        ^self ].  literalIndex < 256 ifTrue: [ stream           nextPut: 132;           nextPut: 128;           nextPut: literalIndex.        ^self ].  ^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255-=JUAMPI=-group  ^'Potential Bugs'-=JUAMPI=-testIncludesAll  self assert: (aTimespan includesAll: (Bag with: jan01)).  self deny: (aTimespan includesAll: (Bag with: jan01 with: jan08))-=JUAMPI=-properties  ^ClassProperties at: self ifAbsent: nil-=JUAMPI=-minute  ^self localSeconds // SecondsInMinute \\ 60-=JUAMPI=-triggerEvent: anEventSelector with: anObject  ^self triggerEvent: anEventSelector withArguments: {anObject}-=JUAMPI=-subtractDays: dayCount  ^(self asDateAndTime - dayCount days) asDate-=JUAMPI=-seconds: secondCount nanoSeconds: nanoCount  seconds := secondCount.  nanos := nanoCount-=JUAMPI=-rule: aRule  rule := aRule-=JUAMPI=-testMultDicAddSub  | n f f1 |  n := 100.  f := 100 factorial.  f1 := f * (n + 1).  n timesRepeat: [ f1 := f1 - f ].  self assert: f1 equals: f.  n timesRepeat: [ f1 := f1 + f ].  self assert: f1 // f equals: n + 1.  self assert: f1 negated equals: (Number readFrom: '-' , f1 printString)-=JUAMPI=-nextInstruction  ^self interpretNextInstructionFor: MessageCatcher new-=JUAMPI=-testSemaphoreTimeout  | sem |  sem := Semaphore new.  [ | process |  process := [ Delay timeoutSemaphore: sem afterMSecs: 0.  sem wait ] newProcess.  process priority: Processor highIOPriority.  process resume.  self assert: process isTerminated ] ensure: [ sem signal ]-=JUAMPI=-storeOn: aStream  self storeOn: aStream base: 10-=JUAMPI=-sharedPools: aCollection  sharedPools := aCollection-=JUAMPI=-testNot  self deny: true not-=JUAMPI=-testMillisecondsToGoExpired  | delay |  delay := Delay forMilliseconds: 100.  scheduler simulate_vmMilliseconds: 1.  scheduler schedule: delay.  scheduler simulate_vmMilliseconds: 200-=JUAMPI=-methodClass  ^self outerCode methodClass-=JUAMPI=-testSingleTiming  | timeBefore |  timeBefore := DateAndTime now.  aStopwatch activate.  aDelay wait.  aStopwatch suspend.  self assert: aStopwatch timespans size equals: 1.  self assert: aStopwatch timespans first asDateAndTime >= timeBefore.  self assert: aStopwatch timespans first asDateAndTime <= aStopwatch end-=JUAMPI=-name  ^'Sends a deprecated message to a known global'-=JUAMPI=-var1: anObject  var1 := anObject-=JUAMPI=-name  ^self subclassResponsibility-=JUAMPI=-testConvertFromDecimalFraction  0 to: 11 do: [:pow2 |  0 to: 11 do: [:pow5 |  | fraction sd sd2 |              fraction := 13 / (2 raisedTo: pow2) / (5 raisedTo: pow5).              sd := fraction asScaledDecimal.              self assert: sd scale equals: (pow2 max: pow5).              sd2 := ScaledDecimal readFrom: sd printString.              self assert: sd equals: sd2 ] ]-=JUAMPI=-allSharedPools  ^self superclass ifNil: [ self sharedPools copy ] ifNotNil: [ | aSet |        aSet := self superclass allSharedPools.        aSet           addAll: self sharedPools;           yourself ]-=JUAMPI=-retryUsing: alternativeBlock  handlerContext restartWithNewReceiver: alternativeBlock-=JUAMPI=-criticNameOn: aStream  aStream << self name << ' (' << self category << ')'-=JUAMPI=-methodsReadingSlot: aSlot  ^self methods select: [:method |  method readsSlot: aSlot ]-=JUAMPI=-fieldIndex  ^fieldIndex-=JUAMPI=-addDays: dayCount  ^(self asDateAndTime + dayCount days) asDate-=JUAMPI=-allSubInstances  | aCollection |  aCollection := OrderedCollection new.  self allSubInstancesDo: [:x |  x == aCollection ifFalse: [ aCollection add: x ] ].  ^aCollection-=JUAMPI=-critiqueFor: aPackage  ^ArchitecturalCritique withAnchor: (self anchorFor: aPackage) by: self-=JUAMPI=-testMetaclassSuperclassHierarchy  | s |  self assert: SequenceableCollection class instanceCount equals: 1.  self assert: Collection class instanceCount equals: 1.  self assert: Object class instanceCount equals: 1.  self assert: ProtoObject class instanceCount equals: 1.  s := OrderedCollection new     add: SequenceableCollection class;     add: Collection class;     add: Object class;     add: ProtoObject class;     add: Class;     add: ClassDescription;     add: Behavior;     add: Object;     add: ProtoObject;     yourself.  self assert: OrderedCollection class allSuperclasses equals: s-=JUAMPI=-testEncodingVarLengthSourcePointer  | trailer newTrailer |  trailer := CompiledMethodTrailer new.  trailer sourcePointer: 1.  newTrailer := trailer testEncoding.  self assert: newTrailer sourcePointer equals: 1.  trailer sourcePointer: 16r100000000000000.  newTrailer := trailer testEncoding.  self assert: newTrailer sourcePointer equals: 16r100000000000000.  self assert: newTrailer endPC equals: 0-=JUAMPI=-stonOn: stonWriter  stonWriter writeBoolean: self-=JUAMPI=-as31BitSmallInt  ^self subclassResponsibility-=JUAMPI=-index  ^self monthIndex-=JUAMPI=-genSendSuper: selectorLiteralIndex numArgs: nArgs  | extendedIndex extendedNArgs |  (selectorLiteralIndex < 0 or: [ selectorLiteralIndex > 65535 ]) ifTrue: [ ^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535 ].  (nArgs < 0 or: [ nArgs > 31 ]) ifTrue: [ ^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 ].  (extendedIndex := selectorLiteralIndex) > 31 ifTrue: [ self genUnsignedSingleExtendA: extendedIndex // 32.        extendedIndex := extendedIndex \\ 32 ].  (extendedNArgs := nArgs) > 7 ifTrue: [ self genUnsignedSingleExtendB: extendedNArgs // 8.        extendedNArgs := extendedNArgs \\ 8 ].  stream     nextPut: 235;     nextPut: extendedNArgs + (extendedIndex * 8)-=JUAMPI=-class  < primitive: 111>  self primitiveFailed-=JUAMPI=-bypassGoferLoadUpdateCategories: anObject  bypassGoferLoadUpdateCategories := anObject-=JUAMPI=-tearDown  | aGofer finalWorkingCopyList diff |  aGofer := Gofer new.  self tearDownPackageNames do: [:pName |  (self hasPackage: pName) ifTrue: [ aGofer package: pName ] ].  aGofer references notEmpty ifTrue: [ aGofer metacelloUnload ].  MCRepositoryGroup default     removeIdenticalRepository: (testingEnvironment at: #Metacello_Gofer_Test_Repository ifAbsent: [  ]);     removeIdenticalRepository: (testingEnvironment at: #Metacello_Configuration_Test_Repository ifAbsent: [  ]);     yourself.  testingEnvironment removeKey: #Metacello_Gofer_Test_Repository ifAbsent: [  ].  testingEnvironment removeKey: #Metacello_Configuration_Test_Repository ifAbsent: [  ].  finalWorkingCopyList := MCWorkingCopy allManagers collect: [:each |  each packageName ].  diff := finalWorkingCopyList difference: initialWorkingCopyList.  diff do: [:leak |  MetacelloNotification signal: 'leaked package from ' , self printString , ' -> ' , leak printString ].  self assert: diff isEmpty.  super tearDown-=JUAMPI=-configuration094Issue185: spec  < version: '0.9.4'>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>configuration094Issue185:'.        spec           baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomIssue185SHA1 , '/repository' ];           import: 'External' ]-=JUAMPI=-argumentsWith: aCollection  ^CommandLineArguments withArguments: aCollection-=JUAMPI=-useIncoming  self allow-=JUAMPI=-species  ^MCPackage-=JUAMPI=-title  ^'linear load'-=JUAMPI=-asBaselineProject  ^self-=JUAMPI=-importedVersions: aCollection  importedVersions := aCollection-=JUAMPI=-version42Issue119: spec  < version: '4.2' imports: #('4.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec project: 'Foo' with: '2.0'.        spec package: 'GoferBar ' with: 'GoferBar-jf.1' ]-=JUAMPI=-allow  self checkAllowed.  self resume: self newProjectRegistration-=JUAMPI=-setUpConfigurationIssue339  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfIssue339-dkh.1'.  className := #ConfigurationOfIssue339.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version100Issue339:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version100Issue339:) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfo-=JUAMPI=-ignoreImage  ^self loaderPolicy ignoreImage-=JUAMPI=-baseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec           package: 'Example-Core';           package: 'Example-AddOn' with: [ spec requires: #('Example-Core') ];           package: 'Example-Tests' with: [ spec requires: #('Example-AddOn') ];           package: 'Example-TestsUI' with: [ spec requires: #('Example-UI' 'Example-Tests') ];           package: 'Example-UI' with: [ spec requires: #('Example-AddOn') ] ]-=JUAMPI=-name  ^name-=JUAMPI=-import: aString provides: anArray  importArray := importArray ifNil: [ {(aString -> anArray)} ] ifNotNil: [ importArray , {(aString -> anArray)} ]-=JUAMPI=-testAddProjectA  | packages project projectReferenceSpec |  packages := self packagesSpec.  packages add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself).  packages add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: projectReferenceSpec projectName equals: 'Project'.  self assert: projectReferenceSpec versionString equals: '1.0'.  self should: [ projectReferenceSpec includes: #() ] raise: Error.  self should: [ projectReferenceSpec requires: #() ] raise: Error.  self should: [ projectReferenceSpec answers: #() ] raise: Error.  projectReferenceSpec projectDo: [:prjct |  self assert: projectReferenceSpec identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  project projectDo: [:prjct |  self assert: project identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ]-=JUAMPI=-configMethodBodyOn: aStream hasName: hasName indent: indent  | hasFile hasRepositories hasPreLoadDoIt hasPostLoadDoIt hasRequiresOrIncludesOrAnswers |  hasFile := file ~~ nil.  hasRepositories := self repositorySpecs size > 0.  hasPreLoadDoIt := self getPreLoadDoIt ~~ nil.  hasPostLoadDoIt := self getPostLoadDoIt ~~ nil.  hasRequiresOrIncludesOrAnswers := (self requires isEmpty and: [ self includes isEmpty and: [ self answers isEmpty ] ]) not.  hasRequiresOrIncludesOrAnswers ifTrue: [ self configMethodBodyOn: aStream hasName: hasName cascading: hasFile | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt indent: indent ].  self configMethodOn: aStream for: file selector: 'file: ' cascading: hasName | hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers cascade: hasRepositories | hasPreLoadDoIt | hasPostLoadDoIt indent: indent.  hasRepositories ifTrue: [ self repositorySpecs size > 1 ifTrue: [ hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers ifTrue: [ aStream                       cr;                       tab: indent ].              aStream                 nextPutAll: 'repositories: [';                 cr;                 tab: indent + 1;                 nextPutAll: 'spec';                 cr.              self repositories configMethodCascadeOn: aStream indent: indent + 1.              aStream nextPutAll: ' ]' ] ifFalse: [ hasName | hasFile | hasPreLoadDoIt | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers ifTrue: [ aStream                       cr;                       tab: indent ].              self repositories configMethodCascadeOn: aStream indent: indent ].        hasPreLoadDoIt | hasPostLoadDoIt ifTrue: [ aStream nextPut: $; ] ].  self configMethodOn: aStream for: self getPreLoadDoIt selector: 'preLoadDoIt: ' cascading: hasName | hasFile | hasRepositories | hasPostLoadDoIt | hasRequiresOrIncludesOrAnswers cascade: hasPostLoadDoIt indent: indent.  self configMethodOn: aStream for: self getPostLoadDoIt selector: 'postLoadDoIt: ' cascading: hasName | hasFile | hasRepositories | hasPreLoadDoIt | hasRequiresOrIncludesOrAnswers cascade: false indent: indent.  aStream nextPut: $.-=JUAMPI=-remove  -=JUAMPI=-lesson13  ^Lesson title: 'Lesson 12 (DoIts)' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #baseline13:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version13:."For version 1.3 we are adding a platform specific package ''Example-Platform''. ''Example-Platform''requires ''Example-Core''. On GemStone, Pharo and Squeak, a branch of the ''Example-Platform'' package will be loaded: ''Example-Platform.gemstone'', ''Example-Platform.pharo'', ''Example-Platform.squeak'' respectively will be loaded. Consequently we''ve updated the baselines with #baseline13: to reflect the structural changes and#version13: reflects the package versions.The platform-specific versions and branches are defined in the #for:do: block for the correspondingplatforms: #gemstone, #pharo, #squeak (in both methods)The result of the following expression will depend on the platform upon which you are running:"	(MetacelloTutorialConfig project version: ''1.3'') load."Note that when you execute the following expresson to load ''Example-Core'' that the correct''Example-Platform'' is loaded as well:"	(MetacelloTutorialConfig project version: ''1.3'') load: ''Example-Core''."If you look at the specification for ''Example-Core'' (in #baseline13:) you will note that ''Example-Core'' #includes: ''Example-Platform''. The #includes: directive means that the package ''Example-Platform'' should be loaded whenever the ''Example-Core'' package is loaded.Also note when you evaluate the following expression that the ''Example-Platform'' package is loadedbefore ''Example-Tests'' as if ''Example-Tests'' #requires: ''Example-Platform'':"	(MetacelloTutorialConfig project version: ''1.3'') load: ''Example-Tests''."When you use the #includes: directive, you are not only specifying that the listed packages shouldbe loaded when the parent package is loaded, but that the #included: packages should be loaded_before_ any packages that require the parent package."ProfStef next.'-=JUAMPI=-version  ^self optionAt: 'version'-=JUAMPI=-lesson10  -=JUAMPI=-baseline50Foo: spec  < version: '5.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.2';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferFaux' with: 'GoferFaux-tg.34';           package: 'GoferBeau' with: 'GoferBeau-dkh.55';           yourself.        spec           group: '1' with: #('GoferFoo' 'GoferBar');           group: '2' with: #('GoferFoo' 'GoferFaux');           yourself ]-=JUAMPI=-root  ^root-=JUAMPI=-projectForScriptEngine: aMetacelloScriptEngine unconditionalLoad: aBool  ^self subclassResponsibility-=JUAMPI=-asBaselineProjectSpec  ^self-=JUAMPI=-requiredSpecsForPackageOrdering: aVersionSpec  ^#()-=JUAMPI=-primeRegistryProjectSpecRegistered: projectSpec  MetacelloProjectRegistration registrationForProjectSpec: projectSpec ifAbsent: [:new |  ^false ] ifPresent: [:existing :new |  ^true ]-=JUAMPI=-handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock  ^onUpgradeBlock cull: self cull: self existingProjectRegistration cull: self newProjectRegistration-=JUAMPI=-beforeLoads  beforeLoads == nil ifTrue: [ beforeLoads := OrderedCollection new ].  ^beforeLoads-=JUAMPI=-silently: aBool  self loaderPolicy silently: aBool-=JUAMPI=-baselineVersion124ProjectToolBox: spec  < version: '1.2.4-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'http://www.example.com/aa' ].  spec for: #common do: [ spec repository: 'http://www.example.com/ab' ]-=JUAMPI=-resolveRecordingPackageSpecReference: packageSpec gofer: gofer  | externalPackageReference |  externalPackageReference := packageSpec file == nil ifTrue: [ GoferPackageReference name: packageSpec name ] ifFalse: [ GoferResolvedReference name: packageSpec file repository: nil ].  packageSpec repositorySpecs isEmpty ifTrue: [ self repositoryMap at: externalPackageReference packageName put: (gofer repositories reject: [:repo |  repo = MetacelloPlatform current defaultPackageCache ]) ] ifFalse: [ self repositoryMap at: externalPackageReference packageName put: (packageSpec repositorySpecs collect: [:repoSpec |  repoSpec createRepository ]) ].  ^externalPackageReference-=JUAMPI=-postLoad: packageOrVersionSpec  self evalDoits ifFalse: [ ^self ].  packageOrVersionSpec postLoadDoItBlock ~~ nil ifTrue: [ self afterLoads add: packageOrVersionSpec printString , ' load' ].  super postLoad: packageOrVersionSpec-=JUAMPI=-isMutable  mutable ifNil: [ ^true ].  ^mutable-=JUAMPI=-requiredSpecNamesForPackageOrdering: aVersionSpec  ^(self requiredSpecsForPackageOrdering: aVersionSpec) collect: [:spec |  spec name ]-=JUAMPI=-resolvePackageSpec: packageSpec gofer: gofer  | references resolvedReference mcVersion loadedVersionInfos |  references := self retryingResolvePackageSpecReferences: packageSpec gofer: gofer.  resolvedReference := references last asMetacelloCachingResolvedReference.  mcVersion := resolvedReference version.  (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ifTrue: [ loadedVersionInfos do: [:info |  info name = mcVersion info name ifTrue: [ | spc |                    spc := packageSpec copy.                    spc file: info name.                    (MetacelloIgnorePackageLoaded signal: spc) ifFalse: [ ^nil ] ] ] ].  ^resolvedReference-=JUAMPI=-mergeIntoMetacelloPackages: aMetacelloPackagesSpec  aMetacelloPackagesSpec addMember: (aMetacelloPackagesSpec mergeMember           name: self name;           spec: self;           yourself)-=JUAMPI=-attribute  self deprecated: 'Use attributes instead'.  self attributes size > 1 ifTrue: [ self error: 'invalid use of attribute' ].  self attributes isEmpty ifTrue: [ ^nil ].  ^self attributes first-=JUAMPI=-exception: anObject  exception := anObject-=JUAMPI=-configurationRepository  ^MetacelloConfigurationResource current monticelloRepository-=JUAMPI=-aPackageIsLoaded: aBoolean  aPackageIsLoaded := aBoolean-=JUAMPI=-linearLoadPackageSpec: packageSpec gofer: gofer  MetacelloPlatform current do: [ | externalReference loadBlock answers fake |        externalReference := self resolveRecordingPackageSpecReference: packageSpec gofer: gofer.        loadBlock := [ self preLoad: packageSpec.        (MetacelloDirective loadPackage: packageSpec externalReference: externalReference loader: self) addTo: self loadDirective.        self postLoad: packageSpec ].        (answers := packageSpec answers) notEmpty ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ] ifFalse: [ loadBlock value ].        fake := packageSpec copy.        fake name: fake file.        self loadData addVersion: fake versionInfo: fake resolvedReference: externalReference packageSpec: packageSpec ] displaying: 'Recording ' , packageSpec file-=JUAMPI=-spec  ^spec-=JUAMPI=-configurationExternalRef091: spec  < version: '0.9.1'>  spec for: #common do: [ spec blessing: #version.        spec description: 'MetacelloScriptingResource>>configurationExternalRef090:'.        spec project: 'External' with: [ spec                 className: 'ConfigurationOfExternal';                 version: '0.9.1';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]-=JUAMPI=-downloadZipArchive: url to: outputFileName  outputFileName asFileReference ensureDelete.  [:bar |  bar title: 'Download: ' , url asString , ' to ' , outputFileName.  [ ZnClient new     url: url;     signalProgress: true;     downloadTo: outputFileName ] on: HTTPProgress do: [:progress |  progress isEmpty ifFalse: [ bar current: progress percentage ].        progress resume ] ] asJob run.  ^ZipArchive new readFrom: outputFileName asFileReference-=JUAMPI=-projectSpec  ^projectSpec-=JUAMPI=-testRemoveD  | repositories removed |  repositories := self repositoriesSpec.  repositories add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  repositories remove: 'http://example.com/repository'.  removed := false.  repositories map at: 'http://example.com/repository' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-projectMethodSource  ^(self class sourceCodeAt: #project) asString-=JUAMPI=-version43SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version43Symbolic:) asString-=JUAMPI=-hash  ^self versionComponents hash-=JUAMPI=-packageSpecsInLoadOrderForMap: packageMap  | loadOrder pkgs packageNames importNames importSpec importProjectSpecs importProjectNameMap |  loadOrder := self packageSpecsInLoadOrder.  importNames := (packageNames := (packageMap values collect: [:pkg |  pkg name ]) asSet) copy.  (self import isNil and: [ self importArray isNil ]) ifTrue: [ ^loadOrder select: [:pkg |  packageNames includes: pkg name ] ].  loadOrder do: [:pkg |  importNames remove: pkg name ifAbsent: [  ] ].  pkgs := OrderedCollection new.  importProjectSpecs := Dictionary new.  importProjectNameMap := Dictionary new.  importArray ifNotNil: [ loadOrder do: [:pkg |  importArray do: [:assoc |  assoc key = pkg name ifTrue: [ importProjectSpecs at: pkg name put: pkg.                          (assoc value select: [:each |  importNames includes: each ]) do: [:each |  (importProjectNameMap at: pkg name ifAbsent: [ importProjectNameMap at: pkg name put: Set new ]) add: each ] ] ] ] ].  self import ifNotNil: [ loadOrder do: [:pkg |  pkg name = self import ifTrue: [ importProjectSpecs at: pkg name put: pkg.                    importProjectNameMap at: pkg name put: importNames ] ] ].  loadOrder do: [:pkg |  (packageNames includes: pkg name) ifTrue: [ pkgs add: pkg ].        importProjectSpecs at: pkg name ifPresent: [:importProjectSpec |  (importProjectNameMap at: pkg name ifAbsent: [ #() ]) do: [:importedName |  pkgs add: (importSpec := importProjectSpec copy                             name: importedName;                             mergeImportLoads: {importedName};                             yourself).                    importSpec projectReference name: importedName ] ] ].  ^pkgs-=JUAMPI=-testBaselineOrConfigurationNameSuffix  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: cli baselineOrConfigurationNameSuffix equals: 'MineSweeper'.  cli := self command: #('install' 'http://ss3.gemstone.com/ss/MetaRepoForPharo20' 'ConfigurationOfFoo').  self assert: cli baselineOrConfigurationNameSuffix equals: 'Foo'-=JUAMPI=-version10Issue136: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec blessing: #development.        spec package: 'GoferBeau' with: 'GoferBeau-dkh.15' ]-=JUAMPI=-invalidConfiguration10: spec  < version: '1.0.0'>  spec for: #common do: [ spec blessing: #release.        spec description: 'MetacelloScriptingResource>>invalidConfiguration10: ... missing className:'.        spec project: 'External' with: [ spec                 version: '0.9.0';                 repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalConfigurationSHA , '/repository' ] ]-=JUAMPI=-setUpIssue77B  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfIssue77B-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline10B:' category: 'cat' timeStamp: '' source: self baseline10MethodSourceB)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())-=JUAMPI=-packageSpec  ^packageSpec-=JUAMPI=-locked  locked ifNil: [ locked := false ].  ^locked-=JUAMPI=-name  ^self description-=JUAMPI=-hasGroups  ^self hasOption: 'groups'-=JUAMPI=-existingProjectRegistration  ^existingProjectRegistration-=JUAMPI=-doingLoads: aBlock  -=JUAMPI=-testForDoListAtrribute1Active  | project version expected actual |  project := self projectWith: #(#attribute1).  version := project version: '3.0-baseline'.  expected := 'spec blessing: #''baseline''.spec preLoadDoIt: #''preloadForCore''.spec postLoadDoIt: #''postloadForCore:package:''.spec 	project: ''Example Project'' with: [		spec			className: ''ConfigurationOfExampleProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ];	project: ''Extra Project'' with: [		spec			className: ''ConfigurationOfExtraProject'';			versionString: ''1.0-baseline'';			preLoadDoIt: #''preloadForProject'';			postLoadDoIt: #''postloadForProject'';			loads: #(''core'' ) ].spec 	group: ''Core'' with: #(''Example Project'' );	group: ''Core'' with: #(''Extra Project'' ).'.  actual := version spec printString.  self assert: expected equals: actual-=JUAMPI=-possibleVersions  ^self versionDoesNotExistException possibleVersions-=JUAMPI=-defaultRepositoryDescription  ^'http://www.squeaksource.com/MetacelloRepository'-=JUAMPI=-gtInspectorVersionsIn: composite  < gtInspectorPresentationOrder: 40>  composite list     title: 'Versions';     display: #versions-=JUAMPI=-goferCommitProject: commitMessage  | pkgSpec |  (pkgSpec := self projectPackage) == nil ifTrue: [ ^false ].  ^pkgSpec goferCommitPackage: commitMessage-=JUAMPI=-testRemoveA  | repositories removed |  repositories := self repositoriesSpec.  repositories add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself).  repositories remove: (self repositorySpec           description: 'http://example.com/repository';           yourself).  removed := false.  repositories map at: 'http://example.com/repository' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-isResumable  ^false-=JUAMPI=-versionString: anObject  versionString := anObject-=JUAMPI=-closestAncestorVersionFor: anAncestry ifNone: errorBlock  ^self localRepository closestAncestorVersionFor: anAncestry ifNone: errorBlock-=JUAMPI=-recordingSpecLoader  ^self-=JUAMPI=-packageForVersion: aString  | spec |  spec := self project packageSpec     name: aString;     yourself.  self root packages add: spec-=JUAMPI=-version08: spec  < version: '0.8' imports: #('0.7-baseline')>  spec for: #common do: [ spec           package: 'Example-Core' with: 'Example-Core-anon.15';           package: 'Example-Tests' with: 'Example-Tests-anon.6';           package: 'Example-AddOn' with: 'Example-AddOn-anon.2' ]-=JUAMPI=-dataMap  dataMap == nil ifTrue: [ dataMap := Dictionary new ].  ^dataMap-=JUAMPI=-loaderPolicy  loaderPolicy == nil ifTrue: [ loaderPolicy := MetacelloLoaderPolicy new ].  ^loaderPolicy-=JUAMPI=-= aMetacelloVersionNumber  | condensed aCondensed |  aMetacelloVersionNumber species = self species ifFalse: [ ^false ].  condensed := self collapseZeros.  aCondensed := aMetacelloVersionNumber collapseZeros.  (condensed ~~ self or: [ aCondensed ~~ aMetacelloVersionNumber ]) ifTrue: [ ^condensed compareEqualTo: aCondensed ].  ^self compareEqualTo: aMetacelloVersionNumber-=JUAMPI=-versionNumber  ^self project versionNumberClass fromString: self versionString-=JUAMPI=-referencedSpec  ^self-=JUAMPI=-projectVersion: aString  | x |  aString ifNil: [ projectVersion := aString.        ^self ].  (x := aString findDelimiters: {$# .         $* .         $?} startingAt: 1) <= aString size ifTrue: [ self resolveProjectVersionPattern: aString ] ifFalse: [ projectVersion := aString ]-=JUAMPI=-runCase  | original |  self doSilently ifFalse: [ ^super runCase ].  original := MetacelloPlatform current bypassGoferLoadUpdateCategories.  [ MetacelloPlatform current bypassGoferLoadUpdateCategories: true.  ^MetacelloPlatform current suspendSystemUpdateEventsDuring: [ super runCase ] ] ensure: [ MetacelloPlatform current bypassGoferLoadUpdateCategories: original ]-=JUAMPI=-configurationForVersion: aString with: aBlock  aBlock setConfiguration: aString withInMetacelloConfig: self-=JUAMPI=-baselineVersion30Issue125: spec  < version: '3.0-baseline' imports: #('2.0-baseline')>  spec for: #(#attribute1 #attribute2) do: [ spec description: 'MetacelloConfigurationResource>>baselineVersion30Issue125:'.        spec           package: 'GoferFaux' with: [ spec requires: 'GoferFoo' ];           package: 'GoferBeau' with: [ spec requires: 'GoferFaux' ];           yourself ]-=JUAMPI=-versionSpec  ^versionSpec-=JUAMPI=-asConfigurationProjectSpec  ^self copyForScriptingInto: (MetacelloMCConfigurationOfProjectSpec for: self project asConfigurationProject)-=JUAMPI=-customProjectAttributes  ^#()-=JUAMPI=-testMCProjectSpec  | project repository |  project := self projectSpec.  project     name: 'Project';     projectPackage: self project packageSpec;     className: 'ConfigurationOfProject';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project projectPackage name equals: project className.  self assert: project projectPackage file equals: project className.  repository := project repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := project repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'-=JUAMPI=-packageAndProjectNamesToLoad: defaultList loader: aLoader  | loadedPackageNames projectMap loadedProjectNames list |  loadedPackageNames := ((self packages select: [:pkg |  pkg isPackageLoaded: aLoader ]) collect: [:pkg |  pkg name ]) asSet , defaultList.  projectMap := Dictionary new.  self projects do: [:prj |  prj className ~~ nil ifTrue: [ | coll loaded |              coll := projectMap at: prj className ifAbsent: [ coll := OrderedCollection new.                    projectMap at: prj className put: coll.                    coll ].              (loaded := prj loadedPackageNames: aLoader) isEmpty ifFalse: [ coll add: prj -> (loaded -> prj loadPackageList) ] ] ].  loadedProjectNames := Set new.  projectMap keysAndValuesDo: [:prjClass :coll |  coll size <= 1 ifTrue: [ coll do: [:assoc |  loadedProjectNames add: assoc key name ] ] ifFalse: [ coll do: [:assoc |  | loaded packageList |                    loaded := assoc value key.                    packageList := assoc value value.                    (packageList difference: loaded) isEmpty ifTrue: [ loadedProjectNames add: assoc key name ] ] ] ].  list := loadedPackageNames , loadedProjectNames.  list isEmpty ifTrue: [ ^self spec defaultPackageNames ].  ^list-=JUAMPI=-buildMapFrom: mapList for: packageList  | map |  map := Dictionary new.  mapList do: [:assoc |  | pkgName pkgSpec |        pkgName := assoc key.        (packageList includes: pkgName) ifFalse: [ self error: 'package ' , pkgName printString , ' not found in packages.' ].        map at: pkgName put: assoc value ].  ^map-=JUAMPI=-projectPath  ^projectPath-=JUAMPI=-conflictOf20: spec  < version: '2.0.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>conflictOf20:'.        spec author: 'dkh'.        spec timestamp: '6/1/2012 14:46' ].  spec for: #custom do: [ spec configuration: 'ExternalX' with: [ spec                 version: '0.9.0';                 repository: 'dictionary://Metacello_Conflict_Test_Repository' ] ]-=JUAMPI=-setUpBaselineIssue215  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'BaselineOfIssue215-dkh.1'.  className := #BaselineOfIssue215.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #BaselineOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'postloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #postloadDoIt) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'preloadDoIt' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #preloadDoIt) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'baselineIssue215:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #baselineIssue215:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfo-=JUAMPI=-workingCopy  ^self projectPackage workingCopy-=JUAMPI=-warningReasonCodes  ^super warningReasonCodes , #(#loadWarning #notDevelopmentVersion #stableDevelopmentVersion)-=JUAMPI=-hasVersion: versionString  self version: versionString ifAbsent: [ ^false ].  ^true-=JUAMPI=-versionString  ^self versionNumber versionString-=JUAMPI=-defaultTimeout  ^60000-=JUAMPI=-baselineOfProjectSpecClass  ^MetacelloCypressBaselineProjectSpec-=JUAMPI=-loads: anObject constructor: aVersionConstructor  aVersionConstructor loadsForProject: anObject-=JUAMPI=-useCurrentVersion  ^self options at: #useCurrentVersion ifAbsent: [ false ]-=JUAMPI=-version10: spec  < version: '1.0' imports: #('1.0-baseline')>  spec for: #common do: [ spec           package: 'Example-Core' with: 'Example-Core-anon.14';           package: 'Example-Tests' with: 'Example-Tests-anon.3';           package: 'Example-AddOn' with: 'Example-AddOn-anon.1';           package: 'Example-AddOnTests' with: 'Example-AddOnTests-anon.1' ]-=JUAMPI=-onWarning: aBlock  self options at: #onWarning put: aBlock-=JUAMPI=-packageloads  packageloads == nil ifTrue: [ packageloads := OrderedCollection new ].  ^packageloads-=JUAMPI=-reset  attributeMap := attributeOrder := nil-=JUAMPI=-target: anObject  target := anObject-=JUAMPI=-aLoadedPackageIsNotCurrent: aBoolean  aLoadedPackageIsNotCurrent := aBoolean-=JUAMPI=-decrementMajorVersion  self decrementVersionAt: 1-=JUAMPI=-packagesNeedSavingVisited: visitedProjects using: repos into: aCollection  ^self loader packagesNeedSavingUsing: repos into: aCollection-=JUAMPI=-repository: description username: username password: password  self root repository: description username: username password: password constructor: self-=JUAMPI=-createFiletreeRepository: aRepositorySpec  MCRepository findFiletreeAlternateFormat: aRepositorySpec ifFound: [:repository |  ^repository createRepositoryFromSpec: aRepositorySpec on: self ].  ^super createFiletreeRepository: aRepositorySpec-=JUAMPI=-handleResolutionFor: aScriptEngine  self subclassResponsibility-=JUAMPI=-extractTypeFromDescription: description  description == nil ifTrue: [ ^nil ].  ((description beginsWith: '/') or: [ description second = $: ]) ifTrue: [ ^'directory' ].  (description beginsWith: 'dictionary://') ifTrue: [ ^'dictionary' ].  (description beginsWith: 'filetree://') ifTrue: [ ^'filetree' ].  (description beginsWith: 'tonel://') ifTrue: [ ^'tonel' ].  (description beginsWith: 'github://') ifTrue: [ ^'github' ].  (description beginsWith: 'gitorious://') ifTrue: [ ^'gitorious' ].  (description beginsWith: 'bitbucket://') ifTrue: [ ^'bitbucket' ].  ^'http'-=JUAMPI=-hasPackage: aString  | package |  package := MCWorkingCopy allManagers detect: [:each |  each packageName = aString ] ifNone: [ nil ].  ^package notNil-=JUAMPI=-notEmpty  ^self list notEmpty-=JUAMPI=-projectName  ^self projectSpec name-=JUAMPI=-isPackageLoaded: aLoader  MCWorkingCopy allManagers detect: [:wc |  wc packageName = self file ] ifNone: [ ^false ].  ^true-=JUAMPI=-lesson10  -=JUAMPI=-methodSections: anObject  methodSections := anObject-=JUAMPI=-versionString  ^MetacelloMCBaselineProject singletonVersionName-=JUAMPI=-baseline13C: spec  < version: '1.3'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GeauxBeau' with: 'GeauxBeau-dkh.56';           yourself ]-=JUAMPI=-projectName  ^self projectReference name-=JUAMPI=-aProjectIsLoaded  ^aProjectIsLoaded-=JUAMPI=-configuration  ^configuration-=JUAMPI=-versionString: anObject constructor: aVersionConstructor  self error: 'versionString: not allowed in a baseline project spec'-=JUAMPI=-repository: aString username: username password: password  self repositories repository: aString username: username password: password.  self projectPackage: nil-=JUAMPI=-packageDirectivesDo: aBlock  self loadDirectives do: [:directive |  directive packageDirectivesDo: aBlock ]-=JUAMPI=-baselineProjectSpec  ^baselineProjectSpec-=JUAMPI=-configurationProjectSpecs  | projectSpecs |  projectSpecs := OrderedCollection new.  self configurationRegistry keysAndValuesDo: [:className :registration |  projectSpecs add: (self projectSpecForClassNamed: className ifAbsent: [ self error: 'not expected' ]) ].  ^projectSpecs asArray-=JUAMPI=-projectAttributes  projectAttributes ~~ nil ifTrue: [ ^projectAttributes ].  ^#()-=JUAMPI=-projectWith: projectAttributes  | project |  project := MetacelloMCProject new.  project projectAttributes: projectAttributes.  MetacelloVersionConstructor on: self projectClass new project: project.  project loader: MetacelloNullRecordingMCSpecLoader new.  project loader evalDoits: false.  ^project-=JUAMPI=-projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  self packageSpecsInLoadOrder do: [:pkgSpec |  pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ]-=JUAMPI=-baseline61Fix: spec  < version: '6.1'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           package: 'GoferFoo' with: 'GoferFoo-lr.4';           package: 'GoferBar' with: 'GoferBar-lr.1';           package: 'GoferBeau' with: 'GoferBeau-dkh.53';           package: 'GoferFaux' with: 'GoferFaux-tg.31';           yourself ]-=JUAMPI=-validateProjectVersionLoad: versionString loads: loadList  | issues project version |  (issues := (self validateProjectVersion: versionString) select: [:issue |  issue isError ]) notEmpty ifTrue: [ ^issues ].  project := self configurationClass project.  version := project version: versionString ifAbsent: [ self recordValidationError: 'Version ' , versionString printString , ' does not exist.' callSite: #validateProjectVersionLoad:loads: reasonCode: #cannotResolveVersion.        ^self validationReport ].  version blessing = #broken ifTrue: [ self error: 'The specified version is #broken' ].  self validateCleanLoadAndTestsForVersion: version loads: loadList.  ^self validationReport-=JUAMPI=-postCopy  super postCopy.  blessing := blessing copy.  description := description copy.  author := author copy.  timestamp := timestamp copy.  packageList := packageList copy-=JUAMPI=-category: anObject  category := anObject-=JUAMPI=-preLoadDo: aBlock  aBlock value: self-=JUAMPI=-alternateRepository  ^MetacelloAlternateResource current monticelloRepository-=JUAMPI=-updateVersionMethodForVersion: inputVersionStringOrSymbol versionSpecsDo: aBlock  ^self updateVersionMethodForVersion: inputVersionStringOrSymbol updateProjects: true updatePackages: true versionSpecsDo: aBlock-=JUAMPI=-timestamp  ^self basicSpec timestamp value-=JUAMPI=-currentVersion  ^self version isSomethingLoaded ifTrue: [ self version ] ifFalse: [ nil ]-=JUAMPI=-version102ProjectToolBox: spec  < version: '1.0.2-baseline'>  spec for: #common do: [ spec preLoadDoIt: #preloadForCore.        spec postLoadDoIt: #postloadForCore:package:.        spec           package: 'Example-Core' with: [ spec includes: #('Example-AddOn') ];           package: 'Example-AddOn' with: [ spec requires: #('Example-Core') ];           package: 'Example-Tests' with: [ spec requires: #('Example-AddOn') ] ]-=JUAMPI=-description: anObject  anObject setDescriptionInMetacelloVersion: self-=JUAMPI=-isPossibleBaseline  self subclassResponsibility-=JUAMPI=-spotterForRequiresFor: aStep  < spotterOrder: 2>  aStep listProcessor     title: 'Requires';     allCandidates: [ self requires ];     itemName: [:item |  item name ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: true-=JUAMPI=-versionString  ^versionString-=JUAMPI=-testVersion13  self deny: (self versionClass fromString: '0.8') <= (self versionClass fromString: '0.7').  self deny: (self versionClass fromString: '0.8.1.8') <= (self versionClass fromString: '0.7.0.5')-=JUAMPI=-isConfigurationName  ^self baselineOrConfigurationName matchesRegex: 'ConfigurationOf.+'-=JUAMPI=-evaluateMethodSection: methodSection version: sourceVersionString  | versionSpec |  versionSpec := self project versionSpec.  versionSpec versionString: sourceVersionString.  methodSection versionSpec: versionSpec.  currentSection := methodSection.  self with: versionSpec during: methodSection block.  methodSection methodSections do: [:ms |  self evaluateMethodSection: ms version: sourceVersionString ]-=JUAMPI=-fetchRequiredFromArray: anArray  | originalLoader displayString newLoader |  originalLoader := self versionSpec loader.  newLoader := originalLoader fetchingSpecLoader.  displayString := newLoader actionLabel , self versionNumber printString , ' of ' , self spec projectLabel.  MetacelloPlatform current do: [ [ self versionSpec loader: newLoader.        MetacelloPlatform current useStackCacheDuring: [:dict |  ^self executeLoadFromArray: anArray ] defaultDictionary: Dictionary new ] ensure: [ self versionSpec loader: originalLoader ] ] displaying: displayString-=JUAMPI=-baseline10: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec package: 'Example-Core' with: [ spec                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: self directoryForPlatform ] ]-=JUAMPI=-packageNamed: aString forLoad: ignored forMap: map ifAbsent: absentBlock  | importSpec |  ^map at: aString ifAbsent: [ (self importArray notNil or: [ self import notNil ]) ifTrue: [ importArray ifNotNil: [ importArray do: [:assoc |  ((assoc value includes: aString) and: [ map includesKey: assoc key ]) ifTrue: [ importSpec := (map at: assoc key)                                   mergeImportLoads: {aString};                                   yourself ] ].                    importSpec ifNotNil: [ ^importSpec ] ].              (importSpec isNil and: [ self import notNil ]) ifTrue: [ ^(map at: self import ifAbsent: absentBlock)                       mergeImportLoads: {aString};                       yourself ] ].        (aString = 'default' or: [ aString = 'ALL' ]) ifTrue: [ self project groupSpec                 name: aString;                 includes: self packageNames;                 yourself ] ifFalse: [ absentBlock value ] ]-=JUAMPI=-loadType  ^#linear-=JUAMPI=-testProjectTagsUrlFor  | repository |  repository := MCGitlabRepository location: 'gitlab://pharo-project/pharo:master/src'.  self assert: (repository projectTagsUrlFor: 'pharo-project/pharo') equals: 'https://gitlab.com/api/v4/projects/pharo-project/pharo/repository/tags'.  repository := MCGitlabRepository location: 'gitlab://git.pharo.org:pharo-project/pharo:master/src'.  self assert: (repository projectTagsUrlFor: 'pharo-project/pharo') equals: 'https://git.pharo.org/api/v4/projects/pharo-project/pharo/repository/tags'-=JUAMPI=-testMixedStack  | x |  self assert: (x := self mixedStack) identicalTo: 4-=JUAMPI=-latestVersion  ^self version-=JUAMPI=-computeVersionStatus: resolvedPackageAndProjectNames matchBlock: matchBlock  | status |  status := resolvedPackageAndProjectNames ifNil: [ self isPartiallyCurrent ] ifNotNil: [ self isPartiallyCurrentAgainst: resolvedPackageAndProjectNames ].  status isAllLoadedToSpec: matchBlock.  status isLoadedToSpec: matchBlock.  status isLoadedMatchConstraints: matchBlock.  status isSomethingLoaded: matchBlock-=JUAMPI=-projectSpecCreationBlock  ^[:projectName |  {(MetacelloMCProject new projectSpec name: projectName)} ]-=JUAMPI=-symbolicVersionMap: aDictionary  symbolicVersionMap := aDictionary-=JUAMPI=-projectForVersion: aString  self project: aString with: ''-=JUAMPI=-handleResolutionFor: aScriptEngine  ^aScriptEngine handleDowngrade: self-=JUAMPI=-className: aString  self root className: aString constructor: self-=JUAMPI=-tempRepositories  tempRepositories ifNil: [ tempRepositories := OrderedCollection new ].  ^tempRepositories-=JUAMPI=-constructClassName  ^nil-=JUAMPI=-tearDown  | finalWorkingCopyList diff |  self tearDownPackages.  self tearDownRepositories.  MetacelloProjectRegistration registry: registry.  self disableUndefinedSymbolTracking ifTrue: [ MetacelloPlatform current reenableUndefinedSybolUpdates: undefinedSymbols ].  finalWorkingCopyList := MCWorkingCopy allManagers collect: [:each |  each packageName ].  diff := finalWorkingCopyList difference: initialWorkingCopyList.  diff do: [:leak |  MetacelloNotification signal: 'leaked package from ' , self printString , ' -> ' , leak printString ].  self assert: diff isEmpty.  super tearDown-=JUAMPI=-registrationForExactClassNamed: aClassName ifAbsent: absentBlock  self configurationRegistry at: aClassName ifPresent: [:registration |  ^registration ].  self baselineRegistry at: aClassName ifPresent: [:registration |  ^registration ].  ^absentBlock value-=JUAMPI=-mixedStackCall  ^MetacelloPlatform current stackCacheFor: #mixedStack at: #key doing: [:cache |  | value |        value := cache at: #x ifAbsent: [ 0 ].        value > 3 ifTrue: [ ^value ].        value := value + 1.        cache at: #x put: value.        self assert: self cachedReturnOfValue identicalTo: 6.        self mixedStackCall ]-=JUAMPI=-baseline: aString with: aBlockOrString  self root baseline: aString with: aBlockOrString constructor: self-=JUAMPI=-testRemovePackageB  | packages removed |  packages := self packagesSpec.  packages add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  packages remove: {(self packageSpec           name: 'Package';           yourself)}.  removed := false.  packages packageNamed: 'Package' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-externalBaselineXXX: spec  < baseline>  spec for: #common do: [ spec description: 'MetacelloScriptingResource>>externalBaselineXXX:'.        spec           package: 'External-CoreX';           package: 'External-TestsX' with: [ spec requires: 'External-CoreX' ];           yourself.        spec           group: 'Core' with: #('External-CoreX');           group: 'default' with: #('Core');           group: 'Tests' with: #('External-TestsX');           yourself ].  spec for: #custom do: [ spec package: 'External-UIX'.        spec group: 'UI' with: #('External-UIX') ]-=JUAMPI=-versionString  ^self versionDoesNotExistException versionString-=JUAMPI=-loaderPolicy  ^loaderPolicy-=JUAMPI=-match: aVersionPattern  | patternVersion mySize patternSize |  patternVersion := aVersionPattern asMetacelloVersionNumber.  mySize := self size.  patternSize := patternVersion size.  mySize = patternSize ifFalse: [ mySize < patternSize ifTrue: [ ^false ].        (patternVersion at: patternSize) ~= '?' ifTrue: [ ^false ].        mySize := patternSize ].  1 to: mySize do: [:i |  | pattern |        pattern := (patternVersion at: i) asString.        pattern = '?' ifTrue: [ i = mySize ifFalse: [ ^self error: 'Invalid version match pattern: ' , aVersionPattern printString ] ] ifFalse: [ (pattern match: (self at: i) asString) ifFalse: [ ^false ] ] ].  ^true-=JUAMPI=-projectVersion10Issue283: spec  < version: '1.0'>  spec for: #common do: [ spec blessing: #release.        spec configuration: 'ProjectIssue283' with: [ spec                 version: #stable;                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ] ]-=JUAMPI=-projectWith: projectAttributes  | project |  project := MetacelloProject new.  project projectAttributes: projectAttributes.  MetacelloVersionConstructor on: self project: project.  ^project-=JUAMPI=-unregisterProjectRegistration: aMetacelloProjectRegistration  aMetacelloProjectRegistration configurationProjectSpec ifNotNil: [:spec |  self configurationRegistry removeKey: spec className ifAbsent: [ self error: 'unexpectedly missing project registration' ] ].  aMetacelloProjectRegistration baselineProjectSpec ifNotNil: [:spec |  self baselineRegistry removeKey: spec className ifAbsent: [ self error: 'unexpectedly missing project registration' ] ]-=JUAMPI=-fetchProject  ^self fetchProject: MetacelloLoaderPolicy new-=JUAMPI=-preloadDoItMethodSource  ^(self class sourceCodeAt: #preloadDoIt) asString-=JUAMPI=-testAddB  | repositories repository |  repositories := self repositoriesSpec.  repositories     add: (self repositorySpec           description: 'http://example.com/repository';           username: 'dkh';           password: 'password';           yourself);     add: '/opt/gemstone/repository'.  repository := repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: 'http://example.com/repository'.  self assert: repository type equals: 'http'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'.  repository := repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository description equals: '/opt/gemstone/repository'.  self assert: repository type equals: 'directory'-=JUAMPI=-setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new.  versionReferences do: [:reference |  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) with: (MCClassDefinition name: (reference packageName copyWithout: $-) asSymbol superclassName: #Object category: reference packageName asSymbol instVarNames: #() comment: ''))) dependencies: #()) ]-=JUAMPI=-testBaseline10Projects  | project version expected list |  project := self project.  version := project version: '1.0-baseline'.  expected := #('UTF8').  list := version projects.  self assert: list size equals: expected size.  list do: [:pkg |  self assert: (expected includes: pkg name) ]-=JUAMPI=-versionOfXX: spec  < version: '0.9.0'>  spec for: #common do: [ spec blessing: #development.        spec description: 'MetacelloScriptingResource>>versionOfXX:'.        spec author: 'dkh'.        spec timestamp: '5/4/2012 14:16' ].  spec for: #custom do: [ spec baseline: 'External' with: [ spec repository: 'github://dalehenrich/external:' , MetacelloScriptingResource externalCustomSHA , '/repository' ] ]-=JUAMPI=-version134ProjectToolBox: spec  < version: '1.3.4-baseline'>  spec for: #common do: [  ]-=JUAMPI=-repository: anObject  self root repository: anObject constructor: self-=JUAMPI=-repository: description username: username password: password  | spec |  spec := self project repositorySpec     description: description;     username: username;     password: password;     yourself.  self addMember: (self addMember           name: spec name;           spec: spec;           yourself)-=JUAMPI=-testEqualityComparison  self deny: '1.0.0+-' asMetacelloSemanticVersionNumber equals: '1.0.0--' asMetacelloSemanticVersionNumber.  self sampleVersionStrings do: [:versionString |  self assert: versionString asMetacelloSemanticVersionNumber equals: versionString asMetacelloSemanticVersionNumber ]-=JUAMPI=-postLoad: packageOrVersionSpec  | block |  (block := packageOrVersionSpec postLoadDoItBlock) ~~ nil ifTrue: [ block valueWithPossibleArgs: {self .               packageOrVersionSpec} ]-=JUAMPI=-testMCVersionSpec  | version projectReferenceSpec group package repository |  version := self versionSpec     blessing: #baseline;     versionString: '1.0';     repository: 'http://example.com/repository' username: 'dkh' password: 'password';     repository: '/opt/gemstone/repository';     yourself.  version packages     add: (self packageSpec           name: 'Package';           requires: 'AnotherPackage';           includes: 'IncludedPackage';           answers: #(#('preload' 'preload answer') #('postload' 'postload answer'));           file: 'Package-dkh.1';           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself);     add: (self packageSpec           name: 'AnotherPackage';           yourself);     add: (self packageSpec           name: 'IncludedPackage';           yourself);     add: (self groupSpec           name: 'Platform';           includes: 'Core';           yourself);     add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProjectA';           versionString: #stable;           loads: #('MyPackage' 'MyTests');           preLoadDoIt: #preLoadDoItB;           postLoadDoIt: #postLoadDoItB;           yourself);     yourself.  self assert: version blessing value equals: #baseline.  self assert: version versionString value equals: '1.0'.  repository := version repositories map at: '/opt/gemstone/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'directory'.  repository := version repositories map at: 'http://example.com/repository' ifAbsent: [ self assert: false ].  self assert: repository type equals: 'http'.  self assert: repository username equals: 'dkh'.  self assert: repository password equals: 'password'.  package := version packages packageNamed: 'Package' ifAbsent: [ self assert: false ].  self assert: package name equals: 'Package'.  group := version packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  self assert: (group includes includes: 'Core').  projectReferenceSpec := version packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  self assert: projectReferenceSpec projectName equals: 'Project'.  self assert: projectReferenceSpec versionString equals: #stable.  version projectDo: [:prjct |  prjct == projectReferenceSpec ] packageDo: [:pkg |  pkg == package ] groupDo: [:grp |  grp == group ]-=JUAMPI=-allPackagesForSpecNamed: aStringOrArray ifAbsent: aBlock  ^aStringOrArray resolvePackageSpecsNamedForMetacelloMCVersion: self visited: MetacelloVisitedPackages new ifAbsent: aBlock-=JUAMPI=-testRepositoryUrl  | cli |  cli := self command: #('install' 'github://juliendelplanque/MineSweeper/repository' 'BaselineOfMineSweeper').  self assert: cli repositoryUrl equals: 'github://juliendelplanque/MineSweeper/repository'-=JUAMPI=-errorMap  errorMap ifNil: [ errorMap := Dictionary new ].  ^errorMap-=JUAMPI=-useStackCacheDuring: aBlock defaultDictionary: defaultDictionary  | dict |  dict := MetacelloStackCacheNotification signal.  dict == nil ifTrue: [ dict := defaultDictionary == nil ifTrue: [ Dictionary new ] ifFalse: [ defaultDictionary ] ].  [ ^aBlock value: dict ] on: MetacelloStackCacheNotification , MetacelloClearStackCacheNotification do: [:ex |  (ex isKindOf: MetacelloStackCacheNotification) ifTrue: [ ex resume: dict ].        (ex isKindOf: MetacelloClearStackCacheNotification) ifTrue: [ | keys |              keys := ex cacheNames.              keys ifNil: [ keys := dict keys ].              keys do: [:k |  (dict includesKey: k) ifTrue: [ | c |                          c := dict at: k.                          c keys do: [:ck |  c removeKey: ck ].                          dict removeKey: k ] ].              ex resume ] ]-=JUAMPI=-lastVersion  ^self version-=JUAMPI=-hasRepository  ^false-=JUAMPI=-setName: aStringOrNil  self shouldBeMutable.  name := aStringOrNil-=JUAMPI=-removeGroupForVersion: aString  | spec |  spec := self project groupSpec     name: aString;     yourself.  self root packages remove: spec-=JUAMPI=-sortedAndFilteredVersions  ^(self map values asArray sort: [:a :b |  a >= b ]) select: [:vrsn |  (#(structural broken baseline) includes: vrsn blessing) not ]-=JUAMPI=-testMergeProjectB  | packages project projectReferenceSpec referenceSpec |  packages := self packagesSpec.  project := self projectSpec     name: 'Project';     className: 'ConfigurationOfProjectA';     versionString: #stable;     loads: #('MyPackage' 'MyTests');     preLoadDoIt: #preLoadDoItB;     postLoadDoIt: #postLoadDoItB;     yourself.  referenceSpec := self project projectReferenceSpec     name: project name;     projectReference: project;     yourself.  packages add: referenceSpec.  project := self projectSpec     name: 'Project';     className: 'ConfigurationOfProject';     versionString: '1.0';     operator: #<;     loads: #('MyPackage');     preLoadDoIt: #preLoadDoIt;     postLoadDoIt: #postLoadDoIt;     yourself.  referenceSpec := self project projectReferenceSpec     name: project name;     projectReference: project;     yourself.  packages merge: {referenceSpec}.  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  project projectDo: [:prjct |  self assert: project identicalTo: prjct ] packageDo: [:ignored |  self assert: false ] groupDo: [:ignored |  self assert: false ]-=JUAMPI=-testVersion23  self assert: (MetacelloVersionNumber fromString: '3.0.0.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0') > (MetacelloVersionNumber fromString: '3.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3') > (MetacelloVersionNumber fromString: '3-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0.-rc.1') equals: (MetacelloVersionNumber fromString: '3.0.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3') > (MetacelloVersionNumber fromString: '3.0-rc.1').  self assert: (MetacelloVersionNumber fromString: '3.0') > (MetacelloVersionNumber fromString: '3.0.0-rc.1')-=JUAMPI=-setIncludes: aCollection  includes := aCollection-=JUAMPI=-methodSections  methodSections == nil ifTrue: [ methodSections := OrderedCollection new ].  ^methodSections-=JUAMPI=-bitbucketUser: userName project: projectName commitish: commitish path: path  | branchOrCommitOrTag |  branchOrCommitOrTag := commitish.  branchOrCommitOrTag isEmpty ifTrue: [ branchOrCommitOrTag := 'master' ].  self repository: 'bitbucket://' , userName , '/' , projectName , ':' , branchOrCommitOrTag , '/' , path-=JUAMPI=-specsNamed: packageAndProjectNames projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock  | map |  map := self packages map.  packageAndProjectNames do: [:name |  | pkgSpec |        (pkgSpec := map at: name ifAbsent: [  ]) ~~ nil ifTrue: [ pkgSpec projectDo: projectBlock packageDo: packageBlock groupDo: groupBlock ] ]-=JUAMPI=-newVersionForWorkingCopy: aWorkingCopy  ^aWorkingCopy newVersion-=JUAMPI=-lesson11  -=JUAMPI=-spec  ^spec-=JUAMPI=-isPossibleBaseline  self projectDo: [:prj |  prj isPossibleBaseline ifFalse: [ ^false ] ] packageDo: [:pkg |  pkg isPackageLoaded ifFalse: [ ^false ] ] groupDo: [:ignored |   ].  ^true-=JUAMPI=-baseline40MethodSourceProjectIssue95  ^(self class sourceCodeAt: #baseline40ProjectIssue95:) asString-=JUAMPI=-setUpConfigurationNextedIssue84dkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'ConfigurationOfNestedIssue84-dkh.1'.  className := #ConfigurationOfNestedIssue84.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #ConfigurationOf category: reference packageName instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'version10NestedIssue84:' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #version10NestedIssue84:) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'versionNumberClass' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #versionNumberClass) asString) .   (MCMethodDefinition className: className asString classIsMeta: false selector: 'customProjectAttributes' category: 'cat' timeStamp: '' source: (self class sourceCodeAt: #customProjectAttributes) asString)}.  configurationRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfo-=JUAMPI=-resolveToPackagesIn: aVersionSpec andProjects: andProjectsBool visited: visited  ^andProjectsBool ifTrue: [ {self} ] ifFalse: [ self resolveToPackagesIn: aVersionSpec visited: visited ]-=JUAMPI=-repositoryForProject: anObject  self repositoryForSpec: anObject-=JUAMPI=-isSample  ^false-=JUAMPI=-externalRepositoryContents  ^#('External-CoreX-dkh.1' 'BaselineOfExternalX-dkh.1' 'BaselineOfGithubRefXX-dkh.1' 'BaselineOfGithubRefIV-dkh.1' 'BaselineOfGithubRefV-dkh.1' 'BaselineOfGithubRefVI-dkh.1' 'BaselineOfGithubRefVII-dkh.1' 'BaselineOfGithubRefVIII-dkh.1' 'BaselineOfGithubRefIX-dkh.1' 'BaselineOfGithubRefXI-dkh.1' 'BaselineOfGithubRefXII-dkh.1' 'BaselineOfGithubRefXIII-dkh.1')-=JUAMPI=-goferCommitPackage: commitMessage  | latestFile pkgSpec |  ^(file notNil and: [ self name = self file ]) ifTrue: [ latestFile := self loader latestPackage: self name fromRepository: self repositorySpecs.        pkgSpec := self copy.        pkgSpec file: latestFile.        pkgSpec goferCommitPackage: commitMessage ] ifFalse: [ self loader goferCommitPackageUsing: self repositorySpecs commitMessage: commitMessage ]-=JUAMPI=-asProjectRegistration  ^MetacelloProjectRegistration fromMCBaselineProjectSpec: self-=JUAMPI=-project  ^self projectWith: #()-=JUAMPI=-lesson10  ^Lesson title: 'Lesson 10' lesson: 'Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #baseline10:.Smalltalk tools browser openOnClass: MetacelloTutorialConfig selector: #version10:."In #baseline10: we''ve added two things: the ''Example-AddOnTests'' package and a specification for groups. The ''Example-AddOnTests'' package has been added to make the idea of needing to group packages alittle more appealing. The package requires ''Example-AddOn'' and ''Example-Tests''.With two Test packages it would be convenient to be able to load all of the tests with a simpleexpression like the following:"  (MetacelloTutorialConfig project version: ''1.0'') load: { ''Tests''. }."instead of having to explicitly list all of the test projects like this:"  (MetacelloTutorialConfig project version: ''1.0'') 	load: { ''Example-Tests''. ''Example-AddOnTests''. }."This becomes especially useful if over time the project evolves to have more component and test packages.The ''default'' group is special in that when a ''default'' group is defined, the #load method loadsthe members of the ''default'' group instead of loading all of the packages:"  (MetacelloTutorialConfig project version: ''1.0'') load."If you want to load all of the packages in a project, then the pseudo group ''ALL'' may be used asfollows:"  (MetacelloTutorialConfig project version: ''1.0'') load: ''ALL''.ProfStef next.'-=JUAMPI=-version41SymbolicMethodSourceSymbolic  ^(self class sourceCodeAt: #version41Symbolic:) asString-=JUAMPI=-isConfigurationOfProjectSpec  ^true-=JUAMPI=-onConflict: aBlock  self options at: #onConflict put: aBlock-=JUAMPI=-baselineVersion40Issue119: spec  < version: '4.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Foo' with: [ spec                 versionString: #bleedingEdge;                 className: 'MetacelloTestConfigurationOfFoo';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           yourself.        spec package: 'GoferBar' ]-=JUAMPI=-printOn: aStream  self print: self normalVersion prefix: nil on: aStream.  self print: self preReleaseVersion prefix: $- on: aStream.  self print: self buildVersion prefix: $+ on: aStream-=JUAMPI=-setUpMonticelloRepository  monticelloRepository := MCDictionaryRepository new-=JUAMPI=-setUpConfigurationOfAtomicFan  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfAtomicFan-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline20Fan:' category: 'cat' timeStamp: '' source: self baseline20MethodSourceFan) .   (MCMethodDefinition className: className asString selector: 'baseline31Fan:' category: 'cat' timeStamp: '' source: self baseline31MethodSourceFan) .   (MCMethodDefinition className: className asString selector: 'postLoad31baseline' category: 'cat' timeStamp: '' source: self postLoad31baselineMethodSource)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())-=JUAMPI=-file: aString  file := aString-=JUAMPI=-versionSpec  ^self project versionSpec-=JUAMPI=-loadUsing: mcLoader  self loader doingLoads: [ self explicitLoadUsing: mcLoader ]-=JUAMPI=-validateBaselineOf  self validatePragmas.  ^self validateBaselineProject-=JUAMPI=-project  ^self versionSpec project-=JUAMPI=-asMetacelloSemanticVersionNumber  ^self-=JUAMPI=-testInvalidSpecialMatch  self should: [ (self versionClass fromString: '1.1') match: '?.?' ] raise: Error-=JUAMPI=-validateConfiguration  | issues |  issues := (MetacelloMCVersionValidator validateConfiguration: project configuration class recurse: false) select: [:issue |  issue isCritical ].  issues notEmpty ifTrue: [ MetacelloValidationFailure issues: issues message: 'There are critical issues in the configuration' ]-=JUAMPI=-primeRegistryFromImage: prioritizeConfiguration  self primeRegistryFromImage: MetacelloProjectRegistration configurationClasses baselineClasses: MetacelloProjectRegistration baselineClasses prioritizeConfiguration: prioritizeConfiguration-=JUAMPI=-modifiedPackageSpecs: versionStringOrSymbol packageSpecsDo: aBlock  | versionSpec |  versionSpec := (self project version: versionStringOrSymbol) spec.  versionSpec projectDo: [:ignored |   ] packageDo: [:packageSpec |  | wc |        wc := packageSpec workingCopy.        wc ~~ nil ifTrue: [ wc modified ifTrue: [ aBlock value: versionSpec value: packageSpec value: wc ] ] ] groupDo: [:ignored |   ]-=JUAMPI=-baselineOfProjectSpec  ^self baselineOfProjectSpecClass for: self-=JUAMPI=-setUpIssue399  | versionInfo |  versionInfo := self setUpIssue399CoreSampledkh1.  versionInfo := self setUpIssue399CoreSampledkh2: {versionInfo}.  self     setUpIssue399CoreExternaldkh1;     setUpBaselineIssue399;     setUpBaselineIssue399Cypress;     yourself-=JUAMPI=-latestVersionMatching: versionPatternString excludedBlessings: excluded  ^self latestVersionMatching: versionPatternString includedBlessings: #() excludedBlessings: excluded-=JUAMPI=-useCurrentVersion: aBool  self options at: #useCurrentVersion put: aBool-=JUAMPI=-label  ^self spec label-=JUAMPI=-hasRepository  ^self repositorySpecs notEmpty-=JUAMPI=-loader  loader == nil ifTrue: [ loader := self versionSpec loader copy.        loader spec: self.        loaderPolicy notNil ifTrue: [ loader loaderPolicy: loaderPolicy ] ].  ^loader-=JUAMPI=-createDevelopmentVersion  ^Lesson title: '2. Create development version' lesson: '"After the configuration and initial baseline version have been created, define the initial development version:"		MetacelloToolBox		createDevelopment: ''1.0''		for: ''Example''		importFromBaseline: ''1.0-baseline''		description: ''initial version''."After evaluating the above expression, take a look at the #version10: method in ConfigurationOfExample:"	Smalltalk tools browser openOnClass: ConfigurationOfExample selector: #version10:."The current version of the Shout project has been filled in as well as the current version of the ProfStef packages.When a new development version is created the #development symbolic version is defined as well:"	Smalltalk tools browser openOnClass: ConfigurationOfExample selector: #development:."The #development version is defined as 1.0 for all platforms.Note that the #development symbolic version is used in a number of the Development Support scripts, so you want to make sure that it is kept up-to-date."ProfStef next.'-=JUAMPI=-projectPackage: aBlock  self root projectPackage: aBlock constructor: self-=JUAMPI=-setUpIssue399CoreSampledkh1  | reference className definitionArray versionInfo |  reference := GoferVersionReference name: 'Issue399-Core-dkh.1'.  className := #Issue399Sample.  definitionArray := {(MCOrganizationDefinition categories: (Array with: reference packageName asSymbol)) .   (MCClassDefinition name: className superclassName: #Object category: reference packageName instVarNames: #() comment: '')}.  sampleRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (versionInfo := MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #()).  ^versionInfo-=JUAMPI=-setUpConfigurationOfFeaux  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfFeaux-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline40Feaux:' category: 'cat' timeStamp: '' source: self baseline40MethodSourceFeaux)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())-=JUAMPI=-setUpConfigurationOfFix  | reference className definitionArray |  reference := GoferVersionReference name: 'MetacelloTestConfigurationOfFix-dkh.1'.  className := reference packageName asSymbol.  definitionArray := {(MCOrganizationDefinition categories: (Array with: className)) .   (MCClassDefinition name: className superclassName: #Object category: className instVarNames: #() comment: '') .   (MCMethodDefinition className: className asString classIsMeta: true selector: 'project' category: 'cat' timeStamp: '' source: self projectClassMethodSource) .   (MCMethodDefinition className: className asString selector: 'project' category: 'cat' timeStamp: '' source: self projectMethodSource) .   (MCMethodDefinition className: className asString selector: 'baseline60Fix:' category: 'cat' timeStamp: '' source: self baseline60MethodSourceFix) .   (MCMethodDefinition className: className asString selector: 'baseline61Fix:' category: 'cat' timeStamp: '' source: self baseline61MethodSourceFix)}.  monticelloRepository basicStoreVersion: (MCVersion new setPackage: (MetacelloTestsMCPackage new name: reference packageName) info: (MCVersionInfo name: reference name id: UUID new message: 'This is a mock version' date: Date today time: Time now author: reference author ancestors: #()) snapshot: (MCSnapshot fromDefinitions: definitionArray) dependencies: #())-=JUAMPI=-configurationRepositoryContents  ^#('ConfigurationOfExternalX-dkh.1' 'ConfigurationOfExternalXX-dkh.1' 'ConfigurationOfExternalXXX-dkh.1' 'ConfigurationOfExternalIV-dkh.1' 'MarianosImage-dkh.1')-=JUAMPI=-version20Foo: spec  < version: '2.0' imports: #('2.0-baseline')>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec blessing: #release.        spec           package: 'GoferBar' with: 'GoferBar-dkh.1';           package: 'GoferFoo' with: 'GoferFoo-dkh.4';           package: 'GoferBeau' with: 'GoferBeau-dkh.15';           package: 'GoferFaux' with: 'GoferFaux-tg.30';           yourself ]-=JUAMPI=-install  | metacello |  metacello := Metacello new.  self isBaselineName ifTrue: [ metacello baseline: self baselineOrConfigurationNameSuffix ].  self isConfigurationName ifTrue: [ metacello configuration: self baselineOrConfigurationNameSuffix ].  metacello repository: self repositoryUrl.  self hasVersion ifTrue: [ metacello version: self version ].  self hasGroups ifTrue: [ metacello load: self groups ] ifFalse: [ metacello load ]-=JUAMPI=-scriptExecutor  ^(self class scriptExecutorClass: self executorSpec) new-=JUAMPI=-projectPath: anObject  projectPath := anObject-=JUAMPI=-validateVersion: versionStringOrSymbol  | issues |  issues := (MetacelloMCVersionValidator validateProject: project version: versionStringOrSymbol) select: [:issue |  issue isError ].  issues notEmpty ifTrue: [ MetacelloValidationFailure issues: issues message: 'There are error issues with version ' , versionStringOrSymbol printString ]-=JUAMPI=-baselineVersion10MetacelloExample: spec  < version: '1.0-baseline'>  spec for: #common do: [ spec blessing: #baseline.        spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec package: 'GoferFoo' ]-=JUAMPI=-versionOrNil  ^self projectReference versionOrNil-=JUAMPI=-repository: aString username: username password: password  self repositoriesSpec repository: aString username: username password: password-=JUAMPI=-baseline14: spec  < version: '1.4-baseline' imports: #('1.2-baseline')>  spec for: #common do: [ spec description: 'Add groups and Project-Extra, extending 1.2-baseline'.        spec           package: 'Project-Core' with: [ spec includes: 'Project-Extra' ];           package: 'Project-Extra' with: [ spec requires: 'Project-Core' ].        spec           group: 'default' with: #('Project-Core' 'Project-Extra');           group: 'Core' with: #('default');           group: 'Tests' with: #('Project-Tests') ]-=JUAMPI=-projectForVersion: aString copyFrom: oldSpecName with: aBlock  | spec projectSpec |  projectSpec := self project projectSpec     name: aString;     yourself.  spec := self project projectReferenceSpec     name: aString;     projectReference: projectSpec;     yourself.  self root packages copy: oldSpecName to: spec.  self with: projectSpec during: aBlock-=JUAMPI=-setBlessing: anObject  blessing := anObject-=JUAMPI=-handleLock: exception  ^(self options at: #onLock ifAbsent: [ ^exception pass ]) cull: exception cull: exception existingProjectRegistration cull: exception newProjectRegistration-=JUAMPI=-setVersionString: anObject  versionString ifNil: [ self versionString: anObject ]-=JUAMPI=-testVersion22  self assert: (MetacelloVersionNumber fromString: '3.0.0') collapseZeros size equals: 1.  self assert: (MetacelloVersionNumber fromString: '3.0.0') equals: (MetacelloVersionNumber fromString: '3.0').  self assert: (MetacelloVersionNumber fromString: '3.0') equals: (MetacelloVersionNumber fromString: '3.0.0')-=JUAMPI=-version115ProjectToolBox: spec  < version: '1.1.5-baseline' imports: #('1.1.4-baseline')>  spec for: #common do: [ spec project: 'Example Project' with: [ spec preLoadDoIt: #alternatePreloadForCore ] ]-=JUAMPI=-configMethodOn: aStream indent: indent  aStream     tab: indent;     nextPutAll: 'spec';     cr.  self configMethodCascadeOn: aStream indent: indent-=JUAMPI=-operationString  ^operationString-=JUAMPI=-baseline13: spec  < version: '1.3-baseline'>  spec for: #squeakCommon do: [ spec package: 'Example-Core' with: [ spec                 includes: 'Example-AddOn';                 file: 'Example-Core-anon.1';                 repository: 'ftp://ftp.example.com/examples' ] ]-=JUAMPI=-testRemoveProjectA  | packages project projectReferenceSpec removed |  packages := self packagesSpec.  packages add: (self projectSpec           name: 'Project';           className: 'ConfigurationOfProject';           versionString: '1.0';           operator: #<;           loads: #('MyPackage');           preLoadDoIt: #preLoadDoIt;           postLoadDoIt: #postLoadDoIt;           yourself).  projectReferenceSpec := packages packageNamed: 'Project' ifAbsent: [ self assert: false ].  project := projectReferenceSpec referencedSpec.  self assert: project name equals: 'Project'.  self assert: project className equals: 'ConfigurationOfProject'.  self assert: project versionString equals: '1.0'.  self assert: project operator identicalTo: #<.  self assert: project loads equals: #('MyPackage').  self assert: project preLoadDoIt value identicalTo: #preLoadDoIt.  self assert: project postLoadDoIt value identicalTo: #postLoadDoIt.  packages remove: (self projectReferenceSpec           name: 'Project';           yourself).  removed := false.  packages packageNamed: 'Project' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-baseline40ProjectLoop: spec  < version: '4.0'>  spec for: #common do: [ spec repository: 'dictionary://Metacello_Gofer_Test_Repository'.        spec           project: 'Infinite' with: [ spec                 className: 'MetacelloTestConfigurationOfProjectInfinite';                 versionString: '4.0';                 loads: 'GoferBar';                 repository: 'dictionary://Metacello_Configuration_Test_Repository' ];           package: 'GoferFaux' with: [ spec                 file: 'GoferFaux-tg.30';                 requires: 'Infinite';                 yourself ];           package: 'GeauxBeau' with: [ spec                 file: 'GeauxBeau-dkh.55';                 yourself ];           yourself ]-=JUAMPI=-validateVersionString: issues withDefaultVersionString: ignored  self versionString ifNotNil: [:vs |  | prj |        prj := self project asBaselineProject.        vs ~= prj singletonVersionName ifTrue: [ issues add: (MetacelloValidationError configurationClass: self projectClass reasonCode: #invalidVersionString callSite: #validateForScriptLoad:withDefaultVersionString:withDefaultRepositoryDecription: explanation: 'version field is incorrect, should be: ' , prj singletonVersionName printString) ] ]-=JUAMPI=-loader: aLoader  self shouldBeMutable.  loader := aLoader copy.  loader spec: self-=JUAMPI=-directoryForPlatform  | dir |  dir := '/opt/mcexamples'.  (Smalltalk classNamed: #OSPlatform) ifNotNil: [:c |  c current isWindows ifTrue: [ dir := 'c:\opt\mcexamples' ] ].  ^dir-=JUAMPI=-updatePackageSpec: updatedSpecs  | prj currentVersion spec |  className == nil ifTrue: [ ^self ].  prj := self projectClassProject.  (currentVersion := prj currentVersion) = self versionOrNil ifTrue: [ ^self ].  currentVersion == nil ifTrue: [ ^self ].  spec := self copy.  spec versionString: currentVersion versionString.  updatedSpecs at: spec name put: spec-=JUAMPI=-aLoadedProjectIsNotCurrent  ^aLoadedProjectIsNotCurrent-=JUAMPI=-versionInfo: aMetacelloProjectRegistrationVersionInfo  versionInfo := aMetacelloProjectRegistrationVersionInfo-=JUAMPI=-validateDoItSelector: anObject  anObject == nil ifTrue: [ ^self ].  anObject isSymbol ifFalse: [ self error: 'Invalid message selector for doit: ' , anObject printString ]-=JUAMPI=-packageSpecClass  ^MetacelloCypressPackageSpec-=JUAMPI=-aLoadedPackageIsExact: aBoolean  aLoadedPackageIsExact := aBoolean-=JUAMPI=-recursiveDelete: aDirectory  ^aDirectory recursiveDelete-=JUAMPI=-samplePath  ^'metacello-tests/sample'-=JUAMPI=-ancestorsFor: packageSpec ifAbsent: aBlock  ^self versionInfoMap at: packageSpec file ifAbsent: [ self packageNameMap at: packageSpec name ifAbsent: aBlock ]-=JUAMPI=-decrementMinorVersionNumber  self decrementNormalVersionAt: 3-=JUAMPI=-version  ^self version: self singletonVersionName-=JUAMPI=-postloadForCore: loader package: packageSpec  MetacelloNotification signal: '#postloadForCore executed, Loader: ' , loader printString , ' spec: ' , packageSpec printString-=JUAMPI=-determineCurrentVersionForLoad  ^self version-=JUAMPI=-handleLookupProjectSpecForLoad: exception  | requested override |  requested := exception projectSpec.  override := self useCurrentVersion ifTrue: [ nil ] ifFalse: [ | registered |        registered := self lookupProjectSpecFor: exception projectSpec.        (registered compareEqual: requested) ifFalse: [ override := registered ] ].  ^exception resume: (MetacelloProjectSpecForLoad new           projectSpec: requested;           useDetermineVersionForLoad: self useCurrentVersion;           overrideProjectSpec: override;           yourself)-=JUAMPI=-target  ^target-=JUAMPI=-answers  answers == nil ifTrue: [ answers := #() ].  ^answers-=JUAMPI=-setPostLoadDoIt: aSymbol  self shouldBeMutable.  postLoadDoIt := aSymbol-=JUAMPI=-baseline61MethodSourceProjectIssue86  ^(self class sourceCodeAt: #baseline61ProjectIssue86:) asString-=JUAMPI=-loadUsing: aLoader gofer: gofer  -=JUAMPI=-closeZipArchive: anArchive  -=JUAMPI=-testRemoveGroupC  | packages removed |  packages := self packagesSpec.  packages add: {(self groupSpec           name: 'Platform';           includes: 'Core';           yourself) .         (self groupSpec           name: 'Base';           includes: 'Base';           yourself) .         (self groupSpec           name: 'Tests';           includes: 'Tests';           yourself)}.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  packages packageNamed: 'Base' ifAbsent: [ self assert: false ].  packages packageNamed: 'Tests' ifAbsent: [ self assert: false ].  packages remove: 'Tests'.  packages packageNamed: 'Platform' ifAbsent: [ self assert: false ].  packages packageNamed: 'Base' ifAbsent: [ self assert: false ].  removed := false.  packages packageNamed: 'Tests' ifAbsent: [ removed := true ].  self assert: removed-=JUAMPI=-versionReferences  ^versionReferences-=JUAMPI=-performLoad  | displayString spec |  spec := self projectSpec.  displayString := 'Project: ' , spec name.  spec versionString ~~ nil ifTrue: [ displayString := displayString , ' ' , spec versionString ].  MetacelloNotification signal: displayString.  self hasOverride ifTrue: [ | override |        override := self overrideProjectSpec copy.        override mergeScriptLoads: spec.        override loadVersion: nil ] ifFalse: [ | vrsn |        vrsn := self useDetermineVersionForLoad ifTrue: [ spec determineCurrentVersionForLoad ] ifFalse: [ spec versionOrNil ].        (spec asProjectSpecForVersion: vrsn) loadVersion: vrsn ]-=JUAMPI=-repositorySpecs  ^self repositories map values-=JUAMPI=-selectedFillStyle  ^self theme tabLabelSelectedFillStyleFor: self-=JUAMPI=-printStructureOn: aStream indent: tabCount  tabCount timesRepeat: [ aStream tab ].  self printOn: aStream.  aStream cr.  self submorphsDo: [:m |  m printStructureOn: aStream indent: tabCount + 1 ]-=JUAMPI=-updateFromEvent: anEvent  | pNew previousX newWidth minX newLeft |  pNew := anEvent cursorPoint - lastMouse second.  minX := index = 1 ifTrue: [ container minResizerX ] ifFalse: [ (container columnResizers at: index - 1) right + container minResizerOffset ].  newLeft := minX max: pNew x.  index = 1 ifTrue: [ newLeft := newLeft + 3 ].  self left: newLeft.  previousX := index = 1 ifTrue: [ container scroller left - container scroller offset x + 3 ] ifFalse: [ (container columnResizers at: index - 1) left ].  newWidth := self left - previousX.  (container columns at: index) currentWidth: newWidth.  container resizerChanged-=JUAMPI=-displaySelectionInLine: line on: aCanvas  | leftX rightX w caretColor |  selectionStart ifNil: [ ^self ].  aCanvas isShadowDrawing ifTrue: [ ^self ].  selectionStart = selectionStop ifTrue: [ selectionStart textLine ~= line ifTrue: [ ^self ] ] ifFalse: [ (selectionStop stringIndex < line first or: [ selectionStart stringIndex > (line last + 1) ]) ifTrue: [ ^self ].        (selectionStop stringIndex = line first and: [ selectionStop textLine ~= line ]) ifTrue: [ ^self ].        (selectionStart stringIndex = (line last + 1) and: [ selectionStop textLine ~= line ]) ifTrue: [ ^self ] ].  leftX := (selectionStart stringIndex < line first ifTrue: [ line ] ifFalse: [ selectionStart ]) left.  rightX := (selectionStop stringIndex > (line last + 1) or: [ selectionStop stringIndex = (line last + 1) and: [ selectionStop textLine ~= line ] ]) ifTrue: [ line right ] ifFalse: [ selectionStop left ].  selectionStart = selectionStop ifTrue: [ rightX := rightX + 1.        w := self caretWidth.        caretRect := (leftX - w) @ line top corner: (rightX + w) @ line bottom.        self showCaret ifFalse: [ ^self ].        caretColor := self insertionPointColor.        1 to: w do: [:i |  aCanvas fillRectangle: ((leftX - w + i - 1) @ (line top + i - 1) extent: ((w - i) * 2 + 3) @ 1) color: caretColor.              aCanvas fillRectangle: ((leftX - w + i - 1) @ (line bottom - i) extent: ((w - i) * 2 + 3) @ 1) color: caretColor ].        aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom) color: caretColor ] ifFalse: [ caretRect := nil.        aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom) color: self selectionColor ]-=JUAMPI=-enabled: anObject  enabled := anObject.  self     cachedForm: nil;     changed-=JUAMPI=-ghostText  self subclassResponsibility-=JUAMPI=-toggle  self isExpanded ifTrue: [ self collapseAndRefresh ] ifFalse: [ self expandAndRefresh ]-=JUAMPI=-flashBounds  5 timesRepeat: [ Display flash: self boundsInWorld andWait: 120 ]-=JUAMPI=-handlesClickOrDrag: evt  ^(self existsSubscriptionsFor: #click) or: [ (self existsSubscriptionsFor: #doubleClick) or: [ self existsSubscriptionsFor: #startDrag ] ]-=JUAMPI=-newLabel  ^self theme checkboxLabelFor: self-=JUAMPI=-targetPoint  ^position - source targetOffset-=JUAMPI=-copyHandlerState: anEvent  -=JUAMPI=-table: aTable  table := aTable-=JUAMPI=-font: anObject  font := anObject.  self update: getLabelSelector-=JUAMPI=-wantsColumnBreaks: aBoolean  wantsColumnBreaks := aBoolean-=JUAMPI=-gripLayoutFrame  ^(0 @ 1 corner: 0 @ 1) asLayoutFrame     topOffset: self defaultHeight negated;     rightOffset: self defaultWidth-=JUAMPI=-testTransform  | lf rectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightOffset: -10;     bottomOffset: -10;     yourself.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 140 @ 60) equals: rectangle-=JUAMPI=-defaultColor  ^Color green lighter-=JUAMPI=-changePropotionalLayout  | layout |  ((layout := self layoutPolicy) notNil and: [ layout isProportionalLayout ]) ifTrue: [ ^self ].  self layoutPolicy: ProportionalLayout new.  self layoutChanged-=JUAMPI=-setGrabbedColor  self fillStyle: self theme fastTableColumnSplitterSelectedColor-=JUAMPI=-calculateVisibleRows  ^self calculateMaxVisibleRows min: self table numberOfRows-=JUAMPI=-newGroupbox: aString for: control  ^self theme newGroupboxIn: self label: aString for: control-=JUAMPI=-drawText: aStringOrText on: aCanvas in: aRectangle  ^self drawText: aStringOrText on: aCanvas in: aRectangle color: self stringColorToUse-=JUAMPI=-drawLinesOn: canvas  self selectedTab ifNotNil: [ self drawWithSelectionOn: canvas ] ifNil: [ self drawWithoutSelectedOn: canvas ]-=JUAMPI=-selectRow: index  selectedRows add: index.  self invalidRect: (self selectionFrameForRow: index)-=JUAMPI=-scrollBarColor  ^self paneColor-=JUAMPI=-flushLayoutCache  minExtentCache := nil-=JUAMPI=-colorFor: index  index odd ifTrue: [ ^Smalltalk ui theme lightBackgroundColor ].  ^Smalltalk ui theme backgroundColor-=JUAMPI=-finishedScrolling: event  self finishedScrolling.  (self containsPoint: event position) ifTrue: [ pagingArea           fillStyle: self mouseOverFillStyle;           borderStyle: self mouseOverBorderStyle ] ifFalse: [ pagingArea           fillStyle: self normalFillStyle;           borderStyle: self normalBorderStyle ].  (upButton containsPoint: event position) ifTrue: [ upButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: event position) ifTrue: [ upButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ upButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ].  (downButton containsPoint: event position) ifTrue: [ downButton           fillStyle: self mouseOverButtonFillStyle;           borderStyle: self mouseOverButtonBorderStyle ] ifFalse: [ (self containsPoint: event position) ifTrue: [ downButton                 fillStyle: self mouseOverPagingAreaButtonFillStyle;                 borderStyle: self mouseOverPagingAreaButtonBorderStyle ] ifFalse: [ downButton                 fillStyle: self normalButtonFillStyle;                 borderStyle: self normalButtonBorderStyle ] ]-=JUAMPI=-theme  ^Smalltalk ui theme-=JUAMPI=-mouseUp: evt  actWhen == #buttonUp ifFalse: [ ^super mouseUp: evt ].  (self containsPoint: evt cursorPoint) ifTrue: [ self state: #on.        self doButtonAction: evt ] ifFalse: [ self state: #off ]-=JUAMPI=-preferredKeyboardPosition  ^(self bounds: self bounds in: self currentWorld) topLeft-=JUAMPI=-indexFromPosition: aTuple  ^aTuple first-=JUAMPI=-initializeTable: aTable  table := aTable.  self initialize-=JUAMPI=-handleFocusEvent: anEvent  ^self handleEvent: anEvent-=JUAMPI=-rotationDegrees  ^0.0-=JUAMPI=-target: aMorph  self setTarget: aMorph.  target ifNotNil: [ self addHandles ]-=JUAMPI=-wantsDirectionHandles  ^false-=JUAMPI=-gridSpecPut: newSpec  ^self setProperty: #gridSpec toValue: newSpec-=JUAMPI=-wantsKeyboardFocusOnMouseDown  ^self wantsKeyboardFocus and: [ self valueOfProperty: #wantsKeyboardFocusOnMouseDown ifAbsent: [ false ] ]-=JUAMPI=-selectionBarColor  ^self theme selectionBarColor-=JUAMPI=-itemWithWording: wording  self items do: [:anItem |  | found |        found := anItem itemWithWording: wording.        found ifNotNil: [ ^found ] ].  ^nil-=JUAMPI=-compositionRectangle  ^container-=JUAMPI=-tasks: anObject  tasks := anObject-=JUAMPI=-inject: thisValue into: binaryBlock  | nextValue |  nextValue := thisValue.  self do: [:each |  nextValue := binaryBlock value: nextValue value: each ].  ^nextValue-=JUAMPI=-selectionIndex  ^self listMorph selectedRow ifNil: [ 0 ]-=JUAMPI=-positionModalOwner  self modalOwner ifNotNil: [:modalOwner |  (modalOwner isKindOf: SystemWindow) ifTrue: [ modalOwner bringBehind: self ] ]-=JUAMPI=-down: anObject  down := anObject.  self changed-=JUAMPI=-addNameBeneath: outerRectangle string: aString  | namePosition w |  w := self world ifNil: [ target world ].  nameMorph := StringMorph contents: aString font: StandardFonts haloFont.  nameMorph     wantsYellowButtonMenu: false;     color: self theme balloonTextColor;     backgroundColor: self theme balloonBackgroundColor;     target: innerTarget.  namePosition := outerRectangle bottomCenter - ((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).  nameMorph position: (namePosition min: w viewBox bottomRight - nameMorph extent y + 2).  self addMorph: nameMorph.  ^nameMorph-=JUAMPI=-acceptOnCR: trueOrFalse  acceptOnCR := trueOrFalse-=JUAMPI=-drawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self hasKeyboardFocus ifTrue: [ self drawKeyboardFocusOn: aCanvas ]-=JUAMPI=-initialize  super initialize.  self elements: #()-=JUAMPI=-table  ^table-=JUAMPI=-getChildren  ^dataSource childrenBlock isSymbol ifTrue: [ dataSource childrenBlock value: data ] ifFalse: [ dataSource childrenBlock cull: data cull: self ]-=JUAMPI=-setType: aSymbol  type := aSymbol-=JUAMPI=-getIconSelector: anObject  getIconSelector := anObject-=JUAMPI=-takesKeyboardFocus  ^true-=JUAMPI=-addItemShowing: aString from: startNumber to: endNumber  lock critical: [ | item items |        item := SystemProgressItemMorph labeled: aString from: startNumber to: endNumber.        items := self bars size.        items < 10 ifTrue: [ self addMorphBack: item.              self recenter ].        ^item ]-=JUAMPI=-wantsStepsWhenCollapsed  ^false-=JUAMPI=-updateTasks  | tasksThatShouldBeUpdated |  tasksThatShouldBeUpdated := windows collect: [:window |  self newTaskFor: window ].  self updateOrderedTasksFrom: tasksThatShouldBeUpdated-=JUAMPI=-lineWidth: anInteger  self borderWidth: (anInteger rounded max: 1)-=JUAMPI=-scrollUpInit  | bc |  bc := upButton borderStyle baseColor.  upButton borderInset.  upButton borderStyle baseColor: bc.  self resetTimer.  self scrollBarAction: #doScrollUp.  self doScrollUp.  self startStepping: #stepAt: at: Time millisecondClockValue + self stepTime arguments: nil stepTime: nil.  upButton fillStyle: self pressedButtonFillStyle.  upButton borderStyle: self pressedButtonBorderStyle-=JUAMPI=-action  self inform: 'Button pressed'-=JUAMPI=-changeMinCellSize: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self minCellSize: (newPoint - evt cursorPoint) asIntegerPoint ].  evt hand attachMorph: handle.  handle startStepping-=JUAMPI=-beIconRight  iconPosition := #right.  self update: getIconSelector-=JUAMPI=-on: anObject color: getColSel  self     model: anObject;     getColorSelector: getColSel;     updateColor-=JUAMPI=-getChildrenSelector  ^getChildrenSelector-=JUAMPI=-indexForRow: aRowIndex  ^{aRowIndex .   self table selectedIndex second}-=JUAMPI=-newLocationMorph  ^ImageMorph new form: Cursor crossHair withMask asCursorForm-=JUAMPI=-defaultColor  ^self theme menuSelectionColor alpha: 0.08-=JUAMPI=-cellColumn: column row: rowIndex  column id = 'Icon' ifTrue: [ ^self iconColumn: column row: rowIndex ].  column id = 'Name' ifTrue: [ ^self nameColumn: column row: rowIndex ].  column id = 'Number of methods' ifTrue: [ ^self numberOfMethodsColumn: column row: rowIndex ].  column id = 'Number of instance variables' ifTrue: [ ^self numberOfInstanceVariablesColumn: column row: rowIndex ].  self error: 'Invalid column'-=JUAMPI=-indentingItemClass  ^MorphTreeNodeMorph-=JUAMPI=-hasTableLayoutString  | layout |  ^((layout := self layoutPolicy) notNil and: [ layout isTableLayout ]) -> 'table layout' translated-=JUAMPI=-wantsExpandBox  ^true-=JUAMPI=-deriveHScrollRange  | unadjustedRange totalRange |  (list isNil or: [ list isEmpty ]) ifTrue: [ hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0 ] ifFalse: [ unadjustedRange := self listMorph hUnadjustedScrollRange.        totalRange := unadjustedRange + self hExtraScrollRange + self hMargin.        hScrollRangeCache := Array with: totalRange with: unadjustedRange with: list size with: list first with: list last ]-=JUAMPI=-headerColumn: column  ^self basicHeaderCellFor: column-=JUAMPI=-setIndexSelector: aSelector  setIndexSelector := aSelector-=JUAMPI=-windowEventHandler: anObject  WindowEventHandler := anObject-=JUAMPI=-initialExtent  ^(self model respondsTo: #initialExtent) ifTrue: [ self model initialExtent ] ifFalse: [ RealEstateAgent standardWindowExtent ]-=JUAMPI=-ownerChanged  super ownerChanged.  self updateLayoutInDockingBar-=JUAMPI=-newOKButton  ^self newOKButtonFor: self-=JUAMPI=-currentlyExpanded  ^(scroller submorphs select: [:each |  each isExpanded ]) collect: [:each |  each complexContents ]-=JUAMPI=-acquireBorderWidth: aBorderWidth  | delta |  (delta := aBorderWidth - self borderWidth) = 0 ifTrue: [ ^self ].  self bounds: (self bounds origin - (delta @ delta) corner: self bounds corner + (delta @ delta)).  self borderWidth: aBorderWidth.  self layoutChanged-=JUAMPI=-allSiblingItems  | menus str index |  str := (Array new: 40) writeStream.  menus := self owner submorphs select: [:m |  m isKindOf: self class ].  menus := (menus copyFrom: (index := menus indexOf: self) to: menus size) , (menus copyFrom: 1 to: index - 1).  menus do: [:menu |  str nextPutAll: menu items ].  ^str contents-=JUAMPI=-userString  ^nil-=JUAMPI=-visible: newValue  visible := newValue-=JUAMPI=-target: aMorph  -=JUAMPI=-headerButtonLabel: aLabel icon: anIconForm  self headerButtonLabel: aLabel font: nil.  self header cellInset: 3 @ 0.  self header icon: (ImageMorph new form: anIconForm)-=JUAMPI=-newLabel  | lbl |  lbl := self theme buttonLabelFor: self.  font ifNotNil: [ lbl font: font.        lbl extent: lbl optimalExtent ].  ^lbl-=JUAMPI=-arguments  ^arguments-=JUAMPI=-handlesMouseDown: event  ^true-=JUAMPI=-getListSelector: sel  getListSelector := sel.  self changed.  self updateList-=JUAMPI=-basicBorderWidth: aNumber  borderWidth := aNumber-=JUAMPI=-doGrow: evt with: growHandle  | newExtent extentToUse scale |  evt hand obtainHalo: self.  newExtent := (target pointFromWorld: evt cursorPoint - positionOffset) - target topLeft.  evt shiftPressed ifTrue: [ scale := newExtent x / (originalExtent x max: 1) min: newExtent y / (originalExtent y max: 1).        newExtent := (originalExtent x * scale) asInteger @ (originalExtent y * scale) asInteger ].  (newExtent x < 1 or: [ newExtent y < 1 ]) ifTrue: [ ^self ].  target renderedMorph extent: (extentToUse := newExtent).  growHandle position: evt cursorPoint - (growHandle extent // 2).  self layoutChanged-=JUAMPI=-focusBounds  ^self theme buttonFocusBoundsFor: self-=JUAMPI=-isMouseOver  ^self type == #mouseOver-=JUAMPI=-getCurrentSelectionIndex  getIndexSelector ifNil: [ ^0 ].  ^model perform: getIndexSelector-=JUAMPI=-restoreAndActivate  self isMinimized ifTrue: [ self restore ].  self isActive ifFalse: [ self activate ]-=JUAMPI=-removeFlexShell  | oldHalo unflexed myWorld refPos aPosition |  refPos := self referencePosition.  myWorld := self world.  oldHalo := self halo.  submorphs isEmpty ifTrue: [ ^self delete ].  aPosition := (owner submorphIndexOf: self) ifNil: [ 1 ].  unflexed := self firstSubmorph.  self submorphs do: [:m |  m position: self center - (m extent // 2).        owner addMorph: m asElementNumber: aPosition ].  oldHalo ifNotNil: [ oldHalo setTarget: unflexed ].  myWorld ifNotNil: [ myWorld startSteppingSubmorphsOf: unflexed ].  self delete.  unflexed referencePosition: refPos.  ^unflexed-=JUAMPI=-selectionColor  ^selectionColor-=JUAMPI=-includesTableProperties  ^true-=JUAMPI=-newBracketSliderFor: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newBracketSliderIn: self for: aModel getValue: getSel setValue: setSel min: minValue max: maxValue quantum: quantum getEnabled: enabledSel help: helpText-=JUAMPI=-needSeparatorBefore: index  | tmpIndex |  index <= 1 ifTrue: [ ^false ].  tmpIndex := index.  self items do: [:elements |  elements size >= tmpIndex ifTrue: [ ^tmpIndex = 1 ] ifFalse: [ tmpIndex := tmpIndex - elements size ] ].  self errorSubscriptBounds: index-=JUAMPI=-drawBackgroundOnAthensCanvas: anAthensCanvas  (isSelected and: [ isEnabled ]) ifFalse: [ ^self ].  anAthensCanvas setPaint: self selectionFillStyle.  anAthensCanvas drawShape: (0 @ 0 extent: self extent)-=JUAMPI=-lastKeystroke: aString  ^self setProperty: #lastKeystroke toValue: aString-=JUAMPI=-lastColumnBounded  ^self lastColumnUnbounded not-=JUAMPI=-selection  ^editor ifNotNil: [ editor selection ]-=JUAMPI=-actions  ^actions-=JUAMPI=-drawOn: aCanvas  aCanvas fillOval: bounds fillStyle: self fillStyle borderWidth: borderWidth borderColor: borderColor-=JUAMPI=-selfOrChildAt: anIndex  ^anIndex = 1 ifTrue: [ self ] ifFalse: [ self childAt: anIndex - 1 ]-=JUAMPI=-setMultipleContents  | tabs size delta |  contentsWrapper removeAllMorphs.  self cleanProcesses.  tabs := toolbar orderedSelectedTabs.  size := tabs size.  delta := 1 / size.  tabs allButLast keysAndValuesDo: [:index :tab |  self addTabContents: tab at: index delta: delta ].  self addLastTabContents: tabs last among: size delta: delta.  self addSplitterOn: tabs delta: delta-=JUAMPI=-drawSubMorphOn: aCanvas  | morphBounds |  morphBounds := self bounds insetBy: (self cornerRadius + 3) @ (self topInactiveGap // 2 + 2).  morphBounds := morphBounds translateBy: 0 @ (self topInactiveGap // 2 + 1).  self active ifTrue: [ morphBounds := morphBounds translateBy: 0 @ (self topInactiveGap // 2 + 1) negated ].  self subMorph bounds height < morphBounds height ifTrue: [ morphBounds := morphBounds insetBy: 0 @ ((morphBounds height - self subMorph bounds height) // 2) ].  self subMorph bounds width < morphBounds width ifTrue: [ morphBounds := morphBounds insetBy: ((morphBounds width - self subMorph bounds width) // 2) @ 0 ].  self subMorph bounds: morphBounds.  aCanvas drawMorph: self subMorph-=JUAMPI=-defaultGraphics  ^DefaultGraphics-=JUAMPI=-bringBehind: aMorph  | outerMorph |  outerMorph := self topRendererOrSelf.  outerMorph owner ifNil: [ ^self ].  outerMorph owner addMorph: outerMorph after: aMorph topRendererOrSelf.  self modalOwner ifNotNil: [:mo |  mo bringBehind: self ]-=JUAMPI=-checkMorphsRightOrBottomFrom: splitter  | index |  index := submorphs identityIndexOf: splitter.  index := index - 1.  [ index > 0 ] whileTrue: [ | submorph done |        submorph := submorphs at: index.        splitter addRightOrBottom: submorph.        done := self isResizeableMorph: submorph forSplitter: splitter.        done ifTrue: [ index := 0 ].        index := index - 1 ]-=JUAMPI=-controlKeyPressed  ^buttons anyMask: 2r00010000-=JUAMPI=-prepareForRotating  ^self addFlexShell-=JUAMPI=-addFlexShell  | oldHalo flexMorph myWorld anIndex |  myWorld := self world.  oldHalo := self halo.  anIndex := self owner submorphIndexOf: self.  self owner addMorph: (flexMorph := self newTransformationMorph asFlexOf: self) asElementNumber: anIndex.  self transferStateToRenderer: flexMorph.  oldHalo ifNotNil: [ oldHalo setTarget: flexMorph ].  myWorld ifNotNil: [ myWorld startSteppingSubmorphsOf: flexMorph ].  ^flexMorph-=JUAMPI=-handlesMouseOverDragging: evt  ^self dropEnabled-=JUAMPI=-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-=JUAMPI=-mouseLeaveDragging: event  (self dropEnabled and: [ event hand hasSubmorphs ]) ifFalse: [ ^super mouseLeaveDragging: event ].  self basicHighlightIndexes: #().  self refresh-=JUAMPI=-handleKeystroke: aKeystrokeEvent inMorph: aMorph  -=JUAMPI=-wrapOnOff  self wrapFlag: wrapFlag not-=JUAMPI=-pressedBorderStyle  ^self theme controlButtonPressedBorderStyleFor: self-=JUAMPI=-aMorph  ^aMorph-=JUAMPI=-newSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText-=JUAMPI=-splitterRight  | splitters |  splitters := (self siblingSplitters select: [:each |  each left > self left and: [ self overlapsVertical: each ] ]) asSortedCollection: [:a :b |  a left < b left ].  ^splitters ifEmpty: [ nil ] ifNotEmpty: [:s |  s first ]-=JUAMPI=-listSpacing: aSymbol  self assureTableProperties listSpacing: aSymbol.  self layoutChanged-=JUAMPI=-onImage  | form |  form := Form extent: (self fontToUse ascent - 2) asPoint depth: 16.  form getCanvas     frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) borderWidth: 1 borderColor: Color black;     fillRectangle: (form boundingBox insetBy: 2) fillStyle: Color black.  ^form-=JUAMPI=-expandItem  expanded := true.  children := (dataSource childrenFor: item) collect: [:each |  self treeItemFor: each ].  dataSource updateAvailableRows: self availableRows - 1-=JUAMPI=-fillWithRamp: rampSpecsOrColor oriented: aRatio  rampSpecsOrColor isColor ifTrue: [ self color: rampSpecsOrColor ] ifFalse: [ | fill |        fill := GradientFillStyle ramp: rampSpecsOrColor.        fill origin: self bounds topLeft.        fill direction: (self bounds extent * aRatio) truncated.        fill radial: false.        self fillStyle: fill.        self borderColor: (rampSpecsOrColor first value mixed: 0.5 with: rampSpecsOrColor last value) muchDarker ]-=JUAMPI=-adjustToHorizontalScrollBarValue: aNumber  | newStartColumnIndex |  newStartColumnIndex := (self table numberOfColumns * aNumber) rounded min: self table numberOfColumns max: 1.  newStartColumnIndex ~= self startColumnIndex ifTrue: [ self startColumnIndex: newStartColumnIndex.        self changed ]-=JUAMPI=-testUpdateEmptyTaskBarWithNewWindow  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: taskbar tasks size equals: 1-=JUAMPI=-iconOrThumbnailOfSize: aNumberOrPoint  ^self iconOrThumbnail scaledIntoFormOfSize: aNumberOrPoint-=JUAMPI=-handlesKeyboard: evt  ^true-=JUAMPI=-newFuzzyLabel: aString  ^self theme newFuzzyLabelIn: self for: nil label: aString offset: 1 alpha: 0.5 getEnabled: nil-=JUAMPI=-matches: aString  self subclassResponsibility-=JUAMPI=-debug  [ builder menuSpec asMenuMorph ] ensure: [ builder reset ]-=JUAMPI=-world  ^world-=JUAMPI=-mouseFocus: aMorphOrNil  mouseFocus := aMorphOrNil-=JUAMPI=-mouseEnter: anEvent  self canResizeColumn ifFalse: [ ^self ].  (owner notNil and: [ owner bounds containsPoint: anEvent position ]) ifTrue: [ super mouseEnter: anEvent ]-=JUAMPI=-verticesAt: ix put: newPoint  vertices at: ix put: newPoint.  self computeBounds-=JUAMPI=-newAColorMorph  ^AColorSelectorMorph new     model: self;     hResizing: #spaceFill;     vResizing: #rigid;     setValueSelector: #alphaSelected:;     extent: 24 @ 24-=JUAMPI=-vShowScrollBar  self vIsScrollbarShowing ifTrue: [ ^self ].  self vResizeScrollBar.  self privateAddMorph: scrollBar atIndex: 1.  self resetExtent-=JUAMPI=-menu: menu shifted: b  super menu: menu shifted: b.  menu addLine.  self selectedNode ifNotNil: [:current |  current menu: menu shifted: b.        menu addLine.        menu add: 'Expand all from here' target: self selector: #expandAllFromNode: argument: current ].  ^menu-=JUAMPI=-mouseUp: event  needToggleAtMouseUp ifFalse: [ ^self ].  (self selectionModeStrategy selectableIndexContainingPoint: event cursorPoint) ifNotNil: [:index |  self selectIndex: index event: event ].  needToggleAtMouseUp := false-=JUAMPI=-event  ^event-=JUAMPI=-userString  ^list ifNotNil: [ String streamContents: [:strm |  list do: [:i |  strm                       nextPutAll: i string;                       cr ] ] ]-=JUAMPI=-layoutProperties  ^extension ifNotNil: [ extension layoutProperties ]-=JUAMPI=-modifiedCharacter  self flag: #hack.  ^(self hasSpecialCTRLKeyValue and: [ #(MacOSX Windows) includes: Smalltalk os platformFamily ]) ifTrue: [ (self keyValue + $a asciiValue - 1) asCharacter ] ifFalse: [ Smalltalk os isWindows ifTrue: [ self keyCharacter asLowercase ] ifFalse: [ self keyCharacter ] ]-=JUAMPI=-newGroupboxFor: control  ^self theme newGroupboxIn: self for: control-=JUAMPI=-openInWindowLabeled: aString inWorld: aWorld  self layoutInset: 0.  ^super openInWindowLabeled: aString inWorld: aWorld-=JUAMPI=-isAutoFit  ^false-=JUAMPI=-removeWindow: aMorph  windows remove: aMorph-=JUAMPI=-useSecondarySelection  ^false-=JUAMPI=-mouseEnter: evt  super mouseEnter: evt.  self over: true-=JUAMPI=-selectAll  self isMultipleSelection ifFalse: [ ^self ].  1 to: self maximumSelection do: [:i |  self listSelectionAt: i put: true ]-=JUAMPI=-getListSelector  ^getListSelector-=JUAMPI=-basicBorderColor: aColor  borderColor := aColor-=JUAMPI=-newAutoAcceptTextEntryFor: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: aClass getEnabled: enabledSel font: aFont help: helpText-=JUAMPI=-view: aViewOrMorph  -=JUAMPI=-defaultButton  ^IconicButton new     target: self;     color: Color transparent;     borderWidth: 0;     yourself-=JUAMPI=-selectedIndex  ^self selectedIndexes ifNotEmpty: #first ifEmpty: [ self selectionModeStrategy nullIndex ]-=JUAMPI=-negateBottomRightOffsets  bottomOffset := bottomOffset negated.  rightOffset := rightOffset negated-=JUAMPI=-keyStroke: anEvent  ^false-=JUAMPI=-mouseLeaveDragging: evt  super mouseLeaveDragging: evt.  self over: false-=JUAMPI=-assureExtension  extension ifNil: [ self initializeExtension ].  ^extension-=JUAMPI=-vSetScrollDelta  | range delta |  scroller hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  delta := self scrollDeltaHeight.  range := self vLeftoverScrollRange.  range = 0 ifTrue: [ ^scrollBar           scrollDelta: 0.02 pageDelta: 0.2;           interval: 1.0;           setValue: 0 ].  scrollBar scrollDelta: (delta / range) asFloat pageDelta: ((self innerBounds height - delta) / range) asFloat.  scrollBar interval: (self innerBounds height / self vTotalScrollRange) asFloat.  scrollBar setValue: (scroller offset y / range min: 1.0) asFloat-=JUAMPI=-passenger: anObject  passenger := anObject-=JUAMPI=-paneWithLongestSide: sideBlock near: aPoint  | thePane theSide theLen |  theLen := 0.  paneMorphs do: [:pane |  | box |        box := pane bounds.        box forPoint: aPoint closestSideDistLen: [:side :dist :len |  (dist <= 5 and: [ len > theLen ]) ifTrue: [ thePane := pane.                    theSide := side.                    theLen := len ] ] ].  sideBlock value: theSide.  ^thePane-=JUAMPI=-emptySelection  self selectedMorphList do: [:n |  n           unhighlight;           setSelectedSilently: false ].  self selectedMorphList removeAll.  self selectionChanged-=JUAMPI=-hasUnacceptedEdits: aBoolean  -=JUAMPI=-toggleEnabled  self enabled: self enabled not-=JUAMPI=-newSeparator  ^self theme newSeparatorIn: self-=JUAMPI=-leftArrowStroked: evt  popUpOwner ifNil: [ ^self ].  ^self deselectAndFocusOutermenuOn: evt-=JUAMPI=-unsort  self unsortElements.  self table refresh-=JUAMPI=-nextState  ^FTDescendingSortingState context: self context-=JUAMPI=-getLabelSelector  ^getLabelSelector-=JUAMPI=-enabled: anObject  enabled = anObject ifTrue: [ ^self ].  enabled := anObject.  self changed: #enabled.  self     adoptPaneColor: self paneColor;     changed-=JUAMPI=-currentCursor  ^ActiveHand world currentCursor-=JUAMPI=-imageFromName: aSymbol  ^self images at: aSymbol ifPresent: [:block |  block value ] ifAbsent: [  ]-=JUAMPI=-isClosed  ^closed-=JUAMPI=-topLeftColor  ^width = 1 ifTrue: [ self color twiceLighter ] ifFalse: [ self color lighter ]-=JUAMPI=-displayWorld  worldState displayWorld: self submorphs: submorphs-=JUAMPI=-findDeepSubmorphThat: block1 ifAbsent: block2  self allMorphsDo: [:m |  (block1 value: m) == true ifTrue: [ ^m ] ].  ^block2 value-=JUAMPI=-selected  ^state selected-=JUAMPI=-addToggleItemsToHaloMenu: aCustomMenu  super addToggleItemsToHaloMenu: aCustomMenu.  aCustomMenu addUpdating: #enabledString target: self selector: #toggleEnabled-=JUAMPI=-defaultColor  ^Color white-=JUAMPI=-isRight  ^direction = Character arrowRight-=JUAMPI=-formerPosition  ^self valueOfProperty: #formerPosition-=JUAMPI=-initialize  super initialize.  hasFocus := false.  self initializeScrollBars.  self extent: self defaultExtent.  self hideOrShowScrollBars-=JUAMPI=-addHandleAt: aPoint color: aColor icon: iconName on: eventName send: selector to: recipient  | handle |  handle := self createHandleAt: aPoint color: aColor iconName: iconName.  self addMorph: handle.  handle on: #mouseUp send: #endInteraction to: self.  handle on: eventName send: selector to: recipient.  handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.  ^handle-=JUAMPI=-steppingMorphsNotInWorld  | all |  all := self allMorphs.  ^self listOfSteppingMorphs reject: [:m |  all includes: m ]-=JUAMPI=-enableFilter  function := FTFilterFunction table: self-=JUAMPI=-selectPreviousTab  self selectedIndex: (self selectedIndex < 2 ifTrue: [ self tabs size ] ifFalse: [ self selectedIndex - 1 ])-=JUAMPI=-wantsYellowButtonMenu  self valueOfProperty: #wantsYellowButtonMenu ifPresentDo: [:value |  ^value ].  self isInSystemWindow ifTrue: [ ^false ].  ^self defaultYellowButtonMenuEnabled-=JUAMPI=-model  ^nil-=JUAMPI=-on: eventName send: selector to: recipient withValue: value  selector numArgs = 3 ifFalse: [ self error: 'Warning: value parameters are passed as first of 3 arguments' ].  self addSubscription: (MorphEventSubscription on: eventName send: selector to: recipient withValue: value) toEvent: eventName-=JUAMPI=-truncatedMenuLabelFor: aWindowLabel  ^aWindowLabel truncateWithElipsisTo: 47-=JUAMPI=-selectedNodePathList: aCollectionOfPath  selectedNodePathList := aCollectionOfPath-=JUAMPI=-newBalloonHelp: aTextStringOrMorph for: aMorph  ^self theme newBalloonHelpIn: self contents: aTextStringOrMorph for: aMorph corner: #bottomLeft-=JUAMPI=-unshiftedYellowButtonActivity  ^self yellowButtonActivity: false-=JUAMPI=-keyStroke: evt  | keyValue |  owner isHandMorph ifFalse: [ ^self ].  keyValue := evt keyValue.  keyValue = 28 ifTrue: [ ^self position: self position - (1 @ 0) ].  keyValue = 29 ifTrue: [ ^self position: self position + (1 @ 0) ].  keyValue = 30 ifTrue: [ ^self position: self position - (0 @ 1) ].  keyValue = 31 ifTrue: [ ^self position: self position + (0 @ 1) ].  keyValue = 13 ifTrue: [ owner releaseKeyboardFocus: self.        self delete ]-=JUAMPI=-testSelectLast  table selectLast.  self assert: table selectedIndexes equals: #(10)-=JUAMPI=-selectIndexes: anArray andMakeVisibleIf: shouldEnsureVisibleSelection  | oldSelectedIndexes |  anArray = self selectedIndexes ifTrue: [ ^self ].  oldSelectedIndexes := self selectedIndexes.  self basicSelectIndexes: anArray.  shouldEnsureVisibleSelection ifTrue: [ self ensureVisibleFirstSelection ].  self refresh.  self doAnnounce: ((FTSelectionChanged from: oldSelectedIndexes to: self selectedIndexes)           fastTable: self;           yourself)-=JUAMPI=-privateFullMoveBy: delta  self privateMoveBy: delta.  submorphs do: [:each |  each privateFullMoveBy: delta ]-=JUAMPI=-updateImage  (self model notNil and: [ self getImageSelector notNil ]) ifTrue: [ (self model perform: self getImageSelector) ifNotNil: [:i |  self image: i ] ]-=JUAMPI=-createExpandBox  ^self theme createExpandBoxFor: self-=JUAMPI=-spotterWindowsFor: aStep  < spotterOrder: 100>  aStep listProcessor     title: 'Windows';     allCandidates: [ self class allSubInstances ];     itemName: [:window |  '**' , window label , '**' ];     filter: GTFilterSubstring-=JUAMPI=-vHideOrShowScrollBar  self vIsScrollbarNeeded ifTrue: [ self vShowScrollBar ] ifFalse: [ self vHideScrollBar ]-=JUAMPI=-children  | children |  children := OrderedCollection new.  self childrenDo: [:each |  children add: each ].  ^children-=JUAMPI=-keyStroke: event  (super keyStroke: event) ifTrue: [ ^true ].  self keystrokeSelector ifNotNil: [ (self keyStrokeAction: event) ifTrue: [ ^true ] ].  (self keystrokeActionSelector notNil and: [ event anyModifierKeyPressed ]) ifTrue: [ (self keyStrokeModifierAction: event) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-cachedForm  | form i effectiveAlpha |  cachedForm ifNil: [ i := self scaledImage.        effectiveAlpha := self enabled ifTrue: [ self alpha ] ifFalse: [ self alpha / 2 ].        effectiveAlpha = 1.0 ifTrue: [ self cachedForm: i ] ifFalse: [ form := Form extent: i extent depth: 32.              form fillColor: (Color white alpha: 0.003922).              (form getCanvas asAlphaBlendingCanvas: effectiveAlpha) drawImage: i at: 0 @ 0.              self cachedForm: form ] ].  ^cachedForm-=JUAMPI=-newColumn: controls  ^self theme newColumnIn: self for: controls-=JUAMPI=-reversedSelectedTabs  ^selectionHistory last: numberOfSelectedTabs-=JUAMPI=-openInExternalWindow  | world |  world := OSWindowWorldMorph new extent: self fullBounds extent.  world     layoutPolicy: ProportionalLayout new;     clipSubmorphs: true.  self     hResizing: #spaceFill;     vResizing: #spaceFill.  self openInWorld: world.  self onAnnouncement: MorphDeleted do: [:announce |  world ifNotNil: [ world delete ].        world := nil ].  ^world open-=JUAMPI=-removePendingBalloonFor: aMorph  self removeAlarm: #spawnBalloonFor:.  self deleteBalloonTarget: aMorph-=JUAMPI=-expandAllSuchThat: aBlock  self roots do: [:m |  self expand: m suchThat: aBlock ].  self innerWidgetChanged-=JUAMPI=-setSwitchState: aBoolean  aBoolean ifTrue: [ self turnOn ] ifFalse: [ self turnOff ]-=JUAMPI=-tabKey: event  event controlKeyPressed ifFalse: [ event keyCharacter = Character tab ifTrue: [ event shiftPressed ifTrue: [ self navigateFocusBackward ] ifFalse: [ self navigateFocusForward ].              ^true ] ].  ^false-=JUAMPI=-newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel  ^self newTextEditorFor: aModel getText: getSel setText: setSel getEnabled: enabledSel menu: nil-=JUAMPI=-alpha: anObject  alpha := anObject.  self changed-=JUAMPI=-hue: anInteger  | c |  c := self selectedColor.  self selectedColor: ((Color h: (anInteger / 255 * 359) rounded s: c saturation v: c brightness) alpha: c alpha)-=JUAMPI=-testIndexesToSelectInMultipleSelectionFromTo  self subclassResponsibility-=JUAMPI=-borderWidth: anInteger  borderColor ifNil: [ borderColor := Color black ].  borderWidth := anInteger max: 0.  self computeBounds-=JUAMPI=-getEnabledSelector: anObject  getEnabledSelector := anObject.  self updateEnabled-=JUAMPI=-submorphBounds  | box |  submorphs do: [:m |  | subBox |        m visible ifTrue: [ subBox := m fullBounds.              box ifNil: [ box := subBox copy ] ifNotNil: [ box := box quickMerge: subBox ] ] ].  box ifNil: [ ^self bounds ].  ^box origin asIntegerPoint corner: box corner asIntegerPoint-=JUAMPI=-isPartialMatch  ^self complexContents isPartialMatch-=JUAMPI=-dropItemSelector: aSelector  self dataSource dropItemSelector: aSelector-=JUAMPI=-onWindowLabelChanged: ann  self tabGroup relabelPage: ann window with: (self tabLabelFor: ann window)-=JUAMPI=-potentialDropMorph: anObject  potentialDropMorph := anObject-=JUAMPI=-activateCursor: aCursor withMask: maskForm  -=JUAMPI=-imageExport  ^self form bits asArray-=JUAMPI=-maximumSelection  ^scroller submorphs size-=JUAMPI=-vanishAfterSlidingTo: aPosition event: evt  | aForm aWorld startPoint endPoint |  aForm := self imageForm offset: 0 @ 0.  aWorld := self world.  startPoint := evt hand fullBounds origin.  self delete.  aWorld displayWorld.  endPoint := aPosition.  aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15-=JUAMPI=-yellowButtonPressed  ^buttons anyMask: self class yellowButton-=JUAMPI=-drawOn: aCanvas  super drawOn: aCanvas.  (ActiveHand notNil and: [ ActiveHand keyboardFocus == self and: [ self rootMenu hasProperty: #hasUsedKeyboard ] ]) ifTrue: [ aCanvas frameAndFillRectangle: self innerBounds fillColor: Color transparent borderWidth: self theme menuBorderWidth borderColor: self theme menuKeyboardFocusColor ]-=JUAMPI=-maximumSelection  ^self getListSize-=JUAMPI=-newMenu  ^self theme newMenuIn: self for: self-=JUAMPI=-selectFirst  self table selectIndex: #(1 1)-=JUAMPI=-gridOrigin: newOrigin  ^self gridSpecPut: (newOrigin extent: self gridModulus)-=JUAMPI=-borderColor: aColor  super borderColor: aColor.  (borderColor isColor and: [ borderColor isTranslucentButNotTransparent ]) == (aColor isColor and: [ aColor isTranslucentButNotTransparent ]) ifFalse: [ self releaseCachedState ]-=JUAMPI=-is: anIndex bellowRow: aRowIndex  ^anIndex > aRowIndex-=JUAMPI=-hResizeScrollBar  super hResizeScrollBar.  hScrollBar bounds: ((hScrollBar bounds withTop: hScrollBar top - self pagerHeight) withBottom: hScrollBar bottom - self pagerHeight)-=JUAMPI=-taskbarButtonMenu: aMenu  | menu theme submenu |  theme := self theme.  menu := theme newMenuIn: self for: self.  menu addToggle: 'Restore' translated target: self selector: #restore getStateSelector: nil enablementSelector: #isNotRestored.  menu lastItem     icon: self theme windowMaximizeForm;     font: theme menuFont.  menu addToggle: 'Minimize' translated target: self selector: #minimize getStateSelector: nil enablementSelector: #isNotMinimized.  menu lastItem     icon: self theme windowMinimizeForm;     font: theme menuFont.  menu addToggle: 'Maximize' translated target: self selector: #maximize getStateSelector: nil enablementSelector: #canBeMaximized.  menu lastItem     icon: self theme windowMaximizeForm;     font: theme menuFont.  menu addLine.  submenu := theme newMenuIn: self for: self.  menu add: 'Close all' icon: self theme windowCloseForm subMenu: submenu.  submenu addToggle: 'windows to right' translated target: self selector: #taskbarCloseAllToRight getStateSelector: nil enablementSelector: true.  submenu addToggle: 'windows like this' translated target: self selector: #taskbarCloseAllLikeThis getStateSelector: nil enablementSelector: true.  submenu addToggle: 'unchanged windows' translated target: self currentWorld selector: #closeAllUnchangedWindows getStateSelector: nil enablementSelector: true.  submenu addToggle: 'close all debuggers' translated target: Smalltalk tools debugger selector: #closeAllDebuggers getStateSelector: nil enablementSelector: true.  menu addToggle: 'Close' translated target: self selector: #closeBoxHit getStateSelector: nil enablementSelector: #allowedToClose.  menu lastItem     icon: self theme windowCloseForm;     font: theme menuFont.  ^menu-=JUAMPI=-couldHaveRoundedCorners  ^false-=JUAMPI=-font: aFont  self labelMorph font: aFont-=JUAMPI=-cellInset  ^0-=JUAMPI=-normalFillStyle  ^self theme splitterNormalFillStyleFor: self-=JUAMPI=-tearDown  morph delete.  super tearDown-=JUAMPI=-drawOnAthensCanvas: anAthensCanvas  self getListSize = 0 ifTrue: [ ^self ].  self setColumnWidthsFor: anAthensCanvas.  self adjustWidth.  super drawOnAthensCanvas: anAthensCanvas-=JUAMPI=-newHatchMorph  ^Morph new     color: Color transparent;     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     minWidth: 48;     minHeight: 12;     addMorph: (Morph new color: Color white) fullFrame: (0 @ 0 corner: 0.3 @ 1) asLayoutFrame;     addMorph: (Morph new fillStyle: (InfiniteForm with: self hatchForm)) fullFrame: (0.3 @ 0 corner: 0.7 @ 1) asLayoutFrame;     addMorph: self solidLabelMorph fullFrame: (0.7 @ 0 corner: 1 @ 1) asLayoutFrame;     addMorph: self labelMorph fullFrame: (0 @ 0 corner: 1 @ 1) asLayoutFrame-=JUAMPI=-dismissMorph  | w |  w := self world ifNil: [ ^self ].  w stopStepping: self.  self delete-=JUAMPI=-extent: newExtent  self adjustAfter: [ | scaleFactor |        scaleFactor := self scale * newExtent r / self fullBounds extent r max: 0.1.        self scale: (scaleFactor detentBy: 0.1 atMultiplesOf: 1.0 snap: false) ]-=JUAMPI=-defaultImageFormOfSize: aPoint  ^(defaultImageForm isNil or: [ defaultImageForm extent ~= aPoint ]) ifTrue: [ defaultImageForm := Form extent: aPoint ] ifFalse: [ defaultImageForm ]-=JUAMPI=-sliderThickness  ^7-=JUAMPI=-testHeading  | t |  cases := {(t := TransformationMorph new openCenteredInWorld)}.  self shouldntTakeLong: [ [ self assert: t heading equals: 0.0 ] ensure: [ t delete ] ]-=JUAMPI=-setListFont  StandardFonts chooseFontWithTitle: 'Choose the font for this list' translated for: self setSelector: #font: getSelector: #font-=JUAMPI=-menuColumn: column row: rowIndex  | menu |  self getMenuSelector ifNil: [ ^nil ].  menu := UIManager default newMenuIn: self table for: self model.  self getMenuSelector numArgs = 1 ifTrue: [ ^self model perform: self getMenuSelector with: menu ].  ^self model perform: self getMenuSelector with: menu with: false-=JUAMPI=-clipboardText: aString  ^self osWindow clipboardText: aString-=JUAMPI=-newHColorMorph  ^HColorSelectorMorph new     model: self;     setValueSelector: #hue:;     hResizing: #rigid;     vResizing: #spaceFill;     extent: 36 @ 36-=JUAMPI=-getListElementSelector  ^self dataSource getListElementSelector-=JUAMPI=-minWidth  | noVPlease noHPlease minW |  noVPlease := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  noHPlease := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  minW := noVPlease ifTrue: [ noHPlease ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness * 3 ] ] ifFalse: [ noHPlease ifTrue: [ self scrollBarThickness + 20 ] ifFalse: [ self scrollBarThickness * 3 + 2 ] ].  ^minW max: super minWidth-=JUAMPI=-requestDropReference: i  | fileName |  fileNames ifNil: [ ^FileReference requestDropReference: i ].  fileName := self fileNames at: i.  ^(FilePathEncoder decode: fileName) asFileReference-=JUAMPI=-explicitFunction  function showWidget-=JUAMPI=-outerBounds  ^self bounds-=JUAMPI=-cellPositioning: aSymbol  cellPositioning := aSymbol-=JUAMPI=-actionOffset  ^4 * self displayScaleFactor-=JUAMPI=-wantsHaloFromClick  ^true-=JUAMPI=-removeKeyCombination: aShortcut  self kmDispatcher removeKeyCombination: aShortcut-=JUAMPI=-wantsToBeTopmost  ^false-=JUAMPI=-listDirection: aSymbol  listDirection := aSymbol-=JUAMPI=-beStraightSegments  smoothCurve == false ifFalse: [ smoothCurve := false.        self computeBounds ]-=JUAMPI=-wantsWindowEvent: anEvent  ^true-=JUAMPI=-setColor: aColor  self labelMorph color: aColor.  self solidLabelMorph color: aColor beOpaque-=JUAMPI=-testWhenChangingOrderInWorldListTaskOrderShouldRemains  | window1 window2 |  taskbar := self.  world := self.  window1 := world addWindow.  window2 := world addWindow.  taskbar updateTasks.  world putOnTop: window1.  taskbar updateTasks.  self assert: taskbar tasks first morph equals: window1.  self assert: taskbar tasks second morph equals: window2-=JUAMPI=-selectMoreAtTop  | first |  autoTargetMorph ifNil: [ ^self ].  first := autoTargetMorph index.  first > 1 ifTrue: [ self autoMultiSelect: (self allNodeMorphs at: first - 1).        self selectionChanged ]-=JUAMPI=-actionSelector  ^actionSelector-=JUAMPI=-adoptGradientColor: aColor  | c fs bfs bs bbs |  aColor ifNil: [ ^self ].  c := aColor.  fs := self normalThumbFillStyle.  bfs := self normalButtonFillStyle.  bs := self normalThumbBorderStyle.  bbs := self normalButtonBorderStyle.  sliderColor := c.  downButton     fillStyle: bfs;     borderStyle: bbs.  upButton     fillStyle: bfs shallowCopy;     borderStyle: bbs.  slider     fillStyle: fs;     borderStyle: bs.  self updateUpButtonImage.  self updateDownButtonImage-=JUAMPI=-newButtonFor: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpText  ^self theme newButtonIn: self for: aModel getState: stateSel action: actionSel arguments: args getEnabled: enabledSel getLabel: labelSel help: helpText-=JUAMPI=-setTabContentFrom: aTab  | process |  contentsWrapper removeAllMorphs.  self cleanProcesses.  process := aTab retrieveMorph: [:contents |  contents ifNil: [ TabWithNoContents signalTab: aTab ].        contentsWrapper addMorph: contents fullFrame: LayoutFrame identity ].  process ifNotNil: [ processes add: process ]-=JUAMPI=-outermostMorphThat: conditionBlock  | outermost |  self allOwnersDo: [:m |  (conditionBlock value: m) ifTrue: [ outermost := m ] ].  ^outermost-=JUAMPI=-getColorSelector: anObject  getColorSelector := anObject-=JUAMPI=-wantsDroppedMorph: aMorph event: anEvent  ^aMorph dragTransferType == #dragTransfer ifTrue: [ super wantsDroppedMorph: aMorph event: anEvent ] ifFalse: [ self model wantsDroppedMorph: aMorph event: anEvent inMorph: self ]-=JUAMPI=-minHeight  | iconHeight |  iconHeight := self hasIcon ifTrue: [ self icon height + 2 ] ifFalse: [ 0 ].  ^((self contents heightToDisplayInTree: self) max: iconHeight) max: super minHeight-=JUAMPI=-wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph  (#(addDismissHandle:) includes: aSelector) ifTrue: [ ^self resistsRemoval not ].  (#(addDragHandle:) includes: aSelector) ifTrue: [ ^self okayToBrownDragEasily ].  (#(addGrowHandle: addScaleHandle:) includes: aSelector) ifTrue: [ ^self okayToResizeEasily ].  (#(addRotateHandle:) includes: aSelector) ifTrue: [ ^self okayToRotateEasily ].  (#(addRecolorHandle:) includes: aSelector) ifTrue: [ ^self renderedMorph wantsRecolorHandle ].  ^true-=JUAMPI=-transform: anEvent from: originalEvent andSendTo: aMorph  | transformedEvent |  transformedEvent := anEvent transformedBy: (aMorph transformedFrom: originalEvent hand).  ^aMorph handleEvent: transformedEvent-=JUAMPI=-releaseKeyboardFocus: aMorph  self keyboardFocus == aMorph ifTrue: [ self releaseKeyboardFocus ]-=JUAMPI=-computedBounds  | tb tbw yGap |  tb := treeMorph bounds.  tbw := treeMorph borderWidth.  yGap := self layoutInset asPoint y + self cellInset asPoint y.  ^tb bottomLeft + (tbw @ (self computedHeight + yGap) negated) corner: tb bottomRight - ((tbw * 2) @ yGap)-=JUAMPI=-newHueSelector: aModel getHue: getSel setHue: setSel help: helpText  ^self theme newHueSelectorIn: self for: aModel getHue: getSel setHue: setSel help: helpText-=JUAMPI=-nextPage: newLast  | addedNodeList |  newLast > self lastIndex ifFalse: [ ^self ].  self lastIndex < self nodeList size ifTrue: [ addedNodeList := self nodeList copyFrom: 1 to: newLast.        self lastIndex: newLast.        treeMorph scroller removeAllMorphs.        treeMorph addSubmorphsFromNodeList: addedNodeList previouslyExpanded: treeMorph currentlyExpanded ]-=JUAMPI=-isAdheringToRight  ^self edgeToAdhereTo == #right-=JUAMPI=-hasSelection  ^self selectedIndexes isNotEmpty-=JUAMPI=-generateKeyboardEvent: evtBuf  | buttons modifiers type pressType stamp charCode keyValue keyEvent |  stamp := evtBuf second.  stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ].  pressType := evtBuf fourth.  pressType = EventKeyDown ifTrue: [ type := #keyDown.        lastKeyScanCode := evtBuf third ].  pressType = EventKeyUp ifTrue: [ type := #keyUp ].  pressType = EventKeyChar ifTrue: [ type := #keystroke ].  modifiers := evtBuf fifth.  buttons := modifiers bitShift: 3.  keyValue := evtBuf third.  charCode := evtBuf sixth.  type = #keystroke ifTrue: [ combinedChar ifNil: [ | peekedEvent |              peekedEvent := Sensor peekEvent.              (peekedEvent notNil and: [ peekedEvent fourth = EventKeyDown ]) ifTrue: [ (CombinedChar isCompositionCharacter: charCode) ifTrue: [ combinedChar := CombinedChar new.                          combinedChar simpleAdd: charCode asCharacter.                          (combinedChar combinesWith: peekedEvent third asCharacter) ifTrue: [ ^nil ] ] ] ] ifNotNil: [ (combinedChar simpleAdd: charCode asCharacter) ifTrue: [ charCode := combinedChar combined charCode ].              combinedChar := nil ] ].  (type = #keystroke and: [ (buttons anyMask: 16) and: [ {Character arrowUp .               Character arrowDown} includes: charCode asCharacter ] ]) ifTrue: [ ^MouseWheelEvent fromCharacter: charCode asCharacter position: lastMouseEvent cursorPoint buttons: buttons hand: self stamp: stamp ].  self flag: #pharoFixMe.  (charCode notNil and: [ charCode > 255 ]) ifTrue: [ keyValue := 0 ].  keyEvent := KeyboardEvent new setType: type buttons: buttons position: self position keyValue: keyValue charCode: charCode hand: self stamp: stamp.  keyEvent scanCode: lastKeyScanCode.  ^keyEvent-=JUAMPI=-mouseLeave: evt  ^self eventHandler ifNotNil: [ self eventHandler mouseLeave: evt fromMorph: self ]-=JUAMPI=-leftLayoutFrame  ^(0 @ 0 corner: 0 @ 1) asLayoutFrame     topOffset: -7;     bottomRightOffset: SystemWindow borderWidth @ (SystemWindow borderWidth - 26)-=JUAMPI=-selectMorph: aNodeMorph multiple: withMultipleSelection clickedTheCheckBox: checkBox  | path mult |  checkBox ifFalse: [ self lastClickedMorph: aNodeMorph ].  aNodeMorph ifNil: [ self emptySelection.        ^nil ].  aNodeMorph selected ifTrue: [ withMultipleSelection ifTrue: [ self removeFromSelection: aNodeMorph ] ifFalse: [ mult := self selectedMorphList size > 1.              path := aNodeMorph path collect: [:m |  m complexContents ].              (self autoDeselection or: [ mult ]) ifTrue: [ self emptySelection.                    mult ifTrue: [ self addToSelection: aNodeMorph ] ifFalse: [ path := nil ] ] ] ] ifFalse: [ withMultipleSelection ifFalse: [ self emptySelection ].        self addToSelection: aNodeMorph clickedTheCheckBox: checkBox.        path := aNodeMorph path collect: [:m |  m complexContents ] ].  self selectionChanged.  ^path-=JUAMPI=-takesKeyboardFocus  ^true-=JUAMPI=-releaseCachedState  self borderStyle releaseCachedState-=JUAMPI=-labelMorph  ^labelMorph-=JUAMPI=-drawDropHighlightOn: aCanvas  self highlightedForDrop ifTrue: [ aCanvas frameRectangle: self fullBounds color: self dropHighlightColor ]-=JUAMPI=-item: newItem  item := newItem-=JUAMPI=-newOKButton  ^self newOKButtonFor: self-=JUAMPI=-shouldFlex  ^true-=JUAMPI=-layoutFrame: aLayoutFrame  layoutFrame := aLayoutFrame-=JUAMPI=-borderStyleToUse  ^self isRadioButton ifTrue: [ self radioBorderStyleToUse ] ifFalse: [ self checkboxBorderStyleToUse ]-=JUAMPI=-newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpText-=JUAMPI=-adoptPaneColor: aColor  self color: aColor-=JUAMPI=-adjustBorderUponDeactivationWhenLabeless  | aWidth |  (aWidth := self valueOfProperty: #borderWidthWhenInactive) ifNotNil: [ self acquireBorderWidth: aWidth ]-=JUAMPI=-enabled: aBoolean  aBoolean = self enabled ifFalse: [ enabled := aBoolean.        self           adoptPaneColor: self paneColor;           changed ]-=JUAMPI=-balloonText  extension ifNil: [ ^nil ].  ^extension balloonText ifNotNil: [:text |  text asString withNoLineLongerThan: self theme settings maxBalloonHelpLineLength ]-=JUAMPI=-drawWithSelectionOn: canvas  canvas line: self bottomLeft + (0 @ -1) to: self selectedTab bottomLeft width: 1 color: self borderColor.  canvas line: self selectedTab bottomLeft to: self selectedTab bottomRight width: 1 color: self selectedColor.  canvas line: self selectedTab bottomRight to: self bottomRight + (0 @ -1) width: 1 color: self borderColor-=JUAMPI=-setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) rounded-=JUAMPI=-allowsKeymapping  ^self valueOfProperty: #allowsKeymapping ifAbsent: [ true ]-=JUAMPI=-originColumn: column row: rowIndex  ^FTCellMorph new     color: (self colorFor: rowIndex);     addMorph: (self elementAt: rowIndex) origin name asMorph;     yourself-=JUAMPI=-paneColor  ^self paneColorOrNil ifNil: [ self color ]-=JUAMPI=-mouseUp: anEvent  self canResizeColumn ifFalse: [ ^self ].  (self bounds containsPoint: anEvent cursorPoint) ifFalse: [ anEvent hand showTemporaryCursor: nil ].  self class fastSplitterResize ifTrue: [ self updateFromEvent: anEvent ].  traceMorph ifNotNil: [ traceMorph delete.        traceMorph := nil ].  self adoptPaneColor: self paneColor.  self triggerEvent: #mouseUp-=JUAMPI=-buildVerticesFrom: borderVertices  ^state buildVerticesFrom: borderVertices-=JUAMPI=-scrollPane  ^scrollPane-=JUAMPI=-mouseOverBorderStyle  ^mouseOverBorderStyle ifNil: [ BorderStyle thinGray ]-=JUAMPI=-selectedLabel  ^selectedLabel-=JUAMPI=-canvas: x  -=JUAMPI=-useExtraSelection  ^self useFindReplaceSelection or: [ self useSecondarySelection ]-=JUAMPI=-themeChanged  self fillStyle: self normalFillStyle.  super themeChanged-=JUAMPI=-complexContents  ^complexContents-=JUAMPI=-addInterruptionButton  self isInterruptable ifFalse: [ ^self ].  self addMorphBack: (self iconNamed: #stopIcon) asMorph-=JUAMPI=-hand  ^source-=JUAMPI=-shouldDraw  ^super shouldDraw or: [ self class showSplitterHandles ]-=JUAMPI=-mouseEnterDragging: evt  evt hand mouseFocus == owner ifTrue: [ owner selectItem: self event: evt ]-=JUAMPI=-bounds: aRectangle in: referenceMorph  owner ifNil: [ ^aRectangle ].  ^(owner transformFrom: referenceMorph) localBoundsToGlobal: aRectangle-=JUAMPI=-transformBy: aMorphicTransform  position := aMorphicTransform globalPointToLocal: position-=JUAMPI=-getEnabledSelector  ^getEnabledSelector-=JUAMPI=-index: anIndex  index := anIndex-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: (splitsTopAndBottom ifTrue: [ #top ] ifFalse: [ #left ])-=JUAMPI=-asAthensCurvedPathOn: anAthensCanvas  | points |  points := self computeCurvedSegmentCtrlPoints.  ^anAthensCanvas createPath: [:builder |  self vertices notEmpty ifTrue: [ | prior |              prior := points first.              builder absolute.              builder moveTo: prior second.              points allButFirst do: [:p |  builder curveVia: prior third and: p first to: p second.                    prior := p ].              self isClosed ifTrue: [ builder curveVia: prior third and: points first first to: points first second.                    builder close ] ].        builder ]-=JUAMPI=-bottomFraction  ^bottomFraction-=JUAMPI=-newHSVSelector: aColor help: helpText  ^self theme newHSVSelectorIn: self color: aColor help: helpText-=JUAMPI=-handlesKeyboard: evt  ^true-=JUAMPI=-getLabelSelector: anObject  getLabelSelector := anObject.  self updateLabel-=JUAMPI=-hasProperty: aSymbol  extension ifNil: [ ^false ].  ^extension hasProperty: aSymbol-=JUAMPI=-intoWorldCount  ^intoWorldCount-=JUAMPI=-labelString  ^label ifNil: [ labelString ] ifNotNil: [ label contents asString ]-=JUAMPI=-getListItem: index  ^listSource getListRow: index-=JUAMPI=-addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol argumentList: argList  self addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol enablementSelector: nil argumentList: argList-=JUAMPI=-navigateWindowBackward  self previousWindow ifNotNil: [:m |  m isCollapsed ifTrue: [ m collapseOrExpand ].        m activate ]-=JUAMPI=-icon: anObject  icon := anObject-=JUAMPI=-adoptPaneColor: paneColor  (paneColor notNil and: [ self trackPaneColor ]) ifTrue: [ self color: paneColor ].  super adoptPaneColor: paneColor-=JUAMPI=-selectedObject  | halo |  halo := self halo.  halo ifNil: [ ^nil ].  ^halo target renderedMorph-=JUAMPI=-contents  ^text-=JUAMPI=-activeSubmenu: aSubmenu  activeSubMenu ifNotNil: [ activeSubMenu delete ].  activeSubMenu := aSubmenu.  aSubmenu ifNil: [ ^self ].  activeSubMenu selectItem: nil event: nil.  activeSubMenu borderColor: self borderColor.  activeSubMenu beSticky.  activeSubMenu resistsRemoval: true.  activeSubMenu removeMatchString-=JUAMPI=-setProperty: aSymbol toValue: abObject  self assureOtherProperties at: aSymbol put: abObject-=JUAMPI=-showFirstSelection  self hasSelection ifFalse: [ ^self ].  self moveShowIndexTo: self selectedIndex-=JUAMPI=-hasContents  ^self contents isEmpty not-=JUAMPI=-lastVertex  ^vertices last-=JUAMPI=-removeMorph: aMorph  | aWorld |  aMorph owner == self ifFalse: [ ^self ].  aWorld := self world.  aWorld ifNotNil: [ aMorph outOfWorld: aWorld.        self privateInvalidateMorph: aMorph ].  self privateRemove: aMorph.  aMorph privateOwner: nil.  self removedMorph: aMorph-=JUAMPI=-handlesMouseDown: evt  ^true-=JUAMPI=-selectedPressedBorderStyle  ^self theme controlButtonSelectedPressedBorderStyleFor: self-=JUAMPI=-highlightSelection  selectedMorph ifNotNil: [ selectedMorph highlight ]-=JUAMPI=-max  ^(self sliderMorph ifNil: [ ^0 ]) max-=JUAMPI=-newTabSelectorMorph  ^TabSelectorMorph new     vResizing: #shrinkWrap;     hResizing: #spaceFill-=JUAMPI=-announceDate  | announcement |  announcement := ChoseDate of: self date from: self.  announcer ifNotNil: [ announcer announce: announcement ]-=JUAMPI=-setColor: aColor toHandle: aHandle  aHandle color: aColor.  self gradientHalo ifTrue: [ | fill |        fill := GradientFillStyle ramp: {(0.0 -> aColor muchLighter) .               (1.0 -> aColor darker)}.        fill origin: aHandle topLeft.        fill direction: aHandle extent.        aHandle fillStyle: fill ]-=JUAMPI=-isCloseable  ^self mustNotClose not and: [ model ifNotNil: [ model okToChange ] ifNil: [ true ] ]-=JUAMPI=-selectLast  self table selectIndex: self table numberOfRows-=JUAMPI=-objectToPaste  ^Cursor wait showWhile: [ PasteBuffer veryDeepCopy ]-=JUAMPI=-halo  ^self primaryHand halo ifNotNil: [:h |  h target == self ifTrue: [ h ] ]-=JUAMPI=-themeChanged  self     removeAllMorphs;     initializeSlider.  super themeChanged-=JUAMPI=-initialize  super initialize.  self cellInset: 7-=JUAMPI=-setValue: newValue  self value: newValue.  setValueSelector ifNotNil: [ ^model perform: setValueSelector with: value ]-=JUAMPI=-target  ^objectToView-=JUAMPI=-shadowPoint: newPoint  self changed.  self shadowOffset: (newPoint - self center) // 5.  fullBounds ifNotNil: [ fullBounds := self privateFullBounds ].  self changed-=JUAMPI=-disable  self enabled: false-=JUAMPI=-athensDisplay: item atRow: row on: aCanvas  | c backgroundColor drawBounds |  drawBounds := self drawBoundsForRow: row.  c := self colorForRow: row.  backgroundColor := self backgroundColorForRow: row.  item listRenderOn: aCanvas asCanvasWrapper atRow: row bounds: drawBounds color: c backgroundColor: backgroundColor from: self.  row = self mouseDownRow ifTrue: [ (aCanvas setStrokePaint: c)           width: 1;           dashes: {1} offset: 0.        aCanvas drawShape: (self selectionFrameForRow: row) ]-=JUAMPI=-color: aColor  super color: aColor.  self setProperty: #basicColor toValue: aColor-=JUAMPI=-themeChanged  self onImage: (self isRadioButton ifTrue: [ self theme radioButtonMarkerForm ] ifFalse: [ self theme checkboxMarkerForm ]).  self adoptPaneColor: self paneColor.  super themeChanged-=JUAMPI=-separatorAfterARow: aRow  aRow ifNil: [ ^false ].  self separatorBlockOrSelector ifNotNil: [:blockOrSelector |  | anItem |        anItem := getListElementSelector ifNil: [ list at: aRow ifAbsent: [ ^false ] ] ifNotNil: [ model perform: getListElementSelector with: aRow ].        ^blockOrSelector isBlock ifTrue: [ blockOrSelector cull: anItem cull: aRow ] ifFalse: [ blockOrSelector isSymbol ifTrue: [ blockOrSelector numArgs == 0 ifTrue: [ anItem perform: blockOrSelector ] ifFalse: [ self model perform: blockOrSelector withEnoughArguments: {anItem .                                 aRow} ] ] ifFalse: [ false ] ] ].  ^false-=JUAMPI=-selectLast  self table selectIndex: {self table numberOfRows .         self table numberOfColumns}-=JUAMPI=-scrollLeft: count  self scrollUp: count-=JUAMPI=-offColor  ^offColor-=JUAMPI=-scrollAbsolute: event  | r p |  r := self roomToMove.  bounds isWide ifTrue: [ r width = 0 ifTrue: [ ^self ] ] ifFalse: [ r height = 0 ifTrue: [ ^self ] ].  p := event targetPoint adhereTo: r.  self descending ifFalse: [ self setValue: (bounds isWide ifTrue: [ (p x - r left) asFloat / r width ] ifFalse: [ (p y - r top) asFloat / r height ]) ] ifTrue: [ self setValue: (bounds isWide ifTrue: [ (r right - p x) asFloat / r width ] ifFalse: [ (r bottom - p y) asFloat / r height ]) ]-=JUAMPI=-transform  ^transform-=JUAMPI=-filterNowWith: patternString  pattern := patternString.  self field setText: pattern.  self filterWith: pattern.  self filter-=JUAMPI=-oldScrollingIndex  ^oldScrollingIndex-=JUAMPI=-newContentMorph  self hsvaMorph: self newHSVAColorSelectorMorph.  ^self newRow: {(self newGroupbox: 'Color' translated forAll: {self hsvaMorph .               ((self newRow: {((self newLabelGroup: {('Selected color' translated -> self newColorPresenterMorph)}) vResizing: #shrinkWrap) .                     self newColorPickerButtonMorph}) cellPositioning: #leftCenter)}) .         ((self newGroupbox: 'Values' translated for: (self newLabelGroup: {('Red' translated -> (self newColorComponentFieldMorph: #red)) .                     ('Green' translated -> (self newColorComponentFieldMorph: #green)) .                     ('Blue' translated -> (self newColorComponentFieldMorph: #blue)) .                     ('Hue' translated -> (self newColorComponentFieldMorph: #hue)) .                     ('Saturation' translated -> (self newColorComponentFieldMorph: #saturation)) .                     ('Brightness' translated -> (self newColorComponentFieldMorph: #brightness)) .                     ('Alpha' translated -> (self newColorComponentFieldMorph: #alpha))})) hResizing: #shrinkWrap)}-=JUAMPI=-containsPoint: aPoint  ^(lines at: (self lineIndexForPoint: aPoint)) rectangle containsPoint: aPoint-=JUAMPI=-removeOtherProperties  otherProperties := nil-=JUAMPI=-setMultipleSelection: aBoolean  aBoolean ifTrue: [ self beMultipleSelection ] ifFalse: [ self beSingleSelection ]-=JUAMPI=-addColumn: aTreeColumn  self addColumn: aTreeColumn afterIndex: self columns size-=JUAMPI=-selectionColor: aColor  selectionColor := aColor-=JUAMPI=-display: aBlock  displayBlock := aBlock-=JUAMPI=-isFullOnScreen  owner ifNil: [ ^true ].  self visible ifFalse: [ ^true ].  ^owner clearArea containsRect: self fullBounds-=JUAMPI=-offerWindowMenu  | aMenu |  aMenu := self buildWindowMenu.  model ifNotNil: [ model addModelItemsToWindowMenu: aMenu ].  aMenu popUpEvent: self currentEvent in: self world-=JUAMPI=-initialize  super initialize.  icon := ImageMorph new-=JUAMPI=-privateMoveBy: delta  super privateMoveBy: delta-=JUAMPI=-icon  ^icon-=JUAMPI=-addARowCentered: aCollectionOfMorphs cellInset: cellInsetInteger  ^(self addARow: aCollectionOfMorphs)     hResizing: #shrinkWrap;     wrapCentering: #center;     cellPositioning: #leftCenter;     cellInset: cellInsetInteger-=JUAMPI=-menuStringBounds  | stringBounds |  stringBounds := bounds.  self hasIcon ifTrue: [ | iconForm |        iconForm := self iconForm.        stringBounds := stringBounds left: stringBounds left + iconForm width + 2 ].  self hasMarker ifTrue: [ stringBounds := stringBounds left: stringBounds left + self submorphBounds width + 8 ].  ^stringBounds top: (stringBounds top + stringBounds bottom - self fontToUse height) // 2-=JUAMPI=-basicMoveShowIndexTo: aNumber  showIndex := aNumber-=JUAMPI=-tabs: aCollection  toolbar tabs: aCollection-=JUAMPI=-openModal: aSystemWindow  | area mySysWin keyboardFocus |  keyboardFocus := self activeHand keyboardFocus.  mySysWin := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  mySysWin ifNil: [ mySysWin := self ].  mySysWin modalLockTo: aSystemWindow.  area := RealEstateAgent maximumUsableArea.  aSystemWindow extent: aSystemWindow initialExtent.  aSystemWindow position = (0 @ 0) ifTrue: [ aSystemWindow position: self activeHand position - (aSystemWindow extent // 2) ].  aSystemWindow bounds: (aSystemWindow bounds translatedToBeWithin: area).  [ | aWidget |  aWidget := aSystemWindow openAsIs.  self activeHand mouseFocus: aWidget.  [ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] ensure: [ mySysWin modalUnlockFrom: aSystemWindow.        self activeHand newKeyboardFocus: keyboardFocus ].  ^aSystemWindow-=JUAMPI=-modalUnlockFrom: aSystemWindow  aSystemWindow removeProperty: #modalOwner.  self removeProperty: #modalChild.  closeBox ifNotNil: [:cl |  cl enabled: (self valueOfProperty: #preModalCloseEnabled ifAbsent: [ true ]) ].  self removeProperty: #preModalCloseEnabled.  self activate-=JUAMPI=-defaultBorderWidth  ^0-=JUAMPI=-passivate  super passivate.  self nonVisibleTabs do: [:t |  t passivate ]-=JUAMPI=-activeDisabledNotOverUpFillStyle: aFillStyle  self stateMap atPath: #(active disabled notOver up) put: aFillStyle.  self changed-=JUAMPI=-menuItems  ^submorphs select: [:m |  m isMenuItemMorph ]-=JUAMPI=-calendar: aCalendarChooserMorph  calendar := aCalendarChooserMorph-=JUAMPI=-updateWidth  self resize-=JUAMPI=-doubleClickSelector: aSelector  doubleClickSelector := aSelector-=JUAMPI=-apply: delta  | oldBounds |  oldBounds := target bounds.  target bounds: (oldBounds origin corner: oldBounds corner + delta)-=JUAMPI=-cellPositioning  ^#center-=JUAMPI=-newEditableDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newEditableDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel addToList: addSel class: aClass default: defaultValue ghostText: ghostText getEnabled: enabledSel useIndex: useIndex help: helpText-=JUAMPI=-collpasedButton  ^IconicButton new     target: self;     actionSelector: #expandAndRefresh;     arguments: {};     labelGraphic: self class unexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-=JUAMPI=-recipient  ^recipient-=JUAMPI=-newHueSelector: aModel getHue: getSel setHue: setSel help: helpText  ^self theme newHueSelectorIn: self for: aModel getHue: getSel setHue: setSel help: helpText-=JUAMPI=-trackDirectionArrow: anEvent with: shaft  anEvent hand obtainHalo: self.  shaft setVertices: {directionArrowAnchor .         anEvent cursorPoint}.  self layoutChanged-=JUAMPI=-stateSelector: anObject  stateSelector := anObject-=JUAMPI=-newListFor: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpText  ^self theme newListIn: self for: aModel list: listSelector selected: getSelector changeSelected: setSelector icon: iconSelector getEnabled: enabledSel help: helpText-=JUAMPI=-drawOn: aCanvas  | keyBounds |  keyBounds := self boundsForKeyText: self keyText font: self owner fontToUse.  self owner drawText: keyText on: aCanvas in: keyBounds color: self color-=JUAMPI=-userString  ^String streamContents: [:stream |  1 to: self getListSize do: [:i |  (self getListItem: i) submorphs detect: [:morph |  morph userString notNil ] ifFound: [:morph |  stream nextPutAll: morph userString ].              stream cr ] ]-=JUAMPI=-triggerOnMouseDown  ^triggerOnMouseDown-=JUAMPI=-currentNodelist  ^self nodeList-=JUAMPI=-newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText-=JUAMPI=-setColorSelector: anObject  setColorSelector := anObject-=JUAMPI=-canDrawBorder: aBorderStyle  ^aBorderStyle style == #simple-=JUAMPI=-setLastCharacter: source  | aChar chars |  aChar := source asCharacter.  (chars := self getCharacters) size > 0 ifFalse: [ self newContents: (String with: aChar) ] ifTrue: [ chars last = aChar ifFalse: [ self newContents: (String streamContents: [:aStream |  aStream nextPutAll: (chars copyFrom: 1 to: chars size - 1).                          aStream nextPut: aChar ]) ] ]-=JUAMPI=-bottomRightColor  ^self color-=JUAMPI=-doneWithEdits  hasFocus := false-=JUAMPI=-chooseFileName: title extensions: exts path: path preview: preview  self deprecated: 'Use UIManager default chooseFileReference:extensions:path:preview:. instead.' on: '26 October 2018' in: #Pharo7.  ^self theme chooseFileNameIn: self title: title extensions: exts path: path preview: preview-=JUAMPI=-chooseServiceFrom: aCollection  aCollection size = 1 ifTrue: [ ^aCollection anyOne ].  ^UIManager default chooseFrom: (aCollection collect: [:each |  each label ]) values: aCollection-=JUAMPI=-medium  ^27-=JUAMPI=-on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel  self model: anObject.  getListSelector := getListSel.  getIndexSelector := getSelectionSel.  setIndexSelector := setSelectionSel.  getMenuSelector := getMenuSel.  keystrokeActionSelector := keyActionSel.  self autoDeselect: true.  self borderWidth: 1.  self updateList.  self selectionIndex: self getCurrentSelectionIndex.  self initForKeystrokes-=JUAMPI=-selectedFillStyle  ^self theme buttonSelectedFillStyleFor: self-=JUAMPI=-setUp  super setUp.  prototypes     add: (TextAnchor new anchoredMorph: Morph new initialize);     add: (TextAnchor new anchoredMorph: EllipseMorph new initialize)-=JUAMPI=-font: anObject  font := anObject-=JUAMPI=-beRowSelection  self selectionModeStrategy: (FTRowSelectionModeStrategy table: self)-=JUAMPI=-roomToMove  ^self totalSliderArea insetBy: (0 @ 0 extent: self sliderExtent)-=JUAMPI=-treeLineWidth  ^treeLineWidth ifNil: [ treeLineWidth := self theme treeLineWidth ]-=JUAMPI=-fontName: fontName pointSize: fontSize  | newTextStyle |  newTextStyle := ((TextStyle named: fontName asSymbol) ifNil: [ TextStyle default ]) copy.  newTextStyle ifNil: [ self error: 'font ' , fontName , ' not found.' ].  textStyle := newTextStyle.  text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOfPointSize: fontSize)).  paragraph ifNotNil: [ paragraph textStyle: newTextStyle ]-=JUAMPI=-currentNodelist  ^self pager ifNil: [ super nodeList ] ifNotNil: [ self pager currentNodelist ]-=JUAMPI=-hasHighlighted  ^self highlightedIndexes notEmpty-=JUAMPI=-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self assureExtension.  extension fillStyle ifNil: [ self color: paneColor ].  self borderStyle baseColor: paneColor darker-=JUAMPI=-recordDamagedRect: damageRect  damageRecorder ifNotNil: [ damageRecorder recordInvalidRect: damageRect truncated ]-=JUAMPI=-initialize  super initialize.  self     style: #inset;     trackPaneColor: true-=JUAMPI=-showSelectionFeedback  ^showSelectionFeedback-=JUAMPI=-computeFramedColors  | base light dark w hw colorArray param |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  w = 1 ifTrue: [ ^{(base mixed: 0.5 with: light) .         (base mixed: 0.5 with: dark)} ].  colorArray := Array new: w.  hw := w // 2.  0 to: hw - 1 do: [:i |  param := 0.5 + (i asFloat / hw * 0.5).        colorArray at: i + 1 put: (base mixed: param with: light).        colorArray at: w - i put: (base mixed: param with: dark) ].  w odd ifTrue: [ colorArray at: hw + 1 put: base ].  ^colorArray , colorArray-=JUAMPI=-newAutoAcceptTextEntryFor: aModel getText: getSel setText: setSel getEnabled: enabledSel font: aFont help: helpText  ^self theme newAutoAcceptTextEntryIn: self for: aModel get: getSel set: setSel class: String getEnabled: enabledSel font: aFont help: helpText-=JUAMPI=-newLeftButton  ^(ControlButtonMorph on: self getState: nil action: #scrollTabsLeft label: #leftButtonLabel)     getEnabledSelector: #leftButtonEnabled;     hResizing: #rigid;     vResizing: #spaceFill;     cornerStyle: #square;     extent: self controlButtonWidth asPoint-=JUAMPI=-rowColorForOdd: oddColor  rowColors at: 2 put: oddColor-=JUAMPI=-hasChildren  ^(dataSource childrenBlock value: item) isNotEmpty-=JUAMPI=-initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel  container := hostList.  self cellInset: container resizerWidth @ 0.  complexContents := anObject.  complexContents addDependent: self.  isExpanded := complexContents isExpanded.  nextSibling := firstChild := nil.  priorMorph ifNotNil: [ priorMorph nextSibling: self ].  indentLevel := newLevel.  self setBalloonText: complexContents helpText.  self initRow.  complexContents selected ifTrue: [ self selectedWithoutNotifyingComplexContents: true ]-=JUAMPI=-selectionChanged  self requestView: (MorphTreeSelectionChanged new selection: self selection)-=JUAMPI=-handlerForBlueButtonDown: anEvent  self wantsHaloFromClick ifFalse: [ ^nil ].  self class cycleHalosBothDirections ifTrue: [ anEvent handler ifNil: [ ^self ].        (anEvent handler isKindOf: PasteUpMorph) ifTrue: [ ^self ] ].  anEvent shiftPressed ifFalse: [ ^nil ] ifTrue: [ ^self ]-=JUAMPI=-resizeFromMenu  self resizeMorph: ActiveEvent-=JUAMPI=-handleStep: anEvent  ^self dispatchDefault: anEvent with: morph-=JUAMPI=-separatorSize: anInteger  separatorSize := anInteger-=JUAMPI=-yellowButtonActivity: shiftKeyState  (self getMenu: shiftKeyState) ifNotNil: [:menu |  menu setInvokingView: self.        menu popUpEvent: self activeHand lastEvent in: self world.        ^true ].  ^false-=JUAMPI=-translateBy: delta  position := position + delta-=JUAMPI=-itemsForTest  ^rootClass allSubclasses-=JUAMPI=-minExtentFrom: minExtent  | width height widthProp heightProp |  width := minExtent x + leftOffset - rightOffset.  height := minExtent y + topOffset - bottomOffset.  widthProp := rightFraction - leftFraction.  heightProp := bottomFraction - topFraction.  width := widthProp = 0 ifTrue: [ 0 ] ifFalse: [ width / widthProp ].  height := heightProp = 0 ifTrue: [ 0 ] ifFalse: [ height / heightProp ].  ^width truncated @ height truncated-=JUAMPI=-maxNodeWidth  ^maxNodeWidth ifNil: [ maxNodeWidth := 0 ]-=JUAMPI=-themedFillStyle  ^self theme buttonNormalFillStyleFor: self-=JUAMPI=-addToggle: aString target: anObject selector: aSymbol getStateSelector: stateSymbol enablementSelector: enableSymbol argumentList: argList  | item |  item := ToggleMenuItemMorph new     contents: aString;     target: anObject;     selector: aSymbol;     arguments: argList;     getStateSelector: stateSymbol;     enablementSelector: enableSymbol.  ^self addMenuItem: item-=JUAMPI=-configureForUnembedding  labelArea owner ifNil: [ self           makeBordered;           initializeLabelArea;           themeChanged;           addGrips ]-=JUAMPI=-hasItems  ^submorphs anySatisfy: [:each |  each isMenuItemMorph ]-=JUAMPI=-newRow  ^self theme newRowIn: self for: #()-=JUAMPI=-autoAccept: aBoolean  autoAccept := aBoolean-=JUAMPI=-multipleSelection  ^multipleSelection ifNil: [ multipleSelection := self defaultMultipleSelectionValue ]-=JUAMPI=-selectIndexes: index previous: oldSelection  self table selectIndexes: (((oldSelection includes: index) ifTrue: [ oldSelection copyWithout: index ] ifFalse: [ oldSelection ]) copyWithFirst: index)-=JUAMPI=-resizeToFit  ^self vResizing == #shrinkWrap-=JUAMPI=-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  scrollBar adoptPaneColor: paneColor.  hScrollBar adoptPaneColor: paneColor.  paneColor ifNil: [ ^self ].  self borderWidth > 0 ifTrue: [ self borderStyle: self borderStyleToUse ]-=JUAMPI=-passengerAt: rowIndex  ^self elementAt: rowIndex-=JUAMPI=-removeCollapseBox  collapseBox ifNotNil: [ collapseBox delete.        collapseBox := nil ]-=JUAMPI=-adjustLineIndicesBy: delta  firstCharacterIndex := firstCharacterIndex + delta.  lines do: [:line |  line slide: delta ]-=JUAMPI=-setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp  type := aSymbol.  buttons := anInteger.  position := pos.  keyValue := aValue.  source := aHand.  wasHandled := false.  timeStamp := stamp-=JUAMPI=-handlesMouseOver: evt  ^true-=JUAMPI=-model: aTreeModel  self model ifNotNil: [ self model announcer unsubscribe: self ].  super model: aTreeModel.  self registerRequestHandlers-=JUAMPI=-asSpecAdapter  ^MorphicGenericAdapter morph: self-=JUAMPI=-toggleSelected  self takeKeyboardFocus.  self enabled ifFalse: [ ^self ].  self model ifNil: [ ^self ].  (self setStateSelector ifNil: [ ^self ]) numArgs = 0 ifTrue: [ self model perform: self setStateSelector ].  self setStateSelector numArgs = 1 ifTrue: [ self model perform: self setStateSelector with: self isSelected not ].  self updateSelection-=JUAMPI=-handleMouseOver: anEvent  ^self dispatchDefault: anEvent with: morph-=JUAMPI=-cellPositioning  | props |  props := self layoutProperties.  ^props ifNil: [ #center ] ifNotNil: [ props cellPositioning ]-=JUAMPI=-menu: menu shifted: b  super menu: menu shifted: b.  menu addLine.  self selectedNode ifNotNil: [:current |  current menu: menu shifted: b ].  ^menu-=JUAMPI=-balloonHelpTextForHandle: aHandle  (aHandle eventHandler mouseSelectorsInclude: #doRecolor:with:) ifTrue: [ ^'Change color' ].  (aHandle eventHandler mouseSelectorsInclude: #mouseDownInDimissHandle:with:) ifTrue: [ ^'Remove from screen' translated ].  #(#(#addFullHandles 'More halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#trackCenterOfRotation:with: 'Set center of rotation')) do: [:pair |  (aHandle eventHandler mouseSelectorsInclude: pair first) ifTrue: [ ^pair last ] ].  ^'unknown halo handle' translated-=JUAMPI=-initializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigation.  aKMDispatcher attachCategory: #TabMorphsNavigation-=JUAMPI=-collapsedFrame  ^collapsedFrame-=JUAMPI=-subMenuSelector  ^subMenuSelector-=JUAMPI=-show: aString from: startNumber to: endNumber  | progressMorph |  self flag: #pharoFixMe.  self openInWorld.  progressMorph := self addItemShowing: aString from: startNumber to: endNumber.  self     refresh;     reposition.  ^progressMorph-=JUAMPI=-resetPotentialDropMorph  potentialDropMorph ifNotNil: [ potentialDropMorph resetHighlightForDrop.        potentialDropMorph := nil ]-=JUAMPI=-wrapFlag: aBoolean  aBoolean == wrapFlag ifTrue: [ ^self ].  wrapFlag := aBoolean.  self composeToBounds-=JUAMPI=-secondarySelectionColor  ^self theme secondarySelectionColor-=JUAMPI=-seeClassSide  -=JUAMPI=-addNavigationPane: aNavigPane  pager := aNavigPane.  self addMorph: pager.  pager buildPanel.  self updatePager.  self changed-=JUAMPI=-icon: aBlock  self dataSource icon: aBlock-=JUAMPI=-parent: aNodeMorph  parent := aNodeMorph-=JUAMPI=-popUpForHand: hand in: aWorld  | p |  p := hand position truncated.  ^self popUpAt: p forHand: hand in: aWorld-=JUAMPI=-fromArray: anArray  | str |  str := anArray readStream.  #(leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset:) do: [:sel |  str next ifNil: [ ^self ] ifNotNil: [:value |  self perform: sel with: value ] ]-=JUAMPI=-doFastWindowReframe: aSideOrCornerName  (FastDraggingFrameMorph forResizing: self fromLocation: aSideOrCornerName) openInWorld-=JUAMPI=-baseColor  ^self theme autoMenuColor ifTrue: [ owner color twiceDarker ] ifFalse: [ self theme currentSettings flatMenu ifFalse: [ owner color ] ifTrue: [ owner color twiceDarker ] ]-=JUAMPI=-initialize  super initialize.  self     changeProportionalLayout;     bounds: self currentWorld clearArea;     beSticky-=JUAMPI=-computeLength  | width size length |  size := tabs size.  size isZero ifTrue: [ ^0 ].  width := self width - self extraSpace + ((size - 1) * self overlap).  length := width / size.  length := length min: 150 * self displayScaleFactor.  length := length max: 33 * self displayScaleFactor.  ^length-=JUAMPI=-newPluggableDialogWindow: title for: contentMorph  ^self theme newPluggableDialogWindowIn: self title: title for: contentMorph-=JUAMPI=-iconFor: rowIndex  ^(self elementAt: rowIndex) actionOn: self-=JUAMPI=-fileNames  ^fileNames-=JUAMPI=-initDraggedMorph  draggedMorph ifNotNil: [ ^self ].  draggedMorph := self passenger asDraggableMorph.  self addMorphBack: draggedMorph.  self updateCopyIcon.  self     changed;     fullBounds-=JUAMPI=-useSortedTabsBy: sortBlock  toolbar useSortedTabsBy: sortBlock-=JUAMPI=-eventListeners  ^eventListeners-=JUAMPI=-actualViewee  | aMorph actualViewee |  aMorph := self morphToView ifNil: [ ^nil ].  aMorph isInWorld ifFalse: [ ^nil ].  actualViewee := viewSelector ifNil: [ aMorph ] ifNotNil: [ objectToView perform: viewSelector ].  actualViewee = 0 ifTrue: [ ^nil ].  actualViewee ifNil: [ actualViewee := objectToView ].  (actualViewee isMorph and: [ actualViewee isFlexMorph and: [ actualViewee submorphs size = 1 ] ]) ifTrue: [ actualViewee := actualViewee firstSubmorph ].  ^actualViewee-=JUAMPI=-popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem  | tryToPlace selectedOffset |  hand world startSteppingSubmorphsOf: self.  popUpOwner := sourceItem.  self fullBounds.  self updateColor.  selectedOffset := selectedItem ifNil: [ self items ifEmpty: [ 0 @ 0 ] ifNotEmpty: [:col |  col first position - self position ] ] ifNotNil: [ selectedItem position - self position ].  tryToPlace := [:where :mustFit |  | delta |  self position: where - selectedOffset.  delta := self fullBoundsInWorld amountToTranslateWithin: sourceItem worldBounds.  (delta x = 0 or: [ mustFit ]) ifTrue: [ delta = (0 @ 0) ifFalse: [ self position: self position + delta ].        sourceItem world addMorphFront: self.        ^self ] ].  tryToPlace     value: rightOrLeftPoint first value: false;     value: rightOrLeftPoint last - (self width @ 0) value: false;     value: rightOrLeftPoint first value: true-=JUAMPI=-modalLockTo: aSystemWindow  self lock-=JUAMPI=-displaySelectionBarOnAthensCanvas: anAthensCanvas  | visibleRectangle line |  selectionStart ifNil: [ ^self ].  selectionStop ifNil: [ ^self ].  visibleRectangle := anAthensCanvas clipRect.  selectionStart textLine = selectionStop textLine ifFalse: [ ^self ].  line := selectionStart textLine.  anAthensCanvas setPaint: self selectionBarColor.  anAthensCanvas drawShape: (visibleRectangle left @ line top corner: visibleRectangle right @ line bottom)-=JUAMPI=-hResizeScrollbar  | b |  b := self innerBounds.  b := b top: b bottom - self scrollBarThickness.  self vScrollbarShowing ifTrue: [ b := b right: b right - self scrollBarThickness ].  self hScrollbar bounds: b-=JUAMPI=-initializeLabel: aString start: startNumber end: endNumber  lock := Semaphore forMutualExclusion.  hasResult := false.  lastRefresh := 0.  self     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #topToBottom;     cellPositioning: #center;     cellInset: 5;     listCentering: #center;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap.  labelMorph := StringMorph contents: aString font: StandardFonts windowTitleFont.  self addMorphBack: labelMorph.  bar := ProgressBarMorph from: startNumber to: endNumber.  self addMorphBack: bar-=JUAMPI=-withHLines: aBoolean  withHLines := aBoolean-=JUAMPI=-themeChanged  super themeChanged.  tabs do: #themeChanged-=JUAMPI=-withText: aStringOrText label: title  self title: title.  self addMorph: (RubScrolledTextMorph new           setText: aStringOrText asString;           yourself) fullFrame: LayoutFrame identity.  self themeChanged-=JUAMPI=-invokeModal  ^self invokeModal: self menuKeyboardControl-=JUAMPI=-valueParameter: anObject  valueParameter := anObject-=JUAMPI=-leftMarginForAlignment: alignmentCode  alignmentCode = RightFlush ifTrue: [ ^self left + paddingWidth ].  alignmentCode = Centered ifTrue: [ ^self left + (paddingWidth // 2) ].  ^self left-=JUAMPI=-minWidth  ^self minimumExtent x max: super minWidth-=JUAMPI=-fillStyle: anObject  fillStyle := anObject-=JUAMPI=-deny: aStringOrText title: aString  ^self theme denyIn: self text: aStringOrText title: aString-=JUAMPI=-wantsRoundedCorners  ^color isTransparent not and: [ owner wantsRoundedCorners ]-=JUAMPI=-usableArea  ^self viewBox-=JUAMPI=-minHeight  | noVPlease noHPlease minH |  noVPlease := self valueOfProperty: #noVScrollBarPlease ifAbsent: [ false ].  noHPlease := self valueOfProperty: #noHScrollBarPlease ifAbsent: [ false ].  minH := noVPlease ifTrue: [ noHPlease ifTrue: [ 1 ] ifFalse: [ self scrollBarThickness ] ] ifFalse: [ noHPlease ifTrue: [ self scrollBarThickness * 3 ] ifFalse: [ self scrollBarThickness * 4 + 2 ] ].  ^minH max: super minHeight-=JUAMPI=-disabledBorderStyle  ^self theme buttonDisabledBorderStyleFor: self-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: #left-=JUAMPI=-addPaneVSplitters  | remaining targetRight sameRight sameLeft |  remaining := paneMorphs reject: [:each |  each layoutFrame rightFraction = 1 or: [ each layoutFrame rightFraction = 0 ] ].  [ remaining notEmpty ] whileTrue: [ targetRight := remaining first layoutFrame rightFraction.        sameRight := remaining select: [:each |  each layoutFrame rightFraction = targetRight ].        sameLeft := paneMorphs select: [:each |  each layoutFrame leftFraction = targetRight and: [ each layoutFrame rightFraction ~= targetRight ] ].        remaining := remaining copyWithoutAll: (self addPaneVSplitterBetween: sameRight and: sameLeft) ]-=JUAMPI=-world  ^owner ifNotNil: [ owner world ]-=JUAMPI=-removeFlexShell  self isFlexed ifTrue: [ self owner removeFlexShell ]-=JUAMPI=-activateSubmenu: evt  subMenu ifNil: [ ^false ].  (subMenu fullContainsPoint: evt position) ifFalse: [ ^false ].  subMenu activate: evt.  self removeAlarm: #deselectTimeOut:.  ^true-=JUAMPI=-exposedColumnsRange: columnWidths  ^self startColumnIndex isZero ifTrue: [ 1 to: self table numberOfColumns ] ifFalse: [ (1 to: columnWidths size) select: [:idx |  (columnWidths at: idx) > 0 ] ]-=JUAMPI=-updateOrderedTasksFrom: tasksThatShouldBeUpdated  | deadTasks |  deadTasks := OrderedCollection new.  self orderedTasks do: [:aTaskbarTask |  tasksThatShouldBeUpdated detect: [:aTaskThatShouldBeUpdated |  aTaskThatShouldBeUpdated morph = aTaskbarTask morph ] ifFound: [:foundTask |  tasksThatShouldBeUpdated remove: foundTask ] ifNone: [ deadTasks add: aTaskbarTask ] ].  (deadTasks isEmpty and: [ tasksThatShouldBeUpdated isEmpty ]) ifTrue: [ ^self ].  self orderedTasks: (self orderedTasks           removeAll: deadTasks;           addAll: tasksThatShouldBeUpdated;           yourself)-=JUAMPI=-forwardDirection  ^self valueOfProperty: #forwardDirection ifAbsent: [ 0.0 ]-=JUAMPI=-scrollValue  ^0 @ self verticalScrollBar value-=JUAMPI=-addHandlesTo: aHaloMorph box: box  | onlyThese |  aHaloMorph haloBox: box.  onlyThese := #(addDismissHandle: addMenuHandle: addGrabHandle: addDragHandle: addDupHandle: addHelpHandle: addGrowHandle: addFontSizeHandle: addFontStyleHandle: addFontEmphHandle: addRecolorHandle:).  HaloMorph currentHaloSpecifications do: [:aSpec |  (onlyThese includes: aSpec addHandleSelector) ifTrue: [ aHaloMorph perform: aSpec addHandleSelector with: aSpec ] ].  aHaloMorph innerTarget addOptionalHandlesTo: aHaloMorph box: box-=JUAMPI=-releaseCachedState  colors := nil.  lineStyles := nil-=JUAMPI=-keyUp: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #keyUp from: sourceMorph-=JUAMPI=-filter  self subclassResponsibility-=JUAMPI=-addMorph: aMorph fullFrame: aLayoutFrame  aMorph layoutFrame: aLayoutFrame asLayoutFrame.  aMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorph: aMorph-=JUAMPI=-containsPoint: aPoint  ^target ifNil: [ super containsPoint: aPoint ] ifNotNil: [ false ]-=JUAMPI=-newGroupbox: aString forAll: controls  ^self theme newGroupboxIn: self label: aString forAll: controls-=JUAMPI=-pressedFillStyle  ^self theme morphTreeSplitterPressedFillStyleFor: self-=JUAMPI=-setRotationCenterFrom: aPoint  self setProperty: #referencePosition toValue: aPoint-=JUAMPI=-eventListeners: anArrayOrNil  eventListeners := anArrayOrNil-=JUAMPI=-actionSelector: aSymbolOrString  (nil = aSymbolOrString or: [ 'nil' = aSymbolOrString or: [ aSymbolOrString isEmpty ] ]) ifTrue: [ ^actionSelector := nil ].  actionSelector := aSymbolOrString asSymbol-=JUAMPI=-changeMaxCellSize: evt  | handle |  handle := HandleMorph new forEachPointDo: [:newPoint |  self maxCellSize: (newPoint - evt cursorPoint) asIntegerPoint ].  evt hand attachMorph: handle.  handle startStepping-=JUAMPI=-clyAddEmphasis: aTextEmphasis  self emphasis: (emphasis bitOr: aTextEmphasis emphasisCode)-=JUAMPI=-initializeShortcuts: aKMDispatcher  aKMDispatcher attachCategory: #MorphFocusCtrlNavigation-=JUAMPI=-findReplaceDialog  ^EditorFindReplaceDialogWindow singleton-=JUAMPI=-veryDeepCopyWith: deepCopier  ^self-=JUAMPI=-newSliderFor: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText  ^self theme newSliderIn: self for: aModel getValue: getSel setValue: setSel min: min max: max quantum: quantum getEnabled: enabledSel help: helpText-=JUAMPI=-animateRestore  | expandedRect restoredRect rects steps |  expandedRect := self bounds.  restoredRect := self unexpandedFrame.  steps := self theme numberOfStepsForAnimations.  rects := ((steps - 1) / steps to: 0 by: -1 / steps) collect: [:x |  restoredRect interpolateTo: expandedRect at: ((20 raisedTo: x) - 1) / 19 ].  self fastAnimateRectangles: rects-=JUAMPI=-asAthensShapeOn: anAthensCanvas  | halfWidth halfHeight |  self bounds area > 0 ifFalse: [ ^self ].  halfWidth := self bounds width / 2 asFloat.  halfHeight := self bounds height / 2 asFloat.  ^anAthensCanvas createPath: [:builder |  builder           absolute;           moveTo: self bounds center;           relative;           moveTo: halfWidth negated @ 0;           curveVia: 0 @ (halfHeight negated * 0.55) and: (0.45 * halfWidth) @ halfHeight negated to: halfWidth @ halfHeight negated;           curveVia: (halfWidth * 0.55) @ 0 and: halfWidth @ (0.45 * halfHeight) to: halfWidth @ halfHeight;           curveVia: 0 @ (halfHeight * 0.55) and: (0.45 * halfWidth negated) @ halfHeight to: halfWidth negated @ halfHeight;           curveVia: (halfWidth negated * 0.55) @ 0 and: halfWidth negated @ (halfHeight negated * 0.45) to: halfWidth negated @ halfHeight negated ]-=JUAMPI=-nextCell  ^nextCell-=JUAMPI=-veryDeepInner: deepCopier  super veryDeepInner: deepCopier.  activatorDockingBar := activatorDockingBar-=JUAMPI=-chooseForSaveFileReference: title extensions: exts path: path preview: preview  ^self theme chooseForSaveFileReferenceIn: self title: title extensions: exts path: path preview: preview-=JUAMPI=-initialize  expanded := false.  depth := 0.  children := #()-=JUAMPI=-topRight: aPoint  self position: (aPoint x - bounds width) @ aPoint y-=JUAMPI=-alignBottomEdges  | maxBottom |  maxBottom := (selectedItems collect: [:itm |  itm bottom ]) max.  selectedItems do: [:itm |  itm bottom: maxBottom ].  self changed-=JUAMPI=-treeRenderOn: aCanvas bounds: drawBounds color: drawColor font: aFont from: aMorph  self bounds: drawBounds.  aMorph addMorphBack: self-=JUAMPI=-string  ^string-=JUAMPI=-setColorSelector  ^setColorSelector-=JUAMPI=-originalCenter: anObject  originalCenter := anObject-=JUAMPI=-selectedWithoutNotifyingComplexContents: aBoolean  aBoolean ifFalse: [ ^self ].  container listManager silentlySetSelectedMorph: self.  selected := aBoolean-=JUAMPI=-undoRedoExchange: aninterval with: anotherInterval  self handleEdit: [ self editor undoRedoExchange: aninterval with: anotherInterval ]-=JUAMPI=-defaultBorderWidth  ^self theme borderWidth-=JUAMPI=-navigationKey: anEvent  self isMultipleSelection ifTrue: [ | keyString |        keyString := anEvent keyString.        keyString = '<Cmd-a>' ifTrue: [ self selectAll.              ^true ].        keyString = '<Cmd-A>' ifTrue: [ self deselectAll.              ^true ] ].  ^super navigationKey: anEvent-=JUAMPI=-asMorph  ^self-=JUAMPI=-isUp  ^direction = Character arrowUp-=JUAMPI=-mouseUp: event  self storeValue: nil.  super mouseUp: event-=JUAMPI=-isMenuMorph  ^false-=JUAMPI=-testMouseEnterEventIsNotDuplicated  | mockObject window evt |  mockObject := MockObjectForEventTests new.  [ window := mockObject stringMorph openInWindow.  evt := MouseButtonEvent new setType: nil position: mockObject stringMorph center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  self assert: mockObject counter equals: 0.  mockObject stringMorph handleMouseEnter: evt.  self assert: mockObject counter equals: 1 ] ensure: [ window ifNotNil: #close ]-=JUAMPI=-mouseEnter: evt  self color: (selectionColor isTransparent ifTrue: [ self mouseOverColor ] ifFalse: [ self mouseOverColor mixed: 0.5 with: selectionColor ])-=JUAMPI=-mouseUpInSlider: event  sliderShadow hide.  (slider containsPoint: event position) ifTrue: [ slider           fillStyle: self mouseOverThumbFillStyle;           borderStyle: self mouseOverThumbBorderStyle ] ifFalse: [ self mouseLeaveThumb: event ].  slider changed-=JUAMPI=-on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel  self on: anObject getState: getStateSel action: actionSel label: labelSel icon: nil menu: menuSel-=JUAMPI=-indentationLevel: anInteger  indent := anInteger-=JUAMPI=-lastKeystrokeTime  ^lastKeystrokeTime-=JUAMPI=-paneColor  ^self paneColorOrNil ifNil: [ self owner ifNil: [ Color transparent ] ifNotNil: [ self owner color ] ]-=JUAMPI=-rowHeight  ^rowHeight ifNil: [ rowHeight := self class defaultRowHeight ]-=JUAMPI=-selectableIndexAfter: anIndex  ^self subclassResponsibility-=JUAMPI=-lastSelection: anObject  lastSelection := anObject-=JUAMPI=-drawOnAthensCanvas: anAthensCanvas  | border ellipse |  self bounds area > 0 ifFalse: [ ^self ].  border := self borderStyle.  ellipse := self asAthensShapeOn: anAthensCanvas.  anAthensCanvas setPaint: self fillStyle.  anAthensCanvas setShape: ellipse.  anAthensCanvas draw.  (anAthensCanvas setStrokePaint: border color) width: border width.  anAthensCanvas draw-=JUAMPI=-orientation  ^orientation-=JUAMPI=-selectToMe  self triggerEvent: #tabSelectTo with: self-=JUAMPI=-bottomArrow  ^BottomArrow-=JUAMPI=-buildPanel  | widgets firstPageButton previousButton wid nextButton lastPageButton pageSizeEditor searchEditor |  self removeAllMorphs.  pageSize ifNil: [ ^self ].  self nodeList ifNil: [ ^self ].  widgets := OrderedCollection new.  self nodeList size > pageSize ifTrue: [ firstPageButton := self buttonLabel: self class smallToLeftEndIcon actionSelector: #currentPage: arguments: {1} getEnabled: #notOnFirstPage help: 'First page'.        widgets add: firstPageButton.        previousButton := self buttonLabel: self class smallToLeftIcon actionSelector: #previousPage arguments: {} getEnabled: #notOnFirstPage help: 'Previous page'.        widgets add: previousButton.        wid := self textEntryLabel: '' get: #currentPageToString set: #currentPageInput: help: 'Index of page to view' translated class: String.        wid hResizing: #rigid.        wid width: (self preferedFont widthOfString: '1000000').        widgets add: wid.        widgets add: (self buttonLabel: self class smallDiezeIcon actionSelector: #choosePage arguments: {} getEnabled: nil help: 'Choose page').        nextButton := self buttonLabel: self class smallToRightIcon actionSelector: #nextPage arguments: {} getEnabled: #notOnLastPage help: 'Next page'.        widgets add: nextButton.        lastPageButton := self buttonLabel: self class smallToRightEndIcon actionSelector: #currentPage: arguments: {self lastPage} getEnabled: #notOnLastPage help: 'Last page'.        widgets add: lastPageButton.        widgets add: (self spacer: 10) ].  widgets add: (LabelMorph contents: 'Page size: ' font: self preferedFont).  pageSizeEditor := self textEntryLabel: 'Page size' get: #pageSizeToString set: #pageSizeFromString: help: 'Change the page size or the number of pages if the input begins with "/"' translated class: String.  pageSizeEditor hResizing: #rigid.  pageSizeEditor width: (self preferedFont widthOfString: '1000000').  widgets add: pageSizeEditor.  self withSearch ifTrue: [ searchEditor := self textEntryLabel: '' get: #pageSearchText set: #pageSearchText: help: 'Enter a text correspondig to your search' translated class: String.        searchEditor ghostText: 'Searched text'.        widgets add: searchEditor ].  self addAllMorphs: widgets.  self updateContents-=JUAMPI=-testSelectableIndexAbove  self subclassResponsibility-=JUAMPI=-basicSelectedColor: anObject  selectedColor := anObject.  self     changed: #selectedColor;     changed: #red;     changed: #green;     changed: #blue;     changed: #hue;     changed: #saturation;     changed: #brightness;     changed: #alpha.  self announcer announce: (ColorChanged to: selectedColor)-=JUAMPI=-autoAccept: anObject  autoAccept := anObject-=JUAMPI=-newAlphaImage: aForm help: helpText  ^self theme newAlphaImageIn: self image: aForm help: helpText-=JUAMPI=-proceed: aStringOrText  ^self proceed: aStringOrText title: 'Proceed' translated-=JUAMPI=-extent: aPoint  | old |  old := self extent.  super extent: aPoint.  self extent = old ifTrue: [ ^self ].  self updateColor-=JUAMPI=-findDeeplyA: aClass  ^(self allMorphs copyWithout: self) detect: [:p |  p isKindOf: aClass ] ifNone: [ nil ]-=JUAMPI=-setStrategy  table beCellSelection-=JUAMPI=-indentingItemClass  ^LazyMorphTreeNodeMorph-=JUAMPI=-left  ^textMorph owner left-=JUAMPI=-color: aColor  super color: aColor beOpaque.  self fillStyle: self defaultFillStyle-=JUAMPI=-drawOn: aCanvas  | time |  time := Time millisecondClockValue.  self drawMeOn: aCanvas.  drawTime := Time millisecondClockValue - time.  drawTime < 0 ifTrue: [ drawTime := nil ]-=JUAMPI=-hasFocus  ^hasFocus ifNil: [ false ]-=JUAMPI=-itemStringGetter: aValuable  self columns first itemStringGetter: aValuable-=JUAMPI=-fillStyleToUse  ^self isSelected ifTrue: [ self selectedFillStyle ] ifFalse: [ self normalFillStyle ]-=JUAMPI=-openOn: aClass  rootClass := aClass.  (self defaultTreeMorph buildContents embeddedInMorphicWindowLabeled: 'test') openInWorld-=JUAMPI=-openDialogOn: aClass  rootClass := aClass.  ^self openDialogWindowIn: self currentWorld title: 'All Object subclasses'-=JUAMPI=-deselect  editor ifNotNil: [ editor deselect ]-=JUAMPI=-allEnabledSiblingItems  ^self allSiblingItems select: [:item |  item isEnabled ]-=JUAMPI=-setSelectedSilently: aBoolean  selected := aBoolean.  self complexContents selected: aBoolean-=JUAMPI=-beUnsticky  extension ifNotNil: [ extension sticky: false ]-=JUAMPI=-announcer  WorldAnnouncer ifNil: [ WorldAnnouncer := Announcer new ].  ^WorldAnnouncer-=JUAMPI=-needSpaceForActions  | tab |  tab := self selectedTab.  tab ifNil: [ ^false ].  ^self selectedTab hasMenu or: [ self selectedTab hasActions ]-=JUAMPI=-isSelfEvaluating  ^false-=JUAMPI=-indentBy: aNumber  indentation := aNumber + self cellInset-=JUAMPI=-acceptDroppingMorph: aMorph event: evt  | item dropTarget |  dropItemSelector ifNil: [ model acceptDroppingMorph: aMorph event: evt inMorph: self ] ifNotNil: [ item := aMorph passenger.        dropTarget := (self itemFromPoint: evt position) withoutListWrapper.        model perform: dropItemSelector with: item with: dropTarget ].  evt hand releaseMouseFocus: self.  Cursor normal show-=JUAMPI=-halo  ^self valueOfProperty: #halo-=JUAMPI=-playMaximizeSound  self theme windowMaximizeSound play-=JUAMPI=-drawOn: aCanvas  super drawOn: aCanvas.  self drawGridOn: aCanvas.  self drawBackgroundSketchOn: aCanvas-=JUAMPI=-openItemPath: anArray  | found |  anArray isEmpty ifTrue: [ ^container listManager setSelectedMorph: nil ].  found := nil.  self withSiblingsDo: [:each |  found ifNil: [ (each complexContents withoutListWrapper = anArray first or: [ anArray first isNil ]) ifTrue: [ found := each ] ] ].  found ifNotNil: [ found isExpanded ifFalse: [ found toggleExpandedState ].        found changed.        anArray size = 1 ifTrue: [ ^container listManager setSelectedMorph: found ].        ^found firstChild ifNil: [ container setSelectedMorph: nil ] ifNotNil: [ found firstChild openItemPath: anArray allButFirst ] ].  ^self-=JUAMPI=-minExtent  ^self theme tabSelectorMorphMinExtentFor: self-=JUAMPI=-transferHalo: event from: formerHaloOwner  | localEvt w target |  self flag: #workAround.  (formerHaloOwner == self and: [ self isRenderer and: [ self wantsHaloFromClick not ] ]) ifTrue: [ event shiftPressed ifTrue: [ target := owner.              localEvt := event transformedBy: (self transformedFrom: owner) ] ifFalse: [ target := self renderedMorph.              localEvt := event transformedBy: (target transformedFrom: self) ].        ^target transferHalo: localEvt from: target ].  (self isWorldMorph and: [ owner isNil ]) ifFalse: [ (self wantsHaloFromClick and: [ formerHaloOwner ~~ self ]) ifTrue: [ ^self addHalo: event from: formerHaloOwner ] ].  event shiftPressed ifTrue: [ owner ifNotNil: [ ^owner transferHalo: event from: formerHaloOwner ].        formerHaloOwner removeHalo.        ^self processEvent: event copy resetHandlerFields ].  self submorphsDo: [:m |  localEvt := event transformedBy: (m transformedFrom: self).        (m fullContainsPoint: localEvt position) ifTrue: [ ^m transferHalo: event from: formerHaloOwner ] ].  formerHaloOwner removeHalo.  (w := self world) ifNil: [ ^self ].  localEvt := event transformedBy: (self transformedFrom: w) inverseTransformation.  ^w processEvent: localEvt resetHandlerFields-=JUAMPI=-invokeModal: allowKeyboardControl  ^self invokeModalAt: ActiveHand position in: self currentWorld allowKeyboard: allowKeyboardControl-=JUAMPI=-setSelectionIndex: idx  | theMorph index |  idx ifNil: [ ^self ].  index := idx min: scroller submorphs size max: 0.  theMorph := index = 0 ifTrue: [ nil ] ifFalse: [ scroller submorphs at: index ].  self setSelectedMorph: theMorph-=JUAMPI=-inToggleArea: aPoint  ^self sensitiveToggleRectangle containsPoint: aPoint-=JUAMPI=-onImage  ^image-=JUAMPI=-initialize  isExpanded := false.  recentlyChanged := false-=JUAMPI=-textColor: aColor  textColor := aColor-=JUAMPI=-fontNumber  ^fontNumber-=JUAMPI=-deleteBalloonTarget: aMorph  self handsDo: [:h |  h deleteBalloonTarget: aMorph ]-=JUAMPI=-expandAll: aMorph  | subs |  self expandAllSilently: aMorph.  aMorph updateChildrenRecursively.  subs := self scroller submorphs.  1 to: subs size do: [:pos |  (subs at: pos) index: pos ].  self innerWidgetChanged-=JUAMPI=-initializeClass: aClass  self initialize.  self elements: ((aClass selectors sorted: [:a :b |  a < b ]) collect: [:each |  FTExampleMethodModel method: aClass >> each ])-=JUAMPI=-nextMorphAcrossInWindow  ^self submorphAfter ifNil: [ (self owner ifNil: [ ^self ]) nextMorphAcrossInWindow ]-=JUAMPI=-privateMoveBy: delta  | fill |  super privateMoveBy: delta.  fill := self barFillStyle.  fill isOrientedFill ifTrue: [ fill origin: fill origin + delta ]-=JUAMPI=-gradientRamp  ^gradientRamp ifNil: [ {(0.0 -> originalColor muchLighter) .         (1.0 -> originalColor twiceDarker)} ]-=JUAMPI=-lastSelectedNode  ^self lastSelectedNodePath ifNotNil: [:path |  path ifEmpty: [ nil ] ifNotEmpty: [:p |  path last ] ]-=JUAMPI=-resetHScrollRange  hScrollRangeCache := nil.  self deriveHScrollRange-=JUAMPI=-includesHandle: aMorph  handles ifNil: [ ^false ].  ^handles includes: aMorph-=JUAMPI=-noteNewOwner: aMorph  -=JUAMPI=-delete  self removeHalo.  self activeHand     releaseKeyboardFocus: self;     releaseMouseFocus: self.  owner ifNotNil: [ self privateDelete.        self announceDeleted ]-=JUAMPI=-spSetModal: aSystemWindow  | area mySysWin keyboardFocus |  keyboardFocus := self activeHand keyboardFocus.  mySysWin := self isSystemWindow ifTrue: [ self ] ifFalse: [ self ownerThatIsA: SystemWindow ].  mySysWin ifNil: [ mySysWin := self ].  mySysWin modalLockTo: aSystemWindow.  area := RealEstateAgent maximumUsableArea.  aSystemWindow extent: aSystemWindow initialExtent.  aSystemWindow position = (0 @ 0) ifTrue: [ aSystemWindow position: self activeHand position - (aSystemWindow extent // 2) ].  aSystemWindow bounds: (aSystemWindow bounds translatedToBeWithin: area).  [ | aWidget |  aWidget := aSystemWindow.  [ aWidget world notNil ] whileTrue: [ aWidget outermostWorldMorph doOneCycle ] ] ensure: [ mySysWin modalUnlockFrom: aSystemWindow.        self activeHand newKeyboardFocus: keyboardFocus ].  ^aSystemWindow-=JUAMPI=-label  ^label-=JUAMPI=-drawOn: aCanvas  super drawOn: aCanvas.  topSeparator ifTrue: [ aCanvas line: bounds topLeft to: bounds topRight color: self seperatorColor ]-=JUAMPI=-computeCellSizes: aMorph in: newBounds horizontal: aBool  | cells block minSize maxSize maxCell |  cells := (Array new: aMorph submorphCount) writeStream.  minSize := properties minCellSize asPoint.  maxSize := properties maxCellSize asPoint.  aBool ifTrue: [ minSize := minSize transposed.        maxSize := maxSize transposed ].  maxCell := 0 @ 0.  block := [:m |  | cell size |  m disableTableLayout ifFalse: [ size := m minExtent asIntegerPoint.        cell := LayoutCell new target: m.        aBool ifTrue: [ cell hSpaceFill: m hResizing == #spaceFill.              cell vSpaceFill: m vResizing == #spaceFill ] ifFalse: [ cell hSpaceFill: m vResizing == #spaceFill.              cell vSpaceFill: m hResizing == #spaceFill.              size := size transposed ].        size := (size min: maxSize) max: minSize.        cell cellSize: size.        maxCell := maxCell max: size.        cells nextPut: cell ] ].  properties reverseTableCells ifTrue: [ aMorph submorphsReverseDo: block ] ifFalse: [ aMorph submorphsDo: block ].  ^maxCell -> cells contents-=JUAMPI=-setContainer: newContainer  self changed.  container := newContainer.  self releaseParagraph-=JUAMPI=-wantsColumnBreaks  ^wantsColumnBreaks-=JUAMPI=-addLine  submorphs isEmpty ifTrue: [ ^self ].  (self lastSubmorph isKindOf: DockingBarMenuLineMorph) ifFalse: [ self addMorphBack: DockingBarMenuLineMorph new ]-=JUAMPI=-transformedBy: aMorphicTransform  ^self shallowCopy transformBy: aMorphicTransform-=JUAMPI=-enabled  ^enabled ifNil: [ enabled := true ]-=JUAMPI=-terminateUIProcess  UIProcess     suspend;     terminate.  UIProcess := nil-=JUAMPI=-checkSplitters  (self submorphsSatisfying: [:e |  e isKindOf: ProportionalSplitterMorph ]) do: [:splitter |  self checkMorphsLeftOrTopFrom: splitter.        self checkMorphsRightOrBottomFrom: splitter ]-=JUAMPI=-setSelectionListSelector: aSelector  setSelectionListSelector := aSelector-=JUAMPI=-startDrag: event  | passengers transferMorph |  event hand hasSubmorphs ifTrue: [ ^self ].  self dragEnabled ifFalse: [ ^self ].  event hand anyButtonPressed ifFalse: [ ^self ].  self hasSelection ifFalse: [ ^self ].  passengers := self selectedIndexes collect: [:each |  self dataSource passengerAt: each ].  transferMorph := self dataSource transferFor: passengers from: self.  transferMorph align: transferMorph draggedMorph topLeft with: event position.  transferMorph dragTransferType: self dataSource dragTransferType.  event hand grabMorph: transferMorph-=JUAMPI=-expandAllFromNode: aNode  self requestView: (MorphTreeChangeRequest expandAllFromNode: aNode)-=JUAMPI=-initializeContainer  container := self defaultContainer.  self addMorph: container-=JUAMPI=-leftFraction: aNumber  leftFraction := aNumber-=JUAMPI=-initialDataSource: aDataSource  initialDataSource := aDataSource-=JUAMPI=-isFirstItem  ^owner submorphs first == self-=JUAMPI=-selectMatch: aString  | firstMatch |  self items do: [:item |  | match |        match := aString isEmpty or: [ item contents asString asLowercase includesSubstring: aString ].        item isEnabled: match.        (match and: [ firstMatch isNil ]) ifTrue: [ firstMatch := item ] ].  ^firstMatch-=JUAMPI=-result  ^result-=JUAMPI=-newImageFor: aModel get: getSel help: helpText  ^self theme newImageIn: self for: aModel get: getSel help: helpText-=JUAMPI=-pressed: anIndex  self model pressed: anIndex-=JUAMPI=-showWidget  self initializeMorph.  table     addMorph: field;     resizeAllSubviews-=JUAMPI=-newDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText  ^self theme newDropListIn: self for: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: useIndex help: helpText-=JUAMPI=-deactivate  InputEventSensor default shutDown.  Display shutDown.  InputEventFetcher default shutDown-=JUAMPI=-testLeftTopAligned  | lf rectangle |  lf := LayoutFrame new     leftOffset: 10;     topOffset: 10;     rightFraction: 0 offset: 60;     bottomFraction: 0 offset: 25;     yourself.  rectangle := lf layout: nil in: (50 @ 10 corner: 150 @ 70).  self assert: (60 @ 20 corner: 110 @ 35) equals: rectangle-=JUAMPI=-removeAlarm: aSelector for: aTarget  worldState removeAlarm: aSelector for: aTarget-=JUAMPI=-deselectTimeOut: evt  owner selectedItem == self ifTrue: [ evt hand releaseMouseFocus: owner.        owner selectItem: nil event: evt ]-=JUAMPI=-showIconTreshold  ^(closeIcon visible ifTrue: [ 54 ] ifFalse: [ 40 ]) * self displayScaleFactor-=JUAMPI=-chooseDirectory: title  ^self chooseDirectory: title path: nil-=JUAMPI=-mouseDown: anEvent  self enabled ifTrue: [ self           scrollPoint: anEvent;           computeSlider ].  super mouseDown: anEvent.  self enabled ifFalse: [ ^self ].  anEvent hand newMouseFocus: slider event: anEvent.  slider     mouseEnter: anEvent copy;     mouseDown: anEvent copy-=JUAMPI=-hasSubMenu: aMenuMorph  ^submorphs anySatisfy: [:m |  m isMenuItemMorph and: (m hasSubMenu: aMenuMorph) ]-=JUAMPI=-containsPoint: aPoint  | w |  ^(super containsPoint: aPoint) and: [ w := SystemWindow borderWidth.        ((self bounds translateBy: w @ w negated) containsPoint: aPoint) not ]-=JUAMPI=-updateContents  target ifNotNil: [ contents := target perform: nameSelector ]-=JUAMPI=-characterBlockForIndex: index  | line |  line := lines at: (self lineIndexForCharacter: index).  ^(CharacterBlockScanner new text: text textStyle: textStyle) characterBlockAtPoint: nil index: ((index max: line first) min: text size + 1) in: line-=JUAMPI=-type: aType extension: anExtension action: anAction  action := anAction.  type := aType.  extension := anExtension-=JUAMPI=-layoutProperties: newProperties  self layoutProperties == newProperties ifTrue: [ ^self ].  self assureExtension layoutProperties: newProperties-=JUAMPI=-focusChanged  | rects fm |  fm := self focusIndicatorMorph.  fm fillStyle isTransparent ifTrue: [ fm borderWidth > 0 ifTrue: [ rects := fm bounds areasOutside: (fm bounds insetBy: fm borderWidth).              rects do: [:r |  self invalidRect: r ] ] ] ifFalse: [ self invalidRect: fm bounds ]-=JUAMPI=-isFirstColumn  ^container columns first = self-=JUAMPI=-initialize  super initialize.  vertices := Array with: 5 @ 0 with: 20 @ 10 with: 0 @ 20.  closed := true.  smoothCurve := false.  arrows := #none.  self computeBounds.  self beSmoothCurve.  self diamondOval-=JUAMPI=-dropEnabled  ^(self valueOfProperty: #dropEnabled) == true-=JUAMPI=-onImageSelector: anObject  onImageSelector := anObject-=JUAMPI=-defersHaloOnClickTo: aSubMorph  ^true-=JUAMPI=-moveSelectionDown: anInteger event: anEvent  | allEnabledSiblingItems index |  allEnabledSiblingItems := self allEnabledSiblingItems.  index := (allEnabledSiblingItems indexOf: selectedItem ifAbsent: [ 0 + (anInteger negative ifTrue: [ 1 ] ifFalse: [ 0 ]) ]) + anInteger.  allEnabledSiblingItems do: [:unused |  | m |        m := allEnabledSiblingItems atWrap: index.        (m isMenuItemMorph and: [ m isEnabled ]) ifTrue: [ m owner = self owner ifFalse: [ anEvent hand newKeyboardFocus: m owner ].              ^m owner selectItem: m event: anEvent ].        index := index + anInteger sign ].  ^self selectItem: nil event: anEvent-=JUAMPI=-font  ^self listMorph font-=JUAMPI=-testSelectLast  self subclassResponsibility-=JUAMPI=-leftButtonEnabled  ^self wrapScrolling or: [ self visibleTabRange first > 1 ]-=JUAMPI=-getRawLabel  | contentsFit |  contentsFit := label shallowCopy fitContents.  contentsFit extent: (label extent x min: contentsFit extent x) @ contentsFit extent y.  ^contentsFit-=JUAMPI=-doDebug: evt with: menuHandle  | menu |  self world displayWorld.  evt shiftPressed ifTrue: [ self delete.        ^innerTarget inspectInMorphic: evt ].  menu := innerTarget buildDebugMenu: evt hand.  menu     buildTitle: [:menuTitle |  menuTitle           title: (innerTarget externalName asString truncateWithElipsisTo: 40);           withCloseBox;           withPinBox ];     popUpEvent: evt in: self world-=JUAMPI=-moveSelectionDown: direction event: evt  | index |  index := (submorphs indexOf: selectedItem ifAbsent: [ 1 - direction ]) + direction.  submorphs do: [:unused |  | m |        m := submorphs atWrap: index.        (m isMenuItemMorph and: [ m isEnabled ]) ifTrue: [ ^self selectItem: m event: evt ].        index := index + direction sign ].  ^self selectItem: nil event: evt-=JUAMPI=-mouseLeaveDragging: event fromMorph: sourceMorph  ^self notifyMorphsOfEvent: event ofType: #mouseLeaveDragging from: sourceMorph-=JUAMPI=-bestSegments  ^self honeIn: self calcEnoughSegments-=JUAMPI=-findSubmorphBinary: aBlock  ^submorphs findBinary: aBlock do: [:found |  found ] ifNone: [:a :b |   ]-=JUAMPI=-hasExtraSelection  ^extraSelectionBlocks isEmptyOrNil not-=JUAMPI=-internalSpaces: spacesInteger paddingWidth: padWidthInteger  internalSpaces := spacesInteger.  paddingWidth := padWidthInteger-=JUAMPI=-extent: p  p x > p y ifTrue: [ super extent: (p max: (42 @ 8) scaledByDisplayScaleFactor) ] ifFalse: [ super extent: (p max: (8 @ 42) scaledByDisplayScaleFactor) ]-=JUAMPI=-abort: aStringOrText  ^self abort: aStringOrText title: 'Error' translated-=JUAMPI=-prepareForRotating  ^self addFlexShell-=JUAMPI=-wantsDropSelector: aSelector  wantsDropSelector := aSelector-=JUAMPI=-model  ^self complexContents-=JUAMPI=-computeBounds  | oldBounds delta excludeHandles |  vertices ifNil: [ ^self ].  self changed.  oldBounds := bounds.  self releaseCachedState.  bounds := self curveBounds expanded.  self arrowForms do: [:f |  bounds := bounds merge: (f offset extent: f extent) ].  handles ifNotNil: [ self updateHandles ].  (oldBounds notNil and: [ (delta := bounds origin - oldBounds origin) ~= (0 @ 0) ]) ifTrue: [ excludeHandles := IdentitySet new.        handles ifNotNil: [ excludeHandles addAll: handles ].        self submorphsDo: [:each |  (excludeHandles includes: each) ifFalse: [ each position: each position + delta ] ] ].  self layoutChanged.  self changed-=JUAMPI=-hash  ^self morph hash bitXor: (self state hash bitXor: (self icon hash bitXor: self label hash))-=JUAMPI=-newExpander: aString  ^self theme newExpanderIn: self label: aString forAll: #()-=JUAMPI=-rotationDegrees: degrees  self adjustAfter: [ self angle: degrees degreesToRadians negated ]-=JUAMPI=-childrenItems  ^Array new-=JUAMPI=-addMorph: aMorph frame: rectangle  ^self addMorph: aMorph fullFrame: rectangle-=JUAMPI=-deselectAll  | selHolder |  self allNodeMorphs isEmpty ifTrue: [ ^self ].  self emptySelection.  self selectionUpdateFromViewWhile: [ selHolder := self newSelectionHolderWithNodePath: nil.        self listModel selection: selHolder ]-=JUAMPI=-newMenuFor: aModel  ^self theme newMenuIn: self for: aModel-=JUAMPI=-setSelectedMorph: aMorph  selectedWrapper := aMorph complexContents.  self selection: selectedWrapper.  setSelectionSelector ifNotNil: [ model perform: setSelectionSelector with: (selectedWrapper ifNotNil: [ selectedWrapper item ]) ]-=JUAMPI=-drawArrowOn: aCanvas at: endPoint from: priorPoint  | pts spec wingBase |  pts := self arrowBoundsAt: endPoint from: priorPoint.  wingBase := pts size = 4 ifTrue: [ pts third ] ifFalse: [ (pts copyFrom: 2 to: 3) average ].  spec := self valueOfProperty: #arrowSpec ifAbsent: [ PolygonMorph defaultArrowSpec ].  spec x sign = spec y sign ifTrue: [ aCanvas drawPolygon: pts fillStyle: borderColor ] ifFalse: [ aCanvas drawPolygon: pts fillStyle: Color transparent borderWidth: (borderWidth + 1) // 2 borderColor: borderColor ].  ^wingBase-=JUAMPI=-adjacentTo  ^{(self bounds topRight + (5 @ 0)) .   (self bounds topLeft + (2 @ 0))}-=JUAMPI=-testIsBeforeColumn  self subclassResponsibility-=JUAMPI=-replaceFrom: start to: stop with: aText displaying: displayBoolean  text replaceFrom: start to: stop with: aText.  self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop - start + 1)-=JUAMPI=-initForKeystrokes  canMove := true.  lastKeystrokeTime := 0.  lastKeystrokes := ''-=JUAMPI=-defaultTarget: anObject  defaultTarget := anObject-=JUAMPI=-secondName: aString  self item secondName: aString.  self changed: #secondName-=JUAMPI=-pageSizeToString  ^self pageSize asString-=JUAMPI=-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-=JUAMPI=-debugPrint  ^(WriteStream on: (String new: 10))     print: self class;     nextPutAll: ' (';     print: self date;     nextPutAll: ' - ';     print: self bounds;     nextPut: $);     contents-=JUAMPI=-handle: dropStream in: pasteUp dropEvent: anEvent  ^action cull: dropStream cull: pasteUp cull: anEvent-=JUAMPI=-gridModulus  ^self gridSpec extent-=JUAMPI=-listMorphClass  ^MulticolumnLazyListMorph-=JUAMPI=-commentText  ^(self theme newTextIn: self currentWorld text: self item comment)     unlock;     wrapFlag: true;     yourself-=JUAMPI=-vScrollBarMenuButtonPressed: event  ^self scrollBarMenuButtonPressed: event-=JUAMPI=-handlesMouseOver: evt  ^false-=JUAMPI=-isSelected  self model ifNil: [ ^false ].  ^self model perform: (self getStateSelector ifNil: [ ^false ])-=JUAMPI=-taskbarThumbnailExtent  ^self isMinimized ifTrue: [ self fullFrame extent min: self defaultTaskbarThumbnailExtent ] ifFalse: [ super taskbarThumbnailExtent ]-=JUAMPI=-extent: aPoint  | size oldRotationCenter |  oldRotationCenter := self rotationCenter.  size := aPoint x min: aPoint y.  super extent: size @ size.  self rotationCenter: oldRotationCenter-=JUAMPI=-startPoint  ^startPoint-=JUAMPI=-prepareForScaling  ^self-=JUAMPI=-releaseCachedState  super releaseCachedState.  filledForm := nil.  arrowForms := nil.  borderForm := nil.  curveState := nil.  (self hasProperty: #flex) ifTrue: [ self removeProperty: #flex ]-=JUAMPI=-indentationOfLineIndex: lineIndex ifBlank: aBlock  | arrayIndex first last crlf |  crlf := CharacterSet crlf.  arrayIndex := lineIndex.  [ first := (lines at: arrayIndex) first.  first > 1 and: [ crlf includes: (text string at: first - 1) ] ] whileTrue: [ arrayIndex := arrayIndex - 1 ].  last := (lines at: arrayIndex) last.  ^(text string copyFrom: first to: last) indentationIfBlank: aBlock-=JUAMPI=-chooseDirectory: title  ^self chooseDirectory: title path: nil-=JUAMPI=-selectedLocation  | b c x y |  b := self innerBounds.  c := self selectedColor.  x := c saturation * (b width - 1).  y := (1 - c brightness) * (b height - 1).  ^x truncated @ y truncated + b topLeft-=JUAMPI=-grabMorph: aMorph from: formerOwner  | grabbed offset targetPoint grabTransform fullTransform |  self releaseMouseFocus.  grabbed := aMorph.  aMorph keepsTransform ifTrue: [ grabTransform := fullTransform := IdentityTransform new ] ifFalse: [ grabTransform := formerOwner ifNil: [ IdentityTransform new ] ifNotNil: [ formerOwner grabTransform ].        fullTransform := formerOwner ifNil: [ IdentityTransform new ] ifNotNil: [ formerOwner transformFrom: owner ] ].  targetPoint := fullTransform globalPointToLocal: self position.  offset := targetPoint - (grabTransform globalPointToLocal: self position).  grabbed := grabbed transformedBy: grabTransform.  grabbed == aMorph ifFalse: [ grabbed setProperty: #addedFlexAtGrab toValue: true ].  grabbed position: grabbed position - offset asIntegerPoint.  targetOffset := grabbed position - self position.  self addMorphBack: grabbed.  grabbed justGrabbedFrom: formerOwner-=JUAMPI=-firstName  ^firstName-=JUAMPI=-drawBackgroundForRow: row on: aCanvas color: aColor  | frame |  frame := self selectionFrameForRow: row.  aCanvas fillRectangle: frame color: aColor-=JUAMPI=-newPosition: anObject  newPosition := anObject-=JUAMPI=-setLayoutSizingFor: aSymbol  (aSymbol = #left or: [ aSymbol = #right ]) ifTrue: [ self           hResizing: #rigid;           vResizing: #spaceFill ].  (aSymbol = #top or: [ aSymbol = #bottom ]) ifTrue: [ self           hResizing: #spaceFill;           vResizing: #rigid ]-=JUAMPI=-getEnabledSelector  ^getEnabledSelector-=JUAMPI=-addScaleHandle: haloSpec  target shouldFlex ifTrue: [ (self addHandle: haloSpec on: #mouseDown send: #startScale:with: to: self) on: #mouseMove send: #doScale:with: to: self ]-=JUAMPI=-initializeShortcuts: aKMDispatcher  super initializeShortcuts: aKMDispatcher.  aKMDispatcher attachCategory: #MorphFocusNavigation-=JUAMPI=-keyString  ^String streamContents: [:s |  self printKeyStringOn: s ]-=JUAMPI=-drawKeyTextOnAthenCanvas: aCanvas  self keyText ifNil: [ ^self ].  (ToggleMenuItemShortcut owner: self keyText: self keyText) drawOnAthensCanvas: aCanvas-=JUAMPI=-hasDropShadowString  ^self hasDropShadow -> 'show shadow' translated-=JUAMPI=-playCloseSound  self theme windowCloseSound play-=JUAMPI=-monthNameFont  | font boldItalic |  font := LogicalFont familyName: 'Bitmap DejaVu Sans' pointSize: 12.  boldItalic := TextEmphasis italic emphasisCode | TextEmphasis bold emphasisCode.  ^font emphasis: boldItalic-=JUAMPI=-indicateModalChild  (self isMinimized and: [ self isTaskbarPresent ]) ifTrue: [ self worldTaskbar ifNotNil: [:tb |  tb indicateModalChildForMorph: self ] ] ifFalse: [ self flash ]-=JUAMPI=-withAllOwners  ^Array streamContents: [:strm |  self withAllOwnersDo: [:m |  strm nextPut: m ] ]-=JUAMPI=-expandNodePath: aNodePath  self requestView: (MorphTreeChangeRequest expandNodePath: aNodePath)-=JUAMPI=-submorphsSatisfying: aBlock  ^submorphs select: [:m |  (aBlock value: m) == true ]-=JUAMPI=-dragVertex: ix event: evt fromHandle: handle  | p |  p := evt cursorPoint.  handle position: p - (handle extent // 2).  self verticesAt: ix put: p-=JUAMPI=-firstChild  ^firstChild-=JUAMPI=-keyStroke: evt  | view |  editView keyStroke: evt.  (editView scrollByKeyboard: evt) ifTrue: [ ^self ].  (acceptOnCR and: [ evt keyCharacter = Character cr ]) ifFalse: [ (editView navigationKey: evt) ifTrue: [ ^self ] ].  self editor model: editView model.  view := editView.  (acceptOnCR and: [ evt keyCharacter = Character cr ]) ifTrue: [ ^self editor accept ].  super keyStroke: evt.  view textChanged.  view scrollSelectionIntoView.  self doAutoAccept: evt.  view scrollSelectionIntoView-=JUAMPI=-nextSibling  ^nextSibling-=JUAMPI=-drawOn: aCanvas  | borderVertices vertices |  borderVertices := self buildBorderVertices.  vertices := self buildVerticesFrom: borderVertices.  aCanvas drawPolygon: vertices color: self backgroundColor borderWidth: 0 borderColor: Color transparent.  borderVertices overlappingPairsDo: [:start :end |  aCanvas line: start to: end width: 1 color: self borderColor ]-=JUAMPI=-textColor  ^self valueOfProperty: #textColor ifAbsent: [ self theme textColor ]-=JUAMPI=-lastVisibleRowIndex  ^self container lastVisibleRowIndex-=JUAMPI=-widthToDisplayInList: aList  ^self minExtent x-=JUAMPI=-mouseStillDown: evt  self eventHandler ifNotNil: [ self eventHandler mouseStillDown: evt fromMorph: self ]-=JUAMPI=-eventQueue  ^Sensor-=JUAMPI=-container  ^container-=JUAMPI=-privateFullMoveBy: delta  | deltaSlipped griddingMorph |  selectedItems isEmpty ifTrue: [ ^super privateFullMoveBy: delta ].  griddingMorph := self pasteUpMorph.  griddingMorph ifNil: [ ^super privateFullMoveBy: delta ].  deltaSlipped := delta + slippage.  slippage := 0.  super privateFullMoveBy: deltaSlipped.  selectedItems do: [:m |  m position: m position + deltaSlipped ]-=JUAMPI=-toggleRowIndex: index  self deprecated: 'Use #toggleIndex: instead.' transformWith: '`@receiver toggleRowIndex: `@statements' -> '`@receiver toggleIndex: `@statements'.  self toggleIndex: index-=JUAMPI=-buildMetaMenu: evt  | menu |  menu := UIManager default newMenuIn: self for: self.  menu add: 'grab' selector: #grabMorph:.  menu add: 'copy to paste buffer' selector: #copyToPasteBuffer:.  self maybeAddCollapseItemTo: menu.  menu add: 'delete' selector: #dismissMorph:.  menu addLine.  menu add: 'copy text' selector: #clipText.  menu addLine.  menu add: 'go behind' selector: #goBehind.  menu add: 'add halo' selector: #addHalo:.  menu add: 'duplicate' selector: #maybeDuplicateMorph:.  self addEmbeddingMenuItemsTo: menu hand: evt hand.  menu add: 'resize' selector: #resizeMorph:.  self addFillStyleMenuItems: menu hand: evt hand.  self addDropShadowMenuItems: menu hand: evt hand.  self addLayoutMenuItems: menu hand: evt hand.  menu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().  menu addLine.  menu add: 'inspect' selector: #inspectAt:event: argument: evt position.  menu add: 'explore' selector: #inspect.  menu lastItem icon: (self iconNamed: #smallInspectItIcon).  menu addLine.  menu add: 'show actions' selector: #showActions.  menu addLine.  self addDebuggingItemsTo: menu hand: evt hand.  self addCustomMenuItems: menu hand: evt hand.  ^menu-=JUAMPI=-withoutListWrapper  ^complexContents withoutListWrapper-=JUAMPI=-wantsDropSelector: aSymbol  wantsDropSelector := aSymbol-=JUAMPI=-shouldDraw  ^self fillStyle isTransparent not-=JUAMPI=-justified  self changeAlignment: #justified-=JUAMPI=-elementWrapped: object  ^self wrapSelector ifNotNil: [:selector |  self model perform: selector with: object ] ifNil: [ object ]-=JUAMPI=-testUpdateTaskBarShouldContainsTaskbarTasks  taskbar := self.  world := self.  world addWindow.  taskbar updateTasks.  self assert: (taskbar tasks first isKindOf: TaskbarTask)-=JUAMPI=-hasProperty: aSymbol  | property |  otherProperties ifNil: [ ^false ].  property := otherProperties at: aSymbol ifAbsent: [  ].  property ifNil: [ ^false ].  property == false ifTrue: [ ^false ].  ^true-=JUAMPI=-setTextStyle: aTextStyle  textStyle := aTextStyle.  self     releaseCachedState;     changed-=JUAMPI=-forwardDirection: newDirection  self setProperty: #forwardDirection toValue: newDirection-=JUAMPI=-newToolDockingBar  ^self theme newToolDockingBarIn: self-=JUAMPI=-setDirectionFrom: aPoint  | delta degrees |  delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.  degrees := delta degrees + 90.0.  self forwardDirection: (degrees \\ 360) rounded-=JUAMPI=-positionSubmorphs  self submorphsDo: [:aMorph |  aMorph snapToEdgeIfAppropriate ]-=JUAMPI=-hasCollapseBox  ^collapseBox notNil-=JUAMPI=-newYesButton  ^self newYesButtonFor: self-=JUAMPI=-calculateExactVisibleRows  | rowIndex maxHeight height |  self table hasDataSource ifFalse: [ ^super calculateExactVisibleRows ].  rowIndex := self table showIndex max: 1.  height := 0.  maxHeight := self height.  headerRow ifNotNil: [ maxHeight := maxHeight - headerRow height ].  [ height < maxHeight and: [ rowIndex <= self table dataSource numberOfRows ] ] whileTrue: [ height := height + (self table dataSource rowHeight: rowIndex).        rowIndex := rowIndex + 1 ].  ^rowIndex - self table showIndex-=JUAMPI=-ghostText  ^'Search...'-=JUAMPI=-spawnBalloonFor: aMorph  aMorph showBalloon: aMorph balloonText hand: self-=JUAMPI=-wantsDirectionHandles  ^self valueOfProperty: #wantsDirectionHandles ifAbsent: [ false ]-=JUAMPI=-fitTargetBoundsInOwner: aRect  | ownerMinExt targetOwner |  targetOwner := self target owner ifNil: [ ^self ].  ownerMinExt := targetOwner minExtent.  ownerMinExt x > self target owner width ifTrue: [ self edgeName = #left ifTrue: [ self target bounds: ((aRect left + (ownerMinExt x - targetOwner width)) @ aRect top extent: (aRect width - (ownerMinExt x - targetOwner width)) @ aRect height) ] ifFalse: [ self target bounds: (aRect origin extent: (aRect width - (ownerMinExt x - targetOwner width)) @ aRect height) ] ].  ownerMinExt y > self target owner height ifTrue: [ self edgeName = #top ifTrue: [ self target bounds: (aRect left @ (aRect top + (ownerMinExt y - targetOwner height)) extent: aRect width @ (aRect height - (ownerMinExt y - targetOwner height))) ] ifFalse: [ self target bounds: (aRect origin extent: aRect width @ (aRect height - (ownerMinExt y - targetOwner height))) ] ]-=JUAMPI=-hasChildren  ^self children size ~= 0-=JUAMPI=-value  ^progressBar value-=JUAMPI=-translateBy: delta  position := position + delta.  startPoint := startPoint + delta-=JUAMPI=-showAbout  self theme longMessageIn: self text: self aboutText title: self aboutTitle-=JUAMPI=-colorForInsets  (color isColor and: [ color isTransparent and: [ owner notNil ] ]) ifTrue: [ ^owner colorForInsets ].  ^color colorForInsets-=JUAMPI=-clipSubmorphs: aBool  self invalidRect: self fullBounds.  aBool == self clipSubmorphs ifFalse: [ self assureExtension.        extension clipSubmorphs: aBool.        self invalidRect: self fullBounds ]-=JUAMPI=-getMenuSelector: aSymbol  getMenuSelector := aSymbol-=JUAMPI=-readyToBeDisplayed  -=JUAMPI=-isDeActivated  ^true-=JUAMPI=-allMorphsDo: aBlock  submorphs do: [:m |  m allMorphsDo: aBlock ].  aBlock value: self-=JUAMPI=-canDrawBorder: aBorderStyle  ^true-=JUAMPI=-sliderColor: aColor  | buttonColor |  super sliderColor: aColor.  self lastPaneColor: aColor.  buttonColor := self thumbColor.  upButton color: buttonColor.  downButton color: buttonColor.  slider color: buttonColor slightlyLighter.  pagingArea     fillStyle: self normalFillStyle;     borderStyle: self normalBorderStyle.  (self theme scrollbarPagingAreaCornerStyleIn: self window) = #rounded ifTrue: [ self fillStyle: self normalButtonFillStyle ] ifFalse: [ self fillStyle: self normalFillStyle ].  self borderWidth: 0.  ^self adoptGradientColor: aColor-=JUAMPI=-putLabelItemsInLabelArea  labelArea ifNotNil: [ stripes ifNotNil: [ stripes do: [:stripe |  labelArea addMorph: stripe ] ].        closeBox ifNotNil: [ labelArea addMorph: closeBox ].        menuBox ifNotNil: [ labelArea addMorph: menuBox ].        collapseBox ifNotNil: [ labelArea addMorph: collapseBox ].        label ifNotNil: [ labelArea addMorph: label ] ]-=JUAMPI=-simulateKeyStroke: aCharacterOrShortcut  | shortcut |  shortcut := aCharacterOrShortcut asKeyCombination.  self handleEvent: (KeyboardEvent new setType: #keystroke buttons: shortcut modifier eventCode position: self position keyValue: shortcut key asciiValue charCode: shortcut key asciiValue hand: self activeHand stamp: DateAndTime now)-=JUAMPI=-intersects: aRectangle  ^self fullBoundsInWorld intersects: aRectangle-=JUAMPI=-newPreviewMorph  ^Morph new     color: Color transparent;     extent: self defaultPreviewExtent;     yourself-=JUAMPI=-mouseMoveOnMultiple: event  | oldIndex oldVal row |  canMove ifFalse: [ ^self ].  event position y < self top ifTrue: [ scrollBar scrollUp: 1.        row := self rowAtLocation: scroller topLeft + (1 @ 1) ] ifFalse: [ row := event position y > self bottom ifTrue: [ scrollBar scrollDown: 1.              self rowAtLocation: scroller bottomLeft + (1 @ -1) ] ifFalse: [ self rowAtLocation: event position ] ].  row = 0 ifTrue: [ ^super mouseDown: event ].  (self potentialDropItem notNil and: [ self dropEnabled ]) ifTrue: [ ^self ].  dragOnOrOff ifNil: [ dragOnOrOff := (self listSelectionAt: row) not ].  oldIndex := self getCurrentSelectionIndex.  oldIndex ~= 0 ifTrue: [ oldVal := self listSelectionAt: oldIndex ].  oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].  self listSelectionAt: row put: dragOnOrOff.  row changed-=JUAMPI=-drawSubmorphsOn: aCanvas  super drawSubmorphsOn: aCanvas.  self drawLinesOn: aCanvas-=JUAMPI=-addPaneSplitters  self removePaneSplitters.  self addPaneVSplitters.  self addPaneHSplitters.  self linkSplittersToSplitters-=JUAMPI=-dropFiles: anEvent  | numFiles |  numFiles := anEvent contents.  1 to: numFiles do: [:i |  | aFileReference handler |        aFileReference := anEvent requestDropReference: i.        handler := ExternalDropHandler lookupExternalDropHandler: aFileReference.        handler ifNotNil: [ handler handle: aFileReference in: self dropEvent: anEvent ] ]-=JUAMPI=-bounds: aRectangle  | size |  size := aRectangle width min: aRectangle height.  super bounds: (Rectangle origin: aRectangle origin extent: size @ size)-=JUAMPI=-searchStrategy  ^searchStrategy ifNil: [ #default ]-=JUAMPI=-textEntry: aStringOrText title: aString entryText: defaultEntryText  ^self theme textEntryIn: self text: aStringOrText title: aString entryText: defaultEntryText-=JUAMPI=-is: anIndex afterColumn: aColumnIndex  ^anIndex second > aColumnIndex-=JUAMPI=-minWidth  ^self valueOfProperty: #minWidth ifAbsent: [ 2 ]-=JUAMPI=-controls  ^controls-=JUAMPI=-rowIndexToVerticalScrollBarValue: aNumber  | numberOfRows |  numberOfRows := self numberOfRows - self container calculateMinVisibleRows.  ^(numberOfRows = 0 or: [ aNumber <= 1 ]) ifTrue: [ 0.0 ] ifFalse: [ ((aNumber / numberOfRows) asFloat max: 0.0) min: 1.0 ]-=JUAMPI=-image: anImage  ^self image: anImage size: anImage extent-=JUAMPI=-allSubmorphNamesDo: nameBlock  ^self-=JUAMPI=-dragItemSelector  ^dragItemSelector-=JUAMPI=-pressedImageSelector  ^pressedImageSelector-=JUAMPI=-minCellSize  ^0-=JUAMPI=-vScrollbar  ^vScrollbar-=JUAMPI=-showsNever  ^self showState == #never-=JUAMPI=-index: anIndex  index := anIndex-=JUAMPI=-updateValue  self model ifNotNil: [ self getValueSelector ifNotNil: [ self sliderMorph ifNotNil: [:sm |  sm scaledValue: self value.                    self                       changed: #minEnabled;                       changed: #maxEnabled ] ] ]-=JUAMPI=-getEnabledSelector: aSymbol  getEnabledSelector := aSymbol.  self updateEnabled-=JUAMPI=-newRow: controls  ^self theme newRowIn: self for: controls-=JUAMPI=-handleUpdate: aMorphChangedAnnouncement  ^aMorphChangedAnnouncement deliverTo: self-=JUAMPI=-testIndexFromPosition  self assert: (strategy indexFromPosition: #(3 7)) equals: #(3 7)-=JUAMPI=-printOn: aStream  aStream nextPutAll: 'Node('.  self item printOn: aStream.  aStream nextPut: $)-=JUAMPI=-getListSizeSelector: aSymbol  getListSizeSelector := aSymbol-=JUAMPI=-icon  ^icon-=JUAMPI=-message: aStringOrText  ^self message: aStringOrText title: 'Information' translated-=JUAMPI=-tabs  ^tabs-=JUAMPI=-optimalExtent  ^(Paragraph new     compose: text style: textStyle copy from: 1 in: (0 @ 0 extent: 9999999 @ 9999999);     adjustRightX;     extent) + (self borderWidth * 2) + (2 @ 0)-=JUAMPI=-tabRemovedFromSelection: aTab  self setMultipleContents-=JUAMPI=-drawLineFrom: startPoint to: stopPoint on: aCanvas  | lineColor |  lineColor := (stopPoint truncated quadrantOf: startPoint truncated) > 2 ifTrue: [ self topLeftColor ] ifFalse: [ self bottomRightColor ].  aCanvas line: startPoint to: stopPoint width: (self width - self margin max: 0) color: lineColor-=JUAMPI=-beCellSelection  self selectionModeStrategy: (FTCellSelectionModeStrategy table: self)-=JUAMPI=-newScrollPaneFor: aMorph  ^self theme newScrollPaneIn: self for: aMorph-=JUAMPI=-currentNodelist  ^self nodeList copyFrom: self currentPageFirstIndex to: self currentPageLastIndex-=JUAMPI=-removeDependent: anObject  self announcer unsubscribe: anObject-=JUAMPI=-mouseOverAllowed  ^mouseOverAllowed ifNil: [ mouseOverAllowed := false ]-=JUAMPI=-unexpandAllChildOf: anItem  anItem children do: [:item |  item isExpanded ifTrue: [ self unexpandAllChildOf: item ].        item collapse ] displayingProgress: [:each |  'Rearanging ' , each name ]-=JUAMPI=-addCustomHaloMenuItems: aMenu hand: aHandMorph  self addCustomMenuItems: aMenu hand: aHandMorph-=JUAMPI=-passiveDisabledOverDownFillStyle: aFillStyle  self stateMap atPath: #(passive disabled over down) put: aFillStyle.  self changed-=JUAMPI=-handlesMouseOver: evt  self table ifNotNil: [:table |  ^table selectionModeStrategy allowsCellSelection ].  ^false-=JUAMPI=-captureEventsUntil: aBlock  | release |  release := false.  captureBlock := [:evt |  release := aBlock value: evt ].  [ [ self world doOneCycle.  release ] whileFalse ] ensure: [ captureBlock := nil ]-=JUAMPI=-table: anObject  table := anObject-=JUAMPI=-makeMeVisible  self world extent > (0 @ 0) ifFalse: [ ^self ].  ((self world bounds insetBy: (0 @ 0 corner: self labelHeight asPoint)) containsPoint: self position) ifTrue: [ ^self ].  self isCollapsed ifTrue: [ self position: (RealEstateAgent assignCollapsePointFor: self) ] ifFalse: [ self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent world: self world) topLeft ]-=JUAMPI=-allowsRowSelection  ^false-=JUAMPI=-offerWindowMenu  | aMenu |  aMenu := self buildWindowMenu.  aMenu     addLine;     add: 'Grab window...' target: self selector: #grabWindow.  aMenu lastItem icon: (self iconNamed: #smallWindowIcon).  self tabGroup page ifNotNil: [:page |  page model addModelItemsToWindowMenu: aMenu ].  aMenu popUpEvent: self currentEvent in: self world-=JUAMPI=-matchesTypes: types  (self type isNil or: [ types isNil ]) ifTrue: [ ^false ].  ^types anySatisfy: [:mimeType |  mimeType beginsWith: self type ]-=JUAMPI=-numberOfLines  ^lines size-=JUAMPI=-interactionState: aSymbol  -=JUAMPI=-collapseAll  self subclassResponsibility-=JUAMPI=-colorForSelection: primarySelection  ^primarySelection ifTrue: [ self selectionColor ] ifFalse: [ self secondarySelectionColor ]-=JUAMPI=-minimumSelection  ^1-=JUAMPI=-stayUp  ^false-=JUAMPI=-preferredButtonCornerStyle  ^#square-=JUAMPI=-adoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self hScrollbar adoptPaneColor: paneColor.  self vScrollbar adoptPaneColor: paneColor-=JUAMPI=-moveShowIndexTo: arg  | index oldIndex |  index := self selectionModeStrategy rowIndexFrom: arg.  oldIndex := showIndex.  self basicMoveShowIndexTo: index.  self verticalScrollBar value: (self rowIndexToVerticalScrollBarValue: index).  self refresh.  self announceScrollChangedFrom: oldIndex to: index-=JUAMPI=-setOptimalResizing  self hResizing: #rigid.  self vResizing: #rigid-=JUAMPI=-= other  ^other class == self class and: [ other anchoredMorph == anchoredMorph ]-=JUAMPI=-menu  | menu |  menu := UIManager default newMenuIn: self currentWorld for: self.  menu buildTitle: [:menuTitle |  menuTitle onlyCloseAndPinable ].  menu add: 'Why you see this menu' target: self selector: #fallbackMenuExplanations.  menu add: 'Debug' target: self selector: #debug.  menu addLine.  client fallbackMenuOn: menu.  ^menu-=JUAMPI=-expandAll  rootItem expandAll.  self tableRefresh-=JUAMPI=-centeredAlert: aStringOrText title: aString configure: aBlock  ^self theme centeredAlertIn: self text: aStringOrText title: aString configure: aBlock-=JUAMPI=-newStateForSelected: aBoolean  ^TabEnabled tab: self tab-=JUAMPI=-useGradientFill  | fill color1 color2 |  self fillStyle isGradientFill ifTrue: [ ^self ].  color1 := self color asColor.  color2 := color1 negated.  fill := GradientFillStyle ramp: {(0.0 -> color1) .         (1.0 -> color2)}.  fill origin: self topLeft.  fill direction: 0 @ self bounds extent y.  fill normal: self bounds extent x @ 0.  fill radial: false.  self fillStyle: fill-=JUAMPI=-optionalOperations  pattern isEmptyOrNil ifTrue: [ self unexpandAllChildOf: dataSource rootItem.        ^#() ] ifFalse: [ ^nil ]-=JUAMPI=-imageMorph: anObject  imageMorph := anObject-=JUAMPI=-initialize  super initialize.  self initForKeystrokes.  self on: #mouseMove send: #mouseStillDown:onItem: to: self-=JUAMPI=-adjustAfter: changeBlock  changeBlock value.  self chooseSmoothing.  self layoutChanged.  owner ifNotNil: [ owner invalidRect: bounds ]-=JUAMPI=-userString  ^text string-=JUAMPI=-newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel help: helpText  ^self newMorphDropListFor: aModel list: listSel getSelected: getSel setSelected: setSel getEnabled: enabledSel useIndex: true help: helpText-=JUAMPI=-computeAltFramedColors  | base light dark w hw colorArray param |  base := self color asColor.  light := Color white.  dark := Color black.  w := self width isPoint ifTrue: [ self width x max: self width y ] ifFalse: [ self width ].  w := w asInteger.  w = 1 ifTrue: [ ^{(base mixed: 0.5 with: light) .         (base mixed: 0.5 with: dark)} ].  colorArray := Array new: w.  hw := w // 2.  0 to: hw - 1 do: [:i |  param := 0.5 + (i asFloat / hw * 0.5).        colorArray at: i + 1 put: (base mixed: param with: dark).        colorArray at: w - i put: (base mixed: param with: light) ].  w odd ifTrue: [ colorArray at: hw + 1 put: base ].  ^colorArray , colorArray-=JUAMPI=-filterClass: aFTFilterClass  filterClass := aFTFilterClass-=JUAMPI=-doubleClickTimeout  dblClickTimeoutSelector ifNotNil: [ clickClient perform: dblClickTimeoutSelector with: firstClickDown ]-=JUAMPI=-first: firstCharBlock last: lastCharBlock color: aColor  first := firstCharBlock.  last := lastCharBlock.  color := aColor-=JUAMPI=-wrapCentering  ^#topLeft-=JUAMPI=-initializeColumsFrom: aModel  self columns: aModel columns-=JUAMPI=-chooseColor  ^self chooseColor: Color black-=JUAMPI=-wasHandled  ^false-=JUAMPI=-addDependent: aDependent  dependents := #().  super addDependent: aDependent-=JUAMPI=-hsvaMorph: anObject  hsvaMorph := anObject-=JUAMPI=-roundedCorners  self isAdheringToTop ifTrue: [ ^#(2 3) ].  self isAdheringToBottom ifTrue: [ ^#(1 4) ].  self isAdheringToLeft ifTrue: [ ^#(3 4) ].  self isAdheringToRight ifTrue: [ ^#(1 2) ].  ^#(1 2 3 4)-=JUAMPI=-predecessor: pred successor: succ  predecessor := pred.  successor := succ-=JUAMPI=-blueButtonPressed  ^buttons anyMask: self class blueButton-=JUAMPI=-iconPosition  ^iconPosition ifNil: [ iconPosition := #left ]-=JUAMPI=-class: aBehavior variable: aString  self changeClass: aBehavior.  variable := aString-=JUAMPI=-hasPermutedArguments  ^hasPermutedArguments ifNil: [ hasPermutedArguments := super hasPermutedArguments ] ifNotNil: [ hasPermutedArguments ]-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' classNames: '.  classNames asArray storeOn: aStream.  aStream nextPut: $)-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' addMethod: ''';     nextPutAll: source;     nextPutAll: ''' toClass: '.  class storeOn: aStream.  aStream nextPutAll: ' inProtocols: '.  protocols storeOn: aStream.  aStream nextPut: $)-=JUAMPI=-storeOn: aStream  super storeOn: aStream.  aStream nextPutAll: ' class'-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' sourceCode: '''.  sourceCode storeOn: aStream.  aStream nextPutAll: ''' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' withProtocol: #';     nextPutAll: protocol asString.  aStream nextPut: $)-=JUAMPI=-category  ^category-=JUAMPI=-testClassVariable  | refactoring |  refactoring := (RBPullUpVariableTransformation classVariable: #RecursiveSelfRule class: #RBDummyLintRuleTest) asRefactoring.  [ refactoring transform ] on: RBRefactoringError do: [:e |  e resume ].  self assert: ((refactoring model classNamed: #RBDummyLintRuleTest) directlyDefinesClassVariable: #RecursiveSelfRule).  self deny: ((refactoring model classNamed: #RBTransformationDummyRuleTest) directlyDefinesClassVariable: #RecursiveSelfRule)-=JUAMPI=-asEpiceaEvent  ^EpRenameMethodRefactoring renameMethod: oldSelector in: class name to: newSelector-=JUAMPI=-changeForMetaclass: aClassName selector: aSelector  changes reverseDo: [:each |  | change |        change := each changeForMetaclass: aClassName selector: aSelector.        change notNil ifTrue: [ ^change ] ].  ^nil-=JUAMPI=-formNameFor: aSelector  | method keywords arguments |  method := class methodFor: aSelector.  keywords := method parseTree keywords asOrderedCollection ifNil: [ '' ].  arguments := method parseTree arguments ifNil: [ '' ].  (keywords isNotEmpty and: [ arguments isNotEmpty ]) ifTrue: [ ^String streamContents: [:s |  keywords with: arguments do: [:keyword :arg |  s nextPutAll: keyword , ' ' , arg name , ' ' ] ] ] ifFalse: [ ^aSelector asString ]-=JUAMPI=-computeLiteralsForSelector: aSelector in: aClass  | method |  method := aClass compiledMethodAt: aSelector ifAbsent: [ nil ].  method ifNil: [ ^self ].  self addLiteralsFor: method-=JUAMPI=-classVariableNames: aCollectionOfStrings  classVariableNames := (aCollectionOfStrings collect: [:each |  each asSymbol ]) asOrderedCollection-=JUAMPI=-visitBlockNode: aBlockNode  aBlockNode arguments do: [:arg |  self replace: arg with: 'tempMatch' , temporaries asString.        temporaries := temporaries + 1 ].  super visitBlockNode: aBlockNode-=JUAMPI=-renameClassVariable: oldName to: newName in: aClass  ^RBRenameClassVariableChange rename: oldName to: newName in: aClass-=JUAMPI=-checkBrowseOccurrenceOf: selector in: aRBMethod  self refactoringError: ('Possible call to <2s> in <1p><n>Browse references?' expandMacrosWith: aRBMethod modelClass with: selector) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: selector) ]-=JUAMPI=-modifiesCollection  | collection |  collection := (1 to: 10) asOrderedCollection.  collection do: [:each |  each > 5 ifTrue: [ collection remove: each ] ].  ^collection-=JUAMPI=-transform  class compile: source classified: protocols-=JUAMPI=-replaceReferences  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter replaceTree: assignmentNode variable withTree: assignmentNode value.  definingNode removeTemporaryNamed: assignmentNode variable name.  rewriter executeTree: definingNode-=JUAMPI=-pragma: aPragmaDefinition inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  pragma := aPragmaDefinition-=JUAMPI=-testNonExistantName  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-initialize  super initialize.  changes := OrderedCollection new-=JUAMPI=-buildArgumentSearch  self createArgumentSearchWith: 'aSmalllintContext' selectors: #(#checkMethod: #checkClass:) inClass: RBBasicLintRuleTestData-=JUAMPI=-testRefactoring  | refactoring selector class |  selector := 'selectorNotReferenced' asSymbol.  refactoring := (RBRemoveMethodTransformation selector: selector from: #RBRefactoryTestDataApp) asRefactoring.  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class directlyDefinesMethod: selector).  refactoring transform.  self deny: (class directlyDefinesMethod: selector)-=JUAMPI=-transform  | source tree formatted |  self model allClassesDo: [:class |  class selectors do: [:selector |  (self model environment includesSelector: selector in: class realClass) ifTrue: [ source := class sourceCodeFor: selector.                    source ifNotNil: [ tree := class parseTreeFor: selector.                          tree ifNotNil: [ formatted := tree formattedCode.                                (source ~= formatted and: [ (self parserClass parseMethod: formatted) = tree ]) ifTrue: [ class compile: formatted classified: (class protocolsFor: selector) ] ] ] ] ] ]-=JUAMPI=-accept: presenter  self okToChange ifFalse: [ ^self ].  [ change do: [:aChange |  RBRefactoryChangeManager instance performChange: aChange ] ] asJob     title: 'Refactoring';     run.  presenter     beOk;     close-=JUAMPI=-testRenameClass  | refactoring class |  refactoring := RBRenameClassRefactoring rename: (testingEnvironment at: ('RBClass' , 'ToRename') asSymbol) to: 'RBNew' , 'ClassName' asSymbol.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: ('RBNew' , 'ClassName') asSymbol) parseTreeFor: #method1) equals: (self parseMethod: 'method1	^self method2').  self deny: (refactoring model includesClassNamed: ('RBClass' , 'ToRename') asSymbol).  class := refactoring model classNamed: ('RBSubclass' , 'OfClassToRename') asSymbol.  self assert: class superclass equals: (refactoring model classNamed: ('RBNew' , 'ClassName') asSymbol).  self assert: (class parseTreeFor: #symbolReference) equals: (self parseMethod: 'symbolReference								^#RBNewClassName').  self assert: (class parseTreeFor: #reference) equals: (self parseMethod: 'reference								^RBNewClassName new')-=JUAMPI=-testRemoveClassVariable  | change |  change := changes removeClassVariable: 'ClassVar' from: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change variable equals: 'ClassVar'.  self universalTestFor: change-=JUAMPI=-testObjectIsNotAbstract  self deny: objectClass isAbstract.  self deny: objectClass classSide isAbstract-=JUAMPI=-isOkEnabled  ^argumentsList isEmpty-=JUAMPI=-pullUp: selectorCollection from: aClass to: aSuperClass  self setOption: #superClass toUse: [:ref |   ].  class := self classObjectFor: aClass.  targetSuperclass := self classObjectFor: aSuperClass.  selectors := selectorCollection.  removeDuplicates := false-=JUAMPI=-asUndoOperation  ^self class selector: self selector in: self changeClass classified: self oldProtocol-=JUAMPI=-signalFailure: aString  self classForTestResult failure signal: aString-=JUAMPI=-findMessageNodes  beforeNodes := cascadeNode messages select: [:each |  each stop <= selectedInterval first ].  afterNodes := cascadeNode messages select: [:each |  selectedInterval last <= each keywordsPositions first ].  (beforeNodes isEmpty or: [ afterNodes isEmpty ]) ifTrue: [ self refactoringFailure: 'Splitting a cascade into the whole cascade and an empty one is pointless' ].  beforeNodes size + afterNodes size = cascadeNode messages size ifFalse: [ self refactoringFailure: 'To set the split boundary place the cursor inbetween two cascaded messages' ]-=JUAMPI=-reparentClasses: aRBClassCollection to: newClass  aRBClassCollection do: [:aClass |  self defineClass: (self replaceClassNameIn: aClass definitionString to: newClass name) ]-=JUAMPI=-allSubclasses  | allSubclasses index |  index := 1.  allSubclasses := OrderedCollection withAll: self subclasses.  [ index <= allSubclasses size ] whileTrue: [ allSubclasses addAll: (allSubclasses at: index) subclasses.        index := index + 1 ].  ^allSubclasses-=JUAMPI=-definingClass  ^classVariable ifTrue: [ class classSide ] ifFalse: [ class ]-=JUAMPI=-realName: aSymbol  self subclassResponsibility-=JUAMPI=-testBadName  self shouldFail: (RBExtractToTemporaryRefactoring extract: (14 to: 23) to: 'a sdf' from: #testMethod in: RBRefactoryTestDataApp)-=JUAMPI=-nonUnaryAccessingMessageStatementMethodWithoutReturn: anObject  self value-=JUAMPI=-sendsDifferentSuper  super printString-=JUAMPI=-newMethodName  | methodName newAttempt |  newAttempt := newSelector isNil.  methodName := RBMethodName new.  methodName arguments: arguments.  newSelector ifNotNil: [ methodName selector: newSelector ].  [ newAttempt ] whileTrue: [ methodName := (RBMethodNameEditor openOn: methodName) methodName.        methodName ifNil: [ newAttempt := false ] ifNotNil: [:newMethodName |  newSelector := newMethodName selector.              newAttempt := newSelector isNil.              (newSelector isString and: [ RBScanner isSelector: newSelector ]) ifFalse: [ self inform: newSelector asString , ' is not a valid selector.'.                    newSelector := nil ].              (self definingClass directlyDefinesLocalMethod: newSelector) ifTrue: [ self inform: newSelector , ' is already defined in ' , class asString.                    newSelector := nil ] ] ].  ^methodName-=JUAMPI=-performComponentRefactoring: aRefactoring  aRefactoring copyOptionsFrom: self options.  aRefactoring primitiveExecute-=JUAMPI=-withAllSubclasses  ^self allSubclasses     add: self;     yourself-=JUAMPI=-selector: aSelector in: aClass classified: aProtocol  selector := aSelector.  self changeClass: aClass.  self protocols: aProtocol-=JUAMPI=-preconditions  ^RBCondition withBlock: [ (class hierarchyDefinesInstanceVariable: variableName) ifFalse: [ self refactoringFailure: 'No subclass defines ' , variableName ].        (class subclasses anySatisfy: [:each |  (each directlyDefinesInstanceVariable: variableName) not ]) ifTrue: [ self refactoringWarning: 'Not all subclasses have an instance variable named ' , variableName , '.' ].        true ]-=JUAMPI=-createTemporariesInExtractedMethodFor: assigned  assigned do: [:each |  extractedParseTree body addTemporaryNamed: each ]-=JUAMPI=-testMoveMethodIntoArgument  | refactoring class |  self proceedThroughWarning: [ refactoring := RBMoveMethodRefactoring selector: #checkMethod: class: RBTransformationRuleTestData variable: 'aSmalllintContext'.        self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.        self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: #RBSmalllintContext)).        self setupMethodNameFor: refactoring toReturn: #foo:.        self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext aSmalllintContext foo: self').  self assert: ((refactoring model classNamed: #RBSmalllintContext) parseTreeFor: #foo:) equals: (self parseMethod: 'foo: transformationRule	transformationRule class: self selectedClass.	(transformationRule rewriteRule executeTree: self parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: self protocols]]').  self assert: (class parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (class parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject class := anObject').  self assert: (class classSide parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (class classSide parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (class parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (class parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject builder := anObject').  self assert: (class parseTreeFor: #rewriteRule) equals: (self parseMethod: 'rewriteRule ^rewriteRule').  self assert: (class parseTreeFor: #rewriteRule:) equals: (self parseMethod: 'rewriteRule: anObject rewriteRule := anObject')-=JUAMPI=-return: anExpression inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  returnValue := anExpression-=JUAMPI=-primitiveExecute  self changeClass organization removeProtocol: (self changeClass organization protocolNamed: protocol)-=JUAMPI=-initialize  super initialize.  modelFactory := RBClassModelFactory new.  changeFactory := RBRefactoryChangeManager changeFactory-=JUAMPI=-buildTransformations  ^transformations ifNil: [ transformations := OrderedCollection with: (RBAddMethodTransformation sourceCode: (String streamContents: [:code |  code                             nextPutAll: 'new';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: 'self deprecated: ''Use superclass '' on: ''4 May 2016'' in: #Pharo60.';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ super new' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddMethodTransformation sourceCode: (String streamContents: [:code |  code                             nextPutAll: 'deprecated';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ true' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddMethodTransformation sourceCode: (String streamContents: [:code |  code                             nextPutAll: 'systemIcon';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ Smalltalk ui icons iconNamed: #packageDelete' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddClassCommentTransformation comment: 'Deprecated!!! Use superclass' in: className) ]-=JUAMPI=-renameReferences  | replacer subclasses |  replacer := RBParseTreeRewriter rename: variableName to: newVariableName handler: [ self refactoringError: ('<1s> is already defined as a method					or block temporary <n> variable in this class or one of its subclasses' expandMacrosWith: newVariableName) ].  subclasses := (self model classObjectFor: className) withAllSubclasses.  isClassVariable ifTrue: [ subclasses addAll: self definingClass withAllSubclasses ].  self model convertClasses: subclasses select: [:aClass |  self referencesFor: aClass ] using: replacer-=JUAMPI=-renameSuperclassOfSubclasses  | replacement |  replacement := self model classNamed: newName.  self model reparentClasses: deprecatedClass subclasses to: replacement-=JUAMPI=-environmentForInstanceVariable: aString in: aClass  | selectorEnvironment isReader isWriter |  selectorEnvironment := RBSelectorEnvironment onEnvironment: self.  selectorEnvironment addSearchString: aString.  isReader := isWriter := false.  ((instanceVariables at: aClass name ifAbsent: [ #() ]) includes: aString) ifTrue: [ isReader := true.        isWriter := true ].  ((instanceVariableWriters at: aClass name ifAbsent: [ #() ]) includes: aString) ifTrue: [ isWriter := true ].  ((instanceVariableReaders at: aClass name ifAbsent: [ #() ]) includes: aString) ifTrue: [ isReader := true ].  aClass withAllSubAndSuperclassesDo: [:each |  isWriter ifTrue: [ (each whichSelectorsStoreInto: aString) do: [:sel |  selectorEnvironment addClass: each selector: sel ] ].        isReader ifTrue: [ (each whichSelectorsRead: aString) do: [:sel |  selectorEnvironment addClass: each selector: sel ] ] ].  ^selectorEnvironment-=JUAMPI=-executeNotifying: aBlock  | undo |  self addNewVariable.  self copyOldValuesToNewVariable.  undo := super executeNotifying: aBlock.  undo     oldName: newName;     newName: oldName.  self removeOldVariable.  ^undo-=JUAMPI=-removeClasses  classNames do: [:each |  self model removeClassNamed: each ]-=JUAMPI=-testMethodDoesNotExist  self shouldFail: (RBRemoveAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #method inClass: #RBRemoveAssignmentTransformationTest) asRefactoring-=JUAMPI=-testTransform  | transformation |  transformation := (RBAddProtocolTransformation new protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  self assert: transformation model changes changes size equals: 1-=JUAMPI=-left: aCondition right: aCondition2  left := aCondition.  right := aCondition2.  failed := #unknownFailed-=JUAMPI=-booleanPrecedence  ^(true & 4) = 45-=JUAMPI=-endTrueFalse  self isVariable ifTrue: [ self printString.        self isVariable printString ] ifFalse: [ self printString.        ^4 ]-=JUAMPI=-getNewSelector  | tree |  (class directlyDefinesMethod: oldSelector) ifFalse: [ self refactoringFailure: 'Method doesn''t exist' ].  tree := class parseTreeFor: oldSelector.  tree ifNil: [ self refactoringFailure: 'Cannot parse sources' ].  argument ifNil: [ self refactoringFailure: 'This method does not have an argument' ].  parameterIndex := tree argumentNames indexOf: argument ifAbsent: [ self refactoringFailure: 'Select a parameter!!' ].  permutation := (1 to: oldSelector numArgs) copyWithout: parameterIndex.  newSelector := self computeNewSelector-=JUAMPI=-transform  | original replacement protocols |  self model allClassesDo: [:class |  class selectors do: [:selector |  original := class sourceCodeFor: selector.              replacement := self execute: original.              replacement = original ifFalse: [ (self parseMethod: replacement) ifNotNil: [ protocols := class protocolsFor: selector.                          (self parseSelector: replacement) = selector ifFalse: [ class removeMethod: selector ].                          class compile: replacement classified: protocols ] ] ] ]-=JUAMPI=-assertCollection: actual equals: expected  ^self assert: expected = actual description: [ self comparingCollectionBetween: actual and: expected ]-=JUAMPI=-asSelectorEnvironment  ^RBSelectorEnvironment new     searchStrings: #();     label: self label;     onEnvironment: self environment;     classSelectors: self classSelectorDictionary metaClassSelectors: self metaClassSelectorDictionary;     yourself-=JUAMPI=-testMetaClassFailure  self shouldFail: (RBRenameClassVariableRefactoring rename: #RecursiveSelfRule to: #Foo in: RBTransformationRuleTestData class)-=JUAMPI=-testNonExistantName  self shouldFail: (RBRenameInstanceVariableRefactoring rename: 'foo' to: 'newFoo' in: RBBasicLintRuleTestData)-=JUAMPI=-testAccessorsAlreadyExist  | class |  (RBProtectVariableTransformation model: model instanceVariable: 'instVarName1' class: #Foo) asRefactoring transform.  class := model classNamed: #Foo.  self assert: (class parseTreeFor: #bar) equals: (self parseMethod: 'bar			"Add one to instVarName1"			self instVarName11: self instVarName11 + 1').  self assert: (class parseTreeFor: #instVarName11:) equals: (self parseMethod: 'instVarName11: anObject			instVarName1 := anObject').  self assert: (class parseTreeFor: #instVarName11) equals: (self parseMethod: 'instVarName11 ^instVarName1').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo			self instVarName11: self instVarName11 + instVarName2 + ClassVarName1')-=JUAMPI=-inlineMethod  | temp |  temp := self     foo;     inlineMethod;     bar.  ^temp-=JUAMPI=-caller  | anObject |  anObject := 5.  self called: anObject + 1 on: [ ^anObject ]-=JUAMPI=-testModelRemoveUnusedVariable  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  self assert: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: (model classNamed: #SomeClass)).  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  self deny: ((model classNamed: #Subclass) directlyDefinesVariable: #Foo)-=JUAMPI=-testAddClassVariable  | refactoring |  refactoring := (RBAddVariableTransformation classVariable: 'Asdf' class: #RBTransformationRuleTestData) asRefactoring transform.  self assert: ((refactoring model classNamed: #RBTransformationRuleTestData) directlyDefinesClassVariable: #Asdf)-=JUAMPI=-transform  | brokenSenders |  class addInstanceVariable: variableName asString.  oldClass removeInstanceVariable: variableName asString.  brokenSenders := self collectSendersOfInstVar.  brokenSenders ifNotEmpty: [ Smalltalk tools messageList browse: (brokenSenders collect: #method) title: 'Broken methods' autoSelect: brokenSenders first selector ]-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' comment: ''';     nextPutAll: comment;     nextPutAll: ''' in: ''';     nextPutAll: className.  aStream nextPut: $)-=JUAMPI=-comment: aString  model comment: (comment := aString) in: self-=JUAMPI=-postCopy  | newDict |  super postCopy.  newDict := classSelectors copy.  newDict keysAndValuesDo: [:key :value |  newDict at: key put: value copy ].  classSelectors := newDict.  newDict := metaClassSelectors copy.  newDict keysAndValuesDo: [:key :value |  newDict at: key put: value copy ].  metaClassSelectors := newDict-=JUAMPI=-includesCategory: aCategory  ^true-=JUAMPI=-testAddClass  | refactoring newClass superClass classTest |  refactoring := (RBAddClassTransformation addClass: #FooTest superclass: #RBTransformationTest subclasses: #(RBAddClassTransformationTest) category: #'Refactory-Testing') asRefactoring.  refactoring transform.  newClass := refactoring model classNamed: #FooTest.  superClass := refactoring model classNamed: #RBTransformationTest.  classTest := refactoring model classNamed: self class name.  self assert: newClass superclass equals: superClass.  self assert: (superClass subclasses includes: newClass).  self assert: newClass theMetaClass superclass equals: superClass theMetaClass.  self assert: (superClass theMetaClass subclasses includes: newClass theMetaClass).  self assert: classTest superclass equals: newClass.  self assert: (newClass subclasses includes: classTest).  self assert: classTest theMetaClass superclass equals: newClass theMetaClass.  self assert: (newClass theMetaClass subclasses includes: classTest theMetaClass)-=JUAMPI=-classNamesFor: anEnvironment  | classNames allClassNames |  classNames := IdentitySet new     addAll: anEnvironment classNames asSet;     addAll: anEnvironment not classNames;     yourself.  allClassNames := universalEnvironment classNames asSortedCollection.  self assert: classNames asSortedCollection equals: allClassNames.  self assertEmpty: (anEnvironment & anEnvironment not) classNames.  self assert: (anEnvironment | anEnvironment not) classNames asSortedCollection equals: allClassNames-=JUAMPI=-initialize  super initialize.  delegatesPreconditions := true-=JUAMPI=-testInheritedName  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'name' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: #DependentsFields class: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-comment: aString in: aClass  ^changes comment: aString in: aClass-=JUAMPI=-addMethodSource: sourceCode in: aClass for: aController  ^RBAddMethodChange compile: sourceCode in: aClass for: aController-=JUAMPI=-testInlineMethod5  | refactoring |  refactoring := RBInlineMethodRefactoring inline: (53 to: 64) inMethod: #inlineLast forClass: RBRefactoryTestDataApp.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineLast) equals: (self parseMethod: 'inlineLast									5 = 3 ifTrue: [^self caller] ifFalse: [^	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]]')-=JUAMPI=-asRefactoring  ^self     checksPreconditions;     yourself-=JUAMPI=-includesBehaviorNamed: aClassName  | current |  current := self selectedClass.  [ current isNil ] whileFalse: [ current name = aClassName ifTrue: [ ^true ].        current := current superclass ].  ^false-=JUAMPI=-extractedParseTree  ^extractedParseTree-=JUAMPI=-allPoolDictionaryNames  | sprClass |  sprClass := self superclass.  ^sprClass ifNil: [ self sharedPoolNames ] ifNotNil: [ sprClass allPoolDictionaryNames , self sharedPoolNames ]-=JUAMPI=-removeClass: aClass classVariable: aSymbol  | vars |  vars := classVariables at: aClass name ifAbsent: [ Set new ].  vars remove: aSymbol ifAbsent: [  ].  vars ifEmpty: [ classVariables removeKey: aClass name ifAbsent: [  ] ].  self flushCachesFor: aClass-=JUAMPI=-isEmpty  ^environmentDictionaries isEmpty-=JUAMPI=-newContentMorph  ^labelGroup := (self newRow: {(self newLabelGroup: {('Selector:' -> (selectorField := (self newTextEntryFor: self getText: #selector setText: #selector: help: nil)                       autoAccept: true;                       on: #keyStroke send: #value:value: to: [:key :morph |  key keyCharacter = Character cr ifTrue: [ self ok.                                true ].                          false ];                       hResizing: #spaceFill;                       yourself)) .               ('Arguments:' -> (self newRow: {((self newColumn: {(self newButtonFor: self action: #add label: '+' help: nil) .                                 (self newButtonFor: self action: #remove label: '-' help: nil)}) hResizing: #shrinkWrap) .                           ((self newListFor: self list: #argumentList selected: #argumentIndex changeSelected: #argumentIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               ('Preview:' -> (labelMorph := self newLabel: self methodName printString))})})     minWidth: 400;     hResizing: #spaceFill;     yourself-=JUAMPI=-initialize  self computeLiterals-=JUAMPI=-testNotEnvironmentWithClassEnvironments  | numberEnvironment notNumberEnvironment |  numberEnvironment := RBBrowserEnvironment new forClasses: Number withAllSubclasses.  notNumberEnvironment := numberEnvironment not.  self universalTestFor: notNumberEnvironment.  self deny: (notNumberEnvironment includesClass: Number).  self assertEmpty: (notNumberEnvironment & numberEnvironment) classes.  self assert: (notNumberEnvironment not includesClass: Number)-=JUAMPI=-checkMethod: aMethod  (self basicCheck: aMethod) ifTrue: [ result addMethod: aMethod ]-=JUAMPI=-compile: aString  ^self compile: aString withAttributesFrom: (self methodFor: (self parserClass parseMethodPattern: aString))-=JUAMPI=-newSelector  ^newSelector-=JUAMPI=-preconditions  ^className inject: RBCondition empty into: [:cond :aClass |  | aClassOrTrait |        aClassOrTrait := self model classNamed: className asSymbol.        aClassOrTrait ifNil: [ self refactoringError: 'No such class or trait named ' , className ].        cond & ((self preconditionIsNotMetaclass: aClassOrTrait) & (self preconditionHasNoReferences: className) & (self preconditionHasNoSubclasses: aClassOrTrait) & (self preconditionHasNoUsers: aClassOrTrait)) ]-=JUAMPI=-testPerformAddRemoveClass  | change |  change := changes defineClass: 'Object subclass: #' , self changeMock name , 'Temporary	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	package: ''' , self class category , ''''.  self perform: change do: [ self assert: (workingEnvironment hasClassNamed: change changeClassName).        self assert: change definedClass name equals: change changeClassName.        self assert: change definedClass isBehavior ].  self deny: (workingEnvironment hasClassNamed: change changeClassName).  self assert: change definedClass isObsolete-=JUAMPI=-isComposite  ^true-=JUAMPI=-selectorsFor: aProtocol in: aClass  ^(aClass organization listAtCategoryNamed: aProtocol) select: [:each |  self includesSelector: each in: aClass ]-=JUAMPI=-createReference  self performComponentRefactoring: (RBAddInstanceVariableRefactoring variable: referenceVariableName class: class)-=JUAMPI=-uncommonMessageSend2  | a |  a := 3 Object new.  ^a-=JUAMPI=-hasConflicts  ^true-=JUAMPI=-methodAfter  | variable |  variable := 'String'.  variable byteAt: 1-=JUAMPI=-testNonExistantName  self shouldFail: (RBRemoveInstanceVariableRefactoring variable: 'name1' class: RBLintRuleTestData)-=JUAMPI=-parameters: anOrderedCollection  parameters := anOrderedCollection-=JUAMPI=-fillOutDefinition: aDictionary  className := (aDictionary at: '`traitName') asSymbol-=JUAMPI=-inline: anInterval from: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  sourceInterval := anInterval-=JUAMPI=-classForName: aString  | name isMeta class |  isMeta := aString includes: $ .  name := (isMeta ifTrue: [ aString copyFrom: 1 to: (aString size - 6 max: 1) ] ifFalse: [ aString ]) asSymbol.  class := self systemDictionary at: name ifAbsent: [ nil ].  ^(class notNil and: [ isMeta ]) ifTrue: [ class class ] ifFalse: [ class ]-=JUAMPI=-rationale  ^'Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end.'-=JUAMPI=-setUp  super setUp.  model := self abstractVariableTestData-=JUAMPI=-addChangeToClass: aRBClass  ^changedClasses at: aRBClass name put: (Array with: aRBClass instanceSide with: aRBClass classSide)-=JUAMPI=-toDoCollect  | array |  array := Array new: 10.  1 to: 10 do: [:i |  array at: i put: i * i ].  ^array-=JUAMPI=-checkClass: aSmalllintContext  ^classBlock value: aSmalllintContext value: result-=JUAMPI=-classVarRefsTo: instVarName in: aClass  ^RBVariableEnvironment on: self referencesToClassVariable: instVarName in: aClass-=JUAMPI=-newName  ^newName-=JUAMPI=-testMetaClassFailure  self shouldFail: (RBChildrenToSiblingsRefactoring name: #Foo class: RBLintRuleTestData class subclasses: (Array with: RBBasicLintRuleTestData class with: RBCompositeLintRuleTestData class))-=JUAMPI=-includesClass: aClass  (super includesClass: aClass) ifFalse: [ ^false ].  (instanceVariables includesKey: aClass name) ifTrue: [ ^true ].  (classVariables includesKey: aClass name) ifTrue: [ ^true ].  ^(self selectorCacheFor: aClass) anySatisfy: [:each |  self includesSelector: each in: aClass ]-=JUAMPI=-denyEmpty: aCollection  ^self assert: aCollection isNotEmpty description: aCollection asString , ' should not have been empty'-=JUAMPI=-checkSuperMessages  inlineParseTree superMessages isEmpty ifFalse: [ self refactoringError: 'Cannot inline method since it sends a super message' ]-=JUAMPI=-equalNotUsed  | string |  string = '' yourself.  (1 to: 10) do: [:i |  string := i printString ].  ^string-=JUAMPI=-testMoveDefinition  | transformation class |  transformation := (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #moveDefinition inClass: #RBDummyRefactoryTestDataApp) transform.  class := transformation model classNamed: #RBDummyRefactoryTestDataApp.  self assert: (class parseTreeFor: #moveDefinition) equals: (self parseMethod: 'moveDefinition								^(self collect: 										[:each | 										| temp |										temp := each printString.										temp , temp]) 									select: 										[:each | 										| temp |										temp := each size.										temp odd]')-=JUAMPI=-shouldUseExistingMethod: aSelector  ^(self options at: #useExistingMethod) value: self value: aSelector-=JUAMPI=-remainingTemporaries  | temps |  temps := modifiedParseTree allDefinedVariables asSet.  extractedParseTree allDefinedVariables do: [:each |  temps remove: each ifAbsent: [  ] ].  ^temps-=JUAMPI=-classSelectors: classSelectorDictionary metaClassSelectors: metaClassSelectorDictionary  classSelectors := classSelectorDictionary.  metaClassSelectors := metaClassSelectorDictionary-=JUAMPI=-testTransform  | transformation class |  transformation := (RBRenameVariableTransformation rename: 'classBlock' to: 'asdf' in: #RBBasicLintRuleTestData classVariable: false) transform.  class := transformation model classNamed: #RBBasicLintRuleTestData.  self assert: (class directlyDefinesInstanceVariable: 'asdf').  self deny: (class directlyDefinesInstanceVariable: 'classBlock').  self assert: (class parseTreeFor: #checkClass:) equals: (self parseMethod: 'checkClass: aSmalllintContext 					^asdf value: aSmalllintContext value: result').  self assert: (class parseTreeFor: #initialize) equals: (self parseMethod: 'initialize					super initialize.					self anInstVar: 1.					asdf := [:context :aResult | ].					methodBlock := [:context :aResult | ].					self resultClass: RBSelectorEnvironment')-=JUAMPI=-preconditions  | aSubtree |  aSubtree := self calculateSubtree.  ^(RBCondition withBlock: [ aSubtree ifNil: [ self refactoringError: 'Cannot extract code.' ].        true ]) & (RBCondition withBlock: [ aSubtree parent isCascade ifTrue: [ self refactoringError: 'Cannot extract code in a cascaded message' ].              true ]) & (RBCondition withBlock: [ | tempVariables |              tempVariables := self calculateTemporaries.              (RBReadBeforeWrittenTester readBeforeWritten: tempVariables in: aSubtree) ifNotEmpty: [ self refactoringError: 'Cannot extract temporaries if they are read before written.' ].              true ]) & (RBCondition withBlock: [ self calculateAssignments size > 1 ifTrue: [ self refactoringError: 'Cannot extract two or more assignments to temporaries without also extracting all the references.' ].              true ]) & (RBCondition withBlock: [ | assignmentCollection |              assignmentCollection := self calculateAssignments.              assignmentCollection ifNotEmpty: [ ((RBReadBeforeWrittenTester isVariable: assignmentCollection first readBeforeWrittenIn: aSubtree) or: [ aSubtree containsReturn ]) ifTrue: [ self refactoringError: ('Cannot extract assignment to <1s> without also extracting all the references.' expandMacrosWith: assignments asString) ] ].              true ]) & (RBCondition withBlock: [ | searchSpace |              searchSpace := (self class allMethodsInHierarchyOf: self definingClass) reject: [:m |  m selector = selector ].              (RBParseTreeSearcher whichMethodIn: searchSpace matches: aSubtree) ifNotEmpty: [:opportunities |  self refactoringError: ('<1s> method(s) already implement this code.<n>Do you want to send a message instead?' expandMacrosWith: opportunities size asString) with: [ (RBParseTreeRewriter replaceCode: aSubtree byMessageSendTo: opportunities anyOne in: (self definingClass methodFor: self calculateTree selector)) transform ].                    false ] ifEmpty: [ true ] ])-=JUAMPI=-includesSelector: aSelector in: aClass  ^(self includesClass: aClass) and: [ environment includesSelector: aSelector in: aClass ]-=JUAMPI=-testRemovePool  | change |  change := changes removePool: 'PoolDict' from: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change variable equals: 'PoolDict'.  self universalTestFor: change-=JUAMPI=-returnInEnsure  [ self error: 'asdf' ] ensure: [ ^4 ]-=JUAMPI=-testRefactoring  | refactoring class |  refactoring := (RBAddAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBAddAssignmentTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBAddAssignmentTransformationTest.  self assert: (class directlyDefinesMethod: #methodBefore).  self assert: (class parseTreeFor: #methodBefore) body statements size equals: 2.  self assert: (class parseTreeFor: #methodBefore) body statements last value sourceCode equals: '1 asString'-=JUAMPI=-testModelAlreadyExistingName  | refactoring |  refactoring := RBAddClassVariableRefactoring model: model variable: #ClassVarName2 class: (model classNamed: #Bar).  self shouldFail: refactoring-=JUAMPI=-methodSourceFor: aSymbol  ^(self changeClass includesSelector: aSymbol) ifTrue: [ self changeClass sourceCodeAt: aSymbol ]-=JUAMPI=-removeClassVariable: aString  self privateClassVariableNames remove: aString asSymbol.  model removeClassVariable: aString from: self-=JUAMPI=-checkIsSubclass: aClass  aClass ~= class ifTrue: [ (class subclasses includes: aClass) ifFalse: [ self refactoringError: ('<1p> is not subclass of <2s>' expandMacrosWith: aClass name with: class name) ] ]-=JUAMPI=-removeDuplicateMethods  selectors do: [:each |  self removeDuplicatesOf: each ]-=JUAMPI=-booleanPrecedence  ^(true & 4) = 45-=JUAMPI=-rules  ^rules-=JUAMPI=-leaves  ^{self}-=JUAMPI=-check: anEntity forCritiquesDo: aCriticBlock  (self basicCheck: anEntity) ifTrue: [ aCriticBlock cull: (self critiqueFor: anEntity) ]-=JUAMPI=-includesProtocol: aProtocol in: aClass  ^(aClass organization protocolOrganizer getProtocolNamed: aProtocol ifNone: [ ^false ]) methods anySatisfy: [:selector |  self includesSelector: selector in: aClass ]-=JUAMPI=-testNonExistantName  self     shouldFail: (RBRemoveVariableTransformation instanceVariable: 'name1' class: #RBDummyLintRuleTest) asRefactoring;     shouldFail: (RBRemoveVariableTransformation classVariable: #RecursiveSelfRule1 class: #RBTransformationDummyRuleTest) asRefactoring-=JUAMPI=-addClass: aClass instanceVariableWriter: aString  (instanceVariableWriters at: aClass name ifAbsentPut: [ Set new ]) add: aString.  self flushCachesFor: aClass.  self addSearchString: aString-=JUAMPI=-delete: selector in: aClass  (aClass realClass includesSelector: selector) ifTrue: [ [ self performComponentRefactoring: (RBRemoveMethodRefactoring model: self model removeMethods: {selector} from: aClass) ] on: RBRefactoringError do: [:ex |  (self confirm: (ex messageText copyReplaceAll: 'Browse references?' with: 'Remove anyway?')) ifTrue: [ ex resume ] ] ]-=JUAMPI=-shouldFail: aRefactoring  self proceedThroughWarning: [ self should: [ aRefactoring transform ] raise: RBRefactoringError ]-=JUAMPI=-testModelAddClass  | refactoring newClass superClass subclass |  subclass := model classNamed: #Bar.  superClass := model classNamed: #Foo.  refactoring := (RBAddClassTransformation model: model addClass: #FooTest superclass: #Foo subclasses: #(Bar) category: #'Refactory-Testing') asRefactoring.  refactoring transform.  newClass := model classNamed: #FooTest.  self assert: newClass superclass equals: superClass.  self assert: (superClass subclasses includes: newClass).  self assert: newClass theMetaClass superclass equals: superClass theMetaClass.  self assert: (superClass theMetaClass subclasses includes: newClass theMetaClass).  self assert: subclass superclass equals: newClass.  self assert: (newClass subclasses includes: subclass).  self assert: subclass theMetaClass superclass equals: newClass theMetaClass.  self assert: (newClass theMetaClass subclasses includes: subclass theMetaClass)-=JUAMPI=-testTransform  | transformation class |  transformation := (RBDeprecateClassTransformation class: self changeMock name) transform.  self assert: transformation model changes changes size equals: 4.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: class comment equals: 'Deprecated!!! Use superclass'.  class := transformation model metaclassNamed: self changeMock name.  self assert: (class parseTreeFor: #new) equals: (self parseMethod: 'new				self deprecated: ''Use superclass '' on: ''4 May 2016''  in: #Pharo60.				^ super new').  self assert: (class parseTreeFor: #deprecated) equals: (self parseMethod: 'deprecated ^ true').  self assert: (class parseTreeFor: #systemIcon) equals: (self parseMethod: 'systemIcon				^ Smalltalk ui icons iconNamed: #packageDelete')-=JUAMPI=-testModelAlreadyExistingName  self     shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'instVarName1' class: (model classNamed: #Bar)) asRefactoring;     shouldFail: (RBAddVariableTransformation model: model classVariable: #ClassVarName2 class: (model classNamed: #Bar)) asRefactoring-=JUAMPI=-neitherFailed  ^(left errorStringFor: true) , ' AND ' , (right errorStringFor: true)-=JUAMPI=-convertAllReferencesToClass: aRBClass using: searchReplacer  self model allReferencesToClass: aRBClass do: [:method |  self convertMethod: method selector for: method modelClass using: searchReplacer ]-=JUAMPI=-testSystemIntegrity  | classes environment |  classes := IdentitySet new.  environment := RBBrowserEnvironment new.  environment allClassesDo: [:class |  (classes includes: class) ifFalse: [ classes add: class ] ifTrue: [ self error: 'The class ' , class name , ' that is available under two or more names. This causes problems with the refactoring browser.' ] ]-=JUAMPI=-rootClasses  ^rootClasses ifNil: [ rootClasses := self privateRootClasses ]-=JUAMPI=-checkClassVars  selectors do: [:each |  self checkClassVarsFor: each ]-=JUAMPI=-testInheritedName  self shouldFail: (RBAbstractInstanceVariableRefactoring variable: 'name' class: RBBasicLintRuleTestData)-=JUAMPI=-condition: aCondition  condition := aCondition.  self errorMacro: condition errorMacro-=JUAMPI=-renameClass: aRBClass to: newName  ^RBRenameClassChange rename: aRBClass name to: newName-=JUAMPI=-extractMethod  | parseTree isSequence extractCode subtree newCode errorMessage |  extractCode := self getExtractedSource.  extractedParseTree := self parserClass parseExpression: extractCode onError: [:string :pos :parser |  errorMessage := string.        parser parseErrorNode: string ].  extractedParseTree ifNil: [ self refactoringFailure: 'Invalid source to extract' ].  extractedParseTree isFaulty ifTrue: [ self refactoringFailure: 'Invalid source to extract - ' , errorMessage ].  (extractedParseTree isSequence and: [ extractedParseTree statements isEmpty ]) ifTrue: [ self refactoringError: 'Select some code to extract' ].  isSequence := extractedParseTree isSequence or: [ extractedParseTree isReturn ].  extractedParseTree := RBMethodNode selector: #value arguments: #() body: (extractedParseTree isSequence ifTrue: [ extractedParseTree ] ifFalse: [ RBSequenceNode temporaries: #() statements: (OrderedCollection with: extractedParseTree) ]).  extractedParseTree body temporaries ifNotEmpty: [ extractedParseTree body temporaries: #() ].  extractedParseTree source: extractCode.  parseTree := class parseTreeFor: selector.  parseTree ifNil: [ self refactoringFailure: 'Could not parse ' , selector printString ].  subtree := isSequence ifTrue: [ self parseTreeSearcherClass treeMatchingStatements: extractedParseTree body formattedCode in: parseTree ] ifFalse: [ self parseTreeSearcherClass treeMatching: extractCode in: parseTree ].  subtree ifNil: [ self refactoringFailure: 'Could not extract code from method' ].  newCode := self methodDelimiter.  isSequence ifTrue: [ | stmts |        stmts := extractedParseTree body statements.        stmts ifNotEmpty: [ stmts last isAssignment ifTrue: [ | name |                    name := stmts last variable name.                    (self shouldExtractAssignmentTo: name) ifFalse: [ newCode := '<1s> := <2s>' expandMacrosWith: name with: newCode.                          stmts at: stmts size put: stmts last value ] ] ] ].  modifiedParseTree := isSequence ifTrue: [ RBParseTreeRewriter replaceStatements: subtree formattedCode with: newCode in: parseTree onInterval: extractionInterval ] ifFalse: [ RBParseTreeRewriter replace: subtree formattedCode with: newCode in: parseTree onInterval: extractionInterval ]-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' bindTight: '.  interval storeOn: aStream.  aStream nextPutAll: ' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: selector.  aStream nextPut: $)-=JUAMPI=-receiver: aString  receiver := aString-=JUAMPI=-isMeta  ^true-=JUAMPI=-existingMethodsThatReferToInstanceVariable: aString  | existingMethods |  existingMethods := self realClass whichSelectorsAccess: aString.  (newMethods isNil and: [ removedMethods isNil ]) ifTrue: [ ^existingMethods ].  ^existingMethods reject: [:each |  (self hasRemoved: each) or: [ self newMethods includesKey: each ] ]-=JUAMPI=-postCopy  super postCopy.  protocols := protocols copy-=JUAMPI=-testBasicLintRuleTypes  | typer types |  typer := RBRefactoryTyper new.  types := typer guessTypesFor: 'classBlock' in: RBBasicLintRuleTestData.  self assert: ([  ] class withAllSuperclasses detect: [:each |  types includes: (typer model classFor: each) ] ifNone: [ nil ]) notNil.  types := typer typesFor: 'methodBlock' in: (typer model classFor: RBBasicLintRuleTestData).  self assert: ([  ] class withAllSuperclasses detect: [:each |  types includes: (typer model classFor: each) ] ifNone: [ nil ]) notNil.  typer printString-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)-=JUAMPI=-options: aDictionary  options := aDictionary-=JUAMPI=-transform: aClass  | class method parseTree |  aClass allSelectors do: [:selector |  class := aClass whoDefinesMethod: selector.        (class notNil and: [ class ~= aClass ]) ifTrue: [ method := class methodFor: selector.              (method notNil and: [ method refersToSymbol: #subclassResponsibility ]) ifTrue: [ parseTree := method parseTree.                    parseTree body                       temporaries: OrderedCollection new;                       statements: OrderedCollection new;                       addNode: (RBMessageNode receiver: (RBVariableNode named: 'self') selector: #shouldBeImplemented).                    aClass compile: parseTree newSource withAttributesFrom: method ] ] ]-=JUAMPI=-uniqueClassesIn: aBrowserEnvironment  | allClasses |  allClasses := IdentitySet new.  aBrowserEnvironment classesDo: [:each |  self deny: (allClasses includes: each).        allClasses add: each ]-=JUAMPI=-pushUpMethodsFrom: aClass  | selectorsToPushUp |  selectorsToPushUp := self selectorsToPushUpFrom: aClass.  aClass selectors do: [:each |  (selectorsToPushUp includes: each) ifTrue: [ self pushUp: each in: aClass ] ifFalse: [ self createSubclassResponsibilityFor: each in: aClass ] ].  selectorsToPushUp do: [:each |  aClass removeMethod: each ]-=JUAMPI=-testTransform  | transformation class |  transformation := (RBRemoveAssignmentTransformation new variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) body-=JUAMPI=-checkMethod: aSmalllintContext  rules do: [:each |  each checkMethod: aSmalllintContext.        Processor yield ]-=JUAMPI=-preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ | methodSource |              interval first <= interval last ifFalse: [ self refactoringFailure: 'You must select a variable name' ].              methodSource := class sourceCodeFor: selector.              methodSource size >= interval last ifFalse: [ self refactoringFailure: 'Invalid range for variable' ].              name := methodSource copyFrom: interval first to: interval last.              (self checkInstanceVariableName: name in: class) ifFalse: [ self refactoringFailure: name , ' does not seem to be a valid variable name.' ].              parseTree := class parseTreeFor: selector.              self checkParseTree.              true ])-=JUAMPI=-executeRefactoring: aRefactoring  aRefactoring primitiveExecute.  self parserClass parseExpression: aRefactoring storeString-=JUAMPI=-checkSuperMessages  self inlineClass = class ifTrue: [ ^self ].  self inlineClass superclass ifNil: [ ^self ].  inlineParseTree superMessages do: [:each |  (self inlineClass superclass whoDefinesMethod: each) = (class superclass whoDefinesMethod: each) ifFalse: [ self refactoringError: ('Cannot inline method since it sends a super message <1s> that is overriden' expandMacrosWith: each) ] ]-=JUAMPI=-buildTransformations  self subclassResponsibility-=JUAMPI=-testRefactoring  | refactoring |  refactoring := (RBRemoveClassTransformation className: #RBFooDummyLintRuleTest1) asRefactoring.  [ refactoring transform ] on: RBRefactoringError do: [:error |  self resumeIfCannotRemove: error ].  self assert: (refactoring model classNamed: #RBFooDummyLintRuleTest1) isNil.  self assert: (refactoring model classNamed: 'RBTransformationDummyRuleTest1' asSymbol) superclass equals: (refactoring model classNamed: #RBDummyLintRuleTest)-=JUAMPI=-hasConflicts  ^rules anySatisfy: [:each |  each hasConflicts ]-=JUAMPI=-forPackageNames: aCollection  ^RBPackageEnvironment onEnvironment: self packageNames: aCollection-=JUAMPI=-testMetaclassFailure  self shouldFail: (RBPullUpVariableTransformation classVariable: #RecursiveSelfRule class: RBDummyLintRuleTest class) asRefactoring-=JUAMPI=-testNonExistantName  self     shouldFail: (RBCreateAccessorsForVariableRefactoring variable: #Foo class: RBBasicLintRuleTestData classVariable: true);     shouldFail: (RBCreateAccessorsForVariableRefactoring variable: 'foo' class: RBBasicLintRuleTestData classVariable: true)-=JUAMPI=-removeClassVariable: variableName from: aClass  ^RBRemoveClassVariableChange remove: variableName from: aClass-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' class: '.  class storeOn: aStream.  aStream nextPutAll: ' instanceVariables: '.  instanceVariables asArray storeOn: aStream.  aStream     nextPutAll: ' newClassName: #';     nextPutAll: newClassName;     nextPutAll: ' referenceVariableName: ''';     nextPutAll: referenceVariableName;     nextPutAll: ''')'-=JUAMPI=-setupSelfArgumentNameFor: aRefactoring toReturn: aString  | options |  options := aRefactoring options copy.  options at: #selfArgumentName put: [:ref |  aString ].  aRefactoring options: options-=JUAMPI=-findSequenceNode  sequenceNode := self parserClass parseExpression: self selectedSource onError: [:msg :pos |  self refactoringFailure: 'Invalid source to rewrite' ].  (sequenceNode isSequence and: [ sequenceNode statements size > 1 ]) ifFalse: [ self refactoringFailure: 'You must select two or more statements' ]-=JUAMPI=-protocol: aString inClass: aClassName  self className: aClassName.  protocol := aString-=JUAMPI=-refineTypesByLookingAtAssignments  | searcher needsSearch |  needsSearch := false.  searcher := self parseTreeSearcher.  variableTypes keysAndValuesDo: [:key :value |  key first = $- ifFalse: [ needsSearch := true.              searcher matches: key , ' := ``@object' do: [:aNode :answer |  self guessTypeFromAssignment: aNode ] ] ].  needsSearch ifTrue: [ self executeSearch: searcher ]-=JUAMPI=-testExtractMethodThatNeedsTemporaryVariable  | refactoring class |  refactoring := RBExtractMethodRefactoring extract: (78 to: 197) from: #displayName in: RBLintRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo:.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class parseTreeFor: #displayName) equals: (self parseMethod: 'displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	self foo: nameStream.	^nameStream contents').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: nameStream 	nameStream nextPutAll: self name;		nextPutAll: '' (''.	self problemCount printOn: nameStream.	nameStream nextPut: $).')-=JUAMPI=-classNames  ^IdentitySet new     addAll: classSelectors keys;     addAll: metaClassSelectors keys;     yourself-=JUAMPI=-inlineParameter: aString in: aClass selector: aSelector  oldSelector := aSelector.  class := self classObjectFor: aClass.  argument := aString-=JUAMPI=-checkMethod: aMethod  -=JUAMPI=-addClassVariable: aString to: aRBClass  ^changes addClassVariable: aString to: aRBClass-=JUAMPI=-isParseTreeEquivalentTo: aSelector  | tree definingClass |  definingClass := class whoDefinesMethod: aSelector.  tree := definingClass parseTreeFor: aSelector.  tree ifNil: [ ^false ].  tree isPrimitive ifTrue: [ ^false ].  (tree body equalTo: extractedParseTree body exceptForVariables: (tree arguments collect: [:each |  each name ])) ifFalse: [ ^false ].  (definingClass = class or: [ (tree superMessages anySatisfy: [:each |  (class superclass whichClassIncludesSelector: aSelector) ~= (definingClass superclass whichClassIncludesSelector: each) ]) not ]) ifFalse: [ ^false ].  ^self shouldUseExistingMethod: aSelector-=JUAMPI=-newResultClass: aClass  result := aClass new-=JUAMPI=-problemCount  ^self numberSelectors-=JUAMPI=-initialize  super initialize.  keywords := IdentitySet new.  condition := [:pragma |  true ]-=JUAMPI=-removeArgument  | removeIndex |  removeIndex := parseTree argumentNames indexOf: variable.  removeIndex = 0 ifFalse: [ parseTree selector: ('' join: (parseTree selector keywords asOrderedCollection                       removeAt: removeIndex;                       yourself)) asSymbol keywordsPositions: (parseTree keywordsPositions asOrderedCollection                 removeAt: removeIndex;                 yourself) asIntegerArray arguments: (parseTree arguments asOrderedCollection                 removeAt: removeIndex;                 yourself) asArray ]-=JUAMPI=-initialize  super initialize.  comment := LookupComment-=JUAMPI=-abstractSuperclass  ^self model classNamed: className asSymbol-=JUAMPI=-testModelRemoveInstanceVariable  | class |  model defineClass: 'nil subclass: #Object		instanceVariableNames: ''foo1''		classVariableNames: ''''		poolDictionaries: ''''		category: #''Refactory-Test data'''.  class := model classNamed: #Object.  self assert: (class definesInstanceVariable: 'foo1').  (RBRemoveVariableTransformation model: model instanceVariable: 'foo1' class: class) asRefactoring transform.  self deny: (class definesInstanceVariable: 'foo1')-=JUAMPI=-definitionClass  ^Trait-=JUAMPI=-matchNodes  ^matchNodes ifNil: [ | visitor node sourceCode |        visitor := RBMatchVisitor new.        node := method sourceNode copy.        node acceptVisitor: visitor.        sourceCode := self replaceArgumentsByPattern: node newSource.        sourceCode := sourceCode copyFrom: method sourceNode body statements first start + visitor difference to: sourceCode size.        matchNodes := OrderedCollection new.        matchNodes add: (RBPatternParser parseExpression: sourceCode).        node lastIsReturn ifTrue: [ node hasMultipleReturns ifFalse: [ sourceCode := sourceCode copyReplaceAll: '^' with: ''.                    matchNodes add: (RBPatternParser parseExpression: sourceCode) ] ].        matchNodes ]-=JUAMPI=-testVariableDoesNotExist  self     shouldFail: (RBRenameVariableTransformation rename: 'foo' to: 'newFoo' in: #RBBasicLintRuleTestData classVariable: false) asRefactoring;     shouldFail: (RBRenameVariableTransformation rename: #foo to: #newFoo in: #RBBasicLintRuleTestData classVariable: true) asRefactoring-=JUAMPI=-isSelectorEnvironment  ^false-=JUAMPI=-testEmptyCode  self shouldFail: (RBReplaceSubtreeTransformation replace: '' to: '^ selector' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoring-=JUAMPI=-testRenamePermuteArgs  | refactoring class |  refactoring := RBRenameMethodRefactoring renameMethod: ('rename:' , 'two:') asSymbol in: RBRefactoryTestDataApp to: ('rename:' , 'two:') asSymbol permutation: #(2 1).  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: ('rename:' , 'two:') asSymbol) equals: (self parseMethod: 'rename: argumentMethod two: this ^self printString, this, argumentMethod').  self assert: (class parseTreeFor: #exampleCall) equals: (self parseMethod: 'exampleCall <sampleInstance> ^self rename: 2 two: 1')-=JUAMPI=-initialize  super initialize.  self resetResult-=JUAMPI=-refactoringFailure: aString  ^RBRefactoringFailure signal: aString-=JUAMPI=-classBlock  ^self anInstVar + 5-=JUAMPI=-renameSelfReferences  self addSelfReferenceToSourceMessage.  self addSelfReferenceToInlineParseTree-=JUAMPI=-cruft  < haltOrBreakpointForTesting>  self halt-=JUAMPI=-setUp  super setUp.  model := Smalltalk compiler evaluate: self childrenToSiblingTestData-=JUAMPI=-refactoringError: aString with: aBlock  ^RBRefactoringError signal: aString with: aBlock-=JUAMPI=-callFoo  ^self testFoo: 5-=JUAMPI=-transform  self transform: self theClass.  self transform: self theClass classSide-=JUAMPI=-preconditionHasNoReferences: aClass  | env |  env := self environmentWithReferencesTo: aClass.  ^(RBCondition withBlock: [ env isEmpty ])     errorMacro: aClass , ' is referenced.<n>Browse references?';     errorBlock: [ self openBrowserOn: env ];     yourself-=JUAMPI=-includesSelector: aSelector in: aClass  (environment includesSelector: aSelector in: aClass) ifFalse: [ ^false ].  ^(aClass compiledMethodAt: aSelector) pragmas anySatisfy: [:each |  self includesPragma: each ]-=JUAMPI=-literalArrayWithTrueFalseOrNil2  | b c |  b := #(#true #false #nil).  c := #(#true #(#true #false #nil) #false #nil).  ^b-=JUAMPI=-transform  self renameMessageSends-=JUAMPI=-testTransform  | transformation class |  transformation := (RBAddVariableAccessorTransformation instanceVariable: 'instVar' class: self changeMock name) transform.  self assert: transformation model changes changes size equals: 2.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class parseTreeFor: #instVar) equals: (self parseMethod: 'instVar ^instVar').  self assert: (class parseTreeFor: #instVar:) equals: (self parseMethod: 'instVar: anObject instVar := anObject')-=JUAMPI=-hash  ^self changeClassName hash bitXor: self variable hash-=JUAMPI=-renameReferences  | replacer |  replacer := RBParseTreeRewriter rename: variableName to: newName handler: [ self refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' expandMacrosWith: newName) ].  self convertClasses: class withAllSubclasses select: [:aClass |  aClass whichSelectorsReferToInstanceVariable: variableName ] using: replacer-=JUAMPI=-result  ^result-=JUAMPI=-selectors: aList  selectors := aList-=JUAMPI=-classNameFor: aBehavior  ^aBehavior instanceSide name-=JUAMPI=-buildTransformations  ^OrderedCollection new     addAll: (self variableDefinitionsInHierarchy collect: [:each |  RBRemoveVariableTransformation model: self model variable: variableName class: each classVariable: isClassVariable ]);     add: (RBAddVariableTransformation model: self model variable: variableName class: className classVariable: isClassVariable);     yourself-=JUAMPI=-returnsIfTrue  ^self isNil ifTrue: [ 4 ]-=JUAMPI=-environmentWithUsersOf: aTrait  ^RBClassEnvironment onEnvironment: RBBrowserEnvironment new classes: aTrait realClass users-=JUAMPI=-equivalentSuperclassMethods  ^self identityHash-=JUAMPI=-= aRefactoryBuilder  self class = aRefactoryBuilder class ifFalse: [ ^false ].  changes size = aRefactoryBuilder changes size ifFalse: [ ^false ].  changes with: aRefactoryBuilder changes do: [:first :second |  first = second ifFalse: [ ^false ] ].  ^true-=JUAMPI=-sharedPoolNames  ^self privatePoolDictionaryNames copy-=JUAMPI=-whichCategoryIncludes: aClassName  ^self systemDictionary organization categoryOfElement: aClassName-=JUAMPI=-changeString  ^'Add Protocol named ' , self displayProtocolName , ' in ' , self displayClassName-=JUAMPI=-changeSymbol  ^#addSharedPool:-=JUAMPI=-isSharedPool  ^(self allSuperclasses collect: #name) includes: #SharedPool-=JUAMPI=-shouldPushUp: aSelector from: aClass  ^(aClass isMeta ifTrue: [ subclasses collect: [:each |  each classSide ] ] ifFalse: [ subclasses ]) anySatisfy: [:each |  (each directlyDefinesMethod: aSelector) not ]-=JUAMPI=-definesClass: aClass  ^self includesClass: aClass-=JUAMPI=-createReference  transformations add: (RBAddVariableTransformation model: self model instanceVariable: referenceVariableName class: class)-=JUAMPI=-addClassAndMetaClassFor: aClassOrMetaClass  self     addClass: aClassOrMetaClass classSide;     addClass: aClassOrMetaClass instanceSide-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' removeMethods: '.  selectors asArray storeOn: aStream.  aStream nextPutAll: ' from: '.  class storeOn: aStream.  aStream nextPut: $)-=JUAMPI=-getClassesForTemporaryVariable  | types |  types := RBRefactoryTyper typesFor: variable in: parseTree model: self model.  types ifEmpty: [ types := OrderedCollection with: (self model classNamed: #Object) ].  moveToClasses := self selectVariableTypesFrom: types selected: types.  moveToClasses ifNil: [ self refactoringFailure: 'Method not moved' ]-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-hierarchyDefinesVariable: aString  (self definesVariable: aString) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:each |  each directlyDefinesVariable: aString ]-=JUAMPI=-printOn: aStream  super printOn: aStream.  self name ifNotNil: [ aStream           nextPutAll: ' name: ';           print: self name ]-=JUAMPI=-preconditions  | cond |  cond := ((RBCondition isMetaclass: (self model classObjectFor: superclass)) errorMacro: 'Superclass must not be a metaclass') not.  cond := subclasses inject: cond into: [:sub :each |  sub & ((RBCondition isMetaclass: (self model classObjectFor: each)) errorMacro: 'Subclass must <1?not :>be a metaclass') not & (RBCondition isImmediateSubclass: (self model classObjectFor: each) of: (self model classObjectFor: superclass)) ].  ^cond & (RBCondition isValidClassName: className) & (RBCondition isGlobal: className in: self model) not & (RBCondition isSymbol: category) & ((RBCondition withBlock: [ category isEmpty not ]) errorMacro: 'Invalid category name')-=JUAMPI=-model  ^model ifNil: [ model := (RBClassModelFactory rbNamespace onEnvironment: self defaultEnvironment)           name: self printString;           yourself ] ifNotNil: [ model ]-=JUAMPI=-allSuperclassesUntil: aClass  | supers sprClass |  supers := OrderedCollection new.  sprClass := self superclass.  [ sprClass notNil and: [ sprClass name ~= aClass name ] ] whileTrue: [ supers add: sprClass.        sprClass := sprClass superclass ].  ^supers-=JUAMPI=-protocol: aString  protocol := aString-=JUAMPI=-someDemoMethod  ^self junk-=JUAMPI=-directlyDefinesClassVariable: aString  ^self theNonMetaClass directlyDefinesClassVariable: aString-=JUAMPI=-privateTransform  self model     defineClass: ('<1p> subclass: #<2s> instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: <3p>' expandMacrosWith: (self model classObjectFor: superclass) with: className with: category asString);     reparentClasses: (subclasses collect: [:e |  self model classObjectFor: e ]) to: (self model classNamed: className asSymbol)-=JUAMPI=-testExtractMethodThatNeedsArgument  | refactoring class |  refactoring := RBExtractMethodRefactoring extract: (145 to: 343) from: #checkMethod: in: RBTransformationRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo:.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[self foo: aSmalllintContext]').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: aSmalllintContext (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]')-=JUAMPI=-rename: this two: argumentMethod  ^self printString , this , argumentMethod-=JUAMPI=-methodAfter  < gtInspectorPresentationOrder: 56>  | variable |  variable := 'String'-=JUAMPI=-selectionIntervalFor: aString  | parseTree node |  matcher ifNil: [ ^super selectionIntervalFor: aString ].  parseTree := RBParser parseMethod: aString onError: [:error :position |  ^super selectionIntervalFor: aString ].  node := matcher executeTree: parseTree initialAnswer: nil.  ^(node isKindOf: RBProgramNode) ifTrue: [ node sourceInterval ] ifFalse: [ super selectionIntervalFor: aString ]-=JUAMPI=-variableAssignedLiteral  temporaryVariable := #()-=JUAMPI=-multiplePeriodsTerminatingAssignmentStatement  | strings |  strings := OrderedCollection.  strings     add: 'one';     add: 'two'.  ^strings-=JUAMPI=-executeNotifying: aBlock  | undo |  undo := self asUndoOperation.  undo name: self name.  self primitiveExecute.  aBlock value.  ^undo-=JUAMPI=-testRemoveClassWithReferences  self shouldFail: (RBRemoveClassTransformation className: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-reparentSubclasses  self model reparentClasses: self definingClass subclasses copy to: self definingClass superclass-=JUAMPI=-equalsTrue  ^true == self-=JUAMPI=-notifyUserOfCommand: aCommand  | answer title |  title := self actionBlock ifNotNil: [ 'Warning' ] ifNil: [ 'Warning. Want to proceed?' ].  answer := UIManager default confirm: self messageText label: title.  answer ifTrue: [ self actionBlock ifNil: [ self resume: true ] ifNotNil: #value ]-=JUAMPI=-testModelInvalidSubclass  self shouldFail: (RBAddClassTransformation model: model addClass: #Foo2 superclass: #Object subclasses: (Array with: (model classNamed: #Bar)) category: #'Refactory-Tesing') asRefactoring-=JUAMPI=-calculateTree  ^parseTree ifNil: [ parseTree := self definingMethod ]-=JUAMPI=-isEmpty  ^self builder changes isEmpty-=JUAMPI=-propagateTransformation  self renameReferences-=JUAMPI=-shouldCopyExtensions: anObject  shouldCopyExtensions := anObject-=JUAMPI=-testMethodDoesNotExist  self shouldFail: (RBMethodProtocolTransformation protocol: 'empty protocol 2' inMethod: #method inClass: #RBDummyEmptyClass) asRefactoring-=JUAMPI=-methods  | methods |  methods := IdentitySet new: 4096.  self methodsDo: [:each |  methods add: each ].  ^methods-=JUAMPI=-rationale  ^'Checks for ifTrue: or ifFalse: conditions at end of methods that have two or more statements inside their blocks. Such code might better represent the true meaning of the code if they returned self instead.'-=JUAMPI=-textToDisplay  ^self source-=JUAMPI=-safeVariableNameFor: aClass temporaries: allTempVars  | baseString i newString |  newString := baseString := 'anObject'.  i := 0.  [ (allTempVars includes: newString) or: [ aClass definesInstanceVariable: newString ] ] whileTrue: [ i := i + 1.        newString := baseString , i printString ].  ^newString-=JUAMPI=-preconditions  ^(selectors inject: RBCondition empty into: [:cond :each |  cond & (RBCondition definesSelector: each in: class) ]) & (RBCondition withBlock: [ self checkSuperMethods.              true ])-=JUAMPI=-classSide  ^model metaclassNamed: self name-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' deprecateMethod: #';     nextPutAll: oldSelector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' using: #';     nextPutAll: newSelector.  aStream nextPut: $)-=JUAMPI=-changeStamp  ^Author changeStamp-=JUAMPI=-consistencyCheck  ^(1 to: 10) size > 0-=JUAMPI=-testModel  | class |  class := model metaclassNamed: #Bar.  (RBAddMethodTransformation model: model sourceCode: 'printString1 ^super printString' in: class withProtocol: #accessing) asRefactoring transform.  self assert: (class parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')-=JUAMPI=-testNewClassVariableAccessors  | refactoring class |  refactoring := (RBAddVariableAccessorTransformation classVariable: 'Foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  class := refactoring model metaclassNamed: #RBDummyLintRuleTest.  self denyEmpty: refactoring changes changes.  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^Foo1').  self assert: (class parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject Foo1 := anObject')-=JUAMPI=-environment  ^self-=JUAMPI=-testMetaclass  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #SomeClass) addInstanceVariable: 'foo'.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model instanceVariable: 'foo' class: (model metaclassNamed: #SomeClass)) asRefactoring transform.  self deny: ((model metaclassNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model metaclassNamed: #Subclass) directlyDefinesVariable: 'foo')-=JUAMPI=-hash  ^(self class hash bitXor: self oldName hash) bitXor: self newName hash-=JUAMPI=-errorMacro  ^errorMacro ifNil: [ self longMacro ] ifNotNil: [ super errorMacro ]-=JUAMPI=-method1  ^self method2-=JUAMPI=-unaryAccessingMessageStatementMethodWithReturn  ^self value-=JUAMPI=-testExistingSelector  self shouldFail: (RBAddMethodRefactoring addMethod: 'printString ^super printString' toClass: RBBasicLintRuleTestData inProtocols: #(#accessing))-=JUAMPI=-selectorNotReferenced  ^self selectorNotReferenced + 4-=JUAMPI=-detectContains  ^(1 to: 10) do: [:each |  each > 2 ifTrue: [ ^each ] ]-=JUAMPI=-removeMethod: aSelector from: aClass  ^self addChange: (changeFactory removeMethod: aSelector from: aClass)-=JUAMPI=-asUndoOperation  ^RBAddProtocolChange addProtocolNamed: protocol in: self changeClass-=JUAMPI=-missingYourself  ^OrderedCollection new     add: 1;     add: 2;     removeFirst-=JUAMPI=-testPullUpInstVar  | refactoring |  self proceedThroughWarning: [ refactoring := RBPullUpInstanceVariableRefactoring variable: 'result' class: RBLintRuleTestData.        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #RBLintRuleTestData) directlyDefinesInstanceVariable: 'result').  self deny: ((refactoring model classNamed: #RBBasicLintRuleTestData) directlyDefinesInstanceVariable: 'result')-=JUAMPI=-changeString  ^'Remove protocol named ' , self displayProtocolName , ' in ' , self displayClassName-=JUAMPI=-testBadInterval  self shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (14 to: 17) to: 'asdf' in: RBRefactoryTestDataApp selector: #testMethod)-=JUAMPI=-description: aString  self changes name: aString-=JUAMPI=-deny: actual equals: expected  ^self deny: expected = actual description: [ self unexpectedEqualityStringBetween: actual and: expected ]-=JUAMPI=-testMoveMethodThatReferencesPoolDictionary  | refactoring class |  self proceedThroughWarning: [ refactoring := RBMoveMethodRefactoring selector: #junk class: RBLintRuleTestData variable: 'RefactoryTestDataApp'.        self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.        self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: 'RBRefactoryTestDataApp class' asSymbol)).        self setupMethodNameFor: refactoring toReturn: #junk1.        self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class parseTreeFor: #junk) equals: (self parseMethod: 'junk ^RefactoryTestDataApp junk1').  self assert: ((refactoring model metaclassNamed: #RBRefactoryTestDataApp) parseTreeFor: #junk1) equals: (self parseMethod: 'junk1	^RBRefactoryTestDataApp printString copyFrom: 1 to: CR').  self assert: (class directlyDefinesPoolDictionary: 'TextConstants' asSymbol)-=JUAMPI=-testMoveInstVarToClassAlreadyDefined  self shouldFail: (RBMoveInstVarToClassRefactoring model: model variable: 'result' class: RBBasicLintRuleTestData oldClass: RBFooLintRuleTestData)-=JUAMPI=-methodBefore  | variable |  variable := 'String'-=JUAMPI=-copyDownMethod: aSelector  | oldProtocol oldSource superclassDefiner subclasses refactoring |  superclassDefiner := targetSuperclass whoDefinesMethod: aSelector.  superclassDefiner ifNil: [ ^self ].  oldSource := superclassDefiner sourceCodeFor: aSelector.  oldSource ifNil: [ self refactoringFailure: ('Source code for <1s> superclass method not available' expandMacrosWith: aSelector) ].  oldProtocol := superclassDefiner protocolsFor: aSelector.  subclasses := targetSuperclass subclasses reject: [:each |  each directlyDefinesMethod: aSelector ].  subclasses ifEmpty: [ ^self ].  (superclassDefiner parseTreeFor: aSelector) superMessages detect: [:each |  superclassDefiner directlyDefinesMethod: each ] ifFound: [ self refactoringError: ('Cannot pull up <1s> since we must copy down the superclass method in <2p><n>to the other subclasses, and the superclass method sends a super message which is overriden.' expandMacrosWith: aSelector with: superclassDefiner) ].  self refactoringWarning: 'Do you want to copy down the superclass method to the classes that don''t define ' , aSelector.  refactoring := RBExpandReferencedPoolsRefactoring model: self model forMethod: (superclassDefiner parseTreeFor: aSelector) fromClass: superclassDefiner toClasses: subclasses.  self performComponentRefactoring: refactoring.  subclasses do: [:each |  each compile: oldSource classified: oldProtocol ]-=JUAMPI=-modifiesCollection  | collection |  collection := (1 to: 10) asOrderedCollection.  collection do: [:each |  each > 5 ifTrue: [ collection remove: each ] ].  ^collection-=JUAMPI=-buildTransformations  ^OrderedCollection with: (RBAddVariableTransformation model: self model instanceVariable: variableName asString class: className) with: (RBRemoveVariableTransformation model: self model instanceVariable: variableName asString class: oldClass)-=JUAMPI=-removeInstanceVariable: aString  self privateInstanceVariableNames remove: aString.  model removeInstanceVariable: aString from: self-=JUAMPI=-testTransform  | transformation class |  transformation := (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'class' class: #RBTransformationRuleTestData) transform.  class := transformation model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #superSends) equals: (self parseMethod: 'superSends		| rule |		rule := RBParseTreeRewriter new.		rule addSearch: ''super `@message: ``@args'' 			-> (				[:aNode | 				(self class withAllSubclasses 					detect: [:each | each includesSelector: aNode selector]					ifNone: [nil]) isNil] 						-> ''self `@message: ``@args'').		self rewriteUsing: rule').  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 		self class: aSmalllintContext selectedClass.		(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: 				[builder 					compile: rewriteRule tree printString					in: self class					classified: aSmalllintContext protocols]]')-=JUAMPI=-displayClassName  ^isMeta ifTrue: [ self changeClassName , ' class' ] ifFalse: [ self changeClassName asString ]-=JUAMPI=-initialize  combinations := OrderedCollection new-=JUAMPI=-refersToClass  ^RBRefactoryTestDataApp-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-split: anInterval from: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  selectedInterval := anInterval-=JUAMPI=-resultClass  self subclassResponsibility-=JUAMPI=-testEncodedLatin1Url  self assert: (String with: Character space with: (Character codePoint: 233) with: (Character codePoint: 228)) urlEncodedGives: '%20%E9%E4'-=JUAMPI=-addValue: anObject  values add: anObject-=JUAMPI=-testTableColumnGroup  self assert: [:html |  html tableColumnGroup ] gives: '<colgroup></colgroup>'.  self assert: [:html |  html tableColumnGroup           character: '.';           characterOffset: 2 ] gives: '<colgroup char="." charoff="2"></colgroup>'.  self assert: [:html |  html tableColumnGroup           align: 'right';           verticalAlign: 'top' ] gives: '<colgroup align="right" valign="top"></colgroup>'.  self assert: [:html |  html tableColumnGroup           span: 3;           width: '20' ] gives: '<colgroup span="3" width="20"></colgroup>'-=JUAMPI=-next  | nextIndex |  nextIndex := self selectionIndex \\ classes size + 1.  self selected: (classes at: nextIndex)-=JUAMPI=-onContextMenu: anObject  self document scriptGenerator event: 'contextmenu' do: anObject on: self-=JUAMPI=-version  ^version-=JUAMPI=-style  ^self add: (WAStyleElement root: self)-=JUAMPI=-confirm: aString  ^self wait: [:cc |  self confirm: aString onAnswer: cc ]-=JUAMPI=-<= other  ^self quality <= other quality-=JUAMPI=-removeFromRemovals  self expression removals: (self removeAll: self selectedRemovals from: self expression removals)-=JUAMPI=-day: anObject  day := anObject-=JUAMPI=-initializeOn: aStream  self initialize-=JUAMPI=-notFound  self ifResetPossible: [ self response           notFound;           contentType: WAMimeType textHtml ].  self response nextPutAll: (WAHtmlCanvas builder           fullDocument: true;           rootBlock: [:root |  root title: 'Not Found' ];           render: [:html |  html heading: [ html text: 'Error: "'.                    html render: self request url.                    html text: '" not found' ] ])-=JUAMPI=-rawAddAllToPath: aCollectionOfStrings  aCollectionOfStrings do: [:each |  self rawAddToPath: each ]-=JUAMPI=-addTelevision  self addMedia: 'tv'-=JUAMPI=-printMilliSeconds: aNumber  ^aNumber > 2000 ifTrue: [ self printDuration: (Duration milliseconds: aNumber greaseInteger) ] ifFalse: [ aNumber > 2 ifTrue: [ aNumber greaseInteger printString , ' ms' ] ifFalse: [ (GRNumberPrinter new precision: 2) , ' ms' print: aNumber ] ]-=JUAMPI=-application  ^self parent-=JUAMPI=-renderContentOn: aRenderer  self childrenDo: [:each |  aRenderer render: each ]-=JUAMPI=-renderContentOn: html  html select     list: self options;     selected: self selection;     callback: [:value |  self selection: value ]-=JUAMPI=-renderContentOn: html  self renderExplanationOn: html.  html table: [ self renderLabel: 'Codec:' value: self requestContext codec on: html.        self renderLabel: 'Session:' value: self requestContext session on: html.        self renderLabel: 'Application:' value: self requestContext application on: html.        self renderLabel: 'Request:' value: self requestContext request on: html.        self renderLabel: 'Response:' value: self requestContext response on: html.        self renderRequestHandlersOn: html.        self renderPropertiesOn: html ]-=JUAMPI=-renderConfigurationOn: html  html form: [ html paragraph: [ self renderTypeOn: html.              html space.              self renderStartOn: html.              html space.              self renderReversedOn: html.              html space.              html submitButton ] ]-=JUAMPI=-hash  ^self host hash bitXor: self path hash-=JUAMPI=-stream  ^contentsStream-=JUAMPI=-unableToResumeResponse  | content |  content := WAHtmlCanvas builder     fullDocument: true;     rootBlock: [:root |  root title: 'Unable to proceed' ];     render: [:html |  html heading           level1;           with: 'Unable to proceed - hit the back button, and try again'.        html paragraph: 'Some exceptions cannot be resumed. You will usually see this page if you hit Proceed while debugging one of these exceptions. Your request was aborted but you can retry it by refreshing the page.' ].  self requestContext respond: [:response |  response           internalError;           contentType: self application contentType;           nextPutAll: content ]-=JUAMPI=-cellspacing: anInteger  self attributes at: 'cellspacing' put: anInteger-=JUAMPI=-testHandleFileRequest  | response |  self requestContextWithUrl: '/root/files/WATestingFiles/sample.js'.  self requestContext consumer     next;     next.  response := self responseAfter: [ handler handle: self requestContext ].  self assert: response status = 200.  self assert: response contentType main = 'application'.  self assert: response contentType sub = 'javascript'.  self assert: response contents = WATestingFiles new sampleJs-=JUAMPI=-utf16beString  ^self asString: #(0 220 0 98 0 232 0 114 0 115 0 116 0 114 0 238 0 241 0 103 0 233)-=JUAMPI=-stringForValue: anObject  ^anObject isNil ifFalse: [ anObject greaseString ]-=JUAMPI=-testEncodedXmlUnicde  | lineSeparator paragraphSeparator snowMan string |  lineSeparator := Character codePoint: 16r2028.  paragraphSeparator := Character codePoint: 16r2028.  paragraphSeparator := Character codePoint: 16r2028.  snowMan := Character codePoint: 16r2603.  string := (String with: lineSeparator) , (String with: paragraphSeparator) , (String with: snowMan).  self assert: string xmlEncodedGives: string-=JUAMPI=-preferenceAt: aSymbol  ^self configuration at: aSymbol-=JUAMPI=-builder  ^super builder     resourceUrl: (WAUrl absolute: self resourceBaseUrl);     yourself-=JUAMPI=-batchSize: aSize  batcher batchSize: aSize-=JUAMPI=-updateRoot: aRoot  super updateRoot: aRoot.  aRoot stylesheet url: WAExamplesLibrary / #todoCss.  aRoot javascript url: JQDeploymentLibrary / #jQueryJs-=JUAMPI=-childrenOf: aNode  | children |  children := self childrenBlock value: aNode.  ^children ifNil: [ Array new ]-=JUAMPI=-testAddAllFilesIn  | workingDirectory directory library |  workingDirectory := FileSystem disk workingDirectory.  workingDirectory = FileSystem root ifTrue: [ workingDirectory := FileLocator imageDirectory ].  directory := workingDirectory / 'XXXUsedBySeasideTests'.  GRPlatform current ensureExistenceOfFolder: directory pathString.  [ [ (directory / '.Seaside_Store') ensureCreateFile.  (directory / 'foo') ensureCreateFile.  GRPlatform current doSilently: [ library := WAFileLibrary subclass: #XXXTestFileLibrary instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'Uncategorized'.        [ library addAllFilesIn: directory fullName.        self assert: library selectors size = 1 ] ensure: [ library removeFromSystem ] ] ] ensure: [ directory children do: [:each |  each delete ] ] ] ensure: [ directory delete ]-=JUAMPI=-removeAll: aRemoveCollection from: aCollection  ^aCollection reject: [:each |  aRemoveCollection includes: each ]-=JUAMPI=-parseProperty  | name value |  name := self parseString.  self expectChar: $:.  value := self parseValue.  ^self createProperty: name with: value-=JUAMPI=-nextId  ^lastId := 'id' , self callbacks advanceKey-=JUAMPI=-testSettingRegularPath  | cookie |  cookie := WACookie new     key: 'name';     value: 'homer';     path: '/springfield/powerplant';     yourself.  self assert: cookie path equals: '/springfield/powerplant'.  self assert: cookie pathUnencoded equals: '/springfield/powerplant'.  self assert: cookie pathEncoded equals: '/springfield/powerplant'-=JUAMPI=-onVolumeChange: anObject  self document scriptGenerator event: 'volumechange' do: anObject on: self-=JUAMPI=-testRefreshAfterLocation  self response refreshAfter: 3 seconds location: 'http://www.seaside.st/'.  self assertLines: #('HTTP/1.1 200 OK' 'Refresh: 3; http://www.seaside.st/' 'Content-Length: 0' '')-=JUAMPI=-openOn: aDocument  super openOn: aDocument.  self writePreambleOn: aDocument-=JUAMPI=-month  ^month-=JUAMPI=-renderConfigurationOn: html  self subclassResponsibility-=JUAMPI=-addCc: anEmailAddress  ^self cc add: anEmailAddress-=JUAMPI=-pathStringSafeUnencoded  | stream |  stream := WriteStream on: (String new: self pathStringUnencodedSize).  self pathUnencodedOn: stream.  ^stream contents-=JUAMPI=-keyFromContext: aRequestContext  self subclassResponsibility-=JUAMPI=-renderGroup: aBlock named: aName on: html  html div     class: 'group';     with: [ html div           class: 'groupTitle';           with: [ html label: aName.              self renderActionsOn: html ].        self collapsed ifFalse: [ self showHelp ifTrue: [ html div                       class: 'help';                       with: [ html code: (self class helpTextFor: group) ] ] ifFalse: [ html div                       class: 'groupContent';                       with: aBlock ] ] ]-=JUAMPI=-renderButtonsOn: html  html paragraph: [ dialog ifTrue: [ html submitButton on: #ok of: self ].        html submitButton on: #apply of: self.        html cancelButton on: #cancel of: self ]-=JUAMPI=-isServerRunning  ^self serverInstance isRunning-=JUAMPI=-testDeleteSessionCookieDomain  | context request response cookie |  request := self requestWithMethod: 'GET'.  request setCookies: (Array with: (WARequestCookie key: '_s' value: 'goner')).  response := WABufferedResponse new.  context := WARequestContext request: request response: response.  [ handler handle: context ] on: WAResponseNotification do: [:notification |   ].  self assert: response status = 302.  self assert: response cookies size = 1.  cookie := response cookies first.  self assert: cookie domain = 'www.seaside.st'-=JUAMPI=-attributeAt: aSymbol ifAbsent: aBlock  ^self allAttributes at: aSymbol ifAbsent: aBlock-=JUAMPI=-flush  -=JUAMPI=-classesWithManyInstances  ^Array streamContents: [:stream |  Smalltalk globals keysAndValuesDo: [:key :value |  ((value isKindOf: Class) and: [ key == value name ]) ifTrue: [ | class |                    class := Smalltalk globals at: key.                    (self shouldConsider: class) ifTrue: [ stream nextPut: class ] ] ] ]-=JUAMPI=-testUrlOf  self assert: (WATestingFiles / #samplePng) greaseString = '/files/WATestingFiles/sample.png'-=JUAMPI=-request: aRequestString label: aLabelString  ^self wait: [:cc |  self request: aRequestString label: aLabelString onAnswer: cc ]-=JUAMPI=-tableData  ^self brush: WATableDataTag new-=JUAMPI=-browserSessionIDCookieKey  ^'seaside_browser_session'-=JUAMPI=-size  ^dictionary size-=JUAMPI=-ensureId  ^self attributes at: 'id' ifAbsentPut: [ canvas nextId ]-=JUAMPI=-buildDescription  | d |  d := WAConfigurationDescription new.  self describeOn: d.  ^description := d-=JUAMPI=-renderContentOn: html  self renderExplanationOn: html.  self renderLinksOn: html-=JUAMPI=-document  ^document-=JUAMPI=-nextPutAll: aString  self subclassResponsibility-=JUAMPI=-actionUrl  ^actionUrl-=JUAMPI=-testLanguageName  | locale |  locale := WALocale fromString: 'de'.  self assert: locale languageName = 'German'.  locale := WALocale fromString: 'gsw'.  self assert: locale languageName = 'Swiss German; Alemannic; Alsatian'-=JUAMPI=-cookies  ^self requestContext request cookies-=JUAMPI=-testTakeServerParametersFromRequestBase  | request |  request := (WARequest method: 'GET' uri: (WAUrl new           scheme: 'https';           yourself))     setHeaders: (Dictionary new           at: 'host' put: 'www.thehost.com:1337';           yourself);     yourself.  url takeServerParametersFromRequest: request.  self assert: url greaseString = 'https://www.thehost.com:1337/'-=JUAMPI=-renderRow: anObject index: aNumber on: html  self renderHeadingForRow: anObject on: html.  self datesDo: [:date |  self renderCellForDate: date row: anObject index: aNumber on: html ] separatedBy: [ self renderHeadingSpacerOn: html ]-=JUAMPI=-handleFiltered: aRequestContext  aRequestContext request isPrefetch ifTrue: [ self handlePrefetch: aRequestContext ] ifFalse: [ (self isImplemented: aRequestContext request method) ifTrue: [ super handleFiltered: aRequestContext ] ifFalse: [ aRequestContext responseGenerator                 notImplemented;                 respond ] ]-=JUAMPI=-testWithoutValue  self should: [ WACurrentRequestContext value ] raise: WARequestContextNotFound-=JUAMPI=-addHaloVisitor: aHaloVisitor  visitor := visitor addHaloVisitor: aHaloVisitor-=JUAMPI=-<= otherVersion  ^self = otherVersion or: [ self < otherVersion ]-=JUAMPI=-renderContentOn: html  html table     cellspacing: 0;     cellpadding: 0;     style: 'width: 100%';     with: [ html tableRow: [ html tableData                 verticalAlign: 'top';                 style: 'padding: 4px; width: 250px;';                 with: [ self renderDispatcherOn: html ].              html tableData                 verticalAlign: 'top';                 style: 'padding: 4px';                 with: [ self renderEditorOn: html ] ] ]-=JUAMPI=-next  ^path removeFirst-=JUAMPI=-testNoFieldCookieHandlerPresent  | response context key |  registry := self createRegistryWithCookiesEnabled.  key := self registerNewHandler.  context := self createRequestContextWithFieldKey: nil cookieKey: key.  response := self dispatch: context to: registry.  self assertNoCookies: response.  self assertDispatched: response-=JUAMPI=-handle: aRequestContext  aRequestContext push: self during: [ self filter handleFiltered: aRequestContext ]-=JUAMPI=-addCallback  self hasCallback ifFalse: [ canvas flush.        ^self ].  canvas hiddenInput     callback: [ callbackBlock value: self setValueWithNewTime ];     with: nil-=JUAMPI=-index: aNumber  valueBlock := [:row |  row at: aNumber ]-=JUAMPI=-absoluteExamples  ^#('http://www.seaside.st/' 'http://www.seaside.st:8080/' 'http://lukas@www.seaside.st/' 'http://lukas:renggli@www.seaside.st/' 'http://www.seaside.st/resources' 'http://www.seaside.st/styles/favicon.png' 'http://www.seaside.st/%24%26%2B%2C%2F%3A%3B%3D%3F%40' 'http://www.seaside.st/#top' 'http://www.seaside.st/styles#top' 'http://www.seaside.st/about/screenshots?_c' 'http://www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn' 'http://www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn&_k=lZWXfESZ' 'http://www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn&_k=lZWXfESZ&_n&47' 'http://www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn&_k=lZWXfESZ&_n&47#149361951' 'http://www.seaside.st/;jsessionid=42?redirectcounter=1' 'http://www.seaside.st/seaside/files;old/WAStandardFiles;key1=value1,value3;key2=value2/seaside.jpg;jsessionid=42?redirectcounter=1' 'http://www.seaside.st/seaside/WAStandardFiles;session%3Aid=42?redirectcounter=1' 'http://lukas:renggli@www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn&_k=lZWXfESZ&_n&47#149361951' 'http://lukas:renggli@www.seaside.st:8080/about/screenshots?_s=XrkNBpErXTKlVRhn&_k=lZWXfESZ&_n&47#149361951')-=JUAMPI=-states  ^Array with: self-=JUAMPI=-at: aKey put: anObject  | present value |  present := false.  value := WABulkReapingCacheEntry value: anObject.  dictionary at: aKey ifAbsentPut: [ present := true.        value ].  present ifTrue: [ ^anObject ].  dictionary at: aKey put: value.  ^anObject-=JUAMPI=-requestFor: aNativeRequest  ^(WARequest method: (self requestMethodFor: aNativeRequest) uri: (self requestUrlFor: aNativeRequest) version: (self requestVersionFor: aNativeRequest))     setHeaders: (self requestHeadersFor: aNativeRequest);     setBody: (self requestBodyFor: aNativeRequest);     setPostFields: (self requestFieldsFor: aNativeRequest);     setCookies: (self requestCookiesFor: aNativeRequest);     setRemoteAddress: (self requestAddressFor: aNativeRequest);     setSslSessionId: (self sslSessionIdFor: aNativeRequest);     yourself-=JUAMPI=-children  ^Array with: navigation-=JUAMPI=-testForm  | handler context |  self formClassExists ifFalse: [ ^self ].  handler := WADocumentHandler document: self sampleForm mimeType: self sampleForm defaultMimeType fileName: nil.  context := WARequestContext request: WARequest new response: WABufferedResponse new.  [ handler handle: context ] on: WAResponseNotification do: [:n |   ].  self assert: context response notNil-=JUAMPI=-initializeOn: aStream  super initializeOn: aStream.  contentsStream := aStream-=JUAMPI=-inlineWithFileName: aString  aString notNil ifTrue: [ self headerAt: 'Content-Disposition' put: 'inline; filename="' , aString greaseString , '"' ]-=JUAMPI=-testAddKeyOfSessionToUrlCookieAlreadyPresent  | context uri cookie1 |  context := self requestContext.  cookie1 := WARequestCookie key: strategy keyCookieName value: 'The_Metaphor'.  context request setCookies: (Array with: cookie1).  uri := context request uri copy.  strategy addKey: 'The_Metaphor' toUrl: uri.  self assert: uri greaseString = '/1/2'-=JUAMPI=-startRow  ^rowSelectionStart min: rowSelectionEnd-=JUAMPI=-postCopy  super postCopy.  expressions := expressions copy.  parents := parents copy-=JUAMPI=-newHandler  ^WARegistry new-=JUAMPI=-verifyRequest: aRequest  ^self authenticator verifyPassword: aRequest password forUser: aRequest user-=JUAMPI=-addKey: aString toContext: aRequestContext  ^(self strategyFor: aRequestContext) addKey: aString toContext: aRequestContext-=JUAMPI=-removeExpressionAt: aSymbol  ^self removeExpressionAt: aSymbol ifAbsent: [ nil ]-=JUAMPI=-jumpToAnchor: aString  | actionContinuation |  actionContinuation := self requestContext handlers detect: [:each |  each isActionContinuation ] ifNone: [ WAIllegalStateException signal: 'You can only send #jumpToAnchor: from within a callback' ].  actionContinuation jumpToAnchor: aString-=JUAMPI=-testExpirePrinting  | cookie |  cookie := WACookie key: 'foo' value: 'bar'.  cookie expiry: (DateAndTime year: 2003 day: 4 hour: 5 minute: 6 second: 7 offset: Duration zero).  self assert: cookie rfc6265String = 'foo=bar; expires=Sat, 04-Jan-2003 05:06:07 GMT; path=/'-=JUAMPI=-setUp  handler := WALegacyRedirectionHandler new-=JUAMPI=-realm  ^realm ifNil: [ realm := 'Seaside' ]-=JUAMPI=-deployFiles  GRPlatform current ensureExistenceOfFolder: self name.  self fileSelectors do: [:each |  | folderInfo |        folderInfo := self asFileAndFoldername: each.        GRPlatform current ensureExistenceOfFolder: folderInfo first.        GRPlatform current write: (self fileResourceOf: each) contents value toFile: folderInfo second inFolder: folderInfo first ]-=JUAMPI=-onSelect: anObject  self document scriptGenerator event: 'select' do: anObject on: self-=JUAMPI=-addXmlNamespaces  self htmlAttributes     at: 'xmlns' put: 'http://www.w3.org/1999/xhtml';     at: 'xml:lang' put: 'en';     at: 'lang' put: 'en'-=JUAMPI=-summary  ^self tag: 'summary'-=JUAMPI=-context  ^context-=JUAMPI=-visitPainter: aPainter  aPainter updateRoot: self root-=JUAMPI=-value: anObject  value := anObject-=JUAMPI=-libraries  ^(self preferenceAt: #libraries) collect: [:each |  each value ]-=JUAMPI=-handleFiltered: aRequestContext  self responseForContext: aRequestContext-=JUAMPI=-delay  ^delay ifNil: [ 1 ]-=JUAMPI=-createRequest  ^WARequest new-=JUAMPI=-maximumRelativeAge: aStringOrAnInteger  maximumRelativeAge := aStringOrAnInteger asUnsignedInteger-=JUAMPI=-valueForField: anObject  ^anObject-=JUAMPI=-children  ^super children copyWith: cacheEditor-=JUAMPI=-allPresentersDo: aBlock  (WAAllPresenterGuide client: (WAPluggablePresenterVisitor block: aBlock)) start: self-=JUAMPI=-low: anInteger  self attributeAt: 'low' put: anInteger-=JUAMPI=-initialize  super initialize.  ipStrategy := WAIPSessionTrackingStrategy new.  cookieStrategy := WACookieOnlySessionTrackingStrategy new-=JUAMPI=-initialize  super initialize.  self     rows: 'auto';     columns: 'auto'-=JUAMPI=-dateAndTime: anObject  dateSelector date: anObject asDate.  timeSelector time: anObject asTime-=JUAMPI=-subscript  ^self tag: 'sub'-=JUAMPI=-destroy  self shouldDestroy ifTrue: [ self request destroy.        self response destroy.        handlers := request := response := codec := properties := nil ]-=JUAMPI=-defaultConfiguration  ^WAUserConfiguration new     addParent: WARequestHandlingConfiguration instance;     yourself-=JUAMPI=-type  ^'range'-=JUAMPI=-renderRow: aHandler named: aString on: html  html tableRow: [ html tableData: [ self renderRowName: aHandler named: aString on: html ].        html tableData: [ self renderRowDescription: aHandler on: html ] ]-=JUAMPI=-resume: anException  self open: anException.  ^self basicResume: anException-=JUAMPI=-canStop: aServerAdaptor  ^aServerAdaptor isStopped not-=JUAMPI=-renderContext  ^WARenderContext new     actionUrl: WAUrl new;     document: (WAHtmlDocument on: (WriteStream on: String new));     yourself-=JUAMPI=-initialRequest: aRequest  super initialRequest: aRequest.  self requestContext consumer nextIfPresentDo: [:className |  classes do: [:each |  each name greaseString = className ifTrue: [ self selected: each ] ] ]-=JUAMPI=-deleteCookieAt: aKeyString  self deleteCookie: (WACookie key: aKeyString value: '')-=JUAMPI=-startDate: aDate  self clearSelection.  super startDate: aDate-=JUAMPI=-renderSpacerRowOn: html  html div     class: 'dialog-spacer';     with: [ html space ]-=JUAMPI=-attributes: anObject  attributes := anObject-=JUAMPI=-canSelect: aDate  ^canSelectBlock value: aDate-=JUAMPI=-lineBreakOpportunity: aBlock  self lineBreakOpportunity with: aBlock-=JUAMPI=-gone  self status: WAResponse statusGone-=JUAMPI=-initialize  super initialize.  self urlencoded: 'urlencoded'.  self multipart: 'multipart'.  self get: 'get'-=JUAMPI=-setHeaders: headerDictionary  headers := headerDictionary-=JUAMPI=-valueWithArguments: anArray  anArray size = 1 ifFalse: [ ^GRInvalidArgumentCount signal: 'Continuations can only be resumed with one argument.' ].  self value: anArray first-=JUAMPI=-beSubmit  type := 'submit'-=JUAMPI=-priority  ^200-=JUAMPI=-pathElementsIn: aString do: aOneArgumentBlock  GRPlatform subStringsIn: aString splitBy: $/ do: aOneArgumentBlock-=JUAMPI=-lastId  ^lastId-=JUAMPI=-clear  dictionary do: [:value |  self cacheEntryRemoved: value value ].  dictionary removeAll-=JUAMPI=-initializeWithUrl: aUrl  self initialize.  url := aUrl-=JUAMPI=-serverPort: anInteger  self preferenceAt: #serverPort put: anInteger-=JUAMPI=-initialize  super initialize.  self altText: ''-=JUAMPI=-memorySvg  ^'<?xml version="1.0" encoding="UTF-8" standalone="no"?><!-- Created with Inkscape (http://www.inkscape.org/) --><svg   xmlns:dc="http://purl.org/dc/elements/1.1/"   xmlns:cc="http://creativecommons.org/ns#"   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"   xmlns:svg="http://www.w3.org/2000/svg"   xmlns="http://www.w3.org/2000/svg"   xmlns:xlink="http://www.w3.org/1999/xlink"   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"   width="48px"   height="48px"   id="svg1306"   sodipodi:version="0.32"   inkscape:version="0.46"   sodipodi:docbase="/home/jimmac/src/cvs/tango-icon-theme/scalable/apps"   sodipodi:docname="utilities-system-monitor.svg"   inkscape:output_extension="org.inkscape.output.svg.inkscape">  <defs     id="defs1308">    <inkscape:perspective       sodipodi:type="inkscape:persp3d"       inkscape:vp_x="0 : 24 : 1"       inkscape:vp_y="0 : 1000 : 0"       inkscape:vp_z="48 : 24 : 1"       inkscape:persp3d-origin="24 : 16 : 1"       id="perspective69" />    <radialGradient       inkscape:collect="always"       xlink:href="#linearGradient5060"       id="radialGradient5031"       gradientUnits="userSpaceOnUse"       gradientTransform="matrix(-2.774389,0,0,1.969706,112.7623,-872.8854)"       cx="605.71429"       cy="486.64789"       fx="605.71429"       fy="486.64789"       r="117.14286" />    <linearGradient       inkscape:collect="always"       id="linearGradient5060">      <stop         style="stop-color:black;stop-opacity:1;"         offset="0"         id="stop5062" />      <stop         style="stop-color:black;stop-opacity:0;"         offset="1"         id="stop5064" />    </linearGradient>    <radialGradient       inkscape:collect="always"       xlink:href="#linearGradient5060"       id="radialGradient5029"       gradientUnits="userSpaceOnUse"       gradientTransform="matrix(2.774389,0,0,1.969706,-1891.633,-872.8854)"       cx="605.71429"       cy="486.64789"       fx="605.71429"       fy="486.64789"       r="117.14286" />    <linearGradient       id="linearGradient5048">      <stop         style="stop-color:black;stop-opacity:0;"         offset="0"         id="stop5050" />      <stop         id="stop5056"         offset="0.5"         style="stop-color:black;stop-opacity:1;" />      <stop         style="stop-color:black;stop-opacity:0;"         offset="1"         id="stop5052" />    </linearGradient>    <linearGradient       inkscape:collect="always"       xlink:href="#linearGradient5048"       id="linearGradient5027"       gradientUnits="userSpaceOnUse"       gradientTransform="matrix(2.774389,0,0,1.969706,-1892.179,-872.8854)"       x1="302.85715"       y1="366.64789"       x2="302.85715"       y2="609.50507" />    <linearGradient       inkscape:collect="always"       id="linearGradient2223">      <stop         style="stop-color:#ffffff;stop-opacity:1;"         offset="0"         id="stop2225" />      <stop         style="stop-color:#ffffff;stop-opacity:0;"         offset="1"         id="stop2229" />    </linearGradient>    <linearGradient       id="linearGradient2222">      <stop         style="stop-color:#5187d6;stop-opacity:1;"         offset="0"         id="stop2224" />      <stop         style="stop-color:#1e4580;stop-opacity:1;"         offset="1"         id="stop2227" />    </linearGradient>    <linearGradient       id="linearGradient3090">      <stop         style="stop-color:#626c07;stop-opacity:1;"         offset="0"         id="stop3092" />      <stop         style="stop-color:#313603;stop-opacity:1;"         offset="1"         id="stop3094" />    </linearGradient>    <linearGradient       inkscape:collect="always"       id="linearGradient2238">      <stop         style="stop-color:#ffffff;stop-opacity:1;"         offset="0"         id="stop2240" />      <stop         style="stop-color:#ffffff;stop-opacity:0;"         offset="1"         id="stop2242" />    </linearGradient>    <linearGradient       id="linearGradient2224">      <stop         style="stop-color:#32342f;stop-opacity:0.54639173;"         offset="0.0000000"         id="stop2226" />      <stop         style="stop-color:#32342f;stop-opacity:0;"         offset="1"         id="stop2228" />    </linearGradient>    <linearGradient       id="linearGradient2214">      <stop         style="stop-color:#a9aaa7;stop-opacity:1.0000000;"         offset="0.0000000"         id="stop2216" />      <stop         style="stop-color:#676964;stop-opacity:1.0000000;"         offset="1.0000000"         id="stop2218" />    </linearGradient>    <linearGradient       id="linearGradient2206">      <stop         style="stop-color:#c3c6c0;stop-opacity:1.0000000;"         offset="0.0000000"         id="stop2208" />      <stop         style="stop-color:#e8eae6;stop-opacity:1.0000000;"         offset="1.0000000"         id="stop2210" />    </linearGradient>    <linearGradient       id="linearGradient2198">      <stop         style="stop-color:#32342f;stop-opacity:1;"         offset="0"         id="stop2200" />      <stop         style="stop-color:#171816;stop-opacity:1.0000000;"         offset="1.0000000"         id="stop2202" />    </linearGradient>    <linearGradient       inkscape:collect="always"       id="linearGradient2180">      <stop         style="stop-color:#ffffff;stop-opacity:1;"         offset="0"         id="stop2182" />      <stop         style="stop-color:#ffffff;stop-opacity:0;"         offset="1"         id="stop2184" />    </linearGradient>    <linearGradient       inkscape:collect="always"       xlink:href="#linearGradient2206"       id="linearGradient2212"       x1="25.861118"       y1="26.133587"       x2="18.300278"       y2="19.567596"       gradientUnits="userSpaceOnUse"       gradientTransform="matrix(0.952387,0.000000,0.000000,1.018339,1.142599,-1.941627)" />    <linearGradient       inkscape:collect="always"       xlink:href="#linearGradient2214"       id="linearGradient2220"       x1="0.0012142062"       y1="24.012266"       x2="47.998765"       y2="24.012266"       gradientUnits="userSpaceOnUse"       gradientTransform="matrix(0.952387,0.000000,0.000000,1.018339,1.142599,-1.941627)" />    <radialGradient       inkscape:collect="always"       xlink:href="#linearGradient2224"       id="radialGradient2230"       cx="24.041630"       cy="42.242130"       fx="24.041630"       fy="42.242130"       r="17.576654"       gradientTransform="matrix(1.000000,0.000000,0.000000,0.304598,-5.757924e-16,29.37527)"       gradientUnits="userSpaceOnUse" />    <linearGradient       inkscape:collect="always"       xlink:href="#linearGradient2238"       id="linearGradient2244"       x1="20.338758"       y1="19.636894"       x2="46.092255"       y2="39.708324"       gradientUnits="userSpaceOnUse"       gradientTransform="matrix(0.952387,0.000000,0.000000,1.015657,1.142599,-0.876325)" />    <linearGradient       inkscape:collect="always"       xlink:href="#linearGradient2180"       id="linearGradient1340"       gradientUnits="userSpaceOnUse"       gradientTransform="matrix(3.809547,0.000000,0.000000,1.750325,-16.00036,-15.78719)"       x1="8.8207808"       y1="12.53757"       x2="12.499243"       y2="24.238262" />    <radialGradient       inkscape:collect="always"       xlink:href="#linearGradient2222"       id="radialGradient2229"       cx="23.994133"       cy="32.266911"       fx="23.994133"       fy="32.266911"       r="19.088932"       gradientTransform="matrix(1.768625,-1.961257e-23,1.552064e-23,1.387102,-18.44248,-15.29268)"       gradientUnits="userSpaceOnUse" />    <linearGradient       inkscape:collect="always"       xlink:href="#linearGradient2223"       id="linearGradient2231"       x1="35.694206"       y1="37.333858"       x2="15.044075"       y2="5.9588566"       gradientUnits="userSpaceOnUse" />  </defs>  <sodipodi:namedview     id="base"     pagecolor="#ffffff"     bordercolor="#666666"     borderopacity="0.25490196"     inkscape:pageopacity="0.0"     inkscape:pageshadow="2"     inkscape:zoom="1"     inkscape:cx="-105.4283"     inkscape:cy="21.335249"     inkscape:current-layer="layer1"     showgrid="false"     inkscape:grid-bbox="true"     inkscape:document-units="px"     inkscape:window-width="1064"     inkscape:window-height="782"     inkscape:window-x="370"     inkscape:window-y="66"     inkscape:showpageshadow="false"     fill="#204a87" />  <metadata     id="metadata1311">    <rdf:RDF>      <cc:Work         rdf:about="">        <dc:format>image/svg+xml</dc:format>        <dc:type           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />        <dc:title>System Monitor</dc:title>        <dc:date>2005-10-10</dc:date>        <dc:creator>          <cc:Agent>            <dc:title>Andreas Nilsson</dc:title>          </cc:Agent>        </dc:creator>        <dc:subject>          <rdf:Bag>            <rdf:li>system</rdf:li>            <rdf:li>monitor</rdf:li>            <rdf:li>performance</rdf:li>          </rdf:Bag>        </dc:subject>        <cc:license           rdf:resource="http://creativecommons.org/licenses/publicdomain/" />        <dc:contributor>          <cc:Agent>            <dc:title>Jakub Steiner</dc:title>          </cc:Agent>        </dc:contributor>      </cc:Work>      <cc:License         rdf:about="http://creativecommons.org/licenses/publicdomain/">        <cc:permits           rdf:resource="http://creativecommons.org/ns#Reproduction" />        <cc:permits           rdf:resource="http://creativecommons.org/ns#Distribution" />        <cc:permits           rdf:resource="http://creativecommons.org/ns#DerivativeWorks" />      </cc:License>    </rdf:RDF>  </metadata>  <g     id="layer1"     inkscape:label="Layer 1"     inkscape:groupmode="layer">    <g       id="g5022"       transform="matrix(2.454499e-2,0,0,2.086758e-2,45.89369,40.09109)">      <rect         y="-150.69685"         x="-1559.2523"         height="478.35718"         width="1339.6335"         id="rect4173"         style="opacity:0.40206185;color:black;fill:url(#linearGradient5027);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible" />      <path         sodipodi:nodetypes="cccc"         id="path5058"         d="M -219.61876,-150.68038 C -219.61876,-150.68038 -219.61876,327.65041 -219.61876,327.65041 C -76.744594,328.55086 125.78146,220.48075 125.78138,88.454235 C 125.78138,-43.572302 -33.655436,-150.68036 -219.61876,-150.68038 z "         style="opacity:0.40206185;color:black;fill:url(#radialGradient5029);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible" />      <path         style="opacity:0.40206185;color:black;fill:url(#radialGradient5031);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible"         d="M -1559.2523,-150.68038 C -1559.2523,-150.68038 -1559.2523,327.65041 -1559.2523,327.65041 C -1702.1265,328.55086 -1904.6525,220.48075 -1904.6525,88.454235 C -1904.6525,-43.572302 -1745.2157,-150.68036 -1559.2523,-150.68038 z "         id="path5018"         sodipodi:nodetypes="cccc" />    </g>    <rect       style="opacity:1;fill:url(#linearGradient2212);fill-opacity:1;fill-rule:evenodd;stroke:url(#linearGradient2220);stroke-width:0.9999997;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"       id="rect1316"       width="44.759838"       height="41.701817"       x="1.6199486"       y="1.6600797"       rx="4.5659914"       ry="4.5659928" />    <rect       style="opacity:1;fill:url(#radialGradient2229);fill-opacity:1;fill-rule:evenodd;stroke:#173562;stroke-width:0.99999982;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"       id="rect1314"       width="37.177864"       height="28.954594"       x="5.4052019"       y="5.4815545"       rx="1.6946707"       ry="1.694671" />    <path       style="opacity:1;fill:#ecffd9;fill-opacity:1;fill-rule:evenodd;stroke:#c3ea9b;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:0.41618497"       d="M 12.390689,20.935247 L 6.3688614,20.935247 L 6.3688614,22.152253 L 14.087646,22.152253 L 15.493568,16.239132 L 18.956082,29.936652 L 22.164804,19.116952 L 25.059348,25.028755 L 28.946308,21.516786 L 41.654736,21.516786 L 41.654736,19.457141 L 28.505235,19.457141 L 25.335019,22.596741 L 22.059557,15.937588 L 19.049723,24.112486 L 15.78119,11.248712 L 12.390689,20.935247 z "       id="path2188"       sodipodi:nodetypes="ccccccccccccccccc" />    <rect       style="opacity:1;fill:none;fill-opacity:1;fill-rule:evenodd;stroke:url(#linearGradient2244);stroke-width:0.99999982;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"       id="rect2232"       width="42.894741"       height="39.646549"       x="2.553669"       y="2.6544337"       rx="4.1303334"       ry="4.1303344" />    <path       sodipodi:nodetypes="ccccccccccccccccc"       id="path3088"       d="M 11.515689,20.012278 L 6.3688614,20.012278 L 6.3688614,23.061029 L 14.962646,22.936029 L 15.618568,19.893387 L 18.963229,32.601726 L 22.539804,21.135091 L 25.059348,26.551191 L 29.321308,22.442609 L 41.654736,22.317609 L 40.904736,18.408071 L 28.505235,18.283071 L 25.460019,21.456026 L 22.059557,13.665616 L 19.424723,20.604266 L 15.90619,8.333659 L 11.515689,20.012278 z "       style="opacity:0.38068183;fill:#ecffd9;fill-opacity:1;fill-rule:evenodd;stroke:#c3ea9b;stroke-width:1.00000036;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:0.41618497" />    <path       style="opacity:0.43181817;fill:url(#linearGradient1340);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"       d="M 6.84375,6.96875 L 6.84375,15.795073 C 10.513653,16.483179 14.582567,16.875 18.875,16.875 C 27.810295,16.875 35.812258,15.21019 41.15625,12.596829 L 41.15625,6.96875 L 6.84375,6.96875 z "       id="rect2178"       sodipodi:nodetypes="ccsccc" />    <g       id="g3126"       style="opacity:0.07954544;fill:#000000;fill-opacity:1;stroke:#000000;stroke-opacity:1"       transform="translate(0.187500,0.687500)">      <path         style="opacity:1;color:#000000;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:10;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible"         d="M 39.125,37.8125 L 38.0625,37.34375 C 37.805688,37.204184 37.500156,37.125 37.1875,37.125 C 36.187,37.125 35.375,37.937 35.375,38.9375 C 35.375,39.938 36.187,40.75 37.1875,40.75 C 38.156734,40.75 38.951426,39.988481 39,39.03125 C 39.000392,39.02353 38.999705,39.007745 39,39 L 39.125,37.8125 z "         id="path3120"         sodipodi:nodetypes="ccsssscc" />      <path         sodipodi:nodetypes="ccsssscc"         id="path3122"         d="M 28.992526,37.544659 L 28.893139,38.709836 C 28.855813,38.999729 28.892396,39.313228 29.005385,39.604754 C 29.366952,40.537636 30.417519,41.001313 31.350402,40.639747 C 32.283284,40.27818 32.746961,39.227613 32.385394,38.29473 C 32.035127,37.391001 31.037884,36.925219 30.127792,37.225858 C 30.120452,37.228282 30.105982,37.234627 30.098654,37.237151 L 28.992526,37.544659 z "         style="opacity:1;color:#000000;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:10;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible" />      <path         style="opacity:1;color:#000000;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:10;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible"         d="M 25.5,37.8125 L 24.5625,37.34375 C 24.305688,37.204184 24.000156,37.125 23.6875,37.125 C 22.687,37.125 21.875,37.937 21.875,38.9375 C 21.875,39.938 22.687,40.75 23.6875,40.75 C 24.656734,40.75 25.451426,39.988481 25.5,39.03125 C 25.500392,39.02353 25.499705,39.007745 25.5,39 L 25.5,37.8125 z "         id="path3124"         sodipodi:nodetypes="ccsssscc" />    </g>    <path       style="opacity:1;color:#000000;fill:#e0e2df;fill-opacity:1;fill-rule:nonzero;stroke:#9b9d99;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:10;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible"       d="M 39.125,37.8125 L 38.0625,37.34375 C 37.805688,37.204184 37.500156,37.125 37.1875,37.125 C 36.187,37.125 35.375,37.937 35.375,38.9375 C 35.375,39.938 36.187,40.75 37.1875,40.75 C 38.156734,40.75 38.951426,39.988481 39,39.03125 C 39.000392,39.02353 38.999705,39.007745 39,39 L 39.125,37.8125 z "       id="path3111"       sodipodi:nodetypes="ccsssscc" />    <path       sodipodi:nodetypes="ccsssscc"       id="path3116"       d="M 28.992526,37.544659 L 28.893139,38.709836 C 28.855813,38.999729 28.892396,39.313228 29.005385,39.604754 C 29.366952,40.537636 30.417519,41.001313 31.350402,40.639747 C 32.283284,40.27818 32.746961,39.227613 32.385394,38.29473 C 32.035127,37.391001 31.037884,36.925219 30.127792,37.225858 C 30.120452,37.228282 30.105982,37.234627 30.098654,37.237151 L 28.992526,37.544659 z "       style="opacity:1;color:#000000;fill:#e0e2df;fill-opacity:1;fill-rule:nonzero;stroke:#9b9d99;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:10;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible" />    <path       style="opacity:1;color:#000000;fill:#e0e2df;fill-opacity:1;fill-rule:nonzero;stroke:#9b9d99;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;marker:none;marker-start:none;marker-mid:none;marker-end:none;stroke-miterlimit:10;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;visibility:visible;display:inline;overflow:visible"       d="M 25.5,37.8125 L 24.5625,37.34375 C 24.305688,37.204184 24.000156,37.125 23.6875,37.125 C 22.687,37.125 21.875,37.937 21.875,38.9375 C 21.875,39.938 22.687,40.75 23.6875,40.75 C 24.656734,40.75 25.451426,39.988481 25.5,39.03125 C 25.500392,39.02353 25.499705,39.007745 25.5,39 L 25.5,37.8125 z "       id="path3118"       sodipodi:nodetypes="ccsssscc" />    <rect       ry="2.5696716"       rx="2.5696716"       y="4.635767"       x="4.3192058"       height="30.646179"       width="39.349869"       id="rect2221"       style="opacity:0.57386364;fill:none;fill-opacity:1;fill-rule:evenodd;stroke:url(#linearGradient2231);stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1" />  </g></svg>'-=JUAMPI=-selectedRemovals  ^(selectionsCurrent select: [:each |  each key = #remove ]) collect: [:assoc |  assoc value ]-=JUAMPI=-renderCellForDate: aDate row: anObject index: aNumber on: html  html tableData: [ html space ]-=JUAMPI=-testHolder  | original snapshot1 snapshot2 snapshot3 |  original := WAValueHolder new.  snapshot1 := original snapshotCopy.  original contents: 1.  snapshot2 := original snapshotCopy.  original contents: 2.  snapshot3 := original snapshotCopy.  original restoreFromSnapshot: snapshot1.  self assert: original contents isNil.  original restoreFromSnapshot: snapshot2.  self assert: original contents equals: 1.  original restoreFromSnapshot: snapshot3.  self assert: original contents equals: 2-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream     nextPutAll: ' contents: ';     print: self contents-=JUAMPI=-date  (self privateIsValidDay: day monthNumber: month year: year) ifFalse: [ self error: 'Invalid date' ].  ^self dateClass year: year month: month day: day-=JUAMPI=-allSelectors  ^(class class selectors select: [:each |  each beginsWithSubCollection: self selectorPrefix ]) sorted-=JUAMPI=-sourceSet: aString  self attributes at: 'srcset' put: aString-=JUAMPI=-pathParameterAt: anIndex key: aKey ifAbsent: aZeroArgumentBlock  ^self privatePathParameterMapAt: anIndex ifPresentDo: [:parameters |  parameters at: aKey ifAbsent: aZeroArgumentBlock ] ifAbsent: aZeroArgumentBlock-=JUAMPI=-potentialFilters  ^WAConfiguredRequestFilter allSubclasses-=JUAMPI=-visitStringAttribute: anAttribute  self visitAttribute: anAttribute-=JUAMPI=-initialize  super initialize.  tree := WATree new     root: Collection;     labelBlock: [:class |  class name ];     childrenBlock: [:class |  class subclasses ];     selectBlock: [:class |  selected := class name ];     canSelectBlock: [:class |  class subclasses notEmpty ];     yourself-=JUAMPI=-hash  ^self document hash-=JUAMPI=-makePlainTextAndPerform: aSelector  self ifResetPossible: [ | mimeType response |        response := self response.        response perform: aSelector.        mimeType := WAMimeType textPlain.        mimeType charset: self requestContext charSet.        response contentType: mimeType ]-=JUAMPI=-context  ^context-=JUAMPI=-initialize  super initialize.  expressions := Dictionary new.  parents := OrderedCollection new-=JUAMPI=-testCookieAfterCommit  self response flush.  self should: [ self response addCookie: WACookie new ] raise: WAIllegalStateException-=JUAMPI=-count  ^512-=JUAMPI=-callbacks  ^self context callbacks-=JUAMPI=-testPathEncoding  | cookies cookie |  cookies := WARequestCookie fromString: '$Version="1";                 Customer="WILE_E_COYOTE"; $Path="/%20"' codec: GRNullCodec new.  self assert: cookies size = 1.  cookie := cookies first.  self assert: cookie path = '/ '.  self assert: cookie pathUnencoded = '/ '.  self assert: cookie pathEncoded = '/%20'-=JUAMPI=-renderContentOn: html  html header: [ html heading           level1;           with: [ html anchor                 url: 'http://www.elharo.com/blog';                 with: 'Mokka mit Schlag' ] ].  html section: [ html article: [ html heading                 level2;                 with: [ html anchor                       url: '/blog/birding/2007/04/23/spring-comes-and-goes-in-sussex-county/';                       with: 'Spring Comes (and Goes) in Sussex County' ].              html paragraph: 'Yesterday I joined the Brooklyn Bird Club for our annual trip to Western New Jersey, specifically Hyper Humus, a relatively recently discovered hot spot. It started out as a nice winter morning when we arrived at the site at 7:30 A.M., progressed to Spring around 10:00 A.M., and reached early summer by 10:15.' ].        html article: [ html heading                 level2;                 with: [ html anchor                       url: '/blog/birding/2007/04/23/but-does-it-count-for-your-life-list/';                       with: 'But does it count for your life list?' ].              html paragraph: [ html text: 'Seems you can now go '.                    html anchor                       url: 'http://www.wired.com/science/discoveries/news/ 2007/04/cone_sf';                       with: 'bird watching via the Internet'.                    html text: '. I haven''t been able to test it out yet (20 user limit apparently) but this is certainly cool. Personally, I can''t imagine it replacing actually being out in the field by any small amount. On the other hand, I''ve always found it quite sad to meet senior birders who are no longer able to hold binoculars steady or get to the park. I can imagine this might be of some interest to them. At least one elderly birder did a big year on TV, after he could no longer get out so much. This certainly tops that.' ] ] ].  html navigation: [ html anchor           url: '/blog/page/2/';           with: '<< Previous Entries' ].  html navigation: [ html unorderedList: [ html listItem: [ html heading                       level2;                       with: 'Info'.                    html unorderedList: [ html listItem: [ html anchor                                   url: '/blog/comment-policy/';                                   with: 'Comment Policy' ].                          html listItem: [ html anchor                                   url: '/blog/todo-list/';                                   with: 'Todo List' ] ] ].              html listItem: [ html heading                       level2;                       with: 'Archives'.                    html unorderedList: [ html listItem: [ html anchor                                   url: '/blog/2007/04/';                                   with: 'April 2007' ].                          html listItem: [ html anchor                                   url: '/blog/2007/02/';                                   with: 'February 2007' ] ] ].              html listItem: [ html anchor                       url: '/blog/2007/01/';                       with: 'January 2007' ] ] ].  html aside: [ html heading level3 with: '.xf-value'.        html paragraph: [ html text: 'The '.              html code: '.xf-value'.              html text: ' selector used here styles the input field value but not its label. This is actually inconsistent with the current CSS3 draft. The example really should use the '.              html code: '::value'.              html text: 'pseudo-class instead like so:' ].        html preformatted: 'input::value { width: 20em; }#ccnumber::value { width: 18em }#zip::value { width: 12em }#state::value { width: 3em  }'.        html paragraph: 'However, Firefox doesn''t yet support this syntax' ].  html footer: [ html paragraph: 'Copyright 2007 Elliotte Rusty Harold' ]-=JUAMPI=-testNoMarkerOnCall  | captured seen |  captured := false.  seen := false.  self should: [ self callcc: [:cc |  captured := true ].        seen := true ] raise: Error.  self deny: captured.  self deny: seen-=JUAMPI=-writeLoadScriptsOn: aDocument  self loadScripts do: [:each |  aDocument stream javascript: each.        aDocument nextPut: $; ]-=JUAMPI=-mainJpg  ^#(255 216 255 224 0 16 74 70 73 70 0 1 1 1 0 72 0 72 0 0 255 225 0 22 69 120 105 102 0 0 77 77 0 42 0 0 0 8 0 0 0 0 0 0 255 219 0 67 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 255 219 0 67 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 255 192 0 17 8 0 4 2 152 3 1 34 0 2 17 1 3 17 1 255 196 0 24 0 1 0 3 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7 9 10 255 196 0 38 16 0 2 3 0 1 1 8 3 1 0 0 0 0 0 0 0 0 1 17 81 145 7 2 6 8 9 40 49 54 116 195 65 103 129 183 255 196 0 20 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 196 0 20 17 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 218 0 12 3 1 0 2 17 3 17 0 63 0 235 191 191 103 181 250 190 7 87 216 85 254 17 73 62 9 229 249 83 230 63 181 191 230 188 74 0 26 177 10 150 33 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 132 42 88 128 1 10 150 33 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 132 42 88 128 1 10 150 33 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 132 42 88 128 1 10 150 33 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 132 42 88 128 1 10 150 33 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 132 42 88 128 1 10 150 33 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 132 42 88 128 1 10 150 33 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 132 42 88 128 1 10 150 33 10 150 32 0 66 94 137 47 225 32 0 0 0 0 0 132 253 84 145 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 132 42 88 128 1 10 150 33 10 150 32 0 66 165 136 66 165 136 0 16 169 98 16 169 98 0 4 42 88 140 168 241 117 73 112 55 16 66 75 204 143 100 255 0 31 173 121 108 0 44 254 226 126 215 233 248 29 63 88 0 15 255 217) asByteArray-=JUAMPI=-type  ^'number'-=JUAMPI=-isValid  ^validationError isNil-=JUAMPI=-renderDetailsOn: html  html heading     level2;     with: '<details>'.  html details: [ html summary: '[Sibley, 2000]'.        html paragraph: 'Sibley, David Allen, The Sibley Guide to Birds, (New York: Chanticleer Press, 2000) p. 247' ]-=JUAMPI=-writeDiscardOn: aStream  (self discard notNil and: [ self discard ]) ifTrue: [ aStream nextPutAll: '; Discard' ]-=JUAMPI=-contents: aString  contents := GRPlatform current convertToSmalltalkNewlines: aString-=JUAMPI=-urlForDocument: anObject mimeType: mimeType fileName: fileName  | handler |  handler := WADocumentHandler document: anObject mimeType: mimeType fileName: fileName.  ^self requestContext session register: handler-=JUAMPI=-beHidden  self hidden: true-=JUAMPI=-renderColumnsOn: html  html div     class: 'columns';     with: [ self columns do: [:each |  html form                 class: 'column';                 with: [ | array |                    array := self model perform: (each , 'List') asSymbol.                    html div: [ html select                             size: 10;                             list: array;                             attributeAt: 'onchange' put: 'submit()';                             selected: (array at: (self model perform: (each , 'ListIndex') asSymbol) ifAbsent: [ nil ]);                             callback: [:item |  self model perform: (each , 'ListIndex:') asSymbol with: (array indexOf: item) ] ] ] ] ]-=JUAMPI=-seasideMimeType  ^self-=JUAMPI=-top: anInteger  features at: #top put: anInteger-=JUAMPI=-boolean: aSymbol  ^self addAttribute: (WABooleanAttribute key: aSymbol)-=JUAMPI=-editMemoryVMParameterAt: anInteger named: aString  self show: ((WAVMParameterEditor paramterIndex: anInteger)           addMessage: aString;           yourself)-=JUAMPI=-notFound  | response |  self makePlainTextAndPerform: #notFound.  response := self response.  self request url pathUnencodedOn: response.  response nextPutAll: ' not found'-=JUAMPI=-hash  ^(self mimeType hash bitXor: self fileName hash) bitXor: self contents hash-=JUAMPI=-expectedMimeType  ^WAMimeType textHtml-=JUAMPI=-initialize  super initialize.  self initializeFields-=JUAMPI=-tabIndex: aString  self attributes at: 'tabindex' put: aString-=JUAMPI=-toggleHelp  self showHelp: self showHelp not.  self showHelp ifTrue: [ self collapsed: false ]-=JUAMPI=-openTag: aString attributes: anAttributes closed: aBoolean  stream     nextPut: $<;     nextPutAll: aString.  anAttributes encodeOn: self.  aBoolean ifTrue: [ stream nextPut: $/ ].  stream nextPut: $>-=JUAMPI=-testCantReset  | resetPossible |  resetPossible := self response     status: WAResponse statusNotFound;     attachmentWithFileName: 'upload.csv';     nextPutAll: 'the content';     resetIfPossible.  self deny: resetPossible.  self assertLines: #('HTTP/1.1 404 Not Found' 'Content-Disposition: attachment; filename="upload.csv"' '' 'the content')-=JUAMPI=-testBlockTemps  | y |  #(1 2 3) do: [:i |  | x |        x := i.        tmp ifNil: [ tmp2 := self callcc: [:cc |  tmp := cc.                    [:q |   ] ] ].        tmp2 value: x.        x := 17 ].  y := self callcc: [:cc |  tmp value: cc.        42 ].  self assert: y = 1-=JUAMPI=-associationsDo: aBlock  delegates do: [:each |  each associationsDo: aBlock ]-=JUAMPI=-classListIndex  ^(self classesInTheSelectedPackage sorted: [:a :b |  a name <= b name ]) indexOf: selectedClass-=JUAMPI=-renderFigureOn: html  html heading     level2;     with: '<figure>'.  html figure: [ html image           url: WATestingFiles / #samplePng;           altText: 'sample'.        html figureCaption: 'A Sample Icon' ]-=JUAMPI=-hash  ^self main hash bitXor: self sub hash-=JUAMPI=-colorForDate: aDate rowIndex: aNumber  ^(self hasSelection and: [ self selectionContainsDate: aDate rowIndex: aNumber ]) ifTrue: [ 'lightgrey' ] ifFalse: [ 'white' ]-=JUAMPI=-asSpecCommand  ^super asSpecCommand     iconName: #smallInspectIt;     yourself-=JUAMPI=-testAbsoluteUrlForResourceWithoutBase  | context |  context := WARenderContext new.  context resourceUrl: nil.  self assert: (context absoluteUrlForResource: nil) isNil.  self assert: ((context absoluteUrlForResource: 'bar') isKindOf: WAUrl).  self assert: (context absoluteUrlForResource: 'bar') greaseString = '/bar'.  self assert: ((context absoluteUrlForResource: '/bar') isKindOf: WAUrl).  self assert: (context absoluteUrlForResource: '/bar') greaseString = '/bar'.  self assert: ((context absoluteUrlForResource: '') isKindOf: WAUrl).  self assert: (context absoluteUrlForResource: '') greaseString = '/'.  self assert: ((context absoluteUrlForResource: 'http://localhost/foo') isKindOf: WAUrl).  self assert: (context absoluteUrlForResource: 'http://localhost/foo') greaseString = 'http://localhost/foo'-=JUAMPI=-renderValuesOn: html  | incrementalGCs tenures parameters fullGCs fullGCTime incrementalGCTime |  parameters := SmalltalkImage current vm getParameters.  fullGCs := parameters at: 7.  fullGCTime := parameters at: 8.  incrementalGCs := parameters at: 9.  incrementalGCTime := parameters at: 10.  tenures := parameters at: 11.  self renderLabel: 'Full GCs' value: fullGCs value: (self printMilliSeconds: fullGCTime) value: (self printMilliSeconds: fullGCTime dividedBy: fullGCs) on: html.  self renderLabel: 'Incremental GCs' value: incrementalGCs value: (self printMilliSeconds: incrementalGCTime) value: (self printMilliSeconds: incrementalGCTime dividedBy: incrementalGCs) on: html.  self renderLabel: 'Tenures' value: tenures on: html.  tenures isZero ifFalse: [ self renderLabel: 'Avg. GCs/tenure' value: (incrementalGCs / tenures) greaseInteger on: html ]-=JUAMPI=-forbidden  | response |  self makePlainTextAndPerform: #forbidden.  response := self response.  response nextPutAll: 'Error: you are forbidden to access "'.  self request url pathUnencodedOn: response.  response nextPutAll: '"'-=JUAMPI=-newSession  ^self sessionClass new     configuration: (WAUserConfiguration new           addParent: self configuration;           yourself);     yourself-=JUAMPI=-accept: aVisitor  aVisitor visitPainter: self-=JUAMPI=-renderHeadingOn: html  html div     class: 'header';     with: [ html heading           level1;           class: 'welcome';           with: self title.        html heading           level2;           class: 'congrats';           with: 'Congratulations, you have a working Seaside environment.' ]-=JUAMPI=-meta  ^self add: (WAMetaElement root: self)-=JUAMPI=-unhandledExceptionClass  ^Exception-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream     nextPutAll: ' cacheDuration: ';     print: self cacheDuration.  aStream     nextPutAll: ' filepath: ';     print: self filepath.  aStream     nextPutAll: ' mimeType: ';     print: self mimeType.  aStream     nextPutAll: ' contents: ';     print: (self contents greaseString truncateWithElipsisTo: 100)-=JUAMPI=-testAtIfAbsent  one at: 'foo' put: 1.  two at: 'bar' put: 2.  self assert: (merged at: 'foo' ifAbsent: [ true ]) = 1.  self assert: (merged at: 'bar' ifAbsent: [ true ]) = 2.  two at: 'foo' put: 3.  self assert: (merged at: 'foo' ifAbsent: [ true ]) = 1.  self assert: (merged at: 'zork' ifAbsent: [ true ])-=JUAMPI=-binary  self subclassResponsibility-=JUAMPI=-renderSubItemsOn: html  super renderSubItemsOn: html.  html render: cacheEditor-=JUAMPI=-testMimeType  | library |  library := WATestingMetadataFileLibrary default.  self assert: (library mimetypeOf: #imgglyphiconshalflingsPng) = WAMimeType imagePng.  self assert: (library mimetypeOf: #jsbootstrapJs) = 'application/javascript' seasideMimeType-=JUAMPI=-handleAnswer: anObject continueWith: aBlock  (self validate: anObject) ifTrue: [ aBlock value ]-=JUAMPI=-labels: aBlock  labelBlock := aBlock-=JUAMPI=-renderRadioButtonsCustomOn: html  self renderLabel: 'Radiogroup (Custom)' input: [ html radioGroup: [:group |  self elements do: [:each |  html label: [ html radioButton                             group: group;                             selected: radioCustom = each;                             callback: [ radioCustom := each ].                          html text: each ].                    html break ] ] ] output: radioCustom printString on: html-=JUAMPI=-renderContentOn: html  html table     class: 'DateTable';     with: [ html tableRow: [ self renderMonthHeadingsOn: html ].        html tableRow: [ self renderDayHeadingsOn: html ].        rows keysAndValuesDo: [:index :each |  html tableRow: [ self renderRow: each index: index on: html ] ] ]-=JUAMPI=-rows: aCollection  self clearSelection.  super rows: aCollection-=JUAMPI=-createRequest  ^WARequest method: 'GET' uri: '/1/2'-=JUAMPI=-testMapCallback  | key |  key := registry store: (WAMapCallback on: [:v |  log add: v ]).  self shouldnt: [ self request: (WARequestFields new                 at: key put: '?1,2';                 yourself) ] raise: WARenderNotification.  self assertLog: (Array with: 1 @ 2).  self shouldnt: [ self request: (WARequestFields new                 at: key put: '?1,23';                 yourself) ] raise: WARenderNotification.  self assertLog: (Array with: 1 @ 23).  self shouldnt: [ self request: (WARequestFields new                 at: key put: '?12,34';                 yourself) ] raise: WARenderNotification.  self assertLog: (Array with: 12 @ 34).  self shouldnt: [ self request: (WARequestFields new                 at: key put: nil;                 yourself) ] raise: WARenderNotification.  self assertLog: #().  self shouldnt: [ self request: (WARequestFields new                 at: key put: '';                 yourself) ] raise: WARenderNotification.  self assertLog: #().  self shouldnt: [ self request: (WARequestFields new                 at: key put: '1,2';                 yourself) ] raise: WARenderNotification.  self assertLog: #().  self shouldnt: [ self request: (WARequestFields new                 at: key put: '?1';                 yourself) ] raise: WARenderNotification.  self assertLog: #().  self shouldnt: [ self request: (WARequestFields new                 at: key put: '?1,';                 yourself) ] raise: WARenderNotification.  self shouldnt: [ self request: (WARequestFields new                 at: key put: '?1x2';                 yourself) ] raise: WARenderNotification.  self assertLog: #().  self shouldnt: [ self request: (WARequestFields new                 at: key put: '?a,b';                 yourself) ] raise: WARenderNotification.  self assertLog: #()-=JUAMPI=-ensure  [ self go ] ensure: [ self inform: 'ensure' ]-=JUAMPI=-limit  ^limit ifNil: [ limit := self defaultLimit min: self frameCount ]-=JUAMPI=-testAsFileAndFoldername  | library |  library := WATestingMetadataFileLibrary default.  self assert: (library asFileAndFoldername: #mainCss) first equals: library name-=JUAMPI=-showHelp  self model plusButtonHit-=JUAMPI=-exceptionClass  ^exceptionClass ifNil: [ exceptionClass := WAValidationNotification ]-=JUAMPI=-renderMonthHeadingOn: html  html form: [ html div: [ html select                 list: (1 to: 12);                 on: #monthIndex of: self;                 labels: [:index |  Date nameOfMonth: index ].              html textInput                 maxLength: 4;                 on: #year of: self.              html submitButton text: 'Refresh' ] ]-=JUAMPI=-date: aDate  day := aDate dayOfMonth.  month := aDate monthIndex.  year := aDate year-=JUAMPI=-initialize  super initialize.  properties := Dictionary new.  self hasAdvancedAttributes: self hasAdvancedAttributesDefault.  self displayAdvancedAttributes: false.  self collapsed: self collapsedByDefault.  self showHelp: false-=JUAMPI=-value  ^value-=JUAMPI=-evaluate  ^self object class compilerClass new evaluate: input in: thisContext to: self object-=JUAMPI=-stop: aServerAdaptor  (self canStop: aServerAdaptor) ifTrue: [ aServerAdaptor basicStop ]-=JUAMPI=-onRender: aBlock  renderBlock := aBlock-=JUAMPI=-columns: anArray  columns := anArray-=JUAMPI=-percent: aDecimal  ^GRSequentialPrinter new , (GRNumberPrinter new           separator: $.;           precision: 2;           accuracy: 0.1;           yourself) , ' %' print: aDecimal * 100-=JUAMPI=-sessionIdFromContext: aRequestContext  ^aRequestContext request forwardedFor ifNil: [ aRequestContext request remoteAddress ]-=JUAMPI=-updateStates: aSnapshot  super updateStates: aSnapshot.  decoration isNil ifFalse: [ aSnapshot register: decoration ]-=JUAMPI=-nextPutAllFast: aByteString  | lastIndex nextIndex |  lastIndex := 1.  nextIndex := ByteString findFirstInString: aByteString inSet: table startingAt: lastIndex.  nextIndex = 0 ifTrue: [ ^stream nextPutAll: aByteString ].  [ nextIndex > lastIndex ifTrue: [ stream greaseNext: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex ].  delegate nextPut: (aByteString at: nextIndex).  lastIndex := nextIndex + 1.  nextIndex := ByteString findFirstInString: aByteString inSet: table startingAt: lastIndex.  nextIndex = 0 ] whileFalse.  stream greaseNext: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex-=JUAMPI=-isModify  ^self expression notNil and: [ self isOverride not ]-=JUAMPI=-minutes: anIntegerOrString  minutes := anIntegerOrString greaseInteger ifNil: [ 0 ]-=JUAMPI=-document: anObject mimeType: aMimeString  self document: anObject mimeType: aMimeString fileName: nil-=JUAMPI=-openBrush  super openBrush.  key jsonOn: canvas.  self document stream nextPutAll: ': '-=JUAMPI=-starting  status := #starting-=JUAMPI=-renderContentOn: html  self renderHeadingOn: html.  self renderDispatcherOn: html-=JUAMPI=-accept: aVisitor  aVisitor visitPasswordAttribute: self-=JUAMPI=-size  ^self rawContents size-=JUAMPI=-parseNumberInteger  | number |  number := 0.  [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next greaseInteger - 48) ].  ^number-=JUAMPI=-testStore  | generator |  generator := WAPrecomputedKeyGenerator keys: #(1 1 1 2 2 2 3).  WAKeyGenerator use: generator during: [ self assert: (cache store: 'key1') = 1.        self assert: (cache store: 'key2') = 2.        self assert: (cache store: 'key3') = 3 ]-=JUAMPI=-respond  WAResponseNotification signal-=JUAMPI=-remove: anObject  self subclassResponsibility-=JUAMPI=-port  ^port-=JUAMPI=-renderFormOn: html  groups do: [:each |  html render: each ]-=JUAMPI=-logger  ^(JSLogger context: self context)     rendererClass: self species;     yourself-=JUAMPI=-processes  ^(Process allSubInstances reject: [:each |  each isTerminated or: [ each = Processor activeProcess ] ]) sorted: [:a :b |  a priority >= b priority ]-=JUAMPI=-selection  ^selection-=JUAMPI=-charset: aString  self attributes at: 'charset' put: aString-=JUAMPI=-tag  ^'script'-=JUAMPI=-value: anInteger  self attributeAt: 'value' put: anInteger-=JUAMPI=-destroy  super destroy.  bufferedStream := nil.  externalStream := nil-=JUAMPI=-renderEntityTableFootOn: html  html tableFoot: [ html tableRow: [ html tableData                 align: 'center';                 colSpan: 7;                 with: '5 entities shown' ] ]-=JUAMPI=-callback: aBlock  self name: (self storeCallback: (WAValueCallback on: aBlock)).  self value: self value-=JUAMPI=-postCopyForRenderContext: aRenderContext  super postCopyForRenderContext: aRenderContext.  renderContext := aRenderContext-=JUAMPI=-renderPartsOn: html  self renderHaltOn: html.  self renderErrorOn: html.  self renderPostErrorOn: html.  self renderRenderErrorOn: html.  self renderResumableErrorOn: html.  self renderWarningOn: html.  self renderDeprecatedOn: html-=JUAMPI=-defaultConfiguration  self subclassResponsibility-=JUAMPI=-second: anObject  second := anObject-=JUAMPI=-renderContentOn: html  html render: self delegate-=JUAMPI=-testCanResetIfNoBody  | resetPossible |  resetPossible := self response     status: WAResponse statusNotFound;     attachmentWithFileName: 'upload.csv';     resetIfPossible.  self assert: resetPossible.  self assertLines: #('HTTP/1.1 200 OK' 'Content-Length: 0' '')-=JUAMPI=-hasTotal: aBoolean  hasTotal := aBoolean-=JUAMPI=-describeOn: config  (config string: #login)     group: #authentication;     comment: 'The username for this application.'.  (config password: #passwordHash)     group: #authentication;     comment: 'The password for this application.';     label: 'Password'-=JUAMPI=-renderPhaseContinuationClasses  ^self continuationClasses select: [:each |  each isRenderLoopContinuation and: [ each isRenderContinuation ] ]-=JUAMPI=-assert: aBlock gives: aString  | stream |  aBlock value: (attributes := WAHtmlAttributes new).  (WAHtmlDocument on: (stream := WriteStream on: String new) codec: self requestContext codec) print: attributes.  self assert: stream contents = aString description: 'Expected ' , aString printString , ', but got ' , stream contents printString resumable: true-=JUAMPI=-renderValuesOn: html  self processes do: [:each |  self renderProcess: each on: html ]-=JUAMPI=-at: aKey append: aValue separator: aSeparator  aValue isNil ifFalse: [ | current |        current := self at: aKey ifAbsentPut: [ aValue ].        current ~~ aValue ifTrue: [ current isConcatenatedHtmlAttributeValue ifTrue: [ current addValue: aValue ] ifFalse: [ self at: aKey put: (WAConcatenatedHtmlAttributeValue separator: aSeparator value: current value: aValue) ] ] ]-=JUAMPI=-text: anObject  self flush.  super text: anObject-=JUAMPI=-selection  ^selection contents-=JUAMPI=-handlerClass  ^WAHtmlFileHandlerListing-=JUAMPI=-search: anObject  search := anObject-=JUAMPI=-isAttributeInheritedOn: aConfiguration  ^attributeInheritors includes: aConfiguration-=JUAMPI=-addTo: anEmailAddress  ^self to add: anEmailAddress-=JUAMPI=-optimum: anInteger  self attributeAt: 'optimum' put: anInteger-=JUAMPI=-ruby: aBlock  self ruby with: aBlock-=JUAMPI=-filter: aFilter  filter := aFilter-=JUAMPI=-tag  ^'time'-=JUAMPI=-writeSameSiteOn: aStream  sameSite isNil ifTrue: [ ^self ].  aStream     nextPutAll: '; SameSite=';     nextPutAll: sameSite-=JUAMPI=-writeVersionOn: aStream  aStream nextPutAll: '; Version='.  aStream print: self version-=JUAMPI=-setEmptyPage  editor := WADispatcherEmptyPage on: self-=JUAMPI=-handleExceptionsDuring: aBlock  ^aBlock on: self do: [:exception |  [ self handleException: exception ] on: Error do: [:error |  self internalError: error ] ]-=JUAMPI=-children  ^Array with: self component-=JUAMPI=-testLinkElementWithContent  self assertRoot: [:html |  html stylesheet add: 'div > em { color: blue; }' ] gives: '<title></title><style type="text/css">div > em { color: blue; }</style>'.  self assertRoot: [:html |  html stylesheet add: 'E[foo$="bar"]' ] gives: '<title></title><style type="text/css">E[foo$="bar"]</style>'-=JUAMPI=-renderHeaderOn: html  html heading     level2;     with: '<header>'.  html header: [ html paragraph: 'Welcome to...'.        html heading           level1;           with: 'Voidwars!' ]-=JUAMPI=-renderExplanationOn: html  html paragraph: [ html text: 'This test serves three purposes:'.        html orderedList: [ html listItem: 'First it is a regression test, earlier versions of Seaside could only handle a limited number of callbacks per page. The oldest links (low numbers) would use their callback. Clicking on any link should display this number with a button.'.              html listItem: 'Second it serves as a raw rendering speed benchmark.'.              html listItem: 'Third it tests WASession >> #jumpToAnchor:. After confirming the number you should return to the page and be automatically at the place where the link is.' ] ]-=JUAMPI=-childrenBlock: aBlock  childrenBlock := aBlock-=JUAMPI=-testCompileByteArrayWithCacheSource  | library data file source expected |  self useCompileUseNewCompiler: false during: [ self deny: GRPharoPlatform current useByteArrayLiterals.        library := WATestingFiles default.        data := (1 to: 255) asByteArray.        file := WAFile new           contentType: WAMimeType imageJpeg;           contents: data;           fileName: 'demo.jpeg';           yourself.        library addFile: file.        [ source := WATestingFiles sourceCodeAt: #demoJpeg.        expected := 'demoJpeg	^ #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255) asByteArray'.        self assert: source greaseString = expected ] ensure: [ library removeFile: file fileName ] ]-=JUAMPI=-addField: aKey value: aValue  aKey isEmpty ifFalse: [ self queryFields at: aKey add: aValue ]-=JUAMPI=-parse  | result |  result := self     whitespace;     parseValue.  self whitespace.  stream atEnd ifFalse: [ self error: 'end of input expected' ].  ^result-=JUAMPI=-months  ^1 to: 12-=JUAMPI=-accept: aVisitor  aVisitor visitComponent: self-=JUAMPI=-bePrevious  self relationship: 'previous'-=JUAMPI=-registerPassenger: anObject named: aString  | callback |  callback := JSPassenger new.  callback     setKey: aString callbacks: callbacks;     setObject: anObject.  callbacks at: (callback convertKey: aString) put: callback.  ^aString-=JUAMPI=-contents  ^contents-=JUAMPI=-level4  level := 4-=JUAMPI=-register: aServerAdaptor  ^adaptors add: aServerAdaptor-=JUAMPI=-postCopy  super postCopy.  document := document copy-=JUAMPI=-minutes  ^minutes-=JUAMPI=-sampleForm  ^(Smalltalk classNamed: #Form) extent: 16 @ 16 depth: 1 fromArray: #(0 0 0 50331648 25165824 12582912 281018368 415236096 264241152 132120576 7340032 3670016 1572864 0 0 0) offset: 0 @ 0-=JUAMPI=-testDictionary  | original snapshot1 snapshot2 snapshot3 snapshot4 |  original := Dictionary new.  original     at: 1 put: #a;     at: 2 put: #b.  snapshot1 := original snapshotCopy.  original at: 3 put: #c.  snapshot2 := original snapshotCopy.  original at: 3 put: #d.  snapshot3 := original snapshotCopy.  original removeKey: 1.  snapshot4 := original snapshotCopy.  original restoreFromSnapshot: snapshot1.  self assert: original size equals: 2.  self assert: (original at: 1 ifAbsent: [  ]) equals: #a.  self assert: (original at: 2 ifAbsent: [  ]) equals: #b.  self assert: (original at: 3 ifAbsent: [  ]) isNil.  self assert: (original at: 4 ifAbsent: [  ]) isNil.  original restoreFromSnapshot: snapshot2.  self assert: (original at: 1 ifAbsent: [  ]) equals: #a.  self assert: (original at: 2 ifAbsent: [  ]) equals: #b.  self assert: (original at: 3 ifAbsent: [  ]) equals: #c.  self assert: (original at: 4 ifAbsent: [  ]) isNil.  original restoreFromSnapshot: snapshot3.  self assert: (original at: 1 ifAbsent: [  ]) equals: #a.  self assert: (original at: 2 ifAbsent: [  ]) equals: #b.  self assert: (original at: 3 ifAbsent: [  ]) equals: #d.  self assert: (original at: 4 ifAbsent: [  ]) isNil.  original restoreFromSnapshot: snapshot4.  self assert: (original at: 1 ifAbsent: [  ]) isNil.  self assert: (original at: 2 ifAbsent: [  ]) equals: #b.  self assert: (original at: 3 ifAbsent: [  ]) equals: #d.  self assert: (original at: 4 ifAbsent: [  ]) isNil.  original at: 2 put: #!.  original restoreFromSnapshot: snapshot4.  self assert: (original at: 1 ifAbsent: [  ]) isNil.  self assert: (original at: 2 ifAbsent: [  ]) equals: #b.  self assert: (original at: 3 ifAbsent: [  ]) equals: #d.  self assert: (original at: 4 ifAbsent: [  ]) isNil-=JUAMPI=-renderResumeOn: html  html form: [ html text: 'UI Process is suspended. '.        html submitButton           callback: [ self resume ];           text: 'Resume' ]-=JUAMPI=-testNextKey  self assert: registry nextKey = '1'.  registry increaseKey.  self assert: registry nextKey = '2'.  self assert: registry nextKey = '2'-=JUAMPI=-initialize  super initialize.  self label: ''-=JUAMPI=-contentType  | contentType |  contentType := self headerAt: 'content-type'.  ^contentType isNil ifFalse: [ WAMimeType fromString: contentType ]-=JUAMPI=-initialize  super initialize.  configuration := self defaultConfiguration.  filter := WAValueHolder with: self-=JUAMPI=-testStringWithFilename  self createAndVerifyTextDocumentNamed: 'toolbar.css' hasAttachment: 'attachment; filename="toolbar.css"'-=JUAMPI=-onMouseUp: anObject  self document scriptGenerator event: 'mouseup' do: anObject on: self-=JUAMPI=-renderMouseClickOn: html  html div: [ html map           title: 'Click here';           callback: [:point |  self click: point + self offset ];           with: [ html image form: self form ] ]-=JUAMPI=-renderYearNavigationOn: html  html span     class: 'calendarPrevious';     with: [ html anchor           callback: [ self year: self year - 1 ];           with: self year - 1 ].  html space.  html span     class: 'calendarNext';     with: [ html anchor           callback: [ self year: self year + 1 ];           with: self year + 1 ]-=JUAMPI=-datesDo: aBlock separatedBy: monthlyBlock  | month |  month := datesCache first monthIndex.  datesCache do: [:date |  date monthIndex = month ifFalse: [ month := date monthIndex.              monthlyBlock value ].        aBlock value: date ].  monthlyBlock value-=JUAMPI=-priority  ^400-=JUAMPI=-execute  self adaptor ifNotNil: [:adaptor |  adaptor isRunning ifFalse: [ ^self ].        WebBrowser openOn: 'http://localhost:' , adaptor port asString ]-=JUAMPI=-initialize  super initialize.  semaphore := GRPlatform current semaphoreClass forMutualExclusion.  owner := GRPlatform current newTransientValueHolder-=JUAMPI=-updateRoot: anHtmlRoot  super updateRoot: anHtmlRoot.  WAToolFiles default updateRoot: anHtmlRoot.  WADevelopmentFiles default updateRoot: anHtmlRoot-=JUAMPI=-testHandleListing  | response |  self requestContextWithUrl: '/root/files/WATestingFiles/'.  requestContext consumer     next;     next.  response := self responseAfter: [ handler handle: self requestContext ].  self assertListing: response.  self requestContextWithUrl: '/root/files/WATestingFiles'.  requestContext consumer     next;     next.  response := self responseAfter: [ handler handle: self requestContext ].  self assertListing: response.  self requestContextWithUrl: '/root/files/'.  requestContext consumer     next;     next.  response := self responseAfter: [ handler handle: self requestContext ].  self assertListing: response.  self requestContextWithUrl: '/root/files'.  requestContext consumer     next;     next.  response := self responseAfter: [ handler handle: self requestContext ].  self assertListing: response-=JUAMPI=-renderContentOn: html  html paragraph: [ html text: 'You can see your component in action here: '.        html anchor           target: '_blank';           url: '/' , self componentName;           with: '/' , self componentName ].  html paragraph: [ html           text: 'Now go find the class ';           code: self componentName;           text: ' in your Smalltalk image. First, try changing the displayed text by changing the ';           code: '#renderContentOn:';           text: ' method. Then you can experiment further based on what you''ve seen in the examples and what you read in the '.        html anchor           url: 'http://book.seaside.st/';           with: 'documentation.' ].  html paragraph: [ html text: 'Want to '.        html anchor           callback: [ self answer ];           with: 'create another component'.        html text: '?' ]-=JUAMPI=-collapsed: aBoolean  ^self propertyAt: #collapsed put: aBoolean-=JUAMPI=-attributeAt: aString put: anObject  ^self attributes at: aString put: anObject-=JUAMPI=-renderKeyGeneratorOn: html  html form: [ html keyGenerator callback: [:k |  key := k ].        html submitButton ]-=JUAMPI=-name  ^self class name greaseString-=JUAMPI=-testCopy  | copy absent |  cache at: 1 put: '1'.  cache at: 2 put: '2'.  copy := cache copy.  copy at: 1 put: '1a'.  copy at: 3 put: '3'.  self assert: (cache at: 1 ifAbsent: [ self assert: false ]) = '1'.  self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.  absent := false.  cache at: 3 ifAbsent: [ absent := true ].  self assert: absent.  self assert: (copy at: 1 ifAbsent: [ self assert: false ]) = '1a'.  self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.  self assert: (copy at: 3 ifAbsent: [ self assert: false ]) = '3'-=JUAMPI=-headers  ^headers-=JUAMPI=-testHeadersAtPut  self assert: (self response headerAt: 'foo' put: 'bar') = 'bar'.  self assert: (self response headerAt: 'foo') = 'bar'.  self assert: (self response headerAt: 'foo' put: 'zork') = 'zork'.  self assert: (self response headerAt: 'foo') = 'zork'.  self assert: self response headers size = 1-=JUAMPI=-testAddToPathWithLeadingSlash  url addToPath: '/files/WAStandardFiles/seaside.jpg'.  self assert: url path size = 3.  self assert: url path first = 'files'.  self assert: url path second = 'WAStandardFiles'.  self assert: url path third = 'seaside.jpg'.  self assert: url greaseString = '/files/WAStandardFiles/seaside.jpg'-=JUAMPI=-priority  ^900-=JUAMPI=-renderExplanationOn: html  html paragraph: 'This tests whether the sever adapter correctly passes the tailing slash of the request URL to the request context.'.  html paragraph: 'Click each of the links below, and the status should change from "not run" to "success".'-=JUAMPI=-childrenDo: aBlock  self cache keysAndValuesDo: [:key :value |  aBlock value: value ]-=JUAMPI=-isHtml  ^false-=JUAMPI=-callback: aNiladicValuable  aNiladicValuable argumentCount > 0 ifTrue: [ GRInvalidArgumentCount signal: 'Buttons expect a niladic callback.' ].  self name: (self storeCallback: (WAActionCallback on: aNiladicValuable))-=JUAMPI=-testHandler  | filter1 filter2 |  filter1 := handler addFilter: WARequestFilter new.  filter2 := handler addFilter: WARequestFilter new.  self assert: handler handler = handler.  self assert: filter1 handler = handler.  self assert: filter2 handler = handler-=JUAMPI=-onCut: anObject  self document scriptGenerator event: 'cut' do: anObject on: self-=JUAMPI=-title  ^'Task'-=JUAMPI=-renderChooseCheeseCodeOn: html  html preformatted     class: #codeSample;     with: [ html span           class: #patternUnary;           with: 'chooseCheese'.        html break.        html span           class: #instanceVar;           with: '    cheese'.        html text: ' := '.        html span           class: #self;           with: 'self'.        html break.        html text: '        chooseFrom: '.        html span           class: #symbol;           with: '#'.        html text: '( '.        html span           class: #string;           with: '''Greyerzer'' ''Tilsiter'' ''Sbrinz'''.        html text: ' )'.        html break.        html text: '        caption: '.        html span           class: #string;           with: '''What''''s your favorite cheese?'''.        html text: '.'.        html break.        html span           class: #instanceVar;           with: '    cheese'.        html text: ' isNil ifTrue: [ '.        html span           class: #self;           with: 'self'.        html text: ' chooseCheese ]' ]-=JUAMPI=-endDateSelection  ^dateSelectionStart isNil ifFalse: [ dateSelectionStart max: dateSelectionEnd ]-=JUAMPI=-renderContentOn: html  html anchor     class: self cssClass;     url: (html actionUrl withField: 'terminate');     with: self label-=JUAMPI=-raiseWarning  self notify: 'Test Warning'.  self inform: 'To be displayed' onAnswer: [  ]-=JUAMPI=-includes: anObject  ^byValue includesKey: anObject-=JUAMPI=-form: aForm  self extent: aForm extent.  self document: aForm-=JUAMPI=-user  | authorization |  ^(authorization := self authorization) isNil ifFalse: [ authorization copyUpTo: $: ]-=JUAMPI=-initializeWithException: anException  self initialize.  exception := anException-=JUAMPI=-cssClass  ^'wa-action'-=JUAMPI=-defaultAction: aBlock  defaultAction := aBlock-=JUAMPI=-valueFromString: aString  ^aString isEmptyOrNil ifFalse: [ WAUrl absolute: aString ]-=JUAMPI=-marked  ^self tag: 'mark'-=JUAMPI=-renderCookiesRequiredStatementOn: html  html text: 'Sorry, but this application requires cookies to be enabled'-=JUAMPI=-acceptDecorated: aVisitor  aVisitor visitDecorationsOfComponent: self-=JUAMPI=-showTask  selection contents notNil ifTrue: [ self show: selection contents new ]-=JUAMPI=-testByteArrayWithoutFilename  self createAndVerifyBinaryDocumentNamed: nil hasAttachment: nil-=JUAMPI=-chooseObject: anObject named: aString  path pushSegment: anObject name: aString.  selected := nil-=JUAMPI=-ie  self addToCondition: ' IE'-=JUAMPI=-input: aString  input := aString-=JUAMPI=-httpVersion  ^'HTTP/1.1'-=JUAMPI=-initialize  super initialize.  self input: 'a text'-=JUAMPI=-bePopup  self type: 'popup'-=JUAMPI=-document: aString fileName: fileName  self document: aString mimeType: self typeOrNil fileName: fileName-=JUAMPI=-expectedLibrariesContents  ^handler libraries first name-=JUAMPI=-sample  ^self tag: 'samp'-=JUAMPI=-source: aBlock  self source with: aBlock-=JUAMPI=-renderExplanationOn: html  html paragraph: 'The purpose of this test is to make sure WAContext and WACurrentContext work correctly. For each label you should see the print string of one or several matching objects. For the ''Request Handlers'' the first object should be a WASession or subclass, the second a WAApplication and then one or several WADispatchers matching the path.'-=JUAMPI=-logon  user isEmptyOrNil ifTrue: [ self inform: 'Nope !' onAnswer: [  ] ] ifFalse: [ state := #ON.        test ifTrue: [ self inform: 'Logged on' onAnswer: [  ] ] ]-=JUAMPI=-initialize  super initialize.  handlers := WABidirectionalCache new-=JUAMPI=-onKeyPress: anObject  self document scriptGenerator event: 'keypress' do: anObject on: self-=JUAMPI=-type  ^'text'-=JUAMPI=-renderBreakOn: canvas  self renderInline: [:html |  html break ] factor: 1 / 50 key: #seasideBR on: canvas-=JUAMPI=-stream  self subclassResponsibility-=JUAMPI=-handler  ^handler-=JUAMPI=-parents  ^#()-=JUAMPI=-valueFor: anObject  ^self valuesAt: self nextKey put: anObject-=JUAMPI=-configuration  ^configuration-=JUAMPI=-testAsMIMEDocumentByteArray  | document content |  document := WABlockMimeDocument onBlock: [ #(1 2 3 4) asByteArray ].  self assert: document contentType = WAMimeType applicationOctetStream.  content := document content.  self assert: content size = 4.  self assert: content class = ByteArray.  1 to: 4 do: [:index |  self assert: (content at: index) = index ]-=JUAMPI=-render: anObject  self flush.  super render: anObject-=JUAMPI=-at: aSymbol putClass: aClass  ^self at: aSymbol put: (GRPlatform current bindingOf: aClass)-=JUAMPI=-show: aComponent  self show: aComponent onAnswer: [:value |   ]-=JUAMPI=-testNoMarkerOnValue  | kk captured seen |  captured := false.  seen := false.  self shouldnt: [ self markDiscardingResultOf: [ | value |              value := self callcc: [:cc |  kk := cc.                    captured := true ].              seen := true.              value ] ] raise: Error.  self assert: captured.  self assert: seen.  captured := false.  seen := false.  self assert: (kk value: 123) = 123.  self deny: captured.  self assert: seen-=JUAMPI=-handleDefault: aRequestContext  self handle: aRequestContext registering: self newSession-=JUAMPI=-numArgs  self subclassResponsibility-=JUAMPI=-toggleUIProcess  | uiProcess |  uiProcess := self uiProcess.  uiProcess isSuspended ifTrue: [ uiProcess resume ] ifFalse: [ uiProcess suspend ]-=JUAMPI=-selected: aClass  current contents: aClass new.  (current contents respondsTo: #parent:) ifTrue: [ current contents parent: self ]-=JUAMPI=-children  ^Array with: self componentCreator-=JUAMPI=-testAtPut  1 to: 100 do: [:i |  | absent mapped |        absent := false.        cache at: i ifAbsent: [ absent := true ].        self assert: absent.        mapped := cache at: i put: i greaseString.        self assert: mapped = i greaseString.        mapped := cache at: i ifAbsent: [ self assert: false ].        self assert: mapped = i greaseString ]-=JUAMPI=-beUp  self relationship: 'up'-=JUAMPI=-renderExplanationOn: html  html paragraph: [ html text: 'This is a functional test for WATree.'.        html orderedList: [ html listItem: 'Clicking on ''+'' should expand a node'.              html listItem: 'Clicking on ''-'' should collapse a node'.              html listItem: 'Clicking on a node should display its name after ''Selected:'''.              html listItem: 'Leaf nodes should not be clickable' ] ]-=JUAMPI=-buildTable  ^WATableReport new     rows: instances values;     columns: (Array with: (WAReportColumn new                 title: 'Class';                 selector: #name;                 sortBlock: [:a :b |  a < b ];                 yourself) with: (WAReportColumn new                 title: 'Instances';                 selector: #count;                 sortBlock: [:a :b |  a > b ];                 cssClass: 'right';                 hasTotal: true;                 yourself) with: (WAReportColumn new                 title: 'Total Size';                 selector: #size;                 sortBlock: [:a :b |  a > b ];                 formatBlock: [:each |  formatter print: each ];                 cssClass: 'right';                 hasTotal: true;                 yourself));     yourself-=JUAMPI=-describeOn: config  (config list: #fileHandlerListingClass)     beAdvanced;     options: [ self listingClasses ];     default: WAForbiddenFileHandlerListing.  (config url: #resourceBaseUrl)     group: #server;     comment: 'Sets the base URL for generated URLs.'.  (config boolean: #useXSendfile)     beAdvanced;     group: #server;     comment: 'Sets whether to use the X-Sendfile header to stream file library contents.';     default: false.  (config string: #xSendfileBaseDirectory)     beAdvanced;     group: #server;     comment: 'The directory in which the deployed file libraries are.'-=JUAMPI=-initializeWithSeparator: aSeparator value: anFirstObject value: aSecondObject  self initialize.  separator := aSeparator.  values := OrderedCollection new: 4.  values add: anFirstObject.  values add: aSecondObject-=JUAMPI=-value  ^value-=JUAMPI=-clearAttribute: anAttribute  self configuration removeExpressionAt: anAttribute key-=JUAMPI=-form  ^zoom ifFalse: [ Display copy ] ifTrue: [ self topWindow imageForm ]-=JUAMPI=-initialize  super initialize.  count := 1-=JUAMPI=-handler: anObject  handler := anObject-=JUAMPI=-source: html visitor: aPainterVisitor  | context |  html div     class: 'wa-halo-source';     with: [ context := html context copy.        context disableHalos.        context document: (WAPrettyPrintedDocument context: html context).        (WARenderVisitor context: context) start: self root.        context document close ]-=JUAMPI=-renderActionsOn: html  html paragraph: [ html anchor           callback: [ self authentication ];           with: 'Basic Authentication'.        html text: ' (admin/seaside)'.        html break.        html anchor           callback: [ self protectorByRemoteAddress ];           with: 'Session Protector by remote address'.        html break.        html anchor           callback: [ self protectorByBrowserSessionCookie ];           with: 'Session Protector by session cookie' ].  html horizontalRule.  html paragraph: self children-=JUAMPI=-multiplier  ^multiplier-=JUAMPI=-initializeWithClient: aPainterVisitor  self initialize.  client := aPainterVisitor-=JUAMPI=-input: aString  input := aString-=JUAMPI=-removeDelegation  self delegations notEmpty ifTrue: [ self removeDecoration: self delegations first ]-=JUAMPI=-at: aSymbol addAll: additions removeAll: removals  ^self storeExpression: ((WAAddRemoveExpression key: aSymbol)           additions: additions;           removals: removals;           yourself) forAttribute: (self attributeAt: aSymbol)-=JUAMPI=-children  ^Array with: batcher-=JUAMPI=-onLoadedData: anObject  self document scriptGenerator event: 'loadeddata' do: anObject on: self-=JUAMPI=-register: anObject  anObject isNil ifFalse: [ objects at: anObject put: anObject snapshotCopy ]-=JUAMPI=-demoJpegContent  ^#(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255) asByteArray-=JUAMPI=-addKey: aString toContext: aRequestContext  self subclassResponsibility-=JUAMPI=-renderContentOn: html  | last selected |  last := nil.  html div     class: 'trail';     with: [ root visiblePresentersDo: [:each |  (each isDecoration and: [ each isDelegation ]) ifTrue: [ (each decoratedComponent respondsTo: #trailName) ifTrue: [ last := each.                          html anchor                             callback: [ each remove ];                             with: (each decoratedComponent perform: #trailName).                          html span                             class: 'separator';                             with: self separator ] ] ].        selected := last isNil ifTrue: [ root ] ifFalse: [ last delegate ].        (selected respondsTo: #trailName) ifTrue: [ html text: (selected perform: #trailName) ] ]-=JUAMPI=-testRfc1  | accept |  accept := WAAccept fromString: 'audio/*; q=0.2, audio/basic'.  self assert: accept size = 2.  self assert: accept at: 1 main: 'audio' sub: '*' quality: 0.2.  self assert: accept at: 2 main: 'audio' sub: 'basic' quality: 1.0-=JUAMPI=-openingConditionClass  ^WAOpeningConditionalComment-=JUAMPI=-testAddKeyToUrl  | context uri |  context := self requestContext.  uri := context request uri copy.  strategy addKey: 'The_Metaphor' toUrl: uri.  self assert: uri greaseString = '/catspajamassc2?_s=The_Metaphor'-=JUAMPI=-configurationComponent  ^WAHandlerEditor on: self-=JUAMPI=-codetype: aString  self attributes at: 'codetype' put: aString-=JUAMPI=-withLineBreaksAndUrls: aString  | stream |  aString ifNil: [ ^self ].  stream := aString readStream.  [ stream atEnd ] whileFalse: [ self withUrls: stream nextLine.        stream atEnd ifFalse: [ self break ] ]-=JUAMPI=-with: aString  self attributes at: 'type' ifAbsentPut: [ 'text/javascript' ].  super with: [ aString isNil ifFalse: [ self document nextPutAll: aString greaseString ] ]-=JUAMPI=-addParent: aConfiguration  (self parents includes: aConfiguration) ifTrue: [ ^aConfiguration ].  (self canAddParent: aConfiguration) ifTrue: [ self clearSearchContexts.        parents add: aConfiguration ] ifFalse: [ WAConfigurationError signal: 'Cannot add this configuration as a parent. Would this cause a circular ancestry graph?' ].  ^aConfiguration-=JUAMPI=-label  ^self brush: WALabelTag new-=JUAMPI=-initializeOn: aDispatcher  self initialize.  dispatcher := aDispatcher-=JUAMPI=-openBrush  self document openArray-=JUAMPI=-initialize  super initialize.  self     name: 'Remove adaptor';     description: 'Remove the currently selected seaside adaptor'-=JUAMPI=-isResumable  ^false-=JUAMPI=-responseForLibraries  context respond: [:response |  response contentType: WAMimeType textPlain.        handler libraries do: [:each |  response stream                 nextPutAll: each name;                 crlf ] ]-=JUAMPI=-renderConfigurationOn: html  | selectedLib |  selectedLib := WAValueHolder new.  html form: [ html table: [ html tableRow: [ html tableData: [ html select                             list: self libraries;                             callback: [:value |  selectedLib contents: value ];                             size: 10 ].                    html tableData: [ html anchor                             title: 'Configure selected file library';                             class: 'large';                             onClick: 'return submitForm(this)';                             callback: [ selectedLib contents isNil ifFalse: [ self configureLibrary: selectedLib contents default ] ];                             with: 'Configure' ] ] ] ]-=JUAMPI=-value: anObject with: aListTag  self selected: (aListTag isSelected: anObject).  self value: (aListTag valueFor: anObject)-=JUAMPI=-table: aBlock  self table with: aBlock-=JUAMPI=-testEquals  | first second |  first := WAMimeType fromString: 'text/html'.  second := WAMimeType fromString: 'text/html'.  self assert: first = second.  self assert: first hash = second hash.  second charset: 'utf-8'.  self assert: first = second.  self assert: first hash = second hash.  first charset: 'iso-8859-1'.  self assert: first = second.  self assert: first hash = second hash.  second := WAMimeType fromString: 'text/xml'.  self deny: first = second-=JUAMPI=-isOptional  ^isOptional-=JUAMPI=-radioButton: aBlock  ^self radioButton with: aBlock-=JUAMPI=-respond  WAResponseNotification signal-=JUAMPI=-scrollbars: aBoolean  features at: #scrollbars put: aBoolean-=JUAMPI=-table  ^table ifNil: [ table := self buildTable ]-=JUAMPI=-type: aMimeType  self attributeAt: 'type' put: aMimeType-=JUAMPI=-basicUrl  ^self isRoot ifTrue: [ WAUrl new ] ifFalse: [ self parent urlFor: self ]-=JUAMPI=-definition  ^self tag: 'dfn'-=JUAMPI=-createCodec  ^GRNullCodec new-=JUAMPI=-editorClass  ^cache editorClass-=JUAMPI=-menu: aBlock  self menu with: aBlock-=JUAMPI=-testIsNotFromCrawler  | context |  context := self requestContext.  self browserUserAgents do: [:each |  context request headers at: 'user-agent' put: each.        self deny: (strategy isFromCrawler: context) ]-=JUAMPI=-testRemoveRelativeOldest  | tenMissing |  cache := WAHashCache initialSize: 13 maximumSize: 10 maximumAbsoluteAge: 0 maximumRelativeAge: 0 overflowAction: WAHashCache removeRelativeOldest.  1 to: 10 do: [:i |  cache at: i put: i greaseString ].  1 to: 9 do: [:i |  cache at: i ifAbsent: [ self assert: false ] ].  cache at: 11 put: '11'.  1 to: 9 do: [:i |  self assert: (cache at: i ifAbsent: [ self assert: false ]) = i greaseString ].  self assert: (cache at: 11 ifAbsent: [ self assert: false ]) = '11'.  tenMissing := false.  cache at: 10 ifAbsent: [ tenMissing := true ].  self assert: tenMissing-=JUAMPI=-sourceSet: aString  self attributes at: 'srcset' put: aString-=JUAMPI=-renderObject: anObject labelled: aString on: html  html definitionTerm: [ html anchor           callback: [ (WAInspectorHaloPlugin on: anObject for: self) execute ];           with: aString ].  html definitionData: (self safePrintString: anObject)-=JUAMPI=-fullStackUrl  ^self urlForDebugAction: '_fullStack'-=JUAMPI=-parents  ^Array with: WARequestHandlingConfiguration instance with: WACacheConfiguration instance-=JUAMPI=-testNotImplemented  | generator |  generator := WAResponseGenerator on: self requestContext.  self requestContext response nextPutAll: 'oops'.  generator notImplemented.  self assertContents: 'Not Implemented'-=JUAMPI=-ambigousExamples  ^#(#('www.seaside.st' '/www.seaside.st') #('http://www.seaside.st:443/' 'http://www.seaside.st:443/') #('https://www.seaside.st:80/' 'https://www.seaside.st:80/') #('http://www.seaside.st:/' 'http://www.seaside.st/') #('http://' '/') #('http://@' '/') #('http://@www.seaside.st/' 'http://@www.seaside.st/') #('http://:lukas@www.seaside.st/' 'http://:lukas@www.seaside.st/') #('http://lukas:@www.seaside.st/' 'http://lukas:@www.seaside.st/') #('http://www.seaside.st' 'http://www.seaside.st/') #('http://www.seaside.st//' 'http://www.seaside.st/') #('http://www.seaside.st/.' 'http://www.seaside.st/') #('http://www.seaside.st/./' 'http://www.seaside.st/') #('http://www.seaside.st/..' 'http://www.seaside.st/') #('http://www.seaside.st/../' 'http://www.seaside.st/') #('http://www.seaside.st/?' 'http://www.seaside.st/') #('http://www.seaside.st/??' 'http://www.seaside.st/?%3F') #('http://www.seaside.st/?=2' 'http://www.seaside.st/') #('http://www.seaside.st/?&' 'http://www.seaside.st/') #('http://www.seaside.st/?1==' 'http://www.seaside.st/?1=%3D') #('http://www.seaside.st/?1=2&' 'http://www.seaside.st/?1=2') #('http://www.seaside.st/#' 'http://www.seaside.st/') #('http://www.seaside.st/##' 'http://www.seaside.st/#%23') #('http://www.seaside.st/#?a=b' 'http://www.seaside.st/#%3Fa%3Db'))-=JUAMPI=-start: anInteger  self attributes at: 'start' put: anInteger-=JUAMPI=-document: anObject mimeType: aMimeType  self document: (anObject seasideMimeDocument           mimeType: aMimeType;           yourself)-=JUAMPI=-createRegistry  ^WADispatcher new register: (WARedirectingApplication new           sessionClass: WATestSession;           cache: WAUnidirectionalCache new;           yourself) at: self registryName-=JUAMPI=-from  ^from-=JUAMPI=-width: anInteger  self attributes at: 'width' put: anInteger-=JUAMPI=-copy  ^self error: 'SystemConfigurations are singletons and should not be copied.'-=JUAMPI=-testContents  file contents: #(83 101 97 115 105 100 101) asByteArray.  self assert: file rawContents = #(83 101 97 115 105 100 101) asByteArray.  self assert: (file contentsDecodedUsing: 'ISO-8859-1') = 'Seaside'-=JUAMPI=-ports: aCollection  ports := aCollection-=JUAMPI=-urlForAction: aBlock  ^self actionUrl withField: (self callbacks store: (WAActionCallback on: aBlock))-=JUAMPI=-localAttributeAt: aSymbol ifAbsent: absentBlock  ^absentBlock value-=JUAMPI=-destroy  super destroy.  urlEncoder := xmlEncoder := nil-=JUAMPI=-< otherVersion  ^major < otherVersion major or: [ major = otherVersion major and: [ minor < otherVersion minor ] ]-=JUAMPI=-canAnswer  ^self decorations anySatisfy: [:each |  each isKindOf: WAAnswerHandler ]-=JUAMPI=-initializeWithBlock: aBlock  self initialize.  block := aBlock-=JUAMPI=-children  ^groups-=JUAMPI=-version: aVersion  version := aVersion-=JUAMPI=-execute  self handler parent defaultName: self handler name-=JUAMPI=-testPostFields  | request headers |  request := WARequest method: 'POST' uri: '/foo?bar=1'.  self     deny: request isXmlHttpRequest;     assert: request headers class equals: WAHeaderFields;     assert: request remoteAddress isNil;     assert: request isPost;     assert: request sslSessionId isNil.  headers := Dictionary new.  headers at: 'content-type' put: WAMimeType formUrlencoded greaseString.  request setHeaders: headers.  request setBody: 'baz=2&bar=3'.  request setPostFields: (WARequestFields new           at: 'baz' put: '2';           at: 'bar' put: '3';           yourself).  self assert: request postFields size = 2.  self assert: (request postFields at: 'baz') = '2'.  self assert: (request postFields at: 'bar') = '3'.  self assert: request queryFields size = 1.  self assert: (request queryFields at: 'bar') = '1'.  self assert: request fields size = 3.  self assert: (request fields at: 'bar') = '1'.  self assert: (request fields at: 'baz') = '2'-=JUAMPI=-renderContentOn: html  html paragraph: [ html popupAnchor           callback: [ self batchFunctionalTestLoop ];           with: 'popup'.        html break.        html popupAnchor           extent: 300 @ 300;           callback: [ self batchFunctionalTestLoop ];           with: 'popup with extent'.        html break.        html popupAnchor           position: 100 @ 100;           callback: [ self batchFunctionalTestLoop ];           with: 'popup with position'.        html break.        html popupAnchor           location: true;           callback: [ self batchFunctionalTestLoop ];           with: 'popup with location'.        html break.        html popupAnchor           resizable: false;           callback: [ self batchFunctionalTestLoop ];           with: 'popup not resizable'.        html break.        html popupAnchor           resizable: false;           extent: 300 @ 300;           position: 50 @ 50;           callback: [ self popupCloseTest ];           with: 'popup with close button' ]-=JUAMPI=-newStrategy  ^WAIPSessionTrackingStrategy new-=JUAMPI=-span: anInteger  self attributes at: 'span' put: anInteger-=JUAMPI=-media: aString  self attributes at: 'media' put: aString-=JUAMPI=-start  self application initialContinuationClass new handle: self requestContext-=JUAMPI=-renderContentOn: html  self renderExplanationOn: html.  self renderSwapParentOn: html-=JUAMPI=-testBody  | actual |  actual := WAHtmlCanvas builder render: [:html |  html unorderedList: [ html listItem: 'an item' ] ].  self assert: actual = '<ul><li>an item</li></ul>'-=JUAMPI=-isActionContinuation  ^self class isActionContinuation-=JUAMPI=-verifyBrowserSessionIDFor: requestContext  | cookie |  cookie := requestContext request cookieAt: self browserSessionIDCookieKey.  ^cookie notNil and: [ cookie value = self browserSessionID ]-=JUAMPI=-seasidePossibleCauses  ^#('you included self in the return value of #children' 'You''re probably missing a return (^) somewhere.')-=JUAMPI=-testEmpty  | key |  key := strategy keyFromContext: self requestContext.  self assert: key isNil-=JUAMPI=-initializeOn: aCollection mimeType: aMimeType fileName: aString  self initialize.  self contents: aCollection.  self mimeType: aMimeType.  self fileName: aString-=JUAMPI=-dispatcher: anObject  dispatcher := anObject-=JUAMPI=-children  ^Array with: inputElements-=JUAMPI=-select: aDate  self date: aDate.  selectBlock value: aDate-=JUAMPI=-children  ^Array with: trail with: component-=JUAMPI=-ruby  ^self tag: 'ruby'-=JUAMPI=-initializeWithSnapshot: aSnapshot renderContext: aRenderContext  self initializeWithSnapshot: aSnapshot.  renderContext := aRenderContext-=JUAMPI=-raiseHalt  | context |  self halt.  context := self requestContext.  self inform: 'To be displayed' onAnswer: [  ]-=JUAMPI=-renderAcceptCharsetFor: aRequest on: html  html definitionTerm: 'Accept-Charset:'.  self renderQualifiedValues: aRequest acceptCharset on: html-=JUAMPI=-encodeOn: aStream usingQuotes: aBoolean  username isNil ifFalse: [ aBoolean ifTrue: [ aStream nextPut: $" ].        aStream nextPutAll: username.        aBoolean ifTrue: [ aStream nextPut: $" ].        aStream nextPutAll: ' <' ].  aStream nextPutAll: address.  username isNil ifFalse: [ aStream nextPut: $> ]-=JUAMPI=-type  ^nil-=JUAMPI=-assert: anArray at: anInteger main: aMainString sub: aSubString quality: aFloat  | value mimeType |  value := anArray at: anInteger.  self assert: (value isKindOf: WAQualifiedValue).  self assert: value quality = aFloat.  mimeType := value value.  self assert: (mimeType isKindOf: WAMimeType).  self assert: mimeType main = aMainString.  self assert: mimeType sub = aSubString-=JUAMPI=-testDoNotCache  self response doNotCache.  self assert: (self response headerAt: 'Pragma') = 'no-cache'.  self assert: (self response headerAt: 'Expires') notNil.  self assert: (self response headerAt: 'Cache-Control') = 'no-cache, max-age=0, must-revalidate, no-store'-=JUAMPI=-renderToolsOn: html  html paragraph: [ self canAnswer ifTrue: [ self renderAnsweringToolsOn: html ] ifFalse: [ self renderNotAnsweringToolsOn: html ] ]-=JUAMPI=-cacheEntryRemoved: anObject  (anObject respondsTo: #unregistered) ifTrue: [ [ anObject unregistered ] on: Error do: [:e |   ] ]-=JUAMPI=-tableHeading  ^self brush: WATableHeadingTag new-=JUAMPI=-tag  ^'input'-=JUAMPI=-store: anObject  | candidateKey |  [ candidateKey := WAKeyGenerator current keyOfLength: self keySize.  self at: candidateKey put: anObject overwrite: false ] whileFalse.  ^candidateKey-=JUAMPI=-buttons  ^#(save)-=JUAMPI=-sendFailFor: anError  | message |  message := WAEmailMessage from: self from to: self to subject: (self subjectFor: anError).  message body: (self bodyFor: anError).  message send-=JUAMPI=-visitStringAttribute: anAttribute  self html textInput     value: (anAttribute stringForValue: (self configuration at: anAttribute key));     callback: [:value |  self configuration takeValueFromString: value forAttribute: anAttribute ]-=JUAMPI=-isCommitted  ^false-=JUAMPI=-buildTable  ^WATableReport new     rowPeriod: 1;     rowColors: #('#eee' 'white');     rows: self notifications;     columns: (Array with: (WAReportColumn selector: #messageText title: 'Deprecated') with: (WAReportColumn selector: #details title: 'Details'));     yourself-=JUAMPI=-dispatchCallback  ^self name: (self storeCallback: WADispatchCallback new)-=JUAMPI=-testCopy  | copy absent |  cache at: 1 put: '1'.  cache at: 2 put: '2'.  copy := cache copy.  copy at: 1 put: '1a'.  copy at: 3 put: '3'.  self assert: (cache at: 1 ifAbsent: [ self assert: false ]) = '1'.  self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.  absent := false.  cache at: 3 ifAbsent: [ absent := true ].  self assert: absent.  self assert: (copy at: 1 ifAbsent: [ self assert: false ]) = '1a'.  self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.  self assert: (copy at: 3 ifAbsent: [ self assert: false ]) = '3'-=JUAMPI=-cssClass  ^cssClass-=JUAMPI=-span: anInteger  self attributes at: 'rbspan' put: anInteger-=JUAMPI=-tag  ^'track'-=JUAMPI=-testFragment  url fragment: 'id'.  self assert: url fragment = 'id'.  self assert: url greaseString = '/#id'-=JUAMPI=-created  self status: WAResponse statusCreated-=JUAMPI=-destroy  headers := cookies := nil-=JUAMPI=-discard  ^discard-=JUAMPI=-onReset: anObject  self document scriptGenerator event: 'reset' do: anObject on: self-=JUAMPI=-imageUpTime  ^DateAndTime now - self imageBootTime-=JUAMPI=-initialize  super initialize.  self reset-=JUAMPI=-onLoadedMetadata: anObject  self document scriptGenerator event: 'loadedmetadata' do: anObject on: self-=JUAMPI=-main: aString  main := aString-=JUAMPI=-renderContentOn: html  duration := 0.  referenceDict ifNil: [ referenceDict := self class referenceDict ].  self renderExplanationOn: html.  self renderAnchorsOn: html.  self renderScriptOn: html.  self renderTableOn: html.  self renderLineBreaksOn: html.  self renderCallbackOn: html.  self renderFormOn: html.  self renderIdTestOn: html.  self renderTextOn: html.  self renderHtmlTextOn: html.  self renderBreakOn: html.  self renderNativeBreakOn: html.  html div     class: 'result';     with: 'Seaside Performance Index: ' , duration greaseString-=JUAMPI=-commandLineArgumentsFrom: aSmalltalkImage  | options |  options := ((3 to: 1000) collect: [:each |  aSmalltalkImage vm getSystemAttribute: each ]) select: [:each |  each notNil ].  ^String streamContents: [:stream |  options do: [:each |  stream nextPutAll: each ] separatedBy: [ stream space ] ]-=JUAMPI=-updateUrl: aUrl  super updateUrl: aUrl.  (WAVisiblePresenterGuide client: (WAUpdateUrlVisitor url: aUrl)) start: self presenter-=JUAMPI=-reversed: aBoolean  self attributes at: 'reversed' put: aBoolean-=JUAMPI=-testPageExpired  | generator |  generator := WAResponseGenerator on: self requestContext.  self requestContext response nextPutAll: 'oops'.  generator pageExpired.  self assertContents: 'This page has expired, please use the back-button to navigate to the last valid page.'-=JUAMPI=-description  ^description isNil ifFalse: [ description ] ifTrue: [ self buildDescription ]-=JUAMPI=-renderInline: aBlock key: key on: html  self renderInline: aBlock factor: 1 key: key on: html-=JUAMPI=-tearDown  super tearDown.  process isNil ifFalse: [ GRPlatform current terminateProcess: process ].  process2 isNil ifFalse: [ GRPlatform current terminateProcess: process2 ].  mutex := nil.  process := nil.  process2 := nil-=JUAMPI=-snapshot  ^snapshot-=JUAMPI=-footer: aBlock  self footer with: aBlock-=JUAMPI=-visitIntegerAttribute: anAttribute  self visitNumberAttribute: anAttribute-=JUAMPI=-renderRowForWeek: initialDay on: html  html tableRow: [ 0 to: 6 do: [:each |  self renderCellForDate: (initialDay addDays: each) on: html ] ]-=JUAMPI=-challenge: aString  self attributeAt: 'challenge' put: aString-=JUAMPI=-script: aStringOrJSObject  self script with: aStringOrJSObject-=JUAMPI=-tableColumnGroup  ^self brush: WATableColumnGroupTag new-=JUAMPI=-getSearchContextFor: aSymbol  ^self getSearchContextFor: aSymbol ifAbsent: [ WAAttributeNotFound signalWithKey: aSymbol ]-=JUAMPI=-testAssociationsDo  | keys values |  one at: 'foo' put: 1.  two at: 'bar' put: 2.  two at: 'foo' put: 3.  keys := OrderedCollection new.  values := OrderedCollection new.  merged associationsDo: [:assoc |  keys add: assoc key.        values add: assoc value ].  self assert: keys asArray = #('foo' 'bar' 'foo').  self assert: values asArray = #(1 2 3)-=JUAMPI=-hasCallback  ^callbackBlock notNil-=JUAMPI=-classesInTheSelectedPackage  ^selectedPackage ifNil: [ #() ] ifNotNil: [ selectedPackage classes ]-=JUAMPI=-testAsMIMEDocumentStream  | document |  document := 'dolphin' readStream seasideMimeDocument.  self assert: document contentType = WAMimeType textPlain.  self assert: document content = 'dolphin'-=JUAMPI=-closeThisPopup  ^self respond: [:resp |  resp           contentType: WAMimeType textHtml;           nextPutAll: (WAHtmlCanvas builder                 fullDocument: true;                 rootBlock: [:root |  root                       title: 'Seaside';                       beHtml5 ];                 render: [:html |  html script: 'window.close();' ]) ]-=JUAMPI=-testRemoveFilter  | filter1 filter2 |  handler addFilter: (filter1 := WARequestFilter new).  handler addFilter: (filter2 := WARequestFilter new).  self assert: (handler removeFilter: WARequestFilter new) isNil.  self assert: (handler removeFilter: filter1) = filter1.  self assert: handler filters size = 1.  self assert: handler filters first = filter2.  self assert: (handler removeFilter: filter2) = filter2.  self assert: handler filters isEmpty.  self assert: (handler removeFilter: filter2) isNil-=JUAMPI=-renderContentOn: html  self actions do: [:symbol |  symbol numArgs = 0 ifTrue: [ self renderLink: symbol on: html ] ifFalse: [ self renderInput: symbol on: html ] ]-=JUAMPI=-status: aNumber message: aString  self committedCheck.  super status: aNumber message: aString-=JUAMPI=-states  ^Array with: current-=JUAMPI=-year: anIntegerOrString  year := anIntegerOrString greaseInteger ifNil: [ 1900 ]-=JUAMPI=-renderContentOn: html  html heading: count.  html anchor     callback: [ self increase ];     with: '++'.  html space.  html anchor     callback: [ self decrease ];     with: '--'-=JUAMPI=-newStrategy  ^WACookieForBrowserIPForCrawlerTrackingStrategy new-=JUAMPI=-testActionCallback  | key1 key2 |  key1 := registry store: (WAActionCallback on: [ log add: 1 ]).  key2 := registry store: (WAActionCallback on: [ log add: 2 ]).  self should: [ self request: (WARequestFields new                 at: key1 put: nil;                 yourself) ] raise: WARenderNotification.  self assertLog: #(1).  self should: [ self request: (WARequestFields new                 at: key2 put: nil;                 yourself) ] raise: WARenderNotification.  self assertLog: #(2).  self should: [ self request: (WARequestFields new                 at: key2 put: nil;                 at: key1 put: nil;                 yourself) ] raise: WARenderNotification.  self assertLog: #(1).  self should: [ self request: (WARequestFields new                 at: key1 put: nil;                 at: key1 put: nil;                 yourself) ] raise: WARenderNotification.  self assertLog: #(1)-=JUAMPI=-isReversed  ^isReversed-=JUAMPI=-initialize  | charSet |  super initialize.  charSet := self requestContext charSet.  charSet isNil ifTrue: [ self acceptCharset: self defaultUrlCharset ] ifFalse: [ self acceptCharset: charSet ]-=JUAMPI=-rawBody  ^body-=JUAMPI=-method: aMethod  method := aMethod-=JUAMPI=-taskbarIcon  ^self windowIcon ifNil: [ self presenter ifNil: [ super taskbarIcon ] ifNotNil: #taskbarIcon ]-=JUAMPI=-label  ^self presenter label-=JUAMPI=-selectedItems  | wrappers items |  wrappers := listPresenter listItems.  items := wrappers collect: [:e |  | value |        value := associationsWrapperToItem at: e ifAbsent: [ nil ].        (value isNil or: [ e state not ]) ifTrue: [ nil ] ifFalse: [ value ] ] thenSelect: [:e |  e notNil ].  ^items-=JUAMPI=-whenSelectedItemsChanged: aBlock  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectedItemsChanged: `@argument' -> '`@receiver whenSelectionChangedDo: [ :selection | `@argument cull: selection selectedItems ]'.  self selection whenChangedDo: [:selection |  aBlock cull: selection selectedItems ]-=JUAMPI=-adoptMenuItemModel: item accumulator: controls  item subMenu ifNil: [ | button |        button := self buildButtonFor: item.        controls add: button ] ifNotNil: [ self emptyAccumulator: controls.        widget addMorphBack: (self theme newToolSpacerIn: widget).        widget add: item name font: self theme menuBarFont icon: item icon help: item description subMenu: item subMenu buildWithSpecAsPopup.        widget addMorphBack: (self theme newToolSpacerIn: widget) ]-=JUAMPI=-addPage: each to: aNotebook  aNotebook addLazyPage: [ self buildContentForPage: each ] label: (self buildLabelForPage: each).  aNotebook pages last model: each-=JUAMPI=-spec: anObject  spec := anObject-=JUAMPI=-widget  ^self adapter widget-=JUAMPI=-display: aBlock  ^self list display: aBlock-=JUAMPI=-listModel  self deprecated: 'It is not wise to allow external user access the content of a sub presenter. If this is accessed directly, the behavior should probably be moved to the MessageBrowser.'.  ^messageList listModel-=JUAMPI=-hasContentToShow  ^self nodeModel hasContentToShow-=JUAMPI=-testSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: 20.  self assert: (self adapter selectedIndexes includes: 2)-=JUAMPI=-testSubscriptionsAreTransfered  | count |  count := 0.  presenter beMultipleSelection.  presenter whenSelectionChangedDo: [ count := count + 1 ].  presenter beSingleSelection.  presenter selectIndex: 2.  self assert: count equals: 1-=JUAMPI=-rememberMe: anObject  rememberMe := anObject-=JUAMPI=-isOverlay  ^overlay = true-=JUAMPI=-testStartsWithoutSelection  self assert: self adapter selectedItem equals: nil-=JUAMPI=-fileOutClass: aClass from: aChangeSet  | aSet |  aSet := ChangeSet newChangeSet: aClass name.  aSet ifNil: [ ^self ].  aSet absorbClass: aClass name from: aChangeSet.  aSet fileOut.  ChangeSet removeChangeSet: aSet-=JUAMPI=-open  self presenter windowIsOpening-=JUAMPI=-leftOffset  ^layoutFrame leftOffset-=JUAMPI=-testSelectManyIndexesKeepsLastSelectionInWidget  presenter selectIndex: 1.  presenter selectIndex: 2.  self assert: self adapter selectedIndexes equals: #(2)-=JUAMPI=-testInitialSelectedTab  self assert: presenter selectedTab equals: nil.  presenter addTab: redTab.  self assert: presenter selectedTab equals: redTab.  presenter addTab: self redMorphTab.  self assert: presenter selectedTab equals: redTab-=JUAMPI=-whenSelectionIndexChanged: aBlock  self list whenSelectionIndexChanged: aBlock-=JUAMPI=-testDayBeforeMonthOf  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 1)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 14)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 30)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 1)) equals: 1.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 17)) equals: 1.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 30)) equals: 1-=JUAMPI=-testSelectPathSetsSelectedItem  presenter selectPath: #(1 3).  self assert: presenter selection selectedItem equals: 10-=JUAMPI=-initializeWindow  self presenter initializeWindow: self-=JUAMPI=-morph  ^self widget-=JUAMPI=-applyTo: aMorph  -=JUAMPI=-selectedPaths  ^selection-=JUAMPI=-newText  ^self instantiate: SpTextPresenter-=JUAMPI=-wantsVisualFeedback  ^wantsVisualFeedback-=JUAMPI=-setFocus  self focusOrder     add: changesListPresenter;     add: classesListPresenter;     add: methodsListPresenter;     add: textPresenter-=JUAMPI=-testActivationOnDoubleClickShouldActivateOnDoubleClick  | activatedItem |  activatedItem := nil.  presenter     activateOnDoubleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter doubleClickAtIndex: 1.  self assert: activatedItem equals: 10-=JUAMPI=-aboutToStyle: aBoolean  self deprecated: 'Use #withSyntaxHighlight, #withoutSyntaxHighlight or #syntaxHighlight: instead.' transformWith: '`@receiver aboutToStyle: `@argument' -> '`@receiver syntaxHighlight: `@argument'.  self syntaxHighlight: aBoolean-=JUAMPI=-execute  self evaluateSelectionAndDo: [:result |  self inspectObject: result ]-=JUAMPI=-contextMenu  ^contextMenu-=JUAMPI=-updatePresenter  self modelChanged-=JUAMPI=-testIconNameFrom  self assert: command iconProvider equals: Smalltalk ui icons.  command iconName: #banana from: self.  self assert: command iconProvider equals: self.  self assert: command icon equals: self banana-=JUAMPI=-resizerWidth  ^self model resizerWidth-=JUAMPI=-whenCurrentActivatedChanged: aBlock  self deprecated: 'Use #whenCurrentActivatedChangedDo: instead.' transformWith: '`@receiver whenCurrentActivatedChanged: `@statements' -> '`@receiver whenCurrentActivatedChangedDo: `@statements'.  self whenCurrentActivatedChangedDo: aBlock-=JUAMPI=-menuColumn: column row: rowIndex  | menuPresenter |  menuPresenter := self model contextMenu.  menuPresenter ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ menuPresenter value buildWithSpec ]-=JUAMPI=-resizingSetSelector  ^layout isHorizontal ifTrue: [ #hResizing: ] ifFalse: [ #vResizing: ]-=JUAMPI=-leftLabel  ^leftLabel-=JUAMPI=-whenNumberTypeChangedDo: aBlock  self property: #numberType whenChangedDo: aBlock-=JUAMPI=-setSelectedItem: anItem  self deprecated: 'Use #selectedItem: instead' transformWith: '`@receiver setSelectedItem: `@argument' -> '`@receiver selectedItem:`@argument'.  ^self selectedItem: anItem-=JUAMPI=-oldPage: anObject  oldPage := anObject-=JUAMPI=-registerClassShortcuts: aWidget  aWidget bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self selectedClass ifNotNil: [ self browseMethodFull ] ].  aWidget bindKeyCombination: $d meta toAction: [ self selectedClass ifNotNil: [ self forgetClass ] ].  aWidget bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self selectedClass ifNotNil: [ self removeClass ] ]-=JUAMPI=-action: aBlock  action := aBlock-=JUAMPI=-presenterAt: aName  ^self basicPresenters at: aName-=JUAMPI=-initialize  super initialize.  self withSyntaxHighlight.  self registerEventsForStyling.  self contextMenu: self buildCodeMenu.  self contextKeyBindings: self buildCodeKeyBindings-=JUAMPI=-y: anObject  y := anObject-=JUAMPI=-iconName: aSymbol  self icon: (self iconNamed: aSymbol)-=JUAMPI=-pages  ^layout presenters-=JUAMPI=-isMultipleSelection  ^true-=JUAMPI=-whenCurrentlyActivatedChanged: aBlock  self deprecated: 'Use #whenCurrentlyActivatedChangedDo: instead.' transformWith: '`@receiver whenCurrentlyActivatedChanged: `@statements' -> '`@receiver whenCurrentlyActivatedChangedDo: `@statements'.  self whenCurrentlyActivatedChangedDo: aBlock-=JUAMPI=-passenger  ^[ self model passenger ]-=JUAMPI=-objectClassPage  ^SpNotebookPage title: 'Object class' icon: (self iconNamed: #nautilusIcon) provider: [ MessageBrowser new messages: Object methods ]-=JUAMPI=-pathOfItem: anItem root: aRoot  aRoot isExpanded ifFalse: [ ^#() ].  (aRoot children includes: anItem) ifTrue: [ ^{(aRoot children indexOf: anItem)} ].  aRoot children withIndexDo: [:aChild :index |  | aSubPath |        aSubPath := self pathOfItem: anItem root: aChild.        aSubPath ifNotEmpty: [ ^{index} , aSubPath ] ].  ^#()-=JUAMPI=-askOkToClose  ^askOkToClose-=JUAMPI=-expandAll  self changed: #expandAll with: #()-=JUAMPI=-configureButton: aButton item: aToolbarItem  self subclassResponsibility-=JUAMPI=-buildWidget  ^SpTransferMorph new     model: self;     passenger: self passenger;     source: self source;     yourself-=JUAMPI=-value  ^self presenter value-=JUAMPI=-buildWidget  ^SpStubTreeView new-=JUAMPI=-drawOn: aCanvas  | area |  area := self innerBounds.  aCanvas fillRectangle: area fillStyle: self fillStyle.  value > 0 ifTrue: [ cachedWidth := self completedWidth.        area := (area left + (cachedWidth - (area width / 2.5))) @ area top corner: area origin + (cachedWidth @ area height).        aCanvas fillRectangle: area fillStyle: self barFillStyle ].  self borderStyle frameRectangle: self bounds on: aCanvas-=JUAMPI=-askBeforeChanging  ^self model askBeforeChanging-=JUAMPI=-isEmpty  ^self items isEmpty-=JUAMPI=-content  ^'I am a modal demo with default actions buttons. I set closeOnBackdropClick to true (which is the default value) to close the modal if the user click on the backdrop of the modal. This will trigger the cancel action of the modal.'-=JUAMPI=-headerTitle: aString  headerTitle := aString-=JUAMPI=-maxWidth: aNumber  self maxExtent: aNumber @ self maxExtentOrDefault y-=JUAMPI=-includesIndex: anIndex  ^self selectedIndexes includes: anIndex-=JUAMPI=-addItemLeft: aMorph  leftPanel addMorphBack: (aMorph           vResizing: #spaceFill;           yourself)-=JUAMPI=-selectPaths: pathArray  self subclassResponsibility-=JUAMPI=-isStyleProperty  ^true-=JUAMPI=-selectionMode  ^selectionMode-=JUAMPI=-contextMenuFromCommandsGroup: aValuable  self contextMenu: [ aValuable value beRoot asMenuPresenter ]-=JUAMPI=-displayedIcon  self model hasIcons ifFalse: [ ^nil ].  ^self widget currentIcon-=JUAMPI=-step  self model step-=JUAMPI=-whenChangedDo: aBlock  self announcer when: ValueChanged do: [:ann |  aBlock cull: ann newValue cull: ann oldValue cull: ann ]-=JUAMPI=-apply  fromPort attachTransmission: self-=JUAMPI=-onActivation: anObject  onActivation := anObject-=JUAMPI=-manualFractionComputation  | delta |  delta := numberOfProportionals isZero ifTrue: [ 0 ] ifFalse: [ 1 / numberOfProportionals ].  self commands doWithIndex: [:e :idx |  e layoutFrame hasNoOffsets ifTrue: [ self setWidgetLayoutWithNoOffset: e at: idx delta: delta ] ifFalse: [ self setWidgetLayoutWithOffset: e at: idx ] ]-=JUAMPI=-methodsListPresenter  ^methodsListPresenter-=JUAMPI=-removeRootsSuchAs: aBlock  self widgetDo: [:w |  w model rootNodes removeAllSuchThat: [:node |  aBlock value: node nodeModel ] ]-=JUAMPI=-initializePresenters  super initializePresenters.  textModel := self newCode.  textModel whenBuiltDo: [:ann |  ann widget font: self codeFont ].  refreshingBlock := [:item |  true ].  self     initializeDropList;     setFocus-=JUAMPI=-buildWidget  widget := FTTableMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     intercellSpacing: self class intercellSpacing;     yourself.  self addModelTo: widget.  ^widget-=JUAMPI=-checkboxLabel: anObject  checkboxLabel := anObject-=JUAMPI=-addModelItemsToWindowMenu: aMenu  self presenter addModelItemsToWindowMenu: aMenu-=JUAMPI=-leftFraction: aNumber  ^0-=JUAMPI=-beep  widget flash-=JUAMPI=-initialize  super initialize.  bottomFraction := 1.  bottomOffset := 0.  leftFraction := 0.  leftOffset := 0.  rightFraction := 1.  rightOffset := 0.  topFraction := 0.  topOffset := 0-=JUAMPI=-borderWidth: aNumber  borderWidth := aNumber-=JUAMPI=-object: anObject  object := anObject-=JUAMPI=-whenSelectedItemChanged: aBlock  self list whenSelectedItemChanged: aBlock-=JUAMPI=-propertyAt: aKey ifPresent: aBlock ifAbsent: absentBlock  ^self properties at: aKey ifPresent: aBlock ifAbsent: absentBlock-=JUAMPI=-startWithoutSelection  startsWithSelection := false-=JUAMPI=-model: anObject  model := anObject-=JUAMPI=-testWhenMaximumChangedDo  | count result |  count := 0.  presenter whenMaximumChangedDo: [:value |  count := count + 1.        result := value ].  presenter maximum: 10.  self assert: count equals: 1.  self assert: result equals: 10-=JUAMPI=-testSelectItemSetsSelectedIndex  presenter selectItem: 20.  self assert: presenter selection selectedIndex equals: 2-=JUAMPI=-includesPath: aPath  ^selection includes: aPath-=JUAMPI=-application  ^self hasOwner ifTrue: [ self owner application ] ifFalse: [ application ifNil: [ self flag: #TODO.              application := SpApplication defaultApplication ] ]-=JUAMPI=-property: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObject-=JUAMPI=-descriptionPresenter: anObject  descriptionPresenter := anObject-=JUAMPI=-checkThatSidesDiffer: escapeBlock  changeSorterLeft selectedChangeSet == changeSorterRight selectedChangeSet ifFalse: [ ^self ].  self inform: 'This command requires that thechange sets selected on the twosides of the change sorter *not*be the same.'.  ^escapeBlock value-=JUAMPI=-send: aSelector withArguments: arguments  self commands add: (SpLayoutSend selector: aSelector)-=JUAMPI=-buildWidget  | instance |  instance := SpAthensMorph new.  self presenter whenDrawBlockChangedDo: [:newBlock |  instance drawBlock: newBlock ].  self presenter whenExtentChangedDo: [:newExtent |  instance extent: newExtent ].  instance extent: self presenter surfaceExtent.  instance drawBlock: self presenter drawBlock.  instance setBalloonText: self model help.  self presenter whenHelpChangedDo: [ instance setBalloonText: self model help ].  ^instance-=JUAMPI=-shortcuts  | collection |  collection := OrderedCollection new.  KMRepository default categories do: [:cat |  cat keymaps do: [:keymapping |  collection add: (KMShortcutDeclaration new                       shortcutName: keymapping name;                       categoryName: cat name;                       yourself) ] ].  ^collection sorted: #categoryName ascending-=JUAMPI=-buildAdapterWithSpecLayout: aSpecLayout  ^SpBindings value: self application adapterBindings during: [ self basicBuildAdapterWithSpecLayout: aSpecLayout ]-=JUAMPI=-children  ^childrenBlock-=JUAMPI=-instantiateModels: aCollectionOfPairs  self deprecated: 'Use #instantiatePresenters: instead' transformWith: '`@receiver instantiateModels: `@statement' -> '`@receiver instantiatePresenters: `@statement'.  ^self instantiatePresenters: aCollectionOfPairs-=JUAMPI=-pushMessage: message to: aMorph  pushedMessages add: message.  aMorph     removeAllMorphs;     addMorph: message asStringMorph-=JUAMPI=-defaultDate  ^Date today-=JUAMPI=-presenter: aPresenter  presenter := aPresenter-=JUAMPI=-addConstraits: constraints toChild: childMorph  | theMorph |  theMorph := childMorph.  theMorph setProperty: #constraints toValue: constraints.  ^theMorph-=JUAMPI=-addModelTo: tableMorph  self model columns do: [:each |  tableMorph addColumn: (self newColumnFrom: each) ].  self ensureAtLeastOneColumnIn: tableMorph.  self isResizable ifTrue: [ tableMorph beResizable ] ifFalse: [ tableMorph beNotResizable ].  tableMorph setMultipleSelection: self model isMultipleSelection.  self refreshShowColumnHeaders.  self refreshWidgetSelection.  self presenter whenShowColumnHeadersChangedDo: [:showColumns |  self refreshShowColumnHeaders ].  self presenter whenModelChangedDo: [ widget refresh ].  self presenter whenColumnsChangedDo: [ self refreshColumnsInWidget ].  tableMorph setBalloonText: self help.  self configureScrolling.  tableMorph     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: self.  tableMorph dataSource: self newDataSource.  self presenter whenItemFilterBlockChangedDo: [:block |  self updateItemFilterBlockWith: block ].  self presenter whenSearchChangedDo: [ self updateSearch ].  self updateItemFilterBlockWith: self itemFilter-=JUAMPI=-addColumn: aTableColumn  columns add: aTableColumn-=JUAMPI=-submitButton  ^submitButton-=JUAMPI=-enabled: aBoolean  ^self subclassResponsibility-=JUAMPI=-addItemsFromContext: aContext  self flag: #TODO-=JUAMPI=-hasCustomSearch  ^searchBlock notNil-=JUAMPI=-unregisterShortcut: oldShortcut  | receiver |  receiver := self window.  (receiver isNil or: [ oldShortcut isNil ]) ifTrue: [ ^self ].  receiver model removeKeyCombination: oldShortcut-=JUAMPI=-inspectValue  ^self value inspect-=JUAMPI=-columns  ^widget columns-=JUAMPI=-testSmokeTestForDemoPages  self timeLimit: 1 minute.  SpDemoPage availablePages do: [:demoPage |  [ [ window := demoPage new openWithSpec ] on: Error do: [:e |  self fail: 'Broken demo page: ' , demoPage asString , '' , e signalerContext shortStack ] ] ensure: [ window ifNotNil: #close ] ]-=JUAMPI=-buildWidget  ^SpStubGridView new-=JUAMPI=-objectAsUnicodeCodePoint  ^String streamContents: [:stream |  stream << 'U+'.        self object codePoint printOn: stream base: 16 nDigits: 4 ]-=JUAMPI=-classToTest  ^SpMethodToolbar-=JUAMPI=-initialize  self flag: #pharoTodo.  super initialize.  oddPassage := true-=JUAMPI=-initializeTestedInstance  presenter     min: 1;     max: 100;     quantum: 1;     value: 20-=JUAMPI=-taskbarIcon  ^self model taskbarIcon-=JUAMPI=-defineInputPorts  ^{SpTextPort new}-=JUAMPI=-whenMenuChangedDo: aBlock  self property: #menu whenChangedDo: aBlock-=JUAMPI=-hasButtonWithLabel: aString  ^self widget leftPanel submorphs , self widget rightPanel submorphs detect: [:e |  (e isKindOf: SpToolBarButtonMorph) and: [ e label = aString ] ] ifFound: [ true ] ifNone: [ false ]-=JUAMPI=-visiblePages  ^visiblePages-=JUAMPI=-vShrinkWrap  self subclassResponsibility-=JUAMPI=-show  self widgetDo: #show-=JUAMPI=-selectedElement  ^self list selection selectedItem ifNil: [ self list selectedIndex ifNotNil: [:currentIndex |  currentIndex = 0 ifTrue: [ ^nil ].              self list listItems ifNotEmpty: [:aList |  aList at: currentIndex ] ] ]-=JUAMPI=-initializePresenters  super initializePresenters.  self content: SpInputTextDropList-=JUAMPI=-testSelectInvalidPathsIsEmpty  presenter selectPaths: {#(40) .         #(10 20)}.  self assert: presenter selection isEmpty-=JUAMPI=-add: aBlock withSpec: aSpec left: left right: right  self add: aBlock withSpec: aSpec top: nil bottom: nil left: left right: right-=JUAMPI=-exploreValue  ^self value inspect-=JUAMPI=-enabled  ^self presenter isEnabled-=JUAMPI=-basicSelectIndex: indexToSelect  selectedIndex := indexToSelect-=JUAMPI=-acceptDroppingMorph: draggedMorph event: event inMorph: source  | item |  item := self widget ifNotNil: [:w |  w scrollerSubMorphFromPoint: event position ].  item ifNil: [ ^self ].  ^self acceptDropBlock valueWithEnoughArguments: {draggedMorph model model .         event .         source model model model .         item model nodeModel}-=JUAMPI=-observablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: self-=JUAMPI=-page: anObject  page := anObject-=JUAMPI=-step  | oldAngle transform |  oldAngle := transformationMorph rotationDegrees.  transform := transformationMorph transform withAngle: (oldAngle + 15) degreesToRadians negated.  transformationMorph     transform: transform;     invalidRect: transformationMorph fullBounds-=JUAMPI=-testShortcutKey  self should: [ command shortcutKey ] raise: CmNoShortcutIsDefined.  command shortcutKey: $a asKeyCombination.  self assert: command shortcutKey equals: $a asKeyCombination-=JUAMPI=-addPaneSplitters  self removePaneSplitters.  self addPaneVSplitters.  self addPaneHSplitters.  self linkSplittersToSplitters-=JUAMPI=-rebuildWithSpecLayout: aSpec  | sub |  sub := self model window submorphs copy.  self model window removeAllMorphs.  sub allButLast do: [:e |  self model window addMorphBack: e ].  self model addPresenterIn: self widget withSpecLayout: aSpec.  self widget model: self-=JUAMPI=-label  ^label-=JUAMPI=-initialize  super initialize.  name := 'some name'.  surname := ''.  number1 := 1.  number2 := 12.009.  scale := 42.  password := 'password'.  rememberMe := true.  date := '2018-01-01' asDate.  gender := #male.  selectedItems := {(self items at: 3) .   (self items at: 4)}-=JUAMPI=-shortcut  ^shortcut-=JUAMPI=-labelClickable: aBoolean  labelClickableHolder value: aBoolean-=JUAMPI=-menuColumn: column row: rowIndex  | menuPresenter |  menuPresenter := self model contextMenu.  menuPresenter ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ | m |        m := menuPresenter value.        m isMorph ifTrue: [ m ] ifFalse: [ m buildWithSpec ] ]-=JUAMPI=-target  ^self owner ifNotNil: [:aMorph |  aMorph submorphs before: self ]-=JUAMPI=-limit2  ^10-=JUAMPI=-prepareAsStandaloneApplication  -=JUAMPI=-open  ^self openWithSpec-=JUAMPI=-whenQuantumChangedDo: aBlock  self property: #quantum whenChangedDo: aBlock-=JUAMPI=-testTextWithStyle  | text |  presenter     behavior: nil;     doItReceiver: Object;     type: 'self asString.'.  text := self adapter textWithStyle.  self assertText: text atInterval: (1 to: 4) isStyle: #self.  self assertText: text atInterval: (6 to: 13) isStyle: #unary.  presenter type: '10 + 42.0'.  text := self adapter textWithStyle.  self assertText: text atInterval: (1 to: 2) isStyle: #integer.  self assertText: text atInterval: (4 to: 4) isStyle: #binary.  self assertText: text atInterval: (6 to: 9) isStyle: #number.  presenter behavior: Object.  presenter type: 'm1 ^ "test" 42'.  text := self adapter textWithStyle.  self assertText: text atInterval: (1 to: 2) isStyle: #patternKeyword.  self assertText: text atInterval: (4 to: 4) isStyle: #return.  self assertText: text atInterval: (6 to: 11) isStyle: #comment.  self assertText: text atInterval: (13 to: 14) isStyle: #number-=JUAMPI=-testRightClickShowsMenu  | menu |  presenter contextMenu: (menu := SpMockMenuPresenter new).  self deny: menu shown.  self emulateRightClick.  self assert: menu shown-=JUAMPI=-spacing  ^spacing-=JUAMPI=-buildAdapterFor: aPresenter bindings: bindings  adapter := (aPresenter needRebuild or: [ aPresenter adapter isNil ]) ifTrue: [ (bindings adapterClass: self adapterName) adapt: aPresenter ] ifFalse: [ aPresenter adapter           removeSubWidgets;           yourself ].  aPresenter needRebuild: true.  adapter layout: self.  children keysAndValuesDo: [:presenterNameOrLayout :constraints |  adapter add: (self resolvePresenter: presenterNameOrLayout presenter: aPresenter bindings: bindings) constraints: constraints ].  ^adapter-=JUAMPI=-oldPage  ^oldPage-=JUAMPI=-asMenuPresenterWith: aBlock  | builder |  builder := SpMenuPresenterBuilder new.  aBlock value: builder menuPresenter.  ^builder     visit: self;     menuPresenter-=JUAMPI=-newNumberInput  ^self instantiate: SpNumberInputFieldPresenter-=JUAMPI=-redMorphTab  presenter     label: 'Red Morph';     icon: (presenter iconNamed: #smallBackIcon);     contents: (Morph new           color: Color red;           yourself)-=JUAMPI=-topologicSort: anObject  topologySort := anObject-=JUAMPI=-presenter  ^presenter-=JUAMPI=-label  ^label-=JUAMPI=-shown  ^shown-=JUAMPI=-newListColumn  ^SpMorphicTableColumn new     model: (SpStringTableColumn title: self presenter headerTitle evaluated: self presenter display);     yourself-=JUAMPI=-classToTest  ^SpTextInputFieldPresenter-=JUAMPI=-surnameTextInput: anObject  surnameTextInput := anObject-=JUAMPI=-buildLabel: text withIcon: icon  icon ifNil: [ ^text ifNil: [ '' ] ifNotNil: [ text ] ].  ^IconicListItem text: text icon: icon-=JUAMPI=-fromSpec: aSpec  | grps subgroup |  grps := OrderedCollection new.  aSpec label ifNotNil: [:label |  self title: label ].  subgroup := OrderedCollection new.  aSpec items do: [:each |  subgroup add: each.        each separator ifTrue: [ grps add: subgroup copy.              subgroup removeAll ] ].  subgroup ifNotEmpty: [ grps add: subgroup copy ].  grps do: [:each |  self addGroup: [:group |  each do: [:spec |  group addItem: [:item |  item fromSpec: spec ] ] ] ]-=JUAMPI=-initialize: anInteger  text label: anInteger asString-=JUAMPI=-initialize  super initialize.  borderWidth := 0.  borderColor := Color transparent.  enabled := true.  dragEnabled := false.  dropEnabled := false.  dragTransformationBlock := [:item :source |  item ].  wantDropBlock := [:draggedItem :event :source |  self dropEnabled ].  acceptDropBlock := [:draggedItem :event :source |   ].  transferBlock := [:passenger :source |  self defaultTransferFor: passenger from: source ].  color := self defaultColor.  self whenHelpChangedDo: [:string |  self withAdapterDo: [:w |  w update: #setBalloonText: with: {string} ] ].  self whenBorderWidthChangedDo: [:int |  self withWidgetDo: [:w |  w update: #borderWidth: with: {int} ] ].  self whenBorderColorChangedDo: [:newColor |  self withWidgetDo: [:w |  w update: #borderColor: with: {newColor} ] ].  self property: #color whenChangedDo: [:newColor |  self withAdapterDo: [:w |  w update: #color: with: {newColor} ] ].  self whenEnabledChangedDo: [:b |  self withAdapterDo: [:w |  w update: #enabled: with: {b} ] ].  self property: #dragEnabled whenChangedDo: [:b |  self withWidgetDo: [:w |  w update: #dragEnabled: with: {b} ] ].  self property: #dropEnabled whenChangedDo: [:b |  self withWidgetDo: [:w |  w update: #dropEnabled: with: {b} ] ].  styles := #()-=JUAMPI=-menu  ^menuBlockHolder value-=JUAMPI=-assertText: text at: index isStyle: styleName  | tag |  tag := SpCodeStyleForTest new.  text attributesAt: index do: [:each |  self fillTag: tag withAttribute: each ].  self assert: tag equals: (self style: styleName)-=JUAMPI=-newMultiColumnList  self deprecated: 'Use newTable instead' on: '2019-02-05' in: #Pharo8.  ^self instantiate: SpMultiColumnListPresenter-=JUAMPI=-actionArguments  ^[ Array with: self ]-=JUAMPI=-whenSelectionChanged: aBlock  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectionChanged: `@argument' -> '`@receiver whenSelectionChangedDo: `@argument'.  ^self whenSelectionChangedDo: aBlock-=JUAMPI=-testModelSettingValueHolderToModel  | model point valueHolder presenter |  point := 1 @ 0.  model := SpTestingPointModel x: 1 y: 2.  valueHolder := NewValueHolder value: point.  presenter := SpTestingPresenterWithModel on: model.  self assert: presenter announcingObject isSpAnnouncingObject.  self deny: presenter announcingObject isValueHolder.  self assert: valueHolder isSpAnnouncingObject.  self assert: valueHolder isValueHolder.  presenter model: valueHolder.  self assert: presenter announcingObject isSpAnnouncingObject.  self assert: presenter announcingObject isValueHolder.  self assert: presenter announcingObject == valueHolder.  self assert: presenter announcingObject announcer numberOfSubscriptions > 0-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: self edgeName-=JUAMPI=-createNullPresenters: anInteger  nullPresentersInstVarNames := self generateNullPresentersInstVarNames: anInteger.  dynamicPresenter instantiatePresenters: self nullPresentersInstVarNamesAndPresenterNamesArray-=JUAMPI=-block: aBlock layoutFrame: aLayoutFrame  | column |  column := SpColumnLayout composed.  aBlock value: column.  subwidget := column.  self layoutFrame: aLayoutFrame-=JUAMPI=-addInstancesVariable: elements  -=JUAMPI=-number: aNumber  self text: aNumber asString-=JUAMPI=-currentlyActivated  ^currentlyActivated-=JUAMPI=-whenCanDeselectByClickChangedDo: aBlock  self deprecated: 'It is not clear what option to select if deselected'-=JUAMPI=-newTextInput  ^self instantiate: SpTextInputFieldPresenter-=JUAMPI=-testDaysAfterMonthOf  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 1)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 14)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 30)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 1)) equals: 10.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 17)) equals: 10.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 30)) equals: 10-=JUAMPI=-testIsDisplayed  windowPresenter := SpTextPresenter new openWithSpec.  self assert: windowPresenter isDisplayed.  windowPresenter window minimize.  self assert: windowPresenter isDisplayed.  windowPresenter window close.  self assert: windowPresenter isDisplayed not-=JUAMPI=-calculateHomogeneousColumnWidths  | columnWidth |  columnWidth := 0.  morphs do: [:each |  columnWidth := columnWidth max: (self minWidthOf: each) ].  ^Array new: numColumns withAll: (self baseColumnWidth max: columnWidth)-=JUAMPI=-theme  ^theme-=JUAMPI=-forgetSelector: selector inClass: aClass fromChangeSet: aChangeSet  aChangeSet removeSelectorChanges: selector class: aClass-=JUAMPI=-dateInput: anObject  dateInput := anObject-=JUAMPI=-testRemoveHeaderTitleInPresenterRemovesColumnHeaderMorph  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  self presenter headerTitle: 'test'.  self presenter hideHeaderTitle.  backendForTest denyHasHeader: self adapter-=JUAMPI=-initialize  self class initializeSlots: self.  super initialize-=JUAMPI=-commands: anObject  commands := anObject-=JUAMPI=-initialize  super initialize.  self spec: #defaultSpec-=JUAMPI=-initializeWindow: aWindowPresenter  aWindowPresenter     title: self title;     initialExtent: 500 @ 350-=JUAMPI=-ensureHeightPosition: aMorph in: aRect  | firstMorph |  self position ifNil: [ ^self ].  firstMorph := aMorph submorphs first.  firstMorph vResizing = #rigid ifFalse: [ firstMorph vResizing: #rigid ].  firstMorph privateBounds: (firstMorph bounds withHeight: (self heightPositionIn: aRect extent))-=JUAMPI=-takeKeyboardFocus  ^self inspector takeKeyboardFocus-=JUAMPI=-resetArrayComputation  super resetArrayComputation.  currentOffset := 0.  currentProportional := 0.  numberOfProportionals := 0.  lastFractionIndex := 0.  autoFractionComputation := true.  size := self commands size-=JUAMPI=-fillItem: aMenuItem with: aCommand  aMenuItem     name: aCommand name;     description: aCommand description;     icon: aCommand icon;     action: [ aCommand execute ].  aCommand hasShortcutKey ifTrue: [ aMenuItem shortcut: aCommand shortcutKey ].  ^aMenuItem-=JUAMPI=-surnameLabel  ^surnameLabel-=JUAMPI=-valueAtColumn: aColumn row: aRow  ^(columns at: aColumn) readObject: (self model items at: aRow)-=JUAMPI=-testActivateRaisesActivatedEvent  presenter state: false.  self assertEvent: #whenActivatedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: true ]-=JUAMPI=-hSpaceFill  self subclassResponsibility-=JUAMPI=-isDisplayed  self flag: #TODO.  ^self hasWindow ifTrue: [ self root isDisplayed ] ifFalse: [ false ]-=JUAMPI=-beIcons  self displayMode: SpToolBarDisplayMode modeIcon-=JUAMPI=-whenHelpChangedDo: aBlock  self property: #help whenChangedDo: aBlock-=JUAMPI=-menu  self deprecated: 'Use #contextMenu instead.' transformWith: '`@receiver menu' -> '`@receiver contextMenu'.  ^self contextMenu-=JUAMPI=-mainIcon  ^mainIcon-=JUAMPI=-fileOutMessage  self selectedSelector ifNotNil: [:selector |  Cursor write showWhile: [ self model fileOutSelector: selector from: self selectedClass ] ]-=JUAMPI=-resetTo: anIndex  self presenters copy withIndexDo: [:presenter :index |  index <= anIndex ifFalse: [ layout remove: presenter ] ]-=JUAMPI=-property: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosure-=JUAMPI=-browseMessages  self currentMethod ifNotNil: [:method |  model browseMessagesFrom: method selector ]-=JUAMPI=-menuGroups  ^self model menuGroups reject: [:e |  e isEmpty ]-=JUAMPI=-testObservableSlotWorksAsNormalSlot  point x: 17.  point y: 299.  self assert: point x equals: 17.  self assert: point y equals: 299-=JUAMPI=-childrenBlock  ^tree childrenBlock-=JUAMPI=-layout: aLayout  layout := aLayout-=JUAMPI=-selector  ^self selection asSymbol-=JUAMPI=-refreshWidgetSelection  | rowIndexes |  rowIndexes := self presenter selection selectedIndexes.  rowIndexes = self widget selectedIndexes ifTrue: [ ^self ].  rowIndexes isEmpty ifTrue: [ self widget basicSelectIndexes: #() ] ifFalse: [ self widget basicSelectIndexes: rowIndexes ].  ^self widget refresh-=JUAMPI=-aboutTitle  (self presenter respondsTo: #aboutTitle) ifTrue: [ ^self presenter aboutTitle ].  ^self presenter toolName-=JUAMPI=-namesOfDaysLabels  ^namesOfDaysLabels-=JUAMPI=-activate  activationBlock value: (SpMillerActivation on: 1)-=JUAMPI=-fixedAt: aNumber  self state: (SpProgressBarFixed value: aNumber)-=JUAMPI=-adapter  ^self-=JUAMPI=-emptyList  self dropList emptyList-=JUAMPI=-whenExtentForPreviewChanged: aBlock  extentForPreview whenChangedDo: aBlock-=JUAMPI=-save: aValue  saveBlock value: aValue-=JUAMPI=-compareToCurrentVersion  self compareTo: rgMethod withLabel: 'Current version'-=JUAMPI=-performHeaderActionSelector  ^self headerAction ifNil: [ nil ] ifNotNil: [ #performHeaderAction ]-=JUAMPI=-initializeTestedInstance  super initializeTestedInstance.  presenter addColumn: (SpStringTableColumn evaluated: [:e |  e displayString ])-=JUAMPI=-whenSelectedItemChanged: aBlock  messageList whenSelectedItemChanged: aBlock-=JUAMPI=-selectedItem: anItem  self deprecated: 'Use #selectItem: instead' transformWith: '`@receiver selectedItem: `@arg' -> '`@receiver selectItem: `@arg'.  self selectItem: anItem-=JUAMPI=-subMenu: aMenuPresenter  aMenuPresenter ifNotNil: [ aMenuPresenter owner: self ].  subMenu := aMenuPresenter-=JUAMPI=-model  ^model-=JUAMPI=-rowSpan  ^self span y-=JUAMPI=-surnameLabel: anObject  surnameLabel := anObject-=JUAMPI=-initializeWindow: aWindowPresenter  aWindowPresenter     title: 'Transmission example browser';     initialExtent: 800 @ 600-=JUAMPI=-rootMenu  ^self owner isMenuPresenter ifTrue: [ self owner rootMenu ] ifFalse: [ self ]-=JUAMPI=-object  ^self inspector object-=JUAMPI=-cacheHierarchyForClasses: aCollection  cachedHierarchy := self buildHierarchyForMessages: aCollection-=JUAMPI=-testWhenStateChangedDo  presenter whenStateChangedDo: [:new :old |  self deny: old.        self assert: new ].  self deny: presenter state.  self openInstance.  presenter state: true.  self assert: presenter state-=JUAMPI=-testRightClickShowsMenu  | menu |  presenter contextMenu: (menu := SpMockMenuPresenter new).  self deny: menu shown.  self emulateRightClick.  self assert: menu shown-=JUAMPI=-url: aString  self action: [ WebBrowser openOn: aString ].  self label ifNil: [ self label: aString ]-=JUAMPI=-beColumnHomogeneous  self columnHomogeneous: true-=JUAMPI=-clicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  (widget handlesMouseDown: evt) ifTrue: [ widget mouseDown: evt.        widget mouseUp: evt ]-=JUAMPI=-classToTest  ^SpRGBSliders-=JUAMPI=-whenMaximumChangedDo: aBlock  self property: #maximum whenChangedDo: aBlock-=JUAMPI=-whenSyntaxHighlightChangedDo: aBlock  self property: #syntaxHighlight whenChangedDo: aBlock-=JUAMPI=-displayBlock: aBlock  displayBlock value: aBlock-=JUAMPI=-newButton  ^PluggableButtonMorph on: self getState: #state action: #action label: #label menu: #menu:-=JUAMPI=-layoutSpec  ^layoutSpec-=JUAMPI=-eventKeyStrokesForPreviousFocus  ^{Character tab shift asKeyCombination}-=JUAMPI=-isEmpty  ^self subclassResponsibility-=JUAMPI=-whenValueChangedDo: aBlock  slider whenValueChangedDo: aBlock-=JUAMPI=-newColumnFrom: aTableColumn  ^(SpMorphicTableColumn on: aTableColumn)     width: aTableColumn width;     yourself-=JUAMPI=-encrypted: aBoolean  ^self input encrypted: aBoolean-=JUAMPI=-testShowPresenterShowsWidget  self skip-=JUAMPI=-initialize  super initialize.  paneMorphs := OrderedCollection new-=JUAMPI=-classToTest  ^SpSliderPresenter-=JUAMPI=-assertEvent: anEventName isRaisedInPresenter: aPresenter whenDoing: aBlock  self assertWith: [:times |  times > 0 ] timesRaisedEvent: anEventName inPresenter: aPresenter whenDoing: aBlock-=JUAMPI=-initializePresenters  fieldNormal := self newTextInput.  fieldDisabled := self newTextInput enabled: false.  fieldPlaceholderText := self newTextInput placeholder: 'Placeholder text'.  fieldEncrypted := self newTextInput     text: 'Password';     bePassword-=JUAMPI=-autoRefresh: aBoolean  autoRefresh := aBoolean-=JUAMPI=-okAction  ^okAction-=JUAMPI=-testChangingHelpAffectTheWidget  ^self skip-=JUAMPI=-whenCurrentActivatedChangedDo: aBlock  currentActivated whenChangedDo: aBlock-=JUAMPI=-testUnselectWidgetIndexRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectPath: #().  self assert: counter equals: 1-=JUAMPI=-methodBrowser  ^methodBrowser-=JUAMPI=-show  visible := true-=JUAMPI=-initializePresenters  listModel := self instantiate: SpListPresenter.  textModel := self newCode.  toolbarModel := self instantiate: SpMethodToolbar.  self focusOrder     add: listModel;     add: toolbarModel;     add: textModel-=JUAMPI=-maxHeight: aNumber  self maxExtent: self maxExtentOrDefault x @ aNumber-=JUAMPI=-updateClassesList  | sel |  sel := self selectedClass.  self selectedChangeSet ifNil: [ classesListPresenter items: {} ] ifNotNil: [:change |  classesListPresenter items: (change changedClasses sort: [:a :b |  a name < b name ]) ].  sel ifNotNil: [ classesListPresenter selectItem: sel ]-=JUAMPI=-addLazyPage: aBlock label: aStringOrMorph action: anActionMorphOrNil  | newPage label |  newPage := SpNotebookPageMorph new.  newPage lazyPageMorphCreation: aBlock.  label := self buildLabelFrom: aStringOrMorph withAction: anActionMorphOrNil.  newPage labelMorph: label.  self addPage: newPage label: label-=JUAMPI=-label: aStringOrImageMorph  self button label: aStringOrImageMorph-=JUAMPI=-testSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedIndex |  presenter selection whenChangedDo: [:selection |  selectedIndex := selection selectedIndexes ].  self adapter selectIndex: 1.  self assert: (selectedIndex includes: 1)-=JUAMPI=-selectedItems: anObject  selectedItems := anObject asArray-=JUAMPI=-label  ^label-=JUAMPI=-layout: aMorph in: layoutBounds  aMorph submorphsDo: [:m |  | constraints |        constraints := m valueOfProperty: #constraints.        (m visible and: [ constraints isOverlay not ]) ifTrue: [ m bounds: layoutBounds ].        (m visible and: [ constraints isOverlay ]) ifTrue: [ | morphBounds left top newBounds |              morphBounds := layoutBounds area > (0 @ 0 corner: m extent) area ifTrue: [ layoutBounds origin corner: layoutBounds origin + m extent ] ifFalse: [ layoutBounds ].              left := layoutBounds width / 2 - (morphBounds width / 2).              top := layoutBounds height / 2 - (morphBounds height / 2).              newBounds := layoutBounds origin + (left @ top) corner: layoutBounds corner + (left @ top).              m bounds: newBounds ].        m visible ifFalse: [ m bounds: (0 @ 0 corner: 0 @ 0) ] ]-=JUAMPI=-openWithSpec  self layout ifNil: [ ^super openWithSpec ].  ^self application open: self withSpecLayout: self layout-=JUAMPI=-classToTest  ^SpLabelPresenter-=JUAMPI=-updateText  textRefreshingProcess ifNotNil: [ textRefreshingProcess terminate ].  textRefreshingProcess := [ | indexes items |  indexes := listModel selection selectedIndexes sort collect: [:i |  i printString ].  indexes := indexes joinUsing: '; '.  items := listModel selectedItems collect: [:i |  i printString ].  items := items sort joinUsing: '; '.  UIManager default defer: [ textModel1 text: indexes.        textModel2 text: items ] ] fork-=JUAMPI=-enableSearch  searchEnabled := true-=JUAMPI=-traversePresentersDo: aBlock  self traversePresentersDo: aBlock excluding: Set new-=JUAMPI=-eventKeyStrokesForNextFocus  ^{Character arrowRight command ctrl asKeyCombination}-=JUAMPI=-selector: anObject  selector := anObject-=JUAMPI=-popUpInWorld: aWorld  self shown: true-=JUAMPI=-wantsVisualFeedback  ^self model wantsVisualFeedback-=JUAMPI=-getText  ^self model text-=JUAMPI=-display: aBlock  tree display: aBlock-=JUAMPI=-implementorsMethod  self method ifNotNil: [:aMethod |  self model browseMessagesFrom: aMethod selector ]-=JUAMPI=-testSmokeOpenEmptyPresenter  window := presenter openWithSpec-=JUAMPI=-scrollingChanged  widget container updateAllRows.  self presenter verticalAlignment     firstVisibleRowIndex: widget firstVisibleRowIndex;     lastVisibleRowIndex: widget lastVisibleRowIndex-=JUAMPI=-computeNumberOfRowsAndColumns  numRows := 0.  numColumns := 0.  self allGridConstraints do: [:each |  numRows := numRows max: each row + each rowSpan - 1.        numColumns := numColumns max: each column + each columnSpan - 1 ]-=JUAMPI=-list1  ^list1-=JUAMPI=-newMenuBar  ^self instantiate: SpMenuBarPresenter-=JUAMPI=-vRigid  self subclassResponsibility-=JUAMPI=-preferedPaneColor  ^preferedPaneColor value-=JUAMPI=-whenTextChanged: aBlock  self deprecated: 'Use #whenTextChangedDo: instead.' transformWith: '`@receiver whenTextChanged: `@statement' -> '`@receiver whenTextChangedDo: `@statement'.  self whenTextChangedDo: aBlock-=JUAMPI=-setX: xValue setY: yValue  x := xValue.  y := yValue-=JUAMPI=-contextMenu: aValuable  contextMenu := aValuable-=JUAMPI=-initializePresenters  element11 := self newMorph morph: (Morph new color: Color red).  element21 := self newMorph morph: (Morph new color: Color green).  element12 := self newMorph morph: (Morph new color: Color blue).  element22 := self newMorph morph: (Morph new color: Color yellow).  borderWidth := self newSlider     beHorizontal;     min: 0;     max: 100.  columnSpacing := self newSlider     beHorizontal;     min: 0;     max: 100.  rowSpacing := self newSlider     beHorizontal;     min: 0;     max: 100.  columnHomogeneous := self newCheckBox label: 'Column is homogeneous'.  rowHomogeneous := self newCheckBox label: 'Row is homogeneous'.  self announcer when: SpWidgetBuilt send: #widgetBuilt: to: self-=JUAMPI=-classToTest  ^SpNumberInputFieldPresenter-=JUAMPI=-classToTest  ^SpCodePresenter-=JUAMPI=-chooseDateButton  ^chooseDateButton-=JUAMPI=-testDoesNotUnderstand  | block |  themeDecorator property: #foo returnsValueOf: 42.  self assert: themeDecorator foo equals: 42.  block := [ 42 ].  themeDecorator property: #fooBlock returnsValueOf: block.  self assert: themeDecorator fooBlock equals: 42.  block := [:x |  x + 42 ].  themeDecorator property: #fooBlock: returnsValueOf: block.  self assert: (themeDecorator fooBlock: 3) equals: 45-=JUAMPI=-pageClass  ^SpDemoDynamicMemoryGamePresenter-=JUAMPI=-selectItem: anItem  self selectionMode selectItem: anItem-=JUAMPI=-heterogeneousDropList  ^heterogeneousDropList-=JUAMPI=-action  ^self model action-=JUAMPI=-testWhenTextChangesRaisesSingleEvent  self assertWith: [:times |  times = 1 ] timesRaisedEvent: #whenTextChangedDo: inPresenter: presenter whenDoing: [ presenter text: 'test' ]-=JUAMPI=-setIndex: anIndex  ^self dropList setIndex: anIndex-=JUAMPI=-listSize  ^self model listSize-=JUAMPI=-bePassword: aBoolean  isPassword := aBoolean-=JUAMPI=-initialize  self class initializeSlots: self.  super initialize.  ticks := 0.  highestValue := Float negativeInfinity.  lowestValue := Float infinity.  stepBy := 1-=JUAMPI=-keyStroke: aKeyStroke  keyStroke value cull: aKeyStroke-=JUAMPI=-performSearch: item matching: pattern  ^searchBlock value: item value: pattern-=JUAMPI=-observablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: self-=JUAMPI=-add: aPresenter constraints: constraints  self widgetDo: [:aPanel |  self basicAdd: aPresenter constraints: constraints to: aPanel ]-=JUAMPI=-type: aString  aString do: [:each |  self keyPressed: each asciiValue shift: each isUppercase meta: false control: false option: false ]-=JUAMPI=-notifyError: aSpecNotification  GrowlMorph openWithLabel: 'Error' contents: aSpecNotification message backgroundColor: GrowlMorph theme dangerBackgroundColor labelColor: GrowlMorph theme textColor-=JUAMPI=-addSplitter  self commands add: (SpSplitterVertical commands: self commands)-=JUAMPI=-testPresentersBlockReceivesAthensCanvas  | receivedCanvas |  self presenter drawBlock: [:canvas |  receivedCanvas := canvas ].  self adapter redraw.  self openInstance.  1 second wait.  self assert: receivedCanvas isNotNil.  self assert: (receivedCanvas isKindOf: AthensCanvas)-=JUAMPI=-protocolListAction  protocolList transmitTo: methodList transform: [:selectedProtocol |  selectedProtocol ifNotNil: [ (selectedProtocol methodSelectors collect: [:methodSelector |  self methodNamed: methodSelector ]) asOrderedCollection ] ifNil: [ #() ] ] postTransmission: [:methodPresenter |  methodPresenter selectIndex: 1 ]-=JUAMPI=-visiblePages  ^layout visiblePages-=JUAMPI=-selectedClass  ^self selectedMethod origin-=JUAMPI=-classToTest  ^SpTreeTablePresenter-=JUAMPI=-initializePresenters  menu := self mainMenu.  list := self newList.  page := self instantiate: (selectedPage := self availablePages first).  menu applyTo: self.  list     items: self availablePages;     display: [:item |  item pageName ];     contextMenu: (self newMenu           addItem: [:item |  item                 name: 'Browse';                 icon: (self iconNamed: #smallHelp);                 action: [ list selectedItem browse ] ];           addItem: [:item |  item                 name: 'Browse presenter';                 icon: (self iconNamed: #smallHelp);                 action: [ list selectedItem new pageClass browse ] ];           yourself).  self focusOrder     add: list;     add: page-=JUAMPI=-searchText: aString  | search |  aString isEmptyOrNil ifTrue: [ ^#() ].  search := aString trimBoth asLowercase.  ^Array streamContents: [:stream |  self elements withIndexDo: [:each :rowIndex |  (self model performSearch: each matching: search) ifTrue: [ stream nextPut: rowIndex ] ] ]-=JUAMPI=-whenActionPerformedDo: aBlock  self property: #actionPerformed whenChangedDo: aBlock-=JUAMPI=-testSelectAll  self initializationText.  self openInstance.  presenter selectAll.  self assert: presenter selectionInterval equals: (1 to: 15)-=JUAMPI=-explore: anObject  ^self class explore: anObject-=JUAMPI=-displayMode  ^displayMode-=JUAMPI=-doItContext  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8-=JUAMPI=-initializePresenters  listModel := self newTable.  listModel     sortingBlock: [:a :b |  self sortClassesInCachedHierarchy: a b: b ];     addColumn: (SpStringTableColumn title: 'Location' evaluated: [:item |  self locationOf: item ]);     addColumn: (SpStringTableColumn title: 'Selector' evaluated: [:item |  self selectorOf: item ]);     addColumn: (SpStringTableColumn title: 'Package' evaluated: [:item |  self packageOf: item ]);     beResizable.  self contextMenu: self messageListMenu-=JUAMPI=-content: aWidgetClass  subwidget := self instantiate: aWidgetClass.  self focusOrder add: subwidget-=JUAMPI=-initialize  | isChanging |  super initialize.  isHorizontal := true.  marks := OrderedCollection new.  max := 100.  min := 0.  quantum := 1.  value := 0.  absoluteValue := 0.  label := ''.  isChanging := false.  self whenMaxChangedDo: [:m |  self changed: {#max: .               m} ].  self whenMinChangedDo: [:m |  self changed: {#min: .               m} ].  self whenQuantumChangedDo: [:m |  self changed: {#quantum: .               m} ].  self whenValueChangedDo: [:v |  isChanging ifFalse: [ isChanging := true.              self absoluteValue: (self valueToAbsoluteValue: v).              self changed: {#scaledValue: .                     v}.              isChanging := false ].        self changed: #value ].  self whenAbsoluteValueChangedDo: [:v |  isChanging ifFalse: [ isChanging := true.              self value: (self absoluteValueToValue: v).              self changed: {#value: .                     v}.              isChanging := false ] ].  self whenLabelChangedDo: [:v |  self changed: #label ]-=JUAMPI=-testPresenterTextIsSetInWidget  presenter text: 'something'.  self assert: self widget text equals: 'something'-=JUAMPI=-fieldPlaceholderText: anObject  fieldPlaceholderText := anObject-=JUAMPI=-hasFilter  ^self widget hasFilter-=JUAMPI=-initialize  super initialize.  onlyStrong := false-=JUAMPI=-indeterminated: anObject  indeterminated := anObject-=JUAMPI=-title: aString  self widgetDo: [:w |  w setLabel: aString ]-=JUAMPI=-icon  ^self presenter icon ifNil: [ self defaultIcon ]-=JUAMPI=-setUp  super setUp.  presentersBuilder := SpDynamicPresentersListBuilder new     modelObjects: (1 to: 14);     presenter: SpButtonPresenter configuredAs: [:button :i |   ];     buildDynamicPresenter;     yourself.  layout := SpDynamicLeftToRightColumnsLayout columns: 7-=JUAMPI=-action: anObject  action := anObject-=JUAMPI=-applyTo: aModel  aModel applyMenuModel: self-=JUAMPI=-browseValue  ^self value browse-=JUAMPI=-testSettingNilResetsSelection  self presenter selectItem: 10.  self presenter selectItem: nil.  self assert: self presenter selectedItem equals: nil.  self assert: self adapter selectedIndexes isEmpty-=JUAMPI=-isComposite  ^true-=JUAMPI=-headerColumn: column  | headerMorph |  column id ifNil: [ ^nil ].  headerMorph := SpHeaderCellMorph new     addMorph: column id asMorph asReadOnlyMorph;     yourself.  column isSortable ifTrue: [ headerMorph eventHandler: (MorphicEventHandler new on: #click send: #sortByColumn:event:morph: to: self withValue: column) ].  ^headerMorph-=JUAMPI=-ghostText: aText  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: aText-=JUAMPI=-openInstance  backendForTest openInstanceOf: self-=JUAMPI=-testUnselectSelectedItemRemovesItFromSelectionList  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmpty-=JUAMPI=-execute  self editor paste-=JUAMPI=-externalIndex: anObject  externalIndex := anObject-=JUAMPI=-update: aParameter  self changed: aParameter-=JUAMPI=-= anObject  ^super = anObject and: [ instVarName = anObject instVarName ]-=JUAMPI=-testSelectIndexesOutsideRangeHasNoSelectedItems  presenter selectIndexes: {4 .         5}.  self assert: presenter selection selectedItems isEmpty-=JUAMPI=-whenMenuChangedDo: aBlock  self property: #contextMenu whenChangedDo: aBlock-=JUAMPI=-maximize  self changed: #maximize with: #()-=JUAMPI=-sortingBlock: aBlock  listModel sortingBlock: aBlock-=JUAMPI=-textConverter: aTextConverter  textConverter := aTextConverter method: self textConverter method-=JUAMPI=-menu: aMenu shifted: aBoolean  | menu |  (self allowMenuOnNoItem not and: [ self selectedItems isEmpty ]) ifTrue: [ ^nil ].  menuBlockHolder value ifNil: [ ^nil ].  menuBlockHolder value isBlock ifFalse: [ ^menuBlockHolder value ].  menu := SpMenuPresenter new.  menuBlockHolder value cull: menu cull: aBoolean.  ^menu-=JUAMPI=-ensureKeyBindingsFor: widget  super ensureKeyBindingsFor: widget.  self shortcut ifNotNil: [:s |  self registerShortcut: s ]-=JUAMPI=-cellColumn: column row: rowIndex  | displayValue cell item |  item := self model itemAt: rowIndex.  displayValue := column readObject: item.  cell := FTCellMorph new     cellInset: 5;     yourself.  self model hasIcons ifTrue: [ (self model iconFor: item) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ] ].  cell addMorphBack: displayValue asMorph asReadOnlyMorph.  ^cell-=JUAMPI=-giveFocusToNextFrom: aModel  ^self model giveFocusToNextFrom: aModel-=JUAMPI=-properties  ^self styles select: [:each |  each isStyleProperty ]-=JUAMPI=-emptyList  ^self dropList emptyList-=JUAMPI=-open: anObject  object := anObject.  self open-=JUAMPI=-testTickIncrementsOne  timeline tick.  self assert: timeline ticks equals: 1-=JUAMPI=-childrenWidgets  ^widget submorphs first submorphs , widget submorphs second submorphs-=JUAMPI=-copyClass: aClass from: source to: destination  destination absorbClass: aClass name from: source-=JUAMPI=-methodModified: anAnnouncement  UIManager default defer: [ self handleMethodModified: anAnnouncement ]-=JUAMPI=-action: aBlock  action := aBlock-=JUAMPI=-listElementAt: anIndex  ^self model at: anIndex ifAbsent: [ nil ]-=JUAMPI=-testUnselectAllUnselectsSingleSelection  presenter     selectPath: #(1 1);     unselectAll.  self assert: presenter selection isEmpty-=JUAMPI=-items  ^items value-=JUAMPI=-model  ^model-=JUAMPI=-valueToAbsoluteValue: v  ^((v - self min) / (self max - self min)) asFloat-=JUAMPI=-testSelectItemSetsSelectedPath  presenter selectItem: 20.  self assert: presenter selection selectedPath equals: #(1 1 3)-=JUAMPI=-initialize  super initialize-=JUAMPI=-label  ^self presenter label-=JUAMPI=-testWhenDaySelectedBlock  | blockExecuted d |  blockExecuted := false.  d := Date year: 2018 month: 9 day: 15.  calendar     adaptToDate: d;     whenDaySelectedBlock: [ blockExecuted := true ].  self deny: blockExecuted.  calendar daysButtons basicPresenters value values first performAction.  self assert: blockExecuted-=JUAMPI=-propertyAt: aKey put: aValue  ^self properties at: aKey put: aValue-=JUAMPI=-testSelectItemAddsPathToSelectedPathList  presenter selectItem: 10.  self assert: (presenter selection includesPath: #(1 3))-=JUAMPI=-adapterName: anObject  adapterName := anObject-=JUAMPI=-testSetSelectIndexRaisesSelectionChangeEventWithSelectedIndex  | selectedIndexes |  presenter whenSelectionChangedDo: [:selection |  selectedIndexes := selection selectedIndexes ].  presenter selectIndex: 1.  self assert: (selectedIndexes includes: 1)-=JUAMPI=-testRebuildPresenterBeforeOpeningWorks  self assert: presenter label label equals: ''.  self shouldnt: [ presenter selectFirstElement.        self openInstance ] raise: Error.  self assert: presenter label label equals: '1'-=JUAMPI=-calculateExtentFor: aMorph constraint: constraint computation: computation  | cellExtent height width |  cellExtent := computation cellExtentAt: constraint position.  width := self calculateWidthFor: aMorph base: cellExtent x.  height := self calculateHeightFor: aMorph base: cellExtent y.  ^width @ height-=JUAMPI=-buildWidget  ^SpTickingSpecWindow new     model: self;     isResizeable: self isResizeable;     yourself-=JUAMPI=-placeholder  ^self model placeholder-=JUAMPI=-testSelectInvalidPathHasNoSelectedPaths  presenter selectPath: #(4).  self assert: presenter selection selectedPaths isEmpty-=JUAMPI=-testSelectMultipleIndexesAddsAllToSelectedIndexList  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: (presenter selection includesIndex: 1).  self assert: (presenter selection includesIndex: 3)-=JUAMPI=-canResize  ^resize-=JUAMPI=-extent: aPoint  | newExtent |  newExtent := aPoint rounded.  (bounds extent closeTo: newExtent) ifTrue: [ ^self ].  self invalidRect: bounds.  bounds := bounds topLeft extent: newExtent.  self layoutChanged.  self invalidRect: bounds-=JUAMPI=-testSelectPresenterItemSetsSelectedIndexInWidget  self skip-=JUAMPI=-dispatchTo: aNotificationCenter  ^aNotificationCenter notify: self-=JUAMPI=-add: aName withConstraints: aBlock  | constraints |  constraints := self constraintsClass new.  aBlock value: constraints.  children at: aName put: constraints-=JUAMPI=-differentCardsCountSlider  ^differentCardsCountSlider-=JUAMPI=-initialize  needRecalculatePages := false.  super initialize-=JUAMPI=-testRemovePage  | page |  presenter addPage: (page := SpNotebookPage title: 'Mock3' provider: [ SpLabelPresenter new ]).  self assert: self adapter numberOfTabs equals: 3.  presenter removePage: page.  self assert: self adapter numberOfTabs equals: 2-=JUAMPI=-initialize  super initialize.  self     name: 'Inspect';     description: 'Inspect the context of this command.'-=JUAMPI=-activateOnSingleClick  activateOnSingleClick := true-=JUAMPI=-refreshPrintDescription  self printDescription: self selectedElement-=JUAMPI=-clicked  widget toggleSelected-=JUAMPI=-sliceButton  ^sliceButton-=JUAMPI=-defaultWindowPresenterClass  ^SpTickingWindowPresenter-=JUAMPI=-initialize  super initialize.  type := #SpContainerPresenter.  self commands: OrderedCollection new-=JUAMPI=-displaySymbol  ^displaySymbol ifNil: [ #printString ]-=JUAMPI=-initializeWindow: aWindowPresenter  aWindowPresenter     title: 'Grid layout example';     initialExtent: 300 @ 400-=JUAMPI=-itemNamed: aString  ^self items detect: [:e |  e label = aString ]-=JUAMPI=-fieldPlaceholderText  ^fieldPlaceholderText-=JUAMPI=-icon: anIcon  icon := anIcon-=JUAMPI=-addVariableFields: elements  self tempNames withIndexDo: [:name :index |  elements add: (ContextTempEyeElement host: self object tempName: name tempIndex: index) ]-=JUAMPI=-shown: anObject  ^shown := anObject-=JUAMPI=-presenterProvider: aBlock  presenterProvider := aBlock-=JUAMPI=-classToTest  ^SpListPresenter-=JUAMPI=-add: aBlock withSpec: aSpec left: aNumber  self add: aBlock withSpec: aSpec top: nil bottom: nil left: aNumber right: nil-=JUAMPI=-preview  ^preview-=JUAMPI=-initializeDialogWindow: aDialog  super initializeDialogWindow: aDialog.  aDialog     initialExtent: 600 @ 400;     title: 'Select a method';     closeOnBackdropClick: false-=JUAMPI=-deselect  self widgetDo: [:w |  w changed: #deselect.        w model selectionChanged.        w dependents do: [:e |  e changed ] ]-=JUAMPI=-newTable  ^self instantiate: SpTablePresenter-=JUAMPI=-newColumnFrom: aTableColumn  ^(SpMorphicTableColumn on: aTableColumn)     width: aTableColumn width;     yourself-=JUAMPI=-extent  ^transformationMorph extent-=JUAMPI=-runCase  self resources do: [:each |  each availableFor: self ].  [ super setUp.  self performTest ] ensure: [ self tearDown.        self cleanUpInstanceVariables ]-=JUAMPI=-listModel  ^listModel-=JUAMPI=-badgeColor  ^self theme badgeColor-=JUAMPI=-whenSelectionChangedDo: aBlock  selection whenChangedDo: aBlock-=JUAMPI=-initialize  super initialize.  action := [  ].  displayBlock := [:e |  e asString ]-=JUAMPI=-presenterAt: aName ifAbsent: aBlock  ^self basicPresenters at: aName ifAbsent: [ [ self readSlotNamed: aName ] on: SlotNotFound do: aBlock ]-=JUAMPI=-classToTest  ^SpToolBarPresenter-=JUAMPI=-password  ^password-=JUAMPI=-styles  ^styles-=JUAMPI=-isEnabled  ^enabled-=JUAMPI=-setUp  super setUp.  timeline := SpTimeline new-=JUAMPI=-initializeTestedInstance  presenter-=JUAMPI=-testUnselectSelectedItemRaisesSingleEvent  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 10.  self assert: counter equals: 1-=JUAMPI=-bindKeyCombination: aKMCombination toAction: aBlock  -=JUAMPI=-connectPresenters  self packageListAction.  self classListAction.  self protocolListAction.  self radioButtonsAction.  packageList selectIndex: 1-=JUAMPI=-testSetRootModelPushesPresenterToList  self presenter presenterBlock: [:model |  SpNullMillerPresenter on: (SpLabelPresenter new label: model asString) ].  self presenter setRootModel: 1.  self assert: self presenter size equals: 1-=JUAMPI=-addModelItemsToWindowMenu: aMenu  self model addMenuItemsToWindowMenu: aMenu-=JUAMPI=-initializeTestedInstance  presenter items: #(10 20 30)-=JUAMPI=-value  ^self host tempNamed: self tempName-=JUAMPI=-addVariableFields: elements  self variableFieldsToShow do: [:index |  elements add: (IndexedEyeElement host: self object index: index) ]-=JUAMPI=-addItemTo: aGroup  aGroup addItem: [:item |  item           name: 'Dynamic';           icon: (self iconNamed: #delete);           action: [ aGroup menuItems remove: item.              self needRebuild: false.              self buildWithSpec ] ].  self needRebuild: false.  self buildWithSpec-=JUAMPI=-setUp  super setUp.  presenter items: #(10 20 30)-=JUAMPI=-basicAdd: aPresenter constraints: constraints to: aPanel  self subclassResponsibility-=JUAMPI=-numberType  ^numberType-=JUAMPI=-placeholder  ^placeholder-=JUAMPI=-traverseInFocusOrderDo: aBlock excluding: excludes  self canTakeKeyboardFocus ifFalse: [ ^self ].  excludes add: self.  aBlock value: self-=JUAMPI=-color  ^color-=JUAMPI=-buildPushMessageToolBarItem  ^SpToolBarButton new     label: 'Push';     icon: (self iconNamed: #glamorousUp);     help: 'Push a new status bar message';     action: [ self pushMessage ];     yourself-=JUAMPI=-testActivateSubPresenterPushesElementToList  | mock |  self presenter presenterBlock: [:model |  mock := SpMockMillerPresenter new ].  self presenter setRootModel: 1.  mock activate.  self assert: self presenter size equals: 2-=JUAMPI=-rightClicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  (widget handlesMouseDown: evt) ifTrue: [ widget mouseDown: evt.        widget mouseUp: evt ]-=JUAMPI=-initializeTestedInstance  super initializeTestedInstance.  presenter addColumn: (SpStringTableColumn evaluated: [:e |  e ])-=JUAMPI=-refresh  self needRebuild: false.  self buildWithSpec-=JUAMPI=-testSubscriptionsAreTransfered  | count |  count := 0.  presenter beSingleSelection.  presenter whenSelectionChangedDo: [ count := count + 1 ].  presenter beMultipleSelection.  presenter selectIndex: 2.  self assert: count equals: 1-=JUAMPI=-styles  ^styles-=JUAMPI=-buildWidget  | newWidget |  newWidget := super buildWidget.  self presenter whenTextStylerChangedDo: [ self applyTextStyle ].  ^newWidget-=JUAMPI=-initializePresenter  self property: #object whenChangedDo: [ self objectChanged ].  text whenBuiltDo: [:w |  self text behavior: self object class ].  self initializeShortcuts-=JUAMPI=-connectPresenters  -=JUAMPI=-foundIcon  ^self iconNamed: #glamorousAccept-=JUAMPI=-whenReadSelectionIsChangedDo: aBlock  self property: #readSelection whenChangedDo: aBlock-=JUAMPI=-isSplitter  ^true-=JUAMPI=-selected  ^selected value-=JUAMPI=-classToTest  ^SpButtonPresenter-=JUAMPI=-triggerOkAction  -=JUAMPI=-title  ^'Pointers to: ' , self object printString-=JUAMPI=-color  ^color ifNil: [ Color transparent ]-=JUAMPI=-canDeselectByClick: aBoolean  self deprecated: 'It is not clear what option to select if deselected'-=JUAMPI=-window  ^window-=JUAMPI=-behavior: aClass  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the APIof the Code presenter... This method and other methods from the CodePresenter APIwill be removed.'.  self contextClass: aClass-=JUAMPI=-onDesactivation: anObject  onDesactivation := anObject-=JUAMPI=-menu  ^tree menu-=JUAMPI=-itemAtPath: aPath expanding: shouldExpandItems  | item |  (aPath isNil or: [ aPath isEmpty ]) ifTrue: [ ^nil ].  item := self rootItem.  aPath do: [:index |  (shouldExpandItems and: [ item isRoot not ]) ifTrue: [ item expand ].        item children size < index ifTrue: [ ^nil ].        item := item children at: index ].  ^item-=JUAMPI=-testUnselectNonSelectedItemRaisesNoEvent  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 20.  self assert: counter equals: 0-=JUAMPI=-topLeftOffset: aPoint  topOffset := aPoint y.  leftOffset := aPoint x-=JUAMPI=-initializeAnnouncements  SystemAnnouncer uniqueInstance weak when: ClassAdded , ClassCommented , ClassRecategorized , ClassModifiedClassDefinition , ClassRemoved , ClassRenamed , ClassReorganized , MethodAdded , MethodModified , MethodRecategorized , MethodRemoved , ProtocolAdded , ProtocolRemoved send: #updateClassesList to: self-=JUAMPI=-inspectionMenu: aMenu  self hasSelectedObject ifFalse: [ ^aMenu ].  ^super inspectionMenu: aMenu-=JUAMPI=-connectPresenters  button1 whenActivatedDo: [ self updateLabel ].  button1 whenDeactivatedDo: [ self updateLabel ].  button2 whenChangedDo: [ self updateLabel ].  button3 whenChangedDo: [ self updateLabel ]-=JUAMPI=-testHideColumnHeadersInPresenterHidesThemInWidget  self presenter hideColumnHeaders.  self deny: self adapter isShowColumnHeaders-=JUAMPI=-method4  -=JUAMPI=-initializeSemaphore  uiWaitingSemaphore := Semaphore new-=JUAMPI=-isResizeable  ^self model isResizeable-=JUAMPI=-testReplaceItemList  | changed |  changed := false.  presenter whenModelChangedDo: [ changed := true ].  presenter items: #(a b c).  self assert: (presenter model collection collect: #label) equals: #(a b c).  self assert: changed-=JUAMPI=-testColumnNotHomogeneousDiferentRowsAndColumns  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 2.  self place: label2 at: 3 @ 3.  self place: morph2 at: 4 @ 4.  layout := self newLayout.  layout layout beColumnNotHomogeneous.  (self styleExtent: 30 @ 20) applyTo: label1.  (self styleExtent: 40 @ 20) applyTo: morph1.  (self styleExtent: 50 @ 20) applyTo: label2.  (self styleExtent: 60 @ 20) applyTo: morph2.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 30 @ 20).  self assert: morph1 bounds equals: (30 @ 20 corner: 70 @ 40).  self assert: label2 bounds equals: (70 @ 40 corner: 120 @ 60).  self assert: morph2 bounds equals: (120 @ 60 corner: 180 @ 80)-=JUAMPI=-testAddPresenterToComponentListShouldNotBeEmpty  presenter addPresenter: SpButtonPresenter new.  self deny: presenter isEmpty-=JUAMPI=-removeAll  pagesHolder removeAll-=JUAMPI=-testSetSelectItemRaisesSelectionChangeEventWithSelectedPath  | selectedPath |  presenter whenSelectionChangedDo: [:selection |  selectedPath := selection selectedPath ].  presenter selectItem: 20.  self assert: selectedPath equals: #(1 1 3)-=JUAMPI=-initializePresenters  text := self newText.  sideRuler := self newMorph.  sideRuler morph: (Morph new           color: Color yellow;           extent: 50 @ 500;           useGradientFill;           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself).  text whenScrollValueChangedDo: [:newPosition |  self syncMorphPosition ].  text text: self loremIpsum-=JUAMPI=-buildWidget  | panelMorph |  panelMorph := SpToolBarMorph new.  self addModelTo: panelMorph.  ^panelMorph-=JUAMPI=-testContextMenu  | menu changed |  self assert: presenter contextMenu isNil.  menu := SpMenuPresenter new.  changed := false.  presenter whenMenuChangedDo: [ changed := true ].  presenter contextMenu: menu.  self assert: presenter contextMenu equals: menu.  self assert: changed-=JUAMPI=-width  ^width-=JUAMPI=-transferSubscriptionsTo: anotherSelectionMode  self selectionHolder transferSubscriptionsTo: anotherSelectionMode selectionHolder-=JUAMPI=-addPresenter: newSubPresenter  newSubPresenter whenActivatedDo: [:selection |  self changeSelection: selection selectedItem from: newSubPresenter ].  newSubPresenter owner: self.  layout add: newSubPresenter-=JUAMPI=-asArray  ^specArray-=JUAMPI=-testFocusRotationForward  mock := SpMockFocusOrderPresenter new     openWithSpec;     yourself.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter-=JUAMPI=-whenMarksChangedDo: aBlock  self property: #marks whenChangedDo: aBlock-=JUAMPI=-whenSelectionChanged: aBlock  self dropList whenSelectionChanged: aBlock-=JUAMPI=-font  ^self model font-=JUAMPI=-id  ^self model title-=JUAMPI=-initializePresenters  classListPresenter := self newList.  methodListPresenter := self newList.  textPresenter := self newCode.  textPresenter acceptBlock: [:t |  methodListPresenter selectedItem inspect ].  methodListPresenter display: #selector.  self focusOrder     add: classListPresenter;     add: methodListPresenter;     add: textPresenter-=JUAMPI=-initialize  super initialize.  maxLength := 0.  acceptOnCR := true.  isPassword := false.  self whenAcceptOnCRChangedDo: [:bool |  self changed: #acceptOnCR: with: {bool} ]-=JUAMPI=-text  ^text-=JUAMPI=-itemFilterBlock: aBlock  self deprecated: 'Use #itemFilter: instead' transformWith: '`@receiver itemFilterBlock: `@statements1' -> '`@receiver itemFilter: `@statements1'.  ^self itemFilter: aBlock-=JUAMPI=-testNotPasswordIsSetInWidget  presenter bePassword: false.  self deny: self adapter isPassword-=JUAMPI=-toolbarItemFont  ^toolbarItemFont ifNil: [ toolbarItemFont := self newToolbarItemFont ]-=JUAMPI=-testUnselectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedIndex |  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  self adapter selectIndex: 0.  self assert: selectedIndex equals: 0-=JUAMPI=-setText: text to: aWidget  super setText: (self presenter textStyler applyStyleTo: text) to: aWidget-=JUAMPI=-openChangeSetBrowser  | cs |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  cs := self selectedChangeSet ifNil: [ ^self ].  ^Smalltalk tools messageList browseClasses: (RBBrowserEnvironment new forClasses: cs changedClasses)-=JUAMPI=-action  ^action-=JUAMPI=-rightText  ^rightText-=JUAMPI=-isMultipleSelection  ^selectionMode isMultipleSelection-=JUAMPI=-widget: anObject  widget := anObject-=JUAMPI=-displayBlock  ^self model displayBlock-=JUAMPI=-contextKeyBindings: aKMCategory  contextKeyBindings := aKMCategory-=JUAMPI=-label: aString  ^label := aString-=JUAMPI=-showAllInstVars  ^self class showAllInstVars-=JUAMPI=-testSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedIndex |  presenter selection whenChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  self adapter selectIndex: 1.  self assert: selectedIndex equals: 1-=JUAMPI=-normalFillStyle  ^Color transparent-=JUAMPI=-clearFilterButton: anObject  clearFilterButton := anObject-=JUAMPI=-daysToDisplayCount  ^self maxNumberOfWeeksToDisplay * self daysInAWeek-=JUAMPI=-open: aPresenter withSpecLayout: aSpecLayout  ^self open: aPresenter withSpecLayout: aSpecLayout using: aPresenter defaultWindowPresenterClass-=JUAMPI=-styleName  ^'toolBar.label'-=JUAMPI=-handlesDoubleClick: aBoolean  handlesDoubleClick := aBoolean-=JUAMPI=-adaptToDate: aDate  self monthYearLabel label: aDate month asString.  self previousMonthButton action: [ self adaptToDate: aDate onPreviousMonth ].  self nextMonthButton action: [ self adaptToDate: aDate onNextMonth ].  self newDynamicPresentersListIn: #namesOfDaysLabels usingBuilder: self daysLabelsBuilder.  self newDynamicPresentersListIn: #daysButtons usingBuilder: (self daysButtonsBuilderFrom: aDate)-=JUAMPI=-autoAccept: aBoolean  ^self sliderInput autoAccept: aBoolean-=JUAMPI=-applyTo: aMorph  self color ifNotNil: [:aColor |  aMorph color: aColor ].  self backgroundColor ifNotNil: [:aColor |  aMorph backgroundColor: aColor ]-=JUAMPI=-testUnselectAllInWidgetNotRaisesEmptySelectionChangeEvent  | gotSelection |  presenter selection whenChangedDo: [:selection |  gotSelection := selection ].  self adapter selectIndex: 0.  self assert: gotSelection isNil-=JUAMPI=-application: anApplication  application := anApplication-=JUAMPI=-initializePresenters  form := (self instantiate: SpDemoLabeledContainer)     label: 'form';     subwidget: (self instantiate: SpDemoStandaloneFormPresenter on: self announcingObject).  resultPane := (self instantiate: SpDemoLabeledContainer)     label: 'result';     subwidget: (table := self newTable).  table     addColumn: (SpStringTableColumn title: 'Name' evaluated: #key);     addColumn: (SpStringTableColumn title: 'Value' evaluated: #value);     items: self model elements;     beResizable.  self focusOrder     add: form;     add: table-=JUAMPI=-doActivateAtIndex: index  self presenters at: index ifAbsent: [ ^self ].  activationBlock cull: ((SpSingleSelectionMode on: self)           basicSelectIndex: index;           yourself)-=JUAMPI=-from: aPresenter port: aSymbol to: anotherPresenter transform: aValuable  self from: aPresenter port: aSymbol to: anotherPresenter transform: aValuable postTransmission: nil-=JUAMPI=-sliders  ^sliders-=JUAMPI=-newSplitter  ^SpPanedResizerMorph newVertical-=JUAMPI=-presenterAt: aName ifAbsent: aBlock  ^self basicPresenters at: aName ifAbsent: [ [ self readSlotNamed: aName ] on: SlotNotFound do: aBlock ]-=JUAMPI=-add: aBlock withSpec: aSpec top: top bottom: bottom  self add: aBlock withSpec: aSpec top: top bottom: bottom left: nil right: nil-=JUAMPI=-whenResizingDo: aBlock  self announcer when: WindowResizing do: aBlock-=JUAMPI=-searchValueOf: item  ^self displayValueOf: item-=JUAMPI=-specInitializationStrategy: aStrategy  specInitializationStrategy := aStrategy-=JUAMPI=-step  self objectChanged-=JUAMPI=-updateText  self text: self text-=JUAMPI=-whenAutoDeselectChangedDo: aBlock  self deprecated: 'Should not use. This feature is not supported anymore'.  self property: #autoDeselect whenChangedDo: aBlock-=JUAMPI=-allSelectedItems  | result |  result := OrderedCollection new.  self selected ifTrue: [ result add: self ].  self children value do: [:e |  result addAll: e allSelectedItems ].  ^result-=JUAMPI=-beForText  self deprecated: 'The forCode functionality has moved to TextCodePresenter, please use it instead TextPresenter.' on: '2019-04-05' in: #Pharo8-=JUAMPI=-strongSelectionChanged: aFTStrongSelectionChanged  self presenter activatesOnDoubleClick ifFalse: [ ^self ].  self presenter doubleClickAtIndex: aFTStrongSelectionChanged selectedIndex-=JUAMPI=-testSelectMultipleIndexesRaisesSelectionChangeEventMultipleTimes  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: events equals: 2-=JUAMPI=-whenBorderWidthChanged: aBlock  self deprecated: 'Use #whenBorderWidthChangedDo: instead.' transformWith: '`@receiver whenBorderWidthChanged: `@statements' -> '`@receiver whenBorderWidthChangedDo: `@statements'.  self whenBorderWidthChangedDo: aBlock-=JUAMPI=-selectedIndexes  | selectedIndex |  selectedIndex := self widget getCurrentSelectionIndex.  ^selectedIndex = 0 ifTrue: [ #() ] ifFalse: [ {selectedIndex} ]-=JUAMPI=-searchMatching: aBlock  searchBlock := aBlock.  self enableSearch-=JUAMPI=-adapterName  ^#GridAdapter-=JUAMPI=-preserveLayoutPosition  self owner layoutPolicy preservePositionProportionOn: self owner-=JUAMPI=-selectedContacts  ^table selectedItems-=JUAMPI=-beUnselected  self setSelection: false-=JUAMPI=-classToTest  ^SpLabelledDropList-=JUAMPI=-thumbnailMorph  ^self object taskThumbnailOfSize: self thumbnailSize-=JUAMPI=-radioButtonInstanceSide  ^radioButtonInstanceSide-=JUAMPI=-genderLabel: anObject  genderLabel := anObject-=JUAMPI=-selectPage: aPage  self widgetDo: [:w |  w page: (w pageWithModel: aPage) ]-=JUAMPI=-whenActivatedDo: aBlock  activationBlock := aBlock-=JUAMPI=-defaultInitialExtent  ^400 @ 300-=JUAMPI=-close  self widget ifNotNil: [:w |  w close ]-=JUAMPI=-addLazyPage: aBlock label: aStringOrMorph  self addLazyPage: aBlock label: aStringOrMorph collapsable: false-=JUAMPI=-rightClicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: evt-=JUAMPI=-state  ^state-=JUAMPI=-whenIconChangedDo: aBlock  self property: #icon whenChangedDo: aBlock-=JUAMPI=-doubleClickFirstRowAndColumn: anAdapter  self waitUntilUIRedrawed.  anAdapter widget doubleClick: (MouseEvent new           setPosition: anAdapter widget submorphs first submorphs first bounds center;           yourself)-=JUAMPI=-notifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChanged-=JUAMPI=-initializeWidgets  input := self instantiate: SpTextInputFieldPresenter.  dropList := self instantiate: SpDropListPresenter.  self focusOrder     add: input;     add: dropList-=JUAMPI=-modelChanged  table items: self model elements-=JUAMPI=-browseSubMenu: aMenu  aMenu addGroup: [:aGroup |  aGroup addItem: [:anItem |  anItem                 name: 'Browse Full';                 action: [ self browseSelectedObject ];                 shortcut: PharoShortcuts current browseShortcut ].        aGroup addItem: [:anItem |  anItem                 name: 'Browse Class';                 action: [ self browseSelectedObjectClass ] ].        aGroup addItem: [:anItem |  anItem                 name: 'Browse Hierarchy';                 action: [ self browseSelectedObjectClassHierarchy ];                 shortcut: $h meta ] ]-=JUAMPI=-presentersInFocusOrder  ^self presenters-=JUAMPI=-unselectPath: aPath  self selection unselectPath: aPath-=JUAMPI=-windowIsOpening  isClosed := false-=JUAMPI=-size  ^self presenters size-=JUAMPI=-extent  ^self widget extent-=JUAMPI=-onActivation  ^onActivation-=JUAMPI=-pageClass  ^SpDemoRadioButtonsPresenter-=JUAMPI=-testShowColumnHeadersRaisesOneEventOnly  | count |  count := 0.  presenter whenShowColumnHeadersChangedDo: [ count := count + 1 ].  presenter showColumnHeaders.  self assert: count equals: 1-=JUAMPI=-initializePresenters  layout := SpMillerLayout newHorizontal-=JUAMPI=-property: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosure-=JUAMPI=-connectPresenters  textField acceptBlock: [:text |  self class environment at: text asSymbol ifPresent: [:class |  methodBrowser messages: class methods ] ifAbsent: [ methodBrowser messages: #() ] ]-=JUAMPI=-calculateHomogeneousRowHeights  | rowHeight |  rowHeight := 0.  morphs do: [:each |  rowHeight := rowHeight max: (self minHeightOf: each) ].  ^Array new: numRows withAll: (self baseRowHeight max: rowHeight)-=JUAMPI=-accept: text notifying: notifyer  ^self selectedMessage ifNotNil: [:message |  message methodClass compile: text classified: message protocol notifying: notifyer ]-=JUAMPI=-initializePresenters  < script: 'self new openWithSpec'>  (button := self newButton)     label: 'Choice';     action: [ text text: text text , button label , String cr ].  menu := self newMenuButton     help: 'An example menu.';     menu: [ self newExampleMenu ];     yourself.  text := self newText-=JUAMPI=-traverseInFocusOrderDo: aBlock excluding: excludes  self presentersInFocusOrder do: [:each |  each traverseInFocusOrderDo: aBlock excluding: excludes ]-=JUAMPI=-= anObject  ^super = anObject and: [ index = anObject index ]-=JUAMPI=-beExpand  self expand: true-=JUAMPI=-stateSelector  ^self state ifNil: [ nil ] ifNotNil: [ #state ]-=JUAMPI=-to: aPresenter  self toPort: aPresenter inputPortDefault-=JUAMPI=-testSelectItemOutsideRangeUnsetsSelectedItem  presenter selectItem: 40.  self assert: presenter selection selectedItem equals: nil-=JUAMPI=-setFocusOrder  self focusOrder     add: changeSorterLeft;     add: changeSorterRight-=JUAMPI=-inspect: anObject  self object: anObject.  self list selectIndex: 1.  self refresh-=JUAMPI=-updateMenu  -=JUAMPI=-model: anObject  model := anObject.  model isSortable ifTrue: [ self sortableUsing: model sortFunction ]-=JUAMPI=-newSearchInput  ^self instantiate: SpSearchInputFieldPresenter-=JUAMPI=-icon  ^icon-=JUAMPI=-aboutText  ^self model model ifNotNil: [:m |  m aboutText ]-=JUAMPI=-footnoteIcon  ^footnoteIcon-=JUAMPI=-updateView  table items: contactBook contents-=JUAMPI=-shouldRefreshItem: item fromAnnouncement: anAnnouncement  ^refreshingBlock cull: item cull: anAnnouncement cull: self-=JUAMPI=-includesPaths: aListOfPaths  ^selection includesAll: aListOfPaths-=JUAMPI=-window  ^self hasWindow ifTrue: [ self root ] ifFalse: [ nil ]-=JUAMPI=-leftFraction  ^layoutFrame leftFraction-=JUAMPI=-selectedBehavior  self flag: #TODO.  ^self behavior-=JUAMPI=-isShowColumnHeaders  ^widget isShowColumnHeaders-=JUAMPI=-useProportionalLayout  -=JUAMPI=-build  ^self buildDynamicPresenter     layout: self buildLayout;     yourself-=JUAMPI=-testUnselectUnselectedPathRaisesNoSelectionEvent  | counter |  counter := 0.  presenter     selectPath: #(1 2);     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectPath: #(2 2).  self assert: counter equals: 0-=JUAMPI=-incomingTransmission: anObject from: outPort  self subclassResponsibility-=JUAMPI=-testWhenNumberTypeChangedDo  | count result |  count := 0.  presenter whenNumberTypeChangedDo: [:value |  count := count + 1.        result := value ].  presenter beFloat.  self assert: count equals: 1.  self assert: result equals: Float-=JUAMPI=-encrypted  ^self model isPassword-=JUAMPI=-minus  ^minus-=JUAMPI=-bottomFraction: anObject  bottomFraction := anObject-=JUAMPI=-