testTransientPairLeft  | tmp1 |  self analyzer when: [:arg1 |  FLPair = arg1 class and: [ arg1 left isNil not ] ] substituteBy: [:arg1 |  arg1 copy left: nil ].  tmp1 := self resultOfSerializeAndMaterialize: (FLPair new           left: $A;           yourself).  self assert: tmp1 left isNilreadStreamDo: arg1  targetStrategy readStreamDo: [:arg2 |  ^GZipReadStream with: arg2 do: arg1 ]testOrderedCollection  self assertSerializationEqualityOf: (OrderedCollection with: 10 with: 20)testCompleteBinaryTree  | tmp1 tmp2 |  tmp2 := 2 raisedTo: 13.  tmp1 := OrderedCollection new.  1 to: tmp2 do: [:arg1 |  tmp1 add: (FLPair new                 left: 2 * arg1;                 right: 2 * arg1 + 1;                 yourself) ].  [ tmp1 size > 1 ] whileTrue: [ tmp1 := tmp1 pairsCollect: [:arg2 :arg3 |  FLPair new                 left: arg2;                 right: arg3;                 yourself ] ].  self assertSerializationEqualityOf: tmp1printOn: arg1  super printOn: arg1.  arg1 nextPutAll: '->'.  substitutions printElementsOn: arg1testClassSideCompiledMethod  | tmp1 tmp2 |  tmp1 := self newClass.  tmp1 class duringTestCompileSilently: 'm  ^ 42'.  tmp2 := self newClass.  tmp2 class duringTestCompileSilently: 'm    ^    42   '.  self assert: (tmp1 class >> #m) bytecodesHash equals: (tmp2 class >> #m) bytecodesHash.  self deny: tmp1 class >> #m identicalTo: tmp2 class >> #m.  materializationEnvironment at: tmp1 name put: tmp2.  self assert: (self resultOfSerializeAndMaterialize: tmp1 class >> #m) identicalTo: tmp2 class >> #mtestProxyByTargetAnalisysIsPropagated  | tmp1 tmp2 tmp3 |  self flag: #pharoTodo.  tmp1 := (self newSubclassOf: Object instanceVariableNames: 'target' classVariableNames: '')     duringTestCompileSilently: 'target: x  target := x';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: target';     yourself.  tmp3 := FLPair new.  tmp3 left: 6.  tmp3 right: 'foo'.  tmp1 new     target: tmp3;     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp3.  self assert: tmp2 left equals: 6.  self assert: tmp2 right equals: 'foo'expectedFailures  ^#(testConsiderCustomWideSymbolGlobal testWideStringGlobal testWideStringClassName)testConsiderCustomGlobal  self analyzer considerGlobal: #FLGlobalVariableForTesting.  serializationEnvironment at: #FLGlobalVariableForTesting put: 42.  materializationEnvironment at: #FLGlobalVariableForTesting put: 7.  self assert: (self resultOfSerializeAndMaterialize: 42) equals: 7testSet  | tmp1 tmp2 |  tmp1 := Set new.  tmp1 add: 10.  tmp1 add: 20.  tmp1 add: 30.  tmp1 add: 30.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp1 equals: tmp2.  self assert: tmp2 size equals: 3.  self assert: (tmp2 includes: 10).  self assert: (tmp2 includes: 20).  self assert: (tmp2 includes: 30)materializeReferencesOf: arg1 with: arg2  arg2 nextEncodedPositiveInteger timesRepeat: [ arg1 add: arg2 nextEncodedReference ]testClassSideObsolete  | tmp1 |  tmp1 := self newClassOrTrait.  self removeFromSystem: tmp1.  self should: [ self serialize: tmp1 ] raise: FLObsolete whoseDescriptionIncludes: tmp1 name description: 'Should raise an error when serializing as global an obsolete class or trait.'hash  ^idreference: arg1  ^reference := arg1deleteFileNamed: arg1  ((Smalltalk at: #File) named: arg1) deletetearDown  #('demo.fuel' 'numbers.fuel' 'number.fuel.zip' 'example.FL') do: [:arg1 |  self deleteFileNamed: arg1 ].  testingEnvironment removeKey: #GlobalSet1 ifAbsent: [  ].  testingEnvironment removeKey: #GlobalSet2 ifAbsent: [  ].  super tearDownincludes: arg1  arg1 ifNil: [ ^includesNil ].  ^(array at: arg1 largeIdentityHash \\ 4096 + 1) ifNil: [ false ] ifNotNil: [:arg2 |  arg2 fuelPointsTo: arg1 ]initializeWith: arg1 root: arg2 analyzer: arg3  self initialize.  encoder := arg1.  root := arg2 fuelReplacement.  analyzer := arg3serializeInstancesStepWith: arg1  testSerializingShortDelay  | tmp1 |  tmp1 := [ 2 timesRepeat: [ | tmp2 |        tmp2 := Delay forMilliseconds: 50.        tmp2 wait ] ] forkAt: Processor userBackgroundPriority.  self shouldnt: [ self serialize: tmp1 ] raise: FLObjectNotFoundfileNamed: arg1 writeStreamDo: arg2  ^self subclassResponsibilityserializeReferencesOf: arg1 with: arg2  (self references at: arg1 ifAbsent: [ ^self ]) do: [:arg3 |  arg2 encodeReferenceTo: arg3 ]testSmallIntegerMinValue  self assertSerializationIdentityOf: SmallInteger minValfuelAccept: arg1  ^arg1 visitSubstitution: self by: niluseBinaryFileStream  streamFactory := FLFileStreamStrategy newWithBinaryFileStreamvisitBytesObject: arg1  self mapAndTraceByObjectClass: arg1 to: FLByteObjectClusternextPutAll: arg1  self flushBufferIfFull.  arg1 size <= self bufferFreeSize ifTrue: [ self buffer replaceFrom: position + 1 to: position + arg1 size with: arg1.        position := position + arg1 size ] ifFalse: [ self flushBuffer.        arg1 size > (self buffer size / 2) ifTrue: [ stream nextPutAll: arg1 ] ifFalse: [ self nextPutAll: arg1 ] ]testDate  self assertSerializationEqualityOf: (Date fromDays: 37023).  self assertSerializationEqualityOf: Date today.  self assertSerializationEqualityOf: (Date year: 3050 month: 12 day: 31).  self assertSerializationEqualityOf: (Date year: 1600 month: 12 day: 31)visitRectangle: arg1  self mapAndTraceByClusterName: arg1 to: FLRectangleClustervisitSmallInteger: arg1  self mapAndTraceByClusterName: arg1 to: (self clusterClassForSmallInteger: arg1)fileStreamClass  ^fileStreamClassmaterializeInstancesStepWith: arg1  testByteArrays  self assertSerializationEqualityOf: {#[1 2 3 4 5 6] .         #[1 2 3 4 5 6] .         #[7 8 9 10 11 12] .         #[7 8 9 10 11 12]}.  self assertSerializationEqualityOf: (ByteArray with: 10 with: 20 with: 30).  self assertSerializationEqualityOf: ByteArray new.  self assertSerializationEqualityOf: (ByteArray new: 100).  self assertSerializationEqualityOf: (0 to: 255) asByteArraymaterializeInstanceWith: arg1  ^0 @ 0id  ^idpostCopy  super postCopy.  keys := keys copy.  values := values copy.  1 to: 4096 do: [:arg1 |  (keys at: arg1) ifNotNil: [:arg2 |  keys at: arg1 put: arg2 copy.              values at: arg1 put: (values at: arg1) copy ] ]initializeAnalyzing  self initializemapAndTrace: arg1  self subclassResponsibilitytestWideString  self shouldnt: [ self assertSerializationEqualityOf: 'aString' asWideString.        self assertSerializationEqualityOf: (WideString streamContents: [:arg1 |  2000 timesRepeat: [ arg1 nextPut: (256 to: 1000) atRandom asCharacter ] ]) ] raise: ErrorvisitMetaclass: arg1  self mapAndTraceByClusterName: arg1 to: FLGlobalClassSideClustertestContextWithNilPc  | tmp1 tmp2 |  tmp1 := Context newForMethod: FLPair >> #method1.  tmp1 initializeWith: nil stackPtr: 1 method: FLPair >> #method1 receiver: (FLPair new           right: 4;           left: 2) sender: nil.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp2 in: selfdecoder  ^decodernewSubclassOf: arg1 instanceVariableNames: arg2 classVariableNames: arg3  ^self classFactory silentlyNewSubclassOf: arg1 instanceVariableNames: arg2 classVariableNames: arg3serializeInstancesStepWith: arg1  initializeClassNamed: arg1 toClass: arg2 variables: arg3  self initialize.  sourceClassName := arg1.  targetClass := arg2.  variables := arg3testDemo  | tmp1 tmp2 |  tmp1 := Array with: 'a string' with: Smalltalk with: [ Smalltalk vm.        'a string' ].  FLSerializer serialize: tmp1 toFileNamed: 'example.FL'.  tmp2 := FLMaterializer materializeFromFileNamed: 'example.FL'.  [ tmp1 ~~ tmp2 ] assert.  [ tmp1 first ~~ tmp2 first ] assert.  [ tmp1 first = tmp2 first ] assert.  [ tmp1 second == tmp2 second ] assert.  self assert: tmp2 third value equals: 'a string'materializeInstanceWith: arg1  ^arg1 nextEncodedUint8 negatedsetDefaultMaterialization  materializationFactory := [:arg1 |  (FLMaterialization with: arg1)     run;     yourself ]clusterClassForSmallInteger: arg1  arg1 >= 0 ifTrue: [ arg1 <= 255 ifTrue: [ ^FLPositive8SmallIntegerCluster ].        arg1 <= 65535 ifTrue: [ ^FLPositive16SmallIntegerCluster ].        arg1 <= 16777215 ifTrue: [ ^FLPositive24SmallIntegerCluster ].        arg1 <= 4294967295 ifTrue: [ ^FLPositive32SmallIntegerCluster ].        arg1 <= 1152921504606846975 ifTrue: [ ^FLPositive64SmallIntegerCluster ] ].  arg1 >= -128 ifTrue: [ ^FLNegative8SmallIntegerCluster ].  arg1 >= -32768 ifTrue: [ ^FLNegative16SmallIntegerCluster ].  arg1 >= -8388608 ifTrue: [ ^FLNegative24SmallIntegerCluster ].  arg1 >= -2147483648 ifTrue: [ ^FLNegative32SmallIntegerCluster ].  arg1 >= -1152921504606846976 ifTrue: [ ^FLNegative64SmallIntegerCluster ].  self error: 'SmallInteger is out of range'testNextIndexPut  | tmp1 tmp2 |  tmp2 := #() writeStream.  tmp1 := self indexStreamOn: tmp2 digits: 1.  tmp1 nextIndexPut: 0.  tmp1 nextIndexPut: 1testVariableInsertion  | tmp1 tmp2 tmp3 |  tmp1 := self newClassWithInstanceVariableNames: 'left right'.  tmp2 := tmp1 new.  tmp2 instVarAt: 1 put: $A.  tmp2 instVarAt: 2 put: $B.  self serialize: tmp2.  self redefined: tmp1 with: 'left middle right'.  tmp3 := self materialized.  self assert: $A equals: (tmp3 instVarAt: 1).  self assert: nil equals: (tmp3 instVarAt: 2).  self assert: $B equals: (tmp3 instVarAt: 3)testLargePositiveInteger  self assertSerializationEqualityOf: 354314316134313999999999.  self assertSerializationEqualityOf: 100 factorialtestPoint  self assertSerializationEqualityOf: 10 @ 20.  self assertSerializationEqualityOf: -10 @ 20.  self assertSerializationEqualityOf: -10 @ -20.  self assertSerializationEqualityOf: 1.1 @ 2.2.  self assertSerializationEqualityOf: 1.1 @ -2.2copySelector: arg1 ofMethod: arg2 toClass: arg3  arg3 addAndClassifySelector: arg1 withMethod: arg2 copy inProtocol: self extensionProtocolNamedecodeYourself  | tmp1 |  tmp1 := self nextEncodedPositiveInteger.  indexStream := FLIndexStream on: stream digits: tmp1 bytesCount.  objects := Array new: tmp1.  objectsWriteStream := WriteStream on: objects.  isBigEndian := self nextEncodedPositiveIntegerfirstInMapperChain  ^self mappers firsttestWordArray  self assertSerializationEqualityOf: (WordArray with: 10 with: 20)addPostMaterializationAction: arg1  arg1 isClean ifFalse: [ self error: 'Post materializaton actions have to be clean closures. For more details see method BlocKClosure >> #isClean' ].  postMaterializationActions add: arg1materializeReferencesStepWith: arg1  objects do: [:arg2 |  self materializeLiteralsTo: arg2 with: arg1 ]visitCompiledMethod: arg1  (arg1 isInstalled not or: [ arg1 isDoIt ]) ifTrue: [ self mapAndTraceByClusterName: arg1 to: FLCompiledMethodCluster ] ifFalse: [ self mapAndTraceByClusterName: arg1 to: FLGlobalCompiledMethodCluster ]serializeInstance: arg1 with: arg2  arg2 encodePositiveInteger: arg1 basicSize.  arg2 encodeBytes: arg1setUp  super setUp.  FLSingletonMock resetmaterializeReferencesOf: arg1 with: arg2  arg1 setX: arg2 nextEncodedReference setY: arg2 nextEncodedReferenceexecutePreMaterializationActions  preMaterializationActions do: [:arg1 |  arg1 value ]testPop  | tmp1 |  tmp1 := FLSimpleStack new.  tmp1 push: 1.  tmp1 pop.  self assert: tmp1 isEmptytestSetWithNil  self assertSerializationEqualityOf: (Set with: nil)testClassSidePreservesIdentity  self assertSerializationIdentityOf: self newClassOrTrait classSidematerializeReferencesOf: arg1 with: arg2  self subclassResponsibilitytestDateOffsets  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := TimeZone timeZones third.  tmp2 := TimeZone timeZones fourth.  DateAndTime localTimeZone: tmp1.  self assert: DateAndTime now offset equals: 1 hour.  tmp4 := Date fromDays: 37023.  self assert: tmp4 start offset equals: 0 hours.  tmp3 := self resultOfSerializeAndMaterialize: tmp4.  self assert: tmp3 start offset equals: 0 hours.  DateAndTime localTimeZone: tmp2.  self assert: DateAndTime now offset equals: 2 hours.  tmp4 := Date fromDays: 37023.  self assert: tmp4 start offset equals: 0 hours.  tmp3 := self resultOfSerializeAndMaterialize: tmp4.  self assert: tmp3 start offset equals: 0 hoursmaterializeGlobalAssociationFrom: arg1  | tmp1 |  tmp1 := arg1 nextEncodedString asSymbol.  ^arg1 globalEnvironment associationAt: tmp1 ifAbsent: [ FLGlobalNotFound signalWithName: tmp1 ]encodeReferenceTo: arg1  | tmp1 |  tmp1 := substitutionIndexes at: arg1 ifAbsent: [ objectsIndexes at: arg1 ifAbsent: [ FLObjectNotFound signalWith: arg1 ] ].  indexStream nextIndexPut: tmp1testRemoteString  | tmp1 tmp2 |  tmp1 := SourceFiles remoteStringAt: thisContext method sourcePointer.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp1 string equals: tmp2 string.  self assert: tmp1 sourcePointer identicalTo: tmp2 sourcePointerclassVariableForTesting  ^ClassVariableForTestingtearDown  DateAndTime localTimeZone: currentTimeZone.  super tearDownnewAnalyzingCollection  ^OrderedCollection newinitializeOn: arg1 globalEnvironment: arg2  self initialize.  stream := FLBufferedWriteStream on: arg1.  globalEnvironment := arg2tearDown  materialized  ^FLMaterializer materializeFromByteArray: byteArrayverifySignatureFrom: arg1  | tmp1 |  tmp1 := ByteArray new: self signature size.  arg1 nextEncodedBytesInto: tmp1.  self signature asByteArray = tmp1 ifFalse: [ FLBadSignature signalCurrentSignature: self signature streamSignature: tmp1 ]materializeInstanceWith: arg1  ^self subclassResponsibilityreferencesOf: arg1 do: arg2  arg2 value: arg1 size.  arg1 do: [:arg3 |  arg2 value: arg3 ]setTestTimeLimitFor: arg1 to: arg2  arg1 timeLimit: arg2testSystemDictionary  self assertSerializationEqualityOf: SystemDictionary newtestString  self assertSerializationEqualityOf: 'testString'.  self assertSerializationEqualityOf: 'Hi, I''m String-object'.  self assertSerializationEqualityOf: String new.  self assertSerializationEqualityOf: (0 to: 255) asByteArray asStringserializeInstance: arg1 with: arg2  arg2 encodeUint8: arg1