trailerStep  encoder encodeReferenceTo: rootanalysisFor: arg1  ^analysisFactory value: arg1clusterReferencesDo: arg1  arg1 value: theClasstestSmalltalkGlobals  self assertSerializationIdentityOf: Smalltalk globalsmaterializer  ^materializertestExceptions  | tmp1 |  tmp1 := Error new messageText: 'sample error'.  self assert: (self resultOfSerializeAndMaterialize: tmp1) messageText equals: tmp1 messageText.  tmp1 := Warning new messageText: 'sample warning'.  self assert: (self resultOfSerializeAndMaterialize: tmp1) messageText equals: tmp1 messageText.  tmp1 := Notification new messageText: 'sample notification'.  self assert: (self resultOfSerializeAndMaterialize: tmp1) messageText equals: tmp1 messageTextobjects  ^encoder objectsIndexes keystearDown  self     tearDownClassFactory;     tearDownGlobalVariables.  self streamFactory tearDown.  self tearDownInstanceVariables.  super tearDowntestTrue  self assertSerializationIdentityOf: trueencodeString: arg1  | tmp1 |  (tmp1 := arg1 size) < 192 ifTrue: [ stream nextPut: tmp1 ] ifFalse: [ stream nextPut: (tmp1 byteAt: 4) + 192.        stream nextPut: (tmp1 byteAt: 3).        stream nextPut: (tmp1 byteAt: 2).        stream nextPut: (tmp1 byteAt: 1) ].  stream nextBytesPutAll: arg1serializeInstance: arg1 with: arg2  arg2 encodeUint32: arg1deserialize: arg1  ^FLMaterializer materializeFromByteArray: arg1nextEncodedClusterClass  ^self class environment at: self nextEncodedString asSymboltargetClass  ^targetClassclusters  ^self clusterBuckets flatCollect: [:arg1 |  arg1 ]referencesOf: arg1 do: arg2  arg1 fuelPrepare.  1 to: arg1 numLiterals do: [:arg3 |  arg2 value: (arg1 literalAt: arg3) ]serializeOn: arg1  arg1 encodeByte: notIgnoredVariables size.  notIgnoredVariables do: [:arg2 |  arg1 encodeString: arg2 ]addIfNotPresent: arg1 ifPresentDo: arg2  | tmp1 |  arg1 ifNil: [ includesNil ifFalse: [ includesNil := true.              tally := tally + 1 ].        ^arg1 ].  (array at: (tmp1 := arg1 largeIdentityHash \\ 4096 + 1)) ifNil: [ array at: tmp1 put: (Array with: arg1).        tallies at: tmp1 put: 1.        tally := tally + 1 ] ifNotNil: [:arg3 |  (arg3 fuelPointsTo: arg1) ifTrue: [ arg2 value ] ifFalse: [ | tmp2 |              tally := tally + 1.              arg3 size < (tmp2 := (tallies at: tmp1) + 1) ifFalse: [ arg3 at: tmp2 put: arg1 ] ifTrue: [ | tmp3 |                    tmp3 := Array new: arg3 size * 2.                    tmp3                       replaceFrom: 1 to: arg3 size with: arg3 startingAt: 1;                       at: tmp2 put: arg1.                    array at: tmp1 put: tmp3 ].              tallies at: tmp1 put: tmp2 ] ].  ^arg1registerIndexesOn: arg1  self flag: #pharoTodo.  objects := objects asIdentitySet.  super registerIndexesOn: arg1clusterMaterializeStepWith: arg1  fuelAfterMaterialization  self become: contentstestAvoidRecursion  | tmp1 |  self analyzer when: [:arg1 |  arg1 < 10 ] substituteBy: [:arg1 |  arg1 + 1 ].  tmp1 := self resultOfSerializeAndMaterialize: 1.  self assert: tmp1 equals: 2testBlockClosureWithSelfSend  | tmp1 tmp2 |  tmp1 := self class blockClosureWithSelfSend.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp2 in: self.  self assert: tmp2 value equals: tmp1 valuematerializeInstanceWith: arg1  | tmp1 tmp2 |  tmp2 := arg1 nextEncodedPositiveInteger.  tmp1 := theClass basicNew: tmp2.  arg1 nextEncodedWordsInto: tmp1.  arg1 isBigEndian = FLPlatform current isBigEndian asBit ifTrue: [ ^tmp1 ] ifFalse: [ ^self swapBytesOf: tmp1 ]testSetWithSetElement  self assertSerializationEqualityOf: (Set with: (CollectionElement with: 3))serializeReferencesStepWith: arg1  objects do: [:arg2 |  self serializeReferencesOf: arg2 with: arg1 ]newClassWithInstanceVariableNames: arg1 superclass: arg2  ^self newSubclassOf: arg2 instanceVariableNames: arg1 classVariableNames: ''serializationOf: arg1  self streamFactory writeStreamDo: [:arg2 |  ^serializer serialize: arg1 on: arg2 ]printNameOn: arg1  super printNameOn: arg1.  arg1 nextPut: $[.  theClass printOn: arg1.  arg1 nextPut: $]version: arg1  version := arg1left: arg1  left := arg1testClassRename  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self newClassWithInstanceVariableNames: 'x y'.  tmp4 := tmp1 name.  tmp2 := tmp1 new.  tmp2 instVarNamed: 'x' put: 7.  tmp2 instVarNamed: 'y' put: 11.  self serialize: tmp2.  tmp1 renameSilently: (tmp4 , 'Renamed') asSymbol.  self materializer migrateClassNamed: tmp4 toClass: tmp1.  tmp3 := self materialized.  self assert: (tmp3 instVarNamed: 'x') equals: 7.  self assert: (tmp3 instVarNamed: 'y') equals: 11serializeInstancesStepWith: arg1  testEmptyArray  self assertSerializationEqualityOf: #()testColor  self assertSerializationEqualityOf: Color blue.  self assertSerializationEqualityOf: Color blackprivateMappers  ^OrderedCollection new     addAll: self globalMappers;     add: self generalMapper;     reduceRight: [:arg1 :arg2 |  arg1 next: arg2 ];     yourselfvisitMetaclassForTraits: arg1  self mapAndTraceByClusterName: arg1 to: FLGlobalClassSideClusterclusterInstancesStepOf: arg1  encoder encodeClusterClass: arg1 class.  arg1 clusterSerializeStepWith: self.  arg1 serializeInstancesStepWith: encoder.  arg1 serializePostInstancesStepWith: encodertestFileStream  | tmp1 |  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:arg1 |  FLSerializer newDefault serialize: 'stringToSerialize' on: arg1 ].  tmp1 := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:arg1 |  (FLMaterializer newDefault materializeFrom: arg1) root ].  self assert: tmp1 equals: 'stringToSerialize'swapBytesOf: arg1  Bitmap swapBytesIn: arg1 from: 1 to: arg1 basicSize.  ^arg1right: arg1  right := arg1mapAndTrace: arg1  firstMapper mapAndTrace: arg1 fuelReplacementtestDuration  self assertSerializationEqualityOf: 123 seconds.  self assertSerializationEqualityOf: -123 seconds.  self assertSerializationEqualityOf: (Duration seconds: 3 nanoSeconds: 35)afterMaterializationStepWith: arg1  objects do: [:arg2 |  arg2 fuelAfterMaterialization ]deleteFileNamed: arg1  self subclassResponsibilityat: arg1 put: arg2  | tmp1 |  (keys at: (tmp1 := arg1 largeIdentityHash \\ 4096 + 1)) ifNil: [ keys at: tmp1 put: (Array with: arg1).        values at: tmp1 put: (Array with: arg2).        tallies at: tmp1 put: 1.        tally := tally + 1 ] ifNotNil: [:arg3 |  | tmp2 |        1 to: (tallies at: tmp1) do: [:arg4 |  (arg3 at: arg4) == arg1 ifTrue: [ ^(values at: tmp1) at: arg4 put: arg2 ] ].        tally := tally + 1.        arg3 size < (tmp2 := (tallies at: tmp1) + 1) ifFalse: [ arg3 at: tmp2 put: arg1.              (values at: tmp1) at: tmp2 put: arg2 ] ifTrue: [ | tmp3 |              (tmp3 := Array new: arg3 size * 2)                 replaceFrom: 1 to: arg3 size with: arg3 startingAt: 1;                 at: tmp2 put: arg1.              keys at: tmp1 put: tmp3.              (tmp3 := Array new: arg3 size * 2)                 replaceFrom: 1 to: arg3 size with: (values at: tmp1) startingAt: 1;                 at: tmp2 put: arg2.              values at: tmp1 put: tmp3 ].        tallies at: tmp1 put: tmp2 ].  ^arg2useNotInstalled  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: false.  theCompiledMethod := theClass methodNamed: #m.  theClass methodDict removeKey: #mreferencesOf: arg1 do: arg2  testWideStringClassName  | tmp1 tmp2 |  tmp2 := 'Foox' asWideString     at: 4 put: (Character value: 265);     yourself.  tmp1 := Class new     setName: tmp2;     yourself.  [ testingEnvironment at: tmp1 name put: tmp1.  self shouldnt: [ self resultOfSerializeAndMaterialize: tmp1 ] raise: Error ] ensure: [ testingEnvironment removeKey: tmp1 name ]add: arg1 traceWith: arg2  objects addIfNotPresent: arg1 ifPresentDo: [ ^self ].  self referencesOf: arg1 do: [:arg3 |  | tmp1 |        tmp1 := arg3 fuelReplacement.        self addReferenceFrom: arg1 to: tmp1.        arg2 trace: tmp1 ]testDictionaryRehash  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := Dictionary new.  tmp2 := FLPerson new id: 1.  tmp3 := FLPerson new id: 5.  tmp4 := FLPerson new id: 8.  tmp1     at: tmp2 put: tmp2;     at: tmp3 put: tmp3;     at: tmp4 put: tmp4.  self assert: (tmp1 at: tmp2) equals: tmp2.  self assert: (tmp1 at: tmp3) equals: tmp3.  self assert: (tmp1 at: tmp4) equals: tmp4.  tmp5 := self resultOfSerializeAndMaterialize: tmp1.  tmp6 := tmp5 keys detect: [:arg1 |  arg1 id = tmp2 id ].  tmp6 id: 3.  tmp5 rehash.  self assert: (tmp5 includesKey: tmp6)install  self targetClass ifNil: [ ^self ].  self isSource ifTrue: [ ^self compileInTarget ].  self selector = self method selector ifFalse: [ ^self renameAndCompileInTarget ].  self copyToTargetmaterializeInstanceWith: arg1  | tmp1 tmp2 |  tmp1 := (self materializeGlobalAssociationFrom: arg1) value.  tmp2 := arg1 nextEncodedString asSymbol.  ^tmp1 perform: tmp2newAnalyzingCollection  ^OrderedCollection newreferencesStep  clusters do: [:arg1 |  arg1 materializeReferencesStepWith: decoder ]testAvoidRecursion  | tmp1 tmp2 |  tmp2 := FLClassWithRecursiveSubstitution new index: 1.  tmp1 := self resultOfSerializeAndMaterialize: tmp2.  self assert: tmp1 index equals: 2initializeOn: arg1 migrations: arg2 globalEnvironment: arg3  self initialize.  stream := arg1.  migrations := arg2.  globalEnvironment := arg3testGlobalNotFound  self should: [ self resultOfSerializeAndMaterialize: FLGlobalSendNotPresentMock new ] raise: FLGlobalNotFound whoseDescriptionIncludes: #FLKeyNotPresentInSmalltalks description: 'Should raise an error when global name is not present in Smalltalks globals.'stream: arg1  stream := arg1afterMaterializationStepWith: arg1  objects do: [:arg2 |  arg2 fuelAfterMaterialization ]initializeAnalyzing  super initializeAnalyzing.  substitutions := IdentityDictionary new.  substitutes := IdentitySet newtestSubstituteByItself  | tmp1 tmp2 |  tmp1 := (self newSubclassOf: Object instanceVariableNames: '' classVariableNames: '')     duringTestCompileSilently: 'fuelAccept: aMapper  			^aMapper 				visitSubstitution: self by: self 				onRecursionDo: [super fuelAccept: aMapper]';     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp1 newnextEncodedBytesInto: arg1  stream next: arg1 basicSize into: arg1initialize  super initialize.  keys := Array new: 4096.  values := Array new: 4096testOneIgnoredVariable  | tmp1 tmp2 tmp3 |  tmp3 := self newClassWithInstanceVariableNames: 'a b c'.  tmp3 class duringTestCompileSilently: 'fuelIgnoredInstanceVariableNames ^#(b)'.  tmp1 := tmp3 new     instVarAt: 1 put: $A;     instVarAt: 2 put: $B;     instVarAt: 3 put: $C;     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: $A equals: (tmp2 instVarAt: 1).  self assert: nil equals: (tmp2 instVarAt: 2).  self assert: $C equals: (tmp2 instVarAt: 3)fuelAccept: arg1  arg1 visitNotSerializable: selfmaterializeInstanceWith: arg1  ^arg1 nextEncodedUint32 negatedreadStreamDo: arg1  ^self fileStreamClass oldFileNamed: self fileName do: [:arg2 |  arg1 value: arg2 binary ]materializedObjects  ^self materialization objectstestDoIt  | tmp1 |  FLPlatform current setTestTimeLimitFor: self to: 30 seconds.  [ Smalltalk compiler evaluate: 'self error' ] on: Error do: [:arg1 |  tmp1 := arg1 signalerContext copyStack ].  self serialize: tmp1encodeInt32: arg1  | tmp1 |  tmp1 := arg1 < 0 ifTrue: [ (0 - arg1) bitInvert32 + 1 ] ifFalse: [ arg1 ].  1 to: 4 do: [:arg2 |  stream nextPut: (tmp1 byteAt: 5 - arg2) ]ignoreMe  ^ignoreMe := truecopyToTarget  FLPlatform current addAndClassifySelector: self selector inClass: self targetClass withMethod: self method copy inProtocol: self extensionProtocolNameversion  ^versiontestGlobalClassNotFound  self serialize: Integer.  self should: [ self materialization ] raise: FLClassNotFound description: 'Raise an error since the class is not present in materialization global environment'testFileShortcuts  | tmp1 |  FLSerializer serialize: 'stringToSerialize' toFileNamed: 'demo.fuel'.  tmp1 := FLMaterializer materializeFromFileNamed: 'demo.fuel'.  self assert: tmp1 equals: 'stringToSerialize'testIsEmpty  self assert: FLSimpleStack new isEmptyisPharo  ^falseselector  ^selectorvisitSimpleCollection: arg1  self mapAndTraceByObjectClass: arg1 to: FLSimpleCollectionClustertestBasic  | tmp1 |  self deny: FLGlobalSendMock newInstanceToSerialize equals: FLGlobalSendMock newInstanceToMaterialize.  tmp1 := self resultOfSerializeAndMaterialize: FLGlobalSendMock newInstanceToSerialize.  self assert: FLGlobalSendMock newInstanceToMaterialize equals: tmp1analyzer: arg1  analyzer := arg1clusterInstancesStep  | tmp1 |  tmp1 := decoder nextEncodedClusterClass newMaterializing.  tmp1 clusterMaterializeStepWith: self.  tmp1 materializeInstancesStepWith: decoder.  self registerAll: tmp1 objects.  tmp1 materializePostInstancesStepWith: decoder.  clusters add: tmp1testWeakWithStrongReferenceFromGraph  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := 11.  tmp4 := 'something'.  tmp1 := WeakArray with: tmp3 with: tmp4.  tmp2 := OrderedCollection with: 40 with: 'aaaa' with: tmp1 with: tmp4.  tmp5 := self resultOfSerializeAndMaterialize: tmp2.  self assert: (tmp5 at: 3) first isNil.  self assert: (tmp5 at: 3) second equals: tmp4.  self deny: (self serializationOf: tmp2 includes: 11).  self assert: (self serializationOf: tmp2 includes: tmp4)setUp  super setUp.  self useBinaryFileStreamtestSingletonMaterializationEnforced  | tmp1 tmp2 |  tmp1 := FLSingletonMockEnforced instance.  tmp1 reference: 'a reference'.  self assert: tmp1 equals: FLSingletonMockEnforced instance.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp2 identicalTo: tmp1.  self deny: tmp2 reference isNil.  self assert: tmp2 reference identicalTo: tmp1 reference.  FLSingletonMock resetextensionProtocolName  ^FLPlatform extensionProtocolNametestCapacity  | tmp1 |  tmp1 := FLSimpleStack new: 3.  self assert: 3 equals: tmp1 capacity.  tmp1 := FLSimpleStack new: 5.  self assert: 5 equals: tmp1 capacitytestWriteStream  | tmp1 tmp2 |  tmp1 := WriteStream on: (ByteArray new: 1).  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 nextPut: 1.  self assert: 1 equals: tmp1 size.  self assert: 0 equals: tmp2 size.  tmp2 nextPut: 2.  self assert: (Array with: 2) equals: tmp2 contents asArrayinitializeMaterializingFrom: arg1  notIgnoredVariables := (1 to: arg1 nextEncodedByte) collect: [:arg2 |  arg1 nextEncodedString ].  mapping := notIgnoredVariables collect: [:arg3 |  theClass instVarIndexFor: arg3 ifAbsent: [ nil ] ]testSymbol  self assertSerializationIdentityOf: #testSymbol.  self assertSerializationIdentityOf: #with:with:with:with:.  self assertSerializationIdentityOf: #'hello there'writeStreamDo: arg1  inMemoryStream := MultiByteBinaryOrTextStream on: ''.  ^arg1 value: inMemoryStream binaryisBigEndian  ^self subclassResponsibilityreferencesOf: arg1 do: arg2  variablesMapping referencesOf: arg1 do: arg2testMethodDictionary  self resultOfSerializeAndMaterializeMethodDictionary: FLPair methodDicttestClassSideMethodNotFoundAfterRemoval  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 classSide duringTestCompileSilently: 'you'.  self serialize: tmp1 classSide >> #you.  tmp1 classSide removeSelectorSilently: #you.  self should: [ self materialized ] raise: FLMethodNotFound whoseDescriptionIncludes: tmp1 classSide printString description: 'Should raise an error when method is not present.'addAndClassifySelector: arg1 inClass: arg2 withMethod: arg3 inProtocol: arg4  self subclassResponsibilityobjects  self subclassResponsibilitytestInstanceOfAnObsoleteClass  | tmp1 tmp2 |  tmp1 := self newClassOrTrait.  tmp2 := self newInstanceFrom: tmp1.  self removeFromSystem: tmp1.  self should: [ self serialize: tmp2 ] raise: FLObsolete whoseDescriptionIncludes: tmp1 name description: 'Should raise an error when serializing as global an obsolete class.'nextPut: arg1  self flushBufferIfFull.  position := position + 1.  self buffer at: position put: arg1method: arg1  method := arg1serialize: arg1 on: arg2  FLEncoder on: arg2 globalEnvironment: self analyzer globalEnvironment do: [:arg3 |  self encodeSignatureWith: arg3.        self encodeVersionWith: arg3.        self encodeHeaderWith: arg3.        ^self serializationFactory value: arg1 value: arg3 ]objectCount: arg1  objectCount := arg1.  objectsIndexes := FLLargeIdentityDictionary new.  substitutionIndexes := FLLargeIdentityDictionary new.  indexStream := FLIndexStream on: stream digits: arg1 bytesCountserializeReferencesStepWith: arg1  testBlockClosureWithTempVariableRead  | tmp1 tmp2 |  tmp1 := self class blockClosureWithTempVariableRead.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp2 in: self.  self assert: tmp2 value equals: 'TEST'testPreservesIdentity  self assertSerializationIdentityOf: self newClassOrTraitrenameAndCompileInTarget  | tmp1 |  tmp1 := FLPlatform current renamedMethodCopyOf: self method selector: self selector.  FLPlatform current silentlyAddAndClassifySelector: self selector inClass: self targetClass withMethod: tmp1 inProtocol: self extensionProtocolNametestAssociationWithWeak  | tmp1 tmp2 tmp3 |  tmp1 := FLWeakClassMock new: 1.  tmp1 instVar1: 'nonWeak'.  tmp1 basicAt: 1 put: 'weak'.  tmp2 := Association key: #foo value: tmp1.  tmp3 := self resultOfSerializeAndMaterialize: tmp2.  self assert: tmp3 value instVar1 isNil not.  self assert: (tmp3 value basicAt: 1) isNil.  self assert: tmp3 key equals: #footestClassSideMethodPreservesIdentity  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 classSide duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: tmp1 classSide >> #younextIndex  | tmp1 |  tmp1 := 0.  1 to: digits do: [:arg1 |  tmp1 := (tmp1 bitShift: 8) bitOr: stream next ].  ^tmp1serialize: arg1  ^self serialize: arg1 on: streamtestSubstitute: arg1 inPresenceOf: arg2  | tmp1 |  self analyzer when: [:arg3 |  arg3 == arg1 ] substituteBy: [:arg3 |  424242 ].  tmp1 := self resultOfSerializeAndMaterialize: {arg1 .         arg2}.  self assert: tmp1 first equals: 424242.  self assert: tmp1 second equals: arg2mappers  ^OrderedCollection new     addAll: self pluggableSubstitutionMappers;     addAll: self globalMappers;     add: self generalMapper;     reduceRight: [:arg1 :arg2 |  arg1 next: arg2 ];     yourselftestWideString  | tmp1 |  tmp1 := OrderedCollection new.  600 timesRepeat: [ tmp1 add: (WideString streamContents: [:arg1 |  600 timesRepeat: [ arg1 nextPut: (256 to: 1000) atRandom asCharacter ] ]) ].  self shouldnt: [ self assertSerializationEqualityOf: tmp1 ] raise: ErrortestBlockClosureWithClassVariableRead  | tmp1 tmp2 |  ClassVariableForTesting := nil.  tmp1 := [ ClassVariableForTesting ].  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp2 in: self.  ClassVariableForTesting := true.  self assert: tmp2 value.  ClassVariableForTesting := false.  self deny: tmp2 valuerenamedMethodCopyOf: arg1 selector: arg2  ^self subclassResponsibilitytestNotFoundAfterRemoval  | tmp1 |  tmp1 := self newClassOrTrait.  self serialize: tmp1.  self removeFromSystem: tmp1.  self should: [ self materialized ] raise: FLClassNotFoundobjects  ^objectsnewInstanceFrom: arg1  | tmp1 |  tmp1 := self newClass.  testingEnvironment at: arg1 name put: arg1.  tmp1 addToComposition: arg1.  ^tmp1 newserializeReferencesStepWith: arg1  objects do: [:arg2 |  self serializeReferencesOf: arg2 with: arg1 ]bufferFreeSize  ^buffer size - positionvisitSubstitution: arg1 by: arg2 onRecursionDo: arg3  | tmp1 |  tmp1 := self clusterKeyedByClusterName: FLSubstitutionCluster.  (tmp1 isSubstitute: arg1) ifTrue: arg3 ifFalse: [ tmp1 add: arg1 substitutedBy: arg2 traceWith: analysis ]readStreamDo: arg1  ^FLPlatform current fileNamed: self fileName readStreamDo: [:arg2 |  arg1 value: arg2 binary ]testSmallInteger  self assertSerializationIdentityOf: -1212.  self assertSerializationIdentityOf: 7.  self assertSerializationIdentityOf: 0.  self assertSerializationIdentityOf: 1111.  self assertSerializationIdentityOf: SmallInteger onetestArray  self assertSerializationEqualityOf: #(1).  self assertSerializationEqualityOf: #(10 20).  self assertSerializationEqualityOf: #(1 2 3 #('Hello' 2 3))addPostMaterializationAction: arg1  header addPostMaterializationAction: arg1testNotFoundAfterRemoval  | tmp1 |  tmp1 := self newClassOrTrait.  self serialize: tmp1.  self removeFromSystem: tmp1.  self should: [ self materialized ] raise: FLClassNotFoundisSubstitute: arg1  ^substitutes identityIncludes: arg1testSmallIntegerMaxValue  self assertSerializationIdentityOf: SmallInteger maxValvaluesDo: arg1  tally = 0 ifTrue: [ ^self ].  1 to: 4096 do: [:arg2 |  | tmp1 |        tmp1 := values at: arg2.        1 to: (tallies at: arg2) do: [:arg3 |  arg1 value: (tmp1 at: arg3) ] ]serializeInstance: arg1 with: arg2  arg2 encodeUint24: arg1 absaddPreMaterializationAction: arg1  header addPreMaterializationAction: arg1assertSerializationEqualityOrIdentityOf: arg1  | tmp1 |  tmp1 := self resultOfSerializeAndMaterialize: arg1.  self assert: arg1 = tmp1 description: 'The materialized object should be equal to serialized one'references  ^references ifNil: [ references := FLLargeIdentityDictionary new ]testGrow  | tmp1 |  tmp1 := FLSimpleStack new: 1.  self assert: 1 equals: tmp1 capacity.  tmp1 push: #a.  self assert: 1 < tmp1 capacityat: arg1 ifAbsent: arg2  | tmp1 |  (keys at: (tmp1 := arg1 largeIdentityHash \\ 4096 + 1)) ifNotNil: [:arg3 |  1 to: (tallies at: tmp1) do: [:arg4 |  (arg3 at: arg4) == arg1 ifTrue: [ ^(values at: tmp1) at: arg4 ] ] ].  ^arg2 valuevisitNotSerializable: arg1  FLNotSerializable signalWith: arg1serializationOf: arg1 includes: arg2  | tmp1 |  self streamFactory writeStreamDo: [:arg3 |  tmp1 := serializer serialize: arg1 on: arg3.        ^tmp1 objects includes: arg2 ]materializeInstanceWith: arg1  ^arg1 nextEncodedUint24readArgumentsFrom: arg1  ^{arg1 key keywords .   arg1 arguments}do: arg1  ^self valuesDo: arg1materializationFactory  ^materializationFactoryprintOn: arg1  super printOn: arg1.  arg1     nextPutAll: ' contents: ';     print: contentstestAdditionalObjects  self serializer at: #test putAdditionalObject: 'test'.  self serializer at: 42 putAdditionalObject: 68.  self assertSerializationEqualityOf: 'foo'.  self assert: (self materialization additionalObjectAt: #test) equals: 'test'.  self assert: (self materialization additionalObjectAt: 42) equals: 68testPostMaterializationActions  | tmp1 |  tmp1 := self newSubclassNamed: #FuelPostMaterializationTestClassToBeDeleted of: Object instanceVariableNames: '' classVariableNames: 'TestClassVariable TestClassVariable2'.  tmp1 class     duringTestCompileSilently: 'postLoadMethod  TestClassVariable := 1';     duringTestCompileSilently: 'postLoadMethod2  TestClassVariable := 2';     duringTestCompileSilently: 'classVariable  ^TestClassVariable '.  tmp1 perform: #postLoadMethod.  self assert: (tmp1 perform: #classVariable) equals: 1.  self serializer addPostMaterializationAction: [ (Smalltalk at: #FuelPostMaterializationTestClassToBeDeleted) perform: #postLoadMethod2 ].  self serialize: tmp1.  self assert: (tmp1 perform: #classVariable) equals: 1.  self materialized.  self assert: (tmp1 perform: #classVariable) equals: 2registerIndexesOn: arg1  | tmp1 |  tmp1 := arg1 objectsIndexes.  self objects do: [:arg2 |  tmp1 at: arg2 put: tmp1 size + 1 ]nextEncodedWordsInto: arg1  stream fuelNextWordsInto: arg1fuelReplacement  ^ignoreMe ifTrue: [ nil ] ifFalse: [ self ]testSuperclassChange  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self newClassWithInstanceVariableNames: 'a b c' superclass: Object.  tmp2 := self newClassWithInstanceVariableNames: 'd e' superclass: tmp1.  tmp5 := self newClassWithInstanceVariableNames: 'x' superclass: Object.  tmp3 := tmp2 new.  tmp3 instVarNamed: 'a' put: $A.  tmp3 instVarNamed: 'b' put: $B.  tmp3 instVarNamed: 'c' put: $C.  tmp3 instVarNamed: 'd' put: $D.  tmp3 instVarNamed: 'e' put: $E.  self serialize: tmp3.  tmp2 superclass: tmp5.  tmp4 := self materialized.  self assert: $D equals: (tmp4 instVarNamed: 'd').  self assert: $E equals: (tmp4 instVarNamed: 'e').  self should: [ tmp4 instVarNamed: 'a' ] raise: Error.  self should: [ tmp4 instVarNamed: 'b' ] raise: Error.  self should: [ tmp4 instVarNamed: 'c' ] raise: Error.  self assert: (tmp4 instVarNamed: 'x') isNilreferencesStep  clusters do: [:arg1 |  arg1 serializeReferencesStepWith: encoder ]isEmpty  ^1 = slotIndextestShowingProgressBar  (testingEnvironment includesKey: #FLProgressSerialization) ifFalse: [ ^self skip ].  FLPlatform current fileNamed: 'numbers.fuel' writeStreamDo: [:arg1 |  FLSerializer newDefault           showProgress;           serialize: (1 to: 200000) asArray on: arg1 ].  FLPlatform current fileNamed: 'numbers.fuel' readStreamDo: [:arg1 |  FLMaterializer newDefault           showProgress;           materializeFrom: arg1 ]dontIgnoreMe  ignoreMe := falseserializeInstancesStepWith: arg1  objects do: [:arg2 |  self serializeInstance: arg2 with: arg1 ]do: arg1  tally = 0 ifTrue: [ ^self ].  includesNil ifTrue: [ arg1 value: nil ].  1 to: 4096 do: [:arg2 |  | tmp1 |        tmp1 := array at: arg2.        1 to: (tallies at: arg2) do: [:arg3 |  arg1 value: (tmp1 at: arg3) ] ]additionalObjectAt: arg1  ^header additionalObjectAt: arg1signature  ^signaturetestProxyByTarget  | tmp1 tmp2 tmp3 |  tmp1 := (self newSubclassOf: Object instanceVariableNames: 'target' classVariableNames: '')     duringTestCompileSilently: 'target: x  target := x';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: target';     yourself.  tmp3 := tmp1 new     target: 5;     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp3.  self assert: 5 equals: tmp2isBigEndian  ^(Smalltalk at: #EndianDetector) isBigEndianvisitVariableObject: arg1  self mapAndTraceByObjectClass: arg1 to: FLVariableObjectClusterinitializeOn: arg1 digits: arg2  self initialize.  stream := arg1.  digits := arg2testRunArray  self assertSerializationEqualityOf: (RunArray runs: #(1 2 1) values: #(1 2 3))encodeUint32: arg1  stream     nextPut: (arg1 bitShift: -24);     nextPut: ((arg1 bitShift: -16) bitAnd: 255);     nextPut: ((arg1 bitShift: -8) bitAnd: 255);     nextPut: (arg1 bitAnd: 255)testFormatFixedToVariable  | tmp1 |  self serialize: FLPair new.  tmp1 := self during: [ self materialized ] rename: FLPair as: FLWeakClassMock.  self assert: tmp1 size equals: 0readStreamDo: arg1  ^arg1 value: inMemoryStream resetassertSerializationEqualityOf: arg1  | tmp1 |  tmp1 := self resultOfSerializeAndMaterialize: arg1.  self assert: arg1 ~~ tmp1 description: 'The materialized object should not be the same as the serialized one'.  self assert: arg1 = tmp1 description: 'The materialized object should be equal to serialized one'pluggableSubstitutionMappers  ^pluggableSubstitutions collect: [:arg1 |  FLPluggableSubstitutionMapper when: arg1 key substituteBy: arg1 value ]nextEncodedUint16  ^(stream next bitShift: 8) + stream nextclusterMaterializeStepWith: arg1  super clusterMaterializeStepWith: arg1.  theClass := arg1 decoder nextEncodedReferencetestCreation  self indexStreamOn: #() writeStream digits: 2initializeAnalyzing: arg1  super initializeAnalyzing: arg1.  variablesMapping := FLVariablesMapping newAnalyzing: theClass references: self referencestestGlobalMetaclass  self assertSerializationIdentityOf: Integer classtestDontConsiderCustomGlobal  | tmp1 |  tmp1 := Object new.  serializationEnvironment at: #FLGlobalVariableForTesting put: tmp1.  materializationEnvironment     at: #FLGlobalVariableForTesting put: tmp1;     at: #Object put: Object.  self deny: (self analyzer globalSymbols includes: #FLGlobalVariableForTesting).  self deny: (self resultOfSerializeAndMaterialize: tmp1) identicalTo: tmp1materializeReferencesOf: arg1 with: arg2  super materializeReferencesOf: arg1 with: arg2.  self materializeReferencesVariablePartOf: arg1 with: arg2testFraction  self assertSerializationEqualityOf: 3 / 4.  self assertSerializationEqualityOf: 4 / 3.  self assertSerializationEqualityOf: -4 / 3.  self assertSerializationEqualityOf: -4 / -3.  self assertSerializationEqualityOf: 4 / -3.  self assertSerializationIdentityOf: (0 - 0) / -3.  self assertSerializationEqualityOf: 0 - (1001 / 1000)initializeWith: arg1  self initialize.  decoder := arg1includesKey: arg1  | tmp1 |  ^(keys at: (tmp1 := arg1 largeIdentityHash \\ 4096 + 1)) ifNil: [ false ] ifNotNil: [:arg2 |  arg1 ifNotNil: [ arg2 fuelPointsTo: arg1 ] ifNil: [ 1 to: (tallies at: tmp1) do: [:arg3 |  (arg2 at: arg3) == arg1 ifTrue: [ ^true ] ].              false ] ]testGlobalMetaclass  materializationEnvironment at: #Integer put: FLPerson.  self assert: (self resultOfSerializeAndMaterialize: Integer class) identicalTo: FLPerson classnextEncodedString  | tmp1 tmp2 |  tmp1 := stream next.  tmp1 >= 192 ifTrue: [ tmp1 := tmp1 - 192.        1 to: 3 do: [:arg1 |  tmp1 := tmp1 * 256 + stream next ] ].  tmp2 := ByteArray new: tmp1.  stream nextInto: tmp2.  ^tmp2 asStringtestWeakWithStrongReferenceFromGraph2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := 11.  tmp4 := 'something'.  tmp1 := WeakArray with: tmp3 with: tmp4.  tmp2 := OrderedCollection with: 40 with: 'aaaa' with: tmp1 with: tmp4 with: (Point x: tmp1 y: tmp1).  tmp5 := self resultOfSerializeAndMaterialize: tmp2.  self assert: (tmp5 at: 3) first isNil.  self assert: (tmp5 at: 3) second equals: tmp4.  self deny: (self serializationOf: tmp2 includes: 11).  self assert: (self serializationOf: tmp2 includes: tmp4)globalsBucket  ^globalsBucketmanageFile: arg1  Stdio stdout     nextPutAll: 'Materializing from file: ';     nextPutAll: arg1 fullName;     lf.  arg1 readStreamDo: [:arg2 |  arg2 binary.        FLMaterializer new materializeFrom: arg2 ].  Stdio stdout     nextPutAll: 'Materialization finished';     lftestSubstituteTrueInPresenceOfTheTrueInstance  self testSubstitute: True inPresenceOf: truevalues  ^Array new: tally streamContents: [:arg1 |  self valuesDo: [:arg2 |  arg1 nextPut: arg2 ] ]substitutions  ^substitutionsprintOn: arg1  self printNameOn: arg1.  arg1 nextPutAll: '->'.  objects printElementsOn: arg1testEmptyOrderedCollection  self assertSerializationEqualityOf: OrderedCollection newclusterKeyedByObjectClass: arg1 class: arg2  ^self clusterInstanceOf: arg1 keyInBucket: arg2 factory: [ arg1 newAnalyzing: arg2 ]mapAndTrace: arg1  (globals includes: arg1) ifTrue: [ self mapAndTraceByClusterName: arg1 to: FLGlobalValueCluster ] ifFalse: [ next mapAndTrace: arg1 ]instVar1: arg1  instVar1 := arg1useStandardFileStream  streamFactory := FLFileStreamStrategy newWithStandardFileStreamfuelAccept: arg1  ^arg1 visitSubstitution: self by: niltestSortedCollectionWithInstanceVariableReferenceChange  | tmp1 tmp2 |  instanceVariableForTesting := false.  tmp1 := self sortedBlockClosureWithInstanceVariable.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  instanceVariableForTesting := true.  tmp2 addAll: #(2 3 1).  tmp1 addAll: #(2 3 1).  self deny: tmp1 asArray equals: tmp2 asArraytestSimple  | tmp1 |  self analyzer when: [:arg1 |  arg1 < 0 ] substituteBy: [:arg1 |  0 ].  tmp1 := self resultOfSerializeAndMaterialize: -1.  self assert: tmp1 equals: 0useInstalled  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: true.  theCompiledMethod := theClass methodNamed: #mtestSerializeExternalAddressCorrectly  | tmp1 tmp2 |  tmp1 := ExternalAddress fromAddress: 1234567890.  tmp2 := self serialize: tmp1.  self assert: tmp2 isNotNil.  self assert: tmp2 size > 0isBigEndian  ^isBigEndianremove: arg1 ifAbsent: arg2  | tmp1 tmp2 tmp3 |  arg1 ifNil: [ includesNil ifTrue: [ includesNil := false.              tally := tally - 1.              ^arg1 ].        ^arg2 value ].  tmp1 := (array at: (tmp2 := arg1 largeIdentityHash \\ 4096 + 1)) ifNil: [ ^arg2 value ].  (tmp1 fuelPointsTo: arg1) ifFalse: [ ^arg2 value ].  1 to: (tmp3 := tallies at: tmp2) do: [:arg3 |  (tmp1 at: arg3) == arg1 ifTrue: [ tmp1                 at: arg3 put: (tmp1 at: tmp3);                 at: tmp3 put: nil.              (tmp3 := tmp3 - 1) < (tmp1 size // 4) ifTrue: [ | tmp4 |                    tmp4 := Array new: tmp3 * 2.                    tmp4 replaceFrom: 1 to: tmp3 with: tmp1 startingAt: 1.                    array at: tmp2 put: tmp4 ].              tallies at: tmp2 put: tmp3.              tally := tally - 1.              ^arg1 ] ].  ^arg2 valueinitializeWithClass: arg1 references: arg2  self initialize.  theClass := arg1.  references := arg2nextBytesPutAll: arg1  self flushBufferIfFull.  arg1 size <= self bufferFreeSize ifTrue: [ self buffer replaceFrom: position + 1 to: position + arg1 size with: arg1.        position := position + arg1 size ] ifFalse: [ self flushBuffer.        arg1 size > (self buffer size / 2) ifTrue: [ stream nextBytesPutAll: arg1 ] ifFalse: [ self nextBytesPutAll: arg1 ] ]serializer  ^serializerhash  ^self right hash bitXor: self left hashid: arg1  id := arg1add: arg1  | tmp1 |  arg1 ifNil: [ includesNil ifFalse: [ includesNil := true.              tally := tally + 1 ].        ^arg1 ].  (array at: (tmp1 := arg1 largeIdentityHash \\ 4096 + 1)) ifNil: [ array at: tmp1 put: (Array with: arg1).        tallies at: tmp1 put: 1.        tally := tally + 1 ] ifNotNil: [:arg2 |  (arg2 fuelPointsTo: arg1) ifFalse: [ | tmp2 |              tally := tally + 1.              arg2 size < (tmp2 := (tallies at: tmp1) + 1) ifFalse: [ arg2 at: tmp2 put: arg1 ] ifTrue: [ | tmp3 |                    tmp3 := Array new: arg2 size * 2.                    tmp3                       replaceFrom: 1 to: arg2 size with: arg2 startingAt: 1;                       at: tmp2 put: arg1.                    array at: tmp1 put: tmp3 ].              tallies at: tmp1 put: tmp2 ] ].  ^arg1privateTrace: arg1  privateObjectStack push: arg1testWeakAndNoStrongReferenceFromGraph  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := 11.  tmp4 := 'something'.  tmp1 := WeakArray with: tmp3 with: tmp4.  tmp2 := OrderedCollection with: 40 with: 'aaaa' with: tmp1.  tmp5 := self resultOfSerializeAndMaterialize: tmp2.  self assert: (tmp5 at: 3) first isNil.  self assert: (tmp5 at: 3) second isNil.  self deny: (self serializationOf: tmp2 includes: 11).  self deny: (self serializationOf: tmp2 includes: 'something')serialize: arg1  byteArray := FLSerializer serializeToByteArray: arg1fileNamed: arg1 writeStreamDo: arg2  ^((Smalltalk at: #File) named: arg1) writeStreamDo: [:arg3 |  arg2 value: arg3 ]fileExtension  ^self class fileExtension= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^contents = arg1 contentsprintNameOn: arg1  super printOn: arg1serializeReferencesOf: arg1 with: arg2  variablesMapping serializeReferencesOf: arg1 with: arg2testBlockClosureWithThreeArguments  | tmp1 tmp2 |  tmp1 := [:arg1 :arg2 :arg3 |  arg1 + arg2 + arg3 ].  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp2 in: self.  self assert: (tmp2 value: 1 value: 2 value: 3) equals: 6keysDo: arg1  tally = 0 ifTrue: [ ^self ].  1 to: 4096 do: [:arg2 |  | tmp1 |        tmp1 := keys at: arg2.        1 to: (tallies at: arg2) do: [:arg3 |  arg1 value: (tmp1 at: arg3) ] ]tearDown  FLPlatform current deleteFileNamed: self fileNameobjectsIndexes  ^objectsIndexesmaterializeInstanceWith: arg1  ^Character value: arg1 nextEncodedUint32clusterReferencesDo: arg1  arg1 value: theClassserializeReferencesOf: arg1 with: arg2  | tmp1 |  tmp1 := self references at: arg1 ifAbsent: [ ^self ].  arg2 encodePositiveInteger: tmp1 first.  tmp1 from: 2 to: tmp1 size do: [:arg3 |  arg2 encodeReferenceTo: arg3 ]clusterMaterializeStepWith: arg1  super clusterMaterializeStepWith: arg1.  objects := Array new: arg1 decoder nextEncodedPositiveIntegertestMethodPreservesIdentity  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: tmp1 >> #younewClass  ^self newSubclassOf: Object instanceVariableNames: '' classVariableNames: ''activate  self manageFiles.  (self commandLine hasOption: 'save') ifTrue: [ ThreadSafeTranscript install.        SessionManager default addDeferredStartupAction: [ Smalltalk snapshot: true andQuit: true.              NonInteractiveTranscript new install ] ].  (self commandLine hasOption: 'quit') ifTrue: [ self exitSuccess ]contents  ^contentsmaterializeInstanceWith: arg1  | tmp1 tmp2 tmp3 |  tmp2 := arg1 nextEncodedInt32.  tmp3 := arg1 nextEncodedUint16.  tmp1 := CompiledMethod newMethod: tmp3 header: tmp2.  tmp1 initialPC to: tmp1 size do: [:arg2 |  tmp1 at: arg2 put: arg1 nextEncodedByte ].  ^tmp1instancesStep  clusterCount timesRepeat: [ self clusterInstancesStep ]objectCount  ^objectCounttestNotInstalled  | tmp1 |  self useNotInstalled.  self deny: theCompiledMethod isInstalled.  self deny: theCompiledMethod isDoIt.  self deny: theCompiledMethod trailer hasSource.  self assert: theCompiledMethod trailer isEmpty.  self deny: theCompiledMethod trailer hasSourcePointer.  tmp1 := self resultOfSerializeAndMaterialize: theCompiledMethod.  self deny: tmp1 isInstalled.  self deny: tmp1 isDoIt.  self assert: tmp1 trailer hasSource.  self deny: tmp1 trailer isEmpty.  self deny: tmp1 trailer hasSourcePointer.  self assert: (tmp1 isEqualRegardlessTrailerTo: theCompiledMethod)theClass  ^theClassmaterializeInstanceWith: arg1  ^theClass fuelNew: arg1 nextEncodedPositiveIntegertestEmptySet  self assertSerializationEqualityOf: Set newtestAssociation  self assertSerializationEqualityOf: 1 -> 'marino'.  self assertSerializationEqualityOf: nil -> 'marino'.  self assertSerializationEqualityOf: nil -> nil.  self assertSerializationEqualityOf: nil -> #(1 3 4).  self assertSerializationEqualityOf: nil -> truefuelAccept: arg1  ^arg1 visitSubstitution: self by: nilsignature  ^signaturetestBadSignature  serializer signature: 'FUELx'.  materializer signature: 'FUELy'.  self should: [ self resultOfSerializeAndMaterialize: 'content' ] raise: FLBadSignature whoseDescriptionIncludes: 'FUELy' description: 'The materializer should raise an error when signature differs of the expected one.'analysis: arg1  analysis := arg1.  next ifNotNil: [ next analysis: arg1 ]testTransientPair  | tmp1 |  self analyzer when: [:arg1 |  FLPair = arg1 class ] substituteBy: [:arg1 |  nil ].  tmp1 := self resultOfSerializeAndMaterialize: FLPair new.  self assert: tmp1 isNilreadSelectorFrom: arg1 argumentNames: arg2 argumentValues: arg3  | tmp1 |  tmp1 := arg2 indexOf: 'selector:' ifAbsent: [ ^arg1 method selector ].  ^arg3 at: tmp1serialize: arg1  self streamFactory writeStreamDo: [:arg2 |  self serializer serialize: arg1 on: arg2 ]materializeInstanceWith: arg1  ^arg1 nextEncodedUint32globalEnvironment  ^globalEnvironmentprintOn: arg1  super printOn: arg1.  array printElementsOn: arg1setUp  super setUp.  thisContextSample := self class thisContextSamplereadStreamDo: arg1  self subclassResponsibilitytestCompiledMethod  | tmp1 tmp2 |  tmp1 := self newClass     duringTestCompileSilently: 'm  ^ 42';     yourself.  tmp2 := self newClass     duringTestCompileSilently: 'm    ^    42   ';     yourself.  self assert: (tmp1 >> #m) bytecodesHash equals: (tmp2 >> #m) bytecodesHash.  self deny: tmp1 >> #m identicalTo: tmp2 >> #m.  materializationEnvironment at: tmp1 name put: tmp2.  self assert: (self resultOfSerializeAndMaterialize: tmp1 >> #m) identicalTo: tmp2 >> #mserializeInstance: arg1 with: arg2  | tmp1 |  tmp1 := globalSends at: arg1.  self serializeGlobalAssociationKeyed: tmp1 key on: arg2.  arg2 encodeString: tmp1 valuemapAndTraceSubstitutionIfNotRecursive: arg1  | tmp1 |  tmp1 := self clusterKeyedByClusterName: FLSubstitutionCluster.  (tmp1 isSubstitute: arg1) ifTrue: [ next mapAndTrace: arg1 ] ifFalse: [ tmp1 add: arg1 substitutedBy: (substitutionFactory value: arg1) traceWith: analysis ]visitFixedObject: arg1  self mapAndTraceByObjectClass: arg1 to: FLFixedObjectClustersetDefaultSerialization  ^serializationFactory := [:arg1 :arg2 |  (FLSerialization with: arg2 root: arg1 analyzer: self analyzer)     run;     yourself ]testPairs  | tmp1 |  tmp1 := (1 to: 1 << 14) collect: [:arg1 |  FLPair new           left: arg1;           right: arg1 + 1;           yourself ].  self assertSerializationEqualityOf: tmp1visitClass: arg1  self mapAndTraceInstanceSideGlobal: arg1printOn: arg1  arg1     nextPutAll: 'a ';     nextPutAll: self class namematerializeReferencesOf: arg1 with: arg2  variablesMapping materializeReferencesOf: arg1 with: arg2manageFiles  files := (self commandLine allFilesWithExtension: self fileExtension) collect: [:arg1 |  (FileSystem disk resolve: arg1) asFileReference ].  files ifNil: [ ^self ].  files do: [:arg2 |  self manageFile: arg2 ]testTransientByNil  | tmp1 tmp2 |  tmp2 := self newClass     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: nil';     yourself.  tmp1 := self resultOfSerializeAndMaterialize: tmp2 new.  self assert: tmp1 isNilsubstitutionIndexes  ^substitutionIndexesinitializeWithPragma: arg1  | tmp1 |  tmp1 := self readArgumentsFrom: arg1.  self     method: arg1 method copy;     selector: (self readSelectorFrom: arg1 argumentNames: tmp1 first argumentValues: tmp1 second);     isSource: (self readIsSourceFrom: arg1 argumentNames: tmp1 first argumentValues: tmp1 second);     targetClass: (self readTargetClassFrom: arg1 argumentNames: tmp1 first argumentValues: tmp1 second)absolutePathOf: arg1  ^arg1 asFileReference fullNametestSubstituteByItself  | tmp1 |  self analyzer when: [:arg1 |  true ] substituteBy: [:arg1 |  arg1 ].  tmp1 := self resultOfSerializeAndMaterialize: 1.  self assert: tmp1 equals: 1defaultAnalyzer  ^FLAnalyzer newDefaultserializeInstance: arg1 with: arg2  self serializeGlobalClass: arg1 instanceSide on: arg2newSubclassNamed: arg1 of: arg2 instanceVariableNames: arg3 classVariableNames: arg4  | tmp1 |  SystemAnnouncer uniqueInstance suspendAllWhile: [ tmp1 := arg2 subclass: arg1 asSymbol instanceVariableNames: arg3 classVariableNames: arg4 category: self classFactory defaultCategory ].  self classFactory createdClasses add: tmp1.  ^tmp1isPharo  ^trueclusterBuckets  ^OrderedCollection new     add: globalsBucket;     add: primitivesBucket;     add: metalevelClassSideBucket;     add: metalevelInstanceSideBucket;     add: baselevelBucket;     add: postBaselevelBucket;     add: substitutionsBucket;     yourselfglobalEnvironment  ^globalEnvironmentaddAndClassifySelector: arg1 inClass: arg2 withMethod: arg3 inProtocol: arg4  arg2 addAndClassifySelector: arg1 withMethod: arg3 inProtocol: arg4versionNumber  ^('\d+' asRegex matchesIn: self className) first asIntegerencodePositiveInteger: arg1  1 to: 4 do: [:arg2 |  stream nextPut: (arg1 byteAt: 4 + 1 - arg2) ]run  self headerStep.  self instancesStep.  self referencesStep.  self trailerStep.  self afterMaterializationStepuseInMemorySerializationStream  streamFactory := FLByteArrayStreamStrategy newencodeYourself  self encodePositiveInteger: objectCount.  self encodePositiveInteger: FLPlatform current isBigEndian asBitmaterializationHeader  self streamFactory readStreamDo: [:arg1 |  ^self materializer materializeHeaderFrom: arg1 ]testGlobalClass  self assertSerializationIdentityOf: Integerat: arg1 putAdditionalObject: arg2  additionalObjects at: arg1 put: arg2setUpMaterializer  materializer := FLMaterializer newDefaultencodeBytes: arg1  stream nextBytesPutAll: arg1targetClass: arg1  targetClass := arg1baselevelBucket  ^baselevelBuckettraceWith: arg1  self clusterReferencesDo: [:arg2 |  arg1 privateTrace: arg2 ]testSameSignature  serializer signature: 'FUELx'.  materializer signature: 'FUELx'.  self assertSerializationEqualityOf: 'content'testConsiderCustomWideSymbolGlobal  self errorresultOfSerializeAndMaterializeCompiledMethod: arg1  | tmp1 |  tmp1 := self resultOfSerializeAndMaterialize: arg1.  self assert: (tmp1 isEqualRegardlessTrailerTo: arg1)instanceVariableNamesToSerialize  | tmp1 tmp2 |  tmp1 := theClass fuelIgnoredInstanceVariableNames.  tmp2 := OrderedCollection new.  theClass instanceVariableNamesDo: [:arg1 |  (tmp1 includes: arg1) ifFalse: [ tmp2 add: arg1 ] ].  ^tmp2fileName  ^FLPlatform current absolutePathOf: FLPlatform current imageName , '-tests.fuel'serializeInstance: arg1 with: arg2  arg2 encodePositiveInteger: arg1 basicSize.  arg2 encodeWords: arg1trailerStep  root := decoder nextEncodedReferenceisSqueak  ^falsematerializeReferencesOf: arg1 with: arg2  mapping do: [:arg3 |  | tmp1 |        tmp1 := arg2 nextEncodedReference.        arg3 ifNotNil: [ arg1 instVarAt: arg3 put: tmp1 ] ]testTwoIgnoredVariables  | tmp1 tmp2 tmp3 |  tmp3 := self newClassWithInstanceVariableNames: 'a b c'.  tmp3 class duringTestCompileSilently: 'fuelIgnoredInstanceVariableNames ^#(a c)'.  tmp1 := tmp3 new     instVarAt: 1 put: $A;     instVarAt: 2 put: $B;     instVarAt: 3 put: $C;     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: nil equals: (tmp2 instVarAt: 1).  self assert: $B equals: (tmp2 instVarAt: 2).  self assert: nil equals: (tmp2 instVarAt: 3)visitMethodContext: arg1  self mapAndTraceByObjectClass: arg1 to: FLContextClusteruseLightMappers  globalMappersFactory := [ self lightGlobalMappers ].  generalMapperFactory := [ FLLightGeneralMapper new ]map: arg1 to: arg2  | tmp1 |  tmp1 := notIgnoredVariables indexOf: arg1.  tmp1 > 0 ifTrue: [ mapping at: tmp1 put: (theClass instVarIndexFor: arg2 ifAbsent: [ self error: 'Bad variable destination.' ]) ]fuelAccept: arg1  ^index < 10 ifTrue: [ arg1 visitSubstitution: self by: (self copy index: self index + 1) onRecursionDo: [ super fuelAccept: arg1 ] ] ifFalse: [ super fuelAccept: arg1 ]registerIndexesOn: arg1  self flag: #pharoTodo.  objects := objects asIdentitySet.  super registerIndexesOn: arg1silentlyAddAndClassifySelector: arg1 inClass: arg2 withMethod: arg3 inProtocol: arg4  self subclassResponsibilitynextEncodedInt24  | tmp1 tmp2 |  tmp1 := tmp2 := stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp2 >= 128 ifTrue: [ tmp1 := -16r1000000 + tmp1 ].  ^tmp1nextEncodedBitmap  ^Bitmap newFromStream: streamclassFactoryForTestCaseClass  ^ClassFactoryForTestCaseserialize: arg1  ^FLSerializer serializeToByteArray: arg1clusterReferencesDo: arg1  super clusterReferencesDo: arg1.  arg1 value: nilisSource  ^isSourcetestPreservesIdentity  self assertSerializationIdentityOf: self newClassOrTraitmaterializeInstanceWith: arg1  ^Rectangle basicNewroot  ^rootremoveKey: arg1 ifAbsent: arg2  | tmp1 |  (keys at: (tmp1 := arg1 largeIdentityHash \\ 4096 + 1)) ifNotNil: [:arg3 |  | tmp2 |        1 to: (tmp2 := tallies at: tmp1) do: [:arg4 |  (arg3 at: arg4) == arg1 ifTrue: [ | tmp3 |                    arg3                       at: arg4 put: (arg3 at: tmp2);                       at: tmp2 put: nil.                    (tmp3 := values at: tmp1)                       at: arg4 put: (tmp3 at: tmp2);                       at: tmp2 put: nil.                    (tmp2 := tmp2 - 1) < (arg3 size // 4) ifTrue: [ | tmp4 |                          tmp4 := Array new: tmp2 * 2.                          tmp4 replaceFrom: 1 to: tmp2 with: arg3 startingAt: 1.                          keys at: tmp1 put: tmp4.                          tmp4 := Array new: tmp2 * 2.                          tmp4 replaceFrom: 1 to: tmp2 with: tmp3 startingAt: 1.                          values at: tmp1 put: tmp4 ].                    tallies at: tmp1 put: tmp2.                    tally := tally - 1.                    ^arg1 ] ] ].  ^arg2 valueroot  ^rootencodeUint8: arg1  stream nextPut: arg1setUp  super setUp.  theClass := self newClass classwriteStreamDo: arg1  inMemoryStream := ByteArray new writeStream.  ^arg1 value: inMemoryStream binaryencodeReferenceToClusterObjectClass: arg1  indexStream nextIndexPut: (objectsIndexes at: arg1 ifAbsent: [ FLObjectNotFound signalWith: arg1 ])nextEncodedPositiveInteger  | tmp1 |  tmp1 := 0.  1 to: 4 do: [:arg1 |  tmp1 := (tmp1 bitShift: 8) + stream next ].  ^tmp1nextEncodedReference  ^objects at: indexStream nextIndexsetDefaultSerialization  ^serializationFactory := [:arg1 :arg2 |  (FLDelayedSerializationMock with: arg2 root: arg1 analyzer: self analyzer)     run;     yourself ]testIgnoredValueIsNotMaterialized  | tmp1 tmp2 tmp3 |  tmp3 := self newClassWithInstanceVariableNames: 'a'.  tmp3 class duringTestCompileSilently: 'fuelIgnoredInstanceVariableNames ^#(a)'.  tmp1 := tmp3 new     instVarAt: 1 put: #A;     yourself.  self serialize: tmp1.  tmp2 := self materializedObjects.  self deny: (tmp2 includes: #A)streamFactory  ^streamFactorytestClassWithCachedValueByNil  | tmp1 tmp2 tmp3 |  tmp1 := (self newSubclassOf: Object instanceVariableNames: 'cache' classVariableNames: '')     duringTestCompileSilently: 'cache ^cache';     duringTestCompileSilently: 'cache: x cache := x';     duringTestCompileSilently: '			fuelAccept: aVisitor  				^cache 					ifNil: [ super fuelAccept: aVisitor ]					ifNotNil: [ aVisitor visitSubstitution: self by: (self copy cache: nil)]';     yourself.  tmp3 := tmp1 new     cache: 5;     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp3.  self assert: tmp2 cache isNilversion  ^versiontestMethodNotFoundAfterRemoval  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 duringTestCompileSilently: 'you'.  self serialize: tmp1 >> #you.  tmp1 removeSelectorSilently: #you.  self should: [ self materialized ] raise: FLMethodNotFound whoseDescriptionIncludes: tmp1 name , '>>#you' description: 'Should raise an error when method is not present.'initialize  super initialize.  self signature: self class defaultSignature.  self version: self class currentVersion.  header := FLHeader newserializeReferencesOf: arg1 with: arg2  super serializeReferencesOf: arg1 with: arg2.  self serializeReferencesVariablePartOf: arg1 with: arg2tearDownInstanceVariables  self class withAllSuperclasses do: [:arg1 |  arg1 = TestCase ifTrue: [ ^self ].        arg1 instVarNames do: [:arg2 |  self instVarNamed: arg2 put: nil ] ]serializeInstance: arg1 with: arg2  arg2 encodeUint8: arg1 absat: arg1 putAdditionalObject: arg2  header at: arg1 putAdditionalObject: arg2visitWeakObject: arg1  self mapAndTraceByObjectClass: arg1 to: FLWeakVariableObjectClusterindex  ^indextestClassSideMethodNotFoundAfterRemoval  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 classSide duringTestCompileSilently: 'you'.  self serialize: tmp1 classSide >> #you.  tmp1 classSide removeSelectorSilently: #you.  self should: [ self materialized ] raise: FLMethodNotFound whoseDescriptionIncludes: tmp1 classSide printString description: 'Should raise an error when method is not present.'initializeAnalyzing  super initializeAnalyzing.  objects := self newAnalyzingCollectiontestByteArray  self assertSerializationEqualityOf: #[1 2 3 4 5 6 7]materializeReferencesOf: arg1 with: arg2  arg2 nextEncodedPositiveInteger timesRepeat: [ arg1 add: arg2 nextEncodedReference -> arg2 nextEncodedReference ]clusterSerializeStepWith: arg1  super clusterSerializeStepWith: arg1.  arg1 encoder encodeReferenceToClusterObjectClass: theClassinitialize: arg1  array := Array new: arg1.  slotIndex := 1testSortedCollectionWithClassVariableChanges  | tmp1 tmp2 tmp3 tmp4 |  ClassVariableForTesting := false.  tmp1 := self class sortedCollectionForTestingWithClassVariable.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp3 := tmp2 sortBlock outerContext method.  tmp4 := tmp3 literals indexOf: (self class bindingOf: #ClassVariableForTesting).  self deny: (tmp3 literalAt: tmp4) value.  ClassVariableForTesting := true.  self assert: (tmp3 literalAt: tmp4) valuetestObjectByProxyThatBecomesItsContent  | tmp1 tmp2 |  tmp1 := (self newSubclassOf: Object instanceVariableNames: 'someState' classVariableNames: '')     duringTestCompileSilently: 'initialize  someState := 5@1';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: (FLProxyThatBecomesItsContent newWith: someState)';     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp1 new.  self assert: 5 @ 1 equals: tmp2setUpClassFactory  classFactory := FLPlatform current classFactoryForTestCaseClass newserializeInstance: arg1 with: arg2  arg2 encodeUint64: arg1 absmigrateClassNamed: arg1 toClass: arg2  self migrateClassNamed: arg1 toClass: arg2 variables: #()addVariableReferenceFrom: arg1 to: arg2  | tmp1 |  tmp1 := self variableReferences at: arg1 ifAbsent: [ nil ].  tmp1 ifNil: [ self variableReferences at: arg1 put: (tmp1 := OrderedCollection new) ].  tmp1 add: arg2withNotificationsNewClassWithInstanceVariableNames: arg1  ^classFactory withNotificationsNewClassWithInstanceVariableNames: arg1method1  self name.  self printString= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^id = arg1 idtestPair  self assertSerializationEqualityOf: (FLPair new           left: 10;           right: 20;           yourself)materializeInstanceWith: arg1  ^self materializeGlobalClassFrom: arg1testUUID  self assertSerializationEqualityOf: (UUID fromString: 'a3b64357-377a-5b41-b575-1c653084a121').  self assertSerializationEqualityOf: UUID nilUUID.  self assertSerializationEqualityOf: UUID newtestCyclicIdentitySet  | tmp1 tmp2 |  tmp1 := IdentitySet new.  tmp1 add: tmp1.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp1 ~~ tmp2.  self assert: (tmp2 includes: tmp2) description: 'The materialized set has to include himself. Note aSet = materializedSet is false, bacause equality implementation checks that materializedSet *identity-includes* each element of aSet, which is false.'newClassInCategory: arg1  ^self classFactory silentlyNewClassInCategory: arg1registerIndexesOn: arg1  globalEnvironment  ^globalEnvironmenttargetClass  ^targetClassgeneralMapper  ^generalMapperFactory valuetestContextWithClosureAndSender  | tmp1 tmp2 tmp3 |  tmp1 := Context newForMethod: FLPair >> #method1.  tmp1 initializeWith: 23 stackPtr: 1 method: FLPair >> #method1 receiver: (FLPair new           right: 4;           left: 2) sender: nil.  tmp3 := self class blockClosureContextTestingWithSender: tmp1.  tmp2 := self resultOfSerializeAndMaterialize: tmp3.  tmp3 assertWellMaterializedInto: tmp2 in: selfinitializeStream: arg1  stream := arg1.  streamRespondsToNextPutAllStartingAt := stream respondsTo: #next:putAll:startingAt:testRecursiveArray  | tmp1 tmp2 |  tmp1 := Array new: 3.  tmp1 at: 1 put: 10.  tmp1 at: 2 put: 20.  tmp1 at: 3 put: tmp1.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp2 first equals: 10.  self assert: tmp2 second equals: 20.  self assert: tmp2 third identicalTo: tmp2postCopy  tallies := tallies copyclose  self flushBuffer.  stream closedefaultLabel  ^'Fuel out Stack'useAuthor: arg1 during: arg2  self subclassResponsibilityvariablePartReferencesOf: arg1 do: arg2  method2  self namesetTestTimeLimitFor: arg1 to: arg2  self subclassResponsibilitypostBaselevelBucket  ^postBaselevelBucketafterMaterializationStepWith: arg1  primitivesBucket  ^primitivesBucketpostMaterializationActions: arg1  postMaterializationActions := arg1materializeInstancesStepWith: arg1  1 to: objects size do: [:arg2 |  objects at: arg2 put: (self materializeInstanceWith: arg1) ]initializeWith: arg1 substitutionFactory: arg2  self initialize.  condition := arg1.  substitutionFactory := arg2testConsiderCustomGlobal  | tmp1 tmp2 |  tmp2 := #FLGlobalVariableForTesting.  self analyzer considerGlobal: tmp2.  tmp1 := FLPerson new.  [ testingEnvironment at: tmp2 put: tmp1.  self assertSerializationIdentityOf: tmp1 ] ensure: [ testingEnvironment removeKey: tmp2 ]testObsolete  | tmp1 |  tmp1 := self newClassOrTrait.  self removeFromSystem: tmp1.  self should: [ self serialize: tmp1 ] raise: FLObsolete whoseDescriptionIncludes: tmp1 name description: 'Should raise an error when serializing as global an obsolete class or trait.'testFuelReplacement  | tmp1 |  self assert: (self resultOfSerializeAndMaterialize: FLReplacementClassMock) equals: nil.  self assert: (self resultOfSerializeAndMaterialize: {FLReplacementClassMock}) equals: {nil}.  tmp1 := FLReplacementMock new     ignoreMe;     yourself.  self assert: (self resultOfSerializeAndMaterialize: {tmp1}) equals: {nil}.  tmp1 dontIgnoreMe.  self assert: (self resultOfSerializeAndMaterialize: {tmp1}) equals: {tmp1}registerIndexesOn: arg1  substitutions keysAndValuesDo: [:arg2 :arg3 |  | tmp1 |        tmp1 := arg1 objectsIndexes at: arg3.        arg1 substitutionIndexes at: arg2 put: tmp1 ]encodeByte: arg1  stream nextPut: arg1testDoIt  | tmp1 |  self useDoIt.  theCompiledMethod selector: #DoIt.  self assert: theCompiledMethod isDoIt.  self assert: theCompiledMethod isInstalled.  self deny: theCompiledMethod trailer hasSource.  self assert: theCompiledMethod trailer isEmpty.  self deny: theCompiledMethod trailer hasSourcePointer.  tmp1 := self resultOfSerializeAndMaterialize: theCompiledMethod.  self deny: tmp1 isInstalled.  self assert: tmp1 isDoIt.  self assert: tmp1 trailer hasSource.  self deny: tmp1 trailer isEmpty.  self deny: tmp1 trailer hasSourcePointer.  self assert: (tmp1 isEqualRegardlessTrailerTo: theCompiledMethod)serializeInstance: arg1 with: arg2  serializationFactory  ^serializationFactory ifNil: [ self setDefaultSerialization.        serializationFactory ]initializeWith: arg1  self initialize.  fileStreamClass := arg1testBitmap  | tmp1 tmp2 |  self assertSerializationEqualityOf: (Bitmap with: 0 with: 16rFFFFFFFF).  self assertSerializationEqualityOf: (Bitmap with: 4278190080).  self assertSerializationEqualityOf: (Bitmap new: 4096).  self assertSerializationEqualityOf: (Bitmap with: 0 with: 4294967295).  self assertSerializationEqualityOf: (Bitmap new: 256).  self assertSerializationEqualityOf: (Bitmap with: 0).  tmp1 := Bitmap new: 3.  tmp1 at: 1 put: 4324.  tmp1 at: 2 put: 5674.  tmp1 at: 3 put: 8978.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: (tmp2 at: 1) equals: 4324.  self assert: (tmp2 at: 2) equals: 5674.  self assert: (tmp2 at: 3) equals: 8978keysAndValuesDo: arg1  tally = 0 ifTrue: [ ^self ].  1 to: 4096 do: [:arg2 |  | tmp1 tmp2 |        tmp1 := keys at: arg2.        tmp2 := values at: arg2.        1 to: (tallies at: arg2) do: [:arg3 |  arg1 value: (tmp1 at: arg3) value: (tmp2 at: arg3) ] ]testCompiledMethod  self assertSerializationIdentityOf: FLPair >> #lefttestCyclicLink  | tmp1 tmp2 |  tmp1 := Link new.  tmp1 nextLink: tmp1.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp2 nextLink identicalTo: tmp2materializeInstanceWith: arg1  ^arg1 nextEncodedUint64 negatedtestChangeInSuperclass  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self newClassWithInstanceVariableNames: 'a b c' superclass: Object.  tmp2 := self newClassWithInstanceVariableNames: 'd e' superclass: tmp1.  tmp3 := tmp2 new.  tmp3 instVarNamed: 'a' put: $A.  tmp3 instVarNamed: 'b' put: $B.  tmp3 instVarNamed: 'c' put: $C.  tmp3 instVarNamed: 'd' put: $D.  tmp3 instVarNamed: 'e' put: $E.  self serialize: tmp3.  tmp1 removeInstVarNamed: 'a'.  tmp1 removeInstVarNamed: 'b'.  tmp1 addInstVarNamed: 'x'.  tmp2 superclass: tmp1.  tmp4 := self materialized.  self assert: $D equals: (tmp4 instVarNamed: 'd').  self assert: $E equals: (tmp4 instVarNamed: 'e').  self should: [ tmp4 instVarNamed: 'a' ] raise: Error.  self should: [ tmp4 instVarNamed: 'b' ] raise: Error.  self assert: $C equals: (tmp4 instVarNamed: 'c').  self assert: (tmp4 instVarNamed: 'x') isNiltestNotSerializableObject  self should: [ self serialize: FLNotSerializableMock new ] raise: FLNotSerializable whoseDescriptionIncludes: FLNotSerializableMock new printString description: 'User can prevent some objects from serialization.'clusterSerializeStepWith: arg1  super clusterSerializeStepWith: arg1.  arg1 encoder encodePositiveInteger: objects sizeprivateFirstInMapperChain  ^self privateMappers firstheaderStep  decoder decodeYourself.  clusterCount := decoder nextEncodedPositiveInteger.  clusters := OrderedCollection new: clusterCount.  clusters resetTo: 1instancesStep  clusters do: [:arg1 |  arg1 registerIndexesOn: encoder ].  clusters do: [:arg1 |  self clusterInstancesStepOf: arg1 ]setUpSerializer  ^serializer := FLDelayedSerializerMock newDefaultinitializeOn: arg1 bufferSize: arg2  self initialize.  self initializeStream: arg1.  self sizeBuffer: arg2.  position := 0testSortedCollectionWithInstanceVariableReference  | tmp1 tmp2 |  instanceVariableForTesting := false.  tmp1 := self sortedBlockClosureWithInstanceVariable.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp2 addAll: #(2 3 1).  tmp1 addAll: #(2 3 1).  self assert: tmp1 asArray equals: tmp2 asArray.  self assert: tmp1 asArray equals: #(3 2 1)clusterReferencesDo: arg1  testTime  self assertSerializationEqualityOf: (Time fromSeconds: 84072).  self assertSerializationEqualityOf: (Time hour: 24 minute: 60 second: 60).  self assertSerializationEqualityOf: (Time hour: 23 minute: 59 second: 59).  self assertSerializationEqualityOf: (Time hour: 0 minute: 0 second: 0).  self assertSerializationEqualityOf: (Time seconds: 0 nanoSeconds: 5).  self assertSerializationEqualityOf: (Time allInstances sort: [:arg1 :arg2 |  arg1 asSeconds > arg2 asSeconds ]) first.  self assertSerializationEqualityOf: (Time allInstances sort: [:arg1 :arg2 |  arg1 nanoSecond > arg2 nanoSecond ]) firstfuelAccept: arg1  ^arg1 visitSubstitution: self by: niltestConsiderCustomGlobalNotFound  self analyzer considerGlobal: #FLGlobalVariableForTesting.  serializationEnvironment at: #FLGlobalVariableForTesting put: 42.  self serialize: 42.  self should: [ self materialization ] raise: FLGlobalNotFound description: 'Raise an error since the variable is not present in materialization global environment'withNotificationsNewClass  ^self classFactory withNotificationsNewClassprivateMapAndTrace: arg1  privateFirstMapper mapAndTrace: arg1testVariableRemoved  | tmp1 tmp2 tmp3 |  tmp1 := self newClassWithInstanceVariableNames: 'left right'.  tmp2 := tmp1 new.  tmp2 instVarAt: 1 put: $A.  tmp2 instVarAt: 2 put: $B.  self serialize: tmp2.  self redefined: tmp1 with: 'right'.  tmp3 := self materialized.  self assert: $B equals: (tmp3 instVarAt: 1)materializeFrom: arg1  | tmp1 tmp2 tmp3 |  tmp1 := FLDecoder on: arg1 migrations: migrations globalEnvironment: globalEnvironment.  self verifySignatureFrom: tmp1.  self verifyVersionFrom: tmp1.  tmp3 := self decodeHeaderWith: tmp1.  tmp3 executePreMaterializationActions.  tmp2 := materializationFactory value: tmp1.  tmp2 header: tmp3.  tmp3 materialization: tmp2.  tmp3 executePostMaterializationActions.  ^tmp2testWideAndByteCharacters  | tmp1 tmp2 tmp3 |  tmp3 := Character value: 12345.  tmp2 := $a.  tmp1 := self resultOfSerializeAndMaterialize: (Array with: tmp3 with: tmp2).  self assert: tmp1 first equals: tmp3.  self assert: tmp1 second identicalTo: tmp2errorKeyNotFound: arg1  KeyNotFound signalFor: arg1readIsSourceFrom: arg1 argumentNames: arg2 argumentValues: arg3  | tmp1 |  tmp1 := arg2 indexOf: 'isSource:' ifAbsent: [ ^false ].  ^arg3 at: tmp1materializeInstanceWith: arg1  | tmp1 tmp2 |  tmp2 := arg1 nextEncodedPositiveInteger.  tmp1 := theClass basicNew: tmp2.  arg1 nextEncodedBytesInto: tmp1.  ^tmp1imageName  ^self subclassResponsibilitytestLargeNegativeInteger  self assertSerializationEqualityOf: -354314316134313999999999.  self assertSerializationEqualityOf: 0 - 100 factorialmaterializeInstanceWith: arg1  ^arg1 nextEncodedUint8serializeInstance: arg1 with: arg2  arg2 encodeUint32: arg1 asciiValuetestProxyByTargetInsideObjectAndAnalisysIsPropagated  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := (self newSubclassOf: Object instanceVariableNames: 'target' classVariableNames: '')     duringTestCompileSilently: 'target: x  target := x';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: target';     yourself.  tmp4 := FLPair new.  tmp4 left: 6.  tmp4 right: 'foo'.  tmp3 := tmp1 new     target: tmp4;     yourself.  tmp5 := FLPair new     left: tmp3;     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp5.  self assert: tmp2 left left equals: 6.  self assert: tmp2 left right equals: 'foo'.  self assert: tmp2 right isNilsetUp  super setUp.  self setUpClassFactory.  self setUpSerializer.  self setUpMaterializer.  self useMemoryStreammapAndTrace: arg1  (condition value: arg1) ifTrue: [ self mapAndTraceSubstitutionIfNotRecursive: arg1 ] ifFalse: [ next mapAndTrace: arg1 ]newSecondaryTrait  ^self newTraitSuffixed: 'Secondary'absolutePathOf: arg1  ^self subclassResponsibilitypush: arg1  array at: slotIndex put: arg1.  array size = slotIndex ifTrue: [ self grow ].  slotIndex := slotIndex + 1.  ^arg1newAnalyzingCollection  ^FLLargeIdentitySet newmaterializeLiteralsTo: arg1 with: arg2  1 to: arg1 numLiterals do: [:arg3 |  arg1 literalAt: arg3 put: arg2 nextEncodedReference ]flush  ^stream flushvisitGlobalSend: arg1 name: arg2 selector: arg3  (self clusterKeyedByClusterName: FLGlobalSendCluster) add: arg1 name: arg2 selector: arg3 traceWith: analysisvisitTrait: arg1  self mapAndTraceInstanceSideGlobal: arg1serializeInstance: arg1 with: arg2  arg2 encodeUint24: arg1testVariableOrderChange  | tmp1 tmp2 tmp3 |  tmp1 := self newClassWithInstanceVariableNames: 'left right'.  tmp2 := tmp1 new.  tmp2 instVarAt: 1 put: $A.  tmp2 instVarAt: 2 put: $B.  self serialize: tmp2.  self redefined: tmp1 with: 'right left'.  tmp3 := self materialized.  self assert: $B equals: (tmp3 instVarAt: 1).  self assert: $A equals: (tmp3 instVarAt: 2)testMethodNotFoundAfterRemoval  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 duringTestCompileSilently: 'you'.  self serialize: tmp1 >> #you.  tmp1 removeSelectorSilently: #you.  self should: [ self materialized ] raise: FLMethodNotFound whoseDescriptionIncludes: tmp1 name , '>>#you' description: 'Should raise an error when method is not present.'testAllVariablesIgnored  | tmp1 tmp2 tmp3 |  tmp3 := self newClassWithInstanceVariableNames: 'a b'.  tmp3 class duringTestCompileSilently: 'fuelIgnoredInstanceVariableNames ^#(a b)'.  tmp1 := tmp3 new     instVarAt: 1 put: $A;     instVarAt: 2 put: $B;     yourself.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: (tmp2 instVarAt: 1) isNil.  self assert: (tmp2 instVarAt: 2) isNilencodeBitmap: arg1  arg1 writeOn: streamtestConsiderGlobal  | tmp1 tmp2 tmp3 |  tmp2 := Array with: Set new with: Set new.  testingEnvironment at: #GlobalSet1 put: tmp2 first.  testingEnvironment at: #GlobalSet2 put: tmp2 second.  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:arg1 |  tmp1 := FLSerializer newDefault.        tmp1 analyzer considerGlobal: #GlobalSet1.        tmp1 serialize: tmp2 on: arg1 ].  tmp3 := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:arg1 |  (FLMaterializer newDefault materializeFrom: arg1) root ].  [ (testingEnvironment at: #GlobalSet1) == tmp3 first ] assert.  [ (testingEnvironment at: #GlobalSet2) ~~ tmp3 second ] asserttestVariableRename  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self newClassWithInstanceVariableNames: 'x y'.  tmp4 := tmp1 name.  tmp2 := tmp1 new.  tmp2 instVarNamed: 'x' put: 7.  tmp2 instVarNamed: 'y' put: 11.  self serialize: tmp2.  self redefined: tmp1 with: 'posY posX'.  self materializer migrateClassNamed: tmp4 variables: {('x' -> 'posX') .         ('y' -> 'posY')}.  tmp3 := self materialized.  self assert: (tmp3 instVarNamed: 'posX') equals: 7.  self assert: (tmp3 instVarNamed: 'posY') equals: 11newClassWithInstanceVariableNames: arg1  ^self newClassWithInstanceVariableNames: arg1 superclass: ObjectanalysisStep  | tmp1 |  tmp1 := analyzer analysisFor: root.  clusters := tmp1 clusterization clusters.  encoder objectCount: tmp1 clusterization objectCountvisitTraitedMetaclass: arg1  self mapAndTraceByClusterName: arg1 to: FLGlobalClassSideClustermaterializeInstanceWith: arg1  ^(self materializeGlobalClassFrom: arg1) classSidetestSameVersion  serializer version: 1.  materializer version: 1.  self assertSerializationEqualityOf: 'content'visitHookPrimitive: arg1  self mapAndTraceByObjectClass: arg1 to: FLHookPrimitiveClustermaterializeReferencesStepWith: arg1  objects do: [:arg2 |  self materializeReferencesOf: arg2 with: arg1 ]serializePostInstancesStepWith: arg1  classNamed: arg1  ^(migrations detect: [:arg2 |  arg2 sourceClassName = arg1 ] ifNone: [ ^self globalClassNamed: arg1 ]) targetClassnewClassOrTrait  ^self newClassWithInstanceVariableNames: ''metalevelClassSideBucket  ^metalevelClassSideBuckettestUniqueSubstitution  | tmp1 |  self analyzer when: [:arg1 |  arg1 isNumber ] substituteBy: [:arg1 |  arg1 printString ].  self deny: 1 printString identicalTo: 1 printString.  tmp1 := self resultOfSerializeAndMaterialize: (Array with: 1 with: 1).  self assert: tmp1 first equals: '1'.  self assert: tmp1 first identicalTo: tmp1 second= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^self right = arg1 right and: [ self left = arg1 left ]size  ^tallytestObsolete  | tmp1 |  tmp1 := self newClassOrTrait.  self removeFromSystem: tmp1.  self should: [ self serialize: tmp1 ] raise: FLObsolete whoseDescriptionIncludes: tmp1 name description: 'Should raise an error when serializing as global an obsolete class or trait.'testBlockClosureRemoved  | tmp1 tmp2 |  tmp1 := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]';     yourself.  tmp2 := tmp1 new perform: #methodWithClosure.  self serialize: tmp2.  tmp1 removeSelectorSilently: #methodWithClosure.  self should: [ self materialized ] raise: FLMethodNotFoundsetDefaultAnalysis  analysisFactory := [:arg1 |  (FLAnalysis newWith: self firstInMapperChain private: self privateFirstInMapperChain root: arg1)     run;     yourself ]testClassAndVariableRename  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self newClassWithInstanceVariableNames: 'x y'.  tmp4 := tmp1 name.  tmp2 := tmp1 new.  tmp2 instVarNamed: 'x' put: 7.  tmp2 instVarNamed: 'y' put: 11.  self serialize: tmp2.  tmp1 renameSilently: (tmp4 , 'Renamed') asSymbol.  tmp1 := self redefined: tmp1 with: 'posY posX'.  self materializer migrateClassNamed: tmp4 toClass: tmp1 variables: {('x' -> 'posX') .         ('y' -> 'posY')}.  tmp3 := self materialized.  self assert: (tmp3 instVarNamed: 'posX') equals: 7.  self assert: (tmp3 instVarNamed: 'posY') equals: 11analyzer  ^serializer analyzeradd: arg1 substitutedBy: arg2 traceWith: arg3  substitutions at: arg1 ifAbsent: [ substitutions at: arg1 put: arg2.        substitutes add: arg2.        arg3 trace: arg2 ]newInstanceFrom: arg1  ^arg1 newtestNextIndex  | tmp1 tmp2 tmp3 |  tmp1 := #(0 1 128 255).  tmp3 := #() writeStream.  tmp2 := self indexStreamOn: tmp3 digits: 1.  tmp1 do: [:arg1 |  tmp2 nextIndexPut: arg1 ].  tmp2 := self indexStreamOn: tmp3 contents readStream digits: 1.  tmp1 do: [:arg1 |  self assert: tmp2 nextIndex equals: arg1 ]visitClassTrait: arg1  self mapAndTraceByClusterName: arg1 to: FLGlobalClassSideClusterindex: arg1  index := arg1next: arg1  next := arg1globalClassNamed: arg1  ^globalEnvironment at: arg1 ifAbsent: [ FLClassNotFound signalWithName: arg1 ]redefined: arg1 with: arg2  | tmp1 |  tmp1 := arg1 name.  self removeFromSystem: arg1.  ^(self withNotificationsNewClassWithInstanceVariableNames: arg2) renameSilently: tmp1expectedFailures  ^super expectedFailures , #(testWideString)initializeWith: arg1  self initialize.  globals := arg1testGlobalClass  materializationEnvironment at: #Integer put: FLPerson.  self assert: (self resultOfSerializeAndMaterialize: Integer) identicalTo: FLPersongtGetMetaData  | tmp1 |  tmp1 := OrderedCollection new.  tmp1 add: 'Meta' -> (String streamContents: [:arg1 |  additionalObjects do: [:arg2 |  arg2 printOn: arg1.                          arg1 crlf ] ]).  tmp1 add: 'Pre materialization actions:' -> (String streamContents: [:arg1 |  preMaterializationActions do: [:arg3 |  arg3 printOn: arg1 ] ]).  tmp1 add: 'Post materialization actions: ' -> (String streamContents: [:arg1 |  postMaterializationActions do: [:arg3 |  arg3 printOn: arg1 ] ]).  ^tmp1initializeWithClass: arg1  self initialize.  theClass := arg1tearDownClassFactory  self classFactory cleanUpat: arg1 ifAbsentPut: arg2  ^self at: arg1 ifAbsent: [ self at: arg1 put: arg2 value ]testSingletonMaterializationEnforcedNoInstance  | tmp1 tmp2 |  tmp1 := FLSingletonMockEnforced instance.  tmp1 reference: 'a reference'.  self assert: tmp1 equals: FLSingletonMockEnforced instance.  self serialize: tmp1.  FLSingletonMock reset.  tmp2 := self materialized.  self deny: tmp2 identicalTo: tmp1.  self deny: tmp2 reference isNil.  self assert: tmp2 reference equals: tmp1 reference.  FLSingletonMock resetnextEncodedInt32  | tmp1 tmp2 |  tmp1 := tmp2 := stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp2 >= 128 ifTrue: [ tmp1 := -16r100000000 + tmp1 ].  ^tmp1printOn: arg1  super printOn: arg1.  arg1     nextPutAll: '(';     print: left;     space;     print: right;     nextPutAll: ')'resultOfSerializeAndMaterialize: arg1  self serialize: arg1.  ^self materializedreadTargetClassFrom: arg1 argumentNames: arg2 argumentValues: arg3  | tmp1 |  tmp1 := Smalltalk at: (arg3 at: (arg2 indexOf: 'flExtensionOf:')) ifAbsent: [ ^nil ].  ^(arg1 method pragmas anySatisfy: [:arg4 |  arg4 key = #flExtensionClassSide ]) ifTrue: [ tmp1 class ] ifFalse: [ tmp1 ]testNestedBlockClosure  | tmp1 tmp2 |  tmp1 := [ [ 42 ] ].  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp2 in: self.  self assert: tmp2 value value equals: 42encodeHeaderWith: arg1  arg1 encodeByte: (header isEmpty ifTrue: [ 0 ] ifFalse: [ 1 ]).  header isEmpty ifFalse: [ self class newDefault serializationFactory value: header value: arg1 ]initializeWith: arg1 private: arg2 root: arg3  self initialize.  firstMapper := arg1.  privateFirstMapper := arg2.  arg1 analysis: self.  arg2 analysis: self.  root := arg3.  objectStack := FLSimpleStack new.  privateObjectStack := FLSimpleStack new.  clusterization := FLClusterization new= arg1  ^self class = arg1 classvisitWordsObject: arg1  self mapAndTraceByObjectClass: arg1 to: FLWordObjectClusterexecuteAction  self serializeStackat: arg1 ifPresent: arg2 ifAbsent: arg3  | tmp1 |  (keys at: (tmp1 := arg1 largeIdentityHash + 1)) ifNotNil: [:arg4 |  1 to: (tallies at: tmp1) do: [:arg5 |  (arg4 at: arg5) == arg1 ifTrue: [ ^arg2 cull: ((values at: tmp1) at: arg5) ] ] ].  ^arg3 valuesourceClassName  ^sourceClassNameregisterAll: arg1  objectsWriteStream nextPutAll: arg1nextEncodedUint64  | tmp1 |  tmp1 := stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  ^tmp1serializeInstance: arg1 with: arg2  arg2 encodePositiveInteger: arg1 sizetestContextWithClosure  | tmp1 tmp2 |  tmp1 := self class blockClosureContextTesting.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp2 in: selffuelAccept: arg1  ^arg1 visitSubstitution: self by: nilcompileInTarget  | tmp1 |  tmp1 := self method methodClass instanceSide perform: self method selector withArguments: (1 to: self method selector numArgs) asArray.  self targetClass compile: tmp1.  self targetClass organization classify: self selector under: self extensionProtocolNamemapAndTrace: arg1  arg1 fuelAccept: selftestProxyInsideObjectByTarget  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := (self newSubclassOf: Object instanceVariableNames: 'target' classVariableNames: '')     duringTestCompileSilently: 'target: x  target := x';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: target';     yourself.  tmp3 := tmp1 new     target: 5;     yourself.  tmp4 := FLPair new.  tmp4 left: tmp3.  tmp4 right: 'foo'.  tmp2 := self resultOfSerializeAndMaterialize: tmp4.  self assert: tmp2 left equals: 5.  self assert: tmp2 right equals: 'foo'serializeReferencesStepWith: arg1  objects do: [:arg2 |  self serializeLiteralsOf: arg2 with: arg1 ]clusterKeyedByClusterName: arg1  ^self clusterKeyedByClusterName: arg1 factory: [ arg1 newAnalyzing ]registerAll: arg1  decoder registerAll: arg1method  ^methodsetUp  super setUp.  serializationEnvironment := Dictionary new.  materializationEnvironment := Dictionary new.  self analyzer globalEnvironment: serializationEnvironment.  self materializer globalEnvironment: materializationEnvironmentdefaultBufferSize  ^8192initializeWith: arg1  self initialize.  targetStrategy := arg1newClassOrTraitWithSuperClass: arg1  ^self newClassWithInstanceVariableNames: '' superclass: arg1testPrivateExcludedAndWithConflicts  | tmp1 |  self analyzer when: [:arg1 |  FLPair == arg1 ] substituteBy: [:arg1 |  FLWeakClassMock ].  tmp1 := self resultOfSerializeAndMaterialize: {FLPair new .         FLPair}.  self assert: tmp1 first class identicalTo: FLPair.  self assert: tmp1 second identicalTo: FLWeakClassMockencodeUint24: arg1  stream     nextPut: ((arg1 bitShift: -16) bitAnd: 255);     nextPut: ((arg1 bitShift: -8) bitAnd: 255);     nextPut: (arg1 bitAnd: 255)serializeGlobalAssociationKeyed: arg1 on: arg2  arg2 encodeString: arg1testCharacter  self assertSerializationIdentityOf: $a.  FLPlatform current isSpur ifTrue: [ self assertSerializationIdentityOf: (Character value: 12345) ] ifFalse: [ self assertSerializationEqualityOf: (Character value: 12345) ].  self assertSerializationEqualityOf: Character allCharacters.  self assertSerializationEqualityOf: (Array with: $a with: (Character value: 12345))serializeReferencesOf: arg1 with: arg2  (self references at: arg1 ifAbsent: [ ^self ]) do: [:arg3 |  arg2 encodeReferenceTo: arg3 ]contents: arg1  contents := arg1fuelAccept: arg1  ^arg1 visitSubstitution: self by: nilfuelAccept: arg1  ^arg1 visitSubstitution: self by: nilsetUpSerializer  serializer := FLSerializer newDefaultuseMultiByteFileStream  streamFactory := FLFileStreamStrategy newWithMultiByteFileStreammaterialization: arg1  materialization := arg1testWideStringGlobal  | tmp1 tmp2 |  tmp1 := 'Foox' asWideString     at: 4 put: (Character value: 265);     yourself.  tmp2 := tmp1 , 'value'.  [ testingEnvironment at: tmp1 put: tmp2.  self analyzer considerGlobal: tmp1.  self shouldnt: [ self serialize: 'bar' -> tmp2 ] raise: Error.  self assert: self materialized class equals: Association.  self assert: self materialized value identicalTo: tmp1 ] ensure: [ testingEnvironment removeKey: tmp1 ]testClassSidePreservesIdentity  self assertSerializationIdentityOf: self newClassOrTrait classSidetestConsiderCustomGlobal  materializeReferencesOf: arg1 with: arg2  self subclassResponsibilitynextEncodedByte  ^stream nextfileNamed: arg1 readStreamDo: arg2  ^self subclassResponsibilityclusterKeyedByClusterName: arg1 factory: arg2  ^self clusterInstanceOf: arg1 keyInBucket: arg1 name factory: arg2header  ^headermethodWithTemp  | tmp1 |  tmp1 := 'test'.  self name.  self printStringindexStreamOn: arg1 digits: arg2  ^FLIndexStream on: arg1 digits: arg2addReferenceFrom: arg1 to: arg2  | tmp1 |  tmp1 := self references at: arg1 ifAbsentPut: [ OrderedCollection new ].  tmp1 add: arg2signature: arg1  signature := arg1clusterization  ^clusterizationclassFactory  ^classFactorycapacity  ^array sizetestFloat  {180.0 .   0.0 .   -0.0 .   11.22321 .   -11.22321 .   -132311.22321 .   1234567890.123456789 .   -1234567890.123456789 .   Float e .   Float infinity .   Float halfPi .   Float negativeZero .   Float halfPi .   Float pi} do: [:arg1 |  self assertSerializationEqualityOrIdentityOf: arg1 ]testReadStream  | tmp1 tmp2 |  tmp1 := ReadStream on: 'A'.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: $A equals: tmp1 next.  self deny: tmp2 atEnd.  self assert: $A equals: tmp2 next.  self assert: tmp2 atEndtestEmptyDictionary  self assertSerializationEqualityOf: Dictionary newtestContextWithSender  | tmp1 tmp2 tmp3 |  tmp1 := Context newForMethod: FLPair >> #method1.  tmp1 initializeWith: 23 stackPtr: 1 method: FLPair >> #method1 receiver: (FLPair new           right: 4;           left: 2) sender: nil.  tmp2 := Context newForMethod: FLPair >> #method2.  tmp2 initializeWith: 18 stackPtr: 1 method: FLPair >> #method2 receiver: (FLPair new           right: 5;           left: 6) sender: nil.  tmp1 privSender: tmp2.  tmp3 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp3 in: selfmaterializeInstanceWith: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self materializeGlobalClassFrom: arg1.  arg1 nextEncodedByte = 1 ifTrue: [ tmp1 := tmp1 classSide ].  tmp2 := arg1 nextEncodedString asSymbol.  tmp3 := tmp1 compiledMethodAt: tmp2 ifAbsent: [ FLMethodNotFound signalWith: tmp1 name and: tmp2 ].  tmp4 := arg1 nextEncodedUint16.  tmp3 bytecodesHash = tmp4 ifFalse: [ FLMethodChanged signalWith: tmp1 name and: tmp2 ].  ^tmp3setUp  super setUp.  currentTimeZone := DateAndTime localTimeZonematerializeInstanceWith: arg1  ^arg1 nextEncodedUint16nextEncodedUint32  | tmp1 |  tmp1 := stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  ^tmp1header: arg1  header := arg1clusterInstanceOf: arg1 keyInBucket: arg2 factory: arg3  | tmp1 |  tmp1 := arg1 clusterBucketIn: analysis clusterization.  ^tmp1 at: arg2 ifAbsentPut: [ arg3 value           traceWith: analysis;           yourself ]newSecondaryTrait  ^self newTraitSuffixed: 'Secondary'materializeReferencesStepWith: arg1  objects do: [:arg2 |  self materializeReferencesOf: arg2 with: arg1 ]testSetRehash  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := Set new.  tmp2 := FLPerson new id: 1.  tmp3 := FLPerson new id: 5.  tmp4 := FLPerson new id: 8.  tmp1     add: tmp2;     add: tmp3;     add: tmp4.  self assert: (tmp1 includes: tmp2).  self assert: (tmp1 includes: tmp3).  self assert: (tmp1 includes: tmp4).  tmp5 := self resultOfSerializeAndMaterialize: tmp1.  tmp6 := tmp5 detect: [:arg1 |  arg1 id = tmp2 id ].  tmp6 id: 3.  tmp5 rehash.  self assert: (tmp5 includes: tmp6)resultOfSerializeAndMaterializeMethod: arg1  self analyzer considerInternalMethod: arg1.  self serialize: arg1.  ^self materializedserializeReferencesVariablePartOf: arg1 with: arg2  (self variableReferences at: arg1 ifAbsent: [ ^self ]) do: [:arg3 |  arg2 encodeReferenceTo: arg3 ]deleteFileNamed: arg1  FLPlatform current deleteFileNamed: arg1clusters  ^clusterstestGlobalMetaclassNotFound  self serialize: Integer class.  self should: [ self materialization ] raise: FLClassNotFound description: 'Raise an error since the class is not present in materialization global environment'referencesOf: arg1 do: arg2  arg2 value: arg1 x.  arg2 value: arg1 yrun  objectStack push: root.  [ objectStack isEmpty ] whileFalse: [ self mapAndTrace: objectStack pop ].  [ privateObjectStack isEmpty ] whileFalse: [ self privateMapAndTrace: privateObjectStack pop ]version: arg1  version := arg1hash  ^contents hashmaterialization  self error: 'Disabled, instead use #materialized.'metalevelInstanceSideBucket  ^metalevelInstanceSideBucketencodeVersionWith: arg1  arg1 encodeUint16: self versionwriteStreamDo: arg1  ^FLPlatform current fileNamed: self fileName writeStreamDo: [:arg2 |  arg1 value: arg2 binary ]add: arg1 traceWith: arg2  objects addLast: arg1testSmallIntegerNegative  self assertSerializationIdentityOf: -42serializeInstance: arg1 with: arg2  arg2 encodeUint64: arg1keys  ^Array new: tally streamContents: [:arg1 |  self keysDo: [:arg2 |  arg1 nextPut: arg2 ] ]testPrivateExcluded  | tmp1 |  self analyzer when: [:arg1 |  arg1 isBehavior ] substituteBy: [:arg1 |  FLWeakClassMock ].  tmp1 := self resultOfSerializeAndMaterialize: {String new .         FLPair}.  self assert: tmp1 first class identicalTo: ByteString.  self assert: tmp1 second identicalTo: FLWeakClassMocknextEncodedUint24  | tmp1 |  tmp1 := stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  tmp1 := (tmp1 bitShift: 8) + stream next.  ^tmp1objectCount  ^self clusterBuckets sum: [:arg1 |  arg1 inject: 0 into: [:arg2 :arg3 |  arg2 + arg3 objects size ] ]serializeReferencesStepWith: arg1  objects do: [:arg2 |  self serializeReferencesOf: arg2 with: arg1 ]writeStreamDo: arg1  ^self fileStreamClass forceNewFileNamed: self fileName do: [:arg2 |  arg1 value: arg2 binary ]considerGlobal: arg1  globalSymbols add: arg1add: arg1 name: arg2 selector: arg3 traceWith: arg4  self add: arg1 traceWith: arg4.  globalSends at: arg1 ifAbsentPut: [ Association key: arg2 value: arg3 ]mapAndTraceByObjectClass: arg1 to: arg2  (self clusterKeyedByObjectClass: arg2 class: arg1 class) add: arg1 traceWith: analysisisSpur  ^trueclusterMaterializeStepWith: arg1  super clusterMaterializeStepWith: arg1.  theClass := arg1 decoder nextEncodedReferenceinitialize  super initialize.  primitivesBucket := IdentityDictionary new.  baselevelBucket := IdentityDictionary new.  globalsBucket := IdentityDictionary new.  metalevelInstanceSideBucket := IdentityDictionary new.  metalevelClassSideBucket := IdentityDictionary new.  substitutionsBucket := IdentityDictionary new.  postBaselevelBucket := IdentityDictionary newinitialize  additionalObjects := IdentityDictionary new.  preMaterializationActions := OrderedCollection new.  postMaterializationActions := OrderedCollection newfuelAccept: arg1  ^arg1 visitSubstitution: self by: nilflushBuffer  position = 0 ifTrue: [ ^self ].  position = buffer size ifTrue: [ stream nextPutAll: buffer ] ifFalse: [ streamRespondsToNextPutAllStartingAt ifTrue: [ stream next: position putAll: buffer startingAt: 1 ] ifFalse: [ stream nextPutAll: (buffer copyFrom: 1 to: position) ] ].  position := 0serializeInstance: arg1 with: arg2  arg2 encodeUint16: arg1 absnewTraitSuffixed: arg1  ^self classFactory newTraitNamed: (self traitNamePrefix , arg1) asSymbol uses: Array new tag: (self classFactory packageName , '-' , self classFactory defaultTagPostfix) asSymbolinitialize  tally := 0.  tallies := Array new: 4096 withAll: 0testSharedReferences  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := SmallInteger maxVal + 1.  tmp2 := Point x: tmp1 y: SmallInteger maxVal + 2.  tmp3 := Point x: SmallInteger maxVal + 2 y: tmp1.  tmp5 := Array with: tmp2 with: tmp3.  tmp4 := self resultOfSerializeAndMaterialize: tmp5.  self assert: tmp5 equals: tmp4.  self assert: tmp4 first x == tmp4 second y description: 'An object that is referenced twice by the graph must not be duplicated when materialized'.  self deny: tmp4 first y == tmp4 second x description: 'Two (non-literal) objects must maintain different identity even if they are equal'globalEnvironment  ^globalEnvironmentflushBufferIfFull  position = buffer size ifTrue: [ self flushBuffer ]materializeInstanceWith: arg1  ^theClass fuelNewtestColorArray  self assertSerializationEqualityOf: (ColorArray with: (Color r: 0.0 g: 0.031 b: 0.008) with: (Color r: 0.0 g: 0.07 b: 0.023))testCyclicLinksInArray  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := Link new.  tmp2 := Link new.  tmp3 := Link new.  tmp1 nextLink: tmp2.  tmp2 nextLink: tmp3.  tmp3 nextLink: tmp1.  tmp5 := self resultOfSerializeAndMaterialize: (Array with: tmp1 with: tmp2 with: tmp3).  tmp4 := tmp5 first.  self assert: tmp5 size equals: 3.  self assert: tmp4 nextLink nextLink nextLink identicalTo: tmp4.  self deny: tmp4 nextLink identicalTo: tmp4.  self deny: tmp4 nextLink nextLink identicalTo: tmp4isSpur  ^truemapAndTraceInstanceSideGlobal: arg1  (self clusterKeyedByClusterName: FLGlobalClassCluster) add: arg1 traceWith: analysistestContext  | tmp1 tmp2 |  tmp1 := Context newForMethod: FLPair >> #method1.  tmp1 initializeWith: 23 stackPtr: 1 method: FLPair >> #method1 receiver: (FLPair new           right: 4;           left: 2) sender: nil.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  tmp1 assertWellMaterializedInto: tmp2 in: selfsizeBuffer: arg1  buffer ifNotNil: [ self flushBuffer ].  buffer := (stream isBinary ifTrue: [ ByteArray ] ifFalse: [ String ]) new: arg1newClassOrTrait  ^self newTraitSuffixed: 'Main'globalSymbols  ^globalSymbolsmaterializeInstanceWith: arg1  ^arg1 nextEncodedUint16 negatedinitializeAnalyzing: arg1  self initializeAnalyzing.  theClass := arg1flush  self flushBuffer.  stream flushfuelAccept: arg1  ^arg1 visitGlobalSend: self name: #FLGlobalSendMock selector: #newInstanceToMaterializeencoder  ^encoderverifyVersionFrom: arg1  | tmp1 |  tmp1 := arg1 nextEncodedUint16.  self version = tmp1 ifFalse: [ FLBadVersion signalCurrentVersion: self version streamVersion: tmp1 ]setUp  super setUp.  self useStandardFileStreamadd: arg1 traceWith: arg2  objects addIfNotPresent: arg1 ifPresentDo: [ ^self ].  self referencesOf: arg1 do: [:arg3 |  | tmp1 |        tmp1 := arg3 fuelReplacement.        self addReferenceFrom: arg1 to: tmp1.        arg2 trace: tmp1 ].  self variablePartReferencesOf: arg1 do: [:arg3 |  | tmp1 |        tmp1 := arg3 fuelReplacement.        self addVariableReferenceFrom: arg1 to: tmp1.        arg2 trace: tmp1 ]materialization  self streamFactory readStreamDo: [:arg1 |  ^self materializer materializeFrom: arg1 ]assertSerializationIdentityOf: arg1  | tmp1 |  tmp1 := self resultOfSerializeAndMaterialize: arg1.  self assert: arg1 == tmp1 description: 'The materialized object is not the same as the serialized one'testInstalled  | tmp1 |  self useInstalled.  self assert: theCompiledMethod isInstalled.  self deny: theCompiledMethod isDoIt.  self deny: theCompiledMethod trailer hasSource.  self deny: theCompiledMethod trailer isEmpty.  self assert: theCompiledMethod trailer hasSourcePointer.  tmp1 := self resultOfSerializeAndMaterialize: theCompiledMethod.  self assert: tmp1 identicalTo: theCompiledMethodleft  ^lefttestPluggableSubstitution  | tmp1 tmp2 tmp3 |  tmp1 := Array with: 'hello' with: '' writeStream.  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:arg1 |  tmp2 := FLSerializer newDefault.        tmp2 analyzer when: [:arg2 |  arg2 isStream ] substituteBy: [:arg2 |  nil ].        tmp2 serialize: tmp1 on: arg1 ].  tmp3 := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:arg1 |  (FLMaterializer newDefault materializeFrom: arg1) root ].  self assert: tmp3 equals: (Array with: 'hello' with: nil)run  self analysisStep.  self headerStep.  self instancesStep.  self referencesStep.  self trailerStepuseGzipInMemoryStream  streamFactory := FLGZipStrategy newWithTarget: FLByteArrayStreamStrategy newserializeInstance: arg1 with: arg2  | tmp1 |  tmp1 := arg1 methodClass.  self serializeGlobalClass: tmp1 instanceSide on: arg2.  arg2 encodeByte: (tmp1 isClassSide ifTrue: [ 1 ] ifFalse: [ 0 ]).  arg2 encodeString: arg1 selector.  arg2 encodeUint16: arg1 bytecodesHashtestPush  | tmp1 |  tmp1 := FLSimpleStack new.  tmp1 push: 1.  self deny: tmp1 isEmptydecodeHeaderWith: arg1  ^arg1 nextEncodedByte = 0 ifTrue: [ FLHeader new ] ifFalse: [ (self class newDefault materializationFactory value: arg1) root ]testLotsOfCharacters  | tmp1 |  tmp1 := OrderedCollection new.  1 << 16 timesRepeat: [ tmp1 add: (1 to: 255) atRandom asCharacter ].  self assertSerializationEqualityOf: tmp1initializeWith: arg1  super initialize.  contents := arg1fuelAccept: arg1  ^arg1 visitGlobalSend: self name: #FLKeyNotPresentInSmalltalks selector: #someSelectortestGradientFillStyle  self assertSerializationEqualityOf: GradientFillStyle sampletearDownGlobalVariables  testingEnvironment removeKey: #FLGlobalVariableForTesting ifAbsent: [  ]buffer  buffer ifNil: [ self sizeBuffer: self defaultBufferSize ].  ^bufferreferencesOf: arg1 do: arg2  mapping do: [:arg3 |  arg2 value: (arg1 instVarAt: arg3) ]testAllRangeOfIntegers  1 to: 100 do: [:arg1 |  self assertSerializationEqualityOrIdentityOf: 1 << arg1.        self assertSerializationEqualityOrIdentityOf: 0 - (1 << arg1) ]fuelAccept: arg1  ^arg1 visitSubstitution: self by: nilwriteStreamDo: arg1  self subclassResponsibilitytestSingletonMaterialization  | tmp1 tmp2 |  tmp1 := FLSingletonMock instance.  tmp1 reference: 'a reference'.  self assert: tmp1 equals: FLSingletonMock instance.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self deny: tmp2 identicalTo: tmp1.  self deny: tmp2 reference isNil.  self deny: tmp2 reference identicalTo: tmp1 reference.  FLSingletonMock resettestContextWithTemp  | tmp1 tmp2 |  tmp1 := Context newForMethod: FLPair >> #methodWithTemp.  tmp1 initializeWith: nil stackPtr: 1 method: FLPair >> #methodWithTemp receiver: (FLPair new           right: 4;           left: 2) sender: nil.  tmp1 tempNamed: 'string' put: 'capo'.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: (tmp2 tempNamed: 'string') equals: 'capo'.  tmp1 assertWellMaterializedInto: tmp2 in: selfserializeInstance: arg1 with: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := self class transformationForSerializing value: arg1.  tmp1 := tmp5 header.  tmp3 := tmp5 size.  tmp4 := tmp5 initialPC.  tmp2 := tmp3 - tmp4 + 1.  arg2     encodeInt32: tmp1;     encodeUint16: tmp2.  tmp4 to: tmp3 do: [:arg3 |  arg2 encodeByte: (tmp5 at: arg3) ]addReferencesFrom: arg1 to: arg2  arg2 do: [:arg3 |  self addReferenceFrom: arg1 to: arg3 ]testFalse  self assertSerializationIdentityOf: falsematerializeGlobalClassFrom: arg1  | tmp1 |  tmp1 := arg1 nextEncodedString asSymbol.  ^arg1 classNamed: tmp1testBadVersion  serializer version: 2.  materializer version: 1.  self should: [ self resultOfSerializeAndMaterialize: 'content' ] raise: FLBadVersion whoseDescriptionIncludes: '2' description: 'The materializer should raise an error when version differs of the expected one.'initialize  super initialize.  array := Array new: 4096.  includesNil := falsemigrateClassNamed: arg1 variables: arg2  self migrateClassNamed: arg1 toClass: (self class environment at: arg1) variables: arg2testDateOffsetsChanging  | tmp1 tmp2 tmp3 |  tmp1 := TimeZone timeZones third.  tmp2 := TimeZone timeZones fourth.  DateAndTime localTimeZone: tmp1.  self assert: DateAndTime now offset equals: 1 hour.  tmp3 := Date fromDays: 37023.  self assert: tmp3 start offset equals: 0 hours.  self serialize: tmp3.  DateAndTime localTimeZone: tmp2.  self assert: DateAndTime now offset equals: 2 hours.  tmp3 := Date fromDays: 37023.  self assert: tmp3 start offset equals: 0 hours.  self assert: self materialized start offset equals: 0 hourstestStringGlobalsAndClosure  | tmp1 |  tmp1 := self resultOfSerializeAndMaterialize: (Array with: 'a string' with: Smalltalk with: [ Smalltalk vm.              'a string' ]).  self assert: tmp1 first equals: 'a string'.  self assert: tmp1 second identicalTo: SmalltalkinitializeWith: arg1  super initialize.  contents := arg1materializeInstanceWith: arg1  ^arg1 nextEncodedUint24 negatedcopyWordObjectToBuffer: arg1  | tmp1 |  tmp1 := (BitBlt toForm: (Form new hackBits: self buffer)) sourceForm: (Form new hackBits: arg1).  tmp1 combinationRule: Form over.  tmp1     sourceX: 0;     sourceY: 0;     height: arg1 byteSize // 4;     width: 4.  tmp1     destX: 0;     destY: position // 4.  tmp1 copyBitspreMaterializationActions: arg1  preMaterializationActions := arg1testConsiderCustomWideSymbolGlobal  | tmp1 tmp2 |  tmp1 := (WideString streamContents: [:arg1 |  256 to: 280 do: [:arg2 |  arg1 nextPut: arg2 asCharacter ] ]) asSymbol.  self analyzer considerGlobal: tmp1.  tmp2 := FLPerson new.  [ testingEnvironment at: tmp1 put: tmp2.  self shouldnt: [ self resultOfSerializeAndMaterialize: tmp2 ] raise: Error ] ensure: [ testingEnvironment removeKey: tmp1 ]testSubstituteUndefinedObjectInPresenceOfNil  self testSubstitute: UndefinedObject inPresenceOf: nilclusterSerializeStepWith: arg1  super clusterSerializeStepWith: arg1.  arg1 encoder encodeReferenceToClusterObjectClass: theClassresultOfSerializeAndMaterializeMethodDictionary: arg1  | tmp1 |  tmp1 := self resultOfSerializeAndMaterialize: arg1.  self assert: (tmp1 isEqualRegardlessMethodsTrailerTo: arg1)serializeInstance: arg1 with: arg2  arg2 encodePositiveInteger: arg1 basicSizeapplyTo: arg1  variables do: [:arg2 |  arg1 map: arg2 key to: arg2 value ]serializeInstance: arg1 with: arg2  self serializeGlobalAssociationKeyed: (arg2 globalEnvironment keyAtValue: arg1) on: arg2nextIndexPut: arg1  1 to: digits do: [:arg2 |  stream nextPut: (arg1 byteAt: digits + 1 - arg2) ]serializeInstance: arg1 with: arg2  arg2 encodeUint16: arg1help  ^'Serialize a portion of the current stack trace using fuel.'visitDictionary: arg1  self mapAndTraceByObjectClass: arg1 to: FLDictionaryCollectionClusterserializeReferencesVariablePartOf: arg1 with: arg2  1 to: arg1 basicSize do: [:arg3 |  arg2 encodeWeakReferenceTo: (arg1 basicAt: arg3) ]nextEncodedUint8  ^stream nextmaterializeInstanceWith: arg1  ^arg1 nextEncodedUint64materializeInstanceWith: arg1  ^theClass materializeFrom: arg1testCompiledMethodChanged  | tmp1 tmp2 |  tmp1 := self newClass     duringTestCompileSilently: 'm  ^ 42';     yourself.  tmp2 := self newClass     duringTestCompileSilently: 'm  ^ [ 42 ]';     yourself.  materializationEnvironment at: tmp1 name put: tmp2.  self serialize: tmp1 >> #m.  self should: [ self materialization ] raise: FLMethodChanged description: 'Serialized and materialized methods should have the same bytecodes.'materializeHeaderFrom: arg1  | tmp1 |  tmp1 := FLDecoder on: arg1 migrations: migrations globalEnvironment: globalEnvironment.  self verifySignatureFrom: tmp1.  self verifyVersionFrom: tmp1.  ^self decodeHeaderWith: tmp1initialize  super initialize.  self setDefaultAnalysis.  self useLightMappers.  pluggableSubstitutions := OrderedCollection new.  internalClasses := IdentitySet new.  internalMethods := IdentitySet new.  globalEnvironment := self class environment.  globalSymbols := self class defaultGlobalSymbols asIdentitySettestInstalledModified  | tmp1 tmp2 |  self useInstalled.  self assert: theCompiledMethod isInstalled.  self deny: theCompiledMethod isDoIt.  self deny: theCompiledMethod trailer hasSource.  self deny: theCompiledMethod trailer isEmpty.  self assert: theCompiledMethod trailer hasSourcePointer.  tmp1 := theCompiledMethod copy.  self deny: tmp1 isInstalled.  self deny: tmp1 isDoIt.  self deny: tmp1 trailer hasSource.  self deny: tmp1 trailer isEmpty.  self assert: tmp1 trailer hasSourcePointer.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self deny: tmp2 identicalTo: theCompiledMethod.  self deny: tmp2 identicalTo: tmp1.  self deny: tmp2 isInstalled.  self deny: tmp2 isDoIt.  self assert: tmp2 trailer hasSource.  self deny: tmp2 trailer isEmpty.  self deny: tmp2 trailer hasSourcePointertestDateAndTime  | tmp1 tmp2 |  tmp1 := Time fromSeconds: 76020.  tmp2 := Date fromSeconds: 3492288000.  self assertSerializationEqualityOf: (DateAndTime date: tmp2 time: tmp1).  tmp1 := Time hour: 24 minute: 60 second: 60.  tmp2 := Date year: 3050 month: 12 day: 31.  self assertSerializationEqualityOf: (DateAndTime date: tmp2 time: tmp1).  tmp1 := Time hour: 24 minute: 60 second: 60.  tmp2 := Date year: 1600 month: 12 day: 31.  self assertSerializationEqualityOf: (DateAndTime date: tmp2 time: tmp1)visitSubstitution: arg1 by: arg2  (self clusterKeyedByClusterName: FLSubstitutionCluster) add: arg1 substitutedBy: arg2 traceWith: analysistestNil  self assertSerializationIdentityOf: nilinitializeAnalyzing: arg1  self initializeAnalyzing.  theClass := arg1testBadDestinationVariableRename  | tmp1 tmp2 tmp3 |  tmp1 := self newClassWithInstanceVariableNames: 'x y'.  tmp3 := tmp1 name.  tmp2 := tmp1 new.  self materializer migrateClassNamed: tmp3 variables: {('x' -> 'posX')}.  self serialize: tmp2.  self should: [ self materialized ] raise: Error.  self flag: #pharoTodoadd: arg1 traceWith: arg2  objects addLast: arg1testBlockClosureChangeSameBytecodes  | tmp1 tmp2 tmp3 |  tmp1 := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 41 ]';     yourself.  tmp2 := tmp1 new perform: #methodWithClosure.  self serialize: tmp2.  tmp1 duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]'.  self deny: tmp2 method isInstalled.  tmp3 := self materialized.  self assert: tmp3 value equals: 42position  ^position + stream positionreferences  ^referencesserializeInstance: arg1 with: arg2  arg2 encodeByte: arg1 method frameSizetestDictionary  self assertSerializationEqualityOf: (Dictionary with: 1 -> 2)visitPoint: arg1  self mapAndTraceByClusterName: arg1 to: FLPointClusterinitializeAnalyzing  notIgnoredVariables := self instanceVariableNamesToSerialize.  mapping := notIgnoredVariables collect: [:arg1 |  theClass instVarIndexFor: arg1 ]testNestedDictionary  | tmp1 tmp2 |  tmp1 := Dictionary new.  tmp1 at: #child1 put: 'abcde'.  tmp2 := Dictionary new.  tmp2 at: #parent1 put: 'sample string.'.  tmp2 at: #parent2 put: 100.  tmp2 at: #parent3 put: #(10 20 30).  tmp2 at: #parent4 put: tmp1.  self assertSerializationEqualityOf: tmp1.  self assertSerializationEqualityOf: tmp2pop  slotIndex := slotIndex - 1.  ^array at: slotIndexserializeInstance: arg1 with: arg2  arg1 serializeOn: arg2initialize  super initialize.  self setDefaultMaterialization.  self signature: self class defaultSignature.  self version: self class currentVersion.  migrations := Dictionary new.  globalEnvironment := self class environmenttestInterval  self assertSerializationEqualityOf: (-10 to: 10 by: 5).  self assertSerializationEqualityOf: (-0 to: 0 by: 1).  self assertSerializationEqualityOf: (1 to: 10 by: 2).  self assertSerializationEqualityOf: (33333333333333331 to: 1444444444444444440 by: 2).  self assertSerializationEqualityOf: (0 to: 1 by: 2)initializeMaterializing  self initializeduring: arg1 rename: arg2 as: arg3  [ testingEnvironment at: arg2 name put: arg3.  ^arg1 value ] ensure: [ testingEnvironment at: arg2 name put: arg2 ]when: arg1 substituteBy: arg2  pluggableSubstitutions add: arg1 -> arg2testRectangle  self assertSerializationEqualityOf: (10 @ 20 corner: 30 @ 40).  self assertSerializationEqualityOf: (1.1 @ 2.2 corner: 3.3 @ 4.4).  self assertSerializationEqualityOf: (1.1 @ -2.2 corner: -3.3 @ 4.4)sortedBlockClosureWithInstanceVariable  ^SortedCollection sortBlock: [:arg1 :arg2 |  instanceVariableForTesting ifTrue: [ arg1 <= arg2 ] ifFalse: [ arg1 >= arg2 ] ]instVar1  ^instVar1serialize: arg1 toFileNamed: arg2  FLPlatform current fileNamed: arg2 writeStreamDo: [:arg3 |  self serialize: arg1 on: arg3 ]materializeReferencesStepWith: arg1  objects do: [:arg2 |  self materializeReferencesOf: arg2 with: arg1 ]globalEnvironment: arg1  globalEnvironment := arg1testScaledDecimal  self assertSerializationEqualityOf: 13 / 11s6.  self assertSerializationEqualityOf: -13 / 11s6.  self assertSerializationEqualityOf: 7621476292473147 / 9007199254740992s8.  self assertSerializationEqualityOf: -7621476292473147 / 9007199254740992s8.  self assertSerializationEqualityOf: -0 / 9007199254740992s8.  self assertSerializationEqualityOf: (13 / 11 asScaledDecimal: 6).  self assertSerializationEqualityOf: (11 / 13) asFloat asScaledDecimaltestSortedCollectionWithClassVariableReference  | tmp1 tmp2 |  ClassVariableForTesting := false.  tmp1 := self class sortedCollectionForTestingWithClassVariable.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  ClassVariableForTesting := true.  tmp2 addAll: #(2 3 1).  tmp1 addAll: #(2 3 1).  tmp1 sortBlock assertWellMaterializedInto: tmp2 sortBlock in: self.  self assert: tmp1 asArray equals: tmp2 asArraytrace: arg1  objectStack push: arg1testBag  | tmp1 tmp2 |  tmp1 := Bag new.  tmp1 add: 10.  tmp1 add: 20.  tmp1 add: 30.  tmp1 add: 30.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp1 ~~ tmp2.  self assert: tmp1 equals: tmp2.  self assert: tmp2 size equals: 4materializeReferencesStepWith: arg1  testDeserializedExternalAddressIsNull  | tmp1 tmp2 |  tmp1 := ExternalAddress fromAddress: 1234567890.  tmp2 := self serialize: tmp1.  tmp1 := self deserialize: tmp2.  self assert: tmp1 isNullremoveFromSystem: arg1  arg1 removeFromSystem: falsefuelAccept: arg1  ^arg1 visitSubstitution: self by: niltestContextThisContext  | tmp1 tmp2 |  tmp2 := thisContextSample.  tmp1 := self resultOfSerializeAndMaterialize: tmp2.  self deny: tmp2 identicalTo: tmp1.  self assert: tmp2 pc equals: tmp1 pc.  self assert: tmp2 stackPtr equals: tmp1 stackPtr.  self assert: tmp2 method equals: tmp1 method.  self assert: tmp2 receiver equals: tmp1 receiver.  self deny: tmp2 sender identicalTo: tmp1 sender.  self assert: tmp2 sender pc identicalTo: tmp1 sender pc.  self assert: tmp2 sender stackPtr equals: tmp1 sender stackPtrencodeWords: arg1  stream nextWordsPut: arg1testLowercaseSomeSymbols  | tmp1 |  self analyzer when: [:arg1 |  #A = arg1 ] substituteBy: [:arg1 |  #a ].  self analyzer when: [:arg1 |  #B = arg1 ] substituteBy: [:arg1 |  #b ].  tmp1 := self resultOfSerializeAndMaterialize: #(A B C).  self assert: #(a b C) equals: tmp1serializeLiteralsOf: arg1 with: arg2  arg1 fuelPrepare.  1 to: arg1 numLiterals do: [:arg3 |  arg2 encodeReferenceTo: (arg1 literalAt: arg3) ]clusterSerializeStepWith: arg1  super clusterSerializeStepWith: arg1.  variablesMapping serializeOn: arg1 encoderlightGlobalMappers  ^globalSymbols isEmpty ifTrue: [ #() ] ifFalse: [ Array with: (FLLightGlobalMapper for: globalSymbols in: self globalEnvironment) ]isEmpty  ^preMaterializationActions isEmpty and: [ postMaterializationActions isEmpty and: [ additionalObjects isEmpty ] ]testContextWithClosureContextWithOutPointerTesting  | tmp1 tmp2 |  tmp1 := self class blockClosureContextWithOutPointerTesting.  self assert: (tmp1 tempNamed: 'string') equals: 'test'.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: (tmp2 tempNamed: 'string') equals: 'test'.  tmp1 assertWellMaterializedInto: tmp2 in: selftestClassSideCompiledMethod  self assertSerializationIdentityOf: FLGlobalSendMock class >> #newInstanceToSerialize