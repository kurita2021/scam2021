testNotFoundAfterRename  | classOrTrait |  classOrTrait := self newClassOrTrait.  self serialize: classOrTrait.  classOrTrait renameSilently: (classOrTrait name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-======-useDoIt  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: false.  theCompiledMethod := theClass methodNamed: #m.  theClass methodDict at: #DoIt put: theCompiledMethod-======-useMemoryStream  streamFactory := FLMultiByteStreamStrategy new-======-testAssociationWithWeakFinalizationList  | weak association materializedAssociation object list |  object := Object new.  list := WeakFinalizationList new.  weak := WeakFinalizerItem new list: list object: object executor: nil.  association := Association key: #foo value: weak.  materializedAssociation := self resultOfSerializeAndMaterialize: association.  self assert: materializedAssociation value executor isNil.  self assert: materializedAssociation value list isNil not.  self assert: materializedAssociation value object isNil.  self assert: materializedAssociation key equals: #foo-======-headerStep  encoder encodeYourself.  encoder encodePositiveInteger: clusters size-======-signature: anObject  signature := anObject-======-grow  | newArray |  newArray := Array new: array size * 2.  newArray replaceFrom: 1 to: array size with: array startingAt: 1.  array := newArray-======-testGZip  | materialized |  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:aFileStream |  | gzip |        gzip := GZipWriteStream on: aFileStream.        FLSerializer newDefault serialize: 123 on: gzip.        gzip finish ].  materialized := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:aFileStream |  | gzip |        gzip := GZipReadStream on: aFileStream.        (FLMaterializer newDefault materializeFrom: gzip) root ].  self assert: materialized equals: 123-======-testCyclicLinks  | a b c materializedA |  a := Link new.  b := Link new.  c := Link new.  a nextLink: b.  b nextLink: c.  c nextLink: a.  materializedA := self resultOfSerializeAndMaterialize: a.  self assert: materializedA nextLink nextLink nextLink identicalTo: materializedA.  self deny: materializedA nextLink identicalTo: materializedA.  self deny: materializedA nextLink nextLink identicalTo: materializedA-======-writeStreamDo: aValuable  targetStrategy writeStreamDo: [:aStream |  ^GZipWriteStream with: aStream do: aValuable ]-======-addPreMaterializationAction: aCleanBlockClosure  aCleanBlockClosure isClean ifFalse: [ self error: 'Pre materializaton actions have to be clean closures. For more details see method BlocKClosure >> #isClean' ].  preMaterializationActions add: aCleanBlockClosure-======-clusterSerializeStepWith: aSerialization  -======-objects  ^objects-======-testNotFoundAfterRename  | classOrTrait |  classOrTrait := self newClassOrTrait.  self serialize: classOrTrait.  classOrTrait renameSilently: (classOrTrait name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-======-fileNamed: aFilename readStreamDo: aBlock  ^((Smalltalk at: #File) named: aFilename) readStreamDo: [:stream |  aBlock value: stream ]-======-classVariableForTesting: anObject  ClassVariableForTesting := anObject-======-testDontConsiderCustomGlobal  | aPerson globalName |  aPerson := FLPerson new.  globalName := #FLGlobalVariableForTesting.  [ testingEnvironment at: globalName put: aPerson.  self deny: (self resultOfSerializeAndMaterialize: aPerson) identicalTo: aPerson ] ensure: [ testingEnvironment removeKey: globalName ]-======-encodeWeakReferenceTo: anObject  indexStream nextIndexPut: (objectsIndexes at: anObject ifAbsent: [ objectsIndexes at: nil ])-======-testSubstituteCharacterInPresenceOfSomeCharacter  self testSubstitute: Character inPresenceOf: $c-======-run  self analysisStep.  self headerStep.  self instancesStep.  (Delay forMilliseconds: 100) wait.  self referencesStep.  self trailerStep-======-postCopy  super postCopy.  array := array copy.  1 to: 4096 do: [:index |  (array at: index) ifNotNil: [:list |  array at: index put: list copy ] ]-======-testLotsOfNils  self assertSerializationEqualityOf: (Array new: 1 << 16)-======-encodeUint16: aSmallInteger  stream nextPut: (aSmallInteger bitShift: -8).  stream nextPut: (aSmallInteger bitAnd: 255)-======-testExecuteAfterMaterialization  | anObject result aClass |  aClass := self newClass     addInstVarNamed: 'a';     duringTestCompileSilently: 'fuelAfterMaterialization a := #A';     yourself.  anObject := aClass new.  result := self resultOfSerializeAndMaterialize: anObject.  self assert: #A equals: (result instVarNamed: 'a')-======-id  ^#fuelOutStack-======-materializeInstanceWith: aDecoder  ^theClass new: aDecoder nextEncodedPositiveInteger-======-encodeInt24: aSmallInteger  | pos |  pos := aSmallInteger < 0 ifTrue: [ (0 - aSmallInteger bitXor: 16rFFFFFF) + 1 ] ifFalse: [ aSmallInteger ].  1 to: 3 do: [:i |  stream nextPut: (pos byteAt: 4 - i) ]-======-useAuthor: aString during: aBlock  (Smalltalk at: #Author) useAuthor: aString during: aBlock-======-variablePartReferencesOf: anObject do: aBlock  1 to: anObject basicSize do: [:index |  aBlock value: (anObject basicAt: index) ]-======-newTraitNamed: traitName inCategory: aCategory  ^self classFactory newTraitNamed: traitName asSymbol uses: Array new tag: aCategory asSymbol-======-reference  ^reference-======-materializeInstanceWith: aDecoder  ^(self materializeGlobalAssociationFrom: aDecoder) value-======-testPreMaterializationActions  | aClass |  aClass := self newSubclassNamed: #FuelPreMaterializationTestClassToBeDeleted of: Object instanceVariableNames: '' classVariableNames: 'TestClassVariable TestClassVariable2'.  aClass class     duringTestCompileSilently: 'postLoadMethod  TestClassVariable := 1';     duringTestCompileSilently: 'postLoadMethod2  TestClassVariable := 2';     duringTestCompileSilently: 'classVariable  ^TestClassVariable '.  aClass perform: #postLoadMethod.  self assert: (aClass perform: #classVariable) equals: 1.  self serializer addPreMaterializationAction: [ (Smalltalk at: #FuelPreMaterializationTestClassToBeDeleted) perform: #postLoadMethod2 ].  self serialize: aClass.  self assert: (aClass perform: #classVariable) equals: 1.  self materialized.  self assert: (aClass perform: #classVariable) equals: 2-======-at: key  | hash |  (keys at: (hash := key largeIdentityHash \\ 4096 + 1)) ifNotNil: [:keyList |  1 to: (tallies at: hash) do: [:index |  (keyList at: index) == key ifTrue: [ ^(values at: hash) at: index ] ] ].  self errorKeyNotFound: key-======-materializeReferencesVariablePartOf: anObject with: aDecoder  1 to: anObject basicSize do: [:index |  anObject basicAt: index put: aDecoder nextEncodedReference ]-======-objects  ^decoder objects-======-selector: aSymbol  selector := aSymbol-======-globalEnvironment: aDictionary  globalEnvironment := aDictionary-======-serializeStack  | date fileName |  date := DateAndTime now.  fileName := String streamContents: [:s |  s           << 'Debugger-Stack-';           << self interruptedContext receiver class instanceSide name;           << '-'.        date printYMDOn: s.        s           << '-';           print: date hour24;           print: date minute;           print: date second;           << '.fuel' ].  self class serializeTestFailureContext: self interruptedContext copyStack toFileNamed: fileName-======-objects  ^#()-======-testSetElement  self assertSerializationEqualityOf: (CollectionElement with: 3)-======-substitutionsBucket  ^substitutionsBucket-======-testMemoryStream  | anArray materializedString |  anArray := FLSerializer serializeToByteArray: 'stringToSerialize'.  materializedString := FLMaterializer materializeFromByteArray: anArray.  self assert: materializedString equals: 'stringToSerialize'-======-encodeSignatureWith: anEncoder  anEncoder encodeBytes: self signature asByteArray-======-testMethodPreservesIdentity  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: classOrTrait >> #you-======-right  ^right-======-testClassSideObsolete  | classOrTrait |  classOrTrait := self newClassOrTrait.  self removeFromSystem: classOrTrait.  self should: [ self serialize: classOrTrait ] raise: FLObsolete whoseDescriptionIncludes: classOrTrait name description: 'Should raise an error when serializing as global an obsolete class or trait.'-======-clustersSortedByAmountOfObjects  ^self clusters sorted: [:a :b |  a objects size > b objects size ]-======-nextWordsPut: aWordObject  | byteSize |  byteSize := aWordObject basicSize * 4.  byteSize > buffer size ifTrue: [ self sizeBuffer: 1 << byteSize highBit ].  ((position bitAnd: 3) = 0 and: [ byteSize < self bufferFreeSize ]) ifFalse: [ self flushBuffer ].  self copyWordObjectToBuffer: aWordObject.  position := position + byteSize-======-testSortedCollection  | aSortBlock aSortedCollection materialized |  aSortBlock := [:a :b |  a >= b ].  aSortedCollection := SortedCollection sortBlock: aSortBlock.  materialized := self resultOfSerializeAndMaterialize: aSortedCollection.  self assert: aSortedCollection sortBlock ~~ materialized sortBlock.  materialized addAll: #(2 1 3).  aSortedCollection addAll: #(2 1 3).  self assert: aSortedCollection asArray equals: materialized asArray-======-afterMaterializationStep  clusters do: [:aCluster |  aCluster afterMaterializationStepWith: decoder ]-======-mapAndTraceByClusterName: anObject to: aClusterClass  (self clusterKeyedByClusterName: aClusterClass) add: anObject traceWith: analysis-======-serializeGlobalClass: aClass on: anEncoder  aClass isObsolete ifTrue: [ FLObsolete signalWithName: aClass name ].  anEncoder encodeString: aClass name-======-additionalObjectAt: key  ^additionalObjects at: key-======-materializeReferencesOf: aRectangle with: aDecoder  aRectangle fuelSetOrigin: aDecoder nextEncodedReference @ aDecoder nextEncodedReference corner: aDecoder nextEncodedReference @ aDecoder nextEncodedReference-======-materializeInstanceWith: aDecoder  ^theClass newFromFrameSize: aDecoder nextEncodedByte-======-globalMappers  ^globalMappersFactory value-======-variableReferences  ^variableReferences ifNil: [ variableReferences := FLLargeIdentityDictionary new ]-======-isSource: aBoolean  isSource := aBoolean-======-migrateClassNamed: aSymbol toClass: aClass variables: aDictionary  migrations at: aSymbol put: (FLMigration fromClassNamed: aSymbol toClass: aClass variables: aDictionary)-======-analyzer  ^analyzer ifNil: [ analyzer := self defaultAnalyzer ]-======-initializeAnalyzing  super initializeAnalyzing.  globalSends := IdentityDictionary new-======-referencesOf: aRectangle do: aBlock  aBlock value: aRectangle origin x.  aBlock value: aRectangle origin y.  aBlock value: aRectangle corner x.  aBlock value: aRectangle corner y-======-variablesMappingFor: aClass  | variables |  variables := FLVariablesMapping materializing: aClass from: self.  migrations select: [:m |  m targetClass == aClass or: [ aClass inheritsFrom: m targetClass ] ] thenDo: [:m |  m applyTo: variables ].  ^variables-======-serializeInstance: anInteger with: anEncoder  anEncoder encodeUint32: anInteger abs-======-imageName  ^Smalltalk image shortImageName-======-executePostMaterializationActions  postMaterializationActions do: [:each |  each cull: materialization ]-======-addHacks  self class addHacks-======-testClassSideMethodPreservesIdentity  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait classSide duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: classOrTrait classSide >> #you-======-serializeInstance: aClass with: anEncoder  self serializeGlobalClass: aClass on: anEncoder-======-encodeClusterClass: aClusterClass  self encodeString: aClusterClass name-======-setUp  super setUp.  self useGzipInMemoryStream-======-printNameOn: aStream  super printNameOn: aStream.  aStream nextPut: $[.  theClass printOn: aStream.  aStream nextPut: $]-======-testJustMaterializeHeader  self serializer at: #test putAdditionalObject: 'test'.  self serializer at: 42 putAdditionalObject: 68.  self serialize: 'foo'.  self assert: (self materializationHeader additionalObjectAt: #test) equals: 'test'.  self assert: (self materializationHeader additionalObjectAt: 42) equals: 68-======-renamedMethodCopyOf: aMethod selector: aSymbol  | newMethod |  newMethod := aMethod ast selector: aSymbol yourself.  ^newMethod compiledMethod-======-materialized  ^self materialization root-======-referencesOf: anObject do: aBlock  aBlock value: anObject size.  anObject keysAndValuesDo: [:key :value |  aBlock value: key.        aBlock value: value ]-======-clusterMaterializeStepWith: aMaterialization  super clusterMaterializeStepWith: aMaterialization.  variablesMapping := aMaterialization decoder variablesMappingFor: theClass-======-defaultOrder  ^125-======-registerBehavior: aBehavior  aBehavior isTrait ifTrue: [ self classFactory createdTraits add: aBehavior ] ifFalse: [ self classFactory createdClasses add: aBehavior ]-======-traitNamePrefix  ^'FLTraitForTesting'-======-materializePostInstancesStepWith: aDecoder  -======-readStreamDo: aValuable  ^aValuable value: inMemoryStream contents readStream-======-encodeUint64: aSmallInteger  stream     nextPut: (aSmallInteger bitShift: -56);     nextPut: ((aSmallInteger bitShift: -48) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -40) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -32) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -24) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -16) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -8) bitAnd: 255);     nextPut: (aSmallInteger bitAnd: 255)-======-testBlockClosureChangeDifferentBytecodes  | aClass aClosure |  aClass := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]';     yourself.  aClosure := aClass new perform: #methodWithClosure.  self serialize: aClosure.  aClass duringTestCompileSilently: 'methodWithClosure  ^ 42'.  self should: [ self materialized ] raise: FLMethodChanged-======-