testNotFoundAfterRename  | classOrTrait |  classOrTrait := self newClassOrTrait.  self serialize: classOrTrait.  classOrTrait renameSilently: (classOrTrait name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-=JUAMPI=-useDoIt  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: false.  theCompiledMethod := theClass methodNamed: #m.  theClass methodDict at: #DoIt put: theCompiledMethod-=JUAMPI=-useMemoryStream  streamFactory := FLMultiByteStreamStrategy new-=JUAMPI=-testAssociationWithWeakFinalizationList  | weak association materializedAssociation object list |  object := Object new.  list := WeakFinalizationList new.  weak := WeakFinalizerItem new list: list object: object executor: nil.  association := Association key: #foo value: weak.  materializedAssociation := self resultOfSerializeAndMaterialize: association.  self assert: materializedAssociation value executor isNil.  self assert: materializedAssociation value list isNil not.  self assert: materializedAssociation value object isNil.  self assert: materializedAssociation key equals: #foo-=JUAMPI=-headerStep  encoder encodeYourself.  encoder encodePositiveInteger: clusters size-=JUAMPI=-signature: anObject  signature := anObject-=JUAMPI=-grow  | newArray |  newArray := Array new: array size * 2.  newArray replaceFrom: 1 to: array size with: array startingAt: 1.  array := newArray-=JUAMPI=-testGZip  | materialized |  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:aFileStream |  | gzip |        gzip := GZipWriteStream on: aFileStream.        FLSerializer newDefault serialize: 123 on: gzip.        gzip finish ].  materialized := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:aFileStream |  | gzip |        gzip := GZipReadStream on: aFileStream.        (FLMaterializer newDefault materializeFrom: gzip) root ].  self assert: materialized equals: 123-=JUAMPI=-testCyclicLinks  | a b c materializedA |  a := Link new.  b := Link new.  c := Link new.  a nextLink: b.  b nextLink: c.  c nextLink: a.  materializedA := self resultOfSerializeAndMaterialize: a.  self assert: materializedA nextLink nextLink nextLink identicalTo: materializedA.  self deny: materializedA nextLink identicalTo: materializedA.  self deny: materializedA nextLink nextLink identicalTo: materializedA-=JUAMPI=-writeStreamDo: aValuable  targetStrategy writeStreamDo: [:aStream |  ^GZipWriteStream with: aStream do: aValuable ]-=JUAMPI=-addPreMaterializationAction: aCleanBlockClosure  aCleanBlockClosure isClean ifFalse: [ self error: 'Pre materializaton actions have to be clean closures. For more details see method BlocKClosure >> #isClean' ].  preMaterializationActions add: aCleanBlockClosure-=JUAMPI=-clusterSerializeStepWith: aSerialization  -=JUAMPI=-objects  ^objects-=JUAMPI=-testNotFoundAfterRename  | classOrTrait |  classOrTrait := self newClassOrTrait.  self serialize: classOrTrait.  classOrTrait renameSilently: (classOrTrait name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-=JUAMPI=-fileNamed: aFilename readStreamDo: aBlock  ^((Smalltalk at: #File) named: aFilename) readStreamDo: [:stream |  aBlock value: stream ]-=JUAMPI=-classVariableForTesting: anObject  ClassVariableForTesting := anObject-=JUAMPI=-testDontConsiderCustomGlobal  | aPerson globalName |  aPerson := FLPerson new.  globalName := #FLGlobalVariableForTesting.  [ testingEnvironment at: globalName put: aPerson.  self deny: (self resultOfSerializeAndMaterialize: aPerson) identicalTo: aPerson ] ensure: [ testingEnvironment removeKey: globalName ]-=JUAMPI=-encodeWeakReferenceTo: anObject  indexStream nextIndexPut: (objectsIndexes at: anObject ifAbsent: [ objectsIndexes at: nil ])-=JUAMPI=-testSubstituteCharacterInPresenceOfSomeCharacter  self testSubstitute: Character inPresenceOf: $c-=JUAMPI=-run  self analysisStep.  self headerStep.  self instancesStep.  (Delay forMilliseconds: 100) wait.  self referencesStep.  self trailerStep-=JUAMPI=-postCopy  super postCopy.  array := array copy.  1 to: 4096 do: [:index |  (array at: index) ifNotNil: [:list |  array at: index put: list copy ] ]-=JUAMPI=-testLotsOfNils  self assertSerializationEqualityOf: (Array new: 1 << 16)-=JUAMPI=-encodeUint16: aSmallInteger  stream nextPut: (aSmallInteger bitShift: -8).  stream nextPut: (aSmallInteger bitAnd: 255)-=JUAMPI=-testExecuteAfterMaterialization  | anObject result aClass |  aClass := self newClass     addInstVarNamed: 'a';     duringTestCompileSilently: 'fuelAfterMaterialization a := #A';     yourself.  anObject := aClass new.  result := self resultOfSerializeAndMaterialize: anObject.  self assert: #A equals: (result instVarNamed: 'a')-=JUAMPI=-id  ^#fuelOutStack-=JUAMPI=-materializeInstanceWith: aDecoder  ^theClass new: aDecoder nextEncodedPositiveInteger-=JUAMPI=-encodeInt24: aSmallInteger  | pos |  pos := aSmallInteger < 0 ifTrue: [ (0 - aSmallInteger bitXor: 16rFFFFFF) + 1 ] ifFalse: [ aSmallInteger ].  1 to: 3 do: [:i |  stream nextPut: (pos byteAt: 4 - i) ]-=JUAMPI=-useAuthor: aString during: aBlock  (Smalltalk at: #Author) useAuthor: aString during: aBlock-=JUAMPI=-variablePartReferencesOf: anObject do: aBlock  1 to: anObject basicSize do: [:index |  aBlock value: (anObject basicAt: index) ]-=JUAMPI=-newTraitNamed: traitName inCategory: aCategory  ^self classFactory newTraitNamed: traitName asSymbol uses: Array new tag: aCategory asSymbol-=JUAMPI=-reference  ^reference-=JUAMPI=-materializeInstanceWith: aDecoder  ^(self materializeGlobalAssociationFrom: aDecoder) value-=JUAMPI=-testPreMaterializationActions  | aClass |  aClass := self newSubclassNamed: #FuelPreMaterializationTestClassToBeDeleted of: Object instanceVariableNames: '' classVariableNames: 'TestClassVariable TestClassVariable2'.  aClass class     duringTestCompileSilently: 'postLoadMethod  TestClassVariable := 1';     duringTestCompileSilently: 'postLoadMethod2  TestClassVariable := 2';     duringTestCompileSilently: 'classVariable  ^TestClassVariable '.  aClass perform: #postLoadMethod.  self assert: (aClass perform: #classVariable) equals: 1.  self serializer addPreMaterializationAction: [ (Smalltalk at: #FuelPreMaterializationTestClassToBeDeleted) perform: #postLoadMethod2 ].  self serialize: aClass.  self assert: (aClass perform: #classVariable) equals: 1.  self materialized.  self assert: (aClass perform: #classVariable) equals: 2-=JUAMPI=-at: key  | hash |  (keys at: (hash := key largeIdentityHash \\ 4096 + 1)) ifNotNil: [:keyList |  1 to: (tallies at: hash) do: [:index |  (keyList at: index) == key ifTrue: [ ^(values at: hash) at: index ] ] ].  self errorKeyNotFound: key-=JUAMPI=-materializeReferencesVariablePartOf: anObject with: aDecoder  1 to: anObject basicSize do: [:index |  anObject basicAt: index put: aDecoder nextEncodedReference ]-=JUAMPI=-objects  ^decoder objects-=JUAMPI=-selector: aSymbol  selector := aSymbol-=JUAMPI=-globalEnvironment: aDictionary  globalEnvironment := aDictionary-=JUAMPI=-serializeStack  | date fileName |  date := DateAndTime now.  fileName := String streamContents: [:s |  s           << 'Debugger-Stack-';           << self interruptedContext receiver class instanceSide name;           << '-'.        date printYMDOn: s.        s           << '-';           print: date hour24;           print: date minute;           print: date second;           << '.fuel' ].  self class serializeTestFailureContext: self interruptedContext copyStack toFileNamed: fileName-=JUAMPI=-objects  ^#()-=JUAMPI=-testSetElement  self assertSerializationEqualityOf: (CollectionElement with: 3)-=JUAMPI=-substitutionsBucket  ^substitutionsBucket-=JUAMPI=-testMemoryStream  | anArray materializedString |  anArray := FLSerializer serializeToByteArray: 'stringToSerialize'.  materializedString := FLMaterializer materializeFromByteArray: anArray.  self assert: materializedString equals: 'stringToSerialize'-=JUAMPI=-encodeSignatureWith: anEncoder  anEncoder encodeBytes: self signature asByteArray-=JUAMPI=-testMethodPreservesIdentity  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: classOrTrait >> #you-=JUAMPI=-right  ^right-=JUAMPI=-testClassSideObsolete  | classOrTrait |  classOrTrait := self newClassOrTrait.  self removeFromSystem: classOrTrait.  self should: [ self serialize: classOrTrait ] raise: FLObsolete whoseDescriptionIncludes: classOrTrait name description: 'Should raise an error when serializing as global an obsolete class or trait.'-=JUAMPI=-clustersSortedByAmountOfObjects  ^self clusters sorted: [:a :b |  a objects size > b objects size ]-=JUAMPI=-nextWordsPut: aWordObject  | byteSize |  byteSize := aWordObject basicSize * 4.  byteSize > buffer size ifTrue: [ self sizeBuffer: 1 << byteSize highBit ].  ((position bitAnd: 3) = 0 and: [ byteSize < self bufferFreeSize ]) ifFalse: [ self flushBuffer ].  self copyWordObjectToBuffer: aWordObject.  position := position + byteSize-=JUAMPI=-testSortedCollection  | aSortBlock aSortedCollection materialized |  aSortBlock := [:a :b |  a >= b ].  aSortedCollection := SortedCollection sortBlock: aSortBlock.  materialized := self resultOfSerializeAndMaterialize: aSortedCollection.  self assert: aSortedCollection sortBlock ~~ materialized sortBlock.  materialized addAll: #(2 1 3).  aSortedCollection addAll: #(2 1 3).  self assert: aSortedCollection asArray equals: materialized asArray-=JUAMPI=-afterMaterializationStep  clusters do: [:aCluster |  aCluster afterMaterializationStepWith: decoder ]-=JUAMPI=-mapAndTraceByClusterName: anObject to: aClusterClass  (self clusterKeyedByClusterName: aClusterClass) add: anObject traceWith: analysis-=JUAMPI=-serializeGlobalClass: aClass on: anEncoder  aClass isObsolete ifTrue: [ FLObsolete signalWithName: aClass name ].  anEncoder encodeString: aClass name-=JUAMPI=-additionalObjectAt: key  ^additionalObjects at: key-=JUAMPI=-materializeReferencesOf: aRectangle with: aDecoder  aRectangle fuelSetOrigin: aDecoder nextEncodedReference @ aDecoder nextEncodedReference corner: aDecoder nextEncodedReference @ aDecoder nextEncodedReference-=JUAMPI=-materializeInstanceWith: aDecoder  ^theClass newFromFrameSize: aDecoder nextEncodedByte-=JUAMPI=-globalMappers  ^globalMappersFactory value-=JUAMPI=-variableReferences  ^variableReferences ifNil: [ variableReferences := FLLargeIdentityDictionary new ]-=JUAMPI=-isSource: aBoolean  isSource := aBoolean-=JUAMPI=-migrateClassNamed: aSymbol toClass: aClass variables: aDictionary  migrations at: aSymbol put: (FLMigration fromClassNamed: aSymbol toClass: aClass variables: aDictionary)-=JUAMPI=-analyzer  ^analyzer ifNil: [ analyzer := self defaultAnalyzer ]-=JUAMPI=-initializeAnalyzing  super initializeAnalyzing.  globalSends := IdentityDictionary new-=JUAMPI=-referencesOf: aRectangle do: aBlock  aBlock value: aRectangle origin x.  aBlock value: aRectangle origin y.  aBlock value: aRectangle corner x.  aBlock value: aRectangle corner y-=JUAMPI=-variablesMappingFor: aClass  | variables |  variables := FLVariablesMapping materializing: aClass from: self.  migrations select: [:m |  m targetClass == aClass or: [ aClass inheritsFrom: m targetClass ] ] thenDo: [:m |  m applyTo: variables ].  ^variables-=JUAMPI=-serializeInstance: anInteger with: anEncoder  anEncoder encodeUint32: anInteger abs-=JUAMPI=-imageName  ^Smalltalk image shortImageName-=JUAMPI=-executePostMaterializationActions  postMaterializationActions do: [:each |  each cull: materialization ]-=JUAMPI=-addHacks  self class addHacks-=JUAMPI=-testClassSideMethodPreservesIdentity  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait classSide duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: classOrTrait classSide >> #you-=JUAMPI=-serializeInstance: aClass with: anEncoder  self serializeGlobalClass: aClass on: anEncoder-=JUAMPI=-encodeClusterClass: aClusterClass  self encodeString: aClusterClass name-=JUAMPI=-setUp  super setUp.  self useGzipInMemoryStream-=JUAMPI=-printNameOn: aStream  super printNameOn: aStream.  aStream nextPut: $[.  theClass printOn: aStream.  aStream nextPut: $]-=JUAMPI=-testJustMaterializeHeader  self serializer at: #test putAdditionalObject: 'test'.  self serializer at: 42 putAdditionalObject: 68.  self serialize: 'foo'.  self assert: (self materializationHeader additionalObjectAt: #test) equals: 'test'.  self assert: (self materializationHeader additionalObjectAt: 42) equals: 68-=JUAMPI=-renamedMethodCopyOf: aMethod selector: aSymbol  | newMethod |  newMethod := aMethod ast selector: aSymbol yourself.  ^newMethod compiledMethod-=JUAMPI=-materialized  ^self materialization root-=JUAMPI=-referencesOf: anObject do: aBlock  aBlock value: anObject size.  anObject keysAndValuesDo: [:key :value |  aBlock value: key.        aBlock value: value ]-=JUAMPI=-clusterMaterializeStepWith: aMaterialization  super clusterMaterializeStepWith: aMaterialization.  variablesMapping := aMaterialization decoder variablesMappingFor: theClass-=JUAMPI=-defaultOrder  ^125-=JUAMPI=-registerBehavior: aBehavior  aBehavior isTrait ifTrue: [ self classFactory createdTraits add: aBehavior ] ifFalse: [ self classFactory createdClasses add: aBehavior ]-=JUAMPI=-traitNamePrefix  ^'FLTraitForTesting'-=JUAMPI=-materializePostInstancesStepWith: aDecoder  -=JUAMPI=-readStreamDo: aValuable  ^aValuable value: inMemoryStream contents readStream-=JUAMPI=-encodeUint64: aSmallInteger  stream     nextPut: (aSmallInteger bitShift: -56);     nextPut: ((aSmallInteger bitShift: -48) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -40) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -32) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -24) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -16) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -8) bitAnd: 255);     nextPut: (aSmallInteger bitAnd: 255)-=JUAMPI=-testBlockClosureChangeDifferentBytecodes  | aClass aClosure |  aClass := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]';     yourself.  aClosure := aClass new perform: #methodWithClosure.  self serialize: aClosure.  aClass duringTestCompileSilently: 'methodWithClosure  ^ 42'.  self should: [ self materialized ] raise: FLMethodChanged-=JUAMPI=-