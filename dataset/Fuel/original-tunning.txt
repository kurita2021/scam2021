testTransientPairLeft  | result |  self analyzer when: [:x |  FLPair = x class and: [ x left isNil not ] ] substituteBy: [:x |  x copy left: nil ].  result := self resultOfSerializeAndMaterialize: (FLPair new           left: $A;           yourself).  self assert: result left isNilreadStreamDo: aValuable  targetStrategy readStreamDo: [:aStream |  ^GZipReadStream with: aStream do: aValuable ]testOrderedCollection  self assertSerializationEqualityOf: (OrderedCollection with: 10 with: 20)testCompleteBinaryTree  | aCollection numberOfLeafs |  numberOfLeafs := 2 raisedTo: 13.  aCollection := OrderedCollection new.  1 to: numberOfLeafs do: [:i |  aCollection add: (FLPair new                 left: 2 * i;                 right: 2 * i + 1;                 yourself) ].  [ aCollection size > 1 ] whileTrue: [ aCollection := aCollection pairsCollect: [:leftPair :rightPair |  FLPair new                 left: leftPair;                 right: rightPair;                 yourself ] ].  self assertSerializationEqualityOf: aCollectionprintOn: aStream  super printOn: aStream.  aStream nextPutAll: '->'.  substitutions printElementsOn: aStreamtestClassSideCompiledMethod  | classA classB |  classA := self newClass.  classA class duringTestCompileSilently: 'm  ^ 42'.  classB := self newClass.  classB class duringTestCompileSilently: 'm    ^    42   '.  self assert: (classA class >> #m) bytecodesHash equals: (classB class >> #m) bytecodesHash.  self deny: classA class >> #m identicalTo: classB class >> #m.  materializationEnvironment at: classA name put: classB.  self assert: (self resultOfSerializeAndMaterialize: classA class >> #m) identicalTo: classB class >> #mtestProxyByTargetAnalisysIsPropagated  | aProxyClass result pair |  self flag: #pharoTodo.  aProxyClass := (self newSubclassOf: Object instanceVariableNames: 'target' classVariableNames: '')     duringTestCompileSilently: 'target: x  target := x';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: target';     yourself.  pair := FLPair new.  pair left: 6.  pair right: 'foo'.  aProxyClass new     target: pair;     yourself.  result := self resultOfSerializeAndMaterialize: pair.  self assert: result left equals: 6.  self assert: result right equals: 'foo'expectedFailures  ^#(testConsiderCustomWideSymbolGlobal testWideStringGlobal testWideStringClassName)testConsiderCustomGlobal  self analyzer considerGlobal: #FLGlobalVariableForTesting.  serializationEnvironment at: #FLGlobalVariableForTesting put: 42.  materializationEnvironment at: #FLGlobalVariableForTesting put: 7.  self assert: (self resultOfSerializeAndMaterialize: 42) equals: 7testSet  | set materialized |  set := Set new.  set add: 10.  set add: 20.  set add: 30.  set add: 30.  materialized := self resultOfSerializeAndMaterialize: set.  self assert: set equals: materialized.  self assert: materialized size equals: 3.  self assert: (materialized includes: 10).  self assert: (materialized includes: 20).  self assert: (materialized includes: 30)materializeReferencesOf: anObject with: aDecoder  aDecoder nextEncodedPositiveInteger timesRepeat: [ anObject add: aDecoder nextEncodedReference ]testClassSideObsolete  | classOrTrait |  classOrTrait := self newClassOrTrait.  self removeFromSystem: classOrTrait.  self should: [ self serialize: classOrTrait ] raise: FLObsolete whoseDescriptionIncludes: classOrTrait name description: 'Should raise an error when serializing as global an obsolete class or trait.'hash  ^idreference: anObject  ^reference := anObjectdeleteFileNamed: aFilename  ((Smalltalk at: #File) named: aFilename) deletetearDown  #('demo.fuel' 'numbers.fuel' 'number.fuel.zip' 'example.FL') do: [:each |  self deleteFileNamed: each ].  testingEnvironment removeKey: #GlobalSet1 ifAbsent: [  ].  testingEnvironment removeKey: #GlobalSet2 ifAbsent: [  ].  super tearDownincludes: anObject  anObject ifNil: [ ^includesNil ].  ^(array at: anObject largeIdentityHash \\ 4096 + 1) ifNil: [ false ] ifNotNil: [:list |  list fuelPointsTo: anObject ]initializeWith: anEncoder root: anObject analyzer: anAnalyzer  self initialize.  encoder := anEncoder.  root := anObject fuelReplacement.  analyzer := anAnalyzerserializeInstancesStepWith: anEncoder  testSerializingShortDelay  | process |  process := [ 2 timesRepeat: [ | d |        d := Delay forMilliseconds: 50.        d wait ] ] forkAt: Processor userBackgroundPriority.  self shouldnt: [ self serialize: process ] raise: FLObjectNotFoundfileNamed: aFilename writeStreamDo: aBlock  ^self subclassResponsibilityserializeReferencesOf: anObject with: anEncoder  (self references at: anObject ifAbsent: [ ^self ]) do: [:value |  anEncoder encodeReferenceTo: value ]testSmallIntegerMinValue  self assertSerializationIdentityOf: SmallInteger minValfuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: niluseBinaryFileStream  streamFactory := FLFileStreamStrategy newWithBinaryFileStreamvisitBytesObject: anObject  self mapAndTraceByObjectClass: anObject to: FLByteObjectClusternextPutAll: collection  self flushBufferIfFull.  collection size <= self bufferFreeSize ifTrue: [ self buffer replaceFrom: position + 1 to: position + collection size with: collection.        position := position + collection size ] ifFalse: [ self flushBuffer.        collection size > (self buffer size / 2) ifTrue: [ stream nextPutAll: collection ] ifFalse: [ self nextPutAll: collection ] ]testDate  self assertSerializationEqualityOf: (Date fromDays: 37023).  self assertSerializationEqualityOf: Date today.  self assertSerializationEqualityOf: (Date year: 3050 month: 12 day: 31).  self assertSerializationEqualityOf: (Date year: 1600 month: 12 day: 31)visitRectangle: aRectangle  self mapAndTraceByClusterName: aRectangle to: FLRectangleClustervisitSmallInteger: aSmallInteger  self mapAndTraceByClusterName: aSmallInteger to: (self clusterClassForSmallInteger: aSmallInteger)fileStreamClass  ^fileStreamClassmaterializeInstancesStepWith: aDecoder  testByteArrays  self assertSerializationEqualityOf: {#[1 2 3 4 5 6] .         #[1 2 3 4 5 6] .         #[7 8 9 10 11 12] .         #[7 8 9 10 11 12]}.  self assertSerializationEqualityOf: (ByteArray with: 10 with: 20 with: 30).  self assertSerializationEqualityOf: ByteArray new.  self assertSerializationEqualityOf: (ByteArray new: 100).  self assertSerializationEqualityOf: (0 to: 255) asByteArraymaterializeInstanceWith: aDecoder  ^0 @ 0id  ^idpostCopy  super postCopy.  keys := keys copy.  values := values copy.  1 to: 4096 do: [:index |  (keys at: index) ifNotNil: [:list |  keys at: index put: list copy.              values at: index put: (values at: index) copy ] ]initializeAnalyzing  self initializemapAndTrace: anObject  self subclassResponsibilitytestWideString  self shouldnt: [ self assertSerializationEqualityOf: 'aString' asWideString.        self assertSerializationEqualityOf: (WideString streamContents: [:stream |  2000 timesRepeat: [ stream nextPut: (256 to: 1000) atRandom asCharacter ] ]) ] raise: ErrorvisitMetaclass: aMetaclass  self mapAndTraceByClusterName: aMetaclass to: FLGlobalClassSideClustertestContextWithNilPc  | context1 materializedContext1 |  context1 := Context newForMethod: FLPair >> #method1.  context1 initializeWith: nil stackPtr: 1 method: FLPair >> #method1 receiver: (FLPair new           right: 4;           left: 2) sender: nil.  materializedContext1 := self resultOfSerializeAndMaterialize: context1.  context1 assertWellMaterializedInto: materializedContext1 in: selfdecoder  ^decodernewSubclassOf: aClass instanceVariableNames: ivNamesString classVariableNames: classVarsString  ^self classFactory silentlyNewSubclassOf: aClass instanceVariableNames: ivNamesString classVariableNames: classVarsStringserializeInstancesStepWith: anEncoder  initializeClassNamed: aSymbol toClass: aClass variables: anArray  self initialize.  sourceClassName := aSymbol.  targetClass := aClass.  variables := anArraytestDemo  | sourceArray loadedArray |  sourceArray := Array with: 'a string' with: Smalltalk with: [ Smalltalk vm.        'a string' ].  FLSerializer serialize: sourceArray toFileNamed: 'example.FL'.  loadedArray := FLMaterializer materializeFromFileNamed: 'example.FL'.  [ sourceArray ~~ loadedArray ] assert.  [ sourceArray first ~~ loadedArray first ] assert.  [ sourceArray first = loadedArray first ] assert.  [ sourceArray second == loadedArray second ] assert.  self assert: loadedArray third value equals: 'a string'materializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint8 negatedsetDefaultMaterialization  materializationFactory := [:aDecoder |  (FLMaterialization with: aDecoder)     run;     yourself ]clusterClassForSmallInteger: aSmallInteger  aSmallInteger >= 0 ifTrue: [ aSmallInteger <= 255 ifTrue: [ ^FLPositive8SmallIntegerCluster ].        aSmallInteger <= 65535 ifTrue: [ ^FLPositive16SmallIntegerCluster ].        aSmallInteger <= 16777215 ifTrue: [ ^FLPositive24SmallIntegerCluster ].        aSmallInteger <= 4294967295 ifTrue: [ ^FLPositive32SmallIntegerCluster ].        aSmallInteger <= 1152921504606846975 ifTrue: [ ^FLPositive64SmallIntegerCluster ] ].  aSmallInteger >= -128 ifTrue: [ ^FLNegative8SmallIntegerCluster ].  aSmallInteger >= -32768 ifTrue: [ ^FLNegative16SmallIntegerCluster ].  aSmallInteger >= -8388608 ifTrue: [ ^FLNegative24SmallIntegerCluster ].  aSmallInteger >= -2147483648 ifTrue: [ ^FLNegative32SmallIntegerCluster ].  aSmallInteger >= -1152921504606846976 ifTrue: [ ^FLNegative64SmallIntegerCluster ].  self error: 'SmallInteger is out of range'testNextIndexPut  | indexStream targetStream |  targetStream := #() writeStream.  indexStream := self indexStreamOn: targetStream digits: 1.  indexStream nextIndexPut: 0.  indexStream nextIndexPut: 1testVariableInsertion  | pairClass aPair resultPair |  pairClass := self newClassWithInstanceVariableNames: 'left right'.  aPair := pairClass new.  aPair instVarAt: 1 put: $A.  aPair instVarAt: 2 put: $B.  self serialize: aPair.  self redefined: pairClass with: 'left middle right'.  resultPair := self materialized.  self assert: $A equals: (resultPair instVarAt: 1).  self assert: nil equals: (resultPair instVarAt: 2).  self assert: $B equals: (resultPair instVarAt: 3)testLargePositiveInteger  self assertSerializationEqualityOf: 354314316134313999999999.  self assertSerializationEqualityOf: 100 factorialtestPoint  self assertSerializationEqualityOf: 10 @ 20.  self assertSerializationEqualityOf: -10 @ 20.  self assertSerializationEqualityOf: -10 @ -20.  self assertSerializationEqualityOf: 1.1 @ 2.2.  self assertSerializationEqualityOf: 1.1 @ -2.2copySelector: aSelector ofMethod: aCompiledMethod toClass: aClass  aClass addAndClassifySelector: aSelector withMethod: aCompiledMethod copy inProtocol: self extensionProtocolNamedecodeYourself  | objectCount |  objectCount := self nextEncodedPositiveInteger.  indexStream := FLIndexStream on: stream digits: objectCount bytesCount.  objects := Array new: objectCount.  objectsWriteStream := WriteStream on: objects.  isBigEndian := self nextEncodedPositiveIntegerfirstInMapperChain  ^self mappers firsttestWordArray  self assertSerializationEqualityOf: (WordArray with: 10 with: 20)addPostMaterializationAction: aCleanBlockClosure  aCleanBlockClosure isClean ifFalse: [ self error: 'Post materializaton actions have to be clean closures. For more details see method BlocKClosure >> #isClean' ].  postMaterializationActions add: aCleanBlockClosurematerializeReferencesStepWith: aDecoder  objects do: [:aCompiledMethod |  self materializeLiteralsTo: aCompiledMethod with: aDecoder ]visitCompiledMethod: aCompiledMethod  (aCompiledMethod isInstalled not or: [ aCompiledMethod isDoIt ]) ifTrue: [ self mapAndTraceByClusterName: aCompiledMethod to: FLCompiledMethodCluster ] ifFalse: [ self mapAndTraceByClusterName: aCompiledMethod to: FLGlobalCompiledMethodCluster ]serializeInstance: anObject with: anEncoder  anEncoder encodePositiveInteger: anObject basicSize.  anEncoder encodeBytes: anObjectsetUp  super setUp.  FLSingletonMock resetmaterializeReferencesOf: aPoint with: aDecoder  aPoint setX: aDecoder nextEncodedReference setY: aDecoder nextEncodedReferenceexecutePreMaterializationActions  preMaterializationActions do: [:each |  each value ]testPop  | stack |  stack := FLSimpleStack new.  stack push: 1.  stack pop.  self assert: stack isEmptytestSetWithNil  self assertSerializationEqualityOf: (Set with: nil)testClassSidePreservesIdentity  self assertSerializationIdentityOf: self newClassOrTrait classSidematerializeReferencesOf: anObject with: aDecoder  self subclassResponsibilitytestDateOffsets  | bst sast materialized object |  bst := TimeZone timeZones third.  sast := TimeZone timeZones fourth.  DateAndTime localTimeZone: bst.  self assert: DateAndTime now offset equals: 1 hour.  object := Date fromDays: 37023.  self assert: object start offset equals: 0 hours.  materialized := self resultOfSerializeAndMaterialize: object.  self assert: materialized start offset equals: 0 hours.  DateAndTime localTimeZone: sast.  self assert: DateAndTime now offset equals: 2 hours.  object := Date fromDays: 37023.  self assert: object start offset equals: 0 hours.  materialized := self resultOfSerializeAndMaterialize: object.  self assert: materialized start offset equals: 0 hoursmaterializeGlobalAssociationFrom: aDecoder  | globalName |  globalName := aDecoder nextEncodedString asSymbol.  ^aDecoder globalEnvironment associationAt: globalName ifAbsent: [ FLGlobalNotFound signalWithName: globalName ]encodeReferenceTo: anObject  | index |  index := substitutionIndexes at: anObject ifAbsent: [ objectsIndexes at: anObject ifAbsent: [ FLObjectNotFound signalWith: anObject ] ].  indexStream nextIndexPut: indextestRemoteString  | aRemoteString materializedRemoteString |  aRemoteString := SourceFiles remoteStringAt: thisContext method sourcePointer.  materializedRemoteString := self resultOfSerializeAndMaterialize: aRemoteString.  self assert: aRemoteString string equals: materializedRemoteString string.  self assert: aRemoteString sourcePointer identicalTo: materializedRemoteString sourcePointerclassVariableForTesting  ^ClassVariableForTestingtearDown  DateAndTime localTimeZone: currentTimeZone.  super tearDownnewAnalyzingCollection  ^OrderedCollection newinitializeOn: aStream globalEnvironment: aDictionary  self initialize.  stream := FLBufferedWriteStream on: aStream.  globalEnvironment := aDictionarytearDown  materialized  ^FLMaterializer materializeFromByteArray: byteArrayverifySignatureFrom: aDecoder  | streamSignature |  streamSignature := ByteArray new: self signature size.  aDecoder nextEncodedBytesInto: streamSignature.  self signature asByteArray = streamSignature ifFalse: [ FLBadSignature signalCurrentSignature: self signature streamSignature: streamSignature ]materializeInstanceWith: aDecoder  ^self subclassResponsibilityreferencesOf: anObject do: aBlock  aBlock value: anObject size.  anObject do: [:each |  aBlock value: each ]setTestTimeLimitFor: aTest to: aDuration  aTest timeLimit: aDurationtestSystemDictionary  self assertSerializationEqualityOf: SystemDictionary newtestString  self assertSerializationEqualityOf: 'testString'.  self assertSerializationEqualityOf: 'Hi, I''m String-object'.  self assertSerializationEqualityOf: String new.  self assertSerializationEqualityOf: (0 to: 255) asByteArray asStringserializeInstance: anInteger with: anEncoder  anEncoder encodeUint8: anInteger