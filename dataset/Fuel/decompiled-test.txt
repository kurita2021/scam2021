testNotFoundAfterRename  | tmp1 |  tmp1 := self newClassOrTrait.  self serialize: tmp1.  tmp1 renameSilently: (tmp1 name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-======-useDoIt  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: false.  theCompiledMethod := theClass methodNamed: #m.  theClass methodDict at: #DoIt put: theCompiledMethod-======-useMemoryStream  streamFactory := FLMultiByteStreamStrategy new-======-testAssociationWithWeakFinalizationList  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := Object new.  tmp5 := WeakFinalizationList new.  tmp1 := WeakFinalizerItem new list: tmp5 object: tmp4 executor: nil.  tmp2 := Association key: #foo value: tmp1.  tmp3 := self resultOfSerializeAndMaterialize: tmp2.  self assert: tmp3 value executor isNil.  self assert: tmp3 value list isNil not.  self assert: tmp3 value object isNil.  self assert: tmp3 key equals: #foo-======-headerStep  encoder encodeYourself.  encoder encodePositiveInteger: clusters size-======-signature: arg1  signature := arg1-======-grow  | tmp1 |  tmp1 := Array new: array size * 2.  tmp1 replaceFrom: 1 to: array size with: array startingAt: 1.  array := tmp1-======-testGZip  | tmp1 |  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:arg1 |  | tmp2 |        tmp2 := GZipWriteStream on: arg1.        FLSerializer newDefault serialize: 123 on: tmp2.        tmp2 finish ].  tmp1 := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:arg1 |  | tmp2 |        tmp2 := GZipReadStream on: arg1.        (FLMaterializer newDefault materializeFrom: tmp2) root ].  self assert: tmp1 equals: 123-======-testCyclicLinks  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Link new.  tmp2 := Link new.  tmp3 := Link new.  tmp1 nextLink: tmp2.  tmp2 nextLink: tmp3.  tmp3 nextLink: tmp1.  tmp4 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp4 nextLink nextLink nextLink identicalTo: tmp4.  self deny: tmp4 nextLink identicalTo: tmp4.  self deny: tmp4 nextLink nextLink identicalTo: tmp4-======-writeStreamDo: arg1  targetStrategy writeStreamDo: [:arg2 |  ^GZipWriteStream with: arg2 do: arg1 ]-======-addPreMaterializationAction: arg1  arg1 isClean ifFalse: [ self error: 'Pre materializaton actions have to be clean closures. For more details see method BlocKClosure >> #isClean' ].  preMaterializationActions add: arg1-======-clusterSerializeStepWith: arg1  -======-objects  ^objects-======-testNotFoundAfterRename  | tmp1 |  tmp1 := self newClassOrTrait.  self serialize: tmp1.  tmp1 renameSilently: (tmp1 name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-======-fileNamed: arg1 readStreamDo: arg2  ^((Smalltalk at: #File) named: arg1) readStreamDo: [:arg3 |  arg2 value: arg3 ]-======-classVariableForTesting: arg1  ClassVariableForTesting := arg1-======-testDontConsiderCustomGlobal  | tmp1 tmp2 |  tmp1 := FLPerson new.  tmp2 := #FLGlobalVariableForTesting.  [ testingEnvironment at: tmp2 put: tmp1.  self deny: (self resultOfSerializeAndMaterialize: tmp1) identicalTo: tmp1 ] ensure: [ testingEnvironment removeKey: tmp2 ]-======-encodeWeakReferenceTo: arg1  indexStream nextIndexPut: (objectsIndexes at: arg1 ifAbsent: [ objectsIndexes at: nil ])-======-testSubstituteCharacterInPresenceOfSomeCharacter  self testSubstitute: Character inPresenceOf: $c-======-run  self analysisStep.  self headerStep.  self instancesStep.  (Delay forMilliseconds: 100) wait.  self referencesStep.  self trailerStep-======-postCopy  super postCopy.  array := array copy.  1 to: 4096 do: [:arg1 |  (array at: arg1) ifNotNil: [:arg2 |  array at: arg1 put: arg2 copy ] ]-======-testLotsOfNils  self assertSerializationEqualityOf: (Array new: 1 << 16)-======-encodeUint16: arg1  stream nextPut: (arg1 bitShift: -8).  stream nextPut: (arg1 bitAnd: 255)-======-testExecuteAfterMaterialization  | tmp1 tmp2 tmp3 |  tmp3 := self newClass     addInstVarNamed: 'a';     duringTestCompileSilently: 'fuelAfterMaterialization a := #A';     yourself.  tmp1 := tmp3 new.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: #A equals: (tmp2 instVarNamed: 'a')-======-id  ^#fuelOutStack-======-materializeInstanceWith: arg1  ^theClass new: arg1 nextEncodedPositiveInteger-======-encodeInt24: arg1  | tmp1 |  tmp1 := arg1 < 0 ifTrue: [ (0 - arg1 bitXor: 16rFFFFFF) + 1 ] ifFalse: [ arg1 ].  1 to: 3 do: [:arg2 |  stream nextPut: (tmp1 byteAt: 4 - arg2) ]-======-useAuthor: arg1 during: arg2  (Smalltalk at: #Author) useAuthor: arg1 during: arg2-======-variablePartReferencesOf: arg1 do: arg2  1 to: arg1 basicSize do: [:arg3 |  arg2 value: (arg1 basicAt: arg3) ]-======-newTraitNamed: arg1 inCategory: arg2  ^self classFactory newTraitNamed: arg1 asSymbol uses: Array new tag: arg2 asSymbol-======-reference  ^reference-======-materializeInstanceWith: arg1  ^(self materializeGlobalAssociationFrom: arg1) value-======-testPreMaterializationActions  | tmp1 |  tmp1 := self newSubclassNamed: #FuelPreMaterializationTestClassToBeDeleted of: Object instanceVariableNames: '' classVariableNames: 'TestClassVariable TestClassVariable2'.  tmp1 class     duringTestCompileSilently: 'postLoadMethod  TestClassVariable := 1';     duringTestCompileSilently: 'postLoadMethod2  TestClassVariable := 2';     duringTestCompileSilently: 'classVariable  ^TestClassVariable '.  tmp1 perform: #postLoadMethod.  self assert: (tmp1 perform: #classVariable) equals: 1.  self serializer addPreMaterializationAction: [ (Smalltalk at: #FuelPreMaterializationTestClassToBeDeleted) perform: #postLoadMethod2 ].  self serialize: tmp1.  self assert: (tmp1 perform: #classVariable) equals: 1.  self materialized.  self assert: (tmp1 perform: #classVariable) equals: 2-======-at: arg1  | tmp1 |  (keys at: (tmp1 := arg1 largeIdentityHash \\ 4096 + 1)) ifNotNil: [:arg2 |  1 to: (tallies at: tmp1) do: [:arg3 |  (arg2 at: arg3) == arg1 ifTrue: [ ^(values at: tmp1) at: arg3 ] ] ].  self errorKeyNotFound: arg1-======-materializeReferencesVariablePartOf: arg1 with: arg2  1 to: arg1 basicSize do: [:arg3 |  arg1 basicAt: arg3 put: arg2 nextEncodedReference ]-======-objects  ^decoder objects-======-selector: arg1  selector := arg1-======-globalEnvironment: arg1  globalEnvironment := arg1-======-serializeStack  | tmp1 tmp2 |  tmp1 := DateAndTime now.  tmp2 := String streamContents: [:arg1 |  arg1           << 'Debugger-Stack-';           << self interruptedContext receiver class instanceSide name;           << '-'.        tmp1 printYMDOn: arg1.        arg1           << '-';           print: tmp1 hour24;           print: tmp1 minute;           print: tmp1 second;           << '.fuel' ].  self class serializeTestFailureContext: self interruptedContext copyStack toFileNamed: tmp2-======-objects  ^#()-======-testSetElement  self assertSerializationEqualityOf: (CollectionElement with: 3)-======-substitutionsBucket  ^substitutionsBucket-======-testMemoryStream  | tmp1 tmp2 |  tmp1 := FLSerializer serializeToByteArray: 'stringToSerialize'.  tmp2 := FLMaterializer materializeFromByteArray: tmp1.  self assert: tmp2 equals: 'stringToSerialize'-======-encodeSignatureWith: arg1  arg1 encodeBytes: self signature asByteArray-======-testMethodPreservesIdentity  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: tmp1 >> #you-======-right  ^right-======-testClassSideObsolete  | tmp1 |  tmp1 := self newClassOrTrait.  self removeFromSystem: tmp1.  self should: [ self serialize: tmp1 ] raise: FLObsolete whoseDescriptionIncludes: tmp1 name description: 'Should raise an error when serializing as global an obsolete class or trait.'-======-clustersSortedByAmountOfObjects  ^self clusters sorted: [:arg1 :arg2 |  arg1 objects size > arg2 objects size ]-======-nextWordsPut: arg1  | tmp1 |  tmp1 := arg1 basicSize * 4.  tmp1 > buffer size ifTrue: [ self sizeBuffer: 1 << tmp1 highBit ].  ((position bitAnd: 3) = 0 and: [ tmp1 < self bufferFreeSize ]) ifFalse: [ self flushBuffer ].  self copyWordObjectToBuffer: arg1.  position := position + tmp1-======-testSortedCollection  | tmp1 tmp2 tmp3 |  tmp1 := [:arg1 :arg2 |  arg1 >= arg2 ].  tmp2 := SortedCollection sortBlock: tmp1.  tmp3 := self resultOfSerializeAndMaterialize: tmp2.  self assert: tmp2 sortBlock ~~ tmp3 sortBlock.  tmp3 addAll: #(2 1 3).  tmp2 addAll: #(2 1 3).  self assert: tmp2 asArray equals: tmp3 asArray-======-afterMaterializationStep  clusters do: [:arg1 |  arg1 afterMaterializationStepWith: decoder ]-======-mapAndTraceByClusterName: arg1 to: arg2  (self clusterKeyedByClusterName: arg2) add: arg1 traceWith: analysis-======-serializeGlobalClass: arg1 on: arg2  arg1 isObsolete ifTrue: [ FLObsolete signalWithName: arg1 name ].  arg2 encodeString: arg1 name-======-additionalObjectAt: arg1  ^additionalObjects at: arg1-======-materializeReferencesOf: arg1 with: arg2  arg1 fuelSetOrigin: arg2 nextEncodedReference @ arg2 nextEncodedReference corner: arg2 nextEncodedReference @ arg2 nextEncodedReference-======-materializeInstanceWith: arg1  ^theClass newFromFrameSize: arg1 nextEncodedByte-======-globalMappers  ^globalMappersFactory value-======-variableReferences  ^variableReferences ifNil: [ variableReferences := FLLargeIdentityDictionary new ]-======-isSource: arg1  isSource := arg1-======-migrateClassNamed: arg1 toClass: arg2 variables: arg3  migrations at: arg1 put: (FLMigration fromClassNamed: arg1 toClass: arg2 variables: arg3)-======-analyzer  ^analyzer ifNil: [ analyzer := self defaultAnalyzer ]-======-initializeAnalyzing  super initializeAnalyzing.  globalSends := IdentityDictionary new-======-referencesOf: arg1 do: arg2  arg2 value: arg1 origin x.  arg2 value: arg1 origin y.  arg2 value: arg1 corner x.  arg2 value: arg1 corner y-======-variablesMappingFor: arg1  | tmp1 |  tmp1 := FLVariablesMapping materializing: arg1 from: self.  migrations select: [:arg2 |  arg2 targetClass == arg1 or: [ arg1 inheritsFrom: arg2 targetClass ] ] thenDo: [:arg2 |  arg2 applyTo: tmp1 ].  ^tmp1-======-serializeInstance: arg1 with: arg2  arg2 encodeUint32: arg1 abs-======-imageName  ^Smalltalk image shortImageName-======-executePostMaterializationActions  postMaterializationActions do: [:arg1 |  arg1 cull: materialization ]-======-addHacks  self class addHacks-======-testClassSideMethodPreservesIdentity  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 classSide duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: tmp1 classSide >> #you-======-serializeInstance: arg1 with: arg2  self serializeGlobalClass: arg1 on: arg2-======-encodeClusterClass: arg1  self encodeString: arg1 name-======-setUp  super setUp.  self useGzipInMemoryStream-======-printNameOn: arg1  super printNameOn: arg1.  arg1 nextPut: $[.  theClass printOn: arg1.  arg1 nextPut: $]-======-testJustMaterializeHeader  self serializer at: #test putAdditionalObject: 'test'.  self serializer at: 42 putAdditionalObject: 68.  self serialize: 'foo'.  self assert: (self materializationHeader additionalObjectAt: #test) equals: 'test'.  self assert: (self materializationHeader additionalObjectAt: 42) equals: 68-======-renamedMethodCopyOf: arg1 selector: arg2  | tmp1 |  tmp1 := arg1 ast selector: arg2 yourself.  ^tmp1 compiledMethod-======-materialized  ^self materialization root-======-referencesOf: arg1 do: arg2  arg2 value: arg1 size.  arg1 keysAndValuesDo: [:arg3 :arg4 |  arg2 value: arg3.        arg2 value: arg4 ]-======-clusterMaterializeStepWith: arg1  super clusterMaterializeStepWith: arg1.  variablesMapping := arg1 decoder variablesMappingFor: theClass-======-defaultOrder  ^125-======-registerBehavior: arg1  arg1 isTrait ifTrue: [ self classFactory createdTraits add: arg1 ] ifFalse: [ self classFactory createdClasses add: arg1 ]-======-traitNamePrefix  ^'FLTraitForTesting'-======-materializePostInstancesStepWith: arg1  -======-readStreamDo: arg1  ^arg1 value: inMemoryStream contents readStream-======-encodeUint64: arg1  stream     nextPut: (arg1 bitShift: -56);     nextPut: ((arg1 bitShift: -48) bitAnd: 255);     nextPut: ((arg1 bitShift: -40) bitAnd: 255);     nextPut: ((arg1 bitShift: -32) bitAnd: 255);     nextPut: ((arg1 bitShift: -24) bitAnd: 255);     nextPut: ((arg1 bitShift: -16) bitAnd: 255);     nextPut: ((arg1 bitShift: -8) bitAnd: 255);     nextPut: (arg1 bitAnd: 255)-======-testBlockClosureChangeDifferentBytecodes  | tmp1 tmp2 |  tmp1 := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]';     yourself.  tmp2 := tmp1 new perform: #methodWithClosure.  self serialize: tmp2.  tmp1 duringTestCompileSilently: 'methodWithClosure  ^ 42'.  self should: [ self materialized ] raise: FLMethodChanged-======-