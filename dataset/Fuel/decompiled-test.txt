testNotFoundAfterRename  | tmp1 |  tmp1 := self newClassOrTrait.  self serialize: tmp1.  tmp1 renameSilently: (tmp1 name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-=JUAMPI=-useDoIt  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: false.  theCompiledMethod := theClass methodNamed: #m.  theClass methodDict at: #DoIt put: theCompiledMethod-=JUAMPI=-useMemoryStream  streamFactory := FLMultiByteStreamStrategy new-=JUAMPI=-testAssociationWithWeakFinalizationList  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := Object new.  tmp5 := WeakFinalizationList new.  tmp1 := WeakFinalizerItem new list: tmp5 object: tmp4 executor: nil.  tmp2 := Association key: #foo value: tmp1.  tmp3 := self resultOfSerializeAndMaterialize: tmp2.  self assert: tmp3 value executor isNil.  self assert: tmp3 value list isNil not.  self assert: tmp3 value object isNil.  self assert: tmp3 key equals: #foo-=JUAMPI=-headerStep  encoder encodeYourself.  encoder encodePositiveInteger: clusters size-=JUAMPI=-signature: arg1  signature := arg1-=JUAMPI=-grow  | tmp1 |  tmp1 := Array new: array size * 2.  tmp1 replaceFrom: 1 to: array size with: array startingAt: 1.  array := tmp1-=JUAMPI=-testGZip  | tmp1 |  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:arg1 |  | tmp2 |        tmp2 := GZipWriteStream on: arg1.        FLSerializer newDefault serialize: 123 on: tmp2.        tmp2 finish ].  tmp1 := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:arg1 |  | tmp2 |        tmp2 := GZipReadStream on: arg1.        (FLMaterializer newDefault materializeFrom: tmp2) root ].  self assert: tmp1 equals: 123-=JUAMPI=-testCyclicLinks  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Link new.  tmp2 := Link new.  tmp3 := Link new.  tmp1 nextLink: tmp2.  tmp2 nextLink: tmp3.  tmp3 nextLink: tmp1.  tmp4 := self resultOfSerializeAndMaterialize: tmp1.  self assert: tmp4 nextLink nextLink nextLink identicalTo: tmp4.  self deny: tmp4 nextLink identicalTo: tmp4.  self deny: tmp4 nextLink nextLink identicalTo: tmp4-=JUAMPI=-writeStreamDo: arg1  targetStrategy writeStreamDo: [:arg2 |  ^GZipWriteStream with: arg2 do: arg1 ]-=JUAMPI=-addPreMaterializationAction: arg1  arg1 isClean ifFalse: [ self error: 'Pre materializaton actions have to be clean closures. For more details see method BlocKClosure >> #isClean' ].  preMaterializationActions add: arg1-=JUAMPI=-clusterSerializeStepWith: arg1  -=JUAMPI=-objects  ^objects-=JUAMPI=-testNotFoundAfterRename  | tmp1 |  tmp1 := self newClassOrTrait.  self serialize: tmp1.  tmp1 renameSilently: (tmp1 name , 'Renamed') asSymbol.  self should: [ self materialized ] raise: FLClassNotFound-=JUAMPI=-fileNamed: arg1 readStreamDo: arg2  ^((Smalltalk at: #File) named: arg1) readStreamDo: [:arg3 |  arg2 value: arg3 ]-=JUAMPI=-classVariableForTesting: arg1  ClassVariableForTesting := arg1-=JUAMPI=-testDontConsiderCustomGlobal  | tmp1 tmp2 |  tmp1 := FLPerson new.  tmp2 := #FLGlobalVariableForTesting.  [ testingEnvironment at: tmp2 put: tmp1.  self deny: (self resultOfSerializeAndMaterialize: tmp1) identicalTo: tmp1 ] ensure: [ testingEnvironment removeKey: tmp2 ]-=JUAMPI=-encodeWeakReferenceTo: arg1  indexStream nextIndexPut: (objectsIndexes at: arg1 ifAbsent: [ objectsIndexes at: nil ])-=JUAMPI=-testSubstituteCharacterInPresenceOfSomeCharacter  self testSubstitute: Character inPresenceOf: $c-=JUAMPI=-run  self analysisStep.  self headerStep.  self instancesStep.  (Delay forMilliseconds: 100) wait.  self referencesStep.  self trailerStep-=JUAMPI=-postCopy  super postCopy.  array := array copy.  1 to: 4096 do: [:arg1 |  (array at: arg1) ifNotNil: [:arg2 |  array at: arg1 put: arg2 copy ] ]-=JUAMPI=-testLotsOfNils  self assertSerializationEqualityOf: (Array new: 1 << 16)-=JUAMPI=-encodeUint16: arg1  stream nextPut: (arg1 bitShift: -8).  stream nextPut: (arg1 bitAnd: 255)-=JUAMPI=-testExecuteAfterMaterialization  | tmp1 tmp2 tmp3 |  tmp3 := self newClass     addInstVarNamed: 'a';     duringTestCompileSilently: 'fuelAfterMaterialization a := #A';     yourself.  tmp1 := tmp3 new.  tmp2 := self resultOfSerializeAndMaterialize: tmp1.  self assert: #A equals: (tmp2 instVarNamed: 'a')-=JUAMPI=-id  ^#fuelOutStack-=JUAMPI=-materializeInstanceWith: arg1  ^theClass new: arg1 nextEncodedPositiveInteger-=JUAMPI=-encodeInt24: arg1  | tmp1 |  tmp1 := arg1 < 0 ifTrue: [ (0 - arg1 bitXor: 16rFFFFFF) + 1 ] ifFalse: [ arg1 ].  1 to: 3 do: [:arg2 |  stream nextPut: (tmp1 byteAt: 4 - arg2) ]-=JUAMPI=-useAuthor: arg1 during: arg2  (Smalltalk at: #Author) useAuthor: arg1 during: arg2-=JUAMPI=-variablePartReferencesOf: arg1 do: arg2  1 to: arg1 basicSize do: [:arg3 |  arg2 value: (arg1 basicAt: arg3) ]-=JUAMPI=-newTraitNamed: arg1 inCategory: arg2  ^self classFactory newTraitNamed: arg1 asSymbol uses: Array new tag: arg2 asSymbol-=JUAMPI=-reference  ^reference-=JUAMPI=-materializeInstanceWith: arg1  ^(self materializeGlobalAssociationFrom: arg1) value-=JUAMPI=-testPreMaterializationActions  | tmp1 |  tmp1 := self newSubclassNamed: #FuelPreMaterializationTestClassToBeDeleted of: Object instanceVariableNames: '' classVariableNames: 'TestClassVariable TestClassVariable2'.  tmp1 class     duringTestCompileSilently: 'postLoadMethod  TestClassVariable := 1';     duringTestCompileSilently: 'postLoadMethod2  TestClassVariable := 2';     duringTestCompileSilently: 'classVariable  ^TestClassVariable '.  tmp1 perform: #postLoadMethod.  self assert: (tmp1 perform: #classVariable) equals: 1.  self serializer addPreMaterializationAction: [ (Smalltalk at: #FuelPreMaterializationTestClassToBeDeleted) perform: #postLoadMethod2 ].  self serialize: tmp1.  self assert: (tmp1 perform: #classVariable) equals: 1.  self materialized.  self assert: (tmp1 perform: #classVariable) equals: 2-=JUAMPI=-at: arg1  | tmp1 |  (keys at: (tmp1 := arg1 largeIdentityHash \\ 4096 + 1)) ifNotNil: [:arg2 |  1 to: (tallies at: tmp1) do: [:arg3 |  (arg2 at: arg3) == arg1 ifTrue: [ ^(values at: tmp1) at: arg3 ] ] ].  self errorKeyNotFound: arg1-=JUAMPI=-materializeReferencesVariablePartOf: arg1 with: arg2  1 to: arg1 basicSize do: [:arg3 |  arg1 basicAt: arg3 put: arg2 nextEncodedReference ]-=JUAMPI=-objects  ^decoder objects-=JUAMPI=-selector: arg1  selector := arg1-=JUAMPI=-globalEnvironment: arg1  globalEnvironment := arg1-=JUAMPI=-serializeStack  | tmp1 tmp2 |  tmp1 := DateAndTime now.  tmp2 := String streamContents: [:arg1 |  arg1           << 'Debugger-Stack-';           << self interruptedContext receiver class instanceSide name;           << '-'.        tmp1 printYMDOn: arg1.        arg1           << '-';           print: tmp1 hour24;           print: tmp1 minute;           print: tmp1 second;           << '.fuel' ].  self class serializeTestFailureContext: self interruptedContext copyStack toFileNamed: tmp2-=JUAMPI=-objects  ^#()-=JUAMPI=-testSetElement  self assertSerializationEqualityOf: (CollectionElement with: 3)-=JUAMPI=-substitutionsBucket  ^substitutionsBucket-=JUAMPI=-testMemoryStream  | tmp1 tmp2 |  tmp1 := FLSerializer serializeToByteArray: 'stringToSerialize'.  tmp2 := FLMaterializer materializeFromByteArray: tmp1.  self assert: tmp2 equals: 'stringToSerialize'-=JUAMPI=-encodeSignatureWith: arg1  arg1 encodeBytes: self signature asByteArray-=JUAMPI=-testMethodPreservesIdentity  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: tmp1 >> #you-=JUAMPI=-right  ^right-=JUAMPI=-testClassSideObsolete  | tmp1 |  tmp1 := self newClassOrTrait.  self removeFromSystem: tmp1.  self should: [ self serialize: tmp1 ] raise: FLObsolete whoseDescriptionIncludes: tmp1 name description: 'Should raise an error when serializing as global an obsolete class or trait.'-=JUAMPI=-clustersSortedByAmountOfObjects  ^self clusters sorted: [:arg1 :arg2 |  arg1 objects size > arg2 objects size ]-=JUAMPI=-nextWordsPut: arg1  | tmp1 |  tmp1 := arg1 basicSize * 4.  tmp1 > buffer size ifTrue: [ self sizeBuffer: 1 << tmp1 highBit ].  ((position bitAnd: 3) = 0 and: [ tmp1 < self bufferFreeSize ]) ifFalse: [ self flushBuffer ].  self copyWordObjectToBuffer: arg1.  position := position + tmp1-=JUAMPI=-testSortedCollection  | tmp1 tmp2 tmp3 |  tmp1 := [:arg1 :arg2 |  arg1 >= arg2 ].  tmp2 := SortedCollection sortBlock: tmp1.  tmp3 := self resultOfSerializeAndMaterialize: tmp2.  self assert: tmp2 sortBlock ~~ tmp3 sortBlock.  tmp3 addAll: #(2 1 3).  tmp2 addAll: #(2 1 3).  self assert: tmp2 asArray equals: tmp3 asArray-=JUAMPI=-afterMaterializationStep  clusters do: [:arg1 |  arg1 afterMaterializationStepWith: decoder ]-=JUAMPI=-mapAndTraceByClusterName: arg1 to: arg2  (self clusterKeyedByClusterName: arg2) add: arg1 traceWith: analysis-=JUAMPI=-serializeGlobalClass: arg1 on: arg2  arg1 isObsolete ifTrue: [ FLObsolete signalWithName: arg1 name ].  arg2 encodeString: arg1 name-=JUAMPI=-additionalObjectAt: arg1  ^additionalObjects at: arg1-=JUAMPI=-materializeReferencesOf: arg1 with: arg2  arg1 fuelSetOrigin: arg2 nextEncodedReference @ arg2 nextEncodedReference corner: arg2 nextEncodedReference @ arg2 nextEncodedReference-=JUAMPI=-materializeInstanceWith: arg1  ^theClass newFromFrameSize: arg1 nextEncodedByte-=JUAMPI=-globalMappers  ^globalMappersFactory value-=JUAMPI=-variableReferences  ^variableReferences ifNil: [ variableReferences := FLLargeIdentityDictionary new ]-=JUAMPI=-isSource: arg1  isSource := arg1-=JUAMPI=-migrateClassNamed: arg1 toClass: arg2 variables: arg3  migrations at: arg1 put: (FLMigration fromClassNamed: arg1 toClass: arg2 variables: arg3)-=JUAMPI=-analyzer  ^analyzer ifNil: [ analyzer := self defaultAnalyzer ]-=JUAMPI=-initializeAnalyzing  super initializeAnalyzing.  globalSends := IdentityDictionary new-=JUAMPI=-referencesOf: arg1 do: arg2  arg2 value: arg1 origin x.  arg2 value: arg1 origin y.  arg2 value: arg1 corner x.  arg2 value: arg1 corner y-=JUAMPI=-variablesMappingFor: arg1  | tmp1 |  tmp1 := FLVariablesMapping materializing: arg1 from: self.  migrations select: [:arg2 |  arg2 targetClass == arg1 or: [ arg1 inheritsFrom: arg2 targetClass ] ] thenDo: [:arg2 |  arg2 applyTo: tmp1 ].  ^tmp1-=JUAMPI=-serializeInstance: arg1 with: arg2  arg2 encodeUint32: arg1 abs-=JUAMPI=-imageName  ^Smalltalk image shortImageName-=JUAMPI=-executePostMaterializationActions  postMaterializationActions do: [:arg1 |  arg1 cull: materialization ]-=JUAMPI=-addHacks  self class addHacks-=JUAMPI=-testClassSideMethodPreservesIdentity  | tmp1 |  tmp1 := self newClassOrTrait.  tmp1 classSide duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: tmp1 classSide >> #you-=JUAMPI=-serializeInstance: arg1 with: arg2  self serializeGlobalClass: arg1 on: arg2-=JUAMPI=-encodeClusterClass: arg1  self encodeString: arg1 name-=JUAMPI=-setUp  super setUp.  self useGzipInMemoryStream-=JUAMPI=-printNameOn: arg1  super printNameOn: arg1.  arg1 nextPut: $[.  theClass printOn: arg1.  arg1 nextPut: $]-=JUAMPI=-testJustMaterializeHeader  self serializer at: #test putAdditionalObject: 'test'.  self serializer at: 42 putAdditionalObject: 68.  self serialize: 'foo'.  self assert: (self materializationHeader additionalObjectAt: #test) equals: 'test'.  self assert: (self materializationHeader additionalObjectAt: 42) equals: 68-=JUAMPI=-renamedMethodCopyOf: arg1 selector: arg2  | tmp1 |  tmp1 := arg1 ast selector: arg2 yourself.  ^tmp1 compiledMethod-=JUAMPI=-materialized  ^self materialization root-=JUAMPI=-referencesOf: arg1 do: arg2  arg2 value: arg1 size.  arg1 keysAndValuesDo: [:arg3 :arg4 |  arg2 value: arg3.        arg2 value: arg4 ]-=JUAMPI=-clusterMaterializeStepWith: arg1  super clusterMaterializeStepWith: arg1.  variablesMapping := arg1 decoder variablesMappingFor: theClass-=JUAMPI=-defaultOrder  ^125-=JUAMPI=-registerBehavior: arg1  arg1 isTrait ifTrue: [ self classFactory createdTraits add: arg1 ] ifFalse: [ self classFactory createdClasses add: arg1 ]-=JUAMPI=-traitNamePrefix  ^'FLTraitForTesting'-=JUAMPI=-materializePostInstancesStepWith: arg1  -=JUAMPI=-readStreamDo: arg1  ^arg1 value: inMemoryStream contents readStream-=JUAMPI=-encodeUint64: arg1  stream     nextPut: (arg1 bitShift: -56);     nextPut: ((arg1 bitShift: -48) bitAnd: 255);     nextPut: ((arg1 bitShift: -40) bitAnd: 255);     nextPut: ((arg1 bitShift: -32) bitAnd: 255);     nextPut: ((arg1 bitShift: -24) bitAnd: 255);     nextPut: ((arg1 bitShift: -16) bitAnd: 255);     nextPut: ((arg1 bitShift: -8) bitAnd: 255);     nextPut: (arg1 bitAnd: 255)-=JUAMPI=-testBlockClosureChangeDifferentBytecodes  | tmp1 tmp2 |  tmp1 := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]';     yourself.  tmp2 := tmp1 new perform: #methodWithClosure.  self serialize: tmp2.  tmp1 duringTestCompileSilently: 'methodWithClosure  ^ 42'.  self should: [ self materialized ] raise: FLMethodChanged-=JUAMPI=-