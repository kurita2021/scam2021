trailerStep  encoder encodeReferenceTo: rootanalysisFor: anObject  ^analysisFactory value: anObjectclusterReferencesDo: aBlock  aBlock value: theClasstestSmalltalkGlobals  self assertSerializationIdentityOf: Smalltalk globalsmaterializer  ^materializertestExceptions  | ex |  ex := Error new messageText: 'sample error'.  self assert: (self resultOfSerializeAndMaterialize: ex) messageText equals: ex messageText.  ex := Warning new messageText: 'sample warning'.  self assert: (self resultOfSerializeAndMaterialize: ex) messageText equals: ex messageText.  ex := Notification new messageText: 'sample notification'.  self assert: (self resultOfSerializeAndMaterialize: ex) messageText equals: ex messageTextobjects  ^encoder objectsIndexes keystearDown  self     tearDownClassFactory;     tearDownGlobalVariables.  self streamFactory tearDown.  self tearDownInstanceVariables.  super tearDowntestTrue  self assertSerializationIdentityOf: trueencodeString: aString  | length |  (length := aString size) < 192 ifTrue: [ stream nextPut: length ] ifFalse: [ stream nextPut: (length byteAt: 4) + 192.        stream nextPut: (length byteAt: 3).        stream nextPut: (length byteAt: 2).        stream nextPut: (length byteAt: 1) ].  stream nextBytesPutAll: aStringserializeInstance: anInteger with: anEncoder  anEncoder encodeUint32: anIntegerdeserialize: aByteArray  ^FLMaterializer materializeFromByteArray: aByteArraynextEncodedClusterClass  ^self class environment at: self nextEncodedString asSymboltargetClass  ^targetClassclusters  ^self clusterBuckets flatCollect: [:c |  c ]referencesOf: aCompiledMethod do: aBlock  aCompiledMethod fuelPrepare.  1 to: aCompiledMethod numLiterals do: [:index |  aBlock value: (aCompiledMethod literalAt: index) ]serializeOn: anEncoder  anEncoder encodeByte: notIgnoredVariables size.  notIgnoredVariables do: [:name |  anEncoder encodeString: name ]addIfNotPresent: anObject ifPresentDo: aBlock  | hash |  anObject ifNil: [ includesNil ifFalse: [ includesNil := true.              tally := tally + 1 ].        ^anObject ].  (array at: (hash := anObject largeIdentityHash \\ 4096 + 1)) ifNil: [ array at: hash put: (Array with: anObject).        tallies at: hash put: 1.        tally := tally + 1 ] ifNotNil: [:list |  (list fuelPointsTo: anObject) ifTrue: [ aBlock value ] ifFalse: [ | newIndex |              tally := tally + 1.              list size < (newIndex := (tallies at: hash) + 1) ifFalse: [ list at: newIndex put: anObject ] ifTrue: [ | newList |                    newList := Array new: list size * 2.                    newList                       replaceFrom: 1 to: list size with: list startingAt: 1;                       at: newIndex put: anObject.                    array at: hash put: newList ].              tallies at: hash put: newIndex ] ].  ^anObjectregisterIndexesOn: anEncoder  self flag: #pharoTodo.  objects := objects asIdentitySet.  super registerIndexesOn: anEncoderclusterMaterializeStepWith: aMaterialization  fuelAfterMaterialization  self become: contentstestAvoidRecursion  | result |  self analyzer when: [:x |  x < 10 ] substituteBy: [:x |  x + 1 ].  result := self resultOfSerializeAndMaterialize: 1.  self assert: result equals: 2testBlockClosureWithSelfSend  | closure materializedClosure |  closure := self class blockClosureWithSelfSend.  materializedClosure := self resultOfSerializeAndMaterialize: closure.  closure assertWellMaterializedInto: materializedClosure in: self.  self assert: materializedClosure value equals: closure valuematerializeInstanceWith: aDecoder  | inst wideSize |  wideSize := aDecoder nextEncodedPositiveInteger.  inst := theClass basicNew: wideSize.  aDecoder nextEncodedWordsInto: inst.  aDecoder isBigEndian = FLPlatform current isBigEndian asBit ifTrue: [ ^inst ] ifFalse: [ ^self swapBytesOf: inst ]testSetWithSetElement  self assertSerializationEqualityOf: (Set with: (CollectionElement with: 3))serializeReferencesStepWith: anEncoder  objects do: [:anObject |  self serializeReferencesOf: anObject with: anEncoder ]newClassWithInstanceVariableNames: instanceVariableNames superclass: aSuperclass  ^self newSubclassOf: aSuperclass instanceVariableNames: instanceVariableNames classVariableNames: ''serializationOf: anObject  self streamFactory writeStreamDo: [:aStream |  ^serializer serialize: anObject on: aStream ]printNameOn: aStream  super printNameOn: aStream.  aStream nextPut: $[.  theClass printOn: aStream.  aStream nextPut: $]version: anObject  version := anObjectleft: anObject  left := anObjecttestClassRename  | pointClass aPoint resultPoint pointClassName |  pointClass := self newClassWithInstanceVariableNames: 'x y'.  pointClassName := pointClass name.  aPoint := pointClass new.  aPoint instVarNamed: 'x' put: 7.  aPoint instVarNamed: 'y' put: 11.  self serialize: aPoint.  pointClass renameSilently: (pointClassName , 'Renamed') asSymbol.  self materializer migrateClassNamed: pointClassName toClass: pointClass.  resultPoint := self materialized.  self assert: (resultPoint instVarNamed: 'x') equals: 7.  self assert: (resultPoint instVarNamed: 'y') equals: 11serializeInstancesStepWith: anEncoder  testEmptyArray  self assertSerializationEqualityOf: #()testColor  self assertSerializationEqualityOf: Color blue.  self assertSerializationEqualityOf: Color blackprivateMappers  ^OrderedCollection new     addAll: self globalMappers;     add: self generalMapper;     reduceRight: [:left :right |  left next: right ];     yourselfvisitMetaclassForTraits: aMetaclass  self mapAndTraceByClusterName: aMetaclass to: FLGlobalClassSideClusterclusterInstancesStepOf: aCluster  encoder encodeClusterClass: aCluster class.  aCluster clusterSerializeStepWith: self.  aCluster serializeInstancesStepWith: encoder.  aCluster serializePostInstancesStepWith: encodertestFileStream  | materializedString |  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:aStream |  FLSerializer newDefault serialize: 'stringToSerialize' on: aStream ].  materializedString := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:aStream |  (FLMaterializer newDefault materializeFrom: aStream) root ].  self assert: materializedString equals: 'stringToSerialize'swapBytesOf: aWordObject  Bitmap swapBytesIn: aWordObject from: 1 to: aWordObject basicSize.  ^aWordObjectright: anObject  right := anObjectmapAndTrace: anObject  firstMapper mapAndTrace: anObject fuelReplacementtestDuration  self assertSerializationEqualityOf: 123 seconds.  self assertSerializationEqualityOf: -123 seconds.  self assertSerializationEqualityOf: (Duration seconds: 3 nanoSeconds: 35)afterMaterializationStepWith: aDecoder  objects do: [:anObject |  anObject fuelAfterMaterialization ]deleteFileNamed: aFilename  self subclassResponsibilityat: key put: value  | hash |  (keys at: (hash := key largeIdentityHash \\ 4096 + 1)) ifNil: [ keys at: hash put: (Array with: key).        values at: hash put: (Array with: value).        tallies at: hash put: 1.        tally := tally + 1 ] ifNotNil: [:keyList |  | newIndex |        1 to: (tallies at: hash) do: [:index |  (keyList at: index) == key ifTrue: [ ^(values at: hash) at: index put: value ] ].        tally := tally + 1.        keyList size < (newIndex := (tallies at: hash) + 1) ifFalse: [ keyList at: newIndex put: key.              (values at: hash) at: newIndex put: value ] ifTrue: [ | newList |              (newList := Array new: keyList size * 2)                 replaceFrom: 1 to: keyList size with: keyList startingAt: 1;                 at: newIndex put: key.              keys at: hash put: newList.              (newList := Array new: keyList size * 2)                 replaceFrom: 1 to: keyList size with: (values at: hash) startingAt: 1;                 at: newIndex put: value.              values at: hash put: newList ].        tallies at: hash put: newIndex ].  ^valueuseNotInstalled  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: false.  theCompiledMethod := theClass methodNamed: #m.  theClass methodDict removeKey: #mreferencesOf: anObject do: aBlock  testWideStringClassName  | class className |  className := 'Foox' asWideString     at: 4 put: (Character value: 265);     yourself.  class := Class new     setName: className;     yourself.  [ testingEnvironment at: class name put: class.  self shouldnt: [ self resultOfSerializeAndMaterialize: class ] raise: Error ] ensure: [ testingEnvironment removeKey: class name ]add: anObject traceWith: aAnalysis  objects addIfNotPresent: anObject ifPresentDo: [ ^self ].  self referencesOf: anObject do: [:aChild |  | actual |        actual := aChild fuelReplacement.        self addReferenceFrom: anObject to: actual.        aAnalysis trace: actual ]testDictionaryRehash  | aDictionary person1 person2 person3 materializedDict newPerson1 |  aDictionary := Dictionary new.  person1 := FLPerson new id: 1.  person2 := FLPerson new id: 5.  person3 := FLPerson new id: 8.  aDictionary     at: person1 put: person1;     at: person2 put: person2;     at: person3 put: person3.  self assert: (aDictionary at: person1) equals: person1.  self assert: (aDictionary at: person2) equals: person2.  self assert: (aDictionary at: person3) equals: person3.  materializedDict := self resultOfSerializeAndMaterialize: aDictionary.  newPerson1 := materializedDict keys detect: [:each |  each id = person1 id ].  newPerson1 id: 3.  materializedDict rehash.  self assert: (materializedDict includesKey: newPerson1)install  self targetClass ifNil: [ ^self ].  self isSource ifTrue: [ ^self compileInTarget ].  self selector = self method selector ifFalse: [ ^self renameAndCompileInTarget ].  self copyToTargetmaterializeInstanceWith: aDecoder  | global selector |  global := (self materializeGlobalAssociationFrom: aDecoder) value.  selector := aDecoder nextEncodedString asSymbol.  ^global perform: selectornewAnalyzingCollection  ^OrderedCollection newreferencesStep  clusters do: [:aCluster |  aCluster materializeReferencesStepWith: decoder ]testAvoidRecursion  | result original |  original := FLClassWithRecursiveSubstitution new index: 1.  result := self resultOfSerializeAndMaterialize: original.  self assert: result index equals: 2initializeOn: aStream migrations: aCollection globalEnvironment: aDictionary  self initialize.  stream := aStream.  migrations := aCollection.  globalEnvironment := aDictionarytestGlobalNotFound  self should: [ self resultOfSerializeAndMaterialize: FLGlobalSendNotPresentMock new ] raise: FLGlobalNotFound whoseDescriptionIncludes: #FLKeyNotPresentInSmalltalks description: 'Should raise an error when global name is not present in Smalltalks globals.'stream: aStream  stream := aStreamafterMaterializationStepWith: aDecoder  objects do: [:anObject |  anObject fuelAfterMaterialization ]initializeAnalyzing  super initializeAnalyzing.  substitutions := IdentityDictionary new.  substitutes := IdentitySet newtestSubstituteByItself  | aRecursiveClass result |  aRecursiveClass := (self newSubclassOf: Object instanceVariableNames: '' classVariableNames: '')     duringTestCompileSilently: 'fuelAccept: aMapper  			^aMapper 				visitSubstitution: self by: self 				onRecursionDo: [super fuelAccept: aMapper]';     yourself.  result := self resultOfSerializeAndMaterialize: aRecursiveClass newnextEncodedBytesInto: aBytesObject  stream next: aBytesObject basicSize into: aBytesObjectinitialize  super initialize.  keys := Array new: 4096.  values := Array new: 4096testOneIgnoredVariable  | anObject result aClass |  aClass := self newClassWithInstanceVariableNames: 'a b c'.  aClass class duringTestCompileSilently: 'fuelIgnoredInstanceVariableNames ^#(b)'.  anObject := aClass new     instVarAt: 1 put: $A;     instVarAt: 2 put: $B;     instVarAt: 3 put: $C;     yourself.  result := self resultOfSerializeAndMaterialize: anObject.  self assert: $A equals: (result instVarAt: 1).  self assert: nil equals: (result instVarAt: 2).  self assert: $C equals: (result instVarAt: 3)fuelAccept: aGeneralMapper  aGeneralMapper visitNotSerializable: selfmaterializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint32 negatedreadStreamDo: aValuable  ^self fileStreamClass oldFileNamed: self fileName do: [:aStream |  aValuable value: aStream binary ]materializedObjects  ^self materialization objectstestDoIt  | context |  FLPlatform current setTestTimeLimitFor: self to: 30 seconds.  [ Smalltalk compiler evaluate: 'self error' ] on: Error do: [:error |  context := error signalerContext copyStack ].  self serialize: contextencodeInt32: aSmallInteger  | pos |  pos := aSmallInteger < 0 ifTrue: [ (0 - aSmallInteger) bitInvert32 + 1 ] ifFalse: [ aSmallInteger ].  1 to: 4 do: [:i |  stream nextPut: (pos byteAt: 5 - i) ]ignoreMe  ^ignoreMe := truecopyToTarget  FLPlatform current addAndClassifySelector: self selector inClass: self targetClass withMethod: self method copy inProtocol: self extensionProtocolNameversion  ^versiontestGlobalClassNotFound  self serialize: Integer.  self should: [ self materialization ] raise: FLClassNotFound description: 'Raise an error since the class is not present in materialization global environment'testFileShortcuts  | materializedString |  FLSerializer serialize: 'stringToSerialize' toFileNamed: 'demo.fuel'.  materializedString := FLMaterializer materializeFromFileNamed: 'demo.fuel'.  self assert: materializedString equals: 'stringToSerialize'testIsEmpty  self assert: FLSimpleStack new isEmptyisPharo  ^falseselector  ^selectorvisitSimpleCollection: aCollection  self mapAndTraceByObjectClass: aCollection to: FLSimpleCollectionClustertestBasic  | result |  self deny: FLGlobalSendMock newInstanceToSerialize equals: FLGlobalSendMock newInstanceToMaterialize.  result := self resultOfSerializeAndMaterialize: FLGlobalSendMock newInstanceToSerialize.  self assert: FLGlobalSendMock newInstanceToMaterialize equals: resultanalyzer: anObject  analyzer := anObjectclusterInstancesStep  | aCluster |  aCluster := decoder nextEncodedClusterClass newMaterializing.  aCluster clusterMaterializeStepWith: self.  aCluster materializeInstancesStepWith: decoder.  self registerAll: aCluster objects.  aCluster materializePostInstancesStepWith: decoder.  clusters add: aClustertestWeakWithStrongReferenceFromGraph  | weak graph obj1 obj2 materializedGraph |  obj1 := 11.  obj2 := 'something'.  weak := WeakArray with: obj1 with: obj2.  graph := OrderedCollection with: 40 with: 'aaaa' with: weak with: obj2.  materializedGraph := self resultOfSerializeAndMaterialize: graph.  self assert: (materializedGraph at: 3) first isNil.  self assert: (materializedGraph at: 3) second equals: obj2.  self deny: (self serializationOf: graph includes: 11).  self assert: (self serializationOf: graph includes: obj2)setUp  super setUp.  self useBinaryFileStreamtestSingletonMaterializationEnforced  | singleton materialized |  singleton := FLSingletonMockEnforced instance.  singleton reference: 'a reference'.  self assert: singleton equals: FLSingletonMockEnforced instance.  materialized := self resultOfSerializeAndMaterialize: singleton.  self assert: materialized identicalTo: singleton.  self deny: materialized reference isNil.  self assert: materialized reference identicalTo: singleton reference.  FLSingletonMock resetextensionProtocolName  ^FLPlatform extensionProtocolNametestCapacity  | stack |  stack := FLSimpleStack new: 3.  self assert: 3 equals: stack capacity.  stack := FLSimpleStack new: 5.  self assert: 5 equals: stack capacitytestWriteStream  | aWriteStream materialized |  aWriteStream := WriteStream on: (ByteArray new: 1).  materialized := self resultOfSerializeAndMaterialize: aWriteStream.  aWriteStream nextPut: 1.  self assert: 1 equals: aWriteStream size.  self assert: 0 equals: materialized size.  materialized nextPut: 2.  self assert: (Array with: 2) equals: materialized contents asArrayinitializeMaterializingFrom: aDecoder  notIgnoredVariables := (1 to: aDecoder nextEncodedByte) collect: [:index |  aDecoder nextEncodedString ].  mapping := notIgnoredVariables collect: [:name |  theClass instVarIndexFor: name ifAbsent: [ nil ] ]testSymbol  self assertSerializationIdentityOf: #testSymbol.  self assertSerializationIdentityOf: #with:with:with:with:.  self assertSerializationIdentityOf: #'hello there'writeStreamDo: aValuable  inMemoryStream := MultiByteBinaryOrTextStream on: ''.  ^aValuable value: inMemoryStream binaryisBigEndian  ^self subclassResponsibilityreferencesOf: anObject do: aBlock  variablesMapping referencesOf: anObject do: aBlocktestMethodDictionary  self resultOfSerializeAndMaterializeMethodDictionary: FLPair methodDicttestClassSideMethodNotFoundAfterRemoval  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait classSide duringTestCompileSilently: 'you'.  self serialize: classOrTrait classSide >> #you.  classOrTrait classSide removeSelectorSilently: #you.  self should: [ self materialized ] raise: FLMethodNotFound whoseDescriptionIncludes: classOrTrait classSide printString description: 'Should raise an error when method is not present.'addAndClassifySelector: aSymbol inClass: aClass withMethod: aCompiledMethod inProtocol: aString  self subclassResponsibilityobjects  self subclassResponsibilitytestInstanceOfAnObsoleteClass  | aClass instance |  aClass := self newClassOrTrait.  instance := self newInstanceFrom: aClass.  self removeFromSystem: aClass.  self should: [ self serialize: instance ] raise: FLObsolete whoseDescriptionIncludes: aClass name description: 'Should raise an error when serializing as global an obsolete class.'nextPut: object  self flushBufferIfFull.  position := position + 1.  self buffer at: position put: objectmethod: aCompiledMethod  method := aCompiledMethodserialize: anObject on: aStream  FLEncoder on: aStream globalEnvironment: self analyzer globalEnvironment do: [:anEncoder |  self encodeSignatureWith: anEncoder.        self encodeVersionWith: anEncoder.        self encodeHeaderWith: anEncoder.        ^self serializationFactory value: anObject value: anEncoder ]objectCount: aNumber  objectCount := aNumber.  objectsIndexes := FLLargeIdentityDictionary new.  substitutionIndexes := FLLargeIdentityDictionary new.  indexStream := FLIndexStream on: stream digits: aNumber bytesCountserializeReferencesStepWith: anEncoder  testBlockClosureWithTempVariableRead  | closure materializedClosure |  closure := self class blockClosureWithTempVariableRead.  materializedClosure := self resultOfSerializeAndMaterialize: closure.  closure assertWellMaterializedInto: materializedClosure in: self.  self assert: materializedClosure value equals: 'TEST'testPreservesIdentity  self assertSerializationIdentityOf: self newClassOrTraitrenameAndCompileInTarget  | newMethod |  newMethod := FLPlatform current renamedMethodCopyOf: self method selector: self selector.  FLPlatform current silentlyAddAndClassifySelector: self selector inClass: self targetClass withMethod: newMethod inProtocol: self extensionProtocolNametestAssociationWithWeak  | weak association materializedAssociation |  weak := FLWeakClassMock new: 1.  weak instVar1: 'nonWeak'.  weak basicAt: 1 put: 'weak'.  association := Association key: #foo value: weak.  materializedAssociation := self resultOfSerializeAndMaterialize: association.  self assert: materializedAssociation value instVar1 isNil not.  self assert: (materializedAssociation value basicAt: 1) isNil.  self assert: materializedAssociation key equals: #footestClassSideMethodPreservesIdentity  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait classSide duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: classOrTrait classSide >> #younextIndex  | s |  s := 0.  1 to: digits do: [:i |  s := (s bitShift: 8) bitOr: stream next ].  ^sserialize: anObject  ^self serialize: anObject on: streamtestSubstitute: anObject inPresenceOf: anotherObject  | result |  self analyzer when: [:x |  x == anObject ] substituteBy: [:x |  424242 ].  result := self resultOfSerializeAndMaterialize: {anObject .         anotherObject}.  self assert: result first equals: 424242.  self assert: result second equals: anotherObjectmappers  ^OrderedCollection new     addAll: self pluggableSubstitutionMappers;     addAll: self globalMappers;     add: self generalMapper;     reduceRight: [:left :right |  left next: right ];     yourselftestWideString  | anObject |  anObject := OrderedCollection new.  600 timesRepeat: [ anObject add: (WideString streamContents: [:stream |  600 timesRepeat: [ stream nextPut: (256 to: 1000) atRandom asCharacter ] ]) ].  self shouldnt: [ self assertSerializationEqualityOf: anObject ] raise: ErrortestBlockClosureWithClassVariableRead  | closure materializedClosure |  ClassVariableForTesting := nil.  closure := [ ClassVariableForTesting ].  materializedClosure := self resultOfSerializeAndMaterialize: closure.  closure assertWellMaterializedInto: materializedClosure in: self.  ClassVariableForTesting := true.  self assert: materializedClosure value.  ClassVariableForTesting := false.  self deny: materializedClosure valuerenamedMethodCopyOf: aMethod selector: aSymbol  ^self subclassResponsibilitytestNotFoundAfterRemoval  | classOrTrait |  classOrTrait := self newClassOrTrait.  self serialize: classOrTrait.  self removeFromSystem: classOrTrait.  self should: [ self materialized ] raise: FLClassNotFoundobjects  ^objectsnewInstanceFrom: aTrait  | aClass |  aClass := self newClass.  testingEnvironment at: aTrait name put: aTrait.  aClass addToComposition: aTrait.  ^aClass newserializeReferencesStepWith: anEncoder  objects do: [:anObject |  self serializeReferencesOf: anObject with: anEncoder ]bufferFreeSize  ^buffer size - positionvisitSubstitution: anObject by: anotherObject onRecursionDo: aBlock  | cluster |  cluster := self clusterKeyedByClusterName: FLSubstitutionCluster.  (cluster isSubstitute: anObject) ifTrue: aBlock ifFalse: [ cluster add: anObject substitutedBy: anotherObject traceWith: analysis ]readStreamDo: aValuable  ^FLPlatform current fileNamed: self fileName readStreamDo: [:aStream |  aValuable value: aStream binary ]testSmallInteger  self assertSerializationIdentityOf: -1212.  self assertSerializationIdentityOf: 7.  self assertSerializationIdentityOf: 0.  self assertSerializationIdentityOf: 1111.  self assertSerializationIdentityOf: SmallInteger onetestArray  self assertSerializationEqualityOf: #(1).  self assertSerializationEqualityOf: #(10 20).  self assertSerializationEqualityOf: #(1 2 3 #('Hello' 2 3))addPostMaterializationAction: aCleanBlockClosure  header addPostMaterializationAction: aCleanBlockClosuretestNotFoundAfterRemoval  | classOrTrait |  classOrTrait := self newClassOrTrait.  self serialize: classOrTrait.  self removeFromSystem: classOrTrait.  self should: [ self materialized ] raise: FLClassNotFoundisSubstitute: anObject  ^substitutes identityIncludes: anObjecttestSmallIntegerMaxValue  self assertSerializationIdentityOf: SmallInteger maxValvaluesDo: aBlock  tally = 0 ifTrue: [ ^self ].  1 to: 4096 do: [:arrayIndex |  | valueArray |        valueArray := values at: arrayIndex.        1 to: (tallies at: arrayIndex) do: [:index |  aBlock value: (valueArray at: index) ] ]serializeInstance: anInteger with: anEncoder  anEncoder encodeUint24: anInteger absaddPreMaterializationAction: aCleanBlockClosure  header addPreMaterializationAction: aCleanBlockClosureassertSerializationEqualityOrIdentityOf: anObject  | materialized |  materialized := self resultOfSerializeAndMaterialize: anObject.  self assert: anObject = materialized description: 'The materialized object should be equal to serialized one'references  ^references ifNil: [ references := FLLargeIdentityDictionary new ]testGrow  | stack |  stack := FLSimpleStack new: 1.  self assert: 1 equals: stack capacity.  stack push: #a.  self assert: 1 < stack capacityat: key ifAbsent: aBlock  | hash |  (keys at: (hash := key largeIdentityHash \\ 4096 + 1)) ifNotNil: [:keyList |  1 to: (tallies at: hash) do: [:index |  (keyList at: index) == key ifTrue: [ ^(values at: hash) at: index ] ] ].  ^aBlock valuevisitNotSerializable: anObject  FLNotSerializable signalWith: anObjectserializationOf: anObject includes: anotherObject  | serialization |  self streamFactory writeStreamDo: [:aStream |  serialization := serializer serialize: anObject on: aStream.        ^serialization objects includes: anotherObject ]materializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint24readArgumentsFrom: aPragma  ^{aPragma key keywords .   aPragma arguments}do: aBlock  ^self valuesDo: aBlockmaterializationFactory  ^materializationFactoryprintOn: aStream  super printOn: aStream.  aStream     nextPutAll: ' contents: ';     print: contentstestAdditionalObjects  self serializer at: #test putAdditionalObject: 'test'.  self serializer at: 42 putAdditionalObject: 68.  self assertSerializationEqualityOf: 'foo'.  self assert: (self materialization additionalObjectAt: #test) equals: 'test'.  self assert: (self materialization additionalObjectAt: 42) equals: 68testPostMaterializationActions  | aClass |  aClass := self newSubclassNamed: #FuelPostMaterializationTestClassToBeDeleted of: Object instanceVariableNames: '' classVariableNames: 'TestClassVariable TestClassVariable2'.  aClass class     duringTestCompileSilently: 'postLoadMethod  TestClassVariable := 1';     duringTestCompileSilently: 'postLoadMethod2  TestClassVariable := 2';     duringTestCompileSilently: 'classVariable  ^TestClassVariable '.  aClass perform: #postLoadMethod.  self assert: (aClass perform: #classVariable) equals: 1.  self serializer addPostMaterializationAction: [ (Smalltalk at: #FuelPostMaterializationTestClassToBeDeleted) perform: #postLoadMethod2 ].  self serialize: aClass.  self assert: (aClass perform: #classVariable) equals: 1.  self materialized.  self assert: (aClass perform: #classVariable) equals: 2registerIndexesOn: anEncoder  | indexes |  indexes := anEncoder objectsIndexes.  self objects do: [:instance |  indexes at: instance put: indexes size + 1 ]nextEncodedWordsInto: aWordsObject  stream fuelNextWordsInto: aWordsObjectfuelReplacement  ^ignoreMe ifTrue: [ nil ] ifFalse: [ self ]testSuperclassChange  | aClass aClassSubclass instance materializedInstance anotherSuperclass |  aClass := self newClassWithInstanceVariableNames: 'a b c' superclass: Object.  aClassSubclass := self newClassWithInstanceVariableNames: 'd e' superclass: aClass.  anotherSuperclass := self newClassWithInstanceVariableNames: 'x' superclass: Object.  instance := aClassSubclass new.  instance instVarNamed: 'a' put: $A.  instance instVarNamed: 'b' put: $B.  instance instVarNamed: 'c' put: $C.  instance instVarNamed: 'd' put: $D.  instance instVarNamed: 'e' put: $E.  self serialize: instance.  aClassSubclass superclass: anotherSuperclass.  materializedInstance := self materialized.  self assert: $D equals: (materializedInstance instVarNamed: 'd').  self assert: $E equals: (materializedInstance instVarNamed: 'e').  self should: [ materializedInstance instVarNamed: 'a' ] raise: Error.  self should: [ materializedInstance instVarNamed: 'b' ] raise: Error.  self should: [ materializedInstance instVarNamed: 'c' ] raise: Error.  self assert: (materializedInstance instVarNamed: 'x') isNilreferencesStep  clusters do: [:aCluster |  aCluster serializeReferencesStepWith: encoder ]isEmpty  ^1 = slotIndextestShowingProgressBar  (testingEnvironment includesKey: #FLProgressSerialization) ifFalse: [ ^self skip ].  FLPlatform current fileNamed: 'numbers.fuel' writeStreamDo: [:aStream |  FLSerializer newDefault           showProgress;           serialize: (1 to: 200000) asArray on: aStream ].  FLPlatform current fileNamed: 'numbers.fuel' readStreamDo: [:aStream |  FLMaterializer newDefault           showProgress;           materializeFrom: aStream ]dontIgnoreMe  ignoreMe := falseserializeInstancesStepWith: anEncoder  objects do: [:instance |  self serializeInstance: instance with: anEncoder ]do: aBlock  tally = 0 ifTrue: [ ^self ].  includesNil ifTrue: [ aBlock value: nil ].  1 to: 4096 do: [:arrayIndex |  | subArray |        subArray := array at: arrayIndex.        1 to: (tallies at: arrayIndex) do: [:index |  aBlock value: (subArray at: index) ] ]additionalObjectAt: aKey  ^header additionalObjectAt: aKeysignature  ^signaturetestProxyByTarget  | aProxyClass result original |  aProxyClass := (self newSubclassOf: Object instanceVariableNames: 'target' classVariableNames: '')     duringTestCompileSilently: 'target: x  target := x';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: target';     yourself.  original := aProxyClass new     target: 5;     yourself.  result := self resultOfSerializeAndMaterialize: original.  self assert: 5 equals: resultisBigEndian  ^(Smalltalk at: #EndianDetector) isBigEndianvisitVariableObject: anObject  self mapAndTraceByObjectClass: anObject to: FLVariableObjectClusterinitializeOn: aStream digits: aNumberOfDigits  self initialize.  stream := aStream.  digits := aNumberOfDigitstestRunArray  self assertSerializationEqualityOf: (RunArray runs: #(1 2 1) values: #(1 2 3))encodeUint32: aSmallInteger  stream     nextPut: (aSmallInteger bitShift: -24);     nextPut: ((aSmallInteger bitShift: -16) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -8) bitAnd: 255);     nextPut: (aSmallInteger bitAnd: 255)testFormatFixedToVariable  | materialized |  self serialize: FLPair new.  materialized := self during: [ self materialized ] rename: FLPair as: FLWeakClassMock.  self assert: materialized size equals: 0readStreamDo: aValuable  ^aValuable value: inMemoryStream resetassertSerializationEqualityOf: anObject  | materialized |  materialized := self resultOfSerializeAndMaterialize: anObject.  self assert: anObject ~~ materialized description: 'The materialized object should not be the same as the serialized one'.  self assert: anObject = materialized description: 'The materialized object should be equal to serialized one'pluggableSubstitutionMappers  ^pluggableSubstitutions collect: [:aLink |  FLPluggableSubstitutionMapper when: aLink key substituteBy: aLink value ]nextEncodedUint16  ^(stream next bitShift: 8) + stream nextclusterMaterializeStepWith: aMaterialization  super clusterMaterializeStepWith: aMaterialization.  theClass := aMaterialization decoder nextEncodedReferencetestCreation  self indexStreamOn: #() writeStream digits: 2initializeAnalyzing: aClass  super initializeAnalyzing: aClass.  variablesMapping := FLVariablesMapping newAnalyzing: theClass references: self referencestestGlobalMetaclass  self assertSerializationIdentityOf: Integer classtestDontConsiderCustomGlobal  | anObject |  anObject := Object new.  serializationEnvironment at: #FLGlobalVariableForTesting put: anObject.  materializationEnvironment     at: #FLGlobalVariableForTesting put: anObject;     at: #Object put: Object.  self deny: (self analyzer globalSymbols includes: #FLGlobalVariableForTesting).  self deny: (self resultOfSerializeAndMaterialize: anObject) identicalTo: anObjectmaterializeReferencesOf: anObject with: aDecoder  super materializeReferencesOf: anObject with: aDecoder.  self materializeReferencesVariablePartOf: anObject with: aDecodertestFraction  self assertSerializationEqualityOf: 3 / 4.  self assertSerializationEqualityOf: 4 / 3.  self assertSerializationEqualityOf: -4 / 3.  self assertSerializationEqualityOf: -4 / -3.  self assertSerializationEqualityOf: 4 / -3.  self assertSerializationIdentityOf: (0 - 0) / -3.  self assertSerializationEqualityOf: 0 - (1001 / 1000)initializeWith: aDecoder  self initialize.  decoder := aDecoderincludesKey: key  | hash |  ^(keys at: (hash := key largeIdentityHash \\ 4096 + 1)) ifNil: [ false ] ifNotNil: [:keyList |  key ifNotNil: [ keyList fuelPointsTo: key ] ifNil: [ 1 to: (tallies at: hash) do: [:index |  (keyList at: index) == key ifTrue: [ ^true ] ].              false ] ]testGlobalMetaclass  materializationEnvironment at: #Integer put: FLPerson.  self assert: (self resultOfSerializeAndMaterialize: Integer class) identicalTo: FLPerson classnextEncodedString  | length aByteArray |  length := stream next.  length >= 192 ifTrue: [ length := length - 192.        1 to: 3 do: [:ii |  length := length * 256 + stream next ] ].  aByteArray := ByteArray new: length.  stream nextInto: aByteArray.  ^aByteArray asStringtestWeakWithStrongReferenceFromGraph2  | weak graph obj1 obj2 materializedGraph |  obj1 := 11.  obj2 := 'something'.  weak := WeakArray with: obj1 with: obj2.  graph := OrderedCollection with: 40 with: 'aaaa' with: weak with: obj2 with: (Point x: weak y: weak).  materializedGraph := self resultOfSerializeAndMaterialize: graph.  self assert: (materializedGraph at: 3) first isNil.  self assert: (materializedGraph at: 3) second equals: obj2.  self deny: (self serializationOf: graph includes: 11).  self assert: (self serializationOf: graph includes: obj2)globalsBucket  ^globalsBucketmanageFile: aFileReference  Stdio stdout     nextPutAll: 'Materializing from file: ';     nextPutAll: aFileReference fullName;     lf.  aFileReference readStreamDo: [:stream |  stream binary.        FLMaterializer new materializeFrom: stream ].  Stdio stdout     nextPutAll: 'Materialization finished';     lftestSubstituteTrueInPresenceOfTheTrueInstance  self testSubstitute: True inPresenceOf: truevalues  ^Array new: tally streamContents: [:stream |  self valuesDo: [:value |  stream nextPut: value ] ]substitutions  ^substitutionsprintOn: aStream  self printNameOn: aStream.  aStream nextPutAll: '->'.  objects printElementsOn: aStreamtestEmptyOrderedCollection  self assertSerializationEqualityOf: OrderedCollection newclusterKeyedByObjectClass: clusterClass class: objectClass  ^self clusterInstanceOf: clusterClass keyInBucket: objectClass factory: [ clusterClass newAnalyzing: objectClass ]mapAndTrace: anObject  (globals includes: anObject) ifTrue: [ self mapAndTraceByClusterName: anObject to: FLGlobalValueCluster ] ifFalse: [ next mapAndTrace: anObject ]instVar1: anObject  instVar1 := anObjectuseStandardFileStream  streamFactory := FLFileStreamStrategy newWithStandardFileStreamfuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: niltestSortedCollectionWithInstanceVariableReferenceChange  | aSortedCollection materialized |  instanceVariableForTesting := false.  aSortedCollection := self sortedBlockClosureWithInstanceVariable.  materialized := self resultOfSerializeAndMaterialize: aSortedCollection.  instanceVariableForTesting := true.  materialized addAll: #(2 3 1).  aSortedCollection addAll: #(2 3 1).  self deny: aSortedCollection asArray equals: materialized asArraytestSimple  | result |  self analyzer when: [:x |  x < 0 ] substituteBy: [:x |  0 ].  result := self resultOfSerializeAndMaterialize: -1.  self assert: result equals: 0useInstalled  theClass duringTestCompileSilently: 'm  ^ 42' storeSource: true.  theCompiledMethod := theClass methodNamed: #mtestSerializeExternalAddressCorrectly  | externalAddress byteArray |  externalAddress := ExternalAddress fromAddress: 1234567890.  byteArray := self serialize: externalAddress.  self assert: byteArray isNotNil.  self assert: byteArray size > 0isBigEndian  ^isBigEndianremove: anObject ifAbsent: aBlock  | list hash size |  anObject ifNil: [ includesNil ifTrue: [ includesNil := false.              tally := tally - 1.              ^anObject ].        ^aBlock value ].  list := (array at: (hash := anObject largeIdentityHash \\ 4096 + 1)) ifNil: [ ^aBlock value ].  (list fuelPointsTo: anObject) ifFalse: [ ^aBlock value ].  1 to: (size := tallies at: hash) do: [:index |  (list at: index) == anObject ifTrue: [ list                 at: index put: (list at: size);                 at: size put: nil.              (size := size - 1) < (list size // 4) ifTrue: [ | newList |                    newList := Array new: size * 2.                    newList replaceFrom: 1 to: size with: list startingAt: 1.                    array at: hash put: newList ].              tallies at: hash put: size.              tally := tally - 1.              ^anObject ] ].  ^aBlock valueinitializeWithClass: aClass references: aCollection  self initialize.  theClass := aClass.  references := aCollectionnextBytesPutAll: collection  self flushBufferIfFull.  collection size <= self bufferFreeSize ifTrue: [ self buffer replaceFrom: position + 1 to: position + collection size with: collection.        position := position + collection size ] ifFalse: [ self flushBuffer.        collection size > (self buffer size / 2) ifTrue: [ stream nextBytesPutAll: collection ] ifFalse: [ self nextBytesPutAll: collection ] ]serializer  ^serializerhash  ^self right hash bitXor: self left hashid: anObject  id := anObjectadd: anObject  | hash |  anObject ifNil: [ includesNil ifFalse: [ includesNil := true.              tally := tally + 1 ].        ^anObject ].  (array at: (hash := anObject largeIdentityHash \\ 4096 + 1)) ifNil: [ array at: hash put: (Array with: anObject).        tallies at: hash put: 1.        tally := tally + 1 ] ifNotNil: [:list |  (list fuelPointsTo: anObject) ifFalse: [ | newIndex |              tally := tally + 1.              list size < (newIndex := (tallies at: hash) + 1) ifFalse: [ list at: newIndex put: anObject ] ifTrue: [ | newList |                    newList := Array new: list size * 2.                    newList                       replaceFrom: 1 to: list size with: list startingAt: 1;                       at: newIndex put: anObject.                    array at: hash put: newList ].              tallies at: hash put: newIndex ] ].  ^anObjectprivateTrace: anObject  privateObjectStack push: anObjecttestWeakAndNoStrongReferenceFromGraph  | weak graph obj1 obj2 materializedGraph |  obj1 := 11.  obj2 := 'something'.  weak := WeakArray with: obj1 with: obj2.  graph := OrderedCollection with: 40 with: 'aaaa' with: weak.  materializedGraph := self resultOfSerializeAndMaterialize: graph.  self assert: (materializedGraph at: 3) first isNil.  self assert: (materializedGraph at: 3) second isNil.  self deny: (self serializationOf: graph includes: 11).  self deny: (self serializationOf: graph includes: 'something')serialize: anObject  byteArray := FLSerializer serializeToByteArray: anObjectfileNamed: aFilename writeStreamDo: aBlock  ^((Smalltalk at: #File) named: aFilename) writeStreamDo: [:stream |  aBlock value: stream ]fileExtension  ^self class fileExtension= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^contents = anObject contentsprintNameOn: aStream  super printOn: aStreamserializeReferencesOf: anObject with: anEncoder  variablesMapping serializeReferencesOf: anObject with: anEncodertestBlockClosureWithThreeArguments  | closure materializedClosure |  closure := [:a :b :c |  a + b + c ].  materializedClosure := self resultOfSerializeAndMaterialize: closure.  closure assertWellMaterializedInto: materializedClosure in: self.  self assert: (materializedClosure value: 1 value: 2 value: 3) equals: 6keysDo: aBlock  tally = 0 ifTrue: [ ^self ].  1 to: 4096 do: [:arrayIndex |  | keyArray |        keyArray := keys at: arrayIndex.        1 to: (tallies at: arrayIndex) do: [:index |  aBlock value: (keyArray at: index) ] ]tearDown  FLPlatform current deleteFileNamed: self fileNameobjectsIndexes  ^objectsIndexesmaterializeInstanceWith: aDecoder  ^Character value: aDecoder nextEncodedUint32clusterReferencesDo: aBlock  aBlock value: theClassserializeReferencesOf: anObject with: anEncoder  | refs |  refs := self references at: anObject ifAbsent: [ ^self ].  anEncoder encodePositiveInteger: refs first.  refs from: 2 to: refs size do: [:ref |  anEncoder encodeReferenceTo: ref ]clusterMaterializeStepWith: aMaterialization  super clusterMaterializeStepWith: aMaterialization.  objects := Array new: aMaterialization decoder nextEncodedPositiveIntegertestMethodPreservesIdentity  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait duringTestCompileSilently: 'you'.  self assertSerializationIdentityOf: classOrTrait >> #younewClass  ^self newSubclassOf: Object instanceVariableNames: '' classVariableNames: ''activate  self manageFiles.  (self commandLine hasOption: 'save') ifTrue: [ ThreadSafeTranscript install.        SessionManager default addDeferredStartupAction: [ Smalltalk snapshot: true andQuit: true.              NonInteractiveTranscript new install ] ].  (self commandLine hasOption: 'quit') ifTrue: [ self exitSuccess ]contents  ^contentsmaterializeInstanceWith: aDecoder  | compiledMethod header bytecodesPlusTrailerSize |  header := aDecoder nextEncodedInt32.  bytecodesPlusTrailerSize := aDecoder nextEncodedUint16.  compiledMethod := CompiledMethod newMethod: bytecodesPlusTrailerSize header: header.  compiledMethod initialPC to: compiledMethod size do: [:index |  compiledMethod at: index put: aDecoder nextEncodedByte ].  ^compiledMethodinstancesStep  clusterCount timesRepeat: [ self clusterInstancesStep ]objectCount  ^objectCounttestNotInstalled  | materialized |  self useNotInstalled.  self deny: theCompiledMethod isInstalled.  self deny: theCompiledMethod isDoIt.  self deny: theCompiledMethod trailer hasSource.  self assert: theCompiledMethod trailer isEmpty.  self deny: theCompiledMethod trailer hasSourcePointer.  materialized := self resultOfSerializeAndMaterialize: theCompiledMethod.  self deny: materialized isInstalled.  self deny: materialized isDoIt.  self assert: materialized trailer hasSource.  self deny: materialized trailer isEmpty.  self deny: materialized trailer hasSourcePointer.  self assert: (materialized isEqualRegardlessTrailerTo: theCompiledMethod)theClass  ^theClassmaterializeInstanceWith: aDecoder  ^theClass fuelNew: aDecoder nextEncodedPositiveIntegertestEmptySet  self assertSerializationEqualityOf: Set newtestAssociation  self assertSerializationEqualityOf: 1 -> 'marino'.  self assertSerializationEqualityOf: nil -> 'marino'.  self assertSerializationEqualityOf: nil -> nil.  self assertSerializationEqualityOf: nil -> #(1 3 4).  self assertSerializationEqualityOf: nil -> truefuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: nilsignature  ^signaturetestBadSignature  serializer signature: 'FUELx'.  materializer signature: 'FUELy'.  self should: [ self resultOfSerializeAndMaterialize: 'content' ] raise: FLBadSignature whoseDescriptionIncludes: 'FUELy' description: 'The materializer should raise an error when signature differs of the expected one.'analysis: anAnalysis  analysis := anAnalysis.  next ifNotNil: [ next analysis: anAnalysis ]testTransientPair  | result |  self analyzer when: [:x |  FLPair = x class ] substituteBy: [:x |  nil ].  result := self resultOfSerializeAndMaterialize: FLPair new.  self assert: result isNilreadSelectorFrom: aPragma argumentNames: argumentNames argumentValues: argumentValues  | index |  index := argumentNames indexOf: 'selector:' ifAbsent: [ ^aPragma method selector ].  ^argumentValues at: indexserialize: anObject  self streamFactory writeStreamDo: [:aStream |  self serializer serialize: anObject on: aStream ]materializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint32globalEnvironment  ^globalEnvironmentprintOn: aStream  super printOn: aStream.  array printElementsOn: aStreamsetUp  super setUp.  thisContextSample := self class thisContextSamplereadStreamDo: aValuable  self subclassResponsibilitytestCompiledMethod  | classA classB |  classA := self newClass     duringTestCompileSilently: 'm  ^ 42';     yourself.  classB := self newClass     duringTestCompileSilently: 'm    ^    42   ';     yourself.  self assert: (classA >> #m) bytecodesHash equals: (classB >> #m) bytecodesHash.  self deny: classA >> #m identicalTo: classB >> #m.  materializationEnvironment at: classA name put: classB.  self assert: (self resultOfSerializeAndMaterialize: classA >> #m) identicalTo: classB >> #mserializeInstance: anObject with: anEncoder  | globalSend |  globalSend := globalSends at: anObject.  self serializeGlobalAssociationKeyed: globalSend key on: anEncoder.  anEncoder encodeString: globalSend valuemapAndTraceSubstitutionIfNotRecursive: anObject  | cluster |  cluster := self clusterKeyedByClusterName: FLSubstitutionCluster.  (cluster isSubstitute: anObject) ifTrue: [ next mapAndTrace: anObject ] ifFalse: [ cluster add: anObject substitutedBy: (substitutionFactory value: anObject) traceWith: analysis ]visitFixedObject: anObject  self mapAndTraceByObjectClass: anObject to: FLFixedObjectClustersetDefaultSerialization  ^serializationFactory := [:anObject :anEncoder |  (FLSerialization with: anEncoder root: anObject analyzer: self analyzer)     run;     yourself ]testPairs  | pairs |  pairs := (1 to: 1 << 14) collect: [:i |  FLPair new           left: i;           right: i + 1;           yourself ].  self assertSerializationEqualityOf: pairsvisitClass: aClass  self mapAndTraceInstanceSideGlobal: aClassprintOn: aStream  aStream     nextPutAll: 'a ';     nextPutAll: self class namematerializeReferencesOf: anObject with: aDecoder  variablesMapping materializeReferencesOf: anObject with: aDecodermanageFiles  files := (self commandLine allFilesWithExtension: self fileExtension) collect: [:each |  (FileSystem disk resolve: each) asFileReference ].  files ifNil: [ ^self ].  files do: [:reference |  self manageFile: reference ]testTransientByNil  | result aClassOfTransientObjects |  aClassOfTransientObjects := self newClass     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: nil';     yourself.  result := self resultOfSerializeAndMaterialize: aClassOfTransientObjects new.  self assert: result isNilsubstitutionIndexes  ^substitutionIndexesinitializeWithPragma: aPragma  | argumentNamesAndValues |  argumentNamesAndValues := self readArgumentsFrom: aPragma.  self     method: aPragma method copy;     selector: (self readSelectorFrom: aPragma argumentNames: argumentNamesAndValues first argumentValues: argumentNamesAndValues second);     isSource: (self readIsSourceFrom: aPragma argumentNames: argumentNamesAndValues first argumentValues: argumentNamesAndValues second);     targetClass: (self readTargetClassFrom: aPragma argumentNames: argumentNamesAndValues first argumentValues: argumentNamesAndValues second)absolutePathOf: aString  ^aString asFileReference fullNametestSubstituteByItself  | result |  self analyzer when: [:x |  true ] substituteBy: [:x |  x ].  result := self resultOfSerializeAndMaterialize: 1.  self assert: result equals: 1defaultAnalyzer  ^FLAnalyzer newDefaultserializeInstance: aClassOrTraitClassSide with: anEncoder  self serializeGlobalClass: aClassOrTraitClassSide instanceSide on: anEncodernewSubclassNamed: nameString of: aClass instanceVariableNames: ivNamesString classVariableNames: classVarsString  | class |  SystemAnnouncer uniqueInstance suspendAllWhile: [ class := aClass subclass: nameString asSymbol instanceVariableNames: ivNamesString classVariableNames: classVarsString category: self classFactory defaultCategory ].  self classFactory createdClasses add: class.  ^classisPharo  ^trueclusterBuckets  ^OrderedCollection new     add: globalsBucket;     add: primitivesBucket;     add: metalevelClassSideBucket;     add: metalevelInstanceSideBucket;     add: baselevelBucket;     add: postBaselevelBucket;     add: substitutionsBucket;     yourselfglobalEnvironment  ^globalEnvironmentaddAndClassifySelector: aSymbol inClass: aClass withMethod: aCompiledMethod inProtocol: aString  aClass addAndClassifySelector: aSymbol withMethod: aCompiledMethod inProtocol: aStringversionNumber  ^('\d+' asRegex matchesIn: self className) first asIntegerencodePositiveInteger: anInteger  1 to: 4 do: [:i |  stream nextPut: (anInteger byteAt: 4 + 1 - i) ]run  self headerStep.  self instancesStep.  self referencesStep.  self trailerStep.  self afterMaterializationStepuseInMemorySerializationStream  streamFactory := FLByteArrayStreamStrategy newencodeYourself  self encodePositiveInteger: objectCount.  self encodePositiveInteger: FLPlatform current isBigEndian asBitmaterializationHeader  self streamFactory readStreamDo: [:aStream |  ^self materializer materializeHeaderFrom: aStream ]testGlobalClass  self assertSerializationIdentityOf: Integerat: key putAdditionalObject: anObject  additionalObjects at: key put: anObjectsetUpMaterializer  materializer := FLMaterializer newDefaultencodeBytes: aBytesObject  stream nextBytesPutAll: aBytesObjecttargetClass: aClass  targetClass := aClassbaselevelBucket  ^baselevelBuckettraceWith: anAnalysis  self clusterReferencesDo: [:aChild |  anAnalysis privateTrace: aChild ]testSameSignature  serializer signature: 'FUELx'.  materializer signature: 'FUELx'.  self assertSerializationEqualityOf: 'content'testConsiderCustomWideSymbolGlobal  self errorresultOfSerializeAndMaterializeCompiledMethod: aCompiledMethod  | materialized |  materialized := self resultOfSerializeAndMaterialize: aCompiledMethod.  self assert: (materialized isEqualRegardlessTrailerTo: aCompiledMethod)instanceVariableNamesToSerialize  | ignoredInstanceVariableNames instanceVariableNamesToSerialize |  ignoredInstanceVariableNames := theClass fuelIgnoredInstanceVariableNames.  instanceVariableNamesToSerialize := OrderedCollection new.  theClass instanceVariableNamesDo: [:name |  (ignoredInstanceVariableNames includes: name) ifFalse: [ instanceVariableNamesToSerialize add: name ] ].  ^instanceVariableNamesToSerializefileName  ^FLPlatform current absolutePathOf: FLPlatform current imageName , '-tests.fuel'serializeInstance: aWordObject with: anEncoder  anEncoder encodePositiveInteger: aWordObject basicSize.  anEncoder encodeWords: aWordObjecttrailerStep  root := decoder nextEncodedReferenceisSqueak  ^falsematerializeReferencesOf: anObject with: aDecoder  mapping do: [:index |  | reference |        reference := aDecoder nextEncodedReference.        index ifNotNil: [ anObject instVarAt: index put: reference ] ]testTwoIgnoredVariables  | anObject result aClass |  aClass := self newClassWithInstanceVariableNames: 'a b c'.  aClass class duringTestCompileSilently: 'fuelIgnoredInstanceVariableNames ^#(a c)'.  anObject := aClass new     instVarAt: 1 put: $A;     instVarAt: 2 put: $B;     instVarAt: 3 put: $C;     yourself.  result := self resultOfSerializeAndMaterialize: anObject.  self assert: nil equals: (result instVarAt: 1).  self assert: $B equals: (result instVarAt: 2).  self assert: nil equals: (result instVarAt: 3)visitMethodContext: aMethodContext  self mapAndTraceByObjectClass: aMethodContext to: FLContextClusteruseLightMappers  globalMappersFactory := [ self lightGlobalMappers ].  generalMapperFactory := [ FLLightGeneralMapper new ]map: sourceName to: destinationName  | indexOfVariableToMap |  indexOfVariableToMap := notIgnoredVariables indexOf: sourceName.  indexOfVariableToMap > 0 ifTrue: [ mapping at: indexOfVariableToMap put: (theClass instVarIndexFor: destinationName ifAbsent: [ self error: 'Bad variable destination.' ]) ]fuelAccept: aGeneralMapper  ^index < 10 ifTrue: [ aGeneralMapper visitSubstitution: self by: (self copy index: self index + 1) onRecursionDo: [ super fuelAccept: aGeneralMapper ] ] ifFalse: [ super fuelAccept: aGeneralMapper ]registerIndexesOn: anEncoder  self flag: #pharoTodo.  objects := objects asIdentitySet.  super registerIndexesOn: anEncodersilentlyAddAndClassifySelector: aSymbol inClass: aClass withMethod: aCompiledMethod inProtocol: aString  self subclassResponsibilitynextEncodedInt24  | n firstDigit |  n := firstDigit := stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  firstDigit >= 128 ifTrue: [ n := -16r1000000 + n ].  ^nnextEncodedBitmap  ^Bitmap newFromStream: streamclassFactoryForTestCaseClass  ^ClassFactoryForTestCaseserialize: anObject  ^FLSerializer serializeToByteArray: anObjectclusterReferencesDo: aBlock  super clusterReferencesDo: aBlock.  aBlock value: nilisSource  ^isSourcetestPreservesIdentity  self assertSerializationIdentityOf: self newClassOrTraitmaterializeInstanceWith: aDecoder  ^Rectangle basicNewroot  ^rootremoveKey: key ifAbsent: aBlock  | hash |  (keys at: (hash := key largeIdentityHash \\ 4096 + 1)) ifNotNil: [:keyList |  | size |        1 to: (size := tallies at: hash) do: [:index |  (keyList at: index) == key ifTrue: [ | valueList |                    keyList                       at: index put: (keyList at: size);                       at: size put: nil.                    (valueList := values at: hash)                       at: index put: (valueList at: size);                       at: size put: nil.                    (size := size - 1) < (keyList size // 4) ifTrue: [ | newList |                          newList := Array new: size * 2.                          newList replaceFrom: 1 to: size with: keyList startingAt: 1.                          keys at: hash put: newList.                          newList := Array new: size * 2.                          newList replaceFrom: 1 to: size with: valueList startingAt: 1.                          values at: hash put: newList ].                    tallies at: hash put: size.                    tally := tally - 1.                    ^key ] ] ].  ^aBlock valueroot  ^rootencodeUint8: aSmallInteger  stream nextPut: aSmallIntegersetUp  super setUp.  theClass := self newClass classwriteStreamDo: aValuable  inMemoryStream := ByteArray new writeStream.  ^aValuable value: inMemoryStream binaryencodeReferenceToClusterObjectClass: aClass  indexStream nextIndexPut: (objectsIndexes at: aClass ifAbsent: [ FLObjectNotFound signalWith: aClass ])nextEncodedPositiveInteger  | s |  s := 0.  1 to: 4 do: [:i |  s := (s bitShift: 8) + stream next ].  ^snextEncodedReference  ^objects at: indexStream nextIndexsetDefaultSerialization  ^serializationFactory := [:anObject :anEncoder |  (FLDelayedSerializationMock with: anEncoder root: anObject analyzer: self analyzer)     run;     yourself ]testIgnoredValueIsNotMaterialized  | anObject materializedInstances aClass |  aClass := self newClassWithInstanceVariableNames: 'a'.  aClass class duringTestCompileSilently: 'fuelIgnoredInstanceVariableNames ^#(a)'.  anObject := aClass new     instVarAt: 1 put: #A;     yourself.  self serialize: anObject.  materializedInstances := self materializedObjects.  self deny: (materializedInstances includes: #A)streamFactory  ^streamFactorytestClassWithCachedValueByNil  | aClassWithCachedValue result original |  aClassWithCachedValue := (self newSubclassOf: Object instanceVariableNames: 'cache' classVariableNames: '')     duringTestCompileSilently: 'cache ^cache';     duringTestCompileSilently: 'cache: x cache := x';     duringTestCompileSilently: '			fuelAccept: aVisitor  				^cache 					ifNil: [ super fuelAccept: aVisitor ]					ifNotNil: [ aVisitor visitSubstitution: self by: (self copy cache: nil)]';     yourself.  original := aClassWithCachedValue new     cache: 5;     yourself.  result := self resultOfSerializeAndMaterialize: original.  self assert: result cache isNilversion  ^versiontestMethodNotFoundAfterRemoval  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait duringTestCompileSilently: 'you'.  self serialize: classOrTrait >> #you.  classOrTrait removeSelectorSilently: #you.  self should: [ self materialized ] raise: FLMethodNotFound whoseDescriptionIncludes: classOrTrait name , '>>#you' description: 'Should raise an error when method is not present.'initialize  super initialize.  self signature: self class defaultSignature.  self version: self class currentVersion.  header := FLHeader newserializeReferencesOf: anObject with: anEncoder  super serializeReferencesOf: anObject with: anEncoder.  self serializeReferencesVariablePartOf: anObject with: anEncodertearDownInstanceVariables  self class withAllSuperclasses do: [:class |  class = TestCase ifTrue: [ ^self ].        class instVarNames do: [:varName |  self instVarNamed: varName put: nil ] ]serializeInstance: anInteger with: anEncoder  anEncoder encodeUint8: anInteger absat: key putAdditionalObject: anObject  header at: key putAdditionalObject: anObjectvisitWeakObject: anObject  self mapAndTraceByObjectClass: anObject to: FLWeakVariableObjectClusterindex  ^indextestClassSideMethodNotFoundAfterRemoval  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait classSide duringTestCompileSilently: 'you'.  self serialize: classOrTrait classSide >> #you.  classOrTrait classSide removeSelectorSilently: #you.  self should: [ self materialized ] raise: FLMethodNotFound whoseDescriptionIncludes: classOrTrait classSide printString description: 'Should raise an error when method is not present.'initializeAnalyzing  super initializeAnalyzing.  objects := self newAnalyzingCollectiontestByteArray  self assertSerializationEqualityOf: #[1 2 3 4 5 6 7]materializeReferencesOf: anObject with: aDecoder  aDecoder nextEncodedPositiveInteger timesRepeat: [ anObject add: aDecoder nextEncodedReference -> aDecoder nextEncodedReference ]clusterSerializeStepWith: aSerialization  super clusterSerializeStepWith: aSerialization.  aSerialization encoder encodeReferenceToClusterObjectClass: theClassinitialize: hintSize  array := Array new: hintSize.  slotIndex := 1testSortedCollectionWithClassVariableChanges  | aSortedCollection materialized mmethod index |  ClassVariableForTesting := false.  aSortedCollection := self class sortedCollectionForTestingWithClassVariable.  materialized := self resultOfSerializeAndMaterialize: aSortedCollection.  mmethod := materialized sortBlock outerContext method.  index := mmethod literals indexOf: (self class bindingOf: #ClassVariableForTesting).  self deny: (mmethod literalAt: index) value.  ClassVariableForTesting := true.  self assert: (mmethod literalAt: index) valuetestObjectByProxyThatBecomesItsContent  | aProxyClass result |  aProxyClass := (self newSubclassOf: Object instanceVariableNames: 'someState' classVariableNames: '')     duringTestCompileSilently: 'initialize  someState := 5@1';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: (FLProxyThatBecomesItsContent newWith: someState)';     yourself.  result := self resultOfSerializeAndMaterialize: aProxyClass new.  self assert: 5 @ 1 equals: resultsetUpClassFactory  classFactory := FLPlatform current classFactoryForTestCaseClass newserializeInstance: anInteger with: anEncoder  anEncoder encodeUint64: anInteger absmigrateClassNamed: aSymbol toClass: aClass  self migrateClassNamed: aSymbol toClass: aClass variables: #()addVariableReferenceFrom: anObject to: anotherObject  | list |  list := self variableReferences at: anObject ifAbsent: [ nil ].  list ifNil: [ self variableReferences at: anObject put: (list := OrderedCollection new) ].  list add: anotherObjectwithNotificationsNewClassWithInstanceVariableNames: instanceVariableNames  ^classFactory withNotificationsNewClassWithInstanceVariableNames: instanceVariableNamesmethod1  self name.  self printString= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^id = anObject idtestPair  self assertSerializationEqualityOf: (FLPair new           left: 10;           right: 20;           yourself)materializeInstanceWith: aDecoder  ^self materializeGlobalClassFrom: aDecodertestUUID  self assertSerializationEqualityOf: (UUID fromString: 'a3b64357-377a-5b41-b575-1c653084a121').  self assertSerializationEqualityOf: UUID nilUUID.  self assertSerializationEqualityOf: UUID newtestCyclicIdentitySet  | aSet materializedSet |  aSet := IdentitySet new.  aSet add: aSet.  materializedSet := self resultOfSerializeAndMaterialize: aSet.  self assert: aSet ~~ materializedSet.  self assert: (materializedSet includes: materializedSet) description: 'The materialized set has to include himself. Note aSet = materializedSet is false, bacause equality implementation checks that materializedSet *identity-includes* each element of aSet, which is false.'newClassInCategory: aCategory  ^self classFactory silentlyNewClassInCategory: aCategoryregisterIndexesOn: anEncoder  globalEnvironment  ^globalEnvironmenttargetClass  ^targetClassgeneralMapper  ^generalMapperFactory valuetestContextWithClosureAndSender  | context1 materializedContext2 context2 |  context1 := Context newForMethod: FLPair >> #method1.  context1 initializeWith: 23 stackPtr: 1 method: FLPair >> #method1 receiver: (FLPair new           right: 4;           left: 2) sender: nil.  context2 := self class blockClosureContextTestingWithSender: context1.  materializedContext2 := self resultOfSerializeAndMaterialize: context2.  context2 assertWellMaterializedInto: materializedContext2 in: selfinitializeStream: aWriteStream  stream := aWriteStream.  streamRespondsToNextPutAllStartingAt := stream respondsTo: #next:putAll:startingAt:testRecursiveArray  | arr materialized |  arr := Array new: 3.  arr at: 1 put: 10.  arr at: 2 put: 20.  arr at: 3 put: arr.  materialized := self resultOfSerializeAndMaterialize: arr.  self assert: materialized first equals: 10.  self assert: materialized second equals: 20.  self assert: materialized third identicalTo: materializedpostCopy  tallies := tallies copyclose  self flushBuffer.  stream closedefaultLabel  ^'Fuel out Stack'useAuthor: aString during: aBlock  self subclassResponsibilityvariablePartReferencesOf: anObject do: aBlock  method2  self namesetTestTimeLimitFor: aTest to: aDuration  self subclassResponsibilitypostBaselevelBucket  ^postBaselevelBucketafterMaterializationStepWith: aDecoder  primitivesBucket  ^primitivesBucketpostMaterializationActions: listOfPostMaterializationActions  postMaterializationActions := listOfPostMaterializationActionsmaterializeInstancesStepWith: aDecoder  1 to: objects size do: [:index |  objects at: index put: (self materializeInstanceWith: aDecoder) ]initializeWith: aCondition substitutionFactory: aBlock  self initialize.  condition := aCondition.  substitutionFactory := aBlocktestConsiderCustomGlobal  | aPerson globalKey |  globalKey := #FLGlobalVariableForTesting.  self analyzer considerGlobal: globalKey.  aPerson := FLPerson new.  [ testingEnvironment at: globalKey put: aPerson.  self assertSerializationIdentityOf: aPerson ] ensure: [ testingEnvironment removeKey: globalKey ]testObsolete  | classOrTrait |  classOrTrait := self newClassOrTrait.  self removeFromSystem: classOrTrait.  self should: [ self serialize: classOrTrait ] raise: FLObsolete whoseDescriptionIncludes: classOrTrait name description: 'Should raise an error when serializing as global an obsolete class or trait.'testFuelReplacement  | object |  self assert: (self resultOfSerializeAndMaterialize: FLReplacementClassMock) equals: nil.  self assert: (self resultOfSerializeAndMaterialize: {FLReplacementClassMock}) equals: {nil}.  object := FLReplacementMock new     ignoreMe;     yourself.  self assert: (self resultOfSerializeAndMaterialize: {object}) equals: {nil}.  object dontIgnoreMe.  self assert: (self resultOfSerializeAndMaterialize: {object}) equals: {object}registerIndexesOn: anEncoder  substitutions keysAndValuesDo: [:anObject :theSubstitution |  | substitutionIndex |        substitutionIndex := anEncoder objectsIndexes at: theSubstitution.        anEncoder substitutionIndexes at: anObject put: substitutionIndex ]encodeByte: aSmallInteger  stream nextPut: aSmallIntegertestDoIt  | materialized |  self useDoIt.  theCompiledMethod selector: #DoIt.  self assert: theCompiledMethod isDoIt.  self assert: theCompiledMethod isInstalled.  self deny: theCompiledMethod trailer hasSource.  self assert: theCompiledMethod trailer isEmpty.  self deny: theCompiledMethod trailer hasSourcePointer.  materialized := self resultOfSerializeAndMaterialize: theCompiledMethod.  self deny: materialized isInstalled.  self assert: materialized isDoIt.  self assert: materialized trailer hasSource.  self deny: materialized trailer isEmpty.  self deny: materialized trailer hasSourcePointer.  self assert: (materialized isEqualRegardlessTrailerTo: theCompiledMethod)serializeInstance: anObject with: anEncoder  serializationFactory  ^serializationFactory ifNil: [ self setDefaultSerialization.        serializationFactory ]initializeWith: aFileStreamClass  self initialize.  fileStreamClass := aFileStreamClasstestBitmap  | bitmap materialized |  self assertSerializationEqualityOf: (Bitmap with: 0 with: 16rFFFFFFFF).  self assertSerializationEqualityOf: (Bitmap with: 4278190080).  self assertSerializationEqualityOf: (Bitmap new: 4096).  self assertSerializationEqualityOf: (Bitmap with: 0 with: 4294967295).  self assertSerializationEqualityOf: (Bitmap new: 256).  self assertSerializationEqualityOf: (Bitmap with: 0).  bitmap := Bitmap new: 3.  bitmap at: 1 put: 4324.  bitmap at: 2 put: 5674.  bitmap at: 3 put: 8978.  materialized := self resultOfSerializeAndMaterialize: bitmap.  self assert: (materialized at: 1) equals: 4324.  self assert: (materialized at: 2) equals: 5674.  self assert: (materialized at: 3) equals: 8978keysAndValuesDo: aBlock  tally = 0 ifTrue: [ ^self ].  1 to: 4096 do: [:arrayIndex |  | keyArray valueArray |        keyArray := keys at: arrayIndex.        valueArray := values at: arrayIndex.        1 to: (tallies at: arrayIndex) do: [:index |  aBlock value: (keyArray at: index) value: (valueArray at: index) ] ]testCompiledMethod  self assertSerializationIdentityOf: FLPair >> #lefttestCyclicLink  | a materializedA |  a := Link new.  a nextLink: a.  materializedA := self resultOfSerializeAndMaterialize: a.  self assert: materializedA nextLink identicalTo: materializedAmaterializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint64 negatedtestChangeInSuperclass  | aClass aClassSubclass instance materializedInstance |  aClass := self newClassWithInstanceVariableNames: 'a b c' superclass: Object.  aClassSubclass := self newClassWithInstanceVariableNames: 'd e' superclass: aClass.  instance := aClassSubclass new.  instance instVarNamed: 'a' put: $A.  instance instVarNamed: 'b' put: $B.  instance instVarNamed: 'c' put: $C.  instance instVarNamed: 'd' put: $D.  instance instVarNamed: 'e' put: $E.  self serialize: instance.  aClass removeInstVarNamed: 'a'.  aClass removeInstVarNamed: 'b'.  aClass addInstVarNamed: 'x'.  aClassSubclass superclass: aClass.  materializedInstance := self materialized.  self assert: $D equals: (materializedInstance instVarNamed: 'd').  self assert: $E equals: (materializedInstance instVarNamed: 'e').  self should: [ materializedInstance instVarNamed: 'a' ] raise: Error.  self should: [ materializedInstance instVarNamed: 'b' ] raise: Error.  self assert: $C equals: (materializedInstance instVarNamed: 'c').  self assert: (materializedInstance instVarNamed: 'x') isNiltestNotSerializableObject  self should: [ self serialize: FLNotSerializableMock new ] raise: FLNotSerializable whoseDescriptionIncludes: FLNotSerializableMock new printString description: 'User can prevent some objects from serialization.'clusterSerializeStepWith: aSerialization  super clusterSerializeStepWith: aSerialization.  aSerialization encoder encodePositiveInteger: objects sizeprivateFirstInMapperChain  ^self privateMappers firstheaderStep  decoder decodeYourself.  clusterCount := decoder nextEncodedPositiveInteger.  clusters := OrderedCollection new: clusterCount.  clusters resetTo: 1instancesStep  clusters do: [:aCluster |  aCluster registerIndexesOn: encoder ].  clusters do: [:aCluster |  self clusterInstancesStepOf: aCluster ]setUpSerializer  ^serializer := FLDelayedSerializerMock newDefaultinitializeOn: writeStream bufferSize: aSize  self initialize.  self initializeStream: writeStream.  self sizeBuffer: aSize.  position := 0testSortedCollectionWithInstanceVariableReference  | aSortedCollection materialized |  instanceVariableForTesting := false.  aSortedCollection := self sortedBlockClosureWithInstanceVariable.  materialized := self resultOfSerializeAndMaterialize: aSortedCollection.  materialized addAll: #(2 3 1).  aSortedCollection addAll: #(2 3 1).  self assert: aSortedCollection asArray equals: materialized asArray.  self assert: aSortedCollection asArray equals: #(3 2 1)clusterReferencesDo: aBlock  testTime  self assertSerializationEqualityOf: (Time fromSeconds: 84072).  self assertSerializationEqualityOf: (Time hour: 24 minute: 60 second: 60).  self assertSerializationEqualityOf: (Time hour: 23 minute: 59 second: 59).  self assertSerializationEqualityOf: (Time hour: 0 minute: 0 second: 0).  self assertSerializationEqualityOf: (Time seconds: 0 nanoSeconds: 5).  self assertSerializationEqualityOf: (Time allInstances sort: [:a :b |  a asSeconds > b asSeconds ]) first.  self assertSerializationEqualityOf: (Time allInstances sort: [:a :b |  a nanoSecond > b nanoSecond ]) firstfuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: niltestConsiderCustomGlobalNotFound  self analyzer considerGlobal: #FLGlobalVariableForTesting.  serializationEnvironment at: #FLGlobalVariableForTesting put: 42.  self serialize: 42.  self should: [ self materialization ] raise: FLGlobalNotFound description: 'Raise an error since the variable is not present in materialization global environment'withNotificationsNewClass  ^self classFactory withNotificationsNewClassprivateMapAndTrace: anObject  privateFirstMapper mapAndTrace: anObjecttestVariableRemoved  | pairClass aPair resultPair |  pairClass := self newClassWithInstanceVariableNames: 'left right'.  aPair := pairClass new.  aPair instVarAt: 1 put: $A.  aPair instVarAt: 2 put: $B.  self serialize: aPair.  self redefined: pairClass with: 'right'.  resultPair := self materialized.  self assert: $B equals: (resultPair instVarAt: 1)materializeFrom: aStream  | aDecoder materialization header |  aDecoder := FLDecoder on: aStream migrations: migrations globalEnvironment: globalEnvironment.  self verifySignatureFrom: aDecoder.  self verifyVersionFrom: aDecoder.  header := self decodeHeaderWith: aDecoder.  header executePreMaterializationActions.  materialization := materializationFactory value: aDecoder.  materialization header: header.  header materialization: materialization.  header executePostMaterializationActions.  ^materializationtestWideAndByteCharacters  | materialized aByteCharacter aWideCharacter |  aWideCharacter := Character value: 12345.  aByteCharacter := $a.  materialized := self resultOfSerializeAndMaterialize: (Array with: aWideCharacter with: aByteCharacter).  self assert: materialized first equals: aWideCharacter.  self assert: materialized second identicalTo: aByteCharactererrorKeyNotFound: aKey  KeyNotFound signalFor: aKeyreadIsSourceFrom: aPragma argumentNames: argumentNames argumentValues: argumentValues  | index |  index := argumentNames indexOf: 'isSource:' ifAbsent: [ ^false ].  ^argumentValues at: indexmaterializeInstanceWith: aDecoder  | instance size |  size := aDecoder nextEncodedPositiveInteger.  instance := theClass basicNew: size.  aDecoder nextEncodedBytesInto: instance.  ^instanceimageName  ^self subclassResponsibilitytestLargeNegativeInteger  self assertSerializationEqualityOf: -354314316134313999999999.  self assertSerializationEqualityOf: 0 - 100 factorialmaterializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint8serializeInstance: aCharacter with: anEncoder  anEncoder encodeUint32: aCharacter asciiValuetestProxyByTargetInsideObjectAndAnalisysIsPropagated  | aProxyClass result original pair pairRoot |  aProxyClass := (self newSubclassOf: Object instanceVariableNames: 'target' classVariableNames: '')     duringTestCompileSilently: 'target: x  target := x';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: target';     yourself.  pair := FLPair new.  pair left: 6.  pair right: 'foo'.  original := aProxyClass new     target: pair;     yourself.  pairRoot := FLPair new     left: original;     yourself.  result := self resultOfSerializeAndMaterialize: pairRoot.  self assert: result left left equals: 6.  self assert: result left right equals: 'foo'.  self assert: result right isNilsetUp  super setUp.  self setUpClassFactory.  self setUpSerializer.  self setUpMaterializer.  self useMemoryStreammapAndTrace: anObject  (condition value: anObject) ifTrue: [ self mapAndTraceSubstitutionIfNotRecursive: anObject ] ifFalse: [ next mapAndTrace: anObject ]newSecondaryTrait  ^self newTraitSuffixed: 'Secondary'absolutePathOf: aString  ^self subclassResponsibilitypush: anObject  array at: slotIndex put: anObject.  array size = slotIndex ifTrue: [ self grow ].  slotIndex := slotIndex + 1.  ^anObjectnewAnalyzingCollection  ^FLLargeIdentitySet newmaterializeLiteralsTo: compiledMethod with: aDecoder  1 to: compiledMethod numLiterals do: [:index |  compiledMethod literalAt: index put: aDecoder nextEncodedReference ]flush  ^stream flushvisitGlobalSend: anObject name: globalName selector: aSymbol  (self clusterKeyedByClusterName: FLGlobalSendCluster) add: anObject name: globalName selector: aSymbol traceWith: analysisvisitTrait: aTrait  self mapAndTraceInstanceSideGlobal: aTraitserializeInstance: anInteger with: anEncoder  anEncoder encodeUint24: anIntegertestVariableOrderChange  | pairClass aPair resultPair |  pairClass := self newClassWithInstanceVariableNames: 'left right'.  aPair := pairClass new.  aPair instVarAt: 1 put: $A.  aPair instVarAt: 2 put: $B.  self serialize: aPair.  self redefined: pairClass with: 'right left'.  resultPair := self materialized.  self assert: $B equals: (resultPair instVarAt: 1).  self assert: $A equals: (resultPair instVarAt: 2)testMethodNotFoundAfterRemoval  | classOrTrait |  classOrTrait := self newClassOrTrait.  classOrTrait duringTestCompileSilently: 'you'.  self serialize: classOrTrait >> #you.  classOrTrait removeSelectorSilently: #you.  self should: [ self materialized ] raise: FLMethodNotFound whoseDescriptionIncludes: classOrTrait name , '>>#you' description: 'Should raise an error when method is not present.'testAllVariablesIgnored  | anObject result aClass |  aClass := self newClassWithInstanceVariableNames: 'a b'.  aClass class duringTestCompileSilently: 'fuelIgnoredInstanceVariableNames ^#(a b)'.  anObject := aClass new     instVarAt: 1 put: $A;     instVarAt: 2 put: $B;     yourself.  result := self resultOfSerializeAndMaterialize: anObject.  self assert: (result instVarAt: 1) isNil.  self assert: (result instVarAt: 2) isNilencodeBitmap: aBitmap  aBitmap writeOn: streamtestConsiderGlobal  | aSerializer anArray materializedArray |  anArray := Array with: Set new with: Set new.  testingEnvironment at: #GlobalSet1 put: anArray first.  testingEnvironment at: #GlobalSet2 put: anArray second.  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:aStream |  aSerializer := FLSerializer newDefault.        aSerializer analyzer considerGlobal: #GlobalSet1.        aSerializer serialize: anArray on: aStream ].  materializedArray := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:aStream |  (FLMaterializer newDefault materializeFrom: aStream) root ].  [ (testingEnvironment at: #GlobalSet1) == materializedArray first ] assert.  [ (testingEnvironment at: #GlobalSet2) ~~ materializedArray second ] asserttestVariableRename  | pointClass aPoint resultPoint pointClassName |  pointClass := self newClassWithInstanceVariableNames: 'x y'.  pointClassName := pointClass name.  aPoint := pointClass new.  aPoint instVarNamed: 'x' put: 7.  aPoint instVarNamed: 'y' put: 11.  self serialize: aPoint.  self redefined: pointClass with: 'posY posX'.  self materializer migrateClassNamed: pointClassName variables: {('x' -> 'posX') .         ('y' -> 'posY')}.  resultPoint := self materialized.  self assert: (resultPoint instVarNamed: 'posX') equals: 7.  self assert: (resultPoint instVarNamed: 'posY') equals: 11newClassWithInstanceVariableNames: instanceVariableNames  ^self newClassWithInstanceVariableNames: instanceVariableNames superclass: ObjectanalysisStep  | anAnalysis |  anAnalysis := analyzer analysisFor: root.  clusters := anAnalysis clusterization clusters.  encoder objectCount: anAnalysis clusterization objectCountvisitTraitedMetaclass: aMetaclass  self mapAndTraceByClusterName: aMetaclass to: FLGlobalClassSideClustermaterializeInstanceWith: aDecoder  ^(self materializeGlobalClassFrom: aDecoder) classSidetestSameVersion  serializer version: 1.  materializer version: 1.  self assertSerializationEqualityOf: 'content'visitHookPrimitive: anObject  self mapAndTraceByObjectClass: anObject to: FLHookPrimitiveClustermaterializeReferencesStepWith: aDecoder  objects do: [:anObject |  self materializeReferencesOf: anObject with: aDecoder ]serializePostInstancesStepWith: anEncoder  classNamed: className  ^(migrations detect: [:m |  m sourceClassName = className ] ifNone: [ ^self globalClassNamed: className ]) targetClassnewClassOrTrait  ^self newClassWithInstanceVariableNames: ''metalevelClassSideBucket  ^metalevelClassSideBuckettestUniqueSubstitution  | result |  self analyzer when: [:x |  x isNumber ] substituteBy: [:x |  x printString ].  self deny: 1 printString identicalTo: 1 printString.  result := self resultOfSerializeAndMaterialize: (Array with: 1 with: 1).  self assert: result first equals: '1'.  self assert: result first identicalTo: result second= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^self right = anObject right and: [ self left = anObject left ]size  ^tallytestObsolete  | classOrTrait |  classOrTrait := self newClassOrTrait.  self removeFromSystem: classOrTrait.  self should: [ self serialize: classOrTrait ] raise: FLObsolete whoseDescriptionIncludes: classOrTrait name description: 'Should raise an error when serializing as global an obsolete class or trait.'testBlockClosureRemoved  | aClass aClosure |  aClass := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]';     yourself.  aClosure := aClass new perform: #methodWithClosure.  self serialize: aClosure.  aClass removeSelectorSilently: #methodWithClosure.  self should: [ self materialized ] raise: FLMethodNotFoundsetDefaultAnalysis  analysisFactory := [:anObject |  (FLAnalysis newWith: self firstInMapperChain private: self privateFirstInMapperChain root: anObject)     run;     yourself ]testClassAndVariableRename  | pointClass aPoint resultPoint pointClassName |  pointClass := self newClassWithInstanceVariableNames: 'x y'.  pointClassName := pointClass name.  aPoint := pointClass new.  aPoint instVarNamed: 'x' put: 7.  aPoint instVarNamed: 'y' put: 11.  self serialize: aPoint.  pointClass renameSilently: (pointClassName , 'Renamed') asSymbol.  pointClass := self redefined: pointClass with: 'posY posX'.  self materializer migrateClassNamed: pointClassName toClass: pointClass variables: {('x' -> 'posX') .         ('y' -> 'posY')}.  resultPoint := self materialized.  self assert: (resultPoint instVarNamed: 'posX') equals: 7.  self assert: (resultPoint instVarNamed: 'posY') equals: 11analyzer  ^serializer analyzeradd: anObject substitutedBy: anotherObject traceWith: aAnalysis  substitutions at: anObject ifAbsent: [ substitutions at: anObject put: anotherObject.        substitutes add: anotherObject.        aAnalysis trace: anotherObject ]newInstanceFrom: aClass  ^aClass newtestNextIndex  | indexes indexStream targetStream |  indexes := #(0 1 128 255).  targetStream := #() writeStream.  indexStream := self indexStreamOn: targetStream digits: 1.  indexes do: [:x |  indexStream nextIndexPut: x ].  indexStream := self indexStreamOn: targetStream contents readStream digits: 1.  indexes do: [:x |  self assert: indexStream nextIndex equals: x ]visitClassTrait: aClassTrait  self mapAndTraceByClusterName: aClassTrait to: FLGlobalClassSideClusterindex: anObject  index := anObjectnext: anObject  next := anObjectglobalClassNamed: className  ^globalEnvironment at: className ifAbsent: [ FLClassNotFound signalWithName: className ]redefined: aClass with: instanceVariableNames  | name |  name := aClass name.  self removeFromSystem: aClass.  ^(self withNotificationsNewClassWithInstanceVariableNames: instanceVariableNames) renameSilently: nameexpectedFailures  ^super expectedFailures , #(testWideString)initializeWith: someObjects  self initialize.  globals := someObjectstestGlobalClass  materializationEnvironment at: #Integer put: FLPerson.  self assert: (self resultOfSerializeAndMaterialize: Integer) identicalTo: FLPersongtGetMetaData  | assoc |  assoc := OrderedCollection new.  assoc add: 'Meta' -> (String streamContents: [:stream |  additionalObjects do: [:add |  add printOn: stream.                          stream crlf ] ]).  assoc add: 'Pre materialization actions:' -> (String streamContents: [:stream |  preMaterializationActions do: [:action |  action printOn: stream ] ]).  assoc add: 'Post materialization actions: ' -> (String streamContents: [:stream |  postMaterializationActions do: [:action |  action printOn: stream ] ]).  ^associnitializeWithClass: aClass  self initialize.  theClass := aClasstearDownClassFactory  self classFactory cleanUpat: key ifAbsentPut: aBlock  ^self at: key ifAbsent: [ self at: key put: aBlock value ]testSingletonMaterializationEnforcedNoInstance  | singleton materialized |  singleton := FLSingletonMockEnforced instance.  singleton reference: 'a reference'.  self assert: singleton equals: FLSingletonMockEnforced instance.  self serialize: singleton.  FLSingletonMock reset.  materialized := self materialized.  self deny: materialized identicalTo: singleton.  self deny: materialized reference isNil.  self assert: materialized reference equals: singleton reference.  FLSingletonMock resetnextEncodedInt32  | n firstDigit |  n := firstDigit := stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  firstDigit >= 128 ifTrue: [ n := -16r100000000 + n ].  ^nprintOn: aStream  super printOn: aStream.  aStream     nextPutAll: '(';     print: left;     space;     print: right;     nextPutAll: ')'resultOfSerializeAndMaterialize: anObject  self serialize: anObject.  ^self materializedreadTargetClassFrom: aPragma argumentNames: argumentNames argumentValues: argumentValues  | class |  class := Smalltalk at: (argumentValues at: (argumentNames indexOf: 'flExtensionOf:')) ifAbsent: [ ^nil ].  ^(aPragma method pragmas anySatisfy: [:pragma |  pragma key = #flExtensionClassSide ]) ifTrue: [ class class ] ifFalse: [ class ]testNestedBlockClosure  | closure materializedClosure |  closure := [ [ 42 ] ].  materializedClosure := self resultOfSerializeAndMaterialize: closure.  closure assertWellMaterializedInto: materializedClosure in: self.  self assert: materializedClosure value value equals: 42encodeHeaderWith: anEncoder  anEncoder encodeByte: (header isEmpty ifTrue: [ 0 ] ifFalse: [ 1 ]).  header isEmpty ifFalse: [ self class newDefault serializationFactory value: header value: anEncoder ]initializeWith: aMapper private: privateMapper root: anObject  self initialize.  firstMapper := aMapper.  privateFirstMapper := privateMapper.  aMapper analysis: self.  privateMapper analysis: self.  root := anObject.  objectStack := FLSimpleStack new.  privateObjectStack := FLSimpleStack new.  clusterization := FLClusterization new= anObject  ^self class = anObject classvisitWordsObject: anObject  self mapAndTraceByObjectClass: anObject to: FLWordObjectClusterexecuteAction  self serializeStackat: key ifPresent: presentBlock ifAbsent: absentBlock  | hash |  (keys at: (hash := key largeIdentityHash + 1)) ifNotNil: [:keyList |  1 to: (tallies at: hash) do: [:index |  (keyList at: index) == key ifTrue: [ ^presentBlock cull: ((values at: hash) at: index) ] ] ].  ^absentBlock valuesourceClassName  ^sourceClassNameregisterAll: someObjects  objectsWriteStream nextPutAll: someObjectsnextEncodedUint64  | n |  n := stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  ^nserializeInstance: anObject with: anEncoder  anEncoder encodePositiveInteger: anObject sizetestContextWithClosure  | context1 materializedContext1 |  context1 := self class blockClosureContextTesting.  materializedContext1 := self resultOfSerializeAndMaterialize: context1.  context1 assertWellMaterializedInto: materializedContext1 in: selffuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: nilcompileInTarget  | source |  source := self method methodClass instanceSide perform: self method selector withArguments: (1 to: self method selector numArgs) asArray.  self targetClass compile: source.  self targetClass organization classify: self selector under: self extensionProtocolNamemapAndTrace: anObject  anObject fuelAccept: selftestProxyInsideObjectByTarget  | aProxyClass result original pair |  aProxyClass := (self newSubclassOf: Object instanceVariableNames: 'target' classVariableNames: '')     duringTestCompileSilently: 'target: x  target := x';     duringTestCompileSilently: 'fuelAccept: aVisitor  ^aVisitor visitSubstitution: self by: target';     yourself.  original := aProxyClass new     target: 5;     yourself.  pair := FLPair new.  pair left: original.  pair right: 'foo'.  result := self resultOfSerializeAndMaterialize: pair.  self assert: result left equals: 5.  self assert: result right equals: 'foo'serializeReferencesStepWith: anEncoder  objects do: [:aCompiledMethod |  self serializeLiteralsOf: aCompiledMethod with: anEncoder ]clusterKeyedByClusterName: aClusterClass  ^self clusterKeyedByClusterName: aClusterClass factory: [ aClusterClass newAnalyzing ]registerAll: materializedObjects  decoder registerAll: materializedObjectsmethod  ^methodsetUp  super setUp.  serializationEnvironment := Dictionary new.  materializationEnvironment := Dictionary new.  self analyzer globalEnvironment: serializationEnvironment.  self materializer globalEnvironment: materializationEnvironmentdefaultBufferSize  ^8192initializeWith: aStreamStrategy  self initialize.  targetStrategy := aStreamStrategynewClassOrTraitWithSuperClass: superclass  ^self newClassWithInstanceVariableNames: '' superclass: superclasstestPrivateExcludedAndWithConflicts  | result |  self analyzer when: [:x |  FLPair == x ] substituteBy: [:x |  FLWeakClassMock ].  result := self resultOfSerializeAndMaterialize: {FLPair new .         FLPair}.  self assert: result first class identicalTo: FLPair.  self assert: result second identicalTo: FLWeakClassMockencodeUint24: aSmallInteger  stream     nextPut: ((aSmallInteger bitShift: -16) bitAnd: 255);     nextPut: ((aSmallInteger bitShift: -8) bitAnd: 255);     nextPut: (aSmallInteger bitAnd: 255)serializeGlobalAssociationKeyed: aSymbol on: anEncoder  anEncoder encodeString: aSymboltestCharacter  self assertSerializationIdentityOf: $a.  FLPlatform current isSpur ifTrue: [ self assertSerializationIdentityOf: (Character value: 12345) ] ifFalse: [ self assertSerializationEqualityOf: (Character value: 12345) ].  self assertSerializationEqualityOf: Character allCharacters.  self assertSerializationEqualityOf: (Array with: $a with: (Character value: 12345))serializeReferencesOf: anObject with: anEncoder  (self references at: anObject ifAbsent: [ ^self ]) do: [:value |  anEncoder encodeReferenceTo: value ]contents: anObject  contents := anObjectfuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: nilfuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: nilsetUpSerializer  serializer := FLSerializer newDefaultuseMultiByteFileStream  streamFactory := FLFileStreamStrategy newWithMultiByteFileStreammaterialization: aMaterialization  materialization := aMaterializationtestWideStringGlobal  | global globalValue |  global := 'Foox' asWideString     at: 4 put: (Character value: 265);     yourself.  globalValue := global , 'value'.  [ testingEnvironment at: global put: globalValue.  self analyzer considerGlobal: global.  self shouldnt: [ self serialize: 'bar' -> globalValue ] raise: Error.  self assert: self materialized class equals: Association.  self assert: self materialized value identicalTo: global ] ensure: [ testingEnvironment removeKey: global ]testClassSidePreservesIdentity  self assertSerializationIdentityOf: self newClassOrTrait classSidetestConsiderCustomGlobal  materializeReferencesOf: anObject with: aDecoder  self subclassResponsibilitynextEncodedByte  ^stream nextfileNamed: aFilename readStreamDo: aBlock  ^self subclassResponsibilityclusterKeyedByClusterName: aClusterClass factory: clusterFactory  ^self clusterInstanceOf: aClusterClass keyInBucket: aClusterClass name factory: clusterFactoryheader  ^headermethodWithTemp  | string |  string := 'test'.  self name.  self printStringindexStreamOn: aStream digits: aNumberOfDigits  ^FLIndexStream on: aStream digits: aNumberOfDigitsaddReferenceFrom: anObject to: anotherObject  | list |  list := self references at: anObject ifAbsentPut: [ OrderedCollection new ].  list add: anotherObjectsignature: anObject  signature := anObjectclusterization  ^clusterizationclassFactory  ^classFactorycapacity  ^array sizetestFloat  {180.0 .   0.0 .   -0.0 .   11.22321 .   -11.22321 .   -132311.22321 .   1234567890.123456789 .   -1234567890.123456789 .   Float e .   Float infinity .   Float halfPi .   Float negativeZero .   Float halfPi .   Float pi} do: [:aFloat |  self assertSerializationEqualityOrIdentityOf: aFloat ]testReadStream  | aReadStream materialized |  aReadStream := ReadStream on: 'A'.  materialized := self resultOfSerializeAndMaterialize: aReadStream.  self assert: $A equals: aReadStream next.  self deny: materialized atEnd.  self assert: $A equals: materialized next.  self assert: materialized atEndtestEmptyDictionary  self assertSerializationEqualityOf: Dictionary newtestContextWithSender  | context1 context2 materializedContext1 |  context1 := Context newForMethod: FLPair >> #method1.  context1 initializeWith: 23 stackPtr: 1 method: FLPair >> #method1 receiver: (FLPair new           right: 4;           left: 2) sender: nil.  context2 := Context newForMethod: FLPair >> #method2.  context2 initializeWith: 18 stackPtr: 1 method: FLPair >> #method2 receiver: (FLPair new           right: 5;           left: 6) sender: nil.  context1 privSender: context2.  materializedContext1 := self resultOfSerializeAndMaterialize: context1.  context1 assertWellMaterializedInto: materializedContext1 in: selfmaterializeInstanceWith: aDecoder  | methodClass selector method serializedHash |  methodClass := self materializeGlobalClassFrom: aDecoder.  aDecoder nextEncodedByte = 1 ifTrue: [ methodClass := methodClass classSide ].  selector := aDecoder nextEncodedString asSymbol.  method := methodClass compiledMethodAt: selector ifAbsent: [ FLMethodNotFound signalWith: methodClass name and: selector ].  serializedHash := aDecoder nextEncodedUint16.  method bytecodesHash = serializedHash ifFalse: [ FLMethodChanged signalWith: methodClass name and: selector ].  ^methodsetUp  super setUp.  currentTimeZone := DateAndTime localTimeZonematerializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint16nextEncodedUint32  | n |  n := stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  ^nheader: aHeader  header := aHeaderclusterInstanceOf: aClusterClass keyInBucket: clusterKey factory: clusterFactory  | bucket |  bucket := aClusterClass clusterBucketIn: analysis clusterization.  ^bucket at: clusterKey ifAbsentPut: [ clusterFactory value           traceWith: analysis;           yourself ]newSecondaryTrait  ^self newTraitSuffixed: 'Secondary'materializeReferencesStepWith: aDecoder  objects do: [:anObject |  self materializeReferencesOf: anObject with: aDecoder ]testSetRehash  | aSet person1 person2 person3 materializedSet newPerson1 |  aSet := Set new.  person1 := FLPerson new id: 1.  person2 := FLPerson new id: 5.  person3 := FLPerson new id: 8.  aSet     add: person1;     add: person2;     add: person3.  self assert: (aSet includes: person1).  self assert: (aSet includes: person2).  self assert: (aSet includes: person3).  materializedSet := self resultOfSerializeAndMaterialize: aSet.  newPerson1 := materializedSet detect: [:each |  each id = person1 id ].  newPerson1 id: 3.  materializedSet rehash.  self assert: (materializedSet includes: newPerson1)resultOfSerializeAndMaterializeMethod: aCompiledMethod  self analyzer considerInternalMethod: aCompiledMethod.  self serialize: aCompiledMethod.  ^self materializedserializeReferencesVariablePartOf: anObject with: anEncoder  (self variableReferences at: anObject ifAbsent: [ ^self ]) do: [:value |  anEncoder encodeReferenceTo: value ]deleteFileNamed: aFilename  FLPlatform current deleteFileNamed: aFilenameclusters  ^clusterstestGlobalMetaclassNotFound  self serialize: Integer class.  self should: [ self materialization ] raise: FLClassNotFound description: 'Raise an error since the class is not present in materialization global environment'referencesOf: aPoint do: aBlock  aBlock value: aPoint x.  aBlock value: aPoint yrun  objectStack push: root.  [ objectStack isEmpty ] whileFalse: [ self mapAndTrace: objectStack pop ].  [ privateObjectStack isEmpty ] whileFalse: [ self privateMapAndTrace: privateObjectStack pop ]version: anObject  version := anObjecthash  ^contents hashmaterialization  self error: 'Disabled, instead use #materialized.'metalevelInstanceSideBucket  ^metalevelInstanceSideBucketencodeVersionWith: anEncoder  anEncoder encodeUint16: self versionwriteStreamDo: aValuable  ^FLPlatform current fileNamed: self fileName writeStreamDo: [:aStream |  aValuable value: aStream binary ]add: anObject traceWith: aAnalysis  objects addLast: anObjecttestSmallIntegerNegative  self assertSerializationIdentityOf: -42serializeInstance: anInteger with: anEncoder  anEncoder encodeUint64: anIntegerkeys  ^Array new: tally streamContents: [:stream |  self keysDo: [:key |  stream nextPut: key ] ]testPrivateExcluded  | result |  self analyzer when: [:x |  x isBehavior ] substituteBy: [:x |  FLWeakClassMock ].  result := self resultOfSerializeAndMaterialize: {String new .         FLPair}.  self assert: result first class identicalTo: ByteString.  self assert: result second identicalTo: FLWeakClassMocknextEncodedUint24  | n |  n := stream next.  n := (n bitShift: 8) + stream next.  n := (n bitShift: 8) + stream next.  ^nobjectCount  ^self clusterBuckets sum: [:aClusterBucket |  aClusterBucket inject: 0 into: [:sum :aCluster |  sum + aCluster objects size ] ]serializeReferencesStepWith: anEncoder  objects do: [:anObject |  self serializeReferencesOf: anObject with: anEncoder ]writeStreamDo: aValuable  ^self fileStreamClass forceNewFileNamed: self fileName do: [:aStream |  aValuable value: aStream binary ]considerGlobal: aSymbol  globalSymbols add: aSymboladd: anObject name: globalName selector: selector traceWith: anAnalysis  self add: anObject traceWith: anAnalysis.  globalSends at: anObject ifAbsentPut: [ Association key: globalName value: selector ]mapAndTraceByObjectClass: anObject to: aClusterClass  (self clusterKeyedByObjectClass: aClusterClass class: anObject class) add: anObject traceWith: analysisisSpur  ^trueclusterMaterializeStepWith: aMaterialization  super clusterMaterializeStepWith: aMaterialization.  theClass := aMaterialization decoder nextEncodedReferenceinitialize  super initialize.  primitivesBucket := IdentityDictionary new.  baselevelBucket := IdentityDictionary new.  globalsBucket := IdentityDictionary new.  metalevelInstanceSideBucket := IdentityDictionary new.  metalevelClassSideBucket := IdentityDictionary new.  substitutionsBucket := IdentityDictionary new.  postBaselevelBucket := IdentityDictionary newinitialize  additionalObjects := IdentityDictionary new.  preMaterializationActions := OrderedCollection new.  postMaterializationActions := OrderedCollection newfuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: nilflushBuffer  position = 0 ifTrue: [ ^self ].  position = buffer size ifTrue: [ stream nextPutAll: buffer ] ifFalse: [ streamRespondsToNextPutAllStartingAt ifTrue: [ stream next: position putAll: buffer startingAt: 1 ] ifFalse: [ stream nextPutAll: (buffer copyFrom: 1 to: position) ] ].  position := 0serializeInstance: anInteger with: anEncoder  anEncoder encodeUint16: anInteger absnewTraitSuffixed: suffix  ^self classFactory newTraitNamed: (self traitNamePrefix , suffix) asSymbol uses: Array new tag: (self classFactory packageName , '-' , self classFactory defaultTagPostfix) asSymbolinitialize  tally := 0.  tallies := Array new: 4096 withAll: 0testSharedReferences  | sharedObject point1 point2 materialized array |  sharedObject := SmallInteger maxVal + 1.  point1 := Point x: sharedObject y: SmallInteger maxVal + 2.  point2 := Point x: SmallInteger maxVal + 2 y: sharedObject.  array := Array with: point1 with: point2.  materialized := self resultOfSerializeAndMaterialize: array.  self assert: array equals: materialized.  self assert: materialized first x == materialized second y description: 'An object that is referenced twice by the graph must not be duplicated when materialized'.  self deny: materialized first y == materialized second x description: 'Two (non-literal) objects must maintain different identity even if they are equal'globalEnvironment  ^globalEnvironmentflushBufferIfFull  position = buffer size ifTrue: [ self flushBuffer ]materializeInstanceWith: aDecoder  ^theClass fuelNewtestColorArray  self assertSerializationEqualityOf: (ColorArray with: (Color r: 0.0 g: 0.031 b: 0.008) with: (Color r: 0.0 g: 0.07 b: 0.023))testCyclicLinksInArray  | a b c materializedA materialized |  a := Link new.  b := Link new.  c := Link new.  a nextLink: b.  b nextLink: c.  c nextLink: a.  materialized := self resultOfSerializeAndMaterialize: (Array with: a with: b with: c).  materializedA := materialized first.  self assert: materialized size equals: 3.  self assert: materializedA nextLink nextLink nextLink identicalTo: materializedA.  self deny: materializedA nextLink identicalTo: materializedA.  self deny: materializedA nextLink nextLink identicalTo: materializedAisSpur  ^truemapAndTraceInstanceSideGlobal: aClassOrTrait  (self clusterKeyedByClusterName: FLGlobalClassCluster) add: aClassOrTrait traceWith: analysistestContext  | context1 materializedContext1 |  context1 := Context newForMethod: FLPair >> #method1.  context1 initializeWith: 23 stackPtr: 1 method: FLPair >> #method1 receiver: (FLPair new           right: 4;           left: 2) sender: nil.  materializedContext1 := self resultOfSerializeAndMaterialize: context1.  context1 assertWellMaterializedInto: materializedContext1 in: selfsizeBuffer: size  buffer ifNotNil: [ self flushBuffer ].  buffer := (stream isBinary ifTrue: [ ByteArray ] ifFalse: [ String ]) new: sizenewClassOrTrait  ^self newTraitSuffixed: 'Main'globalSymbols  ^globalSymbolsmaterializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint16 negatedinitializeAnalyzing: aClass  self initializeAnalyzing.  theClass := aClassflush  self flushBuffer.  stream flushfuelAccept: aGeneralMapper  ^aGeneralMapper visitGlobalSend: self name: #FLGlobalSendMock selector: #newInstanceToMaterializeencoder  ^encoderverifyVersionFrom: aDecoder  | streamVersion |  streamVersion := aDecoder nextEncodedUint16.  self version = streamVersion ifFalse: [ FLBadVersion signalCurrentVersion: self version streamVersion: streamVersion ]setUp  super setUp.  self useStandardFileStreamadd: anObject traceWith: aAnalysis  objects addIfNotPresent: anObject ifPresentDo: [ ^self ].  self referencesOf: anObject do: [:aChild |  | actual |        actual := aChild fuelReplacement.        self addReferenceFrom: anObject to: actual.        aAnalysis trace: actual ].  self variablePartReferencesOf: anObject do: [:aChild |  | actual |        actual := aChild fuelReplacement.        self addVariableReferenceFrom: anObject to: actual.        aAnalysis trace: actual ]materialization  self streamFactory readStreamDo: [:aStream |  ^self materializer materializeFrom: aStream ]assertSerializationIdentityOf: anObject  | result |  result := self resultOfSerializeAndMaterialize: anObject.  self assert: anObject == result description: 'The materialized object is not the same as the serialized one'testInstalled  | materialized |  self useInstalled.  self assert: theCompiledMethod isInstalled.  self deny: theCompiledMethod isDoIt.  self deny: theCompiledMethod trailer hasSource.  self deny: theCompiledMethod trailer isEmpty.  self assert: theCompiledMethod trailer hasSourcePointer.  materialized := self resultOfSerializeAndMaterialize: theCompiledMethod.  self assert: materialized identicalTo: theCompiledMethodleft  ^lefttestPluggableSubstitution  | objectToSerialize aSerializer materializedObject |  objectToSerialize := Array with: 'hello' with: '' writeStream.  FLPlatform current fileNamed: 'demo.fuel' writeStreamDo: [:aStream |  aSerializer := FLSerializer newDefault.        aSerializer analyzer when: [:o |  o isStream ] substituteBy: [:o |  nil ].        aSerializer serialize: objectToSerialize on: aStream ].  materializedObject := FLPlatform current fileNamed: 'demo.fuel' readStreamDo: [:aStream |  (FLMaterializer newDefault materializeFrom: aStream) root ].  self assert: materializedObject equals: (Array with: 'hello' with: nil)run  self analysisStep.  self headerStep.  self instancesStep.  self referencesStep.  self trailerStepuseGzipInMemoryStream  streamFactory := FLGZipStrategy newWithTarget: FLByteArrayStreamStrategy newserializeInstance: aCompiledMethod with: anEncoder  | methodClass |  methodClass := aCompiledMethod methodClass.  self serializeGlobalClass: methodClass instanceSide on: anEncoder.  anEncoder encodeByte: (methodClass isClassSide ifTrue: [ 1 ] ifFalse: [ 0 ]).  anEncoder encodeString: aCompiledMethod selector.  anEncoder encodeUint16: aCompiledMethod bytecodesHashtestPush  | stack |  stack := FLSimpleStack new.  stack push: 1.  self deny: stack isEmptydecodeHeaderWith: aDecoder  ^aDecoder nextEncodedByte = 0 ifTrue: [ FLHeader new ] ifFalse: [ (self class newDefault materializationFactory value: aDecoder) root ]testLotsOfCharacters  | all |  all := OrderedCollection new.  1 << 16 timesRepeat: [ all add: (1 to: 255) atRandom asCharacter ].  self assertSerializationEqualityOf: allinitializeWith: aByteSymbol  super initialize.  contents := aByteSymbolfuelAccept: aGeneralMapper  ^aGeneralMapper visitGlobalSend: self name: #FLKeyNotPresentInSmalltalks selector: #someSelectortestGradientFillStyle  self assertSerializationEqualityOf: GradientFillStyle sampletearDownGlobalVariables  testingEnvironment removeKey: #FLGlobalVariableForTesting ifAbsent: [  ]buffer  buffer ifNil: [ self sizeBuffer: self defaultBufferSize ].  ^bufferreferencesOf: anObject do: aBlock  mapping do: [:index |  aBlock value: (anObject instVarAt: index) ]testAllRangeOfIntegers  1 to: 100 do: [:shift |  self assertSerializationEqualityOrIdentityOf: 1 << shift.        self assertSerializationEqualityOrIdentityOf: 0 - (1 << shift) ]fuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: nilwriteStreamDo: aValuable  self subclassResponsibilitytestSingletonMaterialization  | singleton materialized |  singleton := FLSingletonMock instance.  singleton reference: 'a reference'.  self assert: singleton equals: FLSingletonMock instance.  materialized := self resultOfSerializeAndMaterialize: singleton.  self deny: materialized identicalTo: singleton.  self deny: materialized reference isNil.  self deny: materialized reference identicalTo: singleton reference.  FLSingletonMock resettestContextWithTemp  | context1 materializedContext1 |  context1 := Context newForMethod: FLPair >> #methodWithTemp.  context1 initializeWith: nil stackPtr: 1 method: FLPair >> #methodWithTemp receiver: (FLPair new           right: 4;           left: 2) sender: nil.  context1 tempNamed: 'string' put: 'capo'.  materializedContext1 := self resultOfSerializeAndMaterialize: context1.  self assert: (materializedContext1 tempNamed: 'string') equals: 'capo'.  context1 assertWellMaterializedInto: materializedContext1 in: selfserializeInstance: aCompiledMethodToSerialize with: anEncoder  | header bytecodesPlusTrailerSize cmSize cmInitialPC aCompiledMethod |  aCompiledMethod := self class transformationForSerializing value: aCompiledMethodToSerialize.  header := aCompiledMethod header.  cmSize := aCompiledMethod size.  cmInitialPC := aCompiledMethod initialPC.  bytecodesPlusTrailerSize := cmSize - cmInitialPC + 1.  anEncoder     encodeInt32: header;     encodeUint16: bytecodesPlusTrailerSize.  cmInitialPC to: cmSize do: [:index |  anEncoder encodeByte: (aCompiledMethod at: index) ]addReferencesFrom: anObject to: aCollection  aCollection do: [:ref |  self addReferenceFrom: anObject to: ref ]testFalse  self assertSerializationIdentityOf: falsematerializeGlobalClassFrom: aDecoder  | className |  className := aDecoder nextEncodedString asSymbol.  ^aDecoder classNamed: classNametestBadVersion  serializer version: 2.  materializer version: 1.  self should: [ self resultOfSerializeAndMaterialize: 'content' ] raise: FLBadVersion whoseDescriptionIncludes: '2' description: 'The materializer should raise an error when version differs of the expected one.'initialize  super initialize.  array := Array new: 4096.  includesNil := falsemigrateClassNamed: aSymbol variables: aDictionary  self migrateClassNamed: aSymbol toClass: (self class environment at: aSymbol) variables: aDictionarytestDateOffsetsChanging  | bst sast object |  bst := TimeZone timeZones third.  sast := TimeZone timeZones fourth.  DateAndTime localTimeZone: bst.  self assert: DateAndTime now offset equals: 1 hour.  object := Date fromDays: 37023.  self assert: object start offset equals: 0 hours.  self serialize: object.  DateAndTime localTimeZone: sast.  self assert: DateAndTime now offset equals: 2 hours.  object := Date fromDays: 37023.  self assert: object start offset equals: 0 hours.  self assert: self materialized start offset equals: 0 hourstestStringGlobalsAndClosure  | materialized |  materialized := self resultOfSerializeAndMaterialize: (Array with: 'a string' with: Smalltalk with: [ Smalltalk vm.              'a string' ]).  self assert: materialized first equals: 'a string'.  self assert: materialized second identicalTo: SmalltalkinitializeWith: anObject  super initialize.  contents := anObjectmaterializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint24 negatedcopyWordObjectToBuffer: aWordObject  | blt |  blt := (BitBlt toForm: (Form new hackBits: self buffer)) sourceForm: (Form new hackBits: aWordObject).  blt combinationRule: Form over.  blt     sourceX: 0;     sourceY: 0;     height: aWordObject byteSize // 4;     width: 4.  blt     destX: 0;     destY: position // 4.  blt copyBitspreMaterializationActions: listOfPreMaterializationActions  preMaterializationActions := listOfPreMaterializationActionstestConsiderCustomWideSymbolGlobal  | aWideSymbol aPerson |  aWideSymbol := (WideString streamContents: [:stream |  256 to: 280 do: [:code |  stream nextPut: code asCharacter ] ]) asSymbol.  self analyzer considerGlobal: aWideSymbol.  aPerson := FLPerson new.  [ testingEnvironment at: aWideSymbol put: aPerson.  self shouldnt: [ self resultOfSerializeAndMaterialize: aPerson ] raise: Error ] ensure: [ testingEnvironment removeKey: aWideSymbol ]testSubstituteUndefinedObjectInPresenceOfNil  self testSubstitute: UndefinedObject inPresenceOf: nilclusterSerializeStepWith: aSerialization  super clusterSerializeStepWith: aSerialization.  aSerialization encoder encodeReferenceToClusterObjectClass: theClassresultOfSerializeAndMaterializeMethodDictionary: aMethodDictionary  | materialized |  materialized := self resultOfSerializeAndMaterialize: aMethodDictionary.  self assert: (materialized isEqualRegardlessMethodsTrailerTo: aMethodDictionary)serializeInstance: anObject with: anEncoder  anEncoder encodePositiveInteger: anObject basicSizeapplyTo: aVariablesMapping  variables do: [:link |  aVariablesMapping map: link key to: link value ]serializeInstance: anObject with: anEncoder  self serializeGlobalAssociationKeyed: (anEncoder globalEnvironment keyAtValue: anObject) on: anEncodernextIndexPut: v  1 to: digits do: [:i |  stream nextPut: (v byteAt: digits + 1 - i) ]serializeInstance: anInteger with: anEncoder  anEncoder encodeUint16: anIntegerhelp  ^'Serialize a portion of the current stack trace using fuel.'visitDictionary: aDictionary  self mapAndTraceByObjectClass: aDictionary to: FLDictionaryCollectionClusterserializeReferencesVariablePartOf: anObject with: anEncoder  1 to: anObject basicSize do: [:index |  anEncoder encodeWeakReferenceTo: (anObject basicAt: index) ]nextEncodedUint8  ^stream nextmaterializeInstanceWith: aDecoder  ^aDecoder nextEncodedUint64materializeInstanceWith: aDecoder  ^theClass materializeFrom: aDecodertestCompiledMethodChanged  | classA classB |  classA := self newClass     duringTestCompileSilently: 'm  ^ 42';     yourself.  classB := self newClass     duringTestCompileSilently: 'm  ^ [ 42 ]';     yourself.  materializationEnvironment at: classA name put: classB.  self serialize: classA >> #m.  self should: [ self materialization ] raise: FLMethodChanged description: 'Serialized and materialized methods should have the same bytecodes.'materializeHeaderFrom: aStream  | aDecoder |  aDecoder := FLDecoder on: aStream migrations: migrations globalEnvironment: globalEnvironment.  self verifySignatureFrom: aDecoder.  self verifyVersionFrom: aDecoder.  ^self decodeHeaderWith: aDecoderinitialize  super initialize.  self setDefaultAnalysis.  self useLightMappers.  pluggableSubstitutions := OrderedCollection new.  internalClasses := IdentitySet new.  internalMethods := IdentitySet new.  globalEnvironment := self class environment.  globalSymbols := self class defaultGlobalSymbols asIdentitySettestInstalledModified  | copy materialized |  self useInstalled.  self assert: theCompiledMethod isInstalled.  self deny: theCompiledMethod isDoIt.  self deny: theCompiledMethod trailer hasSource.  self deny: theCompiledMethod trailer isEmpty.  self assert: theCompiledMethod trailer hasSourcePointer.  copy := theCompiledMethod copy.  self deny: copy isInstalled.  self deny: copy isDoIt.  self deny: copy trailer hasSource.  self deny: copy trailer isEmpty.  self assert: copy trailer hasSourcePointer.  materialized := self resultOfSerializeAndMaterialize: copy.  self deny: materialized identicalTo: theCompiledMethod.  self deny: materialized identicalTo: copy.  self deny: materialized isInstalled.  self deny: materialized isDoIt.  self assert: materialized trailer hasSource.  self deny: materialized trailer isEmpty.  self deny: materialized trailer hasSourcePointertestDateAndTime  | initialTime initialDate |  initialTime := Time fromSeconds: 76020.  initialDate := Date fromSeconds: 3492288000.  self assertSerializationEqualityOf: (DateAndTime date: initialDate time: initialTime).  initialTime := Time hour: 24 minute: 60 second: 60.  initialDate := Date year: 3050 month: 12 day: 31.  self assertSerializationEqualityOf: (DateAndTime date: initialDate time: initialTime).  initialTime := Time hour: 24 minute: 60 second: 60.  initialDate := Date year: 1600 month: 12 day: 31.  self assertSerializationEqualityOf: (DateAndTime date: initialDate time: initialTime)visitSubstitution: anObject by: anotherObject  (self clusterKeyedByClusterName: FLSubstitutionCluster) add: anObject substitutedBy: anotherObject traceWith: analysistestNil  self assertSerializationIdentityOf: nilinitializeAnalyzing: aClass  self initializeAnalyzing.  theClass := aClasstestBadDestinationVariableRename  | pointClass aPoint pointClassName |  pointClass := self newClassWithInstanceVariableNames: 'x y'.  pointClassName := pointClass name.  aPoint := pointClass new.  self materializer migrateClassNamed: pointClassName variables: {('x' -> 'posX')}.  self serialize: aPoint.  self should: [ self materialized ] raise: Error.  self flag: #pharoTodoadd: anObject traceWith: anAnalysis  objects addLast: anObjecttestBlockClosureChangeSameBytecodes  | aClass aClosure materializedClosure |  aClass := self newClass     duringTestCompileSilently: 'methodWithClosure  ^ [ 41 ]';     yourself.  aClosure := aClass new perform: #methodWithClosure.  self serialize: aClosure.  aClass duringTestCompileSilently: 'methodWithClosure  ^ [ 42 ]'.  self deny: aClosure method isInstalled.  materializedClosure := self materialized.  self assert: materializedClosure value equals: 42position  ^position + stream positionreferences  ^referencesserializeInstance: aMethodContext with: anEncoder  anEncoder encodeByte: aMethodContext method frameSizetestDictionary  self assertSerializationEqualityOf: (Dictionary with: 1 -> 2)visitPoint: aPoint  self mapAndTraceByClusterName: aPoint to: FLPointClusterinitializeAnalyzing  notIgnoredVariables := self instanceVariableNamesToSerialize.  mapping := notIgnoredVariables collect: [:name |  theClass instVarIndexFor: name ]testNestedDictionary  | childDic dic |  childDic := Dictionary new.  childDic at: #child1 put: 'abcde'.  dic := Dictionary new.  dic at: #parent1 put: 'sample string.'.  dic at: #parent2 put: 100.  dic at: #parent3 put: #(10 20 30).  dic at: #parent4 put: childDic.  self assertSerializationEqualityOf: childDic.  self assertSerializationEqualityOf: dicpop  slotIndex := slotIndex - 1.  ^array at: slotIndexserializeInstance: anObject with: anEncoder  anObject serializeOn: anEncoderinitialize  super initialize.  self setDefaultMaterialization.  self signature: self class defaultSignature.  self version: self class currentVersion.  migrations := Dictionary new.  globalEnvironment := self class environmenttestInterval  self assertSerializationEqualityOf: (-10 to: 10 by: 5).  self assertSerializationEqualityOf: (-0 to: 0 by: 1).  self assertSerializationEqualityOf: (1 to: 10 by: 2).  self assertSerializationEqualityOf: (33333333333333331 to: 1444444444444444440 by: 2).  self assertSerializationEqualityOf: (0 to: 1 by: 2)initializeMaterializing  self initializeduring: aBlock rename: aClass as: anotherClass  [ testingEnvironment at: aClass name put: anotherClass.  ^aBlock value ] ensure: [ testingEnvironment at: aClass name put: aClass ]when: aCondition substituteBy: aFactory  pluggableSubstitutions add: aCondition -> aFactorytestRectangle  self assertSerializationEqualityOf: (10 @ 20 corner: 30 @ 40).  self assertSerializationEqualityOf: (1.1 @ 2.2 corner: 3.3 @ 4.4).  self assertSerializationEqualityOf: (1.1 @ -2.2 corner: -3.3 @ 4.4)sortedBlockClosureWithInstanceVariable  ^SortedCollection sortBlock: [:a :b |  instanceVariableForTesting ifTrue: [ a <= b ] ifFalse: [ a >= b ] ]instVar1  ^instVar1serialize: anObject toFileNamed: aFilename  FLPlatform current fileNamed: aFilename writeStreamDo: [:aFileStream |  self serialize: anObject on: aFileStream ]materializeReferencesStepWith: aDecoder  objects do: [:anObject |  self materializeReferencesOf: anObject with: aDecoder ]globalEnvironment: aDictionary  globalEnvironment := aDictionarytestScaledDecimal  self assertSerializationEqualityOf: 13 / 11s6.  self assertSerializationEqualityOf: -13 / 11s6.  self assertSerializationEqualityOf: 7621476292473147 / 9007199254740992s8.  self assertSerializationEqualityOf: -7621476292473147 / 9007199254740992s8.  self assertSerializationEqualityOf: -0 / 9007199254740992s8.  self assertSerializationEqualityOf: (13 / 11 asScaledDecimal: 6).  self assertSerializationEqualityOf: (11 / 13) asFloat asScaledDecimaltestSortedCollectionWithClassVariableReference  | aSortedCollection materialized |  ClassVariableForTesting := false.  aSortedCollection := self class sortedCollectionForTestingWithClassVariable.  materialized := self resultOfSerializeAndMaterialize: aSortedCollection.  ClassVariableForTesting := true.  materialized addAll: #(2 3 1).  aSortedCollection addAll: #(2 3 1).  aSortedCollection sortBlock assertWellMaterializedInto: materialized sortBlock in: self.  self assert: aSortedCollection asArray equals: materialized asArraytrace: anObject  objectStack push: anObjecttestBag  | bag materialized |  bag := Bag new.  bag add: 10.  bag add: 20.  bag add: 30.  bag add: 30.  materialized := self resultOfSerializeAndMaterialize: bag.  self assert: bag ~~ materialized.  self assert: bag equals: materialized.  self assert: materialized size equals: 4materializeReferencesStepWith: aDecoder  testDeserializedExternalAddressIsNull  | externalAddress byteArray |  externalAddress := ExternalAddress fromAddress: 1234567890.  byteArray := self serialize: externalAddress.  externalAddress := self deserialize: byteArray.  self assert: externalAddress isNullremoveFromSystem: aClassOrTrait  aClassOrTrait removeFromSystem: falsefuelAccept: aGeneralMapper  ^aGeneralMapper visitSubstitution: self by: niltestContextThisContext  | materializedContext context |  context := thisContextSample.  materializedContext := self resultOfSerializeAndMaterialize: context.  self deny: context identicalTo: materializedContext.  self assert: context pc equals: materializedContext pc.  self assert: context stackPtr equals: materializedContext stackPtr.  self assert: context method equals: materializedContext method.  self assert: context receiver equals: materializedContext receiver.  self deny: context sender identicalTo: materializedContext sender.  self assert: context sender pc identicalTo: materializedContext sender pc.  self assert: context sender stackPtr equals: materializedContext sender stackPtrencodeWords: aWordsObject  stream nextWordsPut: aWordsObjecttestLowercaseSomeSymbols  | result |  self analyzer when: [:x |  #A = x ] substituteBy: [:x |  #a ].  self analyzer when: [:x |  #B = x ] substituteBy: [:x |  #b ].  result := self resultOfSerializeAndMaterialize: #(A B C).  self assert: #(a b C) equals: resultserializeLiteralsOf: aCompiledMethod with: anEncoder  aCompiledMethod fuelPrepare.  1 to: aCompiledMethod numLiterals do: [:index |  anEncoder encodeReferenceTo: (aCompiledMethod literalAt: index) ]clusterSerializeStepWith: aSerialization  super clusterSerializeStepWith: aSerialization.  variablesMapping serializeOn: aSerialization encoderlightGlobalMappers  ^globalSymbols isEmpty ifTrue: [ #() ] ifFalse: [ Array with: (FLLightGlobalMapper for: globalSymbols in: self globalEnvironment) ]isEmpty  ^preMaterializationActions isEmpty and: [ postMaterializationActions isEmpty and: [ additionalObjects isEmpty ] ]testContextWithClosureContextWithOutPointerTesting  | context1 materializedContext1 |  context1 := self class blockClosureContextWithOutPointerTesting.  self assert: (context1 tempNamed: 'string') equals: 'test'.  materializedContext1 := self resultOfSerializeAndMaterialize: context1.  self assert: (materializedContext1 tempNamed: 'string') equals: 'test'.  context1 assertWellMaterializedInto: materializedContext1 in: selftestClassSideCompiledMethod  self assertSerializationIdentityOf: FLGlobalSendMock class >> #newInstanceToSerialize