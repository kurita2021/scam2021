package  ^packagesortFunction  ^sortFunctionbuild  diffMorph := DiffMorph from: self leftMethod sourceCode to: self rightMethod sourceCode.  diffMorph     contextClass: self rightMethod sourceCode;     hResizing: #spaceFill;     vResizing: #spaceFill;     showOptions: false.  self addMorph: diffMorph fullFrame: LayoutFrame identitymetaLevelsOf: aClass do: aBlock  self subclassResponsibilitytestCreationWithSingleSubquery  | subquery |  subquery := self subqueryFromScopeOf: Array.  query := ClyUnionQuery with: {subquery}.  self assert: query equals: subquery.  self deny: query identicalTo: subquerybuildStatusBar  statusBar := ClyStatusBarMorph new.  statusBar width: browser width.  self addMorphBack: statusBar.  self fillStatusBarupdateItemsWhichBelongsTo: aDataSource  | relatedItems updatedItems |  relatedItems := items select: [:each |  each belongsToDataSource: aDataSource ].  updatedItems := aDataSource itemCursor findItemsWith: (relatedItems collect: #actualObject).  relatedItems with: updatedItems do: [:myItem :updatedBrowserItem |  updatedBrowserItem ifNotNil: [ myItem updateItemWith: updatedBrowserItem ] ].  ^falsecollectMethodGroupProviders  ^{ClyBreakpointMethodGroupProvider new .   ClyMethodCounterGroupProvider new .   ClyWatchpointMethodGroupProvider new}critique  ^critiquetestClassVarsEnumeration  scope := ClyClassScope ofAll: {Object .         ClyClass1FromP1}.  scope classVariablesDo: [:each |  result add: each ].  self assert: result size equals: 1.  self assert: result anyOne equals: (ClyClassVariable on: Object classVariables first definedIn: Object)findParentItemOf: itemTypeClass  | parent |  parent := self parentItem ifNil: [ ^nil ].  (parent isBasedOnItemType: itemTypeClass) ifTrue: [ ^parent ].  ^parent findParentItemOf: itemTypeClassrestoreBrowserInstance  self snapshotState.  browser := navigationState createBrowserapplyBreakpointCondition: aBreakpoint  aBreakpoint oncemethodFromRoot1  selectsMethod: aMethod  ^aMethod isTaggedWith: tagtargetVarName  ^#readVar1selectedTextInterval  ^textMorph selectionIntervalisResult: aQueryResult affectedBy: aSystemAnnouncement  ^(aSystemAnnouncement affectsMethodsDefinedInPackage: package) and: [ scope includesMethodsAffectedBy: aSystemAnnouncement ]subscribe: anObject  self subscribe: anObject for: SystemAnnouncementtestRetrievesMetaLevelScope  self snapshotState.  self assert: navigationState metaLevelScope equals: browser metaLevelScopeselectsMethod: aMethod  ^aMethod isTestMethod and: [ aMethod isPassedTest not ]order  ^5000readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  runTestCases := aToolContext selectedClassesmethodGroup  ^methodGroupqueryClass  ^ClyFilterQuerycheckEmptyResult  | allCritiques |  allCritiques := baseCritiqueQuery execute.  ^(allCritiques items anySatisfy: [:each |  self selectsCritique: each ]) notadoptForDialog  (self areItemsLoaded and: [ self itemCount < 10 ]) ifTrue: [ self height: 100 ] ifFalse: [ self           height: 300;           enableFilterUsing: ClyRegexPattern new ]runUpdate  self isClosed ifTrue: [ ^self ].  dirty ifFalse: [ ^self ].  dirty := false.  itemCursor updateItemCache.  self updateExpandingItems.  queryView itemsChangedIn: self.  self tableRefreshhasMetaProperty: aPropertyClass  ^self metadata hasProperty: aPropertyClasstestAscending  function := ClyTraitFirstSortFunction ascending.  self assert: (function value: ClyTraitRoot1 value: ClyTraitRoot2).  self deny: (function value: ClyTraitRoot2 value: ClyTraitRoot1).  self deny: (function value: ClyClass1FromP1 value: ClyTraitRoot1).  self assert: (function value: ClyTraitRoot1 value: ClyClass1FromP1).  self assert: (function value: ClyTraitRoot1 value: ClyTraitRoot1).  self assert: (function value: ClyClass1FromP1 value: ClyClass1FromP1)deprecatedMethod1  self deprecated: 'it is deprecated method for testing deprecation analyzis'globalPositionOf: childDataSourceItem  self subclassResponsibilityselectedClassItems  | unique classItem |  unique := OrderedCollection new.  selectedItems do: [:each |  classItem := each systemDefinition definingClassItem.        unique detect: [:existing |  existing actualObject == classItem actualObject ] ifNone: [ unique add: classItem ] ].  ^uniquerecordState: aBrowserState  aBrowserState representsConcreteQuery ifFalse: [ ^self ].  waitingNewState ifFalse: [ ^self ].  undoExecuting | redoExecuting ifTrue: [ waitingNewState := false ].  undoExecuting ifTrue: [ redoList add: aBrowserState ] ifFalse: [ redoExecuting ifFalse: [ redoList removeAll ].        undoList add: aBrowserState ]isClassVariable  self subclassResponsibilityinitialize  super initialize.  environment := RGEnvironment new.  projectManager := ClyProjectManagerRegistry newtestCreationFromTwoDifferentTypedQueries  | subquery1 subquery2 |  subquery1 := ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: Array in: environment.  subquery2 := ClyQueryExampleReturningScopeBasis2 from: ClyScopeExample of: String in: environment.  query := subquery1 , subquery2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {subquery1 .         subquery2} asSet.  self assert: query requiredResult identicalTo: subquery1 requiredResultapplyChanges  | newClass |  newClass := browser compileANewClassFrom: self pendingText asString notifying: textMorph startingFrom: editingClass.  newClass ifNil: [ ^false ].  editingClass == newClass ifFalse: [ self removeFromBrowser ].  browser selectClass: newClass.  ^trueunsubscribe: anObject  environment announcer unsubscribe: anObjecttag1Method1  definingPackage: aPackage  definingPackageItem := ClyBrowserItem named: aPackage name with: aPackagenewName: anObject  newName := anObjectacceptTags  textMorph accept.  textMorph hasUnacceptedEdits: falsetestIsEmptyFromEmptyMethodScope  < expectedFailure>  super testIsEmptyFromEmptyMethodScopecreateCommandContext  ^ClyUnknownBrowserContext for: selfmetaLevelScope  ^ClyClassSideScopeaddInheritedMethodGroup  | group |  group := ClyAllMethodGroup withMethodsInheritedFrom: self queryScope.  items add: group asCalypsoBrowserItemclassesDo: aBlock  basisObjects do: [:each |  self allClassesRelatedTo: each do: aBlock ]collectMetadataOfMethods: aQueryResult  | property |  property := ClyTestResultProperty new.  aQueryResult rawItemsOf: ClyMethod do: [:method |  (method isTestMethod and: [ method methodClass isAbstract not ]) ifTrue: [ property accumulateTestMethod: method ] ].  property allCount > 0 ifTrue: [ aQueryResult addMetaProperty: property ]prepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  targetClass := aToolContext requestSingleClass: 'Choose class'.  targetClass := aToolContext currentMetaLevelOf: targetClassaffectsMethodsDefinedInPackage: aPackage  overridingSubclass allSuperclassesDo: [:each |  each package = aPackage ifTrue: [ ^true ] ].  ^falsetestForMetaclass  query := ClyClassReferencesQuery to: self referencedClass classSide.  self queryFromScope: ClyMethodScope of: self class >> #reference1OfClass.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfClassinitializeNavigationViews  self subclassResponsibilityclassSampleWhichHasGroup  ^ClyClassWithDeprecatedMethodsdescription  ^'Ban this rule'elementAt: rowIndex  | localIndex |  localIndex := rowIndex.  expandedItems do: [:each |  each position = localIndex ifTrue: [ ^each ].        (each hasChildAt: localIndex) ifTrue: [ ^each childrenItemAt: localIndex ].        (each isAfter: localIndex) ifTrue: [ self itemCursor moveTo: localIndex.              ^ClyDataSourceItem of: self value: self itemCursor currentItem ].        localIndex := localIndex - each childrenCount ].  self itemCursor moveTo: localIndex.  ^ClyDataSourceItem of: self value: self itemCursor currentItembuildingQuery: anEnvironmentQuery  buildingQuery := anEnvironmentQueryaddCritique: aCritique  | newSeverity |  newSeverity := ClyCritiqueSeverityProperty of: aCritique.  (newSeverity isMoreImportantThan: ruleSeverity) ifTrue: [ ruleSeverity := newSeverity ]ignoreNavigationDuring: aBlock  aBlock valuerequiredQueryResult  self subclassResponsibilityprepareBasisFrom: aCollection  ^aCollectioncollectMetadataOfClasses: aQueryResult  initializeNavigationViews  resultView := self newNavigationView.  resultView enableFilter: ClyQueryBrowserFilter.  resultView allowsDeselection: false.  resultView mainColumn     width: 250;     displayItemPropertyBy: [:item |  self classNameOf: item ].  (resultView addColumn: #name)     width: 400;     displayItemPropertyBy: [:item |  self mainNameOf: item ].  (resultView addColumn: #package)     width: 50;     displayItemPropertyBy: [:item |  self packageNameOf: item ]createClassQueryFrom: aPackageScope  ^ClyRestUntaggedClassesQuery from: aPackageScopecollectMetadataOf: aQueryResult by: anEnvironmentPlugin  anEnvironmentPlugin collectMetadataOfMethodGroups: aQueryResulttestCase  ^testCasetestDetectingDefiningClassFromSubclassClassSide  | varBinding var |  varBinding := ClyClass2FromP1 classVariableNamed: #ClassVar1.  var := ClyClassVariable on: varBinding visibleFrom: ClySubclassLOfClass2FromP1 class.  self assert: var definingClass equals: ClyClass2FromP1printTextLinePositionOf: aCharacterBlock  | result textLine linePosition |  textLine := aCharacterBlock textLine.  linePosition := aCharacterBlock stringIndex - textLine first + 1.  result := textLine lineNumber printString , '/' , self textArea lines size printString , ' [' , linePosition printString , ']'.  ^resultisMessageSelected  ^self selectedSourceNode isMessagesubtreeSize: anObject  subtreeSize := anObjectdefiningClassItem  ^definingClassItemexecute  self executeRefactoringsasSelectedParentsOf: itemTypeClass  | parents resultItems currentItems resultSet lastSelectedItem |  self isEmpty ifTrue: [ ^self ].  currentItems := items select: [:each |  each isBasedOnItemType: itemTypeClass ].  currentItems = items ifTrue: [ ^self ].  parents := items reject: [:each |  each isBasedOnItemType: itemTypeClass ] thenCollect: [:each |  each findParentItemOf: itemTypeClass ].  resultSet := parents asSet.  resultSet remove: nil ifAbsent: [  ].  resultSet addAll: currentItems.  resultItems := resultSet asOrderedCollection.  lastSelectedItem := self lastSelectedItem.  (resultSet includes: lastSelectedItem) ifTrue: [ resultItems remove: lastSelectedItem.        resultItems addFirst: lastSelectedItem ].  ^self class fromRoot: self rootDataSource items: resultItemsgetMetaProperty: aPropertyClass  ^self metadata getProperty: aPropertyClasscreateQuery  ^ClyUnionQuery with: {(ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: self class in: environment) .         (ClyQueryExampleReturningScopeBasis2 from: ClyScopeExample2 of: self class superclass in: environment)}isInSameStateAs: anotherDataSource  (super isInSameStateAs: anotherDataSource) ifFalse: [ ^false ].  collapsedItems size = anotherDataSource collapsedItems size ifFalse: [ ^false ].  ^collapsedItems allSatisfy: [:myItem |  anotherDataSource collapsedItems anySatisfy: [:anotherItem |  myItem isSameAs: anotherItem ] ]excludesHaltsForTesting: anObject  excludesHaltsForTesting := anObjectglobalPosition  ^ownerDataSource globalPositionOf: selftestNotAffectedByChangeOfNotAbstractMethod  query scope: (ClyClassScope of: ClyClassWhichInheritsAbstractClass in: environment).  self deny: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)package  ^packageinitialize  super initialize.  title := 'MessageBrowser'applyResultInContext: aToolContext  super applyResultInContext: aToolContext.  aToolContext tool criticView updateclassSampleWhichHasGroup  ^ClyClassWhichInheritsAbstractSubclasschangeStateOf: aQueryView by: aBlock  aBlock valueisEmpty  ^methodQuery hasEmptyResultincludesClassesAffectedBy: aSystemAnnouncement  self classesDo: [:each |  (aSystemAnnouncement affectsClass: each) ifTrue: [ ^true ] ].  ^falsetestClassEnumeration  | expected |  scope := ClySubclassScope of: ClyClass1FromP1.  scope classesDo: [:each |  result add: each ].  expected := ClyClass1FromP1 allSubclasses.  self assert: result asSet equals: expected asSetbuildTestSuite  self subclassResponsibilitylastSelectedClassGroup  ^self lastSelectedObjectdefaultMenuIconName  ^#monticelloPackagetestFromPackageWithoutTagsAndExtensions  self queryFromScope: ClyPackageScope of: ClyClass9FromPExtendedByP5 package.  self assert: resultItems isEmptymultipleScopeSample  ^self scopeClass ofAll: {self singleBasisSample .         self extraBasisSample} in: environmentwhen: anAnnouncementClass send: aSelector to: anObject  self environment announcer when: anAnnouncementClass send: aSelector to: anObjectorder  ^1.5selectedMethod  ^tool editingMethodrepresentsItemOfType: aClass  ^type isCalypsoItemType: aClassitemsWhere: conditionBlock  ^self prepareItems: (actualResult itemsWhere: conditionBlock)testConvertingToInterestingClassScope  | convertedScope |  scope := ClyCompositeScope on: {(ClySuperclassScope of: String in: environment localScope: ClyInstanceSideScope) .         (ClySubclassScope of: Array in: environment localScope: ClyClassSideScope)}.  convertedScope := scope asInterestingClassScope.  self assert: convertedScope class equals: ClyCompositeScope.  self assert: convertedScope subscopes asSet equals: {(ClyInterestingSuperclassScope of: String localScope: ClyInstanceSideScope) .         (ClySubclassScope of: Array localScope: ClyClassSideScope)} asSet.  self assert: convertedScope environment equals: environmentbuildItemFor: aClass from: aHierarchyMap depth: currentDepth  | item childDepth children subTreeSize childItem |  item := ClyBrowserItem named: aClass name with: aClass.  item depth: currentDepth.  items add: item.  childDepth := currentDepth + 1.  children := aHierarchyMap childrenOf: aClass.  subTreeSize := children size.  children do: [:child |  childItem := self buildItemFor: child from: aHierarchyMap depth: childDepth.        subTreeSize := subTreeSize + childItem localHierarchySize ].  item localHierarchySize: subTreeSize.  ^itemrebuild  self initializeItems.  metadata ifNil: [ metadata := ClyQueryResultMetadata new ].  metadata addProperty: ClyBackgroundProcessingTag instance.  self runBuildProcessprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  classGroup := aToolContext requestSinglePackage: 'Choose package'priority: anObject  priority := anObjectmethodSelectionChanged  | actualMethods |  actualMethods := self methodSelection actualObjects.  methodGroupView highlightItemsWhich: [:eachGroup |  actualMethods anySatisfy: [:eachMethod |  eachGroup actualObject includesMethod: eachMethod ] ]decorateBrowserItem: anItem ofMethodGroup: aMethodGroup  initialize  super initialize.  subgroupsQuery := ClyUnknownQuery instancescope  ^buildingQuery scopeexecute  | method |  method := browser searchDialog requestSingleObject: 'Choose method' from: browser methodView query.  browser selectMethod: methodisClassHasToBeImplemented: aClass  (self doesClassDefinedAsAbstract: aClass) ifTrue: [ ^false ].  aClass allSuperclassesDo: [:superclass |  superclass == Object ifTrue: [ ^false ].        self withAbstractMethodsOf: superclass do: [:abstractMethod |  | implementor |              implementor := aClass lookupSelector: abstractMethod selector.              implementor == abstractMethod ifTrue: [ ^true ] ] ].  ^falsetestConvertingWithNewBasisShouldKeepMetaLevelScope  | convertedScope |  scope := self singleScopeSample.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope withNewBasisObjects: {self extraBasisSample}.  self assert: convertedScope localScopeClass equals: ClyInstanceSideScopedefiningClass: anObject  definingClass := anObjectitemAt: globalPosition  ^items at: globalPosition - startPosition + 1browser  ^browserclassGroup: anObject  classGroup := anObjectcreateQuery  ^ClyAllProblemMethodQuery from: (ClyClassScope emptyIn: environment)testConvertingToAnotherScopeClass  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asScope: ClyScopeExample.  self assert: convertedScope class equals: ClyScopeExample.  self assert: convertedScope basisObjects asIdentitySet equals: scope basisObjects asIdentitySet.  self assert: convertedScope environment equals: environment= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^items = anObject itemsnewMethodGroupView  ^self newNavigationView     treeStructure: {(ClyMethodGroup -> #prepareSubgroupsQueryFrom:in:)};     requestNavigationBy: #methodGroupSelectionChanged;     neverRestoreSelectiontestIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  query subqueries: {(self subqueryFromScope: ClyScopeExample of: self class) .         (self subqueryFromScope: ClyScopeExample2 of: self class)}.  self assert: query isExecutedFromSingleScopetestFillingItems  queryResult fillWith: {Object .         Array .         Point}.  self assert: queryResult items asArray equals: {Array .         Object .         Point}classGroupSelection  ^packageView selection asSelectedItemsOf: ClyClassGroupqueryClass  ^ClyVariableReferencesQueryhash  ^super hash bitXor: tag hashcompileANewClassFrom: aString notifying: aController startingFrom: aClass  ^self system compileANewClassFrom: aString notifying: aController startingFrom: aClassaffectedMethod  ^affectedMethodshortName  ^'Vars'defaultMenuIconName  ^#smallQuestionIconnavigateSpawnedFullBrowser: aFullBrowser  self isScopedModeEnabled ifTrue: [ aFullBrowser switchToPackageScopeOf: packageView query scope basisObjects ].  self methodSelection isEmpty ifFalse: [ ^aFullBrowser selectMethod: self methodSelection lastSelectedItem actualObject ].  self classSelection isEmpty ifFalse: [ ^aFullBrowser selectClass: self classSelection lastSelectedItem actualObject ].  self packageSelection isEmpty ifFalse: [ ^aFullBrowser selectPackage: self packageSelection lastSelectedItem actualObject ]affectedPackage  ^affectedPackagelastSelectedMethodClass  | lastMethodItem |  lastMethodItem := self lastSelectedObjectIn: self selectedMethodItems.  ^lastMethodItem systemDefinition definingClasshash  ^super hash bitXor: relationScopeClasses hashfindItemsSimilarTo: sampleBrowserItems  | rest found |  self protectItemsWhile: [ rest := sampleBrowserItems as: OrderedCollection.        found := OrderedCollection new.        items do: [:existing |  rest detect: [:sample |  sample isSimilarTo: existing ] ifFound: [:sample |  existing prepareIn: environment.                    found add: existing.                    rest remove: sample.                    rest ifEmpty: [ ^found ] ] ].        ^found ]isAccessibleFrom: aClass  ^aClass = definingClass or: [ aClass inheritsFrom: definingClass ]lastSelectedMessage  ^SycMessageDescription ofMethod: self lastSelectedMethodscopes  ^browser allNavigationScopescriteriaBlock  ^criteriaBlocktestSelectsFFIMethod  self assert: (query selectsMethod: ClyClassWithFFIMethods >> #ffiMethod)untestedOneTwo: anObject  self two: anObjectaddProperty: aProperty  properties add: aPropertytestRetrievesMethodGroupContent  self snapshotState.  self assert: navigationState methodGroupQuery equals: browser methodGroupQuerytestConvertingAsRestrictedByAnotherScope  | newScope convertedQuery |  newScope := ClyScopeExample2 of: #newBasis in: environment.  convertedQuery := query restrictedByScope: newScope.  self assert: convertedQuery class equals: query class.  self assert: convertedQuery scope class equals: query scope class.  self assert: convertedQuery scope basisObjects equals: #(newBasis) asSettableDescription  ^'Sent ' , self currentCallsCount asString , ' times. Click to remove'createSelectionContext  ^self createSelectionContextOf: self selectionrestoreSelectedTools: selectedTools  | mainTool extraTools |  tools ifEmpty: [ ^self ].  mainTool := self selectMainTool.  extraTools := selectedTools reject: [:each |  each class = mainTool class ].  extraTools size = selectedTools size ifTrue: [ extraTools := #() ] ifFalse: [ mainTool isExtraSelectionRequested ifTrue: [ extraTools add: mainTool ] ].  (tools copyWithout: mainTool) do: [:currentTool |  extraTools detect: [:oldTool |  oldTool class = currentTool class ] ifFound: [ self restoreSelectionOfExtraTool: currentTool ] ifNone: [ currentTool deselectTab ] ].  extraTools ifNotEmpty: [ mainTool deselectTab.        mainTool selectAsExtraTab ].  mainTool waitBuildCompletiongetProperty: propertyClass ifAbsent: absentBlock  ^properties detect: [:each |  each isKindOf: propertyClass ] ifNone: absentBlockisBasedOn: someBasisObject  ^basisObjects includes: someBasisObjectbuild  dropList := self theme newDropListIn: World for: self list: #scopeNames getSelected: #currentScopeIndex setSelected: #currentScopeIndex: getEnabled: nil useIndex: true help: self currentScope description.  self addMorph: dropListinitiateUIChangeBy: aBlock  changesWasInitiatedByUser ifFalse: [ ^aBlock value ].  changesWasInitiatedByUser := false.  aBlock ensure: [ changesWasInitiatedByUser := true ]fillStatusBar  | position |  super fillStatusBar.  position := statusBar addContextItem: (ClyCursorPositionLabelMorph of: textMorph).  position comeToFront.  statusBar addCommandItem: (ClyTextWrapModeSwitchMorph of: textMorph).  statusBar addCommandItem: (ClyTextLineNumbersSwitchMorph of: textMorph).  statusBar addCommandItem: (ClyFormatAsReadSwitchMorph of: textMorph).  statusBar addCommandItem: (ClyMethodTagsAndPackageEditorMorph for: self)extensionMethod2FromClass9  pattern  ^patternpriority  ^100registerProjectManager: aPackageManager  aPackageManager systemEnvironment: self.  projectManager registerProjectManager: aPackageManagercreateQuery  ^ClyAllMethodsQuery from: ClyClassScope of: Object in: environmentdefaultHeight  ^30allProcesses  ^Process allSubInstancesshowMethodTag: tagName  tool selectMethodGroupNamed: tagNameupdate  self dataSource forceFullUpdatetestExpandedDataSourceIsClosed  | expandedItem |  self selectedItem expand.  self snapshotState.  expandedItem := navigationState dataSource expandedItems first.  self assert: expandedItem childrenDataSource isClosedtestFastQueryShouldBeSync  query passExecution.  queryResult rebuild.  self assert: queryResult isBuilt.  self assert: queryResult buildProcess isNiltestClassEnumerationOverMetaClass  | expected |  scope := ClySubclassScope of: ClyClass1FromP1 class.  scope classesDo: [:each |  result add: each ].  expected := ClyClass1FromP1 allSubclasses collect: #classSide.  self assert: result asSet equals: expected asSetasLocalClassScope  self subclassResponsibilityselectors: anObject  selectors := anObjectassertItems: itemValueWithDepthArray withValue: aBlockToGetValue  | i actualItem valueOfItem |  items := queryResult items.  self assert: queryResult size equals: itemValueWithDepthArray size / 2.  i := 1.  itemValueWithDepthArray pairsDo: [:expectedValue :expectedDepth |  actualItem := items at: i.        valueOfItem := aBlockToGetValue value: actualItem.        self assert: valueOfItem equals: expectedValue.        self assert: actualItem depth equals: expectedDepth.        i := i + 1 ]initialize  super initialize.  decorators := OrderedCollection new.  isManagedByUser := false.  isDirty := false.  self     changeTableLayout;     listDirection: #topToBottom;     hResizing: #spaceFill;     vResizing: #spaceFillchooseClassForEditorOfMethod: aMethod  | selectedClass |  self classSelection isSingleSelected ifTrue: [ selectedClass := self classSelection lastSelectedItem actualObject.        ^self currentMetaLevelOf: selectedClass ].  ^aMethod originnavigationEnvironment: anObject  navigationEnvironment := anObjecttestComparisonWithAnotherFilter  | anotherFilter |  filter := ClyItemNameFilter substringPattern: 'filter'.  anotherFilter := ClyItemNameFilter substringPattern: 'filter'.  self assert: filter equals: anotherFilter.  self assert: filter hash equals: anotherFilter hash.  anotherFilter := ClyItemNameFilter substringPattern: 'filter2'.  self deny: filter equals: anotherFilterexecute  testItems do: [:each |  self runTestItem: each ]= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^requiredResult = anObject requiredResult and: [ scope = anObject scope ]initialize  super initialize.  isForScripting := falsebuildGroupsFrom: aClassScope  | methodQuery methodGroup |  methodQuery := self createMethodQueryFrom: aClassScope.  (self shouldBuildGroupWith: methodQuery) ifFalse: [ ^#() ].  methodGroup := self createMethodGroupFor: methodQuery from: aClassScope.  methodQuery isAsync ifTrue: [ methodGroup := methodGroup asAsyncQueryGroup ].  ^Array with: methodGroupisClassScriptSelected  ^self isMethodSelected and: [ (self lastSelectedObjectIn: self selectedMethodItems) hasProperty: ClyClassScriptProperty ]editingClass: anObject  editingClass := anObjecttestFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(reader1OfVar1 reader2OfVar1 supeclassReaderOfVar1)testCreationOnSingleSubscopeOfMultipleObjects  | subscope |  subscope := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {subscope}.  self assert: scope basisObjects asSet equals: subscope basisObjects asSetreferencesTo: aVariableName  | class var |  class := self modelCurrentSelectedClass.  class isBehavior ifTrue: [ class slotNamed: aVariableName ifFound: [:slot |  var := ClyInstanceVariable on: slot visibleFrom: class.              ^self browser spawnQueryBrowserOn: (ClyVariableReferencesQuery of: var) ] ].  self browser browseReferencesTo: aVariableName asSymbol from: classdescription  ^'methods sources with ' , pattern value printStringensureVisibleSelection  self selection isEmpty ifFalse: [ ^self ].  UIManager default defer: [ self selection ensureVisibleLastItem ]isFromScopeWithClassKindOf: aClass  scope classesDo: [:each |  (each includesBehavior: aClass) ifTrue: [ ^true ] ].  ^falsetestAscending  function := ClySortItemGroupFunction ascending.  self assert: (function value: (ClyItemGroup named: 'group1' priority: 20) value: (ClyItemGroup named: 'group2' priority: 10)).  self deny: (function value: (ClyItemGroup named: 'group1' priority: 10) value: (ClyItemGroup named: 'group2' priority: 20)).  self deny: (function value: (ClyItemGroup named: 'group2') value: (ClyItemGroup named: 'group1')).  self assert: (function value: (ClyItemGroup named: 'group1') value: (ClyItemGroup named: 'group2'))prepareFullExecutionInContext: aBrowserContext  super prepareFullExecutionInContext: aBrowserContext.  script := aBrowserContext selectedClassScript.  targetClass := aBrowserContext selectedClasses detect: [:each |  script isImplementedByClass: each ] ifNone: [ script implementorClass ]iconForSpotterMenu  ^self iconNameForSpotterMenu ifNotNil: [:iconName |  Smalltalk ui iconNamed: iconName ]rewriteASTToSimulateExecutionInADifferentContext: anAST  | semanticallyAnalysedMethodAST allUndeclaredVariableNodes allUndeclaredVariableSymbols rewriter rewrittenConditionBlockProducerAST allMessageNodes receiverSuperclassValueNode intermediateAST analysedIntermediateAST rewriter2 |  rewriter := RBParseTreeRewriter new.  semanticallyAnalysedMethodAST := anAST doSemanticAnalysis.  rewriter replace: (RBVariableNode named: #ThisContext) name with: '(ThisContext lookupSymbol: #' , (RBVariableNode named: #ThisContext) name , ')'.  allMessageNodes := semanticallyAnalysedMethodAST allChildren select: [:astElem |  astElem isMessage ].  receiverSuperclassValueNode := self parserClass parseExpression: 'ThisContext receiver class superclass'.  allMessageNodes do: [:msgNode |  msgNode receiver class = RBSuperNode ifTrue: [ rewriter replaceTree: msgNode withTree: (RBMessageNode receiver: (self parserClass parseExpression: 'ThisContext receiver') selector: #perform:withArguments:inSuperclass: arguments: {(RBLiteralValueNode value: msgNode selector) .                           (RBArrayNode statements: msgNode arguments) .                           receiverSuperclassValueNode}) ] ].  intermediateAST := rewriter     executeTree: semanticallyAnalysedMethodAST;     tree.  analysedIntermediateAST := intermediateAST doSemanticAnalysis.  rewriter2 := RBParseTreeRewriter new.  allUndeclaredVariableNodes := analysedIntermediateAST allChildren select: [:astElem |  astElem isVariable and: [ astElem isUndeclared ] ].  allUndeclaredVariableSymbols := (allUndeclaredVariableNodes collect: [:varNode |  varNode name ]) asSet asArray.  allUndeclaredVariableSymbols withIndexDo: [:tempName :index |  rewriter2 replace: tempName with: '(ThisContext lookupSymbol: #' , tempName , ')' ].  rewriter2 replace: 'thisContext' with: 'ThisContext'.  rewriter2 replace: 'self' with: 'ThisContext receiver'.  rewrittenConditionBlockProducerAST := rewriter2     executeTree: analysedIntermediateAST;     tree.  ^rewrittenConditionBlockProducerAST doSemanticAnalysissimpleNameForSpotterMenu  ^'Class editor: ' , self editingClass nameextraParameter: anObject  extraParameter := anObjectinitializeForBrowserStateSpanshot  | copy |  super initializeForBrowserStateSpanshot.  copy := collapsedItems collect: [:each |  each copyForBrowserStateSnapshotOf: self ].  collapsedItems := copy asSortedCollection: [:a :b |  a position < b position ]findObjectsSameAsFilter  itemsView dataSource numberOfRows = 1 ifTrue: [ ^itemsView dataSource allElements collect: #actualObject ].  ^itemsView findItemsSameAsFilter ifNotEmpty: [:foundItems |  foundItems collect: #actualObject ]isResult: aQueryResult affectedBy: aSystemAnnouncement  | asyncGroups |  (scope includesMethodGroupsAffectedBy: aSystemAnnouncement) ifTrue: [ ^true ].  (aSystemAnnouncement isKindOf: ClyAsyncQueryIsDone) ifTrue: [ asyncGroups := aQueryResult items select: [:each |  each isKindOf: ClyAsyncMethodGroup ].        (asyncGroups anySatisfy: [:each |  each asyncQueryResult == aSystemAnnouncement queryResult ]) ifTrue: [ ^true ] ].  ^falsedecorateResultMethodEditor: aMethodEditor  aMethodEditor selectAnyString: {pattern value}toString: anItem  ^anItem nameupdateDefaultPackageFilter  DefaultPackageFilter := packageView filterField getText ifEmpty: [ nil ]selectsMethod: aMethod  ^aMethod isDeprecatedexecute  browser switchToHierarchicalResultbuildResult: aQueryResult  | packages |  packages := OrderedCollection new.  scope packagesDo: [:each |  packages add: each ].  aQueryResult fillWith: packagesallChildrenOf: aClass do: blockWithClass  | children |  children := parentMap at: aClass ifAbsent: [ ^self ].  children do: [:eachChild |  blockWithClass value: eachChild.        self allChildrenOf: eachChild do: blockWithClass ]passExecution  executionSemaphore signalbuildResult: aQueryResult  | methods |  methods := OrderedCollection new.  scope classesDo: [:eachClass |  methods addAll: (self methodsToImplementIn: eachClass) ].  aQueryResult fillWith: methodstestComparisonWithResultWithSameHierarchyAbdSortFunction  | queryResult2 |  queryResult2 := queryResult sortedBy: queryResult hierarchy sortFunction.  self assert: queryResult equals: queryResult2.  self assert: queryResult hash equals: queryResult2 hashinitialize  super initialize.  critiqueQuery := ClyAllMethodCritiqueQuery new= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^methodQuery = anObject methodQuery and: [ subgroupsQuery = anObject subgroupsQuery ]order  ^50000prepareStateBeforeExecution  super prepareStateBeforeExecution.  self specialSelectorIndexesprintCriteria  ^pattern valuetestNotSelectsMethodWithoutFlag  self deny: (query selectsMethod: ClyClassWithFlags >> #methodWithoutFlag)createMethodQueryFrom: aClassScope  ^ClyDeprecatedMethodsQuery from: aClassScopeprintContext  package ifNil: [ ^super printContext ].  classTag ifNil: [ ^package name ].  ^package name , ' / ' , classTagselectsMethod: aMethod  ^aMethod sendsAnySelectorOf: #(flag:)selectsMethod: aMethod  ^aMethod isFFIMethodreferenceOfAnotherClass  ^PointtestCheckIfEmpty  query scope: (ClyClassScope of: ClyClass2FromP1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ProtoObject in: environment).  self assert: query checkEmptyResultsetUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyInheritanceAnalysisEnvironmentPlugin neworderForBrowser  ^2collectMetadataOf: aQueryResult by: anEnvironmentPlugin  self subclassResponsibilityforBrowserItems  ^ClySortBrowserItemFunction with: selfprintVariables  ^variableQuery scope == scope ifTrue: [ variableQuery description ] ifFalse: [ variableQuery fullDescription ]asRefactorings  ^targetClass deprecationRefactoringsasLocalClassScope  ^selfisValidClass: inputClass  ^(inputClass isTestCase or: [ inputClass isMeta ]) notmarkWithChildrenOf: anItemTypeClass  self addProperty: (ClyItemChildrenTag childrenType: anItemTypeClass)hasPluginOf: aBrowserPluginClass  ^plugins anySatisfy: [:each |  each class = aBrowserPluginClass ]treeStructure  ^treeStructureupdateItemCache  isClassTagSelected  ^falseselectedItems  ^selectedItemstestFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector)checkEmptyResult  self analyzedObjectsDo: [:each |  each critiques ifNotEmpty: [ ^false ] ].  ^trueisPackageSelected: aPackage  ^self packageSelection includesActualObject: aPackagetype: aClass  type := aClassinitializeForBrowserStateSpanshot  | copy |  super initializeForBrowserStateSpanshot.  copy := expandedItems collect: [:each |  each copyForBrowserStateSnapshotOf: self ].  expandedItems := copy asSortedCollection: [:a :b |  a position < b position ]hasSubscriber: anObject  ^actualResult hasSubscriber: anObjectundoList  ^undoListabstractMethod2  self subclassResponsibilitytestMethodsEnumerationWhenBasisIsClass  | expected |  scope := ClyClassSideScope of: ClyClass1FromP1.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClass1FromP1 classSide localMethods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArrayaffectsMethodsDefinedInClass: aClass  ^overridingSubclass inheritsFrom: aClass instanceSidetestFromClassWhichTraitIsExtendedButNotItself  < expectedFailure>  self queryFromScope: ClyClassScope of: ClyClassWithTraits.  self assert: resultItems size equals: 0methodWithCritiques  ^ClyClassWithProblemMethods >> #methodWithHaltcopy  | copy |  copy := super copy.  type prepareCalypsoItemCopy: copy.  ^copyhasProperty: propertyClass  ^browserItem hasProperty: propertyClassdefaultMenuIcon  ^Smalltalk ui iconNamed: script iconNamesetUp  super setUp.  environment := ClyNavigationEnvironment overSystemEnvironment: ClySystemEnvironment currentImage.  environment detachFromSystem.  browser := self createBrowser.  browser navigationEnvironment: environment.  browser plugins removeAllinstanceSideClassVar1Writer  ClassVar1 := #classVar1ValuespotterPreviewCodeIn: aComposite  < spotterPreview: 10>  ^targetView spotterPreviewMorphIn: aCompositeclasses: classCollection  classes := classCollection asIdentitySetenableFilter: anItemStringFilterClass using: aStringPattern  self enableFilterWithFactory: (ClyTableFilterFactory of: anItemStringFilterClass using: aStringPattern)testComparisonToSimilarQueryWithDifferentTag  | query2 |  query2 := self createQuery.  query2 tag: #AnotherTag1.  self deny: query equals: query2readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  commitModel := aToolContext itembrowserContextWasChanged  self warnUserAboutChangedContext.  self rebuildStatusBarcheckEmptyResult  scope classesDo: [:each |  (each isTestCase and: [ each isAbstract not and: [ each hasFailedTest or: [ each hasErrorTest ] ] ]) ifTrue: [ ^false ] ].  ^truehasIconOrMarker  ^trueapplyResultInContext: aToolContext  super applyResultInContext: aToolContext.  aToolContext showPackage: package atClassTag: newNameswitchToFlatResult  DefaultQueryResult := self defaultFlatQueryResult.  self switchResultTo: expectedFlatQueryResultprojectChildrenSelection  ^packageView selection asSelectedParentsOf: ClyProjectChildItemcheckItemsOfCurrentSelection: currentSelection  | newItems |  isSameAsCurrent := false.  newItems := currentSelection items.  newItems size = items size ifFalse: [ ^self ].  newItems do: [:eachNewItem |  items do: [:eachMyItem |  (eachNewItem isSameAs: eachMyItem) ifFalse: [ ^self ] ] ].  isSameAsCurrent := truecreateQuery  ^ClyClassReferencesQuery to: self referencedClass from: (ClyClassScope of: Object in: environment)printBasisObject: aClass on: aStream  ^aStream nextPutAll: aClass nameareItemsLoaded  ^(self dataSource hasMetaProperty: ClyBackgroundProcessingTag) notsubqueryFromScope: aScopeClass of: aBasisObject  ^self subqueryFromScope: (aScopeClass of: aBasisObject)decorateMainTableCell: anItemCellMorph of: aDataSourceItem  | context |  context := ClyContextSelectionStrategy selectContextOfSingleItem: aDataSourceItem for: browser.  ClyTableDecorationStrategy activeInstancesInContext: context do: [:strategy |  strategy decorateMainTableCell: anItemCellMorph inContext: context ]collate: systemObject1 with: systemObject2  | function |  systemObject1 calypsoEnvironmentType = systemObject2 calypsoEnvironmentType ifTrue: [ function := self sortFunctionFor: systemObject1.        ^function collate: systemObject1 with: systemObject2 ].  ^systemObject1 calypsoEnvironmentType itemsSortOrderForCalypso threeWayCompareTo: systemObject2 calypsoEnvironmentType itemsSortOrderForCalypsowantsStayInDifferentContext  ^super wantsStayInDifferentContext | applyingChangescontext: aBrowserContext  context := aBrowserContexttestMethodsEnumerationOverMetaclassWhenBothMetaLevelsAreLocalScope  | expected |  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:each |  result add: each ].  expected := {Object .   Object class .   ProtoObject .   ProtoObject class} flatCollect: #localMethods as: IdentitySet.  self assert: result asIdentitySet equals: expectedcollapsedItems  ^collapsedItemsscopeClass  ^ClyTraitUserScopequeryResult  ^queryResultinitialize  super initialize.  self     changeTableLayout;     listDirection: #leftToRight;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     cellInset: 4testResult: anObject  testResult := anObjectqueryResult: anObject  queryResult := anObjectbuildParentMap: aHierarchyMap for: aClass  | eachClass superclass |  eachClass := aClass.  [ eachClass isRootInEnvironment ] whileFalse: [ superclass := eachClass superclass.        (aHierarchyMap includesClass: superclass) ifTrue: [ ^aHierarchyMap addChild: aClass to: superclass ].        eachClass := superclass ]attachToSystem  environment system subscribe: self for: MCPackageModifiedsetWindowTitle: aString in: aWindow  aWindow setLabel: aStringtestCheckEmptyQueryWhenThereIsNotEmptyResult  | query result |  query := self createQueryFromScopeOf: self class.  result := environment query: query.  self assert: result items notEmpty.  self deny: (environment isQueryEmpty: query)defaultColor  ^Color transparentdefaultMenuIconName  ^#removeIcontestComparison  | pattern pattern2 |  pattern := ClySubstringPattern with: 'subString' caseSensitive: true.  pattern2 := ClySubstringPattern with: 'subString' copy caseSensitive: true.  self assert: pattern equals: pattern2.  self assert: pattern hash equals: pattern2 hash.  pattern2 value: 'another pattern'.  self deny: pattern equals: pattern2.  pattern2 value: pattern value.  pattern2 isCaseSensitive: pattern isCaseSensitive not.  self deny: pattern equals: pattern2reference2OfClass  ^ClyClassReferencesQueryTestactualResult  ^actualResulttestIsAffectedByChangeOfOwnMethodWhichIsNotOverridden  query := ClyOverriddenMethodsQuery from: ClyClassScope of: ClyClassWhichInheritsAbstractClass in: environment.  self assert: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)referencedSelector  ^'clyReferencedMessage1' asSymbolisSelectedClassUsesTraits  | classItem |  classItem := self lastSelectedObjectIn: self selectedClassItems.  ^classItem isMarkedWith: ClyTraitUserTagsortFunction: anObject  sortFunction := anObjectdefaultFlatQueryResult  ^ClySortedQueryResult using: ClySortSystemItemFunction ascendingtestConvertingWithNewScopeWhenAllSubqueriesAreSameKind  | newScope convertedQuery |  query subqueries: {(self subqueryFromScope: ClyScopeExample of: Array) .         (self subqueryFromScope: ClyScopeExample2 of: String)}.  newScope := ClyScopeExample2 of: #someBasis in: environment.  convertedQuery := query withScope: newScope.  self assert: convertedQuery class equals: query subqueries anyOne class.  self assert: convertedQuery scope equals: newScope.  self assert: convertedQuery requiredResult identicalTo: query requiredResulttestFillingWithClassWithoutTraits  queryResult fillWith: {ClyClassWithoutTraits}.  self assertItems: {ClyClassWithoutTraits .         0}createMethodGroupFor: aMethodQuery from: aClassScope  self subclassResponsibilitymessages  ^messagestoggleMode: aBool  self executeCommandevaluate  | importer class createdClass |  importer := RGChunkImporter new.  importer fileInFrom: (definitionString , '!') readStream.  class := importer environment ask behaviors detect: [:each |  each isRingResolved and: [ each superclass isRingResolved ] ].  importer := RGChunkImporter new.  importer environment: environment.  importer fileInFrom: (definitionString , '!') readStream.  createdClass := environment ask behaviorNamed: class name.  createdClass superclass metaclass metaclass isRingResolved ifTrue: [ environment cleanWithMetaclassNamed: createdClass superclass metaclass metaclass name ].  ^createdClasssingleBasisSample  ^super singleBasisSample classSidegetProperty: aPropertyClass  ^properties detect: [:each |  each isKindOf: aPropertyClass ]initialize  super initialize.  baseCritiqueQuery := ClyAllBasisCritiqueQuery newinverted  ^self copy inverse: inverse notbelongsToCurrentBrowserContext  ^truedoesClassDefinedAsAbstract: aClass  ^(aClass classSide includesLocalSelector: #isAbstract) and: [ aClass instanceSide isAbstract ]testFromWrongClassScope  self queryFromScope: ClyClassScope of: self class superclass.  self assert: resultItems isEmptysetUp  super setUp.  query := self createQueryisForbidden  ^annotatedClass isAbstractcriticView  ^criticViewsubscopes  ^subscopestestConvertingWithNewBasisObjectsWhenThereIsExtraScopeParameter  | convertedScope |  scope := self singleScopeSample.  scope extraParameter: #testParameter.  convertedScope := scope withNewBasisObjects: {self extraBasisSample}.  self assert: convertedScope extraParameter equals: #testParameterdecorateBrowserItem: anItem ofClass: aClass  (aClass isTestCase not or: [ aClass isAbstract ]) ifTrue: [ ^self ].  anItem addProperty: (ClyTestResultProperty ofTestCase: aClass)isBuilt  ^super isBuilt and: [ (self hasMetaProperty: ClyBackgroundProcessingTag) not ]testConvertingToReducedScopeByExtraClassScope  | convertedScope extraClassScope increasedScope |  scope := self multipleScopeSample.  extraClassScope := ClySuperclassScope of: self class in: environment.  increasedScope := scope increasedByClassesFrom: extraClassScope.  convertedScope := increasedScope reducedByClassesFrom: extraClassScope.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects equals: (scope basisObjects collect: #instanceSide)initialize  super initialize.  self changeTableLayout.  self initializeTable.  self whenDoubleClickDo: [ self triggerDoubleClickCommands ].  shouldRestoreSelection := true.  changesWasInitiatedByUser := true.  treeStructure := #().  self setUpDataSource: ClyDataSource emptydefaultResult  ^ClyRawQueryResult newitemCount  ^resultView itemCountcreateQueryResult  ^ClySortedQueryResult using: ClySortByNameFunction ascendingselectsMethod: aMethod  selectors with: self specialSelectorIndexes do: [:selector :specialIndex |  (aMethod hasSelector: selector specialSelectorIndex: specialIndex) ifTrue: [ ^true ] ].  ^falseimportMethod: aMethod  cancelChanges  self updateMethodTagsAndPackage.  super cancelChangesaddMetaProperty: aProperty  self metadata addProperty: aPropertyclassSampleWhichHasGroup  ^ClyTestedClassTestorder  ^1.5description  ^'extension methods'activationPriority  ^self tabOrderinitializeToolsPanel  toolbar := ClyToolbarMorph of: self.  tabManager := ClyTabManager of: self.  toolPanel := PanelMorph new.  toolPanel name: 'tools panel'.  toolPanel     changeTableLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     listDirection: #topToBottom.  self addMorph: toolPanel fullFrame: ((0.0 @ 0.5 corner: 1.0 @ 1.0) asLayoutFrame topOffset: toolbar height negated).  toolPanel addMorphBack: toolbar.  toolPanel addMorphBack: tabManager tabMorphtestClassGroupEnumeration  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new.  scope := ClyPackageScope of: ClyClass7WithTag1FromP5 package in: environment.  scope classGroupsDo: [:each |  result add: each ].  self assert: (result collect: #class as: Set) equals: {ClyNoTagClassGroup .         ClyTaggedClassGroup .         ClyClassGroup} asSet.  self assert: (result select: [:each |  each class = ClyTaggedClassGroup ] thenCollect: #tag) sorted asArray equals: ClyClass7WithTag1FromP5 package tagsForClasses sorted asArraytoggle  [ ownerTool toggleExtendingPackage ] on: CmdCommandAborted do: [:err |   ].  checkbox updateLabelsetUp  super setUp.  installedBreakpoints := OrderedCollection newtestExpandedDataSourceWithoutQueryView  | expandedItem |  self selectedItem expand.  self snapshotState.  expandedItem := navigationState dataSource expandedItems first.  self assert: expandedItem childrenDataSource queryView isNilclassSampleWhichHasGroup  ^ClyMethodWatchpointsQueryTestasync  ^ClyAsyncQuery for: selfcreateQuery  ^ClyAllBasisCritiqueQuery from: self scopeWithCritiquesrestoreBrowserInstance  self snapshotState.  navigationState applyTo: browsername  ^name ifNil: [ self defaultName ]testClassVarsEnumerationFromClassSideOfDefiningClass  scope := ClyClassScope of: Object class.  scope classVariablesDo: [:each |  result add: each ].  self assert: result size equals: 1.  self assert: result anyOne equals: (ClyClassVariable on: Object classVariables first definedIn: Object)testConvertingToSemiAsyncQuery  | convertedQuery |  convertedQuery := query semiAsync.  self assert: convertedQuery class equals: ClyAsyncQuery.  self assert: convertedQuery actualQuery identicalTo: query.  self assert: convertedQuery requiredResult identicalTo: query requiredResult.  self assert: convertedQuery scope identicalTo: query scope.  self assert: convertedQuery asyncResult class equals: ClySemiAsyncQueryResultenableFilter  self enableFilter: ClyItemNameFilterprepareDefaultState  self prepareInitialStatepackages  ^packagestestFillingWithClassAndItsTraitsWhenSomeMiddleTraitIsMissing  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitRoot1 .         2}switchToMetaLevelScope: aMetaLevelScopeClass  metaLevelScope = aMetaLevelScopeClass ifTrue: [ ^self ].  self changeMethodGroupQueryBy: [ metaLevelScope := aMetaLevelScopeClass.        methodGroupQuery withMetaLevelScope: metaLevelScope ]singleBasisSample  ^#singleBasis= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^variableQuery = anObject variableQuerytestClassEnumerationWhenMetaClassIsBasis  scope := ClyBothMetaLevelClassScope of: ClyClass1FromP1 class.  scope classesDo: [:each |  result add: each ].  self assert: result asArray equals: {ClyClass1FromP1}testDetectingSpecialSelectorLikeIfTrue  query := ClyMessageSendersQuery of: #ifTrue:.  self queryFromScope: ClyMethodScope of: self class >> #senderOfIfTrue.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #senderOfIfTruewarnUserAboutDifferentContext  containerTab icon: (self iconNamed: #uncommentedClass)methodTags: tagsArray  methodTags := tagsArray.  extendingPackage := nilbuildTextMorph  textModel := RubScrolledTextModel new.  textModel interactionModel: self.  textMorph := textModel newScrolledText.  textMorph     width: self width;     beWrapped;     font: StandardFonts codeFont;     editingMode: self editingMode.  CmdKMDispatcher attachedTo: textMorph textArea withCommandsFrom: self.  self buildLeftSideBar.  textModel setInitialText: self editingTexttestNotBasedOnMultipleBasisWhenAllSubscopesHaveEmptyBasis  | subscope1 subscope2 |  subscope1 := ClyScopeExample emptyIn: environment.  subscope2 := ClyScopeExample emptyIn: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self deny: scope isBasedOnMultipleBasiscriticAnalysisScope  ^ClyMethodScope of: editingMethod in: browser navigationEnvironmentasRBEnvironment  ^RBClassEnvironment classes: self collectAllClassesasDesiredSelection  | itemsCopy |  itemsCopy := items collect: [:each |  each copy childrenDataSource: nil ].  ^ClyDesiredSelection fromRoot: rootDataSource items: itemsCopybuildToolsOn: toolsList for: aBrowserContext  | tool |  ClyTabActivationStrategy activeInstancesInContext: aBrowserContext do: [:strategy |  tool := strategy createToolFor: browser inContext: aBrowserContext.        browser decorateTool: tool.        toolsList add: tool ]collectMetadataOfClassGroups: aQueryResult  sortFunction: aSortFunction  super sortFunction: aSortFunction.  mergedParts do: [:each |  each sortFunction: aSortFunction ]description  ^String streamContents: [:s |  self printDescriptionOn: s ]requestSingleClass: queryTitle from: classCollection  ^tool searchDialog requestSingleObject: queryTitle from: ClyAllClassesQuery hierarchical inScope: (ClyClassScope ofAll: classCollection)overrideItemDepthByDelta: delta  ^itemDepth := item depth + deltaasGoToSpotterCandidate  ^ClyGoToSpotterCandidate target: self named: self simpleNameForSpotterMenu icon: self defaultIcon using: [ self           selectAsMainTab;           takeKeyboardFocus ]enableFilterWithFactory: aTableFilterFactory  table     enableFilter: aTableFilterFactory;     explicitFunctiondescription  ^'failed tests'localHierarchySize: childrenCount  childrenCount = 0 ifTrue: [ ^self ].  self addProperty: (ClyItemLocalHierarchyProperty size: childrenCount)mainNameOf: aBrowserItem  aBrowserItem type = ClyClass ifTrue: [ ^'' ].  ^aBrowserItem nameupdateTextAreaWhenPlugged  super updateTextAreaWhenPlugged.  isForScripting ifTrue: [ self textArea shoutStyler beForSmalltalkScripting ]testItemsInitialization  queryResult initializeItems.  self assert: queryResult items notNilasFullHierarchyScope  | subclassScope fullScope |  subclassScope := self asScope: ClySubclassScope.  fullScope := self withInheritedScope , subclassScope.  fullScope name: self class hierarchyScopeName.  ^fullScopecreateQuery  ^ClyActiveBreakpointsQuery from: ClyClassScope of: ClyClassWithHalts in: environmentexecute  browser switchToFlatResulttestConvertingToNewMetaLevel  | convertedScope |  scope := self createSampleScope.  self deny: scope localScopeClass equals: ClyInstanceSideScope.  convertedScope := scope withMetaLevel: ClyInstanceSideScope.  self assert: convertedScope class equals: scope class.  self assert: convertedScope localScopeClass equals: ClyInstanceSideScope.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environmentinitializeNavigationPanel  | eachViewExtent lastViewLeft |  navigationPanel := PanelMorph new.  navigationPanel name: 'navigation panel'.  navigationPanel changeProportionalLayout.  navigationViews := OrderedCollection new.  self initializeNavigationViews.  eachViewExtent := 1.0 / navigationViews size.  lastViewLeft := 0.0.  navigationViews do: [:each |  | frame |        frame := (lastViewLeft @ 0.0 corner: (lastViewLeft + eachViewExtent) @ 1.0) asLayoutFrame.        each == navigationViews last ifFalse: [ frame := frame rightOffset: -4 ].        navigationPanel addMorph: each fullFrame: frame.        lastViewLeft := lastViewLeft + eachViewExtent ].  navigationPanel addPaneSplitters.  self addMorph: navigationPanel fullFrame: ((0.0 @ 0 corner: 1.0 @ 0.5) asLayoutFrame bottomOffset: toolbar height negated)setUp  super setUp.  installedWatchpoint := ClyMethodWatchpointsQueryTest new     setUp;     installWatchpointInto: #methodWithWatchpointtestNotBasedOnSingleBasisWhenTwoSubscopesAreBasedOnSingleButDifferentObject  | subscope1 subscope2 |  subscope1 := ClyScopeExample of: #basisObject1 in: environment.  subscope2 := ClyScopeExample of: #basisObject2 in: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self deny: scope isBasedOnSingleBasiscreateQuery  ^ClyClassCommentsQuery withString: self expectedClassCommentSubstring from: (ClyPackageScope of: Object package in: environment)createQueryResult  ^(ClySubclassHierarchy new , ClyTraitUserHierarchy inverse) asQueryResult sortedBy: ClyTraitFirstSortFunction ascendingprepareExecutionInDropContext: aToolContext  super prepareExecutionInDropContext: aToolContext.  targetClass := aToolContext lastSelectedClass.  targetClass := aToolContext currentMetaLevelOf: targetClassdecorateMethodGroupTableCell: anItemCellMorph of: groupItem  anItemCellMorph addExtraIcon: #traittestIsBasedOnEmptyBasis  scope := self createSampleScope.  self assert: scope isBasedOnEmptyBasisprintCriteria  ^self printStringexecute  | env commit snapshot |  commit := repositoryModel commit.  env := RGEnvironment new.  commit packageNames do: [:packageName |  snapshot := commit snapshotFor: (RPackage named: packageName).        snapshot importInto: env asPackageNamed: packageName ] displayingProgress: 'loading'.  env clean.  env browseAs: repositoryModel entity descriptionexecute  | selectors |  selectors := messages collect: [:each |  each selector ].  browser spawnQueryBrowserOn: (ClyMessageSendersQuery ofAny: selectors)simpleNameForSpotterMenu  ^'Packages'createMethodQueryFrom: aClassScope  ^ClyUnclassifiedMethodsQuery from: aClassScopekmDispatcher  ^CmdKMDispatcher attachedTo: selftestRestoredBrowserInstanceWithActiveScope  browser activeScope: browser queryScopes last.  self restoreBrowserInstance.  self assert: browser activeScope equals: browser queryScopes lastmetaLevelScope  ^metaLevelScopegetPlugin: environmentPluginClass ifAbsent: absentBlock  ^plugins detect: [:each |  each class = environmentPluginClass ] ifNone: absentBlockdefaultMenuIconName  ^#jumpscope: aScope  aScope isBoundToEnvironment ifFalse: [ ^self error: 'Query should be always initialized with scope bound to concrete environment' ].  (aScope supportsQuery: self) ifFalse: [ self error: 'Given scope do not support given query! Try use #adoptQuery:' ].  scope := aScopeisSimilarTo: anotherBrowserTool  (super isSimilarTo: anotherBrowserTool) ifFalse: [ ^false ].  ^editingClass = anotherBrowserTool editingClassname  ^name ifNil: [ super printString ]printMethodTags  ^', ' join: ownerTool methodTagsprepareInitialState  methodGroupQuery := ClyAllMethodGroupsQuery sortedFrom: (metaLevelScope emptyIn: navigationEnvironment).  self switchToPackagesdescription  ^'(Re)initialize class'description  ^'active breakpoints'testNotSelectsMethodWithoutBreakpoint  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  self deny: (query selectsMethod: ClyClassWithBreakpoints >> #methodWithoutBreakpoints)execute  testItems do: [:each |  self runPackageTests: each actualObject ]setUpAvailablePlugins  ClyEnvironmentPlugin allSubclasses select: [:each |  each isAutoActivatedOn: self ] thenDo: [:each |  self addPlugin: each new ]createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'watchpoints' priority: 8.4 on: aMethodQuerydropElements: aPassenger index: rowIndex  | dropTargetItem |  dropTargetItem := self elementAt: rowIndex.  ^queryView dropPassenger: aPassenger at: dropTargetItemrootsDo: aBlock  self containerForChildren     addAll: roots;     do: aBlocktestPackageEnumeration  scope := ClyPackageExtensionScope ofAll: {Array package .         Object package}.  scope packagesDo: [:each |  result add: each ].  self assert: result asArray equals: {Array package .         Object package}decorateBrowserItem: anItem ofClassGroup: aClassGroup  aClassGroup decorateOwnBrowserItem: anItem= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^mergedParts = mergedPartsrequestMultipleVariables: queryTitle from: classes  ^tool searchDialog requestMultipleObjects: queryTitle from: ClyAllInstanceVariablesQuery sorted inScope: (ClyClassScope ofAll: classes) withInheritedScoperepresentsBrowserItems  ^falsetestCheckIfEmpty  query scope: (ClyMethodScope of: ClySubclassLOfClass0FromPExtendedByP1 >> #extensionMethodFromSubclassL in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClass9FromPExtendedByP5 >> #extensionMethodFromClass9 in: environment).  self assert: query checkEmptyResultpackageSampleWhichHasGroup  self subclassResponsibilityallContexts  | result |  result := OrderedCollection new.  self allContextsDo: [:each |  result add: each ].  ^resultclassGroup  ^classGrouplastSelectedClass  ^self lastSelectedObjectIn: self selectedClassesadoptForNewCalypsoQuery  ^self copyscript  ^scriptisResult: aQueryResult affectedBy: aSystemAnnouncement  (scope includesClassesAffectedBy: aSystemAnnouncement) ifTrue: [ ^true ].  (scope canDetectAffectOnClassesBy: aSystemAnnouncement) ifTrue: [ ^false ].  aQueryResult rawItemsDo: [:each |  (aSystemAnnouncement affectsClass: each) ifTrue: [ ^true ] ].  ^falseisAffectedByChangedMethod: aMethod  | selector methodClass |  selector := aMethod selector.  methodClass := aMethod origin.  scope classesDo: [:each |  each = methodClass ifTrue: [ ^true ].        ((methodClass inheritsFrom: each) and: [ each includesLocalSelector: selector ]) ifTrue: [ ^true ] ].  ^falsetestCheckIfEmpty  self assert: query hasEmptyResult.  self assert: query checkEmptyResultdefinitionIcon: iconName  | icon |  icon := self iconNamed: iconName.  ^self definitionMorph: icon asMorphnavigationEnvironment: aNavigationEnvironment  navigationEnvironment := aNavigationEnvironmentvariableQuery: aClassQuery  super variableQuery: (aClassQuery withResult: ClyClassBindings new)isClassVariable  ^falsedecorateMainTableCell: anItemCellMorph inContext: itemContext  annotatedClass decorateMainTableCell: anItemCellMorph inContext: itemContextselectedItems: anObject  selectedItems := anObjectsubscribe: anObject for: anAnnouncementClass  self unsubscribe: anObject.  environment announcer when: anAnnouncementClass send: #systemChanged: to: anObjectbuildParentMap: aHierarchyMap for: aClass  mergedParts do: [:each |  aHierarchyMap hierarchy: each.        each buildParentMap: aHierarchyMap for: aClass ].  aHierarchyMap hierarchy: selfisCommandAvailable: aCommand  ^aCommand canBeExecutedInMethodEditor: selftestSelectsMethodOnWhichItIsBased  self assert: (query selectsMethod: self class >> #method1)buildResult: aQueryResult  | groups |  groups := OrderedCollection new.  scope classGroupsDo: [:each |  groups add: each ].  aQueryResult fillWith: groupstestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithDeprecatedMethods >> #deprecatedMethod1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithDeprecatedMethods >> #notDeprecatedMethod in: environment).  self assert: query checkEmptyResultitemFilterClass  ^itemFilterClasstestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClass1FromP1 >> #tag1Method1) .         (Object >> #printString) .         (ClyClass2FromP1 >> #instanceSideClassVar1Reader)}.  self assert: foundSelectors equals: #(tag1Method1)asInheritedScope  ^ClyInheritedScopeProvider createInheritedScopeFrom: selfretrieveChildrenOf: aDataSourceItem  | childQuery childDataSource |  childQuery := queryView queryToExpand: aDataSourceItem ifAbsent: [ self error: 'cant retrieve children from ' , aDataSourceItem printString ].  childDataSource := ClyCollapsedDataSource on: childQuery.  childDataSource openOn: queryView.  ^childDataSourcedefaultMenuIcon  ^self testResult createIcontestFindItemsWithActualObjectsWhenTheyAreNotInCache  | found |  cursor cleanCache.  found := cursor findItemsWith: {#absentItem1 .         Array .         #absentItem2}.  self assert: found size equals: 3.  self assert: found first equals: nil.  self assert: found last equals: nil.  self assert: found second actualObject equals: Array.  self assert: found second isPrepared.  self assert: found second position equals: (self rawResultItems indexOf: Array)findItemsSimilarTo: sampleEnvironmentItems  | rest found existingItem |  actualResult protectItemsWhile: [ rest := sampleEnvironmentItems as: OrderedCollection.        found := OrderedCollection new.        actualResult items doWithIndex: [:existing :index |  existingItem := existing asCalypsoBrowserItem.              rest detect: [:sample |  sample isSimilarTo: existingItem ] ifFound: [:sample |  existingItem position: index.                    existingItem prepareIn: self environment.                    found add: existingItem.                    rest remove: sample.                    rest ifEmpty: [ ^found ] ] ].        ^found ]tag1Method1  testMethodsEnumerationOverMetaclassWhenClassSideIsLocalScope  | expected |  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassSideScope.  scope methodsDo: [:each |  result add: each ].  expected := {Object class .   ProtoObject class} flatCollect: #localMethods as: IdentitySet.  self assert: result asIdentitySet equals: expectedorder  ^1hash  ^super hash bitXor: sortFunction hashbuildTextMorph  super buildTextMorph.  self formatTextIfNeededretrieveAll  ^queryResult allItemsdefaultMenuIcon  | fullResult |  fullResult := self testResult.  runTestCases do: [:each |  fullResult concreteResultOf: runTestCases first ifPresent: [:testResult |  ^testResult createIcon ] ].  ^fullResult createIconretrievesItemsAs: aQueryResultClass  ^requiredResult isKindOf: aQueryResultClassscopeClass  ^ClyScopeExampleresetStateForSnapshot  super resetStateForSnapshot.  diffMorph := nilsubgroupsQuery  ^subgroupsQuerytestSelectsMethodWithCounter  self installCounterInto: #methodWithCounter.  self assert: (query selectsMethod: self class >> #methodWithCounter)value: anObject  value := anObjecttestCheckIfEmpty  query scope: (ClyClassScope of: ClyClass2FromP1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ProtoObject in: environment).  self assert: query checkEmptyResultqueryClass  ^self subclassResponsibilitytestCreationUnifiedInstance  self assert: query asUnifiedInstance identicalTo: queryincludesClassesAffectedBy: aSystemAnnouncement  ^falseexecute  | moveCommand |  methodGroups do: [:each |  moveCommand := SycMoveMethodsToClassCommand methods: each methods class: targetClass.        moveCommand execute.        each removeWithMethods ]printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  queryResult buildingQuery printOn: aStream.  aStream nextPut: $)projectManager: anObject  projectManager := anObjecttestSelectedTabsWithoutContext  | tab |  self snapshotState.  tab := navigationState selectedTabs first.  self assert: tab context isNilsomeNotDeprecatedMethod  asyncQueryResult: anObject  asyncQueryResult := anObjectinstalledMethods  ^self filterInstalledMethods: methodsretrieveStateFrom: aBrowser  browserState := aBrowser snapshotState.  (window := aBrowser window) ifNotNil: [ windowGroup := window ownerThatIsA: GroupWindowMorph ].  browserPlugins := aBrowser plugins collect: [:each |  each copy browser: nil ].  navigationEnvironment := aBrowser navigationEnvironment.  navigationHistory := aBrowser navigationHistorywithScope: aScope  | copy |  copy := self copy.  ^aScope adoptQuery: copytestOpeningShouldSubscribeObserver  self assert: (queryResult hasSubscriber: itemObserver).  self assert: cursor itemObserver equals: itemObserverinitializeTable  table := FTTableMorph new.  table allowsDeselection: true.  table beMultipleSelection.  table beResizable.  table dragEnabled: true.  table dropEnabled: true.  table onAnnouncement: FTSelectionChanged send: #selectionChanged to: self.  table addColumn: ClyMainTableColumn default.  table vResizing: #spaceFill.  table hResizing: #spaceFill.  self addMorph: tabletestConvertingWithoutBasisObjectsWhenSomeIsNotExist  | convertedScope |  scope := self createSampleScope.  convertedScope := scope withoutBasisObjects: {#absentObject .         scope basisObjects anyOne}.  self assert: convertedScope class equals: scope class.  self deny: (convertedScope basisObjects includes: scope basisObjects anyOne)decorateBrowserItem: anItem ofPackage: aPackage  aPackage classes ifNotEmpty: [ anItem markWithChildrenOf: ClyClass ].  (self checkPackageHasClassGroups: aPackage) ifTrue: [ anItem markWithChildrenOf: ClyClassGroup ]selectAnyString: strings  textMorph setSelection: (self findAnyString: strings in: self pendingText)definitionMorph: aMorph  definitionMorph := aMorph.  definitionMorph width: 16.  ^definitionMorphwriterOfVar1  readVar1 := #testValueapplyResultInContext: aToolContext  super applyResultInContext: aToolContext.  browser rebuildToolbarexpand: aDataSourceItem  queryView changeStateBy: [ collapsedItems remove: aDataSourceItem.        self expansionChanged ]testSelectorOf: testMethodItem  ^testMethodItem name asSymbolbrowser: anObject  browser := anObjectattachToSystem  super attachToSystem.  environment system when: MethodAdded , MethodRemoved send: #processMethodChange: to: self.  environment system when: ClassRemoved send: #processClassRemoval: to: self.  environment system when: ClassModifiedClassDefinition send: #processClassDefinitionChange: to: self.  environment system when: ClassModificationApplied send: #processFullClassChange: to: selfisLive  ^falseparentItem  ^parentItemwithMetaLevelScope: aScopeClass  ^self withScope: (scope withMetaLevel: aScopeClass)isEmpty  ^undoList isEmpty and: [ redoList isEmpty ]selectedTabs: anObject  selectedTabs := anObjectqueryView  ^ownerDataSource queryViewimportMethod: aMethod  aMethod tags do: [:each |  aMethod untagFrom: each ]whenDoubleClickDo: aBlock  table onAnnouncement: FTStrongSelectionChanged do: aBlockexpectedClassCommentSubstring  ^'it should be in the comment of this class to test class comment query'createBrowserContextOfSingleItem: aDataSourceItem for: aBrowser  ^annotatedClass of: {aDataSourceItem} for: aBrowsershowQueryResult  self showsFlatResult ifTrue: [ expectedFlatQueryResult := systemQuery requiredResult ].  self setUpActiveScope.  resultView showQuery: systemQuery semiAsyncshowItemsOf: aQuery  | actualQuery |  actualQuery := aQuery isBoundToEnvironment ifTrue: [ aQuery ] ifFalse: [ aQuery withScope: browser systemScope ].  itemsView showQuery: actualQuery semiAsync.  itemsView adoptForDialogattachToSystem  system subscribe: self.  plugins do: [:each |  each attachToSystem ]systemDefinitionClass  ^self systemDefinition definingClassdecorateTableCell: anItemCellMorph of: groupItem  super decorateTableCell: anItemCellMorph of: groupItem.  anItemCellMorph browser metaLevelScope = ClyClassSideScope ifTrue: [ anItemCellMorph label clyAddEmphasis: TextEmphasis bold ]publishCollectedChanges  self subclassResponsibilityfindAllItemsBy: aBlockWithDataSource  self findAllItemsBy: aBlockWithDataSource stopLookupWhen: [:result |  false ]defaultClassCompiler  ^self class compilerclassSelectionChanged  self changeStateBy: [ self showsFlatClasses ifFalse: [ self silentlySelectPackageOfSelectedClass ].        self changeMethodGroupQueryBy: [ self adoptForExtendedClass.              methodGroupQuery restrictedByScope: self defaultClassScopeForMethods ].        self selectCurrentExtensionMethodGroup ]tagEditingMethod: aMethod  | existingTags removedTags newTags |  self applyChangesBy: [ existingTags := aMethod tags reject: [:each |  each beginsWith: '*' ].        removedTags := existingTags reject: [:each |  methodTags includes: each ].        newTags := methodTags reject: [:each |  existingTags includes: each ].        newTags do: [:each |  aMethod tagWith: each asSymbol ].        removedTags do: [:each |  aMethod untagFrom: each asSymbol ] ]resultItemsType  ^self class resultItemsTypeisForScripting  ^truesubscopes: aCollection  aCollection ifEmpty: [ ^self error: 'ClyCompositeScope should include at least one subscope' ].  subscopes := aCollection.  environment := subscopes anyOne environment.  self basisObjects: (subscopes flatCollect: [:each |  each basisObjects ])iconName  ^'small' , name capitalized , 'Icon'browserContextWasChanged  applyingChanges ifFalse: [ super browserContextWasChanged ]startPosition: anObject  startPosition := anObjectisSameKindAs: anotherItem  ^self type = anotherItem typeenvironment  ^environmenttestSelectionWithRetrievedDataSourceCopy  self snapshotState.  self assert: navigationState selection rootDataSource equals: navigationState dataSourcetestBasedOnBasisObject  scope := self createSampleScope.  self assert: (scope isBasedOn: scope basisObjects anyOne).  self deny: (scope isBasedOn: #anotherObject)decorateTableCell: anItemCellMorph of: aDataSourceItem  | context |  context := ClyContextSelectionStrategy selectContextOfSingleItem: aDataSourceItem for: browser.  ClyTableDecorationStrategy activeInstancesInContext: context do: [:strategy |  strategy decorateTableCell: anItemCellMorph inContext: context ]definesChildren  self subclassResponsibilitydetectDefiningClassFrom: anUserClass  (anUserClass slots includes: actualVariable) ifTrue: [ definingClass := anUserClass.        ^self ].  anUserClass isRootInEnvironment ifTrue: [ self error: 'Cant find the class defining variable' ].  self detectDefiningClassFrom: anUserClass superclassrestoreTableSelection  | actualSelectionChanged |  actualSelectionChanged := items anySatisfy: #isRemoved.  self restoreTableSelectionSilently: actualSelectionChanged not.  ^actualSelectionChangedensureVisibleLastItem  testFillingWithSuperclassAndSubclassMethods  queryResult fillWith: ClyClass1FromP1 localMethods , ClySubclassN1OfClass1FromP1 localMethods.  self assertItems: #(#instanceSideVar1ReaderMethod 0 #instanceSideVar1WriterMethod 0 #superclassTag1Method 0 #tag1Method1 0 #noTagMethod 1 tag1Method1 1 tag1Method2 1 tag2Method1 1) withValue: [:each |  each name ]processClassDefinitionChange: aClassDefinitionChange  aClassDefinitionChange oldClassDefinition superclass ifNotNil: [:superclass |  (superclass subclasses includes: aClassDefinitionChange oldClassDefinition) ifTrue: [ ^self ] ].  aClassDefinitionChange oldClassDefinition superclass = aClassDefinitionChange newClassDefinition superclass ifTrue: [ ^self ].  environment systemChanged: (ClyOverriddenSuperclassesChanged overridingSubclass: aClassDefinitionChange oldClassDefinition)defaultMenuItemName  ^'Hier.'waitBuildCompletion  containerTab waitReadyMorphFor: 50 milliSecondsasScope: anotherTypedScopeClass of: singleBasisObject  ^anotherTypedScopeClass of: singleBasisObject in: environmentmetadata  ^metadatarestoreSelectionOfExtraTool: aBrowserTool  aBrowserTool hasUnacceptedEdits ifFalse: [ aBrowserTool selectAsExtraTab.        ^self ].  (self countToolsSimilarTo: aBrowserTool) = 1 ifTrue: [ aBrowserTool selectAsExtraTab ] ifFalse: [ aBrowserTool deselectTab ]decorateBrowserItem: anItem ofMethod: aMethod  (aMethod sendsAnySelectorOf: #(flag:)) ifTrue: [ anItem markWith: ClyMethodFlag ]testHasUnknownScopeByDefault  query := query class new.  self assert: query scope equals: ClyUnknownScope instancebrowseImplementorsOf: aSymbol  | classBinding classToBrowse |  aSymbol first isUppercase ifTrue: [ classBinding := self system bindingOf: aSymbol.        classBinding ifNotNil: [ classToBrowse := classBinding value.              classToBrowse isClassOrTrait ifFalse: [ classToBrowse := classToBrowse class ].              ^self spawnBrowser: ClyFullBrowser withState: [:browser |  browser selectClass: classToBrowse ] ] ].  self spawnQueryBrowserOn: (ClyMessageImplementorsQuery of: aSymbol)position: anObject  position := anObjectbuild  self subclassResponsibilityforceFullUpdate  itemCursor forceFullUpdategroupProviderClass  ^ClyTaggedMethodGroupProviderignoreNavigationDuring: aBlock  waitingNewState := false.  aBlock ensure: [ waitingNewState := true ]decorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red.  anItemCellMorph definitionIcon: #classIconrawItems  ^buildingQuery retrievesBrowserItems ifTrue: [ items collect: [:each |  each actualObject ] ] ifFalse: [ items ]testFillingWithSingleClasses  | group visibilityLevel |  queryResult fillWith: {ClyClass2FromP1}.  self assert: queryResult size equals: 1.  group := queryResult items first actualObject.  self assert: group class equals: ClyInheritedMethodGroup.  self assert: group name equals: ClyClass2FromP1 name.  self assert: group methodQuery equals: (ClyAllMethodsQuery from: ClyClassScope of: ClyClass2FromP1 in: environment).  self assert: group visibilityLevels size equals: 1.  visibilityLevel := group visibilityLevels first.  self assert: visibilityLevel class equals: ClySuperclassVisibilityLevel.  self assert: visibilityLevel visibleClassScope equals: (ClyClassScope of: ClyClass1FromP1 in: environment).  self assert: visibilityLevel extraClassScope equals: (ClyClassScope of: ClyClass2FromP1 in: environment)announceChangesOf: aQueryResult  changes add: aQueryResultaffectsMethod: aMethod  ^self affectsMethodsDefinedInClass: aMethod origintestExpandedDataSourceWithRetrievedExpandedItem  | expandedItem |  self selectedItem expand.  self snapshotState.  expandedItem := navigationState dataSource expandedItems first.  self assert: expandedItem childrenDataSource parentItem equals: expandedItemclassGroupsIn: aPackageScope do: aBlock  self subclassResponsibilityfindCachedElementWith: anEnvironmentItem ifAbsent: absentBlock  ^collapsedItems detect: [:each |  each actualObject == anEnvironmentItem actualObject ] ifNone: absentBlockbrowser: anObject  browser := anObjectsortedBy: aSortFunction  ^self copy hierarchy: (hierarchy sortedBy: aSortFunction)isMainColumn  ^truebuildItemsFrom: classes  | subResult |  subResult := baseQueryResult prepareNewFor: buildingQuery in: environment.  subResult buildWith: classes.  ^subResult items collect: [:each |  each asCalypsoBrowserItem ]resetTagsAndPackage  ownerTool methodTags: #().  self updateisEnabled  ^truetag1Method2  lastSelectedPackage  ^self lastSelectedItem systemDefinition definingPackageprocessesDo: aBlock  self system allProcesses do: aBlockcollectMetadataOf: aQueryResult by: anEnvironmentPlugin  moveToNext  self moveTo: position + 1importClass: aClass  | newPackages |  super importClass: aClass.  newPackages := OrderedCollection new.  classQuery scope packagesDo: [:each |  each = aClass package ifFalse: [ newPackages add: each ] ].  newPackages size > 1 ifTrue: [ ^self error: 'You should select single package for import!' ].  newPackages ifNotEmpty: [ newPackages first addClass: aClass ].  aClass tagWith: self tagtestMethodsEnumeration  scope := ClyMethodScope ofAll: {(self class >> #method1) .         (self class >> #method2)}.  scope methodsDo: [:each |  result add: each ].  self assert: result asArray equals: scope basisObjects asArrayinitialize  super initialize.  self resetScope.  self requiredResult: self defaultResultprojectQueryFor: aScope  ^environment system projectManager projectQueryFor: aScopeswitchFocusToNextPane  | focused next |  focused := navigationViews detect: [:each |  each hasKeyboardFocus ] ifNone: [ ^self ].  next := navigationViews after: focused ifAbsent: [ ^self focusActiveTab ].  next takeKeyboardFocusprepareInitialStateBy: aBlock  navigationHistory ignoreNavigationDuring: [ self prepareInitialState.        aBlock valueWithPossibleArgument: self ]testFillingWithClassAndItGrandSuperclass  queryResult fillWith: {ClyClass1FromP1 .         ClySubclassLOfSubclassMFromP3}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1}disablePluginsWhichAreNotIn: aBrowser  plugins removeAllSuchThat: [:each |  each isAutoActivated and: [ (aBrowser hasPlugin: each) not ] ]execute  | result |  result := self prepareNewResult.  result initializeItems.  self buildResult: result.  ^resultchildrenType: aClass  childrenType := aClasstestComparisonWithAnotherFunction  | function2 |  function := ClySortBrowserItemFunction with: ClySortByNameFunction ascending.  function2 := ClySortBrowserItemFunction with: ClySortByNameFunction ascending.  self assert: function equals: function2.  self assert: function hash equals: function2 hash.  function2 := ClySortBrowserItemFunction with: ClySortByNameFunction descending.  self deny: function equals: function2requestRemoveMethodStrategyFor: methods  ^tool requestRemoveMethodStrategyFor: methodshash  ^value hashrawItems  ^itemshash  ^super hash bitXor: asyncResult hash= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^hierarchy = anObject hierarchydefaultMenuItemName  queryScope ifNil: [ ^'Switch scope' ].  ^'Switch scope to ' , queryScope descriptiontestComparisonWithItself  self assert: queryResult equals: queryResultstringPattern: anObject  stringPattern := anObjectaccumulateTest: testSelector of: aTestClass  allCount := allCount + 1.  successCount := successCount + (aTestClass methodPassed: testSelector) asBit.  failureCount := failureCount + (aTestClass methodFailed: testSelector) asBit.  errorCount := errorCount + (aTestClass methodRaisedError: testSelector) asBitpackage  ^packagetestRetrievesCurrentSelection  self snapshotState.  self assert: (navigationState selection lastSelectedItem isSameAs: self selectedItem)belongsToRemovedBrowserContext  ^self leftMethod isInstalled not or: [ self rightMethod isInstalled not ]findSourceNodeAt: aCursorPoint  | startPosition endPosition line lineIndex selection ast |  lineIndex := self leftSideBar lineIndexForPoint: aCursorPoint.  line := textMorph paragraph lines at: lineIndex.  startPosition := line first.  endPosition := line last.  selection := self selectedTextInterval.  selection ifNotNil: [ selection first >= startPosition & (selection last <= endPosition) ifTrue: [ startPosition := selection first max: 1.              endPosition := selection last min: self editingText size ] ].  ast := self editingMethod astForStylingInCalypso.  ^(ast bestNodeFor: (startPosition to: endPosition)) ifNil: [ ast ]testFillingWithTwoSameClasses  queryResult fillWith: {ClyClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0}selectsMethod: aMethod  | selector |  selector := aMethod selector.  scope classesDo: [:eachClass |  ((self isClass: eachClass shouldImplement: selector) and: [ (eachClass includesSelector: selector) not ]) ifTrue: [ ^true ] ].  ^falsespawnHierarchyForClass: aClass selector: aSymbolOrNil  navigationEnvironment ifNil: [ self navigationEnvironment: ClyNavigationEnvironment currentImage.        self setUpAvailablePlugins ].  self spawnBrowser: ClyFullBrowser withState: [:browser |  browser selectClass: aClass.        browser switchToFullClassHierarchy.        aSymbolOrNil ifNotNil: [ browser selectMethod: aClass >> aSymbolOrNil ] ]printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  items do: [:each |  aStream           nextPutAll: each name;           nextPutAll: '; ' ].  items ifNotEmpty: [ aStream skip: -2 ].  aStream nextPut: $)printExtraInfoOn: aStream  super printExtraInfoOn: aStream.  ^aStream nextPutAll: tagretrievesItem: anObject  ^subqueries anySatisfy: [:each |  each retrievesItem: anObject ]createQuery  ^(ClyConstantMethodQuery with: {(self class >> #method1) .         (self class >> #method2)}) scope: (ClyScopeExample emptyIn: environment)tag  ^tagisAccessibleFrom: aClass  ^truepriority  ^SmallInteger maxValassertVars: varNames  | vars i var |  vars := items select: [:each |  each actualObject isKindOf: ClyVariableMethodGroup ].  self assert: vars size equals: varNames size.  i := 1.  varNames do: [:expectedVar |  var := vars at: i.        self assert: var actualObject name equals: expectedVar.        i := i + 1 ]matches: aString  self subclassResponsibilitymetaLevelScope: aMetaLevelScopeClass  metaLevelScope := aMetaLevelScopeClassprojectsDo: aBlock  basisObjects do: aBlockdefaultNavigationScope  ^self systemScopetestHasResultAdapterOverActualQueryResult  self assert: cursor queryResult class equals: ClyQueryResultBrowserAdapter.  self assert: cursor queryResult actualResult equals: queryResultselectedPackageItems  self subclassResponsibilityprintExtraInfoOn: aStream  super printExtraInfoOn: aStream.  ^aStream nextPutAll: pattern valuecanAffectResultOfMethodQuery: aMethodQuery  ^truegroupProviderClass  ^ClyRequiredMethodGroupProviderprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  methodEditor := aToolContext toolpattern  ^patternbrowseReferencesTo: aSymbol  self browseReferencesTo: aSymbol from: self systemdetachFromSystem  browser system unsubscribe: selfdeactivateExtraScope  ^visibleClassScope reducedByClassesFrom: extraClassScopetestAscendingForBinaryAndUnarySelectors  function := ClySortMethodBySelectorFunction ascending.  self assert: #| > #abs.  self assert: (function value: Integer >> #| value: Number >> #abs).  self deny: (function value: Number >> #abs value: Integer >> #|).  self deny: #+ > #abs.  self assert: (function value: Number >> #+ value: Number >> #abs).  self deny: (function value: Number >> #abs value: Number >> #+)localMethodFromSubclass  selectedMessage  ^SycMessageDescription ofMessageNode: self selectedSourceNodesemiAsync  ^self async asyncResult: ClySemiAsyncQueryResult newsetUpEnvironment  super setUpEnvironment.  environment system: ClySystemEnvironment currentImage.  plugin := ClyTestedEnvironmentPlugin new.  plugin environment: environmentcontainerForChildren  ^hierarchy containerForChildrentestAdoptQuery  | query adoptedQuery |  scope := self singleScopeSample.  query := ClyQueryExampleReturningScopeBasis new.  adoptedQuery := scope adoptQuery: query.  self assert: adoptedQuery identicalTo: querymethod2WithUndeclares  undeclaredStubInstVar2 := 100asSelectedItemsOf: itemTypeClass  | resultItems |  self isEmpty ifTrue: [ ^self ].  resultItems := items select: [:each |  each isBasedOnItemType: itemTypeClass ].  resultItems = items ifTrue: [ ^self ].  ^self class fromRoot: self rootDataSource items: resultItemstestthisContext_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'thisContext') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: ThisContext ]')testCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #reference1OfVar1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #referenceOfAnotherVar in: environment).  self assert: query checkEmptyResulttestCheckEmptyQueryWhenThereIsNoResultButItWouldNotBeEmpty  | query |  query := self createQueryFromScopeOf: self class.  self deny: (environment isQueryEmpty: query)countChildrenOf: aDataSourceItem  self subclassResponsibilitydefaultMenuItemName  ^'Commit'testClassEnumeration  scope := ClyBothMetaLevelClassScope ofAll: {ClyClass1FromP1 .         ClyClass2FromP1}.  scope classesDo: [:each |  result add: each ].  self assert: result asArray equals: {ClyClass1FromP1 .         ClyClass2FromP1}defaultColor  ^Color transparentexecute  UIManager default longMessage: critique description title: critique titletestDetectingDefiningClassFromSharedPoolUser  | varBinding var |  varBinding := ChronologyConstants classVariableNamed: #DayNames.  var := ClyClassVariable on: varBinding visibleFrom: Date.  self assert: var definingClass equals: ChronologyConstantstestBuildCompletionShouldResetProcess  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self assert: queryResult buildProcess isNildescription  ^'all methods'environment: anObject  environment := anObjectdefinitionString  ^definitionStringsubscribeOnTextChanges  textMorph announcer     when: RubTextAccepted send: #changesAccepted to: self;     when: RubTextChanged send: #textChanged: to: self;     when: RubCancelEditRequested send: #changesCancelRequested: to: selfinitialize  super initialize.  parentMap := IdentityDictionary newremovePlugin: aBrowserPlugin  plugins removeAllSuchThat: [:each |  each class = aBrowserPlugin class ]applyResultInContext: aToolContext  super applyResultInContext: aToolContext.  aToolContext showMethodTag: tagNamedeselect: sth  simpleNameForSpotterMenu  ^'Classes'updateExpandingItems  self subclassResponsibilityglobalPositionOf: childDataSourceItem  | result |  result := parentItem ifNil: [ 0 ] ifNotNil: [ parentItem globalPosition ].  expandedItems do: [:each |  (each isAfter: childDataSourceItem position) ifTrue: [ ^result + childDataSourceItem position ].        result := result + each childrenCount ].  ^result + childDataSourceItem positioncreateClassGroupFor: aClassQuery from: aPackageScope  ^ClyClassGroup named: 'Extensions' priority: 0 on: aClassQuerydefaultMenuItemName  ^'Browse rule'itemFilter: anObject  itemFilter := anObjecttestFromClassWhichIncludesTwoProtocolExtensionsOfSamePackage  self queryFromScope: ClyClassScope of: ClyClass9FromPExtendedByP5.  self assert: resultItems asSet equals: {ClyClass7WithTag1FromP5 package} asSetloadItemOf: aBrowserQueryResult at: position  (self includesItemAt: position) ifTrue: [ ^self ].  startPosition := position.  self fillItemsFrom: aBrowserQueryResultwithMetaLevel: aScopeClass  | newSubscopes |  newSubscopes := subscopes collect: [:each |  each withMetaLevel: aScopeClass ].  ^ClyCompositeScope on: newSubscopes in: environment named: nameeditingText  ^editingClass commenttestMatchesClassOfPackageWhichMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'SystemQueries-Tests'.  self assert: (filter matches: self itemOfThisTestClass)isStatic  ^truedescription  ^'all classes'attachToTextMorph  super attachToTextMorph.  self textArea announcer when: RubSelectionChanged send: #updateContents to: self.  self updateContentstestFillingWithClassAndItsTraitsWhenSomeMiddleTraitIsMissing  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitRoot1 .         2}activeColor  ^self theme backgroundColortestFillingWithExtendedClassSide  query := ClyAllClassesQuery from: ClyPackageScope of: ClyClass1FromP1 package in: environment.  queryResult := ClyExtensionLastSortedClasses simple prepareNewFor: query in: environment.  queryResult buildWith: {ClySubclassLOfClass0FromPExtendedByP1 class .         ClyClass2FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClyClass2FromP1 .         0 .         ClySubclassLOfClass0FromPExtendedByP1 class .         0}.  self assert: (items last isMarkedWith: ClyExtendedClassTag)readParametersFromContext: aCriticContext  super readParametersFromContext: aCriticContext.  critique := aCriticContext selectedCritique.  analyzedObject := aCriticContext analyzedObjectcreateHierarchy  ^annotatedClass hierarchyForMethodVisibilityisInstanceSide  ^isInstanceSidetestNotBasedOnSingleBasisWhenAllSubscopesHaveEmptyBasis  | subscope1 subscope2 |  subscope1 := ClyScopeExample emptyIn: environment.  subscope2 := ClyScopeExample emptyIn: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self deny: scope isBasedOnSingleBasisdefaultItems  ^SortedCollection sortBlock: ClySortByNameFunction ascendingitemsChanged  superclassVar1ReaderMethod  ^instanceSideVar1baseClass  ^baseClassignoreNavigationDuring: aBlock  | selector |  selector := navigationSelector.  navigationSelector := nil.  aBlock ensure: [ navigationSelector := selector ]groupProviderClass  ^ClyUnclassifiedMethodGroupProvidernewContentMorph  itemsView := ClyQueryViewMorph for: self.  itemsView width: 250.  itemsView whenDoubleClickDo: [:ann |  self ok ].  itemsView whenEnterKeyPressedDo: [:ann |  self ok ].  itemsView whenEscapeKeyPressedDo: [:ann |  self cancel ].  ^itemsViewtestFromClassAndInheritedTrait  query := ClyMessageImplementorsQuery of: #methodFromRoot1.  self queryFromScope: ClyBothMetaLevelClassScope ofAll: {ClyClassWithTraits .         ClyTraitRoot1}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: ClyTraitRoot1 >> #methodFromRoot1testCreationFromTwoUnionQueries  | subquery1 subquery2 subquery3 subquery4 unionQuery1 unionQuery2 scopes |  subquery1 := self subqueryFromScope: ClyScopeExample of: Array.  subquery2 := self subqueryFromScope: ClyScopeExample2 of: String.  subquery3 := self subqueryFromScope: ClyScopeExample of: Object.  subquery4 := self subqueryFromScope: ClyScopeExample2 of: Class.  unionQuery1 := subquery1 , subquery2.  unionQuery2 := subquery3 , subquery4.  query := unionQuery1 , unionQuery2.  self assert: query class equals: self queryClass.  self assert: query subqueries size equals: 2.  self assert: (query subqueries collect: #class as: Set) equals: {subquery1 class} asSet.  scopes := query subqueries collect: #scope as: Set.  self assert: scopes equals: {(ClyScopeExample ofAll: {Array .               Object}) .         (ClyScopeExample2 ofAll: {String .               Class})} asSet.  self assert: query requiredResult identicalTo: subquery1 requiredResultsetUpModelFromContext  super setUpModelFromContext.  editingClass := context selectedClassSidechildrenType  ^childrenTypeannouncer  ^announcernavigationViews  ^navigationViewswithNewBasisObjects: newBasisObjects  ^self copy     basisObjects: newBasisObjects;     bindTo: environmentmethodGroup: anObject  methodGroup := anObjectmetaLevelScope  ^metaLevelScopeselectsMethod: aMethod  ^(selectors includes: aMethod selector) and: [ aMethod origin = aMethod methodClass ]defaultMenuIconName  ^#smallFindIconassertItems: itemValueWithDepthArray  self assertItems: itemValueWithDepthArray withValue: [:item |  self meaningfullObjectToAssert: item ]createElementWith: anEnvironmentItem  ^self findCachedElementWith: anEnvironmentItem ifAbsent: [ ClyDataSourceItem of: self value: anEnvironmentItem ]selectedClassItems  self subclassResponsibilitysuperclassTag1Method  testCreationOnBasisObjects  | expectedBasis |  scope := self createSampleScope.  expectedBasis := scope prepareBasisFrom: scope basisObjects.  self assert: scope basisObjects equals: expectedBasismethodSelection  ^self selection asSelectedItemsOf: ClyMethodformatAsYouReadLabel  ^'F'testRetrievesStateOfAllNavigationViews  self snapshotState.  self assert: navigationState viewStates size equals: browser navigationViews sizeinitialize  super initialize.  self     changeTableLayout;     hResizing: #rigid;     width: 200testFillingWithTraitsOfClassWhichIsMissingInGivenList  queryResult fillWith: {ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyTraitChild1 .         0 .         ClyTraitRoot1 .         1 .         ClyTraitChild2Child .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot1 .         2}findItemsWith: actualObjects forAbsentDo: absentBlock  ^actualObjects collect: [:eachObject |  items detect: [:item |  item actualObject == eachObject ] ifNone: absentBlock ]printSelectors  ^',' join: selectorsmetalinkManagerClass  ^WatchpointtagsAndPackageEditor  ^(statusBar findDeeplyA: ClyMethodTagsAndPackageEditorMorph) ifNil: [ CmdCommandAborted signal ]classQuery  ^classQueryensureSelectedItemIfNeeded  table allowsDeselection ifFalse: [ self ensureSelectedItem ].  self ensureVisibleSelectionitemObserver  ^itemObservertestConvertingToNewMetaLevel  | convertedScope |  scope := self createSampleScope.  convertedScope := scope withMetaLevel: ClyInstanceSideScope.  self assert: convertedScope class equals: ClyInstanceSideScope.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environmentforceLazyRebuild  self protectAccessWhile: [ needsRebuild := true ]setUp  super setUp.  groupProvider := self groupProviderClass new.  builtGroups := OrderedCollection newextraBasisSample  ^self class >> #method2writer2OfVar1  writtenVar1 := #value2testCreatesGroupsForEveryTag  self buildGroupsFor: ClyClass7WithTag1FromP5 package.  self assert: builtGroups size equals: 2.  self assert: (builtGroups collect: #tag) sorted asArray equals: #(Tag1 Tag2)showDesiredSelection  self initiateUIChangeBy: [ desiredSelection ifNil: [ ^selection beEmpty ].        desiredSelection restoreCurrentSelection: selection ]hash  ^super hash bitXor: groupName hashtestCases  ^testCaseResults keyshash  ^super hash bitXor: extraParameter hashelementAt: rowIndex  | localIndex |  localIndex := rowIndex.  collapsedItems do: [:each |  each position = localIndex ifTrue: [ ^each ].        (each isAfter: localIndex) ifTrue: [ self itemCursor moveTo: localIndex.              ^ClyDataSourceItem of: self value: self itemCursor currentItem ].        localIndex := localIndex + each childrenCount ].  self itemCursor moveTo: localIndex.  ^ClyDataSourceItem of: self value: self itemCursor currentItemuniformActualObjects  | lastItem |  self isEmpty ifTrue: [ ^#() ].  lastItem := self lastSelectedItem.  ^(items allSatisfy: [:each |  each isSameKindAs: lastItem ]) ifTrue: [ items collect: #actualObject ] ifFalse: [ {lastItem actualObject} ]= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^asyncResult = anObject asyncResultdescription  ^'Get the class sample (predefined instance) in a inspector to tweak it and have fun with it'currentScopeIndex  ^self scopes indexOf: self currentScopefindItemsWhere: conditionBlock  | myItems childItems |  myItems := super findItemsWhere: conditionBlock.  childItems := expandedItems flatCollect: [:each |  each childrenDataSource findItemsWhere: conditionBlock ].  ^myItems , childItemsdescription: anObject  description := anObjectrestoreBrowserState  self subclassResponsibilitytestMethodsEnumerationWhenBothMetaLevels  scope := ClySubclassScope of: ClyClass1FromP1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyClass1FromP1 subclasses first localMethods).  self assert: (result includesAll: ClyClass1FromP1 subclasses first classSide localMethods).  self assert: (result includesAll: ClyClass1FromP1 subclasses second localMethods).  self assert: (result includesAll: ClyClass1FromP1 subclasses second classSide localMethods).  self deny: (result includesAll: ClyClass1FromP1 localMethods).  self deny: (result includesAll: ClyClass1FromP1 classSide localMethods).  self deny: (result includesAll: ClyClass1FromP1 superclass localMethods).  self deny: (result includesAll: ClyClass1FromP1 superclass classSide localMethods)findAnySelectorOrString: selectors inSourceCode: aText  ^(self findAnySelectorInSourceCode: selectors) ifEmpty: [ self findAnyString: selectors in: aText ]editingClass  ^editingClassvariable  ^methodQuery variableQuery resultItems firstsupportsCriticDecoration  ^truetestNotMatchesClassWithWrongNameAndPackage  filter := ClyQueryBrowserFilter substringPattern: 'filter not matches class name and package'.  self deny: (filter matches: self itemOfThisTestClass)defaultColor  ^Color transparentinheritanceAnalyzer  ^environment getPlugin: ClyInheritanceAnalysisEnvironmentPluginexecute  methodGroups do: [:each |  each convertToMethodTag: tagName ]decorateTableCell: anItemCellMorph with: aMorph  aMorph setBalloonText: self description.  anItemCellMorph addExtraTool: aMorphfindCachedElementWith: anEnvironmentItem ifAbsent: absentBlock  self subclassResponsibilitymethodFromTraitChild1  currentMetaLevelOf: aClass  ^metaLevelScope metaLevelOf: aClasscreateMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'abstract' priority: -10 on: aMethodQueryundo  super undo.  self editingState undoManager hasPrevious ifFalse: [ self browserTool changesCancelled ]decorateTableCell: anItemCellMorph of: groupItem  | myName |  super decorateTableCell: anItemCellMorph of: groupItem.  myName := name asLowercase.  (myName beginsWith: 'private') ifTrue: [ ^anItemCellMorph definitionIcon: #protocolPrivateIcon ].  (#('initial' 'class initial' 'releaz' 'releas' 'finali') anySatisfy: [:each |  myName beginsWith: each ]) ifTrue: [ anItemCellMorph definitionIcon: #protocolProtectedIcon ]openOn: aQueryView  self isClosed ifFalse: [ self close ].  queryView := aQueryView.  table := aQueryView table.  itemCursor := query openBrowserCursorFor: self.  dirty := falsedefaultColor  ^Color transparentrestoreNavigationState: aBrowserState of: aBrowser  aBrowserState applyTo: aBrowser byUndo: undoExecutingprintContext  ^editingClass printSystemPathtestRetrievesExpectedFlatQueryResult  self snapshotState.  self assert: navigationState expectedFlatQueryResult equals: browser expectedFlatQueryResultone: aFirstObject two: aSecondObject  self     one: aFirstObject;     two: aSecondObjecttriggerUpdate  applyingChanges ifFalse: [ self update ]ignoreNavigationDuring: aBlock  navigationStarted ifTrue: [ ^aBlock value ].  navigationStarted := true.  aBlock ensure: [ navigationStarted := false ]execute  | repackagingCommand |  methodGroups do: [:each |  repackagingCommand := SycMoveMethodsToPackageCommand for: each methods to: package.        repackagingCommand execute.        each removeWithMethods ]testUsingScript  filter := ClyQueryBrowserFilter substringPattern: '[:each | each selector = #testUsingScript]'.  self assert: (filter matches: self itemOfThisTestMethod).  self deny: (filter matches: (ClyBrowserItem with: Object >> #printString))confirmUnusedVariables: variables  | refQuery |  refQuery := ClyVariableReferencesQuery ofAny: variables from: self systemScope.  ^self confirmEmptySystemQuery: refQueryfindAllItemsBy: aBlockWithDataSource stopLookupWhen: stopCondition  | result fullResult |  result := aBlockWithDataSource value: self dataSource.  self isFilterActive ifFalse: [ ^result ].  (stopCondition value: result) ifTrue: [ ^result ].  fullResult := aBlockWithDataSource value: table initialDataSource.  result size = fullResult size ifTrue: [ ^result ].  self setUpDataSource: table initialDataSource.  ^fullResultcreateTextContext  ^self selectedSourceNode ifNil: [ super createTextContext ] ifNotNil: [:astNode |  ClyMethodSourceCodeContext for: self selectedNode: astNode ]extraBasisSample  ^super extraBasisSample classSidecreateQuery  ^ClyRestUntaggedClassesQuery from: ClyPackageScope of: Object package in: environmentlocalScopeClass  ^localScopeClassincludesMethodsAffectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsMethodstestRestoredBrowserInstanceWithQueryScopes  self restoreBrowserInstance.  self assert: navigationState queryScopes size equals: 2.  self assert: browser queryScopes equals: navigationState queryScopesshowsQueryResultAs: aQueryResult  ^systemQuery requiredResult = aQueryResultdefaultMenuItemName  ^'Select method package'dropPassenger: aPassanger at: aDataSourceItem  | context |  context := self createSelectionContextOf: aDataSourceItem asSelection.  ^aPassanger dropInContext: contextisExpanded: aDataSourceItem  ^(collapsedItems includes: aDataSourceItem) nottestCompareTwoItemsOfClasses  function := ClySortBrowserItemFunction with: ClySortByNameFunction ascending.  self deny: (function value: Object asCalypsoBrowserItem value: Array asCalypsoBrowserItem).  self assert: (function value: Array asCalypsoBrowserItem value: Object asCalypsoBrowserItem).  self assert: (function value: Object asCalypsoBrowserItem value: Object asCalypsoBrowserItem)findFirstOccurrenceOf: searchedString in: textToSearchIn  | firstIndex |  firstIndex := textToSearchIn findString: searchedString startingAt: 1.  [ firstIndex > 1 and: [ (textToSearchIn at: firstIndex - 1) isAlphaNumeric ] ] whileTrue: [ firstIndex := textToSearchIn findString: searchedString startingAt: firstIndex + 1 ].  ^firstIndexhierarchy: anObject  hierarchy := anObjectdecorateMethodGroupTableCell: anItemCellMorph of: groupItem  setUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyReflectiveEnvironmentPlugin newtestNormalizingSelectorForComparison  #(#one #one: #two #two: #one:two: #oneTwo: #+ #- #+-) with: #('one' 'one' 'two' 'two' 'onetwo' 'onetwo' '+' '-' '+-') do: [:original :transformed |  self assert: (plugin normalizeSelectorForComparison: original) equals: transformed.        self assert: (plugin normalizeSelectorForComparison: original asString) equals: transformed.        self assert: (plugin normalizeSelectorForComparison: transformed) equals: transformed.        self deny: (plugin normalizeSelectorForComparison: original) identicalTo: original.        self deny: (plugin normalizeSelectorForComparison: transformed) identicalTo: transformed.        self deny: (plugin normalizeSelectorForComparison: original) isSymbol.        self deny: (plugin normalizeSelectorForComparison: transformed) isSymbol ]affectsMethodsDefinedInClass: aClass  ^testCase == aClassgroupProviderClass  ^ClyOverriddenMethodGroupProviderscope  ^scopeisBasedOn: aQuery  ^query = aQueryfileOut  | internalStream class |  internalStream := (String new: 1000) writeStream.  internalStream     header;     timeStamp;     cr.  self methods do: [:each |  each origin printMethodChunk: each selector on: internalStream ].  internalStream trailer.  class := methodQuery scope basisObjects anyOne.  ^CodeExporter writeSourceCodeFrom: internalStream baseName: class name , '-' , self name isSt: trueupdate: aSymbol with: anObject  super update: aSymbol with: anObject.  self updateMainWindowTitlecreateMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'expected failures' priority: -2 on: aMethodQuerysetUp  super setUp.  environment system: ClySystemEnvironment currentImage.  environment detachFromSystemtestFromLocalClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: foundSelectors equals: #(classSideSender1OfMessage1 classSideSender2OfMessage1 sender1OfMessage1 sender2OfMessage1)itemsChanged  browser  ^browserTool browsertransferFor: dataSourceItems from: aMorph  | selection passenger |  selection := dataSourceItems first rootDataSource newSelectionWith: dataSourceItems.  passenger := queryView createDragPassengerFor: selection.  ^super transferFor: passenger from: aMorphgroupProviderClass  ^ClyOverridingMethodGroupProvidercancelChanges  changesCancelRequested := true.  textMorph setText: self editingText.  changesCancelRequested := false.  self rebuildStatusBardescription  ^'Click to show all packages'collectMethodGroupProviders  ^{ClyInheritedMethodGroupProvider .   ClyTaggedMethodGroupProvider .   ClyUnclassifiedMethodGroupProvider .   ClyExtendedMethodGroupProvider} collect: [:each |  each new ]countChildrenOf: aDataSourceItem  aDataSourceItem childrenDataSource ifNotNil: [:children |  ^children numberOfRows ].  self definesChildren ifFalse: [ ^0 ].  self error: 'should not happen'applyChangesBy: aBlock  applyingChanges := true.  ^aBlock ensure: [ applyingChanges := false ]testComparison  self assert: (ClyMessageImplementorsQuery of: #message1) equals: (ClyMessageImplementorsQuery of: #message1).  self assert: (ClyMessageImplementorsQuery of: #message1) hash equals: (ClyMessageImplementorsQuery of: #message1) hash.  self deny: (ClyMessageImplementorsQuery of: #message1) equals: (ClyMessageImplementorsQuery of: #message2)testShouldFoundClassNameSymbolReference  query variableQuery: (ClyConstantQuery returning: {Number}).  self queryFromScope: ClyMethodScope of: self class >> #referenceOfNumberClassByNameSymbol.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #referenceOfNumberClassByNameSymboliconName  ^#smallDoItIcontestIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  query subqueries: {(self subqueryFromScopeOf: self class) .         (self subqueryFromScopeOf: self class superclass)}.  self assert: query isExecutedFromMultipleScopetestIsBasedOnSingleBasisWhenTwoSubscopesAreBasedOnSameSingleObject  | subscope1 subscope2 |  subscope1 := ClyScopeExample of: #basisObject in: environment.  subscope2 := ClyScopeExample2 of: #basisObject in: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self assert: scope isBasedOnSingleBasisdecorateBrowserItem: anItem ofClass: aClass  aClass isTrait ifTrue: [ anItem markWith: ClyTraitTag ].  aClass traits ifNotEmpty: [ anItem markWith: ClyTraitUserTag ]untestedTwo: anObject  self two: anObjecttestCheckIfEmpty  query scope: (ClyPackageScope of: ClyClass1FromP1 package in: environment).  self deny: query checkEmptyResultaffectsMethods  ^truetestFillingWithClassAndItsTraitsWhenSomeMiddleTraitIsMissing  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitRoot1 .         2}installInto: aMorph  aMorph assureExtension balloonText: selfmethodFromRoot1  whenReadyDo: aBlock  containerTab waitReadyMorphFor: 10 seconds.  aBlock value: selfclassGroupsIn: aPackageScope do: aBlock  | classQuery |  classQuery := self createClassQueryFrom: aPackageScope.  classQuery hasEmptyResult ifTrue: [ ^self ].  aBlock value: (self createClassGroupFor: classQuery from: aPackageScope)isClassCheapForOverriddenMethodsAnalysis: aClass  | numberOfSubclasses |  numberOfSubclasses := 0.  aClass allSubclassesDo: [:each |  numberOfSubclasses > littleHierarchyMaxSize ifTrue: [ ^false ].        numberOfSubclasses := numberOfSubclasses + 1 ].  ^truetestPreparation  | newQuery newResult |  newQuery := self createQuery.  newResult := queryResult prepareNewFor: newQuery in: environment.  self assert: newResult class equals: queryResult class.  self deny: newResult identicalTo: queryResult.  self assert: newResult buildingQuery identicalTo: newQuery.  self assert: newResult environment equals: environment.  self assert: newResult isProtecteduntestedOne: aFirstObject two: aSecondObject  self     one: aFirstObject;     two: aSecondObjectisGlobalVariableSelected  | node binding |  node := self selectedSourceNode.  node isVariable ifFalse: [ ^false ].  binding := node binding.  ^binding isGlobalVariableadoptForBrowser  ^selftestClassEnumeration  scope := ClyInstanceSideScope ofAll: {ClyClass1FromP1 classSide .         ClyClass2FromP1}.  scope classesDo: [:each |  result add: each ].  self assert: result asArray equals: {ClyClass1FromP1 .         ClyClass2FromP1}isSimilarTo: anotherBrowserTool  (super isSimilarTo: anotherBrowserTool) ifFalse: [ ^false ].  ^methodClass == anotherBrowserTool methodClass and: [ methodTags = anotherBrowserTool methodTags and: [ extendingPackage = anotherBrowserTool extendingPackage ] ]copyForBrowserStateSnapshot  ^self copy     initializeForBrowserStateSpanshot;     yourselfimportMethod: aMethod  super importMethod: aMethod.  aMethod tagWith: self tagdefaultMenuItemName  ^'Debug tests'setUp  super setUp.  environment addPlugin: ClyDefaultSystemEnvironmentPlugin newbaseCritiqueQuery  ^baseCritiqueQuerycreateSampleScope  ^ClyUnknownScope newnotifyObservers  announcer ifNil: [ ^self ].  environment announceChangesOf: selftestMatchesClassWhichNameMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'FilterTest'.  self assert: (filter matches: self itemOfThisTestClass)activateExtraScope  ^visibleClassScope increasedByClassesFrom: extraClassScope asInterestingClassScopeprojectQueryFor: aScope  projectManagers isEmpty ifTrue: [ ^ClyUnknownQuery instance ].  ^(projectManagers collect: [:found |  found queryClass sortedFrom: aScope ]) reduce: [:a :b |  a , b ]queryScopes  ^queryScopesdescription  ^String streamContents: [:s |  s nextPutAll: self class name.        s nextPut: $(.        self printExtraInfoOn: s.        s nextPut: $) ]classes  ^classesbuildTitleFromSelections  | newTitle mainItem |  self projectSelection isEmpty ifFalse: [ newTitle := self projectSelection lastSelectedItem name ].  self packageSelection isEmpty ifFalse: [ newTitle := self packageSelection lastSelectedItem name ].  self classSelection isEmpty ifTrue: [ ^newTitle ].  mainItem := self methodSelection isEmpty ifTrue: [ self classSelection lastSelectedItem ] ifFalse: [ self methodSelection lastSelectedItem ].  newTitle := mainItem systemDefinition printDefiningClass.  mainItem systemDefinition isInstanceSide & (metaLevelScope = ClyClassSideScope) ifTrue: [ newTitle := newTitle , ' class' ].  self methodSelection isEmpty ifFalse: [ newTitle := newTitle , '>>' , self methodSelection lastSelectedItem name ].  ^newTitleselect: sth  withExtraBasisObjects: extraBasisObjects  | newBasis |  newBasis := OrderedCollection withAll: basisObjects.  extraBasisObjects do: [:each |  (newBasis identityIncludes: each) ifFalse: [ newBasis add: each ] ].  ^self withNewBasisObjects: newBasisdefaultMenuItemName  ^'References'testQueryExecutionShouldRemoveOldWeaklyGarbagedCache  | result query |  query := self createQueryFromScopeOf: self class.  environment query: query.  Smalltalk     garbageCollectMost;     garbageCollectMost.  result := environment cachedResultOf: query.  self assert: result equals: nil.  result := environment query: (self createQueryFromScopeOf: self class superclass).  self deny: (environment queryCache includesKey: query)extraParameter: anObject  extraParameter := anObjectexecuteOn: aClass  | pragma |  pragma := implementorMethod pragmaAt: #script:.  ^aClass compiler     receiver: aClass instanceSide;     evaluate: pragma arguments firstcreateMethodQueryFrom: aClassScope  ^ClyMethodCallCountersQuery from: aClassScopedecorateMethodEditor: aMethodEditor  systemQuery decorateResultMethodEditor: aMethodEditorexecute  | testCase |  testCase := (selectedClassItem getProperty: ClyTestedClassProperty) coveringTestCase.  browser spawnBrowser: ClyFullBrowser withState: [:b |  b selectClass: testCase ]showQuery: aQuery  | dataSource |  self initiateUIChangeBy: [ dataSource := ClyCollapsedDataSource on: aQuery.        self dataSource: dataSource.        self ensureSelectedItemIfNeeded ]description  ^self actualQuery descriptionexecute  codeObjects do: [:each |  each fileOut ]packageSampleWhichHasGroup  ^ClyClass7WithTag1FromP5 packagecollectMethodGroupProviders  providesMethodGroup ifFalse: [ ^#() ].  ^{ClyCriticMethodGroupProvider new}extraScopesOfSelectedItems  | classScope |  classScope := self classScopeOfSelectedItems.  ^{self packageScopeOfSelectedItems .   classScope asFullHierarchyScope .   classScope}testIsEmptyFromEmptyPackageScope  query scope: (ClyPackageScope emptyIn: environment).  self assert: query checkEmptyResultexpand: aDataSourceItem  self subclassResponsibilitygroupItemsByTypeAndDo: typeAndItemsBlock  self groupItemsByType keysAndValuesDo: typeAndItemsBlockhasTestResult  ^methodDataSource hasMetaProperty: ClyTestResultPropertyisSelectedItemHasExecutionCounter  ^selectedItems anySatisfy: [:each |  each isMarkedWith: ClyMethodWithExecutionCounterTag ]addActualChild: childClass to: parentClass  | children |  children := parentMap at: parentClass ifAbsentPut: [ self containerForChildren ].  children add: childClass.  roots remove: childClass ifAbsent: niltestNotBuiltWhenBuildIsJustStarted  queryResult rebuild.  self deny: queryResult isBuiltcheckbox  ^checkboxselectObject: anObject  | foundItems |  self changeStateBy: [ foundItems := resultView findItemsWith: {anObject}.        foundItems ifNotEmpty: [ self selection selectItems: foundItems ] ]collectGoToCandidates  | result |  result := OrderedCollection new.  browser allContextsDo: [:each |  each asGoToSpotterCandidate ifNotNil: [:c |  result add: c ] ].  ^resultinitialize  super initialize.  self cellInset: 2 @ 2editingText  ^methodClass sourceCodeTemplatesuccessCount: anObject  successCount := anObjectdecorateByCritic: aCriticTool  | segments |  (textMorph segments select: [:each |  each class = ClyCriticalTextSegmentMorph ]) do: [:each |  each delete ].  segments := aCriticTool buildCriticalTextSegmentsFor: editingMethod.  segments do: [:each |  textMorph addSegment: each ]asScope: anotherTypedScopeClass  ^anotherTypedScopeClass ofAll: basisObjects in: environment named: name, anotherQuery  ^anotherQuery unionWith: {self} as: requiredResultdefaultMenuItemName  ^'All Packages'order  ^3execute  browser switchToMetaLevelScope: self metaLevelScopedefaultItems  ^SortedCollection sortBlock: ClySortByNameFunction ascendingisExecutedFromMultipleScope  ^scope isBasedOnMultipleBasisdescription  ^'View rationale behind the rule'testCreatesBrowserWithNavigationHistory  self restoreBrowserInstance.  self assert: browser navigationHistory equals: navigationState navigationHistorydefaultIconName  ^#commentsIcondepth  ^depthselectsMethod: aMethod  (aMethod hasBreakpoint or: [ aMethod containsHalt ]) ifFalse: [ ^false ].  self excludesHaltsForTesting ifFalse: [ ^true ].  ^(aMethod hasPragmaNamed: #haltOrBreakpointForTesting) notupdateContents  labelMorph contents: self printCursorPositionextraBasisSample  ^ClySubclassMOfClass1FromP2 packagedoInOrderWithDepth: blockWithClassAndDepth  self rootsDo: [:root |  blockWithClassAndDepth value: root value: 0.        self allChildrenOf: root depth: 0 do: blockWithClassAndDepth ]classNameOf: aBrowserItem  ^aBrowserItem systemDefinition printDefiningClassconditionBlock  ^conditionBlockprojectsDo: aBlock  self system projects do: aBlockffiMethod  ^self ffiCall: #(int system #(char * command))isResult: aQueryResult affectedBy: aSystemAnnouncement  ^scope includesClassGroupsAffectedBy: aSystemAnnouncementshowsItemsFromScope: aTypedScopeClass  ^self query isExecutedFromScope: aTypedScopeClassselection  ^resultView selectionmethodTags: tagsArray  super methodTags: tagsArray.  self hasUnacceptedEdits ifFalse: [ self tagEditingMethod: editingMethod ]selectedTools  ^tools select: [:each |  each isTabSelected ]testConvertingWithExtraBasisObjects  | convertedScope |  scope := self singleScopeSample.  convertedScope := scope withExtraBasisObjects: {self singleBasisSample .         self extraBasisSample}.  self assert: convertedScope class equals: scope class.  self assert: (convertedScope basisObjects asIdentitySet includesAll: scope basisObjects).  self assert: (convertedScope basisObjects asIdentitySet includes: self extraBasisSample).  self assert: convertedScope basisSize equals: scope basisSize + 1retrievesItemsOfType: itemTypeClass  ^resultItems anySatisfy: [:each |  each calypsoEnvironmentType = itemTypeClass ]testAscending  function := ClySortByNameFunction ascending.  self deny: (function value: Object value: Array).  self assert: (function value: Array value: Object).  self assert: (function value: Object value: Object)detachFromSystem  initialize  super initialize.  metaLevelScope := ClyInstanceSideScopeactualObject  ^actualObjectundoNavigationOf: aBrowser  undoList ifEmpty: [ ^self ].  self executeUndoBy: [ self restoreNavigationState: undoList removeLast of: aBrowser ]testCreationByCommaFromThreeSubscopes  | subscope1 subscope2 subscope3 |  subscope1 := ClyScopeExample of: #basisObject1 in: environment.  subscope2 := ClyScopeExample2 of: #basisObject2 in: environment.  subscope3 := ClyScopeExample2 of: #basisObject3 in: environment.  scope := subscope1 , subscope2 , subscope3.  self assert: scope class equals: ClyCompositeScope.  self assert: scope basisObjects equals: #(basisObject1 basisObject2 basisObject3) asSet.  self assert: scope subscopes asSet equals: {subscope1 .         subscope2 .         subscope3} asSet.  self assert: scope environment equals: environmentshowVariableNamed: varName  tool selectVariableNamed: varNameselectedClassSide  ^self lastSelectedClassformatTextIfNeeded  RBProgramNode formatterClass formatAsYouReadPolicy ifFalse: [ ^self ].  textMorph formatSourceCode.  textModel clearUserEditsexpectedFlatQueryResult: anObject  expectedFlatQueryResult := anObjectclose  super close.  expandedItems do: [:each |  each childrenDataSource close ]createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'failed tests' priority: -1 on: aMethodQuerytestClassNameFor: inputClass  ^(inputClass name , 'Test') asSymbolprintOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: (annotatedClass ifNil: [ 'detached' ] ifNotNil: [ annotatedClass name ]);     nextPutAll: '; ';     nextPutAll: priority asString;     nextPut: $)doesNodeOf: aMetalinkManager belongsTo: aMethod  | methodNode |  methodNode := aMetalinkManager node methodNode.  methodNode selector == aMethod selector ifFalse: [ ^false ].  methodNode methodClass == aMethod methodClass ifFalse: [ ^false ].  methodNode == aMethod ast ifFalse: [ ^false ].  ^trueprintContext  ^self editingMethod printSystemPathdepth: anObject  depth := anObjecttestMethodsEnumerationOverMetaclassWhenConcreteClassScopeIsScope  | expected |  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassScope.  scope methodsDo: [:each |  result add: each ].  expected := ClyClass1FromP1 class allSuperclasses flatCollect: #methods as: IdentitySet.  self assert: result asIdentitySet equals: expectedaffectsMethodsTaggedWith: tagName  overridingSubclass allSuperclassesDo: [:each |  (each tagsForMethods includes: tagName) ifTrue: [ ^true ] ].  ^falseasDraggableMorph  ^(String streamContents: [:s |  selectedItems do: [:each |  s nextPutAll: each name ] separatedBy: [ s space ] ]) asStringMorphname  ^namecollectMetadataOf: aQueryResult by: anEnvironmentPlugin  subqueries do: [:each |  each collectMetadataOf: aQueryResult by: anEnvironmentPlugin ]analyzedObjectsDo: aBlock  scope methodsDo: aBlockokToClose  self hasUnacceptedEdits ifFalse: [ ^true ].  ^browser confirmDiscardChangescreateQueryResult  ^ClyTraitUserHierarchy inverse asQueryResulttestForbidCreationOnScopeWithoutEnvironment  [ query scope: (ClyScopeExample ofAll: {}).  self assert: false description: 'Query should be only created on scope bound to concrete environment' ] ifError: [  ]getMetaProperty: aPropertyClass  ^metadata getProperty: aPropertyClassprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  self printBasisOn: aStream.  aStream nextPut: $)testComparisonWithSimilarQueryBasedOnDifferentBaseCritiqueQuery  | query2 |  query baseCritiqueQuery: ClyAllBasisCritiqueQuery new.  query2 := self createQuery.  query2 baseCritiqueQuery: ClyAllMethodCritiqueQuery new.  self deny: query equals: query2testForbidCreationOnScopeWhichNotSupportIt  [ query scope: (ClyCompositeScope in: environment).  self assert: false description: 'Query should be supported by scope' ] ifError: [  ]requiresNewDesiredSelection  desiredSelection ifEmpty: [ ^false ].  ^(self selectedTools allSatisfy: [:each |  desiredSelection includes: each class ]) notexecute  | tagEditor |  tagEditor := methodEditor tagsAndPackageEditor.  tagEditor requestChangeBy: [ tagEditor requestTag ]providesGroupsAffectedBy: aSystemAnnouncement inScope: aClassScope  aClassScope classesDo: [:each |  (aSystemAnnouncement affectsMethodTagIn: each) ifTrue: [ ^true ] ].  ^falsetestCheckIfEmpty  query scope: self scopeWithCritiques.  self deny: query checkEmptyResult.  query scope: self scopeWithoutCritiques.  self assert: query checkEmptyResultincludesClass: aClass  ^classes includes: aClasscreateMethodQueryFrom: aClassScope  ^ClyAllMethodsQuery from: aClassScope asLocalClassScopelastSelectedObjectIn: selectedObjects  ^selectedObjects firstcreateRegexMatcherIfFailed: errorBlock  value trimBoth ifEmpty: [ ^errorBlock value ].  ^[ value asRegexIgnoringCase ] on: RegexSyntaxError do: [:ex |  ^self createFixedRegexMatcherIfFailed: errorBlock ]= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^pattern = anObject patterntestFromThreeMethods  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithHalts >> #methodWithHalts1) .         (ClyClassWithBreakpoints >> #methodWithBreakpoints) .         (ClyClassWithBreakpoints >> #methodWithoutBreakpoints)}.  self assert: foundSelectors sorted asArray equals: #(#methodWithBreakpoints #methodWithHalts1)selectClass: aClass  | foundItems classDefinition |  self changeStateBy: [ self switchToMetaLevelScope: aClass metaLevelScope.        foundItems := classView findItemsWith: {aClass instanceSide}.        foundItems ifNotEmpty: [ classDefinition := foundItems anyOne systemDefinition.              (self isPackageSelected: classDefinition definingPackage) ifTrue: [ ^self classSelection selectItems: foundItems ] ].        aClass tags ifEmpty: [ self selectPackage: aClass package ] ifNotEmpty: [:tags |  self selectPackage: aClass package atClassTag: tags anyOne ].        self packageSelection isEmpty ifTrue: [ ^self ].        self showsFullClassHierarchy ifTrue: [ self switchToFullClassHierarchyOf: aClass ].        self classSelection selectItemsWith: {aClass instanceSide} ]testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClass1FromP1 >> #tag1Method1) .         (Object >> #printString) .         (ClySubclassLOfClass0FromPExtendedByP1 >> #extensionMethodFromSubclassL) .         (ClyClass9FromPExtendedByP5 >> #extensionMethodFromClass9)}.  self assert: foundSelectors equals: #(#extensionMethodFromSubclassL)numberOfRows  ^self itemCursor itemCount - (collapsedItems detectSum: [:each |  each childrenCount ])buildIsDone  asyncModeIsActive ifTrue: [ super buildIsDone ]lastSelectedClassTag  ^self lastSelectedObjectIn: self selectedClassTagstestEmptySubqueriesAreForbidden  [ query subqueries: {}.  self assert: false description: 'empty subqueries should be forbidden' ] ifError: [  ]definitionTypeLabel  ^'Slots'isAppliedToBrowser  ^browser showsFlatClassestestQueryExecutionWhenResultWasWeaklyCollectedAsGarbage  | cache result result2 query |  query := self createQueryFromScopeOf: self class.  environment query: query.  Smalltalk     garbageCollectMost;     garbageCollectMost.  cache := environment cachedResultOf: query.  self assert: cache equals: nil.  result := environment query: query.  self assert: result class equals: ClyRawQueryResult.  result2 := environment query: query.  self assert: result identicalTo: result2testCreationUnifiedInstanceWhenThereIsExtraScopeParameter  | unifiedInstance |  query extraParameter: #testParameter.  unifiedInstance := query asUnifiedInstance.  self assert: unifiedInstance extraParameter equals: #testParameterwindowIsClosing  self closeDataSourcetestIsEmptyForExplicitlyDefinedAbstractClass  query scope: (ClyClassScope of: ClyExplicitAbstractClassExample in: environment).  self assert: query checkEmptyResult.  self executeQuery.  self assert: foundSelectors isEmptycreatePackageNamed: aPackageName  ^environment ensurePackageNamed: aPackageNametestFillingWithTraitAndItsUsersWhenSomeUserInMiddleIsMissing  queryResult fillWith: {ClyTraitRoot1 .         ClyTraitChild1 .         ClyClassWithTraits .         ClyTraitChild2}.  self assertItems: {ClyTraitRoot1 .         0 .         ClyTraitChild1 .         1 .         ClyClassWithTraits .         2 .         ClyTraitChild2 .         1 .         ClyClassWithTraits .         2}announcerPlugin  ^announcerPlugintestCheckIfEmpty  query scope: (ClyMethodScope of: self class >> self targetSelector in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #messageImplementor2 in: environment).  self assert: query checkEmptyResultwasNotified  ^wasNotified ifNil: [ false ]decorateBrowserItem: anItem ofClass: aClass  aClass isDeprecated ifTrue: [ anItem markWith: ClyDeprecatedItemTag ]handleSystemChange: aSystemAnnouncement byProcessingList: allProcessingResults  | expectedResult |  super handleSystemChange: aSystemAnnouncement byProcessingList: allProcessingResults.  expectedResult := environment cachedResultOf: buildingQuery.  expectedResult ifNil: [ ^self ].  needsRebuild ifTrue: [ buildProcess ifNotNil: [ buildProcess terminate.              metadata removeProperty: ClyBackgroundProcessingTag instance ].        expectedResult itemsChanged ].  allProcessingResults remove: expectedResult ifAbsent: [  ]testBuildingGroups  self buildGroupsFor: self packageSampleWhichHasGroup.  self assert: builtGroups notEmptydefaultMenuIconName  ^#smallDebugprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  aStream nextPutAll: 'size: '.  subtreeSize printOn: aStream.  aStream nextPut: $)defaultMenuItemName  ^'Inheritance'= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^sortFunction = anObject sortFunction and: [ inverse = anObject isInverse ]collectClassGroupProviders  ^{ClyExtendedClassGroupProvider .   ClyNoTagClassGroupProvider .   ClyTaggedClassGroupProvider} collect: [:each |  each new ]sender1OfMessage1  self clyReferencedMessage1semiAsync  ^self copy asyncResult: ClySemiAsyncQueryResult newtestFillingWithClassesFromOneHierarchy  queryResult fillWith: {ClySubclassN1OfClass1FromP1 .         ClySubclassLOfSubclassMFromP3 .         ClyClass1FromP1 .         ClySubclassN2OfClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1 .         ClySubclassN1OfClass1FromP1 .         1 .         ClySubclassN2OfClass1FromP1 .         1}isStatic  ^truedefaultMenuIconName  ^#smallCancelsetUpTargetClasses  self subclassResponsibilitygrabSelectionAt: rowIndex  | selectedItems |  (table isIndexSelected: rowIndex) ifTrue: [ ^self selection ].  selectedItems := rowIndex = 0 ifTrue: [ #() ] ifFalse: [ {(self itemAt: rowIndex)} ].  ^self newSelectionWith: selectedItemsbelongsToCurrentBrowserContext  ^browser isClassSelected: testClasspackageView  ^packageViewcoveringTest: anObject  coveringTest := anObjecttestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithUndeclares >> #method1WithUndeclares in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: Object >> #printString in: environment).  self assert: query checkEmptyResultinitializeItems  items := self defaultItemschooseClassForNewMethodIfNone: aBlock  targetClasses size = 1 ifTrue: [ ^targetClasses first ].  ^[ self browser searchDialog requestSingleObject: 'Where install new method?' from: (ClyAllClassesQuery as: ClyMethodVisibilityProvider defaultHierarchy asQueryResult) inScope: (ClyClassScope ofAll: targetClasses) ] on: CmdCommandAborted do: [:err |  aBlock value ]switchToProjects  packageView showQuery: (systemScope projectQueryFor: self systemScope)installBreakpointInto: aMethod  | breakpoint |  breakpoint := Breakpoint new     node: aMethod ast;     always.  installedBreakpoints add: breakpoint.  breakpoint installisManagedByUser: anObject  isManagedByUser := anObjectscopeClass  ^ClyBothMetaLevelClassScopetestRepresentsClassOfScope  scope := ClyMultipleClassRelationScope of: #() merging: {ClySuperclassScope}.  self assert: (scope representsScope: ClySuperclassScope).  self assert: (scope representsScope: ClyMultipleClassRelationScope).  self assert: (scope representsScope: ClyTypedScope).  self deny: (scope representsScope: ClySubclassScope).  self deny: (scope representsScope: ClyCompositeScope)warnUserAboutMyContext  self setUpDefaultIconclassesDo: aBlock  self system classes do: aBlockapplyDecorations  | hasEdits |  hasEdits := textMorph hasUnacceptedEdits.  textMorph segments copy do: #delete.  IconStyler styleText: textModel withAst: editingMethod astForStylingInCalypso.  textMorph hasUnacceptedEdits: hasEdits.  super applyDecorations.  browser decorateMethodEditor: selfconfirmEmptySystemQuery: aQuery excluding: classes  | showResult result |  result := aQuery execute.  (result isEmpty or: [ ((result items collect: [:each |  each origin ]) difference: classes) isEmpty ]) ifTrue: [ ^true ].  showResult := UIManager default confirm: 'There are ' , result size asString , ' ' , aQuery description , '. Show them?'.  showResult ifTrue: [ self spawnQueryBrowserOn: aQuery ].  ^falseretrieveStateFrom: aBrowser  super retrieveStateFrom: aBrowser.  metaLevelScope := aBrowser metaLevelScope.  methodGroupQuery := aBrowser methodGroupQueryautoSelect  ^autoSelecttestSimpleCondition_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'true') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: true ]')description  ^name ifNil: [ self system name ]applyResultInContext: aToolContext  super applyResultInContext: aToolContext.  aToolContext activeQueryView dataSource runUpdateprintMethodTagsOrPackage  ^self isExtensionActive ifTrue: [ ownerTool extendingPackage name ] ifFalse: [ self printMethodTags ]createCellFor: aDataSourceItem in: aQueryView  | cell |  cell := ClyMainItemCellMorph on: aDataSourceItem.  displayBlock value: cell value: aDataSourceItem.  aQueryView decorateMainTableCell: cell of: aDataSourceItem.  cell build.  ^cellbrowser  ^browserlocalScopeClass  self subclassResponsibility= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^basisObjects = anObject basisObjectsrepresentsConcreteQuery  ^(dataSource isBasedOn: ClyUnknownQuery instance) notparentItem: anObject  parentItem := anObjectexecute  | methodsOfAnotherClass |  methodsOfAnotherClass := methods reject: [:each |  each origin = targetClass ].  methodsOfAnotherClass ifNotEmpty: [ (SycMoveMethodsToClassCommand methods: methodsOfAnotherClass class: targetClass) execute ].  methodGroup importMethods: methodsprepareFullExecutionInContext: aBrowserContext  super prepareFullExecutionInContext: aBrowserContext.  selectedItems := aBrowserContext selectedObjectstestFromSingleClass  self executeQuery.  self assert: foundSelectors equals: #(abstractMethod2 abstractSubclassMethod)buildTestSuite  | suite |  suite := TestSuite new.  self testMethodsDo: [:eachMethod |  suite addTest: (eachMethod methodClass selector: eachMethod selector) ].  ^suitegroupProviderClass  ^ClyAbstractMethodGroupProviderdetachedItems  ^items collect: [:each |  each copy ]name  ^'Refactorings'= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^critiqueQuery = anObject critiqueQuerytestNotAffectedByChangeOfAbstractMethodOfNotRelatedClass  self deny: (query isAffectedByChangedMethod: self class >> #createQuery)detachFromSystem  browser system unsubscribe: selfitems: anObject  items := anObjectcreateMethodQueryFrom: aClassScope  ^ClyFFIMethodQuery from: aClassScopeisGlobalVariableSelected  ^falseinitialExtent  ^850 @ 620selectedSourceNode  | selectedInterval |  selectedInterval := self selectedTextInterval.  ^(editingMethod astForStylingInCalypso bestNodeFor: selectedInterval) ifNil: [ editingMethod astForStylingInCalypso ]description  ^super description , ' filtered by ' , itemFilter printCriteriahash  ^basisObjects hashapplyChanges  | newClass |  newClass := browser compileANewClassFrom: self pendingText asString notifying: textMorph startingFrom: nil.  newClass ifNil: [ ^false ].  self removeFromBrowser.  browser selectClass: newClass.  ^truecreateInheritanceScopeFrom: classes  | classScope |  classScope := ClyClassScope ofAll: classes in: browser navigationEnvironment.  ^classScope asInheritedScopetestNotSelectsTaggedClass  self deny: (query selectsClass: ClyClass7WithTag1FromP5)execute  | env commit snapshot |  env := RGEnvironment new.  commit := repositoryModel commit.  #(1) do: [:i |  snapshot := commit snapshotFor: (RPackage named: packageModel name).        snapshot importInto: env asPackageNamed: packageModel name ] displayingProgress: 'loading'.  env clean.  env browseAs: repositoryModel entity descriptioncolor  ^colorprojectSelection  ^packageView selection asSelectedParentsOf: self projectClasscollectMetadataOfProjects: aQueryResult  selectCurrentExtensionMethodGroup  self classSelection isEmpty ifTrue: [ ^self ].  self classSelection isMultipleSelected ifTrue: [ ^self ].  (self classSelection lastSelectedItem isMarkedWith: ClyExtendedClassTag) ifFalse: [ ^self ].  self selectMethodGroupNamed: self packageSelection lastSelectedItem namedefaultMenuIconName  ^#arrowUpprepareExecutionInDropContext: aToolContext  super prepareExecutionInDropContext: aToolContext.  classGroup := aToolContext lastSelectedClassGrouptestHasUnknownResultInstance  self assert: query requiredResult identicalTo: ClyUnknownQueryResult instanceswapPrioritiesBetween: aTool1 and: aTool2  | priority1 priority2 |  aTool1 allowsDifferentActivationPriority ifFalse: [ ^self ].  aTool2 allowsDifferentActivationPriority ifFalse: [ ^self ].  priority1 := self overridenPriorityOf: aTool1.  priority2 := self overridenPriorityOf: aTool2.  selectionPriorities at: aTool1 class put: priority2.  selectionPriorities at: aTool2 class put: priority1testCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #writer1OfVar1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #readerOfVar1 in: environment).  self assert: query checkEmptyResultisAffectedByChangedMethod: aMethod  | selector |  (self isFromScopeWithClassKindOf: aMethod origin) ifFalse: [ ^false ].  selector := aMethod selector.  scope classesDo: [:each |  (each lookupSelector: selector) ifNotNil: [ ^true ] ].  ^falseokToChange  (tools anySatisfy: #hasUnacceptedEdits) ifFalse: [ ^true ].  ^browser confirmDiscardChangestestDoesNotExecuteAnyQuery  self deny: (query executesQuery: #any)includesClassGroupsAffectedBy: aSystemAnnouncement  ^falseselectMethod: aMethod  | foundItems |  self changeStateBy: [ foundItems := methodView findItemsWith: {aMethod}.        foundItems ifNotEmpty: [ ^self methodSelection selectItems: foundItems ].        self selectClass: aMethod origin.        self classSelection isEmpty ifTrue: [ ^self ].        self methodGroupSelection beEmpty.        self methodSelection selectItemsWith: {aMethod} ]methodWithoutHalts  self printStringclassNamed: aString ifPresent: aBlockClosure ifAbsent: anotherBlockClosure  ^globals at: aString ifPresent: aBlockClosure ifAbsent: anotherBlockClosurelastSelectedClass  ^self lastSelectedItem systemDefinition definingClasswithInheritingScope  | fullScope |  fullScope := self , self asInheritingScope.  fullScope name: self class userHierarchyScopeName.  ^fullScopegroupProviderClass  ^ClyExtendedMethodGroupProviderinitialize  | separator |  super initialize.  self     changeTableLayout;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: 4 @ 0.  separator := self theme newLabelIn: self label: '|'.  self addMorph: separatoraddItemToMenu: aMenu  | listItem |  listItem := ClyCritiqueMenuItemMorph new     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     cellPositioning: #center;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     cellInset: 5;     color: Color transparent;     yourself.  listItem addMorphBack: (ImageMorph withForm: critique icon).  listItem addMorphBack: critique title asStringMorph.  critique actions do: [:action |  listItem addMorphBack: (IconicButton new                 target: action;                 labelGraphic: action icon;                 actionSelector: #actOnCritic:ofEntity:;                 arguments: {critique .                     entity};                 color: Color transparent;                 helpText: action description;                 extent: 16 @ 16;                 borderWidth: 0;                 yourself) ].  ^aMenu addMenuItem: listItemasScope: anotherEnvironmentScopeClass  ^selftestDescendingSamePackageSameClassDifferentSelector  function := ClySortMethodByPackageFunction descending.  self deny: (function value: Object >> #printString value: Object >> #yourself).  self assert: (function value: Object >> #yourself value: Object >> #printString)itemObserver: anObject  itemObserver := anObjectcreateQuery  ^ClyMessageImplementorsQuery of: self targetSelector from: (ClyClassScope of: Object in: environment)environment: anObject  environment := anObjectprepareBasisFrom: aCollection  ^aCollection asIdentitySetaddCommandItem: aMorph  commandBar addMorphBack: aMorph.  ^aMorphopenAnotherBrowser: aBrowser  (aBrowser isKindOf: ClyQueryBrowser) ifTrue: [ aBrowser openInWindow: self window ] ifFalse: [ aBrowser open ]prepareFullExecutionInContext: aToolContext  | packageName |  super prepareFullExecutionInContext: aToolContext.  method := aToolContext lastSelectedMethod.  packageName := method package name.  repository := IceRepository registry detect: [:each |  each includesPackageNamed: packageName ]subqueries: aCollection  | subscopes |  aCollection ifEmpty: [ ^self error: 'Composite query must have at least one subquery' ].  subqueries := aCollection asSet.  subscopes := subqueries collect: [:each |  each scope ].  scope := ClyCompositeScope on: subscopes.  self requiredResult: subqueries anyOne requiredResultclassNamed: aString  ^globals classNamed: aStringitemFilterClass: anObject  itemFilterClass := anObjectsetUp  | query |  super setUp.  query := self createQuery.  queryResult := query execute.  itemObserver := ClyItemObserverExample new.  cursor := queryResult openBrowserCursorFor: itemObserverdescription  ^'extending packages'doesAnyManager: metalinkManagers belongsTo: aMethod  ^metalinkManagers anySatisfy: [:each |  each notNil and: [ self doesNodeOf: each belongsTo: aMethod ] ]activeQueryView  ^self browser navigationViews detect: [:each |  each createSelectionContext class = self class ]classScopeOfSelectedItems  | classes |  classes := self selection items collect: [:methodItem |  methodItem systemDefinition definingClass ].  ^ClyBothMetaLevelClassScope ofAll: classes in: navigationEnvironmentbuildGroupsForAll: packages  | classScope |  classScope := ClyPackageScope ofAll: packages in: environment.  groupProvider classGroupsIn: classScope do: [:each |  builtGroups add: each ]start: anObject  start := anObjectdefaultMenuIconName  ^#komitterSmalltalkhubRemoterequiredResult: aQueryResult  requiredResult := aQueryResult.  self shouldBeProtectedByWriteBarrier ifTrue: [ requiredResult beReadOnlyObject ]asScope: anotherTypedScopeClass ofAll: newBasisObjects  ^anotherTypedScopeClass ofAll: newBasisObjects in: environmentwithScope: aScope  self subclassResponsibilitydecorateItemGroup: groupItem  groupItem markWithChildrenOf: self resultItemsTypemetalinkManagerClass  self subclassResponsibilitybelongsToCurrentBrowserContext  ^browser isClassSelected: methodClass instanceSidetestIsAffectedByChangeOfAbstractMethodWhichIsNotImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #abstractMethod2).  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractSubclassMethod)beBoldIfActive  self isModeActive ifTrue: [ radioButton labelMorph emphasis: TextEmphasis bold emphasisCode ] ifFalse: [ radioButton labelMorph emphasis: TextEmphasis normal emphasisCode ]setUpParametersFromModel  editingMethod := testClass lookupSelector: #setUp.  super setUpParametersFromModelinitialize  super initialize.  expandedItems := SortedCollection sortBlock: [:a :b |  a position < b position ]initialize  super initialize.  needsRebuild := false.  self initializeItems.  self collectMetadataactiveStatusBar  ^self selectedTools first statusBardetachFromSystem  environment system unsubscribe: self.  super detachFromSystemorderForBrowser  ^3criteriaBlock: anObject  criteriaBlock := anObjectcreateQuery  ^ClyConstantQuery returning: #(item1 item2) from: (ClyScopeExample emptyIn: environment)execute  browser closeprintContext  ^methodClass printSystemPath , ' / ' , methodClass nametestSelf_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'self') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: ThisContext receiver ]')isEmpty  self subclassResponsibilityprepareFullExecutionInContext: aBrowserContext  super prepareFullExecutionInContext: aBrowserContext.  packages := browser searchDialog requestMultipleObjects: 'Select package scope' from: ClyAllPackagesQuery sorted.  packages ifEmpty: [ CmdCommandAborted signal ]checkEmptyResult  scope packagesDo: [:each |  each tagsForClasses ifNotEmpty: [ ^scope isQueryEmpty: ClyUntaggedClassesQuery new ] ].  ^trueupdateCacheForMethod: aMethod  allImplementorsCache ifNil: [ ^self ].  cacheGuard critical: [ aMethod isInstalled ifTrue: [ self cacheMethod: aMethod ] ifFalse: [ self removeMethodFromCache: aMethod ] ]setUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyInheritanceAnalysisEnvironmentPlugin newdefaultMenuItemName  ^'Find class'testRetrievesNavigationHistory  self snapshotState.  self assert: navigationState navigationHistory equals: browser navigationHistoryaddToolbarItemInto: toolbarMorph using: aCommandActivator  | compoBox |  compoBox := ClyScopeCompoBox for: browser.  toolbarMorph addNewItem: compoBoxprovidesGroupsAffectedBy: aSystemAnnouncement inScope: aClassScope  | query |  query := self createMethodQueryFrom: aClassScope.  ^query isResult: ClyUnknownQueryResult instance affectedBy: aSystemAnnouncementdefaultMenuItemName  ^'Remove'testClassEnumerationOverClassWhenClassSideIsLocalScope  | expected |  scope := ClySubclassScope of: Class localScope: ClyClassSideScope.  scope classesDo: [:each |  result add: each ].  expected := Class subclasses select: #isInstanceSide thenCollect: #classSide.  self assert: result asSet equals: expected asSetprintDefinition  ^self printDefiningClassasRBEnvironment  | env |  env := subscopes first asRBEnvironment.  subscopes allButFirstDo: [:each |  env := env | each asRBEnvironment ].  ^envtestItemsChangedNotificationShouldResetItems  queryResult initializeItems.  self assert: queryResult isBuilt.  queryResult itemsChanged.  self deny: queryResult isBuilt.  self assert: queryResult items isNilcreateMethodGroupFor: aMethodQuery from: aClassScope  ^ClyAllMethodGroup withMethodQuery: aMethodQuery andClassesInheritedFrom: aClassScopeprepareFullExecutionInContext: aToolContext  | confirmed |  super prepareFullExecutionInContext: aToolContext.  classGroup := aToolContext lastSelectedClassGroup.  classGroup classesSize > 0 ifTrue: [ confirmed := UIManager default confirm: 'Are you sure you want to remove all classes in group ' , classGroup name , '?'.        confirmed ifFalse: [ CmdCommandAborted signal ] ]testCheckIfEmpty  query scope: (ClyMethodScope of: ClySubclassLOfClass0FromPExtendedByP1 >> #extensionMethodFromSubclassL in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self assert: query checkEmptyResultisInlined  ^truetestIsBoundToEnvironmentWhenScopeIs  self assert: query scope isBoundToEnvironment.  self assert: query isBoundToEnvironmentqueryScopes  ^queryScopesfullDescription  ^self description , ' from ' , (scope isBasedOnEmptyBasis ifTrue: [ 'empty scope' ] ifFalse: [ scope description ])testMoveToItemWhichSatisfiesCondition  | found |  found := cursor moveToItemWhich: [:each |  each actualObject = Object ].  self assert: found.  self assert: cursor position equals: 2.  self assert: cursor currentItem actualObject equals: Objectname: anObject  name := anObjectbrowser  ^browsercreateQueryFromScopeOf: aBasisObject  ^self createQueryFromScope: (ClyScopeExample of: aBasisObject)description  ^'classes without tags'activationPriority  ^browser methodGroupSelection isEmpty ifTrue: [ 0 ] ifFalse: [ ClyClassDefinitionEditorToolMorph tabOrder + 1 ]classesDo: aBlock  self packagesDo: [:package |  package definedClasses do: aBlock ]allClassesRelatedTo: aClass do: aBlock  | actualClass |  actualClass := localScopeClass metaLevelForHierarchyOf: aClass.  self classesRelatedTo: actualClass do: [:each |  (localScopeClass metaLevelForHierarchyOf: each) = each ifTrue: [ each isObsolete ifFalse: [ self metaLevelsOf: each do: aBlock ].              self allClassesRelatedTo: each do: aBlock ] ]doesMethodHasWatchpoint: aMethod  ^self doesAnyManager: Watchpoint allWatchpoints belongsTo: aMethodbuildTestSuite  | suite |  suite := TestSuite new.  self testMethodsDo: [:eachMethod |  eachMethod isFailedTest | eachMethod isErrorTest ifTrue: [ suite addTest: (eachMethod methodClass selector: eachMethod selector) ] ].  ^suitedecorateOwnBrowserItem: myItem  super decorateOwnBrowserItem: myItem.  methodQuery decorateItemGroup: myItem.  subgroupsQuery decorateItemGroup: myItemscopeClass  ^ClyPackageExtensionScopeisFilterActive  table initialDataSource ifNil: [ ^false ].  ^self dataSource ~~ table initialDataSourcetestClassFor: inputClass  | className resultClass |  className := self testClassNameFor: inputClass.  self systemEnvironment classNamed: className ifPresent: [:class |  resultClass := class ] ifAbsent: [ (self isValidClass: inputClass) ifFalse: [ ClyInvalidClassForTestClassGeneration signalFor: inputClass ].        self systemEnvironment ensureExistAndRegisterPackageNamed: inputClass package name asString , '-Tests'.        resultClass := TestCase subclass: className instanceVariableNames: '' classVariableNames: '' package: (self newTestClassCategoryFor: inputClass).        self addNewCommentForTestClass: resultClass basedOn: inputClass ].  ^resultClassupdateWindowTitle  self window ifNotNil: [:w |  self setWindowTitle: self newWindowTitle in: w.        (self ownerThatIsA: GroupWindowMorph) ifNotNil: [:group |  group window ifNotNil: [:mainWindow |  self setWindowTitle: w labelString in: mainWindow ] ] ]execute  browser switchToPackageScopeOf: packagessetUpEnvironment  environment := ClyNavigationEnvironment newtestConvertingToInheritedScope  | convertedScope |  scope := ClyCompositeScope on: {(ClyInstanceSideScope of: Object in: environment) .         (ClyClassSideScope of: Array in: environment)}.  convertedScope := scope asInheritedScope.  self assert: convertedScope class equals: ClyCompositeScope.  self assert: (convertedScope subscopes first representsScope: ClySuperclassScope).  self assert: (convertedScope subscopes last representsScope: ClySuperclassScope).  self assert: (convertedScope subscopes collect: #localScopeClass as: Set) equals: {ClyInstanceSideScope .         ClyClassSideScope} asSet.  self assert: convertedScope environment equals: environment.  self assert: convertedScope name equals: ClyClassScope inheritedScopeNameactionBlock: anObject  actionBlock := anObjecttag  ^methodQuery tagcreateCriticView  criticView := ClyQueryViewMorph for: self.  criticView     name: 'critiques table';     hResizing: #spaceFill;     vResizing: #rigid;     borderWidth: 4;     borderColor: browserTool containerTab backgroundColor.  criticView height: 50selectedTabs  ^selectedTabsprepareStateBeforeExecution  testCurrentItem  | item |  item := cursor currentItem.  self assert: item class equals: ClyBrowserItem.  self assert: item isPrepared.  self assert: item position equals: 1implementorSelector  ^implementorMethod selectortestCaseResults  ^testCaseResultsexecute  methodGroups do: #removeWithMethodsprovidesGroupsAffectedBy: aSystemAnnouncement inScope: aPackageScope  aPackageScope packagesDo: [:each |  (aSystemAnnouncement affectsPackage: each) ifTrue: [ ^true ] ].  ^falsetestApplyingToQueryViewShouldCreateOpenedDataSource  | newView |  self snapshotState.  newView := ClyQueryViewMorph for: browser.  navigationState applyTo: newView.  self assert: newView dataSource ~~ navigationState dataSource.  self deny: newView dataSource isClosed.  self assert: newView dataSource queryView equals: newView.  self assert: newView dataSource table notNiltestFillingWithOnlyTraitWithoutUsers  queryResult fillWith: {ClyTraitRoot1}.  self assertItems: {ClyTraitRoot1 .         0}testExecution  self executeQuery.  self assert: foundSelectors equals: #(methodWithHalt methodWithHalt2)supportsCriticDecoration  ^package notNillocalHierarchySize  | property |  property := self getProperty: ClyItemLocalHierarchyProperty ifAbsent: [ ^0 ].  ^property subtreeSizeisSelectedItemHasExecutionCounter  ^selectedSourceNode hasExecutionCounterspotterForGoToFor: aStep  < spotterOrder: 10>  aStep listProcessor     title: 'Go to';     allCandidates: [ self collectGoToCandidates ];     itemName: #name;     itemIcon: #icon;     candidatesLimit: 10;     filter: GTFilterSubstring;     actLogic: [:assoc :step |  step exit.        assoc activate ]classes  ^globals allClassesAndTraits= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^pattern = anObject patterntoggleScope  ^self isActive ifTrue: [ self deactivateExtraScope ] ifFalse: [ self activateExtraScope ]fillWith: classes  | actualClassScope classMap addedClasses |  actualClassScope := self scope asLocalClassScope.  classMap := hierarchy buildFrom: classes.  addedClasses := Set new.  classMap doInOrderWithDepth: [:each :depth |  (addedClasses includes: each) ifFalse: [ addedClasses add: each.              self buildGroupFor: each depth: depth toShowMethodsFrom: actualClassScope ] ]criticAnalysisScope  ^ClyClassScope of: editingClass in: browser navigationEnvironmentitemCount  ^self dataSource numberOfRowsshouldBuildGroupWith: aMethodQuery  self isStatic ifFalse: [ ^true ].  ^aMethodQuery hasEmptyResult notreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  testItems := aToolContext selectedItems select: [:each |  each hasProperty: ClyTestedMethodProperty ]mainColumn  ^table columns detect: #isMainColumnactualResult  ^actualResultitemsStartingWhere: conditionBlock count: size  | firstItemIndex |  firstItemIndex := items findFirst: conditionBlock.  firstItemIndex = 0 ifTrue: [ ^#() ].  ^self itemsStartingAt: firstItemIndex count: sizetestDetectingDefiningClassFromClassSide  | varBinding var |  varBinding := ClyClass2FromP1 classVariableNamed: #ClassVar1.  var := ClyClassVariable on: varBinding visibleFrom: ClyClass2FromP1 class.  self assert: var definingClass equals: ClyClass2FromP1= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^subqueries = anObject subqueriesisStatic  ^trueprocessMethodChange: aMethodAnnouncement  | method |  self updateCacheForMethod: aMethodAnnouncement methodAffected.  method := aMethodAnnouncement methodAffected.  method methodClass superclass ifNotNil: [:superclass |  (superclass lookupSelector: method selector) ifNotNil: [:overriddenMethod |  ^environment systemChanged: (ClyOverriddenMethodChanged method: overriddenMethod) ] ].  method methodClass subclasses ifEmpty: [ ^self ].  environment systemChanged: (ClyOverridingMethodsChanged initiatedBy: self forOverriddenMethod: method)printBasisObject: aPackage on: aStream  ^aStream nextPutAll: aPackage nameshowClass: aClass  tool selectClass: aClassnotDeprecatedMethod  when: anAnnouncementClass send: aSelector to: anObject  changesAnnouncer weak when: anAnnouncementClass send: aSelector to: anObjectmethodGroupQuery: aQuery  methodGroupQuery := aQueryclassGroupsIn: aPackageScope do: aBlock  | classGroups group |  classGroups := Dictionary new.  aPackageScope packagesDo: [:each |  each tagsForClasses do: [:eachTag |  classGroups at: eachTag ifAbsentPut: [ group := ClyTaggedClassGroup withClassesFrom: aPackageScope taggedBy: eachTag.                    aBlock value: group.                    group ] ] ]description  ^'Method call counters'execute  browser spawnQueryBrowserOn: (ClyVariableWritersQuery ofAny: variables)lastSelectedObject  ^self lastSelectedItem actualObjecteditingText  self flag: #pharoTodo.  ^editingClass definitionisPackageSelected  ^self selectedPackageItems notEmptyisSelectedItemHasBreakpoint  ^selectedItems anySatisfy: [:each |  each isMarkedWith: ClyMethodWithBreakpointTag ]selectsMethod: aMethod  ^aMethod usesUndeclaresclassSampleWhichHasGroup  ^ClyAbstractClassExampletestMethodsEnumerationOverInstanceSideWhenBothMetaLevelsAreLocalScope  | expected |  scope := ClySuperclassScope of: ClyClass1FromP1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:each |  result add: each ].  expected := {Object .   Object class .   ProtoObject .   ProtoObject class} flatCollect: #localMethods as: IdentitySet.  self assert: result asIdentitySet equals: expectedtestHasCompositeScopeFromSubqueries  | scope |  scope := query scope.  self assert: scope class equals: ClyCompositeScope.  self assert: scope subscopes equals: (query subqueries collect: #scope)testCompareClassesAndMethods  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object)asInheritedScope  | newSubscopes |  newSubscopes := subscopes collect: [:each |  each asInheritedScope ].  ^ClyCompositeScope on: newSubscopes in: environment named: ClyClassScope inheritedScopeNamedoesItemHaveChildren: aDataSourceItem  self subclassResponsibilityprintBasisObject: anObject on: aStream  ^anObject printOn: aStreamdecorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph definitionIcon: #protocolExtensionIcontargetClass: anObject  targetClass := anObjectselectedMethodItems  ^tool methodSelection itemsdesiredSelection  ^desiredSelectionbuildResult: aQueryResult  self subclassResponsibilitydescription  ^'classes tagged with ' , tagtoggle  textMorph wrapped ifTrue: [ textMorph beNotWrapped ] ifFalse: [ textMorph beWrapped ].  self updateLabelselectSourceNode: anASTNode  textMorph setSelection: anASTNode sourceIntervalgroupName  ^groupNameclassNamesContainingIt  | query |  self lineSelectAndEmptyCheck: [ ^self ].  query := ClyAllClassesQuery new filteredBy: (ClyItemNameFilter substringPattern: self selection string).  self browser spawnQueryBrowserOn: queryprintOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: annotatedClass name.  targetItemType ifNotNil: [ aStream           nextPutAll: '; ';           nextPutAll: targetItemType name ].  aStream nextPut: $)testFillingWithOnlyClassWhichHasTraits  queryResult fillWith: {ClyClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0}collapse: aDataSourceItem  queryView changeStateBy: [ expandedItems remove: aDataSourceItem.        aDataSourceItem childrenDataSource close.        self expansionChanged ]methodClass  self subclassResponsibilitydescription  ^'all variables'testBuildsDefaultResultByDefault  self assert: query buildsDefaultResultinstanceSideVar1ReaderMethod  ^instanceSideVar1isTestClass: aClass  ^aClass isTestCase or: [ aClass users anySatisfy: [:eachUser |  self isTestClass: eachUser ] ]createSelectionContextOf: aSelection  ^ClyContextSelectionStrategy selectContextOf: aSelection for: browserincludesClassNamed: aSymbol  ^self environment includesClassNamed: aSymbolselectsMethod: aMethod  ^truetestFindTestedClassCoveredByTestCaseWithoutSuffix  | foundClass |  foundClass := plugin findTestedClassCoveredBy: ClyTestedClass ifAbsent: [ #noResult ].  self assert: foundClass equals: #noResultincludesVariablesAffectedBy: aSystemAnnouncement  ^falsetestFromSingleClass  self queryFromScope: ClyInstanceSideScope of: ClyClass1FromP1.  self assert: (resultItems collect: #class as: Set) equals: {ClyAllMethodGroup .         ClyTaggedMethodGroup} asSet.  self assert: (resultItems select: [:each |  each class = ClyTaggedMethodGroup ] thenCollect: #tag) asSet equals: ClyClass1FromP1 tagsForMethods asSettestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClass1FromP1 >> #tag1Method1) .         (Object >> #printString) .         (ClySubclassLOfClass0FromPExtendedByP1 >> #extensionMethodFromSubclassL)}.  self assert: foundSelectors equals: #(#extensionMethodFromSubclassL)collectAllClasses  | classes |  classes := OrderedCollection new: basisObjects size.  self classesDo: [:each |  classes add: each ].  ^classesisExtensionActive  ^ownerTool extendingPackage notNilexecuteQuery  result := query execute.  resultItems := result itemsmethodSourceContainingIt  | query pattern |  self lineSelectAndEmptyCheck: [ ^self ].  pattern := self selection string.  query := (ClyMethodSourcesQuery withString: pattern) , (ClyClassCommentsQuery withString: pattern).  self browser spawnQueryBrowserOn: querylevel  ^#(information warning error) indexOf: nameasCalypsoBrowserItem  ^selfmethodsDo: aBlock  self classesDo: [:eachClass |  self metaLevelsOf: eachClass do: [:concreteMetaLevelClass |  concreteMetaLevelClass methods do: aBlock ] ]isResult: aQueryResult affectedBy: aSystemAnnouncement  ^falserequestPackage  | extendingPackage |  extendingPackage := ownerTool context requestSinglePackage: 'Choose package for method'.  ownerTool extendingPackage: extendingPackageselectedClassSide  ^tool currentMetaLevelOf: self lastSelectedClassswitchToFullClassHierarchyOf: aClass  | classScope |  classScope := ClyInstanceSideScope of: aClass in: navigationEnvironment.  self switchClassViewTo: ClyHierarchicallySortedClasses new inScope: classScope asFullHierarchyScopehasMetaProperty: aPropertyClass  ^self itemCursor hasMetaProperty: aPropertyClassisBasedOnItemType: aClass  ^self isEmpty ifTrue: [ rootDataSource isBasedOnQueryOf: aClass ] ifFalse: [ self lastSelectedItem isBasedOnItemType: aClass ]testComparisonWithCopy  | queryResult2 |  queryResult2 := queryResult copy.  self assert: queryResult equals: queryResult2execute  | traitDefinition category resultTrait |  category := package name.  classTag ifNotNil: [ category := category , '-' , classTag ].  traitDefinition := 'Trait named: #TNameOfTrait	uses: {}	package: ''' , category , ''''.  traitDefinition := UIManager default multiLineRequest: 'Define trait definition:' initialAnswer: traitDefinition answerHeight: 250.  traitDefinition isEmptyOrNil ifTrue: [ ^self ].  resultTrait := browser compileANewClassFrom: traitDefinition notifying: nil startingFrom: nil.  resultTrait ifNotNil: [ browser selectClass: resultTrait ]createQuery  ^ClyAllClassVariablesQuery from: ClyClassScope of: ClyClass2FromP1 in: environmentexecute  | tagEditor |  tagEditor := methodEditor tagsAndPackageEditor.  tagEditor resetTagsAndPackagetestGettingItemsStartingAtGivenPosition  | actual |  queryResult fillWith: #(1 2 3 4 5 6).  actual := queryResult itemsStartingAt: 3 count: 2.  self assert: actual asArray equals: #(3 4)buildParentMap: aHierarchyMap for: aClass  | allParents eachParent |  allParents := IdentitySet withAll: aClass traits.  [ allParents isEmpty ] whileFalse: [ eachParent := allParents anyOne.        allParents remove: eachParent.        (aHierarchyMap includesClass: eachParent) ifTrue: [ aHierarchyMap addChild: aClass to: eachParent ] ifFalse: [ allParents addAll: eachParent traits ] ]buildResult: aQueryResult  self shouldNotImplementmergedParts  ^mergedPartsaddIcon: anIcon  classSampleWhichHasGroup  self subclassResponsibilitytestBuildingGroups  self buildGroupsFor: self classSampleWhichHasGroup.  self assert: builtGroups notEmptycheckEmptyResult  ^subqueries allSatisfy: [:each |  each hasEmptyResult ]instanceVariablesDo: aBlock  self classesDo: [:eachClass |  self instanceVariablesOf: eachClass do: aBlock ]createCommandContext  ^ClyGlobalContextOfFullBrowser for: selfshouldBeAppliedFor: aSelectionOrItem  targetItemType ifNil: [ ^true ].  ^aSelectionOrItem isBasedOnItemType: targetItemTypemethods  ^methodQuery execute itemsaffectsMethodsDefinedInPackage: aPackage  overriddenSuperclass withAllSubclassesDo: [:each |  each package = aPackage ifTrue: [ ^true ] ].  ^falsetestConvertingToFullHierarchyScope  | convertedScope inheritedScope |  scope := self createSampleScope.  inheritedScope := scope asInheritedScope.  convertedScope := scope asFullHierarchyScope.  self assert: convertedScope class equals: ClyCompositeScope.  self assert: convertedScope name equals: ClyClassScope hierarchyScopeName.  self assert: (convertedScope subscopes includes: scope).  self assert: (convertedScope subscopes includes: inheritedScope).  self assert: (convertedScope subscopes includes: (ClySubclassScope ofAll: scope basisObjects localScope: scope class))kmDispatcher  ^CmdKMDispatcher attachedTo: selftestRan: aTestSuiteEnded  | event runTestCase testedClass |  runTestCase := aTestSuiteEnded testResult.  testedClass := self findTestedClassCoveredBy: runTestCase ifAbsent: [ ^self ].  event := ClyTestCaseRan testCase: testedClass.  environment systemChanged: eventnewWindowTitle  | newTitle |  packageView selection isEmpty ifTrue: [ ^self systemScope description ].  newTitle := self buildTitleFromSelections.  self systemScope isCurrentImage ifFalse: [ newTitle := newTitle , ' in ' , self systemScope description ].  ^newTitledescription  ^'implementors of ' , self printSelectorsleftSideBar  ^textMorph rulerNamed: #textSegmentIconsupdate  label color: label defaultColor.  label contents: self printMethodTagsOrPackage.  self isExtensionActive ifTrue: [ editButton helpText: 'Choose package for method' ] ifFalse: [ editButton helpText: 'Classify method' ]doesItemHaveChildren: aDataSourceItem  | childQuery |  aDataSourceItem childrenDataSource ifNotNil: [:children |  ^children isEmpty not ].  self definesChildren ifFalse: [ ^false ].  childQuery := queryView queryToExpand: aDataSourceItem ifAbsent: [ ^false ].  ^aDataSourceItem browserItem hasChildrenWhich: [:childType |  childQuery retrievesItemsOfType: childType ]async  ^selfsetUpEnvironment  super setUpEnvironment.  environment system: ClySystemEnvironment currentImagetestNotSelectsMethodWithoutCritiques  self deny: (query selectsMethod: ClyClassWithProblemMethods >> #methodWithoutCritiques)collectMetadata  metadata := ClyQueryResultMetadata new.  environment pluginsDo: [:each |  buildingQuery collectMetadataOf: self by: each ]itemsStartingAt: startIndex count: size  ^self prepareItems: (actualResult itemsStartingAt: startIndex count: size)requiredResult  ^requiredResulteditingPackage: anObject  editingPackage := anObjectprepareInitialState  self subclassResponsibilitytestFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #writer1OfVar1) .         (self class >> #readerOfVar1)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #writer1OfVar1testFillingSimpleInstance  query := ClyAllClassesQuery from: ClyPackageScope of: ClyClass1FromP1 package in: environment.  queryResult := ClyExtensionLastSortedClasses simple prepareNewFor: query in: environment.  queryResult buildWith: {ClySubclassLOfClass0FromPExtendedByP1 .         ClySubclassN1OfClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassN1OfClass1FromP1 .         0 .         ClySubclassLOfClass0FromPExtendedByP1 .         0}.  self assert: (items last isMarkedWith: ClyExtendedClassTag).  self deny: (items first isMarkedWith: ClyExtendedClassTag).  self deny: (items second isMarkedWith: ClyExtendedClassTag)affectsCritiques  ^falseresolveMetadataOfCritiques: aClySortedCritiques  withScope: aTypedScope  | newSubqueries |  newSubqueries := subqueries collect: [:each |  each withScope: aTypedScope ].  ^self withSubqueries: newSubqueriesdescription  ^'all packages'testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(reference1OfVar1 reference2OfVar1 #supeclassReferenceOfVar1)executeRedoBy: aBlock  redoExecuting := true.  aBlock ensure: [ redoExecuting := false.        waitingNewState := true ]compileANewClassFrom: aString notifying: aController startingFrom: aClass  | importer |  importer := RGChunkImporter new.  importer environment: self environment.  importer fileInFrom: (aString , '!') readStream.  ^aClassdefaultMenuItemName  ^'Move to method group'changesAreAboutApply  selectedClassGroups  ^self selectedObjectsinitialize  super initialize.  self     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWraprepresentsScope: aScopeClass  ^subscopes anySatisfy: [:each |  each representsScope: aScopeClass ]testComparisonOfSameQueriesWithDifferentRequestedContent  | query2 |  query requiredResult: #contentClass1.  query2 := self createQuery.  query2 requiredResult: #contentClass2.  self deny: query equals: query2isClassSelected  | node |  node := self selectedSourceNode.  node isVariable ifFalse: [ ^false ].  ^node binding isLiteralVariable and: [ node binding isGlobalClassNameBinding ]fillWith: queriedObjects  self subclassResponsibilitytestFindTestedClassCoveredByTestCase  | foundClass |  foundClass := plugin findTestedClassCoveredBy: ClyTestedClassTest ifAbsent: [  ].  self assert: foundClass equals: ClyTestedClassclassVariablesOf: definingClass do: aBlock  definingClass instanceSide classVariables associationsDo: [:var |  aBlock value: (ClyClassVariable on: var definedIn: definingClass instanceSide) ]actualObjectSortFunction  ^actualObjectSortFunctiondefaultMenuItemName  ^'Remove'isRedundant  extraClassScope asInterestingClassScope classesDo: [:each |  ^false ].  ^truebuild  self buildResetButton.  self addMorphBack: resetButton.  self buildEditButton.  self addMorphBack: editButton.  self buildLabel.  self addMorphBack: label.  self buildExtensionCheckBoxButton.  self addMorphBack: extensionCheckbox.  self updateclyMessageImplementor1  classAffected  ^testCasetestIsAffectedByChangeOfOwnMethodWhichIsNotOverridden  self assert: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)hash  ^super hash bitXor: localScopeClass hashtoggle  Slot showSlotClassDefinition: Slot showSlotClassDefinition not.  ownerTool updatebrowser  ^tool browserbindingOf: aString  ^self selectedClassOrMetaClass bindingOf: aStringhasSubscriber: anObject  announcer ifNil: [ ^false ].  ^announcer hasSubscriber: anObjecthasUnacceptedEdits  textMorph ifNil: [ ^false ].  ^textMorph hasUnacceptedEditstestForClassVariable  | classVar |  classVar := ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1.  query := ClyVariableReferencesQuery of: classVar.  self queryFromScope: ClyClassScope of: ClyClass2FromP1.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(instanceSideClassVar1Reader instanceSideClassVar1Writer)defaultMenuItemName  ^'Debug the exception'testMatchesMethodOfPackageWhichMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'SystemQueries-Tests'.  self assert: (filter matches: self itemOfThisTestMethod)standardMessageText  ^String streamContents: [:stream |  stream print: self baseClass.        stream nextPutAll: ' is not a valid class to generate a test class' ]testNotSelectsMethodOnWhichItIsBased  self deny: (query selectsMethod: Point >> #x)newSelectionWith: dataSourceItems  ^self dataSource newSelectionWith: dataSourceItemsinitialize  super initialize.  badScript := falsesetUpModelFromContext  super setUpModelFromContext.  editingMethod := context lastSelectedMethodrootDataSource: anObject  rootDataSource := anObjectdecorateBrowserItem: anItem ofMethod: aMethod  aMethod isDeprecated ifTrue: [ anItem markWith: ClyDeprecatedItemTag ]initialize  super initialize.  extraMethods := IdentitySet newhierarchy: anObject  hierarchy := anObjecttestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWhichInheritsAbstractClass >> #abstractMethod1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWhichInheritsAbstractClass >> #overriddenMethod in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod in: environment).  self assert: query checkEmptyResultdescription  ^'class variables'isCurrentImage  ^falsemethods  ^methodshandleSystemChange: aSystemAnnouncement  needsRebuild ifTrue: [ ^self ].  aSystemAnnouncement shouldBeConsideredByCalypsoEnvironment ifFalse: [ ^self ].  self protectAccessWhile: [ (buildingQuery isResult: self affectedBy: aSystemAnnouncement) ifTrue: [ self itemsChanged ] ]metadata: anObject  metadata := anObjectapplyTo: aBrowser byUndo: undoExecuting  (window isInWorld and: [ (browserState isCurrentStateOf: window model) not ]) ifTrue: [ ^self ].  navigationHistory recordAcrossWindowNavigationFrom: aBrowser byUndo: undoExecuting.  undoExecuting ifTrue: [ aBrowser close ].  self restoreBrowserWindow.  window model focusActiveTabcollectMetadata  self protectAccessWhile: [ metadata ifNotNil: [ ^self ].        metadata := ClyQueryResultMetadata new.        environment pluginsDo: [:each |  buildingQuery collectMetadataOf: self by: each ] ]menuColumn: column row: rowIndex  | menuSelection context |  menuSelection := self grabSelectionAt: rowIndex.  context := self createSelectionContextOf: menuSelection.  ^CmdContextMenuActivation buildContextMenuFor: self inContext: contextcreateClassGroupFor: aClassQuery from: aPackageScope  ^ClyNoTagClassGroup named: 'Uncategorized' priority: 100 on: aClassQueryinitialize  super initialize.  navigationStarted := false.  navigationHistory := ClyNavigationHistory new.  plugins := SortedCollection sortBlock: [:a :b |  a priority <= b priority ].  self extent: self initialExtent.  self changeProportionalLayout.  self initializeToolsPanel.  self initializeNavigationPanel.  self addPaneSplitterstestRetrievesSystemScope  self snapshotState.  self assert: navigationState systemScope equals: environment systemScoperestoreNavigationStateOf: aBrowser  aBrowser navigationViews with: viewStates do: [:view :state |  view ignoreNavigationDuring: [ state applyTo: view ] ]async  ^selfprintCursorPosition  | result textArea |  textArea := self textArea.  textArea selectionStart ifNil: [ ^'' ].  textArea paragraph lines ifNil: [ ^'' ].  result := self printTextLinePositionOf: textArea selectionStart.  textArea selectionStop ~= textArea selectionStart ifTrue: [ result := result , ' -- ' , (self printTextLinePositionOf: textArea selectionStop) ].  ^resultbuildResult: aQueryResult  | allCritiques filtered |  allCritiques := baseCritiqueQuery execute.  filtered := allCritiques items select: [:each |  self selectsCritique: each ].  aQueryResult fillWith: filteredcreateQuery  ^ClyMessageSendersQuery of: self referencedSelector from: (ClyClassScope of: Object in: environment)protectAccessWhile: aBlock  ^accessGuard critical: [ aBlock value ]selectsMethod: aMethod  self subclassResponsibilitytestFillingWithClassWithoutTraits  queryResult fillWith: {ClyClassWithoutTraits}.  self assertItems: {ClyClassWithoutTraits .         0}testConvertingWithExtraBasisObjectWhenThereIsExtraScopeParameter  | convertedScope |  scope := self singleScopeSample.  scope extraParameter: #testParameter.  convertedScope := scope withExtraBasisObject: self extraBasisSample.  self assert: convertedScope extraParameter equals: #testParameterrepresentsObjectEqualTo: anObject  actualObject == anObject ifTrue: [ ^true ].  type = anObject calypsoEnvironmentType ifFalse: [ ^false ].  ^type checkCalypsoItem: actualObject isEqualTo: anObjecteditingText  ^self classTemplatemetaLevelsOf: aClass do: aBlock  localScopeClass metaLevelsOf: aClass do: aBlockleftMethod  ^leftMethodbrowser  ^browserfindItemsWith: actualObjects  | result |  ^actualResult protectItemsWhile: [ result := actualObjects collect: [:eachObject |  actualResult items detect: [:item |  item representsObjectEqualTo: eachObject ] ifNone: nil ].        self prepareItems: result ]isResult: aQueryResult affectedBy: aSystemAnnouncement  self flag: #todo.  ^falseretrieveStateFrom: aBrowser  systemScope := aBrowser systemScope.  viewStates := aBrowser navigationViews collect: [:each |  each snapshotState ].  selectedTabs := aBrowser tabManager selectedTools collect: [:each |  each copyForBrowserStateSnapshot ]asInterestingClassScope  | newSubscopes |  newSubscopes := subscopes collect: [:each |  each asInterestingClassScope ].  ^ClyCompositeScope on: newSubscopes in: environment named: nameautoSelect: anObject  autoSelect := anObjectallNavigationScopes  | defaultScope |  defaultScope := self defaultNavigationScope.  ^self systemScope = defaultScope ifTrue: [ {self systemScope} ] ifFalse: [ {self systemScope .         defaultScope} ]properties: anObject  properties := anObjectrebuildToolsForChangedEnvironment  super rebuildToolsForChangedEnvironment.  tabManager tools ifEmpty: [ resultView ensureSelectedItem.        self rebuildAllTools ].  self updateWindowTitlemethodGroupQuery  ^methodGroupQueryisMethodSelected  ^self selectedMethodItems notEmptytoggleExtension  self requestChangeBy: [ self isExtensionActive ifTrue: [ self requestTag ] ifFalse: [ self requestPackage ] ]selectedClassOrMetaClass  ^editingClassbrowserState  ^browserStatedefaultMenuIconName  ^#haloViewwithTool: aToolClass do: aBlock  | tool |  tool := tools detect: [:each |  each isKindOf: aToolClass ].  ^tool whenReadyDo: aBlockinverse: aBoolean  inverse := aBooleanisProtected  ^accessGuard notNilisMethodSelected  ^self selectedSourceNode isMethoddecorateOwnBrowserItem: myItem  super decorateOwnBrowserItem: myItem.  self asyncQueryResult isBuilt ifFalse: [ myItem markWith: ClyBackgroundProcessingTag ]navigationEnvironment  ^navigationEnvironmentremoveWithMethods  super removeWithMethods.  methodQuery scope classesDo: [:each |  each removeMethodTag: self tag ]affectedClass: anObject  affectedClass := anObjecttestMethodsEnumerationWhenBasisIsMetaclass  | expected |  scope := ClyInstanceSideScope of: ClyClass1FromP1 classSide.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArraytestCreationOnMultipleScopeOfSameBasis  | queryClass |  queryClass := query class.  query := queryClass fromAll: {ClyScopeExample .         ClyScopeExample2} of: Array in: environment.  self assert: query class equals: ClyUnionQuery.  self assert: query subqueries equals: {(queryClass from: ClyScopeExample of: Array in: environment) .         (queryClass from: ClyScopeExample2 of: Array in: environment)} asSetunsubscribe: anObject  actualResult unsubscribe: anObjecttype  ^browserItem typehasProperty: propertyClass  ^properties anySatisfy: [:each |  each isKindOf: propertyClass ]description  ^'overriding methods'newTestClassCategoryFor: aClass  | tag |  tag := aClass package classTagForClass: aClass.  ^String streamContents: [:s |  s           nextPutAll: aClass package name;           nextPutAll: '-Tests'.        tag isRoot ifFalse: [ s                 nextPut: $-;                 nextPutAll: tag name ] ]containerForItemsSortedByName  ^SortedCollection sortBlock: #name ascendingsetUpModelFromContext  testClass := context lastSelectedClasscreateVariableRefactoring: variableRefactoringClass  ^self createRefactoring: variableRefactoringClass for: definingClassfileOut  self inform: 'not supported yet'defaultMenuItemName  ^'Set up scope'hasRealQuery  ^self query ~~ ClyUnknownQuery instanceisDirty  ^dirtyhideCritiques  criticView delete.  browserTool removePaneSplitters.  originalToolPanel layoutFrame     bottomFraction: 1;     bottomOffset: 0isQueryEmpty: aQuery  ^trueclassSampleWhichHasGroup  ^ClyClassWithProblemMethodsscopeClass  ^ClyMultipleClassRelationScopedefaultMenuItemName  ^'Update'restrictedByScope: aScope  self subclassResponsibilitycreateTextContext  ^ClyTextEditorContext for: selfrefreshAsyncState  (self findA: ClyActivityAnimationIconMorph) ifNotNil: #delete.  self areItemsLoaded ifFalse: [ self addMorph: (ClyActivityAnimationIconMorph label: 'loading items') ]isClassTagSelected  ^falsebrowserClass  ^browserClassdescription  ^'go forward in the navigation history'needsRebuild  ^needsRebuilditemFilter  ^itemFiltercreateQuery  ^ClyAsyncQuery for: (ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: self class in: environment)messages: anObject  messages := anObjectisFilterChanged  table initialDataSource ifNil: [ ^false ].  ^selection rootDataSource ~~ self dataSourcecopyForBrowserStateSnapshot  ^self shallowCopy     resetStateForSnapshot;     yourselfsupportsQuery: aQuery  ^aQuery isKindOf: ClyCompositeQueryaddExtraTool: aMorph  extraToolMorphs ifNil: [ extraToolMorphs := OrderedCollection new ].  extraToolMorphs add: aMorph.  ^aMorphcreateQuery  ^ClyAllInstanceVariablesQuery from: ClyClassScope of: ClyClass2FromP1 in: environmentbrowser: anObject  browser := anObjecttestCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #reference1OfClass in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #referenceOfAnotherClass in: environment).  self assert: query checkEmptyResulttestCreationSimpleInstance  queryResult := ClyExtensionLastSortedClasses simple.  self assert: queryResult baseQueryResult class equals: ClySortedQueryResulttestCreatesBrowserWithPlugins  browser addPlugin: ClyStandardBrowserPlugin new.  self restoreBrowserInstance.  self assert: browser plugins first browser equals: browser.  self assert: browser plugins first class equals: ClyStandardBrowserPlugin.  self deny: navigationState browserPlugins first identicalTo: browser plugins firstcreateTextContext  ^self selectedSourceNode ifNil: [ super createTextContext ] ifNotNil: [:astNode |  ClySourceCodeContext for: self selectedNode: astNode ]testGettingSingletonInstanceFromScratch  ClyUnknownScope reset.  self assert: ClyUnknownScope instance identicalTo: ClyUnknownScope instancebrowser  ^browserTool browserconvertToMethodTag: aTagName  self renameMethodTagTo: aTagNametestFromSinglePackage  self queryFromScope: ClyPackageScope of: ClyClass7WithTag1FromP5 package.  self assert: (resultItems collect: #class as: Set) equals: {ClyNoTagClassGroup .         ClyTaggedClassGroup .         ClyClassGroup} asSet.  self assert: (resultItems select: [:each |  each class = ClyTaggedClassGroup ] thenCollect: #tag) asSet equals: ClyClass7WithTag1FromP5 package tagsForClasses asSetprocessClassRemoval: aClassRemoved  environment systemChanged: (ClyOverriddenSuperclassesChanged overridingSubclass: aClassRemoved classAffected)selectedClassTags  ^selectedItems select: [:each |  each type isBasedOnClassTag ] thenCollect: [:each |  each name ]methodWithHalt  < haltOrBreakpointForTesting>  self haltisRedundant  extraClassScope classesDo: [:each |  ^false ].  ^truedecorateResultMethodEditor: aMethodEditor  | vars |  vars := variableQuery execute items.  aMethodEditor selectAnyVariable: (vars collect: [:each |  each name ])createInheritanceScopeFrom: classes  | classScope |  classScope := ClyClassScope ofAll: classes in: browser navigationEnvironment.  ^classScope asFullHierarchyScopemethodWithWatchpoint  ^1 + 2browseFullClass  self evaluateSelectionAndDo: [:result |  self browser browseClassNamed: result class instanceSide name ]newDataSourceMatching: anItemFilter  lastFilteredDataSource ifNotNil: [ lastFilteredDataSource close ].  self isClosed ifTrue: [ Processor activeProcess == UIManager default uiProcess ifTrue: [ self error: 'Should not happens' ].        ^Processor terminateActive ].  lastFilteredDataSource := self class on: (query filteredBy: anItemFilter).  lastFilteredDataSource openOn: queryView.  ^lastFilteredDataSourcedefinesChildren  ^truevariablesDo: aBlock  self classesDo: [:eachClass |  self classVariablesOf: eachClass do: aBlock.        self instanceVariablesOf: eachClass do: aBlock ]createQuery  ^ClyExpectedFailedTestMethodsQuery from: ClyClassScope of: ClyTestedClassTest in: environmentsystem  ^environment systemmethodsDo: aBlock  self classesDo: [:class |  class instanceSide localMethods do: aBlock.        class classSide localMethods do: aBlock ]defaultMenuItemName  ^'Unclassify method'defaultIconName  ^(context lastSelectedItem isMarkedWith: ClyNoCommentTag) ifTrue: [ #uncommentedClass ] ifFalse: [ #commentsIcon ]findTestMethodCovering: aMethod ifAbsent: aBlock  | selectorString testCase |  aMethod isTestMethod ifTrue: [ ^aBlock value ].  testCase := self findTestCaseCovering: aMethod methodClass ifAbsent: [ ^aBlock value ].  selectorString := 'test' , (self normalizeSelectorForComparison: aMethod selector).  ^testCase methods detect: [:each |  (self normalizeSelectorForComparison: each selector) = selectorString ] ifNone: aBlocknoTagMethod  tearDown  installedWatchpoints do: [:each |  each uninstall ].  installedWatchpoints removeAll.  super tearDownbuildWithFullIndentation  | expansionButton |  self addBarForFullIndentation.  item supportsExpansion ifTrue: [ expansionButton := self currentExpansionButton.        self addMorphBack: expansionButton ].  definitionMorph ifNotNil: [ definitionMorph width: 16.        self addMorphBack: definitionMorph ].  self addMorphBack: label.  extraToolMorphs ifNotNil: [ extraToolMorphs do: [:each |  each width: 16.              self addMorphBack: each ] ]systemScope: anObject  systemScope := anObjectselectsClass: aClass  ^truetestExecution  query subqueries: {(self subqueryFromScope: ClyScopeExample of: self class) .         (self subqueryFromScope: ClyScopeExample2 of: self class superclass)}.  self executeQuery.  self assert: resultItems size equals: 2.  self assert: resultItems asSet equals: {self class .         self class superclass} asSet= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^package = anObject packagecheckEmptyResult  scope instanceVariablesDo: [:each |  ^false ].  ^truetestClassEnumeration  scope := ClyClassScope ofAll: {ClyClass1FromP1 .         ClyClass2FromP1}.  scope classesDo: [:each |  result add: each ].  self assert: result asArray equals: {ClyClass1FromP1 .         ClyClass2FromP1}runTestItem: testItem  | testSelector |  testSelector := self testSelectorOf: testItem.  (self targetTestCasesFor: testItem) do: [:each |  self runTest: testSelector of: each ]realElementAt: anIndex  ^(self elementAt: anIndex) browserItemtargetItemType  ^targetItemTypesystem: anObject  system := anObjectcritiqueQuery  ^critiqueQueryviewStates: anObject  viewStates := anObjectselectsMethod: aMethod  | result |  (super selectsMethod: aMethod) ifTrue: [ ^true ].  criteriaBlock ifNil: [ ^false ].  extraMethods removeAllSuchThat: [:each |  each calypsoEnvironmentType checkCalypsoItem: each isEqualTo: aMethod ].  result := criteriaBlock value: aMethod.  result ifTrue: [ extraMethods add: aMethod ].  ^resultactivator: aCommandActivator  activator := aCommandActivator.  self buildcurrentMetaLevelOf: aClass  ^metaLevelScope metaLevelOf: aClassmodifiesExtension  ^editingMethod isExtension ifTrue: [ extendingPackage ~~ editingMethod package ] ifFalse: [ extendingPackage notNil and: [ extendingPackage ~~ self methodClass package ] ]execute  | browserClass |  browserClass := #IceTipExtendedVersionBrowser asClassInEnvironment: self class environment ifAbsent: [ #IceExtendedVersionBrowser asClass ].  (browserClass repository: repository method: method) openforceFullUpdate  super forceFullUpdate.  expandedItems do: [:each |  each childrenDataSource forceFullUpdate ]prepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browsericon: anObject  icon := anObjectmetaLevelScope  ^ClyInstanceSideScopesubqueries  ^subqueriestable  ^tableshortName  ^'Methods'buildWithLabelIndentation  | expansionButton |  item supportsExpansion ifTrue: [ expansionButton := self currentExpansionButton.        self addMorphBack: expansionButton ].  definitionMorph ifNotNil: [ definitionMorph width: 16.        self addMorphBack: definitionMorph ].  self addBarForLabelIndentation.  self addMorphBack: label.  extraToolMorphs ifNotNil: [ extraToolMorphs do: [:each |  each width: 16.              self addMorphBack: each ] ]testRetrievesActiveScope  self snapshotState.  self assert: navigationState activeScope equals: browser activeScopecollapse  ownerDataSource collapse: selftestSelectsClassWithoutTags  self assert: (query selectsClass: ClyClass6UntaggedFromP5)testIsExecutedFromSingleScopeWhenSingleSubqueryIsBasedOnIt  query subqueries: {(self subqueryFromScopeOf: self class)}.  self assert: query isExecutedFromSingleScopetestUsingUncompiledScript  filter := ClyQueryBrowserFilter substringPattern: '[:each | each 123selector]'.  self assert: (filter matches: self itemOfThisTestMethod).  self assert: (filter matches: (ClyBrowserItem with: Object >> #printString))setWindowTitle: aString in: aWindow  | emphasis |  super setWindowTitle: aString in: aWindow.  aWindow basicLabel ifNotNil: [:label |  emphasis := metaLevelScope = ClyInstanceSideScope ifTrue: [ TextEmphasis normal ] ifFalse: [ TextEmphasis bold ].        label emphasis: emphasis emphasisCode ]method1WithUndeclares  ^undeclaredStubInstVar1 printStringconfirmDiscardChanges  ^self confirm: 'Changes have not been saved.Is it OK to discard changes?'requestChangeBy: aBlock  aBlock on: CmdCommandAborted do: [:err |   ].  self updateabstractMethod1  selection  ^selectionisCurrentImage  ^self system == ClySystemEnvironment currentImagebrowser: anObject  browser := anObject= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^baseQueryResult = anObject baseQueryResultdescription  ^'all class groups'testComparisonWithAnotherHierarchy  | queryResult2 |  queryResult2 := self createQueryResult.  queryResult2 hierarchy: queryResult hierarchy inverted.  self deny: queryResult equals: queryResult2createQuery  ^ClyQueryExampleReturningScopeBasis from: (ClyScopeExample emptyIn: environment)depth: anObject  depth := anObjectrestoreDesiredSelectionWith: newDataSourceItems silently: aBool  items := newDataSourceItems.  self restoreTableSelectionSilently: aBool.  aBool ifFalse: [ self ensureVisibleLastItem ]switchToMethodGroups  self changeMethodGroupQueryBy: [ ClyAllMethodGroupsQuery sortedFrom: self classScopeForMethods ]testCreationFromTwoQueriesOfSameTypeButDifferentScope  | subquery1 subquery2 |  subquery1 := self subqueryFromScope: ClyScopeExample of: Array.  subquery2 := self subqueryFromScope: ClyScopeExample2 of: String.  query := subquery1 , subquery2.  self assert: query class equals: self queryClass.  self assert: query subqueries asSet equals: {subquery1 .         subquery2} asSet.  self assert: query requiredResult identicalTo: subquery1 requiredResultwithMetaLevel: aScopeClass  ^self copy localScopeClass: aScopeClassdefaultMenuItemName  ^'go backward'decorateBy: anEnvironmentPlugin  type decorateBrowserItem: self by: anEnvironmentPluginvariableQuery  ^variableQuerymessageImplementor2  testNotEmptyWhenThereIsNotEmptySubquery  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 of: self class superclass)}.  self deny: query checkEmptyResultdecorateTableCell: anItemCellMorph of: groupItem  super decorateTableCell: anItemCellMorph of: groupItem.  anItemCellMorph definitionIcon: #protocolExtensionIcon.  (anItemCellMorph browser isPackagePartOfSelection: self package) ifTrue: [ anItemCellMorph label emphasis: TextEmphasis bold emphasisCode ] ifFalse: [ anItemCellMorph label color: Smalltalk ui theme classExtensionColor ]globals: anObject  globals := anObjectfillWithGroupedVariables: varsPerTypeAndDefiningClass  self addInheritedMethodGroup.  varsPerTypeAndDefiningClass at: ClyClassVariable ifPresent: [:classVarsPerClass |  self addClassVariableGroup ].  varsPerTypeAndDefiningClass at: ClyInstanceVariable ifPresent: [:instVarsPerClass |  self fillWithVariables: instVarsPerClass type: ClyInstanceVariable ]isBoundToEnvironment  ^scope isBoundToEnvironmentgtDisplayOn: stream  stream << self browser newWindowTitlecontainerTab: anObject  containerTab := anObjectorder  ^1itemCount  ^0analyzedObjectsDo: aBlock  self subclassResponsibilitycreateMethodGroup  self subclassResponsibilityrunTest: testSelector of: testClass  | breakpoint |  breakpoint := Breakpoint new     node: (testClass lookupSelector: testSelector) ast;     install.  [ super runTest: testSelector of: testClass ] ensure: [ breakpoint remove ]tooltipText  ^'Expand me to toggle method visibility of concrete class.Use checkbox at the right of label to make all inherited methods visible in browser (it skips Object methods). Select me to see all inherited methods which are not overriden by selected class'buildEditButton  editButton := IconicButton new     target: self;     actionSelector: #openEditor;     arguments: #();     labelGraphic: (self iconNamed: #edit);     color: Color transparent;     borderWidth: 0decorateItemGroup: groupItem  hash  ^itemType hashselectedSourceNode  | selectedInterval definitionNode |  selectedInterval := self selectedTextInterval.  definitionNode := self parseClassDefinition.  ^(definitionNode bestNodeFor: selectedInterval) ifNil: [ definitionNode ]untestedTwo  ^self twohash  ^pattern hashnewPackageView  | newPackageView |  newPackageView := self newNavigationView     treeStructure: {(ClyProjectChildItem -> #prepareProjectItemsQueryFrom:in:) .         (RPackage -> #prepareClassGroupQueryFrom:in:)};     enableFilterUsing: ClyRegexPattern new;     requestNavigationBy: #packageSelectionChanged.  newPackageView filterField announcer when: RubTextChanged send: #updateDefaultPackageFilter to: self.  ^newPackageViewreferenceOfAnotherVar  ^var2name  ^'Query'printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  aStream nextPutAll: iconName.  aStream nextPut: $)testFillingWithTwoSameClasses  queryResult fillWith: {ClyClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0}focusActiveTab  | activeTab |  activeTab := self selectedTools detectMax: [:each |  self activationPriorityOf: each ].  activeTab ifNotNil: [ activeTab takeKeyboardFocus ]handleSystemChange: aSystemAnnouncement  | todoList todoSize anyResult |  todoList := (queryCache values select: [:each |  each notNil ]) as: IdentitySet.  todoSize := 0.  [ [ todoSize = todoList size ] whileFalse: [ todoSize := todoList size.        todoList asArray do: [:eachResult |  (todoList includes: eachResult) ifTrue: [ eachResult handleSystemChange: aSystemAnnouncement byProcessingList: todoList ] ] ].  todoList notEmpty ] whileTrue: [ anyResult := todoList anyOne.        anyResult handleSystemChange: aSystemAnnouncement.        todoList remove: anyResult ]describes: aBrowserDialog  ^(aBrowserDialog isKindOf: dialogClass) and: [ aBrowserDialog browser isKindOf: browserClass ]simpleNameForSpotterMenu  ^self class namebuildResult: aQueryResult  | packages classPackage |  packages := IdentitySet new.  scope methodsDo: [:eachMethod |  classPackage := eachMethod origin package.        (eachMethod isDefinedInPackage: classPackage) ifFalse: [ eachMethod package ifNotNil: [:p |  packages add: p ] ] ].  aQueryResult fillWith: packageseditingText  ^editingPackage packageManifestOrNil ifNil: [ self packageCommentBlank ] ifNotNil: [:manifest |  manifest hasComment ifTrue: [ manifest comment ] ifFalse: [ self packageCommentBlank ] ]beEmpty  self selectItems: {}buildLeftSideBar  textMorph withTextSegmentIconshash  ^definingClass hash bitXor: actualVariable hashdefaultMenuIcon  ^Smalltalk ui iconNamed: #smallDebugswitchToHierarchicalResult  DefaultQueryResult := ClyHierarchicalSystemItems new.  self switchResultTo: DefaultQueryResultselectedClasses  ^{self selectedClass}testNotSelectsClassSideMethodWhichReturnesFloat  self deny: (query selectsMethod: ClyClassWithUndeclares class >> #withFloatReturn)reader2OfVar1  ^readVar1hash  ^methodQuery hash bitXor: subgroupsQuery hashignoreNavigationDuring: aBlock  aBlock valuecommandListProcessorForContext: aContext step: aStep  aStep listProcessor     order: 20;     title: aContext simpleNameForSpotterMenu;     allCandidates: [ self collectCommandCandidatesInContext: aContext ];     itemName: #menuItemName;     itemIcon: #menuItemIcon;     candidatesLimit: 5;     filter: GTFilterSubstring;     actLogic: [:activator :step |  step exit.        activator executeCommand ]classSampleWhichHasGroup  ^ClyClassWhichInheritsAbstractClasssubscribe: anObject  self subscribe: anObject for: SystemAnnouncementtestRepresentsClassOfScope  scope := self createSampleScope.  self assert: (scope representsScope: self scopeClass).  self assert: (scope representsScope: ClyTypedScope).  self deny: (scope representsScope: ClyCompositeScope)= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^direction = anObject directiontestIsBoundToEnvironmentWhenScopeIs  < expectedFailure>  super testIsBoundToEnvironmentWhenScopeIshash  ^super hash bitXor: critiqueQuery hashfindItemsWith: actualObjects  | found result foundIndex |  actualResult protectItemsWhile: [ result := actualObjects collect: [:eachObject |  foundIndex := actualResult items findFirst: [:item |  item calypsoEnvironmentType checkCalypsoItem: item isEqualTo: eachObject ].              foundIndex > 0 ifTrue: [ found := (actualResult itemAt: foundIndex) asCalypsoBrowserItem.                    found position: foundIndex.                    found prepareIn: self environment.                    found ] ifFalse: [ nil ] ].        ^result ]includesItemsOf: itemTypeClass  ^items anySatisfy: [:each |  each isBasedOnItemType: itemTypeClass ]description  ^'deprecated methods'testFillingWithClassInsteadOfTrait  queryResult fillWith: {ClyClassWithoutTraits}.  self assertItems: {ClyClassWithoutTraits .         0}userRequestString  ^'Remove, then browse senders'simpleNameForSpotterMenu  ^'Method editor: ' , super simpleNameForSpotterMenutestHasRequiredResultByDefault  self assert: query requiredResult notNilsetUpTargetClasses  targetClasses := browser chooseClassesForNewMethod: editingMethodrelationScopeClasses: anObject  relationScopeClasses := anObjectlabel  | label |  label := ownerTool extendingPackage ifNil: [ 'extension' ] ifNotNil: [:package |  package name ].  ownerTool modifiesExtension ifTrue: [ label := '*' , label ].  ^labelimportMethod: aMethod  super importMethod: aMethod.  self package addMethod: aMethod.  aMethod tagWith: ('*' , self package name) asSymbolmethodSelection  ^methodView selectionpackagesDo: aBlock  basisObjects do: aBlockadoptQuery: aQuery  | subqueries result |  subqueries := subscopes collect: [:each |  aQuery withScope: each ].  result := ClyQuery unionFrom: subqueries.  result scope name: name.  ^resultchooseClassForEditorOfMethod: aMethod  ^aMethod origintestFromTwoMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithFlags >> #methodWithFlag) .         (ClyClassWithFlags >> #methodWithoutFlag)}.  self assert: foundSelectors sorted asArray equals: #(methodWithFlag)updateToolsBy: aBlock  updatingStarted := true.  aBlock ensure: [ updatingStarted := false ]isClassSelected  ^self hasSelectedItemssupportsCriticDecoration  ^truesizeLimit: anObject  sizeLimit := anObjectlittleHierarchyMaxSize  ^littleHierarchyMaxSizecurrentItem  ^cache itemAt: positionsimpleNameForSpotterMenu  ^'Comment editor: ' , editingPackage namecreateCommandContext  ^self createSelectionContextisAsync  ^trueincludesActualObject: anObject  ^self browserItem includesActualObject: anObjectasGlobalScopeIn: aNavigationEnvironment  ^ClySystemEnvironmentScope of: self in: aNavigationEnvironment named: namenotifyUserAboutResults: testResult with: message  | color |  color := Color gray.  testResult hasPassed ifTrue: [ color := Color green ].  testResult hasFailures ifTrue: [ color := Color yellow ].  testResult hasErrors ifTrue: [ color := Color red ].  GrowlMorph openWithLabel: message contents: testResult printString backgroundColor: color labelColor: Color blackbuild  checkbox := CheckboxMorph on: self selected: #usesSlotBasedDefinition changeSelected: #toggle.  checkbox     getLabelSelector: #definitionTypeLabel;     labelClickable: true;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     setBalloonText: 'You can switch between old and new class definition. New definition is based on slots'.  self addMorph: checkboxaffectsMethod: aMethod  ^aMethod selector = self overriddenMethod selector and: [ aMethod origin inheritsFrom: self overriddenMethod origin ]hierarchy: anObject  hierarchy := anObjectinstanceSideClassVar1Reader  ^ClassVar1testMethodsEnumeration  scope := ClySubclassScope of: ClyClass1FromP1.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyClass1FromP1 subclasses first localMethods).  self deny: (result includesAll: ClyClass1FromP1 subclasses first classSide localMethods).  self assert: (result includesAll: ClyClass1FromP1 subclasses second localMethods).  self deny: (result includesAll: ClyClass1FromP1 subclasses second classSide localMethods).  self deny: (result includesAll: ClyClass1FromP1 localMethods).  self deny: (result includesAll: ClyClass1FromP1 classSide localMethods).  self deny: (result includesAll: ClyClass1FromP1 superclass localMethods).  self deny: (result includesAll: ClyClass1FromP1 superclass classSide localMethods)systemScope  ^systemScopedescription  ^String streamContents: [:s |  self printExtraInfoOn: s ]collectMethodGroupProviders  ^{ClyFlagMethodGroupProvider new}sendersOfIt  | selector |  (selector := self selectedSelector) == nil ifTrue: [ ^textArea flash ].  self sendersOf: selectortestComparisonWithSimilarScope  | scope2 |  scope := self createSampleScope.  scope2 := self createSampleScope.  self assert: scope equals: scope2.  self assert: scope hash equals: scope2 hashselectedMessages  ^{self selectedMessage}setUpModelFromContext  leftMethod := context firstSelectedMethod.  rightMethod := context lastSelectedMethodselectedPackageItems  ^self selectedItemsOfType: RPackageprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browser.  systemEnvironment := aToolContext systemEnvironmentsetUpTargetClasses  targetClasses := browser chooseClassesForNewMethod.  (targetClasses includes: methodClass) ifFalse: [ targetClasses := {methodClass} , targetClasses ]wantsTextStyling  ^falseaccumulateFailures: failures andErrors: errors  allCount := allCount + failures + errors.  failureCount := failureCount + failures.  errorCount := errorCount + errorstoolWasRemoved  criticView ifNotNil: [ criticView closeDataSource ]currentExpansionButton  item hasChildren ifFalse: [ ^FTTreeDataSource emptyMorph ].  ^item isExpanded ifTrue: [ self expandedButton ] ifFalse: [ self collapsedButton ]createBrowser  | newBrowser |  newBrowser := browserState createBrowser.  browserPlugins do: [:each |  newBrowser addPlugin: each copy ].  newBrowser navigationEnvironment: navigationEnvironment.  newBrowser navigationHistory: navigationHistory.  browserState restoreStateOf: newBrowser.  ^newBrowserdragTab: aSystemWindow event: anEvent in: aTabLabel  aSystemWindow announcer unsubscribe: self.  self tabGroup removePage: aSystemWindow.  aSystemWindow configureForUnembedding.  self tabGroup pages size = 0 ifTrue: [ self owner delete ].  aSystemWindow position: anEvent targetPoint.  anEvent hand grabMorph: aSystemWindowdecorateTableCell: anItemCellMorph using: aCommandActivator  extensionMethodFromClass9  execute  critique guidedBanwaitBuildComplete  [ queryResult buildProcess isNil or: [ queryResult buildProcess isTerminated ] ] whileFalse: [ 20 milliSeconds wait ]overriddenMethod  ^methodorder  ^4testFindItemsSimilarToOthersWhenTheyAreNotInCache  | found |  cursor cleanCache.  found := cursor findItemsSimilarTo: ({Class .         Array} collect: #asCalypsoBrowserItem).  self assert: found size equals: 1.  self assert: found first actualObject equals: Array.  self assert: found first isPrepared.  self assert: found first position equals: (self rawResultItems indexOf: Array)isClass: aClass shouldImplement: aSelector  | inheritedMethod |  aClass isRootInEnvironment ifTrue: [ ^false ].  inheritedMethod := aClass superclass lookupSelector: aSelector.  inheritedMethod ifNil: [ ^false ].  ^self isAbstractMethod: inheritedMethodaffectsMethodsTaggedWith: tagName  ^announcerPlugin isMethodOverridden: methodmethodEditor: anObject  methodEditor := anObjectspawnQueryBrowserOn: aQuery withState: navigationBlock  | targetQuery |  targetQuery := aQuery.  aQuery isBoundToEnvironment ifFalse: [ targetQuery := aQuery withScope: self defaultNavigationScope ].  targetQuery scope = self systemScope ifTrue: [ targetQuery semiAsync hasEmptyResult ifTrue: [ ^self inform: 'There are no ' , targetQuery description ] ].  self spawnBrowser: ClyQueryBrowser withState: [:browser |  browser queryScopes: self allNavigationScopes.        browser showResultOf: targetQuery.        navigationBlock valueWithPossibleArgs: {browser} ]restoreCurrentSelectionAfterUpdate: currentSelection  | wasSameAsCurrent newItems currentSelectionIsChanged |  wasSameAsCurrent := isSameAsCurrent.  self checkItemsOfCurrentSelection: currentSelection.  newItems := isSameAsCurrent ifTrue: [ currentSelection items ] ifFalse: [ currentSelection rootDataSource findItemsWith: self actualObjects ].  currentSelectionIsChanged := (wasSameAsCurrent & isSameAsCurrent) not.  currentSelection restoreDesiredSelectionWith: newItems silently: currentSelectionIsChanged not.  ^currentSelectionIsChangedtriggerDoubleClickCommands  CmdDoubleClickActivation executeCommandInContext: self createSelectionContexttestComparisonWithResultWithAnotherHierarchyType  | queryResult2 |  queryResult2 := self createQueryResult.  queryResult2 hierarchy: #anotherHierarchy.  self deny: queryResult equals: queryResult2attachToSystem  asRBEnvironment  ^RBBrowserEnvironment newfullDescription  ^self descriptioninstallCounterInto: selector  | counter |  counter := ExecutionCounter installOn: (self class >> selector) ast sendNodes last.  installedCounters add: counter.  ^counterallItems  ^self wrapRawItems: actualResult allItems startingAt: 1prepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browsertestFindItemsWithActualObjects  | found |  found := cursor findItemsWith: {#absentItem1 .         Array .         #absentItem2}.  self assert: found size equals: 3.  self assert: found first equals: nil.  self assert: found last equals: nil.  self assert: found second actualObject equals: Array.  self assert: found second isPrepared.  self assert: found second position equals: (self rawResultItems indexOf: Array)spawnFullBrowser  ^self spawnBrowser: ClyFullBrowser withState: [:browser |  self navigateSpawnedFullBrowser: browser ]classesDo: aBlock  self projectsDo: [:project |  project classes do: aBlock ]createQuery  self subclassResponsibilitydefaultMenuItemName  ^'File Out'testFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reference1OfClass) .         (self class >> #referenceOfAnotherClass)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfClasstestExecutionShouldRemoveDuplication  query subqueries: {(self subqueryFromScope: ClyScopeExample of: self class) .         (self subqueryFromScope: ClyScopeExample2 of: self class)}.  self executeQuery.  self assert: resultItems asArray equals: {self class}environment: anObject  environment := anObjecttestCase: anObject  testCase := anObjecttestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClass1FromP1 >> #tag1Method1) .         (Object >> #printString) .         (ClyClass2FromP1 >> #instanceSideClassVar1Reader)}.  self assert: foundSelectors equals: #(instanceSideClassVar1Reader)createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'ffi calls' on: aMethodQueryisSimilarTo: anotherBrowserContext  ^(super isSimilarTo: anotherBrowserContext) and: [ metaLevelScope == anotherBrowserContext metaLevelScope ]methodGroups: anObject  methodGroups := anObjectcollectMetadataOf: aQueryResult by: anEnvironmentPlugin  anEnvironmentPlugin collectMetadataOfPackages: aQueryResulttestNotBasedOnMultipleBasisWhenTwoSubscopesAreBasedOnSameSingleObject  | subscope1 subscope2 |  subscope1 := ClyScopeExample of: #basisObject in: environment.  subscope2 := ClyScopeExample2 of: #basisObject in: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self deny: scope isBasedOnMultipleBasiscollectClassGroupProviders  ^#()itemsChanged  self refreshCritiquesexecute  | env snapshot commit |  env := RGEnvironment new.  commit := commitModel entity.  commit packageNames do: [:packageName |  snapshot := commit snapshotFor: (RPackage named: packageName).        snapshot importInto: env asPackageNamed: packageName ] displayingProgress: 'loading'.  env clean.  env browseAs: commit repository origin url , '[' , commit shortId , ']'doesMethod: aMethod useVar: aVariable  ^aVariable isWrittenIn: aMethod= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^pattern = anObject patternerrorCount: anObject  errorCount := anObjecttextUpdated  self applyDecorations.  self updateDirtyStatecolor: anObject  color := anObjectgroupVariablesByTypeAndDefinition: variables  | groups varsPerClass typedVars |  groups := IdentityDictionary new.  variables do: [:var |  typedVars := groups at: var class ifAbsentPut: [ IdentityDictionary new ].        varsPerClass := typedVars at: var definingClass ifAbsentPut: [ self containerForItemsSortedByName ].        varsPerClass add: var ].  ^groupsdefaultResult  ^ClyUnknownQueryResult instancedecorateResultMethodEditor: aMethodEditor  subqueries do: [:each |  each decorateResultMethodEditor: aMethodEditor ]enableFilter: anItemStringFilterClass  self enableFilterWithFactory: (ClyTableFilterFactory of: anItemStringFilterClass)classSampleWhichHasGroup  ^ClySubclassLOfClass0FromPExtendedByP1openBrowser  definingClass browsedefaultMenuItemName  ^'Apply deprecation'desiredSelection: toolClasses  | currentSelection |  desiredSelection := toolClasses asIdentitySet.  shouldSkipCurrentDesiredSelection ifFalse: [ currentSelection := self selectedTools collect: [:each |  each class ].        desiredSelection addAll: currentSelection ].  shouldSkipCurrentDesiredSelection := false, anotherQuery  self subclassResponsibilitytestComparisonToSimilarQueryWhichReturningDifferentObjects  | query2 |  query2 := self createQuery.  query2 resultItems: #(anotherResult).  self deny: query equals: query2tag2Method1  browser  ^browserexpandedButton  ^IconicButton new     target: item;     actionSelector: #collapse;     arguments: {};     labelGraphic: self theme treeExpandedForm;     color: Color transparent;     helpText: 'Unexpand Item';     borderWidth: 0addChild: childClass to: parentClass  hierarchy isInverse ifTrue: [ self addActualChild: parentClass to: childClass ] ifFalse: [ self addActualChild: childClass to: parentClass ]description  ^'unimplemented methods'createSampleScope  ^self multipleScopeSampleupdateTools  | newTools selectedTools currentTools needsNewSelection |  self updateToolsBy: [ newTools := OrderedCollection new.        browser navigationContextsDo: [:each |  self buildToolsOn: newTools for: each ].        needsNewSelection := self requiresNewDesiredSelection.        selectedTools := self selectedTools.        currentTools := tools copy.        self updateTabsWith: newTools.        tools ~= currentTools | needsNewSelection ifTrue: [ self restoreSelectedTools: selectedTools ] ]defaultMenuItemName  ^'Remove ' , self metalinkManagerClass name asLowercasesupeclassReaderOfVar1  ^readVar1block: anObject  block := anObject= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^baseCritiqueQuery = anObject baseCritiqueQuerydirection  ^directionunsubscribe: anObject  printExtraInfoOn: aStream  super printExtraInfoOn: aStream.  aStream nextPutAll: pattern valueensureScope: aScope  scope == ClyUnknownScope instance ifTrue: [ ^self scope: aScope ].  scope == aScope ifFalse: [ self error: 'Scope modification is forbidden. Query is bound to scope forever' ]createQuery  ^ClyFlaggingMethodsQuery from: ClyClassScope of: Object in: environment, anotherTypedScope  (anotherTypedScope isKindOf: ClyTypedScope) ifFalse: [ ^self error: 'Complex composition is not supported' ].  ^ClyCompositeScope on: (subscopes copyWith: anotherTypedScope)initialize  super initialize.  ruleSeverity := ClyCritiqueSeverityProperty defaultruleSeverity  ^ruleSeverityopenInspector  definingClass isClassSide ifTrue: [ ^(actualVariable read: definingClass instanceSide) inspect ].  super openInspectortestItemsChangedNotificationShouldResetItems  < expectedFailure>  super testItemsChangedNotificationShouldResetItemsdecorateTableCell: anItemCellMorph of: groupItem  super decorateTableCell: anItemCellMorph of: groupItem.  anItemCellMorph setBalloonText: self tooltipText.  visibilityLevels do: [:each |  each decorateMethodGroupTableCell: anItemCellMorph of: groupItem ]methodGroupQuery  ^methodGroupQueryisBasedOnSingleBasis  ^self basisSize = 1classTag  ^classTagcreateQuery  ^ClyAllVariablesQuery from: ClyClassScope of: ClyClass2FromP1 in: environmentisCurrentStateOf: aBrowser  aBrowser navigationViews with: viewStates do: [:view :state |  (state isCurrentStateOf: view) ifFalse: [ ^false ] ].  ^aBrowser tabManager selectsTools: selectedTabsitemType: aClass  itemType := aClassupdateSelection  | selectedItems |  selectedItems := table selectedIndexes select: [:i |  i between: 1 and: self dataSource numberOfRows ] thenCollect: [:each |  self itemAt: each ].  selection := self newSelectionWith: selectedItems.  shouldRestoreSelection ifTrue: [ changesWasInitiatedByUser ifTrue: [ desiredSelection := selection asDesiredSelection ] ifFalse: [ desiredSelection ifNotNil: [ desiredSelection checkItemsOfCurrentSelection: selection ] ] ]hash  ^super hash bitXor: tag hashselectedProjectChildItems  ^tool projectChildrenSelection itemstestOpeningBrowserCursor  | itemObserver |  itemObserver := ClyItemObserverExample new.  cursor := queryResult openBrowserCursorFor: itemObserver.  self assert: cursor class equals: ClyBrowserQueryCursor.  self assert: cursor queryResult equals: queryResult.  self assert: cursor itemObserver equals: itemObserver.  queryResult hasSubscriber: itemObservertestIsEmptyForExplicitlyDefinedAbstractMetaclass  query scope: (ClyClassScope of: ClyExplicitAbstractClassExample class in: environment).  self assert: query checkEmptyResult.  self executeQuery.  self assert: foundSelectors isEmptycreateDragPassengerFor: aSelection  | context |  context := self createSelectionContextOf: aSelection.  ^CmdDragAndDropActivation createDragPassengerInContext: contextisSameAs: anotherItem  ^browserItem isSameAs: anotherItem browserItemclassGroup  ^classGroupcreateMethodQueryFrom: aClassScope  ^ClyUnimplementedMethodsQuery from: aClassScopebrowser  ^self queryView browserallowsDifferentActivationPriority  ^falsebeProtected  accessGuard := Mutex newprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  methodGroups := aToolContext selectedMethodGroupstestMethodsEnumerationWhenBasisIsTraitedClass  | expected |  scope := ClyClassSideScope of: ClyClassWithTraits.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClassWithTraits class methods reject: [:e |  e origin = TraitedClass ] thenCollect: #selector.  self assert: result sorted asArray equals: expected sorted asArraysemiAsync  ^selftestFindItemsSimilarToOthers  | found |  found := cursor findItemsSimilarTo: ({Class .         Array} collect: #asCalypsoBrowserItem).  self assert: found size equals: 1.  self assert: found first actualObject equals: Array.  self assert: found first isPrepared.  self assert: found first position equals: (self rawResultItems indexOf: Array)testSelectedTabsWithoutBrowser  | tab |  self snapshotState.  tab := navigationState selectedTabs first.  self assert: tab browser isNilsearchDialog  ^ClyBrowserSearchDialogWindow for: selffindTestCaseCovering: aClass ifAbsent: absentBlock  | className |  className := aClass instanceSide name.  ^environment system classNamed: (className , 'Test') asSymbol ifAbsent: [ environment system classNamed: (className , 'Tests') asSymbol ifAbsent: absentBlock ]openOn: aQuery withTitle: dialogTitle thenDo: resultActionBlock  self showItemsOf: aQuery.  self title: dialogTitle.  browser openModal: self.  ^[ itemsView table cleanupFilter.  itemsView dataSource isClosed ifTrue: [ CmdCommandAborted signal ].  self cancelled ifTrue: [ CmdCommandAborted signal ].  resultActionBlock value ] ensure: [ itemsView closeDataSource ]testDataSourceIsClosed  self snapshotState.  self assert: navigationState dataSource isClosedinitializeForBrowserStateSpanshot  table := nil.  queryView := nil.  itemCursor := ClyClosedBrowserCursor instance.  lastFilteredDataSource := nil.  dirty := falsetestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithFlags >> #methodWithFlag in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithFlags >> #methodWithoutFlag in: environment).  self assert: query checkEmptyResulthasUnacceptedEdits  ^falsechangeStateBy: aBlock  | state navigationFailed |  navigationStarted ifTrue: [ ^aBlock value ].  navigationStarted := true.  navigationFailed := false.  state := self snapshotState.  ^[ aBlock on: Error do: [:err |  navigationFailed := true.        err pass ] ] ensure: [ navigationStarted := false.        navigationFailed | (state isCurrentStateOf: self) ifFalse: [ self recordNavigationState: state.              self updateWindowTitle.              self rebuildAllTools ] ]buildResult: aQueryResult  | failedTests |  failedTests := OrderedCollection new.  scope classesDo: [:each |  each isTestCase ifTrue: [ (each history at: #failures) do: [:testSelector |  (each lookupSelector: testSelector) ifNotNil: [:method |  failedTests add: method ] ].              (each history at: #errors) do: [:testSelector |  (each lookupSelector: testSelector) ifNotNil: [:method |  failedTests add: method ] ] ] ].  aQueryResult fillWith: failedTestsdefiningClass  ^definingClasssemiAsync  ^selfskipCurrentDesiredSelection  shouldSkipCurrentDesiredSelection := trueexecute  browser switchFocusToNextPanecreateInheritanceScopeFrom: classes  self subclassResponsibilitytestFixingStateBeforeExecution  query fixStateBeforeExecution.  self assert: query isReadOnlyObject.  self assert: query scope isReadOnlyObjecttestTriesFixWronglyUsedStarInRegex  | pattern |  pattern := ClyRegexPattern with: '*abs'.  self assert: (pattern matches: 'abs').  self deny: (pattern matches: 'ert')two  ^twotestFillingWithOneInstVarAndTwoClassVarsOfSameClass  queryResult fillWith: {(ClyInstanceVariable named: #instVar definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #ClassVar2 definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instVar)isForScripting  ^falsetestCreationOnTwoSubscopesOfDifferentObjects  | subscope1 subscope2 |  subscope1 := ClyScopeExample of: #basisObject1 in: environment.  subscope2 := ClyScopeExample of: #basisObject2 in: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self assert: scope basisObjects asSet equals: #(basisObject1 basisObject2) asSetbuildResult: aQueryResult  | allVars |  allVars := OrderedCollection new.  scope variablesDo: [:each |  allVars add: each ].  aQueryResult fillWith: allVarstestHasDefaultClassLocalScope  scope := self createSampleScope.  self assert: scope localScopeClass equals: ClyClassScopeisManagedByUser  ^isManagedByUserprovidesMethodGroup: anObject  providesMethodGroup := anObjecttestClassEnumeration  scope := ClyClassSideScope ofAll: {ClyClass1FromP1 classSide .         ClyClass2FromP1}.  scope classesDo: [:each |  result add: each ].  self assert: result asArray equals: {ClyClass1FromP1 classSide .         ClyClass2FromP1 classSide}testCheckIfEmpty  query scope: self scopeWithoutCritiques.  self assert: query checkEmptyResult.  query := self createQuery.  query scope: self scopeWithCritiques.  self deny: query checkEmptyResult.  query groupName: 'wrong group'.  self assert: query checkEmptyResulttestDataSourceWithoutQueryView  self snapshotState.  self assert: navigationState dataSource queryView isNilshowPackage: aPackage  tool selectPackage: aPackage, anotherQuery  ^anotherQuery unionWith: subqueries as: requiredResultnew  ^selfrootDataSource  ^rootDataSourcetestRetrievesBrowserState  self snapshotState.  self assert: (navigationState browserState isKindOf: ClyBrowserState)executeCommand: aCommand by: aCommandActivator  aCommand isComplexRefactoring ifTrue: [ aCommand confirmRefactoringInContext: self by: aCommandActivator ].  aCommand executedecorateBrowserItem: anItem ofClass: aClass  | testCase |  aClass isTestCase ifTrue: [ ^self ].  testCase := self findTestCaseCovering: aClass ifAbsent: [ ^self ].  anItem addProperty: (ClyTestedClassProperty coveringTestCase: testCase)selectItems: dataSourceItems  | newSelectionIsSame |  newSelectionIsSame := (dataSourceItems collect: #actualObject as: IdentitySet) = (items collect: #actualObject as: IdentitySet).  items := dataSourceItems.  self restoreTableSelectionSilently: newSelectionIsSame.  self ensureVisibleLastIteminitialize  super initialize.  selectedItems := #()implementorsOf: selectedSelector  self browser browseImplementorsOf: selectedSelectorisClassGroupSelected  ^falseretrieveStateFrom: aBrowser  super retrieveStateFrom: aBrowser.  queryScopes := aBrowser queryScopes.  activeScope := aBrowser activeScope.  methodQuery := aBrowser systemQuery.  expectedFlatQueryResult := aBrowser expectedFlatQueryResultdescription  ^'class comments with ' , pattern value printStringpackageOrganizer: anObject  packageOrganizer := anObjectcollectMetadata  metadata := ClyQueryResultMetadata newclear  undoList removeAll.  redoList removeAlltestSelectorOf: methodItem  ^(methodItem getProperty: ClyTestedMethodProperty) coveringTest selectorsupportsCriticDecoration  ^falsesimpleNameForSpotterMenu  ^'Packages'step  progress := progress + 1.  progress > 10 ifTrue: [ progress := 1 ].  progressIconMorph form: self currentIconexecute  self critique rule class browsetestNeedsRebuildByDefault  queryResult := self createQueryResult.  self assert: queryResult needsRebuildtestFindTestCaseCoveringTestedMetaclass  | foundClass |  foundClass := plugin findTestCaseCovering: ClyTestedClass class ifAbsent: [  ].  self assert: foundClass equals: ClyTestedClassTestselectsMethod: aMethod  ^aMethod sendsSelector: #subclassResponsibilitysystem  ^tool systemnavigationContextsDo: aBlock  navigationViews do: [:each |  aBlock value: each createSelectionContext ]setUpDataSource: aDataSource  table dataSource: aDataSource.  table initialDataSource: nil.  highlighting := ClyHighlightingSelection fromRoot: aDataSource items: #().  highlighting restoreTableSelection.  selection := self newSelectionWith: #().  aDataSource openOn: self.  self showDesiredSelection.  self refreshAsyncState.  self ensureSelectedItemIfNeededselectedProjectChildren  ^self actualSelectionFrom: self selectedProjectChildItemstestMoveToItemWhichNotSatisfiesCondition  | found |  found := cursor moveToItemWhich: [:each |  each actualObject = Object ].  self assert: found.  self assert: cursor position equals: 2.  found := cursor moveToItemWhich: [:each |  false ].  self deny: found.  self assert: cursor position equals: 2moveMainColumnAtTheEnd  | mainColumn |  mainColumn := self mainColumn.  table columns: (table columns copyWithout: mainColumn) , {mainColumn}testCreateGroupsForEveryMethodTag  | groups query |  self buildGroupsFor: ClySubclassN1OfClass1FromP1.  groups := builtGroups select: [:each |  each isKindOf: ClyTaggedMethodGroup ].  self assert: (groups collect: #tag as: Set) equals: ClySubclassN1OfClass1FromP1 tagsForMethods asSet.  query := groups first methodQuery.  self assert: query class equals: ClyTaggedMethodsQuery.  self assert: query scope equals: (ClyClassScope of: ClySubclassN1OfClass1FromP1)testCreationFromAnotherCompositeQueryAndNewDifferentSubquery  | subquery1 subquery2 subquery3 |  subquery1 := self subqueryFromScope: ClyScopeExample of: Array.  subquery2 := self subqueryFromScope: ClyScopeExample2 of: String.  subquery3 := ClyQueryExampleReturningScopeBasis2 from: ClyScopeExample of: Object in: environment.  query := subquery1 , subquery2 , subquery3.  self assert: query class equals: ClyUnionQuery.  self assert: query subqueries equals: {subquery1 .         subquery2 .         subquery3} asSet.  self assert: query requiredResult equals: subquery1 requiredResultdefinesTree  ^treeStructure notEmptyrawItems  ^actualResult rawItemsdefaultIconName  ^#diffdefiningMetaLevelScope  ^isInstanceSide ifTrue: [ ClyInstanceSideScope ] ifFalse: [ ClyClassSideScope ]groupProviderClass  ^ClyCriticMethodGroupProviderprepareDefaultState  super prepareDefaultState.  DefaultPackageFilter ifNotNil: [ packageView activateFilterWith: DefaultPackageFilter ].  UIManager default defer: [ packageView takeKeyboardFocus ]untestedOne  ^self onesetUpDefaultIcon  containerTab icon: self defaultIconiconNameForSpotterMenu  ^nilmergedParts: anObject  mergedParts := anObjectredoList: anObject  redoList := anObjectdefaultMenuIconName  ^#smallSystemBrowsernavigationHistory: anObject  navigationHistory := anObjectreducedByClassesFrom: aClassScope  | myClasses classesToExclude |  myClasses := basisObjects collect: [:each |  each instanceSide ].  classesToExclude := aClassScope collectAllClasses collect: [:each |  each instanceSide ].  ^self withNewBasisObjects: (myClasses copyWithoutAll: classesToExclude)testFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}type  ^typeitemsStartingAt: startIndex count: size  ^self wrapRawItems: (actualResult itemsStartingAt: startIndex count: size) startingAt: startIndexwithResult: aQueryResult  | newQuery |  newQuery := super withResult: aQueryResult.  newQuery subqueries: (subqueries collect: [:each |  each withResult: aQueryResult ]).  ^newQueryannotatedClass: aTableDecoratorClass  super annotatedClass: aTableDecoratorClass.  priority := aTableDecoratorClass prioritycreateMethodQueryFrom: aClassScope  ^ClyUndeclaredMethodsQuery from: aClassScopeselectedVariables  ^{self selectedVariable}tagName: anObject  tagName := anObjectensureRunning  (process notNil and: [ process isTerminated not ]) ifTrue: [ ^self ].  process := [ self processQueue ] forkAt: Processor userBackgroundPriority + 1 named: 'Calypso update'runPackageTests: aPackage  | testResult testClasses |  testClasses := aPackage definedClasses select: [:each |  each isTestCase and: [ each isAbstract not ] ].  testClasses ifEmpty: [ testResult := TestAsserter classForTestResult new ] ifNotEmpty: [ testResult := testClasses anyOne classForTestResult new ].  testClasses do: [:each |  self runTestCase: each results: testResult ].  testResult updateResultsInHistory.  self notifyUserAboutResults: testResult with: aPackage nameclassSampleWhichHasGroup  ^ClyClassWithHaltsdefaultMenuItemName  ^'Users'detectDefiningClassFrom: anUserClass  createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'overrides' priority: -10 on: aMethodQuerytestIsBasedOnMultipleBasisWhenSingleSubscopeIs  | subscope |  subscope := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {subscope}.  self assert: scope isBasedOnMultipleBasisdecorateByCritic: aCriticTool  testHasScopeFromSubquery  self assert: query scope equals: query subqueries anyOne scopescopeClass  ^ClyClassSideScopelastSelectedPackage  ^self lastSelectedObjectIn: self selectedPackagesisMarkedWith: propertyClass  ^self hasProperty: propertyClasswriter1OfVar1  writtenVar1 := #value1sendersOf: selectedSelector  self browser browseReferencesTo: selectedSelectorapplyChanges  self pendingText asString = self editingText asString ifFalse: [ editingClass comment: self pendingText stamp: Author changeStamp ].  ^truetestNotSelectsNotFFIMethod  self deny: (query selectsMethod: ClyClassWithFFIMethods >> #notFFIMethod)testIsAffectedByChangeOfMethodOfTargetClassWhichOverridesAbstractOne  query scope: (ClyClassScope of: ClyClassWhichInheritsAbstractClass in: environment).  self assert: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #abstractMethod1)spawnQueryBrowserOn: aQuery  self spawnQueryBrowserOn: aQuery withState: [  ]showsItemsFromMultipleScope  ^self query isExecutedFromMultipleScopeunionWith: typedQueries as: aQueryResult  self subclassResponsibilityname  ^'SUnit'visibleClassScope  ^visibleClassScopeaddLabel: aStringOrMorph  self addMorphBack: aStringOrMorph asMorphtestConvertingToSemiAsyncQuery  | convertedQuery |  convertedQuery := query semiAsync.  self assert: convertedQuery identicalTo: queryasyncQueryResult  ^asyncQueryResult ifNil: [ asyncQueryResult := self loadAsyncQueryResult ]criteriaString  ^criteriaStringtestAscending  function := ClySortByDefiningClassFunction ascending.  self deny: (function value: (ClyClassComment of: Object) value: (ClyClassComment of: Array)).  self assert: (function value: (ClyClassComment of: Array) value: (ClyClassComment of: Object)).  self assert: (function value: (ClyClassComment of: Object) value: (ClyClassComment of: Object))testBuildCompletionShouldNotifyItemObservers  | observer cursor |  observer := ClyItemObserverExample new.  cursor := queryResult openBrowserCursorFor: observer.  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self assert: observer wasNotifieddecorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color redfillWith: queriedObjects  self shouldNotImplementselectsClass: aClass  self subclassResponsibilityisQueryScopeActive: aScope  ^self activeScope = aScopetestFillingWithClassAndItsTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot1 .         3}hasProperty: aPropertyClass  ^properties anySatisfy: [:each |  each isKindOf: aPropertyClass ]build  self hResizing: #rigid.  self width: 120.  textMorph := self theme newTextEntryIn: self for: self get: #printMethodTags set: #setNewMethodTags: class: nil getEnabled: nil help: 'input tags which should be applied to current method'.  textMorph     hResizing: #spaceFill;     acceptOnFocusChange: false;     ghostText: 'as yet unclassified'.  self addMorph: textMorphimportClass: aClass  | newPackages |  super importClass: aClass.  newPackages := OrderedCollection new.  classQuery scope packagesDo: [:each |  each = aClass package ifFalse: [ newPackages add: each ] ].  newPackages size > 1 ifTrue: [ ^self error: 'You should select single package for import!' ].  newPackages ifNotEmpty: [ ^newPackages first addClass: aClass ].  aClass tags do: [:eachTag |  aClass untagFrom: eachTag ]testNotExecutedFromMultipleScopeWhenAllSubqueriesAreFromEmptyScope  < expectedFailure>  super testNotExecutedFromMultipleScopeWhenAllSubqueriesAreFromEmptyScopeinstanceVariablesOf: definingClass do: aBlock  | slots |  self metaLevelsOf: definingClass do: [:concreteMetaLevelClass |  slots := (concreteMetaLevelClass respondsTo: #localSlots) ifTrue: [ concreteMetaLevelClass localSlots ] ifFalse: [ concreteMetaLevelClass slots ].        slots do: [:var |  aBlock value: (ClyInstanceVariable on: var definedIn: definingClass) ] ]testFromTwoMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithFFIMethods >> #ffiMethod) .         (ClyClassWithFFIMethods >> #notFFIMethod)}.  self assert: foundSelectors sorted asArray equals: #(ffiMethod)lastSelectedItem  ^items firsttestConvertingToNewMetaLevel  | newQuery scopes |  query subqueries: {(ClyAllMethodGroupsQuery from: ClyClassScope of: Object in: environment) .         (ClyAllMethodGroupsQuery from: ClySubclassScope of: Array in: environment)}.  newQuery := query withMetaLevelScope: ClyInstanceSideScope.  self assert: newQuery class equals: self queryClass.  self assert: (newQuery subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: newQuery requiredResult identicalTo: query requiredResult.  scopes := newQuery subqueries collect: [:each |  each scope ] as: Set.  self assert: scopes equals: {(ClyInstanceSideScope of: Object) .         (ClySubclassScope of: Array localScope: ClyInstanceSideScope)} asSetkmDispatcher  ^CmdKMDispatcher attachedTo: selfplugins  ^pluginsisAppliedToBrowser  ^falsewarnUserAboutChangedContext  self belongsToCurrentBrowserContext ifTrue: [ self warnUserAboutMyContext ] ifFalse: [ self warnUserAboutDifferentContext ]testCheckEmptyQueryWhenThereIsEmptyResult  | query result |  query := self createQueryFromScope: ClyScopeExample empty.  result := environment query: query.  self assert: result items isEmpty.  self assert: (environment isQueryEmpty: query)isClassTagSelected  | classGroupClass |  self isClassGroupSelected ifFalse: [ ^false ].  classGroupClass := self lastSelectedItem type.  ^classGroupClass isBasedOnClassTaginitialize  super initialize.  checkbox := CheckboxMorph on: self selected: #formatAsYouRead changeSelected: #toggle.  checkbox     getLabelSelector: #formatAsYouReadLabel;     labelClickable: true;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     setBalloonText: 'Autoformat code without editing. Useful when reading some old/unformatted code. You can configure your own format in the settings browser.'.  self addMorph: checkboxgroupProviderClass  ^ClyExpectedFailureMethodGroupProviderupdateItems: dataSourceItems  | updatedItems |  updatedItems := itemCursor findItemsWith: (dataSourceItems collect: #actualObject).  dataSourceItems with: updatedItems do: [:myItem :updatedBrowserItem |  myItem updateItemWith: updatedBrowserItem ]isSimilarTo: anotherBrowserTool  (super isSimilarTo: anotherBrowserTool) ifFalse: [ ^false ].  ^package = anotherBrowserTool package and: [ classTag = anotherBrowserTool classTag ]hash  ^super hash bitXor: methods hashdataSource  ^table dataSourcedisplayBlock: anObject  displayBlock := anObjectfixStateBeforeExecution  super fixStateBeforeExecution.  subqueries do: [:each |  each fixStateBeforeExecution ]defaultMenuItemName  ^sourceNode hasExecutionCounter ifTrue: [ 'Remove counter (' , self currentCallsCount asString , ')' ] ifFalse: [ 'Remove counter' ]createBrowser  self subclassResponsibilitysetUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyInheritanceAnalysisEnvironmentPlugin newsetUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyInheritanceAnalysisEnvironmentPlugin newrefactoringScopes  | allScopes defaultScope |  allScopes := tool allNavigationScopes.  defaultScope := tool defaultNavigationScope.  ^(allScopes copyWithout: defaultScope) copyWithFirst: defaultScopedecorateBrowserItem: anEnvironmentItem ofMethod: aMethod  shouldSkipCurrentDesiredSelection: anObject  shouldSkipCurrentDesiredSelection := anObjectcreateQueryResult  ^ClyGroupedClassVariables withHierarchy: ClySubclassHierarchy newreadParametersFromContext: aBrowserContext  super readParametersFromContext: aBrowserContext.  methodDataSource := aBrowserContext browser resultView dataSourcebuild  fullIndentation ifTrue: [ self buildWithFullIndentation ] ifFalse: [ self buildWithLabelIndentation ]testSelectedItemPointsToRetrievedDataSource  | item |  self snapshotState.  item := navigationState selection items first.  self assert: item ownerDataSource equals: navigationState dataSourcedetachFromSystem  methodWithoutBreakpoints2  subscribe: aBrowserQueryCursor  actualResult subscribe: aBrowserQueryCursorbasisSize  ^basisObjects sizetag: anObject  tag := anObjectparserClass  ^RBParserfindString: searchedString asSelectorIn: aString  | string interval firstIndex |  searchedString ifNil: [ ^0 to: 0 ].  aString isEmptyOrNil ifTrue: [ ^0 to: 0 ].  string := aString asString.  interval := 0 to: 0.  (searchedString includes: $:) ifTrue: [ | list |        list := searchedString substrings: ':'.        list size = 1 ifTrue: [ firstIndex := self findFirstOccurrenceOf: searchedString in: string.              firstIndex isZero ifFalse: [ interval := firstIndex to: firstIndex + searchedString size - 1 ] ] ifFalse: [ | lastIndex |              firstIndex := self findFirstOccurrenceOf: list first , ':' in: string.              firstIndex > 0 ifTrue: [ lastIndex := string findString: list last , ':' startingAt: firstIndex + (list first size - 1).                    interval := firstIndex to: lastIndex + list last size ] ] ] ifFalse: [ firstIndex := self findFirstOccurrenceOf: searchedString in: string.        firstIndex > 0 ifTrue: [ interval := firstIndex to: firstIndex + searchedString size - 1 ] ].  ^intervaldecorateMethodGroupTableCell: anItemCellMorph of: groupItem  | tool |  tool := ClyMethodVisibilityMorph for: anItemCellMorph browser level: self.  tool build.  anItemCellMorph definitionMorph: tooltestFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> #method1).  self assert: (resultItems identityIncludes: self class >> #method2)depth  ^depthrequestSingleMethodTag: queryTitle suggesting: suggestedTag  | knownTags ui selectedTag |  knownTags := (SystemNavigation default allExistingProtocolsFor: true) reject: [:each |  each beginsWith: '*' ].  knownTags := knownTags asSortedCollection: [:a :b |  a asLowercase < b asLowercase ].  ui := ListDialogWindow new     getList: [:r |  knownTags select: [:e |  r search: e ] ];     displayBlock: [:e |  e ];     initialAnswer: suggestedTag;     acceptNewEntry: true;     title: queryTitle;     yourself.  selectedTag := ui chooseFromOwner: tool.  selectedTag isEmptyOrNil ifTrue: [ CmdCommandAborted signal ].  (selectedTag beginsWith: '*') ifTrue: [ self inform: 'Star is forbidden for protocol name. You can specify package in method editor using status bar checkbox'.        ^CmdCommandAborted signal ].  ^selectedTag asSymboltestVariablesEnumerationForObject  scope := ClyClassScope of: Object.  scope variablesDo: [:each |  result add: each ].  self assert: result size equals: 1.  self assert: result anyOne equals: (ClyClassVariable on: Object classVariables first definedIn: Object)isBasedOnQueryOf: itemTypeClass  ^query retrievesItemsOfType: itemTypeClasstestComparisonWithQueryOfAnotherGroup  | query2 |  query2 := self createQuery.  query2 groupName: 'another group'.  self deny: query equals: query2collectMethodGroupProviders  ^{ClyAbstractMethodGroupProvider .   ClyOverridingMethodGroupProvider .   ClyOverriddenMethodGroupProvider .   ClyRequiredMethodGroupProvider} collect: [:each |  each new ]iconName: anObject  iconName := anObjecttestConvertingToInheritingScope  | convertedScope |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope asInheritingScope.  self assert: (convertedScope representsScope: ClySubclassScope).  self assert: convertedScope localScopeClass equals: ClyInstanceSideScope.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environment.  self assert: convertedScope name equals: ClyClassScope inheritingScopeNametestSelectsMethodWithHalt  self assert: (query selectsMethod: ClyClassWithHalts >> #methodWithHalts1)checkEmptyResult  ^resultItems notEmptycheckEmptyResult  scope packagesDo: [:each |  ^false ].  ^truetestAscending  function := ClySortMethodBySelectorFunction ascending.  self deny: (function value: Object >> #size value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)itemsWhere: conditionBlock  ^self protectItemsWhile: [ items select: conditionBlock ]hasSelectedItems  ^self isEmpty not= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^isCaseSensitive = anObject isCaseSensitiveisAccessibleFrom: aClass  (aClass instanceSide includesSharedPoolNamed: definingClass name) ifTrue: [ ^true ].  ^aClass instanceSide = definingClass or: [ aClass instanceSide inheritsFrom: definingClass ]hash  ^super hash bitXor: actualObjectSortFunction hashproperties  ^propertiesprojectManager  ^projectManagerdefaultMenuIconName  ^#scriptManagerIcontestNotMatchesMethodWithWrongClassAndPackageAndSelector  filter := ClyQueryBrowserFilter substringPattern: 'filter not matches package, class or selector'.  self deny: (filter matches: self itemOfThisTestMethod)queryResult  ^queryResultspawnQueryBrowserOn: aQuery  browser spawnQueryBrowserOn: aQuerydecorateMethodGroupTableCell: anItemCellMorph of: groupItem  | tool |  tool := ClyMethodVisibilityMorph for: anItemCellMorph browser level: self.  tool build.  anItemCellMorph addExtraIcon: #hierarchy.  anItemCellMorph addExtraTool: toolmethodsSize  ^self methods sizeabstractMethod1  self subclassResponsibilitydescribes: aBrowserContext  ^(aBrowserContext isKindOf: ClyFullBrowserContext) and: [ aBrowserContext isClassSelected not ]methodWithExpectedStringInSources  ^self printStringtestMatchesAnyStringWhenItIsOnlySpaces  | pattern |  pattern := ClyRegexPattern with: '  '.  self assert: (pattern matches: 'any string')parseClassDefinition  ^CDClassDefinitionParser parse: self editingTextbaseQueryResult  ^baseQueryResultupdateUsing: newUpdateStrategy by: updateBlock  [ updateGuard critical: [ | oldStrategy |        oldStrategy := updateStrategy.        [ updateStrategy := newUpdateStrategy.        updateBlock on: Error do: [:err |  updateStrategy := oldStrategy.              updateGuard := Mutex new.              err pass ] ] ensure: [ updateStrategy == newUpdateStrategy ifTrue: [ updateStrategy := oldStrategy ] ] ] ] ensure: [ newUpdateStrategy publishCollectedChanges ]testDescendingDifferentPackage  function := ClySortMethodByPackageFunction descending.  self deny: (function value: Number >> #printString value: Object >> #printString).  self assert: (function value: Object >> #printString value: Number >> #printString)runTest: testSelector of: testClass  | testResult |  testResult := testClass debug: testSelector.  self notifyUserAboutResults: testResult with: 'Method: ' , testClass asString , '>>#' , testSelector asStringselectsMethod: aMethod  ^aMethod tags isEmptyisAffectedByPackageChange: aPackageAnnouncement  ^falseresetStateForSnapshot  super resetStateForSnapshot.  textMorph := nil.  textModel := nilclassScopeForMethods  | currentClassScope |  currentClassScope := methodGroupQuery scope asScope: metaLevelScope.  ^self extendClassScopeForMethods: currentClassScopecreateRefactoring: variableRefactoringClass for: aClass  ^actualVariable createRefactoring: variableRefactoringClass for: aClassisInstanceSideMethodSelected  self isMethodSelected ifFalse: [ ^false ].  ^self selectedMethodItems anySatisfy: [:each |  each systemDefinition isInstanceSide ]announceChangesOf: aQueryResult  updateStrategy announceChangesOf: aQueryResultbrowserClass: anObject  browserClass := anObjecttestDescendingMethodsWithSameSelectorButDifferentClass  function := ClySortMethodBySelectorFunction descending.  self assert: (function value: Object >> #printString value: Number >> #printString).  self deny: (function value: Number >> #printString value: Object >> #printString)pattern: anObject  pattern := anObjectinitialize  super initialize.  subgroupsQuery := ClyUnknownQuery instanceasGlobalScopeIn: aNavigationEnvironment  ^ClySystemEnvironmentScope of: self in: aNavigationEnvironment named: namequery: aQuery  self isBasedOnEmptyBasis ifTrue: [ ^ClyUnknownQueryResult instance ].  aQuery ensureScope: self.  ^environment query: aQuerydefaultMenuItemName  ^'Convert to protocol'systemQuery  ^methodQuerybelongsToRemovedBrowserContext  super belongsToRemovedBrowserContext ifTrue: [ ^true ].  ^self methodClass isObsoleterequiredQueryResult  ^ClyTraitUserHierarchy inverse asQueryResultselectedMethodGroups  ^self actualSelectionFrom: self selectedMethodGroupItemsnewTestClassCategoryFor: aClass  | tag |  tag := aClass package classTagForClass: aClass.  ^String streamContents: [:s |  s           nextPutAll: aClass package name;           nextPutAll: '-Tests'.        tag isRoot ifFalse: [ s                 nextPut: $-;                 nextPutAll: tag name ] ]defaultMenuItemName  ^'Senders'testIsBuiltWhenItemsExist  queryResult initializeItems.  self assert: queryResult isBuiltdefaultMenuItemName  ^'Add breakpoint'rebuild  self initializeItems.  buildingQuery buildResult: self.  metadata := nilretrievesItem: aClass  ^self selectsClass: aClasstestFillingWithMethodsAndClasses  queryResult fillWith: {ClyClass1FromP1 .         (ClyClass1FromP1 >> #tag1Method1)}.  self assertItems: #(tag1Method1 0 ClyClass1FromP1 0) withValue: [:each |  each name ]queryEnvironment  ^query environmenttestFillingWithUsersOfTraitWhenRootTraitIsMissingInGivenList  queryResult fillWith: {ClyTraitChild1 .         ClyClassWithTraits .         ClyTraitChild2}.  self assertItems: {ClyTraitChild1 .         0 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         0 .         ClyClassWithTraits .         1}createBrowser  ^ClyQueryBrowser newisMoreImportantThan: anotherSeverity  ^self level > anotherSeverity levelqueryScopes: scopesCollection  queryScopes := (scopesCollection reject: [:each |  each isBasedOnEmptyBasis ]) as: OrderedCollectionadoptQuery: aQuery  aQuery scope: self.  ^aQuerychangesAnnouncer: anObject  changesAnnouncer := anObjectcreateQuery  ^ClyTaggedMethodsQuery by: #tag1 from: (ClyClassScope of: ClyClass1FromP1 in: environment)createSampleScope  | subscope subscope2 |  subscope := ClyScopeExample of: #basisObject in: environment.  subscope2 := ClyScopeExample2 of: #basisObject2 in: environment.  ^ClyCompositeScope on: {subscope .         subscope2}analyzedObject  ^analyzedObjectbuildResult: aQueryResult  | vars |  vars := OrderedCollection new.  scope classVariablesDo: [:each |  vars add: each ].  aQueryResult fillWith: varscurrentIcon  ^TabMorph perform: (#refreshIcon , progress asString) asSymbolisMethodOverriding: aMethod  ^aMethod isOverridingsimpleNameForSpotterMenu  ^'Projects'defaultMenuIconName  ^#removeIconshowsFlatClasses  ^self packageSelection isEmpty not and: [ (classView showsItemsFromScope: ClyClassHierarchyScope) not ]meaningfullObjectToAssert: aBrowserItem  ^aBrowserItem actualObject classisResult: aQueryResult affectedBy: aSystemAnnouncement  aSystemAnnouncement affectsCritiques ifFalse: [ ^false ].  (super isResult: aQueryResult affectedBy: aSystemAnnouncement) ifTrue: [ ^true ].  aQueryResult forceLazyRebuild.  ^falsereferenceOfSmalltalk  ^SmalltalkprepareFullExecutionInContext: aToolContext  | tagsString confirmed |  super prepareFullExecutionInContext: aToolContext.  tagsString := ', ' join: (methodGroups collect: #name).  (methodGroups anySatisfy: [:each |  each methodsSize > 0 ]) ifTrue: [ confirmed := UIManager default confirm: 'Are you sure you want to remove methods tagged with ' , tagsString , '?'.        confirmed ifFalse: [ CmdCommandAborted signal ] ]isAppliedToBrowser  ^browser showsFlatResultswitchToFullClassHierarchy  | classScope |  classScope := self classSelection asItemsScope: ClyInstanceSideScope.  self switchClassViewTo: ClyHierarchicallySortedClasses new inScope: classScope asFullHierarchyScopedescription  ^'overridden methods'createQueryResult  ^ClyRawQueryResult newwithExtraBasisObject: newBasisObject  (basisObjects includes: newBasisObject) ifTrue: [ ^self ].  ^self withNewBasisObjects: (basisObjects copyWith: newBasisObject)testFromTwoMethods  self installCounterInto: #methodWithCounter.  self queryFromScope: ClyMethodScope ofAll: {(self class >> #methodWithCounter) .         (self class >> #methodWithoutCounter)}.  self assert: foundSelectors sorted asArray equals: #(#methodWithCounter)buildLabel  label := self theme newLabelIn: self label: self printMethodTagsOrPackage.  label on: #click send: #openEditor to: selfdefaultTitle  ^'setUp'decorateTool  self subclassResponsibilitydecorateBrowserItem: anItem ofMethod: aMethod  | script |  script := ClyClassScript detectInMethod: aMethod ifAbsent: [ ^self ].  anItem addProperty: (ClyClassScriptProperty script: script)isBoundToEnvironment  ^environment notNilisAsync  ^falsefindItemsWith: actualObjects  | myItems childItems |  myItems := super findItemsWith: actualObjects.  myItems size == actualObjects size ifTrue: [ ^myItems ].  childItems := expandedItems flatCollect: [:each |  each childrenDataSource findItemsWith: actualObjects ].  ^myItems , childItemstestIsAffectedByChangeOfSubclassMethodWhichOverridesSuperclass  self assert: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #overriddenMethod)isRoot  ^parentItem isNilincludesClassGroupsAffectedBy: aSystemAnnouncement  | providers |  basisObjects do: [:eachPackage |  environment pluginsDo: [:plugin |  providers := plugin collectClassGroupProviders.              providers do: [:eachProvider |  (eachProvider providesGroupsAffectedBy: aSystemAnnouncement inScope: self) ifTrue: [ ^true ] ] ] ].  ^falsebelongsToCurrentBrowserContext  ^browser methodSelection isEmpty ifTrue: [ browser isClassSelected: self editingMethod origin ] ifFalse: [ browser isMethodSelected: self editingMethod ]isResult: aQueryResult affectedBy: aSystemAnnouncement  ^scope includesMethodsAffectedBy: aSystemAnnouncementdecorateTableCell: anItemCellMorph inContext: itemContext  ^self decorateTableCell: anItemCellMorph of: itemContext lastSelectedItemhasBrokenTests  ^failureCount > 0 | (errorCount > 0)tearDown  installedBreakpoints do: [:each |  each remove ].  installedBreakpoints removeAll.  super tearDownshoutAboutToStyle: aMorph  ^self wantsTextStylingcreateQuery  ^ClyQueryExampleReturningScopeBasis from: (ClyScopeExample ofAll: {Array .               Object .               String} in: environment) as: self createQueryResultprintExtraInfoOn: aStream  super printExtraInfoOn: aStream.  aStream nextPutAll: self printSelectorstestComparisonWithDifferentScope  | scope2 |  scope := self createSampleScope.  scope2 := ClyScopeExample2 of: #basisObject in: environment.  self deny: scope equals: scope2asTraitVisibility  | traits |  traits := extraClassScope basisObjects select: [:each |  each isTrait ].  ^(ClySingleTraitVisibilityLevel of: visibleClassScope) extraClassScope: (visibleClassScope asScope: ClyClassScope ofAll: traits)testClassEnumerationOverClassWhenConcreteClassScopeIsLocal  | expected |  scope := ClySubclassScope of: Class localScope: ClyClassScope.  scope classesDo: [:each |  result add: each ].  expected := Class allSubclasses asSet.  self assert: result asSet equals: expected asSetincludesClassesAffectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsClassesrequestNavigationBy: aBlock  navigationSelector := aBlockgetProperty: anEnvironmentPropertyClass  ^browserItem getProperty: anEnvironmentPropertyClasshash  ^super hash bitXor: package hashbrowser  ^browser= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^itemType = anObject itemTypeconfirmUnusedVariablesInDefiningClass: variables  ^self browser confirmUnusedVariablesInDefiningClass: variablesisExtension  ^isExtensionwantsDropPassenger: aPassenger at: aDataSourceItem  | context |  context := self createSelectionContextOf: aDataSourceItem asSelection.  ^aPassenger canBeDroppedInContext: contextprintOn: aStream  | position |  super printOn: aStream.  aStream nextPut: $(.  position := aStream position.  self printExtraInfoOn: aStream.  aStream position = position ifTrue: [ aStream           skip: -1;           nextPut: $  ] ifFalse: [ aStream nextPutAll: ') ' ].  aStream nextPutAll: 'from '.  scope isBasedOnEmptyBasis ifTrue: [ aStream nextPutAll: 'empty scope' ] ifFalse: [ scope printDescriptionOn: aStream ]testSelectsAbstractMethodWhichIsNotImplemented  self assert: (query selectsMethod: ClyAbstractClassExample >> #abstractMethod2).  self assert: (query selectsMethod: ClyAbstractSubclassExample >> #abstractSubclassMethod)executeCommand: aCommand by: aCommandActivator  aCommand isComplexRefactoring ifTrue: [ aCommand confirmRefactoringInContext: self by: aCommandActivator ].  aCommand executetearDown  installedCounter uninstall.  super tearDowndescription  ^'unclassified methods'printOn: aStream  super printOn: aStream.  inverse ifTrue: [ aStream nextPutAll: '(inverse)' ]switchFocusToPreviousPane  | focused next |  focused := navigationViews detect: [:each |  each hasKeyboardFocus ] ifNone: [ ^self ].  next := navigationViews before: focused ifAbsent: [ ^self ].  next takeKeyboardFocustestFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reader1OfVar1) .         (self class >> #writerOfVar1)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reader1OfVar1outOfWorld: aWorld  super outOfWorld: aWorld.  self detachFromTextMorphextensionMethodFromRoot1Trait  currentCallsCount  ^sourceNode counter countcreateMethodGroupFor: aMethodQuery from: aClassScope  | subgroupsQuery |  subgroupsQuery := ClyExtendingPackagesQuery from: aClassScope as: ClyGroupedExtendingPackages new.  ^ClyMethodGroup named: 'extensions' priority: 9 on: aMethodQuery withSubgroupsFrom: subgroupsQueryprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browserconcreteResultOf: aTestClass ifPresent: presentBlock  ^testCaseResults at: aTestClass ifPresent: presentBlockshowMessage: aMessageDescription renamedTo: newSelector  tool editingMethod selector == aMessageDescription selector ifTrue: [ tool switchToMethod: tool methodClass >> newSelector ] ifFalse: [ tool selectAnySelector: {newSelector} ]importClasses: classesCollection  classesCollection do: [:each |  self importClass: each ]singleBasisSample  ^self class >> #method1testFilterObjectWithName  filter := ClyItemNameFilter substringPattern: 'ject'.  self assert: (filter matches: Object).  self deny: (filter matches: Array)testIsBuiltWhenBuildComplete  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self assert: queryResult isBuiltcollate: aMethod1 with: aMethod2  (aMethod1 selector isBinary and: [ aMethod2 selector isBinary not ]) ifTrue: [ ^-1 ].  (aMethod1 selector isBinary not and: [ aMethod2 selector isBinary ]) ifTrue: [ ^1 ].  aMethod1 selector = aMethod2 selector ifTrue: [ ^aMethod1 origin name threeWayCompareTo: aMethod2 origin name ].  ^aMethod1 selector threeWayCompareTo: aMethod2 selectornewMethodView  ^self newNavigationView     displayMainColumnBy: [:cell :item |  self specifyMethodItemNameOn: cell label for: item browserItem ];     requestNavigationBy: #methodSelectionChangedinitialize  super initialize.  depth := 0.  properties := OrderedCollection new.  isPrepared := falsetestDescendingForBinaryAndUnarySelectors  function := ClySortMethodBySelectorFunction descending.  self assert: #| > #abs.  self deny: (function value: Integer >> #| value: Number >> #abs).  self assert: (function value: Number >> #abs value: Integer >> #|).  self deny: #+ > #abs.  self deny: (function value: Number >> #+ value: Number >> #abs).  self assert: (function value: Number >> #abs value: Number >> #+)elementAt: rowIndex  self subclassResponsibilitytitle  ^activator menuItemNamestepTime  ^100collate: aMethod1 with: aMethod2  | comparisonResult |  comparisonResult := aMethod1 package name threeWayCompareTo: aMethod2 package name.  comparisonResult = 0 ifFalse: [ ^comparisonResult ].  comparisonResult := aMethod1 origin name threeWayCompareTo: aMethod2 origin name.  comparisonResult = 0 ifFalse: [ ^comparisonResult ].  ^aMethod1 selector threeWayCompareTo: aMethod2 selectordefaultTitle  ^browser metaLevelScope defaultName capitalized , ' method'isSameAs: anotherBrowserItem  type = anotherBrowserItem type ifFalse: [ ^false ].  ^type checkCalypsoItem: actualObject isSameAs: anotherBrowserItem actualObjecttestNotExecutedFromSingleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  query subqueries: {(self subqueryFromScopeOf: self class) .         (self subqueryFromScopeOf: self class superclass)}.  self deny: query isExecutedFromSingleScopeopenInWindow: aWindow  | groupWindow myWindow |  groupWindow := self createWindowGroupFrom: aWindow.  myWindow := self buildWindow.  groupWindow addWindow: myWindow.  myWindow activate.  myWindow announceOpenedupdateItemCache  | update |  update := cache createFullUpdateOf: queryResult.  cache := update itemCache.  itemCount := update totalItemCount.  metadata := update metadatasystemQuery  ^systemQuerytestFromTwoMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyTestedClassTest >> #testExpectedFailure) .         (ClyTestedClassTest >> #testOne)}.  self assert: foundSelectors sorted asArray equals: #(testExpectedFailure)= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^value = anObject valuetestHasDefaultBaseQueryResultByDefault  self assert: queryResult baseQueryResult class equals: ClySortedQueryResultinitialize  super initialize.  isSameAsCurrent := truetestClassEnumerationOverInstanceSideBasisWhenBothMetaLevelsAreLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {Object .         Object class .         ProtoObject .         ProtoObject class} asSetexecute  GTSpotterMorph new     extent: ((World width / 2.4) @ (World height / 1.6)) asIntegerPoint;     doLayout;     spotterModel: (GTSpotter on: (ClySpotterModel on: browser));     openCenteredInWorldallElements  ^(1 to: self numberOfRows) collect: [:i |  self elementAt: i ]buildExtensionItemsFrom: classes  | extensions |  extensions := self buildItemsFrom: classes.  extensions do: [:each |  each markWith: ClyExtendedClassTag ].  ^extensionstwo: anObject  two := anObjecttestSelectsMethodWithWatchpoint  self installWatchpointInto: #methodWithWatchpoint.  self assert: (query selectsMethod: self class >> #methodWithWatchpoint)errorCount  ^errorCounttestFillingWithMethodsOfSameClass  queryResult fillWith: (#(tag1Method1 instanceSideVar1WriterMethod instanceSideVar1ReaderMethod) collect: [:each |  ClyClass1FromP1 >> each ]).  self assertItems: #(#instanceSideVar1ReaderMethod 0 #instanceSideVar1WriterMethod 0 #tag1Method1 0) withValue: [:each |  each name ]switchToPackages  | packages |  packages := ClyAllPackagesQuery sortedFrom: self systemScope.  packageView showQuery: packagesprintDescriptionOn: aStream  name ifNotNil: [ ^super printDescriptionOn: aStream ].  subscopes do: [:each |  each printDescriptionOn: aStream.        aStream nextPutAll: ', ' ].  aStream skip: -2isVariableSelected  ^self hasSelectedItemsname  ^name ifNil: [ super printString ]iconName  ^#scriptManagerIconhasKeyboardFocus  ^super hasKeyboardFocus or: [ table hasKeyboardFocus ]pendingText  ^textMorph textitem: aDataSourceItem  item := aDataSourceItemisInProjectView  ^self packageView showsItemsFromQuery: (systemScope projectQueryFor: self systemScope) classrootParentItem  ^ownerDataSource isRoot ifTrue: [ self ] ifFalse: [ self parentItem rootParentItem ]testComparisonToSimilarQueryButWithDifferentPackage  | query2 |  query package: Object package.  query2 := self createQuery.  query2 package: String package.  self deny: query equals: query2initialize  super initialize.  queryScopes := OrderedCollection new.  expectedFlatQueryResult := self defaultFlatQueryResultmethodGroup  ^methodGrouptraitScopeClass  ^ClyInheritedTraitScopeopenOn: aQueryView  super openOn: aQueryView.  expandedItems do: [:each |  each childrenDataSource openOn: aQueryView ]extraBasisSample  self subclassResponsibilitydecorateBrowserItem: anItem ofMethod: aMethod  aMethod origin isTrait ifTrue: [ anItem systemDefinition definingClassItem markWith: ClyTraitTag ]prepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  package := aToolContext lastSelectedPackage.  classGroup := aToolContext lastSelectedClassGroup.  newName := UIManager default request: 'New name of the class tag' initialAnswer: classGroup name title: 'Rename a class tag'.  newName isEmptyOrNil | (newName = classGroup name) ifTrue: [ CmdCommandAborted signal ]buildActualResult  [ actualResult := buildingQuery execute.  (items := actualResult items) isNil ] whileTrue.  self collectMetadata.  buildProcess := nil.  self buildIsDonecreateMethodQueryFrom: aClassScope  ^ClyOverridingMethodsQuery from: aClassScopeisSimilarTo: anotherBrowserTool  ^self class = anotherBrowserTool class and: [ testClass == anotherBrowserTool testClass ]collate: aGroup1 with: aGroup2  aGroup1 priority = aGroup2 priority ifTrue: [ ^aGroup1 name threeWayCompareTo: aGroup2 name ].  ^aGroup2 priority threeWayCompareTo: aGroup1 priorityselectedItem  ^viewDataSource elementAt: 1testFillingWithClassesFromOneHierarchy  queryResult fillWith: {ClySubclassN1OfClass1FromP1 .         ClySubclassLOfSubclassMFromP3 .         ClyClass1FromP1 .         ClySubclassN2OfClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1 .         ClySubclassN1OfClass1FromP1 .         1 .         ClySubclassN2OfClass1FromP1 .         1}isLive  ^trueexecute  [ browser selectClass: (self testClassFor: targetClass) ] on: ClyInvalidClassForTestClassGeneration do: [:ex |  self inform: 'Cannot generate test class for ' , ex baseClass printString , '.' ]testComparisonWithCompositeScopeBasedOnDifferentQueries  | scope2 |  scope := self createSampleScope.  scope2 := self createSampleScope.  scope2 subscopes: {(ClyScopeExample2 of: #someBasis in: environment)}.  self deny: scope equals: scope2itemCount  ^itemCountselectsTools: toolsArray  | selectedTools |  selectedTools := self selectedTools.  selectedTools size = toolsArray size ifFalse: [ ^false ].  ^selectedTools allSatisfy: [:existingTool |  toolsArray anySatisfy: [:each |  existingTool isSimilarTo: each ] ]testDecoratingMethodWithHalt  | plugin method methodItem |  plugin := ClyReflectiveEnvironmentPlugin new.  method := ClyClassWithHalts >> #methodWithHalts1.  methodItem := method asCalypsoBrowserItem.  plugin decorateBrowserItem: methodItem ofMethod: method.  self assert: (methodItem isMarkedWith: ClyMethodWithHaltTag).  self deny: (methodItem isMarkedWith: ClyMethodWithBreakpointTag)testClassEnumerationOverMetaclassWhenConcreteClassScopeIsLocal  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: ClyClass1FromP1 class allSuperclasses asSetselectedItemsOfType: itemTypeClass  ^selectedItems select: [:each |  each isBasedOnItemType: itemTypeClass ]isSelectedItemHasWatchpoint  ^selectedItems anySatisfy: [:each |  each isMarkedWith: ClyMethodWithWatchpointTag ]printExtraInfoOn: aStream  ^aStream nextPutAll: self descriptionselectedMethodItems  ^selectedItems select: [:each |  each isBasedOnItemType: ClyMethod ]testClassVarsEnumerationWhenTheyNotExist  scope := ClyClassScope of: ClyClass1FromP1.  scope classVariablesDo: [:each |  result add: each ].  self assert: result isEmptydecorateResultMethodEditor: aMethodEditor  aMethodEditor selectAnySelector: selectorssimpleNameForSpotterMenu  ^self defaultTitleisAppliedToBrowser  ^browser classView showsItemsFromScope: self traitScopeClasssubclassClassVar1Reader  ^ClassVar1projects  ^projectManager projectscurrentScope  ^self scopes detect: [:each |  browser isQueryScopeActive: each ]doItReceiver  ^self selectedClassOrMetaClass ifNotNil: [:class |  class instanceSide ]displayMainColumnBy: cellAndItemBlock  self mainColumn displayBlock: cellAndItemBlockdescription  ^'senders of ' , self printSelectorsprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  selectedClassItem := aToolContext lastSelectedItemlastSelectedProjectChild  ^self lastSelectedObjectIn: self selectedProjectChildrentestComparisonWithSimilarScopeButWithDifferentMetaLevelScope  | scope2 |  scope := self createSampleScope.  scope2 := self createSampleScope.  self deny: scope localScopeClass equals: ClyInstanceSideScope.  scope2 localScopeClass: ClyInstanceSideScope.  self deny: scope equals: scope2findDataSourceSameAs: aDataSource ifNone: noneBlock  ^(self isSameAs: aDataSource) ifTrue: [ ^self ] ifFalse: noneBlocksingleBasisSample  ^ClyClass1FromP1testAllItems  | allItems unprepared |  allItems := cursor retrieveAll.  self assert: allItems equals: queryResult items.  unprepared := allItems reject: #isPrepared.  self assert: unprepared isEmpty.  self assert: (allItems collect: #position) asArray equals: (1 to: queryResult size) asArraycreateMethodGroupFor: aMethodQuery from: aClassScope  ^ClyAllCritiquesMethodGroup withMethods: aMethodQuery actualQuery from: aClassScopeactivateExtraScope  ^visibleClassScope increasedByClassesFrom: extraClassScope= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^resultItems = anObject resultItemstreeStructure: anObject  treeStructure := anObjecttestNotBasedOnMultipleBasisWhenSingleSubscopeIsNot  | subscope |  subscope := ClyScopeExample of: #basisObject in: environment.  scope := ClyCompositeScope on: {subscope}.  self deny: scope isBasedOnMultipleBasischeckEmptyResult  scope classVariablesDo: [:each |  ^false ].  ^truechangesAreAboutApply  | tagsEditor |  super changesAreAboutApply.  tagsEditor := statusBar findDeeplyA: ClyMethodTagsEditorMorph.  tagsEditor ifNil: [ ^self ].  tagsEditor acceptTagstestConvertingWithoutExistingBasisObject  | convertedScope |  scope := self multipleScopeSample.  convertedScope := scope withoutBasisObject: self extraBasisSample.  self assert: convertedScope class equals: scope class.  self deny: (convertedScope basisObjects includes: self extraBasisSample).  self assert: (convertedScope basisObjects includes: self singleBasisSample)decorateBrowserItem: anItem ofMethod: aMethod  aMethod isAbstract ifTrue: [ anItem markWith: ClyAbstractItemTag ].  (self isMethodOverriding: aMethod) ifTrue: [ anItem markWith: ClyOverridingMethodTag ].  (self isMethodOverridden: aMethod) ifTrue: [ anItem markWith: ClyOverriddenMethodTag ]testIsEmptyFromEmptyMethodScope  query scope: (ClyMethodScope emptyIn: environment).  self assert: query checkEmptyResultisResult: aQueryResult affectedBy: aSystemAnnouncement  ^(aSystemAnnouncement canAffectResultOfMethodQuery: self) and: [ scope includesMethodsAffectedBy: aSystemAnnouncement ]confirmUnusedVariablesInDefiningClass: variables  | refQuery classScope |  classScope := ClyBothMetaLevelClassScope ofAll: (variables collect: [:each |  each definingClass ]) in: navigationEnvironment.  refQuery := ClyVariableReferencesQuery ofAny: variables from: classScope.  ^self confirmEmptySystemQuery: refQuerydeselectTab  containerTab removeFromSelectiontestQueryResultShouldBeCached  | result1 result2 |  result1 := environment query: (self createQueryFromScopeOf: self class).  result2 := environment query: (self createQueryFromScopeOf: self class).  self assert: result1 identicalTo: result2defaultColor  ^Color transparent= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^sortFunction = anObject sortFunctionupdateItemWith: updatedEnvironmentItem  browserItem := updatedEnvironmentItemitem  ^itemupdateItems  | menu |  menu := CmdMenu activatedBy: ClyToolbarActivation.  browser navigationContextsDo: [:eachContext |  menu buildInContext: eachContext ].  self hide.  self removeAllMorphs.  [ menu buildBrowserToolbar: self ] ensure: [ self show ]attachToSystem  browser system when: (ClyPackageChange of: editingPackage) send: #triggerUpdate to: selfstartPosition  ^startPositionqueryResult: aQueryResult  queryResult := aQueryResult.  position := 0.  cache := ClyBrowserQueryCache withSize: 20.  itemCount := aQueryResult size.  metadata := queryResult metadatainitializeForBrowserStateSnapshot  selectedItems := selectedItems collect: [:each |  each copyForBrowserStateSnapshot ].  selectedItems do: [:each |  each ownerDataSource parentItem: nil ].  tool := nilprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browsertestFromThreeMethodsWhenImplementorsCacheShouldBeUsed  | plugin |  plugin := environment getPlugin: ClyInheritanceAnalysisEnvironmentPlugin.  plugin littleHierarchyMaxSize: -1.  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (ClyAbstractClassExample >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 overriddenMethod)findAnySelectorInSourceCode: selectors  | foundSelector foundNode positions ast |  ast := editingMethod astForStylingInCalypso.  foundNode := ast sendNodes detect: [:each |  selectors includes: (foundSelector := each selector) ] ifNone: [ ast allChildren detect: [:each |  each isLiteralNode and: [ selectors includes: each value ] ] ifFound: [:literal |  ^literal sourceInterval ].        ^0 to: -1 ].  positions := foundNode keywordsPositions.  ^positions first to: positions last + foundSelector keywords last size - 1checkEmptyResult  ^truetag  ^tagdefaultMenuItemName  ^'Flat'accumulateTestMethod: testMethod  self accumulateTest: testMethod selector of: testMethod methodClassdecorateTableCell: anItemCellMorph of: groupItem  super decorateTableCell: anItemCellMorph of: groupItem.  (groupItem isMarkedWith: ClyBackgroundProcessingTag) ifTrue: [ anItemCellMorph definitionMorph: ClyActivityAnimationIconMorph new ] ifFalse: [ methodQuery decorateMethodGroupTableCell: anItemCellMorph of: groupItem ]detachFromSystem  system unsubscribe: self.  plugins do: [:each |  each detachFromSystem ]childrenCount  ^ownerDataSource countChildrenOf: selfbuildLeftSideBar  super buildLeftSideBar.  self leftSideBar enableMouseCommands: CmdTextLeftBarClickActivation withContextFrom: selfisValidClass: inputClass  ^(inputClass isTestCase or: [ inputClass isMeta ]) notmethodWithCounter  ^1 + 2selectedClassItems  ^tool classSelection itemsprintAsConstantQueryItem  ^self namemethodGroupsDo: aBlock  | dynamicGroups groups |  dynamicGroups := OrderedCollection new.  self methodGroupProvidersDo: [:groupProvider |  groups := groupProvider buildGroupsFrom: self.        groupProvider isStatic ifTrue: [ groups do: aBlock ] ifFalse: [ dynamicGroups addAll: groups ] ].  self processDynamicMethodGroups: dynamicGroups by: aBlocktestConvertingToNewMetaLevel  | convertedScope |  scope := ClyCompositeScope on: {(ClyClassScope of: Object in: environment) .         (ClySubclassScope of: Array in: environment)}.  convertedScope := scope withMetaLevel: ClyInstanceSideScope.  self assert: convertedScope class equals: ClyCompositeScope.  self assert: convertedScope subscopes first equals: (ClyInstanceSideScope of: Object).  self assert: convertedScope subscopes last class equals: ClySubclassScope.  self assert: convertedScope subscopes last localScopeClass equals: ClyInstanceSideScope.  self assert: convertedScope environment equals: environment.  self assert: (convertedScope subscopes collect: #environment as: Set) equals: {environment} asSetdefaultItems  ^OrderedCollection newdecorateOwnBrowserItem: myItem  isScopedModeEnabled  ^packageView showsItemsFromScope: ClyPackageScopepackage: anObject  package := anObjecttestCheckIfEmpty  query tag: #Tag1.  query scope: (ClyClassScope of: ClyClass7WithTag1FromP5 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ClyClass8WithTag2FromP5 in: environment).  self assert: query checkEmptyResulttriggerClickCommands  CmdClickActivation executeCommandInContext: self createSelectionContextdefaultTitle  ^'Diff'refactoringScopes  ^self browser allNavigationScopesinstalledMethods  | onlyMethods actualMethods |  onlyMethods := methods select: [:each |  each isCompiledMethod ].  actualMethods := self filterInstalledMethods: onlyMethods , extraMethods.  ^actualMethods , (methods reject: [:each |  each isCompiledMethod ])extensionMethodFromClassItself  testCreationFromTwoQueriesOfSameTypeSimilarScope  | subquery1 subquery2 |  subquery1 := self subqueryFromScope: ClyScopeExample of: Array.  subquery2 := self subqueryFromScope: (ClyScopeExample ofAll: {String .               Array}).  query := subquery1 , subquery2.  self assert: query class equals: subquery1 class.  self deny: query identicalTo: subquery1.  self assert: query scope equals: (ClyScopeExample ofAll: {Array .               String} in: environment).  self assert: query requiredResult identicalTo: subquery1 requiredResultinitialize  super initialize.  self     color: self theme windowColor;     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     height: 0;     minHeight: 0;     layoutInset: 10 @ 2.  self buildContextBar.  self buildCommandBarcurrentScopeIndex: index  self currentScope: (self scopes at: index)createTab  | menu |  menu := CmdMenu activatedBy: ClyBrowserTabCommandActivation.  menu buildInContext: context.  containerTab := TabMorph label: self defaultTitle icon: self defaultIcon retrievingBlock: [ self buildAndDecorate ] actions: menu buildBrowserTabActions.  containerTab model: self.  ^containerTabattachToSystem  browser system when: (ClyClassChange of: editingClass) send: #triggerUpdate to: selfclassView  ^classViewtestThisClassShouldIncludeExpectedComment  self assert: (self class comment includesSubstring: self expectedClassCommentSubstring caseSensitive: false)classSampleWhichHasGroup  ^ClyAbstractClassExampleadoptForExtendedClass  | extendingPackages extraGroups |  self classSelection isEmpty ifTrue: [ ^self ].  methodGroupQuery := methodGroupQuery withoutItemsOfType: RPackage.  (self classSelection lastSelectedItem isMarkedWith: ClyExtendedClassTag) ifFalse: [ ^self ].  methodGroupQuery := ClyAllMethodGroupsQuery sortedFrom: self classScopeForMethods.  extendingPackages := self packageSelection actualObjects.  extraGroups := ClyConstantQuery returning: extendingPackages as: ClyGroupedExtendingPackages new.  extraGroups := methodGroupQuery scope adoptQuery: extraGroups.  methodGroupQuery := methodGroupQuery , extraGroupscreateQueryResult  ^ClyRawQueryResult newactiveScope: anObject  activeScope := anObjectdecorateContainerTab  selectMainTool  | desiredTools mainTool |  desiredTools := tools select: [:each |  desiredSelection includes: each class ].  desiredTools ifEmpty: [ desiredTools := tools ].  mainTool := desiredTools detectMax: [:each |  self activationPriorityOf: each ].  mainTool selectAsMainTab.  ^mainTooltestEmptyInPackageWithoutAnyTags  query scope: (ClyPackageScope of: ClyClass9FromPExtendedByP5 package in: environment).  self assert: query checkEmptyResultisTempVariableSelected  | node |  node := self selectedSourceNode.  ^node isVariable and: [ node isTemp ]textModel  ^textModeldetectDefiningClassFrom: anUserClass ifAbsent: aBlock  (anUserClass instanceSide classVariables includes: actualVariable) ifTrue: [ definingClass := anUserClass instanceSide.        ^self ].  anUserClass instanceSide sharedPools do: [:each |  self detectDefiningClassFrom: each ifAbsent: [  ].        definingClass ifNotNil: [ ^self ] ].  anUserClass isRootInEnvironment ifTrue: [ ^aBlock value ].  self detectDefiningClassFrom: anUserClass superclass ifAbsent: aBlocktestFillingWithOnePackage  | group |  queryResult fillWith: {ClyClass1FromP1 package}.  group := queryResult items first.  self assert: group class equals: ClyExternalPackageMethodGroup.  self assert: group package equals: ClyClass1FromP1 package.  self assert: group methodQuery equals: (ClyPackageExtensionMethodsQuery of: ClyClass1FromP1 package from: query scope)doesMethod: aMethod useAnyOf: vars  ^vars anySatisfy: [:each |  self doesMethod: aMethod useVar: each ]editingClass  ^self methodClasslastSelectedVariable  ^self lastSelectedObject variableimplementorMethod  ^implementorMethodtestRetrievesBrowserEnvironment  self snapshotState.  self assert: navigationState navigationEnvironment equals: environmentsetUpParametersFromModel  super setUpParametersFromModel.  self setUpTargetClassescreateSampleScope  self subclassResponsibilitytestMessageSend_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'val msg: arg') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: ((ThisContext lookupSymbol: #val) msg: (ThisContext lookupSymbol: #arg))]')isExpanded: aDataSourceItem  self subclassResponsibilitypackagesDo: aBlock  subscopes do: [:each |  each packagesDo: aBlock ]matchesByScript: anObject  badScript ifTrue: [ ^true ].  scriptBlock ifNil: [ self createBlockFromPattern ].  badScript ifTrue: [ ^true ].  ^[ (scriptBlock value: anObject) ~~ false ] ifError: [ false ]groupProviderClass  ^ClyWatchpointMethodGroupProviderupdate  self setUpParametersFromModel.  self decorateContainerTab.  self rebuildStatusBar.  self warnUserAboutChangedContextbrowser  ^toolselectedPackageItems  | unique packageItem |  unique := OrderedCollection new.  selectedItems do: [:each |  packageItem := each systemDefinition definingPackageItem.        unique detect: [:existing |  existing actualObject == packageItem actualObject ] ifNone: [ unique add: packageItem ] ].  ^uniquegroupProviderClass  ^ClyFFIMethodGroupProvidermeaningfullObjectToAssert: resultItem  ^resultItem actualObject methodQuery scope basisObjects anyOnetestFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(supeclassWriterOfVar1 writer1OfVar1 writer2OfVar1)textMorph: aTextMorph  textMorph := aTextMorph.  self attachToTextMorphaddExtraIcon: iconName  | icon |  icon := self iconNamed: iconName.  ^self addExtraTool: icon asMorphblock  ^blockprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  tagName := aToolContext requestSingleMethodTag: 'New protocol name'isRoot  ^ownerDataSource isRoot & browserItem isRootmethodsDo: aBlock  self classesDo: [:eachClass |  self metaLevelsOf: eachClass do: [:concreteMetaLevelClass |  concreteMetaLevelClass visibleMethods do: aBlock ] ]queryFromScope: scopeClass of: aBasisObject  query scope: (scopeClass of: aBasisObject in: environment).  self executeQuerytestDecoratingMethodWithExecutionCounter  | plugin method methodItem |  plugin := ClyReflectiveEnvironmentPlugin new.  self installCounterInto: #methodWithCounter.  method := self class >> #methodWithCounter.  methodItem := method asCalypsoBrowserItem.  plugin decorateBrowserItem: methodItem ofMethod: method.  self assert: (methodItem isMarkedWith: ClyMethodWithExecutionCounterTag)isClassSideMethodSelected  self isMethodSelected ifFalse: [ ^false ].  ^self selectedMethodItems anySatisfy: [:each |  each systemDefinition isInstanceSide not ]testFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(writer1OfVar1 writer2OfVar1)asUnifiedInstance  ^selfswitchScopeTo: aScope  self changeStateBy: [ systemQuery := systemQuery withScope: aScope.        self showQueryResult ]environment  scope ifNil: [ self error: 'Scope is not defined. So environment is undefined' ].  ^scope environmentattachToTextMorph  actualResult: anObject  actualResult := anObjectfileOut  classQuery scope packagesDo: [:each |  (each classTagNamed: self tag) fileOut ]iconName  ^iconNametestCreationOnTwoDifferentSubscopesOfSameObject  | subscope1 subscope2 |  subscope1 := ClyScopeExample ofAll: #(sameBasisObject basisObject1) in: environment.  subscope2 := ClyScopeExample2 ofAll: #(sameBasisObject basisObject2) in: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self assert: scope basisObjects asSet equals: #(sameBasisObject basisObject1 basisObject2) asSetcollectMetadataOf: aQueryResult by: anEnvironmentPlugin  anEnvironmentPlugin collectMetadataOfMethods: aQueryResultemptyScopeSample  ^self scopeClass emptyIn: environmentprotectItemsWhile: aBlock  ^self protectAccessWhile: [ self rebuildIfNeeded.        aBlock value ]defaultMenuIconName  ^#backasQueryResult  ^ClyHierarchicallySortedClasses with: selfbrowser  ^tool browserquery: aQuery  | result |  self cleanGarbageInCache.  result := queryCache at: aQuery ifAbsent: [ nil ].  result ifNil: [ result := aQuery prepareNewResult.        aQuery fixStateBeforeExecution.        accessGuard critical: [ queryCache at: aQuery put: result ] ].  result rebuildIfNeeded.  ^resultreset  properties removeAlltestNotExecutedFromMultipleScopeWhenAllSubqueriesAreFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self deny: query isExecutedFromMultipleScopepackage  ^methodQuery packagedefaultMenuIconName  ^#repairIconprocessQueue  [ | available next |  available := OrderedCollection with: updateQueue next.  [ next := updateQueue nextOrNil ] whileNotNil: [ available add: next ].  self runUpdateFor: available ] repeatdefaultMenuIconName  ^#classIcondecorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red.  anItemCellMorph definitionIcon: #haloViewbrowser  ^browserisResult: aQueryResult affectedBy: aSystemAnnouncement  ^falsetestFillingWithEmptyList  queryResult fillWith: {}.  self assertItems: {}= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^extraParameter = anObject extraParameterwithoutItemsOfType: anItemTypeClass  ^self withSubqueries: (subqueries reject: [:each |  each retrievesItemsOfType: anItemTypeClass ])showCritiques  criticView owner ifNotNil: [ ^self ].  originalToolPanel layoutFrame bottomFraction: 0.8.  browserTool addMorph: criticView fullFrame: (0 @ 0.8 corner: 1 @ 1) asLayoutFrame.  browserTool addPaneSplitterssetUpSelectedRows: indexes in: aTableMorph silently: silentSelection  silentSelection ifTrue: [ aTableMorph basicSelectIndexes: indexes ] ifFalse: [ aTableMorph basicSelectIndexes: #(-1000).        aTableMorph selectIndexes: indexes ]restoreBrowserInstance  self snapshotState.  navigationState applyTo: browserdefaultTitle  ^'Comment'testHasBasisCritiquesAsBaseQuery  query := query class new.  self assert: query baseCritiqueQuery class equals: ClyAllBasisCritiqueQuerybaseClass: anObject  baseClass := anObjectforceLazyRebuild  self protectAccessWhile: [ needsRebuild := true.        items := nil ]createQuery  ^ClyUnimplementedMethodsQuery from: ClyClassScope of: ClyClassWhichInheritsAbstractSubclass in: environmentinitialize  super initialize.  projectManager := ClyProjectManagerRegistry newhasMetaProperty: aPropertyClass  ^metadata hasProperty: aPropertyClasscreateQueryFromScope: aScope  aScope bindTo: environment.  ^ClyQueryExampleReturningScopeBasis from: aScopeactiveStatusBar  ^tabManager activeStatusBarisRoot  ^depth = 0execute  | classScope |  classScope := browser classSelection asItemsScope: ClyClassScope.  browser switchClassViewTo: self requiredQueryResult inScope: classScope , (classScope asScope: self traitScopeClass)groupProviderClass  ^ClyNoTagClassGroupProvidertestFillingWithItemsTwice  queryResult fillWith: #(1 2 3).  queryResult fillWith: #(4 5 6).  self assert: queryResult items asArray equals: #(1 2 3 4 5 6)systemDefinition  ^self getProperty: ClyItemDefinitionProperty ifAbsent: [ self error: 'No system definition is specified for item' ]updateLabel  | newValue |  newValue := textMorph lineNumbersRuler ifNil: [ '+L' ] ifNotNil: [ 'L' ].  label contents: newValuecreateQuery  ^ClyAbstractMethodsQuery from: ClyClassScope of: ClyAbstractClassExample in: environmenttestSelectsOverriddenMethod  self assert: (query selectsMethod: ClyAbstractClassExample >> #overriddenMethod)statusBar  ^statusBartestFromTwoMethods  self installWatchpointInto: #methodWithWatchpoint.  self queryFromScope: ClyMethodScope ofAll: {(self class >> #methodWithWatchpoint) .         (self class >> #methodWithoutWatchpoint)}.  self assert: foundSelectors sorted asArray equals: #(#methodWithWatchpoint)collectMetadataOf: aQueryResult by: anEnvironmentPlugin  self flag: #todoselectedMethods  ^{self selectedMethod}ownerDataSource: anObject  ownerDataSource := anObjectcreateQueryResult  ^ClyExtensionLastSortedClasses simpletabSelected: aTab  | oldTabs newTab browserState |  updatingStarted ifTrue: [ ^self ].  newTab := tools detect: [:each |  each containerTab == aTab ] ifNone: [ ^self ].  newTab takeKeyboardFocus.  oldTabs := tools select: [:each |  each isTabSelected & (each containerTab ~~ aTab) ].  oldTabs ifEmpty: [ ^self ].  desiredSelection removeAll.  browserState := browser snapshotState.  browserState selectedTabs: oldTabs.  browser recordNavigationState: browserState.  self swapPrioritiesBetween: newTab and: oldTabs firsttestMethodsDo: aBlock  methodDataSource queryResult rawItemsDo: [:eachMethod |  (eachMethod isTestMethod and: [ eachMethod methodClass isAbstract not ]) ifTrue: [ aBlock value: eachMethod ] ]unionWith: typedQueries as: aQueryResult  ^ClyQuery unionFrom: (typedQueries copyWith: self) as: aQueryResult= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^selectors = anObject selectorstargetVarName  self subclassResponsibilitycopyForBrowserStateSnapshot  ^self copyForBrowserStateSnapshotOf: ownerDataSource copyForBrowserStateSnapshotupdateDirtyState  | currentLabel |  self hasUnacceptedEdits == isDirty ifTrue: [ ^self ].  currentLabel := containerTab label morph contents.  isDirty := self hasUnacceptedEdits.  isDirty ifTrue: [ containerTab label: '*' , currentLabel ] ifFalse: [ (currentLabel beginsWith: '*') ifTrue: [ containerTab label: currentLabel allButFirst ] ]rawItemsDo: aBlock  ^items collect: [:each |  each actualObject ] thenDo: aBlockextraParameter  ^extraParameterdefaultMenuIconName  ^#smallWindowcreateQueryResult  ^ClyHierarchicallySortedClasses newtestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithFFIMethods >> #ffiMethod in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithFFIMethods >> #notFFIMethod in: environment).  self assert: query checkEmptyResultclose  lastFilteredDataSource ifNotNil: [ lastFilteredDataSource close ].  itemCursor := itemCursor closeclassSampleWhichHasGroup  ^ClyClassWithFlagstestClassEnumerationOverMetaclassBasisWhenInstanceSideIsLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyInstanceSideScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {Object .         ProtoObject} asSetshowSourceNode  tool selectSourceNode: selectedSourceNodetestComparisonOfSimilarQueriesWithDifferentScopes  | query2 |  query2 := self createQuery.  query scope: (ClyScopeExample of: #basisObject1 in: environment).  query2 scope: (ClyScopeExample of: #basisObject2 in: environment).  self deny: query equals: query2.  query2 scope: (ClyScopeExample2 of: #basisObject1 in: environment).  self deny: query equals: query2findItemsWith: actualObjects  ^self findAllItemsBy: [:ds |  ds findItemsWith: actualObjects ] stopLookupWhen: [:result |  result size = actualObjects size ]requestSinglePackage: queryTitle  ^tool searchDialog requestSingleObject: queryTitle from: ClyAllPackagesQuery sortedrestoreBrowserState  context restoreBrowserStatemethodGroup: anObject  methodGroup := anObjectisClassSelected: aClass  ^self classSelection items anySatisfy: [:each |  each actualObject == aClass or: [ each systemDefinition definingClass == aClass ] ]toggleExtendingPackage  super toggleExtendingPackage.  self hasUnacceptedEdits ifFalse: [ self packageEditingMethod: editingMethod ]adoptLocalScopeClassTo: aLocalScopeClass  self subclassResponsibilityisSlow  ^truemetaLevelScope  self subclassResponsibilitymethodGroupQuery: aQuery  methodGroupQuery := aQueryexpandChildren  self childrenDataSource: (ownerDataSource retrieveChildrenOf: self)expandedItems  ^expandedItemspackageEditingMethod: aMethod  self applyChangesBy: [ (extendingPackage notNil and: [ aMethod package ~~ extendingPackage ]) ifTrue: [ ^(SycMoveMethodsToPackageCommand for: {aMethod} to: extendingPackage) execute ].        (extendingPackage isNil and: [ aMethod isExtension ]) ifTrue: [ (SycMoveMethodsToPackageDefiningClassCommand for: {aMethod}) execute ] ]groupItemsByType  | groups |  groups := IdentityDictionary new.  items do: [:each |  | group |        group := groups at: each type ifAbsentPut: [ OrderedCollection new ].        group add: each actualObject ].  ^groupssystem  ^navigationEnvironment systemitems  self subclassResponsibilitysetUpParametersFromModel  methodQuery  ^methodQuerytestIsBasedOnSingleBasisWhenSingleSubscopeIs  | subscope |  subscope := ClyScopeExample of: #basisObject in: environment.  scope := ClyCompositeScope on: {subscope}.  self assert: scope isBasedOnSingleBasistestCheckIfEmpty  query scope: (ClyMethodScope of: ClyTestedClassTest >> #testExpectedFailure in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyTestedClassTest >> #testOne in: environment).  self assert: query checkEmptyResultcheckEmptyResult  scope variablesDo: [:each |  ^false ].  ^truebuild  radioButton := self theme newRadioButtonIn: World for: self getSelected: #isModeActive setSelected: #toggleMode: getEnabled: nil label: self title help: nil.  self addMorph: radioButtontestFindTestCaseCoveringUntestedClass  | foundClass |  foundClass := plugin findTestCaseCovering: ClyUntestedClass ifAbsent: [ #noResult ].  self assert: foundClass equals: #noResultcancelRebuild  items ifNil: [ self initializeItems ].  needsRebuild := falsedecorateBrowserItem: anItem ofClassGroup: aClassGroup  update: aSymbol  super update: aSymbol.  self updateMainWindowTitlesystem  ^systemcreateQueryResult  ^ClyAsyncQueryResult newtestMethodsEnumerationWhenBasisIsClass  scope := ClyBothMetaLevelClassScope of: ClyClass1FromP1.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyClass1FromP1 localMethods).  self assert: (result includesAll: ClyClass1FromP1 classSide localMethods)itemCache  ^itemCacheselectedClasses  ^self actualSelectionFrom: self selectedClassItemstestComparisonToSimilarResultButWithWithDifferentBaseResult  | result2 |  queryResult := ClyExtensionLastSortedClasses simple.  result2 := ClyExtensionLastSortedClasses hierarchical.  self deny: queryResult equals: result2testComparisonWithSimilarResult  | queryResult2 |  queryResult := self createQueryResult.  queryResult2 := self createQueryResult.  self assert: queryResult equals: queryResult2.  self assert: queryResult hash equals: queryResult2 hashremoveProperty: aProperty  properties remove: aProperty ifAbsent: [  ]createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'flags' priority: 8.3 on: aMethodQuerytestConvertingToNewMetaLevelShouldKeepScopeName  | convertedScope |  scope := ClyCompositeScope on: {(ClyClassScope of: Object in: environment) .         (ClySubclassScope of: Array in: environment)}.  scope name: 'test scope'.  convertedScope := scope withMetaLevel: ClyInstanceSideScope.  self assert: convertedScope name equals: 'test scope'classGroupsDo: aBlock  self classGroupProvidersDo: [:groupProvider |  groupProvider classGroupsIn: self do: [:group |  aBlock value: group ] ]defaultColor  ^Color transparentisAppliedToBrowser  ^browser isQueryScopeActive: queryScopetestFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}isExecutedFromEmptyScope  ^scope isBasedOnEmptyBasishasSelectedItems  ^selectedItems notEmptydefaultMenuItemName  ^'Invert hierarchy'retrievesItem: aMethod  ^self selectsMethod: aMethodstringPattern  ^stringPatternclassesDo: aBlock  basisObjects do: [:each |  self metaLevelsOf: each do: aBlock ]setUp  super setUp.  installedCounter := ClyMethodCallCountersQueryTest new     setUp;     installCounterInto: #methodWithCounterallItems  ^self itemsStartingAt: 1 count: self sizetestFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(classSideReference1OfClass reference1OfClass reference2OfClass)shouldBeProtectedByWriteBarrier  ^ShouldBeProtectedByWriteBarrier ifNil: [ ShouldBeProtectedByWriteBarrier := Smalltalk vm supportsWriteBarrier ]changesWasInitiatedByUser  ^changesWasInitiatedByUsercriteriaString: anObject  criteriaString := anObject asStringimportClass: aClass  testConvertingWithNewBasisObjects  | convertedScope |  scope := self singleScopeSample.  convertedScope := scope withNewBasisObjects: {self extraBasisSample}.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects asSet equals: {self extraBasisSample} asSet.  self assert: convertedScope basisSize equals: 1.  self assert: convertedScope environment notNil.  self assert: convertedScope environment equals: environmenttestItems: anObject  testItems := anObjectmouseEnter: evt  super mouseEnter: evt.  self currentHand showTemporaryCursor: Cursor webLinkmodifiesExtension  self subclassResponsibilitysubgroupsQuery  ^subgroupsQueryisResult: aQueryResult affectedBy: aSystemAnnouncement  ^subqueries anySatisfy: [:each |  each isResult: aQueryResult affectedBy: aSystemAnnouncement ]targetVarName  ^#writtenVar1testHasCompositeScopeFromSubqueries  < expectedFailure>  super testHasCompositeScopeFromSubqueriestestExecution  self executeQuery.  self assert: resultItems size equals: 1createToolbarItemFor: aCommandActivator  ^ClyBrowserModeSwitchMorph activatingBy: aCommandActivatorscopeClass  ^ClyPackageScopename  ^'Switch scope to'addIcon: anIcon  self addMorphFront: anIcon asMorphincludesMethodsAffectedBy: aSystemAnnouncement  ^basisObjects anySatisfy: [:each |  each includesMethodsAffectedBy: aSystemAnnouncement ]buildResult: aQueryResult  executionSemaphore wait.  super buildResult: aQueryResulttestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass2FromP1 >> #instanceSideClassVar1Reader in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self assert: query checkEmptyResulttestSelectsMethodWithBreakpoint  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  self assert: (query selectsMethod: ClyClassWithBreakpoints >> #methodWithBreakpoints)publishCollectedChanges  rightMethod  ^rightMethodtestUsingBadScriptWhichNotReturnBoolean  filter := ClyQueryBrowserFilter substringPattern: '[:each | each selector]'.  self assert: (filter matches: self itemOfThisTestMethod).  self assert: (filter matches: (ClyBrowserItem with: Object >> #printString))testIsEmptyFromEmptyClassScope  < expectedFailure>  super testIsEmptyFromEmptyClassScopeisBuilt  containerTab ifNil: [ ^false ].  ^containerTab morph == selfbuildCriticalTextSegmentsFor: anObject  | interval segment severity |  ^criticView dataSource allElements select: [:critique |  critique hasProperty: ClySourceNodeCritiqueIntervalProperty ] thenCollect: [:critique |  interval := critique getProperty: ClySourceNodeCritiqueIntervalProperty.        segment := ClyCriticalTextSegmentMorph from: interval start to: interval stop + 1.        severity := critique getProperty: ClyCritiqueSeverityProperty.        segment           label: critique name;           icon: (browserTool iconNamed: severity iconName);           color: severity color;           critique: critique actualObject;           entity: anObject;           yourself ]testFillingWithTwoClasses  queryResult fillWith: {Array .         String}.  self assert: queryResult items equals: {Array binding .         String binding}hash  ^super hash bitXor: subqueries hashtestForceLazyRebuildShouldNotResetExistingItems  self assert: queryResult items notNil.  queryResult forceLazyRebuild.  self assert: queryResult needsRebuild.  self assert: queryResult isBuilt.  self assert: queryResult items notNildoInOrder: blockWithClass  self rootsDo: [:root |  blockWithClass value: root.        self allChildrenOf: root do: blockWithClass ]collectMetadataOfMethods: aQueryResult  spawnBrowser: aBrowserClass withState: navigationBlock  | browser |  browser := aBrowserClass on: navigationEnvironment systemScope: self systemScope.  browser disablePluginsWhichAreNotIn: self.  browser prepareInitialStateBy: navigationBlock.  self openAnotherBrowser: browser.  browser wasSpawnedFrom: self.  ^browseractiveScope: anEnvironmentScope  activeScope := anEnvironmentScopetestConvertingToAsyncQuery  | convertedQuery |  convertedQuery := query async.  self assert: convertedQuery identicalTo: queryfindAnyVariableInSourceCode: varNames  | foundNode |  foundNode := editingMethod variableNodes detect: [:each |  varNames includes: each name ] ifNone: [ ^0 to: -1 ].  ^foundNode start to: foundNode stoprestoreStateOf: aBrowser  super restoreStateOf: aBrowser.  aBrowser     metaLevelScope: metaLevelScope;     methodGroupQuery: methodGroupQuerydefaultName  ^self class defaultNamecoveringTestCase  ^coveringTestCaseprepareExecutionInDragContext: aToolContext  super prepareExecutionInDragContext: aToolContext.  methodGroups := aToolContext selectedMethodGroupsexecute  ClyQueryBrowser browseBreakpointsremoveWithClasses  super removeWithClasses.  classQuery scope packagesDo: [:each |  each removeClassTag: self tag ]systemScope: aSystemScope  systemScope := aSystemScopeprintBasisOn: aStream  basisObjects ifEmpty: [ ^self ].  basisObjects do: [:each |  self printBasisObject: each on: aStream.        aStream nextPutAll: ', ' ].  aStream skip: -2sortFunction  ^sortFunctionexecuteQuery  super executeQuery.  foundSelectors := (resultItems collect: #selector) sorted asArraycreateUpdateWithItemsStartingAt: startPosition count: cacheSize  | itemCache |  itemCache := ClyBrowserQueryCache filledBy: self startingAt: startPosition size: cacheSize.  ^ClyBrowserQueryUpdate of: self withItems: itemCachetestEmptySubscopesAreForbidden  [ ClyCompositeScope on: #().  self assert: false description: 'empty subscopes should be forbidden' ] ifError: [  ]compileANewClassFrom: aString notifying: aController startingFrom: aClass  | oldClass class newClassName defTokens keywdIx classCompiler |  oldClass := aClass.  defTokens := aString findTokens: Character separators.  ((defTokens first = 'Trait' and: [ defTokens second = 'named:' ]) or: [ defTokens second = 'classTrait' ]) ifTrue: [ ^self defineTrait: aString notifying: aController startingFrom: aClass ].  keywdIx := defTokens findFirst: [:x |  x beginsWith: 'category' ].  keywdIx := defTokens findFirst: [:x |  '*subclass*' match: x ].  newClassName := (defTokens at: keywdIx + 1) copyWithoutAll: '#()'.  ((oldClass isNil or: [ oldClass instanceSide name asString ~= newClassName ]) and: [ self includesClassNamed: newClassName asSymbol ]) ifTrue: [ (self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size)) ifFalse: [ ^nil ] ].  oldClass ifNil: [ classCompiler := self defaultClassCompiler ] ifNotNil: [ classCompiler := oldClass superclass subclassDefinerClass new ].  class := classCompiler     source: aString;     requestor: aController;     logged: true;     evaluate.  ^class isBehavior ifTrue: [ class ] ifFalse: [ nil ]isAccessibleFrom: aClass  self subclassResponsibilitywrapRawItems: objects startingAt: firstItemIndex  | result |  result := objects collect: [:each |  each asCalypsoBrowserItem ].  result doWithIndex: [:each :i |  each position: firstItemIndex + i - 1.        each prepareIn: self environment ].  ^resultrefreshCritiques  browserTool decorateByCritic: self.  criticView dataSource isEmpty ifTrue: [ self hideCritiques ] ifFalse: [ self showCritiques ].  (criticView dataSource hasMetaProperty: ClyBackgroundProcessingTag) ifFalse: [ progressMorph delete.        browserTool statusBar update ] ifTrue: [ browserTool statusBar addContextItem: progressMorph ]testFromSingleClass  | varNames |  self queryFromScope: ClyClassScope of: ClyClass2FromP1.  varNames := resultItems collect: #name as: Set.  self assert: varNames equals: ClyClass2FromP1 instVarNames asSetfillWith: variables  | typedGroups |  typedGroups := self groupVariablesByTypeAndDefinition: variables.  self fillWithGroupedVariables: typedGroupsrequestConditionBlock  | script |  script := 'true'.  script := UIManager default request: 'This expression will be evaluated in the context of the position of this breakpoint.		You can use variables, globals, `thisContext`, `self` and `super`.		`:=` and Pool variables are not supported`' initialAnswer: script title: 'Break on what condition?'.  script isEmptyOrNil ifTrue: [ CmdCommandAborted signal ].  ^self generateConditionBlockFrom: scriptisEmpty  ^items isEmptyclasses  ^self environment ask allClassesrequestSingleObject: dialogTitle from: aQuery  self openOn: aQuery withTitle: dialogTitle thenDo: [ itemsView selection isEmpty ifTrue: [ ^self findObjectsSameAsFilter ifEmpty: [ CmdCommandAborted signal ] ifNotEmpty: [:items |  items first ] ].        ^itemsView selection lastSelectedItem actualObject ]testNotExecutedFromMultipleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  query subqueries: {(self subqueryFromScope: ClyScopeExample of: self class) .         (self subqueryFromScope: ClyScopeExample2 of: self class)}.  self deny: query isExecutedFromMultipleScopecreateQuery  ^ClyAllExtensionMethodsQuery from: ClyClassScope of: Object in: environmentshowInheritedMethods: aBoolean  | newScope |  self isMethodsVisible == aBoolean ifTrue: [ ^self ].  newScope := visibilityLevel toggleScope.  newScope isBasedOnEmptyBasis ifFalse: [ browser restrictMethodVisibilityBy: newScope ]itemsStartingAt: startIndex count: size  ^self protectItemsWhile: [ items copyFrom: startIndex to: (startIndex + size - 1 min: items size) ]createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'overridden' priority: -10 on: aMethodQueryisAppliedToBrowser  ^browser isInProjectViewpattern: aString  | newPattern |  newPattern := stringPattern copy.  newPattern value: aString.  ^itemFilterClass pattern: newPatternemptyBarWithWidth: aNumber  | bar |  bar := Morph new.  bar     setNamePropertyTo: 'emptyBar';     color: Color transparent;     changeTableLayout;     vResizing: #spaceFill;     hResizing: #rigid;     minWidth: 0;     width: aNumber.  ^bartestNotSelectsMethodWithoutExpectedFailurePragma  self deny: (query selectsMethod: ClyTestedClassTest >> #testOne)createFixedRegexMatcherIfFailed: errorBlock  | fixedPattern |  fixedPattern := value copyReplaceAll: '*' with: '.*'.  ^[ fixedPattern asRegexIgnoringCase ] on: RegexSyntaxError do: [:ex |  errorBlock value ]newName  ^newNameimplementorMethod: anObject  implementorMethod := anObjecttestMakeQueryScopeOfResultAsReadOnlyObjectWhenItIsExecuted  | query |  query := self createQueryFromScopeOf: self class.  environment query: query.  self assert: query scope isReadOnlyObjecttestMatchesMethodOfClassWhichMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'FilterTest'.  self assert: (filter matches: self itemOfThisTestMethod)ownerTool: anObject  super ownerTool: anObjectsubclassN2VarWriterMethod  subclassN2Var := #subclassN2VarValuedecorateTool: aBrowserTool  isQueryEmpty: aQuery  | result |  result := queryCache at: aQuery ifAbsent: [ nil ].  result ifNotNil: [ result isBuilt ifTrue: [ ^result isEmpty ] ].  ^aQuery checkEmptyResultloadItemsOf: aBrowserQueryResult startingWhere: conditionBlock  | newItems |  newItems := aBrowserQueryResult itemsStartingWhere: conditionBlock count: sizeLimit.  newItems ifEmpty: [ ^false ].  startPosition := newItems first position.  items := newItems.  ^trueselectMethodsIn: aQueryBrowser  browserTool: aTextEditorTool  browserTool := aTextEditorToolpackage: anObject  package := anObjectasRBEnvironment  ^RBPackageEnvironment packages: basisObjectsisAutoActivated  ^self class isAutoActivatedcreateQueryResult  self subclassResponsibilitybuildResetButton  resetButton := IconicButton new     target: self;     actionSelector: #resetTagsAndPackage;     arguments: #();     labelGraphic: (self iconNamed: #glamorousClose);     color: Color transparent;     borderWidth: 0;     hResizing: #shinkWrap;     layoutInset: 4 @ 0hash  ^super hash bitXor: extraParameter hashtestIsBasedOnEmptyBasisWhenAllSubscopesHaveEmptyBasis  | subscope1 subscope2 |  subscope1 := ClyScopeExample emptyIn: environment.  subscope2 := ClyScopeExample emptyIn: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self assert: scope isBasedOnEmptyBasisloadCritiquesAsync  ^critiqueQuery async executecheckEmptyResult  scope classesDo: [:eachClass |  (self isClassHasToBeImplemented: eachClass) ifTrue: [ ^false ] ].  ^trueinitialize  super initialize.  startPosition := 0.  items := Array emptyisMethodSelected: aMethod  ^self methodSelection includesActualObject: aMethodresultItems  ^resultItemstestFromPackageWithExtensionsButWithoutTags  self queryFromScope: ClyPackageScope of: ClyClass1FromP1 package.  self assert: resultItems isEmptymethodsDo: aBlock  self classesDo: [:eachClass |  eachClass methods do: aBlock ]scopedMethods  | installedMethods scopedMethods |  installedMethods := self installedMethods.  scopedMethods := IdentitySet new.  scope methodsDo: [:each |  (installedMethods includes: each) ifTrue: [ scopedMethods add: each.              installedMethods remove: each.              installedMethods ifEmpty: [ ^scopedMethods ] ] ].  ^scopedMethodsselectedSourceNode: anObject  selectedSourceNode := anObjectsubscribe: anObject  metaLevelScope: anObject  metaLevelScope := anObjectbasisObjects  ^basisObjectshasChildAt: ownerDataSourceIndex  ^ownerDataSourceIndex > self position and: [ ownerDataSourceIndex <= (self position + self childrenCount) ]isCommandAvailable: aCommand  ^aCommand canBeExecutedInClassEditor: selfdecorateBrowserItem: anItem ofClass: aClass  (aClass classSide includesLocalSelector: #isAbstract) ifTrue: [ aClass instanceSide isAbstract ifTrue: [ anItem markWith: ClyAbstractItemTag ].        ^self ].  (self checkClassIsAbstract: aClass) ifTrue: [ anItem markWith: ClyAbstractItemTag ]testDecoratingMethodWithBreakpoint  | plugin method methodItem |  plugin := ClyReflectiveEnvironmentPlugin new.  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  method := ClyClassWithBreakpoints >> #methodWithBreakpoints.  methodItem := method asCalypsoBrowserItem.  plugin decorateBrowserItem: methodItem ofMethod: method.  self assert: (methodItem isMarkedWith: ClyMethodWithBreakpointTag).  self deny: (methodItem isMarkedWith: ClyMethodWithHaltTag)collapse: aDataSourceItem  self subclassResponsibility= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^methods = anObject methodsscopeClass  ^ClyClassScopesupeclassReferenceOfVar1  ^referencedVar1rawResultItems  ^queryResult itemsselectedMethodGroupItems  ^tool methodGroupSelection itemsasUnifiedInstance  ^self withNewBasisObjects: #()cancel  self browserTool cancelChangesrestrictedByScope: aScope  | newSubqueries |  newSubqueries := subqueries collect: [:each |  each restrictedByScope: aScope ].  ^self withSubqueries: newSubqueriesparentItem  ^ownerDataSource isRoot ifTrue: [ nil ] ifFalse: [ ownerDataSource parentItem ]collectMethodGroupProviders  ^#()testFindTestedClassCoveredByTestCaseWhenItAbsent  | foundClass |  foundClass := plugin findTestedClassCoveredBy: ClyAbstractlyNamedTest ifAbsent: [ #noResult ].  self assert: foundClass equals: #noResultexecutesQuery: aTypedQueryClass  ^subqueries anySatisfy: [:each |  each executesQuery: aTypedQueryClass ]selectsClass: aClass  ^aClass hasComment and: [ pattern matches: aClass comment ]description  ^'critiques of scope basis'testFixingStateBeforeExecutionShouldFixSubqueriesState  query fixStateBeforeExecution.  query subqueries do: [:each |  self assert: each isReadOnlyObject.        self assert: each scope isReadOnlyObject ]resultView  ^resultViewcreateQuery  ^ClyFilterQuery for: (ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: self class in: environment) filter: (ClyItemNameFilter substringPattern: 'FilterQueryTest')queryClass  ^ClyVariableReadersQueryprojectQueryFor: aClySystemEnvironmentScope  ^ClyUnknownQuery instancedefaultMenuItemName  ^'Invert hierarchy'selectVariableNamed: aString  | classDefinition varNode |  classDefinition := self parseClassDefinition.  varNode := classDefinition children detect: [:each |  each isVariable and: [ each name = aString ] ] ifNone: [ ^self ].  self selectSourceNode: varNodetabOrder  ^self class tabOrderitems  ^itemshandlesAnnouncement: anAnnouncement  ^anAnnouncement affectsPackage: affectedPackagetestMethodsEnumeration  | expected |  scope := ClySuperclassScope of: ClyClass1FromP1.  scope methodsDo: [:each |  result add: each ].  expected := {Object .   ProtoObject} flatCollect: #localMethods as: IdentitySet.  self assert: result asIdentitySet equals: expectedexecute  CriticBrowser openOnRule: ReRuleManager uniqueInstance allRules onEnvironment: (RBPackageEnvironment packages: packages)selectPackage: aPackage atClassTag: tagName  | packageItem targetClassGroup foundPackages |  self changeStateBy: [ foundPackages := packageView findItemsWith: {aPackage}.        foundPackages ifEmpty: [ self switchToPackages.              foundPackages := packageView findItemsWith: {aPackage} ].        packageItem := foundPackages first.        packageItem expand.        targetClassGroup := packageItem childrenItems detect: [:each |  each name = tagName ].        packageView selection selectItems: {targetClassGroup} ]defaultMenuItemName  ^self methodGroupType shortNameasUnifiedInstance  ^selfdefaultMenuItemName  ^'Browse critiques'prepareNewResult  ^requiredResult prepareNewFor: self in: self environmentabstractMethod1  ^#resultbrowser: anObject  browser := anObjecttestCaseInsensitiveByDefault  | pattern |  pattern := ClySubstringPattern with: 'subString'.  self deny: pattern isCaseSensitivetoolbar  ^toolbarprovidesMethodGroup  ^providesMethodGroupname  ^nameselectedClassItems  ^self selectedItemsOfType: ClyClasspackageCommentBlank  ^'Please comment package here'createQueryResult  ^ClyBrowserQueryResultExample newmethod1  ^#method1testRepresentsClassOfScope  scope := self createSampleScope.  self assert: (scope representsScope: ClyScopeExample).  self assert: (scope representsScope: ClyTypedScope).  self deny: (scope representsScope: String)removePackage: aPackage  packageOrganizer unregisterPackage: aPackagebuildWindow  | window |  window := (SystemWindow labelled: self newWindowTitle) model: self.  window     addMorph: self frame: (0 @ 0 extent: 1 @ 1);     updatePaneColors.  ^windowwasSpawnedFrom: aBrowser  self recordNavigationState: (ClyAccrossWindowNavigationState from: aBrowser)size  ^actualResult sizetestDetectingDefiningClassFromSubclass  | varBinding var |  varBinding := ClyClass2FromP1 classVariableNamed: #ClassVar1.  var := ClyClassVariable on: varBinding visibleFrom: ClySubclassLOfClass2FromP1.  self assert: var definingClass equals: ClyClass2FromP1globals  ^globalstestExecutionOverExistingQuery  | scope mainQuery |  scope := ClyScopeExample ofAll: {self class superclass .         self class} in: environment.  mainQuery := ClyQueryExampleReturningScopeBasis from: scope.  query := mainQuery filteredBy: query itemFilter.  result := query execute.  resultItems := result items.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self classselectedClass  ^self selectedSourceNode binding valuerunTestCase: testCase  | testResult |  testResult := testCase classForTestResult new.  self runTestCase: testCase results: testResult.  testResult updateResultsInHistory.  self notifyUserAboutResults: testResult with: testCase nameretrievesItemsOfType: itemTypeClass  ^falseselection  self isFilterChanged ifTrue: [ self initiateUIChangeBy: [ self updateSelection ] ].  selection updateIfDirty.  ^selectionisExtensionMethodSelected  self isMethodSelected ifFalse: [ ^false ].  ^self selectedMethodItems anySatisfy: [:each |  each systemDefinition isExtension ]decorateContainerTab  | title |  super decorateContainerTab.  title := editingMethod selector.  editingMethod origin isClassSide ifTrue: [ title := title asText allBold asStringMorph ].  containerTab label: titleselectMethodsIn: aQueryBrowser  aQueryBrowser selectObject: methods lastdefaultMenuItemName  ^'Browse dependencies'testFromSingleClass  self queryFromScope: ClyClassScope of: ClyClass1FromP1.  self assert: foundSelectors equals: #(#instanceSideVar1ReaderMethod #instanceSideVar1WriterMethod #superclassTag1Method #tag1Method1)groupProviderClass  ^ClyDeprecatedMethodGroupProvidertestVariablesEnumerationForClassWithInstanceVariables  scope := ClyClassScope of: ClyClass1FromP1.  scope variablesDo: [:each |  result add: each ].  self assert: (result as: Set) equals: {(ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)} asSettextArea  ^textMorph textAreaoverridenPriorityOf: aBrowserTool  ^selectionPriorities at: aBrowserTool class ifAbsent: [ aBrowserTool activationPriority ]restoreBrowserState  browser selectClass: methodClassdescription  ^'abstract methods'decorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color redtestCheckIfEmpty  query scope: (ClyMethodScope of: ClyAbstractClassExample >> #abstractMethod1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: Object >> #printString in: environment).  self assert: query checkEmptyResultisSimilarTo: anotherBrowserItem  type = anotherBrowserItem type ifFalse: [ ^false ].  ^name = anotherBrowserItem name or: [ self isEqualTo: anotherBrowserItem ]testFillingWithObjectAndTwoProtoObjects  queryResult fillWith: {Object .         ProtoObject .         ProtoObject}.  self assertItems: {ProtoObject .         0 .         Object .         1}wantsTextStyling  ^falsetag: anObject  tag := anObjectselectsMethod: aMethod  ^aMethod hasPragmaNamed: #expectedFailuredataSource: aDataSource  self changeStateBy: [ self closeDataSource.        self setUpDataSource: aDataSource.        self refreshTable ]tagName  ^tagNamecreateQuery  | scope |  scope := ClyInstanceSideScope ofAll: {Object .         Array .         String} in: environment.  ^ClyAllClassesQuery from: scopedefaultMenuItemName  ^'Add watchpoint'extendingPackage: aPackage  super extendingPackage: aPackage.  self hasUnacceptedEdits ifFalse: [ self packageEditingMethod: editingMethod ]createQuery  ^ClyAllClassesQuery from: ClyClassScope of: Object in: environmentdecorateBrowserItem: anItem ofMethod: aMethod  | testMethod testResult |  aMethod isTestMethod ifTrue: [ ^self ].  testMethod := self findTestMethodCovering: aMethod ifAbsent: [ ^self ].  testResult := ClyTestResultProperty ofMethod: testMethod.  anItem addProperty: (ClyTestedMethodProperty coveringTest: testMethod result: testResult)providesGroupsAffectedBy: aSystemAnnouncement inScope: aClassScope  aClassScope classesDo: [:each |  (aSystemAnnouncement affectsClass: each) ifTrue: [ ^true ] ].  ^falseprojects  ^projectManagers flatCollect: [:each |  each projects ]description  ^'expected failures'belongsToRemovedBrowserContext  ^falsecreateQuery  ^ClyAllClassGroupsQuery from: ClyPackageScope of: Object package in: environmentisAfter: ownerIndex  ^ownerIndex <= self positiontestVariablesEnumerationWhenThereAreNoVariables  scope := ClyClassScope of: ProtoObject.  scope variablesDo: [:each |  result add: each ].  self assert: result isEmptyrequestTag  | selectedTag existingTag |  existingTag := ownerTool methodTags ifEmpty: [ '' ] ifNotEmpty: [:tags |  tags anyOne ].  selectedTag := self ownerTool context requestSingleMethodTag: 'New protocol name' suggesting: existingTag.  selectedTag = existingTag ifTrue: [ ^CmdCommandAborted signal ].  ownerTool methodTags: {selectedTag asSymbol}execute  | repoBrowser commitBrowser repos targetRepo |  repoBrowser := self class environment at: #IceTipRepositoriesBrowser ifAbsent: [ ^self inform: 'Iceberg 0.7 and higher is required' ].  commitBrowser := self class environment at: #IceTipCommitBrowser ifAbsent: [ ^self inform: 'Iceberg 0.7 and higher is required' ].  packages ifEmpty: [ ^repoBrowser new openWithSpec ].  repos := IceRepository registry select: [:repo |  packages anySatisfy: [:each |  repo includesPackageNamed: each name ] ].  repos ifEmpty: [ ^self inform: 'Selected packages are not managed by Iceberg' ].  targetRepo := repos size = 1 ifTrue: [ repos first ] ifFalse: [ UIManager default chooseFrom: (repos collect: #name) values: repos title: 'Choose repository' ].  targetRepo ifNil: [ ^self ].  (targetRepo isMissing or: [ targetRepo isCodeMissing or: [ targetRepo isDetached or: [ targetRepo hasUnbornProject ] ] ]) ifTrue: [ UIManager default alert: 'The ' , targetRepo name , ' repository is not operational to commit.Causes can be:- The local repository is missing- The code directory is missing- The project is in detached head state- Metadatas are missing.You can fix this problem using the Iceberg tool.' title: 'Error'.        ^self ].  (commitBrowser onRepository: targetRepo) openWithSpecwithMetaLevelScope: aScopeClass  ^self withScope: (scope withMetaLevel: aScopeClass)createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'counters' priority: 8.4 on: aMethodQuerywithoutItemsOfType: anItemTypeClass  self subclassResponsibilitysingleBasisSample  ^ClyClass1FromP1 packagetestFillingWithItems  queryResult fillWith: #(1 2 3).  self assert: queryResult items asArray equals: #(1 2 3)executeOn: aClass  ^aClass instanceSide perform: implementorMethod selectorpackages  ^packageOrganizer packagesbuildIndexes  items withIndexDo: [:each :index |  each position: index ]testComparisonOfSameQueries  | query2 |  self assert: query equals: query.  query2 := self createQuery.  self assert: query equals: query2.  self assert: query hash equals: query2 hashwantsDropElements: aPassanger type: type index: rowIndex  | dropTargetItem result |  rowIndex = 0 | (rowIndex > self numberOfRows) ifTrue: [ ^false ].  self dragTransferType == type ifFalse: [ ^false ].  dropTargetItem := self elementAt: rowIndex.  result := queryView wantsDropPassenger: aPassanger at: dropTargetItem.  result & dropTargetItem hasChildren ifTrue: [ dropTargetItem expand ].  ^resultmethodWithHalt2  self halttestFillingWithSingleClassVar  | classVarGroup |  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyMethodGroup .         0}.  classVarGroup := items last actualObject.  self assert: classVarGroup methodQuery class equals: ClyVariableReferencesQuery.  self assert: classVarGroup methodQuery variableQuery class equals: ClyAllClassVariablesQuery.  self assert: classVarGroup subgroupsQuery class equals: ClyAllClassVariablesQuery.  self assert: classVarGroup subgroupsQuery requiredResult class equals: ClyGroupedClassVariables.  self assert: classVarGroup subgroupsQuery requiredResult hierarchy equals: queryResult hierarchyasTraitVisibility  self subclassResponsibilitynavigationHistory  ^navigationHistorycreateClassQueryFrom: aPackageScope  self subclassResponsibilityaffectedMethod: anObject  affectedMethod := anObjectbuildResult: aQueryResult  | foundClasses |  scope packagesDo: [:each |  each tagsForClasses ifNotEmpty: [ foundClasses := scope query: ClyUntaggedClassesQuery new.              ^aQueryResult fillWith: foundClasses rawItems ] ]rebuildStatusBar  self isBuilt ifFalse: [ ^self ].  statusBar clear.  self fillStatusBarprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  methodGroup := aToolContext lastSelectedMethodGroup.  newName := aToolContext requestSingleMethodTag: 'New name of protocol' suggesting: methodGroup name.  newName = methodGroup name ifTrue: [ CmdCommandAborted signal ]asLocalClassScope  | newSubscopes |  newSubscopes := subscopes collect: [:each |  each asLocalClassScope ].  ^ClyCompositeScope on: newSubscopes in: environmentisAbstractMethod: aMethod  ^aMethod sendsSelector: #subclassResponsibilityaddBarForFullIndentation  | mainItemsCount absentItemsCount requiredWidth |  mainItemsCount := 0.  absentItemsCount := mainItemsCount - submorphs size.  requiredWidth := absentItemsCount * 16 + (self itemDepth * 8).  requiredWidth = 0 ifTrue: [ ^self ].  self addMorphBack: (self emptyBarWithWidth: requiredWidth)checkEmptyResult  scope classesDo: [:each |  (self selectsClass: each) ifTrue: [ ^false ] ].  ^trueselectsCritique: aCritique  ^aCritique rule group = groupNameadoptQuery: aQuery  self subclassResponsibility= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^classQuery = anObject classQuerytestRetrievesQueryScopes  self snapshotState.  self assert: navigationState queryScopes equals: browser queryScopessuccessCount  ^successCountextendingPackage  ^extendingPackagedefaultMenuItemName  ^self metaLevelScope defaultName capitalizedbindTo: aNavigationEnvironment  super bindTo: aNavigationEnvironment.  subscopes do: [:each |  each bindTo: aNavigationEnvironment ]definingClass  ^definingClasstestClassesEnumeration  scope := ClyPackageExtensionScope of: ClyClass1FromP1 package.  scope classesDo: [:each |  result add: each ].  self deny: (result includesAll: ClyClass1FromP1 package definedClasses).  self assert: (result includesAll: ClyClass1FromP1 package extendedClasses)getProperty: propertyClass  ^properties detect: [:each |  each isKindOf: propertyClass ]description  ^''definingClass: aClass  definingClassItem := ClyBrowserItem named: aClass name with: aClassprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browsercollectCommandCandidatesInContext: aContext  | allActivators allCommands |  allActivators := CmdContextMenuActivation createActivatorsExecutableInContext: aContext.  allCommands := allActivators collect: [:each |  each command class ] as: IdentitySet.  CmdMenuCommandActivationStrategy allSubclassesDo: [:eachStrategy |  eachStrategy activateAllInContext: aContext by: [:eachActivator |  (allCommands includes: eachActivator command class) ifFalse: [ allActivators add: eachActivator.                    allCommands add: eachActivator command class ] ] ].  ^allActivatorsplugins  ^pluginscreateMethodQueryFrom: aClassScope  ^ClyAbstractMethodsQuery from: aClassScopeisMethodGroupSelected  ^self selectedMethodGroupItems notEmptycollectMethodGroupProviders  ^{ClyFailedTestGroupProvider new .   ClyExpectedFailureMethodGroupProvider new}textChanged: aTextChanged  changesCancelRequested ifTrue: [ changesCancelRequested := false.        ^self changesCancelled ].  self updateDirtyStatedefaultMenuItemName  ^'Rename'scopeClass  self subclassResponsibilityfindItemsWhere: conditionBlock  | foundItems |  foundItems := self itemCursor findItemsWhere: conditionBlock.  ^foundItems collect: [:each |  self createElementWith: each ]initialize  super initialize.  direction := 1fillWithGroupedVariables: varsPerTypeAndDefiningClass  varsPerTypeAndDefiningClass at: ClyClassVariable ifPresent: [:classVarsPerClass |  self fillWithVariables: classVarsPerClass type: ClyClassVariable ]currentScope: aScope  browser switchScopeTo: aScope.  dropList setBalloonText: aScope descriptionbuildingQuery  ^actualResult buildingQuerycopyForBrowserStateSnapshotOf: aDataSource  | copy |  copy := self asDesiredSelection.  copy rootDataSource: aDataSource.  copy items: (items collect: [:each |  each copyForBrowserStateSnapshotOf: aDataSource ]).  ^copyroots  ^rootsdialogClass: anObject  dialogClass := anObjectitemOfThisTestClass  ^ClyBrowserItem with: self classclose  openedBrowser ifNotNil: #closeaddProperty: aProperty  properties add: aPropertyaddNewItem: aMorph  self addMorphBack: aMorphselectMethod: aMethod  self selectObject: aMethodinitialize  super initialize.  self     color: self theme windowColor;     changeTableLayout;     height: self defaultHeight;     layoutInset: 2 @ 0;     listDirection: #leftToRight;     wrapCentering: #center;     hResizing: #spaceFill;     vResizing: #rigidposition  ^positiondecorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph definitionIcon: #smallDebugloadAsyncQueryResult  ^methodQuery loadCritiquesAsynctestRetrievesPlugins  browser addPlugin: ClyStandardBrowserPlugin new.  self snapshotState.  self assert: navigationState browserPlugins first class equals: ClyStandardBrowserPluginparentGlobalPosition  ^parentItem ifNil: [ 0 ] ifNotNil: [ parentItem globalPosition ]queryResult  ^self itemCursor queryResultclasses  ^classQuery execute itemstestConvertingToScopeIncludedInheritedScope  | convertedScope inheritedScope |  scope := self createSampleScope.  inheritedScope := scope asInheritedScope.  convertedScope := scope withInheritedScope.  self assert: convertedScope class equals: ClyCompositeScope.  self assert: convertedScope name equals: ClyClassScope hierarchyScopeName.  self assert: (convertedScope subscopes includes: scope).  self assert: (convertedScope subscopes includes: inheritedScope)queryView  ^queryViewrepresentsScope: aScopeClass  ^(super representsScope: aScopeClass) or: [ relationScopeClasses anySatisfy: [:each |  each includesBehavior: aScopeClass ] ]selectedClassOrMetaClass  ^niltestFindItemsUsingPredicateWhenTheyAreNotInCache  | allItems |  cursor cleanCache.  allItems := cursor findItemsWhere: [:each |  each actualObject = Object ].  self assert: allItems size equals: 1.  self assert: allItems first actualObject equals: Object.  self assert: allItems first isPrepared.  self assert: allItems first position equals: 2checkEmptyResult  scope methodGroupsDo: [:each |  ^false ].  ^trueprojectManagers: anObject  projectManagers := anObjecttestRan: aTestSuiteEnded  | event |  event := ClyTestCaseRan testCase: aTestSuiteEnded testResult.  environment systemChanged: eventtestConvertingToInterestingClassScope  | convertedScope |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope asInterestingClassScope.  self assert: convertedScope class equals: ClyInterestingSuperclassScope.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope localScopeClass equals: scope localScopeClass.  self assert: convertedScope environment equals: scope environmenttestFillingWithTraitsOfClassWhichIsMissingInGivenList  queryResult fillWith: {ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyTraitChild1 .         0 .         ClyTraitRoot1 .         1 .         ClyTraitChild2Child .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot1 .         2}defaultBorderWidth  ^0createMethodQueryFrom: aClassScope  ^ClyFlaggingMethodsQuery from: aClassScopeupdateLabel  | newValue |  newValue := textMorph wrapped ifTrue: [ 'W' ] ifFalse: [ 'NW' ].  wrapModeLabel contents: newValuequery: anObject  query := anObjectdefaultMenuIconName  ^#smallCancelIcontestFillingWithClassesFromOneHierarchy  queryResult fillWith: {ClySubclassN1OfClass1FromP1 .         ClySubclassLOfSubclassMFromP3 .         ClyClass1FromP1 .         ClySubclassN2OfClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1 .         ClySubclassN1OfClass1FromP1 .         1 .         ClySubclassN2OfClass1FromP1 .         1}editingPackage  ^editingPackagetabMorph  ^tabMorphsystemScope  ^system asGlobalScopeIn: selfdefaultToolbarItemName  ^queryScope descriptionclassesDo: aBlock  basisObjects do: [:each |  aBlock value: each instanceSide ]restoreBrowserWindow  | newBrowser |  window isInWorld ifFalse: [ newBrowser := self createBrowser.        window addMorph: newBrowser frame: (0 @ 0 extent: 1 @ 1).        window model: newBrowser.        browserState applyTo: newBrowser ].  windowGroup ifNil: [ window isInWorld ifTrue: [ window                 comeToFront;                 activate ] ifFalse: [ window openAsIs ] ] ifNotNil: [ windowGroup isInWorld ifTrue: [ windowGroup window comeToFront ] ifFalse: [ windowGroup window openAsIs ].        windowGroup activateWindow: window ]defaultMenuItemName  ^'Flat'isSameAsCurrent  ^isSameAsCurrenttestClassEnumeration  scope := ClyTraitUserScope of: ClyTraitRoot1.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {ClyTraitChild1 .         ClyTraitChild2 .         ClyClassWithTraits .         ClyTraitChild2Child .         ClyTraitChild3 .         ClySubclassWithTraitsOfClassWithTraits} asSettestHasQueryResult  self assert: cursor queryResult equals: queryResultnavigateForward  navigationHistory redoNavigationOf: selfisStatic  ^trueattachToSystem  TestCase historyAnnouncer weak when: TestSuiteEnded send: #testRan: to: selfitemsWhere: conditionBlock  | result |  result := super itemsWhere: conditionBlock.  result do: [:each |  each prepareIn: environment ].  ^resulteditorClass  ^ClyTextEditorrestoreBrowserState  self browser selectMethod: self lastSelectedMethodisInverse  ^inversetestRestoredBrowserInstanceWithMetaLevelScope  browser metaLevelScope: #testScope.  self restoreBrowserInstance.  self assert: browser metaLevelScope equals: #testScopetestNotSelectsNotAbstractMethod  self deny: (query selectsMethod: Object >> #printString)testFindingTestCoveringMethod  {((ClyTestedClass >> #one) -> (ClyTestedClassTest >> #testOne)) .   ((ClyTestedClass >> #one:) -> (ClyTestedClassTest >> #testOne)) .   ((ClyTestedClass >> #two) -> (ClyTestedClassTest >> #testTwo)) .   ((ClyTestedClass >> #two:) -> (ClyTestedClassTest >> #testTwo)) .   ((ClyTestedClass >> #one:two:) -> (ClyTestedClassTest >> #testOneTwo)) .   ((ClyTestedClass >> #oneTwo:) -> (ClyTestedClassTest >> #testOneTwo)) .   ((ClyTestedClass >> #untestedOne) -> nil) .   ((ClyTestedClass >> #untestedOne:) -> nil) .   ((ClyTestedClass >> #untestedTwo) -> nil) .   ((ClyTestedClass >> #untestedTwo:) -> nil) .   ((ClyTestedClass >> #untestedOne:two:) -> nil) .   ((ClyTestedClass >> #untestedOneTwo:) -> nil) .   ((ClyTestedClass class >> #one:two:) -> (ClyTestedClassTest >> #testOneTwo)) .   ((ClyTestedClass class >> #untestedOne:two:) -> nil) .   ((ClyTestedClassTest >> #testOne) -> nil) .   ((ClyTestedClassTest >> #testTwo) -> nil) .   ((ClyTestedClassTest >> #testOneTwo) -> nil)} do: [:each |  self assert: (plugin findTestMethodCovering: each key ifAbsent: nil) identicalTo: each value ]testRestoredBrowserInstanceWithMethodGroupQuery  browser methodGroupQuery: #testQuery.  self restoreBrowserInstance.  self assert: browser methodGroupQuery equals: #testQuerydecorateBrowserItem: anItem ofClass: aClass  anItem ensureSystemDefinition: [ ClyClassDefinitionProperty of: aClass ].  aClass localSelectors ifNotEmpty: [ anItem markWithChildrenOf: ClyMethod ].  aClass hasComment ifFalse: [ anItem markWith: ClyNoCommentTag ]triggerUpdate  self updatetestHasReadonlyRequiredResultByDefault  self assert: query requiredResult isReadOnlyObjectcollate: anObject1 with: anObject2  ^anObject1 definingClass name threeWayCompareTo: anObject2 definingClass nametargetItemType: aClass  targetItemType := aClassshowResultOf: aQuery  self changeStateBy: [ systemQuery := aQuery buildsDefaultResult ifTrue: [ aQuery withResult: self requiredQueryResult ] ifFalse: [ aQuery ].        self showQueryResult ]representsObject: anObject  actualObject == anObject ifTrue: [ ^true ].  type = anObject calypsoEnvironmentType ifFalse: [ ^false ].  ^type checkCalypsoItem: actualObject isSameAs: anObjectcriticAnalysisScope  ^ClyPackageScope of: package in: browser navigationEnvironmentdefaultIcon  self defaultIconName ifNil: [ ^nil ].  ^self iconNamed: self defaultIconNametestComparisonWithCopy  | copy |  scope := self createSampleScope.  copy := scope copy.  self assert: scope equals: copy.  self assert: scope hash equals: copy hashitemsChanged  self forceRebuildqueryScope  ^queryScopebrowserItem: aBrowserItem  browserItem := aBrowserItemwithoutItemsOfType: anItemTypeClass  ^(self retrievesItemsOfType: anItemTypeClass) ifTrue: [ ClyUnknownQuery instance ] ifFalse: [ self ]metadata  ^metadatabuildMethodGroupWithCritique: aCritique on: resultDictionary  | critiqueGroupName group |  critiqueGroupName := aCritique rule group.  group := resultDictionary at: critiqueGroupName ifAbsentPut: [ ClyConcreteCritiqueMethodGroup basedOn: aCritique withMethodsFrom: self scope ].  group addCritique: aCritiqueexecute  | selectors query |  selectors := methods collect: [:each |  each selector ].  query := ClyMessageImplementorsQuery ofAny: selectors from: self createQueryScope.  browser spawnQueryBrowserOn: query withState: [:queryBrowser |  self selectMethodsIn: queryBrowser ]firstSelectedObjectIn: selectedObjects  ^selectedObjects lastopenEditor  self requestChangeBy: [ self isExtensionActive ifTrue: [ self requestPackage ] ifFalse: [ self requestTag ] ]targetSelector  ^#clyMessageImplementor1asSelectedRoots  | roots lastSelectedRoot resultItems |  self isEmpty ifTrue: [ ^self ].  roots := items collect: [:each |  each rootParentItem ] as: Set.  roots = items ifTrue: [ ^self ].  lastSelectedRoot := self lastSelectedItem rootParentItem.  roots remove: lastSelectedRoot.  resultItems := OrderedCollection with: lastSelectedRoot.  resultItems addAll: roots.  ^self class fromRoot: self rootDataSource items: resultItemsoverriddenSuperclass  ^overriddenSuperclasstestAdoptQueryShouldKeepScopeName  | query adoptedQuery |  scope := ClyCompositeScope on: {(ClyScopeExample of: Object in: environment) .         (ClyScopeExample2 of: Array in: environment)}.  scope name: 'test scope'.  query := ClyQueryExampleReturningScopeBasis new.  adoptedQuery := scope adoptQuery: query.  self assert: adoptedQuery scope name equals: 'test scope'isAppliedToBrowser  ^browser metaLevelScope = self metaLevelScopetestCaseSensitiveMathingString  | pattern |  pattern := ClySubstringPattern with: 'subString' caseSensitive: true.  self assert: (pattern matches: 'start subString end').  self deny: (pattern matches: 'start substring end')createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'deprecated' priority: -9 on: aMethodQueryeditingMode  | editingMode |  editingMode := ClyTextEditingMode browserTool: self.  editingMode     classOrMetaClass: self selectedClassOrMetaClass;     isForScripting: self isForScripting.  ^editingModecreateQueryResult  ^ClyGroupedExtendingPackages newpackages  ^environment ask packagesname: anObject  name := anObjectcollate: anObject1 with: anObject2  self subclassResponsibilitycreateMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'undeclared' priority: 8.4 on: aMethodQuerytestFromTwoClasses  self queryFromScope: ClyClassScope ofAll: {ClyClass9FromPExtendedByP5 .         ClySubclassLOfClass0FromPExtendedByP1}.  self assert: resultItems asSet equals: {ClyClass1FromP1 package .         ClyClass7WithTag1FromP5 package} asSetinitialize  super initialize.  label := StringMorph newnavigateSpawnedFullBrowser: aFullBrowser  | lastItem definition |  aFullBrowser setUpScopedModeWith: self activeScope.  lastItem := self selection lastSelectedItem.  definition := lastItem systemDefinition.  aFullBrowser selectPackage: definition definingPackage.  aFullBrowser selectClass: definition definingClass.  (definition isKindOf: ClyMethodDefinitionProperty) ifTrue: [ aFullBrowser selectMethod: lastItem actualObject ]toolClass  ^annotatedClassdecorateTableCell: anItemCellMorph inContext: itemContext  annotatedClass decorateTableCell: anItemCellMorph inContext: itemContextfillWith: objects  items addAll: objectscreateCellFor: aDataSourceItem in: aQueryView  | cell |  cell := ClyItemCellMorph new.  displayBlock value: cell value: aDataSourceItem.  aQueryView decorateTableCell: cell of: aDataSourceItem.  cell build.  ^cellclassUnderTest  ^ClyTestedClasshasChildrenOf: itemTypeClass  ^self hasChildrenWhich: [:childType |  childType = itemTypeClass ]selectsMethod: aMethod  ^scope inheritanceAnalyzer isMethodOverridden: aMethodcritique: anObject  critique := anObjecttestSuperSendWithArgs_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'super foo: arg1 bar: arg2') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext receiver perform: #foo:bar: withArguments: {ThisContext lookupSymbol: #arg1. ThisContext lookupSymbol: #arg2.} inSuperclass: ThisContext receiver class superclass)]')hash  ^items hash= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^dialogClass = anObject dialogClass and: [ browserClass = anObject browserClass ]execute  selectedItems size = 1 ifTrue: [ selectedItems first inspect ] ifFalse: [ selectedItems inspect ]newSelectionWith: dataSourceItems  ^ClyDataSourceSelection fromRoot: self items: dataSourceItemstestIsExecutedFromSingleScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self deny: query isExecutedFromSingleScope.  query scope: (ClyScopeExample of: #singleObject in: environment).  self assert: query isExecutedFromSingleScope.  query scope: (ClyScopeExample emptyIn: environment).  self deny: query isExecutedFromSingleScopeabstractSubclassMethod  self subclassResponsibilitymethod2  collectAllClasses  | result |  result := IdentitySet new.  subscopes do: [:scope |  scope classesDo: [:each |  result add: each ] ].  ^resultcreateQuery  ^ClyExtendingPackagesQuery from: ClyClassScope of: Object in: environmentextraClassScope  ^extraClassScopehasChildren  ^ownerDataSource doesItemHaveChildren: selfrepresentsBrowserItems  ^trueasAsyncQueryGroup  ^selftestConvertingToInheritingScope  | convertedScope |  scope := ClyCompositeScope on: {(ClyInstanceSideScope of: Object in: environment) .         (ClyClassSideScope of: Array in: environment)}.  convertedScope := scope asInheritingScope.  self assert: convertedScope class equals: ClyCompositeScope.  self assert: (convertedScope subscopes first representsScope: ClySubclassScope).  self assert: (convertedScope subscopes last representsScope: ClySubclassScope).  self assert: (convertedScope subscopes collect: #localScopeClass as: Set) equals: {ClyInstanceSideScope .         ClyClassSideScope} asSet.  self assert: convertedScope environment equals: environment.  self assert: convertedScope name equals: ClyClassScope inheritingScopeNameattachToTextMorph  super attachToTextMorph.  label := StringMorph new.  label setBalloonText: 'Let you decide if the code pane should show the line numbers at the left of the code pane or not. +L: Click to add the lines number/L: Click to hide them.'.  label on: #mouseDown send: #toggle to: self.  self updateLabel.  self addMorph: labeldelayExecution  executionSemaphore consumeAllSignalsisEqualTo: anotherBrowserItem  type = anotherBrowserItem type ifFalse: [ ^false ].  ^type checkCalypsoItem: actualObject isEqualTo: anotherBrowserItem actualObjectprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  package := aToolContext requestSinglePackage: 'Choose package'methodsDo: aBlock  self classesDo: [:class |  class localMethods do: aBlock.        class classSide localMethods do: aBlock ].  self packagesDo: [:package |  package extensionMethods do: aBlock ], anotherHierarchy  ^ClyMergedHierarchy merge: {self .         anotherHierarchy}hash  ^dialogClass hash bitXor: browserClass hashbrokenCount  ^failureCount + errorCountscope: aScope  super scope: aScope.  baseCritiqueQuery scope: aScopedescription  ^'methods tagged with ' , tagbuild  checkbox := self theme newCheckboxIn: self for: self getSelected: #isActive setSelected: #toggle getEnabled: nil getLabel: #label help: 'toggle check box to choose/reset package of method'.  checkbox     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap.  self addMorph: checkboxtestIsExecutedFromMultipleScopeWhenSingleSubqueryIsBasedOnIt  query subqueries: {(self subqueryFromScope: (ClyScopeExample ofAll: {self class .                     self class superclass}))}.  self assert: query isExecutedFromMultipleScopemethodWithBreakpoints  self printStringtestResult  self subclassResponsibilitysenderOfMessage2  self message2withSubqueries: newSubqueries  ^self class with: newSubqueries as: requiredResultclassVariablesDo: aBlock  self classesDo: [:eachClass |  self classVariablesOf: eachClass do: aBlock ]decorateContainerTab  | title |  super decorateContainerTab.  browser metaLevelScope == ClyClassSideScope ifFalse: [ ^self ].  title := self defaultTitle asText allBold asStringMorph.  containerTab label: title, anotherTypedScope  ^ClyCompositeScope on: {self .         anotherTypedScope}build  | checkBox |  checkBox := CheckboxMorph on: self selected: #isMethodsVisible changeSelected: #showInheritedMethods:.  checkBox     borderWidth: 0;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap.  checkBox labelMorph delete.  self addMorph: checkBoxcreateQuery  ^super createQuery semiAsyncexecute  ClySubclassHierarchy invertVariableHierarchy.  browser switchToVariablesallNavigationScopes  | extraScopes |  extraScopes := self extraScopesOfSelectedItems reject: #isBasedOnEmptyBasis.  ^queryScopes , (extraScopes copyWithoutAll: queryScopes)prepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browserpackageName  package ifNil: [ ^'' ].  classTag ifNil: [ ^package name ].  ^package name , '-' , classTagtestFromTwoSamePackages  self buildGroupsForAll: {ClyClass7WithTag1FromP5 package .         ClyClass7WithTag1FromP5 package}.  self assert: builtGroups size equals: 2.  self assert: (builtGroups collect: #tag) sorted asArray equals: #(Tag1 Tag2)testMethodsEnumeration  scope := ClyTraitUserScope of: ClyTraitRoot1.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyTraitChild1 localMethods).  self assert: (result includesAll: ClyClassWithTraits localMethods).  self deny: (result includesAll: ClyClassWithTraits classSide localMethods).  self deny: (result includesAll: ClyTraitRoot1 localMethods).  self deny: (result includesAll: ClyTraitRoot1 classSide localMethods)detachFromSystem  TestCase historyAnnouncer unsubscribe: selfqueryScope  ^buildingQuery scopecreateMethodQueryFrom: aClassScope  ^ClyActiveBreakpointsQuery from: aClassScopedoesMethod: aMethod useVar: aVariable  (super doesMethod: aMethod useVar: aVariable) ifTrue: [ ^true ].  ^aMethod hasSelector: aVariable name asSymboltestFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> self targetSelector) .         (self class >> #messageImplementor2)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> self targetSelectordefaultMenuItemName  ^'Hier.'expectedFlatQueryResult: anObject  expectedFlatQueryResult := anObjectselectsMethod: aMethod  | critiques |  critiques := self loadCritiquesAsync.  ^critiques items anySatisfy: [:each |  each sourceAnchor entity == aMethod ]testAdoptQuery  | query adoptedQuery |  scope := ClyCompositeScope on: {(ClyScopeExample of: Object in: environment) .         (ClyScopeExample2 of: Array in: environment)}.  query := ClyQueryExampleReturningScopeBasis new.  query extraParameter: #testParameter.  adoptedQuery := scope adoptQuery: query.  self assert: adoptedQuery class equals: ClyUnionQuery.  self assert: adoptedQuery subqueries size equals: 2.  adoptedQuery subqueries do: [:each |  self assert: each class equals: query class.        self assert: each extraParameter equals: #testParameter ].  self assert: (adoptedQuery subqueries collect: #scope) equals: scope subscopes asSetselectors  ^selectorsbuildGroupsFrom: aClassScope  self subclassResponsibilityquery  ^querysystemEnvironment  ^systemEnvironmenttestCreationFromTwoQueriesOfSameTypeAndScopeButWithDifferentParameter  | subquery1 subquery2 |  subquery1 := self subqueryFromScopeOf: Array.  subquery1 extraParameter: #testParameter.  subquery2 := self subqueryFromScopeOf: Array.  subquery2 extraParameter: #testParameter2.  query := subquery1 , subquery2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {subquery1 .         subquery2} asSet.  self assert: query requiredResult identicalTo: subquery1 requiredResulttestExpandedDataSourceWithoutTable  | expandedItem |  self selectedItem expand.  self snapshotState.  expandedItem := navigationState dataSource expandedItems first.  self assert: expandedItem childrenDataSource table isNilclassGroupProvidersDo: aBlock  | providers |  environment pluginsDo: [:plugin |  providers := plugin collectClassGroupProviders.        providers do: aBlock ]testItems  ^testItemsasyncResult  ^asyncResultselectsMethod: aMethod  | vars |  vars := variableQuery execute.  ^self doesMethod: aMethod useAnyOf: vars itemssingleScopeSample  ^self scopeClass of: self singleBasisSample in: environmentwithMetaLevelScope: aScopeClass  ^self withScope: (scope withMetaLevel: aScopeClass)initialize  super initialize.  description := 'Methods'selectedClassScript  | methodItem |  methodItem := self lastSelectedObjectIn: self selectedMethodItems.  ^(methodItem getProperty: ClyClassScriptProperty) scriptgenerateConditionBlockFrom: aString  | conditionBlockProducerMethodAST |  conditionBlockProducerMethodAST := self conditionBlockProducerMethodAST: aString.  ^conditionBlockProducerMethodAST generateWithSource valueWithReceiver: nil arguments: {}hierarchy  ^hierarchyhash  ^super hash bitXor: mergedParts hashspecifyMethodItemNameOn: nameMorph for: methodItem  | definition |  nameMorph contents: methodItem name.  definition := methodItem systemDefinition.  (self isPackagePartOfSelection: definition definingPackage) ifFalse: [ nameMorph color: self theme classExtensionColor ].  self classSelection isMultipleSelected ifTrue: [ ^nameMorph contents: (definition printFullNameOf: methodItem) ].  (self isClassSelected: definition definingClass) ifTrue: [ ^self ].  nameMorph emphasis: TextEmphasis italic emphasisCode.  nameMorph contents: (definition printFullNameOf: methodItem)update  navigationViews do: [:each |  each update ]buildResult: aQueryResult  | subResult allItems |  allItems := subqueries flatCollect: [:each |  subResult := each execute.        subResult items ].  aQueryResult fillWith: allItems asIdentitySetcreateInheritanceScopeFrom: classes  ^ClySubclassScope ofAll: classes in: browser navigationEnvironmentasInheritingScope  ^ClyInheritedScopeProvider createInheritingScopeFrom: selfmethodClass  ^methodClassbrowser  ^browserprepareFullExecutionInContext: aBrowserContext  super prepareFullExecutionInContext: aBrowserContext.  conditionBlock := self requestConditionBlockexecute  | breakpoint |  breakpoint := Breakpoint new node: sourceNode.  self applyBreakpointCondition: breakpoint.  breakpoint installselectAnySelector: selectors  textMorph setSelection: (self findAnySelectorInSourceCode: selectors)testSelectedTabsWithoutOwner  | tab |  self snapshotState.  tab := navigationState selectedTabs first.  self assert: tab owner isNilmethodGroupSelectionChanged  | methodQueries |  methodGroupView changesWasInitiatedByUser ifTrue: [ tabManager skipCurrentDesiredSelection ].  self methodGroupSelection isEmpty ifTrue: [ ^self showAllMethods ].  methodQueries := self methodGroupSelection actualObjects collect: [:eachGroup |  eachGroup methodQuery ].  methodView showQueries: methodQueries as: (ClySortedQueryResult using: ClySortMethodBySelectorFunction ascending)asItemsScope: aTypedScope  | actualItems |  actualItems := self uniformActualObjects.  ^aTypedScope ofAll: actualItems in: rootDataSource queryEnvironmentenvironment  ^actualResult environmenttestCheckIfEmpty  query scope: (ClyClassScope of: self class in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: self class superclass in: environment).  self assert: query checkEmptyResultprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  pattern printOn: aStream.  aStream nextPut: $)expand: aDataSourceItem  queryView changeStateBy: [ aDataSourceItem expandChildren.        expandedItems add: aDataSourceItem.        self expansionChanged ]restoreCurrentSelection: currentSelection  | wasSameAsCurrent newItems currentSelectionIsChanged |  wasSameAsCurrent := isSameAsCurrent.  self checkItemsOfCurrentSelection: currentSelection.  newItems := isSameAsCurrent ifTrue: [ currentSelection items ] ifFalse: [ currentSelection rootDataSource findItemsSimilarTo: items ].  currentSelectionIsChanged := (wasSameAsCurrent & isSameAsCurrent) not.  currentSelection restoreDesiredSelectionWith: newItems silently: currentSelectionIsChanged not.  ^currentSelectionIsChangedupdateToolsForChangedEnvironment  | currentState |  currentState := OrderedCollection new: tools size.  tools do: [:each |  currentState add: each -> each isManagedByUser.        each isManagedByUser: true ].  self updateTools.  currentState do: [:each |  each key isManagedByUser: each value ]findItemsWhere: conditionBlock  ^self findAllItemsBy: [:ds |  ds findItemsWhere: conditionBlock ]restrictedBy: aScope  ^self withNewBasisObjects: aScope basisObjectsdetachFromTextMorph  super detachFromTextMorph.  self textArea announcer unsubscribe: selfsetUpModelFromContext  testFromSinglePackage  self queryFromScope: ClyPackageScope of: ClyClass1FromP1 package.  self assert: resultItems asSet equals: ClyClass1FromP1 package definedClasses.  self deny: (resultItems includes: ClySubclassLOfClass0FromPExtendedByP1)changeStateBy: aBlock  aBlock valuebrowseVariableReferencesOf: variables  tool spawnQueryBrowserOn: (ClyVariableReferencesQuery ofAny: variables)testConvertingWithNewScopeShouldKeepFilter  | newScope convertedQuery |  newScope := ClyScopeExample2 of: #someBasis in: environment.  convertedQuery := query withScope: newScope.  self assert: convertedQuery itemFilter equals: query itemFiltercreateQueryResult  ^ClyGroupedInstanceVariables withHierarchy: ClySubclassHierarchy newtestFromClassScope  self queryFromScope: ClyClassScope of: self class.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self class >> #methodWithExpectedStringInSourcesclose  execute  ^scope query: selfsubtreeSize  ^subtreeSizeone: anObject  one := anObjectdefaultMenuItemName  ^'Traits'affectsMethodsDefinedInClass: aClass  ^aClass instanceSide includesBehavior: overriddenSuperclassretrievesItem: aVariable  ^aVariable isKindOf: ClyClassVariablequeryScopes: anObject  queryScopes := anObjectisClosed  ^itemCursor == ClyClosedBrowserCursor instanceisMethodsVisible  ^visibilityLevel isActiveallowsDeselection: aBool  table allowsDeselection: aBoolasAsyncQueryGroup  ^ClyAsyncMethodGroup named: name priority: priority on: methodQuery withSubgroupsFrom: subgroupsQuerydescription  ^'readers of ' , self printVariablestestClassEnumerationOverClassShouldStopAtObject  scope := ClyInterestingSuperclassScope of: Class.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {ClassDescription .         Behavior} asSetnotFFIMethod  groupName: anObject  groupName := anObjectfillWithGroupedVariables: varsPerTypeAndDefiningClass  self subclassResponsibilityvalue: anObject1 value: anObject2  | result |  result := (self collate: anObject1 with: anObject2) * direction.  ^result <= 0navigationHistory  ^navigationHistoryfindCachedElementWith: anEnvironmentItem ifAbsent: absentBlock  ^expandedItems detect: [:each |  each actualObject == anEnvironmentItem actualObject ] ifNone: absentBlocktestCompareTwoClasses  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object value: Array).  self assert: (function value: Array value: Object).  self assert: (function value: Object value: Object)description  ^descriptionnavigationEnvironment  ^navigationEnvironmentdecorateBrowserItem: anItem ofMethod: aMethod  anItem ensureSystemDefinition: [ ClyMethodDefinitionProperty of: aMethod ]findAnyString: strings in: text  | index |  strings do: [:each |  index := text findString: each startingAt: 1.        index > 0 ifTrue: [ ^index to: index + each size ] ].  ^0 to: -1printExtraInfoOn: aStream  super printExtraInfoOn: aStream.  ^aStream nextPutAll: tagallChildrenOf: aClass depth: currentDepth do: blockWithClass  | children childDepth |  children := parentMap at: aClass ifAbsent: [ ^self ].  childDepth := currentDepth + 1.  children do: [:eachChild |  blockWithClass value: eachChild value: childDepth.        self allChildrenOf: eachChild depth: childDepth do: blockWithClass ]createBrowserContextOf: aSelection for: aBrowser  ^annotatedClass ofSelection: aSelection for: aBrowsertestForSharedClassVariable  | classVar |  classVar := ClyClassVariable named: #DayNames definedIn: ChronologyConstants.  query := ClyVariableReferencesQuery of: classVar.  self queryFromScope: ClyBothMetaLevelClassScope of: Date.  self assert: resultItems notEmptyresultItems: anObject  resultItems := anObjectinitialize  super initialize.  self     changeTableLayout;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     listDirection: #leftToRight;     cellInset: 2.  progress := 1.  progressIconMorph := self currentIcon asMorph.  self addMorphBack: progressIconMorph.  self extent: progressIconMorph extenttestFillingWithTwoInstVarsOfSameClass  | variables |  variables := {(ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .   (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)}.  queryResult fillWith: variables.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar1 #instanceSideVar2)testRestoredBrowserInstanceWithMethodQuery  | query |  query := ClyAllMethodsQuery sorted.  browser systemQuery: query.  self restoreBrowserInstance.  self assert: browser systemQuery equals: queryisExpanded: aDataSourceItem  ^expandedItems includes: aDataSourceItemtestNotBoundToEnvironmentByDefault  query := query class new.  self deny: query isBoundToEnvironmentitemsChanged  wasNotified := truebuildResult: aQueryResult  | allItems |  allItems := OrderedCollection new.  scope projectsDo: [:each |  allItems addAll: each items ].  aQueryResult fillWith: allItemsitemAt: index  ^items at: indexapplyChanges  | newMethod selector selectedClass |  selectedClass := self chooseClassForNewMethodIfNone: [ ^false ].  selector := methodTags ifEmpty: [ selectedClass compile: self pendingText asString notifying: textMorph ] ifNotEmpty: [ selectedClass compile: self pendingText asString classified: methodTags anyOne notifying: textMorph ].  selector ifNil: [ ^false ].  newMethod := selectedClass >> selector.  methodTags ifEmpty: [ MethodClassifier classify: newMethod.        methodTags := newMethod tags ].  self tagAndPackageEditingMethod: newMethod.  self removeFromBrowser.  browser tabManager desiredSelection: {ClyMethodCodeEditorToolMorph}.  browser selectMethod: newMethod.  ^truecreateClassGroupFor: aClassQuery from: aPackageScope  self subclassResponsibilitytestNotSelectsNotOverriddenMethod  self deny: (query selectsMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)withTool: aToolClass do: aBlock  ^tabManager withTool: aToolClass do: aBlockdecorateBrowserItem: anItem ofMethod: aMethod  (self isTestMethod: aMethod) ifFalse: [ ^self ].  anItem addProperty: (ClyTestResultProperty ofMethod: aMethod)rawItemsDo: aBlock  ^self rawItems do: aBlocktestMethodsEnumerationWhenBasisIsTraitedClass  | expected |  scope := ClyInstanceSideScope of: ClyClassWithTraits.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClassWithTraits methods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArraygroupProviderClass  ^ClyMethodCounterGroupProvidercopy  | copy |  copy := super copy.  copy browserItem: browserItem copy.  ^copyiconNameForSpotterMenu  ^#packageIcontagAndPackageEditingMethod: aMethod  self tagEditingMethod: aMethod.  self packageEditingMethod: aMethodtestIsNotBasedOnMultipleBasis  scope := self createSampleScope.  self deny: scope isBasedOnMultipleBasisselectedMethodItems  self subclassResponsibilitypackageSampleWhichHasGroup  ^ClyClass1FromP1 packagedoesMethod: aMethod useVar: aVariable  ^aVariable isReferencedIn: aMethodselectedClassItems  ^selectedItemswithScopeOf: newBasisObjects  ^self withScope: (scope withNewBasisObjects: newBasisObjects)systemDefinition  ^browserItem systemDefinitionanalyzedObjectsDo: aBlock  scope basisObjects do: aBlocktestFillingWithClassAndSuperclassVariables  queryResult fillWith: {(ClyInstanceVariable named: #subclassN1Var definedIn: ClySubclassN1OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN1OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar1 #instanceSideVar2 #subclassN1Var #subclassSameVar)actualVariable  ^actualVariabledefaultMenuIconName  ^#smallFindIconconfirmUnusedVariables: variables  ^self browser confirmUnusedVariables: variablestestBuildShouldStartBackgroundProcessing  queryResult rebuild.  self assert: (queryResult hasMetaProperty: ClyBackgroundProcessingTag).  self deny: queryResult buildProcess isTerminatedrestoreSelectedItems  self initiateUIChangeBy: [ selection restoreTableSelection ].  highlighting restoreTableSelectionwithScopeOf: newBasisObjects  self subclassResponsibilityprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  definingClass printOn: aStream.  aStream nextPut: $)selectLastItem  self changeStateBy: [ resultView selectLastItem ]iconNameForSpotterMenu  ^#classIconmethodClass  self belongsToCurrentBrowserContext ifFalse: [ ^editingMethod origin ].  ^browser chooseClassForEditorOfMethod: editingMethodrecordAcrossWindowNavigationFrom: aBrowser byUndo: isUndoOperation  | returnState |  returnState := ClyAccrossWindowNavigationState from: aBrowser.  isUndoOperation ifTrue: [ self executeUndoBy: [ self recordState: returnState ] ] ifFalse: [ self executeRedoBy: [ self recordState: returnState ] ]asInterestingClassScope  ^selftestOneTwo  | testedObject |  testedObject := self newTestedObject one: #one two: #two.  self     assert: testedObject one equals: #one;     assert: testedObject two equals: #two;     assert: (testedObject one: #three two: #four) identicalTo: testedObject;     assert: testedObject one equals: #three;     assert: testedObject two equals: #four;     assert: (testedObject oneTwo: #five) identicalTo: testedObject;     assert: testedObject one equals: #three;     assert: testedObject two equals: #fiveallowSilentlyRemoveMethods: methods whichHaveSenders: senders  | singleSender sendersCount |  sendersCount := senders size.  sendersCount = 0 ifTrue: [ ^true ].  methods size = 1 & (sendersCount = 1) ifFalse: [ ^false ].  singleSender := senders itemAt: 1.  ^singleSender == methods firstdefaultMenuItemName  ^'Add counter'setUpModelFromContext  | selectedGroup |  super setUpModelFromContext.  methodClass := context selectedClassSide.  context isMethodGroupSelected ifFalse: [ ^self ].  selectedGroup := context lastSelectedMethodGroup.  (selectedGroup isKindOf: ClyExternalPackageMethodGroup) ifTrue: [ ^extendingPackage := selectedGroup package ].  (selectedGroup isKindOf: ClyTaggedMethodGroup) ifTrue: [ ^methodTags := {selectedGroup tag} ]testFromSingleClass  | varNames |  self queryFromScope: ClyClassScope of: ClyClass2FromP1.  varNames := resultItems collect: #name as: Set.  self assert: varNames equals: ClyClass2FromP1 instVarNames asSet , (ClyClass2FromP1 classVariables collect: #name)sortFunctionFor: systemObject  ^functionsForTypes at: systemObject calypsoEnvironmentType ifAbsentPut: [ systemObject calypsoEnvironmentType defaultSortFunctionForCalypso ]methodFromTraitChild3  requestor: anObject  requestor := anObjecttestOne  | testedObject |  testedObject := self newTestedObject.  self     assert: testedObject one isNil;     assert: (testedObject one: #one) identicalTo: testedObject;     assert: testedObject one equals: #oneallCount: anObject  allCount := anObjectcreateQuery  ^ClyAllMethodCritiqueQuery from: self scopeWithCritiquesselectAnyVariable: varNames  textMorph setSelection: (self findAnyVariableInSourceCode: varNames)untestedOne: anObject  self one: anObjectsubclassClassVar1Writer  ClassVar1 := #subclassClassVar1Valueinitialize  super initialize.  asyncResult := ClyAsyncQueryResult newundoList: anObject  undoList := anObjectisAppliedToBrowser  ^browser showsFlatResult notdisplayItemName  self displayItemPropertyBy: [:item |  item name ]execute  | packageNames |  packageNames := packages collect: [:each |  each name ].  (DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: packageNames) opentestMatchesMethodWithSelectorWhichMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'MethodWithSelector'.  self assert: (filter matches: self itemOfThisTestMethod)environment  ^environmentusesSlotBasedDefinition  ^Slot showSlotClassDefinitionsetUp  super setUp.  browser showResultOf: (ClyAllMethodsQuery sortedFrom: browser queryScopes first)executesQuery: aTypedQueryClass  self subclassResponsibilityasUnifiedInstance  ^selfinstSideMethodWithScriptWithArgument  < script: 'self inform: ''It is example inst side method with script with argument from '', self name'>  protectAccessWhile: aBlock  ^aBlock valuequeryView: aQueryView  queryView := aQueryViewactualObjects  ^items collect: [:each |  each actualObject ]matches: aBrowserItem  | actualObject |  actualObject := aBrowserItem class = ClyBrowserItem ifTrue: [ aBrowserItem actualObject ] ifFalse: [ aBrowserItem ].  (pattern value beginsWith: '[') ifTrue: [ ^self matchesByScript: actualObject ].  ^actualObject matchesQueryBrowserFilter: selfisStatic  ^falsebaseQueryResult: anObject  baseQueryResult := anObjectasGoToSpotterCandidate  ^tool asGoToSpotterCandidatetestComparison  self assert: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}) equals: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}).  self assert: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}) hash equals: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}) hash.  self deny: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}) equals: (self queryClass of: (ClyInstanceVariable named: #y definedIn: Point))iconNameForSpotterMenu  ^#packageIconenvironment: anObject  environment := anObjectselectedProjects  ^self actualSelectionFrom: self selectedProjectItemsrawItems  ^items collect: [:each |  each actualObject ]testSelectsAbstractMethod  self assert: (query selectsMethod: ClyAbstractClassExample >> #abstractMethod1)readParametersFromContext: aBrowserContext  super readParametersFromContext: aBrowserContext.  script := aBrowserContext selectedClassScripthierarchy: anObject  hierarchy := anObjectaddTool: aBrowserTool  | tab |  tools add: aBrowserTool.  aBrowserTool width: tabMorph width.  tab := aBrowserTool createTab.  tab when: #tabDeleted send: #tabDeleted: to: self.  tab when: #tabSelected send: #tabSelected: to: self.  tab label on: #doubleClick send: #toggleFullWindowTabs to: browser.  tab label on: #mouseDown send: #mouseDown: to: tab.  tab label on: #mouseUp send: #mouseUp: to: tab.  tabMorph addTab: tab= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^tag = anObject tagbuildResult: aQueryResult  | classComments |  classComments := OrderedCollection new.  scope classesDo: [:each |  (self selectsClass: each) ifTrue: [ classComments add: (ClyClassComment of: each) ] ].  aQueryResult fillWith: classCommentsexecuteCommand: aCommand by: aCommandActivator  aCommand isComplexRefactoring ifTrue: [ aCommand confirmRefactoringInContext: self by: aCommandActivator ].  aCommand executeneverRestoreSelection  shouldRestoreSelection := falseposition  ^positiondefaultMenuIconName  ^#smallFindIcon= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^localScopeClass = anObject localScopeClassbuildProcess  ^buildProcesstestDefaultHierarchyShouldExist  self assert: (ClyMethodVisibilityGroups defaultHierarchy isKindOf: ClyClassHierarchy)value  ^valuequeryClass  ^ClyAsyncQuerycollate: anObject1 with: anObject2  ^anObject1 name threeWayCompareTo: anObject2 nametestFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1 .         ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1}testIsNotBasedOnAnyObject  scope := self createSampleScope.  self deny: (scope isBasedOn: #anyObject)defaultMenuIconName  ^#arrowDownimportMethods: methodsCollection  methodsCollection do: [:each |  self importMethod: each ]createQuery  ^ClyUnclassifiedMethodsQuery from: (ClyClassScope of: ClyClass1FromP1 in: environment)adoptLocalScopeClassTo: aLocalScopeClass  description  ^'instance variables'editingText  ^editingMethod sourceCodemethodsDo: aBlock  self packagesDo: [:package |  package extensionMethods do: aBlock ]setUp  super setUp.  installedCounters := OrderedCollection newisForScripting  ^isForScriptingdefaultIconName  ^#classIcontestDataSourceWithExpandedItems  self selectedItem expand.  self snapshotState.  self assert: (navigationState dataSource expandedItems first isSameAs: viewDataSource expandedItems first)printBasisObject: anObject on: aStream  | actualScope |  actualScope := subscopes detect: [:each |  each isBasedOn: anObject ].  ^actualScope printBasisObject: anObject on: aStreamqueryFromScope: scopeClass ofAll: basisObjects  query scope: (scopeClass ofAll: basisObjects in: environment).  self executeQueryfindItemsWhere: conditionBlock  ^queryResult itemsWhere: conditionBlockdefaultMenuItemName  ^'Overriding methods'setUpModelFromContext  super setUpModelFromContext.  editingClass := context lastSelectedClassadoptBrowserToolLayout  originalToolPanel := PanelMorph new.  originalToolPanel     name: 'original tool elements';     color: Color transparent;     borderWidth: 0;     layoutPolicy: browserTool layoutPolicy.  browserTool submorphs do: [:each |  originalToolPanel addMorphBack: each ].  browserTool changeProportionalLayout.  browserTool addMorph: originalToolPanel fullFrame: (0 @ 0 corner: 1 @ 1) asLayoutFrameattachToSystem  TestCase historyAnnouncer weak when: TestSuiteEnded send: #testRan: to: selftestFillingHierarchicalInstance  query := ClyAllClassesQuery from: ClyPackageScope of: ClyClass1FromP1 package in: environment.  queryResult := ClyExtensionLastSortedClasses hierarchical prepareNewFor: query in: environment.  queryResult buildWith: {ClySubclassLOfClass0FromPExtendedByP1 .         ClySubclassN1OfClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassN1OfClass1FromP1 .         1 .         ClySubclassLOfClass0FromPExtendedByP1 .         0}.  self assert: (items last isMarkedWith: ClyExtendedClassTag).  self deny: (items first isMarkedWith: ClyExtendedClassTag).  self deny: (items second isMarkedWith: ClyExtendedClassTag)description  ^'Open browser with methods where halts or breakpoints are installed'register: aDataSource  updateQueue nextPut: aDataSource.  self ensureRunninginitialize  super initialize.  self layoutInset: 4 @ 0selectsMethod: aMethod  ^methods anySatisfy: [:each |  each calypsoEnvironmentType checkCalypsoItem: each isEqualTo: aMethod ]isEmpty  ^self size = 0actualSelectionFrom: browserItemCollection  ^browserItemCollection collect: [:each |  each actualObject ]supportsQuery: aQuery  ^true= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^relationScopeClasses = anObject relationScopeClassesinitialize  super initialize.  functionsForTypes := IdentityDictionary newrefreshingBlock: anObject  refreshingBlock := anObjectsnapshotState  navigationState := queryView snapshotStatedetachFromSystem  browser system unsubscribe: selftestClassFor: inputClass  | className resultClass |  className := self testClassNameFor: inputClass.  self systemEnvironment classNamed: className ifPresent: [:class |  resultClass := class ] ifAbsent: [ (self isValidClass: inputClass) ifFalse: [ ClyInvalidClassForTestClassGeneration signalFor: inputClass ].        self systemEnvironment ensureExistAndRegisterPackageNamed: inputClass package name asString , '-Tests'.        resultClass := TestCase subclass: className instanceVariableNames: '' classVariableNames: '' package: (self newTestClassCategoryFor: inputClass).        self addNewCommentForTestClass: resultClass basedOn: inputClass ].  ^resultClasssource: aString  definitionString := aStringexecute  ClySubclassHierarchy invertMethodVisibilityHierarchy.  browser switchToMethodGroupsselectClass: aClass  self selectObject: aClassbrowseClassNamed: aString  | classToBrowse |  classToBrowse := (self system bindingOf: aString) ifNil: [ self chooseClassToBrowseFrom: aString ] ifNotNil: [:binding |  classToBrowse := binding value ].  classToBrowse ifNil: [ ^self ].  classToBrowse isClassOrTrait ifFalse: [ classToBrowse := classToBrowse class ].  self spawnBrowser: ClyFullBrowser withState: [:browser |  browser selectClass: classToBrowse ]testEmptyWhenNoMethods  query scope: (ClyMethodScope of: self class >> #method1 in: environment).  query methods: #().  self assert: query checkEmptyResultqueryToExpand: aDataSourceItem ifAbsent: absentBlock  | itemTypeAndQuerySelector |  itemTypeAndQuerySelector := treeStructure detect: [:each |  aDataSourceItem isBasedOnItemType: each key ] ifNone: absentBlock.  ^aDataSourceItem type perform: itemTypeAndQuerySelector value with: aDataSourceItem actualObject with: self dataSource queryEnvironmentsubqueries: queriesCollection  queriesCollection size = 1 ifFalse: [ self error: 'Wrapper query should include single subquery' ].  super subqueries: queriesCollectiontestCreationUnifiedInstance  | unifiedInstance |  scope := self multipleScopeSample.  unifiedInstance := scope asUnifiedInstance.  self assert: unifiedInstance class equals: scope class.  self assert: unifiedInstance environment equals: environment.  self assert: unifiedInstance basisObjects isEmptytestFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(classSideReference1OfClass reference1OfClass reference2OfClass)publishCollectedChanges  changes do: [:queryResult |  queryResult notifyChanges ].  changes removeAlltestFillingWithClassAndItsTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot1 .         3}update  (contextBar submorphs isEmpty and: [ commandBar submorphs isEmpty ]) ifTrue: [ self height: 0.        contextBar height: 0.        commandBar height: 0 ]extraClassScope: aScope  extraClassScope := aScope.  self detectActiveStateisInlined  ^trueisClassSelected  ^self selectedClassItems notEmptytestNotExecutedFromMultipleScopeWhenSingleSubqueryIsBasedOnScopeOfSingleObject  query subqueries: {(self subqueryFromScopeOf: self class)}.  self deny: query isExecutedFromMultipleScopetestIsBasedOnMultipleBasisWhenTwoSubscopesAreBasedOnSingleButDifferentObject  | subscope1 subscope2 |  subscope1 := ClyScopeExample of: #basisObject1 in: environment.  subscope2 := ClyScopeExample of: #basisObject2 in: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self assert: scope isBasedOnMultipleBasisbuild  | label |  label := self theme newLabelIn: self label: self title.  label on: #click send: #executeCommand to: self.  label emphasis: TextEmphasis underlined emphasisCode.  self addMorph: labelcreateMethodGroupFor: aMethodQuery from: aClassScope  ^ClyNoTagMethodGroup withMethodsFrom: aMethodQueryisSimilarTo: anotherBrowserTool  (super isSimilarTo: anotherBrowserTool) ifFalse: [ ^false ].  ^editingPackage = anotherBrowserTool editingPackagetestFromSingleClass  self queryFromScope: ClyClassScope of: ClySubclassLOfClass0FromPExtendedByP1.  self assert: resultItems asSet equals: {ClyClass1FromP1 package} asSetprintDefiningClass  ^isInstanceSide ifTrue: [ definingClassItem name ] ifFalse: [ definingClassItem name , ' class' ]failureCount: anObject  failureCount := anObjectcheckEmptyResult  scope classGroupsDo: [:each |  ^false ].  ^truechildrenDataSource: aDataSource  childrenDataSource := aDataSource.  childrenDataSource ifNotNil: [ childrenDataSource parentItem: self.        childrenDataSource depth: self depth + 1 ]depth  ^ownerDataSource depth + browserItem depthdetachFromSystem  browser system unsubscribe: selfexecuteUndoBy: aBlock  undoExecuting := true.  aBlock ensure: [ undoExecuting := false.        waitingNewState := true ]showAllMethods  | methodQuery |  methodQuery := ClyAllMethodsQuery sortedFrom: self classScopeForMethods.  methodView showQuery: methodQuerytestExecutionWhenNoCritiquesFromRequiredGroup  query groupName: 'wrong group'.  self executeQuery.  self assert: resultItems isEmptytestFromPackageWithTagsAndUncategorizedClasses  self queryFromScope: ClyPackageScope of: ClyClass6UntaggedFromP5 package.  self assert: resultItems asSet equals: {ClyClass6UntaggedFromP5} asSetbelongsToRemovedBrowserContext  ^editingClass isObsoletesimpleNameForSpotterMenu  ^'Protocols'testAllItems  | allItems unprepared |  allItems := cursor retrieveAll.  self deny: allItems equals: queryResult items.  self assert: (allItems collect: #actualObject) equals: queryResult items.  unprepared := allItems reject: #isPrepared.  self assert: unprepared isEmpty.  self assert: (allItems collect: #position) asArray equals: (1 to: queryResult size) asArrayexpectedFlatQueryResult  ^expectedFlatQueryResultexpansionChanged  queryView restoreSelectedItems.  self tableRefresh.  self table resetFunctiontitle: anObject  title := anObjectdescription  ^', ' join: (resultItems collect: [:each |  each printAsConstantQueryItem ])unsubscribe: anObject  announcer ifNil: [ ^self ].  announcer unsubscribe: anObjectfindItemsWith: aCollection  ^Array new: aCollection size withAll: nilreferencedClass  ^self classdefaultFocusMorph  ^itemsView filterField ifNil: [ itemsView dataSource table ]takeKeyboardFocus  table takeKeyboardFocusprepareItems: browserItems  browserItems do: [:each |  each ifNotNil: [ each prepareIn: self environment ] ].  ^browserItemschildrenDataSource  ^childrenDataSourceactivateFilterWith: patternString  self initiateUIChangeBy: [ table activateFilterWith: patternString.        self updateSelection ]initialize  super initialize.  mergedParts := #()testCompareWithSimilarQueryWhichSubqueryHasDifferentScope  | query2 |  query2 := self queryClass with: {(self subqueryFromScopeOf: self class superclass)}.  self deny: query equals: query2processDynamicMethodGroups: dynamicGroups by: aBlock  | activeGroups |  activeGroups := OrderedCollection new: dynamicGroups size.  self methodsDo: [:eachMethod |  dynamicGroups do: [:eachGroup |  (eachGroup dependsOnMethod: eachMethod) ifTrue: [ aBlock value: eachGroup.                    activeGroups add: eachGroup ] ].        dynamicGroups removeAll: activeGroups.        dynamicGroups ifEmpty: [ ^self ].        activeGroups reset ]itemsWhere: conditionBlock  | found item |  actualResult protectItemsWhile: [ found := OrderedCollection new.        actualResult items doWithIndex: [:each :i |  item := each asCalypsoBrowserItem.              (conditionBlock value: item) ifTrue: [ item position: i.                    item prepareIn: self environment.                    found add: item ] ].        ^found ]testExecution  self executeQuery.  self assert: resultItems size equals: 1testPrepareResultForExecution  | preparedResult |  preparedResult := query prepareNewResult.  self assert: preparedResult class equals: ClyAsyncQueryResult.  self assert: preparedResult buildingQuery identicalTo: query actualQuery.  self assert: preparedResult environment identicalTo: environment.  self assert: preparedResult isProtectedselectStringAsInMessageBrowser: criteriaString  | interval |  interval := (self findAnySelectorInSourceCode: {criteriaString}) ifEmpty: [ self findString: criteriaString asSelectorIn: self pendingText ].  textMorph setSelection: intervalbrowser  ^textArea editingMode browserlastSelectedProject  ^self lastSelectedObjectIn: self selectedProjectssimpleNameForSpotterMenu  ^'Comment editor: ' , self editingClass nameexpectedSourceCodeSubstring  ^'it should be in the source code of ' , #expectedMethodrenameClassTagTo: newTag  self classes do: [:each |  each tagWith: newTag.        each untagFrom: self tag ].  classQuery scope packagesDo: [:each |  (each tagsForClasses includes: newTag) ifFalse: [ each addClassTag: newTag ].        each removeClassTag: self tag ]methodWithoutWatchpoint  name: anObject  name := anObjectredoList  ^redoListsnapshotState  | dataSourceSnapshot |  dataSourceSnapshot := selection rootDataSource copyForBrowserStateSnapshot.  ^ClyQueryViewState new     dataSource: dataSourceSnapshot;     selection: (selection copyForBrowserStateSnapshotOf: dataSourceSnapshot)pattern  ^patternsize  ^items sizeisMethodSelected  ^selectedItems anySatisfy: [:each |  each isBasedOnItemType: ClyMethod ]runTestCase: testCase results: testResult  testCase resetHistory.  testCase suite run: testResultpattern: anObject  pattern := anObjecttestConvertingToNewMetaLevel  | newQuery |  newQuery := query withMetaLevelScope: ClyInstanceSideScope.  self assert: newQuery scope class equals: ClyInstanceSideScope.  self assert: newQuery scope basisObjects equals: query scope basisObjectsexecute  (ChangesBrowser changes: {critique change}) openasInterestingClassScope  ^self copy relationScopeClasses: (relationScopeClasses collect: [:each |  each asInterestingClassScope ])initialize  super initialize.  self     changeTableLayout;     listDirection: #leftToRight;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     extent: 0 @ 0prepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browser.  systemEnvironment := aToolContext systemEnvironmentrepresentsScope: aScopeClass  self subclassResponsibilitytestNotSelectsMethodWithCritiquesWhenTheyNotComputedYet  self deny: (query selectsMethod: ClyClassWithProblemMethods >> #methodWithHalt)execute  testItems do: [:each |  self runTestCase: each actualObject ]testNotSelectsAbstractMethodWhichIsImplemented  self deny: (query selectsMethod: ClyAbstractClassExample >> #abstractMethod1)buildResult: aQueryResult  aQueryResult fillWith: (scope basisObjects sorted: #printString ascending)initialize  super initialize.  stringPattern := ClySubstringPattern with: '' caseSensitive: falseremoveFromBrowser  containerTab deleterequiredQueryResult  ^ClyTraitUserHierarchy new asQueryResultdescription  ^'Automatically resolve the issue'execute  browser switchToFullClassHierarchyisLive  ^definingClass isClassSidebrowser: aBrowser  browser := aBrowseropenInspector  actualVariable value inspectrebuild  super rebuild.  self buildIndexesexecute  self methods do: [:method |  self generateTestMethodFor: method ].  testMethodToBrowse ifNotNil: [:testMethod |  browser selectMethod: testMethod ]dialogClass  ^dialogClassbuildResult: aQueryResult  aQueryResult fillWith: self scopedMethodsisProjectChildSelected  ^self selectedProjectChildItems notEmptylastSelectedSourceNode  ^self lastSelectedMethod astForStylingInCalypsotestAscendingSamePackageSameClassDifferentSelector  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: Object >> #yourself value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #yourself)createMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'breakpoints' priority: 8.4 on: aMethodQuerytestIsNotBasedOnSingleBasis  scope := self createSampleScope.  self deny: scope isBasedOnSingleBasisisInlined  ^truetestMethodsEnumerationWithBothMetaLevelScopeShouldNotDublicateMethods  | expected |  scope := ClySuperclassScope of: ClySubclassN1OfClass1FromP1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:each |  each methodClass instanceSide = ClyClass1FromP1 ifTrue: [ result add: each ] ].  expected := (ClyClass1FromP1 localMethods , ClyClass1FromP1 class localMethods) asIdentitySet.  self assert: result asIdentitySet equals: expectedsetUp  super setUp.  group := self createMethodGroupconfirmUnusedClasses: classes  | refQuery noUsers answer subclasses users |  refQuery := ClyClassReferencesQuery toAny: classes from: self systemScope.  noUsers := self confirmEmptySystemQuery: refQuery excluding: (classes flatCollect: [:each |  {each .               each classSide} ]).  subclasses := (classes flatCollect: [:each |  each subclasses ]) copyWithoutAll: classes.  subclasses ifNotEmpty: [ noUsers := false.        answer := UIManager default confirm: 'There are subclasses. Show them?'.        answer ifTrue: [ self spawnQueryBrowserOn: (ClyConstantQuery returning: subclasses) ] ].  users := (classes flatCollect: [:each |  each users ]) copyWithoutAll: classes.  users ifNotEmpty: [ noUsers := false.        answer := UIManager default confirm: 'There are users of trait. Show them?'.        answer ifTrue: [ self spawnQueryBrowserOn: (ClyConstantQuery returning: users) ] ].  ^noUsersactivationPriorityInNonActiveContext  ^isManagedByUser ifTrue: [ self activationPriority ] ifFalse: [ Float negativeInfinity ]isResult: aQueryResult affectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsMethods and: [ scope includesMethodsAffectedBy: aSystemAnnouncement ]testConvertingToScopeIncludedInheritingScope  | convertedScope inheritingScope |  scope := self createSampleScope.  inheritingScope := scope asInheritingScope.  convertedScope := scope withInheritingScope.  self assert: convertedScope class equals: ClyCompositeScope.  self assert: convertedScope name equals: ClyClassScope userHierarchyScopeName.  self assert: (convertedScope subscopes includes: scope).  self assert: (convertedScope subscopes includes: inheritingScope)methodGroupProvidersDo: aBlock  | providers |  environment pluginsDo: [:plugin |  providers := plugin collectMethodGroupProviders.        providers do: aBlock ]defaultItems  ^#()initialize  super initialize.  changes := IdentitySet newbaseCritiqueQuery: aCritiqueQuery  baseCritiqueQuery := scope adoptQuery: aCritiqueQuerycheckEmptyResult  | classPackage |  scope methodsDo: [:eachMethod |  classPackage := eachMethod origin package.        (eachMethod isDefinedInPackage: classPackage) ifFalse: [ eachMethod package ifNotNil: [:p |  ^false ] ] ].  ^trueannounceChangesOf: aQueryResult  aQueryResult notifyChangestestClassEnumerationOverMetaclassBasisWhenInstanceSideIsLocalScope  scope := ClyInterestingSuperclassScope of: ClySubclassN1OfClass1FromP1 class localScope: ClyInstanceSideScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {ClyClass1FromP1} asSettestComparison  self assert: (ClyClassCommentsQuery withString: 'test substring') equals: (ClyClassCommentsQuery withString: 'test ' , 'substring').  self assert: (ClyClassCommentsQuery withString: 'test substring') hash equals: (ClyClassCommentsQuery withString: 'test ' , 'substring') hash.  self deny: (ClyClassCommentsQuery withString: 'test substring') equals: (ClyClassCommentsQuery withString: 'another substring')async  ^selfeditingMethod  ^editingMethodprintIt  | printString |  self evaluateSelectionAndDo: [:result |  printString := [ result asScriptResultStringInCalypso ] on: Error do: [ '<error in printString: try ''Inspect it'' to debug>' ].        self afterSelectionInsertAndSelect: printString ]= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^hierarchy = anObject hierarchyisExecutedFromScopeOf: basisObject  ^scope isBasedOn: basisObjecttargetView  ^targetViewtestIsAffectedByChangeOfSuperclassMethodWhichIsAlreadyImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #overriddenMethod)methodWithHalts2  self haltrecordNavigationState: aBrowserNavigationState  navigationHistory recordState: aBrowserNavigationStateloadAsyncQueryResult  ^methodQuery executechangesCancelRequested: aRubCancelEditRequested  changesCancelRequested := truedescription  ^'rest unclassified classes'testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScope  < expectedFailure>  super testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScopesetUpDefaultIcon  | iconName |  iconName := editingClass hasComment ifTrue: [ #commentsIcon ] ifFalse: [ #uncommentedClass ].  containerTab icon: (self iconNamed: iconName)allCount  ^allCounttestFindTestCaseWithAnotherSuffixCoveringTestedClass  | foundClass |  foundClass := plugin findTestCaseCovering: ClyTestedClass2 ifAbsent: [  ].  self assert: foundClass equals: ClyTestedClass2TesttestExpectedFailure  < expectedFailure>  self assert: false description: 'it is example test with expected failure'applyChanges  self pendingText asString = self editingText ifFalse: [ editingPackage packageManifest comment: self pendingText stamp: Author changeStamp ].  ^truepackage  ^packageadoptForBrowser  buildingQuery retrievesBrowserItems ifTrue: [ ^ClyAsyncBrowserQueryResultAdapter for: self ].  ^super adoptForBrowserorder  ^2isSelectedItemHasBreakpoint  ^selectedSourceNode hasBreakpointdecorateBrowserItem: anItem ofMethod: aMethod  aMethod containsHalt ifTrue: [ anItem markWith: ClyMethodWithHaltTag ].  aMethod hasBreakpoint ifTrue: [ anItem markWith: ClyMethodWithBreakpointTag ].  (self doesMethodHasExecutionCounter: aMethod) ifTrue: [ anItem markWith: ClyMethodWithExecutionCounterTag ].  (self doesMethodHasWatchpoint: aMethod) ifTrue: [ anItem markWith: ClyMethodWithWatchpointTag ]prepareBasisFrom: aCollection  aCollection size = 1 ifFalse: [ self error: 'System scope should be created on single basis' ].  ^aCollectiontestComparison  self assert: (ClyConstantMethodQuery with: {(self class >> #method1)}) equals: (ClyConstantMethodQuery with: {(self class >> #method1)}).  self assert: (ClyConstantMethodQuery with: {(self class >> #method1)}) hash equals: (ClyConstantMethodQuery with: {(self class >> #method1)}) hash.  self deny: (ClyConstantMethodQuery with: {(self class >> #method1)}) equals: (ClyConstantMethodQuery with: {(self class >> #method2)})filteredBy: anItemFilter  ^ClyFilterQuery for: self filter: anItemFilterchooseClassToBrowseFrom: aClassNamePattern  | query result |  query := (ClyAllClassesQuery sortedFrom: self systemScope) filteredBy: (ClyItemNameFilter substringPattern: aClassNamePattern).  result := query execute.  result isEmpty ifTrue: [ ^nil ].  result size = 1 ifTrue: [ ^result items first ].  ^[ self searchDialog requestSingleObject: 'Choose a class to browse...' from: query ] on: CmdCommandAborted do: [ nil ]testComparisonOfSimilarQueriesWithEqualScopes  | query2 |  query2 := self createQuery.  query scope: (ClyScopeExample of: #basisObject in: environment).  query2 scope: (ClyScopeExample of: #basisObject in: environment).  self assert: query equals: query2.  self assert: query hash equals: query2 hashmethod2  ^#method2decorateContainerTab  | title |  super decorateContainerTab.  title := editingClass name.  editingClass isClassSide ifTrue: [ title := title asText allBold asStringMorph ].  containerTab label: titledefaultMenuItemName  ^'History'prepare  self adoptBrowserToolLayout.  self createCriticView.  progressMorph := ClyActivityAnimationIconMorph label: 'critiques analysis'defaultMenuIconName  ^#smallDebugtestFillingWithMetaclass  queryResult fillWith: {Array class}.  self assert: queryResult items equals: {Array binding}description  ^'extension methods of ' , package nametestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithUndeclares >> #method1WithUndeclares) .         (ClyClassWithUndeclares >> #method2WithUndeclares) .         (Object >> #printString)}.  self assert: foundSelectors sorted asArray equals: #(method1WithUndeclares method2WithUndeclares)testFillingWithClassAndItsTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot1 .         3}execute  Watchpoint in: sourceNodeaffectsMethodsDefinedInPackage: aPackage  ^aPackage definesOverridesOf: self overriddenMethodtestNotExecutedFromSingleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  < expectedFailure>  super testNotExecutedFromSingleScopeWhenSubqueriesAreFromScopesOfDifferentObjectsretrievesItemsOfType: itemTypeClass  ^self resultItemsType isCalypsoItemType: itemTypeClasscreateQueryResult  ^ClySemiAsyncQueryResult newincludesMethodsAffectedBy: aSystemAnnouncement  self classesDo: [:each |  (each includesMethodsAffectedBy: aSystemAnnouncement) ifTrue: [ ^true ] ].  ^falseselectedObjects  ^self actualSelectionFrom: selectedItemsexecute  | packageEditor |  packageEditor := methodEditor tagsAndPackageEditor.  packageEditor requestChangeBy: [ packageEditor requestPackage ]browser: anObject  browser := anObjecttitle  ^titlecreateQuery  ^ClyUnknownQuery newupdateSelectedItemsOf: aDataSource  | actualSelectionChanged |  self initiateUIChangeBy: [ actualSelectionChanged := selection updateItemsWhichBelongsTo: aDataSource.        highlighting updateItemsWhichBelongsTo: aDataSource.        desiredSelection ifNotNil: [ desiredSelection updateItemsWhichBelongsTo: aDataSource.              actualSelectionChanged := actualSelectionChanged | (desiredSelection restoreCurrentSelectionAfterUpdate: selection) ].        ^actualSelectionChanged ]packageSelection  ^packageView selection asSelectedParentsOf: RPackageanalyzedObject  ^analysisScope basisObjects anyOnetestBindToEnvironment  scope := self createSampleScope.  scope bindTo: environment.  self assert: scope environment equals: environment.  self assert: scope isBoundToEnvironmentisResult: aQueryResult affectedBy: aSystemAnnouncement  ^self subclassResponsibilityselectedProjectItems  ^selectedItems collect: [:each |  each rootParentItem ]testAscendingMethodsWithSameSelectorButDifferentClass  function := ClySortMethodBySelectorFunction ascending.  self deny: (function value: Object >> #printString value: Number >> #printString).  self assert: (function value: Number >> #printString value: Object >> #printString)traitScopeClass  ^ClyTraitUserScopecreateQuery  ^ClyTaggedClassesQuery by: #Tag1 from: (ClyClassScope of: Object in: environment)defaultMenuItemName  ^'Overridden methods'isMainColumn  ^falseprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  aStream nextPutAll: name.  aStream nextPut: $)markWith: simpleTagClass  self addProperty: simpleTagClass instancesnapshotState  self subclassResponsibilityprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  testCase printOn: aStream.  aStream nextPut: $)name  ^nametestConvertingWithNewRequiredResultShouldConvertActualQueryToo  | newResult convertedQuery |  newResult := ClyRawQueryResult new.  convertedQuery := query withResult: newResult.  self assert: convertedQuery actualQuery requiredResult identicalTo: newResultbuildAndDecorate  self isBuilt ifTrue: [ ^self ].  self setUpParametersFromModel.  self decorateContainerTab.  self build.  self buildStatusBar.  self applyDecorations.  self attachToSystemselectPackage: aPackage  self changeStateBy: [ packageView selection selectItemsWith: {aPackage}.        packageView selection isEmpty ifTrue: [ self switchToPackages ].        packageView selection selectItemsWith: {aPackage} ]= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^definingClass = anObject definingClass and: [ actualVariable = anObject actualVariable ]testComparingWithAnotherAsyncQueryWithDifferentAsyncResult  | anotherQuery |  anotherQuery := query semiAsync.  self deny: query equals: anotherQuerytestConvertingToInterestingClassScope  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asInterestingClassScope.  self assert: convertedScope equals: scopeexecute  ExecutionCounter installOn: sourceNodeupdateIfDirty  rootDataSource isDirty ifTrue: [ rootDataSource runUpdate ].  items do: [:each |  each ownerDataSource isDirty ifTrue: [ each ownerDataSource runUpdate ] ]testGettingAllItems  | actual |  queryResult fillWith: #(1 2 3).  actual := queryResult allItems.  self assert: actual asArray equals: #(1 2 3)name: anObject  name := anObjectprojectManager  ^projectManagertestComparisonWithDifferentRelationScopes  | scope2 |  scope := ClyMultipleClassRelationScope of: #() merging: {ClySuperclassScope}.  scope2 := ClyMultipleClassRelationScope of: #() merging: {ClySubclassScope}.  self deny: scope equals: scope2createQuery  ^ClyAllMethodGroupsQuery from: ClyClassScope of: Object in: environmentmethods: anObject  methods := anObject asIdentitySetinitialize  super initialize.  color := Color transparent.  self changeTableLayout.  self vResizing: #shrinkWrap.  self hResizing: #shrinkWrap.  self minWidth: 0.  self minHeight: 0browserTool  ^browserToolisExecutedFromScope: aTypedScopeClass  ^scope representsScope: aTypedScopeClassselectSourceNode: aCDNode  textMorph setSelection: aCDNode sourceIntervalstop  ^stopbuildContextBar  contextBar := Morph new     setNameTo: 'context bar';     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     cellInset: 4 @ 0;     color: Color transparent;     height: 0;     minHeight: 0.  self addMorphBack: contextBarexecute  browser switchToFlatClassestestConvertingWithoutAbsentBasisObject  | convertedScope |  scope := self createSampleScope.  convertedScope := scope withoutBasisObject: #notExistedBasis.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects equals: scope basisObjectstestDescendingSamePackageDifferentClass  function := ClySortMethodByPackageFunction descending.  self deny: (function value: Object >> #printString value: True >> #not).  self assert: (function value: True >> #not value: Object >> #printString)createQuery  ^super createQuery semiAsyncupdateMainWindowTitle  | activeWindow |  activeWindow := self activeWindow ifNil: [ ^self ].  self window ifNotNil: [:w |  w setLabel: activeWindow label ]conditionBlockProducerMethodAST: conditionString  | conditionBlockProducerMethodAST conditionAST |  conditionAST := self parserClass parseExpression: conditionString.  conditionBlockProducerMethodAST := RBMethodNode selector: #conditionBlockGenerator body: (RBReturnNode value: (RBBlockNode arguments: {(RBVariableNode named: 'ThisContext')} body: (RBMessageNode receiver: (RBVariableNode named: 'Breakpoint') selector: #checkBreakConditionValue: arguments: {conditionAST}) asSequenceNode)) asSequenceNode.  conditionBlockProducerMethodAST := self rewriteASTToSimulateExecutionInADifferentContext: conditionBlockProducerMethodAST.  conditionBlockProducerMethodAST source: conditionBlockProducerMethodAST formattedCode.  ^conditionBlockProducerMethodASTshowPackage: aPackage atClassTag: tagName  tool selectPackage: aPackage atClassTag: tagNamepattern: anObject  pattern := anObjectgroupProviderClass  self subclassResponsibilitycreateCommandContext  ^self createTextContextname  ^browserItem nameaffectsMethodsTaggedWith: tagName  ^testCase tagsForMethods includes: tagNamedecorateBrowserItem: anItem ofPackage: aPackage  (aPackage classes anySatisfy: [:testCase |  testCase isTestCase and: [ testCase isAbstract not ] ]) ifFalse: [ ^self ].  anItem addProperty: ClyTestResultProperty newtestConvertingToAsyncQuery  | convertedQuery |  convertedQuery := query async.  self assert: convertedQuery class equals: ClyAsyncQuery.  self assert: convertedQuery actualQuery identicalTo: query.  self assert: convertedQuery requiredResult identicalTo: query requiredResult.  self assert: convertedQuery scope identicalTo: query scope.  self assert: convertedQuery asyncResult class equals: ClyAsyncQueryResultshowMethod: aMethod  tool selectMethod: aMethodopenAnotherBrowser: aBrowser  aBrowser opentestMethodsEnumeration  scope := ClyPackageScope of: ClyClass1FromP1 package.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyClass1FromP1 localMethods).  self assert: (result includesAll: ClyClass2FromP1 localMethods).  self assert: (result includesAll: ClyClass1FromP1 classSide localMethods) description: 'Package scope should see class side methods too'.  self assert: (result includesAll: ClySubclassLOfClass0FromPExtendedByP1 localMethods) description: 'Package scope should see all clas extensions'registerProjectManager: aPackageManager  projectManagers removeAllSuchThat: [:each |  each class = aPackageManager class ].  projectManagers add: aPackageManagertestNotBuiltByDefault  queryResult := queryResult class new.  self deny: queryResult isBuiltisPackagePartOfSelection: aPackage  (self isPackageSelected: aPackage) ifTrue: [ ^true ].  ^self projectSelection actualObjects anySatisfy: [:each |  each includesPackage: aPackage ]testFillingWithOnlyClassWhichHasTraits  queryResult fillWith: {ClyClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0}testIsExecutedFromMultipleScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self assert: query isExecutedFromMultipleScope.  query scope: (ClyScopeExample of: #singleObject in: environment).  self deny: query isExecutedFromMultipleScope.  query scope: (ClyScopeExample emptyIn: environment).  self deny: query isExecutedFromMultipleScopeshowsItemsOfType: itemTypeClass  ^self query retrievesItemsOfType: itemTypeClassitemType  ^itemTypedescription  ^'Run the example'projectManager: anObject  projectManager := anObjectdescription  ^'methods with undeclared variables'hash  ^super hash bitXor: excludesHaltsForTesting hashcollapsedItems: items  collapsedItems := itemsgetMetaProperty: aPropertyClass  ^self itemCursor getMetaProperty: aPropertyClassrebuildToolbar  toolbar updateItemsresetScope  scope := ClyUnknownScope instanceconfirmUnusedVariablesInDefiningClass: variables  ^tool confirmUnusedVariablesInDefiningClass: variablesbrowserTool  ^browserToolclassSampleWhichHasGroup  ^ClyClassWithFFIMethodssingleScopeSample  | newScope |  newScope := super singleScopeSample.  newScope relationScopeClasses: {ClySuperclassScope}.  ^newScopeone  ^oneselectAsMainTab  containerTab selected: true.  (browser tabManager tabMorph instVarNamed: #contentsWrapper) color: self activeColoropenInspector  actualVariable value inspectcollectMethodGroupProviders  ^{ClyFFIMethodGroupProvider new}hash  ^super hash bitXor: resultItems hashisTraitSelected  | classItem |  classItem := self lastSelectedObjectIn: self selectedClassItems.  ^classItem isMarkedWith: ClyTraitTagtestExecution  self executeQuery.  self assert: resultItems asArray equals: query resultItems= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^hierarchy = anObject hierarchybrowser: aMethodBrowser  browser := aMethodBrowser.  self buildtestFillingWithTraitsOfClassWhichIsMissingInGivenList  queryResult fillWith: {ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyTraitChild1 .         0 .         ClyTraitRoot1 .         1 .         ClyTraitChild2Child .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot1 .         2}itemsChangedIn: aDataSource  | selectionWasEmpty |  self refreshAsyncState.  selectionWasEmpty := self selection isEmpty.  browser ignoreNavigationDuring: [ self updateSelectedItemsOf: aDataSource.        selectionWasEmpty ifTrue: [ self ensureSelectedItemIfNeeded ] ].  browser itemsChangedinitialize  super initialize.  executionSemaphore := Semaphore newrequestSingleMethodTag: queryTitle  ^self requestSingleMethodTag: queryTitle suggesting: ''switchResultTo: aQueryResult  self changeStateBy: [ systemQuery := systemQuery withResult: aQueryResult.        self showQueryResult ]changeStateOf: aQueryView by: aBlock  aBlock valuechangeMethodGroupQueryBy: aBlock  self changeStateBy: [ methodGroupQuery := aBlock value.        methodGroupView showQuery: methodGroupQuery.        methodGroupView initiateUIChangeBy: [ self methodGroupSelectionChanged ] ]countToolsSimilarTo: aBrowserTool  ^tools count: [:each |  each class = aBrowserTool class ]printExtraInfoOn: aStream  super printExtraInfoOn: aStream.  aStream nextPutAll: critiqueQuery descriptionimplementorsOfIt  | selector |  (selector := self selectedSelector) == nil ifTrue: [ ^textArea flash ].  selector isCharacter ifTrue: [ ^textArea flash ].  self browser browseImplementorsOf: selectorasInterestingClassScope  ^self asScope: ClyInterestingSuperclassScopeisCurrentStateOf: aQueryView  ^(aQueryView dataSource isInSameStateAs: dataSource) and: [ aQueryView selection isSameAs: selection ]priority  ^priority ifNil: [ self class priority ]findItemsWith: actualObjects  | foundItems |  foundItems := self itemCursor findItemsWith: actualObjects.  ^foundItems select: #notNil thenCollect: [:each |  self createElementWith: each ]testConvertingWithNewScope  | newScope convertedQuery |  newScope := ClyScopeExample2 of: #someBasis in: environment.  convertedQuery := query withScope: newScope.  self assert: convertedQuery class equals: query class.  self assert: convertedQuery requiredResult identicalTo: query requiredResult.  self assert: (convertedQuery subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (convertedQuery subqueries collect: #scope as: Set) equals: {newScope} asSetdecorateTableCell: anItemCellMorph of: groupItem  super decorateTableCell: anItemCellMorph of: groupItem.  methodQuery decorateMethodGroupTableCell: anItemCellMorph of: groupItemtestMethodsEnumeration  scope := ClyPackageExtensionScope of: ClyClass1FromP1 package.  scope methodsDo: [:each |  result add: each ].  self deny: (result includesAll: ClyClass1FromP1 localMethods).  self deny: (result includesAll: ClyClass2FromP1 classSide localMethods).  self assert: (result includesAll: ClySubclassLOfClass0FromPExtendedByP1 localMethods)isBasedOnMultipleBasis  ^self basisSize > 1methodWithFlag  self flag: #todo= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^actualObjectSortFunction = anObject actualObjectSortFunctionisLive  ^truechangeStateBy: aBlock  browser changeStateOf: self by: aBlockoverridingSubclass  ^overridingSubclasstestExecution  self executeQuery.  self assert: result identicalTo: ClyUnknownQueryResult instance.  self assert: resultItems equals: #()execute  browser updateisForbidden  ^self toolClass isAbstractisReadIn: aMethod  (self isAccessibleFrom: aMethod origin) ifFalse: [ ^false ].  ^actualVariable isReadIn: aMethodinitialize  super initialize.  testCaseResults := IdentityDictionary newproperties: anObject  properties := anObjectcreateQuery  ^ClyOverridingMethodsQuery from: ClyClassScope of: ClyClassWhichInheritsAbstractClass in: environmentpackage: anObject  package := anObjectreadParametersFromContext: aToolContext  menuItemName := aToolContext tool hasUnacceptedEdits ifTrue: [ 'Classify currently editing method' ] ifFalse: [ 'Classify method' ]initialize  super initialize.  query := ClyUnknownQuery instance.  itemCursor := ClyClosedBrowserCursor instance.  depth := 0.  dirty := falsequeryCache  ^queryCachechangesAccepted  | applied |  ^self applyChangesBy: [ textMorph hasUnacceptedEdits: true.        [ self changesAreAboutApply.        applied := self applyChanges ] on: Error do: [:err |  textModel text: self editingText.              textMorph hasUnacceptedEdits: true.              err pass ].        applied ifTrue: [ textMorph hasUnacceptedEdits: false.              self textUpdated.              browser focusActiveTab ] ifFalse: [ textModel text: self editingText.              textMorph hasUnacceptedEdits: true ] ]overriddenSuperclass: anObject  overriddenSuperclass := anObjecthash  ^requiredResult hash bitXor: scope hashtestResultOf: anItem  ^anItem getProperty: ClyTestResultPropertyorder  ^4printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  childrenType printOn: aStream.  aStream nextPut: $)execute  classGroup removeWithClassessetUp  super setUp.  self setUpEnvironmentconvertToMethodTag: aTagName  self methods do: [:each |  each tagWith: aTagName ]defaultMenuItemName  ^'Add breakpoint once'isActiveInContext: aBrowserItemContext  ^(super isActiveInContext: aBrowserItemContext) and: [ annotatedClass wantsDecorateTableCellInContext: aBrowserItemContext ]newName: anObject  newName := anObjecttestNotAffectedByChangeOfOverriddenMethodFromAnotherHierarchyWhenSameMethodExistsHereToo  self deny: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)abstractMethod2  self subclassResponsibilitysimpleNameForSpotterMenu  ^'Query result'position  ^browserItem positionscheduleUpdate  self class scheduleUpdateOf: selftestSelectsMethodWithFlag  self assert: (query selectsMethod: ClyClassWithFlags >> #methodWithFlag)defaultMenuItemName  ^'Browse'retrievesItem: anObject  ^resultItems includes: anObjectbrowserState: anObject  browserState := anObjectitems: anObject  items := anObjectformatAsYouRead  ^RBProgramNode formatterClass formatAsYouReadPolicytestFillingWithThreeClasses  queryResult fillWith: {ClyClass2FromP1 .         ClySubclassN1OfClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassN1OfClass1FromP1 .         1 .         ClyClass2FromP1 .         0}setUpIconForMenuItem: aMenuItemMorph  overriddenMethod  ^#originalValueclose  | currentWindow |  currentWindow := self window.  (currentWindow ownerThatIsA: GroupWindowMorph) ifNotNil: [:group |  ^self okToChange ifTrue: [ [ group removeWindow: currentWindow ] on: ProvideAnswerNotification do: [:notification |  notification resume: true ] ] ].  currentWindow closepackageNamed: aString  ^packageOrganizer packageNamed: aStringrestrictMethodVisibilityBy: aClassScope  self changeMethodGroupQueryBy: [ methodGroupQuery restrictedByScope: aClassScope ]hasBindingThatBeginsWith: aString  ^self selectedClassOrMetaClass ifNil: [ false ] ifNotNil: [:c |  c hasBindingThatBeginsWith: aString ]isCaseSensitive: anObject  isCaseSensitive := anObjectcreateInheritedScopeFrom: aClassScope  | scope |  scope := annotatedClass createInheritedScopeFrom: aClassScope.  scope name: ClyClassScope inheritedScopeName.  ^scopescopeWithoutCritiques  ^ClyMethodScope of: self methodWithoutCritiques in: environmentisVariableSelected  | node binding |  self isClassSelected ifTrue: [ ^false ].  node := self selectedSourceNode.  node isVariable ifFalse: [ ^false ].  binding := node binding.  ^binding isClassVariable | binding isInstance | binding isGlobalVariable | binding isUndeclaredselectedPackageItems  ^selectedItemsdefaultMenuItemName  ^'Browse test class'classQuery: anObject  classQuery := anObjectisAffectedByChangedMethod: aMethod  | methodClass selector |  selector := aMethod selector.  methodClass := aMethod origin.  (self isFromScopeWithClassKindOf: methodClass) ifFalse: [ ^false ].  ^(self isAbstractMethod: aMethod) or: [ self isClass: methodClass shouldImplement: selector ]testIsExecutedFromScopeOfBasisObject  query scope: (ClyScopeExample of: #basis in: environment).  self assert: (query isExecutedFromScopeOf: query scope basisObjects anyOne).  self deny: (query isExecutedFromScopeOf: #someObject)classesDo: aBlock  subscopes do: [:each |  each classesDo: aBlock ]belongsToCurrentBrowserContext  | packageSelection |  packageSelection := browser packageSelection.  package ifNil: [ ^packageSelection isEmpty ].  packageSelection isEmpty ifTrue: [ ^true ].  ^packageSelection includesActualObject: packagesimpleNameForSpotterMenu  ^'Methods'testCheckIfEmpty  query scope: (ClyClassScope of: ClyClass6UntaggedFromP5 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ClyClass7WithTag1FromP5 in: environment).  self assert: query checkEmptyResultbrowserTool  ^textArea editingMode browserTooltargetVarName  ^#referencedVar1checkEmptyResult  executionSemaphore wait.  super checkEmptyResultdefaultTitle  ^'Comment'fillWith: objects  | itemsPerClass localItems classMap |  itemsPerClass := self buildItemsPerClassFrom: objects.  classMap := ClySubclassHierarchy buildFrom: itemsPerClass keys.  items := OrderedCollection new: objects size.  classMap doInOrderWithDepth: [:eachClass :depth |  localItems := itemsPerClass at: eachClass.        localItems do: [:each |  each depth: depth ].        items addAll: localItems ]withMetaLevelScope: aScopeClass  | newSubqueries |  newSubqueries := subqueries collect: [:each |  each withMetaLevelScope: aScopeClass ].  ^self class with: newSubqueries as: requiredResultprintExtraInfoOn: aStream  | descriptions |  super printExtraInfoOn: aStream.  descriptions := subqueries collect: [:each |  each description ] as: Set.  descriptions do: [:each |  aStream           nextPutAll: each;           nextPutAll: ', ' ].  aStream skip: -2entity: anObject  entity := anObjectselectVariableNamed: varName  self selectMethodGroupNamed: varNametestIsAffectedByChangeOfSuperclassMethodWhichOverridesAnotherSuperclassMethod  query := ClyOverridingMethodsQuery from: ClyClassScope of: ClyClassWhichInheritsAbstractSubclass in: environment.  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)defaultMenuIconName  ^#forwardfillWith: classes  items := classes collect: [:each |  (each isKindOf: Association) ifTrue: [ each ] ifFalse: [ each isObsolete ifTrue: [ GlobalVariable key: (each name allButFirst: 'AnObsolete' size) asSymbol value: each ] ifFalse: [ each instanceSide binding ] ] ]isEqualTo: anotherItem  ^browserItem isEqualTo: anotherItem browserItemtestApplyingToQueryViewShouldRestoreExpandedItems  | expandedItem newView |  self selectedItem expand.  self snapshotState.  newView := ClyQueryViewMorph for: browser.  navigationState applyTo: newView.  expandedItem := navigationState dataSource expandedItems first.  self assert: expandedItem childrenDataSource isClosed description: 'applying should not open data source snapshot'.  self assert: newView dataSource expandedItems size equals: 1.  expandedItem := newView dataSource expandedItems first.  self assert: (expandedItem isSameAs: self selectedItem).  self deny: expandedItem childrenDataSource isClosed.  self assert: expandedItem childrenDataSource queryView equals: newView.  self assert: expandedItem childrenDataSource table notNiltestDescending  function := ClySortItemGroupFunction descending.  self deny: (function value: (ClyItemGroup named: 'group1' priority: 20) value: (ClyItemGroup named: 'group2' priority: 10)).  self assert: (function value: (ClyItemGroup named: 'group1' priority: 10) value: (ClyItemGroup named: 'group2' priority: 20)).  self assert: (function value: (ClyItemGroup named: 'group2') value: (ClyItemGroup named: 'group1')).  self deny: (function value: (ClyItemGroup named: 'group1') value: (ClyItemGroup named: 'group2'))addPlugin: aBrowserPlugin  plugins detect: [:each |  each class = aBrowserPlugin class ] ifFound: [ ^self ].  aBrowserPlugin browser: self.  plugins add: aBrowserPlugindefaultMenuItemName  ^'Rename'testCreationOnTwoSimilarSubscopesOfSameObject  | subscope1 subscope2 |  subscope1 := ClyScopeExample ofAll: #(sameBasisObject basisObject1) in: environment.  subscope2 := ClyScopeExample ofAll: #(sameBasisObject basisObject2) in: environment.  scope := ClyCompositeScope on: {subscope1 .         subscope2}.  self assert: scope basisObjects asSet equals: #(sameBasisObject basisObject1 basisObject2) asSetclassGroup: anObject  classGroup := anObjecttestBasedOnSingleBasis  scope := self singleScopeSample.  self assert: scope isBasedOnSingleBasis.  scope := self multipleScopeSample.  self deny: scope isBasedOnSingleBasis.  scope := self emptyScopeSample.  self deny: scope isBasedOnSingleBasisisSingleSelected  ^items size = 1collectMetadataOfPackages: aQueryResult  testMethodsEnumerationWhenBasisIsTraitedClassClasSide  | expected |  scope := ClyInstanceSideScope of: ClyClassWithTraits classSide.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClassWithTraits methods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArrayscript: anObject  script := anObjectdisplayItemPropertyBy: propertyBlock  displayBlock := [:cell :item |  cell label contents: (propertyBlock value: item browserItem) ]isExpanded  ^ownerDataSource isExpanded: selftestMatchesStringWhichMatchesCorrectRegex  | pattern |  pattern := ClyRegexPattern with: '.abs'.  self assert: (pattern matches: '1abs').  self deny: (pattern matches: 'abs')dataSource  ^dataSourcehash  ^super hash bitXor: isCaseSensitive hashtestVariableLookup_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'var') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext lookupSymbol: #var)]')iconNameForSpotterMenu  ^#packageIconsystemEnvironment  ^self systemtestGettingAllItemsSatisfyingCondition  | actual |  queryResult fillWith: #(1 2 3 4 5 6).  actual := queryResult itemsWhere: [:each |  each between: 2 and: 4 ].  self assert: actual asArray equals: #(2 3 4)rootDataSource  ^ownerDataSource isRoot ifTrue: [ ownerDataSource ] ifFalse: [ ownerDataSource parentItem rootDataSource ]isClassGroupSelected  ^self hasSelectedItemsopenInspector  actualVariable inspectlocalScopeClass  ^self classisClassSelected: aClass  ^self selection items anySatisfy: [:methodItem |  methodItem systemDefinition definingClass == aClass ]isMenuItemMorph  ^truecleanCache  cache items: #()collectMetadataOf: aQueryResult by: anEnvironmentPlugin  anEnvironmentPlugin collectMetadataOfClassGroups: aQueryResulthash  ^definingClass hashhandlesMouseOver: evt  ^truedecorateTableCell: anItemCellMorph of: groupItem  testConvertingWithExtraBasisObject  | convertedScope |  scope := self singleScopeSample.  convertedScope := scope withExtraBasisObject: self extraBasisSample.  self assert: convertedScope class equals: scope class.  self assert: (convertedScope basisObjects includesAll: scope basisObjects).  self assert: (convertedScope basisObjects includes: self extraBasisSample).  self assert: convertedScope basisSize equals: scope basisSize + 1rebuildToolsForChangedEnvironment  tabManager updateToolsForChangedEnvironment.  self rebuildToolbarbrowser  ^browserviewStates  ^viewStatesname  ^actualVariable namecreateWindowGroupFrom: currentWindow  | group pos ext |  (currentWindow ownerThatIsA: GroupWindowMorph) ifNotNil: [:existing |  ^existing ].  pos := currentWindow position.  ext := currentWindow extent.  group := ClyGroupWindowMorph new.  group addWindow: currentWindow.  (group openInWindowLabeled: currentWindow label)     extent: ext;     position: pos.  ^groupfillWith: objects  fillWith: objects  items := objects collect: [:each |  ClyBrowserItem named: each printString with: each ]buildGroupFor: aClass depth: depth toShowMethodsFrom: aScope  | group item |  group := ClyInheritedMethodGroup withMethodsOf: aClass toShowIn: aScope.  item := group asCalypsoBrowserItem.  item depth: depth.  items add: itemselectedMessages  ^self selectedMethods collect: [:each |  SycMessageDescription ofMethod: each ]toggleExtendingPackage  extendingPackage ifNotNil: [ ^extendingPackage := nil ].  extendingPackage := browser searchDialog requestSingleObject: 'Choose package for method' from: ClyAllPackagesQuery sorteddescribes: aBrowserContext  ^aBrowserContext isAboutBrowserItemType: itemTypechooseClassesForNewMethod  ^self classSelection actualObjects collect: [:each |  metaLevelScope metaLevelOf: each ]defaultMenuIconName  ^#smallUpdatecachedResultOf: aQuery  ^queryCache at: aQuery ifAbsent: [ nil ]withInverseHierarchy  ^self copy hierarchy: hierarchy invertedbrowser  ^browserincludesMethodGroupsAffectedBy: aSystemAnnouncement  self methodGroupProvidersDo: [:each |  (each providesGroupsAffectedBy: aSystemAnnouncement inScope: self) ifTrue: [ ^true ] ].  ^falsebrowseReferencesTo: aSymbol from: anEnvironment  | classBinding |  aSymbol isSymbol and: [ aSymbol first isUppercase ifTrue: [ classBinding := anEnvironment bindingOf: aSymbol.              classBinding ifNotNil: [ ^self spawnQueryBrowserOn: (ClyClassReferencesQuery of: classBinding) ] ] ].  self browseSendersOf: aSymbolwindowIsClosing  navigationViews do: [:each |  each windowIsClosing ].  tabManager windowIsClosing.  self window ifNotNil: [:w |  w           removeMorph: self;           updatePanesFromSubmorphs;           model: nil ]testFillingWithEmptyList  queryResult fillWith: {}.  self assertItems: {ClyAllMethodGroup .         0}testBasedOnEmptyBasis  scope := self multipleScopeSample.  self deny: scope isBasedOnEmptyBasis.  scope := self singleScopeSample.  self deny: scope isBasedOnEmptyBasis.  scope := self emptyScopeSample.  self assert: scope isBasedOnEmptyBasisfilterInstalledMethods: methodsCollection  ^methodsCollection collect: [:each |  each origin localMethodNamed: each selector ifAbsent: [ nil ] ] thenReject: [:each |  each isNil or: [ each package isNil or: [ each isInstalled not ] ] ]changesAnnouncer  ^changesAnnouncerclear  commandBar removeAllMorphs.  contextBar removeAllMorphsdefaultMenuIconName  ^#glamorousBrowsenavigationHistory: aNavigationHistory  navigationHistory := aNavigationHistory= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^groupName = anObject groupNamemessageText  ^messageText ifNil: [ messageText := self standardMessageText ]userRequestString  ^'Don''t remove, but show me those senders'dependsOnMethod: aMethod  ^self includesMethod: aMethoddefaultIconName  ^nilcreateQuery  ^ClyFFIMethodQuery from: ClyClassScope of: Object in: environmenttestNotSelectsTaggedClass  self deny: (query selectsClass: ClyClass7WithTag1FromP5)setUp  super setUp.  result := SortedCollection sortBlock: #printString ascendinginitializeNavigationViews  packageView := self newPackageView.  classView := self newClassView.  methodGroupView := self newMethodGroupView.  methodView := self newMethodViewtestIsExecutedFromScopeOfBasisObject  self assert: (query isExecutedFromScopeOf: query scope basisObjects anyOne).  self deny: (query isExecutedFromScopeOf: #someObject)buildResult: aQueryResult  | filteredMethods vars |  vars := variableQuery execute items.  filteredMethods := OrderedCollection new.  scope methodsDo: [:each |  (self doesMethod: each useAnyOf: vars) ifTrue: [ filteredMethods add: each ] ].  aQueryResult fillWith: filteredMethodscreateQuery  | exampleCritique |  exampleCritique := self methodWithCritiques critiques anyOne.  ^ClyConcreteGroupCritiqueQuery filter: ClyAllMethodCritiqueQuery new from: self scopeWithCritiques byGroup: exampleCritique rule grouppackage: anObject  package := anObjectincludesClassNamed: aSymbol  ^globals includesKey: aSymboldecorateTool: aBrowserTool  plugins do: [:each |  each decorateTool: aBrowserTool ]selectedProjectItems  ^tool projectSelection itemsupdateMethodTagsAndPackage  methodTags := editingMethod tags reject: [:each |  each beginsWith: '*' ].  extendingPackage := editingMethod isExtension ifTrue: [ editingMethod package ] ifFalse: [ nil ]scopeClass  ^ClySubclassScopeisInstanceSide: anObject  isInstanceSide := anObjecttestMethodsEnumerationWhenBasisIsTraitedClassClassSide  | expected |  scope := ClyClassSideScope of: ClyClassWithTraits classSide.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClassWithTraits class methods reject: [:e |  e origin = TraitedClass ] thenCollect: #selector.  self assert: result sorted asArray equals: expected sorted asArraydecorateTableCell: anItemCellMorph of: groupItem  anItemCellMorph definitionIcon: ruleSeverity iconNametestClassNameFor: inputClass  ^(inputClass name , 'Test') asSymbolprintExtraInfoOn: aStream  super printExtraInfoOn: aStream.  aStream nextPutAll: self printVariablesconfirmUnusedVariables: variables  ^tool confirmUnusedVariables: variablestestCheckIfEmpty  | scope |  scope := ClyPackageScope of: ClyClass7WithTag1FromP5 package in: environment.  query scope: scope.  self deny: query checkEmptyResult.  scope := ClyPackageScope of: ClySubclassMOfClass1FromP2 package in: environment.  query scope: scope.  self assert: query checkEmptyResulttestConvertingToAnotherScopeClassShouldKeepName  | convertedScope |  scope := self createSampleScope.  scope name: 'test scope'.  convertedScope := scope asScope: ClyScopeExample.  self assert: convertedScope name equals: 'test scope'execute  classGroup renameClassTagTo: newNametestResult  ^self testResultOf: testItems firstitemsStartingWhere: conditionBlock count: size  actualResult protectItemsWhile: [ actualResult items doWithIndex: [:each :i |  (conditionBlock value: each asCalypsoBrowserItem) ifTrue: [ ^self itemsStartingAt: i count: size ] ] ].  ^#()tool: aBrowser  super tool: aBrowser.  metaLevelScope := aBrowser metaLevelScopemodifiesExtension  ^falsetestFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #sender1OfMessage1) .         (self class >> #senderOfMessage2)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #sender1OfMessage1snapshotState  ^ClyFullBrowserState of: selfremoveMethods: methods  (ClyShowMessageSenderCommand forMethods: methods by: browser) executeisInSameStateAs: anotherDataSource  ^self isSameAs: anotherDataSourcereference1OfVar1  ^referencedVar1activeScope  ^activeScopecreateFullUpdateOf: aBrowserQueryResult  ^aBrowserQueryResult createUpdateWithItemsStartingAt: startPosition count: sizeLimitmethodsDo: aBlock  basisObjects do: aBlockexecute  | testSuite result |  testSuite := self buildTestSuite.  result := testSuite run.  result updateResultsInHistory.  self notifyUserAboutResults: result with: 'Tests complete'classSampleWhichHasGroup  ^ClyMethodCallCountersQueryTestdefiningClass  ^self definingClassItem actualObjectannouncerPlugin: anObject  announcerPlugin := anObjecttestHasAsyncResultbyDefault  self assert: query asyncResult class equals: ClyAsyncQueryResultextensionMethodFromSubclassL  testAdoptQuery  | query adoptedQuery |  scope := self createSampleScope.  query := ClyQueryExampleReturningScopeBasis new.  adoptedQuery := scope adoptQuery: query.  self assert: adoptedQuery identicalTo: queryproperties  ^propertiesisResult: aQueryResult affectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsPackagestestCheckIfEmpty  query scope: (ClyClassScope of: ClyClass2FromP1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ProtoObject in: environment).  self assert: query checkEmptyResultfindItemsSimilarTo: sampleEnvironmentItems  | rest found |  actualResult protectItemsWhile: [ rest := sampleEnvironmentItems as: OrderedCollection.        found := OrderedCollection new.        actualResult items do: [:existing |  rest detect: [:sample |  sample isSimilarTo: existing ] ifFound: [:sample |  existing prepareIn: self environment.                    found add: existing.                    rest remove: sample.                    rest ifEmpty: [ ^found ] ] ].        ^found ]hierarchy  ^hierarchydefaultMenuItemName  ^'Run tests'projectClass  ^ClyManagedProjectisMethodTagSelected  self isMethodGroupSelected ifFalse: [ ^false ].  ^self selectedMethodGroupClass isBasedOnMethodTagtestFillingWithTwoSimilarCritiques  | method method2 critique group |  method := ClyClassWithProblemMethods >> #methodWithHalt.  method2 := ClyClassWithProblemMethods >> #methodWithHalt2.  critique := method critiques anyOne.  queryResult fillWith: method critiques , method2 critiques.  self assert: queryResult size equals: 1.  group := queryResult items first.  self assert: group class equals: ClyConcreteCritiqueMethodGroup.  self assert: group name equals: critique rule group asLowercase.  self assert: group ruleSeverity name equals: critique rule severitytestCheckIfEmpty  | scope |  scope := ClyInstanceSideScope of: ClyClass1FromP1 in: environment.  query scope: scope.  self deny: query checkEmptyResultprintBasisObject: aSystemEnvironment on: aStream  aStream nextPutAll: aSystemEnvironment namecheckEmptyResult  ^scope basisObjects isEmptytestPackageEnumeration  scope := ClyPackageScope ofAll: {Array package .         Object package}.  scope packagesDo: [:each |  result add: each ].  self assert: result asArray equals: {Array package .         Object package}testMethodNameFor: aMethod  ^aMethod selector asTestSelectordecorateTableCell: anItemCellMorph with: aMorph  super decorateTableCell: anItemCellMorph with: aMorph.  anItemCellMorph definitionIcon: #exceptionIconconfirmUnusedClasses: variables  ^tool confirmUnusedClasses: variablesremoveWithClasses  self classes do: [:each |  each removeFromSystem ]metaLevelOf: aClass  ^self class metaLevelOf: aClassfillWithVariables: varsPerClass type: varTypeClass  | classMap vars declarationGroup varItem methodQueryScope |  methodQueryScope := self queryScope asLocalClassScope.  classMap := hierarchy buildFrom: varsPerClass keys.  classMap doInOrder: [:eachClass |  vars := varsPerClass at: eachClass.        declarationGroup := ClyVarDefinitionMethodGroup withMethodsFrom: methodQueryScope referencedAny: varTypeClass definedIn: eachClass.        items add: declarationGroup asCalypsoBrowserItem.        vars do: [:each |  | varGroup |              varGroup := ClyVariableMethodGroup withMethodsFrom: methodQueryScope referencedVar: each.              varItem := varGroup asCalypsoBrowserItem.              varItem depth: 1.              items add: varItem ] ]description  ^'references to ' , self printVariableshasBindingOf: aString  ^self selectedClassOrMetaClass hasBindingOf: aStringdoesMethod: aMethod useVar: aVariable  ^aVariable isReadIn: aMethodaffectsMethodsDefinedInPackage: aPackage  ^testCase package == aPackage or: [ aPackage extendsClass: testCase ]classAffected  ^overriddenSuperclassvisibleClassScope: aClassScope  visibleClassScope := aClassScope asLocalClassScopeensureSystemDefinition: aBlock  self getProperty: ClyItemDefinitionProperty ifAbsent: [ self addProperty: aBlock value ]initialize  super initialize.  isCaseSensitive := falsereference2OfVar1  referencedVar1 := #testValuewithScopeOf: newBasisObjects  | newSubqueries |  newSubqueries := subqueries collect: [:each |  each withScopeOf: newBasisObjects ].  ^self withSubqueries: newSubqueriesenvironment  ^environmentsubqueryFromScopeOf: aBasisObject  ^self subqueryFromScope: ClyScopeExample of: aBasisObjecttestDescending  function := ClySortMethodBySelectorFunction descending.  self assert: (function value: Object >> #size value: Object >> #printString).  self deny: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)isExtension: anObject  isExtension := anObjectdependsOnMethod: aMethod  self asyncQueryResult isBuilt ifFalse: [ ^true ].  ^super dependsOnMethod: aMethodmethodWithHalts1  self haltcreateQueryResult  ^(ClySubclassHierarchy inverse , ClyTraitUserHierarchy inverse) asQueryResult sortedBy: ClyTraitFirstSortFunction ascendingcreateToolFor: aBrowser inContext: aBrowserContext  ^self toolClass for: aBrowser inContext: aBrowserContextspawnQueryBrowserOn: aQuery withState: navigationState  | actualQuery |  actualQuery := aQuery isBoundToEnvironment ifTrue: [ aQuery ] ifFalse: [ aQuery withScope: activeScope ].  super spawnQueryBrowserOn: actualQuery withState: navigationStatetestNotSelectsNotOverrideMethod  self deny: (query selectsMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)isWrittenIn: aMethod  (self isAccessibleFrom: aMethod origin) ifFalse: [ ^false ].  ^actualVariable isWrittenIn: aMethodmethodWithoutFlag  belongsToCurrentBrowserContext  ^(browser isClassSelected: editingClass) or: [ ^browser isClassSelected: editingClass instanceSide ]isAppliedToBrowser  ^(browser packageView showsItemsFromQuery: ClyAllPackagesQuery) and: [ browser isScopedModeEnabled ]selectedMethods  ^self actualSelectionFrom: self selectedMethodItemstestCheckIfEmpty  query scope: (ClyClassScope of: ClyAbstractSubclassExample in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ClyAbstractClassExample in: environment).  self assert: query checkEmptyResultextraBasisSample  ^#extraBasisasLocalClassScope  ^self asScope: localScopeClasstearDown  installedWatchpoint uninstall.  super tearDowntestComparison  self assert: ClyActiveBreakpointsQuery new equals: ClyActiveBreakpointsQuery new.  self assert: ClyActiveBreakpointsQuery newIncludingHaltsForTesting equals: ClyActiveBreakpointsQuery newIncludingHaltsForTesting.  self deny: ClyActiveBreakpointsQuery new equals: ClyActiveBreakpointsQuery newIncludingHaltsForTestingdecorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label clyAddEmphasis: TextEmphasis struckOutexpectedFlatQueryResult  ^expectedFlatQueryResulttestConvertingToInheritedScope  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asInheritedScope.  self assert: (convertedScope representsScope: ClySuperclassScope).  self assert: convertedScope localScopeClass equals: self scopeClass.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environment.  self assert: convertedScope name equals: ClyClassScope inheritedScopeNameisAppliedToBrowser  ^(browser packageView showsItemsFromQuery: ClyAllPackagesQuery) and: [ browser isScopedModeEnabled not ]initialize  super initialize.  allCount := 0.  successCount := 0.  failureCount := 0.  errorCount := 0totalItemCount: anObject  totalItemCount := anObjectisBuilt  ^items notNiltestNotSelectsNotDeprecatedMethod  self deny: (query selectsMethod: ClyClassWithDeprecatedMethods >> #notDeprecatedMethod)testPluginsWithoutBrowser  browser addPlugin: ClyStandardBrowserPlugin new.  self snapshotState.  self assert: navigationState browserPlugins first browser isNildefaultClassScopeForMethods  | selectedClassScope |  selectedClassScope := self classSelection asItemsScope: metaLevelScope.  ^self extendClassScopeForMethods: selectedClassScopetestConvertingAsRestrictedByAnotherScope  | convertedScope restrictedScope |  scope := self multipleScopeSample.  restrictedScope := self singleScopeSample.  convertedScope := scope restrictedBy: restrictedScope.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects equals: restrictedScope basisObjectscollectMetadataOf: aQueryResult by: anEnvironmentPlugin  anEnvironmentPlugin resolveMetadataOfCritiques: aQueryResultcreateQueryResult  self subclassResponsibilityreferencesToIt  | selector |  (selector := self selectedSelector) == nil ifTrue: [ ^textArea flash ].  self referencesTo: selectortestInstVarsEnumeration  scope := ClyClassScope of: ClyClass1FromP1.  scope instanceVariablesDo: [:each |  result add: each ].  self assert: (result as: Set) equals: {(ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)} asSetsetUpModelFromContext  super setUpModelFromContext.  editingPackage := context lastSelectedPackageenvironment  ^environmentlastSelectedMethodGroup  ^self lastSelectedObjectIn: self selectedMethodGroupsisMarkedWith: propertyClass  ^browserItem isMarkedWith: propertyClassdecorateResultMethodEditor: aMethodEditor  isPrepared: anObject  isPrepared := anObjectbrowserEnvironment  ^self browser navigationEnvironmentapplyDecorations  decorators do: [:each |  each decorateTool ]processFullClassChange: aClassModificationApplied  environment systemChanged: (ClyOverriddenSuperclassesChanged overridingSubclass: aClassModificationApplied classAffected).  environment systemChanged: (ClyOverridingSubclassesChanged overriddenSuperclass: aClassModificationApplied classAffected)testIsExecutedFromEmptyScope  self deny: query isExecutedFromEmptyScope.  query := self queryClass with: {(self subqueryFromScope: ClyScopeExample empty)}.  self assert: query isExecutedFromEmptyScopeattachToTextMorph  super attachToTextMorph.  wrapModeLabel := StringMorph new.  wrapModeLabel setBalloonText: 'Let you decide if the code pane should automaticaly wrap lines if a line reach the end of the line. W: Wrap / NW: Add a scrollbar.'.  wrapModeLabel on: #mouseDown send: #toggle to: self.  self updateLabel.  self addMorph: wrapModeLabeleditingMethod: aMethod  editingMethod := aMethodfindItemsWith: actualObjects  ^cache findItemsWith: actualObjects forAbsentDo: [ ^queryResult findItemsWith: actualObjects ]checkPackageHasClassGroups: aPackage  | providers packageScope |  packageScope := ClyPackageScope of: aPackage in: environment.  environment pluginsDo: [:plugin |  providers := plugin collectClassGroupProviders.        providers do: [:each |  each classGroupsIn: packageScope do: [:group |  ^true ] ] ].  ^falseitemCursor  dirty ifTrue: [ self runUpdate ].  ^itemCursorexecutesQuery: aClass  ^falsefirstSelectedMethod  ^self firstSelectedObjectIn: self selectedMethodsnewClassView  ^self newNavigationView     displayMainColumnBy: [:cell :item |  self specifyClassItemNameOn: cell label for: item browserItem ];     enableFilter;     requestNavigationBy: #classSelectionChangedinitialize  super initialize.  providesMethodGroup := self class providesMethodGroupByDefaultrefactoringScopes  ^self browser allNavigationScopesruleSeverity: anObject  ruleSeverity := anObjecttestCreationUnifiedInstance  | unifiedInstance |  unifiedInstance := query asUnifiedInstance.  self assert: unifiedInstance class equals: query class.  self assert: unifiedInstance requiredResult equals: query requiredResult.  self assert: unifiedInstance scope equals: ClyUnknownScope instanceinitialize  super initialize.  accessGuard := Mutex new.  updateGuard := Mutex new.  plugins := OrderedCollection new.  queryCache := WeakValueDictionary new.  updateStrategy := ClyInstantEnvironmentUpdateStrategy newmethodsToImplementIn: aClass  | result implementor |  (self doesClassDefinedAsAbstract: aClass) ifTrue: [ ^#() ].  result := OrderedCollection new.  aClass allSuperclassesDo: [:superclass |  superclass == Object ifTrue: [ ^result ].        self withAbstractMethodsOf: superclass do: [:abstractMethod |  implementor := aClass lookupSelector: abstractMethod selector.              implementor == abstractMethod ifTrue: [ result add: implementor ] ] ].  ^resultfillContextMenu: aMenu using: aCommandActivator  | concreteScopeCommand switchActivator |  browser allNavigationScopes do: [:newScope |  concreteScopeCommand := self class toScope: newScope in: browser.        switchActivator := aCommandActivator newForCommand: concreteScopeCommand.        aMenu add: switchActivator menuItemName target: switchActivator selector: #executeCommand ]tearDown  installedCounters do: [:each |  each uninstall ].  installedCounters removeAll.  super tearDownsnapshotState  ^ClyBrowserState of: selfclassSelection  ^classView selectionconfirmUnusedClasses: variables  ^self browser confirmUnusedClasses: variablesincludesActualObject: anObject  ^self actualObject == anObjectisInSameStateAs: anotherDataSource  (super isInSameStateAs: anotherDataSource) ifFalse: [ ^false ].  expandedItems size = anotherDataSource expandedItems size ifFalse: [ ^false ].  ^expandedItems allSatisfy: [:myItem |  anotherDataSource expandedItems detect: [:anotherItem |  myItem isSameAs: anotherItem ] ifFound: [:anotherItem |  myItem childrenDataSource isInSameStateAs: anotherItem childrenDataSource ] ifNone: [ false ] ]hasMetaProperty: aPropertyClass  ^falsemethod1  withNewBasisObjects: aCollection  ^selftargetClass: anObject  targetClass := anObjectinitialize  super initialize.  localScopeClass := ClyClassScopetotalItemCount  ^totalItemCountrunUpdateFor: dataSources  UIManager default defer: [ dataSources do: [:each |  each runUpdate ] ]build  self subclassResponsibilitychooseClassesForNewMethod: aMethod  ^{aMethod origin}testCheckIfEmpty  query scope: (ClyClassScope of: ClyClass1FromP1 in: environment).  self deny: query checkEmptyResultanalyzedObject: anObject  analyzedObject := anObjectsupportsQuery: aQuery  ^aQuery isKindOf: ClyTypedQuerytestFillingWithSingleInstVar  | classVarGroup allClassVarGroup |  queryResult fillWith: {(ClyInstanceVariable named: #instVar definedIn: ClyClass2FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  classVarGroup := items last actualObject.  self assert: classVarGroup methodQuery class equals: ClyVariableReferencesQuery.  self assert: classVarGroup methodQuery variableQuery resultItems equals: {(ClyInstanceVariable named: #instVar definedIn: ClyClass2FromP1)}.  allClassVarGroup := items second actualObject.  self assert: allClassVarGroup methodQuery class equals: ClyVariableReferencesQuery.  self assert: allClassVarGroup methodQuery variableQuery class equals: ClyAllInstanceVariablesQueryoverriddenMethod  ^#newValuenewWindowTitle  self subclassResponsibilityactivate  actionBlock valuetestFromThreeClasses  query tag: #Tag1.  self queryFromScope: ClyClassScope ofAll: {ClyClass6UntaggedFromP5 .         ClyClass7WithTag1FromP5 .         ClyClass8WithTag2FromP5}.  self assert: resultItems asArray equals: {ClyClass7WithTag1FromP5}forceFullUpdate  queryResult forceRebuildclyMessageImplementor1  testCreatesBrowserWithNavigationEnvironment  self restoreBrowserInstance.  self assert: browser navigationEnvironment equals: environmenthash  ^super hash bitXor: itemFilter hashwithCachedQueriesDo: aBlock  queryCache select: [:each |  each notNil ] thenDo: aBlocktestFromThreeClasses  self queryFromScope: ClyClassScope ofAll: {ClyClass7WithTag1FromP5 .         ClyClass6UntaggedFromP5 .         ClyClass1FromP1}.  self assert: resultItems asSet equals: {ClyClass6UntaggedFromP5 .         ClyClass1FromP1} asSetdefaultMenuItemName  ^'New trait'browser: anObject  browser := anObjectdecorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red.  anItemCellMorph definitionIcon: #smallDebugactiveScope  ^activeScope ifNil: [ activeScope := self systemScope ]testAscendingSamePackageDifferentClass  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: True >> #not value: Object >> #printString).  self assert: (function value: Object >> #printString value: True >> #not)decorateTableCell: anItemCellMorph of: groupItem  self isEditableGroup ifFalse: [ anItemCellMorph label color: anItemCellMorph theme calypsoFrozenItemColor ]fillWith: queriedObjects  items addAll: queriedObjectstestClosing  cursor close.  self deny: (queryResult hasSubscriber: itemObserver)printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  activator printOn: aStream.  aStream nextPut: $)order  ^10100packageSampleWhichHasGroup  ^ClyClass6UntaggedFromP5 packageisTabSelected  ^containerTab selecteddefaultMenuItemName  ^'Jump to test method'analyzedObject  ^tool analyzedObjectname: anObject  name := anObjecttestConvertingToSemiAsyncQuery  | convertedQuery |  convertedQuery := query semiAsync.  self assert: convertedQuery asyncResult class equals: ClySemiAsyncQueryResult.  self deny: convertedQuery identicalTo: query.  self assert: convertedQuery class equals: query class.  self assert: convertedQuery requiredResult identicalTo: query requiredResult.  self assert: convertedQuery scope identicalTo: query scopeselectsClass: aClass  ^aClass isTaggedWith: tagbuildResult: aQueryResult  | vars |  vars := OrderedCollection new.  scope instanceVariablesDo: [:each |  vars add: each ].  aQueryResult fillWith: varsmethod2  testMethodsEnumerationWhenBasisIsMetaclass  scope := ClyBothMetaLevelClassScope of: ClyClass1FromP1 classSide.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyClass1FromP1 localMethods).  self assert: (result includesAll: ClyClass1FromP1 classSide localMethods)execute  ^browser packageSelection actualObjects ifNotEmpty: [:packages |  browser switchToPackageScopeOf: packages ]generateTestMethodNamed: aSymbol in: aClass  | body |  body := '{1}	self flag: #toImplement.	self assert: false' format: {aSymbol}.  aClass compile: body classified: 'test'printBasisObject: aPackage on: aStream  aStream nextPutAll: aPackage namedefaultMenuItemName  ^'Browse breakpoints'defaultNavigationScope  ^self activeScopeaffectsPackages  ^falseapplyTo: aQueryView  | newDataSource |  (aQueryView dataSource isInSameStateAs: dataSource) ifFalse: [ newDataSource := dataSource copyForBrowserStateSnapshot.        aQueryView dataSource: newDataSource ].  selection restoreCurrentSelection: aQueryView selection.  aQueryView selection ensureVisibleLastItemaccumulateTestCase: aClass  allCount := allCount + aClass allTestSelectors size.  successCount := successCount + (aClass history at: #passed) size.  failureCount := failureCount + (aClass history at: #failures) size.  errorCount := errorCount + (aClass history at: #errors) sizerestoreBrowserState  self browser selectClass: self lastSelectedClasstestCheckIfEmpty  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  query scope: (ClyMethodScope of: ClyClassWithHalts >> #methodWithHalts1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithBreakpoints in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResulttestConvertingWithNewRequiredResult  | newResult convertedQuery |  newResult := ClyRawQueryResult new.  convertedQuery := query withResult: newResult.  self assert: convertedQuery class equals: query class.  self assert: convertedQuery scope equals: query scope.  self assert: convertedQuery requiredResult identicalTo: newResultcreateIcon  allCount = 0 ifTrue: [ ^self iconNamed: #testNotRunIcon ].  allCount = successCount ifTrue: [ ^self iconNamed: #testGreenIcon ].  errorCount = 0 & (failureCount > 0) ifTrue: [ ^self iconNamed: #testYellowIcon ].  errorCount > 0 ifTrue: [ ^self iconNamed: #testRedIcon ].  ^self iconNamed: #testNotRunIconshowsFullClassHierarchy  ^classView showsItemsFromScope: ClySuperclassScopetestConvertingToIncreasedScopeByExtraClassScope  | convertedScope extraClassScope |  scope := self singleScopeSample.  extraClassScope := ClySuperclassScope of: self class in: environment.  convertedScope := scope increasedByClassesFrom: extraClassScope.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects equals: scope basisObjects , self class allSuperclassesdoesMethodHasExecutionCounter: aMethod  ^self doesAnyManager: ExecutionCounter allCounters belongsTo: aMethodhash  ^super hash bitXor: pattern hashbuildCommandBar  commandBar := Morph new     setNameTo: 'command bar';     changeTableLayout;     listDirection: #rightToLeft;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     cellInset: 4 @ 0;     color: Color transparent;     height: 0;     minHeight: 0.  self addMorphBack: commandBarnewWindowTitle  | title |  title := systemQuery description.  resultView areItemsLoaded ifTrue: [ title := title capitalized , ' [' , self itemCount asString , ']' ] ifFalse: [ title := 'Loading: ' , title ].  self systemScope isCurrentImage ifFalse: [ title := title , ' in ' , self systemScope description ].  ^titlehandlesAnnouncement: anAnnouncement  ^anAnnouncement affectsClass: affectedClasstestConvertingToInterestingClassScopeShouldKeepScopeName  | convertedScope |  scope := ClyCompositeScope on: {(ClySuperclassScope of: String) .         (ClySubclassScope of: Array)}.  scope name: 'test scope'.  convertedScope := scope asInterestingClassScope.  self assert: convertedScope name equals: 'test scope'selectedMethodGroupClass  ^(self lastSelectedObjectIn: self selectedMethodGroupItems) typeselectedPackages  ^self actualSelectionFrom: self selectedPackageItemsensureSelectedItem  | selectionIndex |  self selection isEmpty ifFalse: [ ^self ].  self dataSource isEmpty ifTrue: [ ^self ].  selectionIndex := 1.  (desiredSelection notNil and: [ desiredSelection isEmpty not ]) ifTrue: [ selectionIndex := desiredSelection lastSelectedItem globalPosition min: self dataSource numberOfRows ].  self selection selectItems: {(self dataSource elementAt: selectionIndex)}.  self ensureVisibleSelectiontestComparisonWithSortedResultBasedOnAnotherFunction  | queryResult2 |  queryResult2 := ClySortedQueryResult using: #someAspect ascending.  self deny: queryResult equals: queryResult2renameMethodTagTo: newTag  self methods do: [:each |  each tagWith: newTag ]testResult  ^methodDataSource getMetaProperty: ClyTestResultPropertyextendingPackage: aPackage  extendingPackage := aPackage.  methodTags := #()testMethodsEnumerationWhenBasisIsMetaclass  | expected |  scope := ClyClassSideScope of: ClyClass1FromP1 classSide.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClass1FromP1 classSide localMethods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArrayexcludesHaltsForTesting  ^excludesHaltsForTestinginitialize  super initialize.  hierarchy := ClySubclassHierarchy newswitchToMethod: aMethod  browser selectMethod: aMethod.  self removeFromBrowseritems  ^itemsunsubscribe: anObject  changesAnnouncer unsubscribe: anObjectdefinesChildren  ^queryView definesTreetestSelectsOverrideMethod  self assert: (query selectsMethod: ClyClassWhichInheritsAbstractClass >> #overriddenMethod)fillStatusBar  super fillStatusBar.  statusBar addCommandItem: (ClySlotClassDefinitionSwitchMorph for: self)includesMethod: aMethod  ^self methodQuery retrievesItem: aMethodisAppliedToBrowser  ^browser methodGroupView showsItemsOfType: self methodGroupTypetestSelectsMethodWithCritiquesWhenTheyExistAndComputedInAdvance  | critiques |  critiques := query critiqueQuery async execute.  [ critiques isBuilt ] whileFalse: [ 30 milliSeconds wait ].  self assert: (query selectsMethod: ClyClassWithProblemMethods >> #methodWithHalt)notOverriddenMethod  isSimilarTo: anotherBrowserTool  (super isSimilarTo: anotherBrowserTool) ifFalse: [ ^false ].  ^{leftMethod .   rightMethod} asIdentitySet = {anotherBrowserTool leftMethod .         anotherBrowserTool rightMethod} asIdentitySetsetUpAvailablePlugins  ClyBrowserPlugin allSubclasses select: [:each |  each isAutoActivated ] thenDo: [:each |  self addPlugin: each new ]defaultMenuItemName  ^'Implementors'subscribe: anObject for: anAnnouncementClass  self when: anAnnouncementClass send: #systemChanged: to: anObjecttestCreationByComma  | subscope1 subscope2 |  subscope1 := ClyScopeExample of: #basisObject1 in: environment.  subscope2 := ClyScopeExample2 of: #basisObject2 in: environment.  scope := subscope1 , subscope2.  self assert: scope class equals: ClyCompositeScope.  self assert: scope basisObjects equals: #(basisObject1 basisObject2) asSet.  self assert: scope subscopes asSet equals: {subscope1 .         subscope2} asSet.  self assert: scope environment equals: environmenttargetClass  ^targetClassclassAffected  ^overridingSubclassdefaultTitle  ^context hasSelectedItems ifTrue: [ context lastSelectedItem name ] ifFalse: [ self class name ]checkEmptyResult  | result |  result := self execute.  result isBuilt ifTrue: [ ^result isEmpty ].  ^falseopenBrowser  actualVariable value browsecollectMethodGroupProviders  ^{ClyDeprecatedMethodGroupProvider new}testConvertingToNewMetaLevel  | newQuery |  newQuery := query withMetaLevelScope: ClyInstanceSideScope.  self assert: newQuery class equals: query class.  self assert: newQuery scope class equals: ClyInstanceSideScope.  self assert: newQuery scope basisObjects equals: query scope basisObjectstestClassEnumerationShouldStopAtObject  scope := ClyInterestingSuperclassScope of: ClySubclassN1OfClass1FromP1.  scope classesDo: [:each |  result add: each ].  self assert: result asArray equals: {ClyClass1FromP1}testClassEnumerationWhenObjectIsFirstSuperclass  scope := ClyInterestingSuperclassScope of: ClyClass1FromP1.  scope classesDo: [:each |  result add: each ].  self assert: result isEmptysystemChanged: aPackageModified  environment systemChanged: aPackageModifiedprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browsertakeKeyboardFocus  textMorph ifNotNil: [ textMorph takeKeyboardFocus ]visibilityLevel: anObject  visibilityLevel := anObjectdefaultTitle  ^'New class'requestMultipleObjects: dialogTitle from: aQuery inScope: aScope  aScope bindTo: browser navigationEnvironment.  ^self requestMultipleObjects: dialogTitle from: (aScope adoptQuery: aQuery)execute  browser spawnFullBrowserfixStateBeforeExecution  self prepareStateBeforeExecution.  self shouldBeProtectedByWriteBarrier ifFalse: [ ^self ].  self beReadOnlyObject.  scope beReadOnlyObjectcollate: aClass1 with: aClass2  aClass1 isTrait & aClass2 isTrait not ifTrue: [ ^-1 ].  aClass1 isTrait not & aClass2 isTrait ifTrue: [ ^1 ].  ^aClass1 name threeWayCompareTo: aClass2 namesizeLimit  ^sizeLimittestFillingWithTwoClassWhichInheriteSameTraitsAndTheirSuperclasses  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits .         Object .         ProtoObject}.  self assertItems: {ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot2 .         3 .         ClyTraitRoot2 .         2 .         Object .         2 .         ProtoObject .         3}createRefactoring: variableRefactoringClass for: aClass  ^variableRefactoringClass classVariableAnalog variable: actualVariable name class: aClasssortedBy: aSortFunction  ^self copy sortFunction: aSortFunctionisForScripting: anObject  isForScripting := anObjectselectItemsWith: actualObjects  | newItems |  newItems := rootDataSource queryView findItemsWith: actualObjects.  self selectItems: newItemsnextItem  self moveToNext.  ^self currentItemcacheMethod: aMethod  | classes |  classes := self implementorsOf: aMethod.  classes add: aMethod methodClasstestConvertingToAsyncQuery  self assert: query async identicalTo: querynewTestedObject  ^self classUnderTest newgetProperty: anEnvironmentPropertyClass ifAbsent: absentBlock  ^browserItem getProperty: anEnvironmentPropertyClass ifAbsent: absentBlockclassGroup: anObject  classGroup := anObjectexpand  self isExpanded ifTrue: [ ^self ].  ownerDataSource expand: selfcreateQuery  ^ClyOverriddenMethodsQuery from: ClyClassScope of: ClyAbstractClassExample in: environmentnavigateBack  navigationHistory undoNavigationOf: selfcollectMetadataOfMethodGroups: aQueryResult  adoptForBrowser  ^ClyQueryResultBrowserAdapter for: selfdefaultMenuItemName  ^'Scoped View'scopeClass  ^ClyInterestingSuperclassScopeisQueryScopeDefinesClass: aClass  | classPackage |  classPackage := aClass package.  buildingQuery scope packagesDo: [:each |  (each isAboutPackage: classPackage) ifTrue: [ ^true ] ].  ^falseisSimilarTo: anotherBrowserTool  (super isSimilarTo: anotherBrowserTool) ifFalse: [ ^false ].  ^editingMethod == anotherBrowserTool editingMethod or: [ editingMethod selector == anotherBrowserTool editingMethod selector and: [ editingMethod origin == anotherBrowserTool editingMethod origin ] ]decorateBrowserItem: anItem ofMethodGroup: aMethodGroup  aMethodGroup decorateOwnBrowserItem: anItemcollectMetadataOf: aQueryResult by: anEnvironmentPlugin  classGroup  ^classGrouptestIsEmptyWhenAllSubqueriesAreEmpty  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self assert: query checkEmptyResultselectedCritique  ^self lastSelectedItem actualObjectsnapshotState  ^ClyQueryBrowserState of: selfprintContext  ^'left / ' , leftMethod printSystemPath , ' vs right / ' , rightMethod printSystemPathapplyBreakpointCondition: aBreakpoint  aBreakpoint condition: conditionBlocksender2OfMessage1  self clyReferencedMessage1asUnifiedInstance  ^self copy resetScopedecorateMethodEditor: aMethodEditor  testCreationUnifiedInstanceWhenThereIsExtraScopeParameter  | unifiedInstance |  scope := self multipleScopeSample.  scope extraParameter: #testParameter.  unifiedInstance := scope asUnifiedInstance.  self assert: unifiedInstance extraParameter equals: #testParametersetNewMethodTags: tagsString  | tags |  tags := (',' split: tagsString) collect: #trimBoth as: Array.  ownerTool methodTags: (tags reject: #isEmpty)actualObject  ^item actualObjecttestProcessingQueryCacheWhenSomeWasCollectedAsGarbage  | evaluated |  environment query: (self createQueryFromScopeOf: self class).  Smalltalk     garbageCollectMost;     garbageCollectMost.  evaluated := false.  environment withCachedQueriesDo: [:each |  evaluated := true ].  self deny: evaluatedincludesItemAt: position  ^position between: startPosition and: startPosition + items size - 1methodEditor  ^methodEditorasString  ^block valuesetUp  super setUp.  installedWatchpoints := OrderedCollection newtestConvertingWithNewScope  | newScope convertedQuery |  newScope := ClyScopeExample2 of: #someBasis in: environment.  convertedQuery := query withScope: newScope.  self assert: convertedQuery class equals: query class.  self assert: convertedQuery scope equals: newScopecacheAllImplementors  cacheGuard critical: [ allImplementorsCache := IdentityDictionary new: Symbol selectorTable size.        environment systemScope methodsDo: [:each |  self cacheMethod: each ] ]createMethodQueryFrom: aClassScope  ^ClyOverriddenMethodsQuery from: aClassScopesystemQuery: anObject  systemQuery := anObjectexecute  | selectors |  selectors := messages collect: [:each |  each selector ].  browser spawnQueryBrowserOn: (ClyMessageImplementorsQuery ofAny: selectors)execute  ^browser switchToPackagestestExecution  self executeQuery.  self assert: resultItems size equals: 1testConvertingWithNewScopeWhenThereIsExtraQueryParameter  | newScope convertedQuery |  query extraParameter: #testParameter.  newScope := ClyScopeExample2 of: #someBasis in: environment.  convertedQuery := query withScope: newScope.  self assert: convertedQuery extraParameter equals: #testParameterisImplementedByClass: aClass  ^aClass instanceSide respondsTo: self implementorSelectormethodsDo: aBlock  self subclassResponsibilityisClassVariable  ^falsedoesItemHaveChildren: aDataSourceItem  | environmentItem |  environmentItem := aDataSourceItem browserItem.  ^environmentItem localHierarchySize > 0prepareNewFor: aQuery in: aNavigationEnvironment  ^self copy     environment: aNavigationEnvironment;     buildingQuery: aQuery;     beProtectedallContextsDo: aBlock  self navigationContextsDo: aBlock.  tabManager tools select: [:each |  each isKindOf: ClyTextEditorToolMorph ] thenDo: [:each |  aBlock value: each createTextContext ]tableCellIcon  ^Smalltalk ui iconNamed: #classIconpackageOrganizer  ^packageOrganizeropenBrowserCursorFor: anItemObserver  ^self execute openBrowserCursorFor: anItemObserverhighlightItemsWhich: predicateBlock  highlighting selectItemsWhere: predicateBlockhasChildrenWhich: aBlockWithChildType  ^properties anySatisfy: [:each |  (each isKindOf: ClyItemChildrenTag) and: [ aBlockWithChildType value: each childrenType ] ]testConvertingWithNewScopeBasis  | convertedQuery |  convertedQuery := query withScopeOf: #(newBasis).  self assert: convertedQuery class equals: query class.  self assert: convertedQuery scope class equals: query scope class.  self assert: convertedQuery scope basisObjects equals: #(newBasis) asSetdisableSlowPlugins  plugins removeAllSuchThat: [:each |  each isSlow ]wantsTextStyling  ^truepackageSelectionChanged  self switchToFlatClassesselectsMethod: aMethod  ^pattern matches: aMethod sourceCodeisPackageSelected  ^self hasSelectedItemsselectsClass: aClass  ^aClass tags isEmptyinitialize  super initialize.  self setBalloonText: 'Current line number/Total line number [Current character number]'.  labelMorph := '' asStringMorph.  self addMorph: labelMorphtestMethodGroupsEnumeration  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new.  scope := ClyClassScope of: ClyClass1FromP1 in: environment.  scope methodGroupsDo: [:each |  result add: each ].  self assert: (result collect: #class as: Set) equals: {ClyAllMethodGroup .         ClyTaggedMethodGroup} asSet.  self assert: (result select: [:each |  each class = ClyTaggedMethodGroup ] thenCollect: #tag) sorted asArray equals: ClyClass1FromP1 tagsForMethods sorted asArraytestFillingWithEmptyList  queryResult fillWith: #().  self assert: queryResult size equals: 0moveToItemWhich: conditionBlock  | itemsFound |  cache findItemWhich: conditionBlock ifExists: [:cached |  position := cached position.        ^true ].  itemsFound := cache loadItemsOf: queryResult startingWhere: conditionBlock.  itemsFound ifFalse: [ ^false ].  position := cache startPosition.  ^truegenerateTestMethodFor: aMethod  [ | testClass selector |  testClass := self testClassFor: aMethod methodClass.  selector := self testMethodNameFor: aMethod.  (testClass includesSelector: selector) ifFalse: [ self generateTestMethodNamed: selector in: testClass ].  testMethodToBrowse := testClass >> selector ] on: ClyInvalidClassForTestClassGeneration do: [:ex |  self inform: 'Impossible to create test class for ' , ex baseClass printString , '.' ]defaultIconName  ^#addincludesClassesAffectedBy: aSystemAnnouncement  ^basisObjects anySatisfy: [:each |  each includesClassesAffectedBy: aSystemAnnouncement ]selectsCritique: aCritique  self subclassResponsibilitydescription  ^'ffi calls'decorateBrowserItem: anItem ofObject: anObject  visibilityLevels  ^visibilityLevelssimpleNameForSpotterMenu  ^tool simpleNameForSpotterMenucanAffectResultOfMethodQuery: aMethodQuery  ^truecreateMethodQueryFrom: aClassScope  ^ClyExpectedFailedTestMethodsQuery from: aClassScopeselectedVariable  ^self selectedSourceNode binding asCalypsoVariableOf: tool editingClasstestCheckIfEmpty  query scope: (ClyClassScope of: self class in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: self class superclass in: environment).  self assert: query checkEmptyResultdefiningClass: anObject  definingClass := anObjecttag  ^classQuery tagcreateQueryResult  ^ClyGroupedCritiqueResult newupdateExpandingItems  self updateItems: expandedItems.  expandedItems := expandedItems reject: [:each |  each isRemoved ]textMorph  ^textMorphprintFullNameOf: anEnvironmentItem  ^anEnvironmentItem name , ' (' , self printDefinition , ')'= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^itemFilter = anObject itemFilterdecorateResultMethodEditor: aMethodEditor  aMethodEditor selectAnySelector: #(flag:)buildWith: objects  needsRebuild := false.  self initializeItems.  self fillWith: objectsupdateItemsWhichBelongsTo: aDataSource  | relatedItems actualSelectionChanged |  relatedItems := items select: [:each |  each belongsToDataSource: aDataSource ].  aDataSource updateItems: relatedItems.  actualSelectionChanged := relatedItems anySatisfy: #isRemoved.  self restoreTableSelectionSilently: actualSelectionChanged not.  ^actualSelectionChangedprojectManagers  ^projectManagersextraParameter  ^extraParameteractualObject  ^browserItem ifNotNil: [ browserItem actualObject ]hasPlugin: aBrowserPlugin  ^self hasPluginOf: aBrowserPlugin classdecorateItemGroup: methodGroupItem  | property |  super decorateItemGroup: methodGroupItem.  property := ClyTestResultProperty new.  scope classesDo: [:testCase |  | failures errors |        (testCase isTestCase and: [ testCase isAbstract not ]) ifTrue: [ failures := (testCase history at: #failures) size.              errors := (testCase history at: #errors) size.              property accumulateFailures: failures andErrors: errors ] ].  methodGroupItem addProperty: propertydecorateItemGroup: groupItem  subqueries do: [:each |  each decorateItemGroup: groupItem ]addPlugin: anEnvironmentPlugin  plugins detect: [:each |  each class = anEnvironmentPlugin class ] ifFound: [ ^self ].  anEnvironmentPlugin environment: self.  plugins add: anEnvironmentPlugintestConvertingWithNewCompositeScope  | newScope convertedQuery |  newScope := ClyCompositeScope on: {(ClyScopeExample of: #someBasis1 in: environment) .         (ClyScopeExample2 of: #someBasis2 in: environment)}.  convertedQuery := query withScope: newScope.  self assert: convertedQuery class equals: ClyUnionQuery.  self assert: (convertedQuery subqueries collect: #class as: Set) equals: {query class} asSet.  self assert: (convertedQuery subqueries collect: #scope as: Set) equals: newScope subscopes asSetselectedMethodGroupItems  ^selectedItemsisBasedOnItemType: aClass  ^browserItem representsItemOfType: aClasssubqueryFromScope: aScope  aScope bindTo: environment.  ^ClyQueryExampleReturningScopeBasis from: aScopeattachToSystem  browser system when: (ClyMethodChange ofAll: {self leftMethod .               self rightMethod}) send: #triggerUpdate to: selfexecuteOn: aClass  (super executeOn: aClass) inspecttestCreationHierarchicalInstance  queryResult := ClyExtensionLastSortedClasses hierarchical.  self assert: queryResult baseQueryResult class equals: ClyHierarchicallySortedClassesdefaultMenuItemName  ^'go forward'testClassEnumerationOverMetaclassWhenBothMetaLevelsAreLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {Object .         Object class .         ProtoObject .         ProtoObject class} asSetdescription  ^'Open dependency analyzer'setUpSelectedRows: indexes in: aTableMorph silently: silentSelection  silentSelection ifTrue: [ aTableMorph basicHighlightIndexes: indexes ] ifFalse: [ aTableMorph basicHighlightIndexes: #(-1000).        aTableMorph highlightIndexes: indexes ]installWatchpointInto: selector  | watchpoint |  watchpoint := Watchpoint in: (self class >> selector) ast sendNodes last.  installedWatchpoints add: watchpoint.  ^watchpointdefiningPackage  ^self definingPackageItem actualObjectwithMetaLevel: aScopeClass  ^self asScope: aScopeClassmouseLeave: evt  super mouseLeave: evt.  self currentHand showTemporaryCursor: nilchildrenOf: aClass  ^parentMap at: aClass ifAbsent: [ #() ]implementorsOf: aMethod  allImplementorsCache ifNil: [ self cacheAllImplementors ].  ^allImplementorsCache at: aMethod selector ifAbsentPut: [ WeakOrderedCollection new ]printDescriptionOn: aStream  aStream nextPutAll: self name.  aStream nextPutAll: ': '.  self printBasisOn: aStreamopen  | window |  self ensureInitialState.  window := self openInWindow.  window model: self.  self updateWindowTitle