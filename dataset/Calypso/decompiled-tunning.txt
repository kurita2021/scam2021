forceLazyRebuild  setUpModelFromContext  super setUpModelFromContext.  context isPackageSelected ifTrue: [ package := context lastSelectedPackage ].  context isClassTagSelected ifTrue: [ classTag := context lastSelectedClassTag ]prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browsermethodView  ^methodViewinitialize  super initialize.  tools := SortedCollection sortBlock: [:arg1 :arg2 |  arg1 tabOrder <= arg2 tabOrder ].  selectionPriorities := IdentityDictionary new.  desiredSelection := IdentitySet new.  shouldSkipCurrentDesiredSelection := false.  updatingStarted := false.  tabMorph := TabManagerMorph new.  tabMorph useSortedTabsBy: [:arg1 :arg2 |  arg1 model tabOrder <= arg2 model tabOrder ].  tabMorph     hResizing: #spaceFill;     vResizing: #spaceFillshowsItemsFromQuery: arg1  ^self query executesQuery: arg1buildGroupsFrom: arg1  | tmp1 |  tmp1 := IdentityDictionary new.  arg1 classesDo: [:arg2 |  arg2 tagsForAllMethods do: [:arg3 |  tmp1 at: arg3 ifAbsentPut: [ ClyTaggedMethodGroup withMethodsFrom: arg1 taggedBy: arg3 ] ] ].  ^tmp1 valuesdefaultMenuItemName  ^'Projects'applyTo: arg1 byUndo: arg2  self applyTo: arg1decorateMethodGroupTableCell: arg1 of: arg2  self subclassResponsibilitydefaultMenuItemName  self hasTestResult ifFalse: [ ^'Run all' ].  ^'Run all (' , self testResult allCount asString , ')'definitionString: arg1  definitionString := arg1executeCommand  [ super executeCommand ] on: Exception fork: [:arg1 |  arg1 pass ]runBuildProcess  | tmp1 |  asyncModeIsActive := false.  tmp1 := Semaphore new.  buildProcess := [ self buildActualResult.  tmp1 signal ] forkAt: Processor userBackgroundPriority named: 'Build result of ' , buildingQuery printString.  tmp1 wait: 500 milliSeconds.  asyncModeIsActive := buildProcess notNilprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  codeObjects := arg1 selectedObjectsclassSampleWhichHasGroup  ^ClyClassWithUndeclarestestIsAffectedByChangeOfOwnMethodWhichIsOverridden  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #overriddenMethod)switchToPackageScopeOf: arg1  | tmp1 tmp2 |  tmp2 := ClyPackageScope ofAll: arg1 in: navigationEnvironment.  tmp2 name: 'Scoped pckg'.  tmp1 := ClyAllPackagesQuery sortedFrom: tmp2.  packageView showQuery: tmp1selectsMethod: arg1  | tmp1 |  tmp1 := self environment getPlugin: ClyReflectiveEnvironmentPlugin.  ^tmp1 doesMethodHasExecutionCounter: arg1restoreStateOf: arg1  super restoreStateOf: arg1.  arg1     systemQuery: methodQuery;     queryScopes: queryScopes;     activeScope: activeScope;     expectedFlatQueryResult: expectedFlatQueryResultbuildParentMap: arg1 for: arg2  self subclassResponsibilitymetalinkManagerClass  ^BreakpointbindTo: arg1  environment ifNil: [ environment := arg1 ].  environment == arg1 ifFalse: [ self error: 'Scope should never be rebound to new environment' ]detectDefiningClassFrom: arg1  self detectDefiningClassFrom: arg1 ifAbsent: [ self error: 'Cant find the class defining variable' ]defaultMenuItemName  ^'Class refs.'selectedClassOrMetaClass  ^self methodClasstestSelectsClassWithoutTags  self assert: (query selectsClass: ClyClass6UntaggedFromP5)resetStateForSnapshot  owner := nil.  submorphs := EmptyArray.  extension := nil.  browser := nil.  context := nil.  containerTab := nil.  statusBar := nil.  isDirty := false.  decorators := niltestPrepareResultForExecution  | tmp1 |  tmp1 := query prepareNewResult.  self assert: tmp1 class equals: query requiredResult class.  self assert: tmp1 buildingQuery identicalTo: query.  self assert: tmp1 environment identicalTo: environmentbrowserItem  ^browserItemtestComparison  self assert: (ClyClassReferencesQuery to: Point) equals: (ClyClassReferencesQuery to: Point).  self assert: (ClyClassReferencesQuery to: Point) hash equals: (ClyClassReferencesQuery to: Point) hash.  self deny: (ClyClassReferencesQuery to: Point) equals: (ClyClassReferencesQuery to: Rectangle)itemDepth  ^itemDepth ifNil: [ item depth ]representsConcreteQuery  ^(viewStates allSatisfy: [:arg1 |  arg1 representsConcreteQuery not ]) notexpandedItems: arg1  expandedItems := arg1testVariablesEnumerationForTwoClassesWithClassAndInstanceVars  scope := ClyClassScope ofAll: {Object .         ClyClass1FromP1}.  scope variablesDo: [:arg1 |  result add: arg1 ].  self assert: (result as: Set) equals: {(ClyClassVariable named: #DependentsFields definedIn: Object) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)} asSetdescription  ^'Run the script'build  matchesString: arg1  ^pattern matches: arg1query  ^self dataSource querytestConvertingToInheritedScopeShouldAddInheritedTraits  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asInheritedScope.  self assert: (tmp1 representsScope: ClyInheritedTraitScope)switchToFlatClasses  | tmp1 |  tmp1 := OrderedCollection new.  packageView selection groupItemsByTypeAndDo: [:arg1 :arg2 |  tmp1 addAll: (arg1 prepareClassQueriesFrom: arg2 in: navigationEnvironment) ].  classView showQueries: tmp1 as: ClyExtensionLastSortedClasses hierarchicaltestMethodsEnumerationWhenInstanceSideMetaLevel  | tmp1 |  scope := ClySubclassScope of: ClyClass1FromP1.  scope localScopeClass: ClyInstanceSideScope.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyClass1FromP1 subclasses first localMethods).  tmp1 := ClyClass1FromP1 subclasses flatCollect: [:arg1 |  arg1 classSide localMethods ].  self assert: tmp1 notEmpty.  self deny: (result includesAll: tmp1)testSelectedTabsAreNotBuild  | tmp1 |  self snapshotState.  tmp1 := navigationState selectedTabs first.  self deny: tmp1 isBuiltbuild  roots := IdentitySet withAll: classes.  parentMap := IdentityDictionary new.  classes do: [:arg1 |  hierarchy buildParentMap: self for: arg1 ]description  ^groupNameshouldBuildGroupWith: arg1  ^truebuildGroupsFor: arg1  | tmp1 |  tmp1 := ClyPackageScope of: arg1 in: environment.  groupProvider classGroupsIn: tmp1 do: [:arg2 |  builtGroups add: arg2 ]prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  package := arg1 lastSelectedPackage.  arg1 isClassTagSelected ifTrue: [ classTag := arg1 lastSelectedClassTag ]testBasedOnBasisObject  scope := self createSampleScope.  self assert: (scope isBasedOn: scope basisObjects anyOne).  self deny: (scope isBasedOn: #anotherObject)testViewDataSourceIsNotDetatchedAfterSnapshoting  self snapshotState.  self assert: (viewDataSource queryResult hasSubscriber: viewDataSource)browserPlugins: arg1  browserPlugins := arg1testConvertingWithNewScopeBasis  | tmp1 |  tmp1 := query withScopeOf: #(newBasis).  self assert: tmp1 class equals: query class.  self assert: tmp1 requiredResult identicalTo: query requiredResult.  self assert: (tmp1 subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (tmp1 subqueries collect: #scope) equals: (query subqueries collect: [:arg1 |  arg1 scope withNewBasisObjects: #(newBasis) ])adoptForBrowser  ^selfdetectDefiningClassFrom: arg1  self subclassResponsibilitypackageOrganizer: arg1  packageOrganizer := arg1editingText  self subclassResponsibilityfindItemsSimilarTo: arg1  ^#()testCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #sender1OfMessage1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #senderOfMessage2 in: environment).  self assert: query checkEmptyResultcreateQueryResult  ^ClyHierarchicalSystemItems newprintOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     nextPutAll: self name;     nextPut: $)coveringTestCase: arg1  coveringTestCase := arg1cleanAfterRemove  self detachFromSystem.  decorators do: [:arg1 |  arg1 toolWasRemoved ]removeMethodFromCache: arg1  | tmp1 |  tmp1 := allImplementorsCache at: arg1 selector ifAbsent: [ ^self ].  tmp1 remove: arg1 methodClass ifAbsent: [  ].  (tmp1 isEmpty or: [ tmp1 allSatisfy: [:arg2 |  arg2 isNil or: [ arg2 isObsolete ] ] ]) ifTrue: [ allImplementorsCache removeKey: arg1 selector ]switchToMethod: arg1  self detachFromSystem.  editingMethod := arg1.  self attachToSystem.  browser selectMethod: editingMethod.  self updateadoptLocalScopeClassTo: arg1  addBarForLabelIndentation  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := item rootDataSource definesChildren.  tmp2 := tmp1 ifTrue: [ 2 ] ifFalse: [ 1 ].  tmp3 := tmp2 - submorphs size.  tmp4 := tmp3 * 16 + (self itemDepth * 8).  tmp4 = 0 ifTrue: [ ^self ].  self addMorphBack: (self emptyBarWithWidth: tmp4)calypsoEnvironmentType  ^self classtestFillingWithOneCritique  | tmp1 tmp2 tmp3 |  tmp1 := ClyClassWithProblemMethods >> #methodWithHalt.  tmp2 := tmp1 critiques anyOne.  queryResult fillWith: {tmp2}.  self assert: queryResult size equals: 1.  tmp3 := queryResult items first.  self assert: tmp3 class equals: ClyConcreteCritiqueMethodGroup.  self assert: tmp3 name equals: tmp2 rule group asLowercase.  self assert: tmp3 ruleSeverity name equals: tmp2 rule severitysetUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyReflectiveEnvironmentPlugin newtestClassesEnumeration  scope := ClyPackageScope of: ClyClass1FromP1 package.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyClass1FromP1 package definedClasses).  self deny: (result includesAll: ClyClass1FromP1 package extendedClasses)supportsExpansion  ^ownerDataSource definesChildrencreateMethodQueryFrom: arg1  ^(ClyAllProblemMethodQuery from: arg1) asynccountChildrenOf: arg1  | tmp1 |  tmp1 := arg1 browserItem.  ^tmp1 localHierarchySizedetectActiveState  extraClassScope classesDo: [:arg1 |  (visibleClassScope includesClass: arg1) ifTrue: [ ^isActive := true ] ].  isActive := falsebuildResult: arg1  | tmp1 tmp2 |  tmp1 := self actualQuery execute.  tmp2 := tmp1 items select: [:arg2 |  itemFilter matches: arg2 ] thenCollect: [:arg2 |  arg2 adoptForNewCalypsoQuery ].  arg1 items: tmp2build  self buildTextMorph.  textModel clearUndoManager.  self subscribeOnTextChanges.  textMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorph: textMorphapplyBreakpointCondition: arg1  self subclassResponsibilityrenameMethodTagTo: arg1  arg1 = self tag ifTrue: [ ^self ].  self methods do: [:arg2 |  arg2 tagWith: arg1.        arg2 untagFrom: self tag ].  methodQuery scope classesDo: [:arg2 |  (arg2 tagsForMethods includes: arg1) ifFalse: [ arg2 addMethodTag: arg1 ].        arg2 removeMethodTag: self tag ]isMethodOverridden: arg1  | tmp1 tmp2 |  (self isClassCheapForOverriddenMethodsAnalysis: arg1 methodClass) ifTrue: [ ^arg1 isOverridden ].  tmp1 := self implementorsOf: arg1.  tmp2 := arg1 methodClass.  ^tmp1 anySatisfy: [:arg2 |  arg2 notNil and: [ (arg2 inheritsFrom: tmp2) and: [ arg2 isObsolete not ] ] ]coveringTest  ^coveringTestbrowserItem  ^item browserItemclassSampleWhichHasGroup  ^ClyClass1FromP1hash  ^super hash bitXor: selectors hashisReferencedIn: arg1  (self isAccessibleFrom: arg1 origin) ifFalse: [ ^false ].  ^(actualVariable isReadIn: arg1) or: [ actualVariable isWrittenIn: arg1 ]stop: arg1  stop := arg1testFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: foundSelectors equals: #(classSideSender1OfMessage1 classSideSender2OfMessage1 sender1OfMessage1 sender2OfMessage1 superclassSenderOfMessage1)createQuery  ^ClyUndeclaredMethodsQuery from: (ClyClassScope of: ClyClassWithUndeclares in: environment)execute  classGroup importClasses: classescreateMethodQueryFrom: arg1  self subclassResponsibilitymethodEditor  ^toolbrowser  ^browserclassTag: arg1  classTag := arg1fillStatusBar  super fillStatusBar.  statusBar addCommandItem: (ClySlotClassDefinitionSwitchMorph for: self)specifyClassItemNameOn: arg1 for: arg2  | tmp1 |  arg1 contents: arg2 name.  tmp1 := arg2 systemDefinition.  self packageSelection isMultipleSelected ifTrue: [ arg1 contents: (tmp1 printFullNameOf: arg2) ].  (self isPackagePartOfSelection: tmp1 definingPackage) ifFalse: [ arg1 color: self theme classExtensionColor ]testCreationWithEmptySubqueriesShouldReturnUnknownQuery  query := self queryClass with: {}.  self assert: query identicalTo: ClyUnknownQuery instancegroupProviderClass  ^ClyBreakpointMethodGroupProviderselectMethodsIn: arg1  arg1 selectLastItemactualVariable: arg1  actualVariable := arg1whenEnterKeyPressedDo: arg1  table bindKeyCombination: Character cr asShortcut toAction: arg1confirmEmptySystemQuery: arg1  | tmp1 tmp2 |  tmp2 := arg1 execute.  tmp2 isEmpty ifTrue: [ ^true ].  tmp1 := UIManager default confirm: 'There are ' , tmp2 size asString , ' ' , arg1 description , '. Show them?'.  tmp1 ifTrue: [ self spawnQueryBrowserOn: arg1 ].  ^falseexecute  browser switchToMethodGroupsremoveMethods: arg1  SycSilentlyRemoveMethodStrategy new removeMethods: arg1.  (ClyShowMessageSenderCommand forMethods: arg1 by: browser) executefailureCount  ^failureCountsetUp  super setUp.  query := self createQuery.  queryResult := self createQueryResult prepareNewFor: query in: environment.  queryResult cancelRebuildtestFillingWithEmptyList  queryResult fillWith: {}.  self assert: queryResult isEmptyhandleSystemChange: arg1 byProcessingList: arg2  needsRebuild ifTrue: [ ^arg2 remove: self ].  arg1 shouldBeConsideredByCalypsoEnvironment ifFalse: [ ^arg2 remove: self ].  accessGuard tryEnterCritical: [ self handleSystemChange: arg1 ] ifLocked: [ ^self ].  arg2 remove: selfshowMessage: arg1 renamedTo: arg2  | tmp1 tmp2 |  tmp1 := arg1 contextUser.  tmp2 := tmp1 origin >> arg2.  self showMethod: tmp2cache  ^cachesystemQuery: arg1  methodQuery := arg1scopeClass  ^ClyInstanceSideScopegroupProviderClass  ^ClyTaggedClassGroupProviderspotterForCommandsFor: arg1  < spotterOrder: 20>  browser allContextsDo: [:arg2 |  self commandListProcessorForContext: arg2 step: arg1 ]= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^tag = arg1 tagisSameAs: arg1  self class == arg1 class ifFalse: [ ^false ].  ^self isBasedOn: arg1 querybrowser  ^browsertestFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: foundSelectors equals: #(classSideSender1OfMessage1 classSideSender2OfMessage1 sender1OfMessage1 sender2OfMessage1 superclassSenderOfMessage1)testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector).  self assert: (resultItems identityIncludes: self class superclass >> self targetSelector)textMorph  ^textMorphpendingText: arg1  textMorph updateTextWith: arg1.  textMorph hasUnacceptedEdits: truetestExecutesConcreteQueryClass  query subqueries: {(self subqueryFromScopeOf: #basis)}.  self deny: (query executesQuery: query class).  self assert: (query executesQuery: query subqueries anyOne class).  self deny: (query executesQuery: ClyQueryExampleReturningScopeBasis2)containerTab  ^containerTabcheckEmptyResult  self subclassResponsibilitysetUpParametersFromModel  super setUpParametersFromModel.  self updateMethodTagsAndPackagetestSelectsMethodWhichUsesUndeclares  self assert: (query selectsMethod: ClyClassWithUndeclares >> #method1WithUndeclares)testFillingWithSingleClassVar  | tmp1 tmp2 |  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  tmp1 := items last actualObject.  self assert: tmp1 methodQuery class equals: ClyVariableReferencesQuery.  self assert: tmp1 methodQuery variableQuery resultItems equals: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1)}.  tmp2 := items first actualObject.  self assert: tmp2 methodQuery class equals: ClyVariableReferencesQuery.  self assert: tmp2 methodQuery variableQuery class equals: ClyAllClassVariablesQuerylocalScopeClass: arg1  localScopeClass := arg1metaLevelScope  ^metaLevelScopedecorateBrowserItem: arg1 ofPackage: arg2  | tmp1 |  tmp1 := arg2 mcWorkingCopy.  tmp1 ifNil: [ ^self ].  tmp1 modified ifTrue: [ arg1 markWith: ClyDirtyPackageTag ]testFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1 .         ClySubclassWithTraitsOfClassWithTraits .         1 .         ClyTraitRoot2 .         2}createClassQueryFrom: arg1  ^ClyAllClassesQuery from: (arg1 asScope: ClyPackageExtensionScope)testDescending  function := ClySortByNameFunction descending.  self assert: (function value: Object value: Array).  self deny: (function value: Array value: Object).  self assert: (function value: Object value: Object)testUsingBadScriptWithoutClosingBracket  filter := ClyQueryBrowserFilter substringPattern: '[:each | true '.  self assert: (filter matches: self itemOfThisTestMethod).  self assert: (filter matches: (ClyBrowserItem with: Object >> #printString))testComparisonWithItself  scope := self createSampleScope.  self assert: scope equals: scopeisParentRemoved  parentItem ifNil: [ ^false ].  ^parentItem isRemovedtestCheckIfEmpty  query scope: self scopeWithCritiques.  self deny: query checkEmptyResult.  query scope: self scopeWithoutCritiques.  self assert: query checkEmptyResulttestRestoredBrowserInstanceWithExpectedFlatQueryResult  self restoreBrowserInstance.  self assert: navigationState expectedFlatQueryResult notNil.  self assert: browser expectedFlatQueryResult equals: navigationState expectedFlatQueryResultrestoreStateOf: arg1  arg1 systemScope: systemScopetestFillingWithTraitAndItsUsers  queryResult fillWith: {ClyTraitRoot1 .         ClyTraitChild1 .         ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitChild2Child}.  self assertItems: {ClyTraitRoot1 .         0 .         ClyTraitChild1 .         1 .         ClyClassWithTraits .         2 .         ClyTraitChild2 .         1 .         ClyTraitChild2Child .         2 .         ClyClassWithTraits .         3}testClassEnumeration  | tmp1 |  scope := ClySuperclassScope of: ClyClass1FromP1.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := ClyClass1FromP1 allSuperclasses.  self assert: result asArray equals: tmp1 asArraymethodWithoutCritiques  ^self printStringtestComparisonWithResultWithAnotherSortFunction  | tmp1 |  tmp1 := queryResult sortedBy: #anotherSortFunction.  self deny: queryResult equals: tmp1.  self deny: queryResult identicalTo: tmp1testConvertingToAnotherScopeClassShouldRemoveDuplications  | tmp1 |  scope := ClyCompositeScope on: {(ClyScopeExample of: Object in: environment) .         (ClyScopeExample2 ofAll: {Object .               Array} in: environment)}.  tmp1 := scope asScope: ClyScopeExample2.  self assert: tmp1 class equals: ClyScopeExample2.  self assert: tmp1 basisObjects size equals: 2.  self assert: tmp1 basisObjects asIdentitySet equals: {Object .         Array} asSet.  self assert: tmp1 environment equals: environmenttestFromSingleClass  | tmp1 |  self queryFromScope: ClyClassScope of: ClyClass2FromP1.  tmp1 := resultItems collect: #name as: Set.  self assert: tmp1 equals: (ClyClass2FromP1 classVariables collect: #name as: Set)newNavigationView  | tmp1 |  tmp1 := ClyQueryViewMorph for: self.  navigationViews add: tmp1.  ^tmp1updateBrowser  self browser updatehash  ^super hash bitXor: hierarchy hashwithoutBasisObjects: arg1  ^self withNewBasisObjects: (basisObjects copyWithoutAll: arg1)globalPositionOf: arg1  | tmp1 |  tmp1 := parentItem ifNil: [ 0 ] ifNotNil: [ parentItem globalPosition ].  collapsedItems do: [:arg2 |  (arg2 isAfter: arg1 position) ifTrue: [ ^tmp1 + arg1 position ].        tmp1 := tmp1 - arg2 childrenCount ].  ^tmp1 + arg1 positiontestCheckIfEmpty  self deny: query checkEmptyResultprintOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  browserItem ifNil: [ nil printOn: arg1 ] ifNotNil: [ arg1 nextPutAll: browserItem name ].  arg1 nextPut: $)name: arg1  name := arg1methodGroupSelection  ^methodGroupView selectiontestCheckIfEmpty  query scope: (ClyClassScope of: ClySubclassLOfClass0FromPExtendedByP1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ClyClass1FromP1 in: environment).  self assert: query checkEmptyResultisSimilarTo: arg1  ^self class = arg1 classtestMethodsEnumerationWhenBasisIsClass  | tmp1 |  scope := ClyInstanceSideScope of: ClyClass1FromP1.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArrayhierarchy  ^hierarchymethodGroupType  ^ClyMethodGrouptestIsEmptyFromEmptyMethodScope  < expectedFailure>  super testIsEmptyFromEmptyMethodScopemethodQuery: arg1  methodQuery := arg1testFindItemsUsingPredicate  | tmp1 |  tmp1 := cursor findItemsWhere: [:arg1 |  arg1 actualObject = Array ].  self assert: tmp1 size equals: 1.  self assert: tmp1 first actualObject equals: Array.  self assert: tmp1 first isPrepared.  self assert: tmp1 first position equals: (self rawResultItems indexOf: Array)description  ^'Command to browse the class defining the rule producing the critique.'refreshingBlock  ^refreshingBlockaffectsCritiques  ^falsematches: arg1  ^arg1 includesSubstring: value caseSensitive: isCaseSensitiveclassNamed: arg1 ifAbsent: arg2  ^globals at: arg1 ifPresent: [:arg3 |  arg3 isBehavior ifTrue: [ arg3 ] ifFalse: arg2 ] ifAbsent: arg2testFindTestedClassCoveredByTestCaseWithAnotherSuffix  | tmp1 |  tmp1 := plugin findTestedClassCoveredBy: ClyTestedClass2Test ifAbsent: [  ].  self assert: tmp1 equals: ClyTestedClass2testRestoredBrowserInstanceWithSystemScope  browser systemScope: #testScope.  self restoreBrowserInstance.  self assert: browser systemScope equals: #testScopesnapshotState  navigationState := browser snapshotStateisClassGroupSelected  ^falsecanDetectAffectOnClassesBy: arg1  ^trueretrievesItemsOfType: arg1  ^subqueries anySatisfy: [:arg2 |  arg2 retrievesItemsOfType: arg1 ]selectLastItem  | tmp1 |  tmp1 := self dataSource numberOfRows.  tmp1 = 0 ifTrue: [ ^self ].  self selection selectItems: {(self dataSource elementAt: tmp1)}.  UIManager default defer: [ self selection ensureVisibleLastItem ]testHasEnvironmentFromSubscopes  scope := self createSampleScope.  self assert: scope environment equals: environmenttestConvertingToIncreasedScopeByExtraClassScope  | tmp1 tmp2 |  scope := self singleScopeSample.  tmp2 := ClySuperclassScope of: self class localScope: self scopeClass.  tmp1 := scope increasedByClassesFrom: tmp2.  self assert: tmp1 class equals: scope class.  self assert: tmp1 basisObjects equals: scope basisObjects , tmp2 collectAllClassesokToChange  ^tabManager okToChangetabDeleted: arg1  | tmp1 |  tmp1 := tools detect: [:arg2 |  arg2 containerTab = arg1 ] ifNone: [ ^self ].  tools remove: tmp1.  tmp1 cleanAfterRemoveprintDefinition  self subclassResponsibilitytestConvertingToAnotherScopeClass  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asScope: ClyScopeExample.  self assert: tmp1 identicalTo: scopeisMessageSelected  ^self isMethodSelectedisResult: arg1 affectedBy: arg2  ^(arg2 affectsMethodsTaggedWith: tag) and: [ scope includesMethodsAffectedBy: arg2 ]initialize  super initialize.  needsRebuild := trueincludesActualObject: arg1  ^items anySatisfy: [:arg2 |  arg2 includesActualObject: arg1 ]critiqueQuery: arg1  critiqueQuery := scope adoptQuery: arg1createMethodQueryFrom: arg1  ^ClyMethodWatchpointsQuery from: arg1classesDo: arg1  self subclassResponsibilitybrowseSendersOf: arg1  self spawnQueryBrowserOn: (ClyMessageSendersQuery of: arg1)lastSelectedClassTag  | tmp1 |  tmp1 := tool classGroupSelection items detect: [:arg1 |  arg1 type isBasedOnClassTag ].  ^tmp1 nameitems: arg1  items := arg1applyChanges  self subclassResponsibilitysetUpScopedModeWith: arg1  (arg1 isKindOf: ClyPackageScope) ifFalse: [ ^self ].  self switchToPackageScopeOf: arg1 basisObjectscollate: arg1 with: arg2  ^actualObjectSortFunction collate: arg1 actualObject with: arg2 actualObjectforceRebuild  belongsToRemovedBrowserContext  | tmp1 |  super belongsToRemovedBrowserContext ifTrue: [ ^true ].  tmp1 := editingMethod origin localMethodNamed: editingMethod selector ifAbsent: [ ^true ].  self editingMethod: tmp1.  ^falsequeryClass  ^ClyUnionQuerycollapse: arg1  queryView changeStateBy: [ collapsedItems removeAllSuchThat: [:arg2 |  arg1 hasChildAt: arg2 position ].        collapsedItems add: arg1.        self expansionChanged ]testFillingWithClassWithoutTraits  queryResult fillWith: {ClyClassWithoutTraits}.  self assertItems: {ClyClassWithoutTraits .         0}ensureInitialState  (navigationViews anySatisfy: [:arg1 |  arg1 hasRealQuery ]) ifTrue: [ ^self ].  self prepareDefaultStateselectsClass: arg1  ^arg1 tags isEmptyclassesRelatedTo: arg1 do: arg2  self class classesRelatedTo: arg1 do: arg2checkEmptyResult  scope projectsDo: [:arg1 |  arg1 items ifNotEmpty: [ ^false ] ].  ^truesetUp  | tmp1 |  super setUp.  tmp1 := ClyAllPackagesQuery from: ClyPackageScope of: ClyClass7WithTag1FromP5 package in: environment.  viewDataSource := ClyCollapsedDataSource on: tmp1.  queryView := ClyQueryViewMorph for: browser.  queryView treeStructure: {(RPackage -> #prepareClassGroupQueryFrom:in:)}.  queryView dataSource: viewDataSource.  queryView selection selectItems: {self selectedItem}hash  ^classQuery hashapplyBreakpointCondition: arg1  arg1 alwaystestBindToEnvironmentShouldBindSubscopes  | tmp1 |  scope := ClyCompositeScope on: {(ClyScopeExample of: Object) .         (ClyScopeExample2 of: Array)}.  scope bindTo: environment.  tmp1 := scope subscopes asArray.  self assert: tmp1 first environment equals: environment.  self assert: tmp1 second environment equals: environmentsubgroupsQuery: arg1  subgroupsQuery := arg1snapshotState  navigationState := ClyAccrossWindowNavigationState from: browsercreateBrowser  ^ClyFullBrowser newtestComparisonWithResultWithSimilarInverseHierarchy  | tmp1 |  tmp1 := self createQueryResult.  tmp1 := tmp1 withInverseHierarchy.  self deny: queryResult equals: tmp1printExtraInfoOn: arg1  super printExtraInfoOn: arg1.  ^arg1 nextPutAll: package nameclassesDo: arg1  self packagesDo: [:arg2 |  arg2 extendedClasses collect: [:arg3 |  arg3 instanceSide ] thenDo: arg1 ]asyncResult: arg1  asyncResult := arg1decorateByCritic: arg1  decorateTool  | tmp1 |  criticView ifNil: [ self prepare ].  tmp1 := browserTool criticAnalysisScope.  (analysisScope isNil or: [ tmp1 basisObjects ~= analysisScope basisObjects ]) ifTrue: [ analysisScope := tmp1.        self updateCriticView ].  self refreshCritiquesitemCache: arg1  itemCache := arg1isTestMethod: arg1  arg1 numArgs isZero ifFalse: [ ^false ].  ((arg1 selector beginsWith: 'test') or: [ arg1 selector beginsWith: 'should' ]) ifFalse: [ ^false ].  ^self isTestClass: arg1 methodClasstestConvertingWithNewScopeBasisShouldKeepFilter  | tmp1 |  tmp1 := query withScopeOf: #(newBasis).  self assert: tmp1 itemFilter equals: query itemFilteraddDecorator: arg1  arg1 browserTool: self.  decorators add: arg1moveToStart  self moveTo: 1createBrowser  ^ClyQueryBrowser on: environment scopes: {(ClyBothMetaLevelClassScope of: ClyClass1FromP1 in: environment) .         (ClyBothMetaLevelClassScope of: ClyClass2FromP1 in: environment)}decorateResultMethodEditor: arg1  arg1 selectAnySelector: #(halt halt: haltIf: haltOnce haltOnCount)testInstVarsEnumerationWhenThereAreNoVariables  scope := ClyClassScope of: Object.  scope instanceVariablesDo: [:arg1 |  result add: arg1 ].  self assert: result isEmptyqueryClass  self subclassResponsibilityquerySystemFor: arg1  arg1 bindTo: self systemScope in: self.  ^arg1 executetestNotEmptyInPackageWithTagsAndUncategorizedClasses  query scope: (ClyPackageScope of: ClyClass6UntaggedFromP5 package in: environment).  self deny: query checkEmptyResultactivationPriorityOf: arg1  | tmp1 |  arg1 belongsToCurrentBrowserContext ifFalse: [ ^arg1 activationPriorityInNonActiveContext ].  tmp1 := self overridenPriorityOf: arg1.  ^(desiredSelection includes: arg1 class) ifTrue: [ tmp1 * 1000 ] ifFalse: [ tmp1 ]testMatchesAnyStringWhenItIsEmpty  | tmp1 |  tmp1 := ClyRegexPattern with: ''.  self assert: (tmp1 matches: 'any string')testTwo  | tmp1 |  tmp1 := self newTestedObject.  self     assert: tmp1 two isNil;     assert: (tmp1 two: #two) identicalTo: tmp1;     assert: tmp1 two equals: #twofindDataSourceSameAs: arg1 ifNone: arg2  | tmp1 |  (self isSameAs: arg1) ifTrue: [ ^self ].  expandedItems do: [:arg3 |  tmp1 := arg3 childrenDataSource findDataSourceSameAs: arg1 ifNone: [ nil ].        tmp1 ifNotNil: [ ^tmp1 ] ].  ^arg2 valuetestFillingWithClassAndItGrandSuperclass  queryResult fillWith: {ClyClass1FromP1 .         ClySubclassLOfSubclassMFromP3}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1}singleBasisSample  self subclassResponsibilitytestNotExecutedFromMultipleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  < expectedFailure>  super testNotExecutedFromMultipleScopeWhenSubqueriesAreFromDifferentScopesOfSameObjecttestConvertingWithoutExistingBasisObjects  | tmp1 |  scope := self multipleScopeSample.  tmp1 := scope withoutBasisObjects: scope basisObjects.  self assert: tmp1 class equals: scope class.  self deny: (tmp1 basisObjects includesAll: scope basisObjects)restoreBrowserState: arg1  | tmp1 |  self updateTools.  tmp1 := arg1 selectedTabs collect: [:arg2 |  tools detect: [:arg3 |  arg3 isSimilarTo: arg2 ] ifNone: [ nil ] ] thenSelect: #notNil.  tmp1 ifEmpty: [ ^self ].  tmp1 first selectAsMainTab.  tmp1 allButFirstDo: [:arg3 |  arg3 selectAsExtraTab ]description  ^'Scope to selected packages'addClassVariableGroup  | tmp1 tmp2 tmp3 |  tmp1 := ClyAllClassVariablesQuery from: self queryScope.  tmp2 := ClyVariableReferencesQuery from: self queryScope asLocalClassScope toVariablesFrom: tmp1.  tmp3 := ClyMethodGroup named: 'Class variables' priority: 9 on: tmp2 withSubgroupsFrom: (tmp1 withResult: (ClyGroupedClassVariables withHierarchy: hierarchy)).  items add: tmp3 asCalypsoBrowserItemtestFillingWithOnlyClassWhichHasTraits  queryResult fillWith: {ClyClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0}isResult: arg1 affectedBy: arg2  ^scope includesVariablesAffectedBy: arg2defaultIconName  ^#addisAppliedToBrowser  ^browser showsFullClassHierarchypackageNameOf: arg1  ^arg1 systemDefinition definingPackageItem namedefiningPackageItem  ^definingPackageItemmethodGroupType  self subclassResponsibilitydescription  ^'all critiques'defaultColor  ^Color transparentretrievesBrowserItems  ^requiredResult representsBrowserItemsexecuteCommand  activator executeCommandsortFunction: arg1  sortFunction := arg1activationPriorityInNonActiveContext  ^applyingChanges ifTrue: [ Float infinity ] ifFalse: [ super activationPriorityInNonActiveContext ]testQueryCacheShouldBeWeak  | tmp1 tmp2 |  tmp2 := self createQueryFromScopeOf: self class.  environment query: tmp2.  Smalltalk     garbageCollectMost;     garbageCollectMost.  tmp1 := environment cachedResultOf: tmp2.  self assert: tmp1 equals: nilactualObjectSortFunction: arg1  actualObjectSortFunction := arg1createCommandContextForCursorAt: arg1  | tmp1 |  tmp1 := self findSourceNodeAt: arg1.  ^ClyMethodSourceCodeContext for: self selectedNode: tmp1actualQuery  ^subqueries anyOneitems  ^itemsinitializeItems  items ifNil: [ super initializeItems ]selectedMethodItems  ^selectedItemscheckbox: arg1  checkbox := arg1buildResult: arg1  arg1 fillWith: resultItemsupdateCriticView  | tmp1 |  tmp1 := (ClyAllBasisCritiqueQuery from: analysisScope) async.  criticView showQuery: tmp1activateSubmenu: arg1  ^falsescopeClass  ^ClyMethodScopemenuColumn: arg1 row: arg2  ^queryView menuColumn: arg1 row: arg2switchClassViewTo: arg1 inScope: arg2  | tmp1 |  tmp1 := ClyAllClassesQuery from: arg2 as: arg1.  classView showQuery: tmp1childrenItemAt: arg1  ^childrenDataSource elementAt: arg1 - self positiontestDetectingDefiningClassFromItself  | tmp1 tmp2 |  tmp1 := ClyClass2FromP1 classVariableNamed: #ClassVar1.  tmp2 := ClyClassVariable on: tmp1 visibleFrom: ClyClass2FromP1.  self assert: tmp2 definingClass equals: ClyClass2FromP1retrievesItem: arg1  ^trueclassTemplate  | tmp1 |  tmp1 := Slot showSlotClassDefinition ifTrue: [ 'Object subclass: #NameOfSubclass	slots: {}	classVariables: {}	package: ''' ] ifFalse: [ 'Object subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	package: ''' ].  ^tmp1 , self packageName , ''''testDataSourceWithoutTable  self snapshotState.  self assert: navigationState dataSource table isNiltestFindTestCaseCoveringTestedClass  | tmp1 |  tmp1 := plugin findTestCaseCovering: ClyTestedClass ifAbsent: [  ].  self assert: tmp1 equals: ClyTestedClassTesttestForGlobalVariable  query variableQuery: (ClyConstantQuery returning: {(self class environment bindingOf: #Smalltalk)}).  self queryFromScope: ClyMethodScope of: self class >> #referenceOfSmalltalk.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #referenceOfSmalltalkclassesRelatedTo: arg1 do: arg2  relationScopeClasses do: [:arg3 |  arg3 classesRelatedTo: arg1 do: arg2 ]ensureExistAndRegisterPackageNamed: arg1  ^packageOrganizer ensureExistAndRegisterPackageNamed: arg1testClassEnumerationOverMetaclassBasisWhenClassSideIsLocalScope  scope := ClyInterestingSuperclassScope of: ClySubclassN1OfClass1FromP1 class localScope: ClyClassSideScope.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {ClyClass1FromP1 class} asSet= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^excludesHaltsForTesting = arg1 excludesHaltsForTestingoverridingSubclass: arg1  overridingSubclass := arg1createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'should be implemented' priority: 8.5 on: arg1testResultOf: arg1  ^(arg1 getProperty: ClyTestedMethodProperty) testResultactivator  ^activatortestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithProblemMethods >> #methodWithHalt in: environment).  self deny: query checkEmptyResult.  query := self createQuery.  query scope: (ClyMethodScope of: ClyClassWithProblemMethods >> #methodWithoutCritiques in: environment).  self assert: query checkEmptyResultdecorateBrowserItem: arg1 ofMethod: arg2  arg2 isFFIMethod ifTrue: [ arg1 markWith: ClyFFIMethodTag ]defaultMenuIconName  ^#smallDebugasSelection  ^self rootDataSource newSelectionWith: {self}entity  ^entitycreateQuery  ^ClyAllProblemMethodQuery from: ClyClassScope of: ClyClassWithProblemMethods in: environmentselectedSourceNode  ^selectedSourceNodedetachFromSystem  TestCase historyAnnouncer unsubscribe: selftestNotExecutedFromMultipleScopeWhenSingleSubqueryIsFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty)}.  self deny: query isExecutedFromMultipleScopetestFillingWithThreePackages  | tmp1 |  queryResult fillWith: {ClySubclassMOfClass1FromP2 package .         ClySubclassLOfSubclassMFromP3 package .         ClyClass1FromP1 package}.  tmp1 := queryResult items collect: #package as: Array.  self assert: tmp1 equals: {ClyClass1FromP1 package .         ClySubclassMOfClass1FromP2 package .         ClySubclassLOfSubclassMFromP3 package}testCheckIfEmpty  query scope: (ClyMethodScope of: ClyAbstractClassExample >> #abstractMethod1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyAbstractClassExample >> #overriddenMethod in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyAbstractClassExample >> #abstractMethod2 in: environment).  self assert: query checkEmptyResultfindItemsWith: arg1  ^Array new: arg1 size withAll: nillastSelectedItem  ^selectedItems firstwithAbstractMethodsOf: arg1 do: arg2  arg1 localMethods select: [:arg3 |  self isAbstractMethod: arg3 ] thenDo: arg2lastSelectedVariable  ^self selectedVariabletestFillingWithObjectAndTwoProtoObjects  queryResult fillWith: {Object .         ProtoObject .         ProtoObject}.  self assertItems: {ProtoObject .         0 .         Object .         1}copyForBrowserStateSnapshot  ^self copy     initializeForBrowserStateSnapshot;     yourselftestComparisonWithAnotherHierarchy  | tmp1 |  tmp1 := self createQueryResult.  tmp1 hierarchy: queryResult hierarchy inverted.  self deny: queryResult equals: tmp1systemChanged: arg1  self updateUsing: ClyFullEnvironmentUpdateStrategy new by: [ self handleSystemChange: arg1 ]supportsQuery: arg1  self subclassResponsibilitytestCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #reader1OfVar1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #writerOfVar1 in: environment).  self assert: query checkEmptyResultasScope: arg1  | tmp1 |  tmp1 := super asScope: arg1.  tmp1 adoptLocalScopeClassTo: self localScopeClass.  ^tmp1affectedClass  ^affectedClasslastSelectedMethod  ^self lastSelectedObjectIn: self selectedMethodsprintContext  ^editingPackage namedecorateBrowserItem: arg1 ofProject: arg2  testItemsChangedNotificationShouldNotResetExistingItems  queryResult items: #(items).  queryResult itemsChanged.  self assert: queryResult items equals: #(items).  self assert: queryResult needsRebuildtestFromClassWithoutCommentWhenPatternSatisfiesCommentTemplate  | tmp1 tmp2 |  tmp1 := Object newAnonymousSubclass.  self deny: tmp1 hasComment.  tmp2 := tmp1 comment copyFrom: 4 to: 30.  query pattern: (ClySubstringPattern with: tmp2).  self queryFromScope: ClyClassScope of: tmp1.  self assert: resultItems isEmptytestDescriptionWhenSimpleClassBindingIsUsed  query := ClyClassReferencesQuery to: Object binding.  self assert: query description equals: 'references to Object'restoreBrowserState  ownerTool restoreBrowserStatelogged: arg1  lastSelectedMessage  ^self selectedMessagecreateQuery  ^ClyMethodCallCountersQuery from: ClyClassScope of: self class in: environmentnavigationEnvironment  ^self browser navigationEnvironmentrenameClassTagTo: arg1  self classes do: [:arg2 |  arg2 tagWith: arg1 ]= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^extraParameter = arg1 extraParameterapplyChanges  | tmp1 tmp2 tmp3 |  tmp2 := self chooseClassForNewMethodIfNone: [ ^false ].  tmp1 := tmp2 compile: self pendingText classified: editingMethod protocol notifying: textMorph.  tmp1 ifNil: [ ^false ].  tmp3 := tmp2 >> tmp1.  self tagAndPackageEditingMethod: tmp3.  self switchToMethod: tmp3.  ^truetabMorph: arg1  tabMorph := arg1handlesAnnouncement: arg1  | tmp1 |  affectedMethod isInstalled ifFalse: [ tmp1 := affectedMethod origin localMethodNamed: affectedMethod selector ifAbsent: [ nil ].        tmp1 ifNotNil: [ affectedMethod := tmp1 ] ].  ^arg1 affectsMethod: affectedMethodtestComparisonToSimilarQueryButWithDifferentVariables  | tmp1 |  tmp1 := self createQuery.  tmp1 variableQuery: (ClyConstantQuery returning: #(someAnotherVar)).  self deny: query equals: tmp1rawResultItems  ^queryResult items collect: #actualObject, arg1  self subclassResponsibilitysystemEnvironment  ^systemEnvironmentdescription  ^'problem methods (' , critiqueQuery description , ')'selectClass: arg1 atMethodTag: arg2  self changeStateBy: [ self selectClass: arg1.        self methodGroupSelection selectItemsWhere: [:arg3 |  arg3 name = arg2 ] ]showQueries: arg1 as: arg2  | tmp1 |  tmp1 := ClyQuery unionFrom: arg1 as: arg2.  self showQuery: tmp1dragTransferType  ^#CommanderDragAndDropasInheritingScope  | tmp1 |  tmp1 := subscopes collect: [:arg1 |  arg1 asInheritingScope ].  ^ClyCompositeScope on: tmp1 in: environment named: ClyClassScope inheritingScopeNameisPackageSelected  ^tool packageSelection isEmpty notselectedVariables  ^self selectedObjects collect: [:arg1 |  arg1 variable ]fillWith: arg1  | tmp1 |  tmp1 := Dictionary new.  arg1 do: [:arg2 |  self buildMethodGroupWithCritique: arg2 on: tmp1 ].  tmp1 do: [:arg3 |  items add: arg3 ]visibilityLevels: arg1  visibilityLevels := arg1 reject: [:arg2 |  arg2 isRedundant ]testSuperSendNoArg_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'super msg') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext receiver perform: #msg withArguments: {} inSuperclass: ThisContext receiver class superclass)]')asTraitVisibility  ^selftestSelectsTestMethodWithExpectedFailurePragma  self assert: (query selectsMethod: ClyTestedClassTest >> #testExpectedFailure)testGettingEnvironment  self assert: query environment equals: environmentgroupProviderClass  ^ClyInheritedMethodGroupProvidertargetTestCasesFor: arg1  | tmp1 tmp2 |  tmp2 := IdentitySet new.  tmp1 := self testResultOf: arg1.  runTestCases do: [:arg2 |  tmp1 concreteResultOf: arg2 ifPresent: [:arg3 |  tmp2 add: arg2 ] ].  ^tmp2 ifEmpty: [ tmp1 testCases ]buildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope methodGroupsDo: [:arg2 |  tmp1 add: arg2 ].  arg1 fillWith: tmp1defaultMenuIconName  ^#smallFindIconprintExtraInfoOn: arg1  testFromSinglePackage  self queryFromScope: ClyPackageScope of: ClyClass1FromP1 package.  self assert: resultItems asSet equals: {ClyClass1FromP1 package} asSettestConvertingToSemiAsyncQuery  | tmp1 |  tmp1 := query semiAsync.  self assert: tmp1 identicalTo: querytargetView: arg1  targetView := arg1retrievesItem: arg1  self subclassResponsibilitytestFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(classSideReference1OfClass reference1OfClass reference2OfClass)lastSelectedMethod  ^self selectedMethodinitialize  super initialize.  changesCancelRequested := false.  applyingChanges := falseclassesRelatedTo: arg1 do: arg2  self subclassResponsibilityrepresentsScope: arg1  ^self isKindOf: arg1isSelectedMethodGroupEditable  self isMethodGroupSelected ifFalse: [ ^false ].  ^self selectedMethodGroupClass isEditableGroupisAppliedToBrowser  self subclassResponsibilitydecorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 definitionIcon: #recoverLostChangesbuildGroupsFor: arg1  | tmp1 |  tmp1 := ClyClassScope of: arg1 in: environment.  builtGroups := groupProvider buildGroupsFrom: tmp1retrievesItemsOfType: arg1  self subclassResponsibilityapplyResultInContext: arg1  super applyResultInContext: arg1.  arg1 showMethodTag: newNamedetachFromSystem  environment system unsubscribe: selftestHasQueryResult  self assert: cursor queryResult class equals: ClyAsyncBrowserQueryResultAdapter.  self assert: cursor queryResult actualResult equals: queryResultformatSourceCode  textMorph formatSourceCodeisProjectSelected  ^self selectedProjectItems notEmptyaddColumn: arg1  | tmp1 |  tmp1 := ClyTableColumn id: arg1.  table addColumn: tmp1.  ^tmp1abstractMethod1  self subclassResponsibilityupdate  editingMethod := editingMethod origin localMethodNamed: editingMethod selector ifAbsent: [ ^self ].  super update.  self formatTextIfNeededselectVariableNamed: arg1  self selectAnyVariable: {arg1}printExtraInfoOn: arg1  super printExtraInfoOn: arg1.  arg1 nextPutAll: groupNamematches: arg1  ^pattern matches: arg1 nametestFromClassScope  self queryFromScope: ClyClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(reference1OfVar1 reference2OfVar1)resetImplementorsCache  cacheGuard critical: [ allImplementorsCache := nil ]testCheckEmptyQueryWhenThereIsNoResultButItWouldBeEmpty  | tmp1 |  tmp1 := self createQueryFromScope: ClyScopeExample empty.  self assert: (environment isQueryEmpty: tmp1)createQuery  ^self queryClass of: (ClyInstanceVariable named: self targetVarName definedIn: ClyVariableReferencesTestCase) from: (ClyClassScope of: self class in: environment)system  ^basisObjects anyOnedefaultMenuItemName  ^'Find method'testComparison  self assert: (ClyMessageSendersQuery of: #message1) equals: (ClyMessageSendersQuery of: #message1).  self assert: (ClyMessageSendersQuery of: #message1) hash equals: (ClyMessageSendersQuery of: #message1) hash.  self deny: (ClyMessageSendersQuery of: #message1) equals: (ClyMessageSendersQuery of: #message2)refreshTable  table refreshsilentlySelectPackageOfSelectedClass  | tmp1 |  self classSelection isEmpty ifTrue: [ ^self ].  tmp1 := self classSelection lastSelectedItem actualObject.  packageView ignoreNavigationDuring: [ tmp1 tags ifEmpty: [ self selectPackage: tmp1 package ] ifNotEmpty: [:arg1 |  self selectPackage: tmp1 package atClassTag: arg1 anyOne ] ]decorateTableCell: arg1 of: arg2  | tmp1 |  super decorateTableCell: arg1 of: arg2.  tmp1 := arg1 label font.  arg1 label font: (LogicalFont familyName: tmp1 familyName pointSize: tmp1 pointSize - 1).  arg1 label color: Color grayhash  ^super hash bitXor: hierarchy hashremoveWithMethods  self error: 'You should not remove inherited methods'moveTo: arg1  position := arg1.  cache loadItemOf: queryResult at: positioncreateQueryResult  ^ClyTraitUserHierarchy new asQueryResulthash  ^direction hashinstanceSideVar1WriterMethod  instanceSideVar1 := #var1ValuecreateQuery  ^super createQuery scope: (ClyClassScope of: ClyClass1FromP1 in: environment)execute  methodGroup renameMethodTagTo: newName asSymbolrawItemsOf: arg1 do: arg2  ^self rawItemsDo: [:arg3 |  arg3 calypsoEnvironmentType = arg1 ifTrue: [ arg2 value: arg3 ] ]bindingOf: arg1  ^globals bindingOf: arg1matches: arg1  | tmp1 |  tmp1 := self createRegexMatcherIfFailed: [ ^true ].  ^tmp1 search: arg1initialize  super initialize.  inverse := falsefindItemWhich: arg1 ifExists: arg2  items detect: arg1 ifFound: arg2isExtraSelectionRequested  | tmp1 |  tmp1 := ActiveHand lastEvent.  ^tmp1 isMouse and: [ tmp1 isMouseDown and: [ tmp1 commandKeyPressed or: [ tmp1 controlKeyPressed ] ] ]spawnFullBrowser  super spawnFullBrowser.  self itemCount = 1 ifTrue: [ [ self close ] on: ProvideAnswerNotification do: [:arg1 |  arg1 resume: false ] ]initializeOn: arg1  browser := arg1.  self initializetestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (ClyAbstractClassExample >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 overriddenMethod)testMakeQueryOfResultAsReadOnlyObjectWhenItIsExecuted  | tmp1 |  tmp1 := self createQueryFromScopeOf: self class.  environment query: tmp1.  self assert: tmp1 isReadOnlyObjecttestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: Object >> #printString in: environment).  self assert: query checkEmptyResulttestCaseInsensitiveMathingString  | tmp1 |  tmp1 := ClySubstringPattern with: 'subString' caseSensitive: false.  self assert: (tmp1 matches: 'start subString end').  self assert: (tmp1 matches: 'start substring end').  self deny: (tmp1 matches: 'another string')visibilityLevel  ^visibilityLevelinitialize  super initialize.  updateQueue := AtomicSharedQueue newtestConvertingToAsyncQuery  | tmp1 |  tmp1 := query async.  self assert: tmp1 identicalTo: querycreateQueryScope  | tmp1 tmp2 |  tmp1 := methods collect: [:arg1 |  arg1 origin ].  tmp2 := self createInheritanceScopeFrom: tmp1.  tmp2 := tmp2 withMetaLevel: ClyClassScope.  ^tmp2belongsToCurrentBrowserContext  ^(browser isMethodSelected: leftMethod) and: [ browser isMethodSelected: rightMethod ]packagesDo: arg1  self projectsDo: [:arg2 |  arg2 packages do: arg1 ]hasSubMenu  ^falsecreateQuery  ^ClyAllPackagesQuery from: ClyPackageScope of: Object package in: environmentselectAsExtraTab  containerTab addToSelectionisAboutBrowserItemType: arg1  ^selectedItems anySatisfy: [:arg2 |  arg2 type isCalypsoItemType: arg1 ]requestRemoveMethodStrategyFor: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := (arg1 collect: [:arg2 |  arg2 selector ] as: IdentitySet) asArray.  tmp5 := (ClyMessageSendersQuery ofAny: tmp1 from: self systemScope) execute.  (self allowSilentlyRemoveMethods: arg1 whichHaveSenders: tmp5) ifTrue: [ ^SycSilentlyRemoveMethodStrategy new ].  tmp3 := SycRemoveMethodStrategy createAllForBrowser: self.  tmp6 := tmp5 size.  tmp7 := '' asPluralBasedOn: tmp6.  tmp4 := tmp1 size > 1 ifTrue: [ 'There are {1} sender{2}' format: {tmp6 .               tmp7} ] ifFalse: [ 'The message #{1} has {2} sender{3}' format: {tmp1 anyOne .               tmp6 .               tmp7} ].  tmp2 := UIManager default chooseFrom: (tmp3 collect: #userRequestString) values: tmp3 title: tmp4.  ^tmp2 ifNil: [ SycNotRemoveMethodStrategy new ]updateSelectionForNewFilter  | tmp1 |  tmp1 := selection.  self initiateUIChangeBy: [ self updateSelection.        (desiredSelection notNil and: [ desiredSelection isEmpty not ]) ifTrue: [ desiredSelection restoreCurrentSelection: selection ] ].  ^(selection isSameAs: tmp1) notselectionChanged  | tmp1 |  tmp1 := true.  self changeStateBy: [ self isFilterChanged ifTrue: [ tmp1 := self updateSelectionForNewFilter.              tmp1 ifFalse: [ ^self ] ].        tmp1 ifTrue: [ self updateSelection ].        navigationSelector ifNotNil: [ browser perform: navigationSelector withEnoughArguments: {self selection} ] ].  self triggerClickCommandsqueryClass  self subclassResponsibilitynumberOfRows  ^self itemCursor itemCount + (expandedItems detectSum: [:arg1 |  arg1 childrenCount ])createMethodQueryFrom: arg1  ^ClyFailedTestMethodsQuery from: arg1testNotSelectsMethodWithoutCounter  self deny: (query selectsMethod: self class >> #methodWithoutCounter)getPlugin: arg1  ^plugins detect: [:arg2 |  arg2 class = arg1 ]beProtected  tabManager  ^tabManagerhash  ^super hash bitXor: baseCritiqueQuery hashdecorateTool: arg1  arg1 supportsCriticDecoration ifFalse: [ ^self ].  arg1 addDecorator: ClyCriticDecorator newactivateWindow: arg1  | tmp1 |  (self tabGroup pages includes: arg1) ifTrue: [ tmp1 := self tabGroup pages indexOf: arg1.        ^self tabGroup selectedPageIndex: tmp1 ].  self addWindow: arg1.  arg1     activate;     announceOpenedtools  ^toolstestDetectingDefiningClassFromSharedPoolUserClassSide  | tmp1 tmp2 |  tmp1 := ChronologyConstants classVariableNamed: #DayNames.  tmp2 := ClyClassVariable on: tmp1 visibleFrom: Date class.  self assert: tmp2 definingClass equals: ChronologyConstantsbuildFrom: arg1  | tmp1 |  tmp1 := ClyClassHierarchyMap for: self of: arg1.  tmp1 build.  ^tmp1methodWithoutCounter  iconName  ^#smallDoItIconcreateMethodQueryFrom: arg1  ^ClyAllExtensionMethodsQuery from: arg1defaultClassCompiler  ^self class compilertraitScopeClass  self subclassResponsibilityactionBlock  ^actionBlocklastSelectedClass  ^self selectedClassreader1OfVar1  ^readVar1subclassN2VarReaderMethod  ^subclassN2VarprintOn: arg1  super printOn: arg1.  name ifNil: [ ^self ].  arg1 nextPut: $(.  arg1 nextPutAll: name.  arg1 nextPut: $)buildContextMenu: arg1  arg1 addLine.  super buildContextMenu: arg1.  arg1 addLineprintMethodTags  ^ownerTool methodTags ifEmpty: [ 'as yet unclassified' asText makeAllColor: Color red ] ifNotEmpty: [:arg1 |  arg1 joinUsing: ', ' ]withSubqueries: arg1  ^self copy subqueries: arg1testIsExecutedFromConcreteScopeClass  self assert: (query isExecutedFromScope: ClyScopeExample).  self assert: (query isExecutedFromScope: ClyScope).  self deny: (query isExecutedFromScope: Array)belongsToDataSource: arg1  ^ownerDataSource == arg1asGoToSpotterCandidate  ^ClyGoToSpotterCandidate target: self activeQueryView named: self simpleNameForSpotterMenu icon: self iconForSpotterMenu using: [ self activeQueryView takeKeyboardFocus ]fillItemsFrom: arg1  items := arg1 itemsStartingAt: startPosition count: sizeLimitmatches: arg1  self subclassResponsibilityfillWith: arg1  | tmp1 |  items := OrderedCollection new: arg1 size.  tmp1 := hierarchy buildFrom: arg1.  tmp1 rootsDo: [:arg2 |  self buildItemFor: arg2 from: tmp1 depth: 0 ]