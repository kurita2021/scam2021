package  ^packagesortFunction  ^sortFunctionbuild  diffMorph := DiffMorph from: self leftMethod sourceCode to: self rightMethod sourceCode.  diffMorph     contextClass: self rightMethod sourceCode;     hResizing: #spaceFill;     vResizing: #spaceFill;     showOptions: false.  self addMorph: diffMorph fullFrame: LayoutFrame identitymetaLevelsOf: arg1 do: arg2  self subclassResponsibilitytestCreationWithSingleSubquery  | tmp1 |  tmp1 := self subqueryFromScopeOf: Array.  query := ClyUnionQuery with: {tmp1}.  self assert: query equals: tmp1.  self deny: query identicalTo: tmp1buildStatusBar  statusBar := ClyStatusBarMorph new.  statusBar width: browser width.  self addMorphBack: statusBar.  self fillStatusBarupdateItemsWhichBelongsTo: arg1  | tmp1 tmp2 |  tmp1 := items select: [:arg2 |  arg2 belongsToDataSource: arg1 ].  tmp2 := arg1 itemCursor findItemsWith: (tmp1 collect: #actualObject).  tmp1 with: tmp2 do: [:arg3 :arg4 |  arg4 ifNotNil: [ arg3 updateItemWith: arg4 ] ].  ^falsecollectMethodGroupProviders  ^{ClyBreakpointMethodGroupProvider new .   ClyMethodCounterGroupProvider new .   ClyWatchpointMethodGroupProvider new}critique  ^critiquetestClassVarsEnumeration  scope := ClyClassScope ofAll: {Object .         ClyClass1FromP1}.  scope classVariablesDo: [:arg1 |  result add: arg1 ].  self assert: result size equals: 1.  self assert: result anyOne equals: (ClyClassVariable on: Object classVariables first definedIn: Object)findParentItemOf: arg1  | tmp1 |  tmp1 := self parentItem ifNil: [ ^nil ].  (tmp1 isBasedOnItemType: arg1) ifTrue: [ ^tmp1 ].  ^tmp1 findParentItemOf: arg1restoreBrowserInstance  self snapshotState.  browser := navigationState createBrowserapplyBreakpointCondition: arg1  arg1 oncemethodFromRoot1  selectsMethod: arg1  ^arg1 isTaggedWith: tagtargetVarName  ^#readVar1selectedTextInterval  ^textMorph selectionIntervalisResult: arg1 affectedBy: arg2  ^(arg2 affectsMethodsDefinedInPackage: package) and: [ scope includesMethodsAffectedBy: arg2 ]subscribe: arg1  self subscribe: arg1 for: SystemAnnouncementtestRetrievesMetaLevelScope  self snapshotState.  self assert: navigationState metaLevelScope equals: browser metaLevelScopeselectsMethod: arg1  ^arg1 isTestMethod and: [ arg1 isPassedTest not ]order  ^5000readParametersFromContext: arg1  super readParametersFromContext: arg1.  runTestCases := arg1 selectedClassesmethodGroup  ^methodGroupqueryClass  ^ClyFilterQuerycheckEmptyResult  | tmp1 |  tmp1 := baseCritiqueQuery execute.  ^(tmp1 items anySatisfy: [:arg1 |  self selectsCritique: arg1 ]) notadoptForDialog  (self areItemsLoaded and: [ self itemCount < 10 ]) ifTrue: [ self height: 100 ] ifFalse: [ self           height: 300;           enableFilterUsing: ClyRegexPattern new ]runUpdate  self isClosed ifTrue: [ ^self ].  dirty ifFalse: [ ^self ].  dirty := false.  itemCursor updateItemCache.  self updateExpandingItems.  queryView itemsChangedIn: self.  self tableRefreshhasMetaProperty: arg1  ^self metadata hasProperty: arg1testAscending  function := ClyTraitFirstSortFunction ascending.  self assert: (function value: ClyTraitRoot1 value: ClyTraitRoot2).  self deny: (function value: ClyTraitRoot2 value: ClyTraitRoot1).  self deny: (function value: ClyClass1FromP1 value: ClyTraitRoot1).  self assert: (function value: ClyTraitRoot1 value: ClyClass1FromP1).  self assert: (function value: ClyTraitRoot1 value: ClyTraitRoot1).  self assert: (function value: ClyClass1FromP1 value: ClyClass1FromP1)deprecatedMethod1  self deprecated: 'it is deprecated method for testing deprecation analyzis'globalPositionOf: arg1  self subclassResponsibilityselectedClassItems  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  selectedItems do: [:arg1 |  tmp2 := arg1 systemDefinition definingClassItem.        tmp1 detect: [:arg2 |  arg2 actualObject == tmp2 actualObject ] ifNone: [ tmp1 add: tmp2 ] ].  ^tmp1recordState: arg1  arg1 representsConcreteQuery ifFalse: [ ^self ].  waitingNewState ifFalse: [ ^self ].  undoExecuting | redoExecuting ifTrue: [ waitingNewState := false ].  undoExecuting ifTrue: [ redoList add: arg1 ] ifFalse: [ redoExecuting ifFalse: [ redoList removeAll ].        undoList add: arg1 ]isClassVariable  self subclassResponsibilityinitialize  super initialize.  environment := RGEnvironment new.  projectManager := ClyProjectManagerRegistry newtestCreationFromTwoDifferentTypedQueries  | tmp1 tmp2 |  tmp1 := ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: Array in: environment.  tmp2 := ClyQueryExampleReturningScopeBasis2 from: ClyScopeExample of: String in: environment.  query := tmp1 , tmp2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {tmp1 .         tmp2} asSet.  self assert: query requiredResult identicalTo: tmp1 requiredResultapplyChanges  | tmp1 |  tmp1 := browser compileANewClassFrom: self pendingText asString notifying: textMorph startingFrom: editingClass.  tmp1 ifNil: [ ^false ].  editingClass == tmp1 ifFalse: [ self removeFromBrowser ].  browser selectClass: tmp1.  ^trueunsubscribe: arg1  environment announcer unsubscribe: arg1tag1Method1  definingPackage: arg1  definingPackageItem := ClyBrowserItem named: arg1 name with: arg1newName: arg1  newName := arg1acceptTags  textMorph accept.  textMorph hasUnacceptedEdits: falsetestIsEmptyFromEmptyMethodScope  < expectedFailure>  super testIsEmptyFromEmptyMethodScopecreateCommandContext  ^ClyUnknownBrowserContext for: selfmetaLevelScope  ^ClyClassSideScopeaddInheritedMethodGroup  | tmp1 |  tmp1 := ClyAllMethodGroup withMethodsInheritedFrom: self queryScope.  items add: tmp1 asCalypsoBrowserItemclassesDo: arg1  basisObjects do: [:arg2 |  self allClassesRelatedTo: arg2 do: arg1 ]collectMetadataOfMethods: arg1  | tmp1 |  tmp1 := ClyTestResultProperty new.  arg1 rawItemsOf: ClyMethod do: [:arg2 |  (arg2 isTestMethod and: [ arg2 methodClass isAbstract not ]) ifTrue: [ tmp1 accumulateTestMethod: arg2 ] ].  tmp1 allCount > 0 ifTrue: [ arg1 addMetaProperty: tmp1 ]prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  targetClass := arg1 requestSingleClass: 'Choose class'.  targetClass := arg1 currentMetaLevelOf: targetClassaffectsMethodsDefinedInPackage: arg1  overridingSubclass allSuperclassesDo: [:arg2 |  arg2 package = arg1 ifTrue: [ ^true ] ].  ^falsetestForMetaclass  query := ClyClassReferencesQuery to: self referencedClass classSide.  self queryFromScope: ClyMethodScope of: self class >> #reference1OfClass.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfClassinitializeNavigationViews  self subclassResponsibilityclassSampleWhichHasGroup  ^ClyClassWithDeprecatedMethodsdescription  ^'Ban this rule'elementAt: arg1  | tmp1 |  tmp1 := arg1.  expandedItems do: [:arg2 |  arg2 position = tmp1 ifTrue: [ ^arg2 ].        (arg2 hasChildAt: tmp1) ifTrue: [ ^arg2 childrenItemAt: tmp1 ].        (arg2 isAfter: tmp1) ifTrue: [ self itemCursor moveTo: tmp1.              ^ClyDataSourceItem of: self value: self itemCursor currentItem ].        tmp1 := tmp1 - arg2 childrenCount ].  self itemCursor moveTo: tmp1.  ^ClyDataSourceItem of: self value: self itemCursor currentItembuildingQuery: arg1  buildingQuery := arg1addCritique: arg1  | tmp1 |  tmp1 := ClyCritiqueSeverityProperty of: arg1.  (tmp1 isMoreImportantThan: ruleSeverity) ifTrue: [ ruleSeverity := tmp1 ]ignoreNavigationDuring: arg1  arg1 valuerequiredQueryResult  self subclassResponsibilityprepareBasisFrom: arg1  ^arg1collectMetadataOfClasses: arg1  initializeNavigationViews  resultView := self newNavigationView.  resultView enableFilter: ClyQueryBrowserFilter.  resultView allowsDeselection: false.  resultView mainColumn     width: 250;     displayItemPropertyBy: [:arg1 |  self classNameOf: arg1 ].  (resultView addColumn: #name)     width: 400;     displayItemPropertyBy: [:arg1 |  self mainNameOf: arg1 ].  (resultView addColumn: #package)     width: 50;     displayItemPropertyBy: [:arg1 |  self packageNameOf: arg1 ]createClassQueryFrom: arg1  ^ClyRestUntaggedClassesQuery from: arg1collectMetadataOf: arg1 by: arg2  arg2 collectMetadataOfMethodGroups: arg1testCase  ^testCasetestDetectingDefiningClassFromSubclassClassSide  | tmp1 tmp2 |  tmp1 := ClyClass2FromP1 classVariableNamed: #ClassVar1.  tmp2 := ClyClassVariable on: tmp1 visibleFrom: ClySubclassLOfClass2FromP1 class.  self assert: tmp2 definingClass equals: ClyClass2FromP1printTextLinePositionOf: arg1  | tmp1 tmp2 tmp3 |  tmp2 := arg1 textLine.  tmp3 := arg1 stringIndex - tmp2 first + 1.  tmp1 := tmp2 lineNumber printString , '/' , self textArea lines size printString , ' [' , tmp3 printString , ']'.  ^tmp1isMessageSelected  ^self selectedSourceNode isMessagesubtreeSize: arg1  subtreeSize := arg1definingClassItem  ^definingClassItemexecute  self executeRefactoringsasSelectedParentsOf: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self isEmpty ifTrue: [ ^self ].  tmp3 := items select: [:arg2 |  arg2 isBasedOnItemType: arg1 ].  tmp3 = items ifTrue: [ ^self ].  tmp1 := items reject: [:arg2 |  arg2 isBasedOnItemType: arg1 ] thenCollect: [:arg2 |  arg2 findParentItemOf: arg1 ].  tmp4 := tmp1 asSet.  tmp4 remove: nil ifAbsent: [  ].  tmp4 addAll: tmp3.  tmp2 := tmp4 asOrderedCollection.  tmp5 := self lastSelectedItem.  (tmp4 includes: tmp5) ifTrue: [ tmp2 remove: tmp5.        tmp2 addFirst: tmp5 ].  ^self class fromRoot: self rootDataSource items: tmp2getMetaProperty: arg1  ^self metadata getProperty: arg1createQuery  ^ClyUnionQuery with: {(ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: self class in: environment) .         (ClyQueryExampleReturningScopeBasis2 from: ClyScopeExample2 of: self class superclass in: environment)}isInSameStateAs: arg1  (super isInSameStateAs: arg1) ifFalse: [ ^false ].  collapsedItems size = arg1 collapsedItems size ifFalse: [ ^false ].  ^collapsedItems allSatisfy: [:arg2 |  arg1 collapsedItems anySatisfy: [:arg3 |  arg2 isSameAs: arg3 ] ]excludesHaltsForTesting: arg1  excludesHaltsForTesting := arg1globalPosition  ^ownerDataSource globalPositionOf: selftestNotAffectedByChangeOfNotAbstractMethod  query scope: (ClyClassScope of: ClyClassWhichInheritsAbstractClass in: environment).  self deny: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)package  ^packageinitialize  super initialize.  title := 'MessageBrowser'applyResultInContext: arg1  super applyResultInContext: arg1.  arg1 tool criticView updateclassSampleWhichHasGroup  ^ClyClassWhichInheritsAbstractSubclasschangeStateOf: arg1 by: arg2  arg2 valueisEmpty  ^methodQuery hasEmptyResultincludesClassesAffectedBy: arg1  self classesDo: [:arg2 |  (arg1 affectsClass: arg2) ifTrue: [ ^true ] ].  ^falsetestClassEnumeration  | tmp1 |  scope := ClySubclassScope of: ClyClass1FromP1.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := ClyClass1FromP1 allSubclasses.  self assert: result asSet equals: tmp1 asSetbuildTestSuite  self subclassResponsibilitylastSelectedClassGroup  ^self lastSelectedObjectdefaultMenuIconName  ^#monticelloPackagetestFromPackageWithoutTagsAndExtensions  self queryFromScope: ClyPackageScope of: ClyClass9FromPExtendedByP5 package.  self assert: resultItems isEmptymultipleScopeSample  ^self scopeClass ofAll: {self singleBasisSample .         self extraBasisSample} in: environmentwhen: arg1 send: arg2 to: arg3  self environment announcer when: arg1 send: arg2 to: arg3order  ^1.5selectedMethod  ^tool editingMethodrepresentsItemOfType: arg1  ^type isCalypsoItemType: arg1itemsWhere: arg1  ^self prepareItems: (actualResult itemsWhere: arg1)testConvertingToInterestingClassScope  | tmp1 |  scope := ClyCompositeScope on: {(ClySuperclassScope of: String in: environment localScope: ClyInstanceSideScope) .         (ClySubclassScope of: Array in: environment localScope: ClyClassSideScope)}.  tmp1 := scope asInterestingClassScope.  self assert: tmp1 class equals: ClyCompositeScope.  self assert: tmp1 subscopes asSet equals: {(ClyInterestingSuperclassScope of: String localScope: ClyInstanceSideScope) .         (ClySubclassScope of: Array localScope: ClyClassSideScope)} asSet.  self assert: tmp1 environment equals: environmentbuildItemFor: arg1 from: arg2 depth: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := ClyBrowserItem named: arg1 name with: arg1.  tmp1 depth: arg3.  items add: tmp1.  tmp2 := arg3 + 1.  tmp3 := arg2 childrenOf: arg1.  tmp4 := tmp3 size.  tmp3 do: [:arg4 |  tmp5 := self buildItemFor: arg4 from: arg2 depth: tmp2.        tmp4 := tmp4 + tmp5 localHierarchySize ].  tmp1 localHierarchySize: tmp4.  ^tmp1rebuild  self initializeItems.  metadata ifNil: [ metadata := ClyQueryResultMetadata new ].  metadata addProperty: ClyBackgroundProcessingTag instance.  self runBuildProcessprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  classGroup := arg1 requestSinglePackage: 'Choose package'priority: arg1  priority := arg1methodSelectionChanged  | tmp1 |  tmp1 := self methodSelection actualObjects.  methodGroupView highlightItemsWhich: [:arg1 |  tmp1 anySatisfy: [:arg2 |  arg1 actualObject includesMethod: arg2 ] ]decorateBrowserItem: arg1 ofMethodGroup: arg2  initialize  super initialize.  subgroupsQuery := ClyUnknownQuery instancescope  ^buildingQuery scopeexecute  | tmp1 |  tmp1 := browser searchDialog requestSingleObject: 'Choose method' from: browser methodView query.  browser selectMethod: tmp1isClassHasToBeImplemented: arg1  (self doesClassDefinedAsAbstract: arg1) ifTrue: [ ^false ].  arg1 allSuperclassesDo: [:arg2 |  arg2 == Object ifTrue: [ ^false ].        self withAbstractMethodsOf: arg2 do: [:arg3 |  | tmp1 |              tmp1 := arg1 lookupSelector: arg3 selector.              tmp1 == arg3 ifTrue: [ ^true ] ] ].  ^falsetestConvertingWithNewBasisShouldKeepMetaLevelScope  | tmp1 |  scope := self singleScopeSample.  scope localScopeClass: ClyInstanceSideScope.  tmp1 := scope withNewBasisObjects: {self extraBasisSample}.  self assert: tmp1 localScopeClass equals: ClyInstanceSideScopedefiningClass: arg1  definingClass := arg1itemAt: arg1  ^items at: arg1 - startPosition + 1browser  ^browserclassGroup: arg1  classGroup := arg1createQuery  ^ClyAllProblemMethodQuery from: (ClyClassScope emptyIn: environment)testConvertingToAnotherScopeClass  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asScope: ClyScopeExample.  self assert: tmp1 class equals: ClyScopeExample.  self assert: tmp1 basisObjects asIdentitySet equals: scope basisObjects asIdentitySet.  self assert: tmp1 environment equals: environment= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^items = arg1 itemsnewMethodGroupView  ^self newNavigationView     treeStructure: {(ClyMethodGroup -> #prepareSubgroupsQueryFrom:in:)};     requestNavigationBy: #methodGroupSelectionChanged;     neverRestoreSelectiontestIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  query subqueries: {(self subqueryFromScope: ClyScopeExample of: self class) .         (self subqueryFromScope: ClyScopeExample2 of: self class)}.  self assert: query isExecutedFromSingleScopetestFillingItems  queryResult fillWith: {Object .         Array .         Point}.  self assert: queryResult items asArray equals: {Array .         Object .         Point}classGroupSelection  ^packageView selection asSelectedItemsOf: ClyClassGroupqueryClass  ^ClyVariableReferencesQueryhash  ^super hash bitXor: tag hashcompileANewClassFrom: arg1 notifying: arg2 startingFrom: arg3  ^self system compileANewClassFrom: arg1 notifying: arg2 startingFrom: arg3affectedMethod  ^affectedMethodshortName  ^'Vars'defaultMenuIconName  ^#smallQuestionIconnavigateSpawnedFullBrowser: arg1  self isScopedModeEnabled ifTrue: [ arg1 switchToPackageScopeOf: packageView query scope basisObjects ].  self methodSelection isEmpty ifFalse: [ ^arg1 selectMethod: self methodSelection lastSelectedItem actualObject ].  self classSelection isEmpty ifFalse: [ ^arg1 selectClass: self classSelection lastSelectedItem actualObject ].  self packageSelection isEmpty ifFalse: [ ^arg1 selectPackage: self packageSelection lastSelectedItem actualObject ]affectedPackage  ^affectedPackagelastSelectedMethodClass  | tmp1 |  tmp1 := self lastSelectedObjectIn: self selectedMethodItems.  ^tmp1 systemDefinition definingClasshash  ^super hash bitXor: relationScopeClasses hashfindItemsSimilarTo: arg1  | tmp1 tmp2 |  self protectItemsWhile: [ tmp1 := arg1 as: OrderedCollection.        tmp2 := OrderedCollection new.        items do: [:arg2 |  tmp1 detect: [:arg3 |  arg3 isSimilarTo: arg2 ] ifFound: [:arg3 |  arg2 prepareIn: environment.                    tmp2 add: arg2.                    tmp1 remove: arg3.                    tmp1 ifEmpty: [ ^tmp2 ] ] ].        ^tmp2 ]isAccessibleFrom: arg1  ^arg1 = definingClass or: [ arg1 inheritsFrom: definingClass ]lastSelectedMessage  ^SycMessageDescription ofMethod: self lastSelectedMethodscopes  ^browser allNavigationScopescriteriaBlock  ^criteriaBlocktestSelectsFFIMethod  self assert: (query selectsMethod: ClyClassWithFFIMethods >> #ffiMethod)untestedOneTwo: arg1  self two: arg1addProperty: arg1  properties add: arg1testRetrievesMethodGroupContent  self snapshotState.  self assert: navigationState methodGroupQuery equals: browser methodGroupQuerytestConvertingAsRestrictedByAnotherScope  | tmp1 tmp2 |  tmp1 := ClyScopeExample2 of: #newBasis in: environment.  tmp2 := query restrictedByScope: tmp1.  self assert: tmp2 class equals: query class.  self assert: tmp2 scope class equals: query scope class.  self assert: tmp2 scope basisObjects equals: #(newBasis) asSettableDescription  ^'Sent ' , self currentCallsCount asString , ' times. Click to remove'createSelectionContext  ^self createSelectionContextOf: self selectionrestoreSelectedTools: arg1  | tmp1 tmp2 |  tools ifEmpty: [ ^self ].  tmp1 := self selectMainTool.  tmp2 := arg1 reject: [:arg2 |  arg2 class = tmp1 class ].  tmp2 size = arg1 size ifTrue: [ tmp2 := #() ] ifFalse: [ tmp1 isExtraSelectionRequested ifTrue: [ tmp2 add: tmp1 ] ].  (tools copyWithout: tmp1) do: [:arg3 |  tmp2 detect: [:arg4 |  arg4 class = arg3 class ] ifFound: [ self restoreSelectionOfExtraTool: arg3 ] ifNone: [ arg3 deselectTab ] ].  tmp2 ifNotEmpty: [ tmp1 deselectTab.        tmp1 selectAsExtraTab ].  tmp1 waitBuildCompletiongetProperty: arg1 ifAbsent: arg2  ^properties detect: [:arg3 |  arg3 isKindOf: arg1 ] ifNone: arg2isBasedOn: arg1  ^basisObjects includes: arg1build  dropList := self theme newDropListIn: World for: self list: #scopeNames getSelected: #currentScopeIndex setSelected: #currentScopeIndex: getEnabled: nil useIndex: true help: self currentScope description.  self addMorph: dropListinitiateUIChangeBy: arg1  changesWasInitiatedByUser ifFalse: [ ^arg1 value ].  changesWasInitiatedByUser := false.  arg1 ensure: [ changesWasInitiatedByUser := true ]fillStatusBar  | tmp1 |  super fillStatusBar.  tmp1 := statusBar addContextItem: (ClyCursorPositionLabelMorph of: textMorph).  tmp1 comeToFront.  statusBar addCommandItem: (ClyTextWrapModeSwitchMorph of: textMorph).  statusBar addCommandItem: (ClyTextLineNumbersSwitchMorph of: textMorph).  statusBar addCommandItem: (ClyFormatAsReadSwitchMorph of: textMorph).  statusBar addCommandItem: (ClyMethodTagsAndPackageEditorMorph for: self)extensionMethod2FromClass9  pattern  ^patternpriority  ^100registerProjectManager: arg1  arg1 systemEnvironment: self.  projectManager registerProjectManager: arg1createQuery  ^ClyAllMethodsQuery from: ClyClassScope of: Object in: environmentdefaultHeight  ^30allProcesses  ^Process allSubInstancesshowMethodTag: arg1  tool selectMethodGroupNamed: arg1update  self dataSource forceFullUpdatetestExpandedDataSourceIsClosed  | tmp1 |  self selectedItem expand.  self snapshotState.  tmp1 := navigationState dataSource expandedItems first.  self assert: tmp1 childrenDataSource isClosedtestFastQueryShouldBeSync  query passExecution.  queryResult rebuild.  self assert: queryResult isBuilt.  self assert: queryResult buildProcess isNiltestClassEnumerationOverMetaClass  | tmp1 |  scope := ClySubclassScope of: ClyClass1FromP1 class.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := ClyClass1FromP1 allSubclasses collect: #classSide.  self assert: result asSet equals: tmp1 asSetasLocalClassScope  self subclassResponsibilityselectors: arg1  selectors := arg1assertItems: arg1 withValue: arg2  | tmp1 tmp2 tmp3 |  items := queryResult items.  self assert: queryResult size equals: arg1 size / 2.  tmp1 := 1.  arg1 pairsDo: [:arg3 :arg4 |  tmp2 := items at: tmp1.        tmp3 := arg2 value: tmp2.        self assert: tmp3 equals: arg3.        self assert: tmp2 depth equals: arg4.        tmp1 := tmp1 + 1 ]initialize  super initialize.  decorators := OrderedCollection new.  isManagedByUser := false.  isDirty := false.  self     changeTableLayout;     listDirection: #topToBottom;     hResizing: #spaceFill;     vResizing: #spaceFillchooseClassForEditorOfMethod: arg1  | tmp1 |  self classSelection isSingleSelected ifTrue: [ tmp1 := self classSelection lastSelectedItem actualObject.        ^self currentMetaLevelOf: tmp1 ].  ^arg1 originnavigationEnvironment: arg1  navigationEnvironment := arg1testComparisonWithAnotherFilter  | tmp1 |  filter := ClyItemNameFilter substringPattern: 'filter'.  tmp1 := ClyItemNameFilter substringPattern: 'filter'.  self assert: filter equals: tmp1.  self assert: filter hash equals: tmp1 hash.  tmp1 := ClyItemNameFilter substringPattern: 'filter2'.  self deny: filter equals: tmp1execute  testItems do: [:arg1 |  self runTestItem: arg1 ]= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^requiredResult = arg1 requiredResult and: [ scope = arg1 scope ]initialize  super initialize.  isForScripting := falsebuildGroupsFrom: arg1  | tmp1 tmp2 |  tmp1 := self createMethodQueryFrom: arg1.  (self shouldBuildGroupWith: tmp1) ifFalse: [ ^#() ].  tmp2 := self createMethodGroupFor: tmp1 from: arg1.  tmp1 isAsync ifTrue: [ tmp2 := tmp2 asAsyncQueryGroup ].  ^Array with: tmp2isClassScriptSelected  ^self isMethodSelected and: [ (self lastSelectedObjectIn: self selectedMethodItems) hasProperty: ClyClassScriptProperty ]editingClass: arg1  editingClass := arg1testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(reader1OfVar1 reader2OfVar1 supeclassReaderOfVar1)testCreationOnSingleSubscopeOfMultipleObjects  | tmp1 |  tmp1 := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {tmp1}.  self assert: scope basisObjects asSet equals: tmp1 basisObjects asSetreferencesTo: arg1  | tmp1 tmp2 |  tmp1 := self modelCurrentSelectedClass.  tmp1 isBehavior ifTrue: [ tmp1 slotNamed: arg1 ifFound: [:arg2 |  tmp2 := ClyInstanceVariable on: arg2 visibleFrom: tmp1.              ^self browser spawnQueryBrowserOn: (ClyVariableReferencesQuery of: tmp2) ] ].  self browser browseReferencesTo: arg1 asSymbol from: tmp1description  ^'methods sources with ' , pattern value printStringensureVisibleSelection  self selection isEmpty ifFalse: [ ^self ].  UIManager default defer: [ self selection ensureVisibleLastItem ]isFromScopeWithClassKindOf: arg1  scope classesDo: [:arg2 |  (arg2 includesBehavior: arg1) ifTrue: [ ^true ] ].  ^falsetestAscending  function := ClySortItemGroupFunction ascending.  self assert: (function value: (ClyItemGroup named: 'group1' priority: 20) value: (ClyItemGroup named: 'group2' priority: 10)).  self deny: (function value: (ClyItemGroup named: 'group1' priority: 10) value: (ClyItemGroup named: 'group2' priority: 20)).  self deny: (function value: (ClyItemGroup named: 'group2') value: (ClyItemGroup named: 'group1')).  self assert: (function value: (ClyItemGroup named: 'group1') value: (ClyItemGroup named: 'group2'))prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  script := arg1 selectedClassScript.  targetClass := arg1 selectedClasses detect: [:arg2 |  script isImplementedByClass: arg2 ] ifNone: [ script implementorClass ]iconForSpotterMenu  ^self iconNameForSpotterMenu ifNotNil: [:arg1 |  Smalltalk ui iconNamed: arg1 ]rewriteASTToSimulateExecutionInADifferentContext: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp4 := RBParseTreeRewriter new.  tmp1 := arg1 doSemanticAnalysis.  tmp4 replace: (RBVariableNode named: #ThisContext) name with: '(ThisContext lookupSymbol: #' , (RBVariableNode named: #ThisContext) name , ')'.  tmp6 := tmp1 allChildren select: [:arg2 |  arg2 isMessage ].  tmp7 := self parserClass parseExpression: 'ThisContext receiver class superclass'.  tmp6 do: [:arg3 |  arg3 receiver class = RBSuperNode ifTrue: [ tmp4 replaceTree: arg3 withTree: (RBMessageNode receiver: (self parserClass parseExpression: 'ThisContext receiver') selector: #perform:withArguments:inSuperclass: arguments: {(RBLiteralValueNode value: arg3 selector) .                           (RBArrayNode statements: arg3 arguments) .                           tmp7}) ] ].  tmp8 := tmp4     executeTree: tmp1;     tree.  tmp9 := tmp8 doSemanticAnalysis.  tmp10 := RBParseTreeRewriter new.  tmp2 := tmp9 allChildren select: [:arg2 |  arg2 isVariable and: [ arg2 isUndeclared ] ].  tmp3 := (tmp2 collect: [:arg4 |  arg4 name ]) asSet asArray.  tmp3 withIndexDo: [:arg5 :arg6 |  tmp10 replace: arg5 with: '(ThisContext lookupSymbol: #' , arg5 , ')' ].  tmp10 replace: 'thisContext' with: 'ThisContext'.  tmp10 replace: 'self' with: 'ThisContext receiver'.  tmp5 := tmp10     executeTree: tmp9;     tree.  ^tmp5 doSemanticAnalysissimpleNameForSpotterMenu  ^'Class editor: ' , self editingClass nameextraParameter: arg1  extraParameter := arg1initializeForBrowserStateSpanshot  | tmp1 |  super initializeForBrowserStateSpanshot.  tmp1 := collapsedItems collect: [:arg1 |  arg1 copyForBrowserStateSnapshotOf: self ].  collapsedItems := tmp1 asSortedCollection: [:arg2 :arg3 |  arg2 position < arg3 position ]findObjectsSameAsFilter  itemsView dataSource numberOfRows = 1 ifTrue: [ ^itemsView dataSource allElements collect: #actualObject ].  ^itemsView findItemsSameAsFilter ifNotEmpty: [:arg1 |  arg1 collect: #actualObject ]isResult: arg1 affectedBy: arg2  | tmp1 |  (scope includesMethodGroupsAffectedBy: arg2) ifTrue: [ ^true ].  (arg2 isKindOf: ClyAsyncQueryIsDone) ifTrue: [ tmp1 := arg1 items select: [:arg3 |  arg3 isKindOf: ClyAsyncMethodGroup ].        (tmp1 anySatisfy: [:arg3 |  arg3 asyncQueryResult == arg2 queryResult ]) ifTrue: [ ^true ] ].  ^falsedecorateResultMethodEditor: arg1  arg1 selectAnyString: {pattern value}toString: arg1  ^arg1 nameupdateDefaultPackageFilter  DefaultPackageFilter := packageView filterField getText ifEmpty: [ nil ]selectsMethod: arg1  ^arg1 isDeprecatedexecute  browser switchToHierarchicalResultbuildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope packagesDo: [:arg2 |  tmp1 add: arg2 ].  arg1 fillWith: tmp1allChildrenOf: arg1 do: arg2  | tmp1 |  tmp1 := parentMap at: arg1 ifAbsent: [ ^self ].  tmp1 do: [:arg3 |  arg2 value: arg3.        self allChildrenOf: arg3 do: arg2 ]passExecution  executionSemaphore signalbuildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope classesDo: [:arg2 |  tmp1 addAll: (self methodsToImplementIn: arg2) ].  arg1 fillWith: tmp1testComparisonWithResultWithSameHierarchyAbdSortFunction  | tmp1 |  tmp1 := queryResult sortedBy: queryResult hierarchy sortFunction.  self assert: queryResult equals: tmp1.  self assert: queryResult hash equals: tmp1 hashinitialize  super initialize.  critiqueQuery := ClyAllMethodCritiqueQuery new= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^methodQuery = arg1 methodQuery and: [ subgroupsQuery = arg1 subgroupsQuery ]order  ^50000prepareStateBeforeExecution  super prepareStateBeforeExecution.  self specialSelectorIndexesprintCriteria  ^pattern valuetestNotSelectsMethodWithoutFlag  self deny: (query selectsMethod: ClyClassWithFlags >> #methodWithoutFlag)createMethodQueryFrom: arg1  ^ClyDeprecatedMethodsQuery from: arg1printContext  package ifNil: [ ^super printContext ].  classTag ifNil: [ ^package name ].  ^package name , ' / ' , classTagselectsMethod: arg1  ^arg1 sendsAnySelectorOf: #(flag:)selectsMethod: arg1  ^arg1 isFFIMethodreferenceOfAnotherClass  ^PointtestCheckIfEmpty  query scope: (ClyClassScope of: ClyClass2FromP1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ProtoObject in: environment).  self assert: query checkEmptyResultsetUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyInheritanceAnalysisEnvironmentPlugin neworderForBrowser  ^2collectMetadataOf: arg1 by: arg2  self subclassResponsibilityforBrowserItems  ^ClySortBrowserItemFunction with: selfprintVariables  ^variableQuery scope == scope ifTrue: [ variableQuery description ] ifFalse: [ variableQuery fullDescription ]asRefactorings  ^targetClass deprecationRefactoringsasLocalClassScope  ^selfisValidClass: arg1  ^(arg1 isTestCase or: [ arg1 isMeta ]) notmarkWithChildrenOf: arg1  self addProperty: (ClyItemChildrenTag childrenType: arg1)hasPluginOf: arg1  ^plugins anySatisfy: [:arg2 |  arg2 class = arg1 ]treeStructure  ^treeStructureupdateItemCache  isClassTagSelected  ^falseselectedItems  ^selectedItemstestFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector)checkEmptyResult  self analyzedObjectsDo: [:arg1 |  arg1 critiques ifNotEmpty: [ ^false ] ].  ^trueisPackageSelected: arg1  ^self packageSelection includesActualObject: arg1type: arg1  type := arg1initializeForBrowserStateSpanshot  | tmp1 |  super initializeForBrowserStateSpanshot.  tmp1 := expandedItems collect: [:arg1 |  arg1 copyForBrowserStateSnapshotOf: self ].  expandedItems := tmp1 asSortedCollection: [:arg2 :arg3 |  arg2 position < arg3 position ]hasSubscriber: arg1  ^actualResult hasSubscriber: arg1undoList  ^undoListabstractMethod2  self subclassResponsibilitytestMethodsEnumerationWhenBasisIsClass  | tmp1 |  scope := ClyClassSideScope of: ClyClass1FromP1.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClass1FromP1 classSide localMethods collect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArrayaffectsMethodsDefinedInClass: arg1  ^overridingSubclass inheritsFrom: arg1 instanceSidetestFromClassWhichTraitIsExtendedButNotItself  < expectedFailure>  self queryFromScope: ClyClassScope of: ClyClassWithTraits.  self assert: resultItems size equals: 0methodWithCritiques  ^ClyClassWithProblemMethods >> #methodWithHaltcopy  | tmp1 |  tmp1 := super copy.  type prepareCalypsoItemCopy: tmp1.  ^tmp1hasProperty: arg1  ^browserItem hasProperty: arg1defaultMenuIcon  ^Smalltalk ui iconNamed: script iconNamesetUp  super setUp.  environment := ClyNavigationEnvironment overSystemEnvironment: ClySystemEnvironment currentImage.  environment detachFromSystem.  browser := self createBrowser.  browser navigationEnvironment: environment.  browser plugins removeAllinstanceSideClassVar1Writer  ClassVar1 := #classVar1ValuespotterPreviewCodeIn: arg1  < spotterPreview: 10>  ^targetView spotterPreviewMorphIn: arg1classes: arg1  classes := arg1 asIdentitySetenableFilter: arg1 using: arg2  self enableFilterWithFactory: (ClyTableFilterFactory of: arg1 using: arg2)testComparisonToSimilarQueryWithDifferentTag  | tmp1 |  tmp1 := self createQuery.  tmp1 tag: #AnotherTag1.  self deny: query equals: tmp1readParametersFromContext: arg1  super readParametersFromContext: arg1.  commitModel := arg1 itembrowserContextWasChanged  self warnUserAboutChangedContext.  self rebuildStatusBarcheckEmptyResult  scope classesDo: [:arg1 |  (arg1 isTestCase and: [ arg1 isAbstract not and: [ arg1 hasFailedTest or: [ arg1 hasErrorTest ] ] ]) ifTrue: [ ^false ] ].  ^truehasIconOrMarker  ^trueapplyResultInContext: arg1  super applyResultInContext: arg1.  arg1 showPackage: package atClassTag: newNameswitchToFlatResult  DefaultQueryResult := self defaultFlatQueryResult.  self switchResultTo: expectedFlatQueryResultprojectChildrenSelection  ^packageView selection asSelectedParentsOf: ClyProjectChildItemcheckItemsOfCurrentSelection: arg1  | tmp1 |  isSameAsCurrent := false.  tmp1 := arg1 items.  tmp1 size = items size ifFalse: [ ^self ].  tmp1 do: [:arg2 |  items do: [:arg3 |  (arg2 isSameAs: arg3) ifFalse: [ ^self ] ] ].  isSameAsCurrent := truecreateQuery  ^ClyClassReferencesQuery to: self referencedClass from: (ClyClassScope of: Object in: environment)printBasisObject: arg1 on: arg2  ^arg2 nextPutAll: arg1 nameareItemsLoaded  ^(self dataSource hasMetaProperty: ClyBackgroundProcessingTag) notsubqueryFromScope: arg1 of: arg2  ^self subqueryFromScope: (arg1 of: arg2)decorateMainTableCell: arg1 of: arg2  | tmp1 |  tmp1 := ClyContextSelectionStrategy selectContextOfSingleItem: arg2 for: browser.  ClyTableDecorationStrategy activeInstancesInContext: tmp1 do: [:arg3 |  arg3 decorateMainTableCell: arg1 inContext: tmp1 ]collate: arg1 with: arg2  | tmp1 |  arg1 calypsoEnvironmentType = arg2 calypsoEnvironmentType ifTrue: [ tmp1 := self sortFunctionFor: arg1.        ^tmp1 collate: arg1 with: arg2 ].  ^arg1 calypsoEnvironmentType itemsSortOrderForCalypso threeWayCompareTo: arg2 calypsoEnvironmentType itemsSortOrderForCalypsowantsStayInDifferentContext  ^super wantsStayInDifferentContext | applyingChangescontext: arg1  context := arg1testMethodsEnumerationOverMetaclassWhenBothMetaLevelsAreLocalScope  | tmp1 |  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:arg1 |  result add: arg1 ].  tmp1 := {Object .   Object class .   ProtoObject .   ProtoObject class} flatCollect: #localMethods as: IdentitySet.  self assert: result asIdentitySet equals: tmp1collapsedItems  ^collapsedItemsscopeClass  ^ClyTraitUserScopequeryResult  ^queryResultinitialize  super initialize.  self     changeTableLayout;     listDirection: #leftToRight;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     cellInset: 4testResult: arg1  testResult := arg1queryResult: arg1  queryResult := arg1buildParentMap: arg1 for: arg2  | tmp1 tmp2 |  tmp1 := arg2.  [ tmp1 isRootInEnvironment ] whileFalse: [ tmp2 := tmp1 superclass.        (arg1 includesClass: tmp2) ifTrue: [ ^arg1 addChild: arg2 to: tmp2 ].        tmp1 := tmp2 ]attachToSystem  environment system subscribe: self for: MCPackageModifiedsetWindowTitle: arg1 in: arg2  arg2 setLabel: arg1testCheckEmptyQueryWhenThereIsNotEmptyResult  | tmp1 tmp2 |  tmp1 := self createQueryFromScopeOf: self class.  tmp2 := environment query: tmp1.  self assert: tmp2 items notEmpty.  self deny: (environment isQueryEmpty: tmp1)defaultColor  ^Color transparentdefaultMenuIconName  ^#removeIcontestComparison  | tmp1 tmp2 |  tmp1 := ClySubstringPattern with: 'subString' caseSensitive: true.  tmp2 := ClySubstringPattern with: 'subString' copy caseSensitive: true.  self assert: tmp1 equals: tmp2.  self assert: tmp1 hash equals: tmp2 hash.  tmp2 value: 'another pattern'.  self deny: tmp1 equals: tmp2.  tmp2 value: tmp1 value.  tmp2 isCaseSensitive: tmp1 isCaseSensitive not.  self deny: tmp1 equals: tmp2reference2OfClass  ^ClyClassReferencesQueryTestactualResult  ^actualResulttestIsAffectedByChangeOfOwnMethodWhichIsNotOverridden  query := ClyOverriddenMethodsQuery from: ClyClassScope of: ClyClassWhichInheritsAbstractClass in: environment.  self assert: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)referencedSelector  ^'clyReferencedMessage1' asSymbolisSelectedClassUsesTraits  | tmp1 |  tmp1 := self lastSelectedObjectIn: self selectedClassItems.  ^tmp1 isMarkedWith: ClyTraitUserTagsortFunction: arg1  sortFunction := arg1defaultFlatQueryResult  ^ClySortedQueryResult using: ClySortSystemItemFunction ascendingtestConvertingWithNewScopeWhenAllSubqueriesAreSameKind  | tmp1 tmp2 |  query subqueries: {(self subqueryFromScope: ClyScopeExample of: Array) .         (self subqueryFromScope: ClyScopeExample2 of: String)}.  tmp1 := ClyScopeExample2 of: #someBasis in: environment.  tmp2 := query withScope: tmp1.  self assert: tmp2 class equals: query subqueries anyOne class.  self assert: tmp2 scope equals: tmp1.  self assert: tmp2 requiredResult identicalTo: query requiredResulttestFillingWithClassWithoutTraits  queryResult fillWith: {ClyClassWithoutTraits}.  self assertItems: {ClyClassWithoutTraits .         0}createMethodGroupFor: arg1 from: arg2  self subclassResponsibilitymessages  ^messagestoggleMode: arg1  self executeCommandevaluate  | tmp1 tmp2 tmp3 |  tmp1 := RGChunkImporter new.  tmp1 fileInFrom: (definitionString , '!') readStream.  tmp2 := tmp1 environment ask behaviors detect: [:arg1 |  arg1 isRingResolved and: [ arg1 superclass isRingResolved ] ].  tmp1 := RGChunkImporter new.  tmp1 environment: environment.  tmp1 fileInFrom: (definitionString , '!') readStream.  tmp3 := environment ask behaviorNamed: tmp2 name.  tmp3 superclass metaclass metaclass isRingResolved ifTrue: [ environment cleanWithMetaclassNamed: tmp3 superclass metaclass metaclass name ].  ^tmp3singleBasisSample  ^super singleBasisSample classSidegetProperty: arg1  ^properties detect: [:arg2 |  arg2 isKindOf: arg1 ]initialize  super initialize.  baseCritiqueQuery := ClyAllBasisCritiqueQuery newinverted  ^self copy inverse: inverse notbelongsToCurrentBrowserContext  ^truedoesClassDefinedAsAbstract: arg1  ^(arg1 classSide includesLocalSelector: #isAbstract) and: [ arg1 instanceSide isAbstract ]testFromWrongClassScope  self queryFromScope: ClyClassScope of: self class superclass.  self assert: resultItems isEmptysetUp  super setUp.  query := self createQueryisForbidden  ^annotatedClass isAbstractcriticView  ^criticViewsubscopes  ^subscopestestConvertingWithNewBasisObjectsWhenThereIsExtraScopeParameter  | tmp1 |  scope := self singleScopeSample.  scope extraParameter: #testParameter.  tmp1 := scope withNewBasisObjects: {self extraBasisSample}.  self assert: tmp1 extraParameter equals: #testParameterdecorateBrowserItem: arg1 ofClass: arg2  (arg2 isTestCase not or: [ arg2 isAbstract ]) ifTrue: [ ^self ].  arg1 addProperty: (ClyTestResultProperty ofTestCase: arg2)isBuilt  ^super isBuilt and: [ (self hasMetaProperty: ClyBackgroundProcessingTag) not ]testConvertingToReducedScopeByExtraClassScope  | tmp1 tmp2 tmp3 |  scope := self multipleScopeSample.  tmp2 := ClySuperclassScope of: self class in: environment.  tmp3 := scope increasedByClassesFrom: tmp2.  tmp1 := tmp3 reducedByClassesFrom: tmp2.  self assert: tmp1 class equals: scope class.  self assert: tmp1 basisObjects equals: (scope basisObjects collect: #instanceSide)initialize  super initialize.  self changeTableLayout.  self initializeTable.  self whenDoubleClickDo: [ self triggerDoubleClickCommands ].  shouldRestoreSelection := true.  changesWasInitiatedByUser := true.  treeStructure := #().  self setUpDataSource: ClyDataSource emptydefaultResult  ^ClyRawQueryResult newitemCount  ^resultView itemCountcreateQueryResult  ^ClySortedQueryResult using: ClySortByNameFunction ascendingselectsMethod: arg1  selectors with: self specialSelectorIndexes do: [:arg2 :arg3 |  (arg1 hasSelector: arg2 specialSelectorIndex: arg3) ifTrue: [ ^true ] ].  ^falseimportMethod: arg1  cancelChanges  self updateMethodTagsAndPackage.  super cancelChangesaddMetaProperty: arg1  self metadata addProperty: arg1classSampleWhichHasGroup  ^ClyTestedClassTestorder  ^1.5description  ^'extension methods'activationPriority  ^self tabOrderinitializeToolsPanel  toolbar := ClyToolbarMorph of: self.  tabManager := ClyTabManager of: self.  toolPanel := PanelMorph new.  toolPanel name: 'tools panel'.  toolPanel     changeTableLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     listDirection: #topToBottom.  self addMorph: toolPanel fullFrame: ((0.0 @ 0.5 corner: 1.0 @ 1.0) asLayoutFrame topOffset: toolbar height negated).  toolPanel addMorphBack: toolbar.  toolPanel addMorphBack: tabManager tabMorphtestClassGroupEnumeration  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new.  scope := ClyPackageScope of: ClyClass7WithTag1FromP5 package in: environment.  scope classGroupsDo: [:arg1 |  result add: arg1 ].  self assert: (result collect: #class as: Set) equals: {ClyNoTagClassGroup .         ClyTaggedClassGroup .         ClyClassGroup} asSet.  self assert: (result select: [:arg1 |  arg1 class = ClyTaggedClassGroup ] thenCollect: #tag) sorted asArray equals: ClyClass7WithTag1FromP5 package tagsForClasses sorted asArraytoggle  [ ownerTool toggleExtendingPackage ] on: CmdCommandAborted do: [:arg1 |   ].  checkbox updateLabelsetUp  super setUp.  installedBreakpoints := OrderedCollection newtestExpandedDataSourceWithoutQueryView  | tmp1 |  self selectedItem expand.  self snapshotState.  tmp1 := navigationState dataSource expandedItems first.  self assert: tmp1 childrenDataSource queryView isNilclassSampleWhichHasGroup  ^ClyMethodWatchpointsQueryTestasync  ^ClyAsyncQuery for: selfcreateQuery  ^ClyAllBasisCritiqueQuery from: self scopeWithCritiquesrestoreBrowserInstance  self snapshotState.  navigationState applyTo: browsername  ^name ifNil: [ self defaultName ]testClassVarsEnumerationFromClassSideOfDefiningClass  scope := ClyClassScope of: Object class.  scope classVariablesDo: [:arg1 |  result add: arg1 ].  self assert: result size equals: 1.  self assert: result anyOne equals: (ClyClassVariable on: Object classVariables first definedIn: Object)testConvertingToSemiAsyncQuery  | tmp1 |  tmp1 := query semiAsync.  self assert: tmp1 class equals: ClyAsyncQuery.  self assert: tmp1 actualQuery identicalTo: query.  self assert: tmp1 requiredResult identicalTo: query requiredResult.  self assert: tmp1 scope identicalTo: query scope.  self assert: tmp1 asyncResult class equals: ClySemiAsyncQueryResultenableFilter  self enableFilter: ClyItemNameFilterprepareDefaultState  self prepareInitialStatepackages  ^packagestestFillingWithClassAndItsTraitsWhenSomeMiddleTraitIsMissing  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitRoot1 .         2}switchToMetaLevelScope: arg1  metaLevelScope = arg1 ifTrue: [ ^self ].  self changeMethodGroupQueryBy: [ metaLevelScope := arg1.        methodGroupQuery withMetaLevelScope: metaLevelScope ]singleBasisSample  ^#singleBasis= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^variableQuery = arg1 variableQuerytestClassEnumerationWhenMetaClassIsBasis  scope := ClyBothMetaLevelClassScope of: ClyClass1FromP1 class.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: {ClyClass1FromP1}testDetectingSpecialSelectorLikeIfTrue  query := ClyMessageSendersQuery of: #ifTrue:.  self queryFromScope: ClyMethodScope of: self class >> #senderOfIfTrue.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #senderOfIfTruewarnUserAboutDifferentContext  containerTab icon: (self iconNamed: #uncommentedClass)methodTags: arg1  methodTags := arg1.  extendingPackage := nilbuildTextMorph  textModel := RubScrolledTextModel new.  textModel interactionModel: self.  textMorph := textModel newScrolledText.  textMorph     width: self width;     beWrapped;     font: StandardFonts codeFont;     editingMode: self editingMode.  CmdKMDispatcher attachedTo: textMorph textArea withCommandsFrom: self.  self buildLeftSideBar.  textModel setInitialText: self editingTexttestNotBasedOnMultipleBasisWhenAllSubscopesHaveEmptyBasis  | tmp1 tmp2 |  tmp1 := ClyScopeExample emptyIn: environment.  tmp2 := ClyScopeExample emptyIn: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self deny: scope isBasedOnMultipleBasiscriticAnalysisScope  ^ClyMethodScope of: editingMethod in: browser navigationEnvironmentasRBEnvironment  ^RBClassEnvironment classes: self collectAllClassesasDesiredSelection  | tmp1 |  tmp1 := items collect: [:arg1 |  arg1 copy childrenDataSource: nil ].  ^ClyDesiredSelection fromRoot: rootDataSource items: tmp1buildToolsOn: arg1 for: arg2  | tmp1 |  ClyTabActivationStrategy activeInstancesInContext: arg2 do: [:arg3 |  tmp1 := arg3 createToolFor: browser inContext: arg2.        browser decorateTool: tmp1.        arg1 add: tmp1 ]collectMetadataOfClassGroups: arg1  sortFunction: arg1  super sortFunction: arg1.  mergedParts do: [:arg2 |  arg2 sortFunction: arg1 ]description  ^String streamContents: [:arg1 |  self printDescriptionOn: arg1 ]requestSingleClass: arg1 from: arg2  ^tool searchDialog requestSingleObject: arg1 from: ClyAllClassesQuery hierarchical inScope: (ClyClassScope ofAll: arg2)overrideItemDepthByDelta: arg1  ^itemDepth := item depth + arg1asGoToSpotterCandidate  ^ClyGoToSpotterCandidate target: self named: self simpleNameForSpotterMenu icon: self defaultIcon using: [ self           selectAsMainTab;           takeKeyboardFocus ]enableFilterWithFactory: arg1  table     enableFilter: arg1;     explicitFunctiondescription  ^'failed tests'localHierarchySize: arg1  arg1 = 0 ifTrue: [ ^self ].  self addProperty: (ClyItemLocalHierarchyProperty size: arg1)mainNameOf: arg1  arg1 type = ClyClass ifTrue: [ ^'' ].  ^arg1 nameupdateTextAreaWhenPlugged  super updateTextAreaWhenPlugged.  isForScripting ifTrue: [ self textArea shoutStyler beForSmalltalkScripting ]testItemsInitialization  queryResult initializeItems.  self assert: queryResult items notNilasFullHierarchyScope  | tmp1 tmp2 |  tmp1 := self asScope: ClySubclassScope.  tmp2 := self withInheritedScope , tmp1.  tmp2 name: self class hierarchyScopeName.  ^tmp2createQuery  ^ClyActiveBreakpointsQuery from: ClyClassScope of: ClyClassWithHalts in: environmentexecute  browser switchToFlatResulttestConvertingToNewMetaLevel  | tmp1 |  scope := self createSampleScope.  self deny: scope localScopeClass equals: ClyInstanceSideScope.  tmp1 := scope withMetaLevel: ClyInstanceSideScope.  self assert: tmp1 class equals: scope class.  self assert: tmp1 localScopeClass equals: ClyInstanceSideScope.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 environment equals: environmentinitializeNavigationPanel  | tmp1 tmp2 |  navigationPanel := PanelMorph new.  navigationPanel name: 'navigation panel'.  navigationPanel changeProportionalLayout.  navigationViews := OrderedCollection new.  self initializeNavigationViews.  tmp1 := 1.0 / navigationViews size.  tmp2 := 0.0.  navigationViews do: [:arg1 |  | tmp3 |        tmp3 := (tmp2 @ 0.0 corner: (tmp2 + tmp1) @ 1.0) asLayoutFrame.        arg1 == navigationViews last ifFalse: [ tmp3 := tmp3 rightOffset: -4 ].        navigationPanel addMorph: arg1 fullFrame: tmp3.        tmp2 := tmp2 + tmp1 ].  navigationPanel addPaneSplitters.  self addMorph: navigationPanel fullFrame: ((0.0 @ 0 corner: 1.0 @ 0.5) asLayoutFrame bottomOffset: toolbar height negated)setUp  super setUp.  installedWatchpoint := ClyMethodWatchpointsQueryTest new     setUp;     installWatchpointInto: #methodWithWatchpointtestNotBasedOnSingleBasisWhenTwoSubscopesAreBasedOnSingleButDifferentObject  | tmp1 tmp2 |  tmp1 := ClyScopeExample of: #basisObject1 in: environment.  tmp2 := ClyScopeExample of: #basisObject2 in: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self deny: scope isBasedOnSingleBasiscreateQuery  ^ClyClassCommentsQuery withString: self expectedClassCommentSubstring from: (ClyPackageScope of: Object package in: environment)createQueryResult  ^(ClySubclassHierarchy new , ClyTraitUserHierarchy inverse) asQueryResult sortedBy: ClyTraitFirstSortFunction ascendingprepareExecutionInDropContext: arg1  super prepareExecutionInDropContext: arg1.  targetClass := arg1 lastSelectedClass.  targetClass := arg1 currentMetaLevelOf: targetClassdecorateMethodGroupTableCell: arg1 of: arg2  arg1 addExtraIcon: #traittestIsBasedOnEmptyBasis  scope := self createSampleScope.  self assert: scope isBasedOnEmptyBasisprintCriteria  ^self printStringexecute  | tmp1 tmp2 tmp3 |  tmp2 := repositoryModel commit.  tmp1 := RGEnvironment new.  tmp2 packageNames do: [:arg1 |  tmp3 := tmp2 snapshotFor: (RPackage named: arg1).        tmp3 importInto: tmp1 asPackageNamed: arg1 ] displayingProgress: 'loading'.  tmp1 clean.  tmp1 browseAs: repositoryModel entity descriptionexecute  | tmp1 |  tmp1 := messages collect: [:arg1 |  arg1 selector ].  browser spawnQueryBrowserOn: (ClyMessageSendersQuery ofAny: tmp1)simpleNameForSpotterMenu  ^'Packages'createMethodQueryFrom: arg1  ^ClyUnclassifiedMethodsQuery from: arg1kmDispatcher  ^CmdKMDispatcher attachedTo: selftestRestoredBrowserInstanceWithActiveScope  browser activeScope: browser queryScopes last.  self restoreBrowserInstance.  self assert: browser activeScope equals: browser queryScopes lastmetaLevelScope  ^metaLevelScopegetPlugin: arg1 ifAbsent: arg2  ^plugins detect: [:arg3 |  arg3 class = arg1 ] ifNone: arg2defaultMenuIconName  ^#jumpscope: arg1  arg1 isBoundToEnvironment ifFalse: [ ^self error: 'Query should be always initialized with scope bound to concrete environment' ].  (arg1 supportsQuery: self) ifFalse: [ self error: 'Given scope do not support given query! Try use #adoptQuery:' ].  scope := arg1isSimilarTo: arg1  (super isSimilarTo: arg1) ifFalse: [ ^false ].  ^editingClass = arg1 editingClassname  ^name ifNil: [ super printString ]printMethodTags  ^', ' join: ownerTool methodTagsprepareInitialState  methodGroupQuery := ClyAllMethodGroupsQuery sortedFrom: (metaLevelScope emptyIn: navigationEnvironment).  self switchToPackagesdescription  ^'(Re)initialize class'description  ^'active breakpoints'testNotSelectsMethodWithoutBreakpoint  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  self deny: (query selectsMethod: ClyClassWithBreakpoints >> #methodWithoutBreakpoints)execute  testItems do: [:arg1 |  self runPackageTests: arg1 actualObject ]setUpAvailablePlugins  ClyEnvironmentPlugin allSubclasses select: [:arg1 |  arg1 isAutoActivatedOn: self ] thenDo: [:arg1 |  self addPlugin: arg1 new ]createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'watchpoints' priority: 8.4 on: arg1dropElements: arg1 index: arg2  | tmp1 |  tmp1 := self elementAt: arg2.  ^queryView dropPassenger: arg1 at: tmp1rootsDo: arg1  self containerForChildren     addAll: roots;     do: arg1testPackageEnumeration  scope := ClyPackageExtensionScope ofAll: {Array package .         Object package}.  scope packagesDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: {Array package .         Object package}decorateBrowserItem: arg1 ofClassGroup: arg2  arg2 decorateOwnBrowserItem: arg1= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^mergedParts = mergedPartsrequestMultipleVariables: arg1 from: arg2  ^tool searchDialog requestMultipleObjects: arg1 from: ClyAllInstanceVariablesQuery sorted inScope: (ClyClassScope ofAll: arg2) withInheritedScoperepresentsBrowserItems  ^falsetestCheckIfEmpty  query scope: (ClyMethodScope of: ClySubclassLOfClass0FromPExtendedByP1 >> #extensionMethodFromSubclassL in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClass9FromPExtendedByP5 >> #extensionMethodFromClass9 in: environment).  self assert: query checkEmptyResultpackageSampleWhichHasGroup  self subclassResponsibilityallContexts  | tmp1 |  tmp1 := OrderedCollection new.  self allContextsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1classGroup  ^classGrouplastSelectedClass  ^self lastSelectedObjectIn: self selectedClassesadoptForNewCalypsoQuery  ^self copyscript  ^scriptisResult: arg1 affectedBy: arg2  (scope includesClassesAffectedBy: arg2) ifTrue: [ ^true ].  (scope canDetectAffectOnClassesBy: arg2) ifTrue: [ ^false ].  arg1 rawItemsDo: [:arg3 |  (arg2 affectsClass: arg3) ifTrue: [ ^true ] ].  ^falseisAffectedByChangedMethod: arg1  | tmp1 tmp2 |  tmp1 := arg1 selector.  tmp2 := arg1 origin.  scope classesDo: [:arg2 |  arg2 = tmp2 ifTrue: [ ^true ].        ((tmp2 inheritsFrom: arg2) and: [ arg2 includesLocalSelector: tmp1 ]) ifTrue: [ ^true ] ].  ^falsetestCheckIfEmpty  self assert: query hasEmptyResult.  self assert: query checkEmptyResultdefinitionIcon: arg1  | tmp1 |  tmp1 := self iconNamed: arg1.  ^self definitionMorph: tmp1 asMorphnavigationEnvironment: arg1  navigationEnvironment := arg1variableQuery: arg1  super variableQuery: (arg1 withResult: ClyClassBindings new)isClassVariable  ^falsedecorateMainTableCell: arg1 inContext: arg2  annotatedClass decorateMainTableCell: arg1 inContext: arg2selectedItems: arg1  selectedItems := arg1subscribe: arg1 for: arg2  self unsubscribe: arg1.  environment announcer when: arg2 send: #systemChanged: to: arg1buildParentMap: arg1 for: arg2  mergedParts do: [:arg3 |  arg1 hierarchy: arg3.        arg3 buildParentMap: arg1 for: arg2 ].  arg1 hierarchy: selfisCommandAvailable: arg1  ^arg1 canBeExecutedInMethodEditor: selftestSelectsMethodOnWhichItIsBased  self assert: (query selectsMethod: self class >> #method1)buildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope classGroupsDo: [:arg2 |  tmp1 add: arg2 ].  arg1 fillWith: tmp1testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithDeprecatedMethods >> #deprecatedMethod1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithDeprecatedMethods >> #notDeprecatedMethod in: environment).  self assert: query checkEmptyResultitemFilterClass  ^itemFilterClasstestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClass1FromP1 >> #tag1Method1) .         (Object >> #printString) .         (ClyClass2FromP1 >> #instanceSideClassVar1Reader)}.  self assert: foundSelectors equals: #(tag1Method1)asInheritedScope  ^ClyInheritedScopeProvider createInheritedScopeFrom: selfretrieveChildrenOf: arg1  | tmp1 tmp2 |  tmp1 := queryView queryToExpand: arg1 ifAbsent: [ self error: 'cant retrieve children from ' , arg1 printString ].  tmp2 := ClyCollapsedDataSource on: tmp1.  tmp2 openOn: queryView.  ^tmp2defaultMenuIcon  ^self testResult createIcontestFindItemsWithActualObjectsWhenTheyAreNotInCache  | tmp1 |  cursor cleanCache.  tmp1 := cursor findItemsWith: {#absentItem1 .         Array .         #absentItem2}.  self assert: tmp1 size equals: 3.  self assert: tmp1 first equals: nil.  self assert: tmp1 last equals: nil.  self assert: tmp1 second actualObject equals: Array.  self assert: tmp1 second isPrepared.  self assert: tmp1 second position equals: (self rawResultItems indexOf: Array)findItemsSimilarTo: arg1  | tmp1 tmp2 tmp3 |  actualResult protectItemsWhile: [ tmp1 := arg1 as: OrderedCollection.        tmp2 := OrderedCollection new.        actualResult items doWithIndex: [:arg2 :arg3 |  tmp3 := arg2 asCalypsoBrowserItem.              tmp1 detect: [:arg4 |  arg4 isSimilarTo: tmp3 ] ifFound: [:arg4 |  tmp3 position: arg3.                    tmp3 prepareIn: self environment.                    tmp2 add: tmp3.                    tmp1 remove: arg4.                    tmp1 ifEmpty: [ ^tmp2 ] ] ].        ^tmp2 ]tag1Method1  testMethodsEnumerationOverMetaclassWhenClassSideIsLocalScope  | tmp1 |  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassSideScope.  scope methodsDo: [:arg1 |  result add: arg1 ].  tmp1 := {Object class .   ProtoObject class} flatCollect: #localMethods as: IdentitySet.  self assert: result asIdentitySet equals: tmp1order  ^1hash  ^super hash bitXor: sortFunction hashbuildTextMorph  super buildTextMorph.  self formatTextIfNeededretrieveAll  ^queryResult allItemsdefaultMenuIcon  | tmp1 |  tmp1 := self testResult.  runTestCases do: [:arg1 |  tmp1 concreteResultOf: runTestCases first ifPresent: [:arg2 |  ^arg2 createIcon ] ].  ^tmp1 createIconretrievesItemsAs: arg1  ^requiredResult isKindOf: arg1scopeClass  ^ClyScopeExampleresetStateForSnapshot  super resetStateForSnapshot.  diffMorph := nilsubgroupsQuery  ^subgroupsQuerytestSelectsMethodWithCounter  self installCounterInto: #methodWithCounter.  self assert: (query selectsMethod: self class >> #methodWithCounter)value: arg1  value := arg1testCheckIfEmpty  query scope: (ClyClassScope of: ClyClass2FromP1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ProtoObject in: environment).  self assert: query checkEmptyResultqueryClass  ^self subclassResponsibilitytestCreationUnifiedInstance  self assert: query asUnifiedInstance identicalTo: queryincludesClassesAffectedBy: arg1  ^falseexecute  | tmp1 |  methodGroups do: [:arg1 |  tmp1 := SycMoveMethodsToClassCommand methods: arg1 methods class: targetClass.        tmp1 execute.        arg1 removeWithMethods ]printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  queryResult buildingQuery printOn: arg1.  arg1 nextPut: $)projectManager: arg1  projectManager := arg1testSelectedTabsWithoutContext  | tmp1 |  self snapshotState.  tmp1 := navigationState selectedTabs first.  self assert: tmp1 context isNilsomeNotDeprecatedMethod  asyncQueryResult: arg1  asyncQueryResult := arg1installedMethods  ^self filterInstalledMethods: methodsretrieveStateFrom: arg1  browserState := arg1 snapshotState.  (window := arg1 window) ifNotNil: [ windowGroup := window ownerThatIsA: GroupWindowMorph ].  browserPlugins := arg1 plugins collect: [:arg2 |  arg2 copy browser: nil ].  navigationEnvironment := arg1 navigationEnvironment.  navigationHistory := arg1 navigationHistorywithScope: arg1  | tmp1 |  tmp1 := self copy.  ^arg1 adoptQuery: tmp1testOpeningShouldSubscribeObserver  self assert: (queryResult hasSubscriber: itemObserver).  self assert: cursor itemObserver equals: itemObserverinitializeTable  table := FTTableMorph new.  table allowsDeselection: true.  table beMultipleSelection.  table beResizable.  table dragEnabled: true.  table dropEnabled: true.  table onAnnouncement: FTSelectionChanged send: #selectionChanged to: self.  table addColumn: ClyMainTableColumn default.  table vResizing: #spaceFill.  table hResizing: #spaceFill.  self addMorph: tabletestConvertingWithoutBasisObjectsWhenSomeIsNotExist  | tmp1 |  scope := self createSampleScope.  tmp1 := scope withoutBasisObjects: {#absentObject .         scope basisObjects anyOne}.  self assert: tmp1 class equals: scope class.  self deny: (tmp1 basisObjects includes: scope basisObjects anyOne)decorateBrowserItem: arg1 ofPackage: arg2  arg2 classes ifNotEmpty: [ arg1 markWithChildrenOf: ClyClass ].  (self checkPackageHasClassGroups: arg2) ifTrue: [ arg1 markWithChildrenOf: ClyClassGroup ]selectAnyString: arg1  textMorph setSelection: (self findAnyString: arg1 in: self pendingText)definitionMorph: arg1  definitionMorph := arg1.  definitionMorph width: 16.  ^definitionMorphwriterOfVar1  readVar1 := #testValueapplyResultInContext: arg1  super applyResultInContext: arg1.  browser rebuildToolbarexpand: arg1  queryView changeStateBy: [ collapsedItems remove: arg1.        self expansionChanged ]testSelectorOf: arg1  ^arg1 name asSymbolbrowser: arg1  browser := arg1attachToSystem  super attachToSystem.  environment system when: MethodAdded , MethodRemoved send: #processMethodChange: to: self.  environment system when: ClassRemoved send: #processClassRemoval: to: self.  environment system when: ClassModifiedClassDefinition send: #processClassDefinitionChange: to: self.  environment system when: ClassModificationApplied send: #processFullClassChange: to: selfisLive  ^falseparentItem  ^parentItemwithMetaLevelScope: arg1  ^self withScope: (scope withMetaLevel: arg1)isEmpty  ^undoList isEmpty and: [ redoList isEmpty ]selectedTabs: arg1  selectedTabs := arg1queryView  ^ownerDataSource queryViewimportMethod: arg1  arg1 tags do: [:arg2 |  arg1 untagFrom: arg2 ]whenDoubleClickDo: arg1  table onAnnouncement: FTStrongSelectionChanged do: arg1expectedClassCommentSubstring  ^'it should be in the comment of this class to test class comment query'createBrowserContextOfSingleItem: arg1 for: arg2  ^annotatedClass of: {arg1} for: arg2showQueryResult  self showsFlatResult ifTrue: [ expectedFlatQueryResult := systemQuery requiredResult ].  self setUpActiveScope.  resultView showQuery: systemQuery semiAsyncshowItemsOf: arg1  | tmp1 |  tmp1 := arg1 isBoundToEnvironment ifTrue: [ arg1 ] ifFalse: [ arg1 withScope: browser systemScope ].  itemsView showQuery: tmp1 semiAsync.  itemsView adoptForDialogattachToSystem  system subscribe: self.  plugins do: [:arg1 |  arg1 attachToSystem ]systemDefinitionClass  ^self systemDefinition definingClassdecorateTableCell: arg1 of: arg2  super decorateTableCell: arg1 of: arg2.  arg1 browser metaLevelScope = ClyClassSideScope ifTrue: [ arg1 label clyAddEmphasis: TextEmphasis bold ]publishCollectedChanges  self subclassResponsibilityfindAllItemsBy: arg1  self findAllItemsBy: arg1 stopLookupWhen: [:arg2 |  false ]defaultClassCompiler  ^self class compilerclassSelectionChanged  self changeStateBy: [ self showsFlatClasses ifFalse: [ self silentlySelectPackageOfSelectedClass ].        self changeMethodGroupQueryBy: [ self adoptForExtendedClass.              methodGroupQuery restrictedByScope: self defaultClassScopeForMethods ].        self selectCurrentExtensionMethodGroup ]tagEditingMethod: arg1  | tmp1 tmp2 tmp3 |  self applyChangesBy: [ tmp1 := arg1 tags reject: [:arg2 |  arg2 beginsWith: '*' ].        tmp2 := tmp1 reject: [:arg2 |  methodTags includes: arg2 ].        tmp3 := methodTags reject: [:arg2 |  tmp1 includes: arg2 ].        tmp3 do: [:arg2 |  arg1 tagWith: arg2 asSymbol ].        tmp2 do: [:arg2 |  arg1 untagFrom: arg2 asSymbol ] ]resultItemsType  ^self class resultItemsTypeisForScripting  ^truesubscopes: arg1  arg1 ifEmpty: [ ^self error: 'ClyCompositeScope should include at least one subscope' ].  subscopes := arg1.  environment := subscopes anyOne environment.  self basisObjects: (subscopes flatCollect: [:arg2 |  arg2 basisObjects ])iconName  ^'small' , name capitalized , 'Icon'browserContextWasChanged  applyingChanges ifFalse: [ super browserContextWasChanged ]startPosition: arg1  startPosition := arg1isSameKindAs: arg1  ^self type = arg1 typeenvironment  ^environmenttestSelectionWithRetrievedDataSourceCopy  self snapshotState.  self assert: navigationState selection rootDataSource equals: navigationState dataSourcetestBasedOnBasisObject  scope := self createSampleScope.  self assert: (scope isBasedOn: scope basisObjects anyOne).  self deny: (scope isBasedOn: #anotherObject)decorateTableCell: arg1 of: arg2  | tmp1 |  tmp1 := ClyContextSelectionStrategy selectContextOfSingleItem: arg2 for: browser.  ClyTableDecorationStrategy activeInstancesInContext: tmp1 do: [:arg3 |  arg3 decorateTableCell: arg1 inContext: tmp1 ]definesChildren  self subclassResponsibilitydetectDefiningClassFrom: arg1  (arg1 slots includes: actualVariable) ifTrue: [ definingClass := arg1.        ^self ].  arg1 isRootInEnvironment ifTrue: [ self error: 'Cant find the class defining variable' ].  self detectDefiningClassFrom: arg1 superclassrestoreTableSelection  | tmp1 |  tmp1 := items anySatisfy: #isRemoved.  self restoreTableSelectionSilently: tmp1 not.  ^tmp1ensureVisibleLastItem  testFillingWithSuperclassAndSubclassMethods  queryResult fillWith: ClyClass1FromP1 localMethods , ClySubclassN1OfClass1FromP1 localMethods.  self assertItems: #(#instanceSideVar1ReaderMethod 0 #instanceSideVar1WriterMethod 0 #superclassTag1Method 0 #tag1Method1 0 #noTagMethod 1 tag1Method1 1 tag1Method2 1 tag2Method1 1) withValue: [:arg1 |  arg1 name ]processClassDefinitionChange: arg1  arg1 oldClassDefinition superclass ifNotNil: [:arg2 |  (arg2 subclasses includes: arg1 oldClassDefinition) ifTrue: [ ^self ] ].  arg1 oldClassDefinition superclass = arg1 newClassDefinition superclass ifTrue: [ ^self ].  environment systemChanged: (ClyOverriddenSuperclassesChanged overridingSubclass: arg1 oldClassDefinition)defaultMenuItemName  ^'Hier.'waitBuildCompletion  containerTab waitReadyMorphFor: 50 milliSecondsasScope: arg1 of: arg2  ^arg1 of: arg2 in: environmentmetadata  ^metadatarestoreSelectionOfExtraTool: arg1  arg1 hasUnacceptedEdits ifFalse: [ arg1 selectAsExtraTab.        ^self ].  (self countToolsSimilarTo: arg1) = 1 ifTrue: [ arg1 selectAsExtraTab ] ifFalse: [ arg1 deselectTab ]decorateBrowserItem: arg1 ofMethod: arg2  (arg2 sendsAnySelectorOf: #(flag:)) ifTrue: [ arg1 markWith: ClyMethodFlag ]testHasUnknownScopeByDefault  query := query class new.  self assert: query scope equals: ClyUnknownScope instancebrowseImplementorsOf: arg1  | tmp1 tmp2 |  arg1 first isUppercase ifTrue: [ tmp1 := self system bindingOf: arg1.        tmp1 ifNotNil: [ tmp2 := tmp1 value.              tmp2 isClassOrTrait ifFalse: [ tmp2 := tmp2 class ].              ^self spawnBrowser: ClyFullBrowser withState: [:arg2 |  arg2 selectClass: tmp2 ] ] ].  self spawnQueryBrowserOn: (ClyMessageImplementorsQuery of: arg1)position: arg1  position := arg1build  self subclassResponsibilityforceFullUpdate  itemCursor forceFullUpdategroupProviderClass  ^ClyTaggedMethodGroupProviderignoreNavigationDuring: arg1  waitingNewState := false.  arg1 ensure: [ waitingNewState := true ]decorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color red.  arg1 definitionIcon: #classIconrawItems  ^buildingQuery retrievesBrowserItems ifTrue: [ items collect: [:arg1 |  arg1 actualObject ] ] ifFalse: [ items ]testFillingWithSingleClasses  | tmp1 tmp2 |  queryResult fillWith: {ClyClass2FromP1}.  self assert: queryResult size equals: 1.  tmp1 := queryResult items first actualObject.  self assert: tmp1 class equals: ClyInheritedMethodGroup.  self assert: tmp1 name equals: ClyClass2FromP1 name.  self assert: tmp1 methodQuery equals: (ClyAllMethodsQuery from: ClyClassScope of: ClyClass2FromP1 in: environment).  self assert: tmp1 visibilityLevels size equals: 1.  tmp2 := tmp1 visibilityLevels first.  self assert: tmp2 class equals: ClySuperclassVisibilityLevel.  self assert: tmp2 visibleClassScope equals: (ClyClassScope of: ClyClass1FromP1 in: environment).  self assert: tmp2 extraClassScope equals: (ClyClassScope of: ClyClass2FromP1 in: environment)announceChangesOf: arg1  changes add: arg1affectsMethod: arg1  ^self affectsMethodsDefinedInClass: arg1 origintestExpandedDataSourceWithRetrievedExpandedItem  | tmp1 |  self selectedItem expand.  self snapshotState.  tmp1 := navigationState dataSource expandedItems first.  self assert: tmp1 childrenDataSource parentItem equals: tmp1classGroupsIn: arg1 do: arg2  self subclassResponsibilityfindCachedElementWith: arg1 ifAbsent: arg2  ^collapsedItems detect: [:arg3 |  arg3 actualObject == arg1 actualObject ] ifNone: arg2browser: arg1  browser := arg1sortedBy: arg1  ^self copy hierarchy: (hierarchy sortedBy: arg1)isMainColumn  ^truebuildItemsFrom: arg1  | tmp1 |  tmp1 := baseQueryResult prepareNewFor: buildingQuery in: environment.  tmp1 buildWith: arg1.  ^tmp1 items collect: [:arg2 |  arg2 asCalypsoBrowserItem ]resetTagsAndPackage  ownerTool methodTags: #().  self updateisEnabled  ^truetag1Method2  lastSelectedPackage  ^self lastSelectedItem systemDefinition definingPackageprocessesDo: arg1  self system allProcesses do: arg1collectMetadataOf: arg1 by: arg2  moveToNext  self moveTo: position + 1importClass: arg1  | tmp1 |  super importClass: arg1.  tmp1 := OrderedCollection new.  classQuery scope packagesDo: [:arg2 |  arg2 = arg1 package ifFalse: [ tmp1 add: arg2 ] ].  tmp1 size > 1 ifTrue: [ ^self error: 'You should select single package for import!' ].  tmp1 ifNotEmpty: [ tmp1 first addClass: arg1 ].  arg1 tagWith: self tagtestMethodsEnumeration  scope := ClyMethodScope ofAll: {(self class >> #method1) .         (self class >> #method2)}.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: scope basisObjects asArrayinitialize  super initialize.  self resetScope.  self requiredResult: self defaultResultprojectQueryFor: arg1  ^environment system projectManager projectQueryFor: arg1switchFocusToNextPane  | tmp1 tmp2 |  tmp1 := navigationViews detect: [:arg1 |  arg1 hasKeyboardFocus ] ifNone: [ ^self ].  tmp2 := navigationViews after: tmp1 ifAbsent: [ ^self focusActiveTab ].  tmp2 takeKeyboardFocusprepareInitialStateBy: arg1  navigationHistory ignoreNavigationDuring: [ self prepareInitialState.        arg1 valueWithPossibleArgument: self ]testFillingWithClassAndItGrandSuperclass  queryResult fillWith: {ClyClass1FromP1 .         ClySubclassLOfSubclassMFromP3}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1}disablePluginsWhichAreNotIn: arg1  plugins removeAllSuchThat: [:arg2 |  arg2 isAutoActivated and: [ (arg1 hasPlugin: arg2) not ] ]execute  | tmp1 |  tmp1 := self prepareNewResult.  tmp1 initializeItems.  self buildResult: tmp1.  ^tmp1childrenType: arg1  childrenType := arg1testComparisonWithAnotherFunction  | tmp1 |  function := ClySortBrowserItemFunction with: ClySortByNameFunction ascending.  tmp1 := ClySortBrowserItemFunction with: ClySortByNameFunction ascending.  self assert: function equals: tmp1.  self assert: function hash equals: tmp1 hash.  tmp1 := ClySortBrowserItemFunction with: ClySortByNameFunction descending.  self deny: function equals: tmp1requestRemoveMethodStrategyFor: arg1  ^tool requestRemoveMethodStrategyFor: arg1hash  ^value hashrawItems  ^itemshash  ^super hash bitXor: asyncResult hash= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^hierarchy = arg1 hierarchydefaultMenuItemName  queryScope ifNil: [ ^'Switch scope' ].  ^'Switch scope to ' , queryScope descriptiontestComparisonWithItself  self assert: queryResult equals: queryResultstringPattern: arg1  stringPattern := arg1accumulateTest: arg1 of: arg2  allCount := allCount + 1.  successCount := successCount + (arg2 methodPassed: arg1) asBit.  failureCount := failureCount + (arg2 methodFailed: arg1) asBit.  errorCount := errorCount + (arg2 methodRaisedError: arg1) asBitpackage  ^packagetestRetrievesCurrentSelection  self snapshotState.  self assert: (navigationState selection lastSelectedItem isSameAs: self selectedItem)belongsToRemovedBrowserContext  ^self leftMethod isInstalled not or: [ self rightMethod isInstalled not ]findSourceNodeAt: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp4 := self leftSideBar lineIndexForPoint: arg1.  tmp3 := textMorph paragraph lines at: tmp4.  tmp1 := tmp3 first.  tmp2 := tmp3 last.  tmp5 := self selectedTextInterval.  tmp5 ifNotNil: [ tmp5 first >= tmp1 & (tmp5 last <= tmp2) ifTrue: [ tmp1 := tmp5 first max: 1.              tmp2 := tmp5 last min: self editingText size ] ].  tmp6 := self editingMethod astForStylingInCalypso.  ^(tmp6 bestNodeFor: (tmp1 to: tmp2)) ifNil: [ tmp6 ]testFillingWithTwoSameClasses  queryResult fillWith: {ClyClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0}selectsMethod: arg1  | tmp1 |  tmp1 := arg1 selector.  scope classesDo: [:arg2 |  ((self isClass: arg2 shouldImplement: tmp1) and: [ (arg2 includesSelector: tmp1) not ]) ifTrue: [ ^true ] ].  ^falsespawnHierarchyForClass: arg1 selector: arg2  navigationEnvironment ifNil: [ self navigationEnvironment: ClyNavigationEnvironment currentImage.        self setUpAvailablePlugins ].  self spawnBrowser: ClyFullBrowser withState: [:arg3 |  arg3 selectClass: arg1.        arg3 switchToFullClassHierarchy.        arg2 ifNotNil: [ arg3 selectMethod: arg1 >> arg2 ] ]printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  items do: [:arg2 |  arg1           nextPutAll: arg2 name;           nextPutAll: '; ' ].  items ifNotEmpty: [ arg1 skip: -2 ].  arg1 nextPut: $)printExtraInfoOn: arg1  super printExtraInfoOn: arg1.  ^arg1 nextPutAll: tagretrievesItem: arg1  ^subqueries anySatisfy: [:arg2 |  arg2 retrievesItem: arg1 ]createQuery  ^(ClyConstantMethodQuery with: {(self class >> #method1) .         (self class >> #method2)}) scope: (ClyScopeExample emptyIn: environment)tag  ^tagisAccessibleFrom: arg1  ^truepriority  ^SmallInteger maxValassertVars: arg1  | tmp1 tmp2 tmp3 |  tmp1 := items select: [:arg2 |  arg2 actualObject isKindOf: ClyVariableMethodGroup ].  self assert: tmp1 size equals: arg1 size.  tmp2 := 1.  arg1 do: [:arg3 |  tmp3 := tmp1 at: tmp2.        self assert: tmp3 actualObject name equals: arg3.        tmp2 := tmp2 + 1 ]matches: arg1  self subclassResponsibilitymetaLevelScope: arg1  metaLevelScope := arg1projectsDo: arg1  basisObjects do: arg1defaultNavigationScope  ^self systemScopetestHasResultAdapterOverActualQueryResult  self assert: cursor queryResult class equals: ClyQueryResultBrowserAdapter.  self assert: cursor queryResult actualResult equals: queryResultselectedPackageItems  self subclassResponsibilityprintExtraInfoOn: arg1  super printExtraInfoOn: arg1.  ^arg1 nextPutAll: pattern valuecanAffectResultOfMethodQuery: arg1  ^truegroupProviderClass  ^ClyRequiredMethodGroupProviderprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  methodEditor := arg1 toolpattern  ^patternbrowseReferencesTo: arg1  self browseReferencesTo: arg1 from: self systemdetachFromSystem  browser system unsubscribe: selfdeactivateExtraScope  ^visibleClassScope reducedByClassesFrom: extraClassScopetestAscendingForBinaryAndUnarySelectors  function := ClySortMethodBySelectorFunction ascending.  self assert: #| > #abs.  self assert: (function value: Integer >> #| value: Number >> #abs).  self deny: (function value: Number >> #abs value: Integer >> #|).  self deny: #+ > #abs.  self assert: (function value: Number >> #+ value: Number >> #abs).  self deny: (function value: Number >> #abs value: Number >> #+)localMethodFromSubclass  selectedMessage  ^SycMessageDescription ofMessageNode: self selectedSourceNodesemiAsync  ^self async asyncResult: ClySemiAsyncQueryResult newsetUpEnvironment  super setUpEnvironment.  environment system: ClySystemEnvironment currentImage.  plugin := ClyTestedEnvironmentPlugin new.  plugin environment: environmentcontainerForChildren  ^hierarchy containerForChildrentestAdoptQuery  | tmp1 tmp2 |  scope := self singleScopeSample.  tmp1 := ClyQueryExampleReturningScopeBasis new.  tmp2 := scope adoptQuery: tmp1.  self assert: tmp2 identicalTo: tmp1method2WithUndeclares  undeclaredStubInstVar2 := 100asSelectedItemsOf: arg1  | tmp1 |  self isEmpty ifTrue: [ ^self ].  tmp1 := items select: [:arg2 |  arg2 isBasedOnItemType: arg1 ].  tmp1 = items ifTrue: [ ^self ].  ^self class fromRoot: self rootDataSource items: tmp1testthisContext_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'thisContext') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: ThisContext ]')testCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #reference1OfVar1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #referenceOfAnotherVar in: environment).  self assert: query checkEmptyResulttestCheckEmptyQueryWhenThereIsNoResultButItWouldNotBeEmpty  | tmp1 |  tmp1 := self createQueryFromScopeOf: self class.  self deny: (environment isQueryEmpty: tmp1)countChildrenOf: arg1  self subclassResponsibilitydefaultMenuItemName  ^'Commit'testClassEnumeration  scope := ClyBothMetaLevelClassScope ofAll: {ClyClass1FromP1 .         ClyClass2FromP1}.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: {ClyClass1FromP1 .         ClyClass2FromP1}defaultColor  ^Color transparentexecute  UIManager default longMessage: critique description title: critique titletestDetectingDefiningClassFromSharedPoolUser  | tmp1 tmp2 |  tmp1 := ChronologyConstants classVariableNamed: #DayNames.  tmp2 := ClyClassVariable on: tmp1 visibleFrom: Date.  self assert: tmp2 definingClass equals: ChronologyConstantstestBuildCompletionShouldResetProcess  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self assert: queryResult buildProcess isNildescription  ^'all methods'environment: arg1  environment := arg1definitionString  ^definitionStringsubscribeOnTextChanges  textMorph announcer     when: RubTextAccepted send: #changesAccepted to: self;     when: RubTextChanged send: #textChanged: to: self;     when: RubCancelEditRequested send: #changesCancelRequested: to: selfinitialize  super initialize.  parentMap := IdentityDictionary newremovePlugin: arg1  plugins removeAllSuchThat: [:arg2 |  arg2 class = arg1 class ]applyResultInContext: arg1  super applyResultInContext: arg1.  arg1 showMethodTag: tagNamedeselect: arg1  simpleNameForSpotterMenu  ^'Classes'updateExpandingItems  self subclassResponsibilityglobalPositionOf: arg1  | tmp1 |  tmp1 := parentItem ifNil: [ 0 ] ifNotNil: [ parentItem globalPosition ].  expandedItems do: [:arg2 |  (arg2 isAfter: arg1 position) ifTrue: [ ^tmp1 + arg1 position ].        tmp1 := tmp1 + arg2 childrenCount ].  ^tmp1 + arg1 positioncreateClassGroupFor: arg1 from: arg2  ^ClyClassGroup named: 'Extensions' priority: 0 on: arg1defaultMenuItemName  ^'Browse rule'itemFilter: arg1  itemFilter := arg1testFromClassWhichIncludesTwoProtocolExtensionsOfSamePackage  self queryFromScope: ClyClassScope of: ClyClass9FromPExtendedByP5.  self assert: resultItems asSet equals: {ClyClass7WithTag1FromP5 package} asSetloadItemOf: arg1 at: arg2  (self includesItemAt: arg2) ifTrue: [ ^self ].  startPosition := arg2.  self fillItemsFrom: arg1withMetaLevel: arg1  | tmp1 |  tmp1 := subscopes collect: [:arg2 |  arg2 withMetaLevel: arg1 ].  ^ClyCompositeScope on: tmp1 in: environment named: nameeditingText  ^editingClass commenttestMatchesClassOfPackageWhichMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'SystemQueries-Tests'.  self assert: (filter matches: self itemOfThisTestClass)isStatic  ^truedescription  ^'all classes'attachToTextMorph  super attachToTextMorph.  self textArea announcer when: RubSelectionChanged send: #updateContents to: self.  self updateContentstestFillingWithClassAndItsTraitsWhenSomeMiddleTraitIsMissing  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitRoot1 .         2}activeColor  ^self theme backgroundColortestFillingWithExtendedClassSide  query := ClyAllClassesQuery from: ClyPackageScope of: ClyClass1FromP1 package in: environment.  queryResult := ClyExtensionLastSortedClasses simple prepareNewFor: query in: environment.  queryResult buildWith: {ClySubclassLOfClass0FromPExtendedByP1 class .         ClyClass2FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClyClass2FromP1 .         0 .         ClySubclassLOfClass0FromPExtendedByP1 class .         0}.  self assert: (items last isMarkedWith: ClyExtendedClassTag)readParametersFromContext: arg1  super readParametersFromContext: arg1.  critique := arg1 selectedCritique.  analyzedObject := arg1 analyzedObjectcreateHierarchy  ^annotatedClass hierarchyForMethodVisibilityisInstanceSide  ^isInstanceSidetestNotBasedOnSingleBasisWhenAllSubscopesHaveEmptyBasis  | tmp1 tmp2 |  tmp1 := ClyScopeExample emptyIn: environment.  tmp2 := ClyScopeExample emptyIn: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self deny: scope isBasedOnSingleBasisdefaultItems  ^SortedCollection sortBlock: ClySortByNameFunction ascendingitemsChanged  superclassVar1ReaderMethod  ^instanceSideVar1baseClass  ^baseClassignoreNavigationDuring: arg1  | tmp1 |  tmp1 := navigationSelector.  navigationSelector := nil.  arg1 ensure: [ navigationSelector := tmp1 ]groupProviderClass  ^ClyUnclassifiedMethodGroupProvidernewContentMorph  itemsView := ClyQueryViewMorph for: self.  itemsView width: 250.  itemsView whenDoubleClickDo: [:arg1 |  self ok ].  itemsView whenEnterKeyPressedDo: [:arg1 |  self ok ].  itemsView whenEscapeKeyPressedDo: [:arg1 |  self cancel ].  ^itemsViewtestFromClassAndInheritedTrait  query := ClyMessageImplementorsQuery of: #methodFromRoot1.  self queryFromScope: ClyBothMetaLevelClassScope ofAll: {ClyClassWithTraits .         ClyTraitRoot1}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: ClyTraitRoot1 >> #methodFromRoot1testCreationFromTwoUnionQueries  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self subqueryFromScope: ClyScopeExample of: Array.  tmp2 := self subqueryFromScope: ClyScopeExample2 of: String.  tmp3 := self subqueryFromScope: ClyScopeExample of: Object.  tmp4 := self subqueryFromScope: ClyScopeExample2 of: Class.  tmp5 := tmp1 , tmp2.  tmp6 := tmp3 , tmp4.  query := tmp5 , tmp6.  self assert: query class equals: self queryClass.  self assert: query subqueries size equals: 2.  self assert: (query subqueries collect: #class as: Set) equals: {tmp1 class} asSet.  tmp7 := query subqueries collect: #scope as: Set.  self assert: tmp7 equals: {(ClyScopeExample ofAll: {Array .               Object}) .         (ClyScopeExample2 ofAll: {String .               Class})} asSet.  self assert: query requiredResult identicalTo: tmp1 requiredResultsetUpModelFromContext  super setUpModelFromContext.  editingClass := context selectedClassSidechildrenType  ^childrenTypeannouncer  ^announcernavigationViews  ^navigationViewswithNewBasisObjects: arg1  ^self copy     basisObjects: arg1;     bindTo: environmentmethodGroup: arg1  methodGroup := arg1metaLevelScope  ^metaLevelScopeselectsMethod: arg1  ^(selectors includes: arg1 selector) and: [ arg1 origin = arg1 methodClass ]defaultMenuIconName  ^#smallFindIconassertItems: arg1  self assertItems: arg1 withValue: [:arg2 |  self meaningfullObjectToAssert: arg2 ]createElementWith: arg1  ^self findCachedElementWith: arg1 ifAbsent: [ ClyDataSourceItem of: self value: arg1 ]selectedClassItems  self subclassResponsibilitysuperclassTag1Method  testCreationOnBasisObjects  | tmp1 |  scope := self createSampleScope.  tmp1 := scope prepareBasisFrom: scope basisObjects.  self assert: scope basisObjects equals: tmp1methodSelection  ^self selection asSelectedItemsOf: ClyMethodformatAsYouReadLabel  ^'F'testRetrievesStateOfAllNavigationViews  self snapshotState.  self assert: navigationState viewStates size equals: browser navigationViews sizeinitialize  super initialize.  self     changeTableLayout;     hResizing: #rigid;     width: 200testFillingWithTraitsOfClassWhichIsMissingInGivenList  queryResult fillWith: {ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyTraitChild1 .         0 .         ClyTraitRoot1 .         1 .         ClyTraitChild2Child .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot1 .         2}findItemsWith: arg1 forAbsentDo: arg2  ^arg1 collect: [:arg3 |  items detect: [:arg4 |  arg4 actualObject == arg3 ] ifNone: arg2 ]printSelectors  ^',' join: selectorsmetalinkManagerClass  ^WatchpointtagsAndPackageEditor  ^(statusBar findDeeplyA: ClyMethodTagsAndPackageEditorMorph) ifNil: [ CmdCommandAborted signal ]classQuery  ^classQueryensureSelectedItemIfNeeded  table allowsDeselection ifFalse: [ self ensureSelectedItem ].  self ensureVisibleSelectionitemObserver  ^itemObservertestConvertingToNewMetaLevel  | tmp1 |  scope := self createSampleScope.  tmp1 := scope withMetaLevel: ClyInstanceSideScope.  self assert: tmp1 class equals: ClyInstanceSideScope.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 environment equals: environmentforceLazyRebuild  self protectAccessWhile: [ needsRebuild := true ]setUp  super setUp.  groupProvider := self groupProviderClass new.  builtGroups := OrderedCollection newextraBasisSample  ^self class >> #method2writer2OfVar1  writtenVar1 := #value2testCreatesGroupsForEveryTag  self buildGroupsFor: ClyClass7WithTag1FromP5 package.  self assert: builtGroups size equals: 2.  self assert: (builtGroups collect: #tag) sorted asArray equals: #(Tag1 Tag2)showDesiredSelection  self initiateUIChangeBy: [ desiredSelection ifNil: [ ^selection beEmpty ].        desiredSelection restoreCurrentSelection: selection ]hash  ^super hash bitXor: groupName hashtestCases  ^testCaseResults keyshash  ^super hash bitXor: extraParameter hashelementAt: arg1  | tmp1 |  tmp1 := arg1.  collapsedItems do: [:arg2 |  arg2 position = tmp1 ifTrue: [ ^arg2 ].        (arg2 isAfter: tmp1) ifTrue: [ self itemCursor moveTo: tmp1.              ^ClyDataSourceItem of: self value: self itemCursor currentItem ].        tmp1 := tmp1 + arg2 childrenCount ].  self itemCursor moveTo: tmp1.  ^ClyDataSourceItem of: self value: self itemCursor currentItemuniformActualObjects  | tmp1 |  self isEmpty ifTrue: [ ^#() ].  tmp1 := self lastSelectedItem.  ^(items allSatisfy: [:arg1 |  arg1 isSameKindAs: tmp1 ]) ifTrue: [ items collect: #actualObject ] ifFalse: [ {tmp1 actualObject} ]= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^asyncResult = arg1 asyncResultdescription  ^'Get the class sample (predefined instance) in a inspector to tweak it and have fun with it'currentScopeIndex  ^self scopes indexOf: self currentScopefindItemsWhere: arg1  | tmp1 tmp2 |  tmp1 := super findItemsWhere: arg1.  tmp2 := expandedItems flatCollect: [:arg2 |  arg2 childrenDataSource findItemsWhere: arg1 ].  ^tmp1 , tmp2description: arg1  description := arg1restoreBrowserState  self subclassResponsibilitytestMethodsEnumerationWhenBothMetaLevels  scope := ClySubclassScope of: ClyClass1FromP1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyClass1FromP1 subclasses first localMethods).  self assert: (result includesAll: ClyClass1FromP1 subclasses first classSide localMethods).  self assert: (result includesAll: ClyClass1FromP1 subclasses second localMethods).  self assert: (result includesAll: ClyClass1FromP1 subclasses second classSide localMethods).  self deny: (result includesAll: ClyClass1FromP1 localMethods).  self deny: (result includesAll: ClyClass1FromP1 classSide localMethods).  self deny: (result includesAll: ClyClass1FromP1 superclass localMethods).  self deny: (result includesAll: ClyClass1FromP1 superclass classSide localMethods)findAnySelectorOrString: arg1 inSourceCode: arg2  ^(self findAnySelectorInSourceCode: arg1) ifEmpty: [ self findAnyString: arg1 in: arg2 ]editingClass  ^editingClassvariable  ^methodQuery variableQuery resultItems firstsupportsCriticDecoration  ^truetestNotMatchesClassWithWrongNameAndPackage  filter := ClyQueryBrowserFilter substringPattern: 'filter not matches class name and package'.  self deny: (filter matches: self itemOfThisTestClass)defaultColor  ^Color transparentinheritanceAnalyzer  ^environment getPlugin: ClyInheritanceAnalysisEnvironmentPluginexecute  methodGroups do: [:arg1 |  arg1 convertToMethodTag: tagName ]decorateTableCell: arg1 with: arg2  arg2 setBalloonText: self description.  arg1 addExtraTool: arg2findCachedElementWith: arg1 ifAbsent: arg2  self subclassResponsibilitymethodFromTraitChild1  currentMetaLevelOf: arg1  ^metaLevelScope metaLevelOf: arg1createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'abstract' priority: -10 on: arg1undo  super undo.  self editingState undoManager hasPrevious ifFalse: [ self browserTool changesCancelled ]decorateTableCell: arg1 of: arg2  | tmp1 |  super decorateTableCell: arg1 of: arg2.  tmp1 := name asLowercase.  (tmp1 beginsWith: 'private') ifTrue: [ ^arg1 definitionIcon: #protocolPrivateIcon ].  (#('initial' 'class initial' 'releaz' 'releas' 'finali') anySatisfy: [:arg3 |  tmp1 beginsWith: arg3 ]) ifTrue: [ arg1 definitionIcon: #protocolProtectedIcon ]openOn: arg1  self isClosed ifFalse: [ self close ].  queryView := arg1.  table := arg1 table.  itemCursor := query openBrowserCursorFor: self.  dirty := falsedefaultColor  ^Color transparentrestoreNavigationState: arg1 of: arg2  arg1 applyTo: arg2 byUndo: undoExecutingprintContext  ^editingClass printSystemPathtestRetrievesExpectedFlatQueryResult  self snapshotState.  self assert: navigationState expectedFlatQueryResult equals: browser expectedFlatQueryResultone: arg1 two: arg2  self     one: arg1;     two: arg2triggerUpdate  applyingChanges ifFalse: [ self update ]ignoreNavigationDuring: arg1  navigationStarted ifTrue: [ ^arg1 value ].  navigationStarted := true.  arg1 ensure: [ navigationStarted := false ]execute  | tmp1 |  methodGroups do: [:arg1 |  tmp1 := SycMoveMethodsToPackageCommand for: arg1 methods to: package.        tmp1 execute.        arg1 removeWithMethods ]testUsingScript  filter := ClyQueryBrowserFilter substringPattern: '[:each | each selector = #testUsingScript]'.  self assert: (filter matches: self itemOfThisTestMethod).  self deny: (filter matches: (ClyBrowserItem with: Object >> #printString))confirmUnusedVariables: arg1  | tmp1 |  tmp1 := ClyVariableReferencesQuery ofAny: arg1 from: self systemScope.  ^self confirmEmptySystemQuery: tmp1findAllItemsBy: arg1 stopLookupWhen: arg2  | tmp1 tmp2 |  tmp1 := arg1 value: self dataSource.  self isFilterActive ifFalse: [ ^tmp1 ].  (arg2 value: tmp1) ifTrue: [ ^tmp1 ].  tmp2 := arg1 value: table initialDataSource.  tmp1 size = tmp2 size ifTrue: [ ^tmp1 ].  self setUpDataSource: table initialDataSource.  ^tmp2createTextContext  ^self selectedSourceNode ifNil: [ super createTextContext ] ifNotNil: [:arg1 |  ClyMethodSourceCodeContext for: self selectedNode: arg1 ]extraBasisSample  ^super extraBasisSample classSidecreateQuery  ^ClyRestUntaggedClassesQuery from: ClyPackageScope of: Object package in: environmentlocalScopeClass  ^localScopeClassincludesMethodsAffectedBy: arg1  ^arg1 affectsMethodstestRestoredBrowserInstanceWithQueryScopes  self restoreBrowserInstance.  self assert: navigationState queryScopes size equals: 2.  self assert: browser queryScopes equals: navigationState queryScopesshowsQueryResultAs: arg1  ^systemQuery requiredResult = arg1defaultMenuItemName  ^'Select method package'dropPassenger: arg1 at: arg2  | tmp1 |  tmp1 := self createSelectionContextOf: arg2 asSelection.  ^arg1 dropInContext: tmp1isExpanded: arg1  ^(collapsedItems includes: arg1) nottestCompareTwoItemsOfClasses  function := ClySortBrowserItemFunction with: ClySortByNameFunction ascending.  self deny: (function value: Object asCalypsoBrowserItem value: Array asCalypsoBrowserItem).  self assert: (function value: Array asCalypsoBrowserItem value: Object asCalypsoBrowserItem).  self assert: (function value: Object asCalypsoBrowserItem value: Object asCalypsoBrowserItem)findFirstOccurrenceOf: arg1 in: arg2  | tmp1 |  tmp1 := arg2 findString: arg1 startingAt: 1.  [ tmp1 > 1 and: [ (arg2 at: tmp1 - 1) isAlphaNumeric ] ] whileTrue: [ tmp1 := arg2 findString: arg1 startingAt: tmp1 + 1 ].  ^tmp1hierarchy: arg1  hierarchy := arg1decorateMethodGroupTableCell: arg1 of: arg2  setUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyReflectiveEnvironmentPlugin newtestNormalizingSelectorForComparison  #(#one #one: #two #two: #one:two: #oneTwo: #+ #- #+-) with: #('one' 'one' 'two' 'two' 'onetwo' 'onetwo' '+' '-' '+-') do: [:arg1 :arg2 |  self assert: (plugin normalizeSelectorForComparison: arg1) equals: arg2.        self assert: (plugin normalizeSelectorForComparison: arg1 asString) equals: arg2.        self assert: (plugin normalizeSelectorForComparison: arg2) equals: arg2.        self deny: (plugin normalizeSelectorForComparison: arg1) identicalTo: arg1.        self deny: (plugin normalizeSelectorForComparison: arg2) identicalTo: arg2.        self deny: (plugin normalizeSelectorForComparison: arg1) isSymbol.        self deny: (plugin normalizeSelectorForComparison: arg2) isSymbol ]affectsMethodsDefinedInClass: arg1  ^testCase == arg1groupProviderClass  ^ClyOverriddenMethodGroupProviderscope  ^scopeisBasedOn: arg1  ^query = arg1fileOut  | tmp1 tmp2 |  tmp1 := (String new: 1000) writeStream.  tmp1     header;     timeStamp;     cr.  self methods do: [:arg1 |  arg1 origin printMethodChunk: arg1 selector on: tmp1 ].  tmp1 trailer.  tmp2 := methodQuery scope basisObjects anyOne.  ^CodeExporter writeSourceCodeFrom: tmp1 baseName: tmp2 name , '-' , self name isSt: trueupdate: arg1 with: arg2  super update: arg1 with: arg2.  self updateMainWindowTitlecreateMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'expected failures' priority: -2 on: arg1setUp  super setUp.  environment system: ClySystemEnvironment currentImage.  environment detachFromSystemtestFromLocalClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: foundSelectors equals: #(classSideSender1OfMessage1 classSideSender2OfMessage1 sender1OfMessage1 sender2OfMessage1)itemsChanged  browser  ^browserTool browsertransferFor: arg1 from: arg2  | tmp1 tmp2 |  tmp1 := arg1 first rootDataSource newSelectionWith: arg1.  tmp2 := queryView createDragPassengerFor: tmp1.  ^super transferFor: tmp2 from: arg2groupProviderClass  ^ClyOverridingMethodGroupProvidercancelChanges  changesCancelRequested := true.  textMorph setText: self editingText.  changesCancelRequested := false.  self rebuildStatusBardescription  ^'Click to show all packages'collectMethodGroupProviders  ^{ClyInheritedMethodGroupProvider .   ClyTaggedMethodGroupProvider .   ClyUnclassifiedMethodGroupProvider .   ClyExtendedMethodGroupProvider} collect: [:arg1 |  arg1 new ]countChildrenOf: arg1  arg1 childrenDataSource ifNotNil: [:arg2 |  ^arg2 numberOfRows ].  self definesChildren ifFalse: [ ^0 ].  self error: 'should not happen'applyChangesBy: arg1  applyingChanges := true.  ^arg1 ensure: [ applyingChanges := false ]testComparison  self assert: (ClyMessageImplementorsQuery of: #message1) equals: (ClyMessageImplementorsQuery of: #message1).  self assert: (ClyMessageImplementorsQuery of: #message1) hash equals: (ClyMessageImplementorsQuery of: #message1) hash.  self deny: (ClyMessageImplementorsQuery of: #message1) equals: (ClyMessageImplementorsQuery of: #message2)testShouldFoundClassNameSymbolReference  query variableQuery: (ClyConstantQuery returning: {Number}).  self queryFromScope: ClyMethodScope of: self class >> #referenceOfNumberClassByNameSymbol.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #referenceOfNumberClassByNameSymboliconName  ^#smallDoItIcontestIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  query subqueries: {(self subqueryFromScopeOf: self class) .         (self subqueryFromScopeOf: self class superclass)}.  self assert: query isExecutedFromMultipleScopetestIsBasedOnSingleBasisWhenTwoSubscopesAreBasedOnSameSingleObject  | tmp1 tmp2 |  tmp1 := ClyScopeExample of: #basisObject in: environment.  tmp2 := ClyScopeExample2 of: #basisObject in: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self assert: scope isBasedOnSingleBasisdecorateBrowserItem: arg1 ofClass: arg2  arg2 isTrait ifTrue: [ arg1 markWith: ClyTraitTag ].  arg2 traits ifNotEmpty: [ arg1 markWith: ClyTraitUserTag ]untestedTwo: arg1  self two: arg1testCheckIfEmpty  query scope: (ClyPackageScope of: ClyClass1FromP1 package in: environment).  self deny: query checkEmptyResultaffectsMethods  ^truetestFillingWithClassAndItsTraitsWhenSomeMiddleTraitIsMissing  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitRoot1 .         2}installInto: arg1  arg1 assureExtension balloonText: selfmethodFromRoot1  whenReadyDo: arg1  containerTab waitReadyMorphFor: 10 seconds.  arg1 value: selfclassGroupsIn: arg1 do: arg2  | tmp1 |  tmp1 := self createClassQueryFrom: arg1.  tmp1 hasEmptyResult ifTrue: [ ^self ].  arg2 value: (self createClassGroupFor: tmp1 from: arg1)isClassCheapForOverriddenMethodsAnalysis: arg1  | tmp1 |  tmp1 := 0.  arg1 allSubclassesDo: [:arg2 |  tmp1 > littleHierarchyMaxSize ifTrue: [ ^false ].        tmp1 := tmp1 + 1 ].  ^truetestPreparation  | tmp1 tmp2 |  tmp1 := self createQuery.  tmp2 := queryResult prepareNewFor: tmp1 in: environment.  self assert: tmp2 class equals: queryResult class.  self deny: tmp2 identicalTo: queryResult.  self assert: tmp2 buildingQuery identicalTo: tmp1.  self assert: tmp2 environment equals: environment.  self assert: tmp2 isProtecteduntestedOne: arg1 two: arg2  self     one: arg1;     two: arg2isGlobalVariableSelected  | tmp1 tmp2 |  tmp1 := self selectedSourceNode.  tmp1 isVariable ifFalse: [ ^false ].  tmp2 := tmp1 binding.  ^tmp2 isGlobalVariableadoptForBrowser  ^selftestClassEnumeration  scope := ClyInstanceSideScope ofAll: {ClyClass1FromP1 classSide .         ClyClass2FromP1}.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: {ClyClass1FromP1 .         ClyClass2FromP1}isSimilarTo: arg1  (super isSimilarTo: arg1) ifFalse: [ ^false ].  ^methodClass == arg1 methodClass and: [ methodTags = arg1 methodTags and: [ extendingPackage = arg1 extendingPackage ] ]copyForBrowserStateSnapshot  ^self copy     initializeForBrowserStateSpanshot;     yourselfimportMethod: arg1  super importMethod: arg1.  arg1 tagWith: self tagdefaultMenuItemName  ^'Debug tests'setUp  super setUp.  environment addPlugin: ClyDefaultSystemEnvironmentPlugin newbaseCritiqueQuery  ^baseCritiqueQuerycreateSampleScope  ^ClyUnknownScope newnotifyObservers  announcer ifNil: [ ^self ].  environment announceChangesOf: selftestMatchesClassWhichNameMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'FilterTest'.  self assert: (filter matches: self itemOfThisTestClass)activateExtraScope  ^visibleClassScope increasedByClassesFrom: extraClassScope asInterestingClassScopeprojectQueryFor: arg1  projectManagers isEmpty ifTrue: [ ^ClyUnknownQuery instance ].  ^(projectManagers collect: [:arg2 |  arg2 queryClass sortedFrom: arg1 ]) reduce: [:arg3 :arg4 |  arg3 , arg4 ]queryScopes  ^queryScopesdescription  ^String streamContents: [:arg1 |  arg1 nextPutAll: self class name.        arg1 nextPut: $(.        self printExtraInfoOn: arg1.        arg1 nextPut: $) ]classes  ^classesbuildTitleFromSelections  | tmp1 tmp2 |  self projectSelection isEmpty ifFalse: [ tmp1 := self projectSelection lastSelectedItem name ].  self packageSelection isEmpty ifFalse: [ tmp1 := self packageSelection lastSelectedItem name ].  self classSelection isEmpty ifTrue: [ ^tmp1 ].  tmp2 := self methodSelection isEmpty ifTrue: [ self classSelection lastSelectedItem ] ifFalse: [ self methodSelection lastSelectedItem ].  tmp1 := tmp2 systemDefinition printDefiningClass.  tmp2 systemDefinition isInstanceSide & (metaLevelScope = ClyClassSideScope) ifTrue: [ tmp1 := tmp1 , ' class' ].  self methodSelection isEmpty ifFalse: [ tmp1 := tmp1 , '>>' , self methodSelection lastSelectedItem name ].  ^tmp1select: arg1  withExtraBasisObjects: arg1  | tmp1 |  tmp1 := OrderedCollection withAll: basisObjects.  arg1 do: [:arg2 |  (tmp1 identityIncludes: arg2) ifFalse: [ tmp1 add: arg2 ] ].  ^self withNewBasisObjects: tmp1defaultMenuItemName  ^'References'testQueryExecutionShouldRemoveOldWeaklyGarbagedCache  | tmp1 tmp2 |  tmp2 := self createQueryFromScopeOf: self class.  environment query: tmp2.  Smalltalk     garbageCollectMost;     garbageCollectMost.  tmp1 := environment cachedResultOf: tmp2.  self assert: tmp1 equals: nil.  tmp1 := environment query: (self createQueryFromScopeOf: self class superclass).  self deny: (environment queryCache includesKey: tmp2)extraParameter: arg1  extraParameter := arg1executeOn: arg1  | tmp1 |  tmp1 := implementorMethod pragmaAt: #script:.  ^arg1 compiler     receiver: arg1 instanceSide;     evaluate: tmp1 arguments firstcreateMethodQueryFrom: arg1  ^ClyMethodCallCountersQuery from: arg1decorateMethodEditor: arg1  systemQuery decorateResultMethodEditor: arg1execute  | tmp1 |  tmp1 := (selectedClassItem getProperty: ClyTestedClassProperty) coveringTestCase.  browser spawnBrowser: ClyFullBrowser withState: [:arg1 |  arg1 selectClass: tmp1 ]showQuery: arg1  | tmp1 |  self initiateUIChangeBy: [ tmp1 := ClyCollapsedDataSource on: arg1.        self dataSource: tmp1.        self ensureSelectedItemIfNeeded ]description  ^self actualQuery descriptionexecute  codeObjects do: [:arg1 |  arg1 fileOut ]packageSampleWhichHasGroup  ^ClyClass7WithTag1FromP5 packagecollectMethodGroupProviders  providesMethodGroup ifFalse: [ ^#() ].  ^{ClyCriticMethodGroupProvider new}extraScopesOfSelectedItems  | tmp1 |  tmp1 := self classScopeOfSelectedItems.  ^{self packageScopeOfSelectedItems .   tmp1 asFullHierarchyScope .   tmp1}testIsEmptyFromEmptyPackageScope  query scope: (ClyPackageScope emptyIn: environment).  self assert: query checkEmptyResultexpand: arg1  self subclassResponsibilitygroupItemsByTypeAndDo: arg1  self groupItemsByType keysAndValuesDo: arg1hasTestResult  ^methodDataSource hasMetaProperty: ClyTestResultPropertyisSelectedItemHasExecutionCounter  ^selectedItems anySatisfy: [:arg1 |  arg1 isMarkedWith: ClyMethodWithExecutionCounterTag ]addActualChild: arg1 to: arg2  | tmp1 |  tmp1 := parentMap at: arg2 ifAbsentPut: [ self containerForChildren ].  tmp1 add: arg1.  roots remove: arg1 ifAbsent: niltestNotBuiltWhenBuildIsJustStarted  queryResult rebuild.  self deny: queryResult isBuiltcheckbox  ^checkboxselectObject: arg1  | tmp1 |  self changeStateBy: [ tmp1 := resultView findItemsWith: {arg1}.        tmp1 ifNotEmpty: [ self selection selectItems: tmp1 ] ]collectGoToCandidates  | tmp1 |  tmp1 := OrderedCollection new.  browser allContextsDo: [:arg1 |  arg1 asGoToSpotterCandidate ifNotNil: [:arg2 |  tmp1 add: arg2 ] ].  ^tmp1initialize  super initialize.  self cellInset: 2 @ 2editingText  ^methodClass sourceCodeTemplatesuccessCount: arg1  successCount := arg1decorateByCritic: arg1  | tmp1 |  (textMorph segments select: [:arg2 |  arg2 class = ClyCriticalTextSegmentMorph ]) do: [:arg2 |  arg2 delete ].  tmp1 := arg1 buildCriticalTextSegmentsFor: editingMethod.  tmp1 do: [:arg2 |  textMorph addSegment: arg2 ]asScope: arg1  ^arg1 ofAll: basisObjects in: environment named: name, arg1  ^arg1 unionWith: {self} as: requiredResultdefaultMenuItemName  ^'All Packages'order  ^3execute  browser switchToMetaLevelScope: self metaLevelScopedefaultItems  ^SortedCollection sortBlock: ClySortByNameFunction ascendingisExecutedFromMultipleScope  ^scope isBasedOnMultipleBasisdescription  ^'View rationale behind the rule'testCreatesBrowserWithNavigationHistory  self restoreBrowserInstance.  self assert: browser navigationHistory equals: navigationState navigationHistorydefaultIconName  ^#commentsIcondepth  ^depthselectsMethod: arg1  (arg1 hasBreakpoint or: [ arg1 containsHalt ]) ifFalse: [ ^false ].  self excludesHaltsForTesting ifFalse: [ ^true ].  ^(arg1 hasPragmaNamed: #haltOrBreakpointForTesting) notupdateContents  labelMorph contents: self printCursorPositionextraBasisSample  ^ClySubclassMOfClass1FromP2 packagedoInOrderWithDepth: arg1  self rootsDo: [:arg2 |  arg1 value: arg2 value: 0.        self allChildrenOf: arg2 depth: 0 do: arg1 ]classNameOf: arg1  ^arg1 systemDefinition printDefiningClassconditionBlock  ^conditionBlockprojectsDo: arg1  self system projects do: arg1ffiMethod  ^self ffiCall: #(int system #(char * command))isResult: arg1 affectedBy: arg2  ^scope includesClassGroupsAffectedBy: arg2showsItemsFromScope: arg1  ^self query isExecutedFromScope: arg1selection  ^resultView selectionmethodTags: arg1  super methodTags: arg1.  self hasUnacceptedEdits ifFalse: [ self tagEditingMethod: editingMethod ]selectedTools  ^tools select: [:arg1 |  arg1 isTabSelected ]testConvertingWithExtraBasisObjects  | tmp1 |  scope := self singleScopeSample.  tmp1 := scope withExtraBasisObjects: {self singleBasisSample .         self extraBasisSample}.  self assert: tmp1 class equals: scope class.  self assert: (tmp1 basisObjects asIdentitySet includesAll: scope basisObjects).  self assert: (tmp1 basisObjects asIdentitySet includes: self extraBasisSample).  self assert: tmp1 basisSize equals: scope basisSize + 1retrievesItemsOfType: arg1  ^resultItems anySatisfy: [:arg2 |  arg2 calypsoEnvironmentType = arg1 ]testAscending  function := ClySortByNameFunction ascending.  self deny: (function value: Object value: Array).  self assert: (function value: Array value: Object).  self assert: (function value: Object value: Object)detachFromSystem  initialize  super initialize.  metaLevelScope := ClyInstanceSideScopeactualObject  ^actualObjectundoNavigationOf: arg1  undoList ifEmpty: [ ^self ].  self executeUndoBy: [ self restoreNavigationState: undoList removeLast of: arg1 ]testCreationByCommaFromThreeSubscopes  | tmp1 tmp2 tmp3 |  tmp1 := ClyScopeExample of: #basisObject1 in: environment.  tmp2 := ClyScopeExample2 of: #basisObject2 in: environment.  tmp3 := ClyScopeExample2 of: #basisObject3 in: environment.  scope := tmp1 , tmp2 , tmp3.  self assert: scope class equals: ClyCompositeScope.  self assert: scope basisObjects equals: #(basisObject1 basisObject2 basisObject3) asSet.  self assert: scope subscopes asSet equals: {tmp1 .         tmp2 .         tmp3} asSet.  self assert: scope environment equals: environmentshowVariableNamed: arg1  tool selectVariableNamed: arg1selectedClassSide  ^self lastSelectedClassformatTextIfNeeded  RBProgramNode formatterClass formatAsYouReadPolicy ifFalse: [ ^self ].  textMorph formatSourceCode.  textModel clearUserEditsexpectedFlatQueryResult: arg1  expectedFlatQueryResult := arg1close  super close.  expandedItems do: [:arg1 |  arg1 childrenDataSource close ]createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'failed tests' priority: -1 on: arg1testClassNameFor: arg1  ^(arg1 name , 'Test') asSymbolprintOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     nextPutAll: (annotatedClass ifNil: [ 'detached' ] ifNotNil: [ annotatedClass name ]);     nextPutAll: '; ';     nextPutAll: priority asString;     nextPut: $)doesNodeOf: arg1 belongsTo: arg2  | tmp1 |  tmp1 := arg1 node methodNode.  tmp1 selector == arg2 selector ifFalse: [ ^false ].  tmp1 methodClass == arg2 methodClass ifFalse: [ ^false ].  tmp1 == arg2 ast ifFalse: [ ^false ].  ^trueprintContext  ^self editingMethod printSystemPathdepth: arg1  depth := arg1testMethodsEnumerationOverMetaclassWhenConcreteClassScopeIsScope  | tmp1 |  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassScope.  scope methodsDo: [:arg1 |  result add: arg1 ].  tmp1 := ClyClass1FromP1 class allSuperclasses flatCollect: #methods as: IdentitySet.  self assert: result asIdentitySet equals: tmp1affectsMethodsTaggedWith: arg1  overridingSubclass allSuperclassesDo: [:arg2 |  (arg2 tagsForMethods includes: arg1) ifTrue: [ ^true ] ].  ^falseasDraggableMorph  ^(String streamContents: [:arg1 |  selectedItems do: [:arg2 |  arg1 nextPutAll: arg2 name ] separatedBy: [ arg1 space ] ]) asStringMorphname  ^namecollectMetadataOf: arg1 by: arg2  subqueries do: [:arg3 |  arg3 collectMetadataOf: arg1 by: arg2 ]analyzedObjectsDo: arg1  scope methodsDo: arg1okToClose  self hasUnacceptedEdits ifFalse: [ ^true ].  ^browser confirmDiscardChangescreateQueryResult  ^ClyTraitUserHierarchy inverse asQueryResulttestForbidCreationOnScopeWithoutEnvironment  [ query scope: (ClyScopeExample ofAll: {}).  self assert: false description: 'Query should be only created on scope bound to concrete environment' ] ifError: [  ]getMetaProperty: arg1  ^metadata getProperty: arg1printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  self printBasisOn: arg1.  arg1 nextPut: $)testComparisonWithSimilarQueryBasedOnDifferentBaseCritiqueQuery  | tmp1 |  query baseCritiqueQuery: ClyAllBasisCritiqueQuery new.  tmp1 := self createQuery.  tmp1 baseCritiqueQuery: ClyAllMethodCritiqueQuery new.  self deny: query equals: tmp1testForbidCreationOnScopeWhichNotSupportIt  [ query scope: (ClyCompositeScope in: environment).  self assert: false description: 'Query should be supported by scope' ] ifError: [  ]requiresNewDesiredSelection  desiredSelection ifEmpty: [ ^false ].  ^(self selectedTools allSatisfy: [:arg1 |  desiredSelection includes: arg1 class ]) notexecute  | tmp1 |  tmp1 := methodEditor tagsAndPackageEditor.  tmp1 requestChangeBy: [ tmp1 requestTag ]providesGroupsAffectedBy: arg1 inScope: arg2  arg2 classesDo: [:arg3 |  (arg1 affectsMethodTagIn: arg3) ifTrue: [ ^true ] ].  ^falsetestCheckIfEmpty  query scope: self scopeWithCritiques.  self deny: query checkEmptyResult.  query scope: self scopeWithoutCritiques.  self assert: query checkEmptyResultincludesClass: arg1  ^classes includes: arg1createMethodQueryFrom: arg1  ^ClyAllMethodsQuery from: arg1 asLocalClassScopelastSelectedObjectIn: arg1  ^arg1 firstcreateRegexMatcherIfFailed: arg1  value trimBoth ifEmpty: [ ^arg1 value ].  ^[ value asRegexIgnoringCase ] on: RegexSyntaxError do: [:arg2 |  ^self createFixedRegexMatcherIfFailed: arg1 ]= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^pattern = arg1 patterntestFromThreeMethods  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithHalts >> #methodWithHalts1) .         (ClyClassWithBreakpoints >> #methodWithBreakpoints) .         (ClyClassWithBreakpoints >> #methodWithoutBreakpoints)}.  self assert: foundSelectors sorted asArray equals: #(#methodWithBreakpoints #methodWithHalts1)selectClass: arg1  | tmp1 tmp2 |  self changeStateBy: [ self switchToMetaLevelScope: arg1 metaLevelScope.        tmp1 := classView findItemsWith: {arg1 instanceSide}.        tmp1 ifNotEmpty: [ tmp2 := tmp1 anyOne systemDefinition.              (self isPackageSelected: tmp2 definingPackage) ifTrue: [ ^self classSelection selectItems: tmp1 ] ].        arg1 tags ifEmpty: [ self selectPackage: arg1 package ] ifNotEmpty: [:arg2 |  self selectPackage: arg1 package atClassTag: arg2 anyOne ].        self packageSelection isEmpty ifTrue: [ ^self ].        self showsFullClassHierarchy ifTrue: [ self switchToFullClassHierarchyOf: arg1 ].        self classSelection selectItemsWith: {arg1 instanceSide} ]testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClass1FromP1 >> #tag1Method1) .         (Object >> #printString) .         (ClySubclassLOfClass0FromPExtendedByP1 >> #extensionMethodFromSubclassL) .         (ClyClass9FromPExtendedByP5 >> #extensionMethodFromClass9)}.  self assert: foundSelectors equals: #(#extensionMethodFromSubclassL)numberOfRows  ^self itemCursor itemCount - (collapsedItems detectSum: [:arg1 |  arg1 childrenCount ])buildIsDone  asyncModeIsActive ifTrue: [ super buildIsDone ]lastSelectedClassTag  ^self lastSelectedObjectIn: self selectedClassTagstestEmptySubqueriesAreForbidden  [ query subqueries: {}.  self assert: false description: 'empty subqueries should be forbidden' ] ifError: [  ]definitionTypeLabel  ^'Slots'isAppliedToBrowser  ^browser showsFlatClassestestQueryExecutionWhenResultWasWeaklyCollectedAsGarbage  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := self createQueryFromScopeOf: self class.  environment query: tmp4.  Smalltalk     garbageCollectMost;     garbageCollectMost.  tmp1 := environment cachedResultOf: tmp4.  self assert: tmp1 equals: nil.  tmp2 := environment query: tmp4.  self assert: tmp2 class equals: ClyRawQueryResult.  tmp3 := environment query: tmp4.  self assert: tmp2 identicalTo: tmp3testCreationUnifiedInstanceWhenThereIsExtraScopeParameter  | tmp1 |  query extraParameter: #testParameter.  tmp1 := query asUnifiedInstance.  self assert: tmp1 extraParameter equals: #testParameterwindowIsClosing  self closeDataSourcetestIsEmptyForExplicitlyDefinedAbstractClass  query scope: (ClyClassScope of: ClyExplicitAbstractClassExample in: environment).  self assert: query checkEmptyResult.  self executeQuery.  self assert: foundSelectors isEmptycreatePackageNamed: arg1  ^environment ensurePackageNamed: arg1testFillingWithTraitAndItsUsersWhenSomeUserInMiddleIsMissing  queryResult fillWith: {ClyTraitRoot1 .         ClyTraitChild1 .         ClyClassWithTraits .         ClyTraitChild2}.  self assertItems: {ClyTraitRoot1 .         0 .         ClyTraitChild1 .         1 .         ClyClassWithTraits .         2 .         ClyTraitChild2 .         1 .         ClyClassWithTraits .         2}announcerPlugin  ^announcerPlugintestCheckIfEmpty  query scope: (ClyMethodScope of: self class >> self targetSelector in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #messageImplementor2 in: environment).  self assert: query checkEmptyResultwasNotified  ^wasNotified ifNil: [ false ]decorateBrowserItem: arg1 ofClass: arg2  arg2 isDeprecated ifTrue: [ arg1 markWith: ClyDeprecatedItemTag ]handleSystemChange: arg1 byProcessingList: arg2  | tmp1 |  super handleSystemChange: arg1 byProcessingList: arg2.  tmp1 := environment cachedResultOf: buildingQuery.  tmp1 ifNil: [ ^self ].  needsRebuild ifTrue: [ buildProcess ifNotNil: [ buildProcess terminate.              metadata removeProperty: ClyBackgroundProcessingTag instance ].        tmp1 itemsChanged ].  arg2 remove: tmp1 ifAbsent: [  ]testBuildingGroups  self buildGroupsFor: self packageSampleWhichHasGroup.  self assert: builtGroups notEmptydefaultMenuIconName  ^#smallDebugprintOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  arg1 nextPutAll: 'size: '.  subtreeSize printOn: arg1.  arg1 nextPut: $)defaultMenuItemName  ^'Inheritance'= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^sortFunction = arg1 sortFunction and: [ inverse = arg1 isInverse ]collectClassGroupProviders  ^{ClyExtendedClassGroupProvider .   ClyNoTagClassGroupProvider .   ClyTaggedClassGroupProvider} collect: [:arg1 |  arg1 new ]sender1OfMessage1  self clyReferencedMessage1semiAsync  ^self copy asyncResult: ClySemiAsyncQueryResult newtestFillingWithClassesFromOneHierarchy  queryResult fillWith: {ClySubclassN1OfClass1FromP1 .         ClySubclassLOfSubclassMFromP3 .         ClyClass1FromP1 .         ClySubclassN2OfClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1 .         ClySubclassN1OfClass1FromP1 .         1 .         ClySubclassN2OfClass1FromP1 .         1}isStatic  ^truedefaultMenuIconName  ^#smallCancelsetUpTargetClasses  self subclassResponsibilitygrabSelectionAt: arg1  | tmp1 |  (table isIndexSelected: arg1) ifTrue: [ ^self selection ].  tmp1 := arg1 = 0 ifTrue: [ #() ] ifFalse: [ {(self itemAt: arg1)} ].  ^self newSelectionWith: tmp1belongsToCurrentBrowserContext  ^browser isClassSelected: testClasspackageView  ^packageViewcoveringTest: arg1  coveringTest := arg1testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithUndeclares >> #method1WithUndeclares in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: Object >> #printString in: environment).  self assert: query checkEmptyResultinitializeItems  items := self defaultItemschooseClassForNewMethodIfNone: arg1  targetClasses size = 1 ifTrue: [ ^targetClasses first ].  ^[ self browser searchDialog requestSingleObject: 'Where install new method?' from: (ClyAllClassesQuery as: ClyMethodVisibilityProvider defaultHierarchy asQueryResult) inScope: (ClyClassScope ofAll: targetClasses) ] on: CmdCommandAborted do: [:arg2 |  arg1 value ]switchToProjects  packageView showQuery: (systemScope projectQueryFor: self systemScope)installBreakpointInto: arg1  | tmp1 |  tmp1 := Breakpoint new     node: arg1 ast;     always.  installedBreakpoints add: tmp1.  tmp1 installisManagedByUser: arg1  isManagedByUser := arg1scopeClass  ^ClyBothMetaLevelClassScopetestRepresentsClassOfScope  scope := ClyMultipleClassRelationScope of: #() merging: {ClySuperclassScope}.  self assert: (scope representsScope: ClySuperclassScope).  self assert: (scope representsScope: ClyMultipleClassRelationScope).  self assert: (scope representsScope: ClyTypedScope).  self deny: (scope representsScope: ClySubclassScope).  self deny: (scope representsScope: ClyCompositeScope)warnUserAboutMyContext  self setUpDefaultIconclassesDo: arg1  self system classes do: arg1applyDecorations  | tmp1 |  tmp1 := textMorph hasUnacceptedEdits.  textMorph segments copy do: #delete.  IconStyler styleText: textModel withAst: editingMethod astForStylingInCalypso.  textMorph hasUnacceptedEdits: tmp1.  super applyDecorations.  browser decorateMethodEditor: selfconfirmEmptySystemQuery: arg1 excluding: arg2  | tmp1 tmp2 |  tmp2 := arg1 execute.  (tmp2 isEmpty or: [ ((tmp2 items collect: [:arg3 |  arg3 origin ]) difference: arg2) isEmpty ]) ifTrue: [ ^true ].  tmp1 := UIManager default confirm: 'There are ' , tmp2 size asString , ' ' , arg1 description , '. Show them?'.  tmp1 ifTrue: [ self spawnQueryBrowserOn: arg1 ].  ^falseretrieveStateFrom: arg1  super retrieveStateFrom: arg1.  metaLevelScope := arg1 metaLevelScope.  methodGroupQuery := arg1 methodGroupQueryautoSelect  ^autoSelecttestSimpleCondition_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'true') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: true ]')description  ^name ifNil: [ self system name ]applyResultInContext: arg1  super applyResultInContext: arg1.  arg1 activeQueryView dataSource runUpdateprintMethodTagsOrPackage  ^self isExtensionActive ifTrue: [ ownerTool extendingPackage name ] ifFalse: [ self printMethodTags ]createCellFor: arg1 in: arg2  | tmp1 |  tmp1 := ClyMainItemCellMorph on: arg1.  displayBlock value: tmp1 value: arg1.  arg2 decorateMainTableCell: tmp1 of: arg1.  tmp1 build.  ^tmp1browser  ^browserlocalScopeClass  self subclassResponsibility= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^basisObjects = arg1 basisObjectsrepresentsConcreteQuery  ^(dataSource isBasedOn: ClyUnknownQuery instance) notparentItem: arg1  parentItem := arg1execute  | tmp1 |  tmp1 := methods reject: [:arg1 |  arg1 origin = targetClass ].  tmp1 ifNotEmpty: [ (SycMoveMethodsToClassCommand methods: tmp1 class: targetClass) execute ].  methodGroup importMethods: methodsprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  selectedItems := arg1 selectedObjectstestFromSingleClass  self executeQuery.  self assert: foundSelectors equals: #(abstractMethod2 abstractSubclassMethod)buildTestSuite  | tmp1 |  tmp1 := TestSuite new.  self testMethodsDo: [:arg1 |  tmp1 addTest: (arg1 methodClass selector: arg1 selector) ].  ^tmp1groupProviderClass  ^ClyAbstractMethodGroupProviderdetachedItems  ^items collect: [:arg1 |  arg1 copy ]name  ^'Refactorings'= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^critiqueQuery = arg1 critiqueQuerytestNotAffectedByChangeOfAbstractMethodOfNotRelatedClass  self deny: (query isAffectedByChangedMethod: self class >> #createQuery)detachFromSystem  browser system unsubscribe: selfitems: arg1  items := arg1createMethodQueryFrom: arg1  ^ClyFFIMethodQuery from: arg1isGlobalVariableSelected  ^falseinitialExtent  ^850 @ 620selectedSourceNode  | tmp1 |  tmp1 := self selectedTextInterval.  ^(editingMethod astForStylingInCalypso bestNodeFor: tmp1) ifNil: [ editingMethod astForStylingInCalypso ]description  ^super description , ' filtered by ' , itemFilter printCriteriahash  ^basisObjects hashapplyChanges  | tmp1 |  tmp1 := browser compileANewClassFrom: self pendingText asString notifying: textMorph startingFrom: nil.  tmp1 ifNil: [ ^false ].  self removeFromBrowser.  browser selectClass: tmp1.  ^truecreateInheritanceScopeFrom: arg1  | tmp1 |  tmp1 := ClyClassScope ofAll: arg1 in: browser navigationEnvironment.  ^tmp1 asInheritedScopetestNotSelectsTaggedClass  self deny: (query selectsClass: ClyClass7WithTag1FromP5)execute  | tmp1 tmp2 tmp3 |  tmp1 := RGEnvironment new.  tmp2 := repositoryModel commit.  #(1) do: [:arg1 |  tmp3 := tmp2 snapshotFor: (RPackage named: packageModel name).        tmp3 importInto: tmp1 asPackageNamed: packageModel name ] displayingProgress: 'loading'.  tmp1 clean.  tmp1 browseAs: repositoryModel entity descriptioncolor  ^colorprojectSelection  ^packageView selection asSelectedParentsOf: self projectClasscollectMetadataOfProjects: arg1  selectCurrentExtensionMethodGroup  self classSelection isEmpty ifTrue: [ ^self ].  self classSelection isMultipleSelected ifTrue: [ ^self ].  (self classSelection lastSelectedItem isMarkedWith: ClyExtendedClassTag) ifFalse: [ ^self ].  self selectMethodGroupNamed: self packageSelection lastSelectedItem namedefaultMenuIconName  ^#arrowUpprepareExecutionInDropContext: arg1  super prepareExecutionInDropContext: arg1.  classGroup := arg1 lastSelectedClassGrouptestHasUnknownResultInstance  self assert: query requiredResult identicalTo: ClyUnknownQueryResult instanceswapPrioritiesBetween: arg1 and: arg2  | tmp1 tmp2 |  arg1 allowsDifferentActivationPriority ifFalse: [ ^self ].  arg2 allowsDifferentActivationPriority ifFalse: [ ^self ].  tmp1 := self overridenPriorityOf: arg1.  tmp2 := self overridenPriorityOf: arg2.  selectionPriorities at: arg1 class put: tmp2.  selectionPriorities at: arg2 class put: tmp1testCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #writer1OfVar1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #readerOfVar1 in: environment).  self assert: query checkEmptyResultisAffectedByChangedMethod: arg1  | tmp1 |  (self isFromScopeWithClassKindOf: arg1 origin) ifFalse: [ ^false ].  tmp1 := arg1 selector.  scope classesDo: [:arg2 |  (arg2 lookupSelector: tmp1) ifNotNil: [ ^true ] ].  ^falseokToChange  (tools anySatisfy: #hasUnacceptedEdits) ifFalse: [ ^true ].  ^browser confirmDiscardChangestestDoesNotExecuteAnyQuery  self deny: (query executesQuery: #any)includesClassGroupsAffectedBy: arg1  ^falseselectMethod: arg1  | tmp1 |  self changeStateBy: [ tmp1 := methodView findItemsWith: {arg1}.        tmp1 ifNotEmpty: [ ^self methodSelection selectItems: tmp1 ].        self selectClass: arg1 origin.        self classSelection isEmpty ifTrue: [ ^self ].        self methodGroupSelection beEmpty.        self methodSelection selectItemsWith: {arg1} ]methodWithoutHalts  self printStringclassNamed: arg1 ifPresent: arg2 ifAbsent: arg3  ^globals at: arg1 ifPresent: arg2 ifAbsent: arg3lastSelectedClass  ^self lastSelectedItem systemDefinition definingClasswithInheritingScope  | tmp1 |  tmp1 := self , self asInheritingScope.  tmp1 name: self class userHierarchyScopeName.  ^tmp1groupProviderClass  ^ClyExtendedMethodGroupProviderinitialize  | tmp1 |  super initialize.  self     changeTableLayout;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: 4 @ 0.  tmp1 := self theme newLabelIn: self label: '|'.  self addMorph: tmp1addItemToMenu: arg1  | tmp1 |  tmp1 := ClyCritiqueMenuItemMorph new     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     cellPositioning: #center;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     cellInset: 5;     color: Color transparent;     yourself.  tmp1 addMorphBack: (ImageMorph withForm: critique icon).  tmp1 addMorphBack: critique title asStringMorph.  critique actions do: [:arg2 |  tmp1 addMorphBack: (IconicButton new                 target: arg2;                 labelGraphic: arg2 icon;                 actionSelector: #actOnCritic:ofEntity:;                 arguments: {critique .                     entity};                 color: Color transparent;                 helpText: arg2 description;                 extent: 16 @ 16;                 borderWidth: 0;                 yourself) ].  ^arg1 addMenuItem: tmp1asScope: arg1  ^selftestDescendingSamePackageSameClassDifferentSelector  function := ClySortMethodByPackageFunction descending.  self deny: (function value: Object >> #printString value: Object >> #yourself).  self assert: (function value: Object >> #yourself value: Object >> #printString)itemObserver: arg1  itemObserver := arg1createQuery  ^ClyMessageImplementorsQuery of: self targetSelector from: (ClyClassScope of: Object in: environment)environment: arg1  environment := arg1prepareBasisFrom: arg1  ^arg1 asIdentitySetaddCommandItem: arg1  commandBar addMorphBack: arg1.  ^arg1openAnotherBrowser: arg1  (arg1 isKindOf: ClyQueryBrowser) ifTrue: [ arg1 openInWindow: self window ] ifFalse: [ arg1 open ]prepareFullExecutionInContext: arg1  | tmp1 |  super prepareFullExecutionInContext: arg1.  method := arg1 lastSelectedMethod.  tmp1 := method package name.  repository := IceRepository registry detect: [:arg2 |  arg2 includesPackageNamed: tmp1 ]subqueries: arg1  | tmp1 |  arg1 ifEmpty: [ ^self error: 'Composite query must have at least one subquery' ].  subqueries := arg1 asSet.  tmp1 := subqueries collect: [:arg2 |  arg2 scope ].  scope := ClyCompositeScope on: tmp1.  self requiredResult: subqueries anyOne requiredResultclassNamed: arg1  ^globals classNamed: arg1itemFilterClass: arg1  itemFilterClass := arg1setUp  | tmp1 |  super setUp.  tmp1 := self createQuery.  queryResult := tmp1 execute.  itemObserver := ClyItemObserverExample new.  cursor := queryResult openBrowserCursorFor: itemObserverdescription  ^'extending packages'doesAnyManager: arg1 belongsTo: arg2  ^arg1 anySatisfy: [:arg3 |  arg3 notNil and: [ self doesNodeOf: arg3 belongsTo: arg2 ] ]activeQueryView  ^self browser navigationViews detect: [:arg1 |  arg1 createSelectionContext class = self class ]classScopeOfSelectedItems  | tmp1 |  tmp1 := self selection items collect: [:arg1 |  arg1 systemDefinition definingClass ].  ^ClyBothMetaLevelClassScope ofAll: tmp1 in: navigationEnvironmentbuildGroupsForAll: arg1  | tmp1 |  tmp1 := ClyPackageScope ofAll: arg1 in: environment.  groupProvider classGroupsIn: tmp1 do: [:arg2 |  builtGroups add: arg2 ]start: arg1  start := arg1defaultMenuIconName  ^#komitterSmalltalkhubRemoterequiredResult: arg1  requiredResult := arg1.  self shouldBeProtectedByWriteBarrier ifTrue: [ requiredResult beReadOnlyObject ]asScope: arg1 ofAll: arg2  ^arg1 ofAll: arg2 in: environmentwithScope: arg1  self subclassResponsibilitydecorateItemGroup: arg1  arg1 markWithChildrenOf: self resultItemsTypemetalinkManagerClass  self subclassResponsibilitybelongsToCurrentBrowserContext  ^browser isClassSelected: methodClass instanceSidetestIsAffectedByChangeOfAbstractMethodWhichIsNotImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #abstractMethod2).  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractSubclassMethod)beBoldIfActive  self isModeActive ifTrue: [ radioButton labelMorph emphasis: TextEmphasis bold emphasisCode ] ifFalse: [ radioButton labelMorph emphasis: TextEmphasis normal emphasisCode ]setUpParametersFromModel  editingMethod := testClass lookupSelector: #setUp.  super setUpParametersFromModelinitialize  super initialize.  expandedItems := SortedCollection sortBlock: [:arg1 :arg2 |  arg1 position < arg2 position ]initialize  super initialize.  needsRebuild := false.  self initializeItems.  self collectMetadataactiveStatusBar  ^self selectedTools first statusBardetachFromSystem  environment system unsubscribe: self.  super detachFromSystemorderForBrowser  ^3criteriaBlock: arg1  criteriaBlock := arg1createQuery  ^ClyConstantQuery returning: #(item1 item2) from: (ClyScopeExample emptyIn: environment)execute  browser closeprintContext  ^methodClass printSystemPath , ' / ' , methodClass nametestSelf_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'self') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: ThisContext receiver ]')isEmpty  self subclassResponsibilityprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  packages := browser searchDialog requestMultipleObjects: 'Select package scope' from: ClyAllPackagesQuery sorted.  packages ifEmpty: [ CmdCommandAborted signal ]checkEmptyResult  scope packagesDo: [:arg1 |  arg1 tagsForClasses ifNotEmpty: [ ^scope isQueryEmpty: ClyUntaggedClassesQuery new ] ].  ^trueupdateCacheForMethod: arg1  allImplementorsCache ifNil: [ ^self ].  cacheGuard critical: [ arg1 isInstalled ifTrue: [ self cacheMethod: arg1 ] ifFalse: [ self removeMethodFromCache: arg1 ] ]setUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyInheritanceAnalysisEnvironmentPlugin newdefaultMenuItemName  ^'Find class'testRetrievesNavigationHistory  self snapshotState.  self assert: navigationState navigationHistory equals: browser navigationHistoryaddToolbarItemInto: arg1 using: arg2  | tmp1 |  tmp1 := ClyScopeCompoBox for: browser.  arg1 addNewItem: tmp1providesGroupsAffectedBy: arg1 inScope: arg2  | tmp1 |  tmp1 := self createMethodQueryFrom: arg2.  ^tmp1 isResult: ClyUnknownQueryResult instance affectedBy: arg1defaultMenuItemName  ^'Remove'testClassEnumerationOverClassWhenClassSideIsLocalScope  | tmp1 |  scope := ClySubclassScope of: Class localScope: ClyClassSideScope.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := Class subclasses select: #isInstanceSide thenCollect: #classSide.  self assert: result asSet equals: tmp1 asSetprintDefinition  ^self printDefiningClassasRBEnvironment  | tmp1 |  tmp1 := subscopes first asRBEnvironment.  subscopes allButFirstDo: [:arg1 |  tmp1 := tmp1 | arg1 asRBEnvironment ].  ^tmp1testItemsChangedNotificationShouldResetItems  queryResult initializeItems.  self assert: queryResult isBuilt.  queryResult itemsChanged.  self deny: queryResult isBuilt.  self assert: queryResult items isNilcreateMethodGroupFor: arg1 from: arg2  ^ClyAllMethodGroup withMethodQuery: arg1 andClassesInheritedFrom: arg2prepareFullExecutionInContext: arg1  | tmp1 |  super prepareFullExecutionInContext: arg1.  classGroup := arg1 lastSelectedClassGroup.  classGroup classesSize > 0 ifTrue: [ tmp1 := UIManager default confirm: 'Are you sure you want to remove all classes in group ' , classGroup name , '?'.        tmp1 ifFalse: [ CmdCommandAborted signal ] ]testCheckIfEmpty  query scope: (ClyMethodScope of: ClySubclassLOfClass0FromPExtendedByP1 >> #extensionMethodFromSubclassL in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self assert: query checkEmptyResultisInlined  ^truetestIsBoundToEnvironmentWhenScopeIs  self assert: query scope isBoundToEnvironment.  self assert: query isBoundToEnvironmentqueryScopes  ^queryScopesfullDescription  ^self description , ' from ' , (scope isBasedOnEmptyBasis ifTrue: [ 'empty scope' ] ifFalse: [ scope description ])testMoveToItemWhichSatisfiesCondition  | tmp1 |  tmp1 := cursor moveToItemWhich: [:arg1 |  arg1 actualObject = Object ].  self assert: tmp1.  self assert: cursor position equals: 2.  self assert: cursor currentItem actualObject equals: Objectname: arg1  name := arg1browser  ^browsercreateQueryFromScopeOf: arg1  ^self createQueryFromScope: (ClyScopeExample of: arg1)description  ^'classes without tags'activationPriority  ^browser methodGroupSelection isEmpty ifTrue: [ 0 ] ifFalse: [ ClyClassDefinitionEditorToolMorph tabOrder + 1 ]classesDo: arg1  self packagesDo: [:arg2 |  arg2 definedClasses do: arg1 ]allClassesRelatedTo: arg1 do: arg2  | tmp1 |  tmp1 := localScopeClass metaLevelForHierarchyOf: arg1.  self classesRelatedTo: tmp1 do: [:arg3 |  (localScopeClass metaLevelForHierarchyOf: arg3) = arg3 ifTrue: [ arg3 isObsolete ifFalse: [ self metaLevelsOf: arg3 do: arg2 ].              self allClassesRelatedTo: arg3 do: arg2 ] ]doesMethodHasWatchpoint: arg1  ^self doesAnyManager: Watchpoint allWatchpoints belongsTo: arg1buildTestSuite  | tmp1 |  tmp1 := TestSuite new.  self testMethodsDo: [:arg1 |  arg1 isFailedTest | arg1 isErrorTest ifTrue: [ tmp1 addTest: (arg1 methodClass selector: arg1 selector) ] ].  ^tmp1decorateOwnBrowserItem: arg1  super decorateOwnBrowserItem: arg1.  methodQuery decorateItemGroup: arg1.  subgroupsQuery decorateItemGroup: arg1scopeClass  ^ClyPackageExtensionScopeisFilterActive  table initialDataSource ifNil: [ ^false ].  ^self dataSource ~~ table initialDataSourcetestClassFor: arg1  | tmp1 tmp2 |  tmp1 := self testClassNameFor: arg1.  self systemEnvironment classNamed: tmp1 ifPresent: [:arg2 |  tmp2 := arg2 ] ifAbsent: [ (self isValidClass: arg1) ifFalse: [ ClyInvalidClassForTestClassGeneration signalFor: arg1 ].        self systemEnvironment ensureExistAndRegisterPackageNamed: arg1 package name asString , '-Tests'.        tmp2 := TestCase subclass: tmp1 instanceVariableNames: '' classVariableNames: '' package: (self newTestClassCategoryFor: arg1).        self addNewCommentForTestClass: tmp2 basedOn: arg1 ].  ^tmp2updateWindowTitle  self window ifNotNil: [:arg1 |  self setWindowTitle: self newWindowTitle in: arg1.        (self ownerThatIsA: GroupWindowMorph) ifNotNil: [:arg2 |  arg2 window ifNotNil: [:arg3 |  self setWindowTitle: arg1 labelString in: arg3 ] ] ]execute  browser switchToPackageScopeOf: packagessetUpEnvironment  environment := ClyNavigationEnvironment newtestConvertingToInheritedScope  | tmp1 |  scope := ClyCompositeScope on: {(ClyInstanceSideScope of: Object in: environment) .         (ClyClassSideScope of: Array in: environment)}.  tmp1 := scope asInheritedScope.  self assert: tmp1 class equals: ClyCompositeScope.  self assert: (tmp1 subscopes first representsScope: ClySuperclassScope).  self assert: (tmp1 subscopes last representsScope: ClySuperclassScope).  self assert: (tmp1 subscopes collect: #localScopeClass as: Set) equals: {ClyInstanceSideScope .         ClyClassSideScope} asSet.  self assert: tmp1 environment equals: environment.  self assert: tmp1 name equals: ClyClassScope inheritedScopeNameactionBlock: arg1  actionBlock := arg1tag  ^methodQuery tagcreateCriticView  criticView := ClyQueryViewMorph for: self.  criticView     name: 'critiques table';     hResizing: #spaceFill;     vResizing: #rigid;     borderWidth: 4;     borderColor: browserTool containerTab backgroundColor.  criticView height: 50selectedTabs  ^selectedTabsprepareStateBeforeExecution  testCurrentItem  | tmp1 |  tmp1 := cursor currentItem.  self assert: tmp1 class equals: ClyBrowserItem.  self assert: tmp1 isPrepared.  self assert: tmp1 position equals: 1implementorSelector  ^implementorMethod selectortestCaseResults  ^testCaseResultsexecute  methodGroups do: #removeWithMethodsprovidesGroupsAffectedBy: arg1 inScope: arg2  arg2 packagesDo: [:arg3 |  (arg1 affectsPackage: arg3) ifTrue: [ ^true ] ].  ^falsetestApplyingToQueryViewShouldCreateOpenedDataSource  | tmp1 |  self snapshotState.  tmp1 := ClyQueryViewMorph for: browser.  navigationState applyTo: tmp1.  self assert: tmp1 dataSource ~~ navigationState dataSource.  self deny: tmp1 dataSource isClosed.  self assert: tmp1 dataSource queryView equals: tmp1.  self assert: tmp1 dataSource table notNiltestFillingWithOnlyTraitWithoutUsers  queryResult fillWith: {ClyTraitRoot1}.  self assertItems: {ClyTraitRoot1 .         0}testExecution  self executeQuery.  self assert: foundSelectors equals: #(methodWithHalt methodWithHalt2)supportsCriticDecoration  ^package notNillocalHierarchySize  | tmp1 |  tmp1 := self getProperty: ClyItemLocalHierarchyProperty ifAbsent: [ ^0 ].  ^tmp1 subtreeSizeisSelectedItemHasExecutionCounter  ^selectedSourceNode hasExecutionCounterspotterForGoToFor: arg1  < spotterOrder: 10>  arg1 listProcessor     title: 'Go to';     allCandidates: [ self collectGoToCandidates ];     itemName: #name;     itemIcon: #icon;     candidatesLimit: 10;     filter: GTFilterSubstring;     actLogic: [:arg2 :arg3 |  arg3 exit.        arg2 activate ]classes  ^globals allClassesAndTraits= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^pattern = arg1 patterntoggleScope  ^self isActive ifTrue: [ self deactivateExtraScope ] ifFalse: [ self activateExtraScope ]fillWith: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self scope asLocalClassScope.  tmp2 := hierarchy buildFrom: arg1.  tmp3 := Set new.  tmp2 doInOrderWithDepth: [:arg2 :arg3 |  (tmp3 includes: arg2) ifFalse: [ tmp3 add: arg2.              self buildGroupFor: arg2 depth: arg3 toShowMethodsFrom: tmp1 ] ]criticAnalysisScope  ^ClyClassScope of: editingClass in: browser navigationEnvironmentitemCount  ^self dataSource numberOfRowsshouldBuildGroupWith: arg1  self isStatic ifFalse: [ ^true ].  ^arg1 hasEmptyResult notreadParametersFromContext: arg1  super readParametersFromContext: arg1.  testItems := arg1 selectedItems select: [:arg2 |  arg2 hasProperty: ClyTestedMethodProperty ]mainColumn  ^table columns detect: #isMainColumnactualResult  ^actualResultitemsStartingWhere: arg1 count: arg2  | tmp1 |  tmp1 := items findFirst: arg1.  tmp1 = 0 ifTrue: [ ^#() ].  ^self itemsStartingAt: tmp1 count: arg2testDetectingDefiningClassFromClassSide  | tmp1 tmp2 |  tmp1 := ClyClass2FromP1 classVariableNamed: #ClassVar1.  tmp2 := ClyClassVariable on: tmp1 visibleFrom: ClyClass2FromP1 class.  self assert: tmp2 definingClass equals: ClyClass2FromP1= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^subqueries = arg1 subqueriesisStatic  ^trueprocessMethodChange: arg1  | tmp1 |  self updateCacheForMethod: arg1 methodAffected.  tmp1 := arg1 methodAffected.  tmp1 methodClass superclass ifNotNil: [:arg2 |  (arg2 lookupSelector: tmp1 selector) ifNotNil: [:arg3 |  ^environment systemChanged: (ClyOverriddenMethodChanged method: arg3) ] ].  tmp1 methodClass subclasses ifEmpty: [ ^self ].  environment systemChanged: (ClyOverridingMethodsChanged initiatedBy: self forOverriddenMethod: tmp1)printBasisObject: arg1 on: arg2  ^arg2 nextPutAll: arg1 nameshowClass: arg1  tool selectClass: arg1notDeprecatedMethod  when: arg1 send: arg2 to: arg3  changesAnnouncer weak when: arg1 send: arg2 to: arg3methodGroupQuery: arg1  methodGroupQuery := arg1classGroupsIn: arg1 do: arg2  | tmp1 tmp2 |  tmp1 := Dictionary new.  arg1 packagesDo: [:arg3 |  arg3 tagsForClasses do: [:arg4 |  tmp1 at: arg4 ifAbsentPut: [ tmp2 := ClyTaggedClassGroup withClassesFrom: arg1 taggedBy: arg4.                    arg2 value: tmp2.                    tmp2 ] ] ]description  ^'Method call counters'execute  browser spawnQueryBrowserOn: (ClyVariableWritersQuery ofAny: variables)lastSelectedObject  ^self lastSelectedItem actualObjecteditingText  self flag: #pharoTodo.  ^editingClass definitionisPackageSelected  ^self selectedPackageItems notEmptyisSelectedItemHasBreakpoint  ^selectedItems anySatisfy: [:arg1 |  arg1 isMarkedWith: ClyMethodWithBreakpointTag ]selectsMethod: arg1  ^arg1 usesUndeclaresclassSampleWhichHasGroup  ^ClyAbstractClassExampletestMethodsEnumerationOverInstanceSideWhenBothMetaLevelsAreLocalScope  | tmp1 |  scope := ClySuperclassScope of: ClyClass1FromP1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:arg1 |  result add: arg1 ].  tmp1 := {Object .   Object class .   ProtoObject .   ProtoObject class} flatCollect: #localMethods as: IdentitySet.  self assert: result asIdentitySet equals: tmp1testHasCompositeScopeFromSubqueries  | tmp1 |  tmp1 := query scope.  self assert: tmp1 class equals: ClyCompositeScope.  self assert: tmp1 subscopes equals: (query subqueries collect: #scope)testCompareClassesAndMethods  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object)asInheritedScope  | tmp1 |  tmp1 := subscopes collect: [:arg1 |  arg1 asInheritedScope ].  ^ClyCompositeScope on: tmp1 in: environment named: ClyClassScope inheritedScopeNamedoesItemHaveChildren: arg1  self subclassResponsibilityprintBasisObject: arg1 on: arg2  ^arg1 printOn: arg2decorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 definitionIcon: #protocolExtensionIcontargetClass: arg1  targetClass := arg1selectedMethodItems  ^tool methodSelection itemsdesiredSelection  ^desiredSelectionbuildResult: arg1  self subclassResponsibilitydescription  ^'classes tagged with ' , tagtoggle  textMorph wrapped ifTrue: [ textMorph beNotWrapped ] ifFalse: [ textMorph beWrapped ].  self updateLabelselectSourceNode: arg1  textMorph setSelection: arg1 sourceIntervalgroupName  ^groupNameclassNamesContainingIt  | tmp1 |  self lineSelectAndEmptyCheck: [ ^self ].  tmp1 := ClyAllClassesQuery new filteredBy: (ClyItemNameFilter substringPattern: self selection string).  self browser spawnQueryBrowserOn: tmp1printOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     nextPutAll: annotatedClass name.  targetItemType ifNotNil: [ arg1           nextPutAll: '; ';           nextPutAll: targetItemType name ].  arg1 nextPut: $)testFillingWithOnlyClassWhichHasTraits  queryResult fillWith: {ClyClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0}collapse: arg1  queryView changeStateBy: [ expandedItems remove: arg1.        arg1 childrenDataSource close.        self expansionChanged ]methodClass  self subclassResponsibilitydescription  ^'all variables'testBuildsDefaultResultByDefault  self assert: query buildsDefaultResultinstanceSideVar1ReaderMethod  ^instanceSideVar1isTestClass: arg1  ^arg1 isTestCase or: [ arg1 users anySatisfy: [:arg2 |  self isTestClass: arg2 ] ]createSelectionContextOf: arg1  ^ClyContextSelectionStrategy selectContextOf: arg1 for: browserincludesClassNamed: arg1  ^self environment includesClassNamed: arg1selectsMethod: arg1  ^truetestFindTestedClassCoveredByTestCaseWithoutSuffix  | tmp1 |  tmp1 := plugin findTestedClassCoveredBy: ClyTestedClass ifAbsent: [ #noResult ].  self assert: tmp1 equals: #noResultincludesVariablesAffectedBy: arg1  ^falsetestFromSingleClass  self queryFromScope: ClyInstanceSideScope of: ClyClass1FromP1.  self assert: (resultItems collect: #class as: Set) equals: {ClyAllMethodGroup .         ClyTaggedMethodGroup} asSet.  self assert: (resultItems select: [:arg1 |  arg1 class = ClyTaggedMethodGroup ] thenCollect: #tag) asSet equals: ClyClass1FromP1 tagsForMethods asSettestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClass1FromP1 >> #tag1Method1) .         (Object >> #printString) .         (ClySubclassLOfClass0FromPExtendedByP1 >> #extensionMethodFromSubclassL)}.  self assert: foundSelectors equals: #(#extensionMethodFromSubclassL)collectAllClasses  | tmp1 |  tmp1 := OrderedCollection new: basisObjects size.  self classesDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1isExtensionActive  ^ownerTool extendingPackage notNilexecuteQuery  result := query execute.  resultItems := result itemsmethodSourceContainingIt  | tmp1 tmp2 |  self lineSelectAndEmptyCheck: [ ^self ].  tmp2 := self selection string.  tmp1 := (ClyMethodSourcesQuery withString: tmp2) , (ClyClassCommentsQuery withString: tmp2).  self browser spawnQueryBrowserOn: tmp1level  ^#(information warning error) indexOf: nameasCalypsoBrowserItem  ^selfmethodsDo: arg1  self classesDo: [:arg2 |  self metaLevelsOf: arg2 do: [:arg3 |  arg3 methods do: arg1 ] ]isResult: arg1 affectedBy: arg2  ^falserequestPackage  | tmp1 |  tmp1 := ownerTool context requestSinglePackage: 'Choose package for method'.  ownerTool extendingPackage: tmp1selectedClassSide  ^tool currentMetaLevelOf: self lastSelectedClassswitchToFullClassHierarchyOf: arg1  | tmp1 |  tmp1 := ClyInstanceSideScope of: arg1 in: navigationEnvironment.  self switchClassViewTo: ClyHierarchicallySortedClasses new inScope: tmp1 asFullHierarchyScopehasMetaProperty: arg1  ^self itemCursor hasMetaProperty: arg1isBasedOnItemType: arg1  ^self isEmpty ifTrue: [ rootDataSource isBasedOnQueryOf: arg1 ] ifFalse: [ self lastSelectedItem isBasedOnItemType: arg1 ]testComparisonWithCopy  | tmp1 |  tmp1 := queryResult copy.  self assert: queryResult equals: tmp1execute  | tmp1 tmp2 tmp3 |  tmp2 := package name.  classTag ifNotNil: [ tmp2 := tmp2 , '-' , classTag ].  tmp1 := 'Trait named: #TNameOfTrait	uses: {}	package: ''' , tmp2 , ''''.  tmp1 := UIManager default multiLineRequest: 'Define trait definition:' initialAnswer: tmp1 answerHeight: 250.  tmp1 isEmptyOrNil ifTrue: [ ^self ].  tmp3 := browser compileANewClassFrom: tmp1 notifying: nil startingFrom: nil.  tmp3 ifNotNil: [ browser selectClass: tmp3 ]createQuery  ^ClyAllClassVariablesQuery from: ClyClassScope of: ClyClass2FromP1 in: environmentexecute  | tmp1 |  tmp1 := methodEditor tagsAndPackageEditor.  tmp1 resetTagsAndPackagetestGettingItemsStartingAtGivenPosition  | tmp1 |  queryResult fillWith: #(1 2 3 4 5 6).  tmp1 := queryResult itemsStartingAt: 3 count: 2.  self assert: tmp1 asArray equals: #(3 4)buildParentMap: arg1 for: arg2  | tmp1 tmp2 |  tmp1 := IdentitySet withAll: arg2 traits.  [ tmp1 isEmpty ] whileFalse: [ tmp2 := tmp1 anyOne.        tmp1 remove: tmp2.        (arg1 includesClass: tmp2) ifTrue: [ arg1 addChild: arg2 to: tmp2 ] ifFalse: [ tmp1 addAll: tmp2 traits ] ]buildResult: arg1  self shouldNotImplementmergedParts  ^mergedPartsaddIcon: arg1  classSampleWhichHasGroup  self subclassResponsibilitytestBuildingGroups  self buildGroupsFor: self classSampleWhichHasGroup.  self assert: builtGroups notEmptycheckEmptyResult  ^subqueries allSatisfy: [:arg1 |  arg1 hasEmptyResult ]instanceVariablesDo: arg1  self classesDo: [:arg2 |  self instanceVariablesOf: arg2 do: arg1 ]createCommandContext  ^ClyGlobalContextOfFullBrowser for: selfshouldBeAppliedFor: arg1  targetItemType ifNil: [ ^true ].  ^arg1 isBasedOnItemType: targetItemTypemethods  ^methodQuery execute itemsaffectsMethodsDefinedInPackage: arg1  overriddenSuperclass withAllSubclassesDo: [:arg2 |  arg2 package = arg1 ifTrue: [ ^true ] ].  ^falsetestConvertingToFullHierarchyScope  | tmp1 tmp2 |  scope := self createSampleScope.  tmp2 := scope asInheritedScope.  tmp1 := scope asFullHierarchyScope.  self assert: tmp1 class equals: ClyCompositeScope.  self assert: tmp1 name equals: ClyClassScope hierarchyScopeName.  self assert: (tmp1 subscopes includes: scope).  self assert: (tmp1 subscopes includes: tmp2).  self assert: (tmp1 subscopes includes: (ClySubclassScope ofAll: scope basisObjects localScope: scope class))kmDispatcher  ^CmdKMDispatcher attachedTo: selftestRan: arg1  | tmp1 tmp2 tmp3 |  tmp2 := arg1 testResult.  tmp3 := self findTestedClassCoveredBy: tmp2 ifAbsent: [ ^self ].  tmp1 := ClyTestCaseRan testCase: tmp3.  environment systemChanged: tmp1newWindowTitle  | tmp1 |  packageView selection isEmpty ifTrue: [ ^self systemScope description ].  tmp1 := self buildTitleFromSelections.  self systemScope isCurrentImage ifFalse: [ tmp1 := tmp1 , ' in ' , self systemScope description ].  ^tmp1description  ^'implementors of ' , self printSelectorsleftSideBar  ^textMorph rulerNamed: #textSegmentIconsupdate  label color: label defaultColor.  label contents: self printMethodTagsOrPackage.  self isExtensionActive ifTrue: [ editButton helpText: 'Choose package for method' ] ifFalse: [ editButton helpText: 'Classify method' ]doesItemHaveChildren: arg1  | tmp1 |  arg1 childrenDataSource ifNotNil: [:arg2 |  ^arg2 isEmpty not ].  self definesChildren ifFalse: [ ^false ].  tmp1 := queryView queryToExpand: arg1 ifAbsent: [ ^false ].  ^arg1 browserItem hasChildrenWhich: [:arg3 |  tmp1 retrievesItemsOfType: arg3 ]async  ^selfsetUpEnvironment  super setUpEnvironment.  environment system: ClySystemEnvironment currentImagetestNotSelectsMethodWithoutCritiques  self deny: (query selectsMethod: ClyClassWithProblemMethods >> #methodWithoutCritiques)collectMetadata  metadata := ClyQueryResultMetadata new.  environment pluginsDo: [:arg1 |  buildingQuery collectMetadataOf: self by: arg1 ]itemsStartingAt: arg1 count: arg2  ^self prepareItems: (actualResult itemsStartingAt: arg1 count: arg2)requiredResult  ^requiredResulteditingPackage: arg1  editingPackage := arg1prepareInitialState  self subclassResponsibilitytestFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #writer1OfVar1) .         (self class >> #readerOfVar1)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #writer1OfVar1testFillingSimpleInstance  query := ClyAllClassesQuery from: ClyPackageScope of: ClyClass1FromP1 package in: environment.  queryResult := ClyExtensionLastSortedClasses simple prepareNewFor: query in: environment.  queryResult buildWith: {ClySubclassLOfClass0FromPExtendedByP1 .         ClySubclassN1OfClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassN1OfClass1FromP1 .         0 .         ClySubclassLOfClass0FromPExtendedByP1 .         0}.  self assert: (items last isMarkedWith: ClyExtendedClassTag).  self deny: (items first isMarkedWith: ClyExtendedClassTag).  self deny: (items second isMarkedWith: ClyExtendedClassTag)affectsCritiques  ^falseresolveMetadataOfCritiques: arg1  withScope: arg1  | tmp1 |  tmp1 := subqueries collect: [:arg2 |  arg2 withScope: arg1 ].  ^self withSubqueries: tmp1description  ^'all packages'testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(reference1OfVar1 reference2OfVar1 #supeclassReferenceOfVar1)executeRedoBy: arg1  redoExecuting := true.  arg1 ensure: [ redoExecuting := false.        waitingNewState := true ]compileANewClassFrom: arg1 notifying: arg2 startingFrom: arg3  | tmp1 |  tmp1 := RGChunkImporter new.  tmp1 environment: self environment.  tmp1 fileInFrom: (arg1 , '!') readStream.  ^arg3defaultMenuItemName  ^'Move to method group'changesAreAboutApply  selectedClassGroups  ^self selectedObjectsinitialize  super initialize.  self     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWraprepresentsScope: arg1  ^subscopes anySatisfy: [:arg2 |  arg2 representsScope: arg1 ]testComparisonOfSameQueriesWithDifferentRequestedContent  | tmp1 |  query requiredResult: #contentClass1.  tmp1 := self createQuery.  tmp1 requiredResult: #contentClass2.  self deny: query equals: tmp1isClassSelected  | tmp1 |  tmp1 := self selectedSourceNode.  tmp1 isVariable ifFalse: [ ^false ].  ^tmp1 binding isLiteralVariable and: [ tmp1 binding isGlobalClassNameBinding ]fillWith: arg1  self subclassResponsibilitytestFindTestedClassCoveredByTestCase  | tmp1 |  tmp1 := plugin findTestedClassCoveredBy: ClyTestedClassTest ifAbsent: [  ].  self assert: tmp1 equals: ClyTestedClassclassVariablesOf: arg1 do: arg2  arg1 instanceSide classVariables associationsDo: [:arg3 |  arg2 value: (ClyClassVariable on: arg3 definedIn: arg1 instanceSide) ]actualObjectSortFunction  ^actualObjectSortFunctiondefaultMenuItemName  ^'Remove'isRedundant  extraClassScope asInterestingClassScope classesDo: [:arg1 |  ^false ].  ^truebuild  self buildResetButton.  self addMorphBack: resetButton.  self buildEditButton.  self addMorphBack: editButton.  self buildLabel.  self addMorphBack: label.  self buildExtensionCheckBoxButton.  self addMorphBack: extensionCheckbox.  self updateclyMessageImplementor1  classAffected  ^testCasetestIsAffectedByChangeOfOwnMethodWhichIsNotOverridden  self assert: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)hash  ^super hash bitXor: localScopeClass hashtoggle  Slot showSlotClassDefinition: Slot showSlotClassDefinition not.  ownerTool updatebrowser  ^tool browserbindingOf: arg1  ^self selectedClassOrMetaClass bindingOf: arg1hasSubscriber: arg1  announcer ifNil: [ ^false ].  ^announcer hasSubscriber: arg1hasUnacceptedEdits  textMorph ifNil: [ ^false ].  ^textMorph hasUnacceptedEditstestForClassVariable  | tmp1 |  tmp1 := ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1.  query := ClyVariableReferencesQuery of: tmp1.  self queryFromScope: ClyClassScope of: ClyClass2FromP1.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(instanceSideClassVar1Reader instanceSideClassVar1Writer)defaultMenuItemName  ^'Debug the exception'testMatchesMethodOfPackageWhichMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'SystemQueries-Tests'.  self assert: (filter matches: self itemOfThisTestMethod)standardMessageText  ^String streamContents: [:arg1 |  arg1 print: self baseClass.        arg1 nextPutAll: ' is not a valid class to generate a test class' ]testNotSelectsMethodOnWhichItIsBased  self deny: (query selectsMethod: Point >> #x)newSelectionWith: arg1  ^self dataSource newSelectionWith: arg1initialize  super initialize.  badScript := falsesetUpModelFromContext  super setUpModelFromContext.  editingMethod := context lastSelectedMethodrootDataSource: arg1  rootDataSource := arg1decorateBrowserItem: arg1 ofMethod: arg2  arg2 isDeprecated ifTrue: [ arg1 markWith: ClyDeprecatedItemTag ]initialize  super initialize.  extraMethods := IdentitySet newhierarchy: arg1  hierarchy := arg1testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWhichInheritsAbstractClass >> #abstractMethod1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWhichInheritsAbstractClass >> #overriddenMethod in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod in: environment).  self assert: query checkEmptyResultdescription  ^'class variables'isCurrentImage  ^falsemethods  ^methodshandleSystemChange: arg1  needsRebuild ifTrue: [ ^self ].  arg1 shouldBeConsideredByCalypsoEnvironment ifFalse: [ ^self ].  self protectAccessWhile: [ (buildingQuery isResult: self affectedBy: arg1) ifTrue: [ self itemsChanged ] ]metadata: arg1  metadata := arg1applyTo: arg1 byUndo: arg2  (window isInWorld and: [ (browserState isCurrentStateOf: window model) not ]) ifTrue: [ ^self ].  navigationHistory recordAcrossWindowNavigationFrom: arg1 byUndo: arg2.  arg2 ifTrue: [ arg1 close ].  self restoreBrowserWindow.  window model focusActiveTabcollectMetadata  self protectAccessWhile: [ metadata ifNotNil: [ ^self ].        metadata := ClyQueryResultMetadata new.        environment pluginsDo: [:arg1 |  buildingQuery collectMetadataOf: self by: arg1 ] ]menuColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self grabSelectionAt: arg2.  tmp2 := self createSelectionContextOf: tmp1.  ^CmdContextMenuActivation buildContextMenuFor: self inContext: tmp2createClassGroupFor: arg1 from: arg2  ^ClyNoTagClassGroup named: 'Uncategorized' priority: 100 on: arg1initialize  super initialize.  navigationStarted := false.  navigationHistory := ClyNavigationHistory new.  plugins := SortedCollection sortBlock: [:arg1 :arg2 |  arg1 priority <= arg2 priority ].  self extent: self initialExtent.  self changeProportionalLayout.  self initializeToolsPanel.  self initializeNavigationPanel.  self addPaneSplitterstestRetrievesSystemScope  self snapshotState.  self assert: navigationState systemScope equals: environment systemScoperestoreNavigationStateOf: arg1  arg1 navigationViews with: viewStates do: [:arg2 :arg3 |  arg2 ignoreNavigationDuring: [ arg3 applyTo: arg2 ] ]async  ^selfprintCursorPosition  | tmp1 tmp2 |  tmp2 := self textArea.  tmp2 selectionStart ifNil: [ ^'' ].  tmp2 paragraph lines ifNil: [ ^'' ].  tmp1 := self printTextLinePositionOf: tmp2 selectionStart.  tmp2 selectionStop ~= tmp2 selectionStart ifTrue: [ tmp1 := tmp1 , ' -- ' , (self printTextLinePositionOf: tmp2 selectionStop) ].  ^tmp1buildResult: arg1  | tmp1 tmp2 |  tmp1 := baseCritiqueQuery execute.  tmp2 := tmp1 items select: [:arg2 |  self selectsCritique: arg2 ].  arg1 fillWith: tmp2createQuery  ^ClyMessageSendersQuery of: self referencedSelector from: (ClyClassScope of: Object in: environment)protectAccessWhile: arg1  ^accessGuard critical: [ arg1 value ]selectsMethod: arg1  self subclassResponsibilitytestFillingWithClassWithoutTraits  queryResult fillWith: {ClyClassWithoutTraits}.  self assertItems: {ClyClassWithoutTraits .         0}testConvertingWithExtraBasisObjectWhenThereIsExtraScopeParameter  | tmp1 |  scope := self singleScopeSample.  scope extraParameter: #testParameter.  tmp1 := scope withExtraBasisObject: self extraBasisSample.  self assert: tmp1 extraParameter equals: #testParameterrepresentsObjectEqualTo: arg1  actualObject == arg1 ifTrue: [ ^true ].  type = arg1 calypsoEnvironmentType ifFalse: [ ^false ].  ^type checkCalypsoItem: actualObject isEqualTo: arg1editingText  ^self classTemplatemetaLevelsOf: arg1 do: arg2  localScopeClass metaLevelsOf: arg1 do: arg2leftMethod  ^leftMethodbrowser  ^browserfindItemsWith: arg1  | tmp1 |  ^actualResult protectItemsWhile: [ tmp1 := arg1 collect: [:arg2 |  actualResult items detect: [:arg3 |  arg3 representsObjectEqualTo: arg2 ] ifNone: nil ].        self prepareItems: tmp1 ]isResult: arg1 affectedBy: arg2  self flag: #todo.  ^falseretrieveStateFrom: arg1  systemScope := arg1 systemScope.  viewStates := arg1 navigationViews collect: [:arg2 |  arg2 snapshotState ].  selectedTabs := arg1 tabManager selectedTools collect: [:arg2 |  arg2 copyForBrowserStateSnapshot ]asInterestingClassScope  | tmp1 |  tmp1 := subscopes collect: [:arg1 |  arg1 asInterestingClassScope ].  ^ClyCompositeScope on: tmp1 in: environment named: nameautoSelect: arg1  autoSelect := arg1allNavigationScopes  | tmp1 |  tmp1 := self defaultNavigationScope.  ^self systemScope = tmp1 ifTrue: [ {self systemScope} ] ifFalse: [ {self systemScope .         tmp1} ]properties: arg1  properties := arg1rebuildToolsForChangedEnvironment  super rebuildToolsForChangedEnvironment.  tabManager tools ifEmpty: [ resultView ensureSelectedItem.        self rebuildAllTools ].  self updateWindowTitlemethodGroupQuery  ^methodGroupQueryisMethodSelected  ^self selectedMethodItems notEmptytoggleExtension  self requestChangeBy: [ self isExtensionActive ifTrue: [ self requestTag ] ifFalse: [ self requestPackage ] ]selectedClassOrMetaClass  ^editingClassbrowserState  ^browserStatedefaultMenuIconName  ^#haloViewwithTool: arg1 do: arg2  | tmp1 |  tmp1 := tools detect: [:arg3 |  arg3 isKindOf: arg1 ].  ^tmp1 whenReadyDo: arg2inverse: arg1  inverse := arg1isProtected  ^accessGuard notNilisMethodSelected  ^self selectedSourceNode isMethoddecorateOwnBrowserItem: arg1  super decorateOwnBrowserItem: arg1.  self asyncQueryResult isBuilt ifFalse: [ arg1 markWith: ClyBackgroundProcessingTag ]navigationEnvironment  ^navigationEnvironmentremoveWithMethods  super removeWithMethods.  methodQuery scope classesDo: [:arg1 |  arg1 removeMethodTag: self tag ]affectedClass: arg1  affectedClass := arg1testMethodsEnumerationWhenBasisIsMetaclass  | tmp1 |  scope := ClyInstanceSideScope of: ClyClass1FromP1 classSide.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArraytestCreationOnMultipleScopeOfSameBasis  | tmp1 |  tmp1 := query class.  query := tmp1 fromAll: {ClyScopeExample .         ClyScopeExample2} of: Array in: environment.  self assert: query class equals: ClyUnionQuery.  self assert: query subqueries equals: {(tmp1 from: ClyScopeExample of: Array in: environment) .         (tmp1 from: ClyScopeExample2 of: Array in: environment)} asSetunsubscribe: arg1  actualResult unsubscribe: arg1type  ^browserItem typehasProperty: arg1  ^properties anySatisfy: [:arg2 |  arg2 isKindOf: arg1 ]description  ^'overriding methods'newTestClassCategoryFor: arg1  | tmp1 |  tmp1 := arg1 package classTagForClass: arg1.  ^String streamContents: [:arg2 |  arg2           nextPutAll: arg1 package name;           nextPutAll: '-Tests'.        tmp1 isRoot ifFalse: [ arg2                 nextPut: $-;                 nextPutAll: tmp1 name ] ]containerForItemsSortedByName  ^SortedCollection sortBlock: #name ascendingsetUpModelFromContext  testClass := context lastSelectedClasscreateVariableRefactoring: arg1  ^self createRefactoring: arg1 for: definingClassfileOut  self inform: 'not supported yet'defaultMenuItemName  ^'Set up scope'hasRealQuery  ^self query ~~ ClyUnknownQuery instanceisDirty  ^dirtyhideCritiques  criticView delete.  browserTool removePaneSplitters.  originalToolPanel layoutFrame     bottomFraction: 1;     bottomOffset: 0isQueryEmpty: arg1  ^trueclassSampleWhichHasGroup  ^ClyClassWithProblemMethodsscopeClass  ^ClyMultipleClassRelationScopedefaultMenuItemName  ^'Update'restrictedByScope: arg1  self subclassResponsibilitycreateTextContext  ^ClyTextEditorContext for: selfrefreshAsyncState  (self findA: ClyActivityAnimationIconMorph) ifNotNil: #delete.  self areItemsLoaded ifFalse: [ self addMorph: (ClyActivityAnimationIconMorph label: 'loading items') ]isClassTagSelected  ^falsebrowserClass  ^browserClassdescription  ^'go forward in the navigation history'needsRebuild  ^needsRebuilditemFilter  ^itemFiltercreateQuery  ^ClyAsyncQuery for: (ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: self class in: environment)messages: arg1  messages := arg1isFilterChanged  table initialDataSource ifNil: [ ^false ].  ^selection rootDataSource ~~ self dataSourcecopyForBrowserStateSnapshot  ^self shallowCopy     resetStateForSnapshot;     yourselfsupportsQuery: arg1  ^arg1 isKindOf: ClyCompositeQueryaddExtraTool: arg1  extraToolMorphs ifNil: [ extraToolMorphs := OrderedCollection new ].  extraToolMorphs add: arg1.  ^arg1createQuery  ^ClyAllInstanceVariablesQuery from: ClyClassScope of: ClyClass2FromP1 in: environmentbrowser: arg1  browser := arg1testCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #reference1OfClass in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #referenceOfAnotherClass in: environment).  self assert: query checkEmptyResulttestCreationSimpleInstance  queryResult := ClyExtensionLastSortedClasses simple.  self assert: queryResult baseQueryResult class equals: ClySortedQueryResulttestCreatesBrowserWithPlugins  browser addPlugin: ClyStandardBrowserPlugin new.  self restoreBrowserInstance.  self assert: browser plugins first browser equals: browser.  self assert: browser plugins first class equals: ClyStandardBrowserPlugin.  self deny: navigationState browserPlugins first identicalTo: browser plugins firstcreateTextContext  ^self selectedSourceNode ifNil: [ super createTextContext ] ifNotNil: [:arg1 |  ClySourceCodeContext for: self selectedNode: arg1 ]testGettingSingletonInstanceFromScratch  ClyUnknownScope reset.  self assert: ClyUnknownScope instance identicalTo: ClyUnknownScope instancebrowser  ^browserTool browserconvertToMethodTag: arg1  self renameMethodTagTo: arg1testFromSinglePackage  self queryFromScope: ClyPackageScope of: ClyClass7WithTag1FromP5 package.  self assert: (resultItems collect: #class as: Set) equals: {ClyNoTagClassGroup .         ClyTaggedClassGroup .         ClyClassGroup} asSet.  self assert: (resultItems select: [:arg1 |  arg1 class = ClyTaggedClassGroup ] thenCollect: #tag) asSet equals: ClyClass7WithTag1FromP5 package tagsForClasses asSetprocessClassRemoval: arg1  environment systemChanged: (ClyOverriddenSuperclassesChanged overridingSubclass: arg1 classAffected)selectedClassTags  ^selectedItems select: [:arg1 |  arg1 type isBasedOnClassTag ] thenCollect: [:arg1 |  arg1 name ]methodWithHalt  < haltOrBreakpointForTesting>  self haltisRedundant  extraClassScope classesDo: [:arg1 |  ^false ].  ^truedecorateResultMethodEditor: arg1  | tmp1 |  tmp1 := variableQuery execute items.  arg1 selectAnyVariable: (tmp1 collect: [:arg2 |  arg2 name ])createInheritanceScopeFrom: arg1  | tmp1 |  tmp1 := ClyClassScope ofAll: arg1 in: browser navigationEnvironment.  ^tmp1 asFullHierarchyScopemethodWithWatchpoint  ^1 + 2browseFullClass  self evaluateSelectionAndDo: [:arg1 |  self browser browseClassNamed: arg1 class instanceSide name ]newDataSourceMatching: arg1  lastFilteredDataSource ifNotNil: [ lastFilteredDataSource close ].  self isClosed ifTrue: [ Processor activeProcess == UIManager default uiProcess ifTrue: [ self error: 'Should not happens' ].        ^Processor terminateActive ].  lastFilteredDataSource := self class on: (query filteredBy: arg1).  lastFilteredDataSource openOn: queryView.  ^lastFilteredDataSourcedefinesChildren  ^truevariablesDo: arg1  self classesDo: [:arg2 |  self classVariablesOf: arg2 do: arg1.        self instanceVariablesOf: arg2 do: arg1 ]createQuery  ^ClyExpectedFailedTestMethodsQuery from: ClyClassScope of: ClyTestedClassTest in: environmentsystem  ^environment systemmethodsDo: arg1  self classesDo: [:arg2 |  arg2 instanceSide localMethods do: arg1.        arg2 classSide localMethods do: arg1 ]defaultMenuItemName  ^'Unclassify method'defaultIconName  ^(context lastSelectedItem isMarkedWith: ClyNoCommentTag) ifTrue: [ #uncommentedClass ] ifFalse: [ #commentsIcon ]findTestMethodCovering: arg1 ifAbsent: arg2  | tmp1 tmp2 |  arg1 isTestMethod ifTrue: [ ^arg2 value ].  tmp2 := self findTestCaseCovering: arg1 methodClass ifAbsent: [ ^arg2 value ].  tmp1 := 'test' , (self normalizeSelectorForComparison: arg1 selector).  ^tmp2 methods detect: [:arg3 |  (self normalizeSelectorForComparison: arg3 selector) = tmp1 ] ifNone: arg2noTagMethod  tearDown  installedWatchpoints do: [:arg1 |  arg1 uninstall ].  installedWatchpoints removeAll.  super tearDownbuildWithFullIndentation  | tmp1 |  self addBarForFullIndentation.  item supportsExpansion ifTrue: [ tmp1 := self currentExpansionButton.        self addMorphBack: tmp1 ].  definitionMorph ifNotNil: [ definitionMorph width: 16.        self addMorphBack: definitionMorph ].  self addMorphBack: label.  extraToolMorphs ifNotNil: [ extraToolMorphs do: [:arg1 |  arg1 width: 16.              self addMorphBack: arg1 ] ]systemScope: arg1  systemScope := arg1selectsClass: arg1  ^truetestExecution  query subqueries: {(self subqueryFromScope: ClyScopeExample of: self class) .         (self subqueryFromScope: ClyScopeExample2 of: self class superclass)}.  self executeQuery.  self assert: resultItems size equals: 2.  self assert: resultItems asSet equals: {self class .         self class superclass} asSet= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^package = arg1 packagecheckEmptyResult  scope instanceVariablesDo: [:arg1 |  ^false ].  ^truetestClassEnumeration  scope := ClyClassScope ofAll: {ClyClass1FromP1 .         ClyClass2FromP1}.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: {ClyClass1FromP1 .         ClyClass2FromP1}runTestItem: arg1  | tmp1 |  tmp1 := self testSelectorOf: arg1.  (self targetTestCasesFor: arg1) do: [:arg2 |  self runTest: tmp1 of: arg2 ]realElementAt: arg1  ^(self elementAt: arg1) browserItemtargetItemType  ^targetItemTypesystem: arg1  system := arg1critiqueQuery  ^critiqueQueryviewStates: arg1  viewStates := arg1selectsMethod: arg1  | tmp1 |  (super selectsMethod: arg1) ifTrue: [ ^true ].  criteriaBlock ifNil: [ ^false ].  extraMethods removeAllSuchThat: [:arg2 |  arg2 calypsoEnvironmentType checkCalypsoItem: arg2 isEqualTo: arg1 ].  tmp1 := criteriaBlock value: arg1.  tmp1 ifTrue: [ extraMethods add: arg1 ].  ^tmp1activator: arg1  activator := arg1.  self buildcurrentMetaLevelOf: arg1  ^metaLevelScope metaLevelOf: arg1modifiesExtension  ^editingMethod isExtension ifTrue: [ extendingPackage ~~ editingMethod package ] ifFalse: [ extendingPackage notNil and: [ extendingPackage ~~ self methodClass package ] ]execute  | tmp1 |  tmp1 := #IceTipExtendedVersionBrowser asClassInEnvironment: self class environment ifAbsent: [ #IceExtendedVersionBrowser asClass ].  (tmp1 repository: repository method: method) openforceFullUpdate  super forceFullUpdate.  expandedItems do: [:arg1 |  arg1 childrenDataSource forceFullUpdate ]prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browsericon: arg1  icon := arg1metaLevelScope  ^ClyInstanceSideScopesubqueries  ^subqueriestable  ^tableshortName  ^'Methods'buildWithLabelIndentation  | tmp1 |  item supportsExpansion ifTrue: [ tmp1 := self currentExpansionButton.        self addMorphBack: tmp1 ].  definitionMorph ifNotNil: [ definitionMorph width: 16.        self addMorphBack: definitionMorph ].  self addBarForLabelIndentation.  self addMorphBack: label.  extraToolMorphs ifNotNil: [ extraToolMorphs do: [:arg1 |  arg1 width: 16.              self addMorphBack: arg1 ] ]testRetrievesActiveScope  self snapshotState.  self assert: navigationState activeScope equals: browser activeScopecollapse  ownerDataSource collapse: selftestSelectsClassWithoutTags  self assert: (query selectsClass: ClyClass6UntaggedFromP5)testIsExecutedFromSingleScopeWhenSingleSubqueryIsBasedOnIt  query subqueries: {(self subqueryFromScopeOf: self class)}.  self assert: query isExecutedFromSingleScopetestUsingUncompiledScript  filter := ClyQueryBrowserFilter substringPattern: '[:each | each 123selector]'.  self assert: (filter matches: self itemOfThisTestMethod).  self assert: (filter matches: (ClyBrowserItem with: Object >> #printString))setWindowTitle: arg1 in: arg2  | tmp1 |  super setWindowTitle: arg1 in: arg2.  arg2 basicLabel ifNotNil: [:arg3 |  tmp1 := metaLevelScope = ClyInstanceSideScope ifTrue: [ TextEmphasis normal ] ifFalse: [ TextEmphasis bold ].        arg3 emphasis: tmp1 emphasisCode ]method1WithUndeclares  ^undeclaredStubInstVar1 printStringconfirmDiscardChanges  ^self confirm: 'Changes have not been saved.Is it OK to discard changes?'requestChangeBy: arg1  arg1 on: CmdCommandAborted do: [:arg2 |   ].  self updateabstractMethod1  selection  ^selectionisCurrentImage  ^self system == ClySystemEnvironment currentImagebrowser: arg1  browser := arg1= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^baseQueryResult = arg1 baseQueryResultdescription  ^'all class groups'testComparisonWithAnotherHierarchy  | tmp1 |  tmp1 := self createQueryResult.  tmp1 hierarchy: queryResult hierarchy inverted.  self deny: queryResult equals: tmp1createQuery  ^ClyQueryExampleReturningScopeBasis from: (ClyScopeExample emptyIn: environment)depth: arg1  depth := arg1restoreDesiredSelectionWith: arg1 silently: arg2  items := arg1.  self restoreTableSelectionSilently: arg2.  arg2 ifFalse: [ self ensureVisibleLastItem ]switchToMethodGroups  self changeMethodGroupQueryBy: [ ClyAllMethodGroupsQuery sortedFrom: self classScopeForMethods ]testCreationFromTwoQueriesOfSameTypeButDifferentScope  | tmp1 tmp2 |  tmp1 := self subqueryFromScope: ClyScopeExample of: Array.  tmp2 := self subqueryFromScope: ClyScopeExample2 of: String.  query := tmp1 , tmp2.  self assert: query class equals: self queryClass.  self assert: query subqueries asSet equals: {tmp1 .         tmp2} asSet.  self assert: query requiredResult identicalTo: tmp1 requiredResultwithMetaLevel: arg1  ^self copy localScopeClass: arg1defaultMenuItemName  ^'go backward'decorateBy: arg1  type decorateBrowserItem: self by: arg1variableQuery  ^variableQuerymessageImplementor2  testNotEmptyWhenThereIsNotEmptySubquery  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 of: self class superclass)}.  self deny: query checkEmptyResultdecorateTableCell: arg1 of: arg2  super decorateTableCell: arg1 of: arg2.  arg1 definitionIcon: #protocolExtensionIcon.  (arg1 browser isPackagePartOfSelection: self package) ifTrue: [ arg1 label emphasis: TextEmphasis bold emphasisCode ] ifFalse: [ arg1 label color: Smalltalk ui theme classExtensionColor ]globals: arg1  globals := arg1fillWithGroupedVariables: arg1  self addInheritedMethodGroup.  arg1 at: ClyClassVariable ifPresent: [:arg2 |  self addClassVariableGroup ].  arg1 at: ClyInstanceVariable ifPresent: [:arg3 |  self fillWithVariables: arg3 type: ClyInstanceVariable ]isBoundToEnvironment  ^scope isBoundToEnvironmentgtDisplayOn: arg1  arg1 << self browser newWindowTitlecontainerTab: arg1  containerTab := arg1order  ^1itemCount  ^0analyzedObjectsDo: arg1  self subclassResponsibilitycreateMethodGroup  self subclassResponsibilityrunTest: arg1 of: arg2  | tmp1 |  tmp1 := Breakpoint new     node: (arg2 lookupSelector: arg1) ast;     install.  [ super runTest: arg1 of: arg2 ] ensure: [ tmp1 remove ]tooltipText  ^'Expand me to toggle method visibility of concrete class.Use checkbox at the right of label to make all inherited methods visible in browser (it skips Object methods). Select me to see all inherited methods which are not overriden by selected class'buildEditButton  editButton := IconicButton new     target: self;     actionSelector: #openEditor;     arguments: #();     labelGraphic: (self iconNamed: #edit);     color: Color transparent;     borderWidth: 0decorateItemGroup: arg1  hash  ^itemType hashselectedSourceNode  | tmp1 tmp2 |  tmp1 := self selectedTextInterval.  tmp2 := self parseClassDefinition.  ^(tmp2 bestNodeFor: tmp1) ifNil: [ tmp2 ]untestedTwo  ^self twohash  ^pattern hashnewPackageView  | tmp1 |  tmp1 := self newNavigationView     treeStructure: {(ClyProjectChildItem -> #prepareProjectItemsQueryFrom:in:) .         (RPackage -> #prepareClassGroupQueryFrom:in:)};     enableFilterUsing: ClyRegexPattern new;     requestNavigationBy: #packageSelectionChanged.  tmp1 filterField announcer when: RubTextChanged send: #updateDefaultPackageFilter to: self.  ^tmp1referenceOfAnotherVar  ^var2name  ^'Query'printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  arg1 nextPutAll: iconName.  arg1 nextPut: $)testFillingWithTwoSameClasses  queryResult fillWith: {ClyClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0}focusActiveTab  | tmp1 |  tmp1 := self selectedTools detectMax: [:arg1 |  self activationPriorityOf: arg1 ].  tmp1 ifNotNil: [ tmp1 takeKeyboardFocus ]handleSystemChange: arg1  | tmp1 tmp2 tmp3 |  tmp1 := (queryCache values select: [:arg2 |  arg2 notNil ]) as: IdentitySet.  tmp2 := 0.  [ [ tmp2 = tmp1 size ] whileFalse: [ tmp2 := tmp1 size.        tmp1 asArray do: [:arg3 |  (tmp1 includes: arg3) ifTrue: [ arg3 handleSystemChange: arg1 byProcessingList: tmp1 ] ] ].  tmp1 notEmpty ] whileTrue: [ tmp3 := tmp1 anyOne.        tmp3 handleSystemChange: arg1.        tmp1 remove: tmp3 ]describes: arg1  ^(arg1 isKindOf: dialogClass) and: [ arg1 browser isKindOf: browserClass ]simpleNameForSpotterMenu  ^self class namebuildResult: arg1  | tmp1 tmp2 |  tmp1 := IdentitySet new.  scope methodsDo: [:arg2 |  tmp2 := arg2 origin package.        (arg2 isDefinedInPackage: tmp2) ifFalse: [ arg2 package ifNotNil: [:arg3 |  tmp1 add: arg3 ] ] ].  arg1 fillWith: tmp1editingText  ^editingPackage packageManifestOrNil ifNil: [ self packageCommentBlank ] ifNotNil: [:arg1 |  arg1 hasComment ifTrue: [ arg1 comment ] ifFalse: [ self packageCommentBlank ] ]beEmpty  self selectItems: {}buildLeftSideBar  textMorph withTextSegmentIconshash  ^definingClass hash bitXor: actualVariable hashdefaultMenuIcon  ^Smalltalk ui iconNamed: #smallDebugswitchToHierarchicalResult  DefaultQueryResult := ClyHierarchicalSystemItems new.  self switchResultTo: DefaultQueryResultselectedClasses  ^{self selectedClass}testNotSelectsClassSideMethodWhichReturnesFloat  self deny: (query selectsMethod: ClyClassWithUndeclares class >> #withFloatReturn)reader2OfVar1  ^readVar1hash  ^methodQuery hash bitXor: subgroupsQuery hashignoreNavigationDuring: arg1  arg1 valuecommandListProcessorForContext: arg1 step: arg2  arg2 listProcessor     order: 20;     title: arg1 simpleNameForSpotterMenu;     allCandidates: [ self collectCommandCandidatesInContext: arg1 ];     itemName: #menuItemName;     itemIcon: #menuItemIcon;     candidatesLimit: 5;     filter: GTFilterSubstring;     actLogic: [:arg3 :arg4 |  arg4 exit.        arg3 executeCommand ]classSampleWhichHasGroup  ^ClyClassWhichInheritsAbstractClasssubscribe: arg1  self subscribe: arg1 for: SystemAnnouncementtestRepresentsClassOfScope  scope := self createSampleScope.  self assert: (scope representsScope: self scopeClass).  self assert: (scope representsScope: ClyTypedScope).  self deny: (scope representsScope: ClyCompositeScope)= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^direction = arg1 directiontestIsBoundToEnvironmentWhenScopeIs  < expectedFailure>  super testIsBoundToEnvironmentWhenScopeIshash  ^super hash bitXor: critiqueQuery hashfindItemsWith: arg1  | tmp1 tmp2 tmp3 |  actualResult protectItemsWhile: [ tmp2 := arg1 collect: [:arg2 |  tmp3 := actualResult items findFirst: [:arg3 |  arg3 calypsoEnvironmentType checkCalypsoItem: arg3 isEqualTo: arg2 ].              tmp3 > 0 ifTrue: [ tmp1 := (actualResult itemAt: tmp3) asCalypsoBrowserItem.                    tmp1 position: tmp3.                    tmp1 prepareIn: self environment.                    tmp1 ] ifFalse: [ nil ] ].        ^tmp2 ]includesItemsOf: arg1  ^items anySatisfy: [:arg2 |  arg2 isBasedOnItemType: arg1 ]description  ^'deprecated methods'testFillingWithClassInsteadOfTrait  queryResult fillWith: {ClyClassWithoutTraits}.  self assertItems: {ClyClassWithoutTraits .         0}userRequestString  ^'Remove, then browse senders'simpleNameForSpotterMenu  ^'Method editor: ' , super simpleNameForSpotterMenutestHasRequiredResultByDefault  self assert: query requiredResult notNilsetUpTargetClasses  targetClasses := browser chooseClassesForNewMethod: editingMethodrelationScopeClasses: arg1  relationScopeClasses := arg1label  | tmp1 |  tmp1 := ownerTool extendingPackage ifNil: [ 'extension' ] ifNotNil: [:arg1 |  arg1 name ].  ownerTool modifiesExtension ifTrue: [ tmp1 := '*' , tmp1 ].  ^tmp1importMethod: arg1  super importMethod: arg1.  self package addMethod: arg1.  arg1 tagWith: ('*' , self package name) asSymbolmethodSelection  ^methodView selectionpackagesDo: arg1  basisObjects do: arg1adoptQuery: arg1  | tmp1 tmp2 |  tmp1 := subscopes collect: [:arg2 |  arg1 withScope: arg2 ].  tmp2 := ClyQuery unionFrom: tmp1.  tmp2 scope name: name.  ^tmp2chooseClassForEditorOfMethod: arg1  ^arg1 origintestFromTwoMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithFlags >> #methodWithFlag) .         (ClyClassWithFlags >> #methodWithoutFlag)}.  self assert: foundSelectors sorted asArray equals: #(methodWithFlag)updateToolsBy: arg1  updatingStarted := true.  arg1 ensure: [ updatingStarted := false ]isClassSelected  ^self hasSelectedItemssupportsCriticDecoration  ^truesizeLimit: arg1  sizeLimit := arg1littleHierarchyMaxSize  ^littleHierarchyMaxSizecurrentItem  ^cache itemAt: positionsimpleNameForSpotterMenu  ^'Comment editor: ' , editingPackage namecreateCommandContext  ^self createSelectionContextisAsync  ^trueincludesActualObject: arg1  ^self browserItem includesActualObject: arg1asGlobalScopeIn: arg1  ^ClySystemEnvironmentScope of: self in: arg1 named: namenotifyUserAboutResults: arg1 with: arg2  | tmp1 |  tmp1 := Color gray.  arg1 hasPassed ifTrue: [ tmp1 := Color green ].  arg1 hasFailures ifTrue: [ tmp1 := Color yellow ].  arg1 hasErrors ifTrue: [ tmp1 := Color red ].  GrowlMorph openWithLabel: arg2 contents: arg1 printString backgroundColor: tmp1 labelColor: Color blackbuild  checkbox := CheckboxMorph on: self selected: #usesSlotBasedDefinition changeSelected: #toggle.  checkbox     getLabelSelector: #definitionTypeLabel;     labelClickable: true;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     setBalloonText: 'You can switch between old and new class definition. New definition is based on slots'.  self addMorph: checkboxaffectsMethod: arg1  ^arg1 selector = self overriddenMethod selector and: [ arg1 origin inheritsFrom: self overriddenMethod origin ]hierarchy: arg1  hierarchy := arg1instanceSideClassVar1Reader  ^ClassVar1testMethodsEnumeration  scope := ClySubclassScope of: ClyClass1FromP1.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyClass1FromP1 subclasses first localMethods).  self deny: (result includesAll: ClyClass1FromP1 subclasses first classSide localMethods).  self assert: (result includesAll: ClyClass1FromP1 subclasses second localMethods).  self deny: (result includesAll: ClyClass1FromP1 subclasses second classSide localMethods).  self deny: (result includesAll: ClyClass1FromP1 localMethods).  self deny: (result includesAll: ClyClass1FromP1 classSide localMethods).  self deny: (result includesAll: ClyClass1FromP1 superclass localMethods).  self deny: (result includesAll: ClyClass1FromP1 superclass classSide localMethods)systemScope  ^systemScopedescription  ^String streamContents: [:arg1 |  self printExtraInfoOn: arg1 ]collectMethodGroupProviders  ^{ClyFlagMethodGroupProvider new}sendersOfIt  | tmp1 |  (tmp1 := self selectedSelector) == nil ifTrue: [ ^textArea flash ].  self sendersOf: tmp1testComparisonWithSimilarScope  | tmp1 |  scope := self createSampleScope.  tmp1 := self createSampleScope.  self assert: scope equals: tmp1.  self assert: scope hash equals: tmp1 hashselectedMessages  ^{self selectedMessage}setUpModelFromContext  leftMethod := context firstSelectedMethod.  rightMethod := context lastSelectedMethodselectedPackageItems  ^self selectedItemsOfType: RPackageprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browser.  systemEnvironment := arg1 systemEnvironmentsetUpTargetClasses  targetClasses := browser chooseClassesForNewMethod.  (targetClasses includes: methodClass) ifFalse: [ targetClasses := {methodClass} , targetClasses ]wantsTextStyling  ^falseaccumulateFailures: arg1 andErrors: arg2  allCount := allCount + arg1 + arg2.  failureCount := failureCount + arg1.  errorCount := errorCount + arg2toolWasRemoved  criticView ifNotNil: [ criticView closeDataSource ]currentExpansionButton  item hasChildren ifFalse: [ ^FTTreeDataSource emptyMorph ].  ^item isExpanded ifTrue: [ self expandedButton ] ifFalse: [ self collapsedButton ]createBrowser  | tmp1 |  tmp1 := browserState createBrowser.  browserPlugins do: [:arg1 |  tmp1 addPlugin: arg1 copy ].  tmp1 navigationEnvironment: navigationEnvironment.  tmp1 navigationHistory: navigationHistory.  browserState restoreStateOf: tmp1.  ^tmp1dragTab: arg1 event: arg2 in: arg3  arg1 announcer unsubscribe: self.  self tabGroup removePage: arg1.  arg1 configureForUnembedding.  self tabGroup pages size = 0 ifTrue: [ self owner delete ].  arg1 position: arg2 targetPoint.  arg2 hand grabMorph: arg1decorateTableCell: arg1 using: arg2  extensionMethodFromClass9  execute  critique guidedBanwaitBuildComplete  [ queryResult buildProcess isNil or: [ queryResult buildProcess isTerminated ] ] whileFalse: [ 20 milliSeconds wait ]overriddenMethod  ^methodorder  ^4testFindItemsSimilarToOthersWhenTheyAreNotInCache  | tmp1 |  cursor cleanCache.  tmp1 := cursor findItemsSimilarTo: ({Class .         Array} collect: #asCalypsoBrowserItem).  self assert: tmp1 size equals: 1.  self assert: tmp1 first actualObject equals: Array.  self assert: tmp1 first isPrepared.  self assert: tmp1 first position equals: (self rawResultItems indexOf: Array)isClass: arg1 shouldImplement: arg2  | tmp1 |  arg1 isRootInEnvironment ifTrue: [ ^false ].  tmp1 := arg1 superclass lookupSelector: arg2.  tmp1 ifNil: [ ^false ].  ^self isAbstractMethod: tmp1affectsMethodsTaggedWith: arg1  ^announcerPlugin isMethodOverridden: methodmethodEditor: arg1  methodEditor := arg1spawnQueryBrowserOn: arg1 withState: arg2  | tmp1 |  tmp1 := arg1.  arg1 isBoundToEnvironment ifFalse: [ tmp1 := arg1 withScope: self defaultNavigationScope ].  tmp1 scope = self systemScope ifTrue: [ tmp1 semiAsync hasEmptyResult ifTrue: [ ^self inform: 'There are no ' , tmp1 description ] ].  self spawnBrowser: ClyQueryBrowser withState: [:arg3 |  arg3 queryScopes: self allNavigationScopes.        arg3 showResultOf: tmp1.        arg2 valueWithPossibleArgs: {arg3} ]restoreCurrentSelectionAfterUpdate: arg1  | tmp1 tmp2 tmp3 |  tmp1 := isSameAsCurrent.  self checkItemsOfCurrentSelection: arg1.  tmp2 := isSameAsCurrent ifTrue: [ arg1 items ] ifFalse: [ arg1 rootDataSource findItemsWith: self actualObjects ].  tmp3 := (tmp1 & isSameAsCurrent) not.  arg1 restoreDesiredSelectionWith: tmp2 silently: tmp3 not.  ^tmp3triggerDoubleClickCommands  CmdDoubleClickActivation executeCommandInContext: self createSelectionContexttestComparisonWithResultWithAnotherHierarchyType  | tmp1 |  tmp1 := self createQueryResult.  tmp1 hierarchy: #anotherHierarchy.  self deny: queryResult equals: tmp1attachToSystem  asRBEnvironment  ^RBBrowserEnvironment newfullDescription  ^self descriptioninstallCounterInto: arg1  | tmp1 |  tmp1 := ExecutionCounter installOn: (self class >> arg1) ast sendNodes last.  installedCounters add: tmp1.  ^tmp1allItems  ^self wrapRawItems: actualResult allItems startingAt: 1prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browsertestFindItemsWithActualObjects  | tmp1 |  tmp1 := cursor findItemsWith: {#absentItem1 .         Array .         #absentItem2}.  self assert: tmp1 size equals: 3.  self assert: tmp1 first equals: nil.  self assert: tmp1 last equals: nil.  self assert: tmp1 second actualObject equals: Array.  self assert: tmp1 second isPrepared.  self assert: tmp1 second position equals: (self rawResultItems indexOf: Array)spawnFullBrowser  ^self spawnBrowser: ClyFullBrowser withState: [:arg1 |  self navigateSpawnedFullBrowser: arg1 ]classesDo: arg1  self projectsDo: [:arg2 |  arg2 classes do: arg1 ]createQuery  self subclassResponsibilitydefaultMenuItemName  ^'File Out'testFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reference1OfClass) .         (self class >> #referenceOfAnotherClass)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfClasstestExecutionShouldRemoveDuplication  query subqueries: {(self subqueryFromScope: ClyScopeExample of: self class) .         (self subqueryFromScope: ClyScopeExample2 of: self class)}.  self executeQuery.  self assert: resultItems asArray equals: {self class}environment: arg1  environment := arg1testCase: arg1  testCase := arg1testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClass1FromP1 >> #tag1Method1) .         (Object >> #printString) .         (ClyClass2FromP1 >> #instanceSideClassVar1Reader)}.  self assert: foundSelectors equals: #(instanceSideClassVar1Reader)createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'ffi calls' on: arg1isSimilarTo: arg1  ^(super isSimilarTo: arg1) and: [ metaLevelScope == arg1 metaLevelScope ]methodGroups: arg1  methodGroups := arg1collectMetadataOf: arg1 by: arg2  arg2 collectMetadataOfPackages: arg1testNotBasedOnMultipleBasisWhenTwoSubscopesAreBasedOnSameSingleObject  | tmp1 tmp2 |  tmp1 := ClyScopeExample of: #basisObject in: environment.  tmp2 := ClyScopeExample2 of: #basisObject in: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self deny: scope isBasedOnMultipleBasiscollectClassGroupProviders  ^#()itemsChanged  self refreshCritiquesexecute  | tmp1 tmp2 tmp3 |  tmp1 := RGEnvironment new.  tmp3 := commitModel entity.  tmp3 packageNames do: [:arg1 |  tmp2 := tmp3 snapshotFor: (RPackage named: arg1).        tmp2 importInto: tmp1 asPackageNamed: arg1 ] displayingProgress: 'loading'.  tmp1 clean.  tmp1 browseAs: tmp3 repository origin url , '[' , tmp3 shortId , ']'doesMethod: arg1 useVar: arg2  ^arg2 isWrittenIn: arg1= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^pattern = arg1 patternerrorCount: arg1  errorCount := arg1textUpdated  self applyDecorations.  self updateDirtyStatecolor: arg1  color := arg1groupVariablesByTypeAndDefinition: arg1  | tmp1 tmp2 tmp3 |  tmp1 := IdentityDictionary new.  arg1 do: [:arg2 |  tmp3 := tmp1 at: arg2 class ifAbsentPut: [ IdentityDictionary new ].        tmp2 := tmp3 at: arg2 definingClass ifAbsentPut: [ self containerForItemsSortedByName ].        tmp2 add: arg2 ].  ^tmp1defaultResult  ^ClyUnknownQueryResult instancedecorateResultMethodEditor: arg1  subqueries do: [:arg2 |  arg2 decorateResultMethodEditor: arg1 ]enableFilter: arg1  self enableFilterWithFactory: (ClyTableFilterFactory of: arg1)classSampleWhichHasGroup  ^ClySubclassLOfClass0FromPExtendedByP1openBrowser  definingClass browsedefaultMenuItemName  ^'Apply deprecation'desiredSelection: arg1  | tmp1 |  desiredSelection := arg1 asIdentitySet.  shouldSkipCurrentDesiredSelection ifFalse: [ tmp1 := self selectedTools collect: [:arg2 |  arg2 class ].        desiredSelection addAll: tmp1 ].  shouldSkipCurrentDesiredSelection := false, arg1  self subclassResponsibilitytestComparisonToSimilarQueryWhichReturningDifferentObjects  | tmp1 |  tmp1 := self createQuery.  tmp1 resultItems: #(anotherResult).  self deny: query equals: tmp1tag2Method1  browser  ^browserexpandedButton  ^IconicButton new     target: item;     actionSelector: #collapse;     arguments: {};     labelGraphic: self theme treeExpandedForm;     color: Color transparent;     helpText: 'Unexpand Item';     borderWidth: 0addChild: arg1 to: arg2  hierarchy isInverse ifTrue: [ self addActualChild: arg2 to: arg1 ] ifFalse: [ self addActualChild: arg1 to: arg2 ]description  ^'unimplemented methods'createSampleScope  ^self multipleScopeSampleupdateTools  | tmp1 tmp2 tmp3 tmp4 |  self updateToolsBy: [ tmp1 := OrderedCollection new.        browser navigationContextsDo: [:arg1 |  self buildToolsOn: tmp1 for: arg1 ].        tmp4 := self requiresNewDesiredSelection.        tmp2 := self selectedTools.        tmp3 := tools copy.        self updateTabsWith: tmp1.        tools ~= tmp3 | tmp4 ifTrue: [ self restoreSelectedTools: tmp2 ] ]defaultMenuItemName  ^'Remove ' , self metalinkManagerClass name asLowercasesupeclassReaderOfVar1  ^readVar1block: arg1  block := arg1= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^baseCritiqueQuery = arg1 baseCritiqueQuerydirection  ^directionunsubscribe: arg1  printExtraInfoOn: arg1  super printExtraInfoOn: arg1.  arg1 nextPutAll: pattern valueensureScope: arg1  scope == ClyUnknownScope instance ifTrue: [ ^self scope: arg1 ].  scope == arg1 ifFalse: [ self error: 'Scope modification is forbidden. Query is bound to scope forever' ]createQuery  ^ClyFlaggingMethodsQuery from: ClyClassScope of: Object in: environment, arg1  (arg1 isKindOf: ClyTypedScope) ifFalse: [ ^self error: 'Complex composition is not supported' ].  ^ClyCompositeScope on: (subscopes copyWith: arg1)initialize  super initialize.  ruleSeverity := ClyCritiqueSeverityProperty defaultruleSeverity  ^ruleSeverityopenInspector  definingClass isClassSide ifTrue: [ ^(actualVariable read: definingClass instanceSide) inspect ].  super openInspectortestItemsChangedNotificationShouldResetItems  < expectedFailure>  super testItemsChangedNotificationShouldResetItemsdecorateTableCell: arg1 of: arg2  super decorateTableCell: arg1 of: arg2.  arg1 setBalloonText: self tooltipText.  visibilityLevels do: [:arg3 |  arg3 decorateMethodGroupTableCell: arg1 of: arg2 ]methodGroupQuery  ^methodGroupQueryisBasedOnSingleBasis  ^self basisSize = 1classTag  ^classTagcreateQuery  ^ClyAllVariablesQuery from: ClyClassScope of: ClyClass2FromP1 in: environmentisCurrentStateOf: arg1  arg1 navigationViews with: viewStates do: [:arg2 :arg3 |  (arg3 isCurrentStateOf: arg2) ifFalse: [ ^false ] ].  ^arg1 tabManager selectsTools: selectedTabsitemType: arg1  itemType := arg1updateSelection  | tmp1 |  tmp1 := table selectedIndexes select: [:arg1 |  arg1 between: 1 and: self dataSource numberOfRows ] thenCollect: [:arg2 |  self itemAt: arg2 ].  selection := self newSelectionWith: tmp1.  shouldRestoreSelection ifTrue: [ changesWasInitiatedByUser ifTrue: [ desiredSelection := selection asDesiredSelection ] ifFalse: [ desiredSelection ifNotNil: [ desiredSelection checkItemsOfCurrentSelection: selection ] ] ]hash  ^super hash bitXor: tag hashselectedProjectChildItems  ^tool projectChildrenSelection itemstestOpeningBrowserCursor  | tmp1 |  tmp1 := ClyItemObserverExample new.  cursor := queryResult openBrowserCursorFor: tmp1.  self assert: cursor class equals: ClyBrowserQueryCursor.  self assert: cursor queryResult equals: queryResult.  self assert: cursor itemObserver equals: tmp1.  queryResult hasSubscriber: tmp1testIsEmptyForExplicitlyDefinedAbstractMetaclass  query scope: (ClyClassScope of: ClyExplicitAbstractClassExample class in: environment).  self assert: query checkEmptyResult.  self executeQuery.  self assert: foundSelectors isEmptycreateDragPassengerFor: arg1  | tmp1 |  tmp1 := self createSelectionContextOf: arg1.  ^CmdDragAndDropActivation createDragPassengerInContext: tmp1isSameAs: arg1  ^browserItem isSameAs: arg1 browserItemclassGroup  ^classGroupcreateMethodQueryFrom: arg1  ^ClyUnimplementedMethodsQuery from: arg1browser  ^self queryView browserallowsDifferentActivationPriority  ^falsebeProtected  accessGuard := Mutex newprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  methodGroups := arg1 selectedMethodGroupstestMethodsEnumerationWhenBasisIsTraitedClass  | tmp1 |  scope := ClyClassSideScope of: ClyClassWithTraits.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClassWithTraits class methods reject: [:arg2 |  arg2 origin = TraitedClass ] thenCollect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArraysemiAsync  ^selftestFindItemsSimilarToOthers  | tmp1 |  tmp1 := cursor findItemsSimilarTo: ({Class .         Array} collect: #asCalypsoBrowserItem).  self assert: tmp1 size equals: 1.  self assert: tmp1 first actualObject equals: Array.  self assert: tmp1 first isPrepared.  self assert: tmp1 first position equals: (self rawResultItems indexOf: Array)testSelectedTabsWithoutBrowser  | tmp1 |  self snapshotState.  tmp1 := navigationState selectedTabs first.  self assert: tmp1 browser isNilsearchDialog  ^ClyBrowserSearchDialogWindow for: selffindTestCaseCovering: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := arg1 instanceSide name.  ^environment system classNamed: (tmp1 , 'Test') asSymbol ifAbsent: [ environment system classNamed: (tmp1 , 'Tests') asSymbol ifAbsent: arg2 ]openOn: arg1 withTitle: arg2 thenDo: arg3  self showItemsOf: arg1.  self title: arg2.  browser openModal: self.  ^[ itemsView table cleanupFilter.  itemsView dataSource isClosed ifTrue: [ CmdCommandAborted signal ].  self cancelled ifTrue: [ CmdCommandAborted signal ].  arg3 value ] ensure: [ itemsView closeDataSource ]testDataSourceIsClosed  self snapshotState.  self assert: navigationState dataSource isClosedinitializeForBrowserStateSpanshot  table := nil.  queryView := nil.  itemCursor := ClyClosedBrowserCursor instance.  lastFilteredDataSource := nil.  dirty := falsetestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithFlags >> #methodWithFlag in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithFlags >> #methodWithoutFlag in: environment).  self assert: query checkEmptyResulthasUnacceptedEdits  ^falsechangeStateBy: arg1  | tmp1 tmp2 |  navigationStarted ifTrue: [ ^arg1 value ].  navigationStarted := true.  tmp2 := false.  tmp1 := self snapshotState.  ^[ arg1 on: Error do: [:arg2 |  tmp2 := true.        arg2 pass ] ] ensure: [ navigationStarted := false.        tmp2 | (tmp1 isCurrentStateOf: self) ifFalse: [ self recordNavigationState: tmp1.              self updateWindowTitle.              self rebuildAllTools ] ]buildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope classesDo: [:arg2 |  arg2 isTestCase ifTrue: [ (arg2 history at: #failures) do: [:arg3 |  (arg2 lookupSelector: arg3) ifNotNil: [:arg4 |  tmp1 add: arg4 ] ].              (arg2 history at: #errors) do: [:arg3 |  (arg2 lookupSelector: arg3) ifNotNil: [:arg4 |  tmp1 add: arg4 ] ] ] ].  arg1 fillWith: tmp1definingClass  ^definingClasssemiAsync  ^selfskipCurrentDesiredSelection  shouldSkipCurrentDesiredSelection := trueexecute  browser switchFocusToNextPanecreateInheritanceScopeFrom: arg1  self subclassResponsibilitytestFixingStateBeforeExecution  query fixStateBeforeExecution.  self assert: query isReadOnlyObject.  self assert: query scope isReadOnlyObjecttestTriesFixWronglyUsedStarInRegex  | tmp1 |  tmp1 := ClyRegexPattern with: '*abs'.  self assert: (tmp1 matches: 'abs').  self deny: (tmp1 matches: 'ert')two  ^twotestFillingWithOneInstVarAndTwoClassVarsOfSameClass  queryResult fillWith: {(ClyInstanceVariable named: #instVar definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #ClassVar2 definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instVar)isForScripting  ^falsetestCreationOnTwoSubscopesOfDifferentObjects  | tmp1 tmp2 |  tmp1 := ClyScopeExample of: #basisObject1 in: environment.  tmp2 := ClyScopeExample of: #basisObject2 in: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self assert: scope basisObjects asSet equals: #(basisObject1 basisObject2) asSetbuildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope variablesDo: [:arg2 |  tmp1 add: arg2 ].  arg1 fillWith: tmp1testHasDefaultClassLocalScope  scope := self createSampleScope.  self assert: scope localScopeClass equals: ClyClassScopeisManagedByUser  ^isManagedByUserprovidesMethodGroup: arg1  providesMethodGroup := arg1testClassEnumeration  scope := ClyClassSideScope ofAll: {ClyClass1FromP1 classSide .         ClyClass2FromP1}.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: {ClyClass1FromP1 classSide .         ClyClass2FromP1 classSide}testCheckIfEmpty  query scope: self scopeWithoutCritiques.  self assert: query checkEmptyResult.  query := self createQuery.  query scope: self scopeWithCritiques.  self deny: query checkEmptyResult.  query groupName: 'wrong group'.  self assert: query checkEmptyResulttestDataSourceWithoutQueryView  self snapshotState.  self assert: navigationState dataSource queryView isNilshowPackage: arg1  tool selectPackage: arg1, arg1  ^arg1 unionWith: subqueries as: requiredResultnew  ^selfrootDataSource  ^rootDataSourcetestRetrievesBrowserState  self snapshotState.  self assert: (navigationState browserState isKindOf: ClyBrowserState)executeCommand: arg1 by: arg2  arg1 isComplexRefactoring ifTrue: [ arg1 confirmRefactoringInContext: self by: arg2 ].  arg1 executedecorateBrowserItem: arg1 ofClass: arg2  | tmp1 |  arg2 isTestCase ifTrue: [ ^self ].  tmp1 := self findTestCaseCovering: arg2 ifAbsent: [ ^self ].  arg1 addProperty: (ClyTestedClassProperty coveringTestCase: tmp1)selectItems: arg1  | tmp1 |  tmp1 := (arg1 collect: #actualObject as: IdentitySet) = (items collect: #actualObject as: IdentitySet).  items := arg1.  self restoreTableSelectionSilently: tmp1.  self ensureVisibleLastIteminitialize  super initialize.  selectedItems := #()implementorsOf: arg1  self browser browseImplementorsOf: arg1isClassGroupSelected  ^falseretrieveStateFrom: arg1  super retrieveStateFrom: arg1.  queryScopes := arg1 queryScopes.  activeScope := arg1 activeScope.  methodQuery := arg1 systemQuery.  expectedFlatQueryResult := arg1 expectedFlatQueryResultdescription  ^'class comments with ' , pattern value printStringpackageOrganizer: arg1  packageOrganizer := arg1collectMetadata  metadata := ClyQueryResultMetadata newclear  undoList removeAll.  redoList removeAlltestSelectorOf: arg1  ^(arg1 getProperty: ClyTestedMethodProperty) coveringTest selectorsupportsCriticDecoration  ^falsesimpleNameForSpotterMenu  ^'Packages'step  progress := progress + 1.  progress > 10 ifTrue: [ progress := 1 ].  progressIconMorph form: self currentIconexecute  self critique rule class browsetestNeedsRebuildByDefault  queryResult := self createQueryResult.  self assert: queryResult needsRebuildtestFindTestCaseCoveringTestedMetaclass  | tmp1 |  tmp1 := plugin findTestCaseCovering: ClyTestedClass class ifAbsent: [  ].  self assert: tmp1 equals: ClyTestedClassTestselectsMethod: arg1  ^arg1 sendsSelector: #subclassResponsibilitysystem  ^tool systemnavigationContextsDo: arg1  navigationViews do: [:arg2 |  arg1 value: arg2 createSelectionContext ]setUpDataSource: arg1  table dataSource: arg1.  table initialDataSource: nil.  highlighting := ClyHighlightingSelection fromRoot: arg1 items: #().  highlighting restoreTableSelection.  selection := self newSelectionWith: #().  arg1 openOn: self.  self showDesiredSelection.  self refreshAsyncState.  self ensureSelectedItemIfNeededselectedProjectChildren  ^self actualSelectionFrom: self selectedProjectChildItemstestMoveToItemWhichNotSatisfiesCondition  | tmp1 |  tmp1 := cursor moveToItemWhich: [:arg1 |  arg1 actualObject = Object ].  self assert: tmp1.  self assert: cursor position equals: 2.  tmp1 := cursor moveToItemWhich: [:arg1 |  false ].  self deny: tmp1.  self assert: cursor position equals: 2moveMainColumnAtTheEnd  | tmp1 |  tmp1 := self mainColumn.  table columns: (table columns copyWithout: tmp1) , {tmp1}testCreateGroupsForEveryMethodTag  | tmp1 tmp2 |  self buildGroupsFor: ClySubclassN1OfClass1FromP1.  tmp1 := builtGroups select: [:arg1 |  arg1 isKindOf: ClyTaggedMethodGroup ].  self assert: (tmp1 collect: #tag as: Set) equals: ClySubclassN1OfClass1FromP1 tagsForMethods asSet.  tmp2 := tmp1 first methodQuery.  self assert: tmp2 class equals: ClyTaggedMethodsQuery.  self assert: tmp2 scope equals: (ClyClassScope of: ClySubclassN1OfClass1FromP1)testCreationFromAnotherCompositeQueryAndNewDifferentSubquery  | tmp1 tmp2 tmp3 |  tmp1 := self subqueryFromScope: ClyScopeExample of: Array.  tmp2 := self subqueryFromScope: ClyScopeExample2 of: String.  tmp3 := ClyQueryExampleReturningScopeBasis2 from: ClyScopeExample of: Object in: environment.  query := tmp1 , tmp2 , tmp3.  self assert: query class equals: ClyUnionQuery.  self assert: query subqueries equals: {tmp1 .         tmp2 .         tmp3} asSet.  self assert: query requiredResult equals: tmp1 requiredResultdefinesTree  ^treeStructure notEmptyrawItems  ^actualResult rawItemsdefaultIconName  ^#diffdefiningMetaLevelScope  ^isInstanceSide ifTrue: [ ClyInstanceSideScope ] ifFalse: [ ClyClassSideScope ]groupProviderClass  ^ClyCriticMethodGroupProviderprepareDefaultState  super prepareDefaultState.  DefaultPackageFilter ifNotNil: [ packageView activateFilterWith: DefaultPackageFilter ].  UIManager default defer: [ packageView takeKeyboardFocus ]untestedOne  ^self onesetUpDefaultIcon  containerTab icon: self defaultIconiconNameForSpotterMenu  ^nilmergedParts: arg1  mergedParts := arg1redoList: arg1  redoList := arg1defaultMenuIconName  ^#smallSystemBrowsernavigationHistory: arg1  navigationHistory := arg1reducedByClassesFrom: arg1  | tmp1 tmp2 |  tmp1 := basisObjects collect: [:arg2 |  arg2 instanceSide ].  tmp2 := arg1 collectAllClasses collect: [:arg2 |  arg2 instanceSide ].  ^self withNewBasisObjects: (tmp1 copyWithoutAll: tmp2)testFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}type  ^typeitemsStartingAt: arg1 count: arg2  ^self wrapRawItems: (actualResult itemsStartingAt: arg1 count: arg2) startingAt: arg1withResult: arg1  | tmp1 |  tmp1 := super withResult: arg1.  tmp1 subqueries: (subqueries collect: [:arg2 |  arg2 withResult: arg1 ]).  ^tmp1annotatedClass: arg1  super annotatedClass: arg1.  priority := arg1 prioritycreateMethodQueryFrom: arg1  ^ClyUndeclaredMethodsQuery from: arg1selectedVariables  ^{self selectedVariable}tagName: arg1  tagName := arg1ensureRunning  (process notNil and: [ process isTerminated not ]) ifTrue: [ ^self ].  process := [ self processQueue ] forkAt: Processor userBackgroundPriority + 1 named: 'Calypso update'runPackageTests: arg1  | tmp1 tmp2 |  tmp2 := arg1 definedClasses select: [:arg2 |  arg2 isTestCase and: [ arg2 isAbstract not ] ].  tmp2 ifEmpty: [ tmp1 := TestAsserter classForTestResult new ] ifNotEmpty: [ tmp1 := tmp2 anyOne classForTestResult new ].  tmp2 do: [:arg2 |  self runTestCase: arg2 results: tmp1 ].  tmp1 updateResultsInHistory.  self notifyUserAboutResults: tmp1 with: arg1 nameclassSampleWhichHasGroup  ^ClyClassWithHaltsdefaultMenuItemName  ^'Users'detectDefiningClassFrom: arg1  createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'overrides' priority: -10 on: arg1testIsBasedOnMultipleBasisWhenSingleSubscopeIs  | tmp1 |  tmp1 := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {tmp1}.  self assert: scope isBasedOnMultipleBasisdecorateByCritic: arg1  testHasScopeFromSubquery  self assert: query scope equals: query subqueries anyOne scopescopeClass  ^ClyClassSideScopelastSelectedPackage  ^self lastSelectedObjectIn: self selectedPackagesisMarkedWith: arg1  ^self hasProperty: arg1writer1OfVar1  writtenVar1 := #value1sendersOf: arg1  self browser browseReferencesTo: arg1applyChanges  self pendingText asString = self editingText asString ifFalse: [ editingClass comment: self pendingText stamp: Author changeStamp ].  ^truetestNotSelectsNotFFIMethod  self deny: (query selectsMethod: ClyClassWithFFIMethods >> #notFFIMethod)testIsAffectedByChangeOfMethodOfTargetClassWhichOverridesAbstractOne  query scope: (ClyClassScope of: ClyClassWhichInheritsAbstractClass in: environment).  self assert: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #abstractMethod1)spawnQueryBrowserOn: arg1  self spawnQueryBrowserOn: arg1 withState: [  ]showsItemsFromMultipleScope  ^self query isExecutedFromMultipleScopeunionWith: arg1 as: arg2  self subclassResponsibilityname  ^'SUnit'visibleClassScope  ^visibleClassScopeaddLabel: arg1  self addMorphBack: arg1 asMorphtestConvertingToSemiAsyncQuery  | tmp1 |  tmp1 := query semiAsync.  self assert: tmp1 identicalTo: queryasyncQueryResult  ^asyncQueryResult ifNil: [ asyncQueryResult := self loadAsyncQueryResult ]criteriaString  ^criteriaStringtestAscending  function := ClySortByDefiningClassFunction ascending.  self deny: (function value: (ClyClassComment of: Object) value: (ClyClassComment of: Array)).  self assert: (function value: (ClyClassComment of: Array) value: (ClyClassComment of: Object)).  self assert: (function value: (ClyClassComment of: Object) value: (ClyClassComment of: Object))testBuildCompletionShouldNotifyItemObservers  | tmp1 tmp2 |  tmp1 := ClyItemObserverExample new.  tmp2 := queryResult openBrowserCursorFor: tmp1.  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self assert: tmp1 wasNotifieddecorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color redfillWith: arg1  self shouldNotImplementselectsClass: arg1  self subclassResponsibilityisQueryScopeActive: arg1  ^self activeScope = arg1testFillingWithClassAndItsTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot1 .         3}hasProperty: arg1  ^properties anySatisfy: [:arg2 |  arg2 isKindOf: arg1 ]build  self hResizing: #rigid.  self width: 120.  textMorph := self theme newTextEntryIn: self for: self get: #printMethodTags set: #setNewMethodTags: class: nil getEnabled: nil help: 'input tags which should be applied to current method'.  textMorph     hResizing: #spaceFill;     acceptOnFocusChange: false;     ghostText: 'as yet unclassified'.  self addMorph: textMorphimportClass: arg1  | tmp1 |  super importClass: arg1.  tmp1 := OrderedCollection new.  classQuery scope packagesDo: [:arg2 |  arg2 = arg1 package ifFalse: [ tmp1 add: arg2 ] ].  tmp1 size > 1 ifTrue: [ ^self error: 'You should select single package for import!' ].  tmp1 ifNotEmpty: [ ^tmp1 first addClass: arg1 ].  arg1 tags do: [:arg3 |  arg1 untagFrom: arg3 ]testNotExecutedFromMultipleScopeWhenAllSubqueriesAreFromEmptyScope  < expectedFailure>  super testNotExecutedFromMultipleScopeWhenAllSubqueriesAreFromEmptyScopeinstanceVariablesOf: arg1 do: arg2  | tmp1 |  self metaLevelsOf: arg1 do: [:arg3 |  tmp1 := (arg3 respondsTo: #localSlots) ifTrue: [ arg3 localSlots ] ifFalse: [ arg3 slots ].        tmp1 do: [:arg4 |  arg2 value: (ClyInstanceVariable on: arg4 definedIn: arg1) ] ]testFromTwoMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithFFIMethods >> #ffiMethod) .         (ClyClassWithFFIMethods >> #notFFIMethod)}.  self assert: foundSelectors sorted asArray equals: #(ffiMethod)lastSelectedItem  ^items firsttestConvertingToNewMetaLevel  | tmp1 tmp2 |  query subqueries: {(ClyAllMethodGroupsQuery from: ClyClassScope of: Object in: environment) .         (ClyAllMethodGroupsQuery from: ClySubclassScope of: Array in: environment)}.  tmp1 := query withMetaLevelScope: ClyInstanceSideScope.  self assert: tmp1 class equals: self queryClass.  self assert: (tmp1 subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: tmp1 requiredResult identicalTo: query requiredResult.  tmp2 := tmp1 subqueries collect: [:arg1 |  arg1 scope ] as: Set.  self assert: tmp2 equals: {(ClyInstanceSideScope of: Object) .         (ClySubclassScope of: Array localScope: ClyInstanceSideScope)} asSetkmDispatcher  ^CmdKMDispatcher attachedTo: selfplugins  ^pluginsisAppliedToBrowser  ^falsewarnUserAboutChangedContext  self belongsToCurrentBrowserContext ifTrue: [ self warnUserAboutMyContext ] ifFalse: [ self warnUserAboutDifferentContext ]testCheckEmptyQueryWhenThereIsEmptyResult  | tmp1 tmp2 |  tmp1 := self createQueryFromScope: ClyScopeExample empty.  tmp2 := environment query: tmp1.  self assert: tmp2 items isEmpty.  self assert: (environment isQueryEmpty: tmp1)isClassTagSelected  | tmp1 |  self isClassGroupSelected ifFalse: [ ^false ].  tmp1 := self lastSelectedItem type.  ^tmp1 isBasedOnClassTaginitialize  super initialize.  checkbox := CheckboxMorph on: self selected: #formatAsYouRead changeSelected: #toggle.  checkbox     getLabelSelector: #formatAsYouReadLabel;     labelClickable: true;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap;     setBalloonText: 'Autoformat code without editing. Useful when reading some old/unformatted code. You can configure your own format in the settings browser.'.  self addMorph: checkboxgroupProviderClass  ^ClyExpectedFailureMethodGroupProviderupdateItems: arg1  | tmp1 |  tmp1 := itemCursor findItemsWith: (arg1 collect: #actualObject).  arg1 with: tmp1 do: [:arg2 :arg3 |  arg2 updateItemWith: arg3 ]isSimilarTo: arg1  (super isSimilarTo: arg1) ifFalse: [ ^false ].  ^package = arg1 package and: [ classTag = arg1 classTag ]hash  ^super hash bitXor: methods hashdataSource  ^table dataSourcedisplayBlock: arg1  displayBlock := arg1fixStateBeforeExecution  super fixStateBeforeExecution.  subqueries do: [:arg1 |  arg1 fixStateBeforeExecution ]defaultMenuItemName  ^sourceNode hasExecutionCounter ifTrue: [ 'Remove counter (' , self currentCallsCount asString , ')' ] ifFalse: [ 'Remove counter' ]createBrowser  self subclassResponsibilitysetUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyInheritanceAnalysisEnvironmentPlugin newsetUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyInheritanceAnalysisEnvironmentPlugin newrefactoringScopes  | tmp1 tmp2 |  tmp1 := tool allNavigationScopes.  tmp2 := tool defaultNavigationScope.  ^(tmp1 copyWithout: tmp2) copyWithFirst: tmp2decorateBrowserItem: arg1 ofMethod: arg2  shouldSkipCurrentDesiredSelection: arg1  shouldSkipCurrentDesiredSelection := arg1createQueryResult  ^ClyGroupedClassVariables withHierarchy: ClySubclassHierarchy newreadParametersFromContext: arg1  super readParametersFromContext: arg1.  methodDataSource := arg1 browser resultView dataSourcebuild  fullIndentation ifTrue: [ self buildWithFullIndentation ] ifFalse: [ self buildWithLabelIndentation ]testSelectedItemPointsToRetrievedDataSource  | tmp1 |  self snapshotState.  tmp1 := navigationState selection items first.  self assert: tmp1 ownerDataSource equals: navigationState dataSourcedetachFromSystem  methodWithoutBreakpoints2  subscribe: arg1  actualResult subscribe: arg1basisSize  ^basisObjects sizetag: arg1  tag := arg1parserClass  ^RBParserfindString: arg1 asSelectorIn: arg2  | tmp1 tmp2 tmp3 |  arg1 ifNil: [ ^0 to: 0 ].  arg2 isEmptyOrNil ifTrue: [ ^0 to: 0 ].  tmp1 := arg2 asString.  tmp2 := 0 to: 0.  (arg1 includes: $:) ifTrue: [ | tmp4 |        tmp4 := arg1 substrings: ':'.        tmp4 size = 1 ifTrue: [ tmp3 := self findFirstOccurrenceOf: arg1 in: tmp1.              tmp3 isZero ifFalse: [ tmp2 := tmp3 to: tmp3 + arg1 size - 1 ] ] ifFalse: [ | tmp5 |              tmp3 := self findFirstOccurrenceOf: tmp4 first , ':' in: tmp1.              tmp3 > 0 ifTrue: [ tmp5 := tmp1 findString: tmp4 last , ':' startingAt: tmp3 + (tmp4 first size - 1).                    tmp2 := tmp3 to: tmp5 + tmp4 last size ] ] ] ifFalse: [ tmp3 := self findFirstOccurrenceOf: arg1 in: tmp1.        tmp3 > 0 ifTrue: [ tmp2 := tmp3 to: tmp3 + arg1 size - 1 ] ].  ^tmp2decorateMethodGroupTableCell: arg1 of: arg2  | tmp1 |  tmp1 := ClyMethodVisibilityMorph for: arg1 browser level: self.  tmp1 build.  arg1 definitionMorph: tmp1testFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> #method1).  self assert: (resultItems identityIncludes: self class >> #method2)depth  ^depthrequestSingleMethodTag: arg1 suggesting: arg2  | tmp1 tmp2 tmp3 |  tmp1 := (SystemNavigation default allExistingProtocolsFor: true) reject: [:arg3 |  arg3 beginsWith: '*' ].  tmp1 := tmp1 asSortedCollection: [:arg4 :arg5 |  arg4 asLowercase < arg5 asLowercase ].  tmp2 := ListDialogWindow new     getList: [:arg6 |  tmp1 select: [:arg7 |  arg6 search: arg7 ] ];     displayBlock: [:arg7 |  arg7 ];     initialAnswer: arg2;     acceptNewEntry: true;     title: arg1;     yourself.  tmp3 := tmp2 chooseFromOwner: tool.  tmp3 isEmptyOrNil ifTrue: [ CmdCommandAborted signal ].  (tmp3 beginsWith: '*') ifTrue: [ self inform: 'Star is forbidden for protocol name. You can specify package in method editor using status bar checkbox'.        ^CmdCommandAborted signal ].  ^tmp3 asSymboltestVariablesEnumerationForObject  scope := ClyClassScope of: Object.  scope variablesDo: [:arg1 |  result add: arg1 ].  self assert: result size equals: 1.  self assert: result anyOne equals: (ClyClassVariable on: Object classVariables first definedIn: Object)isBasedOnQueryOf: arg1  ^query retrievesItemsOfType: arg1testComparisonWithQueryOfAnotherGroup  | tmp1 |  tmp1 := self createQuery.  tmp1 groupName: 'another group'.  self deny: query equals: tmp1collectMethodGroupProviders  ^{ClyAbstractMethodGroupProvider .   ClyOverridingMethodGroupProvider .   ClyOverriddenMethodGroupProvider .   ClyRequiredMethodGroupProvider} collect: [:arg1 |  arg1 new ]iconName: arg1  iconName := arg1testConvertingToInheritingScope  | tmp1 |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  tmp1 := scope asInheritingScope.  self assert: (tmp1 representsScope: ClySubclassScope).  self assert: tmp1 localScopeClass equals: ClyInstanceSideScope.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 environment equals: environment.  self assert: tmp1 name equals: ClyClassScope inheritingScopeNametestSelectsMethodWithHalt  self assert: (query selectsMethod: ClyClassWithHalts >> #methodWithHalts1)checkEmptyResult  ^resultItems notEmptycheckEmptyResult  scope packagesDo: [:arg1 |  ^false ].  ^truetestAscending  function := ClySortMethodBySelectorFunction ascending.  self deny: (function value: Object >> #size value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)itemsWhere: arg1  ^self protectItemsWhile: [ items select: arg1 ]hasSelectedItems  ^self isEmpty not= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^isCaseSensitive = arg1 isCaseSensitiveisAccessibleFrom: arg1  (arg1 instanceSide includesSharedPoolNamed: definingClass name) ifTrue: [ ^true ].  ^arg1 instanceSide = definingClass or: [ arg1 instanceSide inheritsFrom: definingClass ]hash  ^super hash bitXor: actualObjectSortFunction hashproperties  ^propertiesprojectManager  ^projectManagerdefaultMenuIconName  ^#scriptManagerIcontestNotMatchesMethodWithWrongClassAndPackageAndSelector  filter := ClyQueryBrowserFilter substringPattern: 'filter not matches package, class or selector'.  self deny: (filter matches: self itemOfThisTestMethod)queryResult  ^queryResultspawnQueryBrowserOn: arg1  browser spawnQueryBrowserOn: arg1decorateMethodGroupTableCell: arg1 of: arg2  | tmp1 |  tmp1 := ClyMethodVisibilityMorph for: arg1 browser level: self.  tmp1 build.  arg1 addExtraIcon: #hierarchy.  arg1 addExtraTool: tmp1methodsSize  ^self methods sizeabstractMethod1  self subclassResponsibilitydescribes: arg1  ^(arg1 isKindOf: ClyFullBrowserContext) and: [ arg1 isClassSelected not ]methodWithExpectedStringInSources  ^self printStringtestMatchesAnyStringWhenItIsOnlySpaces  | tmp1 |  tmp1 := ClyRegexPattern with: '  '.  self assert: (tmp1 matches: 'any string')parseClassDefinition  ^CDClassDefinitionParser parse: self editingTextbaseQueryResult  ^baseQueryResultupdateUsing: arg1 by: arg2  [ updateGuard critical: [ | tmp1 |        tmp1 := updateStrategy.        [ updateStrategy := arg1.        arg2 on: Error do: [:arg3 |  updateStrategy := tmp1.              updateGuard := Mutex new.              arg3 pass ] ] ensure: [ updateStrategy == arg1 ifTrue: [ updateStrategy := tmp1 ] ] ] ] ensure: [ arg1 publishCollectedChanges ]testDescendingDifferentPackage  function := ClySortMethodByPackageFunction descending.  self deny: (function value: Number >> #printString value: Object >> #printString).  self assert: (function value: Object >> #printString value: Number >> #printString)runTest: arg1 of: arg2  | tmp1 |  tmp1 := arg2 debug: arg1.  self notifyUserAboutResults: tmp1 with: 'Method: ' , arg2 asString , '>>#' , arg1 asStringselectsMethod: arg1  ^arg1 tags isEmptyisAffectedByPackageChange: arg1  ^falseresetStateForSnapshot  super resetStateForSnapshot.  textMorph := nil.  textModel := nilclassScopeForMethods  | tmp1 |  tmp1 := methodGroupQuery scope asScope: metaLevelScope.  ^self extendClassScopeForMethods: tmp1createRefactoring: arg1 for: arg2  ^actualVariable createRefactoring: arg1 for: arg2isInstanceSideMethodSelected  self isMethodSelected ifFalse: [ ^false ].  ^self selectedMethodItems anySatisfy: [:arg1 |  arg1 systemDefinition isInstanceSide ]announceChangesOf: arg1  updateStrategy announceChangesOf: arg1browserClass: arg1  browserClass := arg1testDescendingMethodsWithSameSelectorButDifferentClass  function := ClySortMethodBySelectorFunction descending.  self assert: (function value: Object >> #printString value: Number >> #printString).  self deny: (function value: Number >> #printString value: Object >> #printString)pattern: arg1  pattern := arg1initialize  super initialize.  subgroupsQuery := ClyUnknownQuery instanceasGlobalScopeIn: arg1  ^ClySystemEnvironmentScope of: self in: arg1 named: namequery: arg1  self isBasedOnEmptyBasis ifTrue: [ ^ClyUnknownQueryResult instance ].  arg1 ensureScope: self.  ^environment query: arg1defaultMenuItemName  ^'Convert to protocol'systemQuery  ^methodQuerybelongsToRemovedBrowserContext  super belongsToRemovedBrowserContext ifTrue: [ ^true ].  ^self methodClass isObsoleterequiredQueryResult  ^ClyTraitUserHierarchy inverse asQueryResultselectedMethodGroups  ^self actualSelectionFrom: self selectedMethodGroupItemsnewTestClassCategoryFor: arg1  | tmp1 |  tmp1 := arg1 package classTagForClass: arg1.  ^String streamContents: [:arg2 |  arg2           nextPutAll: arg1 package name;           nextPutAll: '-Tests'.        tmp1 isRoot ifFalse: [ arg2                 nextPut: $-;                 nextPutAll: tmp1 name ] ]defaultMenuItemName  ^'Senders'testIsBuiltWhenItemsExist  queryResult initializeItems.  self assert: queryResult isBuiltdefaultMenuItemName  ^'Add breakpoint'rebuild  self initializeItems.  buildingQuery buildResult: self.  metadata := nilretrievesItem: arg1  ^self selectsClass: arg1testFillingWithMethodsAndClasses  queryResult fillWith: {ClyClass1FromP1 .         (ClyClass1FromP1 >> #tag1Method1)}.  self assertItems: #(tag1Method1 0 ClyClass1FromP1 0) withValue: [:arg1 |  arg1 name ]queryEnvironment  ^query environmenttestFillingWithUsersOfTraitWhenRootTraitIsMissingInGivenList  queryResult fillWith: {ClyTraitChild1 .         ClyClassWithTraits .         ClyTraitChild2}.  self assertItems: {ClyTraitChild1 .         0 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         0 .         ClyClassWithTraits .         1}createBrowser  ^ClyQueryBrowser newisMoreImportantThan: arg1  ^self level > arg1 levelqueryScopes: arg1  queryScopes := (arg1 reject: [:arg2 |  arg2 isBasedOnEmptyBasis ]) as: OrderedCollectionadoptQuery: arg1  arg1 scope: self.  ^arg1changesAnnouncer: arg1  changesAnnouncer := arg1createQuery  ^ClyTaggedMethodsQuery by: #tag1 from: (ClyClassScope of: ClyClass1FromP1 in: environment)createSampleScope  | tmp1 tmp2 |  tmp1 := ClyScopeExample of: #basisObject in: environment.  tmp2 := ClyScopeExample2 of: #basisObject2 in: environment.  ^ClyCompositeScope on: {tmp1 .         tmp2}analyzedObject  ^analyzedObjectbuildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope classVariablesDo: [:arg2 |  tmp1 add: arg2 ].  arg1 fillWith: tmp1currentIcon  ^TabMorph perform: (#refreshIcon , progress asString) asSymbolisMethodOverriding: arg1  ^arg1 isOverridingsimpleNameForSpotterMenu  ^'Projects'defaultMenuIconName  ^#removeIconshowsFlatClasses  ^self packageSelection isEmpty not and: [ (classView showsItemsFromScope: ClyClassHierarchyScope) not ]meaningfullObjectToAssert: arg1  ^arg1 actualObject classisResult: arg1 affectedBy: arg2  arg2 affectsCritiques ifFalse: [ ^false ].  (super isResult: arg1 affectedBy: arg2) ifTrue: [ ^true ].  arg1 forceLazyRebuild.  ^falsereferenceOfSmalltalk  ^SmalltalkprepareFullExecutionInContext: arg1  | tmp1 tmp2 |  super prepareFullExecutionInContext: arg1.  tmp1 := ', ' join: (methodGroups collect: #name).  (methodGroups anySatisfy: [:arg2 |  arg2 methodsSize > 0 ]) ifTrue: [ tmp2 := UIManager default confirm: 'Are you sure you want to remove methods tagged with ' , tmp1 , '?'.        tmp2 ifFalse: [ CmdCommandAborted signal ] ]isAppliedToBrowser  ^browser showsFlatResultswitchToFullClassHierarchy  | tmp1 |  tmp1 := self classSelection asItemsScope: ClyInstanceSideScope.  self switchClassViewTo: ClyHierarchicallySortedClasses new inScope: tmp1 asFullHierarchyScopedescription  ^'overridden methods'createQueryResult  ^ClyRawQueryResult newwithExtraBasisObject: arg1  (basisObjects includes: arg1) ifTrue: [ ^self ].  ^self withNewBasisObjects: (basisObjects copyWith: arg1)testFromTwoMethods  self installCounterInto: #methodWithCounter.  self queryFromScope: ClyMethodScope ofAll: {(self class >> #methodWithCounter) .         (self class >> #methodWithoutCounter)}.  self assert: foundSelectors sorted asArray equals: #(#methodWithCounter)buildLabel  label := self theme newLabelIn: self label: self printMethodTagsOrPackage.  label on: #click send: #openEditor to: selfdefaultTitle  ^'setUp'decorateTool  self subclassResponsibilitydecorateBrowserItem: arg1 ofMethod: arg2  | tmp1 |  tmp1 := ClyClassScript detectInMethod: arg2 ifAbsent: [ ^self ].  arg1 addProperty: (ClyClassScriptProperty script: tmp1)isBoundToEnvironment  ^environment notNilisAsync  ^falsefindItemsWith: arg1  | tmp1 tmp2 |  tmp1 := super findItemsWith: arg1.  tmp1 size == arg1 size ifTrue: [ ^tmp1 ].  tmp2 := expandedItems flatCollect: [:arg2 |  arg2 childrenDataSource findItemsWith: arg1 ].  ^tmp1 , tmp2testIsAffectedByChangeOfSubclassMethodWhichOverridesSuperclass  self assert: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #overriddenMethod)isRoot  ^parentItem isNilincludesClassGroupsAffectedBy: arg1  | tmp1 |  basisObjects do: [:arg2 |  environment pluginsDo: [:arg3 |  tmp1 := arg3 collectClassGroupProviders.              tmp1 do: [:arg4 |  (arg4 providesGroupsAffectedBy: arg1 inScope: self) ifTrue: [ ^true ] ] ] ].  ^falsebelongsToCurrentBrowserContext  ^browser methodSelection isEmpty ifTrue: [ browser isClassSelected: self editingMethod origin ] ifFalse: [ browser isMethodSelected: self editingMethod ]isResult: arg1 affectedBy: arg2  ^scope includesMethodsAffectedBy: arg2decorateTableCell: arg1 inContext: arg2  ^self decorateTableCell: arg1 of: arg2 lastSelectedItemhasBrokenTests  ^failureCount > 0 | (errorCount > 0)tearDown  installedBreakpoints do: [:arg1 |  arg1 remove ].  installedBreakpoints removeAll.  super tearDownshoutAboutToStyle: arg1  ^self wantsTextStylingcreateQuery  ^ClyQueryExampleReturningScopeBasis from: (ClyScopeExample ofAll: {Array .               Object .               String} in: environment) as: self createQueryResultprintExtraInfoOn: arg1  super printExtraInfoOn: arg1.  arg1 nextPutAll: self printSelectorstestComparisonWithDifferentScope  | tmp1 |  scope := self createSampleScope.  tmp1 := ClyScopeExample2 of: #basisObject in: environment.  self deny: scope equals: tmp1asTraitVisibility  | tmp1 |  tmp1 := extraClassScope basisObjects select: [:arg1 |  arg1 isTrait ].  ^(ClySingleTraitVisibilityLevel of: visibleClassScope) extraClassScope: (visibleClassScope asScope: ClyClassScope ofAll: tmp1)testClassEnumerationOverClassWhenConcreteClassScopeIsLocal  | tmp1 |  scope := ClySubclassScope of: Class localScope: ClyClassScope.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := Class allSubclasses asSet.  self assert: result asSet equals: tmp1 asSetincludesClassesAffectedBy: arg1  ^arg1 affectsClassesrequestNavigationBy: arg1  navigationSelector := arg1getProperty: arg1  ^browserItem getProperty: arg1hash  ^super hash bitXor: package hashbrowser  ^browser= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^itemType = arg1 itemTypeconfirmUnusedVariablesInDefiningClass: arg1  ^self browser confirmUnusedVariablesInDefiningClass: arg1isExtension  ^isExtensionwantsDropPassenger: arg1 at: arg2  | tmp1 |  tmp1 := self createSelectionContextOf: arg2 asSelection.  ^arg1 canBeDroppedInContext: tmp1printOn: arg1  | tmp1 |  super printOn: arg1.  arg1 nextPut: $(.  tmp1 := arg1 position.  self printExtraInfoOn: arg1.  arg1 position = tmp1 ifTrue: [ arg1           skip: -1;           nextPut: $  ] ifFalse: [ arg1 nextPutAll: ') ' ].  arg1 nextPutAll: 'from '.  scope isBasedOnEmptyBasis ifTrue: [ arg1 nextPutAll: 'empty scope' ] ifFalse: [ scope printDescriptionOn: arg1 ]testSelectsAbstractMethodWhichIsNotImplemented  self assert: (query selectsMethod: ClyAbstractClassExample >> #abstractMethod2).  self assert: (query selectsMethod: ClyAbstractSubclassExample >> #abstractSubclassMethod)executeCommand: arg1 by: arg2  arg1 isComplexRefactoring ifTrue: [ arg1 confirmRefactoringInContext: self by: arg2 ].  arg1 executetearDown  installedCounter uninstall.  super tearDowndescription  ^'unclassified methods'printOn: arg1  super printOn: arg1.  inverse ifTrue: [ arg1 nextPutAll: '(inverse)' ]switchFocusToPreviousPane  | tmp1 tmp2 |  tmp1 := navigationViews detect: [:arg1 |  arg1 hasKeyboardFocus ] ifNone: [ ^self ].  tmp2 := navigationViews before: tmp1 ifAbsent: [ ^self ].  tmp2 takeKeyboardFocustestFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reader1OfVar1) .         (self class >> #writerOfVar1)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reader1OfVar1outOfWorld: arg1  super outOfWorld: arg1.  self detachFromTextMorphextensionMethodFromRoot1Trait  currentCallsCount  ^sourceNode counter countcreateMethodGroupFor: arg1 from: arg2  | tmp1 |  tmp1 := ClyExtendingPackagesQuery from: arg2 as: ClyGroupedExtendingPackages new.  ^ClyMethodGroup named: 'extensions' priority: 9 on: arg1 withSubgroupsFrom: tmp1prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browserconcreteResultOf: arg1 ifPresent: arg2  ^testCaseResults at: arg1 ifPresent: arg2showMessage: arg1 renamedTo: arg2  tool editingMethod selector == arg1 selector ifTrue: [ tool switchToMethod: tool methodClass >> arg2 ] ifFalse: [ tool selectAnySelector: {arg2} ]importClasses: arg1  arg1 do: [:arg2 |  self importClass: arg2 ]singleBasisSample  ^self class >> #method1testFilterObjectWithName  filter := ClyItemNameFilter substringPattern: 'ject'.  self assert: (filter matches: Object).  self deny: (filter matches: Array)testIsBuiltWhenBuildComplete  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self assert: queryResult isBuiltcollate: arg1 with: arg2  (arg1 selector isBinary and: [ arg2 selector isBinary not ]) ifTrue: [ ^-1 ].  (arg1 selector isBinary not and: [ arg2 selector isBinary ]) ifTrue: [ ^1 ].  arg1 selector = arg2 selector ifTrue: [ ^arg1 origin name threeWayCompareTo: arg2 origin name ].  ^arg1 selector threeWayCompareTo: arg2 selectornewMethodView  ^self newNavigationView     displayMainColumnBy: [:arg1 :arg2 |  self specifyMethodItemNameOn: arg1 label for: arg2 browserItem ];     requestNavigationBy: #methodSelectionChangedinitialize  super initialize.  depth := 0.  properties := OrderedCollection new.  isPrepared := falsetestDescendingForBinaryAndUnarySelectors  function := ClySortMethodBySelectorFunction descending.  self assert: #| > #abs.  self deny: (function value: Integer >> #| value: Number >> #abs).  self assert: (function value: Number >> #abs value: Integer >> #|).  self deny: #+ > #abs.  self deny: (function value: Number >> #+ value: Number >> #abs).  self assert: (function value: Number >> #abs value: Number >> #+)elementAt: arg1  self subclassResponsibilitytitle  ^activator menuItemNamestepTime  ^100collate: arg1 with: arg2  | tmp1 |  tmp1 := arg1 package name threeWayCompareTo: arg2 package name.  tmp1 = 0 ifFalse: [ ^tmp1 ].  tmp1 := arg1 origin name threeWayCompareTo: arg2 origin name.  tmp1 = 0 ifFalse: [ ^tmp1 ].  ^arg1 selector threeWayCompareTo: arg2 selectordefaultTitle  ^browser metaLevelScope defaultName capitalized , ' method'isSameAs: arg1  type = arg1 type ifFalse: [ ^false ].  ^type checkCalypsoItem: actualObject isSameAs: arg1 actualObjecttestNotExecutedFromSingleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  query subqueries: {(self subqueryFromScopeOf: self class) .         (self subqueryFromScopeOf: self class superclass)}.  self deny: query isExecutedFromSingleScopeopenInWindow: arg1  | tmp1 tmp2 |  tmp1 := self createWindowGroupFrom: arg1.  tmp2 := self buildWindow.  tmp1 addWindow: tmp2.  tmp2 activate.  tmp2 announceOpenedupdateItemCache  | tmp1 |  tmp1 := cache createFullUpdateOf: queryResult.  cache := tmp1 itemCache.  itemCount := tmp1 totalItemCount.  metadata := tmp1 metadatasystemQuery  ^systemQuerytestFromTwoMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyTestedClassTest >> #testExpectedFailure) .         (ClyTestedClassTest >> #testOne)}.  self assert: foundSelectors sorted asArray equals: #(testExpectedFailure)= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^value = arg1 valuetestHasDefaultBaseQueryResultByDefault  self assert: queryResult baseQueryResult class equals: ClySortedQueryResultinitialize  super initialize.  isSameAsCurrent := truetestClassEnumerationOverInstanceSideBasisWhenBothMetaLevelsAreLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {Object .         Object class .         ProtoObject .         ProtoObject class} asSetexecute  GTSpotterMorph new     extent: ((World width / 2.4) @ (World height / 1.6)) asIntegerPoint;     doLayout;     spotterModel: (GTSpotter on: (ClySpotterModel on: browser));     openCenteredInWorldallElements  ^(1 to: self numberOfRows) collect: [:arg1 |  self elementAt: arg1 ]buildExtensionItemsFrom: arg1  | tmp1 |  tmp1 := self buildItemsFrom: arg1.  tmp1 do: [:arg2 |  arg2 markWith: ClyExtendedClassTag ].  ^tmp1two: arg1  two := arg1testSelectsMethodWithWatchpoint  self installWatchpointInto: #methodWithWatchpoint.  self assert: (query selectsMethod: self class >> #methodWithWatchpoint)errorCount  ^errorCounttestFillingWithMethodsOfSameClass  queryResult fillWith: (#(tag1Method1 instanceSideVar1WriterMethod instanceSideVar1ReaderMethod) collect: [:arg1 |  ClyClass1FromP1 >> arg1 ]).  self assertItems: #(#instanceSideVar1ReaderMethod 0 #instanceSideVar1WriterMethod 0 #tag1Method1 0) withValue: [:arg1 |  arg1 name ]switchToPackages  | tmp1 |  tmp1 := ClyAllPackagesQuery sortedFrom: self systemScope.  packageView showQuery: tmp1printDescriptionOn: arg1  name ifNotNil: [ ^super printDescriptionOn: arg1 ].  subscopes do: [:arg2 |  arg2 printDescriptionOn: arg1.        arg1 nextPutAll: ', ' ].  arg1 skip: -2isVariableSelected  ^self hasSelectedItemsname  ^name ifNil: [ super printString ]iconName  ^#scriptManagerIconhasKeyboardFocus  ^super hasKeyboardFocus or: [ table hasKeyboardFocus ]pendingText  ^textMorph textitem: arg1  item := arg1isInProjectView  ^self packageView showsItemsFromQuery: (systemScope projectQueryFor: self systemScope) classrootParentItem  ^ownerDataSource isRoot ifTrue: [ self ] ifFalse: [ self parentItem rootParentItem ]testComparisonToSimilarQueryButWithDifferentPackage  | tmp1 |  query package: Object package.  tmp1 := self createQuery.  tmp1 package: String package.  self deny: query equals: tmp1initialize  super initialize.  queryScopes := OrderedCollection new.  expectedFlatQueryResult := self defaultFlatQueryResultmethodGroup  ^methodGrouptraitScopeClass  ^ClyInheritedTraitScopeopenOn: arg1  super openOn: arg1.  expandedItems do: [:arg2 |  arg2 childrenDataSource openOn: arg1 ]extraBasisSample  self subclassResponsibilitydecorateBrowserItem: arg1 ofMethod: arg2  arg2 origin isTrait ifTrue: [ arg1 systemDefinition definingClassItem markWith: ClyTraitTag ]prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  package := arg1 lastSelectedPackage.  classGroup := arg1 lastSelectedClassGroup.  newName := UIManager default request: 'New name of the class tag' initialAnswer: classGroup name title: 'Rename a class tag'.  newName isEmptyOrNil | (newName = classGroup name) ifTrue: [ CmdCommandAborted signal ]buildActualResult  [ actualResult := buildingQuery execute.  (items := actualResult items) isNil ] whileTrue.  self collectMetadata.  buildProcess := nil.  self buildIsDonecreateMethodQueryFrom: arg1  ^ClyOverridingMethodsQuery from: arg1isSimilarTo: arg1  ^self class = arg1 class and: [ testClass == arg1 testClass ]collate: arg1 with: arg2  arg1 priority = arg2 priority ifTrue: [ ^arg1 name threeWayCompareTo: arg2 name ].  ^arg2 priority threeWayCompareTo: arg1 priorityselectedItem  ^viewDataSource elementAt: 1testFillingWithClassesFromOneHierarchy  queryResult fillWith: {ClySubclassN1OfClass1FromP1 .         ClySubclassLOfSubclassMFromP3 .         ClyClass1FromP1 .         ClySubclassN2OfClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1 .         ClySubclassN1OfClass1FromP1 .         1 .         ClySubclassN2OfClass1FromP1 .         1}isLive  ^trueexecute  [ browser selectClass: (self testClassFor: targetClass) ] on: ClyInvalidClassForTestClassGeneration do: [:arg1 |  self inform: 'Cannot generate test class for ' , arg1 baseClass printString , '.' ]testComparisonWithCompositeScopeBasedOnDifferentQueries  | tmp1 |  scope := self createSampleScope.  tmp1 := self createSampleScope.  tmp1 subscopes: {(ClyScopeExample2 of: #someBasis in: environment)}.  self deny: scope equals: tmp1itemCount  ^itemCountselectsTools: arg1  | tmp1 |  tmp1 := self selectedTools.  tmp1 size = arg1 size ifFalse: [ ^false ].  ^tmp1 allSatisfy: [:arg2 |  arg1 anySatisfy: [:arg3 |  arg2 isSimilarTo: arg3 ] ]testDecoratingMethodWithHalt  | tmp1 tmp2 tmp3 |  tmp1 := ClyReflectiveEnvironmentPlugin new.  tmp2 := ClyClassWithHalts >> #methodWithHalts1.  tmp3 := tmp2 asCalypsoBrowserItem.  tmp1 decorateBrowserItem: tmp3 ofMethod: tmp2.  self assert: (tmp3 isMarkedWith: ClyMethodWithHaltTag).  self deny: (tmp3 isMarkedWith: ClyMethodWithBreakpointTag)testClassEnumerationOverMetaclassWhenConcreteClassScopeIsLocal  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassScope.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: ClyClass1FromP1 class allSuperclasses asSetselectedItemsOfType: arg1  ^selectedItems select: [:arg2 |  arg2 isBasedOnItemType: arg1 ]isSelectedItemHasWatchpoint  ^selectedItems anySatisfy: [:arg1 |  arg1 isMarkedWith: ClyMethodWithWatchpointTag ]printExtraInfoOn: arg1  ^arg1 nextPutAll: self descriptionselectedMethodItems  ^selectedItems select: [:arg1 |  arg1 isBasedOnItemType: ClyMethod ]testClassVarsEnumerationWhenTheyNotExist  scope := ClyClassScope of: ClyClass1FromP1.  scope classVariablesDo: [:arg1 |  result add: arg1 ].  self assert: result isEmptydecorateResultMethodEditor: arg1  arg1 selectAnySelector: selectorssimpleNameForSpotterMenu  ^self defaultTitleisAppliedToBrowser  ^browser classView showsItemsFromScope: self traitScopeClasssubclassClassVar1Reader  ^ClassVar1projects  ^projectManager projectscurrentScope  ^self scopes detect: [:arg1 |  browser isQueryScopeActive: arg1 ]doItReceiver  ^self selectedClassOrMetaClass ifNotNil: [:arg1 |  arg1 instanceSide ]displayMainColumnBy: arg1  self mainColumn displayBlock: arg1description  ^'senders of ' , self printSelectorsprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  selectedClassItem := arg1 lastSelectedItemlastSelectedProjectChild  ^self lastSelectedObjectIn: self selectedProjectChildrentestComparisonWithSimilarScopeButWithDifferentMetaLevelScope  | tmp1 |  scope := self createSampleScope.  tmp1 := self createSampleScope.  self deny: scope localScopeClass equals: ClyInstanceSideScope.  tmp1 localScopeClass: ClyInstanceSideScope.  self deny: scope equals: tmp1findDataSourceSameAs: arg1 ifNone: arg2  ^(self isSameAs: arg1) ifTrue: [ ^self ] ifFalse: arg2singleBasisSample  ^ClyClass1FromP1testAllItems  | tmp1 tmp2 |  tmp1 := cursor retrieveAll.  self assert: tmp1 equals: queryResult items.  tmp2 := tmp1 reject: #isPrepared.  self assert: tmp2 isEmpty.  self assert: (tmp1 collect: #position) asArray equals: (1 to: queryResult size) asArraycreateMethodGroupFor: arg1 from: arg2  ^ClyAllCritiquesMethodGroup withMethods: arg1 actualQuery from: arg2activateExtraScope  ^visibleClassScope increasedByClassesFrom: extraClassScope= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^resultItems = arg1 resultItemstreeStructure: arg1  treeStructure := arg1testNotBasedOnMultipleBasisWhenSingleSubscopeIsNot  | tmp1 |  tmp1 := ClyScopeExample of: #basisObject in: environment.  scope := ClyCompositeScope on: {tmp1}.  self deny: scope isBasedOnMultipleBasischeckEmptyResult  scope classVariablesDo: [:arg1 |  ^false ].  ^truechangesAreAboutApply  | tmp1 |  super changesAreAboutApply.  tmp1 := statusBar findDeeplyA: ClyMethodTagsEditorMorph.  tmp1 ifNil: [ ^self ].  tmp1 acceptTagstestConvertingWithoutExistingBasisObject  | tmp1 |  scope := self multipleScopeSample.  tmp1 := scope withoutBasisObject: self extraBasisSample.  self assert: tmp1 class equals: scope class.  self deny: (tmp1 basisObjects includes: self extraBasisSample).  self assert: (tmp1 basisObjects includes: self singleBasisSample)decorateBrowserItem: arg1 ofMethod: arg2  arg2 isAbstract ifTrue: [ arg1 markWith: ClyAbstractItemTag ].  (self isMethodOverriding: arg2) ifTrue: [ arg1 markWith: ClyOverridingMethodTag ].  (self isMethodOverridden: arg2) ifTrue: [ arg1 markWith: ClyOverriddenMethodTag ]testIsEmptyFromEmptyMethodScope  query scope: (ClyMethodScope emptyIn: environment).  self assert: query checkEmptyResultisResult: arg1 affectedBy: arg2  ^(arg2 canAffectResultOfMethodQuery: self) and: [ scope includesMethodsAffectedBy: arg2 ]confirmUnusedVariablesInDefiningClass: arg1  | tmp1 tmp2 |  tmp2 := ClyBothMetaLevelClassScope ofAll: (arg1 collect: [:arg2 |  arg2 definingClass ]) in: navigationEnvironment.  tmp1 := ClyVariableReferencesQuery ofAny: arg1 from: tmp2.  ^self confirmEmptySystemQuery: tmp1deselectTab  containerTab removeFromSelectiontestQueryResultShouldBeCached  | tmp1 tmp2 |  tmp1 := environment query: (self createQueryFromScopeOf: self class).  tmp2 := environment query: (self createQueryFromScopeOf: self class).  self assert: tmp1 identicalTo: tmp2defaultColor  ^Color transparent= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^sortFunction = arg1 sortFunctionupdateItemWith: arg1  browserItem := arg1item  ^itemupdateItems  | tmp1 |  tmp1 := CmdMenu activatedBy: ClyToolbarActivation.  browser navigationContextsDo: [:arg1 |  tmp1 buildInContext: arg1 ].  self hide.  self removeAllMorphs.  [ tmp1 buildBrowserToolbar: self ] ensure: [ self show ]attachToSystem  browser system when: (ClyPackageChange of: editingPackage) send: #triggerUpdate to: selfstartPosition  ^startPositionqueryResult: arg1  queryResult := arg1.  position := 0.  cache := ClyBrowserQueryCache withSize: 20.  itemCount := arg1 size.  metadata := queryResult metadatainitializeForBrowserStateSnapshot  selectedItems := selectedItems collect: [:arg1 |  arg1 copyForBrowserStateSnapshot ].  selectedItems do: [:arg1 |  arg1 ownerDataSource parentItem: nil ].  tool := nilprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browsertestFromThreeMethodsWhenImplementorsCacheShouldBeUsed  | tmp1 |  tmp1 := environment getPlugin: ClyInheritanceAnalysisEnvironmentPlugin.  tmp1 littleHierarchyMaxSize: -1.  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (ClyAbstractClassExample >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 overriddenMethod)findAnySelectorInSourceCode: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := editingMethod astForStylingInCalypso.  tmp2 := tmp4 sendNodes detect: [:arg2 |  arg1 includes: (tmp1 := arg2 selector) ] ifNone: [ tmp4 allChildren detect: [:arg2 |  arg2 isLiteralNode and: [ arg1 includes: arg2 value ] ] ifFound: [:arg3 |  ^arg3 sourceInterval ].        ^0 to: -1 ].  tmp3 := tmp2 keywordsPositions.  ^tmp3 first to: tmp3 last + tmp1 keywords last size - 1checkEmptyResult  ^truetag  ^tagdefaultMenuItemName  ^'Flat'accumulateTestMethod: arg1  self accumulateTest: arg1 selector of: arg1 methodClassdecorateTableCell: arg1 of: arg2  super decorateTableCell: arg1 of: arg2.  (arg2 isMarkedWith: ClyBackgroundProcessingTag) ifTrue: [ arg1 definitionMorph: ClyActivityAnimationIconMorph new ] ifFalse: [ methodQuery decorateMethodGroupTableCell: arg1 of: arg2 ]detachFromSystem  system unsubscribe: self.  plugins do: [:arg1 |  arg1 detachFromSystem ]childrenCount  ^ownerDataSource countChildrenOf: selfbuildLeftSideBar  super buildLeftSideBar.  self leftSideBar enableMouseCommands: CmdTextLeftBarClickActivation withContextFrom: selfisValidClass: arg1  ^(arg1 isTestCase or: [ arg1 isMeta ]) notmethodWithCounter  ^1 + 2selectedClassItems  ^tool classSelection itemsprintAsConstantQueryItem  ^self namemethodGroupsDo: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  self methodGroupProvidersDo: [:arg2 |  tmp2 := arg2 buildGroupsFrom: self.        arg2 isStatic ifTrue: [ tmp2 do: arg1 ] ifFalse: [ tmp1 addAll: tmp2 ] ].  self processDynamicMethodGroups: tmp1 by: arg1testConvertingToNewMetaLevel  | tmp1 |  scope := ClyCompositeScope on: {(ClyClassScope of: Object in: environment) .         (ClySubclassScope of: Array in: environment)}.  tmp1 := scope withMetaLevel: ClyInstanceSideScope.  self assert: tmp1 class equals: ClyCompositeScope.  self assert: tmp1 subscopes first equals: (ClyInstanceSideScope of: Object).  self assert: tmp1 subscopes last class equals: ClySubclassScope.  self assert: tmp1 subscopes last localScopeClass equals: ClyInstanceSideScope.  self assert: tmp1 environment equals: environment.  self assert: (tmp1 subscopes collect: #environment as: Set) equals: {environment} asSetdefaultItems  ^OrderedCollection newdecorateOwnBrowserItem: arg1  isScopedModeEnabled  ^packageView showsItemsFromScope: ClyPackageScopepackage: arg1  package := arg1testCheckIfEmpty  query tag: #Tag1.  query scope: (ClyClassScope of: ClyClass7WithTag1FromP5 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ClyClass8WithTag2FromP5 in: environment).  self assert: query checkEmptyResulttriggerClickCommands  CmdClickActivation executeCommandInContext: self createSelectionContextdefaultTitle  ^'Diff'refactoringScopes  ^self browser allNavigationScopesinstalledMethods  | tmp1 tmp2 |  tmp1 := methods select: [:arg1 |  arg1 isCompiledMethod ].  tmp2 := self filterInstalledMethods: tmp1 , extraMethods.  ^tmp2 , (methods reject: [:arg1 |  arg1 isCompiledMethod ])extensionMethodFromClassItself  testCreationFromTwoQueriesOfSameTypeSimilarScope  | tmp1 tmp2 |  tmp1 := self subqueryFromScope: ClyScopeExample of: Array.  tmp2 := self subqueryFromScope: (ClyScopeExample ofAll: {String .               Array}).  query := tmp1 , tmp2.  self assert: query class equals: tmp1 class.  self deny: query identicalTo: tmp1.  self assert: query scope equals: (ClyScopeExample ofAll: {Array .               String} in: environment).  self assert: query requiredResult identicalTo: tmp1 requiredResultinitialize  super initialize.  self     color: self theme windowColor;     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     height: 0;     minHeight: 0;     layoutInset: 10 @ 2.  self buildContextBar.  self buildCommandBarcurrentScopeIndex: arg1  self currentScope: (self scopes at: arg1)createTab  | tmp1 |  tmp1 := CmdMenu activatedBy: ClyBrowserTabCommandActivation.  tmp1 buildInContext: context.  containerTab := TabMorph label: self defaultTitle icon: self defaultIcon retrievingBlock: [ self buildAndDecorate ] actions: tmp1 buildBrowserTabActions.  containerTab model: self.  ^containerTabattachToSystem  browser system when: (ClyClassChange of: editingClass) send: #triggerUpdate to: selfclassView  ^classViewtestThisClassShouldIncludeExpectedComment  self assert: (self class comment includesSubstring: self expectedClassCommentSubstring caseSensitive: false)classSampleWhichHasGroup  ^ClyAbstractClassExampleadoptForExtendedClass  | tmp1 tmp2 |  self classSelection isEmpty ifTrue: [ ^self ].  methodGroupQuery := methodGroupQuery withoutItemsOfType: RPackage.  (self classSelection lastSelectedItem isMarkedWith: ClyExtendedClassTag) ifFalse: [ ^self ].  methodGroupQuery := ClyAllMethodGroupsQuery sortedFrom: self classScopeForMethods.  tmp1 := self packageSelection actualObjects.  tmp2 := ClyConstantQuery returning: tmp1 as: ClyGroupedExtendingPackages new.  tmp2 := methodGroupQuery scope adoptQuery: tmp2.  methodGroupQuery := methodGroupQuery , tmp2createQueryResult  ^ClyRawQueryResult newactiveScope: arg1  activeScope := arg1decorateContainerTab  selectMainTool  | tmp1 tmp2 |  tmp1 := tools select: [:arg1 |  desiredSelection includes: arg1 class ].  tmp1 ifEmpty: [ tmp1 := tools ].  tmp2 := tmp1 detectMax: [:arg1 |  self activationPriorityOf: arg1 ].  tmp2 selectAsMainTab.  ^tmp2testEmptyInPackageWithoutAnyTags  query scope: (ClyPackageScope of: ClyClass9FromPExtendedByP5 package in: environment).  self assert: query checkEmptyResultisTempVariableSelected  | tmp1 |  tmp1 := self selectedSourceNode.  ^tmp1 isVariable and: [ tmp1 isTemp ]textModel  ^textModeldetectDefiningClassFrom: arg1 ifAbsent: arg2  (arg1 instanceSide classVariables includes: actualVariable) ifTrue: [ definingClass := arg1 instanceSide.        ^self ].  arg1 instanceSide sharedPools do: [:arg3 |  self detectDefiningClassFrom: arg3 ifAbsent: [  ].        definingClass ifNotNil: [ ^self ] ].  arg1 isRootInEnvironment ifTrue: [ ^arg2 value ].  self detectDefiningClassFrom: arg1 superclass ifAbsent: arg2testFillingWithOnePackage  | tmp1 |  queryResult fillWith: {ClyClass1FromP1 package}.  tmp1 := queryResult items first.  self assert: tmp1 class equals: ClyExternalPackageMethodGroup.  self assert: tmp1 package equals: ClyClass1FromP1 package.  self assert: tmp1 methodQuery equals: (ClyPackageExtensionMethodsQuery of: ClyClass1FromP1 package from: query scope)doesMethod: arg1 useAnyOf: arg2  ^arg2 anySatisfy: [:arg3 |  self doesMethod: arg1 useVar: arg3 ]editingClass  ^self methodClasslastSelectedVariable  ^self lastSelectedObject variableimplementorMethod  ^implementorMethodtestRetrievesBrowserEnvironment  self snapshotState.  self assert: navigationState navigationEnvironment equals: environmentsetUpParametersFromModel  super setUpParametersFromModel.  self setUpTargetClassescreateSampleScope  self subclassResponsibilitytestMessageSend_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'val msg: arg') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: ((ThisContext lookupSymbol: #val) msg: (ThisContext lookupSymbol: #arg))]')isExpanded: arg1  self subclassResponsibilitypackagesDo: arg1  subscopes do: [:arg2 |  arg2 packagesDo: arg1 ]matchesByScript: arg1  badScript ifTrue: [ ^true ].  scriptBlock ifNil: [ self createBlockFromPattern ].  badScript ifTrue: [ ^true ].  ^[ (scriptBlock value: arg1) ~~ false ] ifError: [ false ]groupProviderClass  ^ClyWatchpointMethodGroupProviderupdate  self setUpParametersFromModel.  self decorateContainerTab.  self rebuildStatusBar.  self warnUserAboutChangedContextbrowser  ^toolselectedPackageItems  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  selectedItems do: [:arg1 |  tmp2 := arg1 systemDefinition definingPackageItem.        tmp1 detect: [:arg2 |  arg2 actualObject == tmp2 actualObject ] ifNone: [ tmp1 add: tmp2 ] ].  ^tmp1groupProviderClass  ^ClyFFIMethodGroupProvidermeaningfullObjectToAssert: arg1  ^arg1 actualObject methodQuery scope basisObjects anyOnetestFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(supeclassWriterOfVar1 writer1OfVar1 writer2OfVar1)textMorph: arg1  textMorph := arg1.  self attachToTextMorphaddExtraIcon: arg1  | tmp1 |  tmp1 := self iconNamed: arg1.  ^self addExtraTool: tmp1 asMorphblock  ^blockprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  tagName := arg1 requestSingleMethodTag: 'New protocol name'isRoot  ^ownerDataSource isRoot & browserItem isRootmethodsDo: arg1  self classesDo: [:arg2 |  self metaLevelsOf: arg2 do: [:arg3 |  arg3 visibleMethods do: arg1 ] ]queryFromScope: arg1 of: arg2  query scope: (arg1 of: arg2 in: environment).  self executeQuerytestDecoratingMethodWithExecutionCounter  | tmp1 tmp2 tmp3 |  tmp1 := ClyReflectiveEnvironmentPlugin new.  self installCounterInto: #methodWithCounter.  tmp2 := self class >> #methodWithCounter.  tmp3 := tmp2 asCalypsoBrowserItem.  tmp1 decorateBrowserItem: tmp3 ofMethod: tmp2.  self assert: (tmp3 isMarkedWith: ClyMethodWithExecutionCounterTag)isClassSideMethodSelected  self isMethodSelected ifFalse: [ ^false ].  ^self selectedMethodItems anySatisfy: [:arg1 |  arg1 systemDefinition isInstanceSide not ]testFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(writer1OfVar1 writer2OfVar1)asUnifiedInstance  ^selfswitchScopeTo: arg1  self changeStateBy: [ systemQuery := systemQuery withScope: arg1.        self showQueryResult ]environment  scope ifNil: [ self error: 'Scope is not defined. So environment is undefined' ].  ^scope environmentattachToTextMorph  actualResult: arg1  actualResult := arg1fileOut  classQuery scope packagesDo: [:arg1 |  (arg1 classTagNamed: self tag) fileOut ]iconName  ^iconNametestCreationOnTwoDifferentSubscopesOfSameObject  | tmp1 tmp2 |  tmp1 := ClyScopeExample ofAll: #(sameBasisObject basisObject1) in: environment.  tmp2 := ClyScopeExample2 ofAll: #(sameBasisObject basisObject2) in: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self assert: scope basisObjects asSet equals: #(sameBasisObject basisObject1 basisObject2) asSetcollectMetadataOf: arg1 by: arg2  arg2 collectMetadataOfMethods: arg1emptyScopeSample  ^self scopeClass emptyIn: environmentprotectItemsWhile: arg1  ^self protectAccessWhile: [ self rebuildIfNeeded.        arg1 value ]defaultMenuIconName  ^#backasQueryResult  ^ClyHierarchicallySortedClasses with: selfbrowser  ^tool browserquery: arg1  | tmp1 |  self cleanGarbageInCache.  tmp1 := queryCache at: arg1 ifAbsent: [ nil ].  tmp1 ifNil: [ tmp1 := arg1 prepareNewResult.        arg1 fixStateBeforeExecution.        accessGuard critical: [ queryCache at: arg1 put: tmp1 ] ].  tmp1 rebuildIfNeeded.  ^tmp1reset  properties removeAlltestNotExecutedFromMultipleScopeWhenAllSubqueriesAreFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self deny: query isExecutedFromMultipleScopepackage  ^methodQuery packagedefaultMenuIconName  ^#repairIconprocessQueue  [ | tmp1 tmp2 |  tmp1 := OrderedCollection with: updateQueue next.  [ tmp2 := updateQueue nextOrNil ] whileNotNil: [ tmp1 add: tmp2 ].  self runUpdateFor: tmp1 ] repeatdefaultMenuIconName  ^#classIcondecorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color red.  arg1 definitionIcon: #haloViewbrowser  ^browserisResult: arg1 affectedBy: arg2  ^falsetestFillingWithEmptyList  queryResult fillWith: {}.  self assertItems: {}= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^extraParameter = arg1 extraParameterwithoutItemsOfType: arg1  ^self withSubqueries: (subqueries reject: [:arg2 |  arg2 retrievesItemsOfType: arg1 ])showCritiques  criticView owner ifNotNil: [ ^self ].  originalToolPanel layoutFrame bottomFraction: 0.8.  browserTool addMorph: criticView fullFrame: (0 @ 0.8 corner: 1 @ 1) asLayoutFrame.  browserTool addPaneSplitterssetUpSelectedRows: arg1 in: arg2 silently: arg3  arg3 ifTrue: [ arg2 basicSelectIndexes: arg1 ] ifFalse: [ arg2 basicSelectIndexes: #(-1000).        arg2 selectIndexes: arg1 ]restoreBrowserInstance  self snapshotState.  navigationState applyTo: browserdefaultTitle  ^'Comment'testHasBasisCritiquesAsBaseQuery  query := query class new.  self assert: query baseCritiqueQuery class equals: ClyAllBasisCritiqueQuerybaseClass: arg1  baseClass := arg1forceLazyRebuild  self protectAccessWhile: [ needsRebuild := true.        items := nil ]createQuery  ^ClyUnimplementedMethodsQuery from: ClyClassScope of: ClyClassWhichInheritsAbstractSubclass in: environmentinitialize  super initialize.  projectManager := ClyProjectManagerRegistry newhasMetaProperty: arg1  ^metadata hasProperty: arg1createQueryFromScope: arg1  arg1 bindTo: environment.  ^ClyQueryExampleReturningScopeBasis from: arg1activeStatusBar  ^tabManager activeStatusBarisRoot  ^depth = 0execute  | tmp1 |  tmp1 := browser classSelection asItemsScope: ClyClassScope.  browser switchClassViewTo: self requiredQueryResult inScope: tmp1 , (tmp1 asScope: self traitScopeClass)groupProviderClass  ^ClyNoTagClassGroupProvidertestFillingWithItemsTwice  queryResult fillWith: #(1 2 3).  queryResult fillWith: #(4 5 6).  self assert: queryResult items asArray equals: #(1 2 3 4 5 6)systemDefinition  ^self getProperty: ClyItemDefinitionProperty ifAbsent: [ self error: 'No system definition is specified for item' ]updateLabel  | tmp1 |  tmp1 := textMorph lineNumbersRuler ifNil: [ '+L' ] ifNotNil: [ 'L' ].  label contents: tmp1createQuery  ^ClyAbstractMethodsQuery from: ClyClassScope of: ClyAbstractClassExample in: environmenttestSelectsOverriddenMethod  self assert: (query selectsMethod: ClyAbstractClassExample >> #overriddenMethod)statusBar  ^statusBartestFromTwoMethods  self installWatchpointInto: #methodWithWatchpoint.  self queryFromScope: ClyMethodScope ofAll: {(self class >> #methodWithWatchpoint) .         (self class >> #methodWithoutWatchpoint)}.  self assert: foundSelectors sorted asArray equals: #(#methodWithWatchpoint)collectMetadataOf: arg1 by: arg2  self flag: #todoselectedMethods  ^{self selectedMethod}ownerDataSource: arg1  ownerDataSource := arg1createQueryResult  ^ClyExtensionLastSortedClasses simpletabSelected: arg1  | tmp1 tmp2 tmp3 |  updatingStarted ifTrue: [ ^self ].  tmp2 := tools detect: [:arg2 |  arg2 containerTab == arg1 ] ifNone: [ ^self ].  tmp2 takeKeyboardFocus.  tmp1 := tools select: [:arg2 |  arg2 isTabSelected & (arg2 containerTab ~~ arg1) ].  tmp1 ifEmpty: [ ^self ].  desiredSelection removeAll.  tmp3 := browser snapshotState.  tmp3 selectedTabs: tmp1.  browser recordNavigationState: tmp3.  self swapPrioritiesBetween: tmp2 and: tmp1 firsttestMethodsDo: arg1  methodDataSource queryResult rawItemsDo: [:arg2 |  (arg2 isTestMethod and: [ arg2 methodClass isAbstract not ]) ifTrue: [ arg1 value: arg2 ] ]unionWith: arg1 as: arg2  ^ClyQuery unionFrom: (arg1 copyWith: self) as: arg2= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^selectors = arg1 selectorstargetVarName  self subclassResponsibilitycopyForBrowserStateSnapshot  ^self copyForBrowserStateSnapshotOf: ownerDataSource copyForBrowserStateSnapshotupdateDirtyState  | tmp1 |  self hasUnacceptedEdits == isDirty ifTrue: [ ^self ].  tmp1 := containerTab label morph contents.  isDirty := self hasUnacceptedEdits.  isDirty ifTrue: [ containerTab label: '*' , tmp1 ] ifFalse: [ (tmp1 beginsWith: '*') ifTrue: [ containerTab label: tmp1 allButFirst ] ]rawItemsDo: arg1  ^items collect: [:arg2 |  arg2 actualObject ] thenDo: arg1extraParameter  ^extraParameterdefaultMenuIconName  ^#smallWindowcreateQueryResult  ^ClyHierarchicallySortedClasses newtestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithFFIMethods >> #ffiMethod in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithFFIMethods >> #notFFIMethod in: environment).  self assert: query checkEmptyResultclose  lastFilteredDataSource ifNotNil: [ lastFilteredDataSource close ].  itemCursor := itemCursor closeclassSampleWhichHasGroup  ^ClyClassWithFlagstestClassEnumerationOverMetaclassBasisWhenInstanceSideIsLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyInstanceSideScope.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {Object .         ProtoObject} asSetshowSourceNode  tool selectSourceNode: selectedSourceNodetestComparisonOfSimilarQueriesWithDifferentScopes  | tmp1 |  tmp1 := self createQuery.  query scope: (ClyScopeExample of: #basisObject1 in: environment).  tmp1 scope: (ClyScopeExample of: #basisObject2 in: environment).  self deny: query equals: tmp1.  tmp1 scope: (ClyScopeExample2 of: #basisObject1 in: environment).  self deny: query equals: tmp1findItemsWith: arg1  ^self findAllItemsBy: [:arg2 |  arg2 findItemsWith: arg1 ] stopLookupWhen: [:arg3 |  arg3 size = arg1 size ]requestSinglePackage: arg1  ^tool searchDialog requestSingleObject: arg1 from: ClyAllPackagesQuery sortedrestoreBrowserState  context restoreBrowserStatemethodGroup: arg1  methodGroup := arg1isClassSelected: arg1  ^self classSelection items anySatisfy: [:arg2 |  arg2 actualObject == arg1 or: [ arg2 systemDefinition definingClass == arg1 ] ]toggleExtendingPackage  super toggleExtendingPackage.  self hasUnacceptedEdits ifFalse: [ self packageEditingMethod: editingMethod ]adoptLocalScopeClassTo: arg1  self subclassResponsibilityisSlow  ^truemetaLevelScope  self subclassResponsibilitymethodGroupQuery: arg1  methodGroupQuery := arg1expandChildren  self childrenDataSource: (ownerDataSource retrieveChildrenOf: self)expandedItems  ^expandedItemspackageEditingMethod: arg1  self applyChangesBy: [ (extendingPackage notNil and: [ arg1 package ~~ extendingPackage ]) ifTrue: [ ^(SycMoveMethodsToPackageCommand for: {arg1} to: extendingPackage) execute ].        (extendingPackage isNil and: [ arg1 isExtension ]) ifTrue: [ (SycMoveMethodsToPackageDefiningClassCommand for: {arg1}) execute ] ]groupItemsByType  | tmp1 |  tmp1 := IdentityDictionary new.  items do: [:arg1 |  | tmp2 |        tmp2 := tmp1 at: arg1 type ifAbsentPut: [ OrderedCollection new ].        tmp2 add: arg1 actualObject ].  ^tmp1system  ^navigationEnvironment systemitems  self subclassResponsibilitysetUpParametersFromModel  methodQuery  ^methodQuerytestIsBasedOnSingleBasisWhenSingleSubscopeIs  | tmp1 |  tmp1 := ClyScopeExample of: #basisObject in: environment.  scope := ClyCompositeScope on: {tmp1}.  self assert: scope isBasedOnSingleBasistestCheckIfEmpty  query scope: (ClyMethodScope of: ClyTestedClassTest >> #testExpectedFailure in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyTestedClassTest >> #testOne in: environment).  self assert: query checkEmptyResultcheckEmptyResult  scope variablesDo: [:arg1 |  ^false ].  ^truebuild  radioButton := self theme newRadioButtonIn: World for: self getSelected: #isModeActive setSelected: #toggleMode: getEnabled: nil label: self title help: nil.  self addMorph: radioButtontestFindTestCaseCoveringUntestedClass  | tmp1 |  tmp1 := plugin findTestCaseCovering: ClyUntestedClass ifAbsent: [ #noResult ].  self assert: tmp1 equals: #noResultcancelRebuild  items ifNil: [ self initializeItems ].  needsRebuild := falsedecorateBrowserItem: arg1 ofClassGroup: arg2  update: arg1  super update: arg1.  self updateMainWindowTitlesystem  ^systemcreateQueryResult  ^ClyAsyncQueryResult newtestMethodsEnumerationWhenBasisIsClass  scope := ClyBothMetaLevelClassScope of: ClyClass1FromP1.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyClass1FromP1 localMethods).  self assert: (result includesAll: ClyClass1FromP1 classSide localMethods)itemCache  ^itemCacheselectedClasses  ^self actualSelectionFrom: self selectedClassItemstestComparisonToSimilarResultButWithWithDifferentBaseResult  | tmp1 |  queryResult := ClyExtensionLastSortedClasses simple.  tmp1 := ClyExtensionLastSortedClasses hierarchical.  self deny: queryResult equals: tmp1testComparisonWithSimilarResult  | tmp1 |  queryResult := self createQueryResult.  tmp1 := self createQueryResult.  self assert: queryResult equals: tmp1.  self assert: queryResult hash equals: tmp1 hashremoveProperty: arg1  properties remove: arg1 ifAbsent: [  ]createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'flags' priority: 8.3 on: arg1testConvertingToNewMetaLevelShouldKeepScopeName  | tmp1 |  scope := ClyCompositeScope on: {(ClyClassScope of: Object in: environment) .         (ClySubclassScope of: Array in: environment)}.  scope name: 'test scope'.  tmp1 := scope withMetaLevel: ClyInstanceSideScope.  self assert: tmp1 name equals: 'test scope'classGroupsDo: arg1  self classGroupProvidersDo: [:arg2 |  arg2 classGroupsIn: self do: [:arg3 |  arg1 value: arg3 ] ]defaultColor  ^Color transparentisAppliedToBrowser  ^browser isQueryScopeActive: queryScopetestFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}isExecutedFromEmptyScope  ^scope isBasedOnEmptyBasishasSelectedItems  ^selectedItems notEmptydefaultMenuItemName  ^'Invert hierarchy'retrievesItem: arg1  ^self selectsMethod: arg1stringPattern  ^stringPatternclassesDo: arg1  basisObjects do: [:arg2 |  self metaLevelsOf: arg2 do: arg1 ]setUp  super setUp.  installedCounter := ClyMethodCallCountersQueryTest new     setUp;     installCounterInto: #methodWithCounterallItems  ^self itemsStartingAt: 1 count: self sizetestFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(classSideReference1OfClass reference1OfClass reference2OfClass)shouldBeProtectedByWriteBarrier  ^ShouldBeProtectedByWriteBarrier ifNil: [ ShouldBeProtectedByWriteBarrier := Smalltalk vm supportsWriteBarrier ]changesWasInitiatedByUser  ^changesWasInitiatedByUsercriteriaString: arg1  criteriaString := arg1 asStringimportClass: arg1  testConvertingWithNewBasisObjects  | tmp1 |  scope := self singleScopeSample.  tmp1 := scope withNewBasisObjects: {self extraBasisSample}.  self assert: tmp1 class equals: scope class.  self assert: tmp1 basisObjects asSet equals: {self extraBasisSample} asSet.  self assert: tmp1 basisSize equals: 1.  self assert: tmp1 environment notNil.  self assert: tmp1 environment equals: environmenttestItems: arg1  testItems := arg1mouseEnter: arg1  super mouseEnter: arg1.  self currentHand showTemporaryCursor: Cursor webLinkmodifiesExtension  self subclassResponsibilitysubgroupsQuery  ^subgroupsQueryisResult: arg1 affectedBy: arg2  ^subqueries anySatisfy: [:arg3 |  arg3 isResult: arg1 affectedBy: arg2 ]targetVarName  ^#writtenVar1testHasCompositeScopeFromSubqueries  < expectedFailure>  super testHasCompositeScopeFromSubqueriestestExecution  self executeQuery.  self assert: resultItems size equals: 1createToolbarItemFor: arg1  ^ClyBrowserModeSwitchMorph activatingBy: arg1scopeClass  ^ClyPackageScopename  ^'Switch scope to'addIcon: arg1  self addMorphFront: arg1 asMorphincludesMethodsAffectedBy: arg1  ^basisObjects anySatisfy: [:arg2 |  arg2 includesMethodsAffectedBy: arg1 ]buildResult: arg1  executionSemaphore wait.  super buildResult: arg1testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass2FromP1 >> #instanceSideClassVar1Reader in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self assert: query checkEmptyResulttestSelectsMethodWithBreakpoint  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  self assert: (query selectsMethod: ClyClassWithBreakpoints >> #methodWithBreakpoints)publishCollectedChanges  rightMethod  ^rightMethodtestUsingBadScriptWhichNotReturnBoolean  filter := ClyQueryBrowserFilter substringPattern: '[:each | each selector]'.  self assert: (filter matches: self itemOfThisTestMethod).  self assert: (filter matches: (ClyBrowserItem with: Object >> #printString))testIsEmptyFromEmptyClassScope  < expectedFailure>  super testIsEmptyFromEmptyClassScopeisBuilt  containerTab ifNil: [ ^false ].  ^containerTab morph == selfbuildCriticalTextSegmentsFor: arg1  | tmp1 tmp2 tmp3 |  ^criticView dataSource allElements select: [:arg2 |  arg2 hasProperty: ClySourceNodeCritiqueIntervalProperty ] thenCollect: [:arg2 |  tmp1 := arg2 getProperty: ClySourceNodeCritiqueIntervalProperty.        tmp2 := ClyCriticalTextSegmentMorph from: tmp1 start to: tmp1 stop + 1.        tmp3 := arg2 getProperty: ClyCritiqueSeverityProperty.        tmp2           label: arg2 name;           icon: (browserTool iconNamed: tmp3 iconName);           color: tmp3 color;           critique: arg2 actualObject;           entity: arg1;           yourself ]testFillingWithTwoClasses  queryResult fillWith: {Array .         String}.  self assert: queryResult items equals: {Array binding .         String binding}hash  ^super hash bitXor: subqueries hashtestForceLazyRebuildShouldNotResetExistingItems  self assert: queryResult items notNil.  queryResult forceLazyRebuild.  self assert: queryResult needsRebuild.  self assert: queryResult isBuilt.  self assert: queryResult items notNildoInOrder: arg1  self rootsDo: [:arg2 |  arg1 value: arg2.        self allChildrenOf: arg2 do: arg1 ]collectMetadataOfMethods: arg1  spawnBrowser: arg1 withState: arg2  | tmp1 |  tmp1 := arg1 on: navigationEnvironment systemScope: self systemScope.  tmp1 disablePluginsWhichAreNotIn: self.  tmp1 prepareInitialStateBy: arg2.  self openAnotherBrowser: tmp1.  tmp1 wasSpawnedFrom: self.  ^tmp1activeScope: arg1  activeScope := arg1testConvertingToAsyncQuery  | tmp1 |  tmp1 := query async.  self assert: tmp1 identicalTo: queryfindAnyVariableInSourceCode: arg1  | tmp1 |  tmp1 := editingMethod variableNodes detect: [:arg2 |  arg1 includes: arg2 name ] ifNone: [ ^0 to: -1 ].  ^tmp1 start to: tmp1 stoprestoreStateOf: arg1  super restoreStateOf: arg1.  arg1     metaLevelScope: metaLevelScope;     methodGroupQuery: methodGroupQuerydefaultName  ^self class defaultNamecoveringTestCase  ^coveringTestCaseprepareExecutionInDragContext: arg1  super prepareExecutionInDragContext: arg1.  methodGroups := arg1 selectedMethodGroupsexecute  ClyQueryBrowser browseBreakpointsremoveWithClasses  super removeWithClasses.  classQuery scope packagesDo: [:arg1 |  arg1 removeClassTag: self tag ]systemScope: arg1  systemScope := arg1printBasisOn: arg1  basisObjects ifEmpty: [ ^self ].  basisObjects do: [:arg2 |  self printBasisObject: arg2 on: arg1.        arg1 nextPutAll: ', ' ].  arg1 skip: -2sortFunction  ^sortFunctionexecuteQuery  super executeQuery.  foundSelectors := (resultItems collect: #selector) sorted asArraycreateUpdateWithItemsStartingAt: arg1 count: arg2  | tmp1 |  tmp1 := ClyBrowserQueryCache filledBy: self startingAt: arg1 size: arg2.  ^ClyBrowserQueryUpdate of: self withItems: tmp1testEmptySubscopesAreForbidden  [ ClyCompositeScope on: #().  self assert: false description: 'empty subscopes should be forbidden' ] ifError: [  ]compileANewClassFrom: arg1 notifying: arg2 startingFrom: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := arg3.  tmp4 := arg1 findTokens: Character separators.  ((tmp4 first = 'Trait' and: [ tmp4 second = 'named:' ]) or: [ tmp4 second = 'classTrait' ]) ifTrue: [ ^self defineTrait: arg1 notifying: arg2 startingFrom: arg3 ].  tmp5 := tmp4 findFirst: [:arg4 |  arg4 beginsWith: 'category' ].  tmp5 := tmp4 findFirst: [:arg4 |  '*subclass*' match: arg4 ].  tmp3 := (tmp4 at: tmp5 + 1) copyWithoutAll: '#()'.  ((tmp1 isNil or: [ tmp1 instanceSide name asString ~= tmp3 ]) and: [ self includesClassNamed: tmp3 asSymbol ]) ifTrue: [ (self confirm: ((tmp3 , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: tmp3 size)) ifFalse: [ ^nil ] ].  tmp1 ifNil: [ tmp6 := self defaultClassCompiler ] ifNotNil: [ tmp6 := tmp1 superclass subclassDefinerClass new ].  tmp2 := tmp6     source: arg1;     requestor: arg2;     logged: true;     evaluate.  ^tmp2 isBehavior ifTrue: [ tmp2 ] ifFalse: [ nil ]isAccessibleFrom: arg1  self subclassResponsibilitywrapRawItems: arg1 startingAt: arg2  | tmp1 |  tmp1 := arg1 collect: [:arg3 |  arg3 asCalypsoBrowserItem ].  tmp1 doWithIndex: [:arg3 :arg4 |  arg3 position: arg2 + arg4 - 1.        arg3 prepareIn: self environment ].  ^tmp1refreshCritiques  browserTool decorateByCritic: self.  criticView dataSource isEmpty ifTrue: [ self hideCritiques ] ifFalse: [ self showCritiques ].  (criticView dataSource hasMetaProperty: ClyBackgroundProcessingTag) ifFalse: [ progressMorph delete.        browserTool statusBar update ] ifTrue: [ browserTool statusBar addContextItem: progressMorph ]testFromSingleClass  | tmp1 |  self queryFromScope: ClyClassScope of: ClyClass2FromP1.  tmp1 := resultItems collect: #name as: Set.  self assert: tmp1 equals: ClyClass2FromP1 instVarNames asSetfillWith: arg1  | tmp1 |  tmp1 := self groupVariablesByTypeAndDefinition: arg1.  self fillWithGroupedVariables: tmp1requestConditionBlock  | tmp1 |  tmp1 := 'true'.  tmp1 := UIManager default request: 'This expression will be evaluated in the context of the position of this breakpoint.		You can use variables, globals, `thisContext`, `self` and `super`.		`:=` and Pool variables are not supported`' initialAnswer: tmp1 title: 'Break on what condition?'.  tmp1 isEmptyOrNil ifTrue: [ CmdCommandAborted signal ].  ^self generateConditionBlockFrom: tmp1isEmpty  ^items isEmptyclasses  ^self environment ask allClassesrequestSingleObject: arg1 from: arg2  self openOn: arg2 withTitle: arg1 thenDo: [ itemsView selection isEmpty ifTrue: [ ^self findObjectsSameAsFilter ifEmpty: [ CmdCommandAborted signal ] ifNotEmpty: [:arg3 |  arg3 first ] ].        ^itemsView selection lastSelectedItem actualObject ]testNotExecutedFromMultipleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  query subqueries: {(self subqueryFromScope: ClyScopeExample of: self class) .         (self subqueryFromScope: ClyScopeExample2 of: self class)}.  self deny: query isExecutedFromMultipleScopecreateQuery  ^ClyAllExtensionMethodsQuery from: ClyClassScope of: Object in: environmentshowInheritedMethods: arg1  | tmp1 |  self isMethodsVisible == arg1 ifTrue: [ ^self ].  tmp1 := visibilityLevel toggleScope.  tmp1 isBasedOnEmptyBasis ifFalse: [ browser restrictMethodVisibilityBy: tmp1 ]itemsStartingAt: arg1 count: arg2  ^self protectItemsWhile: [ items copyFrom: arg1 to: (arg1 + arg2 - 1 min: items size) ]createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'overridden' priority: -10 on: arg1isAppliedToBrowser  ^browser isInProjectViewpattern: arg1  | tmp1 |  tmp1 := stringPattern copy.  tmp1 value: arg1.  ^itemFilterClass pattern: tmp1emptyBarWithWidth: arg1  | tmp1 |  tmp1 := Morph new.  tmp1     setNamePropertyTo: 'emptyBar';     color: Color transparent;     changeTableLayout;     vResizing: #spaceFill;     hResizing: #rigid;     minWidth: 0;     width: arg1.  ^tmp1testNotSelectsMethodWithoutExpectedFailurePragma  self deny: (query selectsMethod: ClyTestedClassTest >> #testOne)createFixedRegexMatcherIfFailed: arg1  | tmp1 |  tmp1 := value copyReplaceAll: '*' with: '.*'.  ^[ tmp1 asRegexIgnoringCase ] on: RegexSyntaxError do: [:arg2 |  arg1 value ]newName  ^newNameimplementorMethod: arg1  implementorMethod := arg1testMakeQueryScopeOfResultAsReadOnlyObjectWhenItIsExecuted  | tmp1 |  tmp1 := self createQueryFromScopeOf: self class.  environment query: tmp1.  self assert: tmp1 scope isReadOnlyObjecttestMatchesMethodOfClassWhichMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'FilterTest'.  self assert: (filter matches: self itemOfThisTestMethod)ownerTool: arg1  super ownerTool: arg1subclassN2VarWriterMethod  subclassN2Var := #subclassN2VarValuedecorateTool: arg1  isQueryEmpty: arg1  | tmp1 |  tmp1 := queryCache at: arg1 ifAbsent: [ nil ].  tmp1 ifNotNil: [ tmp1 isBuilt ifTrue: [ ^tmp1 isEmpty ] ].  ^arg1 checkEmptyResultloadItemsOf: arg1 startingWhere: arg2  | tmp1 |  tmp1 := arg1 itemsStartingWhere: arg2 count: sizeLimit.  tmp1 ifEmpty: [ ^false ].  startPosition := tmp1 first position.  items := tmp1.  ^trueselectMethodsIn: arg1  browserTool: arg1  browserTool := arg1package: arg1  package := arg1asRBEnvironment  ^RBPackageEnvironment packages: basisObjectsisAutoActivated  ^self class isAutoActivatedcreateQueryResult  self subclassResponsibilitybuildResetButton  resetButton := IconicButton new     target: self;     actionSelector: #resetTagsAndPackage;     arguments: #();     labelGraphic: (self iconNamed: #glamorousClose);     color: Color transparent;     borderWidth: 0;     hResizing: #shinkWrap;     layoutInset: 4 @ 0hash  ^super hash bitXor: extraParameter hashtestIsBasedOnEmptyBasisWhenAllSubscopesHaveEmptyBasis  | tmp1 tmp2 |  tmp1 := ClyScopeExample emptyIn: environment.  tmp2 := ClyScopeExample emptyIn: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self assert: scope isBasedOnEmptyBasisloadCritiquesAsync  ^critiqueQuery async executecheckEmptyResult  scope classesDo: [:arg1 |  (self isClassHasToBeImplemented: arg1) ifTrue: [ ^false ] ].  ^trueinitialize  super initialize.  startPosition := 0.  items := Array emptyisMethodSelected: arg1  ^self methodSelection includesActualObject: arg1resultItems  ^resultItemstestFromPackageWithExtensionsButWithoutTags  self queryFromScope: ClyPackageScope of: ClyClass1FromP1 package.  self assert: resultItems isEmptymethodsDo: arg1  self classesDo: [:arg2 |  arg2 methods do: arg1 ]scopedMethods  | tmp1 tmp2 |  tmp1 := self installedMethods.  tmp2 := IdentitySet new.  scope methodsDo: [:arg1 |  (tmp1 includes: arg1) ifTrue: [ tmp2 add: arg1.              tmp1 remove: arg1.              tmp1 ifEmpty: [ ^tmp2 ] ] ].  ^tmp2selectedSourceNode: arg1  selectedSourceNode := arg1subscribe: arg1  metaLevelScope: arg1  metaLevelScope := arg1basisObjects  ^basisObjectshasChildAt: arg1  ^arg1 > self position and: [ arg1 <= (self position + self childrenCount) ]isCommandAvailable: arg1  ^arg1 canBeExecutedInClassEditor: selfdecorateBrowserItem: arg1 ofClass: arg2  (arg2 classSide includesLocalSelector: #isAbstract) ifTrue: [ arg2 instanceSide isAbstract ifTrue: [ arg1 markWith: ClyAbstractItemTag ].        ^self ].  (self checkClassIsAbstract: arg2) ifTrue: [ arg1 markWith: ClyAbstractItemTag ]testDecoratingMethodWithBreakpoint  | tmp1 tmp2 tmp3 |  tmp1 := ClyReflectiveEnvironmentPlugin new.  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  tmp2 := ClyClassWithBreakpoints >> #methodWithBreakpoints.  tmp3 := tmp2 asCalypsoBrowserItem.  tmp1 decorateBrowserItem: tmp3 ofMethod: tmp2.  self assert: (tmp3 isMarkedWith: ClyMethodWithBreakpointTag).  self deny: (tmp3 isMarkedWith: ClyMethodWithHaltTag)collapse: arg1  self subclassResponsibility= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^methods = arg1 methodsscopeClass  ^ClyClassScopesupeclassReferenceOfVar1  ^referencedVar1rawResultItems  ^queryResult itemsselectedMethodGroupItems  ^tool methodGroupSelection itemsasUnifiedInstance  ^self withNewBasisObjects: #()cancel  self browserTool cancelChangesrestrictedByScope: arg1  | tmp1 |  tmp1 := subqueries collect: [:arg2 |  arg2 restrictedByScope: arg1 ].  ^self withSubqueries: tmp1parentItem  ^ownerDataSource isRoot ifTrue: [ nil ] ifFalse: [ ownerDataSource parentItem ]collectMethodGroupProviders  ^#()testFindTestedClassCoveredByTestCaseWhenItAbsent  | tmp1 |  tmp1 := plugin findTestedClassCoveredBy: ClyAbstractlyNamedTest ifAbsent: [ #noResult ].  self assert: tmp1 equals: #noResultexecutesQuery: arg1  ^subqueries anySatisfy: [:arg2 |  arg2 executesQuery: arg1 ]selectsClass: arg1  ^arg1 hasComment and: [ pattern matches: arg1 comment ]description  ^'critiques of scope basis'testFixingStateBeforeExecutionShouldFixSubqueriesState  query fixStateBeforeExecution.  query subqueries do: [:arg1 |  self assert: arg1 isReadOnlyObject.        self assert: arg1 scope isReadOnlyObject ]resultView  ^resultViewcreateQuery  ^ClyFilterQuery for: (ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: self class in: environment) filter: (ClyItemNameFilter substringPattern: 'FilterQueryTest')queryClass  ^ClyVariableReadersQueryprojectQueryFor: arg1  ^ClyUnknownQuery instancedefaultMenuItemName  ^'Invert hierarchy'selectVariableNamed: arg1  | tmp1 tmp2 |  tmp1 := self parseClassDefinition.  tmp2 := tmp1 children detect: [:arg2 |  arg2 isVariable and: [ arg2 name = arg1 ] ] ifNone: [ ^self ].  self selectSourceNode: tmp2tabOrder  ^self class tabOrderitems  ^itemshandlesAnnouncement: arg1  ^arg1 affectsPackage: affectedPackagetestMethodsEnumeration  | tmp1 |  scope := ClySuperclassScope of: ClyClass1FromP1.  scope methodsDo: [:arg1 |  result add: arg1 ].  tmp1 := {Object .   ProtoObject} flatCollect: #localMethods as: IdentitySet.  self assert: result asIdentitySet equals: tmp1execute  CriticBrowser openOnRule: ReRuleManager uniqueInstance allRules onEnvironment: (RBPackageEnvironment packages: packages)selectPackage: arg1 atClassTag: arg2  | tmp1 tmp2 tmp3 |  self changeStateBy: [ tmp3 := packageView findItemsWith: {arg1}.        tmp3 ifEmpty: [ self switchToPackages.              tmp3 := packageView findItemsWith: {arg1} ].        tmp1 := tmp3 first.        tmp1 expand.        tmp2 := tmp1 childrenItems detect: [:arg3 |  arg3 name = arg2 ].        packageView selection selectItems: {tmp2} ]defaultMenuItemName  ^self methodGroupType shortNameasUnifiedInstance  ^selfdefaultMenuItemName  ^'Browse critiques'prepareNewResult  ^requiredResult prepareNewFor: self in: self environmentabstractMethod1  ^#resultbrowser: arg1  browser := arg1testCaseInsensitiveByDefault  | tmp1 |  tmp1 := ClySubstringPattern with: 'subString'.  self deny: tmp1 isCaseSensitivetoolbar  ^toolbarprovidesMethodGroup  ^providesMethodGroupname  ^nameselectedClassItems  ^self selectedItemsOfType: ClyClasspackageCommentBlank  ^'Please comment package here'createQueryResult  ^ClyBrowserQueryResultExample newmethod1  ^#method1testRepresentsClassOfScope  scope := self createSampleScope.  self assert: (scope representsScope: ClyScopeExample).  self assert: (scope representsScope: ClyTypedScope).  self deny: (scope representsScope: String)removePackage: arg1  packageOrganizer unregisterPackage: arg1buildWindow  | tmp1 |  tmp1 := (SystemWindow labelled: self newWindowTitle) model: self.  tmp1     addMorph: self frame: (0 @ 0 extent: 1 @ 1);     updatePaneColors.  ^tmp1wasSpawnedFrom: arg1  self recordNavigationState: (ClyAccrossWindowNavigationState from: arg1)size  ^actualResult sizetestDetectingDefiningClassFromSubclass  | tmp1 tmp2 |  tmp1 := ClyClass2FromP1 classVariableNamed: #ClassVar1.  tmp2 := ClyClassVariable on: tmp1 visibleFrom: ClySubclassLOfClass2FromP1.  self assert: tmp2 definingClass equals: ClyClass2FromP1globals  ^globalstestExecutionOverExistingQuery  | tmp1 tmp2 |  tmp1 := ClyScopeExample ofAll: {self class superclass .         self class} in: environment.  tmp2 := ClyQueryExampleReturningScopeBasis from: tmp1.  query := tmp2 filteredBy: query itemFilter.  result := query execute.  resultItems := result items.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self classselectedClass  ^self selectedSourceNode binding valuerunTestCase: arg1  | tmp1 |  tmp1 := arg1 classForTestResult new.  self runTestCase: arg1 results: tmp1.  tmp1 updateResultsInHistory.  self notifyUserAboutResults: tmp1 with: arg1 nameretrievesItemsOfType: arg1  ^falseselection  self isFilterChanged ifTrue: [ self initiateUIChangeBy: [ self updateSelection ] ].  selection updateIfDirty.  ^selectionisExtensionMethodSelected  self isMethodSelected ifFalse: [ ^false ].  ^self selectedMethodItems anySatisfy: [:arg1 |  arg1 systemDefinition isExtension ]decorateContainerTab  | tmp1 |  super decorateContainerTab.  tmp1 := editingMethod selector.  editingMethod origin isClassSide ifTrue: [ tmp1 := tmp1 asText allBold asStringMorph ].  containerTab label: tmp1selectMethodsIn: arg1  arg1 selectObject: methods lastdefaultMenuItemName  ^'Browse dependencies'testFromSingleClass  self queryFromScope: ClyClassScope of: ClyClass1FromP1.  self assert: foundSelectors equals: #(#instanceSideVar1ReaderMethod #instanceSideVar1WriterMethod #superclassTag1Method #tag1Method1)groupProviderClass  ^ClyDeprecatedMethodGroupProvidertestVariablesEnumerationForClassWithInstanceVariables  scope := ClyClassScope of: ClyClass1FromP1.  scope variablesDo: [:arg1 |  result add: arg1 ].  self assert: (result as: Set) equals: {(ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)} asSettextArea  ^textMorph textAreaoverridenPriorityOf: arg1  ^selectionPriorities at: arg1 class ifAbsent: [ arg1 activationPriority ]restoreBrowserState  browser selectClass: methodClassdescription  ^'abstract methods'decorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color redtestCheckIfEmpty  query scope: (ClyMethodScope of: ClyAbstractClassExample >> #abstractMethod1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: Object >> #printString in: environment).  self assert: query checkEmptyResultisSimilarTo: arg1  type = arg1 type ifFalse: [ ^false ].  ^name = arg1 name or: [ self isEqualTo: arg1 ]testFillingWithObjectAndTwoProtoObjects  queryResult fillWith: {Object .         ProtoObject .         ProtoObject}.  self assertItems: {ProtoObject .         0 .         Object .         1}wantsTextStyling  ^falsetag: arg1  tag := arg1selectsMethod: arg1  ^arg1 hasPragmaNamed: #expectedFailuredataSource: arg1  self changeStateBy: [ self closeDataSource.        self setUpDataSource: arg1.        self refreshTable ]tagName  ^tagNamecreateQuery  | tmp1 |  tmp1 := ClyInstanceSideScope ofAll: {Object .         Array .         String} in: environment.  ^ClyAllClassesQuery from: tmp1defaultMenuItemName  ^'Add watchpoint'extendingPackage: arg1  super extendingPackage: arg1.  self hasUnacceptedEdits ifFalse: [ self packageEditingMethod: editingMethod ]createQuery  ^ClyAllClassesQuery from: ClyClassScope of: Object in: environmentdecorateBrowserItem: arg1 ofMethod: arg2  | tmp1 tmp2 |  arg2 isTestMethod ifTrue: [ ^self ].  tmp1 := self findTestMethodCovering: arg2 ifAbsent: [ ^self ].  tmp2 := ClyTestResultProperty ofMethod: tmp1.  arg1 addProperty: (ClyTestedMethodProperty coveringTest: tmp1 result: tmp2)providesGroupsAffectedBy: arg1 inScope: arg2  arg2 classesDo: [:arg3 |  (arg1 affectsClass: arg3) ifTrue: [ ^true ] ].  ^falseprojects  ^projectManagers flatCollect: [:arg1 |  arg1 projects ]description  ^'expected failures'belongsToRemovedBrowserContext  ^falsecreateQuery  ^ClyAllClassGroupsQuery from: ClyPackageScope of: Object package in: environmentisAfter: arg1  ^arg1 <= self positiontestVariablesEnumerationWhenThereAreNoVariables  scope := ClyClassScope of: ProtoObject.  scope variablesDo: [:arg1 |  result add: arg1 ].  self assert: result isEmptyrequestTag  | tmp1 tmp2 |  tmp2 := ownerTool methodTags ifEmpty: [ '' ] ifNotEmpty: [:arg1 |  arg1 anyOne ].  tmp1 := self ownerTool context requestSingleMethodTag: 'New protocol name' suggesting: tmp2.  tmp1 = tmp2 ifTrue: [ ^CmdCommandAborted signal ].  ownerTool methodTags: {tmp1 asSymbol}execute  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self class environment at: #IceTipRepositoriesBrowser ifAbsent: [ ^self inform: 'Iceberg 0.7 and higher is required' ].  tmp2 := self class environment at: #IceTipCommitBrowser ifAbsent: [ ^self inform: 'Iceberg 0.7 and higher is required' ].  packages ifEmpty: [ ^tmp1 new openWithSpec ].  tmp3 := IceRepository registry select: [:arg1 |  packages anySatisfy: [:arg2 |  arg1 includesPackageNamed: arg2 name ] ].  tmp3 ifEmpty: [ ^self inform: 'Selected packages are not managed by Iceberg' ].  tmp4 := tmp3 size = 1 ifTrue: [ tmp3 first ] ifFalse: [ UIManager default chooseFrom: (tmp3 collect: #name) values: tmp3 title: 'Choose repository' ].  tmp4 ifNil: [ ^self ].  (tmp4 isMissing or: [ tmp4 isCodeMissing or: [ tmp4 isDetached or: [ tmp4 hasUnbornProject ] ] ]) ifTrue: [ UIManager default alert: 'The ' , tmp4 name , ' repository is not operational to commit.Causes can be:- The local repository is missing- The code directory is missing- The project is in detached head state- Metadatas are missing.You can fix this problem using the Iceberg tool.' title: 'Error'.        ^self ].  (tmp2 onRepository: tmp4) openWithSpecwithMetaLevelScope: arg1  ^self withScope: (scope withMetaLevel: arg1)createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'counters' priority: 8.4 on: arg1withoutItemsOfType: arg1  self subclassResponsibilitysingleBasisSample  ^ClyClass1FromP1 packagetestFillingWithItems  queryResult fillWith: #(1 2 3).  self assert: queryResult items asArray equals: #(1 2 3)executeOn: arg1  ^arg1 instanceSide perform: implementorMethod selectorpackages  ^packageOrganizer packagesbuildIndexes  items withIndexDo: [:arg1 :arg2 |  arg1 position: arg2 ]testComparisonOfSameQueries  | tmp1 |  self assert: query equals: query.  tmp1 := self createQuery.  self assert: query equals: tmp1.  self assert: query hash equals: tmp1 hashwantsDropElements: arg1 type: arg2 index: arg3  | tmp1 tmp2 |  arg3 = 0 | (arg3 > self numberOfRows) ifTrue: [ ^false ].  self dragTransferType == arg2 ifFalse: [ ^false ].  tmp1 := self elementAt: arg3.  tmp2 := queryView wantsDropPassenger: arg1 at: tmp1.  tmp2 & tmp1 hasChildren ifTrue: [ tmp1 expand ].  ^tmp2methodWithHalt2  self halttestFillingWithSingleClassVar  | tmp1 |  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyMethodGroup .         0}.  tmp1 := items last actualObject.  self assert: tmp1 methodQuery class equals: ClyVariableReferencesQuery.  self assert: tmp1 methodQuery variableQuery class equals: ClyAllClassVariablesQuery.  self assert: tmp1 subgroupsQuery class equals: ClyAllClassVariablesQuery.  self assert: tmp1 subgroupsQuery requiredResult class equals: ClyGroupedClassVariables.  self assert: tmp1 subgroupsQuery requiredResult hierarchy equals: queryResult hierarchyasTraitVisibility  self subclassResponsibilitynavigationHistory  ^navigationHistorycreateClassQueryFrom: arg1  self subclassResponsibilityaffectedMethod: arg1  affectedMethod := arg1buildResult: arg1  | tmp1 |  scope packagesDo: [:arg2 |  arg2 tagsForClasses ifNotEmpty: [ tmp1 := scope query: ClyUntaggedClassesQuery new.              ^arg1 fillWith: tmp1 rawItems ] ]rebuildStatusBar  self isBuilt ifFalse: [ ^self ].  statusBar clear.  self fillStatusBarprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  methodGroup := arg1 lastSelectedMethodGroup.  newName := arg1 requestSingleMethodTag: 'New name of protocol' suggesting: methodGroup name.  newName = methodGroup name ifTrue: [ CmdCommandAborted signal ]asLocalClassScope  | tmp1 |  tmp1 := subscopes collect: [:arg1 |  arg1 asLocalClassScope ].  ^ClyCompositeScope on: tmp1 in: environmentisAbstractMethod: arg1  ^arg1 sendsSelector: #subclassResponsibilityaddBarForFullIndentation  | tmp1 tmp2 tmp3 |  tmp1 := 0.  tmp2 := tmp1 - submorphs size.  tmp3 := tmp2 * 16 + (self itemDepth * 8).  tmp3 = 0 ifTrue: [ ^self ].  self addMorphBack: (self emptyBarWithWidth: tmp3)checkEmptyResult  scope classesDo: [:arg1 |  (self selectsClass: arg1) ifTrue: [ ^false ] ].  ^trueselectsCritique: arg1  ^arg1 rule group = groupNameadoptQuery: arg1  self subclassResponsibility= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^classQuery = arg1 classQuerytestRetrievesQueryScopes  self snapshotState.  self assert: navigationState queryScopes equals: browser queryScopessuccessCount  ^successCountextendingPackage  ^extendingPackagedefaultMenuItemName  ^self metaLevelScope defaultName capitalizedbindTo: arg1  super bindTo: arg1.  subscopes do: [:arg2 |  arg2 bindTo: arg1 ]definingClass  ^definingClasstestClassesEnumeration  scope := ClyPackageExtensionScope of: ClyClass1FromP1 package.  scope classesDo: [:arg1 |  result add: arg1 ].  self deny: (result includesAll: ClyClass1FromP1 package definedClasses).  self assert: (result includesAll: ClyClass1FromP1 package extendedClasses)getProperty: arg1  ^properties detect: [:arg2 |  arg2 isKindOf: arg1 ]description  ^''definingClass: arg1  definingClassItem := ClyBrowserItem named: arg1 name with: arg1prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browsercollectCommandCandidatesInContext: arg1  | tmp1 tmp2 |  tmp1 := CmdContextMenuActivation createActivatorsExecutableInContext: arg1.  tmp2 := tmp1 collect: [:arg2 |  arg2 command class ] as: IdentitySet.  CmdMenuCommandActivationStrategy allSubclassesDo: [:arg3 |  arg3 activateAllInContext: arg1 by: [:arg4 |  (tmp2 includes: arg4 command class) ifFalse: [ tmp1 add: arg4.                    tmp2 add: arg4 command class ] ] ].  ^tmp1plugins  ^pluginscreateMethodQueryFrom: arg1  ^ClyAbstractMethodsQuery from: arg1isMethodGroupSelected  ^self selectedMethodGroupItems notEmptycollectMethodGroupProviders  ^{ClyFailedTestGroupProvider new .   ClyExpectedFailureMethodGroupProvider new}textChanged: arg1  changesCancelRequested ifTrue: [ changesCancelRequested := false.        ^self changesCancelled ].  self updateDirtyStatedefaultMenuItemName  ^'Rename'scopeClass  self subclassResponsibilityfindItemsWhere: arg1  | tmp1 |  tmp1 := self itemCursor findItemsWhere: arg1.  ^tmp1 collect: [:arg2 |  self createElementWith: arg2 ]initialize  super initialize.  direction := 1fillWithGroupedVariables: arg1  arg1 at: ClyClassVariable ifPresent: [:arg2 |  self fillWithVariables: arg2 type: ClyClassVariable ]currentScope: arg1  browser switchScopeTo: arg1.  dropList setBalloonText: arg1 descriptionbuildingQuery  ^actualResult buildingQuerycopyForBrowserStateSnapshotOf: arg1  | tmp1 |  tmp1 := self asDesiredSelection.  tmp1 rootDataSource: arg1.  tmp1 items: (items collect: [:arg2 |  arg2 copyForBrowserStateSnapshotOf: arg1 ]).  ^tmp1roots  ^rootsdialogClass: arg1  dialogClass := arg1itemOfThisTestClass  ^ClyBrowserItem with: self classclose  openedBrowser ifNotNil: #closeaddProperty: arg1  properties add: arg1addNewItem: arg1  self addMorphBack: arg1selectMethod: arg1  self selectObject: arg1initialize  super initialize.  self     color: self theme windowColor;     changeTableLayout;     height: self defaultHeight;     layoutInset: 2 @ 0;     listDirection: #leftToRight;     wrapCentering: #center;     hResizing: #spaceFill;     vResizing: #rigidposition  ^positiondecorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 definitionIcon: #smallDebugloadAsyncQueryResult  ^methodQuery loadCritiquesAsynctestRetrievesPlugins  browser addPlugin: ClyStandardBrowserPlugin new.  self snapshotState.  self assert: navigationState browserPlugins first class equals: ClyStandardBrowserPluginparentGlobalPosition  ^parentItem ifNil: [ 0 ] ifNotNil: [ parentItem globalPosition ]queryResult  ^self itemCursor queryResultclasses  ^classQuery execute itemstestConvertingToScopeIncludedInheritedScope  | tmp1 tmp2 |  scope := self createSampleScope.  tmp2 := scope asInheritedScope.  tmp1 := scope withInheritedScope.  self assert: tmp1 class equals: ClyCompositeScope.  self assert: tmp1 name equals: ClyClassScope hierarchyScopeName.  self assert: (tmp1 subscopes includes: scope).  self assert: (tmp1 subscopes includes: tmp2)queryView  ^queryViewrepresentsScope: arg1  ^(super representsScope: arg1) or: [ relationScopeClasses anySatisfy: [:arg2 |  arg2 includesBehavior: arg1 ] ]selectedClassOrMetaClass  ^niltestFindItemsUsingPredicateWhenTheyAreNotInCache  | tmp1 |  cursor cleanCache.  tmp1 := cursor findItemsWhere: [:arg1 |  arg1 actualObject = Object ].  self assert: tmp1 size equals: 1.  self assert: tmp1 first actualObject equals: Object.  self assert: tmp1 first isPrepared.  self assert: tmp1 first position equals: 2checkEmptyResult  scope methodGroupsDo: [:arg1 |  ^false ].  ^trueprojectManagers: arg1  projectManagers := arg1testRan: arg1  | tmp1 |  tmp1 := ClyTestCaseRan testCase: arg1 testResult.  environment systemChanged: tmp1testConvertingToInterestingClassScope  | tmp1 |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  tmp1 := scope asInterestingClassScope.  self assert: tmp1 class equals: ClyInterestingSuperclassScope.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 localScopeClass equals: scope localScopeClass.  self assert: tmp1 environment equals: scope environmenttestFillingWithTraitsOfClassWhichIsMissingInGivenList  queryResult fillWith: {ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyTraitChild1 .         0 .         ClyTraitRoot1 .         1 .         ClyTraitChild2Child .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot1 .         2}defaultBorderWidth  ^0createMethodQueryFrom: arg1  ^ClyFlaggingMethodsQuery from: arg1updateLabel  | tmp1 |  tmp1 := textMorph wrapped ifTrue: [ 'W' ] ifFalse: [ 'NW' ].  wrapModeLabel contents: tmp1query: arg1  query := arg1defaultMenuIconName  ^#smallCancelIcontestFillingWithClassesFromOneHierarchy  queryResult fillWith: {ClySubclassN1OfClass1FromP1 .         ClySubclassLOfSubclassMFromP3 .         ClyClass1FromP1 .         ClySubclassN2OfClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1 .         ClySubclassN1OfClass1FromP1 .         1 .         ClySubclassN2OfClass1FromP1 .         1}editingPackage  ^editingPackagetabMorph  ^tabMorphsystemScope  ^system asGlobalScopeIn: selfdefaultToolbarItemName  ^queryScope descriptionclassesDo: arg1  basisObjects do: [:arg2 |  arg1 value: arg2 instanceSide ]restoreBrowserWindow  | tmp1 |  window isInWorld ifFalse: [ tmp1 := self createBrowser.        window addMorph: tmp1 frame: (0 @ 0 extent: 1 @ 1).        window model: tmp1.        browserState applyTo: tmp1 ].  windowGroup ifNil: [ window isInWorld ifTrue: [ window                 comeToFront;                 activate ] ifFalse: [ window openAsIs ] ] ifNotNil: [ windowGroup isInWorld ifTrue: [ windowGroup window comeToFront ] ifFalse: [ windowGroup window openAsIs ].        windowGroup activateWindow: window ]defaultMenuItemName  ^'Flat'isSameAsCurrent  ^isSameAsCurrenttestClassEnumeration  scope := ClyTraitUserScope of: ClyTraitRoot1.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {ClyTraitChild1 .         ClyTraitChild2 .         ClyClassWithTraits .         ClyTraitChild2Child .         ClyTraitChild3 .         ClySubclassWithTraitsOfClassWithTraits} asSettestHasQueryResult  self assert: cursor queryResult equals: queryResultnavigateForward  navigationHistory redoNavigationOf: selfisStatic  ^trueattachToSystem  TestCase historyAnnouncer weak when: TestSuiteEnded send: #testRan: to: selfitemsWhere: arg1  | tmp1 |  tmp1 := super itemsWhere: arg1.  tmp1 do: [:arg2 |  arg2 prepareIn: environment ].  ^tmp1editorClass  ^ClyTextEditorrestoreBrowserState  self browser selectMethod: self lastSelectedMethodisInverse  ^inversetestRestoredBrowserInstanceWithMetaLevelScope  browser metaLevelScope: #testScope.  self restoreBrowserInstance.  self assert: browser metaLevelScope equals: #testScopetestNotSelectsNotAbstractMethod  self deny: (query selectsMethod: Object >> #printString)testFindingTestCoveringMethod  {((ClyTestedClass >> #one) -> (ClyTestedClassTest >> #testOne)) .   ((ClyTestedClass >> #one:) -> (ClyTestedClassTest >> #testOne)) .   ((ClyTestedClass >> #two) -> (ClyTestedClassTest >> #testTwo)) .   ((ClyTestedClass >> #two:) -> (ClyTestedClassTest >> #testTwo)) .   ((ClyTestedClass >> #one:two:) -> (ClyTestedClassTest >> #testOneTwo)) .   ((ClyTestedClass >> #oneTwo:) -> (ClyTestedClassTest >> #testOneTwo)) .   ((ClyTestedClass >> #untestedOne) -> nil) .   ((ClyTestedClass >> #untestedOne:) -> nil) .   ((ClyTestedClass >> #untestedTwo) -> nil) .   ((ClyTestedClass >> #untestedTwo:) -> nil) .   ((ClyTestedClass >> #untestedOne:two:) -> nil) .   ((ClyTestedClass >> #untestedOneTwo:) -> nil) .   ((ClyTestedClass class >> #one:two:) -> (ClyTestedClassTest >> #testOneTwo)) .   ((ClyTestedClass class >> #untestedOne:two:) -> nil) .   ((ClyTestedClassTest >> #testOne) -> nil) .   ((ClyTestedClassTest >> #testTwo) -> nil) .   ((ClyTestedClassTest >> #testOneTwo) -> nil)} do: [:arg1 |  self assert: (plugin findTestMethodCovering: arg1 key ifAbsent: nil) identicalTo: arg1 value ]testRestoredBrowserInstanceWithMethodGroupQuery  browser methodGroupQuery: #testQuery.  self restoreBrowserInstance.  self assert: browser methodGroupQuery equals: #testQuerydecorateBrowserItem: arg1 ofClass: arg2  arg1 ensureSystemDefinition: [ ClyClassDefinitionProperty of: arg2 ].  arg2 localSelectors ifNotEmpty: [ arg1 markWithChildrenOf: ClyMethod ].  arg2 hasComment ifFalse: [ arg1 markWith: ClyNoCommentTag ]triggerUpdate  self updatetestHasReadonlyRequiredResultByDefault  self assert: query requiredResult isReadOnlyObjectcollate: arg1 with: arg2  ^arg1 definingClass name threeWayCompareTo: arg2 definingClass nametargetItemType: arg1  targetItemType := arg1showResultOf: arg1  self changeStateBy: [ systemQuery := arg1 buildsDefaultResult ifTrue: [ arg1 withResult: self requiredQueryResult ] ifFalse: [ arg1 ].        self showQueryResult ]representsObject: arg1  actualObject == arg1 ifTrue: [ ^true ].  type = arg1 calypsoEnvironmentType ifFalse: [ ^false ].  ^type checkCalypsoItem: actualObject isSameAs: arg1criticAnalysisScope  ^ClyPackageScope of: package in: browser navigationEnvironmentdefaultIcon  self defaultIconName ifNil: [ ^nil ].  ^self iconNamed: self defaultIconNametestComparisonWithCopy  | tmp1 |  scope := self createSampleScope.  tmp1 := scope copy.  self assert: scope equals: tmp1.  self assert: scope hash equals: tmp1 hashitemsChanged  self forceRebuildqueryScope  ^queryScopebrowserItem: arg1  browserItem := arg1withoutItemsOfType: arg1  ^(self retrievesItemsOfType: arg1) ifTrue: [ ClyUnknownQuery instance ] ifFalse: [ self ]metadata  ^metadatabuildMethodGroupWithCritique: arg1 on: arg2  | tmp1 tmp2 |  tmp1 := arg1 rule group.  tmp2 := arg2 at: tmp1 ifAbsentPut: [ ClyConcreteCritiqueMethodGroup basedOn: arg1 withMethodsFrom: self scope ].  tmp2 addCritique: arg1execute  | tmp1 tmp2 |  tmp1 := methods collect: [:arg1 |  arg1 selector ].  tmp2 := ClyMessageImplementorsQuery ofAny: tmp1 from: self createQueryScope.  browser spawnQueryBrowserOn: tmp2 withState: [:arg2 |  self selectMethodsIn: arg2 ]firstSelectedObjectIn: arg1  ^arg1 lastopenEditor  self requestChangeBy: [ self isExtensionActive ifTrue: [ self requestPackage ] ifFalse: [ self requestTag ] ]targetSelector  ^#clyMessageImplementor1asSelectedRoots  | tmp1 tmp2 tmp3 |  self isEmpty ifTrue: [ ^self ].  tmp1 := items collect: [:arg1 |  arg1 rootParentItem ] as: Set.  tmp1 = items ifTrue: [ ^self ].  tmp2 := self lastSelectedItem rootParentItem.  tmp1 remove: tmp2.  tmp3 := OrderedCollection with: tmp2.  tmp3 addAll: tmp1.  ^self class fromRoot: self rootDataSource items: tmp3overriddenSuperclass  ^overriddenSuperclasstestAdoptQueryShouldKeepScopeName  | tmp1 tmp2 |  scope := ClyCompositeScope on: {(ClyScopeExample of: Object in: environment) .         (ClyScopeExample2 of: Array in: environment)}.  scope name: 'test scope'.  tmp1 := ClyQueryExampleReturningScopeBasis new.  tmp2 := scope adoptQuery: tmp1.  self assert: tmp2 scope name equals: 'test scope'isAppliedToBrowser  ^browser metaLevelScope = self metaLevelScopetestCaseSensitiveMathingString  | tmp1 |  tmp1 := ClySubstringPattern with: 'subString' caseSensitive: true.  self assert: (tmp1 matches: 'start subString end').  self deny: (tmp1 matches: 'start substring end')createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'deprecated' priority: -9 on: arg1editingMode  | tmp1 |  tmp1 := ClyTextEditingMode browserTool: self.  tmp1     classOrMetaClass: self selectedClassOrMetaClass;     isForScripting: self isForScripting.  ^tmp1createQueryResult  ^ClyGroupedExtendingPackages newpackages  ^environment ask packagesname: arg1  name := arg1collate: arg1 with: arg2  self subclassResponsibilitycreateMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'undeclared' priority: 8.4 on: arg1testFromTwoClasses  self queryFromScope: ClyClassScope ofAll: {ClyClass9FromPExtendedByP5 .         ClySubclassLOfClass0FromPExtendedByP1}.  self assert: resultItems asSet equals: {ClyClass1FromP1 package .         ClyClass7WithTag1FromP5 package} asSetinitialize  super initialize.  label := StringMorph newnavigateSpawnedFullBrowser: arg1  | tmp1 tmp2 |  arg1 setUpScopedModeWith: self activeScope.  tmp1 := self selection lastSelectedItem.  tmp2 := tmp1 systemDefinition.  arg1 selectPackage: tmp2 definingPackage.  arg1 selectClass: tmp2 definingClass.  (tmp2 isKindOf: ClyMethodDefinitionProperty) ifTrue: [ arg1 selectMethod: tmp1 actualObject ]toolClass  ^annotatedClassdecorateTableCell: arg1 inContext: arg2  annotatedClass decorateTableCell: arg1 inContext: arg2fillWith: arg1  items addAll: arg1createCellFor: arg1 in: arg2  | tmp1 |  tmp1 := ClyItemCellMorph new.  displayBlock value: tmp1 value: arg1.  arg2 decorateTableCell: tmp1 of: arg1.  tmp1 build.  ^tmp1classUnderTest  ^ClyTestedClasshasChildrenOf: arg1  ^self hasChildrenWhich: [:arg2 |  arg2 = arg1 ]selectsMethod: arg1  ^scope inheritanceAnalyzer isMethodOverridden: arg1critique: arg1  critique := arg1testSuperSendWithArgs_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'super foo: arg1 bar: arg2') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext receiver perform: #foo:bar: withArguments: {ThisContext lookupSymbol: #arg1. ThisContext lookupSymbol: #arg2.} inSuperclass: ThisContext receiver class superclass)]')hash  ^items hash= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^dialogClass = arg1 dialogClass and: [ browserClass = arg1 browserClass ]execute  selectedItems size = 1 ifTrue: [ selectedItems first inspect ] ifFalse: [ selectedItems inspect ]newSelectionWith: arg1  ^ClyDataSourceSelection fromRoot: self items: arg1testIsExecutedFromSingleScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self deny: query isExecutedFromSingleScope.  query scope: (ClyScopeExample of: #singleObject in: environment).  self assert: query isExecutedFromSingleScope.  query scope: (ClyScopeExample emptyIn: environment).  self deny: query isExecutedFromSingleScopeabstractSubclassMethod  self subclassResponsibilitymethod2  collectAllClasses  | tmp1 |  tmp1 := IdentitySet new.  subscopes do: [:arg1 |  arg1 classesDo: [:arg2 |  tmp1 add: arg2 ] ].  ^tmp1createQuery  ^ClyExtendingPackagesQuery from: ClyClassScope of: Object in: environmentextraClassScope  ^extraClassScopehasChildren  ^ownerDataSource doesItemHaveChildren: selfrepresentsBrowserItems  ^trueasAsyncQueryGroup  ^selftestConvertingToInheritingScope  | tmp1 |  scope := ClyCompositeScope on: {(ClyInstanceSideScope of: Object in: environment) .         (ClyClassSideScope of: Array in: environment)}.  tmp1 := scope asInheritingScope.  self assert: tmp1 class equals: ClyCompositeScope.  self assert: (tmp1 subscopes first representsScope: ClySubclassScope).  self assert: (tmp1 subscopes last representsScope: ClySubclassScope).  self assert: (tmp1 subscopes collect: #localScopeClass as: Set) equals: {ClyInstanceSideScope .         ClyClassSideScope} asSet.  self assert: tmp1 environment equals: environment.  self assert: tmp1 name equals: ClyClassScope inheritingScopeNameattachToTextMorph  super attachToTextMorph.  label := StringMorph new.  label setBalloonText: 'Let you decide if the code pane should show the line numbers at the left of the code pane or not. +L: Click to add the lines number/L: Click to hide them.'.  label on: #mouseDown send: #toggle to: self.  self updateLabel.  self addMorph: labeldelayExecution  executionSemaphore consumeAllSignalsisEqualTo: arg1  type = arg1 type ifFalse: [ ^false ].  ^type checkCalypsoItem: actualObject isEqualTo: arg1 actualObjectprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  package := arg1 requestSinglePackage: 'Choose package'methodsDo: arg1  self classesDo: [:arg2 |  arg2 localMethods do: arg1.        arg2 classSide localMethods do: arg1 ].  self packagesDo: [:arg3 |  arg3 extensionMethods do: arg1 ], arg1  ^ClyMergedHierarchy merge: {self .         arg1}hash  ^dialogClass hash bitXor: browserClass hashbrokenCount  ^failureCount + errorCountscope: arg1  super scope: arg1.  baseCritiqueQuery scope: arg1description  ^'methods tagged with ' , tagbuild  checkbox := self theme newCheckboxIn: self for: self getSelected: #isActive setSelected: #toggle getEnabled: nil getLabel: #label help: 'toggle check box to choose/reset package of method'.  checkbox     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap.  self addMorph: checkboxtestIsExecutedFromMultipleScopeWhenSingleSubqueryIsBasedOnIt  query subqueries: {(self subqueryFromScope: (ClyScopeExample ofAll: {self class .                     self class superclass}))}.  self assert: query isExecutedFromMultipleScopemethodWithBreakpoints  self printStringtestResult  self subclassResponsibilitysenderOfMessage2  self message2withSubqueries: arg1  ^self class with: arg1 as: requiredResultclassVariablesDo: arg1  self classesDo: [:arg2 |  self classVariablesOf: arg2 do: arg1 ]decorateContainerTab  | tmp1 |  super decorateContainerTab.  browser metaLevelScope == ClyClassSideScope ifFalse: [ ^self ].  tmp1 := self defaultTitle asText allBold asStringMorph.  containerTab label: tmp1, arg1  ^ClyCompositeScope on: {self .         arg1}build  | tmp1 |  tmp1 := CheckboxMorph on: self selected: #isMethodsVisible changeSelected: #showInheritedMethods:.  tmp1     borderWidth: 0;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap.  tmp1 labelMorph delete.  self addMorph: tmp1createQuery  ^super createQuery semiAsyncexecute  ClySubclassHierarchy invertVariableHierarchy.  browser switchToVariablesallNavigationScopes  | tmp1 |  tmp1 := self extraScopesOfSelectedItems reject: #isBasedOnEmptyBasis.  ^queryScopes , (tmp1 copyWithoutAll: queryScopes)prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browserpackageName  package ifNil: [ ^'' ].  classTag ifNil: [ ^package name ].  ^package name , '-' , classTagtestFromTwoSamePackages  self buildGroupsForAll: {ClyClass7WithTag1FromP5 package .         ClyClass7WithTag1FromP5 package}.  self assert: builtGroups size equals: 2.  self assert: (builtGroups collect: #tag) sorted asArray equals: #(Tag1 Tag2)testMethodsEnumeration  scope := ClyTraitUserScope of: ClyTraitRoot1.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyTraitChild1 localMethods).  self assert: (result includesAll: ClyClassWithTraits localMethods).  self deny: (result includesAll: ClyClassWithTraits classSide localMethods).  self deny: (result includesAll: ClyTraitRoot1 localMethods).  self deny: (result includesAll: ClyTraitRoot1 classSide localMethods)detachFromSystem  TestCase historyAnnouncer unsubscribe: selfqueryScope  ^buildingQuery scopecreateMethodQueryFrom: arg1  ^ClyActiveBreakpointsQuery from: arg1doesMethod: arg1 useVar: arg2  (super doesMethod: arg1 useVar: arg2) ifTrue: [ ^true ].  ^arg1 hasSelector: arg2 name asSymboltestFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> self targetSelector) .         (self class >> #messageImplementor2)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> self targetSelectordefaultMenuItemName  ^'Hier.'expectedFlatQueryResult: arg1  expectedFlatQueryResult := arg1selectsMethod: arg1  | tmp1 |  tmp1 := self loadCritiquesAsync.  ^tmp1 items anySatisfy: [:arg2 |  arg2 sourceAnchor entity == arg1 ]testAdoptQuery  | tmp1 tmp2 |  scope := ClyCompositeScope on: {(ClyScopeExample of: Object in: environment) .         (ClyScopeExample2 of: Array in: environment)}.  tmp1 := ClyQueryExampleReturningScopeBasis new.  tmp1 extraParameter: #testParameter.  tmp2 := scope adoptQuery: tmp1.  self assert: tmp2 class equals: ClyUnionQuery.  self assert: tmp2 subqueries size equals: 2.  tmp2 subqueries do: [:arg1 |  self assert: arg1 class equals: tmp1 class.        self assert: arg1 extraParameter equals: #testParameter ].  self assert: (tmp2 subqueries collect: #scope) equals: scope subscopes asSetselectors  ^selectorsbuildGroupsFrom: arg1  self subclassResponsibilityquery  ^querysystemEnvironment  ^systemEnvironmenttestCreationFromTwoQueriesOfSameTypeAndScopeButWithDifferentParameter  | tmp1 tmp2 |  tmp1 := self subqueryFromScopeOf: Array.  tmp1 extraParameter: #testParameter.  tmp2 := self subqueryFromScopeOf: Array.  tmp2 extraParameter: #testParameter2.  query := tmp1 , tmp2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {tmp1 .         tmp2} asSet.  self assert: query requiredResult identicalTo: tmp1 requiredResulttestExpandedDataSourceWithoutTable  | tmp1 |  self selectedItem expand.  self snapshotState.  tmp1 := navigationState dataSource expandedItems first.  self assert: tmp1 childrenDataSource table isNilclassGroupProvidersDo: arg1  | tmp1 |  environment pluginsDo: [:arg2 |  tmp1 := arg2 collectClassGroupProviders.        tmp1 do: arg1 ]testItems  ^testItemsasyncResult  ^asyncResultselectsMethod: arg1  | tmp1 |  tmp1 := variableQuery execute.  ^self doesMethod: arg1 useAnyOf: tmp1 itemssingleScopeSample  ^self scopeClass of: self singleBasisSample in: environmentwithMetaLevelScope: arg1  ^self withScope: (scope withMetaLevel: arg1)initialize  super initialize.  description := 'Methods'selectedClassScript  | tmp1 |  tmp1 := self lastSelectedObjectIn: self selectedMethodItems.  ^(tmp1 getProperty: ClyClassScriptProperty) scriptgenerateConditionBlockFrom: arg1  | tmp1 |  tmp1 := self conditionBlockProducerMethodAST: arg1.  ^tmp1 generateWithSource valueWithReceiver: nil arguments: {}hierarchy  ^hierarchyhash  ^super hash bitXor: mergedParts hashspecifyMethodItemNameOn: arg1 for: arg2  | tmp1 |  arg1 contents: arg2 name.  tmp1 := arg2 systemDefinition.  (self isPackagePartOfSelection: tmp1 definingPackage) ifFalse: [ arg1 color: self theme classExtensionColor ].  self classSelection isMultipleSelected ifTrue: [ ^arg1 contents: (tmp1 printFullNameOf: arg2) ].  (self isClassSelected: tmp1 definingClass) ifTrue: [ ^self ].  arg1 emphasis: TextEmphasis italic emphasisCode.  arg1 contents: (tmp1 printFullNameOf: arg2)update  navigationViews do: [:arg1 |  arg1 update ]buildResult: arg1  | tmp1 tmp2 |  tmp2 := subqueries flatCollect: [:arg2 |  tmp1 := arg2 execute.        tmp1 items ].  arg1 fillWith: tmp2 asIdentitySetcreateInheritanceScopeFrom: arg1  ^ClySubclassScope ofAll: arg1 in: browser navigationEnvironmentasInheritingScope  ^ClyInheritedScopeProvider createInheritingScopeFrom: selfmethodClass  ^methodClassbrowser  ^browserprepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  conditionBlock := self requestConditionBlockexecute  | tmp1 |  tmp1 := Breakpoint new node: sourceNode.  self applyBreakpointCondition: tmp1.  tmp1 installselectAnySelector: arg1  textMorph setSelection: (self findAnySelectorInSourceCode: arg1)testSelectedTabsWithoutOwner  | tmp1 |  self snapshotState.  tmp1 := navigationState selectedTabs first.  self assert: tmp1 owner isNilmethodGroupSelectionChanged  | tmp1 |  methodGroupView changesWasInitiatedByUser ifTrue: [ tabManager skipCurrentDesiredSelection ].  self methodGroupSelection isEmpty ifTrue: [ ^self showAllMethods ].  tmp1 := self methodGroupSelection actualObjects collect: [:arg1 |  arg1 methodQuery ].  methodView showQueries: tmp1 as: (ClySortedQueryResult using: ClySortMethodBySelectorFunction ascending)asItemsScope: arg1  | tmp1 |  tmp1 := self uniformActualObjects.  ^arg1 ofAll: tmp1 in: rootDataSource queryEnvironmentenvironment  ^actualResult environmenttestCheckIfEmpty  query scope: (ClyClassScope of: self class in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: self class superclass in: environment).  self assert: query checkEmptyResultprintOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  pattern printOn: arg1.  arg1 nextPut: $)expand: arg1  queryView changeStateBy: [ arg1 expandChildren.        expandedItems add: arg1.        self expansionChanged ]restoreCurrentSelection: arg1  | tmp1 tmp2 tmp3 |  tmp1 := isSameAsCurrent.  self checkItemsOfCurrentSelection: arg1.  tmp2 := isSameAsCurrent ifTrue: [ arg1 items ] ifFalse: [ arg1 rootDataSource findItemsSimilarTo: items ].  tmp3 := (tmp1 & isSameAsCurrent) not.  arg1 restoreDesiredSelectionWith: tmp2 silently: tmp3 not.  ^tmp3updateToolsForChangedEnvironment  | tmp1 |  tmp1 := OrderedCollection new: tools size.  tools do: [:arg1 |  tmp1 add: arg1 -> arg1 isManagedByUser.        arg1 isManagedByUser: true ].  self updateTools.  tmp1 do: [:arg1 |  arg1 key isManagedByUser: arg1 value ]findItemsWhere: arg1  ^self findAllItemsBy: [:arg2 |  arg2 findItemsWhere: arg1 ]restrictedBy: arg1  ^self withNewBasisObjects: arg1 basisObjectsdetachFromTextMorph  super detachFromTextMorph.  self textArea announcer unsubscribe: selfsetUpModelFromContext  testFromSinglePackage  self queryFromScope: ClyPackageScope of: ClyClass1FromP1 package.  self assert: resultItems asSet equals: ClyClass1FromP1 package definedClasses.  self deny: (resultItems includes: ClySubclassLOfClass0FromPExtendedByP1)changeStateBy: arg1  arg1 valuebrowseVariableReferencesOf: arg1  tool spawnQueryBrowserOn: (ClyVariableReferencesQuery ofAny: arg1)testConvertingWithNewScopeShouldKeepFilter  | tmp1 tmp2 |  tmp1 := ClyScopeExample2 of: #someBasis in: environment.  tmp2 := query withScope: tmp1.  self assert: tmp2 itemFilter equals: query itemFiltercreateQueryResult  ^ClyGroupedInstanceVariables withHierarchy: ClySubclassHierarchy newtestFromClassScope  self queryFromScope: ClyClassScope of: self class.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self class >> #methodWithExpectedStringInSourcesclose  execute  ^scope query: selfsubtreeSize  ^subtreeSizeone: arg1  one := arg1defaultMenuItemName  ^'Traits'affectsMethodsDefinedInClass: arg1  ^arg1 instanceSide includesBehavior: overriddenSuperclassretrievesItem: arg1  ^arg1 isKindOf: ClyClassVariablequeryScopes: arg1  queryScopes := arg1isClosed  ^itemCursor == ClyClosedBrowserCursor instanceisMethodsVisible  ^visibilityLevel isActiveallowsDeselection: arg1  table allowsDeselection: arg1asAsyncQueryGroup  ^ClyAsyncMethodGroup named: name priority: priority on: methodQuery withSubgroupsFrom: subgroupsQuerydescription  ^'readers of ' , self printVariablestestClassEnumerationOverClassShouldStopAtObject  scope := ClyInterestingSuperclassScope of: Class.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {ClassDescription .         Behavior} asSetnotFFIMethod  groupName: arg1  groupName := arg1fillWithGroupedVariables: arg1  self subclassResponsibilityvalue: arg1 value: arg2  | tmp1 |  tmp1 := (self collate: arg1 with: arg2) * direction.  ^tmp1 <= 0navigationHistory  ^navigationHistoryfindCachedElementWith: arg1 ifAbsent: arg2  ^expandedItems detect: [:arg3 |  arg3 actualObject == arg1 actualObject ] ifNone: arg2testCompareTwoClasses  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object value: Array).  self assert: (function value: Array value: Object).  self assert: (function value: Object value: Object)description  ^descriptionnavigationEnvironment  ^navigationEnvironmentdecorateBrowserItem: arg1 ofMethod: arg2  arg1 ensureSystemDefinition: [ ClyMethodDefinitionProperty of: arg2 ]findAnyString: arg1 in: arg2  | tmp1 |  arg1 do: [:arg3 |  tmp1 := arg2 findString: arg3 startingAt: 1.        tmp1 > 0 ifTrue: [ ^tmp1 to: tmp1 + arg3 size ] ].  ^0 to: -1printExtraInfoOn: arg1  super printExtraInfoOn: arg1.  ^arg1 nextPutAll: tagallChildrenOf: arg1 depth: arg2 do: arg3  | tmp1 tmp2 |  tmp1 := parentMap at: arg1 ifAbsent: [ ^self ].  tmp2 := arg2 + 1.  tmp1 do: [:arg4 |  arg3 value: arg4 value: tmp2.        self allChildrenOf: arg4 depth: tmp2 do: arg3 ]createBrowserContextOf: arg1 for: arg2  ^annotatedClass ofSelection: arg1 for: arg2testForSharedClassVariable  | tmp1 |  tmp1 := ClyClassVariable named: #DayNames definedIn: ChronologyConstants.  query := ClyVariableReferencesQuery of: tmp1.  self queryFromScope: ClyBothMetaLevelClassScope of: Date.  self assert: resultItems notEmptyresultItems: arg1  resultItems := arg1initialize  super initialize.  self     changeTableLayout;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     listDirection: #leftToRight;     cellInset: 2.  progress := 1.  progressIconMorph := self currentIcon asMorph.  self addMorphBack: progressIconMorph.  self extent: progressIconMorph extenttestFillingWithTwoInstVarsOfSameClass  | tmp1 |  tmp1 := {(ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .   (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)}.  queryResult fillWith: tmp1.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar1 #instanceSideVar2)testRestoredBrowserInstanceWithMethodQuery  | tmp1 |  tmp1 := ClyAllMethodsQuery sorted.  browser systemQuery: tmp1.  self restoreBrowserInstance.  self assert: browser systemQuery equals: tmp1isExpanded: arg1  ^expandedItems includes: arg1testNotBoundToEnvironmentByDefault  query := query class new.  self deny: query isBoundToEnvironmentitemsChanged  wasNotified := truebuildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope projectsDo: [:arg2 |  tmp1 addAll: arg2 items ].  arg1 fillWith: tmp1itemAt: arg1  ^items at: arg1applyChanges  | tmp1 tmp2 tmp3 |  tmp3 := self chooseClassForNewMethodIfNone: [ ^false ].  tmp2 := methodTags ifEmpty: [ tmp3 compile: self pendingText asString notifying: textMorph ] ifNotEmpty: [ tmp3 compile: self pendingText asString classified: methodTags anyOne notifying: textMorph ].  tmp2 ifNil: [ ^false ].  tmp1 := tmp3 >> tmp2.  methodTags ifEmpty: [ MethodClassifier classify: tmp1.        methodTags := tmp1 tags ].  self tagAndPackageEditingMethod: tmp1.  self removeFromBrowser.  browser tabManager desiredSelection: {ClyMethodCodeEditorToolMorph}.  browser selectMethod: tmp1.  ^truecreateClassGroupFor: arg1 from: arg2  self subclassResponsibilitytestNotSelectsNotOverriddenMethod  self deny: (query selectsMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)withTool: arg1 do: arg2  ^tabManager withTool: arg1 do: arg2decorateBrowserItem: arg1 ofMethod: arg2  (self isTestMethod: arg2) ifFalse: [ ^self ].  arg1 addProperty: (ClyTestResultProperty ofMethod: arg2)rawItemsDo: arg1  ^self rawItems do: arg1testMethodsEnumerationWhenBasisIsTraitedClass  | tmp1 |  scope := ClyInstanceSideScope of: ClyClassWithTraits.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClassWithTraits methods collect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArraygroupProviderClass  ^ClyMethodCounterGroupProvidercopy  | tmp1 |  tmp1 := super copy.  tmp1 browserItem: browserItem copy.  ^tmp1iconNameForSpotterMenu  ^#packageIcontagAndPackageEditingMethod: arg1  self tagEditingMethod: arg1.  self packageEditingMethod: arg1testIsNotBasedOnMultipleBasis  scope := self createSampleScope.  self deny: scope isBasedOnMultipleBasisselectedMethodItems  self subclassResponsibilitypackageSampleWhichHasGroup  ^ClyClass1FromP1 packagedoesMethod: arg1 useVar: arg2  ^arg2 isReferencedIn: arg1selectedClassItems  ^selectedItemswithScopeOf: arg1  ^self withScope: (scope withNewBasisObjects: arg1)systemDefinition  ^browserItem systemDefinitionanalyzedObjectsDo: arg1  scope basisObjects do: arg1testFillingWithClassAndSuperclassVariables  queryResult fillWith: {(ClyInstanceVariable named: #subclassN1Var definedIn: ClySubclassN1OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN1OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar1 #instanceSideVar2 #subclassN1Var #subclassSameVar)actualVariable  ^actualVariabledefaultMenuIconName  ^#smallFindIconconfirmUnusedVariables: arg1  ^self browser confirmUnusedVariables: arg1testBuildShouldStartBackgroundProcessing  queryResult rebuild.  self assert: (queryResult hasMetaProperty: ClyBackgroundProcessingTag).  self deny: queryResult buildProcess isTerminatedrestoreSelectedItems  self initiateUIChangeBy: [ selection restoreTableSelection ].  highlighting restoreTableSelectionwithScopeOf: arg1  self subclassResponsibilityprintOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  definingClass printOn: arg1.  arg1 nextPut: $)selectLastItem  self changeStateBy: [ resultView selectLastItem ]iconNameForSpotterMenu  ^#classIconmethodClass  self belongsToCurrentBrowserContext ifFalse: [ ^editingMethod origin ].  ^browser chooseClassForEditorOfMethod: editingMethodrecordAcrossWindowNavigationFrom: arg1 byUndo: arg2  | tmp1 |  tmp1 := ClyAccrossWindowNavigationState from: arg1.  arg2 ifTrue: [ self executeUndoBy: [ self recordState: tmp1 ] ] ifFalse: [ self executeRedoBy: [ self recordState: tmp1 ] ]asInterestingClassScope  ^selftestOneTwo  | tmp1 |  tmp1 := self newTestedObject one: #one two: #two.  self     assert: tmp1 one equals: #one;     assert: tmp1 two equals: #two;     assert: (tmp1 one: #three two: #four) identicalTo: tmp1;     assert: tmp1 one equals: #three;     assert: tmp1 two equals: #four;     assert: (tmp1 oneTwo: #five) identicalTo: tmp1;     assert: tmp1 one equals: #three;     assert: tmp1 two equals: #fiveallowSilentlyRemoveMethods: arg1 whichHaveSenders: arg2  | tmp1 tmp2 |  tmp2 := arg2 size.  tmp2 = 0 ifTrue: [ ^true ].  arg1 size = 1 & (tmp2 = 1) ifFalse: [ ^false ].  tmp1 := arg2 itemAt: 1.  ^tmp1 == arg1 firstdefaultMenuItemName  ^'Add counter'setUpModelFromContext  | tmp1 |  super setUpModelFromContext.  methodClass := context selectedClassSide.  context isMethodGroupSelected ifFalse: [ ^self ].  tmp1 := context lastSelectedMethodGroup.  (tmp1 isKindOf: ClyExternalPackageMethodGroup) ifTrue: [ ^extendingPackage := tmp1 package ].  (tmp1 isKindOf: ClyTaggedMethodGroup) ifTrue: [ ^methodTags := {tmp1 tag} ]testFromSingleClass  | tmp1 |  self queryFromScope: ClyClassScope of: ClyClass2FromP1.  tmp1 := resultItems collect: #name as: Set.  self assert: tmp1 equals: ClyClass2FromP1 instVarNames asSet , (ClyClass2FromP1 classVariables collect: #name)sortFunctionFor: arg1  ^functionsForTypes at: arg1 calypsoEnvironmentType ifAbsentPut: [ arg1 calypsoEnvironmentType defaultSortFunctionForCalypso ]methodFromTraitChild3  requestor: arg1  requestor := arg1testOne  | tmp1 |  tmp1 := self newTestedObject.  self     assert: tmp1 one isNil;     assert: (tmp1 one: #one) identicalTo: tmp1;     assert: tmp1 one equals: #oneallCount: arg1  allCount := arg1createQuery  ^ClyAllMethodCritiqueQuery from: self scopeWithCritiquesselectAnyVariable: arg1  textMorph setSelection: (self findAnyVariableInSourceCode: arg1)untestedOne: arg1  self one: arg1subclassClassVar1Writer  ClassVar1 := #subclassClassVar1Valueinitialize  super initialize.  asyncResult := ClyAsyncQueryResult newundoList: arg1  undoList := arg1isAppliedToBrowser  ^browser showsFlatResult notdisplayItemName  self displayItemPropertyBy: [:arg1 |  arg1 name ]execute  | tmp1 |  tmp1 := packages collect: [:arg1 |  arg1 name ].  (DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: tmp1) opentestMatchesMethodWithSelectorWhichMatchesIt  filter := ClyQueryBrowserFilter substringPattern: 'MethodWithSelector'.  self assert: (filter matches: self itemOfThisTestMethod)environment  ^environmentusesSlotBasedDefinition  ^Slot showSlotClassDefinitionsetUp  super setUp.  browser showResultOf: (ClyAllMethodsQuery sortedFrom: browser queryScopes first)executesQuery: arg1  self subclassResponsibilityasUnifiedInstance  ^selfinstSideMethodWithScriptWithArgument  < script: 'self inform: ''It is example inst side method with script with argument from '', self name'>  protectAccessWhile: arg1  ^arg1 valuequeryView: arg1  queryView := arg1actualObjects  ^items collect: [:arg1 |  arg1 actualObject ]matches: arg1  | tmp1 |  tmp1 := arg1 class = ClyBrowserItem ifTrue: [ arg1 actualObject ] ifFalse: [ arg1 ].  (pattern value beginsWith: '[') ifTrue: [ ^self matchesByScript: tmp1 ].  ^tmp1 matchesQueryBrowserFilter: selfisStatic  ^falsebaseQueryResult: arg1  baseQueryResult := arg1asGoToSpotterCandidate  ^tool asGoToSpotterCandidatetestComparison  self assert: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}) equals: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}).  self assert: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}) hash equals: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}) hash.  self deny: (self queryClass of: {(ClyInstanceVariable named: #x definedIn: Point)}) equals: (self queryClass of: (ClyInstanceVariable named: #y definedIn: Point))iconNameForSpotterMenu  ^#packageIconenvironment: arg1  environment := arg1selectedProjects  ^self actualSelectionFrom: self selectedProjectItemsrawItems  ^items collect: [:arg1 |  arg1 actualObject ]testSelectsAbstractMethod  self assert: (query selectsMethod: ClyAbstractClassExample >> #abstractMethod1)readParametersFromContext: arg1  super readParametersFromContext: arg1.  script := arg1 selectedClassScripthierarchy: arg1  hierarchy := arg1addTool: arg1  | tmp1 |  tools add: arg1.  arg1 width: tabMorph width.  tmp1 := arg1 createTab.  tmp1 when: #tabDeleted send: #tabDeleted: to: self.  tmp1 when: #tabSelected send: #tabSelected: to: self.  tmp1 label on: #doubleClick send: #toggleFullWindowTabs to: browser.  tmp1 label on: #mouseDown send: #mouseDown: to: tmp1.  tmp1 label on: #mouseUp send: #mouseUp: to: tmp1.  tabMorph addTab: tmp1= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^tag = arg1 tagbuildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope classesDo: [:arg2 |  (self selectsClass: arg2) ifTrue: [ tmp1 add: (ClyClassComment of: arg2) ] ].  arg1 fillWith: tmp1executeCommand: arg1 by: arg2  arg1 isComplexRefactoring ifTrue: [ arg1 confirmRefactoringInContext: self by: arg2 ].  arg1 executeneverRestoreSelection  shouldRestoreSelection := falseposition  ^positiondefaultMenuIconName  ^#smallFindIcon= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^localScopeClass = arg1 localScopeClassbuildProcess  ^buildProcesstestDefaultHierarchyShouldExist  self assert: (ClyMethodVisibilityGroups defaultHierarchy isKindOf: ClyClassHierarchy)value  ^valuequeryClass  ^ClyAsyncQuerycollate: arg1 with: arg2  ^arg1 name threeWayCompareTo: arg2 nametestFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1 .         ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1}testIsNotBasedOnAnyObject  scope := self createSampleScope.  self deny: (scope isBasedOn: #anyObject)defaultMenuIconName  ^#arrowDownimportMethods: arg1  arg1 do: [:arg2 |  self importMethod: arg2 ]createQuery  ^ClyUnclassifiedMethodsQuery from: (ClyClassScope of: ClyClass1FromP1 in: environment)adoptLocalScopeClassTo: arg1  description  ^'instance variables'editingText  ^editingMethod sourceCodemethodsDo: arg1  self packagesDo: [:arg2 |  arg2 extensionMethods do: arg1 ]setUp  super setUp.  installedCounters := OrderedCollection newisForScripting  ^isForScriptingdefaultIconName  ^#classIcontestDataSourceWithExpandedItems  self selectedItem expand.  self snapshotState.  self assert: (navigationState dataSource expandedItems first isSameAs: viewDataSource expandedItems first)printBasisObject: arg1 on: arg2  | tmp1 |  tmp1 := subscopes detect: [:arg3 |  arg3 isBasedOn: arg1 ].  ^tmp1 printBasisObject: arg1 on: arg2queryFromScope: arg1 ofAll: arg2  query scope: (arg1 ofAll: arg2 in: environment).  self executeQueryfindItemsWhere: arg1  ^queryResult itemsWhere: arg1defaultMenuItemName  ^'Overriding methods'setUpModelFromContext  super setUpModelFromContext.  editingClass := context lastSelectedClassadoptBrowserToolLayout  originalToolPanel := PanelMorph new.  originalToolPanel     name: 'original tool elements';     color: Color transparent;     borderWidth: 0;     layoutPolicy: browserTool layoutPolicy.  browserTool submorphs do: [:arg1 |  originalToolPanel addMorphBack: arg1 ].  browserTool changeProportionalLayout.  browserTool addMorph: originalToolPanel fullFrame: (0 @ 0 corner: 1 @ 1) asLayoutFrameattachToSystem  TestCase historyAnnouncer weak when: TestSuiteEnded send: #testRan: to: selftestFillingHierarchicalInstance  query := ClyAllClassesQuery from: ClyPackageScope of: ClyClass1FromP1 package in: environment.  queryResult := ClyExtensionLastSortedClasses hierarchical prepareNewFor: query in: environment.  queryResult buildWith: {ClySubclassLOfClass0FromPExtendedByP1 .         ClySubclassN1OfClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassN1OfClass1FromP1 .         1 .         ClySubclassLOfClass0FromPExtendedByP1 .         0}.  self assert: (items last isMarkedWith: ClyExtendedClassTag).  self deny: (items first isMarkedWith: ClyExtendedClassTag).  self deny: (items second isMarkedWith: ClyExtendedClassTag)description  ^'Open browser with methods where halts or breakpoints are installed'register: arg1  updateQueue nextPut: arg1.  self ensureRunninginitialize  super initialize.  self layoutInset: 4 @ 0selectsMethod: arg1  ^methods anySatisfy: [:arg2 |  arg2 calypsoEnvironmentType checkCalypsoItem: arg2 isEqualTo: arg1 ]isEmpty  ^self size = 0actualSelectionFrom: arg1  ^arg1 collect: [:arg2 |  arg2 actualObject ]supportsQuery: arg1  ^true= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^relationScopeClasses = arg1 relationScopeClassesinitialize  super initialize.  functionsForTypes := IdentityDictionary newrefreshingBlock: arg1  refreshingBlock := arg1snapshotState  navigationState := queryView snapshotStatedetachFromSystem  browser system unsubscribe: selftestClassFor: arg1  | tmp1 tmp2 |  tmp1 := self testClassNameFor: arg1.  self systemEnvironment classNamed: tmp1 ifPresent: [:arg2 |  tmp2 := arg2 ] ifAbsent: [ (self isValidClass: arg1) ifFalse: [ ClyInvalidClassForTestClassGeneration signalFor: arg1 ].        self systemEnvironment ensureExistAndRegisterPackageNamed: arg1 package name asString , '-Tests'.        tmp2 := TestCase subclass: tmp1 instanceVariableNames: '' classVariableNames: '' package: (self newTestClassCategoryFor: arg1).        self addNewCommentForTestClass: tmp2 basedOn: arg1 ].  ^tmp2source: arg1  definitionString := arg1execute  ClySubclassHierarchy invertMethodVisibilityHierarchy.  browser switchToMethodGroupsselectClass: arg1  self selectObject: arg1browseClassNamed: arg1  | tmp1 |  tmp1 := (self system bindingOf: arg1) ifNil: [ self chooseClassToBrowseFrom: arg1 ] ifNotNil: [:arg2 |  tmp1 := arg2 value ].  tmp1 ifNil: [ ^self ].  tmp1 isClassOrTrait ifFalse: [ tmp1 := tmp1 class ].  self spawnBrowser: ClyFullBrowser withState: [:arg3 |  arg3 selectClass: tmp1 ]testEmptyWhenNoMethods  query scope: (ClyMethodScope of: self class >> #method1 in: environment).  query methods: #().  self assert: query checkEmptyResultqueryToExpand: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := treeStructure detect: [:arg3 |  arg1 isBasedOnItemType: arg3 key ] ifNone: arg2.  ^arg1 type perform: tmp1 value with: arg1 actualObject with: self dataSource queryEnvironmentsubqueries: arg1  arg1 size = 1 ifFalse: [ self error: 'Wrapper query should include single subquery' ].  super subqueries: arg1testCreationUnifiedInstance  | tmp1 |  scope := self multipleScopeSample.  tmp1 := scope asUnifiedInstance.  self assert: tmp1 class equals: scope class.  self assert: tmp1 environment equals: environment.  self assert: tmp1 basisObjects isEmptytestFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(classSideReference1OfClass reference1OfClass reference2OfClass)publishCollectedChanges  changes do: [:arg1 |  arg1 notifyChanges ].  changes removeAlltestFillingWithClassAndItsTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot1 .         3}update  (contextBar submorphs isEmpty and: [ commandBar submorphs isEmpty ]) ifTrue: [ self height: 0.        contextBar height: 0.        commandBar height: 0 ]extraClassScope: arg1  extraClassScope := arg1.  self detectActiveStateisInlined  ^trueisClassSelected  ^self selectedClassItems notEmptytestNotExecutedFromMultipleScopeWhenSingleSubqueryIsBasedOnScopeOfSingleObject  query subqueries: {(self subqueryFromScopeOf: self class)}.  self deny: query isExecutedFromMultipleScopetestIsBasedOnMultipleBasisWhenTwoSubscopesAreBasedOnSingleButDifferentObject  | tmp1 tmp2 |  tmp1 := ClyScopeExample of: #basisObject1 in: environment.  tmp2 := ClyScopeExample of: #basisObject2 in: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self assert: scope isBasedOnMultipleBasisbuild  | tmp1 |  tmp1 := self theme newLabelIn: self label: self title.  tmp1 on: #click send: #executeCommand to: self.  tmp1 emphasis: TextEmphasis underlined emphasisCode.  self addMorph: tmp1createMethodGroupFor: arg1 from: arg2  ^ClyNoTagMethodGroup withMethodsFrom: arg1isSimilarTo: arg1  (super isSimilarTo: arg1) ifFalse: [ ^false ].  ^editingPackage = arg1 editingPackagetestFromSingleClass  self queryFromScope: ClyClassScope of: ClySubclassLOfClass0FromPExtendedByP1.  self assert: resultItems asSet equals: {ClyClass1FromP1 package} asSetprintDefiningClass  ^isInstanceSide ifTrue: [ definingClassItem name ] ifFalse: [ definingClassItem name , ' class' ]failureCount: arg1  failureCount := arg1checkEmptyResult  scope classGroupsDo: [:arg1 |  ^false ].  ^truechildrenDataSource: arg1  childrenDataSource := arg1.  childrenDataSource ifNotNil: [ childrenDataSource parentItem: self.        childrenDataSource depth: self depth + 1 ]depth  ^ownerDataSource depth + browserItem depthdetachFromSystem  browser system unsubscribe: selfexecuteUndoBy: arg1  undoExecuting := true.  arg1 ensure: [ undoExecuting := false.        waitingNewState := true ]showAllMethods  | tmp1 |  tmp1 := ClyAllMethodsQuery sortedFrom: self classScopeForMethods.  methodView showQuery: tmp1testExecutionWhenNoCritiquesFromRequiredGroup  query groupName: 'wrong group'.  self executeQuery.  self assert: resultItems isEmptytestFromPackageWithTagsAndUncategorizedClasses  self queryFromScope: ClyPackageScope of: ClyClass6UntaggedFromP5 package.  self assert: resultItems asSet equals: {ClyClass6UntaggedFromP5} asSetbelongsToRemovedBrowserContext  ^editingClass isObsoletesimpleNameForSpotterMenu  ^'Protocols'testAllItems  | tmp1 tmp2 |  tmp1 := cursor retrieveAll.  self deny: tmp1 equals: queryResult items.  self assert: (tmp1 collect: #actualObject) equals: queryResult items.  tmp2 := tmp1 reject: #isPrepared.  self assert: tmp2 isEmpty.  self assert: (tmp1 collect: #position) asArray equals: (1 to: queryResult size) asArrayexpectedFlatQueryResult  ^expectedFlatQueryResultexpansionChanged  queryView restoreSelectedItems.  self tableRefresh.  self table resetFunctiontitle: arg1  title := arg1description  ^', ' join: (resultItems collect: [:arg1 |  arg1 printAsConstantQueryItem ])unsubscribe: arg1  announcer ifNil: [ ^self ].  announcer unsubscribe: arg1findItemsWith: arg1  ^Array new: arg1 size withAll: nilreferencedClass  ^self classdefaultFocusMorph  ^itemsView filterField ifNil: [ itemsView dataSource table ]takeKeyboardFocus  table takeKeyboardFocusprepareItems: arg1  arg1 do: [:arg2 |  arg2 ifNotNil: [ arg2 prepareIn: self environment ] ].  ^arg1childrenDataSource  ^childrenDataSourceactivateFilterWith: arg1  self initiateUIChangeBy: [ table activateFilterWith: arg1.        self updateSelection ]initialize  super initialize.  mergedParts := #()testCompareWithSimilarQueryWhichSubqueryHasDifferentScope  | tmp1 |  tmp1 := self queryClass with: {(self subqueryFromScopeOf: self class superclass)}.  self deny: query equals: tmp1processDynamicMethodGroups: arg1 by: arg2  | tmp1 |  tmp1 := OrderedCollection new: arg1 size.  self methodsDo: [:arg3 |  arg1 do: [:arg4 |  (arg4 dependsOnMethod: arg3) ifTrue: [ arg2 value: arg4.                    tmp1 add: arg4 ] ].        arg1 removeAll: tmp1.        arg1 ifEmpty: [ ^self ].        tmp1 reset ]itemsWhere: arg1  | tmp1 tmp2 |  actualResult protectItemsWhile: [ tmp1 := OrderedCollection new.        actualResult items doWithIndex: [:arg2 :arg3 |  tmp2 := arg2 asCalypsoBrowserItem.              (arg1 value: tmp2) ifTrue: [ tmp2 position: arg3.                    tmp2 prepareIn: self environment.                    tmp1 add: tmp2 ] ].        ^tmp1 ]testExecution  self executeQuery.  self assert: resultItems size equals: 1testPrepareResultForExecution  | tmp1 |  tmp1 := query prepareNewResult.  self assert: tmp1 class equals: ClyAsyncQueryResult.  self assert: tmp1 buildingQuery identicalTo: query actualQuery.  self assert: tmp1 environment identicalTo: environment.  self assert: tmp1 isProtectedselectStringAsInMessageBrowser: arg1  | tmp1 |  tmp1 := (self findAnySelectorInSourceCode: {arg1}) ifEmpty: [ self findString: arg1 asSelectorIn: self pendingText ].  textMorph setSelection: tmp1browser  ^textArea editingMode browserlastSelectedProject  ^self lastSelectedObjectIn: self selectedProjectssimpleNameForSpotterMenu  ^'Comment editor: ' , self editingClass nameexpectedSourceCodeSubstring  ^'it should be in the source code of ' , #expectedMethodrenameClassTagTo: arg1  self classes do: [:arg2 |  arg2 tagWith: arg1.        arg2 untagFrom: self tag ].  classQuery scope packagesDo: [:arg2 |  (arg2 tagsForClasses includes: arg1) ifFalse: [ arg2 addClassTag: arg1 ].        arg2 removeClassTag: self tag ]methodWithoutWatchpoint  name: arg1  name := arg1redoList  ^redoListsnapshotState  | tmp1 |  tmp1 := selection rootDataSource copyForBrowserStateSnapshot.  ^ClyQueryViewState new     dataSource: tmp1;     selection: (selection copyForBrowserStateSnapshotOf: tmp1)pattern  ^patternsize  ^items sizeisMethodSelected  ^selectedItems anySatisfy: [:arg1 |  arg1 isBasedOnItemType: ClyMethod ]runTestCase: arg1 results: arg2  arg1 resetHistory.  arg1 suite run: arg2pattern: arg1  pattern := arg1testConvertingToNewMetaLevel  | tmp1 |  tmp1 := query withMetaLevelScope: ClyInstanceSideScope.  self assert: tmp1 scope class equals: ClyInstanceSideScope.  self assert: tmp1 scope basisObjects equals: query scope basisObjectsexecute  (ChangesBrowser changes: {critique change}) openasInterestingClassScope  ^self copy relationScopeClasses: (relationScopeClasses collect: [:arg1 |  arg1 asInterestingClassScope ])initialize  super initialize.  self     changeTableLayout;     listDirection: #leftToRight;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     extent: 0 @ 0prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browser.  systemEnvironment := arg1 systemEnvironmentrepresentsScope: arg1  self subclassResponsibilitytestNotSelectsMethodWithCritiquesWhenTheyNotComputedYet  self deny: (query selectsMethod: ClyClassWithProblemMethods >> #methodWithHalt)execute  testItems do: [:arg1 |  self runTestCase: arg1 actualObject ]testNotSelectsAbstractMethodWhichIsImplemented  self deny: (query selectsMethod: ClyAbstractClassExample >> #abstractMethod1)buildResult: arg1  arg1 fillWith: (scope basisObjects sorted: #printString ascending)initialize  super initialize.  stringPattern := ClySubstringPattern with: '' caseSensitive: falseremoveFromBrowser  containerTab deleterequiredQueryResult  ^ClyTraitUserHierarchy new asQueryResultdescription  ^'Automatically resolve the issue'execute  browser switchToFullClassHierarchyisLive  ^definingClass isClassSidebrowser: arg1  browser := arg1openInspector  actualVariable value inspectrebuild  super rebuild.  self buildIndexesexecute  self methods do: [:arg1 |  self generateTestMethodFor: arg1 ].  testMethodToBrowse ifNotNil: [:arg2 |  browser selectMethod: arg2 ]dialogClass  ^dialogClassbuildResult: arg1  arg1 fillWith: self scopedMethodsisProjectChildSelected  ^self selectedProjectChildItems notEmptylastSelectedSourceNode  ^self lastSelectedMethod astForStylingInCalypsotestAscendingSamePackageSameClassDifferentSelector  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: Object >> #yourself value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #yourself)createMethodGroupFor: arg1 from: arg2  ^ClyMethodGroup named: 'breakpoints' priority: 8.4 on: arg1testIsNotBasedOnSingleBasis  scope := self createSampleScope.  self deny: scope isBasedOnSingleBasisisInlined  ^truetestMethodsEnumerationWithBothMetaLevelScopeShouldNotDublicateMethods  | tmp1 |  scope := ClySuperclassScope of: ClySubclassN1OfClass1FromP1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:arg1 |  arg1 methodClass instanceSide = ClyClass1FromP1 ifTrue: [ result add: arg1 ] ].  tmp1 := (ClyClass1FromP1 localMethods , ClyClass1FromP1 class localMethods) asIdentitySet.  self assert: result asIdentitySet equals: tmp1setUp  super setUp.  group := self createMethodGroupconfirmUnusedClasses: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := ClyClassReferencesQuery toAny: arg1 from: self systemScope.  tmp2 := self confirmEmptySystemQuery: tmp1 excluding: (arg1 flatCollect: [:arg2 |  {arg2 .               arg2 classSide} ]).  tmp4 := (arg1 flatCollect: [:arg2 |  arg2 subclasses ]) copyWithoutAll: arg1.  tmp4 ifNotEmpty: [ tmp2 := false.        tmp3 := UIManager default confirm: 'There are subclasses. Show them?'.        tmp3 ifTrue: [ self spawnQueryBrowserOn: (ClyConstantQuery returning: tmp4) ] ].  tmp5 := (arg1 flatCollect: [:arg2 |  arg2 users ]) copyWithoutAll: arg1.  tmp5 ifNotEmpty: [ tmp2 := false.        tmp3 := UIManager default confirm: 'There are users of trait. Show them?'.        tmp3 ifTrue: [ self spawnQueryBrowserOn: (ClyConstantQuery returning: tmp5) ] ].  ^tmp2activationPriorityInNonActiveContext  ^isManagedByUser ifTrue: [ self activationPriority ] ifFalse: [ Float negativeInfinity ]isResult: arg1 affectedBy: arg2  ^arg2 affectsMethods and: [ scope includesMethodsAffectedBy: arg2 ]testConvertingToScopeIncludedInheritingScope  | tmp1 tmp2 |  scope := self createSampleScope.  tmp2 := scope asInheritingScope.  tmp1 := scope withInheritingScope.  self assert: tmp1 class equals: ClyCompositeScope.  self assert: tmp1 name equals: ClyClassScope userHierarchyScopeName.  self assert: (tmp1 subscopes includes: scope).  self assert: (tmp1 subscopes includes: tmp2)methodGroupProvidersDo: arg1  | tmp1 |  environment pluginsDo: [:arg2 |  tmp1 := arg2 collectMethodGroupProviders.        tmp1 do: arg1 ]defaultItems  ^#()initialize  super initialize.  changes := IdentitySet newbaseCritiqueQuery: arg1  baseCritiqueQuery := scope adoptQuery: arg1checkEmptyResult  | tmp1 |  scope methodsDo: [:arg1 |  tmp1 := arg1 origin package.        (arg1 isDefinedInPackage: tmp1) ifFalse: [ arg1 package ifNotNil: [:arg2 |  ^false ] ] ].  ^trueannounceChangesOf: arg1  arg1 notifyChangestestClassEnumerationOverMetaclassBasisWhenInstanceSideIsLocalScope  scope := ClyInterestingSuperclassScope of: ClySubclassN1OfClass1FromP1 class localScope: ClyInstanceSideScope.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {ClyClass1FromP1} asSettestComparison  self assert: (ClyClassCommentsQuery withString: 'test substring') equals: (ClyClassCommentsQuery withString: 'test ' , 'substring').  self assert: (ClyClassCommentsQuery withString: 'test substring') hash equals: (ClyClassCommentsQuery withString: 'test ' , 'substring') hash.  self deny: (ClyClassCommentsQuery withString: 'test substring') equals: (ClyClassCommentsQuery withString: 'another substring')async  ^selfeditingMethod  ^editingMethodprintIt  | tmp1 |  self evaluateSelectionAndDo: [:arg1 |  tmp1 := [ arg1 asScriptResultStringInCalypso ] on: Error do: [ '<error in printString: try ''Inspect it'' to debug>' ].        self afterSelectionInsertAndSelect: tmp1 ]= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^hierarchy = arg1 hierarchyisExecutedFromScopeOf: arg1  ^scope isBasedOn: arg1targetView  ^targetViewtestIsAffectedByChangeOfSuperclassMethodWhichIsAlreadyImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #overriddenMethod)methodWithHalts2  self haltrecordNavigationState: arg1  navigationHistory recordState: arg1loadAsyncQueryResult  ^methodQuery executechangesCancelRequested: arg1  changesCancelRequested := truedescription  ^'rest unclassified classes'testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScope  < expectedFailure>  super testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScopesetUpDefaultIcon  | tmp1 |  tmp1 := editingClass hasComment ifTrue: [ #commentsIcon ] ifFalse: [ #uncommentedClass ].  containerTab icon: (self iconNamed: tmp1)allCount  ^allCounttestFindTestCaseWithAnotherSuffixCoveringTestedClass  | tmp1 |  tmp1 := plugin findTestCaseCovering: ClyTestedClass2 ifAbsent: [  ].  self assert: tmp1 equals: ClyTestedClass2TesttestExpectedFailure  < expectedFailure>  self assert: false description: 'it is example test with expected failure'applyChanges  self pendingText asString = self editingText ifFalse: [ editingPackage packageManifest comment: self pendingText stamp: Author changeStamp ].  ^truepackage  ^packageadoptForBrowser  buildingQuery retrievesBrowserItems ifTrue: [ ^ClyAsyncBrowserQueryResultAdapter for: self ].  ^super adoptForBrowserorder  ^2isSelectedItemHasBreakpoint  ^selectedSourceNode hasBreakpointdecorateBrowserItem: arg1 ofMethod: arg2  arg2 containsHalt ifTrue: [ arg1 markWith: ClyMethodWithHaltTag ].  arg2 hasBreakpoint ifTrue: [ arg1 markWith: ClyMethodWithBreakpointTag ].  (self doesMethodHasExecutionCounter: arg2) ifTrue: [ arg1 markWith: ClyMethodWithExecutionCounterTag ].  (self doesMethodHasWatchpoint: arg2) ifTrue: [ arg1 markWith: ClyMethodWithWatchpointTag ]prepareBasisFrom: arg1  arg1 size = 1 ifFalse: [ self error: 'System scope should be created on single basis' ].  ^arg1testComparison  self assert: (ClyConstantMethodQuery with: {(self class >> #method1)}) equals: (ClyConstantMethodQuery with: {(self class >> #method1)}).  self assert: (ClyConstantMethodQuery with: {(self class >> #method1)}) hash equals: (ClyConstantMethodQuery with: {(self class >> #method1)}) hash.  self deny: (ClyConstantMethodQuery with: {(self class >> #method1)}) equals: (ClyConstantMethodQuery with: {(self class >> #method2)})filteredBy: arg1  ^ClyFilterQuery for: self filter: arg1chooseClassToBrowseFrom: arg1  | tmp1 tmp2 |  tmp1 := (ClyAllClassesQuery sortedFrom: self systemScope) filteredBy: (ClyItemNameFilter substringPattern: arg1).  tmp2 := tmp1 execute.  tmp2 isEmpty ifTrue: [ ^nil ].  tmp2 size = 1 ifTrue: [ ^tmp2 items first ].  ^[ self searchDialog requestSingleObject: 'Choose a class to browse...' from: tmp1 ] on: CmdCommandAborted do: [ nil ]testComparisonOfSimilarQueriesWithEqualScopes  | tmp1 |  tmp1 := self createQuery.  query scope: (ClyScopeExample of: #basisObject in: environment).  tmp1 scope: (ClyScopeExample of: #basisObject in: environment).  self assert: query equals: tmp1.  self assert: query hash equals: tmp1 hashmethod2  ^#method2decorateContainerTab  | tmp1 |  super decorateContainerTab.  tmp1 := editingClass name.  editingClass isClassSide ifTrue: [ tmp1 := tmp1 asText allBold asStringMorph ].  containerTab label: tmp1defaultMenuItemName  ^'History'prepare  self adoptBrowserToolLayout.  self createCriticView.  progressMorph := ClyActivityAnimationIconMorph label: 'critiques analysis'defaultMenuIconName  ^#smallDebugtestFillingWithMetaclass  queryResult fillWith: {Array class}.  self assert: queryResult items equals: {Array binding}description  ^'extension methods of ' , package nametestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithUndeclares >> #method1WithUndeclares) .         (ClyClassWithUndeclares >> #method2WithUndeclares) .         (Object >> #printString)}.  self assert: foundSelectors sorted asArray equals: #(method1WithUndeclares method2WithUndeclares)testFillingWithClassAndItsTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild1 .         1 .         ClyTraitRoot1 .         2 .         ClyTraitChild2Child .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot1 .         3}execute  Watchpoint in: sourceNodeaffectsMethodsDefinedInPackage: arg1  ^arg1 definesOverridesOf: self overriddenMethodtestNotExecutedFromSingleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  < expectedFailure>  super testNotExecutedFromSingleScopeWhenSubqueriesAreFromScopesOfDifferentObjectsretrievesItemsOfType: arg1  ^self resultItemsType isCalypsoItemType: arg1createQueryResult  ^ClySemiAsyncQueryResult newincludesMethodsAffectedBy: arg1  self classesDo: [:arg2 |  (arg2 includesMethodsAffectedBy: arg1) ifTrue: [ ^true ] ].  ^falseselectedObjects  ^self actualSelectionFrom: selectedItemsexecute  | tmp1 |  tmp1 := methodEditor tagsAndPackageEditor.  tmp1 requestChangeBy: [ tmp1 requestPackage ]browser: arg1  browser := arg1title  ^titlecreateQuery  ^ClyUnknownQuery newupdateSelectedItemsOf: arg1  | tmp1 |  self initiateUIChangeBy: [ tmp1 := selection updateItemsWhichBelongsTo: arg1.        highlighting updateItemsWhichBelongsTo: arg1.        desiredSelection ifNotNil: [ desiredSelection updateItemsWhichBelongsTo: arg1.              tmp1 := tmp1 | (desiredSelection restoreCurrentSelectionAfterUpdate: selection) ].        ^tmp1 ]packageSelection  ^packageView selection asSelectedParentsOf: RPackageanalyzedObject  ^analysisScope basisObjects anyOnetestBindToEnvironment  scope := self createSampleScope.  scope bindTo: environment.  self assert: scope environment equals: environment.  self assert: scope isBoundToEnvironmentisResult: arg1 affectedBy: arg2  ^self subclassResponsibilityselectedProjectItems  ^selectedItems collect: [:arg1 |  arg1 rootParentItem ]testAscendingMethodsWithSameSelectorButDifferentClass  function := ClySortMethodBySelectorFunction ascending.  self deny: (function value: Object >> #printString value: Number >> #printString).  self assert: (function value: Number >> #printString value: Object >> #printString)traitScopeClass  ^ClyTraitUserScopecreateQuery  ^ClyTaggedClassesQuery by: #Tag1 from: (ClyClassScope of: Object in: environment)defaultMenuItemName  ^'Overridden methods'isMainColumn  ^falseprintOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  arg1 nextPutAll: name.  arg1 nextPut: $)markWith: arg1  self addProperty: arg1 instancesnapshotState  self subclassResponsibilityprintOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  testCase printOn: arg1.  arg1 nextPut: $)name  ^nametestConvertingWithNewRequiredResultShouldConvertActualQueryToo  | tmp1 tmp2 |  tmp1 := ClyRawQueryResult new.  tmp2 := query withResult: tmp1.  self assert: tmp2 actualQuery requiredResult identicalTo: tmp1buildAndDecorate  self isBuilt ifTrue: [ ^self ].  self setUpParametersFromModel.  self decorateContainerTab.  self build.  self buildStatusBar.  self applyDecorations.  self attachToSystemselectPackage: arg1  self changeStateBy: [ packageView selection selectItemsWith: {arg1}.        packageView selection isEmpty ifTrue: [ self switchToPackages ].        packageView selection selectItemsWith: {arg1} ]= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^definingClass = arg1 definingClass and: [ actualVariable = arg1 actualVariable ]testComparingWithAnotherAsyncQueryWithDifferentAsyncResult  | tmp1 |  tmp1 := query semiAsync.  self deny: query equals: tmp1testConvertingToInterestingClassScope  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asInterestingClassScope.  self assert: tmp1 equals: scopeexecute  ExecutionCounter installOn: sourceNodeupdateIfDirty  rootDataSource isDirty ifTrue: [ rootDataSource runUpdate ].  items do: [:arg1 |  arg1 ownerDataSource isDirty ifTrue: [ arg1 ownerDataSource runUpdate ] ]testGettingAllItems  | tmp1 |  queryResult fillWith: #(1 2 3).  tmp1 := queryResult allItems.  self assert: tmp1 asArray equals: #(1 2 3)name: arg1  name := arg1projectManager  ^projectManagertestComparisonWithDifferentRelationScopes  | tmp1 |  scope := ClyMultipleClassRelationScope of: #() merging: {ClySuperclassScope}.  tmp1 := ClyMultipleClassRelationScope of: #() merging: {ClySubclassScope}.  self deny: scope equals: tmp1createQuery  ^ClyAllMethodGroupsQuery from: ClyClassScope of: Object in: environmentmethods: arg1  methods := arg1 asIdentitySetinitialize  super initialize.  color := Color transparent.  self changeTableLayout.  self vResizing: #shrinkWrap.  self hResizing: #shrinkWrap.  self minWidth: 0.  self minHeight: 0browserTool  ^browserToolisExecutedFromScope: arg1  ^scope representsScope: arg1selectSourceNode: arg1  textMorph setSelection: arg1 sourceIntervalstop  ^stopbuildContextBar  contextBar := Morph new     setNameTo: 'context bar';     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     cellInset: 4 @ 0;     color: Color transparent;     height: 0;     minHeight: 0.  self addMorphBack: contextBarexecute  browser switchToFlatClassestestConvertingWithoutAbsentBasisObject  | tmp1 |  scope := self createSampleScope.  tmp1 := scope withoutBasisObject: #notExistedBasis.  self assert: tmp1 class equals: scope class.  self assert: tmp1 basisObjects equals: scope basisObjectstestDescendingSamePackageDifferentClass  function := ClySortMethodByPackageFunction descending.  self deny: (function value: Object >> #printString value: True >> #not).  self assert: (function value: True >> #not value: Object >> #printString)createQuery  ^super createQuery semiAsyncupdateMainWindowTitle  | tmp1 |  tmp1 := self activeWindow ifNil: [ ^self ].  self window ifNotNil: [:arg1 |  arg1 setLabel: tmp1 label ]conditionBlockProducerMethodAST: arg1  | tmp1 tmp2 |  tmp2 := self parserClass parseExpression: arg1.  tmp1 := RBMethodNode selector: #conditionBlockGenerator body: (RBReturnNode value: (RBBlockNode arguments: {(RBVariableNode named: 'ThisContext')} body: (RBMessageNode receiver: (RBVariableNode named: 'Breakpoint') selector: #checkBreakConditionValue: arguments: {tmp2}) asSequenceNode)) asSequenceNode.  tmp1 := self rewriteASTToSimulateExecutionInADifferentContext: tmp1.  tmp1 source: tmp1 formattedCode.  ^tmp1showPackage: arg1 atClassTag: arg2  tool selectPackage: arg1 atClassTag: arg2pattern: arg1  pattern := arg1groupProviderClass  self subclassResponsibilitycreateCommandContext  ^self createTextContextname  ^browserItem nameaffectsMethodsTaggedWith: arg1  ^testCase tagsForMethods includes: arg1decorateBrowserItem: arg1 ofPackage: arg2  (arg2 classes anySatisfy: [:arg3 |  arg3 isTestCase and: [ arg3 isAbstract not ] ]) ifFalse: [ ^self ].  arg1 addProperty: ClyTestResultProperty newtestConvertingToAsyncQuery  | tmp1 |  tmp1 := query async.  self assert: tmp1 class equals: ClyAsyncQuery.  self assert: tmp1 actualQuery identicalTo: query.  self assert: tmp1 requiredResult identicalTo: query requiredResult.  self assert: tmp1 scope identicalTo: query scope.  self assert: tmp1 asyncResult class equals: ClyAsyncQueryResultshowMethod: arg1  tool selectMethod: arg1openAnotherBrowser: arg1  arg1 opentestMethodsEnumeration  scope := ClyPackageScope of: ClyClass1FromP1 package.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyClass1FromP1 localMethods).  self assert: (result includesAll: ClyClass2FromP1 localMethods).  self assert: (result includesAll: ClyClass1FromP1 classSide localMethods) description: 'Package scope should see class side methods too'.  self assert: (result includesAll: ClySubclassLOfClass0FromPExtendedByP1 localMethods) description: 'Package scope should see all clas extensions'registerProjectManager: arg1  projectManagers removeAllSuchThat: [:arg2 |  arg2 class = arg1 class ].  projectManagers add: arg1testNotBuiltByDefault  queryResult := queryResult class new.  self deny: queryResult isBuiltisPackagePartOfSelection: arg1  (self isPackageSelected: arg1) ifTrue: [ ^true ].  ^self projectSelection actualObjects anySatisfy: [:arg2 |  arg2 includesPackage: arg1 ]testFillingWithOnlyClassWhichHasTraits  queryResult fillWith: {ClyClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0}testIsExecutedFromMultipleScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self assert: query isExecutedFromMultipleScope.  query scope: (ClyScopeExample of: #singleObject in: environment).  self deny: query isExecutedFromMultipleScope.  query scope: (ClyScopeExample emptyIn: environment).  self deny: query isExecutedFromMultipleScopeshowsItemsOfType: arg1  ^self query retrievesItemsOfType: arg1itemType  ^itemTypedescription  ^'Run the example'projectManager: arg1  projectManager := arg1description  ^'methods with undeclared variables'hash  ^super hash bitXor: excludesHaltsForTesting hashcollapsedItems: arg1  collapsedItems := arg1getMetaProperty: arg1  ^self itemCursor getMetaProperty: arg1rebuildToolbar  toolbar updateItemsresetScope  scope := ClyUnknownScope instanceconfirmUnusedVariablesInDefiningClass: arg1  ^tool confirmUnusedVariablesInDefiningClass: arg1browserTool  ^browserToolclassSampleWhichHasGroup  ^ClyClassWithFFIMethodssingleScopeSample  | tmp1 |  tmp1 := super singleScopeSample.  tmp1 relationScopeClasses: {ClySuperclassScope}.  ^tmp1one  ^oneselectAsMainTab  containerTab selected: true.  (browser tabManager tabMorph instVarNamed: #contentsWrapper) color: self activeColoropenInspector  actualVariable value inspectcollectMethodGroupProviders  ^{ClyFFIMethodGroupProvider new}hash  ^super hash bitXor: resultItems hashisTraitSelected  | tmp1 |  tmp1 := self lastSelectedObjectIn: self selectedClassItems.  ^tmp1 isMarkedWith: ClyTraitTagtestExecution  self executeQuery.  self assert: resultItems asArray equals: query resultItems= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^hierarchy = arg1 hierarchybrowser: arg1  browser := arg1.  self buildtestFillingWithTraitsOfClassWhichIsMissingInGivenList  queryResult fillWith: {ClyTraitChild1 .         ClyTraitChild2 .         ClyTraitRoot1 .         ClyTraitChild2Child}.  self assertItems: {ClyTraitChild1 .         0 .         ClyTraitRoot1 .         1 .         ClyTraitChild2Child .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot1 .         2}itemsChangedIn: arg1  | tmp1 |  self refreshAsyncState.  tmp1 := self selection isEmpty.  browser ignoreNavigationDuring: [ self updateSelectedItemsOf: arg1.        tmp1 ifTrue: [ self ensureSelectedItemIfNeeded ] ].  browser itemsChangedinitialize  super initialize.  executionSemaphore := Semaphore newrequestSingleMethodTag: arg1  ^self requestSingleMethodTag: arg1 suggesting: ''switchResultTo: arg1  self changeStateBy: [ systemQuery := systemQuery withResult: arg1.        self showQueryResult ]changeStateOf: arg1 by: arg2  arg2 valuechangeMethodGroupQueryBy: arg1  self changeStateBy: [ methodGroupQuery := arg1 value.        methodGroupView showQuery: methodGroupQuery.        methodGroupView initiateUIChangeBy: [ self methodGroupSelectionChanged ] ]countToolsSimilarTo: arg1  ^tools count: [:arg2 |  arg2 class = arg1 class ]printExtraInfoOn: arg1  super printExtraInfoOn: arg1.  arg1 nextPutAll: critiqueQuery descriptionimplementorsOfIt  | tmp1 |  (tmp1 := self selectedSelector) == nil ifTrue: [ ^textArea flash ].  tmp1 isCharacter ifTrue: [ ^textArea flash ].  self browser browseImplementorsOf: tmp1asInterestingClassScope  ^self asScope: ClyInterestingSuperclassScopeisCurrentStateOf: arg1  ^(arg1 dataSource isInSameStateAs: dataSource) and: [ arg1 selection isSameAs: selection ]priority  ^priority ifNil: [ self class priority ]findItemsWith: arg1  | tmp1 |  tmp1 := self itemCursor findItemsWith: arg1.  ^tmp1 select: #notNil thenCollect: [:arg2 |  self createElementWith: arg2 ]testConvertingWithNewScope  | tmp1 tmp2 |  tmp1 := ClyScopeExample2 of: #someBasis in: environment.  tmp2 := query withScope: tmp1.  self assert: tmp2 class equals: query class.  self assert: tmp2 requiredResult identicalTo: query requiredResult.  self assert: (tmp2 subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (tmp2 subqueries collect: #scope as: Set) equals: {tmp1} asSetdecorateTableCell: arg1 of: arg2  super decorateTableCell: arg1 of: arg2.  methodQuery decorateMethodGroupTableCell: arg1 of: arg2testMethodsEnumeration  scope := ClyPackageExtensionScope of: ClyClass1FromP1 package.  scope methodsDo: [:arg1 |  result add: arg1 ].  self deny: (result includesAll: ClyClass1FromP1 localMethods).  self deny: (result includesAll: ClyClass2FromP1 classSide localMethods).  self assert: (result includesAll: ClySubclassLOfClass0FromPExtendedByP1 localMethods)isBasedOnMultipleBasis  ^self basisSize > 1methodWithFlag  self flag: #todo= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^actualObjectSortFunction = arg1 actualObjectSortFunctionisLive  ^truechangeStateBy: arg1  browser changeStateOf: self by: arg1overridingSubclass  ^overridingSubclasstestExecution  self executeQuery.  self assert: result identicalTo: ClyUnknownQueryResult instance.  self assert: resultItems equals: #()execute  browser updateisForbidden  ^self toolClass isAbstractisReadIn: arg1  (self isAccessibleFrom: arg1 origin) ifFalse: [ ^false ].  ^actualVariable isReadIn: arg1initialize  super initialize.  testCaseResults := IdentityDictionary newproperties: arg1  properties := arg1createQuery  ^ClyOverridingMethodsQuery from: ClyClassScope of: ClyClassWhichInheritsAbstractClass in: environmentpackage: arg1  package := arg1readParametersFromContext: arg1  menuItemName := arg1 tool hasUnacceptedEdits ifTrue: [ 'Classify currently editing method' ] ifFalse: [ 'Classify method' ]initialize  super initialize.  query := ClyUnknownQuery instance.  itemCursor := ClyClosedBrowserCursor instance.  depth := 0.  dirty := falsequeryCache  ^queryCachechangesAccepted  | tmp1 |  ^self applyChangesBy: [ textMorph hasUnacceptedEdits: true.        [ self changesAreAboutApply.        tmp1 := self applyChanges ] on: Error do: [:arg1 |  textModel text: self editingText.              textMorph hasUnacceptedEdits: true.              arg1 pass ].        tmp1 ifTrue: [ textMorph hasUnacceptedEdits: false.              self textUpdated.              browser focusActiveTab ] ifFalse: [ textModel text: self editingText.              textMorph hasUnacceptedEdits: true ] ]overriddenSuperclass: arg1  overriddenSuperclass := arg1hash  ^requiredResult hash bitXor: scope hashtestResultOf: arg1  ^arg1 getProperty: ClyTestResultPropertyorder  ^4printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  childrenType printOn: arg1.  arg1 nextPut: $)execute  classGroup removeWithClassessetUp  super setUp.  self setUpEnvironmentconvertToMethodTag: arg1  self methods do: [:arg2 |  arg2 tagWith: arg1 ]defaultMenuItemName  ^'Add breakpoint once'isActiveInContext: arg1  ^(super isActiveInContext: arg1) and: [ annotatedClass wantsDecorateTableCellInContext: arg1 ]newName: arg1  newName := arg1testNotAffectedByChangeOfOverriddenMethodFromAnotherHierarchyWhenSameMethodExistsHereToo  self deny: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)abstractMethod2  self subclassResponsibilitysimpleNameForSpotterMenu  ^'Query result'position  ^browserItem positionscheduleUpdate  self class scheduleUpdateOf: selftestSelectsMethodWithFlag  self assert: (query selectsMethod: ClyClassWithFlags >> #methodWithFlag)defaultMenuItemName  ^'Browse'retrievesItem: arg1  ^resultItems includes: arg1browserState: arg1  browserState := arg1items: arg1  items := arg1formatAsYouRead  ^RBProgramNode formatterClass formatAsYouReadPolicytestFillingWithThreeClasses  queryResult fillWith: {ClyClass2FromP1 .         ClySubclassN1OfClass1FromP1 .         ClyClass1FromP1}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassN1OfClass1FromP1 .         1 .         ClyClass2FromP1 .         0}setUpIconForMenuItem: arg1  overriddenMethod  ^#originalValueclose  | tmp1 |  tmp1 := self window.  (tmp1 ownerThatIsA: GroupWindowMorph) ifNotNil: [:arg1 |  ^self okToChange ifTrue: [ [ arg1 removeWindow: tmp1 ] on: ProvideAnswerNotification do: [:arg2 |  arg2 resume: true ] ] ].  tmp1 closepackageNamed: arg1  ^packageOrganizer packageNamed: arg1restrictMethodVisibilityBy: arg1  self changeMethodGroupQueryBy: [ methodGroupQuery restrictedByScope: arg1 ]hasBindingThatBeginsWith: arg1  ^self selectedClassOrMetaClass ifNil: [ false ] ifNotNil: [:arg2 |  arg2 hasBindingThatBeginsWith: arg1 ]isCaseSensitive: arg1  isCaseSensitive := arg1createInheritedScopeFrom: arg1  | tmp1 |  tmp1 := annotatedClass createInheritedScopeFrom: arg1.  tmp1 name: ClyClassScope inheritedScopeName.  ^tmp1scopeWithoutCritiques  ^ClyMethodScope of: self methodWithoutCritiques in: environmentisVariableSelected  | tmp1 tmp2 |  self isClassSelected ifTrue: [ ^false ].  tmp1 := self selectedSourceNode.  tmp1 isVariable ifFalse: [ ^false ].  tmp2 := tmp1 binding.  ^tmp2 isClassVariable | tmp2 isInstance | tmp2 isGlobalVariable | tmp2 isUndeclaredselectedPackageItems  ^selectedItemsdefaultMenuItemName  ^'Browse test class'classQuery: arg1  classQuery := arg1isAffectedByChangedMethod: arg1  | tmp1 tmp2 |  tmp2 := arg1 selector.  tmp1 := arg1 origin.  (self isFromScopeWithClassKindOf: tmp1) ifFalse: [ ^false ].  ^(self isAbstractMethod: arg1) or: [ self isClass: tmp1 shouldImplement: tmp2 ]testIsExecutedFromScopeOfBasisObject  query scope: (ClyScopeExample of: #basis in: environment).  self assert: (query isExecutedFromScopeOf: query scope basisObjects anyOne).  self deny: (query isExecutedFromScopeOf: #someObject)classesDo: arg1  subscopes do: [:arg2 |  arg2 classesDo: arg1 ]belongsToCurrentBrowserContext  | tmp1 |  tmp1 := browser packageSelection.  package ifNil: [ ^tmp1 isEmpty ].  tmp1 isEmpty ifTrue: [ ^true ].  ^tmp1 includesActualObject: packagesimpleNameForSpotterMenu  ^'Methods'testCheckIfEmpty  query scope: (ClyClassScope of: ClyClass6UntaggedFromP5 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ClyClass7WithTag1FromP5 in: environment).  self assert: query checkEmptyResultbrowserTool  ^textArea editingMode browserTooltargetVarName  ^#referencedVar1checkEmptyResult  executionSemaphore wait.  super checkEmptyResultdefaultTitle  ^'Comment'fillWith: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self buildItemsPerClassFrom: arg1.  tmp3 := ClySubclassHierarchy buildFrom: tmp1 keys.  items := OrderedCollection new: arg1 size.  tmp3 doInOrderWithDepth: [:arg2 :arg3 |  tmp2 := tmp1 at: arg2.        tmp2 do: [:arg4 |  arg4 depth: arg3 ].        items addAll: tmp2 ]withMetaLevelScope: arg1  | tmp1 |  tmp1 := subqueries collect: [:arg2 |  arg2 withMetaLevelScope: arg1 ].  ^self class with: tmp1 as: requiredResultprintExtraInfoOn: arg1  | tmp1 |  super printExtraInfoOn: arg1.  tmp1 := subqueries collect: [:arg2 |  arg2 description ] as: Set.  tmp1 do: [:arg2 |  arg1           nextPutAll: arg2;           nextPutAll: ', ' ].  arg1 skip: -2entity: arg1  entity := arg1selectVariableNamed: arg1  self selectMethodGroupNamed: arg1testIsAffectedByChangeOfSuperclassMethodWhichOverridesAnotherSuperclassMethod  query := ClyOverridingMethodsQuery from: ClyClassScope of: ClyClassWhichInheritsAbstractSubclass in: environment.  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)defaultMenuIconName  ^#forwardfillWith: arg1  items := arg1 collect: [:arg2 |  (arg2 isKindOf: Association) ifTrue: [ arg2 ] ifFalse: [ arg2 isObsolete ifTrue: [ GlobalVariable key: (arg2 name allButFirst: 'AnObsolete' size) asSymbol value: arg2 ] ifFalse: [ arg2 instanceSide binding ] ] ]isEqualTo: arg1  ^browserItem isEqualTo: arg1 browserItemtestApplyingToQueryViewShouldRestoreExpandedItems  | tmp1 tmp2 |  self selectedItem expand.  self snapshotState.  tmp2 := ClyQueryViewMorph for: browser.  navigationState applyTo: tmp2.  tmp1 := navigationState dataSource expandedItems first.  self assert: tmp1 childrenDataSource isClosed description: 'applying should not open data source snapshot'.  self assert: tmp2 dataSource expandedItems size equals: 1.  tmp1 := tmp2 dataSource expandedItems first.  self assert: (tmp1 isSameAs: self selectedItem).  self deny: tmp1 childrenDataSource isClosed.  self assert: tmp1 childrenDataSource queryView equals: tmp2.  self assert: tmp1 childrenDataSource table notNiltestDescending  function := ClySortItemGroupFunction descending.  self deny: (function value: (ClyItemGroup named: 'group1' priority: 20) value: (ClyItemGroup named: 'group2' priority: 10)).  self assert: (function value: (ClyItemGroup named: 'group1' priority: 10) value: (ClyItemGroup named: 'group2' priority: 20)).  self assert: (function value: (ClyItemGroup named: 'group2') value: (ClyItemGroup named: 'group1')).  self deny: (function value: (ClyItemGroup named: 'group1') value: (ClyItemGroup named: 'group2'))addPlugin: arg1  plugins detect: [:arg2 |  arg2 class = arg1 class ] ifFound: [ ^self ].  arg1 browser: self.  plugins add: arg1defaultMenuItemName  ^'Rename'testCreationOnTwoSimilarSubscopesOfSameObject  | tmp1 tmp2 |  tmp1 := ClyScopeExample ofAll: #(sameBasisObject basisObject1) in: environment.  tmp2 := ClyScopeExample ofAll: #(sameBasisObject basisObject2) in: environment.  scope := ClyCompositeScope on: {tmp1 .         tmp2}.  self assert: scope basisObjects asSet equals: #(sameBasisObject basisObject1 basisObject2) asSetclassGroup: arg1  classGroup := arg1testBasedOnSingleBasis  scope := self singleScopeSample.  self assert: scope isBasedOnSingleBasis.  scope := self multipleScopeSample.  self deny: scope isBasedOnSingleBasis.  scope := self emptyScopeSample.  self deny: scope isBasedOnSingleBasisisSingleSelected  ^items size = 1collectMetadataOfPackages: arg1  testMethodsEnumerationWhenBasisIsTraitedClassClasSide  | tmp1 |  scope := ClyInstanceSideScope of: ClyClassWithTraits classSide.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClassWithTraits methods collect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArrayscript: arg1  script := arg1displayItemPropertyBy: arg1  displayBlock := [:arg2 :arg3 |  arg2 label contents: (arg1 value: arg3 browserItem) ]isExpanded  ^ownerDataSource isExpanded: selftestMatchesStringWhichMatchesCorrectRegex  | tmp1 |  tmp1 := ClyRegexPattern with: '.abs'.  self assert: (tmp1 matches: '1abs').  self deny: (tmp1 matches: 'abs')dataSource  ^dataSourcehash  ^super hash bitXor: isCaseSensitive hashtestVariableLookup_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'var') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext lookupSymbol: #var)]')iconNameForSpotterMenu  ^#packageIconsystemEnvironment  ^self systemtestGettingAllItemsSatisfyingCondition  | tmp1 |  queryResult fillWith: #(1 2 3 4 5 6).  tmp1 := queryResult itemsWhere: [:arg1 |  arg1 between: 2 and: 4 ].  self assert: tmp1 asArray equals: #(2 3 4)rootDataSource  ^ownerDataSource isRoot ifTrue: [ ownerDataSource ] ifFalse: [ ownerDataSource parentItem rootDataSource ]isClassGroupSelected  ^self hasSelectedItemsopenInspector  actualVariable inspectlocalScopeClass  ^self classisClassSelected: arg1  ^self selection items anySatisfy: [:arg2 |  arg2 systemDefinition definingClass == arg1 ]isMenuItemMorph  ^truecleanCache  cache items: #()collectMetadataOf: arg1 by: arg2  arg2 collectMetadataOfClassGroups: arg1hash  ^definingClass hashhandlesMouseOver: arg1  ^truedecorateTableCell: arg1 of: arg2  testConvertingWithExtraBasisObject  | tmp1 |  scope := self singleScopeSample.  tmp1 := scope withExtraBasisObject: self extraBasisSample.  self assert: tmp1 class equals: scope class.  self assert: (tmp1 basisObjects includesAll: scope basisObjects).  self assert: (tmp1 basisObjects includes: self extraBasisSample).  self assert: tmp1 basisSize equals: scope basisSize + 1rebuildToolsForChangedEnvironment  tabManager updateToolsForChangedEnvironment.  self rebuildToolbarbrowser  ^browserviewStates  ^viewStatesname  ^actualVariable namecreateWindowGroupFrom: arg1  | tmp1 tmp2 tmp3 |  (arg1 ownerThatIsA: GroupWindowMorph) ifNotNil: [:arg2 |  ^arg2 ].  tmp2 := arg1 position.  tmp3 := arg1 extent.  tmp1 := ClyGroupWindowMorph new.  tmp1 addWindow: arg1.  (tmp1 openInWindowLabeled: arg1 label)     extent: tmp3;     position: tmp2.  ^tmp1fillWith: arg1  fillWith: arg1  items := arg1 collect: [:arg2 |  ClyBrowserItem named: arg2 printString with: arg2 ]buildGroupFor: arg1 depth: arg2 toShowMethodsFrom: arg3  | tmp1 tmp2 |  tmp1 := ClyInheritedMethodGroup withMethodsOf: arg1 toShowIn: arg3.  tmp2 := tmp1 asCalypsoBrowserItem.  tmp2 depth: arg2.  items add: tmp2selectedMessages  ^self selectedMethods collect: [:arg1 |  SycMessageDescription ofMethod: arg1 ]toggleExtendingPackage  extendingPackage ifNotNil: [ ^extendingPackage := nil ].  extendingPackage := browser searchDialog requestSingleObject: 'Choose package for method' from: ClyAllPackagesQuery sorteddescribes: arg1  ^arg1 isAboutBrowserItemType: itemTypechooseClassesForNewMethod  ^self classSelection actualObjects collect: [:arg1 |  metaLevelScope metaLevelOf: arg1 ]defaultMenuIconName  ^#smallUpdatecachedResultOf: arg1  ^queryCache at: arg1 ifAbsent: [ nil ]withInverseHierarchy  ^self copy hierarchy: hierarchy invertedbrowser  ^browserincludesMethodGroupsAffectedBy: arg1  self methodGroupProvidersDo: [:arg2 |  (arg2 providesGroupsAffectedBy: arg1 inScope: self) ifTrue: [ ^true ] ].  ^falsebrowseReferencesTo: arg1 from: arg2  | tmp1 |  arg1 isSymbol and: [ arg1 first isUppercase ifTrue: [ tmp1 := arg2 bindingOf: arg1.              tmp1 ifNotNil: [ ^self spawnQueryBrowserOn: (ClyClassReferencesQuery of: tmp1) ] ] ].  self browseSendersOf: arg1windowIsClosing  navigationViews do: [:arg1 |  arg1 windowIsClosing ].  tabManager windowIsClosing.  self window ifNotNil: [:arg2 |  arg2           removeMorph: self;           updatePanesFromSubmorphs;           model: nil ]testFillingWithEmptyList  queryResult fillWith: {}.  self assertItems: {ClyAllMethodGroup .         0}testBasedOnEmptyBasis  scope := self multipleScopeSample.  self deny: scope isBasedOnEmptyBasis.  scope := self singleScopeSample.  self deny: scope isBasedOnEmptyBasis.  scope := self emptyScopeSample.  self assert: scope isBasedOnEmptyBasisfilterInstalledMethods: arg1  ^arg1 collect: [:arg2 |  arg2 origin localMethodNamed: arg2 selector ifAbsent: [ nil ] ] thenReject: [:arg2 |  arg2 isNil or: [ arg2 package isNil or: [ arg2 isInstalled not ] ] ]changesAnnouncer  ^changesAnnouncerclear  commandBar removeAllMorphs.  contextBar removeAllMorphsdefaultMenuIconName  ^#glamorousBrowsenavigationHistory: arg1  navigationHistory := arg1= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^groupName = arg1 groupNamemessageText  ^messageText ifNil: [ messageText := self standardMessageText ]userRequestString  ^'Don''t remove, but show me those senders'dependsOnMethod: arg1  ^self includesMethod: arg1defaultIconName  ^nilcreateQuery  ^ClyFFIMethodQuery from: ClyClassScope of: Object in: environmenttestNotSelectsTaggedClass  self deny: (query selectsClass: ClyClass7WithTag1FromP5)setUp  super setUp.  result := SortedCollection sortBlock: #printString ascendinginitializeNavigationViews  packageView := self newPackageView.  classView := self newClassView.  methodGroupView := self newMethodGroupView.  methodView := self newMethodViewtestIsExecutedFromScopeOfBasisObject  self assert: (query isExecutedFromScopeOf: query scope basisObjects anyOne).  self deny: (query isExecutedFromScopeOf: #someObject)buildResult: arg1  | tmp1 tmp2 |  tmp2 := variableQuery execute items.  tmp1 := OrderedCollection new.  scope methodsDo: [:arg2 |  (self doesMethod: arg2 useAnyOf: tmp2) ifTrue: [ tmp1 add: arg2 ] ].  arg1 fillWith: tmp1createQuery  | tmp1 |  tmp1 := self methodWithCritiques critiques anyOne.  ^ClyConcreteGroupCritiqueQuery filter: ClyAllMethodCritiqueQuery new from: self scopeWithCritiques byGroup: tmp1 rule grouppackage: arg1  package := arg1includesClassNamed: arg1  ^globals includesKey: arg1decorateTool: arg1  plugins do: [:arg2 |  arg2 decorateTool: arg1 ]selectedProjectItems  ^tool projectSelection itemsupdateMethodTagsAndPackage  methodTags := editingMethod tags reject: [:arg1 |  arg1 beginsWith: '*' ].  extendingPackage := editingMethod isExtension ifTrue: [ editingMethod package ] ifFalse: [ nil ]scopeClass  ^ClySubclassScopeisInstanceSide: arg1  isInstanceSide := arg1testMethodsEnumerationWhenBasisIsTraitedClassClassSide  | tmp1 |  scope := ClyClassSideScope of: ClyClassWithTraits classSide.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClassWithTraits class methods reject: [:arg2 |  arg2 origin = TraitedClass ] thenCollect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArraydecorateTableCell: arg1 of: arg2  arg1 definitionIcon: ruleSeverity iconNametestClassNameFor: arg1  ^(arg1 name , 'Test') asSymbolprintExtraInfoOn: arg1  super printExtraInfoOn: arg1.  arg1 nextPutAll: self printVariablesconfirmUnusedVariables: arg1  ^tool confirmUnusedVariables: arg1testCheckIfEmpty  | tmp1 |  tmp1 := ClyPackageScope of: ClyClass7WithTag1FromP5 package in: environment.  query scope: tmp1.  self deny: query checkEmptyResult.  tmp1 := ClyPackageScope of: ClySubclassMOfClass1FromP2 package in: environment.  query scope: tmp1.  self assert: query checkEmptyResulttestConvertingToAnotherScopeClassShouldKeepName  | tmp1 |  scope := self createSampleScope.  scope name: 'test scope'.  tmp1 := scope asScope: ClyScopeExample.  self assert: tmp1 name equals: 'test scope'execute  classGroup renameClassTagTo: newNametestResult  ^self testResultOf: testItems firstitemsStartingWhere: arg1 count: arg2  actualResult protectItemsWhile: [ actualResult items doWithIndex: [:arg3 :arg4 |  (arg1 value: arg3 asCalypsoBrowserItem) ifTrue: [ ^self itemsStartingAt: arg4 count: arg2 ] ] ].  ^#()tool: arg1  super tool: arg1.  metaLevelScope := arg1 metaLevelScopemodifiesExtension  ^falsetestFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #sender1OfMessage1) .         (self class >> #senderOfMessage2)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #sender1OfMessage1snapshotState  ^ClyFullBrowserState of: selfremoveMethods: arg1  (ClyShowMessageSenderCommand forMethods: arg1 by: browser) executeisInSameStateAs: arg1  ^self isSameAs: arg1reference1OfVar1  ^referencedVar1activeScope  ^activeScopecreateFullUpdateOf: arg1  ^arg1 createUpdateWithItemsStartingAt: startPosition count: sizeLimitmethodsDo: arg1  basisObjects do: arg1execute  | tmp1 tmp2 |  tmp1 := self buildTestSuite.  tmp2 := tmp1 run.  tmp2 updateResultsInHistory.  self notifyUserAboutResults: tmp2 with: 'Tests complete'classSampleWhichHasGroup  ^ClyMethodCallCountersQueryTestdefiningClass  ^self definingClassItem actualObjectannouncerPlugin: arg1  announcerPlugin := arg1testHasAsyncResultbyDefault  self assert: query asyncResult class equals: ClyAsyncQueryResultextensionMethodFromSubclassL  testAdoptQuery  | tmp1 tmp2 |  scope := self createSampleScope.  tmp1 := ClyQueryExampleReturningScopeBasis new.  tmp2 := scope adoptQuery: tmp1.  self assert: tmp2 identicalTo: tmp1properties  ^propertiesisResult: arg1 affectedBy: arg2  ^arg2 affectsPackagestestCheckIfEmpty  query scope: (ClyClassScope of: ClyClass2FromP1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ProtoObject in: environment).  self assert: query checkEmptyResultfindItemsSimilarTo: arg1  | tmp1 tmp2 |  actualResult protectItemsWhile: [ tmp1 := arg1 as: OrderedCollection.        tmp2 := OrderedCollection new.        actualResult items do: [:arg2 |  tmp1 detect: [:arg3 |  arg3 isSimilarTo: arg2 ] ifFound: [:arg3 |  arg2 prepareIn: self environment.                    tmp2 add: arg2.                    tmp1 remove: arg3.                    tmp1 ifEmpty: [ ^tmp2 ] ] ].        ^tmp2 ]hierarchy  ^hierarchydefaultMenuItemName  ^'Run tests'projectClass  ^ClyManagedProjectisMethodTagSelected  self isMethodGroupSelected ifFalse: [ ^false ].  ^self selectedMethodGroupClass isBasedOnMethodTagtestFillingWithTwoSimilarCritiques  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := ClyClassWithProblemMethods >> #methodWithHalt.  tmp2 := ClyClassWithProblemMethods >> #methodWithHalt2.  tmp3 := tmp1 critiques anyOne.  queryResult fillWith: tmp1 critiques , tmp2 critiques.  self assert: queryResult size equals: 1.  tmp4 := queryResult items first.  self assert: tmp4 class equals: ClyConcreteCritiqueMethodGroup.  self assert: tmp4 name equals: tmp3 rule group asLowercase.  self assert: tmp4 ruleSeverity name equals: tmp3 rule severitytestCheckIfEmpty  | tmp1 |  tmp1 := ClyInstanceSideScope of: ClyClass1FromP1 in: environment.  query scope: tmp1.  self deny: query checkEmptyResultprintBasisObject: arg1 on: arg2  arg2 nextPutAll: arg1 namecheckEmptyResult  ^scope basisObjects isEmptytestPackageEnumeration  scope := ClyPackageScope ofAll: {Array package .         Object package}.  scope packagesDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: {Array package .         Object package}testMethodNameFor: arg1  ^arg1 selector asTestSelectordecorateTableCell: arg1 with: arg2  super decorateTableCell: arg1 with: arg2.  arg1 definitionIcon: #exceptionIconconfirmUnusedClasses: arg1  ^tool confirmUnusedClasses: arg1removeWithClasses  self classes do: [:arg1 |  arg1 removeFromSystem ]metaLevelOf: arg1  ^self class metaLevelOf: arg1fillWithVariables: arg1 type: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := self queryScope asLocalClassScope.  tmp1 := hierarchy buildFrom: arg1 keys.  tmp1 doInOrder: [:arg3 |  tmp2 := arg1 at: arg3.        tmp3 := ClyVarDefinitionMethodGroup withMethodsFrom: tmp5 referencedAny: arg2 definedIn: arg3.        items add: tmp3 asCalypsoBrowserItem.        tmp2 do: [:arg4 |  | tmp6 |              tmp6 := ClyVariableMethodGroup withMethodsFrom: tmp5 referencedVar: arg4.              tmp4 := tmp6 asCalypsoBrowserItem.              tmp4 depth: 1.              items add: tmp4 ] ]description  ^'references to ' , self printVariableshasBindingOf: arg1  ^self selectedClassOrMetaClass hasBindingOf: arg1doesMethod: arg1 useVar: arg2  ^arg2 isReadIn: arg1affectsMethodsDefinedInPackage: arg1  ^testCase package == arg1 or: [ arg1 extendsClass: testCase ]classAffected  ^overriddenSuperclassvisibleClassScope: arg1  visibleClassScope := arg1 asLocalClassScopeensureSystemDefinition: arg1  self getProperty: ClyItemDefinitionProperty ifAbsent: [ self addProperty: arg1 value ]initialize  super initialize.  isCaseSensitive := falsereference2OfVar1  referencedVar1 := #testValuewithScopeOf: arg1  | tmp1 |  tmp1 := subqueries collect: [:arg2 |  arg2 withScopeOf: arg1 ].  ^self withSubqueries: tmp1environment  ^environmentsubqueryFromScopeOf: arg1  ^self subqueryFromScope: ClyScopeExample of: arg1testDescending  function := ClySortMethodBySelectorFunction descending.  self assert: (function value: Object >> #size value: Object >> #printString).  self deny: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)isExtension: arg1  isExtension := arg1dependsOnMethod: arg1  self asyncQueryResult isBuilt ifFalse: [ ^true ].  ^super dependsOnMethod: arg1methodWithHalts1  self haltcreateQueryResult  ^(ClySubclassHierarchy inverse , ClyTraitUserHierarchy inverse) asQueryResult sortedBy: ClyTraitFirstSortFunction ascendingcreateToolFor: arg1 inContext: arg2  ^self toolClass for: arg1 inContext: arg2spawnQueryBrowserOn: arg1 withState: arg2  | tmp1 |  tmp1 := arg1 isBoundToEnvironment ifTrue: [ arg1 ] ifFalse: [ arg1 withScope: activeScope ].  super spawnQueryBrowserOn: tmp1 withState: arg2testNotSelectsNotOverrideMethod  self deny: (query selectsMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)isWrittenIn: arg1  (self isAccessibleFrom: arg1 origin) ifFalse: [ ^false ].  ^actualVariable isWrittenIn: arg1methodWithoutFlag  belongsToCurrentBrowserContext  ^(browser isClassSelected: editingClass) or: [ ^browser isClassSelected: editingClass instanceSide ]isAppliedToBrowser  ^(browser packageView showsItemsFromQuery: ClyAllPackagesQuery) and: [ browser isScopedModeEnabled ]selectedMethods  ^self actualSelectionFrom: self selectedMethodItemstestCheckIfEmpty  query scope: (ClyClassScope of: ClyAbstractSubclassExample in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ClyAbstractClassExample in: environment).  self assert: query checkEmptyResultextraBasisSample  ^#extraBasisasLocalClassScope  ^self asScope: localScopeClasstearDown  installedWatchpoint uninstall.  super tearDowntestComparison  self assert: ClyActiveBreakpointsQuery new equals: ClyActiveBreakpointsQuery new.  self assert: ClyActiveBreakpointsQuery newIncludingHaltsForTesting equals: ClyActiveBreakpointsQuery newIncludingHaltsForTesting.  self deny: ClyActiveBreakpointsQuery new equals: ClyActiveBreakpointsQuery newIncludingHaltsForTestingdecorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label clyAddEmphasis: TextEmphasis struckOutexpectedFlatQueryResult  ^expectedFlatQueryResulttestConvertingToInheritedScope  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asInheritedScope.  self assert: (tmp1 representsScope: ClySuperclassScope).  self assert: tmp1 localScopeClass equals: self scopeClass.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 environment equals: environment.  self assert: tmp1 name equals: ClyClassScope inheritedScopeNameisAppliedToBrowser  ^(browser packageView showsItemsFromQuery: ClyAllPackagesQuery) and: [ browser isScopedModeEnabled not ]initialize  super initialize.  allCount := 0.  successCount := 0.  failureCount := 0.  errorCount := 0totalItemCount: arg1  totalItemCount := arg1isBuilt  ^items notNiltestNotSelectsNotDeprecatedMethod  self deny: (query selectsMethod: ClyClassWithDeprecatedMethods >> #notDeprecatedMethod)testPluginsWithoutBrowser  browser addPlugin: ClyStandardBrowserPlugin new.  self snapshotState.  self assert: navigationState browserPlugins first browser isNildefaultClassScopeForMethods  | tmp1 |  tmp1 := self classSelection asItemsScope: metaLevelScope.  ^self extendClassScopeForMethods: tmp1testConvertingAsRestrictedByAnotherScope  | tmp1 tmp2 |  scope := self multipleScopeSample.  tmp2 := self singleScopeSample.  tmp1 := scope restrictedBy: tmp2.  self assert: tmp1 class equals: scope class.  self assert: tmp1 basisObjects equals: tmp2 basisObjectscollectMetadataOf: arg1 by: arg2  arg2 resolveMetadataOfCritiques: arg1createQueryResult  self subclassResponsibilityreferencesToIt  | tmp1 |  (tmp1 := self selectedSelector) == nil ifTrue: [ ^textArea flash ].  self referencesTo: tmp1testInstVarsEnumeration  scope := ClyClassScope of: ClyClass1FromP1.  scope instanceVariablesDo: [:arg1 |  result add: arg1 ].  self assert: (result as: Set) equals: {(ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)} asSetsetUpModelFromContext  super setUpModelFromContext.  editingPackage := context lastSelectedPackageenvironment  ^environmentlastSelectedMethodGroup  ^self lastSelectedObjectIn: self selectedMethodGroupsisMarkedWith: arg1  ^browserItem isMarkedWith: arg1decorateResultMethodEditor: arg1  isPrepared: arg1  isPrepared := arg1browserEnvironment  ^self browser navigationEnvironmentapplyDecorations  decorators do: [:arg1 |  arg1 decorateTool ]processFullClassChange: arg1  environment systemChanged: (ClyOverriddenSuperclassesChanged overridingSubclass: arg1 classAffected).  environment systemChanged: (ClyOverridingSubclassesChanged overriddenSuperclass: arg1 classAffected)testIsExecutedFromEmptyScope  self deny: query isExecutedFromEmptyScope.  query := self queryClass with: {(self subqueryFromScope: ClyScopeExample empty)}.  self assert: query isExecutedFromEmptyScopeattachToTextMorph  super attachToTextMorph.  wrapModeLabel := StringMorph new.  wrapModeLabel setBalloonText: 'Let you decide if the code pane should automaticaly wrap lines if a line reach the end of the line. W: Wrap / NW: Add a scrollbar.'.  wrapModeLabel on: #mouseDown send: #toggle to: self.  self updateLabel.  self addMorph: wrapModeLabeleditingMethod: arg1  editingMethod := arg1findItemsWith: arg1  ^cache findItemsWith: arg1 forAbsentDo: [ ^queryResult findItemsWith: arg1 ]checkPackageHasClassGroups: arg1  | tmp1 tmp2 |  tmp2 := ClyPackageScope of: arg1 in: environment.  environment pluginsDo: [:arg2 |  tmp1 := arg2 collectClassGroupProviders.        tmp1 do: [:arg3 |  arg3 classGroupsIn: tmp2 do: [:arg4 |  ^true ] ] ].  ^falseitemCursor  dirty ifTrue: [ self runUpdate ].  ^itemCursorexecutesQuery: arg1  ^falsefirstSelectedMethod  ^self firstSelectedObjectIn: self selectedMethodsnewClassView  ^self newNavigationView     displayMainColumnBy: [:arg1 :arg2 |  self specifyClassItemNameOn: arg1 label for: arg2 browserItem ];     enableFilter;     requestNavigationBy: #classSelectionChangedinitialize  super initialize.  providesMethodGroup := self class providesMethodGroupByDefaultrefactoringScopes  ^self browser allNavigationScopesruleSeverity: arg1  ruleSeverity := arg1testCreationUnifiedInstance  | tmp1 |  tmp1 := query asUnifiedInstance.  self assert: tmp1 class equals: query class.  self assert: tmp1 requiredResult equals: query requiredResult.  self assert: tmp1 scope equals: ClyUnknownScope instanceinitialize  super initialize.  accessGuard := Mutex new.  updateGuard := Mutex new.  plugins := OrderedCollection new.  queryCache := WeakValueDictionary new.  updateStrategy := ClyInstantEnvironmentUpdateStrategy newmethodsToImplementIn: arg1  | tmp1 tmp2 |  (self doesClassDefinedAsAbstract: arg1) ifTrue: [ ^#() ].  tmp1 := OrderedCollection new.  arg1 allSuperclassesDo: [:arg2 |  arg2 == Object ifTrue: [ ^tmp1 ].        self withAbstractMethodsOf: arg2 do: [:arg3 |  tmp2 := arg1 lookupSelector: arg3 selector.              tmp2 == arg3 ifTrue: [ tmp1 add: tmp2 ] ] ].  ^tmp1fillContextMenu: arg1 using: arg2  | tmp1 tmp2 |  browser allNavigationScopes do: [:arg3 |  tmp1 := self class toScope: arg3 in: browser.        tmp2 := arg2 newForCommand: tmp1.        arg1 add: tmp2 menuItemName target: tmp2 selector: #executeCommand ]tearDown  installedCounters do: [:arg1 |  arg1 uninstall ].  installedCounters removeAll.  super tearDownsnapshotState  ^ClyBrowserState of: selfclassSelection  ^classView selectionconfirmUnusedClasses: arg1  ^self browser confirmUnusedClasses: arg1includesActualObject: arg1  ^self actualObject == arg1isInSameStateAs: arg1  (super isInSameStateAs: arg1) ifFalse: [ ^false ].  expandedItems size = arg1 expandedItems size ifFalse: [ ^false ].  ^expandedItems allSatisfy: [:arg2 |  arg1 expandedItems detect: [:arg3 |  arg2 isSameAs: arg3 ] ifFound: [:arg3 |  arg2 childrenDataSource isInSameStateAs: arg3 childrenDataSource ] ifNone: [ false ] ]hasMetaProperty: arg1  ^falsemethod1  withNewBasisObjects: arg1  ^selftargetClass: arg1  targetClass := arg1initialize  super initialize.  localScopeClass := ClyClassScopetotalItemCount  ^totalItemCountrunUpdateFor: arg1  UIManager default defer: [ arg1 do: [:arg2 |  arg2 runUpdate ] ]build  self subclassResponsibilitychooseClassesForNewMethod: arg1  ^{arg1 origin}testCheckIfEmpty  query scope: (ClyClassScope of: ClyClass1FromP1 in: environment).  self deny: query checkEmptyResultanalyzedObject: arg1  analyzedObject := arg1supportsQuery: arg1  ^arg1 isKindOf: ClyTypedQuerytestFillingWithSingleInstVar  | tmp1 tmp2 |  queryResult fillWith: {(ClyInstanceVariable named: #instVar definedIn: ClyClass2FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  tmp1 := items last actualObject.  self assert: tmp1 methodQuery class equals: ClyVariableReferencesQuery.  self assert: tmp1 methodQuery variableQuery resultItems equals: {(ClyInstanceVariable named: #instVar definedIn: ClyClass2FromP1)}.  tmp2 := items second actualObject.  self assert: tmp2 methodQuery class equals: ClyVariableReferencesQuery.  self assert: tmp2 methodQuery variableQuery class equals: ClyAllInstanceVariablesQueryoverriddenMethod  ^#newValuenewWindowTitle  self subclassResponsibilityactivate  actionBlock valuetestFromThreeClasses  query tag: #Tag1.  self queryFromScope: ClyClassScope ofAll: {ClyClass6UntaggedFromP5 .         ClyClass7WithTag1FromP5 .         ClyClass8WithTag2FromP5}.  self assert: resultItems asArray equals: {ClyClass7WithTag1FromP5}forceFullUpdate  queryResult forceRebuildclyMessageImplementor1  testCreatesBrowserWithNavigationEnvironment  self restoreBrowserInstance.  self assert: browser navigationEnvironment equals: environmenthash  ^super hash bitXor: itemFilter hashwithCachedQueriesDo: arg1  queryCache select: [:arg2 |  arg2 notNil ] thenDo: arg1testFromThreeClasses  self queryFromScope: ClyClassScope ofAll: {ClyClass7WithTag1FromP5 .         ClyClass6UntaggedFromP5 .         ClyClass1FromP1}.  self assert: resultItems asSet equals: {ClyClass6UntaggedFromP5 .         ClyClass1FromP1} asSetdefaultMenuItemName  ^'New trait'browser: arg1  browser := arg1decorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color red.  arg1 definitionIcon: #smallDebugactiveScope  ^activeScope ifNil: [ activeScope := self systemScope ]testAscendingSamePackageDifferentClass  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: True >> #not value: Object >> #printString).  self assert: (function value: Object >> #printString value: True >> #not)decorateTableCell: arg1 of: arg2  self isEditableGroup ifFalse: [ arg1 label color: arg1 theme calypsoFrozenItemColor ]fillWith: arg1  items addAll: arg1testClosing  cursor close.  self deny: (queryResult hasSubscriber: itemObserver)printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  activator printOn: arg1.  arg1 nextPut: $)order  ^10100packageSampleWhichHasGroup  ^ClyClass6UntaggedFromP5 packageisTabSelected  ^containerTab selecteddefaultMenuItemName  ^'Jump to test method'analyzedObject  ^tool analyzedObjectname: arg1  name := arg1testConvertingToSemiAsyncQuery  | tmp1 |  tmp1 := query semiAsync.  self assert: tmp1 asyncResult class equals: ClySemiAsyncQueryResult.  self deny: tmp1 identicalTo: query.  self assert: tmp1 class equals: query class.  self assert: tmp1 requiredResult identicalTo: query requiredResult.  self assert: tmp1 scope identicalTo: query scopeselectsClass: arg1  ^arg1 isTaggedWith: tagbuildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope instanceVariablesDo: [:arg2 |  tmp1 add: arg2 ].  arg1 fillWith: tmp1method2  testMethodsEnumerationWhenBasisIsMetaclass  scope := ClyBothMetaLevelClassScope of: ClyClass1FromP1 classSide.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyClass1FromP1 localMethods).  self assert: (result includesAll: ClyClass1FromP1 classSide localMethods)execute  ^browser packageSelection actualObjects ifNotEmpty: [:arg1 |  browser switchToPackageScopeOf: arg1 ]generateTestMethodNamed: arg1 in: arg2  | tmp1 |  tmp1 := '{1}	self flag: #toImplement.	self assert: false' format: {arg1}.  arg2 compile: tmp1 classified: 'test'printBasisObject: arg1 on: arg2  arg2 nextPutAll: arg1 namedefaultMenuItemName  ^'Browse breakpoints'defaultNavigationScope  ^self activeScopeaffectsPackages  ^falseapplyTo: arg1  | tmp1 |  (arg1 dataSource isInSameStateAs: dataSource) ifFalse: [ tmp1 := dataSource copyForBrowserStateSnapshot.        arg1 dataSource: tmp1 ].  selection restoreCurrentSelection: arg1 selection.  arg1 selection ensureVisibleLastItemaccumulateTestCase: arg1  allCount := allCount + arg1 allTestSelectors size.  successCount := successCount + (arg1 history at: #passed) size.  failureCount := failureCount + (arg1 history at: #failures) size.  errorCount := errorCount + (arg1 history at: #errors) sizerestoreBrowserState  self browser selectClass: self lastSelectedClasstestCheckIfEmpty  self installBreakpointInto: ClyClassWithBreakpoints >> #methodWithBreakpoints.  query scope: (ClyMethodScope of: ClyClassWithHalts >> #methodWithHalts1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithBreakpoints in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResulttestConvertingWithNewRequiredResult  | tmp1 tmp2 |  tmp1 := ClyRawQueryResult new.  tmp2 := query withResult: tmp1.  self assert: tmp2 class equals: query class.  self assert: tmp2 scope equals: query scope.  self assert: tmp2 requiredResult identicalTo: tmp1createIcon  allCount = 0 ifTrue: [ ^self iconNamed: #testNotRunIcon ].  allCount = successCount ifTrue: [ ^self iconNamed: #testGreenIcon ].  errorCount = 0 & (failureCount > 0) ifTrue: [ ^self iconNamed: #testYellowIcon ].  errorCount > 0 ifTrue: [ ^self iconNamed: #testRedIcon ].  ^self iconNamed: #testNotRunIconshowsFullClassHierarchy  ^classView showsItemsFromScope: ClySuperclassScopetestConvertingToIncreasedScopeByExtraClassScope  | tmp1 tmp2 |  scope := self singleScopeSample.  tmp2 := ClySuperclassScope of: self class in: environment.  tmp1 := scope increasedByClassesFrom: tmp2.  self assert: tmp1 class equals: scope class.  self assert: tmp1 basisObjects equals: scope basisObjects , self class allSuperclassesdoesMethodHasExecutionCounter: arg1  ^self doesAnyManager: ExecutionCounter allCounters belongsTo: arg1hash  ^super hash bitXor: pattern hashbuildCommandBar  commandBar := Morph new     setNameTo: 'command bar';     changeTableLayout;     listDirection: #rightToLeft;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     cellInset: 4 @ 0;     color: Color transparent;     height: 0;     minHeight: 0.  self addMorphBack: commandBarnewWindowTitle  | tmp1 |  tmp1 := systemQuery description.  resultView areItemsLoaded ifTrue: [ tmp1 := tmp1 capitalized , ' [' , self itemCount asString , ']' ] ifFalse: [ tmp1 := 'Loading: ' , tmp1 ].  self systemScope isCurrentImage ifFalse: [ tmp1 := tmp1 , ' in ' , self systemScope description ].  ^tmp1handlesAnnouncement: arg1  ^arg1 affectsClass: affectedClasstestConvertingToInterestingClassScopeShouldKeepScopeName  | tmp1 |  scope := ClyCompositeScope on: {(ClySuperclassScope of: String) .         (ClySubclassScope of: Array)}.  scope name: 'test scope'.  tmp1 := scope asInterestingClassScope.  self assert: tmp1 name equals: 'test scope'selectedMethodGroupClass  ^(self lastSelectedObjectIn: self selectedMethodGroupItems) typeselectedPackages  ^self actualSelectionFrom: self selectedPackageItemsensureSelectedItem  | tmp1 |  self selection isEmpty ifFalse: [ ^self ].  self dataSource isEmpty ifTrue: [ ^self ].  tmp1 := 1.  (desiredSelection notNil and: [ desiredSelection isEmpty not ]) ifTrue: [ tmp1 := desiredSelection lastSelectedItem globalPosition min: self dataSource numberOfRows ].  self selection selectItems: {(self dataSource elementAt: tmp1)}.  self ensureVisibleSelectiontestComparisonWithSortedResultBasedOnAnotherFunction  | tmp1 |  tmp1 := ClySortedQueryResult using: #someAspect ascending.  self deny: queryResult equals: tmp1renameMethodTagTo: arg1  self methods do: [:arg2 |  arg2 tagWith: arg1 ]testResult  ^methodDataSource getMetaProperty: ClyTestResultPropertyextendingPackage: arg1  extendingPackage := arg1.  methodTags := #()testMethodsEnumerationWhenBasisIsMetaclass  | tmp1 |  scope := ClyClassSideScope of: ClyClass1FromP1 classSide.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClass1FromP1 classSide localMethods collect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArrayexcludesHaltsForTesting  ^excludesHaltsForTestinginitialize  super initialize.  hierarchy := ClySubclassHierarchy newswitchToMethod: arg1  browser selectMethod: arg1.  self removeFromBrowseritems  ^itemsunsubscribe: arg1  changesAnnouncer unsubscribe: arg1definesChildren  ^queryView definesTreetestSelectsOverrideMethod  self assert: (query selectsMethod: ClyClassWhichInheritsAbstractClass >> #overriddenMethod)fillStatusBar  super fillStatusBar.  statusBar addCommandItem: (ClySlotClassDefinitionSwitchMorph for: self)includesMethod: arg1  ^self methodQuery retrievesItem: arg1isAppliedToBrowser  ^browser methodGroupView showsItemsOfType: self methodGroupTypetestSelectsMethodWithCritiquesWhenTheyExistAndComputedInAdvance  | tmp1 |  tmp1 := query critiqueQuery async execute.  [ tmp1 isBuilt ] whileFalse: [ 30 milliSeconds wait ].  self assert: (query selectsMethod: ClyClassWithProblemMethods >> #methodWithHalt)notOverriddenMethod  isSimilarTo: arg1  (super isSimilarTo: arg1) ifFalse: [ ^false ].  ^{leftMethod .   rightMethod} asIdentitySet = {arg1 leftMethod .         arg1 rightMethod} asIdentitySetsetUpAvailablePlugins  ClyBrowserPlugin allSubclasses select: [:arg1 |  arg1 isAutoActivated ] thenDo: [:arg1 |  self addPlugin: arg1 new ]defaultMenuItemName  ^'Implementors'subscribe: arg1 for: arg2  self when: arg2 send: #systemChanged: to: arg1testCreationByComma  | tmp1 tmp2 |  tmp1 := ClyScopeExample of: #basisObject1 in: environment.  tmp2 := ClyScopeExample2 of: #basisObject2 in: environment.  scope := tmp1 , tmp2.  self assert: scope class equals: ClyCompositeScope.  self assert: scope basisObjects equals: #(basisObject1 basisObject2) asSet.  self assert: scope subscopes asSet equals: {tmp1 .         tmp2} asSet.  self assert: scope environment equals: environmenttargetClass  ^targetClassclassAffected  ^overridingSubclassdefaultTitle  ^context hasSelectedItems ifTrue: [ context lastSelectedItem name ] ifFalse: [ self class name ]checkEmptyResult  | tmp1 |  tmp1 := self execute.  tmp1 isBuilt ifTrue: [ ^tmp1 isEmpty ].  ^falseopenBrowser  actualVariable value browsecollectMethodGroupProviders  ^{ClyDeprecatedMethodGroupProvider new}testConvertingToNewMetaLevel  | tmp1 |  tmp1 := query withMetaLevelScope: ClyInstanceSideScope.  self assert: tmp1 class equals: query class.  self assert: tmp1 scope class equals: ClyInstanceSideScope.  self assert: tmp1 scope basisObjects equals: query scope basisObjectstestClassEnumerationShouldStopAtObject  scope := ClyInterestingSuperclassScope of: ClySubclassN1OfClass1FromP1.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asArray equals: {ClyClass1FromP1}testClassEnumerationWhenObjectIsFirstSuperclass  scope := ClyInterestingSuperclassScope of: ClyClass1FromP1.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result isEmptysystemChanged: arg1  environment systemChanged: arg1prepareFullExecutionInContext: arg1  super prepareFullExecutionInContext: arg1.  browser := arg1 browsertakeKeyboardFocus  textMorph ifNotNil: [ textMorph takeKeyboardFocus ]visibilityLevel: arg1  visibilityLevel := arg1defaultTitle  ^'New class'requestMultipleObjects: arg1 from: arg2 inScope: arg3  arg3 bindTo: browser navigationEnvironment.  ^self requestMultipleObjects: arg1 from: (arg3 adoptQuery: arg2)execute  browser spawnFullBrowserfixStateBeforeExecution  self prepareStateBeforeExecution.  self shouldBeProtectedByWriteBarrier ifFalse: [ ^self ].  self beReadOnlyObject.  scope beReadOnlyObjectcollate: arg1 with: arg2  arg1 isTrait & arg2 isTrait not ifTrue: [ ^-1 ].  arg1 isTrait not & arg2 isTrait ifTrue: [ ^1 ].  ^arg1 name threeWayCompareTo: arg2 namesizeLimit  ^sizeLimittestFillingWithTwoClassWhichInheriteSameTraitsAndTheirSuperclasses  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits .         Object .         ProtoObject}.  self assertItems: {ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot2 .         3 .         ClyTraitRoot2 .         2 .         Object .         2 .         ProtoObject .         3}createRefactoring: arg1 for: arg2  ^arg1 classVariableAnalog variable: actualVariable name class: arg2sortedBy: arg1  ^self copy sortFunction: arg1isForScripting: arg1  isForScripting := arg1selectItemsWith: arg1  | tmp1 |  tmp1 := rootDataSource queryView findItemsWith: arg1.  self selectItems: tmp1nextItem  self moveToNext.  ^self currentItemcacheMethod: arg1  | tmp1 |  tmp1 := self implementorsOf: arg1.  tmp1 add: arg1 methodClasstestConvertingToAsyncQuery  self assert: query async identicalTo: querynewTestedObject  ^self classUnderTest newgetProperty: arg1 ifAbsent: arg2  ^browserItem getProperty: arg1 ifAbsent: arg2classGroup: arg1  classGroup := arg1expand  self isExpanded ifTrue: [ ^self ].  ownerDataSource expand: selfcreateQuery  ^ClyOverriddenMethodsQuery from: ClyClassScope of: ClyAbstractClassExample in: environmentnavigateBack  navigationHistory undoNavigationOf: selfcollectMetadataOfMethodGroups: arg1  adoptForBrowser  ^ClyQueryResultBrowserAdapter for: selfdefaultMenuItemName  ^'Scoped View'scopeClass  ^ClyInterestingSuperclassScopeisQueryScopeDefinesClass: arg1  | tmp1 |  tmp1 := arg1 package.  buildingQuery scope packagesDo: [:arg2 |  (arg2 isAboutPackage: tmp1) ifTrue: [ ^true ] ].  ^falseisSimilarTo: arg1  (super isSimilarTo: arg1) ifFalse: [ ^false ].  ^editingMethod == arg1 editingMethod or: [ editingMethod selector == arg1 editingMethod selector and: [ editingMethod origin == arg1 editingMethod origin ] ]decorateBrowserItem: arg1 ofMethodGroup: arg2  arg2 decorateOwnBrowserItem: arg1collectMetadataOf: arg1 by: arg2  classGroup  ^classGrouptestIsEmptyWhenAllSubqueriesAreEmpty  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self assert: query checkEmptyResultselectedCritique  ^self lastSelectedItem actualObjectsnapshotState  ^ClyQueryBrowserState of: selfprintContext  ^'left / ' , leftMethod printSystemPath , ' vs right / ' , rightMethod printSystemPathapplyBreakpointCondition: arg1  arg1 condition: conditionBlocksender2OfMessage1  self clyReferencedMessage1asUnifiedInstance  ^self copy resetScopedecorateMethodEditor: arg1  testCreationUnifiedInstanceWhenThereIsExtraScopeParameter  | tmp1 |  scope := self multipleScopeSample.  scope extraParameter: #testParameter.  tmp1 := scope asUnifiedInstance.  self assert: tmp1 extraParameter equals: #testParametersetNewMethodTags: arg1  | tmp1 |  tmp1 := (',' split: arg1) collect: #trimBoth as: Array.  ownerTool methodTags: (tmp1 reject: #isEmpty)actualObject  ^item actualObjecttestProcessingQueryCacheWhenSomeWasCollectedAsGarbage  | tmp1 |  environment query: (self createQueryFromScopeOf: self class).  Smalltalk     garbageCollectMost;     garbageCollectMost.  tmp1 := false.  environment withCachedQueriesDo: [:arg1 |  tmp1 := true ].  self deny: tmp1includesItemAt: arg1  ^arg1 between: startPosition and: startPosition + items size - 1methodEditor  ^methodEditorasString  ^block valuesetUp  super setUp.  installedWatchpoints := OrderedCollection newtestConvertingWithNewScope  | tmp1 tmp2 |  tmp1 := ClyScopeExample2 of: #someBasis in: environment.  tmp2 := query withScope: tmp1.  self assert: tmp2 class equals: query class.  self assert: tmp2 scope equals: tmp1cacheAllImplementors  cacheGuard critical: [ allImplementorsCache := IdentityDictionary new: Symbol selectorTable size.        environment systemScope methodsDo: [:arg1 |  self cacheMethod: arg1 ] ]createMethodQueryFrom: arg1  ^ClyOverriddenMethodsQuery from: arg1systemQuery: arg1  systemQuery := arg1execute  | tmp1 |  tmp1 := messages collect: [:arg1 |  arg1 selector ].  browser spawnQueryBrowserOn: (ClyMessageImplementorsQuery ofAny: tmp1)execute  ^browser switchToPackagestestExecution  self executeQuery.  self assert: resultItems size equals: 1testConvertingWithNewScopeWhenThereIsExtraQueryParameter  | tmp1 tmp2 |  query extraParameter: #testParameter.  tmp1 := ClyScopeExample2 of: #someBasis in: environment.  tmp2 := query withScope: tmp1.  self assert: tmp2 extraParameter equals: #testParameterisImplementedByClass: arg1  ^arg1 instanceSide respondsTo: self implementorSelectormethodsDo: arg1  self subclassResponsibilityisClassVariable  ^falsedoesItemHaveChildren: arg1  | tmp1 |  tmp1 := arg1 browserItem.  ^tmp1 localHierarchySize > 0prepareNewFor: arg1 in: arg2  ^self copy     environment: arg2;     buildingQuery: arg1;     beProtectedallContextsDo: arg1  self navigationContextsDo: arg1.  tabManager tools select: [:arg2 |  arg2 isKindOf: ClyTextEditorToolMorph ] thenDo: [:arg2 |  arg1 value: arg2 createTextContext ]tableCellIcon  ^Smalltalk ui iconNamed: #classIconpackageOrganizer  ^packageOrganizeropenBrowserCursorFor: arg1  ^self execute openBrowserCursorFor: arg1highlightItemsWhich: arg1  highlighting selectItemsWhere: arg1hasChildrenWhich: arg1  ^properties anySatisfy: [:arg2 |  (arg2 isKindOf: ClyItemChildrenTag) and: [ arg1 value: arg2 childrenType ] ]testConvertingWithNewScopeBasis  | tmp1 |  tmp1 := query withScopeOf: #(newBasis).  self assert: tmp1 class equals: query class.  self assert: tmp1 scope class equals: query scope class.  self assert: tmp1 scope basisObjects equals: #(newBasis) asSetdisableSlowPlugins  plugins removeAllSuchThat: [:arg1 |  arg1 isSlow ]wantsTextStyling  ^truepackageSelectionChanged  self switchToFlatClassesselectsMethod: arg1  ^pattern matches: arg1 sourceCodeisPackageSelected  ^self hasSelectedItemsselectsClass: arg1  ^arg1 tags isEmptyinitialize  super initialize.  self setBalloonText: 'Current line number/Total line number [Current character number]'.  labelMorph := '' asStringMorph.  self addMorph: labelMorphtestMethodGroupsEnumeration  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new.  scope := ClyClassScope of: ClyClass1FromP1 in: environment.  scope methodGroupsDo: [:arg1 |  result add: arg1 ].  self assert: (result collect: #class as: Set) equals: {ClyAllMethodGroup .         ClyTaggedMethodGroup} asSet.  self assert: (result select: [:arg1 |  arg1 class = ClyTaggedMethodGroup ] thenCollect: #tag) sorted asArray equals: ClyClass1FromP1 tagsForMethods sorted asArraytestFillingWithEmptyList  queryResult fillWith: #().  self assert: queryResult size equals: 0moveToItemWhich: arg1  | tmp1 |  cache findItemWhich: arg1 ifExists: [:arg2 |  position := arg2 position.        ^true ].  tmp1 := cache loadItemsOf: queryResult startingWhere: arg1.  tmp1 ifFalse: [ ^false ].  position := cache startPosition.  ^truegenerateTestMethodFor: arg1  [ | tmp1 tmp2 |  tmp1 := self testClassFor: arg1 methodClass.  tmp2 := self testMethodNameFor: arg1.  (tmp1 includesSelector: tmp2) ifFalse: [ self generateTestMethodNamed: tmp2 in: tmp1 ].  testMethodToBrowse := tmp1 >> tmp2 ] on: ClyInvalidClassForTestClassGeneration do: [:arg2 |  self inform: 'Impossible to create test class for ' , arg2 baseClass printString , '.' ]defaultIconName  ^#addincludesClassesAffectedBy: arg1  ^basisObjects anySatisfy: [:arg2 |  arg2 includesClassesAffectedBy: arg1 ]selectsCritique: arg1  self subclassResponsibilitydescription  ^'ffi calls'decorateBrowserItem: arg1 ofObject: arg2  visibilityLevels  ^visibilityLevelssimpleNameForSpotterMenu  ^tool simpleNameForSpotterMenucanAffectResultOfMethodQuery: arg1  ^truecreateMethodQueryFrom: arg1  ^ClyExpectedFailedTestMethodsQuery from: arg1selectedVariable  ^self selectedSourceNode binding asCalypsoVariableOf: tool editingClasstestCheckIfEmpty  query scope: (ClyClassScope of: self class in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: self class superclass in: environment).  self assert: query checkEmptyResultdefiningClass: arg1  definingClass := arg1tag  ^classQuery tagcreateQueryResult  ^ClyGroupedCritiqueResult newupdateExpandingItems  self updateItems: expandedItems.  expandedItems := expandedItems reject: [:arg1 |  arg1 isRemoved ]textMorph  ^textMorphprintFullNameOf: arg1  ^arg1 name , ' (' , self printDefinition , ')'= arg1  self == arg1 ifTrue: [ ^true ].  super = arg1 ifFalse: [ ^false ].  ^itemFilter = arg1 itemFilterdecorateResultMethodEditor: arg1  arg1 selectAnySelector: #(flag:)buildWith: arg1  needsRebuild := false.  self initializeItems.  self fillWith: arg1updateItemsWhichBelongsTo: arg1  | tmp1 tmp2 |  tmp1 := items select: [:arg2 |  arg2 belongsToDataSource: arg1 ].  arg1 updateItems: tmp1.  tmp2 := tmp1 anySatisfy: #isRemoved.  self restoreTableSelectionSilently: tmp2 not.  ^tmp2projectManagers  ^projectManagersextraParameter  ^extraParameteractualObject  ^browserItem ifNotNil: [ browserItem actualObject ]hasPlugin: arg1  ^self hasPluginOf: arg1 classdecorateItemGroup: arg1  | tmp1 |  super decorateItemGroup: arg1.  tmp1 := ClyTestResultProperty new.  scope classesDo: [:arg2 |  | tmp2 tmp3 |        (arg2 isTestCase and: [ arg2 isAbstract not ]) ifTrue: [ tmp2 := (arg2 history at: #failures) size.              tmp3 := (arg2 history at: #errors) size.              tmp1 accumulateFailures: tmp2 andErrors: tmp3 ] ].  arg1 addProperty: tmp1decorateItemGroup: arg1  subqueries do: [:arg2 |  arg2 decorateItemGroup: arg1 ]addPlugin: arg1  plugins detect: [:arg2 |  arg2 class = arg1 class ] ifFound: [ ^self ].  arg1 environment: self.  plugins add: arg1testConvertingWithNewCompositeScope  | tmp1 tmp2 |  tmp1 := ClyCompositeScope on: {(ClyScopeExample of: #someBasis1 in: environment) .         (ClyScopeExample2 of: #someBasis2 in: environment)}.  tmp2 := query withScope: tmp1.  self assert: tmp2 class equals: ClyUnionQuery.  self assert: (tmp2 subqueries collect: #class as: Set) equals: {query class} asSet.  self assert: (tmp2 subqueries collect: #scope as: Set) equals: tmp1 subscopes asSetselectedMethodGroupItems  ^selectedItemsisBasedOnItemType: arg1  ^browserItem representsItemOfType: arg1subqueryFromScope: arg1  arg1 bindTo: environment.  ^ClyQueryExampleReturningScopeBasis from: arg1attachToSystem  browser system when: (ClyMethodChange ofAll: {self leftMethod .               self rightMethod}) send: #triggerUpdate to: selfexecuteOn: arg1  (super executeOn: arg1) inspecttestCreationHierarchicalInstance  queryResult := ClyExtensionLastSortedClasses hierarchical.  self assert: queryResult baseQueryResult class equals: ClyHierarchicallySortedClassesdefaultMenuItemName  ^'go forward'testClassEnumerationOverMetaclassWhenBothMetaLevelsAreLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {Object .         Object class .         ProtoObject .         ProtoObject class} asSetdescription  ^'Open dependency analyzer'setUpSelectedRows: arg1 in: arg2 silently: arg3  arg3 ifTrue: [ arg2 basicHighlightIndexes: arg1 ] ifFalse: [ arg2 basicHighlightIndexes: #(-1000).        arg2 highlightIndexes: arg1 ]installWatchpointInto: arg1  | tmp1 |  tmp1 := Watchpoint in: (self class >> arg1) ast sendNodes last.  installedWatchpoints add: tmp1.  ^tmp1definingPackage  ^self definingPackageItem actualObjectwithMetaLevel: arg1  ^self asScope: arg1mouseLeave: arg1  super mouseLeave: arg1.  self currentHand showTemporaryCursor: nilchildrenOf: arg1  ^parentMap at: arg1 ifAbsent: [ #() ]implementorsOf: arg1  allImplementorsCache ifNil: [ self cacheAllImplementors ].  ^allImplementorsCache at: arg1 selector ifAbsentPut: [ WeakOrderedCollection new ]printDescriptionOn: arg1  arg1 nextPutAll: self name.  arg1 nextPutAll: ': '.  self printBasisOn: arg1open  | tmp1 |  self ensureInitialState.  tmp1 := self openInWindow.  tmp1 model: self.  self updateWindowTitle