basisObjects: arg1  basisObjects := arg1 asSet-=JUAMPI=-isImplementedByClass: arg1  ^arg1 instanceSide includesBehavior: self implementorClass instanceSide-=JUAMPI=-testComparisonWithAnotherKindOfResult  self deny: queryResult equals: ClyQueryResult new-=JUAMPI=-selectsMethod: arg1  ^arg1 isExtension and: [ arg1 package = package ]-=JUAMPI=-ownerTool: arg1  ownerTool := arg1.  self build-=JUAMPI=-initialize  super initialize.  projectManagers := OrderedCollection new-=JUAMPI=-testHasEmptyBasisObjects  scope := self createSampleScope.  self assert: scope basisObjects isEmpty-=JUAMPI=-specialSelectorIndexes  ^specialSelectorIndexes ifNil: [ specialSelectorIndexes := selectors collect: [:arg1 |  Smalltalk specialSelectorIndexOrNil: arg1 ] ]-=JUAMPI=-isSlow  ^false-=JUAMPI=-focusActiveTab  tabManager focusActiveTab-=JUAMPI=-testCaseResults: arg1  testCaseResults := arg1-=JUAMPI=-allNavigationScopes  | tmp1 |  tmp1 := self classSelection asItemsScope: ClyBothMetaLevelClassScope.  ^super allNavigationScopes , {(self packageSelection asItemsScope: ClyPackageScope) .         tmp1 asFullHierarchyScope .         tmp1}-=JUAMPI=-itemsStartingAt: arg1 count: arg2  ^#()-=JUAMPI=-isAffectedByChangedMethod: arg1  ^self selectsMethod: arg1-=JUAMPI=-buildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope methodsDo: [:arg2 |  (self selectsMethod: arg2) ifTrue: [ tmp1 add: arg2 ] ].  arg1 fillWith: tmp1-=JUAMPI=-rebuildIfNeeded  self protectAccessWhile: [ needsRebuild ifTrue: [ needsRebuild := false.              self rebuild ] ]-=JUAMPI=-createQuery  ^ClyDeprecatedMethodsQuery from: ClyClassScope of: Object in: environment-=JUAMPI=-testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self deny: query checkEmptyResult-=JUAMPI=-changeStateOf: arg1 by: arg2  | tmp1 |  self changeStateBy: [ arg2 value.        arg1 changesWasInitiatedByUser ifTrue: [ tmp1 := OrderedCollection new.              tabManager buildToolsOn: tmp1 for: arg1 createSelectionContext.              tabManager desiredSelection: (tmp1 collect: #class) ] ]-=JUAMPI=-withResult: arg1  | tmp1 |  tmp1 := self copy.  tmp1 requiredResult: arg1.  ^tmp1-=JUAMPI=-packagesDo: arg1  basisObjects do: arg1-=JUAMPI=-execute  browser switchScopeTo: queryScope-=JUAMPI=-update  | tmp1 tmp2 |  super update.  tmp2 := self editingText.  self pendingText asString = tmp2 ifTrue: [ self applyDecorations.        ^self ].  self hasUnacceptedEdits ifTrue: [ tmp1 := self pendingText copy ].  textModel setInitialText: tmp2.  tmp1 ifNil: [ ^self textUpdated ].  self pendingText: tmp1.  textMorph hasEditingConflicts: true.  textMorph changed-=JUAMPI=-environment  ^environment-=JUAMPI=-defaultMenuItemName  self hasTestResult ifFalse: [ ^'Run failed' ].  ^'Run failed (' , self testResult brokenCount asString , ')'-=JUAMPI=-findItemsWith: arg1  | tmp1 |  self protectItemsWhile: [ tmp1 := arg1 collect: [:arg2 |  items detect: [:arg3 |  arg3 representsObjectEqualTo: arg2 ] ifNone: nil ].        tmp1 select: #notNil thenDo: [:arg4 |  arg4 prepareIn: environment ].        ^tmp1 ]-=JUAMPI=-metalinkManagerClass  ^ExecutionCounter-=JUAMPI=-dataSource: arg1  dataSource := arg1-=JUAMPI=-scopeClass  ^ClySuperclassScope-=JUAMPI=-selectedMethodItems  ^self selectedItemsOfType: ClyMethod-=JUAMPI=-icon  ^icon-=JUAMPI=-prepareNewResult  ^asyncResult prepareNewFor: self actualQuery in: self environment-=JUAMPI=-extensionMethodFromRoot1Trait  -=JUAMPI=-setUp  super setUp.  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new-=JUAMPI=-findItemsSameAsFilter  | tmp1 |  tmp1 := table filterString asLowercase.  ^self dataSource findItemsWhere: [:arg1 |  arg1 name asLowercase = tmp1 ]-=JUAMPI=-forceRebuild  self forceLazyRebuild.  self notifyObservers-=JUAMPI=-browserTool: arg1  browserTool := arg1-=JUAMPI=-rawItemsDo: arg1  actualResult rawItemsDo: arg1-=JUAMPI=-decorateBrowserItem: arg1 ofMethod: arg2  arg2 usesUndeclares ifTrue: [ arg1 markWith: ClyUndeclaresUserTag ]-=JUAMPI=-testComparison  self assert: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring').  self assert: (ClyMethodSourcesQuery withString: 'test substring') hash equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring') hash.  self deny: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'another substring')-=JUAMPI=-testConvertingToInheritingScopeShouldAddTraitUsers  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asInheritingScope.  self assert: (tmp1 representsScope: ClyTraitUserScope)-=JUAMPI=-showsFlatResult  ^(systemQuery retrievesItemsAs: ClyHierarchicalSystemItems) not-=JUAMPI=-multipleScopeSample  | tmp1 |  tmp1 := super multipleScopeSample.  tmp1 relationScopeClasses: {ClySuperclassScope}.  ^tmp1-=JUAMPI=-containerForChildren  ^SortedCollection sortBlock: sortFunction-=JUAMPI=-= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^definingClass = arg1 definingClass-=JUAMPI=-isSameAs: arg1  self size = arg1 size ifFalse: [ ^false ].  items with: arg1 items do: [:arg2 :arg3 |  arg2 actualObject == arg3 actualObject ifFalse: [ ^false ] ].  ^true-=JUAMPI=-browser: arg1  browser := arg1-=JUAMPI=-isResult: arg1 affectedBy: arg2  arg2 affectsCritiques ifFalse: [ ^false ].  arg1 forceLazyRebuild.  ^false-=JUAMPI=-createQuery  ^ClyLongQueryExample from: ClyScopeExample of: String in: environment-=JUAMPI=-testNotEmptyFromEmptyMethodScope  query scope: (ClyMethodScope emptyIn: environment).  self deny: query checkEmptyResult-=JUAMPI=-accumulateTestMethod: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 selector.  tmp3 := (ClyClassScope of: arg1 methodClass) withInheritingScope.  tmp3 classesDo: [:arg2 |  (arg2 isTestCase and: [ arg2 isAbstract not ]) ifTrue: [ self accumulateTest: tmp1 of: arg2.              tmp2 := testCaseResults at: arg2 ifAbsentPut: [ ClyTestResultProperty new ].              tmp2 accumulateTest: tmp1 of: arg2 ] ]-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (Object >> #printString)}.  self assert: foundSelectors equals: #(abstractMethod1 abstractMethod2)-=JUAMPI=-build  | tmp1 tmp2 |  tmp2 := ownerTool printContext.  tmp2 ifEmpty: [ ^self ].  self addMorphBack: (self iconNamed: #uncommentedClass) asMorph.  self addMorphBack: tmp2 asMorph.  tmp1 := IconicButton new     target: self;     actionSelector: #restoreBrowserState;     arguments: {};     labelGraphic: (self iconNamed: #forward);     color: Color transparent;     helpText: 'Move browser to ' , tmp2;     borderWidth: 0.  self addMorphBack: tmp1-=JUAMPI=-menuItemNameFor: arg1  ^menuItemName ifNil: [ arg1 defaultToolbarItemName ]-=JUAMPI=-position: arg1  position := arg1-=JUAMPI=-enableFilterUsing: arg1  self enableFilter: ClyItemNameFilter using: arg1-=JUAMPI=-selectsMethod: arg1  ^scope inheritanceAnalyzer isMethodOverriding: arg1-=JUAMPI=-groupProviderClass  ^ClyFlagMethodGroupProvider-=JUAMPI=-buildExtensionCheckBoxButton  extensionCheckbox := self theme newCheckboxIn: self for: self getSelected: #isExtensionActive setSelected: #toggleExtension getEnabled: nil label: 'extension' help: 'toggle check box to choose/reset package of method'.  extensionCheckbox     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap-=JUAMPI=-reference1OfClass  ^ClyClassReferencesQueryTest-=JUAMPI=-runBuildProcess  buildProcess := [ self buildActualResult ] newProcess.  buildProcess     name: 'Build result of ' , buildingQuery printString;     priority: Processor userBackgroundPriority.  buildProcess resume-=JUAMPI=-classesSize  ^classQuery execute size-=JUAMPI=-isClassTagSelected  | tmp1 |  tmp1 := tool classGroupSelection.  tmp1 isEmpty ifTrue: [ ^false ].  ^tmp1 lastSelectedItem type isBasedOnClassTag-=JUAMPI=-execute  sourceNode nodesWithLinks do: [:arg1 |  self metalinkManagerClass removeFrom: arg1 ]-=JUAMPI=-rebuildAllTools  tabManager updateTools.  self rebuildToolbar-=JUAMPI=-buildResult: arg1  | tmp1 tmp2 |  tmp1 := critiqueQuery execute.  tmp2 := tmp1 items collect: [:arg2 |  arg2 sourceAnchor entity ] as: IdentitySet.  arg1 fillWith: tmp2-=JUAMPI=-attachToSystem  -=JUAMPI=-wantsStayInDifferentContext  self isBuilt ifFalse: [ ^false ].  self hasUnacceptedEdits ifTrue: [ ^true ].  self isTabSelected & self isExtraSelectionRequested ifTrue: [ ^true ].  self belongsToRemovedBrowserContext ifTrue: [ ^false ].  ^isManagedByUser-=JUAMPI=-openFor: arg1  self moveToStart.  itemObserver := arg1.  queryResult subscribe: itemObserver-=JUAMPI=-buildIsDone  self notifyObservers.  environment systemChanged: (ClyAsyncQueryIsDone with: self)-=JUAMPI=-changesCancelled  textMorph hasUnacceptedEdits: false.  self textUpdated-=JUAMPI=-testPrepareResultForExecutionWhenItIsSemiAsync  | tmp1 |  tmp1 := query semiAsync prepareNewResult.  self assert: tmp1 class equals: ClySemiAsyncQueryResult.  self assert: tmp1 buildingQuery identicalTo: query actualQuery.  self assert: tmp1 environment identicalTo: environment.  self assert: tmp1 isProtected-=JUAMPI=-initialize  super initialize.  fullIndentation := false.  self cellInset: 2 @ 0-=JUAMPI=-isCommandAvailable: arg1  ^arg1 canBeExecutedInTool: self-=JUAMPI=-decorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color red.  arg1 definitionIcon: #smallDebug-=JUAMPI=-itemOfThisTestMethod  ^ClyBrowserItem with: self class >> testSelector-=JUAMPI=-browser  ^tool browser-=JUAMPI=-methodFromTraitChild2  -=JUAMPI=-filterField  ^table filterField-=JUAMPI=-testNotAffectedByChangeOfSubclassMethodWhichNotOverridesSuperclass  self deny: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)-=JUAMPI=-itemsChanged  dirty ifTrue: [ ^self ].  dirty := true.  self scheduleUpdate-=JUAMPI=-testNotSelectsMethodWhichHasNoUndeclares  self deny: (query selectsMethod: Object >> #printString)-=JUAMPI=-createInheritingScopeFrom: arg1  | tmp1 |  tmp1 := annotatedClass createInheritingScopeFrom: arg1.  tmp1 name: ClyClassScope inheritingScopeName.  ^tmp1-=JUAMPI=-increasedByClassesFrom: arg1  ^self withExtraBasisObjects: arg1 collectAllClasses-=JUAMPI=-testFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 3.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector).  self assert: (resultItems identityIncludes: self class superclass >> self targetSelector)-=JUAMPI=-close  queryResult unsubscribe: itemObserver.  itemObserver := nil.  ^ClyClosedBrowserCursor instance-=JUAMPI=-testCompareTwoMethods  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object >> #size value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)-=JUAMPI=-printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  methodQuery printOn: arg1.  arg1 nextPut: $)-=JUAMPI=-checkEmptyResult  ^self installedMethods isEmpty-=JUAMPI=-buildItemsPerClassFrom: arg1  | tmp1 tmp2 tmp3 |  tmp1 := IdentityDictionary new.  arg1 do: [:arg2 |  tmp2 := arg2 asCalypsoBrowserItem.        tmp3 := tmp1 at: tmp2 systemDefinitionClass ifAbsentPut: [ self containerForItemsOfClass ].        tmp3 add: tmp2 ].  ^tmp1-=JUAMPI=-actualObject: arg1  actualObject := arg1.  type := arg1 calypsoEnvironmentType-=JUAMPI=-testIsAffectedByChangeOfAbstractMethodWhichIsImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #abstractMethod1)-=JUAMPI=-editingMethod: arg1  editingMethod := arg1-=JUAMPI=-isActive  ^ownerTool extendingPackage notNil-=JUAMPI=-testFillingWithTwoEqualVarsOfDifferentSubclassesAndOneVarOfSuperclass  queryResult fillWith: {(ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN2OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN1OfClass1FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar2 #subclassSameVar #subclassSameVar)-=JUAMPI=-testCreationUnifiedInstance  scope := self createSampleScope.  self assert: scope asUnifiedInstance identicalTo: scope-=JUAMPI=-localMethod  -=JUAMPI=-isBasedOnEmptyBasis  ^self basisSize = 0-=JUAMPI=-cleanGarbageInCache  accessGuard critical: [ queryCache clyCleanGarbage ]-=JUAMPI=-subscribe: arg1  announcer ifNil: [ announcer := Announcer new ].  announcer when: ClyEnvironmentChanged send: #itemsChanged to: arg1-=JUAMPI=-browser: arg1  browser := arg1-=JUAMPI=-testCreationFromTwoSameQueriesOfSameScopeButWithDifferentParameter  | tmp1 tmp2 |  tmp1 := self subqueryFromScopeOf: Array.  tmp1 scope extraParameter: #testParameter.  tmp2 := self subqueryFromScopeOf: Array.  tmp2 scope extraParameter: #testParameter2.  query := tmp1 , tmp2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {tmp1 .         tmp2} asSet.  self assert: query requiredResult identicalTo: tmp1 requiredResult-=JUAMPI=-size  ^self protectItemsWhile: [ items size ]-=JUAMPI=-testRetrievesMethodQuery  self snapshotState.  self assert: navigationState systemQuery equals: browser systemQuery-=JUAMPI=-hash  ^sortFunction hash bitXor: inverse hash-=JUAMPI=-name  ^name-=JUAMPI=-testItemsInitializationShouldNotResetExistingItems  queryResult items: #(items).  queryResult initializeItems.  self assert: queryResult items equals: #(items)-=JUAMPI=-printContext  ^super printContext , ' / ' , editingClass name-=JUAMPI=-testMethodsEnumerationWhenBothMetaLevels  scope := ClyTraitUserScope of: ClyTraitRoot1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyTraitChild1 localMethods).  self assert: (result includesAll: ClyTraitChild1 classSide localMethods).  self assert: (result includesAll: ClyClassWithTraits localMethods).  self assert: (result includesAll: ClyClassWithTraits classSide localMethods).  self deny: (result includesAll: ClyTraitRoot1 localMethods).  self deny: (result includesAll: ClyTraitRoot1 classSide localMethods)-=JUAMPI=-setUpActiveScope  systemQuery isBoundToEnvironment ifFalse: [ systemQuery := systemQuery withScope: self systemScope ].  (queryScopes includes: systemQuery scope) ifFalse: [ queryScopes add: systemQuery scope ].  activeScope := systemQuery scope-=JUAMPI=-scopeNames  ^self scopes collect: [:arg1 |  arg1 description capitalized ]-=JUAMPI=-toolWasRemoved  -=JUAMPI=-defaultMenuItemName  ^'Jump to test class'-=JUAMPI=-defaultNavigationScope  ^self isScopedModeEnabled ifFalse: [ super defaultNavigationScope ] ifTrue: [ packageView query scope ]-=JUAMPI=-isAboutSelectedItem: arg1  (selectedItems anySatisfy: [:arg2 |  arg2 actualObject == arg1 actualObject ]) ifTrue: [ ^true ].  (selectedItems anySatisfy: [:arg2 |  arg2 name = arg1 name ]) ifFalse: [ ^false ].  ^selectedItems anySatisfy: [:arg2 |  arg2 isEqualTo: arg1 ]-=JUAMPI=-checkEmptyResult  ^critiqueQuery hasEmptyResult-=JUAMPI=-tools: arg1  tools := arg1-=JUAMPI=-hasEmptyResult  ^scope isQueryEmpty: self-=JUAMPI=-singleBasisSample  ^ClyClass1FromP1 package-=JUAMPI=-toggle  textMorph lineNumbersRuler ifNil: [ textMorph withLineNumbers ] ifNotNil: [ textMorph withoutLineNumbers ].  self updateLabel-=JUAMPI=-ensureVisibleLastItem  rootDataSource table ensureVisibleFirstSelection-=JUAMPI=-forceRebuild  actualResult forceRebuild-=JUAMPI=-fillStatusBar  self belongsToCurrentBrowserContext ifFalse: [ statusBar addContextItem: (ClyToolContextNavigatorMorph for: self) ]-=JUAMPI=-hash  ^super hash bitXor: variableQuery hash-=JUAMPI=-testMoveToItemWhichSatisfiesConditionWhenItNotExistsInCache  | tmp1 |  cursor cleanCache.  tmp1 := cursor moveToItemWhich: [:arg1 |  arg1 actualObject = Object ].  self assert: tmp1.  self assert: cursor position equals: 2.  self assert: cursor currentItem actualObject equals: Object-=JUAMPI=-testVariableNamedThisContext_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'ThisContext') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext lookupSymbol: #ThisContext)]')-=JUAMPI=-testNotSelectsMethodWithoutWatchpoint  self deny: (query selectsMethod: self class >> #methodWithoutWatchpoint)-=JUAMPI=-execute  | tmp1 |  tmp1 := browser searchDialog requestSingleObject: 'Choose class' from: ClyAllClassesQuery sorted.  browser selectClass: tmp1-=JUAMPI=-decorateBrowserItem: arg1 ofPackage: arg2  -=JUAMPI=-testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> #method1).  self assert: (resultItems identityIncludes: self class >> #method2)-=JUAMPI=-bindTo: arg1 in: arg2  arg1 bindTo: arg2.  self scope: arg1-=JUAMPI=-activationPriority  ^-100-=JUAMPI=-method1  -=JUAMPI=-metaLevelScope: arg1  metaLevelScope := arg1-=JUAMPI=-createBlockFromPattern  (pattern value endsWith: ']') ifFalse: [ badScript := true.        ^self ].  [ scriptBlock := self class compiler evaluate: pattern value ] on: Exception do: [:arg1 |  badScript := true ]-=JUAMPI=-build  self addMorphBack: label-=JUAMPI=-metadata  ^metadata ifNil: [ self collectMetadata.        metadata ]-=JUAMPI=-updateTabsWith: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection withAll: tools.  tmp2 := OrderedCollection new.  arg1 do: [:arg2 |  tools detect: [:arg3 |  arg3 isSimilarTo: arg2 ] ifFound: [:arg3 |  tmp1 remove: arg3 ] ifNone: [ tmp2 add: arg2 ] ].  tmp1 do: [:arg4 |  arg4 wantsStayInDifferentContext ifFalse: [ arg4 removeFromBrowser ] ].  tools do: [:arg4 |  arg4 browserContextWasChanged ].  tmp2 do: [:arg4 |  self addTool: arg4 ]-=JUAMPI=-isSameAsCurrent: arg1  isSameAsCurrent := arg1-=JUAMPI=-adoptLocalScopeClassTo: arg1  localScopeClass := arg1-=JUAMPI=-createQueryResult  ^ClyClassBindings new-=JUAMPI=-requestSingleObject: arg1 from: arg2 inScope: arg3  arg3 bindTo: browser navigationEnvironment.  ^self requestSingleObject: arg1 from: (arg3 adoptQuery: arg2)-=JUAMPI=-testBasedOnMultipleBasis  scope := self multipleScopeSample.  self assert: scope isBasedOnMultipleBasis.  scope := self singleScopeSample.  self deny: scope isBasedOnMultipleBasis.  scope := self emptyScopeSample.  self deny: scope isBasedOnMultipleBasis-=JUAMPI=-defaultMenuIconName  ^#trait-=JUAMPI=-critique  ^critique-=JUAMPI=-affectsMethods  ^true-=JUAMPI=-execute  UIManager default debugProcess: Processor activeProcess context: critique stack label: critique message fullView: true-=JUAMPI=-testMethodsEnumeration  | tmp1 |  scope := ClyClassScope of: ClyClass1FromP1.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArray-=JUAMPI=-changeStateBy: arg1  arg1 value-=JUAMPI=-execute  script executeOn: targetClass-=JUAMPI=-initialize  super initialize.  basisObjects := #()-=JUAMPI=-findItemsSimilarTo: arg1  | tmp1 tmp2 |  tmp1 := super findItemsSimilarTo: arg1.  tmp1 size == arg1 size ifTrue: [ ^tmp1 ].  tmp2 := expandedItems flatCollect: [:arg2 |  arg2 childrenDataSource findItemsSimilarTo: arg1 ].  ^tmp1 , tmp2-=JUAMPI=-packagesDo: arg1  self system packages do: arg1-=JUAMPI=-prepareExecutionInDropContext: arg1  super prepareExecutionInDropContext: arg1.  package := arg1 lastSelectedPackage-=JUAMPI=-targetClass  ^targetClass-=JUAMPI=-conditionBlock: arg1  conditionBlock := arg1-=JUAMPI=-prepareInitialState  -=JUAMPI=-basisObjects: arg1  super basisObjects: (self prepareBasisFrom: arg1)-=JUAMPI=-decorateOwnBrowserItem: arg1  super decorateOwnBrowserItem: arg1.  classQuery decorateItemGroup: arg1.  subgroupsQuery decorateItemGroup: arg1-=JUAMPI=-defaultMenuItemName  ^'Writers'-=JUAMPI=-allowsDifferentActivationPriority  ^true-=JUAMPI=-testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  < expectedFailure>  super testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject-=JUAMPI=-readerOfVar1  ^writtenVar1-=JUAMPI=-selectedPackageItems  ^tool packageSelection items-=JUAMPI=-selectsMethod: arg1  | tmp1 |  tmp1 := self environment getPlugin: ClyReflectiveEnvironmentPlugin.  ^tmp1 doesMethodHasWatchpoint: arg1-=JUAMPI=-representsConcreteQuery  ^true-=JUAMPI=-findItemsSimilarTo: arg1  ^cache findItemsWith: (arg1 collect: #actualObject) forAbsentDo: [ ^queryResult findItemsSimilarTo: arg1 ]-=JUAMPI=-fillWith: arg1  | tmp1 tmp2 |  tmp1 := IdentitySet withAll: arg1.  tmp2 := OrderedCollection new.  arg1 do: [:arg2 |  (self isQueryScopeDefinesClass: arg2) ifFalse: [ tmp1 remove: arg2.              tmp2 add: arg2 ] ].  items := self buildItemsFrom: tmp1.  items addAll: (self buildExtensionItemsFrom: tmp2)-=JUAMPI=-methodGroupType  ^ClyVariable-=JUAMPI=-isCommandAvailable: arg1  ^arg1 canBeExecutedInCodeMethodEditor: self-=JUAMPI=-defaultMenuIconName  ^#smallRedo-=JUAMPI=-superclassVar1WriterMethod  instanceSideVar1 := #subclassVar1Value-=JUAMPI=-extraBasisSample  ^ClySubclassMOfClass1FromP2 package-=JUAMPI=-testConvertingToSomeHierarchyScope  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asScope: ClySubclassScope.  self assert: tmp1 class equals: ClySubclassScope.  self assert: tmp1 localScopeClass equals: scope localScopeClass.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 environment equals: environment-=JUAMPI=-defaultItems  ^SortedCollection sortBlock: sortFunction-=JUAMPI=-direction: arg1  direction := arg1-=JUAMPI=-isParentExpanded  parentItem ifNil: [ ^true ].  ^parentItem isExpanded-=JUAMPI=-testIsExecutedFromConcreteScopeClass  self assert: (query isExecutedFromScope: query scope class).  self assert: (query isExecutedFromScope: query scope class superclass).  self deny: (query isExecutedFromScope: ClyScopeExample2)-=JUAMPI=-testConvertingAsRestrictedByAnotherScope2  | tmp1 tmp2 |  scope := self singleScopeSample.  tmp2 := self multipleScopeSample.  tmp1 := scope restrictedBy: tmp2.  self assert: tmp1 class equals: scope class.  self assert: tmp1 basisObjects equals: tmp2 basisObjects-=JUAMPI=-classSampleWhichHasGroup  ^ClySubclassN1OfClass1FromP1-=JUAMPI=-hash  ^super hash bitXor: pattern hash-=JUAMPI=-start  ^start-=JUAMPI=-isMultipleSelected  ^items size > 1-=JUAMPI=-showVariableNamed: arg1  tool selectVariableNamed: arg1-=JUAMPI=-includesClass: arg1  self classesDo: [:arg2 |  arg2 = arg1 ifTrue: [ ^true ] ].  ^false-=JUAMPI=-decorateMethodGroupTableCell: arg1 of: arg2  | tmp1 |  super decorateMethodGroupTableCell: arg1 of: arg2.  tmp1 := arg1 definitionIcon: #flagIcon.  tmp1 setBalloonText: 'There are methods with flag'-=JUAMPI=-printContext  ^''-=JUAMPI=-description  ^'all method groups'-=JUAMPI=-decorateResultMethodEditor: arg1  criteriaString ifNil: [ ^self ].  arg1 selectStringAsInMessageBrowser: criteriaString-=JUAMPI=-execute  browser switchToVariables-=JUAMPI=-variableQuery: arg1  variableQuery := arg1-=JUAMPI=-createBrowser  ^ClyFullBrowser new-=JUAMPI=-description  ^'Do not supported currently'-=JUAMPI=-queryScope: arg1  queryScope := arg1-=JUAMPI=-readParametersFromContext: arg1  super readParametersFromContext: arg1.  testItems := arg1 selectedItems select: [:arg2 |  arg2 hasProperty: ClyTestResultProperty ]-=JUAMPI=-initialize  super initialize.  undoExecuting := false.  redoExecuting := false.  waitingNewState := true.  undoList := OrderedCollection new.  redoList := OrderedCollection new-=JUAMPI=-createQuery  ^ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: #basisObject in: environment-=JUAMPI=-defaultMenuItemName  ^'Run script'-=JUAMPI=-defaultMenuItemName  ^'Move to package'-=JUAMPI=-activeWindow  self tabGroup pages size = 0 ifTrue: [ ^nil ].  self tabGroup selectedPageIndex <= 0 ifTrue: [ ^nil ].  ^self tabGroup pages at: self tabGroup selectedPageIndex-=JUAMPI=-initialize  super initialize.  methodTags := #()-=JUAMPI=-testCheckIfEmpty  self installCounterInto: #methodWithCounter.  query scope: (ClyMethodScope of: self class >> #methodWithCounter in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-=JUAMPI=-littleHierarchyMaxSize: arg1  littleHierarchyMaxSize := arg1-=JUAMPI=-decorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color red-=JUAMPI=-affectedPackage: arg1  affectedPackage := arg1-=JUAMPI=-execute  browser switchToProjects-=JUAMPI=-execute  | tmp1 tmp2 |  tmp1 := methodGroups collect: [:arg1 |  arg1 methodQuery ].  tmp2 := ClyQuery unionFrom: tmp1.  browser spawnQueryBrowserOn: tmp2-=JUAMPI=-initialize  super initialize.  collapsedItems := SortedCollection sortBlock: [:arg1 :arg2 |  arg1 position < arg2 position ]-=JUAMPI=-readParametersFromContext: arg1  super readParametersFromContext: arg1.  browser := arg1 browser-=JUAMPI=-isPrepared  ^isPrepared-=JUAMPI=-defaultMenuItemName  ^'Add breakpoint condition..'-=JUAMPI=-testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  < expectedFailure>  super testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects-=JUAMPI=-hierarchy  ^hierarchy-=JUAMPI=-allItems  ^self prepareItems: actualResult allItems-=JUAMPI=-decorateBrowserItem: arg1 ofPackage: arg2  arg2 isDeprecated ifTrue: [ arg1 markWith: ClyDeprecatedItemTag ]-=JUAMPI=-query: arg1  ^ClyUnknownQueryResult instance-=JUAMPI=-printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  classQuery printOn: arg1.  arg1 nextPut: $)-=JUAMPI=-methodWithoutCritiques  ^ClyClassWithProblemMethods >> #methodWithoutCritiques-=JUAMPI=-findTestedClassCoveredBy: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := arg1 instanceSide name.  (tmp1 endsWith: 'Tests') ifTrue: [ ^environment system classNamed: (tmp1 allButLast: 5) asSymbol ifAbsent: arg2 ].  (tmp1 endsWith: 'Test') ifTrue: [ ^environment system classNamed: (tmp1 allButLast: 4) asSymbol ifAbsent: arg2 ].  ^arg2 value-=JUAMPI=-newName  ^newName-=JUAMPI=-prepareIn: arg1  isPrepared ifTrue: [ ^self ].  arg1 pluginsDo: [:arg2 |  self decorateBy: arg2 ].  isPrepared := true-=JUAMPI=-tableCellIcon  ^Smalltalk ui iconNamed: #halt-=JUAMPI=-restoreBrowserState  self browser selectObject: self lastSelectedObject-=JUAMPI=-testConvertingAsRestrictedByAnotherScope  | tmp1 tmp2 |  tmp2 := ClyScopeExample2 of: #restrictedBasis.  tmp1 := query restrictedByScope: tmp2.  self assert: tmp1 class equals: query class.  self assert: tmp1 requiredResult identicalTo: query requiredResult.  self assert: (tmp1 subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (tmp1 subqueries collect: #scope) equals: (query subqueries collect: [:arg1 |  arg1 scope withNewBasisObjects: #(restrictedBasis) ])-=JUAMPI=-normalizeSelectorForComparison: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 asString.  tmp2 := arg1 size.  tmp3 := tmp1 class new: tmp2.  tmp4 := 0.  1 to: tmp2 do: [:arg2 |  | tmp5 |        (tmp5 := tmp1 at: arg2) == $: ifFalse: [ tmp3 at: (tmp4 := tmp4 + 1) put: tmp5 ] ].  ^(tmp4 < tmp2 ifTrue: [ tmp3 first: tmp4 ] ifFalse: [ tmp1 ]) asLowercase-=JUAMPI=-defaultMenuItemName  ^'Show in method browser'-=JUAMPI=-selectsMethod: arg1  ^arg1 isExtension-=JUAMPI=-toggleFullWindowTabs  | tmp1 |  tmp1 := tabManager tabMorph.  (submorphs includes: tmp1) ifFalse: [ self addMorph: tmp1 fullFrame: LayoutFrame identity ] ifTrue: [ toolPanel addMorphBack: tmp1 ]-=JUAMPI=-methodGroups  ^methodGroups-=JUAMPI=-prepareExecutionInDropContext: arg1  | tmp1 |  super prepareExecutionInDropContext: arg1.  methodGroup := arg1 lastSelectedMethodGroup.  tmp1 := arg1 selectedClasses.  tmp1 := tmp1 collect: [:arg2 |  arg1 currentMetaLevelOf: arg2 ].  targetClass := tmp1 size > 1 ifTrue: [ arg1 requestSingleClass: 'In what class you want to move method?' from: tmp1 ] ifFalse: [ tmp1 last ]-=JUAMPI=-decorateMethodEditor: arg1  methodView query decorateResultMethodEditor: arg1-=JUAMPI=-methodWithoutBreakpoints  -=JUAMPI=-testCreationWithSingleSubqueryButAnotherResult  | tmp1 |  tmp1 := self subqueryFromScopeOf: Array.  query := ClyUnionQuery with: {tmp1} as: #specialResult.  self assert: query class equals: tmp1 class.  self assert: query scope equals: tmp1 scope.  self assert: query requiredResult equals: #specialResult.  self deny: tmp1 requiredResult equals: #specialResult-=JUAMPI=-addNewCommentForTestClass: arg1 basedOn: arg2  arg1 comment: (String streamContents: [:arg3 |  | tmp1 |              tmp1 := arg1 name.              tmp1 first isVowel ifTrue: [ arg3 nextPutAll: 'An ' ] ifFalse: [ arg3 nextPutAll: 'A ' ].              arg3                 nextPutAll: tmp1;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: arg2 name ])-=JUAMPI=-testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self deny: query isExecutedFromSingleScope-=JUAMPI=-testClass  ^testClass-=JUAMPI=-createTableCellButtonWith: arg1 using: arg2  | tmp1 |  tmp1 := super createTableCellButtonWith: arg1 using: arg2.  sourceNode hasExecutionCounter ifTrue: [ ClyDynamicBallonTooltip from: [ self tableDescription ] installInto: tmp1 ].  ^tmp1-=JUAMPI=-execute  browser spawnQueryBrowserOn: (ClyVariableReferencesQuery ofAny: variables)-=JUAMPI=-testCreationFromAnotherCompositeQueryAndSimilarQuery  | tmp1 tmp2 tmp3 |  tmp1 := self subqueryFromScopeOf: Array.  tmp2 := self subqueryFromScope: ClyScopeExample2 of: String.  tmp3 := self subqueryFromScopeOf: Object.  query := tmp1 , tmp2 , tmp3.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {(self subqueryFromScope: (ClyScopeExample ofAll: {Array .                     Object})) .         tmp2} asSet.  self assert: query requiredResult equals: tmp1 requiredResult-=JUAMPI=-requestSingleClass: arg1  ^tool searchDialog requestSingleObject: arg1 from: ClyAllClassesQuery sorted-=JUAMPI=-hash  ^super hash bitXor: hierarchy hash-=JUAMPI=-packageScopeOfSelectedItems  | tmp1 |  tmp1 := self selection items collect: [:arg1 |  arg1 systemDefinition definingPackage ].  ^ClyPackageScope ofAll: tmp1 in: navigationEnvironment-=JUAMPI=-buildsDefaultResult  ^self retrievesItemsAs: self defaultResult class-=JUAMPI=-isMethodSelected  ^false-=JUAMPI=-copyForBrowserStateSnapshotOf: arg1  | tmp1 tmp2 |  tmp2 := arg1 findDataSourceSameAs: ownerDataSource ifNone: [ self error: 'should not happen' ].  tmp1 := self copy.  tmp1 ownerDataSource: tmp2.  childrenDataSource ifNotNil: [ tmp1 childrenDataSource: childrenDataSource copyForBrowserStateSnapshot ].  ^tmp1-=JUAMPI=-shouldSkipCurrentDesiredSelection  ^shouldSkipCurrentDesiredSelection-=JUAMPI=-testResult  ^testResult-=JUAMPI=-defaultMenuItemName  ^'Inspect'-=JUAMPI=-ownerTool  ^ownerTool-=JUAMPI=-simpleNameForSpotterMenu  ^'Variables'-=JUAMPI=-fillWith: arg1  | tmp1 |  arg1 do: [:arg2 |  tmp1 := ClyExternalPackageMethodGroup withMethodsFrom: self scope packagedIn: arg2.        items add: tmp1 ]-=JUAMPI=-canDetectAffectOnClassesBy: arg1  ^(arg1 isKindOf: ClassAnnouncement) not-=JUAMPI=-defaultMenuIconName  ^#glamorousBrowse-=JUAMPI=-isAssignmentSelected  | tmp1 |  tmp1 := self selectedSourceNode.  [ tmp1 notNil ] whileTrue: [ tmp1 isAssignment ifTrue: [ ^true ].        tmp1 := tmp1 parent ].  ^false-=JUAMPI=-setUp  super setUp.  environment := nil-=JUAMPI=-extendClassScopeForMethods: arg1  | tmp1 |  tmp1 := arg1.  (ClyMethodVisibilityLevel allAvailableFor: self classSelection items) ifNotEmpty: [:arg2 |  tmp1 := arg2 anyOne extendClassScope: tmp1 ].  ^tmp1-=JUAMPI=-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-=JUAMPI=-testClassEnumerationOverClassWhenBothMetaLevelsAreLocalScope  | tmp1 |  scope := ClySubclassScope of: Class localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := Class subclasses select: #isInstanceSide.  tmp1 := tmp1 flatCollect: [:arg1 |  {arg1 instanceSide .         arg1 classSide} ].  self assert: result asSet equals: tmp1 asSet-=JUAMPI=-critique: arg1  critique := arg1-=JUAMPI=-testComparisonToSimilarQueryButWithDifferentTag  | tmp1 |  query tag: #tag1.  tmp1 := self createQuery.  tmp1 tag: #anotherTag.  self deny: query equals: tmp1-=JUAMPI=-open  | tmp1 tmp2 tmp3 |  tmp2 := messages select: [:arg1 |  (arg1 isRingObject and: [ arg1 isMethod ]) or: [ arg1 isCompiledMethod ] ] thenCollect: [:arg1 |  arg1 compiledMethod ].  tmp3 := messages select: [:arg1 |  arg1 isRingObject and: [ arg1 isComment ] ] thenCollect: [:arg1 |  ClyClassComment of: arg1 parent realClass ].  tmp1 := ClyOldMessageBrowserQuery named: title with: tmp2 asOrderedCollection , tmp3.  tmp1     criteriaString: autoSelect;     criteriaBlock: refreshingBlock.  openedBrowser := ClyQueryBrowser openOn: tmp1-=JUAMPI=-isSelectedItemHasWatchpoint  ^selectedSourceNode hasWatchpoint-=JUAMPI=-includesMethod: arg1  self asyncQueryResult isBuilt ifFalse: [ ^false ].  ^super includesMethod: arg1-=JUAMPI=-attachToSystem  browser system when: (ClyMethodChange of: self editingMethod) send: #triggerUpdate to: self-=JUAMPI=-referenceOfNumberClassByNameSymbol  ^#Number-=JUAMPI=-update  leftMethod := leftMethod origin localMethodNamed: leftMethod selector ifAbsent: [ ^self ].  rightMethod := rightMethod origin localMethodNamed: rightMethod selector ifAbsent: [ ^self ].  super update.  diffMorph from: leftMethod sourceCode to: rightMethod sourceCode-=JUAMPI=-printDefinition  ^definingPackageItem name-=JUAMPI=-methodTags  ^methodTags-=JUAMPI=-scopeWithCritiques  ^ClyMethodScope of: self methodWithCritiques in: environment-=JUAMPI=-setUp  super setUp.  browser prepareInitialState-=JUAMPI=-isClassVariable  ^true-=JUAMPI=-browserPlugins  ^browserPlugins-=JUAMPI=-isEmpty  ^self itemCursor itemCount = 0-=JUAMPI=-isQueryEmpty: arg1  self isBasedOnEmptyBasis ifTrue: [ ^true ].  arg1 ensureScope: self.  ^environment isQueryEmpty: arg1-=JUAMPI=-supeclassWriterOfVar1  writtenVar1 := #superclassValue-=JUAMPI=-testConvertingToInheritedScope  | tmp1 |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  tmp1 := scope asInheritedScope.  self assert: (tmp1 representsScope: ClySuperclassScope).  self assert: tmp1 localScopeClass equals: ClyInstanceSideScope.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 environment equals: environment.  self assert: tmp1 name equals: ClyClassScope inheritedScopeName-=JUAMPI=-selectMethodGroupNamed: arg1  self changeStateBy: [ self methodGroupSelection selectItemsWhere: [:arg2 |  arg2 name = arg1 ] ]-=JUAMPI=-testDecoratingMethodWithExecutionCounter  | tmp1 tmp2 tmp3 |  tmp1 := ClyReflectiveEnvironmentPlugin new.  self installWatchpointInto: #methodWithWatchpoint.  tmp2 := self class >> #methodWithWatchpoint.  tmp3 := tmp2 asCalypsoBrowserItem.  tmp1 decorateBrowserItem: tmp3 ofMethod: tmp2.  self assert: (tmp3 isMarkedWith: ClyMethodWithWatchpointTag)-=JUAMPI=-subgroupsQuery: arg1  subgroupsQuery := arg1-=JUAMPI=-testForceLazyRebuild  self assert: queryResult items notNil.  queryResult forceLazyRebuild.  self assert: queryResult needsRebuild-=JUAMPI=-createQuery  ^ClyUntaggedClassesQuery from: (ClyClassScope of: Object in: environment)-=JUAMPI=-addContextItem: arg1  contextBar addMorphBack: arg1.  ^arg1-=JUAMPI=-restoreTableSelectionSilently: arg1  | tmp1 |  items := items reject: [:arg2 |  arg2 isRemoved ].  tmp1 := items collect: #globalPosition.  self setUpSelectedRows: tmp1 in: rootDataSource table silently: arg1-=JUAMPI=-includesVariablesAffectedBy: arg1  self classesDo: [:arg2 |  (arg1 affectsVariablesOf: arg2) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-createQuery  ^ClyMethodWatchpointsQuery from: ClyClassScope of: self class in: environment-=JUAMPI=-collapsedButton  ^IconicButton new     target: item;     actionSelector: #expand;     arguments: {};     labelGraphic: self theme treeUnexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-=JUAMPI=-senderOfIfTrue  ^2 * 2 = 4 ifTrue: [ 100 ]-=JUAMPI=-hash  ^super hash bitXor: baseQueryResult hash-=JUAMPI=-affectsMethodsDefinedInClass: arg1  ^(arg1 includesLocalSelector: self overriddenMethod selector) and: [ arg1 inheritsFrom: self overriddenMethod origin ]-=JUAMPI=-context  ^context-=JUAMPI=-retrievesItem: arg1  ^arg1 isKindOf: ClyInstanceVariable-=JUAMPI=-testFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}-=JUAMPI=-packageOrganizer  ^packageOrganizer-=JUAMPI=-itemsChanged  navigationStarted ifTrue: [ ^self ].  navigationStarted := true.  [ self rebuildToolsForChangedEnvironment ] ensure: [ navigationStarted := false ]-=JUAMPI=-actualObject: arg1  ^browserItem actualObject: arg1-=JUAMPI=-withInheritedScope  | tmp1 |  tmp1 := self , self asInheritedScope.  tmp1 name: self class hierarchyScopeName.  ^tmp1-=JUAMPI=-deprecatedMethod2  self deprecated: 'it is deprecated method for testing deprecation analyzis'-=JUAMPI=-testConvertingToInterestingClassScope  | tmp1 |  scope := ClyMultipleClassRelationScope of: {String} merging: {ClySuperclassScope .         ClySubclassScope}.  scope localScopeClass: ClyInstanceSideScope.  tmp1 := scope asInterestingClassScope.  self deny: tmp1 identicalTo: scope.  self assert: tmp1 class equals: ClyMultipleClassRelationScope.  self assert: tmp1 relationScopeClasses equals: {ClyInterestingSuperclassScope .         ClySubclassScope}.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 localScopeClass equals: scope localScopeClass.  self assert: tmp1 environment equals: scope environment-=JUAMPI=-testExecution  | tmp1 tmp2 |  tmp1 := ClyScopeExample ofAll: {self class superclass .         self class} in: environment.  tmp2 := ClyQueryExampleReturningScopeBasis from: tmp1.  query subqueries: {tmp2}.  self executeQuery.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self class-=JUAMPI=-groupProviderClass  ^ClyExtendedClassGroupProvider-=JUAMPI=-isResult: arg1 affectedBy: arg2  ^arg2 affectsClassExtension and: [ scope includesMethodsAffectedBy: arg2 ]-=JUAMPI=-ownerDataSource  ^ownerDataSource-=JUAMPI=-buildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self analyzedObjectsDo: [:arg2 |  tmp1 addAll: arg2 critiques ].  arg1 fillWith: tmp1-=JUAMPI=-execute  browser navigateBack-=JUAMPI=-execute  browser spawnQueryBrowserOn: (ClyClassReferencesQuery toAny: classes)-=JUAMPI=-isExecutedFromSingleScope  ^scope isBasedOnSingleBasis-=JUAMPI=-testNotBasedOnSingleBasisWhenSingleSubscopeIsNot  | tmp1 |  tmp1 := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {tmp1}.  self deny: scope isBasedOnSingleBasis-=JUAMPI=-detachFromTextMorph  -=JUAMPI=-description  ^'Method watchpoints'-=JUAMPI=-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-=JUAMPI=-defaultIconName  ^#scriptManagerIcon-=JUAMPI=-name: arg1  name := arg1-=JUAMPI=-withoutBasisObject: arg1  ^self withNewBasisObjects: (basisObjects copyWithout: arg1)-=JUAMPI=-testSelectedChildInExpandedItemWithRetrievedExpandedDataSource  | tmp1 tmp2 |  self selectedItem expand.  tmp1 := self selectedItem childrenDataSource elementAt: 1.  queryView selection selectItems: {tmp1}.  self snapshotState.  tmp2 := navigationState selection items first.  self assert: tmp2 ownerDataSource equals: navigationState dataSource expandedItems first childrenDataSource-=JUAMPI=-searchText: arg1  | tmp1 |  tmp1 := self itemCursor moveToItemWhich: [:arg2 |  arg2 name asLowercase beginsWith: arg1 asLowercase ].  ^tmp1 ifFalse: [ #() ] ifTrue: [ {self itemCursor position} ]-=JUAMPI=-createQuery  ^ClyPackageExtensionMethodsQuery of: ClyClass1FromP1 package from: (ClyClassScope of: ClyClass1FromP1 in: environment)-=JUAMPI=-priority  ^0-=JUAMPI=-extraBasisSample  ^ClyClass2FromP1-=JUAMPI=-addNewCommentForTestClass: arg1 basedOn: arg2  arg1 comment: (String streamContents: [:arg3 |  | tmp1 |              tmp1 := arg1 name.              tmp1 first isVowel ifTrue: [ arg3 nextPutAll: 'An ' ] ifFalse: [ arg3 nextPutAll: 'A ' ].              arg3                 nextPutAll: tmp1;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: arg2 name ])-=JUAMPI=-scope: arg1  super scope: arg1.  critiqueQuery scope: arg1-=JUAMPI=-isCaseSensitive  ^isCaseSensitive-=JUAMPI=-windowIsClosing  tools do: [:arg1 |  arg1 cleanAfterRemove ]-=JUAMPI=-applyTo: arg1  arg1 changeStateBy: [ self restoreStateOf: arg1.        self restoreNavigationStateOf: arg1.        arg1 tabManager restoreBrowserState: self ]-=JUAMPI=-classSampleWhichHasGroup  ^ClyClass1FromP1-=JUAMPI=-testConvertingWithExtraBasisObjectIfItIsAlreadyBasis  | tmp1 |  scope := self createSampleScope.  tmp1 := scope withExtraBasisObject: scope basisObjects anyOne.  self assert: tmp1 basisObjects equals: scope basisObjects-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithDeprecatedMethods >> #deprecatedMethod1) .         (ClyClassWithDeprecatedMethods >> #deprecatedMethod2) .         (ClyClassWithDeprecatedMethods >> #notDeprecatedMethod)}.  self assert: foundSelectors sorted asArray equals: #(deprecatedMethod1 deprecatedMethod2)-=JUAMPI=-testMatchesAnyStringWhenItIsBadRegex  | tmp1 |  tmp1 := ClyRegexPattern with: '!*'.  self assert: (tmp1 matches: 'any string')-=JUAMPI=-systemScope  ^systemScope ifNil: [ systemScope := navigationEnvironment systemScope ]-=JUAMPI=-closeDataSource  table initialDataSource ifNil: [ ^self dataSource close ].  table cleanupFilter.  table initialDataSource close-=JUAMPI=-doItContext  ^nil-=JUAMPI=-testExpectedMethodShouldIncludeExpectedString  self assert: ((self class >> #methodWithExpectedStringInSources) sourceCode includesSubstring: self expectedSourceCodeSubstring caseSensitive: false)-=JUAMPI=-chooseClassesForNewMethod: arg1  | tmp1 tmp2 |  tmp1 := arg1 origin.  tmp2 := self chooseClassesForNewMethod.  tmp2 := tmp2 copyWithout: tmp1.  ^tmp2 , {tmp1}-=JUAMPI=-findItemsSimilarTo: arg1  | tmp1 tmp2 |  tmp2 := arg1 select: [:arg2 |  self isBasedOnQueryOf: arg2 type ] thenCollect: [:arg2 |  arg2 browserItem ].  tmp1 := self itemCursor findItemsSimilarTo: tmp2.  ^tmp1 collect: [:arg2 |  self createElementWith: arg2 ]-=JUAMPI=-pluginsDo: arg1  ^plugins do: arg1-=JUAMPI=-isActiveInContext: arg1  ^(super isActiveInContext: arg1) and: [ self toolClass shouldBeActivatedInContext: arg1 ]-=JUAMPI=-selection: arg1  selection := arg1-=JUAMPI=-testExpandedItemWithRetrievedOwnerDataSource  | tmp1 |  self selectedItem expand.  self snapshotState.  tmp1 := navigationState dataSource expandedItems first.  self assert: tmp1 ownerDataSource equals: navigationState dataSource-=JUAMPI=-collectMetadataOf: arg1 by: arg2  arg2 collectMetadataOfClasses: arg1-=JUAMPI=-testFromClassScope  self queryFromScope: ClyClassScope ofAll: {self class .         self class superclass}.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: (ClyClassComment of: self class)-=JUAMPI=-description  ^'writers of ' , self printVariables-=JUAMPI=-testAscendingDifferentPackage  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: Object >> #printString value: Number >> #printString).  self assert: (function value: Number >> #printString value: Object >> #printString).  self assert: (function value: Object >> #printOn: value: Object >> #printString)-=JUAMPI=-lastSelectedSourceNode  ^self selectedSourceNode-=JUAMPI=-isResult: arg1 affectedBy: arg2  ^arg2 affectsClasses or: [ arg2 canAffectResultOfMethodQuery: self ]-=JUAMPI=-lastSelectedClassGroup  ^self lastSelectedObject-=JUAMPI=-testSelectsDeprecatedMethod  self assert: (query selectsMethod: ClyClassWithDeprecatedMethods >> #deprecatedMethod1)-=JUAMPI=-printOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     nextPutAll: value;     nextPut: $)-=JUAMPI=-createUpdateWithItemsStartingAt: arg1 count: arg2  | tmp1 |  tmp1 := ClyBrowserQueryCache filledBy: self startingAt: arg1 size: arg2.  ^ClyBrowserQueryUpdate of: self withItems: tmp1-=JUAMPI=-defaultPackageFilter  ^DefaultPackageFilter ifNil: [ DefaultPackageFilter := ClyTableFilterFactory of: ClyItemNameFilter using: ClyRegexPattern new ]-=JUAMPI=-decorateBrowserItem: arg1 ofMethodGroup: arg2  -=JUAMPI=-metaLevelsOf: arg1 do: arg2  self class metaLevelsOf: arg1 do: arg2-=JUAMPI=-testCheckIfEmpty  self installWatchpointInto: #methodWithWatchpoint.  query scope: (ClyMethodScope of: self class >> #methodWithWatchpoint in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-=JUAMPI=-testIsExecutedFromEmptyScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self deny: query isExecutedFromEmptyScope.  query scope: (ClyScopeExample emptyIn: environment).  self assert: query isExecutedFromEmptyScope-=JUAMPI=-buildResult: arg1  | tmp1 |  tmp1 := Set new.  scope classesDo: [:arg2 |  (self selectsClass: arg2) ifTrue: [ tmp1 add: arg2 ] ].  arg1 fillWith: tmp1-=JUAMPI=-createQueryResult  ^ClyMethodVisibilityGroups withHierarchy: ClySubclassHierarchy new-=JUAMPI=-methodGroupView  ^methodGroupView-=JUAMPI=-classCommentsContainingIt  | tmp1 |  self lineSelectAndEmptyCheck: [ ^self ].  tmp1 := ClyClassCommentsQuery withString: self selection string.  self browser spawnQueryBrowserOn: tmp1-=JUAMPI=-initialize  super initialize.  cacheGuard := Mutex new.  littleHierarchyMaxSize := 10-=JUAMPI=-isComplexRefactoring  ^true-=JUAMPI=-containerForItemsOfClass  ^SortedCollection sortBlock: ClySortSystemItemFunction ascending forBrowserItems-=JUAMPI=-announceChangesOf: arg1  self subclassResponsibility-=JUAMPI=-isEditableGroup  ^self class isEditableGroup-=JUAMPI=-browser  ^item browser-=JUAMPI=-isNavigationPanelFocused  ^navigationViews anySatisfy: [:arg1 |  arg1 hasKeyboardFocus ]-=JUAMPI=-defineTrait: arg1 notifying: arg2 startingFrom: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  arg3 isTrait ifTrue: [ tmp3 := arg3 ].  tmp1 := arg1 findTokens: Character separators.  tmp2 := tmp1 findFirst: [:arg4 |  arg4 = 'category' ].  tmp2 := tmp1 findFirst: [:arg4 |  arg4 = 'named:' ].  tmp4 := (tmp1 at: tmp2 + 1) copyWithoutAll: '#()'.  ((tmp3 isNil or: [ tmp3 instanceSide name asString ~= tmp4 ]) and: [ self includesClassNamed: tmp4 asSymbol ]) ifTrue: [ (self confirm: ((tmp4 , ' is an existing class/trait in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: tmp4 size)) ifFalse: [ ^nil ] ].  tmp5 := self defaultClassCompiler     source: arg1;     requestor: arg2;     logged: true;     evaluate.  ^tmp5 isTrait ifTrue: [ tmp5 ] ifFalse: [ nil ]-=JUAMPI=-requiredQueryResult  ^systemQuery ifNil: [ self class defaultQueryResult ] ifNotNil: [ systemQuery requiredResult ]-=JUAMPI=-selectItemsWhere: arg1  | tmp1 |  tmp1 := rootDataSource findItemsWhere: arg1.  self selectItems: tmp1-=JUAMPI=-createPackageNamed: arg1  ^packageOrganizer createPackageNamed: arg1-=JUAMPI=-itemsStartingWhere: arg1 count: arg2  ^self prepareItems: (actualResult itemsStartingWhere: arg1 count: arg2)-=JUAMPI=-testClassEnumerationOverMetaclassWhenClassSideIsLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassSideScope.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {Object class .         ProtoObject class} asSet-=JUAMPI=-notifyChanges  announcer announce: ClyEnvironmentChanged-=JUAMPI=-testFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reference1OfVar1) .         (self class >> #referenceOfAnotherVar)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfVar1-=JUAMPI=-execute  browser switchFocusToPreviousPane-=JUAMPI=-testFillingWithThreeClasVarsOfSuperclassAndSubclass  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #SubclassClassVar definedIn: ClySubclassLOfClass2FromP1) .         (ClyClassVariable named: #ClassVar2 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#ClassVar1 #ClassVar2 #SubclassClassVar)-=JUAMPI=-testClassEnumerationOverClassWhenInstanceSideIsLocalScope  | tmp1 |  scope := ClySubclassScope of: Class localScope: ClyInstanceSideScope.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := Class subclasses select: #isInstanceSide.  self assert: result asSet equals: tmp1 asSet-=JUAMPI=-packages: arg1  packages := arg1-=JUAMPI=-collectMethodGroupProviders  ^{ClyUndeclaredMethodGroupProvider new}-=JUAMPI=-affectsMethodsTaggedWith: arg1  overriddenSuperclass withAllSubclassesDo: [:arg2 |  (arg2 tagsForMethods includes: arg1) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-unionWith: arg1 as: arg2  ^ClyQuery unionFrom: arg1 , subqueries as: arg2-=JUAMPI=-execute  browser navigateForward-=JUAMPI=-isSimilarTo: arg1  self class = arg1 class ifFalse: [ ^false ].  selectedItems size = arg1 selectedItems size ifFalse: [ ^false ].  ^selectedItems allSatisfy: [:arg2 |  arg1 isAboutSelectedItem: arg2 ]-=JUAMPI=-queryClass  ^ClyVariableWritersQuery-=JUAMPI=-decorateMethodGroupTableCell: arg1 of: arg2  subqueries do: [:arg3 |  arg3 decorateMethodGroupTableCell: arg1 of: arg2 ]-=JUAMPI=-isRemoved  ^browserItem isNil or: [ ownerDataSource isParentRemoved or: [ ownerDataSource isParentCollapsed ] ]-=JUAMPI=-testConvertingToNewBasis  scope := self createSampleScope.  self assert: (scope withNewBasisObjects: #(newBasis)) identicalTo: scope.  self assert: scope basisObjects isEmpty-=JUAMPI=-adoptQuery: arg1  ^arg1-=JUAMPI=-withMetaLevel: arg1  self subclassResponsibility-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWhichInheritsAbstractClass >> #abstractMethod1) .         (ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod) .         (ClyClassWhichInheritsAbstractClass >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 #overriddenMethod)-=JUAMPI=-checkEmptyResult  scope methodsDo: [:arg1 |  (self selectsMethod: arg1) ifTrue: [ ^false ] ].  ^true-=JUAMPI=-testBuildShouldSetUpItemsFromActualResultWhenTheyReady  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self deny: (queryResult hasMetaProperty: ClyBackgroundProcessingTag).  self assert: queryResult items identicalTo: queryResult actualResult items.  self assert: queryResult items asSet equals: query scope basisObjects-=JUAMPI=-displayBlock  ^displayBlock-=JUAMPI=-buildingQuery  ^buildingQuery-=JUAMPI=-decorateBrowserItem: arg1 ofClass: arg2  -=JUAMPI=-description  ^'go backward in the navigation history'-=JUAMPI=-label  ^label-=JUAMPI=-includesMethod: arg1  ^true-=JUAMPI=-removeWithMethods  self methods do: [:arg1 |  arg1 removeFromSystem ]-=JUAMPI=-toggle  | tmp1 tmp2 |  tmp1 := RBProgramNode formatterClass.  tmp1 formatAsYouReadPolicy ifTrue: [ tmp1 formatAsYouReadPolicy: false.        textMorph model canDiscardEdits ifTrue: [ textMorph model cancelEdits ] ] ifFalse: [ tmp1 formatAsYouReadPolicy: true.        tmp2 := textMorph hasUnacceptedEdits.        textMorph model formatSourceCodeInView.        tmp2 ifFalse: [ textMorph model clearUserEdits ] ]-=JUAMPI=-switchToVariables  | tmp1 |  self changeMethodGroupQueryBy: [ tmp1 := self classScopeForMethods.        ClyAllVariablesQuery from: tmp1 , tmp1 asInheritedScope as: ClyGroupedInstanceVariables withDefaultHierarchy ]-=JUAMPI=-meaningfullObjectToAssert: arg1  ^arg1 actualObject-=JUAMPI=-activationPriority  ^0-=JUAMPI=-executesQuery: arg1  ^self isKindOf: arg1-=JUAMPI=-bindingOf: arg1  ^environment bindingOf: arg1-=JUAMPI=-oneTwo: arg1  self two: arg1-=JUAMPI=-whenEscapeKeyPressedDo: arg1  table bindKeyCombination: Character escape asShortcut toAction: arg1-=JUAMPI=-testIsAffectedByChangeOfNotAbstractMethodWhichImplementsAbstractOne  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)-=JUAMPI=-itemsStartingAt: arg1 count: arg2  | tmp1 |  tmp1 := super itemsStartingAt: arg1 count: arg2.  tmp1 do: [:arg3 |  arg3 prepareIn: environment ].  ^tmp1-=JUAMPI=-groupProviderClass  ^ClyUndeclaredMethodGroupProvider-=JUAMPI=-testGettingItemsStartingWhereConditionIsValid  | tmp1 |  queryResult fillWith: #(1 2 3 4 5 6).  tmp1 := queryResult itemsStartingWhere: [:arg1 |  arg1 > 3 ] count: 2.  self assert: tmp1 asArray equals: #(4 5)-=JUAMPI=-itemAt: arg1  ^self dataSource elementAt: arg1-=JUAMPI=-testGettingSingletonInstanceFromScratch  ClyUnknownQuery reset.  self assert: ClyUnknownQuery instance identicalTo: ClyUnknownQuery instance-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-initialize  super initialize.  excludesHaltsForTesting := true-=JUAMPI=-childrenItems  ^childrenDataSource allElements-=JUAMPI=-redoNavigationOf: arg1  redoList ifEmpty: [ ^self ].  self executeRedoBy: [ self restoreNavigationState: redoList removeLast of: arg1 ]-=JUAMPI=-openBrowserCursorFor: arg1  | tmp1 |  tmp1 := ClyBrowserQueryCursor for: self adoptForBrowser.  tmp1 openFor: arg1.  ^tmp1-=JUAMPI=-requestMultipleObjects: arg1 from: arg2  self openOn: arg2 withTitle: arg1 thenDo: [ itemsView selection isEmpty ifTrue: [ ^self findObjectsSameAsFilter ].        ^itemsView selection actualObjects ]-=JUAMPI=-superclassSenderOfMessage1  self clyReferencedMessage1-=JUAMPI=-defaultMenuItemName  ^'Convert to extension'-=JUAMPI=-isModeActive  ^activator isCommandAppliedToBrowser-=JUAMPI=-isParentCollapsed  ^self isParentExpanded not-=JUAMPI=-isActive  ^isActive-=JUAMPI=-relationScopeClasses  ^relationScopeClasses-=JUAMPI=-testExecutesConcreteQueryClass  self assert: (query executesQuery: query class).  self assert: (query executesQuery: query class superclass).  self deny: (query executesQuery: ClyQueryExampleReturningScopeBasis2)-=JUAMPI=-defaultMenuItemName  ^menuItemName-=JUAMPI=-cellColumn: arg1 row: arg2  | tmp1 |  tmp1 := self elementAt: arg2.  ^arg1 createCellFor: tmp1 in: queryView-=JUAMPI=-useFullIndentation  fullIndentation := true-=JUAMPI=-metadata  ^actualResult metadata-=JUAMPI=-execute  (DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: {analyzedObject packageName}) open-=JUAMPI=-testFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(reader1OfVar1 reader2OfVar1)-=JUAMPI=-selectedTextInterval  ^tool selectedTextInterval-=JUAMPI=-checkClassIsAbstract: arg1  arg1 withAllSuperclassesDo: [:arg2 |  arg2 methodsDo: [:arg3 |  (arg3 isAbstract and: [ (arg1 lookupSelector: arg3 selector) isAbstract ]) ifTrue: [ ^true ] ] ].  ^false-=JUAMPI=-initialize  super initialize.  properties := OrderedCollection new-=JUAMPI=-implementorClass  ^implementorMethod origin-=JUAMPI=-updateExpandingItems  self updateItems: collapsedItems.  collapsedItems := collapsedItems reject: [:arg1 |  arg1 isRemoved ]-=JUAMPI=-testFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot2 .         3 .         ClyTraitRoot2 .         2}-=JUAMPI=-restrictedByScope: arg1  ^self withScope: (scope restrictedBy: arg1)-=JUAMPI=-tableCellIcon  ^Smalltalk ui iconNamed: #haloView-=JUAMPI=-createQuery  ^ClyMethodSourcesQuery withString: self expectedSourceCodeSubstring from: (ClyClassScope of: self class in: environment)-=JUAMPI=-