basisObjects: arg1  basisObjects := arg1 asSet-======-isImplementedByClass: arg1  ^arg1 instanceSide includesBehavior: self implementorClass instanceSide-======-testComparisonWithAnotherKindOfResult  self deny: queryResult equals: ClyQueryResult new-======-selectsMethod: arg1  ^arg1 isExtension and: [ arg1 package = package ]-======-ownerTool: arg1  ownerTool := arg1.  self build-======-initialize  super initialize.  projectManagers := OrderedCollection new-======-testHasEmptyBasisObjects  scope := self createSampleScope.  self assert: scope basisObjects isEmpty-======-specialSelectorIndexes  ^specialSelectorIndexes ifNil: [ specialSelectorIndexes := selectors collect: [:arg1 |  Smalltalk specialSelectorIndexOrNil: arg1 ] ]-======-isSlow  ^false-======-focusActiveTab  tabManager focusActiveTab-======-testCaseResults: arg1  testCaseResults := arg1-======-allNavigationScopes  | tmp1 |  tmp1 := self classSelection asItemsScope: ClyBothMetaLevelClassScope.  ^super allNavigationScopes , {(self packageSelection asItemsScope: ClyPackageScope) .         tmp1 asFullHierarchyScope .         tmp1}-======-itemsStartingAt: arg1 count: arg2  ^#()-======-isAffectedByChangedMethod: arg1  ^self selectsMethod: arg1-======-buildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  scope methodsDo: [:arg2 |  (self selectsMethod: arg2) ifTrue: [ tmp1 add: arg2 ] ].  arg1 fillWith: tmp1-======-rebuildIfNeeded  self protectAccessWhile: [ needsRebuild ifTrue: [ needsRebuild := false.              self rebuild ] ]-======-createQuery  ^ClyDeprecatedMethodsQuery from: ClyClassScope of: Object in: environment-======-testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self deny: query checkEmptyResult-======-changeStateOf: arg1 by: arg2  | tmp1 |  self changeStateBy: [ arg2 value.        arg1 changesWasInitiatedByUser ifTrue: [ tmp1 := OrderedCollection new.              tabManager buildToolsOn: tmp1 for: arg1 createSelectionContext.              tabManager desiredSelection: (tmp1 collect: #class) ] ]-======-withResult: arg1  | tmp1 |  tmp1 := self copy.  tmp1 requiredResult: arg1.  ^tmp1-======-packagesDo: arg1  basisObjects do: arg1-======-execute  browser switchScopeTo: queryScope-======-update  | tmp1 tmp2 |  super update.  tmp2 := self editingText.  self pendingText asString = tmp2 ifTrue: [ self applyDecorations.        ^self ].  self hasUnacceptedEdits ifTrue: [ tmp1 := self pendingText copy ].  textModel setInitialText: tmp2.  tmp1 ifNil: [ ^self textUpdated ].  self pendingText: tmp1.  textMorph hasEditingConflicts: true.  textMorph changed-======-environment  ^environment-======-defaultMenuItemName  self hasTestResult ifFalse: [ ^'Run failed' ].  ^'Run failed (' , self testResult brokenCount asString , ')'-======-findItemsWith: arg1  | tmp1 |  self protectItemsWhile: [ tmp1 := arg1 collect: [:arg2 |  items detect: [:arg3 |  arg3 representsObjectEqualTo: arg2 ] ifNone: nil ].        tmp1 select: #notNil thenDo: [:arg4 |  arg4 prepareIn: environment ].        ^tmp1 ]-======-metalinkManagerClass  ^ExecutionCounter-======-dataSource: arg1  dataSource := arg1-======-scopeClass  ^ClySuperclassScope-======-selectedMethodItems  ^self selectedItemsOfType: ClyMethod-======-icon  ^icon-======-prepareNewResult  ^asyncResult prepareNewFor: self actualQuery in: self environment-======-extensionMethodFromRoot1Trait  -======-setUp  super setUp.  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new-======-findItemsSameAsFilter  | tmp1 |  tmp1 := table filterString asLowercase.  ^self dataSource findItemsWhere: [:arg1 |  arg1 name asLowercase = tmp1 ]-======-forceRebuild  self forceLazyRebuild.  self notifyObservers-======-browserTool: arg1  browserTool := arg1-======-rawItemsDo: arg1  actualResult rawItemsDo: arg1-======-decorateBrowserItem: arg1 ofMethod: arg2  arg2 usesUndeclares ifTrue: [ arg1 markWith: ClyUndeclaresUserTag ]-======-testComparison  self assert: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring').  self assert: (ClyMethodSourcesQuery withString: 'test substring') hash equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring') hash.  self deny: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'another substring')-======-testConvertingToInheritingScopeShouldAddTraitUsers  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asInheritingScope.  self assert: (tmp1 representsScope: ClyTraitUserScope)-======-showsFlatResult  ^(systemQuery retrievesItemsAs: ClyHierarchicalSystemItems) not-======-multipleScopeSample  | tmp1 |  tmp1 := super multipleScopeSample.  tmp1 relationScopeClasses: {ClySuperclassScope}.  ^tmp1-======-containerForChildren  ^SortedCollection sortBlock: sortFunction-======-= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^definingClass = arg1 definingClass-======-isSameAs: arg1  self size = arg1 size ifFalse: [ ^false ].  items with: arg1 items do: [:arg2 :arg3 |  arg2 actualObject == arg3 actualObject ifFalse: [ ^false ] ].  ^true-======-browser: arg1  browser := arg1-======-isResult: arg1 affectedBy: arg2  arg2 affectsCritiques ifFalse: [ ^false ].  arg1 forceLazyRebuild.  ^false-======-createQuery  ^ClyLongQueryExample from: ClyScopeExample of: String in: environment-======-testNotEmptyFromEmptyMethodScope  query scope: (ClyMethodScope emptyIn: environment).  self deny: query checkEmptyResult-======-accumulateTestMethod: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 selector.  tmp3 := (ClyClassScope of: arg1 methodClass) withInheritingScope.  tmp3 classesDo: [:arg2 |  (arg2 isTestCase and: [ arg2 isAbstract not ]) ifTrue: [ self accumulateTest: tmp1 of: arg2.              tmp2 := testCaseResults at: arg2 ifAbsentPut: [ ClyTestResultProperty new ].              tmp2 accumulateTest: tmp1 of: arg2 ] ]-======-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (Object >> #printString)}.  self assert: foundSelectors equals: #(abstractMethod1 abstractMethod2)-======-build  | tmp1 tmp2 |  tmp2 := ownerTool printContext.  tmp2 ifEmpty: [ ^self ].  self addMorphBack: (self iconNamed: #uncommentedClass) asMorph.  self addMorphBack: tmp2 asMorph.  tmp1 := IconicButton new     target: self;     actionSelector: #restoreBrowserState;     arguments: {};     labelGraphic: (self iconNamed: #forward);     color: Color transparent;     helpText: 'Move browser to ' , tmp2;     borderWidth: 0.  self addMorphBack: tmp1-======-menuItemNameFor: arg1  ^menuItemName ifNil: [ arg1 defaultToolbarItemName ]-======-position: arg1  position := arg1-======-enableFilterUsing: arg1  self enableFilter: ClyItemNameFilter using: arg1-======-selectsMethod: arg1  ^scope inheritanceAnalyzer isMethodOverriding: arg1-======-groupProviderClass  ^ClyFlagMethodGroupProvider-======-buildExtensionCheckBoxButton  extensionCheckbox := self theme newCheckboxIn: self for: self getSelected: #isExtensionActive setSelected: #toggleExtension getEnabled: nil label: 'extension' help: 'toggle check box to choose/reset package of method'.  extensionCheckbox     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap-======-reference1OfClass  ^ClyClassReferencesQueryTest-======-runBuildProcess  buildProcess := [ self buildActualResult ] newProcess.  buildProcess     name: 'Build result of ' , buildingQuery printString;     priority: Processor userBackgroundPriority.  buildProcess resume-======-classesSize  ^classQuery execute size-======-isClassTagSelected  | tmp1 |  tmp1 := tool classGroupSelection.  tmp1 isEmpty ifTrue: [ ^false ].  ^tmp1 lastSelectedItem type isBasedOnClassTag-======-execute  sourceNode nodesWithLinks do: [:arg1 |  self metalinkManagerClass removeFrom: arg1 ]-======-rebuildAllTools  tabManager updateTools.  self rebuildToolbar-======-buildResult: arg1  | tmp1 tmp2 |  tmp1 := critiqueQuery execute.  tmp2 := tmp1 items collect: [:arg2 |  arg2 sourceAnchor entity ] as: IdentitySet.  arg1 fillWith: tmp2-======-attachToSystem  -======-wantsStayInDifferentContext  self isBuilt ifFalse: [ ^false ].  self hasUnacceptedEdits ifTrue: [ ^true ].  self isTabSelected & self isExtraSelectionRequested ifTrue: [ ^true ].  self belongsToRemovedBrowserContext ifTrue: [ ^false ].  ^isManagedByUser-======-openFor: arg1  self moveToStart.  itemObserver := arg1.  queryResult subscribe: itemObserver-======-buildIsDone  self notifyObservers.  environment systemChanged: (ClyAsyncQueryIsDone with: self)-======-changesCancelled  textMorph hasUnacceptedEdits: false.  self textUpdated-======-testPrepareResultForExecutionWhenItIsSemiAsync  | tmp1 |  tmp1 := query semiAsync prepareNewResult.  self assert: tmp1 class equals: ClySemiAsyncQueryResult.  self assert: tmp1 buildingQuery identicalTo: query actualQuery.  self assert: tmp1 environment identicalTo: environment.  self assert: tmp1 isProtected-======-initialize  super initialize.  fullIndentation := false.  self cellInset: 2 @ 0-======-isCommandAvailable: arg1  ^arg1 canBeExecutedInTool: self-======-decorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color red.  arg1 definitionIcon: #smallDebug-======-itemOfThisTestMethod  ^ClyBrowserItem with: self class >> testSelector-======-browser  ^tool browser-======-methodFromTraitChild2  -======-filterField  ^table filterField-======-testNotAffectedByChangeOfSubclassMethodWhichNotOverridesSuperclass  self deny: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)-======-itemsChanged  dirty ifTrue: [ ^self ].  dirty := true.  self scheduleUpdate-======-testNotSelectsMethodWhichHasNoUndeclares  self deny: (query selectsMethod: Object >> #printString)-======-createInheritingScopeFrom: arg1  | tmp1 |  tmp1 := annotatedClass createInheritingScopeFrom: arg1.  tmp1 name: ClyClassScope inheritingScopeName.  ^tmp1-======-increasedByClassesFrom: arg1  ^self withExtraBasisObjects: arg1 collectAllClasses-======-testFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 3.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector).  self assert: (resultItems identityIncludes: self class superclass >> self targetSelector)-======-close  queryResult unsubscribe: itemObserver.  itemObserver := nil.  ^ClyClosedBrowserCursor instance-======-testCompareTwoMethods  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object >> #size value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)-======-printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  methodQuery printOn: arg1.  arg1 nextPut: $)-======-checkEmptyResult  ^self installedMethods isEmpty-======-buildItemsPerClassFrom: arg1  | tmp1 tmp2 tmp3 |  tmp1 := IdentityDictionary new.  arg1 do: [:arg2 |  tmp2 := arg2 asCalypsoBrowserItem.        tmp3 := tmp1 at: tmp2 systemDefinitionClass ifAbsentPut: [ self containerForItemsOfClass ].        tmp3 add: tmp2 ].  ^tmp1-======-actualObject: arg1  actualObject := arg1.  type := arg1 calypsoEnvironmentType-======-testIsAffectedByChangeOfAbstractMethodWhichIsImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #abstractMethod1)-======-editingMethod: arg1  editingMethod := arg1-======-isActive  ^ownerTool extendingPackage notNil-======-testFillingWithTwoEqualVarsOfDifferentSubclassesAndOneVarOfSuperclass  queryResult fillWith: {(ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN2OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN1OfClass1FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar2 #subclassSameVar #subclassSameVar)-======-testCreationUnifiedInstance  scope := self createSampleScope.  self assert: scope asUnifiedInstance identicalTo: scope-======-localMethod  -======-isBasedOnEmptyBasis  ^self basisSize = 0-======-cleanGarbageInCache  accessGuard critical: [ queryCache clyCleanGarbage ]-======-subscribe: arg1  announcer ifNil: [ announcer := Announcer new ].  announcer when: ClyEnvironmentChanged send: #itemsChanged to: arg1-======-browser: arg1  browser := arg1-======-testCreationFromTwoSameQueriesOfSameScopeButWithDifferentParameter  | tmp1 tmp2 |  tmp1 := self subqueryFromScopeOf: Array.  tmp1 scope extraParameter: #testParameter.  tmp2 := self subqueryFromScopeOf: Array.  tmp2 scope extraParameter: #testParameter2.  query := tmp1 , tmp2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {tmp1 .         tmp2} asSet.  self assert: query requiredResult identicalTo: tmp1 requiredResult-======-size  ^self protectItemsWhile: [ items size ]-======-testRetrievesMethodQuery  self snapshotState.  self assert: navigationState systemQuery equals: browser systemQuery-======-hash  ^sortFunction hash bitXor: inverse hash-======-name  ^name-======-testItemsInitializationShouldNotResetExistingItems  queryResult items: #(items).  queryResult initializeItems.  self assert: queryResult items equals: #(items)-======-printContext  ^super printContext , ' / ' , editingClass name-======-testMethodsEnumerationWhenBothMetaLevels  scope := ClyTraitUserScope of: ClyTraitRoot1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:arg1 |  result add: arg1 ].  self assert: (result includesAll: ClyTraitChild1 localMethods).  self assert: (result includesAll: ClyTraitChild1 classSide localMethods).  self assert: (result includesAll: ClyClassWithTraits localMethods).  self assert: (result includesAll: ClyClassWithTraits classSide localMethods).  self deny: (result includesAll: ClyTraitRoot1 localMethods).  self deny: (result includesAll: ClyTraitRoot1 classSide localMethods)-======-setUpActiveScope  systemQuery isBoundToEnvironment ifFalse: [ systemQuery := systemQuery withScope: self systemScope ].  (queryScopes includes: systemQuery scope) ifFalse: [ queryScopes add: systemQuery scope ].  activeScope := systemQuery scope-======-scopeNames  ^self scopes collect: [:arg1 |  arg1 description capitalized ]-======-toolWasRemoved  -======-defaultMenuItemName  ^'Jump to test class'-======-defaultNavigationScope  ^self isScopedModeEnabled ifFalse: [ super defaultNavigationScope ] ifTrue: [ packageView query scope ]-======-isAboutSelectedItem: arg1  (selectedItems anySatisfy: [:arg2 |  arg2 actualObject == arg1 actualObject ]) ifTrue: [ ^true ].  (selectedItems anySatisfy: [:arg2 |  arg2 name = arg1 name ]) ifFalse: [ ^false ].  ^selectedItems anySatisfy: [:arg2 |  arg2 isEqualTo: arg1 ]-======-checkEmptyResult  ^critiqueQuery hasEmptyResult-======-tools: arg1  tools := arg1-======-hasEmptyResult  ^scope isQueryEmpty: self-======-singleBasisSample  ^ClyClass1FromP1 package-======-toggle  textMorph lineNumbersRuler ifNil: [ textMorph withLineNumbers ] ifNotNil: [ textMorph withoutLineNumbers ].  self updateLabel-======-ensureVisibleLastItem  rootDataSource table ensureVisibleFirstSelection-======-forceRebuild  actualResult forceRebuild-======-fillStatusBar  self belongsToCurrentBrowserContext ifFalse: [ statusBar addContextItem: (ClyToolContextNavigatorMorph for: self) ]-======-hash  ^super hash bitXor: variableQuery hash-======-testMoveToItemWhichSatisfiesConditionWhenItNotExistsInCache  | tmp1 |  cursor cleanCache.  tmp1 := cursor moveToItemWhich: [:arg1 |  arg1 actualObject = Object ].  self assert: tmp1.  self assert: cursor position equals: 2.  self assert: cursor currentItem actualObject equals: Object-======-testVariableNamedThisContext_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'ThisContext') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext lookupSymbol: #ThisContext)]')-======-testNotSelectsMethodWithoutWatchpoint  self deny: (query selectsMethod: self class >> #methodWithoutWatchpoint)-======-execute  | tmp1 |  tmp1 := browser searchDialog requestSingleObject: 'Choose class' from: ClyAllClassesQuery sorted.  browser selectClass: tmp1-======-decorateBrowserItem: arg1 ofPackage: arg2  -======-testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> #method1).  self assert: (resultItems identityIncludes: self class >> #method2)-======-bindTo: arg1 in: arg2  arg1 bindTo: arg2.  self scope: arg1-======-activationPriority  ^-100-======-method1  -======-metaLevelScope: arg1  metaLevelScope := arg1-======-createBlockFromPattern  (pattern value endsWith: ']') ifFalse: [ badScript := true.        ^self ].  [ scriptBlock := self class compiler evaluate: pattern value ] on: Exception do: [:arg1 |  badScript := true ]-======-build  self addMorphBack: label-======-metadata  ^metadata ifNil: [ self collectMetadata.        metadata ]-======-updateTabsWith: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection withAll: tools.  tmp2 := OrderedCollection new.  arg1 do: [:arg2 |  tools detect: [:arg3 |  arg3 isSimilarTo: arg2 ] ifFound: [:arg3 |  tmp1 remove: arg3 ] ifNone: [ tmp2 add: arg2 ] ].  tmp1 do: [:arg4 |  arg4 wantsStayInDifferentContext ifFalse: [ arg4 removeFromBrowser ] ].  tools do: [:arg4 |  arg4 browserContextWasChanged ].  tmp2 do: [:arg4 |  self addTool: arg4 ]-======-isSameAsCurrent: arg1  isSameAsCurrent := arg1-======-adoptLocalScopeClassTo: arg1  localScopeClass := arg1-======-createQueryResult  ^ClyClassBindings new-======-requestSingleObject: arg1 from: arg2 inScope: arg3  arg3 bindTo: browser navigationEnvironment.  ^self requestSingleObject: arg1 from: (arg3 adoptQuery: arg2)-======-testBasedOnMultipleBasis  scope := self multipleScopeSample.  self assert: scope isBasedOnMultipleBasis.  scope := self singleScopeSample.  self deny: scope isBasedOnMultipleBasis.  scope := self emptyScopeSample.  self deny: scope isBasedOnMultipleBasis-======-defaultMenuIconName  ^#trait-======-critique  ^critique-======-affectsMethods  ^true-======-execute  UIManager default debugProcess: Processor activeProcess context: critique stack label: critique message fullView: true-======-testMethodsEnumeration  | tmp1 |  scope := ClyClassScope of: ClyClass1FromP1.  scope methodsDo: [:arg1 |  result add: arg1 selector ].  tmp1 := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: tmp1 sorted asArray-======-changeStateBy: arg1  arg1 value-======-execute  script executeOn: targetClass-======-initialize  super initialize.  basisObjects := #()-======-findItemsSimilarTo: arg1  | tmp1 tmp2 |  tmp1 := super findItemsSimilarTo: arg1.  tmp1 size == arg1 size ifTrue: [ ^tmp1 ].  tmp2 := expandedItems flatCollect: [:arg2 |  arg2 childrenDataSource findItemsSimilarTo: arg1 ].  ^tmp1 , tmp2-======-packagesDo: arg1  self system packages do: arg1-======-prepareExecutionInDropContext: arg1  super prepareExecutionInDropContext: arg1.  package := arg1 lastSelectedPackage-======-targetClass  ^targetClass-======-conditionBlock: arg1  conditionBlock := arg1-======-prepareInitialState  -======-basisObjects: arg1  super basisObjects: (self prepareBasisFrom: arg1)-======-decorateOwnBrowserItem: arg1  super decorateOwnBrowserItem: arg1.  classQuery decorateItemGroup: arg1.  subgroupsQuery decorateItemGroup: arg1-======-defaultMenuItemName  ^'Writers'-======-allowsDifferentActivationPriority  ^true-======-testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  < expectedFailure>  super testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject-======-readerOfVar1  ^writtenVar1-======-selectedPackageItems  ^tool packageSelection items-======-selectsMethod: arg1  | tmp1 |  tmp1 := self environment getPlugin: ClyReflectiveEnvironmentPlugin.  ^tmp1 doesMethodHasWatchpoint: arg1-======-representsConcreteQuery  ^true-======-findItemsSimilarTo: arg1  ^cache findItemsWith: (arg1 collect: #actualObject) forAbsentDo: [ ^queryResult findItemsSimilarTo: arg1 ]-======-fillWith: arg1  | tmp1 tmp2 |  tmp1 := IdentitySet withAll: arg1.  tmp2 := OrderedCollection new.  arg1 do: [:arg2 |  (self isQueryScopeDefinesClass: arg2) ifFalse: [ tmp1 remove: arg2.              tmp2 add: arg2 ] ].  items := self buildItemsFrom: tmp1.  items addAll: (self buildExtensionItemsFrom: tmp2)-======-methodGroupType  ^ClyVariable-======-isCommandAvailable: arg1  ^arg1 canBeExecutedInCodeMethodEditor: self-======-defaultMenuIconName  ^#smallRedo-======-superclassVar1WriterMethod  instanceSideVar1 := #subclassVar1Value-======-extraBasisSample  ^ClySubclassMOfClass1FromP2 package-======-testConvertingToSomeHierarchyScope  | tmp1 |  scope := self createSampleScope.  tmp1 := scope asScope: ClySubclassScope.  self assert: tmp1 class equals: ClySubclassScope.  self assert: tmp1 localScopeClass equals: scope localScopeClass.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 environment equals: environment-======-defaultItems  ^SortedCollection sortBlock: sortFunction-======-direction: arg1  direction := arg1-======-isParentExpanded  parentItem ifNil: [ ^true ].  ^parentItem isExpanded-======-testIsExecutedFromConcreteScopeClass  self assert: (query isExecutedFromScope: query scope class).  self assert: (query isExecutedFromScope: query scope class superclass).  self deny: (query isExecutedFromScope: ClyScopeExample2)-======-testConvertingAsRestrictedByAnotherScope2  | tmp1 tmp2 |  scope := self singleScopeSample.  tmp2 := self multipleScopeSample.  tmp1 := scope restrictedBy: tmp2.  self assert: tmp1 class equals: scope class.  self assert: tmp1 basisObjects equals: tmp2 basisObjects-======-classSampleWhichHasGroup  ^ClySubclassN1OfClass1FromP1-======-hash  ^super hash bitXor: pattern hash-======-start  ^start-======-isMultipleSelected  ^items size > 1-======-showVariableNamed: arg1  tool selectVariableNamed: arg1-======-includesClass: arg1  self classesDo: [:arg2 |  arg2 = arg1 ifTrue: [ ^true ] ].  ^false-======-decorateMethodGroupTableCell: arg1 of: arg2  | tmp1 |  super decorateMethodGroupTableCell: arg1 of: arg2.  tmp1 := arg1 definitionIcon: #flagIcon.  tmp1 setBalloonText: 'There are methods with flag'-======-printContext  ^''-======-description  ^'all method groups'-======-decorateResultMethodEditor: arg1  criteriaString ifNil: [ ^self ].  arg1 selectStringAsInMessageBrowser: criteriaString-======-execute  browser switchToVariables-======-variableQuery: arg1  variableQuery := arg1-======-createBrowser  ^ClyFullBrowser new-======-description  ^'Do not supported currently'-======-queryScope: arg1  queryScope := arg1-======-readParametersFromContext: arg1  super readParametersFromContext: arg1.  testItems := arg1 selectedItems select: [:arg2 |  arg2 hasProperty: ClyTestResultProperty ]-======-initialize  super initialize.  undoExecuting := false.  redoExecuting := false.  waitingNewState := true.  undoList := OrderedCollection new.  redoList := OrderedCollection new-======-createQuery  ^ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: #basisObject in: environment-======-defaultMenuItemName  ^'Run script'-======-defaultMenuItemName  ^'Move to package'-======-activeWindow  self tabGroup pages size = 0 ifTrue: [ ^nil ].  self tabGroup selectedPageIndex <= 0 ifTrue: [ ^nil ].  ^self tabGroup pages at: self tabGroup selectedPageIndex-======-initialize  super initialize.  methodTags := #()-======-testCheckIfEmpty  self installCounterInto: #methodWithCounter.  query scope: (ClyMethodScope of: self class >> #methodWithCounter in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-======-littleHierarchyMaxSize: arg1  littleHierarchyMaxSize := arg1-======-decorateMethodGroupTableCell: arg1 of: arg2  super decorateMethodGroupTableCell: arg1 of: arg2.  arg1 label color: Color red-======-affectedPackage: arg1  affectedPackage := arg1-======-execute  browser switchToProjects-======-execute  | tmp1 tmp2 |  tmp1 := methodGroups collect: [:arg1 |  arg1 methodQuery ].  tmp2 := ClyQuery unionFrom: tmp1.  browser spawnQueryBrowserOn: tmp2-======-initialize  super initialize.  collapsedItems := SortedCollection sortBlock: [:arg1 :arg2 |  arg1 position < arg2 position ]-======-readParametersFromContext: arg1  super readParametersFromContext: arg1.  browser := arg1 browser-======-isPrepared  ^isPrepared-======-defaultMenuItemName  ^'Add breakpoint condition..'-======-testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  < expectedFailure>  super testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects-======-hierarchy  ^hierarchy-======-allItems  ^self prepareItems: actualResult allItems-======-decorateBrowserItem: arg1 ofPackage: arg2  arg2 isDeprecated ifTrue: [ arg1 markWith: ClyDeprecatedItemTag ]-======-query: arg1  ^ClyUnknownQueryResult instance-======-printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  classQuery printOn: arg1.  arg1 nextPut: $)-======-methodWithoutCritiques  ^ClyClassWithProblemMethods >> #methodWithoutCritiques-======-findTestedClassCoveredBy: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := arg1 instanceSide name.  (tmp1 endsWith: 'Tests') ifTrue: [ ^environment system classNamed: (tmp1 allButLast: 5) asSymbol ifAbsent: arg2 ].  (tmp1 endsWith: 'Test') ifTrue: [ ^environment system classNamed: (tmp1 allButLast: 4) asSymbol ifAbsent: arg2 ].  ^arg2 value-======-newName  ^newName-======-prepareIn: arg1  isPrepared ifTrue: [ ^self ].  arg1 pluginsDo: [:arg2 |  self decorateBy: arg2 ].  isPrepared := true-======-tableCellIcon  ^Smalltalk ui iconNamed: #halt-======-restoreBrowserState  self browser selectObject: self lastSelectedObject-======-testConvertingAsRestrictedByAnotherScope  | tmp1 tmp2 |  tmp2 := ClyScopeExample2 of: #restrictedBasis.  tmp1 := query restrictedByScope: tmp2.  self assert: tmp1 class equals: query class.  self assert: tmp1 requiredResult identicalTo: query requiredResult.  self assert: (tmp1 subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (tmp1 subqueries collect: #scope) equals: (query subqueries collect: [:arg1 |  arg1 scope withNewBasisObjects: #(restrictedBasis) ])-======-normalizeSelectorForComparison: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 asString.  tmp2 := arg1 size.  tmp3 := tmp1 class new: tmp2.  tmp4 := 0.  1 to: tmp2 do: [:arg2 |  | tmp5 |        (tmp5 := tmp1 at: arg2) == $: ifFalse: [ tmp3 at: (tmp4 := tmp4 + 1) put: tmp5 ] ].  ^(tmp4 < tmp2 ifTrue: [ tmp3 first: tmp4 ] ifFalse: [ tmp1 ]) asLowercase-======-defaultMenuItemName  ^'Show in method browser'-======-selectsMethod: arg1  ^arg1 isExtension-======-toggleFullWindowTabs  | tmp1 |  tmp1 := tabManager tabMorph.  (submorphs includes: tmp1) ifFalse: [ self addMorph: tmp1 fullFrame: LayoutFrame identity ] ifTrue: [ toolPanel addMorphBack: tmp1 ]-======-methodGroups  ^methodGroups-======-prepareExecutionInDropContext: arg1  | tmp1 |  super prepareExecutionInDropContext: arg1.  methodGroup := arg1 lastSelectedMethodGroup.  tmp1 := arg1 selectedClasses.  tmp1 := tmp1 collect: [:arg2 |  arg1 currentMetaLevelOf: arg2 ].  targetClass := tmp1 size > 1 ifTrue: [ arg1 requestSingleClass: 'In what class you want to move method?' from: tmp1 ] ifFalse: [ tmp1 last ]-======-decorateMethodEditor: arg1  methodView query decorateResultMethodEditor: arg1-======-methodWithoutBreakpoints  -======-testCreationWithSingleSubqueryButAnotherResult  | tmp1 |  tmp1 := self subqueryFromScopeOf: Array.  query := ClyUnionQuery with: {tmp1} as: #specialResult.  self assert: query class equals: tmp1 class.  self assert: query scope equals: tmp1 scope.  self assert: query requiredResult equals: #specialResult.  self deny: tmp1 requiredResult equals: #specialResult-======-addNewCommentForTestClass: arg1 basedOn: arg2  arg1 comment: (String streamContents: [:arg3 |  | tmp1 |              tmp1 := arg1 name.              tmp1 first isVowel ifTrue: [ arg3 nextPutAll: 'An ' ] ifFalse: [ arg3 nextPutAll: 'A ' ].              arg3                 nextPutAll: tmp1;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: arg2 name ])-======-testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self deny: query isExecutedFromSingleScope-======-testClass  ^testClass-======-createTableCellButtonWith: arg1 using: arg2  | tmp1 |  tmp1 := super createTableCellButtonWith: arg1 using: arg2.  sourceNode hasExecutionCounter ifTrue: [ ClyDynamicBallonTooltip from: [ self tableDescription ] installInto: tmp1 ].  ^tmp1-======-execute  browser spawnQueryBrowserOn: (ClyVariableReferencesQuery ofAny: variables)-======-testCreationFromAnotherCompositeQueryAndSimilarQuery  | tmp1 tmp2 tmp3 |  tmp1 := self subqueryFromScopeOf: Array.  tmp2 := self subqueryFromScope: ClyScopeExample2 of: String.  tmp3 := self subqueryFromScopeOf: Object.  query := tmp1 , tmp2 , tmp3.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {(self subqueryFromScope: (ClyScopeExample ofAll: {Array .                     Object})) .         tmp2} asSet.  self assert: query requiredResult equals: tmp1 requiredResult-======-requestSingleClass: arg1  ^tool searchDialog requestSingleObject: arg1 from: ClyAllClassesQuery sorted-======-hash  ^super hash bitXor: hierarchy hash-======-packageScopeOfSelectedItems  | tmp1 |  tmp1 := self selection items collect: [:arg1 |  arg1 systemDefinition definingPackage ].  ^ClyPackageScope ofAll: tmp1 in: navigationEnvironment-======-buildsDefaultResult  ^self retrievesItemsAs: self defaultResult class-======-isMethodSelected  ^false-======-copyForBrowserStateSnapshotOf: arg1  | tmp1 tmp2 |  tmp2 := arg1 findDataSourceSameAs: ownerDataSource ifNone: [ self error: 'should not happen' ].  tmp1 := self copy.  tmp1 ownerDataSource: tmp2.  childrenDataSource ifNotNil: [ tmp1 childrenDataSource: childrenDataSource copyForBrowserStateSnapshot ].  ^tmp1-======-shouldSkipCurrentDesiredSelection  ^shouldSkipCurrentDesiredSelection-======-testResult  ^testResult-======-defaultMenuItemName  ^'Inspect'-======-ownerTool  ^ownerTool-======-simpleNameForSpotterMenu  ^'Variables'-======-fillWith: arg1  | tmp1 |  arg1 do: [:arg2 |  tmp1 := ClyExternalPackageMethodGroup withMethodsFrom: self scope packagedIn: arg2.        items add: tmp1 ]-======-canDetectAffectOnClassesBy: arg1  ^(arg1 isKindOf: ClassAnnouncement) not-======-defaultMenuIconName  ^#glamorousBrowse-======-isAssignmentSelected  | tmp1 |  tmp1 := self selectedSourceNode.  [ tmp1 notNil ] whileTrue: [ tmp1 isAssignment ifTrue: [ ^true ].        tmp1 := tmp1 parent ].  ^false-======-setUp  super setUp.  environment := nil-======-extendClassScopeForMethods: arg1  | tmp1 |  tmp1 := arg1.  (ClyMethodVisibilityLevel allAvailableFor: self classSelection items) ifNotEmpty: [:arg2 |  tmp1 := arg2 anyOne extendClassScope: tmp1 ].  ^tmp1-======-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-======-testClassEnumerationOverClassWhenBothMetaLevelsAreLocalScope  | tmp1 |  scope := ClySubclassScope of: Class localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := Class subclasses select: #isInstanceSide.  tmp1 := tmp1 flatCollect: [:arg1 |  {arg1 instanceSide .         arg1 classSide} ].  self assert: result asSet equals: tmp1 asSet-======-critique: arg1  critique := arg1-======-testComparisonToSimilarQueryButWithDifferentTag  | tmp1 |  query tag: #tag1.  tmp1 := self createQuery.  tmp1 tag: #anotherTag.  self deny: query equals: tmp1-======-open  | tmp1 tmp2 tmp3 |  tmp2 := messages select: [:arg1 |  (arg1 isRingObject and: [ arg1 isMethod ]) or: [ arg1 isCompiledMethod ] ] thenCollect: [:arg1 |  arg1 compiledMethod ].  tmp3 := messages select: [:arg1 |  arg1 isRingObject and: [ arg1 isComment ] ] thenCollect: [:arg1 |  ClyClassComment of: arg1 parent realClass ].  tmp1 := ClyOldMessageBrowserQuery named: title with: tmp2 asOrderedCollection , tmp3.  tmp1     criteriaString: autoSelect;     criteriaBlock: refreshingBlock.  openedBrowser := ClyQueryBrowser openOn: tmp1-======-isSelectedItemHasWatchpoint  ^selectedSourceNode hasWatchpoint-======-includesMethod: arg1  self asyncQueryResult isBuilt ifFalse: [ ^false ].  ^super includesMethod: arg1-======-attachToSystem  browser system when: (ClyMethodChange of: self editingMethod) send: #triggerUpdate to: self-======-referenceOfNumberClassByNameSymbol  ^#Number-======-update  leftMethod := leftMethod origin localMethodNamed: leftMethod selector ifAbsent: [ ^self ].  rightMethod := rightMethod origin localMethodNamed: rightMethod selector ifAbsent: [ ^self ].  super update.  diffMorph from: leftMethod sourceCode to: rightMethod sourceCode-======-printDefinition  ^definingPackageItem name-======-methodTags  ^methodTags-======-scopeWithCritiques  ^ClyMethodScope of: self methodWithCritiques in: environment-======-setUp  super setUp.  browser prepareInitialState-======-isClassVariable  ^true-======-browserPlugins  ^browserPlugins-======-isEmpty  ^self itemCursor itemCount = 0-======-isQueryEmpty: arg1  self isBasedOnEmptyBasis ifTrue: [ ^true ].  arg1 ensureScope: self.  ^environment isQueryEmpty: arg1-======-supeclassWriterOfVar1  writtenVar1 := #superclassValue-======-testConvertingToInheritedScope  | tmp1 |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  tmp1 := scope asInheritedScope.  self assert: (tmp1 representsScope: ClySuperclassScope).  self assert: tmp1 localScopeClass equals: ClyInstanceSideScope.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 environment equals: environment.  self assert: tmp1 name equals: ClyClassScope inheritedScopeName-======-selectMethodGroupNamed: arg1  self changeStateBy: [ self methodGroupSelection selectItemsWhere: [:arg2 |  arg2 name = arg1 ] ]-======-testDecoratingMethodWithExecutionCounter  | tmp1 tmp2 tmp3 |  tmp1 := ClyReflectiveEnvironmentPlugin new.  self installWatchpointInto: #methodWithWatchpoint.  tmp2 := self class >> #methodWithWatchpoint.  tmp3 := tmp2 asCalypsoBrowserItem.  tmp1 decorateBrowserItem: tmp3 ofMethod: tmp2.  self assert: (tmp3 isMarkedWith: ClyMethodWithWatchpointTag)-======-subgroupsQuery: arg1  subgroupsQuery := arg1-======-testForceLazyRebuild  self assert: queryResult items notNil.  queryResult forceLazyRebuild.  self assert: queryResult needsRebuild-======-createQuery  ^ClyUntaggedClassesQuery from: (ClyClassScope of: Object in: environment)-======-addContextItem: arg1  contextBar addMorphBack: arg1.  ^arg1-======-restoreTableSelectionSilently: arg1  | tmp1 |  items := items reject: [:arg2 |  arg2 isRemoved ].  tmp1 := items collect: #globalPosition.  self setUpSelectedRows: tmp1 in: rootDataSource table silently: arg1-======-includesVariablesAffectedBy: arg1  self classesDo: [:arg2 |  (arg1 affectsVariablesOf: arg2) ifTrue: [ ^true ] ].  ^false-======-createQuery  ^ClyMethodWatchpointsQuery from: ClyClassScope of: self class in: environment-======-collapsedButton  ^IconicButton new     target: item;     actionSelector: #expand;     arguments: {};     labelGraphic: self theme treeUnexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-======-senderOfIfTrue  ^2 * 2 = 4 ifTrue: [ 100 ]-======-hash  ^super hash bitXor: baseQueryResult hash-======-affectsMethodsDefinedInClass: arg1  ^(arg1 includesLocalSelector: self overriddenMethod selector) and: [ arg1 inheritsFrom: self overriddenMethod origin ]-======-context  ^context-======-retrievesItem: arg1  ^arg1 isKindOf: ClyInstanceVariable-======-testFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}-======-packageOrganizer  ^packageOrganizer-======-itemsChanged  navigationStarted ifTrue: [ ^self ].  navigationStarted := true.  [ self rebuildToolsForChangedEnvironment ] ensure: [ navigationStarted := false ]-======-actualObject: arg1  ^browserItem actualObject: arg1-======-withInheritedScope  | tmp1 |  tmp1 := self , self asInheritedScope.  tmp1 name: self class hierarchyScopeName.  ^tmp1-======-deprecatedMethod2  self deprecated: 'it is deprecated method for testing deprecation analyzis'-======-testConvertingToInterestingClassScope  | tmp1 |  scope := ClyMultipleClassRelationScope of: {String} merging: {ClySuperclassScope .         ClySubclassScope}.  scope localScopeClass: ClyInstanceSideScope.  tmp1 := scope asInterestingClassScope.  self deny: tmp1 identicalTo: scope.  self assert: tmp1 class equals: ClyMultipleClassRelationScope.  self assert: tmp1 relationScopeClasses equals: {ClyInterestingSuperclassScope .         ClySubclassScope}.  self assert: tmp1 basisObjects equals: scope basisObjects.  self assert: tmp1 localScopeClass equals: scope localScopeClass.  self assert: tmp1 environment equals: scope environment-======-testExecution  | tmp1 tmp2 |  tmp1 := ClyScopeExample ofAll: {self class superclass .         self class} in: environment.  tmp2 := ClyQueryExampleReturningScopeBasis from: tmp1.  query subqueries: {tmp2}.  self executeQuery.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self class-======-groupProviderClass  ^ClyExtendedClassGroupProvider-======-isResult: arg1 affectedBy: arg2  ^arg2 affectsClassExtension and: [ scope includesMethodsAffectedBy: arg2 ]-======-ownerDataSource  ^ownerDataSource-======-buildResult: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self analyzedObjectsDo: [:arg2 |  tmp1 addAll: arg2 critiques ].  arg1 fillWith: tmp1-======-execute  browser navigateBack-======-execute  browser spawnQueryBrowserOn: (ClyClassReferencesQuery toAny: classes)-======-isExecutedFromSingleScope  ^scope isBasedOnSingleBasis-======-testNotBasedOnSingleBasisWhenSingleSubscopeIsNot  | tmp1 |  tmp1 := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {tmp1}.  self deny: scope isBasedOnSingleBasis-======-detachFromTextMorph  -======-description  ^'Method watchpoints'-======-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-======-defaultIconName  ^#scriptManagerIcon-======-name: arg1  name := arg1-======-withoutBasisObject: arg1  ^self withNewBasisObjects: (basisObjects copyWithout: arg1)-======-testSelectedChildInExpandedItemWithRetrievedExpandedDataSource  | tmp1 tmp2 |  self selectedItem expand.  tmp1 := self selectedItem childrenDataSource elementAt: 1.  queryView selection selectItems: {tmp1}.  self snapshotState.  tmp2 := navigationState selection items first.  self assert: tmp2 ownerDataSource equals: navigationState dataSource expandedItems first childrenDataSource-======-searchText: arg1  | tmp1 |  tmp1 := self itemCursor moveToItemWhich: [:arg2 |  arg2 name asLowercase beginsWith: arg1 asLowercase ].  ^tmp1 ifFalse: [ #() ] ifTrue: [ {self itemCursor position} ]-======-createQuery  ^ClyPackageExtensionMethodsQuery of: ClyClass1FromP1 package from: (ClyClassScope of: ClyClass1FromP1 in: environment)-======-priority  ^0-======-extraBasisSample  ^ClyClass2FromP1-======-addNewCommentForTestClass: arg1 basedOn: arg2  arg1 comment: (String streamContents: [:arg3 |  | tmp1 |              tmp1 := arg1 name.              tmp1 first isVowel ifTrue: [ arg3 nextPutAll: 'An ' ] ifFalse: [ arg3 nextPutAll: 'A ' ].              arg3                 nextPutAll: tmp1;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: arg2 name ])-======-scope: arg1  super scope: arg1.  critiqueQuery scope: arg1-======-isCaseSensitive  ^isCaseSensitive-======-windowIsClosing  tools do: [:arg1 |  arg1 cleanAfterRemove ]-======-applyTo: arg1  arg1 changeStateBy: [ self restoreStateOf: arg1.        self restoreNavigationStateOf: arg1.        arg1 tabManager restoreBrowserState: self ]-======-classSampleWhichHasGroup  ^ClyClass1FromP1-======-testConvertingWithExtraBasisObjectIfItIsAlreadyBasis  | tmp1 |  scope := self createSampleScope.  tmp1 := scope withExtraBasisObject: scope basisObjects anyOne.  self assert: tmp1 basisObjects equals: scope basisObjects-======-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithDeprecatedMethods >> #deprecatedMethod1) .         (ClyClassWithDeprecatedMethods >> #deprecatedMethod2) .         (ClyClassWithDeprecatedMethods >> #notDeprecatedMethod)}.  self assert: foundSelectors sorted asArray equals: #(deprecatedMethod1 deprecatedMethod2)-======-testMatchesAnyStringWhenItIsBadRegex  | tmp1 |  tmp1 := ClyRegexPattern with: '!*'.  self assert: (tmp1 matches: 'any string')-======-systemScope  ^systemScope ifNil: [ systemScope := navigationEnvironment systemScope ]-======-closeDataSource  table initialDataSource ifNil: [ ^self dataSource close ].  table cleanupFilter.  table initialDataSource close-======-doItContext  ^nil-======-testExpectedMethodShouldIncludeExpectedString  self assert: ((self class >> #methodWithExpectedStringInSources) sourceCode includesSubstring: self expectedSourceCodeSubstring caseSensitive: false)-======-chooseClassesForNewMethod: arg1  | tmp1 tmp2 |  tmp1 := arg1 origin.  tmp2 := self chooseClassesForNewMethod.  tmp2 := tmp2 copyWithout: tmp1.  ^tmp2 , {tmp1}-======-findItemsSimilarTo: arg1  | tmp1 tmp2 |  tmp2 := arg1 select: [:arg2 |  self isBasedOnQueryOf: arg2 type ] thenCollect: [:arg2 |  arg2 browserItem ].  tmp1 := self itemCursor findItemsSimilarTo: tmp2.  ^tmp1 collect: [:arg2 |  self createElementWith: arg2 ]-======-pluginsDo: arg1  ^plugins do: arg1-======-isActiveInContext: arg1  ^(super isActiveInContext: arg1) and: [ self toolClass shouldBeActivatedInContext: arg1 ]-======-selection: arg1  selection := arg1-======-testExpandedItemWithRetrievedOwnerDataSource  | tmp1 |  self selectedItem expand.  self snapshotState.  tmp1 := navigationState dataSource expandedItems first.  self assert: tmp1 ownerDataSource equals: navigationState dataSource-======-collectMetadataOf: arg1 by: arg2  arg2 collectMetadataOfClasses: arg1-======-testFromClassScope  self queryFromScope: ClyClassScope ofAll: {self class .         self class superclass}.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: (ClyClassComment of: self class)-======-description  ^'writers of ' , self printVariables-======-testAscendingDifferentPackage  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: Object >> #printString value: Number >> #printString).  self assert: (function value: Number >> #printString value: Object >> #printString).  self assert: (function value: Object >> #printOn: value: Object >> #printString)-======-lastSelectedSourceNode  ^self selectedSourceNode-======-isResult: arg1 affectedBy: arg2  ^arg2 affectsClasses or: [ arg2 canAffectResultOfMethodQuery: self ]-======-lastSelectedClassGroup  ^self lastSelectedObject-======-testSelectsDeprecatedMethod  self assert: (query selectsMethod: ClyClassWithDeprecatedMethods >> #deprecatedMethod1)-======-printOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     nextPutAll: value;     nextPut: $)-======-createUpdateWithItemsStartingAt: arg1 count: arg2  | tmp1 |  tmp1 := ClyBrowserQueryCache filledBy: self startingAt: arg1 size: arg2.  ^ClyBrowserQueryUpdate of: self withItems: tmp1-======-defaultPackageFilter  ^DefaultPackageFilter ifNil: [ DefaultPackageFilter := ClyTableFilterFactory of: ClyItemNameFilter using: ClyRegexPattern new ]-======-decorateBrowserItem: arg1 ofMethodGroup: arg2  -======-metaLevelsOf: arg1 do: arg2  self class metaLevelsOf: arg1 do: arg2-======-testCheckIfEmpty  self installWatchpointInto: #methodWithWatchpoint.  query scope: (ClyMethodScope of: self class >> #methodWithWatchpoint in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-======-testIsExecutedFromEmptyScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self deny: query isExecutedFromEmptyScope.  query scope: (ClyScopeExample emptyIn: environment).  self assert: query isExecutedFromEmptyScope-======-buildResult: arg1  | tmp1 |  tmp1 := Set new.  scope classesDo: [:arg2 |  (self selectsClass: arg2) ifTrue: [ tmp1 add: arg2 ] ].  arg1 fillWith: tmp1-======-createQueryResult  ^ClyMethodVisibilityGroups withHierarchy: ClySubclassHierarchy new-======-methodGroupView  ^methodGroupView-======-classCommentsContainingIt  | tmp1 |  self lineSelectAndEmptyCheck: [ ^self ].  tmp1 := ClyClassCommentsQuery withString: self selection string.  self browser spawnQueryBrowserOn: tmp1-======-initialize  super initialize.  cacheGuard := Mutex new.  littleHierarchyMaxSize := 10-======-isComplexRefactoring  ^true-======-containerForItemsOfClass  ^SortedCollection sortBlock: ClySortSystemItemFunction ascending forBrowserItems-======-announceChangesOf: arg1  self subclassResponsibility-======-isEditableGroup  ^self class isEditableGroup-======-browser  ^item browser-======-isNavigationPanelFocused  ^navigationViews anySatisfy: [:arg1 |  arg1 hasKeyboardFocus ]-======-defineTrait: arg1 notifying: arg2 startingFrom: arg3  | tmp1 tmp2 tmp3 tmp4 tmp5 |  arg3 isTrait ifTrue: [ tmp3 := arg3 ].  tmp1 := arg1 findTokens: Character separators.  tmp2 := tmp1 findFirst: [:arg4 |  arg4 = 'category' ].  tmp2 := tmp1 findFirst: [:arg4 |  arg4 = 'named:' ].  tmp4 := (tmp1 at: tmp2 + 1) copyWithoutAll: '#()'.  ((tmp3 isNil or: [ tmp3 instanceSide name asString ~= tmp4 ]) and: [ self includesClassNamed: tmp4 asSymbol ]) ifTrue: [ (self confirm: ((tmp4 , ' is an existing class/trait in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: tmp4 size)) ifFalse: [ ^nil ] ].  tmp5 := self defaultClassCompiler     source: arg1;     requestor: arg2;     logged: true;     evaluate.  ^tmp5 isTrait ifTrue: [ tmp5 ] ifFalse: [ nil ]-======-requiredQueryResult  ^systemQuery ifNil: [ self class defaultQueryResult ] ifNotNil: [ systemQuery requiredResult ]-======-selectItemsWhere: arg1  | tmp1 |  tmp1 := rootDataSource findItemsWhere: arg1.  self selectItems: tmp1-======-createPackageNamed: arg1  ^packageOrganizer createPackageNamed: arg1-======-itemsStartingWhere: arg1 count: arg2  ^self prepareItems: (actualResult itemsStartingWhere: arg1 count: arg2)-======-testClassEnumerationOverMetaclassWhenClassSideIsLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassSideScope.  scope classesDo: [:arg1 |  result add: arg1 ].  self assert: result asSet equals: {Object class .         ProtoObject class} asSet-======-notifyChanges  announcer announce: ClyEnvironmentChanged-======-testFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reference1OfVar1) .         (self class >> #referenceOfAnotherVar)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfVar1-======-execute  browser switchFocusToPreviousPane-======-testFillingWithThreeClasVarsOfSuperclassAndSubclass  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #SubclassClassVar definedIn: ClySubclassLOfClass2FromP1) .         (ClyClassVariable named: #ClassVar2 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#ClassVar1 #ClassVar2 #SubclassClassVar)-======-testClassEnumerationOverClassWhenInstanceSideIsLocalScope  | tmp1 |  scope := ClySubclassScope of: Class localScope: ClyInstanceSideScope.  scope classesDo: [:arg1 |  result add: arg1 ].  tmp1 := Class subclasses select: #isInstanceSide.  self assert: result asSet equals: tmp1 asSet-======-packages: arg1  packages := arg1-======-collectMethodGroupProviders  ^{ClyUndeclaredMethodGroupProvider new}-======-affectsMethodsTaggedWith: arg1  overriddenSuperclass withAllSubclassesDo: [:arg2 |  (arg2 tagsForMethods includes: arg1) ifTrue: [ ^true ] ].  ^false-======-unionWith: arg1 as: arg2  ^ClyQuery unionFrom: arg1 , subqueries as: arg2-======-execute  browser navigateForward-======-isSimilarTo: arg1  self class = arg1 class ifFalse: [ ^false ].  selectedItems size = arg1 selectedItems size ifFalse: [ ^false ].  ^selectedItems allSatisfy: [:arg2 |  arg1 isAboutSelectedItem: arg2 ]-======-queryClass  ^ClyVariableWritersQuery-======-decorateMethodGroupTableCell: arg1 of: arg2  subqueries do: [:arg3 |  arg3 decorateMethodGroupTableCell: arg1 of: arg2 ]-======-isRemoved  ^browserItem isNil or: [ ownerDataSource isParentRemoved or: [ ownerDataSource isParentCollapsed ] ]-======-testConvertingToNewBasis  scope := self createSampleScope.  self assert: (scope withNewBasisObjects: #(newBasis)) identicalTo: scope.  self assert: scope basisObjects isEmpty-======-adoptQuery: arg1  ^arg1-======-withMetaLevel: arg1  self subclassResponsibility-======-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWhichInheritsAbstractClass >> #abstractMethod1) .         (ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod) .         (ClyClassWhichInheritsAbstractClass >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 #overriddenMethod)-======-checkEmptyResult  scope methodsDo: [:arg1 |  (self selectsMethod: arg1) ifTrue: [ ^false ] ].  ^true-======-testBuildShouldSetUpItemsFromActualResultWhenTheyReady  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self deny: (queryResult hasMetaProperty: ClyBackgroundProcessingTag).  self assert: queryResult items identicalTo: queryResult actualResult items.  self assert: queryResult items asSet equals: query scope basisObjects-======-displayBlock  ^displayBlock-======-buildingQuery  ^buildingQuery-======-decorateBrowserItem: arg1 ofClass: arg2  -======-description  ^'go backward in the navigation history'-======-label  ^label-======-includesMethod: arg1  ^true-======-removeWithMethods  self methods do: [:arg1 |  arg1 removeFromSystem ]-======-toggle  | tmp1 tmp2 |  tmp1 := RBProgramNode formatterClass.  tmp1 formatAsYouReadPolicy ifTrue: [ tmp1 formatAsYouReadPolicy: false.        textMorph model canDiscardEdits ifTrue: [ textMorph model cancelEdits ] ] ifFalse: [ tmp1 formatAsYouReadPolicy: true.        tmp2 := textMorph hasUnacceptedEdits.        textMorph model formatSourceCodeInView.        tmp2 ifFalse: [ textMorph model clearUserEdits ] ]-======-switchToVariables  | tmp1 |  self changeMethodGroupQueryBy: [ tmp1 := self classScopeForMethods.        ClyAllVariablesQuery from: tmp1 , tmp1 asInheritedScope as: ClyGroupedInstanceVariables withDefaultHierarchy ]-======-meaningfullObjectToAssert: arg1  ^arg1 actualObject-======-activationPriority  ^0-======-executesQuery: arg1  ^self isKindOf: arg1-======-bindingOf: arg1  ^environment bindingOf: arg1-======-oneTwo: arg1  self two: arg1-======-whenEscapeKeyPressedDo: arg1  table bindKeyCombination: Character escape asShortcut toAction: arg1-======-testIsAffectedByChangeOfNotAbstractMethodWhichImplementsAbstractOne  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)-======-itemsStartingAt: arg1 count: arg2  | tmp1 |  tmp1 := super itemsStartingAt: arg1 count: arg2.  tmp1 do: [:arg3 |  arg3 prepareIn: environment ].  ^tmp1-======-groupProviderClass  ^ClyUndeclaredMethodGroupProvider-======-testGettingItemsStartingWhereConditionIsValid  | tmp1 |  queryResult fillWith: #(1 2 3 4 5 6).  tmp1 := queryResult itemsStartingWhere: [:arg1 |  arg1 > 3 ] count: 2.  self assert: tmp1 asArray equals: #(4 5)-======-itemAt: arg1  ^self dataSource elementAt: arg1-======-testGettingSingletonInstanceFromScratch  ClyUnknownQuery reset.  self assert: ClyUnknownQuery instance identicalTo: ClyUnknownQuery instance-======-parserClass  ^RBParser-======-initialize  super initialize.  excludesHaltsForTesting := true-======-childrenItems  ^childrenDataSource allElements-======-redoNavigationOf: arg1  redoList ifEmpty: [ ^self ].  self executeRedoBy: [ self restoreNavigationState: redoList removeLast of: arg1 ]-======-openBrowserCursorFor: arg1  | tmp1 |  tmp1 := ClyBrowserQueryCursor for: self adoptForBrowser.  tmp1 openFor: arg1.  ^tmp1-======-requestMultipleObjects: arg1 from: arg2  self openOn: arg2 withTitle: arg1 thenDo: [ itemsView selection isEmpty ifTrue: [ ^self findObjectsSameAsFilter ].        ^itemsView selection actualObjects ]-======-superclassSenderOfMessage1  self clyReferencedMessage1-======-defaultMenuItemName  ^'Convert to extension'-======-isModeActive  ^activator isCommandAppliedToBrowser-======-isParentCollapsed  ^self isParentExpanded not-======-isActive  ^isActive-======-relationScopeClasses  ^relationScopeClasses-======-testExecutesConcreteQueryClass  self assert: (query executesQuery: query class).  self assert: (query executesQuery: query class superclass).  self deny: (query executesQuery: ClyQueryExampleReturningScopeBasis2)-======-defaultMenuItemName  ^menuItemName-======-cellColumn: arg1 row: arg2  | tmp1 |  tmp1 := self elementAt: arg2.  ^arg1 createCellFor: tmp1 in: queryView-======-useFullIndentation  fullIndentation := true-======-metadata  ^actualResult metadata-======-execute  (DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: {analyzedObject packageName}) open-======-testFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(reader1OfVar1 reader2OfVar1)-======-selectedTextInterval  ^tool selectedTextInterval-======-checkClassIsAbstract: arg1  arg1 withAllSuperclassesDo: [:arg2 |  arg2 methodsDo: [:arg3 |  (arg3 isAbstract and: [ (arg1 lookupSelector: arg3 selector) isAbstract ]) ifTrue: [ ^true ] ] ].  ^false-======-initialize  super initialize.  properties := OrderedCollection new-======-implementorClass  ^implementorMethod origin-======-updateExpandingItems  self updateItems: collapsedItems.  collapsedItems := collapsedItems reject: [:arg1 |  arg1 isRemoved ]-======-testFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot2 .         3 .         ClyTraitRoot2 .         2}-======-restrictedByScope: arg1  ^self withScope: (scope restrictedBy: arg1)-======-tableCellIcon  ^Smalltalk ui iconNamed: #haloView-======-createQuery  ^ClyMethodSourcesQuery withString: self expectedSourceCodeSubstring from: (ClyClassScope of: self class in: environment)-======-