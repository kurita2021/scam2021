forceLazyRebuild  setUpModelFromContext  super setUpModelFromContext.  context isPackageSelected ifTrue: [ package := context lastSelectedPackage ].  context isClassTagSelected ifTrue: [ classTag := context lastSelectedClassTag ]prepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  browser := aToolContext browsermethodView  ^methodViewinitialize  super initialize.  tools := SortedCollection sortBlock: [:a :b |  a tabOrder <= b tabOrder ].  selectionPriorities := IdentityDictionary new.  desiredSelection := IdentitySet new.  shouldSkipCurrentDesiredSelection := false.  updatingStarted := false.  tabMorph := TabManagerMorph new.  tabMorph useSortedTabsBy: [:a :b |  a model tabOrder <= b model tabOrder ].  tabMorph     hResizing: #spaceFill;     vResizing: #spaceFillshowsItemsFromQuery: aTypedQueryClass  ^self query executesQuery: aTypedQueryClassbuildGroupsFrom: aClassScope  | groups |  groups := IdentityDictionary new.  aClassScope classesDo: [:eachClass |  eachClass tagsForAllMethods do: [:eachTag |  groups at: eachTag ifAbsentPut: [ ClyTaggedMethodGroup withMethodsFrom: aClassScope taggedBy: eachTag ] ] ].  ^groups valuesdefaultMenuItemName  ^'Projects'applyTo: aBrowser byUndo: undoExecuting  self applyTo: aBrowserdecorateMethodGroupTableCell: anItemCellMorph of: groupItem  self subclassResponsibilitydefaultMenuItemName  self hasTestResult ifFalse: [ ^'Run all' ].  ^'Run all (' , self testResult allCount asString , ')'definitionString: anObject  definitionString := anObjectexecuteCommand  [ super executeCommand ] on: Exception fork: [:exc |  exc pass ]runBuildProcess  | semaphore |  asyncModeIsActive := false.  semaphore := Semaphore new.  buildProcess := [ self buildActualResult.  semaphore signal ] forkAt: Processor userBackgroundPriority named: 'Build result of ' , buildingQuery printString.  semaphore wait: 500 milliSeconds.  asyncModeIsActive := buildProcess notNilprepareFullExecutionInContext: aToolContext  super prepareFullExecutionInContext: aToolContext.  codeObjects := aToolContext selectedObjectsclassSampleWhichHasGroup  ^ClyClassWithUndeclarestestIsAffectedByChangeOfOwnMethodWhichIsOverridden  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #overriddenMethod)switchToPackageScopeOf: packages  | query scope |  scope := ClyPackageScope ofAll: packages in: navigationEnvironment.  scope name: 'Scoped pckg'.  query := ClyAllPackagesQuery sortedFrom: scope.  packageView showQuery: queryselectsMethod: aMethod  | plugin |  plugin := self environment getPlugin: ClyReflectiveEnvironmentPlugin.  ^plugin doesMethodHasExecutionCounter: aMethodrestoreStateOf: aBrowser  super restoreStateOf: aBrowser.  aBrowser     systemQuery: methodQuery;     queryScopes: queryScopes;     activeScope: activeScope;     expectedFlatQueryResult: expectedFlatQueryResultbuildParentMap: aHierarchyMap for: aClass  self subclassResponsibilitymetalinkManagerClass  ^BreakpointbindTo: aNavigationEnvironment  environment ifNil: [ environment := aNavigationEnvironment ].  environment == aNavigationEnvironment ifFalse: [ self error: 'Scope should never be rebound to new environment' ]detectDefiningClassFrom: anUserClass  self detectDefiningClassFrom: anUserClass ifAbsent: [ self error: 'Cant find the class defining variable' ]defaultMenuItemName  ^'Class refs.'selectedClassOrMetaClass  ^self methodClasstestSelectsClassWithoutTags  self assert: (query selectsClass: ClyClass6UntaggedFromP5)resetStateForSnapshot  owner := nil.  submorphs := EmptyArray.  extension := nil.  browser := nil.  context := nil.  containerTab := nil.  statusBar := nil.  isDirty := false.  decorators := niltestPrepareResultForExecution  | preparedResult |  preparedResult := query prepareNewResult.  self assert: preparedResult class equals: query requiredResult class.  self assert: preparedResult buildingQuery identicalTo: query.  self assert: preparedResult environment identicalTo: environmentbrowserItem  ^browserItemtestComparison  self assert: (ClyClassReferencesQuery to: Point) equals: (ClyClassReferencesQuery to: Point).  self assert: (ClyClassReferencesQuery to: Point) hash equals: (ClyClassReferencesQuery to: Point) hash.  self deny: (ClyClassReferencesQuery to: Point) equals: (ClyClassReferencesQuery to: Rectangle)itemDepth  ^itemDepth ifNil: [ item depth ]representsConcreteQuery  ^(viewStates allSatisfy: [:each |  each representsConcreteQuery not ]) notexpandedItems: items  expandedItems := itemstestVariablesEnumerationForTwoClassesWithClassAndInstanceVars  scope := ClyClassScope ofAll: {Object .         ClyClass1FromP1}.  scope variablesDo: [:each |  result add: each ].  self assert: (result as: Set) equals: {(ClyClassVariable named: #DependentsFields definedIn: Object) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar1 definedIn: ClyClass1FromP1)} asSetdescription  ^'Run the script'build  matchesString: aString  ^pattern matches: aStringquery  ^self dataSource querytestConvertingToInheritedScopeShouldAddInheritedTraits  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asInheritedScope.  self assert: (convertedScope representsScope: ClyInheritedTraitScope)switchToFlatClasses  | classQueries |  classQueries := OrderedCollection new.  packageView selection groupItemsByTypeAndDo: [:typeClass :items |  classQueries addAll: (typeClass prepareClassQueriesFrom: items in: navigationEnvironment) ].  classView showQueries: classQueries as: ClyExtensionLastSortedClasses hierarchicaltestMethodsEnumerationWhenInstanceSideMetaLevel  | subclassMethods |  scope := ClySubclassScope of: ClyClass1FromP1.  scope localScopeClass: ClyInstanceSideScope.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyClass1FromP1 subclasses first localMethods).  subclassMethods := ClyClass1FromP1 subclasses flatCollect: [:each |  each classSide localMethods ].  self assert: subclassMethods notEmpty.  self deny: (result includesAll: subclassMethods)testSelectedTabsAreNotBuild  | tab |  self snapshotState.  tab := navigationState selectedTabs first.  self deny: tab isBuiltbuild  roots := IdentitySet withAll: classes.  parentMap := IdentityDictionary new.  classes do: [:each |  hierarchy buildParentMap: self for: each ]description  ^groupNameshouldBuildGroupWith: aMethodQuery  ^truebuildGroupsFor: aPackage  | classScope |  classScope := ClyPackageScope of: aPackage in: environment.  groupProvider classGroupsIn: classScope do: [:each |  builtGroups add: each ]prepareFullExecutionInContext: aBrowserContext  super prepareFullExecutionInContext: aBrowserContext.  package := aBrowserContext lastSelectedPackage.  aBrowserContext isClassTagSelected ifTrue: [ classTag := aBrowserContext lastSelectedClassTag ]testBasedOnBasisObject  scope := self createSampleScope.  self assert: (scope isBasedOn: scope basisObjects anyOne).  self deny: (scope isBasedOn: #anotherObject)testViewDataSourceIsNotDetatchedAfterSnapshoting  self snapshotState.  self assert: (viewDataSource queryResult hasSubscriber: viewDataSource)browserPlugins: anObject  browserPlugins := anObjecttestConvertingWithNewScopeBasis  | convertedQuery |  convertedQuery := query withScopeOf: #(newBasis).  self assert: convertedQuery class equals: query class.  self assert: convertedQuery requiredResult identicalTo: query requiredResult.  self assert: (convertedQuery subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (convertedQuery subqueries collect: #scope) equals: (query subqueries collect: [:each |  each scope withNewBasisObjects: #(newBasis) ])adoptForBrowser  ^selfdetectDefiningClassFrom: anUserClass  self subclassResponsibilitypackageOrganizer: anObject  packageOrganizer := anObjecteditingText  self subclassResponsibilityfindItemsSimilarTo: sampleEnvironmentItems  ^#()testCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #sender1OfMessage1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #senderOfMessage2 in: environment).  self assert: query checkEmptyResultcreateQueryResult  ^ClyHierarchicalSystemItems newprintOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: self name;     nextPut: $)coveringTestCase: anObject  coveringTestCase := anObjectcleanAfterRemove  self detachFromSystem.  decorators do: [:each |  each toolWasRemoved ]removeMethodFromCache: aMethod  | classes |  classes := allImplementorsCache at: aMethod selector ifAbsent: [ ^self ].  classes remove: aMethod methodClass ifAbsent: [  ].  (classes isEmpty or: [ classes allSatisfy: [:each |  each isNil or: [ each isObsolete ] ] ]) ifTrue: [ allImplementorsCache removeKey: aMethod selector ]switchToMethod: aMethod  self detachFromSystem.  editingMethod := aMethod.  self attachToSystem.  browser selectMethod: editingMethod.  self updateadoptLocalScopeClassTo: aLocalScopeClass  addBarForLabelIndentation  | placeForExpansionRequired mainItemsCount absentItemsCount requiredWidth |  placeForExpansionRequired := item rootDataSource definesChildren.  mainItemsCount := placeForExpansionRequired ifTrue: [ 2 ] ifFalse: [ 1 ].  absentItemsCount := mainItemsCount - submorphs size.  requiredWidth := absentItemsCount * 16 + (self itemDepth * 8).  requiredWidth = 0 ifTrue: [ ^self ].  self addMorphBack: (self emptyBarWithWidth: requiredWidth)calypsoEnvironmentType  ^self classtestFillingWithOneCritique  | method critique group |  method := ClyClassWithProblemMethods >> #methodWithHalt.  critique := method critiques anyOne.  queryResult fillWith: {critique}.  self assert: queryResult size equals: 1.  group := queryResult items first.  self assert: group class equals: ClyConcreteCritiqueMethodGroup.  self assert: group name equals: critique rule group asLowercase.  self assert: group ruleSeverity name equals: critique rule severitysetUpEnvironment  super setUpEnvironment.  environment addPlugin: ClyReflectiveEnvironmentPlugin newtestClassesEnumeration  scope := ClyPackageScope of: ClyClass1FromP1 package.  scope classesDo: [:each |  result add: each ].  self assert: (result includesAll: ClyClass1FromP1 package definedClasses).  self deny: (result includesAll: ClyClass1FromP1 package extendedClasses)supportsExpansion  ^ownerDataSource definesChildrencreateMethodQueryFrom: aClassScope  ^(ClyAllProblemMethodQuery from: aClassScope) asynccountChildrenOf: aDataSourceItem  | environmentItem |  environmentItem := aDataSourceItem browserItem.  ^environmentItem localHierarchySizedetectActiveState  extraClassScope classesDo: [:each |  (visibleClassScope includesClass: each) ifTrue: [ ^isActive := true ] ].  isActive := falsebuildResult: aQueryResult  | fullResult filteredItems |  fullResult := self actualQuery execute.  filteredItems := fullResult items select: [:each |  itemFilter matches: each ] thenCollect: [:each |  each adoptForNewCalypsoQuery ].  aQueryResult items: filteredItemsbuild  self buildTextMorph.  textModel clearUndoManager.  self subscribeOnTextChanges.  textMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorph: textMorphapplyBreakpointCondition: aBreakpoint  self subclassResponsibilityrenameMethodTagTo: newTag  newTag = self tag ifTrue: [ ^self ].  self methods do: [:each |  each tagWith: newTag.        each untagFrom: self tag ].  methodQuery scope classesDo: [:each |  (each tagsForMethods includes: newTag) ifFalse: [ each addMethodTag: newTag ].        each removeMethodTag: self tag ]isMethodOverridden: aMethod  | classes methodClass |  (self isClassCheapForOverriddenMethodsAnalysis: aMethod methodClass) ifTrue: [ ^aMethod isOverridden ].  classes := self implementorsOf: aMethod.  methodClass := aMethod methodClass.  ^classes anySatisfy: [:each |  each notNil and: [ (each inheritsFrom: methodClass) and: [ each isObsolete not ] ] ]coveringTest  ^coveringTestbrowserItem  ^item browserItemclassSampleWhichHasGroup  ^ClyClass1FromP1hash  ^super hash bitXor: selectors hashisReferencedIn: aMethod  (self isAccessibleFrom: aMethod origin) ifFalse: [ ^false ].  ^(actualVariable isReadIn: aMethod) or: [ actualVariable isWrittenIn: aMethod ]stop: anObject  stop := anObjecttestFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: foundSelectors equals: #(classSideSender1OfMessage1 classSideSender2OfMessage1 sender1OfMessage1 sender2OfMessage1 superclassSenderOfMessage1)createQuery  ^ClyUndeclaredMethodsQuery from: (ClyClassScope of: ClyClassWithUndeclares in: environment)execute  classGroup importClasses: classescreateMethodQueryFrom: aClassScope  self subclassResponsibilitymethodEditor  ^toolbrowser  ^browserclassTag: anObject  classTag := anObjectfillStatusBar  super fillStatusBar.  statusBar addCommandItem: (ClySlotClassDefinitionSwitchMorph for: self)specifyClassItemNameOn: nameMorph for: classItem  | definition |  nameMorph contents: classItem name.  definition := classItem systemDefinition.  self packageSelection isMultipleSelected ifTrue: [ nameMorph contents: (definition printFullNameOf: classItem) ].  (self isPackagePartOfSelection: definition definingPackage) ifFalse: [ nameMorph color: self theme classExtensionColor ]testCreationWithEmptySubqueriesShouldReturnUnknownQuery  query := self queryClass with: {}.  self assert: query identicalTo: ClyUnknownQuery instancegroupProviderClass  ^ClyBreakpointMethodGroupProviderselectMethodsIn: aQueryBrowser  aQueryBrowser selectLastItemactualVariable: anObject  actualVariable := anObjectwhenEnterKeyPressedDo: aBlock  table bindKeyCombination: Character cr asShortcut toAction: aBlockconfirmEmptySystemQuery: aQuery  | showResult result |  result := aQuery execute.  result isEmpty ifTrue: [ ^true ].  showResult := UIManager default confirm: 'There are ' , result size asString , ' ' , aQuery description , '. Show them?'.  showResult ifTrue: [ self spawnQueryBrowserOn: aQuery ].  ^falseexecute  browser switchToMethodGroupsremoveMethods: methods  SycSilentlyRemoveMethodStrategy new removeMethods: methods.  (ClyShowMessageSenderCommand forMethods: methods by: browser) executefailureCount  ^failureCountsetUp  super setUp.  query := self createQuery.  queryResult := self createQueryResult prepareNewFor: query in: environment.  queryResult cancelRebuildtestFillingWithEmptyList  queryResult fillWith: {}.  self assert: queryResult isEmptyhandleSystemChange: aSystemAnnouncement byProcessingList: allProcessingResults  needsRebuild ifTrue: [ ^allProcessingResults remove: self ].  aSystemAnnouncement shouldBeConsideredByCalypsoEnvironment ifFalse: [ ^allProcessingResults remove: self ].  accessGuard tryEnterCritical: [ self handleSystemChange: aSystemAnnouncement ] ifLocked: [ ^self ].  allProcessingResults remove: selfshowMessage: aMessageDescription renamedTo: newSelector  | method newMethod |  method := aMessageDescription contextUser.  newMethod := method origin >> newSelector.  self showMethod: newMethodcache  ^cachesystemQuery: anObject  methodQuery := anObjectscopeClass  ^ClyInstanceSideScopegroupProviderClass  ^ClyTaggedClassGroupProviderspotterForCommandsFor: aStep  < spotterOrder: 20>  browser allContextsDo: [:each |  self commandListProcessorForContext: each step: aStep ]= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^tag = anObject tagisSameAs: anotherDataSource  self class == anotherDataSource class ifFalse: [ ^false ].  ^self isBasedOn: anotherDataSource querybrowser  ^browsertestFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: foundSelectors equals: #(classSideSender1OfMessage1 classSideSender2OfMessage1 sender1OfMessage1 sender2OfMessage1 superclassSenderOfMessage1)testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector).  self assert: (resultItems identityIncludes: self class superclass >> self targetSelector)textMorph  ^textMorphpendingText: aText  textMorph updateTextWith: aText.  textMorph hasUnacceptedEdits: truetestExecutesConcreteQueryClass  query subqueries: {(self subqueryFromScopeOf: #basis)}.  self deny: (query executesQuery: query class).  self assert: (query executesQuery: query subqueries anyOne class).  self deny: (query executesQuery: ClyQueryExampleReturningScopeBasis2)containerTab  ^containerTabcheckEmptyResult  self subclassResponsibilitysetUpParametersFromModel  super setUpParametersFromModel.  self updateMethodTagsAndPackagetestSelectsMethodWhichUsesUndeclares  self assert: (query selectsMethod: ClyClassWithUndeclares >> #method1WithUndeclares)testFillingWithSingleClassVar  | classVarGroup allClassVarGroup |  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  classVarGroup := items last actualObject.  self assert: classVarGroup methodQuery class equals: ClyVariableReferencesQuery.  self assert: classVarGroup methodQuery variableQuery resultItems equals: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1)}.  allClassVarGroup := items first actualObject.  self assert: allClassVarGroup methodQuery class equals: ClyVariableReferencesQuery.  self assert: allClassVarGroup methodQuery variableQuery class equals: ClyAllClassVariablesQuerylocalScopeClass: aLocalScopeClass  localScopeClass := aLocalScopeClassmetaLevelScope  ^metaLevelScopedecorateBrowserItem: anItem ofPackage: aPackage  | workingCopy |  workingCopy := aPackage mcWorkingCopy.  workingCopy ifNil: [ ^self ].  workingCopy modified ifTrue: [ anItem markWith: ClyDirtyPackageTag ]testFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1 .         ClySubclassWithTraitsOfClassWithTraits .         1 .         ClyTraitRoot2 .         2}createClassQueryFrom: aPackageScope  ^ClyAllClassesQuery from: (aPackageScope asScope: ClyPackageExtensionScope)testDescending  function := ClySortByNameFunction descending.  self assert: (function value: Object value: Array).  self deny: (function value: Array value: Object).  self assert: (function value: Object value: Object)testUsingBadScriptWithoutClosingBracket  filter := ClyQueryBrowserFilter substringPattern: '[:each | true '.  self assert: (filter matches: self itemOfThisTestMethod).  self assert: (filter matches: (ClyBrowserItem with: Object >> #printString))testComparisonWithItself  scope := self createSampleScope.  self assert: scope equals: scopeisParentRemoved  parentItem ifNil: [ ^false ].  ^parentItem isRemovedtestCheckIfEmpty  query scope: self scopeWithCritiques.  self deny: query checkEmptyResult.  query scope: self scopeWithoutCritiques.  self assert: query checkEmptyResulttestRestoredBrowserInstanceWithExpectedFlatQueryResult  self restoreBrowserInstance.  self assert: navigationState expectedFlatQueryResult notNil.  self assert: browser expectedFlatQueryResult equals: navigationState expectedFlatQueryResultrestoreStateOf: aBrowser  aBrowser systemScope: systemScopetestFillingWithTraitAndItsUsers  queryResult fillWith: {ClyTraitRoot1 .         ClyTraitChild1 .         ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitChild2Child}.  self assertItems: {ClyTraitRoot1 .         0 .         ClyTraitChild1 .         1 .         ClyClassWithTraits .         2 .         ClyTraitChild2 .         1 .         ClyTraitChild2Child .         2 .         ClyClassWithTraits .         3}testClassEnumeration  | expected |  scope := ClySuperclassScope of: ClyClass1FromP1.  scope classesDo: [:each |  result add: each ].  expected := ClyClass1FromP1 allSuperclasses.  self assert: result asArray equals: expected asArraymethodWithoutCritiques  ^self printStringtestComparisonWithResultWithAnotherSortFunction  | queryResult2 |  queryResult2 := queryResult sortedBy: #anotherSortFunction.  self deny: queryResult equals: queryResult2.  self deny: queryResult identicalTo: queryResult2testConvertingToAnotherScopeClassShouldRemoveDuplications  | convertedScope |  scope := ClyCompositeScope on: {(ClyScopeExample of: Object in: environment) .         (ClyScopeExample2 ofAll: {Object .               Array} in: environment)}.  convertedScope := scope asScope: ClyScopeExample2.  self assert: convertedScope class equals: ClyScopeExample2.  self assert: convertedScope basisObjects size equals: 2.  self assert: convertedScope basisObjects asIdentitySet equals: {Object .         Array} asSet.  self assert: convertedScope environment equals: environmenttestFromSingleClass  | varNames |  self queryFromScope: ClyClassScope of: ClyClass2FromP1.  varNames := resultItems collect: #name as: Set.  self assert: varNames equals: (ClyClass2FromP1 classVariables collect: #name as: Set)newNavigationView  | view |  view := ClyQueryViewMorph for: self.  navigationViews add: view.  ^viewupdateBrowser  self browser updatehash  ^super hash bitXor: hierarchy hashwithoutBasisObjects: existingBasisObjects  ^self withNewBasisObjects: (basisObjects copyWithoutAll: existingBasisObjects)globalPositionOf: childDataSourceItem  | result |  result := parentItem ifNil: [ 0 ] ifNotNil: [ parentItem globalPosition ].  collapsedItems do: [:each |  (each isAfter: childDataSourceItem position) ifTrue: [ ^result + childDataSourceItem position ].        result := result - each childrenCount ].  ^result + childDataSourceItem positiontestCheckIfEmpty  self deny: query checkEmptyResultprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  browserItem ifNil: [ nil printOn: aStream ] ifNotNil: [ aStream nextPutAll: browserItem name ].  aStream nextPut: $)name: aString  name := aStringmethodGroupSelection  ^methodGroupView selectiontestCheckIfEmpty  query scope: (ClyClassScope of: ClySubclassLOfClass0FromPExtendedByP1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyClassScope of: ClyClass1FromP1 in: environment).  self assert: query checkEmptyResultisSimilarTo: anotherBrowserTool  ^self class = anotherBrowserTool classtestMethodsEnumerationWhenBasisIsClass  | expected |  scope := ClyInstanceSideScope of: ClyClass1FromP1.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArrayhierarchy  ^hierarchymethodGroupType  ^ClyMethodGrouptestIsEmptyFromEmptyMethodScope  < expectedFailure>  super testIsEmptyFromEmptyMethodScopemethodQuery: aMethodQuery  methodQuery := aMethodQuerytestFindItemsUsingPredicate  | allItems |  allItems := cursor findItemsWhere: [:each |  each actualObject = Array ].  self assert: allItems size equals: 1.  self assert: allItems first actualObject equals: Array.  self assert: allItems first isPrepared.  self assert: allItems first position equals: (self rawResultItems indexOf: Array)description  ^'Command to browse the class defining the rule producing the critique.'refreshingBlock  ^refreshingBlockaffectsCritiques  ^falsematches: aString  ^aString includesSubstring: value caseSensitive: isCaseSensitiveclassNamed: aString ifAbsent: aBlockClosure  ^globals at: aString ifPresent: [:existing |  existing isBehavior ifTrue: [ existing ] ifFalse: aBlockClosure ] ifAbsent: aBlockClosuretestFindTestedClassCoveredByTestCaseWithAnotherSuffix  | foundClass |  foundClass := plugin findTestedClassCoveredBy: ClyTestedClass2Test ifAbsent: [  ].  self assert: foundClass equals: ClyTestedClass2testRestoredBrowserInstanceWithSystemScope  browser systemScope: #testScope.  self restoreBrowserInstance.  self assert: browser systemScope equals: #testScopesnapshotState  navigationState := browser snapshotStateisClassGroupSelected  ^falsecanDetectAffectOnClassesBy: aSystemAnnouncement  ^trueretrievesItemsOfType: itemTypeClass  ^subqueries anySatisfy: [:each |  each retrievesItemsOfType: itemTypeClass ]selectLastItem  | rowsCount |  rowsCount := self dataSource numberOfRows.  rowsCount = 0 ifTrue: [ ^self ].  self selection selectItems: {(self dataSource elementAt: rowsCount)}.  UIManager default defer: [ self selection ensureVisibleLastItem ]testHasEnvironmentFromSubscopes  scope := self createSampleScope.  self assert: scope environment equals: environmenttestConvertingToIncreasedScopeByExtraClassScope  | convertedScope extraClassScope |  scope := self singleScopeSample.  extraClassScope := ClySuperclassScope of: self class localScope: self scopeClass.  convertedScope := scope increasedByClassesFrom: extraClassScope.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects equals: scope basisObjects , extraClassScope collectAllClassesokToChange  ^tabManager okToChangetabDeleted: aTab  | removedTool |  removedTool := tools detect: [:each |  each containerTab = aTab ] ifNone: [ ^self ].  tools remove: removedTool.  removedTool cleanAfterRemoveprintDefinition  self subclassResponsibilitytestConvertingToAnotherScopeClass  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asScope: ClyScopeExample.  self assert: convertedScope identicalTo: scopeisMessageSelected  ^self isMethodSelectedisResult: aQueryResult affectedBy: aSystemAnnouncement  ^(aSystemAnnouncement affectsMethodsTaggedWith: tag) and: [ scope includesMethodsAffectedBy: aSystemAnnouncement ]initialize  super initialize.  needsRebuild := trueincludesActualObject: anObject  ^items anySatisfy: [:each |  each includesActualObject: anObject ]critiqueQuery: aCritiqueQuery  critiqueQuery := scope adoptQuery: aCritiqueQuerycreateMethodQueryFrom: aClassScope  ^ClyMethodWatchpointsQuery from: aClassScopeclassesDo: aBlock  self subclassResponsibilitybrowseSendersOf: aSymbol  self spawnQueryBrowserOn: (ClyMessageSendersQuery of: aSymbol)lastSelectedClassTag  | tagItem |  tagItem := tool classGroupSelection items detect: [:each |  each type isBasedOnClassTag ].  ^tagItem nameitems: anObject  items := anObjectapplyChanges  self subclassResponsibilitysetUpScopedModeWith: aScope  (aScope isKindOf: ClyPackageScope) ifFalse: [ ^self ].  self switchToPackageScopeOf: aScope basisObjectscollate: aBrowserItem1 with: aBrowserItem2  ^actualObjectSortFunction collate: aBrowserItem1 actualObject with: aBrowserItem2 actualObjectforceRebuild  belongsToRemovedBrowserContext  | actualMethod |  super belongsToRemovedBrowserContext ifTrue: [ ^true ].  actualMethod := editingMethod origin localMethodNamed: editingMethod selector ifAbsent: [ ^true ].  self editingMethod: actualMethod.  ^falsequeryClass  ^ClyUnionQuerycollapse: aDataSourceItem  queryView changeStateBy: [ collapsedItems removeAllSuchThat: [:each |  aDataSourceItem hasChildAt: each position ].        collapsedItems add: aDataSourceItem.        self expansionChanged ]testFillingWithClassWithoutTraits  queryResult fillWith: {ClyClassWithoutTraits}.  self assertItems: {ClyClassWithoutTraits .         0}ensureInitialState  (navigationViews anySatisfy: [:each |  each hasRealQuery ]) ifTrue: [ ^self ].  self prepareDefaultStateselectsClass: aClass  ^aClass tags isEmptyclassesRelatedTo: aClass do: aBlock  self class classesRelatedTo: aClass do: aBlockcheckEmptyResult  scope projectsDo: [:each |  each items ifNotEmpty: [ ^false ] ].  ^truesetUp  | packages |  super setUp.  packages := ClyAllPackagesQuery from: ClyPackageScope of: ClyClass7WithTag1FromP5 package in: environment.  viewDataSource := ClyCollapsedDataSource on: packages.  queryView := ClyQueryViewMorph for: browser.  queryView treeStructure: {(RPackage -> #prepareClassGroupQueryFrom:in:)}.  queryView dataSource: viewDataSource.  queryView selection selectItems: {self selectedItem}hash  ^classQuery hashapplyBreakpointCondition: aBreakpoint  aBreakpoint alwaystestBindToEnvironmentShouldBindSubscopes  | subscopes |  scope := ClyCompositeScope on: {(ClyScopeExample of: Object) .         (ClyScopeExample2 of: Array)}.  scope bindTo: environment.  subscopes := scope subscopes asArray.  self assert: subscopes first environment equals: environment.  self assert: subscopes second environment equals: environmentsubgroupsQuery: anObject  subgroupsQuery := anObjectsnapshotState  navigationState := ClyAccrossWindowNavigationState from: browsercreateBrowser  ^ClyFullBrowser newtestComparisonWithResultWithSimilarInverseHierarchy  | queryResult2 |  queryResult2 := self createQueryResult.  queryResult2 := queryResult2 withInverseHierarchy.  self deny: queryResult equals: queryResult2printExtraInfoOn: aStream  super printExtraInfoOn: aStream.  ^aStream nextPutAll: package nameclassesDo: aBlock  self packagesDo: [:package |  package extendedClasses collect: [:each |  each instanceSide ] thenDo: aBlock ]asyncResult: anObject  asyncResult := anObjectdecorateByCritic: aCriticTool  decorateTool  | newScope |  criticView ifNil: [ self prepare ].  newScope := browserTool criticAnalysisScope.  (analysisScope isNil or: [ newScope basisObjects ~= analysisScope basisObjects ]) ifTrue: [ analysisScope := newScope.        self updateCriticView ].  self refreshCritiquesitemCache: anObject  itemCache := anObjectisTestMethod: aMethod  aMethod numArgs isZero ifFalse: [ ^false ].  ((aMethod selector beginsWith: 'test') or: [ aMethod selector beginsWith: 'should' ]) ifFalse: [ ^false ].  ^self isTestClass: aMethod methodClasstestConvertingWithNewScopeBasisShouldKeepFilter  | convertedQuery |  convertedQuery := query withScopeOf: #(newBasis).  self assert: convertedQuery itemFilter equals: query itemFilteraddDecorator: aBrowserToolDecorator  aBrowserToolDecorator browserTool: self.  decorators add: aBrowserToolDecoratormoveToStart  self moveTo: 1createBrowser  ^ClyQueryBrowser on: environment scopes: {(ClyBothMetaLevelClassScope of: ClyClass1FromP1 in: environment) .         (ClyBothMetaLevelClassScope of: ClyClass2FromP1 in: environment)}decorateResultMethodEditor: aMethodEditor  aMethodEditor selectAnySelector: #(halt halt: haltIf: haltOnce haltOnCount)testInstVarsEnumerationWhenThereAreNoVariables  scope := ClyClassScope of: Object.  scope instanceVariablesDo: [:each |  result add: each ].  self assert: result isEmptyqueryClass  self subclassResponsibilityquerySystemFor: aTypedQuery  aTypedQuery bindTo: self systemScope in: self.  ^aTypedQuery executetestNotEmptyInPackageWithTagsAndUncategorizedClasses  query scope: (ClyPackageScope of: ClyClass6UntaggedFromP5 package in: environment).  self deny: query checkEmptyResultactivationPriorityOf: aBrowserTool  | priority |  aBrowserTool belongsToCurrentBrowserContext ifFalse: [ ^aBrowserTool activationPriorityInNonActiveContext ].  priority := self overridenPriorityOf: aBrowserTool.  ^(desiredSelection includes: aBrowserTool class) ifTrue: [ priority * 1000 ] ifFalse: [ priority ]testMatchesAnyStringWhenItIsEmpty  | pattern |  pattern := ClyRegexPattern with: ''.  self assert: (pattern matches: 'any string')testTwo  | testedObject |  testedObject := self newTestedObject.  self     assert: testedObject two isNil;     assert: (testedObject two: #two) identicalTo: testedObject;     assert: testedObject two equals: #twofindDataSourceSameAs: aDataSource ifNone: noneBlock  | found |  (self isSameAs: aDataSource) ifTrue: [ ^self ].  expandedItems do: [:each |  found := each childrenDataSource findDataSourceSameAs: aDataSource ifNone: [ nil ].        found ifNotNil: [ ^found ] ].  ^noneBlock valuetestFillingWithClassAndItGrandSuperclass  queryResult fillWith: {ClyClass1FromP1 .         ClySubclassLOfSubclassMFromP3}.  self assertItems: {ClyClass1FromP1 .         0 .         ClySubclassLOfSubclassMFromP3 .         1}singleBasisSample  self subclassResponsibilitytestNotExecutedFromMultipleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  < expectedFailure>  super testNotExecutedFromMultipleScopeWhenSubqueriesAreFromDifferentScopesOfSameObjecttestConvertingWithoutExistingBasisObjects  | convertedScope |  scope := self multipleScopeSample.  convertedScope := scope withoutBasisObjects: scope basisObjects.  self assert: convertedScope class equals: scope class.  self deny: (convertedScope basisObjects includesAll: scope basisObjects)restoreBrowserState: aBrowserState  | existingTools |  self updateTools.  existingTools := aBrowserState selectedTabs collect: [:oldTool |  tools detect: [:each |  each isSimilarTo: oldTool ] ifNone: [ nil ] ] thenSelect: #notNil.  existingTools ifEmpty: [ ^self ].  existingTools first selectAsMainTab.  existingTools allButFirstDo: [:each |  each selectAsExtraTab ]description  ^'Scope to selected packages'addClassVariableGroup  | variableQuery methodQuery group |  variableQuery := ClyAllClassVariablesQuery from: self queryScope.  methodQuery := ClyVariableReferencesQuery from: self queryScope asLocalClassScope toVariablesFrom: variableQuery.  group := ClyMethodGroup named: 'Class variables' priority: 9 on: methodQuery withSubgroupsFrom: (variableQuery withResult: (ClyGroupedClassVariables withHierarchy: hierarchy)).  items add: group asCalypsoBrowserItemtestFillingWithOnlyClassWhichHasTraits  queryResult fillWith: {ClyClassWithTraits}.  self assertItems: {ClyClassWithTraits .         0}isResult: aQueryResult affectedBy: aSystemAnnouncement  ^scope includesVariablesAffectedBy: aSystemAnnouncementdefaultIconName  ^#addisAppliedToBrowser  ^browser showsFullClassHierarchypackageNameOf: aBrowserItem  ^aBrowserItem systemDefinition definingPackageItem namedefiningPackageItem  ^definingPackageItemmethodGroupType  self subclassResponsibilitydescription  ^'all critiques'defaultColor  ^Color transparentretrievesBrowserItems  ^requiredResult representsBrowserItemsexecuteCommand  activator executeCommandsortFunction: anObject  sortFunction := anObjectactivationPriorityInNonActiveContext  ^applyingChanges ifTrue: [ Float infinity ] ifFalse: [ super activationPriorityInNonActiveContext ]testQueryCacheShouldBeWeak  | cache query |  query := self createQueryFromScopeOf: self class.  environment query: query.  Smalltalk     garbageCollectMost;     garbageCollectMost.  cache := environment cachedResultOf: query.  self assert: cache equals: nilactualObjectSortFunction: anObject  actualObjectSortFunction := anObjectcreateCommandContextForCursorAt: aCursorPoint  | sourceNode |  sourceNode := self findSourceNodeAt: aCursorPoint.  ^ClyMethodSourceCodeContext for: self selectedNode: sourceNodeactualQuery  ^subqueries anyOneitems  ^itemsinitializeItems  items ifNil: [ super initializeItems ]selectedMethodItems  ^selectedItemscheckbox: anObject  checkbox := anObjectbuildResult: aQueryResult  aQueryResult fillWith: resultItemsupdateCriticView  | critiqueQuery |  critiqueQuery := (ClyAllBasisCritiqueQuery from: analysisScope) async.  criticView showQuery: critiqueQueryactivateSubmenu: evt  ^falsescopeClass  ^ClyMethodScopemenuColumn: column row: rowIndex  ^queryView menuColumn: column row: rowIndexswitchClassViewTo: aQueryResult inScope: aScope  | classes |  classes := ClyAllClassesQuery from: aScope as: aQueryResult.  classView showQuery: classeschildrenItemAt: ownerIndex  ^childrenDataSource elementAt: ownerIndex - self positiontestDetectingDefiningClassFromItself  | varBinding var |  varBinding := ClyClass2FromP1 classVariableNamed: #ClassVar1.  var := ClyClassVariable on: varBinding visibleFrom: ClyClass2FromP1.  self assert: var definingClass equals: ClyClass2FromP1retrievesItem: aVariable  ^trueclassTemplate  | template |  template := Slot showSlotClassDefinition ifTrue: [ 'Object subclass: #NameOfSubclass	slots: {}	classVariables: {}	package: ''' ] ifFalse: [ 'Object subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	package: ''' ].  ^template , self packageName , ''''testDataSourceWithoutTable  self snapshotState.  self assert: navigationState dataSource table isNiltestFindTestCaseCoveringTestedClass  | foundClass |  foundClass := plugin findTestCaseCovering: ClyTestedClass ifAbsent: [  ].  self assert: foundClass equals: ClyTestedClassTesttestForGlobalVariable  query variableQuery: (ClyConstantQuery returning: {(self class environment bindingOf: #Smalltalk)}).  self queryFromScope: ClyMethodScope of: self class >> #referenceOfSmalltalk.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #referenceOfSmalltalkclassesRelatedTo: aClass do: aBlock  relationScopeClasses do: [:each |  each classesRelatedTo: aClass do: aBlock ]ensureExistAndRegisterPackageNamed: packageName  ^packageOrganizer ensureExistAndRegisterPackageNamed: packageNametestClassEnumerationOverMetaclassBasisWhenClassSideIsLocalScope  scope := ClyInterestingSuperclassScope of: ClySubclassN1OfClass1FromP1 class localScope: ClyClassSideScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {ClyClass1FromP1 class} asSet= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^excludesHaltsForTesting = anObject excludesHaltsForTestingoverridingSubclass: aClass  overridingSubclass := aClasscreateMethodGroupFor: aMethodQuery from: aClassScope  ^ClyMethodGroup named: 'should be implemented' priority: 8.5 on: aMethodQuerytestResultOf: methodItem  ^(methodItem getProperty: ClyTestedMethodProperty) testResultactivator  ^activatortestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClassWithProblemMethods >> #methodWithHalt in: environment).  self deny: query checkEmptyResult.  query := self createQuery.  query scope: (ClyMethodScope of: ClyClassWithProblemMethods >> #methodWithoutCritiques in: environment).  self assert: query checkEmptyResultdecorateBrowserItem: anItem ofMethod: aMethod  aMethod isFFIMethod ifTrue: [ anItem markWith: ClyFFIMethodTag ]defaultMenuIconName  ^#smallDebugasSelection  ^self rootDataSource newSelectionWith: {self}entity  ^entitycreateQuery  ^ClyAllProblemMethodQuery from: ClyClassScope of: ClyClassWithProblemMethods in: environmentselectedSourceNode  ^selectedSourceNodedetachFromSystem  TestCase historyAnnouncer unsubscribe: selftestNotExecutedFromMultipleScopeWhenSingleSubqueryIsFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty)}.  self deny: query isExecutedFromMultipleScopetestFillingWithThreePackages  | groups |  queryResult fillWith: {ClySubclassMOfClass1FromP2 package .         ClySubclassLOfSubclassMFromP3 package .         ClyClass1FromP1 package}.  groups := queryResult items collect: #package as: Array.  self assert: groups equals: {ClyClass1FromP1 package .         ClySubclassMOfClass1FromP2 package .         ClySubclassLOfSubclassMFromP3 package}testCheckIfEmpty  query scope: (ClyMethodScope of: ClyAbstractClassExample >> #abstractMethod1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyAbstractClassExample >> #overriddenMethod in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyAbstractClassExample >> #abstractMethod2 in: environment).  self assert: query checkEmptyResultfindItemsWith: aCollection  ^Array new: aCollection size withAll: nillastSelectedItem  ^selectedItems firstwithAbstractMethodsOf: aClass do: aBlock  aClass localMethods select: [:each |  self isAbstractMethod: each ] thenDo: aBlocklastSelectedVariable  ^self selectedVariabletestFillingWithObjectAndTwoProtoObjects  queryResult fillWith: {Object .         ProtoObject .         ProtoObject}.  self assertItems: {ProtoObject .         0 .         Object .         1}copyForBrowserStateSnapshot  ^self copy     initializeForBrowserStateSnapshot;     yourselftestComparisonWithAnotherHierarchy  | queryResult2 |  queryResult2 := self createQueryResult.  queryResult2 hierarchy: queryResult hierarchy inverted.  self deny: queryResult equals: queryResult2systemChanged: aSystemAnnouncement  self updateUsing: ClyFullEnvironmentUpdateStrategy new by: [ self handleSystemChange: aSystemAnnouncement ]supportsQuery: aQuery  self subclassResponsibilitytestCheckIfEmpty  query scope: (ClyMethodScope of: self class >> #reader1OfVar1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: self class >> #writerOfVar1 in: environment).  self assert: query checkEmptyResultasScope: aClassScopeClass  | newScope |  newScope := super asScope: aClassScopeClass.  newScope adoptLocalScopeClassTo: self localScopeClass.  ^newScopeaffectedClass  ^affectedClasslastSelectedMethod  ^self lastSelectedObjectIn: self selectedMethodsprintContext  ^editingPackage namedecorateBrowserItem: anItem ofProject: aProject  testItemsChangedNotificationShouldNotResetExistingItems  queryResult items: #(items).  queryResult itemsChanged.  self assert: queryResult items equals: #(items).  self assert: queryResult needsRebuildtestFromClassWithoutCommentWhenPatternSatisfiesCommentTemplate  | noCommentClass substring |  noCommentClass := Object newAnonymousSubclass.  self deny: noCommentClass hasComment.  substring := noCommentClass comment copyFrom: 4 to: 30.  query pattern: (ClySubstringPattern with: substring).  self queryFromScope: ClyClassScope of: noCommentClass.  self assert: resultItems isEmptytestDescriptionWhenSimpleClassBindingIsUsed  query := ClyClassReferencesQuery to: Object binding.  self assert: query description equals: 'references to Object'restoreBrowserState  ownerTool restoreBrowserStatelogged: aBoolean  lastSelectedMessage  ^self selectedMessagecreateQuery  ^ClyMethodCallCountersQuery from: ClyClassScope of: self class in: environmentnavigationEnvironment  ^self browser navigationEnvironmentrenameClassTagTo: newTag  self classes do: [:each |  each tagWith: newTag ]= anObject  self == anObject ifTrue: [ ^true ].  super = anObject ifFalse: [ ^false ].  ^extraParameter = anObject extraParameterapplyChanges  | selector methodClass currentMethod |  methodClass := self chooseClassForNewMethodIfNone: [ ^false ].  selector := methodClass compile: self pendingText classified: editingMethod protocol notifying: textMorph.  selector ifNil: [ ^false ].  currentMethod := methodClass >> selector.  self tagAndPackageEditingMethod: currentMethod.  self switchToMethod: currentMethod.  ^truetabMorph: anObject  tabMorph := anObjecthandlesAnnouncement: anAnnouncement  | newMethod |  affectedMethod isInstalled ifFalse: [ newMethod := affectedMethod origin localMethodNamed: affectedMethod selector ifAbsent: [ nil ].        newMethod ifNotNil: [ affectedMethod := newMethod ] ].  ^anAnnouncement affectsMethod: affectedMethodtestComparisonToSimilarQueryButWithDifferentVariables  | query2 |  query2 := self createQuery.  query2 variableQuery: (ClyConstantQuery returning: #(someAnotherVar)).  self deny: query equals: query2rawResultItems  ^queryResult items collect: #actualObject, anotherTypedScope  self subclassResponsibilitysystemEnvironment  ^systemEnvironmentdescription  ^'problem methods (' , critiqueQuery description , ')'selectClass: aClass atMethodTag: tagName  self changeStateBy: [ self selectClass: aClass.        self methodGroupSelection selectItemsWhere: [:each |  each name = tagName ] ]showQueries: queries as: aQueryResult  | fullQuery |  fullQuery := ClyQuery unionFrom: queries as: aQueryResult.  self showQuery: fullQuerydragTransferType  ^#CommanderDragAndDropasInheritingScope  | newSubscopes |  newSubscopes := subscopes collect: [:each |  each asInheritingScope ].  ^ClyCompositeScope on: newSubscopes in: environment named: ClyClassScope inheritingScopeNameisPackageSelected  ^tool packageSelection isEmpty notselectedVariables  ^self selectedObjects collect: [:each |  each variable ]fillWith: critiques  | groups |  groups := Dictionary new.  critiques do: [:eachCritique |  self buildMethodGroupWithCritique: eachCritique on: groups ].  groups do: [:each |  items add: each ]visibilityLevels: levelCollection  visibilityLevels := levelCollection reject: [:each |  each isRedundant ]testSuperSendNoArg_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'super msg') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext receiver perform: #msg withArguments: {} inSuperclass: ThisContext receiver class superclass)]')asTraitVisibility  ^selftestSelectsTestMethodWithExpectedFailurePragma  self assert: (query selectsMethod: ClyTestedClassTest >> #testExpectedFailure)testGettingEnvironment  self assert: query environment equals: environmentgroupProviderClass  ^ClyInheritedMethodGroupProvidertargetTestCasesFor: testItem  | fullResult itemTestCases |  itemTestCases := IdentitySet new.  fullResult := self testResultOf: testItem.  runTestCases do: [:each |  fullResult concreteResultOf: each ifPresent: [:concreteResult |  itemTestCases add: each ] ].  ^itemTestCases ifEmpty: [ fullResult testCases ]buildResult: aQueryResult  | groups |  groups := OrderedCollection new.  scope methodGroupsDo: [:group |  groups add: group ].  aQueryResult fillWith: groupsdefaultMenuIconName  ^#smallFindIconprintExtraInfoOn: aStream  testFromSinglePackage  self queryFromScope: ClyPackageScope of: ClyClass1FromP1 package.  self assert: resultItems asSet equals: {ClyClass1FromP1 package} asSettestConvertingToSemiAsyncQuery  | convertedQuery |  convertedQuery := query semiAsync.  self assert: convertedQuery identicalTo: querytargetView: anObject  targetView := anObjectretrievesItem: anObject  self subclassResponsibilitytestFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 3.  self assert: foundSelectors equals: #(classSideReference1OfClass reference1OfClass reference2OfClass)lastSelectedMethod  ^self selectedMethodinitialize  super initialize.  changesCancelRequested := false.  applyingChanges := falseclassesRelatedTo: aClass do: aBlock  self subclassResponsibilityrepresentsScope: aScopeClass  ^self isKindOf: aScopeClassisSelectedMethodGroupEditable  self isMethodGroupSelected ifFalse: [ ^false ].  ^self selectedMethodGroupClass isEditableGroupisAppliedToBrowser  self subclassResponsibilitydecorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph definitionIcon: #recoverLostChangesbuildGroupsFor: aClass  | classScope |  classScope := ClyClassScope of: aClass in: environment.  builtGroups := groupProvider buildGroupsFrom: classScoperetrievesItemsOfType: itemTypeClass  self subclassResponsibilityapplyResultInContext: aToolContext  super applyResultInContext: aToolContext.  aToolContext showMethodTag: newNamedetachFromSystem  environment system unsubscribe: selftestHasQueryResult  self assert: cursor queryResult class equals: ClyAsyncBrowserQueryResultAdapter.  self assert: cursor queryResult actualResult equals: queryResultformatSourceCode  textMorph formatSourceCodeisProjectSelected  ^self selectedProjectItems notEmptyaddColumn: columnId  | newColumn |  newColumn := ClyTableColumn id: columnId.  table addColumn: newColumn.  ^newColumnabstractMethod1  self subclassResponsibilityupdate  editingMethod := editingMethod origin localMethodNamed: editingMethod selector ifAbsent: [ ^self ].  super update.  self formatTextIfNeededselectVariableNamed: varName  self selectAnyVariable: {varName}printExtraInfoOn: aStream  super printExtraInfoOn: aStream.  aStream nextPutAll: groupNamematches: anEnvironmentItem  ^pattern matches: anEnvironmentItem nametestFromClassScope  self queryFromScope: ClyClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(reference1OfVar1 reference2OfVar1)resetImplementorsCache  cacheGuard critical: [ allImplementorsCache := nil ]testCheckEmptyQueryWhenThereIsNoResultButItWouldBeEmpty  | query |  query := self createQueryFromScope: ClyScopeExample empty.  self assert: (environment isQueryEmpty: query)createQuery  ^self queryClass of: (ClyInstanceVariable named: self targetVarName definedIn: ClyVariableReferencesTestCase) from: (ClyClassScope of: self class in: environment)system  ^basisObjects anyOnedefaultMenuItemName  ^'Find method'testComparison  self assert: (ClyMessageSendersQuery of: #message1) equals: (ClyMessageSendersQuery of: #message1).  self assert: (ClyMessageSendersQuery of: #message1) hash equals: (ClyMessageSendersQuery of: #message1) hash.  self deny: (ClyMessageSendersQuery of: #message1) equals: (ClyMessageSendersQuery of: #message2)refreshTable  table refreshsilentlySelectPackageOfSelectedClass  | selectedClass |  self classSelection isEmpty ifTrue: [ ^self ].  selectedClass := self classSelection lastSelectedItem actualObject.  packageView ignoreNavigationDuring: [ selectedClass tags ifEmpty: [ self selectPackage: selectedClass package ] ifNotEmpty: [:tags |  self selectPackage: selectedClass package atClassTag: tags anyOne ] ]decorateTableCell: anItemCellMorph of: groupItem  | currentFont |  super decorateTableCell: anItemCellMorph of: groupItem.  currentFont := anItemCellMorph label font.  anItemCellMorph label font: (LogicalFont familyName: currentFont familyName pointSize: currentFont pointSize - 1).  anItemCellMorph label color: Color grayhash  ^super hash bitXor: hierarchy hashremoveWithMethods  self error: 'You should not remove inherited methods'moveTo: newPosition  position := newPosition.  cache loadItemOf: queryResult at: positioncreateQueryResult  ^ClyTraitUserHierarchy new asQueryResulthash  ^direction hashinstanceSideVar1WriterMethod  instanceSideVar1 := #var1ValuecreateQuery  ^super createQuery scope: (ClyClassScope of: ClyClass1FromP1 in: environment)execute  methodGroup renameMethodTagTo: newName asSymbolrawItemsOf: itemTypeClass do: aBlock  ^self rawItemsDo: [:each |  each calypsoEnvironmentType = itemTypeClass ifTrue: [ aBlock value: each ] ]bindingOf: aSymbol  ^globals bindingOf: aSymbolmatches: aString  | matcher |  matcher := self createRegexMatcherIfFailed: [ ^true ].  ^matcher search: aStringinitialize  super initialize.  inverse := falsefindItemWhich: blockCondition ifExists: presentBlock  items detect: blockCondition ifFound: presentBlockisExtraSelectionRequested  | lastEvent |  lastEvent := ActiveHand lastEvent.  ^lastEvent isMouse and: [ lastEvent isMouseDown and: [ lastEvent commandKeyPressed or: [ lastEvent controlKeyPressed ] ] ]spawnFullBrowser  super spawnFullBrowser.  self itemCount = 1 ifTrue: [ [ self close ] on: ProvideAnswerNotification do: [:notification |  notification resume: false ] ]initializeOn: aBrowser  browser := aBrowser.  self initializetestFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (ClyAbstractClassExample >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 overriddenMethod)testMakeQueryOfResultAsReadOnlyObjectWhenItIsExecuted  | query |  query := self createQueryFromScopeOf: self class.  environment query: query.  self assert: query isReadOnlyObjecttestCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: Object >> #printString in: environment).  self assert: query checkEmptyResulttestCaseInsensitiveMathingString  | pattern |  pattern := ClySubstringPattern with: 'subString' caseSensitive: false.  self assert: (pattern matches: 'start subString end').  self assert: (pattern matches: 'start substring end').  self deny: (pattern matches: 'another string')visibilityLevel  ^visibilityLevelinitialize  super initialize.  updateQueue := AtomicSharedQueue newtestConvertingToAsyncQuery  | convertedQuery |  convertedQuery := query async.  self assert: convertedQuery identicalTo: querycreateQueryScope  | classes scope |  classes := methods collect: [:each |  each origin ].  scope := self createInheritanceScopeFrom: classes.  scope := scope withMetaLevel: ClyClassScope.  ^scopebelongsToCurrentBrowserContext  ^(browser isMethodSelected: leftMethod) and: [ browser isMethodSelected: rightMethod ]packagesDo: aBlock  self projectsDo: [:project |  project packages do: aBlock ]hasSubMenu  ^falsecreateQuery  ^ClyAllPackagesQuery from: ClyPackageScope of: Object package in: environmentselectAsExtraTab  containerTab addToSelectionisAboutBrowserItemType: itemTypeClass  ^selectedItems anySatisfy: [:each |  each type isCalypsoItemType: itemTypeClass ]requestRemoveMethodStrategyFor: methods  | selectors result strategies caption senders senderCount plural |  selectors := (methods collect: [:each |  each selector ] as: IdentitySet) asArray.  senders := (ClyMessageSendersQuery ofAny: selectors from: self systemScope) execute.  (self allowSilentlyRemoveMethods: methods whichHaveSenders: senders) ifTrue: [ ^SycSilentlyRemoveMethodStrategy new ].  strategies := SycRemoveMethodStrategy createAllForBrowser: self.  senderCount := senders size.  plural := '' asPluralBasedOn: senderCount.  caption := selectors size > 1 ifTrue: [ 'There are {1} sender{2}' format: {senderCount .               plural} ] ifFalse: [ 'The message #{1} has {2} sender{3}' format: {selectors anyOne .               senderCount .               plural} ].  result := UIManager default chooseFrom: (strategies collect: #userRequestString) values: strategies title: caption.  ^result ifNil: [ SycNotRemoveMethodStrategy new ]updateSelectionForNewFilter  | oldSelection |  oldSelection := selection.  self initiateUIChangeBy: [ self updateSelection.        (desiredSelection notNil and: [ desiredSelection isEmpty not ]) ifTrue: [ desiredSelection restoreCurrentSelection: selection ] ].  ^(selection isSameAs: oldSelection) notselectionChanged  | selectionIsChanged |  selectionIsChanged := true.  self changeStateBy: [ self isFilterChanged ifTrue: [ selectionIsChanged := self updateSelectionForNewFilter.              selectionIsChanged ifFalse: [ ^self ] ].        selectionIsChanged ifTrue: [ self updateSelection ].        navigationSelector ifNotNil: [ browser perform: navigationSelector withEnoughArguments: {self selection} ] ].  self triggerClickCommandsqueryClass  self subclassResponsibilitynumberOfRows  ^self itemCursor itemCount + (expandedItems detectSum: [:each |  each childrenCount ])createMethodQueryFrom: aClassScope  ^ClyFailedTestMethodsQuery from: aClassScopetestNotSelectsMethodWithoutCounter  self deny: (query selectsMethod: self class >> #methodWithoutCounter)getPlugin: environmentPluginClass  ^plugins detect: [:each |  each class = environmentPluginClass ]beProtected  tabManager  ^tabManagerhash  ^super hash bitXor: baseCritiqueQuery hashdecorateTool: aBrowserTool  aBrowserTool supportsCriticDecoration ifFalse: [ ^self ].  aBrowserTool addDecorator: ClyCriticDecorator newactivateWindow: aWindow  | index |  (self tabGroup pages includes: aWindow) ifTrue: [ index := self tabGroup pages indexOf: aWindow.        ^self tabGroup selectedPageIndex: index ].  self addWindow: aWindow.  aWindow     activate;     announceOpenedtools  ^toolstestDetectingDefiningClassFromSharedPoolUserClassSide  | varBinding var |  varBinding := ChronologyConstants classVariableNamed: #DayNames.  var := ClyClassVariable on: varBinding visibleFrom: Date class.  self assert: var definingClass equals: ChronologyConstantsbuildFrom: classes  | map |  map := ClyClassHierarchyMap for: self of: classes.  map build.  ^mapmethodWithoutCounter  iconName  ^#smallDoItIconcreateMethodQueryFrom: aClassScope  ^ClyAllExtensionMethodsQuery from: aClassScopedefaultClassCompiler  ^self class compilertraitScopeClass  self subclassResponsibilityactionBlock  ^actionBlocklastSelectedClass  ^self selectedClassreader1OfVar1  ^readVar1subclassN2VarReaderMethod  ^subclassN2VarprintOn: aStream  super printOn: aStream.  name ifNil: [ ^self ].  aStream nextPut: $(.  aStream nextPutAll: name.  aStream nextPut: $)buildContextMenu: aMenu  aMenu addLine.  super buildContextMenu: aMenu.  aMenu addLineprintMethodTags  ^ownerTool methodTags ifEmpty: [ 'as yet unclassified' asText makeAllColor: Color red ] ifNotEmpty: [:tags |  tags joinUsing: ', ' ]withSubqueries: newSubqueries  ^self copy subqueries: newSubqueriestestIsExecutedFromConcreteScopeClass  self assert: (query isExecutedFromScope: ClyScopeExample).  self assert: (query isExecutedFromScope: ClyScope).  self deny: (query isExecutedFromScope: Array)belongsToDataSource: aDataSource  ^ownerDataSource == aDataSourceasGoToSpotterCandidate  ^ClyGoToSpotterCandidate target: self activeQueryView named: self simpleNameForSpotterMenu icon: self iconForSpotterMenu using: [ self activeQueryView takeKeyboardFocus ]fillItemsFrom: aBrowserQueryResult  items := aBrowserQueryResult itemsStartingAt: startPosition count: sizeLimitmatches: anEnvironmentItem  self subclassResponsibilityfillWith: classes  | hierarchyMap |  items := OrderedCollection new: classes size.  hierarchyMap := hierarchy buildFrom: classes.  hierarchyMap rootsDo: [:root |  self buildItemFor: root from: hierarchyMap depth: 0 ]