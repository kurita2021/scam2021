basisObjects: aCollection  basisObjects := aCollection asSet-=JUAMPI=-isImplementedByClass: aClass  ^aClass instanceSide includesBehavior: self implementorClass instanceSide-=JUAMPI=-testComparisonWithAnotherKindOfResult  self deny: queryResult equals: ClyQueryResult new-=JUAMPI=-selectsMethod: aMethod  ^aMethod isExtension and: [ aMethod package = package ]-=JUAMPI=-ownerTool: anObject  ownerTool := anObject.  self build-=JUAMPI=-initialize  super initialize.  projectManagers := OrderedCollection new-=JUAMPI=-testHasEmptyBasisObjects  scope := self createSampleScope.  self assert: scope basisObjects isEmpty-=JUAMPI=-specialSelectorIndexes  ^specialSelectorIndexes ifNil: [ specialSelectorIndexes := selectors collect: [:each |  Smalltalk specialSelectorIndexOrNil: each ] ]-=JUAMPI=-isSlow  ^false-=JUAMPI=-focusActiveTab  tabManager focusActiveTab-=JUAMPI=-testCaseResults: anObject  testCaseResults := anObject-=JUAMPI=-allNavigationScopes  | classLocalScope |  classLocalScope := self classSelection asItemsScope: ClyBothMetaLevelClassScope.  ^super allNavigationScopes , {(self packageSelection asItemsScope: ClyPackageScope) .         classLocalScope asFullHierarchyScope .         classLocalScope}-=JUAMPI=-itemsStartingAt: startIndex count: size  ^#()-=JUAMPI=-isAffectedByChangedMethod: aMethod  ^self selectsMethod: aMethod-=JUAMPI=-buildResult: aQueryResult  | filteredMethods |  filteredMethods := OrderedCollection new.  scope methodsDo: [:each |  (self selectsMethod: each) ifTrue: [ filteredMethods add: each ] ].  aQueryResult fillWith: filteredMethods-=JUAMPI=-rebuildIfNeeded  self protectAccessWhile: [ needsRebuild ifTrue: [ needsRebuild := false.              self rebuild ] ]-=JUAMPI=-createQuery  ^ClyDeprecatedMethodsQuery from: ClyClassScope of: Object in: environment-=JUAMPI=-testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self deny: query checkEmptyResult-=JUAMPI=-changeStateOf: aQueryView by: aBlock  | newTools |  self changeStateBy: [ aBlock value.        aQueryView changesWasInitiatedByUser ifTrue: [ newTools := OrderedCollection new.              tabManager buildToolsOn: newTools for: aQueryView createSelectionContext.              tabManager desiredSelection: (newTools collect: #class) ] ]-=JUAMPI=-withResult: aQueryResult  | copy |  copy := self copy.  copy requiredResult: aQueryResult.  ^copy-=JUAMPI=-packagesDo: aBlock  basisObjects do: aBlock-=JUAMPI=-execute  browser switchScopeTo: queryScope-=JUAMPI=-update  | unacceptedText newText |  super update.  newText := self editingText.  self pendingText asString = newText ifTrue: [ self applyDecorations.        ^self ].  self hasUnacceptedEdits ifTrue: [ unacceptedText := self pendingText copy ].  textModel setInitialText: newText.  unacceptedText ifNil: [ ^self textUpdated ].  self pendingText: unacceptedText.  textMorph hasEditingConflicts: true.  textMorph changed-=JUAMPI=-environment  ^environment-=JUAMPI=-defaultMenuItemName  self hasTestResult ifFalse: [ ^'Run failed' ].  ^'Run failed (' , self testResult brokenCount asString , ')'-=JUAMPI=-findItemsWith: actualObjects  | result |  self protectItemsWhile: [ result := actualObjects collect: [:eachObject |  items detect: [:item |  item representsObjectEqualTo: eachObject ] ifNone: nil ].        result select: #notNil thenDo: [:each |  each prepareIn: environment ].        ^result ]-=JUAMPI=-metalinkManagerClass  ^ExecutionCounter-=JUAMPI=-dataSource: anObject  dataSource := anObject-=JUAMPI=-scopeClass  ^ClySuperclassScope-=JUAMPI=-selectedMethodItems  ^self selectedItemsOfType: ClyMethod-=JUAMPI=-icon  ^icon-=JUAMPI=-prepareNewResult  ^asyncResult prepareNewFor: self actualQuery in: self environment-=JUAMPI=-extensionMethodFromRoot1Trait  -=JUAMPI=-setUp  super setUp.  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new-=JUAMPI=-findItemsSameAsFilter  | filterString |  filterString := table filterString asLowercase.  ^self dataSource findItemsWhere: [:each |  each name asLowercase = filterString ]-=JUAMPI=-forceRebuild  self forceLazyRebuild.  self notifyObservers-=JUAMPI=-browserTool: anObject  browserTool := anObject-=JUAMPI=-rawItemsDo: aBlock  actualResult rawItemsDo: aBlock-=JUAMPI=-decorateBrowserItem: anItem ofMethod: aMethod  aMethod usesUndeclares ifTrue: [ anItem markWith: ClyUndeclaresUserTag ]-=JUAMPI=-testComparison  self assert: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring').  self assert: (ClyMethodSourcesQuery withString: 'test substring') hash equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring') hash.  self deny: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'another substring')-=JUAMPI=-testConvertingToInheritingScopeShouldAddTraitUsers  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asInheritingScope.  self assert: (convertedScope representsScope: ClyTraitUserScope)-=JUAMPI=-showsFlatResult  ^(systemQuery retrievesItemsAs: ClyHierarchicalSystemItems) not-=JUAMPI=-multipleScopeSample  | newScope |  newScope := super multipleScopeSample.  newScope relationScopeClasses: {ClySuperclassScope}.  ^newScope-=JUAMPI=-containerForChildren  ^SortedCollection sortBlock: sortFunction-=JUAMPI=-= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^definingClass = anObject definingClass-=JUAMPI=-isSameAs: anotherSelection  self size = anotherSelection size ifFalse: [ ^false ].  items with: anotherSelection items do: [:myItem :anotherItem |  myItem actualObject == anotherItem actualObject ifFalse: [ ^false ] ].  ^true-=JUAMPI=-browser: anObject  browser := anObject-=JUAMPI=-isResult: aQueryResult affectedBy: aSystemAnnouncement  aSystemAnnouncement affectsCritiques ifFalse: [ ^false ].  aQueryResult forceLazyRebuild.  ^false-=JUAMPI=-createQuery  ^ClyLongQueryExample from: ClyScopeExample of: String in: environment-=JUAMPI=-testNotEmptyFromEmptyMethodScope  query scope: (ClyMethodScope emptyIn: environment).  self deny: query checkEmptyResult-=JUAMPI=-accumulateTestMethod: aMethod  | testSelector result inheritingScope |  testSelector := aMethod selector.  inheritingScope := (ClyClassScope of: aMethod methodClass) withInheritingScope.  inheritingScope classesDo: [:concreteTestCase |  (concreteTestCase isTestCase and: [ concreteTestCase isAbstract not ]) ifTrue: [ self accumulateTest: testSelector of: concreteTestCase.              result := testCaseResults at: concreteTestCase ifAbsentPut: [ ClyTestResultProperty new ].              result accumulateTest: testSelector of: concreteTestCase ] ]-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (Object >> #printString)}.  self assert: foundSelectors equals: #(abstractMethod1 abstractMethod2)-=JUAMPI=-build  | goButton contextLabel |  contextLabel := ownerTool printContext.  contextLabel ifEmpty: [ ^self ].  self addMorphBack: (self iconNamed: #uncommentedClass) asMorph.  self addMorphBack: contextLabel asMorph.  goButton := IconicButton new     target: self;     actionSelector: #restoreBrowserState;     arguments: {};     labelGraphic: (self iconNamed: #forward);     color: Color transparent;     helpText: 'Move browser to ' , contextLabel;     borderWidth: 0.  self addMorphBack: goButton-=JUAMPI=-menuItemNameFor: aCommand  ^menuItemName ifNil: [ aCommand defaultToolbarItemName ]-=JUAMPI=-position: anObject  position := anObject-=JUAMPI=-enableFilterUsing: aStringPattern  self enableFilter: ClyItemNameFilter using: aStringPattern-=JUAMPI=-selectsMethod: aMethod  ^scope inheritanceAnalyzer isMethodOverriding: aMethod-=JUAMPI=-groupProviderClass  ^ClyFlagMethodGroupProvider-=JUAMPI=-buildExtensionCheckBoxButton  extensionCheckbox := self theme newCheckboxIn: self for: self getSelected: #isExtensionActive setSelected: #toggleExtension getEnabled: nil label: 'extension' help: 'toggle check box to choose/reset package of method'.  extensionCheckbox     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap-=JUAMPI=-reference1OfClass  ^ClyClassReferencesQueryTest-=JUAMPI=-runBuildProcess  buildProcess := [ self buildActualResult ] newProcess.  buildProcess     name: 'Build result of ' , buildingQuery printString;     priority: Processor userBackgroundPriority.  buildProcess resume-=JUAMPI=-classesSize  ^classQuery execute size-=JUAMPI=-isClassTagSelected  | groups |  groups := tool classGroupSelection.  groups isEmpty ifTrue: [ ^false ].  ^groups lastSelectedItem type isBasedOnClassTag-=JUAMPI=-execute  sourceNode nodesWithLinks do: [:each |  self metalinkManagerClass removeFrom: each ]-=JUAMPI=-rebuildAllTools  tabManager updateTools.  self rebuildToolbar-=JUAMPI=-buildResult: aQueryResult  | critiques methods |  critiques := critiqueQuery execute.  methods := critiques items collect: [:each |  each sourceAnchor entity ] as: IdentitySet.  aQueryResult fillWith: methods-=JUAMPI=-attachToSystem  -=JUAMPI=-wantsStayInDifferentContext  self isBuilt ifFalse: [ ^false ].  self hasUnacceptedEdits ifTrue: [ ^true ].  self isTabSelected & self isExtraSelectionRequested ifTrue: [ ^true ].  self belongsToRemovedBrowserContext ifTrue: [ ^false ].  ^isManagedByUser-=JUAMPI=-openFor: anItemObserver  self moveToStart.  itemObserver := anItemObserver.  queryResult subscribe: itemObserver-=JUAMPI=-buildIsDone  self notifyObservers.  environment systemChanged: (ClyAsyncQueryIsDone with: self)-=JUAMPI=-changesCancelled  textMorph hasUnacceptedEdits: false.  self textUpdated-=JUAMPI=-testPrepareResultForExecutionWhenItIsSemiAsync  | preparedResult |  preparedResult := query semiAsync prepareNewResult.  self assert: preparedResult class equals: ClySemiAsyncQueryResult.  self assert: preparedResult buildingQuery identicalTo: query actualQuery.  self assert: preparedResult environment identicalTo: environment.  self assert: preparedResult isProtected-=JUAMPI=-initialize  super initialize.  fullIndentation := false.  self cellInset: 2 @ 0-=JUAMPI=-isCommandAvailable: aCommand  ^aCommand canBeExecutedInTool: self-=JUAMPI=-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red.  anItemCellMorph definitionIcon: #smallDebug-=JUAMPI=-itemOfThisTestMethod  ^ClyBrowserItem with: self class >> testSelector-=JUAMPI=-browser  ^tool browser-=JUAMPI=-methodFromTraitChild2  -=JUAMPI=-filterField  ^table filterField-=JUAMPI=-testNotAffectedByChangeOfSubclassMethodWhichNotOverridesSuperclass  self deny: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)-=JUAMPI=-itemsChanged  dirty ifTrue: [ ^self ].  dirty := true.  self scheduleUpdate-=JUAMPI=-testNotSelectsMethodWhichHasNoUndeclares  self deny: (query selectsMethod: Object >> #printString)-=JUAMPI=-createInheritingScopeFrom: aClassScope  | scope |  scope := annotatedClass createInheritingScopeFrom: aClassScope.  scope name: ClyClassScope inheritingScopeName.  ^scope-=JUAMPI=-increasedByClassesFrom: aClassScope  ^self withExtraBasisObjects: aClassScope collectAllClasses-=JUAMPI=-testFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 3.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector).  self assert: (resultItems identityIncludes: self class superclass >> self targetSelector)-=JUAMPI=-close  queryResult unsubscribe: itemObserver.  itemObserver := nil.  ^ClyClosedBrowserCursor instance-=JUAMPI=-testCompareTwoMethods  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object >> #size value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  methodQuery printOn: aStream.  aStream nextPut: $)-=JUAMPI=-checkEmptyResult  ^self installedMethods isEmpty-=JUAMPI=-buildItemsPerClassFrom: systemObjects  | itemsPerClass item localItems |  itemsPerClass := IdentityDictionary new.  systemObjects do: [:each |  item := each asCalypsoBrowserItem.        localItems := itemsPerClass at: item systemDefinitionClass ifAbsentPut: [ self containerForItemsOfClass ].        localItems add: item ].  ^itemsPerClass-=JUAMPI=-actualObject: anObject  actualObject := anObject.  type := anObject calypsoEnvironmentType-=JUAMPI=-testIsAffectedByChangeOfAbstractMethodWhichIsImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #abstractMethod1)-=JUAMPI=-editingMethod: aMethod  editingMethod := aMethod-=JUAMPI=-isActive  ^ownerTool extendingPackage notNil-=JUAMPI=-testFillingWithTwoEqualVarsOfDifferentSubclassesAndOneVarOfSuperclass  queryResult fillWith: {(ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN2OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN1OfClass1FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar2 #subclassSameVar #subclassSameVar)-=JUAMPI=-testCreationUnifiedInstance  scope := self createSampleScope.  self assert: scope asUnifiedInstance identicalTo: scope-=JUAMPI=-localMethod  -=JUAMPI=-isBasedOnEmptyBasis  ^self basisSize = 0-=JUAMPI=-cleanGarbageInCache  accessGuard critical: [ queryCache clyCleanGarbage ]-=JUAMPI=-subscribe: anObject  announcer ifNil: [ announcer := Announcer new ].  announcer when: ClyEnvironmentChanged send: #itemsChanged to: anObject-=JUAMPI=-browser: anObject  browser := anObject-=JUAMPI=-testCreationFromTwoSameQueriesOfSameScopeButWithDifferentParameter  | subquery1 subquery2 |  subquery1 := self subqueryFromScopeOf: Array.  subquery1 scope extraParameter: #testParameter.  subquery2 := self subqueryFromScopeOf: Array.  subquery2 scope extraParameter: #testParameter2.  query := subquery1 , subquery2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {subquery1 .         subquery2} asSet.  self assert: query requiredResult identicalTo: subquery1 requiredResult-=JUAMPI=-size  ^self protectItemsWhile: [ items size ]-=JUAMPI=-testRetrievesMethodQuery  self snapshotState.  self assert: navigationState systemQuery equals: browser systemQuery-=JUAMPI=-hash  ^sortFunction hash bitXor: inverse hash-=JUAMPI=-name  ^name-=JUAMPI=-testItemsInitializationShouldNotResetExistingItems  queryResult items: #(items).  queryResult initializeItems.  self assert: queryResult items equals: #(items)-=JUAMPI=-printContext  ^super printContext , ' / ' , editingClass name-=JUAMPI=-testMethodsEnumerationWhenBothMetaLevels  scope := ClyTraitUserScope of: ClyTraitRoot1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyTraitChild1 localMethods).  self assert: (result includesAll: ClyTraitChild1 classSide localMethods).  self assert: (result includesAll: ClyClassWithTraits localMethods).  self assert: (result includesAll: ClyClassWithTraits classSide localMethods).  self deny: (result includesAll: ClyTraitRoot1 localMethods).  self deny: (result includesAll: ClyTraitRoot1 classSide localMethods)-=JUAMPI=-setUpActiveScope  systemQuery isBoundToEnvironment ifFalse: [ systemQuery := systemQuery withScope: self systemScope ].  (queryScopes includes: systemQuery scope) ifFalse: [ queryScopes add: systemQuery scope ].  activeScope := systemQuery scope-=JUAMPI=-scopeNames  ^self scopes collect: [:each |  each description capitalized ]-=JUAMPI=-toolWasRemoved  -=JUAMPI=-defaultMenuItemName  ^'Jump to test class'-=JUAMPI=-defaultNavigationScope  ^self isScopedModeEnabled ifFalse: [ super defaultNavigationScope ] ifTrue: [ packageView query scope ]-=JUAMPI=-isAboutSelectedItem: aDataSourceItem  (selectedItems anySatisfy: [:each |  each actualObject == aDataSourceItem actualObject ]) ifTrue: [ ^true ].  (selectedItems anySatisfy: [:each |  each name = aDataSourceItem name ]) ifFalse: [ ^false ].  ^selectedItems anySatisfy: [:each |  each isEqualTo: aDataSourceItem ]-=JUAMPI=-checkEmptyResult  ^critiqueQuery hasEmptyResult-=JUAMPI=-tools: anObject  tools := anObject-=JUAMPI=-hasEmptyResult  ^scope isQueryEmpty: self-=JUAMPI=-singleBasisSample  ^ClyClass1FromP1 package-=JUAMPI=-toggle  textMorph lineNumbersRuler ifNil: [ textMorph withLineNumbers ] ifNotNil: [ textMorph withoutLineNumbers ].  self updateLabel-=JUAMPI=-ensureVisibleLastItem  rootDataSource table ensureVisibleFirstSelection-=JUAMPI=-forceRebuild  actualResult forceRebuild-=JUAMPI=-fillStatusBar  self belongsToCurrentBrowserContext ifFalse: [ statusBar addContextItem: (ClyToolContextNavigatorMorph for: self) ]-=JUAMPI=-hash  ^super hash bitXor: variableQuery hash-=JUAMPI=-testMoveToItemWhichSatisfiesConditionWhenItNotExistsInCache  | found |  cursor cleanCache.  found := cursor moveToItemWhich: [:each |  each actualObject = Object ].  self assert: found.  self assert: cursor position equals: 2.  self assert: cursor currentItem actualObject equals: Object-=JUAMPI=-testVariableNamedThisContext_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'ThisContext') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext lookupSymbol: #ThisContext)]')-=JUAMPI=-testNotSelectsMethodWithoutWatchpoint  self deny: (query selectsMethod: self class >> #methodWithoutWatchpoint)-=JUAMPI=-execute  | class |  class := browser searchDialog requestSingleObject: 'Choose class' from: ClyAllClassesQuery sorted.  browser selectClass: class-=JUAMPI=-decorateBrowserItem: anItem ofPackage: aPackage  -=JUAMPI=-testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> #method1).  self assert: (resultItems identityIncludes: self class >> #method2)-=JUAMPI=-bindTo: aScope in: aNavigationEnvironment  aScope bindTo: aNavigationEnvironment.  self scope: aScope-=JUAMPI=-activationPriority  ^-100-=JUAMPI=-method1  -=JUAMPI=-metaLevelScope: anObject  metaLevelScope := anObject-=JUAMPI=-createBlockFromPattern  (pattern value endsWith: ']') ifFalse: [ badScript := true.        ^self ].  [ scriptBlock := self class compiler evaluate: pattern value ] on: Exception do: [:err |  badScript := true ]-=JUAMPI=-build  self addMorphBack: label-=JUAMPI=-metadata  ^metadata ifNil: [ self collectMetadata.        metadata ]-=JUAMPI=-updateTabsWith: newTools  | toRemove toInstall |  toRemove := OrderedCollection withAll: tools.  toInstall := OrderedCollection new.  newTools do: [:new |  tools detect: [:existing |  existing isSimilarTo: new ] ifFound: [:existing |  toRemove remove: existing ] ifNone: [ toInstall add: new ] ].  toRemove do: [:each |  each wantsStayInDifferentContext ifFalse: [ each removeFromBrowser ] ].  tools do: [:each |  each browserContextWasChanged ].  toInstall do: [:each |  self addTool: each ]-=JUAMPI=-isSameAsCurrent: anObject  isSameAsCurrent := anObject-=JUAMPI=-adoptLocalScopeClassTo: aLocalScopeClass  localScopeClass := aLocalScopeClass-=JUAMPI=-createQueryResult  ^ClyClassBindings new-=JUAMPI=-requestSingleObject: dialogTitle from: aQuery inScope: aScope  aScope bindTo: browser navigationEnvironment.  ^self requestSingleObject: dialogTitle from: (aScope adoptQuery: aQuery)-=JUAMPI=-testBasedOnMultipleBasis  scope := self multipleScopeSample.  self assert: scope isBasedOnMultipleBasis.  scope := self singleScopeSample.  self deny: scope isBasedOnMultipleBasis.  scope := self emptyScopeSample.  self deny: scope isBasedOnMultipleBasis-=JUAMPI=-defaultMenuIconName  ^#trait-=JUAMPI=-critique  ^critique-=JUAMPI=-affectsMethods  ^true-=JUAMPI=-execute  UIManager default debugProcess: Processor activeProcess context: critique stack label: critique message fullView: true-=JUAMPI=-testMethodsEnumeration  | expected |  scope := ClyClassScope of: ClyClass1FromP1.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArray-=JUAMPI=-changeStateBy: aBlock  aBlock value-=JUAMPI=-execute  script executeOn: targetClass-=JUAMPI=-initialize  super initialize.  basisObjects := #()-=JUAMPI=-findItemsSimilarTo: dataSourceItems  | myItems childItems |  myItems := super findItemsSimilarTo: dataSourceItems.  myItems size == dataSourceItems size ifTrue: [ ^myItems ].  childItems := expandedItems flatCollect: [:each |  each childrenDataSource findItemsSimilarTo: dataSourceItems ].  ^myItems , childItems-=JUAMPI=-packagesDo: aBlock  self system packages do: aBlock-=JUAMPI=-prepareExecutionInDropContext: aToolContext  super prepareExecutionInDropContext: aToolContext.  package := aToolContext lastSelectedPackage-=JUAMPI=-targetClass  ^targetClass-=JUAMPI=-conditionBlock: anObject  conditionBlock := anObject-=JUAMPI=-prepareInitialState  -=JUAMPI=-basisObjects: aCollection  super basisObjects: (self prepareBasisFrom: aCollection)-=JUAMPI=-decorateOwnBrowserItem: myItem  super decorateOwnBrowserItem: myItem.  classQuery decorateItemGroup: myItem.  subgroupsQuery decorateItemGroup: myItem-=JUAMPI=-defaultMenuItemName  ^'Writers'-=JUAMPI=-allowsDifferentActivationPriority  ^true-=JUAMPI=-testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  < expectedFailure>  super testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject-=JUAMPI=-readerOfVar1  ^writtenVar1-=JUAMPI=-selectedPackageItems  ^tool packageSelection items-=JUAMPI=-selectsMethod: aMethod  | plugin |  plugin := self environment getPlugin: ClyReflectiveEnvironmentPlugin.  ^plugin doesMethodHasWatchpoint: aMethod-=JUAMPI=-representsConcreteQuery  ^true-=JUAMPI=-findItemsSimilarTo: sampleBrowserItems  ^cache findItemsWith: (sampleBrowserItems collect: #actualObject) forAbsentDo: [ ^queryResult findItemsSimilarTo: sampleBrowserItems ]-=JUAMPI=-fillWith: classes  | definedClasses extensions |  definedClasses := IdentitySet withAll: classes.  extensions := OrderedCollection new.  classes do: [:each |  (self isQueryScopeDefinesClass: each) ifFalse: [ definedClasses remove: each.              extensions add: each ] ].  items := self buildItemsFrom: definedClasses.  items addAll: (self buildExtensionItemsFrom: extensions)-=JUAMPI=-methodGroupType  ^ClyVariable-=JUAMPI=-isCommandAvailable: aCommand  ^aCommand canBeExecutedInCodeMethodEditor: self-=JUAMPI=-defaultMenuIconName  ^#smallRedo-=JUAMPI=-superclassVar1WriterMethod  instanceSideVar1 := #subclassVar1Value-=JUAMPI=-extraBasisSample  ^ClySubclassMOfClass1FromP2 package-=JUAMPI=-testConvertingToSomeHierarchyScope  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asScope: ClySubclassScope.  self assert: convertedScope class equals: ClySubclassScope.  self assert: convertedScope localScopeClass equals: scope localScopeClass.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environment-=JUAMPI=-defaultItems  ^SortedCollection sortBlock: sortFunction-=JUAMPI=-direction: anObject  direction := anObject-=JUAMPI=-isParentExpanded  parentItem ifNil: [ ^true ].  ^parentItem isExpanded-=JUAMPI=-testIsExecutedFromConcreteScopeClass  self assert: (query isExecutedFromScope: query scope class).  self assert: (query isExecutedFromScope: query scope class superclass).  self deny: (query isExecutedFromScope: ClyScopeExample2)-=JUAMPI=-testConvertingAsRestrictedByAnotherScope2  | convertedScope restrictedScope |  scope := self singleScopeSample.  restrictedScope := self multipleScopeSample.  convertedScope := scope restrictedBy: restrictedScope.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects equals: restrictedScope basisObjects-=JUAMPI=-classSampleWhichHasGroup  ^ClySubclassN1OfClass1FromP1-=JUAMPI=-hash  ^super hash bitXor: pattern hash-=JUAMPI=-start  ^start-=JUAMPI=-isMultipleSelected  ^items size > 1-=JUAMPI=-showVariableNamed: aString  tool selectVariableNamed: aString-=JUAMPI=-includesClass: aClass  self classesDo: [:each |  each = aClass ifTrue: [ ^true ] ].  ^false-=JUAMPI=-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  | icon |  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  icon := anItemCellMorph definitionIcon: #flagIcon.  icon setBalloonText: 'There are methods with flag'-=JUAMPI=-printContext  ^''-=JUAMPI=-description  ^'all method groups'-=JUAMPI=-decorateResultMethodEditor: aMethodEditor  criteriaString ifNil: [ ^self ].  aMethodEditor selectStringAsInMessageBrowser: criteriaString-=JUAMPI=-execute  browser switchToVariables-=JUAMPI=-variableQuery: aVariableQuery  variableQuery := aVariableQuery-=JUAMPI=-createBrowser  ^ClyFullBrowser new-=JUAMPI=-description  ^'Do not supported currently'-=JUAMPI=-queryScope: anObject  queryScope := anObject-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  testItems := aToolContext selectedItems select: [:each |  each hasProperty: ClyTestResultProperty ]-=JUAMPI=-initialize  super initialize.  undoExecuting := false.  redoExecuting := false.  waitingNewState := true.  undoList := OrderedCollection new.  redoList := OrderedCollection new-=JUAMPI=-createQuery  ^ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: #basisObject in: environment-=JUAMPI=-defaultMenuItemName  ^'Run script'-=JUAMPI=-defaultMenuItemName  ^'Move to package'-=JUAMPI=-activeWindow  self tabGroup pages size = 0 ifTrue: [ ^nil ].  self tabGroup selectedPageIndex <= 0 ifTrue: [ ^nil ].  ^self tabGroup pages at: self tabGroup selectedPageIndex-=JUAMPI=-initialize  super initialize.  methodTags := #()-=JUAMPI=-testCheckIfEmpty  self installCounterInto: #methodWithCounter.  query scope: (ClyMethodScope of: self class >> #methodWithCounter in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-=JUAMPI=-littleHierarchyMaxSize: anObject  littleHierarchyMaxSize := anObject-=JUAMPI=-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red-=JUAMPI=-affectedPackage: anObject  affectedPackage := anObject-=JUAMPI=-execute  browser switchToProjects-=JUAMPI=-execute  | queries fullQuery |  queries := methodGroups collect: [:each |  each methodQuery ].  fullQuery := ClyQuery unionFrom: queries.  browser spawnQueryBrowserOn: fullQuery-=JUAMPI=-initialize  super initialize.  collapsedItems := SortedCollection sortBlock: [:a :b |  a position < b position ]-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  browser := aToolContext browser-=JUAMPI=-isPrepared  ^isPrepared-=JUAMPI=-defaultMenuItemName  ^'Add breakpoint condition..'-=JUAMPI=-testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  < expectedFailure>  super testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects-=JUAMPI=-hierarchy  ^hierarchy-=JUAMPI=-allItems  ^self prepareItems: actualResult allItems-=JUAMPI=-decorateBrowserItem: anItem ofPackage: aPackage  aPackage isDeprecated ifTrue: [ anItem markWith: ClyDeprecatedItemTag ]-=JUAMPI=-query: aQuery  ^ClyUnknownQueryResult instance-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  classQuery printOn: aStream.  aStream nextPut: $)-=JUAMPI=-methodWithoutCritiques  ^ClyClassWithProblemMethods >> #methodWithoutCritiques-=JUAMPI=-findTestedClassCoveredBy: aTestClass ifAbsent: absentBlock  | className |  className := aTestClass instanceSide name.  (className endsWith: 'Tests') ifTrue: [ ^environment system classNamed: (className allButLast: 5) asSymbol ifAbsent: absentBlock ].  (className endsWith: 'Test') ifTrue: [ ^environment system classNamed: (className allButLast: 4) asSymbol ifAbsent: absentBlock ].  ^absentBlock value-=JUAMPI=-newName  ^newName-=JUAMPI=-prepareIn: aNavigationEnvironment  isPrepared ifTrue: [ ^self ].  aNavigationEnvironment pluginsDo: [:each |  self decorateBy: each ].  isPrepared := true-=JUAMPI=-tableCellIcon  ^Smalltalk ui iconNamed: #halt-=JUAMPI=-restoreBrowserState  self browser selectObject: self lastSelectedObject-=JUAMPI=-testConvertingAsRestrictedByAnotherScope  | convertedQuery restrictedScope |  restrictedScope := ClyScopeExample2 of: #restrictedBasis.  convertedQuery := query restrictedByScope: restrictedScope.  self assert: convertedQuery class equals: query class.  self assert: convertedQuery requiredResult identicalTo: query requiredResult.  self assert: (convertedQuery subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (convertedQuery subqueries collect: #scope) equals: (query subqueries collect: [:each |  each scope withNewBasisObjects: #(restrictedBasis) ])-=JUAMPI=-normalizeSelectorForComparison: aString  | selectorString selectorStringSize normalizedSelectorString normalizedSelectorStringSize |  selectorString := aString asString.  selectorStringSize := aString size.  normalizedSelectorString := selectorString class new: selectorStringSize.  normalizedSelectorStringSize := 0.  1 to: selectorStringSize do: [:i |  | nextChar |        (nextChar := selectorString at: i) == $: ifFalse: [ normalizedSelectorString at: (normalizedSelectorStringSize := normalizedSelectorStringSize + 1) put: nextChar ] ].  ^(normalizedSelectorStringSize < selectorStringSize ifTrue: [ normalizedSelectorString first: normalizedSelectorStringSize ] ifFalse: [ selectorString ]) asLowercase-=JUAMPI=-defaultMenuItemName  ^'Show in method browser'-=JUAMPI=-selectsMethod: aMethod  ^aMethod isExtension-=JUAMPI=-toggleFullWindowTabs  | tabMorph |  tabMorph := tabManager tabMorph.  (submorphs includes: tabMorph) ifFalse: [ self addMorph: tabMorph fullFrame: LayoutFrame identity ] ifTrue: [ toolPanel addMorphBack: tabMorph ]-=JUAMPI=-methodGroups  ^methodGroups-=JUAMPI=-prepareExecutionInDropContext: aToolContext  | selectedClasses |  super prepareExecutionInDropContext: aToolContext.  methodGroup := aToolContext lastSelectedMethodGroup.  selectedClasses := aToolContext selectedClasses.  selectedClasses := selectedClasses collect: [:each |  aToolContext currentMetaLevelOf: each ].  targetClass := selectedClasses size > 1 ifTrue: [ aToolContext requestSingleClass: 'In what class you want to move method?' from: selectedClasses ] ifFalse: [ selectedClasses last ]-=JUAMPI=-decorateMethodEditor: aMethodEditor  methodView query decorateResultMethodEditor: aMethodEditor-=JUAMPI=-methodWithoutBreakpoints  -=JUAMPI=-testCreationWithSingleSubqueryButAnotherResult  | subquery |  subquery := self subqueryFromScopeOf: Array.  query := ClyUnionQuery with: {subquery} as: #specialResult.  self assert: query class equals: subquery class.  self assert: query scope equals: subquery scope.  self assert: query requiredResult equals: #specialResult.  self deny: subquery requiredResult equals: #specialResult-=JUAMPI=-addNewCommentForTestClass: aClass basedOn: baseClass  aClass comment: (String streamContents: [:stream |  | name |              name := aClass name.              name first isVowel ifTrue: [ stream nextPutAll: 'An ' ] ifFalse: [ stream nextPutAll: 'A ' ].              stream                 nextPutAll: name;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: baseClass name ])-=JUAMPI=-testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self deny: query isExecutedFromSingleScope-=JUAMPI=-testClass  ^testClass-=JUAMPI=-createTableCellButtonWith: anIcon using: aCommandActivator  | button |  button := super createTableCellButtonWith: anIcon using: aCommandActivator.  sourceNode hasExecutionCounter ifTrue: [ ClyDynamicBallonTooltip from: [ self tableDescription ] installInto: button ].  ^button-=JUAMPI=-execute  browser spawnQueryBrowserOn: (ClyVariableReferencesQuery ofAny: variables)-=JUAMPI=-testCreationFromAnotherCompositeQueryAndSimilarQuery  | subquery1 subquery2 subquery3 |  subquery1 := self subqueryFromScopeOf: Array.  subquery2 := self subqueryFromScope: ClyScopeExample2 of: String.  subquery3 := self subqueryFromScopeOf: Object.  query := subquery1 , subquery2 , subquery3.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {(self subqueryFromScope: (ClyScopeExample ofAll: {Array .                     Object})) .         subquery2} asSet.  self assert: query requiredResult equals: subquery1 requiredResult-=JUAMPI=-requestSingleClass: queryTitle  ^tool searchDialog requestSingleObject: queryTitle from: ClyAllClassesQuery sorted-=JUAMPI=-hash  ^super hash bitXor: hierarchy hash-=JUAMPI=-packageScopeOfSelectedItems  | packages |  packages := self selection items collect: [:methodItem |  methodItem systemDefinition definingPackage ].  ^ClyPackageScope ofAll: packages in: navigationEnvironment-=JUAMPI=-buildsDefaultResult  ^self retrievesItemsAs: self defaultResult class-=JUAMPI=-isMethodSelected  ^false-=JUAMPI=-copyForBrowserStateSnapshotOf: rootDataSourceSnapshot  | copy ownerDataSourceSnapshot |  ownerDataSourceSnapshot := rootDataSourceSnapshot findDataSourceSameAs: ownerDataSource ifNone: [ self error: 'should not happen' ].  copy := self copy.  copy ownerDataSource: ownerDataSourceSnapshot.  childrenDataSource ifNotNil: [ copy childrenDataSource: childrenDataSource copyForBrowserStateSnapshot ].  ^copy-=JUAMPI=-shouldSkipCurrentDesiredSelection  ^shouldSkipCurrentDesiredSelection-=JUAMPI=-testResult  ^testResult-=JUAMPI=-defaultMenuItemName  ^'Inspect'-=JUAMPI=-ownerTool  ^ownerTool-=JUAMPI=-simpleNameForSpotterMenu  ^'Variables'-=JUAMPI=-fillWith: packages  | group |  packages do: [:each |  group := ClyExternalPackageMethodGroup withMethodsFrom: self scope packagedIn: each.        items add: group ]-=JUAMPI=-canDetectAffectOnClassesBy: aSystemAnnouncement  ^(aSystemAnnouncement isKindOf: ClassAnnouncement) not-=JUAMPI=-defaultMenuIconName  ^#glamorousBrowse-=JUAMPI=-isAssignmentSelected  | node |  node := self selectedSourceNode.  [ node notNil ] whileTrue: [ node isAssignment ifTrue: [ ^true ].        node := node parent ].  ^false-=JUAMPI=-setUp  super setUp.  environment := nil-=JUAMPI=-extendClassScopeForMethods: aClassScope  | resultScope |  resultScope := aClassScope.  (ClyMethodVisibilityLevel allAvailableFor: self classSelection items) ifNotEmpty: [:levels |  resultScope := levels anyOne extendClassScope: resultScope ].  ^resultScope-=JUAMPI=-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-=JUAMPI=-testClassEnumerationOverClassWhenBothMetaLevelsAreLocalScope  | expected |  scope := ClySubclassScope of: Class localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:each |  result add: each ].  expected := Class subclasses select: #isInstanceSide.  expected := expected flatCollect: [:each |  {each instanceSide .         each classSide} ].  self assert: result asSet equals: expected asSet-=JUAMPI=-critique: anObject  critique := anObject-=JUAMPI=-testComparisonToSimilarQueryButWithDifferentTag  | query2 |  query tag: #tag1.  query2 := self createQuery.  query2 tag: #anotherTag.  self deny: query equals: query2-=JUAMPI=-open  | query methods comments |  methods := messages select: [:each |  (each isRingObject and: [ each isMethod ]) or: [ each isCompiledMethod ] ] thenCollect: [:each |  each compiledMethod ].  comments := messages select: [:each |  each isRingObject and: [ each isComment ] ] thenCollect: [:each |  ClyClassComment of: each parent realClass ].  query := ClyOldMessageBrowserQuery named: title with: methods asOrderedCollection , comments.  query     criteriaString: autoSelect;     criteriaBlock: refreshingBlock.  openedBrowser := ClyQueryBrowser openOn: query-=JUAMPI=-isSelectedItemHasWatchpoint  ^selectedSourceNode hasWatchpoint-=JUAMPI=-includesMethod: aMethod  self asyncQueryResult isBuilt ifFalse: [ ^false ].  ^super includesMethod: aMethod-=JUAMPI=-attachToSystem  browser system when: (ClyMethodChange of: self editingMethod) send: #triggerUpdate to: self-=JUAMPI=-referenceOfNumberClassByNameSymbol  ^#Number-=JUAMPI=-update  leftMethod := leftMethod origin localMethodNamed: leftMethod selector ifAbsent: [ ^self ].  rightMethod := rightMethod origin localMethodNamed: rightMethod selector ifAbsent: [ ^self ].  super update.  diffMorph from: leftMethod sourceCode to: rightMethod sourceCode-=JUAMPI=-printDefinition  ^definingPackageItem name-=JUAMPI=-methodTags  ^methodTags-=JUAMPI=-scopeWithCritiques  ^ClyMethodScope of: self methodWithCritiques in: environment-=JUAMPI=-setUp  super setUp.  browser prepareInitialState-=JUAMPI=-isClassVariable  ^true-=JUAMPI=-browserPlugins  ^browserPlugins-=JUAMPI=-isEmpty  ^self itemCursor itemCount = 0-=JUAMPI=-isQueryEmpty: aQuery  self isBasedOnEmptyBasis ifTrue: [ ^true ].  aQuery ensureScope: self.  ^environment isQueryEmpty: aQuery-=JUAMPI=-supeclassWriterOfVar1  writtenVar1 := #superclassValue-=JUAMPI=-testConvertingToInheritedScope  | convertedScope |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope asInheritedScope.  self assert: (convertedScope representsScope: ClySuperclassScope).  self assert: convertedScope localScopeClass equals: ClyInstanceSideScope.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environment.  self assert: convertedScope name equals: ClyClassScope inheritedScopeName-=JUAMPI=-selectMethodGroupNamed: tagName  self changeStateBy: [ self methodGroupSelection selectItemsWhere: [:each |  each name = tagName ] ]-=JUAMPI=-testDecoratingMethodWithExecutionCounter  | plugin method methodItem |  plugin := ClyReflectiveEnvironmentPlugin new.  self installWatchpointInto: #methodWithWatchpoint.  method := self class >> #methodWithWatchpoint.  methodItem := method asCalypsoBrowserItem.  plugin decorateBrowserItem: methodItem ofMethod: method.  self assert: (methodItem isMarkedWith: ClyMethodWithWatchpointTag)-=JUAMPI=-subgroupsQuery: anObject  subgroupsQuery := anObject-=JUAMPI=-testForceLazyRebuild  self assert: queryResult items notNil.  queryResult forceLazyRebuild.  self assert: queryResult needsRebuild-=JUAMPI=-createQuery  ^ClyUntaggedClassesQuery from: (ClyClassScope of: Object in: environment)-=JUAMPI=-addContextItem: aMorph  contextBar addMorphBack: aMorph.  ^aMorph-=JUAMPI=-restoreTableSelectionSilently: silentSelection  | selectionIndexes |  items := items reject: [:each |  each isRemoved ].  selectionIndexes := items collect: #globalPosition.  self setUpSelectedRows: selectionIndexes in: rootDataSource table silently: silentSelection-=JUAMPI=-includesVariablesAffectedBy: aSystemAnnouncement  self classesDo: [:class |  (aSystemAnnouncement affectsVariablesOf: class) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-createQuery  ^ClyMethodWatchpointsQuery from: ClyClassScope of: self class in: environment-=JUAMPI=-collapsedButton  ^IconicButton new     target: item;     actionSelector: #expand;     arguments: {};     labelGraphic: self theme treeUnexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-=JUAMPI=-senderOfIfTrue  ^2 * 2 = 4 ifTrue: [ 100 ]-=JUAMPI=-hash  ^super hash bitXor: baseQueryResult hash-=JUAMPI=-affectsMethodsDefinedInClass: aClass  ^(aClass includesLocalSelector: self overriddenMethod selector) and: [ aClass inheritsFrom: self overriddenMethod origin ]-=JUAMPI=-context  ^context-=JUAMPI=-retrievesItem: aVariable  ^aVariable isKindOf: ClyInstanceVariable-=JUAMPI=-testFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}-=JUAMPI=-packageOrganizer  ^packageOrganizer-=JUAMPI=-itemsChanged  navigationStarted ifTrue: [ ^self ].  navigationStarted := true.  [ self rebuildToolsForChangedEnvironment ] ensure: [ navigationStarted := false ]-=JUAMPI=-actualObject: anObject  ^browserItem actualObject: anObject-=JUAMPI=-withInheritedScope  | fullScope |  fullScope := self , self asInheritedScope.  fullScope name: self class hierarchyScopeName.  ^fullScope-=JUAMPI=-deprecatedMethod2  self deprecated: 'it is deprecated method for testing deprecation analyzis'-=JUAMPI=-testConvertingToInterestingClassScope  | convertedScope |  scope := ClyMultipleClassRelationScope of: {String} merging: {ClySuperclassScope .         ClySubclassScope}.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope asInterestingClassScope.  self deny: convertedScope identicalTo: scope.  self assert: convertedScope class equals: ClyMultipleClassRelationScope.  self assert: convertedScope relationScopeClasses equals: {ClyInterestingSuperclassScope .         ClySubclassScope}.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope localScopeClass equals: scope localScopeClass.  self assert: convertedScope environment equals: scope environment-=JUAMPI=-testExecution  | scope mainQuery |  scope := ClyScopeExample ofAll: {self class superclass .         self class} in: environment.  mainQuery := ClyQueryExampleReturningScopeBasis from: scope.  query subqueries: {mainQuery}.  self executeQuery.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self class-=JUAMPI=-groupProviderClass  ^ClyExtendedClassGroupProvider-=JUAMPI=-isResult: aQueryResult affectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsClassExtension and: [ scope includesMethodsAffectedBy: aSystemAnnouncement ]-=JUAMPI=-ownerDataSource  ^ownerDataSource-=JUAMPI=-buildResult: aQueryResult  | result |  result := OrderedCollection new.  self analyzedObjectsDo: [:each |  result addAll: each critiques ].  aQueryResult fillWith: result-=JUAMPI=-execute  browser navigateBack-=JUAMPI=-execute  browser spawnQueryBrowserOn: (ClyClassReferencesQuery toAny: classes)-=JUAMPI=-isExecutedFromSingleScope  ^scope isBasedOnSingleBasis-=JUAMPI=-testNotBasedOnSingleBasisWhenSingleSubscopeIsNot  | subscope |  subscope := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {subscope}.  self deny: scope isBasedOnSingleBasis-=JUAMPI=-detachFromTextMorph  -=JUAMPI=-description  ^'Method watchpoints'-=JUAMPI=-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-=JUAMPI=-defaultIconName  ^#scriptManagerIcon-=JUAMPI=-name: anObject  name := anObject-=JUAMPI=-withoutBasisObject: existingBasisObject  ^self withNewBasisObjects: (basisObjects copyWithout: existingBasisObject)-=JUAMPI=-testSelectedChildInExpandedItemWithRetrievedExpandedDataSource  | selectedItem retrievedSelectedItem |  self selectedItem expand.  selectedItem := self selectedItem childrenDataSource elementAt: 1.  queryView selection selectItems: {selectedItem}.  self snapshotState.  retrievedSelectedItem := navigationState selection items first.  self assert: retrievedSelectedItem ownerDataSource equals: navigationState dataSource expandedItems first childrenDataSource-=JUAMPI=-searchText: aString  | found |  found := self itemCursor moveToItemWhich: [:each |  each name asLowercase beginsWith: aString asLowercase ].  ^found ifFalse: [ #() ] ifTrue: [ {self itemCursor position} ]-=JUAMPI=-createQuery  ^ClyPackageExtensionMethodsQuery of: ClyClass1FromP1 package from: (ClyClassScope of: ClyClass1FromP1 in: environment)-=JUAMPI=-priority  ^0-=JUAMPI=-extraBasisSample  ^ClyClass2FromP1-=JUAMPI=-addNewCommentForTestClass: aClass basedOn: baseClass  aClass comment: (String streamContents: [:stream |  | name |              name := aClass name.              name first isVowel ifTrue: [ stream nextPutAll: 'An ' ] ifFalse: [ stream nextPutAll: 'A ' ].              stream                 nextPutAll: name;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: baseClass name ])-=JUAMPI=-scope: aScope  super scope: aScope.  critiqueQuery scope: aScope-=JUAMPI=-isCaseSensitive  ^isCaseSensitive-=JUAMPI=-windowIsClosing  tools do: [:each |  each cleanAfterRemove ]-=JUAMPI=-applyTo: aBrowser  aBrowser changeStateBy: [ self restoreStateOf: aBrowser.        self restoreNavigationStateOf: aBrowser.        aBrowser tabManager restoreBrowserState: self ]-=JUAMPI=-classSampleWhichHasGroup  ^ClyClass1FromP1-=JUAMPI=-testConvertingWithExtraBasisObjectIfItIsAlreadyBasis  | convertedScope |  scope := self createSampleScope.  convertedScope := scope withExtraBasisObject: scope basisObjects anyOne.  self assert: convertedScope basisObjects equals: scope basisObjects-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithDeprecatedMethods >> #deprecatedMethod1) .         (ClyClassWithDeprecatedMethods >> #deprecatedMethod2) .         (ClyClassWithDeprecatedMethods >> #notDeprecatedMethod)}.  self assert: foundSelectors sorted asArray equals: #(deprecatedMethod1 deprecatedMethod2)-=JUAMPI=-testMatchesAnyStringWhenItIsBadRegex  | pattern |  pattern := ClyRegexPattern with: '!*'.  self assert: (pattern matches: 'any string')-=JUAMPI=-systemScope  ^systemScope ifNil: [ systemScope := navigationEnvironment systemScope ]-=JUAMPI=-closeDataSource  table initialDataSource ifNil: [ ^self dataSource close ].  table cleanupFilter.  table initialDataSource close-=JUAMPI=-doItContext  ^nil-=JUAMPI=-testExpectedMethodShouldIncludeExpectedString  self assert: ((self class >> #methodWithExpectedStringInSources) sourceCode includesSubstring: self expectedSourceCodeSubstring caseSensitive: false)-=JUAMPI=-chooseClassesForNewMethod: aMethod  | methodClass selectedClasses |  methodClass := aMethod origin.  selectedClasses := self chooseClassesForNewMethod.  selectedClasses := selectedClasses copyWithout: methodClass.  ^selectedClasses , {methodClass}-=JUAMPI=-findItemsSimilarTo: dataSourceItems  | foundItems relatedItems |  relatedItems := dataSourceItems select: [:each |  self isBasedOnQueryOf: each type ] thenCollect: [:each |  each browserItem ].  foundItems := self itemCursor findItemsSimilarTo: relatedItems.  ^foundItems collect: [:each |  self createElementWith: each ]-=JUAMPI=-pluginsDo: aBlock  ^plugins do: aBlock-=JUAMPI=-isActiveInContext: aBrowserContext  ^(super isActiveInContext: aBrowserContext) and: [ self toolClass shouldBeActivatedInContext: aBrowserContext ]-=JUAMPI=-selection: anObject  selection := anObject-=JUAMPI=-testExpandedItemWithRetrievedOwnerDataSource  | expandedItem |  self selectedItem expand.  self snapshotState.  expandedItem := navigationState dataSource expandedItems first.  self assert: expandedItem ownerDataSource equals: navigationState dataSource-=JUAMPI=-collectMetadataOf: aQueryResult by: anEnvironmentPlugin  anEnvironmentPlugin collectMetadataOfClasses: aQueryResult-=JUAMPI=-testFromClassScope  self queryFromScope: ClyClassScope ofAll: {self class .         self class superclass}.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: (ClyClassComment of: self class)-=JUAMPI=-description  ^'writers of ' , self printVariables-=JUAMPI=-testAscendingDifferentPackage  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: Object >> #printString value: Number >> #printString).  self assert: (function value: Number >> #printString value: Object >> #printString).  self assert: (function value: Object >> #printOn: value: Object >> #printString)-=JUAMPI=-lastSelectedSourceNode  ^self selectedSourceNode-=JUAMPI=-isResult: aQueryResult affectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsClasses or: [ aSystemAnnouncement canAffectResultOfMethodQuery: self ]-=JUAMPI=-lastSelectedClassGroup  ^self lastSelectedObject-=JUAMPI=-testSelectsDeprecatedMethod  self assert: (query selectsMethod: ClyClassWithDeprecatedMethods >> #deprecatedMethod1)-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: value;     nextPut: $)-=JUAMPI=-createUpdateWithItemsStartingAt: startPosition count: cacheSize  | itemCache |  itemCache := ClyBrowserQueryCache filledBy: self startingAt: startPosition size: cacheSize.  ^ClyBrowserQueryUpdate of: self withItems: itemCache-=JUAMPI=-defaultPackageFilter  ^DefaultPackageFilter ifNil: [ DefaultPackageFilter := ClyTableFilterFactory of: ClyItemNameFilter using: ClyRegexPattern new ]-=JUAMPI=-decorateBrowserItem: anItem ofMethodGroup: aMethodGroup  -=JUAMPI=-metaLevelsOf: aClass do: aBlock  self class metaLevelsOf: aClass do: aBlock-=JUAMPI=-testCheckIfEmpty  self installWatchpointInto: #methodWithWatchpoint.  query scope: (ClyMethodScope of: self class >> #methodWithWatchpoint in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-=JUAMPI=-testIsExecutedFromEmptyScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self deny: query isExecutedFromEmptyScope.  query scope: (ClyScopeExample emptyIn: environment).  self assert: query isExecutedFromEmptyScope-=JUAMPI=-buildResult: aQueryResult  | filteredClasses |  filteredClasses := Set new.  scope classesDo: [:each |  (self selectsClass: each) ifTrue: [ filteredClasses add: each ] ].  aQueryResult fillWith: filteredClasses-=JUAMPI=-createQueryResult  ^ClyMethodVisibilityGroups withHierarchy: ClySubclassHierarchy new-=JUAMPI=-methodGroupView  ^methodGroupView-=JUAMPI=-classCommentsContainingIt  | query |  self lineSelectAndEmptyCheck: [ ^self ].  query := ClyClassCommentsQuery withString: self selection string.  self browser spawnQueryBrowserOn: query-=JUAMPI=-initialize  super initialize.  cacheGuard := Mutex new.  littleHierarchyMaxSize := 10-=JUAMPI=-isComplexRefactoring  ^true-=JUAMPI=-containerForItemsOfClass  ^SortedCollection sortBlock: ClySortSystemItemFunction ascending forBrowserItems-=JUAMPI=-announceChangesOf: aQueryResult  self subclassResponsibility-=JUAMPI=-isEditableGroup  ^self class isEditableGroup-=JUAMPI=-browser  ^item browser-=JUAMPI=-isNavigationPanelFocused  ^navigationViews anySatisfy: [:each |  each hasKeyboardFocus ]-=JUAMPI=-defineTrait: defString notifying: aController startingFrom: aClass  | defTokens keywdIx oldTrait newTraitName trait |  aClass isTrait ifTrue: [ oldTrait := aClass ].  defTokens := defString findTokens: Character separators.  keywdIx := defTokens findFirst: [:x |  x = 'category' ].  keywdIx := defTokens findFirst: [:x |  x = 'named:' ].  newTraitName := (defTokens at: keywdIx + 1) copyWithoutAll: '#()'.  ((oldTrait isNil or: [ oldTrait instanceSide name asString ~= newTraitName ]) and: [ self includesClassNamed: newTraitName asSymbol ]) ifTrue: [ (self confirm: ((newTraitName , ' is an existing class/trait in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newTraitName size)) ifFalse: [ ^nil ] ].  trait := self defaultClassCompiler     source: defString;     requestor: aController;     logged: true;     evaluate.  ^trait isTrait ifTrue: [ trait ] ifFalse: [ nil ]-=JUAMPI=-requiredQueryResult  ^systemQuery ifNil: [ self class defaultQueryResult ] ifNotNil: [ systemQuery requiredResult ]-=JUAMPI=-selectItemsWhere: conditionBlock  | newItems |  newItems := rootDataSource findItemsWhere: conditionBlock.  self selectItems: newItems-=JUAMPI=-createPackageNamed: packageName  ^packageOrganizer createPackageNamed: packageName-=JUAMPI=-itemsStartingWhere: conditionBlock count: size  ^self prepareItems: (actualResult itemsStartingWhere: conditionBlock count: size)-=JUAMPI=-testClassEnumerationOverMetaclassWhenClassSideIsLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassSideScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {Object class .         ProtoObject class} asSet-=JUAMPI=-notifyChanges  announcer announce: ClyEnvironmentChanged-=JUAMPI=-testFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reference1OfVar1) .         (self class >> #referenceOfAnotherVar)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfVar1-=JUAMPI=-execute  browser switchFocusToPreviousPane-=JUAMPI=-testFillingWithThreeClasVarsOfSuperclassAndSubclass  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #SubclassClassVar definedIn: ClySubclassLOfClass2FromP1) .         (ClyClassVariable named: #ClassVar2 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#ClassVar1 #ClassVar2 #SubclassClassVar)-=JUAMPI=-testClassEnumerationOverClassWhenInstanceSideIsLocalScope  | expected |  scope := ClySubclassScope of: Class localScope: ClyInstanceSideScope.  scope classesDo: [:each |  result add: each ].  expected := Class subclasses select: #isInstanceSide.  self assert: result asSet equals: expected asSet-=JUAMPI=-packages: anObject  packages := anObject-=JUAMPI=-collectMethodGroupProviders  ^{ClyUndeclaredMethodGroupProvider new}-=JUAMPI=-affectsMethodsTaggedWith: tagName  overriddenSuperclass withAllSubclassesDo: [:each |  (each tagsForMethods includes: tagName) ifTrue: [ ^true ] ].  ^false-=JUAMPI=-unionWith: typedQueries as: aQueryResult  ^ClyQuery unionFrom: typedQueries , subqueries as: aQueryResult-=JUAMPI=-execute  browser navigateForward-=JUAMPI=-isSimilarTo: anotherBrowserContext  self class = anotherBrowserContext class ifFalse: [ ^false ].  selectedItems size = anotherBrowserContext selectedItems size ifFalse: [ ^false ].  ^selectedItems allSatisfy: [:each |  anotherBrowserContext isAboutSelectedItem: each ]-=JUAMPI=-queryClass  ^ClyVariableWritersQuery-=JUAMPI=-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  subqueries do: [:each |  each decorateMethodGroupTableCell: anItemCellMorph of: groupItem ]-=JUAMPI=-isRemoved  ^browserItem isNil or: [ ownerDataSource isParentRemoved or: [ ownerDataSource isParentCollapsed ] ]-=JUAMPI=-testConvertingToNewBasis  scope := self createSampleScope.  self assert: (scope withNewBasisObjects: #(newBasis)) identicalTo: scope.  self assert: scope basisObjects isEmpty-=JUAMPI=-adoptQuery: aQuery  ^aQuery-=JUAMPI=-withMetaLevel: aMetaLevelScopeClass  self subclassResponsibility-=JUAMPI=-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWhichInheritsAbstractClass >> #abstractMethod1) .         (ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod) .         (ClyClassWhichInheritsAbstractClass >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 #overriddenMethod)-=JUAMPI=-checkEmptyResult  scope methodsDo: [:each |  (self selectsMethod: each) ifTrue: [ ^false ] ].  ^true-=JUAMPI=-testBuildShouldSetUpItemsFromActualResultWhenTheyReady  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self deny: (queryResult hasMetaProperty: ClyBackgroundProcessingTag).  self assert: queryResult items identicalTo: queryResult actualResult items.  self assert: queryResult items asSet equals: query scope basisObjects-=JUAMPI=-displayBlock  ^displayBlock-=JUAMPI=-buildingQuery  ^buildingQuery-=JUAMPI=-decorateBrowserItem: anItem ofClass: aClass  -=JUAMPI=-description  ^'go backward in the navigation history'-=JUAMPI=-label  ^label-=JUAMPI=-includesMethod: aMethod  ^true-=JUAMPI=-removeWithMethods  self methods do: [:each |  each removeFromSystem ]-=JUAMPI=-toggle  | formatter isDirty |  formatter := RBProgramNode formatterClass.  formatter formatAsYouReadPolicy ifTrue: [ formatter formatAsYouReadPolicy: false.        textMorph model canDiscardEdits ifTrue: [ textMorph model cancelEdits ] ] ifFalse: [ formatter formatAsYouReadPolicy: true.        isDirty := textMorph hasUnacceptedEdits.        textMorph model formatSourceCodeInView.        isDirty ifFalse: [ textMorph model clearUserEdits ] ]-=JUAMPI=-switchToVariables  | classScope |  self changeMethodGroupQueryBy: [ classScope := self classScopeForMethods.        ClyAllVariablesQuery from: classScope , classScope asInheritedScope as: ClyGroupedInstanceVariables withDefaultHierarchy ]-=JUAMPI=-meaningfullObjectToAssert: resultItem  ^resultItem actualObject-=JUAMPI=-activationPriority  ^0-=JUAMPI=-executesQuery: aTypedQueryClass  ^self isKindOf: aTypedQueryClass-=JUAMPI=-bindingOf: aSymbol  ^environment bindingOf: aSymbol-=JUAMPI=-oneTwo: anObject  self two: anObject-=JUAMPI=-whenEscapeKeyPressedDo: aBlock  table bindKeyCombination: Character escape asShortcut toAction: aBlock-=JUAMPI=-testIsAffectedByChangeOfNotAbstractMethodWhichImplementsAbstractOne  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)-=JUAMPI=-itemsStartingAt: startIndex count: size  | result |  result := super itemsStartingAt: startIndex count: size.  result do: [:each |  each prepareIn: environment ].  ^result-=JUAMPI=-groupProviderClass  ^ClyUndeclaredMethodGroupProvider-=JUAMPI=-testGettingItemsStartingWhereConditionIsValid  | actual |  queryResult fillWith: #(1 2 3 4 5 6).  actual := queryResult itemsStartingWhere: [:each |  each > 3 ] count: 2.  self assert: actual asArray equals: #(4 5)-=JUAMPI=-itemAt: rowIndex  ^self dataSource elementAt: rowIndex-=JUAMPI=-testGettingSingletonInstanceFromScratch  ClyUnknownQuery reset.  self assert: ClyUnknownQuery instance identicalTo: ClyUnknownQuery instance-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-initialize  super initialize.  excludesHaltsForTesting := true-=JUAMPI=-childrenItems  ^childrenDataSource allElements-=JUAMPI=-redoNavigationOf: aBrowser  redoList ifEmpty: [ ^self ].  self executeRedoBy: [ self restoreNavigationState: redoList removeLast of: aBrowser ]-=JUAMPI=-openBrowserCursorFor: anItemObserver  | cursor |  cursor := ClyBrowserQueryCursor for: self adoptForBrowser.  cursor openFor: anItemObserver.  ^cursor-=JUAMPI=-requestMultipleObjects: dialogTitle from: aQuery  self openOn: aQuery withTitle: dialogTitle thenDo: [ itemsView selection isEmpty ifTrue: [ ^self findObjectsSameAsFilter ].        ^itemsView selection actualObjects ]-=JUAMPI=-superclassSenderOfMessage1  self clyReferencedMessage1-=JUAMPI=-defaultMenuItemName  ^'Convert to extension'-=JUAMPI=-isModeActive  ^activator isCommandAppliedToBrowser-=JUAMPI=-isParentCollapsed  ^self isParentExpanded not-=JUAMPI=-isActive  ^isActive-=JUAMPI=-relationScopeClasses  ^relationScopeClasses-=JUAMPI=-testExecutesConcreteQueryClass  self assert: (query executesQuery: query class).  self assert: (query executesQuery: query class superclass).  self deny: (query executesQuery: ClyQueryExampleReturningScopeBasis2)-=JUAMPI=-defaultMenuItemName  ^menuItemName-=JUAMPI=-cellColumn: column row: rowIndex  | item |  item := self elementAt: rowIndex.  ^column createCellFor: item in: queryView-=JUAMPI=-useFullIndentation  fullIndentation := true-=JUAMPI=-metadata  ^actualResult metadata-=JUAMPI=-execute  (DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: {analyzedObject packageName}) open-=JUAMPI=-testFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(reader1OfVar1 reader2OfVar1)-=JUAMPI=-selectedTextInterval  ^tool selectedTextInterval-=JUAMPI=-checkClassIsAbstract: aClass  aClass withAllSuperclassesDo: [:eachClass |  eachClass methodsDo: [:eachMethod |  (eachMethod isAbstract and: [ (aClass lookupSelector: eachMethod selector) isAbstract ]) ifTrue: [ ^true ] ] ].  ^false-=JUAMPI=-initialize  super initialize.  properties := OrderedCollection new-=JUAMPI=-implementorClass  ^implementorMethod origin-=JUAMPI=-updateExpandingItems  self updateItems: collapsedItems.  collapsedItems := collapsedItems reject: [:each |  each isRemoved ]-=JUAMPI=-testFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot2 .         3 .         ClyTraitRoot2 .         2}-=JUAMPI=-restrictedByScope: aScope  ^self withScope: (scope restrictedBy: aScope)-=JUAMPI=-tableCellIcon  ^Smalltalk ui iconNamed: #haloView-=JUAMPI=-createQuery  ^ClyMethodSourcesQuery withString: self expectedSourceCodeSubstring from: (ClyClassScope of: self class in: environment)-=JUAMPI=-