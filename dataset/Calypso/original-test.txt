basisObjects: aCollection  basisObjects := aCollection asSet-======-isImplementedByClass: aClass  ^aClass instanceSide includesBehavior: self implementorClass instanceSide-======-testComparisonWithAnotherKindOfResult  self deny: queryResult equals: ClyQueryResult new-======-selectsMethod: aMethod  ^aMethod isExtension and: [ aMethod package = package ]-======-ownerTool: anObject  ownerTool := anObject.  self build-======-initialize  super initialize.  projectManagers := OrderedCollection new-======-testHasEmptyBasisObjects  scope := self createSampleScope.  self assert: scope basisObjects isEmpty-======-specialSelectorIndexes  ^specialSelectorIndexes ifNil: [ specialSelectorIndexes := selectors collect: [:each |  Smalltalk specialSelectorIndexOrNil: each ] ]-======-isSlow  ^false-======-focusActiveTab  tabManager focusActiveTab-======-testCaseResults: anObject  testCaseResults := anObject-======-allNavigationScopes  | classLocalScope |  classLocalScope := self classSelection asItemsScope: ClyBothMetaLevelClassScope.  ^super allNavigationScopes , {(self packageSelection asItemsScope: ClyPackageScope) .         classLocalScope asFullHierarchyScope .         classLocalScope}-======-itemsStartingAt: startIndex count: size  ^#()-======-isAffectedByChangedMethod: aMethod  ^self selectsMethod: aMethod-======-buildResult: aQueryResult  | filteredMethods |  filteredMethods := OrderedCollection new.  scope methodsDo: [:each |  (self selectsMethod: each) ifTrue: [ filteredMethods add: each ] ].  aQueryResult fillWith: filteredMethods-======-rebuildIfNeeded  self protectAccessWhile: [ needsRebuild ifTrue: [ needsRebuild := false.              self rebuild ] ]-======-createQuery  ^ClyDeprecatedMethodsQuery from: ClyClassScope of: Object in: environment-======-testCheckIfEmpty  query scope: (ClyMethodScope of: ClyClass1FromP1 >> #tag1Method1 in: environment).  self deny: query checkEmptyResult-======-changeStateOf: aQueryView by: aBlock  | newTools |  self changeStateBy: [ aBlock value.        aQueryView changesWasInitiatedByUser ifTrue: [ newTools := OrderedCollection new.              tabManager buildToolsOn: newTools for: aQueryView createSelectionContext.              tabManager desiredSelection: (newTools collect: #class) ] ]-======-withResult: aQueryResult  | copy |  copy := self copy.  copy requiredResult: aQueryResult.  ^copy-======-packagesDo: aBlock  basisObjects do: aBlock-======-execute  browser switchScopeTo: queryScope-======-update  | unacceptedText newText |  super update.  newText := self editingText.  self pendingText asString = newText ifTrue: [ self applyDecorations.        ^self ].  self hasUnacceptedEdits ifTrue: [ unacceptedText := self pendingText copy ].  textModel setInitialText: newText.  unacceptedText ifNil: [ ^self textUpdated ].  self pendingText: unacceptedText.  textMorph hasEditingConflicts: true.  textMorph changed-======-environment  ^environment-======-defaultMenuItemName  self hasTestResult ifFalse: [ ^'Run failed' ].  ^'Run failed (' , self testResult brokenCount asString , ')'-======-findItemsWith: actualObjects  | result |  self protectItemsWhile: [ result := actualObjects collect: [:eachObject |  items detect: [:item |  item representsObjectEqualTo: eachObject ] ifNone: nil ].        result select: #notNil thenDo: [:each |  each prepareIn: environment ].        ^result ]-======-metalinkManagerClass  ^ExecutionCounter-======-dataSource: anObject  dataSource := anObject-======-scopeClass  ^ClySuperclassScope-======-selectedMethodItems  ^self selectedItemsOfType: ClyMethod-======-icon  ^icon-======-prepareNewResult  ^asyncResult prepareNewFor: self actualQuery in: self environment-======-extensionMethodFromRoot1Trait  -======-setUp  super setUp.  environment addPlugin: ClyDefaultSystemEnvironmentPlugin new-======-findItemsSameAsFilter  | filterString |  filterString := table filterString asLowercase.  ^self dataSource findItemsWhere: [:each |  each name asLowercase = filterString ]-======-forceRebuild  self forceLazyRebuild.  self notifyObservers-======-browserTool: anObject  browserTool := anObject-======-rawItemsDo: aBlock  actualResult rawItemsDo: aBlock-======-decorateBrowserItem: anItem ofMethod: aMethod  aMethod usesUndeclares ifTrue: [ anItem markWith: ClyUndeclaresUserTag ]-======-testComparison  self assert: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring').  self assert: (ClyMethodSourcesQuery withString: 'test substring') hash equals: (ClyMethodSourcesQuery withString: 'test ' , 'substring') hash.  self deny: (ClyMethodSourcesQuery withString: 'test substring') equals: (ClyMethodSourcesQuery withString: 'another substring')-======-testConvertingToInheritingScopeShouldAddTraitUsers  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asInheritingScope.  self assert: (convertedScope representsScope: ClyTraitUserScope)-======-showsFlatResult  ^(systemQuery retrievesItemsAs: ClyHierarchicalSystemItems) not-======-multipleScopeSample  | newScope |  newScope := super multipleScopeSample.  newScope relationScopeClasses: {ClySuperclassScope}.  ^newScope-======-containerForChildren  ^SortedCollection sortBlock: sortFunction-======-= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^definingClass = anObject definingClass-======-isSameAs: anotherSelection  self size = anotherSelection size ifFalse: [ ^false ].  items with: anotherSelection items do: [:myItem :anotherItem |  myItem actualObject == anotherItem actualObject ifFalse: [ ^false ] ].  ^true-======-browser: anObject  browser := anObject-======-isResult: aQueryResult affectedBy: aSystemAnnouncement  aSystemAnnouncement affectsCritiques ifFalse: [ ^false ].  aQueryResult forceLazyRebuild.  ^false-======-createQuery  ^ClyLongQueryExample from: ClyScopeExample of: String in: environment-======-testNotEmptyFromEmptyMethodScope  query scope: (ClyMethodScope emptyIn: environment).  self deny: query checkEmptyResult-======-accumulateTestMethod: aMethod  | testSelector result inheritingScope |  testSelector := aMethod selector.  inheritingScope := (ClyClassScope of: aMethod methodClass) withInheritingScope.  inheritingScope classesDo: [:concreteTestCase |  (concreteTestCase isTestCase and: [ concreteTestCase isAbstract not ]) ifTrue: [ self accumulateTest: testSelector of: concreteTestCase.              result := testCaseResults at: concreteTestCase ifAbsentPut: [ ClyTestResultProperty new ].              result accumulateTest: testSelector of: concreteTestCase ] ]-======-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyAbstractClassExample >> #abstractMethod1) .         (ClyAbstractClassExample >> #abstractMethod2) .         (Object >> #printString)}.  self assert: foundSelectors equals: #(abstractMethod1 abstractMethod2)-======-build  | goButton contextLabel |  contextLabel := ownerTool printContext.  contextLabel ifEmpty: [ ^self ].  self addMorphBack: (self iconNamed: #uncommentedClass) asMorph.  self addMorphBack: contextLabel asMorph.  goButton := IconicButton new     target: self;     actionSelector: #restoreBrowserState;     arguments: {};     labelGraphic: (self iconNamed: #forward);     color: Color transparent;     helpText: 'Move browser to ' , contextLabel;     borderWidth: 0.  self addMorphBack: goButton-======-menuItemNameFor: aCommand  ^menuItemName ifNil: [ aCommand defaultToolbarItemName ]-======-position: anObject  position := anObject-======-enableFilterUsing: aStringPattern  self enableFilter: ClyItemNameFilter using: aStringPattern-======-selectsMethod: aMethod  ^scope inheritanceAnalyzer isMethodOverriding: aMethod-======-groupProviderClass  ^ClyFlagMethodGroupProvider-======-buildExtensionCheckBoxButton  extensionCheckbox := self theme newCheckboxIn: self for: self getSelected: #isExtensionActive setSelected: #toggleExtension getEnabled: nil label: 'extension' help: 'toggle check box to choose/reset package of method'.  extensionCheckbox     changeTableLayout;     vResizing: #shrinkWrap;     hResizing: #shrinkWrap-======-reference1OfClass  ^ClyClassReferencesQueryTest-======-runBuildProcess  buildProcess := [ self buildActualResult ] newProcess.  buildProcess     name: 'Build result of ' , buildingQuery printString;     priority: Processor userBackgroundPriority.  buildProcess resume-======-classesSize  ^classQuery execute size-======-isClassTagSelected  | groups |  groups := tool classGroupSelection.  groups isEmpty ifTrue: [ ^false ].  ^groups lastSelectedItem type isBasedOnClassTag-======-execute  sourceNode nodesWithLinks do: [:each |  self metalinkManagerClass removeFrom: each ]-======-rebuildAllTools  tabManager updateTools.  self rebuildToolbar-======-buildResult: aQueryResult  | critiques methods |  critiques := critiqueQuery execute.  methods := critiques items collect: [:each |  each sourceAnchor entity ] as: IdentitySet.  aQueryResult fillWith: methods-======-attachToSystem  -======-wantsStayInDifferentContext  self isBuilt ifFalse: [ ^false ].  self hasUnacceptedEdits ifTrue: [ ^true ].  self isTabSelected & self isExtraSelectionRequested ifTrue: [ ^true ].  self belongsToRemovedBrowserContext ifTrue: [ ^false ].  ^isManagedByUser-======-openFor: anItemObserver  self moveToStart.  itemObserver := anItemObserver.  queryResult subscribe: itemObserver-======-buildIsDone  self notifyObservers.  environment systemChanged: (ClyAsyncQueryIsDone with: self)-======-changesCancelled  textMorph hasUnacceptedEdits: false.  self textUpdated-======-testPrepareResultForExecutionWhenItIsSemiAsync  | preparedResult |  preparedResult := query semiAsync prepareNewResult.  self assert: preparedResult class equals: ClySemiAsyncQueryResult.  self assert: preparedResult buildingQuery identicalTo: query actualQuery.  self assert: preparedResult environment identicalTo: environment.  self assert: preparedResult isProtected-======-initialize  super initialize.  fullIndentation := false.  self cellInset: 2 @ 0-======-isCommandAvailable: aCommand  ^aCommand canBeExecutedInTool: self-======-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red.  anItemCellMorph definitionIcon: #smallDebug-======-itemOfThisTestMethod  ^ClyBrowserItem with: self class >> testSelector-======-browser  ^tool browser-======-methodFromTraitChild2  -======-filterField  ^table filterField-======-testNotAffectedByChangeOfSubclassMethodWhichNotOverridesSuperclass  self deny: (query isAffectedByChangedMethod: ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod)-======-itemsChanged  dirty ifTrue: [ ^self ].  dirty := true.  self scheduleUpdate-======-testNotSelectsMethodWhichHasNoUndeclares  self deny: (query selectsMethod: Object >> #printString)-======-createInheritingScopeFrom: aClassScope  | scope |  scope := annotatedClass createInheritingScopeFrom: aClassScope.  scope name: ClyClassScope inheritingScopeName.  ^scope-======-increasedByClassesFrom: aClassScope  ^self withExtraBasisObjects: aClassScope collectAllClasses-======-testFromSystemScope  self queryFromScope: ClySystemEnvironmentScope of: ClySystemEnvironment currentImage.  self assert: resultItems size equals: 3.  self assert: (resultItems identityIncludes: self class >> self targetSelector).  self assert: (resultItems identityIncludes: self class classSide >> self targetSelector).  self assert: (resultItems identityIncludes: self class superclass >> self targetSelector)-======-close  queryResult unsubscribe: itemObserver.  itemObserver := nil.  ^ClyClosedBrowserCursor instance-======-testCompareTwoMethods  function := ClySortSystemItemFunction ascending.  self deny: (function value: Object >> #size value: Object >> #printString).  self assert: (function value: Object >> #printString value: Object >> #size).  self assert: (function value: Object >> #printString value: Object >> #printString)-======-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  methodQuery printOn: aStream.  aStream nextPut: $)-======-checkEmptyResult  ^self installedMethods isEmpty-======-buildItemsPerClassFrom: systemObjects  | itemsPerClass item localItems |  itemsPerClass := IdentityDictionary new.  systemObjects do: [:each |  item := each asCalypsoBrowserItem.        localItems := itemsPerClass at: item systemDefinitionClass ifAbsentPut: [ self containerForItemsOfClass ].        localItems add: item ].  ^itemsPerClass-======-actualObject: anObject  actualObject := anObject.  type := anObject calypsoEnvironmentType-======-testIsAffectedByChangeOfAbstractMethodWhichIsImplemented  self assert: (query isAffectedByChangedMethod: ClyAbstractClassExample >> #abstractMethod1)-======-editingMethod: aMethod  editingMethod := aMethod-======-isActive  ^ownerTool extendingPackage notNil-======-testFillingWithTwoEqualVarsOfDifferentSubclassesAndOneVarOfSuperclass  queryResult fillWith: {(ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN2OfClass1FromP1) .         (ClyInstanceVariable named: #instanceSideVar2 definedIn: ClyClass1FromP1) .         (ClyInstanceVariable named: #subclassSameVar definedIn: ClySubclassN1OfClass1FromP1)}.  self assertItems: {ClyAllMethodGroup .         0 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#instanceSideVar2 #subclassSameVar #subclassSameVar)-======-testCreationUnifiedInstance  scope := self createSampleScope.  self assert: scope asUnifiedInstance identicalTo: scope-======-localMethod  -======-isBasedOnEmptyBasis  ^self basisSize = 0-======-cleanGarbageInCache  accessGuard critical: [ queryCache clyCleanGarbage ]-======-subscribe: anObject  announcer ifNil: [ announcer := Announcer new ].  announcer when: ClyEnvironmentChanged send: #itemsChanged to: anObject-======-browser: anObject  browser := anObject-======-testCreationFromTwoSameQueriesOfSameScopeButWithDifferentParameter  | subquery1 subquery2 |  subquery1 := self subqueryFromScopeOf: Array.  subquery1 scope extraParameter: #testParameter.  subquery2 := self subqueryFromScopeOf: Array.  subquery2 scope extraParameter: #testParameter2.  query := subquery1 , subquery2.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {subquery1 .         subquery2} asSet.  self assert: query requiredResult identicalTo: subquery1 requiredResult-======-size  ^self protectItemsWhile: [ items size ]-======-testRetrievesMethodQuery  self snapshotState.  self assert: navigationState systemQuery equals: browser systemQuery-======-hash  ^sortFunction hash bitXor: inverse hash-======-name  ^name-======-testItemsInitializationShouldNotResetExistingItems  queryResult items: #(items).  queryResult initializeItems.  self assert: queryResult items equals: #(items)-======-printContext  ^super printContext , ' / ' , editingClass name-======-testMethodsEnumerationWhenBothMetaLevels  scope := ClyTraitUserScope of: ClyTraitRoot1 localScope: ClyBothMetaLevelClassScope.  scope methodsDo: [:each |  result add: each ].  self assert: (result includesAll: ClyTraitChild1 localMethods).  self assert: (result includesAll: ClyTraitChild1 classSide localMethods).  self assert: (result includesAll: ClyClassWithTraits localMethods).  self assert: (result includesAll: ClyClassWithTraits classSide localMethods).  self deny: (result includesAll: ClyTraitRoot1 localMethods).  self deny: (result includesAll: ClyTraitRoot1 classSide localMethods)-======-setUpActiveScope  systemQuery isBoundToEnvironment ifFalse: [ systemQuery := systemQuery withScope: self systemScope ].  (queryScopes includes: systemQuery scope) ifFalse: [ queryScopes add: systemQuery scope ].  activeScope := systemQuery scope-======-scopeNames  ^self scopes collect: [:each |  each description capitalized ]-======-toolWasRemoved  -======-defaultMenuItemName  ^'Jump to test class'-======-defaultNavigationScope  ^self isScopedModeEnabled ifFalse: [ super defaultNavigationScope ] ifTrue: [ packageView query scope ]-======-isAboutSelectedItem: aDataSourceItem  (selectedItems anySatisfy: [:each |  each actualObject == aDataSourceItem actualObject ]) ifTrue: [ ^true ].  (selectedItems anySatisfy: [:each |  each name = aDataSourceItem name ]) ifFalse: [ ^false ].  ^selectedItems anySatisfy: [:each |  each isEqualTo: aDataSourceItem ]-======-checkEmptyResult  ^critiqueQuery hasEmptyResult-======-tools: anObject  tools := anObject-======-hasEmptyResult  ^scope isQueryEmpty: self-======-singleBasisSample  ^ClyClass1FromP1 package-======-toggle  textMorph lineNumbersRuler ifNil: [ textMorph withLineNumbers ] ifNotNil: [ textMorph withoutLineNumbers ].  self updateLabel-======-ensureVisibleLastItem  rootDataSource table ensureVisibleFirstSelection-======-forceRebuild  actualResult forceRebuild-======-fillStatusBar  self belongsToCurrentBrowserContext ifFalse: [ statusBar addContextItem: (ClyToolContextNavigatorMorph for: self) ]-======-hash  ^super hash bitXor: variableQuery hash-======-testMoveToItemWhichSatisfiesConditionWhenItNotExistsInCache  | found |  cursor cleanCache.  found := cursor moveToItemWhich: [:each |  each actualObject = Object ].  self assert: found.  self assert: cursor position equals: 2.  self assert: cursor currentItem actualObject equals: Object-======-testVariableNamedThisContext_conditionBlockProducerMethodAST  self assert: (ClyAddConditionalBreakpointCommand new conditionBlockProducerMethodAST: 'ThisContext') equals: (self parserClass parseMethod: 'conditionBlockGenerator ^[ :ThisContext | Breakpoint checkBreakConditionValue: (ThisContext lookupSymbol: #ThisContext)]')-======-testNotSelectsMethodWithoutWatchpoint  self deny: (query selectsMethod: self class >> #methodWithoutWatchpoint)-======-execute  | class |  class := browser searchDialog requestSingleObject: 'Choose class' from: ClyAllClassesQuery sorted.  browser selectClass: class-======-decorateBrowserItem: anItem ofPackage: aPackage  -======-testFromPackageScope  self queryFromScope: ClyPackageScope of: self class package.  self assert: resultItems size equals: 2.  self assert: (resultItems identityIncludes: self class >> #method1).  self assert: (resultItems identityIncludes: self class >> #method2)-======-bindTo: aScope in: aNavigationEnvironment  aScope bindTo: aNavigationEnvironment.  self scope: aScope-======-activationPriority  ^-100-======-method1  -======-metaLevelScope: anObject  metaLevelScope := anObject-======-createBlockFromPattern  (pattern value endsWith: ']') ifFalse: [ badScript := true.        ^self ].  [ scriptBlock := self class compiler evaluate: pattern value ] on: Exception do: [:err |  badScript := true ]-======-build  self addMorphBack: label-======-metadata  ^metadata ifNil: [ self collectMetadata.        metadata ]-======-updateTabsWith: newTools  | toRemove toInstall |  toRemove := OrderedCollection withAll: tools.  toInstall := OrderedCollection new.  newTools do: [:new |  tools detect: [:existing |  existing isSimilarTo: new ] ifFound: [:existing |  toRemove remove: existing ] ifNone: [ toInstall add: new ] ].  toRemove do: [:each |  each wantsStayInDifferentContext ifFalse: [ each removeFromBrowser ] ].  tools do: [:each |  each browserContextWasChanged ].  toInstall do: [:each |  self addTool: each ]-======-isSameAsCurrent: anObject  isSameAsCurrent := anObject-======-adoptLocalScopeClassTo: aLocalScopeClass  localScopeClass := aLocalScopeClass-======-createQueryResult  ^ClyClassBindings new-======-requestSingleObject: dialogTitle from: aQuery inScope: aScope  aScope bindTo: browser navigationEnvironment.  ^self requestSingleObject: dialogTitle from: (aScope adoptQuery: aQuery)-======-testBasedOnMultipleBasis  scope := self multipleScopeSample.  self assert: scope isBasedOnMultipleBasis.  scope := self singleScopeSample.  self deny: scope isBasedOnMultipleBasis.  scope := self emptyScopeSample.  self deny: scope isBasedOnMultipleBasis-======-defaultMenuIconName  ^#trait-======-critique  ^critique-======-affectsMethods  ^true-======-execute  UIManager default debugProcess: Processor activeProcess context: critique stack label: critique message fullView: true-======-testMethodsEnumeration  | expected |  scope := ClyClassScope of: ClyClass1FromP1.  scope methodsDo: [:each |  result add: each selector ].  expected := ClyClass1FromP1 localMethods collect: #selector.  self assert: result sorted asArray equals: expected sorted asArray-======-changeStateBy: aBlock  aBlock value-======-execute  script executeOn: targetClass-======-initialize  super initialize.  basisObjects := #()-======-findItemsSimilarTo: dataSourceItems  | myItems childItems |  myItems := super findItemsSimilarTo: dataSourceItems.  myItems size == dataSourceItems size ifTrue: [ ^myItems ].  childItems := expandedItems flatCollect: [:each |  each childrenDataSource findItemsSimilarTo: dataSourceItems ].  ^myItems , childItems-======-packagesDo: aBlock  self system packages do: aBlock-======-prepareExecutionInDropContext: aToolContext  super prepareExecutionInDropContext: aToolContext.  package := aToolContext lastSelectedPackage-======-targetClass  ^targetClass-======-conditionBlock: anObject  conditionBlock := anObject-======-prepareInitialState  -======-basisObjects: aCollection  super basisObjects: (self prepareBasisFrom: aCollection)-======-decorateOwnBrowserItem: myItem  super decorateOwnBrowserItem: myItem.  classQuery decorateItemGroup: myItem.  subgroupsQuery decorateItemGroup: myItem-======-defaultMenuItemName  ^'Writers'-======-allowsDifferentActivationPriority  ^true-======-testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject  < expectedFailure>  super testIsExecutedFromSingleScopeWhenSubqueriesAreFromDifferentScopesOfSameObject-======-readerOfVar1  ^writtenVar1-======-selectedPackageItems  ^tool packageSelection items-======-selectsMethod: aMethod  | plugin |  plugin := self environment getPlugin: ClyReflectiveEnvironmentPlugin.  ^plugin doesMethodHasWatchpoint: aMethod-======-representsConcreteQuery  ^true-======-findItemsSimilarTo: sampleBrowserItems  ^cache findItemsWith: (sampleBrowserItems collect: #actualObject) forAbsentDo: [ ^queryResult findItemsSimilarTo: sampleBrowserItems ]-======-fillWith: classes  | definedClasses extensions |  definedClasses := IdentitySet withAll: classes.  extensions := OrderedCollection new.  classes do: [:each |  (self isQueryScopeDefinesClass: each) ifFalse: [ definedClasses remove: each.              extensions add: each ] ].  items := self buildItemsFrom: definedClasses.  items addAll: (self buildExtensionItemsFrom: extensions)-======-methodGroupType  ^ClyVariable-======-isCommandAvailable: aCommand  ^aCommand canBeExecutedInCodeMethodEditor: self-======-defaultMenuIconName  ^#smallRedo-======-superclassVar1WriterMethod  instanceSideVar1 := #subclassVar1Value-======-extraBasisSample  ^ClySubclassMOfClass1FromP2 package-======-testConvertingToSomeHierarchyScope  | convertedScope |  scope := self createSampleScope.  convertedScope := scope asScope: ClySubclassScope.  self assert: convertedScope class equals: ClySubclassScope.  self assert: convertedScope localScopeClass equals: scope localScopeClass.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environment-======-defaultItems  ^SortedCollection sortBlock: sortFunction-======-direction: anObject  direction := anObject-======-isParentExpanded  parentItem ifNil: [ ^true ].  ^parentItem isExpanded-======-testIsExecutedFromConcreteScopeClass  self assert: (query isExecutedFromScope: query scope class).  self assert: (query isExecutedFromScope: query scope class superclass).  self deny: (query isExecutedFromScope: ClyScopeExample2)-======-testConvertingAsRestrictedByAnotherScope2  | convertedScope restrictedScope |  scope := self singleScopeSample.  restrictedScope := self multipleScopeSample.  convertedScope := scope restrictedBy: restrictedScope.  self assert: convertedScope class equals: scope class.  self assert: convertedScope basisObjects equals: restrictedScope basisObjects-======-classSampleWhichHasGroup  ^ClySubclassN1OfClass1FromP1-======-hash  ^super hash bitXor: pattern hash-======-start  ^start-======-isMultipleSelected  ^items size > 1-======-showVariableNamed: aString  tool selectVariableNamed: aString-======-includesClass: aClass  self classesDo: [:each |  each = aClass ifTrue: [ ^true ] ].  ^false-======-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  | icon |  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  icon := anItemCellMorph definitionIcon: #flagIcon.  icon setBalloonText: 'There are methods with flag'-======-printContext  ^''-======-description  ^'all method groups'-======-decorateResultMethodEditor: aMethodEditor  criteriaString ifNil: [ ^self ].  aMethodEditor selectStringAsInMessageBrowser: criteriaString-======-execute  browser switchToVariables-======-variableQuery: aVariableQuery  variableQuery := aVariableQuery-======-createBrowser  ^ClyFullBrowser new-======-description  ^'Do not supported currently'-======-queryScope: anObject  queryScope := anObject-======-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  testItems := aToolContext selectedItems select: [:each |  each hasProperty: ClyTestResultProperty ]-======-initialize  super initialize.  undoExecuting := false.  redoExecuting := false.  waitingNewState := true.  undoList := OrderedCollection new.  redoList := OrderedCollection new-======-createQuery  ^ClyQueryExampleReturningScopeBasis from: ClyScopeExample of: #basisObject in: environment-======-defaultMenuItemName  ^'Run script'-======-defaultMenuItemName  ^'Move to package'-======-activeWindow  self tabGroup pages size = 0 ifTrue: [ ^nil ].  self tabGroup selectedPageIndex <= 0 ifTrue: [ ^nil ].  ^self tabGroup pages at: self tabGroup selectedPageIndex-======-initialize  super initialize.  methodTags := #()-======-testCheckIfEmpty  self installCounterInto: #methodWithCounter.  query scope: (ClyMethodScope of: self class >> #methodWithCounter in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-======-littleHierarchyMaxSize: anObject  littleHierarchyMaxSize := anObject-======-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  super decorateMethodGroupTableCell: anItemCellMorph of: groupItem.  anItemCellMorph label color: Color red-======-affectedPackage: anObject  affectedPackage := anObject-======-execute  browser switchToProjects-======-execute  | queries fullQuery |  queries := methodGroups collect: [:each |  each methodQuery ].  fullQuery := ClyQuery unionFrom: queries.  browser spawnQueryBrowserOn: fullQuery-======-initialize  super initialize.  collapsedItems := SortedCollection sortBlock: [:a :b |  a position < b position ]-======-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  browser := aToolContext browser-======-isPrepared  ^isPrepared-======-defaultMenuItemName  ^'Add breakpoint condition..'-======-testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects  < expectedFailure>  super testIsExecutedFromMultipleScopeWhenSubqueriesAreFromScopesOfDifferentObjects-======-hierarchy  ^hierarchy-======-allItems  ^self prepareItems: actualResult allItems-======-decorateBrowserItem: anItem ofPackage: aPackage  aPackage isDeprecated ifTrue: [ anItem markWith: ClyDeprecatedItemTag ]-======-query: aQuery  ^ClyUnknownQueryResult instance-======-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  classQuery printOn: aStream.  aStream nextPut: $)-======-methodWithoutCritiques  ^ClyClassWithProblemMethods >> #methodWithoutCritiques-======-findTestedClassCoveredBy: aTestClass ifAbsent: absentBlock  | className |  className := aTestClass instanceSide name.  (className endsWith: 'Tests') ifTrue: [ ^environment system classNamed: (className allButLast: 5) asSymbol ifAbsent: absentBlock ].  (className endsWith: 'Test') ifTrue: [ ^environment system classNamed: (className allButLast: 4) asSymbol ifAbsent: absentBlock ].  ^absentBlock value-======-newName  ^newName-======-prepareIn: aNavigationEnvironment  isPrepared ifTrue: [ ^self ].  aNavigationEnvironment pluginsDo: [:each |  self decorateBy: each ].  isPrepared := true-======-tableCellIcon  ^Smalltalk ui iconNamed: #halt-======-restoreBrowserState  self browser selectObject: self lastSelectedObject-======-testConvertingAsRestrictedByAnotherScope  | convertedQuery restrictedScope |  restrictedScope := ClyScopeExample2 of: #restrictedBasis.  convertedQuery := query restrictedByScope: restrictedScope.  self assert: convertedQuery class equals: query class.  self assert: convertedQuery requiredResult identicalTo: query requiredResult.  self assert: (convertedQuery subqueries collect: #class) equals: (query subqueries collect: #class).  self assert: (convertedQuery subqueries collect: #scope) equals: (query subqueries collect: [:each |  each scope withNewBasisObjects: #(restrictedBasis) ])-======-normalizeSelectorForComparison: aString  | selectorString selectorStringSize normalizedSelectorString normalizedSelectorStringSize |  selectorString := aString asString.  selectorStringSize := aString size.  normalizedSelectorString := selectorString class new: selectorStringSize.  normalizedSelectorStringSize := 0.  1 to: selectorStringSize do: [:i |  | nextChar |        (nextChar := selectorString at: i) == $: ifFalse: [ normalizedSelectorString at: (normalizedSelectorStringSize := normalizedSelectorStringSize + 1) put: nextChar ] ].  ^(normalizedSelectorStringSize < selectorStringSize ifTrue: [ normalizedSelectorString first: normalizedSelectorStringSize ] ifFalse: [ selectorString ]) asLowercase-======-defaultMenuItemName  ^'Show in method browser'-======-selectsMethod: aMethod  ^aMethod isExtension-======-toggleFullWindowTabs  | tabMorph |  tabMorph := tabManager tabMorph.  (submorphs includes: tabMorph) ifFalse: [ self addMorph: tabMorph fullFrame: LayoutFrame identity ] ifTrue: [ toolPanel addMorphBack: tabMorph ]-======-methodGroups  ^methodGroups-======-prepareExecutionInDropContext: aToolContext  | selectedClasses |  super prepareExecutionInDropContext: aToolContext.  methodGroup := aToolContext lastSelectedMethodGroup.  selectedClasses := aToolContext selectedClasses.  selectedClasses := selectedClasses collect: [:each |  aToolContext currentMetaLevelOf: each ].  targetClass := selectedClasses size > 1 ifTrue: [ aToolContext requestSingleClass: 'In what class you want to move method?' from: selectedClasses ] ifFalse: [ selectedClasses last ]-======-decorateMethodEditor: aMethodEditor  methodView query decorateResultMethodEditor: aMethodEditor-======-methodWithoutBreakpoints  -======-testCreationWithSingleSubqueryButAnotherResult  | subquery |  subquery := self subqueryFromScopeOf: Array.  query := ClyUnionQuery with: {subquery} as: #specialResult.  self assert: query class equals: subquery class.  self assert: query scope equals: subquery scope.  self assert: query requiredResult equals: #specialResult.  self deny: subquery requiredResult equals: #specialResult-======-addNewCommentForTestClass: aClass basedOn: baseClass  aClass comment: (String streamContents: [:stream |  | name |              name := aClass name.              name first isVowel ifTrue: [ stream nextPutAll: 'An ' ] ifFalse: [ stream nextPutAll: 'A ' ].              stream                 nextPutAll: name;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: baseClass name ])-======-testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScope  query subqueries: {(self subqueryFromScope: ClyScopeExample empty) .         (self subqueryFromScope: ClyScopeExample2 empty)}.  self deny: query isExecutedFromSingleScope-======-testClass  ^testClass-======-createTableCellButtonWith: anIcon using: aCommandActivator  | button |  button := super createTableCellButtonWith: anIcon using: aCommandActivator.  sourceNode hasExecutionCounter ifTrue: [ ClyDynamicBallonTooltip from: [ self tableDescription ] installInto: button ].  ^button-======-execute  browser spawnQueryBrowserOn: (ClyVariableReferencesQuery ofAny: variables)-======-testCreationFromAnotherCompositeQueryAndSimilarQuery  | subquery1 subquery2 subquery3 |  subquery1 := self subqueryFromScopeOf: Array.  subquery2 := self subqueryFromScope: ClyScopeExample2 of: String.  subquery3 := self subqueryFromScopeOf: Object.  query := subquery1 , subquery2 , subquery3.  self assert: query class equals: self queryClass.  self assert: query subqueries equals: {(self subqueryFromScope: (ClyScopeExample ofAll: {Array .                     Object})) .         subquery2} asSet.  self assert: query requiredResult equals: subquery1 requiredResult-======-requestSingleClass: queryTitle  ^tool searchDialog requestSingleObject: queryTitle from: ClyAllClassesQuery sorted-======-hash  ^super hash bitXor: hierarchy hash-======-packageScopeOfSelectedItems  | packages |  packages := self selection items collect: [:methodItem |  methodItem systemDefinition definingPackage ].  ^ClyPackageScope ofAll: packages in: navigationEnvironment-======-buildsDefaultResult  ^self retrievesItemsAs: self defaultResult class-======-isMethodSelected  ^false-======-copyForBrowserStateSnapshotOf: rootDataSourceSnapshot  | copy ownerDataSourceSnapshot |  ownerDataSourceSnapshot := rootDataSourceSnapshot findDataSourceSameAs: ownerDataSource ifNone: [ self error: 'should not happen' ].  copy := self copy.  copy ownerDataSource: ownerDataSourceSnapshot.  childrenDataSource ifNotNil: [ copy childrenDataSource: childrenDataSource copyForBrowserStateSnapshot ].  ^copy-======-shouldSkipCurrentDesiredSelection  ^shouldSkipCurrentDesiredSelection-======-testResult  ^testResult-======-defaultMenuItemName  ^'Inspect'-======-ownerTool  ^ownerTool-======-simpleNameForSpotterMenu  ^'Variables'-======-fillWith: packages  | group |  packages do: [:each |  group := ClyExternalPackageMethodGroup withMethodsFrom: self scope packagedIn: each.        items add: group ]-======-canDetectAffectOnClassesBy: aSystemAnnouncement  ^(aSystemAnnouncement isKindOf: ClassAnnouncement) not-======-defaultMenuIconName  ^#glamorousBrowse-======-isAssignmentSelected  | node |  node := self selectedSourceNode.  [ node notNil ] whileTrue: [ node isAssignment ifTrue: [ ^true ].        node := node parent ].  ^false-======-setUp  super setUp.  environment := nil-======-extendClassScopeForMethods: aClassScope  | resultScope |  resultScope := aClassScope.  (ClyMethodVisibilityLevel allAvailableFor: self classSelection items) ifNotEmpty: [:levels |  resultScope := levels anyOne extendClassScope: resultScope ].  ^resultScope-======-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-======-testClassEnumerationOverClassWhenBothMetaLevelsAreLocalScope  | expected |  scope := ClySubclassScope of: Class localScope: ClyBothMetaLevelClassScope.  scope classesDo: [:each |  result add: each ].  expected := Class subclasses select: #isInstanceSide.  expected := expected flatCollect: [:each |  {each instanceSide .         each classSide} ].  self assert: result asSet equals: expected asSet-======-critique: anObject  critique := anObject-======-testComparisonToSimilarQueryButWithDifferentTag  | query2 |  query tag: #tag1.  query2 := self createQuery.  query2 tag: #anotherTag.  self deny: query equals: query2-======-open  | query methods comments |  methods := messages select: [:each |  (each isRingObject and: [ each isMethod ]) or: [ each isCompiledMethod ] ] thenCollect: [:each |  each compiledMethod ].  comments := messages select: [:each |  each isRingObject and: [ each isComment ] ] thenCollect: [:each |  ClyClassComment of: each parent realClass ].  query := ClyOldMessageBrowserQuery named: title with: methods asOrderedCollection , comments.  query     criteriaString: autoSelect;     criteriaBlock: refreshingBlock.  openedBrowser := ClyQueryBrowser openOn: query-======-isSelectedItemHasWatchpoint  ^selectedSourceNode hasWatchpoint-======-includesMethod: aMethod  self asyncQueryResult isBuilt ifFalse: [ ^false ].  ^super includesMethod: aMethod-======-attachToSystem  browser system when: (ClyMethodChange of: self editingMethod) send: #triggerUpdate to: self-======-referenceOfNumberClassByNameSymbol  ^#Number-======-update  leftMethod := leftMethod origin localMethodNamed: leftMethod selector ifAbsent: [ ^self ].  rightMethod := rightMethod origin localMethodNamed: rightMethod selector ifAbsent: [ ^self ].  super update.  diffMorph from: leftMethod sourceCode to: rightMethod sourceCode-======-printDefinition  ^definingPackageItem name-======-methodTags  ^methodTags-======-scopeWithCritiques  ^ClyMethodScope of: self methodWithCritiques in: environment-======-setUp  super setUp.  browser prepareInitialState-======-isClassVariable  ^true-======-browserPlugins  ^browserPlugins-======-isEmpty  ^self itemCursor itemCount = 0-======-isQueryEmpty: aQuery  self isBasedOnEmptyBasis ifTrue: [ ^true ].  aQuery ensureScope: self.  ^environment isQueryEmpty: aQuery-======-supeclassWriterOfVar1  writtenVar1 := #superclassValue-======-testConvertingToInheritedScope  | convertedScope |  scope := self createSampleScope.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope asInheritedScope.  self assert: (convertedScope representsScope: ClySuperclassScope).  self assert: convertedScope localScopeClass equals: ClyInstanceSideScope.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope environment equals: environment.  self assert: convertedScope name equals: ClyClassScope inheritedScopeName-======-selectMethodGroupNamed: tagName  self changeStateBy: [ self methodGroupSelection selectItemsWhere: [:each |  each name = tagName ] ]-======-testDecoratingMethodWithExecutionCounter  | plugin method methodItem |  plugin := ClyReflectiveEnvironmentPlugin new.  self installWatchpointInto: #methodWithWatchpoint.  method := self class >> #methodWithWatchpoint.  methodItem := method asCalypsoBrowserItem.  plugin decorateBrowserItem: methodItem ofMethod: method.  self assert: (methodItem isMarkedWith: ClyMethodWithWatchpointTag)-======-subgroupsQuery: anObject  subgroupsQuery := anObject-======-testForceLazyRebuild  self assert: queryResult items notNil.  queryResult forceLazyRebuild.  self assert: queryResult needsRebuild-======-createQuery  ^ClyUntaggedClassesQuery from: (ClyClassScope of: Object in: environment)-======-addContextItem: aMorph  contextBar addMorphBack: aMorph.  ^aMorph-======-restoreTableSelectionSilently: silentSelection  | selectionIndexes |  items := items reject: [:each |  each isRemoved ].  selectionIndexes := items collect: #globalPosition.  self setUpSelectedRows: selectionIndexes in: rootDataSource table silently: silentSelection-======-includesVariablesAffectedBy: aSystemAnnouncement  self classesDo: [:class |  (aSystemAnnouncement affectsVariablesOf: class) ifTrue: [ ^true ] ].  ^false-======-createQuery  ^ClyMethodWatchpointsQuery from: ClyClassScope of: self class in: environment-======-collapsedButton  ^IconicButton new     target: item;     actionSelector: #expand;     arguments: {};     labelGraphic: self theme treeUnexpandedForm;     color: Color transparent;     helpText: 'Expand Item';     borderWidth: 0-======-senderOfIfTrue  ^2 * 2 = 4 ifTrue: [ 100 ]-======-hash  ^super hash bitXor: baseQueryResult hash-======-affectsMethodsDefinedInClass: aClass  ^(aClass includesLocalSelector: self overriddenMethod selector) and: [ aClass inheritsFrom: self overriddenMethod origin ]-======-context  ^context-======-retrievesItem: aVariable  ^aVariable isKindOf: ClyInstanceVariable-======-testFillingWithClassAndItsDeepTwoTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2}.  self assertItems: {ClyClassWithTraits .         0 .         ClyTraitChild2 .         1 .         ClyTraitRoot2 .         2 .         ClyTraitRoot2 .         1}-======-packageOrganizer  ^packageOrganizer-======-itemsChanged  navigationStarted ifTrue: [ ^self ].  navigationStarted := true.  [ self rebuildToolsForChangedEnvironment ] ensure: [ navigationStarted := false ]-======-actualObject: anObject  ^browserItem actualObject: anObject-======-withInheritedScope  | fullScope |  fullScope := self , self asInheritedScope.  fullScope name: self class hierarchyScopeName.  ^fullScope-======-deprecatedMethod2  self deprecated: 'it is deprecated method for testing deprecation analyzis'-======-testConvertingToInterestingClassScope  | convertedScope |  scope := ClyMultipleClassRelationScope of: {String} merging: {ClySuperclassScope .         ClySubclassScope}.  scope localScopeClass: ClyInstanceSideScope.  convertedScope := scope asInterestingClassScope.  self deny: convertedScope identicalTo: scope.  self assert: convertedScope class equals: ClyMultipleClassRelationScope.  self assert: convertedScope relationScopeClasses equals: {ClyInterestingSuperclassScope .         ClySubclassScope}.  self assert: convertedScope basisObjects equals: scope basisObjects.  self assert: convertedScope localScopeClass equals: scope localScopeClass.  self assert: convertedScope environment equals: scope environment-======-testExecution  | scope mainQuery |  scope := ClyScopeExample ofAll: {self class superclass .         self class} in: environment.  mainQuery := ClyQueryExampleReturningScopeBasis from: scope.  query subqueries: {mainQuery}.  self executeQuery.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: self class-======-groupProviderClass  ^ClyExtendedClassGroupProvider-======-isResult: aQueryResult affectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsClassExtension and: [ scope includesMethodsAffectedBy: aSystemAnnouncement ]-======-ownerDataSource  ^ownerDataSource-======-buildResult: aQueryResult  | result |  result := OrderedCollection new.  self analyzedObjectsDo: [:each |  result addAll: each critiques ].  aQueryResult fillWith: result-======-execute  browser navigateBack-======-execute  browser spawnQueryBrowserOn: (ClyClassReferencesQuery toAny: classes)-======-isExecutedFromSingleScope  ^scope isBasedOnSingleBasis-======-testNotBasedOnSingleBasisWhenSingleSubscopeIsNot  | subscope |  subscope := ClyScopeExample ofAll: #(basisObject1 basisObject2) in: environment.  scope := ClyCompositeScope on: {subscope}.  self deny: scope isBasedOnSingleBasis-======-detachFromTextMorph  -======-description  ^'Method watchpoints'-======-testIsEmptyFromEmptyClassScope  query scope: (ClyClassScope emptyIn: environment).  self assert: query checkEmptyResult-======-defaultIconName  ^#scriptManagerIcon-======-name: anObject  name := anObject-======-withoutBasisObject: existingBasisObject  ^self withNewBasisObjects: (basisObjects copyWithout: existingBasisObject)-======-testSelectedChildInExpandedItemWithRetrievedExpandedDataSource  | selectedItem retrievedSelectedItem |  self selectedItem expand.  selectedItem := self selectedItem childrenDataSource elementAt: 1.  queryView selection selectItems: {selectedItem}.  self snapshotState.  retrievedSelectedItem := navigationState selection items first.  self assert: retrievedSelectedItem ownerDataSource equals: navigationState dataSource expandedItems first childrenDataSource-======-searchText: aString  | found |  found := self itemCursor moveToItemWhich: [:each |  each name asLowercase beginsWith: aString asLowercase ].  ^found ifFalse: [ #() ] ifTrue: [ {self itemCursor position} ]-======-createQuery  ^ClyPackageExtensionMethodsQuery of: ClyClass1FromP1 package from: (ClyClassScope of: ClyClass1FromP1 in: environment)-======-priority  ^0-======-extraBasisSample  ^ClyClass2FromP1-======-addNewCommentForTestClass: aClass basedOn: baseClass  aClass comment: (String streamContents: [:stream |  | name |              name := aClass name.              name first isVowel ifTrue: [ stream nextPutAll: 'An ' ] ifFalse: [ stream nextPutAll: 'A ' ].              stream                 nextPutAll: name;                 nextPutAll: ' is a test class for testing the behavior of ';                 nextPutAll: baseClass name ])-======-scope: aScope  super scope: aScope.  critiqueQuery scope: aScope-======-isCaseSensitive  ^isCaseSensitive-======-windowIsClosing  tools do: [:each |  each cleanAfterRemove ]-======-applyTo: aBrowser  aBrowser changeStateBy: [ self restoreStateOf: aBrowser.        self restoreNavigationStateOf: aBrowser.        aBrowser tabManager restoreBrowserState: self ]-======-classSampleWhichHasGroup  ^ClyClass1FromP1-======-testConvertingWithExtraBasisObjectIfItIsAlreadyBasis  | convertedScope |  scope := self createSampleScope.  convertedScope := scope withExtraBasisObject: scope basisObjects anyOne.  self assert: convertedScope basisObjects equals: scope basisObjects-======-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWithDeprecatedMethods >> #deprecatedMethod1) .         (ClyClassWithDeprecatedMethods >> #deprecatedMethod2) .         (ClyClassWithDeprecatedMethods >> #notDeprecatedMethod)}.  self assert: foundSelectors sorted asArray equals: #(deprecatedMethod1 deprecatedMethod2)-======-testMatchesAnyStringWhenItIsBadRegex  | pattern |  pattern := ClyRegexPattern with: '!*'.  self assert: (pattern matches: 'any string')-======-systemScope  ^systemScope ifNil: [ systemScope := navigationEnvironment systemScope ]-======-closeDataSource  table initialDataSource ifNil: [ ^self dataSource close ].  table cleanupFilter.  table initialDataSource close-======-doItContext  ^nil-======-testExpectedMethodShouldIncludeExpectedString  self assert: ((self class >> #methodWithExpectedStringInSources) sourceCode includesSubstring: self expectedSourceCodeSubstring caseSensitive: false)-======-chooseClassesForNewMethod: aMethod  | methodClass selectedClasses |  methodClass := aMethod origin.  selectedClasses := self chooseClassesForNewMethod.  selectedClasses := selectedClasses copyWithout: methodClass.  ^selectedClasses , {methodClass}-======-findItemsSimilarTo: dataSourceItems  | foundItems relatedItems |  relatedItems := dataSourceItems select: [:each |  self isBasedOnQueryOf: each type ] thenCollect: [:each |  each browserItem ].  foundItems := self itemCursor findItemsSimilarTo: relatedItems.  ^foundItems collect: [:each |  self createElementWith: each ]-======-pluginsDo: aBlock  ^plugins do: aBlock-======-isActiveInContext: aBrowserContext  ^(super isActiveInContext: aBrowserContext) and: [ self toolClass shouldBeActivatedInContext: aBrowserContext ]-======-selection: anObject  selection := anObject-======-testExpandedItemWithRetrievedOwnerDataSource  | expandedItem |  self selectedItem expand.  self snapshotState.  expandedItem := navigationState dataSource expandedItems first.  self assert: expandedItem ownerDataSource equals: navigationState dataSource-======-collectMetadataOf: aQueryResult by: anEnvironmentPlugin  anEnvironmentPlugin collectMetadataOfClasses: aQueryResult-======-testFromClassScope  self queryFromScope: ClyClassScope ofAll: {self class .         self class superclass}.  self assert: resultItems size equals: 1.  self assert: resultItems first equals: (ClyClassComment of: self class)-======-description  ^'writers of ' , self printVariables-======-testAscendingDifferentPackage  function := ClySortMethodByPackageFunction ascending.  self deny: (function value: Object >> #printString value: Number >> #printString).  self assert: (function value: Number >> #printString value: Object >> #printString).  self assert: (function value: Object >> #printOn: value: Object >> #printString)-======-lastSelectedSourceNode  ^self selectedSourceNode-======-isResult: aQueryResult affectedBy: aSystemAnnouncement  ^aSystemAnnouncement affectsClasses or: [ aSystemAnnouncement canAffectResultOfMethodQuery: self ]-======-lastSelectedClassGroup  ^self lastSelectedObject-======-testSelectsDeprecatedMethod  self assert: (query selectsMethod: ClyClassWithDeprecatedMethods >> #deprecatedMethod1)-======-printOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: value;     nextPut: $)-======-createUpdateWithItemsStartingAt: startPosition count: cacheSize  | itemCache |  itemCache := ClyBrowserQueryCache filledBy: self startingAt: startPosition size: cacheSize.  ^ClyBrowserQueryUpdate of: self withItems: itemCache-======-defaultPackageFilter  ^DefaultPackageFilter ifNil: [ DefaultPackageFilter := ClyTableFilterFactory of: ClyItemNameFilter using: ClyRegexPattern new ]-======-decorateBrowserItem: anItem ofMethodGroup: aMethodGroup  -======-metaLevelsOf: aClass do: aBlock  self class metaLevelsOf: aClass do: aBlock-======-testCheckIfEmpty  self installWatchpointInto: #methodWithWatchpoint.  query scope: (ClyMethodScope of: self class >> #methodWithWatchpoint in: environment).  self deny: query checkEmptyResult.  query scope: (ClyMethodScope of: ClyClassWithBreakpoints >> #methodWithoutBreakpoints in: environment).  self assert: query checkEmptyResult-======-testIsExecutedFromEmptyScope  query scope: (ClyScopeExample ofAll: #(object1 object2) in: environment).  self deny: query isExecutedFromEmptyScope.  query scope: (ClyScopeExample emptyIn: environment).  self assert: query isExecutedFromEmptyScope-======-buildResult: aQueryResult  | filteredClasses |  filteredClasses := Set new.  scope classesDo: [:each |  (self selectsClass: each) ifTrue: [ filteredClasses add: each ] ].  aQueryResult fillWith: filteredClasses-======-createQueryResult  ^ClyMethodVisibilityGroups withHierarchy: ClySubclassHierarchy new-======-methodGroupView  ^methodGroupView-======-classCommentsContainingIt  | query |  self lineSelectAndEmptyCheck: [ ^self ].  query := ClyClassCommentsQuery withString: self selection string.  self browser spawnQueryBrowserOn: query-======-initialize  super initialize.  cacheGuard := Mutex new.  littleHierarchyMaxSize := 10-======-isComplexRefactoring  ^true-======-containerForItemsOfClass  ^SortedCollection sortBlock: ClySortSystemItemFunction ascending forBrowserItems-======-announceChangesOf: aQueryResult  self subclassResponsibility-======-isEditableGroup  ^self class isEditableGroup-======-browser  ^item browser-======-isNavigationPanelFocused  ^navigationViews anySatisfy: [:each |  each hasKeyboardFocus ]-======-defineTrait: defString notifying: aController startingFrom: aClass  | defTokens keywdIx oldTrait newTraitName trait |  aClass isTrait ifTrue: [ oldTrait := aClass ].  defTokens := defString findTokens: Character separators.  keywdIx := defTokens findFirst: [:x |  x = 'category' ].  keywdIx := defTokens findFirst: [:x |  x = 'named:' ].  newTraitName := (defTokens at: keywdIx + 1) copyWithoutAll: '#()'.  ((oldTrait isNil or: [ oldTrait instanceSide name asString ~= newTraitName ]) and: [ self includesClassNamed: newTraitName asSymbol ]) ifTrue: [ (self confirm: ((newTraitName , ' is an existing class/trait in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newTraitName size)) ifFalse: [ ^nil ] ].  trait := self defaultClassCompiler     source: defString;     requestor: aController;     logged: true;     evaluate.  ^trait isTrait ifTrue: [ trait ] ifFalse: [ nil ]-======-requiredQueryResult  ^systemQuery ifNil: [ self class defaultQueryResult ] ifNotNil: [ systemQuery requiredResult ]-======-selectItemsWhere: conditionBlock  | newItems |  newItems := rootDataSource findItemsWhere: conditionBlock.  self selectItems: newItems-======-createPackageNamed: packageName  ^packageOrganizer createPackageNamed: packageName-======-itemsStartingWhere: conditionBlock count: size  ^self prepareItems: (actualResult itemsStartingWhere: conditionBlock count: size)-======-testClassEnumerationOverMetaclassWhenClassSideIsLocalScope  scope := ClySuperclassScope of: ClyClass1FromP1 class localScope: ClyClassSideScope.  scope classesDo: [:each |  result add: each ].  self assert: result asSet equals: {Object class .         ProtoObject class} asSet-======-notifyChanges  announcer announce: ClyEnvironmentChanged-======-testFromMethodScope  self queryFromScope: ClyMethodScope ofAll: {(self class >> #reference1OfVar1) .         (self class >> #referenceOfAnotherVar)}.  self assert: resultItems size equals: 1.  self assert: resultItems first identicalTo: self class >> #reference1OfVar1-======-execute  browser switchFocusToPreviousPane-======-testFillingWithThreeClasVarsOfSuperclassAndSubclass  queryResult fillWith: {(ClyClassVariable named: #ClassVar1 definedIn: ClyClass2FromP1) .         (ClyClassVariable named: #SubclassClassVar definedIn: ClySubclassLOfClass2FromP1) .         (ClyClassVariable named: #ClassVar2 definedIn: ClyClass2FromP1)}.  self assertItems: {ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1 .         ClyVariableMethodGroup .         1 .         ClyVarDefinitionMethodGroup .         0 .         ClyVariableMethodGroup .         1}.  self assertVars: #(#ClassVar1 #ClassVar2 #SubclassClassVar)-======-testClassEnumerationOverClassWhenInstanceSideIsLocalScope  | expected |  scope := ClySubclassScope of: Class localScope: ClyInstanceSideScope.  scope classesDo: [:each |  result add: each ].  expected := Class subclasses select: #isInstanceSide.  self assert: result asSet equals: expected asSet-======-packages: anObject  packages := anObject-======-collectMethodGroupProviders  ^{ClyUndeclaredMethodGroupProvider new}-======-affectsMethodsTaggedWith: tagName  overriddenSuperclass withAllSubclassesDo: [:each |  (each tagsForMethods includes: tagName) ifTrue: [ ^true ] ].  ^false-======-unionWith: typedQueries as: aQueryResult  ^ClyQuery unionFrom: typedQueries , subqueries as: aQueryResult-======-execute  browser navigateForward-======-isSimilarTo: anotherBrowserContext  self class = anotherBrowserContext class ifFalse: [ ^false ].  selectedItems size = anotherBrowserContext selectedItems size ifFalse: [ ^false ].  ^selectedItems allSatisfy: [:each |  anotherBrowserContext isAboutSelectedItem: each ]-======-queryClass  ^ClyVariableWritersQuery-======-decorateMethodGroupTableCell: anItemCellMorph of: groupItem  subqueries do: [:each |  each decorateMethodGroupTableCell: anItemCellMorph of: groupItem ]-======-isRemoved  ^browserItem isNil or: [ ownerDataSource isParentRemoved or: [ ownerDataSource isParentCollapsed ] ]-======-testConvertingToNewBasis  scope := self createSampleScope.  self assert: (scope withNewBasisObjects: #(newBasis)) identicalTo: scope.  self assert: scope basisObjects isEmpty-======-adoptQuery: aQuery  ^aQuery-======-withMetaLevel: aMetaLevelScopeClass  self subclassResponsibility-======-testFromThreeMethods  self queryFromScope: ClyMethodScope ofAll: {(ClyClassWhichInheritsAbstractClass >> #abstractMethod1) .         (ClyClassWhichInheritsAbstractClass >> #notOverriddenMethod) .         (ClyClassWhichInheritsAbstractClass >> #overriddenMethod)}.  self assert: foundSelectors equals: #(abstractMethod1 #overriddenMethod)-======-checkEmptyResult  scope methodsDo: [:each |  (self selectsMethod: each) ifTrue: [ ^false ] ].  ^true-======-testBuildShouldSetUpItemsFromActualResultWhenTheyReady  queryResult rebuild.  query passExecution.  self waitBuildComplete.  self deny: (queryResult hasMetaProperty: ClyBackgroundProcessingTag).  self assert: queryResult items identicalTo: queryResult actualResult items.  self assert: queryResult items asSet equals: query scope basisObjects-======-displayBlock  ^displayBlock-======-buildingQuery  ^buildingQuery-======-decorateBrowserItem: anItem ofClass: aClass  -======-description  ^'go backward in the navigation history'-======-label  ^label-======-includesMethod: aMethod  ^true-======-removeWithMethods  self methods do: [:each |  each removeFromSystem ]-======-toggle  | formatter isDirty |  formatter := RBProgramNode formatterClass.  formatter formatAsYouReadPolicy ifTrue: [ formatter formatAsYouReadPolicy: false.        textMorph model canDiscardEdits ifTrue: [ textMorph model cancelEdits ] ] ifFalse: [ formatter formatAsYouReadPolicy: true.        isDirty := textMorph hasUnacceptedEdits.        textMorph model formatSourceCodeInView.        isDirty ifFalse: [ textMorph model clearUserEdits ] ]-======-switchToVariables  | classScope |  self changeMethodGroupQueryBy: [ classScope := self classScopeForMethods.        ClyAllVariablesQuery from: classScope , classScope asInheritedScope as: ClyGroupedInstanceVariables withDefaultHierarchy ]-======-meaningfullObjectToAssert: resultItem  ^resultItem actualObject-======-activationPriority  ^0-======-executesQuery: aTypedQueryClass  ^self isKindOf: aTypedQueryClass-======-bindingOf: aSymbol  ^environment bindingOf: aSymbol-======-oneTwo: anObject  self two: anObject-======-whenEscapeKeyPressedDo: aBlock  table bindKeyCombination: Character escape asShortcut toAction: aBlock-======-testIsAffectedByChangeOfNotAbstractMethodWhichImplementsAbstractOne  self assert: (query isAffectedByChangedMethod: ClyAbstractSubclassExample >> #abstractMethod1)-======-itemsStartingAt: startIndex count: size  | result |  result := super itemsStartingAt: startIndex count: size.  result do: [:each |  each prepareIn: environment ].  ^result-======-groupProviderClass  ^ClyUndeclaredMethodGroupProvider-======-testGettingItemsStartingWhereConditionIsValid  | actual |  queryResult fillWith: #(1 2 3 4 5 6).  actual := queryResult itemsStartingWhere: [:each |  each > 3 ] count: 2.  self assert: actual asArray equals: #(4 5)-======-itemAt: rowIndex  ^self dataSource elementAt: rowIndex-======-testGettingSingletonInstanceFromScratch  ClyUnknownQuery reset.  self assert: ClyUnknownQuery instance identicalTo: ClyUnknownQuery instance-======-parserClass  ^RBParser-======-initialize  super initialize.  excludesHaltsForTesting := true-======-childrenItems  ^childrenDataSource allElements-======-redoNavigationOf: aBrowser  redoList ifEmpty: [ ^self ].  self executeRedoBy: [ self restoreNavigationState: redoList removeLast of: aBrowser ]-======-openBrowserCursorFor: anItemObserver  | cursor |  cursor := ClyBrowserQueryCursor for: self adoptForBrowser.  cursor openFor: anItemObserver.  ^cursor-======-requestMultipleObjects: dialogTitle from: aQuery  self openOn: aQuery withTitle: dialogTitle thenDo: [ itemsView selection isEmpty ifTrue: [ ^self findObjectsSameAsFilter ].        ^itemsView selection actualObjects ]-======-superclassSenderOfMessage1  self clyReferencedMessage1-======-defaultMenuItemName  ^'Convert to extension'-======-isModeActive  ^activator isCommandAppliedToBrowser-======-isParentCollapsed  ^self isParentExpanded not-======-isActive  ^isActive-======-relationScopeClasses  ^relationScopeClasses-======-testExecutesConcreteQueryClass  self assert: (query executesQuery: query class).  self assert: (query executesQuery: query class superclass).  self deny: (query executesQuery: ClyQueryExampleReturningScopeBasis2)-======-defaultMenuItemName  ^menuItemName-======-cellColumn: column row: rowIndex  | item |  item := self elementAt: rowIndex.  ^column createCellFor: item in: queryView-======-useFullIndentation  fullIndentation := true-======-metadata  ^actualResult metadata-======-execute  (DAPackageAnalyzerPackageDependenciesWindow onPackagesNamed: {analyzedObject packageName}) open-======-testFromClassScope  self queryFromScope: ClyBothMetaLevelClassScope of: self class.  self assert: resultItems size equals: 2.  self assert: foundSelectors equals: #(reader1OfVar1 reader2OfVar1)-======-selectedTextInterval  ^tool selectedTextInterval-======-checkClassIsAbstract: aClass  aClass withAllSuperclassesDo: [:eachClass |  eachClass methodsDo: [:eachMethod |  (eachMethod isAbstract and: [ (aClass lookupSelector: eachMethod selector) isAbstract ]) ifTrue: [ ^true ] ] ].  ^false-======-initialize  super initialize.  properties := OrderedCollection new-======-implementorClass  ^implementorMethod origin-======-updateExpandingItems  self updateItems: collapsedItems.  collapsedItems := collapsedItems reject: [:each |  each isRemoved ]-======-testFillingWithTwoClassWhichInheriteSameTraits  queryResult fillWith: {ClyClassWithTraits .         ClyTraitChild2 .         ClyTraitRoot2 .         ClySubclassWithTraitsOfClassWithTraits}.  self assertItems: {ClySubclassWithTraitsOfClassWithTraits .         0 .         ClyTraitRoot2 .         1 .         ClyClassWithTraits .         1 .         ClyTraitChild2 .         2 .         ClyTraitRoot2 .         3 .         ClyTraitRoot2 .         2}-======-restrictedByScope: aScope  ^self withScope: (scope restrictedBy: aScope)-======-tableCellIcon  ^Smalltalk ui iconNamed: #haloView-======-createQuery  ^ClyMethodSourcesQuery withString: self expectedSourceCodeSubstring from: (ClyClassScope of: self class in: environment)-======-