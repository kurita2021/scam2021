isEmpty  ^classSelectors isEmpty and: [ metaClassSelectors isEmpty ]resultClass  ^RBSelectorEnvironmentunoptimizedAndOr  ^(true and: [ false ]) and: [ true ]preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'Class named ' , className , ' does not exist') & (RBCondition withBlock: [ self model environment categories includes: category ] errorString: 'Category named ' , category , ' does not exist')preconditions  ^(RBCondition isValidInstanceVariableName: newVariableName for: self definingClass) & (RBCondition definesSelector: selector in: self definingClass) & (RBCondition definesInstanceVariable: newVariableName in: self definingClass) not & (RBCondition definesClassVariable: newVariableName in: self definingClass) nottestInlineMethodFromComponentFailure  self shouldFail: (RBInlineMethodFromComponentRefactoring inline: (50 to: 64) inMethod: #inlineFailed forClass: RBRefactoryTestDataApp)preconditions  ^selectors inject: RBCondition empty into: [:arg1 :arg2 |  arg1 & (RBCondition definesSelector: arg2 in: class) ]modifyImplementorParseTree: arg1 in: arg2  | tmp1 tmp2 |  tmp1 := (arg1 arguments at: parameterIndex) copy.  arg1 body addTemporaryNamed: tmp1 name.  tmp2 := RBAssignmentNode variable: tmp1 copy value: expressions first.  arg1 body addNodeFirst: tmp2.  super modifyImplementorParseTree: arg1 in: arg2changeSymbol  ^#removeClassVarNamed:testTransformNotSequenceNode  | tmp1 tmp2 |  tmp1 := RBCompositeTransformation new transformations: (OrderedCollection with: (RBAddMethodTransformation sourceCode: 'printString1 super printString' in: self changeMock name withProtocol: #accessing) with: (RBRemoveSubtreeTransformation code: 'super printString' from: #printString1 in: self changeMock name)).  tmp1 transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 directlyDefinesMethod: #printString1).  self assertEmpty: (tmp2 parseTreeFor: #printString1) body statementsargumentsAndValues  ^argsAndValuesparameterMap  ^parameterMapcontroller  ^controllerignoreChangesWhile: arg1  isPerformingRefactoring ifTrue: [ ^arg1 value ].  isPerformingRefactoring := true.  arg1 ensure: [ isPerformingRefactoring := false ]group  ^'Coding Idiom Violation'targetClass  ^classsignalReferenceError: arg1  class realClass ifNil: [ self refactoringError: arg1 ] ifNotNil: [ | tmp1 tmp2 |        tmp2 := '<1s><n>Browse references?' expandMacrosWith: arg1.        tmp1 := variableName asSymbol.        self refactoringError: tmp2 with: [ self openBrowserOn: (RBVariableEnvironment referencesToClassVariable: tmp1 in: class realClass) ] ]convertClasses: arg1 select: arg2 using: arg3  arg1 do: [:arg4 |  (arg2 value: arg4) do: [:arg5 |  self convertMethod: arg5 for: arg4 using: arg3 ] ]moveDefinition  | tmp1 |  ^(self collect: [:arg1 |  tmp1 := arg1 printString.        tmp1 , tmp1 ]) select: [:arg1 |  tmp1 := arg1 size.        tmp1 odd ]testModelPushDownToMetaclass  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model metaclassNamed: #SomeClass) addInstanceVariable: 'foo'.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model metaclassNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  self executeRefactoring: (RBPushDownInstanceVariableRefactoring model: model variable: 'foo' class: (model metaclassNamed: #SomeClass)).  self deny: ((model metaclassNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model metaclassNamed: #Subclass) directlyDefinesVariable: 'foo')removeInstanceVariable: arg1 from: arg2  ^RBRemoveInstanceVariableChange remove: arg1 from: arg2preconditions  ^RBCondition emptyerrorMacro: arg1  errorMacro := arg1resultClass  ^RBPackageEnvironmenttypesFor: arg1  ^variableTypes at: arg1 ifAbsent: [ Set new ]checkForPrimitiveMethod  parseTree isPrimitive ifTrue: [ self refactoringError: 'Cannot move primitive methods' ]definingMethod  ^self definingClass parseTreeFor: selector asSymboltestUnusedClassVariable  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  self assert: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (RBPushDownVariableTransformation model: model classVariable: #Foo class: (model classNamed: #SomeClass)) asRefactoring transform.  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  self deny: ((model classNamed: #Subclass) directlyDefinesVariable: #Foo)signalProcesses: arg1  arg1 ifNil: [ ^self ].  [ arg1 isEmpty ] whileFalse: [ arg1 signal ]haveSameNumberOfArgs  (self numberOfArgs: oldSelector) = (self numberOfArgs: newSelector) ifFalse: [ self refactoringFailure: 'The new selector does not have the same number of parameters.' ]testPullUpWithSuperSendThatCannotBeCopiedDown  | tmp1 |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Object) compile: 'foo ^3' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^super foo' classified: #(#accessing).  model defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (tmp1 := model classNamed: #Foo2) compile: 'foo ^1' classified: #(#accessing).  self shouldFail: (RBPullUpMethodRefactoring model: model pullUp: #(#foo) from: tmp1)messagePattern  ^'self ' , (self buildSelectorString: selector)testNonExistantName  self     shouldFail: (RBMoveVariableDefinitionRefactoring bindTight: (1 to: 10) in: RBLintRuleTestData selector: #name1);     shouldFail: (RBMoveVariableDefinitionRefactoring bindTight: (44 to: 54) in: RBLintRuleTestData selector: #displayName);     shouldFail: (RBMoveVariableDefinitionRefactoring bindTight: (16 to: 25) in: RBLintRuleTestData selector: #displayName)testTransform  | tmp1 tmp2 |  tmp1 := (RBProtectVariableTransformation instanceVariable: 'class' class: #RBTransformationRuleTestData) transform.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 directlyDefinesLocalMethod: #class1).  self assert: (tmp2 directlyDefinesLocalMethod: #class:).  self assert: (tmp2 parseTreeFor: #superSends) equals: (self parseMethod: 'superSends		| rule |		rule := RBParseTreeRewriter new.		rule addSearch: ''super `@message: ``@args'' 			-> (				[:aNode | 				(self class1 withAllSubclasses 					detect: [:each | each includesSelector: aNode selector]					ifNone: [nil]) isNil] 						-> ''self `@message: ``@args'').		self rewriteUsing: rule').  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 		self class: aSmalllintContext selectedClass.		(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: 				[builder 					compile: rewriteRule tree printString					in: self class1					classified: aSmalllintContext protocols]]')addClass: arg1  arg1 isMeta ifTrue: [ metaClassSelectors at: arg1 soleInstance name put: arg1 selectors asIdentitySet ] ifFalse: [ classSelectors at: arg1 name put: arg1 selectors asIdentitySet ]group  ^'Optimization'whatToDisplayIn: arg1  ^(self changes changes select: [:arg2 |  {getterMethod .         setterMethod} includes: arg2 selector ]) flatCollect: [:arg2 |  arg2 whatToDisplayIn: arg1 ]resetResult  result := result copyEmpty.  result label: namemethodDelimiter  ^'#''place.holder.for.method'''testMetaClassFailure  self shouldFail: (RBAbstractClassVariableRefactoring variable: #RecursiveSelfRule class: RBTransformationRuleTestData class)preconditions  | tmp1 |  self requestSelectors.  tmp1 := selectors inject: RBCondition empty into: [:arg1 :arg2 |  arg1 & (RBCondition definesSelector: arg2 in: class) & (RBCondition subclassesOf: class referToSelector: arg2) not ].  ^tmp1 & (RBCondition isAbstractClass: class)superclassEquivalentlyDefines: arg1  | tmp1 tmp2 |  class superclass ifNil: [ ^false ].  tmp1 := class superclass parseTreeFor: arg1.  tmp2 := class parseTreeFor: arg1.  (tmp1 isNil or: [ tmp2 isNil ]) ifTrue: [ ^false ].  ^tmp1 equalTo: tmp2 exceptForVariables: #()changeClass: arg1  changedClasses at: arg1 name put: (Array with: arg1 instanceSide with: arg1 classSide).  self flushCachespackageNames  ^packages collect: [:arg1 |  arg1 packageName ]type: arg1 block: arg2 errorString: arg3  type := arg1.  block := arg2.  self errorMacro: arg3demoRenameMethod: arg1 PermuteArgs: arg2  self do: arg1.  self do: arg2.  ^arg1 > arg2critiqueFor: arg1 about: arg2  | tmp1 |  tmp1 := (arg1 isKindOf: RBProgramNode) ifFalse: [ ReSourceAnchor entity: arg2 ] ifTrue: [ ReIntervalSourceAnchor entity: arg2 interval: arg1 sourceInterval ].  ^ReTrivialCritique withAnchor: tmp1 by: selfrbMetaclassClass  ^RBMetaclass2verifyInitializationExpression  | tmp1 |  tmp1 := self parserClass parseExpression: initializer onError: [:arg1 :arg2 |  self refactoringFailure: 'Illegal initialization code because:.' , arg1 ].  tmp1 isValue ifFalse: [ self refactoringFailure: 'The initialization code cannot be a return node or a list of statements' ].  self checkVariableReferencesIn: tmp1isEmpty  ^result isEmptyisEmpty  ^self accessorMethods allSatisfy: [:arg1 |  (self perform: arg1) isEmpty ]storeOn: arg1  arg1 nextPut: $(.  super storeOn: arg1.  arg1     nextPutAll: ' class: ';     nextPutAll: class name;     nextPutAll: ' protocols: '.  protocols asArray storeOn: arg1.  arg1 nextPut: $)getClassesToMoveTo  self isMovingToArgument ifTrue: [ self getClassesForTemporaryVariable ] ifFalse: [ self isMovingToInstVar ifTrue: [ self getClassesForInstanceVariable ] ifFalse: [ self getClassForGlobalOrClassVariable ] ].  moveToClasses ifEmpty: [ self refactoringFailure: 'No classes selected, method not moved.' ]privateClassVariableNames  (self isDefined and: [ classVariableNames isNil ]) ifTrue: [ self classVariableNames: self realClass classVarNames ].  ^classVariableNamesaddNode: arg1 toSequence: arg2  arg2 statements detect: [:arg3 |  arg3 intersectsInterval: interval ] ifFound: [:arg3 |  arg3 isBlock ifTrue: [ arg3 body addNode: arg1 ] ifFalse: [ arg2 addNode: arg1 before: arg3 ] ].  ^arg2 parentSuchAs: #isMethodtestWithoutClassesRemovesClassesFromSender  | tmp1 tmp2 |  tmp1 := RBBrowserEnvironment new forClasses: Number withAllSubclasses.  tmp2 := tmp1 withoutClasses: {Number .         Integer}.  self assert: tmp2 classes size equals: tmp1 classes size - 2newResultClass: arg1  result := arg1 newtempVarOverridesInstVar  | tmp1 |  tmp1 := 4.  ^tmp1compileEqual  | tmp1 tmp2 tmp3 |  tmp1 := self parserClass parseMethod: '= anObject		"Answer whether the receiver and anObject represent the same object."		self == anObject ifTrue: [ ^ true ].		self class = anObject class ifFalse: [ ^ false ]'.  tmp2 := nil.  variables reversed do: [:arg1 |  | tmp4 |        tmp4 := self accessorForVariable: arg1.        tmp3 := RBMessageNode receiver: (RBVariableNode named: arg1) selector: #= arguments: (Array with: (RBMessageNode receiver: (RBVariableNode named: 'anObject') selector: tmp4)).        tmp2 := tmp2 ifNil: [ tmp3 ] ifNotNil: [ RBMessageNode receiver: tmp3 selector: #and: arguments: (Array with: (RBBlockNode body: (RBSequenceNode statements: (Array with: tmp2)))) ] ].  tmp1     addNode: tmp2;     addReturn.  self theClass compile: tmp1 formattedCode classified: #(comparing)check  ^condition check notforCategories: arg1  ^RBCategoryEnvironment onEnvironment: self categories: arg1setupVariableTypesFor: arg1 toReturn: arg2  | tmp1 |  tmp1 := arg1 options copy.  tmp1 at: #variableTypes put: [:arg3 :arg4 :arg5 |  arg2 ].  arg1 options: tmp1testPullUpMethodWithCopyOverriddenMethodsDown  | tmp1 |  self proceedThroughWarning: [ tmp1 := RBPullUpMethodRefactoring pullUp: #(#isComposite) from: RBCompositeLintRuleTestData.        self executeRefactoring: tmp1 ].  self assert: ((tmp1 model classNamed: #RBBasicLintRuleTestData) parseTreeFor: #isComposite) equals: (self parseMethod: 'isComposite ^false').  self assert: ((tmp1 model classNamed: ('RBFoo' , 'LintRuleTestData') asSymbol) parseTreeFor: #isComposite) equals: (self parseMethod: 'isComposite ^false').  self assert: ((tmp1 model classNamed: #RBLintRuleTestData) parseTreeFor: #isComposite) equals: (self parseMethod: 'isComposite ^true').  self deny: ((tmp1 model classNamed: #RBCompositeLintRuleTestData) directlyDefinesMethod: #isComposite)group  ^'Architecture'testAndEnvironment  | tmp1 tmp2 tmp3 |  tmp1 := universalEnvironment referencesTo: #printOn:.  tmp2 := universalEnvironment forClass: Object selectors: #(#fullPrintString).  tmp3 := tmp2 & tmp1.  self universalTestFor: tmp3.  self assert: tmp3 numberSelectors equals: 1.  self assert: tmp3 classNames asArray equals: #(#Object).  self assert: (tmp3 protocolsFor: Object) size equals: 1.  self assert: (tmp2 & tmp2) packages equals: tmp2 packages.  tmp3 := tmp1 & (universalEnvironment referencesTo: #printString).  self assert: tmp3 numberSelectors equals: (tmp1 referencesTo: #printString) numberSelectors.  self assert: tmp3 classNames asSortedCollection equals: (tmp1 referencesTo: #printString) classNames asSortedCollectioncomputeEquivalenceClassesForMethodsAndVars  | tmp1 |  backpointers := self backpointersDictionary.  class instanceVariableNames do: [:arg1 |  backpointers at: arg1 put: (self backpointersSetWith: arg1) ].  class withAllSubclasses do: [:arg2 |  arg2 selectors do: [:arg1 |  backpointers at: arg1 put: (self backpointersSetWith: arg1) ] ].  tmp1 := self parseTreeSearcher.  tmp1 matches: '^``@object' do: [:arg3 :arg4 |  self processNode: arg3 value ].  self executeSearch: tmp1checkClass: arg1  testExtractFailure  self shouldFail: (RBExtractMethodTransformation extract: (self sourceCodeAt: (80 to: 269) forMethod: #subclassOf:overrides: in: RBBasicLintRuleTestData class) from: #subclassOf:overrides: to: #foo in: #'RBBasicLintRuleTestData class') asRefactoring.  self shouldFail: (RBExtractMethodTransformation extract: (self sourceCodeAt: (53 to: 56) forMethod: #subclassOf:overrides: in: RBBasicLintRuleTestData class) from: #subclassOf:overrides: to: #foo in: #'RBBasicLintRuleTestData class') asRefactoring.  self shouldFail: (RBExtractMethodTransformation extract: (self sourceCodeAt: (77 to: 222) forMethod: #subclassResponsibilityNotDefined in: RBBasicLintRuleTestData class) from: #subclassResponsibilityNotDefined to: #foo in: #'RBBasicLintRuleTestData class') asRefactoringremoveMethods: arg1 from: arg2  class := self classObjectFor: arg2.  selectors := arg1problemCount  self subclassResponsibilitypushUp: arg1 in: arg2  | tmp1 |  tmp1 := arg2 sourceCodeFor: arg1.  tmp1 ifNotNil: [ arg2 superclass compile: tmp1 classified: (arg2 protocolsFor: arg1) ]testRefactoring  | tmp1 |  tmp1 := (RBAddProtocolTransformation protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  RBRefactoryChangeManager instance performChange: tmp1 changes.  tmp1 := (RBRemoveProtocolTransformation protocol: 'transforming' inClass: #RBDummyEmptyClass) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1minMax  ^3 < 5 ifTrue: [ 3 ] ifFalse: [ 5 ]hash  ^definition hashprocessReferenceNode: arg1  | tmp1 |  tmp1 := arg1 name.  ignore = tmp1 ifTrue: [ ^self ].  (arg1 whoDefines: tmp1) ifNotNil: [ ^self ].  (self instanceVariableNames includes: tmp1) ifTrue: [ instVarReaders add: tmp1 ].  (self classVariableNames includes: tmp1) ifTrue: [ classVarReaders add: tmp1 ]testImplementorsMatching  | tmp1 |  tmp1 := RBBrowserEnvironment new implementorsMatching: '*print*'.  self universalTestFor: tmp1.  self assert: (tmp1 implementorsOf: #printString) numberSelectors equals: (RBBrowserEnvironment new implementorsOf: #printString) numberSelectors.  tmp1 classesAndSelectorsDo: [:arg1 :arg2 |  self assert: ('*print*' match: arg2) ]testCompileInInteractively  | tmp1 |  tmp1 := changeFactory addMethodSource: 'setUp' in: self class classified: #running for: self.  self assert: tmp1 controller equals: self.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 selector equals: #setUp.  self assert: tmp1 source equals: 'setUp'.  self assert: tmp1 protocol equals: #running.  self universalTestFor: tmp1rbClass  ^self class rbClasscalculateNewArgumentsIn: arg1  arg1 arguments size > arguments size ifTrue: [ | tmp1 |        tmp1 := RBMethodArgumentsSelector openOn: arg1 arguments copy and: (newMethod body allChildren select: #isLiteralNode thenCollect: [:arg2 |  arg2 value storeString ]) in: newMethod.        newMethod := tmp1 newTree.        ^tmp1 argumentsAndValues ].  ^Dictionary newtempsReadBeforeWritten  | tmp1 |  self isVariable ifTrue: [ tmp1 := 4 ].  ^tmp1removeClassNamed: arg1  ^self addChange: (changeFactory removeClassNamed: arg1)testMethodDoesNotExist  | tmp1 |  tmp1 := (RBAddSubtreeTransformation interval: (0 to: 1) with: 'self printString' from: #two in: self changeMock name) transform.  self assertEmpty: tmp1 model changes changesstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' renameTemporaryFrom: '.  interval storeOn: arg1.  arg1     nextPutAll: ' to: ''';     nextPutAll: newName;     nextPutAll: ''' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' selector: #';     nextPutAll: selector.  arg1 nextPut: $)resetResult  rules do: [:arg1 |  arg1 resetResult ]forClass: arg1 protocols: arg2  ^RBProtocolEnvironment onEnvironment: self class: arg1 protocols: arg2removeParameter: arg1 in: arg2 selector: arg3  oldSelector := arg3.  class := self classObjectFor: arg2.  argument := arg1resumeOnCannotRemoveTopLevelClassError: arg1  ^arg1 messageText = RBRemoveClassRefactoring cannotRemoveTopLevelClassErrorMesssage ifTrue: [ arg1 resume ]preconditions  ^(RBCondition isValidInstanceVariableName: newName for: class) & (RBCondition definesInstanceVariable: variableName in: class) & (RBCondition hierarchyOf: class definesVariable: newName) not & (RBCondition isGlobal: newName in: self model) notsort: arg1  rules first isComposite ifTrue: [ rules do: [:arg2 |  arg2 sort: arg1 ] ] ifFalse: [ self rules: (rules sort: arg1) ]collectionProtocol  | tmp1 |  tmp1 := OrderedCollection new.  (1 to: 10) asOrderedCollection do: [:arg1 |  | tmp2 |        tmp2 := arg1 * 2.        tmp1 add: tmp2 ].  ^tmp1storeOn: arg1  | tmp1 |  arg1     nextPutAll: '((';     nextPutAll: self class name;     nextPutAll: ' onEnvironment: '.  environment storeOn: arg1.  arg1     nextPut: $);     nextPutAll: ' classes: #('.  tmp1 := [:arg2 :arg3 |  arg1     nextPutAll: '#(';     nextPutAll: arg2;     nextPutAll: ' #('.  arg3 do: [:arg4 |  arg1           nextPutAll: arg4;           nextPut: $  ].  arg1     nextPutAll: '))';     cr ].  classSelectors keysAndValuesDo: tmp1.  arg1 nextPutAll: ') metaClasses: #('.  metaClassSelectors keysAndValuesDo: tmp1.  arg1 nextPutAll: '))'testPerformRenameInstanceVariable  | tmp1 |  tmp1 := changes renameInstanceVariable: 'instVar' to: 'instVarPlus' in: self changeMock.  self perform: tmp1 do: [ self deny: (tmp1 changeClass instVarNames includes: tmp1 oldName).        self assert: (tmp1 changeClass instVarNames includes: tmp1 newName) ].  self assert: (tmp1 changeClass instVarNames includes: tmp1 oldName).  self deny: (tmp1 changeClass instVarNames includes: tmp1 newName)result  ^resulttestRefactoring  | tmp1 tmp2 |  model defineClass: 'Object subclass: #Foo		instanceVariableNames: ''a''		classVariableNames: ''''		poolDictionaries: ''''		category: #''Refactoring2-Refactorings-Tests'''.  tmp2 := model classNamed: #Foo.  tmp2     compile: 'foo	^Object' classified: #(#accessing);     compile: 'objectName ^#(Object)' classified: #(#accessing).  tmp1 := (RBRenameClassTransformation model: model rename: #Object to: #Thing) asRefactoring transform.  self assert: (model includesClassNamed: #Thing).  self deny: (model includesClassNamed: #Object).  self assert: (tmp2 parseTreeFor: #foo) equals: (self parseMethod: 'foo ^Thing').  self assert: (tmp2 parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^#(Thing)').  self assert: tmp2 superclass name equals: #Thingselectors  | tmp1 |  tmp1 := Set new.  tmp1 addAll: self newMethods keys.  self isDefined ifTrue: [ tmp1 addAll: self realClass selectors.        removedMethods ifNotNil: [ removedMethods do: [:arg1 |  tmp1 remove: arg1 ifAbsent: [  ] ] ] ].  ^tmp1checkBackReferencesTo: arg1  | tmp1 tmp2 |  tmp1 := targetSuperclass whoDefinesMethod: arg1.  tmp1 ifNil: [ ^self ].  tmp2 := class parseTreeFor: arg1.  targetSuperclass allSubclasses do: [:arg2 |  arg2 selectors do: [:arg3 |  | tmp3 |              tmp3 := arg2 parseTreeFor: arg3.              (tmp3 notNil and: [ (tmp3 superMessages includes: arg1) and: [ tmp1 == (arg2 whoDefinesMethod: arg1) ] ]) ifTrue: [ removeDuplicates := true.                    (arg1 == arg3 and: [ tmp3 equalTo: tmp2 exceptForVariables: #() ]) ifFalse: [ self refactoringError: ('Cannot pull up <1s> since it would override the method defined in <2p>' expandMacrosWith: arg1 with: tmp1) ] ] ] ]methodAfter  | tmp1 |  tmp1 := 'String'unmarkAsRemoved: arg1  removedClasses     remove: arg1 ifAbsent: [  ];     remove: arg1 , ' class' ifAbsent: [  ]testDefinesClassVariable  self deny: (objectClass definesClassVariable: #ClassVariable1).  self assert: (objectClass definesClassVariable: self objectClassVariable).  self assert: (newClass definesClassVariable: #ClassVariable1).  self deny: (messageNodeClass definesClassVariable: #ClassVariable1).  self assert: (messageNodeClass definesClassVariable: self objectClassVariable)testSelectMethods  | tmp1 |  tmp1 := RBBrowserEnvironment new selectMethods: [:arg1 |  false ].  self assert: tmp1 numberSelectors equals: 0.  self assert: tmp1 numberClasses equals: 0.  tmp1 := RBBrowserEnvironment new selectMethods: [:arg1 |  true ].  self assert: tmp1 numberSelectors equals: RBBrowserEnvironment new numberSelectors.  tmp1 := RBBrowserEnvironment new selectMethods: [:arg1 |  arg1 refersToLiteral: #environment ].  self assert: tmp1 numberSelectors equals: (RBBrowserEnvironment new referencesTo: #environment) numberSelectorsonEnvironment: arg1  environment := arg1testExtractWithRenamingOfParameters  | tmp1 tmp2 |  tmp1 := RBExtractMethodRefactoring extract: (78 to: 197) from: #displayName in: RBLintRuleTestData.  self setupMethodNameFor: tmp1 toReturn: #foo:.  tmp1 parameterMap: (Dictionary new           at: #nameStream put: #newParameter;           yourself).  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self assert: (tmp2 parseTreeFor: #displayName) equals: (self parseMethod: 'displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	self foo: nameStream.	^nameStream contents').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: newParameter 	newParameter nextPutAll: self name;		nextPutAll: '' (''.	self problemCount printOn: newParameter.	newParameter nextPut: $).')cancelAction: arg1  cancelAction := arg1fillOutDefinition: arg1  className := (arg1 at: '`#traitName') asSymbol.  category := (arg1 at: '`#package' ifAbsent: [ #Unclassified ]) asSymbolclassSide  ^selfpullUpClassInstanceVariables  | tmp1 |  tmp1 := self abstractSuperclass classSide.  parent classSide instanceVariableNames do: [:arg1 |  self performComponentRefactoring: (RBPullUpInstanceVariableRefactoring model: self model variable: arg1 class: tmp1) ]computeLiterals  literalSemaphore := Semaphore new.  literalProcess := [ self primitiveComputeLiterals ] forkreferencesTo: arg1  ^RBSelectorEnvironment referencesTo: arg1 in: selfaddPackage: arg1  packages add: arg1name  ^nameresultClass  renrakuRule class checksNode ifTrue: [ ^RBSelectorEnvironment ].  renrakuRule class checksMethod ifTrue: [ ^RBSelectorEnvironment ].  renrakuRule class checksClass ifTrue: [ ^RBClassEnvironment ].  renrakuRule class checksPackage ifTrue: [ ^RBPackageEnvironment ].  ^RBMultiEnvironmentcheckClass: arg1 selector: arg2 using: arg3  | tmp1 |  tmp1 := arg1 parseTreeFor: arg2.  tmp1 ifNotNil: [ arg3 executeTree: tmp1 ].  ^arg3 answerselectedClass: arg1  class := arg1.  self selector: nilcaller1  | tmp1 |  tmp1 := 5.  self called: tmp1 + 1 on1: [:arg1 |  arg1 printString.        ^tmp1 ]classBlock  ^self anInstVar + 5getNewMethodName  | tmp1 tmp2 tmp3 |  tmp2 := RBMethodName new.  tmp2 arguments: parameters.  [ tmp3 := self requestMethodNameFor: tmp2.  tmp3 ifNil: [ self refactoringFailure: 'Did not extract code' ].  tmp1 := tmp3 selector.  (self checkMethodName: tmp1 in: class) ifFalse: [ self refactoringWarning: tmp1 , ' is not a valid selector name.'.        tmp1 := nil ].  (class hierarchyDefinesMethod: tmp1 asSymbol) ifTrue: [ (self shouldOverride: tmp1 in: class) ifFalse: [ tmp1 := nil ] ].  tmp1 isNil ] whileTrue: [  ].  parameters := tmp3 arguments asOrderedCollection.  ^tmp1 asSymbolbasicCheck: arg1  (self matcher canMatchMethod: arg1) ifFalse: [ ^false ].  ^(self matcher executeTree: arg1 ast initialAnswer: nil) isNotNiltestTransform  | tmp1 tmp2 |  tmp1 := (RBRemoveSubtreeTransformation code: '^ 1' from: #one in: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 directlyDefinesMethod: #one).  self assertEmpty: (tmp2 parseTreeFor: #one) body statementscategory  ^categorytestRemoveInstVar  | tmp1 tmp2 |  tmp1 := RBRemoveInstanceVariableRefactoring variable: 'foo1' class: RBLintRuleTestData.  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self assert: (tmp2 definesInstanceVariable: 'foo1').  self executeRefactoring: tmp1.  self deny: (tmp2 definesInstanceVariable: 'foo1')testBadName  self     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'name' in: RBLintRuleTestData selector: #openEditor);     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'rules' in: RBLintRuleTestData selector: #openEditor);     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'DependentFields' in: RBLintRuleTestData selector: #openEditor);     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'a b' in: RBLintRuleTestData selector: #openEditor)variableDefinitionsInHierarchy  ^self definingClass allSubclasses select: [:arg1 |  isClassVariable ifTrue: [ arg1 isMeta not and: [ arg1 directlyDefinesClassVariable: variableName ] ] ifFalse: [ arg1 directlyDefinesInstanceVariable: variableName ] ] thenCollect: #nametestBadMethod  self shouldFail: (RBAddMethodRefactoring addMethod: 'asdf ^super ^printString' toClass: RBBasicLintRuleTestData inProtocols: #(#accessing))variables: arg1  variables := arg1testClassDoesNotExist  self shouldFail: (RBAddMessageSendTransformation messageSend: 'variable byteAt: 1' inMethod: #methodBefore inClass: #RBMessageSendTransformationTest) asRefactoringpreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'No such class or trait named ' , className asString) & (RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ self definingMethod allTemporaryVariables includes: variableName ] errorString: 'Method named ' , selector , ' does not define a temporary variable named ' , variableName) & (RBCondition withBlock: [ (self definingMethod allArgumentVariables includes: variableName) not ] errorString: 'Variable named ' , variableName , ' cannot be removed because it is an argument in this method')testCompileInClass  | tmp1 |  tmp1 := changes compile: 'setUp' in: self class.  self assert: tmp1 controller isNil.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 selector equals: #setUp.  self assert: tmp1 source equals: 'setUp'.  self assert: tmp1 protocol equals: #running.  self universalTestFor: tmp1problemCount  ^rules inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 problemCount ]methodAfter  | tmp1 |  tmp1 := 'String'.  tmp1 byteAt: 1testRemoveMethod  | tmp1 tmp2 |  tmp2 := Array with: ('selectorNot' , 'Referenced') asSymbol.  tmp1 := RBRemoveMethodRefactoring removeMethods: tmp2 from: RBRefactoryTestDataApp.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) directlyDefinesMethod: tmp2 first).  self executeRefactoring: tmp1.  self deny: ((tmp1 model classNamed: #RBRefactoryTestDataApp) directlyDefinesMethod: tmp2 first)transform  class removeInstanceVariable: variableName.  class subclasses do: [:arg1 |  arg1 addInstanceVariable: variableName ]primitiveExecute  self changeClass perform: self changeSymbol with: self changeObjectnumberOfSelfSendsIn: arg1  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: self messagePattern do: [:arg2 :arg3 |  arg3 + 1 ].  ^tmp1 executeTree: arg1 initialAnswer: 0testVariableDoesNotExist  self shouldFail: (RBRemoveAssignmentTransformation variable: 'variable1' value: '1 asString' inMethod: #methodBefore inClass: #RBRemoveAssignmentTransformationTest) asRefactoringast  ^self parseTreevariable: arg1 value: arg2 inMethod: arg3 inClass: arg4  self className: arg4.  selector := arg3.  variableName := arg1.  value := arg2defineSetterMethod  | tmp1 tmp2 |  tmp2 := '<1s> anObject<r><t><2s> := anObject'.  tmp1 := self safeMethodNameFor: self definingClass basedOn: variableName asString , ':'.  self definingClass compile: (tmp2 expandMacrosWith: tmp1 with: variableName) classified: #accessing.  ^tmp1checkInstVarsFor: arg1  class instanceVariableNames do: [:arg2 |  ((class whichSelectorsReferToInstanceVariable: arg2) includes: arg1) ifTrue: [ self refactoringError: ('<1p> refers to <2s> which is defined in <3p>' expandMacrosWith: arg1 with: arg2 with: class) ] ]selectors  ^Array streamContents: [:arg1 |  self classesDo: [:arg2 |  self selectorsForClass: arg2 do: [:arg3 |  arg1 nextPut: arg3 ] ] ]demoMethodWithDuplicates  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := 3.  tmp2 := tmp1 + 5.  tmp3 := tmp1 + tmp2.  tmp4 := tmp1 + 5.  tmp5 := tmp3 + tmp4 + (tmp1 + 5).  ^tmp5inlineLast  5 = 3 ifTrue: [ ^self caller ] ifFalse: [ ^self caller2 ]preconditions  | tmp1 tmp2 |  tmp2 := self parserClass parseMethod: source onError: [:arg1 :arg2 |  ^RBCondition withBlock: [ self refactoringFailure: 'The sources could not be parsed' ] ].  tmp1 := tmp2 selector.  tmp1 ifNil: [ self refactoringFailure: 'Invalid source.' ].  ^(RBCondition canUnderstand: tmp1 in: class) notrequestImplementorToInline: arg1  ^(self options at: #implementorToInline) value: self value: arg1removeClass  self model removeClassNamed: classNamecompiledMethodIn: arg1  ^[ arg1 >> newExtractedSelector ] on: Exception do: [ | tmp1 |        tmp1 := arg1 superclass.        tmp1 ifNil: [ ^nil ] ifNotNil: [ self compiledMethodIn: tmp1 ] ]valueIndex: arg1  selectedValueIndex := arg1.  self changed: #valueIndexpreconditions  ^RBCondition definesInstanceVariable: variableName in: classallClassVariableNames  ^self subclassResponsibilityvariableAssignedLiteral  temporaryVariable := #()release  self printStringwhichProtocolIncludes: arg1 in: arg2  ^arg2 organization categoryOfElement: arg1 ifAbsent: [ Protocol unclassified ]testMethodDoesNotExist  self shouldFail: (RBExtractMethodTransformation extract: 'bla' from: #checkClass1: to: #bla in: #RBBasicLintRuleTestData) asRefactoringconvertClasses: arg1 select: arg2 using: arg3  arg1 do: [:arg4 |  (arg2 value: arg4) do: [:arg5 |  arg4 convertMethod: arg5 using: arg3 ] ]buildMessageSearch  self createSearchWith: '``@receiver -> ``@arg' selectors: #(#superSends #superSends) inClass: RBTransformationRuleTestDatatestModelBadName  | tmp1 |  model := RBClassModelFactory rbNamespace new.  tmp1 := model classNamed: #Object.  tmp1 compile: 'aMethod: temp1 ^[| temp2 | temp2 := [:temp3 | temp3 = 5] value: 5. temp2] value' classified: #(#accessing).  self     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (20 to: 24) to: 'temp3' in: tmp1 selector: #aMethod:);     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (20 to: 24) to: 'temp1' in: tmp1 selector: #aMethod:)checkBrowseOccurrences: arg1  arg1 size = 1 ifTrue: [ ^self checkBrowseOccurrenceIn: arg1 first value ] ifFalse: [ ^self checkBrowseAllOccurences: arg1 ]copy: arg1 name: arg2  ^self duplicate: arg1 name: arg2 deep: truedefinition: arg1 controller: arg2  isMeta := false.  definition := arg1.  controller := arg2variable: arg1 value: arg2 inMethod: arg3 inClass: arg4  self className: arg4.  selector := arg3 asSymbol.  variableName := arg1 asSymbol.  value := arg2setupVariableToMoveToFor: arg1 toReturn: arg2  | tmp1 |  tmp1 := arg1 options copy.  tmp1 at: #selectVariableToMoveTo put: [:arg3 :arg4 :arg5 |  arg2 ].  arg1 options: tmp1testModelPushDownToMultipleSubclasses  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #AnotherSubclass) compile: 'bar ^foo' classified: #(#accessing).  self executeRefactoring: (RBPushDownInstanceVariableRefactoring model: model variable: 'foo' class: (model classNamed: #SomeClass)).  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #AnotherSubclass) directlyDefinesVariable: 'foo')testClassVariableInModel  | tmp1 |  (RBProtectVariableTransformation model: model classVariable: 'ClassVarName1' class: #Foo) asRefactoring transform.  tmp1 := (model classNamed: #Foo) theMetaClass.  self assert: (tmp1 parseTreeFor: #classVarName1) equals: (self parseMethod: 'classVarName1 ^ClassVarName1').  self assert: (tmp1 parseTreeFor: #classVarName1:) equals: (self parseMethod: 'classVarName1: anObject ClassVarName1 := anObject').  self assert: (tmp1 parseTreeFor: #foo) equals: (self parseMethod: 'foo				^self classVarName1: self classVarName1 * self classVarName1 * self classVarName1').  self assert: (tmp1 theNonMetaClass parseTreeFor: #classVarName1) equals: (self parseMethod: 'classVarName1 ^self class classVarName1').  self assert: (tmp1 theNonMetaClass parseTreeFor: #classVarName1:) equals: (self parseMethod: 'classVarName1: anObject				^self class classVarName1: anObject')testTransform  | tmp1 tmp2 |  tmp1 := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  tmp1 := (RBRemoveTemporaryVariableTransformation model: tmp1 model variable: 'temp' inMethod: #foo inClass: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: self changeMock name.  self assert: (tmp2 directlyDefinesMethod: #one).  self assert: (tmp2 parseTreeFor: #foo) temporaries size equals: 1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' variable: '.  variableName storeOn: arg1.  arg1 nextPutAll: ' class: '.  class storeOn: arg1.  arg1 nextPut: $)initializeDialogWindow: arg1  arg1     initialExtent: 700 @ 500;     addButton: 'Cancel' do: cancelAction;     addButton: 'Replace' do: [:arg2 |  self accept: arg2 ];     addButton: 'Skip' do: skipAction;     addButton: 'Replace all' do: replaceAllActionresult: arg1  result := arg1 copyEmptyremoveInstanceVariable: arg1 from: arg2  ^self addChange: (changeFactory removeInstanceVariable: arg1 from: arg2)buildTransformations  ^OrderedCollection with: (RBAddVariableAccessorTransformation model: self model variable: variableName asString class: className classVariable: isClassVariable) with: (RBRemoveDirectAccessToVariableTransformation model: self model variable: variableName asString class: className classVariable: isClassVariable)executeShould: arg1 inScopeOf: arg2 withDescriptionContaining: arg3  ^[ arg1 value.  false ] on: arg2 do: [:arg4 |  arg4 return: (arg4 description includesSubstring: arg3) ]minMax  ^3 < 5 ifTrue: [ 3 ] ifFalse: [ 5 ]testRemoveInstanceVariable  | tmp1 |  tmp1 := changes removeInstanceVariable: 'instVar' from: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 variable equals: 'instVar'.  self universalTestFor: tmp1withClassesFixedForNautilus  instanceVariables ifEmpty: [ classVariables keysAndValuesDo: [:arg1 :arg2 |  instanceVariables at: arg1 ifAbsentPut: [ Set new ] ] ]testClassVariable  | tmp1 tmp2 |  tmp1 := (RBPushDownVariableTransformation classVariable: #Foo1 class: #RBDummyLintRuleTest) asRefactoring.  tmp2 := tmp1 model classNamed: #RBDummyLintRuleTest.  self assert: (tmp2 directlyDefinesClassVariable: #Foo1).  tmp1 transform.  tmp2 withAllSubclasses do: [:arg1 |  self deny: (arg1 directlyDefinesClassVariable: #Foo1) ]processCollectionFor: arg1 messagesTo: arg2 in: arg3  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: arg2 , ' `@message: ``@args' do: [:arg4 :arg5 |  self processCollectionMessagesFor: arg1 in: arg4.        arg5           add: arg4 selector;           yourself ].  tmp1 executeTree: arg3 initialAnswer: (variableMessages at: (self collectionNameFor: arg1) ifAbsentPut: [ Set new ])testAlreadyDefinesReturn  self shouldFail: (RBAddReturnStatementTransformation return: '^ variable' inMethod: #methodAfter inClass: #RBAddReturnStatementTransformationTest) asRefactoringsourceCode: arg1 in: arg2 withProtocol: arg3  self className: arg2.  sourceCode := arg1.  protocol := arg3 asSymboljustSendsSuper: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self parseTreeSearcherClass justSendsSuper.  tmp2 := class parseTreeFor: arg1.  (tmp1 executeTree: tmp2 initialAnswer: false) ifFalse: [ ^false ].  tmp2 lastIsReturn ifTrue: [ ^true ].  tmp3 := class superclass whichClassIncludesSelector: arg1.  tmp3 ifNil: [ ^true ].  tmp2 := tmp3 parseTreeFor: arg1.  tmp1 := self parseTreeSearcher.  tmp1 matches: '^``@object' do: [:arg2 :arg3 |  arg3           add: arg2 value;           yourself ].  tmp1 executeTree: tmp2 initialAnswer: Set new.  ^(tmp1 answer anySatisfy: [:arg4 |  arg4 isSelf not ]) notasUndoOperation  | tmp1 |  tmp1 := onSystemDictionary classOrTraitNamed: self changeClassName.  ^tmp1 isTrait ifTrue: [ changeFactory addTraitDefinition: tmp1 oldDefinition ] ifFalse: [ changeFactory removeClassNamed: self changeClassName ]getExtractedSource  | tmp1 |  tmp1 := class sourceCodeFor: selector.  ((extractionInterval first between: 1 and: tmp1 size) and: [ extractionInterval last between: 1 and: tmp1 size ]) ifFalse: [ self refactoringFailure: 'Invalid interval' ].  ^tmp1 copyFrom: extractionInterval first to: extractionInterval lastinlineTemporary  | tmp1 |  self isNil ifTrue: [ tmp1 := 4 ].  ^tmp1selectedClass: arg1  class := model classFor: arg1includesProtocol: arg1 in: arg2  ^(self selectorsFor: arg1 in: arg2) isNotEmptystoreOn: arg1  arg1 nextPut: $(.  environment storeOn: arg1.  arg1 nextPutAll: ' | '.  orEnvironment storeOn: arg1.  arg1 nextPut: $)selector  ^selectordelegatesPreconditions: arg1  delegatesPreconditions := arg1copyOldValuesToNewVariable  self subclassResponsibilityremoveDefinedClassVariables  | tmp1 tmp2 |  tmp2 := fromClass instanceSide.  tmp1 := [:arg1 |  (toClasses detect: [:arg2 |  (arg2 instanceSide includesClass: (tmp2 whoDefinesClassVariable: arg1)) not ] ifNone: [ nil ]) notNil ].  classVarReaders := classVarReaders select: tmp1.  classVarWriters := classVarWriters select: tmp1inline: arg1 inMethod: arg2 forClass: arg3  sourceSelector := arg2.  class := self classObjectFor: arg3.  sourceInterval := arg1assignmentInIfTrue  | tmp1 |  self isVariable ifTrue: [ tmp1 := self ] ifFalse: [ tmp1 := self printString ].  ^tmp1modifyImplementorParseTree: arg1 in: arg2  | tmp1 |  tmp1 := arg1 arguments.  arg1 renameSelector: newSelector andArguments: (permutation collect: [:arg3 |  tmp1 at: arg3 ])testTransform  | tmp1 tmp2 tmp3 |  tmp2 := (self changeMock name , 'Temporary') asSymbol.  tmp1 := RBCustomTransformation with: [:arg1 |  arg1 defineClass: ('<1p> subclass: #<2s>				instanceVariableNames: ''''				classVariableNames: ''''				poolDictionaries: ''''				category: <3p>' expandMacrosWith: 'Object' with: tmp2 with: self class category).        (arg1 classNamed: tmp2) comment: 'Deprecated!!! Use super class'.        (arg1 classNamed: tmp2) addInstanceVariable: 'asdf' ].  tmp1 transform.  self assert: tmp1 model changes changes size equals: 3.  tmp3 := tmp1 model classNamed: (self changeMock name , 'Temporary') asSymbol.  self assert: (tmp3 directlyDefinesInstanceVariable: 'asdf')testNonExistantName  self shouldFail: (RBPushDownClassVariableRefactoring variable: #Foo class: RBBasicLintRuleTestData)isSystem  ^truetestReferencedVariable  self shouldFail: (RBRemoveClassVariableRefactoring variable: #RecursiveSelfRule class: RBTransformationRuleTestData)testExtractMethodAtEndOfMethodThatNeedsReturn  | tmp1 tmp2 |  tmp1 := RBExtractMethodRefactoring extract: (52 to: 133) from: #openEditor in: RBLintRuleTestData.  self setupMethodNameFor: tmp1 toReturn: #foo:.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self assert: (tmp2 parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor	| rules |	rules := self failedRules.	^self foo: rules').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: rules	rules isEmpty ifTrue: [^self].	rules size == 1 ifTrue: [^rules first viewResults]')printOn: arg1  arg1     nextPutAll: self displayClassName;     nextPutAll: ' classCategory: ';     print: self displayCategoryName;     nextPutAll: ' stamp: ';     print: self changeStamp;     nextPutAll: '!'errorStringFor: arg1  ^arg1 ifTrue: [ self neitherFailed ] ifFalse: [ self perform: failed ]testTransform  | tmp1 tmp2 |  tmp1 := (RBSplitClassTransformation class: #RBRemoveDirectAccessToVariableTransformation instanceVariables: #(receiver) newClassName: #RBRemoveDirectAccessWithReceiverTransformation referenceVariableName: #newReceiver) transform.  tmp2 := tmp1 model classNamed: #RBRemoveDirectAccessToVariableTransformation.  self deny: (tmp2 instanceVariableNames includes: #receiver).  self assert: (tmp2 instanceVariableNames includes: #newReceiver).  self assert: (tmp2 parseTreeFor: #receiver:) equals: (self parseMethod: 'receiver: aString					newReceiver receiver: aString').  self assert: (tmp2 parseTreeFor: #receiver) equals: (self parseMethod: 'receiver					^ newReceiver receiver 						ifNil: [ self receiver: ' , 'self' surroundedBySingleQuotes , '. newReceiver receiver ]').  tmp2 := tmp1 model classNamed: #RBRemoveDirectAccessWithReceiverTransformation.  self deny: tmp2 isNil.  self assert: (tmp2 instanceVariableNames includes: #receiver).  self assert: (tmp2 directlyDefinesLocalMethod: #receiver).  self assert: (tmp2 directlyDefinesLocalMethod: #receiver:)sourceCodeAt: arg1 forMethod: arg2 in: arg3  ^(arg3 sourceCodeAt: arg2) copyFrom: arg1 first to: arg1 lastshouldnt: arg1 raise: arg2  ^self assert: (self executeShould: arg1 inScopeOf: arg2) notreceiver  ^receiver ifNil: [ self receiver: 'self'.        receiver ]create: arg1 name: arg2  ^self duplicate: arg1 name: arg2 deep: falseprotocolsFor: arg1  ^arg1 organization categories select: [:arg2 |  self includesProtocol: arg2 in: arg1 ]addClass: arg1 superclass: arg2 subclasses: arg3 category: arg4  self className: arg1.  superclass := self classObjectFor: arg2.  subclasses := arg3 collect: [:arg5 |  self classObjectFor: arg5 ].  category := arg4testMatches  | tmp1 tmp2 |  tmp1 := RBBrowserEnvironment new matches: '*env*'.  tmp2 := RBBrowserEnvironment new referencesTo: #environment.  self assert: (tmp1 referencesTo: #environment) numberSelectors equals: tmp2 numberSelectorstestPerformCompositeChange  changes     compile: 'method1 ^ 1' in: self changeMock;     compile: 'method2 ^ 2' in: self changeMock.  self perform: changes do: [ self assert: (self changeMock canUnderstand: #method1).        self assert: (self changeMock canUnderstand: #method2) ].  self deny: (self changeMock canUnderstand: #method1).  self deny: (self changeMock canUnderstand: #method2)problemCount  ^environmentDictionaries sizestoreOn: arg1  arg1 nextPutAll: self nameremoveSubtree: arg1 in: arg2  ^[ self parseTreeRewriterClass replaceStatements: arg1 formattedCode with: '' in: arg2 onInterval: arg1 sourceInterval ] on: Error do: [ self parseTreeRewriterClass replace: arg1 formattedCode with: '' in: arg2 onInterval: arg1 sourceInterval ]transform  self computePoolsToMove.  self hasPoolsToMove ifTrue: [ self refactoringWarning: 'This method contains references to pools<n>which may need to be moved.' expandMacros ].  self movePoolVariablescheckMethod: arg1  testRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddReturnStatementTransformation return: '^ variable' inMethod: #methodBefore inClass: #RBAddReturnStatementTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBAddReturnStatementTransformationTest.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyselector  ^selectortestBadSourceCode  self shouldFail: (RBAddMethodTransformation sourceCode: 'asdf ^super ^printString' in: RBBasicLintRuleTestData withProtocol: #accessing) asRefactoringerrorBlockFor: arg1  ^nilrenderContentOn: arg1  arg1 form: [ arg1 text: 'Name:'.        arg1 textInput on: #name of: self contact.        arg1 break.        arg1 text: 'Email address:'.        arg1 textInput on: #emailAddress of: self contact.        arg1 break.        arg1 text: 'Example:'.        arg1 textInput on: #example of: self contact.        arg1 break ].  arg1 text: 'Last:'.  arg1 textInput on: #last of: self contact.  arg1 breakpreconditions  ^RBCondition emptyexampleClasses  < sampleInstance>  ^{ProtoObject .   Object .   Class .   Metaclass .   Behavior .   ClassDescription .   Dictionary .   Trait .   SmalltalkImage}inlineComponent  | tmp1 |  tmp1 := 5.  ^tmp1 class     superclass;     hasImmediateInstances;     yourselfrenameAccessors  ^renameAccessorsstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' protocol: ''';     nextPutAll: protocol;     nextPutAll: ''' inClass: ''';     nextPutAll: className.  arg1 nextPut: $)selfMessages  ^self parseTree selfMessagesinitialize  super initialize.  name := #'Unknown Class'computeLiteralsForClass: arg1  (selectors addAll: arg1 selectors) do: [:arg2 |  self computeLiteralsForSelector: arg2 in: arg1.        Processor yield ]shouldFail: arg1  self proceedThroughWarning: [ self should: [ self executeRefactoring: arg1 ] raise: RBRefactoringError ]preconditions  ^(RBCondition withBlock: [ deprecatedClass notNil and: [ deprecatedClass isMeta not ] ]) & (RBCondition isValidClassName: newName) & (RBCondition isGlobal: newName in: self model) | (RBCondition withBlock: [ self refactoringFailure: newName , ' is not a valid class name' ])addMethodSource: arg1 in: arg2 classified: arg3  ^RBAddMethodChange compile: arg1 in: arg2 classified: arg3testRemoveAClassAndTheirSubclass  | tmp1 |  tmp1 := RBRemoveClassRefactoring classNames: {#RBSharedPoolForTestData1 .         #RBSharedPoolForTestData2}.  self executeRefactoring: tmp1.  self assert: (tmp1 model classNamed: #RBSharedPoolForTestData2) isNil.  self assert: (tmp1 model classNamed: #RBSharedPoolForTestData1) isNilclassesAndSelectorsDo: arg1  self classesDo: [:arg2 |  self selectorsForClass: arg2 do: [:arg3 |  arg1 value: arg2 value: arg3 ] ]removeClass: arg1 selector: arg2  (arg1 isMeta ifTrue: [ metaClassSelectors at: arg1 soleInstance name ifAbsent: [ ^self ] ] ifFalse: [ classSelectors at: arg1 name ifAbsent: [ ^self ] ]) remove: arg2 ifAbsent: [  ]compositeRefactoryChange  ^RBCompositeRefactoryChange newcollectionProtocol  | tmp1 |  tmp1 := OrderedCollection new.  (1 to: 10) asOrderedCollection do: [:arg1 |  | tmp2 |        tmp2 := arg1 * 2.        tmp1 add: tmp2 ].  ^tmp1changeClass: arg1  super changeClass: arg1.  isMeta := falsecheckMethod: arg1  ^methodBlock value: arg1 value: resultremoveExtensionMethods  (self instanceSideExtensionMethodsOf: deprecatedClass) do: [:arg1 |  deprecatedClass instanceSide removeMethod: arg1 selector ].  (self classSideExtensionMethodsOf: deprecatedClass) do: [:arg1 |  deprecatedClass classSide removeMethod: arg1 selector ]checkMethod: arg1  ^methodBlock value: arg1 value: resultdefinedSelector  ^definedSelectorselectorsToPushUpFrom: arg1  | tmp1 |  tmp1 := self computeSubclassSupersOf: arg1.  ^arg1 selectors select: [:arg2 |  (tmp1 includes: arg2) or: [ self shouldPushUp: arg2 from: arg1 ] ]caller2  ^(1 to: 10) inject: 1 into: [:arg1 :arg2 |  arg1 * (self foo: arg2) ]className: arg1 newName: arg2  className := arg1 asSymbol.  class := self model classNamed: className.  newName := arg2 asSymbolpreconditionIsNotMetaclass: arg1  ^((RBCondition isMetaclass: arg1) errorMacro: 'Cannot remove just the metaclass') notprintOn: arg1  name ifNil: [ super printOn: arg1 ] ifNotNil: [ arg1 nextPutAll: name ]unaryNonAccessingBranchingStatementMethodWithoutReturn  self value isString ifTrue: [ self value ] ifFalse: [ '' ]initialize  super initialize.  categories := IdentitySet newshouldExtractAssignmentTo: arg1  ^(self options at: #extractAssignment) value: self value: arg1should: arg1 notTakeMoreThan: arg2  ^arg1 valueWithin: arg2 onTimeout: [ self assert: false description: [ 'Block evaluation took more than the expected <1p>' expandMacrosWith: arg2 ] ]testVariableDoesNotExist  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  self     shouldFail: (RBPushDownVariableTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBPushDownVariableTransformation model: model classVariable: #Foo class: (model classNamed: #SomeClass)) asRefactoring;     shouldFail: (RBPushDownVariableTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoringtransform  self     copyDownMethods;     pullUpMethods;     removePulledUpMethods;     removeDuplicateMethodsinitialize  super initialize.  arguments := 0.  temporaries := 0.  difference := 0preconditions  | tmp1 |  tmp1 := (RBCondition withBlock: [ newSelector = oldSelector ] errorString: 'The selector name has <1?not:> changed <1?:to #' , newSelector , '>') & (RBCondition withBlock: [ permutation asArray ~= (1 to: oldSelector numArgs) asArray ] errorString: 'The arguments are <1?:not >permuted').  ^tmp1 | super preconditionsparseMethod: arg1  ^self parserClass parseMethod: arg1variable: arg1 class: arg2 classVariable: arg3  variableName := arg1.  isClassVariable := arg3.  className := arg2sendsDifferentSuper  super printStringvalues  ^valuesList ifNil: [ valuesList := values asOrderedCollection ]findReceiverNode  | tmp1 |  tmp1 := statementNodes collect: [:arg1 |  arg1 receiver ].  tmp1 asSet size = 1 ifFalse: [ self refactoringError: 'All statements must have the same receiver' ].  (tmp1 first isLiteralNode or: [ tmp1 first isVariable ]) ifFalse: [ self refactoringWarning: 'The receiver is an expression. Proceed with caution' ]directlyDefinesClassVariable: arg1  ^self classVariableNames includes: arg1 asSymbolpreconditionChecking  ^preconditionCheckinghasConflicts  ^falsetestRemoveClassVariable  | tmp1 tmp2 |  tmp1 := (RBRemoveVariableTransformation classVariable: 'Foo1' class: #RBDummyLintRuleTest) asRefactoring.  tmp2 := tmp1 model classNamed: #RBDummyLintRuleTest.  self assert: (tmp2 definesClassVariable: 'Foo1').  tmp1 transform.  self deny: (tmp2 definesClassVariable: 'Foo1')storeOn: arg1  arg1     nextPut: $(;     nextPutAll: self class name;     nextPutAll: ' new '.  self accessorMethods do: [:arg2 |  arg1           nextPutAll: arg2;           nextPutAll: ': '.        (self perform: arg2) storeOn: arg1.        arg1 nextPutAll: '; ' ].  arg1 nextPutAll: 'yourself)'hasMultipleReturns  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: '^``@object' do: [:arg1 :arg2 |  arg2 ifTrue: [ ^true ].        true ].  tmp1 executeTree: inlineParseTree initialAnswer: inlineParseTree lastIsReturn not.  ^falseinterval: arg1 with: arg2 from: arg3 in: arg4  self className: arg4.  selector := arg3.  interval := arg1.  sourceCode := arg2whichCategoryIncludes: arg1  ^self environment whichCategoryIncludes: arg1preconditions  | tmp1 |  tmp1 := RBCondition referencesInstanceVariable: variableName in: class.  class realClass ifNil: [ tmp1 errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName) ] ifNotNil: [ tmp1           errorMacro: ('<1s> is referenced.<n>Browse references?' expandMacrosWith: variableName);           errorBlock: [ self openBrowserOn: (RBBrowserEnvironment new instVarRefsTo: variableName in: class realClass) ] ].  ^(RBCondition definesInstanceVariable: variableName in: class) & tmp1 notparseExpression: arg1  ^self parserClass parseExpression: arg1testClassDoesNotExist  self shouldFail: (RBRemoveReturnStatementTransformation return: '^ variable' inMethod: #methodBefore inClass: #RBReturnStatementTransformationTest) asRefactoringisSystem  ^falseprivateTransform  self model selector: self definingMethod selector in: self definingClass classified: self protocoltestTransform  | tmp1 tmp2 |  tmp1 := (RBAddReturnStatementTransformation new return: '^ variable' inMethod: #methodBefore inClass: self class name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodydeprecateMethod: arg1 in: arg2 using: arg3  oldSelector := arg1.  newSelector := arg3.  class := self classObjectFor: arg2testRemoveNonExistantMethod  self shouldFail: (RBRemoveHierarchyMethodRefactoring removeMethods: #(#msg7) from: RBBasicLintRuleTestData)testBadInterval  self     shouldFail: (RBExtractMethodRefactoring extract: (24 to: 30) from: #testMethod in: RBRefactoryTestDataApp);     shouldFail: (RBExtractMethodRefactoring extract: (80 to: 147) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class)methodBefore  | tmp1 |  tmp1 := 'String'.  ^tmp1classSideExtensionMethodsOf: arg1  ^arg1 realClass classSide localMethods select: #isExtension thenCollect: [:arg2 |  arg1 classSide methodFor: arg2 selector ]addInstanceVariables  instanceVariables collect: [:arg1 |  RBAddVariableTransformation model: self model instanceVariable: arg1 class: newClassName ] thenDo: [:arg2 |  transformations add: arg2 ]oldVersionTextToDisplay  ^String streamContents: [:arg1 |  arg1           nextPutAll: '"protocol: ';           nextPutAll: self oldProtocol;           nextPutAll: '"';           nextPutAll: String cr;           nextPutAll: super oldVersionTextToDisplay ]inlineMethod  | tmp1 |  tmp1 := self     foo;     inlineMethod;     bar.  ^tmp1findCascadeNode  cascadeNode := self parseTree bestNodeFor: selectedInterval.  [ cascadeNode isNil or: [ cascadeNode isCascade ] ] whileFalse: [ cascadeNode := cascadeNode parent ].  cascadeNode ifNil: [ self refactoringFailure: 'The selection doesn''t appear to be within a cascade' ]msg4  ^Var1requestSelfArgumentName  ^(self options at: #selfArgumentName) value: selfdirectlyDefinesPoolDictionary: arg1  ^self sharedPoolNames includes: arg1 asSymbolextract: arg1 of: arg2 executing: arg3  | tmp1 tmp2 |  tmp1 := self extractMethodRefactoring.  tmp2 := arg1 asOrderedCollection at: positionIndex.  tmp1 extract: tmp2 key from: arg2 selector in: arg2 origin.  tmp1 setOption: #existingSelector toUse: [:arg4 |  arg4 parameters: (self argumentsOf: tmp2 value).        method selector ].  tmp1 perform: arg3.  ^tmp1checkMethod: arg1  rules do: [:arg2 |  arg2 checkMethod: arg1.        Processor yield ]privateSelectorsForClass: arg1  ^arg1 isMeta ifTrue: [ metaClassSelectors at: arg1 soleInstance name ifAbsent: [ #() ] ] ifFalse: [ classSelectors at: arg1 name ifAbsent: [ #() ] ]initialize  super initialize.  preconditionChecking := falsedetectContains  ^(1 to: 10) do: [:arg1 |  arg1 > 2 ifTrue: [ ^arg1 ] ]classesDo: arg1  classes do: [:arg2 |  | tmp1 |        tmp1 := self systemDictionary at: arg2 ifAbsent: [ nil ].        (tmp1 notNil and: [ environment includesClass: tmp1 ]) ifTrue: [ arg1 value: tmp1 ] ].  metaClasses do: [:arg2 |  | tmp1 |        tmp1 := self systemDictionary at: arg2 ifAbsent: [ nil ].        (tmp1 notNil and: [ environment includesClass: tmp1 classSide ]) ifTrue: [ arg1 value: tmp1 classSide ] ]definesClass: arg1  ^(super definesClass: arg1) and: [ categories includes: arg1 instanceSide category ]checkTemporaries  | tmp1 tmp2 tmp3 |  tmp1 := self remainingTemporaries.  tmp2 := tmp1 select: [:arg1 |  extractedParseTree references: arg1 ].  tmp3 := tmp2 select: [:arg1 |  extractedParseTree assigns: arg1 ].  tmp3 ifNotEmpty: [ self checkAssignments: tmp3 ].  ^parameters := tmp2 asOrderedCollection     removeAll: tmp3;     yourselftestVariableEnvironmentAddRemove  | tmp1 |  tmp1 := RBVariableEnvironment new.  tmp1 addClass: self class instanceVariable: 'universalEnvironment'.  self assert: tmp1 numberSelectors > 0.  self assert: tmp1 numberClasses equals: 1.  tmp1 removeClass: self class instanceVariable: 'universalEnvironment'.  self assert: tmp1 numberSelectors equals: 0.  self assert: tmp1 numberClasses equals: 0.  tmp1 addClass: self class instanceVariableReader: 'universalEnvironment'.  self assert: tmp1 numberSelectors > 0.  self assert: tmp1 numberClasses equals: 1.  tmp1 removeClass: self class instanceVariableReader: 'universalEnvironment'.  self assert: tmp1 numberSelectors equals: 0.  self assert: tmp1 numberClasses equals: 0.  tmp1 addClass: self class instanceVariableWriter: 'universalEnvironment'.  self assert: tmp1 numberSelectors > 0.  self assert: tmp1 numberClasses equals: 1.  tmp1 removeClass: self class instanceVariableWriter: 'universalEnvironment'.  self assert: tmp1 numberSelectors equals: 0.  self assert: tmp1 numberClasses equals: 0.  tmp1 addClass: self class classVariable: 'ClassVariable'.  self assert: tmp1 numberSelectors > 0.  self assert: tmp1 numberClasses equals: 1.  tmp1 removeClass: self class classVariable: 'ClassVariable'.  self assert: tmp1 numberSelectors equals: 0.  self assert: tmp1 numberClasses equals: 0haltClassMentioned  Halt nowconvertMethod: arg1 using: arg2  | tmp1 |  tmp1 := self parseTreeFor: arg1.  tmp1 ifNil: [ ^self ].  (arg2 executeTree: tmp1) ifTrue: [ self compileTree: arg2 tree ]formOldName  ^self formNameFor: oldSelectorincludesCategory: arg1  ^environment includesCategory: arg1subclassesDo: arg1  self subclasses do: arg1extract: arg1 to: arg2 from: arg3 in: arg4  class := self classObjectFor: arg4.  selector := arg3.  sourceInterval := arg1.  newVariableName := arg2exampleCall  < sampleInstance>  ^self rename: 1 two: 2needsReturnForSetter  needsReturn ifNil: [ needsReturn := self usesAssignmentOf: variableName in: class classVariable: classVariable ].  ^needsReturnclassVariableReader  ^ClassVariablevariables: arg1  variables := arg1isComposite  ^falsetestWithArgument  | tmp1 tmp2 |  tmp1 := (RBExtractMethodTransformation extract: (self sourceCodeAt: (145 to: 343) forMethod: #checkMethod: in: RBTransformationRuleTestData) from: #checkMethod: to: #foo: in: #RBTransformationRuleTestData) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 					class := aSmalllintContext selectedClass.					(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 						[self foo: aSmalllintContext]').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: aSmalllintContext					(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)						ifFalse: 							[builder compile: rewriteRule tree printString										in: class										classified: aSmalllintContext protocols]')check: arg1 forCritiquesDo: arg2 ifNone: arg3  | tmp1 |  tmp1 := false.  self check: arg1 forCritiquesDo: [:arg4 |  tmp1 := true.        arg2 cull: arg4 ].  tmp1 ifFalse: arg3noMoveDefinition  | tmp1 |  ^(self collect: [:arg1 |  tmp1 := arg1 printString.        tmp1 , tmp1 ]) select: [:arg1 |  tmp1 := arg1 size + tmp1 ]testVariableEnvironmentInstVars  | tmp1 tmp2 tmp3 tmp4 |  self timeLimit: 300 seconds.  tmp1 := RBVariableEnvironment referencesToInstanceVariable: 'universalEnvironment' in: self class.  tmp2 := RBVariableEnvironment writersOfInstanceVariable: 'universalEnvironment' in: self class.  tmp3 := RBVariableEnvironment readersOfInstanceVariable: 'universalEnvironment' in: self class.  tmp4 := RBVariableEnvironment referencesToClassVariable: 'ClassVariable' in: self class.  self universalTestFor: tmp1.  self universalTestFor: tmp2.  self universalTestFor: tmp3.  self universalTestFor: tmp4.  self deny: universalEnvironment isVariableEnvironment.  self assert: tmp1 isVariableEnvironment.  self assert: tmp1 numberSelectors equals: (tmp2 | tmp3) numberSelectorschangeForMetaclass: arg1 selector: arg2  ^(isMeta and: [ self selector = arg2 and: [ className = arg1 ] ]) ifTrue: [ self ] ifFalse: [ nil ]includesSelector: arg1 in: arg2  ^(super includesSelector: arg1 in: arg2) and: [ protocols includes: (environment whichProtocolIncludes: arg1 in: arg2) ]initialize  super initialize.  matchers := OrderedCollection new