isEmpty  ^protocols isEmptystoreOn: arg1  arg1     nextPutAll: '(';     nextPutAll: self class name;     nextPutAll: ' onEnvironment: '.  environment storeOn: arg1.  arg1 nextPut: $)resetResult  result := result copyEmpty.  result label: namesource  ^source ifNil: [ super oldVersionTextToDisplay ]allPoolDictionaryNames  ^self instanceSide allPoolDictionaryNamescontains  ^((1 to: 10) detect: [:arg1 |  arg1 > 2 ] ifNone: [ nil ]) isNilmethodAfter  | tmp1 |  tmp1 := 'String'transform  self abstractVariableReferences.  self renameSelfReferences.  super transformname  ^name ifNil: [ self changeString ] ifNotNil: [ name ]visitSequenceNode: arg1  | tmp1 tmp2 |  tmp1 := arg1 statements collect: [:arg2 |  arg2 start ].  tmp2 := arg1 statements collect: [:arg2 |  arg2 stop ].  tmp1 do: [:arg3 |  tmp2 do: [:arg4 |  arg3 < arg4 ifTrue: [ combinations add: (Array with: arg3 with: arg4) ] ] ].  super visitSequenceNode: arg1testRefactoring  | tmp1 tmp2 |  self assert: self class category equals: #'Refactoring2-Transformations-Tests'.  tmp1 := (RBMoveClassTransformation move: self class name to: #'Refactoring2-Transformations-Utilities') asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: tmp2 category equals: #'Refactoring2-Transformations-Utilities'messageSend: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  message := arg1transform  selectors do: [:arg1 |  self pushDown: arg1 ].  selectors do: [:arg1 |  class removeMethod: arg1 ]stringConcatenation  | tmp1 |  tmp1 := '' yourself.  (1 to: 10) do: [:arg1 |  tmp1 := tmp1 , arg1 printString ].  ^tmp1testVariableDoesNotExist  self     shouldFail: (RBProtectVariableTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBProtectVariableTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoringadd  | tmp1 |  tmp1 := self argumentList.  tmp1 add: 'arg' , (tmp1 size + 1) asString.  self methodName arguments: tmp1.  self updatepreconditions  ^(RBCondition isMetaclass: class) not & (RBCondition isValidClassVarName: variableName for: class) & (RBCondition hierarchyOf: class definesVariable: variableName asString) not & (RBCondition isGlobal: variableName in: self model) notimplementors  implementors ifNil: [ implementors := self model allImplementorsOf: oldSelector ].  ^implementorsisClassEnvironment  ^trueinitialize  super initialize.  self createClassesvariableAssignedLiteral  temporaryVariable := #()createSearchWith: arg1 selectors: arg2 inClass: arg3  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: arg1 do: [:arg4 :arg5 |  arg5           remove: self currentSelector ifAbsent: [ self error: 'failed' ];           yourself ].  tmp1 answer: arg2 asBag.  (classSearches at: arg3 ifAbsentPut: [ Set new ]) add: tmp1preconditions  ^self refactorings inject: RBCondition empty into: [:arg1 :arg2 |  arg1 & arg2 preconditions ]filteredResult  | tmp1 |  result ifEmpty: [ ^result ].  tmp1 := RBPragmaEnvironment onEnvironment: RBBrowserEnvironment new keywords: #(lint: #lint:rationale: #lint:rationale:author: #lint:author: ignoreLintRule: #ignoreLintRule:rationale: #ignoreLintRule:rationale:author: #ignoreLintRule:author:).  tmp1 condition: [:arg1 |  arg1 arguments first = self name or: [ arg1 arguments first = self group or: [ arg1 arguments first = self class name ] ] ].  result isSelectorEnvironment ifTrue: [ ^result & tmp1 not label: result label ].  result isClassEnvironment ifTrue: [ tmp1 classesDo: [:arg2 |  result                 removeClass: arg2 classSide;                 removeClass: arg2 instanceSide ] ] ifFalse: [ result isVariableEnvironment ifTrue: [ tmp1 classesDo: [:arg2 |  arg2 classVarNames do: [:arg3 |  result removeClass: arg2 classVariable: arg3 ].                    arg2 instVarNames do: [:arg3 |  result removeClass: arg2 instanceVariable: arg3 ] ] ] ].  ^resulttestClassDoesNotExist  self shouldFail: (RBAddReturnStatementTransformation return: '^ variable' inMethod: #methodBefore inClass: #RBReturnStatementTransformationTest) asRefactoringaddInstanceVariable: arg1 to: arg2  ^self addChange: (changeFactory addInstanceVariable: arg1 to: arg2)testInstanceVariable  | tmp1 |  tmp1 := (RBPushDownVariableTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  (tmp1 model classNamed: #RBDummyLintRuleTest) subclasses do: [:arg1 |  self assert: (arg1 directlyDefinesInstanceVariable: 'foo1') ]hasConflicts  ^(rules detect: [:arg1 |  arg1 hasConflicts ] ifNone: [ nil ]) notNilremoveMethod: arg1 from: arg2  self flushCaches.  ^changes removeMethod: arg1 from: arg2checkBrowseAllOccurences: arg1  | tmp1 tmp2 |  tmp1 := arg1 collect: [:arg2 |  arg2 key ] as: Set.  tmp2 := arg1 collect: [:arg3 |  arg3 value ].  tmp1 size = 1 ifTrue: [ self refactoringError: ('Possible call to <2s> in <1p> methods.<n>Browse references?' expandMacrosWith: arg1 size with: tmp1 anyOne) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: tmp1 anyOne) ] ] ifFalse: [ self refactoringError: ('Possible call to the <2p> selectors in <1p> methods.<n>Browse references?' expandMacrosWith: tmp2 size with: tmp1 size) with: [ | tmp3 |              tmp3 := RBSelectorEnvironment new.              tmp2 do: [:arg4 |  tmp3 addMethod: arg4 method ].              self openBrowserOn: tmp3 ] ]definesClass: arg1  ^arg1 == class and: [ super definesClass: arg1 ]checkReturn  needsReturn := self placeholderNode isUsed.  extractedParseTree containsReturn ifFalse: [ ^self ].  extractedParseTree lastIsReturn ifTrue: [ ^self ].  (modifiedParseTree isLast: self placeholderNode) ifFalse: [ self refactoringError: 'Couldn''t extract code since it contains a return.' ].  self checkSelfReturnsargumentIndex  ^selectedArgumentIndex ifNil: [ selectedArgumentIndex := 0 ]usesAssignmentOf: arg1 in: arg2 classVariable: arg3  | tmp1 tmp2 |  tmp1 := self parseTreeSearcher.  tmp1     answer: false;     matches: arg1 , ' := ``@object' do: [:arg4 :arg5 |  arg5 or: [ arg4 isUsed and: [ arg4 methodNode selector ~= arg1 ] ] ].  tmp2 := arg3 ifTrue: [ arg2 instanceSide ] ifFalse: [ arg2 ].  ^tmp2 withAllSubclasses , (arg3 ifTrue: [ tmp2 classSide withAllSubclasses ] ifFalse: [ #() ]) anySatisfy: [:arg6 |  (arg3 ifTrue: [ arg6 whichSelectorsReferToClassVariable: arg1 ] ifFalse: [ arg6 whichSelectorsReferToInstanceVariable: arg1 ]) anySatisfy: [:arg7 |  self checkClass: arg6 selector: arg7 using: tmp1 ] ]hasPermutedArguments  oldSelector numArgs = newSelector numArgs ifFalse: [ ^true ].  1 to: oldSelector numArgs do: [:arg1 |  (permutation at: arg1) = arg1 ifFalse: [ ^true ] ].  ^falseisEmpty  self classesDo: [:arg1 |  ^false ].  ^truetransform  self     replaceAssignment;     replaceReferences;     compileMethodwhatToDisplayIn: arg1  ^(self changes changes select: [:arg2 |  selector = arg2 selector ]) flatCollect: [:arg2 |  arg2 whatToDisplayIn: arg1 ]environment: arg1  environment := arg1testInlineMethod  | tmp1 |  tmp1 := RBInlineMethodRefactoring inline: (455 to: 504) inMethod: #sentNotImplementedInApplication forClass: RBBasicLintRuleTestData class.  self executeRefactoring: tmp1.  self assert: ((tmp1 model metaclassNamed: #RBBasicLintRuleTestData) parseTreeFor: #sentNotImplementedInApplication) equals: (self parseMethod: 'sentNotImplementedInApplication									| detector |									detector := self new.									detector name: ''Messages sent but not implemented in application''.									detector methodBlock: 											[:context :result | 											| message class block |											message := context messages 														detect: [:each | (context isItem: each in: context application) not]														ifNone: [nil].											class := context selectedClass.											block := 													[:each | 													| app methodApp root |													app := context application.													((class canUnderstand: each) 														ifTrue: 															[root := app rootApplication.															methodApp := ((class whichClassIncludesSelector: each) 																		compiledMethodAt: each) application 																		rootApplication.															methodApp == root or: [root isBasedOn: methodApp]]														ifFalse: [false]) not].											message isNil 												ifTrue: [message := context selfMessages detect: block ifNone: [nil]].											message isNil 												ifTrue: 													[class := class superclass.													class isNil 														ifTrue: 															[context superMessages isEmpty 																ifFalse: [message := context superMessages asArray first]]														ifFalse: [message := context superMessages detect: block ifNone: [nil]]].											message notNil 												ifTrue: 													[result addSearchString: message.													result addClass: context selectedClass selector: context selector]].									^detector')release  self disconnectFromChanges.  super releasecomment: arg1 in: arg2  self deprecated: 'use RBClass2 instead'abstractClassReferences  | tmp1 |  tmp1 := RBParseTreeRewriter variable: variableName getter: self accessorsRefactoring getterMethod setter: self accessorsRefactoring setterMethod.  self convertClasses: class classSide withAllSubclasses select: [:arg1 |  (arg1 whichSelectorsReferToClassVariable: variableName) reject: [:arg2 |  arg1 == class classSide and: [ arg2 == self accessorsRefactoring getterMethod or: [ arg2 == self accessorsRefactoring setterMethod ] ] ] ] using: tmp1symbolReference  ^#(#renameThisMethod: #(4 #renameThisMethod:))addClassVariable: arg1 to: arg2  ^RBAddClassVariableChange add: arg1 to: arg2viewResults  builder inspect.  self resetResultshould: arg1 raise: arg2 withExceptionDo: arg3  ^self assert: (self executeShould: arg1 inScopeOf: arg2 withExceptionDo: arg3)protocol: arg1 inClass: arg2  self className: arg2.  protocol := arg1directlyDefinesMethod: arg1  self isDefined ifTrue: [ (self hasRemoved: arg1) ifTrue: [ ^false ].        (self realClass includesSelector: arg1) ifTrue: [ ^true ] ].  ^newMethods notNil and: [ newMethods includesKey: arg1 ]gtInspectorPreviewIn: arg1  arg1 list     title: 'Changes';     display: [ self changes ];     when: [ self changes notEmpty ]method1  ^self method2testReparentSuperclassChange  | tmp1 tmp2 tmp3 |  tmp1 := modelFactory rbNamespace new.  tmp2 := tmp1 classFor: TestCase superclass.  tmp3 := TestCase subclasses collect: [:arg1 |  tmp1 classFor: arg1 ].  tmp1 reparentClasses: tmp3 to: tmp2.  tmp3 do: [:arg1 |  self assert: arg1 superclass equals: tmp2 ]inlineTemporary  | tmp1 |  self isNil ifTrue: [ tmp1 := 4 ].  ^tmp1open  ^self openModalWithSpecinstanceVariableWriters  ^instanceVariableWritersisOverridden  | tmp1 |  tmp1 := self inlineSelector.  class allSubclassesDo: [:arg1 |  (arg1 directlyDefinesMethod: tmp1) ifTrue: [ ^true ] ].  ^falseexecuteNotifying: arg1  self subclassResponsibilitycheckBrowseOccurrences: arg1  arg1 size = 1 ifTrue: [ ^self checkBrowseOccurrenceOf: arg1 first key in: arg1 first value ] ifFalse: [ ^self checkBrowseAllOccurences: arg1 ]convertMethod: arg1 for: arg2 using: arg3  | tmp1 |  tmp1 := arg2 parseTreeFor: arg1.  tmp1 ifNil: [ ^self ].  (arg3 executeTree: tmp1) ifTrue: [ arg2 compileTree: arg3 tree ]testRenameMethodPermuteArgs  | tmp1 tmp2 |  tmp1 := RBRenameMethodRefactoring renameMethod: ('demoRenameMethod:' , 'PermuteArgs:') asSymbol in: RBRefactoryTestDataApp to: ('demoRenameMethod:' , 'PermuteArgs:') asSymbol permutation: #(2 1).  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: ('demoRenameMethod:' , 'PermuteArgs:') asSymbol) equals: (self parseMethod: 'demoRenameMethod: arg2 PermuteArgs: arg1 self do: arg1.	self do: arg2.	^ arg1 > arg2').  self assert: (tmp2 parseTreeFor: #demoExampleCall) equals: (self parseMethod: 'demoExampleCall ^self demoRenameMethod: 2 PermuteArgs: 1')setUp  super setUp.  model := self abstractVariableTestDataabstractVariablesRefactoring  ^RBAbstractVariablesRefactoring model: self model abstractVariablesIn: parseTree from: class toAll: moveToClasses ignoring: variableusesAdd  ^(1 to: 10) asOrderedCollection addAll: (11 to: 20)rename: arg1 to: arg2 class: arg3 classVariable: arg4  self className: arg3.  variableName := arg1.  newVariableName := arg2.  isClassVariable := arg4fail: arg1  ^self assert: false description: arg1allImplementorsOf: arg1  ^implementorsCache at: arg1 ifAbsentPut: [ self privateImplementorsOf: arg1 ]signalMultipleReferenceError  self signalReferenceError: ('Multiple subclasses reference <1s>' expandMacrosWith: variableName)testAddClass  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := RBAddClassRefactoring addClass: #FooTest superclass: RBRefactoringTest subclasses: (Array with: self class) category: #'Refactory-Testing'.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #FooTest.  tmp3 := tmp1 model classNamed: #RBRefactoringTest.  tmp4 := tmp1 model classNamed: self class name.  self assert: tmp2 superclass equals: tmp3.  self assert: (tmp3 subclasses includes: tmp2).  self assert: tmp2 classSide superclass equals: tmp3 classSide.  self assert: (tmp3 classSide subclasses includes: tmp2 classSide).  self assert: tmp4 superclass equals: tmp2.  self assert: (tmp2 subclasses includes: tmp4).  self assert: tmp4 classSide superclass equals: tmp2 classSide.  self assert: (tmp2 classSide subclasses includes: tmp4 classSide)privateTransform  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self definingMethod.  tmp3 := (tmp1 allChildren select: #isAssignment) select: [:arg1 |  arg1 variable name asString = variableName ].  tmp4 := tmp3 size = 1 ifTrue: [ tmp3 first ] ifFalse: [ tmp2 := self parserClass parseExpression: value.        tmp3 detectMax: [:arg2 |  ((arg2 allChildren collect: #class) intersection: (tmp2 allChildren collect: #class)) size ] ].  tmp4 parent removeNode: tmp4.  class compileTree: tmp1classes  | tmp1 |  tmp1 := IdentitySet new: 4096.  self classesDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1selector  selector ifNil: [ selector := self parserClass parseMethodPattern: source.        selector ifNil: [ selector := #unknown ] ].  ^selectorstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' interval: ''';     nextPutAll: interval asString;     nextPutAll: ' with: ''';     nextPutAll: sourceCode;     nextPutAll: ''' from: ''';     nextPutAll: selector;     nextPutAll: ''' in: '.  class storeOn: arg1.  arg1 nextPut: $)transform  selectors do: [:arg1 |  class removeMethod: arg1 ]usesDirectly: arg1  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1     matches: '[:`@args | | `@temps | `@.Statements]' do: [:arg2 :arg3 |  arg3 ];     matches: name do: [:arg2 :arg3 |  true ].  ^tmp1 executeTree: arg1 initialAnswer: falseprivateReferencesTo: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self allBehaviorsDo: [:arg2 |  (arg2 whichSelectorsReferToSymbol: arg1) do: [:arg3 |  tmp1 add: (arg2 methodFor: arg3) ] ].  ^tmp1expressionsToInlineFrom: arg1  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: '``@obj ' , (self buildSelectorString: oldSelector) do: [:arg2 :arg3 |  arg3           add: (arg2 arguments at: parameterIndex);           yourself ].  ^tmp1 executeTree: arg1 initialAnswer: OrderedCollection newfoo: arg1  ^(1 to: 10) inject: arg1 into: [:arg2 :arg3 |  arg2 + arg3 ]resetResult  result := self resultClass new.  result label: self namesource  ^sourcetextToDisplay  ^String streamContents: [:arg1 |  arg1           << self printString;           cr.        self changes do: [:arg2 |  arg1                 << arg2 textToDisplay;                 cr ] ]guardingClause  self isSymbol ifFalse: [ self printString.        self isSymbol printString ]testInlineMethod3  | tmp1 |  tmp1 := RBInlineMethodRefactoring inline: (58 to: 73) inMethod: #caller2 forClass: RBRefactoryTestDataApp.  self setupInlineExpressionFor: tmp1 toReturn: false.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #caller2) equals: (self parseMethod: 'caller2								^(1 to: 10) inject: 1 into: [:sum :each | sum * ((1 to: 10) inject: each into: [:sum1 :each1 | sum1 + each1])]	')severity  ^#warningprivateTransform  self transformations do: [:arg1 |  arg1           copyOptionsFrom: self options;           model: self model;           preconditionChecking: delegatesPreconditions & self preconditionChecking;           transform ]uses: arg1  ^self literals includes: arg1allMethods  ^self allSelectors collect: [:arg1 |  self methodFor: arg1 ] thenSelect: #isNotNilchangeString  ^'Category ' , self displayCategoryName , ' in ' , self displayClassNameinitialize  super initialize.  environmentDictionaries := Dictionary new.  environment := RBSelectorEnvironment newactionBlock: arg1  actionBlock := arg1multipleCalls  self caller2.  self caller2setUp  super setUp.  modelFactory := RBClassModelFactory newtestMethodDoesNotExist  self shouldFail: (RBAddTemporaryVariableTransformation variable: 'variable2' inMethod: #method inClass: #RBAddReturnStatementTransformationTest) asRefactoringtmpName  ^(#TmpSubclass , className) asSymbolrenameInstanceVariable: arg1 to: arg2 around: arg3  self privateInstanceVariableNames at: (self privateInstanceVariableNames indexOf: arg1 asString) put: arg2 asString.  model renameInstanceVariable: arg1 to: arg2 in: self around: arg3comment  ^commentcomputeTypes  variableMessages keysAndValuesDo: [:arg1 :arg2 |  variableTypes at: arg1 put: (self findTypeFor: arg2) ]testRemoveSameMethodButSendsSuper  < expectedFailure>  self shouldWarn: (RBRemoveMethodRefactoring removeMethods: #(#new) from: RBBasicLintRuleTestData class)testAlreadyExistingName  self shouldFail: (RBRenameInstanceVariableRefactoring rename: 'classBlock' to: 'name' in: RBBasicLintRuleTestData)directlyDefinesVariable: arg1  ^(self directlyDefinesClassVariable: arg1) or: [ self directlyDefinesInstanceVariable: arg1 ]testAccessIsNotDefined  self shouldFail: (RBAddReturnStatementTransformation return: '^ variable2' inMethod: #methodBefore inClass: #RBAddReturnStatementTransformationTest) asRefactoringpreconditions  class := self model classObjectFor: className.  ^(isClassVariable ifTrue: [ (RBCondition isMetaclass: class) not & (RBCondition isValidClassVarName: newVariableName asString for: class) & (RBCondition definesClassVariable: variableName asString in: class) ] ifFalse: [ (RBCondition isValidInstanceVariableName: newVariableName for: class) & (RBCondition definesInstanceVariable: variableName in: class) ]) & (RBCondition hierarchyOf: class definesVariable: newVariableName) not & (RBCondition isGlobal: newVariableName in: self model) nottestOverriden  self shouldWarn: (RBInlineMethodRefactoring inline: (15 to: 26) inMethod: #failedRules forClass: RBLintRuleTestData)badMessage  self become: String newimplementorsCanBePrimitives  ^self hasPermutedArguments nottestExtractToTemporaryForLastStatementInBlock  | tmp1 |  tmp1 := RBExtractToTemporaryRefactoring extract: (52 to: 73) to: 'temp' from: #caller2 in: RBRefactoryTestDataApp.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #caller2) equals: (self parseMethod: 'caller2	^(1 to: 10) inject: 1 into: [:sum :each | | temp | temp := sum * (self foo: each). temp]')changeForClass: arg1 selector: arg2  changes reverseDo: [:arg3 |  | tmp1 |        tmp1 := arg3 changeForClass: arg1 selector: arg2.        tmp1 notNil ifTrue: [ ^tmp1 ] ].  ^nilstoreOn: arg1  arg1 nextPut: $(.  super storeOn: arg1.  arg1 nextPutAll: ' keywords: '.  keywords asArray storeOn: arg1.  arg1 nextPut: $)testPerformRenameClass  | tmp1 |  tmp1 := changes renameClass: self changeMock to: self changeMock name , 'Plus'.  self perform: tmp1 do: [ self deny: (workingEnvironment hasClassNamed: tmp1 oldName).        self assert: (workingEnvironment hasClassNamed: tmp1 newName) ].  self assert: (workingEnvironment hasClassNamed: tmp1 oldName).  self deny: (workingEnvironment hasClassNamed: tmp1 newName)gtInspectorPreviewIn: arg1  < gtInspectorPresentationOrder: 0>  arg1 diff     title: 'Changes';     display: [ {self oldVersionTextToDisplay .         self textToDisplay} ]replace: arg1 to: arg2 inMethod: arg3 inClass: arg4  self className: arg4.  selector := arg3.  oldSourceCode := arg1.  newSourceCode := arg2createGetterAccessor  getterMethod := self findGetterMethod.  getterMethod ifNil: [ getterMethod := self defineGetterMethod ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' variable: '.  variableName storeOn: arg1.  arg1 nextPutAll: ' fromClass: '.  oldClass storeOn: arg1.  arg1 nextPutAll: ' toClass: '.  className storeOn: arg1.  arg1 nextPut: $)testNonExistantName  self     shouldFail: (RBRemoveParameterRefactoring removeParameter: 'asdf' in: RBBasicLintRuleTestData selector: #checkClass:);     shouldFail: (RBRemoveParameterRefactoring removeParameter: 'aSmalllintContext' in: RBBasicLintRuleTestData selector: #checkClass1:)classesDo: arg1  self systemDictionaryClassesDo: [:arg2 |  (self includesClass: arg2) ifTrue: [ arg1 value: arg2 ] ]problemCount  ^environment isClassEnvironment ifTrue: [ self numberClasses ] ifFalse: [ super problemCount ]whoDefinesMethod: arg1  | tmp1 |  (self directlyDefinesMethod: arg1) ifTrue: [ ^self ].  tmp1 := self superclass.  ^tmp1 ifNil: [ nil ] ifNotNil: [ tmp1 whoDefinesMethod: arg1 ]hasRemoved: arg1  ^removedClasses includes: arg1testInlineMethodWithMultipleSendersInMethod  | tmp1 |  tmp1 := RBInlineAllSendersRefactoring sendersOf: #caller2 in: RBRefactoryTestDataApp.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineLast) equals: (self parseMethod: 'inlineLast	5 = 3 ifTrue: [^self caller] ifFalse: [^(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]] ').  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #multipleCalls) equals: (self parseMethod: 'multipleCalls	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)].	(1 to: 10) inject: 1 into: [:sum1 :each1 | sum1 * (self foo: each1)]')asUndoOperation  ^changeFactory removePoolVariable: self variable from: self changeClasssignalStillReferencedError  self signalReferenceError: ('<1p> has references to <2s>' expandMacrosWith: class with: variableName)executeRefactoring: arg1  arg1 primitiveExecute.  self parserClass parseExpression: arg1 storeStringchanges  ^changestestRenameTestMethod  | tmp1 tmp2 |  tmp1 := RBRenameMethodRefactoring renameMethod: ('rename' , 'ThisMethod:') asSymbol in: RBRefactoryTestDataApp to: #renameThisMethod2: permutation: (1 to: 1).  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #renameThisMethod2:) equals: (self parseMethod: 'renameThisMethod2: anArg	^self').  self assert: (tmp2 parseTreeFor: #callMethod) equals: (self parseMethod: 'callMethod	^(self renameThisMethod2: 5)').  self assert: (tmp2 parseTreeFor: #symbolReference) equals: (self parseMethod: 'symbolReference		^ #(#renameThisMethod2: #(4 #renameThisMethod2:))').  self deny: (tmp2 directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' selector: ';     nextPutAll: selector;     nextPutAll: ' from: '.  class storeOn: arg1.  arg1 nextPut: $)& arg1  ^RBConjunctiveCondition new left: self right: arg1asSelectorEnvironment  ^(RBClassEnvironment onEnvironment: self classes: self classes) asSelectorEnvironmenttestReferencedVariable  self     shouldFail: (RBRemoveVariableTransformation instanceVariable: 'name' class: #RBDummyLintRuleTest) asRefactoring;     shouldFail: (RBRemoveVariableTransformation classVariable: #RecursiveSelfRule class: #RBTransformationDummyRuleTest) asRefactoringtestAddClassVariable  | tmp1 |  tmp1 := changes addClassVariable: 'ClassVar' to: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 variable equals: 'ClassVar'.  self universalTestFor: tmp1isDefined  ^self realClass notNiltestWithTemporariesSelected  | tmp1 tmp2 |  model := RBNamespace2 new.  tmp1 := model classNamed: self class name.  tmp1 compile: 'foo [| temp | temp := 5. temp * temp] value' classified: #(#accessing).  tmp2 := (RBExtractMethodTransformation model: model extract: '| temp | temp := 5. temp * temp' from: #foo to: #foobar in: tmp1) asRefactoring transform.  self assert: tmp2 model changes changes size equals: 4.  self assert: (tmp1 parseTreeFor: #foo) equals: (self parseMethod: 'foo [self foobar] value').  self assert: (tmp1 parseTreeFor: #foobar) equals: (self parseMethod: 'foobar |temp | temp := 5. ^temp * temp')multiplePeriodsTerminatingStatement  ^selfcollectionMessagesToExternalObject  self someObject collection remove: 10newName  ^newNametestAlreadyExistingName  self     shouldFail: (RBAddInstanceVariableRefactoring variable: 'class' class: RBTransformationRuleTestData);     shouldFail: (RBAddInstanceVariableRefactoring variable: 'name' class: RBTransformationRuleTestData)removeClass: arg1 instanceVariableWriter: arg2  | tmp1 |  tmp1 := instanceVariableWriters at: arg1 name ifAbsent: [ Set new ].  tmp1 remove: arg2 ifAbsent: [  ].  tmp1 ifEmpty: [ instanceVariableWriters removeKey: arg1 name ifAbsent: [  ] ].  self flushCachesFor: arg1preconditions  ^RBCondition withBlock: [ (self theClass withAllSubclasses detect: [:arg1 |  (arg1 whichSelectorsReferToSymbol: #subclassResponsibility) notEmpty or: [ (arg1 classSide whichSelectorsReferToSymbol: #subclassResponsibility) notEmpty ] ] ifNone: [ nil ]) isNil ] errorString: self theClass printString , ' is abstract or has abstract subclasses.'abstractVariableReferences  | tmp1 |  tmp1 := RBAbstractVariablesRefactoring model: self model abstractVariablesIn: inlineParseTree from: inlineClass toAll: (Array with: class).  self performComponentRefactoring: tmp1.  inlineParseTree := tmp1 parseTreeprintOn: arg1  | tmp1 |  self isValid ifFalse: [ ^arg1 nextPutAll: '(invalid)' ].  tmp1 := self arguments readStream.  self selector keywords keysAndValuesDo: [:arg2 :arg3 |  arg2 = 1 ifFalse: [ arg1 space ].        arg1 nextPutAll: arg3.        (self selector isUnary or: [ tmp1 atEnd ]) ifTrue: [ ^self ].        arg1           space;           nextPutAll: tmp1 next ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' removeParameter: ''';     nextPutAll: argument;     nextPutAll: ''' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' selector: #';     nextPutAll: oldSelector.  arg1 nextPut: $)includesCategory: arg1  ^(categories includes: arg1) and: [ super includesCategory: arg1 ]compileNewMethods  moveToClasses do: [:arg1 |  arg1 compile: parseTree newSource withAttributesFrom: (class methodFor: selector) ]numberOfArgs: arg1  ^(arg1 asString splitOn: ':') sizeinitialize  super initialize.  environment := Smalltalk globalspreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ | tmp1 |              tmp1 := self parserClass parsePragma: pragma.              self definingMethod pragmas noneSatisfy: [:arg1 |  arg1 selector = tmp1 selector ] ] errorString: ('Method named <1s> already has a pragma named <2s>' expandMacrosWith: selector with: (self parserClass parsePragma: pragma) selector))addSelfReferenceToInlineParseTree  | tmp1 tmp2 tmp3 |  tmp1 := self newNameForSelf.  tmp2 := RBParseTreeRewriter rename: 'self' to: tmp1.  (tmp2 executeTree: inlineParseTree) ifTrue: [ inlineParseTree := tmp2 tree ].  tmp3 := inlineParseTree arguments asOrderedCollection.  tmp3 addFirst: (RBVariableNode named: tmp1).  inlineParseTree renameSelector: (self addArgumentToSelector: inlineParseTree selector) andArguments: tmp3.  sourceMessage receiver replaceWith: (RBVariableNode named: tmp1)selectorsForClass: arg1 do: arg2  arg1 selectorsAndMethodsDo: [:arg3 :arg4 |  (self includesSelector: arg3 in: arg1) ifTrue: [ arg2 value: arg3 ] ]testAddInstanceVariable  | tmp1 |  tmp1 := (RBAddVariableTransformation instanceVariable: 'asdf' class: #RBTransformationRuleTestData) asRefactoring transform.  self assert: ((tmp1 model classNamed: #RBTransformationRuleTestData) directlyDefinesInstanceVariable: 'asdf')privateTransform  | tmp1 tmp2 tmp3 |  tmp1 := self definingMethod.  tmp2 := tmp1 source copyFrom: 1 to: tmp1 body start - 1.  tmp3 := tmp2 , String cr , (comment surroundedBy: '"') , String cr , tmp1 body sourceCode.  self definingClass compileTree: (self parserClass parseMethod: tmp3)testPullUpWithInvalidSuperSend  | tmp1 |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Foo2) compile: 'yourself ^super yourself + 1' classified: #(#accessing).  tmp1 := model classNamed: #Foo1.  tmp1 compile: 'yourself ^1' classified: #(#accessing).  self shouldFail: (RBPullUpMethodRefactoring model: model pullUp: #(#yourself) from: tmp1)fileBlocks  | tmp1 |  ^[ tmp1 := 'asdf' asFileReference readStream.  tmp1 contents ] ensure: [ tmp1 close ]testChangeFactoryIsCorrectlyInitialized  RBRefactoryChangeManager nuke.  self assert: RBRefactoryChangeManager changeFactory isNotNilasUndoOperation  ^changeFactory removeClassVariable: self variable from: self changeClasstoDo  1 to: self size do: [:arg1 |  (self at: arg1) printString ]asUndoOperation  | tmp1 |  tmp1 := onSystemDictionary classNamed: self changeClassName.  ^tmp1 isBehavior ifTrue: [ changeFactory addClassDefinition: tmp1 oldDefinition ] ifFalse: [ changeFactory removeClassNamed: self changeClassName ]critics  ^self result smallLintCriticsfailedRules  ^self isEmpty ifTrue: [ #() ] ifFalse: [ Array with: self ]initialize  super initialize.  self anInstVar: 1.  classBlock := [:arg1 :arg2 |   ].  methodBlock := [:arg1 :arg2 |   ].  self resultClass: RBSelectorEnvironmentchangeString  ^'Add instance variable <1s> to <2s>' expandMacrosWith: self variable with: self displayClassNameimplementorsOf: arg1  ^RBSelectorEnvironment implementorsOf: arg1 in: selftestInlineMethod1  | tmp1 |  tmp1 := RBInlineMethodRefactoring inline: (39 to: 84) inMethod: #caller forClass: RBRefactoryTestDataApp.  self setupInlineExpressionFor: tmp1 toReturn: false.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #caller) equals: (self parseMethod: 'caller 									| anObject anObject1 | 									anObject := 5.									anObject1 := anObject + 1.									Transcript										show: anObject1 printString;										cr.									^anObject')changeString  ^'Remove class variable <1s> from <2s>' expandMacrosWith: self variable with: self displayClassNametestDefinesMethod  self assert: (objectClass definesMethod: #printString).  self assert: (newClass definesMethod: #printString).  self assert: (messageNodeClass definesMethod: #printString)testMethodDoesNotExist  self shouldFail: (RBAddPragmaTransformation pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #method inClass: #RBAddPragmaTransformationTest) asRefactoringclassVariable: arg1  classVariable := arg1primitiveComputeLiterals  | tmp1 |  literals := IdentitySet new: 25000.  literals addAll: self specialSelectors keys.  selectors := IdentitySet new.  RBBrowserEnvironment new classesDo: [:arg1 |  self computeLiteralsForClass: arg1 ].  tmp1 := literalSemaphore.  literalSemaphore := nil.  self signalProcesses: tmp1.  ^literalProcess := nilaccessorsRefactoring  ^accessorsRefactoring ifNil: [ accessorsRefactoring := RBCreateAccessorsForVariableRefactoring model: self model variable: variableName class: class classVariable: false ] ifNotNil: [ accessorsRefactoring ]testMetaClassFailure  self shouldFail: (RBRenameClassRefactoring rename: self class class to: #Foo)methodBefore  | tmp1 |  tmp1 := 'String'storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' selector: #';     nextPutAll: method selector;     nextPutAll: ' class: '.  class storeOn: arg1.  arg1 nextPutAll: ''')'testAddInstanceVariable  | tmp1 |  tmp1 := RBAddInstanceVariableRefactoring variable: 'asdf' class: RBTransformationRuleTestData.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBTransformationRuleTestData) directlyDefinesInstanceVariable: 'asdf')classVariableNames  ^self privateClassVariableNames copyremoveClassNamed: arg1  ^RBRemoveClassChange removeClassName: arg1testPragmaEnvironment  | tmp1 |  tmp1 := universalEnvironment forPragmas: #(primitive:).  self universalTestFor: tmp1includesProtocol: arg1 in: arg2  ^(environment includesProtocol: arg1 in: arg2) and: [ andedEnvironment includesProtocol: arg1 in: arg2 ]= arg1  super = arg1 ifFalse: [ ^false ].  ^self parseTree = arg1 parseTreerename: arg1 to: arg2  oldName := arg1.  newName := arg2methodsReferencingVariable  ^classVariable ifTrue: [ self definingClass whichSelectorsReferToClassVariable: variableName ] ifFalse: [ self definingClass whichSelectorsReferToInstanceVariable: variableName ]requestExistingSelector  ^[ (self options at: #existingSelector) value: self ] on: Exception do: [ nil ]executeNotifying: arg1  | tmp1 tmp2 |  tmp1 := changes collect: [:arg2 |  arg2 executeNotifying: arg1 ].  tmp2 := self copy.  tmp2 changes: tmp1 reversed.  ^tmp2change: arg1  | tmp1 |  tmp1 := RBRefactoryChangeManager changeFactory compositeRefactoryChange.  tmp1 addChange: arg1.  change := tmp1 whatToDisplayIn: selfname  ^changes nametestEnvironmentWrapper  | tmp1 tmp2 |  tmp1 := RBBrowserEnvironment new referencesTo: #printString.  tmp2 := RBBrowserEnvironmentWrapper onEnvironment: tmp1.  self assert: tmp2 numberSelectors equals: tmp1 numberSelectors.  self assert: tmp2 numberClasses equals: tmp1 numberClasses.  self assert: tmp2 environment identicalTo: tmp1testMethod  ^self classaddClass: arg1 into: arg2  (environmentDictionaries at: arg2 ifAbsentPut: [ RBSelectorEnvironment new ]) addClass: arg1definesClass: arg1  ^(environment definesClass: arg1) or: [ orEnvironment definesClass: arg1 ]abstractVariables  self performComponentRefactoring: self abstractVariablesRefactoring.  parseTree := self abstractVariablesRefactoring parseTreetestInheritedName  self shouldFail: (RBAbstractClassVariableRefactoring variable: #DependentsFields class: RBBasicLintRuleTestData)inline: arg1  self onError: [ self performComponentRefactoring: (RBInlineAllSendersRefactoring model: self model sendersOf: arg1 in: class) ] do: [  ]setterMethod  ^setterMethod ifNil: [ setterMethod := (self definingClass setterMethodFor: variableName) ifNil: [ (variableName uncapitalized , ':') asSymbol ] ]addMethod: arg1 toClass: arg2 inProtocols: arg3  class := self classObjectFor: arg2.  source := arg1.  protocols := arg3critiqueFor: arg1  ^ReTrivialCritique withAnchor: (self anchorFor: arg1) by: selfremoveClass: arg1 instanceVariable: arg2  | tmp1 |  tmp1 := instanceVariables at: arg1 name ifAbsent: [ Set new ].  tmp1 remove: arg2 ifAbsent: [  ].  tmp1 ifEmpty: [ instanceVariables removeKey: arg1 name ifAbsent: [  ] ].  self flushCachesFor: arg1rename: arg1 to: arg2 in: arg3  self variable: arg1 class: arg3.  newName := arg2checkSuperMessages  self checkSuperSendsFromPushedUpMethods.  self checkSuperSendsFromSiblingsclassVariables  ^classVariablesaddProtocolNamed: arg1 in: arg2  ^changes addProtocolNamed: arg1 in: arg2shouldFix: arg1  ^self should: arg1 raise: ExceptionclassVariablesFor: arg1  ^arg1 classVarNameslastUndoPointer  ^undoPointers popaddSelfReferenceToSourceMessage  | tmp1 |  tmp1 := sourceMessage arguments asOrderedCollection.  tmp1 addFirst: sourceMessage receiver copy.  sourceMessage renameSelector: (self addArgumentToSelector: sourceMessage selector) andArguments: tmp1shouldInlineExpression: arg1  ^(self options at: #inlineExpression) value: self value: arg1allSubclassesDo: arg1  self subclassesDo: [:arg2 |  arg1 value: arg2.        arg2 allSubclassesDo: arg1 ]resultClass  ^RBParseTreeEnvironmentsearchingLiteral  ^self printString = #a or: [ #() = self printString | (#() == self printString) ]rootEnvironment  ^selfsendInlineParameterMethod  ^self inlineParameterMethod: #(#asdf)buildDiffFor: arg1  diffPresenter     leftText: arg1 oldVersionTextToDisplay;     rightText: arg1 textToDisplayallImplementorsOf: arg1 do: arg2  (self allImplementorsOf: arg1) do: arg2rewriteUsing: arg1  rewriteRule := arg1.  self resetResulttestAddMethod  | tmp1 |  tmp1 := RBAddMethodRefactoring addMethod: 'printString1 ^super printString' toClass: RBBasicLintRuleTestData inProtocols: #(#accessing).  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBBasicLintRuleTestData) parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')preconditions  ^variables inject: RBCondition empty into: [:arg1 :arg2 |  arg1 & (RBCondition definesInstanceVariable: arg2 in: self theClass) ]privateTransform  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self definingMethod.  tmp2 := RBAssignmentNode variable: (RBVariableNode named: variableName) value: (self parserClass parseExpression: value).  tmp3 := (tmp1 allChildren select: #isAssignment) select: [:arg1 |  arg1 variable name asString = variableName ].  tmp4 := tmp3 detectMax: #stop.  tmp4 ifNil: [ tmp1 body addNodeFirst: tmp2 ] ifNotNil: [ tmp4 parent addNode: tmp2 after: tmp4 ].  class compileTree: tmp1junk  ^RBDummyRefactoryTestDataApp printString copyFrom: 1 to: CRtestNonExistantName  self shouldFail: (RBSplitClassTransformation class: #RBDummyLintRuleTest instanceVariables: #(name1) newClassName: #RBDummyLintRuleTest123 referenceVariableName: #newName) asRefactoringvariable: arg1 class: arg2 classVariable: arg3  variableName := arg1.  isClassVariable := arg3.  className := arg2name: arg1  name := arg1justSendsSuper  super justSendsSuperaccept: arg1 notifying: arg2  ^falsepreconditions  ^(RBCondition isValidClassName: newClassName) & (RBCondition isGlobal: newClassName in: self model) not & (RBCondition isValidInstanceVariableName: referenceVariableName for: class) & (RBCondition hierarchyOf: class definesVariable: referenceVariableName) not & (RBCondition isGlobal: referenceVariableName in: self model) not & (RBCondition definesTemporaryVariable: referenceVariableName in: class) notaddClassDefinition: arg1 for: arg2 context: arg3  ^RBAddClassChange definition: arg1 for: arg2 context: arg3rewriteRule1  ^rewriteRule1printOn: arg1  arg1     nextPutAll: self displayClassName;     nextPutAll: ' removeSelector: ';     print: self selector;     nextPut: $!hash  ^(self class hash bitXor: self oldName hash) bitXor: self newName hashtestRemoveParameter  | tmp1 tmp2 |  tmp1 := RBRemoveParameterRefactoring removeParameter: 'anArg' in: RBRefactoryTestDataApp selector: ('rename' , 'ThisMethod:') asSymbol.  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #renameThisMethod) equals: (self parseMethod: 'renameThisMethod								^self').  self assert: (tmp2 parseTreeFor: #callMethod) equals: (self parseMethod: 'callMethod								^(self renameThisMethod)').  self deny: (tmp2 directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)inlineSelector  sourceMessage ifNil: [ self findSelectedMessage ].  ^sourceMessage selectorclass: arg1 selector: arg2 interval: arg3  interval := arg3.  class := self classObjectFor: arg1.  selector := arg2= arg1  super class = arg1 class ifFalse: [ ^false ].  ^oldName = arg1 oldName and: [ newName = arg1 newName ]testTransform  | tmp1 tmp2 |  tmp1 := (RBRemovePragmaTransformation new pragma: '<gtInspectorPresentationOrder: 34>' inMethod: #methodBefore inClass: self class name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyreturn: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  returnValue := arg1realName: arg1  self realClass: (self class environment at: arg1)createNewClassFor: arg1  | tmp1 tmp2 tmp3 |  tmp3 := arg1 instanceSide name.  tmp1 := (self rbClassClass existingNamed: tmp3)     model: self;     yourself.  tmp2 := (self rbMetaclassClass existingNamed: tmp3)     model: self;     yourself.  ^changedClasses at: tmp3 put: (Array with: tmp1 with: tmp2)testModelInlineMethodWithSameVariableNames  | tmp1 tmp2 |  model := RBClassModelFactory rbNamespace new.  tmp1 := model classNamed: self class name.  tmp1 compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).  (model classNamed: #Object) compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a a9: b b9: c' classified: #(#accessing).  self proceedThroughWarning: [ tmp2 := RBInlineMethodFromComponentRefactoring model: model inline: (72 to: 84) inMethod: #foo forClass: (model classNamed: #Object).        self setupInlineExpressionFor: tmp2 toReturn: false.        self executeRefactoring: tmp2 ].  self assert: ((tmp2 model classNamed: #Object) parseTreeFor: #foo) equals: (self parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a + b + c')hasConflicts  ^rules anySatisfy: [:arg1 |  arg1 hasConflicts ]toDo  1 to: self size do: [:arg1 |  (self at: arg1) printString ]checkAssignments: arg1  | tmp1 tmp2 tmp3 |  tmp3 := arg1 copy.  tmp1 := self placeholderNode.  tmp2 := arg1 select: [:arg2 |  (tmp1 whoDefines: arg2) references: arg2 ].  tmp2 size == 1 ifTrue: [ self checkSingleAssignment: tmp2 asArray first ].  tmp2 size > 1 ifTrue: [ self refactoringError: 'Cannot extract assignment without all references.' ].  tmp3 removeAll: tmp2.  (RBReadBeforeWrittenTester readBeforeWritten: tmp3 in: extractedParseTree) ifNotEmpty: [ self refactoringError: 'Cannot extract assignment if read before written.' ].  tmp3 do: [:arg2 |  (tmp1 whoDefines: arg2) removeTemporaryNamed: arg2 ].  self createTemporariesInExtractedMethodFor: arg1emptyExceptionHandler  [  ] on: Error do: [:arg1 |   ]testTransform  | tmp1 |  tmp1 := (RBPullUpVariableTransformation instanceVariable: 'result' class: #RBDummyLintRuleTest) transform.  self assert: ((tmp1 model classNamed: #RBDummyLintRuleTest) directlyDefinesInstanceVariable: 'result').  self deny: ((tmp1 model classNamed: #RBBasicDummyLintRuleTest) directlyDefinesInstanceVariable: 'result').  self deny: ((tmp1 model classNamed: #RBFooDummyLintRuleTest) directlyDefinesInstanceVariable: 'result')backpointersSetWith: arg1  ^PluggableSet new     equalBlock: [:arg2 :arg3 |  arg2 class == arg3 class and: [ arg2 = arg3 ] ];     hashBlock: [:arg2 |  arg2 class identityHash bitXor: arg2 hash ];     add: arg1;     yourselfinstanceVariableReaders: arg1  instanceVariableReaders := arg1abstractClassVariables  | tmp1 |  (classVarReaders isEmpty and: [ classVarWriters isEmpty ]) ifTrue: [ ^self ].  tmp1 := Set new.  tmp1     addAll: classVarReaders;     addAll: classVarWriters.  tmp1 do: [:arg1 |  self abstractClassVariable: arg1 ]definesClassVariable: arg1  self realClass isTrait ifTrue: [ ^false ].  (self directlyDefinesClassVariable: arg1) ifTrue: [ ^true ].  ^self superclass notNil and: [ self superclass definesClassVariable: arg1 ]buildParseTree  | tmp1 |  tmp1 := self selectedClass parseTreeFor: self selector.  tmp1 ifNil: [ ^RBParser parseMethod: 'method' ].  ^tmp1parserClass  ^RBParserincludesProtocol: arg1 in: arg2  ^(environment includesProtocol: arg1 in: arg2) or: [ orEnvironment includesProtocol: arg1 in: arg2 ]testMoveDefinition  | tmp1 |  tmp1 := RBMoveVariableDefinitionRefactoring bindTight: (19 to: 22) in: RBRefactoryTestDataApp selector: #moveDefinition.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #moveDefinition) equals: (self parseMethod: 'moveDefinition								^(self collect: 										[:each | 										| temp |										temp := each printString.										temp , temp]) 									select: 										[:each | 										| temp |										temp := each size.										temp odd]')setterMethod  ^setterMethodinitializeWidgets  diffPresenter := self newDiff     showOptions: false;     contextClass: True.  self whenBuiltDo: [ self buildDiffFor: change first ]check: arg1 forCritiquesDo: arg2  (self basicCheck: arg1) ifTrue: [ arg2 cull: (ReTransformationCritique for: arg1 by: self tree: rewriteRule tree) ]directlyDefinesInstanceVariable: arg1  ^self instanceVariableNames includes: arg1environmentForClassVariable: arg1 in: arg2  | tmp1 tmp2 tmp3 |  tmp1 := RBSelectorEnvironment onEnvironment: self.  tmp1 addSearchString: arg1.  ((classVariables at: arg2 name ifAbsent: [ #() ]) includes: arg1) ifFalse: [ ^tmp1 ].  tmp2 := arg2 bindingOf: arg1.  tmp3 := [:arg3 |  (arg3 whichSelectorsReferTo: tmp2) do: [:arg4 |  tmp1 addClass: arg3 selector: arg4 ] ].  arg2 withAllSubAndSuperclassesDo: [:arg3 |  tmp3           value: arg3;           value: arg3 class ].  ^tmp1browsedEnvironment  ^browsedEnvironment ifNil: [ browsedEnvironment := RBBrowserEnvironment new ]superclassName  ^superclassNameclassVariables: arg1  classVariables := arg1includesProtocol: arg1 in: arg2  ^truesubblocksIn: arg1  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: '[:`@blockTemps | | `@temps | `@.Statements]' do: [:arg2 :arg3 |  (arg2 references: name) ifTrue: [ arg3 add: arg2 ].        arg3 ].  ^tmp1 executeTree: arg1 initialAnswer: OrderedCollection newallReferencesTo: arg1 do: arg2  (self allReferencesTo: arg1) do: arg2storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' pushDown: '.  selectors asArray storeOn: arg1.  arg1 nextPutAll: ' from: '.  class storeOn: arg1.  arg1 nextPut: $)rewriteUsing: arg1  rewriteRule := arg1.  self resetResulttestNonExistantName  self shouldFail: (RBPushDownInstanceVariableRefactoring variable: 'foo' class: RBBasicLintRuleTestData)isEmpty  ^builder changes isEmptypreconditions  ^(RBCondition withBlock: [ class notNil and: [ class isMeta not ] ]) & (RBCondition isValidClassName: newName) & (RBCondition isGlobal: newName in: self model) not | (RBCondition withBlock: [ self refactoringFailure: newName , ' is not a valid class name' ])testInlineComponentMethodMax  | tmp1 |  self proceedThroughWarning: [ | tmp2 |        tmp1 := RBInlineMethodFromComponentRefactoring inline: (47 to: 58) inMethod: #inlineMax forClass: RBRefactoryTestDataApp.        self setupInlineExpressionFor: tmp1 toReturn: true.        tmp2 := tmp1 model classNamed: #Magnitude.        tmp2 compile: 'max: aMagnitude 					"Answer the receiver or the argument, whichever has the greater magnitude."					self > aMagnitude						ifTrue: [^self]						ifFalse: [^aMagnitude]' classified: #(#accessing).        self setupImplementorToInlineFor: tmp1 toReturn: tmp2.        self executeRefactoring: tmp1 ].  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineMax) equals: (self parseMethod: 'inlineMax								| x y q |								x := 5.								y := 10.								q := x + 1 > y									ifTrue: [x + 1]									ifFalse: [y].								^q')changeSymbol  ^#removeSharedPool:rbMetaclass  ^self class rbMetaclassparserClass  ^RBParserincludesProtocol: arg1 in: arg2  ^arg2 == class and: [ (super includesProtocol: arg1 in: arg2) and: [ protocols includes: arg1 ] ]unaryNonAccessingMessageStatementMethodWithoutReturn  self valueparseTree  ^treerelease  context release.  super releaseproblemCount  ^self subclassResponsibilityasUndoOperation  ^changeFactory addInstanceVariable: self variable to: self changeClasstransform  | tmp1 |  tmp1 := self existingSelector.  self nameNewMethod: (tmp1 ifNil: [ newExtractedSelector ifNil: [ self getNewMethodName ] ] ifNotNil: [ tmp1 ]).  tmp1 ifNil: [ self renameAllParameters.        class compile: extractedParseTree newSource withAttributesFrom: (class methodFor: selector) ].  class compileTree: modifiedParseTreeaddUndo: arg1  undo push: arg1.  undo size > UndoSize ifTrue: [ undo removeFirst ].  redo := OrderedCollection newmatches: arg1  ^RBSelectorEnvironment matches: arg1 in: selfsearchingLiteral  ^self printString = #a or: [ #() = self printString | (#() == self printString) ]testTransform  | tmp1 |  tmp1 := (RBPushDownVariableTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) transform.  (tmp1 model classNamed: #RBDummyLintRuleTest) subclasses do: [:arg1 |  self assert: (arg1 directlyDefinesInstanceVariable: 'foo1') ]rbClassClass  ^RBClass2preconditions  ^RBCondition emptyviewResults  builder inspect.  self resetResulttestTransform  | tmp1 tmp2 |  tmp1 := (RBAddMethodTransformation sourceCode: 'printString1 ^super printString' in: self changeMock name withProtocol: #accessing) transform.  tmp2 := tmp1 model classNamed: self changeMock name.  self assert: (tmp2 parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')preconditions  | tmp1 |  tmp1 := (RBCondition withBlock: [ self haveSameNumberOfArgs.        true ]) & (RBCondition definesSelector: oldSelector in: class) & (RBCondition definesSelector: newSelector in: class).  ^tmp1 & (RBCondition withBlock: [ | tmp2 |              tmp2 := self model allReferencesTo: oldSelector.              tmp2 size > 1 ifTrue: [ self refactoringWarning: ('This will modify all <1p> senders.' expandMacrosWith: tmp2 size) ].              true ])hasConflicts  ^trueclassObjectFor: arg1  (arg1 isBehavior or: [ arg1 isTrait ]) ifTrue: [ ^self classFor: arg1 ].  arg1 isSymbol ifTrue: [ ^self classNamed: arg1 ].  ^arg1testNonExistantName  self shouldFail: (RBAbstractClassVariableRefactoring variable: #Foo class: RBBasicLintRuleTestData)testRefactoring  | tmp1 |  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmpty.  tmp1 := (RBMethodProtocolTransformation protocol: 'empty protocol 2' inMethod: #someMethod inClass: #RBDummyEmptyClass) asRefactoring transform.  RBRefactoryChangeManager instance performChange: tmp1 changes.  self deny: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmpty.  tmp1 := (RBMethodProtocolTransformation protocol: 'empty protocol 1' inMethod: #someMethod inClass: #RBDummyEmptyClass) asRefactoring transform.  RBRefactoryChangeManager instance performChange: tmp1 changes.  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmptychangeString  ^'Add class variable <1s> to <2s>' expandMacrosWith: self variable with: self displayClassNamerefactoringWarning: arg1  ^RBRefactoringWarning signal: arg1checkSingleAssignment: arg1  ((RBReadBeforeWrittenTester isVariable: arg1 readBeforeWrittenIn: extractedParseTree) or: [ extractedParseTree containsReturn ]) ifTrue: [ self refactoringError: 'Cannot extract assignments to temporaries without all references' ].  extractedParseTree addNode: (RBReturnNode value: (RBVariableNode named: arg1)).  modifiedParseTree := RBParseTreeRewriter replace: self methodDelimiter with: arg1 , ' := ' , self methodDelimiter in: modifiedParseTreeorderOcurrences: arg1  ^arg1 asOrderedCollection sort: [:arg2 :arg3 |  arg2 key first < arg3 key first ]variable: arg1 class: arg2  class := self classObjectFor: arg2.  variableName := arg1withBlock: arg1  block := arg1.  type := #(#generic)initialize  methodBlock := [  ].  environment := RBBrowserEnvironment new.  context := RBSmalllintContext newNoCachetestTransform  | tmp1 tmp2 |  tmp1 := (RBReplaceSubtreeTransformation replace: '^ 1' to: '^ 123' inMethod: #one inClass: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 directlyDefinesMethod: #one).  self assert: (tmp2 parseTreeFor: #one) body statements size equals: 1.  self assert: (tmp2 parseTreeFor: #one) body statements first isReturn.  self assert: (tmp2 parseTreeFor: #one) body statements first value value equals: 123privateTransform  isClassVariable ifTrue: [ self definingClass theNonMetaClass renameClassVariable: variableName to: newVariableName around: [ self renameReferences ] ] ifFalse: [ self definingClass renameInstanceVariable: variableName to: newVariableName around: [ self renameReferences ] ]testRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddMessageSendTransformation messageSend: 'variable byteAt: 1' inMethod: #methodBefore inClass: #RBAddMessageSendTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBAddMessageSendTransformationTest.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyconnectToChanges  SystemAnnouncer uniqueInstance weak when: CategoryAdded , CategoryRemoved , CategoryRenamed , ClassAdded , ClassModifiedClassDefinition , ClassRemoved , ClassRenamed , ClassReorganized , MethodAdded , MethodModified , MethodRemoved , ProtocolAdded , ProtocolRemoved send: #update: to: selfanInstVar: arg1  anInstVar := arg1packages  ^self subclassResponsibilitytestPerformChangeClass  | tmp1 |  tmp1 := changes defineClass: self class name , ' subclass: #' , self changeMock name , '	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , self class category , ''''.  self perform: tmp1 do: [ self assert: tmp1 changeClass superclass equals: self class.        self assertEmpty: tmp1 changeClass instVarNames ].  self assert: tmp1 changeClass superclass equals: Object.  self denyEmpty: tmp1 changeClass instVarNames.  self assert: tmp1 definedClass equals: self changeMockrbNamespace  ^self class rbNamespacenewName: arg1  newName := arg1abstractUnaryAccessingMethodWithoutReturn  self subclassResponsibilitytestPerformAddRemoveClassInteractively  | tmp1 |  tmp1 := changeFactory addClassDefinition: 'Object subclass: #' , self changeMock name , 'Temporary	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	package: ''' , self class category , '''' for: self.  self perform: tmp1 do: [ self assert: (workingEnvironment hasClassNamed: tmp1 changeClassName).        self assert: tmp1 definedClass name equals: tmp1 changeClassName.        self assert: tmp1 definedClass isBehavior ].  self deny: (workingEnvironment hasClassNamed: tmp1 changeClassName).  self assert: tmp1 definedClass isObsoletetestCreation  | tmp1 |  tmp1 := RBMethodName selector: #foo: arguments: #('x').  self assert: tmp1 selector equals: #foo:.  self assert: tmp1 arguments equals: #('x')transform  self     inlineSelfSends;     removeMethod;     checkInlinedMethodsclassForTestResult  ^TestResultvalidateRenameNode: arg1 withOldName: arg2 toWithName: arg3  | tmp1 tmp2 |  tmp1 := (RBCondition isValidInstanceVariableName: arg3 for: class) & (RBCondition definesSelector: selector in: class) & (RBCondition definesInstanceVariable: arg3 in: class) not & (RBCondition definesClassVariable: arg3 in: class) not.  tmp1 check ifFalse: [ tmp2 := tmp1 errorBlock.        tmp2 ifNotNil: [ self refactoringError: tmp1 errorString with: tmp2 ] ifNil: [ self refactoringError: tmp1 errorString ] ].  (parameterMap values includes: arg3) ifTrue: [ self refactoringError: arg3 asString , ' is already defined as parameter' ].  (arg1 whoDefines: arg3) ifNotNil: [ self refactoringError: arg3 asString , ' is already defined' ].  (arg1 allDefinedVariables includes: arg3) ifTrue: [ self refactoringError: arg3 asString , ' is already defined' ]oldName  ^oldNameremoveMethods: arg1 from: arg2  class := self classObjectFor: arg2.  selectors := arg1checkAssignmentsToVariable  | tmp1 |  variable ifNotNil: [ tmp1 := self parseTreeSearcher.        tmp1 matches: variable , ' := `@object' do: [:arg1 :arg2 |  true ].        (tmp1 executeTree: parseTree initialAnswer: false) ifTrue: [ self refactoringError: ('Cannot move the method into <1s> since it is assigned' expandMacrosWith: variable) ] ]should: arg1 raise: arg2 whoseDescriptionIncludes: arg3 description: arg4  ^self assert: (self executeShould: arg1 inScopeOf: arg2 withDescriptionContaining: arg3) description: arg4asRefactoring  ^super asRefactoring     delegatesPreconditions: false;     yourselftestModelPushDownVariableToClassDownTwoLevels  | tmp1 |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  tmp1 := model metaclassNamed: #AnotherSubclass.  tmp1 compile: 'bar ^Foo' classified: #(#accessing).  tmp1 := tmp1 instanceSide.  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: tmp1 superclass superclass).  self deny: (tmp1 superclass superclass directlyDefinesClassVariable: #Foo).  self deny: (tmp1 superclass directlyDefinesClassVariable: #Foo).  self assert: (tmp1 directlyDefinesClassVariable: #Foo)testReferencesPrintOn  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := false.  tmp3 := modelFactory rbNamespace new.  tmp3 allReferencesTo: #printOn: do: [:arg1 |  tmp1 := tmp1 or: [ arg1 selector = #fullPrintString and: [ arg1 modelClass = (tmp3 classNamed: #Object) ] ].        tmp2 := tmp2 or: [ arg1 selector = #testReferencesPrintOn and: [ arg1 modelClass = (tmp3 classNamed: self class name) ] ] ].  self assert: tmp1.  self assert: tmp2pullUpInstanceVariables  | tmp1 |  tmp1 := self abstractSuperclass.  parent instanceVariableNames do: [:arg1 |  self performComponentRefactoring: (RBPullUpInstanceVariableRefactoring model: self model variable: arg1 class: tmp1) ]replace: arg1 with: arg2 ignoreCase: arg3  | tmp1 tmp2 |  tmp1 := RxParser preferredMatcherClass for: (RxParser new parse: arg1) ignoreCase: arg3.  tmp2 := arg2 readStream.  matchers add: tmp1 -> tmp2returnsIfTrue  ^self isNil ifTrue: [ 4 ]transform  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self classModelOf: method methodClass.  tmp2 := self classModelOf: class.  tmp3 := RBClassModelFactory rbMethod for: tmp2 source: method sourceCode selector: method selector.  tmp4 := method protocol.  tmp1 removeMethod: method selector.  tmp2 addMethod: tmp3.  tmp2 compile: tmp3 source classified: {tmp4}calls  ^self rewriteRule1: self name , self rewriteRule1includesCategory: arg1  ^(super includesCategory: arg1) and: [ environmentDictionaries anySatisfy: [:arg2 |  arg2 includesCategory: arg1 ] ]changeString  ^self class namedefinedClass  ^definedClassresetResult  classBlock: arg1  classBlock := arg1 testMethod1checkForSuperReferences  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: 'super `@message: `@args' do: [:arg1 :arg2 |  true ].  (tmp1 executeTree: parseTree initialAnswer: false) ifTrue: [ self refactoringError: 'Cannot move the method since it has a super message send.' ]performChange: arg1  self ignoreChangesWhile: [ self addUndo: arg1 execute ]classVariablesFor: arg1  ^classVariables at: arg1 name ifAbsent: [ #() ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' move: ''';     nextPutAll: category;     nextPutAll: ''' to: ';     nextPutAll: className.  arg1 nextPut: $)selectedSource  | tmp1 |  tmp1 := class sourceCodeFor: selector.  tmp1 ifNil: [ self refactoringFailure: 'Couldn''t find sources' ].  ((sourceInterval first between: 1 and: tmp1 size) and: [ sourceInterval last between: 1 and: tmp1 size ]) ifFalse: [ self refactoringFailure: 'Invalid interval' ].  ^tmp1 copyFrom: sourceInterval first to: sourceInterval lastsuperSends  | tmp1 |  tmp1 := self parseTreeRewriter.  tmp1 addSearch: 'super `@message: ``@args' -> ([:arg1 |  (class withAllSubclasses detect: [:arg2 |  arg2 includesSelector: arg1 selector ] ifNone: [ nil ]) isNil ] -> 'self `@message: ``@args').  self rewriteUsing: tmp1assignmentInBlock  [ ^self printString ] ensure: [ self close ]testBadInterval  self     shouldFail: (RBInlineMethodRefactoring inline: (13 to: 23) inMethod: #testMethod forClass: RBRefactoryTestDataApp);     shouldFail: (RBInlineMethodRefactoring inline: (14 to: 17) inMethod: #testMethod forClass: RBRefactoryTestDataApp);     shouldFail: (RBInlineMethodRefactoring inline: (24 to: 30) inMethod: #testMethod forClass: RBRefactoryTestDataApp);     shouldFail: (RBInlineMethodRefactoring inline: (1 to: 30) inMethod: #testMethod forClass: RBRefactoryTestDataApp)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' messageSend: ''';     nextPutAll: message;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)removeOldVariable  self flag: #todo.  (RBRemoveInstanceVariableChange remove: oldName from: self changeClass) executemyConditions  ^RBCondition withBlock: [ oldSelector numArgs + 1 = newSelector numArgs ifFalse: [ self refactoringFailure: newSelector printString , ' doesn''t have the proper number of arguments.' ].        self verifyInitializationExpression.        true ]preconditions  | tmp1 |  tmp1 := RBCondition hierarchyOf: class referencesInstanceVariable: variableName.  class realClass ifNil: [ tmp1 errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName) ] ifNotNil: [ tmp1           errorMacro: ('<1s> is referenced.<n>Browse references?' expandMacrosWith: variableName);           errorBlock: [ self openBrowserOn: (RBBrowserEnvironment new instVarRefsTo: variableName in: class realClass) ] ].  ^(RBCondition definesInstanceVariable: variableName asString in: class) & tmp1 notsafeVariableNameBasedOn: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := inlineParseTree allTemporaryVariables.  tmp1 := arg1 copy.  tmp1 at: 1 put: tmp1 first asLowercase.  tmp2 := tmp1.  tmp3 := 0.  [ (tmp4 includes: tmp2) or: [ class definesInstanceVariable: tmp2 ] ] whileTrue: [ tmp3 := tmp3 + 1.        tmp2 := tmp1 , tmp3 printString ].  ^tmp2hash  ^self name hash bitXor: self class hashoptions  ^options ifNil: [ options := self class refactoringOptions copy ]name  ^'Check for same statements at end of ifTrue:ifFalse: blocks'preconditions  ^isClassVariable ifTrue: [ self preconditionsForClassVariable ] ifFalse: [ self preconditionsForInstanceVariable ]testClassVariableToMultipleSubclassesFailure  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^Foo' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #AnotherSubclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo' classified: #(#accessing).  self shouldFail: (RBPushDownVariableTransformation model: model classVariable: #Foo class: (model classNamed: #SomeClass)) asRefactoringclassFor: arg1  arg1 ifNil: [ ^nil ].  ^arg1 isMeta ifTrue: [ self metaclassNamed: arg1 instanceSide name ] ifFalse: [ self classNamed: arg1 instanceSide name ]testVariableDoesNotExist  self shouldFail: (RBRemoveTemporaryVariableTransformation variable: 'temp123' inMethod: #foo inClass: #RBRemoveTemporaryVariableTransformationTest) asRefactoringtestAddClassTraitPattern  self exampleTraits do: [:arg1 |  | tmp1 |        tmp1 := changes defineClass: arg1 classTrait definition.        self assert: (tmp1 isKindOf: RBAddClassTraitChange).        self assert: tmp1 changeClassName equals: arg1 name.        self universalTestFor: tmp1 ]includesGlobal: arg1  (self hasRemoved: arg1) ifTrue: [ ^false ].  (self includesClassNamed: arg1) ifTrue: [ ^true ].  environment at: arg1 ifAbsent: [ ^false ].  ^trueperformChange: arg1 around: arg2  | tmp1 |  changes addChange: arg1.  tmp1 := changes.  changes := arg1.  arg2 ensure: [ changes := tmp1 ].  ^arg1keywords: arg1  keywords addAll: arg1changeClass  | tmp1 |  tmp1 := onSystemDictionary classNamed: self changeClassName.  ^isMeta ifTrue: [ tmp1 class ] ifFalse: [ tmp1 ]initialize  super initialize.  rewriteRule := RBParseTreeRewriter newfailedRules  ^rules inject: OrderedCollection new into: [:arg1 :arg2 |  arg1           addAll: arg2 failedRules;           yourself ]packages  ^self methods collect: [:arg1 |  arg1 package ]setterMethodFor: arg1  | tmp1 tmp2 |  tmp1 := self parseTreeSearcherClass setterMethod: arg1.  tmp2 := (self definesInstanceVariable: arg1) ifTrue: [ self whichSelectorsReferToInstanceVariable: arg1 ] ifFalse: [ self whichSelectorsReferToClassVariable: arg1 ].  tmp2 := tmp2 select: [:arg2 |  arg2 numArgs == 1 ].  ^tmp2 detect: [:arg2 |  (self checkSelector: arg2 using: tmp1) notNil and: [ (self subclassRedefines: arg2) not ] ] ifNone: [ nil ]testTransform  | tmp1 tmp2 tmp3 |  tmp2 := (self changeMock name , 'Temporary') asSymbol.  tmp1 := RBCompositeTransformation new transformations: (OrderedCollection new           add: (RBAddClassTransformation addClass: tmp2 superclass: #Object subclasses: #() category: self class category);           add: (RBAddVariableTransformation instanceVariable: 'asdf' class: tmp2);           add: (RBAddMethodTransformation sourceCode: 'printString1 ^super printString' in: tmp2 withProtocol: #accessing);           yourself).  tmp1 transform.  self assert: tmp1 model changes changes size equals: 3.  tmp3 := tmp1 model classNamed: (self changeMock name , 'Temporary') asSymbol.  self assert: (tmp3 directlyDefinesInstanceVariable: 'asdf').  self assert: (tmp3 parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')checkMethodsForClass: arg1  ^environment selectorsForClass: arg1 do: [:arg2 |  rule checkMethod: arg1 >> arg2.        methodBlock value ]move: arg1 to: arg2  self className: arg1.  category := arg2testRefactoring  | tmp1 tmp2 |  tmp1 := (RBExtractMethodTransformation extract: '(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)			ifFalse: [builder						compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]' from: #checkMethod: to: #foo: in: #RBTransformationRuleTestData) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 			class := aSmalllintContext selectedClass.			(rewriteRule executeTree: aSmalllintContext parseTree)				ifTrue: [self foo: aSmalllintContext]').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: aSmalllintContext 			(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: [ builder							compile: rewriteRule tree printString							in: class							classified: aSmalllintContext protocols ]')instanceVariableWriters: arg1  instanceVariableWriters := arg1typeOfClassVariable: arg1  ^model classNamed: #Objectcalled: arg1 on: arg2  Transcript     show: arg1 printString;     cr.  arg2 valueincludesSelector: arg1 in: arg2  ^(super includesSelector: arg1 in: arg2) and: [ environmentDictionaries anySatisfy: [:arg3 |  arg3 includesSelector: arg1 in: arg2 ] ]associationForClassVariable: arg1 in: arg2 ifAbsent: arg3  ^arg2 realClass classPool associationAt: arg1 asSymbol ifAbsent: [ arg2 realClass classPool associationAt: arg1 asString ifAbsent: arg3 ]setUp  super setUp.  model := self abstractVariableTestDatapushUpVariables  self pullUpInstanceVariables.  self pullUpClassInstanceVariables.  self pullUpClassVariables.  self pullUpPoolVariablescheckNewVariable: arg1  arg1 ifNil: [ self refactoringError: ('Temporary variable named {1} is not defined by this method.' format: {variableName asString}) ].  (arg1 whoDefines: newVariableName) ifNotNil: [ self refactoringError: ('Temporary variable named {1} is already defined.' format: {newVariableName asString}) ].  (arg1 allDefinedVariables includes: newVariableName) ifTrue: [ self refactoringError: ('Temporary variable named {1} is already defined.' format: {newVariableName asString}) ]testModelRenameSequenceClass  model defineClass: 'Object subclass: #Foo1 			instanceVariableNames: '''' 			classVariableNames: '''' poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #Foo1)     compile: 'foo	 ^ Foo1' classified: #(accessing);     compile: 'objectName ^ #(Foo1)' classified: #(accessing).  self executeRefactoring: (RBRenameClassRefactoring model: model rename: (model classNamed: #Foo1) to: #Foo2).  self executeRefactoring: (RBRenameClassRefactoring model: model rename: (model classNamed: #Foo2) to: #Foo3).  self deny: (model includesClassNamed: #Foo1).  self deny: (model includesClassNamed: #Foo2).  self assert: (model includesClassNamed: #Foo3).  self assert: ((model classNamed: #Foo3) parseTreeFor: #foo) equals: (self parseMethod: 'foo ^ Foo3').  self assert: ((model classNamed: #Foo3) parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^ #(Foo3)')isEmpty  ^classes isEmpty and: [ metaClasses isEmpty ]copyOptionsFrom: arg1  | tmp1 |  tmp1 := self options.  tmp1 == self class refactoringOptions ifTrue: [ ^self options: arg1 copy ].  tmp1 keysAndValuesDo: [:arg2 :arg3 |  arg3 == (self class refactoringOptions at: arg2) ifTrue: [ tmp1 at: arg2 put: (arg1 at: arg2) ] ].  self options: tmp1testWithTemporaryAssigned  | tmp1 tmp2 tmp3 |  model := RBNamespace2 new.  tmp1 := model classNamed: self class name.  tmp2 := 'foo			| temp bar |			bar := 5.			temp := bar * bar.			Transcript show: temp printString; cr.			^temp * temp'.  tmp1 compile: tmp2 classified: #(#accessing).  tmp3 := (RBExtractMethodTransformation model: model extract: (tmp2 copyFrom: 24 to: 98) from: #foo to: #foobar in: tmp1) asRefactoring transform.  self assert: tmp3 model changes changes size equals: 4.  self assert: (tmp1 parseTreeFor: #foo) equals: (self parseMethod: 'foo | temp | temp := self foobar. ^temp * temp').  self assert: (tmp1 parseTreeFor: #foobar) equals: (self parseMethod: 'foobar | temp bar | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.')at: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := self associationAt: arg1 ifAbsent: [ nil ].  ^tmp1 ifNil: [ arg2 value ] ifNotNil: [ tmp1 value ]addProtocolNamed: arg1 in: arg2  ^self addChange: (RBAddProtocolChange addProtocolNamed: arg1 in: arg2)privateTransform  | tmp1 tmp2 tmp3 |  tmp1 := self definingClass parseTreeFor: selector.  tmp1 ifNil: [ ^self ].  tmp2 := tmp1 extractSubtreeWith: oldSourceCode.  tmp2 ifNil: [ ^self ].  tmp3 := self parserClass parseExpression: newSourceCode onError: [:arg1 :arg2 |  ^nil ].  tmp3 ifNil: [ ^self ].  tmp1 := tmp2 isSequence ifTrue: [ self parseTreeRewriterClass replaceStatements: tmp2 formattedCode with: newSourceCode in: tmp1 ] ifFalse: [ self parseTreeRewriterClass replace: tmp2 formattedCode with: newSourceCode in: tmp1 onInterval: tmp1 sourceInterval ].  self definingClass compileTree: tmp1methodsDo: arg1  self classesDo: [:arg2 |  self selectorsForClass: arg2 do: [:arg3 |  arg1 value: arg2 >> arg3 ].        self selectorsForClass: arg2 class do: [:arg3 |  arg1 value: arg2 class >> arg3 ] ]uniqueMethodNameFor: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 'a'.  tmp2 := ''.  arg1 timesRepeat: [ tmp2 := tmp2 , 'z:' ].  tmp3 := 0.  [ tmp4 := tmp1 , tmp3 printString , tmp2.  (Symbol findInterned: tmp4) notNil ] whileTrue: [ tmp3 := tmp3 + 1 ].  ^tmp4 asSymboltestSelectorEnvironment  | tmp1 |  tmp1 := RBBrowserEnvironment new referencesTo: #printString.  self universalTestFor: tmp1.  self deny: universalEnvironment isSelectorEnvironment.  self assert: tmp1 isSelectorEnvironment.  self assert: tmp1 numberSelectors equals: (tmp1 referencesTo: #printString) numberSelectors.  self assert: tmp1 numberClasses equals: (tmp1 referencesTo: #printString) numberClassescheckInstanceVariableName: arg1 in: arg2  ^RBCondition checkInstanceVariableName: arg1 in: arg2storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' rename: '.  variableName storeOn: arg1.  arg1 nextPutAll: ' to: '.  newVariableName storeOn: arg1.  arg1 nextPutAll: ' class: '.  class storeOn: arg1.  arg1 nextPutAll: ' classVariable: '.  isClassVariable storeOn: arg1.  arg1 nextPut: $)changeString  ^'Define ' , self displayClassNamemethod  ^compiledMethodpreconditions  self subclassResponsibilityhash  ^self class hash bitXor: self changes size hashtestRefactoring  | tmp1 tmp2 |  tmp1 := (RBReplaceSubtreeTransformation replace: 'selector := aSelector' to: '^ selector' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBRemoveMethodTransformation.  self assert: (tmp2 directlyDefinesMethod: #selector:from:).  self assert: (tmp2 parseTreeFor: #selector:from:) body statements size equals: 2.  self assert: (tmp2 parseTreeFor: #selector:from:) body statements last isReturnsetUp  super setUp.  model := self abstractVariableTestDatatestVariableDoesNotExist  self shouldFail: (RBRenameTemporaryVariableTransformation rename: #rule to: #name in: #RBLintRuleTestData selector: #openEditor)testRefactoring  self     shouldFail: (RBAddSubtreeTransformation interval: (0 to: 1) with: ':= 123' from: #selector:from: in: #RBRemoveMethodTransformation) asRefactoring;     shouldFail: (RBAddSubtreeTransformation interval: (0 to: 1) with: '^ selector' from: #selector:for: in: #RBRemoveMethodTransformation) asRefactoringsendInlineParameterMethod  ^self inlineParameterMethod: #(#asdf)problemCount  ^builder problemCountstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' pragma: ''';     nextPutAll: pragma;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)testExtractToTemporaryWithDuplicates  | tmp1 |  tmp1 := RBExtractToTemporaryRefactoring extract: (73 to: 77) to: 'temp' from: #demoMethodWithDuplicates in: RBRefactoryTestDataApp.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #demoMethodWithDuplicates) equals: (self parseMethod: 'demoMethodWithDuplicates	| a b result1 result2 answer temp |	a := 3.	temp := a + 5.	b := temp.	result1 := a + b.	result2 := temp.	answer := result1 + result2 + temp.	^ answer')rootClass  ^rootClass ifNil: [ Object ]whichSelectorsReferToClassVariable: arg1  | tmp1 |  tmp1 := Set new.  newMethods ifNotNil: [ newMethods do: [:arg2 |  (arg2 refersToVariable: arg1) ifTrue: [ tmp1 add: arg2 selector ] ] ].  self isDefined ifTrue: [ tmp1 addAll: (self existingMethodsThatReferToClassVariable: arg1) ].  ^tmp1theMetaClass  ^model metaclassNamed: self namenewName  ^newNamecalculateAssignments  ^assignments ifNil: [ | tmp1 tmp2 |        tmp1 := (parseTree allChildren select: #isSequence) last.        assignments := temporaries select: [:arg1 |  tmp2 := tmp1 whoDefines: arg1.              tmp2 statements anySatisfy: [:arg2 |  (arg2 references: arg1) and: [ (subtree allChildren includes: arg2) not ] ] ] ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ' value: ''';     nextPutAll: value;     nextPutAll: ' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: ''';     nextPutAll: className.  arg1 nextPut: $)check: arg1 ifNoCritiques: arg2  | tmp1 |  tmp1 := OrderedCollection new.  self check: arg1 forCritiquesDo: [:arg3 |  tmp1 add: arg3 ] ifNone: arg2.  ^tmp1preconditions  ^(RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ self parserClass parseExpression: sourceCode onError: [:arg1 :arg2 |  self refactoringError: 'Invalid source to add - ' , arg1 ].              true ])debbuggingMessageSent  self rearmOneShottestClassEnvironment  | tmp1 |  tmp1 := RBClassEnvironment onEnvironment: universalEnvironment classes: (Array with: Object with: Object class).  self universalTestFor: tmp1.  self deny: universalEnvironment isClassEnvironment.  self assert: tmp1 isClassEnvironment.  self assert: tmp1 packages size equals: 1.  self assert: (tmp1 implementorsOf: #printString) numberSelectors equals: 1.  self assert: (RBClassEnvironment class: Class) selectors size equals: Class methods size.  self assert: (RBClassEnvironment class: TSortable) selectors size equals: TSortable methods sizeisPrimitive  ^inlineParseTree isPrimitivereference  ^RBDummyClassToRename newaddMethodSource: arg1 in: arg2 classified: arg3 for: arg4  ^RBAddMethodChange compile: arg1 in: arg2 classified: arg3 for: arg4preconditions  ^classVariable ifTrue: [ RBCondition definesClassVariable: variableName asSymbol in: class ] ifFalse: [ RBCondition definesInstanceVariable: variableName in: class ]whileTrue  | tmp1 |  tmp1 := 1.  [ tmp1 < self size ] whileTrue: [ (self at: tmp1) printString.        tmp1 := tmp1 + 1 ]redoOperation  redo ifEmpty: [ ^self ].  self ignoreChangesWhile: [ | tmp1 |        tmp1 := redo removeLast.        undo add: tmp1 execute ]preconditions  | tmp1 |  tmp1 := ((RBCondition isMetaclass: superclass) errorMacro: 'Superclass must not be a metaclass') not.  tmp1 := subclasses inject: tmp1 into: [:arg1 :arg2 |  arg1 & ((RBCondition isMetaclass: arg2) errorMacro: 'Subclass must <1?not :>be a metaclass') not & (RBCondition isImmediateSubclass: arg2 of: superclass) ].  ^tmp1 & (RBCondition isValidClassName: className) & (RBCondition isGlobal: className in: self model) not & (RBCondition isSymbol: category) & ((RBCondition withBlock: [ category isNotEmpty ]) errorMacro: 'Invalid category name')testTemporaryToInstanceVariable  | tmp1 tmp2 |  tmp1 := RBTemporaryToInstanceVariableRefactoring class: RBLintRuleTestData selector: #displayName variable: 'nameStream'.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self assert: (tmp2 parseTreeFor: #displayName) equals: (self parseMethod: 'displayName								nameStream := WriteStream on: (String new: 64).								nameStream									nextPutAll: self name;									nextPutAll: '' (''.								self problemCount printOn: nameStream.								nameStream nextPut: $).								^nameStream contents').  self assert: (tmp2 directlyDefinesInstanceVariable: 'nameStream')bindingOf: arg1  ^self realClass classPool associationAt: arg1 asSymbol ifAbsent: [ self realClass classPool associationAt: arg1 asString ifAbsent: [ nil ] ]abstractVariableTestData  | tmp1 tmp2 tmp3 |  tmp3 := #(#Bar #Foo) inject: OrderedCollection new into: [:arg1 :arg2 |  testingEnvironment at: arg2 ifPresent: [:arg3 |  arg1                 add: arg3;                 add: arg3 class ].        arg1 ].  tmp2 := RBClassEnvironment classes: tmp3.  tmp1 := RBNamespace2 onEnvironment: tmp2 not.  tmp1 name: 'Test'.  #('Object subclass: #Foo		instanceVariableNames: ''instVarName1 instVarName2''		classVariableNames: ''ClassVarName1 ClassVarName2 ''		poolDictionaries: ''''		category: ''Testing'' ' 'Foo subclass: #Bar		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ') do: [:arg2 |  tmp1 defineClass: arg2 ].  #(#(#Bar #(#('instVarName1			^1242321' #tests) #('foo			instVarName1 := instVarName1 + instVarName2 + ClassVarName1' #tests))) #(#Foo #(#('foo			^instVarName2 := 3' #tests) #('bar			"Add one to instVarName1"			instVarName1 := instVarName1 + 1' #tests) #('classVarName1			^ClassVarName1' #tests) #('instVarName1: anObject			^anObject' #tests) #('asdf			^self classVarName1: (ClassVarName1 := ClassVarName1 + 1)' #tests) #('instVarName2			^instVarName2' #tests) #('instVarName2: anObject			instVarName2 := anObject' #tests) #('classVarName1: anObject			^ClassVarName1 := anObject' #tests))) #('Bar class' #(#('classVarName2: anObject			ClassVarName2 := anObject' #tests) #('classVarName2			^ClassVarName2' #tests))) #('Foo class' #(#('foo			^ClassVarName1 := ClassVarName1 * ClassVarName1 * ClassVarName1' #tests)))) do: [:arg2 |  | tmp4 |        arg3 := tmp1 classNamed: arg2 first.        arg2 last do: [:arg4 |  arg3 compile: arg4 first classified: arg4 last ] ].  ^tmp1= arg1  ^self class = arg1 class and: [ self name = arg1 name and: [ self model = arg1 model ] ]problemCount  ^result problemCountcomputeNewSelector  | tmp1 |  oldSelector numArgs == 0 ifTrue: [ self refactoringFailure: 'This method contains no arguments' ].  oldSelector isInfix ifTrue: [ self refactoringFailure: 'Cannot remove parameters of infix selectors' ].  tmp1 := oldSelector keywords asOrderedCollection.  tmp1 size = 1 ifTrue: [ ^(tmp1 first copyWithout: $:) asSymbol ].  tmp1 removeAt: parameterIndex.  ^(String streamContents: [:arg1 |  tmp1 do: [:arg2 |  arg1 nextPutAll: arg2 ] ]) asSymbolabstractReferenceTo: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := RBCreateAccessorsForVariableRefactoring variable: arg1 class: newClass classVariable: false.  self performComponentRefactoring: tmp3.  tmp4 := tmp3 getterMethod.  tmp1 := tmp3 setterMethod.  tmp2 := RBParseTreeRewriter variable: arg1 getter: tmp4 setter: tmp1 receiver: referenceVariableName.  self convertClasses: class withAllSubclasses select: [:arg2 |  arg2 whichSelectorsReferToInstanceVariable: arg1 ] using: tmp2.  self performComponentRefactoring: (RBRemoveInstanceVariableRefactoring remove: arg1 from: class)defineClass: arg1  | tmp1 tmp2 tmp3 |  tmp1 := changes defineClass: arg1.  tmp3 := tmp1 changeClassName.  tmp2 := self classNamed: tmp3.  tmp2 ifNil: [ | tmp4 |        self unmarkAsRemoved: ' class'.        tmp2 := self rbClassClass named: tmp3.        tmp4 := self rbMetaclassClass named: tmp3.        tmp2 model: self.        tmp4 model: self.        newClasses at: tmp3 put: (Array with: tmp2 with: tmp4) ].  tmp2 superclass: (self classNamed: tmp1 superclassName).  tmp2 superclass ifNil: [ self rootClasses add: tmp2.        tmp2 theMetaClass superclass: (self classFor: Object class superclass) ] ifNotNil: [ tmp2 theMetaClass superclass: tmp2 superclass theMetaClass ].  tmp2 instanceVariableNames: tmp1 instanceVariableNames.  tmp2 classVariableNames: tmp1 classVariableNames.  tmp2 poolDictionaryNames: tmp1 sharedPoolNames.  tmp2 category: tmp1 category.  ^tmp1testPullUpReferencesInstVar  self shouldFail: (RBPullUpMethodRefactoring pullUp: #(#checkClass:) from: RBBasicLintRuleTestData)transform  self renameImplementors.  self renameMessageSends.  self removeRenamedImplementorstestModelRenameClass  | tmp1 tmp2 tmp3 tmp4 |  model defineClass: 'Object subclass: #ClassDeprecatorTestingClassReplacement instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'ClassDeprecatorTestingClassReplacement subclass: #ClassDeprecatorTestingClassDeprecated instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'ClassDeprecatorTestingClassDeprecated subclass: #ClassDeprecatorTestingClassDeprecatedUser instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  tmp2 := model classNamed: #ClassDeprecatorTestingClassReplacement.  tmp3 := model classNamed: #ClassDeprecatorTestingClassDeprecated.  tmp4 := model classNamed: #ClassDeprecatorTestingClassDeprecatedUser.  tmp4     compile: 'foo	^ClassDeprecatorTestingClassDeprecated' classified: #(#accessing);     compile: 'objectName ^#(ClassDeprecatorTestingClassDeprecated)' classified: #(#accessing).  tmp1 := RBApplyClassDeprecationRefactoring model: model rename: tmp3 to: #ClassDeprecatorTestingClassReplacement.  tmp1 shouldCopyExtensions: false.  tmp1 shouldRemoveExtensions: false.  self executeRefactoring: tmp1.  self assert: (model includesClassNamed: #ClassDeprecatorTestingClassReplacement).  self assert: (model includesClassNamed: #ClassDeprecatorTestingClassDeprecated).  self assert: (model includesClassNamed: #ClassDeprecatorTestingClassDeprecatedUser).  self assert: (model classNamed: #ClassDeprecatorTestingClassReplacement) equals: tmp2.  self assert: (model classNamed: #ClassDeprecatorTestingClassDeprecated) equals: tmp3.  self assert: (model classNamed: #ClassDeprecatorTestingClassDeprecatedUser) equals: tmp4.  self assert: (tmp4 parseTreeFor: #foo) equals: (self parseMethod: 'foo ^ClassDeprecatorTestingClassReplacement').  self assert: (tmp4 parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^#(ClassDeprecatorTestingClassReplacement)').  self assert: tmp4 superclass name equals: #ClassDeprecatorTestingClassReplacementpackages  ^self rootEnvironment packages select: [:arg1 |  self includesPackage: arg1 ]resetResult  super resetResult.  self result matcher: self matchertestRecursiveMethod  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := model classNamed: #Object.  tmp3 := 'someMethodThatIsNotReferenced' asSymbol.  tmp2 compile: 'someMethodThatIsNotReferenced ^2' classified: #(#accessing).  self assert: (tmp2 definesMethod: tmp3).  tmp4 := model metaclassNamed: self class superclass name.  tmp4 compile: 'someMethodThatIsNotReferenced ^3 someMethodThatIsNotReferenced' classified: #(#accessing).  model removeClassNamed: self class name.  tmp1 := (RBRemoveMethodTransformation model: model selector: tmp3 from: tmp2) asRefactoring.  [ tmp1 transform ] on: RBRefactoringError do: [:arg1 |  arg1 resume ].  self deny: (tmp2 definesMethod: tmp3)testPullUpClassMethod  | tmp1 |  tmp1 := model classNamed: #Object.  tmp1 addClassVariable: #Foo.  tmp1 classSide compile: 'foo ^Foo' classified: #(#accessing).  self shouldFail: (RBPullUpMethodRefactoring model: model pullUp: #(#foo) from: tmp1 classSide)whatToDisplayIn: arg1  ^{self}forPragmas: arg1  ^RBPragmaEnvironment onEnvironment: self keywords: arg1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' return: ''';     nextPutAll: returnValue;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)buildSimpleVariableSearch  self createSearchWith: 'result' selectors: #(#checkClass: #checkMethod: #isEmpty #problemCount #resetResult #resetResult #resetResult #result #result: #resultClass: #newResultClass: #viewResults) inClass: RBBasicLintRuleTestDataprecedence  ^self isArray ifFalse: [ (self block + 5) * 34 ] ifTrue: [ self printString = 10 ]changeClassName  ^classNameallExpressionsToInline  | tmp1 |  tmp1 := Set new.  self model allReferencesTo: oldSelector do: [:arg1 |  | tmp2 |        tmp2 := arg1 parseTree.        tmp2 ifNotNil: [ tmp1 addAll: (self expressionsToInlineFrom: tmp2) ] ].  ^tmp1 asOrderedCollectionisEmpty  ^rules allSatisfy: [:arg1 |  arg1 isEmpty ]includesSelector: arg1 in: arg2  ^(environment includesSelector: arg1 in: arg2) notincludesSelector: arg1 in: arg2  ^(environment includesSelector: arg1 in: arg2) and: [ (self selectorCacheFor: arg2) includes: arg1 ]parseTreeSearcherClass  ^RBParseTreeSearchergtInspectorPreviewIn: arg1  < gtInspectorPresentationOrder: 0>  self changes ifNil: [ ^self ].  self changes gtInspectorPreviewIn: arg1testTransform  | tmp1 tmp2 |  tmp1 := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  tmp1 := (RBExtractMethodTransformation model: tmp1 model extract: 'bar := 5.							temp := bar * bar.							Transcript show: temp printString; cr' from: #foo to: #foobar in: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 4.  tmp2 := tmp1 model classNamed: self changeMock name.  self assert: (tmp2 parseTreeFor: #foo) equals: (self parseMethod: 'foo													| temp |													temp := self foobar.													^temp * temp').  self assert: (tmp2 parseTreeFor: #foobar) equals: (self parseMethod: 'foobar													| temp bar |													bar := 5.													temp := bar * bar.													Transcript show: temp printString; cr.													^temp.')testPullUpVariableNotDefined  self shouldFail: (RBPullUpInstanceVariableRefactoring variable: 'notDefinedVariable' class: RBLintRuleTestData)hasRemoved: arg1  ^removedMethods notNil and: [ removedMethods includes: arg1 ]testPerformChangeComment  | tmp1 tmp2 |  tmp1 := changes comment: 'Some Comment' in: self changeMock.  tmp2 := tmp1 changeClass organization classComment.  self perform: tmp1 do: [ self assert: tmp1 changeClass comment equals: 'Some Comment' ].  self assert: tmp1 changeClass organization classComment equals: tmp2transform  replaceAll := false.  listToFindMatches ifNil: [ (self options at: #listToSearch) value: method value: self ].  listToFindMatches first isClass ifTrue: [ self findOcurrencesInClasses ] ifFalse: [ self findOcurrencesIn: listToFindMatches ]ifTrueReturns  self isSymbol ifFalse: [ ^true ].  ^falsecheckPreconditions  | tmp1 tmp2 |  tmp1 := self preconditions.  tmp2 := tmp1 check.  tmp2 ifFalse: [ self refactoringError: tmp1 errorString ].  ^tmp2openBrowserOn: arg1  ^(self options at: #openBrowser) value: self value: arg1replaceInstanceAccesses  | tmp1 tmp2 |  tmp2 := receiver isNotNil.  tmp1 := RBParseTreeRewriter variable: variableName getter: self getterMethod setter: self setterMethod receiver: self receiver.  self model convertClasses: self definingClass withAllSubclasses select: [:arg1 |  | tmp3 |        tmp3 := arg1 whichSelectorsReferToInstanceVariable: variableName.        tmp2 ifTrue: [ tmp3 ] ifFalse: [ tmp3 reject: [:arg2 |  arg1 == self definingClass and: [ arg2 == self getterMethod or: [ arg2 == self setterMethod ] ] ] ] ] using: tmp1argumentsOf: arg1  | tmp1 tmp2 |  tmp2 := method argumentNames size - 1.  tmp1 := OrderedCollection new.  0 to: tmp2 do: [:arg2 |  tmp1 add: (arg1 at: (arg1 keys detect: [:arg3 |  arg3 name asString = ('`@argMatch' , arg2 asString) ])) sourceCode ].  ^tmp1asUndoOperation  ^changeFactory removeInstanceVariable: self variable from: self changeClasstransform  self     reparentSubclasses;     removeClassesarguments  ^argumentsdemoExampleCall  ^self demoRenameMethod: 1 PermuteArgs: 2testMessageDoesNotExist  self shouldFail: (RBRemoveMessageSendTransformation messageSend: #byteAt123: inMethod: #methodBefore inClass: #RBRemoveMessageSendTransformationTest) asRefactoringcheckSuperMethods  (self justSendsSuper: selector) ifTrue: [ ^self ] ifFalse: [ (self superclassEquivalentlyDefines: selector) ifTrue: [ (self definingClass parseTreeFor: selector) superMessages ifNotEmpty: [ self refactoringError: ('Although <1s> is equivalent to a superclass method,<n>							it contains a super send so it might modify behavior.' expandMacrosWith: selector) ] ] ifFalse: [ self checkReferences ] ]foo: arg1  ^(1 to: 10) inject: arg1 into: [:arg2 :arg3 |  arg2 + arg3 ]equalityTestFor: arg1  self assert: arg1 equals: arg1.  self assert: arg1 hash equals: arg1 hash.  self assert: arg1 copy equals: arg1.  self assert: arg1 copy hash equals: arg1 hashlongMethods  self printString.  self printString.  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ]testBadInterval  self     shouldFail: (RBExtractMethodToComponentRefactoring extract: (24 to: 30) from: #testMethod in: RBRefactoryTestDataApp);     shouldFail: (RBExtractMethodToComponentRefactoring extract: (80 to: 147) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class)nonUnaryAccessingMethodWithoutReturn: arg1  testTransformOneOfManyStatements  | tmp1 tmp2 |  tmp1 := (RBReplaceSubtreeTransformation replace: 'self assert: (class parseTreeFor: #selector:from:) body statements size equals: 2' to: 'self assert: (class parseTreeFor: #selector:from:) body statements size = 2' inMethod: #testRefactoring inClass: #RBReplaceSubtreeTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBReplaceSubtreeTransformationTest.  self assert: (tmp2 directlyDefinesMethod: #testRefactoring).  self assert: (tmp2 parseTreeFor: #testRefactoring) body statements size equals: 6.  self assert: ((((tmp2 parseTreeFor: #testRefactoring) body statements at: 5) sourceCode withBlanksCondensed copyReplaceAll: String cr with: ' ') includesSubstring: 'assert: (class parseTreeFor: #selector:from:) body statements size = 2')changes: arg1  changes := arg1clearUndoRedoList  undo := Stack new.  redo := OrderedCollection new.  undoPointers := Stack newnameToDisplay  ^self changeStringgetClassesForInstanceVariable  | tmp1 tmp2 tmp3 |  tmp1 := class whoDefinesInstanceVariable: variable.  tmp2 := RBRefactoryTyper newFor: self model.  tmp2 runOn: tmp1.  tmp3 := tmp2 typesFor: variable.  tmp3 ifEmpty: [ tmp3 := OrderedCollection with: (self model classNamed: #Object) ].  moveToClasses := self selectVariableTypesFrom: tmp3 selected: (tmp2 guessTypesFor: variable).  moveToClasses ifNil: [ self refactoringFailure: 'Method not moved' ]methodClass  ^classabstractVariableReferences  instanceVariables do: [:arg1 |  self abstractReferenceTo: arg1 ]addSelfReturn  self hasOnlySelfReturns ifTrue: [ ^self ].  parseTree addSelfReturnfoobar  ^#(true false)changeSymbol  ^#addInstVarNamed:testMovePrimitiveMethod  | tmp1 |  (model classNamed: #Object) compile: 'foo <primitive: 100> ^#() primitiveFailed' classified: #(#accessing).  tmp1 := RBMoveMethodRefactoring model: model selector: #foo class: Object variable: 'OrderedCollection'.  self shouldFail: tmp1numberSelectors  | tmp1 |  tmp1 := 0.  self selectorsDo: [:arg1 |  tmp1 := tmp1 + 1 ].  ^tmp1definesInstanceVariable: arg1  (self directlyDefinesInstanceVariable: arg1) ifTrue: [ ^true ].  ^self superclass notNil and: [ self superclass definesInstanceVariable: arg1 ]runOn: arg1  variableTypes := Dictionary new.  variableMessages := Dictionary new.  bestGuesses := Dictionary new.  class := model classFor: arg1.  class instanceVariableNames isEmpty ifTrue: [ ^self ].  self     selectedClass: arg1;     computeEquivalenceClassesForMethodsAndVars;     computeMessagesSentToVariables;     computeTypes;     refineTypesByLookingAtAssignmentspackages  ^(self methods collect: #package) asSettestInlineTemporary  | tmp1 |  tmp1 := RBInlineTemporaryRefactoring inline: (24 to: 72) from: #inlineMethod in: RBRefactoryTestDataApp.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineMethod) equals: (self parseMethod: 'inlineMethod										^self													foo;													inlineMethod;													bar')resumeIfCannotRemove: arg1  ^arg1 messageText = RBRemoveClassTransformation cannotRemoveTopLevelClassErrorMesssage ifTrue: [ arg1 resume ]primitiveExecute  self changeClass organization addCategory: protocolpreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'No such class or trait named ' , className) & (RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ (self definingMethod allTemporaryVariables includes: variableName) not ] errorString: 'Method named ' , selector , ' already defines a temporary variable named ' , variableName) & (RBCondition withBlock: [ (self definingMethod allArgumentVariables includes: variableName) not ] errorString: 'Method named ' , selector , ' already defines an argument named ' , variableName)keysFor: arg1  | tmp1 |  tmp1 := IdentitySet withAll: arg1 keys.  tmp1 addAll: arg1 not keys.  tmp1 removeAll: testingEnvironment keys.  self assertEmpty: tmp1safeMethodNameFor: arg1 basedOn: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg2 copy.  tmp1 at: 1 put: tmp1 first asLowercase.  tmp2 := tmp1.  tmp3 := tmp2 last = $:.  tmp3 ifTrue: [ tmp1 := tmp2 copyFrom: 1 to: tmp2 size - 1 ].  tmp4 := 0.  [ arg1 hierarchyDefinesMethod: tmp2 asSymbol ] whileTrue: [ tmp4 := tmp4 + 1.        tmp2 := tmp1 , tmp4 printString , (tmp3 ifTrue: [ ':' ] ifFalse: [ '' ]) ].  ^tmp2 asSymbolselector: arg1  selector := arg1contains  ^((1 to: 10) detect: [:arg1 |  arg1 > 2 ] ifNone: [ nil ]) isNiltestConditions  | tmp1 tmp2 |  tmp1 := RBCondition new type: #false block: [ false ] errorString: 'false'.  tmp1 errorMacro: '<1?true:false>'.  self deny: tmp1 check.  self assert: tmp1 errorString equals: 'false'.  self assert: tmp1 not check.  self assert: tmp1 printString equals: 'false'.  self assert: tmp1 not printString equals: 'NOT false'.  self deny: (tmp1 not & tmp1) check.  self assert: (tmp1 not & tmp1) printString equals: 'NOT false & false'.  self assert: (tmp1 & tmp1) not check.  self assert: (tmp1 | tmp1 not) check.  self deny: (tmp2 := tmp1 | tmp1) check.  self assert: tmp2 errorString equals: 'false AND false'.  self assert: (tmp1 not | tmp1 not) check.  self deny: (tmp2 := tmp1 & tmp1) check.  self assert: tmp2 errorString equals: 'false'.  self assert: (tmp1 not & tmp1 not) check.  self assert: (tmp1 & tmp1) errorString equals: 'false OR false'someOtherDemoMethod  | tmp1 |  tmp1 := self new.  ^tmp1 junkanchorFor: arg1  ^ReSourceAnchor entity: arg1checkBlocksIn: arg1  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1     matches: '[:`@args | | `@temps | `@.Statements]' do: [:arg2 :arg3 |  arg3 ];     matches: variableName do: [:arg2 :arg3 |  true ].  ^tmp1 executeTree: arg1 initialAnswer: falsemethod: arg1  compiledMethod := arg1selector: arg1  selector := arg1.  parseTree := compiledMethod := nilinitialize  super initialize.  changeFactory := RBRefactoryChangeFactory new.  self clearUndoRedoList.  isPerformingRefactoring := false.  self connectToChangestestCheckInvalidMethodName  self deny: (RBCondition checkMethodName: 'fofo fo').  self deny: (RBCondition checkMethodName: '123fofo').  self deny: (RBCondition checkMethodName: 'foo::').  self deny: (RBCondition checkMethodName: 'agr:goo:aa').  self deny: (RBCondition checkMethodName: 'foo:123:').  self deny: (RBCondition checkMethodName: 'foo[arg]').  self deny: (RBCondition checkMethodName: 'foo:=arg').  self deny: (RBCondition checkMethodName: 'foo:arg)').  self deny: (RBCondition checkMethodName: 'foo:(arg)').  self deny: (RBCondition checkMethodName: 'foo:+arg)').  self deny: (RBCondition checkMethodName: '<<foo:<<arg)').  self deny: (RBCondition checkMethodName: 'foo:agr^:').  self deny: (RBCondition checkMethodName: 'foo:agr')newExtractedSelector  ^newExtractedSelectorname  ^'Code Rewriting'definingClass  ^self model classObjectFor: classtheClass  ^(self classObjectFor: className) instanceSidepackages  ^packagesassociationAt: arg1  ^self associationAt: arg1 ifAbsent: [ self error: arg1 printString , ' not found' ]testModelPushDownToMultipleSubclassesFailure  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^Foo' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo' classified: #(#accessing).  self shouldFail: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: (model classNamed: #SomeClass))renameReferences  | tmp1 tmp2 |  tmp1 := RBParseTreeRewriter rename: variableName to: newName handler: [ self refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' expandMacrosWith: newName) ].  tmp2 := class methodsUsingClassVariableNamed: variableName.  tmp2 do: [:arg1 |  self convertMethod: arg1 selector for: arg1 modelClass using: tmp1 ]testAbstractWithAssignmentUsed  | tmp1 tmp2 |  tmp2 := model classNamed: #Foo.  tmp1 := RBAbstractInstanceVariableRefactoring model: model variable: 'instVarName2' class: tmp2.  self executeRefactoring: tmp1.  self assert: (tmp2 parseTreeFor: #foo) equals: (self parseMethod: 'foo						^self instVarName21: 3').  self assert: (tmp2 parseTreeFor: #instVarName2:) equals: (self parseMethod: 'instVarName2: anObject						self instVarName21: anObject').  self assert: (tmp2 parseTreeFor: #instVarName21:) equals: (self parseMethod: 'instVarName21: anObject						^instVarName2 := anObject').  self assert: (tmp2 parseTreeFor: #instVarName2) equals: (self parseMethod: 'instVarName2						^instVarName2').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo						instVarName1 := instVarName1 + self instVarName2 + ClassVarName1')privateTransform  self replaceInstanceAccesses.  isClassVariable ifTrue: [ self replaceClassAccesses ]renameChangesForClass: arg1 to: arg2  ^self copy     changes: (self changes collect: [:arg3 |  arg3 renameChangesForClass: arg1 to: arg2 ]);     yourselfcompileCode  class compileTree: (RBParseTreeRewriter replaceStatements: sequenceNode formattedCode with: transformedNode formattedCode in: self parseTree onInterval: selectedInterval)testDefineClassAfterDeletedChange  | tmp1 |  tmp1 := modelFactory rbNamespace new.  tmp1 removeClassNamed: self class name.  self deny: (tmp1 includesClassNamed: self class name).  tmp1 defineClass: self class oldDefinition.  self assert: (tmp1 includesClassNamed: self class name).  self assert: (tmp1 classNamed: self class name) notNilstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' variable: '.  variableName storeOn: arg1.  arg1 nextPutAll: ' class: '.  className storeOn: arg1.  arg1 nextPutAll: ' classVariable: '.  isClassVariable storeOn: arg1.  arg1 nextPut: $)primitiveExecute  ^self subclassResponsibilitytransform  self model renameClass: class to: newName around: [ self renameReferences ]renameInstanceVariable: arg1 to: arg2 in: arg3 around: arg4  ^self performChange: (changeFactory renameInstanceVariable: arg1 to: arg2 in: arg3) around: arg4renameClassVariable: arg1 to: arg2 in: arg3 around: arg4  ^self performChange: (changeFactory renameClassVariable: arg1 to: arg2 in: arg3) around: arg4testInstanceVariableToMultipleSubclasses  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''foo''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #AnotherSubclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #AnotherSubclass) compile: 'bar ^foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model instanceVariable: 'foo' class: (model classNamed: #SomeClass)) asRefactoring transform.  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #AnotherSubclass) directlyDefinesVariable: 'foo')propagateTransformation  testInlineRecursiveCascadedMethod  | tmp1 |  tmp1 := RBInlineMethodRefactoring inline: (33 to: 62) inMethod: #inlineMethod forClass: RBRefactoryTestDataApp.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineMethod) equals: (self parseMethod: 'inlineMethod									| temp temp1 |									self foo.									temp1 := self foo; inlineMethod; bar.									temp := self bar.									^temp')changeFactory  ^changeFactorytestPrimitiveMethods  | tmp1 |  (model classNamed: #Object) compile: 'foo123: a <primitive: 100> ^#() primitiveFailed' classified: #(#accessing).  tmp1 := RBRemoveParameterRefactoring model: model removeParameter: 'a' in: Object selector: #foo123:.  self shouldFail: tmp1testMethodSendsSuper  < expectedFailure>  self shouldFail: (RBRemoveMethodTransformation selector: #new from: RBBasicLintRuleTestData class) asRefactoringselectionInterval  ^1 to: 0checkSelector: arg1 using: arg2  | tmp1 |  tmp1 := self parseTreeFor: arg1.  tmp1 ifNotNil: [ arg2 executeTree: tmp1 ].  ^arg2 answerremoveRule: arg1  (rules anySatisfy: [:arg2 |  arg2 name = arg1 name ]) ifTrue: [ rules := rules reject: [:arg2 |  arg2 name = arg1 name ] ] ifFalse: [ rules do: [:arg2 |  arg2 isComposite ifTrue: [ arg2 removeRule: arg1 ] ] ]modifiesCollection  | tmp1 |  tmp1 := (1 to: 10) asOrderedCollection.  tmp1 do: [:arg1 |  arg1 > 5 ifTrue: [ tmp1 remove: arg1 ] ].  ^tmp1demoExampleCall  ^self demoRenameMethod: 1 PermuteArgs: 2testPullUpWhenSuperClassDoesNotDirectlyImplement  | tmp1 tmp2 |  tmp2 := #(#ClassA #ClassB #ClassC) inject: OrderedCollection new into: [:arg1 :arg2 |  testingEnvironment at: arg2 ifPresent: [:arg3 |  arg1                 add: arg3;                 add: arg3 class ].        arg1 ].  tmp1 := RBClassEnvironment classes: tmp2.  model name: 'Test'.  #('Object subclass: #ClassA		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ' 'ClassA subclass: #ClassB		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ' 'ClassB subclass: #ClassC		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ') do: [:arg2 |  model defineClass: arg2 ].  #(#(#ClassA #(#('foo			^ ''ClassA foo''' #private))) #(#ClassC #(#('foo			^ ''ClassC foo''' #private)))) do: [:arg2 |  | tmp3 |        arg3 := model classNamed: arg2 first.        arg2 last do: [:arg4 |  arg3 compile: arg4 first classified: arg4 last ] ].  self shouldntWarn: (RBPullUpMethodRefactoring model: model pullUp: #(#foo) from: (model classNamed: #ClassC))forMethod: arg1 fromClass: arg2 toClasses: arg3  fromClass := self model classFor: arg2.  parseTree := arg1.  toClasses := arg3 collect: [:arg4 |  self model classFor: arg4 ]problemCount  ^self builder problemCountaccessorsRefactoring  ^accessorsRefactoring ifNil: [ accessorsRefactoring := RBCreateAccessorsForVariableRefactoring model: self model variable: variableName asString class: class classVariable: true ] ifNotNil: [ accessorsRefactoring ]classesAndTraits  | tmp1 |  tmp1 := OrderedCollection new: 4096.  self classesAndTraitsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1 asArraytestTransform  | tmp1 |  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmpty.  tmp1 := (RBMethodProtocolTransformation new protocol: 'empty protocol 2' inMethod: #someMethod inClass: #RBDummyEmptyClass) transform.  RBRefactoryChangeManager instance performChange: tmp1 changes.  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmpty not.  tmp1 := (RBMethodProtocolTransformation new protocol: 'empty protocol 1' inMethod: #someMethod inClass: #RBDummyEmptyClass) transform.  RBRefactoryChangeManager instance performChange: tmp1 changes.  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmptychangeString  ^self displayClassNamestoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' name: #';     nextPutAll: className;     nextPutAll: ' class: '.  parent storeOn: arg1.  arg1 nextPutAll: ' subclasses: '.  subclasses asArray storeOn: arg1.  arg1 nextPut: $)testModelInlineMethodWithSameVariableNames1  | tmp1 tmp2 |  model := RBClassModelFactory rbNamespace new.  tmp1 := model classNamed: #Rectangle.  tmp1 compile: 'rectangleRelativeTo: aRectangle ^self origin extent: aRectangle extent' classified: #(#accessing).  (model classNamed: #Object) compile: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle rectangleRelativeTo: temp' classified: #(#accessing).  self proceedThroughWarning: [ tmp2 := RBInlineMethodFromComponentRefactoring model: model inline: (77 to: 112) inMethod: #foo forClass: (model classNamed: #Object).        self setupInlineExpressionFor: tmp2 toReturn: false.        self setupImplementorToInlineFor: tmp2 toReturn: tmp1.        self executeRefactoring: tmp2 ].  self assert: ((tmp2 model classNamed: #Object) parseTreeFor: #foo) equals: (self parseMethod: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle origin extent: temp extent')assert: arg1 closeTo: arg2  ^self assert: (arg1 closeTo: arg2) description: [ self comparingStringBetween: arg1 and: arg2 ]className: arg1  className := arg1class: arg1 selector: arg2 interval: arg3 newName: arg4  class := self classObjectFor: arg1.  selector := arg2.  interval := arg3.  newName := arg4inlineJunk  | tmp1 |  tmp1 := self inlineFoo: [:arg1 |  | tmp2 |        tmp2 := arg1.        tmp2 , tmp2 ].  ^tmp1 foo: [:arg2 |  | tmp3 |        tmp3 := arg2.        tmp3 * tmp3 ]classes  ^environment classes & andedEnvironment classesrefactoringConfirmWarning: arg1  | tmp1 |  tmp1 := UIManager default confirm: arg1 orCancel: [ ^RBRefactoringFailure signal: 'aborted' ].  ^tmp1checkMethod: arg1  class := arg1 selectedClass.  (rewriteRule executeTree: arg1 parseTree) ifTrue: [ (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: [ builder compile: rewriteRule tree printString in: class classified: arg1 protocols ] ]testMetaClassFailure  self shouldFail: (RBApplyClassDeprecationRefactoring rename: self class class to: #Foo)testVariableNotDefined  | tmp1 |  tmp1 := RBProtectInstanceVariableRefactoring variable: 'rewrite' class: RBSubclassOfClassToRename.  self shouldFail: tmp1flushCaches  implementorsCache := IdentityDictionary new.  sendersCache := IdentityDictionary newtestExtractToTemporaryInsideBlock  | tmp1 |  tmp1 := RBExtractToTemporaryRefactoring extract: (133 to: 141) to: 'asdf' from: #noMoveDefinition in: RBRefactoryTestDataApp.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #noMoveDefinition) equals: (self parseMethod: 'noMoveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: [:each | | asdf | asdf := each size. temp := asdf + temp]')classes: arg1  arg1 do: [:arg2 |  self addClass: arg2 ]addClass: arg1 classVariable: arg2  (classVariables at: arg1 name ifAbsentPut: [ Set new ]) add: arg2.  self flushCachesFor: arg1.  self addSearchString: arg2verifySelectedInterval  | tmp1 tmp2 |  tmp2 := self selectedSource.  tmp1 := self parserClass parseExpression: tmp2 onError: [:arg1 :arg2 |  self refactoringFailure: 'Invalid selection' ].  tmp1 isSequence ifTrue: [ self refactoringFailure: 'Cannot assign temp to multiple statements' ]name: arg1  name := arg1unaryAccessingBranchingStatementMethodWithReturn  self value isString ifTrue: [ ^self value ] ifFalse: [ ^'' ]classesDo: arg1  classSelectors keysDo: [:arg2 |  | tmp1 |        tmp1 := self systemDictionary at: arg2 ifAbsent: [ nil ].        (tmp1 notNil and: [ environment includesClass: tmp1 ]) ifTrue: [ arg1 value: tmp1 ] ].  metaClassSelectors keysDo: [:arg2 |  | tmp1 |        tmp1 := self systemDictionary at: arg2 ifAbsent: [ nil ].        (tmp1 notNil and: [ environment includesClass: tmp1 class ]) ifTrue: [ arg1 value: tmp1 class ] ]pullUpMethods  self pushUpMethodsFrom: parent.  self pushUpMethodsFrom: parent classSideprivateTransform  self subclassResponsibilitytestNewExistingName  model := RBNamespace2 new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  self shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'asdf' class: (model classNamed: #FOOBAR)) asRefactoringsuperclass: arg1  self superclass ifNotNil: [ self superclass removeSubclass: self ].  superclass := arg1.  superclass ifNotNil: [ superclass addSubclass: self ]rule: arg1  rule := arg1selectionIntervalFor: arg1  | tmp1 |  tmp1 := super selectionIntervalFor: arg1.  tmp1 ifNotNil: [ ^tmp1 ].  ^andedEnvironment selectionIntervalFor: arg1definitionClass  ^onSystemDictionary classNamed: (self superclassName ifNil: [ #ProtoObject ])markAsRemoved: arg1  removedClasses     add: arg1;     add: arg1 , ' class'testValidateRenameParameters  | tmp1 |  tmp1 := RBExtractMethodRefactoring extract: (78 to: 197) from: #displayName in: RBLintRuleTestData.  self setupMethodNameFor: tmp1 toReturn: #foo:.  tmp1 parameterMap: (Dictionary new           at: #nameStream put: #nameStream;           yourself).  self should: [ tmp1 validateRenameOf: #nameStream to: #name ] raise: RBRefactoringError.  self should: [ tmp1 validateRenameOf: #nameStream to: #foo1 ] raise: RBRefactoringError.  self should: [ tmp1 validateRenameOf: #nameStream to: #Foo1 ] raise: RBRefactoringErrorclassVariableNames  | tmp1 |  tmp1 := fromClass instanceSide.  ^(tmp1 allClassVariableNames collect: [:arg1 |  arg1 asString ]) asSettestVariableIsNotAccessed  | tmp1 tmp2 |  tmp1 := RBProtectVariableTransformation instanceVariable: 'instVar' class: self changeMock name.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self deny: (tmp2 directlyDefinesLocalMethod: #instVar).  self deny: (tmp2 directlyDefinesLocalMethod: #instVar:).  tmp1 transform.  self assert: tmp1 model changes changes size equals: 2.  self assert: (tmp2 directlyDefinesLocalMethod: #instVar).  self assert: (tmp2 directlyDefinesLocalMethod: #instVar:)changeClass  | tmp1 |  tmp1 := onSystemDictionary at: self changeClassName ifAbsent: [ ^nil ].  ^isMeta ifTrue: [ tmp1 classSide ] ifFalse: [ tmp1 ]preconditions  ^(RBCondition definesSelector: sourceSelector in: class) & (RBCondition withBlock: [ self findSelectedMessage.              self isOverridden ifTrue: [ self refactoringWarning: ('<1p>>><2s> is overriden. Do you want to inline it anyway?' expandMacrosWith: self inlineClass with: self inlineSelector) ].              self parseInlineMethod.              self isPrimitive ifTrue: [ self refactoringError: 'Cannot inline primitives' ].              self checkSuperMessages.              self rewriteInlinedTree.              (sourceMessage parent isReturn or: [ self hasMultipleReturns not ]) ifFalse: [ self refactoringError: 'Cannot inline method since it contains multiple returns that cannot be rewritten' ].              true ])classVariableNames: arg1  classVariableNames := (arg1 collect: [:arg2 |  arg2 asSymbol ]) asOrderedCollectionaddTraitDefinition: arg1  ^RBAddTraitChange definition: arg1testExistingSelector  self shouldFail: (RBRenameMethodRefactoring renameMethod: #checkClass: in: RBBasicLintRuleTestData to: #runOnEnvironment: permutation: (1 to: 1))testReferencedVariable  self shouldFail: (RBRemoveInstanceVariableRefactoring variable: 'name' class: RBLintRuleTestData)testPushDownMethodOnNonAbstractClass  | tmp1 |  tmp1 := RBPushDownMethodRefactoring pushDown: #(#isArray) from: Array.  self shouldFail: tmp1privateTransform  self definingClass removeMethod: selectortestClassDoesNotExist  self shouldFail: (RBRemoveAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBAssignmentTransformationTest) asRefactoringinlineParameterMethod: arg1  ^arg1 isSymbolclassNames  ^self categories inject: IdentitySet new into: [:arg1 :arg2 |  arg1           addAll: (self classNamesFor: arg2);           yourself ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ' value: ''';     nextPutAll: value;     nextPutAll: ' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: ''';     nextPutAll: className.  arg1 nextPut: $)transform  | tmp1 |  tmp1 := self subclassDefiningVariable.  tmp1 removeClassVariable: variableName.  class addClassVariable: variableNameunaryAccessingMethodWithoutReturn  variable: arg1 inMethod: arg2 inClass: arg3  self variable: arg1 inInterval: nil inMethod: arg2 inClass: arg3removeClassVariable: arg1 from: arg2  ^self addChange: (changeFactory removeClassVariable: arg1 from: arg2)defineGetterMethod  | tmp1 tmp2 |  tmp2 := self definingClass.  tmp1 := self safeMethodNameFor: tmp2 basedOn: variableName asString.  tmp2 compile: ('<1s><r><t>^ <2s>' expandMacrosWith: tmp1 with: variableName) classified: #(#accessing).  ^tmp1testModelRenameClass  | tmp1 tmp2 |  model defineClass: 'Object subclass: #Foo instanceVariableNames: ''a'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  tmp2 := model classNamed: #Foo.  tmp2     compile: 'foo	^Object' classified: #(#accessing);     compile: 'objectName ^#(Object)' classified: #(#accessing).  tmp1 := RBRenameClassRefactoring model: model rename: Object to: #Thing.  self executeRefactoring: tmp1.  self assert: (model includesClassNamed: #Thing).  self deny: (model includesClassNamed: #Object).  self assert: (tmp2 parseTreeFor: #foo) equals: (self parseMethod: 'foo ^Thing').  self assert: (tmp2 parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^#(Thing)').  self assert: tmp2 superclass name equals: #ThingcompileMethod  class compileTree: sourceTreetestClassVariableToMultipleSubclasses2  | tmp1 |  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #AnotherSubclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  tmp1 := model metaclassNamed: #AnotherSubclass.  tmp1 compile: 'bar ^Foo' classified: #(#accessing).  tmp1 := tmp1 theNonMetaClass.  (RBPushDownVariableTransformation model: model classVariable: #Foo class: tmp1 superclass superclass) asRefactoring transform.  self deny: (tmp1 superclass superclass directlyDefinesClassVariable: #Foo).  self deny: (tmp1 superclass directlyDefinesClassVariable: #Foo).  self assert: (tmp1 directlyDefinesClassVariable: #Foo)testCompileInClassified  | tmp1 |  tmp1 := changes compile: 'setUp' in: self class classified: #accessing.  self assert: tmp1 controller isNil.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 selector equals: #setUp.  self assert: tmp1 source equals: 'setUp'.  self assert: tmp1 protocol equals: #accessing.  self universalTestFor: tmp1refactoringError: arg1  ^RBRefactoringError signal: arg1instVarWritersTo: arg1 in: arg2  ^RBVariableEnvironment on: self writersOfInstanceVariable: arg1 in: arg2resetResult  rules do: [:arg1 |  arg1 resetResult ]addClass: arg1 superclass: arg2 subclasses: arg3 category: arg4  self className: arg1.  superclass := arg2 asSymbol.  subclasses := arg3.  category := arg4 asSymbolshouldntRaiseException  self shouldnt: [ 0 / 1 ] raise: ExceptionimplementorsMatching: arg1  ^RBSelectorEnvironment implementorsMatching: arg1 in: selfhasOnlyOneAssignment  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: assignmentNode variable name , ' := ``@object' do: [:arg1 :arg2 |  arg2 + 1 ].  ^(tmp1 executeTree: definingNode initialAnswer: 0) == 1printOn: arg1  arg1     nextPutAll: self displayClassName;     nextPutAll: ' addProtocolNamed: ';     print: self displayProtocolName;     nextPutAll: ' stamp: ';     print: self changeStamp;     nextPutAll: '!'execute  ^self executeNotifying: [  ]errorStringFor: arg1  ^condition errorStringFor: arg1 notstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' extract: '.  extractionInterval storeOn: arg1.  arg1     nextPutAll: ' from: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1 nextPut: $)compositeRefactoryChangeNamed: arg1  ^RBCompositeRefactoryChange named: arg1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' className ''';     nextPutAll: className;     nextPutAll: ''' newClassName: ''';     nextPutAll: newClassName.  arg1 nextPut: $)whichPoolDefines: arg1  | tmp1 |  tmp1 := fromClass.  [ tmp1 isNil ] whileFalse: [ tmp1 allPoolDictionaryNames do: [:arg2 |  ((self poolVariableNamesIn: arg2) includes: arg1) ifTrue: [ ^arg2 ] ].        tmp1 := tmp1 superclass ].  ^nilbasicCheck: arg1  ^self subclassResponsibilitytestVariableNotDirectlyDefined  self     shouldFail: (RBProtectVariableTransformation instanceVariable: 'name' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBProtectVariableTransformation classVariable: #DependentsFields class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBProtectVariableTransformation model: model classVariable: 'ClassVarName2' class: #Bar) asRefactoringconvertMethod: arg1 for: arg2 using: arg3  | tmp1 |  tmp1 := arg2 parseTreeFor: arg1.  tmp1 ifNil: [ ^self ].  (arg3 executeTree: tmp1) ifTrue: [ arg2 compileTree: arg3 tree ]isComposite  ^falsetestBadName  self     shouldFail: (RBApplyClassDeprecationRefactoring rename: RBLintRuleTestData to: self objectClassVariable);     shouldFail: (RBApplyClassDeprecationRefactoring rename: RBLintRuleTestData to: #'Ob ject')environments  ^environmentDictionaries keysstoreOn: arg1  arg1 nextPut: $(.  environment storeOn: arg1.  arg1 nextPutAll: ' & '.  andedEnvironment storeOn: arg1.  arg1 nextPut: $)assignmentInIfTrue  | tmp1 |  self isVariable ifTrue: [ tmp1 := self ] ifFalse: [ tmp1 := self printString ].  ^tmp1requestMethodNameFor: arg1  ^(self options at: #methodName) value: self value: arg1check: arg1 forCritiquesDo: arg2  (self matcher canMatchMethod: arg1) ifTrue: [ | tmp1 |        tmp1 := self matcher executeTree: arg1 ast initialAnswer: nil.        tmp1 ifNotNil: [ ^arg2 cull: (self critiqueFor: tmp1 about: arg1) ] ]method: arg1 with: arg2 lots: arg3 of: arg4 arguments: arg5  ^arg5 + arg1 > (arg4 - arg2 + arg3)parseTreeSearcher  ^RBParseTreeSearcher newremoveProtocolNamed: arg1 in: arg2  self flag: #todo.  ^self addChange: (RBRemoveProtocolChange removeProtocolNamed: arg1 in: arg2)testModelAbstractClassVariable  | tmp1 tmp2 tmp3 |  tmp3 := model classNamed: #Foo.  tmp2 := tmp3 classSide.  tmp1 := RBAbstractClassVariableRefactoring model: model variable: 'ClassVarName1' class: tmp3.  self executeRefactoring: tmp1.  self assert: (tmp2 parseTreeFor: #classVarName1) equals: (self parseMethod: 'classVarName1 ^ClassVarName1').  self assert: (tmp2 parseTreeFor: #classVarName1:) equals: (self parseMethod: 'classVarName1: anObject ^ClassVarName1 := anObject').  self assert: (tmp2 parseTreeFor: #foo) equals: (self parseMethod: 'foo					^self classVarName1: self classVarName1 * self classVarName1 * self classVarName1').  self assert: (tmp3 parseTreeFor: #classVarName1) equals: (self parseMethod: 'classVarName1							^self class classVarName1').  self assert: (tmp3 parseTreeFor: #classVarName1:) equals: (self parseMethod: 'classVarName1: anObject							^self class classVarName1: anObject').  self assert: (tmp3 parseTreeFor: #asdf) equals: (self parseMethod: 'asdf						^self classVarName1: (self class classVarName1: self class classVarName1 + 1)').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo					instVarName1 := instVarName1 + instVarName2 + self class classVarName1').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo						instVarName1 := instVarName1 + instVarName2 + self class classVarName1')asSelectorEnvironment  | tmp1 |  tmp1 := RBSelectorEnvironment onEnvironment: environment.  self classesAndSelectorsDo: [:arg1 :arg2 |  tmp1 addClass: arg1 selector: arg2 ].  ^tmp1errorMacro  ^errorMacro ifNil: [ 'unknown' ] ifNotNil: [ errorMacro ]transformationBlock: arg1  transformationBlock := arg1group  ^renrakuRule grouptransform  self     createGetterAccessor;     createSetterAccessorclassesDo: arg1  | tmp1 |  tmp1 := IdentitySet new.  environment classesDo: [:arg2 |  arg1 value: arg2.        tmp1 add: arg2 ].  orEnvironment classesDo: [:arg2 |  (tmp1 includes: arg2) ifFalse: [ arg1 value: arg2 ] ]testTransform  | tmp1 tmp2 |  tmp1 := (RBRemoveMessageSendTransformation new messageSend: #byteAt: inMethod: #methodBefore inClass: self class name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyprivateTransform  isClassVariable ifTrue: [ self definingClass theNonMetaClass addClassVariable: variableName ] ifFalse: [ self definingClass addInstanceVariable: variableName ]newContentMorph  ^(self newColumn: {(self newRow: {(self newGroupbox: 'Arguments' for: (self newColumn: {((self newListFor: self list: #arguments selected: #argumentIndex changeSelected: #argumentIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               (self newGroupbox: 'Values' for: (self newColumn: {((self newListFor: self list: #values selected: #valueIndex changeSelected: #valueIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               ((self newRow: {(self newButtonFor: self action: #addAssociation label: 'v' help: 'Map')}) hResizing: #shrinkWrap)}) .         (self newRow: {(self newGroupbox: 'Preview' for: (self newColumn: {(sourceCodeMorph := (self newText: tree formattedCode)                             extent: 400 @ 400;                             hResizing: #rigid)}))}) .         (self newRow: {(self newGroupbox: 'Associations' for: (self newColumn: {((self newListFor: self list: #associations selected: #associationIndex changeSelected: #associationIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               ((self newRow: {(self newButtonFor: self action: #removeAssociation label: '^' help: 'Unmap')}) hResizing: #shrinkWrap)})}) vResizing: #shrinkWraplabel: arg1  label := arg1testNewHierarchyExistingName  model := RBNamespace2 new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  model defineClass: 'FOOBAR subclass: #BARFOO 				instanceVariableNames: '''' 					classVariableNames: ''''				poolDictionaries: ''''				category: ''Refactory-Test data'''.  self shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'asdf' class: (model classNamed: #BARFOO)) asRefactoringsetupImplementorToInlineFor: arg1 toReturn: arg2  | tmp1 |  tmp1 := arg1 options copy.  tmp1 at: #implementorToInline put: [:arg3 :arg4 |  arg2 ].  arg1 options: tmp1testNonExistantSelector  self shouldFail: (RBInlineMethodRefactoring inline: (14 to: 17) inMethod: #checkClass1: forClass: RBRefactoryTestDataApp)realClass: arg1  realClass := arg1.  superclass ifNil: [ superclass := LookupSuperclass ]allSelectors  | tmp1 tmp2 |  tmp1 := self.  tmp2 := Set new.  [ tmp1 notNil ] whileTrue: [ tmp2 addAll: tmp1 selectors.        tmp1 := tmp1 superclass ].  ^tmp2preconditions  ^(RBCondition isMetaclass: class) not & (RBCondition isValidClassVarName: newName asString for: class) & (RBCondition definesClassVariable: variableName asString in: class) & (RBCondition hierarchyOf: class definesVariable: newName asString) not & (RBCondition isGlobal: newName asString in: self model) notcomputeSelectorCacheFor: arg1  ^(self instanceVariableSelectorsFor: arg1)     addAll: (self classVariableSelectorsFor: arg1);     yourselftransform  self     createNewClass;     createReference;     abstractVariableReferencesequalsTrue  ^true == selfwithAllSuperclassesUntil: arg1  ^(self allSuperclassesUntil: arg1)     add: self;     yourselftestModelInheritedSelector  | tmp1 |  tmp1 := RBAddMethodRefactoring model: model addMethod: 'printString ^super printString' toClass: (model classNamed: #Bar) inProtocols: #(#accessing).  self shouldFail: tmp1checkPackage: arg1  addArgumentToSelector: arg1  ^arg1 isInfix ifTrue: [ #value:value: ] ifFalse: [ (arg1 , 'value:') asSymbol ]removeDependentSends  self     removeDependent: #one;     removeDependent: #twotestRefactoring  | tmp1 tmp2 |  tmp1 := (RBRenameVariableTransformation rename: 'classBlock' to: 'asdf' in: #RBBasicLintRuleTestData classVariable: false) asRefactoring transform.  tmp2 := tmp1 model classNamed: #RBBasicLintRuleTestData.  self assert: (tmp2 directlyDefinesInstanceVariable: 'asdf').  self deny: (tmp2 directlyDefinesInstanceVariable: 'classBlock').  self assert: (tmp2 parseTreeFor: #checkClass:) equals: (self parseMethod: 'checkClass: aSmalllintContext 					^asdf value: aSmalllintContext value: result').  self assert: (tmp2 parseTreeFor: #initialize) equals: (self parseMethod: 'initialize					super initialize.					self anInstVar: 1.					asdf := [:context :aResult | ].					methodBlock := [:context :aResult | ].					self resultClass: RBSelectorEnvironment')testMethodDoesNotExist  self shouldFail: (RBRemovePragmaTransformation pragma: '<gtInspectorPresentationOrder: 34>' inMethod: #method inClass: #RBRemovePragmaTransformationTest) asRefactoringincludesClass: arg1  | tmp1 |  tmp1 := self.  [ tmp1 notNil and: [ tmp1 ~= arg1 ] ] whileTrue: [ tmp1 := tmp1 superclass ].  ^tmp1 = arg1transform  self setOption: #inlineExpression toUse: [:arg1 :arg2 |  true ].  self getterSetterMethods do: [:arg3 |  self inline: arg3 ]pragma: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  pragma := arg1preconditions  | tmp1 |  tmp1 := RBCondition withBlock: [ oldSelector numArgs = newSelector numArgs or: [ newSelector numArgs = 0 ] ] errorString: 'The new selectors should have the same number of arguments as the old one, or not have them at all'.  ^tmp1endTrueFalse  self isVariable ifTrue: [ self printString.        self isVariable printString ] ifFalse: [ self printString.        ^4 ]abstractInstanceVariable: arg1  | tmp1 tmp2 |  tmp1 := RBCreateAccessorsForVariableRefactoring model: self model variable: arg1 class: fromClass classVariable: false.  self performComponentRefactoring: tmp1.  tmp2 := RBParseTreeRewriter new.  tmp2     replace: arg1 , ' := ``@object' with: ('self <1s> ``@object' expandMacrosWith: tmp1 setterMethod);     replace: arg1 with: 'self ' , tmp1 getterMethod.  (tmp2 executeTree: tree) ifTrue: [ tree := tmp2 tree ]selectorNotReferenced  ^self selectorNotReferenced + 4testPushDownMethod  | tmp1 tmp2 |  tmp1 := RBPushDownMethodRefactoring pushDown: #(#name:) from: RBLintRuleTestData.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self deny: (tmp2 directlyDefinesMethod: #name:).  tmp2 subclasses do: [:arg1 |  self assert: (arg1 parseTreeFor: #name:) equals: (self parseMethod: 'name: aString name := aString') ]testModelImplementorsSenders  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := modelFactory rbNamespace new.  tmp1 defineClass: 'Object subclass: #Asdf			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Testing'''.  tmp2 := tmp1 classNamed: #Asdf.  tmp2 compile: 'storeOn: aStream ^super storeOn: aStream' classified: #(#printing).  tmp3 := tmp1 allImplementorsOf: #storeOn:.  self assert: (tmp3 includes: tmp2).  self assert: tmp3 size - 1 equals: (RBBrowserEnvironment new implementorsOf: #storeOn:) numberSelectors.  tmp4 := RBBrowserEnvironment new referencesTo: #storeOn:.  tmp5 := false.  tmp1 allReferencesTo: #storeOn: do: [:arg1 |  arg1 modelClass = tmp2 ifTrue: [ tmp5 := true ] ifFalse: [ self assert: (tmp4 includesSelector: arg1 selector in: arg1 modelClass realClass) ] ].  self assert: tmp5testPullUpInAHighHierarchyClass  | tmp1 tmp2 |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  tmp1 := model classNamed: #Foo1.  tmp2 := model classNamed: #SomeClass.  tmp1 compile: 'example ^1' classified: #(#accessing).  self executeRefactoring: (RBPullUpMethodRefactoring model: model pullUp: #(#example) from: tmp1 to: tmp2).  self assert: (tmp2 parseTreeFor: #example) equals: (self parseMethod: 'example ^1').  self deny: (tmp1 directlyDefinesMethod: #example).  tmp1 := model classNamed: #Subclass.  self assert: (tmp1 definesMethod: #example).  self assert: (tmp1 parseTreeFor: #example) equals: ((model classNamed: #SomeClass) parseTreeFor: #example)removeDependentSends  self removeDependent: #onenormalizeIfTrues  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1     replace: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2' with: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1] ifFalse: [``@.s2. ^``@r2]';     replace: '| `@temps | ``@.s1. ``@boolean ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2' with: '| `@temps | ``@.s1. ``@boolean ifTrue: [``@.s2. ^``@r2] ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]'.  [ tmp1 executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := tmp1 tree ]testAbstractClassVariable  | tmp1 tmp2 tmp3 |  tmp1 := RBAbstractClassVariableRefactoring variable: 'RecursiveSelfRule' class: RBTransformationRuleTestData.  self executeRefactoring: tmp1.  tmp3 := tmp1 model classNamed: #RBTransformationRuleTestData.  tmp2 := tmp3 classSide.  self assert: (tmp2 parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (tmp2 parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (tmp2 parseTreeFor: #nuke) equals: (self parseMethod: 'nuke							self recursiveSelfRule: nil').  self assert: (tmp2 parseTreeFor: #initializeAfterLoad1) equals: (self parseMethod: 'initializeAfterLoad1							self recursiveSelfRule: RBParseTreeSearcher new.							self recursiveSelfRule								addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')										-> [:aNode :answer | true]').  self assert: (tmp3 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 							class := aSmalllintContext selectedClass.							(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 									[(self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)										ifFalse: 											[builder compile: rewriteRule tree printString												in: class												classified: aSmalllintContext protocols]]')displayName  | tmp1 |  tmp1 := WriteStream on: (String new: 64).  tmp1     nextPutAll: self name;     nextPutAll: ' ('.  self problemCount printOn: tmp1.  tmp1 nextPut: $).  ^tmp1 contentstestMetaClassFailure  self shouldFail: (RBAddClassRefactoring addClass: #Foo superclass: self class class subclasses: #() category: #'Refactory-Testing')problemCount  ^self subclassResponsibilitynameNewMethod: arg1  | tmp1 tmp2 |  newExtractedSelector := arg1.  tmp1 := parameters collect: [:arg2 |  RBVariableNode named: arg2 ].  extractedParseTree renameSelector: arg1 andArguments: tmp1 asArray.  arg1 numArgs = 0 ifTrue: [ modifiedParseTree := RBParseTreeRewriter replace: self methodDelimiter with: 'self ' , arg1 asString in: modifiedParseTree.        ^self ].  tmp2 := String streamContents: [:arg3 |  arg3 nextPutAll: 'self '.        arg1 keywords with: parameters do: [:arg4 :arg5 |  arg3                 nextPutAll: arg4 asString;                 nextPut: $ ;                 nextPutAll: arg5 asString;                 nextPut: $  ] ].  modifiedParseTree := RBParseTreeRewriter replace: self methodDelimiter with: tmp2 in: modifiedParseTreesafeMethodNameFor: arg1 basedOn: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg2 copy.  tmp1 at: 1 put: tmp1 first asLowercase.  tmp2 := tmp1.  tmp3 := tmp2 last = $:.  tmp3 ifTrue: [ tmp1 := tmp2 copyFrom: 1 to: tmp2 size - 1 ].  tmp4 := 0.  [ arg1 hierarchyDefinesMethod: tmp2 asSymbol ] whileTrue: [ tmp4 := tmp4 + 1.        tmp2 := tmp1 , tmp4 printString , (tmp3 ifTrue: [ ':' ] ifFalse: [ '' ]) ].  ^tmp2 asSymbolcollectionNameFor: arg1  ^'-<1s>-' expandMacrosWith: arg1metaClassSelectorDictionary  ^metaClasses inject: (IdentityDictionary new: metaClasses size) into: [:arg1 :arg2 |  arg1           at: arg2 put: (self systemDictionary at: arg2) class selectors;           yourself ]compileDelegatorMethod  | tmp1 tmp2 tmp3 |  tmp2 := RBMessageNode receiver: (RBVariableNode named: variable) selector: parseTree selector keywordsPositions: parseTree keywordsPositions arguments: (parseTree argumentNames collect: [:arg1 |  RBVariableNode named: (arg1 = selfVariableName ifTrue: [ 'self' ] ifFalse: [ arg1 ]) ]).  self hasOnlySelfReturns ifFalse: [ tmp2 := RBReturnNode value: tmp2 ].  tmp1 := RBSequenceNode temporaries: #() statements: (Array with: tmp2).  (tmp3 := class parseTreeFor: selector) body: tmp1.  class compileTree: tmp3failedRules  ^self isEmpty ifTrue: [ #() ] ifFalse: [ Array with: self ]buildParseTree  parseTree := (class parseTreeFor: selector) copy.  parseTree ifNil: [ self refactoringFailure: 'Could not parse method' ]changes  ^Array with: selftestExtractMethodAtEndOfMethodThatNeedsReturn  | tmp1 tmp2 tmp3 |  tmp1 := RBExtractMethodToComponentRefactoring extract: (52 to: 133) from: #openEditor in: RBLintRuleTestData.  self setupMethodNameFor: tmp1 toReturn: #foo:.  self setupSelfArgumentNameFor: tmp1 toReturn: 'asdf'.  self setupVariableToMoveToFor: tmp1 toReturn: 'rules'.  self setupVariableTypesFor: tmp1 toReturn: (Array with: (tmp1 model classNamed: #Collection)).  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  tmp3 := tmp2 selectors size.  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  self assert: (tmp2 parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor								| rules |								rules := self failedRules.								^rules foo: self').  self assert: ((tmp1 model classNamed: #Collection) parseTreeFor: #foo:) equals: (self parseMethod: 'foo: asdf								self isEmpty ifTrue: [^asdf].								self size == 1 ifTrue: [^self first viewResults].								^asdf').  self assert: tmp2 selectors size equals: tmp3onSystemDictionary  ^onSystemDictionaryshouldnt: arg1 raise: arg2 whoseDescriptionIncludes: arg3 description: arg4  ^self assert: (self executeShould: arg1 inScopeOf: arg2 withDescriptionContaining: arg3) not description: arg4theMetaClass  ^selftransform  class addInstanceVariable: variableNamecode: arg1 from: arg2 in: arg3  self className: arg3.  selector := arg2.  sourceCode := arg1testRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddMethodTransformation sourceCode: 'foo										| temp bar |										bar := 5.										temp := bar * bar.										Transcript show: temp printString; cr.										^temp * temp' in: #RBRemoveTemporaryVariableTransformationTest withProtocol: #accessing) asRefactoring transform.  tmp1 := (RBRemoveTemporaryVariableTransformation model: tmp1 model variable: 'temp' inMethod: #foo inClass: #RBRemoveTemporaryVariableTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: #RBRemoveTemporaryVariableTransformationTest.  self assert: (tmp2 directlyDefinesMethod: #foo).  self assert: (tmp2 parseTreeFor: #foo) temporaries size equals: 1perform: arg1 do: arg2  | tmp1 |  ^SystemAnnouncer uniqueInstance suspendAllWhile: [ tmp1 := arg1 execute.        arg2 ensure: [ tmp1 execute ] ]returnsIfTrue  ^self isNil ifTrue: [ 4 ]testRemoveReferenced  self shouldFail: (RBRemoveMethodRefactoring removeMethods: #(#checkClass:) from: RBBasicLintRuleTestData)returnsBooleanAndOther  self isVariable ifTrue: [ ^false ].  self printStringremoveMockClass  testingEnvironment removeClassNamed: #RBRefactoringChangeMockdeny: arg1 description: arg2 resumable: arg3  self assert: arg1 value not description: arg2 resumable: arg3actionBlock  ^actionBlockreorderParametersToMatch: arg1  | tmp1 tmp2 |  tmp1 := class parseTreeFor: arg1.  tmp2 := Dictionary new.  tmp1 body equalTo: extractedParseTree body withMapping: tmp2.  parameters := tmp1 arguments collect: [:arg2 |  tmp2 at: arg2 name ifAbsent: [ self refactoringFailure: 'An internal error occured, please report this error.' ] ]removeMockClass  testingEnvironment removeClassNamed: #RBRefactoringChangeMockcontroller: arg1  controller := arg1model  ^modelstoreOn: arg1  arg1 nextPut: $(.  super storeOn: arg1.  arg1 nextPutAll: ' classes: (('.  classes asArray storeOn: arg1.  arg1 nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class].				sum]) , ('.  metaClasses asArray storeOn: arg1.  arg1 nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class class].				sum])))'shouldRemoveExtensions: arg1  shouldRemoveExtensions := arg1hasCreatedClassFor: arg1  | tmp1 |  tmp1 := self classNameFor: arg1.  ^(newClasses includesKey: tmp1) or: [ changedClasses includesKey: tmp1 ]replaceArgument: arg1 with: arg2  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1 replaceTree: arg1 withTree: arg2.  (tmp1 executeTree: inlineParseTree body) ifTrue: [ inlineParseTree body: tmp1 tree ]methodBlock: arg1  methodBlock := arg1undoOperation  undo ifEmpty: [ ^self ].  self ignoreChangesWhile: [ | tmp1 |        tmp1 := undo removeLast.        redo add: tmp1 execute ]testExistingName  self     shouldFail: (RBChildrenToSiblingsRefactoring name: #Object class: RBLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData with: RBCompositeLintRuleTestData));     shouldFail: (RBChildrenToSiblingsRefactoring name: #Processor class: RBLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData with: RBCompositeLintRuleTestData))testReturnDoesNotExist  self shouldFail: (RBRemoveReturnStatementTransformation return: '^ variable' inMethod: #methodAfter inClass: #RBRemoveReturnStatementTransformationTest) asRefactoringcategory: arg1 for: arg2  ^changes addChange: (RBClassCategoryChange category: arg1 for: arg2)testTransform  | tmp1 tmp2 |  tmp1 := (RBAddMethodCommentTransformation comment: 'New comment for method' inMethod: #one inClass: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := (tmp1 model classNamed: self changeMock name) methodFor: #one.  self assert: tmp2 ast comments first contents equals: 'New comment for method'testMetaclass  | tmp1 |  tmp1 := model metaclassNamed: #Foo.  tmp1 addInstanceVariable: 'foo'.  tmp1 compile: 'zzz ^foo := foo + foo * 2' classified: #(#testing).  (RBProtectVariableTransformation model: model instanceVariable: 'foo' class: tmp1) asRefactoring transform.  self assert: (tmp1 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^foo').  self assert: (tmp1 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: anObject foo := anObject').  self assert: (tmp1 parseTreeFor: #zzz) equals: (self parseMethod: 'zzz ^self foo: self foo1 + self foo1 * 2')testDefineClassChange  | tmp1 |  tmp1 := modelFactory rbNamespace new.  tmp1 defineClass: 'RefactoringBrowserTest subclass: #SmalltalkTestXXX				instanceVariableNames: ''''				classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Testing'''.  self assert: (tmp1 includesClassNamed: #SmalltalkTestXXX).  self assert: (tmp1 classNamed: #SmalltalkTestXXX) notNilasUndoOperation  ^self copy     comment: self changeClass organization classComment;     yourselfgetterMethod  ^getterMethodaddClassVariable: arg1  self privateClassVariableNames add: arg1 asSymbol.  model addClassVariable: arg1 to: selfprintOn: arg1  name ifNil: [ super printOn: arg1 ] ifNotNil: [ arg1 nextPutAll: name ]labelFor: arg1  self deny: arg1 label isNil.  self deny: arg1 label isEmpty.  self deny: arg1 defaultLabel isNil.  self deny: arg1 defaultLabel isEmptygetterMethod  ^getterMethod ifNil: [ getterMethod := (self definingClass getterMethodFor: variableName) ifNil: [ variableName uncapitalized asSymbol ] ]className: arg1 newName: arg2  className := arg1 asSymbol.  deprecatedClass := self model classNamed: className.  newName := arg2 asSymbolexampleCall  ^self rename: 1 two: 2newName  ^newNameunexpectedIdentityEqualityStringBetween: arg1 and: arg2  ^String streamContents: [:arg3 |  arg3           nextPutAll: 'Unexpected identity equality of ';           nextPutAll: arg1 fullPrintString;           nextPutAll: ' and ';           nextPutAll: arg2 fullPrintString;           nextPutAll: '.' ]moveComments  inlineParseTree nodesDo: [:arg1 |  arg1 comments: (arg1 comments collect: [:arg2 |  | tmp1 tmp2 |                    tmp2 := sourceParseTree source.                    tmp1 := tmp2 size + 1.                    tmp2 := tmp2 , (inlineParseTree source copyFrom: arg2 start to: arg2 stop).                    sourceParseTree source: tmp2.                    RBComment with: arg2 contents at: tmp1 ]) ]transform  | tmp1 |  self model allClassesDo: [:arg1 |  (arg1 isNil or: [ arg1 isMeta ]) ifFalse: [ tmp1 := self execute: arg1 category.              tmp1 = arg1 category asString ifFalse: [ arg1 category: tmp1.                    self model defineClass: arg1 definitionString ] ] ]definitionString  ^String streamContents: [:arg1 |  arg1           nextPutAll: self superclass printString;           nextPutAll: ' subclass: #';           nextPutAll: self name;           nextPutAll: '	instanceVariableNames: '''.        self instanceVariableNames do: [:arg2 |  arg1                 nextPutAll: arg2;                 nextPut: $  ].        arg1 nextPutAll: '''	classVariableNames: '''.        self classVariableNames do: [:arg2 |  arg1                 nextPutAll: arg2;                 nextPut: $  ].        arg1 nextPutAll: '''	poolDictionaries: '''.        self sharedPoolNames do: [:arg2 |  arg1                 nextPutAll: arg2;                 nextPut: $  ].        arg1 nextPutAll: '''	category: #'''.        arg1 nextPutAll: self category asString.        arg1 nextPut: $' ]testModelAddClassVariable  | tmp1 |  tmp1 := RBAddClassVariableRefactoring model: model variable: #ClassVarName3 class: (model classNamed: #Bar).  self executeRefactoring: tmp1.  self assert: ((model classNamed: #Bar) directlyDefinesClassVariable: #ClassVarName3)literalArrayContainsComma  ^#(#,)computePoolsToMove  | tmp1 tmp2 |  tmp1 := self poolVariableNamesFor: fromClass.  pools := Set new.  tmp2 := self parseTreeSearcher.  tmp2 matches: '`var' do: [:arg1 :arg2 |  | tmp3 tmp4 |        tmp3 := arg1 name.        (arg1 whoDefines: tmp3) ifNil: [ (tmp1 includes: tmp3) ifTrue: [ tmp4 := self whichPoolDefines: tmp3.                    tmp4 ifNotNil: [ pools add: tmp4 ] ] ] ].  tmp2 executeTree: parseTreetestInlineLiteralArray  | tmp1 tmp2 |  tmp1 := RBInlineParameterRefactoring inlineParameter: 'aSymbol' in: RBRefactoryTestDataApp selector: ('inline' , 'ParameterMethod:') asSymbol.  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #inlineParameterMethod) equals: (self parseMethod: 'inlineParameterMethod | aSymbol | aSymbol := #(asdf). ^aSymbol isSymbol').  self assert: (tmp2 parseTreeFor: #sendInlineParameterMethod) equals: (self parseMethod: 'sendInlineParameterMethod ^self inlineParameterMethod').  self deny: (tmp2 directlyDefinesMethod: ('inline' , 'ParameterMethod:') asSymbol)literalArrayCharacters  ^#($a $b $c) includes: $afailedRules  ^rules inject: OrderedCollection new into: [:arg1 :arg2 |  arg1           addAll: arg2 failedRules;           yourself ]testParseFailure  self shouldFail: (RBReplaceSubtreeTransformation replace: 'selector := aSelector' to: ':= 123' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoringopenEditor  | tmp1 |  tmp1 := self failedRules.  tmp1 isEmpty ifTrue: [ ^self ].  tmp1 size == 1 ifTrue: [ ^tmp1 first viewResults ]problemCount  ^self result problemCountcalled: arg1 on: arg2  self traceCr: arg1 printString.  arg2 valueisMeta  ^isMetatestCompositeLintRuleTypes  | tmp1 tmp2 |  tmp1 := RBRefactoryTyper new runOn: RBCompositeLintRuleTestData.  tmp2 := tmp1 guessTypesFor: 'rules'.  self assert: (tmp2 includes: (tmp1 model classFor: Collection)).  tmp2 := tmp1 typesFor: '-rules-'.  self assert: (tmp2 includes: (tmp1 model classFor: RBLintRuleTestData)).  self assertEmpty: (tmp1 guessTypesFor: 'asdf').  tmp1 printStringselectors  ^Array streamContents: [:arg1 |  self selectorsDo: [:arg2 |  arg1 nextPut: arg2 ] ]withClassesFixedForNautilus  hasConflicts  ^truecheckClass: arg1  setUp  super setUp.  model := self abstractVariableTestDatafileBlocks  | tmp1 |  ^[ tmp1 := 'asdf' asFileReference readStream.  tmp1 contents ] ensure: [ tmp1 close ]setupMethodNameFor: arg1 toReturn: arg2  | tmp1 |  tmp1 := arg1 options copy.  tmp1 at: #methodName put: [:arg3 :arg4 |  arg4           selector: arg2;           yourself ].  arg1 options: tmp1testPushDownInstanceVariable  | tmp1 |  tmp1 := RBPushDownInstanceVariableRefactoring variable: 'foo1' class: RBLintRuleTestData.  self executeRefactoring: tmp1.  (tmp1 model classNamed: #RBLintRuleTestData) subclasses do: [:arg1 |  self assert: (arg1 directlyDefinesInstanceVariable: 'foo1') ]privateTransform  | tmp1 tmp2 |  tmp1 := self definingMethod.  tmp2 := self parserClass parsePragma: pragma.  tmp1 addPragma: tmp2.  self definingClass compileTree: tmp1normalizeReturns  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1     replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]' with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]' with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'.  [ tmp1 executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := tmp1 tree ]denyCollection: arg1 equals: arg2  ^self deny: arg2 = arg1 description: [ self unexpectedEqualityStringBetween: arg1 and: arg2 ]selector: arg1  super selector: arg1.  labelGroup extent x > self extent x ifTrue: [ self extent: (labelGroup extent x + 20) @ labelGroup extent y ]testAlreadyExistingName  self     shouldFail: (RBAddClassVariableRefactoring variable: #RecursiveSelfRule class: RBTransformationRuleTestData);     shouldFail: (RBAddClassVariableRefactoring variable: self objectClassVariable class: RBTransformationRuleTestData)matcher  ^matcherprocessAssignmentNode: arg1  | tmp1 |  tmp1 := arg1 variable name.  ignore = tmp1 ifTrue: [ ^self ].  (arg1 whoDefines: tmp1) ifNotNil: [ ^self ].  (self instanceVariableNames includes: tmp1) ifTrue: [ instVarWriters add: tmp1 ].  (self classVariableNames includes: tmp1) ifTrue: [ classVarWriters add: tmp1 ]testMetaclass  | tmp1 |  tmp1 := RBAddClassVariableRefactoring variable: #ClassVarName3 class: (model classNamed: #Object) classSide.  tmp1 model: model.  self shouldFail: tmp1compile: arg1 withAttributesFrom: arg2  | tmp1 tmp2 |  tmp1 := model compile: arg1 in: self classified: arg2 protocols.  tmp2 := modelFactory rbMethod for: self source: arg1 selector: tmp1 selector.  self addMethod: tmp2.  ^tmp1onError: arg1 do: arg2  ^arg1 on: self class preconditionSignal do: [:arg3 |  arg2 value.        arg3 return: nil ]existingMethodsThatReferTo: arg1  | tmp1 |  tmp1 := self realClass thoroughWhichSelectorsReferTo: arg1.  (newMethods isNil and: [ removedMethods isNil ]) ifTrue: [ ^tmp1 ].  ^tmp1 reject: [:arg2 |  (self hasRemoved: arg2) or: [ self newMethods includesKey: arg2 ] ]defaultLabel  ^'some methods'testRefactoring  | tmp1 tmp2 |  tmp1 := (RBRemoveReturnStatementTransformation return: '^ variable' inMethod: #methodBefore inClass: #RBRemoveReturnStatementTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBRemoveReturnStatementTransformationTest.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyabstractReferences  | tmp1 |  tmp1 := RBParseTreeRewriter variable: variableName getter: self accessorsRefactoring getterMethod setter: self accessorsRefactoring setterMethod.  self convertClasses: class withAllSubclasses select: [:arg1 |  (arg1 whichSelectorsReferToInstanceVariable: variableName) reject: [:arg2 |  arg1 == class and: [ arg2 == self accessorsRefactoring getterMethod or: [ arg2 == self accessorsRefactoring setterMethod ] ] ] ] using: tmp1transform  self createAccessors.  self abstractInstanceReferences.  self abstractClassReferenceshierarchyDefinesPoolDictionary: arg1  (self definesPoolDictionary: arg1) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:arg2 |  arg2 directlyDefinesPoolDictionary: arg1 ]postCopy  super postCopy.  instanceVariables := self copyDictionary: instanceVariables.  instanceVariableReaders := self copyDictionary: instanceVariableReaders.  instanceVariableWriters := self copyDictionary: instanceVariableWriters.  classVariables := self copyDictionary: classVariables.  selectorCache := nilprotocol  ^self selectedClass whichCategoryIncludesSelector: self selectortestMethod1  ^self testMethod1 , ([:arg1 |  arg1 testMethod1 ] value: #(#(#testMethod1) 2 #testMethod1))preconditions  ^RBCondition emptypackages  self shouldBeImplementednodesOf: arg1  | tmp1 tmp2 |  tmp1 := RBCombinatorVisitor new.  tmp2 := arg1 copy.  tmp2 acceptVisitor: tmp1.  ^tmp1 combinationsstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' inline: '.  sourceInterval storeOn: arg1.  arg1     nextPutAll: ' inMethod: #';     nextPutAll: sourceSelector;     nextPutAll: ' forClass: '.  class storeOn: arg1.  arg1 nextPut: $)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' extract: '.  sourceInterval storeOn: arg1.  arg1     nextPutAll: ' to: ''';     nextPutAll: newVariableName;     nextPutAll: ''' from: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1 nextPut: $)parseTreeRewriter  ^RBParseTreeRewriter newtestModelInlineMethodWithSameVariableNames2  | tmp1 tmp2 |  model := RBClassModelFactory rbNamespace new.  tmp1 := model classNamed: self class name.  tmp1 compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).  (model classNamed: #Object) compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c a9: b b9: a' classified: #(#accessing).  self proceedThroughWarning: [ tmp2 := RBInlineMethodFromComponentRefactoring model: model inline: (72 to: 84) inMethod: #foo forClass: (model classNamed: #Object).        self setupInlineExpressionFor: tmp2 toReturn: false.        self executeRefactoring: tmp2 ].  self assert: ((tmp2 model classNamed: #Object) parseTreeFor: #foo) equals: (self parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c + b + a')textToDisplay  self printStringsetUp  super setUp.  model := self abstractVariableTestDatastoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' removeMethods: '.  selectors asArray storeOn: arg1.  arg1 nextPutAll: ' from: '.  class storeOn: arg1.  arg1 nextPut: $)setupInlineExpressionFor: arg1 toReturn: arg2  | tmp1 |  tmp1 := arg1 options copy.  tmp1 at: #inlineExpression put: [:arg3 :arg4 |  arg2 ].  arg1 options: tmp1transcriptMentioned  Transcript show: 'message'preconditionChecking: arg1  preconditionChecking := arg1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' class: '.  class storeOn: arg1.  arg1     nextPutAll: ' selector: #';     nextPutAll: selector;     nextPutAll: ' variable: ''';     nextPutAll: temporaryVariableName;     nextPut: $'.  arg1 nextPut: $)replace: arg1 with: arg2  | tmp1 |  tmp1 := arg1 whoDefines: arg1 name.  (RBParseTreeRewriter rename: arg1 name to: arg2) executeTree: tmp1isAbstract: arg1  ^(arg1 isMeta or: [ (self literals includes: arg1 name) or: [ self literals includes: (Smalltalk globals associationAt: arg1 name) ] ]) notkeys  | tmp1 |  tmp1 := Set new.  self systemDictionary keysAndValuesDo: [:arg1 :arg2 |  | tmp2 |        arg2 isBehavior ifTrue: [ (self includesClass: arg2) ifTrue: [ tmp1 add: arg1 ] ].        tmp2 := arg2 class.        (self includesClass: tmp2) ifTrue: [ tmp1 add: arg1 ] ].  ^tmp1isEmpty  self subclassResponsibilitysetUp  super setUp.  model := self abstractVariableTestDatatestRefactoring  | tmp1 tmp2 |  tmp1 := (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'environment' class: #RBNamespace) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 6.  tmp2 := tmp1 model classNamed: #RBNamespace.  self assert: (tmp2 parseTreeFor: #includesGlobal:) equals: (self parseMethod: 'includesGlobal: aSymbol 			(self hasRemoved: aSymbol) ifTrue: [^false].			(self includesClassNamed: aSymbol) ifTrue: [^true].			self environment at: aSymbol ifAbsent: [^false].			^ true').  self assert: (tmp2 parseTreeFor: #initialize) equals: (self parseMethod: 'initialize			super initialize.			changes := changeFactory compositeRefactoryChange.			self environment: RBBrowserEnvironment new.			newClasses := IdentityDictionary new.			changedClasses := IdentityDictionary new.			removedClasses := Set new.			implementorsCache := IdentityDictionary new.			sendersCache := IdentityDictionary new')abstractVariableReferences  instanceVariables do: [:arg1 |  self abstractReferenceTo: arg1 ]testTransform  | tmp1 tmp2 tmp3 |  tmp1 := (RBRemoveClassTransformation className: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  tmp3 := tmp1 model classNamed: #Object.  self assert: tmp2 isNil.  tmp2 := self changeMock name.  self assert: ((tmp3 subclasses collect: #name) includes: tmp2) not.  self assert: ((tmp3 theMetaClass subclasses collect: #name) includes: tmp2) notaddClass  transformations add: (RBAddClassTransformation model: self model addClass: newClassName superclass: #Object subclasses: #() category: class category)caller  | tmp1 |  tmp1 := 5.  self called: tmp1 + 1 on: [ ^tmp1 ]senders  senders ifNil: [ senders := Set new.        self model allReferencesTo: oldSelector do: [:arg1 |  senders add: arg1 modelClass ] ].  ^sendersmyConditions  self getNewSelector.  expressions := self allExpressionsToInline.  ^(RBCondition definesSelector: oldSelector in: class) & ((RBCondition withBlock: [ expressions isNotEmpty ]) errorMacro: 'No callers. Use Remove Method instead.') & ((RBCondition withBlock: [ expressions size = 1 ]) errorMacro: 'All values passed as this argument must be identical.') & ((RBCondition withBlock: [ expressions first isLiteralNode ]) errorMacro: 'All values passed must be literal.')testRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddTemporaryVariableTransformation variable: 'variable2' inMethod: #methodBefore inClass: #RBAddReturnStatementTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBAddReturnStatementTransformationTest.  self assert: (tmp2 directlyDefinesMethod: #methodBefore).  self assert: (tmp2 parseTreeFor: #methodBefore) temporaries size equals: 2equalNotUsed  | tmp1 |  tmp1 = '' yourself.  (1 to: 10) do: [:arg1 |  tmp1 := arg1 printString ].  ^tmp1testTransform  | tmp1 tmp2 |  tmp1 := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  tmp1 := (RBRenameTemporaryVariableTransformation model: tmp1 model rename: #temp to: #temp2 in: self changeMock name selector: #foo) transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: self changeMock name.  self assert: (tmp2 directlyDefinesMethod: #foo).  self assert: (tmp2 parseTreeFor: #foo) temporaries size equals: 2.  self assert: ((tmp2 parseTreeFor: #foo) temporaries anySatisfy: [:arg1 |  arg1 name = #temp2 ])testAllClassesDo  | tmp1 tmp2 |  tmp2 := 0.  tmp1 := modelFactory rbNamespace new.  tmp1 allClassesDo: [:arg1 |  arg1 name = #Object ifTrue: [ arg1 allSubclasses ].        tmp2 := tmp2 + 1 ].  RBBrowserEnvironment new classesDo: [:arg1 |  tmp2 := tmp2 - 1 ].  self assert: tmp2 equals: 0testPushDownClassVariable  | tmp1 |  tmp1 := RBPushDownClassVariableRefactoring variable: #Foo1 class: RBLintRuleTestData.  self assert: ((tmp1 model classNamed: #RBLintRuleTestData) directlyDefinesClassVariable: #Foo1).  self executeRefactoring: tmp1.  (tmp1 model classNamed: #RBLintRuleTestData) withAllSubclasses do: [:arg1 |  self deny: (arg1 directlyDefinesClassVariable: #Foo1) ]transform  target compile: (class sourceCodeFor: selector) classified: (class protocolsFor: selector).  class removeMethod: selectorchanges  ^#()processCollectionMessagesFor: arg1 in: arg2  | tmp1 tmp2 |  arg2 isMessage ifFalse: [ ^self ].  (#(anyOne at: #at:ifAbsent: #at:ifAbsentPut: atPin: atRandom atRandom: atWrap: eight fifth first fourth last middle ninth second seventh sixth third) includes: arg2 selector) ifTrue: [ tmp1 := arg2 parent.        (tmp1 notNil and: [ tmp1 isMessage ]) ifFalse: [ ^self ].        arg2 == tmp1 receiver ifFalse: [ ^self ].        (variableMessages at: (self collectionNameFor: arg1) ifAbsentPut: [ Set new ]) add: tmp1 selector.        self processCollectionMessagesFor: (self collectionNameFor: arg1) in: tmp1 ].  (#(allSatisfy: anySatisfy: collect: #collect:as: detect: #detect:ifNone: detectMax: detectMin: detectSum: do: #do:displayingProgress: #do:separatedBy: #flatCollect: noneSatisfy: reject: select:) includes: arg2 selector) ifTrue: [ tmp2 := arg2 arguments first.        tmp2 isBlock ifFalse: [ ^self ].        self processCollectionFor: arg1 messagesTo: tmp2 arguments first name in: tmp2 ].  (#(reduce: reduceLeft: reduceRight:) includes: arg2 selector) ifTrue: [ tmp2 := arg2 arguments last.        tmp2 isBlock ifFalse: [ ^self ].        tmp2 arguments do: [:arg3 |  self processCollectionFor: arg1 messagesTo: arg3 name in: tmp2 ] ].  #inject:into: = arg2 selector ifTrue: [ tmp2 := arg2 arguments last.        tmp2 isBlock ifFalse: [ ^self ].        self processCollectionFor: arg1 messagesTo: tmp2 arguments last name in: tmp2 ]deleteSelectors  selectors do: [:arg1 |  class withAllSubclasses do: [:arg2 |  self delete: arg1 in: arg2 ] ]includesClass: arg1  ^(environment includesClass: arg1) and: [ arg1 selectors anySatisfy: [:arg2 |  self includesSelector: arg2 in: arg1 ] ]copyEmpty  ^self class newtestPragmaDoesNotExist  self shouldFail: (RBRemovePragmaTransformation pragma: '<gtPresentationOrder: 34>' inMethod: #methodBefore inClass: #RBRemovePragmaTransformationTest) asRefactoringincludesClassNamed: arg1  ^(self classNamed: arg1) notNilat: arg1  ^self at: arg1 ifAbsent: [ self error: arg1 printString , ' not found' ]errorBlockFor: arg1  ^arg1 ifTrue: [ nil ] ifFalse: [ failed = #leftFailed ifTrue: [ left errorBlock ] ifFalse: [ right errorBlock ] ]testRenameClass  | tmp1 |  tmp1 := changes renameClass: self class to: self class name , 'Plus'.  self assert: tmp1 oldName equals: self class name.  self assert: tmp1 newName equals: self class name , 'Plus'.  self assert: tmp1 changeClass equals: self class.  self universalTestFor: tmp1storeOn: arg1  arg1     nextPut: $(;     nextPutAll: self class name;     nextPutAll: ' onEnvironment: '.  environment storeOn: arg1.  arg1 nextPutAll: ' packageNames: '.  self packageNames asArray storeOn: arg1.  arg1 nextPut: $)removeClassVariable: arg1  self privateClassVariableNames remove: arg1 asSymbol.  model removeClassVariable: arg1 from: selfprintOn: arg1  arg1 nextPutAll: self displayStringsetUp  super setUp.  universalEnvironment := RBBrowserEnvironment newsetUp  super setUp.  workingEnvironment := Smalltalk globals.  self createMockClass.  changeFactory := RBRefactoryChangeManager changeFactory.  changes := changeFactory compositeRefactoryChangeNamed: 'testing'smallLintCritics  ^self asSelectorEnvironment smallLintCriticsisMultiEnvironment  ^falseliteralArrayWithTrueFalseOrNil2  | tmp1 tmp2 |  tmp1 := #(#true #false #nil).  tmp2 := #(#true #(#true #false #nil) #false #nil).  ^tmp1definingBlock  | tmp1 tmp2 |  tmp1 := self definingMethod ifNil: [ self refactoringError: 'Method does not exist' ] ifNotNil: [:arg1 |  arg1 variableWith: variableName ].  tmp1 ifNil: [ self refactoringError: 'Unable to locate temporary variable in parse tree' ].  tmp2 := tmp1 whoDefines: variableName.  tmp2 ifNil: [ self refactoringError: 'Cannot locate variable definition' ].  tmp2 isSequence ifFalse: [ self refactoringError: 'Variable is an argument' ].  ^tmp2run  ^Object printOn: selfselector: arg1  selector := arg1methodBefore  | tmp1 |  tmp1 := 'String'.  tmp1 byteAt: 1testMethodIsReferenced  self shouldFail: (RBRemoveMethodTransformation selector: #checkClass: from: #RBBasicLintRuleTestData) asRefactoringisComposite  ^falseviewResults  self subclassResponsibilitymessageSendWith: arg1 and: arg2 needsReturn: arg3  ^String streamContents: [:arg4 |  arg3 ifTrue: [ arg4 nextPutAll: '^ ' ].        assignments size = 1 ifTrue: [ arg4                 nextPutAll: assignments first asString;                 nextPutAll: ' := ' ].        arg4 nextPutAll: 'self '.        arg1 arguments ifEmpty: [ arg4 nextPutAll: arg1 selector asString ] ifNotEmpty: [ arg1 selector keywords size = arg1 arguments size ifTrue: [ arg1 selector keywords with: arg1 arguments do: [:arg5 :arg6 |  arg4                             nextPutAll: arg5 asString;                             nextPut: $ .                          (arg2 includesKey: arg6 asString) ifTrue: [ arg4 nextPutAll: (arg2 at: arg6 asString) ] ifFalse: [ arg4 nextPutAll: arg6 asString ].                          arg4 nextPut: $  ] ] ] ]category: arg1 for: arg2  ^self addChange: (RBClassCategoryChange category: arg1 for: arg2)setUp  super setUp.  model := self abstractVariableTestDataname: arg1  name := arg1checkBrowseOccurrenceIn: arg1  self refactoringError: ('Possible call to <2s> in <1p><n>Browse references?' expandMacrosWith: arg1 modelClass with: selector) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: selector) ]hash  ^self changeClassName hashsharedPoolNames  ^poolDictionaryNamesisMeta  ^trueifTrueBlocks  ^true ifFalse: self fooaddSearchStringFrom: arg1 in: arg2  arg1 sourceAnchor providesInterval ifTrue: [ | tmp1 |        tmp1 := arg1 sourceAnchor interval.        result addSearchString: (arg2 copyFrom: tmp1 first to: tmp1 last) ]testTransform  | tmp1 tmp2 |  tmp1 := (RBRenameAndDeprecateClassTransformation rename: self changeMock name to: #RBRefactoringChangeMock2) transform.  self assert: tmp1 model changes changes size equals: 7.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self deny: tmp2 isNil.  self assertEmpty: tmp2 selectors.  self assert: tmp2 superclass name equals: #RBRefactoringChangeMock2.  self assert: tmp2 comment equals: 'Deprecated!!! Use superclass'.  tmp2 := tmp1 model classNamed: #RBRefactoringChangeMock2.  self denyEmpty: tmp2 selectors.  tmp2 := tmp1 model classNamed: #TmpSubclass , self changeMock name asSymbol.  self assert: tmp2 isNilspecialSelectors  | tmp1 |  tmp1 := IdentityDictionary new.  (Smalltalk specialSelectors select: [:arg1 |  arg1 isSymbol ]) do: [:arg1 |  tmp1 at: arg1 put: nil ].  ^tmp1addInstanceVariable: arg1 to: arg2  ^changes addInstanceVariable: arg1 to: arg2msg3  ^Var1initialize  super initialize.  shouldFixSubclasses := true.  shouldCopyExtensions := true.  shouldRemoveExtensions := truetestExistingName  self shouldFail: (RBRenameClassTransformation rename: self class to: #Object) asRefactoringcategory: arg1  category := arg1printOn: arg1  arg1     nextPutAll: class name;     cr.  class instanceVariableNames do: [:arg2 |  arg1           tab;           nextPutAll: arg2;           tab;           nextPut: $<.        self printTypeFor: arg2 on: arg1.        arg1           nextPut: $>;           cr ]calculateArguments  | tmp1 tmp2 tmp3 |  tmp1 := parseTree allDefinedVariables difference: subtree allDefinedVariables.  tmp2 := tmp1 select: [:arg1 |  subtree references: arg1 ].  tmp3 := tmp1 select: [:arg1 |  subtree assigns: arg1 ].  ^tmp2 asOrderedCollection difference: tmp3textToDisplay  ^self definitionassociationIndex  ^selectedAssociationIndex ifNil: [ selectedAssociationIndex := 0 ]returnsBooleanAndOther  self isVariable ifTrue: [ ^false ].  self printStringcheckInstVars  selectors do: [:arg1 |  self checkInstVarsFor: arg1 ]includesClass: arg1  | tmp1 |  (environment includesClass: arg1) ifFalse: [ ^false ].  (andedEnvironment includesClass: arg1) ifFalse: [ ^false ].  tmp1 := true.  environment selectorsForClass: arg1 do: [:arg2 |  tmp1 := false.        (andedEnvironment includesSelector: arg2 in: arg1) ifTrue: [ ^true ] ].  ^tmp1privateTransform  | tmp1 tmp2 |  tmp1 := self definingMethod.  tmp2 := self parserClass parseExpression: returnValue.  tmp1 body addNode: tmp2.  self definingClass compileTree: tmp1isOverridden  | tmp1 |  tmp1 := self inlineSelector.  self inlineClass allSubclassesDo: [:arg1 |  (arg1 directlyDefinesMethod: tmp1) ifTrue: [ ^true ] ].  ^falsetestVariableDoesNotExist  self shouldFail: (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #displayName inClass: #RBDummyLintRuleTest).  self shouldFail: (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #displayName inClass: #RBDummyLintRuleTest) asRefactoringasOrderedCollectionNotNeeded  self foo addAll: (1 to: 10) asOrderedCollectionisSelectorEnvironment  ^truesymbolReference  ^#(#renameThisMethod: #(4 #renameThisMethod:))preconditions  class := self model classObjectFor: className.  ^isClassVariable ifTrue: [ RBCondition definesClassVariable: variableName asSymbol in: class ] ifFalse: [ RBCondition definesInstanceVariable: variableName in: class ]testRecursiveMethod  | tmp1 |  model := RBClassModelFactory rbNamespace new.  tmp1 := model classNamed: self class name.  tmp1     compile: 'foo ^self foo' classified: #(#accessing);     compile: 'bar ^self foo' classified: #(#accessing).  self executeRefactoring: (RBInlineAllSendersRefactoring model: model sendersOf: #foo in: tmp1).  self assert: (tmp1 parseTreeFor: #foo) equals: (self parseMethod: 'foo ^self foo').  self assert: (tmp1 parseTreeFor: #bar) equals: (self parseMethod: 'bar ^self foo')includesProtocol: arg1 in: arg2  ^(environment includesProtocol: arg1 in: arg2) and: [ self packages anySatisfy: [:arg3 |  arg3 includesMethodCategory: arg1 ofClass: arg2 ] ]implementorsCanBePrimitives  ^falseselector  ^selectorfoo  ^6placeholderNode  | tmp1 |  tmp1 := self parseTreeSearcherClass treeMatching: self methodDelimiter in: modifiedParseTree.  tmp1 ifNil: [ self refactoringFailure: 'Cannot extract code' ].  ^tmp1tempVarOverridesInstVar  | tmp1 |  tmp1 := 4.  ^tmp1metaclassNamed: arg1  | tmp1 |  arg1 ifNil: [ ^nil ].  (self hasRemoved: arg1) ifTrue: [ ^nil ].  (newClasses includesKey: arg1) ifTrue: [ ^(newClasses at: arg1) last ].  (changedClasses includesKey: arg1) ifTrue: [ ^(changedClasses at: arg1) last ].  tmp1 := environment at: arg1 ifAbsent: [ nil ].  (tmp1 isBehavior or: [ tmp1 isTrait ]) ifTrue: [ ^(self createNewClassFor: tmp1) last ].  ^nildeprecatedClass  ^deprecatedClassmodel: arg1  model := arg1selfSendIn: arg1  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: self messagePattern do: [:arg2 :arg3 |  ^arg2 ].  ^tmp1 executeTree: arg1 initialAnswer: nilprintOn: arg1  environment printOn: arg1.  arg1 nextPutAll: ' & '.  andedEnvironment printOn: arg1removeAssociation  [ | tmp1 tmp2 tmp3 |  tmp1 := argsAndValues associations at: self associationIndex.  tmp2 := tmp1 key.  tmp3 := tmp1 value.  tree := RBParseTreeRewriter replace: tmp2 with: tmp3 in: tree.  argsAndValues removeKey: tmp2.  argumentsList add: tmp2.  valuesList add: tmp3.  sourceCodeMorph contents: self sourceCode.  self     changed: #associations;     changed: #arguments;     changed: #values;     changed: #isOkEnabled ] on: Error do: [ self inform: 'Please select one association to remove.' ]addStatementNode: arg1  arg1 isMessage ifTrue: [ ^statementNodes add: arg1 ].  arg1 isCascade ifTrue: [ ^statementNodes addAll: arg1 messages ].  self refactoringFailure: arg1 formattedCode , ' is not a valid message'buildTransformations  subtree := self calculateSubtree.  ^(parseTree isNil or: [ subtree isNil ]) ifTrue: [ OrderedCollection new ] ifFalse: [ | tmp1 |        arguments := self calculateArguments.        temporaries := self calculateTemporaries.        assignments := self calculateAssignments.        tmp1 := self calculateTemporariesToRemove.        assignments size > 1 ifTrue: [ OrderedCollection new ] ifFalse: [ | tmp2 tmp3 tmp4 tmp5 |              tmp2 := self newMethodName.              tmp2 ifNil: [ ^OrderedCollection new ].              tmp5 := self calculateIfReturnIsNeeded.              newMethod := self generateNewMethodWith: tmp2.              tmp3 := self calculateNewArgumentsIn: tmp2.              tmp4 := self messageSendWith: tmp2 and: tmp3 needsReturn: tmp5.              OrderedCollection new                 add: (RBAddMethodTransformation model: self model sourceCode: newMethod newSource in: class withProtocol: Protocol unclassified);                 add: (RBReplaceSubtreeTransformation model: self model replace: sourceCode to: tmp4 inMethod: selector inClass: class);                 addAll: (tmp1 collect: [:arg1 |  RBRemoveTemporaryVariableTransformation model: self model variable: arg1 inMethod: selector inClass: class ]);                 yourself ] ]testModelExtractMethodWithTemporariesSelected  | tmp1 tmp2 |  model := RBClassModelFactory rbNamespace new.  tmp1 := model classNamed: self class name.  tmp1 compile: 'foo [| temp | temp := 5. temp * temp] value' classified: #(#accessing).  tmp2 := RBExtractMethodRefactoring model: model extract: (6 to: 36) from: #foo in: tmp1.  self setupMethodNameFor: tmp2 toReturn: #foobar.  self executeRefactoring: tmp2.  self assert: (tmp1 parseTreeFor: #foo) equals: (self parseMethod: 'foo [self foobar] value').  self assert: (tmp1 parseTreeFor: #foobar) equals: (self parseMethod: 'foobar |temp | temp := 5. ^temp * temp')printOn: arg1  arg1     nextPutAll: self displayClassName;     nextPutAll: ' removeProtocolNamed: ';     print: self displayProtocolName;     nextPutAll: ' stamp: ';     print: self changeStamp;     nextPutAll: '!'calls1  ^self rewriteRule10: (self rewriteRule10: self calls)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' className ''';     nextPutAll: className;     nextPutAll: ''' newClassName: ''';     nextPutAll: newClassName.  arg1 nextPut: $)testPushDownNonExistantMenu  | tmp1 |  tmp1 := RBPushDownMethodRefactoring pushDown: #(#someMethodThatDoesNotExist) from: RBLintRuleTestData.  self shouldFail: tmp1whileTrue  | tmp1 |  tmp1 := 1.  [ tmp1 < self size ] whileTrue: [ (self at: tmp1) printString.        tmp1 := tmp1 + 1 ]endTrueFalse  self isVariable ifTrue: [ self printString.        self isVariable printString ] ifFalse: [ self printString.        ^4 ]smallLintCritics  | tmp1 |  tmp1 := OrderedCollection new.  self classes do: [:arg1 |  self selectorsForClass: arg1 do: [:arg2 |  tmp1 add: arg1 >> arg2 ] ].  ^tmp1description  ^self changes nameisEmpty  ^(rules detect: [:arg1 |  arg1 isEmpty not ] ifNone: [ nil ]) isNilrenameThisMethod: arg1  ^selftestAPI  | tmp1 |  tmp1 := RBTransformation allSubclasses select: [:arg1 |  | tmp2 |        tmp2 := arg1 methods collect: #selector.        arg1 subclasses isEmpty and: [ (tmp2 includes: #privateTransform) not and: [ (tmp2 includes: #storeOn:) not ] ] ].  self assertEmpty: tmp1.  tmp1 := RBCompositeTransformation allSubclasses select: [:arg1 |  | tmp2 |        tmp2 := arg1 methods collect: #selector.        arg1 subclasses isEmpty and: [ (tmp2 includes: #buildTransformations) not ] ].  self assertEmpty: tmp1moveMethod  | tmp1 tmp2 |  tmp1 := self selectVariableToMoveMethodTo: extractedMethodSelector class: class.  tmp1 ifNil: [ self refactoringFailure: 'Did not extract method' ].  tmp2 := RBMoveMethodRefactoring model: self model selector: extractedMethodSelector class: class variable: tmp1.  self performComponentRefactoring: tmp2multipleCalls  self caller2.  self caller2whichSelectorsReferToInstanceVariable: arg1  | tmp1 |  tmp1 := Set new.  newMethods ifNotNil: [ newMethods do: [:arg2 |  (arg2 refersToVariable: arg1) ifTrue: [ tmp1 add: arg2 selector ] ] ].  self isDefined ifTrue: [ tmp1 addAll: (self existingMethodsThatReferToInstanceVariable: arg1) ].  ^tmp1threeElementPoint  ^(5 @ 5 + 6) @ 6buildSimpleLiteralSearch  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matchesAnyTreeOf: (Array with: (RBParser parseExpression: '#(''bugs'' ''possible bugs'' ''unnecessary code'' ''intention revealing'' ''miscellaneous'')')) do: [:arg1 :arg2 |  arg2           remove: self currentSelector ifAbsent: [ self error: 'failed' ];           yourself ].  tmp1 answer: #(#protocolsToCheck) asBag.  (classSearches at: RBBasicLintRuleTestData class ifAbsentPut: [ Set new ]) add: tmp1asUndoOperation  ^self class definition: self changeClass class oldDefinitionrewriteCascadedMessage  | tmp1 tmp2 |  tmp2 := sourceMessage parent messages.  tmp1 := (1 to: tmp2 size) detect: [:arg1 |  sourceMessage == (tmp2 at: arg1) ] ifNone: [ 0 ].  inlineParseTree body addNodesFirst: (tmp2 copyFrom: 1 to: tmp1 - 1).  self removeReturns.  inlineParseTree body addNodes: (tmp2 copyFrom: tmp1 + 1 to: tmp2 size).  inlineParseTree addReturntestAddClassInstanceVariable  | tmp1 |  tmp1 := changes addInstanceVariable: 'instVar' to: self class class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class class.  self assert: tmp1 isMeta.  self assert: tmp1 variable equals: 'instVar'.  self universalTestFor: tmp1pullUpPoolVariables  | tmp1 |  tmp1 := self abstractSuperclass.  parent sharedPoolNames do: [:arg1 |  tmp1 addPoolDictionary: arg1 ]consistencyCheck  ^(1 to: 10) size > 0inlineFoo: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 value: self.  tmp2 := tmp1 + tmp1.  tmp3 := tmp2 + tmp1.  ^tmp3storeOn: arg1  arg1 nextPut: $(.  super storeOn: arg1.  arg1 nextPutAll: ' categories: '.  categories asArray storeOn: arg1.  arg1 nextPut: $)pushDown: arg1  | tmp1 tmp2 tmp3 |  tmp1 := class sourceCodeFor: arg1.  tmp2 := class protocolsFor: arg1.  tmp3 := RBExpandReferencedPoolsRefactoring model: self model forMethod: (class parseTreeFor: arg1) fromClass: class toClasses: class subclasses.  self performComponentRefactoring: tmp3.  class subclasses do: [:arg2 |  (arg2 directlyDefinesMethod: arg1) ifFalse: [ arg2 compile: tmp1 classified: tmp2 ] ]testRemoveClass  | tmp1 |  tmp1 := changes removeClass: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self universalTestFor: tmp1leaves  ^rules flatCollect: [:arg1 |  arg1 leaves ]checkReferences  | tmp1 |  tmp1 := OrderedCollection new.  self model allReferencesTo: selector do: [:arg1 |  selector = arg1 selector ifFalse: [ tmp1 add: selector -> arg1 ] ].  tmp1 ifEmpty: [ ^self ].  ^self checkBrowseOccurrences: tmp1category: arg1  category := arg1testExtractFailure  self     shouldFail: (RBExtractMethodRefactoring extract: (80 to: 269) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class);     shouldFail: (RBExtractMethodRefactoring extract: (53 to: 56) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class);     shouldFail: (RBExtractMethodRefactoring extract: (77 to: 222) from: #subclassResponsibilityNotDefined in: RBBasicLintRuleTestData class)execute: arg1  ^matchers inject: arg1 asString into: [:arg2 :arg3 |  self execute: arg2 replace: arg3 key with: arg3 value ]classVariableNames  ^classVariableNamestestNonExistantName  self     shouldFail: (RBTemporaryToInstanceVariableRefactoring class: RBBasicLintRuleTestData selector: #checkClass: variable: 'asdf');     shouldFail: (RBTemporaryToInstanceVariableRefactoring class: RBBasicLintRuleTestData selector: #checkClass1: variable: 'aSmalllintContext')testRenameInstVar  | tmp1 tmp2 |  tmp1 := RBRenameInstanceVariableRefactoring rename: 'classBlock' to: 'asdf' in: RBBasicLintRuleTestData.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBBasicLintRuleTestData.  self assert: (tmp2 directlyDefinesInstanceVariable: 'asdf').  self deny: (tmp2 directlyDefinesInstanceVariable: 'classBlock').  self assert: (tmp2 parseTreeFor: #checkClass:) equals: (self parseMethod: 'checkClass: aSmalllintContext 								^asdf value: aSmalllintContext value: result').  self assert: (tmp2 parseTreeFor: #initialize) equals: (self parseMethod: 'initialize	super initialize.	self anInstVar: 1.	asdf := [:context :aResult | ].	methodBlock := [:context :aResult | ].	self resultClass: RBSelectorEnvironment')replaceClassNameIn: arg1 to: arg2  | tmp1 |  tmp1 := self parserClass parseExpression: arg1.  tmp1 receiver: (RBVariableNode named: arg2).  ^tmp1 formattedCodemodelClass: arg1  class := arg1includesCategory: arg1  ^(super includesCategory: arg1) and: [ self packages anySatisfy: [:arg2 |  arg2 includesSystemCategory: arg1 ] ]usesTrue  ^TrueproblemCount  ^rules inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 problemCount ]errorStringFor: arg1  ^self errorMacro expandMacrosWith: arg1privateTransform  isClassVariable ifTrue: [ self definingClass theNonMetaClass removeClassVariable: variableName ] ifFalse: [ self definingClass removeInstanceVariable: variableName ]transform  self refactorings do: [:arg1 |  self performComponentRefactoring: arg1 ]testRenameClassInstanceVariable  | tmp1 |  tmp1 := changes renameInstanceVariable: 'instVar1' to: 'instVar2' in: self class class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 oldName equals: 'instVar1'.  self assert: tmp1 newName equals: 'instVar2'.  self universalTestFor: tmp1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' pullUp: '.  selectors asArray storeOn: arg1.  arg1 nextPutAll: ' from: '.  class storeOn: arg1.  arg1 nextPut: $)skipAction: arg1  skipAction := arg1inlineSelfSends  class withAllSubclasses do: [:arg1 |  | tmp1 |        tmp1 := arg1 selectors.        tmp1 remove: selector ifAbsent: [  ].        tmp1 do: [:arg2 |  self inlineMessagesInClass: arg1 andSelector: arg2 ] ]testMetaclassInstanceVariables  | tmp1 tmp2 |  tmp2 := model metaclassNamed: #Foo.  tmp2 addInstanceVariable: 'foo'.  tmp2 compile: 'zzz ^foo := foo + foo * 2' classified: #(#testing).  tmp1 := RBAbstractInstanceVariableRefactoring model: model variable: 'foo' class: tmp2.  self executeRefactoring: tmp1.  self assert: (tmp2 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1						^foo').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: anObject						^foo := anObject').  self assert: (tmp2 parseTreeFor: #zzz) equals: (self parseMethod: 'zzz ^self foo: self foo1 + self foo1 * 2')checkAllBlocksIn: arg1  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: '[:`@blockTemps | | `@temps | `@.Statements]' do: [:arg2 :arg3 |  (arg2 references: variableName) ifTrue: [ arg3 add: arg2 ].        arg3 ].  ^tmp1 executeTree: arg1 initialAnswer: OrderedCollection newrewriteRule10  ^rewriteRule10renameClass: arg1 to: arg2 around: arg3  | tmp1 tmp2 tmp3 |  tmp1 := changeFactory renameClass: arg1 to: arg2.  self performChange: tmp1 around: arg3.  self flushCaches.  tmp3 := (newClasses includesKey: arg1 name) ifTrue: [ newClasses ] ifFalse: [ changedClasses ].  self markAsRemoved: arg1 name.  self unmarkAsRemoved: arg2.  tmp2 := tmp3 at: arg1 name.  tmp3 removeKey: arg1 name.  tmp3 at: arg2 put: tmp2.  tmp2 first name: arg2.  tmp2 last name: arg2.  tmp2 first subclasses do: [:arg4 |  arg4 superclass: tmp2 first ].  tmp2 last subclasses do: [:arg4 |  arg4 superclass: tmp2 last ].  ^tmp1removeMethod: arg1 from: arg2  ^RBRemoveMethodChange remove: arg1 from: arg2includesClass: arg1  (environment includesClass: arg1) ifFalse: [ ^true ].  ^falsecategory: arg1  category := arg1environmentWithReferencesTo: arg1  ^RBBrowserEnvironment new referencesTo: (self environment associationAt: arg1 ifAbsent: [ arg1 ])changeSymbol  self subclassResponsibilitynewTree  ^treetoDoWithIncrement  | tmp1 |  tmp1 := 0.  1 to: 10 by: 2 do: [:arg1 |  tmp1 := tmp1 + 2 ].  ^tmp1testModelAddMethod  | tmp1 tmp2 |  tmp2 := model metaclassNamed: #Bar.  tmp1 := RBAddMethodRefactoring model: model addMethod: 'printString1 ^super printString' toClass: tmp2 inProtocols: #(#accessing).  self executeRefactoring: tmp1.  self assert: (tmp2 parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')on: arg1  arg1 keysAndValuesDo: [:arg2 :arg3 |  arg2 isMeta ifTrue: [ metaClassSelectors at: arg2 soleInstance name put: arg3 asIdentitySet ] ifFalse: [ classSelectors at: arg2 name put: arg3 asIdentitySet ] ]getArgumentNameForSelf  self needsToReplaceSelfReferences ifFalse: [ ^self ].  [ selfVariableName := self requestSelfArgumentName.  (self checkInstanceVariableName: selfVariableName in: class) ifTrue: [ self verifyTemporaryVariableDoesNotOverride ifFalse: [ self refactoringWarning: 'The variable is already defined in one of the classes you''re moving the method to.<n>Try another?' expandMacros.              selfVariableName := nil ] ] ifFalse: [ self refactoringWarning: 'The variable name is not a valid Smalltalk temporary variable name<n>Try again?' expandMacros.        selfVariableName := nil ].  selfVariableName isNil ] whileTrue: [  ]testRemoveClassInstanceVariable  | tmp1 |  tmp1 := changes removeInstanceVariable: 'instVar' from: self class class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class class.  self assert: tmp1 isMeta.  self assert: tmp1 variable equals: 'instVar'.  self universalTestFor: tmp1directlyDefinesClassVariable: arg1  ^self instanceSide directlyDefinesClassVariable: arg1hasPoolsToMove  ^pools isNotEmptychangeIsKindOfReferences  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1 replace: '``@object isKindOf: ' , parent name with: '``@object isKindOf: ' , className.  self convertAllReferencesToClass: parent using: tmp1longMethods  self printString.  self printString.  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ]addClass: arg1 selector: arg2 into: arg3  (environmentDictionaries at: arg3 ifAbsentPut: [ RBSelectorEnvironment new ]) addClass: arg1 selector: arg2context: arg1  context := arg1symbolReference  ^#RBDummyClassToRenamecompileHash  | tmp1 tmp2 tmp3 |  tmp1 := self parserClass parseMethod: 'hash		"Answer an integer value that is related to the identity of the receiver."'.  tmp2 := nil.  variables reversed do: [:arg1 |  tmp3 := RBMessageNode receiver: (RBVariableNode named: arg1) selector: #hash.        tmp2 := tmp2 ifNil: [ tmp3 ] ifNotNil: [ RBMessageNode receiver: tmp3 selector: #bitXor: arguments: (Array with: tmp2) ] ].  tmp1     addNode: tmp2;     addReturn.  self theClass compile: tmp1 formattedCode classified: #(comparing)allClassesAndTraits  | tmp1 |  tmp1 := OrderedCollection new: 4096.  self allClassesAndTraitsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1 asArraytestExtractFailure  self shouldFail: (RBReplaceSubtreeTransformation replace: ':= aSelector' to: '^ selector' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoringinlineForwarder  | tmp1 |  tmp1 := RBInlineAllSendersRefactoring model: self model sendersOf: extractedMethodSelector in: class.  tmp1 setOption: #inlineExpression toUse: [:arg1 :arg2 |  true ].  self performComponentRefactoring: tmp1checkMethod: arg1  rules do: [:arg2 |  arg2 checkMethod: arg1 ]testEmptyCode  | tmp1 |  tmp1 := (RBRemoveSubtreeTransformation code: '' from: #one in: self changeMock name) transform.  self assertEmpty: tmp1 model changes changes.  self shouldFail: (RBRemoveSubtreeTransformation code: '' from: #selector:from: in: #RBRemoveMethodTransformation) asRefactoringtestMethod1  ^self testMethod1 , ([:arg1 |  arg1 testMethod1 ] value: #(#(#testMethod1) 2 #testMethod1))printOn: arg1  arg1     nextPutAll: self displayClassName;     nextPutAll: ' removeClassVarName: ';     print: self oldName;     nextPut: $!;     cr.  arg1     nextPutAll: self displayClassName;     nextPutAll: ' addClassVarName: ';     print: self newName;     nextPut: $!parseTreeRewriter  | tmp1 tmp2 tmp3 |  tmp1 := RBParseTreeRewriter new.  tmp2 := self buildSelectorString: oldSelector.  tmp3 := self buildSelectorString: newSelector withPermuteMap: permutation.  tmp1 replace: '``@object ' , tmp2 with: '``@object ' , tmp3.  ^tmp1calls1  ^self rewriteRule1: (self rewriteRule1: self calls)removePoolDictionary: arg1  self privatePoolDictionaryNames remove: arg1 asSymboltestRenameInstanceVariable  | tmp1 |  tmp1 := changes renameInstanceVariable: 'instVar1' to: 'instVar2' in: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 oldName equals: 'instVar1'.  self assert: tmp1 newName equals: 'instVar2'.  self universalTestFor: tmp1addClass: arg1 instanceVariableReader: arg2  (instanceVariableReaders at: arg1 name ifAbsentPut: [ Set new ]) add: arg2.  self flushCachesFor: arg1.  self addSearchString: arg2testNewInstanceVariableAccessors  | tmp1 tmp2 |  tmp1 := (RBAddVariableAccessorTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  tmp2 := tmp1 model classNamed: #RBDummyLintRuleTest.  self denyEmpty: tmp1 changes changes.  self assert: (tmp2 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^foo1').  self assert: (tmp2 parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject foo1 := anObject')disconnectFromChanges  SystemAnnouncer uniqueInstance unsubscribe: selftestCompileInMetaclass  | tmp1 |  tmp1 := changes compile: 'new' in: self class class.  self assert: tmp1 controller isNil.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class class.  self assert: tmp1 isMeta.  self assert: tmp1 selector equals: #new.  self assert: tmp1 source equals: 'new'.  self assert: tmp1 protocol equals: #accessing.  self universalTestFor: tmp1transform  self     abstractVariables;     addSelfReturn;     replaceSelfReferences;     replaceVariableReferences;     compileNewMethods;     compileDelegatorMethodtheClass  ^(self classObjectFor: className) instanceSideverifyTemporaryVariableDoesNotOverride  (parseTree allDefinedVariables includes: selfVariableName) ifTrue: [ ^false ].  ^moveToClasses noneSatisfy: [:arg1 |  arg1 definesVariable: selfVariableName ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ''' inInterval: ''';     nextPutAll: interval;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)hasReferencesToTemporaryIn: arg1  | tmp1 |  tmp1 := arg1 parseTreeFor: oldSelector.  tmp1 ifNil: [ self refactoringFailure: 'Cannot parse sources.' ].  ^tmp1 references: (tmp1 argumentNames at: parameterIndex)testInlineMethod4  | tmp1 |  tmp1 := RBInlineMethodRefactoring inline: (31 to: 112) inMethod: #inlineJunk forClass: RBRefactoryTestDataApp.  self setupInlineExpressionFor: tmp1 toReturn: false.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineJunk) equals: (self parseMethod: 'inlineJunk										| asdf bar1 baz1 asdf1 |										bar1 := 												[:each | 												| temp |												temp := each.												temp , temp] value: self.										baz1 := bar1 + bar1.										asdf1 := baz1 + bar1.										asdf := asdf1.										^asdf foo: 												[:bar | 												| baz |												baz := bar.												baz * baz]')protocol  ^protocol ifNil: [ UIManager default chooseOrRequestFrom: self definingClass protocols title: 'Class name was not defined to perform ' , self class baseClass name , '. Please select a class to resume this transformation.' ]replaceAllAction: arg1  replaceAllAction := arg1controller  ^controllerguessTypesFor: arg1 in: arg2  class = arg2 ifFalse: [ self runOn: arg2 ].  ^bestGuesses at: arg1 ifAbsent: [ self typesFor: arg1 in: arg2 ]selectedClass  ^classdisplayCategoryName  ^categorypreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ (self definingMethod allChildren select: #isMessage) anySatisfy: [:arg1 |  arg1 selector = message asSymbol ] ] errorString: ('Method named <1s> does not implement this message send <2s>' expandMacrosWith: selector with: message))privateTransform  | tmp1 tmp2 |  tmp1 := self definingClass parseTreeFor: selector.  tmp1 ifNil: [ ^self ].  tmp2 := self parserClass parseExpression: sourceCode onError: [:arg1 :arg2 |  ^self ].  tmp1 body statements ifEmpty: [ tmp1 addNode: tmp2.        ^self ].  tmp1 := tmp1 allSequenceNodes detect: [:arg3 |  arg3 intersectsInterval: interval ] ifFound: [:arg3 |  self addNode: tmp2 toSequence: arg3 ] ifNone: [ tmp1 body addNodeLast: tmp2.        tmp1 ].  self definingClass compileTree: tmp1changeClassName: arg1  className := arg1.  isMeta ifNil: [ isMeta := false ]referencesConditionFor: arg1  | tmp1 tmp2 |  ^(RBCondition withBlock: [ tmp2 := Smalltalk associationAt: arg1 name ifAbsent: [ self refactoringError: 'Could not find class' ].        tmp1 := (self environment referencesTo: tmp2) | (self environment referencesTo: arg1 name).        tmp1 isEmpty ])     errorMacro: arg1 , ' is referenced.<n>Browse references?';     errorBlock: [ tmp1 openEditor ];     yourselfremovePool: arg1 from: arg2  ^self addChange: (changeFactory removePoolVariable: arg1 from: arg2)asRBRule  ^selfunknownFailed  ^(left errorStringFor: false) , ' OR ' , (right errorStringFor: false)addClass  self performComponentRefactoring: (RBAddClassRefactoring model: self model addClass: newClassName superclass: Object subclasses: #() category: class category).  newClass := self model classNamed: newClassName asSymboltestRefactoring  | tmp1 tmp2 |  tmp1 := (RBRemoveVariableTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) asRefactoring.  tmp2 := tmp1 model classNamed: #RBDummyLintRuleTest.  self assert: (tmp2 definesInstanceVariable: 'foo1').  tmp1 transform.  self deny: (tmp2 definesInstanceVariable: 'foo1')removeClassNamed: arg1  (self classNamed: arg1) subclasses do: [:arg2 |  self removeClassNamed: arg2 name ].  removedClasses     add: arg1;     add: arg1 , ' class'.  newClasses removeKey: arg1 ifAbsent: [  ].  changedClasses removeKey: arg1 ifAbsent: [  ].  self flushCaches.  ^changes removeClassNamed: arg1copyDownMethods  selectors do: [:arg1 |  self copyDownMethod: arg1 ]allInstanceVariableNames  | tmp1 |  tmp1 := self superclass.  ^tmp1 ifNil: [ self instanceVariableNames ] ifNotNil: [ tmp1 allInstanceVariableNames , self instanceVariableNames ]allClassesDo: arg1  self systemDictionaryClassesDo: arg1transform  class removeClassVariable: variableName.  destinationClass ifNil: [ ^self ].  destinationClass addClassVariable: variableNamevariableDefinitionsInHierarchy  self flag: #pharoTodo.  ^isClassVariable ifTrue: [ self definingClass allSubclasses reject: [:arg1 |  (arg1 whichSelectorsReferToClassVariable: variableName) isEmpty and: [ (arg1 theMetaClass whichSelectorsReferToClassVariable: variableName) isEmpty ] ] ] ifFalse: [ self definingClass subclasses ]shouldntRaiseError  self shouldnt: [ 0 / 1 ] raise: ErrorliteralArrayWithTrueFalseOrNil  | tmp1 tmp2 tmp3 |  tmp1 := #(true false nil).  tmp2 := #(#true #false #nil).  tmp3 := {true .   false .   nil}.  ^{tmp1 .   tmp2 .   tmp3}consistencyCheck  ^(1 to: 10) size > 0sizeCheck  self isEmpty ifFalse: [ self do: [:arg1 |  Transcript                 show: arg1;                 cr ] ]myConditions  | tmp1 |  tmp1 := self model allImplementorsOf: oldSelector.  self getNewSelector.  ^tmp1 inject: (RBCondition definesSelector: oldSelector in: class) into: [:arg1 :arg2 |  arg1 & (RBCondition withBlock: [ (self hasReferencesToTemporaryIn: arg2) not ] errorString: 'This argument is still referenced in at least one implementor!!') ]testRemoveClassWithBadNameRaisesRBRefactoringError  self shouldFail: (RBRemoveClassRefactoring classNames: #(#RecursiveSelfRule))shouldnt: arg1  self deny: arg1 valuevariable: arg1 fromClass: arg2 toClass: arg3  variableName := arg1.  className := arg3.  oldClass := arg2checkPackage: arg1  (environment includesPackage: arg1) ifTrue: [ rule checkPackage: arg1 ]removeInstanceVariable: arg1 from: arg2  ^changes removeInstanceVariable: arg1 from: arg2testRefactoring  | tmp1 tmp2 |  tmp1 := (RBRemoveAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBRemoveAssignmentTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBRemoveAssignmentTransformationTest.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodysubclassRedefines: arg1  ^self allSubclasses anySatisfy: [:arg2 |  arg2 directlyDefinesMethod: arg1 ]testRefactoring  | tmp1 |  tmp1 := (RBAddMethodTransformation sourceCode: 'printString1 ^super printString' in: #RBBasicDummyLintRuleTest withProtocol: #accessing) asRefactoring transform.  self assert: ((tmp1 model classNamed: #RBBasicDummyLintRuleTest) parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')instVarNames  ^self selectedClass allInstVarNamesprintOn: arg1  super printOn: arg1.  self selectedClass ifNotNil: [ arg1           nextPut: $ ;           nextPutAll: self selectedClass name.        self selector ifNotNil: [ arg1                 nextPutAll: '>>';                 print: self selector ] ]= arg1  self class = arg1 class ifFalse: [ ^false ].  ^className = arg1 changeClassName and: [ isMeta = arg1 isMeta and: [ oldName = arg1 oldName and: [ newName = arg1 newName ] ] ]checkMethod: arg1  class := arg1 selectedClass.  (rewriteRule executeTree: arg1 parseTree) ifTrue: [ (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: [ builder compile: rewriteRule tree printString in: class classified: arg1 protocols ] ]allClassVariableNames  ^self instanceSide allClassVariableNamescreateSetterAccessor  (self definingClass setterMethodFor: variableName) ifNil: [ self defineSetterMethod ]classes: arg1 metaClasses: arg2  classSelectors := IdentityDictionary new.  metaClassSelectors := IdentityDictionary new.  arg1 do: [:arg3 |  classSelectors at: arg3 first put: arg3 last asIdentitySet ].  arg2 do: [:arg3 |  metaClassSelectors at: arg3 first put: arg3 last asIdentitySet ]transform  self preconditionChecking ifTrue: [ self checkPreconditions ].  self privateTransformwhichSelectorsReferToSymbol: arg1  | tmp1 |  tmp1 := Set new.  newMethods ifNotNil: [ newMethods do: [:arg2 |  (arg2 refersToSymbol: arg1) ifTrue: [ tmp1 add: arg2 selector ] ] ].  self isDefined ifTrue: [ tmp1 addAll: (self existingMethodsThatReferTo: arg1) ].  ^tmp1comment: arg1 in: arg2  ^self addChange: (changeFactory comment: arg1 in: arg2)getClassForGlobalOrClassVariable  | tmp1 tmp2 |  tmp1 := class whoDefinesClassVariable: (variable ifNil: [ '' ]).  tmp1 ifNil: [ tmp2 := self model classNamed: variable.        tmp2 ifNil: [ tmp2 := self model classNamed: #Object ] ] ifNotNil: [ tmp2 := tmp1 typeOfClassVariable: variable ].  moveToClasses := self selectVariableTypesFrom: (Array with: tmp2) selected: (Array with: tmp2).  moveToClasses ifNil: [ self refactoringFailure: 'Method not moved' ]initialize  super initialize.  renameAccessors := falsetestTransform  | tmp1 tmp2 |  tmp1 := (RBAddPragmaTransformation new pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #methodBefore inClass: self class name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyprintOn: arg1  super printOn: arg1.  arg1 nextPutAll: ' class'environment  ^environmentremovedMethods  ^removedMethods ifNil: [ removedMethods := Set new ] ifNotNil: [ removedMethods ]preconditionIsNotMetaclass: arg1  ^((RBCondition isMetaclass: arg1) errorMacro: 'Cannot remove just the metaclass') notaddCategory: arg1  categories add: arg1referencesFor: arg1  ^isClassVariable ifTrue: [ arg1 whichSelectorsReferToClassVariable: variableName ] ifFalse: [ arg1 whichSelectorsReferToInstanceVariable: variableName ]renameClass: arg1 to: arg2  ^self addChange: (changeFactory renameClass: arg1 to: arg2)testExistingVariable  | tmp1 |  tmp1 := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  self shouldFail: (RBRenameTemporaryVariableTransformation model: tmp1 model rename: #temp to: #bar in: self changeMock name selector: #foo)refactoringError: arg1 with: arg2  ^RBRefactoringError signal: arg1 with: arg2setUp  super setUp.  model := self abstractVariableTestDataprintOn: arg1  name ifNil: [ ^super printOn: arg1 ].  arg1 nextPutAll: namedefinitionString  ^String streamContents: [:arg1 |  arg1           nextPutAll: self superclass printString;           nextPutAll: ' subclass: #';           nextPutAll: self name;           nextPutAll: ' instanceVariableNames: '''.        self instanceVariableNames do: [:arg2 |  arg1                 nextPutAll: arg2;                 nextPut: $  ].        arg1 nextPutAll: ''' classVariableNames: '''.        self classVariableNames do: [:arg2 |  arg1                 nextPutAll: arg2;                 nextPut: $  ].        arg1 nextPutAll: ''' poolDictionaries: '''.        self poolDictionaryNames do: [:arg2 |  arg1                 nextPutAll: arg2;                 nextPut: $  ].        arg1 nextPutAll: ''' category: #'''.        arg1 nextPutAll: self category asString.        arg1 nextPut: $' ]text  ^'method ^1'orEnvironment: arg1  orEnvironment := arg1testWithTemporaryVariable2  | tmp1 tmp2 |  tmp1 := (RBExtractMethodTransformation extract: (self sourceCodeAt: (78 to: 197) forMethod: #displayName in: RBDummyLintRuleTest) from: #displayName to: #foo: in: #RBDummyLintRuleTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: #RBDummyLintRuleTest.  self assert: (tmp2 parseTreeFor: #displayName) equals: (self parseMethod: 'displayName					| nameStream |					nameStream := WriteStream on: (String new: 64).					self foo: nameStream.					^nameStream contents').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: nameStream					nameStream nextPutAll: self name;								nextPutAll: '' (''.					self problemCount printOn: nameStream.					nameStream nextPut: $).')renameClassVariable: arg1 to: arg2 in: arg3  ^self addChange: (changeFactory renameClassVariable: arg1 to: arg2 in: arg3)basicCheck: arg1  arg1 isFromTrait ifTrue: [ ^false ].  (self rewriteRule canMatchMethod: arg1) ifFalse: [ ^false ].  class := arg1 methodClass.  ^(self rewriteRule executeTree: arg1 ast copy) and: [ (self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) not ]definition  ^definitionprintOn: arg1  arg1 nextPutAll: type asStringtestClassDoesNotExist  self shouldFail: (RBRemoveTemporaryVariableTransformation variable: 'temp' inMethod: #foo inClass: #RBTemporaryVariableTransformationTest) asRefactoringisMovingToArgument  ^(parseTree arguments collect: [:arg1 |  arg1 name ]) includes: variablepossibleSetterSelectors  ^self methodsReferencingVariable select: [:arg1 |  arg1 numArgs == 1 ]transform  | tmp1 tmp2 |  self model allClassesDo: [:arg1 |  (arg1 isNil or: [ arg1 isMeta ]) ifFalse: [ tmp1 := self execute: arg1 name.              tmp1 = arg1 name asString ifFalse: [ tmp2 := self perform: mode with: arg1 with: tmp1 asSymbol.                    (tmp2 notNil and: [ tmp2 preconditions check ]) ifTrue: [ tmp2 transform ] ] ] ]renameInstanceVariable: arg1 to: arg2 in: arg3  ^self addChange: (changeFactory renameInstanceVariable: arg1 to: arg2 in: arg3)renameAccessors: arg1  renameAccessors := arg1testDoesNotUnderstandAccessors  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation model: model instanceVariable: 'instVarName1' class: #Foo) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: 'RecursiveSelfRule' class: #RBTransformationRuleTestData) asRefactoringstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' split: '.  selectedInterval storeOn: arg1.  arg1     nextPutAll: ' inMethod: #';     nextPutAll: selector;     nextPutAll: ' forClass: '.  class storeOn: arg1.  arg1 nextPut: $)testMethodDoesNotExist  self shouldFail: (RBAddMessageSendTransformation messageSend: 'variable byteAt: 1' inMethod: #method inClass: #RBAddMessageSendTransformationTest) asRefactoringuncommonMessageSend  true falseenvironmentWithReferencesTo: arg1  ^RBBrowserEnvironment new referencesTo: (Smalltalk globals associationAt: arg1 ifAbsent: [ arg1 ])name  ^'Guarding clauses'privateInstanceVariableNames  instanceVariableNames ifNil: [ self isDefined ifTrue: [ self instanceVariableNames: self realClass instVarNames ] ifFalse: [ instanceVariableNames := OrderedCollection new ] ].  ^instanceVariableNamesasUndoOperation  ^changeFactory addPoolVariable: self variable to: self changeClasspackages  ^self classes collect: #packageminMax  ^3 < 5 ifTrue: [ 3 ] ifFalse: [ 5 ]hasConflicts  ^falsedefinesClass: arg1  ^environment definesClass: arg1selector: arg1 class: arg2 variable: arg3  selector := arg1.  class := self classObjectFor: arg2.  variable := arg3not  ^environmenttestBadName  self     shouldFail: (RBRenameClassTransformation rename: #RBDummyLintRuleTest to: self objectClassVariable) asRefactoring;     shouldFail: (RBRenameClassTransformation rename: #RBDummyLintRuleTest to: #'Ob ject') asRefactoringaddMethod: arg1  self newMethods at: arg1 selector put: arg1.  removedMethods notNil ifTrue: [ removedMethods remove: arg1 selector ifAbsent: [  ] ]testIsValid  | tmp1 |  tmp1 := RBMethodName selector: #foo: arguments: #('x').  self assert: tmp1 isValid.  tmp1 := RBMethodName selector: #foo:arg: arguments: #('x' 'y').  self assert: tmp1 isValid.  tmp1 := RBMethodName selector: #foo:arg: arguments: #('x').  self deny: tmp1 isValid.  tmp1 := RBMethodName selector: #foo: arguments: #('x' 'y').  self deny: tmp1 isValid.  tmp1 := RBMethodName selector: 'fggfg gg g ' arguments: #('x').  self deny: tmp1 isValidrenameNode: arg1  (arg1 whoDefines: newName) ifNotNil: [ self refactoringError: newName asString , ' is already defined' ].  (arg1 allDefinedVariables includes: newName) ifTrue: [ self refactoringError: newName asString , ' is already defined' ].  (RBParseTreeRewriter rename: oldName to: newName) executeTree: arg1collectSelectNotUsed  (1 to: 10) select: [:arg1 |  arg1 = 4 ]testClassDoesNotExist  self shouldFail: (RBRemoveMessageSendTransformation messageSend: #byteAt: inMethod: #methodBefore inClass: #RBMessageSendTransformationTest) asRefactoringrealName: arg1  self realClass: (self class environment at: arg1)basicCheck: arg1  ^(self leaves select: [:arg2 |  arg2 class perform: (arg1 isCompiledMethod ifTrue: [ #checksMethod ] ifFalse: [ #checksClass ]) ]) anySatisfy: [:arg2 |  arg2 basicCheck: arg1 ]fillOutDefinition: arg1  className := (arg1 at: '`className') asSymbol.  classInstanceVariableNames := self namesIn: (arg1 at: '`#instanceVariableNames' ifAbsent: [ String new ])transform  self extractReceiver.  self splitCascadeaddPool: arg1 to: arg2  ^self addChange: (changeFactory addPoolVariable: arg1 to: arg2)preconditions  class := self definingClass.  ^(isClassVariable ifTrue: [ (RBCondition isMetaclass: class) & (RBCondition isValidClassVarName: variableName for: class) ] ifFalse: [ (RBCondition isMetaclass: class) not & (RBCondition isValidInstanceVariableName: variableName for: class) ]) & (RBCondition hierarchyOf: class definesVariable: variableName asString) not & (RBCondition isGlobal: variableName in: self model) nottestPragmaAlreadyExists  self shouldFail: (RBAddPragmaTransformation pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #methodAfter inClass: #RBAddPragmaTransformationTest) asRefactoringviewResults  result openEditortestTransform  | tmp1 tmp2 |  tmp1 := (RBAddAccessorsForClassTransformation className: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 parseTreeFor: #instVar) equals: (self parseMethod: 'instVar ^instVar').  self assert: (tmp2 parseTreeFor: #instVar:) equals: (self parseMethod: 'instVar: anObject instVar := anObject')equalsTrue  ^true == selfgetterSetterMethods  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1     answer: Set new;     matchesAnyMethodOf: (Array with: '`method ^' , variableName with: ('`method: `arg <1s> := `arg' expandMacrosWith: variableName) with: ('`method: `arg ^<1s> := `arg' expandMacrosWith: variableName)) do: [:arg1 :arg2 |  (class subclassRedefines: arg1 selector) ifFalse: [ arg2 add: arg1 selector ].        arg2 ].  (class whichSelectorsReferToInstanceVariable: variableName) do: [:arg3 |  self checkClass: class selector: arg3 using: tmp1 ].  ^tmp1 answerrelease  self printStringcheckVariableName  (class whoDefinesInstanceVariable: newVariableName) ifNotNil: [ self refactoringError: ('<1p> defines an instance variable named <2s>' expandMacrosWith: class with: newVariableName) ].  (class whoDefinesClassVariable: newVariableName) ifNotNil: [ self refactoringError: ('<1p> defines a class variabled named <2s>' expandMacrosWith: class with: newVariableName) ].  (self parseTree allDefinedVariables includes: newVariableName) ifTrue: [ self refactoringError: ('<1s> is already a temporary variable name' expandMacrosWith: newVariableName) ]selectorCacheFor: arg1  ^self selectorCache at: arg1 name ifAbsentPut: [ self computeSelectorCacheFor: arg1 ]model  ^modeldeleteSelectorInSubclasses  class withAllSubclasses do: [:arg1 |  arg1 implements: selectors ]addMethod: arg1  self addClass: arg1 methodClass selector: arg1 selectorstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)includesCategory: arg1  ^(self classNamesFor: arg1) isNotEmptypackagesWithContributors  ^self classes flatCollect: #packages as: SetreplaceClassAccesses  | tmp1 |  tmp1 := self parseTreeRewriterClass variable: variableName getter: self getterMethod setter: self setterMethod receiver: self receiver.  self model convertClasses: self definingClass theMetaClass withAllSubclasses select: [:arg1 |  (arg1 whichSelectorsReferToClassVariable: variableName) reject: [:arg2 |  arg1 == self definingClass theMetaClass and: [ arg2 == self getterMethod or: [ arg2 == self setterMethod ] ] ] ] using: tmp1.  tmp1 := self parseTreeRewriterClass variable: variableName getter: 'class ' , self getterMethod setter: 'class ' , self setterMethod.  self model convertClasses: self definingClass theNonMetaClass withAllSubclasses select: [:arg1 |  arg1 whichSelectorsReferToClassVariable: variableName ] using: tmp1longDescription  self deprecated: 'Please use #rationale  instead' transformWith: '`@receiver longDescription' -> '`@receiver rationale'.  ^self rationalecopyFrom: arg1 to: arg2  arg1 instanceVariableNames do: [:arg3 |  arg2 addInstanceVariable: arg3 ].  arg1 isMeta ifFalse: [ arg1 allClassVariableNames do: [:arg3 |  arg2 addClassVariable: arg3 ].        arg1 sharedPoolNames do: [:arg3 |  arg2 addPoolDictionary: arg3 ] ].  arg1 selectors do: [:arg3 |  arg2 compile: (arg1 sourceCodeFor: arg3) classified: (arg1 protocolsFor: arg3) ]resultClass: arg1  result := arg1 newprintOn: arg1  arg1     nextPutAll: self displayClassName;     nextPutAll: ' classComment: ';     print: (self comment copyReplaceAll: '!' with: '!!');     nextPutAll: ' stamp: ';     print: self changeStamp;     nextPutAll: '!'associationAt: arg1 ifAbsent: arg2  | tmp1 tmp2 |  tmp1 := self systemDictionary associationAt: arg1 ifAbsent: [ ^arg2 value ].  tmp2 := tmp1 value isBehavior ifTrue: [ tmp1 value ] ifFalse: [ tmp1 value class ].  ^((self includesClass: tmp2) or: [ self includesClass: tmp2 class ]) ifTrue: [ tmp1 ] ifFalse: [ nil ]tearDown  self removeMockClass.  super tearDownaddSearchString: arg1  searchStrings ifNil: [ searchStrings := SortedCollection sortBlock: [:arg2 :arg3 |  (arg2 indexOf: $: ifAbsent: [ arg2 size ]) > (arg3 indexOf: $: ifAbsent: [ arg3 size ]) ] ].  (searchStrings includes: arg1) ifFalse: [ searchStrings add: arg1 ]toDoCollect  | tmp1 |  tmp1 := Array new: 10.  1 to: 10 do: [:arg1 |  tmp1 at: arg1 put: arg1 * arg1 ].  ^tmp1refactorings  | tmp1 |  tmp1 := self classObjectFor: className asSymbol.  ^tmp1 instanceVariableNames collect: [:arg1 |  RBCreateAccessorsForVariableRefactoring variable: arg1 class: tmp1 classVariable: false ]checkReferencesToSuperSendsToAnyOf: arg1  [ arg1 isEmpty ] whileFalse: [ self refactoringWarning: ('Although <1s> is equivalent to a superclass method,<n>it contains a super send so it might modify behavior.' expandMacrosWith: arg1 first).        arg1 remove: arg1 first ]initialize  super initialize.  matcher := RBParseTreeSearcher newtestPullUpWithMethodThatCannotBePushedDown  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #SomeClass) compile: 'yourself ^54' classified: #(#accessing).  self shouldFail: (RBPullUpMethodRefactoring model: model pullUp: #(#yourself) from: (model classNamed: #SomeClass))yourselfNotUsed  self     printString;     printString;     yourselfnewUnclassifiedMethod  setUp  super setUp.  model := RBClassModelFactory rbNamespace newrename: arg1 two: arg2  ^self printString , arg1 , arg2fail  ^self assert: falsebuildMethodSearch  self createMethodSearchWith: '`@methodName: `@args ^`@object `@methodName: `@args' selectors: #(#problemCount #isEmpty) inClass: RBTransformationRuleTestDatainitialize  super initialize.  classSelectors := IdentityDictionary new.  metaClassSelectors := IdentityDictionary newtestRefactoring  | tmp1 |  tmp1 := (RBPullUpVariableTransformation instanceVariable: 'result' class: #RBDummyLintRuleTest) asRefactoring.  [ tmp1 transform ] on: RBRefactoringError do: [:arg1 |  arg1 resume ].  self assert: ((tmp1 model classNamed: #RBDummyLintRuleTest) directlyDefinesInstanceVariable: 'result').  self deny: ((tmp1 model classNamed: #RBBasicDummyLintRuleTest) directlyDefinesInstanceVariable: 'result').  self deny: ((tmp1 model classNamed: #RBFooDummyLintRuleTest) directlyDefinesInstanceVariable: 'result')testBadName  self shouldFail: (RBChildrenToSiblingsRefactoring name: #'Obje ct' class: RBLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData with: RBCompositeLintRuleTestData))forClass: arg1 selectors: arg2  ^(RBSelectorEnvironment onMethods: arg2 forClass: arg1 in: self)     label: arg1 name , '>>' , (arg2 detect: [:arg3 |  true ] ifNone: [ '' ]);     yourselffullBlocks  ^[ thisContext ]class: arg1  className := arg1= arg1  ^self == arg1 or: [ self species == arg1 species ]resetResult  classNames  | tmp1 |  tmp1 := IdentitySet new: 4096.  self classesDo: [:arg1 |  tmp1 add: arg1 instanceSide name ].  ^tmp1rewriteRule10: arg1  rewriteRule10 := arg1poolDictionaryNames: arg1  poolDictionaryNames := (arg1 collect: [:arg2 |  arg2 asSymbol ]) asOrderedCollectiontestProtectInstanceVariable  | tmp1 tmp2 |  tmp1 := RBProtectInstanceVariableRefactoring variable: 'rewrite' , 'Rule1' class: RBSubclassOfClassToRename.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBSubclassOfClassToRename.  self assert: (tmp2 parseTreeFor: #calls1) equals: (self parseMethod: 'calls1								^rewriteRule1 := (rewriteRule1 := self calls)').  self assert: (tmp2 parseTreeFor: #calls) equals: (self parseMethod: 'calls								^rewriteRule1 := rewriteRule1 , rewriteRule1').  self deny: (tmp2 directlyDefinesMethod: ('rewrite' , 'Rule1') asSymbol).  self deny: (tmp2 directlyDefinesMethod: ('rewrite' , 'Rule1:') asSymbol)testMetaclassFailure  self shouldFail: (RBProtectVariableTransformation classVariable: #RecursiveSelfRule class: RBTransformationRuleTestData class) asRefactoringclass: arg1 protocols: arg2  class := arg1.  protocols := arg2preconditionEmptyOrHasNoSubclasses: arg1  ^(RBCondition hasSubclasses: arg1 excluding: classNames) not | ((RBCondition isEmptyClass: arg1) & ((RBCondition withBlock: [ arg1 superclass notNil ])                 errorMacro: 'Cannot remove top level class<n>when it has subclasses';                 yourself))testAllSearches  classSearches keysAndValuesDo: [:arg1 :arg2 |  arg1 selectors do: [:arg3 |  currentSelector := arg3.              arg2 do: [:arg4 |  arg4 executeTree: (arg1 parseTreeFor: arg3) initialAnswer: arg4 answer ] ] ].  classSearches do: [:arg2 |  arg2 do: [:arg4 |  self assertEmpty: arg4 answer ] ]findSelectedMessage  sourceParseTree := class parseTreeFor: sourceSelector.  sourceParseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ].  sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.  sourceMessage ifNil: [ self refactoringFailure: 'The selection doesn''t appear to be a message send' ].  sourceMessage isCascade ifTrue: [ sourceMessage := sourceMessage messages last ].  sourceMessage isMessage ifFalse: [ self refactoringFailure: 'The selection doesn''t appear to be a message send' ]setUp  super setUp.  classSearches := Dictionary new.  self     buildMethodSearch;     buildSimpleVariableSearch;     buildSimpleLiteralSearch;     buildMessageSearch;     buildStatementSearch;     buildArgumentSearch;     buildMethodTitleSearch;     buildMethodArgumentSearchincludesClass: arg1  ^(super includesClass: arg1) and: [ environmentDictionaries anySatisfy: [:arg2 |  arg2 includesClass: arg1 ] ]hasSelfReferences  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: 'self' do: [:arg1 :arg2 |  true ].  self hasOnlySelfReturns ifTrue: [ tmp1 matches: '^self' do: [:arg1 :arg2 |  arg2 ] ].  ^tmp1 executeTree: parseTree initialAnswer: falsereplaceArgumentsByPattern: arg1  | tmp1 |  tmp1 := arg1 copyWithRegex: 'tempMatch*' matchesReplacedWith: '`@tempMatch'.  tmp1 := tmp1 copyWithRegex: 'argMatch*' matchesReplacedWith: '`@argMatch'.  ^tmp1instanceVariableSelectorsFor: arg1  | tmp1 |  tmp1 := Set new.  #(#instanceVariables #instanceVariableReaders #instanceVariableWriters) with: #(#whichSelectorsAccess: #whichSelectorsRead: #whichSelectorsStoreInto:) do: [:arg2 :arg3 |  | tmp2 |        tmp2 := Set new.        (self perform: arg2) keysDo: [:arg4 |  | tmp3 |              tmp3 := self classForName: arg4.              (tmp3 notNil and: [ arg1 includesBehavior: tmp3 ]) ifTrue: [ tmp2 addAll: ((self perform: arg2) at: arg4) ] ].        tmp2 do: [:arg4 |  tmp1 addAll: (arg1 perform: arg3 with: arg4) ] ].  ^tmp1directlyDefinesPoolDictionary: arg1  self subclassResponsibilityprintType: arg1 for: arg2 on: arg3  | tmp1 tmp2 |  tmp2 := #().  tmp1 := self collectionNameFor: arg2.  (arg1 includesClass: (model classFor: Collection)) ifTrue: [ tmp2 := self guessTypesFor: tmp1 ].  tmp2 ifNotEmpty: [ arg3 nextPut: $( ].  arg1 printOn: arg3.  tmp2 ifNotEmpty: [ arg3 nextPutAll: ' of: '.        tmp2 size > 1 ifTrue: [ arg3 nextPut: $( ].        self printTypeFor: tmp1 on: arg3.        tmp2 size > 1 ifTrue: [ arg3 nextPut: $) ] ].  tmp2 ifNotEmpty: [ arg3 nextPut: $) ]testCheckValidMethodName  self assert: (RBCondition checkMethodName: 'foo').  self assert: (RBCondition checkMethodName: #foo).  self assert: (RBCondition checkMethodName: #+)refactoringFailure: arg1 with: arg2  ^RBRefactoringFailure signal: arg1 with: arg2inlineFoo: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 value: self.  tmp2 := tmp1 + tmp1.  tmp3 := tmp2 + tmp1.  ^tmp3perform: arg1 do: arg2  | tmp1 |  ^SystemAnnouncer uniqueInstance suspendAllWhile: [ tmp1 := arg1 execute.        arg2 ensure: [ tmp1 execute ] ]packageAt: arg1 ifAbsent: arg2  | tmp1 |  tmp1 := self packageOrganizer packageNamed: arg1 ifAbsent: arg2.  ^(self includesCategory: arg1) ifTrue: [ tmp1 ] ifFalse: arg2sendsDifferentSuper  super printStringtransform  self     extractMethod;     moveMethod;     inlineForwarderasUndoOperation  | tmp1 |  tmp1 := changeFactory compositeRefactoryChange.  self changeClass withAllSubclasses do: [:arg1 |  tmp1 defineClass: arg1 oldDefinition.        arg1 class instVarNames do: [:arg2 |  tmp1 addInstanceVariable: arg2 to: arg1 class ].        arg1 selectors do: [:arg3 |  tmp1 compile: (arg1 sourceCodeAt: arg3) in: arg1 ].        arg1 class selectors do: [:arg3 |  tmp1 compile: (arg1 class sourceCodeAt: arg3) in: arg1 class ] ].  ^tmp1copyOldValuesToNewVariable  | tmp1 tmp2 |  tmp2 := self changeClass allInstVarNames indexOf: oldName asString.  tmp1 := self changeClass allInstVarNames indexOf: newName asString.  self changeClass withAllSubclasses do: [:arg1 |  arg1 allInstances do: [:arg2 |  arg2 instVarAt: tmp1 put: (arg2 instVarAt: tmp2) ] ]selectionIntervalFor: arg1  | tmp1 |  tmp1 := super selectionIntervalFor: arg1.  ^tmp1 ifNotNil: [ tmp1 ] ifNil: [ environment selectionIntervalFor: arg1 ]directlyDefinesClassVariable: arg1  ^self classVariableNames includes: arg1 asSymbolprimitiveExecute  definedClass := self definitionClass compiler     source: self definition;     requestor: self controller;     logged: true;     evaluateremoveClass: arg1  arg1 isMeta ifTrue: [ metaClassSelectors removeKey: arg1 soleInstance name ifAbsent: [  ] ] ifFalse: [ classSelectors removeKey: arg1 name ifAbsent: [  ] ]testRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddVariableAccessorTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  tmp2 := tmp1 model classNamed: #RBDummyLintRuleTest.  self denyEmpty: tmp1 changes changes.  self assert: (tmp2 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^foo1').  self assert: (tmp2 parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject foo1 := anObject')testRefactoring  | tmp1 |  model := RBNamespace2 new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''fdsa'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  tmp1 := (RBAddVariableTransformation model: model instanceVariable: 'asdf' class: (model classNamed: #FOOBAR)) asRefactoring transform.  self assert: ((tmp1 model classNamed: #FOOBAR) directlyDefinesInstanceVariable: 'asdf')directlyDefinesClassVariable: arg1  self subclassResponsibilitydefinesClass: arg1  ^(super definesClass: arg1) and: [ self packages anySatisfy: [:arg2 |  arg2 includesClass: arg1 ] ]accessorForVariable: arg1  | tmp1 |  tmp1 := RBCreateAccessorsForVariableRefactoring model: self model variable: arg1 class: self theClass classVariable: false.  tmp1 createGetterAccessor.  ^tmp1 getterMethodsafeVariableNameFor: arg1 temporaries: arg2 basedOn: arg3  | tmp1 tmp2 tmp3 |  tmp3 := tmp1 := arg3.  tmp2 := 0.  [ (arg2 includes: tmp3) or: [ arg1 definesInstanceVariable: tmp3 ] ] whileTrue: [ tmp2 := tmp2 + 1.        tmp3 := tmp1 , tmp2 printString ].  ^tmp3literals  literalSemaphore ifNil: [ literals ifNil: [ self computeLiterals.              literalSemaphore wait ] ] ifNotNil: [ literalSemaphore wait ].  ^literalsrun  environment classesAndTraits do: [:arg1 |  self checkClass: arg1.        self checkMethodsForClass: arg1.        self checkClass: arg1 classSide.        self checkMethodsForClass: arg1 classSide ] displayingProgress: [:arg1 |  'Running critics on: ' , arg1 name ].  environment packages do: [:arg2 |  self checkPackage: arg2 ] displayingProgress: [:arg2 |  'Running critics on: ' , arg2 name ]hash  ^self parseTree hashtestInstanceVariable  | tmp1 |  (RBRemoveDirectAccessToVariableTransformation model: model instanceVariable: 'instVarName2' class: #Foo) asRefactoring transform.  tmp1 := model classNamed: #Foo.  self assert: (tmp1 parseTreeFor: #foo) equals: (self parseMethod: 'foo ^ self instVarName2: 3')storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' rename: '.  deprecatedClass storeOn: arg1.  arg1     nextPutAll: ' to: #';     nextPutAll: newName;     nextPut: $)theClass  ^(self classObjectFor: className) instanceSideparseTreeSearcher  ^self parseTreeSearcherClass newtestReplaceMethod  | tmp1 tmp2 |  tmp2 := (model allReferencesTo: #newResultClass:) size.  model allReferencesTo: #anInstVar: do: [:arg1 |  tmp2 := tmp2 + 1 ].  tmp1 := RBReplaceMethodRefactoring model: model replaceMethod: #anInstVar: in: RBBasicLintRuleTestData to: #newResultClass: permutation: (1 to: 1).  self proceedThroughWarning: [ tmp1 primitiveExecute ].  model allReferencesTo: #newResultClass: do: [:arg1 |  tmp2 := tmp2 - 1 ].  self assert: tmp2 equals: (model allReferencesTo: #anInstVar:) sizetestModelExistingSelector  | tmp1 |  tmp1 := RBAddMethodRefactoring model: model addMethod: 'classVarName1 ^super printString' toClass: (model classNamed: #Bar) inProtocols: #(#accessing).  self shouldFail: tmp1printOn: arg1  arg1     print: left;     nextPutAll: ' & ';     print: rightinlineMethodTestData  ^'| m |(m := RBNamespace 			onEnvironment: ((RBClassEnvironment onEnvironment: RBBrowserEnvironment new) 					classes: (#(#RBRenameClassVariableChange #RBVariableCompositeRefactoryChange #RBRenameInstanceVariableChange #RBCompositeRefactoryChange #RBRenameVariableChange #RBRefactoryChange) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#() inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''Object subclass: #RBRefactoryChange	instanceVariableNames: ''''name ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBRefactoryChange subclass: #RBCompositeRefactoryChange	instanceVariableNames: ''''changes ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBCompositeRefactoryChange subclass: #RBVariableCompositeRefactoryChange	instanceVariableNames: ''''className isMeta ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBVariableCompositeRefactoryChange subclass: #RBRenameVariableChange	instanceVariableNames: ''''oldName newName ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBRenameVariableChange subclass: #RBRenameClassVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBRenameVariableChange subclass: #RBRenameInstanceVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''') 	do: [:each | m defineClass: each].#(#(#RBRenameClassVariableChange #(#(''removeOldVariable	(RBRemoveClassVariableChange remove: oldName from: self changeClass) execute'' #private) #(''addNewVariable	(RBAddClassVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| oldValue |	oldValue := self changeClass classPool at: oldName ifAbsent: [].	self changeClass at: newName asSymbol put: oldValue'' #private))) #(#RBVariableCompositeRefactoryChange #(#(''displayClassName	^isMeta 		ifTrue: [self changeClassName , '''' class'''']		ifFalse: [self changeClassName asString]'' #printing) #(''isMeta	^isMeta'' #private) #(''changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]'' #accessing) #(''hash	^self changeClassName hash'' #comparing) #(''changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]'' #accessing) #(''changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]'' #accessing) #(''printOn: aStream	aStream nextPutAll: self displayString'' #printing) #(''changeClassName	^className'' #accessing) #(''= aRefactoryClassChange 	self class = aRefactoryClassChange class ifFalse: [^false].	^className = aRefactoryClassChange changeClassName 		and: [isMeta = aRefactoryClassChange isMeta]'' #comparing))) #(#RBRenameInstanceVariableChange #(#(''removeOldVariable	(RBRemoveInstanceVariableChange remove: oldName from: self changeClass) 		execute'' #private) #(''addNewVariable	(RBAddInstanceVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| newIndex oldIndex |	oldIndex := self changeClass allInstVarNames indexOf: oldName asString.	newIndex := self changeClass allInstVarNames indexOf: newName asString.	self changeClass withAllSubclasses do: 			[:each | 			each allInstances 				do: [:inst | each instVarAt: newIndex put: (each instVarAt: oldIndex)]]'' #private))) #(#RBCompositeRefactoryChange #(#(''compile: source in: class 	^self addChange: (RBAddMethodChange compile: source in: class)'' #''refactory-changes'') #(''addClassVariable: variableName to: aClass 	^self addChange: (RBAddClassVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''addChangeFirst: aRefactoryChange 	changes addFirst: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''removeChange: aChange 	changes remove: aChange ifAbsent: []'' #''private-inspector accessing'') #(''addPool: aPoolVariable to: aClass 	^self addChange: (RBAddPoolVariableChange add: aPoolVariable to: aClass)'' #''refactory-changes'') #(''initialize	super initialize.	changes := OrderedCollection new'' #''initialize-release'') #(''defineClass: aString 	^self addChange: (RBAddClassChange definition: aString)'' #''refactory-changes'') #(''changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RBRemoveInstanceVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''printOn: aStream 	aStream nextPutAll: name'' #printing) #(''inspect	RefactoryBuilderInspector openOn: self'' #''user interface'') #(''flattenOnto: aCollection 	changes do: [:each | each flattenOnto: aCollection]'' #private) #(''hash	^changes size'' #comparing) #(''= aRefactoryBuilder 	self class = aRefactoryBuilder class ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true'' #comparing) #(''renameClass: class to: newName 	^self addChange: (RenameClassChange rename: class name to: newName)'' #''refactory-changes'') #(''renameChangesForClass: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForClass: aClassName to: newClassName]);		yourself'' #accessing) #(''postCopy	super postCopy.	changes := changes collect: [:each | each copy]'' #copying) #(''changes: aCollection 	changes := aCollection'' #''private-inspector accessing'') #(''addInstanceVariable: variableName to: aClass 	^self addChange: (RBAddInstanceVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''compile: source in: class classified: aProtocol 	^self addChange: (RBAddMethodChange 				compile: source				in: class				classified: aProtocol)'' #''refactory-changes'') #(''changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeClassVariable: variableName from: aClass 	^self 		addChange: (RBRemoveClassVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''executeNotifying: aBlock 	| undos undo |	undos := changes collect: [:each | each executeNotifying: aBlock].	undo := self copy.	undo changes: undos reverse.	^undo'' #private) #(''changes	^changes'' #''private-inspector accessing'') #(''removeMethod: aSelector from: aClass 	^self addChange: (RBRemoveMethodChange remove: aSelector from: aClass)'' #''refactory-changes'') #(''removeClass: aClass 	^self addChange: (RBRemoveClassChange removeClassName: aClass)'' #''refactory-changes'') #(''addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]'' #accessing) #(''displayString	^super displayString asText allBold'' #printing) #(''problemCount	^self changesSize'' #accessing))) #(#RBRenameVariableChange #(#(''oldName: aString	oldName := aString'' #private) #(''executeNotifying: aBlock 	| undo |	undo := super executeNotifying: aBlock.	undo		oldName: newName;		newName: oldName.	^undo'' #private) #(''newName: aString 	newName := aString'' #private) #(''changeString	^''''Rename '''' , oldName , '''' to '''' , newName'' #printing))) #(#RBRefactoryChange #(#(''flattenedChanges	| changes |	changes := OrderedCollection new.	self flattenOnto: changes.	^changes'' #private) #(''name: aString	name := aString'' #''initialize-release'') #(''initialize'' #''initialize-release'') #(''changeForMetaclass: aSymbol selector: aSelector 	^nil'' #accessing) #(''changeString	^self class name'' #printing) #(''changeForClass: aRBClass selector: aSelector 	^nil'' #accessing) #(''executeWithMessage: aString 	| tally controller m done |	m := 0 asValue.	done := 0.	tally := self changesSize.	controller := aString isNil 				ifTrue: [nil]				ifFalse: [ProgressWidgetView progressOpenOn: m label: aString].	m value: 0.	^	[self executeNotifying: 			[done := done + 1.			m value: done asFloat / tally]] 			ensure: [controller notNil ifTrue: [controller closeAndUnschedule]]'' #''performing-changes'') #(''executeNotifying: aBlock 	self subclassResponsibility'' #private) #(''changes	^Array with: self'' #accessing) #(''execute	^self executeNotifying: []'' #''performing-changes'') #(''inspect	^((RBCompositeRefactoryChange new)		changes: (Array with: self);		yourself) inspect'' #''user interface'') #(''flattenOnto: aCollection 	aCollection add: self'' #private) #(''name	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #accessing) #(''changesSize	^1'' #accessing) #(''displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #printing) #(''renameChangesForClass: aClassName to: newClassName 	"We are in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."	self subclassResponsibility'' #accessing)))) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'privateTransform  | tmp1 tmp2 tmp3 |  tmp1 := self definingMethod.  tmp3 := tmp1 variableWith: variableName.  self checkExistingVariable: tmp3.  tmp2 := tmp3 whoDefines: variableName.  self checkNewVariable: tmp2.  (self parseTreeRewriterClass rename: variableName to: newVariableName) executeTree: tmp2.  class compileTree: tmp1allNonMetaClasses  | tmp1 |  tmp1 := OrderedCollection new: 4096.  self classesDo: [:arg1 |  arg1 isMeta ifFalse: [ tmp1 add: arg1 ] ].  ^tmp1 asArrayremoveEmptyIfTrues  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1     replace: '``@boolean ifTrue: [] ifFalse: [| `@temps | ``@.Stmts]' with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]';     replace: '``@boolean ifFalse: [] ifTrue: [| `@temps | ``@.Stmts]' with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';     replace: '``@boolean ifTrue: [| `@temps | ``@.Stmts] ifFalse: []' with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';     replace: '``@boolean ifFalse: [| `@temps | ``@.Stmts] ifTrue: []' with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]'.  (tmp1 executeTree: sourceParseTree) ifTrue: [ sourceParseTree := tmp1 tree ]modelClass  ^classcheckTemporaryVariableNames  | tmp1 |  tmp1 := parseTree allDefinedVariables.  selfVariableName ifNotNil: [ tmp1 add: selfVariableName ].  tmp1 do: [:arg1 |  moveToClasses do: [:arg2 |  (self canReferenceVariable: arg1 in: arg2) ifTrue: [ self refactoringError: ('<1p> already defines a variable called <2s>' expandMacrosWith: arg2 with: arg1) ] ] ]postCopy  super postCopy.  packages := packages copyincludesCategory: arg1  ^(self classNamesFor: arg1) isNotEmptytestRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddPragmaTransformation pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #methodBefore inClass: #RBAddPragmaTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBAddPragmaTransformationTest.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodychangeString  ^'Remove ' , self displayClassNametestRemoveEmptySuperclass  | tmp1 |  tmp1 := RBRemoveClassRefactoring classNames: (Array with: ('RBFoo' , 'LintRuleTestData1') asSymbol).  self executeRefactoring: tmp1.  self assert: (tmp1 model classNamed: ('RBFoo' , 'LintRuleTestData1') asSymbol) isNil.  self assert: (tmp1 model classNamed: #RBTransformationRuleTestData1) superclass equals: (tmp1 model classNamed: #RBLintRuleTestData)hasVariablesToAbstract  ^instVarReaders notEmpty or: [ instVarWriters notEmpty or: [ classVarReaders notEmpty or: [ classVarWriters notEmpty ] ] ]storeOn: arg1  arg1     nextPutAll: self class name;     nextPutAll: ' new'testNowhereToMove  | tmp1 |  tmp1 := RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #noMoveDefinition inClass: #RBDummyRefactoryTestDataApp.  self assert: tmp1 model changes changes size equals: 0.  self shouldFail: (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #noMoveDefinition inClass: #RBDummyRefactoryTestDataApp) asRefactoringcomputeSubclassSupersOf: arg1  | tmp1 |  tmp1 := Set new.  arg1 subclasses do: [:arg2 |  arg2 selectors do: [:arg3 |  tmp1 addAll: (arg2 parseTreeFor: arg3) superMessages ] ].  ^tmp1preconditionHasNoUsers: arg1  ^(RBCondition withBlock: [ arg1 realClass users isEmpty ])     errorMacro: arg1 name , ' Trait is used.<n>Browse classes using it?';     errorBlock: [ self openBrowserOn: (self environmentWithUsersOf: arg1) ];     yourselftestMethodDoesNotExist  self shouldFail: (RBRemoveTemporaryVariableTransformation variable: 'temp' inMethod: #foofoo inClass: #RBRemoveTemporaryVariableTransformationTest) asRefactoringsmallLintCritics  ^self packagesmsg2  ^Var1addNewVariable  self flag: #todo.  (RBAddInstanceVariableChange add: newName to: self changeClass) executeinlineMessagesInClass: arg1 andSelector: arg2  | tmp1 tmp2 |  tmp2 := 4294967295.  [ tmp1 := self numberOfSelfSendsIn: (arg1 parseTreeFor: arg2).  tmp1 > 0 and: [ tmp2 > tmp1 ] ] whileTrue: [ | tmp3 |        tmp2 := tmp1.        tmp3 := self selfSendIn: (arg1 parseTreeFor: arg2).        self onError: [ self performComponentRefactoring: (RBInlineMethodRefactoring model: self model inline: tmp3 sourceInterval inMethod: arg2 forClass: arg1).              numberReplaced := numberReplaced + 1 ] do: [  ] ].  numberNotReplaced := numberNotReplaced + tmp1testNewHierarchyExistingName  | tmp1 |  model := RBClassModelFactory rbNamespace new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  model defineClass: 'FOOBAR subclass: #BARFOO 				instanceVariableNames: '''' 					classVariableNames: ''''				poolDictionaries: ''''				category: ''Refactory-Test data'''.  tmp1 := RBAddInstanceVariableRefactoring model: model variable: 'asdf' class: (model classNamed: #BARFOO).  self shouldFail: tmp1collectionProtocol  | tmp1 |  tmp1 := OrderedCollection new.  (1 to: 10) asOrderedCollection do: [:arg1 |  | tmp2 |        tmp2 := arg1 * 2.        tmp1 add: tmp2 ].  ^tmp1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' variable: '.  variableName storeOn: arg1.  arg1 nextPutAll: ' class: '.  class storeOn: arg1.  arg1 nextPutAll: ' classVariable: '.  isClassVariable storeOn: arg1.  arg1 nextPut: $)atIfAbsent  ^Smalltalk at: #MyTest ifAbsent: [ | tmp1 |        tmp1 := #().        Smalltalk at: #MyTest put: tmp1 ]compile: arg1 in: arg2 classified: arg3  | tmp1 |  tmp1 := changes compile: arg1 in: arg2 classified: arg3.  self flushCaches.  ^tmp1preconditions  class := self model classObjectFor: className.  ^(isClassVariable ifTrue: [ (RBCondition isMetaclass: class) not & (RBCondition directlyDefinesClassVariable: variableName asSymbol in: class) & ((RBCondition withBlock: [ (#(#Object #Behavior #ClassDescription #Class) includes: class name) not ]) errorMacro: 'This refactoring does not work for Object, Behavior, ClassDescription, or Class') ] ifFalse: [ RBCondition directlyDefinesInstanceVariable: variableName in: class ]) & (RBCondition canUnderstand: self getterMethod in: self definingClass) & (RBCondition canUnderstand: self setterMethod in: self definingClass)variable  ^variableprivateTransform  self definingClass comment: commenttestAbstractWithDefaultNamesUsed  | tmp1 tmp2 |  tmp2 := model classNamed: #Foo.  tmp1 := RBAbstractInstanceVariableRefactoring model: model variable: 'instVarName1' class: tmp2.  self executeRefactoring: tmp1.  self assert: (tmp2 parseTreeFor: #bar) equals: (self parseMethod: 'bar						"Add one to instVarName1"						self instVarName11: self instVarName11 + 1').  self assert: (tmp2 parseTreeFor: #instVarName11:) equals: (self parseMethod: 'instVarName11: anObject						instVarName1 := anObject').  self assert: (tmp2 parseTreeFor: #instVarName11) equals: (self parseMethod: 'instVarName11						^instVarName1').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo						self instVarName11: self instVarName11 + instVarName2 + ClassVarName1')convertAllReferencesTo: arg1 using: arg2  self model allReferencesTo: arg1 do: [:arg3 |  self convertMethod: arg3 selector for: arg3 modelClass using: arg2 ]selector: arg1 in: arg2 classified: arg3  ^changes selector: arg1 in: arg2 classified: arg3storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' inlineParameter: ''';     nextPutAll: argument;     nextPutAll: ''' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' selector: #';     nextPutAll: oldSelector;     nextPut: $)changeString  ^'Rename ' , oldName , ' to ' , newNamepackageAt: arg1  ^self packageAt: arg1 ifAbsent: [ NotFound signalFor: arg1 in: self ]preconditions  ^(RBCondition isMetaclass: class) notchangeForMetaclass: arg1 selector: arg2  ^nilwhoDefinesInstanceVariable: arg1  | tmp1 |  (self directlyDefinesInstanceVariable: arg1) ifTrue: [ ^self ].  tmp1 := self superclass.  ^tmp1 ifNil: [ nil ] ifNotNil: [ tmp1 whoDefinesInstanceVariable: arg1 ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' protocol ''';     nextPutAll: protocol;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)isResumable  ^truesoleInstance  ^self instanceSidetestTransform  | tmp1 tmp2 |  tmp1 := (RBAddSubtreeTransformation interval: (0 to: 1) with: 'self printString' from: #one in: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 directlyDefinesMethod: #one).  self assert: (tmp2 parseTreeFor: #one) body statements size equals: 2oldVersionTextToDisplay  ^String streamContents: [:arg1 |  self changes do: [:arg2 |  arg1                 << arg2 oldVersionTextToDisplay;                 cr ] ]changes  ^self model changestestInlineBlockFailure  self shouldFail: (RBInlineParameterRefactoring inlineParameter: 'aBlock' in: RBRefactoryTestDataApp selector: ('inline' , 'Foo:') asSymbol)testIncludesClass  self assert: (modelFactory rbNamespace new includesClassNamed: #Object).  self deny: (modelFactory rbNamespace new includesClassNamed: #Object1).  self deny: ((modelFactory rbNamespace onEnvironment: (RBClassEnvironment onEnvironment: RBBrowserEnvironment new classes: (Array with: Object))) includesClassNamed: #OrderedCollection)initialize  super initialize.  onSystemDictionary := Smalltalk globals.  changeFactory := RBRefactoryChangeManager changeFactorytestModelAlreadyExistingName  | tmp1 |  tmp1 := RBAddInstanceVariableRefactoring model: model variable: 'instVarName1' class: (model classNamed: #Bar).  self shouldFail: tmp1preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition definesSelector: selector in: target) not & (RBCondition withBlock: [ self checkInstVars.              true ])sizeCheck  self isEmpty ifFalse: [ self do: [:arg1 |  self traceCr: arg1 ] ]addProtocolNamed: arg1  model addProtocolNamed: arg1 in: selftestRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddAccessorsForClassTransformation className: #RBVariableTransformation) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 4.  tmp2 := tmp1 model classNamed: #RBVariableTransformation.  self assert: (tmp2 parseTreeFor: #variableName) equals: (self parseMethod: 'variableName ^variableName').  self assert: (tmp2 parseTreeFor: #variableName:) equals: (self parseMethod: 'variableName: anObject variableName := anObject')getterMethodFor: arg1  | tmp1 tmp2 |  tmp1 := self parseTreeSearcherClass getterMethod: arg1.  tmp2 := (self definesInstanceVariable: arg1) ifTrue: [ self whichSelectorsReferToInstanceVariable: arg1 ] ifFalse: [ self whichSelectorsReferToClassVariable: arg1 ].  tmp2 := tmp2 select: [:arg2 |  arg2 numArgs == 0 ].  ^tmp2 detect: [:arg2 |  (self checkSelector: arg2 using: tmp1) notNil and: [ (self subclassRedefines: arg2) not ] ] ifNone: [ nil ]getNewMethodName  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self removeArgument.  tmp2 := parseTree argumentNames asOrderedCollection.  self needsToReplaceSelfReferences ifTrue: [ tmp2 add: selfVariableName ].  tmp4 := RBMethodName selector: (self uniqueMethodNameFor: tmp2 size) arguments: tmp2.  [ tmp5 := self requestMethodNameFor: tmp4.  tmp5 ifNil: [ self refactoringFailure: 'Did not move method' ].  tmp5 isValid ifTrue: [ tmp1 := tmp5 selector ] ifFalse: [ self refactoringWarning: 'Invalid method name' ].  tmp2 := tmp5 arguments.  (self checkMethodName: tmp1 in: class) ifFalse: [ self refactoringWarning: tmp1 , ' is not a valid selector name.'.        tmp1 := nil ].  tmp3 := moveToClasses detect: [:arg1 |  arg1 hierarchyDefinesMethod: tmp1 ] ifNone: [ nil ].  tmp3 ifNotNil: [ self refactoringWarning: ('<1s> is already defined by <2p> or a super/subclass<n>Try another?' expandMacrosWith: tmp1 with: tmp3).        tmp1 := nil ].  tmp1 isNil ] whileTrue: [  ].  parseTree renameSelector: tmp1 andArguments: (tmp2 collect: [:arg1 |  RBVariableNode named: arg1 ]) asArrayanInstVar: arg1  anInstVar := arg1asOrderedCollectionNotNeeded  self foo addAll: (1 to: 10) asOrderedCollectioncheckPackage: arg1  rules do: [:arg2 |  arg2 checkPackage: arg1 ]assert: arg1 equals: arg2  ^self assert: arg1 = arg2 description: [ self comparingStringBetween: arg1 and: arg2 ]testAddTraitPattern  self exampleTraits do: [:arg1 |  | tmp1 |        tmp1 := changes defineClass: arg1 definition.        self assert: (tmp1 isKindOf: RBAddTraitChange).        self assert: tmp1 changeClassName equals: arg1 name.        self assert: tmp1 category equals: arg1 category.        self universalTestFor: tmp1 ]constructAssignmentFrom: arg1  | tmp1 |  tmp1 := RBVariableNode named: newVariableName.  ^RBAssignmentNode variable: tmp1 value: arg1parseTreeSearcher  ^self parseTreeSearcherClass newclassesDo: arg1  | tmp1 tmp2 |  tmp1 := IdentitySet new.  tmp2 := [:arg2 |  (tmp1 includes: arg2) ifFalse: [ (environment includesClass: arg2) ifTrue: [ arg1 value: arg2 ].        (environment includesClass: arg2 classSide) ifTrue: [ arg1 value: arg2 classSide ].        tmp1 add: arg2 ] ].  packages do: [:arg3 |  arg3 classes do: tmp2.        arg3 extendedClasses do: tmp2 ]check  self subclassResponsibilitywhatToDisplayIn: arg1  ^self changes changes flatCollect: [:arg2 |  arg2 whatToDisplayIn: arg1 ]buildTransformations  transformations := OrderedCollection new.  self     createNewClass;     createReference;     abstractVariableReferences.  ^transformationsprivatePoolDictionaryNames  (self isDefined and: [ poolDictionaryNames isNil ]) ifTrue: [ self poolDictionaryNames: (self realClass sharedPools collect: [:arg1 |  self realClass environment keyAtValue: arg1 ]) ].  ^poolDictionaryNamescheckExistingVariable: arg1  (arg1 isNil or: [ arg1 isVariable not ]) ifTrue: [ self refactoringError: ('Temporary variable named {1} does not exist.' format: {variableName asString}) ].  arg1 name = variableName ifFalse: [ self refactoringError: 'Selected interval should include variable declaration' ]checkPreconditions  | tmp1 tmp2 |  tmp1 := self preconditions.  tmp1 check ifFalse: [ tmp2 := tmp1 errorBlock.        tmp2 ifNotNil: [ self refactoringError: tmp1 errorString with: tmp2 ] ifNil: [ self refactoringError: tmp1 errorString ] ]proceedThroughWarning: arg1  arg1 on: RBRefactoringError do: [:arg2 |  arg2 resume ]privateTransform  self definingClass removeProtocolNamed: protocolcheckSuperSendsFromSiblings  | tmp1 |  tmp1 := targetSuperclass subclasses reject: [:arg1 |  arg1 = class ].  tmp1 do: [:arg2 |  self checkSiblingSuperSendsFrom: arg2 ]checkIsAbstractMethod  method isAbstract ifTrue: [ self refactoringError: ('<1p> method is abstract' expandMacrosWith: sourceSelector) ]addTemporary: arg1 assignedTo: arg2  | tmp1 |  tmp1 := self renameConflictingTemporary: arg1 name.  inlineParseTree body     addTemporaryNamed: tmp1;     addNodeFirst: (RBAssignmentNode variable: (RBVariableNode named: tmp1) value: arg2)preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ self definingMethod lastIsReturn not ] errorString: ('Method named <1s> already has a return statement' expandMacrosWith: selector)) & (RBCondition withBlock: [ | tmp1 |              tmp1 := self parserClass parseExpression: returnValue.              tmp1 allVariables allSatisfy: [:arg1 |  (self definingMethod hasArgumentNamed: arg1 name) or: [ self definingMethod hasTemporaryNamed: arg1 name ] ] ] errorString: ('Some variables in this return statement are not defined in method named <1s>.' expandMacrosWith: selector))propagateTransformation  self renameReferenceslongMethods  self printString.  self printString.  self printString.  self printString.  self printString.  self printString.  self printString.  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ]testRemoveClassWithSubclasses  self shouldFail: (RBRemoveClassTransformation className: #RBFooLintRuleTestData1) asRefactoringfindDestinationClass  | tmp1 |  tmp1 := class withAllSubclasses reject: [:arg1 |  (arg1 whichSelectorsReferToClassVariable: variableName) isEmpty and: [ (arg1 classSide whichSelectorsReferToClassVariable: variableName) isEmpty ] ].  destinationClass := tmp1 ifEmpty: [ nil ] ifNotEmpty: [ tmp1 asOrderedCollection first ].  tmp1 do: [:arg1 |  (destinationClass includesClass: arg1) ifTrue: [ destinationClass := arg1 ] ifFalse: [ (arg1 includesClass: destinationClass) ifFalse: [ self signalMultipleReferenceError ] ] ].  destinationClass = class ifTrue: [ self signalStillReferencedError ].  ^destinationClasssystemDictionaryClassesDo: arg1  self systemDictionary allClassesDo: [:arg2 |  arg1           value: arg2;           value: arg2 classSide ]transform  | tmp1 tmp2 |  parseTree := class parseTreeFor: selector.  tmp2 := self whichVariableNode: parseTree inInterval: interval name: oldName.  (tmp2 isNil or: [ tmp2 isVariable not ]) ifTrue: [ self refactoringFailure: oldName asString , ' isn''t a valid variable' ].  tmp2 name = oldName ifFalse: [ self refactoringFailure: 'Invalid selection' ].  tmp1 := tmp2 whoDefines: oldName.  tmp1 ifNil: [ self refactoringFailure: oldName asString , ' isn''t defined by the method' ].  self renameNode: tmp1.  class compileTree: parseTreetestExistingInstanceVariableAccessors  | tmp1 |  tmp1 := RBCreateAccessorsForVariableRefactoring variable: 'name' class: RBLintRuleTestData classVariable: false.  self executeRefactoring: tmp1.  self assertEmpty: tmp1 changes changes.  self assert: tmp1 setterMethod identicalTo: #name:.  self assert: tmp1 getterMethod identicalTo: #namecheckClassVarsFor: arg1  class instanceSide classVariableNames do: [:arg2 |  ((class whichSelectorsReferToClassVariable: arg2) includes: arg1) ifTrue: [ self refactoringError: ('<1p> refers to <2s> which is defined in <3p>' expandMacrosWith: arg1 with: arg2 with: class) ] ]testInlineMethodForSuperSend  | tmp1 |  model := Smalltalk compiler evaluate: self inlineMethodTestData.  (model classNamed: #RBRenameVariableChange) removeMethod: #executeNotifying:.  tmp1 := RBInlineMethodRefactoring model: model inline: (102 to: 131) inMethod: #executeNotifying: forClass: (model classNamed: #RBRenameInstanceVariableChange).  self executeRefactoring: tmp1.  self assert: ((model classNamed: #RBRenameInstanceVariableChange) parseTreeFor: #executeNotifying:) equals: (self parseMethod: 'executeNotifying: aBlock 									| undo undos undo1 |									self addNewVariable.									self copyOldValuesToNewVariable.									undos := changes collect: [:each | each executeNotifying: aBlock].									undo1 := self copy.									undo1 changes: undos reverse.									undo := undo1.									self removeOldVariable.									^undo')withClassesFixedForNautilus  classes ifEmpty: [ metaClasses do: [:arg1 |  classes add: arg1 ] ]transform  class removeClassVariable: variableNamerewriteInlinedTree  sourceMessage parent isReturn ifTrue: [ (sourceParseTree isLast: sourceMessage parent) ifFalse: [ self addSelfReturn ] ] ifFalse: [ self           writeGuardClauses;           normalizeIfTrues;           normalizeReturns;           addSelfReturn ]removeDuplicatesOf: arg1  | tmp1 |  tmp1 := targetSuperclass parseTreeFor: arg1.  targetSuperclass allSubclasses do: [:arg2 |  ((arg2 directlyDefinesMethod: arg1) and: [ (tmp1 equalTo: (arg2 parseTreeFor: arg1) exceptForVariables: #()) and: [ (arg2 superclass whoDefinesMethod: arg1) == targetSuperclass ] ]) ifTrue: [ removeDuplicates ifFalse: [ removeDuplicates := self refactoringConfirmWarning: 'Do you want to remove duplicate subclass methods?' ].              removeDuplicates ifTrue: [ arg2 removeMethod: arg1 ] ] ]superMessages  ^self parseTree superMessagestestRemoveClassVar  | tmp1 tmp2 |  tmp1 := RBRemoveClassVariableRefactoring variable: 'Foo1' class: RBLintRuleTestData.  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self assert: (tmp2 definesClassVariable: 'Foo1').  self executeRefactoring: tmp1.  self deny: (tmp2 definesClassVariable: 'Foo1')isComposite  ^falsepreconditions  ^subclasses inject: ((RBCondition isMetaclass: parent) errorMacro: 'Superclass must not be a metaclass') not & (RBCondition isValidClassName: className) & (RBCondition isGlobal: className in: self model) not into: [:arg1 :arg2 |  arg1 & ((RBCondition isMetaclass: arg2) errorMacro: 'Subclass must <1?not :>be a metaclass') not & (RBCondition isImmediateSubclass: arg2 of: parent) ]renameClassVariable: arg1 to: arg2 in: arg3 around: arg4  self deprecated: 'Use RBClass2 instead'testReferencesPrintOnAfterRemove  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := false.  tmp3 := modelFactory rbNamespace new.  (tmp3 classNamed: #Object) removeMethod: #printString.  (tmp3 classNamed: self class name) removeMethod: #testReferencesPrintOnAfterRemove.  tmp3 allReferencesTo: #printOn: do: [:arg1 |  tmp1 := tmp1 or: [ arg1 selector = #printString and: [ arg1 modelClass = (tmp3 classNamed: #Object) ] ].        tmp2 := tmp2 or: [ arg1 selector = #testReferencesPrintOnAfterRemove and: [ arg1 modelClass = (tmp3 classNamed: self class name) ] ] ].  self deny: tmp1.  self deny: tmp2| arg1  ^(self not & arg1 not) notnewOKButton  ^self newOKButtonFor: self getEnabled: #isOkEnableddemoRenameMethod: arg1 PermuteArgs: arg2  self do: arg1.  self do: arg2.  ^arg1 > arg2exampleTraits  < sampleInstance>  ^{TSortable .   TAssertable}result  ^resulttransform  self subclassResponsibilityincludesSelector: arg1 in: arg2  ^(environment includesSelector: arg1 in: arg2) and: [ self privateIncludesSelector: arg1 inClass: arg2 ]deprecatedClass: arg1  deprecatedClass := arg1preconditionsForInstanceVariable  ^(RBCondition definesInstanceVariable: variableName in: self definingClass) & (RBCondition accessesInstanceVariable: variableName in: self definingClass showIn: self)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' sendersOf: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1 nextPut: $)buildSelectorString: arg1  arg1 numArgs = 0 ifTrue: [ ^arg1 ].  ^self buildSelectorString: arg1 withPermuteMap: (1 to: arg1 numArgs)badMessage  self become: String newtestLintRuleTypes  | tmp1 tmp2 |  tmp1 := RBRefactoryTyper new.  tmp2 := tmp1 guessTypesFor: 'name' in: RBLintRuleTestData.  self assert: tmp2 size equals: 1.  self assert: (tmp2 includes: (tmp1 model classFor: String))testAddClassInteractively  | tmp1 |  tmp1 := changeFactory addClassDefinition: 'AbstractEnvironmentTestCase subclass: #' , self class name , '	instanceVariableNames: ''instVar''	classVariableNames: ''ClassVar''	poolDictionaries: ''PoolDict''	package: ''' , self class category , '''' for: self.  self assert: tmp1 controller equals: self.  self assert: tmp1 superclassName equals: self class superclass name.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 instanceVariableNames size equals: 1.  self assert: tmp1 instanceVariableNames first equals: 'instVar'.  self assert: tmp1 classVariableNames size equals: 1.  self assert: tmp1 classVariableNames first equals: 'ClassVar'.  self assert: tmp1 sharedPoolNames size equals: 1.  self assert: tmp1 sharedPoolNames first equals: 'PoolDict'.  self assert: tmp1 category equals: self class category.  self universalTestFor: tmp1preconditions  ^RBCondition canUnderstand: selector in: classpreconditions  | tmp1 |  tmp1 := self parserClass parseMethod: sourceCode onError: [:arg1 :arg2 |  ^RBCondition withBlock: [ self refactoringError: 'The content of this method cannot be parsed.' ] ].  tmp1 selector ifNil: [ self refactoringError: 'The method has no selector.' ].  ^(RBCondition canUnderstand: tmp1 selector in: self definingClass) notrightFailed  ^right errorStringFor: falseprivateTransform  | tmp1 tmp2 |  tmp1 := self definingMethod.  tmp2 := tmp1 body.  interval ifNotNil: [ | tmp3 |        tmp3 := tmp1 bestNodeFor: interval.        tmp3 isSequence ifTrue: [ tmp2 := tmp3 ] ].  tmp2 addTemporaryNamed: variableName.  class compileTree: tmp1classModelOf: arg1  | tmp1 |  tmp1 := arg1 isMeta ifTrue: [ RBClassModelFactory rbMetaclass named: arg1 name ] ifFalse: [ RBClassModelFactory rbClass named: arg1 name ].  tmp1 model: self model.  ^tmp1removePulledUpMethods  selectors do: [:arg1 |  class removeMethod: arg1 ]changeForClass: arg1 selector: arg2  ^(isMeta not and: [ self selector = arg2 and: [ className = arg1 ] ]) ifTrue: [ self ] ifFalse: [ nil ]whatToDisplayIn: arg1  ^self changes changes flatCollect: [:arg2 |  arg2 whatToDisplayIn: arg1 ]extract: arg1 from: arg2 to: arg3 in: arg4  class := arg4.  selector := arg2.  newSelector := arg3.  sourceCode := arg1includesClass: arg1  ^arg1 == class and: [ super includesClass: arg1 ]instanceVariableReaders  ^instanceVariableReadersinstanceVariableNames  ^fromClass allInstanceVariableNames asSetandedEnvironment  ^andedEnvironmentreturnInEnsure  [ self error: 'asdf' ] ensure: [ ^4 ]booleanPrecedence  ^(true & 4) = 45refersToClassNamed: arg1  | tmp1 |  tmp1 := self parserTreeSearcher.  tmp1 matches: arg1 asString do: [:arg2 :arg3 |  true ].  ^(tmp1 executeTree: self parseTree initialAnswer: false) or: [ self refersToSymbol: arg1 ]removeSubclass: arg1  self subclasses remove: arg1 ifAbsent: [  ]defaultEnvironment  ^RBBrowserEnvironment newreference  ^RBRemoveClassTesttestRemoveClassChange  | tmp1 |  tmp1 := modelFactory rbNamespace new.  tmp1 removeClassNamed: self class name.  self deny: (tmp1 includesClassNamed: self class name).  self assert: (tmp1 classNamed: self class name) isNilvisitSequenceNode: arg1  | tmp1 |  tmp1 := arg1 parent isMethod.  arg1 temporaries do: [:arg2 |  tmp1 ifTrue: [ difference := difference + (('tempMatch' , temporaries asString) size - arg2 name asString size + 2) ].        self replace: arg2 with: 'tempMatch' , temporaries asString.        temporaries := temporaries + 1 ].  super visitSequenceNode: arg1testSplitCascadeRefactoring  | tmp1 |  tmp1 := RBSplitCascadeRefactoring split: (54 to: 55) from: #methodWithCascades in: self class.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBSplitCascadeRefactoringTest) parseTreeFor: #methodWithCascades) equals: (self parseMethod: 'methodWithCascades	| a receiver |	receiver := Object new.	receiver initialize.	a := receiver asString.	^ a')inlineMax  | tmp1 tmp2 tmp3 |  tmp1 := 5.  tmp2 := 10.  tmp3 := tmp1 + 1 max: tmp2.  ^tmp3checkParseTree  | tmp1 |  blockNodes := OrderedCollection new.  tmp1 := self whichVariableNode: parseTree inInterval: interval name: name.  tmp1 ifNil: [ self refactoringFailure: 'Unable to locate node in parse tree' ].  definingNode := tmp1 whoDefines: name.  definingNode ifNil: [ self refactoringFailure: 'Cannot locate variable definition' ].  definingNode isSequence ifFalse: [ self refactoringFailure: 'Variable is an argument' ].  (self usesDirectly: definingNode) ifTrue: [ self refactoringFailure: 'Variable already bound tightly as possible' ].  (self checkNodes: (self subblocksIn: definingNode)) ifFalse: [ self refactoringError: 'Variable is possibly read before written' ]setOption: arg1 toUse: arg2  | tmp1 |  tmp1 := self options.  tmp1 == self class refactoringOptions ifTrue: [ tmp1 := tmp1 copy ].  tmp1 at: arg1 put: arg2.  self options: tmp1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' variable: '.  variableName storeOn: arg1.  arg1 nextPutAll: ' class: '.  class storeOn: arg1.  arg1 nextPutAll: ' classVariable: '.  classVariable storeOn: arg1.  arg1 nextPut: $)testDoesNotDefineVariable  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation model: model instanceVariable: 'instVarName1' class: #Bar) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: 'Foo1' class: #RBFooLintRuleTestData) asRefactoringyourselfNotUsed  self     printString;     printString;     yourselftransform  self     addSuperclass;     pushUpVariables;     pullUpMethods;     changeIsKindOfReferences;     reparentSubclassespreconditions  ^(RBCondition withBlock: [ | tmp1 |        interval first > interval last ifTrue: [ self refactoringFailure: 'You must select a variable name' ].        tmp1 := class sourceCodeFor: selector.        tmp1 size >= interval last ifFalse: [ self refactoringFailure: 'Invalid range for variable' ].        oldName := tmp1 copyFrom: interval first to: interval last.        true ]) & (RBCondition isValidInstanceVariableName: newName for: class) & (RBCondition definesSelector: selector in: class) & (RBCondition definesInstanceVariable: newName in: class) not & (RBCondition definesClassVariable: newName in: class) notaddMethodSource: arg1 in: arg2  ^RBAddMethodChange compile: arg1 in: arg2changeClass: arg1  super changeClass: arg1.  isMeta := falseinstanceVariablesFor: arg1  | tmp1 tmp2 |  tmp1 := Set new.  tmp2 := arg1 name.  tmp1     addAll: (instanceVariables at: tmp2 ifAbsent: [ #() ]);     addAll: (instanceVariableReaders at: tmp2 ifAbsent: [ #() ]);     addAll: (instanceVariableWriters at: tmp2 ifAbsent: [ #() ]).  ^tmp1nameToDisplay  ^self printStringallSuperclasses  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := self superclass.  [ tmp2 notNil ] whileTrue: [ tmp1 add: tmp2.        tmp2 := tmp2 superclass ].  ^tmp1canUnderstand: arg1  ^self definesMethod: arg1packageNames  ^self packages collect: [:arg1 |  arg1 packageName ]testReceiverDoesNotExist  self shouldFail: (RBAddMessageSendTransformation messageSend: 'variable2 byteAt: 1' inMethod: #methodBefore inClass: #RBAddMessageSendTransformationTest) asRefactoringprivateTransform  self definingClass compile: sourceCode classified: (Array with: protocol)guessTypesFor: arg1  ^bestGuesses at: arg1 ifAbsent: [ self typesFor: arg1 ]includesPackage: arg1  ^truestoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' selector: #';     nextPutAll: selector;     nextPutAll: ' class: '.  class storeOn: arg1.  arg1     nextPutAll: ' variable: ''';     nextPutAll: variable;     nextPutAll: ''')'transform  | tmp1 tmp2 |  self model allClassesDo: [:arg1 |  arg1 selectors do: [:arg2 |  tmp1 := (arg1 realClass whichCategoryIncludesSelector: arg2) asString.              tmp1 ifNotNil: [ tmp2 := self execute: tmp1.                    tmp2 = tmp1 ifFalse: [ arg1 compile: (arg1 sourceCodeFor: arg2) classified: tmp2 ] ] ] ]testVariableAlreadyExists  self shouldFail: (RBAddTemporaryVariableTransformation variable: 'variable' inMethod: #methodBefore inClass: #RBAddReturnStatementTransformationTest) asRefactoringtestAlreadyExistingName  self     shouldFail: (RBAddVariableTransformation instanceVariable: 'class' class: #RBTransformationRuleTestData) asRefactoring;     shouldFail: (RBAddVariableTransformation instanceVariable: 'name' class: #RBTransformationRuleTestData) asRefactoring;     shouldFail: (RBAddVariableTransformation classVariable: #RecursiveSelfRule class: #RBTransformationRuleTestData) asRefactoring;     shouldFail: (RBAddVariableTransformation classVariable: self objectClassVariable class: #RBTransformationRuleTestData) asRefactoringaddClassDefinition: arg1  ^RBAddClassChange definition: arg1testRenameClassVarInSharedPool  | tmp1 tmp2 tmp3 |  tmp1 := RBRenameClassVariableRefactoring rename: #Var1 to: #VarOne in: RBSharedPoolForTestData.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBSharedPoolForTestData.  tmp3 := tmp1 model classNamed: #RBClassUsingSharedPoolForTestData.  self assert: (tmp2 parseTreeFor: #msg1) equals: (self parseMethod: 'msg1 ^ VarOne').  self assert: (tmp2 parseTreeFor: #msg2) equals: (self parseMethod: 'msg2 ^ VarOne').  self assert: (tmp3 parseTreeFor: #msg3) equals: (self parseMethod: 'msg3 ^ VarOne')testExistingName  self shouldFail: (RBAddClassRefactoring addClass: #Object superclass: self class subclasses: #() category: #'Refactory-Testing')rationale  ^self class commentrealClass  ^realClassincludesSelector: arg1 in: arg2  ^(environment includesSelector: arg1 in: arg2) and: [ self packages anySatisfy: [:arg3 |  arg3 includesSelector: arg1 ofClass: arg2 ] ]protocols  ^self modelClass protocolsFor: self selectorpreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition definesSelector: selector in: self definingClass)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' extract: '.  extractionInterval storeOn: arg1.  arg1     nextPutAll: ' from: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1 nextPut: $)compileMethod  class compileTree: sourceParseTreetestRenameClassVariable  | tmp1 |  tmp1 := changes renameClassVariable: 'ClassVar1' to: 'ClassVar2' in: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 oldName equals: 'ClassVar1'.  self assert: tmp1 newName equals: 'ClassVar2'.  self universalTestFor: tmp1testPrimitive  self shouldFail: (RBInlineMethodRefactoring inline: (14 to: 23) inMethod: #testMethod forClass: RBRefactoryTestDataApp)rootClasses  ^model rootClassestestRenameClassVar  | tmp1 tmp2 |  tmp1 := RBRenameClassVariableRefactoring rename: #RecursiveSelfRule to: #RSR in: RBTransformationRuleTestData.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 directlyDefinesClassVariable: #RSR).  self deny: (tmp2 directlyDefinesClassVariable: #RecursiveSelfRule).  self assert: (tmp2 classSide parseTreeFor: #initializeAfterLoad1) equals: (self parseMethod: 'initializeAfterLoad1								RSR := RBParseTreeSearcher new.								RSR									addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')											-> [:aNode :answer | true]').  self assert: (tmp2 classSide parseTreeFor: #nuke) equals: (self parseMethod: 'nuke								RSR := nil').  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 								class := aSmalllintContext selectedClass.								(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 										[(RSR executeTree: rewriteRule tree initialAnswer: false)											ifFalse: 												[builder compile: rewriteRule tree printString													in: class													classified: aSmalllintContext protocols]]')canReferenceVariable: arg1 in: arg2  (arg2 definesVariable: arg1) ifTrue: [ ^true ].  (self model includesGlobal: arg1 asSymbol) ifTrue: [ ^true ].  ^(self poolVariableNamesFor: arg2) includes: arg1testRemoveMethod  | tmp1 |  tmp1 := changes removeMethod: #setUp from: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 selector equals: #setUp.  self universalTestFor: tmp1generateNewMethodWith: arg1  | tmp1 tmp2 |  tmp1 := arg1 arguments collect: [:arg2 |  RBVariableNode named: arg2 ].  tmp2 := RBMethodNode selector: arg1 selector arguments: tmp1 asArray body: (subtree isSequence ifTrue: [ subtree ] ifFalse: [ RBSequenceNode temporaries: #() statements: (OrderedCollection with: subtree) ]).  temporaries do: [:arg3 |  tmp2 body addTemporaryNamed: arg3 ].  ((parseTree parentOfSubtree: subtree) uses: subtree) ifTrue: [ tmp2 addReturn ].  assignments size = 1 ifTrue: [ tmp2 addNode: (RBReturnNode value: (RBVariableNode named: assignments first asString)) ].  ^tmp2setUp  super setUp.  model := self abstractVariableTestDatatestRemoveClassesWithReferencesBetweenThem  | tmp1 |  tmp1 := RBRemoveClassRefactoring classNames: {#RBRemoveClassTest .         #RBSharedPoolForTestData2}.  self executeRefactoring: tmp1.  self assert: (tmp1 model classNamed: #RBRemoveClassTest) isNil.  self assert: (tmp1 model classNamed: #RBSharedPoolForTestData2) isNilcreateNewClassFor: arg1  | tmp1 tmp2 tmp3 |  tmp3 := arg1 instanceSide name.  tmp1 := (modelFactory rbClass existingNamed: tmp3)     model: self;     yourself.  tmp2 := (modelFactory rbMetaclass existingNamed: tmp3)     model: self;     yourself.  ^changedClasses at: tmp3 put: (Array with: tmp1 with: tmp2)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' rename: '.  class storeOn: arg1.  arg1     nextPutAll: ' to: #';     nextPutAll: newName;     nextPut: $)rewriteRule  ^rewriteRulechangesSize  ^1transform: arg1  | tmp1 |  tmp1 := (self changes detect: [:arg2 |  arg2 isMeta = arg1 methodClass isMeta & (arg2 changeClassName = arg1 criticTheNonMetaclassClass name) & (arg2 selector = arg1 selector) ]) source.  arg1 methodClass compile: tmp1targetClass  ^classtestMetaClassFailure  self shouldFail: (RBAddClassVariableRefactoring variable: #VariableName class: RBTransformationRuleTestData class)whatToDisplayIn: arg1  | tmp1 |  tmp1 := OrderedCollection with: self.  ^tmp1 , (self changes flatCollect: [:arg2 |  arg2 changes ])privateTransform  transformationBlock value: self modelchangeSymbol  ^#removeInstVarNamed:implementorsOf: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self rootClasses do: [:arg2 |  self implementorsOf: arg1 in: arg2 storeIn: tmp1 ].  ^tmp1result  ^self subclassResponsibilityprotocolsFor: arg1  | tmp1 |  tmp1 := self isMeta ifTrue: [ model changes changeForMetaclass: name selector: arg1 ] ifFalse: [ model changes changeForClass: name selector: arg1 ].  ^tmp1 ifNil: [ self isDefined ifTrue: [ Array with: (RBBrowserEnvironment new whichProtocolIncludes: arg1 in: self realClass) ] ifFalse: [ #(#accessing) ] ] ifNotNil: [ tmp1 protocols ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' renameMethod: #';     nextPutAll: oldSelector;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' to: #';     nextPutAll: newSelector;     nextPutAll: ' permutation: '.  permutation storeOn: arg1.  arg1 nextPut: $)existingSelector  | tmp1 |  tmp1 := self requestExistingSelector.  tmp1 ifNotNil: [ ^tmp1 ] ifNil: [ ^class allSelectors detect: [:arg1 |  self isMethodEquivalentTo: arg1 ] ifNone: [ nil ] ]model: arg1  model := arg1superSends  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1 addSearch: 'super `@message: ``@args' -> ([:arg1 |  (class withAllSubclasses detect: [:arg2 |  arg2 includesSelector: arg1 selector ] ifNone: [ nil ]) isNil ] -> 'self `@message: ``@args').  self rewriteUsing: tmp1precedence  ^self isArray ifFalse: [ (self block + 5) * 34 ] ifTrue: [ self printString = 10 ]currentSelector  ^currentSelector| arg1  self isSystem ifTrue: [ ^self ].  arg1 isSystem ifTrue: [ ^arg1 ].  ^RBOrEnvironment onEnvironment: self or: arg1testModelExtractMethodWithTemporaryAssigned  | tmp1 tmp2 |  model := RBClassModelFactory rbNamespace new.  tmp1 := model classNamed: self class name.  tmp1 compile: 'foo 				| temp bar | 				bar := 5. 				temp := bar * bar. 				Transcript show: temp printString; cr. 				^temp * temp' classified: #(#accessing).  tmp2 := RBExtractMethodRefactoring model: model extract: (26 to: 102) from: #foo in: tmp1.  self setupMethodNameFor: tmp2 toReturn: #foobar.  self executeRefactoring: tmp2.  self assert: (tmp1 parseTreeFor: #foo) equals: (self parseMethod: 'foo | temp | temp := self foobar. ^temp * temp').  self assert: (tmp1 parseTreeFor: #foobar) = (self parseMethod: 'foobar | bar temp | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.') | ((tmp1 parseTreeFor: #foobar) = (self parseMethod: 'foobar | temp bar | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.'))displayProtocolName  ^protocolonlyReadOrWrittenTemporary  | tmp1 |  tmp1 := 1comment: arg1 in: arg2  ^RBCommentChange comment: arg1 in: arg2removePoolVariable: arg1 from: arg2  ^RBRemovePoolVariableChange remove: arg1 from: arg2errorString  ^self errorStringFor: falsepreconditions  ^RBCondition emptytestNotEnvironment  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := universalEnvironment referencesTo: #printString.  tmp1 := tmp2 not.  tmp3 := RBPackageEnvironment packageName: 'Kernel'.  tmp4 := tmp3 not.  self universalTestFor: tmp1.  self assertEmpty: (tmp1 referencesTo: #printString).  self assert: (tmp1 not includesClass: RBBrowserEnvironmentTest).  self assert: (tmp1 not includesSelector: #testNotEnvironment in: RBBrowserEnvironmentTest).  self assert: (tmp4 includesPackage: 'Kernel' asPackage) not.  self assertEmpty: (tmp4 & tmp3) packagescategories: arg1  categories addAll: arg1selectorsForClass: arg1 do: arg2  environment selectorsForClass: arg1 do: [:arg3 |  (andedEnvironment includesSelector: arg3 in: arg1) ifTrue: [ arg2 value: arg3 ] ]update: arg1  isPerformingRefactoring ifFalse: [ self clearUndoRedoList ]testInvalidSubclass  self shouldFail: (RBAddClassTransformation addClass: #Foo superclass: #RBCompositeLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData) category: #'Refactory-Tesing') asRefactoringwithClassesFixedForNautilus  classSelectors ifEmpty: [ metaClassSelectors keysAndValuesDo: [:arg1 :arg2 |  classSelectors at: arg1 ifAbsentPut: [ IdentitySet new ] ] ]definingMethod  ^method ifNil: [ method := (self definingClass methodFor: selector asSymbol) ast ]buildTransformations  ^OrderedCollection new     add: (RBRemoveVariableTransformation model: self model variable: variableName class: className classVariable: isClassVariable);     addAll: (self variableDefinitionsInHierarchy collect: [:arg1 |  RBAddVariableTransformation model: self model variable: variableName class: arg1 classVariable: isClassVariable ]);     yourselfcreateNewClass  self     addClass;     addInstanceVariablespackages  ^self classes collect: #packagecheckBrowseAllOccurences: arg1  | tmp1 tmp2 |  tmp1 := arg1 collect: [:arg2 |  arg2 key ] as: Set.  tmp2 := arg1 collect: [:arg3 |  arg3 value ].  tmp1 size = 1 ifTrue: [ self refactoringError: ('Possible call to <2s> in <1p> methods.<n>Browse references?' expandMacrosWith: arg1 size with: tmp1 anyOne) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: tmp1 anyOne) ] ] ifFalse: [ self refactoringError: ('Possible call to the <2p> selectors in <1p> methods.<n>Browse references?' expandMacrosWith: tmp2 size with: tmp1 size) with: [ | tmp3 |              tmp3 := RBSelectorEnvironment new.              tmp2 do: [:arg4 |  tmp3 addMethod: arg4 method ].              self openBrowserOn: tmp3 ] ]renameAccessorsReferences  | tmp1 tmp2 |  tmp1 := (class allSelectors select: [:arg1 |  (class methodFor: arg1) isNotNil ] thenCollect: [:arg1 |  arg1 ]) asOrderedCollection.  tmp2 := (tmp1 select: [:arg1 |  (class methodFor: arg1) source includesSubstring: variableName asString ] thenCollect: [:arg1 |  class methodFor: arg1 ]) asOrderedCollection.  tmp2 do: [:arg1 |  arg1 source: (arg1 source copyReplaceAll: variableName asString with: newName asString asTokens: false) ].  tmp2 do: [:arg1 |  (arg1 selector = newName or: [ arg1 selector asString = (newName asString , ':') ]) ifFalse: [ (model classNamed: class name) compile: arg1 source classified: arg1 protocols ] ]asUndoOperation  ^RBRemoveProtocolChange removeProtocolNamed: protocol in: self changeClassprimitiveExecute  definedSelector := self changeClass compile: self source classified: self protocol notifying: self controllerrenameMessageSends  self convertAllReferencesTo: oldSelector using: self parseTreeRewriterimplements: arg1  ^self selectors includes: arg1renameInstanceVariable: arg1 to: arg2 around: arg3  self privateInstanceVariableNames at: (self privateInstanceVariableNames indexOf: arg1 asString) put: arg2 asString.  ^self model performChange: (RBRenameInstanceVariableChange rename: arg1 to: arg2 in: self) around: arg3addChange: arg1  changes add: arg1.  ^arg1compileNewMethod  class compileTree: self parseTreeexecuteSearch: arg1  class withAllSubclasses do: [:arg2 |  arg2 selectors do: [:arg3 |  | tmp1 |              methodName := arg3.              tmp1 := arg2 parseTreeFor: arg3.              tmp1 notNil ifTrue: [ arg1 executeTree: tmp1 ] ] ]checkVariableReferencesIn: arg1  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matches: '`var' do: [:arg2 :arg3 |  | tmp2 |        tmp2 := arg2 name.        (arg2 whoDefines: tmp2) ifNil: [ self checkSendersAccessTo: tmp2 ] ].  tmp1 executeTree: arg1printOn: arg1  arg1 nextPutAll: self labelshouldFixSubclasses  ^shouldFixSubclassescopyOptionsFrom: arg1  | tmp1 |  tmp1 := self options.  tmp1 == self class refactoringOptions ifTrue: [ ^self options: arg1 copy ].  tmp1 keysAndValuesDo: [:arg2 :arg3 |  arg3 == (self class refactoringOptions at: arg2) ifTrue: [ tmp1 at: arg2 put: (arg1 at: arg2) ] ].  self options: tmp1refersToClass  ^RBSmalllintTestObjectrenameClasses  mode := #rename:name:renameAllParameters  parameterMap ifNotNil: [ parameterMap keysAndValuesDo: [:arg1 :arg2 |  arg1 ~= arg2 ifTrue: [ self renameParameterWith: arg1 to: arg2 ] ] ]environmentWithUsersOf: arg1  ^RBClassEnvironment onEnvironment: RBBrowserEnvironment new classes: arg1 realClass usersinstanceVariables: arg1  instanceVariables := arg1variable: arg1 inMethod: arg2 inClass: arg3  class := arg3.  selector := arg2.  variableName := arg1addAssociation  [ | tmp1 tmp2 |  tmp1 := argumentsList at: self argumentIndex.  tmp2 := valuesList at: self valueIndex.  tree := RBParseTreeRewriter replace: tmp2 with: tmp1 in: tree.  argsAndValues at: tmp1 put: tmp2.  argumentsList removeAt: self argumentIndex.  valuesList removeAt: self valueIndex.  sourceCodeMorph contents: self sourceCode.  self     changed: #associations;     changed: #arguments;     changed: #values;     changed: #isOkEnabled ] on: Error do: [ self inform: 'Please select one argument and one value.' ]classInstanceVariableNames  ^classInstanceVariableNamestestRefactoring  | tmp1 tmp2 |  tmp1 := (RBRemoveSubtreeTransformation code: 'selector := aSelector' from: #selector:from: in: #RBRemoveMethodTransformation) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBRemoveMethodTransformation.  self assert: (tmp2 directlyDefinesMethod: #selector:from:).  self assert: (tmp2 parseTreeFor: #selector:from:) body statements size equals: 1testMethodDoesNotExist  self shouldFail: (RBRemoveReturnStatementTransformation return: '^ variable' inMethod: #method inClass: #RBRemoveReturnStatementTransformationTest) asRefactoringshouldnt: arg1 raise: arg2 whoseDescriptionDoesNotInclude: arg3 description: arg4  ^self assert: (self executeShould: arg1 inScopeOf: arg2 withDescriptionNotContaining: arg3) not description: arg4run  ^RBSmalllintChecker runRule: selfshould: arg1 notTakeMoreThanMilliseconds: arg2  self should: arg1 notTakeMoreThan: (Duration milliSeconds: arg2)instanceVariableNames  ^self privateInstanceVariableNames copytestPerformRenameClassInstanceVariable  | tmp1 |  tmp1 := changes renameInstanceVariable: 'classInstVar' to: 'classInstVarPlus' in: self changeMock class.  self perform: tmp1 do: [ self deny: (tmp1 changeClass instVarNames includes: tmp1 oldName).        self assert: (tmp1 changeClass instVarNames includes: tmp1 newName) ].  self assert: (tmp1 changeClass instVarNames includes: tmp1 oldName).  self deny: (tmp1 changeClass instVarNames includes: tmp1 newName)includesCategory: arg1  ^(environment includesCategory: arg1) or: [ orEnvironment includesCategory: arg1 ]junk  ^RBRefactoryTestDataApp printString copyFrom: 1 to: CRobjectClassVariable  ^Object classPool keys detect: [:arg1 |  true ]initialize  super initialize.  instanceVariables := Dictionary new.  classVariables := Dictionary new.  instanceVariableReaders := Dictionary new.  instanceVariableWriters := Dictionary newviewResults  self subclassResponsibilitybuildSelectorString: arg1 withPermuteMap: arg2  | tmp1 tmp2 |  arg1 numArgs == 0 ifTrue: [ ^arg1 asString ].  tmp1 := WriteStream on: String new.  tmp2 := arg1 keywords.  tmp2 with: arg2 do: [:arg3 :arg4 |  tmp1           nextPutAll: arg3;           nextPutAll: ' ``@arg';           nextPutAll: arg4 printString;           nextPut: $  ].  ^tmp1 contentswithAllSuperclasses  ^self allSuperclasses     add: self;     yourselfbuildTransformations  | tmp1 |  tmp1 := self model classObjectFor: className.  ^tmp1 instanceVariableNames collect: [:arg1 |  RBAddVariableAccessorTransformation model: self model instanceVariable: arg1 class: tmp1 ]testExistingName  self shouldFail: (RBAddClassTransformation addClass: #Object superclass: self class name subclasses: #() category: #'Refactory-Testing') asRefactoringcombineMessages  | tmp1 |  transformedNode := RBCascadeNode messages: (statementNodes collect: [:arg1 |  arg1 copy ]).  tmp1 := statementNodes last parent.  [ tmp1 isAssignment ] whileTrue: [ transformedNode := RBAssignmentNode variable: tmp1 variable value: transformedNode.        tmp1 := tmp1 parent ]preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self verifySelectedInterval.              true ])poolDictionaryNames: arg1  poolDictionaryNames := (arg1 collect: [:arg2 |  arg2 asSymbol ]) asOrderedCollectionnoMoveDefinition  | tmp1 |  ^(self collect: [:arg1 |  tmp1 := arg1 printString.        tmp1 , tmp1 ]) select: [:arg1 |  tmp1 := arg1 size + tmp1 ]testSelectorsNotHaveSameNumberOfArgs  self shouldFail: (RBReplaceMethodRefactoring replaceCallMethod: #checkClass: in: RBBasicLintRuleTestData to: #checkMethod23 permutation: (1 to: 1))testAddParameterThatReferencesGlobalAndLiteral  | tmp1 tmp2 |  tmp1 := RBAddParameterRefactoring addParameterToMethod: ('test' , 'Foo:') asSymbol in: RBRefactoryTestDataApp newSelector: #testFoo:bar: initializer: 'OrderedCollection new: 5'.  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #testFoo:bar:) equals: (self parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').  self assert: (tmp2 parseTreeFor: #callFoo) equals: (self parseMethod: 'callFoo ^self testFoo: 5 bar: (OrderedCollection new: 5)').  self deny: (tmp2 directlyDefinesMethod: ('test' , 'Foo:') asSymbol)setUp  super setUp.  model := self abstractVariableTestDatatestBadInterval  self shouldFail: (RBExtractMethodTransformation extract: 'whatever' from: #testMethod to: #bla in: #RBRefactoryTestDataApp) asRefactoring.  self shouldFail: (RBExtractMethodTransformation extract: (self sourceCodeAt: (80 to: 147) forMethod: #subclassOf:overrides: in: RBBasicLintRuleTestData class) from: #subclassOf:overrides: to: #bla in: #'RBBasicLintRuleTestData class') asRefactoringtestParseFailure  | tmp1 |  tmp1 := (RBAddSubtreeTransformation interval: (0 to: 1) with: ':= 123' from: #one in: self changeMock name) transform.  self assertEmpty: tmp1 model changes changesincludesCategory: arg1  ^(self classNamesFor: arg1) isNotEmptytestComposite  changes     compile: 'method ^ 1' in: self class classified: #utilities;     compile: 'method ^ 2' in: self class class classified: #utilities.  self assert: changes changesSize equals: 2.  self assert: changes problemCount equals: 2.  self assert: (changes changeForClass: self class name selector: #method) notNil.  self assert: (changes changeForMetaclass: self class name selector: #method) notNil.  self universalTestFor: changesclassNames  ^IdentitySet new     addAll: classes;     addAll: metaClasses;     yourselfisArchitecturalRule  ^truerenameChangesForClass: arg1 to: arg2  self subclassResponsibilityrootClass: arg1  rootClass := arg1 instanceSidechangeClass: arg1  super changeClass: arg1.  isMeta := falserenameThisMethod: arg1  ^selfcalculateTemporaries  ^temporaries ifNil: [ | tmp1 tmp2 |        tmp1 := parseTree allDefinedVariables difference: subtree allDefinedVariables.        tmp2 := tmp1 select: [:arg1 |  subtree references: arg1 ].        temporaries := tmp2 select: [:arg1 |  subtree assigns: arg1 ] ]compileTree: arg1  ^(self methodFor: arg1 selector) compileTree: arg1testClassDoesNotExist  self shouldFail: (RBAddPragmaTransformation pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #methodBefore inClass: #RBPragmaTransformationTest) asRefactoring= arg1  ^self == arg1 or: [ self species == arg1 species ]compile: arg1 in: arg2  ^self addChange: (changeFactory addMethodSource: arg1 in: arg2)replaceAssignment  assignmentNode parent isSequence ifTrue: [ assignmentNode parent removeNode: assignmentNode ] ifFalse: [ assignmentNode replaceWith: assignmentNode value ]testExistingName  self shouldFail: (RBRenameClassRefactoring rename: self class to: #Object)packages  ^environment packages | orEnvironment packagesstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' addClass: #';     nextPutAll: className;     nextPutAll: ' superclass: '.  superclass storeOn: arg1.  arg1 nextPutAll: ' subclasses: '.  subclasses asArray storeOn: arg1.  arg1 nextPutAll: ' category: '.  category storeOn: arg1.  arg1 nextPut: $)isVariableEnvironment  ^falsetestWithAssignment  | tmp1 tmp2 |  tmp1 := (RBProtectVariableTransformation model: model instanceVariable: 'instVarName2' class: #Foo) asRefactoring transform.  tmp2 := model classNamed: #Foo.  self assert: (tmp2 parseTreeFor: #instVarName2:) equals: (self parseMethod: 'instVarName2: anObject instVarName2 := anObject').  self assert: (tmp2 parseTreeFor: #instVarName2) equals: (self parseMethod: 'instVarName2 ^instVarName2').  self assert: (tmp2 parseTreeFor: #foo) equals: (self parseMethod: 'foo ^self instVarName2: 3').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo			instVarName1 := instVarName1 + self instVarName2 + ClassVarName1')displayName  | tmp1 |  tmp1 := WriteStream on: (String new: 64).  tmp1     nextPutAll: self name;     nextPutAll: ' ('.  self problemCount printOn: tmp1.  tmp1 nextPut: $).  ^tmp1 contentsdefiningClass  ^self model classObjectFor: classtestModelRemoveUnusedVariable  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  self executeRefactoring: (RBPushDownInstanceVariableRefactoring model: model variable: 'foo' class: (model classNamed: #SomeClass)).  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo')check: arg1  ^self check: arg1 ifNoCritiques: [  ]visitMethodNode: arg1  arg1 arguments do: [:arg2 |  difference := difference + (('argMatch' , arguments asString) size - arg2 name asString size + 2).        self replace: arg2 with: 'argMatch' , arguments asString.        arguments := arguments + 1 ].  super visitMethodNode: arg1category  ^category ifNil: [ self isDefined ifTrue: [ category := self realClass category ] ifFalse: [ model environment whichCategoryIncludes: self name ] ] ifNotNil: [ category ]fillOutDefinition: arg1  superclassName := (arg1 at: '`@superclass') ifNotNil: [:arg2 |  arg2 asSymbol ].  className := (arg1 at: '`#className') asSymbol.  instanceVariableNames := self namesIn: (arg1 at: '`#instanceVariableNames' ifAbsent: [ String new ]).  classVariableNames := self namesIn: (arg1 at: '`#classVariableNames' ifAbsent: [ String new ]).  poolDictionaryNames := self namesIn: (arg1 at: '`#poolDictionaries' ifAbsent: [ String new ]).  category := (arg1 at: '`#category' ifAbsent: [ #Unclassified ]) asSymboltestOrEnvironment  | tmp1 tmp2 tmp3 |  tmp2 := #printOn:.  tmp2 := universalEnvironment forClass: Object selectors: #(#fullPrintString).  tmp1 := universalEnvironment forClass: Object selectors: #(#printOn:).  self assert: (tmp1 | tmp2) numberSelectors equals: 2.  self assert: (tmp2 | tmp1) numberSelectors equals: 2.  self universalTestFor: tmp1 | tmp2.  self assert: (tmp1 | tmp1) numberSelectors equals: 1.  tmp3 := tmp1 | tmp1 not.  self assert: (tmp2 | tmp1) packages size equals: 1.  self universalTestFor: tmp3.  self assert: tmp3 numberSelectors equals: universalEnvironment numberSelectors.  self assert: tmp3 classNames asSortedCollection equals: universalEnvironment classNames asSortedCollection.  self assert: (tmp3 protocolsFor: Object) equals: ((universalEnvironment protocolsFor: Object) reject: [:arg1 |  (Object allSelectorsInProtocol: arg1) isEmpty ])defineClass: arg1  | tmp1 tmp2 tmp3 |  tmp1 := changes defineClass: arg1.  tmp3 := tmp1 changeClassName.  tmp2 := self classNamed: tmp3.  tmp2 ifNil: [ | tmp4 |        self unmarkAsRemoved: tmp3.        tmp2 := modelFactory rbClass named: tmp3.        tmp4 := modelFactory rbMetaclass named: tmp3.        tmp2 model: self.        tmp4 model: self.        newClasses at: tmp3 put: (Array with: tmp2 with: tmp4) ].  tmp2 superclass: (self classNamed: tmp1 superclassName).  tmp2 superclass ifNil: [ self rootClasses add: tmp2.        tmp2 classSide superclass: (self classFor: Object class superclass) ] ifNotNil: [ tmp2 classSide superclass: tmp2 superclass classSide ].  tmp2 instanceVariableNames: tmp1 instanceVariableNames.  tmp2 classVariableNames: tmp1 classVariableNames.  tmp2 poolDictionaryNames: tmp1 sharedPoolNames.  tmp2 category: tmp1 category.  ^tmp1includesPragma: arg1  ^(keywords includes: arg1 selector) and: [ condition value: arg1 ]source  ^source ifNil: [ source := (class realClass sourceCodeAt: selector) asString ]addKeyword: arg1  keywords add: arg1asUndoOperation  ^changeFactory addMethodSource: (self methodSourceFor: selector) in: self changeClasstestRaisesRBRefactoringErrorWhenRemovingNonEmptySuperclass  self shouldFail: (RBRemoveClassRefactoring classNames: (Array with: ('RBFoo' , 'LintRuleTest') asSymbol))associations  ^argsAndValues associations collect: #asStringtextToDisplay  ^self namerealName: arg1  self realClass: (Smalltalk globals at: arg1) classSiderewriteRule1: arg1  ^rewriteRule1 := arg1errorBlockFor: arg1  ^errorBlockchangeClass  ^(onSystemDictionary classNamed: oldName) ifNil: [ onSystemDictionary classNamed: newName ]rationale  ^renrakuRule rationalemyConditions  ^RBCondition withBlock: [ oldSelector numArgs = newSelector numArgs ] errorString: newSelector printString , ' doesn''t have the correct number of arguments.'problemCount  ^self changesSizeaddDependentSends  self     addDependent: #one;     addDependent: #twoprivateTransform  | tmp1 tmp2 |  tmp1 := self definingMethod.  tmp2 := (tmp1 allChildren removeDuplicates select: #isReturn) select: [:arg1 |  arg1 sourceCode = returnValue ].  tmp2 ifEmpty: [ tmp1 removeLast ] ifNotEmpty: [ tmp2 do: [:arg1 |  arg1 parent removeNode: arg1 ] ].  self definingClass compileTree: tmp1gtInspectorTreeIn: arg1  < gtInspectorPresentationOrder: 0>  arg1 tree     title: 'Tree';     display: [ {self} ];     children: [:arg2 |  arg2 gtInspectorChildren ];     when: [ self gtInspectorChildren notEmpty ]includesClass: arg1  ^(super includesClass: arg1) and: [ categories includes: arg1 instanceSide category ]privateTransform  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self definingMethod.  tmp2 := self parserClass parseExpression: message.  tmp4 := tmp2 allVariables.  tmp3 := (tmp1 allChildren select: #isAssignment) select: [:arg1 |  tmp4 includes: arg1 variable ].  tmp5 := tmp3 detectMax: #stop.  tmp5 ifNil: [ tmp1 body addNodeFirst: tmp2 ] ifNotNil: [ tmp5 parent addNode: tmp2 after: tmp5 ].  class compileTree: tmp1splitCascade  ancestorNode parent addNode: (beforeNodes size > 1 ifTrue: [ RBCascadeNode messages: beforeNodes ] ifFalse: [ beforeNodes first ]) before: ancestorNode.  afterNodes size > 1 ifTrue: [ cascadeNode messages: afterNodes ] ifFalse: [ cascadeNode replaceWith: afterNodes first ].  class compileTree: ancestorNode methodNodechangeObject  ^self variabletestAddClassVariable  | tmp1 |  tmp1 := RBAddClassVariableRefactoring variable: 'Asdf' class: RBTransformationRuleTestData.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBTransformationRuleTestData) directlyDefinesClassVariable: #Asdf)selectors  ^selectorspreconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self extractMethod.              self checkSpecialExtractions.              self checkReturn.              needsReturn ifTrue: [ extractedParseTree addReturn ].              self checkTemporaries.              true ])floatEqualityComparison  ^1.0 = 1displayClassName  ^isMeta ifTrue: [ self changeClassName , ' class' ] ifFalse: [ self changeClassName asString ]selectorsForClass: arg1 do: arg2  ^(self privateSelectorsForClass: arg1) do: [:arg3 |  (arg1 includesSelector: arg3) ifTrue: [ arg2 value: arg3 ] ]checkLiteral: arg1  (arg1 isSymbol or: [ arg1 isVariableBinding ]) ifTrue: [ literals add: arg1 ] ifFalse: [ arg1 class == Array ifTrue: [ arg1 do: [:arg2 |  self checkLiteral: arg2 ] ] ]checkSuperclass  | tmp1 |  tmp1 := selectors select: [:arg1 |  targetSuperclass directlyDefinesMethod: arg1 ].  tmp1 := tmp1 reject: [:arg1 |  | tmp2 tmp3 |        tmp2 := class parseTreeFor: arg1.        tmp3 := targetSuperclass parseTreeFor: arg1.        tmp3 equalTo: tmp2 exceptForVariables: #() ].  tmp1 ifEmpty: [ ^self ].  targetSuperclass isAbstract ifFalse: [ self refactoringError: ('Non-abstract class <2p> already defines <1p>' expandMacrosWith: tmp1 asArray first with: targetSuperclass) ].  tmp1 do: [:arg1 |  self checkBackReferencesTo: arg1 ]preconditions  ^RBCondition emptyremoveImmediateBlocks  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1 replace: '[``.object] value' with: '``.object' when: [:arg1 |  arg1 parent isCascade not ].  tmp1 replace: '| `@temps | ``@.Stmts1. [| `@bTemps | ``@.bStmts] value. ``@.Stmts2' with: '| `@temps `@bTemps | ``@.Stmts1. ``@.bStmts. ``@.Stmts2'.  (tmp1 executeTree: sourceParseTree) ifTrue: [ sourceParseTree := tmp1 tree ]testMoveDefinitionIntoBlockThatIsAReceiverOfACascadedMessage  | tmp1 |  tmp1 := RBMoveVariableDefinitionRefactoring bindTight: (48 to: 58) in: RBRefactoryTestDataApp selector: #referencesConditionFor:.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #referencesConditionFor:) equals: (self parseMethod: 'referencesConditionFor: aClass 								| environment  |								^(RBCondition withBlock: 										[| association |association := Smalltalk globals associationAt: aClass name													ifAbsent: [self refactoringError: ''Could not find class''].										environment := (self environment referencesTo: association) 													| (self environment referencesTo: aClass name).										environment isEmpty])									errorMacro: aClass , '' is referenced.<n>Browse references?'';									errorBlock: [environment openEditor];									yourself')asEpiceaEvent  ^(EpGenericRefactoring canAccept: self) ifTrue: [ EpGenericRefactoring for: self ] ifFalse: [ EpUnknownRefactoring for: self ]testModelInvalidSubclass  | tmp1 |  tmp1 := RBAddClassRefactoring model: model addClass: #Foo2 superclass: Object subclasses: (Array with: (model classNamed: #Bar)) category: #'Refactory-Tesing'.  self shouldFail: tmp1assignmentInIfTrue  | tmp1 |  self isVariable ifTrue: [ tmp1 := self ] ifFalse: [ tmp1 := self printString ].  ^tmp1errorBlock: arg1  errorBlock := arg1parseMethod: arg1  ^self parserClass parseMethod: arg1should: arg1 description: arg2  self assert: arg1 value description: arg2foo  ^6deny: arg1 identicalTo: arg2  ^self deny: arg2 == arg1 description: [ self unexpectedIdentityEqualityStringBetween: arg1 and: arg2 ]guardingClause  self isSymbol ifFalse: [ self printString.        self isSymbol printString ]findStatementNodes  statementNodes := OrderedCollection new.  sequenceNode statements do: [:arg1 |  (sequenceNode isLast: arg1) ifFalse: [ self addStatementNode: arg1 ] ifTrue: [ | tmp1 |              tmp1 := arg1.              [ tmp1 isReturn or: [ tmp1 isAssignment ] ] whileTrue: [ tmp1 := tmp1 value ].              self addStatementNode: tmp1 ] ]preconditions  ^(RBCondition isMetaclass: class) not & (RBCondition definesClassVariable: variableName in: class) & (RBCondition withBlock: [ | tmp1 |              tmp1 := [:arg1 |  (arg1 whichSelectorsReferToClassVariable: variableName) isEmpty ifFalse: [ class realClass ifNil: [ self refactoringError: ('<1s> is referenced.' expandMacrosWith: variableName) ] ifNotNil: [ self refactoringError: ('<1s> is referenced.<n>Browse references?' expandMacrosWith: variableName) with: [ self openBrowserOn: (RBVariableEnvironment referencesToClassVariable: variableName in: class realClass) ] ] ] ].              class withAllSubclasses do: tmp1.              class classSide withAllSubclasses do: tmp1.              true ])initialize  super initialize.  self matcher matchesAnyMethodOf: #('`@MethodName: `@args 				| `@temps | 				`@.Statements. 				`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' '`@MethodName: `@args 				| `@temps | 				`@.Statements. 				`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]') do: [:arg1 :arg2 |  arg2 ifNil: [ arg1 body statements last ] ifNotNil: [ arg2 ] ]asEpiceaEvent  ^EpRenameInstanceVariableRefactoring rename: variableName to: newName in: class namefillOutDefinition: arg1  self subclassResponsibilityselectionIntervalFor: arg1  | tmp1 |  self searchStrings ifEmpty: [ ^nil ].  tmp1 := self selectionParseTreeIntervalFor: arg1.  tmp1 ifNotNil: [ ^tmp1 ].  self searchStrings do: [:arg2 |  | tmp2 tmp3 |        tmp2 := arg2 isSymbol ifTrue: [ arg2 keywords first ] ifFalse: [ arg2 ].        tmp3 := arg1 indexOfSubCollection: tmp2 startingAt: 1.        tmp3 > 0 ifTrue: [ ^tmp3 to: tmp3 + tmp2 size - 1 ] ].  ^niltestPushDownMethodThatReferencesPoolDictionary  | tmp1 tmp2 tmp3 |  tmp3 := RBLintRuleTestData parseTreeFor: #junk.  self proceedThroughWarning: [ tmp1 := RBPushDownMethodRefactoring pushDown: #(#junk) from: RBLintRuleTestData.        self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self deny: (tmp2 directlyDefinesMethod: #junk).  tmp2 subclasses do: [:arg1 |  self assert: (arg1 parseTreeFor: #junk) equals: tmp3.        self assert: (arg1 directlyDefinesPoolDictionary: 'TextConstants' asSymbol) ]rules  ^rulestestClassDoesNotExist  self shouldFail: (RBRemovePragmaTransformation pragma: '<gtInspectorPresentationOrder: 34>' inMethod: #methodBefore inClass: #RBPragmaTransformationTest) asRefactoringisEmpty  ^self result isEmptyprivateTransform  self model renameClass: self definingClass to: newClassName around: [ self renameReferences ]testModelAbstractClassVariableOverridenMethodsInSubclass  | tmp1 tmp2 tmp3 |  tmp3 := model classNamed: #Foo.  tmp2 := tmp3 classSide.  tmp1 := RBAbstractClassVariableRefactoring model: model variable: 'ClassVarName2' class: tmp3.  self executeRefactoring: tmp1.  self assert: (tmp2 parseTreeFor: #classVarName21) equals: (self parseMethod: 'classVarName21 ^ClassVarName2').  self assert: (tmp2 parseTreeFor: #classVarName21:) equals: (self parseMethod: 'classVarName21: anObject ClassVarName2 := anObject')andedEnvironment: arg1  andedEnvironment := arg1gtInspectorChildren  ^#()extract: arg1 from: arg2 in: arg3  class := self classObjectFor: arg3.  selector := arg2.  extractionInterval := arg1threeElementPoint  ^(5 @ 5 + 6) @ 6testInlineTemporaryMutlipleAssignment  self shouldFail: (RBInlineTemporaryRefactoring inline: (60 to: 83) from: #moveDefinition in: RBRefactoryTestDataApp)testPerformAddRemoveClassVariable  | tmp1 |  tmp1 := changes addClassVariable: 'Foo' to: self changeMock.  self perform: tmp1 do: [ self assert: (tmp1 changeClass classVarNames includes: 'Foo') ].  self deny: (tmp1 changeClass classVarNames includes: 'Foo')parseInlineMethod  self inlineClass ifNil: [ self refactoringFailure: ('<1p> or its superclasses don''t contain method <2s>' expandMacrosWith: class with: self inlineSelector) ].  inlineParseTree := self inlineClass parseTreeFor: self inlineSelector.  inlineParseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ].  inlineParseTree lastIsReturn ifFalse: [ inlineParseTree addSelfReturn ]renameInstanceVariable: arg1 to: arg2 in: arg3  ^RBRenameInstanceVariableChange rename: arg1 to: arg2 in: arg3rewriteRule: arg1  rewriteRule := arg1isEmpty  ^rules allSatisfy: [:arg1 |  arg1 isEmpty ]initialize  name := ''copyFor: arg1  | tmp1 |  tmp1 := arg1 copy.  self assert: tmp1 numberSelectors equals: arg1 numberSelectors.  self assert: (tmp1 not & arg1) numberSelectors equals: 0testVariableDoesNotExistInOldClass  self shouldFail: (RBMoveInstanceVariableToClassTransformation model: model variable: 'abc' fromClass: #RBFooLintRuleTestData toClass: #RBBasicLintRuleTestData) asRefactoringtestTransform  | tmp1 tmp2 |  tmp1 := (RBAddTemporaryVariableTransformation variable: 'variable' inMethod: #one inClass: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 directlyDefinesMethod: #one).  self assert: (tmp2 parseTreeFor: #one) temporaries size equals: 1privateClassVariableNames  (self isDefined and: [ classVariableNames isNil ]) ifTrue: [ self classVariableNames: self realClass classVarNames ].  ^classVariableNamesarguments  ^argumentsList ifNil: [ argumentsList := arguments asOrderedCollection ]methodWithCascades  | tmp1 |  tmp1 := Object new     initialize;     asString.  ^tmp1testPerformChangeMetaclass  | tmp1 |  tmp1 := changes defineClass: self changeMock name , ' class 	instanceVariableNames: '''''.  self perform: tmp1 do: [ self assertEmpty: tmp1 changeClass class instVarNames ].  self denyEmpty: tmp1 changeClass class instVarNames.  self assert: tmp1 definedClass equals: self changeMock classtestClassVariableToMultipleSubclasses  | tmp1 |  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  tmp1 := model classNamed: #Subclass.  tmp1 compile: 'foo ^Foo' classified: #(#accessing).  model defineClass: 'Subclass subclass: #AnotherSubclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model classVariable: #Foo class: #SomeClass) asRefactoring transform.  self deny: (tmp1 superclass directlyDefinesClassVariable: #Foo).  self assert: (tmp1 directlyDefinesClassVariable: #Foo)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' comment: ''';     nextPutAll: comment;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)guessTypeFromAssignment: arg1  | tmp1 tmp2 tmp3 |  tmp1 := nil.  arg1 value isAssignment ifTrue: [ ^self guessTypeFromAssignment: (RBAssignmentNode variable: arg1 variable value: arg1 value value) ].  arg1 value isBlock ifTrue: [ tmp1 := model classFor: [  ] class ].  arg1 value isLiteralNode ifTrue: [ arg1 value value ifNil: [ ^self ].        tmp1 := model classFor: (self typeFor: arg1 value value) ].  arg1 value isMessage ifTrue: [ arg1 value receiver isVariable ifTrue: [ tmp1 := model classNamed: arg1 value receiver name asSymbol ].        arg1 value selector = #asValue ifTrue: [ tmp1 := model classNamed: #ValueHolder ].        (#(#and: #or: #= #== #~= #~~ #<= #< #~~ #> #>=) includes: arg1 value selector) ifTrue: [ tmp1 := model classFor: Boolean ] ].  tmp1 ifNil: [ ^self ].  tmp2 := variableTypes at: arg1 variable name.  tmp3 := tmp2 detect: [:arg2 |  tmp1 includesClass: arg2 ] ifNone: [ nil ].  tmp3 ifNil: [ ^self ].  ((self rootClasses includes: tmp3) or: [ tmp3 = (model classFor: Object) ]) ifTrue: [ tmp3 := tmp1 ].  (bestGuesses at: arg1 variable name ifAbsentPut: [ Set new ]) add: tmp3addClassDefinition: arg1 for: arg2  ^RBAddClassChange definition: arg1 for: arg2privateTransform  self     reparentSubclasses;     removeClassfoobar  ^#(true false)comment  ^comment = LookupComment ifTrue: [ comment := self isDefined ifTrue: [ self realClass comment ] ifFalse: [ nil ] ] ifFalse: [ comment ]defaultLabel  | tmp1 |  tmp1 := String new writeStream.  classes do: [:arg1 |  tmp1           nextPutAll: arg1;           nextPut: $  ].  ^tmp1 contentsclassVariableWriter  ClassVariable := nilnoMoveDefinition  | tmp1 |  ^(self collect: [:arg1 |  tmp1 := arg1 printString.        tmp1 , tmp1 ]) select: [:arg1 |  tmp1 := arg1 size + tmp1 ]definesClass: arg1  ^(environment definesClass: arg1) notreferencesTo: arg1 in: arg2  | tmp1 |  tmp1 := arg2 withAllSuperclasses asSet.  tmp1     addAll: arg2 allSubclasses;     addAll: arg2 class withAllSuperclasses;     addAll: arg2 class allSubclasses.  ^(self forClasses: tmp1) referencesTo: arg1subclasses  ^subclasses ifNil: [ subclasses := self isDefined ifTrue: [ ((self realClass subclasses collect: [:arg1 |  model classFor: arg1 ]) reject: [:arg1 |  arg1 isNil ]) asOrderedCollection ] ifFalse: [ OrderedCollection new ] ] ifNotNil: [ subclasses ]postCopy  super postCopy.  classes := classes copy.  metaClasses := metaClasses copyprotocols  ^protocolsincludesPackage: arg1  ^(environment includesPackage: arg1) notrenameParameterWith: arg1 to: arg2  self renameNode: extractedParseTree withOldName: arg1 toWithName: arg2addClass: arg1  arg1 isMeta ifTrue: [ metaClasses add: arg1 soleInstance name ] ifFalse: [ classes add: arg1 name ]comment: arg1  comment := arg1preconditions  self requestSuperClass.  ^(selectors inject: (RBCondition hasSuperclass: class) into: [:arg1 :arg2 |  arg1 & (RBCondition definesSelector: arg2 in: class) ]) & (RBCondition withBlock: [ self checkInstVars.              self checkClassVars.              self checkSuperclass.              self checkSuperMessages.              true ])addInstanceVariable: arg1  self privateInstanceVariableNames add: arg1.  model addInstanceVariable: arg1 to: selfsymbolReference  ^#RBClassToRenamecheckSuperSendsFromPushedUpMethods  selectors do: [:arg1 |  | tmp1 |        tmp1 := class parseTreeFor: arg1.        tmp1 superMessages detect: [:arg2 |  targetSuperclass directlyDefinesMethod: arg2 ] ifFound: [ self refactoringError: ('Cannot pull up <1s> since it sends a super message that is defined in the superclass.' expandMacrosWith: arg1) ] ]remove  | tmp1 |  tmp1 := self argumentList.  tmp1 removeAt: self argumentIndex.  self methodName arguments: tmp1.  self updateprivateTransform  | tmp1 tmp2 |  tmp1 := self definingMethod.  tmp2 := (tmp1 allChildren removeDuplicates select: #isMessage) select: [:arg1 |  arg1 selector = message asSymbol ].  tmp2 ifNotEmpty: [ tmp2 do: #removeFromTree.        self definingClass compileTree: tmp1 ]someDemoMethod  ^self junkshouldFixSubclasses: arg1  shouldFixSubclasses := arg1testRemoveClassWithBadName  self shouldFail: (RBRemoveClassTransformation className: #RecursiveSelfRule) asRefactoringstoreOn: arg1  environment storeOn: arg1.  arg1 nextPutAll: ' not'preconditionHasNoSubclasses: arg1  ^(RBCondition withBlock: [ arg1 subclasses isEmpty ])     errorMacro: self class cannotRemoveTopLevelClassErrorMesssage;     yourselfgroup  ^'Unclassified rules'isValid  ^selector isString and: [ (RBScanner isSelector: selector) and: [ selector numArgs = arguments size ] ]changeClass: arg1  isMeta := arg1 isMeta.  className := arg1 instanceSide namecreateSubclassResponsibilityFor: arg1 in: arg2  | tmp1 |  (arg2 superclass definesMethod: arg1) ifTrue: [ ^self ].  tmp1 := self subclassResponsibilityFor: arg1 in: arg2.  tmp1 ifNil: [ ^self ].  arg2 superclass compile: tmp1 classified: (arg2 protocolsFor: arg1)packages  ^self packageOrganizer packages select: [:arg1 |  self includesCategory: arg1 name ]assignmentInBlock  [ ^self printString ] ensure: [ self close ]isMeta  ^isMetarenameInstanceVariable: arg1 to: arg2 in: arg3 around: arg4  self deprecated: 'Use RBAbstractClass2 instead'displayString  ^name ifNil: [ self changeString ] ifNotNil: [ name ]errorBlock  ^self errorBlockFor: falsecombine: arg1 from: arg2 in: arg3  class := self classObjectFor: arg3.  selector := arg2.  selectedInterval := arg1runOnEnvironment: arg1  ^Object printOn: self onEnvironment: arg1comment  ^comment = LookupComment ifTrue: [ comment := self isDefined ifTrue: [ self realClass comment ] ifFalse: [ nil ] ] ifFalse: [ comment ]pullUpClassVariables  | tmp1 |  tmp1 := self abstractSuperclass.  parent classVariableNames do: [:arg1 |  self performComponentRefactoring: (RBPullUpClassVariableRefactoring model: self model variable: arg1 class: tmp1) ]childrenToSiblingTestData  ^'| m |(m:= RBNamespace 			onEnvironment: ((RBClassEnvironment onEnvironment: RBBrowserEnvironment new) 					classes: (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 										inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''ConcreteSuperclass subclass: #NoMoveSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''Object subclass: #ConcreteSuperclass	instanceVariableNames: ''''instVarName1 instVarName2 ''''	classVariableNames: ''''ClassVarName1 ClassVarName2 ''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''ConcreteSuperclass subclass: #ConcreteSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''') 	do: [:each | m defineClass: each].(m metaclassNamed: #ConcreteSuperclass) 	addInstanceVariable: ''classInstVarName1''.#(#(#ConcreteSubclass #(#(''initialize	super initialize.	instVarName1 := nil'' #everyone) #(''different	^0'' #everyone))) #(#ConcreteSuperclass #(#(''same	^self initialize isKindOf: ConcreteSuperclass'' #''one def'') #(''different	^instVarName1 + instVarName2'' #everyone) #(''initialize	instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0'' #everyone))) #(#NoMoveSubclass #(#(''same	^123'' #''one def''))) #(''ConcreteSubclass class'' #(#(''bar	^self storeString'' #testing))) #(''ConcreteSuperclass class'' #(#(''foo	^classInstVarName1 + ClassVarName1 + ClassVarName2'' #testing) #(''new	^super new initialize'' #testing) #(''bar	^self printString'' #testing))) #(''NoMoveSubclass class'' #())) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'resetResult  builder := RBRefactoryChangeManager changeFactory compositeRefactoryChangeNamed: self namebuildMethodArgumentSearch  self createMethodSearchWith: '`arg1: `arg1 `arg2: `arg2 | `@temps | `@.Stmts' selectors: #(#subclassOf:overrides: #createMatcherFor:method: #createParseTreeRule:name:) inClass: RBBasicLintRuleTestData classselectors  ^selectorsproceedThroughWarning: arg1  arg1 on: RBRefactoringWarning do: [:arg2 |  arg2 resume ]renameReferences  | tmp1 |  tmp1 := (RBParseTreeRewriter replaceLiteral: className with: newClassName)     replace: className with: newClassName;     yourself.  self model allReferencesToClass: self definingClass do: [:arg1 |  (arg1 modelClass hierarchyDefinesVariable: newClassName) ifFalse: [ self convertMethod: arg1 selector for: arg1 modelClass using: tmp1 ] ]parseSelector: arg1  ^[ self parserClass parseMethodPattern: arg1 ] on: Error do: [ nil ]returnInEnsure  [ self error: 'asdf' ] ensure: [ ^4 ]namesIn: arg1  | tmp1 tmp2 tmp3 |  tmp1 := OrderedCollection new.  tmp2 := RBScanner on: (ReadStream on: arg1) errorBlock: [:arg2 :arg3 |  ^tmp1 ].  [ tmp2 atEnd ] whileFalse: [ tmp3 := tmp2 next.        tmp3 isIdentifier ifTrue: [ tmp1 add: tmp3 value ] ].  ^tmp1 asArrayforPackages: arg1  ^RBPackageEnvironment onEnvironment: self packages: arg1replaceCallMethod: arg1 in: arg2 to: arg3 permutation: arg4  oldSelector := arg1 asSymbol.  newSelector := arg3 asSymbol.  class := self classObjectFor: arg2.  permutation := arg4testMethodDoesNotExist  self shouldFail: (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #name1 inClass: #RBDummyLintRuleTest)testUnusedInstanceVariable  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''foo''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass 			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (RBPushDownVariableTransformation model: model instanceVariable: 'foo' class: (model classNamed: #SomeClass)) asRefactoring transform.  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo')protocols  ^Array with: self protocoltestTransform  | tmp1 tmp2 |  tmp1 := (RBAddMessageSendTransformation new messageSend: 'variable byteAt: 1' inMethod: #methodBefore inClass: self class name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyprimitiveExecute  self changeClass removeFromSystemtestModelNonExistantName  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  self shouldFail: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: (model classNamed: #SomeClass))createSetterAccessor  setterMethod := self findSetterMethod.  setterMethod ifNil: [ setterMethod := self defineSetterMethod ]testInlineTemporaryReadBeforeWritten  self shouldFail: (RBInlineTemporaryRefactoring inline: (48 to: 56) from: #inlineTemporary in: RBRefactoryTestDataApp)testVariableAlreadyExists  self     shouldFail: (RBRenameVariableTransformation rename: 'classBlock' to: 'name' in: #RBBasicLintRuleTestData classVariable: false) asRefactoring;     shouldFail: (RBRenameVariableTransformation rename: #RecursiveSelfRule to: self objectClassVariable in: #RBTransformationRuleTestData classVariable: true) asRefactoringaddClassVariable: arg1  self privateClassVariableNames add: arg1 asSymbol.  model addClassVariable: arg1 to: selfmsg1  ^Var1suggestedCode: arg1  ^(self changes detect: [:arg2 |  arg2 isMeta = arg1 methodClass isMeta & (arg2 changeClassName = arg1 criticTheNonMetaclassClass name) & (arg2 selector = arg1 selector) ]) sourcecallMethod  ^self renameThisMethod: 5class: arg1 instanceVariables: arg2 newClassName: arg3 referenceVariableName: arg4  class := self model classFor: arg1.  instanceVariables := arg2.  newClassName := arg3.  referenceVariableName := arg4testModelRenameSequenceClass  model defineClass: 'Object subclass: #Foo1 			instanceVariableNames: '''' 			classVariableNames: '''' poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #Foo1)     compile: 'foo	 ^ Foo1' classified: #(accessing);     compile: 'objectName ^ #(Foo1)' classified: #(accessing).  (RBRenameClassTransformation model: model rename: #Foo1 to: #Foo2) asRefactoring transform.  (RBRenameClassTransformation model: model rename: #Foo2 to: #Foo3) asRefactoring transform.  self deny: (model includesClassNamed: #Foo1).  self deny: (model includesClassNamed: #Foo2).  self assert: (model includesClassNamed: #Foo3).  self assert: ((model classNamed: #Foo3) parseTreeFor: #foo) equals: (self parseMethod: 'foo ^ Foo3').  self assert: ((model classNamed: #Foo3) parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^ #(Foo3)')literalArrayCharacters  ^#($a $b $c) includes: $acollectionMessagesToExternalObject  self someObject collection remove: 10insertTemporary  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self parseTree whichNodeIsContainedBy: sourceInterval.  (tmp1 notNil and: [ tmp1 isValue ]) ifFalse: [ self refactoringFailure: 'Cannot assign to non-value nodes' ].  tmp4 := self parseTree body allChildren.  tmp3 := tmp4 select: [:arg1 |  arg1 = tmp1 ] thenCollect: [:arg1 |  arg1 ].  tmp2 := tmp1 statementNode.  tmp3 do: [:arg1 |  arg1 replaceWith: (RBVariableNode named: newVariableName) ].  tmp2 parent     addNode: (self constructAssignmentFrom: tmp1) before: (tmp1 == tmp2 ifTrue: [ RBVariableNode named: newVariableName ] ifFalse: [ tmp2 ]);     addTemporaryNamed: newVariableNameremoveProtocolNamed: arg1  model removeProtocolNamed: arg1 in: selfchangeClassName  ^classNameselectorsForClass: arg1 do: arg2  | tmp1 |  tmp1 := IdentitySet new.  environment selectorsForClass: arg1 do: [:arg3 |  tmp1 add: arg3.        arg2 value: arg3 ].  orEnvironment selectorsForClass: arg1 do: [:arg3 |  (tmp1 includes: arg3) ifFalse: [ arg2 value: arg3 ] ]testRenameInstVarNotAccessors  | tmp1 tmp2 |  tmp1 := RBRenameInstanceVariableRefactoring rename: 'result' to: 'whatever' in: RBBasicLintRuleTestData renameAccessors: false.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBBasicLintRuleTestData.  self assert: (tmp2 directlyDefinesInstanceVariable: 'whatever').  self deny: (tmp2 directlyDefinesInstanceVariable: 'result').  self deny: (tmp2 definesMethod: #whatever).  self deny: (tmp2 definesMethod: #whatever:).  self assert: (tmp2 definesMethod: #result)collectSendersOfInstVar  | tmp1 tmp2 tmp3 |  tmp3 := false.  tmp1 := OrderedCollection new.  oldClass superclass instanceVariableNames do: [:arg1 |  arg1 = variableName ifTrue: [ tmp3 := true ] ].  tmp3 ifTrue: [ ^tmp1 ] ifFalse: [ tmp1 := (oldClass selectors select: [:arg1 |  (oldClass methodFor: arg1) source includesSubstring: variableName asString ] thenCollect: [:arg1 |  oldClass methodFor: arg1 ]) asOrderedCollection.        tmp2 := oldClass subclasses.        tmp2 do: [:arg2 |  arg2 selectors do: [:arg1 |  ((arg2 methodFor: arg1) source includesSubstring: ' ' , variableName asString , ' ') ifTrue: [ tmp1 add: (arg2 methodFor: arg1) ] ] ].        ^tmp1 ]isEmpty  ^categories isEmptyassociationIndex: arg1  selectedAssociationIndex := arg1.  self changed: #associationIndexshould: arg1 raise: arg2 whoseDescriptionDoesNotInclude: arg3 description: arg4  ^self assert: (self executeShould: arg1 inScopeOf: arg2 withDescriptionNotContaining: arg3) description: arg4preconditions  ^RBCondition emptyselectMethods: arg1  | tmp1 |  tmp1 := RBSelectorEnvironment onEnvironment: self.  self classesAndSelectorsDo: [:arg2 :arg3 |  (arg1 value: (arg2 compiledMethodAt: arg3)) ifTrue: [ tmp1 addClass: arg2 selector: arg3 ] ].  ^tmp1selectorsForClass: arg1  | tmp1 |  tmp1 := IdentitySet new.  self selectorsForClass: arg1 do: [:arg2 |  tmp1 add: arg2 ].  ^tmp1denyCollection: arg1 hasSameElements: arg2  self deny: ((arg1 difference: arg2) isEmpty and: [ (arg2 difference: arg1) isEmpty ]) description: 'Given collections match!'includesProtocol: arg1 in: arg2  ^(super includesProtocol: arg1 in: arg2) and: [ environmentDictionaries anySatisfy: [:arg3 |  arg3 includesProtocol: arg1 in: arg2 ] ]referencesConditionFor: arg1  | tmp1 tmp2 |  ^(RBCondition withBlock: [ tmp2 := Smalltalk globals associationAt: arg1 name ifAbsent: [ self refactoringError: 'Could not find class' ].        tmp1 := (self environment referencesTo: tmp2) | (self environment referencesTo: arg1 name).        tmp1 isEmpty ])     errorMacro: arg1 , ' is referenced.<n>Browse references?';     errorBlock: [ tmp1 openEditor ];     yourselfcomment: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  comment := arg1selectionIntervalFor: arg1  ^(environment selectionIntervalFor: arg1) ifNil: [ orEnvironment selectionIntervalFor: arg1 ]= arg1  super = arg1 ifFalse: [ ^false ].  ^selector = arg1 selectorclassesAndTraitsDo: arg1  self allClassesAndTraitsDo: [:arg2 |  (self includesClass: arg2) ifTrue: [ arg1 value: arg2 ] ]testRedefinedTemporary  | tmp1 |  tmp1 := model classNamed: #Foo.  tmp1 compile: 'someMethod | instVarName1 | instVarName1 := 4. ^instVarName1' classified: #(#accessing).  self shouldFail: (RBTemporaryToInstanceVariableRefactoring class: tmp1 selector: #someMethod variable: 'instVarName1')addInstanceVariables  instanceVariables do: [:arg1 |  self performComponentRefactoring: (RBAddInstanceVariableRefactoring model: self model variable: arg1 class: newClass) ]asUndoOperation  self copy     category: self changeClass category;     yourselfprintOn: arg1  arg1     nextPutAll: self oldName;     nextPutAll: ' rename: ';     print: self newName;     nextPut: $!refersToClass  ^RBRefactoryTestDataAppclass: arg1 protocol: arg2 source: arg3  self changeClass: arg1.  self protocols: arg2.  source := arg3extractReceiver  | tmp1 |  (cascadeNode receiver isLiteralNode or: [ cascadeNode receiver isVariable ]) ifTrue: [ ^self ].  tmp1 := self safeVariableNameFor: class temporaries: self parseTree allDefinedVariables basedOn: 'receiver'.  ancestorNode parent     addTemporaryNamed: tmp1;     addNode: (RBAssignmentNode variable: (RBVariableNode named: tmp1) value: cascadeNode receiver) before: ancestorNode.  cascadeNode messages do: [:arg1 |  arg1 receiver: (RBVariableNode named: tmp1) ]changeClass: arg1  super changeClass: arg1.  isMeta := falsepreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'Class named ' , className , ' does not exist') & (RBCondition withBlock: [ ((model environment protocolsFor: self definingClass realClass) includes: protocol) not ] errorString: 'Protocol named ' , protocol , ' already exists')shouldRemoveExtensions  ^shouldRemoveExtensionsrename: arg1 to: arg2 in: arg3 renameAccessors: arg4  self variable: arg1 class: arg3.  newName := arg2.  renameAccessors := arg4pushDown: arg1 from: arg2  self setOption: #selectorsFromView toUse: [:arg3 |   ].  class := self classObjectFor: arg2.  selectors := arg1comparingStringBetween: arg1 and: arg2  ^String streamContents: [:arg3 |  arg3           nextPutAll: 'Got ';           nextPutAll: arg1 fullPrintString;           nextPutAll: ' instead of ';           nextPutAll: arg2 fullPrintString;           nextPutAll: '.' ]changeClass: arg1  super changeClass: arg1.  isMeta := falsepreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ | tmp1 |              tmp1 := self parserClass parseExpression: message.              tmp1 allVariables allSatisfy: [:arg1 |  (self definingMethod hasArgumentNamed: arg1 name) or: [ self definingMethod hasTemporaryNamed: arg1 name ] ] ] errorString: ('Some variables in this message send are not defined in method named <1s>.' expandMacrosWith: selector))theNonMetaClass  ^model classNamed: self nametestModelRemoveInstanceVariable  | tmp1 |  model defineClass: 'nil subclass: #Object instanceVariableNames: ''foo1'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  tmp1 := model classNamed: #Object.  self assert: (tmp1 definesInstanceVariable: 'foo1').  self executeRefactoring: (RBRemoveInstanceVariableRefactoring model: model variable: 'foo1' class: tmp1).  self deny: (tmp1 definesInstanceVariable: 'foo1')removeReturns  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1 replace: '^``@object' with: '``@object'.  (tmp1 executeTree: inlineParseTree) ifTrue: [ inlineParseTree := tmp1 tree ]checkClass: arg1  rules do: [:arg2 |  arg2 checkClass: arg1.        Processor yield ]listToFindMatches: arg1  listToFindMatches := arg1hierarchyDefinesInstanceVariable: arg1  (self definesInstanceVariable: arg1) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:arg2 |  arg2 directlyDefinesInstanceVariable: arg1 ]removeClass: arg1  environmentDictionaries keysDo: [:arg2 |  (environmentDictionaries at: arg2) removeClass: arg1 ]equivalentSuperclassMethods  ^self identityHashuniversalTestFor: arg1  self equalityTestFor: arg1.  self stringTestFor: arg1.  (arg1 isKindOf: RBRefactoryClassChange) ifTrue: [ self undoTestFor: arg1 ]execute  self primitiveExecute.  RBRefactoryChangeManager instance     performChange: self changes;     addUndoPointer: 1newModel  ^(RBNamespace2 onEnvironment: self defaultEnvironment)     name: self printString;     yourselfprimitiveExecute  self checkPreconditions.  self transformmessagesNotReplaced  ^numberNotReplacedtestNonExistantName  self     shouldFail: (RBAddVariableAccessorTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBAddVariableAccessorTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoringhasUndoableOperations  ^undo isNotEmptytestMethod1  ^self testMethod1 , ([:arg1 |  arg1 testMethod1 ] value: #(#(#testMethod1) 2 #testMethod1))createMockClass  self class compiler evaluate: 'Object subclass: #RBRefactoringChangeMock	instanceVariableNames: ''instVar''	classVariableNames: ''ClassVar''	poolDictionaries: ''''	category: ''Refactoring-Tests-Changes'''.  self class compiler evaluate: 'RBRefactoringChangeMock class	instanceVariableNames: ''classInstVar'''.  self changeMock compile: 'one ^ 1' classified: 'accessing'refersToSymbol: arg1  | tmp1 |  tmp1 := self parserTreeSearcher.  tmp1     matches: arg1 printString do: [:arg2 :arg3 |  true ];     matches: '`#literal' do: [:arg2 :arg3 |  arg3 or: [ self literal: arg2 value containsReferenceTo: arg1 ] ].  (RBScanner isSelector: arg1) ifTrue: [ tmp1 matches: '`@object ' , (self parseTreeSearcherClass buildSelectorString: arg1) do: [:arg2 :arg3 |  true ] ].  ^tmp1 executeTree: self parseTree initialAnswer: falsetestRedefineClassChange  | tmp1 |  tmp1 := modelFactory rbNamespace new.  tmp1 defineClass: 'nil subclass: #Object				instanceVariableNames: ''a''				classVariableNames: ''A''				poolDictionaries: ''TextConstants''				category: #''Refactory-Testing'''.  self assert: (tmp1 includesClassNamed: #Object).  self assert: (tmp1 classNamed: #Object) notNiltestRefactoring  | tmp1 tmp2 tmp3 |  tmp1 := (RBMoveInstanceVariableToClassTransformation model: model variable: 'methodBlock' fromClass: #RBBasicLintRuleTestData toClass: #RBFooLintRuleTestData) asRefactoring.  tmp2 := tmp1 model classNamed: #RBBasicLintRuleTestData.  tmp3 := tmp1 model classNamed: #RBFooLintRuleTestData.  self assert: (tmp2 directlyDefinesInstanceVariable: 'methodBlock').  self deny: (tmp3 directlyDefinesInstanceVariable: 'methodBlock').  [ tmp1 transform ] on: RBRefactoringError do: [:arg1 |  arg1 resume ].  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: #RBBasicLintRuleTestData.  tmp3 := tmp1 model classNamed: #RBFooLintRuleTestData.  self deny: (tmp2 directlyDefinesInstanceVariable: 'methodBlock').  self assert: (tmp3 directlyDefinesInstanceVariable: 'methodBlock')arguments: arg1  arguments := arg1.  self changed: #argumentsremoveMethod  self onError: [ self performComponentRefactoring: (RBRemoveMethodRefactoring model: self model removeMethods: (Array with: selector) from: class) ] do: [  ]superClass: arg1  (arg1 allSubclasses includes: class realClass) ifFalse: [ self refactoringError: ('<1s> is not a superclass of <2p>' expandMacrosWith: arg1 with: class name) ].  targetSuperclass := self classObjectFor: arg1className  ^className ifNil: [ UIManager default chooseOrRequestFrom: (self environment allClasses collect: #name) title: 'Class name was not defined to perform ' , self class baseClass name , '. Please select a class to resume this transformation.' ]systemDictionary  ^Smalltalk globalsstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' protocol: ''';     nextPutAll: protocol;     nextPutAll: ''' inClass: ''';     nextPutAll: className.  arg1 nextPut: $)testNonExistantName  self shouldFail: (RBAbstractInstanceVariableRefactoring variable: 'foo' class: RBBasicLintRuleTestData)asOrderedCollectionNotNeeded  self foo addAll: (1 to: 10) asOrderedCollectionproblemCount  ^result problemCountcreateMockClass  self class compiler evaluate: 'Object subclass: #RBRefactoringChangeMock	instanceVariableNames: ''instVar''	classVariableNames: ''ClassVar''	poolDictionaries: ''''	category: ''Refactoring-Tests-Changes'''.  self class compiler evaluate: 'RBRefactoringChangeMock class	instanceVariableNames: ''classInstVar'''.  self changeMock compile: 'one ^ 1' classified: 'accessing'preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ (self definingMethod allChildren select: #isVariable thenCollect: #name) anySatisfy: [:arg1 |  arg1 asString = variableName ] ] errorString: ('Method named <1s> does not have an assignment for variable named <2s>' expandMacrosWith: selector with: variableName)) & (RBCondition withBlock: [ (self definingMethod allChildren select: #isAssignment thenCollect: #variable) anySatisfy: [:arg1 |  arg1 name asString = variableName ] ] errorString: ('Method named <1s> does not have an assignment for variable named <2s>' expandMacrosWith: selector with: variableName))calls  ^self rewriteRule10: self name , self rewriteRule10precedence  ^self isArray ifFalse: [ (self block + 5) * 34 ] ifTrue: [ self printString = 10 ]assignmentWithoutEffect  | tmp1 |  tmp1 := 1.  tmp1 := tmp1removeProtocolNamed: arg1 in: arg2  ^changes removeProtocolNamed: arg1 in: arg2smallLintCritics  ^self allClassesrun  ^Object printOn: selfassertEmpty: arg1  ^self assert: arg1 isEmpty description: arg1 asString , ' should have been empty'assert: arg1 identicalTo: arg2  ^self assert: arg2 == arg1 description: [ self comparingIdentityStringBetween: arg1 and: arg2 ]refactoringError: arg1  ^RBRefactoringError signal: arg1checkSelfReturns  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1     matches: '^self' do: [:arg1 :arg2 |  arg2 ];     matches: '^`@anything' do: [:arg1 :arg2 |  true ].  (tmp1 executeTree: extractedParseTree initialAnswer: false) ifTrue: [ self placeholderNode asReturn ]shouldnt: arg1 description: arg2  self deny: arg1 value description: arg2testExistingInstanceVariableAccessors  | tmp1 |  tmp1 := (RBAddVariableAccessorTransformation instanceVariable: 'name' class: #RBDummyLintRuleTest) asRefactoring transform.  self assertEmpty: tmp1 changes changesclassNamesWithVariables  | tmp1 |  tmp1 := Set new.  tmp1     addAll: instanceVariables keys;     addAll: instanceVariableReaders keys;     addAll: instanceVariableWriters keys;     addAll: classVariables keys.  ^tmp1classVariableNames  ^self privateClassVariableNames copyprivatePoolDictionaryNames  (self isDefined and: [ poolDictionaryNames isNil ]) ifTrue: [ self poolDictionaryNames: (self realClass sharedPools collect: [:arg1 |  self realClass environment keyAtValue: arg1 ]) ].  ^poolDictionaryNamesleftFailed  ^left errorStringFor: falsevariable: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  variableName := arg1testMetaClassFailure  self shouldFail: (RBRenameClassTransformation rename: self class class to: #Foo) asRefactoringisEmpty  self subclassResponsibilitydemoMethodWithDuplicates  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := 3.  tmp2 := tmp1 + 5.  tmp3 := tmp1 + tmp2.  tmp4 := tmp1 + 5.  tmp5 := tmp3 + tmp4 + (tmp1 + 5).  ^tmp5testAbstractInstanceVariable  | tmp1 tmp2 |  tmp1 := RBAbstractInstanceVariableRefactoring variable: 'class' class: RBTransformationRuleTestData.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (tmp2 parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject	class := anObject').  self assert: (tmp2 parseTreeFor: #superSends) equals: (self parseMethod: 'superSends	| rule |	rule := RBParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args'' 				-> (					[:aNode | 					(self class1 withAllSubclasses 						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil] 							-> ''self `@message: ``@args'').	self rewriteUsing: rule').  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 	self class: aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) 				ifFalse: 					[builder 						compile: rewriteRule tree printString						in: self class1						classified: aSmalllintContext protocols]]')isMovingToInstVar  ^self isMovingToArgument not and: [ (class whoDefinesInstanceVariable: variable) notNil ]testParseTreeTypes  | tmp1 tmp2 |  tmp2 := RBClassModelFactory rbNamespace new.  tmp1 := RBRefactoryTyper typesFor: 'foo' in: (self parseExpression: 'foo printString; testBasicLintRuleTypes; testParseTreeTypes') model: tmp2.  self assert: tmp1 size equals: 1.  self assert: (tmp1 includes: (tmp2 classFor: self class))selectionParseTreeIntervalFor: arg1  | tmp1 tmp2 |  tmp1 := RBParser parseMethod: arg1 onError: [:arg2 :arg3 |  ^nil ].  tmp2 := [:arg4 :arg5 |  ^arg4 sourceInterval ].  self searchStrings do: [:arg6 |  | tmp3 tmp4 |        tmp3 := RBParseTreeSearcher new.        tmp3 matchesTree: (RBLiteralNode value: arg6) do: tmp2.        arg6 isSymbol ifTrue: [ tmp4 := RBParseTreeSearcher buildSelectorTree: arg6.              tmp4 ifNotNil: [ tmp3 matchesTree: tmp4 do: tmp2 ] ] ifFalse: [ tmp4 := RBVariableNode named: arg6.              tmp3                 matchesTree: tmp4 do: tmp2;                 matchesArgumentTree: tmp4 do: tmp2 ].        tmp3 executeTree: tmp1 ].  ^nilsource: arg1  source := arg1inlineTemporary  | tmp1 |  self isNil ifTrue: [ tmp1 := 4 ].  ^tmp1resetResult  swapMethod: arg1 in: arg2  class := self classObjectFor: arg2.  target := self classObjectFor: (class isMeta ifTrue: [ class instanceSide ] ifFalse: [ class classSide ]).  selector := arg1initialize  model := RBClassModelFactory rbNamespace new.  class := model classFor: Object.  variableTypes := Dictionary new.  variableMessages := Dictionary new.  selectorLookup := IdentityDictionary new.  bestGuesses := Dictionary new= arg1  ^self class = arg1 class and: [ self definition = arg1 definition ]parseTreeSearcherClass  ^RBParseTreeSearchersmallLintCritics  ^self classescheckClass: arg1  rules do: [:arg2 |  arg2 checkClass: arg1.        Processor yield ]allReferencesToClass: arg1 do: arg2  self allClassesDo: [:arg3 |  (arg3 whichSelectorsReferToClass: arg1) do: [:arg4 |  arg2 value: (arg3 methodFor: arg4) ].        (arg3 classSide whichSelectorsReferToClass: arg1) do: [:arg4 |  arg2 value: (arg3 classSide methodFor: arg4) ] ]parseTreeRewriter  | tmp1 tmp2 tmp3 |  tmp1 := RBParseTreeRewriter new.  tmp2 := self buildSelectorString: oldSelector.  tmp3 := self newSelectorString.  tmp1 replace: '``@object ' , tmp2 with: '``@object ' , tmp3.  ^tmp1searchingLiteral  ^self printString = #a or: [ #() = self printString | (#() == self printString) ]testMethodDoesNotExist  self shouldFail: (RBAddReturnStatementTransformation return: '^ variable' inMethod: #method inClass: #RBAddReturnStatementTransformationTest) asRefactoringincludesCategory: arg1  ^(environment includesCategory: arg1) and: [ (self classNamesFor: arg1) notEmpty ]instVarReadersTo: arg1 in: arg2  ^RBVariableEnvironment on: self readersOfInstanceVariable: arg1 in: arg2name  ^renrakuRule namecalled: arg1 on1: arg2  | tmp1 |  tmp1 := arg1 printString.  Transcript     show: tmp1;     cr.  arg2 value: tmp1includesClass: arg1  ^(self privateSelectorsForClass: arg1) isNotEmpty and: [ super includesClass: arg1 ]unaryAccessingMethodWithReturn  ^selftestModelNonExistantName  | tmp1 |  (model classNamed: #RBLintRuleTestData) removeMethod: #name.  tmp1 := RBAddParameterRefactoring model: model addParameterToMethod: #name in: RBLintRuleTestData newSelector: #nameNew: initializer: 'nil'.  self shouldFail: tmp1testNonExistantSelector  self shouldFail: (RBExtractToTemporaryRefactoring extract: (14 to: 23) to: 'asdf' from: #checkClass1: in: RBRefactoryTestDataApp)preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ self definingMethod lastIsReturn ] errorString: ('Method named <1s> does not have a return statement' expandMacrosWith: selector))preconditions  self subclassResponsibilityincludesMethod: arg1  ^self includesSelector: arg1 selector in: arg1 methodClassstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' pragma: ''';     nextPutAll: pragma;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)detectContains  ^(1 to: 10) do: [:arg1 |  arg1 > 2 ifTrue: [ ^arg1 ] ]preconditions  ^RBCondition withBlock: [ (class hierarchyDefinesInstanceVariable: variableName) ifTrue: [ self refactoringError: 'Already defined in hierarchy' ].        true ]testPackageEnvironment  | tmp1 |  tmp1 := universalEnvironment forPackageNames: (Array with: 'Refactoring-Tests-Environment' with: 'Refactoring-Tests-Critics').  self universalTestFor: tmp1.  self assert: (tmp1 implementorsOf: #testPackageEnvironment) numberSelectors equals: 1refersToVariable: arg1  | tmp1 tmp2 |  tmp2 := self parseTree.  ((tmp2 defines: arg1) or: [ tmp2 body defines: arg1 ]) ifTrue: [ ^false ].  tmp1 := self parserTreeSearcher.  tmp1     matches: arg1 do: [:arg2 :arg3 |  true ];     matches: '[:`@vars | | `@temps | `@.Stmts]' do: [:arg2 :arg3 |  arg3 or: [ ((arg2 defines: arg1) or: [ arg2 body defines: arg1 ]) not and: [ tmp1 executeTree: arg2 body initialAnswer: false ] ] ].  ^tmp1 executeTree: self parseTree initialAnswer: falseshouldOverride: arg1 in: arg2  ^(self options at: #alreadyDefined) value: self value: arg2 value: arg1postCopy  super postCopy.  categories := categories copytestModelBadInitializationCode  | tmp1 |  model removeClassNamed: #RBRefactoring.  tmp1 := RBAddParameterRefactoring model: model addParameterToMethod: #name1 in: RBLintRuleTestData newSelector: #name1: initializer: 'AddParameterRefactoring new'.  self shouldFail: tmp1printOn: arg1  class printOn: arg1.  arg1     nextPutAll: '>>';     nextPutAll: self selectorrename: arg1 to: arg2 in: arg3  self rename: arg1 to: arg2 in: arg3 renameAccessors: falseparseTree  ^parseTree ifNil: [ parseTree := self buildParseTree ] ifNotNil: [ parseTree ]transform  class allSubclasses do: [:arg1 |  (arg1 directlyDefinesInstanceVariable: variableName) ifTrue: [ arg1 removeInstanceVariable: variableName ] ].  class addInstanceVariable: variableNameisMethodEquivalentTo: arg1  selector == arg1 ifTrue: [ ^false ].  arg1 numArgs ~~ parameters size ifTrue: [ ^false ].  (self isParseTreeEquivalentTo: arg1) ifFalse: [ ^false ].  self reorderParametersToMatch: arg1.  ^trueclassesDo: arg1  environment classesDo: [:arg2 |  (self includesClass: arg2) ifTrue: [ arg1 value: arg2 ] ]defaultLabel  ^'Smalltalk'renameReferences  | tmp1 |  tmp1 := (RBParseTreeRewriter replaceLiteral: className with: newName)     replace: className with: newName;     replaceArgument: newName withValueFrom: [:arg1 |  self refactoringFailure: newName , ' already exists within the reference scope' ];     yourself.  self model allReferencesToClass: deprecatedClass do: [:arg2 |  (arg2 modelClass hierarchyDefinesVariable: newName) ifTrue: [ self refactoringFailure: newName , ' is already defined in hierarchy of ' , arg2 modelClass printString ].        self convertMethod: arg2 selector for: arg2 modelClass using: tmp1 ]searchStrings  ^searchStrings ifNil: [ #() ] ifNotNil: [ searchStrings ]testPerformAddRemoveInstanceVariable  | tmp1 |  tmp1 := changes addInstanceVariable: 'foo' to: self changeMock.  self perform: tmp1 do: [ self assert: (tmp1 changeClass instVarNames includes: 'foo') ].  self deny: (tmp1 changeClass instVarNames includes: 'foo')testAddParameterForTwoArgumentMessage  | tmp1 tmp2 |  tmp1 := RBAddParameterRefactoring addParameterToMethod: ('called:' , 'on:') asSymbol in: RBRefactoryTestDataApp newSelector: #called:bar:on: initializer: '#(1.0)'.  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #called:bar:on:) equals: (self parseMethod: 'called: anObject bar: aBlock on: anObject1							Transcript								show: anObject printString;								cr.								aBlock value').  self assert: (tmp2 parseTreeFor: #caller) equals: (self parseMethod: 'caller							| anObject |							anObject := 5.							self 								called: anObject + 1								bar: [^anObject] on: #(1.0)').  self deny: (tmp2 directlyDefinesMethod: ('called:' , 'on:') asSymbol)testModelMetaclassAlreadyExistingName  (model metaclassNamed: #Foo) addInstanceVariable: 'instVarName1'.  self shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'instVarName1' class: (model classNamed: #Bar)) asRefactoringtestBrowserEnvironment  self universalTestFor: RBBrowserEnvironment newifTrueReturns  self isSymbol ifFalse: [ ^true ].  ^falsedeny: arg1 description: arg2  self assert: arg1 value not description: arg2testClassVariable  | tmp1 tmp2 |  tmp1 := (RBRemoveDirectAccessToVariableTransformation classVariable: 'UndoSize' class: #RBRefactoryChangeManager) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := (tmp1 model classNamed: #RBRefactoryChangeManager) theMetaClass.  self assert: (tmp2 parseTreeFor: #initialize) equals: (self parseMethod: 'initialize self nuke. self undoSize: 20').  self assert: (tmp2 theNonMetaClass parseTreeFor: #addUndo:) equals: (self parseMethod: 'addUndo: aRefactoringChange				undo push: aRefactoringChange.				undo size > self class undoSize					ifTrue: [ undo removeFirst ].				redo := OrderedCollection new')testMethod  ^self classtestCategoryEnvironment  | tmp1 |  self skip: 'Use RBPackageEnvironment instead.'.  tmp1 := RBCategoryEnvironment onEnvironment: RBBrowserEnvironment new categories: #(#'Kernel-Objects').  self universalTestFor: tmp1.  self assert: (tmp1 implementorsOf: #printString) numberSelectors equals: 1testModelExistingName  | tmp1 |  tmp1 := RBAddClassRefactoring model: model addClass: #Foo superclass: Object subclasses: #() category: #'Refactory-Testing'.  self shouldFail: tmp1toDoCollect  | tmp1 |  tmp1 := Array new: 10.  1 to: 10 do: [:arg1 |  tmp1 at: arg1 put: arg1 * arg1 ].  ^tmp1includesClass: arg1  ^environment includesClass: arg1createGetterAccessor  (self definingClass getterMethodFor: variableName) ifNil: [ self defineGetterMethod ]unaryNonAccessingMethodWithoutReturn  testMultipleSelectors  self shouldWarn: (RBRenameMethodRefactoring renameMethod: #checkClass: in: RBBasicLintRuleTestData to: #foo: permutation: (1 to: 1))transform  self combineMessages.  self compileCodeviewResults  rules do: [:arg1 |  arg1 viewResults ]testPerformAddRemoveMethodInteractively  | tmp1 |  tmp1 := changeFactory addMethodSource: 'method ^ 1' in: self changeMock classified: #utilities for: self.  self perform: tmp1 do: [ self assert: (self changeMock canUnderstand: #method) ].  self deny: (self changeMock canUnderstand: #method).  self assert: tmp1 definedSelector equals: #methodtestNonExistantName  self shouldFail: (RBRenameClassVariableRefactoring rename: #foo to: #newFoo in: RBBasicLintRuleTestData)anInstVar  ^anInstVarstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' addParameterToMethod: #';     nextPutAll: oldSelector;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' newSelector: #';     nextPutAll: newSelector;     nextPutAll: ' initializer: ''';     nextPutAll: initializer;     nextPutAll: ''')'preconditions  ^RBCondition emptyincludesPackage: arg1  ^self packages includes: arg1packages  | tmp1 |  tmp1 := Set new.  self classes do: [:arg1 |  arg1 packages do: [:arg2 |  self selectorsForClass: arg1 do: [:arg3 |  (arg2 includesSelector: arg3 ofClass: arg1) ifTrue: [ tmp1 add: arg2 ] ] ] ].  ^tmp1preconditions  class := self definingClass theNonMetaClass.  ^isClassVariable ifTrue: [ self preconditionsForClassVariable ] ifFalse: [ self preconditionsForInstanceVariable ]= arg1  self class = arg1 class ifFalse: [ ^false ].  ^className = arg1 changeClassName and: [ isMeta = arg1 isMeta ]processNode: arg1  (arg1 isVariable and: [ class instanceVariableNames includes: arg1 name ]) ifTrue: [ ^self merge: arg1 name ].  (arg1 isMessage and: [ arg1 receiver isSelf ]) ifTrue: [ ^self merge: arg1 selector ].  arg1 isAssignment ifTrue: [ self           processNode: arg1 value;           processNode: arg1 variable ].  (arg1 isMessage and: [ #(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) includes: arg1 selector ]) ifTrue: [ arg1 arguments do: [:arg2 |  arg2 isBlock ifTrue: [ arg2 body statements isEmpty ifFalse: [ self processNode: arg2 body statements last ] ] ] ]check  left check ifFalse: [ failed := #leftFailed.        ^false ].  right check ifFalse: [ failed := #rightFailed.        ^false ].  ^trueisVariableEnvironment  ^trueremoveOldAccessors  | tmp1 |  tmp1 := (class allSelectors select: [:arg1 |  arg1 = variableName asSymbol or: [ arg1 = (variableName , ':') asSymbol ] ] thenCollect: [:arg1 |  class methodFor: arg1 ]) asOrderedCollection.  tmp1 do: [:arg1 |  class removeMethod: arg1 selector ]parseTree  ^self parserClass parseMethod: self source onError: [:arg1 :arg2 |  ^nil ]checkOverridesSelectorInClass: arg1  arg1 ~= method origin ifTrue: [ ((self model classNamed: arg1 name asSymbol) directlyDefinesMethod: method selector) ifTrue: [ self refactoringError: ('<1p> overrides the method <2s>' expandMacrosWith: arg1 name with: method selector) ] ]changeString  ^String streamContents: [:arg1 |  arg1           nextPutAll: '[';           nextPutAll: self protocol;           nextPutAll: '] ';           nextPutAll: super changeString ]methodBlock: arg1  methodBlock := arg1rules  ^rulestestFoo: arg1  ^self class + arg1hasRedoableOperations  ^redo isNotEmptyfindGetterMethod  | tmp1 tmp2 |  tmp1 := self definingClass.  tmp2 := self parseTreeSearcherClass getterMethod: variableName.  ^self possibleGetterSelectors detect: [:arg1 |  (self checkClass: tmp1 selector: arg1 using: tmp2) notNil and: [ (tmp1 subclassRedefines: arg1) not ] ] ifNone: [ nil ]testRename  | tmp1 |  tmp1 := (RBRenameTemporaryVariableTransformation rename: #rules to: #asdf in: #RBLintRuleTestData selector: #openEditor) transform.  self assert: ((tmp1 model classNamed: #RBLintRuleTestData) parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor								| asdf |								asdf := self failedRules.								asdf isEmpty ifTrue: [^self].								asdf size == 1 ifTrue: [^asdf first viewResults]')rules: arg1  rules := arg1newName: arg1  newName := arg1testBadInitializationCode  self     shouldFail: (RBAddParameterRefactoring addParameterToMethod: #name in: RBLintRuleTestData newSelector: #name: initializer: 'foo:');     shouldFail: (RBAddParameterRefactoring addParameterToMethod: #name in: RBLintRuleTestData newSelector: #name: initializer: 'foo')instanceSide  ^selfpreconditions  ^(RBCondition isValidInstanceVariableName: variableName for: class) & (RBCondition hierarchyOf: class definesVariable: variableName) not & (RBCondition isGlobal: variableName in: self model) nottestRemoveReferenced  self shouldFail: (RBRemoveHierarchyMethodRefactoring removeMethods: #(#msg1) from: RBBasicLintRuleTestData)testNewExistingName  | tmp1 |  model := RBClassModelFactory rbNamespace new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  tmp1 := RBAddInstanceVariableRefactoring model: model variable: 'asdf' class: (model classNamed: #FOOBAR).  self shouldFail: tmp1selectedSource  ^self parseTree source copyFrom: selectedInterval first to: selectedInterval lastallClasses  | tmp1 |  tmp1 := IdentitySet new: 4096.  self classesDo: [:arg1 |  tmp1 add: arg1 instanceSide ].  ^tmp1 asArrayclassBinding  ^Smalltalk globals associationAt: self nameforClasses: arg1  | tmp1 |  tmp1 := OrderedCollection new: arg1 size * 2.  arg1 do: [:arg2 |  tmp1           add: arg2 instanceSide;           add: arg2 classSide ].  ^RBClassEnvironment onEnvironment: self classes: tmp1definesMethod: arg1  (self directlyDefinesMethod: arg1) ifTrue: [ ^true ].  ^self superclass notNil and: [ self superclass definesMethod: arg1 ]defineSetterMethod  | tmp1 tmp2 tmp3 |  tmp2 := self definingClass.  tmp3 := self needsReturnForSetter ifTrue: [ '<1s> anObject<r><t>^ <2s> := anObject' ] ifFalse: [ '<1s> anObject<r><t><2s> := anObject' ].  tmp1 := self safeMethodNameFor: tmp2 basedOn: variableName asString , ':'.  tmp2 compile: (tmp3 expandMacrosWith: tmp1 with: variableName) classified: #accessing.  ^tmp1whatToDisplayIn: arg1  ^{self}preconditionsForInstanceVariable  ^(RBCondition definesInstanceVariable: variableName asString in: class) & (RBCondition doesNotAccessInstanceVariable: variableName inHierarchyOf: class showIn: self)subclassResponsibilityFor: arg1 in: arg2  | tmp1 tmp2 tmp3 |  tmp3 := arg2 sourceCodeFor: arg1.  tmp1 := self parserClass parseMethod: tmp3 onError: [:arg3 :arg4 |  ^nil ].  tmp2 := tmp1 arguments isEmpty ifTrue: [ tmp1 keywordsIntervals last last ] ifFalse: [ tmp1 arguments last stop ].  ^'<1s><n><t>self subclassResponsibility' expandMacrosWith: (tmp3 copyFrom: 1 to: tmp2)resultClass: arg1  result := arg1 newmethodAfter  | tmp1 |  tmp1 := 'String'.  tmp1 := 1 asStringtextToDisplay  ^String streamContents: [:arg1 |  arg1           nextPutAll: '"protocol: ';           nextPutAll: self protocol;           nextPutAll: '"';           nextPutAll: String cr;           nextPutAll: super textToDisplay ]genericPatternForSelector: arg1  ^String streamContents: [:arg2 |  arg1 keywords keysAndValuesDo: [:arg3 :arg4 |  arg2                 space;                 nextPutAll: arg4.              arg1 last = $: ifTrue: [ arg2                       space;                       nextPutAll: '`@object';                       print: arg3 ] ] ]transform  class removeInstanceVariable: variableNameskipUnless: arg1  arg1 value ifFalse: [ TestSkip signal: 'Assumption in #skipUnless: failed' ]toDo  1 to: self size do: [:arg1 |  (self at: arg1) printString ]includesSelector: arg1 in: arg2  ^(environment includesSelector: arg1 in: arg2) and: [ andedEnvironment includesSelector: arg1 in: arg2 ]includesProtocol: arg1 in: arg2  ^(environment includesProtocol: arg1 in: arg2) and: [ (self selectorsFor: arg1 in: arg2) notEmpty ]classNames: arg1  classNames := arg1class: arg1 selector: arg2 rename: arg3 to: arg4  self className: arg1.  selector := arg2.  variableName := arg3.  newVariableName := arg4testAddClassPattern  self exampleClasses do: [:arg1 |  (arg1 isObsolete or: [ arg1 superclass notNil and: [ arg1 superclass isObsolete ] ]) ifFalse: [ | tmp1 |              tmp1 := changes defineClass: arg1 oldDefinition.              self assert: (tmp1 isKindOf: RBAddClassChange).              self assert: tmp1 changeClassName equals: arg1 name.              arg1 superclass ifNil: [ self assert: tmp1 definitionClass equals: ProtoObject ] ifNotNil: [ self assert: tmp1 definitionClass equals: arg1 superclass ].              self assert: tmp1 instanceVariableNames equals: arg1 instVarNames asArray.              self assert: tmp1 classVariableNames equals: arg1 classVarNames asArray.              self assert: tmp1 sharedPoolNames equals: arg1 sharedPoolNames asArray.              self assert: tmp1 category equals: arg1 category.              self universalTestFor: tmp1 ] ]preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ (self definingMethod allChildren select: #isVariable thenCollect: #name) anySatisfy: [:arg1 |  arg1 asString = variableName ] ] errorString: ('Method named <1s> does not have a variable named <2s>' expandMacrosWith: selector with: variableName))nameToDisplay  ^self nameclassSelectorDictionary  ^classes inject: (IdentityDictionary new: classes size) into: [:arg1 :arg2 |  arg1           at: arg2 put: (self systemDictionary at: arg2) selectors;           yourself ]includesProtocol: arg1 in: arg2  ^(self includesClass: arg2) and: [ environment includesProtocol: arg1 in: arg2 ]sizeCheck  self isEmpty ifFalse: [ self do: [:arg1 |   ] ]checkClass: arg1  renrakuRule class checksClass ifFalse: [ ^self ].  renrakuRule check: arg1 forCritiquesDo: [:arg2 |  result addClass: arg1.        self addSearchStringFrom: arg2 in: arg1 definition.        ^self ]testTransform  | tmp1 tmp2 |  tmp1 := (RBRenameClassTransformation rename: 'RBDummyClassToRename' asSymbol to: 'RBNewDummyClassName' asSymbol) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: 'RBNewDummyClassName' asSymbol.  self assert: (tmp2 parseTreeFor: #method1) equals: (self parseMethod: 'method1 ^ self method2').  self deny: (tmp1 model includesClassNamed: 'RBDummyClassToRename' asSymbol).  tmp2 := tmp1 model classNamed: 'RBDummySubclassOfClassToRename' asSymbol.  self assert: tmp2 superclass equals: (tmp1 model classNamed: 'RBNewDummyClassName' asSymbol).  self assert: (tmp2 parseTreeFor: #symbolReference) equals: (self parseMethod: 'symbolReference ^ #RBNewDummyClassName').  self assert: (tmp2 parseTreeFor: #reference) equals: (self parseMethod: 'reference ^ RBNewDummyClassName new')merge: arg1  | tmp1 tmp2 |  tmp1 := backpointers at: methodName ifAbsent: [ nil ].  tmp2 := backpointers at: arg1 ifAbsent: [ nil ].  (tmp1 isNil or: [ tmp2 isNil or: [ tmp1 == tmp2 ] ]) ifTrue: [ ^self ].  tmp1 addAll: tmp2.  tmp2 do: [:arg2 |  backpointers at: arg2 put: tmp1 ]parseTreeRewriterClass  ^RBParseTreeRewritertestPerformAddRemoveClassInstanceVariable  | tmp1 |  tmp1 := changes addInstanceVariable: 'foo' to: self changeMock class.  self perform: tmp1 do: [ self assert: (tmp1 changeClass instVarNames includes: 'foo') ].  self deny: (tmp1 changeClass instVarNames includes: 'foo')includesProtocol: arg1 in: arg2  ^(super includesProtocol: arg1 in: arg2) and: [ (environment selectorsFor: arg1 in: arg2) anySatisfy: [:arg3 |  self privateIncludesSelector: arg3 inClass: arg2 ] ]transform  class renameClassVariable: variableName to: newName around: [ self renameReferences ]sourceCode  ^self selectedClass sourceCodeAt: self selector ifAbsent: [ '' ]missingYourself  ^OrderedCollection new     add: 1;     add: 2;     removeFirstrename: arg1 name: arg2  ^RBRenameClassRefactoring model: self model rename: arg1 to: arg2cruft  < haltOrBreakpointForTesting>  self haltremoveClassVariable: arg1 from: arg2  ^changes removeClassVariable: arg1 from: arg2initializeWith: arg1 and: arg2 in: arg3  arguments := arg1.  values := arg2.  tree := arg3.  argsAndValues := Dictionary new.  self initialize.  self title: 'There are extra arguments in this method. Please map a value to each extra argument.' translatedreturnsBooleanAndOther  self isVariable ifTrue: [ ^false ].  self printStringatIfAbsent  ^Smalltalk at: #MyTest ifAbsent: [ | tmp1 |        tmp1 := #().        Smalltalk at: #MyTest put: tmp1 ]inlineSourceReplacing: arg1  | tmp1 tmp2 |  tmp1 := inlineParseTree body statements.  (tmp1 size > 1 and: [ arg1 isEvaluatedFirst not ]) ifTrue: [ self refactoringWarning: 'To inline this method, we need to move some of its statements before the original message send.<n>This could change the order of execution, which can change the behavior.<n>Do you want to proceed?' expandMacros ].  tmp2 := arg1.  [ tmp2 parent isSequence ] whileFalse: [ tmp2 := tmp2 parent ].  tmp2 parent     addNodes: (tmp1 copyFrom: 1 to: (tmp1 size - 1 max: 0)) before: tmp2;     addTemporariesNamed: inlineParseTree body temporaryNames.  arg1 parent replaceNode: arg1 withNode: (tmp1 isEmpty ifTrue: [ RBVariableNode named: 'self' ] ifFalse: [ tmp1 last ])testComment  | tmp1 |  tmp1 := changes comment: 'Some Comment' in: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 comment equals: 'Some Comment'.  self universalTestFor: tmp1testNotUnderstandNewSelector  self shouldFail: (RBReplaceMethodRefactoring replaceCallMethod: #checkClass: in: RBBasicLintRuleTestData to: #checkMethod23: permutation: (1 to: 1))testDefinesInstanceVariable  self deny: (objectClass definesInstanceVariable: 'instanceVariable1').  self assert: (newClass definesInstanceVariable: 'instanceVariable1').  self deny: (messageNodeClass definesInstanceVariable: 'instanceVariable1').  self assert: (messageNodeClass definesInstanceVariable: 'parent').  self assert: (messageNodeClass definesInstanceVariable: 'selector')checkMethodForBlocks  | tmp1 |  tmp1 := self definingBlock.  self checkBlocksIn: tmp1.  self checkLocationsIn: (self checkAllBlocksIn: tmp1)createMethodSearchWith: arg1 selectors: arg2 inClass: arg3  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matchesAnyMethodOf: (Array with: arg1) do: [:arg4 :arg5 |  arg5           remove: self currentSelector ifAbsent: [ self error: 'failed' ];           yourself ].  tmp1 answer: arg2 asBag.  (classSearches at: arg3 ifAbsentPut: [ Set new ]) add: tmp1defaultLabel  | tmp1 |  tmp1 := String new writeStream.  categories do: [:arg1 |  tmp1           nextPutAll: arg1;           nextPut: $  ].  ^tmp1 contentstraitsDo: arg1  self systemDictionary allTraitsDo: [:arg2 |  (self includesClass: arg2) ifTrue: [ arg1 value: arg2 ] ]shouldntWarn: arg1  self shouldnt: [ self executeRefactoring: arg1 ] raise: RBRefactoringWarningallMetaClasses  | tmp1 |  tmp1 := OrderedCollection new: 4096.  self classesDo: [:arg1 |  arg1 isMeta ifTrue: [ tmp1 add: arg1 instanceSide ] ].  ^tmp1 asArraysuperclass  ^superclass == LookupSuperclass ifTrue: [ model classFor: self realClass superclass ] ifFalse: [ superclass ]isEmpty  ^builder changes isEmptywithoutClasses: arg1  ^RBClassEnvironment onEnvironment: self classes: (self classes copyWithoutAll: arg1)buildMethodTitleSearch  self createMethodSearchWith: 'initialize | `@temps | `@.Stmts' selectors: #(#initialize) inClass: RBBasicLintRuleTestDatatestRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  tmp1 := (RBRenameTemporaryVariableTransformation model: tmp1 model rename: #temp to: #temp2 in: self changeMock name selector: #foo) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: self changeMock name.  self assert: (tmp2 directlyDefinesMethod: #foo).  self assert: (tmp2 parseTreeFor: #foo) temporaries size equals: 2.  self assert: ((tmp2 parseTreeFor: #foo) temporaries anySatisfy: [:arg1 |  arg1 name = #temp2 ])skip: arg1  TestSkip signal: arg1label  ^label ifNil: [ self defaultLabel ] ifNotNil: [ label ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' messageSend: ''';     nextPutAll: message asString;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)extractMethod  | tmp1 |  tmp1 := RBExtractMethodRefactoring model: self model extract: extractionInterval from: selector in: class.  tmp1 setOption: #methodName toUse: [:arg1 :arg2 |  extractedMethodSelector := arg1 uniqueMethodNameFor: arg2 arguments size.        arg2           selector: extractedMethodSelector;           yourself ].  self performComponentRefactoring: tmp1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' rename: ''';     nextPutAll: variableName;     nextPutAll: ''' to: ''';     nextPutAll: newName;     nextPutAll: ''' in: '.  class storeOn: arg1.  arg1 nextPut: $)fullBlocks  ^[ thisContext ]whichSelectorsReferToClass: arg1  | tmp1 |  tmp1 := Set new.  newMethods ifNotNil: [ newMethods do: [:arg2 |  (arg2 refersToClassNamed: arg1 name) ifTrue: [ tmp1 add: arg2 selector ] ] ].  (self isDefined and: [ arg1 isDefined ]) ifTrue: [ tmp1 addAll: (self existingMethodsThatReferTo: arg1 classBinding).        tmp1 addAll: (self existingMethodsThatReferTo: arg1 name) ].  ^tmp1directlyDefinesPoolDictionary: arg1  ^self instanceSide directlyDefinesPoolDictionary: arg1primitiveExecute  self changeClass category: category.  SystemAnnouncer uniqueInstance classReorganized: self changeClasstestNonExistantName  self shouldFail: (RBRemoveClassVariableRefactoring variable: #RecursiveSelfRule1 class: RBTransformationRuleTestData)testModelPushDownVariableToMultipleClassesInSameHierarchy  | tmp1 |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  tmp1 := model classNamed: #Subclass.  tmp1 compile: 'foo ^Foo' classified: #(#accessing).  model defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo' classified: #(#accessing).  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: tmp1 superclass).  self deny: (tmp1 superclass directlyDefinesClassVariable: #Foo).  self assert: (tmp1 directlyDefinesClassVariable: #Foo)testRemoveMethod  | tmp1 tmp2 |  tmp2 := Array with: 'msg4' asSymbol.  tmp1 := RBRemoveHierarchyMethodRefactoring removeMethods: tmp2 from: RBSharedPoolForTestData.  self assert: ((tmp1 model classNamed: #RBSharedPoolForTestData) directlyDefinesMethod: tmp2 first).  self assert: ((tmp1 model classNamed: #RBSharedPoolForTestData1) directlyDefinesMethod: tmp2 first).  self assert: ((tmp1 model classNamed: #RBSharedPoolForTestData2) directlyDefinesMethod: tmp2 first).  self executeRefactoring: tmp1.  self deny: ((tmp1 model classNamed: #RBSharedPoolForTestData) directlyDefinesMethod: tmp2 first).  self deny: ((tmp1 model classNamed: #RBSharedPoolForTestData1) directlyDefinesMethod: tmp2 first).  self deny: ((tmp1 model classNamed: #RBSharedPoolForTestData2) directlyDefinesMethod: tmp2 first)resetResult  rules do: [:arg1 |  arg1 resetResult ]testProtocolEnvironment  | tmp1 tmp2 |  tmp1 := RBProtocolEnvironment onEnvironment: RBBrowserEnvironment new class: Object protocols: #(#printing #testing).  self universalTestFor: tmp1.  self assert: (tmp1 implementorsOf: #printString) numberSelectors equals: 1.  tmp2 := 0.  tmp1 classesDo: [:arg1 |  tmp2 := tmp2 + 1 ].  self assert: tmp2 equals: 1.  tmp1 selectorsForClass: Object do: [:arg1 |  self assert: (#(#printing #testing) includes: (RBBrowserEnvironment new whichProtocolIncludes: arg1 in: Object)) ]class: arg1 selector: arg2 variable: arg3  class := self classObjectFor: arg1.  selector := arg2.  temporaryVariableName := arg3checkReferencesToAnyOf: arg1  | tmp1 |  tmp1 := OrderedCollection new.  arg1 do: [:arg2 |  self model allReferencesTo: arg2 do: [:arg3 |  (arg1 includes: arg3 selector) ifFalse: [ tmp1 add: arg2 -> arg3 ] ] ].  tmp1 ifEmpty: [ ^self ].  ^self checkBrowseOccurrences: tmp1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' addClass: #';     nextPutAll: className;     nextPutAll: ' superclass: '.  superclass storeOn: arg1.  arg1 nextPutAll: ' subclasses: '.  subclasses asArray storeOn: arg1.  arg1 nextPutAll: ' category: '.  category storeOn: arg1.  arg1 nextPut: $)includesClass: arg1  ^truebackpointersDictionary  ^PluggableDictionary new     equalBlock: [:arg1 :arg2 |  arg1 class == arg2 class and: [ arg1 = arg2 ] ];     hashBlock: [:arg1 |  arg1 class identityHash bitXor: arg1 hash ];     yourselftempsReadBeforeWritten  | tmp1 |  self isVariable ifTrue: [ tmp1 := 4 ].  ^tmp1allClassesDo: arg1  | tmp1 tmp2 |  tmp1 := Set new.  tmp2 := [:arg2 |  | tmp3 |  tmp3 := self classForName: arg2.  tmp1 addAll: tmp3 withAllSubclasses ].  instanceVariables keysDo: tmp2.  instanceVariableReaders keysDo: tmp2.  instanceVariableWriters keysDo: tmp2.  classVariables keysDo: [:arg2 |  | tmp3 |        tmp3 := self classForName: arg2.        tmp3 notNil ifTrue: [ tmp1                 addAll: tmp3 withAllSubclasses;                 addAll: tmp3 class withAllSubclasses ] ].  tmp1 do: arg1toDoWithIncrement  | tmp1 |  tmp1 := 0.  1 to: 10 by: 2 do: [:arg1 |  tmp1 := tmp1 + 2 ].  ^tmp1addSelfReturn  inlineParseTree addSelfReturntestAlreadyExistingName  self shouldFail: (RBRenameClassVariableRefactoring rename: #RecursiveSelfRule to: self objectClassVariable in: RBTransformationRuleTestData)printOn: arg1  arg1     nextPutAll: self displayClassName;     nextPut: $ ;     nextPutAll: self changeSymbol;     nextPut: $ ;     print: self variable;     nextPut: $!storeStringFor: arg1  | tmp1 |  tmp1 := Smalltalk compiler evaluate: arg1 storeString.  self assert: tmp1 numberSelectors equals: arg1 numberSelectors.  self assert: (tmp1 not & arg1) numberSelectors equals: 0searchStrings: arg1  searchStrings := arg1testClassDoesNotExist  self shouldFail: (RBAddAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBAssignmentTransformationTest) asRefactoringcheckMethod: arg1  renrakuRule class checksNode ifTrue: [ ^self byNodeCheckMethod: arg1 ].  renrakuRule class checksMethod ifFalse: [ ^self ].  renrakuRule check: arg1 forCritiquesDo: [:arg2 |  result addMethod: arg1.        self addSearchStringFrom: arg2 in: arg1 definition.        ^self ]addInstanceVariable: arg1 to: arg2  ^RBAddInstanceVariableChange add: arg1 to: arg2myConditions  allClassesDo: arg1  | tmp1 tmp2 |  tmp1 := Set new.  tmp2 := [:arg2 |  tmp1 add: arg2 first name.  arg1     value: arg2 first;     value: arg2 last ].  newClasses do: tmp2.  changedClasses do: tmp2.  environment classesDo: [:arg2 |  arg2 isObsolete ifFalse: [ | tmp3 |              tmp3 := arg2 instanceSide.              ((tmp1 includes: tmp3 name) or: [ self hasRemoved: (self classNameFor: tmp3) ]) ifFalse: [ (tmp3 := self classFor: arg2) ifNotNil: [ tmp1 add: tmp3 name.                          arg1                             value: tmp3;                             value: tmp3 classSide ] ] ] ]addDependentSends  self     addDependent: #one;     addDependent: #tworemoveMethod: arg1  self newMethods removeKey: arg1 ifAbsent: [  ].  model removeMethod: arg1 from: self.  self removedMethods add: arg1parseTreeRewriter  | tmp1 tmp2 tmp3 |  tmp2 := self buildSelectorString: oldSelector.  tmp3 := self buildSelectorString: newSelector withPermuteMap: permutation.  tmp1 := self hasPermutedArguments ifTrue: [ RBParseTreeRewriter new ] ifFalse: [ RBParseTreeRewriter replaceLiteral: oldSelector with: newSelector ].  tmp1 replace: '``@object ' , tmp2 with: '``@object ' , tmp3.  ^tmp1findOcurrencesInClasses  listToFindMatches do: [:arg1 |  [ (self preconditionsOf: arg1) check.        self findOcurrencesIn: arg1 methods ] on: Exception do: [:arg2 |  arg2 messageText isEmptyOrNil ifFalse: [ UIManager default alert: arg2 messageText ] ] ]poolDictionaryNames  ^self privatePoolDictionaryNames copyjustSendsSuper: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self parseTreeSearcherClass justSendsSuper.  tmp2 := self definingClass parseTreeFor: arg1.  (tmp1 executeTree: tmp2 initialAnswer: false) ifFalse: [ ^false ].  tmp2 lastIsReturn ifTrue: [ ^true ].  tmp3 := self definingClass superclass whichClassIncludesSelector: arg1.  tmp3 ifNil: [ ^true ].  tmp2 := tmp3 parseTreeFor: arg1.  tmp1 := self parseTreeSearcherClass new.  tmp1 matches: '^``@object' do: [:arg2 :arg3 |  arg3           add: arg2 value;           yourself ].  tmp1 executeTree: tmp2 initialAnswer: Set new.  ^tmp1 answer allSatisfy: [:arg4 |  arg4 isVariable and: [ arg4 name = 'self' ] ]methodFor: arg1  ^self newMethods at: arg1 ifAbsent: [ | tmp1 tmp2 |        (self hasRemoved: arg1) ifTrue: [ ^nil ].        tmp2 := self realClass.        tmp2 ifNil: [ ^nil ].        tmp1 := tmp2 compiledMethodAt: arg1 ifAbsent: [ nil ].        tmp1 ifNil: [ nil ] ifNotNil: [ modelFactory rbMethod for: self fromMethod: tmp1 andSelector: arg1 ] ]testInlineMethod2  | tmp1 |  tmp1 := RBInlineMethodRefactoring inline: (40 to: 120) inMethod: #caller1 forClass: RBRefactoryTestDataApp.  self setupInlineExpressionFor: tmp1 toReturn: false.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #caller1) equals: (self parseMethod: 'caller1 								| anObject each1 anObject1 | 								anObject := 5.								anObject1 := anObject + 1.								each1 := anObject1 printString.								Transcript									show: each1;									cr.								[:each | each printString. ^anObject] value: each1')selector: arg1 in: arg2 classified: arg3  self flag: #todo.  ^self addChange: (RBMethodProtocolChange selector: arg1 in: arg2 classified: arg3)name  ^nameaddSuperclass  self performComponentRefactoring: (RBAddClassRefactoring model: self model addClass: className superclass: parent superclass subclasses: (Array with: parent) category: parent category)unclassifiedMethods  contains  ^((1 to: 10) detect: [:arg1 |  arg1 > 2 ] ifNone: [ nil ]) isNiltestTransform  | tmp1 tmp2 tmp3 |  tmp1 := (RBAddClassTransformation addClass: self changeMock name , 'Temporary' superclass: #Object subclasses: OrderedCollection new category: self class category) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: (self changeMock name , 'Temporary') asSymbol.  tmp3 := tmp1 model classNamed: #Object.  self assert: tmp2 superclass equals: tmp3.  self assert: (tmp3 subclasses includes: tmp2).  self assert: tmp2 theMetaClass superclass equals: tmp3 theMetaClass.  self assert: (tmp3 theMetaClass subclasses includes: tmp2 theMetaClass)testNotUnderstandSelector  self shouldFail: (RBReplaceMethodRefactoring replaceCallMethod: #checkClass123: in: RBBasicLintRuleTestData to: #checkMethod: permutation: (1 to: 1))undoChange  ^undo poptestInlineMethodForSuperSendThatAlsoSendsSuper  | tmp1 |  model := Smalltalk compiler evaluate: self inlineMethodTestData.  tmp1 := RBInlineMethodRefactoring inline: (102 to: 131) inMethod: #executeNotifying: forClass: (model classNamed: #RBRenameInstanceVariableChange).  self shouldFail: tmp1storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' code: ''';     nextPutAll: sourceCode;     nextPutAll: ''' from: ''';     nextPutAll: selector;     nextPutAll: ''' in: '.  class storeOn: arg1.  arg1 nextPut: $)abstractVariablesIn: arg1 from: arg2 toAll: arg3 ignoring: arg4  | tmp1 |  tree := arg1.  fromClass := self classObjectFor: arg2.  toClasses := arg3 collect: [:arg5 |  self classObjectFor: arg5 ].  ignore := arg4.  tmp1 := RBExpandReferencedPoolsRefactoring model: self model forMethod: tree fromClass: fromClass toClasses: toClasses.  self performComponentRefactoring: tmp1.  self computeVariablesToAbstractcreateAccessors  self performComponentRefactoring: self accessorsRefactoringcalculateIfReturnIsNeeded  | tmp1 |  tmp1 := RBParseTreeSearcher new.  tmp1     matches: '^self' do: [:arg1 :arg2 |  arg2 ];     matches: '^`@anything' do: [:arg1 :arg2 |  true ].  ^tmp1 executeTree: subtree initialAnswer: falsetestTransform  | tmp1 |  tmp1 := (RBAddProtocolTransformation protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  tmp1 := (RBRemoveProtocolTransformation model: tmp1 model protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  self assert: tmp1 model changes changes size equals: 2name: arg1  name := arg1transform  definingNode removeTemporaryNamed: name.  blockNodes do: [:arg1 |  arg1 body addTemporaryNamed: name ].  class compileTree: parseTreemsg4  ^Var1isTransformationRule  ^falsecomparingCollectionBetween: arg1 and: arg2  | tmp1 tmp2 tmp3 |  tmp3 := [:arg3 :arg4 |  arg3 asString <= arg4 asString ].  tmp1 := (arg1 difference: arg2) sorted: tmp3.  tmp2 := (arg2 difference: arg1) sorted: tmp3.  ^String streamContents: [:arg5 |  arg5           nextPutAll: 'Given Collections do not match. Got ';           lf;           tab;           nextPutAll: 'left := ';           print: arg1;           nextPut: $.;           lf;           nextPutAll: ' instead of ';           tab;           nextPutAll: ' right :=';           print: arg1;           nextPut: $.;           lf.        arg1 size = arg2 size ifFalse: [ arg5                 nextPutAll: 'Collection size does not match: left=';                 print: arg1 size;                 nextPutAll: ' vs. right=';                 print: arg2 size;                 lf ].        tmp1 isEmpty ifFalse: [ arg5                 nextPutAll: 'Got ';                 print: tmp1 size;                 nextPutAll: ' additional element(s) in the left collection: ';                 tab;                 print: tmp1 ].        tmp2 isEmpty ifFalse: [ arg5                 nextPutAll: 'Got ';                 print: tmp2 size;                 nextPutAll: ' additional element(s) in the right collection: ';                 tab;                 print: tmp2 ] ]isMeta  self subclassResponsibilityprintOn: arg1  arg1     nextPutAll: 'NOT ';     print: conditionshouldnt: arg1 raise: arg2 description: arg3  ^self assert: (self executeShould: arg1 inScopeOf: arg2) not description: arg3classNamed: arg1  | tmp1 tmp2 tmp3 |  arg1 ifNil: [ ^nil ].  (self hasRemoved: arg1) ifTrue: [ ^nil ].  (newClasses includesKey: arg1) ifTrue: [ ^(newClasses at: arg1) first ].  (changedClasses includesKey: arg1) ifTrue: [ ^(changedClasses at: arg1) first ].  tmp1 := environment at: arg1 ifAbsent: [ nil ].  (tmp1 isBehavior or: [ tmp1 isTrait ]) ifTrue: [ tmp2 := self createNewClassFor: tmp1.        ^tmp1 isMeta ifTrue: [ tmp2 last ] ifFalse: [ tmp2 first ] ].  tmp3 := arg1 indexOfSubCollection: ' class' startingAt: 1 ifAbsent: [ ^nil ].  tmp1 := self classNamed: (arg1 copyFrom: 1 to: tmp3 - 1) asSymbol.  ^tmp1 ifNil: [ nil ] ifNotNil: [ tmp1 classSide ]moveDefinition  | tmp1 |  ^(self collect: [:arg1 |  tmp1 := arg1 printString.        tmp1 , tmp1 ]) select: [:arg1 |  tmp1 := arg1 size.        tmp1 odd ]printOn: arg1  arg1     nextPutAll: self displayClassName;     nextPutAll: ' removeInstVarName: ';     print: self oldName;     nextPut: $!;     cr.  arg1     nextPutAll: self displayClassName;     nextPutAll: ' addInstVarName: ';     print: self newName;     nextPut: $!calculateSubtree  ^subtree ifNil: [ subtree := self calculateTree ifNotNil: [ parseTree extractSubtreeWith: sourceCode ] ]renameChangesForClass: arg1 to: arg2  | tmp1 |  tmp1 := super renameChangesForClass: arg1 to: arg2.  oldName asSymbol = arg1 ifTrue: [ tmp1 rename: arg2 to: newName ].  ^tmp1yourselfNotUsed  self     printString;     printString;     yourselfcalculateTemporariesToRemove  | tmp1 |  tmp1 := parseTree copy removeSubtree: subtree.  ^tmp1 allDefinedVariables reject: [:arg1 |  tmp1 references: arg1 ]asSelectorEnvironment  ^selftestTransform  | tmp1 tmp2 |  tmp1 := (RBAddClassCommentTransformation comment: 'New comment for class' in: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name.  self assert: tmp2 comment equals: 'New comment for class'createClasses  mode := #create:name:executeNotifying: arg1  | tmp1 |  self changeClass rename: newName.  tmp1 := changes collect: [:arg2 |  (arg2 renameChangesForClass: oldName asSymbol to: newName asSymbol) executeNotifying: arg1 ].  ^self copy     changes: tmp1 reverse;     rename: newName to: oldName;     yourselfbuildTransformations  blockNodes ifNil: [ self checkMethodForBlocks ].  ^(OrderedCollection withAll: ((blockNodes sorted: [:arg1 :arg2 |  arg1 start > arg2 start ]) collect: [:arg3 |  RBAddTemporaryVariableTransformation variable: variableName inInterval: arg3 body sourceInterval inMethod: selector inClass: class ]))     add: (RBRemoveTemporaryVariableTransformation variable: variableName inMethod: selector inClass: class);     yourselfremoveClass: arg1 instanceVariableReader: arg2  | tmp1 |  tmp1 := instanceVariableReaders at: arg1 name ifAbsent: [ Set new ].  tmp1 remove: arg2 ifAbsent: [  ].  tmp1 ifEmpty: [ instanceVariableReaders removeKey: arg1 name ifAbsent: [  ] ].  self flushCachesFor: arg1packageOrganizer  ^RPackageOrganizer defaultpreconditions  ^(RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ self checkSuperMethods.              true ])name  ^rewriteRule1abstractInstanceVariables  | tmp1 |  (instVarReaders isEmpty and: [ instVarWriters isEmpty ]) ifTrue: [ ^self ].  tmp1 := Set new.  tmp1     addAll: instVarReaders;     addAll: instVarWriters.  tmp1 do: [:arg1 |  self abstractInstanceVariable: arg1 ]testTransform  | tmp1 tmp2 |  tmp1 := (RBAddAssignmentTransformation new variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: self class name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyinlineComponent  | tmp1 |  tmp1 := 5.  ^tmp1 class     superclass;     hasImmediateInstances;     yourselfremoveClass: arg1  ^self addChange: (changeFactory removeClassNamed: arg1 name)rootEnvironment  ^environment rootEnvironmenttestReferencesPrintOnAfterAddition  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := false.  tmp3 := modelFactory rbNamespace new.  (tmp3 classNamed: #Object) compile: 'someTestReference self printOn: nil' classified: #(testing).  (tmp3 classNamed: self class name) compile: 'someTestReference ^ #printOn:' classified: #(testing).  tmp3 allReferencesTo: #printOn: do: [:arg1 |  tmp1 := tmp1 or: [ arg1 selector = #someTestReference and: [ arg1 modelClass = (tmp3 classNamed: #Object) ] ].        tmp2 := tmp2 or: [ arg1 selector = #someTestReference and: [ arg1 modelClass = (tmp3 classNamed: self class name) ] ] ].  self assert: tmp1.  self assert: tmp2changeClass: arg1  super changeClass: arg1.  isMeta := falsetestTransform  | tmp1 tmp2 |  tmp1 := (RBRemoveMethodTransformation selector: #one from: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self deny: (tmp2 directlyDefinesMethod: #one)printOn: arg1  arg1 nextPutAll: self displayStringcompiledMethod  ^compiledMethod notNil ifTrue: [ compiledMethod ] ifFalse: [ compiledMethod := class compiledMethodAt: selector ]transform  self model     defineClass: ('<1p> subclass: #<2s> instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: <3p>' expandMacrosWith: superclass with: className with: category asString);     reparentClasses: subclasses to: (self model classNamed: className asSymbol)changeSymbol  ^#addClassVarNamed:someOtherDemoMethod  | tmp1 |  tmp1 := self new.  ^tmp1 junkcheckLocationsIn: arg1  (arg1 detect: [:arg2 |  RBReadBeforeWrittenTester isVariable: variableName readBeforeWrittenIn: arg2 ] ifNone: [ nil ]) notNil ifTrue: [ ^false ].  blockNodes ifNil: [ blockNodes := OrderedCollection new ].  arg1 do: [:arg2 |  (self checkBlocksIn: arg2 body) ifTrue: [ blockNodes add: arg2 ] ifFalse: [ (self checkLocationsIn: (self checkAllBlocksIn: arg2 body)) ifFalse: [ blockNodes add: arg2 ] ] ].  ^trueaddParameterToMethod: arg1 in: arg2 newSelector: arg3 initializer: arg4  self renameMethod: arg1 in: arg2 to: arg3 permutation: (1 to: arg3 numArgs).  initializer := arg4transform  | tmp1 tmp2 |  tmp1 := (class methodFor: newSelector) protocols.  tmp2 := self formOldName , String cr , String tab , 'self 		deprecated: ''Use ' , newSelector asString , ' instead''		on: 	''' , Date today asString , ''' 		in: ''' , SystemVersion current imageVersionString , '''.	^ self ' , self formNewName.  (model classNamed: class realClass name) compile: tmp2 classified: tmp1privateImplementorsOf: arg1  | tmp1 |  tmp1 := Set new.  self allClassesDo: [:arg2 |  (arg2 directlyDefinesLocalMethod: arg1) ifTrue: [ tmp1 add: arg2 ].        (arg2 classSide directlyDefinesLocalMethod: arg1) ifTrue: [ tmp1 add: arg2 classSide ] ].  ^tmp1printOn: arg1  arg1 nextPutAll: self namenewNameForSelf  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := inlineClass instanceSide.  tmp1 := tmp3 := (tmp4 name first isVowel ifTrue: [ 'an' ] ifFalse: [ 'a' ]) , tmp4 name.  tmp2 := 1.  [ tmp1 := self safeVariableNameBasedOn: tmp1.  inlineParseTree allDefinedVariables includes: tmp1 ] whileTrue: [ tmp1 := tmp3 , tmp2 printString.        tmp2 := tmp2 + 1 ].  ^tmp1validateRenameOf: arg1 to: arg2  self validateRenameNode: extractedParseTree withOldName: arg1 toWithName: arg2checkSpecialExtractions  | tmp1 |  tmp1 := self placeholderNode parent.  tmp1 ifNil: [ ^self ].  (tmp1 isAssignment and: [ tmp1 variable = self placeholderNode ]) ifTrue: [ self refactoringFailure: 'Cannot extract left hand side of an assignment' ].  tmp1 isCascade ifTrue: [ self refactoringError: 'Cannot extract first message of a cascaded message' ]collectSelectNotUsed  (1 to: 10) select: [:arg1 |  arg1 = 4 ]accept: arg1 notifying: arg2  | tmp1 |  tmp1 := self changeClass ifNil: [ Object compiler ] ifNotNil: [:arg3 |  arg3 compiler ].  tmp1     source: arg1 asString;     class: self changeClass;     requestor: arg2;     failBlock: [ ^false ];     compile.  self class: self changeClass protocol: self protocol source: arg1 asString.  ^truetestTransform  | tmp1 tmp2 |  tmp1 := (RBRemoveVariableTransformation instanceVariable: 'instVar' class: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self deny: (tmp2 directlyDefinesInstanceVariable: 'instVar')callFoo  ^self testFoo: 5typeFor: arg1  arg1 isString ifTrue: [ ^String ].  arg1 isInteger ifTrue: [ ^Integer ].  ^(arg1 == true or: [ arg1 == false ]) ifTrue: [ Boolean ] ifFalse: [ arg1 class ]selectors: arg1  selectors := arg1copyDictionary: arg1  | tmp1 |  tmp1 := Dictionary new: arg1 size.  arg1 keysAndValuesDo: [:arg2 :arg3 |  tmp1 at: arg2 put: arg3 ].  ^tmp1methodBefore  | tmp1 |  tmp1 := 'String'.  tmp1 := 1 asStringresetResult  builder := RBRefactoryChangeManager changeFactory compositeRefactoryChangemessages  ^(self parseTree sendNodes collect: [:arg1 |  arg1 selector ]) asSettestNonExistantSelector  self shouldFail: (RBExtractMethodToComponentRefactoring extract: (10 to: 20) from: #checkClass1: in: RBBasicLintRuleTestData)unaryAccessingMessageStatementMethodWithoutReturn  self valueprivateTransform  | tmp1 |  tmp1 := self definingClass parseTreeFor: selector.  tmp1 ifNil: [ ^self ].  (tmp1 extractSubtreeWith: sourceCode) ifNotNil: [:arg1 |  tmp1 removeSubtree: arg1.        self definingClass compileTree: tmp1 ] ifNil: [ ^self ]oldName: arg1  oldName := arg1environment: arg1  environment := arg1selectorCache  ^selectorCache ifNil: [ selectorCache := Dictionary new ] ifNotNil: [ selectorCache ]testMoveMethodIntoInstanceVariable  | tmp1 tmp2 |  self proceedThroughWarning: [ tmp1 := RBMoveMethodRefactoring selector: #checkMethod: class: RBTransformationRuleTestData variable: 'rewriteRule'.        self setupSelfArgumentNameFor: tmp1 toReturn: 'transformationRule'.        self setupVariableTypesFor: tmp1 toReturn: (Array with: (tmp1 model classNamed: #RBParseTreeRewriter)).        self setupMethodNameFor: tmp1 toReturn: #foo:foo: withArguments: #('transformationRule' 'aSmalllintContext').        self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext rewriteRule foo: self foo: aSmalllintContext').  self assert: ((tmp1 model classNamed: #RBParseTreeRewriter) parseTreeFor: #foo:foo:) equals: (self parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(self executeTree: aSmalllintContext parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: self tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: self tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').  self assert: (tmp2 parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (tmp2 parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject class := anObject').  self assert: (tmp2 classSide parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (tmp2 classSide parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (tmp2 parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (tmp2 parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject builder := anObject')testClassVariable  | tmp1 tmp2 |  tmp1 := (RBRenameVariableTransformation rename: #RecursiveSelfRule to: #RSR in: #RBTransformationRuleTestData classVariable: true) asRefactoring transform.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 directlyDefinesClassVariable: #RSR).  self deny: (tmp2 directlyDefinesClassVariable: #RecursiveSelfRule).  self assert: (tmp2 theMetaClass parseTreeFor: #initializeAfterLoad1) equals: (self parseMethod: 'initializeAfterLoad1					RSR := RBParseTreeSearcher new.					RSR addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')						-> [:aNode :answer | true]').  self assert: (tmp2 theMetaClass parseTreeFor: #nuke) equals: (self parseMethod: 'nuke RSR := nil').  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 					class := aSmalllintContext selectedClass.					(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 						[(RSR executeTree: rewriteRule tree initialAnswer: false)						ifFalse: [builder compile: rewriteRule tree printString										in: class										classified: aSmalllintContext protocols]]')insertInlinedMethod  | tmp1 |  tmp1 := sourceMessage.  self moveComments.  tmp1 parent isCascade ifTrue: [ self rewriteCascadedMessage.        tmp1 := tmp1 parent ].  tmp1 parent isReturn ifTrue: [ tmp1 := tmp1 parent ] ifFalse: [ self removeReturns ].  self replaceArguments.  self inlineSourceReplacing: tmp1.  sourceParseTree removeDeadCode.  self removeEmptyIfTrues.  self removeImmediateBlockstestMoveMethodIntoClassVariable  | tmp1 tmp2 |  self proceedThroughWarning: [ tmp1 := RBMoveMethodRefactoring selector: #checkMethod: class: RBTransformationRuleTestData variable: 'RecursiveSelfRule'.        self setupSelfArgumentNameFor: tmp1 toReturn: 'transformationRule'.        self setupVariableTypesFor: tmp1 toReturn: (Array with: (tmp1 model classNamed: #RBParseTreeSearcher)).        self setupMethodNameFor: tmp1 toReturn: #foo:foo: withArguments: #('transformationRule' 'aSmalllintContext').        self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext RecursiveSelfRule foo: self foo: aSmalllintContext').  self assert: ((tmp1 model classNamed: #RBParseTreeSearcher) parseTreeFor: #foo:foo:) equals: (self parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(transformationRule rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(self executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').  self assert: (tmp2 parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (tmp2 parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject class := anObject').  self assert: (tmp2 parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (tmp2 parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject builder := anObject').  self assert: (tmp2 parseTreeFor: #rewriteRule) equals: (self parseMethod: 'rewriteRule ^rewriteRule').  self assert: (tmp2 parseTreeFor: #rewriteRule:) equals: (self parseMethod: 'rewriteRule: anObject rewriteRule := anObject')method: arg1  method := arg1.  class := method originpostCopy  super postCopy.  changes := changes collect: [:arg1 |  arg1 copy ]checkClass: arg1  ^classBlock value: arg1 value: resulttestExtractFailure  | tmp1 |  tmp1 := (RBRemoveSubtreeTransformation code: ':= anInterval' from: #one in: self changeMock name) transform.  self assertEmpty: tmp1 model changes changes.  self shouldFail: (RBRemoveSubtreeTransformation code: ':= aSelector' from: #selector:from: in: #RBRemoveMethodTransformation) asRefactoringtestNonExistantSelector  self shouldFail: (RBExtractMethodRefactoring extract: (10 to: 20) from: #checkClass1: in: RBBasicLintRuleTestData)testExtractFailure  self     shouldFail: (RBExtractMethodToComponentRefactoring extract: (80 to: 269) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class);     shouldFail: (RBExtractMethodToComponentRefactoring extract: (53 to: 56) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class);     shouldFail: (RBExtractMethodToComponentRefactoring extract: (77 to: 222) from: #subclassResponsibilityNotDefined in: RBBasicLintRuleTestData class)redoChange  ^redo lasttypesFor: arg1 in: arg2 model: arg3  | tmp1 tmp2 |  tmp1 := self parseTreeSearcher.  tmp1 matches: arg1 , ' `@message: ``@args' do: [:arg4 :arg5 |  arg5           add: arg4 selector;           yourself ].  tmp2 := tmp1 executeTree: arg2 initialAnswer: Set new.  ^self     model: arg3;     findTypeFor: tmp2;     yourselfbyNodeCheckMethod: arg1  arg1 ast nodesDo: [:arg2 |  renrakuRule check: arg2 forCritiquesDo: [:arg3 |  result addMethod: arg1.              self addSearchStringFrom: arg3 in: arg1 definition.              ^self ] ]hierarchyDefinesClassVariable: arg1  (self definesClassVariable: arg1) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:arg2 |  arg2 directlyDefinesClassVariable: arg1 ]changeString  ^'Comment ' , self displayClassNameremoveRenamedImplementors  oldSelector = newSelector ifTrue: [ ^self ].  self implementors do: [:arg1 |  arg1 removeMethod: oldSelector ]shouldWarn: arg1  self should: [ self executeRefactoring: arg1 ] raise: RBRefactoringWarningchanges  ^rules flatCollect: [:arg1 |  arg1 changes ]includesCategory: arg1  ^(super includesCategory: arg1) and: [ (self classNamesFor: arg1) anySatisfy: [:arg2 |  (classSelectors includesKey: arg2) or: [ metaClassSelectors includesKey: arg2 ] ] ]whileTrue  | tmp1 |  tmp1 := 1.  [ tmp1 < self size ] whileTrue: [ (self at: tmp1) printString.        tmp1 := tmp1 + 1 ]reparentSubclasses  classNames do: [:arg1 |  | tmp1 |        tmp1 := self model classNamed: arg1.        self model reparentClasses: tmp1 subclasses copy to: tmp1 superclass ]parameterMap: arg1  parameterMap := arg1selector  ^self methodName ifNotNil: [:arg1 |  arg1 selector ]includesClass: arg1  ^(super includesClass: arg1) and: [ self packages anySatisfy: [:arg2 |  (arg2 includesClass: arg1) or: [ (arg2 extensionCategoriesForClass: arg1) notEmpty ] ] ]testTransform  | tmp1 tmp2 |  tmp1 := (RBAddVariableTransformation instanceVariable: 'asdf' class: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 directlyDefinesInstanceVariable: 'asdf')problemCount  ^rules inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 problemCount ]allBehaviorsDo: arg1  | tmp1 tmp2 |  tmp1 := Set new.  tmp2 := [:arg2 |  tmp1 add: arg2 first name.  arg1     value: arg2 first;     value: arg2 last ].  newClasses do: tmp2.  changedClasses do: tmp2.  environment classesDo: [:arg2 |  arg2 isObsolete ifFalse: [ | tmp3 |              tmp3 := arg2 instanceSide.              ((tmp1 includes: tmp3 name) or: [ self hasRemoved: (self classNameFor: tmp3) ]) ifFalse: [ (tmp3 := self classFor: arg2) ifNotNil: [ tmp1 add: tmp3 name.                          arg1                             value: tmp3;                             value: tmp3 classSide ] ] ] ]protocols: arg1  protocols := arg1 isString ifTrue: [ arg1 = Protocol unclassified ifTrue: [ protocols := #(accessing) ] ifFalse: [ Array with: arg1 ] ] ifFalse: [ arg1 ]theNonMetaClass  ^selfcompile: arg1 classified: arg2  | tmp1 tmp2 |  tmp1 := model compile: arg1 in: self classified: arg2.  tmp2 := modelFactory rbMethod for: self source: arg1 selector: tmp1 selector.  self addMethod: tmp2.  ^tmp1testMethodDoesNotExist  self shouldFail: (RBReplaceSubtreeTransformation replace: 'selector := aSelector' to: '^ selector' inMethod: #selector:for: inClass: #RBRemoveMethodTransformation) asRefactoringwriteGuardClauses  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1     replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2' with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^`@r2]';     replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2' with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^`@r2] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]';     replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2' with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^self]';     replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2' with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^self] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]'.  [ tmp1 executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := tmp1 tree ]method  ^class realClass >> selectorremoveClass: arg1 into: arg2  (environmentDictionaries at: arg2 ifAbsent: [ RBSelectorEnvironment new ]) removeClass: arg1preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self buildParseTree.              self checkForPrimitiveMethod.              self checkForSuperReferences.              self checkAssignmentsToVariable.              self getClassesToMoveTo.              self getArgumentNameForSelf.              self checkTemporaryVariableNames.              self getNewMethodName.              true ])checkClass: arg1  (environment includesClass: arg1) ifTrue: [ rule checkClass: arg1 ]class: arg1 protocol: arg2 source: arg3 controller: arg4  self changeClass: arg1.  self protocols: arg2.  source := arg3.  controller := arg4environment: arg1  environment := arg1targetClass  ^classstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' renameTemporary: ';     nextPutAll: variableName;     nextPutAll: ' to: ''';     nextPutAll: newVariableName;     nextPutAll: ''' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' selector: #';     nextPutAll: selector.  arg1 nextPut: $)transform  self     insertTemporary;     compileNewMethodshould: arg1 raise: arg2 description: arg3  ^self assert: (self executeShould: arg1 inScopeOf: arg2) description: arg3undoPointers  ^undoPointerstestWithTemporaryVariable  | tmp1 tmp2 |  tmp1 := (RBExtractMethodTransformation extract: (self sourceCodeAt: (22 to: 280) forMethod: #superSends in: RBTransformationRuleTestData) from: #superSends to: #foo1 in: #RBTransformationRuleTestData) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #superSends) equals: (self parseMethod: 'superSends				| rule |				rule := self foo1.				self rewriteUsing: rule').  self assert: (tmp2 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 | rule |				rule := RBParseTreeRewriter new.				rule addSearch: ''super `@message: ``@args''					-> ([:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> ''self `@message: ``@args'').				^rule')badMessage  self become: String newtestPerformChangeMethod  | tmp1 tmp2 |  tmp1 := changes compile: 'one ^ 2' in: self changeMock.  tmp2 := tmp1 changeClass sourceCodeAt: #one.  self perform: tmp1 do: [ self assert: (tmp1 changeClass sourceCodeAt: #one) equals: 'one ^ 2' ].  self assert: (tmp1 changeClass sourceCodeAt: #one) equals: tmp2testCommentChange  | tmp1 tmp2 |  tmp1 := modelFactory rbNamespace new.  tmp2 := tmp1 classNamed: self class name.  self assert: tmp2 comment isString.  tmp2 comment: 'a comment'.  self assert: tmp2 comment equals: 'a comment'.  self assert: tmp1 changes changes size equals: 1.  self assert: tmp1 changes changes first comment equals: 'a comment'.  tmp2 comment: nil.  self assert: tmp2 comment isNil.  self assert: tmp1 changes changes size equals: 2.  self assert: tmp1 changes changes last comment isNildirectlyDefinesLocalMethod: arg1  self isDefined ifTrue: [ (self hasRemoved: arg1) ifTrue: [ ^false ].        (self realClass includesLocalSelector: arg1) ifTrue: [ ^true ] ].  ^newMethods notNil and: [ newMethods includesKey: arg1 ]asEpiceaEvent  ^EpRenameClassRefactoring rename: className to: newNamechangeMock  ^testingEnvironment at: #RBRefactoringChangeMockvariable: arg1 class: arg2 classVariable: arg3  variableName := arg1.  isClassVariable := arg3.  className := arg2parseTree  parseTree ifNil: [ parseTree := class parseTreeFor: selector.        parseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ] ].  ^parseTreewhatToDisplayIn: arg1  ^self changes flatCollect: [:arg2 |  arg2 whatToDisplayIn: arg1 ]isResumable  ^falsevariable: arg1 inInterval: arg2 inMethod: arg3 inClass: arg4  self className: arg4.  interval := arg2.  selector := arg3.  variableName := arg1parseTree  parseTree ifNil: [ parseTree := class parseTreeFor: selector.        parseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ] ].  ^parseTreeinitialize  super initialize.  classes := IdentitySet new.  metaClasses := IdentitySet newcheckMethod: arg1  systemDictionary  ^environment systemDictionaryselectors  literalSemaphore ifNil: [ selectors ifNil: [ self computeLiterals.              literalSemaphore wait ] ] ifNotNil: [ literalSemaphore wait ].  ^selectorspackages: arg1  packages addAll: arg1oldClass: arg1  oldClass := self classObjectFor: arg1testRefactoring  | tmp1 tmp2 |  tmp1 := (RBRemovePragmaTransformation pragma: '<gtInspectorPresentationOrder: 34>' inMethod: #methodBefore inClass: #RBRemovePragmaTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBRemovePragmaTransformationTest.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyallPoolDictionaryNames  ^self subclassResponsibilitymodifyImplementorParseTree: arg1 in: arg2  | tmp1 tmp2 tmp3 |  tmp3 := arg1 allDefinedVariables.  tmp1 := self safeVariableNameFor: arg2 temporaries: tmp3.  tmp2 := RBVariableNode named: tmp1.  arg1 renameSelector: newSelector andArguments: arg1 arguments , (Array with: tmp2)justSendsSuper  super justSendsSupertransform  self shouldFixSubclasses ifTrue: [ self renameSuperclassOfSubclasses ].  self renameReferences.  self shouldCopyExtensions ifTrue: [ self copyExtensionMethods ].  self shouldRemoveExtensions ifTrue: [ self removeExtensionMethods ]environment  ^environmentstringTestFor: arg1  self assert: (arg1 name isString and: [ arg1 name notEmpty ]).  self assert: (arg1 printString isString and: [ arg1 printString notEmpty ]).  self assert: (arg1 changeString isString and: [ arg1 changeString notEmpty ]).  self assert: (arg1 displayString isString and: [ arg1 displayString notEmpty ])testClassDoesNotExist  self shouldFail: (RBAddTemporaryVariableTransformation variable: 'variable2' inMethod: #methodBefore inClass: #RBReturnStatementTransformationTest) asRefactoringoldProtocol  | tmp1 |  tmp1 := RBBrowserEnvironment new whichProtocolIncludes: self selector in: self changeClass.  ^tmp1 ifNil: [ tmp1 := #accessing ]transform  | tmp1 |  tmp1 := self parserClass parseMethod: 'printOn: aStream		"Append a sequence of characters to aStream that identify the receiver."				super printOn: aStream'.  variables do: [:arg1 |  tmp1 body addNode: (self parserClass parseExpression: ('aStream nextPutAll: '' <1s>: ''; print: <1s>' expandMacrosWith: arg1)) ].  self theClass compile: tmp1 formattedCode classified: #(printing)testClassDoesNotExist  self shouldFail: (RBMethodProtocolTransformation protocol: 'empty protocol 2' inMethod: #someMethod inClass: #RBDummyEmptyClass123) asRefactoringinstanceSideExtensionMethodsOf: arg1  ^arg1 realClass instanceSide localMethods select: #isExtension thenCollect: [:arg2 |  arg1 instanceSide methodFor: arg2 selector ]transform  self compileHash.  self compileEqualnumberSelectorsFor: arg1  | tmp1 tmp2 |  tmp1 := arg1 numberSelectors.  tmp2 := arg1 not numberSelectors.  self assert: tmp1 + tmp2 equals: universalEnvironment numberSelectors.  self assert: (arg1 & arg1 not) numberSelectors equals: 0.  self assert: (universalEnvironment & arg1) numberSelectors equals: tmp1.  self assert: (arg1 & universalEnvironment) numberSelectors equals: tmp1comparingIdentityStringBetween: arg1 and: arg2  ^String streamContents: [:arg3 |  arg3           nextPutAll: arg1 fullPrintString;           nextPutAll: ' is not identical to ';           nextPutAll: arg2 fullPrintString;           nextPutAll: '.' ]transform  self hasVariablesToAbstract ifTrue: [ self refactoringWarning: 'This method has direct variable references which<n>will need to be converted to getter/setters.' expandMacros ].  self abstractInstanceVariables.  self abstractClassVariablesprivateRootClasses  | tmp1 |  tmp1 := OrderedCollection new.  Class rootsOfTheWorld do: [:arg1 |  | tmp2 |        tmp2 := self classFor: arg1.        (tmp2 notNil and: [ tmp2 superclass isNil ]) ifTrue: [ tmp1 add: tmp2 ] ].  ^tmp1rbMethod  ^self class rbMethodcheckPackage: arg1  renrakuRule class checksPackage ifFalse: [ ^self ].  renrakuRule check: arg1 forCritiquesDo: [:arg2 |  ^result addPackage: arg1 ]formNewName  ^self formNameFor: newSelectortestAddPool  | tmp1 |  tmp1 := changes addPool: 'PoolDict' to: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 variable equals: 'PoolDict'.  self universalTestFor: tmp1longMacro  ^'(' , left errorMacro , ') <1?AND:OR> (' , right errorMacro , ')'atIfAbsent  ^Smalltalk at: #MyTest ifAbsent: [ | tmp1 |        tmp1 := #().        Smalltalk at: #MyTest put: tmp1 ]printTypeFor: arg1 on: arg2  | tmp1 |  tmp1 := (self guessTypesFor: arg1) asSortedCollection: [:arg3 :arg4 |  arg3 name < arg4 name ].  1 to: tmp1 size do: [:arg5 |  arg5 == 1 ifFalse: [ arg2 nextPutAll: ' | ' ].        self printType: (tmp1 at: arg5) for: arg1 on: arg2 ]name  self subclassResponsibilityinlineParameterMethod: arg1  ^arg1 isSymbolenvironment  ^environmentclassName: arg1  className := arg1requestSelectors  ^(self options at: #selectorsFromView) value: selfassertCollection: arg1 hasSameElements: arg2  | tmp1 tmp2 |  tmp2 := arg1 difference: arg2.  tmp1 := arg2 difference: (arg1 intersection: arg2).  self assert: (tmp2 isEmpty and: [ tmp1 isEmpty ]) description: (String streamContents: [:arg3 |  arg3                 nextPutAll: 'Given Collections do not match!';                 lf;                 tab;                 nextPutAll: 'additions : ';                 print: tmp2 asArray;                 lf;                 tab;                 nextPutAll: 'missing: ';                 print: tmp1 asArray;                 lf ])hash  ^self species identityHashextraBlock  ^[:arg1 |  arg1 + 43 ] value: 45theNonMetaClass  ^selfundoTestFor: arg1  | tmp1 |  tmp1 := arg1 asUndoOperation.  self assert: (tmp1 isKindOf: RBRefactoryChange)assert: arg1 description: arg2  arg1 value ifFalse: [ | tmp1 |        tmp1 := arg2 value.        self classForTestResult failure signal: tmp1 ]checkMethodName: arg1 in: arg2  ^RBCondition checkMethodName: arg1 in: arg2methodBlock: arg1  methodBlock := arg1computeMessagesSentToVariables  | tmp1 |  variableMessages := Dictionary new.  class instanceVariableNames do: [:arg1 |  variableMessages at: arg1 put: Set new ].  tmp1 := self parseTreeSearcher.  class instanceVariableNames do: [:arg1 |  | tmp2 |        tmp2 := [:arg2 :arg3 |  (variableMessages at: arg1 ifAbsentPut: [ Set new ]) add: arg2 selector.        self processCollectionMessagesFor: arg1 in: arg2 ].        tmp1 matches: arg1 , ' `@messageName: ``@args' do: tmp2.        (backpointers at: arg1) do: [:arg4 |  arg4 isSymbol ifTrue: [ tmp1 matches: ('(self <1s>) `@messageName: ``@args' expandMacrosWith: (self parseTreeSearcherClass buildSelectorString: arg4)) asString do: tmp2 ] ] ].  tmp1 answer: variableMessages.  self executeSearch: tmp1unexpectedEqualityStringBetween: arg1 and: arg2  ^String streamContents: [:arg3 |  arg3           nextPutAll: 'Unexpected equality of ';           nextPutAll: arg1 fullPrintString;           nextPutAll: ' and ';           nextPutAll: arg2 fullPrintString;           nextPutAll: '.' ]testModelRecursiveMethodThatIsNotReferencedFromOtherMethods  | tmp1 tmp2 |  tmp1 := model classNamed: #Object.  tmp1 compile: 'someMethodThatIsNotReferenced ^2' classified: #(#accessing).  self assert: (tmp1 definesMethod: #someMethodThatIsNotReferenced).  tmp2 := model metaclassNamed: self class superclass name.  tmp2 compile: 'someMethodThatIsNotReferenced ^3 someMethodThatIsNotReferenced' classified: #(#accessing).  model removeClassNamed: self class name.  self executeRefactoring: (RBRemoveMethodRefactoring model: model removeMethods: #(#someMethodThatIsNotReferenced) from: tmp1).  self deny: (tmp1 definesMethod: #someMethodThatIsNotReferenced)traits  | tmp1 |  tmp1 := IdentitySet new: 4096.  self traitsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1privateTransform  oldCategory := self definingClass category.  self definingClass category: category.  self model category: category for: self definingClasscreateAccessors  self performComponentRefactoring: self accessorsRefactoringnewMethods  ^newMethods ifNil: [ newMethods := IdentityDictionary new ] ifNotNil: [ newMethods ]allReferencesTo: arg1  ^sendersCache at: arg1 ifAbsentPut: [ self privateReferencesTo: arg1 ]viewResults  result openEditormodel: arg1  model := arg1changeClassName: arg1  className := arg1.  isMeta ifNil: [ isMeta := false ]inlineClass  ^inlineClass ifNil: [ inlineClass := (sourceMessage receiver name = 'super' ifTrue: [ class superclass ] ifFalse: [ class ]) whoDefinesMethod: self inlineSelector ] ifNotNil: [ inlineClass ]changeMock  ^testingEnvironment at: #RBRefactoringChangeMockinitialize  super initialize.  changes := changeFactory compositeRefactoryChange.  environment := RBBrowserEnvironment new.  newClasses := IdentityDictionary new.  changedClasses := IdentityDictionary new.  removedClasses := Set new.  implementorsCache := IdentityDictionary new.  sendersCache := IdentityDictionary newtestHierarchy  | tmp1 |  tmp1 := objectClass classSide.  self assert: (objectClass withAllSubclasses includes: tmp1).  self assert: (tmp1 withAllSuperclasses includes: objectClass)testFindOcurrencesInOf  | tmp1 |  tmp1 := RBFindAndReplaceMethodRefactoring find: RBRefactoryTestDataApp >> #textInput:name:symbol:.  self assert: (tmp1 findOcurrencesIn: #renderContentOn: of: RBRefactoryTestDataApp) size equals: 4methodAfter  | tmp1 |  tmp1 := 'String'defaultLabel  | tmp1 |  tmp1 := String new writeStream.  tmp1     nextPutAll: class name;     nextPut: $>.  protocols do: [:arg1 |  tmp1           nextPutAll: arg1;           nextPut: $  ].  ^tmp1 contentsclassName: arg1 newClassName: arg2  className := arg1.  newClassName := arg2createArgumentSearchWith: arg1 selectors: arg2 inClass: arg3  | tmp1 |  tmp1 := self parseTreeSearcher.  tmp1 matchesAnyArgumentOf: (Array with: arg1) do: [:arg4 :arg5 |  arg5           remove: self currentSelector ifAbsent: [ self error: 'failed' ];           yourself ].  tmp1 answer: arg2 asBag.  (classSearches at: arg3 ifAbsentPut: [ Set new ]) add: tmp1includesSelector: arg1 in: arg2  ^(environment includesSelector: arg1 in: arg2) or: [ orEnvironment includesSelector: arg1 in: arg2 ]result  | tmp1 |  tmp1 := RBParseTreeEnvironment new.  tmp1 matcher: self rewriteRule.  tmp1 label: self name.  self changes do: [:arg1 |  (arg1 isKindOf: RBAddMethodChange) ifTrue: [ tmp1 addClass: arg1 changeClass selector: arg1 selector ] ].  ^tmp1inlineJunk  | tmp1 |  tmp1 := self inlineFoo: [:arg1 |  | tmp2 |        tmp2 := arg1.        tmp2 , tmp2 ].  ^tmp1 foo: [:arg2 |  | tmp3 |        tmp3 := arg2.        tmp3 * tmp3 ]guardingClause  self isSymbol ifFalse: [ self printString.        self isSymbol printString ]compileTree: arg1  | tmp1 tmp2 tmp3 |  tmp2 := arg1 newSource.  tmp3 := self modelClass model compile: tmp2 in: self modelClass classified: self protocols.  tmp1 := self class for: self modelClass source: tmp2 selector: arg1 selector.  self modelClass addMethod: tmp1.  ^tmp3testMetaclassFailure  self shouldFail: (RBRenameVariableTransformation rename: #RecursiveSelfRule to: #Foo in: RBTransformationRuleTestData class classVariable: true) asRefactoringrules: arg1  rules := arg1whoDefinesClassVariable: arg1  | tmp1 |  (self directlyDefinesClassVariable: arg1) ifTrue: [ ^self ].  tmp1 := self superclass.  ^tmp1 ifNil: [ nil ] ifNotNil: [ tmp1 whoDefinesClassVariable: arg1 ]addSubclass: arg1  self subclasses add: arg1parseTreeSearcherClass  ^RBParseTreeSearcherpreconditions  class := self definingClass.  ^(RBCondition isValidClassName: newClassName) & (RBCondition isGlobal: newClassName in: self model) not & (RBCondition isValidInstanceVariableName: referenceVariableName for: class) & (RBCondition hierarchyOf: class definesVariable: referenceVariableName) not & (RBCondition isGlobal: referenceVariableName in: self model) not & (RBCondition definesTemporaryVariable: referenceVariableName in: class) notnot  self isSystem ifTrue: [ ^RBSelectorEnvironment new ].  ^RBNotEnvironment onEnvironment: selfcheckInstVars  class instanceVariableNames do: [:arg1 |  (target instanceVariableNames includes: arg1) ifFalse: [ ((class whichSelectorsReferToInstanceVariable: arg1) includes: selector) ifTrue: [ self refactoringError: ('<1p> refers to <2s>, which is not defined in <3p>' expandMacrosWith: selector with: arg1 with: target) ] ] ]privateTransform  | tmp1 tmp2 tmp3 |  tmp1 := self definingMethod.  tmp2 := self parserClass parsePragma: pragma.  tmp3 := (tmp1 allChildren removeDuplicates select: #isPragma) select: [:arg1 |  arg1 selector = tmp2 selector ].  tmp3 do: [:arg1 |  arg1 parent removePragma: arg1 ].  self definingClass compileTree: tmp1preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ | tmp1 |              tmp1 := self parserClass parsePragma: pragma.              self definingMethod pragmas anySatisfy: [:arg1 |  arg1 selector = tmp1 selector ] ] errorString: ('Method named <1s> does not have a pragma named <2s>' expandMacrosWith: selector with: (self parserClass parsePragma: pragma) selector))addNewAccessors  | tmp1 |  tmp1 := RBCreateAccessorsForVariableRefactoring model: self variable: newName asString class: class classVariable: false.  tmp1     createGetterAccessor;     createSetterAccessorclassName: arg1  className := arg1testExtractMethodThatMovesTemporaryVariable  | tmp1 tmp2 |  tmp1 := RBExtractMethodRefactoring extract: (22 to: 280) from: #superSends in: RBTransformationRuleTestData.  self setupMethodNameFor: tmp1 toReturn: #foo1.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #superSends) equals: (self parseMethod: 'superSends	| rule |	rule := self foo1.	self rewriteUsing: rule').  self assert: (tmp2 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 | rule | 	rule := RBParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args''				-> (					[:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> ''self `@message: ``@args'').		^rule')preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'Class named ' , className , ' does not exist') & (RBCondition withBlock: [ (model environment protocolsFor: self definingClass realClass) includes: protocol ] errorString: 'Protocol named ' , protocol , ' does not exist') & (RBCondition withBlock: [ (self definingClass realClass organization protocolNamed: protocol) canBeRemoved ] errorString: 'Protocol named ' , protocol , ' is a virtual protocol and it cannot be removed') & (RBCondition withBlock: [ (self definingClass realClass organization protocolNamed: protocol) isEmpty ] errorString: 'Protocol named ' , protocol , ' is not empty and it cannot be removed')typesFor: arg1 in: arg2  class = arg2 ifFalse: [ self runOn: arg2 ].  ^variableTypes at: arg1 ifAbsent: [ Set new ]replaceSelfReferences  | tmp1 |  self needsToReplaceSelfReferences ifTrue: [ tmp1 := RBParseTreeRewriter new.        tmp1 replace: 'self' with: selfVariableName.        self hasOnlySelfReturns ifTrue: [ tmp1 replace: '^self' with: '^self' ].        tmp1 executeTree: parseTree.        parseTree := tmp1 tree ]classObjectFor: arg1  (arg1 isBehavior or: [ arg1 isTrait ]) ifTrue: [ ^self model classFor: arg1 ].  arg1 isSymbol ifTrue: [ ^self model classNamed: arg1 ].  ^arg1testModelMetaclassAlreadyExistingName  | tmp1 |  (model metaclassNamed: #Foo) addInstanceVariable: 'instVarName1'.  tmp1 := RBAddInstanceVariableRefactoring model: model variable: 'instVarName1' class: (model classNamed: #Bar).  self shouldFail: tmp1definesClass: arg1  ^trueprimitiveExecute  ^self changeClass removeSelector: selectorremoveClass: arg1 selector: arg2 into: arg3  (environmentDictionaries at: arg3 ifAbsentPut: [ RBSelectorEnvironment new ]) removeClass: arg1 selector: arg2called: arg1 on1: arg2  | tmp1 |  tmp1 := arg1 printString.  self traceCr: tmp1.  arg2 value: tmp1buildStatementSearch  self createSearchWith: '| `@temps | ``@.Stmts1. ``.Stmt1. ``@.Stmts2. ``.Stmt2. ``@.Stmts3' selectors: #(#checkMethod: #rewriteUsing: #viewResults #superSends) inClass: RBTransformationRuleTestDatachangeString  ^'Remove instance variable <1s> from <2s>' expandMacrosWith: self variable with: self displayClassNameshould: arg1 raise: arg2  ^self assert: (self executeShould: arg1 inScopeOf: arg2)findOcurrencesIn: arg1  arg1 do: [:arg2 |  positionIndex := 1.        [ self findAndReplaceOcurrencesIn: arg2 ] on: Exception do: [:arg3 |  arg3 messageText isEmptyOrNil ifFalse: [ UIManager default alert: arg3 messageText ] ] ]classesAndSelectorsDo: arg1  packages do: [:arg2 |  arg2 methods do: [:arg3 |  (environment includesSelector: arg3 selector in: arg3 methodClass) ifTrue: [ arg1 value: arg3 methodClass value: arg3 selector ] ] ]parseTree  parseTree ifNil: [ parseTree := class parseTreeFor: selector.        parseTree ifNil: [ self refactoringFailure: 'Could not parse method' ] ].  ^parseTreeasUndoOperation  ^changeFactory addClassVariable: self variable to: self changeClassdefiningClass  ^self model classObjectFor: classNamemovePoolVariables  pools do: [:arg1 |  toClasses do: [:arg2 |  self movePool: arg1 toClass: arg2 ] ]renameImplementors  self implementors do: [:arg1 |  | tmp1 |        tmp1 := arg1 parseTreeFor: oldSelector.        tmp1 ifNil: [ self refactoringFailure: 'Could not parse source code.' ].        self implementorsCanBePrimitives ifFalse: [ tmp1 isPrimitive ifTrue: [ self refactoringFailure: ('<1p>''s implementation of #<2s> is a primitive' expandMacrosWith: arg1 with: oldSelector) ] ].        self modifyImplementorParseTree: tmp1 in: arg1.        (arg1 methodFor: oldSelector) compileTree: tmp1 ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' class: '.  className storeOn: arg1.  arg1 nextPut: $)universalTestFor: arg1  self labelFor: arg1.  self uniqueClassesIn: arg1.  self numberSelectorsFor: arg1.  self storeStringFor: arg1.  self classNamesFor: arg1.  self copyFor: arg1.  self categoriesFor: arg1.  self protocolsFor: arg1.  self classesFor: arg1.  self keysFor: arg1.  self assert: arg1 problemCount = 0 equals: arg1 isEmptyclassesFor: arg1  | tmp1 |  tmp1 := arg1 classes asSet.  tmp1 addAll: arg1 not classes.  RBBrowserEnvironment new allClassesDo: [:arg2 |  tmp1 remove: arg2 ].  self assertEmpty: tmp1literal: arg1 containsReferenceTo: arg2  arg1 = arg2 ifTrue: [ ^true ].  arg1 class = Array ifFalse: [ ^false ].  ^arg1 anySatisfy: [:arg3 |  self literal: arg3 containsReferenceTo: arg2 ]poolVariableNamesFor: arg1  | tmp1 |  tmp1 := Set new.  arg1 withAllSuperclasses do: [:arg2 |  arg2 allPoolDictionaryNames do: [:arg3 |  tmp1 addAll: ((Smalltalk globals at: arg3 asSymbol) classPool keys collect: [:arg4 |  arg4 asString ]) ] ].  ^tmp1variable: arg1 class: arg2 classVariable: arg3  self className: arg2.  variableName := arg1.  isClassVariable := arg3testModelInlineRecursiveMethod  | tmp1 tmp2 |  tmp2 := model classNamed: #Object.  tmp2 compile: 'foo self bar. self foo. self bar' classified: #(#accessing).  tmp1 := RBInlineMethodRefactoring model: model inline: (15 to: 23) inMethod: #foo forClass: tmp2.  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  self assert: (tmp2 parseTreeFor: #foo) equals: (self parseMethod: 'foo self bar. self bar. self foo. self bar. self bar')testMoveWithoutSelfReference  | tmp1 tmp2 tmp3 |  tmp1 := RBExtractMethodToComponentRefactoring extract: (118 to: 286) from: #copyDictionary: in: RBReadBeforeWrittenTester.  self setupMethodNameFor: tmp1 toReturn: #copyWithAssociations.  self setupVariableToMoveToFor: tmp1 toReturn: 'aDictionary'.  self setupVariableTypesFor: tmp1 toReturn: (Array with: (tmp1 model classNamed: #Dictionary)).  tmp2 := tmp1 model classNamed: #RBReadBeforeWrittenTester.  tmp3 := tmp2 selectors size.  self executeRefactoring: tmp1.  self assert: (tmp2 parseTreeFor: #copyDictionary:) equals: (self parseMethod: 'copyDictionary: aDictionary ^aDictionary copyWithAssociations').  self assert: ((tmp1 model classNamed: #Dictionary) parseTreeFor: #copyWithAssociations) equals: (self parseMethod: 'copyWithAssociations 							| newDictionary |							newDictionary := Dictionary new: self size.							self								keysAndValuesDo: [:key :value | newDictionary at: key put: value].							^newDictionary').  self assert: tmp2 selectors size equals: tmp3runOnEnvironment: arg1  ^RBSmalllintChecker runRule: self onEnvironment: arg1textInput: arg1 name: arg2 symbol: arg3  arg1 text: arg2.  arg1 textInput on: arg3 of: self contact.  arg1 breakprivateTransform  self definingClass addProtocolNamed: protocolremoveOldVariable  self subclassResponsibilitytestVariableEnvironmentClassVars  | tmp1 |  tmp1 := RBVariableEnvironment referencesToClassVariable: 'ClassSideOnlyVariable' in: self class.  self universalTestFor: tmp1.  self denyEmpty: tmp1 methodsprotocol: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  protocol := arg1assignmentInBlock  [ ^self printString ] ensure: [ self close ]testBadName  self     shouldFail: (RBRenameClassRefactoring rename: RBLintRuleTestData to: self objectClassVariable);     shouldFail: (RBRenameClassRefactoring rename: RBLintRuleTestData to: #'Ob ject')testRemoveSelectorByAndAndNot  | tmp1 tmp2 |  tmp1 := RBBrowserEnvironment new.  tmp2 := RBSelectorEnvironment onEnvironment: tmp1.  tmp2 addClass: Object selector: #printString.  self assert: tmp1 numberSelectors - 1 equals: (tmp1 & tmp2 not) numberSelectors.  self universalTestFor: tmp1 & tmp2 notsetUp  | tmp1 |  super setUp.  tmp1 := RBClassModelFactory rbNamespace new.  objectClass := tmp1 classNamed: #Object.  messageNodeClass := tmp1 classNamed: #RBMessageNode.  tmp1 defineClass: 'Object subclass: #SomeClassName	instanceVariableNames: ''instanceVariable1 instanceVariable2''	classVariableNames: ''ClassVariable1''	poolDictionaries: ''TextConstants''	category: #''Refactory-Testing'''.  newClass := tmp1 classNamed: #SomeClassNametestClassVariable  self shouldFail: (RBSplitClassTransformation class: #RBDummyLintRuleTest instanceVariables: #(Foo1) newClassName: #RBDummyLintRuleTest123 referenceVariableName: #receiver) asRefactoringmatcher: arg1  matcher := arg1stringConcatenation  | tmp1 |  tmp1 := '' yourself.  (1 to: 10) do: [:arg1 |  tmp1 := tmp1 , arg1 printString ].  ^tmp1isTransformationRule  ^truetestRoots  | tmp1 |  tmp1 := modelFactory rbNamespace new.  self assert: (tmp1 rootClasses asSortedCollection: [:arg1 :arg2 |  arg1 name < arg2 name ]) asArray equals: ((Class rootsOfTheWorld collect: [:arg3 |  tmp1 classFor: arg3 ]) asSortedCollection: [:arg1 :arg2 |  arg1 name < arg2 name ]) asArraypullUpMethods  selectors do: [:arg1 |  self pullUp: arg1 ]preconditionsForClassVariable  ^(RBCondition isMetaclass: class) not & (RBCondition definesClassVariable: variableName in: class) & (RBCondition accessesClassVariable: variableName in: class showIn: self)testPerformRenameClassVariable  | tmp1 |  tmp1 := changes renameClassVariable: 'ClassVar' to: 'ClassVarPlus' in: self changeMock.  self perform: tmp1 do: [ self deny: (tmp1 changeClass classVarNames includes: tmp1 oldName).        self assert: (tmp1 changeClass classVarNames includes: tmp1 newName) ].  self assert: (tmp1 changeClass classVarNames includes: tmp1 oldName).  self deny: (tmp1 changeClass classVarNames includes: tmp1 newName)abstractClassVariable: arg1  | tmp1 tmp2 tmp3 |  tmp3 := fromClass instanceSide.  tmp1 := RBCreateAccessorsForVariableRefactoring model: self model variable: arg1 class: tmp3 classVariable: true.  self performComponentRefactoring: tmp1.  tmp2 := RBParseTreeRewriter new.  fromClass isMeta ifTrue: [ tmp2           replace: arg1 , ' := ``@object' with: ('self <1s> ``@object' expandMacrosWith: tmp1 setterMethod);           replace: arg1 with: 'self ' , tmp1 getterMethod ] ifFalse: [ tmp2           replace: arg1 , ' := ``@object' with: ('self class <1s> ``@object' expandMacrosWith: tmp1 setterMethod);           replace: arg1 with: 'self class ' , tmp1 getterMethod ].  (tmp2 executeTree: tree) ifTrue: [ tree := tmp2 tree ]testModelChildrenToSibling  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := model classNamed: #ConcreteSuperclass.  tmp3 := model classNamed: #ConcreteSubclass.  tmp1 := RBChildrenToSiblingsRefactoring model: model name: #AbstractSuperclass class: tmp2 subclasses: (Array with: tmp3).  self executeRefactoring: tmp1.  tmp4 := tmp1 model classNamed: #AbstractSuperclass.  self assert: tmp2 superclass equals: tmp4.  self assert: tmp2 classSide superclass equals: tmp4 classSide.  self assert: tmp3 superclass equals: tmp4.  self assert: tmp3 classSide superclass equals: tmp4 classSide.  self assert: (tmp4 parseTreeFor: #same) equals: (self parseMethod: 'same ^self initialize isKindOf: AbstractSuperclass').  self assert: (tmp4 parseTreeFor: #different) equals: (self parseMethod: 'different self subclassResponsibility').  self assert: (tmp4 parseTreeFor: #initialize) equals: (self parseMethod: 'initialize							instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0').  self assert: (tmp4 directlyDefinesInstanceVariable: 'instVarName1').  self assert: (tmp4 directlyDefinesInstanceVariable: 'instVarName2').  self assert: (tmp4 directlyDefinesClassVariable: 'ClassVarName1').  self assert: (tmp4 directlyDefinesClassVariable: 'ClassVarName2').  self assert: (tmp4 classSide directlyDefinesInstanceVariable: 'classInstVarName1').  self assert: (tmp4 classSide parseTreeFor: #foo) equals: (self parseMethod: 'foo							^classInstVarName1 + ClassVarName1 + ClassVarName2').  self assert: (tmp4 classSide parseTreeFor: #new) equals: (self parseMethod: 'new							^super new initialize').  self assert: (tmp4 classSide parseTreeFor: #bar) equals: (self parseMethod: 'bar							self subclassResponsibility').  self deny: (tmp2 directlyDefinesInstanceVariable: 'instVarName1').  self deny: (tmp2 directlyDefinesInstanceVariable: 'instVarName2').  self deny: (tmp2 directlyDefinesClassVariable: 'ClassVarName1').  self deny: (tmp2 directlyDefinesClassVariable: 'ClassVarName2').  self deny: (tmp2 classSide directlyDefinesInstanceVariable: 'classInstVarName1').  self deny: (tmp2 directlyDefinesMethod: #same).  self deny: (tmp2 directlyDefinesMethod: #initialize).  self deny: (tmp2 classSide directlyDefinesMethod: #new).  self assert: (tmp2 parseTreeFor: #different) equals: (self parseMethod: 'different							^instVarName1 + instVarName2').  self assert: (tmp2 classSide parseTreeFor: #bar) equals: (self parseMethod: 'bar							^self printString')findAndReplaceOcurrencesIn: arg1  | tmp1 |  tmp1 := self findOcurrencesIn: arg1 selector of: arg1 origin.  tmp1 ifNotEmpty: [ self replaceOcurrences: tmp1 on: arg1 ]printOn: arg1  self storeOn: arg1abstractVariableTestData  | tmp1 tmp2 tmp3 |  tmp3 := #(#Bar #Foo) inject: OrderedCollection new into: [:arg1 :arg2 |  testingEnvironment at: arg2 ifPresent: [:arg3 |  arg1                 add: arg3;                 add: arg3 class ].        arg1 ].  tmp2 := RBClassEnvironment classes: tmp3.  tmp1 := RBClassModelFactory rbNamespace onEnvironment: tmp2 not.  tmp1 name: 'Test'.  #('Object subclass: #Foo		instanceVariableNames: ''instVarName1 instVarName2''		classVariableNames: ''ClassVarName1 ClassVarName2 ''		poolDictionaries: ''''		category: ''Testing'' ' 'Foo subclass: #Bar		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ') do: [:arg2 |  tmp1 defineClass: arg2 ].  #(#(#Bar #(#('instVarName1			^1242321' #tests) #('foo			instVarName1 := instVarName1 + instVarName2 + ClassVarName1' #tests))) #(#Foo #(#('foo			^instVarName2 := 3' #tests) #('bar			"Add one to instVarName1"			instVarName1 := instVarName1 + 1' #tests) #('classVarName1			^ClassVarName1' #tests) #('instVarName1: anObject			^anObject' #tests) #('asdf			^self classVarName1: (ClassVarName1 := ClassVarName1 + 1)' #tests) #('instVarName2			^instVarName2' #tests) #('instVarName2: anObject			instVarName2 := anObject' #tests) #('classVarName1: anObject			^ClassVarName1 := anObject' #tests))) #('Bar class' #(#('classVarName2: anObject			ClassVarName2 := anObject' #tests) #('classVarName2			^ClassVarName2' #tests))) #('Foo class' #(#('foo			^ClassVarName1 := ClassVarName1 * ClassVarName1 * ClassVarName1' #tests)))) do: [:arg2 |  | tmp4 |        arg3 := tmp1 classNamed: arg2 first.        arg2 last do: [:arg4 |  arg3 compile: arg4 first classified: arg4 last ] ].  ^tmp1testAddToModel  | tmp1 |  model := RBClassModelFactory rbNamespace new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''fdsa'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  tmp1 := RBAddInstanceVariableRefactoring model: model variable: 'asdf' class: (model classNamed: #FOOBAR).  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #FOOBAR) directlyDefinesInstanceVariable: 'asdf')addUndoPointer: arg1  undoPointers push: arg1& arg1  self isSystem ifTrue: [ ^arg1 ].  arg1 isSystem ifTrue: [ ^self ].  ^RBAndEnvironment onEnvironment: self and: arg1model  ^model ifNil: [ model := self newModel ]check  ^block valuetestNonExistantName  self shouldFail: (RBAddParameterRefactoring addParameterToMethod: #name1 in: RBLintRuleTestData newSelector: #name1: initializer: 'nil')changes  ^self model changesreplaceArguments  sourceMessage arguments reversed with: inlineParseTree arguments reversed do: [:arg1 :arg2 |  (arg1 isImmediateNode or: [ self shouldInlineExpression: arg1 newSource ]) ifTrue: [ self replaceArgument: arg2 with: arg1 ] ifFalse: [ self addTemporary: arg2 assignedTo: arg1 ] ]setUp  super setUp.  self createMockClass.  model := RBNamespace2 newtestInlineEmptyComponentMethod  | tmp1 |  self proceedThroughWarning: [ tmp1 := RBInlineMethodFromComponentRefactoring inline: (35 to: 91) inMethod: #inlineComponent forClass: RBRefactoryTestDataApp.        self setupInlineExpressionFor: tmp1 toReturn: false.        self setupImplementorToInlineFor: tmp1 toReturn: (tmp1 model classNamed: #Object).        self executeRefactoring: tmp1 ].  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineComponent) equals: (self parseMethod: 'inlineComponent	| a anObject |	a := 5.	anObject := a class.	anObject superclass.	anObject hasImmediateInstances.	^anObject')instanceVariableNames  ^instanceVariableNamesseverity  ^#informationstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' replace: ''';     nextPutAll: oldSourceCode;     nextPutAll: ''' to: ''';     nextPutAll: newSourceCode;     nextPutAll: ''' inMethod: #';     nextPutAll: selector;     nextPutAll: ' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)name: arg1  ^changes name: arg1preconditions  ^(RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ | tmp1 |              tmp1 := self parserClass parseExpression: sourceCode onError: [:arg1 :arg2 |  self refactoringError: 'Invalid source to extract - ' , arg1 ].              tmp1 ifNil: [ self refactoringError: 'Invalid source to extract - ' , sourceCode ].              (tmp1 isSequence and: [ tmp1 statements isEmpty ]) ifTrue: [ self refactoringError: 'Selected code to extract is empty' ].              tmp1 := ((self definingClass parseTreeFor: selector) extractSubtreeWith: sourceCode) ifNil: [ self refactoringError: 'Could not extract code from method ' , selector ].              true ])changesSize  ^changes inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 changesSize ]propagateTransformation  self renameMessageSendsnumberClasses  ^self classNames sizetestReturn  self shouldFail: (RBInlineMethodRefactoring inline: (418 to: 485) inMethod: #utilityMethods forClass: RBBasicLintRuleTestData class)reference  ^RBClassToRename newexistingMethodsThatReferToClassVariable: arg1  | tmp1 tmp2 |  tmp1 := (self bindingOf: arg1) ifNil: [ ^#() ].  tmp2 := self realClass whichSelectorsReferTo: tmp1.  (newMethods isNil and: [ removedMethods isNil ]) ifTrue: [ ^tmp2 ].  ^tmp2 reject: [:arg2 |  (self hasRemoved: arg2) or: [ self newMethods includesKey: arg2 ] ]preconditionHasNoUsers: arg1  ^(RBCondition withBlock: [ (arg1 realClass users copyWithoutAll: classNames) isEmpty ])     errorMacro: arg1 name , ' Trait is used.<n>Browse classes using it?';     errorBlock: [ self openBrowserOn: (self environmentWithUsersOf: arg1) ];     yourselfnameToDisplay  ^'Rename ' , self oldName , ' into ' , self newNametestRemoveClassNamed  | tmp1 |  tmp1 := changes removeClassNamed: self class name.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self universalTestFor: tmp1definingClass  ^class ifNil: [ class := self model classObjectFor: self className ]preconditionsForClassVariable  ^(RBCondition definesClassVariable: variableName in: self definingClass) & (RBCondition withBlock: [ | tmp1 |              tmp1 := self definingClass subclasses count: [:arg1 |  arg1 withAllSubclasses anySatisfy: [:arg2 |  (arg2 whichSelectorsReferToClassVariable: variableName) isNotEmpty or: [ (arg2 theMetaClass whichSelectorsReferToClassVariable: variableName) isNotEmpty ] ] ].              tmp1 < 2 ])selector  ^selectorcategories  ^self systemDictionary organization categories select: [:arg1 |  self includesCategory: arg1 ]preconditions  | tmp1 |  tmp1 := self myConditions & (RBCondition definesSelector: oldSelector in: class) & (RBCondition isValidMethodName: newSelector for: class).  tmp1 := self implementors inject: tmp1 into: [:arg1 :arg2 |  arg1 & (RBCondition hierarchyOf: arg2 canUnderstand: newSelector) not ].  ^tmp1 & (RBCondition withBlock: [ self implementors size > 1 ifTrue: [ self refactoringWarning: ('This will modify all <1p> implementors.' expandMacrosWith: self implementors size) ].              true ])replaceVariableReferences  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1 replace: variable with: 'self'.  tmp1 executeTree: parseTree.  parseTree := tmp1 treedefinitionClass  ^self changeClass= arg1  ^super = arg1 and: [ self variable = arg1 variable ]setupMethodNameFor: arg1 toReturn: arg2 withArguments: arg3  | tmp1 |  tmp1 := arg1 options copy.  tmp1 at: #methodName put: [:arg4 :arg5 |  arg5           selector: arg2;           arguments: arg3;           yourself ].  arg1 options: tmp1compiledMethod  ^self compiledMethodIn: class realClasscheckSiblingSuperSendsFrom: arg1  arg1 selectors do: [:arg2 |  | tmp1 |        tmp1 := arg1 parseTreeFor: arg2.        tmp1 ifNotNil: [ tmp1 superMessages do: [:arg3 |  (selectors includes: arg3) ifTrue: [ | tmp2 |                          tmp2 := arg1 superclass whoDefinesMethod: arg3.                          (tmp2 notNil and: [ class includesClass: tmp2 ]) ifTrue: [ self refactoringError: ('Cannot pull up <1s> since <2p>>><3s> sends a super message to it.' expandMacrosWith: arg3 with: arg1 with: arg2) ] ] ] ] ].  arg1 allSubclasses do: [:arg2 |  self checkSiblingSuperSendsFrom: arg2 ]ifTrueReturns  self isSymbol ifFalse: [ ^true ].  ^falsenewClass  ^self model classNamed: newNamerenameChangesForClass: arg1 to: arg2  ^self changeClassName = arg1 ifFalse: [ self ] ifTrue: [ self copy           changeClassName: arg2;           yourself ]newName: arg1  newName := arg1protocol  ^self protocols firstrenameReferences  | tmp1 |  tmp1 := (RBParseTreeRewriter replaceLiteral: className with: newName)     replace: className with: newName;     replaceArgument: newName withValueFrom: [:arg1 |  self refactoringFailure: newName , ' already exists within the reference scope' ];     yourself.  self model allReferencesToClass: class do: [:arg2 |  (arg2 modelClass hierarchyDefinesVariable: newName) ifTrue: [ self refactoringFailure: newName , ' is already defined in hierarchy of ' , arg2 modelClass printString ].        self convertMethod: arg2 selector for: arg2 modelClass using: tmp1 ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' variable: '.  variableName storeOn: arg1.  arg1 nextPutAll: ' class: '.  className storeOn: arg1.  arg1 nextPutAll: ' classVariable: '.  isClassVariable storeOn: arg1.  arg1 nextPut: $)parseTreeSearcher  ^RBParseTreeSearcher newselectVariableToMoveMethodTo: arg1 class: arg2  ^(self options at: #selectVariableToMoveTo) value: self value: arg2 value: arg1definesClass: arg1  ^(environment definesClass: arg1) and: [ andedEnvironment definesClass: arg1 ]refineTypes: arg1 with: arg2  | tmp1 |  tmp1 := Set new.  arg1 do: [:arg3 |  arg2 do: [:arg4 |  (arg4 includesClass: arg3) ifTrue: [ tmp1 add: arg4 ] ifFalse: [ (arg3 includesClass: arg4) ifTrue: [ tmp1 add: arg3 ] ] ] ].  ^tmp1openBrowserOn: arg1  ^(self options at: #openBrowser) value: self value: arg1copyOldValuesToNewVariable  | tmp1 |  tmp1 := self changeClass classPool at: oldName ifAbsent: [ nil ].  self changeClass classPool at: newName asSymbol put: tmp1parseTreeFor: arg1  | tmp1 |  tmp1 := self whoDefinesMethod: arg1.  tmp1 ifNil: [ ^nil ].  ^(tmp1 methodFor: arg1) parseTreereplaceOcurrences: arg1 on: arg2  arg1 ifNotEmpty: [ | tmp1 tmp2 tmp3 |        tmp3 := arg1 size.        replaceAll ifTrue: [ self extract: (self orderOcurrences: arg1) of: arg2 executing: #execute.              tmp3 := tmp3 - 1 ] ifFalse: [ tmp1 := self extract: (self orderOcurrences: arg1) of: arg2 executing: #primitiveExecute.              tmp2 := (RBReplacePreview change: tmp1)                 cancelAction: [:arg3 |  listToFindMatches := Array new.                    tmp3 := -1.                    arg3                       beCancel;                       close ];                 skipAction: [:arg3 |  positionIndex := positionIndex + 1.                    tmp3 := tmp3 + 1.                    arg3                       beOk;                       close ];                 replaceAllAction: [:arg3 |  replaceAll := true.                    arg3                       beOk;                       close ];                 open.              tmp2 cancelled ifFalse: [ tmp3 := tmp3 - 1 ] ].        tmp3 >= positionIndex ifTrue: [ self findAndReplaceOcurrencesIn: arg2 ] ]method: arg1 class: arg2  method := arg1.  class := self classObjectFor: arg2methodsUsingClassVariableNamed: arg1  ^(self realClass classVariableNamed: arg1) usingMethods collect: [:arg2 |  | tmp1 |        tmp1 := self model classNamed: arg2 methodClass name.        tmp1 methodFor: arg2 selector ]accessorMethods  ^#(#instanceVariables #instanceVariableReaders #instanceVariableWriters #classVariables)primitiveExecute  self changeClass classComment: comment stamp: self changeStamp.  SystemAnnouncer uniqueInstance classCommented: self changeClasstestPullUpAndCopyDown  | tmp1 |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  tmp1 := model classNamed: #Foo1.  tmp1 compile: 'yourself ^1' classified: #(#accessing).  self proceedThroughWarning: [ self executeRefactoring: (RBPullUpMethodRefactoring model: model pullUp: #(#yourself) from: tmp1) ].  self assert: (tmp1 superclass parseTreeFor: #yourself) equals: (self parseMethod: 'yourself ^1').  self deny: (tmp1 directlyDefinesMethod: #yourself).  tmp1 := model classNamed: #Foo2.  self assert: (tmp1 directlyDefinesMethod: #yourself).  self assert: (tmp1 parseTreeFor: #yourself) equals: ((model classNamed: #Object) parseTreeFor: #yourself)changeString  ^'Add pool variable <1s> to <2s>' expandMacrosWith: self variable with: self displayClassNamechangeClass: arg1  isMeta := arg1 isMeta.  className := isMeta ifTrue: [ arg1 soleInstance name ] ifFalse: [ arg1 name ]flagged  self flag: #pharoTodohasConflicts  ^falseprotocolsFor: arg1  arg1 classesAndSelectorsDo: [:arg2 :arg3 |  | tmp1 |        tmp1 := arg1 whichProtocolIncludes: arg3 in: arg2.        self assert: (arg1 includesProtocol: tmp1 in: arg2) ]checkMethod: arg1  (self basicCheck: arg1) ifTrue: [ self builder compile: rewriteRule tree newSource in: class classified: arg1 protocol ]newSelectorString  | tmp1 tmp2 |  tmp1 := WriteStream on: String new.  tmp2 := newSelector keywords.  1 to: tmp2 size do: [:arg1 |  tmp1 nextPutAll: (tmp2 at: arg1).        arg1 == tmp2 size ifTrue: [ tmp1                 nextPut: $(;                 nextPutAll: initializer;                 nextPut: $) ] ifFalse: [ tmp1                 nextPutAll: ' ``@arg';                 nextPutAll: arg1 printString ].        tmp1 nextPut: $  ].  ^tmp1 contentsstoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' className: '.  className storeOn: arg1.  arg1 nextPut: $)addClass: arg1 instanceVariable: arg2  (instanceVariables at: arg1 name ifAbsentPut: [ Set new ]) add: arg2.  self flushCachesFor: arg1.  self addSearchString: arg2transform  | tmp1 tmp2 tmp3 |  tmp3 := class methodFor: selector.  tmp1 := tmp3 parseTree.  tmp1 ifNil: [ self refactoringFailure: 'Could not parse method' ].  class addInstanceVariable: temporaryVariableName.  (tmp2 := RBParseTreeRewriter removeTemporaryNamed: temporaryVariableName) executeTree: tmp1.  tmp3 compileTree: tmp2 treetestNeedsReturn  | tmp1 tmp2 |  tmp1 := (RBExtractMethodTransformation extract: 'rules isEmpty ifTrue: [^self].						rules size == 1 ifTrue: [^rules first viewResults]' from: #openEditor to: #foo: in: #RBDummyLintRuleTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: #RBDummyLintRuleTest.  self assert: (tmp2 parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor				| rules |				rules := self failedRules.				^self foo: rules').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: rules				rules isEmpty ifTrue: [^self].				rules size == 1 ifTrue: [^rules first viewResults]')oldName  ^oldNamestoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' className: '.  className storeOn: arg1.  arg1 nextPut: $)findSetterMethod  | tmp1 tmp2 |  tmp1 := self definingClass.  tmp2 := self needsReturnForSetter ifTrue: [ self parseTreeSearcherClass returnSetterMethod: variableName ] ifFalse: [ self parseTreeSearcherClass setterMethod: variableName ].  ^self possibleSetterSelectors detect: [:arg1 |  (self checkClass: tmp1 selector: arg1 using: tmp2) notNil and: [ (tmp1 subclassRedefines: arg1) not ] ] ifNone: [ nil ]instanceSide  ^model classNamed: self namerenameClassVariable: arg1 to: arg2 around: arg3  self privateClassVariableNames at: (self privateClassVariableNames indexOf: arg1 asSymbol) put: arg2 asSymbol.  ^self model performChange: (changeFactory renameClassVariable: arg1 to: arg2 in: self) around: arg3caller1  | tmp1 |  tmp1 := 5.  self called: tmp1 + 1 on1: [:arg1 |  arg1 printString.        ^tmp1 ]verifySelectedInterval  sourceTree := class parseTreeFor: selector.  sourceTree ifNil: [ self refactoringFailure: 'Could not parse source' ].  assignmentNode := sourceTree whichNodeIsContainedBy: sourceInterval.  assignmentNode isAssignment ifFalse: [ self refactoringFailure: 'The selected node is not an assignment statement' ].  definingNode := assignmentNode whoDefines: assignmentNode variable name.  self hasOnlyOneAssignment ifFalse: [ self refactoringError: 'There are multiple assignments to the variable' ].  (RBReadBeforeWrittenTester isVariable: assignmentNode variable name writtenBeforeReadIn: definingNode) ifFalse: [ self refactoringError: 'The variable is possible read before it is assigned' ]collectionMessagesToExternalObject  self someObject collection remove: 10nonUnaryAccessingBranchingStatementMethodWithoutReturn: arg1  self value isString ifTrue: [ self value ] ifFalse: [ '' ]testRenameTemporary  | tmp1 |  tmp1 := RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'asdf' in: RBLintRuleTestData selector: #openEditor.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBLintRuleTestData) parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor								| asdf |								asdf := self failedRules.								asdf isEmpty ifTrue: [^self].								asdf size == 1 ifTrue: [^asdf first viewResults]')checksPreconditions  self preconditionChecking: truenotifyUserOfCommand: arg1  | tmp1 tmp2 |  tmp2 := 'Warning. Want to proceed?'.  tmp1 := UIManager default confirm: self messageText label: tmp2.  tmp1 ifTrue: [ self resume: true ]classNamesFor: arg1  ^(self systemDictionary organization listAtCategoryNamed: arg1) select: [:arg2 |  | tmp1 |        tmp1 := self systemDictionary at: arg2 ifAbsent: [ nil ].        tmp1 notNil and: [ (self includesClass: tmp1) or: [ self includesClass: tmp1 class ] ] ]requestSuperClass  ^(self options at: #superClass) value: selfchanges  ^self builder changesremoveChange: arg1  ^changes remove: arg1 ifAbsent: [ nil ]inlineClass  | tmp1 |  inlineClass ifNotNil: [ ^inlineClass ].  tmp1 := (self model allImplementorsOf: self inlineSelector) asOrderedCollection.  tmp1 size = 1 ifTrue: [ ^inlineClass := tmp1 first ].  tmp1 ifEmpty: [ self refactoringFailure: 'Nobody defines a method named ' , self inlineSelector ].  inlineClass := self requestImplementorToInline: tmp1.  inlineClass ifNil: [ self refactoringFailure: 'No implementor selected' ].  ^inlineClasschangeString  ^self displayClassName , '>>' , self selectorhash  ^selector hashtransformations  ^transformations ifNil: [ transformations := self buildTransformations ]categoriesFor: arg1  | tmp1 |  tmp1 := IdentitySet withAll: universalEnvironment categories.  tmp1 removeAll: arg1 categories.  arg1 not categories do: [:arg2 |  tmp1 remove: arg2 ifAbsent: [  ] ].  tmp1 do: [:arg2 |  self assertEmpty: (universalEnvironment classNamesFor: arg2) ]assert: arg1 description: arg2 resumable: arg3  | tmp1 |  arg1 value ifFalse: [ | tmp2 |        tmp2 := arg2 value.        tmp1 := arg3 ifTrue: [ self classForTestResult resumableFailure ] ifFalse: [ self classForTestResult failure ].        tmp1 signal: tmp2 ]isMeta  ^falsecheckSuperMethods  | tmp1 tmp2 |  tmp2 := OrderedCollection new.  tmp1 := OrderedCollection new.  (selectors reject: [:arg1 |  self justSendsSuper: arg1 ]) do: [:arg1 |  (self superclassEquivalentlyDefines: arg1) ifTrue: [ (class parseTreeFor: arg1) superMessages isEmpty ifFalse: [ tmp1 add: arg1 ] ] ifFalse: [ tmp2 add: arg1 ] ].  tmp2 isEmpty & tmp1 isEmpty ifTrue: [ ^self ].  self checkReferencesToAnyOf: tmp2.  self checkReferencesToSuperSendsToAnyOf: tmp1findSelectedMessage  sourceParseTree := class parseTreeFor: sourceSelector.  sourceParseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ].  sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.  sourceMessage ifNil: [ self refactoringFailure: 'The selection doesn''t appear to be a message send' ].  sourceMessage isCascade ifTrue: [ sourceMessage := sourceMessage messages last ].  sourceMessage isMessage ifFalse: [ self refactoringFailure: 'The selection doesn''t appear to be a message send' ].  sourceMessage receiver isSelfOrSuper ifFalse: [ self refactoringError: 'Cannot inline non-self messages' ]testPerformAddRemoveClassMethod  | tmp1 |  tmp1 := changes compile: 'method ^ 1' in: self changeMock class classified: #utilities.  self perform: tmp1 do: [ self assert: (self changeMock respondsTo: #method) ].  self deny: (self changeMock respondsTo: #method).  self assert: tmp1 definedSelector equals: #methodasRefactoring  ^super asRefactoring     delegatesPreconditions: false;     yourselfselectEnvironment: arg1  environment := environmentDictionaries at: arg1 ifAbsent: [ RBSelectorEnvironment new ]testAddParameterThatReferencesSelf  | tmp1 tmp2 |  tmp1 := RBAddParameterRefactoring addParameterToMethod: ('test' , 'Foo:') asSymbol in: RBRefactoryTestDataApp newSelector: #testFoo:bar: initializer: 'self printString'.  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #testFoo:bar:) equals: (self parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').  self assert: (tmp2 parseTreeFor: #callFoo) equals: (self parseMethod: 'callFoo ^self testFoo: 5 bar: (self printString)').  self deny: (tmp2 directlyDefinesMethod: ('test' , 'Foo:') asSymbol)testInvalidSubclass  self shouldFail: (RBChildrenToSiblingsRefactoring name: #Foo class: RBRefactoringTest subclasses: (Array with: RBBasicLintRuleTestData with: RBCompositeLintRuleTestData))parserClass  ^RBParsertestMoveDefinitionIntoBlockThatIsAReceiverOfACascadedMessage  | tmp1 tmp2 |  tmp1 := (RBMoveTemporaryVariableDefinitionTransformation variable: #association inMethod: #referencesConditionFor: inClass: #RBDummyRefactoryTestDataApp) asRefactoring transform.  tmp2 := tmp1 model classNamed: #RBDummyRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #referencesConditionFor:) equals: (self parseMethod: 'referencesConditionFor: aClass 						| environment  |						^(RBCondition withBlock: 								[| association |association := Smalltalk associationAt: aClass name											ifAbsent: [self refactoringError: ''Could not find class''].								environment := (self environment referencesTo: association) 											| (self environment referencesTo: aClass name).								environment isEmpty])							errorMacro: aClass , '' is referenced.<n>Browse references?'';							errorBlock: [environment openEditor];							yourself')asUndoOperation  ^(self changeClass includesSelector: self selector) ifTrue: [ | tmp1 |        tmp1 := RBBrowserEnvironment new whichProtocolIncludes: self selector in: self changeClass.        tmp1 ifNil: [ tmp1 := #accessing ].        changeFactory addMethodSource: (self methodSourceFor: self selector) in: self changeClass classified: tmp1 ] ifFalse: [ changeFactory removeMethod: selector from: self changeClass ]testConstructedClassEnvironment  | tmp1 |  tmp1 := RBClassEnvironment new.  tmp1     addClass: Object;     addClass: OrderedCollection;     addClass: Collection.  self assert: (tmp1 includesClass: Object).  self assert: (tmp1 includesClass: OrderedCollection).  self assert: (tmp1 includesClass: Collection).  self deny: (tmp1 includesClass: Object class).  tmp1 removeClass: Collection.  self assert: (tmp1 includesClass: Object).  self assert: (tmp1 includesClass: OrderedCollection).  self deny: (tmp1 includesClass: Collection).  self assert: tmp1 numberClasses equals: 2.  tmp1 addClass: Object class.  self assert: tmp1 numberClasses equals: 2.  self assert: (tmp1 includesClass: Object class).  tmp1 removeClass: self class.  self assert: tmp1 numberClasses equals: 2preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition hierarchyOf: class definesVariable: temporaryVariableName asString) not & (RBCondition withBlock: [ self checkForValidTemporaryVariable.              true ])collectSelectNotUsed  (1 to: 10) select: [:arg1 |  arg1 = 4 ]pullUp: arg1  | tmp1 tmp2 |  tmp1 := class sourceCodeFor: arg1.  tmp1 ifNil: [ self refactoringFailure: 'Source for method not available' ].  tmp2 := RBExpandReferencedPoolsRefactoring model: self model forMethod: (class parseTreeFor: arg1) fromClass: class toClasses: (Array with: targetSuperclass).  self performComponentRefactoring: tmp2.  targetSuperclass compile: tmp1 classified: (class protocolsFor: arg1)gtInspectorChildren  ^{left .   right}resetResult  builder := RBRefactoryChangeManager changeFactory compositeRefactoryChangepreconditions  ^classNames inject: RBCondition empty into: [:arg1 :arg2 |  | tmp1 |        tmp1 := self model classNamed: arg2 asSymbol.        tmp1 ifNil: [ self refactoringFailure: 'No such class or trait' ].        arg1 & ((self preconditionIsNotMetaclass: tmp1) & (self preconditionHasNoReferences: arg2) & (self preconditionEmptyOrHasNoSubclasses: tmp1) & (self preconditionHasNoUsers: tmp1)) ]openEditor  | tmp1 |  tmp1 := self failedRules.  tmp1 isEmpty ifTrue: [ ^self ].  tmp1 size == 1 ifTrue: [ ^tmp1 first viewResults ]sourceCode  ^tree formattedCodetestTransform  | tmp1 tmp2 |  tmp1 := (RBRemoveReturnStatementTransformation new return: '^ variable' inMethod: #methodBefore inClass: self class name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyrenameClassVariable: arg1 to: arg2 around: arg3  self privateClassVariableNames at: (self privateClassVariableNames indexOf: arg1 asSymbol) put: arg2 asSymbol.  model renameClassVariable: arg1 to: arg2 in: self around: arg3setUp  super setUp.  model := self abstractVariableTestDatabuilder  ^builder ifNil: [ self resetResult.        builder ]objectClassVariable  ^Object classPool keys detect: [:arg1 |  true ]testModelAddClassVariable  | tmp1 |  tmp1 := (RBAddVariableTransformation model: model classVariable: #ClassVarName3 class: (model classNamed: #Bar)) asRefactoring transform.  self assert: ((model classNamed: #Bar) directlyDefinesClassVariable: #ClassVarName3)selector: arg1 from: arg2  self className: arg2.  selector := arg1argumentList  ^self methodName ifNil: [ OrderedCollection new ] ifNotNil: [:arg1 |  arg1 arguments copy ]testPullUpClassVariable  | tmp1 |  tmp1 := RBPullUpClassVariableRefactoring variable: #RecursiveSelfRule class: RBLintRuleTestData.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBLintRuleTestData) directlyDefinesClassVariable: #RecursiveSelfRule).  self deny: ((tmp1 model classNamed: #RBTransformationRuleTestData) directlyDefinesClassVariable: #RecursiveSelfRule)oldVersionTextToDisplay  | tmp1 |  tmp1 := (onSystemDictionary classNamed: className) ifNil: [ ^super oldVersionTextToDisplay ].  isMeta ifTrue: [ tmp1 := tmp1 classSide ].  ^tmp1 methodDict at: self selector ifPresent: [:arg1 |  arg1 sourceCode ] ifAbsent: [ super oldVersionTextToDisplay ]postCopy  super postCopy.  keywords := keywords copypreconditions  ^(RBCondition definesSelector: method selector in: class) nottestRemoveClassWithReferencesRaisesRBRefactoringError  self shouldFail: (RBRemoveClassRefactoring classNames: #(#RBBasicLintRuleTestData))initialize  super initialize.  self anInstVar: 1.  classBlock := [:arg1 :arg2 |   ].  methodBlock := [:arg1 :arg2 |   ].  self resultClass: RBSelectorEnvironmentprivateTransform  | tmp1 tmp2 |  tmp1 := self definingMethod.  tmp2 := (tmp1 allChildren select: [:arg1 |  arg1 isSequence ]) detect: [:arg2 |  arg2 defines: variableName ] ifNone: [ nil ].  tmp2 ifNotNil: [ tmp2 removeTemporaryNamed: variableName ].  class compileTree: tmp1testRenameTestMethod1  | tmp1 tmp2 |  tmp1 := RBRenameMethodRefactoring renameMethod: 'testMethod1' asSymbol in: RBRefactoryTestDataApp to: #testMethod2 permutation: (1 to: 0).  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #testMethod2) equals: (self parseMethod: 'testMethod2	^self testMethod2 , ([:each | each testMethod2] value: #(#(#testMethod2) 2 #testMethod2))').  self assert: ((tmp1 model classNamed: #RBBasicLintRuleTestData) parseTreeFor: #classBlock:) equals: (self parseMethod: 'classBlock: aBlock	classBlock := aBlock testMethod2').  self deny: (tmp2 directlyDefinesMethod: ('test' , 'Method1') asSymbol)isAbstract  (self whichSelectorsReferToSymbol: #subclassResponsibility) ifNotEmpty: [ ^true ].  model allReferencesToClass: self do: [:arg1 |  ^false ].  ^trueinitialize  name := ''addNewVariable  self subclassResponsibilityviewResults  rules do: [:arg1 |  arg1 viewResults ]transform  class addClassVariable: variableNametestNoMoveDefinition  self shouldFail: (RBMoveVariableDefinitionRefactoring bindTight: (21 to: 24) in: RBRefactoryTestDataApp selector: #noMoveDefinition)executeShould: arg1 inScopeOf: arg2 withExceptionDo: arg3  ^[ arg1 value.  false ] on: arg2 do: [:arg4 |  arg3 value: arg4.        arg4 return: true ]inlineMax  | tmp1 tmp2 tmp3 |  tmp1 := 5.  tmp2 := 10.  tmp3 := tmp1 + 1 max: tmp2.  ^tmp3deny: arg1  self assert: arg1 value notchanges  ^changestestAddInstanceVariable  | tmp1 |  tmp1 := changes addInstanceVariable: 'instVar' to: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 variable equals: 'instVar'.  self universalTestFor: tmp1addClass: arg1 superclass: arg2 category: arg3  self addClass: arg1 superclass: arg2 asSymbol subclasses: OrderedCollection new category: arg3testRenamePrimitive  | tmp1 tmp2 |  tmp2 := 0.  model allReferencesTo: #basicAt:put: do: [:arg1 |  tmp2 := tmp2 + 1 ].  tmp1 := RBRenameMethodRefactoring model: model renameMethod: #basicAt:put: in: Object to: ('at:' , 'bar:') asSymbol permutation: (1 to: 2).  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  model allReferencesTo: #basicAt:put: do: [:arg1 |  tmp2 := tmp2 - 1.        self assert: arg1 source isNil ].  model allReferencesTo: ('at:' , 'bar:') asSymbol do: [:arg1 |  tmp2 := tmp2 - 1 ].  self assert: tmp2 equals: 0testAssignmentDoesNotExist  | tmp1 |  tmp1 := (RBAddTemporaryVariableTransformation variable: 'variable2' inMethod: #methodBefore inClass: #RBRemoveAssignmentTransformationTest) asRefactoring transform.  self shouldFail: (RBRemoveAssignmentTransformation model: tmp1 model variable: 'variable2' value: '1 asString' inMethod: #methodBefore inClass: #RBRemoveAssignmentTransformationTest) asRefactoringusesAdd  ^(1 to: 10) asOrderedCollection addAll: (11 to: 20)testPerformAddRemoveMethod  | tmp1 |  tmp1 := changes compile: 'method ^ 1' in: self changeMock classified: #utilities.  self perform: tmp1 do: [ self assert: (self changeMock canUnderstand: #method) ].  self deny: (self changeMock canUnderstand: #method).  self assert: tmp1 definedSelector equals: #methodclassBlock: arg1  classBlock := arg1 testMethod1selectVariableTypesFrom: arg1 selected: arg2  ^(self options at: #variableTypes) value: self value: arg1 value: arg2transform  self deleteSelectorsallClassesAndTraitsDo: arg1  self systemDictionary allClassesAndTraitsDo: arg1checkSendersAccessTo: arg1  (#('self' 'super') includes: arg1) ifTrue: [ ^self ].  self senders detect: [:arg2 |  (self canReferenceVariable: arg1 in: arg2) not ] ifFound: [:arg3 |  self refactoringError: ('<1s> doesn''t appear to be defined in <2p>' expandMacrosWith: arg1 with: arg3) ]callMethod  ^self renameThisMethod: 5methodAfter  | tmp1 |  tmp1 := 'String'.  ^tmp1definitionClass  ^self changeClassmessageSend: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  message := arg1testModelExistingName  self shouldFail: (RBAddClassTransformation model: model addClass: #Foo superclass: #Object subclasses: #() category: #'Refactory-Testing') asRefactoringparserClass  ^RBParserpossibleGetterSelectors  ^self methodsReferencingVariable select: [:arg1 |  arg1 numArgs == 0 ]testBadCategoryName  self shouldFail: (RBMoveClassTransformation move: self class name to: #'Refactoring2-Transformations-Test') asRefactoringisArchitecturalRule  ^falsefindTypeFor: arg1  ^arg1 inject: self rootClasses into: [:arg2 :arg3 |  self refineTypes: arg2 with: (selectorLookup at: arg3 ifAbsentPut: [ self implementorsOf: arg3 ]) ]initialize: arg1  renrakuRule := arg1.  self initializeinstanceVariableNames: arg1  instanceVariableNames := arg1 asOrderedCollectiontestUnmarkRemovedClassIfRenameTargetClass  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := ('RBClass' , 'ToRename') asSymbol.  tmp4 := 'TestUnmarkClassRenameSource' asSymbol.  tmp5 := 'TestUnmarkClassRenameTarget' asSymbol.  tmp1 := RBAddClassRefactoring model: model addClass: tmp4 superclass: Object subclasses: {} category: self class package name.  self executeRefactoring: tmp1.  self assert: (model includesClassNamed: tmp3).  tmp2 := RBRenameClassRefactoring new     model: model;     className: tmp3 newName: tmp5;     yourself.  self executeRefactoring: tmp2.  self deny: (model includesClassNamed: tmp3).  self assert: (model includesClassNamed: tmp5).  tmp2 := RBRenameClassRefactoring new     model: model;     className: tmp4 newName: tmp3;     yourself.  self executeRefactoring: tmp2.  self deny: (model includesClassNamed: tmp4).  self assert: (model includesClassNamed: tmp5).  self assert: (model includesClassNamed: tmp3)preconditions  ^(RBCondition withBlock: [ self definingClass notNil and: [ self definingClass isMeta not ] ]) & (RBCondition isValidClassName: newClassName) & (RBCondition isGlobal: newClassName in: self model) not & (RBCondition withBlock: [ | tmp1 |              tmp1 := (self parseTreeRewriterClass replaceLiteral: className with: newClassName)                 replace: className with: newClassName;                 replaceArgument: newClassName withValueFrom: [:arg1 |  self refactoringError: newClassName , ' already exists within the reference scope' ];                 yourself.              self model allReferencesToClass: self definingClass do: [:arg2 |  (arg2 modelClass hierarchyDefinesVariable: newClassName) ifTrue: [ self refactoringError: newClassName , ' is already defined in hierarchy of ' , arg2 modelClass printString ].                    self convertMethod: arg2 selector for: arg2 modelClass using: tmp1 ].              true ]) | (RBCondition withBlock: [ self refactoringError: newClassName , ' is not a valid class name' ])addPool: arg1 to: arg2  ^changes addPool: arg1 to: arg2extraBlock  ^[:arg1 |  arg1 + 43 ] value: 45not  ^RBNegationCondition on: selfrelease  literalProcess ifNotNil: [ literalProcess terminate ].  super releaseincludesSelector: arg1 in: arg2  ^truetestImplementors  | tmp1 |  tmp1 := modelFactory rbNamespace new.  self assert: ((tmp1 allImplementorsOf: #printString) includes: (tmp1 classNamed: #Object)).  (tmp1 classNamed: #Object) removeMethod: #printString.  self deny: ((tmp1 allImplementorsOf: #printString) includes: (tmp1 classNamed: #Object))transform  self     renameConflictingTemporaries;     insertInlinedMethod;     compileMethodinitialize  super initialize.  packages := Set newrenameNode: arg1 withOldName: arg2 toWithName: arg3  (RBParseTreeRewriter rename: arg2 to: arg3) executeTree: arg1checkClass: arg1  rules do: [:arg2 |  arg2 checkClass: arg1 ]isOkEnabled  ^self methodName isNotNil and: [ self methodName isValid ]addPoolDictionary: arg1  self privatePoolDictionaryNames add: arg1 asSymbol.  model addPool: arg1 to: selfopenEditor  | tmp1 |  tmp1 := self failedRules.  tmp1 isEmpty ifTrue: [ ^self ].  tmp1 size == 1 ifTrue: [ ^tmp1 first viewResults ]unaryAccessingBranchingStatementMethodWithoutReturn  self value isString ifTrue: [ self value ] ifFalse: [ '' ]testAndEnvironmentWithStoreOn  | tmp1 tmp2 tmp3 |  tmp1 := universalEnvironment referencesTo: #storeOn:.  tmp2 := universalEnvironment forClass: Object selectors: #(#storeString).  tmp3 := tmp2 & tmp1.  self universalTestFor: tmp3.  self assert: tmp3 numberSelectors equals: 1.  self assert: tmp3 classNames asArray equals: #(#Object).  self assert: (tmp3 protocolsFor: Object) size equals: 1.  self assert: (tmp2 & tmp2) packages equals: tmp2 packages.  tmp3 := tmp1 & (universalEnvironment referencesTo: #printString).  self assert: tmp3 numberSelectors equals: (tmp1 referencesTo: #printString) numberSelectors.  self assert: tmp3 classNames asSortedCollection equals: (tmp1 referencesTo: #printString) classNames asSortedCollectiontestClassVariable  | tmp1 tmp2 |  tmp1 := (RBProtectVariableTransformation classVariable: 'RecursiveSelfRule' class: #RBTransformationRuleTestData) asRefactoring transform.  tmp2 := (tmp1 model classNamed: #RBTransformationRuleTestData) theMetaClass.  self assert: (tmp2 parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (tmp2 parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (tmp2 parseTreeFor: #nuke) equals: (self parseMethod: 'nuke self recursiveSelfRule: nil').  self assert: (tmp2 parseTreeFor: #initializeAfterLoad1) equals: (self parseMethod: 'initializeAfterLoad1				self recursiveSelfRule: RBParseTreeSearcher new.				self recursiveSelfRule					addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')					-> [:aNode :answer | true]').  self assert: ((tmp1 model classNamed: #RBTransformationRuleTestData) parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 				class := aSmalllintContext selectedClass.				(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 					[(self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)						ifFalse: 							[builder compile: rewriteRule tree printString								in: class								classified: aSmalllintContext protocols]]')isComposite  ^truerules: arg1  rules := arg1definingClass  ^isClassVariable ifTrue: [ super definingClass theMetaClass ] ifFalse: [ super definingClass ]preconditionHasNoReferences: arg1  | tmp1 |  tmp1 := self environmentWithReferencesTo: arg1.  ^(RBCondition withBlock: [ (tmp1 classNames copyWithoutAll: classNames) isEmpty ])     errorMacro: arg1 , ' is referenced.<n>Browse references?';     errorBlock: [ self openBrowserOn: tmp1 ];     yourselfparseTreeSearcherClass  ^RBParseTreeSearchertestTransform  | tmp1 tmp2 tmp3 |  model := RBNamespace2 new.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  tmp1 := RBMoveInstanceVariableToClassTransformation model: model variable: 'asdf' fromClass: #FOOBAR toClass: self changeMock name.  tmp2 := tmp1 model classNamed: #FOOBAR.  tmp3 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 directlyDefinesInstanceVariable: 'asdf').  self deny: (tmp3 directlyDefinesInstanceVariable: 'asdf').  tmp1 transform.  self assert: tmp1 model changes changes size equals: 3.  tmp2 := tmp1 model classNamed: #FOOBAR.  tmp3 := tmp1 model classNamed: self changeMock name asSymbol.  self deny: (tmp2 directlyDefinesInstanceVariable: 'asdf').  self assert: (tmp3 directlyDefinesInstanceVariable: 'asdf')argumentIndex: arg1  selectedArgumentIndex := arg1.  self changed: #argumentIndexmovePool: arg1 toClass: arg2  | tmp1 |  tmp1 := arg2 instanceSide.  (tmp1 definesPoolDictionary: arg1) ifFalse: [ tmp1 addPoolDictionary: arg1 ]release  self printStringclassVariableSelectorsFor: arg1  | tmp1 tmp2 |  tmp1 := Set new.  tmp2 := Set new.  classVariables keysDo: [:arg2 |  | tmp3 |        tmp3 := self classForName: arg2.        (tmp3 notNil and: [ arg1 instanceSide includesBehavior: tmp3 ]) ifTrue: [ tmp2 addAll: (classVariables at: arg2) ] ].  tmp2 do: [:arg2 |  | tmp4 |        tmp4 := arg1 bindingOf: arg2.        tmp4 ifNotNil: [ tmp1 addAll: (arg1 whichSelectorsReferTo: tmp4) ] ].  ^tmp1testConstructedSelectorEnvironment  | tmp1 tmp2 |  tmp1 := RBSelectorEnvironment new.  tmp1     addClass: Object selector: #printString;     addClass: OrderedCollection selector: #add:;     addClass: Collection.  self assert: (tmp1 includesClass: Object).  self assert: (tmp1 selectorsForClass: Object) size equals: 1.  self assert: (tmp1 includesClass: OrderedCollection).  self assert: (tmp1 selectorsForClass: OrderedCollection) size equals: 1.  self assert: (tmp1 includesClass: Collection).  self assert: (tmp1 selectorsForClass: Collection) size equals: Collection selectors size.  self deny: (tmp1 includesClass: Object class).  tmp2 := tmp1 copy.  tmp2     removeClass: OrderedCollection;     addClass: Object selector: #printOn:;     removeClass: Object selector: #printString.  self assert: (tmp2 includesClass: Object).  self deny: (tmp2 includesSelector: #printString in: Object).  self deny: (tmp2 includesClass: OrderedCollection).  self assert: (tmp2 includesClass: Collection).  self assert: tmp2 numberClasses equals: 2.  self assert: tmp2 numberSelectors + 1 equals: tmp1 numberSelectors.  tmp2 addClass: Object class.  self assert: tmp2 numberClasses equals: 2.  self assert: (tmp2 includesClass: Object class).  tmp2 removeClass: self class.  self assert: tmp2 numberClasses equals: 2testPrimitiveMethods  | tmp1 |  (model classNamed: #Object) compile: 'foo <primitive: 100> ^#() primitiveFailed' classified: #(#accessing).  tmp1 := RBAddParameterRefactoring model: model addParameterToMethod: #foo in: Object newSelector: #foo123124321s: initializer: '1'.  self shouldFail: tmp1.  tmp1 := RBAddParameterRefactoring addParameterToMethod: #at: in: Object newSelector: #at:foo: initializer: '1'.  self shouldFail: tmp1name  ^nameequalNotUsed  | tmp1 |  tmp1 = '' yourself.  (1 to: 10) do: [:arg1 |  tmp1 := arg1 printString ].  ^tmp1renameConflictingTemporaries  inlineParseTree allDefinedVariables do: [:arg1 |  self renameConflictingTemporary: arg1 ]isClassEnvironment  ^falseasUndoOperation  ^self subclassResponsibilitycopyClasses  mode := #copy:name:referencesConditionFor: arg1  | tmp1 tmp2 |  ^(RBCondition withBlock: [ tmp2 := Smalltalk globals associationAt: arg1 name ifAbsent: [ self refactoringError: 'Could not find class' ].        tmp1 := (self environment referencesTo: tmp2) | (self environment referencesTo: arg1 name).        tmp1 isEmpty ])     errorMacro: arg1 , ' is referenced.<n>Browse references?';     errorBlock: [ tmp1 openEditor ];     yourselfmethod2  ^self method1transform  renameAccessors ifTrue: [ self removeOldAccessors ].  class renameInstanceVariable: variableName to: newName around: [ self renameReferences ].  renameAccessors ifTrue: [ self addNewAccessors.        self renameAccessorsReferences ]methodBefore  < gtInspectorPresentationOrder: 34>  | tmp1 |  tmp1 := 'String'.  tmp1 byteAt: 1checkInlinedMethods  numberReplaced = 0 ifTrue: [ self refactoringFailure: 'Could not inline any senders' ]addLiteralsFor: arg1  2 to: arg1 numLiterals - 1 do: [:arg2 |  self checkLiteral: (arg1 objectAt: arg2) ]problemCount  ^self numberVariablestestMethodDoesNotExist  self shouldFail: (RBAddAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #method inClass: #RBAddAssignmentTransformationTest) asRefactoringmethodBefore  | tmp1 |  tmp1 := 'String'asUndoOperation  ^self class definition: self changeClass classTrait oldDefinitionimplementorsOf: arg1 in: arg2 storeIn: arg3  (arg2 directlyDefinesMethod: arg1) ifTrue: [ arg3 add: arg2.        ^self ].  arg2 subclasses do: [:arg4 |  self implementorsOf: arg1 in: arg4 storeIn: arg3 ]testModelMetaclass  | tmp1 |  tmp1 := RBAddClassVariableRefactoring model: model variable: #ClassVarName3 class: (model classNamed: #Bar) classSide.  self shouldFail: tmp1testAddMetaclassPattern  self exampleClasses do: [:arg1 |  (arg1 isObsolete or: [ arg1 superclass notNil and: [ arg1 superclass isObsolete ] ]) ifFalse: [ | tmp1 |              tmp1 := changes defineClass: arg1 class definition.              self assert: (tmp1 isKindOf: RBAddMetaclassChange).              self assert: tmp1 changeClassName equals: arg1 name.              self assert: tmp1 classInstanceVariableNames equals: arg1 class instVarNames.              self universalTestFor: tmp1 ] ]allClassVariableNames  | tmp1 |  tmp1 := self superclass.  ^tmp1 ifNil: [ self classVariableNames ] ifNotNil: [ tmp1 allClassVariableNames , self classVariableNames ]testReplaceArgumentsByPattern  | tmp1 tmp2 |  tmp1 := 'foo: argMatch0 bar: argMatch1 	|tempMatch0| 	tempMatch0 := 4.	^ argMatch0, argMatch1, tempMatch0 asString'.  tmp2 := 'foo: `@argMatch0 bar: `@argMatch1 	|`@tempMatch0| 	`@tempMatch0 := 4.	^ `@argMatch0, `@argMatch1, `@tempMatch0 asString'.  self assert: (RBFindAndReplaceMethodRefactoring new replaceArgumentsByPattern: tmp1) equals: tmp2inlineFailed  | tmp1 tmp2 tmp3 |  tmp1 := 5.  tmp2 := 10.  tmp3 := tmp1 + 1 fooMax: tmp2.  ^tmp3replace: arg1 with: arg2  self replace: arg1 with: arg2 ignoreCase: falseerrorBlockFor: arg1  ^condition errorBlockFor: arg1 notinitialize  super initialize.  self matcher matchesAnyOf: #('`@object 				ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 				ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' '`@object 				ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 				ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' '`@object 				ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 				ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' '`@object 				ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 				ifTrue: [| `@temps2 | `.Statement. `@.Statement2]') do: [:arg1 :arg2 |  arg2 ifNil: [ | tmp1 |              tmp1 := arg1 arguments first body statements last.              (tmp1 isVariable and: [ tmp1 = arg1 arguments last body statements last ]) ifFalse: [ arg1 ] ifTrue: [ nil ] ] ifNotNil: [ arg2 ] ]findAncestorNode  ancestorNode := cascadeNode.  [ ancestorNode parent isSequence not and: [ ancestorNode parent isAssignment ] ] whileTrue: [ ancestorNode := ancestorNode parent ].  [ ancestorNode parent isSequence not and: [ ancestorNode parent isReturn ] ] whileTrue: [ ancestorNode := ancestorNode parent ].  ancestorNode parent isSequence ifFalse: [ self refactoringFailure: 'To split this cascade, you must extract it to a temporary first' ]instVarRefsTo: arg1 in: arg2  ^RBVariableEnvironment on: self referencesToInstanceVariable: arg1 in: arg2addPoolVariable: arg1 to: arg2  ^RBAddPoolVariableChange add: arg1 to: arg2storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' with: '.  transformationBlock storeOn: arg1.  arg1 nextPut: $)changeString  ^'Remove <1s>>>#<2s>' expandMacrosWith: self displayClassName with: selectorsetOption: arg1 toUse: arg2  self options at: arg1 put: arg2includesCategory: arg1  ^(super includesCategory: arg1) and: [ (environment classNamesFor: arg1) inject: false into: [:arg2 :arg3 |  arg2 or: [ | tmp1 |                    tmp1 := self systemDictionary at: arg3 ifAbsent: [ nil ].                    tmp1 == class or: [ tmp1 class == class ] ] ] ]printOn: arg1  arg1     nextPutAll: self displayClassName;     nextPutAll: ' removeFromSystem';     nextPut: $!whichVariableNode: arg1 inInterval: arg2 name: arg3  | tmp1 tmp2 |  tmp1 := self parseTreeSearcher.  tmp2 := [:arg4 :arg5 |  (arg4 intersectsInterval: arg2) ifTrue: [ arg4 ] ifFalse: [ arg5 ] ].  tmp1     matches: arg3 do: tmp2;     matchesArgument: arg3 do: tmp2.  ^tmp1 executeTree: arg1 initialAnswer: nilhierarchyDefinesMethod: arg1  (self definesMethod: arg1) ifTrue: [ ^true ].  ^self subclassRedefines: arg1checkNodes: arg1  (arg1 anySatisfy: [:arg2 |  RBReadBeforeWrittenTester isVariable: name readBeforeWrittenIn: arg2 ]) ifTrue: [ ^false ].  arg1 do: [:arg2 |  (self usesDirectly: arg2 body) ifTrue: [ blockNodes add: arg2 ] ifFalse: [ (self checkNodes: (self subblocksIn: arg2 body)) ifFalse: [ blockNodes add: arg2 ] ] ].  ^truechangeClass: arg1  super changeClass: arg1.  isMeta := falsedefineClass: arg1  ^self addChange: (changeFactory addClassDefinition: arg1)executeShould: arg1 inScopeOf: arg2 withDescriptionNotContaining: arg3  ^[ arg1 value.  false ] on: arg2 do: [:arg4 |  arg4 return: (arg4 description includesSubstring: arg3) not ]model: arg1  model := arg1extract: arg1 from: arg2 in: arg3  class := self classObjectFor: arg3.  selector := arg2.  extractionInterval := arg1toDoWithIncrement  | tmp1 |  tmp1 := 0.  1 to: 10 by: 2 do: [:arg1 |  tmp1 := tmp1 + 2 ].  ^tmp1protocols  ^(self allMethods flatCollect: [:arg1 |  self protocolsFor: arg1 selector ]) asOrderedCollectionneedsToReplaceSelfReferences  ^self hasSelfReferences or: [ self abstractVariablesRefactoring hasVariablesToAbstract ]compile: arg1 in: arg2 classified: arg3  ^self addChange: (changeFactory addMethodSource: arg1 in: arg2 classified: arg3)defaultLabel  | tmp1 |  tmp1 := String new writeStream.  keywords do: [:arg1 |  tmp1           nextPut: $<;           nextPutAll: arg1;           nextPut: $>;           nextPut: $  ].  ^tmp1 contentsoldVersionTextToDisplay  ^''abstractInstanceReferences  | tmp1 |  tmp1 := RBParseTreeRewriter variable: variableName getter: 'class ' , self accessorsRefactoring getterMethod setter: 'class ' , self accessorsRefactoring setterMethod.  self convertClasses: class withAllSubclasses select: [:arg1 |  arg1 whichSelectorsReferToClassVariable: variableName ] using: tmp1testModel  | tmp1 |  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo'' 			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  tmp1 := model classNamed: #Subclass.  tmp1 compile: 'foo ^Foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model classVariable: #Foo class: tmp1 superclass) asRefactoring transform.  self deny: (tmp1 superclass directlyDefinesClassVariable: #Foo).  self assert: (tmp1 directlyDefinesClassVariable: #Foo)testNewInstanceVariableAccessors  | tmp1 tmp2 |  tmp1 := RBCreateAccessorsForVariableRefactoring variable: 'foo1' class: RBLintRuleTestData classVariable: false.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self denyEmpty: tmp1 changes changes.  self assert: tmp1 setterMethod identicalTo: #foo1:.  self assert: tmp1 getterMethod identicalTo: #foo1.  self assert: (tmp2 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^foo1').  self assert: (tmp2 parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject foo1 := anObject')checkForValidTemporaryVariable  | tmp1 |  tmp1 := class parseTreeFor: selector.  (tmp1 allTemporaryVariables includes: temporaryVariableName) ifFalse: [ self refactoringFailure: temporaryVariableName , ' isn''t a valid temporary variable name' ].  (tmp1 allArgumentVariables includes: temporaryVariableName) ifTrue: [ self refactoringFailure: temporaryVariableName , ' is a block parameter' ].  (RBReadBeforeWrittenTester isVariable: temporaryVariableName readBeforeWrittenIn: tmp1) ifTrue: [ self refactoringWarning: ('<1s> is read before it is written.<n>Proceed anyway?' expandMacrosWith: temporaryVariableName) ]transformations: arg1  transformations := arg1inlineFailed  | tmp1 tmp2 tmp3 |  tmp1 := 5.  tmp2 := 10.  tmp3 := tmp1 + 1 fooMax: tmp2.  ^tmp3includesClass: arg1  (environment includesClass: arg1) ifTrue: [ ^true ].  (orEnvironment includesClass: arg1) ifTrue: [ ^true ].  (environment selectorsForClass: arg1) ifNotEmpty: [ ^true ].  (orEnvironment selectorsForClass: arg1) ifNotEmpty: [ ^true ].  ^falseduplicate: arg1 name: arg2 deep: arg3  | tmp1 tmp2 tmp3 tmp4 |  (self model includesClassNamed: arg2) ifTrue: [ ^nil ].  tmp1 := arg1 superclass ifNil: [ self rootClass ].  tmp2 := (self model includesClassNamed: tmp1 name) ifFalse: [ tmp1 name ] ifTrue: [ (tmp3 := self execute: tmp1 name) = tmp1 name ifFalse: [ self duplicate: tmp1 name: tmp3 deep: arg3 ].        tmp3 ].  self model defineClass: ('<1s>		subclass: #<2s>		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: <3p>' expandMacrosWith: tmp2 with: arg2 with: arg1 category asString).  arg3 ifTrue: [ (tmp4 := self model classNamed: arg2) ifNil: [ ^self ].        self copyFrom: arg1 to: tmp4.        self copyFrom: arg1 classSide to: tmp4 classSide ].  ^nilrealName: arg1  self realClass: (Smalltalk globals at: arg1) classSidedefinesVariable: arg1  ^(self definesClassVariable: arg1) or: [ self definesInstanceVariable: arg1 ]name: arg1 class: arg2 subclasses: arg3  className := arg1 asSymbol.  parent := self model classFor: arg2.  subclasses := arg3 collect: [:arg4 |  self model classFor: arg4 ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' inline: '.  sourceInterval storeOn: arg1.  arg1     nextPutAll: ' from: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1 nextPut: $)setUp  super setUp.  model := self abstractVariableTestDatanumberVariables  ^self accessorMethods inject: 0 into: [:arg1 :arg2 |  arg1 + ((self perform: arg2) inject: 0 into: [:arg3 :arg4 |  arg3 + arg4 size ]) ]superclassEquivalentlyDefines: arg1  | tmp1 tmp2 |  self definingClass superclass ifNil: [ ^false ].  tmp1 := self definingClass superclass parseTreeFor: arg1.  tmp2 := self definingClass parseTreeFor: arg1.  (tmp1 isNil or: [ tmp2 isNil ]) ifTrue: [ ^false ].  ^tmp1 equalTo: tmp2 exceptForVariables: #()stringConcatenation  | tmp1 |  tmp1 := '' yourself.  (1 to: 10) do: [:arg1 |  tmp1 := tmp1 , arg1 printString ].  ^tmp1caller2  ^(1 to: 10) inject: 1 into: [:arg1 :arg2 |  arg1 * (self foo: arg2) ]flushCachesFor: arg1  selectorCache ifNil: [ ^self ].  arg1 instanceSide withAllSubclasses do: [:arg2 |  selectorCache           removeKey: arg2 name ifAbsent: [  ];           removeKey: arg2 classSide name ifAbsent: [  ] ]sourceCodeFor: arg1  | tmp1 |  tmp1 := self whoDefinesMethod: arg1.  tmp1 ifNil: [ ^nil ].  ^(tmp1 methodFor: arg1) sourceliteralArrayWithTrueFalseOrNil  | tmp1 tmp2 tmp3 |  tmp1 := #(true false nil).  tmp2 := #(#true #false #nil).  tmp3 := {true .   false .   nil}.  ^{tmp1 .   tmp2 .   tmp3}storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' extract: '''.  sourceCode storeOn: arg1.  arg1     nextPutAll: ''' from: #';     nextPutAll: selector asString;     nextPutAll: ' to: #';     nextPutAll: newSelector asString;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1 nextPut: $)storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' variable: '.  variableName storeOn: arg1.  arg1 nextPutAll: ' class: '.  className storeOn: arg1.  arg1 nextPutAll: ' classVariable: '.  isClassVariable storeOn: arg1.  arg1 nextPut: $)abstractReferenceTo: arg1  transformations add: (RBAddVariableAccessorTransformation model: self model instanceVariable: arg1 class: newClassName).  transformations add: ((RBRemoveDirectAccessToVariableTransformation model: self model instanceVariable: arg1 class: class) receiver: referenceVariableName).  transformations add: (RBRemoveVariableTransformation model: self model instanceVariable: arg1 class: class)testNewClassVariableAccessors  | tmp1 tmp2 |  tmp1 := RBCreateAccessorsForVariableRefactoring variable: 'Foo1' class: RBLintRuleTestData classVariable: true.  self executeRefactoring: tmp1.  tmp2 := tmp1 model metaclassNamed: #RBLintRuleTestData.  self denyEmpty: tmp1 changes changes.  self assert: tmp1 setterMethod identicalTo: #foo1:.  self assert: tmp1 getterMethod identicalTo: #foo1.  self assert: (tmp2 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^Foo1').  self assert: (tmp2 parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject Foo1 := anObject')printOn: arg1  arg1     nextPutAll: definition;     nextPut: $!missingYourself  ^OrderedCollection new     add: 1;     add: 2;     removeFirsttestVariableDoesNotExist  self shouldFail: (RBAddAssignmentTransformation variable: 'variable1' value: '1 asString' inMethod: #methodBefore inClass: #RBAddAssignmentTransformationTest) asRefactoringincludesClass: arg1  ^(arg1 isMeta ifTrue: [ metaClasses includes: arg1 soleInstance name ] ifFalse: [ classes includes: arg1 name ]) and: [ super includesClass: arg1 ]addClass: arg1 selector: arg2  (arg1 isMeta ifTrue: [ metaClassSelectors at: arg1 soleInstance name ifAbsentPut: [ IdentitySet new ] ] ifFalse: [ classSelectors at: arg1 name ifAbsentPut: [ IdentitySet new ] ]) add: arg2packages  ^self classes collect: #packagestoreOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' class: '.  class storeOn: arg1.  arg1 nextPutAll: ' instanceVariables: '.  instanceVariables asArray storeOn: arg1.  arg1     nextPutAll: ' newClassName: #';     nextPutAll: newClassName;     nextPutAll: ' referenceVariableName: ''';     nextPutAll: referenceVariableName;     nextPutAll: ''')'sendersOf: arg1 in: arg2  class := self classObjectFor: arg2.  selector := arg1.  numberReplaced := numberNotReplaced := 0preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self                 findSequenceNode;                 findStatementNodes;                 findReceiverNode.              true ])category  ^category ifNil: [ self isDefined ifTrue: [ category := self realClass category ] ifFalse: [ model environment whichCategoryIncludes: self name ] ]storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' return: ''';     nextPutAll: returnValue;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)subclassDefiningVariable  | tmp1 |  tmp1 := class allSubclasses select: [:arg1 |  arg1 isMeta not and: [ arg1 directlyDefinesClassVariable: variableName ] ].  tmp1 ifEmpty: [ self refactoringFailure: 'Could not find a class defining ' , variableName ].  tmp1 size > 1 ifTrue: [ self refactoringError: 'Multiple subclasses define ' , variableName ].  ^tmp1 asArray firstdefinesPoolDictionary: arg1  (self directlyDefinesPoolDictionary: arg1) ifTrue: [ ^true ].  ^self inheritsPoolDictionaries and: [ self superclass notNil and: [ self superclass definesPoolDictionary: arg1 ] ]className: arg1 newClassName: arg2  self className: arg1.  newClassName := arg2storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' rename: ''';     nextPutAll: variableName;     nextPutAll: ''' to: ''';     nextPutAll: newName;     nextPutAll: ''' in: '.  class storeOn: arg1.  arg1 nextPut: $)isComposite  ^trueremoveClass: arg1  self removeClassNamed: arg1 nametestMethodAlreadyExists  self     shouldFail: (RBAddMethodTransformation sourceCode: 'printString ^super printString' in: #RBBasicLintRuleTestData withProtocol: #accessing) asRefactoring;     shouldFail: (RBAddMethodTransformation model: model sourceCode: 'classVarName1 ^super printString' in: (model classNamed: #Bar) withProtocol: #accessing) asRefactoring;     shouldFail: (RBAddMethodTransformation model: model sourceCode: 'printString ^super printString' in: (model classNamed: #Bar) withProtocol: #accessing) asRefactoringextractMethodRefactoring  ^RBExtractMethodRefactoring new     setOption: #useExistingMethod toUse: [:arg1 :arg2 |  UIManager default confirm: 'Do you want use existing method ' , arg2 printString , '?' label: 'Warninig' ];     yourselftestInlineComponentIntoCascadedMessage  | tmp1 |  self proceedThroughWarning: [ tmp1 := RBInlineMethodFromComponentRefactoring inline: (35 to: 79) inMethod: #inlineComponent forClass: RBRefactoryTestDataApp.        (tmp1 model classNamed: #Behavior) compile: 'hasImmediateInstances ^self format = 0' classified: #(#accessing).        self setupInlineExpressionFor: tmp1 toReturn: false.        self executeRefactoring: tmp1 ].  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineComponent) equals: (self parseMethod: 'inlineComponent	| a aBehavior |	a := 5.	aBehavior := a class.	aBehavior superclass.	aBehavior format = 0.	^aBehavior yourself')method2  ^self method1executeShould: arg1 inScopeOf: arg2  ^[ arg1 value.  false ] on: arg2 do: [:arg3 |  arg3 return: true ]testAddParameterThatReferencesModelGlobal  | tmp1 tmp2 |  tmp1 := RBAddParameterRefactoring model: model addParameterToMethod: ('test' , 'Foo:') asSymbol in: RBRefactoryTestDataApp newSelector: #testFoo:bar: initializer: 'Bar new'.  self proceedThroughWarning: [ self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #testFoo:bar:) equals: (self parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').  self assert: (tmp2 parseTreeFor: #callFoo) equals: (self parseMethod: 'callFoo ^self testFoo: 5 bar: (Bar new)').  self deny: (tmp2 directlyDefinesMethod: ('test' , 'Foo:') asSymbol)buildTransformations  ^transformations ifNil: [ transformations := OrderedCollection with: (RBAddClassTransformation addClass: self tmpName superclass: className asSymbol subclasses: #() category: (self model classNamed: className) category) with: (RBRenameClassTransformation new className: className newClassName: newClassName) with: (RBRenameClassTransformation new className: self tmpName newClassName: className) with: (RBDeprecateClassTransformation class: className) ]testRefactoring  | tmp1 tmp2 |  tmp1 := (RBProtectVariableTransformation instanceVariable: 'builder' class: #RBTransformationRuleTestData) asRefactoring transform.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (tmp2 parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject	builder := anObject').  self assert: (tmp2 parseTreeFor: #viewResults) equals: (self parseMethod: 'viewResults		self builder inspect.		self resetResult').  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) 				ifFalse: 					[self builder 						compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]]')name: arg1  name := arg1pullUp: arg1 from: arg2  self pullUp: arg1 from: arg2 to: arg2 superclassreparentSubclasses  self model reparentClasses: subclasses to: self abstractSuperclasscodeCruftLeftInMethods  < haltOrBreakpointForTesting>  | tmp1 tmp2 tmp3 |  tmp1 := tmp2 := tmp3 := 2.  self halt.  ^tmp1 > 0 ifTrue: [ tmp2 ] ifFalse: [ tmp3 ]extraBlock  ^[:arg1 |  arg1 + 43 ] value: 45testDefinesPoolDictionary  self deny: (objectClass definesPoolDictionary: #OpcodePool).  self assert: (newClass definesPoolDictionary: #TextConstants).  self deny: (messageNodeClass definesPoolDictionary: #OpcodePool).  self assert: ((RBClassModelFactory rbNamespace new classNamed: #Text) definesPoolDictionary: #TextConstants)problemCount  ^self numberClassesexecute: arg1 replace: arg2 with: arg3  | tmp1 |  ^arg2 copy: arg1 translatingMatchesUsing: [:arg4 |  tmp1 := WriteStream on: (String new: 2 * arg1 size).        [ arg3 atEnd ] whileFalse: [ tmp1 nextPutAll: (arg3 upTo: $$).              arg3 atEnd ifFalse: [ arg3 peek isDigit ifFalse: [ tmp1 nextPut: arg3 next ] ifTrue: [ tmp1 nextPutAll: (arg2 subexpression: arg3 next asInteger - $0 asInteger + 1) ] ] ].        arg3 reset.        tmp1 contents ]comment: arg1 in: arg2  self className: arg2.  comment := arg1testMethodDoesNotExist  | tmp1 |  tmp1 := (RBRemoveSubtreeTransformation code: 'selector := aSelector' from: #two in: self changeMock name) transform.  self assertEmpty: tmp1 model changes changes.  self shouldFail: (RBRemoveSubtreeTransformation code: 'selector := aSelector' from: #selector:for: in: #RBRemoveMethodTransformation) asRefactoringdefaultEnvironment  ^RBBrowserEnvironment newfullBlocks  ^[ thisContext ]preconditions  ^RBCondition directlyDefinesInstanceVariable: variableName in: classtestVariableAlreadyExists  self shouldFail: (RBMoveInstanceVariableToClassTransformation model: model variable: 'result' fromClass: #RBFooLintRuleTestData toClass: #RBBasicLintRuleTestData) asRefactoringprivateIncludesSelector: arg1 inClass: arg2  ^(self privateSelectorsForClass: arg2) includes: arg1selector: arg1  selector := arg1 asSymbol.  self changed: #selectorcondition: arg1  condition := arg1copyExtensionMethods  (self instanceSideExtensionMethodsOf: deprecatedClass) do: [:arg1 |  self newClass instanceSide compile: arg1 source classified: arg1 protocols ].  (self classSideExtensionMethodsOf: deprecatedClass) do: [:arg1 |  self newClass classSide compile: arg1 source classified: arg1 protocols ]instanceVariablesFor: arg1  ^arg1 instVarNamestestNonExistantName  self shouldFail: (RBPullUpClassVariableRefactoring variable: #Foo class: RBLintRuleTestData)parseTree  ^self parserClass parseMethod: self source onError: [:arg1 :arg2 |  ^nil ]parserTreeSearcher  ^self parseTreeSearcherClass newchangeString  ^'Remove pool variable <1s> from <2s>' expandMacrosWith: self variable with: self displayClassNametestInvalidSubclass  self shouldFail: (RBAddClassRefactoring addClass: #Foo superclass: RBCompositeLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData) category: #'Refactory-Tesing')preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition isValidInstanceVariableName: newVariableName for: class) & (RBCondition withBlock: [ self verifySelectedInterval.              self checkVariableName.              true ])preconditions  ^(RBCondition isMetaclass: class) not & (RBCondition directlyDefinesClassVariable: variableName asSymbol in: class) & ((RBCondition withBlock: [ (#(#Object #Behavior #ClassDescription #Class) includes: class name) not ]) errorMacro: 'This refactoring does not work for Object, Behavior, ClassDescription, or Class')addClassVariable: arg1 to: arg2  ^self addChange: (changeFactory addClassVariable: arg1 to: arg2)testRefactoring  | tmp1 tmp2 |  tmp1 := (RBRemoveMessageSendTransformation messageSend: #byteAt: inMethod: #methodBefore inClass: #RBRemoveMessageSendTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBRemoveMessageSendTransformationTest.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) bodyusesAdd  ^(1 to: 10) asOrderedCollection addAll: (11 to: 20)preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'No such class or trait named ' , class asString) & (RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ self definingMethod allTemporaryVariables includes: variableName ] errorString: 'Method named ' , selector , ' does not define a temporary variable named ' , variableName) & (RBCondition withBlock: [ (self definingMethod allArgumentVariables includes: variableName) not ] errorString: 'Variable named ' , variableName , ' cannot be removed because it is an argument in this method') & (RBCondition withBlock: [ (self checkBlocksIn: self definingBlock) not ] errorString: 'Variable named ' , variableName , ' is already bound tightly as possible.') & (RBCondition withBlock: [ self checkLocationsIn: (self checkAllBlocksIn: self definingBlock) ] errorString: 'Variable named ' , variableName , ' is used in an outside block.')computeVariablesToAbstract  | tmp1 |  instVarReaders := Set new.  instVarWriters := Set new.  classVarReaders := Set new.  classVarWriters := Set new.  tmp1 := self parseTreeSearcher.  tmp1     matches: '`var := ``@anything' do: [:arg1 :arg2 |  self processAssignmentNode: arg1 ];     matches: '`var' do: [:arg1 :arg2 |  self processReferenceNode: arg1 ].  tmp1 executeTree: tree.  self removeDefinedClassVariablestestFoo: arg1  ^self class + arg1result: arg1  result := arg1 copyEmptyasSelectorEnvironment  | tmp1 |  tmp1 := RBSelectorEnvironment new.  tmp1 label: self label.  environmentDictionaries do: [:arg1 |  | tmp2 |        tmp2 := arg1 asSelectorEnvironment.        tmp2 classesDo: [:arg2 |  tmp2 selectorsForClass: arg2 do: [:arg3 |  tmp1 addClass: arg2 selector: arg3 ] ] ].  ^tmp1createNewClass  self     addClass;     addInstanceVariablesjustSendsSuper  super justSendsSuperclass: arg1 instanceVariables: arg2 newClassName: arg3 referenceVariableName: arg4  class := self model classObjectFor: arg1.  instanceVariables := arg2.  newClassName := arg3.  referenceVariableName := arg4changeForClass: arg1 selector: arg2  ^nilsetUp  super setUp.  model := self abstractVariableTestDatasetUp  super setUp.  model := self abstractVariableTestDataskip  TestSkip signaltestMethodAlreadyDefined  | tmp1 tmp2 |  tmp2 := model classNamed: #RBFooLintRuleTestData.  tmp1 := RBClassModelFactory rbMethod for: tmp2 source: 'foo' , String cr , String tab , '^ 6' selector: #foo.  self shouldFail: (RBMoveMethodToClassRefactoring method: tmp1 class: tmp2)parseMethod: arg1  ^[ self parserClass parseMethod: arg1 ] on: Error do: [:arg2 |  nil ]difference  ^differencepoolVariableNamesIn: arg1  ^(Smalltalk globals at: arg1 ifAbsent: [ Dictionary new ]) classPool keys collect: [:arg2 |  arg2 asString ]findOcurrencesIn: arg1 of: arg2  | tmp1 tmp2 tmp3 |  tmp1 := (arg2 >> arg1) sourceNode.  tmp3 := tmp1 sourceCode.  tmp2 := Set new.  (self nodesOf: tmp1) do: [:arg3 |  arg3 first < arg3 last ifTrue: [ self match: (RBPatternParser parseExpression: (tmp3 copyFrom: arg3 first to: arg3 last)) with: arg3 first and: arg3 last in: tmp2 ] ].  tmp1 body nodesDo: [:arg4 |  self match: arg4 with: arg4 start and: arg4 stop in: tmp2 ].  ^tmp2preconditions  ^(RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ | tmp1 |              tmp1 := self parserClass parseExpression: oldSourceCode onError: [:arg1 :arg2 |  self refactoringError: 'Invalid source to extract - ' , arg1 ].              tmp1 ifNil: [ self refactoringError: 'Invalid source to extract - ' , oldSourceCode ].              (tmp1 isSequence and: [ tmp1 statements isEmpty ]) ifTrue: [ self refactoringError: 'Selected code to extract is empty' ].              tmp1 := ((self definingClass parseTreeFor: selector) extractSubtreeWith: oldSourceCode) ifNil: [ self refactoringError: 'Could not extract code from method ' , selector ].              true ]) & (RBCondition withBlock: [ self parserClass parseExpression: newSourceCode onError: [:arg1 :arg2 |  self refactoringError: 'Invalid source to add - ' , arg1 ].              true ])packages  ^environment packages & andedEnvironment packagesshould: arg1  self assert: arg1 valuemsg4  ^Var1options  ^options ifNil: [ self class refactoringOptions ] ifNotNil: [ options ]addNewVariable  (RBAddClassVariableChange add: newName to: self changeClass) executesharedPools  ^self allPoolDictionaryNames collect: [:arg1 |  Smalltalk globals at: arg1 asSymbol ifAbsent: [ Dictionary new ] ]method: arg1 with: arg2 lots: arg3 of: arg4 arguments: arg5  ^arg5 + arg1 > (arg4 - arg2 + arg3)valueIndex  ^selectedValueIndex ifNil: [ selectedValueIndex := 0 ]removeClass: arg1  arg1 isMeta ifTrue: [ metaClasses remove: arg1 soleInstance name ifAbsent: [  ] ] ifFalse: [ classes remove: arg1 name ifAbsent: [  ] ]removeOldVariable  self flag: #todo.  (RBRemoveClassVariableChange remove: oldName from: self changeClass) executeprintOn: arg1  arg1     nextPut: $!;     nextPutAll: self displayClassName;     nextPutAll: ' methodsFor: ''';     nextPutAll: self protocol;     nextPutAll: ''' stamp: ';     print: self changeStamp;     nextPut: $!;     cr;     nextPutAll: (source copyReplaceAll: '!' with: '!!');     nextPutAll: '! !'fileBlocks  | tmp1 |  ^[ tmp1 := 'asdf' asFileReference readStream.  tmp1 contents ] ensure: [ tmp1 close ]checkClass: arg1  sharedPoolNames  ^self privatePoolDictionaryNames copydefinitionClass  self subclassResponsibilitytestMethodDoesNotExist  self shouldFail: (RBRemoveMessageSendTransformation messageSend: #byteAt: inMethod: #method inClass: #RBRemoveMessageSendTransformationTest) asRefactoringisMeta  ^falsetestModelAddClass  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := model classNamed: #Bar.  tmp3 := model classNamed: #Foo.  tmp1 := RBAddClassRefactoring model: model addClass: #FooTest superclass: tmp3 subclasses: (Array with: tmp4) category: #'Refactory-Testing'.  self executeRefactoring: tmp1.  tmp2 := model classNamed: #FooTest.  self assert: tmp2 superclass equals: tmp3.  self assert: (tmp3 subclasses includes: tmp2).  self assert: tmp2 classSide superclass equals: tmp3 classSide.  self assert: (tmp3 classSide subclasses includes: tmp2 classSide).  self assert: tmp4 superclass equals: tmp2.  self assert: (tmp2 subclasses includes: tmp4).  self assert: tmp4 classSide superclass equals: tmp2 classSide.  self assert: (tmp2 classSide subclasses includes: tmp4 classSide)anInstVar  ^anInstVarprivateTransform  self     createGetterAccessor;     createSetterAccessorthreeElementPoint  ^(5 @ 5 + 6) @ 6isEmpty  self subclassResponsibilitypreconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self                 findCascadeNode;                 findAncestorNode;                 findMessageNodes.              true ])defineGetterMethod  | tmp1 |  tmp1 := self safeMethodNameFor: self definingClass basedOn: variableName asString.  self definingClass compile: ('<1s><r><t>^ <2s>' expandMacrosWith: tmp1 with: variableName) classified: #(#accessing).  ^tmp1name  ^nameisEmpty  ^falsetemporaryVariableCapitalization  | tmp1 |  tmp1 := 'Bern'.  ^tmp1transform  self createAccessors.  self abstractReferencesinstanceVariables  ^instanceVariablestestMetaclassFailure  self shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: #RecursiveSelfRule class: RBTransformationRuleTestData class) asRefactoringpreconditionsOf: arg1  ^(RBCondition withBlock: [ self checkIsSubclass: arg1.        true ]) & (RBCondition withBlock: [ self checkIsAbstractMethod.              true ]) & (RBCondition withBlock: [ self checkOverridesSelectorInClass: arg1.              true ])match: arg1 with: arg2 and: arg3 in: arg4  self matchNodes do: [:arg5 |  [ arg5 match: arg1 onSuccess: [:arg6 |  arg4 add: (arg2 to: arg3) -> arg6 ] onFailure: [  ] ] on: Exception do: [:arg7 |  arg7 ] ]methodName  ^String streamContents: [:arg1 |  self printOn: arg1 ]combinations  ^combinationsselectorsDo: arg1  self allClassesDo: [:arg2 |  self selectorsForClass: arg2 do: arg1 ]testMetaClassFailure  self shouldFail: (RBPullUpClassVariableRefactoring variable: #RecursiveSelfRule class: RBLintRuleTestData class)testInlineTemporaryBadInterval  self shouldFail: (RBInlineTemporaryRefactoring inline: (29 to: 100) from: #moveDefinition in: RBRefactoryTestDataApp)renameConflictingTemporary: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Set new     addAll: inlineParseTree allDefinedVariables;     yourself.  tmp1 remove: arg1 ifAbsent: [  ].  tmp4 := sourceMessage.  [ tmp4 isSequence ] whileFalse: [ tmp4 := tmp4 parent ].  tmp1 addAll: tmp4 allDefinedVariables.  tmp2 := arg1.  tmp3 := 0.  [ (sourceMessage whoDefines: tmp2) notNil or: [ (class hierarchyDefinesVariable: tmp2) or: [ tmp1 includes: tmp2 ] ] ] whileTrue: [ tmp3 := tmp3 + 1.        tmp2 := arg1 , tmp3 printString ].  tmp2 = arg1 ifFalse: [ self renameTemporary: arg1 to: tmp2 ].  ^tmp2notifyUserOfCommand: arg1  UIManager default abort: self messageTextshouldCopyExtensions  ^shouldCopyExtensionstempsReadBeforeWritten  | tmp1 |  self isVariable ifTrue: [ tmp1 := 4 ].  ^tmp1someMethod  ^'a String'hasOnlySelfReturns  ^hasOnlySelfReturns ifNil: [ | tmp1 |        tmp1 := self parseTreeSearcher.        tmp1           matches: '^self' do: [:arg1 :arg2 |  arg2 ];           matches: '^`@object' do: [:arg1 :arg2 |  false ].        hasOnlySelfReturns := tmp1 executeTree: parseTree initialAnswer: true ] ifNotNil: [ hasOnlySelfReturns ]tempVarOverridesInstVar  | tmp1 |  tmp1 := 4.  ^tmp1literalArrayCharacters  ^#($a $b $c) includes: $aoptions: arg1  options := arg1preconditions  ^variables inject: RBCondition empty into: [:arg1 :arg2 |  arg1 & (RBCondition definesInstanceVariable: arg2 in: self theClass) ]isEmpty  ^result isEmptytestBadInterval  self     shouldFail: (RBExtractToTemporaryRefactoring extract: (24 to: 30) to: 'asdf' from: #testMethod in: RBRefactoryTestDataApp);     shouldFail: (RBExtractToTemporaryRefactoring extract: (14 to: 105) to: 'asdf' from: #testMethod1 in: RBRefactoryTestDataApp);     shouldFail: (RBExtractToTemporaryRefactoring extract: (61 to: 101) to: 'asdf' from: #noMoveDefinition in: RBRefactoryTestDataApp)definesClass: arg1  ^environment definesClass: arg1preconditions  ^RBCondition emptyproblemCount  ^builder problemCountinheritsPoolDictionaries  ^falseclass: arg1 source: arg2 contoller: arg3  self changeClass: arg1.  source := arg2.  self protocols: (RBBrowserEnvironment new whichProtocolIncludes: self selector in: arg1).  controller := arg3testModelPushDownVariable  | tmp1 |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  tmp1 := model classNamed: #Subclass.  tmp1 compile: 'foo ^Foo' classified: #(#accessing).  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: tmp1 superclass).  self deny: (tmp1 superclass directlyDefinesClassVariable: #Foo).  self assert: (tmp1 directlyDefinesClassVariable: #Foo)renameMethod: arg1 in: arg2 to: arg3 permutation: arg4  oldSelector := arg1 asSymbol.  newSelector := arg3 asSymbol.  class := self classObjectFor: arg2.  permutation := arg4inlineLast  5 = 3 ifTrue: [ ^self caller ] ifFalse: [ ^self caller2 ]renameTemporary: arg1 to: arg2  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1     replace: arg1 with: arg2;     replaceArgument: arg1 with: arg2.  (tmp1 executeTree: inlineParseTree) ifTrue: [ inlineParseTree := tmp1 tree ]parseTreeSearcherClass  ^RBParseTreeSearchertestTransform  | tmp1 tmp2 |  self assert: self changeMock category equals: #'Refactoring-Tests-Changes'.  tmp1 := (RBMoveClassTransformation move: self changeMock name to: #'Refactoring2-Transformations-Test') transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: tmp2 category equals: #'Refactoring2-Transformations-Test'includesCategory: arg1  ^(super includesCategory: arg1) and: [ (environment classNamesFor: arg1) inject: false into: [:arg2 :arg3 |  arg2 or: [ | tmp1 |                    tmp1 := self systemDictionary at: arg3 ifAbsent: [ nil ].                    tmp1 notNil and: [ (self includesClass: tmp1) or: [ self includesClass: tmp1 class ] ] ] ] ]methodBefore  | tmp1 |  tmp1 := 'String'comment: arg1  self model changes comment: (comment := arg1) in: selftearDown  self removeMockClass.  super tearDownpreconditions  ^(RBCondition definesClassVariable: variableName in: class) & (RBCondition withBlock: [ self findDestinationClass.              true ])isMultiEnvironment  ^trueonSystemDictionary: arg1  onSystemDictionary := arg1