isEmpty  ^classSelectors isEmpty and: [ metaClassSelectors isEmpty ]resultClass  ^RBSelectorEnvironmentunoptimizedAndOr  ^(true and: [ false ]) and: [ true ]preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'Class named ' , className , ' does not exist') & (RBCondition withBlock: [ self model environment categories includes: category ] errorString: 'Category named ' , category , ' does not exist')preconditions  ^(RBCondition isValidInstanceVariableName: newVariableName for: self definingClass) & (RBCondition definesSelector: selector in: self definingClass) & (RBCondition definesInstanceVariable: newVariableName in: self definingClass) not & (RBCondition definesClassVariable: newVariableName in: self definingClass) nottestInlineMethodFromComponentFailure  self shouldFail: (RBInlineMethodFromComponentRefactoring inline: (50 to: 64) inMethod: #inlineFailed forClass: RBRefactoryTestDataApp)preconditions  ^selectors inject: RBCondition empty into: [:cond :selector |  cond & (RBCondition definesSelector: selector in: class) ]modifyImplementorParseTree: parseTree in: aClass  | node assignment |  node := (parseTree arguments at: parameterIndex) copy.  parseTree body addTemporaryNamed: node name.  assignment := RBAssignmentNode variable: node copy value: expressions first.  parseTree body addNodeFirst: assignment.  super modifyImplementorParseTree: parseTree in: aClasschangeSymbol  ^#removeClassVarNamed:testTransformNotSequenceNode  | transformation class |  transformation := RBCompositeTransformation new transformations: (OrderedCollection with: (RBAddMethodTransformation sourceCode: 'printString1 super printString' in: self changeMock name withProtocol: #accessing) with: (RBRemoveSubtreeTransformation code: 'super printString' from: #printString1 in: self changeMock name)).  transformation transform.  self assert: transformation model changes changes size equals: 2.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class directlyDefinesMethod: #printString1).  self assertEmpty: (class parseTreeFor: #printString1) body statementsargumentsAndValues  ^argsAndValuesparameterMap  ^parameterMapcontroller  ^controllerignoreChangesWhile: aBlock  isPerformingRefactoring ifTrue: [ ^aBlock value ].  isPerformingRefactoring := true.  aBlock ensure: [ isPerformingRefactoring := false ]group  ^'Coding Idiom Violation'targetClass  ^classsignalReferenceError: errorString  class realClass ifNil: [ self refactoringError: errorString ] ifNotNil: [ | classVarName error |        error := '<1s><n>Browse references?' expandMacrosWith: errorString.        classVarName := variableName asSymbol.        self refactoringError: error with: [ self openBrowserOn: (RBVariableEnvironment referencesToClassVariable: classVarName in: class realClass) ] ]convertClasses: classSet select: aBlock using: searchReplacer  classSet do: [:aClass |  (aBlock value: aClass) do: [:selector |  self convertMethod: selector for: aClass using: searchReplacer ] ]moveDefinition  | temp |  ^(self collect: [:each |  temp := each printString.        temp , temp ]) select: [:each |  temp := each size.        temp odd ]testModelPushDownToMetaclass  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model metaclassNamed: #SomeClass) addInstanceVariable: 'foo'.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model metaclassNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  self executeRefactoring: (RBPushDownInstanceVariableRefactoring model: model variable: 'foo' class: (model metaclassNamed: #SomeClass)).  self deny: ((model metaclassNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model metaclassNamed: #Subclass) directlyDefinesVariable: 'foo')removeInstanceVariable: variableName from: aClass  ^RBRemoveInstanceVariableChange remove: variableName from: aClasspreconditions  ^RBCondition emptyerrorMacro: aString  errorMacro := aStringresultClass  ^RBPackageEnvironmenttypesFor: anInstVarName  ^variableTypes at: anInstVarName ifAbsent: [ Set new ]checkForPrimitiveMethod  parseTree isPrimitive ifTrue: [ self refactoringError: 'Cannot move primitive methods' ]definingMethod  ^self definingClass parseTreeFor: selector asSymboltestUnusedClassVariable  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  self assert: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (RBPushDownVariableTransformation model: model classVariable: #Foo class: (model classNamed: #SomeClass)) asRefactoring transform.  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  self deny: ((model classNamed: #Subclass) directlyDefinesVariable: #Foo)signalProcesses: aSemaphore  aSemaphore ifNil: [ ^self ].  [ aSemaphore isEmpty ] whileFalse: [ aSemaphore signal ]haveSameNumberOfArgs  (self numberOfArgs: oldSelector) = (self numberOfArgs: newSelector) ifFalse: [ self refactoringFailure: 'The new selector does not have the same number of parameters.' ]testPullUpWithSuperSendThatCannotBeCopiedDown  | class |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Object) compile: 'foo ^3' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^super foo' classified: #(#accessing).  model defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (class := model classNamed: #Foo2) compile: 'foo ^1' classified: #(#accessing).  self shouldFail: (RBPullUpMethodRefactoring model: model pullUp: #(#foo) from: class)messagePattern  ^'self ' , (self buildSelectorString: selector)testNonExistantName  self     shouldFail: (RBMoveVariableDefinitionRefactoring bindTight: (1 to: 10) in: RBLintRuleTestData selector: #name1);     shouldFail: (RBMoveVariableDefinitionRefactoring bindTight: (44 to: 54) in: RBLintRuleTestData selector: #displayName);     shouldFail: (RBMoveVariableDefinitionRefactoring bindTight: (16 to: 25) in: RBLintRuleTestData selector: #displayName)testTransform  | transformation class |  transformation := (RBProtectVariableTransformation instanceVariable: 'class' class: #RBTransformationRuleTestData) transform.  class := transformation model classNamed: #RBTransformationRuleTestData.  self assert: (class directlyDefinesLocalMethod: #class1).  self assert: (class directlyDefinesLocalMethod: #class:).  self assert: (class parseTreeFor: #superSends) equals: (self parseMethod: 'superSends		| rule |		rule := RBParseTreeRewriter new.		rule addSearch: ''super `@message: ``@args'' 			-> (				[:aNode | 				(self class1 withAllSubclasses 					detect: [:each | each includesSelector: aNode selector]					ifNone: [nil]) isNil] 						-> ''self `@message: ``@args'').		self rewriteUsing: rule').  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 		self class: aSmalllintContext selectedClass.		(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: 				[builder 					compile: rewriteRule tree printString					in: self class1					classified: aSmalllintContext protocols]]')addClass: aClass  aClass isMeta ifTrue: [ metaClassSelectors at: aClass soleInstance name put: aClass selectors asIdentitySet ] ifFalse: [ classSelectors at: aClass name put: aClass selectors asIdentitySet ]group  ^'Optimization'whatToDisplayIn: aBrowser  ^(self changes changes select: [:change |  {getterMethod .         setterMethod} includes: change selector ]) flatCollect: [:change |  change whatToDisplayIn: aBrowser ]resetResult  result := result copyEmpty.  result label: namemethodDelimiter  ^'#''place.holder.for.method'''testMetaClassFailure  self shouldFail: (RBAbstractClassVariableRefactoring variable: #RecursiveSelfRule class: RBTransformationRuleTestData class)preconditions  | condition |  self requestSelectors.  condition := selectors inject: RBCondition empty into: [:cond :each |  cond & (RBCondition definesSelector: each in: class) & (RBCondition subclassesOf: class referToSelector: each) not ].  ^condition & (RBCondition isAbstractClass: class)superclassEquivalentlyDefines: aSelector  | superTree myTree |  class superclass ifNil: [ ^false ].  superTree := class superclass parseTreeFor: aSelector.  myTree := class parseTreeFor: aSelector.  (superTree isNil or: [ myTree isNil ]) ifTrue: [ ^false ].  ^superTree equalTo: myTree exceptForVariables: #()changeClass: aRBClass  changedClasses at: aRBClass name put: (Array with: aRBClass instanceSide with: aRBClass classSide).  self flushCachespackageNames  ^packages collect: [:each |  each packageName ]type: aSymbol block: aBlock errorString: aString  type := aSymbol.  block := aBlock.  self errorMacro: aStringdemoRenameMethod: arg1 PermuteArgs: arg2  self do: arg1.  self do: arg2.  ^arg1 > arg2critiqueFor: aNode about: aMethod  | anchor |  anchor := (aNode isKindOf: RBProgramNode) ifFalse: [ ReSourceAnchor entity: aMethod ] ifTrue: [ ReIntervalSourceAnchor entity: aMethod interval: aNode sourceInterval ].  ^ReTrivialCritique withAnchor: anchor by: selfrbMetaclassClass  ^RBMetaclass2verifyInitializationExpression  | tree |  tree := self parserClass parseExpression: initializer onError: [:msg :index |  self refactoringFailure: 'Illegal initialization code because:.' , msg ].  tree isValue ifFalse: [ self refactoringFailure: 'The initialization code cannot be a return node or a list of statements' ].  self checkVariableReferencesIn: treeisEmpty  ^result isEmptyisEmpty  ^self accessorMethods allSatisfy: [:each |  (self perform: each) isEmpty ]storeOn: aStream  aStream nextPut: $(.  super storeOn: aStream.  aStream     nextPutAll: ' class: ';     nextPutAll: class name;     nextPutAll: ' protocols: '.  protocols asArray storeOn: aStream.  aStream nextPut: $)getClassesToMoveTo  self isMovingToArgument ifTrue: [ self getClassesForTemporaryVariable ] ifFalse: [ self isMovingToInstVar ifTrue: [ self getClassesForInstanceVariable ] ifFalse: [ self getClassForGlobalOrClassVariable ] ].  moveToClasses ifEmpty: [ self refactoringFailure: 'No classes selected, method not moved.' ]privateClassVariableNames  (self isDefined and: [ classVariableNames isNil ]) ifTrue: [ self classVariableNames: self realClass classVarNames ].  ^classVariableNamesaddNode: aRBNode toSequence: aSequenceNode  aSequenceNode statements detect: [:node |  node intersectsInterval: interval ] ifFound: [:node |  node isBlock ifTrue: [ node body addNode: aRBNode ] ifFalse: [ aSequenceNode addNode: aRBNode before: node ] ].  ^aSequenceNode parentSuchAs: #isMethodtestWithoutClassesRemovesClassesFromSender  | environment newEnvironment |  environment := RBBrowserEnvironment new forClasses: Number withAllSubclasses.  newEnvironment := environment withoutClasses: {Number .         Integer}.  self assert: newEnvironment classes size equals: environment classes size - 2newResultClass: aClass  result := aClass newtempVarOverridesInstVar  | temporaryVariable |  temporaryVariable := 4.  ^temporaryVariablecompileEqual  | method statement comparison |  method := self parserClass parseMethod: '= anObject		"Answer whether the receiver and anObject represent the same object."		self == anObject ifTrue: [ ^ true ].		self class = anObject class ifFalse: [ ^ false ]'.  statement := nil.  variables reversed do: [:each |  | accessor |        accessor := self accessorForVariable: each.        comparison := RBMessageNode receiver: (RBVariableNode named: each) selector: #= arguments: (Array with: (RBMessageNode receiver: (RBVariableNode named: 'anObject') selector: accessor)).        statement := statement ifNil: [ comparison ] ifNotNil: [ RBMessageNode receiver: comparison selector: #and: arguments: (Array with: (RBBlockNode body: (RBSequenceNode statements: (Array with: statement)))) ] ].  method     addNode: statement;     addReturn.  self theClass compile: method formattedCode classified: #(comparing)check  ^condition check notforCategories: categoryList  ^RBCategoryEnvironment onEnvironment: self categories: categoryListsetupVariableTypesFor: aRefactoring toReturn: anObject  | options |  options := aRefactoring options copy.  options at: #variableTypes put: [:ref :ignore1 :ignore2 |  anObject ].  aRefactoring options: optionstestPullUpMethodWithCopyOverriddenMethodsDown  | refactoring |  self proceedThroughWarning: [ refactoring := RBPullUpMethodRefactoring pullUp: #(#isComposite) from: RBCompositeLintRuleTestData.        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #RBBasicLintRuleTestData) parseTreeFor: #isComposite) equals: (self parseMethod: 'isComposite ^false').  self assert: ((refactoring model classNamed: ('RBFoo' , 'LintRuleTestData') asSymbol) parseTreeFor: #isComposite) equals: (self parseMethod: 'isComposite ^false').  self assert: ((refactoring model classNamed: #RBLintRuleTestData) parseTreeFor: #isComposite) equals: (self parseMethod: 'isComposite ^true').  self deny: ((refactoring model classNamed: #RBCompositeLintRuleTestData) directlyDefinesMethod: #isComposite)group  ^'Architecture'testAndEnvironment  | originalEnvironment objectPrintStringEnvironment andEnvironment |  originalEnvironment := universalEnvironment referencesTo: #printOn:.  objectPrintStringEnvironment := universalEnvironment forClass: Object selectors: #(#fullPrintString).  andEnvironment := objectPrintStringEnvironment & originalEnvironment.  self universalTestFor: andEnvironment.  self assert: andEnvironment numberSelectors equals: 1.  self assert: andEnvironment classNames asArray equals: #(#Object).  self assert: (andEnvironment protocolsFor: Object) size equals: 1.  self assert: (objectPrintStringEnvironment & objectPrintStringEnvironment) packages equals: objectPrintStringEnvironment packages.  andEnvironment := originalEnvironment & (universalEnvironment referencesTo: #printString).  self assert: andEnvironment numberSelectors equals: (originalEnvironment referencesTo: #printString) numberSelectors.  self assert: andEnvironment classNames asSortedCollection equals: (originalEnvironment referencesTo: #printString) classNames asSortedCollectioncomputeEquivalenceClassesForMethodsAndVars  | searcher |  backpointers := self backpointersDictionary.  class instanceVariableNames do: [:each |  backpointers at: each put: (self backpointersSetWith: each) ].  class withAllSubclasses do: [:sub |  sub selectors do: [:each |  backpointers at: each put: (self backpointersSetWith: each) ] ].  searcher := self parseTreeSearcher.  searcher matches: '^``@object' do: [:aNode :answer |  self processNode: aNode value ].  self executeSearch: searchercheckClass: aSmalllintContext  testExtractFailure  self shouldFail: (RBExtractMethodTransformation extract: (self sourceCodeAt: (80 to: 269) forMethod: #subclassOf:overrides: in: RBBasicLintRuleTestData class) from: #subclassOf:overrides: to: #foo in: #'RBBasicLintRuleTestData class') asRefactoring.  self shouldFail: (RBExtractMethodTransformation extract: (self sourceCodeAt: (53 to: 56) forMethod: #subclassOf:overrides: in: RBBasicLintRuleTestData class) from: #subclassOf:overrides: to: #foo in: #'RBBasicLintRuleTestData class') asRefactoring.  self shouldFail: (RBExtractMethodTransformation extract: (self sourceCodeAt: (77 to: 222) forMethod: #subclassResponsibilityNotDefined in: RBBasicLintRuleTestData class) from: #subclassResponsibilityNotDefined to: #foo in: #'RBBasicLintRuleTestData class') asRefactoringremoveMethods: selectorCollection from: aClass  class := self classObjectFor: aClass.  selectors := selectorCollectionproblemCount  self subclassResponsibilitypushUp: aSelector in: aClass  | source |  source := aClass sourceCodeFor: aSelector.  source ifNotNil: [ aClass superclass compile: source classified: (aClass protocolsFor: aSelector) ]testRefactoring  | refactoring |  refactoring := (RBAddProtocolTransformation protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  RBRefactoryChangeManager instance performChange: refactoring changes.  refactoring := (RBRemoveProtocolTransformation protocol: 'transforming' inClass: #RBDummyEmptyClass) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1minMax  ^3 < 5 ifTrue: [ 3 ] ifFalse: [ 5 ]hash  ^definition hashprocessReferenceNode: aNode  | varName |  varName := aNode name.  ignore = varName ifTrue: [ ^self ].  (aNode whoDefines: varName) ifNotNil: [ ^self ].  (self instanceVariableNames includes: varName) ifTrue: [ instVarReaders add: varName ].  (self classVariableNames includes: varName) ifTrue: [ classVarReaders add: varName ]testImplementorsMatching  | print |  print := RBBrowserEnvironment new implementorsMatching: '*print*'.  self universalTestFor: print.  self assert: (print implementorsOf: #printString) numberSelectors equals: (RBBrowserEnvironment new implementorsOf: #printString) numberSelectors.  print classesAndSelectorsDo: [:class :sel |  self assert: ('*print*' match: sel) ]testCompileInInteractively  | change |  change := changeFactory addMethodSource: 'setUp' in: self class classified: #running for: self.  self assert: change controller equals: self.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change selector equals: #setUp.  self assert: change source equals: 'setUp'.  self assert: change protocol equals: #running.  self universalTestFor: changerbClass  ^self class rbClasscalculateNewArgumentsIn: aMethodName  aMethodName arguments size > arguments size ifTrue: [ | selection |        selection := RBMethodArgumentsSelector openOn: aMethodName arguments copy and: (newMethod body allChildren select: #isLiteralNode thenCollect: [:e |  e value storeString ]) in: newMethod.        newMethod := selection newTree.        ^selection argumentsAndValues ].  ^Dictionary newtempsReadBeforeWritten  | temp |  self isVariable ifTrue: [ temp := 4 ].  ^tempremoveClassNamed: aSymbol  ^self addChange: (changeFactory removeClassNamed: aSymbol)testMethodDoesNotExist  | transformation |  transformation := (RBAddSubtreeTransformation interval: (0 to: 1) with: 'self printString' from: #two in: self changeMock name) transform.  self assertEmpty: transformation model changes changesstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' renameTemporaryFrom: '.  interval storeOn: aStream.  aStream     nextPutAll: ' to: ''';     nextPutAll: newName;     nextPutAll: ''' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: selector.  aStream nextPut: $)resetResult  rules do: [:each |  each resetResult ]forClass: aClass protocols: protocolCollection  ^RBProtocolEnvironment onEnvironment: self class: aClass protocols: protocolCollectionremoveParameter: aString in: aClass selector: aSelector  oldSelector := aSelector.  class := self classObjectFor: aClass.  argument := aStringresumeOnCannotRemoveTopLevelClassError: error  ^error messageText = RBRemoveClassRefactoring cannotRemoveTopLevelClassErrorMesssage ifTrue: [ error resume ]preconditions  ^(RBCondition isValidInstanceVariableName: newName for: class) & (RBCondition definesInstanceVariable: variableName in: class) & (RBCondition hierarchyOf: class definesVariable: newName) not & (RBCondition isGlobal: newName in: self model) notsort: aBlock  rules first isComposite ifTrue: [ rules do: [:rule |  rule sort: aBlock ] ] ifFalse: [ self rules: (rules sort: aBlock) ]collectionProtocol  | newCollection |  newCollection := OrderedCollection new.  (1 to: 10) asOrderedCollection do: [:each |  | new |        new := each * 2.        newCollection add: new ].  ^newCollectionstoreOn: aStream  | classBlock |  aStream     nextPutAll: '((';     nextPutAll: self class name;     nextPutAll: ' onEnvironment: '.  environment storeOn: aStream.  aStream     nextPut: $);     nextPutAll: ' classes: #('.  classBlock := [:key :value |  aStream     nextPutAll: '#(';     nextPutAll: key;     nextPutAll: ' #('.  value do: [:each |  aStream           nextPutAll: each;           nextPut: $  ].  aStream     nextPutAll: '))';     cr ].  classSelectors keysAndValuesDo: classBlock.  aStream nextPutAll: ') metaClasses: #('.  metaClassSelectors keysAndValuesDo: classBlock.  aStream nextPutAll: '))'testPerformRenameInstanceVariable  | change |  change := changes renameInstanceVariable: 'instVar' to: 'instVarPlus' in: self changeMock.  self perform: change do: [ self deny: (change changeClass instVarNames includes: change oldName).        self assert: (change changeClass instVarNames includes: change newName) ].  self assert: (change changeClass instVarNames includes: change oldName).  self deny: (change changeClass instVarNames includes: change newName)result  ^resulttestRefactoring  | refactoring class |  model defineClass: 'Object subclass: #Foo		instanceVariableNames: ''a''		classVariableNames: ''''		poolDictionaries: ''''		category: #''Refactoring2-Refactorings-Tests'''.  class := model classNamed: #Foo.  class     compile: 'foo	^Object' classified: #(#accessing);     compile: 'objectName ^#(Object)' classified: #(#accessing).  refactoring := (RBRenameClassTransformation model: model rename: #Object to: #Thing) asRefactoring transform.  self assert: (model includesClassNamed: #Thing).  self deny: (model includesClassNamed: #Object).  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo ^Thing').  self assert: (class parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^#(Thing)').  self assert: class superclass name equals: #Thingselectors  | selectors |  selectors := Set new.  selectors addAll: self newMethods keys.  self isDefined ifTrue: [ selectors addAll: self realClass selectors.        removedMethods ifNotNil: [ removedMethods do: [:each |  selectors remove: each ifAbsent: [  ] ] ] ].  ^selectorscheckBackReferencesTo: aSelector  | definingClass pushUpParseTree |  definingClass := targetSuperclass whoDefinesMethod: aSelector.  definingClass ifNil: [ ^self ].  pushUpParseTree := class parseTreeFor: aSelector.  targetSuperclass allSubclasses do: [:each |  each selectors do: [:sel |  | parseTree |              parseTree := each parseTreeFor: sel.              (parseTree notNil and: [ (parseTree superMessages includes: aSelector) and: [ definingClass == (each whoDefinesMethod: aSelector) ] ]) ifTrue: [ removeDuplicates := true.                    (aSelector == sel and: [ parseTree equalTo: pushUpParseTree exceptForVariables: #() ]) ifFalse: [ self refactoringError: ('Cannot pull up <1s> since it would override the method defined in <2p>' expandMacrosWith: aSelector with: definingClass) ] ] ] ]methodAfter  | variable |  variable := 'String'unmarkAsRemoved: newClassName  removedClasses     remove: newClassName ifAbsent: [  ];     remove: newClassName , ' class' ifAbsent: [  ]testDefinesClassVariable  self deny: (objectClass definesClassVariable: #ClassVariable1).  self assert: (objectClass definesClassVariable: self objectClassVariable).  self assert: (newClass definesClassVariable: #ClassVariable1).  self deny: (messageNodeClass definesClassVariable: #ClassVariable1).  self assert: (messageNodeClass definesClassVariable: self objectClassVariable)testSelectMethods  | environment |  environment := RBBrowserEnvironment new selectMethods: [:each |  false ].  self assert: environment numberSelectors equals: 0.  self assert: environment numberClasses equals: 0.  environment := RBBrowserEnvironment new selectMethods: [:each |  true ].  self assert: environment numberSelectors equals: RBBrowserEnvironment new numberSelectors.  environment := RBBrowserEnvironment new selectMethods: [:each |  each refersToLiteral: #environment ].  self assert: environment numberSelectors equals: (RBBrowserEnvironment new referencesTo: #environment) numberSelectorsonEnvironment: anEnvironment  environment := anEnvironmenttestExtractWithRenamingOfParameters  | refactoring class |  refactoring := RBExtractMethodRefactoring extract: (78 to: 197) from: #displayName in: RBLintRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo:.  refactoring parameterMap: (Dictionary new           at: #nameStream put: #newParameter;           yourself).  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class parseTreeFor: #displayName) equals: (self parseMethod: 'displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	self foo: nameStream.	^nameStream contents').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: newParameter 	newParameter nextPutAll: self name;		nextPutAll: '' (''.	self problemCount printOn: newParameter.	newParameter nextPut: $).')cancelAction: aBlock  cancelAction := aBlockfillOutDefinition: aDictionary  className := (aDictionary at: '`#traitName') asSymbol.  category := (aDictionary at: '`#package' ifAbsent: [ #Unclassified ]) asSymbolclassSide  ^selfpullUpClassInstanceVariables  | newSuperclass |  newSuperclass := self abstractSuperclass classSide.  parent classSide instanceVariableNames do: [:each |  self performComponentRefactoring: (RBPullUpInstanceVariableRefactoring model: self model variable: each class: newSuperclass) ]computeLiterals  literalSemaphore := Semaphore new.  literalProcess := [ self primitiveComputeLiterals ] forkreferencesTo: aLiteral  ^RBSelectorEnvironment referencesTo: aLiteral in: selfaddPackage: aSymbol  packages add: aSymbolname  ^nameresultClass  renrakuRule class checksNode ifTrue: [ ^RBSelectorEnvironment ].  renrakuRule class checksMethod ifTrue: [ ^RBSelectorEnvironment ].  renrakuRule class checksClass ifTrue: [ ^RBClassEnvironment ].  renrakuRule class checksPackage ifTrue: [ ^RBPackageEnvironment ].  ^RBMultiEnvironmentcheckClass: aRBClass selector: aSelector using: aMatcher  | parseTree |  parseTree := aRBClass parseTreeFor: aSelector.  parseTree ifNotNil: [ aMatcher executeTree: parseTree ].  ^aMatcher answerselectedClass: anObject  class := anObject.  self selector: nilcaller1  | anObject |  anObject := 5.  self called: anObject + 1 on1: [:each |  each printString.        ^anObject ]classBlock  ^self anInstVar + 5getNewMethodName  | newSelector methodName newMethodName |  methodName := RBMethodName new.  methodName arguments: parameters.  [ newMethodName := self requestMethodNameFor: methodName.  newMethodName ifNil: [ self refactoringFailure: 'Did not extract code' ].  newSelector := newMethodName selector.  (self checkMethodName: newSelector in: class) ifFalse: [ self refactoringWarning: newSelector , ' is not a valid selector name.'.        newSelector := nil ].  (class hierarchyDefinesMethod: newSelector asSymbol) ifTrue: [ (self shouldOverride: newSelector in: class) ifFalse: [ newSelector := nil ] ].  newSelector isNil ] whileTrue: [  ].  parameters := newMethodName arguments asOrderedCollection.  ^newSelector asSymbolbasicCheck: aMethod  (self matcher canMatchMethod: aMethod) ifFalse: [ ^false ].  ^(self matcher executeTree: aMethod ast initialAnswer: nil) isNotNiltestTransform  | transformation class |  transformation := (RBRemoveSubtreeTransformation code: '^ 1' from: #one in: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class directlyDefinesMethod: #one).  self assertEmpty: (class parseTreeFor: #one) body statementscategory  ^categorytestRemoveInstVar  | refactoring class |  refactoring := RBRemoveInstanceVariableRefactoring variable: 'foo1' class: RBLintRuleTestData.  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class definesInstanceVariable: 'foo1').  self executeRefactoring: refactoring.  self deny: (class definesInstanceVariable: 'foo1')testBadName  self     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'name' in: RBLintRuleTestData selector: #openEditor);     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'rules' in: RBLintRuleTestData selector: #openEditor);     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'DependentFields' in: RBLintRuleTestData selector: #openEditor);     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'a b' in: RBLintRuleTestData selector: #openEditor)variableDefinitionsInHierarchy  ^self definingClass allSubclasses select: [:each |  isClassVariable ifTrue: [ each isMeta not and: [ each directlyDefinesClassVariable: variableName ] ] ifFalse: [ each directlyDefinesInstanceVariable: variableName ] ] thenCollect: #nametestBadMethod  self shouldFail: (RBAddMethodRefactoring addMethod: 'asdf ^super ^printString' toClass: RBBasicLintRuleTestData inProtocols: #(#accessing))variables: anArray  variables := anArraytestClassDoesNotExist  self shouldFail: (RBAddMessageSendTransformation messageSend: 'variable byteAt: 1' inMethod: #methodBefore inClass: #RBMessageSendTransformationTest) asRefactoringpreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'No such class or trait named ' , className asString) & (RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ self definingMethod allTemporaryVariables includes: variableName ] errorString: 'Method named ' , selector , ' does not define a temporary variable named ' , variableName) & (RBCondition withBlock: [ (self definingMethod allArgumentVariables includes: variableName) not ] errorString: 'Variable named ' , variableName , ' cannot be removed because it is an argument in this method')testCompileInClass  | change |  change := changes compile: 'setUp' in: self class.  self assert: change controller isNil.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change selector equals: #setUp.  self assert: change source equals: 'setUp'.  self assert: change protocol equals: #running.  self universalTestFor: changeproblemCount  ^rules inject: 0 into: [:count :each |  count + each problemCount ]methodAfter  | variable |  variable := 'String'.  variable byteAt: 1testRemoveMethod  | refactoring selectors |  selectors := Array with: ('selectorNot' , 'Referenced') asSymbol.  refactoring := RBRemoveMethodRefactoring removeMethods: selectors from: RBRefactoryTestDataApp.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) directlyDefinesMethod: selectors first).  self executeRefactoring: refactoring.  self deny: ((refactoring model classNamed: #RBRefactoryTestDataApp) directlyDefinesMethod: selectors first)transform  class removeInstanceVariable: variableName.  class subclasses do: [:each |  each addInstanceVariable: variableName ]primitiveExecute  self changeClass perform: self changeSymbol with: self changeObjectnumberOfSelfSendsIn: aParseTree  | search |  search := self parseTreeSearcher.  search matches: self messagePattern do: [:aNode :answer |  answer + 1 ].  ^search executeTree: aParseTree initialAnswer: 0testVariableDoesNotExist  self shouldFail: (RBRemoveAssignmentTransformation variable: 'variable1' value: '1 asString' inMethod: #methodBefore inClass: #RBRemoveAssignmentTransformationTest) asRefactoringast  ^self parseTreevariable: aVariableName value: anExpression inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  variableName := aVariableName.  value := anExpressiondefineSetterMethod  | selector sourceCode |  sourceCode := '<1s> anObject<r><t><2s> := anObject'.  selector := self safeMethodNameFor: self definingClass basedOn: variableName asString , ':'.  self definingClass compile: (sourceCode expandMacrosWith: selector with: variableName) classified: #accessing.  ^selectorcheckInstVarsFor: aSelector  class instanceVariableNames do: [:each |  ((class whichSelectorsReferToInstanceVariable: each) includes: aSelector) ifTrue: [ self refactoringError: ('<1p> refers to <2s> which is defined in <3p>' expandMacrosWith: aSelector with: each with: class) ] ]selectors  ^Array streamContents: [:stream |  self classesDo: [:class |  self selectorsForClass: class do: [:selector |  stream nextPut: selector ] ] ]demoMethodWithDuplicates  | a b result1 result2 answer |  a := 3.  b := a + 5.  result1 := a + b.  result2 := a + 5.  answer := result1 + result2 + (a + 5).  ^answerinlineLast  5 = 3 ifTrue: [ ^self caller ] ifFalse: [ ^self caller2 ]preconditions  | selector method |  method := self parserClass parseMethod: source onError: [:string :position |  ^RBCondition withBlock: [ self refactoringFailure: 'The sources could not be parsed' ] ].  selector := method selector.  selector ifNil: [ self refactoringFailure: 'Invalid source.' ].  ^(RBCondition canUnderstand: selector in: class) notrequestImplementorToInline: implementorsCollection  ^(self options at: #implementorToInline) value: self value: implementorsCollectionremoveClass  self model removeClassNamed: classNamecompiledMethodIn: aClass  ^[ aClass >> newExtractedSelector ] on: Exception do: [ | aSuperClass |        aSuperClass := aClass superclass.        aSuperClass ifNil: [ ^nil ] ifNotNil: [ self compiledMethodIn: aSuperClass ] ]valueIndex: anInteger  selectedValueIndex := anInteger.  self changed: #valueIndexpreconditions  ^RBCondition definesInstanceVariable: variableName in: classallClassVariableNames  ^self subclassResponsibilityvariableAssignedLiteral  temporaryVariable := #()release  self printStringwhichProtocolIncludes: aSelector in: aClass  ^aClass organization categoryOfElement: aSelector ifAbsent: [ Protocol unclassified ]testMethodDoesNotExist  self shouldFail: (RBExtractMethodTransformation extract: 'bla' from: #checkClass1: to: #bla in: #RBBasicLintRuleTestData) asRefactoringconvertClasses: classSet select: aBlock using: searchReplacer  classSet do: [:aClass |  (aBlock value: aClass) do: [:selector |  aClass convertMethod: selector using: searchReplacer ] ]buildMessageSearch  self createSearchWith: '``@receiver -> ``@arg' selectors: #(#superSends #superSends) inClass: RBTransformationRuleTestDatatestModelBadName  | class |  model := RBClassModelFactory rbNamespace new.  class := model classNamed: #Object.  class compile: 'aMethod: temp1 ^[| temp2 | temp2 := [:temp3 | temp3 = 5] value: 5. temp2] value' classified: #(#accessing).  self     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (20 to: 24) to: 'temp3' in: class selector: #aMethod:);     shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (20 to: 24) to: 'temp1' in: class selector: #aMethod:)checkBrowseOccurrences: anCollectionOfOccurrences  anCollectionOfOccurrences size = 1 ifTrue: [ ^self checkBrowseOccurrenceIn: anCollectionOfOccurrences first value ] ifFalse: [ ^self checkBrowseAllOccurences: anCollectionOfOccurrences ]copy: aClass name: aSymbol  ^self duplicate: aClass name: aSymbol deep: truedefinition: aString controller: aController  isMeta := false.  definition := aString.  controller := aControllervariable: aVariableName value: anExpression inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector asSymbol.  variableName := aVariableName asSymbol.  value := anExpressionsetupVariableToMoveToFor: aRefactoring toReturn: aString  | options |  options := aRefactoring options copy.  options at: #selectVariableToMoveTo put: [:ref :class :selector |  aString ].  aRefactoring options: optionstestModelPushDownToMultipleSubclasses  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #AnotherSubclass) compile: 'bar ^foo' classified: #(#accessing).  self executeRefactoring: (RBPushDownInstanceVariableRefactoring model: model variable: 'foo' class: (model classNamed: #SomeClass)).  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #AnotherSubclass) directlyDefinesVariable: 'foo')testClassVariableInModel  | class |  (RBProtectVariableTransformation model: model classVariable: 'ClassVarName1' class: #Foo) asRefactoring transform.  class := (model classNamed: #Foo) theMetaClass.  self assert: (class parseTreeFor: #classVarName1) equals: (self parseMethod: 'classVarName1 ^ClassVarName1').  self assert: (class parseTreeFor: #classVarName1:) equals: (self parseMethod: 'classVarName1: anObject ClassVarName1 := anObject').  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo				^self classVarName1: self classVarName1 * self classVarName1 * self classVarName1').  self assert: (class theNonMetaClass parseTreeFor: #classVarName1) equals: (self parseMethod: 'classVarName1 ^self class classVarName1').  self assert: (class theNonMetaClass parseTreeFor: #classVarName1:) equals: (self parseMethod: 'classVarName1: anObject				^self class classVarName1: anObject')testTransform  | transformation class |  transformation := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  transformation := (RBRemoveTemporaryVariableTransformation model: transformation model variable: 'temp' inMethod: #foo inClass: self changeMock name) transform.  self assert: transformation model changes changes size equals: 2.  class := transformation model classNamed: self changeMock name.  self assert: (class directlyDefinesMethod: #one).  self assert: (class parseTreeFor: #foo) temporaries size equals: 1storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' variable: '.  variableName storeOn: aStream.  aStream nextPutAll: ' class: '.  class storeOn: aStream.  aStream nextPut: $)initializeDialogWindow: aModalPresenter  aModalPresenter     initialExtent: 700 @ 500;     addButton: 'Cancel' do: cancelAction;     addButton: 'Replace' do: [:presenter |  self accept: presenter ];     addButton: 'Skip' do: skipAction;     addButton: 'Replace all' do: replaceAllActionresult: aResult  result := aResult copyEmptyremoveInstanceVariable: variableName from: aClass  ^self addChange: (changeFactory removeInstanceVariable: variableName from: aClass)buildTransformations  ^OrderedCollection with: (RBAddVariableAccessorTransformation model: self model variable: variableName asString class: className classVariable: isClassVariable) with: (RBRemoveDirectAccessToVariableTransformation model: self model variable: variableName asString class: className classVariable: isClassVariable)executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: aString  ^[ aBlock value.  false ] on: anExceptionalEvent do: [:ex |  ex return: (ex description includesSubstring: aString) ]minMax  ^3 < 5 ifTrue: [ 3 ] ifFalse: [ 5 ]testRemoveInstanceVariable  | change |  change := changes removeInstanceVariable: 'instVar' from: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change variable equals: 'instVar'.  self universalTestFor: changewithClassesFixedForNautilus  instanceVariables ifEmpty: [ classVariables keysAndValuesDo: [:class :variables |  instanceVariables at: class ifAbsentPut: [ Set new ] ] ]testClassVariable  | refactoring class |  refactoring := (RBPushDownVariableTransformation classVariable: #Foo1 class: #RBDummyLintRuleTest) asRefactoring.  class := refactoring model classNamed: #RBDummyLintRuleTest.  self assert: (class directlyDefinesClassVariable: #Foo1).  refactoring transform.  class withAllSubclasses do: [:each |  self deny: (each directlyDefinesClassVariable: #Foo1) ]processCollectionFor: key messagesTo: aName in: aBlock  | searcher |  searcher := self parseTreeSearcher.  searcher matches: aName , ' `@message: ``@args' do: [:aNode :answer |  self processCollectionMessagesFor: key in: aNode.        answer           add: aNode selector;           yourself ].  searcher executeTree: aBlock initialAnswer: (variableMessages at: (self collectionNameFor: key) ifAbsentPut: [ Set new ])testAlreadyDefinesReturn  self shouldFail: (RBAddReturnStatementTransformation return: '^ variable' inMethod: #methodAfter inClass: #RBAddReturnStatementTransformationTest) asRefactoringsourceCode: aString in: aClassName withProtocol: aSymbol  self className: aClassName.  sourceCode := aString.  protocol := aSymbol asSymboljustSendsSuper: aSelector  | matcher parseTree superclass |  matcher := self parseTreeSearcherClass justSendsSuper.  parseTree := class parseTreeFor: aSelector.  (matcher executeTree: parseTree initialAnswer: false) ifFalse: [ ^false ].  parseTree lastIsReturn ifTrue: [ ^true ].  superclass := class superclass whichClassIncludesSelector: aSelector.  superclass ifNil: [ ^true ].  parseTree := superclass parseTreeFor: aSelector.  matcher := self parseTreeSearcher.  matcher matches: '^``@object' do: [:aNode :answer |  answer           add: aNode value;           yourself ].  matcher executeTree: parseTree initialAnswer: Set new.  ^(matcher answer anySatisfy: [:each |  each isSelf not ]) notasUndoOperation  | trait |  trait := onSystemDictionary classOrTraitNamed: self changeClassName.  ^trait isTrait ifTrue: [ changeFactory addTraitDefinition: trait oldDefinition ] ifFalse: [ changeFactory removeClassNamed: self changeClassName ]getExtractedSource  | source |  source := class sourceCodeFor: selector.  ((extractionInterval first between: 1 and: source size) and: [ extractionInterval last between: 1 and: source size ]) ifFalse: [ self refactoringFailure: 'Invalid interval' ].  ^source copyFrom: extractionInterval first to: extractionInterval lastinlineTemporary  | temp |  self isNil ifTrue: [ temp := 4 ].  ^tempselectedClass: aClass  class := model classFor: aClassincludesProtocol: aProtocol in: aClass  ^(self selectorsFor: aProtocol in: aClass) isNotEmptystoreOn: aStream  aStream nextPut: $(.  environment storeOn: aStream.  aStream nextPutAll: ' | '.  orEnvironment storeOn: aStream.  aStream nextPut: $)selector  ^selectordelegatesPreconditions: aBoolean  delegatesPreconditions := aBooleancopyOldValuesToNewVariable  self subclassResponsibilityremoveDefinedClassVariables  | selectionBlock nonMetaClass |  nonMetaClass := fromClass instanceSide.  selectionBlock := [:varName |  (toClasses detect: [:each |  (each instanceSide includesClass: (nonMetaClass whoDefinesClassVariable: varName)) not ] ifNone: [ nil ]) notNil ].  classVarReaders := classVarReaders select: selectionBlock.  classVarWriters := classVarWriters select: selectionBlockinline: anInterval inMethod: aSelector forClass: aClass  sourceSelector := aSelector.  class := self classObjectFor: aClass.  sourceInterval := anIntervalassignmentInIfTrue  | variable |  self isVariable ifTrue: [ variable := self ] ifFalse: [ variable := self printString ].  ^variablemodifyImplementorParseTree: parseTree in: aClass  | oldArgs |  oldArgs := parseTree arguments.  parseTree renameSelector: newSelector andArguments: (permutation collect: [:each |  oldArgs at: each ])testTransform  | transformation newClassName class |  newClassName := (self changeMock name , 'Temporary') asSymbol.  transformation := RBCustomTransformation with: [:aModel |  aModel defineClass: ('<1p> subclass: #<2s>				instanceVariableNames: ''''				classVariableNames: ''''				poolDictionaries: ''''				category: <3p>' expandMacrosWith: 'Object' with: newClassName with: self class category).        (aModel classNamed: newClassName) comment: 'Deprecated!!! Use super class'.        (aModel classNamed: newClassName) addInstanceVariable: 'asdf' ].  transformation transform.  self assert: transformation model changes changes size equals: 3.  class := transformation model classNamed: (self changeMock name , 'Temporary') asSymbol.  self assert: (class directlyDefinesInstanceVariable: 'asdf')testNonExistantName  self shouldFail: (RBPushDownClassVariableRefactoring variable: #Foo class: RBBasicLintRuleTestData)isSystem  ^truetestReferencedVariable  self shouldFail: (RBRemoveClassVariableRefactoring variable: #RecursiveSelfRule class: RBTransformationRuleTestData)testExtractMethodAtEndOfMethodThatNeedsReturn  | refactoring class |  refactoring := RBExtractMethodRefactoring extract: (52 to: 133) from: #openEditor in: RBLintRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo:.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor	| rules |	rules := self failedRules.	^self foo: rules').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: rules	rules isEmpty ifTrue: [^self].	rules size == 1 ifTrue: [^rules first viewResults]')printOn: aStream  aStream     nextPutAll: self displayClassName;     nextPutAll: ' classCategory: ';     print: self displayCategoryName;     nextPutAll: ' stamp: ';     print: self changeStamp;     nextPutAll: '!'errorStringFor: aBoolean  ^aBoolean ifTrue: [ self neitherFailed ] ifFalse: [ self perform: failed ]testTransform  | transformation class |  transformation := (RBSplitClassTransformation class: #RBRemoveDirectAccessToVariableTransformation instanceVariables: #(receiver) newClassName: #RBRemoveDirectAccessWithReceiverTransformation referenceVariableName: #newReceiver) transform.  class := transformation model classNamed: #RBRemoveDirectAccessToVariableTransformation.  self deny: (class instanceVariableNames includes: #receiver).  self assert: (class instanceVariableNames includes: #newReceiver).  self assert: (class parseTreeFor: #receiver:) equals: (self parseMethod: 'receiver: aString					newReceiver receiver: aString').  self assert: (class parseTreeFor: #receiver) equals: (self parseMethod: 'receiver					^ newReceiver receiver 						ifNil: [ self receiver: ' , 'self' surroundedBySingleQuotes , '. newReceiver receiver ]').  class := transformation model classNamed: #RBRemoveDirectAccessWithReceiverTransformation.  self deny: class isNil.  self assert: (class instanceVariableNames includes: #receiver).  self assert: (class directlyDefinesLocalMethod: #receiver).  self assert: (class directlyDefinesLocalMethod: #receiver:)sourceCodeAt: anInterval forMethod: aSelector in: aClass  ^(aClass sourceCodeAt: aSelector) copyFrom: anInterval first to: anInterval lastshouldnt: aBlock raise: anExceptionalEvent  ^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) notreceiver  ^receiver ifNil: [ self receiver: 'self'.        receiver ]create: aClass name: aSymbol  ^self duplicate: aClass name: aSymbol deep: falseprotocolsFor: aClass  ^aClass organization categories select: [:each |  self includesProtocol: each in: aClass ]addClass: aName superclass: aClass subclasses: aCollection category: aSymbol  self className: aName.  superclass := self classObjectFor: aClass.  subclasses := aCollection collect: [:each |  self classObjectFor: each ].  category := aSymboltestMatches  | envEnvironment environmentEnvironment |  envEnvironment := RBBrowserEnvironment new matches: '*env*'.  environmentEnvironment := RBBrowserEnvironment new referencesTo: #environment.  self assert: (envEnvironment referencesTo: #environment) numberSelectors equals: environmentEnvironment numberSelectorstestPerformCompositeChange  changes     compile: 'method1 ^ 1' in: self changeMock;     compile: 'method2 ^ 2' in: self changeMock.  self perform: changes do: [ self assert: (self changeMock canUnderstand: #method1).        self assert: (self changeMock canUnderstand: #method2) ].  self deny: (self changeMock canUnderstand: #method1).  self deny: (self changeMock canUnderstand: #method2)problemCount  ^environmentDictionaries sizestoreOn: aStream  aStream nextPutAll: self nameremoveSubtree: aTree in: aMethodTree  ^[ self parseTreeRewriterClass replaceStatements: aTree formattedCode with: '' in: aMethodTree onInterval: aTree sourceInterval ] on: Error do: [ self parseTreeRewriterClass replace: aTree formattedCode with: '' in: aMethodTree onInterval: aTree sourceInterval ]transform  self computePoolsToMove.  self hasPoolsToMove ifTrue: [ self refactoringWarning: 'This method contains references to pools<n>which may need to be moved.' expandMacros ].  self movePoolVariablescheckMethod: aSmalllintContext  testRefactoring  | refactoring class |  refactoring := (RBAddReturnStatementTransformation return: '^ variable' inMethod: #methodBefore inClass: #RBAddReturnStatementTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBAddReturnStatementTransformationTest.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyselector  ^selectortestBadSourceCode  self shouldFail: (RBAddMethodTransformation sourceCode: 'asdf ^super ^printString' in: RBBasicLintRuleTestData withProtocol: #accessing) asRefactoringerrorBlockFor: aBoolean  ^nilrenderContentOn: html  html form: [ html text: 'Name:'.        html textInput on: #name of: self contact.        html break.        html text: 'Email address:'.        html textInput on: #emailAddress of: self contact.        html break.        html text: 'Example:'.        html textInput on: #example of: self contact.        html break ].  html text: 'Last:'.  html textInput on: #last of: self contact.  html breakpreconditions  ^RBCondition emptyexampleClasses  < sampleInstance>  ^{ProtoObject .   Object .   Class .   Metaclass .   Behavior .   ClassDescription .   Dictionary .   Trait .   SmalltalkImage}inlineComponent  | a |  a := 5.  ^a class     superclass;     hasImmediateInstances;     yourselfrenameAccessors  ^renameAccessorsstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' protocol: ''';     nextPutAll: protocol;     nextPutAll: ''' inClass: ''';     nextPutAll: className.  aStream nextPut: $)selfMessages  ^self parseTree selfMessagesinitialize  super initialize.  name := #'Unknown Class'computeLiteralsForClass: aClass  (selectors addAll: aClass selectors) do: [:sel |  self computeLiteralsForSelector: sel in: aClass.        Processor yield ]shouldFail: aRefactoring  self proceedThroughWarning: [ self should: [ self executeRefactoring: aRefactoring ] raise: RBRefactoringError ]preconditions  ^(RBCondition withBlock: [ deprecatedClass notNil and: [ deprecatedClass isMeta not ] ]) & (RBCondition isValidClassName: newName) & (RBCondition isGlobal: newName in: self model) | (RBCondition withBlock: [ self refactoringFailure: newName , ' is not a valid class name' ])addMethodSource: sourceCode in: aClass classified: aProtocol  ^RBAddMethodChange compile: sourceCode in: aClass classified: aProtocoltestRemoveAClassAndTheirSubclass  | refactoring |  refactoring := RBRemoveClassRefactoring classNames: {#RBSharedPoolForTestData1 .         #RBSharedPoolForTestData2}.  self executeRefactoring: refactoring.  self assert: (refactoring model classNamed: #RBSharedPoolForTestData2) isNil.  self assert: (refactoring model classNamed: #RBSharedPoolForTestData1) isNilclassesAndSelectorsDo: aBlock  self classesDo: [:class |  self selectorsForClass: class do: [:sel |  aBlock value: class value: sel ] ]removeClass: aClass selector: aSelector  (aClass isMeta ifTrue: [ metaClassSelectors at: aClass soleInstance name ifAbsent: [ ^self ] ] ifFalse: [ classSelectors at: aClass name ifAbsent: [ ^self ] ]) remove: aSelector ifAbsent: [  ]compositeRefactoryChange  ^RBCompositeRefactoryChange newcollectionProtocol  | newCollection |  newCollection := OrderedCollection new.  (1 to: 10) asOrderedCollection do: [:each |  | new |        new := each * 2.        newCollection add: new ].  ^newCollectionchangeClass: aBehavior  super changeClass: aBehavior.  isMeta := falsecheckMethod: aSmalllintContext  ^methodBlock value: aSmalllintContext value: resultremoveExtensionMethods  (self instanceSideExtensionMethodsOf: deprecatedClass) do: [:each |  deprecatedClass instanceSide removeMethod: each selector ].  (self classSideExtensionMethodsOf: deprecatedClass) do: [:each |  deprecatedClass classSide removeMethod: each selector ]checkMethod: aSmalllintContext  ^methodBlock value: aSmalllintContext value: resultdefinedSelector  ^definedSelectorselectorsToPushUpFrom: aClass  | superSelectors |  superSelectors := self computeSubclassSupersOf: aClass.  ^aClass selectors select: [:each |  (superSelectors includes: each) or: [ self shouldPushUp: each from: aClass ] ]caller2  ^(1 to: 10) inject: 1 into: [:sum :each |  sum * (self foo: each) ]className: aName newName: aNewName  className := aName asSymbol.  class := self model classNamed: className.  newName := aNewName asSymbolpreconditionIsNotMetaclass: aClass  ^((RBCondition isMetaclass: aClass) errorMacro: 'Cannot remove just the metaclass') notprintOn: aStream  name ifNil: [ super printOn: aStream ] ifNotNil: [ aStream nextPutAll: name ]unaryNonAccessingBranchingStatementMethodWithoutReturn  self value isString ifTrue: [ self value ] ifFalse: [ '' ]initialize  super initialize.  categories := IdentitySet newshouldExtractAssignmentTo: aString  ^(self options at: #extractAssignment) value: self value: aStringshould: aBlock notTakeMoreThan: aDuration  ^aBlock valueWithin: aDuration onTimeout: [ self assert: false description: [ 'Block evaluation took more than the expected <1p>' expandMacrosWith: aDuration ] ]testVariableDoesNotExist  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  self     shouldFail: (RBPushDownVariableTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBPushDownVariableTransformation model: model classVariable: #Foo class: (model classNamed: #SomeClass)) asRefactoring;     shouldFail: (RBPushDownVariableTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoringtransform  self     copyDownMethods;     pullUpMethods;     removePulledUpMethods;     removeDuplicateMethodsinitialize  super initialize.  arguments := 0.  temporaries := 0.  difference := 0preconditions  | newCondition |  newCondition := (RBCondition withBlock: [ newSelector = oldSelector ] errorString: 'The selector name has <1?not:> changed <1?:to #' , newSelector , '>') & (RBCondition withBlock: [ permutation asArray ~= (1 to: oldSelector numArgs) asArray ] errorString: 'The arguments are <1?:not >permuted').  ^newCondition | super preconditionsparseMethod: aString  ^self parserClass parseMethod: aStringvariable: aVariableName class: aClassName classVariable: aBoolean  variableName := aVariableName.  isClassVariable := aBoolean.  className := aClassNamesendsDifferentSuper  super printStringvalues  ^valuesList ifNil: [ valuesList := values asOrderedCollection ]findReceiverNode  | receiverNodes |  receiverNodes := statementNodes collect: [:each |  each receiver ].  receiverNodes asSet size = 1 ifFalse: [ self refactoringError: 'All statements must have the same receiver' ].  (receiverNodes first isLiteralNode or: [ receiverNodes first isVariable ]) ifFalse: [ self refactoringWarning: 'The receiver is an expression. Proceed with caution' ]directlyDefinesClassVariable: aString  ^self classVariableNames includes: aString asSymbolpreconditionChecking  ^preconditionCheckinghasConflicts  ^falsetestRemoveClassVariable  | refactoring class |  refactoring := (RBRemoveVariableTransformation classVariable: 'Foo1' class: #RBDummyLintRuleTest) asRefactoring.  class := refactoring model classNamed: #RBDummyLintRuleTest.  self assert: (class definesClassVariable: 'Foo1').  refactoring transform.  self deny: (class definesClassVariable: 'Foo1')storeOn: aStream  aStream     nextPut: $(;     nextPutAll: self class name;     nextPutAll: ' new '.  self accessorMethods do: [:each |  aStream           nextPutAll: each;           nextPutAll: ': '.        (self perform: each) storeOn: aStream.        aStream nextPutAll: '; ' ].  aStream nextPutAll: 'yourself)'hasMultipleReturns  | searcher |  searcher := self parseTreeSearcher.  searcher matches: '^``@object' do: [:aNode :hasAReturn |  hasAReturn ifTrue: [ ^true ].        true ].  searcher executeTree: inlineParseTree initialAnswer: inlineParseTree lastIsReturn not.  ^falseinterval: anInterval with: aString from: aSelector in: aClass  self className: aClass.  selector := aSelector.  interval := anInterval.  sourceCode := aStringwhichCategoryIncludes: aSymbol  ^self environment whichCategoryIncludes: aSymbolpreconditions  | references |  references := RBCondition referencesInstanceVariable: variableName in: class.  class realClass ifNil: [ references errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName) ] ifNotNil: [ references           errorMacro: ('<1s> is referenced.<n>Browse references?' expandMacrosWith: variableName);           errorBlock: [ self openBrowserOn: (RBBrowserEnvironment new instVarRefsTo: variableName in: class realClass) ] ].  ^(RBCondition definesInstanceVariable: variableName in: class) & references notparseExpression: aString  ^self parserClass parseExpression: aStringtestClassDoesNotExist  self shouldFail: (RBRemoveReturnStatementTransformation return: '^ variable' inMethod: #methodBefore inClass: #RBReturnStatementTransformationTest) asRefactoringisSystem  ^falseprivateTransform  self model selector: self definingMethod selector in: self definingClass classified: self protocoltestTransform  | transformation class |  transformation := (RBAddReturnStatementTransformation new return: '^ variable' inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodydeprecateMethod: aSelector in: aClass using: newSel  oldSelector := aSelector.  newSelector := newSel.  class := self classObjectFor: aClasstestRemoveNonExistantMethod  self shouldFail: (RBRemoveHierarchyMethodRefactoring removeMethods: #(#msg7) from: RBBasicLintRuleTestData)testBadInterval  self     shouldFail: (RBExtractMethodRefactoring extract: (24 to: 30) from: #testMethod in: RBRefactoryTestDataApp);     shouldFail: (RBExtractMethodRefactoring extract: (80 to: 147) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class)methodBefore  | variable |  variable := 'String'.  ^variableclassSideExtensionMethodsOf: anRBClass  ^anRBClass realClass classSide localMethods select: #isExtension thenCollect: [:each |  anRBClass classSide methodFor: each selector ]addInstanceVariables  instanceVariables collect: [:instVar |  RBAddVariableTransformation model: self model instanceVariable: instVar class: newClassName ] thenDo: [:each |  transformations add: each ]oldVersionTextToDisplay  ^String streamContents: [:stream |  stream           nextPutAll: '"protocol: ';           nextPutAll: self oldProtocol;           nextPutAll: '"';           nextPutAll: String cr;           nextPutAll: super oldVersionTextToDisplay ]inlineMethod  | temp |  temp := self     foo;     inlineMethod;     bar.  ^tempfindCascadeNode  cascadeNode := self parseTree bestNodeFor: selectedInterval.  [ cascadeNode isNil or: [ cascadeNode isCascade ] ] whileFalse: [ cascadeNode := cascadeNode parent ].  cascadeNode ifNil: [ self refactoringFailure: 'The selection doesn''t appear to be within a cascade' ]msg4  ^Var1requestSelfArgumentName  ^(self options at: #selfArgumentName) value: selfdirectlyDefinesPoolDictionary: aString  ^self sharedPoolNames includes: aString asSymbolextract: ocurrence of: aMethod executing: aSymbol  | refactoring association |  refactoring := self extractMethodRefactoring.  association := ocurrence asOrderedCollection at: positionIndex.  refactoring extract: association key from: aMethod selector in: aMethod origin.  refactoring setOption: #existingSelector toUse: [:ref |  ref parameters: (self argumentsOf: association value).        method selector ].  refactoring perform: aSymbol.  ^refactoringcheckMethod: aSmalllintContext  rules do: [:each |  each checkMethod: aSmalllintContext.        Processor yield ]privateSelectorsForClass: aClass  ^aClass isMeta ifTrue: [ metaClassSelectors at: aClass soleInstance name ifAbsent: [ #() ] ] ifFalse: [ classSelectors at: aClass name ifAbsent: [ #() ] ]initialize  super initialize.  preconditionChecking := falsedetectContains  ^(1 to: 10) do: [:each |  each > 2 ifTrue: [ ^each ] ]classesDo: aBlock  classes do: [:each |  | class |        class := self systemDictionary at: each ifAbsent: [ nil ].        (class notNil and: [ environment includesClass: class ]) ifTrue: [ aBlock value: class ] ].  metaClasses do: [:each |  | class |        class := self systemDictionary at: each ifAbsent: [ nil ].        (class notNil and: [ environment includesClass: class classSide ]) ifTrue: [ aBlock value: class classSide ] ]definesClass: aClass  ^(super definesClass: aClass) and: [ categories includes: aClass instanceSide category ]checkTemporaries  | temps accesses assigned |  temps := self remainingTemporaries.  accesses := temps select: [:each |  extractedParseTree references: each ].  assigned := accesses select: [:each |  extractedParseTree assigns: each ].  assigned ifNotEmpty: [ self checkAssignments: assigned ].  ^parameters := accesses asOrderedCollection     removeAll: assigned;     yourselftestVariableEnvironmentAddRemove  | refs |  refs := RBVariableEnvironment new.  refs addClass: self class instanceVariable: 'universalEnvironment'.  self assert: refs numberSelectors > 0.  self assert: refs numberClasses equals: 1.  refs removeClass: self class instanceVariable: 'universalEnvironment'.  self assert: refs numberSelectors equals: 0.  self assert: refs numberClasses equals: 0.  refs addClass: self class instanceVariableReader: 'universalEnvironment'.  self assert: refs numberSelectors > 0.  self assert: refs numberClasses equals: 1.  refs removeClass: self class instanceVariableReader: 'universalEnvironment'.  self assert: refs numberSelectors equals: 0.  self assert: refs numberClasses equals: 0.  refs addClass: self class instanceVariableWriter: 'universalEnvironment'.  self assert: refs numberSelectors > 0.  self assert: refs numberClasses equals: 1.  refs removeClass: self class instanceVariableWriter: 'universalEnvironment'.  self assert: refs numberSelectors equals: 0.  self assert: refs numberClasses equals: 0.  refs addClass: self class classVariable: 'ClassVariable'.  self assert: refs numberSelectors > 0.  self assert: refs numberClasses equals: 1.  refs removeClass: self class classVariable: 'ClassVariable'.  self assert: refs numberSelectors equals: 0.  self assert: refs numberClasses equals: 0haltClassMentioned  Halt nowconvertMethod: selector using: searchReplacer  | parseTree |  parseTree := self parseTreeFor: selector.  parseTree ifNil: [ ^self ].  (searchReplacer executeTree: parseTree) ifTrue: [ self compileTree: searchReplacer tree ]formOldName  ^self formNameFor: oldSelectorincludesCategory: aCategory  ^environment includesCategory: aCategorysubclassesDo: aBlock  self subclasses do: aBlockextract: anInterval to: aString from: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  sourceInterval := anInterval.  newVariableName := aStringexampleCall  < sampleInstance>  ^self rename: 1 two: 2needsReturnForSetter  needsReturn ifNil: [ needsReturn := self usesAssignmentOf: variableName in: class classVariable: classVariable ].  ^needsReturnclassVariableReader  ^ClassVariablevariables: anArray  variables := anArrayisComposite  ^falsetestWithArgument  | refactoring class |  refactoring := (RBExtractMethodTransformation extract: (self sourceCodeAt: (145 to: 343) forMethod: #checkMethod: in: RBTransformationRuleTestData) from: #checkMethod: to: #foo: in: #RBTransformationRuleTestData) asRefactoring transform.  self assert: refactoring model changes changes size equals: 2.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 					class := aSmalllintContext selectedClass.					(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 						[self foo: aSmalllintContext]').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: aSmalllintContext					(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)						ifFalse: 							[builder compile: rewriteRule tree printString										in: class										classified: aSmalllintContext protocols]')check: anEntity forCritiquesDo: aCriticBlock ifNone: alternativeBlock  | encounteredCritique |  encounteredCritique := false.  self check: anEntity forCritiquesDo: [:crit |  encounteredCritique := true.        aCriticBlock cull: crit ].  encounteredCritique ifFalse: alternativeBlocknoMoveDefinition  | temp |  ^(self collect: [:each |  temp := each printString.        temp , temp ]) select: [:each |  temp := each size + temp ]testVariableEnvironmentInstVars  | refs writers readers classRefs |  self timeLimit: 300 seconds.  refs := RBVariableEnvironment referencesToInstanceVariable: 'universalEnvironment' in: self class.  writers := RBVariableEnvironment writersOfInstanceVariable: 'universalEnvironment' in: self class.  readers := RBVariableEnvironment readersOfInstanceVariable: 'universalEnvironment' in: self class.  classRefs := RBVariableEnvironment referencesToClassVariable: 'ClassVariable' in: self class.  self universalTestFor: refs.  self universalTestFor: writers.  self universalTestFor: readers.  self universalTestFor: classRefs.  self deny: universalEnvironment isVariableEnvironment.  self assert: refs isVariableEnvironment.  self assert: refs numberSelectors equals: (writers | readers) numberSelectorschangeForMetaclass: aClassName selector: aSelector  ^(isMeta and: [ self selector = aSelector and: [ className = aClassName ] ]) ifTrue: [ self ] ifFalse: [ nil ]includesSelector: aSelector in: aClass  ^(super includesSelector: aSelector in: aClass) and: [ protocols includes: (environment whichProtocolIncludes: aSelector in: aClass) ]initialize  super initialize.  matchers := OrderedCollection new